[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nconst int N=100005;\nint n,size[N],st[N],to[N];\nstruct note{\n\tlong long dis;\n\tint x;\n}d[N];\nbool cmp(note x,note y){\n\treturn x.dis>y.dis;\n}\nusing std::map;\nmap<long long,int> m;\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor (int i=1;i<=n;i++) {\n\t\tscanf(\"%lld\",&d[i].dis);\n\t\td[i].x=i;\n\t\tm[d[i].dis]=i;\n\t}\n\tstd::sort(d+1,d+n+1,cmp);\n\tfor (int i=1;i<=n;i++) size[i]=1;\n\tfor (int i=1;i<n;i++){\n\t\tlong long dis=d[i].dis;\n\t\tint x=d[i].x;\n\t\tlong long t=dis-abs(n-2*size[x]);\n\t\t//if (t<0){\n\t\t//\tputs(\"-1\");\n\t\t//\treturn 0;\n\t\t//}\n\t\tint fa=m.find(t)->second;\n\t\tif (fa==x || !fa){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsize[fa]+=size[x];\n\t\tst[i]=x,to[i]=fa;\n\t}\n\t\n\tfor (int i=1;i<n;i++) printf(\"%lld %lld\\n\",st[i],to[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXn = 1e5 + 10;\ntypedef pair<long long, int> pii;\npii ar[MAXn];\nlong long n, sz[MAXn], root, disroot, d[MAXn], hp3[MAXn];\nvector<int> vec[MAXn];\nvector<pii> ans;\n\nbool cmp(pii p1, pii p2) {\n\treturn p1.first > p2.first;\n}\n\nlong long dfs1(int v, int  par) {\n\tlong long res = 0;\n\tfor (int i = 0; i < vec[v].size(); i++)\n\t\tif (vec[v][i] != par) {\n\t\t\tres += dfs1(vec[v][i], v) + hp3[vec[v][i]];\n\t\t\thp3[v] += hp3[vec[v][i]];\n\t\t}\n\thp3[v]++;\n\treturn res;\n\t\n}\n\nvoid dfs2(int v, int par, int sth) {\n\tif (sth != d[v]) {\n\t\tcout << -1;\n\t\texit(0);\n\t}\n\tfor (int i = 0; i < vec[v].size(); i++) {\n\t\tif (vec[v][i] != par) {\n\t\t\tdfs2(vec[v][i], v, sth - (hp3[vec[v][i]]) + (hp3[0] - hp3[vec[v][i]]));\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}\nint main() {\n\tcin >> n;\n\tfill_n(sz, MAXn, 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tint di;\n\t\tcin >> di;\n\t\td[i] = di;\n\t\tar[i].first = di;\n\t\tar[i].second = i;\n\t}\n\tsort(ar, ar + n);\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tlong long hp = ar[i].first - n;\n\t\thp += 2 * sz[i];\n\t\tint hp2 = lower_bound(ar, ar + n, pii(hp, -1)) - ar;\n\t\tif (ar[hp2].first != hp)\n\t\t\treturn cout << -1,0;\n\t\tsz[hp2]+= sz[i];\n\t\tvec[ar[hp2].second].push_back(ar[i].second);\n\t\tvec[ar[i].second].push_back(ar[hp2].second);\n\t\tans.push_back(pii(ar[i].second, ar[hp2].second));\n\t}\n\tdisroot = dfs1(0, -1);\n\tdfs2(0, -1, disroot);\n\tfor (int i = 0; i < ans.size(); i++)\n\t\tcout << ans[i].first + 1<< ' ' << ans[i].second + 1<< endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,size[100010],fa[100010],tmp=0,cnt=0,s[100010],Un_f=0,head[100010],o=0,hd,dis[100010],si[100010];\nlong long d[100010],g[100010];\nmap<long long,int>ma;\nstruct node{\n\tlong long w;\n\tint id;\n\tbool operator <(const node &b)const{\n\t\treturn w<b.w;\n\t}\n};\nstruct edge{\n\tint to,link;\n}e[400010];\nvoid add_edge(int u,int v){\n\te[++o].to=v,e[o].link=head[u],head[u]=o;\n\te[++o].to=u,e[o].link=head[v],head[v]=o;\n}\npriority_queue<node>q;\nvoid dfs(int u,int pre){\n\tsi[u]=1;\n\tfor(int i=head[u];i;i=e[i].link){\n\t\tif(e[i].to==pre) continue;\n\t\tdis[e[i].to]=dis[u]+1;\n\t\tdfs(e[i].to,u);\n\t\tsi[e[i].to]+=si[u];\n\t}\n}\nvoid work(int u,int pre){\n\tif(g[u]!=d[u]){\n\t\tprintf(\"-1\\n\");\n\t\texit(0);\n\t}\n\tfor(int i=head[u];i;i=e[i].link){\n\t\tif(e[i].to==pre) continue;\n\t\tg[e[i].to]=g[u]+n-si[e[i].to]*2;\n\t\tdfs(e[i].to,u);\n\t}\n}\nint main(){\n\tma.clear();\n\twhile(q.size()) q.pop();\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&d[i]);\n\t\tma[d[i]]=i,size[i]=1;\n\t\tq.push((node){d[i],i});\n\t}\n\twhile(q.size()){\n\t\tnode now=q.top();q.pop();\n\t\tfa[now.id]=ma[d[now.id]+size[now.id]*2-n];\n\t\tsize[fa[now.id]]+=size[now.id];\n\t\tif(!q.size()) hd=now.id;\n\t}\n\tdfs(hd,0);\n\tfor(int i=1;i<=n;i++) g[hd]+=dis[i];\n\twork(hd,0);\n\tfor(int i=1;i<n;i++){\n\t\tif(!fa[i]) continue;\n\t\tprintf(\"%d %d\\n\",i,fa[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define fr first\n#define sc second\n\nconst ll dx[4] = { -1,1,0,0 };\nconst ll dy[4] = { 0,0,-1,1 };\nconst char c[4] = { 'R','L','U','D' };\n\nint main(){\n\tstatic ll n;\n\tstatic ll d[100010];\n\tscanf(\"%lld\",&n);\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tscanf(\"%lld\",&d[i]);\n\t}\n\t\n\tvector<P> vec;\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tvec.push_back(P(d[i],i));\n\t}\n\tsort(vec.begin(),vec.end());\n\treverse(vec.begin(),vec.end());\n\t\n\tstatic ll cnt[100010];\n\tstatic ll dp[100010];\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tcnt[i] = 1;\n\t\tdp[i] = 0;\n\t}\n\t\n\tmap<ll,ll> id;\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tid[d[i]] = i;\n\t}\n\t\n\tvector<P> ans;\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tP p = vec[i-1];\n\t\t//cout << p.fr << \" \" << p.sc << endl;\n\t\tif(cnt[p.sc]*2 >= n)continue;\n\t\tll nx = d[p.sc]-(n-cnt[p.sc])+cnt[p.sc];\n\t\tif(id.find(nx) == id.end()){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tans.push_back(P(p.sc,id[nx]));\n\t\t\tcnt[id[nx]] += cnt[p.sc];\n\t\t\tdp[id[nx]] += dp[p.sc];\n\t\t\tdp[id[nx]] += cnt[p.sc];\n\t\t}\n\t}\n\tif(n%2 == 0){\n\t\tif(vec[n-2].fr != vec[n-1].fr){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tans.push_back(P(vec[n-2].sc,vec[n-1].sc));\n\t\tif(vec[n-1].fr != dp[vec[n-1].sc]+dp[vec[n-2].sc]+n/2){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse {\n\t\tif(vec[n-1].fr != dp[vec[n-1].sc]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\t/*for(int i = 1 ; i <= n ; i ++){\n\t\tif(dp[i] != d[i]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}*/\n\t\n\tif(ans.size() < n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i = 0 ; i < ans.size() ; i ++){\n\t\tprintf(\"%d %d\\n\",ans[i].fr,ans[i].sc);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\nstruct var{\n\tint fr,to,nxt;\n}edge[101001];\nint n,size[101001],cnt,head[101001];\nLL d[101001],dis[101001];\nmap<LL,int>num;\nvoid add(int u,int v)\n{\n\tcnt++;\n\tedge[cnt].to=v;\n\tedge[cnt].fr=u;\n\tedge[cnt].nxt=head[u];\n\thead[u]=cnt;\n}\nvoid dfs(int o,int f)\n{\n\tfor(int i=head[o];i;i=edge[i].nxt)\n\t{\n\t\tint v=edge[i].to;\n\t\tif(v==f)continue;\n\t\tdis[v]=dis[o]+1;\n\t\tdfs(v,o);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&d[i]);\n\t\tnum[d[i]]=i;\n\t\tsize[i]=1;\n\t}\n\tsort(d+1,d+n+1);\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tint u=num[d[i]];\n\t\tLL tmp=n-2*size[u],f=d[i]-tmp;\n\t\tif(tmp<0)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tif(!num.count(f))\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint x=num[f];\n\t\tadd(x,u);\n\t\tsize[x]+=size[u];\n\t}\n\tdfs(num[d[1]],0);\n\tLL sum=0;\n\tfor(int i=1;i<=n;i++)sum+=dis[i];\n\tif(sum!=d[1])\n\t{\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=cnt;i++)\n\t{\n\t\tprintf(\"%d %d\\n\",edge[i].fr,edge[i].to);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<functional>\n#include<cmath>\n#include<vector>\n#include<map>\n//using namespace std;\nusing std::min;\nusing std::max;\nusing std::swap;\nusing std::sort;\nusing std::reverse;\nusing std::random_shuffle;\nusing std::lower_bound;\nusing std::upper_bound;\nusing std::unique;\nusing std::vector;\nusing std::map;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef std::pair<int,int> pii;\ntypedef std::pair<ll,ll> pll;\nvoid open(const char *s){\n#ifndef ONLINE_JUDGE\n\tchar str[100];sprintf(str,\"%s.in\",s);freopen(str,\"r\",stdin);sprintf(str,\"%s.out\",s);freopen(str,\"w\",stdout);\n#endif\n}\nvoid open2(const char *s){\n#ifdef DEBUG\n\tchar str[100];sprintf(str,\"%s.in\",s);freopen(str,\"r\",stdin);sprintf(str,\"%s.out\",s);freopen(str,\"w\",stdout);\n#endif\n}\nint rd(){int s=0,c,b=0;while(((c=getchar())<'0'||c>'9')&&c!='-');if(c=='-'){c=getchar();b=1;}do{s=s*10+c-'0';}while((c=getchar())>='0'&&c<='9');return b?-s:s;}\nvoid put(int x){if(!x){putchar('0');return;}static int c[20];int t=0;while(x){c[++t]=x%10;x/=10;}while(t)putchar(c[t--]+'0');}\nint upmin(int &a,int b){if(b<a){a=b;return 1;}return 0;}\nint upmax(int &a,int b){if(b>a){a=b;return 1;}return 0;}\nconst int N=100010;\nvoid failed()\n{\n\tprintf(\"-1\\n\");\n\texit(0);\n}\nmap<ll,int> mp;\npll a[N];\nint s[N];\nll d[N];\nint n;\nint b[N];\nvector<int> g[N];\nvector<pii> ans;\nint sz[N];\nll f[N];\nll h[N];\nvoid dfs(int x,int fa)\n{\n\tsz[x]=1;\n\tfor(auto v:g[x])\n\t{\n\t\tdfs(v,x);\n\t\tsz[x]+=sz[v];\n\t\tf[x]+=f[v]+sz[v];\n\t}\n}\nvoid dfs2(int x,int fa)\n{\n\tfor(auto v:g[x])\n\t{\n\t\th[v]=h[x]+(n-sz[v])-sz[v];\n\t\tdfs2(v,fa);\n\t}\n}\nint main()\n{\n\topen2(\"f\");\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&d[i]);\n\t\ts[i]=1;\n\t\ta[i]=pll(d[i],i);\n\t\tmp[d[i]]=i;\n\t}\n\tsort(a+1,a+n+1,std::greater<pll>());\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x=a[i].second;\n\t\tint fa=mp[d[x]-(n-s[x])+s[x]];\n\t\tif(!fa||b[fa])\n\t\t\tfailed();\n\t\tg[fa].push_back(x);\n\t\tans.push_back(pii(fa,x));\n\t\ts[fa]+=s[x];\n\t\tb[x]=1;\n\t}\n\tint rt=a[n].second;\n\tdfs(rt,0);\n\th[rt]=f[rt];\n\tdfs2(rt,0);\n\tfor(int i=1;i<=n;i++)\n\t\tif(h[i]!=d[i])\n\t\t\tfailed();\n\tfor(auto v:ans)\n\t\tprintf(\"%d %d\\n\",v.first,v.second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef vector<int> vi;\ntypedef map<ll, pii> mlp;\n\npli dfs1(vi e[], int x) {\n    pli ret = pli(0, 1);\n    for (int i : e[x]) {\n        pli t = dfs1(e, i);\n        ret.first += t.first + t.second;\n        ret.second += t.second;\n    }\n    return ret;\n}\n\nvoid dfs2(vi e[], int x) {\n    for (int i : e[x]) {\n        cout << x + 1 << \" \" << i + 1 << endl;\n        dfs2(e, i);\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    mlp dic;\n    for (int i = 0; i < n; i++) {\n        ll d;\n        cin >> d;\n        dic[d] = pii(i, 1);\n    }\n\n    vi e[n];\n    bool f = true;\n    for (auto it = dic.rbegin(); it != prev(dic.rend()); it++) {\n        ll t = it->first - n + 2 * it->second.second;\n        if (t >= it->first || !dic.count(t)) {\n            f = false;\n            break;\n        }\n        \n        e[dic[t].first].push_back(it->second.first);\n        dic[t].second += it->second.second;\n    }\n    \n    f &= dfs1(e, dic.begin()->second.first).first == dic.begin()->first;\n\n    if (!f) {\n        cout << -1 << endl;\n    } else {\n        dfs2(e, dic.begin()->second.first);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#include <queue>\n#include <vector>\n#define PB push_back\n#define MP make_pair\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=1e5+10;\nstruct node {\n\tint id; ll d;\n\tnode(int id=0,ll d=0): id(id),d(d) {}\n\tfriend bool operator <(node A,node B) { return A.d<B.d; }\n};\npriority_queue<node> que;\nmap<ll,int> mp;\nint n,sz[N];\nll d[N];\nvector< pair<int,int> > E;\nvector<int> son[N];\nll dfs(int u) {\n\tll tot=0;\n\tfor(int i=0;i<son[u].size();++i) tot+=dfs(son[u][i])+sz[u];\n\treturn tot;\n}\nint main() {\n\trd(n);\n\tfor(int i=1;i<=n;++i) {\n\t\trd(d[i]),mp[d[i]]=i;\n\t\tque.push(node(i,d[i]));\n\t\tsz[i]=1;\n\t}\n\twhile(que.size()>1) {\n\t\tint u=que.top().id; que.pop();\n\t\tmp.erase(d[u]);\n\t\tll t=d[u]-(n-sz[u]*2ll);\n\t\tif(!mp.count(t)) {\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint f=mp[t];\n\t\tE.PB(MP(f,u));\n\t\tson[f].PB(u);\n\t\tsz[f]+=sz[u];\n\t}\n\tint rt=que.top().id;\n\tif(dfs(rt)!=d[rt]) {\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<E.size();++i) printf(\"%d %d\\n\",E[i].first,E[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN=3e5+7;\n\nll from[MAXN],to[MAXN];\n\nmap<ll,ll> Map;\n\nll n;\nll a[MAXN],b[MAXN],siz[MAXN];\n\nbool cmp(const ll &A,const ll &B){return a[A]>a[B];}\nbool cmp2(const ll &A,const ll &B){return A>B;}\n\nint main() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) {\n\t\tcin>>a[i];\n\t\tb[i]=i;\n\t\tMap[a[i]]=i;\n\t\tsiz[i]=1;\n\t}\n\tsort(b+1,b+1+n,cmp);\n\tsort(a+1,a+1+n,cmp2);\n\tfor(ll i=1,i2;i<n;i++) {\n\t\ti2=Map[a[i]-(n-2*siz[b[i]])];\n\t\tif(i2!=0&&a[i]-(n-2*siz[b[i]])>a[i]) {\n\t\t\tsiz[i2]+=siz[b[i]];\n\t\t\tfrom[i]=i2;\n\t\t\tto[i]=b[i];\n\t\t}\n\t\telse {\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++) {\n\t\tcout<<from[i]<<\" \"<<to[i]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nconst long long mo=50000007;\nconst int maxn=200010;\n\nint n,m,d[maxn],id[maxn],fa[maxn];\nlong long siz[maxn],ans,js[maxn];\nint tot,nex[maxn*2],las[maxn*2],tov[maxn*2];\nint hs[mo];\n\nvoid con(int x,int y)\n{\n\ttot++;\n\ttov[tot]=y;\n\tnex[tot]=las[x];\n\tlas[x]=tot;\n}\n\nvoid insert(long long x,int id)\n{\n\tlong long i=x%mo;\n\twhile (hs[i]!=0)\n\t{\n\t\ti++;\n\t\tif (i==mo) i=0;\n\t}\n\ths[i]=id;\n}\n\nint find(long long x)\n{\n\tlong long i=x%mo;\n\twhile (hs[i]!=0 && d[hs[i]]!=x)\n\t{\n\t\ti++;\n\t\tif (i==mo) i=0;\n\t}\n\treturn hs[i];\n}\n\nvoid qsort(int l,int r)\n{\n\tint i=l;int j=r;\n\tlong long m=d[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (d[i]>m) i++;\n\t\twhile (d[j]<m) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(d[i],d[j]);\n\t\t\tswap(id[i],id[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort(l,j);\n\tif (r>i) qsort(i,r); \n}\n\nvoid dfs(int x,int ff)\n{\n\tjs[x]=js[ff]+1;\n\tfor (int i=las[x];i;i=nex[i])\n\t{\n\t\tif (tov[i]!=ff)\n\t\t{\n\t\t\tdfs(tov[i],x);\n\t\t\tans+=js[x];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&d[i]);\n\t\tid[i]=i;\n\t\tsiz[i]=1;\n\t}\n\tqsort(1,n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinsert(d[i],i);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tlong long op=d[i]-abs(n-2*siz[i]);\n\t\tlong long oq=find(op);\n\t\tif (oq==0)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfa[i]=oq;\n\t\t\tsiz[oq]+=siz[i];\n\t\t\tcon(i,oq);con(oq,i);\n\t\t}\n\t}\n\tdfs(n,0);\n\tif (ans!=d[n])\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tfor (int i=1;i<n;i++)\n\t\t{\n\t\t\tprintf(\"%d %d\\n\",id[i],id[fa[i]]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reg register\n#define maxn 200001\ninline int  read() {\n    reg int s = 0, t = 0; reg char ch = getchar();\n    while(ch > '9' || ch < '0') t |= ch == '-', ch = getchar();\n    while(ch >= '0' && ch <= '9') s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();\n    return t ? -s : s;\n}\nusing namespace std;\nmap<int, int> mp;\nint D[maxn],a[maxn], b[maxn], cnt, n, sum[maxn];\nint main()\n{\n\tn = read();\n\tfor(int i = 1; i <= n; i++) D[i] = read(), mp[D[i]] = i;\n\tsort(D + 1, D + n + 1);\n\tfor(int i = n; i > 1; i--){\n\t\tsum[mp[D[i]]]++;\n\t\tint x = D[i] - abs(n - sum[mp[D[i]]] * 2);\n\t\tif(!mp[x] || x == D[i]) {printf(\"-1\\n\"); return 0;}\n\t\ta[++cnt] = mp[D[i]], b[cnt] = mp[x]; sum[mp[x]] += sum[mp[D[i]]];\n\t}\n\tfor(int i = 1; i < n; i++)\n\tprintf(\"%d %d\\n\", a[i], b[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> T gi() {\n\tT x = 0; bool f = 0; char c = getchar();\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar();\n\tif (c == '-') f = 1, c = getchar();\n\twhile (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn f ? -x : x;\n}\nconst int N = 1e5 + 10;\nint p[N], siz[N], X[N], Y[N], fa[N];\nint find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\nLL D[N];\nmap<LL, int> M;\nvector<int> e[N];\nbool cmp(int x, int y) { return D[x] > D[y]; }\nLL res;\nvoid dfs(int u, int ff) {\n\tsiz[u] = 1;\n\tfor (auto v : e[u])\n\t\tif (v != ff) {\n\t\t\tdfs(v, u);\n\t\t\tres += siz[v];\n\t\t\tsiz[u] += siz[v];\n\t\t}\n}\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n = gi<int>();\n\tfor (int i = 1; i <= n; i++)\n\t\tD[i] = gi<LL>(), M[D[i]] = i, p[i] = i;\n\tsort(p + 1, p + 1 + n, cmp);\n\tfor (int i = 1; i <= n; i++) siz[i] = 1, fa[i] = i;\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x = p[i];\t\t\n\t\tif (M.find(D[x] - n + 2 * siz[x]) == M.end()) continue;\n\t\tint y = M[D[x] - n + 2 * siz[x]];\n\t\tif (find(x) == find(y)) continue;\n\t\tfa[find(y)] = find(x);\n\t\tsiz[y] += siz[x]; X[++cnt] = x; Y[cnt] = y;\n\t\te[x].push_back(y); e[y].push_back(x);\n\t}\n\tdfs(1, 0);\n\tif (cnt < n - 1 || res != D[1])\n\t\tputs(\"-1\");\n\telse\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tprintf(\"%d %d\\n\", X[i], Y[i]);\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nll D[101010];\npair<ll,int> P[101010];\nint num[101010],par[101010];\nvector<pair<int,int>> E;\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>D[i];\n\t\tP[i]={D[i],i+1};\n\t}\n\tsort(P,P+N);\n\tsort(D,D+N);\n\t\n\tfor(i=N-1;i>=1;i--) {\n\t\tnum[i]++;\n\t\tll sj=D[i]+2*num[i]-N;\n\t\tx=lower_bound(D,D+N,sj)-D;\n\t\tif(x>=i || D[x]!=sj) return _P(\"-1\\n\");\n\t\tE.push_back({x,i});\n\t\tnum[x]+=num[i];\n\t\tpar[i]=x;\n\t}\n\t\n\tFORR(e,E) cout<<P[e.first].second<<\" \"<<P[e.second].second<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = pair<lint, int>;\nconst int MAXN = 100005;\n\nvoid my_ass(bool p){\n\tif(!p){\n\t\tputs(\"-1\");\n\t\texit(0);\n\t}\n}\n\nint n;\npi a[MAXN];\nvector<int> gph[MAXN];\nset<int> s[2];\nint left_size[MAXN];\n\nlint get_dist(int x, int p, int d){\n\tlint ret = d;\n\tfor(auto &i : gph[x]){\n\t\tif(i != p){\n\t\t\tret += get_dist(i, x, d + 1);\n\t\t}\n\t}\n\treturn ret;\n}\n\nvector<int> new_event[MAXN];\n\nvoid INSERT(int val, int atleast){\n\tlint v = n + a[val].first - 2 * left_size[val] + 2;\n\tint l = lower_bound(a + 1, a + n + 1, pi(v, -1)) - a;\n\tnew_event[max(l, atleast)].push_back(val);\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<=n; i++){\n\t\tscanf(\"%lld\",&a[i].first);\n\t\ta[i].second = i;\n\t}\n\tsort(a + 1, a + n + 1);\n\tleft_size[1] = n;\n\tINSERT(1, 2);\n\tfor(int i=2; i<=n; i++){\n\t\tfor(auto &j : new_event[i]){\n\t\t\ts[a[j].first % 2].insert(j);\n\t\t}\n\t\tint msk = (a[i].first % 2) ^ (n % 2);\n\t\tmy_ass(!s[msk].empty());\n\t\tmy_ass(a[i].first <= n + a[*s[msk].begin()].first - 2);\t\n\t\tint p = *s[msk].begin();\n\t\tgph[p].push_back(i);\n\t\tgph[i].push_back(p);\n\t\tleft_size[i] = n - (a[i].first - a[p].first);\n\t\tleft_size[i] /= 2;\n\t\tleft_size[p] -= left_size[i];\n\t\ts[msk].erase(p);\n\t\tif(left_size[p] != 1) INSERT(p, i + 1);\n\t\tif(left_size[i] != 1) INSERT(i, i + 1);\n\t}\n\tfor(int i=1; i<=n; i++){\n\t\tmy_ass(left_size[i] == 1);\n\t}\n\tfor(int i=1; i<=1; i++){\n\t\tmy_ass(get_dist(i, -1, 0) == a[i].first); \n\t}\n\tfor(int i=1; i<=n; i++){\n\t\tfor(auto &j : gph[i]){\n\t\t\tif(i < j) printf(\"%d %d\\n\", a[i].second, a[j].second);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 100005\n#define error {puts(\"-1\");return 0;}\n#define ll long long\nusing namespace std;\n\nmap <ll,int> mp;\n\nstruct edge{\n\tint to,nxt;\n}e[maxn<<1];\n\nstruct node{\n\tll dis;int id;\n\tbool operator < (const node &A) const {return dis>A.dis;}\n}a[maxn];\n\nstruct uv{\n\tint u,v;\n\tbool operator < (const uv &A) const {return u==A.u?v<A.v:u<A.u;}\n}ans[maxn];\n\nint cnt,head[maxn],dis[maxn],size[maxn],n;\n\nvoid add(int u,int v){\n\te[++cnt]=(edge){v,head[u]};\n\thead[u]=cnt;\n}\n\nvoid dfs(int u,int fa,int dep){\n\tdis[a[n].id]+=dep;size[u]=1;\n\tfor(int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif(v==fa) continue;\n\t\tdfs(v,u,dep+1);\n\t\tsize[u]+=size[v];\n\t}\n}\n\nvoid dfs(int u,int fa){\n\tfor(int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif(v==fa) continue;\n\t\tdis[v]=dis[u]+n-size[v]*2;\n\t\tdfs(v,u);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i].dis);\n\t\ta[i].id=i;\n\t\tmp[a[i].dis]=i;\n\t}\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++) size[i]=1;\n\tfor(int i=1;i<n;i++){\n\t\tint u=a[i].id;\n\t\tll tmp=n-size[u]*2;\n\t\tif(tmp<=0||!mp.count(a[i].dis-tmp)) error\n\t\tint fa=mp[a[i].dis-tmp];\n\t\tsize[fa]+=size[u];\n\t\tadd(u,fa);add(fa,u);\n\t\tans[i].u=min(u,fa);\n\t\tans[i].v=max(u,fa);\n\t}\n\tsort(ans+1,ans+n);\n\tdfs(a[n].id,0,0);\n\tdfs(a[n].id,0);\n\tfor(int i=1;i<=n;i++) if(dis[a[i].id]!=a[i].dis) error\n\tfor(int i=1;i<n;i++) printf(\"%d %d\\n\",ans[i].u,ans[i].v);\n}"
  },
  {
    "language": "C++",
    "code": "//Keep pluggin',this is your only outlet.\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<cctype>\n#include<queue>\n#include<map>\n#define MM(x,y) memset(x,y,sizeof(x))\n#define MCPY(a,b) memcpy(a,b,sizeof(b))\n#define pb push_back\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,b,a) for(int i=b;i>=a;i--)\n#define fi first\n#define mp make_pair\n#define se second\nusing namespace std;\n#define int long long\n\ninline int quickpow(int m,int n,int p){int b=1;while(n){if(n&1)b=b*m%p;n=n>>1;m=m*m%p;}return b;}\ninline int quickmul(int x,int y,int mod){return (x*y-(int)((long double)x/mod*y)*mod+mod)%mod;}\ninline int getinv(int x,int p){return quickpow(x,p-2,p);}\ninline int read(void){\n    int x=0,f=1;char ch=getchar();\n    while(!isdigit(ch)){f=ch=='-'?-1:1;ch=getchar();}\n    while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n    return x * f;\n}\n#define GG return puts(\"-1\"),0\nconst int MAXN = 1e5 + 100;\nstruct Node{\n    int x,y;\n    bool operator < (const Node &b) const {\n        return x > b.x;\n    }\n}a[MAXN];\nstruct Edges{\n    int u,to,nxt;\n}E[MAXN<<1];\nint head[MAXN],cnt = 0,n,dep[MAXN],fa[MAXN],sz[MAXN],dis[MAXN];\nmap<int,int>id;\ninline void addedge(int u,int v){\n    E[++cnt].to = v; E[cnt].u = u;E[cnt].nxt = head[u]; head[u] = cnt;\n}\n\ninline void dfs1(int u,int fa,int root){\n    dis[root] += dep[u];\n    for (int i = head[u]; i; i = E[i].nxt) {\n        int v = E[i].to;\n        if (v == fa) continue;\n        dep[v] = dep[u] + 1;\n        dfs1(v,u,root);\n    }\n}\n\ninline void dfs2(int u,int fa){\n    for (int i = head[u]; i; i = E[i].nxt) {\n        int v = E[i].to;\n        if (v == fa) continue;\n        dis[v] = dis[u] - (sz[v] << 1) + n;\n        dfs2(v,u);\n    }\n}\n\n///------------------head------------------\nsigned main(signed argc, char *argv[]){\n    n = read();\n    for (int i = 1; i <= n; ++i) {\n        a[i].x = read(); sz[i] = 1;\n        a[i].y = i; id[a[i].x] = i;\n    }\n    sort(a+1,a+n+1);\n    for (int i = 1; i < n; ++i) {\n        int u = a[i].y,tofind = a[i].x + 2 * sz[a[i].y] - n;\n        if (!id.count(tofind)) GG;\n        if (n <= 2 * sz[u]) GG;\n        fa[u] = id[tofind];\n        sz[fa[u]] += sz[u];\n        addedge(u,fa[u]);\n        addedge(fa[u],u);\n    }\n    dep[a[n].y] = 0;\n    dfs1(a[n].y,0,a[n].y);\n    dfs2(a[n].y,0);\n    for (int i = 1; i <= n; ++i) if (a[i].x != dis[a[i].y]) GG;\n    for (int i = 1; i <= cnt; ++i) {\n        if (E[i].u < E[i].to) printf(\"%lld %lld\\n\",E[i].u,E[i].to);\n    }\n    return 0;\n}\n\n/* Examples: */\n/*\n\n*/\n\n/*\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid err() {\n  cout << -1 << endl;\n  exit(0);\n}\nvoid dfs (int crr, int dpt, vector<vector<int>>& grh, long long& cnt) {\n  cnt += dpt;\n  for (int nxt : grh[crr]) {\n    dfs(nxt, dpt + 1, grh, cnt);\n  }\n}\nint main() {\n  int n;\n  cin >> n;\n  vector<long long> d(n);\n  map<long long, int> mp;\n  for (int i = 0; i < n; i++) {\n    cin >> d[i];\n    mp[d[i]] = i;\n  }\n  sort(d.begin(), d.end());\n  vector<long long> sz(n, 1);\n  vector<vector<int>> grh(n);\n  for (auto it = d.rbegin(); next(it) != d.rend(); it++) {\n    auto i = mp.rbegin()->second;\n    long long wnt = *it - n + 2 * sz[i];\n    if (mp.find(wnt) == mp.end()) err();\n    auto p = mp[wnt];\n    grh[p].push_back(i);\n    sz[p] += sz[i];\n    mp.erase(--mp.end());\n  }\n  long long cnt = 0;\n  int rt = mp[d[0]];\n  dfs(rt, 0, grh, cnt);\n  if (d[0] != cnt) err();\n  for (int crr = 0; crr < n; crr++) {\n    for (int nxt : grh[crr]) {\n      cout << crr + 1 << ' ' << nxt + 1 << endl;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nconst int N = 100005;\n\nlong long n;\npair <long long, long long> p[N];\n\nvector < pair<long long, long long> > answ;\n\nlong long order[N];\n\nset < pair<long long, long long> > odd, even;\nset < pair<long long, long long> >::iterator it , it1;\nqueue < pair<long long, long long> > q;\n\nint main() {\n\tcin >> n;\n\tfor (long long i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &p[i].first);\n\t\tp[i].second = i;\n\t\tif (p[i].first % 2)\n\t\t\todd.insert(p[i]);\n\t\telse\n\t\t\teven.insert(p[i]);\n\t}\n\t///\n\tsort(p + 1, p + n + 1);\n\t///\n\tq.push(p[1]);\n\torder[p[1].second] = n - 1;\n\tif (p[1].first % 2)\n\t\todd.erase(p[1]);\n\telse\n\t\teven.erase(p[1]);\n\twhile (!q.empty()) {\n\t\tpair<long long,long long> P = q.front();\n\t\tlong long v = P.second;\n\t\tlong long d = P.first;\n\t\tq.pop();\n\t\tif (n % 2 == 0) {\n\t\t\tif (d % 2 == 0) {\n\t\t\t\tlong long sum = order[v];\n\t\t\t\tif ((int)even.size() == 0) {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tit = even.upper_bound(make_pair(d + n - 2, 1000 * 1000 * 1000));\n\t\t\t\tif (it == even.begin()) {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t--it;\n\t\t\t\twhile (sum > 0) {\n\t\t\t\t\tif (sum >= 1 + (n - 2 - ((*it).first - d)) / 2) {\n\t\t\t\t\t\tsum -= 1 + (n - 2 - ((*it).first - d)) / 2;\n\t\t\t\t\t\tlong long to = (*it).second;\n\t\t\t\t\t\torder[to] = (n - 2 - ((*it).first - d)) / 2;\n\t\t\t\t\t\tif (order[to] != 0) {\n\t\t\t\t\t\t\tq.push(*it);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tansw.push_back(make_pair(v, (*it).second));\n\t\t\t\t\t\tit1 = it;\n\t\t\t\t\t\t--it1;\n\t\t\t\t\t\teven.erase(it);\n\t\t\t\t\t\t++it1;\n\t\t\t\t\t\tit = it1;\n\t\t\t\t\t}\n\t\t\t\t\tif (it == even.begin())break;\n\t\t\t\t\t--it;\n\t\t\t\t}\n\t\t\t\tif (sum != 0) {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong long sum = order[v];\n\t\t\t\tif ((int)odd.size() == 0) {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tit = odd.upper_bound(make_pair(d + n - 2, 1000 * 1000 * 1000));\n\t\t\t\tif (it == odd.begin()) {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t--it;\n\t\t\t\twhile (sum > 0) {\n\t\t\t\t\tif (sum >= 1 + (n - 2 - ((*it).first - d)) / 2) {\n\t\t\t\t\t\tsum -= 1 + (n - 2 - ((*it).first - d)) / 2;\n\t\t\t\t\t\tlong long to = (*it).second;\n\t\t\t\t\t\torder[to] = (n - 2 - ((*it).first - d)) / 2;\n\t\t\t\t\t\tif (order[to] != 0) {\n\t\t\t\t\t\t\tq.push(*it);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tansw.push_back(make_pair(v, (*it).second));\n\t\t\t\t\t\tit1 = it;\n\t\t\t\t\t\t--it1;\n\t\t\t\t\t\todd.erase(it);\n\t\t\t\t\t\t++it1;\n\t\t\t\t\t\tit = it1;\n\t\t\t\t\t}\n\t\t\t\t\tif (it == odd.begin())break;\n\t\t\t\t\t--it;\n\t\t\t\t}\n\t\t\t\tif (sum != 0) {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (d % 2 == 0) {\n\t\t\t\tlong long sum = order[v];\n\t\t\t\tif ((int)odd.size() == 0) {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tit = odd.upper_bound(make_pair(d + n - 2, 1000 * 1000 * 1000));\n\t\t\t\tif (it == odd.begin()) {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t--it;\n\t\t\t\twhile (sum > 0) {\n\t\t\t\t\tif (sum >= 1 + (n - 2 - ((*it).first - d)) / 2) {\n\t\t\t\t\t\tsum -= 1 + (n - 2 - ((*it).first - d)) / 2;\n\t\t\t\t\t\tlong long to = (*it).second;\n\t\t\t\t\t\torder[to] = (n - 2 - ((*it).first - d)) / 2;\n\t\t\t\t\t\tif (order[to] != 0) {\n\t\t\t\t\t\t\tq.push(*it);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tansw.push_back(make_pair(v, (*it).second));\n\t\t\t\t\t\tit1 = it;\n\t\t\t\t\t\t--it1;\n\t\t\t\t\t\todd.erase(it);\n\t\t\t\t\t\t++it1;\n\t\t\t\t\t\tit = it1;\n\t\t\t\t\t}\n\t\t\t\t\tif (it == odd.begin())break;\n\t\t\t\t\t--it;\n\t\t\t\t}\n\t\t\t\tif (sum != 0) {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong long sum = order[v];\n\t\t\t\tif ((int)even.size() == 0) {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tit = even.upper_bound(make_pair(d + n - 2, 1000 * 1000 * 1000));\n\t\t\t\tif (it == even.begin()) {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\t--it;\n\t\t\t\twhile (sum > 0) {\n\t\t\t\t\tif (sum >= 1 + (n - 2 - ((*it).first - d)) / 2) {\n\t\t\t\t\t\tsum -= 1 + (n - 2 - ((*it).first - d)) / 2;\n\t\t\t\t\t\tlong long to = (*it).second;\n\t\t\t\t\t\torder[to] = (n - 2 - ((*it).first - d)) / 2;\n\t\t\t\t\t\tif (order[to] != 0) {\n\t\t\t\t\t\t\tq.push(*it);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tansw.push_back(make_pair(v, (*it).second));\n\t\t\t\t\t\tit1 = it;\n\t\t\t\t\t\t--it1;\n\t\t\t\t\t\teven.erase(it);\n\t\t\t\t\t\t++it1;\n\t\t\t\t\t\tit = it1;\n\t\t\t\t\t}\n\t\t\t\t\tif (it == even.begin())break;\n\t\t\t\t\t--it;\n\t\t\t\t}\n\t\t\t\tif (sum != 0) {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < (int)answ.size(); i++) {\n\t\tcout << answ[i].first << \" \" << answ[i].second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 100005\n#define error {puts(\"-1\");return 0;}\n#define ll long long\nusing namespace std;\n\nmap <ll,int> mp;\n\nstruct edge{\n\tint to,nxt;\n}e[maxn<<1];\n\nstruct node{\n\tll dis;int id;\n\tbool operator < (const node &A) const {return dis>A.dis;}\n}a[maxn];\n\nstruct uv{\n\tint u,v;\n\tbool operator < (const uv &A) const {return u==A.u?v<A.v:u<A.u;}\n}ans[maxn];\n\nint cnt,head[maxn],n;ll dis[maxn],size[maxn];\n\nvoid add(int u,int v){\n\te[++cnt]=(edge){v,head[u]};\n\thead[u]=cnt;\n}\n\nvoid dfs(int u,int fa,int dep){\n\tdis[a[n].id]+=dep;size[u]=1;\n\tfor(int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif(v==fa) continue;\n\t\tdfs(v,u,dep+1);\n\t\tsize[u]+=size[v];\n\t}\n}\n\nvoid dfs(int u,int fa){\n\tfor(int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif(v==fa) continue;\n\t\tdis[v]=dis[u]+n-size[v]*2;\n\t\tdfs(v,u);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i].dis);\n\t\ta[i].id=i;\n\t\tmp[a[i].dis]=i;\n\t}\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++) size[i]=1;\n\tfor(int i=1;i<n;i++){\n\t\tint u=a[i].id;\n\t\tll tmp=n-size[u]*2;\n\t\tif(tmp<=0||!mp.count(a[i].dis-tmp)) error\n\t\tint fa=mp[a[i].dis-tmp];\n\t\tsize[fa]+=size[u];\n\t\tadd(u,fa);add(fa,u);\n\t\tans[i].u=min(u,fa);\n\t\tans[i].v=max(u,fa);\n\t}\n\tsort(ans+1,ans+n);\n\tdfs(a[n].id,0,0);\n\tdfs(a[n].id,0);\n\tfor(int i=1;i<=n;i++) if(dis[a[i].id]!=a[i].dis) error\n\tfor(int i=1;i<n;i++) printf(\"%d %d\\n\",ans[i].u,ans[i].v);\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nnamespace IO\n{\n\tchar buf[1 << 20 | 1] , *f1 = buf , *f2 = buf , pbuf[1 << 24 | 1] , *f3 = pbuf , sta[100];\n\t#define gc() ((f1 == f2) && (f2 = (f1 = buf) + fread(buf,1,sizeof buf,stdin),f1 == f2) ? EOF : *f1 ++)\n\t#define gt() getchar()\n\tinline int read()\n\t{\n\t\tint x = 0 , f = 1; char ch = gt();\n\t\twhile(ch < '0' || ch > '9')\t{if(ch == '-')\tf = -1; ch = gt();}\n\t\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = gt();}\n\t\treturn x * f;\n\t}\n\ttemplate <class T> inline void write(T x)\n\t{\n\t\tif(!x) return (void)(*f3 ++ = 48 , *f3 ++ = ' ');\n\t\tif(x < 0) *f3 ++ = '-' , x = ~x + 1;\n\t\tchar *top = sta;\n\t\twhile(x) *top ++ = x % 10 + 48 , x /= 10;\n\t\twhile(top != sta) *f3 ++ = *-- top;\n\t\t*f3 ++ = ' ';\n\t}\n\tinline void put(std::string s)\n\t{\n\t\tint len = s.length();\n\t\tfor(int i = 0;i < len;i ++) *f3 ++ = s[i];\n\t\t*f3 ++ = ' ';\n\t}\n\tinline void endline() { *f3 ++ = '\\n';}\n\t#define flush() fwrite(pbuf,1,f3 - pbuf,stdout)\n\ttemplate <class T> inline T abs(T a) { return a < 0 ? -a : a;}\n\ttemplate <class T> inline T max(T a,T b) { return a > b ? a : b;}\n\ttemplate <class T> inline T min(T a,T b) { return a < b ? a : b;}\n\ttemplate <class T> inline void swap(T &a,T &b) { T t = a; a = b; b = t;}\n}\nusing namespace IO;\nconst int N = 1e5 + 5;\nint n , cnt;\nint size[N] , u[N] , v[N];\nll dis;\nll D[N];\nstruct node\n{\n\tll d; int id;\n\tnode(ll d = 0,int id = 0) : d(d) , id(id) {}\n\tfriend bool operator < (const node &a,const node &b) { return a.d < b.d;}\n} e[N];\nint main()\n{\n\tn = read();\n\tfor(int i = 1;i <= n;i ++) e[i] = node(read(),i) , size[i] = 1;\n\tstd::sort(e + 1,e + 1 + n);\n\tfor(int i = n;i > 1;i --)\n\t{\n\t\tll dfa = e[i].d + 2 * size[i] - n;\n\t\tint j = std::lower_bound(e + 1,e + 1 + n,node(dfa)) - e;\n\t\tif(e[j].d != dfa) return puts(\"-1\") , 0;\n\t\tu[++ cnt] = i; v[cnt] = j;\n\t\tsize[j] += size[i];\n\t\tdis += size[i];\n\t}\n\tif(dis != e[1].d) return puts(\"-1\") , 0;\n\telse for(int i = 1;i <= cnt;i ++) printf(\"%d %d\\n\",u[i],v[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define forab(i, a, b) for(int i=(a);i<(b);++i)\n#define foreach(i, n) for (__typeof(n.begin()) i = n.begin(); i != n.end(); ++i)\n#define sqr(x) ((x)*(x))\n#define clr(a, b) memset(a, b, sizeof(a))\n#define MP make_pair\n#define PB push_back\n#define SZ(a) ((int)a.size())\n#define all(a) (a).begin(),(a).end()\n#define inf 0x3f3f3f3f\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst double eps = 1e-8;\nint dcmp(double x) { if (x < -eps) return -1; else return x > eps;}\n#define se(x) cout<<#x<<\" = \"<<x<<endl\n\n#ifdef CHEN_PC\n#define debug(...) printf(__VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\nconst int N = 100010;\nconst int mod = 1000000007; // 10^9+7\nint n;\nll d[N];\nint pnt[N];\nint cnt[N];\nmap<ll, int> dic;\n\nint solve() {\n    dic.clear();\n\tsort(d, d + n);\n\tforn (i, n) {\n\t\tpnt[i] = -1;\n\t\tcnt[i] = 1;\n\t\tdic[ d[i] ] = i;\n\t}\n\tll dd = 0;\n\tfor (int i = n - 1; i > 0; --i) {\n\t    dd += cnt[i];\n\t\tint delta = n - cnt[i] * 2;\n\t\tll val = d[i] - delta;\n\t\tif (delta == 0 || dic.find(val) == dic.end()) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tpnt[i] = dic[val];\n\t\tcnt[ pnt[i] ] += cnt[i];\n\t}\n//    debug(\"--- %d\\n\", dd);\n\tif (dd != d[0]) {\n\t    puts(\"-1\");\n\t    return 0;\n\t}\n\tforn (i, n) {\n\t\tif (pnt[i] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tprintf(\"%d %d\\n\", pnt[i] + 1, i + 1);\n\t}\n\treturn 1;\n}\n\nint main(int argc, char *argv[]) {\n#ifdef CHEN_PC\n\tfreopen(\"F.in\", \"r\", stdin);\n#endif\n\n\twhile (scanf(\"%d\", &n) != EOF) {\n\t\tforn (i, n) {\n\t\t\tscanf(\"%lld\", d + i);\n\t\t}\n\t\tint ret = solve();\n//\t\tprintf(\"%d\\n\", ret);\n\n#ifdef CHEN_PC\n        puts(\"\");\n#endif\n\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<long long, int> pli;\n\nconst int N = 1e5 + 10;\nint h[N], n, cnt[N], check, par[N];\nlong long d[N];\nvector<pli> di;\nvector<int> child[N];\nmap<long long, int> mp;\n\nvoid dfs(int v, int p){\n\th[v] = h[p] + 1;\n\tfor (int u : child[v])\n\t\tdfs(u, v);\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);cout.tie(0);\n\t\n\tcin >> n;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> d[i];\n\t\tdi.push_back({d[i], i});\n\t\tmp[d[i]] = i + 1;\n\t}\n\t\n\tsort(di.begin(), di.end());\n\treverse(di.begin(), di.end());\n\t\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[i] = 1;\n\tfor (int i = 0; i < n - 1; i++){\n\t\tint v = di[i].second,\n\t\t\tdis = di[i].first,\n\t\t\tpar_dis = dis + (2 * cnt[v]) - n;\n\t\t\n\t\tif(mp[par_dis] == 0)\n\t\t\treturn cout << -1, 0;\n\t\t\n\t\tint ver_par = mp[par_dis] - 1;\n\t\tcnt[ver_par] += cnt[v];\n\t\tpar[v] = ver_par;\n\t\tchild[par[v]].push_back(v);\n\t}\n\t\n\tint root = di[n - 1].second;\n\th[root] = -1;\n\tdfs(root, root);\n\t\n\tfor (int i = 0; i < n; i++)\n\t\tcheck += h[i];\n\t\n\tif(check != d[root])\n\t\treturn cout << -1, 0;\n\t\n\tfor (int i = 0; i < n; i++)\n\t\tif(par[i] != i)\n\t\t\tcout << par[i] + 1 << ' ' << i + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <stack>\n#include <queue>\n#include <list>\n#include <bitset>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <numeric>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <chrono>\n#include <random>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <functional>\n#include <sstream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<pair<int,int>> solve(vector<long long>& W) {\n        int n = W.size();\n        vector<pair<long long,int>> P;\n        for (int i = 0; i < n; ++i) {\n            P.emplace_back(W[i], i);\n        }\n        sort(P.begin(), P.end());\n\n\n        vector<long long> sums(n, 0);\n        vector<int> sizes(n, 1);\n        vector<int> pars(n, -1);\n\n        for (int i = n - 1; i > 0; --i) {\n            int u = P[i].second;\n            long long sum = P[i].first;\n            long long tar = sum - (n - 2 * sizes[u]);\n            if (tar == sum) {\n                return {};\n            }\n            auto it = lower_bound(P.begin(), P.end(), make_pair(tar, -1));\n            if (it == P.end()) {\n                return {};\n            }\n            if (it->first != tar || it->second == u) {\n                return {};\n            }\n            int p = it->second;\n            sums[p] += sums[u] + sizes[u];\n            sizes[p] += sizes[u];\n            pars[u] = p;\n        }\n\n        if (sums[P[0].second] != P[0].first) {\n            return {};\n        }\n\n        vector<pair<int,int>> res;\n        for (int i = 0; i < n; ++i) {\n            if (pars[i] >= 0) {\n                res.emplace_back(pars[i], i);\n            }\n        }\n\n        return res;\n    }\n};\n\nint main(int argc, char** argv) {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n    vector<long long> W(n, 0);\n    for (int i = 0; i < n; ++i) {\n        cin >> W[i];\n    }\n    Solution sol;\n    auto res = sol.solve(W);\n    if (res.size() != n - 1) {\n        cout << \"-1\\n\";\n    } else {\n        for (auto& e : res) {\n            cout << e.first + 1 << \" \" << e.second + 1 << \"\\n\";\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define per(i,r,l) for(int i=(r);i>=(l);--i)\nusing namespace std;\ntypedef long long ll;\nconst int maxn=1e5+10;\nint n,sz[maxn],fa[maxn],d[maxn];\nll b[maxn],D;\nvector<int> G[maxn];\nstruct Node{ll x;int id;}a[maxn];\ninline bool operator <(Node x,Node y){return x.x<y.x;}\nvoid dfs(int u,int fa){\n    for(int v:G[u]) if(v!=fa) d[v]=d[u]+1,dfs(v,u);\n}\nint main(){\n    scanf(\"%d\",&n);\n    rep(i,1,n) scanf(\"%lld\",&a[i].x),a[i].id=i,b[i]=a[i].x;\n    sort(a+1,a+n+1);sort(b+1,b+n+1);\n    rep(i,1,n) sz[i]=1;\n    per(i,n,2){\n        int u=a[i].id;\n        if(n%2==0&&sz[u]==n/2) return puts(\"-1\"),0;\n        int x=lower_bound(b+1,b+n+1,a[i].x-(n-2*sz[u]))-b;\n        if(b[x]!=a[i].x-(n-sz[u])+sz[u]) return puts(\"-1\"),0;\n        x=a[x].id;fa[u]=x;sz[x]+=sz[u];\n    }\n    rep(i,1,n) G[i].push_back(fa[i]),G[fa[i]].push_back(i);\n    dfs(a[1].id,0);\n    rep(i,1,n) D+=d[i];if(D!=a[1].x) return puts(\"-1\"),0; \n    rep(i,1,n) if(fa[i]) printf(\"%d %d\\n\",i,fa[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid dfs(int nd, vector<int> &vis, vector<vector<int>> &adjList)\n{\n  vis[nd] = 1;\n  for(int cd : adjList[nd])\n  {\n    if(!vis[cd])\n    {\n      dfs(cd, vis, adjList);\n    }\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  long long n;\n  cin >> n;\n  vector<pair<long long, int>> d(n);\n  vector<long long> sz(n, n);\n  for(int i = 0; i < n; i++)\n  {\n    cin >> d[i].first;\n    d[i].second = i + 1;\n  }\n  sort(d.begin(), d.end());\n  vector<pair<int, int>> ans;\n  vector<vector<int>> adjList(n + 1);\n  for(int i = n - 1; i > 0; i--)\n  {\n    long long dval = d[i].first + (n - sz[i] + 1) - (sz[i] - 1);\n    int pr = lower_bound(d.begin(), d.end(), make_pair(dval, 0)) - d.begin();\n    if(pr >= i || d[pr].first != dval)\n    {\n      cout << \"-1\" << endl;\n      return 0;\n    }\n    ans.push_back({d[i].second, d[pr].second});\n    adjList[d[i].second].push_back(d[pr].second);\n    adjList[d[pr].second].push_back(d[i].second);\n    sz[pr] -= (n - sz[i] + 1);\n  }\n  vector<int> vis(n + 1, 0);\n  dfs(1, vis, adjList);\n  int nds = 0;\n  for(int i = 1; i <= n; i++) nds += vis[i];\n  if(nds != n)\n  {\n    cout << \"-1\" << endl;\n    return 0;\n  }\n  for(int i = 0; i < n - 1; i++)\n  {\n    cout << ans[i].first << \" \" << ans[i].second << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n    > File Name: D.cpp\n    > Author: PumpkinYing\n    > Created Time: 2018/11/9 15:51:37\n ************************************************************************/\n\n#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <stack>\n#include <cmath>\nusing namespace std;\n\n#define mem(a,b) memset(a,b,sizeof(a))\n#define prii pair<int,int>\n#define prdd pair<double,double>\n#define rep(i,l,r) for(int i = l;i < r;i++)\n#define rep_(i,l,r) for(int i = l;i <= r;i++)\ntypedef long long ll;\n\nconst int maxn = 1000010;\nmap<ll,int> mp;\nint sz[maxn];\n\nstruct Node {\n\tll d;\n\tint id;\n\tvoid read(int i) {\n\t\tid = i;\n\t\tscanf(\"%lld\",&d);\n\t}\n\tbool operator < (const Node& b) const {\n\t\treturn d > b.d;\n\t}\n}ns[maxn];\n\nint fa[maxn],vis[maxn];\n\nint main() {\n\tint n;\n\tscanf(\"%d\",&n);\n\trep_(i,1,n) {\n\t\tns[i].read(i);\n\t\tmp[ns[i].d] = i;\n\t\tsz[i] = 1;\n\t}\n\tsort(ns+1,ns+1+n);\n\tint ok = 1;\n\tint tot = 0;\n\trep_(i,1,n-1) {\n\t\tint id = ns[i].id;\n\t\tvis[id] = 1;\n\t\tll val = ns[i].d+sz[id]-(n-sz[id]);\n\t\tif(mp[val] == 0 || vis[mp[val]]) {\n\t\t\tok = 0;\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tfa[id] = mp[val];\n\t\t\tsz[mp[val]] += sz[id];\n\t\t\ttot += sz[id];\n\t\t}\n\t}\n\tint root;\n\trep_(i,1,n) if(fa[ns[i].id] == 0) root = i;\n\tif(ok == 0 || ns[root].d != tot) printf(\"-1\\n\");\n\telse rep_(i,1,n) if(fa[i] != 0) printf(\"%d %d\\n\",i,fa[i]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXn = 1e5 + 10;\ntypedef pair<long long, int> pii;\npii ar[MAXn];\nlong long n, sz[MAXn], root, disroot, d[MAXn];\nvector<int> vec[MAXn];\nvector<pii> ans;\n\nbool cmp(pii p1, pii p2) {\n\treturn p1.first > p2.first;\n}\n\nint main() {\n\tcin >> n;\n\tfill_n(sz, MAXn, 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tint di;\n\t\tcin >> di;\n\t\td[i] = di;\n\t\tar[i].first = di;\n\t\tar[i].second = i;\n\t}\n\tsort(ar, ar + n);\n\tfor (int i = n - 1; i >= 1; i--) {\n\t\tint hp = ar[i].first - n;\n\t\thp += 2 * sz[i];\n\t\tint hp2 = lower_bound(ar, ar + n, pii(hp, -1)) - ar;\n\t\tif (ar[hp2].first != hp)\n\t\t\treturn cout << -1,0;\n\t\tsz[hp2]+= sz[i];\n\t\tvec[ar[hp2].second].push_back(ar[i].second);\n\t\tvec[ar[i].second].push_back(ar[hp2].second);\n\t\tans.push_back(pii(ar[i].second, ar[hp2].second));\n\t}\n\tfor (int i = 0; i < ans.size(); i++)\n\t\tcout << ans[i].first + 1<< ' ' << ans[i].second + 1<< endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "\n// Problem : F - Distance Sums\n// Contest : AtCoder Regular Contest 103\n// URL : https://atcoder.jp/contests/arc103/tasks/arc103_d\n// Memory Limit : 1024 MB\n// Time Limit : 2000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\n#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\n#define cerr if(1)cerr\n#define size(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n#define temptts template <class T, class... Ts>\n\nconst int N = 1e6 + 1, mod = 1e9 + 7, inf = 2e9;\n\nstruct pp {\n\tll v;\n\tint i;\n\tbool operator < (const pp &o) const {\n\t\treturn v < o.v;\n\t}\n} d[N];\n\nmap<ll, int> id;\nint n, sz[N];\nvector<pair<int, int>> ans;\n\nint main() { cin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> d[i].v;\n\t\td[i].i = i;\n\t}\n\tsort(d + 1, d + n + 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tid[d[i].v] = i;\n\t}\n\tfor (int i = n; i >= 2; i--) {\n\t\tsz[i]++;\n\t\tll j = d[i].v - n + 2 * sz[i];\n\t\tif (!id[j] || id[j] == i) {\n\t\t\treturn cout << -1, 0;\n\t\t}\n\t\tans.push_back({d[id[j]].i, d[i].i});\n\t\tsz[id[j]] += sz[i];\n\t}\n\tfor (auto& x : ans) {\n\t\tcout << x.first << ' ' << x.second << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define llong long long \n#define xx first\n#define yy second\n#define len(x) ((int)x.size())\n#define rep(i,n) for (int i = -1; ++ i < n; )\n#define rep1(i,n) for (int i = 0; i ++ < n; )\n#define all(x) x.begin(), x.end()\n\n#define maxn 101010\nint n;\nint nchild[maxn];\nmap<llong, int> inv_d;\n\nint main(void) {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n;\n    rep1(i, n) {\n      llong d; cin >> d;\n      inv_d[d] = i;\n    }\n    rep1(i, n) nchild[i] = 1;\n\n    vector<pair<int, int>> ans;\n    while (len(inv_d) > 1) {\n      llong d = inv_d.rbegin()->xx;\n      int u = inv_d.rbegin()->yy;\n      inv_d.erase(--inv_d.end());\n      llong td = d - 1ll * (n - 2 * nchild[u]);\n      // clog << u << ' ' << d << ' ' << nchild[u] << endl;\n      if (!inv_d.count(td)) {\n        cout << \"-1\";\n        return 0;\n      }\n      int v = inv_d[td];\n      ans.push_back({u, v});\n      // clog << u << ' ' << v << endl;\n      nchild[v] += nchild[u];\n    }\n    rep(i, n - 1) cout << ans[i].xx << ' ' << ans[i].yy << '\\n';\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define IL inline\n#define _ 1000005\n#define ll long long\nusing namespace std ;\n\nIL ll gi(){\n\tll data = 0 , m = 1; char ch = 0;\n\twhile(ch!='-' && (ch<'0'||ch>'9')) ch = getchar();\n\tif(ch == '-'){m = 0 ; ch = getchar() ; }\n\twhile(ch >= '0' && ch <= '9'){data = (data<<1) + (data<<3) + (ch^48) ; ch = getchar(); }\n\treturn (m) ? data : -data ; \n}\n\nll fa[_],sz[_],m,n,d[_] ; \nstruct Item{int id , dis ; } t[_] ; \n\nIL bool cmp1(Item A , Item B){\n\treturn (A.dis ^ B.dis) ? A.dis < B.dis : A.id < B.id ;  \n}\n\nint main() {\n\tn = gi() ;\n\tfor(int i = 1; i <= n; i ++) t[i].id = i , t[i].dis = gi() ;\n\tsort(t + 1 , t + n + 1 , cmp1) ;\n\tfor(int i = 1; i <= n; i ++) d[i] = t[i].dis ; \n\t//for(int i = 1; i <= n; i ++) cout << d[i] << \" \" ; cout << endl ;\n\td[n + 1] = 1e9 ;  \n\tfor(int i = n; i > 1; i --) {\n\t\tint u = t[i].id ; \n\t\tsz[u] ++ ; \n\t\tll ds = t[i].dis + 2ll * sz[u] - n ;\n\t\tll ps = lower_bound(d + 1 , d + n + 2 , ds) - d ;\n\t\t//cout << i << \"  sz=\"<<sz[u]<<\"  ds=\"<<ds<<\"  ps=\"<<ps<<endl ;\n\t\tif(ps >= i || t[ps].dis != ds) return puts(\"-1\") , 0 ;\n\t\tfa[u] = t[ps].id ;\n\t\tsz[t[ps].id] += sz[u] ; \n\t}\n\tfor(int i = 1; i <= n; i ++) if(fa[i]) cout << fa[i] << \" \" << i << endl ;\n\treturn 0 ; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fo(i,s,t) for(int i = s; i <= t; ++ i)\n#define fd(i,s,t) for(int i = s; i >= t; -- i)\n#define bf(i,s) for(int i = head[s]; i; i = e[i].next)\n#define mp make_pair\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pb push_back\n#define VI vector<int>\n#define sf scanf\n#define pf printf\n#define fp freopen\n#define SZ(x) ((int)(x).size())\n#ifdef MPS\n#define D(x...) printf(x)\n#else\n#define D(x...)\n#endif\ntypedef long long ll;\ntypedef double db;\ntypedef unsigned long long ull;\nconst int inf = 1<<30;\nconst ll INF = 1ll<<60;\nconst db Inf = 1e20;\nconst db eps = 1e-9;\n\nvoid gmax(int &a,int b){a = (a > b ? a : b);}\nvoid gmin(int &a,int b){a = (a < b ? a : b);}\n\nconst int maxn = 100050;\n\nint n, sz[maxn];\npair<ll,int> d[maxn];\nstruct edge{int u, v;}e[maxn];\n\nint main()\n{\n\t// fp(\"1.in\",\"r\",stdin);\n\t// fp(\"2.out\",\"w\",stdout);\n\tsf(\"%d\",&n);\n\tfo(i,1,n) sf(\"%lld\",&d[i].fi), d[i].se = i;\n\tsort(d+1, d+n+1);\n\tfd(i,n,2)\n\t{\n\t\tsz[i] ++;\n\t\tint l = 1, r = i-1, mid, p = -1;\n\t\twhile(l <= r)\n\t\t{\n\t\t\tmid = (l + r) >> 1;\n\t\t\tif(d[mid].fi <= d[i].fi-n+2*sz[i]) p = mid, l = mid + 1;\n\t\t\telse r = mid - 1;\n\t\t}\n\t\tif(p == -1 || d[p].fi != d[i].fi-n+2*sz[i]) \n\t\t\treturn 0 * pf(\"-1\\n\");\n\t\tsz[p] += sz[i];\n\t\te[i].u = d[p].se; e[i].v = d[i].se;\n\t}\n\tsz[1] ++;\n\tll ans = 0;\n\tfo(i,1,n) ans += sz[i] * (ll)(n - sz[i]);\n\tans <<= 1;\n\tfo(i,1,n) ans -= d[i].fi;\n\tif(ans != 0) return 0 * pf(\"-1\\n\");\n\tfo(i,2,n) pf(\"%d %d\\n\",e[i].u,e[i].v);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 1e5 + 10;\nll a[maxn], dp[maxn];\nint n, rt, sz[maxn], dep[maxn], tid[maxn];\n\nmap <ll, int> mp;\nvector <int> e[maxn];\n\nvoid DFS(int u) {\n  for (int v : e[u]) {\n    dep[v] = dep[u] + 1;\n    dp[rt] += dep[v];\n    DFS(v);\n  }\n}\n\nvoid dfs(int u) {\n  for (int v : e[u]) {\n    dp[v] = dp[u] + n - 2 * sz[v], dfs(v);\n  }\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    tid[i] = i, sz[i] = 1;\n    scanf(\"%lld\", a + i), mp[a[i]] = i;\n  }\n  sort(tid + 1, tid + n + 1, [] (int x, int y) {\n    return a[x] > a[y];\n  });\n  rt = tid[n];\n  for (int i = 1; i < n; i++) {\n    int u = tid[i];\n    ll val = a[u] + 2 * sz[u] - n;\n    map <ll, int> :: iterator it = mp.find(val);\n    if (it == mp.end()) {\n      return puts(\"-1\"), 0;\n    }\n    int v = it -> second;\n    sz[v] += sz[u], e[v].push_back(u);\n  }\n  DFS(rt), dfs(rt);\n  for (int i = 1; i <= n; i++) {\n    if (a[i] != dp[i]) {\n      return puts(\"-1\"), 0;\n    }\n  }\n  for (int u = 1; u <= n; u++) {\n    for (int v : e[u]) {\n      printf(\"%d %d\\n\", u, v);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <long long, long long> pii;\n\nconst long long MAX_N = 1e5 + 5;\nlong long n, root;\nlong long Arr[MAX_N];\nlong long h[MAX_N];\nlong long Siz[MAX_N];\nlong long Mark[MAX_N];\nlong long par[MAX_N];\nunordered_map <long long, long long> Map;\nvector <pii> edge;\nlong long dp_d[MAX_N];\nlong long dp_u[MAX_N];\nvector <long long> child[MAX_N];\n\nbool cmp(long long a, long long b) {\n\treturn Arr[b] < Arr[a];\n}\n\nvoid dfs1(long long v) {\n\tfor (long long i = 0; i < child[v].size(); i++) {\n\t\tdfs1(child[v][i]);\n\t\tdp_d[v] += dp_d[child[v][i]] + Siz[child[v][i]];\n\t}\n}\n\nvoid dfs2(long long v, long long val) {\n\tdp_u[v] = val;\n\tfor (long long i = 0; i < child[v].size(); i++)\n\t\tdfs2(child[v][i], dp_d[v] + dp_u[v] - dp_d[child[v][i]] - Siz[child[v][i]] + (n - Siz[child[v][i]]));\n}\n\nint main() {\n\tios::sync_with_stdio(false), cout.tie(0), cin.tie(0);\n\tcin >> n;\n\tfor (long long i = 0; i < n; i++) {\n\t\tcin >> Arr[i];\n\t\tSiz[i] = 1;\n\t\th[i] = i;\n\t\tMap[Arr[i]] = i;\n\t}\n\t\t\n\tsort(h, h + n, cmp);\n\t\n\tfor (long long i = 0; i + 1 < n; i++) {\n\t\tlong long v = h[i];\n\t\tlong long tmp = Arr[v] + Siz[v] - (n - Siz[v]);\n\n\t\tif (tmp < 0 || (Map[tmp] == 0 && Arr[0] != tmp)) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tlong long u = Map[tmp];\n\t\tif (Mark[u]) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tSiz[u] += Siz[v];\n\t\tpar[v] = u;\n\t\tedge.push_back({v, u});\n\t\tchild[u].push_back(v);\n\t}\n\troot = h[n - 1];\n\tdfs1(root);\n\tdfs2(root, 0);\n\t\n\tfor (long long i = 0; i < n; i++)\n\t\tif (dp_d[i] + dp_u[i] != Arr[i]) {\n\t\t\tcout << i << \" \" << dp_d[i] + dp_u[i] << \"\\n\";\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\n\tfor (long long i = 0; i + 1 < n; i++)\n\t\tcout << edge[i].first + 1 << \" \" << edge[i].second + 1 << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = int(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\nusing ll = long long;\nusing namespace std;\n\nvector<pair<int, int> > solve(int n, vector<ll> const & d) {\n    map<ll, int> index;\n    REP (i, n) {\n        index[d[i]] = i;\n    }\n\n    int root = index.begin()->second;\n    vector<pair<int, int> > edges;\n    vector<vector<int> > children(n);\n    vector<int> size(n, 1);\n    for (auto it = index.rbegin(); ; ++ it) {\n        ll d_i; int i; tie(d_i, i) = *it;\n        if (i == root) break;\n        int d_parent = d_i - (n - size[i]) + size[i];\n        if (not index.count(d_parent)) {\n            return vector<pair<int, int> >();\n        }\n        int parent = index[d_parent];\n        edges.emplace_back(parent, i);\n        children[parent].push_back(i);\n        size[parent] += size[i];\n    }\n\n    vector<ll> d1(n);\n    function<void (int)> fold = [&](int i) {\n        for (int j : children[i]) {\n            fold(j);\n            d1[i] += size[j] + d1[j];\n        }\n    };\n    fold(root);\n    function<void (int, int)> reroot = [&](int i, int parent) {\n        if (parent != -1) {\n            int d1_j = d1[parent] - size[i] - d1[i];\n            int size_j = n - size[i];\n            d1[i] += size_j + d1_j;\n        }\n        for (int j : children[i]) {\n            reroot(j, i);\n        }\n    };\n    reroot(root, -1);\n    if (d != d1) {\n        return vector<pair<int, int> >();\n    }\n\n    return edges;\n}\n\nint main() {\n    int n; cin >> n;\n    vector<ll> d(n);\n    REP (i, n) cin >> d[i];\n    auto edges = solve(n, d);\n    if (edges.empty()) {\n        cout << -1 << endl;\n    } else {\n        for (auto edge : edges) {\n            int i, j; tie(i, j) = edge;\n            cout << i + 1 << ' ' << j + 1 << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 100005;\n\ntemplate <class T>\nvoid read (T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\n\ntemplate <class T>\nvoid write (T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nint n, sz[N];\nbool flag = true;\n\nstruct node {\n\tint id;\n\tlong long dist;\n\tbool operator < (node rhs) const {\n\t\treturn dist < rhs.dist;\n\t}\n} vec[N];\nlong long d[N];\nvector<pair<int, int> > tree;\n\nint main () {\n\tread(n);\n\tfor (int i = 1; i <= n; i++) vec[i].id = i, read(vec[i].dist);\n\n\tsort(vec + 1, vec + n + 1);\n\tfor (int i = 1; i <= n; i++) d[i] = vec[i].dist, sz[i] = 1;\n\n\tfor (int i = n; i > 1; i--) {\n\t\tint pos = lower_bound(d + 1, d + i, d[i] - (n - sz[i]) + sz[i]) - d;\n\t\tif (pos > i || d[pos] != d[i] - (n - sz[i]) + sz[i]) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t\ttree.push_back(make_pair(vec[i].id, vec[pos].id));\n\t\tsz[pos] += sz[i];\n\t}\n\n\tif (!flag) write(-1), putchar('\\n');\n\telse {\n\t\tfor (int i = 0; i < tree.size(); i++) {\n\t\t\twrite(tree[i].first), putchar(' ');\n\t\t\twrite(tree[i].second), putchar('\\n');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxN = 1e5 + 10;\nlong long d[maxN];\nint n;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i) cin >> d[i];\n\tmultiset<pair<long long, int>> points;\n\tfor (int i = 1; i <= n; ++i) points.insert({d[i], i});\t\n\tbool fun = 1;\n\tauto root = points.begin();\n\tpoints.erase(points.begin());\n\tvector<pair<int, int>> edges;\n\tlong long d_root = 0;\n\twhile (not points.empty()) {\n\t\tauto q = points.begin();\n\t\tpoints.erase(q);\n\t\tfun &= (root->first - q->first + n) % 2 == 0;\n\t\tlong long sz = (root->first - q->first + n) / 2; \n\t\tfun &= sz < n;\n\t\tif (not fun) break;\n\t\td_root += sz *1ll* (sz + 1) / 2;\n\t\tedges.push_back({root->second, q->second});\n\t\tlong long temp_d = q->first;\n\t\tint last = q->second;\n\t\tfor (int i = sz-1; i >= 1; --i) {\n\t\t\tlong long cur_d = temp_d + n - 2 * i;\n\t\t\tauto u = points.lower_bound({cur_d, 1000000});\n\t\t\tfun &= u != points.end();\n\t\t\tif (not fun) break;\n\t\t\tpoints.erase(u);\n\t\t\tfun &= cur_d == u->first;\n\t\t\tif (not fun) break;\t\n\t\t\tedges.push_back({last, u->second});\n\t\t\ttemp_d = cur_d;\n\t\t\tlast = u->second;\n\t\t}\n\t\tif (not fun) break;\n\t}\n\tfun &= d[root->second] == d_root;\n\tif (fun) {\n\t\tfor (auto e : edges) {\n\t\t\tcout << e.first << \" \" << e.second << endl;\n\t\t}\n\t} else puts(\"-1\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\ntemplate<typename T, typename U> inline bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> inline bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\nstruct Init {\n    Init() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(20);\n    };\n} init;\n\nint N;\nint D[110000], n[110000], d[110000];\nunordered_map<int, int> mp;\nvint ans;\nsigned main() {\n    cin >> N;\n    for (int i = 1; i <= N; i++) {cin >> D[i]; n[i] = 1; mp[D[i]] = i;};\n    sort(D + 1, D + N + 1); reverse(D + 1, D + N + 1);\n    for (int i = 1; i <= N - 1; i++) {\n        int s = mp[D[i]];\n        int t = mp[D[i] - N + 2 * n[s]];\n        n[t] += n[s];\n        d[t] += d[s] + n[s];\n        ans.push_back(s); ans.push_back(t);\n    }\n    if (n[mp[D[N]]] != N || d[mp[D[N]]] != D[N]) {\n        cout << -1 << endl;\n        return 0;\n    }\n    for (int i = 0; i < 2 * (N - 1); i += 2) {\n        cout << ans[i] << \" \" << ans[i + 1] << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC optimize(2)\n// #pragma G++ optimize(2)\n// #pragma comment(linker,\"/STACK:102400000,102400000\")\n\n// #include <bits/stdc++.h>\n#include <map>\n#include <set>\n#include <list>\n#include <array>\n#include <cfenv>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <mutex>\n#include <queue>\n#include <ratio>\n#include <regex>\n#include <stack>\n#include <tuple>\n#include <atomic>\n#include <bitset>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <chrono>\n#include <cstdio>\n#include <cwchar>\n#include <future>\n#include <limits>\n#include <locale>\n#include <memory>\n#include <random>\n#include <string>\n#include <thread>\n#include <vector>\n#include <cassert>\n#include <climits>\n#include <clocale>\n#include <complex>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <ctgmath>\n#include <cwctype>\n#include <fstream>\n#include <iomanip>\n#include <numeric>\n#include <sstream>\n#include <ccomplex>\n#include <cstdbool>\n#include <iostream>\n#include <typeinfo>\n#include <valarray>\n#include <algorithm>\n#include <cinttypes>\n#include <cstdalign>\n#include <stdexcept>\n#include <typeindex>\n#include <functional>\n#include <forward_list>\n#include <system_error>\n#include <unordered_map>\n#include <unordered_set>\n#include <scoped_allocator>\n#include <condition_variable>\n// #include <conio.h>\n// #include <windows.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef float fl;\ntypedef double ld;\ntypedef long double LD;\ntypedef pair<int,int> pii;\n#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)\n#define lld \"%I64d\"\n#define llu \"%I64u\"\n#else\n#define lld \"%lld\"\n#define llu \"%llu\"\n#endif\n#define ui(n) ((unsigned int)(n))\n#define LL(n) ((long long)(n))\n#define ull(n) ((unsigned long long)(n))\n#define fl(n) ((float)(n))\n#define ld(n) ((double)(n))\n#define LD(n) ((long double)(n))\n#define char(n) ((char)(n))\n#define Bool(n) ((bool)(n))\n#define fixpoint(n) fixed<<setprecision(n)\n\nconst int INF=1061109567;\nconst int NINF=-1044266559;\nconst LL LINF=4557430888798830399;\nconst ld eps=1e-15;\n#define MOD (1000000007)\n#define PI (3.1415926535897932384626433832795028841971)\n\n/*\n#define MB_LEN_MAX 5\n#define SHRT_MIN (-32768)\n#define SHRT_MAX 32767\n#define USHRT_MAX 0xffffU\n#define INT_MIN (-2147483647 - 1)\n#define INT_MAX 2147483647\n#define UINT_MAX 0xffffffffU\n#define LONG_MIN (-2147483647L - 1)\n#define LONG_MAX 2147483647L\n#define ULONG_MAX 0xffffffffUL\n#define LLONG_MAX 9223372036854775807ll\n#define LLONG_MIN (-9223372036854775807ll - 1)\n#define ULLONG_MAX 0xffffffffffffffffull\n*/\n\n#define MP make_pair\n#define MT make_tuple\n#define All(a) (a).begin(),(a).end()\n#define pall(a) (a).rbegin(),(a).rend()\n#define log2(x) log(x)/log(2)\n#define Log(x,y) log(x)/log(y)\n#define SZ(a) ((int)(a).size())\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define rep1(i,n) for(int i=1;i<=((int)(n));i++)\n#define repa(i,a,n) for(int i=((int)(a));i<((int)(n));i++)\n#define repa1(i,a,n) for(int i=((int)(a));i<=((int)(n));i++)\n#define repd(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define repd1(i,n) for(int i=((int)(n));i>=1;i--)\n#define repda(i,n,a) for(int i=((int)(n));i>((int)(a));i--)\n#define repda1(i,n,a) for(int i=((int)(n));i>=((int)(a));i--)\n#define FOR(i,a,n,step) for(int i=((int)(a));i<((int)(n));i+=((int)(step)))\n#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)\n#define repV(i,v) for(auto i:v)\n#define repE(i,v) for(auto &i:v)\n#define MS(x,y) memset(x,y,sizeof(x))\n#define MC(x) MS(x,0)\n#define MINF(x) MS(x,63)\n#define MCP(x,y) memcpy(x,y,sizeof(y))\n#define sqr(x) ((x)*(x))\n#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())\n#define filein(x) freopen(x,\"r\",stdin)\n#define fileout(x) freopen(x,\"w\",stdout)\n#define fileio(x)\\\n\tfreopen(x\".in\",\"r\",stdin);\\\n\tfreopen(x\".out\",\"w\",stdout)\n#define filein2(filename,name) ifstream name(filename,ios::in)\n#define fileout2(filename,name) ofstream name(filename,ios::out)\n#define file(filename,name) fstream name(filename,ios::in|ios::out)\n#define Pause system(\"pause\")\n#define Cls system(\"cls\")\n#define fs first\n#define sc second\n#define PC(x) putchar(x)\n#define GC(x) x=getchar()\n#define Endl PC('\\n')\n#define SF scanf\n#define PF printf\n\ninline int Read()\n{\n    int X=0,w=0;char ch=0;while(!isdigit(ch)){w|=ch=='-';ch=getchar();}while(isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();\n\treturn w?-X:X;\n}\ninline void Write(int x){if(x<0)putchar('-'),x=-x;if(x>9)Write(x/10);putchar(x%10+'0');}\n\ninline LL powmod(LL a,LL b){LL RES=1;a%=MOD;assert(b>=0);for(;b;b>>=1){if(b&1)RES=RES*a%MOD;a=a*a%MOD;}return RES%MOD;}\ninline LL gcdll(LL a,LL b){return b?gcdll(b,a%b):a;}\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={1,0,-1,0,-1,-1,1,1};\n/************************************************************Begin************************************************************/\nconst int maxn=100010;\n\nint n;\nLL a[maxn];\nvector<pair<LL,int> > e;\nmap<LL,int> mp;\n\nint main()\n{\n\tSF(\"%d\",&n);\n\n\trep(i,n)\n\t{\n\t\tLL x;SF(\"%lld\",&x);\n\t\tmp[x]=i;\n\t\te.push_back({x,i});\n\t}\n\n\tsort(e.rbegin(),e.rend());\n\tLL x=e.back().fs;\n\n\tvector<int> sz(n,1);\n\tvector<LL> dp(n,0);\n\tvector<pair<int,int> > ans;\n\n\trepV(i,e) if(i.fs!=x)\n\t{\n\t\tif(sz[i.sc]*2>=n) return !PF(\"-1\");\n\n\t\tLL need=i.fs-(n-sz[i.sc]*2);\n\n\t\tif(!mp.count(need)) return !PF(\"-1\");\n\n\t\tint par=mp[need];\n\t\tdp[par]+=dp[i.sc]+sz[i.sc];\n\t\tsz[par]+=sz[i.sc];\n\n\t\tans.push_back({i.sc+1,par+1});\n\t}\n\n\tif(dp[e.back().sc]!=x) return !PF(\"-1\");\n\n\trepV(i,ans) PF(\"%d %d\\n\",i.fs,i.sc);\n\n\treturn 0;\n}\n/*************************************************************End**************************************************************/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Inf 0x3f3f3f3f\n#define rg register\nusing namespace std;\nconst int Maxn = 1e5 + 5;\ntypedef long long ll;\ntypedef ll arr[Maxn];\nll min(ll x, ll y) { return x < y ? x : y; }\nll max(ll x, ll y) { return x > y ? x : y; }\ninline ll read()\n{\n\trg ll res = 0, sign = 1;\n\trg char ch = getchar();\n\twhile (!isdigit(ch))\n\t{\n\t\tif (ch == '-')\n\t\t\tsign = -1;\n\t\tch = getchar();\n\t}\n\tdo\n\t{\n\t\tres = (res << 3) + (res << 1) + (ch ^ 48);\n\t\tch = getchar();\n\t} while (isdigit(ch));\n\treturn res * sign;\n}\nint n;\narr siz, fa;\nstruct str\n{\n\tll d;\n\tint id;\n\tbool operator<(str A) const { return d < A.d; }\n} p[Maxn];\n\nint main()\n{\n\tint tmp, now, s;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tp[i] = {read(), i};\n\t\tsiz[i] = 1;\n\t}\n\tsort(p + 1, p + n + 1);\n\tfor (int i = n; i > 1; i--)\n\t{\n\t\tnow = p[i].id;\n\t\ttmp = p[i].d - n + 2 * siz[now];\n\t\tfa[now] = p[s = lower_bound(p + 1, p + n + 1, (str){tmp, 0}) - p].id;\n\t\tif (p[s].d != tmp || s >= i)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[fa[now]] += siz[now];\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (fa[i])\n\t\t\tprintf(\"%d %d\\n\", fa[i], i);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 1e5 + 5;\n\npair<ll, int> pp[MAXN];\nint sz[MAXN];\nint par[MAXN];\n\nint get_par(int v) {\n\treturn par[v] == v ? v : par[v] = get_par(par[v]);\n}\n\nvi g[MAXN];\n\nll sum_dis[MAXN];\nint cnt[MAXN];\nint used[MAXN];\n\nvoid dfs(int s) {\n\tused[s] = 1;\n\tcnt[s] = 1;\n\tREP(i, 0, SZ(g[s])) {\n\t\tint to = g[s][i];\n\t\tif (!used[to]) {\n\t\t\tdfs(to);\n\t\t\tcnt[s] += cnt[to];\n\t\t\tsum_dis[s] += sum_dis[to] + cnt[to];\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tREPN(i, 1, n) {\n\t\tscanf(\"%lld\", &pp[i]._1);\n\t\tpp[i]._2 = i;\n\t\tsz[i] = 1;\n\t\tpar[i] = i;\n\t}\n\tsort(pp + 1, pp + n + 1);\n\tint r = n;\n\t//int bads = 0;\n\tfor(; r > 1; r--) {\n\t\tint a = pp[r]._2;\n\t\tll val = pp[r]._1 - (n - 2 * sz[a]);\n\t\tint ind = lower_bound(pp + 1, pp + n + 1, mp(val, -1)) - pp;\n\t\tif (ind == n + 1 || pp[ind]._1 != val) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn;\n\t\t}\n\t\tint a1 = get_par(a);\n\t\tint b = pp[ind]._2;\n\t\tint b1 = get_par(b);\n\t\tif (a == b) {\n\t\t\t// Let's assume\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn;\n\t\t}\n\t\tpar[a1] = b1;\n\t\tsz[b] += sz[a];\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\t\n\tint s = pp[1]._2;\n\tdfs(s);\n\tif (sum_dis[s] != pp[1]._1) {\n\t\t// Let's assume\n\t\tprintf(\"-1\\n\");\n\t\treturn;\n\t}\n\t\n\tREPN(i, 1, n) {\n\t\tREP(j, 0, SZ(g[i])) {\n\t\t\tint to = g[i][j];\n\t\t\tif (to > i) {\n\t\t\t\tprintf(\"%d %d\\n\", i, to);\n\t\t\t}\n\t\t}\n\t}\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// By Hacheylight\n\n#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n//#define int long long\n#define rep(i, a, b) for (int i = (a); i <= (b); i++)\n#define per(i, a, b) for (int i = (a); i >= (b); i--)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (int i = head[x]; i; i = e[i].nxt)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, sum) memset(a, sum, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter cout << endl\n#define siz(x) ((int)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef long double ld ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef queue <pii> qii ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int N = 100010 ;\nconst int INF = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst int mod = 1000000007 ;\nconst double eps = 1e-7 ;\nvoid douout(double x){ printf(\"%lf\\n\", x + 0.0000000001) ; }\ntemplate <class T> void print(T a) { cout << a << endl ; exit(0) ; }\ntemplate <class T> void chmin(T &a, T b) { if (a > b) a = b ; }\ntemplate <class T> void chmax(T &a, T b) { if (a < b) a = b ; }\nvoid add(int &a, int b) { a = a + b < mod ? a + b : a + b - mod ; }\nvoid sub(int &a, int b) { a = (a - b + mod) % mod ; }\nvoid mul(int &a, int b) { a = (ll) a * b % mod ; }\nint addv(int a, int b) { return (a += b) >= mod ? a -= mod : a ; }\nint subv(int a, int b) { return (a -= b) < 0 ? a += mod : a ; }\nint mulv(int a, int b) { return (ll) a * b % mod ; }\nint read() {\n    int f = 1, x = 0 ;\n    char ch = getchar() ;\n    while (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n    while (isdigit(ch)) { x = x * 10 + ch -'0' ; ch = getchar() ; }\n    return x * f ;\n}\nint pw(int a, int b) {\n\tint s = 1 ;\n\tfor (; b; b >>= 1, a = (ll) a * a % mod)\n    if (b & 1) s = (ll) s * a % mod ;\n    return s ;\n}\n\nint n ;\nmap <ll, int> hsh ;\nint used[N] ;\nvector <pii> ans ;\n\nstruct node {\n\tll v ; int id ;\n} a[N] ;\n\nbool cmp(node a, node b) {\n\treturn a.v > b.v ;\n}\n\nvoid dfs(int u, ll x, int dis) {\n//\tcout << u << \" \" << x << \" \" << dis << endl ;\n\tused[u] = 1 ;\n\tif (hsh.find(x - dis) == hsh.end()) {\n\t\treturn ;\n\t//\tprint(-1) ;\n\t} else {\n\t\tint ID = hsh[x - dis] ;\n\t\tif (dis - 2 > 0) dfs(ID, x - dis, dis - 2) ;\n\t\tif (u > ID) swap(u, ID) ;\n\t\tans.pb(mp(u, ID)) ; // hsh.erase(x - dis) ;\n\t\t\n\t}\n}\n\nsigned main() {\n\tscanf(\"%d\", &n) ;\n\trep(i, 1, n) scanf(\"%lld\", &a[i].v), a[i].id = i ;\n\tsort(a + 1, a + n + 1, cmp) ;\n\trep(i, 1, n) hsh[a[i].v] = a[i].id ;\n\trep(i, 1, n)\n\tif (!used[a[i].id]) {\n\t//\tcout<<\"---\\n\";\n\t\tdfs(a[i].id, a[i].v, n - 2) ;\n\t//\tcout<<\"---\\n\";\n\t}\n\tif (siz(ans) != n - 1) print(-1) ;\n\tsort(ans.begin(), ans.end()) ;\n\tloop(it, ans) printf(\"%d %d\\n\", it->fi, it->se) ;\n\treturn 0 ;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    // freopen(\"atcoder(distancesums2).in\",\"r\",stdin);\n    // freopen(\"atcoder(distancesums2).out\",\"w\",stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    vector<long long>d(n);\n    vector<int>size(n,1);\n    map<long long,int>mp;\n    for(int i=0;i<n;i++){\n        cin>>d[i];\n        mp[d[i]]=i;\n    }\n    vector<pair<int,int> >res;\n    for(int itt = 0;itt<n-1;itt++){\n    auto it = mp.rbegin();\n    int i = it -> second;\n    long long need = d[i] - n + 2 * size[i];\n    if(mp.find(need) == mp.end() || mp[need] == i){\n        cout<<\"-1\"<<endl;\n       return 0;\n    }\n    int j = mp[need];\n    res.emplace_back(i,j);\n    size[j]+=size[i];\n    mp.erase(--mp.end());\n}\n    vector<long long>real_dist(n,-1);\n    real_dist[0] = 0;\n    vector<vector<int>  >g(n);\n    for(auto &p:res){\n        g[p.first].push_back(p.second);\n        g[p.second].push_back(p.first);\n    }\n    vector<int>que(1,0);\n    for(int b = 0 ;b < (int)que.size();b++){\n        for(int j:g[que[b]]){\n            if(real_dist[j]==-1){\n                que.push_back(j);\n                real_dist[j] = real_dist[que[b]]+1;\n            }\n        }\n    }\n    if(accumulate(real_dist.begin(),real_dist.end(),0LL)!=d[0]){\n        cout<<\"-1\"<<endl;\n        return 0;\n    }\n    for(auto &p:res){\n        cout<<p.first + 1<<' '<<p.second+1<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reg register\n#define pr std::pair<ll, int>\n#define fi first\n#define se second\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define lep(i, l, r) for (int i = l; i < r; ++i)\n#define irep(i, r, l) for (int i = r; i >= l; --i)\n#define ilep(i, r, l) for (int i = r; i > l; --i)\n#define Rep(i, n) rep(i, 1, n)\n#define Lep(i, n) lep(i, 1, n)\n#define IRep(i, n) irep(i, n, 1)\n#define ILep(i, n) ilep(i, n, 1)\ntypedef long long ll;\ntypedef long double ld;\n\nnamespace modular {\n    const int MOD = 1000000007;\n    inline int add(int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n    inline void inc(int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n    inline int mul(int x, int y) { return 1LL * x * y % MOD; }\n    inline int qpow(int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x))\n            if (y & 1)\n                ans = mul(ans, x);\n        return ans;\n    }\n}; // namespace modular\n\nnamespace Base {\n    template <typename Tp> inline Tp input() {\n        Tp x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-')\n                y = -1;\n            c = getchar();\n        }\n        if (c == EOF)\n            return 0;\n        while ('0' <= c && c <= '9')\n            x = x * 10 + c - '0', c = getchar();\n        return x *= y;\n    }\n    template <typename Tp> inline void read(Tp &x) { x = input<Tp>(); }\n    template <typename Tp> inline void chmax(Tp &x, Tp y) { x < y ? x = y : 0; }\n    template <typename Tp> inline void chmin(Tp &x, Tp y) { x > y ? x = y : 0; }\n}; // namespace Base\nusing namespace Base;\n/*----------------------------------------------------------------------------*/\n\n#define MAX_N 200007\n#define V std::vector\n\nint N;\nint sz[MAX_N];\nll d[MAX_N];\npr a[MAX_N];\nV<int> G[MAX_N];\nstd::map<ll, int> mp;\n\nvoid dfs1(int x, int las) {\n    sz[x] = 1;\n    for (int y : G[x])\n        if (y != las) {\n            dfs1(y, x);\n            sz[x] += sz[y];\n            d[x] += d[y] + sz[y];\n        }\n}\n\nbool dfs2(int x, int las) {\n    if (mp[d[x]] != x)\n        return false;\n    for (int y : G[x])\n        if (y != las) {\n            d[y] = d[x] + N - 2 * sz[y];\n            if (!dfs2(y, x))\n                return false;\n        }\n    return true;\n}\n\nvoid solve() {\n    std::sort(a + 1, a + N + 1);\n    Rep(i, N) sz[i] = 1, mp[a[i].fi] = a[i].se;\n    ILep(i, N) {\n        int u = a[i].se, s = N - 2 * sz[u], v;\n        if (mp.count(a[i].fi - s)) {\n            v = mp[a[i].fi - s];\n            sz[v] += sz[u];\n            G[u].push_back(v);\n            G[v].push_back(u);\n        } else\n            return puts(\"-1\"), void();\n    }\n    dfs1(1, 0);\n    if (!dfs2(1, 0))\n        return puts(\"-1\"), void();\n    Rep(i, N) {\n        for (int j : G[i])\n            if (i < j)\n                printf(\"%d %d\\n\", i, j);\n    }\n}\n\nint main() {\n#ifdef LOCAL\n    FIN(\"in\");\n#endif\n    read(N);\n    Rep(i, N) read(a[i].fi), a[i].se = i;\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+10;\nint n,pa[maxn],sz[maxn];\nvector<pair<int,int>> b;\npair<long long,int> a[maxn];\nvector<int> g[maxn];\nvector<long long> ch;\nlong long sum;\nvoid dfs(int nod,int dep){\n    sum+=dep;\n    for(int i:g[nod]){\n        dfs(i,dep+1);\n    }\n    return;\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        scanf(\"%lld\",&a[i].first);\n        a[i].second=i;\n    }\n    for(int i=1;i<=n;i++){\n    sz[i]=1;\n    }\n    sort(a+1,a+1+n);\n    for(int i=n;i>1;i--){\n        long long tar=a[i].first+2*sz[a[i].second]-n;\n        int l=1,r=i-1,mid,ans;\n        while(l<=r){\n            mid=(l+r)>>1;\n            if(a[mid].first<=tar){\n                ans=mid;\n                l=mid+1;\n            }\n            else{\n                r=mid-1;\n            }\n        }\n        if(a[ans].first!=tar){\n            return !printf(\"-1\");\n        }\n        pa[a[i].second]=a[ans].second;\n        b.push_back(make_pair(a[ans].second,a[i].second));\n        sz[a[ans].second]+=(sz[a[i].second]);\n        g[a[ans].second].push_back(a[i].second);\n    }\n    dfs(a[1].second,0);\n    if(sum!=a[1].first)return !printf(\"-1\");\n    assert((int)b.size()==n-1);\n    for(auto i:b){\n        printf(\"%d %d\\n\",i.first,i.second);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst int MAXN = 200010;\nconst LL INF = 2147483600;\n\nstruct dat{\n\tLL id,val;\n}a[MAXN+1]; LL N;\nbool cmpval(dat a,dat b){\n\treturn a.val>b.val;\n}\nLL Node[MAXN<<1],Next[MAXN<<1],Root[MAXN+1],cnt;\ninline void insert(LL u,LL v){\n\tNode[++cnt]=v; Next[cnt]=Root[u]; Root[u]=cnt; return ;\n} LL sz[MAXN+1],f[MAXN+1],b[MAXN+1];\ninline void dfs(LL k,LL Fa){\n\tsz[k]=1;\n\tfor(LL x=Root[k];x;x=Next[x]){\n\t\tLL v=Node[x]; if(v==Fa) continue;\n\t\tdfs(v,k); sz[k]+=sz[v]; f[1]+=sz[v];\n\t} return ;\n}\ninline void dfs2(LL k,LL Fa){\n\tif(f[k]!=b[k]){ puts(\"-1\"); exit(0); }\n\tfor(LL x=Root[k];x;x=Next[x]){\n\t\tLL v=Node[x]; if(v==Fa) continue;\n\t\tf[v]=f[k]+N-2*sz[v]; dfs2(v,k);\n\t} return ;\n} LL s1[MAXN+1],s2[MAXN+1],top;\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tN=read();\n\tfor(LL i=1;i<=N;i++){\n\t\ta[i].id=i; a[i].val=read(); b[i]=a[i].val;\n\t} sort(a+1,a+N+1,cmpval);\n\tfor(LL i=1;i<=N;i++) sz[i]=1;\n\tfor(LL i=1;i<N;i++){\n\t\tLL val=a[i].val-N+2*sz[i]; \n\t\tLL l=i+1,r=N,pos=-1;\n\t\twhile(l<=r){\n\t\t\tLL mid=(l+r)>>1;\n\t\t\tif(a[mid].val>=val) pos=mid,l=mid+1;\n\t\t\telse r=mid-1;\n\t\t} if(pos==-1||a[pos].val!=val){\n\t\t\tputs(\"-1\"); return 0;\n\t\t} sz[pos]+=sz[i];\n\t\ts1[++top]=a[i].id; s2[top]=a[pos].id;\n\t\tinsert(a[i].id,a[pos].id);\n\t\tinsert(a[pos].id,a[i].id);\n\t\tcout<<a[i].id<<\" \"<<a[pos].id<<endl;\n\t\t//sz=N+a[fa]-a[i].val\n\t} fgx dfs(1,0); dfs2(1,0);\n\tfor(LL i=1;i<=top;i++) printf(\"%lld %lld\\n\",s1[i],s2[i]); \n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define max(a,b) (((a)>(b))?a:b)\n#define min(a,b) (((a)<(b))?a:b)\n#define int long long\nusing namespace std;\ntemplate<typename T>void read(T &x){\n\tx=0;int f=1;\n\tchar c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if (c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-48;\n\tx*=f;\n}\nint n,fa[100010],sz[100010];\nstruct ha{int d,id;}a[100010];\nbool cmp(ha x,ha y){\n\treturn x.d>y.d;\t\n}\nint dis;\nvector<int>e[100010];\nvoid dfs(int x,int d){\n\tdis+=d;\n\tint si=e[x].size();\n\tfor(int i=0;i<si;++i)\n\t\tdfs(e[x][i],d+1);\n}\nsigned main(){\n\tread(n);\n\tfor(int i=1;i<=n;++i)\n\t\tread(a[i].d),a[i].id=i;\n\tsort(a+1,a+1+n,cmp);\n\tfor(int i=1;i<=n;++i)\n\t\tsz[i]=1;\n\tfor(int i=1;i<n;++i){\n\t\tint xx=a[i].d-(n-sz[a[i].id])+sz[a[i].id];\n\t\tint l=i+1,r=n;\n\t\twhile(l<=r){\n\t\t\tint mid=(l+r)/2;\n\t\t\tif(a[mid].d==xx) {fa[a[i].id]=a[mid].id;sz[a[mid].id]+=sz[a[i].id];e[a[mid].id].push_back(a[i].id);break;}\n\t\t\telse if(a[mid].d<xx) r=mid-1;\n\t\t\telse l=mid+1;\n\t\t}\n\t\tif(!fa[a[i].id]) {puts(\"-1\");return 0;}\n\t}\n\tdfs(a[n].id,0);\n\tif(dis!=a[n].d) {puts(\"-1\");return 0;}\n\tfor(int i=1;i<=n;++i)\n\t\tif(fa[i]) printf(\"%d %d\\n\",i,fa[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pi;\nconst int N=1e5+5;\nstruct eg{int v,nx;}e[N<<1];int head[N],tot;\ninline void add(R int u,R int v){e[++tot]={v,head[u]},head[u]=tot;}\nmap<ll,int>mp;ll s[N],sum;int sz[N],id[N],n;\nvoid dfs(int u,int fa,int dis){\n\tsum+=dis;\n\tgo(u)if(v!=fa)dfs(v,u,dis+1);\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfp(i,1,n)scanf(\"%lld\",&s[i]),id[i]=i,sz[i]=1,mp[s[i]]=i;\n\tsort(id+1,id+1+n,[](const int &x,const int &y){return s[x]>s[y];});\n\tfp(i,1,n-1){\n\t\tR int u=id[i];\n\t\tif(!mp.count(s[u]-n+(sz[u]<<1)))return puts(\"-1\"),0;\n\t\tR int v=mp[s[u]-n+(sz[u]<<1)];\n\t\tif(s[v]>=s[u])return puts(\"-1\"),0;\n\t\tadd(u,v),add(v,u),sz[v]+=sz[u];\n\t}\n\tdfs(id[n],0,0);\n\tif(sum!=s[id[n]])return puts(\"-1\"),0;\n\tfp(u,1,n)go(u)if(u<v)printf(\"%d %d\\n\",u,v);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <utility>\nusing namespace std;\n\ntypedef long long ll;\nll MOD = 1e9+7;\n\nll x[1000];\nll y[1000];\nll bit=0;\nvector<ll> arm;\nchar com[41];\n\nint main()\n{\n\tint n;\n\tint ans=0;\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t\tcin>>x[i]>>y[i];\n\t\n\tbool f=true;\n\t//座標の合計の偶奇が一致しているかどうか調べる\n\tif(((ll)abs(x[0])+(ll)abs(y[0]))%2==0)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(((ll)abs(x[i])+(ll)abs(y[i]))%2!=0)\n\t\t\t{\n\t\t\t\tf=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}else{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(((ll)abs(x[i])+(ll)abs(y[i]))%2==0)\n\t\t\t{\n\t\t\t\tf=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t//一致していなければ構成は無理\n\tif(!f)\n\t{\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\t//アームは大きい方から40本\n\tint armcnt=40;\n\tif(((ll)abs(x[0])+(ll)abs(y[0]))%2==0)\n\t{\n\t\tarm.push_back(1);//偶数なら1を足しておく\n\t\tarmcnt--;\n\t}\n\tbit=1;\n\tfor(int i=0;i<armcnt;i++)\n\t{\n\t\tarm.push_back(bit);\n\t\tbit*=2;\n\t}\n\tsort(arm.begin(),arm.end());\n\treverse(arm.begin(),arm.end());\n\n\t//ここから答え\n\tcout<<40<<endl;\n\tfor(int i=0;i<40;i++)\n\t\tcout<<arm[i]<<\" \";\n\tcout<<endl;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfill(com,com+41,'0');\n\t\tll nowx=0;\n\t\tll nowy=0;\n\t\tfor(int j=0;j<40;j++)\n\t\t{\n\t\t\tif(abs(x[i]-nowx)<abs(y[i]-nowy))\n\t\t\t{\n\t\t\t\tif(y[i]<=nowy)\n\t\t\t\t{\n\t\t\t\t\tnowy-=arm[j];\n\t\t\t\t\tcom[j]='D';\n\t\t\t\t}else{\n\t\t\t\t\tnowy+=arm[j];\n\t\t\t\t\tcom[j]='U';\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(x[i]<=nowx)\n\t\t\t\t{\n\t\t\t\t\tnowx-=arm[j];\n\t\t\t\t\tcom[j]='L';\n\t\t\t\t}else{\n\t\t\t\t\tnowx+=arm[j];\n\t\t\t\t\tcom[j]='R';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<40;j++)\n\t\t\tcout<<com[j]<<\" \";\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define biu (puts(\"-1\"), exit(0))\nusing namespace std;\ntypedef long long ll;\n#define int ll\n\ntemplate <typename Tp> inline void getint(Tp &num){\n\tregister int ch, neg = 0;\n\twhile(!isdigit(ch = getchar())) if(ch == '-') neg = 1;\n\tnum = ch & 15;\n\twhile(isdigit(ch = getchar())) num = num * 10 + (ch & 15);\n\tif(neg) num = -num;\n}\n\nint N, siz[100005], tope = 0;\nstruct disData {ll d; int id;} D[100005];\nstruct Edge {int np; Edge *nxt;} E[100005], *V[100005];\n\ninline bool operator < (const disData &d1, const disData &d2) {return d1.d < d2.d;}\ninline void addedge(const int &u, const int &v) {E[++tope].np = v, E[tope].nxt = V[u], V[u] = E + tope;}\n\nsigned main(){\n\tgetint(N);\n\tfor(register int i = 1; i <= N; i++) getint(D[i].d), D[i].id = i, siz[i] = 1;\n\tsort(D + 1, D + N + 1);\n\tfor(register int i = N; i > 1; i--){\n\t\tif((siz[i] << 1) >= N) biu;\n\t\tconst ll d = D[i].d - N + (siz[i] << 1);\n\t\tconst int fa = lower_bound(D + 1, D + i, (disData){d, 0}) - D;\n\t\tif(D[fa].d != d) biu; siz[fa] += siz[i], addedge(fa, i);\n\t}\n\tfor(register int i = 1; i <= N; i++)\n\t\tfor(register Edge *ne = V[i]; ne; ne = ne->nxt) printf(\"%d %d\\n\", D[i].id, D[ne->np].id);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint n,cnt,size[100005];\nll dis[100005];\nstruct node{\n\tll d;\n\tint id;\n}a[100005];\nstruct edge{\n\tint x,y;\n}e[100005];\n\nint cmp(node u,node v){\n\treturn u.d<v.d;\n}\n\nint cmp1(edge u,edge v){\n\treturn u.x<v.x||(u.x==v.x&&u.y<v.y);\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&a[i].d),a[i].id=i;\n\tsort(a+1,a+n+1,cmp);\n\tfor(int i=1;i<=n;i++) size[i]=1;\n\tfor(int i=n;i>=2;i--){\n\t\tll o=a[i].d+1ll*(2*size[a[i].id]-n);\n\t\tint l=1,r=i-1,mid,p=i;\n\t\twhile(l<=r){\n\t\t\tmid=(l+r)/2;\n\t\t\tif(a[mid].d>=o) p=min(p,mid),r=mid-1;\n\t\t\telse l=mid+1;\n\t\t}\n\t\tif(p==i||a[p].d!=o){puts(\"-1\");return 0;}\n\t\tsize[a[p].id]+=size[a[i].id];\n\t\te[++cnt]=(edge){a[p].id,a[i].id};\n\t\tif(e[cnt].x>e[cnt].y) swap(e[cnt].x,e[cnt].y);\n\t\tdis[a[p].id]+=dis[a[i].id]+1ll*size[a[i].id];\n\t}\n\tif(dis[a[1].id]!=a[1].d){puts(\"-1\");return 0;}\n\tsort(e+1,e+cnt+1,cmp1);\n\tfor(int i=1;i<=cnt;i++) printf(\"%d %d\\n\",e[i].x,e[i].y); \n\n\treturn 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<cstring>\n#include<utility>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<set>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#define ll long long\n#define pii pair<ll,int>\n#define mp make_pair\n#define fi first\n#define se second\n#define inf 0x7fffffff\nusing namespace std;\nint main()\n{\n\tprintf(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n// Problem : F - Distance Sums\n// Contest : AtCoder - AtCoder Regular Contest 103\n// URL : https://atcoder.jp/contests/arc103/tasks/arc103_d\n// Memory Limit : 1024 MB\n// Time Limit : 2000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,ll > pil;\ntypedef pair<ll ,int> pli;\ntypedef pair<ll ,ll > pll;\n#define rep(i,l,r) for(i=(l);i<=(r);++i)\n#define per(i,l,r) for(i=(l);i>=(r);--i)\n#define REP(i,l,r) for(i=(l);i< (r);++i)\n#define PER(i,l,r) for(i=(l);i> (r);--i)\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define pob pop_back\n#define pof pop_front\n#define fi first\n#define se second\n#define it iterator\ntemplate<class IT>inline void cmx(IT &a,IT b){if(a<b)a=b;}\ntemplate<class IT>inline void cmn(IT &a,IT b){if(b<a)a=b;}\ntemplate<class IT>inline bool bmx(IT &a,IT b){if(a<b){a=b;return true;}else return false;}\ntemplate<class IT>inline bool bmn(IT &a,IT b){if(b<a){a=b;return true;}else return false;}\nconst int N=100005;\nmap<ll,int>M;\npli D[N];\nint S[N],F[N];\ninline void ac(){\n\tint n,i,a,s;ll w,d;\n\tscanf(\"%d\",&n);\n\trep(i,1,n){scanf(\"%lld\",&D[i].fi);M[D[i].fi]=D[i].se=i;}\n\tsort(D+1,D+n+1);\n\tper(i,n,2){\n\t\tw=D[i].fi;\n\t\ta=D[i].se;\n\t\t//printf(\"w=%lld a=%d\\n\",w,a);\n\t\ts=++S[a];\n\t\tif((s<<1)>=n){printf(\"-1\");return;}\n\t\td=w+(s<<1)-n;\n\t\tif(!M[d]){printf(\"-1\");return;}\n\t\tS[F[a]=M[d]]+=s;\n\t\t//printf(\"f=%d\\n\",F[a]);\n\t}\n\tw=-S[D[1].se];\n\trep(i,1,n)w+=S[i];\n\tif(w==D[1].fi){rep(i,1,n)if(a=F[i])printf(\"%d %d\\n\",i,a);}\n\telse printf(\"-1\");\n}\nint main(){\n\t//freopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\t\n\tac();\n\treturn 0;\n}\n#undef rep\n#undef per\n#undef REP\n#undef PER\n#undef mp\n#undef pb\n#undef pf\n#undef pob\n#undef pof\n#undef fi\n#undef se\n#undef it"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint main(){puts(\"-1\");}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <map>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to \n#define mp(a, b) make_pair(a, b)\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 100010;\n\npair<LL, int> d[N];\npair<int, int> e[N];\nmap<LL, int> mmp;\n\nint sz[N];\n\nstruct Edge{ int to, next; } edge[N * 2];\nint head[N], num;\nvoid add_edge(int a, int b) { edge[++ num] = (Edge){b, head[a]}, head[a] = num;}\n\nLL sum = 0;\n\nvoid dfs(int x, int f, int dis)\n{\n\tsum += dis;\n\tRepG(i, x) if (v != f) dfs(v, x, dis + 1);\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tRep(i, n){\n\t\tscanf(\"%lld\", &d[i].fi);\n\t\tsz[i] = 1, d[i].se = i, mmp[d[i].fi] = i;\n\t}\n\tsort(d + 1, d + 1 + n);\n\tfor (int i = n; i > 1; i --) {\n\t\tLL tmp = d[i].fi + 2 * sz[d[i].se] - n;\n\t//\tprintf(\"%d %lld\\n\", d[i].fi, tmp);\n\t\tif (tmp < d[i].fi && mmp[tmp]) e[i - 1] = mp(d[i].se, mmp[tmp]), sz[mmp[tmp]] += sz[d[i].se];\n\t\telse {printf(\"-1\\n\"); return 0;}\n\t}\n\tRep(i, n - 1) add_edge(e[i].se, e[i].fi);\n\tdfs(d[1].se, 0, 0);\n//\tprintf(\"%lld\\n\", sum);\n\tif (sum != d[1].fi) printf(\"-1\\n\"); \n\telse Rep(i, n - 1) printf(\"%d %d\\n\", e[i].fi, e[i].se);\n\t\n\treturn 0;\n}\n\n/*\nd[a] - d[b] = n - sz[a] - sz[a]\nd[b] = d[a] + 2 * sz[a] - n;\n*/"
  },
  {
    "language": "C++",
    "code": "\n// Problem : F - Distance Sums\n// Contest : AtCoder Regular Contest 103\n// URL : https://atcoder.jp/contests/arc103/tasks/arc103_d\n// Memory Limit : 1024 MB\n// Time Limit : 2000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\n#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\n#define cerr if(1)cerr\n#define size(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n#define temptts template <class T, class... Ts>\n\nconst int N = 1e6 + 1, mod = 1e9 + 7, inf = 2e9;\n\nstruct pp {\n\tll v;\n\tint i;\n\tbool operator < (const pp &o) const {\n\t\treturn v < o.v;\n\t}\n} d[N];\n\nmap<ll, int> id;\nint n, sz[N];\nll dp[N], D[N];\nvector<int> adj[N];\nvector<pair<int, int>> ans;\n\nvoid add(int v, int u) {\n\tans.push_back({u, v});\n\tadj[v].push_back(u);\n\tadj[u].push_back(v);\n\tsz[v] += sz[u];\n}\n\nvoid dfs_size(int v, int p = 0) {\n\tsz[v] = 1;\n\tfor (auto u : adj[v]) {\n\t\tif (u == p) continue;\n\t\tdfs_size(u, v);\n\t\tsz[v] += sz[u];\n\t}\n}\n\nvoid dfs(int v, int p = 0) {\n\tfor (auto u : adj[v]) {\n\t\tif (u == p) continue;\n\t\tdp[u] = dp[v] + n - 2 * sz[u];\n\t\tdfs(u, v);\n\t}\n\tif (dp[v] != D[v]) {\n\t\tcout << -1;\n\t\texit(0);\n\t}\n}\n\nint main() { cin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> D[i];\n\t\td[i] = {D[i], i};\n\t}\n\tsort(d + 1, d + n + 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tid[d[i].v] = i;\n\t}\n\tfor (int i = n; i >= 2; i--) {\n\t\tsz[d[i].i]++;\n\t\tll j = d[i].v - n + 2 * sz[d[i].i];\n\t\tif (!id[j] || id[j] == i) {\n\t\t\treturn cout << -1, 0;\n\t\t}\n\t\tadd(d[id[j]].i, d[i].i);\n\t}\n\tmemset(sz, 0, sizeof sz);\n\tdp[1] = D[1];\n\tdfs_size(1);\n\tdfs(1);\n\tfor (auto& x : ans) {\n\t\tcout << x.first << ' ' << x.second << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<unordered_map>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nll d[N];\nunordered_map<ll,vector<int> > p;\nll cnt[N],sum[N],n,r[N];\nvector<pair<int,int> > w;\nbool comp(int a,int b){\n\treturn d[a]>d[b];\n}\nint main(){\n\tcin>>n;\n\tfor (int i=1;i<=n;i++)scanf(\"%lld\",&d[i]),r[i]=i,p[d[i]].push_back(i),cnt[i]=1;\n\tsort(r+1,r+n+1,comp);\n\tfor (int i=1;i<n;i++){\n\t\tll x=r[i],s=d[x]-(n-2*cnt[x]),y;\n\t\tif (p[s].empty()||s>=d[x]){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\ty=p[s].back();\n\t\tw.push_back(make_pair(x,y));\n\t\tcnt[y]+=cnt[x];\n\t\tsum[y]+=sum[x]+cnt[x];\n\t}\n\tif (sum[r[n]]!=d[r[n]]){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tfor (int i=0;i<n-1;i++)printf(\"%d %d\\n\",w[i].first,w[i].second);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nlong long d[100001];\nint x[100001];\nint size[100001];\nlong long g[100001];\nvector<pair<int, int> > edge;\nmap<long long, int>f;\nbool cmp(int x, int y) {\n    return d[x] > d[y];\n}\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n ; i ++)\n        scanf(\"%lld\", &d[i]), x[i] = i, size[i] = 1, f[d[i]] = i;\n    sort(x + 1, x + n + 1, cmp);\n    bool sig = 0;\n    for (int i = 1; i <= n ; i ++) {\n        long long dd = d[x[i]] +size[x[i]] - n + size[x[i]];\n        if (dd != d[x[i]]&&f[dd]) size[f[dd]] += size[x[i]], edge.push_back(make_pair(x[i], f[dd])), g[f[dd]] += g[x[i]] + size[x[i]];\n    }\n    if (size[x[n]] == n && edge.size() == n - 1 &&g[x[n]] == d[x[n]]){\n        for (auto u : edge) printf(\"%d %d\\n\", u.first, u.second);\n    } else printf(\"-1\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_N 100000\nusing namespace std;\ntypedef long long lnt;\ntemplate <class T> inline void read(T &x) {\n\tx = 0; int c = getchar(), f = 1;\n\tfor (; !isdigit(c); c = getchar()) if (c == 45) f = -1;\n\tfor (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');\n}\nint n, sz[MAX_N+5]; lnt s[MAX_N+5], tot;\nmap <lnt, int> id; vector <int> G[MAX_N+5];\nvoid DFS(int u, int d) {tot += d; for (int v : G[u]) DFS(v, d+1);}\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n; i++)\n\t\tread(s[i]), id[s[i]] = i, sz[i] = 1;\n\tsort(s+1, s+n+1, greater<int>());\n\tfor (int i = 1; i < n; i++) {\n\t\tint u = id[s[i]];\n\t\tlnt sf = s[i]-n+2*sz[u];\n\t\tif (sf >= s[i] || !id.count(sf))\n\t\t\treturn puts(\"-1\"), 0;\n\t\tint f = id[sf];\n\t\tsz[f] += sz[u];\n\t\tG[f].push_back(u);\n\t}\n\tDFS(id[s[n]], 0);\n\tif (tot != s[n])\n\t\treturn puts(\"-1\"), 0;\n\tfor (int u = 1; u <= n; u++)\n\t\tfor (int v : G[u]) printf(\"%d %d\\n\", u, v);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\n#include<map>\n#define LL long long \nusing namespace std;\n\nconst int M = 210001;\nint n,m,k,a[M],s[M],W,ver[M],nex[M],head[M],cnt;\nvoid add(int x,int y)\n{\n\tver[++cnt]=y, nex[cnt]=head[x], head[x]=cnt;\n\tver[++cnt]=x, nex[cnt]=head[y], head[y]=cnt;\n}\nmap<LL,int> mp;\nstruct vv\n{\n\tLL x;\n\tint w;\n} t[M];\n\nbool cmp(vv a,vv b){return a.x>b.x;}\nbool cmp1(vv a,vv b){return a.w<b.w;}\n\nLL dfs(int x,int fa,int dp)\n{\n\tLL S=s[x];\n\tfor(int i=head[x];i;i=nex[i])\n\t{\n\t\tif(ver[i]==fa) continue;\n\t\tS+=dfs(ver[i],x,dp+1);\n\t}\n\treturn S;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&t[i].x);\n\t\tt[i].w=i; s[i]=1;\n\t\tmp[t[i].x]=i;\n\t}\n\tsort(t+1,t+1+n,cmp);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tLL k=t[i].x+(LL)s[t[i].w]-n+s[t[i].w];\n\t\tif(k==t[i].x || mp.find(k)==mp.end())\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\ta[t[i].w]=mp[k];\n\t\tadd(t[i].w,mp[k]);\n\t\ts[mp[k]]+=s[t[i].w];\n\t}\n\tLL k=dfs(t[n].w,0,0)-n;\n\tif(dfs(t[n].w,0,0)-n!=t[n].x) \n\t{\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<n;i++) printf(\"%d %d\\n\",t[i].w,a[t[i].w]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (lli i = 0; i < (n); i++)\n#define rrep(i, n) for (lli i = (n)-1; i >= 0; i--)\nusing namespace std;\nusing lli = long long int;\nvector<int> ans[100005];\nbool paint[100005] = {};\nvoid p(int u){\n    if(paint[u])return;\n    paint[u] = true;\n    for(auto s:ans[u]){\n        p(s);\n    }\n}\nint main() {\n    int n;cin >> n;\n    vector<pair<lli,lli>> d(n);\n    map<lli,lli> m;\n    rep(i,n){\n        cin >> d[i].first,d[i].second = i;\n        m[d[i].first] = i;\n    }\n    sort(d.begin(),d.end());\n    reverse(d.begin(),d.end());\n    vector<bool> used(n);\n    if(n==2){\n        cout << -1 << endl;\n        return 0;\n    }\n    rep(i,n){\n        int leaf = d[i].second;\n        if(used[leaf])continue;\n        lli value = d[i].first;\n        lli N = n - 2;\n        while(N>0){\n            value -= N;\n            N-=2;\n            if(value<=0 || m.find(value) == m.end()){\n                break;\n            }\n            used[leaf] = true;\n            ans[m[value]].push_back(leaf);\n            ans[leaf].push_back(m[value]);\n\n            leaf = m[value];\n        }\n    }\n    p(0);\n    rep(i,n){\n        if(!paint[i]){\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n    rep(i,n){\n        for(auto s:ans[i]){\n            if(i<s ){\n                cout << i+1 << \" \" << s+1 << endl;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nconst int N = 500000;\n\nint sz[N];\nvector<int> graph[N];\n\nsigned main()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    int n;\n    cin >> n;\n    vector<ll> d(n);\n    vector<pair<ll, int> > q(n);\n    map<ll, int> mm;\n    for (int i = 1; i <= n; i++) cin >> d[i], q[i - 1] = {d[i], i}, mm[d[i]] = i;\n    sort(rall(q));\n    fill(sz, sz + N, 1);\n    for (int i = 0; i + 1 < q.size(); i++)\n    {\n        auto it = q[i];\n        ll ex = it.first + sz[it.second] - (n - sz[it.second]);\n        if (ex >= it.first || mm.find(ex) == mm.end())\n        {\n            cout << \"-1\";\n            return 0;\n        }\n        graph[it.second].push_back(mm[ex]);\n        sz[mm[ex]] += sz[it.second];\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (auto u : graph[i])\n        {\n            cout << u << \" \" << i << \"\\n\";\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst int MAXN = 200010;\nconst LL INF = 2147483600;\n\nstruct dat{\n\tLL id,val;\n}a[MAXN+1]; LL N;\nbool cmpval(dat a,dat b){\n\treturn a.val>b.val;\n}\nLL Node[MAXN<<1],Next[MAXN<<1],Root[MAXN+1],cnt;\ninline void insert(LL u,LL v){\n\tNode[++cnt]=v; Next[cnt]=Root[u]; Root[u]=cnt; return ;\n} LL sz[MAXN+1],f[MAXN+1],b[MAXN+1];\ninline void dfs(LL k,LL Fa){\n\tsz[k]=1;\n\tfor(LL x=Root[k];x;x=Next[x]){\n\t\tLL v=Node[x]; if(v==Fa) continue;\n\t\tdfs(v,k); sz[k]+=sz[v]; f[1]+=sz[v];\n\t} return ;\n}\ninline void dfs2(LL k,LL Fa){\n\tif(f[k]!=b[k]){ puts(\"-1\"); exit(0); }\n\tfor(LL x=Root[k];x;x=Next[x]){\n\t\tLL v=Node[x]; if(v==Fa) continue;\n\t\tf[v]=f[k]+N-2*sz[v]; dfs2(v,k);\n\t} return ;\n} LL s1[MAXN+1],s2[MAXN+1],top;\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tN=read();\n\tfor(LL i=1;i<=N;i++){\n\t\ta[i].id=i; a[i].val=read(); b[i]=a[i].val;\n\t} sort(a+1,a+N+1,cmpval);\n\tfor(LL i=1;i<=N;i++) sz[i]=1;\n\tfor(LL i=1;i<N;i++){\n\t\tLL val=a[i].val-N+2*sz[i]; \n\t\tLL l=i+1,r=N,pos=-1;\n\t\twhile(l<=r){\n\t\t\tLL mid=(l+r)>>1;\n\t\t\tif(a[mid].val>=val) pos=mid,l=mid+1;\n\t\t\telse r=mid-1;\n\t\t} if(pos==-1||a[pos].val!=val){\n\t\t\tputs(\"-1\"); return 0;\n\t\t} sz[pos]+=sz[i];\n\t\ts1[++top]=a[i].id; s2[top]=a[pos].id;\n\t\tinsert(a[i].id,a[pos].id);\n\t\tinsert(a[pos].id,a[i].id);\n\t\t//sz=N+a[fa]-a[i].val\n\t} //dfs(1,0); dfs2(1,0);\n\tfor(LL i=1;i<=top;i++) printf(\"%lld %lld\\n\",s1[i],s2[i]); \n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <cstring>\n#include <utility>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cmath>\n#include <deque>\n#include <unordered_map>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\nconst int MAXN = 123456;\nint num[MAXN];\nLL D[MAXN], sz[MAXN];\nvector<int> G[MAXN];\nmap<LL, int> mp;\n\nbool cmp(int a, int b) {\n     return D[a] > D[b];\n}\n\nLL dfs(int cur, LL dis) {\n   LL sum = 0;\n   for (int i : G[cur]) {\n       sum += dfs(i, dis + 1);\n   }\n   return sum + dis;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    for (int i = 1; i <= N; i++) {\n        num[i] = i;\n        sz[i] = 1;\n        scanf(\"%lld\", &D[i]);\n        mp[D[i]] = i;\n    }\n    sort(num + 1, num + 1 + N, cmp);\n    for (int i = 1; i < N; i++) {\n        int cur = num[i];\n        LL cur_D = D[cur];\n        LL par_D = cur_D - N + 2 * sz[cur];\n        if (mp.find(par_D) == mp.end()) return !printf(\"-1\\n\");\n        int par = mp[par_D];\n        G[par].push_back(cur);\n        sz[par] += sz[cur];\n    }\n    LL check = dfs(num[N], 0);\n    if (check != D[num[N]]) return !printf(\"-1\\n\");\n    for (int i = 1; i <= N; i++) {\n        for (int j : G[i]) {\n            printf(\"%d %d\\n\", i, j);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100001\nusing namespace std;\nstruct S{\n\tlong long w,dep;\n\tlong long u,v,ne;\n}a[N],e[N];\n\tlong long n,sz[N],dy[N],fir[N],root,vis[N],sum;\n\tbool bo=false;\nvoid add(long long u,long long v){\n\te[++sum].ne=fir[u];\n\tfir[u]=sum;\n\te[sum].v=v;\n\te[sum].u=u;\n}\nbool cmp(S x,S y){\n\treturn x.w>y.w;\n}\nvoid check(long long x,long long father){\n\tif(bo)return;\n\tvis[x]=1;\n\tfor(long long i=fir[x];i;i=e[i].ne){\n\t\tlong long to=e[i].v;\n\t\tif(to!=father&&!vis[to]){\n\t\t\t//if(vis[to])bo=true;\n\t\t\tcheck(to,x);\n\t\t}\n\t}\n}\nvoid dfs(long long x,long long father){\n\tvis[x]=1;\n\tfor(long long i=fir[x];i;i=e[i].ne){\n\t\tlong long to=e[i].v;\n\t\tif(to!=father&&!vis[to]){\n\t\t\tprintf(\"%lld %lld\\n\",x,to);\n\t\t\tdfs(to,x);\n\t\t}\n\t}\n}\nlong long query(long long sum){\n\tlong long l=1,r=n;\n\twhile(l<r){\n\t\tlong long mid=(l+r+1)>>1;\n\t\tif(a[mid].w>sum)l=mid;\n\t\telse if(a[mid].w<sum)r=mid-1;\n\t\telse {\n\t\t\tl=mid;\n\t\t\treturn a[l].dep;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tscanf(\"%lld\",&n);\n\tfor(long long i=1;i<=n;i++)scanf(\"%lld\",&a[i].w),sz[i]=1,a[i].dep=i;\n\tsort(a+1,a+n+1,cmp);\n\tfor(long long i=1;i<=n;i++){\n\t\tlong long tmp=n-2*sz[a[i].dep];\n\t\tlong long father=query(a[i].w-tmp);\n\t\tsz[father]+=sz[a[i].dep];\n/*\t\tif(!father){\n\t\t\tif(root){\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\troot=a[i].dep;\n\t\t}\n\t\telse {\n*/\t\t\tadd(a[i].dep,father);\n\t\t\tadd(father,a[i].dep);\n//\t\t}\n\t}\n\troot=a[n].dep;\n\tcheck(root,0);\n\tif(bo){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(long long i=1;i<=n;i++)if(!vis[i]){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tmemset(vis,0,sizeof(vis));\n\tdfs(root,0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<iomanip>\n#include<cstring>\n#include<algorithm>\n#include<ctime>\n#define int long long\nusing namespace std;\ninline int read()\n{\n\tint kkk=0,x=1;\n\tchar c=getchar();\n\twhile((c<'0' || c>'9') && c!='-')\n\t\tc=getchar();\n\tif(c=='-')\n\t\tc=getchar(),x=-1;\n\twhile(c>='0' && c<='9')\n\t\tkkk=(kkk<<3)+(kkk<<1)+(c-'0'),c=getchar();\n\treturn kkk*x;\n}\nint n,head[100001],tot;\nstruct node\n{\n\tint sum,id,size,fa;\n}a[100001];\nstruct sb\n{\n\tint to,nextn;\n}con[100001];\ninline void ADD(int from,int to)\n{\n\tcon[++tot].to=to,con[tot].nextn=head[from];\n\thead[from]=tot;\n}\ninline int cmp(node x,node y)\n{\n\treturn x.sum>y.sum;\n}\ninline int find(int V)\n{\n\tint l=1,r=n,bck=0;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)/2;\n\t\tif(a[mid].sum>=V)\n\t\t\tbck=mid,l=mid+1;\n\t\telse\n\t\t\tr=mid-1;\n\t}\n\treturn bck;\n}\ninline int check(int u,int fa)\n{\n\tint bck=0;\n\tfor(register int i=head[u];i!=0;i=con[i].nextn)\n\t{\n\t\tint v=con[i].to;\n\t\tif(v==fa)\n\t\t\tcontinue;\n\t\tbck+=check(v,u);\n\t}\n\treturn bck+a[u].size-1;\n}\nsigned main()\n{\n\tn=read();\n\tfor(register int i=1;i<=n;++i)\n\t{\n\t\ta[i].id=i;\n\t\ta[i].sum=read();\n\t\ta[i].size=1;\n\t}\n\tsort(a+1,a+n+1,cmp);\n\ta[0].sum=0x7f7f7f7f7f7f7f7f;\n\tfor(register int i=1;i<n;++i)\n\t{\n\t\tint sum=a[i].sum+a[i].size-(n-a[i].size);\n\t\tif(sum>=a[i].sum)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint zone=find(sum);\n\t\tif(a[zone].sum!=sum)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\ta[zone].size+=a[i].size;\n\t\ta[i].fa=zone;\n\t\tADD(zone,i);\n\t}\n\tif(check(n,0)!=a[n].sum)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(register int i=1;i<n;++i)\n\t\tprintf(\"%lld %lld\\n\",a[i].id,a[a[i].fa].id);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<60)+1e9; // ~ 1.15 * 1e18\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\n\nInt check(vector<vector<Int> > G, Int root,Int d){\n\n  function<Int(Int,Int,Int)>  dfs = [&](Int pos,Int pre,Int dis){\n    Int res = 0;\n    for(Int to:G[pos]){\n      if(to == pre) continue;\n      res += dfs(to, pos, dis+1);\n    }\n    return res;\n  };\n  return dfs(root, -1, 0) == d;\n}\n\nsigned main(){\n  srand((unsigned)time(NULL));\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  Int n;\n  cin>>n;\n  vector<P> D(n);\n  map<Int,Int> num;\n  for(Int i=0;i<n;i++){\n    Int d;\n    cin>>d;\n    D[i] = P(d, i);\n    num[d] = i;\n  }\n  sort(D.begin(), D.end(), greater<P>());\n\n  vector<Int> sz(n, 1);\n  vector<vector<Int> > G(n);\n\n  auto add_edge = [&](Int a,Int b){\n    G[a].push_back(b);\n    G[b].push_back(a);\n  };\n\n  \n  for(Int i=0;i<n-1;i++){\n    Int d, pos; tie(d, pos) = D[i];\n    Int x  = sz[pos];\n    Int nd = d + x - (n - x);\n\n    if(!num.count(nd)){\n      cout<<-1<<endl;\n      return 0;\n    }\n    Int to = num[nd];\n    if(d <= nd){\n      cout<<-1<<endl;\n      return 0;\n    }\n\n    add_edge(pos, to);\n    sz[to] += sz[pos];\n  }\n\n  \n  if(check(G, D[n-1].second, D[n-1].first)){\n    cout<<-1<<endl;\n    return 0;\n  }\n  \n  for(Int i=0;i<9;i++){\n    Int idx = rand()%n;\n    if(check(G, D[idx].second, D[idx].first)){\n      cout<<-1<<endl;\n      return 0;\n    }\n  }\n  \n\n\n  for(Int i=0;i<n;i++)\n    for(Int to:G[i]){\n      if(i > to) continue;\n      cout<<i+1<<\" \"<<to+1<<endl;\n    }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> pii;\n\npii inp[100005];\nint siz[100005];\nll dp[100005];\nvector<pii> ans;\n\nint main() {\n\tint N; scanf(\"%d\", &N);\n\tfor (int i = 1; i <= N; i++) {\n\t\tll x; scanf(\"%lld\", &x);\n\t\tinp[i] = {x, i};\n\t\tsiz[i] = 1;\n\t}\n\tsort(inp + 1, inp + N + 1);\n\tfor (int i = N; i >= 2; i--) {\n\t\tll cur; int id;\n\t\ttie(cur, id) = inp[i];\n\t\tint del = N - 2 * siz[id];\n\t\tauto it = *lower_bound(inp + 1, inp + i, pii(cur - del, 0));\n\t\tif (it.first != cur - del || del <= 0) return !printf(\"-1\");\n\t\tsiz[it.second] += siz[id];\n\t\tdp[it.second] += siz[id] + 1;\n\t\tif (id > it.second) swap(id, it.second);\n\t\tans.push_back({id, it.second});\n\t}\n\tif (dp[inp[1].second] + 1 != inp[1].first) return !printf(\"-1\");\n\tsort(ans.begin(), ans.end());\n\n\tfor (pii &x : ans) {\n\t\tprintf(\"%lld %d\\n\", x.first, x.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define ln                '\\n'\n#define all(dat)           dat.begin(), dat.end()\n#define loop(i, to)        for (int i = 0; i < to; ++i)\n#define cont(i, to)        for (int i = 1; i <= to; ++i)\n#define circ(i, fr, to)    for (int i = fr; i <= to; ++i)\n#define foreach(i, dat)    for (__typeof(dat.begin()) i = dat.begin(); i != dat.end(); ++i)\n\ntypedef long long          num;\n\nusing namespace std;\n\nconst int nsz = 1e5;\nint n;\nnum mn, w[nsz + 5];\nmap<num, bool> vis;\nmap<num, int> id;\nvector<pair<int, int>> ans;\n\nbool inline cmp(num a, num b) {\n    return a > b;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> n;\n    cont (i, n) {\n        cin >> w[i];\n        id[w[i]] = i;\n    }\n    sort(w + 1, w + n + 1, cmp);\n    mn = w[n];\n    cont (i, n) {\n        num cur = w[i], tmp = n - 2, nxt = cur - tmp;\n        if (vis[cur])  continue;\n        while (id[cur] && cur != mn) {\n            vis[cur] = 1;\n            ans.push_back({id[cur], id[nxt]});\n            cur = nxt;\n            tmp -= 2;\n            nxt -= tmp;\n        }\n        vis[cur] = 1;\n        if (cur != mn) {\n            cout << -1 << ln;\n            return 0;\n        }\n    }\n    foreach (it, id) {\n        if (!vis[it->first]) {\n            cout << -1 << ln;\n            return 0;\n        }\n    }\n    for (pair<int, int> tmp : ans) {\n        cout << tmp.first << ' ' << tmp.second << ln;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <string.h>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <cassert>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <sstream>\n#include <functional>\n#include <iomanip>\n#include <bitset>\n//#include <windows.h>  //Should be deleted when using AtCoder&POJ\nusing namespace std;\n\n#define ll long long\n#define pii pair<int,int>\n#define qi ios::sync_with_stdio(0)\n/**==Info==\n*Program:6\n*Problem:Distance Sums\n*Date:2019-7-12\n*Algorithm:Orange Boy's Greedy and Sorting\n*Stats:Unknown*/\n\nbool debug=false;\n\n\ntemplate<typename T1,typename T2> ostream& operator<<(ostream& o,pair<T1,T2> p){\n\to<<\"{\";\n\to<<p.first<<\",\"<<p.second;\n\to<<\"}\";\n\treturn o;\n}\n\nll n;\nll d[100005];\nmap <ll,ll> m;\npair<ll,ll> p[100005];\nll sub[100005];\nll sz[100005];\nvector <pair<ll,ll> >res;\n \nint main()\n{\n//\tfreopen(\"input.txt\",\"r\",stdin);\n\tios_base::sync_with_stdio(false);\n\tcin>>n;\n\tfor(ll i=0;i<n;i++)\n\t{\n\t\tcin>>d[i];\n\t\tif(d[i]>n*(n-1)/2){\n\t\t\tcout<<-1;\n\t\t\treturn 0;\n\t\t}\n\t\tm[d[i]]=i;\n\t\tp[i].first=d[i];\n\t\tp[i].second=i;\n\t\tsz[i]=1;\n\t}\n\tsort(p,p+n);\n\treverse(p,p+n);\n\tmemset(sub,-1,sizeof(sub));\n\tfor(ll i=0;i<n-1;i++)\n\t{\n\t\tll de=p[i].first;\n\t\tll x=p[i].second;\n\t\tsub[x]=n-sz[x]*2;\n\t\tif(sub[x]==0){\n\t\t\tcout<<-1;\n\t\t\treturn 0;\t\n\t\t}\n\t\tif(m.find(de-sub[x])==m.end()){\n\t\t\tcout<<-1;\n\t\t\treturn 0;\n\t\t}\n\t\tll par=m[de-sub[x]];\n\t\tsz[par]+=sz[x];\n\t\tres.push_back(make_pair(x,par));\n\t}\n\t\n\t\n\tfor(ll i=0;i<n-1;i++)\n\t{\n\t\tcout<<res[i].first+1<<\" \"<<res[i].second+1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\n//ll mod=1000000007;\nll mod=998244353;\nll inf=1000000000000000000;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(int i=n;i>=m;i--)\nll lmax(ll a,ll b){\n    if(a<b)return b;\n    else return a;\n}\nll lmin(ll a,ll b){\n    if(a<b)return a;\n    else return b;\n}\nint main(){\n    ll n;cin>>n;\n    ll d[n];\n    vector<pll> v;\n    ll num;\n    ll mi=inf;\n    rep(i,0,n){\n        cin>>d[i];\n        v.push_back(make_pair(d[i],i));\n        if(mi>d[i]){\n            mi=d[i];\n            num=i;\n        }\n    }\n    ll root=v[0].first;\n    ll now=-1;\n    ll sa=-1;\n    ll par=-1;\n    vector<pll> ans;\n  ll qq=1;\n  bool used[n];fill(used,used+n,false);\n    for(;;){\n      if(qq==n)break;\n        if(now==-1){\n            pll p=v[qq];\n            if(used[p.second]){\n              qq++;\n              continue;\n            }\n            now=p.first;\n            ll ban=p.second;\n            //cout<<now<<endl;\n            if(now>root+n-2){\n                cout<<-1<<endl;\n                return 0;\n            }\n            sa=now-root;\n          used[p.second]=true;\n            ans.push_back(make_pair(num,ban));\n            par=ban;\n        }\n        else{\n            ll y=lower_bound(v.begin(),v.end(),make_pair(now+sa+2,0))-v.begin();\n            if(y==n){\n                if(sa!=n-2){\n                    cout<<-1<<endl;\n                    return 0;\n                }\n                now=-1;\n                sa=-1;\n              qq++;\n            }\n            else{\n                pll p=v[y];\n                if(p.first!=now+sa+2){\n                    cout<<-1<<endl;\n                    return 0;\n                }\n                ans.push_back(make_pair(par,p.second));\n                par=p.second;\n                now=p.first;\n                sa+=2;\n                used[p.second]=true;\n            }\n        }\n        \n        //cout<<now<<\" \";\n    }\n    rep(i,0,ans.size()){\n        if(ans[i].first>ans[i].second)swap(ans[i].first,ans[i].second);\n    }\n    sort(ans.begin(),ans.end());\n    rep(i,0,ans.size())cout<<ans[i].first+1<<\" \"<<ans[i].second+1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n\nint n ;\n\npair < long long , int > d[100010] ;\n\nint nChild[100010] ;\n\nmap < long long , int > f;\n\nvector < pair < int , int > > lis ;\n\nint main(){\n    #define NAME \"example\"\n    //freopen(NAME\".inp\", \"r\", stdin) ; freopen(NAME\".out\", \"w\", stdout) ;\n\n    ios_base :: sync_with_stdio(false) ;\n\n    cin >> n ;\n\n    for (int i = 1; i <= n; ++ i) cin >> d[i].first, d[i].second = i ;\n\n    sort(d + 1, d + n + 1) ;\n\n    long long total = 0 ;\n\n    for (int i = 1; i <= n; ++ i) f[d[i].first] = d[i].second ;\n    for (int i = n; i >= 2; -- i){\n        long long foo = d[i].first + 2ll * (nChild[d[i].second] + 1) - 1ll * n ;\n        int bar = f[foo] ;\n        if(!bar) return cout << -1 , 0 ;\n        nChild[bar] += nChild[d[i].second] + 1 ;\n        if(bar != d[1].second && 2 * nChild[bar] >= n) return cout << -1, 0 ;\n        lis.push_back(make_pair(d[i].second, bar)) ;\n        total += 1ll * (nChild[d[i].second] + 1) ;\n    }\n    if(total != d[1].first) return cout << -1, 0 ;\n\n    for (int i = 0; i < (int)lis.size(); ++ i) cout << lis[i].first << \" \" << lis[i].second << endl ;\n\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n;\nconst int maxN = 1e5 + 10;\nll d[maxN];\nint sz[maxN];\nvector < int > g[maxN];\nvoid dfs(int v, int p, int he, ll& ans) {\n    ans += he;\n    for (int to : g[v]) {\n        if (to == p) continue;\n        dfs(to, v, he + 1, ans);\n    }\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> n;\n    vector < pair < ll, int > > f;\n    for (int i = 1; i <= n; i++) {\n        cin >> d[i];\n        f.emplace_back(d[i], i);\n        sz[i] = 1;\n    }\n    sort(f.begin(), f.end());\n    vector < pair < int, int > > ed;\n    for (int i = n - 1; i >= 1; i--) {\n        if (sz[f[i].second] > n / 2) {\n            cout << -1;\n            return 0;\n        }\n        ll need = f[i].first - n + 2 * sz[f[i].second];\n        int r = lower_bound(f.begin(), f.end(), make_pair(need, -1)) - f.begin();\n        if (f[r].first != need) {\n            cout << -1;\n            return 0;\n        }\n        ed.emplace_back(f[r].second, f[i].second);\n        sz[f[r].second] += sz[f[i].second];\n        g[f[r].second].emplace_back(f[i].second);\n        g[f[i].second].emplace_back(f[r].second);\n    }\n    int who = f[0].second;\n    ll ans = 0;\n    dfs(who, -1, 0, ans);\n    if (ans != d[who]) {\n        cout << -1;\n        return 0;\n    }\n    for (auto it : ed) {\n        cout << it.first << \" \" << it.second << '\\n';\n    }\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  \n  int n;\n  cin >> n;\n  vector<int> d(n);\n  for (int i = 0; i < n; i++) {\n    cin >> d[i];\n  }\n\n  vector<int> ord(n);\n  iota(ord.begin(), ord.end(), 0);\n  sort(ord.begin(), ord.end(), [&](int i, int j) { return d[i] > d[j]; });\n  ord.pop_back();\n\n  map<long long, int> mp;\n  for (int i = 0; i < n; i++) {\n    mp[d[i]] = i;\n  }\n  vector<int> sz(n, 1), par(n, -1);\n\n  for (auto i : ord) {\n    long long par_d = d[i] + sz[i] - (n - sz[i]);\n    if (mp.count(par_d) == 0 || mp[par_d] == i) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n    par[i] = mp[par_d];\n    sz[par[i]] += sz[i];\n  }\n\n  for (int i = 0; i < n; i++) {\n    if (par[i] != -1) {\n      cout << i + 1 << ' ' << par[i] + 1 << '\\n';\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<ctime>\n#include<cmath>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<string>\n#include<vector>\n#include<bitset>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define rep(i,s,t) for(register int i=s;i<=t;++i)\n#define _rep(i,s,t) for(register int i=s;i>=t;--i)\n#define Rep(i,s,t) for(register int i=s;i<t;++i)\n#define go(x) for(register int e=las[x];e;e=nxt[e])\n#define re register\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define ub upper_bound\n#define lb lower_bound\n#define pii pair<int,int>\n#define ms(f,x) memset(f,x,sizeof f)\n#define mc(f,x) memcpy(f,x,sizeof f)\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\n#define gi(x) read(x)\n#define gii(x,y) read(x),read(y)\n#define giii(x,y,z) read(x),read(y),read(z)\nnamespace IO{\n    #define gc getchar()\n    #define pc(x) putchar(x)\n    template<typename T>inline void read(T &x){\n        x=0;int f=1;char ch=gc;while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=gc;}\n        while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=gc;x*=f;return;\n    }\n    template<typename T>inline void write(T x=0){\n        T wr[51];wr[0]=0;if(x<0)pc('-'),x=-x;if(!x)pc(48);\n        while(x)wr[++wr[0]]=x%10,x/=10;while(wr[0])pc(48+wr[wr[0]--]);return;\n    }\n}\nusing IO::read;\nusing IO::write;\ntypedef long long ll;\ntypedef double db;\ntypedef long double ld;\ntypedef unsigned long long ull;\nusing namespace std;\nconst int N=2e5+11;\nint n,ans;\nint sz[N],x[N],y[N];\nll a[N];\nstruct node{\n\tll d;\n\tint id;\n\tinline void in(){\n\t\tgi(d);\n\t}\n\tinline bool operator<(node A)const{\n\t\treturn d<A.d;\n\t}\n}p[N];\nint main(){\n\tgi(n);\n\trep(i,1,n)\n\t\tsz[i]=1;\n\trep(i,1,n)\n\t\tp[i].in(),p[i].id=i;\n\tsort(p+1,p+n+1);\n\trep(i,1,n)\n\t\ta[i]=p[i].d;\n\t_rep(i,n,2){\n\t\tint pos=lower_bound(a+1,a+n+1,p[i].d-n+2*sz[p[i].id])-a;\n\t\tif(a[pos]!=p[i].d-n+2*sz[p[i].id]||p[i].id==p[pos].id){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsz[p[pos].id]+=sz[p[i].id];\n\t\tx[++ans]=p[pos].id,y[ans]=p[i].id;\n\t}\n\trep(i,1,ans)\n\t\tprintf(\"%d %d\\n\",x[i],y[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::cerr;\nusing std::endl;\n\ntypedef long long ll;\n\ninline ll rd(){\n  ll x; scanf(\"%lld\",&x);\n  return x;\n}\n\nconst int N=1e5+233;\n\nint n;\nll D[N],S[N];\nstd::vector<std::pair<int,int>>ans;\nstd::map<ll,int>map;\nstd::vector<int> T[N];\n\nll dfs(int x,int fa,int dis){\n  ll ret=dis;\n  for(int y:T[x]) if(y!=fa)\n    ret+=dfs(y,x,dis+1);\n  return ret;\n}\n\nint main(){\n  //freopen(\"data\",\"r\",stdin);\n  n=rd();\n  for(int i=1;i<=n;++i){\n    D[i]=rd();\n    S[i]=1;\n    map[-D[i]]=i;\n  }\n  while(!map.empty()){\n    if(map.size()==1)\n      break;\n    int x=map.begin()->second;\n    map.erase(map.begin());\n    std::map<ll,int>::iterator it;\n    it=map.find(-(D[x]-n+2*S[x]));\n    if(it==map.end()){\n      puts(\"-1\");\n      return 0;\n    }\n    S[it->second]+=S[x];\n    ans.push_back({x,it->second});\n    T[x].push_back(it->second);\n    T[it->second].push_back(x);\n  }\n  int root=map.begin()->second;\n  if(dfs(root,0,0)!=D[root]){\n    puts(\"-1\");\n    return 0;\n  }\n  for(int i=0;i<n-1;++i)\n    printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <set>\n#include <vector>\n#include <numeric>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n    ios_base::sync_with_stdio(0);\n\n    int n;\n    cin >> n;\n    vector<pair<int, int> > v;\n    for (int i = 0, d; i < n; i++) {\n        cin >> d;\n        v.emplace_back(d, i);\n    }\n    vector<int> sz(n, 1);\n    sort(v.begin(), v.end());\n    vector<pair<int, int> > edges;\n    bool res = true;\n    for (auto it = v.end() - 1; res and it != v.begin(); it--) {\n        const int u = it->second;\n        const int next_d = it->first - (n - 2 * sz[u]);\n        const auto p = make_pair(next_d, 0);\n        auto i = lower_bound(v.begin(), it, p);\n        if (i == it or i->first != next_d) {\n            res = false;\n        }\n        else {\n            edges.emplace_back(u, i->second);\n            sz[i->second] += sz[u];\n        }\n    }\n    if (res) {\n        for (auto p : edges) {\n            cout << p.first + 1 << ' '\n                 << p.second + 1 << '\\n';\n        }\n    } \n    else {\n        cout << \"-1\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = int(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\nusing ll = long long;\nusing namespace std;\n\nvector<pair<int, int> > solve(int n, vector<ll> const & d) {\n    map<ll, int> index;\n    REP (i, n) {\n        index[d[i]] = i;\n    }\n\n    int root = index.begin()->second;\n    vector<pair<int, int> > edges;\n    vector<vector<int> > children(n);\n    vector<int> size(n, 1);\n    for (auto it = index.rbegin(); ; ++ it) {\n        ll d_i; int i; tie(d_i, i) = *it;\n        if (i == root) break;\n        int d_parent = d_i - n + 2 * size[i];\n        if (not index.count(d_parent)) {\n            return vector<pair<int, int> >();\n        }\n        int parent = index[d_parent];\n        edges.emplace_back(parent, i);\n        children[parent].push_back(i);\n        size[parent] += size[i];\n    }\n\n    vector<ll> d1(n);\n    function<void (int)> fold = [&](int i) {\n        for (int j : children[i]) {\n            fold(j);\n            d1[i] += d1[j] + size[j];\n        }\n    };\n    fold(root);\n    function<void (int, int)> reroot = [&](int i, int parent) {\n        if (parent != -1) {\n            d1[i] = d1[parent] - size[i] + (n - size[i]);\n        }\n        for (int j : children[i]) {\n            reroot(j, i);\n        }\n    };\n    reroot(root, -1);\n    if (d != d1) {\n        return vector<pair<int, int> >();\n    }\n\n    return edges;\n}\n\nint main() {\n    int n; cin >> n;\n    vector<ll> d(n);\n    REP (i, n) cin >> d[i];\n    auto edges = solve(n, d);\n    if (edges.empty()) {\n        cout << -1 << endl;\n    } else {\n        for (auto edge : edges) {\n            int i, j; tie(i, j) = edge;\n            cout << i + 1 << ' ' << j + 1 << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=100005;\nstruct node{\n\tll d; int sz,id;\n\tfriend bool operator < (node a,node b){\n\t\treturn a.d<b.d;\n\t}\n};\nset<node> s;\nvector<pii> ans;\nint d[N],n;\nll rem;\nvi e[N];\n\nvoid dfs(int u,int fa){\n\tfor(auto v:e[u])\n\t\tif(v!=fa){\n\t\t\td[v]=d[u]+1;\n\t\t\tdfs(v,u);\n\t\t}\n\trem-=d[u];\n}\n\nint main(){\n\tread(n);\t\n\trep(i,1,n){\n\t\tll tmp; read(tmp);\n\t\ts.insert((node){tmp,1,i});\n\t}\n\twhile(s.size()>=2){\n\t\tnode t=*(--s.end());\n\t\ts.erase(--s.end());\n\t\tset<node>::iterator it=s.lower_bound((node){t.d-n+2*t.sz,0});\n\t\tif(it==s.end()||it->d!=t.d-n+2*t.sz)\n\t\t\treturn puts(\"-1\"),0;\n\t\tint x=t.id,y=it->id;\n\t\tif(x>y)swap(x,y);\n\t\tans.pb(mp(x,y));\n\t\tnode v=*it;\n\t\tv.sz+=t.sz;\n\t\ts.erase(it);\n\t\ts.insert(v);\n\t}\n\tfor(auto x:ans)\n\t\te[x.fi].pb(x.se),e[x.se].pb(x.fi);\n\tint rt=s.begin()->id;\n\trem=s.begin()->d;\n\tdfs(rt,0);\n\tif(rem!=0)return puts(\"-1\"),0;\n\tsort(ans.begin(),ans.end());\n\tfor(auto x:ans)\n\t\tprintf(\"%d %d\\n\",x.fi,x.se);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)   FOR(i,0,n)\n#define LL long long\n\nint n;\nvector<LL> d,init_d;\nvector<LL> ind,width;\nvector<pair<int,int>> ans;\nvector<vector<int>> tree;\n\nLL dfs(int pos,LL cum){\n  LL ret = cum;\n  REP(i,tree[pos].size())\n    ret += dfs(tree[pos][i],cum+1);\n  return ret;\n}\n\nint main(){\n  cin>>n;\n  LL tmp;\n  REP(i,n){\n    cin>>tmp;\n    d.push_back(tmp);\n    init_d.push_back(tmp);\n  }\n  sort(d.begin(),d.end());\n  ind.resize(n);\n  REP(i,n){\n    int min_ind = distance(d.begin(),lower_bound(d.begin(),d.end(),init_d[i]));\n    ind[min_ind] = i+1;\n  }\n  REP(i,n){\n    width.push_back(1);\n  }\n  tree.resize(n);\n  REP(i,n-1){\n    LL s = d[n-1-i] - (n - 2*width[n-1-i]);\n    //cerr<<s<<endl;\n    int min_ind2 = distance(d.begin(),lower_bound(d.begin(),d.end(),s));\n    if(d[min_ind2] != s || s > d[n-1-i]){\n      cout<<-1<<endl;\n      return 0;\n     }\n    ans.push_back(make_pair(min_ind2,n-1-i));\n    tree[min_ind2].push_back(n-1-i);\n    //tree[n-1-i].push_back(min_ind2);\n    width[min_ind2] += width[n-1-i];\n  }\n  \n  if(d[0] != dfs(0,0)){\n    cout<<-1<<endl;\n    return 0;\n  }\n  \n  REP(i,ans.size())\n    cout<<ind[ans[i].first]<<\" \"<<ind[ans[i].second]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 100003\nusing namespace std;\nstruct edge{int to,next;}e[maxn<<1];\nint head[maxn],cnte,fa[maxn];\nvoid add(int u,int v){e[++cnte].to=v,e[cnte].next=head[u],head[u]=cnte;}\nint n,sz[maxn],chksz[maxn],s[maxn];\nlong long d[maxn],chksum[maxn];\nmap<long long,int> b;\nbool cmp(int x,int y){return d[x]<d[y];}\nvoid dfs(int u){\n\tchksz[u]=1;\n\tfor(int i=head[u];i;i=e[i].next){\n\t\tint v=e[i].to;\n\t\tif(v==fa[u])continue;\n\t\tdfs(v);\n\t\tchksz[u]+=chksz[v];\n\t\tchksum[u]+=chksum[v]+sz[v];\n\t}\n\tif(chksz[u]!=sz[u]){puts(\"-1\");exit(0);}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",d+i),s[i]=i;\n\tsort(s+1,s+n+1,cmp);\n\tfor(int i=1;i<=n;i++)b[d[i]]=i,sz[i]=1;\n\tfor(int i=n;i>=2;i--){\n\t\tint v=s[i],d_u=d[v]-(n-sz[v])+sz[v];\n\t\tif(!b.count(d_u)){puts(\"-1\");return 0;}\n\t\tint u=b[d_u];\n\t\tadd(u,v),add(v,u),fa[v]=u;\n\t\tsz[u]+=sz[v];\n\t}\n\tif(cnte!=(n-1)*2){puts(\"-1\");return 0;}\n\tdfs(s[1]);\n\tif(chksz[s[1]]!=n||chksum[s[1]]!=d[s[1]]){puts(\"-1\");return 0;}\n\tfor(int u=1;u<=n;u++){\n\t\tfor(int i=head[u];i;i=e[i].next){\n\t\t\tint v=e[i].to;\n\t\t\tif(v==fa[u])continue;\n\t\t\tprintf(\"%d %d\\n\",u,v);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\n\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\n\nconst int maxn=100111;\nint n,pa[maxn],sz[maxn];\nLL d[maxn];\npair<LL,int> vs[maxn];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",d+i);\n\t\tvs[i]=mp(d[i],i);\n\t\tsz[i]=1;\n\t}\n\tsort(vs+1,vs+n+1);for(int i=1;i<=n;i++)d[i]=vs[i].ff;\n\tfor(int i=n;i>=2;i--)\n\t{\n\t\tint dlt=(n-sz[i])-sz[i],id=lower_bound(d+1,d+n+1,d[i]-dlt)-d;\n\t\tif(id>=i||d[id]!=d[i]-dlt)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tpa[i]=id;\n\t\tsz[id]+=sz[i];\n\t}\n\tLL sum=0;\n\tfor(int i=1;i<=n;i++)sum+=sz[i]-1;\n\tif(sum!=d[1])\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=2;i<=n;i++)printf(\"%d %d\\n\",vs[pa[i]].ss,vs[i].ss);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = int(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\nusing ll = long long;\nusing namespace std;\n\nvector<pair<int, int> > solve(int n, vector<ll> const & d) {\n    map<ll, int> index;\n    REP (i, n) {\n        index[d[i]] = i;\n    }\n\n    int root = index.begin()->second;\n    vector<pair<int, int> > edges;\n    vector<vector<int> > children(n);\n    vector<int> size(n, 1);\n    for (auto it = index.rbegin(); ; ++ it) {\n        ll d_i; int i; tie(d_i, i) = *it;\n        if (i == root) break;\n        int d_parent = d_i - (n - size[i]) + size[i];\n        if (not index.count(d_parent)) {\n            return vector<pair<int, int> >();\n        }\n        int parent = index[d_parent];\n        edges.emplace_back(parent, i);\n        children[parent].push_back(i);\n        size[parent] += size[i];\n    }\n    return edges;\n\n    vector<ll> d1(n);\n    function<void (int)> fold = [&](int i) {\n        for (int j : children[i]) {\n            fold(j);\n            d1[i] += size[j] + d1[j];\n        }\n    };\n    fold(root);\n    function<void (int, int)> reroot = [&](int i, int parent) {\n        if (parent != -1) {\n            d1[i] = d1[parent] - size[i] + (n - size[i]);\n        }\n        for (int j : children[i]) {\n            reroot(j, i);\n        }\n    };\n    reroot(root, -1);\n    if (d != d1) {\n        return vector<pair<int, int> >();\n    }\n\n    return edges;\n}\n\nint main() {\n    int n; cin >> n;\n    vector<ll> d(n);\n    REP (i, n) cin >> d[i];\n    auto edges = solve(n, d);\n    if (edges.empty()) {\n        cout << -1 << endl;\n    } else {\n        for (auto edge : edges) {\n            int i, j; tie(i, j) = edge;\n            cout << i + 1 << ' ' << j + 1 << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <iostream>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cout<<#x<<\" :: \"<<x<<endl;\n#define debug2(x,y) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<endl;\n#define debug3(x,y,z) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<\"\\t\"<<#z<<\" :: \"<<z<<endl;\n\n#define boost ios::sync_with_stdio(0); cin.tie(0)\n\n#define fi first\n#define se second\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<ll, ll> pii;\n\nconst int N = 1e6 + 5;\n\n/***************************************************************************/\n\nll D[N];\nmap<ll, int> M;\nint sz[N];\nvector<pii> edges;\n\nint main() {\n\n\tboost;\n\tint n; cin>>n;\n\tfor(int i=1; i<=n; i++) {\n\t\tcin>>D[i];\n\t\tM[D[i]] = i;\n\t\tsz[i] = 1;\n\t}\n\n\tfor(auto it=M.rbegin(); (int) edges.size() < n-1 and it!=M.rend(); it++) {\n\t\tll d = it->fi;\n\t\tint p = it->se;\n\t\tll pard = d - n + 2 * sz[p];\n\t\tint par = M[pard];\n\t\tif(pard >= d or par == 0) break;\n\t\tsz[par] += sz[p];\n\t\tedges.pb(mp(par, p));\n\t}\n\n\tif((int) edges.size() < n-1) {\n\t\tcout<<\"-1\\n\";\n\t}\n\telse {\n\t\tfor(auto it : edges) {\n\t\t\tcout<<it.fi<<\" \"<<it.se<<\"\\n\";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\nvector<int> G[MAX_N];\n\npl D[MAX_N];\nll ts[MAX_N];\npi ans[MAX_N];\n\npl dist(int v, int p) {\n\tpl res(0, 1);\n\trep(i, 0, sz(G[v])) {\n\t\tint n = G[v][i];\n\t\tif(n == p) continue;\n\t\tpl tmp = dist(n, v);\n\t\tres.fst += tmp.fst + tmp.sec;\n\t\tres.sec += tmp.sec;\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N) {\n\t\tcin >> D[i].fst;\n\t\tD[i].fst *= -1;\n\t\tD[i].sec = i;\n\t}\n\trep(i, 0, N) ts[i] = 1;\n\tsort(D, D + N);\n\trep(i, 0, N - 1) {\n\t\tint at = lower_bound(D, D + N, pl(D[i].fst + (N - 2 * ts[i]), -inf)) - D;\n\t\tif(at == N || D[at].fst != D[i].fst + (N - 2 * ts[i]) || at <= i) {\n\t\t\tcout << \"-1\\n\"; return;\n\t\t}\n\t\tts[at] += ts[i];\n\t\tans[i] = pi(D[i].sec, D[at].sec);\n\t\tG[D[i].sec].pb(D[at].sec);\n\t\tG[D[at].sec].pb(D[i].sec);\n\t}\n\tif(dist(D[N - 1].sec, -1).fst != -D[N - 1].fst) {\n\t\tcout << \"-1\\n\"; return;\n\t}\n\trep(i, 0, N - 1) {\n\t\tcout << ans[i].fst + 1 << \" \" << ans[i].sec + 1 << \"\\n\";\n\t}\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <cmath>\n#include <bitset>\n#include <algorithm>\n#include <map>\n#include <vector>\ntypedef long long ll;\nusing namespace std;\nconst int maxn=101000;\nint n;\nll d[maxn];\nint size[maxn];\nll dis[maxn];\nmap<ll,int> mp;\nvector<int> G[maxn];\nll sum=0;\n\nvoid dfs1(int u,int fa){\n    for(int i=0;i<G[u].size();i++){\n        int v=G[u][i];\n        if(v==fa) continue;\n        dis[v]=dis[u]+1;\n        dfs1(v,u);\n    }\n    sum+=dis[u];\n}\n\nvoid dfs2(int u,int fa){\n    for(int i=0;i<G[u].size();i++){\n        int v=G[u][i];\n        if(v==fa) continue;\n        printf(\"%d %d\\n\",u,v);\n        dfs2(v,u);\n    }\n}\n\nint main(){\n    //初始化\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        scanf(\"%lld\",&d[i]);\n        mp[d[i]]=i;\n    }\n    sort(d+1,d+n+1);\n    for(int i=1;i<=n;i++) size[i]=1;\n    //构树\n    for(int i=n;i>=1;i--){\n        int k=mp[d[i]];\n        int tmp=n-2*size[k];\n        if(tmp<=0) {printf(\"-1\");return 0;}\n        ll ss=d[i]+tmp;\n        if(mp.count(ss)==0){printf(\"-1\\n\");return 0;}\n        int pos=mp[ss];\n        size[pos]+=size[k];\n        G[pos].push_back(k);\n        G[k].push_back(pos);\n    }\n    dis[mp[d[1]]]=0;\n    dfs1(mp[d[1]],-1);\n    if(sum!=d[1]){\n        printf(\"-1\\n\");\n    }else{\n        dfs2(1,-1);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=100005;\nint n,size[N],st[N],to[N<<1],tto[N],last[N],Next[N<<1],edge;\nlong long D;\nstruct note{\n\tlong long dis;\n\tint x;\n}d[N];\nbool cmp(note x,note y){\n\treturn x.dis>y.dis;\n}\nusing std::map;\nmap<long long,int> m;\nvoid add(int x,int y){\n\tto[++edge]=y;\n\tNext[edge]=last[x];\n\tlast[x]=edge;\n}\nint dfs(int x,int fa,long long now){\n\tD+=now;\n\tfor (int i=last[x];i;i=Next[i])\n\t\tif (to[i]!=fa)\n\t\t\tdfs(to[i],x,now+1);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) {\n\t\tscanf(\"%lld\",&d[i].dis);\n\t\td[i].x=i;\n\t\tm[d[i].dis]=i;\n\t}\n\tstd::sort(d+1,d+n+1,cmp);\n\tfor (int i=1;i<=n;i++) size[i]=1;\n\tfor (int i=1;i<n;i++){\n\t\tlong long dis=d[i].dis;\n\t\tint x=d[i].x;\n\t\tlong long t=dis-abs(n-2*size[x]);\n\t\tint fa=m.find(t)->second;\n\t\tif (fa==x || !fa){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsize[fa]+=size[x];\n\t\tst[i]=x,tto[i]=fa;\n\t\tadd(x,fa),add(fa,x);\n\t}\n\tdfs(d[n].x,0,0);\n\tif (D!=d[n].dis){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++) printf(\"%d %d\\n\",st[i],tto[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define N 500005\nusing namespace std;\nint n,cnt,a[N],sz[N],tmp[N],ansx[N],ansy[N];\nmap<int,int>b;\ninline bool cmp(int x,int y){return a[x]>a[y];}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%lld\",&a[i]),b[a[i]]=i,tmp[i]=i,sz[i]=1;\n\tsort(tmp+1,tmp+n+1,cmp);\n\tfor (int i=1;i<n;i++){\n\t\tint x=tmp[i];\n\t\tint dis=a[x]-(n-sz[x])+sz[x];\n\t\tif (!b[dis]) return puts(\"-1\"),0;\n\t\tint y=b[dis];\n\t\tsz[y]+=sz[x];ansx[++cnt]=x;ansy[cnt]=y;\n\t\tif (x==y) return puts(\"-1\"),0;\n\t}\n\tfor (int i=1;i<=cnt;i++) printf(\"%lld %lld\\n\",ansx[i],ansy[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n;\nconst int maxN = 1e5 + 10;\nll d[maxN];\nint sz[maxN];\nvector < int > g[maxN];\nvoid dfs(int v, int p, int he, ll& ans) {\n    ans += he;\n    for (int to : g[v]) {\n        if (to == p) continue;\n        dfs(to, v, he + 1, ans);\n    }\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> n;\n    vector < pair < int, int > > f;\n    for (int i = 1; i <= n; i++) {\n        cin >> d[i];\n        f.emplace_back(d[i], i);\n        sz[i] = 1;\n    }\n    sort(f.begin(), f.end());\n    vector < pair < int, int > > ed;\n    for (int i = n - 1; i >= 1; i--) {\n        if (sz[f[i].second] > n / 2) {\n            cout << -1;\n            return 0;\n        }\n        int need = f[i].first - n + 2 * sz[f[i].second];\n        int r = lower_bound(f.begin(), f.end(), make_pair(need, -1)) - f.begin();\n        if (f[r].first != need) {\n            cout << -1;\n            return 0;\n        }\n        ed.emplace_back(f[r].second, f[i].second);\n        sz[f[r].second] += sz[f[i].second];\n        g[f[r].second].emplace_back(f[i].second);\n        g[f[i].second].emplace_back(f[r].second);\n    }\n    int who = f[0].second;\n    ll ans = 0;\n    dfs(who, -1, 0, ans);\n    if (ans != d[who]) {\n        cout << -1;\n        return 0;\n    }\n    for (auto it : ed) {\n        cout << it.first << \" \" << it.second << '\\n';\n    }\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long ;\nstruct Node {\n    int i;\n    ll d;\n    Node() {}\n    Node(int _i, ll _d) : i(_i), d(_d) {}\n    bool operator<(const Node& _r) const {\n        return d > _r.d;\n    }\n};\n\nvoid solve() {\n    int n; cin >> n;\n    vector<int> p(n,-1), sz(n,1);\n    set<Node> s;\n    for (int i = 0; i < n; i++) {\n        ll d; cin >> d;\n        s.insert({i,d});\n    }\n    vector<vector<int>> g(n);\n    vector<pair<int, int>> e;\n    while ((int)s.size()>1) {\n        auto it = s.begin();\n        auto v = *it; s.erase(it);\n        ll target = v.d + 2*sz[v.i] - n; \n        auto jt = s.lower_bound({-1, target});\n        if (jt == s.end() || jt->d != target) {\n            cout << -1; return;\n        }\n        p[v.i] = jt->i;\n        sz[jt->i] += sz[v.i];\n        g[jt->i].emplace_back(v.i);\n        e.emplace_back(jt->i, v.i);\n    }\n    int root = -1;\n    for (int i = 0; i < n; i++) {\n        if (p[i] == -1) root = i;\n    }\n    function<ll(int)> dfs = [&](int u){\n        ll sum = sz[u]-1;\n        for (int v: g[u])\n            sum += dfs(v);\n        return sum;\n    };\n    auto it = s.begin();\n    if (sz[root] != n || it->d != dfs(root)) {\n        cout << -1; return;\n    }\n    for (auto& p: e) {\n        cout << p.first+1 << ' ' << p.second+1 << \"\\n\";\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <iostream>\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cout<<#x<<\" :: \"<<x<<endl;\n#define debug2(x,y) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<endl;\n#define debug3(x,y,z) cout<<#x<<\" :: \"<<x<<\"\\t\"<<#y<<\" :: \"<<y<<\"\\t\"<<#z<<\" :: \"<<z<<endl;\n\n#define boost ios::sync_with_stdio(0); cin.tie(0)\n\n#define fi first\n#define se second\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<ll, ll> pii;\n\nconst int N = 1e6 + 5;\n\n/***************************************************************************/\n\nll D[N];\nmap<ll, int> M;\nint sz[N];\nvector<pii> edges;\nvector<int> adj[N];\n\nll dfs(int v, int p, int dis) {\n\tll ans = dis;\n\tfor(auto it : adj[v]) {\n\t\tif(it == p) continue;\n\t\tans += dfs(it, v, dis+1);\n\t}\n\treturn ans;\n}\n\nint main() {\n\n\tboost;\n\tint n; cin>>n;\n\tfor(int i=1; i<=n; i++) {\n\t\tcin>>D[i];\n\t\tM[D[i]] = i;\n\t\tsz[i] = 1;\n\t}\n\n\tfor(auto it=M.rbegin(); (int) edges.size() < n-1 and it!=M.rend(); it++) {\n\t\tll d = it->fi;\n\t\tint p = it->se;\n\t\tll pard = d - n + 2 * sz[p];\n\t\tint par = M[pard];\n\t\tif(pard >= d or par == 0) break;\n\t\tsz[par] += sz[p];\n\t\tedges.pb(mp(par, p));\n\t\tadj[par].pb(p), adj[p].pb(par);\n\t}\n\tint v = M.begin()->se;\n\n\tif((int) edges.size() < n-1 or dfs(v, 0, 0) != D[v]) {\n\t\tcout<<\"-1\\n\";\n\t}\n\telse {\n\t\tfor(auto it : edges) {\n\t\t\tcout<<it.fi<<\" \"<<it.se<<\"\\n\";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 100233;\nint n, size[N], fa[N], dep[N];\npair<int, ll> p[N];\nmap<ll, int> q;\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%lld\", &p[i].second);\n    p[i].first = i;\n    q[p[i].second] = i;\n    size[i] = 1;\n  }\n  sort(p + 1, p + 1 + n, [&](pair<int, ll> a, pair<int, ll> b){return a.second < b.second;});\n  for (int i = n; i >= 2; i--) {\n    int x = p[i].first;\n    ll t = p[i].second + 2 * size[x] - n;\n    if (t >= p[i].second) return puts(\"-1\"), 0;\n    int y = q[t];\n    if (!y) return puts(\"-1\"), 0;\n    size[y] += size[x];\n    fa[x] = y;\n  }\n  ll t = 0;\n  for (int i = 2; i <= n; i++) {\n    int x = p[i].first;\n    dep[x] = dep[fa[x]] + 1;\n    t += dep[x];\n  }\n  if (t != p[1].second) return puts(\"-1\"), 0;\n  for (int i = 2; i <= n; i++) {\n    int x = p[i].first;\n    printf(\"%d %d\\n\", x, fa[x]);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "// ARC103F.cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 1e5 + 200;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint n, siz[MAX_N], id[MAX_N], fa[MAX_N], head[MAX_N], current;\nll D[MAX_N];\nset<ll> st[2];\nmap<ll, int> mp;\n\nstruct edge\n{\n    int to, nxt;\n} edges[MAX_N << 1];\n\nvoid addpath(int src, int dst)\n{\n    edges[current].to = dst, edges[current].nxt = head[src];\n    head[src] = current++;\n}\n\nll dfs(int u, int up)\n{\n    ll ret = 0;\n    for (int i = head[u]; i != -1; i = edges[i].nxt)\n        if (edges[i].to != up)\n            ret += dfs(edges[i].to, u) + siz[edges[i].to];\n    return ret;\n}\n\nint main()\n{\n    memset(head, -1, sizeof(head));\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%lld\", &D[i]), mp[D[i]] = i, siz[i] = 1, id[i] = i;\n    sort(id + 1, id + 1 + n, [](const int &rhs1, const int &rhs2) { return D[rhs1] > D[rhs2]; });\n    for (int i = 1; i < n; i++)\n    {\n        int u = id[i];\n        ll transfer = D[u] - (n - siz[u]) + siz[u];\n        if (mp.count(transfer) == 0)\n            puts(\"-1\"), exit(0);\n        fa[u] = mp[transfer], siz[fa[u]] += siz[u], addpath(fa[u], u), addpath(u, fa[u]);\n    }\n    if (dfs(id[n], 0) == D[id[n]])\n    {\n        for (int i = 1; i <= n; i++)\n            if (fa[i] != 0)\n                printf(\"%d %d\\n\", i, fa[i]);\n    }\n    else\n        puts(\"-1\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 100005\n#define ll long long\nll read() {\n    ll s=0,w=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9')\n\t{\n\t    if(ch=='-') w=-1;\n\t    ch=getchar();\n\t}\n    while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48),ch=getchar();\n    return s*w;\n}\nmap<ll,int> ap;\nstruct node{\n    ll d;\n    int id;\n}a[M];\nbool cmp(node p1,node p2) {return p1.d>p2.d;}\nstruct edge{\n    int u,v;\n    edge(int r_u=0,int r_v=0) {u=r_u,v=r_v;}\n}e[M];\nint cnt;\nint n,sz[M];\nvoid work() {\n    int tp=0;\n    for(int i=1;i<=n;i++) ap[a[i].d]=a[i].id,sz[i]=1;\n    for(int i=1;i<n;i++)\n\t{\n\t    ll d_F=a[i].d-n+2*sz[a[i].id];\n\t    if(d_F<0||d_F>=a[i].d||ap[d_F]==0) {tp=1;break ;}\n\t    sz[ap[d_F]]+=sz[a[i].id];\n\t    e[++cnt]=edge(ap[d_F],a[i].id);\n\t}\n    if(tp) cout<<-1<<'\\n';\n    else for(int i=1;i<=cnt;i++) cout<<e[i].u<<' '<<e[i].v<<'\\n';\n}\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;i++) {a[i].d=read();a[i].id=i;}\n    sort(a+1,a+n+1,cmp);\n    work();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nThough leaves are many, the root is one;\nThrough all the lying days of my youth\nI swayed my leaves and flowers in the sun,\nNow many I wither into the truth.\n-- William Butler Yeats\nµ±»ªÃÀµÄÒ¶Æ¬Âä¾¡£¬ÉúÃüµÄÂöÂç²ÅÀúÀú¿É¼û\n*/ \n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <string.h>\n#include <stack>\n#define Endl endl\n#define mp make_pair\n#define ll long long \n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define over(A) {cout<<A<<endl;exit(0);}\n#define all(A) A.begin(),A.end()\n#define ceil(a,b) ((a-1)/b+1)\n#define srand() mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n#define rand(l,r) uniform_int_distribution<int>(l,r)(rng)\ntypedef unsigned long long ull;\nconst int inf=1039074182;\nusing namespace std;\nll n;\nll d[100005];\nmap <ll,ll> m;\npair<ll,ll> p[100005];\nll sub[100005];\nll sz[100005];\nvector <pair<ll,ll> >res;\nvector <int>vec[100005];\nll dp[100005];\n\nint dfs(int x,int p=-1)\n{\n\tsz[x]=1;\n\tfor(int i=0;i<vec[x].size();i++)\n\t{\n\t\tif(vec[x][i]==p) continue;\n\t\tsz[x]+=dfs(vec[x][i],x);\n\t}\n\treturn sz[x];\n}\n\nint go(int x,int p=-1)\n{\n\tdp[x]=sz[x]-1;\n\tfor(int i=0;i<vec[x].size();i++)\n\t{\n\t\tif(vec[x][i]==p) continue;\n\t\tdp[x]+=go(vec[x][i],x);\n\t}\n\treturn dp[x];\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\",\"r\",stdin);\n\tios_base::sync_with_stdio(false);\n\tcin>>n;\n\tfor(ll i=0;i<n;i++)\n\t{\n\t\tcin>>d[i];\n\t\tm[d[i]]=i;\n\t\tp[i].first=d[i];\n\t\tp[i].second=i;\n\t\tsz[i]=1;\n\t}\n\tsort(p,p+n);\n\treverse(p,p+n);\n\tmemset(sub,-1,sizeof(sub));\n\tfor(ll i=0;i<n-1;i++)\n\t{\n\t\tll de=p[i].first;\n\t\tll x=p[i].second;\n\t\tsub[x]=n-sz[x]*2;\n//\t\tcout<<x+1<<'-'<<de<<'-'<<sub[x]<<'-'<<sz[i]<<endl;\n\t\tif(sub[x]==0) over(\"-1\");\n\t\tif(m.find(de-sub[x])==m.end()) over(\"-1\");\n\t\tll par=m[de-sub[x]];\n\t\tsz[par]+=sz[x];\n\t\tdp[par]+=dp[x];\n\t\tres.push_back(mp(x,par));\n\t}\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tvec[res[i].first].push_back(res[i].second);\n\t\tvec[res[i].second].push_back(res[i].first);\n\t}\n\tdfs(p[n-1].second);\n\tgo(p[n-1].second);\n//\tcout<<dp[p[n-1].second]<<endl;\n\tif(dp[p[n-1].second]!=p[n-1].first) over(\"-1\");\n\tfor(ll i=0;i<n-1;i++)\n\t{\n\t\tcout<<res[i].first+1<<' '<<res[i].second+1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\n//ll mod=1000000007;\nll mod=998244353;\nll inf=1000000000000000000;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(int i=n;i>=m;i--)\nll lmax(ll a,ll b){\n    if(a<b)return b;\n    else return a;\n}\nll lmin(ll a,ll b){\n    if(a<b)return a;\n    else return b;\n}\nint main(){\n    ll n;cin>>n;\n    ll d[n];\n    vector<pll> v;\n    ll num;\n    ll mi=inf;\n    rep(i,0,n){\n        cin>>d[i];\n        v.push_back(make_pair(d[i],i));\n        if(mi>d[i]){\n            mi=d[i];\n            num=i;\n        }\n    }\n  sort(v.begin(),v.end());\n    ll root=v[0].first;\n    ll now=-1;\n    ll sa=-1;\n    ll par=-1;\n    vector<pll> ans;\n  ll qq=1;\n  bool used[n];fill(used,used+n,false);\n    for(;;){\n      if(qq==n)break;\n        if(now==-1){\n            pll p=v[qq];\n            if(used[p.second]){\n              qq++;\n              continue;\n            }\n            now=p.first;\n            ll ban=p.second;\n            //cout<<now<<endl;\n            if(now>root+n-2){\n                cout<<-1<<endl;\n                return 0;\n            }\n            sa=now-root;\n          used[p.second]=true;\n            ans.push_back(make_pair(num,ban));\n            par=ban;\n        }\n        else{\n          pll g=make_pair(now+sa+2,0);\n            ll y=lower_bound(v.begin(),v.end(),g)-v.begin();\n            if(y==n){\n                if(sa!=n-2){\n                    cout<<-1<<endl;\n                    return 0;\n                }\n                now=-1;\n                sa=-1;\n              qq++;\n            }\n            else{\n                pll p=v[y];\n                if(p.first!=now+sa+2){\n                    cout<<-1<<endl;\n                    return 0;\n                }\n                ans.push_back(make_pair(par,p.second));\n                par=p.second;\n                now=p.first;\n                sa+=2;\n                used[p.second]=true;\n            }\n        }\n        \n        //cout<<now<<\" \";\n    }\n    rep(i,0,ans.size()){\n        if(ans[i].first>ans[i].second)swap(ans[i].first,ans[i].second);\n    }\n    sort(ans.begin(),ans.end());\n    rep(i,0,ans.size())cout<<ans[i].first+1<<\" \"<<ans[i].second+1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define title \"title\"\n#define ll long long\n#define ull unsigned ll\n#define fix(x) fixed<<setprecision(x)\n#define pii pair<int,int>\n#define vint vector<int>\n#define pb push_back\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define red(i,a,b) for(int i=(a);i>=(b);i--)\n#define db double\n#define ld long db\nusing namespace std;\nvoid Freopen(){\n\tfreopen(title\".in\",\"r\",stdin);\n\tfreopen(title\".out\",\"w\",stdout);\n}\nll read(){\n\tll g=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch){if(ch=='-')f=-1;ch=getchar();}\n\twhile('0'<=ch&&ch<='9'){g=g*10+ch-'0';ch=getchar();}\n\treturn g*f;\n}\nconst int N=1e5+5;\nmap<ll,int>id;\nll a[N],ans;\nint n,siz[N];\nvint G[N];\nvoid dfs(int x,int dis){ans+=dis;for(auto y:G[x])dfs(y,dis+1);}\nsigned main(){\n\t//freopen(\"a\",\"r\",stdin);\n\tn=read();rep(i,1,n)a[i]=read();\n\tsort(a+1,a+n+1,[](int a,int b){return a>b;});\n\trep(i,1,n)id[a[i]]=i,siz[i]=1;\n\trep(i,1,n-1){\n\t\tint to=a[i]+siz[i]-(n-siz[i]);\n\t\tif(!id[to])return cout<<-1,signed();\n\t\tG[id[to]].pb(i);siz[id[to]]+=siz[i];\n\t}dfs(n,0);if(ans^a[n])return cout<<-1,signed();\n\trep(i,1,n)for(auto j:G[i])cout<<i<<' '<<j<<'\\n';\n\treturn signed();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) {cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl;}\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}\nbool operator<(const TRI&_)const{return(fi==_.fi)?((se==_.se)?(th<_.th):(se<_.se)):(fi<_.fi);}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<ll, ll> P;\n\nconst int MAX_N = 100005;\n\nunordered_map<ll, int> mp;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    set<P> st;\n    rep(i,n){\n        ll d;\n        cin >> d;\n        mp[d] = i;\n        st.insert(P(d, 1));\n    }\n    vector<pair<int, int> > vec;\n    while(len(st) > 1){\n        auto p = *(--st.end());\n        st.erase(--st.end());\n        auto it = st.lower_bound(P(p.fi+2*p.se-n, -INF));\n        if(it->fi != p.fi+2*p.se-n){\n            cout << \"-1\\n\";\n            return 0;\n        }\n        vec.emplace_back(mp[p.fi], mp[it->fi]);\n        P nw = P(it->fi, it->se + p.se);\n        st.erase(it);\n        st.insert(nw);\n    }\n    rep(i,n-1){\n        cout << vec[i].fi+1 << \" \" << vec[i].se+1 << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint n;\nvector<pair<ll,int>> v;\nvector<int> fa,siz;\nvector<vector<int>> G;\nll tot;\nvoid dfs(int u,int par,ll d){\n    tot += d;\n    for(int v : G[u]){\n        if(v == par) continue;\n        dfs(v,u,d + 1);\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n    cin>>n;\n    v.resize(n + 1);\n    fa.resize(n + 1);\n    siz.resize(n + 1);\n    G.resize(n + 1);\n    fill(fa.begin(),fa.end(),0);\n    fill(siz.begin(),siz.end(),1);\n    for(int i = 1; i <= n; i++) {\n        cin>>v[i].first;\n        v[i].second = i;\n    }\n    sort(v.begin() + 1,v.end(),[](auto x,auto y){ return x.first > y.first;});\n    for(int i = 1; i < n; i++){\n        ll d = v[i].first;\n        int sz = siz[v[i].second];\n        ll d_nxt = d - n + 2 * sz;\n        int lo = i + 1, hi = n;\n        int ans_pos = 0;\n        while(lo <= hi){\n            int mid = lo + hi >> 1;\n            if(v[mid].first > d_nxt){\n                lo = mid + 1;\n            }\n            else if(v[mid].first < d_nxt){\n                hi = mid - 1;\n            }\n            else {\n                ans_pos = mid;\n                break;\n            }\n        }\n        if(ans_pos == 0){\n            cout<<-1<<endl;\n            exit(0);\n        }\n        int u = v[i].second;\n        int f = v[ans_pos].second;\n        fa[u] = f;\n        G[f].emplace_back(u);\n        G[u].emplace_back(f);\n        siz[f] += siz[u];\n    }\n    dfs(1,0,0);\n    if(tot != v[n].first){\n        cout<<-1<<endl;\n        exit(0);\n    }\n    for(int i = 1; i < n; i++){\n        cout<<v[i].second<<\" \"<<fa[v[i].second]<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<iomanip>\n#include<cstring>\n#include<complex>\n#include<vector>\n#include<cstdio>\n#include<string>\n#include<bitset>\n#include<ctime>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#define Cpy(x,y) memcpy(x,y,sizeof(x))\n#define Set(x,y) memset(x,y,sizeof(x))\n#define FILE \"a\"\n#define mp make_pair\n#define pb push_back\n#define RG register\n#define il inline\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef vector<int>VI;\ntypedef long long ll;\ntypedef double dd;\nconst int N=1<<17;\nconst int mod=998244353;\nconst int base=26;\nconst dd eps=1e-6;\nconst int inf=2147483647;\nconst ll INF=1ll<<60;\nconst ll P=100000;\nil ll read(){\n  RG ll data=0,w=1;RG char ch=getchar();\n  while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n  if(ch=='-')w=-1,ch=getchar();\n  while(ch<='9'&&ch>='0')data=data*10+ch-48,ch=getchar();\n  return data*w;\n}\n\nil void file(){\n  srand(time(NULL)+rand());\n  freopen(FILE\".in\",\"r\",stdin);\n  freopen(FILE\".out\",\"w\",stdout);\n}\n\nint n,o[N],sz[N],m;\nstruct node{int d,id;}t[N];bool cmp_d(node a,node b){return a.d<b.d;}\nil void er(){puts(\"-1\");exit(0);}\nstruct edge{int u,v;}E[N];\nint main()\n{\n  n=read();\n  for(RG int i=1;i<=n;i++){t[i].d=read();t[i].id=i;}\n  sort(t+1,t+n+1,cmp_d);\n  for(RG int i=1;i<=n;i++)o[i]=t[i].d,sz[i]=1;\n  for(RG int i=n,p;i!=1;i--){\n    p=lower_bound(o+1,o+n+1,t[i].d-n+2*sz[i])-o;\n    if(o[p]!=t[i].d-n+2*sz[i])er();\n    E[++m]=(edge){t[p].id,t[i].id};sz[p]+=sz[i];\n  }\n  for(RG int i=1;i<=m;i++)printf(\"%d %d\\n\",E[i].u,E[i].v);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#define Maxn 1000008 \nusing namespace std;\ntypedef long long ll;\n\nint n,cnt;\nll d;\nint son[Maxn];\nmap <ll,int> M;\n\nstruct node{\n\tint num;\n\tll val;\n}N[Maxn];\n\nbool cmp(node a,node b){\treturn a.val > b.val;}\n\nint U[Maxn],V[Maxn];\n\nint main()\n{\n\tmemset(son,0,sizeof(son));\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\tscanf(\"%lld\",&d);\n\t\tM[d] = i;\n\t\tN[i].num = i,N[i].val = d;\n\t}\n\tsort(N+1,N+1+n,cmp);\n\tmap<ll,int>::iterator iter;;\n\tfor(int i = 1;i < n;i ++)\n\t{\n\t\tint u = N[i].num;\n\t\titer = M.find(N[i].val - n + 2 + (son[u] << 1));\n\t\tif(iter == M.end()) continue;\n\t\tint v = iter->second;\n\t\tson[v] += son[u]+1;\n\t\tU[cnt] = u,V[cnt++] = v;\n\t}\n//\tfor(int i = 1;i <= n;i ++) printf(\"son[N[%d].num] = %d\\n\",i,son[N[i].num]);\n\tif(cnt != n - 1) printf(\"-1\\n\");\n\telse\n\t\tif(son[N[n].num] == n - 1) \n\t\t\tfor(int i = 0;i < cnt;i ++)\n\t\t\t\tprintf(\"%d %d\\n\",U[i],V[i]);\n\t\telse printf(\"-1\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define re register\n#define gc getchar\n#define pc putchar\n#define cs const\n\ninline\nll getint(){\n\tre ll num;\n\tre char c;\n\twhile(!isdigit(c=gc()));num=c^48;\n\twhile(isdigit(c=gc()))num=(num<<1)+(num<<3)+(c^48);\n\treturn num;\n}\n\ninline\nvoid outint(int a){\n\tstatic char ch[13];\n\tif(a==0)pc('0');\n\twhile(a)ch[++ch[0]]=a-a/10*10,a/=10;\n\twhile(ch[0])pc(ch[ch[0]--]^48);\n}\n\ncs int N=100005;\n\nint last[N],nxt[N],to[N],ecnt;\ninline\nvoid addedge(int u,int v){\n\tnxt[++ecnt]=last[u],last[u]=ecnt,to[ecnt]=v;\n}\n\nmap<ll,int> id;\nint n;\nll d[N];\nint siz[N];\n\nint dist[N];\ninline\nvoid dfs(int u){\n\tfor(int re e=last[u],v=to[e];e;v=to[e=nxt[e]]){\n\t\tdist[v]=dist[u]+1;\n\t\tdfs(v);\n\t}\n}\n\nvector<pair<int,int> > edge;\n\nsigned main(){\n\tn=getint();\n\tfor(int re i=1;i<=n;++i)d[i]=getint(),id[d[i]]=i;\n\t\n\tsort(d+1,d+n+1);\n\tfor(int re i=1;i<=n;++i)siz[i]=1;\n\t\n\tfor(int re i=n;i>1;--i){\n\t\tint u=id[d[i]];\n\t\tint tmp=n-2*siz[u];\n\t\tif(tmp<=0)return puts(\"-1\"),0; \n\t\tll t=d[i]-tmp;\n\t\tif(id.count(t)==0)return puts(\"-1\"),0;\n\t\tint pos=id[t];\n\t\taddedge(pos,u);\n\t\tsiz[pos]+=siz[u];\n\t\tedge.push_back(make_pair(pos,u));\n\t}\n\tll sum=0;\n\tdfs(id[d[1]]);\n\tfor(int re i=1;i<=n;++i){\n\t\tsum+=dist[i];\n\t}\n\tif(sum!=d[1])return puts(\"-1\"),0;\n\tfor(int re i=0;i<edge.size();++i)outint(edge[i].first),pc(' '),outint(edge[i].second),pc('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// comment\n// 가장 큰게 리프였다는 사실을 알았으면 해볼만 했을지도..\n// 가장 작은 값을 기준으로 트리를 만들면 밑으로 갈수록 점점 증가한다라는 사실을 인지하는 능력?\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define SZ(v) ((int)(v).size())\n#define ALL(v) (v).begin(),(v).end()\n#define one first\n#define two second\nusing ll = long long;\nusing pi = pair<int, int>;\nusing pli = pair<ll, int>;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 1ll * INF * INF;\n\nconst int MAX_N = 1e5 + 100;\n\nint N, Ix[MAX_N];\nll Ds[MAX_N];\nint S[MAX_N];\n\nint findD(ll d) {\n\tint ix = lower_bound(Ds+1, Ds+N+1, d) - Ds;\n\tif(Ds[ix] == d) return ix;\n\treturn -1;\n}\n\nint main() {\n\tcin >> N;\n\tvector<pli> temp;\n\tfor(int i=1; i<=N; i++) {\n\t\tscanf(\"%lld\", &Ds[i]);\n\t\ttemp.emplace_back(Ds[i], i);\n\t}\n\tsort(Ds+1, Ds+N+1);\n\tsort(ALL(temp));\n\tfor(int i=0; i<N; i++) Ix[i+1] = temp[i].two;\n\tfor(int i=1; i<=N; i++) S[i] = 1;\n\t\n\tvector<pi> Ans;\n\t//for(int i=1; i<=N; i++) printf(\"%lld \", Ds[i]); puts(\"\");\n\tfor(int i=N; i>=2; i--) {\n\t\tll pd = Ds[i] + 2*S[i] - N;\n\t\tint ix = findD(pd);\n\t\t//printf(\"%lld [%lld + 2*%d - %d] %d\\n\", pd, Ds[i], S[i], N, ix);\n\t\tif(ix == -1 || ix == i) return puts(\"-1\") < 0;\n\t\tS[ix] += S[i];\n\t\tAns.emplace_back(Ix[ix], Ix[i]);\n\t}\n\tfor(auto p: Ans) {\n\t\tint x, y; tie(x, y) = p;\n\t\tprintf(\"%d %d\\n\", x, y);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid err() {\n  cout << -1 << endl;\n  exit(0);\n}\nint main() {\n  int n;\n  cin >> n;\n  vector<pair<int, int>> di(n);\n  for (int i = 0; i < n; i++) {\n    int d;\n    cin >> d;\n    di[i] = {d, i};\n  }\n  sort(di.begin(), di.end());\n  vector<int> sz(n, 1), prt(n);\n  vector<pair<int, int>> edg;\n  for (int h = n - 1; h > 0; h--) {\n    auto const& e = di[h];\n    int d = e.first;\n    int i = e.second;\n    int prtv = d - n + 2 * sz[i];\n    auto it = lower_bound(di.begin(), di.end(), make_pair(prtv, 0));\n    if (it->first != prtv) err();\n    prt[i] = it->second;\n    if (i == prt[i]) err();\n    sz[prt[i]] += sz[i];\n    edg.emplace_back(min(i, prt[i]), max(i, prt[i]));\n  }\n  sort(edg.begin(), edg.end());\n  for (auto const & e : edg) {\n    cout << e.first + 1 << ' ' << e.second + 1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=100005;\nint n;\nint par[maxn],sz[maxn],ord[maxn];\nll d[maxn];\nmap<ll,int>rev;\nbool cmp(int a,int b){\n\treturn d[a]<d[b];\n} \n\nint main(){\n\tscanf(\"%d\",&n);\n\tREP(i,n){\n\t\tscanf(\"%lld\",&d[i]);\n\t\tord[i]=i;\n\t\trev[d[i]]=i;\n\t}\n\tsort(ord+1,ord+1+n,cmp);\n\tfor(int i=n;i>1;i--){\n\t\tint x=ord[i];\n\t\tif(sz[x]+1>=n||!rev.count(2*(sz[x]+1)+d[x]-n)){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint y=rev[2*(sz[x]+1)+d[x]-n];\n\t\tpar[x]=y;\n\t\tsz[y]+=sz[x]+1;\n\t}\n\tREP(i,n)if(!par[i]){\n\t\tif(sz[i]+1!=n||i!=ord[1]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tREP(i,n)if(par[i])printf(\"%d %d\\n\",par[i],i);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  \n  int n;\n  cin >> n;\n  vector<long long> d(n);\n  for (int i = 0; i < n; i++) {\n    cin >> d[i];\n  }\n\n  vector<int> ord(n);\n  iota(ord.begin(), ord.end(), 0);\n  sort(ord.begin(), ord.end(), [&](int i, int j) { return d[i] > d[j]; });\n  int rt = ord.back(); ord.pop_back();\n\n  map<long long, int> mp;\n  for (int i = 0; i < n; i++) {\n    mp[d[i]] = i;\n  }\n  vector<int> sz(n, 1), par(n, -1);\n  vector<vector<int>> g(n);\n\n  for (auto i : ord) {\n    long long par_d = d[i] + sz[i] - (n - sz[i]);\n    if (mp.count(par_d) == 0 || mp[par_d] == i || par[mp[par_d]] != -1) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n    par[i] = mp[par_d];\n    g[par[i]].push_back(i);\n    sz[par[i]] += sz[i];\n  }\n\n  // check dist[rt]\n  long long real_d = 0;\n  queue<pair<int,int>> q;\n  q.emplace(rt, 0);\n  while (q.size()) {\n    auto v = q.front(); q.pop();\n    real_d += v.second;\n    for (auto u : g[v.first]) {\n      q.emplace(u, v.second + 1);\n    }\n  }\n  if (d[rt] != real_d) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n\n  for (int i = 0; i < n; i++) {\n    if (par[i] != -1) {\n      cout << i + 1 << ' ' << par[i] + 1 << '\\n';\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long dfs(int nd, vector<long long> &vis, vector<vector<int>> &adjList)\n{\n  vis[nd] += 1;\n  long long ans = 0;\n  for(int cd : adjList[nd])\n  {\n    if(!vis[cd])\n    {\n      ans += dfs(cd, vis, adjList);\n      vis[nd] += vis[cd];\n    }\n  }\n  ans += vis[nd] - 1;\n  return ans;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  long long n;\n  cin >> n;\n  vector<pair<long long, int>> d(n);\n  vector<long long> sz(n, n);\n  for(int i = 0; i < n; i++)\n  {\n    cin >> d[i].first;\n    d[i].second = i + 1;\n  }\n  sort(d.begin(), d.end());\n  vector<pair<int, int>> ans;\n  vector<vector<int>> adjList(n + 1);\n  for(int i = n - 1; i > 0; i--)\n  {\n    long long dval = d[i].first + (n - sz[i] + 1) - (sz[i] - 1);\n    int pr = lower_bound(d.begin(), d.end(), make_pair(dval, 0)) - d.begin();\n    if(pr >= i || d[pr].first != dval)\n    {\n      cout << \"-1\" << endl;\n      return 0;\n    }\n    ans.push_back({d[i].second, d[pr].second});\n    adjList[d[i].second].push_back(d[pr].second);\n    adjList[d[pr].second].push_back(d[i].second);\n    sz[pr] -= (n - sz[i] + 1);\n  }\n  vector<long long> vis(n + 1, 0);\n  long long ver = dfs(d[0].second, vis, adjList);\n  if(d[0].first != ver)\n  {\n    cout << \"-1\" << endl;\n    return 0;\n  }\n  for(int i = 0; i < n - 1; i++)\n  {\n    cout << ans[i].first << \" \" << ans[i].second << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n题意：问能否构造出一棵树，使得对于某点i，到其他所有点的距离和为Di。Di各不相同。 \n如果已知x的size，那么x的父亲的Di=Dx-n+2*size[x],唯一还原\n我们需要从底往上构造\n由于一棵树一定有一个点到其他所有点的距离最小，其余点离此点距离越远，Di越大\n将Di从大到小排序，父亲一定在儿子之后被统计 \n*/\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll; \nconst int N=100005;\nint n,size[N],fa[N];\nmap<ll,int> mp;\nstruct node{int id;ll dis;}p[N];\nbool cmp(const node &A,const node &B){return A.dis>B.dis;}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%lld\",&p[i].dis),p[i].id=i,mp[p[i].dis]=i;\n\tsort(p+1,p+n+1,cmp);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tsize[p[i].id]++;\n\t\tll fa_Di=p[i].dis-n+2*size[p[i].id];\n\t\tif (!mp.count(fa_Di)) return puts(\"-1\"),0;else fa[p[i].id]=mp[fa_Di];\n\t\tif (fa[p[i].id]==p[i].id) return puts(\"-1\"),0;\n\t\tsize[fa[p[i].id]]+=size[p[i].id];\n\t}\n\tfor (int i=1;i<=n;i++) \n\t  if (fa[i]) printf(\"%d %d\\n\",i,fa[i]); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <cctype>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}\n\twhile (isdigit(ch)){x=x*10+ch-48;ch=getchar();}\n\treturn x*f;\n}\n\npair <long long,int> D[100050];\n\npair <int,int> edge[100050];\n\nvector <int> G[100050];\n\nint n,size[100050],tot;\n\nlong long dis[100050];\n\ninline void dfs(int u,int fa)\n{\n\tfor (int i=0;i<G[u].size();i++)\n\t{\n\t\tint v=G[u][i];\n\t\tif (v!=fa)\n\t\t{\n\t\t\tdis[v]=dis[u]+1;\n\t\t\tdfs(v,u);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tn=read();\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint d=read();\n\t\tD[i]={d,i};\n\t\tsize[i]=1;\n\t}\n\tsort(D+1,D+n+1);\n\treverse(D+1,D+n+1);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tlong long delta=D[i].first-n+2*size[i];\n\t\tint l=1,r=n+1,pos=0; \n\t\twhile (l<=r)\n\t\t{\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif (D[mid].first<=delta)\n\t\t\t{\n\t\t\t\tr=mid-1;\n\t\t\t\tpos=mid;\n\t\t\t}\n\t\t\telse\n\t\t\t\tl=mid+1;\n\t\t}\n\t\t//cout << D[pos].first << \" \" << delta << endl;\n\t\tif (D[pos].first!=delta)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint u=D[i].second,v=D[pos].second;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t\tedge[++tot]={u,v};\n\t\tsize[pos]+=size[i];\n\t}\t\n\tdfs(D[n].second,0);\n\tlong long sum=0;\n\tfor (int i=1;i<=n;i++)\n\t\tsum+=dis[i];\n\tif (sum==D[n].first)\n\t{\n\t\tfor (int i=1;i<=tot;i++)\n\t\t\tcout << edge[i].first << \" \" << edge[i].second << endl;\n\t}\n\telse\n\t\tputs(\"-1\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define x first\n#define y second\n#define iter iterator\n#define riter reversed_iterator\n#define y1 Lorem_ipsum_\n#define tm dolor_sit_amet_\n#define pii pair<int,int>\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int mxN = 1e5;\nint n,en;\nstruct Edge {int v,nxt;} e[mxN*2+3]; int fe[mxN+3];\nllong d[mxN+3]; map<llong,int> mp;\nint id[mxN+3];\nint sz[mxN+3];\nvector<pii> way;\n\nbool cmp(int x,int y) {return d[x]<d[y];}\n\nvoid addedge(int u,int v) {en++; e[en].v = v; e[en].nxt = fe[u]; fe[u] = en;}\n\nllong dfs(int u,int x)\n{\n\tllong ret = x;\n\tfor(int i=fe[u]; i; i=e[i].nxt)\n\t{\n\t\tint v = e[i].v;\n\t\tret += dfs(v,x+1);\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tn = read(); for(int i=1; i<=n; i++) id[i] = i;\n\tfor(int i=1; i<=n; i++) {scanf(\"%lld\",&d[i]); mp[d[i]] = i;}\n\tsort(id+1,id+n+1,cmp);\n\tfor(int i=1; i<=n; i++) sz[i] = 1;\n\tfor(int i=n; i>1; i--)\n\t{\n\t\tint u = id[i]; d[u] -= n-2ll*sz[u];\n\t\tif(!mp.count(d[u])) {puts(\"-1\"); return 0;}\n\t\tint v = mp[d[u]]; sz[v] += sz[u]; way.push_back(mkpr(u,v)); addedge(v,u);\n\t}\n\tif(dfs(id[1],0)!=d[id[1]]) {puts(\"-1\"); return 0;}\n\tfor(int i=0; i<n-1; i++) {printf(\"%d %d\\n\",way[i].x,way[i].y);}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#define jizz ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define pb push_back\n#define F first\n#define S second\n#define MP make_pair\n#define ET cout << \"\\n\"\n#define ALL(v) v.begin(),v.end()\n#define MEM(i,j) memset(i,j,sizeof i)\n#define DB(a,s,e) {for(int i=s;i<e;i++) cout << a[i] << \" \";ET;}\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nbitset<100001> vis;\nmultiset<pll> s;\nvector<pll> v;\npll arr[100001],tarr[100001];\nll w[100001];\n\nint main()\n{jizz\n\tll n,x,c=0,t;\n\tcin >> n;\n\tfor(int i=1;i<=n;++i)\n\t\tcin >> x,s.insert(tarr[i]=arr[i]=MP(x,i)),w[i]=1;\n\tsort(tarr+1,tarr+n+1);\n\tfor(int i=n;i>0;--i)\n\t\tif(!vis[tarr[i].S])\n\t\t{\n\t\t\tx=tarr[i].S;\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\t//cout << x << \" \" << w[x] << \" \" << arr[x].F << \" \" << arr[x].F-n+w[x]*2 << \"\\n\";\n\t\t\t\tauto p=s.lower_bound(MP(arr[x].F-n+w[x]*2,-1));\n\t\t\t\tif(p==s.end()||p->F!=arr[x].F-n+w[x]*2)\n\t\t\t\t\tbreak;\n\t\t\t\t//cout << x << \" -> \" << p->S << \"*\\n\";\n\t\t\t\ts.erase(s.find(MP(arr[x].F,arr[x].S)));\n\t\t\t\t//cout << x << \" -> \" << p->S << \"\\n\";\n\t\t\t\tvis[x]=1,v.pb(MP(x,p->S)),w[p->S]+=w[x],x=p->S;\n\t\t\t}\n\t\t}\n\tif(vis.count()!=n-1) cout << \"-1\\n\";\n\telse\n\t\tfor(auto i:v)\n\t\t\tcout << i.F << \" \" << i.S << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<cstring>\n#include<utility>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<set>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#define ll long long\n#define pii pair<ll,int>\n#define mp make_pair\n#define fi first\n#define se second\n#define inf 0x7fffffff\nusing namespace std;\nint a[100010];\npii b[100010],c[100010];\nint main()\n{\n\tint i,k,n,m,x,y,x1,n1;\n\tll j;\n\tscanf(\"%d\",&n);\n\tn1=n;\n\tfor(i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tb[i].fi=a[i];\n\t\tb[i].se=i+1;\n\t\tc[i]=b[i];\n\t}\n\tsort(b,b+n);\n\tvector<int> cl;\n\twhile(n>1)\n\t{\n\t\tx=n-1;\n\t\ti=2;\n\t\tk=0;\n\t\tcl.clear();\n\t\twhile(x!=0&&k<n)\n\t\t{\n\t\t\tj=b[x].fi-n1+i;\n\t\t\tif(j<y)\n\t\t\t{\n\t\t\t\tprintf(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ti+=2;\n\t\t\tx1=lower_bound(b,b+n,mp(j,0))-b;\n\t\t\tif(b[x1].fi!=j)\n\t\t\t{\n\t\t\t\tprintf(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcl.push_back(x);\n\t\t\tk++;\n\t\t\tx=x1;\n\t\t}\n\t\tif(k>=n)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(i=0;i<cl.size();i++)\n\t\t{\n\t\t\tb[cl[i]]=mp(0,0);\n\t\t}\n\t\tsort(b,b+n);\n\t\treverse(b,b+n);\n\t\treverse(b,b+n-k);\n\t\tn-=k;\n\t}\n\tn=n1;\n\tsort(c,c+n);\n\twhile(n>1)\n\t{\n\t\tx=n-1;\n\t\ti=2;\n\t\tk=0;\n\t\tcl.clear();\n\t\twhile(x!=0&&k<n)\n\t\t{\n\t\t\tj=c[x].fi-n1+i;\n\t\t\ti+=2;\n\t\t\tx1=lower_bound(c,c+n,mp(j,0))-c;\n\t\t\tprintf(\"%d %d\\n\",c[x].se,c[x1].se);\n\t\t\tcl.push_back(x);\n\t\t\tk++;\n\t\t\tx=x1;\n\t\t}\n\t\tif(k>=n)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(i=0;i<cl.size();i++)\n\t\t{\n\t\t\tc[cl[i]]=mp(0,0);\n\t\t}\n\t\tsort(c,c+n);\n\t\treverse(c,c+n);\n\t\treverse(c,c+n-k);\n\t\tn-=k;\n\t}\n\treturn 0;\n}/*\n7\n10\n15\n13\n18\n11\n14\n19\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint N; long long D[101010];\nint size[101010], parent[101010];\nmap<long long, int> D2I; //Distance-index;\nvector<int> child[101010];\nvoid check(bool p)\n{\n  if(!p)\n  {\n    puts(\"-1\");\n    exit(0);\n  }\n}\nlong long dfs(int ind, int height)\n{\n  long long ans = height;\n  for(auto x: child[ind]) ans += dfs(x, height+1);\n  return ans;\n}\nvoid verify_print()\n{\n  int root = 0;\n  for(int i=1; i<=N; ++i)\n  {\n    if(parent[i]) child[parent[i]].push_back(i);\n    else root = i;\n  }\n  check(dfs(root, 0) == D[root]);\n  for(int i=1; i<=N; ++i)\n    if(parent[i])\n      printf(\"%d %d\\n\", parent[i], i);\n  return;\n}\nint main()\n{\n  vector<pair<long long, int> > V;\n  scanf(\"%d\", &N);\n  for(int i=1; i<=N; ++i)\n  {\n    scanf(\"%lld\", D+i);\n    V.emplace_back(D[i], i);\n    D2I[D[i]] = i;\n  }\n  sort(V.rbegin(), V.rend());\n  for(auto x: V)\n  {\n    long long distance; int index; tie(distance, index) = x;\n    size[index]++;\n    \n    if(V[V.size()-1] == x) check(size[index] == N);\n    else\n    {\n      check(size[index] <= (N-1)/2);\n      long long pdist = distance - (N-2*size[index]);\n      int pind = D2I[pdist]; check(pind != 0);\n      parent[index] = pind; size[pind] += size[index];\n    }\n  }  \n  verify_print();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define per(i,r,l) for(int i=(r);i>=(l);--i)\nusing namespace std;\ntypedef long long ll;\nconst int maxn=1e5+10;\nint n,sz[maxn],fa[maxn];\nll b[maxn];\nstruct Node{ll x;int id;}a[maxn];\ninline bool operator <(Node x,Node y){return x.x<y.x;}\nint main(){\n    scanf(\"%d\",&n);\n    rep(i,1,n) scanf(\"%lld\",&a[i].x),a[i].id=i,b[i]=a[i].x;\n    sort(a+1,a+n+1);sort(b+1,b+n+1);\n    rep(i,1,n) sz[i]=1;\n    per(i,n,2){\n        int u=a[i].id;\n        if(n%2==0&&sz[u]==n/2) return puts(\"-1\"),0;\n        int x=lower_bound(b+1,b+n+1,a[i].x-(n-sz[u])+sz[u])-b;\n        if(b[x]!=a[i].x-(n-sz[u])+sz[u]) return puts(\"-1\"),0;\n        x=a[x].id;fa[u]=x;sz[x]+=sz[u];\n    }\n    rep(i,1,n) if(fa[i]) printf(\"%d %d\\n\",i,fa[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T> void assign(V<T>& v, int n, const T& a = T()) { v.assign(n, a); }\ntemplate<class T, class... U> void assign(V<T>& v, int n, const U&... u) { v.resize(n); for (auto&& i : v) assign(i, u...); }\n\nint main() {\n  cin.tie(NULL); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  if (n < 7) return cout << -1 << '\\n', 0;\n  V<lint> d(n); for (int i = 0; i < n; i++) cin >> d[i];\n  map<lint, int> invd; for (int i = 0; i < n; i++) invd[d[i]] = i;\n  set<lint> s; for (int i = 0; i < n; i++) s.insert(d[i]);\n  VV<> g(n);\n  V<> c(n, 1);\n  while (!s.empty()) {\n    int v = invd[*--s.end()];\n    if (!s.count(d[v] - (n - 2 * c[v]))) break;\n    int w = invd[d[v] - (n - 2 * c[v])];\n    c[w] += c[v];\n    g[v].push_back(w);\n    g[w].push_back(v);\n    s.erase(--s.end());\n  }\n  V<> d0(n, -1);\n  queue<int> que;\n  d0[0] = 0; que.push(0);\n  while (!que.empty()) {\n    int v = que.front(); que.pop();\n    for (int w : g[v]) if (d0[w] == -1) {\n      d0[w] = d0[v] + 1; que.push(w);\n    }\n  }\n  for (int i = 0; i < n; i++) if (d0[i] == -1) return cout << -1 << '\\n', 0;\n  if (accumulate(d0.begin(), d0.end(), 0LL) != d[0]) return cout << -1 << '\\n', 0;\n  for (int v = 0; v < n; v++) for (int w : g[v]) if (v < w) cout << v + 1 << ' ' << w + 1 << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fo(i,s,t) for(int i = s; i <= t; ++ i)\n#define fd(i,s,t) for(int i = s; i >= t; -- i)\n#define bf(i,s) for(int i = head[s]; i; i = e[i].next)\n#define mp make_pair\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pb push_back\n#define VI vector<int>\n#define sf scanf\n#define pf printf\n#define fp freopen\n#define SZ(x) ((int)(x).size())\n#ifdef MPS\n#define D(x...) printf(x)\n#else\n#define D(x...)\n#endif\ntypedef long long ll;\ntypedef double db;\ntypedef unsigned long long ull;\nconst int inf = 1<<30;\nconst ll INF = 1ll<<60;\nconst db Inf = 1e20;\nconst db eps = 1e-9;\n\nvoid gmax(int &a,int b){a = (a > b ? a : b);}\nvoid gmin(int &a,int b){a = (a < b ? a : b);}\n\nconst int maxn = 100050;\n\nint n, sz[maxn];\npair<ll,int> d[maxn];\nstruct edge{int u, v;}e[maxn];\n\nint main()\n{\n\tsf(\"%d\",&n);\n\tfo(i,1,n) sf(\"%I64d\",&d[i].fi), d[i].se = i;\n\tsort(d+1, d+n+1);\n\tfd(i,n,2)\n\t{\n\t\tsz[i] ++;\n\t\tint l = 1, r = i-1, mid, p = -1;\n\t\twhile(l <= r)\n\t\t{\n\t\t\tmid = (l + r) >> 1;\n\t\t\tif(d[mid].fi <= d[i].fi-n+2*sz[i]) p = mid, l = mid + 1;\n\t\t\telse r = mid - 1;\n\t\t}\n\t\tif(p == -1 || d[p].fi != d[i].fi-n+2*sz[i]) return 0 * pf(\"-1\\n\");\n\t\tsz[p] += sz[i];\n\t\te[i].u = d[p].se; e[i].v = d[i].se;\n\t}\n\tsz[1] ++;\n\tll ans = 0;\n\tfo(i,1,n) ans += sz[i] * (ll)(n - sz[i]);\n\tans <<= 1;\n\tfo(i,1,n) ans -= d[i].fi;\n\tif(ans != 0) return 0 * pf(\"-1\\n\");\n\tassert(0);\n\tfo(i,2,n) pf(\"%d %d\\n\",e[i].u,e[i].v);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\n#define ll long long\n#define rep(i, a, b) for(int i = a; i <= (int)b; i++)\nvoid read(int &x) {\n    x = 0; int flag = 1; char ch = ' ';\n    while(ch < '0' || ch > '9') { if(ch == '-') flag = -1; ch = getchar(); }\n    while(ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();\n    x *= flag;\n}\nvoid read(ll &x) {\n    x = 0; int flag = 1; char ch = ' ';\n    while(ch < '0' || ch > '9') { if(ch == '-') flag = -1; ch = getchar(); }\n    while(ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();\n    x *= flag;\n}\nusing namespace std;\nconst int maxn = 100010;\nint n, dis[maxn], Size[maxn], weight[maxn];\nll d[maxn];\nvector < pair <int, int > > ans;\nvector <int> edge[maxn];\nvoid dfs(int u, int fa) {\n    Size[u] = 1;\n    for(int i = 0; i < edge[u].size(); i++) if(edge[u][i] != fa) {\n        int v = edge[u][i];\n        dfs(v, u);\n        dis[u] += dis[v] + Size[v];\n        Size[u] += Size[v];\n    }\n}\nint main()\n{\n    read(n);\n    map <ll, int> mp;\n    rep(i, 1, n) read(d[i]), mp[d[i]] = i, weight[i] = 1;\n    rep(times, 1, n - 1) {\n        map <ll, int> :: iterator it = --mp.end();\n        int i = it -> second;\n        ll want = d[i] + 2 * weight[i] - n;\n        if(mp.find(want) == mp.end() || mp[want] == i) {\n            puts(\"-1\");\n            return 0;\n        }\n        int j = mp[want];\n        weight[j] += weight[i];\n        ans.push_back(make_pair(i, j));\n        edge[i].push_back(j), edge[j].push_back(i);\n        mp.erase(--mp.end());\n    }\n    dfs(1, 0);\n    if(dis[1] != d[1]) {\n        puts(\"-1\");\n        return 0;\n    }\n    rep(i, 0, n - 2) printf(\"%d %d\\n\", ans[i].first, ans[i].second);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <long long, long long> pii;\n\nconst long long MAX_N = 1e5 + 5;\nlong long n, root;\nlong long Arr[MAX_N];\nlong long h[MAX_N];\nlong long Siz[MAX_N];\nlong long Mark[MAX_N];\nlong long par[MAX_N];\nunordered_map <long long, long long> Map;\nvector <pii> edge;\nlong long dp_d[MAX_N];\nlong long dp_u[MAX_N];\nvector <long long> child[MAX_N];\n\nbool cmp(long long a, long long b) {\n\treturn Arr[b] < Arr[a];\n}\n\nvoid dfs1(long long v) {\n\tfor (long long i = 0; i < child[v].size(); i++) {\n\t\tdfs1(child[v][i]);\n\t\tdp_d[v] += dp_d[child[v][i]] + Siz[child[v][i]];\n\t}\n}\n\nvoid dfs2(long long v, long long val) {\n\tdp_u[v] = val;\n\tfor (long long i = 0; i < child[v].size(); i++)\n\t\tdfs2(child[v][i], dp_d[v] + dp_u[v] - dp_d[child[v][i]] - Siz[child[v][i]] + (n - Siz[child[v][i]]));\n}\n\nint main() {\n\tios::sync_with_stdio(false), cout.tie(0), cin.tie(0);\n\tcin >> n;\n\tfor (long long i = 0; i < n; i++) {\n\t\tcin >> Arr[i];\n\t\tSiz[i] = 1;\n\t\th[i] = i;\n\t\tMap[Arr[i]] = i;\n\t}\n\t\t\n\tsort(h, h + n, cmp);\n\t\n\tfor (long long i = 0; i + 1 < n; i++) {\n\t\tlong long v = h[i];\n\t\tlong long tmp = Arr[v] + Siz[v] - (n - Siz[v]);\n\n\t\tif (tmp < 0 || (Map[tmp] == 0 && Arr[0] != tmp)) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tlong long u = Map[tmp];\n\t\tif (Mark[u]) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tSiz[u] += Siz[v];\n\t\tpar[v] = u;\n\t\tedge.push_back({v, u});\n\t\tchild[u].push_back(v);\n\t}\n\troot = h[n - 1];\n\tdfs1(root);\n\tdfs2(root, 0);\n\t\n\tfor (long long i = 0; i < n; i++)\n\t\tif (dp_d[i] + dp_u[i] != Arr[i]) {\n\t\t\tcout << i << \" \" << dp_d[i] + dp_u[i] << \"\\n\";\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\n\tfor (long long i = 0; i + 1 < n; i++)\n\t\tcout << edge[i].first + 1 << \" \" << edge[i].second + 1 << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,int>P;\n\nint n;\nP d[200000];\nvector<int>E[200000];\nint sz[200000];\nll dp1[200000],dp2[200000];\nvector<pair<int,int>>ans;\n\nvoid dfs1(int v){\n\tfor(int u:E[v]){\n\t\tdfs1(u);\n\t\tdp1[v]+=dp1[u]+sz[u];\n\t}\n}\nvoid dfs2(int v,int p){\n\tif(p==-1)dp2[v]=dp1[v];\n\telse dp2[v]=dp2[p]+n-2*sz[v];\n\tfor(int u:E[v]){\n\t\tans.push_back({v+1,u+1});\n\t\tdfs2(u,v);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%lld\",&d[i].first);\n\t\td[i].second=i;\n\t}\n\trep(i,n)sz[i]=1;\n\tsort(d,d+n);\n\tfor(int i=n-1;i>0;i--){\n\t\tint c=d[i].first-n+2*sz[d[i].second];\n\t\tint id=lower_bound(d,d+n,P(c,0))-d;\n\t\tif(id==n||d[id].first!=c){\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t\tif(i==id)abort();\n\t\tE[d[id].second].push_back(d[i].second);\n\t\tsz[d[id].second]+=sz[d[i].second];\n\t}\n\tdfs1(d[0].second);\n\tdfs2(d[0].second,-1);\n\trep(i,n){\n\t\tif(dp2[d[i].second]!=d[i].first){\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t}\n\tfor(auto p:ans){\n\t\tprintf(\"%d %d\\n\",p.first,p.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//ios::sync_with_stdio(false);\n#include<bits/stdc++.h>\n#define LL long long\n#define F(x,y,z) for(int x=y;x<=z;++x)\n#define D(x,y,z) for(int x=y;x>=z;--x)\n#define ckmax(a,b) (a)=max(a,b)\n#define ckmin(a,b) (a)=min(a,b)\n#define pb push_back\nusing namespace std;\nconst int N=100010;\nLL R(){\n    LL ans=0,f=1;char c=getchar();\n    for(;c<'0'||c>'9';c=getchar()) if (c=='-') f=-1;\n    for(;c>='0'&&c<='9';c=getchar()) ans=ans*10+c-'0';\n    return ans*f;\n}\nint n,fa[N],siz[N];\nvector<int> v[N];\nLL d[N],s,g[N];\nmap<LL,int> ys,id;\nvoid Err(){\n\tprintf(\"-1\\n\");\n\texit(0);\n}\nvoid dfs(int u,int dep){\n\ts+=dep;\n\tfor(auto to:v[u])dfs(to,dep+1);\n}\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);freopen(\"1.out\",\"w\",stdout);\n\tn=R();\n\tF(i,1,n)d[i]=R(),siz[i]=1,id[d[i]]=i;\n\tsort(d+1,d+1+n);\n\tF(i,1,n)ys[d[i]]=i;\n\tD(i,n,2){\n\t\tfa[i]=ys[d[i]+siz[i]*2-n];\n\t\tif(fa[i]==0)Err();\n\t\tv[fa[i]].pb(i);\n\t\tsiz[fa[i]]+=siz[i];\n\t}\n\tdfs(1,0);\n\tif(s!=d[1])Err();\n\tF(i,2,n)printf(\"%d %d\\n\",id[d[i]],id[d[fa[i]]]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define EPS 1e-10\n#define setNil(x) memset((x),0,sizeof(x))\n#define setINF(x) memset((x),63,sizeof(x))\n#define setNegINF(x) memset((x),192,sizeof(x)) //NegINF=-INF-1\n#define setNeg1(x) memset((x),255,sizeof(x))\n#define D first\n#define ID second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,int> pii;\nconst int N=100005;\nint n,f[N],sz[N];\nll d[N],tot;\npii p[N];\nmap<ll,int> mp;\nvector<int> g[N];\nvoid dfs(int x,int p,int dep){\n\ttot+=dep;\n\tfor(int i=0;i<g[x].size();i++){\n\t\tint u=g[x][i];\n\t\tif(u==p)continue;\n\t\tdfs(u,x,dep+1);\n\t}\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>d[i];\n\t\tp[i]=pii(d[i],i);\n\t\tsz[i]=1;\n\t\tmp[d[i]]=i;\n\t}\n\tsort(p+1,p+n+1);\n\tfor(int i=n;i>1;i--){\n\t\tint fs=p[i].D-n+2*sz[p[i].ID];\n\t\tif(!mp[fs] || fs>=p[i].D){\n\t\t\tcout<<\"-1\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tsz[f[p[i].ID]=mp[fs]]+=sz[p[i].ID];\n\t\tg[p[i].ID].push_back(f[p[i].ID]);\n\t\tg[f[p[i].ID]].push_back(p[i].ID);\n\t}\n\tdfs(p[1].ID,0,0);\n\tif(tot!=p[1].D)cout<<\"-1\\n\";\n\telse for(int i=n;i>1;i--)cout<<f[p[i].ID]<<' '<<p[i].ID<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\nnamespace Base{\n\t# define mr make_pair\n\ttypedef long long ll;\n\ttypedef double db;\n\tconst int inf = 0x3f3f3f3f, INF = 0x7fffffff;\n\tconst ll  infll = 0x3f3f3f3f3f3f3f3fll, INFll = 0x7fffffffffffffffll;\n\ttemplate<typename T> void read(T &x){\n    \tx = 0; int fh = 1; double num = 1.0; char ch = getchar();\n\t\twhile (!isdigit(ch)){ if (ch == '-') fh = -1; ch = getchar(); }\n\t\twhile (isdigit(ch)){ x = x * 10 + ch - '0'; ch = getchar(); }\n\t    if (ch == '.'){\n\t    \tch = getchar();\n\t    \twhile (isdigit(ch)){num /= 10; x = x + num * (ch - '0'); ch = getchar();}\n\t\t}\n\t\tx = x * fh;\n\t}\n\ttemplate<typename T> void chmax(T &x, T y){x = x < y ? y : x;}\n\ttemplate<typename T> void chmin(T &x, T y){x = x > y ? y : x;}\n}\nusing namespace Base;\n\nconst int N = 100010;\nstruct Edge{\n\tint data, next;\n}e[N * 2];\nstruct Node{\n\tint id; ll num;\n}p[N];\nint n, size[N], eu[N], ev[N], head[N], place, cnt;\nll num[N], dis;\nvoid build(int u, int v){\n\te[++place].data = v; e[place].next = head[u]; head[u] = place;\n}\nvoid dfs(int x, int fa, int di){\n\tdis += di;\n\tfor (int ed = head[x]; ed != 0; ed = e[ed].next)\n\t\tif (e[ed].data != fa)\n\t\t\tdfs(e[ed].data, x, di + 1);\n}\nvoid error(){\n\tprintf(\"-1\\n\");\n\texit(0);\n}\nbool cmp(Node x, Node y){\n\treturn x.num < y.num;\n}\nint main(){\n\tread(n);\n\tfor (int i = 1; i <= n; i++){\n\t\tread(num[i]), size[i]++;\n\t\tp[i].num = num[i];\n\t\tp[i].id = i;\n\t}\n\tsort(num + 1, num + n + 1);\n\tsort(p + 1, p + n + 1, cmp);\n\tfor (int i = n; i >= 1; i--){\n\t\tll tmp = num[i] - (n - 2 * size[i]);\n\t\tif (tmp >= num[i]) continue;\n\t\tll id = lower_bound(num + 1, num + n + 1, tmp) - num;\n\t\tif (num[id] == tmp){\n\t\t\tbuild(id, i); build(i, id);\n\t\t\teu[++cnt] = id, ev[cnt] = i;\n\t\t\tsize[id] += size[i];\n\t\t}\n\t\telse error();\n\t}\n\tdfs(1, 0, 0);\n\tif (dis != num[1]) error();\n\tfor (int i = 1; i < n; i++)\n\t\tprintf(\"%d %d\\n\", p[eu[i]].id, p[ev[i]].id);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint main()\n{\nputs(\"-1\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<iomanip>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<string>\n#include<utility>\n#include<cmath>\n#include<algorithm>\n#include<cctype>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stack>\n#include<ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vpii;\ntypedef vector<pli> vpli;\n\ninline ll read(){\n    ll Hashimoto=0;\n\tbool Kanna=1;\n    char I_Love=getchar();\n    while(I_Love<'0'||I_Love>'9'){\n        if(I_Love=='-')Kanna=0;\n        I_Love=getchar();\n    }\n    while(I_Love>='0'&&I_Love<='9'){\n        Hashimoto=Hashimoto*10+I_Love-'0';\n        I_Love=getchar();\n    }\n    return (Kanna?Hashimoto:-Hashimoto);\n}\ntemplate<typename T1,typename T2> inline void Umax(T1 &a,T2 b){\n\tif(a<b)a=b;\n}\ntemplate<typename T1,typename T2> inline void Umin(T1 &a,T2 b){\n\tif(a>b)a=b;\n}\n\n#define I_Love_Hashimoto_Kanna main\n#define fastio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define filein(s) freopen(s,\"r\",stdin);\n#define fileout(s) freopen(s,\"w\",stdout);\n#define file freopen(\"I_Love_Hashimoto_Kanna.out\",\"w\",stdout);\n#define RE cout<<\"I_Love_Hashimoto_Kanna\"<<endl;\n#define Tone(Kanna) cout<<Kanna<<endl;\n#define Tall(Hashimoto,Kanna) for(int I_Love=0;I_Love<(Kanna);++I_Love)cout<<Hashimoto[I_Love]<<(I_Love==(Kanna)-1?\"\\n\":\" \");\n#define FOR(I_Love,Hashimoto,Kanna) for(int I_Love=Hashimoto;I_Love<(Kanna);++I_Love)\n#define MP(Hashimoto,Kanna) make_pair(Hashimoto,Kanna)\n#define REV(Kanna) reverse(Kanna.begin(),Kanna.end());\n#define SORT(Kanna) sort(Kanna.begin(),Kanna.end());\n#define UNIQUE(Kanna) Kanna.erase(unique(Kanna.begin(),Kanna.end()),Kanna.end());\n#define inf (int)1e9\n#define linf (ll)1e18\n#define mod (inf+7)\n\nint n;\npli a[111111];\nint s[111111];\nint f[111111];\n\nint I_Love_Hashimoto_Kanna() {\n\t//完全想清楚了再开始写。\n\t//写不顺、不知道怎么写、很乱的时候，停下来好好想想。\n\t//做得慢总比做不出好。\n\tfastio;\n\tn=read();\n\tFOR(i,0,n){\n\t\ta[i]={read(),i};\n\t\ts[i]=1;\n\t}\n\tsort(a,a+n);\n\tll sum=0;\n\tfor(int i=n-1;i>0;--i){\n\t\tint j=lower_bound(a,a+n,MP(a[i].first-(n-s[i]-s[i]),-1))-a;\n\t\tif(i==j||a[j].first!=a[i].first-(n-s[i]-s[i])){\n\t\t\tTone(-1);\n\t\t\treturn 0;\n\t\t}\n\t\tf[i]=j;\n\t\ts[j]+=s[i];\n\t\tsum+=s[i];\n\t}\n\tif(sum!=a[0].first){\n\t\tTone(-1);\n\t\treturn 0;\n\t}\n\tFOR(i,1,n){\n\t\tprintf(\"%d %d\\n\",a[i].second+1,a[f[i]].second+1);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//ここから編集する\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N;\n    cin >> N;\n\n    vector<ll> D(N);\n    map<ll, int> Dtov;\n    rep(i, 0, N) cin >> D[i];\n    rep(i, 0, N) Dtov[D[i]] = i + 1;\n\n    sort(D.rbegin(), D.rend());\n    vector<vector<int> > G(N + 1, vector<int>());\n    vector<bool> used(D.size(), false);\n    vector<pair<int, int>> ans;\n\n    for (int i = 0; i < N - 1; ++i) {\n        if (!used[i]) {\n            used[i] = true;\n\n//            for (int k = N - 2; k > 0; k -= 2) {\n//                if (find(all(D), D[i] - k) == D.end()) {\n//                    cout << -1 << endl;\n//                    return 0;\n//                } else {\n//                    ans.emplace_back(Dtov[D[i]], Dtov[D[i] - k]);\n//                }\n//            }\n            ll tmp = D[i];\n            ll dec = N - 2;\n            while (tmp > D.back() && dec > 0) {\n                if (find(all(D), tmp - dec) == D.end()) {\n                    cout << -1 << endl;\n                    return 0;\n                } else {\n                    if (tmp - dec >= D.back()) {\n\n                        ans.emplace_back(Dtov[tmp], Dtov[tmp - dec]);\n                        G[Dtov[tmp - dec]].push_back(Dtov[tmp]);\n\n//                    used[Dtov[tmp - dec]] = true;\n                        used[find(all(D), tmp - dec) - D.begin()] = true;\n                        tmp -= dec;\n                        dec -= 2;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    function<ll(int, int)> treesize = [&](int v, int dist) {\n        ll ret = dist;\n        for (auto e: G[v]) {\n            ret += treesize(e, dist + 1);\n        }\n        return ret;\n    };\n\n    ll min_tree_size = treesize(Dtov[D.back()], 0);\n    if (min_tree_size != D.back()) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    for (auto e : ans) {\n        cout << e.first << \" \" << e.second << endl;\n//        cout << e.second << \" \" << e.first << endl;\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\nusing namespace std;\npair<long long,int> p[100010];\nmap<long long,vector<pair<int,int>>> mp;\nvector<pair<int,int>> ans;\nint main(){\n\tint i,n;\n\tcin >> n;\n\tfor(i=0;i<n;i++){\n\t\tlong long d;\n\t\tcin >> d;\n\t\tp[i] = {d,i};\n\t}\n\tsort(p,p + n);\n\tfor(i=n-1;i>=0;i--){\n\t\tif(mp.find(p[i].first)==mp.end()){\n\t\t\tmp[p[i].first - n + 2].push_back({p[i].second,1});\n\t\t}else{\n\t\t\tint sum = 1;\n\t\t\tfor(auto x:mp[p[i].first]){\n\t\t\t\tsum += x.second;\n\t\t\t\tans.push_back({x.first,p[i].second});\n\t\t\t}\n\t\t\tmp[p[i].first - n + 2*sum].push_back({p[i].second,sum});\n\t\t}\n\t}\n\tif(ans.size()==n-1){\n\t\tfor(i=0;i<ans.size();i++){\n\t\t\tcout << ans[i].first + 1 << \" \" << ans[i].second + 1 << endl;\n\t\t}\n\t}else{\n\t\tcout << -1 << endl;\n\t}\n}\n\t"
  },
  {
    "language": "C++",
    "code": "// Peace Of SHIT\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ntypedef pair<int, int> pii;\nconst int maxn = 1e5 + 5;\nint n, si[maxn];\nint sum = 0;\nvector<int> e[maxn];\npii d[maxn];\n\nvoid impossible() {\n\tcout << -1;\n\texit(0);\n}\n\nvoid dfs(int u, int x) {\n\tsum += x;\n\tfor(int i = 0; i < e[u].size(); i++) {\n\t\tdfs(e[u][i], x + 1);\n\t}\n}\n\nint32_t main() {\n\tscanf(\"%lld\", &n);\n\tfor(int i = 0; i < n; i++) {\n\t\tint a;\n\t\tscanf(\"%lld\", &a);\n\t\td[i] = {a, i};\n\t}\n\tsort(d, d + n);\n\treverse(d, d + n);\n\t\n\tvector <pii> k (d, d + n);\n\t\n\tfor(int q = 0; q < n - 1; q++) {\n\t\tint leaf = d[q].second;\n\t\tint parD = d[q].first - (n - (2 * (si[leaf] + 1)));\n\t\tauto it = lower_bound(k.rbegin(), k.rend(), pii(parD, 0));\n//\t\tcout << \"PAR : \" <<it->first << \" : \" << parD << '\\n';\n\t\tif(it -> first != parD) {\n//\t\t\tcerr << \"AVALI\\n\";\n\t\t\timpossible();\n\t\t}\n\t\tint par = it -> second;\n\t\tsi[par] += si[leaf] + 1;\n\t\tif((si[leaf] + 1) * 2 > n) {\n//\t\t\tcout << \"DOVOMI\\n\";\n\t\t\timpossible();\n\t\t}\n\t\t//SEVOMI HAM MISHE D[I] ROOT OK E ?\n\t\te[par].push_back(leaf);\n\t}\n\tint D = d[n - 1].second;\n\tdfs(D, 0);\n\tif(sum != d[n - 1].first)\n\t\timpossible();\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < e[i].size(); j++) {\n\t\t\tprintf(\"%lld %lld\\n\", i + 1, e[i][j] + 1);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<iomanip>\n#include<cstring>\n#include<algorithm>\n#include<ctime>\nusing namespace std;\ninline int read()\n{\n\tint kkk=0,x=1;\n\tchar c=getchar();\n\twhile((c<'0' || c>'9') && c!='-')\n\t\tc=getchar();\n\tif(c=='-')\n\t\tc=getchar(),x=-1;\n\twhile(c>='0' && c<='9')\n\t\tkkk=(kkk<<3)+(kkk<<1)+(c-'0'),c=getchar();\n\treturn kkk*x;\n}\nint n;\nstruct sb\n{\n\tint sum,id,size,fa;\n}a[100001];\ninline int cmp(sb x,sb y)\n{\n\treturn x.sum>y.sum;\n}\ninline int find(int V)\n{\n\tint l=1,r=n,bck=0;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)/2;\n\t\tif(a[mid].sum>=V)\n\t\t\tbck=mid,l=mid+1;\n\t\telse\n\t\t\tr=mid-1;\n\t}\n\treturn bck;\n}\nint main()\n{\n\tn=read();\n\tfor(register int i=1;i<=n;++i)\n\t{\n\t\ta[i].id=i;\n\t\ta[i].sum=read();\n\t\ta[i].size=1;\n\t}\n\tsort(a+1,a+n+1,cmp);\n\ta[0].sum=-1;\n\tfor(register int i=1;i<n;++i)\n\t{\n\t\tint fv=a[i].sum+a[i].size-(n-a[i].size);\n\t\tif(fv<n-1)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint zone=find(fv);\n\t\tif(a[zone].sum!=fv)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\ta[zone].size+=a[i].size;\n\t\ta[i].fa=zone;\n\t}\n\tfor(register int i=1;i<n;++i)\n\t\tprintf(\"%d %d\\n\",a[i].id,a[a[i].fa].id);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 100005\n#define ll long long\nll read() {\n    ll s=0,w=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9')\n\t{\n\t    if(ch=='-') w=-1;\n\t    ch=getchar();\n\t}\n    while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48),ch=getchar();\n    return s*w;\n}\nmap<ll,int> ap;\nstruct node{\n    ll d;\n    int id;\n}a[M];\nbool cmp(node p1,node p2) {return p1.d>p2.d;}\nstruct edge{\n    int u,v;\n    edge(int r_u=0,int r_v=0) {u=r_u,v=r_v;}\n}ans[M];\nvector<int> e[M]; \nint cnt;\nint n,sz[M];\nll dep[M],sum;\nvoid dfs(int x,int fa) {\n    dep[x]=dep[fa]+1,sum+=dep[x];\n    for(int i=0;i<e[x].size();i++)\n\t{\n\t    int to=e[x][i];\n\t    dfs(to,x);\n\t}\n}\nvoid work() {\n    int tp=0;\n    for(int i=1;i<=n;i++) ap[a[i].d]=a[i].id,sz[i]=1;\n    for(int i=1;i<n;i++)\n\t{\n\t    ll d_F=a[i].d-n+2*sz[a[i].id];\n\t    if(d_F<0||d_F>=a[i].d||ap[d_F]==0) {tp=1;break ;}\n\t    sz[ap[d_F]]+=sz[a[i].id];\n\t    ans[++cnt]=edge(ap[d_F],a[i].id);\n\t    e[ap[d_F]].push_back(a[i].id);\n\t}\n    dep[0]=-1;\n    dfs(a[n].id,0);\n    if(sum!=a[n].d) tp=1;\n    if(tp) cout<<-1<<'\\n';\n    else for(int i=1;i<=cnt;i++) cout<<ans[i].u<<' '<<ans[i].v<<'\\n';\n}\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;i++) {a[i].d=read();a[i].id=i;}\n    sort(a+1,a+n+1,cmp);\n    work();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\nstruct node\n{\n\tlong long d;int p;\n}a[100010];\nstruct bian\n{\n\tint x,y,next;\n}e[100010];int len,last[100010];\nvoid ins(int x,int y)\n{\n\tlen++;\n\te[len].x=x;e[len].y=y;\n\te[len].next=last[x];last[x]=len;\n}\nbool cmp(node a,node b){return a.d<b.d;}\nint n;\nbool v[100010];\ninline int erfen(long long x)\n{\n\tint l=1,r=n,ans;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)/2;\n\t\tif(a[mid].d<=x)ans=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\tif(a[ans].d==x)return ans;\n\telse return -1;\n}\nint tot[100010];\nlong long sum=0;\nvoid dfs(int x,int dis)\n{\n\tsum+=dis;\n\tfor(int k=last[x];k;k=e[k].next)\n\t{\n\t\tint y=e[k].y;\n\t\tdfs(y,dis+1);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i].d),a[i].p=i;\n\tsort(a+1,a+n+1,cmp);\n\tfor(int i=1;i<=n;i++)tot[i]=1;\n\tbool bk=true;\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tlong long ul=a[i].d-n+2*tot[i];\n\t\tint y=erfen(ul);\n\t\tif(y==-1 || y==i){bk=false;break;}\n\t\tins(a[y].p,a[i].p);\n\t\ttot[y]+=tot[i];\n\t}\n\tdfs(a[1].p,0);\n\tif(bk==false || sum!=a[1].d)printf(\"-1\\n\");\n\telse for(int i=1;i<=len;i++)printf(\"%d %d\\n\",e[i].x,e[i].y);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*====Corycle====*/\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#define ll long long\n#define set_it set<Node>::iterator\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst int N=1e5+5;\nint read(){\n\tint s=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){s=s*10+c-'0';c=getchar();}\n\treturn s*f;\n}\nll Dist,a[N];\nint n,m,b[N],fa[N],sum[N];\nbool cmp(int x,int y){return a[x]>a[y];}\nstruct Node{\n\tll val;int x;\n\tfriend bool operator<(Node A,Node B){return A.val!=B.val?A.val<B.val:A.x<B.x;}\n};\nset<Node>F;\nint main(){\n//\tfreopen(\"_.in\",\"r\",stdin);\n//\tfreopen(\"_.out\",\"w\",stdout);\n\tn=read();\n\tfor(int i=1;i<=n;i++){a[i]=read();b[i]=i;sum[i]=1;F.insert((Node){a[i],i});}\n\tsort(b+1,b+n+1,cmp);\n\tfor(int i=1;i<n;i++){\n\t\tint x=b[i];\n\t\tll val=a[x]+2*sum[x]-n;\n\t\tF.erase((Node){a[x],x});\n\t\tset_it p=F.lower_bound((Node){val,0});\n\t\tif((*p).val!=val){puts(\"-1\");return 0;}\n\t\tint y=(*p).x;fa[x]=y;sum[y]+=sum[x];Dist+=sum[x];\n\t}\n\tif(Dist!=a[b[n]]){puts(\"-1\");return 0;}\n\tfor(int i=1;i<=n;i++)if(fa[i])printf(\"%d %d\\n\",i,fa[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nmap<ll,int>p;\nmap<ll,int>::iterator it;\nint fa[100010],siz[100010],a[100010],b[100010],M;\nint get(int x){return fa[x]==x?x:(fa[x]=get(fa[x]));}\nint main(){\n\tint n,i;\n\tll x;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&x);\n\t\tp[x]=i;\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tfa[i]=i;\n\t\tsiz[i]=1;\n\t}\n\tit=p.end();\n\tfor(it--;it!=p.begin();it--){\n\t\tif(n-siz[it->second]*2==0||!p.count(it->first-(n-siz[it->second]*2))){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tM++;\n\t\ta[M]=it->second;\n\t\tb[M]=p[it->first-(n-siz[it->second]*2)];\n\t\tsiz[fa[a[M]]=get(b[M])]+=siz[a[M]];\n\t}\n\tfor(i=1;i<=M;i++)printf(\"%d %d\\n\",a[i],b[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int N=100100;\n\nmap<LL,int> qaq;\n\nvoid GG(){\n\tputs(\"-1\");\n\texit(0);\n}\n\nvector<pair<int,int> > es;\nvoid ae(int u,int v){\n\tif(u>v)swap(u,v);\n\tes.push_back(pair<int,int>(u,v));\n}\nvoid print(){\n\tsort(es.begin(),es.end());\n\tfor(vector<pair<int,int> >::iterator it=es.begin();it!=es.end();++it){\n\t\tprintf(\"%d %d\\n\",it->first,it->second);\n\t}\n}\n\nint sz[N];\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tLL d;\n\t\tscanf(\"%lld\",&d);\n\t\tqaq[d]=i;\n\t\tsz[i]=1;\n\t}\n\tint cnt=n;\n\tfor(map<LL,int>::reverse_iterator it=qaq.rbegin();it!=qaq.rend();++it){\n\t\tint x=it->second;\n\t\tint d=it->first;\n\t\tif(sz[x]*2==n)GG();\n\t\tint nd=d+sz[x]-(n-sz[x]);\n\t\tif(cnt==1)break;\n\t\tif(!qaq.count(nd)){\n\t\t\tGG();\n\t\t}else{\n\t\t\tint v=qaq[nd];\n\t\t\tae(x,v);\n\t\t\tsz[v]+=sz[x];\n\t\t}\n\t\tcnt--;\n\t}\n\tprint();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\nusing namespace std;\n\nconst int mod = 1e9 + 7;\ntypedef long long li;\n\ninline int Add(int x) { return x >= mod ? x - mod : x; }\ninline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\ninline int Sub(int x) { return x < 0 ? x + mod : x; }\ninline void Sub(int &x, int y) { x -= y; if (x < 0) x += mod; }\ninline int Mul(int x, int y) { return (int)((li)x * y % mod); }\ninline int Mul(int x, int y, int z) { return Mul(x, Mul(y, z)); }\n\nint Pow(int x, int y) {\n  int z = 1;\n  for (; y; y >>= 1) {\n    if (y & 1) z = Mul(z, x);\n    x = Mul(x, x);\n  }\n  return z;\n}\n\n// ----------------------------------------\n\nconst int maxn = 1e5;\nconst li infl = 1e18;\n\nint n;\nli d[maxn];\nmap<li, int> id;\n\nint fa[maxn];\nint size[maxn];\nli sdep[maxn];\n\nvoid No(void) {\n  puts(\"-1\");\n  exit(0);\n}\n\nint main(void) {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%lld\", d + i);\n    id[d[i]] = i;\n    size[i] = 1;\n    sdep[i] = 0;\n  }\n  int root = min_element(d, d + n) - d;\n  while (id.size() > 1) {\n    int u = (--id.end())->second;\n    id.erase(--id.end());\n    li fa_d = d[u] - (n - size[u]) + size[u];\n    if (!id.count(fa_d)) No();\n    fa[u] = id[fa_d];\n    // printf(\"fa[%d] = %d\\n\", u, fa[u]);\n    size[fa[u]] += size[u];\n    sdep[fa[u]] += sdep[u] + size[u];\n  }\n  // printf(\"root = %d\\n\", root);\n  // printf(\"%lld %d\\n\", sdep[root], size[root]);\n  if (d[root] != sdep[root]) No();\n  for (int i = 0; i < n; ++i) {\n    if (i != root) {\n      printf(\"%d %d\\n\", i + 1, fa[i] + 1);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing nagai = long long;\nusing ll = long long;\n\nconst int N = 1e6 + 100;\nvector<int> g[N];\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n    int n;\n    cin >> n;\n    vector<nagai> d(n);\n    for (auto& x : d)\n        cin >> x;\n    vector<int> ord(n);\n    iota(ord.begin(), ord.end(), 0);\n    sort(ord.begin(), ord.end(), [&](int a, int b)\n            {\n             return d[a] > d[b];\n            });\n    map<nagai, int> mp;\n    for (int i = 0; i < n; ++i)\n        mp[d[i]] = i;\n    vector<int> sz(n, 1);\n    vector<pair<int, int>> edg;\n    vector<bool> used(n);\n    ord.pop_back();\n    for (int x : ord)\n    {\n        used[x] = true;\n        nagai dp = d[x] + sz[x] - (n - sz[x]);\n        if (!mp.count(dp) || used[mp[dp]])\n        {\n             cout << -1 << '\\n';\n             return 0;\n        }\n        edg.emplace_back(mp[dp], x);\n        sz[mp[dp]] += sz[x];\n    }\n    for (auto& [x, y] : edg)\n        g[x].push_back(y), g[y].push_back(x);\n    vector<nagai> d1(n, -1);\n    d1[0] = 0;\n    vector<int> q = {0};\n    for (int i = 0; i < q.size(); ++i)\n    {\n         int x = q[i];\n         for (int y : g[x])\n             if (d1[y] == -1)\n                 d1[y] = d1[x] + 1, q.emplace_back(y);\n    }\n    if (d[0] != accumulate(d1.begin(), d1.end(), 0LL))\n    {\n        cout << -1 << '\\n';\n        return 0;\n    }\n    for (auto& x : edg)\n        cout << x.first + 1 << ' ' << x.second + 1 << '\\n';\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nmap<long long, int> ids;\n\nlong long D[100100];\nint N;\n\nvoid input(){\n\tscanf(\"%d\", &N);\n\tfor(int i = 0; i < N; ++i){\n\t\tscanf(\"%lld\", D + i);\n\t\tids[D[i]] = i;\n\t}\n}\n\nint sz[100100];\n\nvector<P> ans;\n\nvector<int> G[100100];\nint dis[100100];\n\nvoid dfs(int v){\n\tfor(int i = 0; i < G[v].size(); ++i){\n\t\tint u = G[v][i];\n\t\tdis[u] = dis[v] + 1;\n\t\tdfs(u);\n\t}\n}\n\nbool solve(){\n\tfor(int i = 0; i < N; ++i){\n\t\tsz[i] = 1;\n\t}\n\tsort(D, D + N);\n\tfor(int i = N - 1; i >= 1; --i){\n\t\tint v = ids[D[i]];\n\t\tint s = sz[v];\n\t\tint dif = N - 2 * s;\n\t\tif(dif <= 0) return false;\n\t\tlong long nd = D[i] - dif;\n\t\tif(ids.count(nd) == 0) return false;\n\t\tint p = ids[nd];\n\t\tG[p].push_back(v);\n\t\tsz[p] += sz[v];\n\t\tans.push_back(P(v, p));\n\t}\n\tint root = ids[D[0]];\n\tdis[root] = 0;\n\tdfs(root);\n\tlong long sum = 0;\n\tfor(int i = 0; i < N; ++i){\n\t\tsum += dis[i];\n\t}\n\tif(sum != D[0]) return false;\n\treturn true;\n}\n\nint main(){\n\tinput();\n\tbool flg = solve();\n\tif(!flg){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tfor(int i = 0; i < ans.size(); ++i){\n\t\t\tprintf(\"%d %d\\n\", ans[i].first + 1, ans[i].second + 1);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5+100;\ntypedef long long ll;\ntypedef pair<ll,int> pli;\n#define fr(i,a,b) for(int i = a;i <= b; ++i)\n#define nfr(i,a,b) for(int i = a;i >= b; --i)\n#define pb push_back\n\nint n;\npli v[N];\nll d[N];\nint fa[N];\nint siz[N];\nmap<ll,int> vis;\n\nvector<int> edge[N];\nll val;\n\nvoid dfs(int x,int fa,int dep){\n   val += dep;\n   fr(i,0,(int)edge[x].size()-1){\n      int y = edge[x][i];\n      if(y == fa)continue ;\n      dfs(y,x,dep+1);\n   }\n}\n\nint main(){\n   val = 0;\n   scanf(\"%d\",&n);\n   fr(i,1,n){\n      scanf(\"%lld\",d+i); v[i] = pli(d[i],i);\n      vis[d[i]] = i;\n   }\n\n   sort(v+1,v+n+1,greater<pli>());\n   fr(i,1,n-1){\n      siz[v[i].second]++;\n      ll w = v[i].first+siz[v[i].second]*2-n;\n      if(!vis[w]){\n         puts(\"-1\"); return 0;\n      } else {\n         fa[v[i].second] = vis[w]; siz[vis[w]] += siz[v[i].second];\n         edge[vis[w]].pb(v[i].second);\n      }\n   }\n\n   dfs(v[n].second,0,0);\n   if(val != v[n].first){\n      puts(\"-1\"); return 0;\n   }\n   \n   fr(i,1,n-1){\n      printf(\"%d %d\\n\",v[i].second,fa[v[i].second]);\n   }\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<vector>\n#include<queue>\n#include<deque>\n#define ll long long\n#define mp make_pair\n#define rep(i,x,y) for(int i=(x);i<=(y);++i)\n#define r0p(i,n) for(int i=0;i<n;++i)\n#pragma GCC optimize(1)\n#pragma G++ optimize(1)\n#pragma GCC optimize(2)\n#pragma G++ optimize(2)\n#pragma GCC optimize(3)\n#pragma G++ optimize(3)\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#define pii pair<int,int>\n#pragma GCC diagnostic error \"-std=c++11\"\nusing namespace std;\ninline void rdl(long long &val){\n    long long x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n\t}\n\twhile(ch>='0' and ch<='9'){\n\t    x=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n    val=x*f;\n}\ninline void rdi(int &val){\n    int x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    val=x*f;\n}\ninline long long rdl(){\n    long long x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline int rdi(){\n    int x=0;\n    int f=1;\n\tchar ch=getchar();\n\twhile((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n\tif(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline void write(int x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\ninline void _write(int x){\n\twrite(x);\n\tputchar(' ');\n}\ninline void print(int x){\n\twrite(x);\n\tputchar('\\n');\n}\ninline void write(ll x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\ninline void _write(ll x){\n\twrite(x);\n\tputchar(' ');\n}\ninline void print(ll x){\n\twrite(x);\n\tputchar('\\n');\n}\nstruct dsu{\n\tint par[200200];\n\tinline void init(int _n){for(int i=0;i<_n;++i) par[i]=i;}\n\tinline int find(int now){\n\t\tif(par[now]==now) return now;\n\t\treturn par[now]=find(par[now]);\n\t}\n\tinline bool uni(int a, int b){\n\t\tint Pa(find(a)),Pb(find(b));\n\t\tif(Pa==Pb) return false;\n\t\tpar[Pa]=Pb;\n\t\treturn true;\n\t}\n};\n#define int ll\nmap<int,int> m,m2;\nvector<pair<int,int> >ans;\nint n,x;\nsigned main(){\n\trdl(n);\n\tint i,j,mn=100000000000000ll;\n\tint cnt=n;\n\tfor(i=1;i<=n;++i) rdl(x),m[x]=i,mn=min(mn,x),m2[i]=x;\n\twhile(cnt>1){\n\t\tmap<int,int>::iterator it=m2.end();it--;\n\t\tint t=it->second;\n\t\tint now=n;\n\t\tint tt=t;\n\t\twhile(t>mn){\n\t\t\tt-=now-2;\n\t\t\tnow-=2;\n\t\t\tif(!m[t]){\n\t\t\t\tprint(-1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(now<=0){\n\t\t\t\tprint(-1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tans.push_back(mp(m[t],m[tt]));\n\t\t\tm2.erase(m[tt]);\n\t\t\tm.erase(tt);\n\t\t\ttt=t;\n\t\t\t--cnt;\n\t\t}\n\t}\n\tfor(int i=0;i<ans.size();++i) _write(ans[i].first),print(ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\nnamespace Base{\n\t# define mr make_pair\n\ttypedef long long ll;\n\ttypedef double db;\n\tconst int inf = 0x3f3f3f3f, INF = 0x7fffffff;\n\tconst ll  infll = 0x3f3f3f3f3f3f3f3fll, INFll = 0x7fffffffffffffffll;\n\ttemplate<typename T> void read(T &x){\n    \tx = 0; int fh = 1; double num = 1.0; char ch = getchar();\n\t\twhile (!isdigit(ch)){ if (ch == '-') fh = -1; ch = getchar(); }\n\t\twhile (isdigit(ch)){ x = x * 10 + ch - '0'; ch = getchar(); }\n\t    if (ch == '.'){\n\t    \tch = getchar();\n\t    \twhile (isdigit(ch)){num /= 10; x = x + num * (ch - '0'); ch = getchar();}\n\t\t}\n\t\tx = x * fh;\n\t}\n\ttemplate<typename T> void chmax(T &x, T y){x = x < y ? y : x;}\n\ttemplate<typename T> void chmin(T &x, T y){x = x > y ? y : x;}\n}\nusing namespace Base;\n\nconst int N = 100010;\nstruct Edge{\n\tint data, next;\n}e[N * 2];\nint n, size[N], eu[N], ev[N], head[N], place, cnt;\nll num[N], dis;\nvoid build(int u, int v){\n\te[++place].data = v; e[place].next = head[u]; head[u] = place;\n}\nvoid dfs(int x, int fa, int di){\n\tdis += di;\n\tfor (int ed = head[x]; ed != 0; ed = e[ed].next)\n\t\tif (e[ed].data != fa)\n\t\t\tdfs(e[ed].data, x, di + 1);\n}\nvoid error(){\n\tprintf(\"-1\\n\");\n\texit(0);\n}\nint main(){\n\tread(n);\n\tfor (int i = 1; i <= n; i++)\n\t\tread(num[i]), size[i]++;\n\tsort(num + 1, num + n + 1);\n\tfor (int i = n; i >= 1; i--){\n\t\tint tmp = num[i] - (n - 2 * size[i]);\n\t\tif (tmp >= num[i]) continue;\n\t\tll id = lower_bound(num + 1, num + n + 1, tmp) - num;\n\t\tif (num[id] == tmp){\n\t\t\tbuild(id, i); build(i, id);\n\t\t\teu[++cnt] = id, ev[cnt] = i;\n\t\t\tsize[id] += size[i];\n\t\t}\n\t\telse error();\n\t}\n\tdfs(1, 0, 0);\n\tif (dis != num[1]) error();\n\tfor (int i = 1; i < n; i++)\n\t\tprintf(\"%d %d\\n\", eu[i], ev[i]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC target (\"sse4.2\")\n#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx,avx2,fma\")\n#pragma GCC optimize (\"unroll-loops\")\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;\n\n#define MP make_pair\n#define sp(x) fixed<<setprecision(x)\n#define pb push_back\n#define die(x) return cout << x << endl, 0\n#define fastio ios_base::sync_with_stdio(0);cin.tie(nullptr);cout.tie(nullptr);\n#define file ifstream cin(\"input.txt\"); ofstream cout(\"output.txt\")\n#define F first\n#define S second\n#define int long long\n#define lc ind << 1\n#define rc ind << 1 | 1\n//thissss\nconst int MAXN = 1000 * 1000 + 7, MOD = 1000 * 1000 * 1000 + 7;\nint n, sz[MAXN], par[MAXN];\npair<int, int>d[MAXN];\nmap<int, int>pos;\nint32_t main(){\n    fastio;\n\tcin >> n;\n\tfor(int i = 0; i < n; i ++){\n\t\tcin >> d[i].F;\n\t\td[i].S = i;\n\t}\n\tsort(d, d + n, greater<pair<int, int> >());\n\tfor(int i = 0; i < n; i ++)\n\t\tpos[d[i].F] = i + 1;\n\tfill(sz, sz + n, 1);\n\tfor(int i = 0; i < n - 1; i ++){\n\t\tint dis = d[i].F, v = d[i].S;\n\t\tint dpar = dis - (n - 2*sz[v]);\n\t\tint par= pos[dpar];\n\t\tpar --;\n\t\tif(par == -1 || par <= i)die(-1);\n\t\t::par[v] = d[par].S;\n\t\tsz[::par[v]] += sz[v];\n\t}\n\tfor(int i = 0; i < n - 1; i ++){\n\t\tint v = d[i].S;\n\t\tcout << v + 1 << ' ' << par[v] + 1 << endl;\n\t}\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n#include <numeric>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tmap<long long int, int> d_map;\n\tvector<pair<long long int, int> > d;\n\tfor(int i = 1; i <= n; i++){\n\t\tlong long int tmp;\n\t\tcin >> tmp;\n\t\td.push_back(make_pair(tmp, i));\n\t\td_map[tmp] = i;\n\t}\n\tsort(d.begin(), d.end());\n\treverse(d.begin(), d.end());\n\tvector<bool> ischecked(n, false);\n\tset<pair<int, int> > ans;\n\tfor(int i = 0; i < d.size(); i++){\n\t\tint now = d[i].second;\n\t\tlong long int nowd = d[i].first;\n\t\tif(ischecked[now]) continue;\n\t\tischecked[now] = true;\n\t\t// nowから1本でつながっている分をつなげていく\n\t\tint j = 1;\n\t\tfor(j = 1; j <= n; j++){\n\t\t\tlong long int nextd = nowd - (n  - j) + j;\n\t\t\tif(nextd >= nowd || d_map.find(nextd) == d_map.end()){\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tint next = d_map[nextd];\n\t\t\t\tans.insert(make_pair(min(now, next), max(now, next)));\n\t\t\t\tischecked[next] = true;\n\t\t\t\tnow = next;\n\t\t\t\tnowd = nextd;\n\t\t\t}\n\t\t}\n\t}\n\tif(ans.size() != n - 1){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tfor(auto i = ans.begin(); i != ans.end(); i++){\n\t\tcout << (*i).first << \" \" << (*i).second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nlong long d[100001];\nint x[100001];\nint size[100001];\nlong long g[100001];\nvector<pair<int, int> > edge;\nmap<long long, int>f;\nbool cmp(int x, int y) {\n    return d[x] > d[y];\n}\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n ; i ++)\n        scanf(\"%lld\", &d[i]), x[i] = i, size[i] = 1, f[d[i]] = i;\n    sort(x + 1, x + n + 1, cmp);\n    bool sig = 0;\n    for (int i = 1; i <= n ; i ++) {\n        long long dd = d[x[i]] +size[x[i]] - n + size[x[i]];\n        if (dd != d[x[i]]&&f[dd]) size[f[dd]] += size[x[i]], edge.push_back(make_pair(x[i], f[dd])), g[f[dd]] += g[x[i]] + size[x[i]];\n    }\n    if (size[x[n]] == n && g[x[n]] == d[x[n]]){\n        for (auto u : edge) printf(\"%d %d\\n\", u.first, u.second);\n    } else printf(\"-1\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int maxn=1e5+9;\nstruct node{\n\tint d,id;\n\tnode(int d=0,int id=0):d(d),id(id){}\n\tfriend bool operator<(node x,node y){\n\t\treturn x.d<y.d;\n\t}\n}d[maxn];\nint n,dis,tot,siz[maxn],u[maxn],v[maxn];\nsigned main(){\n\tcin>>n;\n\tfor(int i=1,x;i<=n;++i)cin>>x,d[i]=node(x,i),siz[i]=1;\n\tsort(d+1,d+1+n);\n\tfor(int i=n;i>1;--i){//最大的一定是叶子 可以递推siz\n\t\tint nxt=d[i].d-n+2*siz[i];//下一个的d\n\t\tint p=lower_bound(d+1,d+1+n,node(nxt,0))-d;\n\t\tif(d[p].d!=nxt)return puts(\"-1\"),0;//如果找不到 不符合\n\t\tu[++tot]=d[i].id;v[tot]=d[p].id;\n\t\tsiz[p]+=siz[i];\n\t\tdis+=siz[i];\n\t}\n\tif(dis!=d[1].d)puts(\"-1\");//因为只判断了d之差的关系 要看找出的siz是否符合条件\n\telse{\n\t\tfor(int i=1;i<=tot;++i)cout<<u[i]<<\" \"<<v[i]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define INF 1000000000007\nusing namespace std;\n\nint n,d[200010],sz[200010],dp[200010],minv,pos;\nmap<int,int> mp;\nvector<pair<int,int> > res;\nvector<int> v[200010];\n\ninline void dfs(int u,int pr)\n{\n\tfor(int i=0;i<v[u].size();i++) if(v[u][i]!=pr){\n\t\tdfs(v[u][i],u);\n\t\tdp[u]+=dp[v[u][i]]+sz[v[u][i]];\n\t}\n}\n\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){cin>>d[i];mp[d[i]]=i;}\n\tfor(int i=1;i<=n;i++){\n\t\tif(d[i]<minv){\n\t\t\tminv=d[i];\n\t\t\tpos=i;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){sz[i]=1;}\n  \tmap<int,int>::iterator it=mp.end();\n  \tit--;\n\tfor(;it!=mp.begin();it--){\n\t\tint num=it->first,loc=it->second;\n\t\tif(loc==pos) continue;\n\t\tif(sz[loc]*2>=n){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint cur=num-n+2*sz[loc];\n\t\tif(!mp.count(cur)){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint par=mp[cur];\n\t\tres.push_back(make_pair(par,loc));\n\t\tsz[par]+=sz[loc];\n\t}\n\tfor(int i=0;i<res.size();i++){\n\t\tv[res[i].first].push_back(res[i].second);\n\t\tv[res[i].second].push_back(res[i].first);\n\t}\n\tdfs(pos,-1);\n\tif(dp[pos]!=minv){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<res.size();i++){\n\t\tcout<<res[i].first<<\" \"<<res[i].second<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fatherdis fd\n\nlong long ans=0,n,father[100010],size[100010],first[100010],nxt[200020],u[200020],v[200020],tot=0,tmp,fatherdis,pos,judge=0,j,root,depth[100010]={0};\n\nstruct csx\n{\n\tlong long num,dis;\n}p[100010];\n\nbool cmp(const csx a,const csx b)\n{\n\tif (a.dis<b.dis) return true;\n\telse return false;\n}\n\nvoid add(long long from,long long to)\n{\n\ttot++;\n\tnxt[tot]=first[from];\n\tfirst[from]=tot;\n\tu[tot]=from;\n\tv[tot]=to;\n\treturn;\n}\n\nvoid dfs(long long point)\n{\n\tlong long k=first[point];\n\twhile (k!=-1)\n\t{\n\t\tlong long to=v[k];\n\t\tif (father[point]!=to)\n\t\t{\n\t\t    depth[to]=depth[point]+1;\n\t\t\tdfs(to);\n\t\t}\n\t\tk=nxt[k];\n\t}\n\tans+=depth[point];\n\treturn;\n}\n\nint main()\n{\n\tmemset(first,-1,sizeof(first));\n\tscanf(\"%lld\",&n);\n\tfor (int i=1;i<=n;i++) \n\t{\n\t\tscanf(\"%lld\",&tmp);\n\t\tsize[i]=1;\n\t    p[i].num=i;\n\t    p[i].dis=tmp;\n\t}\n\tsort(p+1,p+n+1,cmp);\n\troot=p[1].num;\n\tfor (int i=n;i>1;i--)\n\t{\n\t\tfd=p[i].dis-(n-2*size[p[i].num]);\n\t\tj=i-1;\n\t\twhile (j>0&&p[j].dis!=fd) j--;\n\t\tif (!j) \n\t\t{\n\t\t\tjudge=1;\n\t\t\tbreak;\n\t\t}\n\t\tfather[p[i].num]=p[j].num;\n\t\tsize[p[j].num]+=size[p[i].num];\n\t\tadd(p[j].num,p[i].num);\n\t\tadd(p[i].num,p[j].num);\n\t}\n\tdfs(root);\n\tif (judge||ans!=p[1].dis) printf(\"-1\");\n\telse for (int i=1;i<=tot/2;i++) printf(\"%lld %lld\\n\",u[i*2],v[i*2]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\n\nconst int MAXN = 1e5 + 5;\nint n, par[MAXN];\nll d, sz[MAXN];\nmap <ll, int> mp;\n\nint main()\n{\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tvector <pair<ll,int>> v;\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> d; sz[i] = 1ll;\n\t\tmp[d] = i;\n\t\tv.push_back({-d, i});\n\t}\n\tsort(v.begin(), v.end());\n\tfor(int i = 0; i < n - 1; i++){\n\t\td = -v[i].first;\n\t\tint ind = v[i].second;\n\t\tll dpar = d - (n - (2 * sz[ind]));\n\t\tif(!mp[dpar] || mp[dpar] == ind){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tpar[ind] = mp[dpar];\n\t\tsz[par[ind]] += sz[ind];\n\t}\n\tfor(int i = 0; i < n - 1; i++){\n\t\tcout << par[v[i].second] << \" \" << v[i].second << '\\n';\n\t}\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <cctype>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\ninline long long read()\n{\n\tlong long x=0,f=1;char ch=getchar();\n\twhile (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}\n\twhile (isdigit(ch)){x=x*10+ch-48;ch=getchar();}\n\treturn x*f;\n}\n\npair <long long,int> D[100050];\n\npair <int,int> edge[100050];\n\nvector <int> G[100050];\n\nint n,size[100050],tot;\n\nlong long dis[100050];\n\ninline void dfs(int u,int fa)\n{\n\tfor (int i=0;i<G[u].size();i++)\n\t{\n\t\tint v=G[u][i];\n\t\tif (v!=fa)\n\t\t{\n\t\t\tdis[v]=dis[u]+1;\n\t\t\tdfs(v,u);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tn=read();\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tlong long d=read();\n\t\tD[i]={d,i};\n\t\tsize[i]=1;\n\t}\n\tsort(D+1,D+n+1);\n\treverse(D+1,D+n+1);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tlong long delta=D[i].first-n+2*size[i];\n\t\tint l=1,r=n+1,pos=0; \n\t\twhile (l<=r)\n\t\t{\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif (D[mid].first<=delta)\n\t\t\t{\n\t\t\t\tr=mid-1;\n\t\t\t\tpos=mid;\n\t\t\t}\n\t\t\telse\n\t\t\t\tl=mid+1;\n\t\t}\n\t\t//cout << D[pos].first << \" \" << delta << endl;\n\t\tif (D[pos].first!=delta)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint u=D[i].second,v=D[pos].second;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t\tedge[++tot]={u,v};\n\t\tsize[pos]+=size[i];\n\t}\t\n\tdfs(D[n].second,0);\n\tlong long sum=0;\n\tfor (int i=1;i<=n;i++)\n\t\tsum+=dis[i];\n\tif (sum==D[n].first)\n\t{\n\t\tfor (int i=1;i<=tot;i++)\n\t\t\tcout << edge[i].first << \" \" << edge[i].second << endl;\n\t}\n\telse\n\t\tputs(\"-1\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<cstring>\n#include<utility>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<set>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#define ll long long\n#define pii pair<ll,int>\n#define mp make_pair\n#define fi first\n#define se second\n#define inf 0x7fffffff\nusing namespace std;\nll a[100010];\npii b[100010],c[100010];\nint main()\n{\n\tint i,k,n,m,x,y,x1,n1;\n\tll j;\n\tscanf(\"%d\",&n);\n\tn1=n;\n\tfor(i=0;i<n;i++)\n\t{\n\t\tscanf(\"%lld\",&a[i]);\n\t\tb[i].fi=a[i];\n\t\tb[i].se=i+1;\n\t\tc[i]=b[i];\n\t}\n\tsort(b,b+n);\n\tvector<int> cl;\n\twhile(n>1)\n\t{\n\t\tx=n-1;\n\t\ti=2;\n\t\tk=0;\n\t\tcl.clear();\n\t\twhile(x!=0&&k<n)\n\t\t{\n\t\t\tj=b[x].fi-n1+i;\n\t\t\tif(j<y)\n\t\t\t{\n\t\t\t\tprintf(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ti+=2;\n\t\t\tx1=lower_bound(b,b+n,mp(j,0))-b;\n\t\t\tif(b[x1].fi!=j)\n\t\t\t{\n\t\t\t\tprintf(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcl.push_back(x);\n\t\t\tk++;\n\t\t\tx=x1;\n\t\t}\n\t\tif(k>=n)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(i=0;i<cl.size();i++)\n\t\t{\n\t\t\tb[cl[i]]=mp(0,0);\n\t\t}\n\t\tsort(b,b+n);\n\t\treverse(b,b+n);\n\t\treverse(b,b+n-k);\n\t\tn-=k;\n\t}\n\tn=n1;\n\tsort(c,c+n);\n\twhile(n>1)\n\t{\n\t\tx=n-1;\n\t\ti=2;\n\t\tk=0;\n\t\tcl.clear();\n\t\twhile(x!=0&&k<n)\n\t\t{\n\t\t\tj=c[x].fi-n1+i;\n\t\t\ti+=2;\n\t\t\tx1=lower_bound(c,c+n,mp(j,0))-c;\n\t\t\tprintf(\"%d %d\\n\",c[x].se,c[x1].se);\n\t\t\tcl.push_back(x);\n\t\t\tk++;\n\t\t\tx=x1;\n\t\t}\n\t\tif(k>=n)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(i=0;i<cl.size();i++)\n\t\t{\n\t\t\tc[cl[i]]=mp(0,0);\n\t\t}\n\t\tsort(c,c+n);\n\t\treverse(c,c+n);\n\t\treverse(c,c+n-k);\n\t\tn-=k;\n\t}\n\treturn 0;\n}/*\n7\n10\n15\n13\n18\n11\n14\n19\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nconst int MX = 100000;\nint n, sz[MX];\nll sum[MX];\nvector<vi> e;\nvector<ll> ans2;\nvoid rec(int c, int p){\n\tsz[c] = 1;\n\tfor(int i : e[c]) if(i != p){\n\t\trec(i, c);\n\t\tsz[c] += sz[i];\n\t\tsum[c] += sum[i] + sz[i];\n\t}\n}\nvoid rec(int c, int p, ll csum){\n\tans2[c] = csum;\n\tfor(int i : e[c]) if(i != p) rec(i, c, csum - 2 * sz[i] + n);\n}\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tcin >> n;\n\tvi sz(n, 1);\n\tvector<pair<ll, int>> v;\n\trep(i, n){\n\t\tll x; cin >> x;\n\t\tv.emplace_back(x, i);\n\t}\n\tsort(all(v));\n\tvector<pi> ans;\n\t\n\t//dbg(v);\n\t\n\tfor(int i = n - 1; i > 0; i--){\n\t\tll nx = v[i].first - n + 2 * sz[v[i].second];\n\t\tauto j = lower_bound(all(v), pair<ll, int>(nx, -1));\n\t\t\n\t\t//dbg(i, nx);\n\t\t\n\t\tif(j - v.begin() >= i || j->first != nx){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tans.emplace_back(j->second, v[i].second);\n\t\tsz[j->second] += sz[v[i].second];\n\t}\n\tassert(sz[v[0].second] == n);\n\t\n\te.resize(n);\n\tfor(auto i : ans){\n\t\te[i.first].pb(i.second);\n\t\te[i.second].pb(i.first);\n\t}\n\t\n\trec(0, 0);\n\tans2.resize(n);\n\trec(0, 0, sum[0]);\n\tvector<pair<ll, int>> u;\n\trep(i, n) u.emplace_back(ans2[i], i);\n\tsort(all(u));\n\t\n\tif(u != v){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tfor(auto i : ans) cout << i.first+1 << \" \" << i.second+1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <map>\n#define Maxn 100005\nint n,id[Maxn],par[Maxn],sz[Maxn];\nlong long a[Maxn];\nstd::map <long long,int> mp;\nint cmp(const void* x,const void* y){return a[*(int*)y]-a[*(int*)x];}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%lld\",&a[i]);\n\t\tmp[a[i]]=i;\n\t\tid[i]=i;\n\t\tsz[i]=1;\n\t}\n\tqsort(id+1,n,sizeof(int),cmp);\n\tfor (int i=1;i<n;++i)\n\t{\n\t\tint x=id[i];\n\t\tpar[x]=mp[a[x]-n+2*sz[x]];\n\t\tif (!par[x]) return (int)puts(\"-1\")*0;\n\t\tsz[par[x]]+=sz[x];\n\t}\n\tfor (int i=1;i<n;++i) a[id[n]]-=sz[id[i]];\n\tif (a[id[n]]) return (int)puts(\"-1\")*0;\n\tfor (int i=1;i<n;++i) printf(\"%d %d\\n\",id[i],par[id[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nstruct Node {\n\tint parent{-1}, children{1}, id{};\n\tlong long d;\n};\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tstd::vector<Node> nodes(n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%lld\", &nodes[i].d);\n\t\tnodes[i].id = i;\n\t}\n\tstd::sort(nodes.begin(), nodes.end(),\n\t\t[](const Node& a, const Node& b){ return a.d < b.d; }\n\t);\n\tfor (auto node{nodes.rbegin()}; node + 1 < nodes.rend(); node++)\n\t{\n\t\tauto parent = std::lower_bound(nodes.begin(), nodes.end(), node->d - n + 2 * node->children,\n\t\t\t[](Node &e, long long value){ return e.d < value; }\n\t\t);\n\t\tif (parent == nodes.end() || parent->d != node->d - n + 2 * node->children || parent->id == node->id)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tnode->parent = parent->id;\n\t\tparent->children += node->children;\n\t}\n\tfor (auto node{nodes.begin() + 1}; node < nodes.end(); node++)\n\t{\n\t\tprintf(\"%d %d\\n\", node->id + 1, node->parent + 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <assert.h>\nusing namespace std;\ntypedef long long LL;\nconst int N=100000+10;\nint n,sz[N],ss[N]; \npair<int,LL> d[N];\nvector<int> g[N];\nbool cmp(pair<int,LL> p1,pair<int,LL> p2){\n    return p1.second>p2.second;\n}\nmap<LL,int> mp;\nvector< pair<int,int> > res;\nvoid prt(int u,int p){\n    ss[u]=1;\n    for(auto v:g[u]){\n        if(v==p)continue;\n        res.push_back(make_pair(u,v));\n        prt(v,u);\n        ss[u]+=ss[v];\n    }\n}\nint main() {\n    scanf(\"%d\",&n); \n    for(int i=1;i<=n;i++){\n        d[i].first=i; \n        scanf(\"%lld\",&d[i].second);\n        mp[d[i].second]=i;\n        sz[i]=1;\n    }\n    sort(d+1,d+1+n,cmp);\n    for(int i=1;i<n;i++){\n        LL tmp=d[i].second;\n        LL nex=tmp-(n-2*sz[d[i].first]);\n        if(mp[nex]==0||nex>=tmp){\n            return !printf(\"-1\\n\");\n        }\n        int u=mp[nex];\n        int v=d[i].first;\n        g[u].push_back(v); g[v].push_back(u);\n        sz[u]+=sz[v];\n    }\n    prt(d[n].first,d[n].first);\n    for(int i=1;i<=n;i++) if(ss[i]!=sz[i]) return !printf(\"-1\\n\");\n    if(res.size()==n-1){\n        for(auto p: res) printf(\"%d %d\\n\", p.first, p.second);\n    } else {\n        printf(\"-1\\n\");\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long s64; \ntypedef std::pair<int, int> pii; \n\ntemplate <class T>\ninline void read(T &x) {\n\tstatic char ch; \n\twhile (!isdigit(ch = getchar())); \n\tx = ch - '0'; \n\twhile (isdigit(ch = getchar()))\n\t\tx = x * 10 + ch - '0'; \n}\n\ninline void invalid() {\n\tputs(\"-1\"); \n\texit(0); \n}\n\nconst int MaxN = 1e5 + 5;  \n\nint n; \nint sze[MaxN]; \nbool vis[MaxN]; \n\ns64 d[MaxN], c[MaxN];\nstd::vector<pii> ans; \nstd::map<s64, int> pos; \n\nint fa[MaxN]; \nstd::vector<int> adj[MaxN]; \n\ninline void addEdge(int u, int v) {\n\tsze[u] += sze[v]; \n\tadj[u].push_back(v); \n\tans.push_back(pii(u, v)); \n}\n\ninline void dfs(int u) {\n\tfor (int v : adj[u]) {\n\t\tdfs(v); \n\t\tc[u] += c[v] + sze[v]; \n\t}\n}\n\nbool check() {\n\tint G = pos[d[n]]; \n\treturn dfs(G), c[G] == d[n]; \n}\n\nint main() {\n#ifdef orzczk\n\tfreopen(\"tree.in\", \"r\", stdin); \n#endif\n\t\n\tread(n); \n\tfor (int i = 1; i <= n; ++i) {\n\t\tread(d[i]); \n\t\tsze[i] = 1; \n\t\tpos[d[i]] = i; \n\t}\n\tstd::sort(d + 1, d + n + 1, std::greater<s64>()); \n\n\tfor (int i = 1; i < n; ++i) {\n\t\tint v = pos[d[i]], u; \n\t\ts64 faD = d[i] - n + 2 * sze[v]; \n\n\t\tvis[v] = true; \n\t\tif (!pos.count(faD) || vis[u = pos[faD]]) {\n\t\t\tinvalid(); \n\t\t}\n\t\t\n\t\taddEdge(u, v); \n\t}\n\n\tif (check()) {\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\tprintf(\"%d %d\\n\", ans[i].first, ans[i].second); \n\t\t}\n\t} else {\n\t\tinvalid(); \n\t}\n\n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=100005;\nint n,mnid;\nint par[maxn],sz[maxn];\nll d[maxn];\nset<ll>s[2];\nmap<ll,int>rev;\nqueue<int>q;\n\nint main(){\n\tscanf(\"%d\",&n);\n\tREP(i,n){\n\t\tscanf(\"%lld\",&d[i]);\n\t\tif(!mnid||d[i]<d[mnid])mnid=i;\n\t\ts[d[i]&1].insert(d[i]);\n\t\trev[d[i]]=i;\n\t}\n\tint cc=n&1;\n\tq.push(mnid);\n\tsz[mnid]=n;\n\ts[d[mnid]&1].erase(s[d[mnid]&1].find(d[mnid]));\n\twhile(!q.empty()){\n\t\tint x=q.front();q.pop();\n\t\twhile(sz[x]>1){\n\t\t\tint c=cc^(d[x]&1); \n\t\t\tset<ll>::iterator it=s[c].upper_bound(n+d[x]-2*sz[x]);\n\t\t\tif(it==s[c].end()){\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint y=rev[*it];\n\t\t\tpar[y]=x;\n\t\t\tsz[y]=(n-d[y]+d[x])/2;\n\t\t\tif(sz[y]<=0){\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tsz[x]-=sz[y];\n\t\t\tq.push(y);\n\t\t\ts[c].erase(it);\n\t\t}\n\t}\n\tREP(i,n)if(i!=mnid){\n\t\tif(!par[i]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tprintf(\"%d %d\\n\",par[i],i);\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "/*input\n15\n57\n62\n47\n45\n42\n74\n90\n75\n54\n50\n66\n63\n77\n87\n51\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\n\n//}}}\nconst ll maxn=300005;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=8000000000000000000LL;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=ll(1e9+7);\nconst double PI=acos(-1);\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\t\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n#define int ll\nll d[maxn];\nset<pll,greater<pll>> st;\nvector<pii> edge;\nint sz[maxn];\nint32_t main()\n{\n\tIOS;\n\tint n;\n\tcin>>n;\n\tREP(i,n) cin>>d[i];\n\tREP(i,n) st.insert(MP(d[i],i));\n\tREP(i,n) sz[i]=1;\n\n\twhile(SZ(st)>1){\n\t\tauto cur=*st.begin();\n\t\t// cout<<cur<<'\\n';\n\t\tst.erase(st.begin());\n\t\tll new_size=cur.F+sz[cur.S]-(n-sz[cur.S]);\n\t\tauto nxt=*st.lower_bound(MP(new_size,INF64));\n\t\tif(nxt.F!=new_size){\n\t\t\tcout<<\"-1\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tedge.pb(MP(cur.S,nxt.S));\n\t\tsz[nxt.S]+=sz[cur.S];\n\t}\n\tfor(int i=0;i<n-1;i++){\n\t\tcout<<edge[i].F+1<<' '<<edge[i].S+1<<'\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//kmcode\n#include<bits/stdc++.h>\n#define ll long long\n#define pii pair<int,int> \n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fi first\n#define se second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint n;\nvector<ll> d;\nvector<int> v[100002];\nmap<ll,int> ret;\nint siz[100002];\nbool vis[100002];\nll dp[100002];\nint cnt[100002];\ninline void die(){\n    puts(\"-1\");\n    exit(0);\n}\ninline void dfs(int b,int pr=-1){\n    cnt[b]++;\n    vis[b]=1;\n    for(int i=0;i<v[b].size();i++){\n        int go=v[b][i];\n        if(go==pr) continue;\n        if(vis[go])\n            die();\n        dfs(go,b);\n        dp[b]+=dp[go]+cnt[go];\n        cnt[b]+=cnt[go];\n    }\n}\nll ans[100001];\ninline void dfs2(int b,int pr=-1,ll weight=0){\n    ans[b]=dp[b]+weight;\n    weight+=dp[b];\n    for(int i=0;i<v[b].size();i++){\n        int go=v[b][i];\n        if(go==pr) continue;\n        dfs2(go,b,weight-dp[go]-cnt[go]+(n-cnt[go]));\n    }\n}\nvector<pii> ed;\nint main(){\n    cin>>n;\n    for(int i=0;i<n;i++){\n        ll a;\n        cin>>a;\n        d.pb(a);\n        ret[a]=i;\n    }\n    for(auto it=ret.rbegin();it!=ret.rend();it++){\n        int node=(*it).se;\n        ll val=(*it).fi;\n        siz[node]++;\n        ll op=n-siz[node];\n        if(op==0) continue;\n        ll nex=val+siz[node]-op;\n        if(!ret.count(nex))\n            die();\n        int ne=ret[nex];\n        siz[ne]+=siz[node];\n        v[ne].pb(node);\n        v[node].pb(ne);\n        ed.pb(mp(ne+1,node+1));\n    }\n    dfs(0);\n    dfs2(0);\n    for(int i=0;i<n;i++){\n        if(vis[i]==0)\n            die();\n        if(ans[i]!=d[i])\n            die();\n    }\n    for(int i=0;i<ed.size();i++)\n        cout<<ed[i].fi<<\" \"<<ed[i].se<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int maxn = 101010;\nstruct Node{\n    int num;\n    ll d;\n    bool operator < (const Node &tx) const {\n        return d < tx.d;\n    }\n}a[maxn];\nint n, flag;\nint siz[maxn];\n\nqueue<int> q[2];\nvector<pair<int, int> > ans;\n\nint main(){\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i ++){\n        scanf(\"%lld\", &a[i].d);\n        a[i].num = i;\n    }\n\n    sort(a+1, a+1+n);\n\n    q[a[1].d & 1].push(1);\n    siz[a[1].num] = n - 1;\n    int tem_flag = n & 1;\n    \n    for(int i = 2; i <= n; i ++){\n        if(q[1 & (a[i].d ^ tem_flag)].empty()){\n            printf(\"-1\");\n            return 0;\n        }\n        int tem_num = q[1 & (a[i].d ^ tem_flag)].front();\n\n        ll diff = a[i].d - a[tem_num].d;\n        int diff_siz = (n - diff) / 2;\n        \n        siz[a[i].num] = diff_siz - 1;\n        siz[a[tem_num].num] -= diff_siz;\n\n        if(diff_siz > 1)\n            q[a[i].d & 1].push(i);\n        ans.push_back(make_pair(a[i].num, a[tem_num].num));\n        if(siz[a[tem_num].num] <= 0) q[1 & (a[i].d ^ tem_flag)].pop();\n    }\n\n    for(int i = 1; i <= n; i ++){\n        if(siz[i]){\n            printf(\"-1\\n\");\n            return 0;\n        }\n    }\n\n    int siz = ans.size() - 1;\n    for(int i = 0; i <= siz; i ++)\n        printf(\"%d %d\\n\", ans[i].first, ans[i].second);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stdio.h>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n \nusing namespace std;\n\ntypedef long long ll;\n \nconst ll INF = 1e9;\n \nvector < pair <ll, ll> > v;\n \nll n, sz[1000000];\n \nvector <ll> g[1000000];\n \nint main () \n{\n    cin >> n;\n    \n    for (ll i = 0; i < n; i++)\n    {\n\tll d;\n\tscanf (\"%lld\", &d);\n\t\n\tv.emplace_back (d, i);\n    }\n    \n    sort (v.begin (), v.end ());\n    \n    for (ll i = n - 1; i; i--)\n    {\n\tll x = v[i].second, d = v[i].first;\n\t\n\tv.pop_back ();\n\t\n\tsz[x] = 1;\n\t\n\tfor (ll to : g[x])\n\t    sz[x] += sz[to];\n\t\n\tll k = upper_bound (v.begin (), v.end (), make_pair (d + 2 * sz[x] - n, -1LL)) - v.begin ();\n\t\n\tif (k == v.size () || v[k].first != d + 2 * sz[x] - n)\n\t{\n\t    cout << -1;\n\t    return 0;\n\t}\n\t\n\tg[v[k].second].push_back (x);\n    }\n    \n    for (ll i = 0; i < n; i++)\n\tfor (ll to : g[i])\n\t{\n\t    printf (\"%lld %lld\\n\", i + 1, to + 1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tint n; cin >> n;\n\tvi sz(n, 1);\n\tvector<pair<ll, int>> v;\n\trep(i, n){\n\t\tll x; cin >> x;\n\t\tv.emplace_back(x, i);\n\t}\n\tsort(all(v));\n\tvector<pi> ans;\n\t\n\t//dbg(v);\n\t\n\tfor(int i = n - 1; i > 0; i--){\n\t\tll nx = v[i].first - n + 2 * sz[v[i].second];\n\t\tauto j = lower_bound(all(v), pair<ll, int>(nx, -1));\n\t\t\n\t\t//dbg(i, nx);\n\t\t\n\t\tif(j - v.begin() >= i || j->first != nx){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tans.emplace_back(j->second, v[i].second);\n\t\tsz[j->second] += sz[v[i].second];\n\t}\n\tassert(sz[v[i].second] == n);\n\t\n\tfor(auto i : ans) cout << i.first+1 << \" \" << i.second+1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cstdlib>\n\n#define int long long\n\nusing namespace std;\n\nint n, S[100010], W[100010], D[100010], Sz[100010], F[100010], ans = 0;\n\nint find(int x) {\n    int t = lower_bound(D + 1, D + n + 1, x) - D;\n    if(D[t] != x) {\n        puts(\"-1\");\n        exit(0);\n    }\n    return t;\n}\n\nsigned main() {\n    scanf(\"%lld\", &n);\n    for(int i = 1; i <= n; i++) scanf(\"%lld\", &D[i]);\n    memcpy(S, D, sizeof D);\n    sort(D + 1, D + n + 1);\n    for(int i = 1; i <= n; i++) W[find(S[i])] = i;\n    for(int i = 1; i <= n; i++) Sz[i] = 1;\n    for(int i = n; i > 1; i--) {\n        F[i] = find(D[i] - n + Sz[i] * 2);\n        Sz[F[i]] += Sz[i];\n        ans += Sz[i];\n    }\n    if(ans != D[1]) {\n        puts(\"-1\");\n        return 0;\n    }\n    for(int i = 2; i <= n; i++) printf(\"%lld %lld\\n\", W[i], W[F[i]]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#define ll long long\nusing namespace std;\nmap<ll,int> us;\nll d[100010];\nll che=0;\nint n,cnt=0;\nstruct node{\n\tint to,nxt,cap;\n}e[200010];\nint pos[100010],siz[100010],head[100010],ansa[100010],ansb[100010];\nbool cmp(int a,int b){\n\treturn d[a]>d[b];\n}\nvoid add(int u,int v){\n\te[++cnt].to=v;e[cnt].nxt=head[u];head[u]=cnt;\n\te[++cnt].to=u;e[cnt].nxt=head[v];head[v]=cnt;\n}\nvoid dfs(int x,int fa,int dep){\n\tche+=dep;\n\tint i;\n\tfor(i=head[x];i;i=e[i].nxt){\n\t\tif(e[i].to==fa)  continue ;\n\t\tdfs(e[i].to,x,dep+1);\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tint i,j;\n\tfor(i=1;i<=n;++i){\n\t\tscanf(\"%lld\",&d[i]);us[d[i]]=i;siz[i]=1;pos[i]=i;\n\t}\n\tsort(pos+1,pos+1+n,cmp);\n\tfor(i=1;i<n;++i){\n\t\tll x=d[pos[i]]-(n-siz[pos[i]])+siz[pos[i]];\n\t\tif(!us[x] || x>=d[pos[i]]){printf(\"-1\\n\");return 0;}\n\t\tansa[i]=us[x];ansb[i]=pos[i];\n\t\tadd(us[x],pos[i]);\n\t\tsiz[us[x]]+=siz[pos[i]];\n\t}\n\tdfs(pos[n],0,0);\n\tif(che!=d[pos[n]]){printf(\"-1\\n\");return 0;}\n\tfor(i=1;i<n;++i)  printf(\"%d %d\\n\",ansa[i],ansb[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\nusing ll = long long;\n\nint main() {\n  int n;\n  cin >> n;\n  vector<ll> d(n);\n  vector<int> parent(n, -1);\n  vector<int> p(n);\n  vector<ll> size(n, 1);\n  map<ll, int> mp;\n  for (int i = 0; i < n; i++) {\n    cin >> d[i];\n    p[i] = i;\n    mp[d[i]] = i;\n  }\n  sort(p.begin(), p.end(), [&](int i, int j) { return d[i] > d[j]; });\n  p.pop_back();\n  for (int i : p) {\n    ll tmp = d[i] - n + 2 * size[i];\n    if (mp.count(tmp)) {\n      parent[i] = mp[tmp];\n      size[parent[i]] += size[i];\n    } else {\n      cout << -1 << '\\n';\n      return 0;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (parent[i] != -1) {\n      cout << i+1 << ' ' << parent[i]+1 << '\\n';\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+3;\nint n,siz[N],he[N],e;\nlong long anss;\nstruct syzs{\n\tlong long val;\n\tint num;\n} a[N];\nstruct ans{\n\tint e1,e2;\n\tbool operator <(const ans &emm) const{\n\t    if(emm.e1==e1) return e2>emm.e2;\n\t\treturn emm.e1<e1;\n\t}\n};\nstruct edg{\n\tint ne,to;\n} edg[N];\nbool cmp(syzs c,syzs b){\n\treturn c.val>b.val;\n}\nint find(int k){\n\tlong long chec=2*siz[k]-n;\n\tfor(int i=k+1;i<=n;i++) if(a[i].val-a[k].val==chec) return i;\n\treturn -1;\n}\nlong long read(){\n\tlong long s=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}\n\treturn s*f;\n}\nvoid add(int u,int v){\n\tedg[++e].to=v;\n\tedg[e].ne=he[u];\n\the[u]=e;\n}\nvoid test(int u,int fa,int dep){\n\tanss+=dep;\n\tfor(int i=he[u];i;i=edg[i].ne){\n\t\tint v =edg[i].to;\n\t\tif(v==fa) continue;\n\t\ttest(v,u,dep+1);\n\t}\n}\nint main(){\n    priority_queue <ans> q;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\ta[i].val=read();//scanf(\"%lld\",&a[i].val);\n\t\ta[i].num=i;\n\t\tsiz[i]=1;\n\t}\n\tsort(a+1,a+n+1,cmp);\n\tfor(int i=1;i<n;i++){\n\t\tint v=find(i);\n\t\tif(v==-1){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[v]+=siz[i];\n\t\tadd(a[i].num,a[v].num);\n\t\tadd(a[v].num,a[i].num);\n\t\tq.push((ans) {min(a[v].num,a[i].num),max(a[v].num,a[i].num)});\n\t}\n\ttest(a[1].num,0,0);\n\tif(anss!=a[1].val){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\twhile(!q.empty()){\n\t\tint v1=q.top().e1,v2=q.top().e2;\n    \tq.pop();\n    \tprintf(\"%d %d\\n\",v1,v2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\nThough leaves are many, the root is one;\nThrough all the lying days of my youth\nI swayed my leaves and flowers in the sun,\nNow many I wither into the truth.\n-- William Butler Yeats\nµ±»ªÃÀµÄÒ¶Æ¬Âä¾¡£¬ÉúÃüµÄÂöÂç²ÅÀúÀú¿É¼û\n*/ \n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <string.h>\n#include <stack>\n#define Endl endl\n#define mp make_pair\n#define ll long long \n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define over(A) {cout<<A<<endl;exit(0);}\n#define all(A) A.begin(),A.end()\n#define ceil(a,b) ((a-1)/b+1)\n#define srand() mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n#define rand(l,r) uniform_int_distribution<int>(l,r)(rng)\ntypedef unsigned long long ull;\nconst int inf=1039074182;\nusing namespace std;\nll n;\nll d[100005];\nmap <ll,ll> m;\npair<ll,ll> p[100005];\nll sub[100005];\nll sz[100005];\nvector <pair<ll,ll> >res;\nvector <int>vec[100005];\nll dp[100005];\n\nint dfs(int x,int p=-1)\n{\n\tsz[x]=1;\n\tfor(int i=0;i<vec[x].size();i++)\n\t{\n\t\tif(vec[x][i]==p) continue;\n\t\tsz[x]+=dfs(vec[x][i],x);\n\t}\n\treturn sz[x];\n}\n\nint go(int x,int p=-1)\n{\n\tdp[x]=sz[x]-1;\n\tfor(int i=0;i<vec[x].size();i++)\n\t{\n\t\tif(vec[x][i]==p) continue;\n\t\tdp[x]+=go(vec[x][i],x);\n\t}\n\treturn dp[x];\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\",\"r\",stdin);\n\tios_base::sync_with_stdio(false);\n\tcin>>n;\n\tfor(ll i=0;i<n;i++)\n\t{\n\t\tcin>>d[i];\n\t\tm[d[i]]=i;\n\t\tp[i].first=d[i];\n\t\tp[i].second=i;\n\t\tsz[i]=1;\n\t}\n\tsort(p,p+n);\n\treverse(p,p+n);\n\tmemset(sub,-1,sizeof(sub));\n\tfor(ll i=0;i<n-1;i++)\n\t{\n\t\tll de=p[i].first;\n\t\tll x=p[i].second;\n\t\tsub[x]=n-sz[x]*2;\n//\t\tcout<<x+1<<'-'<<de<<'-'<<sub[x]<<'-'<<sz[i]<<endl;\n\t\tif(sub[x]==0) over(\"-1\");\n\t\tif(m.find(de-sub[x])==m.end()) over(\"-1\");\n\t\tll par=m[de-sub[x]];\n\t\tsz[par]+=sz[x];\n\t\tdp[par]+=dp[x];\n\t\tres.push_back(mp(x,par));\n\t}\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tvec[res[i].first].push_back(res[i].second);\n\t\tvec[res[i].second].push_back(res[i].first);\n\t}\n\tdfs(p[n-1].second);\n\tgo(p[n-1].second);\n//\tcout<<dp[p[n-1].second]<<endl;\n\tif(dp[p[n-1].second]!=p[n-1].first) over(\"-1\");\n\tfor(ll i=0;i<n-1;i++)\n\t{\n\t\tcout<<res[i].first+1<<' '<<res[i].second+1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\nmap<long long,int> id;\nint size[100005];\nvector<pair<int,int> >e;\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tlong long D;\n\t\tscanf(\"%lld\",&D);\n\t\tid[D]=i;\n\t}\n\tfor(int i=1;i<=n;i++)size[i]=1;\n\tfor(int j=1;j<n;j++){\n\t\tlong long d=id.rbegin()->first;\n\t\tint x=id.rbegin()->second;\n\t\tid.erase(d);\n\t\td-=n-2*size[x];\n\t\tif(!id.count(d)||size[x]*2>n){puts(\"-1\"); return 0;}\n\t\te.push_back(make_pair(id[d],x));\n\t\tsize[id[d]]+=size[x];\n\t}\n\tif(size[id.begin()->second]!=n){puts(\"-1\"); return 0;}\n\tfor(int i=0;i<e.size();i++)printf(\"%d %d\\n\",e[i].first,e[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<cstring>\n#include<utility>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<set>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#define ll long long\n#define pii pair<int,int>\n#define mp make_pair\n#define fi first\n#define se second\n#define inf 0x7fffffff\nusing namespace std;\npii a[100010];\nint main()\n{\n\tint i,j,k,n,m;\n\tll x,y;\n\tscanf(\"%d\",&n);\n\tx=0;\n\tfor(i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&a[i].fi,&a[i].se);\n\t\tx=max(x,1ll*abs(a[i].se)+abs(a[i].fi));\n\t\tif(i>0&&(((1ll*abs(a[i].se)+abs(a[i].fi))&1)!=((1ll*abs(a[i-1].se)+abs(a[i-1].fi))&1)))\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(i=0;i<=40;i++)\n\t{\n\t\tif((1ll<<(i))-1>=x)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\tm=i;\n\tprintf(\"%d\\n\",x%2==1?i:i+1);\n\tfor(i=0;i<m;i++)\n\t{\n\t\tprintf(\"%d \",1<<i);\n\t}\n\tif(x%2==0)\n\t{\n\t\tprintf(\"1\");\n\t}\n\tprintf(\"\\n\");\n\tstring s;\n\tfor(i=0;i<n;i++)\n\t{\n\t\tj=0;\n\t\ts=\"\";\n\t\tif(x%2==0)\n\t\t{\n\t\t\ta[i].fi++;\n\t\t}\n\t\tfor(j=0;j<m;j++)\n\t\t{\n\t\t\tif(abs(a[i].fi)>abs(a[i].se))\n\t\t\t{\n\t\t\t\tif(a[i].fi>0)\n\t\t\t\t{\n\t\t\t\t\ts+=\"R\";\n\t\t\t\t\ta[i].fi-=(1<<(m-j-1));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts+=\"L\";\n\t\t\t\t\ta[i].fi+=(1<<(m-j-1));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(a[i].se>0)\n\t\t\t\t{\n\t\t\t\t\ts+=\"U\";\n\t\t\t\t\ta[i].se-=(1<<(m-j-1));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts+=\"D\";\n\t\t\t\t\ta[i].se+=(1<<(m-j-1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treverse(s.begin(),s.end());\n\t\tcout<<s<<\"L \"[x%2];\n\t\tprintf(\"\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXn = 1e5 + 10;\ntypedef pair<long long, int> pii;\npii ar[MAXn];\nlong long n, sz[MAXn], root, disroot, d[MAXn], hp3[MAXn];\nvector<int> vec[MAXn];\nvector<pii> ans;\n\nbool cmp(pii p1, pii p2) {\n\treturn p1.first > p2.first;\n}\n\nlong long dfs1(int v, int  par) {\n\tlong long res = 0;\n\tfor (int i = 0; i < vec[v].size(); i++)\n\t\tif (vec[v][i] != par) {\n\t\t\tres += dfs1(vec[v][i], v) + hp3[vec[v][i]];\n\t\t\thp3[v] += hp3[vec[v][i]];\n\t\t}\n\thp3[v]++;\n\treturn res;\n\t\n}\n\nvoid dfs2(int v, int par, int sth) {\n\tif (sth != d[v]) {\n\t\tcout << -1;\n\t\texit(0);\n\t}\n\tfor (int i = 0; i < vec[v].size(); i++) {\n\t\tif (vec[v][i] != par) {\n\t\t\tdfs2(vec[v][i], v, sth - (hp3[vec[v][i]]) + (hp3[0] - hp3[vec[v][i]]));\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}\nint main() {\n\tcin >> n;\n\tfill_n(sz, MAXn, 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tint di;\n\t\tcin >> di;\n\t\td[i] = di;\n\t\tar[i].first = di;\n\t\tar[i].second = i;\n\t}\n\tsort(ar, ar + n);\n\tfor (int i = n - 1; i >= 1; i--) {\n\t\tlong long hp = ar[i].first - n;\n\t\thp += 2 * sz[i];\n\t\tint hp2 = lower_bound(ar, ar + n, pii(hp, -1)) - ar;\n\t\tif (ar[hp2].first != hp)\n\t\t\treturn cout << -1,0;\n\t\tsz[hp2]+= sz[i];\n\t\tvec[ar[hp2].second].push_back(ar[i].second);\n\t\tvec[ar[i].second].push_back(ar[hp2].second);\n\t\tans.push_back(pii(ar[i].second, ar[hp2].second));\n\t}\n\tdisroot = dfs1(0, -1);\n\tdfs2(0, -1, disroot);\n\tfor (int i = 0; i < ans.size(); i++)\n\t\tcout << ans[i].first + 1<< ' ' << ans[i].second + 1<< endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long h[100009];\nlong long sz[100009];\nlong long f[100009];\nlong long D[100009];\nvector<long long> v[100009];\nmap<long long,long long> M;\nvoid dfs(long long x, long long de){\n    f[x] = 1;\n    h[x] = de;\n    for(long long i = 0; i < v[x].size(); i++){\n        if(!f[v[x][i]]) dfs(v[x][i], de + 1);\n    }\n}\nmain(){\n    long long n;\n    cin >> n;\n    for(long long i = 1; i <= n; i++){\n        cin >> D[i];\n        M[D[i]] = i;\n        sz[i] = 1;\n    }\n    sort(D + 1, D + n + 1);\n    for(long long i= n; i >= 2; i--){\n        long long k = M[D[i]];\n        long long diff = n - 2 * sz[k];\n        if(diff <= 0 || !M[D[i] - diff]){\n            cout << -1 << endl;\n            return 0;\n        }\n\n        v[k].push_back(M[D[i]-diff]);\n        v[M[D[i] - diff]].push_back(k);\n        sz[M[D[i] - diff]] += sz[k];\n\n    }\n\n    dfs(1,0);\n    long long S = 0;\n    for(long long i = 1; i <= n; i++){\n        S += h[i];\n    }\n    if(S == D[1]){\n        for(long long i = 1; i <= n; i++){\n            for(long long j = 0; j < v[i].size(); j++){\n                if(i < v[i][j]){\n                    cout<<i<<\" \"<<v[i][j]<<endl;\n                }\n            }\n        }\n    }\n    else{\n        cout<< -1 << endl;\n        return 0;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Inf 0x3f3f3f3f\n#define rg register\nusing namespace std;\nconst int Maxn = 1e5 + 5;\ntypedef long long ll;\ntypedef ll arr[Maxn];\nll min(ll x, ll y) { return x < y ? x : y; }\nll max(ll x, ll y) { return x > y ? x : y; }\ninline ll read()\n{\n\trg ll res = 0, sign = 1;\n\trg char ch = getchar();\n\twhile (!isdigit(ch))\n\t{\n\t\tif (ch == '-')\n\t\t\tsign = -1;\n\t\tch = getchar();\n\t}\n\tdo\n\t{\n\t\tres = (res << 3) + (res << 1) + (ch ^ 48);\n\t\tch = getchar();\n\t} while (isdigit(ch));\n\treturn res * sign;\n}\nint n;\narr siz, fa;\nstruct str\n{\n\tll d;\n\tint id;\n\tbool operator<(str A) const { return d < A.d; }\n} p[Maxn];\n\nint main()\n{\n\tint tmp, now, s;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tp[i] = {read(), i};\n\t\tsiz[i] = 1;\n\t}\n\tsort(p + 1, p + n + 1);\n\tfor (int i = n; i > 1; i--)\n\t{\n\t\tnow = p[i].id;\n\t\ttmp = p[i].d - n + 2 * siz[now];\n\t\tfa[now] = p[s = lower_bound(p + 1, p + n + 1, (str){tmp, 0}) - p].id;\n\t\tif (p[s].d != tmp || s == i)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[fa[now]] += siz[now];\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (fa[i])\n\t\t\tprintf(\"%d %d\\n\", fa[i], i);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\n//ll mod=1000000007;\nll mod=998244353;\nll inf=1000000000000000000;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(int i=n;i>=m;i--)\nll lmax(ll a,ll b){\n    if(a<b)return b;\n    else return a;\n}\nll lmin(ll a,ll b){\n    if(a<b)return a;\n    else return b;\n}\nint main(){\n    ll n;cin>>n;\n    ll d[n];\n    vector<pll> v;\n    ll num;\n    ll mi=inf;\n    rep(i,0,n){\n        cin>>d[i];\n        v.push_back(make_pair(d[i],i));\n        if(mi>d[i]){\n            mi=d[i];\n            num=i;\n        }\n    }\n  sort(v.begin(),v.end());\n    ll root=v[0].first;\n    ll now=-1;\n    ll sa=-1;\n    ll par=-1;\n    vector<pll> ans;\n  ll qq=1;\n  bool used[n];fill(used,used+n,false);\n    for(;;){\n      if(sa==n-2){\n        now=-1;\n        sa=-1;\n        qq++;\n        continue;\n      }\n      if(qq==n)break;\n        if(now==-1){\n            pll p=v[qq];\n            if(used[p.second]){\n              qq++;\n              continue;\n            }\n            now=p.first;\n            ll ban=p.second;\n            //cout<<now<<endl;\n            if(now>root+n-2){\n                cout<<-1<<endl;\n                return 0;\n            }\n            sa=now-root;\n          used[p.second]=true;\n            ans.push_back(make_pair(num,ban));\n            par=ban;\n        }\n        else{\n          pll g=make_pair(now+sa+2,0);\n            ll y=lower_bound(v.begin(),v.end(),g)-v.begin();\n            if(y==n){\n                if(sa!=n-2){\n                    cout<<-1<<endl;\n                    return 0;\n                }\n                now=-1;\n                sa=-1;\n              qq++;\n            }\n            else{\n                pll p=v[y];\n                if(p.first!=now+sa+2){\n                    cout<<-1<<endl;\n                    return 0;\n                }\n                ans.push_back(make_pair(par,p.second));\n                par=p.second;\n                now=p.first;\n                sa+=2;\n                used[p.second]=true;\n            }\n        }\n        \n        //cout<<now<<\" \";\n    }\n    rep(i,0,ans.size()){\n        if(ans[i].first>ans[i].second)swap(ans[i].first,ans[i].second);\n    }\n    sort(ans.begin(),ans.end());\n    rep(i,0,ans.size())cout<<ans[i].first+1<<\" \"<<ans[i].second+1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nconst long long mo=50000007;\nconst int maxn=200010;\n\nint n,m,id[maxn],fa[maxn];\nlong long d[maxn],siz[maxn],ans,js[maxn];\nint tot,nex[maxn*2],las[maxn*2],tov[maxn*2];\nint hs[mo+10];\n\nvoid con(int x,int y)\n{\n\ttot++;\n\ttov[tot]=y;\n\tnex[tot]=las[x];\n\tlas[x]=tot;\n}\n\nvoid insert(long long x,int id)\n{\n\tlong long i=x%mo;\n\twhile (hs[i]!=0)\n\t{\n\t\ti++;\n\t\tif (i==mo) i=0;\n\t}\n\ths[i]=id;\n}\n\nlong long find(long long x)\n{\n\tlong long i=x%mo;\n\twhile (hs[i]!=0 && d[hs[i]]!=x)\n\t{\n\t\ti++;\n\t\tif (i==mo) i=0;\n\t}\n\treturn hs[i];\n}\n\nvoid qsort(int l,int r)\n{\n\tint i=l;int j=r;\n\tlong long m=d[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (d[i]>m) i++;\n\t\twhile (d[j]<m) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(d[i],d[j]);\n\t\t\tswap(id[i],id[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort(l,j);\n\tif (r>i) qsort(i,r);\n}\n\nvoid dfs(int x,int ff)\n{\n\tjs[x]=js[ff]+1;\n\tfor (int i=las[x];i;i=nex[i])\n\t{\n\t\tif (tov[i]!=ff)\n\t\t{\n\t\t\tdfs(tov[i],x);\n\t\t\tans+=js[x];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&d[i]);\n\t\tid[i]=i;\n\t\tsiz[i]=1;\n\t}\n\tqsort(1,n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinsert(d[i],i);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tlong long op=d[i]-(n-2*siz[i]);\n\t\tlong long oq=find(op);\n\t\tif (oq==0 || oq==i)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfa[i]=oq;\n\t\t\tsiz[oq]+=siz[i];\n\t\t\tcon(i,oq);con(oq,i);\n\t\t}\n\t}\n\tdfs(n,0);\n\tif (ans!=d[n])\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tfor (int i=1;i<n;i++)\n\t\t{\n\t\t\tprintf(\"%d %d\\n\",id[i],id[fa[i]]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=1e5+10;\nint n,cnt,e,f[N],a[N],id[N],w[N],siz[N],res[N],head[N],link[N],to[N];\nbool vis[111111];\nbool cmp(int x,int y){return a[x]<a[y];}\nvoid add(int u,int v){to[++e]=v,link[e]=head[u],head[u]=e;}\nvoid dfs1(int u,int dep){\n\tsiz[u]=1,res[id[1]]+=dep;\n\tfor(int i=head[u];i;i=link[i])if(to[i]!=f[u])dfs1(to[i],dep+1),siz[u]+=siz[to[i]];\n}\nvoid dfs2(int u){for(int i=head[u];i;i=link[i])if(to[i]!=f[u])res[to[i]]=res[u]+n-2*siz[to[i]],dfs2(to[i]);}\nsigned main(){\n\tscanf(\"%d\",&n),w[0]=-LLONG_MAX;\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]),id[i]=i,w[i]=a[i],siz[i]=1;\n\tsort(id+1,id+n+1,cmp),sort(w+1,w+n+1);\n\tfor(int i=n;i>1;i--){\n\t\tint x=2*siz[id[i]]-n+a[id[i]],pos=lower_bound(w+1,w+n+1,x)-w;\n\t\tif(w[pos]!=x||n-2*siz[id[i]]<=0){printf(\"-1\");return 0;}\n\t\tadd(id[pos],id[i]),siz[id[pos]]+=siz[id[i]],f[id[i]]=id[pos];\n\t}\n\tdfs1(id[1],0),dfs2(id[1]);\n\tfor(int i=1;i<=n;i++)if(a[i]!=res[i]){printf(\"-1\");return 0;}\n\tfor(int i=2;i<=n;i++)printf(\"%d %d\\n\",f[id[i]],id[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\nusing ll = long long;\n\nint main() {\n  int n;\n  cin >> n;\n  vector<ll> d(n);\n  vector<int> parent(n, -1);\n  vector<int> p(n);\n  vector<ll> size(n, 1);\n  map<ll, int> mp;\n  for (int i = 0; i < n; i++) {\n    cin >> d[i];\n    p[i] = i;\n    mp[d[i]] = i;\n  }\n  sort(p.begin(), p.end(), [&](int i, int j) { return d[i] > d[j]; });\n  int r = p.back();\n  p.pop_back();\n  for (int i : p) {\n    ll tmp = d[i] - n + 2 * size[i];\n    if (tmp < d[i] && mp.count(tmp)) {\n      parent[i] = mp[tmp];\n      size[parent[i]] += size[i];\n    } else {\n      cout << -1 << '\\n';\n      return 0;\n    }\n  }\n  vector<ll> sum(n);\n  for (int i : p) {\n    sum[parent[i]] += sum[i] + size[i];\n  }\n  reverse(p.begin(), p.end());\n  vector<ll> correct(n);\n  correct[r] = sum[r];\n  for (int i : p) {\n    correct[i] = correct[parent[i]] + n - 2 * size[i];\n  }\n  if (correct != d) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  for (int i = 0; i < n; i++) {\n    if (parent[i] != -1) {\n      cout << i+1 << ' ' << parent[i]+1 << '\\n';\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\n#define R register\n#define ll long long\nconst int MAXN=1e5+10;\n\nint n;\nll D[MAXN];\nint siz[MAXN];\nmap<ll,int> loc;\nset<ll> st;\n\nstruct edge\n{\n\tint fr,to,next;\n}e[MAXN<<1];\nint tot;\nint head[MAXN];\nint dep[MAXN];\n\ninline void add(int x,int y)\n{\n\ttot++;\n\te[tot].fr=x;e[tot].to=y;e[tot].next=head[x];head[x]=tot;\n}\n\ninline void dfs(int x,int fx)\n{\n\tdep[x]=dep[fx]+1;\n\tfor(R int i=head[x];i;i=e[i].next)\n\t{\n\t\tint y=e[i].to;\n\t\tif(y==fx) continue;\n\t\tdfs(y,x);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(R int i=1;i<=n;i++) \n\t{\n\t\tscanf(\"%lld\",&D[i]);\n\t\tsiz[i]=1;\n\t\tloc[D[i]]=i;\n\t\tst.insert(D[i]);\n\t}\n\tint rt=0,cnt=0;\n\twhile(st.size()&&cnt<n-1)\n\t{\n\t\tll dx=*st.rbegin(),dy;\n\t\tint x,y;\n\t\tst.erase(dx);\n\t\tx=loc[dx];\n\t\tdy=dx+siz[x]*2-n;\n\t\ty=loc[dy];\n\t\tif(y==0) {printf(\"-1\\n\");return 0;}\n\t\tsiz[y]+=siz[x];\n\t\tadd(x,y);add(y,x);\n\t\tcnt++;\n\t}\n\trt=loc[*st.begin()];\n\tdfs(rt,0);\n\tll ans=0;\n\tfor(R int i=1;i<=n;i++) ans+=dep[i];\n\tif(ans-n!=D[rt]) {printf(\"-1\\n\");return 0;}\n\t\n\tfor(R int i=1;i<=tot;i+=2)\n\t{\n\t\tint x=e[i].fr,y=e[i].to;\n\t\tif(x>y) swap(x,y);\n\t\tprintf(\"%d %d\\n\",x,y);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#define N 100100\n#define pii pair<int, int>\nusing namespace std;\n\nint n, sz[N], fa[N];\npii p[N];\n\nint main() {\n#ifdef isLOCAL\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n;\n\n    for (int i = 1, d; i <= n; ++i)\n        scanf(\"%d\", &d), p[i] = make_pair(d, i);\n\n    sort(p + 1, p + n + 1);\n\n    for (int i = n; i > 1; --i) {\n        int u = p[i].second, szp, tmp;\n        ++sz[u], szp = n - sz[u];\n        tmp = p[i].first + n - 2 * szp;\n        int pos = lower_bound(p + 1, p + n + 1, make_pair(tmp, 0)) - p;\n        pii now = p[pos];\n        if (pos >= i || now.first != tmp) return puts(\"-1\"), 0;\n        sz[fa[u] = now.second] += sz[u];\n        printf(\"%d %d\\n\", fa[u], u);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = int(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\nusing ll = long long;\nusing namespace std;\n\nvector<pair<int, int> > solve(int n, vector<ll> const & d) {\n    map<ll, int> index;\n    REP (i, n) {\n        index[d[i]] = i;\n    }\n\n    int root = index.begin()->second;\n    vector<pair<int, int> > edges;\n    vector<vector<int> > children(n);\n    vector<int> size(n, 1);\n    for (auto it = index.rbegin(); ; ++ it) {\n        ll d_i; int i; tie(d_i, i) = *it;\n        if (i == root) break;\n        int d_parent = d_i - (n - size[i]) + size[i];\n        if (not index.count(d_parent)) {\n            return vector<pair<int, int> >();\n        }\n        int parent = index[d_parent];\n        edges.emplace_back(parent, i);\n        children[parent].push_back(i);\n        size[parent] += size[i];\n    }\n\n    vector<ll> d1(n);\n    function<void (int)> fold = [&](int i) {\n        for (int j : children[i]) {\n            fold(j);\n            d1[i] += d1[j] + size[j];\n        }\n    };\n    fold(root);\n    function<void (int, int)> reroot = [&](int i, int parent) {\n        if (parent != -1) {\n            d1[i] = d1[parent] - size[i] + (n - size[i]);\n        }\n        for (int j : children[i]) {\n            reroot(j, i);\n        }\n    };\n    reroot(root, -1);\n    if (d != d1) {\n        return vector<pair<int, int> >();\n    }\n    assert (false);\n\n    return edges;\n}\n\nint main() {\n    int n; cin >> n;\n    vector<ll> d(n);\n    REP (i, n) cin >> d[i];\n    auto edges = solve(n, d);\n    if (edges.empty()) {\n        cout << -1 << endl;\n    } else {\n        for (auto edge : edges) {\n            int i, j; tie(i, j) = edge;\n            cout << i + 1 << ' ' << j + 1 << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <time.h>\n\n#include <stdlib.h>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <vector>\n#include <map>\nusing namespace std;\nstruct condition{\n\tint32_t vertex;\n\tint64_t total;\n};\nstruct current{\n\tint32_t parent;\n\tint32_t vertex_num;\n};\nstruct edge{\n\tint32_t v1;\n\tint32_t v2;\n};\nbool operator< (const condition& a,const condition& b){\n\treturn a.total>b.total;\n}\nint main() {\n\n\tint32_t n;\n\tcin>>n;\n\tstd::vector<condition> cd;\n\tvector<edge> ans;\n\tans.reserve(n);\n\tcd.reserve(n);\n\tfor(int i=0;i<n;i++){\n\t\tint64_t temp;\n\t\tcin>>temp;\n\t\tcd.push_back(condition{i+1,temp});\n\t}\n\tbool ans_possible=true;\n\tsort(cd.begin(),cd.end());\n\tmap<int64_t,vector<current> > flow;\n\tfor(auto i=cd.begin();i!=cd.end();i++){\n\t\tint32_t sum_vertex=0;\n\n\t\tif(flow.count(i->total)){\n\t\t\tvector<current>& t=flow.at(i->total);\n\t\t\tint64_t total_cost=0;\n\t\t\tfor(auto k=t.begin();k!=t.end();k++){\n\t\t\t\tans.push_back(edge{k->parent,i->vertex});\n\t\t\t\tsum_vertex+=(k->vertex_num);\n\t\t\t\ttotal_cost+=((k->vertex_num)*(k->vertex_num+1))/2;\n\t\t\t}\n\t\t\tans_possible=(total_cost==i->total);\n\n\t\t\tflow.erase(i->total);\n\t\t}else{\n\t\t\tans_possible=false;\n\t\t}\n\n\t\tsum_vertex++;\n\n\t\tint32_t parent_value=i->total-(n-2*sum_vertex);\n\t\tif(parent_value>=i->total){\n\t\t\tans_possible=false;\n\t\t\tbreak;\n\t\t}\n\t\tif(flow.count(parent_value)){\n\t\t\tflow.at(parent_value).push_back(current{i->vertex,sum_vertex});\n\t\t}else{\n\t\t\tvector<current> temp2;\n\t\t\ttemp2.push_back(current{i->vertex,sum_vertex});\n\t\t\tflow.emplace(parent_value,temp2);\n\t\t}\n\n\t}\n\tif(flow.size()==1&&ans_possible&&ans.size()==(n-1)){\n\t\tfor(auto i=ans.begin();i!=ans.end();i++){\n\t\t\tcout<<i->v1<<\" \"<<i->v2<<endl;\n\t\t}\n\t}else{\n\t\tcout<<-1<<endl;\n\t}\n\n\n\n\n\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <set>\n#include <vector>\n#include <numeric>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(0);\n\n    int n;\n    cin >> n;\n    vector<pair<long long, int> > v;\n    for (int i = 0, d; i < n; i++) {\n        cin >> d;\n        v.emplace_back(d, i);\n    }\n    vector<int> sz(n, 1);\n    sort(v.begin(), v.end());\n    vector<pair<int, int> > edges;\n    bool res = true;\n    for (auto it = v.end() - 1; res and it != v.begin(); it--) {\n        const int u = it->second;\n        const long long next_d = it->first - (n - 2 * sz[u]);\n        const auto p = make_pair(next_d, 0);\n        auto i = lower_bound(v.begin(), it, p);\n        if (i == it or i->first != next_d) {\n            res = false;\n        }\n        else {\n            edges.emplace_back(u, i->second);\n            sz[i->second] += sz[u];\n        }\n    }\n    if (res) {\n        for (auto p : edges) {\n            cout << p.first + 1 << ' '\n                 << p.second + 1 << '\\n';\n        }\n    } \n    else {\n        cout << \"-1\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n\nint n ;\n\npair < long long , int > d[100010] ;\n\nint nChild[100010] ;\n\nmap < long long , int > f;\n\nvector < pair < int , int > > lis ;\n\nint main(){\n    #define NAME \"example\"\n    //freopen(NAME\".inp\", \"r\", stdin) ; freopen(NAME\".out\", \"w\", stdout) ;\n\n    ios_base :: sync_with_stdio(false) ;\n\n    cin >> n ;\n\n    for (int i = 1; i <= n; ++ i) cin >> d[i].first, d[i].second = i ;\n\n    sort(d + 1, d + n + 1) ;\n\n    for (int i = 1; i <= n; ++ i) f[d[i].first] = d[i].second ;\n    for (int i = n; i >= 2; -- i){\n        long long foo = d[i].first + 2ll * (nChild[d[i].second] + 1) - 1ll * n ;\n        int bar = f[foo] ;\n        if(!bar) return cout << -1 , 0 ;\n        nChild[bar] += nChild[d[i].second] + 1 ;\n        if(bar != d[1].second && 2 * nChild[bar] >= n) return cout << -1, 0 ;\n        lis.push_back(make_pair(d[i].second, bar)) ;\n    }\n    for (int i = 0; i < (int)lis.size(); ++ i) cout << lis[i].first << \" \" << lis[i].second << endl ;\n\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm> \n#include<cstdio>\n#define N 100001\nusing namespace std;\nint a[N],b[N],f[N],i,n,s[N];\ninline bool cmp(int u,int v){return a[u]<a[v];}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)scanf(\"%d\",a+i),s[b[i]=i]=1;\n\tsort(b+1,b+n+1,cmp);\n\tfor(i=n;i>1;i--)\n\t{\n\t\tif(s[b[i]]<<1>=n)return 0*puts(\"-1\");\n\t\t*a=a[b[i]]-n+(s[b[i]]<<1),f[b[i]]=lower_bound(b+1,b+n+1,0,cmp)-b;\n\t\tif(f[b[i]]>n||a[b[f[b[i]]]]!=*a)return 0*puts(\"-1\");\n\t\ts[f[b[i]]=b[f[b[i]]]]+=s[b[i]];\n\t}\n\tfor(i=2;i<=n;i++)printf(\"%d %d\\n\",b[i],f[b[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nlong long d[100001];\nint x[100001];\nint size[100001];\nvector<pair<int, int> > edge;\nmap<long long, int>f;\nbool cmp(int x, int y) {\n    return d[x] > d[y];\n}\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n ; i ++)\n        scanf(\"%lld\", &d[i]), x[i] = i, size[i] = 1, f[d[i]] = i;\n    sort(x + 1, x + n + 1, cmp);\n    bool sig = 0;\n    for (int i = 1; i <= n ; i ++) {\n        long long dd = d[x[i]] +size[x[i]] - n + size[x[i]];\n        if (dd != d[x[i]]&&f[dd]) size[f[dd]] += size[x[i]], edge.push_back(make_pair(x[i], f[dd]));\n        if (size[x[i]] == n) sig = 1;\n    }\n    if (sig ){\n        for (auto u : edge) printf(\"%d %d\\n\", u.first, u.second);\n    } else printf(\"-1\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++){for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  vector<ll>d(n);\n  rep(i,0,n){\n    cin>>d[i];\n  }\n  vector<ll>ord(n);\n  iota(ALL(ord),0);\n  map<ll,ll>mp;\n  sort(ALL(ord),[&](ll x,ll y){\n    return d[x]>d[y];\n  });\n  rep(i,0,n)mp[d[i]]=i;\n  vector<ll>sub(n,1);\n  vector<P>ret;\n  ll root=-1;\n  for(auto i:ord){\n    if(sub[i]==n){\n      root=i;\n      break;\n    }\n    ll k=d[i]-(n-2*sub[i]);\n    if(mp.count(k)){\n      sub[mp[k]]+=sub[i];\n      ret.EB(i,mp[k]);\n    }\n    else{\n      judge=false;\n      break;\n    }\n  }\n  //debug(sub,n);\n  //debug(ret,ret.size());\n  if(root==-1)judge=false;\n  else{\n    ll sum=0;\n    vector<vector<ll>>g(n);\n    for(auto p:ret){\n      g[p.fi].PB(p.se);\n      g[p.se].PB(p.fi);\n    }\n    auto dfs=[&](auto &&f,ll k,ll par,ll d)->void{\n      for(auto to:g[k]){\n        if(to==par)continue;\n        f(f,to,k,d+1);\n      }\n      sum+=d;\n    };\n    dfs(dfs,root,-1,0);\n    if(sum!=d[root])judge=false;\n  }\n  if(judge){\n    for(auto z:ret)cout<<z.fi+1 spa z.se+1<<endl;\n  }\n  else cout<<-1<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define inf 0x3f3f3f3f\n#define mod 1000000007\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define vi vector <int>\n#define pii pair <int, int>\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i,n) for (int i = 0; i < (int) (n); ++ i)\n#define foreach(it,c) for (__typeof(c.begin()) it = c.begin(); it != c.end(); ++ it)\n\ninline int read() {\n\tint x = 0, f = 1, c = getchar();\n\tfor (;!isdigit(c);c = getchar()) if (c == '-') f ^= 1;\n\tfor (; isdigit(c);c = getchar()) x = x * 10 + c - '0';\n\treturn f ? x : -x;\n}\n\nint n;\nll d[100005];\nint dis[100005];\nmap <ll, int> MP;\nint que[100005], lb, rb;\nint siz[100005];\nvi g[100005];\nvector <pii> ans;\n\nint main() {\n\tn = read();\n\trep(i, n) scanf(\"%lld\", &d[i]);\n\trep(i, n) MP[d[i]] = i, siz[i] = 1;\n\tint rt = MP.begin() -> second;\n\tfor (map <ll, int> :: reverse_iterator rit = MP.rbegin(); rit != MP.rend(); ++ rit) {\n\t\tint u = rit -> second; if (u == rt) break;\n\t\tll nw = d[u] - n + 2 * siz[u];\n\t\tif (!MP.count(nw)) {puts(\"-1\"); return 0;}\n\t\tint fa = MP[nw];\n\t\tans.pb(mp(fa, u));\n\t\tg[fa].pb(u);\n\t\tsiz[fa] += siz[u];\n\t}\n\tque[rb ++] = rt;\n\tmemset(dis, -1, sizeof dis); dis[rt] = 0;\n\twhile (lb < rb) {\n\t\tint u = que[lb ++];\n\t\trep(i, g[u].size()) {\n\t\t\tint v = g[u][i];\n\t\t\tif (!~dis[v]) {\n\t\t\t\tdis[v] = dis[u] + 1;\n\t\t\t\tque[rb ++] = v;\n\t\t\t}\n\t\t}\n\t}\n\tll sum = 0;\n\trep(i, n) sum += dis[i];\n\tif (sum != d[rt]) {puts(\"-1\"); return 0;}\n\trep(i, n - 1) printf(\"%d %d\\n\", ans[i].first + 1, ans[i].second + 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n// Problem : F - Distance Sums\n// Contest : AtCoder Regular Contest 103\n// URL : https://atcoder.jp/contests/arc103/tasks/arc103_d\n// Memory Limit : 1024 MB\n// Time Limit : 2000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\n#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\n#define cerr if(1)cerr\n#define size(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n#define temptts template <class T, class... Ts>\n\nconst int N = 1e6 + 1, mod = 1e9 + 7, inf = 2e9;\n\nstruct pp {\n\tll v;\n\tint i;\n\tbool operator < (const pp &o) const {\n\t\treturn v < o.v;\n\t}\n} d[N];\n\nmap<ll, int> id;\nint n, sz[N];\nvector<pair<int, int>> ans;\n\nint main() { cin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tif (n % 2 == 0) {\n\t\treturn cout << -1, 0;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> d[i].v;\n\t\td[i].i = i;\n\t}\n\tsort(d + 1, d + n + 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tid[d[i].v] = i;\n\t}\n\tfor (int i = n; i >= 2; i--) {\n\t\tsz[i]++;\n\t\tll j = d[i].v - n + 2 * sz[i];\n\t\tif (j <= 0 || !id[j]) {\n\t\t\treturn cout << -1, 0;\n\t\t}\n\t\tans.push_back({d[id[j]].i, d[i].i});\n\t\tsz[id[j]] += sz[i];\n\t}\n\tfor (auto& x : ans) {\n\t\tcout << x.first << ' ' << x.second << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nmap<ll,int>id;\nint n;\nll d[101000];\n\n#define pli pair<ll,int>\n#define fi first\n#define se second\npriority_queue<pli>q;\n\nint fa[101000], sz[101000]; ll sum[101000];\n\nint main(){\n    cin>>n;\n    for (int i=1;i<=n;++i){\n        cin>>d[i]; id[d[i]]=i;\n    }\n    sort(d+1,d+n+1,greater<ll>());\n    for (int i=1;i<=n;++i){\n        sz[i]=1;\n        while (q.size()&&q.top().fi==d[i]){\n            fa[q.top().se]=i;\n            sz[i]+=sz[q.top().se];\n            sum[i]+=sum[q.top().se]+sz[q.top().se];\n            q.pop();\n        }\n        q.push({d[i]-(n-sz[i]*2),i});\n    }\n    if (q.size()!=1||sum[n]!=d[n]){\n        puts(\"-1\");\n        return 0;\n    }\n    for (int i=1;i<n;++i)\n        printf(\"%d %d\\n\",id[d[i]],id[d[fa[i]]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint n,nn;\nstruct node{int p,f,l,r;long long d;};\nnode a[100010];\nint oa[100010],ob[100010];\n\nvoid qsort(int l,int r)\n{\n\tint i,j;\n\tnode m,t;\n\ti=l;j=r;\n\tm=a[(l+r)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (a[i].d<m.d) i++;\n\t\twhile (a[j].d>m.d) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tt=a[i];a[i]=a[j];a[j]=t;\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort(l,j);\n\tif (i<r) qsort(i,r);\n}\n\nvoid qsort2(int l,int r)\n{\n\tint i,j;\n\tint ma,mb,t;\n\ti=l;j=r;\n\tma=oa[(l+r)/2];\n\tmb=ob[(l+r)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (oa[i]<ma || (oa[i]==ma && ob[i]<mb)) i++;\n\t\twhile (oa[j]>ma || (oa[j]==ma && ob[j]>mb)) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tt=oa[i];oa[i]=oa[j];oa[j]=t;\n\t\t\tt=ob[i];ob[i]=ob[j];ob[j]=t;\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort2(l,j);\n\tif (i<r) qsort2(i,r);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tnn=n-2;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i].d);\n\t\ta[i].p=i;\n\t\ta[i].f=-1;\n\t\ta[i].l=-1;\n\t\ta[i].r=-1;\n\t}\n\tqsort(1,n);\n\tbool ok=true;\n\ta[1].l=0;a[1].r=n-1;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tbool check=true;\n\t\tfor (int j=i-1;j>=1;j--)\n\t\t{\n\t\t\tif (a[i].d-a[j].d>nn) \n\t\t\t{\n\t\t\t\tcheck=false;break;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif ((a[i].d-a[j].d-nn)%2==0)\n\t\t\t\t{\n\t\t\t\t\tint l,r;\n\t\t\t\t\tl=(nn+(a[i].d-a[j].d))/2;\n\t\t\t\t\tr=(nn-(a[i].d-a[j].d))/2;\n\t\t\t\t\tif (r<a[j].r)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[i].f=a[j].p;\n\t\t\t\t\t\ta[i].l=nn-r;\n\t\t\t\t\t\ta[i].r=r;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!check) {ok=false;break;}\n\t}\n\tif (ok)\n\t{\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tif (a[i].f<a[i].p) {oa[i]=a[i].f;ob[i]=a[i].p;}\n\t\t\telse {oa[i]=a[i].p;ob[i]=a[i].f;}\n\t\t}\n\t\tqsort2(1,n);\n\t\tfor (int i=2;i<=n;i++)\n\t\t\tprintf(\"%d %d\\n\",oa[i],ob[i]);\n\t}\n\telse printf(\"-1\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll int\n#define pb push_back\n#define mp make_pair\n#define ld long double\n#define F first\n#define S second\n#define pii pair<ll,ll>\n\nusing namespace :: std;\n\nconst ll maxn=1e5+1050;\nconst ll mod=1e9+7;\nconst ll inf=1e9+5;\n\nvector<pii> yal;\nll sz[maxn];\npii d[maxn];\n\nint main(){\n   ll n;\n   cin>>n;\n   for(ll i=0;i<n;i++){\n        cin>>d[i].F;\n        d[i].S=i+1;\n   }\n   sort(d,d+n);\n   fill(sz,sz+maxn,1);\n   for(ll i=n-1;i>=1;i--){\n        ll v=d[i].S;\n        ll dpar=d[i].F+2*sz[v]-n;\n        ll K=lower_bound(d,d+n,mp(dpar,0))-d;\n        if(d[K].F!=dpar || dpar>=d[i].F){\n            cout<<-1;\n            return 0;\n        }\n        ll par=d[K].S;\n        sz[par]+=sz[v];\n        yal.pb(mp(min(v,par),max(v,par)));\n   }\n   sort(yal.begin(),yal.end());\n   for(auto v:yal){\n        cout<<v.F<<' '<<v.S<<endl;\n   }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int \n#define F first\n#define S second\n#define pb push_back\nconst ll N = 1e5 + 5, MOD =  1e9 + 7, INF = 1e9 + 10;\nconst long double PI = acos(-1);\nint n, sz[N];\nll h[N];\npair <ll, int> d[N];\nvector <int> adj[N];\nunordered_map <ll, int> mp;\nvoid dfs(int v){\n\tfor (int u : adj[v]){\n\t\th[u] = h[v] + 1;\n\t\tdfs(u);\n\t}\n\treturn;\n}\nbool ok(){\n\tdfs(d[n].S);\n\tll all = 0;\n\tfor (int i = 1; i <= n; i++){\n\t\tall += h[i];\n\t}\n\treturn (all == d[n].F);\n}\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++){\n\t\tcin >> d[i].F;\n\t\td[i].S = i;\n\t\tmp[d[i].F] = i;\n\t}\n\tsort(d + 1, d + n + 1);\n\treverse(d + 1, d + n + 1);\n\tfor (int i = 1; i <= n; i++){\n\t\tint u = d[i].S;\n\t\tsz[u] = 1;\n\t\tfor (int v : adj[u]){\n\t\t\tsz[u] += sz[v];\n\t\t}\n\t\tll x = d[i].F + 2 * sz[u] - n;\n\t\tif (mp.find(x) == mp.end()) break;\n\t\tadj[mp[x]].pb(u);\n\t}\n\tif (ok()){\n\t\tfor (int u = 1; u <= n; u++){\n\t\t\tfor (int v : adj[u]){\n\t\t\t\tcout << u << ' ' << v << '\\n';\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tcout << \"-1\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 100005;\n\ntemplate <class T>\nvoid read (T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\n\ntemplate <class T>\nvoid write (T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nint n, sz[N];\nbool flag = true;\n\nstruct node {\n\tint id;\n\tlong long dist;\n\tbool operator < (node rhs) const {\n\t\treturn dist < rhs.dist;\n\t}\n} vec[N];\nlong long d[N];\nvector<pair<int, int> > tree;\n\nint main () {\n\tread(n);\n\tfor (int i = 1; i <= n; i++) vec[i].id = i, read(vec[i].dist);\n\n\tsort(vec + 1, vec + n + 1);\n\tfor (int i = 1; i <= n; i++) d[i] = vec[i].dist, sz[i] = 1;\n\n\tfor (int i = n; i > 1; i--) {\n\t\tint pos = lower_bound(d + 1, d + i, d[i] - (n - sz[i]) + sz[i]) - d;\n\t\tif (pos >= i || d[pos] != d[i] - (n - sz[i]) + sz[i]) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t\ttree.push_back(make_pair(vec[i].id, vec[pos].id));\n\t\tsz[pos] += sz[i];\n\t}\n\n\tif (!flag) write(-1), putchar('\\n');\n\telse {\n\t\tfor (int i = 0; i < tree.size(); i++) {\n\t\t\twrite(tree[i].first), putchar(' ');\n\t\t\twrite(tree[i].second), putchar('\\n');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC optimize(2)\n// #pragma G++ optimize(2)\n// #pragma comment(linker,\"/STACK:102400000,102400000\")\n\n// #include <bits/stdc++.h>\n#include <map>\n#include <set>\n#include <list>\n#include <array>\n#include <cfenv>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <mutex>\n#include <queue>\n#include <ratio>\n#include <regex>\n#include <stack>\n#include <tuple>\n#include <atomic>\n#include <bitset>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <chrono>\n#include <cstdio>\n#include <cwchar>\n#include <future>\n#include <limits>\n#include <locale>\n#include <memory>\n#include <random>\n#include <string>\n#include <thread>\n#include <vector>\n#include <cassert>\n#include <climits>\n#include <clocale>\n#include <complex>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <ctgmath>\n#include <cwctype>\n#include <fstream>\n#include <iomanip>\n#include <numeric>\n#include <sstream>\n#include <ccomplex>\n#include <cstdbool>\n#include <iostream>\n#include <typeinfo>\n#include <valarray>\n#include <algorithm>\n#include <cinttypes>\n#include <cstdalign>\n#include <stdexcept>\n#include <typeindex>\n#include <functional>\n#include <forward_list>\n#include <system_error>\n#include <unordered_map>\n#include <unordered_set>\n#include <scoped_allocator>\n#include <condition_variable>\n// #include <conio.h>\n// #include <windows.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef float fl;\ntypedef double ld;\ntypedef long double LD;\ntypedef pair<int,int> pii;\n#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)\n#define lld \"%I64d\"\n#define llu \"%I64u\"\n#else\n#define lld \"%lld\"\n#define llu \"%llu\"\n#endif\n#define ui(n) ((unsigned int)(n))\n#define LL(n) ((long long)(n))\n#define ull(n) ((unsigned long long)(n))\n#define fl(n) ((float)(n))\n#define ld(n) ((double)(n))\n#define LD(n) ((long double)(n))\n#define char(n) ((char)(n))\n#define Bool(n) ((bool)(n))\n#define fixpoint(n) fixed<<setprecision(n)\n\nconst int INF=1061109567;\nconst int NINF=-1044266559;\nconst LL LINF=4557430888798830399;\nconst ld eps=1e-15;\n#define MOD (1000000007)\n#define PI (3.1415926535897932384626433832795028841971)\n\n/*\n#define MB_LEN_MAX 5\n#define SHRT_MIN (-32768)\n#define SHRT_MAX 32767\n#define USHRT_MAX 0xffffU\n#define INT_MIN (-2147483647 - 1)\n#define INT_MAX 2147483647\n#define UINT_MAX 0xffffffffU\n#define LONG_MIN (-2147483647L - 1)\n#define LONG_MAX 2147483647L\n#define ULONG_MAX 0xffffffffUL\n#define LLONG_MAX 9223372036854775807ll\n#define LLONG_MIN (-9223372036854775807ll - 1)\n#define ULLONG_MAX 0xffffffffffffffffull\n*/\n\n#define MP make_pair\n#define MT make_tuple\n#define All(a) (a).begin(),(a).end()\n#define pall(a) (a).rbegin(),(a).rend()\n#define log2(x) log(x)/log(2)\n#define Log(x,y) log(x)/log(y)\n#define SZ(a) ((int)(a).size())\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define rep1(i,n) for(int i=1;i<=((int)(n));i++)\n#define repa(i,a,n) for(int i=((int)(a));i<((int)(n));i++)\n#define repa1(i,a,n) for(int i=((int)(a));i<=((int)(n));i++)\n#define repd(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define repd1(i,n) for(int i=((int)(n));i>=1;i--)\n#define repda(i,n,a) for(int i=((int)(n));i>((int)(a));i--)\n#define repda1(i,n,a) for(int i=((int)(n));i>=((int)(a));i--)\n#define FOR(i,a,n,step) for(int i=((int)(a));i<((int)(n));i+=((int)(step)))\n#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)\n#define repV(i,v) for(auto i:v)\n#define repE(i,v) for(auto &i:v)\n#define MS(x,y) memset(x,y,sizeof(x))\n#define MC(x) MS(x,0)\n#define MINF(x) MS(x,63)\n#define MCP(x,y) memcpy(x,y,sizeof(y))\n#define sqr(x) ((x)*(x))\n#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())\n#define filein(x) freopen(x,\"r\",stdin)\n#define fileout(x) freopen(x,\"w\",stdout)\n#define fileio(x)\\\n\tfreopen(x\".in\",\"r\",stdin);\\\n\tfreopen(x\".out\",\"w\",stdout)\n#define filein2(filename,name) ifstream name(filename,ios::in)\n#define fileout2(filename,name) ofstream name(filename,ios::out)\n#define file(filename,name) fstream name(filename,ios::in|ios::out)\n#define Pause system(\"pause\")\n#define Cls system(\"cls\")\n#define fs first\n#define sc second\n#define PC(x) putchar(x)\n#define GC(x) x=getchar()\n#define Endl PC('\\n')\n#define SF scanf\n#define PF printf\n\ninline int Read()\n{\n    int X=0,w=0;char ch=0;while(!isdigit(ch)){w|=ch=='-';ch=getchar();}while(isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();\n\treturn w?-X:X;\n}\ninline void Write(int x){if(x<0)putchar('-'),x=-x;if(x>9)Write(x/10);putchar(x%10+'0');}\n\ninline LL powmod(LL a,LL b){LL RES=1;a%=MOD;assert(b>=0);for(;b;b>>=1){if(b&1)RES=RES*a%MOD;a=a*a%MOD;}return RES%MOD;}\ninline LL gcdll(LL a,LL b){return b?gcdll(b,a%b):a;}\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={1,0,-1,0,-1,-1,1,1};\n/************************************************************Begin************************************************************/\nconst int maxn=100010;\n\nint n;\nLL a[maxn];\nvector<pair<LL,int> > e;\nmap<LL,int> mp;\n\nint main()\n{\n\tSF(\"%d\",&n);\n\tif(n%2==0) return !PF(\"-1\");\n\n\trep(i,n)\n\t{\n\t\tLL x;SF(\"%lld\",&x);\n\t\tmp[x]=i;\n\t\te.push_back({x,i});\n\t}\n\n\tsort(e.rbegin(),e.rend());\n\tLL x=e.back().fs;\n\n\tvector<int> sz(n,1);\n\tvector<LL> dp(n,0);\n\tvector<pair<int,int> > ans;\n\n\trepV(i,e) if(i.fs!=x)\n\t{\n\t\tif(sz[i.sc]*2>=n) return !PF(\"-1\");\n\n\t\tLL need=i.fs-(n-sz[i.sc]*2);\n\n\t\tif(!mp.count(need)) return !PF(\"-1\");\n\n\t\tint par=mp[need];\n\t\tdp[par]+=dp[i.sc]+sz[i.sc];\n\t\tsz[par]+=sz[i.sc];\n\n\t\tans.push_back({i.sc+1,par+1});\n\t}\n\n\tif(dp[e.back().sc]!=x) return !PF(\"-1\");\n\n\trepV(i,ans) PF(\"%d %d\\n\",i.fs,i.sc);\n\n\treturn 0;\n}\n/*************************************************************End**************************************************************/"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <random>\n#include <complex>\n#include <regex>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define quickIO()\t{cin.tie(0);\tcout.sync_with_stdio(false);}\n#define reach(i,a)\tfor(auto i:a)\n#define rep(i,n)\tfor(int i=0;i<((int)n);i++)\n#define REP(i,n)\tfor(int i=0;i<=((int)n);i++)\n#define srep(i,a,n)\tfor(int i=a;i<((int)n);i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=((int)n);i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define pb\tpush_back\ntemplate<typename T> istream& operator >> (istream& is, vector<T>& vec) {\n\tfor (T& x : vec)\tis >> x;\n\treturn is;\n}\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n\tos << \"[\";\n\trep(i, vec.size())\tos << (i ? \", \" : \"\") << vec[i];\n\tos << \"]\";\n\treturn os;\n}\ntemplate<typename T> istream& operator >> (istream& is, pair<T, T>& p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate<typename T> ostream& operator << (ostream& os, pair<T, T>& p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\";\n\treturn os;\n}\nint bitcnt(ll x) {\n\tx = ((x & 0xAAAAAAAAAAAAAAAA) >> 1) + (x & 0x5555555555555555);\n\tx = ((x & 0xCCCCCCCCCCCCCCCC) >> 2) + (x & 0x3333333333333333);\n\tx = ((x & 0xF0F0F0F0F0F0F0F0) >> 4) + (x & 0x0F0F0F0F0F0F0F0F);\n\tx = ((x & 0xFF00FF00FF00FF00) >> 8) + (x & 0x00FF00FF00FF00FF);\n\tx = ((x & 0xFFFF0000FFFF0000) >> 16) + (x & 0x0000FFFF0000FFFF);\n\tx = ((x & 0xFFFFFFFF00000000) >> 32) + (x & 0x00000000FFFFFFFF);\n\treturn x;\n}\nint bitcnt(int x) {\n\tx = ((x & 0xAAAAAAAA) >> 1) + (x & 0x55555555);\n\tx = ((x & 0xCCCCCCCC) >> 2) + (x & 0x33333333);\n\tx = ((x & 0xF0F0F0F0) >> 4) + (x & 0x0F0F0F0F);\n\tx = ((x & 0xFF00FF00) >> 8) + (x & 0x00FF00FF);\n\tx = ((x & 0xFFFF0000) >> 16) + (x & 0x0000FFFF);\n\treturn x;\n}\nll sqrtll(ll x) {\n\tll left = 0, right = x;\n\trep(i, 100) {\n\t\tll mid = (left + right) >> 1;\n\t\tif (mid*mid <= x)\tleft = mid;\n\t\telse\tright = mid;\n\t}\n\treturn left;\n}\nll gcd(ll a, ll b) {\n\treturn a % b == 0 ? b : gcd(b, a%b);\n}\n#define debug(x)\tprintf(\"Case #%d: \", x)\n#define DEBUG 0\nconst ll inf = 1e18;\nconst ld infl = 1e100;\nconst ll mod = 1e9+7;\nconst ld eps = 1e-9;\nconst int dx[] = { 1,0,-1,0,0 };\nconst int dy[] = { 0,1,0,-1,0 };\n\nint group[100010];\n\nint getGroup(int i) {\n\treturn group[i] = (i == group[i] ? group[i] : getGroup(group[i]));\n}\nvoid merge(int i, int j) {\n\ti = getGroup(i);\tj = getGroup(j);\n\tgroup[i] = group[j];\n}\n\n// 最初の2頂点はxとx-n+2があったらマージ。headのみを残す。\n// 以降x(a)とy(b)についてx+n-2*b=yやy+n-2*a=xで判断\n// x(a)は固定できるけど、y(b)が見つけられない\n// xが親になる場合はx+n=y+2*b->子になる場合はx+2*a-n=y\n// 「一番大きいdiは子になる」より再帰的に(UF?)出来そう\nint main() {\n\tll n;\tcin >> n;\n\tif (n == 2) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tvll d(n);\tcin >> d;\n\tvll num(n, 1);\n\tmap<ll, ll> mp;\n\trep(i, n) {\n\t\tmp[d[i]] = i;\n\t}\n\tvector<pll> d2(n);\n\trep(i, n) {\n\t\td2[i] = mp(d[i], i);\n\t\tgroup[i] = i;\n\t}\n\tsort(all(d2));\n\tvector<pll> ret;\n\tfor (ll i = n - 1; i > 0; i--) {\n\t\tll id = d2[i].second;\n\t\tif (getGroup(id) != id)\tcontinue;\n\t\tll a = num[id];\n\t\tif (!mp.count(d[id] + 2 * a - n) || id == mp[d[id] + 2 * a - n]) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tll to = mp[d[id] + 2 * a - n];\n\t\tmp.erase(d[id]);\n\t\tmerge(id, to);\n\t\tnum[to] += num[id];\n\t\tret.push_back(mp(id + 1, to + 1));\n\t}\n\trep(i, n - 1) {\n\t\tcout << ret[i].first << \" \" << ret[i].second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define il inline\n#define int long long\nconst int N=1e5+5;\n\nint n,m,D,sz[N],U[N],V[N];\nstruct node{int id,p;}d[N];\n\nil bool operator < (node a,node b){return a.p<b.p;}\n\nsigned main()\n{\n\tscanf(\"%lld\",&n); int i,f,dis;\n\tfor (i=1; i<=n; i++) scanf(\"%lld\",&d[i].p),d[i].id=i,sz[i]=1;\n\tstd::sort(d+1,d+n+1);\n\t\n\tfor (i=n; i>1; i--)\n\t{\n\t\tf=std::lower_bound(d+1,d+n+1,(node){0,dis=d[i].p-n+sz[i]+sz[i]})-d;\n\t\tif (dis!=d[f].p) return puts(\"-1\"),0;\n\t\tU[++m]=d[i].id,V[m]=d[f].id,sz[f]+=sz[i],D+=sz[i];\n\t}\n\tif (D!=d[1].p) return puts(\"-1\"),0;\n\tfor (i=1; i<n; i++) printf(\"%lld %lld\\n\",U[i],V[i]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<unordered_map>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nll d[N];\nunordered_map<ll,vector<int> > p;\nll cnt[N],sum[N],n,r[N];\nvector<pair<int,int> > w;\nbool comp(int a,int b){\n\treturn d[a]>d[b];\n}\nint main(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\tcin>>n;\n\tfor (int i=1;i<=n;i++)scanf(\"%lld\",&d[i]),r[i]=i,p[d[i]].push_back(i),cnt[i]=1;\n\tsort(r+1,r+n+1,comp);\n\tfor (int i=1;i<n;i++){\n\t\tll x=r[i],s=d[x]-(n-2*cnt[x]),y;\n\t\tif (p[s].empty()||s>=d[x]){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\ty=p[s].back();\n\t\tw.push_back(make_pair(x,y));\n\t\tcnt[y]+=cnt[x];\n\t\tsum[y]+=sum[x]+cnt[x];\n\t}\n\tif (sum[r[n]]!=d[r[n]]){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tfor (int i=0;i<n-1;i++)printf(\"%d %d\\n\",w[i].first,w[i].second);\n}#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<unordered_map>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nll d[N];\nunordered_map<ll,vector<int> > p;\nll cnt[N],sum[N],n,r[N];\nvector<pair<int,int> > w;\nbool comp(int a,int b){\n\treturn d[a]>d[b];\n}\nint main(){\n\tcin>>n;\n\tfor (int i=1;i<=n;i++)scanf(\"%lld\",&d[i]),r[i]=i,p[d[i]].push_back(i),cnt[i]=1;\n\tsort(r+1,r+n+1,comp);\n\tfor (int i=1;i<n;i++){\n\t\tll x=r[i],s=d[x]-(n-2*cnt[x]),y;\n\t\tif (p[s].empty()||s>=d[x]){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\ty=p[s].back();\n\t\tw.push_back(make_pair(x,y));\n\t\tcnt[y]+=cnt[x];\n\t\tsum[y]+=sum[x]+cnt[x];\n\t}\n\tif (sum[r[n]]!=d[r[n]]){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tfor (int i=0;i<n-1;i++)printf(\"%d %d\\n\",w[i].first,w[i].second);\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC optimize(2)\n// #pragma G++ optimize(2)\n// #pragma comment(linker,\"/STACK:102400000,102400000\")\n\n// #include <bits/stdc++.h>\n#include <map>\n#include <set>\n#include <list>\n#include <array>\n#include <cfenv>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <mutex>\n#include <queue>\n#include <ratio>\n#include <regex>\n#include <stack>\n#include <tuple>\n#include <atomic>\n#include <bitset>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <chrono>\n#include <cstdio>\n#include <cwchar>\n#include <future>\n#include <limits>\n#include <locale>\n#include <memory>\n#include <random>\n#include <string>\n#include <thread>\n#include <vector>\n#include <cassert>\n#include <climits>\n#include <clocale>\n#include <complex>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <ctgmath>\n#include <cwctype>\n#include <fstream>\n#include <iomanip>\n#include <numeric>\n#include <sstream>\n#include <ccomplex>\n#include <cstdbool>\n#include <iostream>\n#include <typeinfo>\n#include <valarray>\n#include <algorithm>\n#include <cinttypes>\n#include <cstdalign>\n#include <stdexcept>\n#include <typeindex>\n#include <functional>\n#include <forward_list>\n#include <system_error>\n#include <unordered_map>\n#include <unordered_set>\n#include <scoped_allocator>\n#include <condition_variable>\n// #include <conio.h>\n// #include <windows.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef float fl;\ntypedef double ld;\ntypedef long double LD;\ntypedef pair<int,int> pii;\n#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)\n#define lld \"%I64d\"\n#define llu \"%I64u\"\n#else\n#define lld \"%lld\"\n#define llu \"%llu\"\n#endif\n#define ui(n) ((unsigned int)(n))\n#define LL(n) ((long long)(n))\n#define ull(n) ((unsigned long long)(n))\n#define fl(n) ((float)(n))\n#define ld(n) ((double)(n))\n#define LD(n) ((long double)(n))\n#define char(n) ((char)(n))\n#define Bool(n) ((bool)(n))\n#define fixpoint(n) fixed<<setprecision(n)\n\nconst int INF=1061109567;\nconst int NINF=-1044266559;\nconst LL LINF=4557430888798830399;\nconst ld eps=1e-15;\n#define MOD (1000000007)\n#define PI (3.1415926535897932384626433832795028841971)\n\n/*\n#define MB_LEN_MAX 5\n#define SHRT_MIN (-32768)\n#define SHRT_MAX 32767\n#define USHRT_MAX 0xffffU\n#define INT_MIN (-2147483647 - 1)\n#define INT_MAX 2147483647\n#define UINT_MAX 0xffffffffU\n#define LONG_MIN (-2147483647L - 1)\n#define LONG_MAX 2147483647L\n#define ULONG_MAX 0xffffffffUL\n#define LLONG_MAX 9223372036854775807ll\n#define LLONG_MIN (-9223372036854775807ll - 1)\n#define ULLONG_MAX 0xffffffffffffffffull\n*/\n\n#define MP make_pair\n#define MT make_tuple\n#define All(a) (a).begin(),(a).end()\n#define pall(a) (a).rbegin(),(a).rend()\n#define log2(x) log(x)/log(2)\n#define Log(x,y) log(x)/log(y)\n#define SZ(a) ((int)(a).size())\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define rep1(i,n) for(int i=1;i<=((int)(n));i++)\n#define repa(i,a,n) for(int i=((int)(a));i<((int)(n));i++)\n#define repa1(i,a,n) for(int i=((int)(a));i<=((int)(n));i++)\n#define repd(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define repd1(i,n) for(int i=((int)(n));i>=1;i--)\n#define repda(i,n,a) for(int i=((int)(n));i>((int)(a));i--)\n#define repda1(i,n,a) for(int i=((int)(n));i>=((int)(a));i--)\n#define FOR(i,a,n,step) for(int i=((int)(a));i<((int)(n));i+=((int)(step)))\n#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)\n#define repV(i,v) for(auto i:v)\n#define repE(i,v) for(auto &i:v)\n#define MS(x,y) memset(x,y,sizeof(x))\n#define MC(x) MS(x,0)\n#define MINF(x) MS(x,63)\n#define MCP(x,y) memcpy(x,y,sizeof(y))\n#define sqr(x) ((x)*(x))\n#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())\n#define filein(x) freopen(x,\"r\",stdin)\n#define fileout(x) freopen(x,\"w\",stdout)\n#define fileio(x)\\\n\tfreopen(x\".in\",\"r\",stdin);\\\n\tfreopen(x\".out\",\"w\",stdout)\n#define filein2(filename,name) ifstream name(filename,ios::in)\n#define fileout2(filename,name) ofstream name(filename,ios::out)\n#define file(filename,name) fstream name(filename,ios::in|ios::out)\n#define Pause system(\"pause\")\n#define Cls system(\"cls\")\n#define fs first\n#define sc second\n#define PC(x) putchar(x)\n#define GC(x) x=getchar()\n#define Endl PC('\\n')\n#define SF scanf\n#define PF printf\n\ninline int Read()\n{\n    int X=0,w=0;char ch=0;while(!isdigit(ch)){w|=ch=='-';ch=getchar();}while(isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();\n\treturn w?-X:X;\n}\ninline void Write(int x){if(x<0)putchar('-'),x=-x;if(x>9)Write(x/10);putchar(x%10+'0');}\n\ninline LL powmod(LL a,LL b){LL RES=1;a%=MOD;assert(b>=0);for(;b;b>>=1){if(b&1)RES=RES*a%MOD;a=a*a%MOD;}return RES%MOD;}\ninline LL gcdll(LL a,LL b){return b?gcdll(b,a%b):a;}\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={1,0,-1,0,-1,-1,1,1};\n/************************************************************Begin************************************************************/\nconst int maxn=100010;\n\nint n;\nLL a[maxn];\nvector<pair<LL,int> > e;\nmap<LL,int> mp;\n\nint main()\n{\n\tSF(\"%d\",&n);\n\n\trep(i,n)\n\t{\n\t\tLL x;SF(\"%lld\",&x);\n\t\tmp[x]=i;\n\t\te.push_back({x,i});\n\t}\n\n\tsort(e.rbegin(),e.rend());\n\tLL x=e.back().fs;\n\n\tvector<int> sz(n,1);\n\tvector<LL> dp(n,0);\n\tvector<pair<int,int> > ans;\n\n\trepV(i,e) if(i.fs!=x)\n\t{\n\t\tif(sz[i.sc]*2>=n) return !PF(\"-1\");\n\n\t\tLL need=i.fs-(n-sz[i.sc]*2);\n\n\t\tif(!mp.count(need)) return !PF(\"-1\");\n\n\t\tint par=mp[need];\n\t\tdp[par]+=dp[i.sc]+sz[i.sc];\n\t\tsz[par]+=sz[i.sc];\n\n\t\tans.push_back({i.sc+1,par+1});\n\t}\n\n\tif(dp[e.back().sc]!=x) return !PF(\"-1\");\n\n\trepV(i,ans) PF(\"%d %d\\n\",i.fs,i.sc);\n\n\treturn 0;\n}\n/*************************************************************End**************************************************************/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=100005,p=1000000007;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint n,fl,siz[N],b[N],fa[N];\nvector<int> e[N];\nll a[N],f[N],ans[N];\nunordered_map<ll,int> h;\nbool cmp(int x,int y){return a[x]<a[y];}\nvoid work(int x){\n\tf[x]=siz[x]-1;\n\tfor (auto y : e[x]){work(y);f[x]+=f[y];}\n}\nvoid calc(int x,ll s){\n\tans[x]=f[x]+s+n-siz[x];\n\tfor (auto y : e[x])\n\tcalc(y,ans[x]-f[y]-siz[y]);\n}\nint main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++) {scanf(\"%lld\",a+i);h[a[i]]=i;b[i]=i;siz[i]=1;}\n\tsort(b+1,b+n+1,cmp);\n\tfor (int i=n;i>1;i--){\n\t\tint x=b[i];\n\t\tfa[x]=h[a[x]+siz[x]-n+siz[x]];\n\t\tif (!fa[x]){puts(\"-1\");return 0;}\n\t\tsiz[fa[x]]+=siz[x];\n\t\te[fa[x]].push_back(x);\n\t}\n\twork(b[1]);\n\tcalc(b[1],0);\n\tfor (int i=1;i<=n;i++)\n\tif (ans[i]!=a[i]){puts(\"-1\");return 0;}\n\tfor (int i=2;i<=n;i++) printf(\"%d %d\\n\",fa[b[i]],b[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define E \"\\n\"\n\nusing namespace std;\nconst long long MOD = (long long)1e9 + 7;\n\nint n, rt;\npair<long long, int> d[100009];\nset<pair<long long, int> > st;\nvector<pair<int, int> > vec;\nmap<long long, int> mp;\nvector<int> vec2[100009];\n\nlong long fun(int c)\n{\n\tif (d[c].se == 1) return 1;\n\tlong long retval = 0;\n\tfor (int i = 0; i < (int)vec2[c].size(); i++) {\n\t\tretval += fun(vec2[c][i]);\n\t}\n\tif (c == rt) return retval;\n\telse return retval + d[c].se;\n}\n\nbool gun(int c, long long cd)\n{\n\tif (cd != d[c].fi) return false;\n\tfor (int i = 0; i < (int)vec2[c].size(); i++) {\n\t\tif (!gun(vec2[c][i], d[c].fi + n - 2*d[vec2[c][i]].se)) return false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> d[i].fi;\n\t\td[i].se = 1;\n\t\tst.insert({ -d[i].fi, i });\n\t\tmp[d[i].fi] = i;\n\t}\n\twhile (1) {\n\t\tauto x = st.begin();\n\t\tint cur = (*x).se;\n\t\tst.erase(x);\n\t\tlong long tmp = d[cur].fi - n + 2 * d[cur].se;\n\t\tif (mp.count(tmp) == 0) {\n\t\t\tcout << -1 << E;\n\t\t\treturn 0;\n\t\t}\n\t\tint to = mp[tmp];\n\t\tif (to == cur) {\n\t\t\tcout << -1 << E;\n\t\t\treturn 0;\n\t\t}\n\t\td[to].se += d[cur].se;\n\t\tvec.pb(make_pair(to, cur));\n\t\tif (vec.size() == n - 1) {\n\t\t\tx = st.begin();\n\t\t\trt = (*x).se;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < (int)vec.size(); i++) {\n\t\tvec2[vec[i].fi].pb(vec[i].se);\n\t}\n\tif (!gun(rt, fun(rt))) {\n\t\tcout << -1 << E;\n\t}\n\telse {\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tcout << vec[i].fi << \" \" << vec[i].se << E;\n\t\t}\n\t}\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<map>\n\ntypedef long long ll;\n\nint main() {\n    std::map<ll, int, std::greater<ll> > M;\n    std::ios::sync_with_stdio(0);\n    int n;\n    std::cin >> n;\n    for(int i = 1; i <= n; ++i) {\n        ll x;\n        std::cin >> x;\n        M.insert(std::make_pair(x, i));\n    }\n    static int fa[int(1e5) + 5];\n    static int sz[int(1e5) + 5];\n    for(auto& k : M) if(k.first != (*M.rbegin()).first) {\n        int now = k.second;\n        ++sz[now];\n        int f = k.first + 2 * sz[now] - n;\n        if(M.count(f) == 0) {\n            puts(\"-1\");\n            return 0;\n        }\n        fa[now] = M[f];\n        sz[fa[now]] += sz[now];\n    }\n    for(int i = 1; i <= n; ++i) if(fa[i] != 0) {\n        std::cout << i << ' ' << fa[i] << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string>\n#include <algorithm>\n#include <math.h>\n#include <map>\n#include <chrono>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    int N;\n    cin >> N;\n    vector<long long> d(N);\n    vector<pair<int, int>> t;\n    map<long long, int> a;\n    for (int i = 0; i < N; i++)\n    {\n        cin >> d[i];\n        a[d[i]] = i;\n    }\n\n    vector<int> weigtht(N, 1);\n    for (int it = 0; it < N - 1; it++)\n    {\n        auto target = a.rbegin();\n        int i = target->second;\n        long long dis = d[i];\n        long long next = dis - (N - weigtht[i]) + weigtht[i];\n        if (a.find(next) == a.end() || a[next] == i)\n        {\n            cout << \"-1\" << endl;\n            return 0;\n        }\n        int j = a[next];\n        weigtht[j] += weigtht[i];\n        t.push_back({i, j});\n        a.erase(--a.end());\n    }\n\n    for (int i = 0; i < N - 1; i++)\n    {\n        cout << t[i].first + 1 << \" \" << t[i].second + 1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define repr(i,b,e) for(int i = (b); i <= (e); i++)\n\n#define pr(x) do{cerr << (#x) << \" = \" << (x) << endl;}while(0)\n#define pri(x,i) do{cerr << (#x) << \"[\" << i << \"] = \" << (x[i]) << endl;}while(0)\n\nnamespace std {\n\ttemplate<class S, class T> pair<S, T> operator + (const pair<S, T> &a, const pair<S, T> &b) {return mp<S, T>(a.first + b.first, a.second + b.second);}\n\ttemplate<class S, class T> pair<S, T> operator - (const pair<S, T> &a, const pair<S, T> &b) {return mp<S, T>(a.first - b.first, a.second - b.second);}\n\ttemplate<class S, class T> pair<S, T>& operator += (pair<S, T> &a, const pair<S, T> &other) {return a = a + other;}\n\ttemplate<class S, class T> pair<S, T>& operator -= (pair<S, T> &a, const pair<S, T> &other) {return a = a - other;}\n\ttemplate<class S, class T> ostream& operator << (ostream& ost, pair<S, T> p) {ost << \"(\" << p.first << \", \" << p.second << \")\";return ost;}\n\ttemplate<class T> ostream& print_iterable_container(ostream& ost, T& container) {\n\t\tfor (auto&& iter = begin(container); iter != end(container); ++iter) ost << (iter == begin(container) ? \" [ \" : \", \") << (*iter);\n\t\treturn ost << \" ]\";\n\t}\n#\tdefine APPLY_PRINT_ITERABLE_CONTAINER(container_type)\\\n\ttemplate<class T> ostream& operator << (ostream& ost, container_type<T>& container) {\\\n\t\treturn print_iterable_container(ost, container);\\\n\t}\n\tAPPLY_PRINT_ITERABLE_CONTAINER(vector);\n\tAPPLY_PRINT_ITERABLE_CONTAINER(list);\n\tAPPLY_PRINT_ITERABLE_CONTAINER(deque);\n}\n\ntemplate<class T> inline bool CHMAX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool CHMIN(T &l,const T &r){return l>r?l=r,1:0;}\n\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\n\nusing ld = long double;\n\ntemplate<class T> using VV = vector<vector<T> >;\ntemplate<class T> using maxPQ = priority_queue<T>;\ntemplate<class T> using minPQ = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T, class U> using uomap = unordered_map<T, U>;\ntemplate<class T> using uoset = unordered_set<T>;\n\nconst ll INF = 1001001001;\nconst ll INFll = (ll)INF * INF;\nconst ll MOD = 1000000007;\nconst ll MOD_FFT = 998244353;\nconst ld EPS = 1e-15;\n\n//function<void(int,int)> tensi_no_3p=[&](int v,int d){\n//};\n\nvoid no() {\n\tcout << -1 << endl;\n\texit(0);\n}\n\nint main() {\n\tint N; cin >> N;\n\tvi D(N); rep(i, N) cin >> D[i];\n\tif (N <= 3) no();\n\n\tmap<int, int> w2i;\n\trep(i, N) w2i[D[i]] = i;\n\n\tvi nc(N);\n\tvi par(N, -1);\n\tmaxPQ<pii> pq;\n\trep(i, N) pq.push(mp(D[i], i));\n\tint root = -1;\n\twhile (! pq.empty()) {\n\t\tpii t = pq.top();\n\t\tpq.pop();\n\t\tint w = t.first;\n\t\tint i = t.second;\n\t\tif (pq.empty()) {\n\t\t\troot = i;break;\n\t\t}\n\t\tint nw = w - N + 2 + nc[i];\n\t\tif (w2i.find(nw) == w2i.end()) no();\n\t\tpar[i] = w2i[nw];\n\t\tnc[nw] += nc[i] + 1;\n\t}\n\tif (root == -1) no();\n\tvpii nci(N);\n\trep(i, N) nci[i] = mp(nc[i], i);\n\tsort(nci.begin(), nci.end());\n\tvll dist(N);\n\trep(k, N) {\n\t\tint n = nci[k].first;\n\t\tint i = nci[k].second;\n\t\tif (i == root) continue;\n\t\tdist[par[i]] += dist[i] * (1 + nc[i]) + 1;\n\t}\n\tif (dist[root] != D[root]) no();\n\trep(i, N) if (i != root) cout << (i + 1) << \" \" << (1 + par[i]) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(X,A,B) for(int X=A;X<=B;X++)\n#define tep(X,A,B) for(int X=A;X>=B;X--)\n#define LL long long\n#define DB double\nconst int N=400010;\nconst int M=800010;\nusing namespace std;\n\nint n;\nmap<LL,int> mp;\nLL sz[N];\nint fa[N],edge[M],lst[N],nxt[M],t=0;\n\nstruct nn{\n\tLL d;\n\tint id;\n}a[N];\n\nint cmp(nn A,nn B){\n\treturn A.d<B.d;\n}\n\nvoid READ(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n)scanf(\"%lld\",&a[i].d),a[i].id=i,mp[a[i].d]=i;\n\tsort(a+1,a+n+1,cmp);\n}\n\nvoid ADD(int x,int y){\n\tedge[++t]=y;nxt[t]=lst[x];lst[x]=t;\n}\n\nLL SEARCH(int x,int dep){\n\tLL res=dep;\n\tfor(int r=lst[x];r;r=nxt[r]){\n\t\tres+=SEARCH(edge[r],dep+1);\n\t}\n\treturn res;\n}\n\nint SOLVE(){\n\trep(i,1,n)sz[i]=1;\n\ttep(i,n,2){\n\t\tint x=a[i].id;\n\t\tLL d=a[i].d;\n\t\tLL now=d+2*sz[x]-n;\n\t\tint pos=mp[now];\n\t\tif(pos==0||now>=a[i].d)return 0;\n\t\tfa[x]=pos;\n\t\tADD(fa[x],x);\n\t\tsz[fa[x]]+=sz[x];\n\t}\n\tLL sum=SEARCH(a[1].id,0);\n\tif(sum!=a[1].d)return 0;\n\trep(i,1,n){\n\t\tif(i==a[1].id)continue;\n\t\tprintf(\"%d %d\\n\",i,fa[i]);\n\t}\n}\n\nint main(){\n\tREAD();\n\tSOLVE();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MN 100005\nint T,n,id[MN];\nll a[MN];\nmap<ll,int>rea,cnt;\nstruct node{int x,y;};\nvector<node>sc;\nbool cmp(int x,int y){return a[x]>a[y];}\nint main(){\n//\tfreopen(\"test.in\",\"r\",stdin);\n//\tfreopen(\"mysol.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),rea[a[i]]=i,cnt[a[i]]=1,id[i]=i;\n\tsort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<n;i++){\n\t\tint t=id[i],tmp=a[t]-n+2*cnt[a[t]];\n\t\tif(rea[tmp]&&rea[tmp]!=t){\n\t\t\tcnt[tmp]+=cnt[a[t]];\n\t\t\tsc.push_back((node){t,rea[tmp]});\n\t\t}\n\t\telse return 0*puts(\"-1\");\n\t}\n\tfor(int i=0;i<sc.size();i++)printf(\"%d %d\\n\",sc[i].x,sc[i].y);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// LightOj Pass : qavajxyq\n\n#include <bits/stdc++.h>\n#define deb(x)     cerr << (#x) << \" : \" << x << \"\\n\"\n#define ll long long int\n#define ld long double\nusing namespace std;\nconst ll MOD = 1e9 + 7 ;\nconst ll INF = 1e18;\n\nll powmod(ll a, ll b, ll mod = MOD){\n\tll res = 1ll;\n\tb %= (mod - 1ll), a %= mod;\n\twhile(b){\n\t\tif(b%2 == 1)\tres = (res * a) % mod;\n\t\ta = (a * a) % mod;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nll d[300000];\nll n;\n\nbool comp(int a, int b){\n\treturn d[a] < d[b];\n}\n\nvector<vector<int>> edges;\nint cnt = 0;\nll res = 0;\nll tree[400000];\nbool visited[4000000];\nbool state = true;\n\nvoid dfs(int u, int par = -1, ll dpth = 0){\n\tcnt++;\n\tres += dpth;\n\ttree[u] = 1;\n\tvisited[u] = true;\n\tint tmp = 0;\n\tfor(auto v : edges[u]){\n\t\tif(!visited[v]){\n\t\t\tdfs(v, u, dpth + 1ll);\n\t\t\ttree[u] += tree[v];\n\t\t}\n\t\telse{\n\t\t\ttmp++;\n\t\t}\n\t}\n\n\tif(tmp > 1)\tstate = false;\n}\n\n\nvoid dfs2(int u, int par = -1, ll ans = res){\n\tif(ans != d[u])\tstate = false;\n\tfor(auto v : edges[u]){\n\t\tif(v != par)\tdfs2(v, u, ans - tree[v] * 2 + n);\n\t}\n}\n\nint main(){\t\n    #ifndef ONLINE_JUDGE\n        freopen(\"D:\\\\V S Code\\\\cpp\\\\competitiveProgramming\\\\Input.txt\", \"r\", stdin);\n        freopen(\"D:\\\\V S Code\\\\cpp\\\\competitiveProgramming\\\\OPT.txt\", \"w\", stdout);\n    #endif\n \n\tios::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tcin >> n;\n\tedges.resize(n+1);\n\tmemset(visited, false, sizeof(visited));\n\tint arr[n];\n\tmap<ll, int> mp;\n\tll sub[n+1];\n\tfor(int i = 1; i <= n; i++)\tcin >> d[i], arr[i-1] = i, mp[d[i]] = i, sub[i] = 1;\n\n\tsort(arr, arr + n, comp);\n\tbool vis[n+1];\n\tmemset(vis, false, sizeof(vis));\n\n\tint cur, par;\n\tint parent[n];\n\n\tvector<pair<int, int>> edge;\n\tfor(int i = n-1; i >= 0; i--) {\n\t\t\n\t\tif(vis[arr[i]])\tcontinue;\n\t\tcur = arr[i];\n\t\tdeb(cur);\n\t\tvis[cur] = true;\n\t\twhile(cur != 0){\n\t\t\tpar = 0;\n\t\t\tif(mp.count(d[cur] + (2 * sub[cur]) - n) and !vis[ mp[d[cur] + (2 * sub[cur]) - n]])\tpar = mp[d[cur] + (2 * sub[cur]) - n];\n\t\t\tif(par)\tsub[par] += sub[cur], edges[cur].push_back(par), edges[par].push_back(cur), vis[cur] = true, edge.push_back({cur, par});\n\t\t\tcur = par;\n\t\t\tdeb(sub[par]);\n\t\t\tdeb(par);\n\t\t}\n\t}\n\n\tdfs(arr[0]);\n\tif(cnt != n or res != d[arr[0]] or !state)\t{\n\t\tcout << -1;\n\t\treturn 0;\n\t}\n\n\tdfs2(arr[0]);\n\tif(!state){\n\t\tcout << -1;\n\t\treturn 0;\n\t}\n\n\tfor(auto x : edge)\tcout << x.first << \" \" << x.second << \"\\n\"; \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n#include <numeric>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tmap<long long int, int> d_map;\n\tvector<pair<long long int, int> > d;\n\tfor(int i = 1; i <= n; i++){\n\t\tlong long int tmp;\n\t\tcin >> tmp;\n\t\td.push_back(make_pair(tmp, i));\n\t\td_map[tmp] = i;\n\t}\n\tsort(d.begin(), d.end());\n\treverse(d.begin(), d.end());\n\tvector<bool> ischecked(n, false);\n\tset<pair<int, int> > ans;\n\tfor(int i = 0; i < d.size(); i++){\n\t\tint now = d[i].second;\n\t\tlong long int nowd = d[i].first;\n\t\tif(ischecked[now]) continue;\n\t\tischecked[now] = true;\n\t\t// nowから1本でつながっている分をつなげていく\n\t\tint j = 1;\n\t\tfor(j = 1; j < n; j++){\n\t\t\tlong long int nextd = nowd - (n  - j) + j;\n\t\t\tif(nextd >= nowd || d_map.find(nextd) == d_map.end()){\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tlong long int next = d_map[nextd];\n\t\t\t\tans.insert(make_pair(min(now, next), max(now, next)));\n\t\t\t\tischecked[next] = true;\n\t\t\t\tnow = next;\n\t\t\t\tnowd = nextd;\n\t\t\t}\n\t\t}\n\t\tif(j == 1){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(auto i = ans.begin(); i != ans.end(); i++){\n\t\tcout << (*i).first << \" \" << (*i).second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <long long, long long> pii;\n\nconst long long MAX_N = 1e5 + 5;\nlong long n, root;\nlong long Arr[MAX_N];\nlong long h[MAX_N];\nlong long Siz[MAX_N];\nlong long Mark[MAX_N];\nlong long par[MAX_N];\nunordered_map <long long, long long> Map;\nvector <pii> edge;\nlong long dp_d[MAX_N];\nlong long dp_u[MAX_N];\nvector <long long> child[MAX_N];\n\nbool cmp(long long a, long long b) {\n\treturn Arr[b] < Arr[a];\n}\n\nvoid dfs1(long long v) {\n\tfor (long long i = 0; i < child[v].size(); i++) {\n\t\tdfs1(child[v][i]);\n\t\tdp_d[v] += dp_d[child[v][i]] + Siz[child[v][i]];\n\t}\n}\n\nvoid dfs2(long long v, long long val) {\n\tdp_u[v] = val;\n\tfor (long long i = 0; i < child[v].size(); i++)\n\t\tdfs2(child[v][i], dp_d[v] + dp_u[v] - dp_d[child[v][i]] - Siz[child[v][i]] + (n - Siz[child[v][i]]));\n}\n\nint main() {\n\tios::sync_with_stdio(false), cout.tie(0), cin.tie(0);\n\tcin >> n;\n\tfor (long long i = 0; i < n; i++) {\n\t\tcin >> Arr[i];\n\t\tSiz[i] = 1;\n\t\th[i] = i;\n\t\tMap[Arr[i]] = i;\n\t}\n\t\t\n\tsort(h, h + n, cmp);\n\t\n\tfor (long long i = 0; i + 1 < n; i++) {\n\t\tlong long v = h[i];\n\t\tlong long tmp = Arr[v] + Siz[v] - (n - Siz[v]);\n\n\t\tif (tmp < 0 || (Map[tmp] == 0 && Arr[0] != tmp)) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tlong long u = Map[tmp];\n\t\tif (Mark[u]) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tSiz[u] += Siz[v];\n\t\tpar[v] = u;\n\t\tedge.push_back({v, u});\n\t\tchild[u].push_back(v);\n\t\tif (n < 2LL * Siz[v]) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tMark[v] = true;\n\t}\n\troot = h[n - 1];\n\tdfs1(root);\n\tdfs2(root, 0);\n\t\n\tfor (long long i = 0; i < n; i++)\n\t\tif (dp_d[i] + dp_u[i] != Arr[i]) {\n\t\t\tcout << i << \" \" << dp_d[i] + dp_u[i] << \"\\n\";\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\n\tfor (long long i = 0; i + 1 < n; i++)\n\t\tcout << edge[i].first + 1 << \" \" << edge[i].second + 1 << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N=100005;\nint n,p[N],sz[N],U[N],V[N];ll tot,d[N];\nmap<ll,int>mp;vector<int>G[N];\ninline bool cmp(int x,int y){return d[x]>d[y];}\nvoid dfs(int x,int d){tot+=d;for(int i=0;i<G[x].size();i++)dfs(G[x][i],d+1);}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&d[i]),mp[d[i]]=i,sz[i]=1,p[i]=i;\n\tsort(p+1,p+n+1,cmp);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x=p[i];ll w=d[x]-(n-sz[x])+sz[x];\n\t\tif(!mp[w]||w>=d[x]){puts(\"-1\");return 0;}\n\t\tint y=mp[w];U[i]=x;V[i]=y;\n\t\tsz[y]+=sz[x];G[y].push_back(x);\n\t}\n\tdfs(p[n],0);\n\tif(tot!=d[p[n]]){puts(\"-1\");return 0;}\n\tfor(int i=1;i<n;i++)printf(\"%d %d\\n\",U[i],V[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define int long long\ntypedef pair <int, int> ii;\n\nconst int N = 1e5 + 5;\nint n, d[N], subSize[N], f[N], g[N], tot;\nmap <int, int> ind;\nvector <int> adj[N];\n\nvoid dfs(int u, int pre, int s) {\n\tg[u] = s;\n\tfor (int v : adj[u]) {\n\t\tif (v == pre) continue;\n\t\ttot += subSize[v];\n\t\tdfs(v, u, s - 2 * subSize[v] + n);\n\t}\n}\n\nsigned main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> d[i];\n\t\tf[i] = d[i];\n\t\tind[d[i]] = i;\n\t}\n\tvector <ii> res; res.clear();\n\tsort(d + 1, d + 1 + n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tsubSize[i] = 1;\n\tfor (int i = n; i >= 2; --i) {\n\t\tint v = ind[d[i]];\n\t\tint du = d[i] + 2 * subSize[v] - n;\n\t\tif (ind.find(du) == ind.end()) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint u = ind[du];\n\t\tif (u == v) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsubSize[u] += subSize[v];\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t\tres.push_back({u, v});\n\t}\n\tdfs(ind[d[1]], -1, 0);\n\tfor (int i = 1; i <= n; ++i) if (f[i] != g[i] + tot) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tfor (ii d : res)\n\t\tcout << d.first << ' ' << d.second << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<iostream>\n#include<algorithm>\n#define maxn 100050\nusing namespace std;\ntypedef long long LL;\n\nint n;\nLL D[maxn];\n\nint pos[maxn];\n\nLL size[maxn];\n\nmap<LL,int> mp;\n\nvoid init()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tpos[i]=i;\n\t\tscanf(\"%lld\",&D[i]); \n\t\tmp[D[i]]=i;\n\t}\n}\n\nint fa[maxn];\n\nbool cmp(int i,int j)\n{\n\treturn D[i]>D[j];\n}\n\nint find(LL x)\n{\n\treturn mp.count(x)?mp[x]:0;\n}\n\nbool solve()\n{\n\tsort(pos+1,pos+n+1,cmp);\n\tfor (int k=1;k<n;++k)\n\t{\n\t\tint i=pos[k],j=find(D[i]+2LL*++size[i]-n);\n\t\t\n//\t\tcout<<i<<\" \"<<j<<\" \"<<D[i]+2LL*size[i]-n<<endl;\n\t\tif (!j||j==i)\n\t\t\treturn 0;\n\t\tfa[i]=j;\n\t\tsize[j]+=size[i];\n\t}\n\t\n//\tputs(\"YES\");\n\tfor (int k=1;k<=n;++k)\n\t{\n\t\tint u=pos[k];\n\t\tif (fa[u])\n\t\t\tprintf(\"%d %d\\n\",u,fa[u]);\n\t}\n\treturn 1;\n}\n\nint main()\n{\n//    freopen(\"c.in\",\"r\",stdin);\n//    freopen(\"c.out\",\"w\",stdout);\n    init();\n    if (!solve())\n    \tprintf(\"-1\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define E \"\\n\"\n\nusing namespace std;\nconst long long MOD = (long long)1e9 + 7;\n\nint n, rt;\npair<long long, int> d[100009];\nset<pair<long long, int> > st;\nvector<pair<int, int> > vec;\nmap<long long, int> mp;\nvector<int> vec2[100009];\n\nlong long fun(int c)\n{\n\tif (d[c].se == 1) return 1;\n\tlong long retval = 0;\n\tfor (int i = 0; i < (int)vec2[c].size(); i++) {\n\t\tretval += fun(vec2[c][i]);\n\t}\n\tif (c == rt) return retval;\n\telse return retval + d[c].se;\n}\n\nbool gun(int c, long long cd)\n{\n\tif (cd != d[c].fi) return false;\n\tfor (int i = 0; i < (int)vec2[c].size(); i++) {\n\t\tif (!gun(vec2[c][i], d[c].fi + n - 2*d[vec2[c][i]].se)) return false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> d[i].fi;\n\t\td[i].se = 1;\n\t\tst.insert({ -d[i].fi, i });\n\t\tmp[d[i].fi] = i;\n\t}\n\twhile (1) {\n\t\tauto x = st.begin();\n\t\tint cur = (*x).se;\n\t\tst.erase(x);\n\t\tlong long tmp = d[cur].fi - n + 2 * d[cur].se;\n\t\tif (mp.count(tmp) == 0) {\n\t\t\tcout << -1 << E;\n\t\t\treturn 0;\n\t\t}\n\t\tint to = mp[tmp];\n\t\td[to].se += d[cur].se;\n\t\tvec.pb(make_pair(to, cur));\n\t\tif (vec.size() == n - 1) {\n\t\t\tx = st.begin();\n\t\t\trt = (*x).se;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < (int)vec.size(); i++) {\n\t\tvec2[vec[i].fi].pb(vec[i].se);\n\t}\n\tif (!gun(rt, fun(rt))) {\n\t\tcout << -1 << E;\n\t}\n\telse {\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tcout << vec[i].fi << \" \" << vec[i].se << E;\n\t\t}\n\t}\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,size[100010],fa[100010],tmp=0,cnt=0;\nlong long d[100010];\nmap<long long,int>ma;\nstruct node{\n\tlong long w;\n\tint id;\n\tbool operator <(const node &b)const{\n\t\treturn w<b.w;\n\t}\n};\npriority_queue<node>q;\nint main(){\n\tma.clear();\n\twhile(q.size()) q.pop();\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&d[i]);\n\t\tma[d[i]]=i,size[i]=1;\n\t\tq.push((node){d[i],i});\n\t}\n\twhile(q.size()){\n\t\tnode now=q.top();q.pop();\n\t\tif(size[now.id]==1) tmp++;\n\t\tif(!q.size()) break; \n\t\tfa[now.id]=ma[d[now.id]+size[now.id]*2-n];\n\t\tsize[fa[now.id]]+=size[now.id];\n\t}\n\tfor(int i=1;i<=n;i++) if(size[i]==1) cnt++;\n\tif(cnt==tmp){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(fa[i]) printf(\"%d %d\\n\",i,fa[i]);\n\t\t}\n\t}\n\telse printf(\"-1\\n\"); \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//300iq\n#define ll long long\n#define pii pair<int,int> \n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fi first\n#define se second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nvector<pair<ll,int> > e;\nmap<ll,int> ret;\nint n;\ninline void die(){\n    puts(\"-1\");\n    exit(0);\n}\nint main(){\n    cin>>n;\n    for(int i=0;i<n;i++){\n        ll x;\n        cin>>x;\n        ret[x]=i;\n        e.pb(mp(x,i));\n    }\n    sort(e.begin(),e.end());\n    reverse(e.begin(),e.end());\n    ll x=e.back().first;\n    vector<int> siz(n,1);\n    vector<ll> dp(n,0);\n    vector<pii> ans;\n    for(int i=0;i<e.size();i++){\n        pair<ll,ll> c=e[i];\n        if(c.first==x) continue;\n        if(siz[c.se]*2>=n)\n            die();\n        ll need=c.first+2*siz[c.se]-n;\n        if(!ret.count(need))\n            die();\n        int par=ret[need];\n        dp[par]+=dp[c.se]+siz[c.se];\n        siz[par]+=siz[c.se];\n        ans.pb(mp(c.se+1,par+1));\n    }\n    if(dp[e.back().se]!=x)\n        die();\n    for(int i=0;i<ans.size();i++)\n        cout<<ans[i].fi<<\" \"<<ans[i].se<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*====Corycle====*/\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#define ll long long\n#define set_it set<Node>::iterator\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst int N=1e5+5;\nll read(){\n\tll s=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){s=s*10+c-'0';c=getchar();}\n\treturn s*f;\n}\nll Dist,a[N];\nint n,m,b[N],fa[N],sum[N];\nbool cmp(int x,int y){return a[x]>a[y];}\nstruct Node{\n\tll val;int x;\n\tfriend bool operator<(Node A,Node B){return A.val!=B.val?A.val<B.val:A.x<B.x;}\n};\nset<Node>F;\nint main(){\n//\tfreopen(\"_.in\",\"r\",stdin);\n//\tfreopen(\"_.out\",\"w\",stdout);\n\tn=read();\n\tfor(int i=1;i<=n;i++){a[i]=read();b[i]=i;sum[i]=1;F.insert((Node){a[i],i});}\n\tsort(b+1,b+n+1,cmp);\n\tfor(int i=1;i<n;i++){\n\t\tint x=b[i];\n\t\tll val=a[x]+2*sum[x]-n;\n\t\tF.erase((Node){a[x],x});\n\t\tset_it p=F.lower_bound((Node){val,0});\n\t\tif(p==F.end()||(*p).val!=val){puts(\"-1\");return 0;}\n\t\tint y=(*p).x;fa[x]=y;sum[y]+=sum[x];Dist+=sum[x];\n\t}\n\tif(Dist!=a[b[n]]){puts(\"-1\");return 0;}\n\tfor(int i=1;i<=n;i++)if(fa[i])printf(\"%d %d\\n\",i,fa[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint cou[111111];\n\nint main(){\n\t\n\tint n;cin >> n;\n\tvector<pair<ll,ll>> v;\n\tmap<ll,ll> mp;\n\tREP(i,n){\n\t\tll d;cin >> d;\n\t\tv.PB(MP(d,i+1));\n\t\tmp[d] = i+1;\n\t}\n\t\n\tsort(ALL(v),greater<pair<ll,ll>>());\n\t\n\tvector<pair<int,int>> ans;\n\tll sum = 0;\n\t\n\tREP(i,n-1){\n\t\tll mai = n - 2*(cou[v[i].SE]+1);\n\t\t//cout << v[i].FI << ' ' << mai << endl;\n\t\tif(!mp[v[i].FI - mai]){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tans.PB(MP(v[i].SE,mp[v[i].FI - mai]));\n\t\tcou[mp[v[i].FI - mai]] += cou[v[i].SE] + 1;\n\t\tsum += cou[v[i].SE] + 1;\n\t}\n\t\n\tif(sum != v[n-1].FI){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tREP(i,ans.size()){\n\t\tcout << ans[i].FI << ' ' << ans[i].SE << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <map>\nusing namespace std;\n\nnamespace zyt\n{\n\ttypedef long long ll;\n\tconst int N = 1e5 + 10;\n\tint n, id[N], fa[N], size[N];\n\tll d[N];\n\tmap<ll, int> mp;\n\tbool cmp(const int a, const int b)\n\t{\n\t\treturn d[a] < d[b];\n\t}\n\tint work()\n\t{\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tscanf(\"%lld\", d + i), id[i] = i, mp[d[i]] = i, size[i] = 1;\n\t\tsort(id + 1, id + n + 1, cmp);\n\t\tfor (int i = n; i > 1; i--)\n\t\t{\n\t\t\tll t = d[id[i]] - n + 2LL * size[id[i]];\n\t\t\tmp.erase(d[id[i]]);\n\t\t\tif (mp.count(t))\n\t\t\t\tsize[mp[t]] += size[id[i]], fa[id[i]] = mp[t];\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tif (fa[i])\n\t\t\t\tprintf(\"%d %d\\n\", i, fa[i]);\n\t\treturn 0;\n\t}\n}\nint main()\n{\n\treturn zyt::work();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\nconst int inf = (1 << 30) - 1;\nconst int64 infll = (1LL << 61) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\nint main() {\n  int N;\n  cin >> N;\n  set< pair< int64, int > > que;\n  for(int i = 0; i < N; i++) {\n    int64 d;\n    cin >> d;\n    que.emplace(d, i);\n  }\n\n  vector< int > par(N, -1), size(N, 1);\n  while(que.size() >= 2) {\n    auto p = *prev(que.end());\n    que.erase(p);\n    const int other = N - size[p.second];\n    int64 latte = p.first + size[p.second] - other;\n\n    auto it = que.lower_bound({latte, -1});\n    if(it == que.end() || it->first != latte) {\n      cout << -1 << endl;\n      return 0;\n    }\n    size[it->second] += size[p.second];\n    par[p.second] = it->second;\n  }\n  cout << -1 << endl;\n  /*\n  for(int i = 0; i < N; i++) {\n    if(~par[i]) cout << par[i] + 1 << \" \" << i + 1 << endl;\n  }\n   */\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> g[100005];\nlong long d[100005];\nint rd[100005];\nint sz[100005];\nmap<long long,int> mp;\nqueue<int> q;\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> d[i];\n\t\tmp[d[i]] = i;\n\t\tsz[i] = 1;\n\t}\n\tfor (int it = 1; it < n; ++it) {\n\t\tint u = mp.rbegin()->second;\n\t\tlong long need = d[u] - (n - sz[u]) + sz[u];\n\t\tif (mp.find(need) == mp.end() || mp[need] == u) {\n\t\t\treturn cout << -1 << '\\n',0;\n\t\t} \n\t\tint v = mp[need];\n\t\tg[u].push_back(v), g[v].push_back(u);\t\t\n\t\tsz[v] += sz[u];\n\t\tmp.erase(mp.find(d[u]));\n\t}\n\tfor (int i = 1; i <= n; ++i) rd[i] = -1;\n\trd[1] = 0; q.push(1);\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tfor (int v : g[u]) if (rd[v] == -1) {\n\t\t\trd[v] = rd[u] + 1; q.push(v);\n\t\t}\n\t}\n\tif (accumulate(rd + 1, rd + 1 + n, 0LL) != d[1]) {\n\t\treturn cout << -1 << '\\n',0;\n\t}\n\tfor (int u = 1; u <= n; ++u) {\n\t\tfor (int v : g[u]) if (u < v) {\n\t\t\tcout << u << ' ' << v << '\\n';\n\t\t}\n\t} \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<ll,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int maxn=1e5+7;\nll sum[maxn];\nmap<ll,int> id;\nint sz[maxn];\nint main()\n{\n    int n;\n    cin>>n;\n    if(n==2)\n    {\n        print(-1);\n        return 0;\n    }\n    priority_queue<pi> q;\n    for(int i=1;i<=n;i++) \n    {\n        cin>>sum[i];\n        id[sum[i]]=i;\n        q.push(make_pair(sum[i],i));\n        sz[i]=1;\n    }\n    bool ok=1;\n    vc<pi> ans;\n    while(!q.empty())\n    {\n        auto u=q.top();q.pop();\n        if(q.empty()) break;\n        ll fad=u.first-(n-2*sz[u.second]);\n        if(!id.count(fad))\n        {\n            ok=0;\n            break;\n        }\n        sz[id[fad]]+=sz[u.second];\n        ans.emplace_back(u.second,id[fad]);\n    }\n    if(!ok) print(-1);\n    else{\n        for(auto u:ans) cout<<u.first<<\" \"<<u.second<<'\\n';\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimiz(O2)\n\n#include <bits/stdc++.h>\n\n#define rg register\nusing namespace std;\ntypedef long long ll;\n\ntemplate<typename T>\ninline bool read(T &n) {\n    T ans = 0, flag = 1;\n    char ch;\n    while ((ch = getchar()) < '0' || ch > '9') if (ch == '-') flag = -1; else if (ch == EOF) return false;\n    ans = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9') ans = ans * 10 + ch - '0';\n    n = ans * flag;\n    return true;\n}\n\ninline ll read() {\n    ll ans = 0, flag = 1;\n    char ch;\n    while ((ch = getchar()) < '0' || ch > '9') if (ch == '-') flag = -1;\n    ans = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9') ans = ans * 10 + ch - '0';\n    return ans * flag;\n};\nconst int maxn = 100005;\nstruct NODE {\n    ll val, ord;\n    bool operator<(NODE b) const {\n        return val < b.val;\n    }\n} node[maxn];\nint siz[maxn],fa[maxn];\nunordered_map<ll,int> unM;\nint main() {\n    int n;\n    read(n);priority_queue<NODE> pq;\n    for (rg int i = 1; i <= n; ++i) {\n        siz[i] = 1;read(node[i].val);\n        node[i].ord = i;\n        pq.push(node[i]);\n        unM[node[i].val]=i;\n    }\n    for(rg int i=n;i>=2;i--){\n        NODE now=pq.top();pq.pop();\n        if(unM.find(now.val+2*siz[now.ord]-n)==unM.end()||unM[now.val+2*siz[now.ord]-n]<=now.ord){\n            puts(\"-1\");return 0;\n        }\n        fa[now.ord]=unM[now.val+2*siz[now.ord]-n];\n        siz[fa[now.ord]]+=siz[now.ord];\n    }\n    for(rg int i=1;i<=n;i++){\n        if(fa[i]) cout<<i<<' '<<fa[i]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main() {\n\tlong long N;\n\tcin >> N;\n\tvector<pair<long long, long long> > D(N);\n\tvector<long long> E(N);\n\tvector<long long> COUNT(N, 1);\n\tvector<pair<long long, long long> > ANS;\n\tfor (int i = 0; i < N; i++) cin >> D[i].first, D[i].second = i, E[i] = D[i].first;\n\tsort(D.begin(), D.end());\n\tsort(E.begin(), E.end());\n\tfor (int i = N - 1; i > 0; i--) {\n\t\tlong long C = COUNT[D[i].second];\n\t\tlong long ND = D[i].first - (N - C * 2);\n\t\tlong long it = lower_bound(E.begin(), E.end(), ND) - E.begin();\n\t\tif (D[it].first != ND || i <= it) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tANS.push_back({ D[i].second, D[it].second });\n\t\tCOUNT[D[it].second] += COUNT[D[i].second];\n\t}\n\tvector<vector<long long> > V(N);\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tV[ANS[i].first].push_back(ANS[i].second);\n\t\tV[ANS[i].second].push_back(ANS[i].first);\n\t}\n\tvector<long long> Dists(N, -1);\n\tDists[D[0].second] = 0;\n\tqueue<long long> Q;\n\tQ.push(D[0].second);\n\twhile (!Q.empty()) {\n\t\tlong long P = Q.front();\n\t\tQ.pop();\n\t\tfor (long long NP : V[P]) {\n\t\t\tif (Dists[NP] == -1) {\n\t\t\t\tDists[NP] = Dists[P] + 1;\n\t\t\t\tQ.push(NP);\n\t\t\t}\n\t\t}\n\t}\n\tlong long SUM = 0;\n\tfor (int i = 0; i < N; i++) SUM += Dists[i];\n\tif (SUM != D[0].first) cout << -1 << endl;\n\telse for (int i = 0; i < N - 1; i++) cout << ANS[i].first << \" \" << ANS[i].second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN=2e5+7;\n\nint cntm;\nint from[MAXN],to[MAXN];\n\nmap<ll,int> Map,Map2;\n\nint n;\nll a[MAXN],b[MAXN],siz[MAXN];\n\nbool cmp(const int &A,const int &B){return a[A]>a[B];}\nbool cmp2(const int &A,const int &B){return A>B;}\n\nint main() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) {\n\t\tcin>>a[i];\n\t\tb[i]=i;\n\t\tMap[a[i]]=i;\n\t\tsiz[i]=1;\n\t}\n\tsort(b+1,b+1+n,cmp);\n\tsort(a+1,a+1+n,cmp2);\n\tfor(int i=1;i<=n;i++)\n\t\tMap2[a[i]]=i;\n\tfor(int i=1,i2;i<n;i++) {\n\t\ti2=Map[a[i]-(n-2*siz[i])];\n\t\tif(i2!=0&&i2!=b[i]) {\n\t\t\tsiz[Map2[a[i]-(n-2*siz[i])]]+=siz[i];\n\t\t\tfrom[++cntm]=i2;\n\t\t\tto[cntm]=i;\n\t\t}\n\t\telse {\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++) {\n\t\tcout<<from[i]<<\" \"<<to[i]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int N=100005;\ntemplate<typename T>\nvoid read(T &x){\n\tx=0;int f=1; char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if (ch=='-') f=-1; ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n    x*=f;\n}\nll d[N];\nstruct Edg{\n\tint nxt,poi;\n}e[N<<1];\nint size[N],first[N],l=0,n,deep[N];\nvector<pii>G;\nmap<ll,int>id;\nvoid addedge(int u,int v){\n\tG.push_back(make_pair(u,v));\n\tl++;\n\te[l].nxt=first[u];\n\te[l].poi=v;\n\tfirst[u]=l;\n}\nvoid dfs(int u,int f){\n\tfor (int p=first[u];p;p=e[p].nxt){\n\t\tint v=e[p].poi;\n\t\tif (v==f) continue;\n\t\tdeep[v]=deep[u]+1; \n\t\tdfs(v,u);\n\t}\n}\nint main(){\n\tread(n);\n\tfor (int i=1;i<=n;i++) read(d[i]),id[d[i]]=i,size[i]=1;\n\tsort(d+1,d+1+n);\n\tfor (int i=n;i>1;i--){\n\t\tint u=id[d[i]];\n\t\tint tmp=n-2*size[u];\n\t\tif (tmp<=0){printf(\"-1\\n\"); return 0;}\n\t\tll t=d[i]-tmp;\n\t\tif (id[t]==0){printf(\"-1\\n\"); return 0;}\n\t\tint fa=id[t];\n\t\taddedge(fa,u); \n\t\tsize[fa]+=size[u];\n\t}\n\tdfs(id[d[1]],id[d[1]]);\n\tll sum=0;\n\tfor (int i=1;i<=n;i++) sum+=deep[i];\n\tif (sum!=d[1]){printf(\"-1\\n\"); return 0;}\n\tfor (int i=0;i<G.size();i++){\n\t\tprintf(\"%d %d\\n\",G[i].first,G[i].second);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n\nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nint modpow(int a, long long n, int mod = MOD) { int ret = 1; do { if (n & 1) ret = 1LL * ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\n// counterclockwise from 12 o'clock direction\ntemplate<typename T> bool CompareBySlope(pair<T, T> a, pair<T, T> b) { if (a.first * b.first < 0) return a.first < b.first; if (a.first == 0) return a.second >= 0 || b.first > 0; if (b.first == 0) return b.second < 0 && a.first < 0; return a.second * b.first < a.first * b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\nll dfs(Graph<int> &tree, int p, int v, int d) {\n  ll sum = d;\n  for (auto nv : tree[v]) {\n    if (nv != p) {\n      sum += dfs(tree, v, nv, d+1);\n    }\n  }\n  return sum;\n}\n\nvoid solve() {\n  int n; cin >> n;\n  vector<pair<ll, int>> g(n);\n  rep(i,n) {\n    cin >> g[i].first;\n    g[i].second = i;\n  }\n  sort(ALL(g));\n\n  vi cnt(n);\n  vector<pii> ans; ans.reserve(n-1);\n  Graph<int> tree(n);\n\n  rrep1(i,n) {\n    ll d; int idx;\n    tie(d, idx) = g[i];\n\n    ll nd = d - (n-2) + 2*cnt[idx];\n    auto itr = lower_bound(ALL(g), make_pair(nd, 0));\n\n    if (itr->first != nd || nd >= d) {\n      cout << -1 << endl;\n      return;\n    }\n\n    int nidx = itr->second;\n    cnt[nidx] += cnt[idx] + 1;\n    ans.emplace_back(idx+1, nidx+1);\n    tree[idx].emplace_back(nidx);\n    tree[nidx].emplace_back(idx);\n  }\n\n  if (dfs(tree, -1, g[0].second, 0) != g[0].first) {\n    cout << -1 << endl;\n    return;\n  }\n\n  cout << ans << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(12);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#define file(x) freopen(#x\".in\", \"r\", stdin), freopen(#x\".out\", \"w\", stdout)\n\nconst int N(1e5 + 10);\nstruct edge { int x, y; } e[N];\nstruct node { long long d; int id; } a[N];\ninline int operator < (const node &l, const node &r)\n\t{ return l.d < r.d; }\nint n, size[N], cnt;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%lld\", &a[i].d), a[i].id = i, size[i] = 1;\n\tstd::sort(a + 1, a + n + 1);\n\tlong long dis = 0, d;\n\tfor (int i = n, p; i > 1; i--)\n\t{\n\t\td = a[i].d - n + (size[i] << 1), p = std::lower_bound(a + 1, a + n + 1, (node) {d, 0}) - a;\n\t\tif (a[p].d != d) return puts(\"-1\"), 0;\n\t\te[++cnt] = (edge) {a[i].id, a[p].id}, size[p] += size[i], dis += size[i];\n\t}\n\tif (dis != a[1].d) puts(\"-1\");\n\telse for (int i = 1; i < n; i++) printf(\"%d %d\\n\", e[i].x, e[i].y);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#define mp make_pair\n#define fi first\n#define se second\nusing namespace std;\npair <long long, int> a[1000006];\npair <int, int> edge[1000006];\nint sze[1000006];\nint main(){\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++ i){\n\t\tscanf(\"%lld\", &a[i].fi);\n\t\ta[i].se = i;\n\t}\n\tsort(a + 1, a + 1 + n);\n\tint m = 0;\n\tfor (int i = n; i >= 2; -- i){\n\t\t++ sze[i];\n\t\tlong long d = a[i].fi - n + 2 * sze[i];\n\t\tint index = lower_bound(a + 1, a + 1 + n, mp(d, 0)) - a;\n\t\tif (a[index].fi != d || index >= i){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tedge[++ m] = mp(a[index].se, a[i].se);\n\t\tsze[index] += sze[i];\n\t}\n\tfor (int i = 1; i <= m; ++ i)\n\t\tprintf(\"%d %d\\n\", edge[i].fi, edge[i].se);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint n,nn;\nstruct node{int p,f,l,r;long long d;};\nnode a[100010];\nint oa[100010],ob[100010];\n\nvoid qsort(int l,int r)\n{\n\tint i,j;\n\tnode m,t;\n\ti=l;j=r;\n\tm=a[(l+r)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (a[i].d<m.d) i++;\n\t\twhile (a[j].d>m.d) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tt=a[i];a[i]=a[j];a[j]=t;\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort(l,j);\n\tif (i<r) qsort(i,r);\n}\n\nvoid qsort2(int l,int r)\n{\n\tint i,j;\n\tint ma,mb,t;\n\ti=l;j=r;\n\tma=oa[(l+r)/2];\n\tmb=ob[(l+r)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (oa[i]<ma || (oa[i]==ma && ob[i]<mb)) i++;\n\t\twhile (oa[j]>ma || (oa[j]==ma && ob[j]>mb)) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tt=oa[i];oa[i]=oa[j];oa[j]=t;\n\t\t\tt=ob[i];ob[i]=ob[j];ob[j]=t;\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort2(l,j);\n\tif (i<r) qsort2(i,r);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tnn=n-2;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&a[i].d);\n\t\ta[i].p=i;\n\t\ta[i].f=-1;\n\t\ta[i].l=-1;\n\t\ta[i].r=-1;\n\t}\n\tqsort(1,n);\n\tbool ok=true;\n\ta[1].l=0;a[1].r=n-1;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tbool check=true;\n\t\tfor (int j=i-1;j>=1;j--)\n\t\t{\n\t\t\tif (a[i].d-a[j].d>nn) \n\t\t\t{\n\t\t\t\tcheck=false;break;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif ((a[i].d-a[j].d-nn)%2==0)\n\t\t\t\t{\n\t\t\t\t\tint l,r;\n\t\t\t\t\tl=(nn+(a[i].d-a[j].d))/2;\n\t\t\t\t\tr=(nn-(a[i].d-a[j].d))/2;\n\t\t\t\t\tif (r<a[j].r)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[i].f=a[j].p;\n\t\t\t\t\t\ta[i].l=nn-r;\n\t\t\t\t\t\ta[i].r=r;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!check) {ok=false;break;}\n\t}\n\tif (ok)\n\t{\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tif (a[i].f<a[i].p) {oa[i]=a[i].f;ob[i]=a[i].p;}\n\t\t\telse {oa[i]=a[i].p;ob[i]=a[i].f;}\n\t\t}\n\t\tqsort2(1,n);\n\t\tfor (int i=2;i<=n;i++)\n\t\t\tprintf(\"%d %d\\n\",oa[i],ob[i]);\n\t}\n\telse printf(\"-1\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int MN = 100010;\n\nint N;\nll D[MN];\nvector<pair<ll, int> > ord;\nint inv[MN], sz[MN];\nvector<pii> edge;\nvector<int> adj[MN];\nint dep[MN];\n\nvoid dfs(int u, int p) {\n    for(int i = 0; i < adj[u].size(); i++) {\n        int v = adj[u][i];\n        if(v == p) continue;\n        dep[v] = dep[u] + 1;\n        dfs(v, u);\n    }\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%lld\", &D[i]);\n        ord.push_back({ D[i], i });\n    }\n\n    sort(ord.begin(), ord.end());\n    for(int i = 0; i < N; i++) inv[ ord[i].second ] = i;\n    sort(D, D + N);\n\n    for(int i = 0; i < N; i++) sz[i] = 1;\n    for(int i = N - 1; i >= 1; i--) {\n        if(2 * sz[i] >= N) {\n            printf(\"-1\");\n            return 0;\n        }\n        if(D[i] - N + 2 * sz[i] <= 0) {\n            printf(\"-1\");\n            return 0;\n        }\n        int a = lower_bound(D, D + N, D[i] - N + 2 * sz[i]) - D;\n        if(D[a] != D[i] - N + 2 * sz[i]) {\n            printf(\"-1\");\n            return 0;\n        }\n\n        edge.push_back(pii(inv[a], inv[i]));\n        sz[a] += sz[i];\n        adj[a].push_back(i);\n    }\n    if(sz[0] != N) {\n        printf(\"-1\");\n        return 0;\n    }\n\n    dfs(0, -1);\n\n    ll sum = 0;\n    for(int i = 0; i < N; i++) sum += dep[i];\n    if(sum != D[0]) {\n        printf(\"-1\");\n        return 0;\n    }\n\n    for(int i = 0; i < N - 1; i++) {\n        printf(\"%d %d\\n\", edge[i].first + 1, edge[i].second + 1);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n;\nvector<pair<ll,int>>vec;\nint sz[100005];\nvector<int>edge[100005];\nll dist[100005];\nvoid dfs(int v,int u,int d){\n\tdist[v] = d;\n\trep(i,edge[v].size()){\n\t\tif(edge[v][i] == u) continue;\n\t\tdfs(edge[v][i],v,d+1);\n\t}\n}\nll O;\nint main(){\n\tscanf(\"%d\",&n);\n\trepn(i,n){\n\t\tll a; scanf(\"%lld\",&a) ; vec.pb(mp(-a,i)); if(i == 1) O = a;\n\t}\n\tsort(vec.begin(),vec.end());\n\t\n\trepn(i,n) sz[i] = 1;\n\t\n\tfor(int i=0;i<n-1;i++){\n\t\tll a = vec[i].fi;\n\t\tint v = vec[i].sc;\n\t\t\n\t\tll need = -a - (n-2*sz[v]);\n\t\tint aa = POSL(vec,mp(-need,-1));\n\t\tif(aa < vec.size() && -vec[aa].fi != need){\n\t\t\tputs(\"-1\"); return 0;\n\t\t}\n\t\t//cout << v << \" \" << vec[aa].sc << endl;\n\t\tedge[vec[aa].sc].pb(v);\n\t\tedge[v].pb(vec[aa].sc);\n\t\tsz[vec[aa].sc] += sz[v];\n\t}\n\tfill(dist,dist+100005,1e18);\n\tdfs(1,-1,0);\n\t\n\trepn(i,n){\n\t\tO -= dist[i];\n\t}\n\t\n\tif(O){\n\t\tputs(\"-1\"); return 0;\n\t}\n\t\n\trepn(i,n){\n\t\trep(j,edge[i].size()){\n\t\t\tint to = edge[i][j];\n\t\t\tif(i < to) printf(\"%d %d\\n\",i,to);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define size(x) ((int) x.size())\ntypedef pair<int,int> pii;\n\nconst int MAXN = 1e5 + 5;\n\nint n, root, cnt;\nint a[MAXN];\nint d[MAXN], sz[MAXN];\nint v, par;\n\nvector<int> adj[MAXN];\nvector<pii> ans;\n\npii b[MAXN];\n\nbool cmp(int i, int j) {\n\treturn d[i] > d[j];\n}\n\nint getP(int i) {\n\tint hp = d[i] - n + 2 * sz[i];\n\tauto tmp = lower_bound(b, b + n, pii(hp, 0)) - b;\n\t//cerr << b[tmp].first << \" \" << b[tmp].second << endl;\n\tif (b[tmp].first != hp) \n\t\treturn -1;\n\treturn b[tmp].second;\n}\n\nint dfs(int u) {\n\tint val = 0;\n\tfor (auto v : adj[u])\n\t\tval += dfs(v) + sz[v];\n\treturn val;\n}\n\t\nint32_t main() {\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)  {\n\t\tcin >> d[i];\n\t\tb[i] = {d[i], i};\n\t\ta[i] = i;\n\t\tsz[i] = 1;\n\t}\n\tsort(b, b + n);\n\tsort(a, a + n, cmp);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tv = a[i];\n\t\tpar = getP(v);\n\t\t//cout << v << \" \" << par << endl;\n\t\tif (par == -1)\n\t\t\treturn cout << -1 << endl, 0;\n\t\tsz[par] += sz[v];\n\t\tans.push_back({v, par}); \n\t\tadj[par].push_back(v);\n\t\tif (2 * sz[v] > n) \n\t\t\treturn cout << -1 << endl, 0;\n\t\t//cout << v << \" \" << par << endl;\n\t}\n\troot = a[n - 1];\n\tif (d[root] != dfs(root))\n\t\treturn cout << -1 << endl, 0;\n\tfor (auto x : ans) \n\t\tcout << x.first + 1 << \" \" << x.second + 1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <assert.h>\nusing namespace std;\ntypedef long long LL;\nconst int N=100000+10;\nint n,sz[N]; \npair<LL,LL> d[N];\nvector<LL> g[N];\nbool cmp(pair<LL,LL> p1,pair<LL,LL> p2){\n    return p1.second>p2.second;\n}\nmap<LL,LL> mp;\nvector< pair<LL,LL> > res;\nvoid prt(int u,int p){\n    for(auto v:g[u]){\n        if(v==p)continue;\n        res.push_back(make_pair(u,v));\n        prt(v,u);\n    }\n}\nint main() {\n    return !printf(\"-1\\n\");\n    scanf(\"%d\",&n); \n    for(int i=1;i<=n;i++){\n        d[i].first=i; \n        scanf(\"%lld\",&d[i].second);\n        mp[d[i].second]=i;\n        sz[i]=1;\n    }\n    sort(d+1,d+1+n,cmp);\n    for(int i=1;i<n;i++){\n        LL tmp=d[i].second;\n        LL nex=tmp-(n-2*sz[d[i].first]);\n        if(mp[nex]==0||nex>=tmp){\n            return !printf(\"-1\\n\");\n        }\n        int u=mp[nex];\n        int v=d[i].first;\n        g[u].push_back(v); g[v].push_back(u);\n        sz[u]+=sz[v];\n    }\n    prt(d[n].first,d[n].first);\n    if(res.size()==n-1){\n        for(auto p: res) printf(\"%lld %lld\\n\", p.first, p.second);\n    } else {\n        printf(\"-1\\n\");\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nmap<int,int> M1,M2;\nint s1[200010],pa[200010];\nstruct edge\n{\n\tint v,next;\n}vs[200010];\nint st[200010],ee,sz[200010],vis[20010];\ninline void addedge(int u,int v)\n{\n\tvs[++ee].v=v;vs[ee].next=st[u];st[u]=ee;\n}\t\ninline void dfs(int rt,int pr)\n{\n\tif(vis[rt])\n\t{\n\t\tputs(\"-1\"); exit(0);\n\t}\n\tvis[rt]=1; sz[rt]=1;\n\tfor(int i=st[rt];i;i=vs[i].next)\n\t\tif(vs[i].v!=pr) dfs(vs[i].v,rt),sz[rt]+=sz[vs[i].v];\n}\nsigned main()\n{\n\tint n=read();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=read();\n\t\tM1[x]=i; M2[x]=1;\n\t\ts1[i]=x;\n\t}\n\tsort(s1+1,s1+1+n);\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tint id=M1[s1[i]],sz=M2[s1[i]],td=s1[i]+2*sz-n;\t\n\t\tif(td>=s1[i]) continue;\t\n\t\tpa[id]=M1[td]; M2[td]+=sz;\n\t}\n\tint rt=0;\n\tfor(int i=1;i<=n;i++) \n\t{\n\t\tif(pa[i]) addedge(pa[i],i),addedge(i,pa[i]);\n\t\telse \n\t\t{\n\t\t\tif(rt) puts(\"-1\"),exit(0);\n\t\t\telse rt=i;\n\t\t}\n\t}\n\tdfs(rt,0);\n\tif(sz[rt]!=n) puts(\"-1\"),exit(0);\n\telse\n\t{ \n\t\tfor(int i=1;i<=n;i++)\n\t\tif(pa[i]) printf(\"%lld %lld\\n\",i,pa[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\n\n\n\n    \nint main(){\n    ll n;\n    cin>>n;\n    vector<ll> a(n);\n    map<ll,ll> M;\n    for(int i=0;i<n;i++){\n        cin>>a[i];\n        M[a[i]]=i+1;\n    }\n    sort(a.begin(),a.end(),greater<ll>());\n    vector<ll> parent(n,-1);\n    vector<ll> count(n,1);\n    vector<ll> cost(n,0);\n    for(int i=0;i+1<n;i++){\n        if(cost[i]!=a[i]){cout<<-1<<endl; return 0;}\n        ll to=a[i]-n+count[i]*2;\n        ll I=lower_bound(a.begin(),a.end(),to)-a.begin();\n        if(a[I]!=to){cout<<-1<<endl; return 0;}\n        count[I]+=count[i];\n        cost[I]+=cost[i]+count[i];\n        parent[i]=I;\n    }\n    if(cost[n-1]!=a[n-1]){cout<<-1<<endl; return 0;}\n    for(int i=0;i<n-1;i++){\n        cout<<M[a[i]]<<\" \"<<M[a[parent[i]]]<<endl;\n    }\n    \n    \n        \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(i,a,n) for(int i=a;i<=n;++i)\n#define PER(i,a,n) for(int i=n;i>=a;--i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(a) ({REP(__i,1,n) cout<<a[__i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\n\n\nconst int N = 1e6+10;\nint n, sz[N];\nstruct _ {\n\tll d;\n\tint id;\n\tbool operator < (const _ &rhs) const {\n\t\treturn d<rhs.d;\n\t}\n} a[N];\nvector<pii> ans;\nvector<int> g[N];\n\nvoid add(int u, int v) {\n\tans.pb(pii(u,v));\n\tg[u].pb(v),g[v].pb(u);\n}\n\nvoid dfs(int x, int f, int d) {\n\ta[1].d -= d;\n\tfor (int y:g[x]) if (y!=f) dfs(y,x,d+1);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tREP(i,1,n) { \n\t\tscanf(\"%lld\",&a[i].d);\n\t\ta[i].id = i, sz[i] = 1;\n\t}\n\tsort(a+1,a+1+n);\n\tPER(i,2,n) {\n\t\t_ u{a[i].d+2*sz[a[i].id]-n,0};\n\t\tauto p = lower_bound(a+1,a+1+n,u);\n\t\tif (p->d!=u.d) return puts(\"-1\"),0;\n\t\tadd(a[i].id,p->id), sz[p->id] += sz[a[i].id];\n\t}\n\tdfs(1,0,0);\n\tif (a[1].d||sz[a[1].id]!=n) return puts(\"1\"),0;\n\tfor (auto &t:ans) printf(\"%d %d\\n\",t.x,t.y);\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#define ll long long\n#define inf 20021225\n#define N 100010\nusing namespace std;\nll read()\n{\n\tll s=0,t=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')\tt=-1; ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn s*t;\n}\nstruct node{int id; ll d;}a[N];\nbool operator<(node a,node b){return a.d<b.d;}\nint sz[N],fa[N],n;\nmap<ll,int> f;\nint edge[N][2];\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)\ta[i].id=i,a[i].d=read(),f[a[i].d]=i;\n\tsort(a+1,a+n+1);\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tint x=a[i].id; ll d=a[i].d; sz[x]++;\n\t\tif(sz[x]>n/2)\treturn puts(\"-1\"),0;\n\t\tif(d-n+sz[x]*2>=d||f.find(d-n+sz[x]*2)==f.end())\treturn puts(\"-1\"),0;\n\t\tint fx=f[d-n+sz[x]*2]; sz[fx]+=sz[x]; fa[x]=fx;\n\t}\n\tfor(int i=2;i<=n;i++)\n\t\tprintf(\"%d %d\\n\",fa[a[i].id],a[i].id);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream& operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream& operator<<(ostream &os, vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream &os, pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\nint N;\nconstexpr int Nmax = 100000;\nvector<plint> D;\nvector<int> to[Nmax];\n\nplint dfs(int now, int prev)\n{\n    lint d = 0, subtreesz = 1;\n    for (auto nxt : to[now]) if (nxt != prev)\n    {\n        plint pa = dfs(nxt, now);\n        d += pa.first + pa.second;\n        subtreesz += pa.second;\n    }\n    return plint(d, subtreesz);\n}\n\nint main()\n{\n    cin >> N;\n    D.resize(N);\n    REP(i, N)\n    {\n        cin >> D[i].first;\n        D[i].second = i;\n    }\n\n    sort(D.begin(), D.end());\n\n    map<lint, vector<pint>> ma; // requiredD -> [(childId, stSz)]\n\n    while (!D.empty())\n    {\n        lint Dnow, id_now;\n        tie(Dnow, id_now) = D.back();\n        D.pop_back();\n\n        int stsz = 1;\n\n        if (ma.count(Dnow))\n        {\n            for (auto pa : ma[Dnow])\n            {\n                to[id_now].push_back(pa.first);\n                to[pa.first].push_back(id_now);\n                stsz += pa.second;\n            }\n            ma.erase(Dnow);\n        }\n        ma[Dnow + 2 * stsz - N].push_back(pint(id_now, stsz));\n    }\n\n    vector<pint> res;\n    REP(s, N) for (auto t : to[s]) if (s < t) res.push_back(pint(s, t));\n\n    // dbg(dfs(D[0].second, -1));\n    if (res.size() != N - 1 || dfs(D[0].second, -1).first != D[0].first) cout << -1 << endl, exit(0);\n\n    for (auto pa : res) cout << pa.first + 1 << \" \" << pa.second + 1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> T gi() {\n\tT x = 0; bool f = 0; char c = getchar();\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar();\n\tif (c == '-') f = 1, c = getchar();\n\twhile (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn f ? -x : x;\n}\nconst int N = 1e5 + 10;\nint p[N], siz[N], X[N], Y[N], fa[N];\nint find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\nLL D[N];\nmap<LL, int> M;\nbool cmp(int x, int y) { return D[x] > D[y]; }\n\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n = gi<int>();\n\tfor (int i = 1; i <= n; i++)\n\t\tD[i] = gi<LL>(), M[D[i]] = i, p[i] = i;\n\tsort(p + 1, p + 1 + n, cmp);\n\tfor (int i = 1; i <= n; i++) siz[i] = 1, fa[i] = i;\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x = p[i], y = M[D[x] - n + 2 * siz[x]];\n\t\tif (!y) continue;\n\t\tif (find(x) == find(y)) continue;\n\t\tfa[find(y)] = find(x);\n\t\tsiz[y] += siz[x]; X[++cnt] = x; Y[cnt] = y;\n\t}\n\tif (cnt == n - 1) {\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tprintf(\"%d %d\\n\", X[i], Y[i]);\n\t}\n\telse puts(\"-1\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nvoid NO(int where = 0) {\n//   dump(where);\n  cout << -1 << endl;\n  exit(0);\n}\n\n// 解けた〜たぴゃ〜 (ちょっとミスってたけど)\n// D_iは相異なる，まじか〜\n\nconst int N = 1e5;\nvector<vector<int>> g(N);\nusing Value = ll;\nmap<int, Value> dp[N];\nmap<int, int> sz[N];\nint n;\nValue dfs(int i, int p, int f = 0) {\n  if(dp[i].count(p)) return dp[i][p];\n  int cnt = 0;\n  Value res = 0;\n  if(f || p == -1) {\n    // O(deg(i))\n    // go only child\n    sz[i][p] = 1;\n    for(int j : g[i]) if(j != p) {\n      cnt++;\n      res += dfs(j, i, f);\n      res += sz[j][i];\n      sz[i][p] += sz[j][i];\n    }\n  } else {\n    // O(1)\n    dfs(i, -1, f);\n    dfs(p, i, f);\n    res = dp[i][-1] - (dp[p][i] + sz[p][i]);\n    cnt = g[i].size() - 1;\n    sz[i][p] = sz[i][-1] - sz[p][i];\n  }\n  return dp[i][p] = res;\n}\n\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  int n;\n  cin >> n;\n  vector<ll> d(n);\n  for(int i = 0; i < n; i++) cin >> d[i];\n  vector<int> ord(n);\n  iota((ord).begin(), (ord).end(), 0);\n  sort((ord).begin(), (ord).end(), [&](int i, int j) { return d[i] < d[j]; });\n  map<ll, int> mp;\n  for(int i = 0; i < n; i++) mp[d[i]] = i;\n  auto rnk = ord;\n  for(int i = 0; i < n; i++) rnk[ord[i]] = i;\n  vector<int> v(n);\n  vector<pair<int,int>> ans;\n  ll base = n - 2 * (n - 1);\n  for(int i = n - 1; i >= 1; i--) {\n    // dump(d[ord[i]], v[i], i);\n    ll s = d[ord[i]] + (base + v[i] * 2);\n    // dump(s);\n    if(s >= d[ord[i]]) NO(1);\n    if(!mp.count(s)) NO(2);\n    v[rnk[mp[s]]] += v[i] + 1;\n    int a = mp[s], b = ord[i];\n    // dump(a, b);\n    ans.emplace_back(a, b);\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n  // dump(\"here\");\n  dfs(0, -1, 1);\n  for(int i = 0; i < n; i++) if(d[i] != dfs(i, -1, 0)) NO();\n  for(int i = 0; i < n - 1; i++) cout << ans[i].first + 1 << \" \" << ans[i].second + 1 << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MN 100005\nint T,num,dep[MN],n,id[MN],head[MN];\nll a[MN];\nmap<ll,int>rea,cnt;\nstruct node{int x,y;};\nvector<node>sc;\nstruct edge{int to,next;}g[MN<<1];\nbool cmp(int x,int y){return a[x]>a[y];}\nvoid ins(int u,int v){g[++num].next=head[u];head[u]=num;g[num].to=v;}\nvoid dfs(int u,int ff){\n\tfor(int i=head[u];i;i=g[i].next)if(g[i].to!=ff){\n\t\tdep[g[i].to]=dep[u]+1,dfs(g[i].to,u);\n\t}\n}\nint main(){\n//\tfreopen(\"test.in\",\"r\",stdin);\n//\tfreopen(\"mysol.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),rea[a[i]]=i,cnt[a[i]]=1,id[i]=i;\n\tsort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<n;i++){\n\t\tint t=id[i];ll tmp=a[t]-n+2*cnt[a[t]];\n\t\tif(rea[tmp]&&tmp<a[t]){\n\t\t\tcnt[tmp]+=cnt[a[t]];\n\t\t\tsc.push_back((node){t,rea[tmp]});\n\t\t}\n\t\telse return 0*puts(\"-1\");\n\t}\n\tfor(int i=0;i<sc.size();i++)ins(sc[i].x,sc[i].y),ins(sc[i].y,sc[i].x);\n\tdfs(id[n],id[n]);ll tans=0;\n\tfor(int i=1;i<=n;i++)tans+=dep[i];\n\tif(tans!=a[id[n]])return 0*puts(\"-1\");\n\tfor(int i=0;i<sc.size();i++)printf(\"%d %d\\n\",sc[i].x,sc[i].y);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 100003\nusing namespace std;\nstruct edge{int to,next;}e[maxn<<1];\nint head[maxn],cnte,fa[maxn];\nvoid add(int u,int v){e[++cnte].to=v,e[cnte].next=head[u],head[u]=cnte;}\nint n,sz[maxn],chksz[maxn],chksum[maxn],s[maxn];\nlong long d[maxn];\nmap<long long,int> b;\nbool cmp(int x,int y){return d[x]<d[y];}\nvoid dfs(int u){\n\tchksz[u]=1;\n\tfor(int i=head[u];i;i=e[i].next){\n\t\tint v=e[i].to;\n\t\tif(v==fa[u])continue;\n\t\tdfs(v);\n\t\tchksz[u]+=chksz[v];\n\t\tchksum[u]+=chksum[v]+sz[v];\n\t}\n\tif(chksz[u]!=sz[u]){puts(\"-1\");exit(0);}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",d+i),s[i]=i;\n\tsort(s+1,s+n+1,cmp);\n\tfor(int i=1;i<=n;i++)b[d[i]]=i,sz[i]=1;\n\tfor(int i=n;i>=2;i--){\n\t\tint v=s[i],u=b[d[v]-(n-sz[v])+sz[v]];\n\t\tif(u==0){puts(\"-1\");return 0;}\n\t\tadd(u,v),add(v,u),fa[v]=u;\n\t\tsz[u]+=sz[v];\n\t}\n\tif(cnte!=(n-1)*2){puts(\"-1\");return 0;}\n\tdfs(s[1]);\n\tif(chksz[s[1]]!=n||chksum[s[1]]!=d[s[1]]){puts(\"-1\");return 0;}\n\tfor(int u=1;u<=n;u++){\n\t\tfor(int i=head[u];i;i=e[i].next){\n\t\t\tint v=e[i].to;\n\t\t\tif(v==fa[u])continue;\n\t\t\tprintf(\"%d %d\\n\",u,v);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<iomanip>\n#include<cstring>\n#include<complex>\n#include<vector>\n#include<cstdio>\n#include<string>\n#include<bitset>\n#include<ctime>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#define Cpy(x,y) memcpy(x,y,sizeof(x))\n#define Set(x,y) memset(x,y,sizeof(x))\n#define FILE \"a\"\n#define mp make_pair\n#define pb push_back\n#define RG register\n#define il inline\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef vector<int>VI;\ntypedef long long ll;\ntypedef double dd;\nconst int N=1<<17;\nconst int mod=998244353;\nconst int base=26;\nconst dd eps=1e-6;\nconst int inf=2147483647;\nconst ll INF=1ll<<60;\nconst ll P=100000;\nil ll read(){\n  RG ll data=0,w=1;RG char ch=getchar();\n  while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n  if(ch=='-')w=-1,ch=getchar();\n  while(ch<='9'&&ch>='0')data=data*10+ch-48,ch=getchar();\n  return data*w;\n}\n\nil void file(){\n  srand(time(NULL)+rand());\n  freopen(FILE\".in\",\"r\",stdin);\n  freopen(FILE\".out\",\"w\",stdout);\n}\n\nint n,m;ll sz[N],o[N];\nstruct node{ll d,id;}t[N];bool cmp_d(node a,node b){return a.d<b.d;}\nil void er(){puts(\"-1\");exit(0);}\nstruct edge{int u,v;}E[N];\n/*\nint head[N],nxt[N<<1],to[N<<1],cnt;\nil void add(int u,int v){to[++cnt]=v;nxt[cnt]=head[u];head[u]=cnt;}\nint up[N],down[N],w[N],sz[N];\nvoid dfs1(int u,int ff){\n  sz[u]=1;\n  for(RG int i=head[u];i;i=nxt[i]){\n    RG int v=to[i];if(v==ff)continue;\n    dfs1(v,u);sz[u]+=sz[v];if()\n  }\n}\n*/\nint main()\n{\n  n=read();\n  for(RG int i=1;i<=n;i++){t[i].d=read();t[i].id=i;}\n  sort(t+1,t+n+1,cmp_d);\n  for(RG int i=1;i<=n;i++)o[i]=t[i].d,sz[i]=1;\n  for(RG int i=n,p;i!=1;i--){\n    p=lower_bound(o+1,o+n+1,t[i].d-n+2*sz[i])-o;\n    if(o[p]!=t[i].d-n+2*sz[i]||p>=i)er();\n    E[++m]=(edge){t[p].id,t[i].id};sz[p]+=sz[i];\n  }\n  //for(RG int i=1;i<=m;i++)add(E[i].u,E[i].v),add(E[i].v,E[i].u);\n  //dfs1(1,0);dfs2(1,0);\n  for(RG int i=1;i<=m;i++)printf(\"%d %d\\n\",E[i].u,E[i].v);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <map>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define v edge[i].to \n#define mp(a, b) make_pair(a, b)\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 100010;\n\npair<LL, int> d[N];\npair<int, int> e[N];\nmap<LL, int> mmp;\n\nint sz[N];\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tRep(i, n){\n\t\tscanf(\"%lld\", &d[i].fi);\n\t\tsz[i] = 1, d[i].se = i, mmp[d[i].fi] = i;\n\t}\n\tsort(d + 1, d + 1 + n);\n\tfor (int i = n; i > 1; i --) {\n\t\tLL tmp = d[i].fi + 2 * sz[d[i].se] - n;\n\t//\tprintf(\"%d %lld\\n\", d[i].fi, tmp);\n\t\tif (tmp < d[i].fi && mmp[tmp]) e[i - 1] = mp(d[i].se, mmp[tmp]), sz[mmp[tmp]] += sz[d[i].se];\n\t\telse {printf(\"-1\\n\"); return 0;}\n\t}\n\t\n\tRep(i, n - 1) printf(\"%d %d\\n\", e[i].fi, e[i].se);\n\t\n\treturn 0;\n}\n\n/*\nd[a] - d[b] = n - sz[a] - sz[a]\nd[b] = d[a] + 2 * sz[a] - n;\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MX=1e5+5;\npair<long long,int> a[MX];\nmap<long long,int> mp;\nlong long n;\nint p[MX];\nlong long s[MX];\nint main(){\n    cin.tie(0);\n    cout.tie(0);\n    ios_base::sync_with_stdio(0);\n    cin>>n;\n    int i;\n    for(i=1 ; i<=n ; i++){\n        cin>>a[i].first;\n        a[i].second=i;\n        mp[a[i].first]=i;\n    }\n    sort(a+1,a+n+1);\n    for(i=n ; i>=2 ; i--){\n      ///  cout<<i<<endl;\n        s[a[i].second]++;\n        int k=mp[a[i].first+2*s[a[i].second]-n];\n        if(k==0 || k==a[i].second){\n            cout<<-1;\n            return 0;\n        }\n        s[k]+=s[a[i].second];\n        p[a[i].second]=k;\n    }\n    for(i=2 ; i<=n ;i++){\n        cout<<a[i].second<<\" \"<<p[a[i].second]<<\"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cassert>\n#include<vector>\n#define ll long long\nusing namespace std;\ninline ll read(){\n\tll re=0,flag=1;char ch=getchar();\n\twhile(ch>'9'||ch<'0'){\n\t\tif(ch=='-') flag=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();\n\treturn re*flag;\n}\nll n;\nstruct node{\n\tll num,dis;\n}a[100010];\nll siz[100010],fa[100010],d[100010],dep[100010];\nvector<ll>son[100010];\nbool cmp(node l,node r){\n\treturn l.dis<r.dis;\n}\nvoid dfs(ll u,ll f){\n\tll i;dep[u]=dep[f]+1;\n//\tcout<<u<<' '<<dep[u]<<\"***\\n\";\n\tfor(auto v:son[u]){\n\t\tif(v!=f) dfs(v,u);\n\t}\n}\nint main(){\n\tn=read();ll i;\n\tfor(i=1;i<=n;i++) a[i].dis=read(),a[i].num=i;\n\tsort(a+1,a+n+1,cmp);\n\tfor(i=1;i<=n;i++) d[i]=a[i].dis;\n\tfor(i=n;i>=2;i--){\n\t\tsiz[a[i].num]++;\n\t\tll tmp=d[i]-(n-2*siz[a[i].num]);\n\t\tll pos=lower_bound(d+1,d+i,tmp)-d;\n//\t\tcout<<i<<' '<<d[i]<<' '<<a[i].num<<' '<<siz[a[i].num]<<' '<<tmp<<' '<<pos<<' '<<a[pos].num<<' '<<d[pos]<<'\\n';\n\t\tif(pos>=i||d[pos]!=tmp){\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t\tsiz[a[pos].num]+=siz[a[i].num];fa[a[i].num]=a[pos].num;\n\t}\n\tstd::ios::sync_with_stdio(false);\n\tfor(i=1;i<=n;i++) if(fa[i]) son[fa[i]].push_back(i);\n\tdep[0]=-1;dfs(a[1].num,0);\n\tll ans=0;\n\tfor(i=1;i<=n;i++) ans+=dep[i];\n\tif(ans!=d[1]){\n\t\tputs(\"-1\");return 0;\n\t}\n\tfor(i=1;i<=n;i++) if(fa[i]) cout<<i<<' '<<fa[i]<<'\\n';\n} "
  },
  {
    "language": "C++",
    "code": "//jinhaonan\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntemplate<class T>inline void read(T &x){\n\tx=0;char c=getchar();bool f=0;\n\tfor(;c>'9'||c<'0';f=c=='-',c=getchar());\n\tfor(;c>='0'&&c<='9';x=(x<<1)+(x<<3)+c-'0',c=getchar());\n\tx=f?-x:x;\n}\ntemplate<class T>inline void write(T x){\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>=10)write(x/10);\n\tputchar(x%10+48);\n}\ntemplate<class T>inline bool chkmax(T &a,T const &b){\n\treturn a<b?a=b,1:0;\n}\ntemplate<class T>inline bool chkmin(T &a,T const &b){\n\treturn a>b?a=b,1:0;\n}\nconst int N=100000+10;\nvoid Main(){\n\tstatic pair<long long,int> d[N];\n\tstatic int size[N];\n\tstatic long long dis[N];\n\tmap<long long,int> p;\n\tvector<pair<int,int>> ans;\n\tint n;read(n);\n\tfor(int i=1;i<=n;++i){\n\t\tread(d[i].first);\n\t\td[i].second=i;\n\t\tp[d[i].first]=i;\n\t\tsize[i]=1;\n\t}\n\tsort(d+1,d+n+1);\n\tfor(int i=n;i>1;--i){\n\t\tint x=n-size[d[i].second]*2;\n\t\tif(x<=0){\n\t\t\tputs(\"-1\");\n\t\t\treturn;\n\t\t}\n\t\tx=d[i].first-x;\n\t\tauto it=p.find(x);\n\t\tif(it==p.end()){\n\t\t\tputs(\"-1\");\n\t\t\treturn;\n\t\t}\n\t\tdis[it->second]+=dis[d[i].second]+size[d[i].second];\n\t\tsize[it->second]+=size[d[i].second];\n\t\tans.push_back({d[i].second,it->second});\n\t}\n\tif(dis[d[1].second]!=d[1].first){\n\t\tputs(\"-1\");\n\t\treturn;\n\t}\n\tfor(auto e:ans){\n\t\twrite(e.first),putchar(' ');\n\t\twrite(e.second),putchar('\\n');\n\t}\n\n}\nint main(){\n    // freopen(\"in.txt\",\"r\",stdin);\n    // int test;read(test);\n    // while(test--){\n        Main();\n    // }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<long long, int> pli;\n\nconst int N = 1e5 + 10;\nint h[N], n, cnt[N], check, par[N];\nlong long d[N];\nvector<pli> di;\nvector<int> child[N];\nmap<long long, int> mp;\n\nvoid dfs(int v, int p){\n\th[v] = h[p] + 1;\n\tfor (int u : child[v])\n\t\tdfs(u, v);\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);cout.tie(0);\n\t\n\tcin >> n;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> d[i];\n\t\tdi.push_back({d[i], i});\n\t\tmp[d[i]] = i + 1;\n\t}\n\t\n\tsort(di.begin(), di.end());\n\treverse(di.begin(), di.end());\n\t\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[i] = 1;\n\tfor (int i = 0; i < n - 1; i++){\n\t\tint v = di[i].second,\n\t\t\tdis = di[i].first,\n\t\t\tpar_dis = dis + (2 * cnt[v]) - n;\n\t\t\n\t\tif(mp[par_dis] == 0)\n\t\t\treturn cout << -1, 0;\n\t\t\n\t\tint ver_par = mp[par_dis] - 1;\n\t\tcnt[ver_par] += cnt[v];\n\t\tpar[v] = ver_par;\n\t\tchild[par[v]].push_back(v);\n\t}\n\t\n\tint root = di[n - 1].second;\n\th[root] = -1;\n\tdfs(root, root);\n\t\n\tfor (int i = 0; i < n; i++)\n\t\tcheck += h[i];\n\t\n\tif(check != d[root])\n\t\treturn cout << -1, 0;\n\t\n\tfor (int i = 0; i < n; i++)\n\t\tif(par[i] != i)\n\t\t\tcout << par[i] + 1 << ' ' << i + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <set>\n#include <vector>\n#include <numeric>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nstruct DSU {\n    vector<int> parent, set_size;\n    set<int> roots;\n\n    DSU () {}\n\n    DSU(int n) {\n        assign(n);\n    }\n\n    void assign(int n) {\n        parent.resize(n);\n        set_size.assign(n, 1);\n        iota(parent.begin(), parent.end(), 0);\n        roots.insert(parent.begin(), parent.end());\n    }\n\n    bool check(int a, int b) {\n        return root(a) == root(b);\n    }\n\n    int root(int x) {\n        while (x != parent[x]) {\n            x = parent[x] = parent[parent[x]];\n        }\n        return x;\n    }\n\n    int size() { return roots.size(); }\n\n    int size(int i) { return set_size[root(i)]; }\n\n    bool join(int a, int b) {\n        a = root(a), b = root(b);\n        \n        if (a == b) {\n            return false;\n        }\n\n        if (set_size[a] < set_size[b]) {\n            swap(a, b);\n        }\n\n        roots.erase(b);\n        set_size[a] += set_size[b];\n        parent[b] = a;\n        return true;\n    }\n};\n\n\nint main() {\n    ios_base::sync_with_stdio(0);\n\n    int n;\n    cin >> n;\n    set<pair<int, int>, greater<pair<int, int> > > s;\n    for (int i = 1, d; i <= n; i++) {\n        cin >> d;\n        s.emplace(d, i);\n    }\n    vector<pair<int, int> > edges;\n    DSU d(n);\n    bool res = true;\n    while (d.size() != 1 and res) {\n        const int dist = s.begin()->first, i = s.begin()->second;\n        const int next_dist = dist - (n - 2 * d.size(i - 1));\n        s.erase(s.begin());\n        auto it = s.upper_bound({next_dist, INF});\n        if (it == s.end() or it->first != next_dist) {\n            res = false;\n        }\n        else {\n            edges.emplace_back(i, it->second);\n            d.join(i - 1, it->second - 1);\n        }\n    }\n    if (res) {\n        for (auto p : edges) {\n            cout << p.first << ' ' << p.second << '\\n';\n        }\n    } else {\n        cout << \"-1\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define pb push_back\n//#define mp make_pair\n#define fast_io ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\nconst ll maxn = 1e5 + 10;\npair <ll, ll> d[maxn];\nmap <ll, ll> mp;\nvector <ll> adj[maxn];\nll sz[maxn];\nll h[maxn];\nbool mark[maxn];\nll n;\n\nvoid dfs(int v){\n\tmark[v] = true;\n\tfor(int i : adj[v]){\n\t\tif(!mark[i]){\n\t\t\th[i] = h[v] + 1;\n\t\t\tdfs(i);\n\t\t}\n\t}\n}\n\nbool check(){\n\tdfs(d[n - 1].second);\n\tll sum = 0;\n\tfor(int i = 0; i < n; i ++){\n\t\tsum += h[i];\n\t}\n//\tcout << d[n - 1].second << endl;\n\tif(sum != d[n - 1].first)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\nint main(){\n\tfast_io;\n\tcin >> n;\n\tfor(ll i = 0; i < n; i ++){\n\t\tll x;\n\t\tcin >> x;\n\t\td[i] = {x, i};\n//\t\ts.insert({-x, i});\n\t\tmp[x] = i; \n\t}\n\tsort(d, d + n);\n\treverse(d, d + n);\n\tbool flag = true;\n\t\n\tfor(ll i = 0; i < n - 1; i ++){\n\t\tsz[d[i].second] = 1;\n\t\tfor(ll u : adj[d[i].second]){\n\t\t\tsz[d[i].second] += sz[u];\n\t\t}\n\t\tll x = d[i].first + sz[d[i].second] * 2 - n;\n\t\tauto f = mp.find(x);\n\t\tif(f == mp.end()){ \n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}else{\n\t\t\tadj[mp[x]].pb(d[i].second);\n\t\t}\n//\t\tcout << \"x = \" << x << endl;\n\t}\n\t\n\tflag = check();\n\t\n\tif(flag){\n\t\tfor(ll i = 0; i < n; i ++){\n\t\t\tfor(ll u : adj[i]){\n\t\t\t\tcout << i + 1 << \" \" << u + 1 << endl;\n\t\t\t}\n\t\t}\n\t}else{\n\t\tcout << -1 << endl;\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n//#define db double\n#define all(x) x.begin(), x.end()\n#define SZ(x) (int)(x.size())\n#define mem(x, y) memset(x, y, sizeof(x))\n#define what_is(x) cerr <<  \"Line \" << __LINE__ << \": \" << #x << \" is \" << (x) << endl;\n#define suf_zero(x) __builtin_ffs(x)\n#define pre_zero(x) __builtin_clz(x)\n#define num_one(x) __builtin_popcount(x)\n#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }\n#define mt make_tuple\n#define mp make_pair\n#define eb push_back\n#define pb push_back\n#define INFI 2000000009\n#define INFLL (ll)1e18+7\n#define ig ignore\n#define fi first\n#define TP tuple<int, int, int>\n#define se second\n//#define lson l, mid, rt<<1\n//#define rson mid+1, r, rt<<1|1\n#define PII pair<int, int>\n//void print(__int128 x){if(x>9)print(x/10);putchar('0'+x%10);}\n#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)>(end));i!=(end)-((begin)>(end));i+=1-2*((begin)>(end)))\nvoid err(istream_iterator<string> it) {cerr<<endl;}\ntemplate<typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args) {\n    cerr << *it << \" = \" << a << \" , \";\n    err(++it, args...);\n}// fast IO\nauto TIMESTART = chrono::steady_clock::now();\nauto TIMESTOP  = chrono::steady_clock::now();\nvoid TimeStop()\n{\n    TIMESTOP = chrono::steady_clock::now();\n    auto ElapsedTime = TIMESTOP - TIMESTART;\n    cout << \"\\n\\nTime elapsed: \" << chrono::duration<double>(ElapsedTime).count() << \" seconds.\\n\";\n}\nnamespace fastIO{\n    #define BUF_SIZE 2000000\n//     fread -> read\n    bool IOerror = 0;\n    static char obuf[BUF_SIZE], *OUT=obuf;\n    inline char nc(){\n        static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE,\n         *pend = buf+BUF_SIZE;\n         if(p1==pend){\n             p1 = buf;\n             pend = buf+fread(buf, 1, BUF_SIZE, stdin);\n             if(pend==p1){\n                 IOerror = 1;\n                 return -1;\n             }\n         }\n         return *p1++;\n    }\n    inline bool blank(char ch){return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t';}\n    inline void read(int &x){\n        char ch;\n        while(blank(ch=nc()));\n        if(IOerror)return ;\n        for(x=ch-'0';(ch=nc())>='0'&&ch<='9';x=x*10+ch-'0');\n    }\n    inline void read(ll &x){\n        char ch;\n        while(blank(ch=nc()));\n        if(IOerror)return ;\n        for(x=ch-'0';(ch=nc())>='0'&&ch<='9';x=x*10+ch-'0');\n    }\n    void print(const int& x) {\n        if(x > 9) print(x / 10);\n        *OUT++= x % 10 + '0';\n    }\n    void print(const ll& x) {\n        if(x > 9) print(x / 10);\n        *OUT++= x % 10 + '0';\n    }\n    void print(){fwrite(obuf, OUT-obuf, 1, stdout);}\n    #undef BUF_SIZE\n}\nusing namespace fastIO;\n//#include<ext/pb_ds/assoc_container.hpp>\n//#include<ext/pb_ds/tree_policy.hpp>\n//#include<ext/pb_ds/hash_policy.hpp>\n//using namespace __gnu_pbds;\n//mt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\n//mt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\nconst double pi = acos(-1.0);\nconst double eps = 1e-8;\nconst int mod = 1e9+7;\n#define mul(a, b) 1LL * (a) * (b) % mod\n#define add(a, b) (a + b >= mod ? a + b - mod : a + b)\n#define sub(a, b) (a - b <  0 ? a - b + mod : a - b)\n#define RG register\n///////////// BOUND /////////////////\nll qp(ll b, ll n, const ll mod=::mod){ll r=1;if(n<0)n+=mod-1;b%=mod;for(;n;n>>=1,b=mul(b,b))if(n&1)r=mul(r,b);return r;}\n#define inv(x) (qp((x), mod-2))\n//const ll inv2 = (mod+1)/2;\n//const ll inv6 = qp(6, mod-2);\n//ll sum_of_sq(ll n){n%=mod;return n*(n+1)%mod*(2*n+1)%mod*inv6%mod;}\n//tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> T;\n//cc_hash_table<ll, ll> Sf, Sg, Sh;\n/////////////// Macro ///////////////\nconst int maxn = 1e5+7;\nint sz[maxn];\nll d[maxn];\npair<ll, int> p[maxn];\nll ans = 0;\nvector<int> G[maxn];\nint fa[maxn];\nvoid dfs(int u,int h)\n{\n    ans+=h;\n    for(auto v:G[u]) dfs(v, h+1);\n}\nint main()\n{\n    #ifdef aoaoao\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"me.txt\", \"w\", stdout);\n    #endif // aoaoao\n    int n;scanf(\"%d\", &n);\n    for(int i=1;i<=n;++i) scanf(\"%lld\", &d[i]), sz[i]=1, p[i]=mp(d[i], i);\n    sort(p+1, p+1+n, greater<pair<ll, int> >());\n    vector<PII> vec;\n    for(int i=1;i<n;++i)\n    {\n        ll tmp = p[i].fi+sz[p[i].se]*2-n;\n        int x = lower_bound(p+1, p+1+n, mp(tmp, INFI), greater<pair<ll, int> >())-p;\n//        error(i, p[i].fi, p[i].se, tmp, p[x].fi, x);\n        if(p[x].fi!=tmp) return puts(\"-1\"), 0;\n        sz[p[x].se]+=sz[p[i].se];\n        G[p[x].se].eb(p[i].se);\n        vec.eb(mp(p[i].se, p[x].se));\n    }\n    dfs(p[n].se, 0);\n    if(ans!=p[n].fi) return puts(\"-1\"), 0;\n    sort(all(vec));\n    for(auto x:vec)\n        cout << x.fi << ' ' << x.se << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 100100;\n\nint N;\nll D[MAXN];\nvector <int> edge[MAXN];\n\nmap <ll, int> ord;\nmap <ll, int> ssize;\nmap <ll, ll> stot;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n\n    cin >> N;\n    for (int i = 0; i < N; i++)\n    {\n        cin >> D[i];\n        ord[D[i]] = i;\n        ssize[D[i]] = 1;\n        stot[D[i]] = 0;\n    }\n\n    for (auto it = ord.rbegin(); it != ord.rend(); it++)\n    {\n        ll cv = it -> first;\n        int ind = it -> second;\n\n        int csize = ssize[cv];\n        if (csize == N) break;\n        ll ntot = D[ind] - ((N - csize) - csize);\n        //cout << cv << \" \" << ntot << \"\\n\";\n        if (ord.find(ntot) == ord.end())\n        {\n            cout << \"-1\\n\";\n            return 0;\n        }\n\n        ssize[ntot] += csize;\n        stot[ntot] += (stot[cv] + ssize[cv]);\n        edge[ord[ntot]].push_back(ind);\n    }\n    cout << \"made it\\n\";\n\n    int mloc = 0;\n    for (int i = 0; i < N; i++)\n        if (D[i] < D[mloc])\n            mloc = i;\n    if (stot[D[mloc]] != D[mloc])\n    {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    else\n    {\n        for (int i = 0; i < N; i++)\n        {\n            for (int neigh : edge[i])\n                cout << neigh + 1 << \" \" << i + 1 << \"\\n\";\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*====Corycle====*/\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#define ll long long\n#define set_it set<Node>::iterator\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst int N=1e5+5;\nint read(){\n\tint s=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){s=s*10+c-'0';c=getchar();}\n\treturn s*f;\n}\nll Dist,a[N];\nint n,m,b[N],fa[N],sum[N];\nbool cmp(int x,int y){return a[x]>a[y];}\nstruct Node{\n\tll val;int x;\n\tfriend bool operator<(Node A,Node B){return A.val!=B.val?A.val<B.val:A.x<B.x;}\n};\nset<Node>F;\nint main(){\n//\tfreopen(\"_.in\",\"r\",stdin);\n//\tfreopen(\"_.out\",\"w\",stdout);\n\tn=read();\n\tfor(int i=1;i<=n;i++){a[i]=read();b[i]=i;sum[i]=1;F.insert((Node){a[i],i});}\n\tsort(b+1,b+n+1,cmp);\n\tfor(int i=1;i<n;i++){\n\t\tint x=b[i];\n\t\tll val=a[x]+2*sum[x]-n;\n\t\tF.erase((Node){a[x],x});\n\t\tset_it p=F.lower_bound((Node){val,0});\n\t\tif(p==F.end()||(*p).val!=val){puts(\"-1\");return 0;}\n\t\tint y=(*p).x;fa[x]=y;sum[y]+=sum[x];Dist+=sum[x];\n\t}\n\tif(Dist!=a[b[n]]){puts(\"-1\");return 0;}\n\tfor(int i=1;i<=n;i++)if(fa[i])printf(\"%d %d\\n\",i,fa[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=1e5+10;\nint n,cnt,e,f[N],a[N],id[N],siz[N],res[N],head[N],link[N*2],to[N*2];\nbool vis[111111];\nmap <int,int> mp;\nbool cmp(int x,int y){return a[x]<a[y];}\nvoid add(int u,int v){to[++e]=v,link[e]=head[u],head[u]=e;}\nvoid dfs1(int u,int dep){\n\tsiz[u]=1,res[id[1]]+=dep;\n\tfor(int i=head[u];i;i=link[i])if(to[i]!=f[u])dfs1(to[i],dep+1),siz[u]+=siz[to[i]];\n}\nvoid dfs2(int u){for(int i=head[u];i;i=link[i])if(to[i]!=f[u])res[to[i]]=res[u]+n-2*siz[to[i]],dfs2(to[i]);}\nsigned main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]),id[i]=i,mp[a[i]]=i,siz[i]=1;\n\tsort(id+1,id+n+1,cmp);\n\tfor(int i=n;i>1;i--){\n\t\tint x=2*siz[id[i]]-n+a[id[i]];\n\t\tif(!mp.count(x)||n-2*siz[id[i]]<=0){printf(\"-1\");return 0;}\n\t\tint pos=mp[x];add(pos,id[i]),add(id[i],pos),siz[pos]+=siz[id[i]],f[id[i]]=pos;\n\t}\n\tdfs1(id[1],0),dfs2(id[1]);\n\tfor(int i=1;i<=n;i++)if(a[i]!=res[i]){printf(\"-1\");return 0;}\n\tfor(int i=2;i<=n;i++)printf(\"%d %d\\n\",f[id[i]],id[i]);\n}"
  },
  {
    "language": "C++",
    "code": "//#include \"bits/stdc++.h\"\n\n#define _USE_MATH_DEFINES\n#include<cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <iterator>\n#include<iomanip>\n#include<unordered_set>\n#include<unordered_map>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a), i##_len=(b);i<i##_len;i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\n\n#define int ll\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define mp make_pair\n\n//typedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\ntypedef vector< vector<int> > mat;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD =  (int)1e9 + 7;\nconst double EPS = 1e-9;\n\nint N;\nint D[100010],OD[100010],OP[100010];\nint SSZ[100010];\nvector<pii> ANS;\nint CD[100010];\nvector<int> G[100010];\n\nvoid dfs(int idx,int par,int cnt)\n{\n\tCD[idx]=cnt;\n\tfor(auto e:G[idx])\n\t{\n\t\tif(e==par)continue;\n\t\tdfs(e,idx,cnt+1);\n\t}\n}\n\nbool func()\n{\n\tdfs(0,-1,0);\n\tint t=0;\n\trep(i,0,N)\n\t{\n\t\tt+=CD[i];\n\t}\n\treturn t==D[0];\n}\n \nsigned main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tcin>>N;\n\trep(i,0,N)\n\t{\n\t\tcin>>OD[i];\n\t\tD[i]=OD[i];\n\t}\n\n\tsort(D,D+N);\n\n\trep(i,0,N)\n\t{\n\t\tint op=lower_bound(D,D+N,OD[i])-D;\n\t\tOP[op]=i;\n\t}\n\n\tbool ok=true;\n\trrep(i,1,N)\n\t{\n\t\tSSZ[i]++;\n\t\tint sd=D[i]-(N-SSZ[i]*2);\n\t\tint idx=lower_bound(D,D+N,sd)-D;\n\t\tif(idx==N||idx==i||D[idx]!=sd)\n\t\t{\n\t\t\tok=false;\n\t\t\tbreak;\n\t\t}\n\t\tSSZ[idx]+=SSZ[i];\n\t\tANS.push_back(mp(idx,i));\n\t\tG[idx].push_back(i);\n\t\tG[i].push_back(idx);\n\t}\n\n\tif(!ok||!func())\n\t{\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\n\tfor(auto p:ANS)\n\t{\n\t\tcout<<OP[p.first]+1<<\" \"<<OP[p.second]+1<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#define Maxn 1000008 \nusing namespace std;\ntypedef long long ll;\n\nint n,cnt;\nll d;\nint son[Maxn];\nmap <ll,int> M;\n\nstruct node{\n\tint num;\n\tll val;\n}N[Maxn];\n\nbool cmp(node a,node b){\treturn a.val > b.val;}\n\nint U[Maxn],V[Maxn];\n\nint main()\n{\n\tmemset(son,0,sizeof(son));\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\tscanf(\"%lld\",&d);\n\t\tM[d] = i;\n\t\tN[i].num = i,N[i].val = d;\n\t}\n\tsort(N+1,N+1+n,cmp);\n\tmap<ll,int>::iterator iter;;\n\tfor(int i = 1;i < n;i ++)\n\t{\n\t\tint u = N[i].num;\n\t\titer = M.find(N[i].val - n + 2 + (son[u] << 1));\n\t\tif(iter == M.end()) continue;\n\t\tint v = iter->second;\n\t\tson[v] += son[u]+1;\n\t\tU[cnt] = u,V[cnt++] = v;\n\t}\n\tif(cnt != n - 1) printf(\"-1\\n\");\n\telse\n\t\tif(son[n] == n - 1) \n\t\t\tfor(int i = 0;i < cnt;i ++)\n\t\t\t\tprintf(\"%d %d\\n\",U[i],V[i]);\n\t\telse printf(\"-1\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tif (N == 2) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tvector<long long int>v(N);\n\tmap<long long int, int>m;\n\tmap<long long int, int>used;\n\tL = LLONG_MAX;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> v[i];\n\t\tm[v[i]] = i + 1;\n\t\tL = min(L, v[i]);\n\t}\n\tvector<pair<int, int>>ans;\n\tsort(v.begin(), v.end());\n\treverse(v.begin(), v.end());\n\tfor (auto i : v) {\n\t\tif (i == L)break;\n\t//\tcout << i << endl;\n\t\tlong long int dif = N - 2 - used[i] * 2;\n\t\tlong long int box = i;\n\t\tif (m.find(box - dif) == m.end()) {\n\t\t\tcout << \"-1\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tans.push_back({ m[box],m[box - dif] });\n\t//\tcout << box << \" \" << box - dif << endl;\n\t\tused[box - dif] += used[box] + 1;\n\t\tbox -= dif;\n\t\tdif -= 2;\n\t}\n\tvector<vector<int>>edge(N + 1);\n\tfor (auto i : ans) {\n\t\tedge[i.first].push_back(i.second);\n\t\tedge[i.second].push_back(i.first);\n\t}\n\tvector<int>dis(N + 1, MOD);\n\tdis[m[L]] = 0;\n\tqueue<int>Q;\n\tQ.push(m[L]);\n\twhile (!Q.empty()) {\n\t\tint cn = Q.front(); \n\t\tQ.pop();\n\t\tfor (auto i : edge[cn]) {\n\t\t\tif (dis[i] > dis[cn] + 1) {\n\t\t\t\tdis[i] = dis[cn] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tlong long int sum = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tsum += dis[i];\n\t}\n\tif (sum != L) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tfor (auto i : ans) {\n\t\tcout << i.first << \" \" << i.second << endl;\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100005\nusing namespace std;\n\nmap<int,int>mmp;\nvector<int>g[N];\nint d[N],fa[N],pd[N],f[N],n,sz[N];\n\nvoid dfs1(int x,int s,int dep){\n\tpd[s]+=dep;\n\tfor(int i=0;i<g[x].size();++i) dfs1(g[x][i],s,dep+1);\n}\n\nvoid dfs2(int x){\n\tfor(int i=0;i<g[x].size();++i){\n\t\tpd[g[x][i]]=f[x]-2*sz[g[x][i]]+n;\n\t\tdfs2(g[x][i]);\n\t} \t\n}\n\nint main(){\n\tint x,mx=0,cnt=0,a,i;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i) scanf(\"%d\",&d[i]),f[i]=d[i],mmp[d[i]]=i;\n\tfor(i=1;i<=n;++i) sz[i]=1;\n\tsort(d+1,d+n+1);\n\tfor(i=n;i>1;--i){\n\t\ta=mmp[d[i]];\n\t\tx=d[i]-(n-sz[a])+sz[a];\n\t\tif(x>=d[i]) return printf(\"-1\")&0;\n\t\tif(!mmp[x]) return printf(\"-1\")&0;\n\t\tfa[a]=mmp[x];\n\t\tsz[mmp[x]]+=sz[a];\n\t}\n\tfor(i=1;i<=n;++i) if(fa[i]) g[fa[i]].push_back(i);\n\t//judge\n\tint y=mmp[d[1]];\n\tdfs1(y,y,0);\n\tdfs2(y);\n\tfor(i=1;i<=n;++i) if(pd[i]!=f[i]) return printf(\"-1\")&0;\n\tfor(i=1;i<=n;++i) if(fa[i]) printf(\"%d %d\\n\",fa[i],i);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n  each(x,vec) is >> x;\n  return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n  rep(i,vec.size()) {\n    if (i) os << \" \";\n    os << vec[i];\n  }\n  return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n  rep(i,vec.size()) {\n    if (i) os << endl;\n    os << vec[i];\n  }\n  return os;\n}\n\nbool solve() {\n  ll n; cin >> n;\n  vector<ll> D(n); cin >> D;\n  if (n == 2) {\n    if (D[0] != 1 || D[1] != 1) {\n      return false;\n    }\n    cout << 1 << \" \" << 2 << endl;\n    return true;\n  }\n  map<ll, set<ll>> m;\n  auto erase = [&](ll v) {\n    m[D[v]].erase(v);\n  };\n  rep(i, n) m[D[i]].insert(i);\n  vector<bool> isLeaf(n, false);\n  rep(i, n) {\n    if (m[D[i] - (n-2)].size() > 0) {\n      isLeaf[i] = true;\n    }\n  }\n  priority_queue<P, vector<P>, greater<P>> Q;\n  vector<ll> cnt(n, -1), sz(n, 1);\n  rep(i, n) if (isLeaf[i]) {\n    if (m[D[i] - (n-2)].size() != 1) return false;\n    cnt[i] = 0;\n    sz[i] = 1;\n    Q.push(P(D[i], i));\n  }\n  ll root = -1;\n  vector<P> edges;\n  vector<vector<ll>> G(n);\n  vector<bool> used(n, false);\n  while ( !Q.empty() ) {\n    P p = Q.top(); Q.pop();\n    ll v = p.second;\n    if (used[v]) continue;\n    used[v] = true;\n    // ll pd = D[v] + sz[v] - (n - sz[v]);\n    ll pd = D[v] - n + 2 * sz[v];\n    assert(m[pd].size() <= 1);\n    if (m[pd].size() == 0) {\n      used[v] = false;\n      // if (root >= 0) return false;\n      // root = v;\n      continue;\n    }\n    ll par = *m[pd].begin();\n    sz[par] += sz[v];\n    Q.push(P(D[par], par));\n    edges.eb(v, par);\n    erase(v);\n  }\n  // if (root < 0) return false;\n  if (edges.size() != n-1) return false;\n  // assert(edges.size() == n-1);\n  each(p, edges) {\n    cout << p.first+1 << \" \" << p.second+1 << endl;\n  }\n  return true;\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  if (!solve()) {\n    cout << -1 << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define ll long long\n#define N 100005\n#define M 200005\nmap<ll, int>p;\nmap<ll, int>::iterator it;\nint fat[N], siz[N], a[N], b[N], fir[N], nex[M], tar[M];\nint n, cnt;\nvoid Add(int a, int b)\n{\n\t++cnt;\n\ttar[cnt] = b;\n\tnex[cnt] = fir[a];\n\tfir[a] = cnt;\n}\nll wd[N], d[N];\nvoid Dfs(int x, int dis)\n{\n    siz[x] = 1;\n    d[1] += dis;\n\tfor (int i = fir[x]; i; i = nex[i])\n    {\n\t\tif (tar[i] != fat[x])\n\t\t{\n\t\t\tfat[tar[i]] = x;\n\t\t\tDfs(tar[i], dis + 1);\n\t\t\tsiz[x] += siz[tar[i]];\n        }\n    }\n}\nvoid Dfs(int x)\n{\n\tfor (int i = fir[x]; i; i = nex[i])\n\t{\n\t\tif (tar[i] != fat[x])\n        {\n            d[tar[i]] = d[x] + n - siz[tar[i]] * 2;\n            Dfs(tar[i]);\n        }\n    }\n}\nint Getbel(int x)\n{\n\tif (fat[x] == x)\n\t\treturn x;\n\treturn fat[x] = Getbel(fat[x]);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tscanf(\"%lld\", &wd[i]);\n\t\tp[wd[i]] = i;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tfat[i] = i;\n\t\tsiz[i] = 1;\n\t}\n\tit = p.end();\n\tfor (it--; it != p.begin(); it--)\n\t{\n\t\tif (n - siz[it -> second] * 2 == 0 || !p.count(it -> first - (n - siz[it -> second] * 2)))\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tcnt++;\n\t\ta[cnt] = it -> second;\n\t\tb[cnt] = p[it -> first - (n - siz[it -> second] * 2)];\n\t\tsiz[fat[a[cnt]] = Getbel(b[cnt])] += siz[a[cnt]];\n\t}\n\tcnt = 0;\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tAdd(a[i], b[i]);\n\t\tAdd(b[i], a[i]);\n\t}\n\tfat[1] = 0;\n\tDfs(1, 0);\n\tDfs(1);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (wd[i] != d[i])\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t    return 0;\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tprintf(\"%d %d\\n\", a[i], b[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#define Maxn 1000008 \nusing namespace std;\ntypedef long long ll;\n\nint n,cnt,tot,imp;\nint U[Maxn],V[Maxn];\nll d;\nbool vis[Maxn];\nint son[Maxn],head[Maxn];\nmap <ll,int> M;\n\nstruct node{\n\tint num;\n\tll val;\n}N[Maxn];\n\nstruct edge{\n\tint to,next;\n}E[Maxn];\n\nvoid adde(int u,int v)\n{\n\tE[tot].to = v;\n\tE[tot].next = head[u];\n\thead[u] = tot++;\n}\n\nvoid dfs(int u,int val)\n{\n\timp += val,vis[u] = 1;\n\tfor(int i = head[u];~i;i = E[i].next)\n\t{\n\t\tint v = E[i].to;\n\t\tif(vis[v]) continue;\n\t\tdfs(v,val+1);\n\t}\n}\n\nbool cmp(node a,node b){\treturn a.val > b.val;}\n\nint main()\n{\n\tmemset(vis,0,sizeof(vis));\n\tmemset(head,-1,sizeof(head));\n\tmemset(son,0,sizeof(son));\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\tscanf(\"%lld\",&d);\n\t\tM[d] = i;\n\t\tN[i].num = i,N[i].val = d;\n\t}\n\tsort(N+1,N+1+n,cmp);\n\tmap<ll,int>::iterator iter;;\n\tfor(int i = 1;i < n;i ++)\n\t{\n\t\tint u = N[i].num;\n\t\titer = M.find(N[i].val - n + 2 + (son[u] << 1));\n\t\tif(iter == M.end())\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tint v = iter->second;\n\t\tson[v] += son[u]+1;\n\t\tadde(u,v);adde(v,u);\n\t\tU[cnt] = u,V[cnt++] = v;\n\t}\n//\tdfs(N[n].num,0);\n//\tif(N[n].val != imp){\tprintf(\"-1\\n\");return 0;}\n\tfor(int i = 0;i < cnt;i ++) printf(\"%d %d\\n\",U[i],V[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef pair<int,pair<int,ll> > pii;\ntypedef vector<int> vi;\n\n#define f first\n#define s second\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for(register int i=0; i<(n); i++)\n#define Forn(i, n) for(register int i=1; i<=(n); i++)\n#define foreach(it, a) for(__typeof((a).begin()) it=(a).begin(); it!=(a).end(); it++)\n#define Foreach(it, a) for(__typeof((a).rbegin()) it=(a).rbegin(); it!=(a).rend(); it++)\n\ninline int in()\n{\n    char c=getchar();\n    int neg=1, x=0;\n    while(!isdigit(c)) (c=='-')?neg=-1, c=getchar():c=getchar();\n    while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48), c=getchar();\n    return neg*x;\n}\ninline int ex_gcd(int a, int b, int&x, int&y, int mod=1e9+7)\n{\n    if(!a)\n    {\n        x=0, y=1;\n        return b;\n    }\n    int d=ex_gcd(b%a, a, y, x);\n    x=(x-1LL*b/a*y%mod)%mod;\n    return d;\n}\ninline int lcm(int a, int b){return a*b/__gcd(a, b);}\n\nconst int MAX=1e5+5;\n\nint N, ptr, sz[MAX];\nll len[MAX], dp[MAX];\nmap<ll,int> rev;\npi ret[MAX];\npair<ll,int> dat[MAX];\n\ninline void die()\n{\n    puts(\"-1\");\n    exit(0);\n}\n\nsigned main()\n{\n    N=in();\n    Forn(i, N)\n    {\n        scanf(\"%lld\", &len[i]);\n        rev[len[i]]=i;\n        dat[i]=mp(len[i], i);\n        sz[i]=1;\n    }\n    sort(dat+1, dat+1+N);\n    \n    for(int i=N; i>1; i--)\n    {\n        int now=dat[i].s;\n        ll want=dat[i].f-N+2*sz[now];\n        if(want<0) die();\n        if(!rev.count(want)) die();\n        int par=rev[want];\n        sz[par]+=sz[now];\n        dp[par]+=dp[now]+sz[now];\n        ret[ptr++]=mp(min(par, now), max(par, now));\n    }\n    int now=dat[1].s;\n    if(dp[now]!=dat[1].f) die();\n    sort(ret, ret+ptr);\n    forn(i, ptr)\n        printf(\"%d %d\\n\", ret[i].f, ret[i].s);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n,cnt,a[111111],id[111111],w[111111],u[111111],v[111111],siz[111111];\nbool vis[111111];\nbool cmp(int x,int y){return a[x]<a[y];}\nvoid add(int x,int y){u[++cnt]=x,v[cnt]=y;}\nsigned main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]),id[i]=i,w[i]=a[i],siz[i]=1;\n\tsort(id+1,id+n+1,cmp),sort(w+1,w+n+1);\n\tfor(int i=n;i>1;i--){\n\t\tint x=2*siz[id[i]]-n+a[id[i]],pos=lower_bound(w+1,w+n+1,x)-w;\n\t\tif(w[pos]!=x)continue;\n\t\tadd(id[pos],id[i]),siz[id[pos]]+=siz[id[i]];\n\t}\n\tif(cnt!=n-1){printf(\"-1\");return 0;}\n\tfor(int i=1;i<=cnt;i++)printf(\"%d %d\\n\",u[i],v[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint N;\nll D[100005];\nll parent[100005];\nmap<ll,int> tree_sizes;\n\nmap<ll,int> D_to_old;\nint new_to_old[100005];\n\nint main() {\n        cin >> N;\n        for (int i=0; i<N; i++) {\n                cin >> D[i];\n                tree_sizes[D[i]] = 1;\n                D_to_old[D[i]] = i;\n                parent[i] = -1;\n        }\n\n        sort(D,D+N);\n\n        for (int i=0; i<N; i++) {\n                new_to_old[i] = D_to_old[D[i]];\n        }\n\n        for (int i=N-1; i>=1; i--) {\n                if (N - 2*tree_sizes[D[i]] <= 0) {\n                        cout << \"-1\\n\";\n                        return 0;\n                }\n\n                auto new_parent = tree_sizes.find(D[i] - (N - 2*tree_sizes[D[i]]));\n                if (new_parent == tree_sizes.end()) {\n                        cout << \"-1\\n\";\n                        return 0;\n                }\n\n                parent[new_to_old[i]] = D_to_old[new_parent->first];\n                new_parent->second += tree_sizes[D[i]];\n        }\n\n        for (int i=0; i<N; i++) {\n                if (parent[i] != -1) {\n                        cout << i+1 << \" \" << parent[i]+1 << endl;\n                }\n        }\n}"
  },
  {
    "language": "C++",
    "code": "\n// Problem : F - Distance Sums\n// Contest : AtCoder Regular Contest 103\n// URL : https://atcoder.jp/contests/arc103/tasks/arc103_d\n// Memory Limit : 1024 MB\n// Time Limit : 2000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\n#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\n#define cerr if(1)cerr\n#define size(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n#define temptts template <class T, class... Ts>\n\nconst int N = 1e6 + 1, mod = 1e9 + 7, inf = 2e9;\n\nstruct pp {\n\tll v;\n\tint i;\n\tbool operator < (const pp &o) const {\n\t\treturn v < o.v;\n\t}\n} d[N];\n\nmap<ll, int> id;\nint n, h[N], sz[N];\nll dp[N], D[N];\nvector<int> adj[N];\nvector<pair<int, int>> ans;\n\nvoid add(int v, int u) {\n\tans.push_back({u, v});\n\tadj[v].push_back(u);\n\tadj[u].push_back(v);\n\tsz[v] += sz[u];\n}\n\nvoid dfs_size(int v, int p = 0) {\n\tsz[v] = 1;\n\tdp[1] += h[v];\n\tfor (auto u : adj[v]) {\n\t\tif (u == p) continue;\n\t\th[u] = h[v] + 1;\n\t\tdfs_size(u, v);\n\t\tsz[v] += sz[u];\n\t}\n}\n\nvoid dfs(int v, int p = 0) {\n\tfor (auto u : adj[v]) {\n\t\tif (u == p) continue;\n\t\tdp[u] = dp[v] + n - 2 * sz[u];\n\t\tdfs(u, v);\n\t}\n\tif (dp[v] != D[v]) {\n\t\tcout << -1;\n\t\texit(0);\n\t}\n}\n\nint main() { cin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> D[i];\n\t\td[i] = {D[i], i};\n\t}\n\tsort(d + 1, d + n + 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tid[d[i].v] = i;\n\t}\n\tfor (int i = n; i >= 2; i--) {\n\t\tsz[d[i].i]++;\n\t\tll j = d[i].v - n + 2 * sz[d[i].i];\n\t\tif (!id[j] || id[j] == i) {\n\t\t\treturn cout << -1, 0;\n\t\t}\n\t\tadd(d[id[j]].i, d[i].i);\n\t}\n\tmemset(sz, 0, sizeof sz);\n\tdfs_size(1);\n\tdfs(1);\n\tfor (auto& x : ans) {\n\t\tcout << x.first << ' ' << x.second << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\n\nconst int MAXN = 1e5 + 5;\nll n, par[MAXN];\nll d, sz[MAXN];\nmap <ll, ll> mp;\n\nint main()\n{\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tvector <pair<ll,ll>> v;\n\tfor(ll i = 1; i <= n; i++){\n\t\tcin >> d; sz[i] = 1ll;\n\t\tmp[d] = i;\n\t\tv.push_back({-d, i});\n\t}\n\t/*sort(v.begin(), v.end());\n\tfor(int i = 0; i < n - 1; i++){\n\t\td = -v[i].first;\n\t\tll ind = v[i].second;\n\t\tll dpar = max(0ll, d + (2ll * sz[ind]) - (ll)n);\n\t\tif(!mp[dpar] || dpar >= d || dpar == 0ll){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tpar[ind] = mp[dpar];\n\t\tsz[par[ind]] += sz[ind];\n\t}\n\tfor(int i = 0; i < n - 1; i++){\n\t\tcout << par[v[i].second] << \" \" << v[i].second << '\\n';\n\t}*/\n\tcout << -1 << endl;\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <algorithm>\n#include <map>\n#define MN 100000\n#define MM 200000\ntypedef long long LL;\ntypedef std::map<LL,int>::iterator iter;\nint n,hd[MN+5],to[MM+5],nxt[MM+5],rn=0;\nstd::map<LL,int> mp;\nstruct node{int i,sz;LL d;}a[MN+5];\nvoid _add(int u,int v){\n\tto[rn]=v,nxt[rn]=hd[u];\n\thd[u]=rn++;\n}\nvoid add(int u,int v){_add(u,v),_add(v,u);}\nvoid gg(){puts(\"-1\");exit(0);}\nLL check(int u,int fa,int dep){\n\tLL ret=dep;\n\tfor(int i=hd[u];~i;i=nxt[i]){\n\t\tif(to[i]==fa) continue;\n\t\tret+=check(to[i],u,dep+1);\n\t}\n\treturn ret;\n}\nint main(){\n\tmemset(hd,0xff,sizeof(hd));\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i].d);\n\t\ta[i].i=i,a[i].sz=1;\n\t}\n\tstd::sort(a+1,a+1+n,[](node a,node b)->bool{return a.d>b.d;});\n\tfor(int i=1;i<=n;i++) mp[a[i].d]=i;\n\tfor(int i=1;i<=n;i++){\n\t\tint dta=n-(a[i].sz<<1);\n\t\tif(dta<=0) continue;\n\t\titer it=mp.find(a[i].d-dta);\n\t\tif(it==mp.end()) continue;\n\t\ta[it->second].sz+=a[i].sz;\n\t\tadd(a[i].i,a[it->second].i);\n\t}\n\tif(check(a[n].i,0,0)!=a[n].d) gg();\n\tif(rn!=(n-1)<<1) gg();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=hd[i];~j;j=nxt[j])\n\t\t\tif(i<to[j]) printf(\"%d %d\\n\",i,to[j]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define eb emplace_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nvoid fuk() { puts(\"-1\"); exit(0); }\n\nconst int MAXN = 100055;\n\nmap<ll, int> MP;\n\nvector<pii> EV;\n\nll A[MAXN];\nint B[MAXN], C[MAXN], dep[MAXN];\n\nint N;\n\nint main() {\n\tios::sync_with_stdio(false);\n\n\tcin >> N;\n\tfor(int i = 1; i <= N; i++) {\n\t\tcin >> A[i];\n\t\tMP[A[i]] = i;\n\t}\n\n\tiota(B, B+N+1, 0); sort(B+1, B+N+1, [&](int a, int b) {\n\t\treturn A[a] < A[b];\n\t});\n\n\tfill(C+1, C+N+1, 1);\n\tfor(int oi = N, i; oi > 1; oi--) {\n\t\ti = B[oi];\n\t\tll t = A[i] - N + C[i]*2;\n\t\tauto it = MP.find(t);\n\t\tif(MP.end() == it) fuk();\n\t\tint p = it -> second;\n\t\tif(p == i) fuk();\n\t\tC[p] += C[i];\n\t\tEV.eb(p, i);\n\t}\n\n\t{\n\t\treverse(EV.begin(), EV.end());\n\t\tfor(auto &e : EV)\n\t\t\tdep[e.second] = dep[e.first] + 1;\n\n\t\tll sum = 0;\n\t\tfor(int i = 1; i <= N; i++) sum += dep[i];\n\t\tif(sum != A[B[1]]) fuk();\n\t}\n\n\tfor(auto &e : EV) printf(\"%d %d\\n\", e.first, e.second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nmap<int,int> M1,M2;\nint s1[200010],pa[200010];\nstruct edge\n{\n\tint v,next;\n}vs[200010];\nint st[200010],ee,sz[200010],vis[20010];\ninline void addedge(int u,int v)\n{\n\tvs[++ee].v=v;vs[ee].next=st[u];st[u]=ee;\n}\t\ninline void dfs(int rt,int pr)\n{\n\tvis[rt]=1; sz[rt]=1;\n\tfor(int i=st[rt];i;i=vs[i].next)\n\t\tif(vs[i].v!=pr) dfs(vs[i].v,rt),sz[rt]+=sz[vs[i].v];\n}\nsigned main()\n{\n\tint n=read();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=read();\n\t\tM1[x]=i; M2[x]=1;\n\t\ts1[i]=x;\n\t}\n\tsort(s1+1,s1+1+n);\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tint id=M1[s1[i]],sz=M2[s1[i]],td=s1[i]+2*sz-n;\t\n\t\tif(td>=s1[i]) continue;\t\n\t\tpa[id]=M1[td]; M2[td]+=sz;\n\t}\n\tint rt=0;\n\tfor(int i=1;i<=n;i++) \n\t{\n\t\tif(pa[i]) addedge(pa[i],i),addedge(i,pa[i]);\n\t\telse \n\t\t{\n\t\t\tif(rt) puts(\"-1\"),exit(0);\n\t\t\telse rt=i;\n\t\t}\n\t}\n\tdfs(rt,0);\n\tif(sz[rt]!=n) puts(\"-1\"),exit(0);\n\telse\n\t{ \n\t\tfor(int i=1;i<=n;i++)\n\t\tif(pa[i]) printf(\"%lld %lld\\n\",i,pa[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n这是Task F,但是网址是 d 。。。 \n*/\n#include<vector>\n#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define N 100010\n#define int long long\n#define debug cout<<__LINE__<<\" \"<<__FUNCTION__<<\"\\n\"\n\ninline int read(){\n    int x=0,y=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')y=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}\n    return x*y;\n}\nvoid put(int x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>=10) put(x/10);\n    putchar((x%10)+48);\n}\nint n,a[N],id[N],siz[N],fa[N];\ninline int find(int x){\n\treturn x==fa[x]?x:fa[x]=find(fa[x]);\n}\ninline int cmp(const int&A,const int&B){\n\treturn a[A]<a[B];\n}\nvector<int> l[N];\nint dfs(int x){\n//\tcout<<x<<\"       ljsn\\n\";\n\tint num=siz[x]-1;\n\tfor(int i=0;i<l[x].size();i++) num+=dfs(l[x][i]);\n\treturn num;\n}\nsigned main(){\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tn=read();\n\tfor(int i=1;i<=n;i++){\n\t\ta[i]=read();id[i]=fa[i]=i;siz[i]=1;\n\t}\n\tsort(id+1,id+n+1,cmp);sort(a+1,a+n+1);\n\tint root=0;\n\tfor(int i=n,pos,fx;i>=1;i--){\n\t\tfx=find(i);\n\t\tpos=lower_bound(a+1,a+n+1,a[i]-n+2*siz[i])-a;\n\t\twhile(pos<=n&&fx==find(pos)) ++pos;\n\t\tif(a[pos]!=a[i]-n+2*siz[i]){\n//\t\t\tcout<<root<<\"\\n\";\n\t\t\tif(!root){\n\t\t\t\troot=i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[pos]+=siz[i];\n\t\tl[pos].push_back(i);\n\t\tfa[fx]=find(pos);\n//\t\tcerr<<i<<\"\\n\";\n\t}\n//\tcout<<root<<\"\\n\";\n\tint res=dfs(root);\n//\tcout<<res<<\" \"<<a[root]<<\"\\n\";\n\tif(res!=a[root]){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<l[i].size();j++) cout<<id[i]<<\" \"<<id[l[i][j]]<<\"\\n\";\n\t}\n//\tfclose(stdin);\n//\tfclose(stdout);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int N;\n    cin >> N;\n\n    set<array<ll, 3>> pieces;\n\n    vll ds(N);\n    for (int i = 0; i < N; i++) {\n        cin >> ds[i];\n        pieces.insert({ ds[i], 1, i });\n    }\n\n    vector<pair<int, int>> edges;\n    while (pieces.size() > 1) {\n        auto p = *pieces.rbegin();\n        pieces.erase(p);\n\n        ll match = p[0] + 2 * p[1] - N;\n        auto qi = pieces.lower_bound({ match, -1, -1 });\n        if (qi == pieces.end() || (*qi)[0] != match) {\n            cout << -1 << endl;\n            return 0;\n        }\n        auto q = *qi;\n\n        edges.emplace_back(p[2], q[2]);\n        array<ll, 3> comb = { q[0], p[1] + q[1], q[2] };\n\n        pieces.erase(q);\n        pieces.insert(comb);\n    }\n\n    for (auto p : edges) {\n        cout << p.first + 1 << \" \" << p.second + 1 << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n    > File Name: D.cpp\n    > Author: PumpkinYing\n    > Created Time: 2018/11/9 15:51:37\n ************************************************************************/\n\n#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <stack>\n#include <cmath>\nusing namespace std;\n\n#define mem(a,b) memset(a,b,sizeof(a))\n#define prii pair<int,int>\n#define prdd pair<double,double>\n#define rep(i,l,r) for(int i = l;i < r;i++)\n#define rep_(i,l,r) for(int i = l;i <= r;i++)\ntypedef long long ll;\n\nconst int maxn = 1000010;\nmap<ll,int> mp;\nint sz[maxn];\n\nstruct Node {\n\tll d;\n\tint id;\n\tvoid read(int i) {\n\t\tid = i;\n\t\tscanf(\"%lld\",&d);\n\t}\n\tbool operator < (const Node& b) const {\n\t\treturn d > b.d;\n\t}\n}ns[maxn];\n\nint fa[maxn],vis[maxn];\n\nint main() {\n\tint n;\n\tscanf(\"%d\",&n);\n\trep_(i,1,n) {\n\t\tns[i].read(i);\n\t\tmp[ns[i].d] = i;\n\t\tsz[i] = 1;\n\t}\n\tsort(ns+1,ns+1+n);\n\tint ok = 1;\n\trep_(i,1,n-1) {\n\t\tint id = ns[i].id;\n\t\tvis[id] = 1;\n\t\tll val = ns[i].d+sz[id]-(n-sz[id]);\n\t\tif(mp[val] == 0 || vis[mp[val]]) {\n\t\t\tok = 0;\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tfa[id] = mp[val];\n\t\t\tsz[mp[val]] += sz[id];\n\t\t}\n\t}\n\tif(ok == 0) printf(\"-1\\n\");\n\telse rep_(i,1,n) if(fa[i] != 0) printf(\"%d %d\\n\",i,fa[i]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, a, b) for(int i = a;i < b;i++)\n#define For(i, a) FOR(i, 0, a)\n#define REV(i, a, b) for(int i = b-1;i >= a;i--)\n#define Rev(i, a) REV(i, 0, a)\n#define REP(a) For(i, a)\n#define DEBUG_PRINT(...) fprintf(stderr, __VA_ARGS__)\n#ifdef ENABLE_DEBUG\n#define DEBUG(a) cerr<<#a<<\"=\"<<a<<endl\n#define DEBUG_ARRAY(a,n) cerr<<#a<<\"[\"<<n<<\"]=\"<<a[n]<<endl\n#else\n#define DEBUG(a) \n#define DEBUG_ARRAY(a,n) \n#endif\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\nvoid print_pair(pi a){\n  cerr<<\"(\"<<a.first<<\", \"<<a.second<<\") \";\n}\ntemplate<int T1, int T2>\nvoid print_2d(int a[T1][T2], int x, int y){\n  For(i, x){\n    For(j, y){\n      cerr<<a[i][j]<<\" \";\n    }\n    cerr<<endl;\n  }\n}\ntemplate<class T>\nvoid print_array(T a[],size_t n){\n  cerr<<\"array:\";\n  REP(n-1)cerr<<a[i]<<\",\";\n  cerr<<a[n-1]<<endl;\n}\n\nint N;\npll D[100000];\nll d[100000];\nint childnumD[100000];\nvector<ll> ans[100000];\nll dfs(ll index,ll depth){\n  ll ret = 0;\n  DEBUG(index);\n  for(auto&& i : ans[index])\n  {\n    DEBUG(i);\n    ret+=depth+1;\n    ret+=dfs(i,depth+1);\n  }\n  return ret;\n}\nint main(){\n  cin>>N;\n  REP(N){\n    ll tmp;\n    cin>>tmp;\n    D[i]=pll(tmp,i+1);\n  }\n  sort(D,D+N,greater<pll>());\n  REP(N){\n    d[i]=D[i].first;\n    DEBUG(d[i]);\n  }\n  for (int i = 0; i < N-1; i++) {\n    ll tmp=d[i]-(N-2)+2*childnumD[i];\n    DEBUG(tmp);\n      auto itr=lower_bound(d,d+N,tmp,greater<ll>());\n      DEBUG(*itr);\n      if(itr==d+N||*itr!=tmp){\n        cout<<-1<<endl;\n        return 0;\n      }\n      ans[itr-d].push_back(i);\n      childnumD[itr-d]++;\n      childnumD[itr-d]+=childnumD[i];\n  }\n  if(dfs(N-1,0)!=d[N-1]){\n    DEBUG(dfs(N-1,0));\n    cout<<-1<<endl;\n    return 0;\n  }\n  For(j,N){\n    DEBUG(j);\n  for(auto&& i : ans[j])\n  {\n    DEBUG(i);\n    cout<<D[j].second<<\" \"<<D[i].second<<endl;\n  }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing nagai = long long;\nusing ll = long long;\n\nconst int N = 1e6 + 100;\nvector<int> g[N];\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n    int n;\n    cin >> n;\n    vector<nagai> d(n);\n    for (auto& x : d)\n        cin >> x;\n    vector<int> ord(n);\n    iota(ord.begin(), ord.end(), 0);\n    sort(ord.begin(), ord.end(), [&](int a, int b)\n            {\n             return d[a] > d[b];\n            });\n    map<nagai, int> mp;\n    for (int i = 0; i < n; ++i)\n        mp[d[i]] = i;\n    vector<int> sz(n, 1);\n    vector<pair<int, int>> edg;\n    vector<bool> used(n);\n    ord.pop_back();\n    for (int x : ord)\n    {\n        used[x] = true;\n        nagai dp = d[x] + sz[x] - (n - sz[x]);\n        if (!mp.count(dp) || used[mp[dp]])\n        {\n             cout << -1 << '\\n';\n             return 0;\n        }\n        edg.emplace_back(mp[dp], x);\n        sz[mp[dp]] += sz[x];\n    }\n    for (auto& p : edg)\n    {\n        int x = p.first, y = p.second;\n        g[x].push_back(y), g[y].push_back(x);\n    }\n    vector<nagai> d1(n, -1);\n    d1[0] = 0;\n    vector<int> q = {0};\n    for (int i = 0; i < q.size(); ++i)\n    {\n         int x = q[i];\n         for (int y : g[x])\n             if (d1[y] == -1)\n                 d1[y] = d1[x] + 1, q.emplace_back(y);\n    }\n    if (d[0] != accumulate(d1.begin(), d1.end(), 0LL))\n    {\n        cout << -1 << '\\n';\n        return 0;\n    }\n    for (auto& x : edg)\n        cout << x.first + 1 << ' ' << x.second + 1 << '\\n';\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <map>\n\ntypedef long long ll;\nconst int N = 1e5 + 51;\nstruct edge {\n\tint to, next;\n} e[N << 1];\nint head[N], cnt;\nvoid addedge(int x, int y) {\n\te[++cnt] = (edge){y, x[head]}, x[head] = cnt;\n\te[++cnt] = (edge){x, y[head]}, y[head] = cnt;\n}\nvoid dfs(int x, int p) {\n\tfor (int i = x[head], nx; i; i = e[i].next)\n\t\tif ((nx = e[i].to) != p) printf(\"%d %d\\n\", x, nx), dfs(nx, x);\n}\n\nstd::map<ll, int> mp;\nint n, sz[N];\nll a[N];\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", a + i), i[sz] = 1, mp[a[i]] = i;\n\tstd::sort(a + 1, a + n + 1, std::greater<ll>());\n\tfor (int i = 1; i < n; i++) {\n\t\tint x = mp[a[i]], nx;\n\t\tll tmp = a[i] - n + 2 * x[sz];\n\t\tif (tmp == a[i] || !mp.count(tmp)) return puts(\"-1\"), 0;\n\t\tnx = mp[tmp];\n\t\tnx[sz] += x[sz];\n\t\taddedge(x, nx);\n\t}\n\tdfs(1, 0);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tif (N == 2) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tvector<long long int>v(N);\n\tmap<long long int, int>m;\n\tmap<long long int, int>used;\n\tL = LLONG_MAX;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> v[i];\n\t\tm[v[i]] = i + 1;\n\t\tL = min(L, v[i]);\n\t}\n\tvector<pair<int, int>>ans;\n\tsort(v.begin(), v.end());\n\treverse(v.begin(), v.end());\n\tfor (auto i : v) {\n\t\tlong long int dif = N - 2;\n\t\tlong long int box = i;\n\t\twhile (box > L) {\n\t\t\tif (used[box])break;\n\t\t\tif (m.find(box - dif) == m.end()) {\n\t\t\t\tcout << \"-1\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tans.push_back({ m[box],m[box - dif] });\n\t\t\t//cout << m[box] << \" \" << m[box - dif] << endl;\n\t\t\tused[box]++;\n\t\t\tbox -= dif;\n\t\t\tdif -= 2;\n\t\t}\n\t}\n\tvector<vector<int>>edge(N + 1);\n\tfor (auto i : ans) {\n\t\tedge[i.first].push_back(i.second);\n\t\tedge[i.second].push_back(i.first);\n\t}\n\tvector<int>dis(N + 1, MOD);\n\tdis[m[L]] = 0;\n\tqueue<int>Q;\n\tQ.push(m[L]);\n\twhile (!Q.empty()) {\n\t\tint cn = Q.front(); \n\t\tQ.pop();\n\t\tfor (auto i : edge[cn]) {\n\t\t\tif (dis[i] > dis[cn] + 1) {\n\t\t\t\tdis[i] = dis[cn] + 1;\n\t\t\t\tQ.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tlong long int sum = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tsum += dis[i];\n\t}\n\tif (sum != L) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tfor (auto i : ans) {\n\t\tcout << i.first << \" \" << i.second << endl;\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#define rep(i,l,r) for (int i=(l); i<=(r); i++)\ntypedef long long ll;\nusing namespace std;\n\nconst int N=100010;\npair<long long,int> p[N];\nint n,s[N];\nll S[N];\nvector< pair<int,int> > ans;\n\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n) scanf(\"%lld\",&p[i].first),p[i].second=i,s[i]=1;\n\tsort(p+1,p+n+1);\n\tfor(int i=n; i>1; --i){\n\t\tif (n-2*s[i]<0) { puts(\"-1\"); return 0; }\n\t\tint x=lower_bound(p+1,p+n+1,make_pair(p[i].first-n+2*s[i],0))-p;\n\t\tif(p[x].first!=p[i].first-n+2*s[i]) { puts(\"-1\"); return 0; }\n\t\ts[x]+=s[i]; S[x]+=S[i]+s[i]; ans.push_back(make_pair(p[x].second,p[i].second));\n\t}\n\tif (S[1]!=p[1].first) { puts(\"-1\"); return 0; }\n\tfor(int i=0; i<(int)ans.size(); ++i) printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nint n;\nmap<ll, pair<int, int> > st;\nvector<pair<int, int> > edge;\n\nint main()\n{\n\tread(n);\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tll d;\n\t\tread(d);\n\t\tst.insert(make_pair(d, make_pair(1, i)));\n\t}\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tauto x = *st.rbegin();\n\t\tst.erase(--st.end());\n\t\tint y = x.first-(n-x.second.first)+x.second.first;\n\t\tauto it = st.find(y);\n\t\tif(it == st.end()) {printf(\"-1\\n\"); return 0;}\n\t\telse it->second.first += x.second.first, edge.emplace_back(x.second.second, it->second.second);\n\t}\n\tfor(auto i : edge) printf(\"%d %d\\n\", i.first, i.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 100003\nusing namespace std;\nstruct edge{int to,next;}e[maxn<<1];\nint head[maxn],cnte,fa[maxn];\nvoid add(int u,int v){e[++cnte].to=v,e[cnte].next=head[u],head[u]=cnte;}\nint n,sz[maxn],chksz[maxn],s[maxn];\nlong long d[maxn],chksum[maxn];\nmap<long long,int> b;\nbool cmp(int x,int y){return d[x]<d[y];}\nvoid dfs(int u){\n\tchksz[u]=1;\n\tfor(int i=head[u];i;i=e[i].next){\n\t\tint v=e[i].to;\n\t\tif(v==fa[u])continue;\n\t\tdfs(v);\n\t\tchksz[u]+=chksz[v];\n\t\tchksum[u]+=chksum[v]+sz[v];\n\t}\n\tif(chksz[u]!=sz[u]){puts(\"-1\");exit(0);}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",d+i),s[i]=i;\n\tsort(s+1,s+n+1,cmp);\n\tfor(int i=1;i<=n;i++)b[d[i]]=i,sz[i]=1;\n\tfor(int i=n;i>=2;i--){\n\t\tint v=s[i],d_u=d[v]-(n-sz[v])+sz[v];\n\t\tif(d_u>=d[v]||!b.count(d_u)){puts(\"-1\");return 0;}\n\t\tint u=b[d_u];\n\t\tadd(u,v),add(v,u),fa[v]=u;\n\t\tsz[u]+=sz[v];\n\t}\n\tif(cnte!=(n-1)*2){puts(\"-1\");return 0;}\n\tdfs(s[1]);\n\tif(chksz[s[1]]!=n||chksum[s[1]]!=d[s[1]]){puts(\"-1\");return 0;}\n\tfor(int u=1;u<=n;u++){\n\t\tfor(int i=head[u];i;i=e[i].next){\n\t\t\tint v=e[i].to;\n\t\t\tif(v==fa[u])continue;\n\t\t\tprintf(\"%d %d\\n\",u,v);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define eb emplace_back\n#define fi first\n#define se second\nusing namespace std;\nusing cd = complex <double>;\n\nconst long long INF = 1e18; \nconst long long mod = 998244353;//200003;786433;1e9 + 7;\nconst double Pi = acos(-1);\n  \nvoid Fastio()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n}\n\nint n;\nint root;\nlong long mindis = INF;\nlong long d[100005], sz[100005];\nmap <long long, int> M; \nvector <pair <int, int> > Edge;\nvector <int> Adj[100005];\n\nsigned main()\n{\n\tFastio();\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tcin >> d[i];\n\t\tsz[i] = 1;\n\t\tM[d[i]] = i;\n\t\tif(d[i] < mindis)\n\t\t{\n\t\t\troot = i;\n\t\t\tmindis = d[i];\n\t\t}\n\t}\n\twhile(M.size() > 1)\n\t{\n\t\tpair <long long, int> temp = *(prev(M.end()));\n\t\tlong long realdis = temp.fi - n + sz[temp.se] * 2;\n\t\tif(M.count(realdis) == false)\n\t\t{\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\tEdge.eb(temp.se, M[realdis]);\n\t\tsz[M[realdis]] += sz[temp.se];\n\t\tM.erase(temp.fi);\n\t}\n\tif(Edge.size() != n - 1 || sz[root] != n)\n\t{\n\t\tcout << \"-1\";\n\t\treturn 0;\n\t}\n\tfor(auto x : Edge)\n\t{\n\t\tcout << x.fi << ' ' << x.se << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define lli long long int\nconst int N=100005;\nstruct D{int w,x,s;}d[N];int n,he[N],to[N],nx[N];\nbool cmp(D x,D y){return x.x>y.x;}\ninline void wk(int w,int x,int y)\n{to[w]=y,nx[w]=he[x],he[x]=w;}\nint dfs(int x,int y)\n{\n\tint z=y;\n\tfor(int i=he[x];i;i=nx[i])\n\t\tz+=dfs(to[i],y+1);\n\treturn z;\n}\nsigned main()\n{\n\tscanf(\"%lld\",&n);\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(\"%lld\",&d[i].x),d[i].w=i,d[i].s=1;\n\tstd::sort(d+1,d+n+1,cmp);\n\tfor(int i=1,x,l,r,I;i<n;++i)\n\t{\n\t\tfor(x=0,l=i+1,r=n;l<=r;)\n\t\t\tI=l+r>>1,d[I].x>=d[i].x+2*d[i].s-n?(x=I,l=I+1):(r=I-1);\n\t\tif(!x||d[x].x!=d[i].x+2*d[i].s-n)return 0&printf(\"-1\");\n\t\td[x].s+=d[i].s,wk(i,d[x].w,d[i].w);\n\t}\n\tif(dfs(d[n].w,0)!=d[n].x)return 0&printf(\"-1\");\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=he[i];j;j=nx[j])\n\t\t\tprintf(\"%lld %lld\\n\",i,to[j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+5;\nint n,f[N],si[N];\nstruct node\n{\n    ll x;\n    int id;\n    bool operator<(const node&o)const\n    {\n        return x<o.x;\n    }\n}a[N];\nunordered_map<ll,int>mp;\nvector<pair<int,int> >v;\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%lld\",&a[i].x),a[i].id=i;\n    sort(a+1,a+1+n);\n    for(int i=1;i<=n;i++) si[i]=1,f[i]=a[i].id,mp[a[i].x]=i;\n    for(int i=n;i>=1;i--)\n    {\n        ll t=a[i].x+si[i]-(n-si[i]);\n        if(mp[t]&&mp[t]!=i) v.push_back({i,mp[t]}),si[mp[t]]+=si[i];\n    }\n    if(si[1]!=n) printf(\"-1\\n\");\n    else for(int i=0;i<v.size();i++)\n        printf(\"%d %d\\n\",f[v[i].first],f[v[i].second]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<iostream>\n#include<algorithm>\n#define maxn 100050\nusing namespace std;\ntypedef long long LL;\n\nint n;\nLL D[maxn];\n\nint pos[maxn];\n\nLL size[maxn];\n\nmap<LL,int> mp;\n\nvoid init()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tpos[i]=i;\n\t\tscanf(\"%lld\",&D[i]); \n\t\tmp[D[i]]=i;\n\t}\n}\n\nint fa[maxn];\n\nbool vis[maxn];\n\nbool cmp(int i,int j)\n{\n\treturn D[i]>D[j];\n}\n\nint find(LL x)\n{\n\treturn mp.count(x)?mp[x]:0;\n}\n\nbool solve()\n{\n\tsort(pos+1,pos+n+1,cmp);\n\tfor (int k=1;k<n;++k)\n\t{\n\t\t\n\t\tint i=pos[k],j=find(D[i]+2LL*++size[i]-n);\n\t\tvis[i]=1;\n//\t\tcout<<i<<\" \"<<j<<\" \"<<D[i]+2LL*size[i]-n<<endl;\n\t\tif (!j||vis[j])\n\t\t\treturn 0;\n\t\tfa[i]=j;\n\t\tsize[j]+=size[i];\n\t}\n\t\n//\tputs(\"YES\");\n\tfor (int k=1;k<=n;++k)\n\t{\n\t\tint u=pos[k];\n\t\tif (fa[u])\n\t\t\tprintf(\"%d %d\\n\",u,fa[u]);\n\t}\n\treturn 1;\n}\n\nint main()\n{\n//    freopen(\"c.in\",\"r\",stdin);\n//    freopen(\"c.out\",\"w\",stdout);\n    init();\n    if (!solve())\n    \tprintf(\"-1\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\n\nconst int MAX_N = 1e5 + 5;\nint n, root;\nlong long Arr[MAX_N];\nint h[MAX_N];\nint Siz[MAX_N];\nint Mark[MAX_N];\nint par[MAX_N];\nunordered_map <long long, int> Map;\nvector <pii> edge;\nint dp_d[MAX_N];\nint dp_u[MAX_N];\nvector <int> child[MAX_N];\n\nbool cmp(int a, int b) {\n\treturn Arr[b] < Arr[a];\n}\n\nvoid dfs1(int v) {\n\tfor (int i = 0; i < child[v].size(); i++) {\n\t\tdfs1(child[v][i]);\n\t\tdp_d[v] += dp_d[child[v][i]] + Siz[child[v][i]];\n\t}\n}\n\nvoid dfs2(int v, int val) {\n\tdp_u[v] = val;\n\tfor (int i = 0; i < child[v].size(); i++)\n\t\tdfs2(child[v][i], dp_d[v] + dp_u[v] - dp_d[child[v][i]] - Siz[child[v][i]] + (n - Siz[child[v][i]]));\n}\n\nint main() {\n\tios::sync_with_stdio(false), cout.tie(0), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> Arr[i];\n\t\tSiz[i] = 1;\n\t\th[i] = i;\n\t\tMap[Arr[i]] = i;\n\t}\n\t\t\n\tsort(h, h + n, cmp);\n\t\n\tfor (int i = 0; i + 1 < n; i++) {\n\t\tint v = h[i];\n\t\tlong long tmp = Arr[v] + Siz[v] - (n - Siz[v]);\n\n\t\tif (tmp < 0 || (Map[tmp] == 0 && Arr[0] != tmp)) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint u = Map[tmp];\n\t\tif (Mark[u]) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tSiz[u] += Siz[v];\n\t\tpar[v] = u;\n\t\tedge.push_back({v, u});\n\t\tchild[u].push_back(v);\n\t}\n\troot = h[n - 1];\n\tdfs1(root);\n\tdfs2(root, 0);\n\t\n\tfor (int i = 0; i < n; i++)\n\t\tif (dp_d[i] + dp_u[i] != Arr[i]) {\n\t\t\tcout << i << \" \" << dp_d[i] + dp_u[i] << \"\\n\";\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\n\tfor (int i = 0; i + 1 < n; i++)\n\t\tcout << edge[i].first + 1 << \" \" << edge[i].second + 1 << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n/*#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"fast-math\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,popcnt,abm,mmx,tune=native\")*/\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stdio.h>\n#include <cstdio>\n#include <math.h>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <deque>\n#include <random>\n#include <iomanip>\n#include <bitset>\n                      \nusing namespace std;\n                      \ntemplate<typename T> void uin(T &a, T b) {\n    if (b < a) {\n        a = b;\n    }\n}\n                      \ntemplate<typename T> void uax(T &a, T b) {\n    if (b > a) {\n        a = b;\n    }\n}\n\n#define int long long\n#define ghost signed\n#define left left228\n#define right right228\n#define prev prev228\n#define list list228\n\nconst int N = 100 * 1000 + 228;\n\nint n;\nint d[N], sz[N];\nmap<int, int> pos; \nvector<int> g[N];\n\nbool cmp(int i, int j) {\n\treturn d[i] > d[j];\n}\n\nint D[N], S[N];\nint sumd = 0;\nbool OK = 1;\n\nvoid jfs(int v, int par = -1) {\n\tS[v] = 1;\n\tfor (int to : g[v]) {\n\t\tif (to == par) continue;\n\t\tjfs(to, v);\n\t\tS[v] += S[to];\n\t}\n}\n\nvoid bfs(int a) {\n\tfor (int i = 1; i <= n; ++i) D[i] = n * 100;\n\tD[a] = 0;\n\tvector<int> q;\n\tq.push_back(a);\n\tfor (int i = 0; i < (int)q.size(); ++i) {\n\t\tint v = q[i];\n\t\tfor (int to : g[v]) {\n\t\t\tif (D[v] + 1 < D[to]) {\n\t\t\t\tD[to] = D[v] + 1;\n\t\t\t\tq.push_back(to);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) sumd += D[i];\n\tjfs(1);\n}\n\nvoid dfs(int v, int par = -1) {\n\tif (v != 1) {\n\t\tsumd -= S[v];\n\t\tsumd += (n - S[v]);\n\t}\n\tif (sumd != d[v]) OK = 0;\n\tfor (int to : g[v]){\n\t\tif (to == par) continue;\n\t\tdfs(to, v);\n\t}\n\tif (v != 1) {\n\t\tsumd += S[v];\n\t\tsumd -= (n - S[v]);\n\t}\n}\n\nbool check() {\n\tbfs(1);\n\tdfs(1);\n\treturn OK;\n}\n\nghost main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> d[i];\n\t\tpos[d[i]] = i;\n\t}\n\tvector<int> order;\n\tfor (int i = 1; i <= n; ++i) order.push_back(i);\n\tfor (int i = 1; i <= n; ++i) sz[i] = 1;\n\tsort(order.begin(), order.end(), cmp);\n\tvector< pair<int, int> > e;\n\tint last = order.back();\n\tfor (int v : order) {\n\t\tif (v == last) break;\n\t\tint nd = d[v] + 2 * sz[v] - n;\n\t\tif (nd <= v) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint par = pos[nd];\n\t\tif (par == 0) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\te.push_back(make_pair(par, v));\n\t\tg[par].push_back(v);\n\t\tg[v].push_back(par);\n\t\tsz[par] += sz[v];\n\t}\n\tif (!check()) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tfor (auto p : e) cout << p.first << \" \" << p.second << '\\n';\n\treturn 0;\n} // kek ;\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, cnt[100005];\nlong long d[100005];\npair<long long, int> p[100005];\nvector<int> to[100005];\nint ta;\nlong long tb;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%lld\", &p[i].first);\n\t\tp[i].second = i + 1;\n\t\tcnt[i] = 1;\n\t}\n\tsort(p, p + n);\n\tfor (int i = n - 1; i; i--) {\n\t\ttb = p[i].first - n + 2 * cnt[i];\n\t\tta = lower_bound(p, p + i, make_pair(tb, 0)) - p;\n\t\tif (p[ta].first != tb) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\td[ta] += d[i] + cnt[i];\n\t\tto[ta].push_back(i);\n\t\tcnt[ta] += cnt[i];\n\t}\n\tif (d[0] != p[0].first) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j : to[i])\n\t\t\tprintf(\"%d %d\\n\", p[i].second, p[j].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long h[100009];\nlong long sz[100009];\nlong long f[100009];\nlong long D[100009];\nvector<long long> v[100009];\nmap<long long,long long> M;\nvoid dfs(long long x, long long de){\n    f[x] = 1;\n    h[x] = de;\n    for(long long i = 0; i < v[x].size(); i++){\n        if(!f[v[x][i]]) dfs(v[x][i], de + 1);\n    }\n}\nmain(){\n    long long n;\n    cin >> n;\n    for(long long i = 1; i <= n; i++){\n        cin >> D[i];\n        M[D[i]] = i;\n        sz[i] = 1;\n    }\n    long long t = D[1];\n    sort(D + 1, D + n + 1);\n    for(long long i= n; i >= 2; i--){\n        long long k = M[D[i]];\n        long long diff = n - 2 * sz[k];\n        if(diff <= 0 || !M[D[i] - diff]){\n            cout << -1 << endl;\n            return 0;\n        }\n \n        v[k].push_back(M[D[i]-diff]);\n        v[M[D[i] - diff]].push_back(k);\n        sz[M[D[i] - diff]] += sz[k];\n \n    }\n \n    dfs(1,0);\n    long long S = 0;\n    for(long long i = 1; i <= n; i++){\n        S += h[i];\n    }\n    if(S == t){\n        for(long long i = 1; i <= n; i++){\n            for(long long j = 0; j < v[i].size(); j++){\n                if(i < v[i][j]){\n                    cout<<i<<\" \"<<v[i][j]<<endl;\n                }\n            }\n        }\n    }\n    else{\n        cout<< -1 << endl;\n        return 0;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> d(n);\n  for(Int i=0;i<n;i++) cin>>d[i];\n  map<Int, Int> r;\n  for(Int i=0;i<n;i++) r[d[i]]=i;\n\n  vector<vector<Int> > G(n);\n  auto NO=[](){cout<<-1<<endl;exit(0);};\n  auto add_edge=[&](Int x,Int y){\n\t\t  G[x].emplace_back(y);\n\t\t  G[y].emplace_back(x);\n\t\t};\n\n  using P = pair<Int, Int>;\n  priority_queue<P> pq;\n  vector<Int> s(n,1),used(n,0);\n  for(Int i=0;i<n;i++) pq.emplace(d[i],i);\n  \n  while(pq.size()>1u){\n    Int x,v;\n    tie(x,v)=pq.top();pq.pop();\n    \n    Int nd=x-(n-s[v])+s[v];\n    if(!r.count(nd)) NO();\n    \n    Int u=r[nd];    \n    if(used[u]) NO();\n    \n    add_edge(v,u);\n    s[u]+=s[v];    \n    used[v]=1;\n  }\n\n  vector<Int> sz(n,1),dp(n,0);\n  function<Int(Int, Int)> dfs=\n    [&](Int v,Int p){\n      for(Int u:G[v]){\n\tif(u==p) continue;\n\tdp[v]+=dfs(u,v);\n\tdp[v]+=sz[u];\n\tsz[v]+=sz[u];\n      }\n      return dp[v];\n    };\n  \n  if(d[0]!=dfs(0,-1)) NO();\n  \n  for(Int v=0;v<n;v++)\n    for(Int u:G[v]) if(v<u) cout<<v+1<<\" \"<<u+1<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<iomanip>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<string>\n#include<utility>\n#include<cmath>\n#include<algorithm>\n#include<cctype>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stack>\n#include<ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vpii;\ntypedef vector<pli> vpli;\n\ninline ll read(){\n    ll Hashimoto=0;\n\tbool Kanna=1;\n    char I_Love=getchar();\n    while(I_Love<'0'||I_Love>'9'){\n        if(I_Love=='-')Kanna=0;\n        I_Love=getchar();\n    }\n    while(I_Love>='0'&&I_Love<='9'){\n        Hashimoto=Hashimoto*10+I_Love-'0';\n        I_Love=getchar();\n    }\n    return (Kanna?Hashimoto:-Hashimoto);\n}\ntemplate<typename T1,typename T2> inline void Umax(T1 &a,T2 b){\n\tif(a<b)a=b;\n}\ntemplate<typename T1,typename T2> inline void Umin(T1 &a,T2 b){\n\tif(a>b)a=b;\n}\n\n#define I_Love_Hashimoto_Kanna main\n#define fastio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define filein(s) freopen(s,\"r\",stdin);\n#define fileout(s) freopen(s,\"w\",stdout);\n#define file freopen(\"I_Love_Hashimoto_Kanna.out\",\"w\",stdout);\n#define RE cout<<\"I_Love_Hashimoto_Kanna\"<<endl;\n#define Tone(Kanna) cout<<Kanna<<endl;\n#define Tall(Hashimoto,Kanna) for(int I_Love=0;I_Love<(Kanna);++I_Love)cout<<Hashimoto[I_Love]<<(I_Love==(Kanna)-1?\"\\n\":\" \");\n#define FOR(I_Love,Hashimoto,Kanna) for(int I_Love=Hashimoto;I_Love<(Kanna);++I_Love)\n#define MP(Hashimoto,Kanna) make_pair(Hashimoto,Kanna)\n#define REV(Kanna) reverse(Kanna.begin(),Kanna.end());\n#define SORT(Kanna) sort(Kanna.begin(),Kanna.end());\n#define UNIQUE(Kanna) Kanna.erase(unique(Kanna.begin(),Kanna.end()),Kanna.end());\n#define inf (int)1e9\n#define linf (ll)1e18\n#define mod (inf+7)\n\nint n;\npli a[111111];\nint s[111111];\nint f[111111];\n\nint I_Love_Hashimoto_Kanna() {\n\t//完全想清楚了再开始写。\n\t//写不顺、不知道怎么写、很乱的时候，停下来好好想想。\n\t//做得慢总比做不出好。\n\tfastio;\n\tn=read();\n\tFOR(i,0,n){\n\t\ta[i]={read(),i};\n\t\ts[i]=1;\n\t}\n\tsort(a,a+n);\n\tfor(int i=n-1;i>0;--i){\n\t\tint j=lower_bound(a,a+n,MP(a[i].first-(n-s[i]-s[i]),-1))-a;\n\t\tif(i==j||a[j].first!=a[i].first-(n-s[i]-s[i])){\n\t\t\tTone(-1);\n\t\t\treturn 0;\n\t\t}\n\t\tf[i]=j;\n\t\ts[j]+=s[i];\n\t}\n\tFOR(i,1,n){\n\t\tprintf(\"%d %d\\n\",a[i].second+1,a[f[i]].second+1);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// comment\n// 가장 큰게 리프였다는 사실을 알았으면 해볼만 했을지도..\n// 가장 작은 값을 기준으로 트리를 만들면 밑으로 갈수록 점점 증가한다라는 사실을 인지하는 능력?\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define SZ(v) ((int)(v).size())\n#define ALL(v) (v).begin(),(v).end()\n#define one first\n#define two second\nusing ll = long long;\nusing pi = pair<int, int>;\nusing pli = pair<ll, int>;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 1ll * INF * INF;\n\nconst int MAX_N = 1e5 + 100;\n\nint N, Ix[MAX_N];\nll Ds[MAX_N];\nint S[MAX_N];\n\nint findD(ll d) {\n\tint ix = lower_bound(Ds+1, Ds+N+1, d) - Ds;\n\tif(Ds[ix] == d) return ix;\n\treturn -1;\n}\n\nint Vis[MAX_N];\nvector<int> Ed[MAX_N];\n\nint main() {\n\tcin >> N;\n\tvector<pli> temp;\n\tfor(int i=1; i<=N; i++) {\n\t\tscanf(\"%lld\", &Ds[i]);\n\t\ttemp.emplace_back(Ds[i], i);\n\t}\n\tsort(Ds+1, Ds+N+1);\n\tsort(ALL(temp));\n\tfor(int i=0; i<N; i++) Ix[i+1] = temp[i].two;\n\tfor(int i=1; i<=N; i++) S[i] = 1;\n\t\n\tvector<pi> Ans;\n\t//for(int i=1; i<=N; i++) printf(\"%lld \", Ds[i]); puts(\"\");\n\tfor(int i=N; i>=2; i--) {\n\t\tll pd = Ds[i] + 2*S[i] - N;\n\t\tint ix = findD(pd);\n\t\t//printf(\"%lld [%lld + 2*%d - %d] %d\\n\", pd, Ds[i], S[i], N, ix);\n\t\tif(ix == -1 || ix == i) return puts(\"-1\") < 0;\n\t\tS[ix] += S[i];\n\t\tAns.emplace_back(Ix[ix], Ix[i]);\n\t\tEd[Ix[ix]].push_back(Ix[i]);\n\t\tEd[Ix[i]].push_back(Ix[ix]);\n\t}\n\n\tll real = 0;\n\tqueue<int> Q;\n\tint root = Ix[1];\n\tVis[root] = 1; Q.push(root);\n\twhile(!Q.empty()) {\n\t\tint v = Q.front(); Q.pop();\n\t\tfor(int w: Ed[v]) if(Vis[w] == 0) {\n\t\t\tVis[w] = Vis[v] + 1;\n\t\t\tQ.push(w);\n\t\t}\n\t}\n\tint all = 0;\n\tfor(int i=1; i<=N; i++) if(Vis[i] != 0) {\n\t\tall++;\n\t\treal += Vis[i] - 1;\n\t}\n\tif(all != N || real != Ds[1]) return puts(\"-1\") < 0;\n\n\n\tfor(auto p: Ans) {\n\t\tint x, y; tie(x, y) = p;\n\t\tprintf(\"%d %d\\n\", x, y);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+5;\nint n,f[N],si[N];\nstruct node\n{\n    ll x;\n    int id;\n    bool operator<(const node&o)const\n    {\n        return x<o.x;\n    }\n}a[N];\nunordered_map<ll,int>mp;\nvector<pair<int,int> >v;\nint tot,fa[N],head[N],nex[N<<1],to[N<<1];\nvoid add(int u,int v){to[++tot]=v;nex[tot]=head[u];head[u]=tot;}\nll dis[N];\nvoid dfs(int u,int p)\n{\n    fa[u]=p;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==p) continue;\n        dfs(v,u);\n        dis[u]+=dis[v]+si[v];\n    }\n}\nbool dfs(int u)\n{\n    if(a[u].x!=dis[u]) return false;\n    for(int i=head[u];i;i=nex[i])\n    {\n        int v=to[i];if(v==fa[u]) continue;\n        dis[v]=dis[u]-si[v]+(n-si[v]);\n        if(!dfs(v)) return false;\n    }\n    return true;\n}\nbool check()\n{\n    if(v.size()!=n-1) return false;\n    for(int i=0;i<v.size();i++)\n        add(v[i].first,v[i].second),add(v[i].second,v[i].first);\n    dfs(1,0);\n    return dfs(1);\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%lld\",&a[i].x),a[i].id=i;\n    sort(a+1,a+1+n);\n    for(int i=1;i<=n;i++) si[i]=1,f[i]=a[i].id,mp[a[i].x]=i;\n    for(int i=n;i>1;i--)\n    {\n        ll t=a[i].x+si[i]-(n-si[i]);\n        if(mp[t]&&mp[t]<i) v.push_back({i,mp[t]}),si[mp[t]]+=si[i];\n    }\n    if(si[1]!=n||!check()) {printf(\"-1\\n\");return 0;}\n    else for(int i=0;i<v.size();i++)\n        printf(\"%d %d\\n\",f[v[i].first],f[v[i].second]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tif (N == 2) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tvector<long long int>v(N);\n\tmap<long long int, int>m;\n\tmap<long long int, int>used;\n\tL = LLONG_MAX;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> v[i];\n\t\tm[v[i]] = i + 1;\n\t\tL = min(L, v[i]);\n\t}\n\tvector<pair<int, int>>ans;\n\tsort(v.begin(), v.end());\n\treverse(v.begin(), v.end());\n\tfor (auto i : v) {\n\t\tlong long int dif = N - 2;\n\t\tlong long int box = i;\n\t\twhile (box > L) {\n\t\t\tif (used[box])break;\n\t\t\tif (m.find(box - dif) == m.end()) {\n\t\t\t\tcout << \"-1\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tans.push_back({ m[box],m[box - dif] });\n\t\t\t//cout << m[box] << \" \" << m[box - dif] << endl;\n\t\t\tused[box]++;\n\t\t\tbox -= dif;\n\t\t\tdif -= 2;\n\t\t}\n\t}\n\tfor (auto i : ans) {\n\t\tcout << i.first << \" \" << i.second << endl;\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//ここから編集する\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N;\n    cin >> N;\n\n    vector<ll> D(N);\n    map<ll, int> Dtov;\n    rep(i, 0, N) cin >> D[i];\n    rep(i, 0, N) Dtov[D[i]] = i + 1;\n\n    sort(D.rbegin(), D.rend());\n    vector<vector<int> > G(N + 1, vector<int>());\n    vector<bool> used(D.size(), false);\n    vector<pair<int, int>> ans;\n\n    for (int i = 0; i < N - 1; ++i) {\n        if (!used[i]) {\n            used[i] = true;\n\n//            for (int k = N - 2; k > 0; k -= 2) {\n//                if (find(all(D), D[i] - k) == D.end()) {\n//                    cout << -1 << endl;\n//                    return 0;\n//                } else {\n//                    ans.emplace_back(Dtov[D[i]], Dtov[D[i] - k]);\n//                }\n//            }\n            ll tmp = D[i];\n            ll dec = N - 2;\n            while (tmp > D.back() && dec > 0) {\n                if (find(all(D), tmp - dec) == D.end()) {\n                    cout << -1 << endl;\n                    return 0;\n                } else {\n                    ans.emplace_back(Dtov[tmp], Dtov[tmp - dec]);\n                    G[Dtov[tmp - dec]].push_back(Dtov[tmp]);\n\n//                    used[Dtov[tmp - dec]] = true;\n                    used[find(all(D), tmp - dec) - D.begin()] = true;\n                    tmp -= dec;\n                    dec -= 2;\n                }\n            }\n        }\n    }\n\n    function<ll(int, int)> treesize = [&](int v, int dist) {\n        ll ret = dist;\n        for (auto e: G[v]) {\n            ret += treesize(e, dist + 1);\n        }\n        return ret;\n    };\n\n    ll min_tree_size = treesize(Dtov[D.back()],0);\n    if (min_tree_size != D.back()) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    for (auto e : ans) {\n        cout << e.first << \" \" << e.second << endl;\n//        cout << e.second << \" \" << e.first << endl;\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\n#define llint long long\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nllint N;\nllint d[100005];\nP D[100005];\nvector<llint> G[100005];\nmap<llint, vector<P> > mp;\n\nint main(void)\n{\n\tcin >> N;\n\tfor(int i = 1; i <= N; i++) cin >> d[i];\n\tfor(llint i = 1; i <= N; i++) D[i] = make_pair(d[i], i);\n\tsort(D+1, D+N+1);\n\treverse(D+1, D+N+1);\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tif(mp.count(D[i].first) == 0){\n\t\t\tllint p = D[i].first+N-2;\n\t\t\tif(p > D[i].first) continue;\n\t\t\tmp[p].push_back(make_pair(D[i].second, 1));\n\t\t}\n\t\telse{\n\t\t\tllint x = 0;\n\t\t\tfor(int j = 0; j < mp[D[i].first].size(); j++){\n\t\t\t\tG[D[i].second].push_back(mp[D[i].first][j].first);\n\t\t\t\tG[mp[D[i].first][j].first].push_back(D[i].second);\n\t\t\t\tx += mp[D[i].first][j].second;\n\t\t\t}\n\t\t\tx++;\n\t\t\tllint p = D[i].first+N-2*x;\n\t\t\tif(p > D[i].first) continue;\n\t\t\tmp[p].push_back(make_pair(D[i].second, x));\n\t\t}\n\t}\n\tvector<P> ans;\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\tif(G[i][j] > i) ans.push_back(make_pair(i, G[i][j]));\n\t\t}\n\t}\n\tif(ans.size() < N-1) cout << \"-1\" << endl;\n\telse{\n\t\tfor(int i = 0; i < ans.size(); i++) cout << ans[i].first << \" \" << ans[i].second << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n    > File Name: D.cpp\n    > Author: PumpkinYing\n    > Created Time: 2018/11/9 15:51:37\n ************************************************************************/\n\n#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <stack>\n#include <cmath>\nusing namespace std;\n\n#define mem(a,b) memset(a,b,sizeof(a))\n#define prii pair<int,int>\n#define prdd pair<double,double>\n#define rep(i,l,r) for(int i = l;i < r;i++)\n#define rep_(i,l,r) for(int i = l;i <= r;i++)\ntypedef long long ll;\n\nconst int maxn = 1000010;\nmap<ll,int> mp;\nint sz[maxn];\n\nstruct Node {\n\tll d;\n\tint id;\n\tvoid read(int i) {\n\t\tid = i;\n\t\tscanf(\"%I64d\",&d);\n\t}\n\tbool operator < (const Node& b) const {\n\t\treturn d > b.d;\n\t}\n}ns[maxn];\n\nint fa[maxn],vis[maxn];\n\nint main() {\n\tint n;\n\tscanf(\"%d\",&n);\n\trep_(i,1,n) {\n\t\tns[i].read(i);\n\t\tmp[ns[i].d] = i;\n\t\tsz[i] = 1;\n\t}\n\tsort(ns+1,ns+1+n);\n\tint ok = 1;\n\trep_(i,1,n-1) {\n\t\tint id = ns[i].id;\n\t\tvis[id] = 1;\n\t\tll val = ns[i].d+sz[id]-(n-sz[id]);\n\t\tif(mp[val] == 0 || vis[mp[val]]) {\n\t\t\tok = 0;\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tfa[id] = mp[val];\n\t\t\tsz[mp[val]] += sz[id];\n\t\t}\n\t}\n\tif(ok == 0) printf(\"-1\\n\");\n\telse rep_(i,1,n) if(fa[i] != 0) printf(\"%d %d\\n\",i,fa[i]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<long long int>v(N);\n\tM = LLONG_MAX;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> v[i];\n\t\tif (v[i] > N*(N = 1) / 2) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tM = min(M, v[i]);\n\t}\n\tint box = 0;\n\tmap<long long int, int>m;\n\tfor (int i = 0; i < N; i++) {\n\t\tm[v[i] - M] = i;\n\t}\n\tvector<pair<int, int>>ans;\n\twhile (m.size() > 1) {\n\t\tauto  box = *m.rbegin();\n\t\tlong long int c = box.first;\n\t\tint cn = box.second;\n\t//\tcout << c << \" \" << cn << endl;\n\t\tlong long int a, b = 0;\n\t\tfor (long long int i = c / (N - 1) + !!(c % (N - 1)); i <= sqrt(c); i++) {\n\t\t\tif (c%i)continue;\n\t\t\ta = i;\n\t\t\tb = c / i;\n\t\t\tlong long int st = (b  - (a - 1));\n\t\t\tlong long int add = st;\n\t\t//\tcout << a << \" \" << b << \" \" << st << \" \" << add << endl;\n\t\t\tbool flag = true;\n\t\t\twhile (st < c) {\n\t\t\t\tif (m.find(st) == m.end()) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tadd += 2;\n\t\t\t\tst += add;\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tst = (b - (a - 1));\n\t\t\t\tadd = st;\n\t\t\t\tint bef = m[0];\n\t\t\t\twhile (st <= c) {\n\t\t\t//\t\tcout << st << endl;\n\t\t\t\t\tans.push_back({ bef,m[st] });\n\t\t\t\t\tbef = m[st];\n\t\t\t\t\tm.erase(st);\n\t\t\t\t\tadd += 2;\n\t\t\t\t\tst += add;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto i : ans) {\n\t\tcout << i.first + 1 << \" \" << i.second + 1 << endl;\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define int long long\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par, size_;\npublic:\n    UnionFind(){}\n    UnionFind(int node_size) : sz(node_size), par(sz), size_(sz, 1){\n        iota(par.begin(), par.end(), 0);\n    }\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n    void unite(int x,int y){\n        x = find(x), y = find(y);\n        if(x == y) return;\n        if(size_[x] < size_[y]) swap(x,y);\n        par[y] = x;\n        size_[x] += size_[y];\n    }\n    int size(int x){\n        x = find(x);\n        return size_[x];\n    }\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n};\n\nsigned main(){\n    int n;\n    cin >> n;\n    UnionFind uf(n+1);\n    vector<pair<int,int> > v;\n    map<int,int> p;\n    rep(i,n){\n        int d;\n        cin >> d;\n        p[d] = i+1;\n        v.push_back(MP(d,i+1));\n    }\n    sort(v.begin(),v.end(),greater<pair<int,int> >());\n    map<int,int> mp;\n    vector<pair<int,int> > g;\n    bool ng = 1;\n    rep(i,n){\n        int k = v[i].first;\n        int u = v[i].second;\n        int c = mp[k];\n        c++;\n        //cerr << k << \" \" << u << \" \" << c << endl;\n        if(c==n&&i==n-1){\n            ng = 0;\n            continue;\n        }\n        int nxt = k - (n-c-c);\n        if(p.find(nxt)==p.end()){\n            cout << -1 << endl;\n            return 0;\n        }\n        mp[nxt]+=c;\n        g.push_back(MP(u,p[nxt]));\n        uf.unite(u,p[nxt]);\n    }\n    for(int i=1;i<=n;i++){\n        if(!uf.same(i,1)){\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n    if(ng){\n        cout << -1 << endl;\n        return 0;\n    }\n    for(auto x:g){\n        cout << x.first << \" \" << x.second << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define str string\n#define fi first\n#define se second\n#define pb push_back\n#define SET(a, b) memset(a, b, sizeof(a))\n#define eps 1e-6\n#define pi atan(1) * 4\n#define mod 1000000007\n#define inf 1000000000\n#define llinf 1000000000000000000\n#define FOR(i, a, b, c) for (int i = (a); i <= (b); i += (c))\n#define FORD(i, a, b, c) for (int i = (a); i >= (b); i -= (c))\n#define FORl(i, a, b, c) for (ll i = (a); i <= (b); i += (c))\n#define FORDl(i, a, b, c) for (ll i = (a); i >= (b); i -= (c))\nusing namespace std;\nint n;\nmap<ll, ll> inp;\npll order[100005];\nint sze[100005];\n\nvector<int> edges[100005];\nint sub[100005];\nint dep[100005];\nll dfs (int u, int p) {\n\tll s = dep[u];\n\tint sz = 1;\n\tfor (auto v : edges[u]) {\n\t\tif (v == p) continue;\n\t\tdep[v] = dep[u] + 1;\n\t\ts += dfs(v, u);\n\t\tsz += sub[v];\n\t}\n\tsub[u] = sz;\n\treturn s;\n}\nll pos[100005];\nint it = 0;\nvoid dfs2 (int u, int p, ll sd) {\n\tpos[++it] = sd;\n\tfor (auto v : edges[u]) {\n\t\tif (v == p) continue;\n\t\tdfs2(v, u, sd - sub[v] + (n - sub[v]));\n\t}\n}\nint main () {\n\tscanf(\"%d\", &n);\n\tFOR(i, 1, n, 1) {\n\t\tll t;\n\t\tscanf(\"%lld\", &t);\n\t\torder[i] = {t, i};\n\t\tinp[t] = i;\n\t\tsze[i] = 1;\n\t}\n\tsort(order + 1, order + n + 1);\n\tvector<pii> elist;\n\tFORD(i, n, 2, 1) {\n\t\tauto u = order[i];\n\t\tint s = sze[u.se];\n\t\tll nd = u.fi - (n - sze[u.se]) + sze[u.se];\n\t\tif (nd > u.fi || inp.find(nd) == inp.end() || inp[nd] == u.se) {\n\t\t\tprintf(\"-1\\n\"); return 0;\n\t\t}\n\t\tint v = inp[nd];\n\t\telist.pb({u.se, v});\n\t\tedges[u.se].pb(v); edges[v].pb(u.se);\n\t\tsze[v] += sze[u.se];\n\t}\n\n\tdep[1] = 0;\n\tll sumd = dfs(1, -1);\n\tdfs2(1, -1, sumd);\n\tsort(pos + 1, pos + n + 1);\n\tFOR(i, 1, n, 1) {\n\t\tif (order[i].fi != pos[i]) {\n\t\t\tprintf(\"-1\\n\"); return 0;\n\t\t}\n\t}\n\n\tfor (auto e : elist) {\n\t\tprintf(\"%d %d\\n\", e.fi, e.se);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//ここから編集する\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N;\n    cin >> N;\n\n    vector<ll> D(N);\n    map<ll, int> Dtov;\n    rep(i, 0, N) cin >> D[i];\n    rep(i, 0, N) Dtov[D[i]] = i + 1;\n\n    sort(D.rbegin(), D.rend());\n\n    vector<vector<int> > G(N + 1, vector<int>());//自分の親\n    vector<vector<int> > rG(N + 1, vector<int>());//自分の子供\n    vector<int> childs(N + 1, 1); //部分木の数\n\n    for (int i = 0; i < N - 1; ++i) {\n//        ll dec = N - 2 * (1 + rG[Dtov[D[i]]].size());\n        ll dec = N - 2 * childs[Dtov[D[i]]];\n//        if (find(all(D), D[i] - dec) == D.end()) {\n//            cout << -1 << endl;\n//            return 0;\n//        }\n\n        if (*lower_bound(all(D), D[i] - dec) == D[i] - dec) {\n            cout << -1 << endl;\n            return 0;\n        }\n\n        G[Dtov[D[i]]].push_back(Dtov[D[i] - dec]);\n        rG[Dtov[D[i] - dec]].push_back(Dtov[D[i]]);\n        childs[Dtov[D[i] - dec]] += childs[Dtov[D[i]]];\n    }\n\n    function<ll(int, int)> treesize = [&](int v, int dist) {\n        ll ret = dist;\n\n        for (auto e : rG[v]) {\n            ret += treesize(e, dist + 1);\n        }\n\n        return ret;\n    };\n\n    ll min_tree_size = treesize(Dtov[D.back()], 0);\n    if (min_tree_size != D.back()) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    for (int i = 1; i <= N; ++i) {\n        for (auto e : G[i]) {\n            cout << i << \" \" << e << endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e5 + 10;\n\nint D[N],id[N],Sz[N];\nstruct node {\n\tint x,y;\n}G[N];\nmap <ll,int> Map,Id;\n\ninline ll read() {\n\tll x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-')ch = getchar();\n\tif(ch == '-')flag = -1,ch = getchar();\n\twhile(isdigit(ch))x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\nint main() {\n\n\tint n = read();\n\tFor(i,1,n) Map[D[i] = read()] = i,Sz[i] = 1;\n\tsort(D + 1,D + n + 1,greater<int>());\n\tFor(i,1,n) Id[D[i]] = i;\n\n\tFor(i,1,n - 1) {\n\t\tint Pre = D[i] + Sz[i] * 2 - n,val = Id[Pre];\n\t\tif(val <= i) return puts(\"-1\"),-1;\n\t\tSz[val] += Sz[i];\n\t\tG[i] = (node){Map[D[i]],Map[D[val]]};\n\t}\n\n\tFor(i,1,n - 1) printf(\"%d %d\\n\",G[i].x,G[i].y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nconst int N = 100010;\ntypedef long long int64;\n \nmap<int64 , int> val;\nint n , size[N] , fa[N];\n \nint64 d[N];\ntypedef pair<int64 , int> pii;\npriority_queue<pii> leaf;\n#define mp make_pair \n \nint main() {\n    cin >> n;\n    for(int i = 1 ; i <= n ; ++i) {\n        cin >> d[i];\n        size[i] = 1;\n        val[d[i]] = i; \n    }\n    for(int i = 1 ; i <= n ; ++i) leaf.push(mp(d[i] , i));\n\t\n\tint64 root = 0;\n    while(leaf.size()) {\n        int x = leaf.top().second;\n        leaf.pop();\n \n\t\tval.erase(d[x]);\n        if(val.count(d[x] - n + size[x]*2))\n            fa[x] = val[d[x] - n + size[x]*2];\n        else break;\n        \n        size[fa[x]] += size[x];\n        root += size[x];\n    }\n \n    for(int i = 1 , cnt = 0; i <= n ; ++i) {\n    \tif(fa[i] == 0 && (++cnt > 1 || d[i] != root))  {cout << -1 << endl; return 0;}\n\t}\n    for(int i = 1 ; i <= n ; ++i)\n        if(fa[i]) cout << i << ' ' << fa[i] << endl;\n\t\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <time.h>\n\n#include <stdlib.h>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <vector>\n#include <map>\nusing namespace std;\nstruct condition{\n\tint32_t vertex;\n\tint64_t total;\n};\nstruct current{\n\tint32_t parent;\n\tint32_t vertex_num;\n};\nstruct edge{\n\tint32_t v1;\n\tint32_t v2;\n};\nbool operator< (const condition& a,const condition& b){\n\treturn a.total>b.total;\n}\nint main() {\n\n\tint32_t n;\n\tcin>>n;\n\tstd::vector<condition> cd;\n\tvector<edge> ans;\n\tans.reserve(n);\n\tcd.reserve(n);\n\tfor(int i=0;i<n;i++){\n\t\tint64_t temp;\n\t\tcin>>temp;\n\t\tcd.push_back(condition{i+1,temp});\n\t}\n\tbool ans_possible=true;\n\tsort(cd.begin(),cd.end());\n\tmap<int64_t,vector<current> > flow;\n\tfor(auto i=cd.begin();i!=cd.end();i++){\n\t\tint32_t sum_vertex=0;\n\n\t\tif(flow.count(i->total)){\n\t\t\tvector<current>& t=flow.at(i->total);\n\t\t\tint64_t total_cost=0;\n\t\t\tfor(auto k=t.begin();k!=t.end();k++){\n\t\t\t\tans.push_back(edge{k->parent,i->vertex});\n\t\t\t\tsum_vertex+=(k->vertex_num);\n\t\t\t\ttotal_cost+=((k->vertex_num)*(k->vertex_num+1))/2;\n\t\t\t}\n\t\t\tans_possible=(total_cost==i->total);\n\n\t\t\tflow.erase(i->total);\n\t\t}else{\n\t\t\tans_possible=false;\n\t\t}\n\n\t\tsum_vertex++;\n\n\t\tint32_t parent_value=i->total-(n-2*sum_vertex);\n\t\tif(flow.count(parent_value)){\n\t\t\tflow.at(parent_value).push_back(current{i->vertex,sum_vertex});\n\t\t}else{\n\t\t\tvector<current> temp2;\n\t\t\ttemp2.push_back(current{i->vertex,sum_vertex});\n\t\t\tflow.emplace(parent_value,temp2);\n\t\t}\n\n\t}\n\tif(flow.size()==1&&ans_possible){\n\t\tfor(auto i=ans.begin();i!=ans.end();i++){\n\t\t\tcout<<i->v1<<\" \"<<i->v2<<endl;\n\t\t}\n\t}else{\n\t\tcout<<-1<<endl;\n\t}\n\n\n\n\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline int read()\n{\n\tint x = 0, f = 1; char c = getchar();\n\twhile (!isdigit(c)) {if (c == '-') f = -1; c = getchar();}\n\twhile (isdigit(c)) {x = x * 10 + c - '0', c = getchar();}\n\treturn x * f;\n}\n\nconst int MAXN = 1e5 + 10;\nint n, seq[MAXN], sz[MAXN], root;\nvector<int> linker[MAXN];\nll D[MAXN], f[MAXN], g[MAXN];\n\ninline bool cmp(const int &a, const int &b) {return D[a] < D[b];}\n\nvoid dfs(int x, int fa)\n{\n\tf[x] = 0;\n\tfor (int i = 0; i < linker[x].size(); i ++)\n\t{\n\t\tint cur = linker[x][i];\n\t\tif (cur == fa) continue;\n\t\tdfs(cur, x), f[x] += f[cur] + sz[cur];\n\t}\n}\n\nvoid dfs2(int x, int fa)\n{\n\tif (x == root) g[x] = 0;\n\telse g[x] = g[fa] + n - sz[x] + f[fa] - f[x] - sz[x];\n\tfor (int i = 0; i < linker[x].size(); i ++)\n\t{\n\t\tint cur = linker[x][i];\n\t\tif (cur == fa) continue;\n\t\tdfs2(cur, x);\n\t}\n}\n\ninline bool check()\n{\n\tdfs(root, 0), dfs2(root, 0);\n//\tfor (int i = 1; i <= n; i ++)\n//\t\tprintf(\"(%d, %d), \", f[i], g[i]);\n//\tputs(\"\");\n\tfor (int i = 1; i <= n; i ++)\n\t\tif (f[i] + g[i] != D[i]) return 0;\n\treturn 1;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tn = read();\n\tfor (int i = 1; i <= n; i ++) D[i] = read(), seq[i] = i, sz[i] = 1;\n\tsort(seq + 1, seq + 1 + n, cmp), root = seq[1];\n\tfor (int i = n; i > 1; i --)\n\t{\n\t\tint now = seq[i];\n\t\tint l = 1, r = i - 1, pos = -1;\n\t\tll need = D[now] + 2 * sz[now] - n;\n\t\twhile (l <= r)\n\t\t{\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tif (D[seq[mid]] == need)\n\t\t\t{\n\t\t\t\tpos = seq[mid];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (D[seq[mid]] > need) r = mid - 1;\n\t\t\telse l = mid + 1;\n\t\t}\n//\t\tprintf(\"%d (%d, %d, %d, %d)\\n\", i, now, pos, sz[now], need);\n\t\tif (pos == -1) return puts(\"-1\"), 0;\n\t\tlinker[pos].push_back(now), sz[pos] += sz[now];\n\t}\n\tif (check())\n\t{\n\t\tfor (int i = 1; i <= n; i ++)\n\t\t{\n\t\t\tfor (int j = 0; j < linker[i].size(); j ++)\n\t\t\t{\n\t\t\t\tint to = linker[i][j];\n\t\t\t\tprintf(\"%d %d\\n\", i, to);\n\t\t\t}\n\t\t}\n\t}\n\telse puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef pair<ll, int> pli;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst int MN = 100010;\n\nint N;\nll D[MN];\nint sz[MN];\nvi g[MN];\nll val[MN];\n\nll sum;\n\nint dfs(int v, int p) {\n\tint t = 1;\n\tfor (int to : g[v]) if (to != p) {\n\t\tint num = dfs(to, v);\n\t\tsum += (ll)num * (N - num);\n\t\tt += num;\n\t}\n\treturn t;\n}\n\nint main() {\n\tcin >> N;\n\n\tmap<ll, int> T;\n\trep(i, N) {\n\t\tcin >> D[i];\n\t\tsz[i] = 1;\n\t\tT[D[i]] = i;\n\t}\n\n\tvector<pii> es;\n\n\trep(tt, N - 1) {\n\t\tauto it = T.end(); --it;\n\n\t\tint v = it->se;\n\t\tll d = it->fi;\n\t\tll up = d - (N - sz[v] * 2);\n\n\t\tT.erase(d);\n\n\t\tif (!T.count(up)) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tint p = T[up];\n\t\tg[p].pb(v);\n\t\tg[v].pb(p);\n\t\tes.eb(v, p);\n\t\tsz[p] += sz[v];\n\t}\n\n\tdfs(0, -1);\n\tll s = 0;\n\trep(i, N) s += D[i];\n\n\tif (s != sum * 2) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\n\trep(i, N-1) {\n\t\tprintf(\"%d %d\\n\", es[i].fi + 1, es[i].se + 1);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#include <cmath>\n#include <complex>\n// #include \"utiltime.hpp\"\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef complex<double> cdouble;\n\nconst int INFL = (int)1e9;\nconst ll INFLL = (ll)1e18;\nconst double INFD = numeric_limits<double>::infinity();\nconst double PI = 3.14159265358979323846;\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loopll(i, n) for(ll i = 0; i < (ll)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopll1(i, n) for(ll i = 1; i <= (ll)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = (ll)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define Looprll1(i, n) for(ll i = (ll)n; i >= 1; i--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(i, vector.size()) { cout << vector[i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(i, matrix.size()) { Loop(j, matrix[i].size()) { cout << matrix[i][j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define readfile(filename) ifstream in(filename); cin.rdbuf(in.rdbuf());\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\nbool nearlyeq(double x, double y) { return abs(x - y) < 1e6; }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(double x) { ll m = (ll)sqrt(x); return m + (m * m <= (ll)(x) ? 0 : -1); }\nll ceilsqrt(double x) { ll m = (ll)sqrt(x); return m + ((ll)x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\n\n/*******************************************************/\n\nvoid failed() {\n\tcout << -1 << endl;\n\texit(0);\n}\n\nint main() {\n\tquickio();\n\tint n; cin >> n;\n\tvector<Pll> a(n);\n\tLoop(i, n) {\n\t\tcin >> a[i].first;\n\t\ta[i].second = i;\n\t}\n\tsort(a.begin(), a.end());\n\tvll subtree_cnt(n, 0);\n\tvector<Pll> ans;\n\tLoopr1(i, n - 1) {\n\t\tint target_val = a[i].first + subtree_cnt[i] * 2 - n + 2;\n\t\tauto itr = lower_bound(a.begin(), a.end(), P({ target_val, 0 }));\n\t\tif (itr == a.end()) failed();\n\t\tif (itr - a.begin() == a.size() - 1) failed();\n\t\tif (itr->first != target_val) failed();\n\t\tsubtree_cnt[itr - a.begin()] += subtree_cnt[i] + 1;\n\t\tans.push_back({ a[i].second + 1, a[itr - a.begin()].second + 1 });\n\t\ta.pop_back();\n\t\tsubtree_cnt.pop_back();\n\t}\n\tLoop(i, ans.size()) {\n\t\tcout << ans[i].first << \" \" << ans[i].second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define maxn 1000005\n#define inf 1e9\n#define eps 1e-10\nusing namespace std;\n\ninline ll read()\n{\n\tll x=0,w=1; char c=getchar();\n\twhile(c<'0'||c>'9') {if(c=='-') w=-1; c=getchar();}\n\twhile(c<='9'&&c>='0') {x=(x<<1)+(x<<3)+c-'0'; c=getchar();}\n\treturn w==1?x:-x;\n}\n\nll n,d[maxn],siz[maxn],f;\nmap <ll,int> p;\nvector <int> a1,a2;\n\ninline bool cmp(ll a,ll b){return a>b;}\n\nint main()\n{\n\tn=read(); f=0;\n\tfor(int i=1;i<=n;i++) d[i]=read(),p[d[i]]=i;\n\tsort(d+1,d+n+1,cmp);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tsiz[p[d[i]]]++;\n\t\tll dfa=d[i]-n+2*siz[p[d[i]]];\n\t\tif(dfa>d[i]) continue;\n\t\tsiz[p[dfa]]+=siz[p[d[i]]];\n\t\t//cout<<d[i]<<\" \"<<p[d[i]]<<\" \"<<siz[p[d[i]]]<<\" \"<<dfa<<endl;\n\t\tif(p[dfa]==0) {f=1; break;}\n\t\ta1.push_back(p[d[i]]),a2.push_back(p[dfa]);\n\t}\n\tif(f==1) {puts(\"-1\"); return 0;}\n\tfor(int i=0;i<a1.size();i++) printf(\"%d %d\\n\",a1[i],a2[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct Info{int nu,we;}a[1000010];\nstruct edg{int x,y;}an[1000010];\nint n,si[1000010];\nbool c=true;\nbool comp(const Info &a,const Info &b){return a.nu>b.nu;}\nint find(int x){\n\tint l=1,r=n,mid;\n\twhile (l+1<r){\n\t\tmid=(l+r)/2;\n\t\tif (a[mid].nu<x) r=mid;else l=mid;\n\t}\n\tif (a[r].nu==x) return r;\n\tif (a[l].nu==x) return l;\n\treturn 0;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++){scanf(\"%d\",&a[i].nu);a[i].we=i;}\n\tsort(a+1,a+n+1,comp);\n\tfor (int i=1;i<=n;i++) si[i]=1;\n\tfor (int i=1;i<n;i++){\n\t\tint p=a[i].nu-n+si[i]*2;\n\t\tint x=find(p);\n\t\tif (x==0) c=false;\n\t\telse{\n\t\t\tsi[x]+=si[i];\n\t\t\tan[i].x=a[i].we;an[i].y=a[x].we;\n\t\t}\n\t}\n\tif (c){\n\t\tfor (int i=1;i<n;i++) cout<<an[i].x<<' '<<an[i].y<<endl;\n\t}else{\n\t\tcout<<\"-1\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\n\ntypedef long long ll;\ntypedef pair<ll, int> pi;\n\nmap<ll, int> mp;\nconst int maxn = 1e5 + 5;\nint sz[maxn];\nvector<int> G[maxn];\n\nint main(){\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    cin >> n;\n    priority_queue<pi> pq;\n    for(int i = 1;i <= n;i++){\n        ll d;\n        cin >> d;\n        mp[d] = i;\n        pq.push({d, i});\n        sz[i] = 1;\n    }\n    bool flag = true;\n    while(!pq.empty()){\n        pi p = pq.top(); pq.pop();\n        ll dis = p.first;\n        int id = p.second;\n        ll dis1 = dis - (n - 2 * sz[id]);\n        if(mp.find(dis1) == mp.end()){\n            flag = false;\n            break;\n        }else{\n            int fa = mp[dis1];\n            if(fa == id){\n                flag = false;\n                break;\n            }\n            G[fa].push_back(id);\n            sz[fa] += sz[id];\n        }\n    }\n    if(flag){\n        for(int i = 1;i <= n;i++){\n            for(auto v : G[i]){\n                cout << i << \" \" << v << endl;\n            }\n        }\n    }else{\n        cout << -1 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int N=1e5+10;\nstruct Data{\n\tint id;\n\tll val;\n\tfriend bool operator < (Data x,Data y){return x.val<y.val;}\n}d[N];\nll sz[N];\nll fa[N];\nint n,m;\nint find(int val){\n\tint l=1,r=n,ret=-1,mid;\n\twhile (l<=r){\n\t\tmid=l+r>>1;\n\t\tif (d[mid].val<=val) ret=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\treturn ret;\n}\nbool solve(){\n\tint pre;\n\tsort(d+1,d+1+n);\n\tfor (int i=1;i<=n;++i) sz[i]=1;\n\tfor (int i=n;i>=2;--i){\n\t\tpre=find(d[i].val-n+2*sz[i]);\n\t\tif (pre==-1||d[pre].val!=d[i].val-n+2*sz[i]||pre==i) return false;\n\t\tfa[i]=pre; \n\t\tsz[fa[i]]+=sz[i];\n\t}\n\treturn true;\n}\n\nint main(){\n#ifndef ONLINE_JUDGE\n\t//freopen(\"a.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;++i) scanf(\"%lld\",&d[i].val),d[i].id=i;\n\tif (solve()){\n\t\tfor (int i=2;i<=n;++i) cout<<d[fa[i]].id<<\" \"<<d[i].id<<endl;\n\t}\n\telse\n\t\tprintf(\"-1\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<iostream>\n#include<set>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<bitset>\n#define Fail puts(\"NO\"),exit(0);\n#define eps 1e-10\n#define maxn 100010\n#define maxm 100010\n#define inf 1000000007\n//#define mod 1000000009\n#define inv 500000005\n#define G 3\n#define pi acos(-1)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<ll,int>pii;\ntypedef bitset<maxn> bit;\ntypedef long double ld;\nll read()\n{\n    ll x=0,f=1;\n    char ch=getchar();\n    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}\n    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,siz[maxn];\npii p[maxn];\nint head[maxn],nxt[maxn*2],to[maxn*2],tot;\nvoid add(int u,int v)\n{\n    tot++;\n    nxt[tot]=head[u];\n    head[u]=tot;\n    to[tot]=v;\n}\nint u[maxn],v[maxn];\nll dfs(int x,int las,ll d)\n{\n    ll res=d;\n    for(int i=head[x];i;i=nxt[i])\n      if(to[i]!=las)  res+=dfs(to[i],x,d+1);\n    return res;\n}\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;i++)  p[i].fi=read(),p[i].se=i,siz[i]=1;\n    sort(p+1,p+n+1);reverse(p+1,p+n+1);\n    for(int i=1;i<n;i++)\n    {\n        int l=1,r=n,pos=0;\n        while(l<=r)\n        {\n            int mid=(l+r)/2;\n            if(p[mid].fi>=p[i].fi+2*siz[i]-n)\n            {\n                pos=mid;\n                l=mid+1;\n            }\n            else r=mid-1;\n        }\n        if(p[pos].fi!=p[i].fi+2*siz[i]-n)  return puts(\"-1\"),0;\n        siz[pos]+=siz[i];\n        u[i]=p[pos].se;v[i]=p[i].se;\n        add(u[i],v[i]);\n        add(v[i],u[i]);\n    }\n    ll com=dfs(p[n].se,0,0);\n    if(com!=p[n].fi)   return puts(\"-1\"),0;\n    for(int i=1;i<n;i++)  printf(\"%d %d\\n\",u[i],v[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 100010\n#define pii pair<long long,long long>\nusing namespace std;\nlong long a[maxn];\nmap<long long,int>mp;\nset<pii>s;\nvector<int>e[maxn];\nint ans[maxn][2],dp[maxn],d[maxn],vis[maxn];\nlong long sz[maxn],w[maxn];\npriority_queue<pii>pq;\nvoid dfs(int x)\n{\n    if(vis[x])return;\n    vis[x]=1;\n    sz[x]=1;\n    for(int i=0;i<e[x].size();i++)\n    {\n        int k=e[x][i];\n        if(vis[k])continue;\n        dfs(k);\n        sz[x]+=sz[k];\n        w[x]+=w[k]+sz[k];\n    }\n}\nint main()\n{\n    cin.tie(0);ios_base::sync_with_stdio(false);\n    int n;\n    cin>>n;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>a[i];\n        mp[a[i]]=i;\n        s.insert({a[i],i});\n    }\n    for(int i=1;i<=n;i++)dp[i]=1;\n    int f=0,cnt=0,x;\n    for(int i=1;i<n;i++)\n    {\n        pii tmp=*(--s.end());\n        s.erase(tmp);\n        int y=tmp.second;\n        if(!mp.count(a[y]-n+dp[y]*2)){f=1;break;}\n        int u=mp[a[y]-n+dp[y]*2];\n        e[u].push_back(y);\n        e[y].push_back(u);\n        ans[cnt][0]=u;\n        ans[cnt][1]=y;\n        dp[u]+=dp[y];\n        cnt++;\n        x=u;\n    }\n    x=s.begin()->second;\n    dfs(x);\n    for(int i=1;i<=n;i++)if(!vis[i])f=1;\n    if(w[x]!=a[x])f=1;\n    if(f)\n    {\n        cout<<-1<<endl;\n        exit(0);\n    }\n    for(int i=0;i<cnt;i++)cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nconst int mo=10000007;\nconst int maxn=100010;\n\nint n,m,d[maxn],id[maxn],siz[maxn],js[maxn],fa[maxn],ans;\nint tot,nex[maxn*2],las[maxn*2],tov[maxn*2];\nint hs[mo];\n\nvoid con(int x,int y)\n{\n\ttot++;\n\ttov[tot]=y;\n\tnex[tot]=las[x];\n\tlas[x]=tot;\n}\n\nvoid insert(int x,int id)\n{\n\tint i=x%mo;\n\twhile (hs[i]!=0)\n\t{\n\t\ti++;\n\t\tif (i==mo) i=0;\n\t}\n\ths[i]=id;\n}\n\nint find(int x)\n{\n\tint i=x%mo;\n\twhile (hs[i]!=0 && d[hs[i]]!=x)\n\t{\n\t\ti++;\n\t\tif (i==mo) i=0;\n\t}\n\treturn hs[i];\n}\n\nvoid qsort(int l,int r)\n{\n\tint i=l;int j=r;\n\tint m=d[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (d[i]>m) i++;\n\t\twhile (d[j]<m) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(d[i],d[j]);\n\t\t\tswap(id[i],id[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort(l,j);\n\tif (r>i) qsort(i,r); \n}\n\nvoid dfs(int x,int ff)\n{\n\tjs[x]=js[ff]+1;\n\tfor (int i=las[x];i;i=nex[i])\n\t{\n\t\tif (tov[i]!=ff)\n\t\t{\n\t\t\tdfs(tov[i],x);\n\t\t\tans+=js[x];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&d[i]);\n\t\tid[i]=i;\n\t\tsiz[i]=1;\n\t}\n\tqsort(1,n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinsert(d[i],i);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint op=d[i]-n+2*siz[i];\n\t\tint oq=find(op);\n\t\tif (oq==0)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfa[i]=oq;\n\t\t\tsiz[oq]+=siz[i];\n\t\t\tcon(i,oq);con(oq,i);\n\t\t}\n\t}\n\tdfs(n,0);\n\tif (ans!=d[n])\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tfor (int i=1;i<n;i++)\n\t\t{\n\t\t\tprintf(\"%d %d\\n\",id[i],id[fa[i]]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int MAXN = 1e05 + 10;\n\nint N;\npair<LL, int> d[MAXN];\n\nint subsize[MAXN]= {0}, fa[MAXN]= {0};\nvoid solve () {\n\tfor (int i = N; i > 1; i --) {\n\t\tsubsize[d[i].second] ++;\n\t\tint up = N - 2 * subsize[d[i].second];\n\t\tif (up < 0) { puts (\"-1\"); exit (0); }\n\t\tint p = lower_bound (d + 1, d + N + 1, make_pair (d[i].first - up, 0)) - d;\n\t\tif (p == i || d[p].first != d[i].first - up) { puts (\"-1\"); exit (0); }\n\t\tfa[d[i].second] = d[p].second;\n\t\tsubsize[d[p].second] += subsize[d[i].second];\n\t}\n}\n\nvector<int> G[MAXN];\nint cnt = 0;\nvoid DFS (int root) {\n\tcnt ++;\n\tfor (int i = 0; i < (int) G[root].size(); i ++) {\n\t\tint v = G[root][i];\n\t\tDFS (v);\n\t}\n}\n\ninline LL getnum () {\n\tLL num = 0; char ch = getchar ();\n\twhile (! isdigit (ch)) ch = getchar ();\n\twhile (isdigit (ch)) num = (num << 3) + (num << 1) + ch - '0', ch = getchar ();\n\treturn num;\n}\n\nint main () {\n\t// freopen (\"33.txt\", \"r\", stdin);\n\n\tN = getnum ();\n\tfor (int i = 1; i <= N; i ++) d[i].first = getnum (), d[i].second = i;\n\tsort (d + 1, d + N + 1);\n\tsolve ();\n\tfor (int i = 2; i <= N; i ++) G[fa[d[i].second]].push_back(d[i].second);\n\tDFS (1);\n\tif (cnt != N) { puts (\"-1\"); return 0; }\n\tfor (int i = 2; i <= N; i ++)\n\t\tprintf (\"%d %d\\n\", fa[d[i].second], d[i].second);\n\n\treturn 0;\n}\n\n/*\n7\n10\n15\n13\n18\n11\n14\n19\n*/\n\n/*\n2\n1\n2\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#define N 120000\n#include<map>\nusing namespace std;\nstruct node{\n\tlong long x,id;\n}a[N];\nmap<long long,long long>p;\nlong long n,siz[N],fa[N];\nbool cmp(node x,node y){\n\treturn x.x>y.x;\n}\nint main(){\n\tscanf(\"%lld\",&n);\n\tfor(long long i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i].x);\n\t\ta[i].id=i;\n\t}\n\tsort(a+1,a+1+n,cmp);\n\tfor(long long i=1;i<=n;i++){\n\t\tp[a[i].x]=a[i].id;\n\t}\n\tfor(long long i=1;i<n;i++){\n\t\tlong long x=a[i].id;\n\t\tp[a[i].x]=0;\n\t\tsiz[x]++;\n\t\tlong long o=a[i].x+siz[x]-(n-siz[x]);\n\t//\tprlong longf(\"%d %d %d\\n\",a[i].x,o,siz[x]);\n\t\tlong long l=p[o];\n\t\tif(l==0){\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[l]+=siz[x];\n\t\tfa[x]=l;\n\t}\n\tfor(long long i=1;i<=n;i++){\n\t\tif(fa[i]!=0)printf(\"%lld %lld\\n\",i,fa[i]);\n\t}\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define\tINF\t0x3f3f3f3f\n#define\tLL\tlong long\n#define\tMAXN\t100010\nusing namespace std;\nLL minn;\nint n, size[MAXN], fa[MAXN], F[MAXN];\nstruct info{LL w; int id;}a[MAXN];\n\nbool operator < (info a, info b){\n\treturn a.w < b.w;\n}\n\ntemplate <typename T> void chkmin(T &x, T y){x = min(x, y);}\ntemplate <typename T> void chkmax(T &x, T y){x = max(x, y);}\ntemplate <typename T> void read(T &x){\n\tx = 0; int f = 1; char ch = getchar();\n\twhile (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();}\n\twhile (isdigit(ch)) {x = x * 10 + ch - '0'; ch = getchar();}\n\tx *= f;\n}\n\nint find(int x){\n\tif (fa[x] == x) return fa[x];\n\telse return (fa[x] = find(fa[x]));\n}\n\nint merge(int x, int y){\n\tint fx = find(x), fy = find(y);\n\tif (fx == fy) return 0;\n\tfa[fx] = fy;\n\treturn 1;\n}\n\nint main(){\n\tread(n);\n\tminn = 1ll * INF * INF;\n\tfor (int i = 1; i <= n; ++i){\n\t\tread(a[i].w), a[i].id = i;\n\t\tchkmin(minn, a[i].w);\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tsize[i] = 1, fa[i] = i;\n\tsort(a + 1, a + 1 + n);\n\tfor (int i = n; i > 1; --i){\n\t\tint cur = a[i].id;\n\t\tLL vf = a[i].w + 2 * size[cur] - n;\n\t\t//printf(\"%d %lld\\n\", cur, vf);\n\t\tif (vf <= 0) {printf(\"-1\\n\"); return 0;}\n\t\tint f = lower_bound(a + 1, a + 1 + n, (info){vf, 0}) - a;\n\t\tif (a[f].w != vf) {printf(\"-1\\n\"); return 0;}\n\t\tf = a[f].id;\n\t\t//printf(\"%d\\n\", f);\n\t\tint fla = merge(cur, f);\n\t\tif (!fla) {printf(\"-1\\n\"); return 0;}\n\t\tF[cur] = f;\n\t\tsize[f] += size[cur];\n\t}\n\tfor (int i = 2; i <= n; ++i)\n\t\tprintf(\"%d %d\\n\", a[i].id, F[a[i].id]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid err() {\n  cout << -1 << endl;\n  exit(0);\n}\nvoid dfs (int crr, int dpt, vector<vector<int>>& grh, long long& cnt) {\n  cnt += dpt;\n  for (int nxt : grh[crr]) {\n    dfs(nxt, dpt + 1, grh, cnt);\n  }\n}\nint main() {\n  int n;\n  cin >> n;\n  vector<long long> d(n);\n  map<long long, int> mp;\n  for (int i = 0; i < n; i++) {\n    cin >> d[i];\n    mp[d[i]] = i;\n  }\n  sort(d.begin(), d.end());\n  vector<long long> sz(n, 1);\n  vector<vector<int>> grh(n);\n  vector<pair<int, int>> edg;\n  for (auto it = d.rbegin(); next(it) != d.rend(); it++) {\n    auto i = mp.rbegin()->second;\n    long long wnt = *it - n + 2 * sz[i];\n    if (mp.find(wnt) == mp.end()) err();\n    auto p = mp[wnt];\n    sz[p] += sz[i];\n    grh[p].push_back(i);\n    edg.emplace_back(i, p);\n    mp.erase(--mp.end());\n  }\n  int rt = mp.begin()->second;\n  long long cnt = 0;\n  dfs(rt, 0, grh, cnt);\n  if (d[0] != cnt) err();\n  for (auto const& e : edg) {\n    cout << e.first + 1 << ' ' << e.second + 1 << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#define Maxn 1000008 \nusing namespace std;\ntypedef long long ll;\n\nint n;\nll d;\nint son[Maxn];\nmap <ll,int> M;\n\nstruct node{\n\tint num;\n\tll val;\n}N[Maxn];\n\nbool cmp(node a,node b){\treturn a.val > b.val;}\n\nint main()\n{\n\tmemset(son,0,sizeof(son));\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\tscanf(\"%lld\",&d);\n\t\tM[d] = i;\n\t\tN[i].num = i,N[i].val = d;\n\t}\n\tsort(N+1,N+1+n,cmp);\n\tmap<ll,int>::iterator iter;;\n\tfor(int i = 1;i < n;i ++)\n\t{\n\t\tint u = N[i].num;\n\t\tif(N[i].val - n + 2 + (son[u] << 1) <= 0) continue;\n\t\titer = M.find(N[i].val - n + 2 + (son[u] << 1));\n\t\tif(iter >= M.end()) continue;\n\t\tint v = iter->second;\n\t\tson[v] += son[u]+1;\n\t\tprintf(\"%d %d\\n\",u,v);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 5;\nint n;\nlong long d[N];\npriority_queue <pair <int, int> > pq;\nint siz[N];\nint fa[N];\nmap <long long, set <int> > mp;\nvector <int> g[N];\n\n#define NO() return puts(\"-1\"), 0\n\nint dfs(int u) {\n\tint ans = 1;\n\tfor (int i = 0; i < g[u].size(); ++ i)\n\t\tans += dfs(g[u][i]);\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++ i)\n\t\tscanf(\"%lld\", &d[i]), mp[d[i]].insert(i),\n\t\tsiz[i] = 1, pq.push(make_pair(d[i], i));\n\tint rt;\n\twhile (!pq.empty()) {\n\t\tint u = pq.top().second;\n\t\tpq.pop(); mp[d[u]].erase(u);\n\t\tif (!pq.empty()) {\n\t\t\tlong long fa_d = (d[u] - (n - 2 * siz[u]));\n//\t\t\tprintf(\"%d %lld %lld\\n\", u + 1, d[u], fa_d);\n\t\t\tif (!mp[fa_d].size()) NO();\n\t\t\tint v = *mp[fa_d].begin();\n\t\t\tfa[u] = v;\n\t\t\tg[v].push_back(u);\n\t\t\tsiz[v] += siz[u];\n\t\t} else fa[u] = -1, rt = u;\n\t}\n\tif (dfs(rt) != n) NO();\n\tfor (int i = 0; i < n; ++ i)\n\t\tif (~fa[i]) printf(\"%d %d\\n\", fa[i] + 1, i + 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  long long n;\n  cin >> n;\n  vector<pair<long long, int>> d(n);\n  vector<long long> sz(n, n);\n  for(int i = 0; i < n; i++)\n  {\n    cin >> d[i].first;\n    d[i].second = i + 1;\n  }\n  sort(d.begin(), d.end());\n  vector<pair<int, int>> ans;\n  for(int i = n - 1; i > 0; i--)\n  {\n    long long dval = d[i].first + (n - sz[i] + 1) - (sz[i] - 1);\n    int pr = lower_bound(d.begin(), d.end(), make_pair(dval, 0)) - d.begin();\n    if(pr >= i || d[pr].first != dval)\n    {\n      cout << \"-1\" << endl;\n      return 0;\n    }\n    ans.push_back({d[i].second, d[pr].second});\n    sz[pr] -= (n - sz[i] + 1);\n  }\n  for(int i = 0; i < n - 1; i++)\n  {\n    cout << ans[i].first << \" \" << ans[i].second << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> pii;\n\npii inp[100005];\nint siz[100005];\nvector<pii> ans;\nint main() {\n\tint N; scanf(\"%d\", &N);\n\tfor (int i = 1; i <= N; i++) {\n\t\tll x; scanf(\"%lld\", &x);\n\t\tinp[i] = {x, i};\n\t\tsiz[i] = 1;\n\t}\n\tsort(inp + 1, inp + N + 1);\n\tfor (int i = N; i >= 2; i--) {\n\t\tauto [cur, id] = inp[i];\n\t\tint n = N - siz[id];\n\t\tll del = n - siz[id];\n\t\tauto it = *lower_bound(inp + 1, inp + N + 1, pii(cur - del, 0));\n\t\tif (it.first != cur - del || !del) return !printf(\"-1\");\n\t\tsiz[it.second] += siz[id];\n\t\tans.push_back({id, it.second});\n\t}\n\tfor (pii x : ans) {\n\t\tprintf(\"%lld %d\\n\", x.first, x.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <cmath>\n#include <bitset>\n#include <algorithm>\n#include <map>\n#include <vector>\ntypedef long long ll;\nusing namespace std;\nconst int maxn=101000;\nint n;\nll d[maxn];\nint size[maxn];\nll dis[maxn];\nmap<ll,int> mp;\nvector<int> G[maxn];\nll sum=0;\n\nvoid dfs1(int u,int fa){\n    for(int i=0;i<G[u].size();i++){\n        int v=G[u][i];\n        if(v==fa) continue;\n        dis[v]=dis[u]+1;\n        dfs1(v,u);\n    }\n    sum+=dis[u];\n}\n\nvoid dfs2(int u,int fa){\n    for(int i=0;i<G[u].size();i++){\n        int v=G[u][i];\n        if(v==fa) continue;\n        printf(\"%d %d\\n\",u,v);\n        dfs2(v,u);\n    }\n}\n\nint main(){\n    //初始化\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        scanf(\"%lld\",&d[i]);\n        mp[d[i]]=i;\n    }\n    sort(d+1,d+n+1);\n    for(int i=1;i<=n;i++) size[i]=1;\n    //构树\n    for(int i=n;i>1;i--){\n        int k=mp[d[i]];\n        int tmp=n-2*size[k];\n        //printf(\"%d   111\\n\",i);\n        if(tmp<=0) {printf(\"-1\\n\");return 0;}\n        ll ss=d[i]-tmp;\n        //printf(\"%d    222\\n\",i);\n        if(mp.count(ss)==0){printf(\"-1\\n\");return 0;}\n        int pos=mp[ss];\n        size[pos]+=size[k];\n        G[pos].push_back(k);\n        G[k].push_back(pos);\n    }\n   // printf(\"sbsbsb\\n\");\n    dis[mp[d[1]]]=0;\n    dfs1(mp[d[1]],-1);\n    if(sum!=d[1]){\n        printf(\"-1\\n\");\n    }else{\n        dfs2(1,-1);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <sstream>\n#include <stack>\n#include <time.h>\n#include <vector>\n#include <complex>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <math.h>\n#include <stdlib.h>\n#include <list>\n#include <utility>\n#include <memory>\n#include <cstring>\n#include <fstream>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <ios> \n#include <bits/stdc++.h>\nusing namespace std;\nint n;\nmultiset <int> st;\ntypedef long long ll;\nll a[100004];\nbool vis[100004];\nmap <ll,int> mp;\nvector<pair<ll,int> > v;\nint par[100004]; \nvoid nocout(){\n\tputs(\"-1\");exit(0);\n}\nint dfs(ll x,ll now){\n\tif (x!=v[0].first && now<=0) nocout();\n\tif (x==v[0].first) return v[0].second;\n\tif (mp.find(x)==mp.end()) nocout();\n\tint wa=dfs(x-now,now-2);\n\tif (vis[x]){\n\t\tif (wa!=par[mp[x]]) nocout();\n\t}\n\telse par[mp[x]]=wa;\n\tvis[mp[x]]=1;\n\treturn mp[x];\n}\nint main(){\n\tmemset (par,-1,sizeof(par));\n\tcin>>n;\n\tfor (int i=1;i<=n;i++){\n\t\tcin>>a[i];mp[a[i]]=i;\n\t\tv.push_back(make_pair(a[i],i));\n\t}\n\tsort (v.begin(),v.end());\n\tfor (int i=v.size()-1;i>=0;i--){\n\t\tif (vis[v[i].second]) continue;\n\t\tdfs(v[i].first,n-2);\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tif (par[i]>0)\n\t\t\tcout<<i<<\" \"<<par[i]<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#define ll long long\n#define inf 0x3f3f3f3f\n#define maxn 200010\ninline ll read()\n{\n\tll x=0; char c=getchar(),f=1;\n\tfor(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n\tfor(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\ninline void write(ll x)\n{\n\tstatic char buf[20];\n\tint len=0;\n\tif(x<0)putchar('-'),x=-x;\n\tfor(;x;x/=10)buf[len++]=x%10+'0';\n\tif(!len)putchar('0');\n\telse while(len)putchar(buf[--len]);\n}\ninline void writesp(ll x){write(x); putchar(' ');}\ninline void writeln(ll x){write(x); putchar('\\n');}\nll d[maxn];\nstd::map<ll,int>mp;\nint id[maxn],fa[maxn],size[maxn],dep[maxn];\nint n,rt;\nbool cmp(int x,int y){return d[x]>d[y];}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)\n\t\td[i]=read(),mp[d[i]]=i;\n\tfor(int i=1;i<=n;i++)\n\t\tid[i]=i,size[i]=1;\n\tstd::sort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<n;i++){\n\t\tfa[id[i]]=mp[d[id[i]]-(n-2*size[id[i]])];\n\t\tif(!fa[id[i]]||size[id[i]]*2>=n){\n\t\t\tputs(\"-1\"); return 0;\n\t\t}\n\t\tsize[fa[id[i]]]+=size[id[i]];\n\t}\n\tdep[id[n]]=0;\n\tfor(int i=n-1;i;i--)\n\t\tdep[id[i]]=dep[fa[id[i]]]+1;\n\tll sum=0;\n\tfor(int i=1;i<=n;i++)\n\t\tsum+=dep[i];\n\tif(sum!=d[id[n]]){\n\t\tputs(\"-1\"); return 0;\n\t}\n\tfor(int i=1;i<n;i++)\n\t\twritesp(id[i]),writeln(fa[id[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,int>P;\n\nint n;\nP d[200000];\nvector<int>E[200000];\nint sz[200000];\nll dp1[200000],dp2[200000];\nvector<pair<int,int>>ans;\n\nvoid dfs1(int v){\n\tfor(int u:E[v]){\n\t\tdfs1(u);\n\t\tdp1[v]+=dp1[u]+sz[u];\n\t}\n}\nvoid dfs2(int v,int p){\n\tif(p==-1)dp2[v]=dp1[v];\n\telse dp2[v]=dp2[p]+n-2*sz[v];\n\tfor(int u:E[v]){\n\t\tans.push_back({v+1,u+1});\n\t\tdfs2(u,v);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%lld\",&d[i].first);\n\t\td[i].second=i;\n\t}\n\trep(i,n)sz[i]=1;\n\tsort(d,d+n);\n\tfor(int i=n-1;i>0;i--){\n\t\tint c=d[i].first-n+2*sz[d[i].second];\n\t\tint id=lower_bound(d,d+n,P(c,0))-d;\n\t\tif(id==n||d[id].first!=c){\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t\tE[d[id].second].push_back(d[i].second);\n\t\tsz[d[id].second]+=sz[d[i].second];\n\t}\n\tabort();\n\tdfs1(d[0].second);\n\tdfs2(d[0].second,-1);\n\trep(i,n){\n\t\tif(dp2[d[i].second]!=d[i].first){\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t}\n\tfor(auto p:ans){\n\t\tprintf(\"%d %d\\n\",p.first,p.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<ll,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int maxn=1e5+7;\nll sum[maxn];\nmap<ll,int> id;\nint sz[maxn];\nbool ok=1;\nint main()\n{\n    int n;\n    cin>>n;\n    priority_queue<pi> q;\n    for(int i=1;i<=n;i++) \n    {\n        cin>>sum[i];\n        id[sum[i]]=i;\n        q.push(make_pair(sum[i],i));\n        sz[i]=1;\n    }\n    vc<pi> ans;\n    while(!q.empty())\n    {\n        auto u=q.top();q.pop();\n        if(q.empty())\n            break;\n        ll fad=u.first-(n-2*sz[u.second]);\n        if(!id.count(fad)||fad>=u.first)\n        {\n            ok=0;\n            break;\n        }\n        sz[id[fad]]+=sz[u.second];\n        ans.emplace_back(u.second,id[fad]);\n    }\n    if(!ok) print(-1);\n    else{\n        for(auto u:ans) cout<<u.first<<\" \"<<u.second<<'\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring> \n#include <cmath> \n#include <algorithm> \nusing namespace std; \ntypedef long long LL; \nconst int MAX_N = 1e5 + 5; \nstruct Graph { int to, next; } e[MAX_N << 1]; \nint fir[MAX_N], e_cnt; \nvoid clearGraph() { memset(fir, -1, sizeof(fir)); e_cnt = 0; } \nvoid Add_Edge(int u, int v) { e[e_cnt] = (Graph){v, fir[u]}, fir[u] = e_cnt++; } \nint N, sz[MAX_N];\nLL D[MAX_N]; \nstruct node { LL D; int id; } a[MAX_N]; \nbool operator < (const node &l, const node &r) { return l.D < r.D; } \nint dis[MAX_N]; \nvoid dfs(int x, int fa) { \n\tfor (int i = fir[x]; ~i; i = e[i].next) {\n\t\tint v = e[i].to; if (v == fa) continue; \n\t\tdis[v] = dis[x] + 1, dfs(v, x); \n\t} \n} \nint main () { \n\tclearGraph(); \n\tscanf(\"%d\", &N); \n\tfor (int i = 1; i <= N; i++) scanf(\"%lld\", D + i), sz[i] = 1, a[i] = (node){D[i], i}; \n\tsort(&a[1], &a[N + 1]); \n\tfor (int i = N; i > 1; i--) { \n\t\tint x = a[i].id, u = 0; \n\t\tLL ds = 2 * sz[x] - N + a[i].D; \n\t\tu = lower_bound(&a[1], &a[N + 1], (node){ds, 0})->id; \n\t\tif (D[u] != ds) return puts(\"-1\") & 0; \n\t\tsz[u] += sz[x]; \n\t\tAdd_Edge(u, x), Add_Edge(x, u); \n\t} \n\tdfs(1, 0);\n\tLL ds = 0; \n\tfor (int i = 1; i <= N; i++) ds += dis[i]; \n\tif (ds != D[1]) return puts(\"-1\") & 0; \n\tfor (int i = 0; i < e_cnt; i += 2) printf(\"%d %d\\n\", e[i].to, e[i ^ 1].to); \n    return 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nconst int N = 500000;\n\nint sz[N];\nvector<int> graph[N];\nll dist[N];\n\nvoid dfs(int v, int p, int di)\n{\n    dist[v] = di;\n    for (auto u : graph[v]) if (u != p)\n    {\n        dfs(u, v, di + 1);\n    }\n}\n\nsigned main()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    int n;\n    cin >> n;\n    vector<ll> d(n + 1);\n    vector<pair<ll, int> > q(n);\n    map<ll, int> mm;\n    for (int i = 1; i <= n; i++) cin >> d[i], q[i - 1] = {d[i], i}, mm[d[i]] = i;\n    sort(rall(q));\n    fill(sz, sz + N, 1);\n    for (int i = 0; i + 1 < q.size(); i++)\n    {\n        auto it = q[i];\n        ll ex = it.first + sz[it.second] - (n - sz[it.second]);\n        if (ex >= it.first || mm.find(ex) == mm.end())\n        {\n            cout << \"-1\";\n            return 0;\n        }\n        graph[it.second].push_back(mm[ex]);\n        graph[mm[ex]].push_back(it.second);\n        sz[mm[ex]] += sz[it.second];\n    }\n    dfs(1, 0, 0);\n    ll si = 0;\n    for (int i = 1; i <= n; i++) si += dist[i];\n    if (si != d[1])\n    {\n        cout << -1;\n        return 0;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (auto u : graph[i])\n        {\n            if (u > i) cout << u << \" \" << i << \"\\n\";\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//Zory-2018\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n#include<set>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<bitset>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nnamespace mine\n{\n\ttypedef long long ll;\n\tconst int INF=0x3f3f3f3f;\n\n\tconst int MAX_N=110000;\n\tstruct Nod\n\t{\n\t\tll d;int p;\n\t\tfriend bool operator < (Nod a,Nod b) {return a.d<b.d;}\n\t};\n\tset<Nod> s;\n\tint siz[MAX_N];\n\n\t#define PR pair<int,int>\n\tvector<PR> ans;\n\tint n;\n\tbool solve(int op)\n\t{\n\t\tNod now;\n\t\tif(op) now=*(--s.end());\n\t\telse now=*s.begin();\n\n\t\tif(op<2 and siz[now.p]>n/2) return 0;\n\n\t\ts.erase(s.find(now));\n\t\tif(s.begin()==s.end()) return 0;//root\n\n\t\t//printf(\"now=%d p[now].d=%lld \",now.p,now.d);\n\n\t\tll want=now.d-n+2*siz[now.p];Nod fa=*(s.lower_bound((Nod){want,0}));\n\t\t//printf(\"siz=%d want=%lld fa.d=%lld\\n\",siz[now.p],want,fa.d);\n\t\tif(fa.d!=want) {puts(\"-1\");exit(0);}\n\t\tans.push_back( make_pair(now.p,fa.p) );\n\t\tsiz[fa.p]+=siz[now.p];\n\t\treturn 1;\n\t}\n\tvoid main()\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tll t;scanf(\"%lld\",&t);\n\t\t\ts.insert( (Nod){t,i} );\n\t\t\tsiz[i]=1;\n\t\t}\n\n\t\twhile(solve(1)) ;\n\t\twhile(solve(0)) ;\n\t\twhile(solve(2)) ;\n\t\t//int rt=(n+1)/2;\n\t\t//for(int i=n;i>rt;i--) solve(1);\n\t\t//for(int i=1;i<rt;i++) solve(0);\n\t\tfor(int i=0;i<(int)ans.size();i++) printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\t}\n}\nint main()\n{\n\tmine::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define\tINF\t0x3f3f3f3f\n#define\tLL\tlong long\n#define\tMAXN\t100010\nusing namespace std;\nLL minn;\nint n, size[MAXN], fa[MAXN], F[MAXN];\nstruct info{LL w; int id;}a[MAXN];\n\nbool operator < (info a, info b){\n\treturn a.w < b.w;\n}\n\ntemplate <typename T> void chkmin(T &x, T y){x = min(x, y);}\ntemplate <typename T> void chkmax(T &x, T y){x = max(x, y);}\ntemplate <typename T> void read(T &x){\n\tx = 0; int f = 1; char ch = getchar();\n\twhile (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();}\n\twhile (isdigit(ch)) {x = x * 10 + ch - '0'; ch = getchar();}\n\tx *= f;\n}\n\nint find(int x){\n\tif (fa[x] == x) return fa[x];\n\telse return (fa[x] = find(fa[x]));\n}\n\nint merge(int x, int y){\n\tint fx = find(x), fy = find(y);\n\tif (fx == fy) return 0;\n\tfa[fx] = fy;\n\treturn 1;\n}\n\nint main(){\n\tread(n);\n\tminn = 1ll * INF * INF;\n\tfor (int i = 1; i <= n; ++i){\n\t\tread(a[i].w), a[i].id = i;\n\t\tchkmin(minn, a[i].w);\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tsize[i] = 1, fa[i] = i;\n\tsort(a + 1, a + 1 + n);\n\tfor (int i = n; i > 1; --i){\n\t\tint cur = a[i].id;\n\t\tLL vf = a[i].w + 2 * size[cur] - n;\n\t\t//printf(\"%d %lld\\n\", cur, vf);\n\t\tif (vf <= 0) {printf(\"-1\\n\"); return 0;}\n\t\tint f = lower_bound(a + 1, a + 1 + n, (info){vf, 0}) - a;\n\t\tif (a[f].w != vf) {printf(\"-1\\n\"); return 0;}\n\t\tf = a[f].id;\n\t\tif (!f) {printf(\"-1\\n\"); return 0;}\n\t\t//printf(\"%d\\n\", f);\n\t\tint fla = merge(cur, f);\n\t\tif (!fla) {printf(\"-1\\n\"); return 0;}\n\t\tF[cur] = f;\n\t\tsize[f] += size[cur];\n\t}\n\tif (size[a[1].id] != n) {printf(\"-1\\n\"); return 0;}\n\tfor (int i = 2; i <= n; ++i)\n\t\tprintf(\"%d %d\\n\", a[i].id, F[a[i].id]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct node\n{\n    ll d;int id;\n}c[100005];\nbool cmp(node x,node y){return x.d>y.d;}\nint fa[100005],siz[100005],deep[100005];\nll d[100005];\nvector<int>to[100005];\nvoid dfs(int x){for(auto tar:to[x])deep[tar]=deep[x]+1,dfs(tar);}\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)scanf(\"%lld\",&c[i].d),c[i].id=i,siz[i]=1;\n    sort(c+1,c+n+1,cmp);\n    for(int i=1;i<=n;i++)d[i]=c[n+1-i].d;\n    for(int i=1;i<n;i++)\n    {\n        int t=lower_bound(d+1,d+n+1,c[i].d+2*siz[c[i].id]-n)-d;\n        t=n+1-t;\n        if(c[t].d!=c[i].d+2*siz[c[i].id]-n){puts(\"-1\");return 0;}\n        fa[c[i].id]=c[t].id,siz[c[t].id]+=siz[c[i].id];\n    }\n    for(int i=1;i<=n;i++)if(fa[i])to[fa[i]].push_back(i);\n    dfs(c[n].id);\n    ll s=0;\n    for(int i=1;i<=n;i++)s+=deep[i];\n    if(s!=c[n].d){puts(\"-1\");return 0;}\n    for(int i=1;i<=n;i++)if(fa[i])printf(\"%d %d\\n\",i,fa[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nint n;\nint c[100000];\nlong long d[100000];\nlong long p[100000];\nvector <int> v[100000];\n\nint dfs(int x, int y) {\n    int i;\n    \n    c[x] = 1;\n    \n    for (i = 0; i < v[x].size(); i++) {\n        int t;\n        \n        if (v[x][i] == y) continue;\n        \n        t = dfs(v[x][i], x);\n        c[x] += t;\n        p[x] += p[v[x][i]] + t;\n    }\n    \n    return c[x];\n}\n\nvoid dfs2(int x, int y, long long z) {\n    int i;\n    \n    p[x] += z;\n    \n    for (i = 0; i < v[x].size(); i++) {\n        if (v[x][i] == y) continue;\n        \n        dfs2(v[x][i], x, p[x] - p[v[x][i]] + n - c[v[x][i]] * 2);\n    }\n}\n\nint main() {\n    int i;\n    vector <pair<int, int>> ans;\n    map <long long, int> mp, mp2;\n    map <long long, int>::reverse_iterator it;\n    \n    scanf(\"%d\", &n);\n    \n    for (i = 0; i < n; i++) {\n        scanf(\"%lld\", &d[i]);\n        \n        mp[d[i]] = i;\n        mp2[d[i]] = 1;\n    }\n    \n    for (it = mp2.rbegin(); it != mp2.rend(); it++) {\n        long long x = it->first, y;\n        int c = it->second;\n        \n        if (c * 2 >= n) continue;\n        \n        y = x - n + c * 2;\n        \n        if (!mp2.count(y)) {\n            puts(\"-1\");\n            \n            return 0;\n        }\n        \n        mp2[y] += c;\n        v[mp[x]].push_back(mp[y]);\n        v[mp[y]].push_back(mp[x]);\n        ans.push_back(make_pair(mp[x], mp[y]));\n    }\n    \n    dfs(0, -1);\n    dfs2(0, -1, 0);\n    \n    for (i = 0; i < n; i++) {\n        if (d[i] != p[i]) {\n            puts(\"-1\");\n            \n            return 0;\n        }\n    }\n    \n    for (i = 0; i < ans.size(); i++) printf(\"%d %d\\n\", ans[i].first + 1, ans[i].second + 1);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)-form-)\n//#pragma GCC optimize (\"-O3\") \n#ifdef YANG33\n#include \"mydebug.hpp\"\n#else\n#define DD(x) \n#endif\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n\ninline int ri() { int in; int y = scanf(\"%d\", &in); return in; }\ninline LL rl() { LL in; int y = scanf(\"%lld\", &in); return in; }\ninline void oi(int i) { printf(\"%d\\n\", i); }\ninline void od(double i) { printf(\"%.9f\\n\", i); }\n\n\nint main() {\n\tint N = ri();\n\tvector<LL> a(N);\n\tset<PLL>se;\n\tfor (int i = 0; i < N; ++i) {\n\t\ta[i] = rl();\n\t\tse.insert(PLL(a[i], i));\n\t}\n\tVL sub(N, 1);\n\tauto NG = []() {\n\t\tcout << -1 << endl;\n\t\texit(0);\n\t};\n\tvector<vector<int>>G(N);\n\twhile (SZ(se) > 1) {\n\t\tauto it = se.end();\n\t\t--it;\n\t\tPLL a = *it;\n\t\tse.erase(it);\n\t\tLL sa = a.first;\n\t\tint v = a.second;\n\t\tDD(de(sa, v));\n\t\tLL parval = sa + 2 * sub[v] - N;\n\t\tauto parnode = se.lower_bound(PLL(parval, 0));\n\t\tif (parnode->first != parval)NG();\n\t\tint par = parnode->second;\n\t\tsub[par] += sub[v];\n\t\tG[par].push_back(v);\n\t}\n\n\tfunction<LL(int)> f = [&](int v) {\n\t\tLL ret = 0;\n\t\tfor (auto nx : G[v]) {\n\t\t\tret += f(nx) + sub[nx];\n\t\t}\n\t\treturn ret;\n\t};\n\tLL res = f(se.begin()->second);\n\tif (res != se.begin()->first)NG();\n\tFOR(i, 0, N) {\n\t\tfor (auto nx : G[i]) {\n\t\t\tprintf(\"%d %d\\n\", i + 1, nx + 1);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long s64; \ntypedef std::pair<int, int> pii; \n\ntemplate <class T>\ninline void read(T &x) {\n\tstatic char ch; \n\twhile (!isdigit(ch = getchar())); \n\tx = ch - '0'; \n\twhile (isdigit(ch = getchar()))\n\t\tx = x * 10 + ch - '0'; \n}\n\ninline void invalid() {\n\tputs(\"-1\"); \n\texit(0); \n}\n\nconst int MaxN = 1e5 + 5;  \n\nint n; \nint sze[MaxN]; \nbool vis[MaxN]; \n\ns64 d[MaxN], c[MaxN];\nstd::vector<pii> ans; \nstd::map<s64, int> pos; \n\nint fa[MaxN]; \nstd::vector<int> adj[MaxN]; \n\ninline void addEdge(int u, int v) {\n\tsze[u] += sze[v]; \n\tadj[u].push_back(v); \n\tans.push_back(pii(u, v)); \n}\n\ninline void dfs(int u) {\n\tfor (int v : adj[u]) {\n\t\tdfs(v); \n\t\tc[u] += c[v] + sze[v]; \n\t}\n}\n\nbool check() {\n\tint G = pos[d[n]]; \n\treturn dfs(G), c[G] == d[n]; \n}\n\nint main() {\n#ifdef orzczk\n\tfreopen(\"tree.in\", \"r\", stdin); \n#endif\n\t\n\tread(n); \n\tfor (int i = 1; i <= n; ++i) {\n\t\tread(d[i]); \n\t\tsze[i] = 1; \n\t\tpos[d[i]] = i; \n\t}\n\tstd::sort(d + 1, d + n + 1, std::greater<int>()); \n\n\tfor (int i = 1; i < n; ++i) {\n\t\tint v = pos[d[i]], u; \n\t\ts64 faD = d[i] - n + 2 * sze[v]; \n\n\t\tvis[v] = true; \n\t\tif (!pos.count(faD) || vis[u = pos[faD]]) {\n\t\t\tinvalid(); \n\t\t}\n\t\t\n\t\taddEdge(u, v); \n\t}\n\n\tif (check()) {\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\tprintf(\"%d %d\\n\", ans[i].first, ans[i].second); \n\t\t}\n\t} else {\n\t\tinvalid(); \n\t}\n\n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nmap<int,int> M1,M2;\nint s1[200010],pa[200010];\nstruct edge\n{\n\tint v,next;\n}vs[200010];\nint st[200010],ee,sz[200010],vis[20010];\ninline void addedge(int u,int v)\n{\n\tvs[++ee].v=v;vs[ee].next=st[u];st[u]=ee;\n}\ninline void dfs(int rt)\n{\n\tif(vis[rt])\n\t{\n\t\tputs(\"-1\"); exit(0);\n\t}\n\tvis[rt]=1; sz[rt]=1;\n\tfor(int i=st[rt];i;i=vs[i].next)\n\t\tdfs(vs[i].v),sz[rt]+=sz[vs[i].v];\n}\nsigned main()\n{\n\tint n=read();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=read();\n\t\tM1[x]=i; M2[x]=1;\n\t\ts1[i]=x;\n\t}\n\tsort(s1+1,s1+1+n);\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tint id=M1[s1[i]],sz=M2[s1[i]],td=s1[i]+2*sz-n;\t\n\t\tif(td>=s1[i]) continue;\t\n\t\tpa[id]=M1[td]; M2[td]+=sz;\n\t}\n\tint rt=0;\n\tfor(int i=1;i<=n;i++) \n\t\tif(pa[i]) addedge(pa[i],i);\n\t\telse rt=i;\n\tdfs(rt);\n\tif(sz[rt]!=n) puts(\"-1\");\n\telse for(int i=1;i<=n;i++)\n\t\tif(pa[i]) printf(\"%lld %lld\\n\",i,pa[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+5;\nmap<long long,int>ma;\nlong long a[N];\nint n,b[N],si[N];\nbool com(int x,int y){\n\treturn a[x]>a[y];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i]);\n\t\tma[a[i]]=b[i]=i;\n\t}\n\tsort(b+1,b+n+1,com);\n\tfor(int i=1;i<=n;i++)\tsi[i]=1;\n\tfor(int i=1;i<n;i++){\n\t\tint k=ma[a[b[i]]-n+si[b[i]]*2];\n\t\tprintf(\"%d %d\\n\",b[i],k),si[k]+=si[b[i]];\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\nbool is_valid(vector<pair<long long, int>> &D, vector<pair<int, int>> &edges){\n    int N = D.size();\n    vector<vector<int>> G(N);\n    for(auto x : edges){\n        G[x.first].push_back(x.second);\n        G[x.second].push_back(x.first);\n    }\n    queue<pair<int, long long>> que;\n    vector<bool> vis(N, false);\n    que.push(make_pair(0, 0));\n    long long cnt = 0;\n    while(!que.empty()){\n        auto q = que.front();\n        que.pop();\n        if(vis[q.first]) continue;\n        vis[q.first] = true;\n        cnt += q.second;\n        for(auto x : G[q.first])\n            que.push(make_pair(x, q.second+1));\n    }\n    return cnt == D[0].first;\n}\n\nint main(){\n    long long N;\n    cin >> N;\n    vector<pair<long long, int>> D(N);\n    for(int i=0; i<N; i++){\n        long long tmp;\n        cin >> tmp;\n        D[i] = make_pair(tmp, i);\n    }\n    sort(D.begin(), D.end(), greater<pair<long long, int>>());\n\n    vector<int> idx2idx(N);\n    for(int i=0; i<N; i++)\n        idx2idx[i] = D[i].second;\n\n    map<long long, int> d2idx;\n    for(int i=0; i<N; i++)\n        d2idx[D[i].first] = i;\n\n    vector<long long> E(N, 0);\n    vector<pair<int, int>> edges;\n    for(int i=0; i<N; i++){\n        if(E[i] == 0) E[i] = 1;\n        long long d0 = D[i].first;\n        long long d1 = D[i].first + 2 * E[i] - N;\n        if(i == N-1) break;\n        auto itr = d2idx.find(d1);\n        if(itr == d2idx.end() || i == d2idx[d1]){\n            cout << -1 << endl;\n            return 0;\n        }\n        edges.push_back(make_pair(i, d2idx[d1]));\n        E[d2idx[d1]] += E[i] + 1;\n    }\n\n    if(!is_valid(D, edges)){\n        cout << -1 << endl;\n        return 0;\n    }\n\n    for(auto x : edges)\n        cout << idx2idx[x.first]+1 << \" \" << idx2idx[x.second]+1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\nint n, p[N];\nlong long a[N], rd[N];\n\n\nint head[N];\n\nint main() {\n    cin >> n;\n    for(int i = 1; i <= n; i++){\n        cin >> a[i];\n    }\n    for(int i = 1; i <= n; i++) p[i] = i;\n    sort(p + 1, p + n + 1,[](int x,int y){ return a[x] < a[y];});\n    fill(head + 1, head + n + 1, 1);\n\n    vector<pair<int, int>> ans;\n    for(int i = n; i >= 2; i--) {\n        int cur = p[i];\n        int L = 1, R = i - 1;\n        long long con_weight = a[cur] + 2 * head[cur] - n; \n        while (L <= R){\n            int mid = (L + R) / 2;\n            if (con_weight > a[p[mid]]) L = mid + 1;\n            else R = mid - 1;\n        }\n        if (L >= i || con_weight != a[p[L]]) {\n            cout << \"-1\" << endl;\n            return 0;\n        }\n        ans.push_back(make_pair(p[L], cur));\n        head[p[L]] += head[cur];\n        rd[p[L]] += rd[cur] + head[cur];\n        //cout << cur << \" \" << p[L] <<'\\n';\n        //for(int j = 1; j <= n; j++) cout << head[j] << \" \\n\"[j==n]; \n    }\n    if (rd[p[1]] != a[p[1]]) {\n        cout << \"-1\" << endl;\n        return 0;\n    }\n    for(auto i : ans) cout << i.first << \" \" << i.second << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stdio.h>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nvector < pair <int, int> > v;\n\nint n, sz[1000000], r[1000000];\n\nbool ans = true;\n\nvector <int> g[1000000];\n\nint dfs (int x, int p)\n{\n\tint sum = sz[x] - 1;\n\n\tfor (int to : g[x])\n\t\tif (to != p)\n\t\t\tsum += dfs (to, x);\n\n\treturn sum;\n}\n\nint main () \n{\n    cin >> n;\n    \n    for (int i = 0; i < n; i++)\n    {\n\t\tint d;\n\t\tscanf (\"%d\", &d);\n\t\t\n\t\tv.emplace_back (d, i);\n\n\t\tr[i] = d;\n    }\n    \n    sort (v.begin (), v.end ());\n    \n    for (int i = n - 1; i >= 0; i--)\n    {\n\t\tint x = v[i].second, d = v[i].first;\n\t\t\n\t\tv.pop_back ();\n\t\t\n\t\tsz[x] = 1;\n\t\t\n\t\tfor (int to : g[x])\n\t\t    sz[x] += sz[to];\n\t\t\n\t\tif (!i) break;\n\t\t\n\t\tint k = lower_bound (v.begin (), v.end (), make_pair (d + 2 * sz[x] - n, -1)) - v.begin ();\n\t\t\n\t\tif (k == v.size () || v[k].first != d + 2 * sz[x] - n)\n\t\t{\n\t\t    cout << -1;\n\t\t    return 0;\n\t\t}\n\t\t\n\t\tg[v[k].second].push_back (x);\n    }\n    \n    if (dfs (0, -1) != r[0])\n    {\n\t\tcout << -1;\n\t\treturn 0;\n    }\n    \n    for (int i = 0; i < n; i++)\n\t\tfor (int to : g[i])\n\t\t{\n\t\t    printf (\"%d %d\\n\", i + 1, to + 1);\n\t\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int N;\n    cin >> N;\n\n    set<array<ll, 3>> pieces;\n\n    vll ds(N);\n    for (int i = 0; i < N; i++) {\n        cin >> ds[i];\n        pieces.insert({ ds[i], 1, i });\n    }\n\n    vector<pair<int, int>> edges;\n    while (pieces.size() > 1) {\n        auto p = *pieces.rbegin();\n        pieces.erase(p);\n\n        ll match = p[0] + 2 * p[1] - N;\n        auto qi = pieces.lower_bound({ match, -1, -1 });\n        if (qi == pieces.end() || (*qi)[0] != match) {\n            cout << -1 << endl;\n            return 0;\n        }\n        auto q = *qi;\n\n        edges.emplace_back(p[2], q[2]);\n        array<ll, 3> comb = { q[0], p[1] + q[1], q[2] };\n\n        pieces.erase(q);\n        pieces.insert(comb);\n    }\n\n    vvi adj(N);\n    for (auto p : edges) {\n        adj[p.first].push_back(p.second);\n        adj[p.second].push_back(p.first);\n    }\n\n    vi dist(N, -1);\n    dist[0] = 0;\n    for (queue<int> bfs({0}); !bfs.empty(); bfs.pop()) {\n        for (int nbr : adj[bfs.front()]) if (dist[nbr] == -1) {\n            dist[nbr] = dist[bfs.front()] + 1;\n            bfs.push(nbr);\n        }\n    }\n\n    ll tot0 = 0;\n    for (int v : dist)\n        tot0 += v;\n\n    if (tot0 != ds[0]) {\n        cout << -1 << \"\\n\";\n    } else for (auto p : edges) {\n        cout << p.first + 1 << \" \" << p.second + 1 << \"\\n\";\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\n//ll mod=1000000007;\nll mod=998244353;\nll inf=1000000000000000000;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(int i=n;i>=m;i--)\nll lmax(ll a,ll b){\n    if(a<b)return b;\n    else return a;\n}\nll lmin(ll a,ll b){\n    if(a<b)return a;\n    else return b;\n}\nint main(){\n    ll n;cin>>n;\n    ll d[n];\n    multiset<pll> st;\n    ll num;\n    ll mi=inf;\n    rep(i,0,n){\n        cin>>d[i];\n        st.insert(make_pair(d[i],i));\n        if(mi>d[i]){\n            mi=d[i];\n            num=i;\n        }\n    }\n    pll roo=*st.begin();\n    ll root=roo.first;\n    ll now=-1;\n    ll sa=-1;\n    ll par=-1;\n    vector<pll> ans;\n    for(;;){\n        if(now==-1){\n            auto itr=st.begin();\n            itr++;\n            pll p=*itr;\n            now=p.first;\n            ll ban=p.second;\n            //cout<<now<<endl;\n            if(now>root+n-2){\n                cout<<-1<<endl;\n                return 0;\n            }\n            sa=now-root;\n            st.erase(itr);\n            ans.push_back(make_pair(num,ban));\n            par=ban;\n        }\n        else{\n            auto itr=st.lower_bound(make_pair(now+sa+2,0));\n            if(itr==st.end()){\n                if(sa!=n-2){\n                    cout<<-1<<endl;\n                    return 0;\n                }\n                now=-1;\n                sa=-1;\n            }\n            else{\n                pll p=*itr;\n                if(p.first!=now+sa+2){\n                    cout<<-1<<endl;\n                    return 0;\n                }\n                ans.push_back(make_pair(par,p.second));\n                par=p.second;\n                now=p.first;\n                sa+=2;\n                st.erase(itr);\n            }\n        }\n        if(st.size()==1)break;\n        //cout<<now<<\" \";\n    }\n    rep(i,0,ans.size()){\n        if(ans[i].first>ans[i].second)swap(ans[i].first,ans[i].second);\n    }\n    sort(ans.begin(),ans.end());\n    rep(i,0,ans.size())cout<<ans[i].first+1<<\" \"<<ans[i].second+1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct union_find{\n\tstatic const int DEFAULT = 200200;\n\tvector<int> parent;\n\tint N;\n\tunion_find(int N = DEFAULT) : N(N) {\n\t\tclear();\n\t}\n\tvoid clear(){\n\t\tparent.assign(N, -1);\n\t}\n\tint find(int u){\n\t\treturn (parent[u] < 0) ? u : parent[u] = find(parent[u]);\n\t}\n\tbool is_connected(int u, int v){\n\t\treturn find(u) == find(v);\n\t}\n\tbool join(int u, int v){\n\t\tu = find(u);\n\t\tv = find(v);\n\t\tif (u != v){\n\t\t\tif (parent[u] > parent[v])\n\t\t\t\tswap(u, v);\n\t\t\tparent[u] += parent[v];\n\t\t\tparent[v] = u;\n\t\t}\n\t\treturn u != v;\n\t}\n\tint size(int u){\n\t\treturn -parent[find(u)];\n\t}\n};\nconst int maxn = 200200;\nvector<int> to[maxn];\nlong long cost[maxn], sz[maxn];\nvoid dfs(int u, int p){\n\tsz[u] = 1;\n\tfor(int v : to[u]){\n\t\tif(v == p) continue;\n\t\tdfs(v, u);\n\t\tsz[u] += sz[v];\n\t\tcost[u] += cost[v] + sz[v];\n\t}\n}\nint n;\nvoid fix(int u, int p){\n\tif(p != -1){\n\t\tcost[u] = cost[p] + n - 2 * sz[u];\n\t}\n\tfor(int v : to[u]){\n\t\tif(v == p) continue;\n\t\tfix(v, u);\n\t}\n}\nint main(){\n\tcin >> n;\n\tvector<pair<long long, int> > vals;\n\tmap<long long, int> rev;\n\tunion_find uf(n);\n\tlong long sum = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tlong long x; cin >> x;\n\t\trev[x] = i;\n\t\tvals.push_back({x, i});\n\t\tsum += x;\n\t}\n\tif(sum&1){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tvector<pair<int,int> > edges;\n\tsort(vals.rbegin(), vals.rend());\n\tfor(int i = 0; i < n - 1; i++){\n\t\tlong long cost; int u;\n\t\ttie(cost, u) = vals[i];\n\t\tint sz = uf.size(u);\n\t\tlong long ncost = cost - n + 2 * sz;\n\t\tauto it = rev.find(ncost); \n\t\tif(it == rev.end()){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint x = u, y = it->second;\n\t\tif(x == y){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(x > y) swap(x, y);\n\t\tif(!uf.join(x, y)){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tedges.push_back({x, y});\n\t\tto[x].push_back(y);\n\t\tto[y].push_back(x);\n\t}\n\tdfs(0, -1);\n\tfix(0, -1);\n\tvector<pair<long long, int> > nvals;\n\tfor(int i = 0; i < n; i++) nvals.push_back({cost[i], i});\n\tsort(nvals.rbegin(), nvals.rend());\n\tif(nvals != vals){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tsort(edges.begin(), edges.end());\n\tfor(auto e : edges) cout << e.first + 1 << \" \" << e.second + 1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nint n;\nmap<ll, pair<int, int> > st;\nvector<pair<int, int> > edge;\n\nint main()\n{\n\tread(n);\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tll d;\n\t\tread(d);\n\t\tst.insert(make_pair(d, make_pair(1, i)));\n\t}\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tauto x = *st.rbegin();\n\t\tst.erase(--st.end());\n\t\tll y = x.first-(n-x.second.first)+x.second.first;\n\t\tauto it = st.find(y);\n\t\tif(it == st.end()) {printf(\"-1\\n\"); return 0;}\n\t\telse it->second.first += x.second.first, edge.emplace_back(x.second.second, it->second.second);\n\t}\n\tfor(auto i : edge) printf(\"%d %d\\n\", i.first, i.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Be Name Khoda, Besmellah Rahmane Rahim, In The Name Of God;\n//#include<bits/stdc++.h>\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <deque>\n#include <map>\n#include <stack>\n#include<bitset>\n#include<list>\n#include<cassert>\n#include<numeric>\n#include <stdio.h>\n#include <string.h>\n#include<iomanip>\n#include<unordered_map>\n#include<unordered_set>\n#include <fstream>\n\nusing namespace std;\n\nconst long long N = 1e5 + 5;\nlong long n;\nset< pair<long long, long long> > s;\nvector<long long> graph[N];\nlong long cnt[N];\nlong long par[N];\nlong long root, maxi;\nvector< pair<long long, long long> > edge;\nlong long check = 0;\n\nvoid dfs(long long v, long long par = -1, long long h = 0)\n{\n    check += h;\n    for (auto u: graph[v])\n    {\n        if (u != par)\n        {\n            edge.push_back({v, u});\n            dfs(u, v, h + 1);\n        }\n    }\n}\n\n\nint main() \n{\n    cin >> n;\n    for (long long i = 0; i < n; i++)\n    {\n        long long tmp;\n        cin >> tmp;\n        s.insert({-tmp, i});\n    }\n    while (s.size())\n    {\n        /*\n        for (auto u: s)\n        {\n            cout << \"(\" << -u.first << \", \" << u.second << \") \";\n        }\n        cout << endl;\n        */\n        auto p = (*s.begin());\n        s.erase(s.begin());\n        long long v = p.second;\n        long long w = p.first;\n        w = -w;\n        cnt[v]++;\n        long long tmp = w + cnt[v] - (n - cnt[v]);\n        if (s.size())\n        {\n            auto nei = s.lower_bound({-tmp, -1});\n            //cout << (*nei).first << \" \" << (*nei).second << endl;\n            if (nei == s.end() || (*nei).first != -tmp)\n            {\n                cout << -1 << endl;\n                exit(0);\n            }\n            par[v] = (*nei).second;\n            //cout << v << \" \" << par[v] << endl;\n            cnt[(*nei).second] += cnt[v];\n        }\n        else\n        {\n            root = v;\n            maxi = w;\n        }\n    }\n    for (long long i = 0; i < n; i++)\n    {\n        if (i == root)\n        {\n            continue;\n        }\n        graph[i].push_back(par[i]);\n        graph[par[i]].push_back(i);\n    }\n    dfs(root);\n    if (check != maxi)\n    {\n        cout << -1 << endl;\n        //exit(0);\n    }\n    for (long long i = 0; i < n - 1; i++)\n    {\n        cout << edge[i].first + 1 << \" \" << edge[i].second + 1 << endl;\n    }\n    \n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EB emplace_back\n\ntypedef long long ll;\ntypedef std::pair <int, int> pr;\nconst int N = 100054;\n\nint n;\nint o[N], size[N];\nint p[N], fc[N], nc[N];\nll D[N];\nstd::vector <pr> edges;\n\ninline bool Dcmp(const int x, const int y) {return D[x] > D[y];}\n\ninline bool find(ll x, int &ret) {return *D = x, ret = std::lower_bound(o, o + n, 0, Dcmp) - o, D[o[ret]] == x;|\n\ninline void link(int x, int px) {p[x] = px, nc[x] = fc[px], fc[px] = x, size[px] += size[x];}\n\nvoid dfs(int x, int d) {*D += d; for (int y = fc[x]; y; y = nc[y]) dfs(y, d + 1);}\n\nint main() {\n\tint i, j, u;\n\tscanf(\"%d\", &n), std::iota(o, o + n, 1);\n\tfor (i = 1; i <= n; ++i) scanf(\"%lld\", D + i);\n\tstd::sort(o, o + n, Dcmp), std::fill(size + 1, size + (n + 1), 1);\n\tfor (i = 0; i < n - 1; link(u, o[j]), ++i)\n\t\tif (u = o[i], !find(D[u] + 2 * size[u] - n, j) || j <= i) return puts(\"-1\"), 0;\n\tif (dfs(o[i], *D = 0), *D != D[o[i]]) return puts(\"-1\"), 0;\n\tfor (i = 1; i <= n; ++i) if (p[i]) edges.EB(std::minmax(i, p[i]));\n\tstd::sort(edges.begin(), edges.end());\n\tfor (const pr &e : edges) printf(\"%d %d\\n\", e.first, e.second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+5;\nint n,f[N],si[N];\nstruct node\n{\n    ll x;\n    int id;\n    bool operator<(const node&o)const\n    {\n        return x<o.x;\n    }\n}a[N];\nunordered_map<ll,int>mp;\nvector<pair<int,int> >v;\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%lld\",&a[i].x),a[i].id=i;\n    sort(a+1,a+1+n);\n    for(int i=1;i<=n;i++) si[i]=1,f[i]=a[i].id,mp[a[i].x]=i;\n    for(int i=n;i>1;i--)\n    {\n        ll t=a[i].x+si[i]-(n-si[i]);\n        if(mp[t]&&mp[t]!=i) v.push_back({i,mp[t]}),si[mp[t]]+=si[i];\n    }\n    if(si[1]!=n) {printf(\"-1\\n\");return 0;}\n    else for(int i=0;i<v.size();i++)\n        printf(\"%d %d\\n\",f[v[i].first],f[v[i].second]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXn = 1e5 + 10;\ntypedef pair<long long, int> pii;\npii ar[MAXn];\nlong long n, sz[MAXn], root, disroot, d[MAXn], hp3[MAXn];\nvector<int> vec[MAXn];\nvector<pii> ans;\n\nbool cmp(pii p1, pii p2) {\n\treturn p1.first > p2.first;\n}\n\nlong long dfs1(int v, int  par) {\n\tlong long res = 0;\n\tfor (int i = 0; i < vec[v].size(); i++)\n\t\tif (vec[v][i] != par) {\n\t\t\tres += dfs1(vec[v][i], v) + hp3[vec[v][i]];\n\t\t\thp3[v] += hp3[vec[v][i]];\n\t\t}\n\thp3[v]++;\n\treturn res;\n\t\n}\n\nvoid dfs2(int v, int par, int sth) {\n\tif (sth != d[v]) {\n\t\tcout << -1 << sth;\n\t\texit(0);\n\t}\n\tfor (int i = 0; i < vec[v].size(); i++) {\n\t\tif (vec[v][i] != par) {\n\t\t\tdfs2(vec[v][i], v, sth - (hp3[vec[v][i]]) + (hp3[0] - hp3[vec[v][i]]));\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}\nint main() {\n\tcin >> n;\n\tfill_n(sz, MAXn, 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tint di;\n\t\tcin >> di;\n\t\td[i] = di;\n\t\tar[i].first = di;\n\t\tar[i].second = i;\n\t}\n\tsort(ar, ar + n);\n\tfor (int i = n - 1; i >= 1; i--) {\n\t\tlong long hp = ar[i].first - n;\n\t\thp += 2 * sz[i];\n\t\tint hp2 = lower_bound(ar, ar + n, pii(hp, -1)) - ar;\n\t\tif (ar[hp2].first != hp)\n\t\t\treturn cout << -1,0;\n\t\tsz[hp2]+= sz[i];\n\t\tvec[ar[hp2].second].push_back(ar[i].second);\n\t\tvec[ar[i].second].push_back(ar[hp2].second);\n\t\tans.push_back(pii(ar[i].second, ar[hp2].second));\n\t}\n\tdisroot = dfs1(0, -1);\n\tdfs2(0, -1, disroot);\n\tfor (int i = 0; i < ans.size(); i++)\n\t\tcout << ans[i].first + 1<< ' ' << ans[i].second + 1<< endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int N=1e5+5;\nint n;\nlong long d[N],cur[N];\nint id[N],sz[N],par[N];\nbool cmp(int a,int b){return d[a]>d[b];}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&d[i]);\n\t\tid[i]=i;\n\t\tsz[i]=1;\n\t}\n\tsort(id+1,id+n+1,cmp);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tlong long dpar=d[id[i]]+sz[id[i]]-(n-sz[id[i]]);\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t\tif (dpar==d[id[j]])\n\t\t\t{\n\t\t\t\tpar[id[i]]=id[j];\n\t\t\t\tcur[id[j]]+=cur[id[i]]+sz[id[i]];\n\t\t\t\tsz[id[j]]+=sz[id[i]];\n\t\t\t}\n\t}\n\tif (cur[id[n]]!=d[id[n]])\n\t\tprintf(\"-1\\n\");\n\telse\n\t\tfor (int i=1;i<n;i++)\n\t\t\tprintf(\"%d %d\\n\",id[i],par[id[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\n\nconst int maxn = 1e5 + 5;\n\nint par[maxn], N, sub[maxn];\nii d[maxn];\n\nsigned main(void)\n{\n  ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n  if(fopen(\"A.INP\", \"r\")){\n    freopen(\"A.INP\", \"r\", stdin);\n    freopen(\"A.OUT\", \"w\", stdout);\n  }\n  cin >> N;\n  for(int i = 1; i <= N; ++i){\n    cin >> d[i].fi;\n    d[i].se = i;\n    sub[i] = 1;\n  }\n  sort(d + 1, d + 1 + N);\n  for(int i = N; i >= 2; --i){\n    int j = lower_bound(d + 1, d + 1 + N, mp(d[i].fi - (N - 2 * sub[d[i].se]), -1)) - d;\n    if(d[j].fi != d[i].fi - (N - 2 * sub[d[i].se])){\n      cout << -1;\n      return 0;\n    }\n    par[d[i].se] = d[j].se;\n    sub[d[j].se] += sub[d[i].se];\n  }\n  for(int i = 1; i <= N; ++i){\n    if(par[i]) cout << i << ' ' << par[i] << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <map>\n#define __DEBUG__\n#undef __DEBUG__\n#define MAXN 100005\n\nusing namespace std;\n\nint main(){\n    int N;\n    pair<int,int> D[MAXN];//D,ソートする前のノードの番号\n    int Chi[MAXN];\n    map<int,int> Ds;//D,ソート後のノードの番号 配列の逆(Dから配列のindexを探しやすくするため)\n    map<int,int>::iterator it;\n    cin>>N;\n    for(int i = 0;i < N;i++){\n        cin>>D[i].first;\n        D[i].second=i+1;\n        Chi[i]=1;\n    }\n    sort(D,D+N,greater<pair<int,int> >());\n    for(int i = 0;i < N;i++){\n        Ds[D[i].first]=i;\n    }\n#ifdef __DEBUG__\n    cout<<\"sorted:\"<<endl;\n    for(int i = 0;i < N;i++){\n        cout<<D[i].first<<\",\"<<D[i].second<<\"/\";\n    }\n#endif\n    for(int i = 0;i < N-1;i++){\n        int Dj = D[i].first+Chi[i]*2-N;\n        if(it = Ds.find(Dj),it==Ds.end()){\n            cout<<-1<<endl;\n            return 0;\n        }\n        int j = it->second;\n        Chi[j]+=Chi[i];\n        cout<<D[i].second<<\" \"<<D[j].second<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<vector>\n#include<queue>\n#include<deque>\n#define ll long long\n#define mp make_pair\n#include<bits/stdc++.h> \n#define rep(i,x,y) for(int i=(x);i<=(y);++i)\n#define r0p(i,n) for(int i=0;i<n;++i)\n#pragma GCC optimize(1)\n#pragma G++ optimize(1)\n#pragma GCC optimize(2)\n#pragma G++ optimize(2)\n#pragma GCC optimize(3)\n#pragma G++ optimize(3)\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#define pii pair<int,int>\n#pragma GCC diagnostic error \"-std=c++11\"\nusing namespace std;\ninline void rdl(long long &val){\n    long long x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n\t}\n\twhile(ch>='0' and ch<='9'){\n\t    x=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n    val=x*f;\n}\ninline void rdi(int &val){\n    int x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    val=x*f;\n}\ninline long long rdl(){\n    long long x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline int rdi(){\n    int x=0;\n    int f=1;\n\tchar ch=getchar();\n\twhile((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n\tif(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline void write(int x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\ninline void _write(int x){\n\twrite(x);\n\tputchar(' ');\n}\ninline void print(int x){\n\twrite(x);\n\tputchar('\\n');\n}\ninline void write(ll x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\ninline void _write(ll x){\n\twrite(x);\n\tputchar(' ');\n}\ninline void print(ll x){\n\twrite(x);\n\tputchar('\\n');\n}\nstruct dsu{\n\tint par[200200];\n\tinline void init(int _n){for(int i=0;i<_n;++i) par[i]=i;}\n\tinline int find(int now){\n\t\tif(par[now]==now) return now;\n\t\treturn par[now]=find(par[now]);\n\t}\n\tinline bool uni(int a, int b){\n\t\tint Pa(find(a)),Pb(find(b));\n\t\tif(Pa==Pb) return false;\n\t\tpar[Pa]=Pb;\n\t\treturn true;\n\t}\n};\nint main(){\n\tint n,i,j;\n\trdi(n);\n\tvector<ll> d(n);\n\tvector<int> sz(n,1);\n\tmap<ll,int> m;\n\tfor(i=0;i<n;++i){\n\t\trdl(d[i]);\n\t\tm[d[i]]=i;\n\t}\n\tvector<pair<int,int> >ans;\n\tfor(int It=0;It<n-1;++It){\n\t\tauto it=m.begin();\n\t\ti=it->second;\n\t\tll need=d[i]-(n-sz[i])+sz[i];\n\t\tif(m.find(need)==m.end()) return 0*puts(\"-1\");\n\t\tj=m[need];\n\t\tans.emplace_back(i,j);\n\t\tsz[i]+=sz[j];\n\t\tm.erase(--m.end());\n\t}\n\tvector<ll> rd(n,-1);\n\trd[0]=0;\n\tvector<vector<int> >g(n);\n\tfor(auto p:ans){\n\t\tg[p.first].push_back(p.second);\n\t\tg[p.second].push_back(p.first);\n\t}\n\tvector<int> q(1,0);\n\tfor(i=0;i<q.size();++i){\n\t\tfor(int j:g[q[i]]){\n\t\t\tif(rd[j]==-1){\n\t\t\t\tq.push_back(j);\n\t\t\t\trd[j]=rd[q[i]]+1;\n\t\t\t}\n\t\t}\n\t}\n\tif(accumulate(rd.begin(),rd.end(),0ll)!=d[0]) return puts(\"-1\")*0;\n\tfor(pair<int,int>p:ans) _write(p.first),print(p.second);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#define Maxn 1000008 \nusing namespace std;\ntypedef long long ll;\n\nll n;\nll d;\nll son[Maxn];\nmap <ll,ll> M;\n\nstruct node{\n\tll num;\n\tll val;\n}N[Maxn];\n\nbool cmp(node a,node b){\treturn a.val > b.val;}\n\nint main()\n{\n\tmemset(son,0,sizeof(son));\n\tscanf(\"%lld\",&n);\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\tscanf(\"%lld\",&d);\n\t\tM[d] = i;\n\t\tN[i].num = i,N[i].val = d;\n\t}\n\tsort(N+1,N+1+n,cmp);\n\tmap<ll,ll>::iterator iter;;\n\tfor(int i = 1;i < n;i ++)\n\t{\n\t\tll u = N[i].num;\n\t\tif((N[i].val - n + 2LL + (son[u] << 1)) < N[n].val) continue;\n\t\titer = M.find(N[i].val - n + 2 + (son[u] << 1));\n\t\tif(iter == M.end()) continue;\n\t\tll v = iter->second;\n\t\tson[v] += son[u]+1;\n\t\tprintf(\"%lld %lld\\n\",u,v);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nmap<int,int> M1,M2,W1;\nint s1[200010],pa[200010];\nsigned main()\n{\n\tint n=read();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=read();\n\t\tM1[x]=i; M2[x]=1;\n\t\ts1[i]=x; W1[x]=0;\n\t}\n\tsort(s1+1,s1+1+n);\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tint id=M1[s1[i]],sz=M2[s1[i]],td=s1[i]+2*sz-n;\t\n\t\tif(td==s1[i]) continue;\t\n\t\tpa[id]=M1[td]; M2[td]+=sz; W1[td]+=W1[s1[i]]+sz;\n\t}\n\tif(M2[s1[1]]!=n||W1[s1[1]]!=s1[1]) puts(\"-1\"),exit(0);\n\tfor(int i=1;i<=n;i++) if(pa[i])\n\t\tprintf(\"%lld %lld\\n\",i,pa[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100005\n#define rep(i,n) for((i)=0;(i)<(n);(i)++) \n#define LL long long\n#define pii pair<LL,int>\n#define F first\n#define S second\n#define pb push_back\n\nint i;\nint n;\npii d[N];\nmap<LL,int> mp;\nmap<pii,bool> KK;\nbool vis[N];\nint last;\nLL len,now;\nvector<pii> ans;\n\nint main()\n{\n\t\n\tcin>>n;\n\trep(i,n)\n\t{\n\t\tcin>>d[i].F;\n\t\td[i].S=i;\n\t}\n\tsort(d,d+n);\n\tfor(int j=0,k=n-1;j<k;j++,k--)\n\t\tswap(d[j],d[k]);\n\trep(i,n)\n\t\tmp[d[i].F]=d[i].S;\n\t\n\trep(i,n)\n\t{\n\t\tif(vis[d[i].S]) continue;\n\t\tvis[d[i].S]=1;\n\t\tlast=d[i].S;\n\t\tlen=n;\n\t\tnow=d[i].F;\n\t\twhile(1)\n\t\t{\n\t\t\tlen-=2;\n\t\t\tnow-=len;\n\t\t\tif(now<d[n-1].F || len<0) break;\n\t\t\tif(mp.find(now)==mp.end())\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(!KK[make_pair(last+1,mp[now]+1)]) ans.pb(make_pair(last+1,mp[now]+1));\n\t\t\tif(last==mp[now])\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t} \n\t\t\tKK[make_pair(last+1,mp[now]+1)]=1;\n\t\t\tKK[make_pair(mp[now]+1,last+1)]=1;\n\t\t\tlast=mp[now];\n\t\t\tvis[last]=1;\n\t\t}\n\t}\n\trep(i,ans.size())\n\t\tcout<<ans[i].F<<\" \"<<ans[i].S<<'\\n';\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define y1 dmytxdy\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef long double ld;\n\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,1:0;}\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,1:0;}\n\nll readint(){\n\tll x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nint n,tot;\nint v[100005],nxt[100005],h[100005],dep[100005],siz[100005];\npll a[100005];\nvector<pii> ans;\n\nvoid addedge(int x,int y){v[++tot]=y; nxt[tot]=h[x]; h[x]=tot;}\n\nvoid dfs(int u){\n\tfor(int p=h[u];p;p=nxt[p]){\n\t\tdep[v[p]]=dep[u]+1;\n\t\tdfs(v[p]);\n\t}\n}\n\nint main(){\n\tn=readint();\n\tfor(int i=1;i<=n;i++) a[i]=mp(readint(),i);\n\tfor(int i=1;i<=n;i++) siz[i]=1;\n\tsort(a+1,a+n+1);\n\tfor(int i=n;i>=2;i--){\n\t\tll tmp=a[i].fi-(n-2*siz[i]);\n\t\tint x=lower_bound(a+1,a+n+1,mp(tmp,0ll))-a;\n\t\tans.pb(mp(a[x].se,a[i].se));\n\t\taddedge(a[x].se,a[i].se);\n\t\tsiz[x]+=siz[i];\n\t}\n\tdfs(a[1].se);\n\tll sum=0;\n\tfor(int i=1;i<=n;i++) sum+=dep[i];\n\tif(sum!=a[1].fi) return printf(\"-1\\n\"),0;\n\tfor(auto r:ans) printf(\"%d %d\\n\",r.fi,r.se);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for (int i = (a); i <= (b); ++i)\n#define drep(i,a,b) for (int i = (a); i >= (b); --i)\n#define grep(i,u) for (int i = head[u],v = e[i].v; i; v = e[i = e[i].nxt].v)\n#define il inline\n#define LL long long\n#define ULL unsigned LL\n#define pb push_back\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define fi first\n#define se second\nusing namespace std;\nil LL read() {\n\tLL res = 0,f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -f; ch = getchar();}\n\twhile (isdigit(ch)) {res = res*10+ch-'0'; ch = getchar();} return res*f;\n}\nnamespace qiqi {\n\tconst int N = 1e5+5; int n,siz[N],fa[N]; pair<LL,int> a[N];\n\tvoid main() {\n\t\tint x; LL d = 0; n = read(); rep(i,1,n) {a[i] = mp(read(),i); siz[i] = 1;} sort(a+1,a+n+1);\n\t\tdrep(i,n,2) {x = upper_bound(a+1,a+n+1,mp(a[i].fi-n+siz[i]*2,0))-a; if (a[x].fi != a[i].fi-n+siz[i]*2) {puts(\"-1\"); return;} siz[fa[i] = x] += siz[i]; d += siz[i];}\n\t\tif (d != a[1].fi) {puts(\"-1\"); return;} rep(i,2,n) printf(\"%d %d\\n\",a[i].se,a[fa[i]].se);\n\t}\n}\nint main() {\n\tqiqi::main(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cassert>\n#include<iostream>\n#include<algorithm>\n#include<unordered_map>\n\nusing namespace std;\n\n#define Whats(x) cout<<#x<<\" is \"<<(x)<<endl\n#define DivHim() cout<<\">>>>>>>>>>>>>>>\"<<endl\n#define DivHer() cout<<\"<<<<<<<<<<<<<<<\"<<endl\n#define Oops() cout<<\"!!!!!!!!!!!!!!!\"<<endl\n\ntemplate<typename T> bool GetMin(T &a,T b)\n{\n\treturn ((a<=b)?false:(a=b,true));\n}\n\ntemplate<typename T> bool GetMax(T &a,T b)\n{\n\treturn ((a>=b)?false:(a=b,true));\n}\n\n/*\n\t -<Unlimited Blade Works>-\n */\n\n#define int long long\n\nconst int N=1e5+10;\n\nint n,d[N],id[N],sz[N],fa[N],dp[N];\nunordered_map<int,int> re;\n\nbool Cmp(int x,int y)\n{\n\treturn d[x]>d[y];\n}\n\nsigned main()\n{\n\tscanf(\"%lld\",&n);\n\tif(n==2)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%lld\",d+i);\n\t\tre[d[i]]=i;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tid[i]=i;\n\t\tsz[i]=1;\n\t}\n\tsort(id+1,id+n+1,Cmp);\n\tfor(int i=1,u,v,x;i<n;++i)\n\t{\n\t\tre[d[u=id[i]]]=0;\n\t\tif((x=sz[u]+sz[u]-n)>=0||!(v=re[d[u]+x]))\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsz[fa[u]=v]+=sz[u];\n\t\tdp[fa[u]]+=dp[u]+sz[u];\n\t}\n\tif(dp[id[n]]!=d[id[n]])\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tif(fa[i])\n\t\t\tprintf(\"%lld %lld\\n\",fa[i],i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nThough leaves are many, the root is one;\nThrough all the lying days of my youth\nI swayed my leaves and flowers in the sun,\nNow may I wither into the truth.\n\n- William Butler Yeats\n*/\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <string.h>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <cassert>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <sstream>\n#include <functional>\n#include <iomanip>\n#include <bitset>\n//#include <windows.h>  //Should be deleted when using AtCoder&POJ\nusing namespace std;\n\n#define ll long long\n#define pii pair<int,int>\n#define qi ios::sync_with_stdio(0)\n/**==Info==\n*Program:6\n*Problem:Distance Sums\n*Date:2019-7-12\n*Algorithm:Orange Boy's Greedy and Sorting\n*Stats:WA*/\n\nbool debug=false;\n\n\ntemplate<typename T1,typename T2> ostream& operator<<(ostream& o,pair<T1,T2> p){\n\to<<\"{\";\n\to<<p.first<<\",\"<<p.second;\n\to<<\"}\";\n\treturn o;\n}\n\nll n;\nll d[100005];\nmap <ll,ll> m;\npair<ll,ll> p[100005];\nll sub[100005];\nll sz[100005];\nvector <pair<ll,ll> >res;\n \n int fa[100005];\n \nint getFa(int x){\n\tif(fa[x]==x){\n\t\treturn x;\n\t}\n\treturn fa[x]=getFa(fa[x]);\n}\n \n \nvoid Union(int a,int b){\n\tif(fa[a]==fa[b]){\n\t\treturn;\n\t}\n\tfa[getFa(a)]=getFa(b);\n}\n\nll dp[100005];\n\nll dis[100005];\n\nvector<int> nei[100005];\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin>>n;\n\tfor(ll i=0;i<n;i++)\n\t{\n\t\tcin>>d[i];\n\t\tif(d[i]>n*(n-1)/2){\n\t\t\tcout<<-1;\n\t\t\treturn 0;\n\t\t}\n\t\tm[d[i]]=i;\n\t\tp[i].first=d[i];\n\t\tp[i].second=i;\n\t\tsz[i]=1;\n\t}\n\tsort(p,p+n);\n\treverse(p,p+n);\n\tmemset(sub,-1,sizeof(sub));\n\tfor(ll i=0;i<n-1;i++)\n\t{\n\t\tll de=p[i].first;\n\t\tll x=p[i].second;\n\t\tsub[x]=n-sz[x]*2;\n\t\tif(sub[x]==0){\n\t\t\tcout<<-1;\n\t\t\treturn 0;\t\n\t\t}\n\t\tif(m.find(de-sub[x])==m.end()){\n\t\t\tcout<<-1;\n\t\t\treturn 0;\n\t\t}\n\t\tll par=m[de-sub[x]];\n\t\tsz[par]+=sz[x];\n\t\tdp[par]+=dp[x]+sz[x];\n\t\tres.push_back(make_pair(x,par));\n\t}\n\t\n\tfor(int i=0;i<n-1;i++){\n\t\tnei[res[i].first].push_back(res[i].second);\n\t\tnei[res[i].second].push_back(res[i].first);\n\t}\n\t\n\tqueue<int> q;\n\tmemset(dis,-1,sizeof(dis));\n\tq.push(p[n-1].second);\n\tdis[p[n-1].second]=0;\n\t\n\twhile(!q.empty()){\n\t\tint last=q.front();\n\t\tq.pop();\n\t\t\n\t\tfor(int to:nei[last]){\n\t\t\tif(dis[to]==-1){\n\t\t\t\tdis[to]=dis[last]+1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll sm=0;\n\tfor(int i=0;i<n;i++){\n\t\tsm+=dis[i];\n\t}\n\tif(sm!=p[n-1].first){\n\t\tcout<<-1;\n\t\treturn 0;\n\t}\n\t\n\tfor(ll i=0;i<n-1;i++)\n\t{\n\t\tcout<<res[i].first+1<<\" \"<<res[i].second+1<<endl;\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main()\n{ \ncout<<\"-1\"<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "15\n57\n62\n47\n45\n42\n74\n90\n75\n54\n50\n66\n63\n77\n87\n51\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<math.h>\n#include<stdlib.h>\n#include<set>\n#include<bitset>\n#include<map>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<complex>\n#include<list>\n#include<limits.h>\nusing namespace std;\n\nconst int N=1e5+5;\ntypedef pair<int,int> pii;\nint n;\npair<long long,int> a[N];\nint sz[N];\nlong long dp[N];\nvector<pii> vp;\nmap<long long,int> mp;\n\nvoid lnk(int x,int y){\n\tvp.push_back(make_pair(x,y));\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%I64d\",&a[i].first);\n\t\ta[i].second=i;\n\t}\n\tsort(a+1,a+1+n);\n\treverse(a+1,a+1+n);\n\tfor(int i=1;i<=n;i++) mp[a[i].first]=i;\n\tfor(int i=1;i<=n;i++) sz[i]=1;\n\tfor(int i=1;i<n;i++){\n\t\tint nxt=mp[a[i].first-1ll*n+2ll*sz[i]];\n//\t\tprintf(\"%d %d\\n\",i,nxt);\n\t\tdp[nxt]+=dp[i]+1ll*sz[i];\n//\t\tprintf(\" %lld %lld %d\\n\",dp[i],dp[nxt],sz[i]);\n\t\tsz[nxt]+=sz[i];\n\t\tlnk(a[i].second,a[nxt].second);\n\t}\n\tif(vp.size()!=n-1||dp[n]!=a[n].first) puts(\"-1\");\n\telse for(int i=0;i<vp.size();i++) printf(\"%d %d\\n\",vp[i].first,vp[i].second);\n\treturn 0;\n}\n\n/*\n数据不清空，爆零两行泪\n读题不认真，爆零两行泪\n分析不仔细，爆零两行泪\n建树不构造，爆零两行泪\n变量不统一，爆零两行泪\n边界不算清，爆零两行泪\n数组不开大，爆零两行泪\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int Maxn = 100005;\n\nint n, id[Maxn];\nint par[Maxn], sz[Maxn];\nlong long a[Maxn];\nmap<long long, int> mp;\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%lld\", a + i);\n    id[i] = i, sz[i] = 1;\n    mp[a[i]] = i;\n  }\n  sort(id + 1, id + n + 1, [&](const int &x, const int &y)->bool {\n    return a[x] > a[y];\n  });\n  for (int i = 1; i < n; ++i) {\n    int now = id[i];\n    par[now] = mp[a[now] - n + 2 * sz[now]];\n    if (!par[now]) return puts(\"-1\") & 0;\n    sz[par[now]] += sz[now];\n  }\n  long long sum = 0;\n  for (int i = 1; i < n; ++i) sum += sz[id[i]];\n  if (sum != a[id[n]]) return puts(\"-1\") & 0;\n  for (int i = 1; i < n; ++i)\n    printf(\"%d %d\\n\", id[i], par[id[i]]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n#include <bits/stdc++.h>\n\n#define endl '\\n'\n#define int ll\nusing namespace std;\ntypedef long long ll;\n\nclass DisjointSet\n{\nprivate:\n    vector<int> pa, sz;\n\npublic:\n    void init(int n)\n    {\n        pa.resize(n), sz.resize(n);\n        for(int i = 0; i < n; i++)\n        {\n            pa[i] = i, sz[i] = 1;\n        }\n    }\n    int findrt(int x)\n    {\n        if(x == pa[x]) return x;\n        else return pa[x] = findrt(pa[x]);\n    }\n    bool same(int x, int y) { return findrt(x) == findrt(y); }\n    int ccSize(int x) { return sz[findrt(x)]; }\n    void uni(int x, int y)\n    {\n        x = findrt(x), y = findrt(y);\n        if(x == y) return;\n        if(sz[x] > sz[y]) swap(x, y);\n        pa[x] = y, sz[y] += sz[x];\n    }\n};\n\nconst int N = 100005;\n\nint vn;\nvector<ll> arr;\nmap<ll, int> val2idx;\n\nvoid init();\nvoid process();\n\nint32_t main()\n{\n    ios::sync_with_stdio(false); cin.tie(0);\n    init();\n    process();\n    cout.flush();\n    return 0;\n}\n\nvoid init()\n{\n    cin >> vn;\n    arr.resize(vn);\n    for(int i = 0; i < vn; i++) cin >> arr[i];\n    sort(arr.begin(), arr.end());\n    for(int i = 0; i < vn; i++) val2idx[arr[i]] = i;\n}\n\nvoid dfs(int idx, vector<int> tree[])\n{\n    static vector<bool> vis(vn, false);\n    vis[idx] = true;\n    for(auto c:tree[idx])\n    {\n        if(vis[c]) continue;\n        cout << idx+1 << \" \" << c+1 << endl;\n        dfs(c, tree);\n    }\n}\n\nvoid process()\n{\n    vector<int> tree[N]; \n    DisjointSet ds; ds.init(vn);\n    for(int i = vn-1; i >= 0; i--)\n    {\n        if(ds.ccSize(i) == 1)\n        {\n            int idx = i;\n            while(true)\n            {\n                ll paVal = arr[idx] - vn + 2*ds.ccSize(idx);\n                if(val2idx.count(paVal) == 0) break;\n                int paidx = val2idx[paVal];\n                if(ds.same(idx, paidx)) break;\n                tree[idx].push_back(paidx);\n                tree[paidx].push_back(idx);\n                ds.uni(idx, paidx);\n                idx = paidx;\n            }\n        }\n    }\n    if(ds.ccSize(0) == vn)\n    {\n        dfs(0, tree);\n    }\n    else cout << -1 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #includes {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define LET(x,a) __typeof(a) x(a)\n//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)\n#define ALL(c) (c).begin(), (c).end()\n#define MP make_pair\n\n#define EXIST(e,s) ((s).find(e)!=(s).end())\n\n#define RESET(a) memset((a),0,sizeof(a))\n#define SET(a) memset((a),-1,sizeof(a))\n#define PB push_back\n#define DEC(it,command) __typeof(command) it=command\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define debug_v(x) cerr << #x << \" = [\";REP(__ind,(x).size()){cerr << (x)[__ind] << \", \";}cerr << \"] (L\" << __LINE__ << \")\" << endl;\n\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\n\ntypedef long long Int;\ntypedef unsigned long long uInt;\ntypedef long double rn;\n\ntemplate<class T>\nT inf(){\n\treturn numeric_limits<T>::has_infinity?numeric_limits<T>::infinity():(numeric_limits<T>::max()/2);\n}\n\ntypedef pair<int,int> pii;\n\n/*\n#ifdef MYDEBUG\n#include\"debug.h\"\n#include\"print.h\"\n#endif\n*/\n// }}}\n\n\n//{{{ io\nFILE *file_in=stdin,*file_out=stdout;\n#define fin normal_in\n#define fout normal_out\n//const char fname[]=\"\";\n//FILE *fin=fopen(fname,\"r\"),*fout=fopen(fname,\"w\");\n#ifdef __MINGW32__\n#define LLD \"%I64d\"\n#define LLU \"%I64u\"\n#else\n#define LLD \"%lld\"\n#define LLU \"%llu\"\n#endif\nstruct NORMAL_IN{\n\tbool cnt;\n\tNORMAL_IN():cnt(true){}\n\toperator int() const {return cnt;}\n#define endl \"\\n\"\n\tNORMAL_IN& operator>>(int &n){cnt=fscanf(file_in,\"%d\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(unsigned int &n){cnt=fscanf(file_in,\"%u\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(long long &n){cnt=fscanf(file_in,LLD,&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(unsigned long long &n){cnt=fscanf(file_in,LLU,&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(double &n){cnt=fscanf(file_in,\"%lf\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(long double &n){cnt=fscanf(file_in,\"%Lf\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(char *c){cnt=fscanf(file_in,\"%s\",c)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(string &s){\n\t\ts.clear();\n\t\tfor(bool r=false;;){\n\t\t\tconst char c=getchar();\n\t\t\tif(c==EOF){ cnt=false; break;}\n\t\t\tconst int t=isspace(c);\n\t\t\tif(!r and !t)r=true;\n\t\t\tif(r){\n\t\t\t\tif(!t)s.push_back(c);\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\t\tNORMAL_IN& operator>>(vector<T> &v){\n\t\t\tint v_size = v.size();\n\t\t\tREP(i,v_size){\n\t\t\t\t*this>>v[i];\n\t\t\t}\n\t\t\treturn *this;\n\t\t}\n} normal_in;\n\nstruct NORMAL_OUT{\n\tNORMAL_OUT& operator<<(const int &n){fprintf(file_out,\"%d\",n);return *this;}\n\tNORMAL_OUT& operator<<(const unsigned int &n){fprintf(file_out,\"%u\",n);return *this;}\n\tNORMAL_OUT& operator<<(const long long &n){fprintf(file_out,LLD,n);return *this;}\n\tNORMAL_OUT& operator<<(const unsigned long long &n){fprintf(file_out,LLU,n);return *this;}\n\tNORMAL_OUT& operator<<(const double &n){fprintf(file_out,\"%lf\",n);return *this;}\n\tNORMAL_OUT& operator<<(const long double &n){fprintf(file_out,\"%Lf\",n);return *this;}\n\tNORMAL_OUT& operator<<(const char c[]){fprintf(file_out,\"%s\",c);return *this;}\n\tNORMAL_OUT& operator<<(const string &s){fprintf(file_out,\"%s\",s.c_str());return *this;}\n} normal_out;\nstruct ERR_OUT{\n\ttemplate<class T>\n\t\tERR_OUT& operator<<(const T &a){\n\t\t\tcerr<<\"\\x1b[7m\"<<a<<\"\\x1b[m\";\n\t\t\treturn *this;\n\t\t}\n} ferr;\n//}}}\n\n//{{{ Graph<Weight> g(size); addEdge(g,{src,dst},weight); matrix<Weight> A(n,m);\ntypedef int Node;\ntemplate<class Weight>\nstruct edge {\n\tint src, dst;\n\tWeight weight;\n\tint rev;\n\tedge(int src, int dst, Weight weight=1,int rev=-1) :\n\t\tsrc(src), dst(dst), weight(weight), rev(rev){ }\n};\ntemplate<class Weight>\nbool operator < (const edge<Weight> &e, const edge<Weight> &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\t\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n//typedef vector<edge> edges;\n//typedef vector<edges> Graph;\n \ntemplate<class Weight>\nstruct matrix:vector<vector<Weight> >{\n\tmatrix(const array<int,2> &a, Weight w=0):vector<vector<Weight> >(a[0],vector<Weight>(a[1],w)){}\n\tmatrix(const array<int,1> &a, Weight w=0):vector<vector<Weight> >(a[0],vector<Weight>(a[0],0)){}\n\tmatrix(){}\n};\n \ntemplate<class Weight>\nstruct graph:vector<vector<edge<Weight> > >{\n\tWeight inf{::inf<Weight>()};\n\tgraph(){}\n\tgraph(const int &n):vector<vector<edge<Weight> > >(n){}\n\tvoid _add_edge(int from, int to, Weight w, int rev=-1){\n\t\tif((int)this->size() < from + 1)this->resize(from + 1);\n\t\tthis->at(from).push_back(edge<Weight>(from,to,w,rev));\n\t}\n};\n//add bi-directional edge\ntemplate<class Weight>\nvoid addBiEdge(graph<Weight> &g, const pair<int,int> &e, Weight w=1){\n\tconst int &from = e.first, &to = e.second;\n\tg._add_edge(from,to,w,g[to].size());\n\tg._add_edge(to,from,w,g[from].size()-1);\n}\n//add directional edge\ntemplate<class Weight>\nvoid addEdge(graph<Weight> &g, const pair<int,int> &e, Weight w=1){\n\tconst int &from = e.first, &to = e.second;\n\tg._add_edge(from,to,w);\n}\n \ntypedef int Weight;\ntypedef edge<Weight> Edge;\ntypedef vector<edge<Weight> > Edges;\ntypedef graph<Weight> Graph;\ntypedef matrix<Weight> Matrix;\n \n#ifdef DEBUG\n#include\"graph/graphviz.h\"\n#endif\n//}}}\n\nInt N;\nvector<Int> D;\nGraph G;\n\nInt dfs(int u,int level = 0,int p = -1){\n\tInt ret = level;\n\tfor(auto &&e:G[u]){\n\t\tif(e.dst==p)continue;\n\t\tret += dfs(e.dst,level+1,u);\n\t}\n\treturn ret;\n}\n\nvoid solve(){\n\tvector<pii> e;\n\tsort(ALL(D));\n\treverse(ALL(D));\n\tmap<Int,pair<int,int>> mp;//id, num of child\n\tREP(u,D.size()){\n\t\tmp[D[u]] = {u,1};\n\t}\n\tREP(u,D.size()-1){\n\t\tInt d = D[u];\n\t\tauto x = mp[d];\n\t\tInt d2 = d - (N - 2*x.second);\n\t\tauto it = mp.find(d2);\n\t\tif(it==mp.end()){\n\t\t\tfout<<-1<<endl;\n\t\t\treturn;\n\t\t}\n\t\tit->second.second+=x.second;\n\t\te.push_back({u,it->second.first});\n\t}\n\tG.assign(N,Edges());\n\tfor(auto &&p:e){\n\t\taddBiEdge(G,{p.first,p.second});\n\t}\n\tInt k = dfs(N-1);\n\tif(k!=D[N-1]){\n\t\tfout<<-1<<endl;\n\t\treturn;\n\t}\n\tREP(i,e.size()){\n\t\tfout<<e[i].first+1<<\" \"<<e[i].second+1<<endl;\n\t}\n\treturn;\n}\n\n//{{{ main function\nint main(){\t\n\t\n\tfin >> N;\n\tD.assign(N-1+1,Int());\n\tfor(int i = 0 ; i <= N-1 ; i++){\n\t\tfin >> D[i];\n\t}\n\tsolve();\n\treturn 0;\n}\n//}}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define forab(i, a, b) for(int i=(a);i<(b);++i)\n#define foreach(i, n) for (__typeof(n.begin()) i = n.begin(); i != n.end(); ++i)\n#define sqr(x) ((x)*(x))\n#define clr(a, b) memset(a, b, sizeof(a))\n#define MP make_pair\n#define PB push_back\n#define SZ(a) ((int)a.size())\n#define all(a) (a).begin(),(a).end()\n#define inf 0x3f3f3f3f\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst double eps = 1e-8;\nint dcmp(double x) { if (x < -eps) return -1; else return x > eps;}\n#define se(x) cout<<#x<<\" = \"<<x<<endl\n\n#ifdef CHEN_PC\n#define debug(...) printf(__VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\nconst int N = 100010;\nconst int mod = 1000000007; // 10^9+7\nint n;\npair<ll, int> d[N];\nint pnt[N];\nint cnt[N];\nmap<ll, int> dic;\n\nint solve() {\n    dic.clear();\n\tsort(d, d + n);\n\tforn (i, n) {\n\t\tpnt[i] = -1;\n\t\tcnt[i] = 1;\n\t\tdic[ d[i].first ] = i;\n\t}\n\tll dd = 0;\n\tfor (int i = n - 1; i > 0; --i) {\n\t    dd += cnt[i];\n\t\tint delta = n - cnt[i] * 2;\n\t\tll val = d[i].first - delta;\n\t\tif (delta == 0 || dic.find(val) == dic.end()) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tpnt[i] = dic[val];\n\t\tcnt[ pnt[i] ] += cnt[i];\n\t}\n//    debug(\"--- %d\\n\", dd);\n\tif (dd != d[0].first) {\n\t    puts(\"-1\");\n\t    return 0;\n\t}\n\tforn (i, n) {\n\t\tif (pnt[i] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tint u = d[i].second;\n\t\tint v = d[pnt[i]].second;\n\t\tprintf(\"%d %d\\n\", v, u);\n\t}\n\treturn 1;\n}\n\nint main(int argc, char *argv[]) {\n#ifdef CHEN_PC\n\tfreopen(\"F.in\", \"r\", stdin);\n#endif\n\n\twhile (scanf(\"%d\", &n) != EOF) {\n\t\tforn (i, n) {\n\t\t    ll tmp;\n\t\t\tscanf(\"%lld\", &tmp);\n\t\t\td[i] = MP(tmp, i + 1);\n\t\t}\n\t\tint ret = solve();\n//\t\tprintf(\"%d\\n\", ret);\n\n#ifdef CHEN_PC\n        puts(\"\");\n#endif\n\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\n#define R register\n#define ll long long\nconst int MAXN=1e5+10;\n\nint n;\nll D[MAXN];\nint siz[MAXN];\nmap<ll,int> loc;\nset<ll> st;\n\nstruct edge\n{\n\tint fr,to,next;\n}e[MAXN<<1];\nint tot;\nint head[MAXN];\nint dep[MAXN];\n\ninline void add(int x,int y)\n{\n\ttot++;\n\te[tot].fr=x;e[tot].to=y;e[tot].next=head[x];head[x]=tot;\n}\n\ninline void dfs(int x,int fx)\n{\n\tdep[x]=dep[fx]+1;\n\tfor(R int i=head[x];i;i=e[i].next)\n\t{\n\t\tint y=e[i].to;\n\t\tif(y==fx) continue;\n\t\tdfs(y,x);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(R int i=1;i<=n;i++) \n\t{\n\t\tscanf(\"%lld\",&D[i]);\n\t\tsiz[i]=1;\n\t\tloc[D[i]]=i;\n\t\tst.insert(D[i]);\n\t}\n\tint rt=0,cnt=0;\n\twhile(st.size()&&cnt<n-1)\n\t{\n\t\tll dx=*st.rbegin(),dy;\n\t\tint x,y;\n\t\tst.erase(dx);\n\t\tx=loc[dx];\n\t\tdy=dx+siz[x]*2-n;\n\t\ty=loc[dy];\n\t\tif(y==0) {printf(\"-1\\n\");return 0;}\n\t\tsiz[y]+=siz[x];\n\t\tadd(x,y);add(y,x);\n\t\tcnt++;\n\t}\n\trt=loc[*st.begin()];\n\tdfs(rt,0);\n\tll ans=0;\n\tfor(R int i=1;i<=n;i++) ans+=dep[i];\n\tif(ans-n!=D[rt]) {printf(\"-1\\n\");return 0;}\n\t\n\tfor(R int i=1;i<=tot;i+=2)\n\t{\n\t\tint x=e[i].fr,y=e[i].to;\n\t\tif(x>y) swap(x,y);\n\t\tprintf(\"%d %d\\n\",x,y);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,n) for (int i=1;i<=n;i++)\n#define REP(i,a,b) for (int i=a;i<=b;i++)\n \n#define pb push_back\n#define fi first\n#define se second\n#define pi pair<int,int>\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n \ntypedef long long ll;\n\nconst int inf=0x3f3f3f3f;\nconst ll linf=1e18;\nconst int N=200000+10;\nconst double eps=1e-5;\nconst int mo=1e9+7;\n\nint n;\nvector<int> v[N];\nint fa[N];\nll D[N];\nint sz[N];\nstruct node {\n\tint id;\n\tll v;\n} a[N];\nbool used[N];\nbool cmp(node x,node y) {\n\treturn x.v<y.v;\n}\nint F(int x) {\n\treturn (fa[x]==x)?x:(fa[x]=F(fa[x]));\n}\nint find(ll x) {\n\tint l=1,r=n;\n\tint mid;\n\twhile (l<=r) {\n\t\tmid=(l+r)>>1;\n\t\tif (a[mid].v<x) {\n\t\t\tl=mid+1;\n\t\t} else if (a[mid].v>x) {\n\t\t\tr=mid-1;\n\t\t} else return a[mid].id;\n\t}\n\treturn 0;\n}\nvoid dfs(int x,int s,int d,int f) {\n\tD[s]+=d;\n\tint t;\n\tfor (int i=0;i<(int)v[x].size();i++) {\n\t\tt=v[x][i];\n\t\tif (t!=f) {\n\t\t\tdfs(t,s,d+1,x);\n\t\t}\n\t}\n}\nbool check() {\n\tdfs(a[1].id,a[1].id,0,0);\n\tif (D[a[1].id]!=a[1].v) return 0;\n\treturn 1;\n}\nint main() {\n \n    std::ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tint x,y;\n\tFOR(i,n) {\n\t\tscanf(\"%lld\",&a[i].v);\n\t\ta[i].id=i;\n\t}\n\tsort(a+1,a+1+n,cmp);\n\tFOR(i,n) sz[i]=1,fa[i]=i;\n\tll t;\n\tfor (int i=n;i>=2;i--) {\n\t\tx=a[i].id;\n\t\tt=a[i].v-n+2*sz[x];\n\t\t//cout<<x<<\" \"<<t<<endl;\n\t\ty=find(t);\n\t\tif (F(x)==F(y)||used[y]||y==0) {\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tv[x].pb(y);\n\t\tv[y].pb(x);\n\t\tsz[y]+=sz[x];\n\t\tfa[F(x)]=F(y);\n\t\tused[x]=1;\n\t\t// used[x]=1表示x的所有儿子都已经找到了，之后如果还有点想插入x当儿子就是无解的 \n\t}\n\tif (!check()) {\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tFOR(i,n) {\n\t\tfor (int j=0;j<(int)v[i].size();j++) {\n\t\t\ty=v[i][j];\n\t\t\tif (i<y) {\n\t\t\t\tprintf(\"%d %d\\n\",i,y);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 100005;\nint n, id[N], now[N], tot;\nll d[N];\n\nstruct cmp1 {\n\tbool operator()(int x, int y) {\n\t\treturn d[x] < d[y] || (d[x] == d[y] && x < y);\n\t}\n};\nstruct cmp2 {\n\tbool operator()(int x, int y) {\n\t\treturn d[x] - 2 * now[x] < d[y] - 2 * now[y] || (d[x] - 2 * now[x] == d[y] - 2 * now[y] && x < y);\n\t}\n};\nset<int, cmp1> sl[2];\nset<int, cmp2> sr[2];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(\"%lld\", d + i), id[i] = i;\n\tvector<pair<int, int>> res;\n\tsort(id + 1, id + 1 + n, [](int x, int y) { return d[x] < d[y]; });\n\tnow[id[1]] = n - 1;\n\tsr[d[id[1]] & 1].insert(id[1]);\n\tfor (int i = 2; i <= n; ++i) {\n\t\tfor (int t = 0; t < 2; ++t)\n\t\t\twhile (!sr[t].empty()) {\n\t\t\t\tint x = *sr[t].begin();\n\t\t\t\tif (d[x] - 2 * now[x] > d[id[i]] - n)\n\t\t\t\t\tbreak;\n\t\t\t\tsl[t].insert(x), sr[t].erase(x);\n\t\t\t}\n\t\tif (sl[d[id[i]] + n & 1].empty())\n\t\t\treturn puts(\"-1\"), 0;\n\t\tint fa = *--sl[d[id[i]] + n & 1].end();\n\t\tif (d[fa] <= d[id[i]] - n)\n\t\t\treturn puts(\"-1\"), 0;\n\t\tsl[d[fa] & 1].erase(fa);\n\t\tres.emplace_back(fa, id[i]);\n\t\tnow[id[i]] = (n - d[id[i]] + d[fa]) / 2;\n\t\tnow[fa] -= now[id[i]]--;\n\t\tif (now[fa])\n\t\t\tsl[d[fa] & 1].insert(fa);\n\t\tif (now[id[i]])\n\t\t\tsr[d[id[i]] & 1].insert(id[i]);\n\t}\n\tfor (const auto &p : res)\n\t\tprintf(\"%d %d\\n\", p.first, p.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int N=1e5+10;\nll sz[N];\nll fa[N],d[N];\nint n,m;\nbool solve(){\n\tint pre;\n\tsort(d+1,d+1+n);\n\tfor (int i=1;i<=n;++i) sz[i]=1;\n\tfor (int i=n;i>=2;--i){\n\t\tpre=lower_bound(d+1,d+1+n,d[i]-n+2*sz[i])-d;\n\t\tif (d[pre]!=d[i]-n+2*sz[i]||pre==i) return false;\n\t\tfa[i]=pre; \n\t\tsz[fa[i]]+=sz[i];\n\t}\n\treturn true;\n}\n\nint main(){\n#ifndef ONLINE_JUDGE\n\t//freopen(\"a.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;++i) scanf(\"%lld\",d+i);\n\tif (solve()){\n\t\tfor (int i=2;i<=n;++i) cout<<fa[i]<<\" \"<<i<<endl;\n\t}\n\telse\n\t\tprintf(\"-1\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Distance Sums\n\nusing P = pair<int64_t, int64_t>;\n\nint main() {\n  size_t N;\n  cin >> N;\n  map<int64_t, P> mp;\n  for (size_t i = 1; i <= N; i++) {\n    int64_t x;\n    cin >> x;\n    mp[x] = make_pair(i, 1);  // 頂点番号と木のサイズ\n  }\n  if (N == 2) {\n    cout << -1 << endl;\n    return 0;\n  }\n  bool flag = true;  // 条件をみたす木が存在しているかどうか\n  vector<P> graph;\n  auto enditr = mp.rend();\n  enditr--;\n  for (auto itr = mp.rbegin(); itr != enditr; ++itr) {\n    auto key = itr->first;\n    auto value = itr->second;\n    auto vertex = value.first;\n    auto size = value.second;\n    auto child_key = key - N + 2 * size;\n    auto tmpitr = mp.find(child_key);\n    if (tmpitr != mp.end()) {\n      auto tmp = tmpitr->second;\n      mp.at(child_key) = make_pair(tmp.first, tmp.second + size);\n      graph.push_back(make_pair(vertex, tmp.first));\n    } else {\n      flag = false;\n      break;\n    }\n  }\n  if (flag) {\n    for (const auto& e : graph) {\n      cout << e.first << ' ' << e.second << endl;\n    }\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\ntypedef pair<int,int> pii;\n\nconst int N = 1e5 + 100;\n\nint d[N], sz[N], a[N];\nvector<int> adj[N];\nvector<pii> ans;\npii b[N];\nint n, mx, val;\n\nbool cmp(int x, int y) {\n\treturn d[x] > d[y];\t\n}\n\ninline int getPar(int v) {\n\tint hp = d[v] - n + 2 * sz[v];\n\tauto tmp = lower_bound(b, b + n, pii(hp, 0)) - b;\n\tif (b[tmp].first != hp) {\n\t\tcout << -1;\n\t\texit(0);\n\t}\n\treturn b[tmp].second;\n}\n\nint dfs(int v) {\n\tint res = 0;\n\tfor (auto u : adj[v])\n\t\tres += dfs(u) + sz[u];\n\treturn res;\n}\n\nint32_t main() {\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> d[i];\n\t\tb[i] = {d[i], i};\n\t\ta[i] = i;\n\t\tsz[i] = 1;\n\t}\n\tsort(b, b + n);\n\tsort(a, a + n, cmp);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint v = a[i];\n\t\tint p = getPar(v);\n\t\tsz[p] += sz[v];\n\t\tans.push_back({v, p});\n\t\tadj[p].push_back(v);\n\t\tif (2 * sz[v] > n)\n\t\t\treturn cout << -1, 0;\n\t}\n\tint root = a[n - 1];\n\tif (dfs(root) != d[root])\n\t\treturn cout << -1, 0;\n\tfor (auto e : ans)\n\t\tcout << e.first + 1 << \" \" << e.second + 1 << '\\n', 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<math.h>\n#include<stdlib.h>\n#include<set>\n#include<bitset>\n#include<map>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<complex>\n#include<list>\n#include<limits.h>\nusing namespace std;\n\nconst int N=1e5+5;\ntypedef pair<int,int> pii;\nint n;\npair<long long,int> a[N];\nint sz[N];\nlong long dp[N];\nvector<pii> vp;\nmap<long long,int> mp;\n\nvoid lnk(int x,int y){\n\tvp.push_back(make_pair(x,y));\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%I64d\",&a[i].first);\n\t\ta[i].second=i;\n\t}\n\tsort(a+1,a+1+n);\n\treverse(a+1,a+1+n);\n\tfor(int i=1;i<=n;i++) mp[a[i].first]=i;\n\tfor(int i=1;i<=n;i++) sz[i]=1;\n\tfor(int i=1;i<n;i++){\n\t\tint nxt=mp[a[i].first-1ll*n+2ll*sz[i]];\n//\t\tprintf(\"%d %d\\n\",i,nxt);\n\t\tdp[nxt]+=dp[i]+1ll*sz[i];\n//\t\tprintf(\" %lld %lld %d\\n\",dp[i],dp[nxt],sz[i]);\n\t\tsz[nxt]+=sz[i];\n\t\tlnk(a[i].second,a[nxt].second);\n\t}\n\tif(vp.size()!=n-1||dp[n]!=a[n].first) puts(\"-1\");\n\telse for(int i=0;i<vp.size();i++) printf(\"%d %d\\n\",vp[i].first,vp[i].second);\n\treturn 0;\n}\n\n/*\n数据不清空，爆零两行泪\n读题不认真，爆零两行泪\n分析不仔细，爆零两行泪\n建树不构造，爆零两行泪\n变量不统一，爆零两行泪\n边界不算清，爆零两行泪\n数组不开大，爆零两行泪\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <deque>\n#include <stack>\n#include <bitset>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,ll> pil;\ntypedef pair<ll,int> pli;\n#define rep(i,n) for (int i=0;i<n;++i)\n#define REP(i,n) for (int i=1;i<=n;++i)\n#define all(x) x.begin(),x.end()\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define F first\n#define S second\n#define read(x) scanf(\"%d\",&x)\nint n;\nll d[100005];\nmap<ll,int> m;\nll dp[100005];\nint sz[100005];// subtree size\nvector<pii> ans;\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tfor (int i=1;i<=n;++i){\n\t\tcin>>d[i];m[d[i]]=i;sz[i]=1;\n\t}\n\tsort(d+1,d+n+1);reverse(d+1,d+n+1);\n\tmemset(dp,0,sizeof(dp));\n\tfor (int i=1;i<n;++i){\n\t\tint u=m[d[i]];\n\t\tll want=d[i]+(sz[u]<<1)-n;\n\t\tif (!m.count(want)){\n\t\t\tcout<<-1<<endl;return 0;\n\t\t}\n\t\tint pa=m[want];\n\t\tans.pb(mp(u,pa));\n\t\tsz[pa]+=sz[u];\n\t\tdp[pa]+=dp[u]+sz[u];\n\t}\n\tif (dp[m[d[n]]]!=d[n]){\n\t\tcout<<-1<<endl;return 0;\n\t}\n\tfor (int i=0;i<n-1;++i) cout<<ans[i].F<<' '<<ans[i].S<<endl;\n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef pair<ll,ll> P;\nlong long int INF = 1e18;\ndouble Pi = 3.1415926535897932384626;\nlong long int mod = 1000000007;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"RULD\";\n//↓,→,↑,←\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,a,b) for(i=a;i<=b;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\n\n\n\nll i,j,k,ii,jj;\nll n,m,num;\nll a,b,c,e,f,g,h;\nll x[800005],y[800005],z[900005],w[500005];\nll d[800005],dp[500005];\nll no[500005];\nchar s[500005];\nll len[500];\nll vnum = 0,sum;\nbool dame;\nbool check[500005];\n\n\nvoid unite(ll a,ll b){\n    x[vnum] = a;\n    y[vnum] = b;\n    G[a].pb(b);\n    G[b].pb(a);\n    vnum++;\n}\n\nvoid dfs(ll v,ll dpn){\n    if(check[v]){\n        return;\n    }else{\n        sum += dpn;\n        check[v] = true;\n        for(int i=0;i<G[v].size();i++){\n            dfs(G[v][i],dpn + 1);\n        }\n    }\n}\nint main(){\n    cin>>n;\n    for(i=0;i<n;i++){\n        cin>>d[i];\n        z[i] = d[i];\n        no[i] = d[i];\n    }\n    sort(d,d+n);\n    for(i=0;i<n;i++){\n        z[i] = (lb(d,d+n,z[i]) - d) * 100001 + i;\n    }\n    sort(z,z+n);\n    //reverse(d,d+n);\n    for(i=n-1;i>=1;i--){\n        //大きい数字から見て行くよ\n        dp[i]++;\n        num = d[i] - n + 2* dp[i];\n        a = lb(d,d+n,num) - lb(d,d+n,-1);\n        if(d[a] != num || a >= i){\n            //p(\"dame\");\n            //p(a);\n            //p(num);\n            dame = true;\n            break;\n        }else{\n            dp[a] = dp[i];\n            unite(a+1,i+1);\n        }\n    }\n    sum = 0;\n    dfs(1,0);\n    if(sum != d[0]){\n        dame = true;\n    }\n    if(dame){\n        p(-1);\n        return 0;\n    }else{\n        for(i=0;i<vnum;i++){\n            pe(z[x[i]-1]%100001 + 1);p(z[y[i]-1]%100001 + 1);\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\n\nconst int MAXN = 1e5 + 5;\nint n, par[MAXN], mn;\nll d, sz[MAXN];\nmap <ll, ll> mp;\nvector <int> adj[MAXN];\nbool can = false, mark[MAXN];\n\nvoid dfs(int v, int parv){\n\tmark[v] = true;\n\tfor(auto u: adj[v]){\n\t\tif(!mark[u])\n\t\t\tdfs(u, v);\n\t\telse if(u != parv)\n\t\t\tcan = true;\n\t}\n\treturn;\n}\n\nbool check(){\n\tfor(int i = 1; i <= n; i++)\n\t\tif(i != mn && (par[i] < 1 || par[i] > n)){\n\t\t\treturn true;\n\t\t}\n\tdfs(mn, -1);\n\tfor(int i = 1; i <= n; i++)\n\t\tif(!mark[i])\n\t\t\tcan = true;\n\treturn can;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tvector <pair<ll, int>> v;\n\tfor(ll i = 1; i <= n; i++){\n\t\tcin >> d; sz[i] = 1ll;\n\t\tmp[d] = i;\n\t\tv.push_back({-d, i});\n\t}\n\tsort(v.begin(), v.end());\n\tfor(int i = 0; i < n - 1; i++){\n\t\td = -v[i].first;\n\t\tll ind = v[i].second;\n\t\tll dpar = d + (2ll * sz[ind]) - (ll)n;\n\t\tpar[ind] = mp[dpar];\n\t\tsz[par[ind]] += sz[ind];\n\t\tadj[par[ind]].push_back(ind);\n\t\tadj[ind].push_back(par[ind]);\n\t}\n\tmn = v[n - 1].second;\n\tif(check()){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tfor(int i = 0; i < n - 1; i++){\n\t\tcout << par[v[i].second] << \" \" << v[i].second << '\\n';\n\t}\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = 1e5 + 100;\nll n;\nvector<vector<ll>> gr;\nvector<pair<ll, ll>> vec;\n\nll sub[SZ];\nmap<ll, ll> m;\n\nint main()\n{\n\tfastInp;\n\n\tcin >> n;\n\n\tvec.resize(n);\n\tfor (auto &cur : vec) cin >> cur.first;\n\tfor (int i = 0; i < n; i++) {\n\t\tsub[i] = 1;\n\t\tvec[i].second = i;\n\t\tm[vec[i].first] = vec[i].second;\n\t}\n\n\tsort(vec.rbegin(), vec.rend());\n\n\tvector<pair<ll, ll>> edges;\n\tfor (int i = 0; i < vec.size() - 1; i++) {\n\t\tll par = vec[i].first + sub[vec[i].second] - (n - sub[vec[i].second]);\n\t\tif (m.find(par) == m.end() || m[par] == vec[i].second) {\n\t\t\tcout << \"-1\";\n\t\t\treturn 0;\n\t\t}\n\n\t\tsub[m[par]] += sub[vec[i].second];\n\t\tedges.push_back({ vec[i].second, m[par] });\n\t}\n\n\tfor (auto cur : edges) {\n\t\tcout << cur.first + 1 << \" \" << cur.second + 1 << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define rep(pos, len) for(int pos=0;pos<len;pos++)\n#define repp(pos, len) for(int pos=1;pos<=len;pos++)\n\n#define INF 987654321\n#define IINF 2987654321987654321\n#define MOD 998244353\n\nconst int MAXN = 1e5 + 50;\nll d[MAXN], pa[MAXN], sz[MAXN];\n\nint main() {\n\tint n; scanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%lld\", &d[i]);\n\n\tmap<ll, int> M;\n\tfor(int i = 1; i <= n; i++)\n\t\tM[d[i]] = i;\n\tfor(int i = 1; i <= n; i++)\n\t\tsz[i] = 1;\n\n\tvector<int> v;\n\tfor(int i = 1; i <= n; i++) v.push_back(i);\n\tsort(v.begin(), v.end(), [](int i, int j){ return d[i] > d[j]; });\n\tint root = v.back();\n\tfor(auto c : v) {\n\t\tif(c == root) break;\n\t\tll dval = d[c] + 2*sz[c] - n;\n\t\tif(M.find(dval) == M.end() || M[dval] == c) {\n\t\t\tprintf(\"-1\");\n\t\t\texit(0);\n\t\t}\n\t\tint p = M[dval];\n\t\tpa[c] = p;\n\t\tsz[p] += sz[c];\n\t}\n\n\tfor(int i = 1; i <= n; i++)\n\t\tif(i != root) printf(\"%d %d\\n\", i, pa[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+1;\nlong long n,c[N],l,r,d[N],A;\npair<long long,long long>p[N];\nvector<int>a[N];\nvoid D(int k,int f)\n{\n\tA+=d[k]; \n\tfor(int i=0;i<a[k].size();i++)\n\t\tif(a[k][i]!=f)\n\t\t\td[a[k][i]]=d[k]+1,D(a[k][i],k);\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>p[i].first,p[i].second=i,c[i]=1;\n\tsort(p+1,p+n+1); \n\tfor(int i=n;i>1;i--)\n\t{\n\t\tl=1,r=i-1;\n\t\twhile(l<r)\n\t\t\tif(p[(l+r)/2].first<p[i].first+2*c[i]-n)\n\t\t\t\tl=(l+r)/2+1;\n\t\t\telse\n\t\t\t\tr=(l+r)/2;\n\t\tif(p[l].first!=p[i].first+2*c[i]-n)\n\t\t{\n\t\t\tcout<<-1;\n\t\t\treturn 0;\n\t\t}\n\t\tc[l]+=c[i],a[p[l].second].push_back(p[i].second),a[p[i].second].push_back(p[l].second);\n\t}\n\tD(p[1].second,0);\n\tif(A!=p[1].first)\n\t{\n\t\tcout<<-1;\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<a[i].size();j++)\n\t\t\tif(i<a[i][j])\n\t\t\t\tcout<<i<<\" \"<<a[i][j]<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=a; i<=b; i++)\n#define per(i,a,b) for (register int i=a; i>=b; i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ninline void read(ll &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 666666;\nll n,s[N],a[N],size[N],used[N];\nbool cmp(int x, int y){return a[x]>a[y];}\nmap<ll,int>Map;Vi b,c;\nint main() {\n\tread(n);rep(i,1,n)read(a[i]),s[i]=i;sort(s+1,s+n+1,cmp);\n\trep(i,1,n)size[i]=1,Map[a[i]]=i;\n\trep(i,1,n-1){\n\t\tint u=s[i];used[u]=1;\n\t\tint f=Map[a[u]-(n-2*size[u])];if(!f||used[f]){puts(\"-1\");return 0;}\n\t//\tprintf(\"e %d %d\\n\",u,f);\n\t\tb.pb(u);c.pb(f);size[f]+=size[u];\n\t}\n\tper(i,SZ(b)-1,0)printf(\"%d %d\\n\",b[i],c[i]);\n//\trep(i,1,n-1)if(a[s[i]])\n//\trep(i,1,n-1)printf(\"%lld %lld\\n\",s[i],s[i+1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <sstream>\n#include <stack>\n#include <time.h>\n#include <vector>\n#include <complex>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <math.h>\n#include <stdlib.h>\n#include <list>\n#include <utility>\n#include <memory>\n#include <cstring>\n#include <fstream>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <ios> \n#include <bits/stdc++.h>\nusing namespace std;\nvoid coutno(){\n\tputs(\"-1\");exit(0);\n}\nint n;\ntypedef long long ll;\nmap <ll,int> mp;\nvector<pair<ll,int> > v;\nvector<pair<int,int> > res;\nll dp[100004];\nint sz[100004]; \nint main(){\n\tfor (int i=0;i<100004;i++) sz[i]=1;\n\tcin>>n;\n\tfor (int i=1;i<=n;i++){\n\t\tll x;cin>>x;\n\t\tmp[x]=i;v.push_back(make_pair(x,i));\n\t}\n\tsort (v.rbegin(),v.rend());\n\tll x=v.back().first;\n\tfor (int i=0;i<v.size();i++){\n\t\tif (v[i].first!=x){\n\t\t\tpair<ll,int> q=v[i];\n\t\t\tif (sz[q.second]*2>=n) coutno();\n\t\t\tll need=q.first-(n-2*sz[q.second]);\n\t\t\tif (!mp.count(need)) coutno();\n\t\t\tint par=mp[need];\n\t\t\tdp[par]+=dp[q.second]+sz[q.second]; \n\t\t\tsz[par]+=sz[q.second]; \n\t\t\tres.push_back(make_pair(q.second,par)); \n\t\t}\n\t}\n\tif (dp[v.back().second]!=x)coutno();\n\tfor (int i=0;i<n-1;i++)\n\t\tcout<<res[i].first<<\" \"<<res[i].second<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e5;\nint n;\n\nstruct data {\n\tll x; int id;\n\tbool operator < (const data &t) const {\n\t\treturn x < t.x;\n\t}\n}a[maxn + 10];\nll b[maxn + 10], c[maxn + 10], dep[maxn + 10], d[maxn + 10];\nint sz[maxn + 10];\nvector<int> g[maxn + 10];\n\nvoid dfs1(int p) {\n\tc[a[1].id] += dep[p]; sz[p] = 1;\n\tfor (int i = 0; i < (int)g[p].size(); ++i) {\n\t\tint e = g[p][i];\n\t\tdep[e] = dep[p] + 1;\n\t\tdfs1(e); \n\t\tsz[p] += sz[e];\n\t}\n}\n\nvoid dfs2(int p) {\n\tfor (int i = 0; i < (int)g[p].size(); ++i) {\n\t\tint e = g[p][i];\n\t\tc[e] = c[p] + n - 2 * sz[e];\n\t\tdfs2(e);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%lld\", &a[i].x);\n\t\td[i] = a[i].x; a[i].id = i;\n\t}\n\tsort(a + 1, a + n + 1);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tb[i] = a[i].x; sz[i] = 1;\n\t}\n\tfor (int i = n; i > 1; --i) {\n\t\tll v = b[i] - n + 2 * sz[i];\n\t\tint p = lower_bound(b + 1, b + i, v) - b;\n\t\tif (p < i && b[p] == v) {\n\t\t\tg[a[p].id].push_back(a[i].id);\n\t\t\tsz[p] += sz[i];\n\t\t} else {\n\t\t\tprintf(\"-1\"); return 0;\n\t\t}\n\t}\n\tdfs1(a[1].id);\n\tdfs2(a[1].id);\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (d[i] != c[i]) {\n\t\t\tprintf(\"-1\"); return 0;\n\t\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 0; j < (int)g[i].size(); ++j)\n\t\t\tprintf(\"%d %d\\n\", i, g[i][j]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\nint main()\n{\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin>>n;\n\tvector<pair<long long,int>>e;\n\tmap<long long,int>ret;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tlong long x;\n\t\tcin>>x;\n\t\tret[x]=i;\n\t\te.push_back({x,i});\n\t}\n\tsort(e.rbegin(),e.rend());\n\tlong long x=e.back().first;\n\tvector<int>sz(n,1);\n\tvector<long long>dp(n,0);\n\tvector<pair<int,int>>ans;\n\tfor(auto c:e)\n\t{\n\t\tif(c.first!=x)\n\t\t{\n\t\t\tif(sz[c.second]*2>=n)\n\t\t\t{\n\t\t\t\tcout<<-1<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tlong long need=c.first-(n-2*sz[c.second]);\n\t\t\tif(!ret.count(need))\n\t\t\t{\n\t\t\t\tcout<<-1<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint par=ret[need];\n\t\t\tdp[par]+=dp[c.second]+sz[c.second];\n\t\t\tsz[par]+=sz[c.second];\n\t\t\tans.push_back({c.second+1,par+1}); \n\t\t}\n\t}\n\tif(dp[e.back().second]!=x)\n\t{\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tfor(auto c:ans)\n\t\tcout<<c.first<<' '<<c.second<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <array>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n//#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w=0; w<n; ++w){MACRO_VEC_ROW_Scan(w, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\n//Union-Find\nclass UnionFind {\nprivate:\n\tstd::vector<int> parent;\n\tstd::vector<int> height;\n\tstd::vector<int> m_size;\n\npublic:\n\tUnionFind(int size_) : parent(size_), height(size_, 0), m_size(size_, 1) {\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tvoid init(int size_) {\n\t\tparent.resize(size_);\n\t\theight.resize(size_, 0);\n\t\tm_size.resize(size_, 0);\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tint find(int x) {\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tint t = size(x) + size(y);\n\t\tm_size[x] = m_size[y] = t;\n\t\tif (height[x] < height[y]) parent[x] = y;\n\t\telse parent[y] = x;\n\t\tif (height[x] == height[y]) ++height[x];\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\tif (parent[x] == x) return m_size[x];\n\t\treturn size(parent[x] = find(parent[x]));\n\t}\n};\n\n\nstd::vector<int> makeD(std::vector<std::vector<int>> g) {\n\tint n = g.size();\n\t\n\tstd::vector<int> sz(n, 1);\n\t{\n\t\tstd::function<void(int, int)> dfs = [&](int v, int par) {\n\t\t\tfor (auto& to : g[v]) if(to != par) {\n\t\t\t\tdfs(to, v);\n\t\t\t\tsz[v] += sz[to];\n\t\t\t}\n\t\t};\n\t\tdfs(0, -1);\n\t}\n\n\tstd::vector<int> d(n, 0);\n\t{ // init d[0]\n\t\tstd::vector<int> depth(n, 0);\n\t\tstd::function<void(int, int)> dfs = [&](int v, int par) {\n\t\t\td[0] += depth[v];\n\t\t\tfor (auto& to : g[v]) if (to != par) {\n\t\t\t\tdepth[to] = depth[v] + 1;\n\t\t\t\tdfs(to, v);\n\t\t\t}\n\t\t};\n\t\tdfs(0, -1);\n\t}\n\t{\n\t\tstd::function<void(int, int)> dfs = [&](int v, int par) {\n\t\t\tfor (auto& to : g[v]) if (to != par) {\n\t\t\t\td[to] = d[v] + n - 2 * sz[to];\n\t\t\t\tdfs(to, v);\n\t\t\t}\n\t\t};\n\t\tdfs(0, -1);\n\t}\n\treturn d;\n}\n\n\nsigned main() {\n\tINIT;\n\n\t/*VAR(int, n);\n\tVEC_ROW(int, n - 1, a, b);\n\tstd::vector<std::vector<int>> g(n);\n\tREP(i, n-1) {\n\t\t--a[i]; --b[i];\n\t\tg[a[i]].emplace_back(b[i]);\n\t\tg[b[i]].emplace_back(a[i]);\n\t}\n\tauto d(makeD(g));\n\tSHOWVECTOR(d);\n\t*/\n\n\tVAR(int, n);\n\tVEC(int, d, n);\n\n\tstd::map<int, int> map;\n\tREP(i, n) map[d[i]] = i;\n\n\tstd::vector<std::vector<int>> g(n);\n\tUnionFind uf(n);\n\tstd::vector<bool> used(n, false);\n\n\tfor (auto it = map.rbegin(); it != map.rend(); ++it) {\n\t\tint di = it->first, p = it->second;\n\t\tif (uf.size(p) == n) break;\n\t\tif (used[p]) continue;\n\t\tused[p] = true;\n\n\t\tint pi = di - n + 2 * uf.size(p);\n\t\tif (!map.count(pi)) {\n\t\t\tOUT(-1)BR;\n\t\t\treturn 0;\n\t\t}\n\t\tg[p].emplace_back(map[pi]);\n\t\tg[map[pi]].emplace_back(p);\n\t\tuf.unite(p, map[pi]);\n\t}\n\n\tauto d_(makeD(g));\n\tif (d != d_) {\n\t\tOUT(-1)BR;\n\t\treturn 0;\n\t}\n\tREP(i, n) for (auto& x : g[i]) if (i < x) {\n\t\tOUT(i + 1)SP OUT(x + 1)BR;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) std::cerr << #x << \" = \" << x << std::endl\nusing ll = long long;\nint main()\n{\n    int N;\n    std::cin >> N;\n    std::map<ll, int> mp, mp2;\n    std::vector<ll> D(N);\n    for (int i = 0; i < N; i++) { std::cin >> D[i], mp[D[i]] = i; }\n    std::sort(D.begin(), D.end(), std::greater<ll>{});\n    for (int i = 0; i < N; i++) { mp2[D[i]] = i; }\n    std::vector<std::vector<int>> edge(N);\n    std::vector<int> sub(N, 1);\n    for (int i = 0; i < N - 1; i++) {\n        const ll obj = D[i] - (N - 2 * sub[i]);\n        if (obj == D[i] or mp2.find(obj) == mp2.end()) { return std::cout << -1 << std::endl, 0; }\n        const int prev = mp2[obj];\n        edge[mp[obj]].push_back(mp[D[i]]), sub[prev] += sub[i];\n    }\n    for (int i = 0; i < N; i++) {\n        for (const int to : edge[i]) {\n            std::cout << i + 1 << \" \" << to + 1 << std::endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\nint main(){\n    int N;\n    cin >> N;\n    vector<pair<long long, int>> D(N);\n    for(int i=0; i<N; i++){\n        long long tmp;\n        cin >> tmp;\n        D[i] = make_pair(tmp, i);\n    }\n    sort(D.begin(), D.end(), greater<pair<long long, int>>());\n\n    vector<int> idx2idx(N);\n    for(int i=0; i<N; i++)\n        idx2idx[i] = D[i].second;\n\n    map<long long, int> d2idx;\n    for(int i=0; i<N; i++)\n        d2idx[D[i].first] = i;\n\n    vector<int> E(N, 0);\n    vector<pair<int, int>> edges;\n    for(int i=0; i<N; i++){\n        if(E[i] == 0) E[i] = 1;\n        long long d0 = D[i].first;\n        long long d1 = D[i].first + 2 * E[i] - N;\n        if(i == N-1) break;\n        auto itr = d2idx.find(d1);\n        if(itr == d2idx.end() || i == d2idx[d1]){\n            cout << -1 << endl;\n            return 0;\n        }\n        edges.push_back(make_pair(i, d2idx[d1]));\n        E[d2idx[d1]] += E[i] + 1;\n    }\n\n    for(auto x : edges)\n        cout << idx2idx[x.first]+1 << \" \" << idx2idx[x.second]+1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+3;\nint n,siz[N];\nbool b[N];\nstruct syzs{\n\tint val,num;\n} a[N];\nstruct ans{\n\tint e1,e2;\n\tbool operator <(const ans &emm) const{\n\t    if(emm.e1==e1) return e2>emm.e2;\n\t\treturn emm.e1<e1;\n\t}\n};\nbool cmp(syzs c,syzs b){\n\treturn c.val>b.val;\n}\nint find(int k){\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i].val==a[k].val+2*siz[k]-n&&i!=k) return i;\n\t}\n\treturn -1;\n}\nint main(){\n\tpriority_queue <ans> q;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i].val);\n\t\ta[i].num=i;\n\t\tsiz[i]=1;\n\t}\n\tsort(a+1,a+n+1,cmp);\n\tb[1]=1;\n\tfor(int i=1;i<n;i++){\n\t\tint v=find(i);\n\t\tif(v==-1) puts(\"-1\"),exit(0);\n\t\tsiz[v]+=siz[i];\n\t\tq.push((ans) {min(a[v].num,a[i].num),max(a[v].num,a[i].num)});\n\t}\n\twhile(!q.empty()){\n\t\tint v1=q.top().e1,v2=q.top().e2;\n    \tq.pop();\n    \tprintf(\"%d %d\\n\",v1,v2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define eb emplace_back\n#define mt make_tuple\n#define all(x) (x).begin(), (x).end() \n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair <int, int> ii;\ntypedef pair <ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef long double ld;\n\nconst ll INF=LLONG_MAX;\nconst int mxn=1e5+5;\nint sz[mxn];\nbool vis[mxn];\n\nint main()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    //freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout);\n\tint n;\n\tcin >> n;\n\tii dist[n];\n\tmap<int,int>vis;\n\tfor(int i=0; i<n; i++){\n\t\tcin >> dist[i].fi;\n\t\tdist[i].se=i;\n\t\tsz[i]=1;\n\t\tvis[dist[i].fi]=i;\n\t}\n\tmap<ii,bool>edge;\n\tsort(dist,dist+n);\n\tfor(int i=n-1; i>0; i--){\n\t\tint ind = dist[i].se;\n\t\tint next = dist[i].fi-n+2*sz[ind];\n\t\tauto ptr = vis[next];\n\t\tif(ptr==ind){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsz[ptr] += sz[ind];\n\t\tif(ptr>ind)swap(ind,ptr);\n\t\tedge[ii(ptr,ind)]=1;\n\t\tvis[ind]=1; vis[ptr]=1;\n\t}\n\tbool ok=0;\n\tfor(int i=0; i<n&&!ok; i++){\n\t\tif(sz[i]==n)ok=1;\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tif(!vis[i])ok=0;\n\t}\n\tif(!ok)cout << -1 << endl;\n\telse{\n\t\tfor(auto x:edge)\n\t\t\tcout << x.fi.fi+1 << ' ' << x.fi.se+1 << endl;\n\t}\n}\n\t\n// READ & UNDERSTAND\n// ll, int overflow, array bounds, memset(0)\n// special cases (n=1?), n+1 (1-index)\n// do smth instead of nothing & stay organized\n// WRITE STUFF DOWN\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define int long long\n#define ljc 998244353\nusing namespace std;\n#define gc getchar\ninline ll read(){\n    register ll x=0,f=1;char ch=gc();\n    while (!isdigit(ch)){if (ch=='-') f=-1;ch=gc();}\n    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}\n    return (f==1)?x:-x;\n}\nint n;\nstruct node{\n\tll x;\n\tint id;\n}x[1010101];\ninline bool cmp(node a,node b){\n\treturn a.x>b.x;\n}\nint sz[1010101],ans[1010101];\nmap<ll,int> mp;\nvector<pair<int,int> > as;\nsigned main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++) x[i].x=read(),x[i].id=i,sz[i]=1,mp[x[i].x]=i;\n\tsort(x+1,x+1+n,cmp);\n\tif (n==1){\n\t\tputs(x[1].x==0?\"\":\"-1\");\n\t\treturn 0;\n\t}\n\tif (n==2){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++){\n\t\tif (!mp.count(x[i].x-n+sz[x[i].id]+sz[x[i].id])){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint faa=mp[x[i].x-n+sz[x[i].id]+sz[x[i].id]];\n\t\tas.push_back(make_pair(faa,x[i].id));\n\t\tsz[faa]+=sz[x[i].id];\n\t\tans[faa]+=ans[x[i].id]+sz[x[i].id];\n\t}\n\tif (ans[x[n].id]!=x[n].x){\n\t\tputs(\"-1\");return 0;\n\t}\n\tfor (auto i:as) printf(\"%d %d\\n\",i.first,i.second);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 29.09.2018 15:33:19       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<long long> d(n);\n  vector<int> weight(n, 1);\n  map<long long,int> mp;\n  for (int i = 0; i < n; i++) {\n    cin >> d[i];\n    mp[d[i]] = i;\n  }\n  vector<pair<int,int>> res;\n  for (int itt = 0; itt < n - 1; itt++) {\n    auto it = mp.rbegin();\n    int i = it->second;\n    long long want = d[i] - (n - weight[i]) + weight[i];\n    if (mp.find(want) == mp.end() || mp[want] == i) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n    int j = mp[want];\n    res.emplace_back(i, j);\n    weight[j] += weight[i];\n    mp.erase(--mp.end());\n  }\n  for (auto &p : res) {\n    cout << p.first + 1 << \" \" << p.second + 1 << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <vector>\n#include <algorithm>\n\ntypedef long long int64;\n\nconst int maxn = 100005;\nint n, size[maxn];\nint64 d[maxn];\nstd::map<int64, int> s;\n\nint main()\n{\n\tstatic int id[maxn];\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(\"%lld\", d + i), s[d[i]] = i, id[i] = i;\n\tstd::sort(id + 1, id + 1 + n, [](int x, int y) { return d[x] < d[y]; });\n\tstd::vector<std::pair<int, int>> e;\n\tfor (int i = 1; i <= n; ++i)\n\t\tsize[i] = 1;\n\tfor (int i = n; i != 1; --i)\n\t{\n\t\tif (2 * size[id[i]] >= n || !s.count(d[id[i]] - (n - 2 * size[id[i]])))\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint fa = s[d[id[i]] - (n - 2 * size[id[i]])];\n\t\te.emplace_back(fa, id[i]);\n\t\tsize[fa] += size[id[i]];\n\t\td[1] -= size[id[i]];\n\t}\n\tif (d[1])\n\t\tputs(\"-1\");\n\telse\n\t\tfor (const auto &p : e)\n\t\t\tprintf(\"%d %d\\n\", p.first, p.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<cstring>\n#include<utility>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<set>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#define ll long long\n#define pii pair<int,int>\n#define mp make_pair\n#define fi first\n#define se second\n#define inf 0x7fffffff\nusing namespace std;\nint a[100010];\npii b[100010],c[100010];\nint main()\n{\n\tint i,j,k,n,m,x,y,x1,n1;\n\tscanf(\"%d\",&n);\n\tn1=n;\n\tfor(i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tb[i].fi=a[i];\n\t\tb[i].se=i+1;\n\t\tc[i]=b[i];\n\t}\n\tsort(b,b+n);\n\tvector<int> cl;\n\twhile(n>1)\n\t{\n\t\tx=n-1;\n\t\ti=2;\n\t\tk=0;\n\t\tcl.clear();\n\t\twhile(x!=0&&k<n)\n\t\t{\n\t\t\tj=b[x].fi-n1+i;\n\t\t\tif(j<y)\n\t\t\t{\n\t\t\t\tprintf(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ti+=2;\n\t\t\tx1=lower_bound(b,b+n,mp(j,0))-b;\n\t\t\tif(b[x1].fi!=j)\n\t\t\t{\n\t\t\t\tprintf(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcl.push_back(x);\n\t\t\tk++;\n\t\t\tx=x1;\n\t\t}\n\t\tif(k>=n)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(i=0;i<cl.size();i++)\n\t\t{\n\t\t\tb[cl[i]]=mp(0,0);\n\t\t}\n\t\tsort(b,b+n);\n\t\treverse(b,b+n);\n\t\treverse(b,b+n-k);\n\t\tn-=k;\n\t}\n\tn=n1;\n\tsort(c,c+n);\n\twhile(n>1)\n\t{\n\t\tx=n-1;\n\t\ti=2;\n\t\tk=0;\n\t\tcl.clear();\n\t\twhile(x!=0&&k<n)\n\t\t{\n\t\t\tj=c[x].fi-n1+i;\n\t\t\ti+=2;\n\t\t\tx1=lower_bound(c,c+n,mp(j,0))-c;\n\t\t\tprintf(\"%d %d\\n\",c[x].se,c[x1].se);\n\t\t\tcl.push_back(x);\n\t\t\tk++;\n\t\t\tx=x1;\n\t\t}\n\t\tif(k>=n)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(i=0;i<cl.size();i++)\n\t\t{\n\t\t\tc[cl[i]]=mp(0,0);\n\t\t}\n\t\tsort(c,c+n);\n\t\treverse(c,c+n);\n\t\treverse(c,c+n-k);\n\t\tn-=k;\n\t}\n\treturn 0;\n}/*\n7\n10\n15\n13\n18\n11\n14\n19\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define debug printf(\"fuck %d\\n\", __LINE__);\ninline LL read() {\n\tLL res = 0, bo = 1;\n\tchar ch = getchar();\n\twhile(ch < '0' || ch > '9') { if (ch == '-') bo = -1; ch = getchar(); }\n\twhile(ch >= '0' && ch <= '9') { res = (res << 1) + (res << 3) + ch - '0'; ch = getchar(); }\n\treturn bo * res;\n}\ntemplate<typename T> void read(T &x) { x = read(); }\ntemplate<typename T, typename ...Argv> void read(T &a, Argv &...argv) { read(a); read(argv...); }\n\nconst int N = 2e5 + 100;\n\nstruct Edge {\n\tint to;\n\tEdge *nxt;\n\tEdge(int to, Edge *nxt) : to(to), nxt(nxt) {}\n} *head[N];\n\nstruct node {\n\tLL dis; int id;\n\tnode() {}\n\tnode(LL dis, int id) : dis(dis), id(id) {}\n\tfriend bool operator < (const node &a, const node &b) { return a.dis > b.dis; }\n} a[N];\n\nint u[N], v[N], siz[N], dis[N];\n\nvoid dfs(int x, int fa) {\n\tdis[x] = dis[fa] + 1;\n\tfor (Edge *i = head[x]; i; i = i->nxt) {\n\t\tif (i->to == fa) continue;\n\t\tdfs(i->to, x);\n\t}\n}\n\nvoid add(int u, int v) { head[u] = new Edge(v, head[u]), head[v] = new Edge(u, head[v]); }\n\nint main() {\n\tint n = read();\n\tfor (int i = 1; i <= n; ++ i) a[i] = node(read(), i), siz[i] = 1;\n\tstd::sort(a + 1, a + n + 1);\n\tfor (int i = 1; i < n; ++ i) {\n\t\tint d = a[i].dis - n + (siz[i] << 1);\n\t\tint l = 1, r = n, ans = 0;\n\t\twhile (l <= r) {\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tif (a[mid].dis >= d) l = mid + 1, ans = mid;\n\t\t\telse r = mid - 1;\n\t\t}\n\t\tif (a[ans].dis != d) { puts(\"-1\"); return 0; }\n\t\tint v = a[i].id, u = a[ans].id;\n\t\tadd(u, v); siz[ans] += siz[i];\n\t\t::u[i] = u; ::v[i] = v;\n\t}\n\tdfs(a[n].id, 0); LL sum = 0;\n\tfor (int i = 1; i <= n; ++ i) sum += dis[i] - 1;\n\tif (sum != a[n].dis) { puts(\"-1\"); return 0; }\n\tfor (int i = 1; i < n; ++ i) printf(\"%d %d\\n\", u[i], v[i]); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline long long read () {\n\tlong long num = 0;\n\tchar c = ' ';\n\tbool flag = true;\n\tfor (;c > '9' || c < '0';c = getchar())\n\t\tif (c == '-')\n\t\t\tflag = false;\n\tfor (;c >= '0' && c <= '9';num = (num << 1) + (num << 3) + c - 48, c = getchar());\n\treturn flag ? num : -num;\n}\nnamespace graph {\n\tconst int maxn = 100020;\n\tstruct node {\n\t\tint y, next;\n\t} a[maxn << 1];\n\tint head[maxn], top = 0;\n\tvoid insert (int x, int y) {\n\t\ta[top].y = y;\n\t\ta[top].next = head[x];\n\t\thead[x] = top ++;\n\t}\n} using namespace graph;\n\nnamespace INIT {\n\tmap <long long, int> m;\n\tint n; long long d[maxn];\n\tvoid init () {\n\t\tn = read ();\n\t\tfor (int i = 1;i <= n;i ++) {\n\t\t\td[i] = read ();\n\t\t\tm[d[i]] = i;\n\t\t}\n\t\tsort (d + 1,d + 1 + n);\n\t}\n} using namespace INIT;\n\nnamespace WORK {\n\tint size[maxn];\n\tvoid work () {\n\t\tmemset (head, -1, sizeof head);\n\t\tfor (int i = 1;i <= n;i ++)\n\t\t\tsize[i] = 1;\n\t\tfor (int i = n;i > 1;i --) {\n\t\t\tint x = m[d[i]];\n\t\t\tlong long t = n - 2 * size[x];\n\t\t\t/*if (t < 0) {\n\t\t\t\tprintf (\"-1\\n\");\n\t\t\t\texit (0);\n\t\t\t}*/\n\t\t\tt = d[i] - t;\n\t\t\tif (m.count(t) == 0) {\n\t\t\t\tprintf (\"-1\\n\");\n\t\t\t\texit (0);\n\t\t\t}\n\t\t\tint y = m[t];\n\t\t\tinsert (y, x);\n\t\t\tinsert (x, y);\n\t\t\tsize[y] += size[x];\n\t\t}\n\t}\n} using namespace WORK;\n\nnamespace CHECK {\n\tint dis[maxn];\n\tvoid dfs (int x, int fa) {\n\t\tfor (int i = head[x];i + 1;i = a[i].next) {\n\t\t\tint y = a[i].y;\n\t\t\tif (y == fa) continue;\n\t\t\tdis[y] = dis[x] + 1;\n\t\t\tdfs (y, x);\n\t\t}\n\t}\n\tvoid check () {\n\t\tdfs (m[d[1]], -1);\n\t\tlong long s = 0;\n\t\tfor (int i = 1;i <= n;i ++)\n\t\t\ts += dis[i];\n\t\tif (s != d[1]) printf (\"-1\\n\");\n\t\telse for (int i = 0;i < top;i += 2) \n\t\t\t\tprintf (\"%d %d\\n\",a[i].y, a[i ^ 1].y);\n\t}\n} using namespace CHECK;\nint main () {\n\tinit ();\n\twork ();\n\tcheck ();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <cctype>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <vector>\n#include <map>\nconst int maxn = 100005;\nusing ll = long long;\nstd::vector<int> G[maxn];\ninline void ins_edge(int u, int v) {\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nll d_n;\nll calc_dis(int x, int fa = 0) {\n  ll ans = 1;\n  for(int v : G[x]) {\n    if(v != fa) ans += calc_dis(v, x);\n  }\n  d_n += ans;\n  return ans;\n}\n\nll d[maxn];\ninline int cmp(const int &i, const int &j) {\n  return d[i] > d[j];\n}\n\nusing pii = std::pair<int, int>;\nstd::map<ll, int> ma;\nint id[maxn], siz[maxn];\nint main() {\n  int n; scanf(\"%d\", &n); d_n = -n;\n  for(int i = 1; i <= n; i ++) {\n    scanf(\"%lld\", &d[i]);\n    ma[d[i]] = i;\n  }\n  for(int i = 1; i <= n; i ++) id[i] = i;\n  std::sort(id + 1, id + 1 + n, cmp);\n  std::vector<pii> E;\n  for(int i = 1; i < n; i ++) {\n    int th = id[i]; siz[th] ++;\n    ll p_d = d[th] - (n - siz[th]) + siz[th];\n    if(!ma.count(p_d) || p_d > d[th]) {\n      puts(\"-1\"); return 0;\n    }\n    int fa = ma[p_d]; siz[fa] += siz[th];\n    ins_edge(th, fa); E.push_back({th, fa});\n  }\n  calc_dis(id[n]);\n  if(d_n != d[id[n]]) {\n    puts(\"-1\"); return 0;\n  }\n  for(auto e : E) {\n    printf(\"%d %d\\n\", e.first, e.second);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nmap<ll,int>p;\nmap<ll,int>::iterator it;\nint fa[100010],siz[100010],a[100010],b[100010],h[100010],nex[200010],to[200010],M,n;\nvoid add(int a,int b){\n\tM++;\n\tto[M]=b;\n\tnex[M]=h[a];\n\th[a]=M;\n}\nll wd[100010],d[100010];\nvoid dfs(int x,int dis){\n\tsiz[x]=1;\n\td[1]+=dis;\n\tfor(int i=h[x];i;i=nex[i]){\n\t\tif(to[i]!=fa[x]){\n\t\t\tfa[to[i]]=x;\n\t\t\tdfs(to[i],dis+1);\n\t\t\tsiz[x]+=siz[to[i]];\n\t\t}\n\t}\n}\nvoid dfs(int x){\n\tfor(int i=h[x];i;i=nex[i]){\n\t\tif(to[i]!=fa[x]){\n\t\t\td[to[i]]=d[x]+n-siz[to[i]]*2;\n\t\t\tdfs(to[i]);\n\t\t}\n\t}\n}\nint get(int x){return fa[x]==x?x:(fa[x]=get(fa[x]));}\nint main(){\n\tint i;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%lld\",wd+i);\n\t\tp[wd[i]]=i;\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tfa[i]=i;\n\t\tsiz[i]=1;\n\t}\n\tit=p.end();\n\tfor(it--;it!=p.begin();it--){\n\t\tif(n-siz[it->second]*2==0||!p.count(it->first-(n-siz[it->second]*2))){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tM++;\n\t\ta[M]=it->second;\n\t\tb[M]=p[it->first-(n-siz[it->second]*2)];\n\t\tsiz[fa[a[M]]=get(b[M])]+=siz[a[M]];\n\t}\n\tM=0;\n\tfor(i=1;i<n;i++){\n\t\tadd(a[i],b[i]);\n\t\tadd(b[i],a[i]);\n\t}\n\tfa[1]=0;\n\tdfs(1,0);\n\tdfs(1);\n\tfor(i=1;i<=n;i++){\n\t\tif(wd[i]!=d[i]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(i=1;i<n;i++)printf(\"%d %d\\n\",a[i],b[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define inf 0x3f3f3f3f3f3f3f3f\n#define inf 0x3f3f3f3f\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define inv(x) Power(x, mod - 2)\n#define fi first\n#define se second\n#define MP make_pair\n#define PB push_back\n\ntypedef std::vector<int> Poly;\ntypedef std::pair<int,int> Pair;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef long long ll;\n\nconst int maxn = 100000, maxm = 2000, MAX = 1e6 + 5, mod = 1000000;\n//template{{{\nconst long double Pi = 3.14159265358979323846l, Eps = 1e-4;\ntemplate <class T> inline bool equal(T x, T y) { return fabs(x - y) < Eps; }\ninline int add(int x, int y) { x += y; return x >= mod ? x - mod : x; };\ninline void inc(int &x, int y) { x += y; x -= (x >= mod ? mod : 0); }\ninline int mul(int x, int y) { return 1ll * x * y % mod; }\ninline int Power(int x, int y, int Mod = mod) {\n\tint ans = 1;\n\twhile (y) {\n\t\tif (y & 1) ans = (ll) ans * x % Mod;\n\t\tx = (ll) x * x % Mod, y >>= 1;\n\t} return ans;\n}\n\n/*char buf[1<<23],obuf[1<<23],*p1=buf,*p2=buf, *O = obuf;\n#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\nvoid print(int x) {\n    if(x > 9) print(x / 10);\n    *O++=x%10+'0';\n} */\n\ntemplate <class T> inline T\tinput() {\n\tT x; char ch; bool flag = false;\n\twhile (!isdigit(ch = getchar())) flag |= ch == '-';\n\tfor (x = ch ^ 48; isdigit(ch = getchar()); x = x * 10 + (ch ^ 48));\n\treturn flag ? -x : x;\n}\n\ntemplate <class T> inline bool chkmin(T &x, T y) { x = x < y ? x : y; return x == y; }\ntemplate <class T> inline bool chkmax(T &x, T y) { x = x > y ? x : y; return x == y; }\ntemplate <class T> inline T gcd(T x, T y) { return !y ? x : gcd(y, x % y); }\ntemplate <class T> inline T sqrm(T x) { return (ll) x * x % mod; }\ntemplate <class T> inline T sqr(T x) { return x * x; }\n\nstruct {\n\tinline operator int () { return input<int>(); }\n\tinline operator long long () { return input<long long>(); }\n\ttemplate <class T> inline void operator () (T &x) { x = *this; }\n\ttemplate<class T, class ...A> inline void operator () (T &x, A &...a)\n\t{ x = *this; this -> operator ()(a...); }\n} read; //}}}\n\nint n;\nll d[maxn + 5];\nint size[maxn + 5];\nstd::map<ll, int> id;\nstd::pair<ll, int> p[maxn + 5];\nint fa[maxn + 5];\n\nsigned main() {\n#ifdef local\n\tfreopen(\"in\", \"r\", stdin);\n\tfreopen(\"out\", \"w\", stdout);\n\tfreopen(\"log\", \"w\", stderr);\n#endif\n\n\tn = read;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tp[i].fi = d[i] = read;\n\t\tp[i].se = id[d[i]] = i;\n\t\tsize[i] = 1;\n\t}\n\n\tstd::sort(p + 1, p + n + 1);\n\tfor (int i = n; i > 1; --i) {\n\t\tll df = p[i].fi - n + size[p[i].se] * 2;\n\t\tif (df >= p[i].fi) return puts(\"-1\"), 0;\n\t\tfa[p[i].se] = id[df], size[fa[p[i].se]] += size[p[i].se];\n\t\tif (!fa[p[i].se]) return puts(\"-1\"), 0;\n\t}\n\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (fa[i]) printf(\"%d %d\\n\", i, fa[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid err() {\n  cout << -1 << endl;\n  exit(0);\n}\nvoid dfs (int crr, int dpt, vector<vector<int>>& grh, long long& cnt) {\n  cnt += dpt;\n  for (int nxt : grh[crr]) {\n    dfs(nxt, dpt + 1, grh, cnt);\n  }\n}\nint main() {\n  int n;\n  cin >> n;\n  vector<pair<long long, int>> di(n);\n  for (int i = 0; i < n; i++) {\n    int d;\n    cin >> d;\n    di[i] = {d, i};\n  }\n  sort(di.begin(), di.end());\n  vector<int> sz(n, 1), prt(n);\n  vector<vector<int>> grh(n);\n  vector<pair<int, int>> edg;\n  for (auto it = prev(di.end()); it != di.begin(); it--) {\n    auto d = it->first;\n    auto i = it->second;\n    long long prtv = d - n + 2 * sz[i];\n    auto jt = lower_bound(di.begin(), di.end(), make_pair(prtv, 0));\n    if (jt->first != prtv) err();\n    auto p = jt->second;\n    prt[i] = p;\n    grh[p].push_back(i);\n    if (i == prt[i]) err();\n    sz[prt[i]] += sz[i];\n    edg.emplace_back(min(i, prt[i]), max(i, prt[i]));\n  }\n  long long cnt = 0;\n  int rt = di[0].second;\n  dfs(rt, 0, grh, cnt);\n  if (di[0].first != cnt) err();\n  sort(edg.begin(), edg.end());\n  for (auto const & e : edg) {\n    cout << e.first + 1 << ' ' << e.second + 1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\nconst int maxn=1e5+2;\nint n;\nmap<LL,int> mp;\nLL dis[maxn];\nint id[maxn],fa[maxn],siz[maxn];\nbool cmp(int x,int y){\n\treturn dis[x]>dis[y];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&dis[i]);\n\t\tsiz[i]=1;\n\t\tid[i]=mp[dis[i]]=i;\n\t}\n\tsort(id+1,id+n+1,cmp);\n\tfor (int i=1;i<n;i++){\n\t\tfa[id[i]]=mp[dis[id[i]]-n+2*siz[id[i]]];\n\t\tif (!fa[id[i]]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[fa[id[i]]]+=siz[id[i]];\n\t}\n\tfor (int i=1;i<n;i++) dis[id[n]]-=siz[id[i]];\n\tif (dis[id[n]]){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++) printf(\"%d %d\\n\",fa[id[i]],id[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,x,y) for(int i=x;i<=y;++i)\n#define rf(i,x,y) for(int i=x;i>=y;--i)\n#define LL long long\nusing namespace std;\nconst int N=1010;\nstruct data{\n\tLL x,y;\n}a[N];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nchar ch[4]={'R','D','L','U'};\nvector<LL>v;\n\nint main(){\n\tint n;scanf(\"%d\",&n);\n\tfr(i,1,n) scanf(\"%lld%lld\",&a[i].x,&a[i].y);\n\tint flg=0;\n\tfr(i,1,n){\n\t\tif(i==1) flg=(a[i].x+a[i].y)&1;\n\t\telse if(flg!=((a[i].x+a[i].y)&1)) return printf(\"-1\\n\"),0;\n\t}\n\trf(i,30,0) v.push_back(1LL<<i);\n\tif(!flg) v.push_back(1);\n\tint len=v.size();\n\tprintf(\"%d\\n\",len);\n\tfr(i,0,len-1) printf(\"%lld \",v[i]);\n\tputs(\"\");\n\tfr(i,1,n){\n\t\tLL xx=a[i].x,yy=a[i].y;\n\t\tfr(j,0,len-1){\n\t\t\tLL minn=1e18,res=-1;\n\t\t\tfr(o,0,3){\n\t\t\t\tLL nx=xx-v[j]*dx[o],ny=yy-v[j]*dy[o];\n\t\t\t\tif(minn>abs(nx)+abs(ny)) minn=abs(nx)+abs(ny),res=o;\n\t\t\t}\n\t\t\txx-=v[j]*dx[res],yy-=v[j]*dy[res];\n\t\t\tprintf(\"%c\",ch[res]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// By Hacheylight\n\n#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n//#define int long long\n#define rep(i, a, b) for (int i = (a); i <= (b); i++)\n#define per(i, a, b) for (int i = (a); i >= (b); i--)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (int i = head[x]; i; i = e[i].nxt)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, sum) memset(a, sum, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter cout << endl\n#define siz(x) ((int)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef long double ld ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef pair <ll, int> pli ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef queue <pii> qii ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int N = 100010 ;\nconst int INF = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst int mod = 1000000007 ;\nconst double eps = 1e-7 ;\nvoid douout(double x){ printf(\"%lf\\n\", x + 0.0000000001) ; }\ntemplate <class T> void print(T a) { cout << a << endl ; exit(0) ; }\ntemplate <class T> void chmin(T &a, T b) { if (a > b) a = b ; }\ntemplate <class T> void chmax(T &a, T b) { if (a < b) a = b ; }\nvoid add(int &a, int b) { a = a + b < mod ? a + b : a + b - mod ; }\nvoid sub(int &a, int b) { a = (a - b + mod) % mod ; }\nvoid mul(int &a, int b) { a = (ll) a * b % mod ; }\nint addv(int a, int b) { return (a += b) >= mod ? a -= mod : a ; }\nint subv(int a, int b) { return (a -= b) < 0 ? a += mod : a ; }\nint mulv(int a, int b) { return (ll) a * b % mod ; }\nint read() {\n    int f = 1, x = 0 ;\n    char ch = getchar() ;\n    while (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n    while (isdigit(ch)) { x = x * 10 + ch -'0' ; ch = getchar() ; }\n    return x * f ;\n}\nint pw(int a, int b) {\n\tint s = 1 ;\n\tfor (; b; b >>= 1, a = (ll) a * a % mod)\n    if (b & 1) s = (ll) s * a % mod ;\n    return s ;\n}\n\n\n\nsigned main() {\n\tint n ;\n\tcin >> n ;\n\tvector <pli> e ;\n\tmap <ll, int> ret ;\n\trep(i, 0, n - 1) {\n\t\tll x ; cin >> x ;\n\t\tret[x] = i ;\n\t\te.pb({x, i}) ;\n\t}\n\tsort(e.rbegin(), e.rend()) ;\n\tll x = e.back().fi ;\n\tvi sz(n, 1) ;\n\tvector <ll> dp(n, 0) ;\n\tvector <pii> ans ;\n\tfor (auto c : e) {\n\t\tif (c.fi != x) {\n\t\t\tif (sz[c.se] * 2 >= n) print(-1) ;\n\t\t\tll need = c.fi - (n - 2 * sz[c.se]) ;\n\t\t\tif (!ret.count(need)) print(-1) ;\n\t\t\tint par = ret[need] ;\n\t\t\tdp[par] += dp[c.se] + sz[c.se] ;\n\t\t\tsz[par] += sz[c.se] ;\n\t\t\tans.pb({c.se + 1, par + 1}) ;\n\t\t}\n \t}\n \tif (dp[e.back().se] != x) print(-1) ;\n \tfor (auto c : ans) cout << c.fi << \" \" << c.se << endl ;\n\n\n\treturn 0 ;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Written by Zhu Zeqi\n//Come on,baby\n//Hack,please\n#include <iostream> \n#include <cstdio> \n#include <fstream> \n#include <algorithm> \n#include <cmath> \n#include <deque> \n#include <vector> \n#include <queue> \n#include <string> \n#include <cstring> \n#include <map> \n#include <stack> \n#include <set> \n#define INF 0x3f3f3f3f3f3f3f3f\ntypedef long long ll;\n//orz yht\nusing namespace std;\nint main(){\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n    int n;\n  cin >> n;\n  vector<long long> d(n);\n  vector<int> weight(n, 1);\n  map<long long,int> mp;\n  for (int i = 0; i < n; i++) {\n    cin >> d[i];\n    mp[d[i]] = i;\n  }\n  vector<pair<int,int>> res;\n  for (int itt = 0; itt < n - 1; itt++) {\n    auto it = mp.rbegin();\n    int i = it->second;\n    long long want = d[i] - (n - weight[i]) + weight[i];\n    if (mp.find(want) == mp.end() || mp[want] == i) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n    int j = mp[want];\n    res.emplace_back(i, j);\n    weight[j] += weight[i];\n    mp.erase(--mp.end());\n  }\n  vector<long long> real_dist(n, -1);\n  real_dist[0] = 0;\n  vector<vector<int>> g(n);\n  for (auto &p : res) {\n    g[p.first].push_back(p.second);\n    g[p.second].push_back(p.first);\n  }\n  vector<int> que(1, 0);\n  for (int b = 0; b < (int) que.size(); b++) {\n    for (int j : g[que[b]]) {\n      if (real_dist[j] == -1) {\n        que.push_back(j);\n        real_dist[j] = real_dist[que[b]] + 1;\n      }\n    }\n  }\n  if (accumulate(real_dist.begin(), real_dist.end(), 0LL) != d[0]) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  for (auto &p : res) {\n    cout << p.first + 1 << \" \" << p.second + 1 << '\\n';\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pii pair<int, int>\n#define F first\n#define S second\n#define int int_fast64_t\nusing namespace std;\nconst int MX = 1e5 + 100;\nint sz[MX], dst[MX];\npii v[MX];\nvector<int> G[MX];\nmain () {\n    int n; cin >> n;\n    for(int i = 1; i <= n; i ++) cin >> v[i].F, v[i].S = i;\n    sort(v + 1, v + 1 + n);\n    unordered_map<int, int> mp;\n    for(int i = 1; i <= n; i ++) mp[v[i].F] = v[i].S, sz[i] = 1;\n    for(int i = n; i > 1; i --) {\n        int ptr = v[i].F - (n - sz[v[i].S]) + sz[v[i].S];\n        if(ptr >= v[i].F or !mp[ptr]) return cout << -1, 0;\n        int pp = mp[ptr];\n        G[pp].push_back(v[i].S);\n        sz[pp] += sz[v[i].S];\n        dst[pp] += dst[v[i].S] + sz[v[i].S];\n    }\n    if(dst[v[1].S] != v[1].F) return cout << -1, 0; \n    for(int i = 1; i <= n; i ++) {\n        for(auto it: G[i]) cout << i << ' ' << it << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> pii;\n\npii inp[100005];\nint siz[100005];\nvector<pii> ans;\nint main() {\n\tint N; scanf(\"%d\", &N);\n\tfor (int i = 1; i <= N; i++) {\n\t\tll x; scanf(\"%lld\", &x);\n\t\tinp[i] = {x, i};\n\t\tsiz[i] = 1;\n\t}\n\tsort(inp + 1, inp + N + 1);\n\tfor (int i = N; i >= 2; i--) {\n\t\tint cur, id;\n\t\ttie(cur, id) = inp[i];\n\t\tint n = N - siz[id];\n\t\tll del = n - siz[id];\n\t\tauto it = *lower_bound(inp + 1, inp + N + 1, pii(cur - del, 0));\n\t\tif (it.first != cur - del || !del || siz[id] == N) return !printf(\"-1\");\n\t\tsiz[it.second] += siz[id];\n\t\tif (id > it.second) swap(id, it.second);\n\t\tans.push_back({id, it.second});\n\t}\n\tif (siz[inp[1].second] != N) return !printf(\"-1\");\n\tsort(ans.begin(), ans.end());\n\n\tfor (pii &x : ans) {\n\t\tprintf(\"%lld %d\\n\", x.first, x.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <map>\nusing namespace std;\n\nnamespace zyt\n{\n\ttypedef long long ll;\n\tconst int N = 1e5 + 10;\n\tint n, id[N], fa[N], size[N];\n\tll d[N];\n\tmap<ll, int> mp;\n\tbool cmp(const int a, const int b)\n\t{\n\t\treturn d[a] < d[b];\n\t}\n\tint work()\n\t{\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tscanf(\"%lld\", d + i), id[i] = i, mp[d[i]] = i, size[i] = 1;\n\t\tsort(id + 1, id + n + 1, cmp);\n\t\tfor (int i = n; i > 1; i--)\n\t\t{\n\t\t\tint t = d[id[i]] - n + 2LL * size[id[i]];\n\t\t\tmp.erase(d[id[i]]);\n\t\t\tif (mp.count(t))\n\t\t\t\tsize[mp[t]] += size[id[i]], fa[id[i]] = mp[t];\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tif (fa[i])\n\t\t\t\tprintf(\"%d %d\\n\", i, fa[i]);\n\t\treturn 0;\n\t}\n}\nint main()\n{\n\treturn zyt::work();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#define Maxn 1000008 \nusing namespace std;\ntypedef long long ll;\n\nint n,cnt,tot;\nll imp;\nint U[Maxn],V[Maxn];\nll d;\nbool vis[Maxn];\nint son[Maxn],head[Maxn];\nmap <ll,int> M;\n\nstruct node{\n\tint num;\n\tll val;\n}N[Maxn];\n\nstruct edge{\n\tint to,next;\n}E[Maxn];\n\nvoid adde(int u,int v)\n{\n\tE[tot].to = v;\n\tE[tot].next = head[u];\n\thead[u] = tot++;\n}\n\nvoid dfs(int u,ll val)\n{\n\timp += val,vis[u] = 1;\n\tfor(int i = head[u];~i;i = E[i].next)\n\t{\n\t\tint v = E[i].to;\n\t\tif(vis[v]) continue;\n\t\tdfs(v,val+1);\n\t}\n}\n\nbool cmp(node a,node b){\treturn a.val > b.val;}\n\nint main()\n{\n\tmemset(vis,0,sizeof(vis));\n\tmemset(head,-1,sizeof(head));\n\tmemset(son,0,sizeof(son));\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\tscanf(\"%lld\",&d);\n\t\tM[d] = i;\n\t\tN[i].num = i,N[i].val = d;\n\t}\n\tsort(N+1,N+1+n,cmp);\n\tmap<ll,int>::iterator iter;;\n\tfor(int i = 1;i < n;i ++)\n\t{\n\t\tint u = N[i].num;\n\t\titer = M.find(N[i].val - n + 2 + (son[u] << 1));\n\t\tif(iter == M.end())\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tint v = iter->second;\n\t\tson[v] += son[u]+1;\n\t\tadde(u,v);adde(v,u);\n\t\tU[cnt] = u,V[cnt++] = v;\n\t}\n\tdfs(N[n].num,0);\n\tif(N[n].val != imp){\tprintf(\"-1\\n\");return 0;}\n\tfor(int i = 0;i < cnt;i ++) printf(\"%d %d\\n\",U[i],V[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=100003;\n\nint n,w[maxn],head[maxn],siz[maxn];\nstruct EDGE{\n\tint to,nxt;\n}edge[maxn<<1];\nvoid addedge(int u,int v){\n\tstatic int sz=0;edge[++sz].nxt=head[u];\n\tedge[sz].to=v;head[u]=sz;\n}\nll d[maxn],dis[maxn],sum[maxn];\nmap<ll,int> mp;\nvector<pii> v; \n\nvoid dfs(int u,int pre){\n\tint to;siz[u]=1;\n\tfor(int i=head[u];i;i=edge[i].nxt){\n\t\tto=edge[i].to;\n\t\tif(to==pre) continue;\n\t\tdfs(to,u);\n\t\tsum[u]+=sum[to]+siz[to];\n\t\tsiz[u]+=siz[to];\n\t}\n}\n\nvoid dfs1(int u,int pre){\n\tint to;\n\tfor(int i=head[u];i;i=edge[i].nxt){\n\t\tto=edge[i].to;\n\t\tif(to==pre) continue;\n\t\tdis[to]=dis[u]+n-2*siz[to];\n\t\tdfs1(to,u);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%lld\",&d[i]);\n\t\tmp[d[i]]=i;\n\t\tw[i]=1;\n\t}\n\tfor(int i=1;i<n;++i){\n\t\tpair<ll,int> p=*mp.rbegin();\n\t\tint u=p.second;\n\t\tll want=d[u]-n+2*w[u];\n\t\tif(mp.find(want)==mp.end()){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint to=mp[want];\n\t\tv.push_back(make_pair(u,to));\n\t\taddedge(u,to);\n\t\taddedge(to,u);\n\t\tw[to]+=w[u];\n\t\tmp.erase(--mp.end());\n\t}\n\tdfs(1,0);\n\tdis[1]=sum[1];\n\tdfs1(1,0);\n\tfor(int i=1;i<=n;++i)\n\t\tif(dis[i]!=d[i]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\tfor(int i=0;i<v.size();++i)\n\t\tprintf(\"%d %d\\n\",v[i].first,v[i].second);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int \n#define F first\n#define S second\n#define pb push_back\nconst ll N = 1e5 + 5, MOD =  1e9 + 7, INF = 1e9 + 10;\nconst long double PI = acos(-1);\nint n, sz[N];\nll h[N];\npair <ll, int> d[N];\nvector <int> adj[N];\nunordered_map <ll, int> mp;\nbool mrk[N];\nvoid dfs(int v){\n\tmrk[v] = 1;\n\tfor (int u : adj[v]){\n\t\th[u] = h[v] + 1;\n\t\tif (!mrk[u]){\n\t\t\tdfs(u);\n\t\t}\n\t}\n\treturn;\n}\nbool ok(){\n\tdfs(d[n].S);\n\tll all = 0;\n\tfor (int i = 1; i <= n; i++){\n\t\tall += h[i];\n\t}\n\treturn (all == d[n].F);\n}\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++){\n\t\tcin >> d[i].F;\n\t\td[i].S = i;\n\t\tmp[d[i].F] = i;\n\t}\n\tsort(d + 1, d + n + 1);\n\treverse(d + 1, d + n + 1);\n\tfor (int i = 1; i <= n; i++){\n\t\tint u = d[i].S;\n\t\tsz[u] = 1;\n\t\tfor (int v : adj[u]){\n\t\t\tsz[u] += sz[v];\n\t\t}\n\t\tll x = d[i].F + 2ll * (ll)sz[u] - (ll)n;\n\t\tif (mp.find(x) == mp.end()) break;\n\t\tadj[mp[x]].pb(u);\n\t}\n\tif (ok()){\n\t\tfor (int u = 1; u <= n; u++){\n\t\t\tfor (int v : adj[u]){\n\t\t\t\tcout << u << ' ' << v << '\\n';\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tcout << \"-1\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\")\n#include <bits/stdc++.h>\n#define owo(i,a, b) for(int i=(a);i<(b); ++i)\n#define uwu(i,a, b) for(int i=(a)-1; i>=(b); --i)\n#define senpai push_back\n#define ttgl pair<int, int>\n#define ayaya cout<<\"ayaya~\"<<endl\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#define ordered_set tree<ttgl, null_type,less<ttgl>, rb_tree_tag,tree_order_statistics_node_update>*/\n \nusing ll = long long;\nusing ld = long double;\nconst ll MOD = 1000000007;\nconst ll root = 62;\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nll binpow(ll a,ll b){ll res=1;while(b){if(b&1)res=(res*a)%MOD;a=(a*a)%MOD;b>>=1;}return res;}\nll modInv(ll a){return binpow(a, MOD-2);}\nconst double PI = acos(-1);\nconst double eps = 1e-6;\nconst int INF = 0x3f3f3f3f;\nconst int NINF = 0xc0c0c0c0;\nconst ll INFLL = 0x3f3f3f3f3f3f3f3f;\nconst ll NINFLL = 0xc0c0c0c0c0c0c0c0;\nconst int mxN = 100001;\nll arr[mxN];\nmap<ll, int> mp;\nint sz[mxN];\nvector<ttgl> ans;\nvector<int> adj[mxN];\nint par[mxN];\nint n;\nint dist[mxN];\nll sd = 0;\nbool istree() {\n    memset(dist, -1, sizeof(dist));\n    queue<int> Q;\n    Q.push(mp[arr[0]]);\n    dist[mp[arr[0]]] = 0;\n    while(!Q.empty()) {\n        int u = Q.front();\n        Q.pop();\n        for(int v: adj[u]) {\n            if(dist[v]!=-1) {\n              return false;\n            }\n            Q.push(v);\n            dist[v] = dist[u]+1;\n        }\n    }   \n    owo(i, 0, n) {\n        if(dist[i]==-1) {\n            return false;\n        }\n        sd+=dist[i];\n    }\n    if(sd!=arr[0])return false;\n    return true;\n}\nint main() {\n    //freopen(\"file.in\", \"r\", stdin);\n    //freopen(\"file.out\", \"w\", stdout);\n    mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n    cin.tie(0)->sync_with_stdio(0);\n    cin>>n;\n    owo(i, 0, n) {\n        cin>>arr[i];\n        mp[arr[i]] = i;\n    }\n    sort(arr, arr+n);\n    uwu(i, n, 1) {\n        int u = mp[arr[i]];\n        sz[u]++;\n        ll k = arr[i] + 2LL*sz[u] - n;\n        if(mp.count(k)) {\n            int v = mp[k];\n            par[u] = v;\n            adj[v].senpai(u);\n            ans.senpai({u, v});\n            sz[v]+=sz[u];\n        }else {\n            cout<<\"-1\\n\";\n            exit(0);\n        }\n    }\n    if(istree()) {\n        for(auto p: ans) {\n            cout<<(p.first+1)<<\" \"<<(p.second+1)<<\"\\n\";\n        }\n    }else {\n        cout<<\"-1\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define LL long long\nusing namespace std;\nint n,size[N],id[N],ans1[N],ans2[N];\nLL tot,a[N];\nmap <LL,int> num;\nvector <int> vec[N];\nbool cmp(int x,int y)\n{\n    return a[x]>a[y];\n}\nvoid dfs(int x,int fa,int d)\n{\n    tot+=(LL)d;\n    for (int i=0;i<vec[x].size();i++)\n    if (vec[x][i]!=fa) dfs(vec[x][i],x,d+1);\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++) scanf(\"%lld\",&a[i]),num[a[i]]=i;\n    for (int i=1;i<=n;i++) size[i]=1,id[i]=i;\n    sort(id+1,id+n+1,cmp);\n    for (int i=1;i<=n-1;i++)\n    {\n        int x=id[i];\n        LL w=a[x]-(n-size[x])+size[x];\n        if (!num[w] || w>=a[x]) {printf(\"-1\");return 0;}\n        int y=num[w];\n        ans1[i]=x;ans2[i]=y;\n        vec[x].push_back(y);\n        vec[y].push_back(x);\n        size[y]+=size[x];\n    }\n    dfs(id[n],0,0);\n    if (tot!=a[id[n]]) {printf(\"-1\");return 0;}\n    for (int i=1;i<=n-1;i++) printf(\"%d %d\\n\",ans1[i],ans2[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int Maxn = 100005;\n\nint n, id[Maxn];\nint par[Maxn], sz[Maxn];\nlong long a[Maxn];\nmap<long long, int> mp;\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%lld\", a + i);\n    id[i] = i, sz[i] = 1;\n    mp[a[i]] = i;\n  }\n  sort(id + 1, id + n + 1, [&](const int &x, const int &y)->bool {\n    return a[x] > a[y];\n  });\n  for (int i = 1; i < n; ++i) {\n    int now = id[i];\n    par[now] = mp[a[now] - n + 2 * sz[now]];\n    if (!par[now]) return puts(\"-1\") & 0;\n    sz[par[now]] += sz[now];\n  }\n  long long sum = 0;\n  for (int i = 1; i < n; ++i) sum += sz[id[i]];\n  if (sum != a[id[n]]) return puts(\"-1\") & 0;\n  for (int i = 1; i < n; ++i)\n    printf(\"%d %d\\n\", id[i], par[id[i]]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint main(void){\n\tint n; cin >> n; P a[n]; int s[n]; fill(s, s+n, 1);\n\tfor(int i=0; i<n; i++) {cin >> a[i].first; a[i].second=i+1;}\n\tsort(a, a+n, greater<P>()); vector<P> v;\n\tbool ok = true; int ss[n]; fill(ss, ss+n, 0);\n\n\tfor(int i=0; i<n-1 && ok; i++) {\n\t\tint p = a[i].first - n + 2 * s[i];\n\t\tint x = lower_bound(a+i+1, a+n, make_pair(p, 0), greater<P>()) - a-1 ;\n\t\tif (x == n) ok = false;\n\t\telse if (a[x].first != p) ok = false;\n\t\ts[x] += s[i]; ss[x] += ss[i] + s[i];\n\t\tint v1 = min(a[x].second, a[i].second);\n\t\tint v2 = max(a[x].second, a[i].second);\n\t\tv.push_back(make_pair(v1, v2));\n\t\t//cout << i << \" \" << x << \" \" << p << \" \" << s[x] << \" \" << ok << \" \" << a[x].first << endl;\n\t}\n\tif (ss[n-1] != a[n-1].first) ok = false;\n\tif (ok == false) {cout << -1 << endl; return 0;}\n\tsort(v.begin(), v.end());\n\tfor(P y:v){\n\t\tcout << y.first << \" \" << y.second << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define eb emplace_back\n#define mt make_tuple\n#define all(x) (x).begin(), (x).end() \n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair <int, int> ii;\ntypedef pair <ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef long double ld;\n\nconst ll INF=LLONG_MAX;\nconst int mxn=1e5+5;\nll sz[mxn];\nbool vis[mxn];\n\nint main()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    //freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout);\n\tint n;\n\tcin >> n;\n\tpair<ll,int> dist[n];\n\tmap<ll,int>mp;\n\tfor(int i=0; i<n; i++){\n\t\tcin >> dist[i].fi;\n\t\tdist[i].se=i;\n\t\tsz[i]=1LL;\n\t\tmp[dist[i].fi]=i;\n\t}\n\tmap<ii,bool>edge;\n\tsort(dist,dist+n);\n\tfor(int i=n-1; i>0; i--){\n\t\tint ind = dist[i].se;\n\t\tll next = dist[i].fi-n+2*sz[ind];\n\t\tif(mp.find(next)==mp.end()||next>=sz[ind]){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint ptr = mp[next];\n\t\tif(ptr==ind){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsz[ptr] += sz[ind];\n\t\tif(ptr>ind)swap(ind,ptr);\n\t\tedge[ii(ptr,ind)]=1;\n\t\tvis[ind]=1; vis[ptr]=1;\n\t}\n\tbool ok=0;\n\tfor(int i=0; i<n&&!ok; i++){\n\t\tif(sz[i]==n)ok=1;\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tif(!vis[i])ok=0;\n\t}\n\tif(!ok)cout << -1 << endl;\n\telse{\n\t\tfor(auto x:edge)\n\t\t\tcout << x.fi.fi+1 << ' ' << x.fi.se+1 << endl;\n\t}\n}\n\t\n// READ & UNDERSTAND\n// ll, int overflow, array bounds, memset(0)\n// special cases (n=1?), n+1 (1-index)\n// do smth instead of nothing & stay organized\n// WRITE STUFF DOWN\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nint N;\nll D[100010];\nvector<pair<int,int>> ans;\nvector<vector<int>> v(100010);\nll dist[100010] = {0},inf = 1e18;\n\nvoid dfs(int n){\n\tfor(int i=0;i<v[n].size();i++){\n\t\tint s = v[n][i];\n\t\tif(dist[s]==inf){\n\t\t\tdist[s] = dist[n]+1;\n\t\t\tdfs(s);\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> N;\n\tmap<ll,int> m,num;\n\tpriority_queue<ll> Q;\n\tfor(int i=1;i<=N;i++){\n\t\tcin >> D[i];\n\t\tm[D[i]] = i;\n\t\tnum[D[i]] = 1;\n\t\tQ.push(D[i]);\n\t\tdist[i] = inf;\n\t}\n\tint count = 0;\n\twhile(count<N-1 && !Q.empty()){\n\t\tll s = Q.top();\n\t\tQ.pop();\n\t\tll t = s-(N-2*num[s]);\n\t\tif(t<=0) continue;\n\t\tif(m.count(t)){\n\t\t\tans.push_back({m[s],m[t]});\n\t\t\tv[m[s]].push_back(m[t]);\n\t\t\tv[m[t]].push_back(m[s]);\n\t\t\tcount++;\n\t\t\tnum[t] += num[s];\n\t\t}\n\t}\n\tdist[1] = 0;\n\tdfs(1);\n\tll sum = 0;\n\tfor(int i=2;i<=N;i++) sum += dist[i];\n\tif(count!=N-1 || sum!=D[1]) cout << -1 << endl;\n\telse{\n\t\tfor(int i=0;i<N-1;i++){\n\t\t\tcout << ans[i].first << \" \" << ans[i].second << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\n#define exp puts(\"-1\"),exit(0);\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nstd::mt19937 rnd(time(NULL));\n#define rand rnd\n#define pr std::pair<int,int>\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\ntemplate<class T>void cxk(T&a,T b){a=a>b?a:b;}\ntemplate<class T>void cnk(T&a,T b){a=a<b?a:b;}\n#ifdef mod\nint pow(int x,int y){\n\tint ret=1;\n\twhile(y){\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;y>>=1;\n\t}\n\treturn ret;\n}\ntemplate<class Ta,class Tb>void inc(Ta&a,Tb b){a=a+b>=mod?a+b-mod:a+b;}\ntemplate<class Ta,class Tb>void dec(Ta&a,Tb b){a=a>=b?a-b:a+mod-b;}\n#endif\nll D[100010];\nint fa[100010],st[100010],siz[100010];\nstd::unordered_map<ll,int>M;\nint main(){\n#ifdef LOCAL\n\tfreopen(\"in.in\",\"r\",stdin);\n\t//freopen(\"out.out\",\"w\",stdout);\n#endif\n\tint n=gi();\n\tfor(int i=1;i<=n;++i)D[i]=gi(),st[i]=i,M[D[i]]=i,siz[i]=1;\n\tstd::sort(st+1,st+n+1,[&](int a,int b){return D[a]<D[b];});\n\tll ssiz=n;\n\tfor(int _=n,i;_>1;--_){\n\t\ti=st[_];\n\t\tif(!(fa[i]=M[D[i]-n+2*siz[i]]))exp;\n\t\tsiz[fa[i]]+=siz[i];ssiz+=siz[i];\n\t}\n\tif(D[st[1]]!=ssiz)exp;\n\tfor(int i=1;i<=n;++i)if(fa[i])printf(\"%d %d\\n\",i,fa[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#define int long long\nusing namespace std;\nconst int N = 1e5 + 5;\nint n, head[N], tot, siz[N], dis[N];\nstruct data{int d, id;}d[N];\nstruct node{int to, nex;}a[N << 1];\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nbool cmp(const data & a, const data & b) {return a.d > b.d;}\nvoid add(int x, int y) {a[++ tot].to = y; a[tot].nex = head[x]; head[x] = tot;}\nvoid dfs(int x, int fa)\n{\n\tfor(int i = head[x]; i; i = a[i].nex)\n\t{\n\t\tint y = a[i].to; if(y == fa) continue;\n\t\tdis[y] = dis[x] + 1; dfs(y, x);\n\t}\n}\nsigned main()\n{\n\tn = read();\n\tfor(int i = 1; i <= n; i ++) {d[i] = data{read(), i}; siz[i] = 1;}\n\tsort(d + 1, d + n + 1, cmp);\n\tfor(int i = 1; i < n; i ++)//<n\n\t{\n\t\tint val = d[i].d - n + 2 * siz[i];\n\t\tint l = 1, r = n + 1, pos;//n + 1\n\t\twhile(l <= r)\n\t\t{\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tif(d[mid].d <= val) pos = mid, r = mid - 1;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tif(d[pos].d != val) {puts(\"-1\"); return 0;}\n\t\tadd(d[i].id, d[pos].id); add(d[pos].id, d[i].id); siz[pos] += siz[i];\n\t}\n\tdfs(d[n].id, 0); int sum = 0;\n\tfor(int i = 1; i <= n; i ++) sum += dis[i];\n\tif(sum != d[n].d) puts(\"-1\");\n\telse {for(int i = 1; i <= tot; i += 2) printf(\"%lld %lld\\n\", a[i].to, a[i + 1].to);}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <map>\n#define __DEBUG__\n#undef __DEBUG__\n#define MAXN 100005\n\nusing namespace std;\n\nint main(){\n    int N;\n    pair<int,int> D[MAXN];//D,ソートする前のノードの番号\n    pair<int,int> ans[MAXN];\n    int Chi[MAXN];\n    map<int,int> Ds;//D,ソート後のノードの番号 配列の逆(Dから配列のindexを探しやすくするため)\n    map<int,int>::iterator it;\n    cin>>N;\n    for(int i = 0;i < N;i++){\n        cin>>D[i].first;\n        D[i].second=i+1;\n        Chi[i]=1;\n    }\n    sort(D,D+N,greater<pair<int,int> >());\n    for(int i = 0;i < N;i++){\n        Ds[D[i].first]=i;\n    }\n#ifdef __DEBUG__\n    cout<<\"sorted:\"<<endl;\n    for(int i = 0;i < N;i++){\n        cout<<D[i].first<<\",\"<<D[i].second<<\"/\";\n    }\n#endif\n    for(int i = 0;i < N-1;i++){\n        int Dj = D[i].first+Chi[i]*2-N;\n        if(it = Ds.find(Dj),it==Ds.end()){\n            cout<<-1<<endl;\n            return 0;\n        }\n        int j = it->second;\n        Chi[j]+=Chi[i];\n        ans[i]=make_pair(D[i].second,D[j].second);\n    }\n    if(Chi[N-1]!=N){\n        cout<<-1<<endl;\n        return 0;\n    }\n    for(int i = 0;i < N-1;i++){\n        cout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include<bits/stdc++.h>\n#include<stdio.h>\n#include<map>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n//#include <bits/c++config.h>\n#include <bits/cpp_type_traits.h>\n#include <ext/type_traits.h>\n#include <math.h>\n#include<cmath>\n#define inc(i,a,b) for(register int i=a;i<=b;i++)\n#define dec(i,a,b) for(register int i=a;i>=b;i--)\nusing namespace std;\ntypedef long long LL;\ninline void read(int &x)\n{\n\tx=0;bool f=0;char c=getchar();\n\twhile(c>'9'||c<'0'){if(c=='-')f=1;c=getchar();}\n\twhile(c<='9'&&c>='0')x=(x<<3)+(x<<1)+c-'0',c=getchar();\n\tif(f)x=-x;return;\n}\ninline void read(LL &x)\n{\n\tx=0;bool f=0;char c=getchar();\n\twhile(c>'9'||c<'0'){if(c=='-')f=1;c=getchar();}\n\twhile(c<='9'&&c>='0')x=(x<<3)+(x<<1)+c-'0',c=getchar();\n\tif(f)x=-x;return;\t\n}\nconst int mx=100007;\nstruct node\n{\n\tint n,t,u;\n}nx[mx];\nint n,siz[mx],cnt,h[mx];\npair <LL,int> d[mx];\n#define f first\n#define s second\nvoid add(int u,int v)\n{\n\tnx[++cnt].n=h[u];\n\tnx[cnt].u=u;\n\tnx[cnt].t=v;\n\th[u]=cnt;\n}\nint find(LL x)\n{\n\tint l=1,r=n,mid=(l+r)>>1;\n\twhile(l<=r)\n\t{\n\t\tif(d[mid].f==x)return mid;\n\t\tif(d[mid].f<x)l=mid+1;\n\t\telse r=mid-1;mid=(l+r)>>1;\n\t}\n\treturn 0;\n}\nLL check;\n#define link(i,x) for(register int i=h[x];i;i=nx[i].n)\nLL dfs(int x,LL upp)\n{\n\tLL res=upp;\n\tlink(i,x)res+=dfs(nx[i].t,upp+1);\n\treturn res;\n}\nint main()\n{\n\tread(n);\n\tinc(i,1,n)\n\t{\n\t\tread(d[i].f);\n\t\td[i].s=i;\n\t\tsiz[i]=1;\n\t}\n\tsort(d+1,d+n+1);\n\tdec(i,n,2)\n\t{\n\t\tint fr=find(d[i].f+(siz[i]<<1)-n);\n\t\tif(fr)add(fr,i),siz[fr]+=siz[i];\n\t\telse {printf(\"-1\\n\");return 0;}\n\t}\n\tcheck=dfs(1,0);\n\tif(check!=d[1].f)return 0;\n\tinc(i,1,cnt)printf(\"%d %d\\n\",d[nx[i].u].s,d[nx[i].t].s);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n#define ll long long\nusing namespace std;\nconst int N=1e5+5;\nint n,id[N],fa[N],siz[N]; ll a[N]; map<ll,int> mp;\nbool cmp(int x,int y){ return a[x]>a[y]; }\nint main(){\n\tscanf(\"%d\",&n);\n\trep (i,1,n){\n\t\tscanf(\"%lld\",&a[i]);\n\t\tmp[a[i]]=i; id[i]=i; siz[i]=1;\n\t}\n\tsort(id+1,id+1+n,cmp);\n\t//rep(i,1,n) cout<<id[i]<<\" \";\n\t//cout<<endl;\n\trep (i,1,n-1){\n\t\tint x=id[i];\n\t\tfa[x]=mp[a[x]-n+2*siz[x]];\n\t\t//cout<<x<<\" \"<<fa[x]<<endl;\n\t\tif (!fa[x]) return puts(\"-1\"),0;\n\t\tsiz[fa[x]]+=siz[x];\n\t}\n\trep (i,1,n-1) a[id[n]]-=siz[id[i]];\n\tif (a[id[n]]) return puts(\"-1\"),0;\n\trep (i,1,n-1) printf(\"%d %d\\n\",id[i],fa[id[i]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,size[100010],fa[100010],tmp=0,cnt=0;\nlong long d[100010];\nmap<long long,int>ma;\nstruct node{\n\tlong long w;\n\tint id;\n\tbool operator <(const node &b)const{\n\t\treturn w<b.w;\n\t}\n};\npriority_queue<node>q;\nint main(){\n\tma.clear();\n\twhile(q.size()) q.pop();\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&d[i]);\n\t\tma[d[i]]=i,size[i]=1;\n\t\tq.push((node){d[i],i});\n\t}\n\twhile(q.size()){\n\t\tnode now=q.top();q.pop();\n\t\tif(size[now.id]==1) tmp++;\n\t\tfa[now.id]=ma[d[now.id]+size[now.id]*2-n];\n\t\tsize[fa[now.id]]+=size[now.id];\n\t}\n\tfor(int i=1;i<=n;i++) if(size[i]==1) cnt++;\n\tif(cnt==tmp){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(fa[i]) printf(\"%d %d\\n\",i,fa[i]);\n\t\t}\n\t}\n\telse printf(\"-1\\n\"); \n}"
  },
  {
    "language": "C++",
    "code": "// ====================================\n//   author: M_sea\n//   website: https://m-sea-blog.com/\n// ====================================\n#include <bits/stdc++.h>\n#define file(x) freopen(#x\".in\",\"r\",stdin); freopen(#x\".out\",\"w\",stdout)\nusing namespace std;\ntypedef long long ll;\n\nll read() {\n\tll X=0; char c=getchar();\n\twhile (c<'0'||c>'9') c=getchar();\n\twhile (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n\treturn X;\n}\n\nconst int N=100000+10;\n\nint n,sz[N],dep[N];\npair<ll,int> d[N];\nvector<int> E[N];\nvector<pair<int,int> > ans;\n\nvoid dfs(int u,int f) {\n\tdep[u]=dep[f]+1;\n\tfor (int v:E[u]) if (v!=f) dfs(v,u);\n}\n\nint main() {\n\tn=read();\n\tfor (int i=1;i<=n;++i) d[i]=make_pair(read(),i);\n\tsort(d+1,d+n+1);\n\tfor (int i=1;i<=n;++i) sz[i]=1;\n\tfor (int i=n;i>1;--i) {\n\t\tll dlt=2*sz[d[i].second]-n+d[i].first;\n\t\tint p=lower_bound(d+1,d+n+1,make_pair(dlt,0))-d;\n\t\tif (d[p].first!=dlt) { puts(\"-1\"); return 0; }\n\t\tint u=d[i].second,v=d[p].second;\n\t\tans.emplace_back(make_pair(u,v));\n\t\tE[u].emplace_back(v),E[v].emplace_back(u),sz[v]+=sz[u];\n\t}\n\tdep[0]=-1,dfs(d[n].second,0); ll s=0;\n\tfor (int i=1;i<=n;++i) s+=dep[i];\n\tif (s!=d[n].first) { puts(\"-1\"); return 0; }\n\tfor (auto i:ans) printf(\"%d %d\\n\",i.first,i.second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 100233;\nint n, size[N], fa[N], dep[N];\npair<int, ll> p[N];\nmap<ll, int> q;\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%lld\", &p[i].second);\n    p[i].first = i;\n    q[p[i].second] = i;\n    size[i] = 1;\n  }\n  sort(p + 1, p + 1 + n, [&](pair<int, ll> a, pair<int, ll> b){return a.second < b.second;});\n  for (int i = n; i >= 2; i--) {\n    int x = p[i].first;\n    ll t = p[i].second + 2 * size[x] - n;\n    if (t >= p[i].second) return puts(\"-1\"), 0;\n    int y = q[t];\n    if (!y) return puts(\"-1\"), 0;\n    size[y] += size[x];\n    fa[x] = y;\n  }\n  ll t = 0;\n  for (int i = 2; i <= n; i++) {\n    int x = p[i].first;\n    dep[x] = dep[fa[x]] + 1;\n    t += dep[x];\n  }\n  if (t != p[1].second) return puts(\"-1\"), 0;\n  for (int i = 2; i <= n; i++) {\n    int x = p[i].first;\n    printf(\"%d %d\\n\", x, fa[x]);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int N=100005;\nint n;\nLL d[N],size[N];\nvector <int> e[N];\nmap <LL,int> Map;\nint depth[N];\nvoid dfs(int x,int d){\n\tdepth[x]=d;\n\tfor (auto y : e[x])\n\t\tdfs(y,d+1);\n}\nbool check(int x,LL v){\n\tif (v!=d[x])\n\t\treturn 0;\n\tfor (auto y : e[x])\n\t\tif (!check(y,v-size[y]+(n-size[y])))\n\t\t\treturn 0;\n\treturn 1;\n}\nbool check(){\n\tdfs(1,0);\n\tLL v=0;\n\tfor (int i=1;i<=n;i++)\n\t\tv+=depth[i];\n\treturn check(1,v);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t\tscanf(\"%lld\",&d[i]);\n\tsort(d+1,d+n+1);\n\tfor (int i=1;i<=n;i++)\n\t\te[i].clear();\n\tMap.clear();\n\tfor (int i=1;i<=n;i++)\n\t\tMap[d[i]]=i,size[i]=1;\n\tfor (int i=n;i>1;i--){\n\t\tLL tmp=d[i]-n+size[i]*2;\n\t\tint fa=Map[tmp];\n\t\tif (!fa)\n\t\t\treturn puts(\"-1\"),0;\n\t\te[fa].push_back(i);\n\t\tsize[fa]+=size[i];\n\t}\n\tif (!check())\n\t\treturn puts(\"-1\"),0;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (auto j : e[i])\n\t\t\tprintf(\"%d %d\\n\",i,j);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n\nusing namespace std;\n\ntypedef long long ll;\n\nmt19937 rnd(228);\n\nint main()\n{\n#ifdef ONPC\n    freopen(\"a.in\", \"r\", stdin);\n#endif\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    vector <pair <ll, int> > e;\n    map <ll, int> ret;\n    for (int i = 0; i < n; i++)\n    {\n        ll x;\n        cin >> x;\n        ret[x] = i;\n        e.push_back({x, i});\n    }\n    sort(e.rbegin(), e.rend());\n    ll x = e.back().first;\n    vector <int> sz(n, 1);\n    vector <pair <int, int> > ans;\n    for (auto c : e)\n    {\n        if (c.first != x)\n        {\n            if (sz[c.second] * 2 >= n)\n            {\n                cout << -1 << '\\n';\n                return 0;\n            }\n            ll need = c.first - (n - 2 * sz[c.second]);\n            if (!ret.count(need))\n            {\n                cout << -1 << '\\n';\n                return 0;\n            }\n            int par = ret[need];\n            sz[par] += sz[c.second];\n            ans.push_back({c.second + 1, par + 1});\n        }\n    }\n    for (auto c : ans)\n    {\n        cout << c.first << ' ' << c.second << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define inf 0x3f3f3f3f\n#define mod 1000000007\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define vi vector <int>\n#define pii pair <int, int>\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i,n) for (int i = 0; i < (int) (n); ++ i)\n#define foreach(it,c) for (__typeof(c.begin()) it = c.begin(); it != c.end(); ++ it)\n\ninline int read() {\n\tint x = 0, f = 1, c = getchar();\n\tfor (;!isdigit(c);c = getchar()) if (c == '-') f ^= 1;\n\tfor (; isdigit(c);c = getchar()) x = x * 10 + c - '0';\n\treturn f ? x : -x;\n}\n\nint n;\nll d[100005];\nmap <ll, int> st;\nvector <pii> e;\n\nint main() {\n\tn = read();\n\trep(i, n) scanf(\"%lld\", &d[i]);\n\trep(i, n) st[d[i]] = i;\n\tint rt = st.begin() -> second;\n\tst.erase(st.begin());\n\twhile (!st.empty()) {\n\t\tint mx = st.rbegin() -> second;\n\t\tll delta = 0;\n\t\twhile (true) {\n\t\t\tll nwd = d[mx];\n\t\t\tdelta += 2;\n\t\t\tll nxtd = nwd - n + delta;\n\t\t\tif (nxtd != d[rt] && !st.count(nxtd)) {\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tst.erase(nwd);\n\t\t\tif (nxtd == d[rt]) {\n\t\t\t\te.pb(mp(rt, mx));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint nxt = st[nxtd];\n\t\t\te.pb(mp(nxt, mx));\n\t\t\tmx = nxt;\n\t\t}\n\t}\n\trep(i, e.size()) if (e[i].first > e[i].second) swap(e[i].first, e[i].second);\n\tsort(e.begin(), e.end());\n\trep(i, e.size()) printf(\"%d %d\\n\", e[i].first + 1, e[i].second + 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+3;\nint n,siz[N],he[N],e;\nlong long anss;\nstruct syzs{\n\tlong long val;\n\tint num;\n} a[N];\nstruct ans{\n\tint e1,e2;\n\tbool operator <(const ans &emm) const{\n\t    if(emm.e1==e1) return e2>emm.e2;\n\t\treturn emm.e1<e1;\n\t}\n};\nstruct edg{\n\tint ne,to;\n} edg[N];\nbool cmp(syzs c,syzs b){\n\treturn c.val>b.val;\n}\nint find(int k){\n\tlong long chec=2*siz[k]-n;\n\tfor(int i=k+1;i<=n;i++) if(a[i].val-a[k].val==chec) return i;\n\treturn -1;\n}\nlong long read(){\n\tlong long s=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}\n\treturn s*f;\n}\nvoid add(int u,int v){\n\tedg[++e].to=v;\n\tedg[e].ne=he[u];\n\the[u]=e;\n}\nvoid test(int u,int fa,int dep){\n\tanss+=dep;\n\tfor(int i=he[u];i;i=edg[i].ne){\n\t\tint v =edg[i].to;\n\t\tif(v==fa) continue;\n\t\ttest(v,u,dep+1);\n\t}\n}\nint main(){\n    priority_queue <ans> q;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\ta[i].val=read();//scanf(\"%lld\",&a[i].val);\n\t\ta[i].num=i;\n\t\tsiz[i]=1;\n\t}\n\tsort(a+1,a+n+1,cmp);\n\tfor(int i=1;i<n;i++){\n\t\tint v=find(i);\n\t\tif(v==-1){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[v]+=siz[i];\n\t\tadd(a[i].num,a[v].num);\n\t\tadd(a[v].num,a[i].num);\n\t\tq.push((ans) {min(a[v].num,a[i].num),max(a[v].num,a[i].num)});\n\t}\n\ttest(a[1].num,0,0);\n\tif(anss!=a[1].val){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\twhile(!q.empty()){\n\t\tint v1=q.top().e1,v2=q.top().e2;\n    \tq.pop();\n    \tprintf(\"%d %d\\n\",v1,v2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\nstruct node\n{\n\tlong long d;int p;\n}a[100010];\nstruct bian\n{\n\tint x,y;\n}e[100010];int len;\nbool cmp(node a,node b){return a.d<b.d;}\nint n;\nbool v[100010];\ninline int erfen(long long x)\n{\n\tint l=1,r=n,ans;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)/2;\n\t\tif(a[mid].d<=x)ans=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\tif(a[ans].d==x)return ans;\n\telse return -1;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i].d),a[i].p=i;\n\tsort(a+1,a+n+1,cmp);\n\tbool bk=true;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tif(v[i]==true)continue;\n\t\tlong long tot=a[i].d;int dep=2,now=i;\n\t\twhile(1)\n\t\t{\n\t\t\ttot=tot-(n-dep)+dep-2;\n\t\t\tint y=erfen(tot);\n\t\t\tif(y==-1){bk=false;break;}\n\t\t\tlen++;\n\t\t\te[len].x=a[y].p;e[len].y=a[now].p;\n\t\t\tv[y]=true;\n\t\t\tif(y==1)break;\n\t\t\tnow=y;dep++;\n\t\t}\n\t}\n\tif(bk==false)printf(\"-1\\n\");\n\telse for(int i=1;i<=len;i++)printf(\"%d %d\\n\",e[i].x,e[i].y);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// sync\n\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 1e3;\n\nint n, m, x[N], y[N], c[2];\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d%d\", x + i, y + i);\n\t\tc[(x[i] + y[i]) & 1]++;\n\t}\n\tif (c[0] && c[1]) return puts(\"-1\"), 0;\n\tprintf(c[0] ? \"32\\n1 \" : \"31\\n\");\n\tfor (int i = 30; i >= 0; i--) printf(\"%d%c\", 1 << i, \" \\n\"[!i]);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (c[0]) putchar('R'), x[i]--;\n\t\tfor (int j = 30; j >= 0; j--)\n\t\t\tif (abs(x[i]) > abs(y[i])) {\n\t\t\t\tif (x[i] > 0)\n\t\t\t\t\tx[i] -= 1 << j, putchar('R');\n\t\t\t\telse\n\t\t\t\t\tx[i] += 1 << j, putchar('L');\n\t\t\t} else {\n\t\t\t\tif (y[i] > 0)\n\t\t\t\t\ty[i] -= 1 << j, putchar('U');\n\t\t\t\telse\n\t\t\t\t\ty[i] += 1 << j, putchar('D');\n\t\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fo(i,s,t) for(int i = s; i <= t; ++ i)\n#define fd(i,s,t) for(int i = s; i >= t; -- i)\n#define bf(i,s) for(int i = head[s]; i; i = e[i].next)\n#define mp make_pair\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pb push_back\n#define VI vector<int>\n#define sf scanf\n#define pf printf\n#define fp freopen\n#define SZ(x) ((int)(x).size())\n#ifdef MPS\n#define D(x...) printf(x)\n#else\n#define D(x...)\n#endif\ntypedef long long ll;\ntypedef double db;\ntypedef unsigned long long ull;\nconst int inf = 1<<30;\nconst ll INF = 1ll<<60;\nconst db Inf = 1e20;\nconst db eps = 1e-9;\n\nvoid gmax(int &a,int b){a = (a > b ? a : b);}\nvoid gmin(int &a,int b){a = (a < b ? a : b);}\n\nconst int maxn = 100050;\n\nint n, sz[maxn];\npair<ll,int> d[maxn];\nstruct edge{int u, v;}e[maxn];\n\nint main()\n{\n\tsf(\"%d\",&n);\n\tfo(i,1,n) sf(\"%I64d\",&d[i].fi), d[i].se = i;\n\tsort(d+1, d+n+1);\n\tfd(i,n,2)\n\t{\n\t\tsz[i] ++;\n\t\tint l = 1, r = i-1, mid, p = -1;\n\t\t/*while(l <= r)\n\t\t{\n\t\t\tmid = (l + r) >> 1;\n\t\t\tif(d[mid].fi <= d[i].fi-n+2*sz[i]) p = mid, l = mid + 1;\n\t\t\telse r = mid - 1;\n\t\t}*/\n\t\tfo(j,1,i-1) if(d[j].fi == d[i].fi-n+2*sz[i]) {p = j; break;}\n\t\tif(p == -1 || d[p].fi != d[i].fi-n+2*sz[i]) return 0 * pf(\"-1\\n\");\n\t\tsz[p] += sz[i];\n\t\te[i].u = d[p].se; e[i].v = d[i].se;\n\t}\n\tsz[1] ++;\n\tll ans = 0;\n\tfo(i,1,n) ans += sz[i] * (ll)(n - sz[i]);\n\tans <<= 1;\n\tfo(i,1,n) ans -= d[i].fi;\n\tif(ans != 0) return 0 * pf(\"-1\\n\");\n\tfo(i,2,n) pf(\"%d %d\\n\",e[i].u,e[i].v);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int ll\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define gc getchar\n#define pc putchar\n#define fi first\n#define se second\n#define debug(x) cout << #x\" = \" << x << endl;\n#define pp(x,y) cout << \"pp: \" << x << \" \" << y << endl;\n#define rank __RAnK\ninline ll read(){\n\tregister ll x=0,f=1;register char c=gc();\n\tfor(;!isdigit(c);c=gc())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\n#define rd read\nvoid write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\nvoid writeln(ll x){write(x);puts(\"\");}\nconst int maxn = 1e5+233;\nvector<pair<int,int> > ans;\nint d[maxn],w[maxn],a[maxn];\nint del,n;\nvoid GG(){\n\tputs(\"-1\"); exit(0);\n}\nbool cmp(int x,int y){\n\treturn d[x] < d[y];\n}\nint query(int l,int r,int need){\n\tint pos = -1;\n\twhile(l<=r){\n\t\tint mid =(l+r)>>1;\n\t\tif(d[a[mid]] - del < need) l = mid + 1; else\n\t\tif(d[a[mid]] - del > need) r = mid - 1; else\n\t\treturn a[mid];\n\t}\n\treturn -1;\n}\nvector<int> edge[maxn];\nint f[maxn],F[maxn],size[maxn];\nvoid dfs(int u,int fa){\n\tf[u] = 0;\n\tsize[u] = 1;\n\tfor(auto v:edge[u]){\n\t\tif(v==fa) continue;\n\t\tdfs(v,u);\n\t\tsize[u] += size[v];\n\t\tf[u] += f[v] + size[v];\n\t}\n}\nvoid DFS(int u,int fa){\n\tif(u==1) F[u]=f[u];\n\tfor(auto v:edge[u]){\n\t\tif(v==fa) continue;\n\t\tF[v] = F[u] + (n - size[v]) - (size[v]);\n\t\tDFS(v,u);\n\t}\n}\nsigned main(){\n\tn = rd();\n\tRep(i,1,n) d[i] = rd();\n\tRep(i,1,n) w[i] = 1;\n\tRep(i,1,n) a[i] = i;\n\tsort(a+1,a+1+n,cmp);\n\tdel = 0;\n\tDep(i,n,2){\n\t\tll need = d[a[i]] - del - (n - w[a[i]]) + w[a[i]]; \n\t\tint pos = query(1,i-1,need);\n\t\tif(pos == -1){\n\t\t\tGG();\n\t\t}\n\t\tdel += w[a[i]];\n\t\tw[pos] += w[a[i]];\n\t\tans . push_back(pii(a[i],pos));\n\t}\n\tfor(auto i:ans){\n\t\tint x = i.fi,y = i.se;\n\t\tedge[x]. push_back(y);\n\t\tedge[y]. push_back(x);\n\t}\n\tdfs(1,0);\n\tDFS(1,0);\n\tsort(d+1,d+1+n);\n\tsort(F+1,F+1+n);\n\tRep(i,1,n){\n\t\tif(d[i] != F[i]){\n\t\t\tGG();\n\t\t}\n\t}\n\tfor(auto i:ans){\n\t\tprintf(\"%lld %lld\\n\",i.fi,i.se);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nconst long long mo=10000007;\nconst int maxn=100010;\n\nint n,m,d[maxn],id[maxn],siz[maxn],js[maxn],fa[maxn],ans;\nint tot,nex[maxn*2],las[maxn*2],tov[maxn*2];\nint hs[mo];\n\nvoid con(int x,int y)\n{\n\ttot++;\n\ttov[tot]=y;\n\tnex[tot]=las[x];\n\tlas[x]=tot;\n}\n\nvoid insert(long long x,int id)\n{\n\tlong long i=x%mo;\n\twhile (hs[i]!=0)\n\t{\n\t\ti++;\n\t\tif (i==mo) i=0;\n\t}\n\ths[i]=id;\n}\n\nint find(long long x)\n{\n\tlong long i=x%mo;\n\twhile (hs[i]!=0 && d[hs[i]]!=x)\n\t{\n\t\ti++;\n\t\tif (i==mo) i=0;\n\t}\n\treturn hs[i];\n}\n\nvoid qsort(int l,int r)\n{\n\tint i=l;int j=r;\n\tlong long m=d[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (d[i]>m) i++;\n\t\twhile (d[j]<m) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(d[i],d[j]);\n\t\t\tswap(id[i],id[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort(l,j);\n\tif (r>i) qsort(i,r); \n}\n\nvoid dfs(int x,int ff)\n{\n\tjs[x]=js[ff]+1;\n\tfor (int i=las[x];i;i=nex[i])\n\t{\n\t\tif (tov[i]!=ff)\n\t\t{\n\t\t\tdfs(tov[i],x);\n\t\t\tans+=js[x];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&d[i]);\n\t\tid[i]=i;\n\t\tsiz[i]=1;\n\t}\n\tqsort(1,n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinsert(d[i],i);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint op=d[i]-n+2*siz[i];\n\t\tint oq=find(op);\n\t\tif (oq==0)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfa[i]=oq;\n\t\t\tsiz[oq]+=siz[i];\n\t\t\tcon(i,oq);con(oq,i);\n\t\t}\n\t}\n\tdfs(n,0);\n\tif (ans!=d[n])\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tfor (int i=1;i<n;i++)\n\t\t{\n\t\t\tprintf(\"%d %d\\n\",id[i],id[fa[i]]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100010;\ntypedef long long int64;\n\nmap<int64 , int> val;\nint n , size[N] , fa[N];\nbool vis[N];\n\nint64 d[N];\ntypedef pair<int64 , int> pii;\npriority_queue<pii> leaf;\n#define mp make_pair \n\nint main() {\n    cin >> n;\n    for(int i = 1 ; i <= n ; ++i) {\n        cin >> d[i];\n        size[i] = 1;\n        val[d[i]] = i; \n    }\n    for(int i = 1 ; i <= n ; ++i) \n        if(val.count(d[i] - n + 2)) leaf.push(mp(d[i] , i)) , vis[i] = 1;\n\n    int cnt = 0;\n    while(leaf.size()) {\n        int x = leaf.top().second;\n        leaf.pop();\n\n\t\tval.erase(d[x]);\n        if(val.count(d[x] - n + size[x]*2))\n            fa[x] = val[d[x] - n + size[x]*2] , cnt++;\n        else continue;\n        \n        size[fa[x]] += size[x];\n        if(!vis[fa[x]]) leaf.push(mp(d[fa[x]] , fa[x])),  vis[fa[x]] = 1;\n    }\n    if(cnt < n - 1) cout << -1 << endl;\n    else {\n        for(int i = 1 ; i <= n ; ++i)\n            if(fa[i]) cout << i << ' ' << fa[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n题意：问能否构造出一棵树，使得对于某点i，到其他所有点的距离和为Di。Di各不相同。 \n如果已知x的size，那么x的父亲的Di=Dx-n+2*size[x],唯一还原\n我们需要从底往上构造\n由于一棵树一定有一个点到其他所有点的距离最小，其余点离此点距离越远，Di越大\n将Di从大到小排序，父亲一定在儿子之后被统计 \n*/\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll; \nconst int N=100005;\nint n,size[N],fa[N];\nmap<ll,int> mp;\nstruct node{int id;ll dis;}p[N];\nbool cmp(const node &A,const node &B){return A.dis>B.dis;}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%lld\",&p[i].dis),p[i].id=i,mp[p[i].dis]=i;\n\tsort(p+1,p+n+1,cmp);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tsize[p[i].id]++;\n\t\tll fa_Di=p[i].dis-n+2*size[p[i].id];\n\t\tif (!mp.count(fa_Di)) return puts(\"-1\"),0;else fa[p[i].id]=mp[fa_Di];\n\t\tif (fa[p[i].id]==p[i].id) return puts(\"-1\"),0;\n\t\tsize[fa[p[i].id]]+=size[p[i].id];\n\t}\n\tfor (int i=1;i<n;i++) p[n].dis-=size[p[i].id];\n\tif (p[n].dis) return puts(\"-1\"),0;\n\tfor (int i=1;i<=n;i++) \n\t  if (fa[i]) printf(\"%d %d\\n\",i,fa[i]); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\nbool is_valid(vector<pair<long long, int>> &D, vector<pair<int, int>> &edges){\n    int N = D.size();\n    vector<vector<int>> G(N);\n    for(auto x : edges){\n        G[x.first].push_back(x.second);\n        G[x.second].push_back(x.first);\n    }\n    queue<pair<int, int>> que;\n    vector<bool> vis(N, false);\n    que.push(make_pair(0, 0));\n    int cnt = 0;\n    while(!que.empty()){\n        auto q = que.front();\n        que.pop();\n        if(vis[q.first]) continue;\n        vis[q.first] = true;\n        cnt += q.second;\n        for(auto x : G[q.first])\n            que.push(make_pair(x, q.second+1));\n    }\n    return cnt == D[0].first;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    vector<pair<long long, int>> D(N);\n    for(int i=0; i<N; i++){\n        long long tmp;\n        cin >> tmp;\n        D[i] = make_pair(tmp, i);\n    }\n    sort(D.begin(), D.end(), greater<pair<long long, int>>());\n\n    vector<int> idx2idx(N);\n    for(int i=0; i<N; i++)\n        idx2idx[i] = D[i].second;\n\n    map<long long, int> d2idx;\n    for(int i=0; i<N; i++)\n        d2idx[D[i].first] = i;\n\n    vector<int> E(N, 0);\n    vector<pair<int, int>> edges;\n    for(int i=0; i<N; i++){\n        if(E[i] == 0) E[i] = 1;\n        long long d0 = D[i].first;\n        long long d1 = D[i].first + 2 * E[i] - N;\n        if(i == N-1) break;\n        auto itr = d2idx.find(d1);\n        if(itr == d2idx.end() || i == d2idx[d1]){\n            cout << -1 << endl;\n            return 0;\n        }\n        edges.push_back(make_pair(i, d2idx[d1]));\n        E[d2idx[d1]] += E[i] + 1;\n    }\n\n    if(!is_valid(D, edges)){\n        cout << -1 << endl;\n        return 0;\n    }\n\n\n    for(auto x : edges)\n        cout << idx2idx[x.first]+1 << \" \" << idx2idx[x.second]+1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <map>\nusing namespace std;\n#define fors(i,a,b) for(int i=(a);i<=(b);++i)\n#define ford(i,a,b) for(int i=(a);i>=(b);--i)\n#define min(x,y) ((x) < (y) ? (x) : (y))\n#define max(x,y) ((x) < (y) ? (y) : (x))\n#define swap(x,y) ((x)^=(y),(y)^=(x),(x)^=(y))\n#define abs(x) ((x) < 0 ? -(x) : (x)) \nconst int maxn=1e6+7;\ntypedef long long ll;\nconst int inf=1<<25;\nll read(){\n    ll s=0,f=1;\n    char c=getchar();\n    while(c<'0' || c>'9') {if(c=='-') f=-1; c=getchar();}\n    while(c>='0' && c<='9') {s=s*10+c-48;c=getchar();}\n    return s*f;\n}\nvoid write(int x){\n    if(x<0) {putchar('-');x=-x;}\n    if(x>9) write(x/10);\n    putchar(x%10+48);\n}\nint tree[101010];\nll d[101010];\nint siz[101010],fa[101010];\nint cmp(int x,int y){\n    return d[x] < d[y];\n}\nmap<ll,int> maps;\nint main()\n{\n    ll n=read();\n    maps.clear();\n    fors(i,1,n){\n        d[i]=read();\n        siz[i]=1;\n        maps[d[i]]=i;\n        tree[i]=i;\n    }\n    sort(tree+1,tree+n+1,cmp);\n    for(int i=n;i>1;i--){\n        fa[tree[i]]=maps[ d[tree[i]]+ 2*siz[tree[i]] -n ];\n        if(!fa[tree[i]]){\n            printf(\"-1\");\n            return 0;\n        }\n        siz[fa[tree[i]]]+=siz[tree[i]];\n    }\n    fors(i,2,n)\n        d[tree[1]]-=siz[tree[i]];\n    if(d[tree[1]]){\n        printf(\"-1\");\n        return 0;\n    }\n    fors(i,2,n)\n        printf(\"%d %d\\n\",fa[tree[i]],tree[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long h[100009];\nlong long sz[100009];\nlong long f[100009];\nlong long D[100009];\nvector<long long> v[100009];\nmap<long long,long long> M;\nvoid dfs(long long x, long long de){\n    f[x] = 1;\n    h[x] = de;\n    for(long long i = 0; i < v[x].size(); i++){\n        if(!f[v[x][i]]) dfs(v[x][i], de + 1);\n    }\n}\nmain(){\n    long long n;\n    cin >> n;\n    for(long long i = 1; i <= n; i++){\n        cin >> D[i];\n        M[D[i]] = i;\n        sz[i] = 1;\n    }\n    int t = D[1];\n    sort(D + 1, D + n + 1);\n    for(long long i= n; i >= 2; i--){\n        long long k = M[D[i]];\n        long long diff = n - 2 * sz[k];\n        if(diff <= 0 || !M[D[i] - diff]){\n            cout << -1 << endl;\n            return 0;\n        }\n\n        v[k].push_back(M[D[i]-diff]);\n        v[M[D[i] - diff]].push_back(k);\n        sz[M[D[i] - diff]] += sz[k];\n\n    }\n\n    dfs(1,0);\n    long long S = 0;\n    for(long long i = 1; i <= n; i++){\n        S += h[i];\n    }\n    if(S == t){\n        for(long long i = 1; i <= n; i++){\n            for(long long j = 0; j < v[i].size(); j++){\n                if(i < v[i][j]){\n                    cout<<i<<\" \"<<v[i][j]<<endl;\n                }\n            }\n        }\n    }\n    else{\n        cout<< -1 << endl;\n        return 0;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#define Maxn 1000008 \nusing namespace std;\ntypedef long long ll;\n\nint n;\nll d;\nint son[Maxn];\nmap <ll,int> M;\n\nstruct node{\n\tint num;\n\tll val;\n}N[Maxn];\n\nbool cmp(node a,node b){\treturn a.val > b.val;}\n\nint main()\n{\n\tmemset(son,0,sizeof(son));\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\tscanf(\"%lld\",&d);\n\t\tM[d] = i;\n\t\tN[i].num = i,N[i].val = d;\n\t}\n\tsort(N+1,N+1+n,cmp);\n\tmap<ll,int>::iterator iter;;\n\tfor(int i = 1;i < n;i ++)\n\t{\n\t\tint u = N[i].num;\n\t\titer = M.find(N[i].val - n + 2 + (son[u] << 1));\n\t\tif(iter == M.end()) continue;\n\t\tint v = iter->second;\n\t\tson[v] += son[u]+1;\n\t\tprintf(\"%d %d\\n\",u,v);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <string>\n#include <cstring>\n\n#define sz(v) ((int)((v).size()))\n#define all(v) (v).begin(), (v).end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int INF = 0x3c3c3c3c;\nconst ll LINF = 1ll*INF*INF*2;\n\nconst int MAX_N = 100001;\nint n;\nll input[MAX_N];\nint sz[MAX_N];\nint par[MAX_N];\nll sum[MAX_N];\n\nvector<pair<ll, int>> v;\n\nint main(void) {\n\tscanf(\"%d\", &n);\n\tll temp;\n\tfor(int i=1; i<=n; i++) {\n\t\tscanf(\"%lld\", &temp);\n\t\tv.push_back(make_pair(temp, i));\n\t}\n\n\tsort(all(v));\n\tfor(int i=0; i<n; i++) input[i] = v[i].first;\n\tfor(int i=0; i<n; i++) sz[i] = 1;\n\n\tfor(int i=n-1; i>0; i--) {\n\t\tll temp = input[i]+sz[i]+sz[i]-n;\n\t\tint idx = lower_bound(input, input+n, temp)-input;\n\t\tif(input[idx] != temp) {\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tpar[i] = idx;\n\t\tsz[idx]+=sz[i];\n\t\tsum[idx]+=sum[i]+sz[i];\n\t}\n\n\tif(sum[0] != input[0]) {\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\n\tfor(int i=1; i<n; i++) {\n\t\tprintf(\"%d %d\\n\", v[par[i]].second, v[i].second);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int MAXN = 100010;\n\nstruct Edge\n{\n\tint to, nxt;\n}e[MAXN << 1];\nint tot, h[MAXN];\n\ninline void add(int u, int v)\n{\n\te[++tot] = (Edge){v, h[u]};\n\th[u] = tot;\n}\n\nstruct Node\n{\n\tint id; ll val;\n\tbool operator < (const Node &x) const\n\t{\n\t\treturn val < x.val;\n\t}\n}d[MAXN];\n\nint n, fa[MAXN], vis[MAXN], siz[MAXN];\nmap<ll, int> H; ll sum;\n\nbool solve(int x)\n{\n\tif(x == 1) return 1;\n\tll now = d[x].val + 2ll * siz[x] - n;\n\tif(H.find(now) == H.end()) return 0;\n\tint id = H[now];\n\tif(!siz[id]) ++siz[id];\n\tsiz[id] += siz[x];\n\tfa[x] = id;\n\tadd(id, x), add(x, id);\n\tif(vis[id]) return 1;\n\tvis[id] = vis[x] = 1;\n\treturn solve(id);\n}\n\nvoid dfs(int x, ll res)\n{\n\tsum += res;\n\tfor(int i = h[x]; i; i = e[i].nxt)\n\t{\n\t\tint y = e[i].to;\n\t\tif(y == fa[x]) continue;\n\t\tdfs(y, res + 1);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tscanf(\"%lld\", &d[i].val);\n\t\td[i].id  = i;\n\t}\n\tsort(d + 1, d + 1 + n);\n\tfor(int i = 1; i <= n; ++i) H[d[i].val] = i;\n\tfor(int i = n; i > 1; --i)\n\t\tif(!vis[i])\n\t\t{\n\t\t\tsiz[i] = 1;\n\t\t\tif(!solve(i)) return puts(\"-1\"), 0;\n\t\t}\n\tdfs(1, 0);\n\tif(sum != d[1].val) return puts(\"-1\"), 0;\n\tfor(int i = 2; i <= n; ++i) printf(\"%d %d\\n\", fa[i], i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//ここから編集する\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N;\n    cin >> N;\n\n    vector<ll> D(N);\n    map<ll, int> Dtov;\n    rep(i, 0, N) cin >> D[i];\n    rep(i, 0, N) Dtov[D[i]] = i + 1;\n\n    sort(D.rbegin(), D.rend());\n\n    vector<vector<int> > G(N + 1, vector<int>());//自分の親\n    vector<vector<int> > rG(N + 1, vector<int>());//自分の子供\n    vector<int> childs(N + 1, 1); //部分木の数\n\n    for (int i = 0; i < N - 1; ++i) {\n//        ll dec = N - 2 * (1 + rG[Dtov[D[i]]].size());\n        ll dec = N - 2 * childs[Dtov[D[i]]];\n        if (find(all(D), D[i] - dec) == D.end()) {\n            cout << -1 << endl;\n            return 0;\n        }\n\n        G[Dtov[D[i]]].push_back(Dtov[D[i] - dec]);\n        rG[Dtov[D[i] - dec]].push_back(Dtov[D[i]]);\n        childs[Dtov[D[i] - dec]] += childs[Dtov[D[i]]];\n    }\n\n    function<ll(int, int)> treesize = [&](int v, int dist) {\n        ll ret = dist;\n\n        for (auto e : rG[v]) {\n            ret += treesize(e, dist + 1);\n        }\n\n        return ret;\n    };\n\n    ll min_tree_size = treesize(Dtov[D.back()], 0);\n    if (min_tree_size != D.back()) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    for (int i = 1; i <= N; ++i) {\n        for (auto e : G[i]) {\n            cout << i << \" \" << e << endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ d.cpp -o d && d > p.txt && g++ t.cpp -o t && t < p.txt\n// d > p.txt && t < p.txt\n// g++ t.cpp -o t\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint main(void){\n\tint n; cin >> n; P a[n]; int s[n]; fill(s, s+n, 1);\n\tfor(int i=0; i<n; i++) {cin >> a[i].first; a[i].second=i+1;}\n\tsort(a, a+n, greater<P>()); vector<P> v;\n\tbool ok = true; int ss[n]; fill(ss, ss+n, 0);\n\n\tfor(int i=0; i<n-1 && ok; i++) {\n\t\tint p = a[i].first - n + 2 * s[i];\n\t\tif (n - 2 * s[i] <= 0) ok = false;\n\t\tint x = lower_bound(a+i+1, a+n, make_pair(p, 0), greater<P>()) - a-1 ;\n\t\tif (x == n) ok = false;\n\t\telse if (a[x].first != p) ok = false;\n\t\ts[x] += s[i]; ss[x] += ss[i] + s[i];\n\t\tint v1 = min(a[x].second, a[i].second);\n\t\tint v2 = max(a[x].second, a[i].second);\n\t\tv.push_back(make_pair(v1, v2));\n\t\t//cout << i << \" \" << x << \" \" << p << \" \" << s[x] << \" \" << ok << \" \" << a[x].first << endl;\n\t}\n\tif (ss[n-1] != a[n-1].first) ok = false;\n\tif (ok == false) {cout << -1 << endl; return 0;}\n\tsort(v.begin(), v.end());\n\tfor(P y:v){\n\t\tcout << y.first << \" \" << y.second << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <algorithm>\n#include <map>\n#define MN 100000\n#define MM 200000\nint n,hd[MN+5],to[MM+5],nxt[MM+5],rn=0;\nstd::map<int,int> mp;\ntypedef std::map<int,int>::iterator iter;\nstruct node{int i,d,sz;}a[MN+5];\nvoid _add(int u,int v){\n\tto[rn]=v,nxt[rn]=hd[u];\n\thd[u]=rn++;\n}\nvoid add(int u,int v){_add(u,v),_add(v,u);}\nvoid gg(){puts(\"-1\");exit(0);}\nint main(){\n//\tfreopen(\"c.in\",\"r\",stdin);\n\tmemset(hd,0xff,sizeof(hd));\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i].d);\n\t\ta[i].i=i,a[i].sz=1;\n\t}\n\tstd::sort(a+1,a+1+n,[](node a,node b)->bool{return a.d>b.d;});\n\tfor(int i=1;i<=n;i++) mp[a[i].d]=i;\n\tfor(int i=1;i<=n;i++){\n\t\tint dta=n-(a[i].sz<<1);\n\t\tif(dta<=0) continue;\n\t\titer it=mp.find(a[i].d-dta);\n\t\tif(it==mp.end()) continue;\n\t\ta[it->second].sz+=a[i].sz;\n\t\tadd(a[i].i,a[it->second].i);\n\t}\n\tif(rn!=(n-1)<<1) gg();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=hd[i];~j;j=nxt[j])\n\t\t\tif(to[j]>i) printf(\"%d %d\\n\",i,to[j]);\n}"
  },
  {
    "language": "C++",
    "code": "// author: Saman Mahdanian\n#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 1e5 + 10;\n\nint n, size[N], p[N];\nmap <long long, int> who_is;\nvector <int> c[N];\nlong long d[N];\n\nvoid contradict_if (bool, string = \"no exit msg\");\nlong long dfs (int, int = -1);\nint get_par (int);\n\nint32_t main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> d[i];\n\t\twho_is[d[i]] = i;\n\t}\n\n\tvector <int> ver(n);\n\tiota (ver.begin(), ver.end(), 0);\n\tsort (ver.begin(), ver.end(), [] (int a, int b) {\n\t\treturn d[a] > d[b];\n\t});\n\tint root = ver.back();\n\n\tfor (int v: ver) {\n\t\tif (v == root)\n\t\t\tcontinue;\n\n\t\tsize[v]++;\n\t\tcontradict_if (size[v] * 2 > n, \"size failture\");\n\n\t\tp[v] = get_par(v);\n\t\tsize[p[v]] += size[v];\n\t\tc[p[v]].push_back(v);\n\t}\n\n\tcontradict_if (dfs(root) != d[root], \"Root failed\");\n\tfor (int v: ver)\n\t\tfor (int u: c[v])\n\t\t\tcout << v + 1 << ' ' << u + 1 << endl;\n}\n\nvoid contradict_if (bool condition, string msg) {\n\tif (!condition)\n\t\treturn;\n\tcout << -1;\n\t// cerr << \" \" << msg;\n\tcout << endl;\n\texit(0);\n}\n\nint get_par (int v) {\n\tlong long pev = d[v] - n + 2 * size[v];\n\tcontradict_if (who_is.find(pev) == who_is.end(), \"parent not found\");\n\treturn who_is[pev];\n}\n\nlong long dfs (int v, int pv) {\n\tlong long res = 0;\n\tfor (int u: c[v])\n\t\tres += size[u] + dfs(u, v);\n\treturn res;\n}\n\n// SamMHD :: 05/12/2018 12:30:04 :: Another Tree..."
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ljc 998244353\nusing namespace std;\n#define gc getchar\ninline ll read(){\n    register ll x=0,f=1;char ch=gc();\n    while (!isdigit(ch)){if (ch=='-') f=-1;ch=gc();}\n    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}\n    return (f==1)?x:-x;\n}\nint n;\nstruct node{\n\tll x;\n\tint id;\n}x[1010101];\ninline bool cmp(node a,node b){\n\treturn a.x>b.x;\n}\nint sz[1010101],ans[1010101];\nmap<ll,int> mp;\nvector<pair<int,int> > as;\nsigned main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++) x[i].x=read(),x[i].id=i,sz[i]=1,mp[x[i].x]=i;\n\tsort(x+1,x+1+n,cmp);\n\tif (n==1){\n\t\tputs(x[1].x==0?\"\":\"-1\");\n\t\treturn 0;\n\t}\n\tif (n==2){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++){\n\t\tif (!mp.count(x[i].x-n+sz[x[i].id]+sz[x[i].id])){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint faa=mp[x[i].x-n+sz[x[i].id]+sz[x[i].id]];\n\t\tas.push_back(make_pair(faa,x[i].id));\n\t\tsz[faa]+=sz[x[i].id];\n\t\tans[faa]+=ans[x[i].id]+sz[x[i].id];\n\t}\n\tif (ans[x[n].id]!=x[n].x){\n\t\tputs(\"-1\");return 0;\n\t}\n\tfor (auto i:as) printf(\"%d %d\\n\",i.first,i.second);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = 1e5 + 100;\nll n;\nvector<vector<ll>> gr;\nvector<pair<ll, ll>> vec;\n\nll sub[SZ];\nmap<ll, ll> m;\n\nint main()\n{\n\tfastInp;\ncout << \"-1\";\nreturn 0;\n\tcin >> n;\n\n\tvec.resize(n);\n\tfor (auto &cur : vec) cin >> cur.first;\n\tfor (int i = 0; i < n; i++) {\n\t\tsub[i] = 1;\n\t\tvec[i].second = i;\n\t\tm[vec[i].first] = vec[i].second;\n\t}\n\n\tsort(vec.rbegin(), vec.rend());\n\n\tvector<pair<ll, ll>> edges;\n\tfor (int i = 0; i < vec.size() - 1; i++) {\n\t\tll par = vec[i].first + sub[vec[i].second] - (n - sub[vec[i].second]);\n\t\tif (m.find(par) == m.end() || m[par] == vec[i].second) {\n\t\t\tcout << \"-1\";\n\t\t\treturn 0;\n\t\t}\n\n\t\tsub[m[par]] += sub[vec[i].second];\n\t\tedges.push_back({ vec[i].second, m[par] });\n\t}\n\n\tfor (auto cur : edges) {\n\t\tcout << cur.first + 1 << \" \" << cur.second + 1 << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep3(i,a,b) for(int i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\n#define MAX_V 400010\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\ntemplate<typename A, size_t NNN, typename T>\nvoid Fill(A (&array)[NNN], const T &val){\n    fill( (T*)array, (T*)(array+NNN), val );\n}\n#define N 100100\n#define INF 1e9+7\nll MOD=1e9+7;\n\nll n;\nstruct node{\n    ll d;int id;\n};\nnode a[N];\nll s[N];\nmain(){\n    n=lin();\n    map<ll,int> m;\n    rep(i,n){\n        a[i]=node{lin(),i+1};\n        m[a[i].d]=a[i].id;\n    }\n    sort(a,a+n,[](node a,node b){\n        return a.d>b.d;\n    });\n    struct edge{\n        int from,to;\n        void print(){\n            printf(\"%d %d\\n\",from,to);\n        }\n    };\n    vector<edge> ans;\n    rep(i,n-1){\n        ll now=a[i].d;\n        ll t=s[a[i].id];\n        now-=n-(2+t*2);\n        if(!m[now]){\n            cout<<-1;return 0;\n        }\n        s[m[now]]+=t+1;\n        ans.pb(edge{a[i].id,m[now]});\n    }\n    for(auto e:ans){\n        e.print();\n    }\n    return 0;\n}   \n"
  },
  {
    "language": "C++",
    "code": "/*\n    _____\n  .'     '.\n /  0   0  \\\n|     ^     |\n|  \\     /  |\n \\  '---'  /\n  '._____.'\n*/\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nstruct chash\n{\n\tint operator()(int x) const\n\t{\n\t\tx ^= (x >> 20) ^ (x >> 12);\n\t\treturn x ^ (x >> 7) ^ (x >> 4);\n\t}\n};\n\ntemplate<typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename U> using hashtable = gp_hash_table<T, U, chash>;\nrandom_device(rd);\nmt19937 rng(rd());\n\ntemplate<class T>\nvoid readi(T &x)\n{\n\tT input = 0;\n\tbool negative = false;\n\tchar c = ' ';\n\twhile (c < '-')\n\t{\n\t\tc = getchar();\n\t}\n\tif (c == '-')\n\t{\n\t\tnegative = true;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0')\n\t{\n\t\tinput = input * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\tif (negative)\n\t{\n\t\tinput = -input;\n\t}\n\tx = input;\n}\ntemplate<class T>\nvoid printi(T output)\n{\n\tif (output == 0)\n\t{\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif (output < 0)\n\t{\n\t\tputchar('-');\n\t\toutput = -output;\n\t}\n\tint aout[20];\n\tint ilen = 0;\n\twhile(output)\n\t{\n\t\taout[ilen] = ((output % 10));\n\t\toutput /= 10;\n\t\tilen++;\n\t}\n\tfor (int i = ilen - 1; i >= 0; i--)\n\t{\n\t\tputchar(aout[i] + '0');\n\t}\n\treturn;\n}\ntemplate<class T>\nvoid ckmin(T &a, T b)\n{\n\ta = min(a, b);\n}\ntemplate<class T>\nvoid ckmax(T &a, T b)\n{\n\ta = max(a, b);\n}\ntemplate<class T, class U>\nT nmod(T &x, U mod)\n{\n\tif (x >= mod) x -= mod;\n}\ntemplate<class T>\nT gcd(T a, T b)\n{\n\treturn (b ? gcd(b, a % b) : a);\n}\ntemplate<class T>\nT randomize(T mod)\n{\n\treturn (uniform_int_distribution<T>(0, mod - 1))(rng);\n}\n\n#define y0 ___y0\n#define y1 ___y1\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fi first\n#define se second\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\nconst long double PI = 4.0 * atan(1.0);\nconst long double EPS = 1e-10;\n\n#define MAGIC 347\n#define SINF 10007\n#define CO 1000007\n#define INF 1000000007\n#define BIG 1000000931\n#define LARGE 1696969696967ll\n#define GIANT 2564008813937411ll\n#define LLINF 2696969696969696969ll\n#define MAXN 100013\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\n\nint N;\npll arr[MAXN];\nint subtree[MAXN];\nint parent[MAXN];\nint ranking[MAXN];\nint depth[MAXN];\nll tot;\n\nint indexof(ll x)\n{\n\tint w = lower_bound(arr, arr + N, MP(x, -LLINF)) - arr;\n\tif (w == N || arr[w].fi != x)\n\t{\n\t\treturn -1;\n\t}\n\treturn w;\n}\n\nint32_t main()\n{\n\tios_base::sync_with_stdio(0);\n\t// cout << fixed << setprecision(10);\n\t// cerr << fixed << setprecision(10);\n\t// freopen (\"file.in\", \"r\", stdin);\n\t// freopen (\"file.out\", \"w\", stdout);\n\tcin >> N;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> arr[i].fi;\n\t\tarr[i].se = i;\n\t}\n\tsort(arr, arr + N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tranking[arr[i].se] = i;\n\t}\n\t//u have them in increasing order of sum to root!\n\tfor (int i = N - 1; i > 0; i--)\n\t{\n    \t//the values of D are all distinct!!!!\n\t\tsubtree[i]++;\n\t\tint idx = indexof(arr[i].fi + 2 * subtree[i] - N);\n\t\tif (idx == -1 || idx >= i)\n\t\t{\n\t\t\tcout << \"-1\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tparent[i] = idx;\n\t\tsubtree[idx] += subtree[i];\n\t}\n\tsubtree[0]++;\n\tdepth[0] = 0;\n\tfor (int i = 1; i < N; i++)\n\t{\n\t\tdepth[i] = depth[parent[i]] + 1;\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\ttot += depth[i];\n\t}\n\t// cerr << \"fuck\\n\";\n\tif (tot != arr[0].fi)\n\t{\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (ranking[i] == 0) continue;\n\t\tcout << i + 1 << ' ' << arr[parent[ranking[i]]].se + 1 << '\\n';\n\t}\n\t// cerr << \"time elapsed = \" << (clock() / (CLOCKS_PER_SEC / 1000)) << \" ms\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define IL inline\n#define _ 1000005\n#define ll long long\nusing namespace std ;\n\nIL ll gi(){\n\tll data = 0 , m = 1; char ch = 0;\n\twhile(ch!='-' && (ch<'0'||ch>'9')) ch = getchar();\n\tif(ch == '-'){m = 0 ; ch = getchar() ; }\n\twhile(ch >= '0' && ch <= '9'){data = (data<<1) + (data<<3) + (ch^48) ; ch = getchar(); }\n\treturn (m) ? data : -data ; \n}\n\nll dis[_],fa[_],sz[_],m,n ; \n\nIL bool cmp(ll A , ll B){return A > B ; }\n\nint main() {\n\tn = gi() ;\n\tfor(int i = 1; i <= n; i ++) dis[i] = gi() ;\n\tsort(dis + 1 , dis + n + 1) ;\n\t//for(int i = 1; i <= n; i ++) cout << dis[i] << \" \" ; cout << endl ;\n\tdis[n + 1] = 1e18 ; \n\tfor(int i = n; i > 1; i --) {\n\t\tsz[i] ++ ; \n\t\tll ds = dis[i] + 2 * sz[i] - n ;\n\t\tint ps = lower_bound(dis + 1 , dis + n + 2 , ds) - dis ;\n\t\t//cout << i << \"  sz=\"<<sz[i]<<\"  ds=\"<<ds<<\"  ps=\"<<ps<<endl ;\n\t\tif(ps >= i) return puts(\"-1\") , 0 ;\n\t\tfa[i] = ps ;\n\t\tsz[ps] += sz[i] ; \n\t}\n\tsz[1] ++ ; \n\tfor(int i = 2; i <= n; i ++) cout << fa[i] << \" \" << i << endl ;\n\treturn 0 ; \n}\n"
  },
  {
    "language": "C++",
    "code": "//\n#include <bits/stdc++.h>\n\n#define endl '\\n'\n#define int ll\nusing namespace std;\ntypedef long long ll;\n\nclass DisjointSet\n{\nprivate:\n    vector<int> pa, sz;\n\npublic:\n    void init(int n)\n    {\n        pa.resize(n), sz.resize(n);\n        for(int i = 0; i < n; i++)\n        {\n            pa[i] = i, sz[i] = 1;\n        }\n    }\n    int findrt(int x)\n    {\n        if(x == pa[x]) return x;\n        else return pa[x] = findrt(pa[x]);\n    }\n    bool same(int x, int y) { return findrt(x) == findrt(y); }\n    int ccSize(int x) { return sz[findrt(x)]; }\n    void uni(int x, int y)\n    {\n        x = findrt(x), y = findrt(y);\n        if(x == y) return;\n        if(sz[x] > sz[y]) swap(x, y);\n        pa[x] = y, sz[y] += sz[x];\n    }\n};\n\nconst int N = 100005;\n\nint vn;\nvector<ll> arr;\nmap<ll, int> ori2idx, val2idx;\n\nvoid init();\nvoid process();\n\nint32_t main()\n{\n    ios::sync_with_stdio(false); cin.tie(0);\n    init();\n    process();\n    cout.flush();\n    return 0;\n}\n\nvoid init()\n{\n    cin >> vn;\n    arr.resize(vn);\n    for(int i = 0; i < vn; i++) cin >> arr[i];\n    for(int i = 0; i < vn; i++) ori2idx[arr[i]] = i;\n    sort(arr.begin(), arr.end());\n    for(int i = 0; i < vn; i++) val2idx[arr[i]] = i;\n}\n\nvoid dfs(int idx, vector<int> tree[])\n{\n    static vector<bool> vis(vn, false);\n    vis[idx] = true;\n    for(auto c:tree[idx])\n    {\n        if(vis[c]) continue;\n        cout << ori2idx[arr[idx]]+1 << \" \" << ori2idx[arr[c]]+1 << endl;\n        dfs(c, tree);\n    }\n}\n\nvoid process()\n{\n    vector<int> tree[N]; \n    DisjointSet ds; ds.init(vn);\n    for(int i = vn-1; i >= 0; i--)\n    {\n        if(ds.ccSize(i) == 1)\n        {\n            int idx = i;\n            while(true)\n            {\n                ll paVal = arr[idx] - vn + 2*ds.ccSize(idx);\n                if(val2idx.count(paVal) == 0) break;\n                int paidx = val2idx[paVal];\n                if(ds.same(idx, paidx)) break;\n                tree[idx].push_back(paidx);\n                tree[paidx].push_back(idx);\n                ds.uni(idx, paidx);\n                idx = paidx;\n            }\n        }\n    }\n    if(ds.ccSize(0) == vn)\n    {\n        dfs(0, tree);\n    }\n    else cout << -1 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \n#define ll long long\n#define all(aaa) aaa.begin(), aaa.end()\n\nconst int N = 1e5 + 5;\nint sz[N];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    cin >> n;\n\n    map<ll, int> mp;\n\n    for (int i = 0; i < n; i++) {\n    \tll d;\n    \tcin >> d;\n    \tmp[d] = i;\n    \tsz[i] = 1;\n    }\n\n    vector<pair<int, int>> v;\n\n    while (!mp.empty()) {\n    \tll x = mp.rbegin()->first;\n    \tint y = mp.rbegin()->second;\n\n    \t// cout << x + 2 * sz[y] - n << \" \" << y << \"\\n\";\n\n    \tif (mp.size() == 1) {\n    \t\tbreak;\n    \t}\n\n    \tif (!mp.count(x + 2 * sz[y] - n) ||\n    \t\tmp[x + 2 * sz[y] - n] == y) {\n    \t\tcout << \"-1\";\n    \t\treturn 0;\n    \t}\n\n    \tint z = mp[x + 2 * sz[y] - n];\n\n    \tsz[z] += sz[y];\n    \tv.push_back({z, y});\n\n    \tmp.erase(prev(mp.end()));\n    }\n\n    for (auto p : v) {\n    \tcout << p.first + 1 << \" \" << p.second + 1 << \"\\n\";\n    }\n\n    return 0;   \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 998244353\n#define ny 499122177\n#define maxn 1000000000000000000LL\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nlong long n,i,x,zz[100005],sum[100005],sum2[100005];\nstruct nyh{\n\tlong long x,id;\n}o[100005];\nmap<long long,long long> mp;\nbool cmp(nyh u,nyh v){\n\treturn u.x<v.x;\n}\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read();\n\tfor(i=1;i<=n;i++){\n\t\to[i].x=read();\n\t\to[i].id=i;\n\t}\n\tsort(o+1,o+n+1,cmp);\n\tfor(i=1;i<=n;i++){\n\t\tmp[o[i].x]=i;\n\t\tsum[i]=1;\n\t}\n\tfor(i=n;i>=2;i--){\n\t\tx=o[i].x-n+sum[i]*2;\n\t\tif(mp[x]!=0&&mp[x]<i){\n\t\t\tzz[i]=mp[x];\n\t\t\tsum[zz[i]]+=sum[i];\n\t\t\tsum2[zz[i]]+=sum[i]+sum2[i];\n\t\t}\n\t\telse{\n\t\t\tpus(-1,2);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif(sum2[1]==o[1].x){\n\t\tpus(-1,2);\n\t\treturn 0;\n\t}\n\tfor(i=n;i>=2;i--){\n\t\tpus(o[zz[i]].id,1);\n\t\tpus(o[i].id,2);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=1e5+10;\nint n,cnt,e,f[N],a[N],id[N],w[N],siz[N],res[N],head[N],link[N],to[N];\nbool vis[111111];\nbool cmp(int x,int y){return a[x]<a[y];}\nvoid add(int u,int v){to[++e]=v,link[e]=head[u],head[u]=e;}\nvoid dfs1(int u,int dep){\n\tsiz[u]=1,res[id[1]]+=dep;\n\tfor(int i=head[u];i;i=link[i])if(to[i]!=f[u])dfs1(to[i],dep+1),siz[u]+=siz[to[i]];\n}\nvoid dfs2(int u){for(int i=head[u];i;i=link[i])if(to[i]!=f[u])res[to[i]]=res[u]+n-2*siz[to[i]],dfs2(to[i]);}\nsigned main(){\n\tscanf(\"%lld\",&n),w[0]=-LLONG_MAX;\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),id[i]=i,w[i]=a[i],siz[i]=1;\n\tsort(id+1,id+n+1,cmp),sort(w+1,w+n+1);\n\tfor(int i=n;i>1;i--){\n\t\tint x=2*siz[id[i]]-n+a[id[i]],pos=lower_bound(w+1,w+n+1,x)-w;\n\t\tif(w[pos]!=x||n-2*siz[id[i]]<=0){printf(\"-1\");return 0;}\n\t\tadd(id[pos],id[i]),siz[id[pos]]+=siz[id[i]],f[id[i]]=id[pos];\n\t}\n\tdfs1(id[1],0),dfs2(id[1]);\n\tfor(int i=1;i<=n;i++)if(a[i]!=res[i]){printf(\"-1\");return 0;}\n\tfor(int i=2;i<=n;i++)printf(\"%lld %lld\\n\",f[id[i]],id[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define maxn 100005\n#define pii pair<int,int>\nusing namespace std;\nint N;\npii arr[maxn];\nvector<int> G[maxn];\nint sz[maxn];\nvector<pii> ans;\nmain() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> N;\n\tfor(int i=1;i<=N;i++)\n\t\tcin >> arr[arr[i].second=i].first;\n\tsort(arr+1,arr+1+N);\n\tfor(int i=1;i<=N;i++)\n\t\tsz[i] = 1;\n\tfor(int i=N;i>1;i--) {\n\t\tint val = arr[i].first;\n\t\tint idx = arr[i].second;\n\t\tint pa_val = val-(N-sz[idx])+(sz[idx]);\n\t\tif(pa_val >= val) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint tem = lower_bound(arr+1,arr+1+N,pii{pa_val,-1})-arr;\n\t\tif(tem==N+1 || arr[tem].first!=pa_val) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint pa = arr[tem].second;\n\t\tsz[pa] += sz[idx];\n\t\tans.emplace_back(pii{pa,idx});\n\t}\n\tfor(pii now : ans)\n\t\tcout << now.first << \" \" << now.second << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)   FOR(i,0,n)\n#define LL long long\n\nint n;\nvector<LL> d,init_d;\nvector<LL> ind,width;\nvector<pair<int,int>> ans;\n\nLL dfs(vector<vector<int>> tree,int pos,LL cum){\n  LL ret = cum;\n  REP(i,tree[pos].size())\n    ret += dfs(tree,tree[pos][i],cum+1);\n  return ret;\n}\n\nint main(){\n  cin>>n;\n  LL tmp;\n  REP(i,n){\n    cin>>tmp;\n    d.push_back(tmp);\n    init_d.push_back(tmp);\n  }\n  sort(d.begin(),d.end());\n  ind.resize(n);\n  REP(i,n){\n    int min_ind = distance(d.begin(),lower_bound(d.begin(),d.end(),init_d[i]));\n    ind[min_ind] = i+1;\n  }\n  REP(i,n){\n    width.push_back(1);\n  }\n\n  vector<vector<int>> tree(n);\n  REP(i,n-1){\n    LL s = d[n-1-i] - (n - 2*width[n-1-i]);\n    //cerr<<s<<endl;\n    int min_ind2 = distance(d.begin(),lower_bound(d.begin(),d.end(),s));\n    if(d[min_ind2] != s || s > d[n-1-i]){\n      cout<<-1<<endl;\n      return 0;\n     }\n    ans.push_back(make_pair(min_ind2,n-1-i));\n    tree[min_ind2].push_back(n-1-i);\n    //tree[n-1-i].push_back(min_ind2);\n    width[min_ind2] += width[n-1-i];\n  }\n  /*\n  if(d[0] != dfs(tree,0,0)){\n    cout<<-1<<endl;\n    return 0;\n  }\n  */\n  REP(i,ans.size())\n    cout<<ind[ans[i].first]<<\" \"<<ind[ans[i].second]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<algorithm>\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\ntypedef long long ll;\nconst int N=200200;\nint n,u,o[N],sz[N],fa[N];\nll t,a[N],su[N];\nmap<ll,int>h;\nbool cmp(int x,int y){return a[x]>a[y];}\nint main(){\n\tscanf(\"%d\",&n);\n\tFOR(i,1,n) scanf(\"%lld\",&a[i]),h[a[i]]=o[i]=i,sz[i]=1;\n\tsort(o+1,o+n+1,cmp);\n\tFOR(i,1,n-1){\n\t\tu=o[i];t=a[u]+2*sz[u]-n;\n\t\tif(!h.count(t) || h[t]==u || fa[h[t]]) return puts(\"-1\"),0;\n\t\tsz[fa[u]=h[t]]+=sz[u];\n\t\tsu[fa[u]]+=su[u]+sz[u];\n\t}\n\tif(su[o[1]]!=a[o[1]]) return puts(\"-1\"),0;\n\tFOR(i,1,n)if(fa[i]) cout<<i<<' '<<fa[i]<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n//#include<ext/rope>\n//using namespace __gnu_cxx\n//#include<ext/pb_ds/priority_queue.hpp>\n//using namespace __gnu_pbds;\n#define lowbit(x) (x&-x)\n#define pb push_back\n#define empb emplace_back\n#define all(x) (x).begin(),(x).end()\n#define clr(a,b) memset(a,b,sizeof(a))\n#define caze(T) for(cin>>T;T;T--)\n#define inf (1<<29)\n#define Endl ('\\n')\n#define fi first\n#define se second\n#define db double\n#define ldb long double\n#define ll long long\n#define pii pair<int,int>\n#define pil pair<int,ll>\n#define pli pair<ll,int>\n#define pll pair<ll,ll>\n#define ull unsigned long long\n#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)\ninline char nc() {\n\t#define SZ 1000000\n\tstatic char buf[SZ], *p1, *p2;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,SZ,stdin),p1==p2)?EOF:*p1++;\n}\ntemplate<typename T>\ninline int scan(T &x) {\n\tchar c, sign=1; \n\twhile(!isdigit(c=nc())&&c!=EOF)if(c=='-')sign*=-1;\n\tif(c==EOF) return EOF;\n\tfor(x = 0; isdigit(c); c = nc())\n\t\tx = (x<<1) + (x<<3) + (c&15);\n\treturn x *= sign, 1;\n}\ntemplate<typename T, typename...Args>\ninline int scan(T &x, Args&...args) {\n\treturn scan(x), scan(args...);\n}\nvoid no(){exit((cout<<-1<<Endl,0));}\nint main()\n{IOS;\n\tint n;cin>>n;\n\tmap<ll,int>id;\n\tvector<ll>d(n);\n\tvector<int>x(n);\n\tvector<vector<int> >G(n);\n\tvector<int>sz(n,1);\n\tfunction<ll(int,int)>dfs=[&](int u,int d)\n\t{\n\t\tll ret=d;\n\t\tfor(auto v:G[u])\n\t\t\tret+=dfs(v,d+1);\n\t\treturn ret;\n\t};\n\tfor(int i=0;i<n;++i)\n\t\tcin>>d[i],id[d[i]]=i;\n\tiota(all(x),0);\n\tsort(all(x),[&](const int&A,const int&B){return d[A]>d[B];});\n\tfor(int i=0;i<n-1;++i)\n\t{\n\t\tint u=x[i];\n\t\tint df=d[u]-n+2*sz[u];\n\t\tif(id.find(df)==id.end()) no();\n\t\tint fa=id[df];\n\t\tG[fa].pb(u);sz[fa]+=sz[u];\n\t}\n\tif(d[x[n-1]]!=dfs(x[n-1],0))\n\t\tno();\n\tfor(int i=0;i<n;++i)\n\t\tfor(auto c:G[i])\n\t\t\tcout<<i+1<<' '<<c+1<<Endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint sz[100005],par[100005];\npair<long long,int> a[100005];\nmap<long long,int> inv;\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&a[i].first);\n\t\ta[i].second=i;\n\t\tsz[i]=1;\n\t\tinv[a[i].first]=i;\n\t}\n\tsort(a+1,a+n+1);\n\tfor (int i=n;i>1;i--)\n\t{\n\t\tif (2*sz[a[i].second]>=n)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint p=inv[a[i].first-n+2*sz[a[i].second]];\n\t\tif (!p)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsz[p]+=sz[a[i].second];\n\t\tpar[a[i].second]=p;\n\t}\n\tfor (int i=2;i<=n;i++)\n\ta[1].first-=sz[a[i].second];\n\tif (a[1].first)\n\tprintf(\"-1\");\n\telse\n\t{\n\t\tfor (int i=2;i<=n;i++)\n\t\tprintf(\"%d %d\\n\",par[a[i].second],a[i].second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define dbg1(x) cerr<<#x<<\"=\"<<(x)<<\" \"\n#define dbg2(x) cerr<<#x<<\"=\"<<(x)<<\"\\n\"\n#define dbg3(x) cerr<<#x<<\"\\n\"\nusing namespace std;\n#define se second\n#define fi first\n#define reg register\n#define mp make_pair\ninline ll read()\n{\n\tll x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nconst int MN=1e5+5;\nll N,D[MN],siz[MN],fa[MN];\nstruct edge{int to,nex;}e[MN<<1];int hr[MN],en;\nvoid ins(int x,int y){e[++en]=(edge){y,hr[x]};hr[x]=en;}\npair<ll,int> a[MN];\nll dfs(int x)\n{\n\treg int i;ll r=0;\n\tfor(i=hr[x];i;i=e[i].nex) r+=dfs(e[i].to)+siz[e[i].to];\n\treturn r;\n}\nint main()\n{\n\tN=read();reg int i,j;\n\tfor(i=1;i<=N;++i) D[i]=read(),a[i]=mp(D[i],i);\n\tstd::sort(a+1,a+N+1);\n\tfor(i=N;i>1;--i)\n\t{\n\t\tint x=a[i].se;\n\t\t++siz[x];\n\t\tint pos=lower_bound(a+1,a+N+1,mp(D[x]+2*siz[x]-N,0))-a;\n\t\tif(pos>=i||D[x]+2*siz[x]-N!=a[pos].fi) return 0*puts(\"-1\");\n\t\tfa[x]=a[pos].se;siz[fa[x]]+=siz[x];ins(fa[x],x);\n\t}\n\t++siz[a[1].se];\n\tif(dfs(a[1].se)!=D[a[1].se]) return 0*puts(\"-1\");\n\tfor(i=1;i<=N;++i)for(j=hr[i];j;j=e[j].nex)printf(\"%d %d\\n\",i,e[j].to);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#define ll long long\n#define inf 0x3f3f3f3f\n#define maxn 200010\ninline ll read()\n{\n\tll x=0; char c=getchar(),f=1;\n\tfor(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n\tfor(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\ninline void write(ll x)\n{\n\tstatic char buf[20];\n\tint len=0;\n\tif(x<0)putchar('-'),x=-x;\n\tfor(;x;x/=10)buf[len++]=x%10+'0';\n\tif(!len)putchar('0');\n\telse while(len)putchar(buf[--len]);\n}\ninline void writesp(ll x){write(x); putchar(' ');}\ninline void writeln(ll x){write(x); putchar('\\n');}\nll d[maxn];\nstd::map<ll,int>mp;\nint id[maxn],fa[maxn],size[maxn];\nint n;\nbool cmp(int x,int y){return d[x]>d[y];}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)\n\t\td[i]=read(),mp[d[i]]=i;\n\tfor(int i=1;i<=n;i++)\n\t\tid[i]=i,size[i]=1;\n\tstd::sort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<n;i++){\n\t\tfa[id[i]]=mp[d[id[i]]-(n-2*size[id[i]])];\n\t\t// printf(\"%d %d %d\\n\",id[i],size[id[i]],fa[id[i]]);\n\t\tif(!fa[id[i]]||d[fa[id[i]]]>=d[id[i]]){\n\t\t\tputs(\"-1\"); return 0;\n\t\t}\n\t\tsize[fa[id[i]]]+=size[id[i]];\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(fa[i])writesp(fa[i]),writeln(i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#define N 100100\n#define pii pair<ll, int>\nusing namespace std;\ntypedef long long ll;\n\nint n, sz[N], fa[N];\npii p[N];\n\nint main() {\n#ifdef isLOCAL\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n;\n\n    for (int i = 1; i <= n; ++i) {\n        long long d;\n        scanf(\"%lld\", &d);\n        p[i] = make_pair(d, i);\n    }\n\n    sort(p + 1, p + n + 1);\n\n    for (int i = n; i > 1; --i) {\n        int u = p[i].second, szp;\n        ++sz[u], szp = n - sz[u];\n        ll tmp = p[i].first + n - 2 * szp;\n        int pos = lower_bound(p + 1, p + n + 1, make_pair(tmp, 0)) - p;\n        pii now = p[pos];\n        if (pos >= i || now.first != tmp) return puts(\"-1\"), 0;\n        sz[fa[u] = now.second] += sz[u];\n        printf(\"%d %d\\n\", fa[u], u);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pi;\nconst int N=1e5+5;\nmap<ll,int>mp;ll s[N];int sz[N],id[N],n,top;pi st[N];\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfp(i,1,n)scanf(\"%lld\",&s[i]),id[i]=i,sz[i]=1,mp[s[i]]=i;\n\tsort(id+1,id+1+n,[](const int &x,const int &y){return s[x]>s[y];});\n\tfp(i,1,n-1){\n\t\tR int u=id[i];\n\t\tif(!mp.count(s[u]-n+(sz[u]<<1)))return puts(\"-1\"),0;\n\t\tR int v=mp[s[u]-n+(sz[u]<<1)];\n\t\tif(s[v]>=s[u])return puts(\"-1\"),0;\n\t\tst[++top]=pi(u,v),sz[v]+=sz[u];\n\t}\n\tfp(i,1,top)printf(\"%d %d\\n\",st[i].fi,st[i].se);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define\tINF\t0x3f3f3f3f\n#define\tLL\tlong long\n#define\tMAXN\t100010\nusing namespace std;\nLL minn;\nint n, size[MAXN], fa[MAXN], F[MAXN];\nstruct info{LL w; int id;}a[MAXN];\n\nbool operator < (info a, info b){\n\treturn a.w < b.w;\n}\n\ntemplate <typename T> void chkmin(T &x, T y){x = min(x, y);}\ntemplate <typename T> void chkmax(T &x, T y){x = max(x, y);}\ntemplate <typename T> void read(T &x){\n\tx = 0; int f = 1; char ch = getchar();\n\twhile (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();}\n\twhile (isdigit(ch)) {x = x * 10 + ch - '0'; ch = getchar();}\n\tx *= f;\n}\n\nint find(int x){\n\tif (fa[x] == x) return fa[x];\n\telse return (fa[x] = find(fa[x]));\n}\n\nint merge(int x, int y){\n\tint fx = find(x), fy = find(y);\n\tif (fx == fy) return 0;\n\tfa[fx] = fy;\n\treturn 1;\n}\n\nint main(){\n\tread(n);\n\tminn = 1ll * INF * INF;\n\tfor (int i = 1; i <= n; ++i){\n\t\tread(a[i].w), a[i].id = i;\n\t\tchkmin(minn, a[i].w);\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tsize[i] = 1, fa[i] = i;\n\tsort(a + 1, a + 1 + n);\n\tfor (int i = n; i > 1; --i){\n\t\tint cur = a[i].id;\n\t\tLL vf = a[i].w + 2 * size[cur] - n;\n\t\t//printf(\"%d %lld\\n\", cur, vf);\n\t\tint f = lower_bound(a + 1, a + 1 + n, (info){vf, 0}) - a;\n\t\tif (a[f].w != vf) {printf(\"-1\\n\"); return 0;}\n\t\tf = a[f].id;\n\t\t//printf(\"%d\\n\", f);\n\t\tint fla = merge(cur, f);\n\t\tif (!fla) {printf(\"-1\\n\"); return 0;}\n\t\tF[cur] = f;\n\t\tsize[f] += size[cur];\n\t}\n\tfor (int i = 1; i <= n; ++i){\n\t\tif (a[i].w == minn) continue;\n\t\tprintf(\"%d %d\\n\", a[i].id, F[a[i].id]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#define Maxn 1000008 \nusing namespace std;\ntypedef long long ll;\n\nint n,cnt;\nll d;\nint son[Maxn];\nmap <ll,int> M;\n\nstruct node{\n\tint num;\n\tll val;\n}N[Maxn];\n\nbool cmp(node a,node b){\treturn a.val > b.val;}\n\nint U[Maxn],V[Maxn];\n\nint main()\n{\n\tmemset(son,0,sizeof(son));\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\tscanf(\"%lld\",&d);\n\t\tM[d] = i;\n\t\tN[i].num = i,N[i].val = d;\n\t}\n\tsort(N+1,N+1+n,cmp);\n\tmap<ll,int>::iterator iter;;\n\tfor(int i = 1;i < n;i ++)\n\t{\n\t\tint u = N[i].num;\n\t\titer = M.find(N[i].val - n + 2 + (son[u] << 1));\n\t\tif(iter == M.end()) continue;\n\t\tint v = iter->second;\n\t\tson[v] += son[u]+1;\n\t\tU[cnt] = u,V[cnt++] = v;\n\t}\n\tif(cnt != n - 1) printf(\"-1\\n\");\n\telse\n\t\tfor(int i = 0;i < cnt;i ++)\n\t\t\tprintf(\"%d %d\\n\",U[i],V[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<math.h>\n#include<stdlib.h>\n#include<set>\n#include<bitset>\n#include<map>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<complex>\n#include<list>\n#include<limits.h>\nusing namespace std;\n\nconst int N=1e5+5;\ntypedef pair<int,int> pii;\nint n;\npair<long long,int> a[N];\nlong long sz[N];\nlong long dp[N];\nvector<pii> vp;\nmap<long long,int> mp;\n\nvoid lnk(int x,int y){\n\tvp.push_back(make_pair(x,y));\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%I64d\",&a[i].first);\n\t\ta[i].second=i;\n\t}\n\tsort(a+1,a+1+n);\n\treverse(a+1,a+1+n);\n\tfor(int i=1;i<=n;i++) mp[a[i].first]=i;\n\tfor(int i=1;i<=n;i++) sz[i]=1ll;\n\tfor(int i=1;i<n;i++){\n\t\tint nxt=mp[a[i].first-1ll*n+2*sz[i]];\n\t\tif(nxt==0){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n//\t\tprintf(\"%d %d\\n\",i,nxt);\n\t\tdp[nxt]+=dp[i]+sz[i];\n//\t\tprintf(\" %lld %lld %d\\n\",dp[i],dp[nxt],sz[i]);\n\t\tsz[nxt]+=sz[i];\n\t\tlnk(a[i].second,a[nxt].second);\n\t}\n\tif(vp.size()!=n-1||dp[n]!=a[n].first) puts(\"-1\");\n\telse for(int i=0;i<vp.size();i++) printf(\"%d %d\\n\",vp[i].first,vp[i].second);\n\treturn 0;\n}\n\n/*\n数据不清空，爆零两行泪\n读题不认真，爆零两行泪\n分析不仔细，爆零两行泪\n建树不构造，爆零两行泪\n变量不统一，爆零两行泪\n边界不算清，爆零两行泪\n数组不开大，爆零两行泪\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nmap<int,int> M1,M2;\nint s1[200010],pa[200010];\nsigned main()\n{\n\tint n=read();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=read();\n\t\tM1[x]=i; M2[x]=1;\n\t\ts1[i]=x;\n\t}\n\tsort(s1+1,s1+1+n);\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tint id=M1[s1[i]],sz=M2[s1[i]],td=s1[i]+2*sz-n;\t\n\t\tif(td==s1[i]) continue;\t\n\t\tpa[id]=M1[td]; M2[td]+=sz;\n\t}\n\tif(M2[s1[1]]!=n) puts(\"-1\"),exit(0);\n\tfor(int i=1;i<=n;i++) if(pa[i])\n\t\tprintf(\"%lld %lld\\n\",i,pa[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<pair<long long, int>> d(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> d[i].first;\n    d[i].second = i;\n  }\n  sort(d.begin(), d.end());\n  vector<pair<int, int>> ans;\n  vector<long long> sum(n);\n  vector<int> sz(n, 1);\n  for (int i = n - 1; i; --i) {\n    long long v = d[i].first - n + 2 * sz[i];\n    int p = lower_bound(d.begin(), d.end(), make_pair(v, 0)) - d.begin();\n    if (p == n || d[p].first != v) {\n      cout << -1 << \"\\n\";\n      return 0;\n    }\n    sum[p] += sum[i] + sz[i];\n    sz[p] += sz[i];\n    ans.emplace_back(d[i].second, d[p].second);\n  }\n  if (sum[0] != d[0].first) {\n    cout << -1 << \"\\n\";\n    return 0;\n  }\n  for (auto p : ans) {\n    cout << p.first + 1 << \" \" << p.second + 1 << \"\\n\";\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MX=1e5+5;\npair<long long,int> a[MX];\nmap<long long,int> mp;\nlong long n;\nint p[MX];\nint visit[MX];\nlong long s[MX];\nlong long dp[MX];\nint main(){\n    cin.tie(0);\n    cout.tie(0);\n    ios_base::sync_with_stdio(0);\n    cin>>n;\n    int i;\n    for(i=1 ; i<=n ; i++){\n        cin>>a[i].first;\n      ///  a[i].first++;\n        a[i].second=i;\n        mp[a[i].first]=i;\n    }\n    sort(a+1,a+n+1);\n    for(i=n ; i>=2 ; i--){\n      ///  cout<<i<<endl;\n        s[a[i].second]++;\n\n        int k=mp[a[i].first+2*s[a[i].second]-n];\n        if(k==0 || k==a[i].second || a[i].first+2*s[a[i].second]-n>=a[i].first){\n            cout<<-1;\n            return 0;\n        }\n        s[k]+=s[a[i].second];\n        dp[k]+=dp[a[i].second]+s[a[i].second];\n        p[a[i].second]=k;\n    }\n    if(dp[a[1].second]!=a[a[1].second].first){\n        cout<<-1;\n        return 0;\n    }\n    for(i=2 ; i<=n ;i++){\n        cout<<a[i].second<<\" \"<<p[a[i].second]<<\"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <bitset>\n#include <deque>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include<stdio.h>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include <math.h>\n#include<cmath>\n#define inc(i,a,b) for(register int i=a;i<=b;i++)\n#define dec(i,a,b) for(register int i=a;i>=b;i--)\nusing namespace std;\ntypedef long long LL;\ninline void read(int &x)\n{\n\tx=0;bool f=0;char c=getchar();\n\twhile(c>'9'||c<'0'){if(c=='-')f=1;c=getchar();}\n\twhile(c<='9'&&c>='0')x=(x<<3)+(x<<1)+c-'0',c=getchar();\n\tif(f)x=-x;return;\n}\ninline void read(LL &x)\n{\n\tx=0;bool f=0;char c=getchar();\n\twhile(c>'9'||c<'0'){if(c=='-')f=1;c=getchar();}\n\twhile(c<='9'&&c>='0')x=(x<<3)+(x<<1)+c-'0',c=getchar();\n\tif(f)x=-x;return;\t\n}\nconst int mx=100007;\nstruct node\n{\n\tint n,t,u;\n}nx[mx];\nint n,siz[mx],cnt,h[mx];\npair <LL,int> d[mx];\n#define f first\n#define s second\nvoid add(int u,int v)\n{\n\tnx[++cnt].n=h[u];\n\tnx[cnt].u=u;\n\tnx[cnt].t=v;\n\th[u]=cnt;\n}\nint find(LL x)\n{\n\tint l=1,r=n,mid=(l+r)>>1;\n\twhile(l<=r)\n\t{\n\t\tif(d[mid].f==x)return mid;\n\t\tif(d[mid].f<x)l=mid+1;\n\t\telse r=mid-1;mid=(l+r)>>1;\n\t}\n\treturn 0;\n}\nLL check;\n#define link(i,x) for(register int i=h[x];i;i=nx[i].n)\nLL dfs(int x,LL upp)\n{\n\tLL res=upp;\n\tlink(i,x)res+=dfs(nx[i].t,upp+1);\n\treturn res;\n}\nint main()\n{\n\tread(n);\n\tinc(i,1,n)\n\t{\n\t\tread(d[i].f);\n\t\td[i].s=i;\n\t\tsiz[i]=1;\n\t}\n\tsort(d+1,d+n+1);\n\tdec(i,n,2)\n\t{\n\t\tint fr=find(d[i].f+(siz[i]<<1)-n);\n\t\tif(fr)add(fr,i),siz[fr]+=siz[i];\n\t\telse {printf(\"-1\\n\");return 0;}\n\t}\n\tcheck=dfs(1,0);\n\tif(check!=d[1].f)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tinc(i,1,cnt)printf(\"%d %d\\n\",d[nx[i].u].s,d[nx[i].t].s);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid err() {\n  cout << -1 << endl;\n  exit(0);\n}\nvoid dfs (int crr, int dpt, vector<vector<int>>& grh, long long& cnt) {\n  cnt += dpt;\n  for (int nxt : grh[crr]) {\n    dfs(nxt, dpt + 1, grh, cnt);\n  }\n}\nint main() {\n  int n;\n  cin >> n;\n  vector<pair<long long, int>> di(n);\n  for (int i = 0; i < n; i++) {\n    int d;\n    cin >> d;\n    di[i] = {d, i};\n  }\n  sort(di.begin(), di.end());\n  vector<int> sz(n, 1), prt(n);\n  vector<vector<int>> grh(n);\n  vector<pair<int, int>> edg;\n  for (auto it = prev(di.end()); it != di.begin(); it--) {\n    auto d = it->first;\n    auto i = it->second;\n    lont long prtv = d - n + 2 * sz[i];\n    auto jt = lower_bound(di.begin(), di.end(), make_pair(prtv, 0));\n    if (jt->first != prtv) err();\n    auto p = jt->second;\n    prt[i] = p;\n    grh[p].push_back(i);\n    if (i == prt[i]) err();\n    sz[prt[i]] += sz[i];\n    edg.emplace_back(min(i, prt[i]), max(i, prt[i]));\n  }\n  long long cnt = 0;\n  int rt = di[0].second;\n  dfs(rt, 0, grh, cnt);\n  if (di[0].first != cnt) err();\n  sort(edg.begin(), edg.end());\n  for (auto const & e : edg) {\n    cout << e.first + 1 << ' ' << e.second + 1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef pair<ll,ll> P;\nlong long int INF = 1e18;\ndouble Pi = 3.1415926535897932384626;\nlong long int mod = 1000000007;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"RULD\";\n//↓,→,↑,←\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,a,b) for(i=a;i<=b;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\n\n\n\nll i,j,k,ii,jj;\nll n,m,num;\nll a,b,c,e,f,g,h,w;\nll x[800005],y[800005],z[900005];\nll d[800005],dp[500005];\nchar s[500005];\nll len[500];\nll vnum = 0;\nbool dame;\n\n\nvoid unite(ll a,ll b){\n    x[vnum] = a;\n    y[vnum] = b;\n    G[a].pb(b);\n    G[b].pb(a);\n    vnum++;\n}\n\nint main(){\n    cin>>n;\n    for(i=0;i<n;i++){\n        cin>>d[i];\n        \n    }\n    sort(d,d+n);\n    //reverse(d,d+n);\n    for(i=n-1;i>=1;i--){\n        //大きい数字から見て行くよ\n        dp[i]++;\n        num = d[i] - n + 2* dp[i];\n        a = lb(d,d+n,num) - lb(d,d+n,-1);\n        if(d[a] != num){\n            //p(\"dame\");\n            //p(a);\n            //p(num);\n            dame = true;\n            break;\n        }else{\n            dp[a] = dp[i];\n            unite(a+1,i+1);\n        }\n    }\n    if(dame){\n        p(-1);\n        return 0;\n    }else{\n        for(i=0;i<vnum;i++){\n            pe(x[i]);p(y[i]);\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define biu (puts(\"-1\"), exit(0))\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename Tp> inline void getint(Tp &num){\n\tregister int ch, neg = 0;\n\twhile(!isdigit(ch = getchar())) if(ch == '-') neg = 1;\n\tnum = ch & 15;\n\twhile(isdigit(ch = getchar())) num = num * 10 + (ch & 15);\n\tif(neg) num = -num;\n}\n\nint N, siz[100005], tope = 0;\nstruct disData {ll d; int id;} D[100005];\nstruct Edge {int np; Edge *nxt;} E[100005], *V[100005];\n\ninline bool operator < (const disData &d1, const disData &d2) {return d1.d < d2.d;}\ninline void addedge(const int &u, const int &v) {E[++tope].np = v, E[tope].nxt = V[u], V[u] = E + tope;}\n\nll getdis(const int &u, const int &dis = 0){\n\tregister ll res = dis;\n\tfor(register Edge *ne = V[u]; ne; ne = ne->nxt) res += getdis(ne->np, dis + 1);\n\treturn res;\n}\n\nint main(){\n\tgetint(N);\n\tfor(register int i = 1; i <= N; i++) getint(D[i].d), D[i].id = i, siz[i] = 1;\n\tsort(D + 1, D + N + 1);\n\tfor(register int i = N; i > 1; i--){\n\t\tif((siz[i] << 1) >= N) biu;\n\t\tconst ll d = D[i].d - N + (siz[i] << 1);\n\t\tconst int fa = lower_bound(D + 1, D + i, (disData){d, 0}) - D;\n\t\tif(D[fa].d != d) biu; siz[fa] += siz[i], addedge(fa, i);\n\t}\n\tif(getdis(1) != D[1].d) biu;\n\tfor(register int i = 1; i <= N; i++)\n\t\tfor(register Edge *ne = V[i]; ne; ne = ne->nxt) printf(\"%d %d\\n\", D[i].id, D[ne->np].id);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <map>\n#include <cstdio>\n#define int long long\n#define pb push_back\n#define mp make_pair\n#define INF 0x3f3f3f3f\n#define Inf 1000000000000000000LL\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int>pii;\nint n;\nmap<int,int>ret;\nvector<pii>e;\nsigned main(){\n\t\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\t\n\tcin>>n;\n\tfor(int i=0LL,x;i<n;i++){\n\t\tcin>>x;\n\t\tret[x]=i;\n\t\te.pb(mp(x,i));\n\t}\n\tsort(e.rbegin(),e.rend());\n\tint x=e.back().F;\n\tvector<int>sz(n,1LL);\n\tvector<int>dp(n,0LL);\n\tvector<pii>ans;\n\tfor(auto c:e){\n\t\tif(c.F!=x){\n\t\t\tif(sz[c.S]*2LL>=n)return puts(\"-1\"),0;\n\t\t\tint p=c.F-(n-2LL*sz[c.S]);\n\t\t\tif(!ret.count(p))return puts(\"-1\"),0;\n\t\t\tint pa=ret[p];\n\t\t\tdp[pa]+=dp[c.S]+sz[c.S];\n\t\t\tsz[pa]+=sz[c.S];\n\t\t\tans.pb(mp(c.S+1LL,pa+1LL));\n\t\t}\n\t}\n\tif(dp[e.back().S]!=x)return puts(\"-1\"),0;\n\tfor(auto c:ans)cout<<c.F<<' '<<c.S<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 2e5 + 10;\n\nint N, rnk[MAX_N], siz[MAX_N], pa[MAX_N], depth[MAX_N];\nll D[MAX_N];\nmap<ll, int> mp;\n\nint main() {\n    scanf(\"%d\", &N);\n    for (int i = 1; i <= N; i++) scanf(\"%lld\", &D[i]), mp[D[i]] = i;\n    for (int i = 1; i <= N; i++) rnk[i] = i, siz[i] = 1;\n    sort(rnk + 1, rnk + N + 1, [](int a, int b) { return D[a] > D[b]; });\n    for (int i = 1; i < N; i++) {\n        int x = rnk[i];\n        ll pd = D[x] + 2 * siz[x] - N;\n        if (siz[x] * 2 < N && mp.count(pd)) {\n            pa[x] = mp[pd];\n            siz[pa[x]] += siz[x];\n        } else {\n            printf(\"-1\\n\");\n            return 0;\n        }\n    }\n    int sum = 0;\n    for (int i = N - 1; i; i--) {\n        int x = rnk[i];\n        depth[x] = depth[pa[x]] + 1;\n        sum += depth[x];\n    }\n    if (sum != D[rnk[N]]) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n    for (int i = 1; i < N; i++) {\n        int x = rnk[i];\n        printf(\"%d %d\\n\", x, pa[x]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#define Maxn 1000008 \nusing namespace std;\ntypedef long long ll;\n\nint n;\nll d;\nint son[Maxn];\nmap <ll,int> M;\n\nstruct node{\n\tint num;\n\tll val;\n}N[Maxn];\n\nbool cmp(node a,node b){\treturn a.val > b.val;}\n\nint main()\n{\n\tmemset(son,0,sizeof(son));\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\tscanf(\"%lld\",&d);\n\t\tM[d] = i;\n\t\tN[i].num = i,N[i].val = d;\n\t}\n\tsort(N+1,N+1+n,cmp);\n\tmap<ll,int>::iterator iter;;\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\tint u = N[i].num;\n\t\titer = M.find(N[i].val - n + 2 + (son[u] << 1));\n\t\tif(iter == M.end()) continue;\n\t\tint v = iter->second;\n\t\tson[v] += son[u]+1;\n\t\tprintf(\"%d %d\\n\",u,v);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n \nint n,nn;\nstruct node{int p,f,s;long long d;};\nnode a[100010];\n \nvoid qsort(int l,int r)\n{\n\tint i,j;\n\tnode m,t;\n\ti=l;j=r;\n\tm=a[(l+r)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (a[i].d>m.d) i++;\n\t\twhile (a[j].d<m.d) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tt=a[i];a[i]=a[j];a[j]=t;\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort(l,j);\n\tif (i<r) qsort(i,r);\n}\n\nint find(long long x)\n{\n\tint l=1,r=n;\n\tint m=(l+r)/2;\n\twhile (l<=r)\n\t{\n\t\tif (a[m].d==x) return m;\n\t\tif (a[m].d>x) l=m+1;\n\t\telse r=m-1;\n\t\tm=(l+r)/2;\n\t}\n\treturn -1;\n}\n \nint main()\n{\n\tscanf(\"%d\",&n);\n\tnn=n-2;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&a[i].d);\n\t\ta[i].p=i;\n\t\ta[i].f=-1;\n\t\ta[i].s=1;\n\t}\n\tqsort(1,n);\n\tbool ok=true;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tlong long fd=a[i].d-(n-a[i].s*2);\n\t\tint fn;\n\t\tfn=find(fd);\n\t\tif (fn==-1 || fn==i) {ok=false;break;}\n\t\ta[i].f=a[fn].p;\n\t\ta[fn].s+=a[i].s;\n\t}\n\tif (ok)\n\t{\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tif (a[i].f!=-1) printf(\"%d %d\\n\",a[i].f,a[i].p);\n\t\t}\n\t}\n\telse printf(\"-1\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <long long, long long> pii;\n\nconst long long MAX_N = 1e5 + 5;\nlong long n, root;\nlong long Arr[MAX_N];\nlong long h[MAX_N];\nlong long Siz[MAX_N];\nlong long Mark[MAX_N];\nlong long par[MAX_N];\nunordered_map <long long, long long> Map;\nvector <pii> edge;\nlong long dp_d[MAX_N];\nlong long dp_u[MAX_N];\nvector <long long> child[MAX_N];\n\nbool cmp(long long a, long long b) {\n\treturn Arr[b] < Arr[a];\n}\n\nvoid dfs1(long long v) {\n\tfor (long long i = 0; i < child[v].size(); i++) {\n\t\tdfs1(child[v][i]);\n\t\tdp_d[v] += dp_d[child[v][i]] + Siz[child[v][i]];\n\t}\n}\n\nvoid dfs2(long long v, long long val) {\n\tdp_u[v] = val;\n\tfor (long long i = 0; i < child[v].size(); i++)\n\t\tdfs2(child[v][i], dp_d[v] + dp_u[v] - dp_d[child[v][i]] - Siz[child[v][i]] + (n - Siz[child[v][i]]));\n}\n\nint main() {\n\tios::sync_with_stdio(false), cout.tie(0), cin.tie(0);\n\tcin >> n;\n\tfor (long long i = 0; i < n; i++) {\n\t\tcin >> Arr[i];\n\t\tSiz[i] = 1;\n\t\th[i] = i;\n\t\tMap[Arr[i]] = i;\n\t}\n\t\t\n\tsort(h, h + n, cmp);\n\t\n\tfor (long long i = 0; i + 1 < n; i++) {\n\t\tlong long v = h[i];\n\t\tlong long tmp = Arr[v] + Siz[v] - (n - Siz[v]);\n\n\t\tif (tmp < 0 || (Map[tmp] == 0 && Arr[0] != tmp)) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tlong long u = Map[tmp];\n\t\tif (Mark[u]) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tSiz[u] += Siz[v];\n\t\tpar[v] = u;\n\t\tedge.push_back({v, u});\n\t\tchild[u].push_back(v);\n\t}\n\troot = h[n - 1];\n\tdfs1(root);\n\tdfs2(root, 0);\n\t\n\tfor (long long i = 0; i < n; i++)\n\t\tif (dp_d[i] + dp_u[i] != Arr[i]) {\n\t\t\tcout << i << \" \" << dp_d[i] + dp_u[i] << \"\\n\";\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\n\tfor (long long i = 0; i + 1 < n; i++)\n\t\tcout << edge[i].first + 1 << \" \" << edge[i].second + 1 << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<ll, int> pii;\n \npii inp[100005];\nint siz[100005];\nvector<pii> ans;\nint main() {\n\tint N; scanf(\"%d\", &N);\n\tfor (int i = 1; i <= N; i++) {\n\t\tll x; scanf(\"%lld\", &x);\n\t\tinp[i] = {x, i};\n\t\tsiz[i] = 1;\n\t}\n\tsort(inp + 1, inp + N + 1);\n\tfor (int i = N; i >= 2; i--) {\n\t\tll cur; int id;\n\t\ttie(cur, id) = inp[i];\n\t\tint n = N - siz[id];\n\t\tll del = n - siz[id];\n\t\tauto it = *lower_bound(inp + 1, inp + N + 1, pii(cur - del, 0));\n\t\tif (it.first != cur - del || !del || siz[id] == N) return !printf(\"-1\");\n\t\tsiz[it.second] += siz[id];\n\t\tif (id > it.second) swap(id, it.second);\n\t\tans.push_back({id, it.second});\n\t}\n\tif (siz[inp[1].second] != N) return !printf(\"-1\");\n\tsort(ans.begin(), ans.end());\n \n\tfor (pii &x : ans) {\n\t\tprintf(\"%lld %d\\n\", x.first, x.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#define int long long\nint n,sz[100100],u[100100],v[100100],D;\nstruct node{\n\tint dis,x;\n\tbool operator<(node b)const{\n\t\treturn dis>b.dis;\n\t}\n}a[100100];\nmap<int,int>mp;\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i].dis);\n\t\ta[i].x=i;\n\t\tmp[a[i].dis]=i;\n\t}\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)sz[i]=1;\n\tfor(int i=1;i<n;i++){\n\t\tint dis=a[i].dis,x=a[i].x;\n\t\tint tmp=dis-abs(n-2*sz[x]);\n\t\tint fa=mp.find(tmp)->second;\n\t\tif(fa==x||!fa)return puts(\"-1\"),0;\n\t\tsz[fa]+=sz[x];\n\t\tD+=sz[a[i].x];\n\t\tu[i]=x,v[i]=fa;\n\t}\n\tif(D!=a[n].dis)return puts(\"-1\"),0;\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%lld %lld\\n\",u[i],v[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint N;\nvector<long long> D;\nvector<pair<long long, int>> sorted;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> N;\n    D.resize(N);\n\n    for (long long &d : D)\n        cin >> d;\n\n    for (int i = 0; i < N; i++)\n        sorted.emplace_back(D[i], i);\n\n    sort(sorted.begin(), sorted.end());\n    vector<int> parent(N, -1);\n    vector<int> subtree_size(N, 1);\n\n    for (int i = N - 1; i > 0; i--) {\n        int current = sorted[i].second;\n        long long goal = sorted[i].first - (N - 2 * subtree_size[current]);\n        int index = lower_bound(sorted.begin(), sorted.end(), make_pair(goal, 0)) - sorted.begin();\n        int who = sorted[index].first == goal ? sorted[index].second : -1;\n\n        if (index >= i || who < 0) {\n            cout << -1 << '\\n';\n            return 0;\n        }\n\n        subtree_size[who] += subtree_size[current];\n        parent[current] = who;\n    }\n\n    for (int i = N - 1; i > 0; i--) {\n        int current = sorted[i].second;\n        cout << current + 1 << ' ' << parent[current] + 1 << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n\nconst int N = 100100;\nconst long long mod = 1e9 + 7;\n\nusing namespace std;\n\nint n;\nint p[N];\nint s[N];\nint f[N];\npair < long long, int > a[N];\n\nint get(int x){ return f[x] == x ? x : f[x] = get(f[x]); }\n\nint main()\n{\n        ios_base::sync_with_stdio(false);\n\n        //freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n\n        cin >> n;\n        for(int i = 1; i <= n; i++){\n                cin >> a[i].fi;\n                a[i].se = i;\n                s[i] = 1;\n                f[i] = i;\n        }\n        sort(a + 1, a + n + 1);\n        map < long long, int > id;\n        for(int i = 1; i <= n; i++){\n                id[a[i].fi] = i;\n        }\n\n        for(int i = n; i > 1; i--){\n                long long dp = a[i].fi;\n                dp = dp + s[i] - (n - s[i]);\n                if(id.find(dp) == id.end()){\n                        cout << -1 << \"\\n\";\n                        return 0;\n                }\n                p[i] = id[dp];\n                s[p[i]] += s[i];\n\n                int px = get(i), py = get(p[i]);\n                if(px == py){\n                        cout << -1 << \"\\n\";\n                        return 0;\n                }\n                f[px] = py;\n        }\n        if(s[1] != n){\n                cout << -1 << \"\\n\";\n                return 0;\n        }\n        for(int i = 2; i <= n; i++){\n                cout << a[i].se << \" \" << a[p[i]].se << \"\\n\";\n        }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int N=1e5+5;\nint n;\nlong long d[N],cur[N];\nint id[N],sz[N],par[N];\nbool cmp(int a,int b){return d[a]>d[b];}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&d[i]);\n\t\tid[i]=i;\n\t\tsz[i]=1;\n\t}\n\tsort(id+1,id+n+1,cmp);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tlong long dpar=d[id[i]]+sz[id[i]]-(n-sz[id[i]]);\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t\tif (dpar==d[id[j]])\n\t\t\t{\n\t\t\t\tpar[id[i]]=id[j];\n\t\t\t\tcur[id[j]]+=cur[id[i]]+sz[id[i]];\n\t\t\t\tsz[id[j]]+=sz[id[i]];\n\t\t\t}\n\t\t\telse\n\t\t\t\tif (dpar>d[id[j]])\n\t\t\t\t\tbreak;\n\t\tif (!par[id[i]])\n\t\t\tbreak;\n\t}\n\tif (cur[id[n]]!=d[id[n]])\n\t\tprintf(\"-1\\n\");\n\telse\n\t\tfor (int i=1;i<n;i++)\n\t\t\tprintf(\"%d %d\\n\",id[i],par[id[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<math.h>\n#include<stdlib.h>\n#include<set>\n#include<bitset>\n#include<map>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<complex>\n#include<list>\n#include<limits.h>\n#include<iomanip>\nusing namespace std;\n\nconst int N=1e5+5;\nint n,rt;\nmap<long long,int> mp;\nint sz[N];\nlong long dp[N];\npriority_queue<long long> pq;\nvector<int> nei[N];\n\nvoid dfs(int x){\n\tfor(int i=0;i<nei[x].size();i++){\n\t\tdfs(nei[x][i]);\n\t\tdp[x]+=dp[nei[x][i]]+sz[nei[x][i]];\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tlong long x;\n\t\tscanf(\"%lld\",&x);\n\t\tmp[x]=i;\n\t\tpq.push(x);\n\t\tsz[i]=1;\n\t}\n\twhile(!pq.empty()){\n\t\tlong long num=pq.top();\n\t\tpq.pop();\n\t\tint x=mp[num];\n\t\trt=x;\n\t\tif(pq.empty()) break;\n\t\tnum-=n-sz[x];\n\t\tnum+=sz[x];\n\t\tif(mp.find(num)==mp.end()){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint y=mp[num];\n\t\tsz[y]+=sz[x];\n\t\tnei[y].push_back(x);\n\t}\n\tdfs(rt);\n\tif(dp[rt]!=(mp.begin())->first){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++) for(int j=0;j<nei[i].size();j++) printf(\"%d %d\\n\",i,nei[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> pii;\n\npii inp[100005];\nint siz[100005];\nvector<pii> ans;\n\nint main() {\n\tint N; scanf(\"%d\", &N);\n\tfor (int i = 1; i <= N; i++) {\n\t\tll x; scanf(\"%lld\", &x);\n\t\tinp[i] = {x, i};\n\t\tsiz[i] = 1;\n\t}\n\tsort(inp + 1, inp + N + 1);\n\tfor (int i = N; i >= 2; i--) {\n\t\tll cur; int id;\n\t\ttie(cur, id) = inp[i];\n\t\tint del = N - 2 * siz[id];\n\t\tauto it = *lower_bound(inp + 1, inp + i, pii(cur - del, 0));\n\t\tif (it.first != cur - del || del <= 0) return !printf(\"-1\");\n\t\tsiz[it.second] += siz[id];\n\t\tif (id > it.second) swap(id, it.second);\n\t\tans.push_back({id, it.second});\n\t}\n\tif (siz[inp[1].second] != N) return !printf(\"-1\");\n\tsort(ans.begin(), ans.end());\n\n\tfor (pii &x : ans) {\n\t\tprintf(\"%lld %d\\n\", x.first, x.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define\tINF\t0x3f3f3f3f\n#define\tLL\tlong long\n#define\tMAXN\t100010\nusing namespace std;\nLL minn, tot;\nint n, size[MAXN], fa[MAXN], F[MAXN];\nstruct info{LL w; int id;}a[MAXN];\n\nbool operator < (info a, info b){\n\treturn a.w < b.w;\n}\n\ntemplate <typename T> void chkmin(T &x, T y){x = min(x, y);}\ntemplate <typename T> void chkmax(T &x, T y){x = max(x, y);}\ntemplate <typename T> void read(T &x){\n\tx = 0; int f = 1; char ch = getchar();\n\twhile (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();}\n\twhile (isdigit(ch)) {x = x * 10 + ch - '0'; ch = getchar();}\n\tx *= f;\n}\n\nint find(int x){\n\tif (fa[x] == x) return fa[x];\n\telse return (fa[x] = find(fa[x]));\n}\n\nint merge(int x, int y){\n\tint fx = find(x), fy = find(y);\n\tif (fx == fy) return 0;\n\tfa[fx] = fy;\n\treturn 1;\n}\n\nint main(){\n\tread(n);\n\tminn = 1ll * INF * INF;\n\tfor (int i = 1; i <= n; ++i){\n\t\tread(a[i].w), a[i].id = i;\n\t\tchkmin(minn, a[i].w);\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tsize[i] = 1, fa[i] = i;\n\tsort(a + 1, a + 1 + n);\n\tfor (int i = n; i > 1; --i){\n\t\tint cur = a[i].id;\n\t\tLL vf = a[i].w + 2 * size[cur] - n;\n\t\t//printf(\"%d %lld\\n\", cur, vf);\n\t\tif (vf <= 0) {printf(\"-1\\n\"); return 0;}\n\t\tint f = lower_bound(a + 1, a + 1 + n, (info){vf, 0}) - a;\n\t\tif (a[f].w != vf) {printf(\"-1\\n\"); return 0;}\n\t\tf = a[f].id;\n\t\t//printf(\"%d\\n\", f);\n\t\tint fla = merge(cur, f);\n\t\tif (!fla) {printf(\"-1\\n\"); return 0;}\n\t\tF[cur] = f;\n\t\tsize[f] += size[cur];\n\t\ttot += size[cur];\n\t}\n\tif (tot != a[1].w) {printf(\"-1\\n\"); return 0;}\n\tfor (int i = 2; i <= n; ++i)\n\t\tprintf(\"%d %d\\n\", a[i].id, F[a[i].id]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<map>\n#define rep(i,x,y) for(int i=(x);i<=(y);i++)\nusing namespace std;\ntypedef long long ll;\nint n;\nconst int N=200005;\nmap<long long,int> mp;\nlong long a[N];\nint id[N];\nint fa[N],size[N];\nbool cmp(int x,int y){return a[x]>a[y];}\nint main()\n{\n//freopen(\"input.txt\",\"r\",stdin);\nios::sync_with_stdio(false);\ncin.tie(0);\nint n;\ncin >>n;\nrep(i,1,n)cin >>a[i],id[i]=i,mp[a[i]]=i,size[i]=1;\nsort(id+1,id+1+n,cmp);\nrep(i,1,n-1)\n\t{\n\tint x=id[i];\n\tfa[x]=mp[a[x]-n+2*size[x]];\n\tif(!fa[x])return cout <<-1,0;\n\tsize[fa[x]]+=size[x];\n\t}\nrep(i,1,n-1)\n\t{\n\ta[id[n]]-=size[id[i]];\n\t}\nif (a[id[n]]) return puts(\"-1\"),0;\nrep (i,1,n-1) cout <<id[i]<<' '<<fa[id[i]]<<'\\n';\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define re register\nlong long d[1001000];\nint p[1001000],pq[1001000],fa[1001000],sz[1001000],n;\ninline bool cmp(re int A,re int B){return d[A]<d[B];}\ninline bool cmp1(re int A,re int B){return d[A]-n+2*sz[A]<d[B]-n+2*sz[B];}\nint main()\n{\n\tre int ta=1;\n\tscanf(\"%d\",&n);\n\tfor(re int i=1;i<=n;i++)scanf(\"%lld\",&d[i]),p[i]=i,sz[i]=1;\n\tsort(p+1,p+n+1,cmp);\n\tpq[1]=p[n];\n\tfor(re int i=n-1;i;i--)\n\t{\n\t\twhile(ta&&d[p[i]]==d[pq[1]]-n+2*sz[pq[1]])\n\t\t{\n\t\t\tfa[pq[1]]=p[i];sz[p[i]]+=sz[pq[1]];\n\t\t\tpop_heap(pq+1,pq+ta+1,cmp1);\n\t\t\tta--;\n\t\t}\n\t\tpq[++ta]=p[i];\n\t\tpush_heap(pq+1,pq+ta+1,cmp1);\n\t}\n\tif(ta!=1)puts(\"-1\");\n\telse\n\t{\n\t\tre long long ans=0;\n\t\tfor(re int i=1;i<=n;i++)if(fa[i])ans+=sz[i];else ans-=d[i];\n\t\tif(ans==0){for(re int i=1;i<=n;i++)if(fa[i])printf(\"%d %d\\n\",i,fa[i]);}\n\t\telse puts(\"-1\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// ====================================\n//   author: M_sea\n//   website: https://m-sea-blog.com/\n// ====================================\n#include <bits/stdc++.h>\n#define file(x) freopen(#x\".in\",\"r\",stdin); freopen(#x\".out\",\"w\",stdout)\nusing namespace std;\ntypedef long long ll;\n\nll read() {\n\tll X=0; char c=getchar();\n\twhile (c<'0'||c>'9') c=getchar();\n\twhile (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n\treturn X;\n}\n\nconst int N=100000+10;\n\nint n,sz[N],dep[N];\npair<ll,int> d[N];\nvector<int> E[N];\nvector<pair<int,int> > ans;\n\nvoid dfs(int u,int f) {\n\tdep[u]=dep[f]+1;\n\tfor (int v:E[u]) if (v!=f) dfs(v,u);\n}\n\nint main() {\n\tn=read();\n\tfor (int i=1;i<=n;++i) d[i]=make_pair(read(),i);\n\tsort(d+1,d+n+1);\n\tfor (int i=1;i<=n;++i) sz[i]=1;\n\tfor (int i=n;i>1;--i) {\n\t\tll dlt=2*sz[i]-n+d[i].first;\n\t\tint p=lower_bound(d+1,d+n+1,make_pair(dlt,0))-d;\n\t\tif (d[p].first!=dlt) { puts(\"-1\"); return 0; }\n\t\tint u=d[i].second,v=d[p].second;\n\t\tans.emplace_back(make_pair(u,v));\n\t\tE[u].emplace_back(v),E[v].emplace_back(u),sz[p]+=sz[i];\n\t}\n\tdep[0]=-1,dfs(d[n].second,0); ll s=0;\n\tfor (int i=1;i<=n;++i) s+=dep[i];\n\tif (s!=d[n].first) { puts(\"NO\"); return 0; }\n\tfor (auto i:ans) printf(\"%d %d\\n\",i.first,i.second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int ll\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define gc getchar\n#define pc putchar\n#define fi first\n#define se second\n#define debug(x) cout << #x\" = \" << x << endl;\n#define pp(x,y) cout << \"pp: \" << x << \" \" << y << endl;\n#define rank __RAnK\ninline ll read(){\n\tregister ll x=0,f=1;register char c=gc();\n\tfor(;!isdigit(c);c=gc())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\n#define rd read\nvoid write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\nvoid writeln(ll x){write(x);puts(\"\");}\nconst int maxn = 1e5+233;\nvector<pair<int,int> > ans;\nint d[maxn],w[maxn],a[maxn];\nint del,n;\nbool cmp(int x,int y){\n\treturn d[x] < d[y];\n}\nint query(int l,int r,int need){\n\tint pos = -1;\n\twhile(l<=r){\n\t\tint mid =(l+r)>>1;\n\t\tif(d[a[mid]] - del < need) l = mid + 1; else\n\t\tif(d[a[mid]] - del > need) r = mid - 1; else\n\t\treturn a[mid];\n\t}\n\treturn -1;\n}\nsigned main(){\n\tn = rd();\n\tRep(i,1,n) d[i] = rd();\n\tRep(i,1,n) w[i] = 1;\n\tRep(i,1,n) a[i] = i;\n\tsort(a+1,a+1+n,cmp);//从小到大排序 \n\tdel = 0;\n\tDep(i,n,2){\n\t\t/*当前是a[i] - del，权重为w[i]\n\t\t移动一步\n\t\t对于所有(n-w[i])个点，都要减少1*/\n\t\tll need = d[a[i]] - del - (n - w[a[i]]) + w[a[i]]; \n\t\tint pos = query(1,i-1,need);//找到标号\n\t\tif(pos == -1){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tdel += w[a[i]];\n\t\tw[pos] += w[a[i]];\n\t\tans . push_back(pii(a[i],pos));\n\t}\n\tif(d[a[1]] != del){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(auto i:ans){\n\t\tprintf(\"%lld %lld\\n\",i.fi,i.se);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//ここから編集する\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N;\n    cin >> N;\n\n    vector<ll> D(N);\n    map<ll, int> Dtov;\n    rep(i, 0, N) cin >> D[i];\n    rep(i, 0, N) Dtov[D[i]] = i + 1;\n\n    sort(D.rbegin(), D.rend());\n    vector<vector<int> > G(N, vector<int>());\n    vector<bool> used(D.size(), false);\n    vector<pair<int, int>> ans;\n\n    for (int i = 0; i < N - 1; ++i) {\n        if (!used[i]) {\n            used[i] = true;\n\n//            for (int k = N - 2; k > 0; k -= 2) {\n//                if (find(all(D), D[i] - k) == D.end()) {\n//                    cout << -1 << endl;\n//                    return 0;\n//                } else {\n//                    ans.emplace_back(Dtov[D[i]], Dtov[D[i] - k]);\n//                }\n//            }\n            ll tmp = D[i];\n            ll dec = N - 2;\n            while (tmp > D.back()) {\n                if (find(all(D), tmp - dec) == D.end()) {\n                    cout << -1 << endl;\n                    return 0;\n                } else {\n                    ans.emplace_back(Dtov[tmp], Dtov[tmp - dec]);\n//                    used[Dtov[tmp - dec]] = true;\n                    used[find(all(D), tmp - dec) - D.begin()] = true;\n                    tmp -= dec;\n                    dec -= 2;\n                }\n            }\n        }\n    }\n\n    for (auto e : ans) {\n        cout << e.first << \" \" << e.second << endl;\n//        cout << e.second << \" \" << e.first << endl;\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\nconst int N = 2e5;\nint n, cnt;\nint fa[N], ff[N];\nLL di[N], siz[N];\nmap <LL, int> val;\npair <int, int> edges[N];\nint ord[N];\nint get_f(int t)\n{\n    if (ff[t] == t) return t;\n    else return ff[t] = get_f(ff[t]);\n}\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; ++ i) scanf(\"%lld\", &di[i]);\n    for (int i = 1; i <= n; ++ i) ord[i] = i, val[di[i]] = i, ff[i] = i;\n    sort(ord + 1, ord + n + 1, [=](int a, int b) {return di[a] > di[b];});\n    for (int i = 1; i < n; ++ i)\n    {\n        int p = ord[i];\n        siz[p] += 1;\n        LL q = di[p] + siz[p] * 2 - n;\n        if (!val.count(q)) {puts(\"-1\"); return 0;}\n        fa[p] = val[q];\n        if (di[p] < di[fa[p]]) {puts(\"-1\"); return 0;}\n        if (get_f(p) == get_f(fa[p])) {puts(\"-1\"); return 0;}\n        ff[get_f(p)] = get_f(fa[p]);\n        siz[fa[p]] += siz[p];\n        edges[i] = make_pair(p, fa[p]);\n    }\n    for (int i = 1; i < n; ++ i) printf(\"%d %d\\n\", edges[i].first, edges[i].second);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+3;\nint n,siz[N];\nstruct syzs{\n\tlong long val;\n\tint num;\n} a[N];\nstruct ans{\n\tint e1,e2;\n\tbool operator <(const ans &emm) const{\n\t    if(emm.e1==e1) return e2>emm.e2;\n\t\treturn emm.e1<e1;\n\t}\n};\nbool cmp(syzs c,syzs b){\n\treturn c.val>b.val;\n}\nint find(int k){\n\tlong long chec=a[k].val+2*siz[k]-n;\n\tfor(int i=k+1;i<=n;i++) if(a[i].val==chec) return i;\n\treturn -1;\n}\nlong long read(){\n\tlong long s=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}\n\treturn s*f;\n}\nint main(){\n\tpriority_queue <ans> q;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\ta[i].val=read();//scanf(\"%lld\",&a[i].val);\n\t\ta[i].num=i;\n\t\tsiz[i]=1;\n\t}\n\tsort(a+1,a+n+1,cmp);\n\tfor(int i=1;i<n;i++){\n\t\tint v=find(i);\n\t\tif(v==-1){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[v]+=siz[i];\n\t\tq.push((ans) {min(a[v].num,a[i].num),max(a[v].num,a[i].num)});\n\t}\n\twhile(!q.empty()){\n\t\tint v1=q.top().e1,v2=q.top().e2;\n    \tq.pop();\n    \tprintf(\"%d %d\\n\",v1,v2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define Rep(i,v) rep(i,0,(int)v.size()-1)\n#define mp make_pair\n#define fir first\n#define sec second\n#define pb push_back\n#define gc getchar()\n#define lint long long\n#define debug(x) cerr<<#x<<\"=\"<<x\n#define sp <<\" \"\n#define ln <<endl\n#define wrong return !printf(\"-1\\n\")\n#define N 100010\nusing namespace std;\ntypedef pair<int,int> pii;\ninline int inn()\n{\n\tint x,ch;while((ch=gc)<'0'||ch>'9');\n\tx=ch^'0';while((ch=gc)>='0'&&ch<='9')\n\t\tx=(x<<1)+(x<<3)+(ch^'0');return x;\n}\nstruct P{\n\tlint d;int id;\n\tinline bool operator<(const P &p)const{return d>p.d;}\n}p[N];int n;\nvector<int> g[N];\nint us[N],vs[N],sz[N];\nlint d[N];map<lint,int> sv;\nint getdrt(int x,int l,int rt)\n{\n\td[rt]+=l;\n\tRep(i,g[x]) getdrt(g[x][i],l+1,rt);\n\treturn 0;\n}\nint getd(int x)\n{\n\tRep(i,g[x]) d[g[x][i]]=d[x]+n-2*sz[g[x][i]],getd(g[x][i]);\n\treturn 0;\n}\nint main()\n{\n\tn=inn();\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&p[i].d),p[i].id=i,sv[p[i].d]=i;\n\tfor(int i=1;i<=n;i++) sz[i]=1;\n\tsort(p+1,p+n+1);//from big to small\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x=p[i].id;\n\t\tlint dlt=n-2*sz[x];\n\t\tif(dlt<=0) wrong;\n\t\tif(!sv.count(p[i].d-dlt)) wrong;\n\t\tint fa=sv[p[i].d-dlt];\n\t\tus[i]=fa,vs[i]=x,sz[fa]+=sz[x];\n\t}\n\tfor(int i=1;i<n;i++) g[us[i]].pb(vs[i]);\n\tint rt=p[n].id;getdrt(rt,0,rt),getd(rt);\n\tfor(int i=1;i<=n;i++)\n\t\tif(d[p[i].id]!=p[i].d) wrong;\n\tfor(int i=1;i<n;i++) printf(\"%d %d\\n\",us[i],vs[i]);\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author zjsdut\n */\n\n#ifndef ALGO_UTILS\n#define ALGO_UTILS\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <vector>\ntemplate<typename A, typename B>\nbool chkmin(A &a, const B &b) {\n  if (b < a) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate<typename A, typename B>\nbool chkmax(A &a, const B &b) {\n  if (b > a) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing vl = std::vector<ll>;\nusing vb = std::vector<bool>;\nusing vi = std::vector<int>;\nusing pii = std::pair<int, int>;\nusing pli = std::pair<ll, int>;\nusing pil = std::pair<int, ll>;\nusing pll = std::pair<ll, ll>;\nusing vpii = std::vector<pii>;\ntemplate<typename T>\nclass vv {\n  std::vector<std::vector<T>> data;\n\n public:\n  vv(int n, int m, T init = T{}) {\n    assert(n > 0 && m > 0);\n    data.assign(n, std::vector<T>(m, init));\n  }\n  std::vector<T> &operator[](size_t i) { return data[i]; }\n};\n#define rng3(i, a, b) for (std::common_type<decltype(a), decltype(b)>::type i = a; i < b; ++i)\n#define rng2(i, n) rng3(i, 0, n)\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define rng(...) GET_MACRO(__VA_ARGS__, rng3, rng2)(__VA_ARGS__)\n#define up(i, a, b) for (std::common_type<decltype(a), decltype(b)>::type i = a; i <= b; ++i)\n#define down(i, b, a) for (std::common_type<decltype(a), decltype(b)>::type i = b; i >= a; i--)\n#define TOKENPASTE(x, y) x##y\n#define TOKENPASTE2(x, y) TOKENPASTE(x, y)\n#define rep(n)                                                                                     \\\n  for (int TOKENPASTE2(_iter_, __LINE__) = 0, TOKENPASTE2(_num_, __LINE__) = n;                    \\\n       TOKENPASTE2(_iter_, __LINE__) < TOKENPASTE2(_num_, __LINE__);                               \\\n       ++TOKENPASTE2(_iter_, __LINE__))\n#define FOR(x, cont) for (const auto &x : cont)\n#define For(x, cont) for (auto &x : cont)\n#define ALL(x) begin(x), end(x)\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ep emplace\n#define SZ(x) (int) (x).size()\n#define UNIQ(vec) (vec).erase(std::unique(ALL(vec)), std::end(vec))\n#define LB(cont, x) int(std::lower_bound(ALL(cont), x) - std::begin(cont))\n#define UB(cont, x) int(std::upper_bound(ALL(cont), x) - std::begin(cont))\ntemplate<typename T, typename U = std::less<T>>\nusing pq = std::priority_queue<T, std::vector<T>, U>;\ntemplate<typename T>\nstruct reversion_wrapper {\n  T &iterable;\n};\ntemplate<typename T>\nauto begin(reversion_wrapper<T> w) {\n  return std::rbegin(w.iterable);\n}\ntemplate<typename T>\nauto end(reversion_wrapper<T> w) {\n  return std::rend(w.iterable);\n}\ntemplate<typename T>\nreversion_wrapper<T> reverse(T &&iterable) {\n  return {iterable};\n}\ntemplate<typename T, typename U>\nT ceil(T x, U y) {\n  assert(y > 0);\n  if (x > 0) x += y - 1;\n  return x / y;\n}\n\ntemplate<typename T, typename U>\nT floor(T x, U y) {\n  assert(y > 0);\n  if (x < 0) x -= y - 1;\n  return x / y;\n}\n#endif\n#ifndef JHELPER_EXAMPLE_PROJECT_LIBRARY_IO_HPP_\n#define JHELPER_EXAMPLE_PROJECT_LIBRARY_IO_HPP_\n#include <iostream>\n#include <iomanip>\n\nstruct fast_ios {\n  fast_ios() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n    std::cout << std::fixed << std::setprecision(10);\n  };\n} fast_ios_;\n\ntemplate<typename T>\nstd::istream &operator>>(std::istream &stream, std::vector<T> &vec) {\n  for (auto &x : vec)\n    stream >> x;\n  return stream;\n}\n\ntemplate<typename T, typename U>\nstd::istream &operator>>(std::istream &in, std::pair<T, U> &p) {\n  in >> p.first >> p.second;\n  return in;\n}\n\nvoid scan() {}\n\ntemplate<class T, class... Args>\nvoid scan(T &a, Args &... rest) {\n  std::cin >> a;\n  scan(rest...);\n}\n\ntemplate<typename T>\nstd::ostream &operator<<(std::ostream &stream, const std::vector<T> &vec) {\n  bool first = true;\n  for (const T &t : vec) {\n    if (first) first = false;\n    else std::cout << ' ';\n    std::cout << t;\n  }\n  return stream;\n}\n\ntemplate<typename T, typename U>\nstd::ostream &operator<<(std::ostream &out, const std::pair<T,U> &p) {\n  out << p.first << ' ' << p.second;\n  return out;\n}\n\ntemplate<typename T>\nvoid print(const std::vector<std::vector<T>> &t) {\n  for (const auto &row : t) {\n    std::cout << row << '\\n';\n  }\n}\n\ntemplate<typename T>\nvoid print(const T &t) { std::cout << t << ' '; }\n\ntemplate<typename T, typename... Args>\nvoid print(const T &t, const Args &... rest) {\n  print(t);\n  print(rest...);\n}\n\ntemplate<typename T>\nvoid println(const T &t) { std::cout << t << '\\n'; }\n\ntemplate<typename T, typename... Args>\nvoid println(const T &t, const Args &... rest) {\n  print(t);\n  println(rest...);\n}\n#endif //JHELPER_EXAMPLE_PROJECT_LIBRARY_IO_HPP_\n\nusing namespace std;\nclass FDistanceSums {\npublic:\n  static void solve(istream&, ostream&) {\n    int n;\n    scan(n);\n    vi sz(n, 1);\n    map<ll,int> index;\n    rng (i,n) {\n      ll d;\n      scan(d);\n      index[d] = i;\n    }\n    vi parent(n, -1);\n    auto iter = index.rbegin();\n    rep (n - 1) {\n      ll d = iter->first;\n      int i = iter->second;\n      ll nd = d + 2 * sz[i] - n;\n      if (nd >= d) {\n        println(-1);\n        return;\n      }\n      auto iter2 = index.find(nd);\n      if (iter2 == index.end()) {\n        println(-1);\n        return;\n      }\n      sz[iter2->second] += sz[i];\n      parent[i] = iter2->second;\n      ++iter;\n    }\n    vi depth(n);\n    for (auto it = next(index.begin()); it != index.end(); ++it) {\n      depth[it->second] = depth[parent[it->second]] + 1;\n    }\n    if (accumulate(ALL(depth), 0ll) != index.begin()->first) {\n      println(-1);\n    }\n    else {\n      rng (i, n) if (parent[i] != -1) println(i + 1, parent[i] + 1);\n    }\n  }\n};\n/*\n * Make sure that your laptop is plugged in or the build may be slow.\n */\n\n#define in std::cin\n#define out std::cout\nint main() {\n  FDistanceSums solver;\n  solver.solve(in, out);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fo(i,s,t) for(int i = s; i <= t; ++ i)\n#define fd(i,s,t) for(int i = s; i >= t; -- i)\n#define bf(i,s) for(int i = head[s]; i; i = e[i].next)\n#define mp make_pair\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pb push_back\n#define VI vector<int>\n#define sf scanf\n#define pf printf\n#define fp freopen\n#define SZ(x) ((int)(x).size())\n#ifdef MPS\n#define D(x...) printf(x)\n#else\n#define D(x...)\n#endif\ntypedef long long ll;\ntypedef double db;\ntypedef unsigned long long ull;\nconst int inf = 1<<30;\nconst ll INF = 1ll<<60;\nconst db Inf = 1e20;\nconst db eps = 1e-9;\n\nvoid gmax(int &a,int b){a = (a > b ? a : b);}\nvoid gmin(int &a,int b){a = (a < b ? a : b);}\n\nconst int maxn = 100050;\n\nint n, sz[maxn];\npair<ll,int> d[maxn];\nstruct edge{int u, v;}e[maxn];\n\nint main()\n{\n\tsf(\"%d\",&n);\n\tfo(i,1,n) sf(\"%I64d\",&d[i].fi), d[i].se = i;\n\tsort(d+1, d+n+1);\n\tfd(i,n,2)\n\t{\n\t\tsz[i] ++;\n\t\tint l = 1, r = i-1, mid, p = -1;\n\t\twhile(l <= r)\n\t\t{\n\t\t\tmid = (l + r) >> 1;\n\t\t\tif(d[mid].fi <= d[i].fi-n+2*sz[i]) p = mid, l = mid + 1;\n\t\t\telse r = mid - 1;\n\t\t}\n\t\tif(p == -1 || d[p].fi != d[i].fi-n+2*sz[i]) return 0 * pf(\"-1\\n\");\n\t\tsz[p] += sz[i];\n\t\te[i].u = d[p].se; e[i].v = d[i].se;\n\t}\n\tsz[1] ++;\n\tll ans = 0;\n\tfo(i,1,n) ans += sz[i] * (ll)(n - sz[i]);\n\tans <<= 1;\n\tfo(i,1,n) ans -= d[i].fi;\n\tif(ans != 0) return 0 * pf(\"-1\\n\");\n\tfo(i,2,n) pf(\"%d %d\\n\",e[i].u,e[i].v);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\n#define all(x) (x).begin(),(x).end()\n\n\nint main() {\n#ifdef local\n\tfreopen(\"in.txt\", \"r\", stdin);\n#endif\n\tios::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tint n; cin >> n;\n\tvector<pair<ll, ll> > d(n);\n\tfor(int i = 0; i < n; i++) {\n\t\tll x; cin >> x;\n\t\td[i] = make_pair(x, i);\n\t}\n\tvector<int> sz(n, 1);\n\tsort(all(d), greater<pair<ll,ll>>());\n\tvector<pair<int, int> > edges;\n\tfor(int i = 0; i < n - 1; i++) {\n\t\tll id = d[i].se, dis = d[i].fi;\n\t\tint dt = n - 2*sz[id];\n\t\tdis -= dt;\n\t\tauto it = lower_bound(all(d), pair<ll, ll>(dis, n), greater<pair<ll, ll> >());\n\t\tif(it == d.end() || it->fi != dis) {\n\t\t\tcout << \"-1\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tsz[it->se] += sz[id];\n\t\tedges.emplace_back(id + 1, it->se + 1);\n\t}\n\tsort(all(edges));\n\tfor(auto &e : edges) {\n\t\tcout << e.fi << ' ' << e.se << '\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define eb emplace_back\n#define fi first\n#define se second\nusing namespace std;\nusing cd = complex <double>;\n\nconst long long INF = 1e18; \nconst long long mod = 998244353;//200003;786433;1e9 + 7;\nconst double Pi = acos(-1);\n  \nvoid Fastio()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n}\n\nint n;\nint root;\nint dsu[100005];\nlong long mindis = INF;\nlong long d[100005], sz[100005];\nmap <long long, int> M; \nvector <pair <int, int> > Edge;\nvector <int> Adj[100005];\n\nint Root(int node)\n{\n\treturn dsu[node] == node ? node : dsu[node] = Root(dsu[node]);\n}\n\nsigned main()\n{\n\tFastio();\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tcin >> d[i];\n\t\tsz[i] = 1;\n\t\tM[d[i]] = i;\n\t\tif(d[i] < mindis)\n\t\t{\n\t\t\troot = i;\n\t\t\tmindis = d[i];\n\t\t}\n\t}\n\twhile(M.size() > 1)\n\t{\n\t\tpair <long long, int> temp = *(prev(M.end()));\n\t\tlong long realdis = temp.fi - n + sz[temp.se] * 2;\n\t\tif(M.count(realdis) == false)\n\t\t{\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\tif(Root(temp.se) == Root(M[realdis]))\n\t\t{\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\tdsu[Root(temp.se)] = Root(M[realdis]);\n\t\tEdge.eb(temp.se, M[realdis]);\n\t\tsz[M[realdis]] += sz[temp.se];\n\t\tM.erase(temp.fi);\n\t}\n\tif(Edge.size() != n - 1 || sz[root] != n)\n\t{\n\t\tcout << \"-1\";\n\t\treturn 0;\n\t}\n\tfor(auto x : Edge)\n\t{\n\t\tcout << x.fi << ' ' << x.se << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\n#define Accepted 0; \n\nconst int Maxv = 100010; \nlong long d[Maxv], d1[Maxv], u[Maxv], ghostfly233[Maxv], siz[Maxv], cnt, n;  \n\ninline int GldHkkowoSearch(int x) {\n    int tmp = std::lower_bound(d + 1, d + n + 1, x) - d;\n\n    if (d[tmp] != x) {\n        puts(\"-1\"); \n        exit(0); \n    }\n\n    return tmp; \n}\n\nint main() {\n    scanf(\"%lld\", &n); \n    for (int i = 1; i <= n; i++) {\n        scanf(\"%lld\", &d[i]); \n        d1[i] = d[i]; \n    }\n\n    std::sort(d + 1, d + n + 1); \n    for (int i = 1; i <= n; i++) \n        ghostfly233[GldHkkowoSearch(d1[i])] = i;       \n\n    for (int i = 1; i <= n; i++)\n        siz[i] = 1; \n\n    for (int i = n; i > 1; i--) {\n        u[i] = GldHkkowoSearch(d[i] - n + (siz[i] << 1)); \n        siz[ u[i] ] += siz[i]; \n        cnt += siz[i]; \n    }\n\n    if (cnt != d[1]) {\n        puts(\"-1\"); \n        return 0; \n    }\n\n    for (int i = 2; i <= n; i++)\n        printf(\"%lld %lld\\n\", ghostfly233[i], ghostfly233[ u[i] ]); \n\n    return Accepted;  \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cassert>\n#include<iostream>\n#include<algorithm>\n#include<unordered_map>\n\nusing namespace std;\n\n#define Whats(x) cout<<#x<<\" is \"<<(x)<<endl\n#define DivHim() cout<<\">>>>>>>>>>>>>>>\"<<endl\n#define DivHer() cout<<\"<<<<<<<<<<<<<<<\"<<endl\n#define Oops() cout<<\"!!!!!!!!!!!!!!!\"<<endl\n\ntemplate<typename T> bool GetMin(T &a,T b)\n{\n\treturn ((a<=b)?false:(a=b,true));\n}\n\ntemplate<typename T> bool GetMax(T &a,T b)\n{\n\treturn ((a>=b)?false:(a=b,true));\n}\n\n/*\n\t -<Unlimited Blade Works>-\n */\n\n#define int long long\n\nconst int N=1e5+10;\n\nint n,d[N],id[N],sz[N],fa[N];\nunordered_map<int,int> re;\n\nbool Cmp(int x,int y)\n{\n\treturn d[x]>d[y];\n}\n\nsigned main()\n{\n\tscanf(\"%lld\",&n);\n\tif(n==2)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%lld\",d+i);\n\t\tre[d[i]]=i;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tid[i]=i;\n\t\tsz[i]=1;\n\t}\n\tsort(id+1,id+n+1,Cmp);\n\tfor(int i=1,u,v,x;i<n;++i)\n\t{\n\t\tre[d[u=id[i]]]=0;\n\t\tif((x=sz[u]+sz[u]-n)>0||!(v=re[d[u]+x]))\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsz[fa[u]=v]+=sz[u];\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tif(fa[i])\n\t\t\tprintf(\"%lld %lld\\n\",fa[i],i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdint>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX = 100000;\n\ntypedef struct node {\n\tint id;\n\tint64_t num;\n\tint edge;\n\tint height;\n\tbool operator<(const node& r) const {\n\t\treturn num < r.num;\n\t}\n} Node;\n\nint main() {\n\tint N;\n\tint64_t D;\n\tstatic Node node[MAX];\n\tcin >> N;\n\tfor (int i = 0;i < N;++ i) {\n\t\tcin >> node[i].num;\n\t\tnode[i].id = i + 1;\n\t\tnode[i].height = 1;\n\t}\n\tsort(node, node + N);\n\t\n\tint64_t sum = 0; // 1からの距離\n\tfor (int i = N - 1;i > 0;-- i) { // 大きい数字から確定させる\n\t\tint min = 0, max = i - 1, check = node[i].num - N + (node[i].height << 1);\n\t\tfor (int mid = i >> 1;max - min > 1;mid = min + (max - min >> 1)) {\n\t\t\tif (node[mid].num > check) max = mid;\n\t\t\telse min = mid;\n\t\t}\n\t\tif (node[min].num != check) { // 繋げる辺が存在しなかった\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\tnode[i].edge = min;\n\t\tnode[min].height += node[i].height;\n\t\tsum += node[i].height;\n\t}\n\t\n\tif (sum != node[0].num) {\n\t\tcout << -1;\n\t\treturn 0;\n\t}\n\tfor (int i = N - 1;i > 0;-- i) {\n\t\tcout << node[i].id << \" \" << node[node[i].edge].id << endl;\n\t}\n\treturn 0;\n}\n/*\n31536000のコメント解説欄\nここテンプレで用意してるから、A問題とかだとこの先空欄の危険あり\nまた、コンテスト後に https://31536000.hatenablog.com/ で解説していると思うので、良かったら読んでねー\n\n解説AC\n数字の大きい方の頂点から確定させることを考える\nこの時、この頂点から繋ぐ辺は、自分の数-N+(現時点の自分の属する木の高さ*2)となることが数学的に証明できる(解説放送参照)\nということは二分探索していけばO(NlogN)で判定と構築ができるわけだ\n最後に本当に正しいか確認だけして、問題ないなら構築完了\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#include<map>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=100000 +117;\nconst int MM=100000 +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint m,n;\nLL a[NN]={};\nint ord[NN]={};\nint siz[NN]={};\nmap<LL,int> ind;\nbool cmp(int x,int y){\n\treturn a[x]>a[y];\n}\nvector<int> p[NN]={};\nint dis[NN]={};\nvoid dfs(int x){\n\tfor(int i=0;i<p[x].size();++i){\n\t\tint cur=p[x][i];\n\t\tdis[cur]=dis[x]+1;\n\t\tdfs(cur);\n\t}\n}\nint main(){\n\t//open();\n\tn=read();\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%lld\",&a[i]);\n\t\tord[i]=i;\n\t\tind[a[i]]=i;\n\t}\n\tsort(ord+1,ord+1+n,cmp);\n\tbool fl=0;\n\tfor(int i=1;i<n;++i){\n\t\tint x=ord[i];\n\t\tsiz[x]+=1;\n\t\tLL xt=a[x]-n+2*siz[x];\n\t\tif(xt>=a[x])fl=1;\n\t\tint tp=ind[xt];\n\t\tif(!tp){\n\t\t\tfl=1;\n\t\t}\n\t\telse{\n\t\t\tp[tp].push_back(x);\n\t\t\tsiz[tp]+=siz[x];\n\t\t}\n\t}\n\tdfs(ord[n]);\n\tLL chk=0;\n\tfor(int i=1;i<=n;++i)chk+=dis[i];\n\tif(chk!=a[ord[n]])fl=1;\n\tif(fl){\n\t\tprintf(\"-1\\n\");\n\t}\n\telse{\n\t\tfor(int x=1;x<=n;++x){\n\t\t\tfor(int i=0;i<p[x].size();++i){\n\t\t\t\tprintf(\"%d %d\\n\",x,p[x][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 100010;\n\nstruct Node {\n    ll d; int id;\n\n    Node() {}\n    Node(ll d, int x):d(d), id(x) {}\n\n    friend bool operator < (Node a, Node b) { return a.d < b.d; }\n}d[MAXN];\n\nint sz[MAXN];\nint u[MAXN];\nint v[MAXN];\n\nint main() {\n    int n = ri;\n    for(int i = 1; i <= n; i++) d[i] = Node(rl, i), sz[i] = 1;\n    sort(d + 1, d + 1 + n);\n    ll dis = 0, N = 0;\n    for(int i = n; i > 1; i--) {\n        ll D = d[i].d - n + (sz[i] << 1);\n        int p = lower_bound(d + 1, d + 1 + n, Node(D, 0)) - d;\n        if(d[p].d != D) return puts(\"-1\"), 0;\n        ++N;\n        u[N] = d[i].id;\n        v[N] = d[p].id;\n        sz[p] += sz[i];\n        dis += sz[i];\n    }\n    if(dis != d[1].d) puts(\"-1\");\n    else\n        for(int i = 1; i <= N; i++)\n            printf(\"%d %d\\n\", u[i], v[i]);\n    return 0;\n}\n//无脑 "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long int ll;\ntypedef long double doublel;\n#define f first\n#define s second\n \nconst int N = 1e6 + 100;\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e17;\t\n\nset<pair<ll, ll>> s;\nint par[N], cnt[N];\nll h[N];\nvector<pair<int, int>> ans;\nvector<int> adj[N];\n\n\nvoid dfs(int u)\n{\n\tfor(auto x : adj[u])\n\t{\n\t\th[x] = h[u] + 1;\n\t\tdfs(x);\n\t}\n}\n\n\n\nint main()\n{\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\t\n\t\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tll w;\n\t\tcin >> w;\n\t\ts.insert({-w, i});\n\t\tcnt[i] = 1;\n\t\tpar[i] = i; \n\t\t\n\t}\n\t\n\tbool fl = true;\n\t\n\twhile(s.size() != 1)\n\t{\n\t\tll w = -s.begin()->f;\n\t\tint x = s.begin()->s;\n\t\tll w2 = w-n+2*cnt[x];\n\t\ts.erase(s.begin());\n\n\n\t\t//cout << x+1 << ' '  << w << ' ' << w2 << ' ' << fl << endl; \n\n\n\t\tauto it = s.lower_bound({-w2, -1});\n\t\tif(it == s.end() || it->f != -w2)\n\t\t\tfl = false;\n\t\telse\n\t\t{\n\t\t\tint y = it->s;\n\t\t\tpar[x] = y;\n\t\t\tcnt[y] += cnt[x];\n\t\t}\t\t\n\t\t\n\t}\n\t\n\t\n\t\n\t\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(i == par[i])\n\t\t\tcontinue;\n\t\tans.push_back({min(i, par[i]), max(i, par[i])});\n\t\t\n\t\tadj[par[i]].push_back(i);\n\t\t\n\t}\n\t\n\t\n\tint r = s.begin()->s;\n\tdfs(r);\n\t\n\tll sum = 0;\n\tfor(int i = 0; i < n; i++)\n\t\tsum += h[i];\n\t\n\tif(sum != -s.begin()->f)\n\t{\n\t\tfl = false;\n\t}\n\t\t\n\t\n\n\n\n\tif(!fl)\n\t{\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tsort(ans.begin(), ans.end());\n\t\n\tfor(auto e : ans)\n\t\tcout << e.f + 1 << ' ' << e.s + 1<< endl; \n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n    return 0;\n}\n\n \n \t\n \t\n\n\n\n\n \n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<unsigned char, unsigned char> pcc;\ntypedef pair<double, double> pdd;\ntypedef vector<vector<ll>> matrix;\n\nll d[1000000];\nint parent[1000000];\nint treesz[1000000];\nll dp[1000000];\nvoid solve() {\n  int n;\n  cin >> n;\n  for(int i = 0; i < n; i++) cin >> d[i];\n  sort(d, d+n);\n  map<ll, int> from;\n  for(int i = 0; i < n; i++) from[d[i]] = i;\n  for(int i = 0; i < n; i++) treesz[i] = 1;\n  for(int i = n-1; i >= 1; i--) {\n    ll currDist = d[i];\n    ll want = currDist - n + 2 * treesz[i];\n    if(!from.count(want) || from[want] >= i) {\n      cout << \"-1\\n\";\n      return;\n    }\n    parent[i] = from[want];\n    treesz[parent[i]] += treesz[i];\n  }\n  for(int i = 1; i < n; i++) {\n    dp[i] = dp[parent[i]] + 1;\n  }\n  ll total = 0;\n  for(int i = 0; i < n; i++) {\n    total += dp[i];\n  }\n  if(total != d[0]) {\n    cout << \"-1\\n\";\n    return;\n  }\n  for(int i = 1; i < n; i++) {\n    cout << (parent[i]+1) << \" \" << (i+1) << \"\\n\";\n  }\n}\n\nvoid casesolve() {\n  int t;\n  cin >> t;\n  for(int i = 1; i <= t; i++) {\n    cout << \"Case #\" << i << \":\" << \"\\n\";\n    solve();\n  }\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL); cout.tie(NULL);\n  solve();\n  // casesolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define inf 0x3f3f3f3f\n#define mod 1000000007\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define vi vector <int>\n#define pii pair <int, int>\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i,n) for (int i = 0; i < (int) (n); ++ i)\n#define foreach(it,c) for (__typeof(c.begin()) it = c.begin(); it != c.end(); ++ it)\n\ninline int read() {\n\tint x = 0, f = 1, c = getchar();\n\tfor (;!isdigit(c);c = getchar()) if (c == '-') f ^= 1;\n\tfor (; isdigit(c);c = getchar()) x = x * 10 + c - '0';\n\treturn f ? x : -x;\n}\n\nint n;\nll d[100005];\nmap <ll, int> st;\nvector <pii> e;\nint siz[100005];\nvi g[100005];\n\nll dfs(int u, int p) {\n\tll dd = 0;\n\trep(i, g[u].size()) if (g[u][i] != p) dd += siz[g[u][i]] + dfs(g[u][i], u);\n\treturn dd;\n}\n\nint main() {\n\tn = read();\n\trep(i, n) scanf(\"%lld\", &d[i]);\n\trep(i, n) st[d[i]] = i;\n\tint rt = st.begin() -> second;\n\trep(i, n) siz[i] = 1;\n\twhile (!st.empty()) {\n\t\tint mx = st.rbegin() -> second;\n\t\tif (mx == rt) break;\n\t\tst.erase(d[mx]);\n\t\tint nxd = d[mx] - (n - 2 * siz[mx]);\n\t\tif (!st.count(nxd)) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[st[nxd]] += siz[mx];\n\t\te.pb(mp(mx, st[nxd]));\n\t\tg[mx].pb(st[nxd]); g[st[nxd]].pb(mx);\n\t}\n\tif (dfs(rt, -1) != d[rt]) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\trep(i, e.size()) if (e[i].first > e[i].second) swap(e[i].first, e[i].second);\n\tsort(e.begin(), e.end());\n\trep(i, e.size()) printf(\"%d %d\\n\", e[i].first + 1, e[i].second + 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &x) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (x = 0; c >= 33 && c <= 126; s[++x] = c, c = gc());\n\t\ts[x+1] = '\\0';\n\t}\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(string s) {\n\t\tint x = s.length();\n\t\twhile (t < x) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printc;\nusing io::prints;\n\n#define Fail print(-1), exit(0);\nconst int N = 1e5 + 7;\nint n, p[N], s[N], f[N];\nll d[N], ans;\nvi e[N];\nmap<ll, int> c;\n\nvoid dfs(int x, int o) {\n\tans += o;\n\tfor (int y : e[x]) dfs(y, o + 1);\n}\n\nint main() {\n\trd(n), rda(d, n);\n\tfor (int i = 1; i <= n; i++) p[i] = i;\n\tsort(p + 1, p + n + 1, [&](int i, int j) { return d[i] < d[j]; });\n\tfor (int i = 1; i <= n; i++) c[d[i]] = i, s[i] = 1;\n\tfor (int i = n; i > 1; i--) {\n\t\tint u = p[i], fa;\n\t\tc.erase(d[u]);\n\t\tif (!(fa = c[d[u]-n+2*s[u]])) Fail;\n\t\tf[u] = fa, e[fa].pb(u), s[fa] += s[u];\n\t}\n\tdfs(p[1], 0);\n\tif (ans != d[p[1]]) Fail;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (f[i]) print(i, f[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int maxn = 101010;\nstruct Node{\n    int num;\n    ll d;\n    bool operator < (const Node &tx) const {\n        return d < tx.d;\n    }\n}a[maxn];\nint n, flag;\nll siz[maxn];\n\nqueue<int> q[2];\nvector<pair<int, int> > ans;\n\nint main(){\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i ++){\n        scanf(\"%lld\", &a[i].d);\n        a[i].num = i;\n    }\n\n    sort(a+1, a+1+n);\n\n    q[a[1].d & 1].push(1);\n    siz[a[1].num] = n - 1;\n    int tem_flag = n & 1;\n    \n    for(int i = 2; i <= n; i ++){\n        if(q[1 & (a[i].d ^ tem_flag)].empty()){\n            flag = 1;\n        }\n        int tem_num = q[1 & (a[i].d ^ tem_flag)].front();\n\n        ll diff = a[i].d - a[tem_num].d;\n\n        if(diff > n)\n            flag = 1;\n\n        int diff_siz = (n - diff) / 2;\n        siz[a[i].num] = diff_siz - 1;\n        siz[a[tem_num].num] -= diff_siz;\n\n        if(diff_siz > 1)\n            q[a[i].d & 1].push(i);\n        ans.push_back(make_pair(a[i].num, a[tem_num].num));\n        if(siz[a[tem_num].num] <= 0) q[1 & (a[i].d ^ tem_flag)].pop();\n    }\n\n    for(int i = 1; i <= n; i ++){\n        if(siz[i] != 0){\n            flag = 1;\n        }\n    }\n    if(flag){\n        printf(\"-1\\n\");\n        return 0;\n    }\n\n    int siz = ans.size() - 1;\n    for(int i = 0; i <= siz; i ++)\n        printf(\"%d %d\\n\", ans[i].first, ans[i].second);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+3;\nint n,siz[N];\nbool b[N];\nstruct syzs{\n\tint val,num;\n} a[N];\nstruct ans{\n\tint e1,e2;\n\tbool operator <(const ans &emm) const{\n\t    if(emm.e1==e1) return e2>emm.e2;\n\t\treturn emm.e1<e1;\n\t}\n};\nbool cmp(syzs c,syzs b){\n\treturn c.val>b.val;\n}\nint find(int k){\n\tint chec=a[k].val+2*siz[k]-n;\n\tfor(int i=k+1;i<=n;i++){\n\t\tif(a[i].val==chec&&i!=k) return i;\n\t}\n\treturn -1;\n}\nint main(){\n\tpriority_queue <ans> q;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i].val);\n\t\ta[i].num=i;\n\t\tsiz[i]=1;\n\t}\n\tsort(a+1,a+n+1,cmp);\n\tb[1]=1;\n\tfor(int i=1;i<n;i++){\n\t\tint v=find(i);\n\t\tif(v==-1) puts(\"-1\"),exit(0);\n\t\tsiz[v]+=siz[i];\n\t\tq.push((ans) {min(a[v].num,a[i].num),max(a[v].num,a[i].num)});\n\t}\n\twhile(!q.empty()){\n\t\tint v1=q.top().e1,v2=q.top().e2;\n    \tq.pop();\n    \tprintf(\"%d %d\\n\",v1,v2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\nnamespace Base{\n\t# define mr make_pair\n\ttypedef long long ll;\n\ttypedef double db;\n\tconst int inf = 0x3f3f3f3f, INF = 0x7fffffff;\n\tconst ll  infll = 0x3f3f3f3f3f3f3f3fll, INFll = 0x7fffffffffffffffll;\n\ttemplate<typename T> void read(T &x){\n    \tx = 0; int fh = 1; double num = 1.0; char ch = getchar();\n\t\twhile (!isdigit(ch)){ if (ch == '-') fh = -1; ch = getchar(); }\n\t\twhile (isdigit(ch)){ x = x * 10 + ch - '0'; ch = getchar(); }\n\t    if (ch == '.'){\n\t    \tch = getchar();\n\t    \twhile (isdigit(ch)){num /= 10; x = x + num * (ch - '0'); ch = getchar();}\n\t\t}\n\t\tx = x * fh;\n\t}\n\ttemplate<typename T> void chmax(T &x, T y){x = x < y ? y : x;}\n\ttemplate<typename T> void chmin(T &x, T y){x = x > y ? y : x;}\n}\nusing namespace Base;\n\nconst int N = 100010;\nstruct Edge{\n\tint data, next;\n}e[N * 2];\nstruct Node{\n\tint id, num;\n}p[N];\nint n, size[N], eu[N], ev[N], head[N], place, cnt;\nll num[N], dis;\nvoid build(int u, int v){\n\te[++place].data = v; e[place].next = head[u]; head[u] = place;\n}\nvoid dfs(int x, int fa, int di){\n\tdis += di;\n\tfor (int ed = head[x]; ed != 0; ed = e[ed].next)\n\t\tif (e[ed].data != fa)\n\t\t\tdfs(e[ed].data, x, di + 1);\n}\nvoid error(){\n\tprintf(\"-1\\n\");\n\texit(0);\n}\nbool cmp(Node x, Node y){\n\treturn x.num < y.num;\n}\nint main(){\n\tread(n);\n\tfor (int i = 1; i <= n; i++){\n\t\tread(num[i]), size[i]++;\n\t\tp[i].num = num[i];\n\t\tp[i].id = i;\n\t}\n\tsort(num + 1, num + n + 1);\n\tsort(p + 1, p + n + 1, cmp);\n\tfor (int i = n; i >= 1; i--){\n\t\tint tmp = num[i] - (n - 2 * size[i]);\n\t\tif (tmp >= num[i]) continue;\n\t\tll id = lower_bound(num + 1, num + n + 1, tmp) - num;\n\t\tif (num[id] == tmp){\n\t\t\tbuild(id, i); build(i, id);\n\t\t\teu[++cnt] = id, ev[cnt] = i;\n\t\t\tsize[id] += size[i];\n\t\t}\n\t\telse error();\n\t}\n\tdfs(1, 0, 0);\n\tif (dis != num[1]) error();\n\tfor (int i = 1; i < n; i++)\n\t\tprintf(\"%d %d\\n\", p[eu[i]].id, p[ev[i]].id);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<unsigned char, unsigned char> pcc;\ntypedef pair<double, double> pdd;\ntypedef vector<vector<ll>> matrix;\n\npll d[1000000];\nint parent[1000000];\nint treesz[1000000];\nll dp[1000000];\nint n;\nint s;\n\nvector<int> edges[1000000];\nvoid check() {\n  memset(dp, 0, sizeof(dp));\n  queue<pii> q;\n  q.push({s, -1});\n  ll amt = 0;\n  while(!q.empty()) {\n    pii curr = q.front(); q.pop();\n    amt += dp[curr.first];\n    for(int out: edges[curr.first]) {\n      if(out == curr.second) continue;\n      dp[out] = dp[curr.first]+1;\n      q.push({out, curr.first});\n    }\n  }\n  if(amt != d[0].first) {\n    cout << \"-1\\n\";\n    exit(0);\n  }\n}\n\nvoid solve() {\n  cin >> n;\n  for(int i = 0; i < n; i++) {\n    cin >> d[i].first;\n    d[i].second = i;\n  }\n  sort(d, d+n);\n  map<ll, int> from;\n  for(int i = 0; i < n; i++) from[d[i].first] = i;\n  for(int i = 0; i < n; i++) treesz[i] = 1;\n  for(int qq = n-1; qq > 0; qq--) {\n    int realVertex = d[qq].second;\n    ll currDist = d[qq].first;\n    ll want = currDist - n + 2 * treesz[realVertex];\n    if(!from.count(want)) {\n      cout << \"-1\\n\";\n      return;\n    }\n    int fromInD = from[want];\n    int actualVertex = d[fromInD].second;\n    if(actualVertex == realVertex) {\n      cout << \"-1\\n\";\n      return;\n    }\n    parent[realVertex] = actualVertex;\n    edges[realVertex].push_back(actualVertex);\n    edges[actualVertex].push_back(realVertex);\n    treesz[actualVertex] += treesz[realVertex];\n    s = actualVertex;\n  }\n  check();\n  for(int i = 0; i < n; i++) {\n    for(int out: edges[i]) {\n      if(out > i) {\n        cout << (i+1) << \" \" << (out+1) << \"\\n\";\n      }\n    }\n  }\n}\n\nvoid casesolve() {\n  int t;\n  cin >> t;\n  for(int i = 1; i <= t; i++) {\n    cout << \"Case #\" << i << \":\" << \"\\n\";\n    solve();\n  }\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL); cout.tie(NULL);\n  solve();\n  // casesolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n\nvoid io(string s = \"\") {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    if (sz(s)) {\n    \tsetIn(s+\".in\");\n    \tsetOut(s+\".out\");\n    }\n}\n\nint n, num[MX], par[MX];\nll d[MX], ans;\nvi rpar[MX];\nmap<ll,int> m;\n\nvoid gen(int x, int d = 0) {\n    ans += d;\n    for (int i: rpar[x]) gen(i,d+1);\n}\n\nint main() {\n    io();\n    cin >> n;\n    \n    priority_queue<pl> q;\n    FOR(i,1,n+1) {\n        cin >> d[i];\n        num[i] = 1;\n        m[d[i]] = i;\n        q.push({d[i],i});\n    }\n    while (1) {\n        auto a = q.top(); q.pop();\n        par[a.s] = m[a.f-n+2*num[a.s]];\n        if (2*num[a.s] >= n) par[a.s] = 0;\n        if (par[a.s] == 0) {\n            if (sz(q) != 0) {\n                cout << -1;\n                exit(0);\n            } else {\n                gen(a.s);\n                if (d[a.s] != ans) {\n                    cout << -1;\n                    exit(0);\n                }\n                FOR(i,1,n+1) if (par[i]) cout << i << \" \" << par[i] << \"\\n\";\n                exit(0);\n            }\n        } else {\n            rpar[par[a.s]].pb(a.s);\n            num[par[a.s]] += num[a.s];\n        }\n    }\n}\n\n/* \n* (Actually read this pls)\n    * Rlly bad errors: int overflow, array bounds\n    * Less bad errors: special cases (n=1?), set tle\n    * Common sense: do smth instead of nothing\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#define Maxn 1000008 \nusing namespace std;\ntypedef long long ll;\n\nint n,cnt,tot,imp;\nint U[Maxn],V[Maxn];\nll d;\nbool vis[Maxn];\nint son[Maxn],head[Maxn];\nmap <ll,int> M;\n\nstruct node{\n\tint num;\n\tll val;\n}N[Maxn];\n\nstruct edge{\n\tint to,next;\n}E[Maxn];\n\nvoid adde(int u,int v)\n{\n\tE[tot].to = v;\n\tE[tot].next = head[u];\n\thead[u] = tot++;\n}\n\nvoid dfs(int u,int val)\n{\n\timp += val,vis[u] = 1;\n\tfor(int i = head[u];~i;i = E[i].next)\n\t{\n\t\tint v = E[i].to;\n\t\tif(vis[v]) continue;\n\t\tdfs(v,val+1);\n\t}\n}\n\nbool cmp(node a,node b){\treturn a.val > b.val;}\n\nint main()\n{\n\tmemset(vis,0,sizeof(vis));\n\tmemset(head,-1,sizeof(head));\n\tmemset(son,0,sizeof(son));\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\tscanf(\"%lld\",&d);\n\t\tM[d] = i;\n\t\tN[i].num = i,N[i].val = d;\n\t}\n\tsort(N+1,N+1+n,cmp);\n\tmap<ll,int>::iterator iter;;\n\tfor(int i = 1;i < n;i ++)\n\t{\n\t\tint u = N[i].num;\n\t\titer = M.find(N[i].val - n + 2 + (son[u] << 1));\n\t\tif(iter == M.end()) continue;\n\t\tint v = iter->second;\n\t\tson[v] += son[u]+1;\n\t\tadde(u,v);adde(v,u);\n\t\tU[cnt] = u,V[cnt++] = v;\n\t}\n\tdfs(N[n].num,0);\n\tif(N[n].val != imp){\tprintf(\"-1\\n\");return 0;}\n\tfor(int i = 0;i < cnt;i ++) printf(\"%d %d\\n\",U[i],V[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Maxn = 100005;\nint n, cnt, root, fa[Maxn], siz[Maxn], pos[Maxn], head[Maxn];\nlong long d[Maxn], dis[Maxn];\nmap <long long, int> Ma;\nstruct edg\n{\n\tint nxt, to;\n}edge[Maxn];\nvoid add(int x, int y)\n{\n\tedge[++cnt] = (edg){head[x], y};\n\thead[x] = cnt;\n}\nvoid dfs1(int u)\n{\n\tfor (int i = head[u]; i; i = edge[i].nxt)\n\t{\n\t\tint to = edge[i].to;\n\t\tdfs1(to), dis[u] += dis[to] + siz[to];\n\t}\n}\nvoid dfs2(int u)\n{\n\tfor (int i = head[u]; i; i = edge[i].nxt)\n\t{\n\t\tint to = edge[i].to;\n\t\tdis[to] = dis[u] + n - 2 * siz[to];\n\t\tdfs2(to);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\troot = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%lld\", &d[i]), pos[i] = i, Ma[d[i]] = i, siz[i] = 1;\n\tsort(pos + 1, pos + 1 + n, [](int x, int y){return d[x] < d[y];});\n\tfor (int i = n; i >= 1; i--)\n\t{\n\t\tMa[d[pos[i]]] = 0;\n\t\tfa[pos[i]] = Ma[d[pos[i]] - n + 2 * siz[pos[i]]];\n\t\tsiz[fa[pos[i]]] += siz[pos[i]];\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (!fa[i] && i != pos[1])\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tadd(fa[i], i);\n\t}\n\tdfs1(pos[1]);\n\tfor (int i = 2; i <= n; i++)\n\t\tdis[pos[i]] = 0;\n\tdfs2(pos[1]);\n\tfor (int i = 1; i <= n; i++)\n\t\tif (d[i] != dis[i])\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\tfor (int i = 2; i <= n; i++)\n\t\tprintf(\"%d %d\\n\", fa[pos[i]], pos[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\n \nstruct node{\n\tll w;\n\tint y;\n}a[100050];\n \nstruct node2{\n\tint t, nxt;\n}edge[200050];\n \nstruct node3{int fr, f;};\n \nint head[100050], cnt, n, siz[100050];\n \nvoid add(int u, int v){\n\tedge[++cnt] = (node2){v, head[u]};\n\thead[u] = cnt;\n}\n \nbool cmp(node a, node b){return a.w<b.w;}\n \nint find(int u){\n\tfor(int i = u-1; i >= 1; i--)\n\tif(a[i].w - a[u].w == 2*siz[a[u].y] - n) \n\treturn a[i].y;\n\treturn -1;\n}\n \nvoid print(int u, int fa){\n\tqueue<node3> q;\n\tq.push((node3){u, fa});\n\twhile(!q.empty()){\n\t\tu = q.front().fr;\n\t\tint ff = q.front().f;\n\t\tq.pop();\n\t\tfor(int i = head[u]; i; i = edge[i].nxt){\n\t\t\tint v = edge[i].t;\n\t\t\tprintf(\"%d %d\\n\", u, v);\n\t\t\tq.push((node3){v, u});\n\t\t}\n\t}\n}\n \nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &a[i].w);\n\t\ta[i].y = i;\n\t}\n\tsort(a+1, a+n+1, cmp);\n\tint rt = a[1].y;\n\tfor(int i = n; i >= 2; i--) {\n\t\tsiz[a[i].y]++;\n\t\tint p = find(i);\n\t\tif(p == -1){\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[p]+=siz[a[i].y];\n\t\tadd(p, a[i].y);\n\t}\n\tprint(rt, 0);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n\nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nint modpow(int a, long long n, int mod = MOD) { int ret = 1; do { if (n & 1) ret = 1LL * ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\n// counterclockwise from 12 o'clock direction\ntemplate<typename T> bool CompareBySlope(pair<T, T> a, pair<T, T> b) { if (a.first * b.first < 0) return a.first < b.first; if (a.first == 0) return a.second >= 0 || b.first > 0; if (b.first == 0) return b.second < 0 && a.first < 0; return a.second * b.first < a.first * b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\nvoid solve() {\n  int n; cin >> n;\n  vector<pair<ll, int>> g(n);\n  rep(i,n) {\n    cin >> g[i].first;\n    g[i].second = i;\n  }\n  sort(ALL(g));\n\n  vi cnt(n);\n  vector<pii> ans; ans.reserve(n-1);\n\n  rrep1(i,n) {\n    ll d; int idx;\n    tie(d, idx) = g[i];\n\n    ll nd = d - (n-2) + 2*cnt[idx];\n    auto itr = lower_bound(ALL(g), make_pair(nd, 0));\n\n    if (itr->first != nd || nd == d) {\n      cout << -1 << endl;\n      return;\n    }\n\n    int nidx = itr->second;\n    cnt[nidx] += cnt[idx] + 1;\n    ans.emplace_back(idx+1, nidx+1);\n  }\n\n  cout << ans << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(12);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<iomanip>\n#include<cstring>\n#include<algorithm>\n#include<ctime>\nusing namespace std;\ninline int read()\n{\n\tint kkk=0,x=1;\n\tchar c=getchar();\n\twhile((c<'0' || c>'9') && c!='-')\n\t\tc=getchar();\n\tif(c=='-')\n\t\tc=getchar(),x=-1;\n\twhile(c>='0' && c<='9')\n\t\tkkk=(kkk<<3)+(kkk<<1)+(c-'0'),c=getchar();\n\treturn kkk*x;\n}\nint n;\nstruct sb\n{\n\tint sum,id,size,fa;\n}a[100001];\ninline int cmp(sb x,sb y)\n{\n\treturn x.sum>y.sum;\n}\ninline int find(int V)\n{\n\tint l=1,r=n,bck=0;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)/2;\n\t\tif(a[mid].sum>=V)\n\t\t\tbck=mid,l=mid+1;\n\t\telse\n\t\t\tr=mid-1;\n\t}\n\treturn bck;\n}\nint main()\n{\n\tn=read();\n\tfor(register int i=1;i<=n;++i)\n\t{\n\t\ta[i].id=i;\n\t\ta[i].sum=read();\n\t\ta[i].size=1;\n\t}\n\tsort(a+1,a+n+1,cmp);\n\ta[0].sum=-1;\n\tfor(register int i=1;i<n;++i)\n\t{\n\t\tint sum=a[i].sum+a[i].size-(n-a[i].size);\n\t\tif(sum<n-1 || sum==a[i].sum)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint zone=find(sum);\n\t\tif(a[zone].sum!=sum)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\ta[zone].size+=a[i].size;\n\t\ta[i].fa=zone;\n\t}\n\tfor(register int i=1;i<n;++i)\n\t\tprintf(\"%d %d\\n\",a[i].id,a[a[i].fa].id);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate <class T>\ninline void read(T &res)\n{\n\tres = 0; bool bo = 0; char c;\n\twhile (((c = getchar()) < '0' || c > '9') && c != '-');\n\tif (c == '-') bo = 1; else res = c - 48;\n\twhile ((c = getchar()) >= '0' && c <= '9')\n\t\tres = (res << 3) + (res << 1) + (c - 48);\n\tif (bo) res = ~res + 1;\n}\n\ntypedef long long ll;\n\nconst int N = 1e5 + 5;\n\nint n, p[N], m, a[N], b[N], sze[N];\nll d[N];\nstd::map<ll, int> occ;\n\ninline bool comp(int a, int b) {return d[a] < d[b];}\n\nint main()\n{\n\tread(n);\n\tfor (int i = 1; i <= n; i++) read(d[i]), p[i] = i, sze[i] = 1;\n\tstd::sort(p + 1, p + n + 1, comp);\n\tfor (int i = 1; i <= n; i++) occ[d[i]] = i;\n\tfor (int i = n; i >= 2; i--)\n\t{\n\t\tint u = p[i]; occ[d[u]] = 0;\n\t\tint v = occ[d[u] - n + (sze[u] << 1)];\n\t\tif (!v) return puts(\"-1\"), 0;\n\t\ta[++m] = u; b[m] = v; sze[v] += sze[u];\n\t}\n\tfor (int i = 1; i <= m; i++) printf(\"%d %d\\n\", a[i], b[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_N 100000\nusing namespace std;\ntypedef long long lnt;\ntemplate <class T> inline void read(T &x) {\n\tx = 0; int c = getchar(), f = 1;\n\tfor (; !isdigit(c); c = getchar()) if (c == 45) f = -1;\n\tfor (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');\n}\nint n, sz[MAX_N+5]; lnt s[MAX_N+5], tot;\nmap <lnt, int> id; vector <int> G[MAX_N+5];\nvoid DFS(int u, int d) {tot += d; for (int v : G[u]) DFS(v, d+1);}\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n; i++)\n\t\tread(s[i]), id[s[i]] = i, sz[i] = 1;\n\tsort(s+1, s+n+1, greater<lnt>());\n\tfor (int i = 1; i < n; i++) {\n\t\tint u = id[s[i]];\n\t\tlnt sf = s[i]-n+2*sz[u];\n\t\tif (sf >= s[i] || !id.count(sf))\n\t\t\treturn puts(\"-1\"), 0;\n\t\tint f = id[sf];\n\t\tsz[f] += sz[u];\n\t\tG[f].push_back(u);\n\t}\n\tDFS(id[s[n]], 0);\n\tif (tot != s[n])\n\t\treturn puts(\"-1\"), 0;\n\tfor (int u = 1; u <= n; u++)\n\t\tfor (int v : G[u]) printf(\"%d %d\\n\", u, v);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> bool chmin(T& a,const T& b) {\n  if(a>b) {\n    a=b;\n    return true;\n  }\n  return false;\n}\ntemplate<class T> bool chmax(T& a,const T& b) {\n  if(a<b){\n    a=b;\n    return true;\n  }\n  return false;\n}\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\n//const int INF=5e8;\n\nint n;\nlint ar[100005];\nvoid ng(){\n  puts(\"-1\");\n  exit(0);\n}\nvector<int> g[100005];\nlint rec(int v,int p,int d=0){\n  lint res=d;\n  for(auto to:g[v]) if(to!=p){\n    res+=rec(to,v,d+1);\n  }\n  return res;\n}\nint main(){\n  cin>>n;\n  set<pair<lint,pi> > S;\n  REP(i,n){\n    scanf(\"%lld\\n\",&ar[i]);\n    S.insert({ar[i],{i,1}});\n  }\n  vector<pi> es;\n  while(S.size()>1){\n    pair<lint,pi> tmp=*(--S.end());\n    S.erase(--S.end());\n    int v=tmp.sc.fr,wei=tmp.sc.sc;\n    lint co=tmp.fr;\n    if(wei*2>=n) ng();\n\n    lint want=co-(n-2*wei);\n    auto it=S.lower_bound(mp(want,mp(0,0)));\n    if(it!=S.end() && it->fr==want){\n      int v2=it->sc.fr,wei2=it->sc.sc;\n      S.erase(it);\n      es.pb({v,v2});\n      S.insert({want,{v2,wei+wei2}});\n    }else{\n      ng();\n    }\n  }\n  for(auto e:es) g[e.fr].pb(e.sc),g[e.sc].pb(e.fr);\n\n  if(rec(0,-1)!=ar[0]) ng();\n  for(auto e:es) printf(\"%d %d\\n\",e.fr+1,e.sc+1);\n\n\n\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=100005;\nint n;\nint par[maxn],sz[maxn],ord[maxn];\nll d[maxn];\nmap<ll,int>rev;\nbool cmp(int a,int b){\n\treturn d[a]<d[b];\n} \n\nint main(){\n\tscanf(\"%d\",&n);\n\tREP(i,n){\n\t\tscanf(\"%lld\",&d[i]);\n\t\tord[i]=i;\n\t\trev[d[i]]=i;\n\t}\n\tsort(ord+1,ord+1+n,cmp);\n\tfor(int i=n;i>1;i--){\n\t\tint x=ord[i];\n\t\tif(sz[x]+1>n||!rev.count(2*(sz[x]+1)+d[x]-n)){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint y=rev[2*(sz[x]+1)+d[x]-n];\n\t\tpar[x]=y;\n\t\tsz[y]+=sz[x]+1;\n\t}\n\tREP(i,n)if(!par[i]){\n\t\tif(sz[i]+1!=n){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tREP(i,n)if(par[i])printf(\"%d %d\\n\",par[i],i);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "//Zory-2018\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n#include<set>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<bitset>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nnamespace mine\n{\n\ttypedef long long ll;\n\tconst int INF=0x3f3f3f3f;\n\n\tconst int MAX_N=110000;\n\tstruct Nod\n\t{\n\t\tll d;int p,siz;\n\t\tfriend bool operator < (Nod a,Nod b) {return a.d<b.d;}\n\t}p[MAX_N];\n\n\t#define PR pair<int,int>\n\tvector<PR> ans;\n\tvoid main()\n\t{\n\t\tint n;scanf(\"%d\",&n);\n\t\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&p[i].d),p[i].p=i,p[i].siz=1;\n\t\tsort(p+1,p+n+1);\n\n\t\tfor(int i=n;i>=2;i--)\n\t\t{\n\t\t\tll want=p[i].d-n+2*p[i].siz;\n\t\t\tint fa=lower_bound(p+1,p+n+1,(Nod){want,0,0})-p;\n\t\t\t//printf(\"i=%d p[i].siz=%d want=%lld fa=%d p[fa].d=%lld\\n\",p[i].p,p[i].siz,want,p[fa].p,p[fa].d);\n\t\t\tif(p[fa].d!=want or fa==i) {puts(\"-1\");return;}\n\t\t\tans.push_back( make_pair(p[i].p,p[fa].p) );p[fa].siz+=p[i].siz;\n\t\t}\n\n\t\tfor(int i=0;i<(int)ans.size();i++) printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\t}\n}\nint main()\n{\n\tmine::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Stop { cout << \"-1\\n\"; return 0; }\n\nusing namespace std;\n\ntypedef long long ll;\nconst int Nmax = 1e5 + 5;\n\nmap<ll, int> mp;\nvector<int> v[Nmax];\nll d[Nmax], Sum;\nint t[Nmax], w[Nmax], level[Nmax];\nint n, i, node, dad, root;\n\nvoid dfs(int node)\n{\n    for(auto it : v[node])\n    {\n        level[it] = level[node] + 1;\n        dfs(it);\n        w[node] += w[it];\n    }\n    Sum += level[node];\n}\n\nbool verif()\n{\n    int i;\n    for(i=1; i<=n; ++i)\n    {\n        w[i] = 1;\n        v[t[i]].push_back(i);\n    }\n\n    dfs(root);\n\n    if(Sum != d[root]) return 0;\n\n    for(i=1; i<=n; ++i)\n        if(i != root)\n            if(d[i] != d[t[i]] + n - 2 * w[i]) return 0;\n    return 1;\n}\n\nint main()\n{\n ///   freopen(\"input\", \"r\", stdin);\n    cin.sync_with_stdio(false);\n\n    cin >> n;\n    for(i=1; i<=n; ++i) cin >> d[i], mp[d[i]] = i, w[i] = 1;\n\n    root = mp.begin() -> second;\n\n    for(auto it = mp.rbegin(); it != mp.rend(); ++it)\n    {\n        node = it->second;\n        dad = mp[ d[node] - n + 2 * w[node] ];\n\n        if(node == root) dad = 0;\n            else if(!dad) Stop;\n        if(dad == node) Stop;\n\n        t[node] = dad;\n        w[dad] += w[node];\n    }\n\n    if(!verif()) Stop;\n\n    for(i=1; i<=n; ++i)\n        if(t[i]) cout << t[i] << ' ' << i << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <iterator>\n#include <list>\n#include <stack>\n#include <map>\n#include <set>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <limits>\n#include <iomanip>\n#include <time.h>\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\nusing namespace std;\n \n#define ull unsigned long long\n#define ll long long\n#define mod 1000000007\n#define fi first\n#define se second\n#define pb push_back\n#define mkp make_pair\n#define PI acos(-1.0)\nconst int N=1e5 + 5;\nconst int M=1e5 + 5;\n \nll d[N],sub[N];\nvector <int> g[N]; \nvector < pair < ll , int > > v;\nbool vis[N];\nll ans[N],bar[N];\nint n;\n\nvoid dfs(int s)\n{\n    vis[s]=true;\n    for(int i=0;i<g[s].size();i++){\n        int x = g[s][i];\n        if(!vis[x]){\n            dfs(x);\n        bar[s]+=bar[x]+sub[x];\n        }\n    }\n}\n\nvoid dfs1(int s)\n{\n    vis[s]=true;\n    for(int i=0;i<g[s].size();i++){\n        int x = g[s][i];\n        if(!vis[x]){\n            ll ff = ans[s];\n            ff -= bar[x]+sub[x];\n            ff += n-sub[x]+bar[x];\n            ans[x]=ff;\n            dfs1(x);\n        }\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    int i;\n    map <ll,int> mp;\n    cin>>n;\n    for(i=1;i<=n;i++){\n        cin>>d[i];\n        mp[d[i]]=i;\n        v.pb(mkp(d[i],i));\n    }\n    sort(v.begin(),v.end());\n    reverse(v.begin(),v.end());\n    for(i=1;i<=n;i++){\n        sub[i]=1;\n    }\n\n    for(i=0;i<n-1;i++){\n        int x = v[i].se;\n        ll foo = d[x]-((ll)n - 2*sub[x]);\n        int y = mp[foo];\n\n        if(y==0){\n        //    cout << i << endl;\n            cout << -1 << endl;\n            return 0;\n        }\n        sub[y]+=sub[x];\n\n        g[y].pb(x);\n        g[x].pb(y);\n    }\n    int yy = v[n-1].se;\n    for(i=1;i<=n;i++){\n        vis[i]=false;\n    }\n    for(i=1;i<=n;i++){\n        bar[i]=0;\n    }\n    dfs(yy);\n    for(i=1;i<=n;i++){\n        vis[i]=false;\n    }\n    ans[yy]=bar[yy];\n    dfs1(yy);\n    //cout << ans[1]<<endl;\n    for(i=1;i<=n;i++){\n        if(ans[i]!=d[i]){\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n    for(i=1;i<=n;i++){\n        for(int j=0;j<g[i].size();j++){\n            int x = g[i][j];\n            if(x>i) cout << i << \" \" << x << endl;\n        }\n    }\n\n\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define reg register\n#define maxn 200001\ninline int  read() {\n    reg int s = 0, t = 0; reg char ch = getchar();\n    while(ch > '9' || ch < '0') t |= ch == '-', ch = getchar();\n    while(ch >= '0' && ch <= '9') s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();\n    return t ? -s : s;\n}\nusing namespace std;\nmap<int, int> mp;\nint D[maxn],a[maxn], b[maxn], cnt, n, sum[maxn];\nsigned main()\n{\n\tn = read();\n\tfor(int i = 1; i <= n; i++) D[i] = read(), mp[D[i]] = i;\n\tsort(D + 1, D + n + 1);\n\tfor(int i = n; i > 1; i--){\n\t\tsum[mp[D[i]]]++;\n\t\tint x = D[i] - abs(n - sum[mp[D[i]]] * 2);\n\t\tif(!mp[x] || x == D[i]) {printf(\"-1\\n\"); return 0;}\n\t\ta[++cnt] = mp[D[i]], b[cnt] = mp[x]; sum[mp[x]] += sum[mp[D[i]]];\n\t}\n\tfor(int i = 1; i < n; i++)\n\tprintf(\"%lld %lld\\n\", a[i], b[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdint>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX = 100000;\n\ntypedef struct node {\n\tint id;\n\tint64_t num;\n\tint edge;\n\tint height;\n\tbool operator<(const node& r) const {\n\t\treturn num < r.num;\n\t}\n} Node;\n\nint main() {\n\tint N;\n\tstatic Node node[MAX];\n\tcin >> N;\n\tfor (int i = 0;i < N;++ i) {\n\t\tcin >> node[i].num;\n\t\tnode[i].id = i + 1;\n\t\tnode[i].height = 1;\n\t}\n\tsort(node, node + N);\n\t\n\tint64_t sum = 0; // 1からの距離\n\tfor (int i = N - 1;i > 0;-- i) { // 大きい数字から確定させる\n\t\tint min = 0, max = i - 1;\n\t\tint64_t check = node[i].num - N + (node[i].height << 1);\n\t\tfor (int mid = i >> 1;max - min > 1;mid = min + (max - min >> 1)) {\n\t\t\tif (node[mid].num > check) max = mid;\n\t\t\telse min = mid;\n\t\t}\n\t\tif (node[min].num != check) { // 繋げる辺が存在しなかった\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\tnode[i].edge = min;\n\t\tnode[min].height += node[i].height;\n\t\tsum += node[i].height;\n\t}\n\t\n\tif (sum != node[0].num) {\n\t\tcout << -1;\n\t\treturn 0;\n\t}\n\tfor (int i = N - 1;i > 0;-- i) {\n\t\tcout << node[i].id << \" \" << node[node[i].edge].id << endl;\n\t}\n\treturn 0;\n}\n/*\n31536000のコメント解説欄\nここテンプレで用意してるから、A問題とかだとこの先空欄の危険あり\nまた、コンテスト後に https://31536000.hatenablog.com/ で解説していると思うので、良かったら読んでねー\n\n解説AC\n数字の大きい方の頂点から確定させることを考える\nこの時、この頂点から繋ぐ辺は、自分の数-N+(現時点の自分の属する木の高さ*2)となることが数学的に証明できる(解説放送参照)\nということは二分探索していけばO(NlogN)で判定と構築ができるわけだ\n最後に本当に正しいか確認だけして、問題ないなら構築完了\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <map>\nusing namespace std;\ntypedef long long LL;\nconst int N=100000+10;\nint n,sz[N]; \npair<int,LL> d[N];\nvector<int> g[N];\nbool cmp(pair<int,LL> p1,pair<int,LL> p2){\n    return p1.second>p2.second;\n}\nmap<LL,int> mp;\nvector< pair<int,int> > res;\nvoid prt(int u,int p){\n    for(auto v:g[u]){\n        if(v==p)continue;\n        res.push_back(make_pair(u,v));\n        prt(v,u);\n    }\n}\nint main() {\n    scanf(\"%d\",&n); \n    for(int i=1;i<=n;i++){\n        d[i].first=i; \n        scanf(\"%lld\",&d[i].second);\n        mp[d[i].second]=i;\n        sz[i]=1;\n    }\n    sort(d+1,d+1+n,cmp);\n    for(int i=1;i<n;i++){\n        LL tmp=d[i].second;\n        LL nex=tmp-(n-2*sz[d[i].first]);\n        if(mp[nex]==0||nex>=tmp)return !printf(\"-1\\n\");\n        int u=mp[nex];\n        int v=d[i].first;\n        g[u].push_back(v); g[v].push_back(u);\n        sz[u]+=sz[v];\n    }\n    prt(1,1);\n    if(res.size()==n-1){\n        for(auto p: res) printf(\"%d %d\\n\", p.first, p.second);\n    } else {\n        printf(\"-1\\n\");\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#include<map>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n\nusing namespace std;\ntypedef long long LL;\nconst int N=100005;\nint n,p[N],siz[N],fa[N];\nLL d[N];\nmap <LL,int> s;\n\nbool cmp(int x,int y)\n{\n\treturn d[x]>d[y];\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\trep(i,1,n) scanf(\"%lld\",&d[i]),p[i]=i,s[d[i]]=i;\n\tsort(p+1,p+1+n,cmp);\n\trep(i,1,n-1)\n\t{\n\t\t++siz[p[i]];\n\t\tLL D=d[p[i]]-n+2*siz[p[i]];\n\t\tif(D>=d[p[i]] || !s.count(D)) {puts(\"-1\"); return 0;}\n\t\tfa[p[i]]=s[D],siz[s[D]]+=siz[p[i]];\n\t}\n\tif(siz[p[n]]!=n-1) puts(\"-1\");\n\telse rep(i,1,n-1) printf(\"%d %d\\n\",p[i],fa[p[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing vi = vector<ll>;\nconst int maxn = 1<<19, mod = 1e9 + 7;\nint n;\nvi g[maxn];\nll t = 0;\nvoid dfs(int v, int p = -1, int h = 0) {\n\tt += h;\n\tfor(auto &i : g[v]) if(i != p) dfs(i, v, h + 1);\n}\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tvi a(n), sz(n+1, 1);\n\tmap<ll, int> id;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\tid[a[i]] = i+1;\n\t}\n\tsort(rall(a));\n\tvector<pair<int, int>> edges;\n\tfor(auto x : a) {\n\t\tint i = id[x];\n\t\tif(sz[i] == n) continue;\n\t\tll nd = x + 2*sz[i] - n;\n\t\tif(nd < x && id.count(nd)) {\n\t\t\tedges.pb({i, id[nd]});\n\t\t\tsz[id[nd]] += sz[i];\n\t\t}\n\t}\n\tfor(auto i : edges) {\n\t\tint x = i.first, y = i.second;\n\t\tg[x].pb(y);\n\t\tg[y].pb(x);\n\t}\n\tdfs(id[a.back()]);\n\tif(edges.size() != n-1 || t != a.back()) return cout << -1, 0;\n\tfor(auto i : edges) cout << i.first << \" \" << i.second << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n#include <numeric>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tmap<long long int, int> d_map;\n\tfor(int i = 0; i < n; i++){\n\t\tlong long int tmp;\n\t\tcin >> tmp;\n\t\td_map.insert(make_pair(tmp, i));\n\t}\n\tvector<long long int> s(n, 1);\n\tvector<long long int> dps(n, 0);\n\tset<pair<int, int> > ans;\n\tfor(auto i = d_map.rbegin(); i != d_map.rend(); i++){\n\t\tint now = i->second;\n\t\tlong long int nowd = i->first;\n\t\tlong long int nextd = nowd + 2 * s[now] - n;\n\t\tif(nextd >= nowd || d_map.find(nextd) == d_map.end()) continue;\n\t\tint next = d_map[nextd];\n\t\ts[next] += s[now];\n\t\tdps[next] += s[now] + dps[now];\n\t\tans.insert(make_pair(min(now, next), max(now, next)));\n\t}\n\tif(ans.size() != n - 1 || dps[(*d_map.begin()).second] != (*d_map.begin()).first){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tfor(auto i = ans.begin(); i != ans.end(); i++){\n\t\tcout << i->first + 1 << \" \" << i->second + 1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n\n//#pragma GCC optimize (\"O3\")\n//#pragma GCC target (\"sse4\")\n\nusing namespace std;\ntemplate<class T, class T2> inline int chkmax(T &x, const T2 &y) { return x < y ? x = y, 1 : 0; }\ntemplate<class T, class T2> inline int chkmin(T &x, const T2 &y) { return x > y ? x = y, 1 : 0; }\nconst int MAXN = (1 << 20);\n\nint n;\nmap<int64_t, int> id;\nint64_t d[MAXN];\n\nvoid read()\n{\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tcin >> d[i];\n\t\tid[d[i]] = i;\n\t}\n}\n\nvector<pair<int, int> > ans;\nvector<int> adj[MAXN];\nint tr_sz[MAXN];\n\nint64_t solve(int u)\n{\n\tint64_t ret = tr_sz[u] - 1;\n\tfor(auto i: adj[u])\n\t\tret += solve(i);\n\treturn ret;\n}\n\nvoid solve()\n{\n\tfor(int i = 1; i <= n; i++) tr_sz[i] = 1;\n\n\twhile(id.size() > 1)\n\t{\n\t\tauto it = id.rbegin();\n\t\tint i = it->second;\n\n\t\tint64_t d_par = d[i] - n + 2 * tr_sz[i];\n\n\t\tif(!id.count(d_par) || d_par == d[i])\n\t\t{\n\t\t\tcout << -1 << endl;\n\t\t\treturn;\n\t\t}\n\n\t\tint par = id[d_par];\n\n\t\tans.push_back({par, i});\n\t\tadj[par].push_back(i);\n\n\t\ttr_sz[par] += tr_sz[i];\n\t\tid.erase(--id.end());\n\t}\n\n\tint root = id.begin()->second;\n\tif(solve(root) != d[root])\n\t{\n\t\tcout << -1 << endl;\n\t\treturn;\n\t}\n\n\tfor(auto it: ans) cout << it.first << \" \" << it.second << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+5;\nint n,f[N],si[N];\nstruct node\n{\n    ll x;\n    int id;\n    bool operator<(const node&o)const\n    {\n        return x<o.x;\n    }\n}a[N];\nunordered_map<ll,int>mp;\nvector<pair<int,int> >v;\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%lld\",&a[i].x),a[i].id=i;\n    sort(a+1,a+1+n);\n    for(int i=1;i<=n;i++) si[i]=1,f[i]=a[i].id,mp[a[i].x]=i;\n    for(int i=n;i>1;i--)\n    {\n        ll t=a[i].x+si[i]-(n-si[i]);\n        assert(si[i]<n-si[i]);\n        if(mp[t]&&mp[t]!=i) v.push_back({i,mp[t]}),si[mp[t]]+=si[i];\n    }\n    if(si[1]!=n) {printf(\"-1\\n\");return 0;}\n    else for(int i=0;i<v.size();i++)\n        printf(\"%d %d\\n\",f[v[i].first],f[v[i].second]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing vi = vector<ll>;\nconst int maxn = 1<<19, mod = 1e9 + 7;\nint n;\nvi g[maxn];\nint vis[maxn], cnt = 0;\nvoid dfs(int v, int p = -1) {\n\tvis[v] = 1;\n\tcnt++;\n\tfor(auto &i : g[v]) if(!vis[i]) dfs(i, v);\n}\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tvi a(n), sz(n+1, 1);\n\tmap<ll, int> id;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\tid[a[i]] = i+1;\n\t}\n\tsort(rall(a));\n\tvector<pair<int, int>> edges;\n\tfor(auto x : a) {\n\t\tint i = id[x];\n\t\tif(sz[i] == n) continue;\n\t\tll nd = x + 2*sz[i] - n;\n\t\tif(nd < x && id.count(nd)) {\n\t\t\tedges.pb({i, id[nd]});\n\t\t\tsz[id[nd]] += sz[i];\n\t\t}\n\t}\n\tfor(auto i : edges) {\n\t\tint x = i.first, y = i.second;\n\t\tg[x].pb(y);\n\t\tg[y].pb(x);\n\t}\n\tdfs(1);\n\tif(edges.size() != n-1 || cnt != n) return cout << -1, 0;\n\tfor(auto i : edges) cout << i.first << \" \" << i.second << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n \nint n,nn;\nstruct node{int p,f,s;long long d;};\nnode a[100010];\n \nvoid qsort(int l,int r)\n{\n\tint i,j;\n\tnode m,t;\n\ti=l;j=r;\n\tm=a[(l+r)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (a[i].d>m.d) i++;\n\t\twhile (a[j].d<m.d) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tt=a[i];a[i]=a[j];a[j]=t;\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort(l,j);\n\tif (i<r) qsort(i,r);\n}\n\nint find(long long x)\n{\n\tint l=1,r=n;\n\tint m=(l+r)/2;\n\twhile (l<=r)\n\t{\n\t\tif (a[m].d==x) return m;\n\t\tif (a[m].d>x) l=m+1;\n\t\telse r=m-1;\n\t\tm=(l+r)/2;\n\t}\n\treturn -1;\n}\n \nint main()\n{\n\tscanf(\"%d\",&n);\n\tnn=n-2;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&a[i].d);\n\t\ta[i].p=i;\n\t\ta[i].f=-1;\n\t\ta[i].s=1;\n\t}\n\tqsort(1,n);\n\tbool ok=true;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tlong long fd=a[i].d-(n-a[i].s*2);\n\t\tint fn;\n\t\tfn=find(fd);\n\t\tif (fn==-1) {ok=false;break;}\n\t\ta[i].f=a[fn].p;\n\t\ta[fn].s+=a[i].s;\n\t}\n\tif (ok)\n\t{\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tif (a[i].f!=-1) printf(\"%d %d\\n\",a[i].f,a[i].p);\n\t\t}\n\t}\n\telse printf(\"-1\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=100005;\nint n;\nint par[maxn],sz[maxn],ord[maxn],dep[maxn];\nll d[maxn];\nmap<ll,int>rev;\nbool cmp(int a,int b){\n\treturn d[a]<d[b];\n} \n\nint main(){\n\tscanf(\"%d\",&n);\n\tREP(i,n){\n\t\tscanf(\"%lld\",&d[i]);\n\t\tord[i]=i;\n\t\trev[d[i]]=i;\n\t}\n\tsort(ord+1,ord+1+n,cmp);\n\tfor(int i=n;i>1;i--){\n\t\tint x=ord[i];\n\t\tif(sz[x]+1>=n||!rev.count(2*(sz[x]+1)+d[x]-n)){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint y=rev[2*(sz[x]+1)+d[x]-n];\n\t\tpar[x]=y;\n\t\tsz[y]+=sz[x]+1;\n\t}\n\tif(sz[ord[1]]+1!=n){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tdep[ord[1]]=0;\n\tfor(int i=2;i<=n;i++)dep[ord[i]]=dep[par[ord[i]]]+1;\n\tll tot=0;\n\tREP(i,n)tot+=dep[i];\n\tif(tot!=d[ord[1]]){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tREP(i,n)if(par[i])printf(\"%d %d\\n\",par[i],i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nint n,p[101000],s[101000],vis[101000];\nll a[101000];\nvector<pair<int,int> > ans;\nmap<ll,int> mp;\nint main(){\n\tread(n);\n\tfor(int i=1;i<=n;i++){\n\t\tread(a[i]);mp[a[i]]=i;\n\t\tp[i]=i;s[i]=1;\n\t}\n\tsort(p+1,p+n+1,[&](int x,int y){\n\t\treturn a[x]>a[y];\n\t});\n\tll res=0;\n\tfor(int i=1;i<n;i++){\n\t\tint x=p[i];\n\t\tmp.erase(a[x]);\n\t\tll pos=a[x]+s[x]-(n-s[x]);\n\t\tif(!mp.count(pos)){puts(\"-1\");return 0;}\n\t\tans.emplace_back(x,mp[pos]);\n\t\ts[mp[pos]]+=s[x];res+=s[x];\n\t}\n\tif(a[p[n]]!=res){puts(\"-1\");return 0;}\n\tfor(auto pr:ans){\n\t\tcout<<pr.first<<' '<<pr.second<<'\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,n) for (int i=1;i<=n;i++)\n#define REP(i,a,b) for (int i=a;i<=b;i++)\n \n#define pb push_back\n#define fi first\n#define se second\n#define pi pair<int,int>\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n \ntypedef long long ll;\n\nconst int inf=0x3f3f3f3f;\nconst ll linf=1e18;\nconst int N=200000+10;\nconst double eps=1e-5;\nconst int mo=1e9+7;\n\nint n;\nvector<int> v[N];\nint fa[N];\nint sz[N];\nstruct node {\n\tint id,v;\n} a[N];\nbool used[N];\nbool cmp(node x,node y) {\n\treturn x.v<y.v;\n}\nint F(int x) {\n\treturn (fa[x]==x)?x:(fa[x]=F(fa[x]));\n}\nint find(int x) {\n\tint l=1,r=n;\n\tint mid;\n\twhile (l<=r) {\n\t\tmid=(l+r)>>1;\n\t\tif (a[mid].v<x) {\n\t\t\tl=mid+1;\n\t\t} else if (a[mid].v>x) {\n\t\t\tr=mid-1;\n\t\t} else return a[mid].id;\n\t}\n\treturn 0;\n}\nint main() {\n \n    std::ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tint x,y;\n\tFOR(i,n) {\n\t\tscanf(\"%d\",&a[i].v);\n\t\ta[i].id=i;\n\t}\n\tsort(a+1,a+1+n,cmp);\n\tFOR(i,n) sz[i]=1,fa[i]=i;\n\tint t;\n\tfor (int i=n;i>=2;i--) {\n\t\tx=a[i].id;\n\t\tt=a[i].v-n+2*sz[x];\n\t\t//cout<<x<<\" \"<<t<<endl;\n\t\ty=find(t);\n\t\tif (F(x)==F(y)||used[y]||y==0) {\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tv[x].pb(y);\n\t\tv[y].pb(x);\n\t\tsz[y]+=sz[x];\n\t\tfa[F(x)]=F(y);\n\t\tused[x]=1;\n\t\t// used[x]=1表示x的所有儿子都已经找到了，之后如果还有点想插入x当儿子就是无解的 \n\t}\n\tFOR(i,n) {\n\t\tfor (int j=0;j<(int)v[i].size();j++) {\n\t\t\ty=v[i][j];\n\t\t\tif (i<y) {\n\t\t\t\tprintf(\"%d %d\\n\",i,y);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 5;\nint n;\nlong long d[N];\npriority_queue <pair <long long, int> > pq;\nint siz[N];\nint fa[N];\nmap <long long, set <int> > mp;\nvector <int> g[N];\n\n#define NO() return puts(\"-1\"), 0\n\nint dfs(int u) {\n\tint ans = 1;\n\tfor (int i = 0; i < g[u].size(); ++ i)\n\t\tans += dfs(g[u][i]);\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++ i)\n\t\tscanf(\"%lld\", &d[i]), mp[d[i]].insert(i),\n\t\tsiz[i] = 1, pq.push(make_pair(d[i], i));\n\tint rt;\n\twhile (!pq.empty()) {\n\t\tint u = pq.top().second;\n\t\tpq.pop(); mp[d[u]].erase(u);\n\t\tif (!pq.empty()) {\n\t\t\tlong long fa_d = (d[u] - (n - 2 * siz[u]));\n//\t\t\tprintf(\"%d %lld %lld\\n\", u + 1, d[u], fa_d);\n\t\t\tif (!mp[fa_d].size()) NO();\n\t\t\tint v = *mp[fa_d].begin();\n\t\t\tfa[u] = v;\n\t\t\tg[v].push_back(u);\n\t\t\tsiz[v] += siz[u];\n\t\t} else fa[u] = -1, rt = u;\n\t}\n\tif (dfs(rt) != n) NO();\n\tfor (int i = 0; i < n; ++ i)\n\t\tif (~fa[i]) printf(\"%d %d\\n\", fa[i] + 1, i + 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxN = 1e5 + 10;\nlong long d[maxN];\nint n;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i) cin >> d[i];\n\tmultiset<pair<long long, int>> points;\n\tfor (int i = 1; i <= n; ++i) points.insert({d[i], i});\t\n\tbool fun = 1;\n\tauto root = points.begin();\n\tpoints.erase(points.begin());\n\tvector<pair<int, int>> edges;\n\tlong long d_root = 0;\n\twhile (not points.empty()) {\n\t\tauto q = points.begin();\n\t\tpoints.erase(q);\n\t\tfun &= (root->first - q->first + n) % 2 == 0;\n\t\tlong long sz = (root->first - q->first + n) / 2; \n\t\tfun &= sz < n;\n\t\tif (not fun) break;\n\t\td_root += sz *1ll* (sz + 1) / 2;\n\t\tedges.push_back({root->second, q->second});\n\t\tlong long temp_d = q->first;\n\t\tint last = q->second;\n\t\tfor (int i = sz-1; i >= 1; --i) {\n\t\t\tlong long cur_d = temp_d + n - 2 * i;\n\t\t\tauto u = points.lower_bound({cur_d, -1});\n\t\t\tfun &= u != points.end();\n\t\t\tif (not fun) break;\n\t\t\tpoints.erase(u);\n\t\t\tfun &= cur_d == u->first;\n\t\t\tif (not fun) break;\t\n\t\t\tedges.push_back({last, u->second});\n\t\t\ttemp_d = cur_d;\n\t\t\tlast = u->second;\n\t\t}\n\t\tif (not fun) break;\n\t}\n\tfun &= d[root->second] == d_root;\n\tif (fun) {\n\t\tfor (auto e : edges) {\n\t\t\tcout << e.first << \" \" << e.second << endl;\n\t\t}\n\t} else puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 100020\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define inf 0x3f3f3f3f\ntypedef long long ll;\ntypedef pair<int,int> pr;\n\nstruct node2{\n\tll d; int id;\n\tbool operator < (node2 a)const{\n\t\treturn d < a.d;\n\t}\n}dt[maxn];\nll d[maxn],f[maxn];\nstruct node{\n\tint next,to;\n}e[maxn * 2];\nint head[maxn],cnt;\nint n,fa[maxn],sz[maxn],dth[maxn];\n\ninline void adde(int x,int y){\n\te[++cnt].to = y;\n\te[cnt].next = head[x];\n\thead[x] = cnt;\n}\t\nvoid dfs(int x){\n\tfore(i,x){\n\t\tdth[e[i].to] = dth[x] + 1;\n\t\tdfs(e[i].to);\n\t}\n}\nbool check(){\n\tdfs(1);\n\trep(i,1,n) f[1] += dth[i];\n\tif ( f[1] != d[1] ) return 0;\n\trep(i,2,n){\n\t\tf[i] = f[fa[i]] + n - sz[i] * 2;\n\t\tif ( f[i] != d[i] ) return 0;\n\t}\n\treturn 1;\n}\nbool solve(){\n\trep(i,1,n) d[i] = dt[i].d;\n\trepd(i,n,2){\n\t\tsz[i]++;\n\t\tll curd = d[i] - n + 2 * sz[i];\n\t\tint id = lower_bound(d + 1,d + n + 1,curd) - d;\n\t\tif ( d[id] != curd || id >= i ) return 0;\n\t\tfa[i] = id , sz[id] += sz[i];\n\t}\n\trep(i,2,n) adde(fa[i],i);\n\treturn check();\n}\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n) scanf(\"%lld\",&dt[i].d) , dt[i].id = i;\n\tsort(dt + 1,dt + n + 1);\n\tif ( solve() ){\n\t\trep(i,2,n) printf(\"%d %d\\n\",dt[fa[i]].id,dt[i].id);\n\t}\n\telse{\n\t\tprintf(\"-1\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define dbg1(x) cerr<<#x<<\"=\"<<(x)<<\" \"\n#define dbg2(x) cerr<<#x<<\"=\"<<(x)<<\"\\n\"\n#define dbg3(x) cerr<<#x<<\"\\n\"\nusing namespace std;\n#define se second\n#define fi first\n#define reg register\n#define mp make_pair\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nconst int MN=1e5+5;\nint N,D[MN],siz[MN],fa[MN];\nstruct edge{int to,nex;}e[MN<<1];int hr[MN],en;\nvoid ins(int x,int y){e[++en]=(edge){y,hr[x]};hr[x]=en;}\npair<int,int> a[MN];\nint dfs(int x)\n{\n\treg int i;int r=0;\n\tfor(i=hr[x];i;i=e[i].nex) r+=dfs(e[i].to)+siz[e[i].to];\n\treturn r;\n}\nint main()\n{\n\tN=read();reg int i,j;\n\tfor(i=1;i<=N;++i) D[i]=read(),a[i]=mp(D[i],i);\n\tstd::sort(a+1,a+N+1);\n\tfor(i=N;i>1;--i)\n\t{\n\t\tint x=a[i].se;\n\t\t++siz[x];\n\t\tint pos=lower_bound(a+1,a+N+1,mp(D[x]+2*siz[x]-N,0))-a;\n\t\tif(pos>=i||D[x]+2*siz[x]-N!=a[pos].fi) return 0*puts(\"-1\");\n\t\tfa[x]=a[pos].se;siz[fa[x]]+=siz[x];ins(fa[x],x);\n\t}\n\t++siz[a[1].se];\n\tif(dfs(a[1].se)!=D[a[1].se]) return 0*puts(\"-1\");\n\tfor(i=1;i<=N;++i)for(j=hr[i];j;j=e[j].nex)printf(\"%d %d\\n\",i,e[j].to);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*====Corycle====*/\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#define ll long long\n#define set_it set<Node>::iterator\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst int N=1e5+5;\nint read(){\n\tint s=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){s=s*10+c-'0';c=getchar();}\n\treturn s*f;\n}\nll a[N];\nint n,m,b[N],fa[N],sum[N];\nbool cmp(int x,int y){return a[x]>a[y];}\nstruct Node{\n\tll val;int x;\n\tfriend bool operator<(Node A,Node B){return A.val!=B.val?A.val<B.val:A.x<B.x;}\n};\nset<Node>F;\nint main(){\n//\tfreopen(\"_.in\",\"r\",stdin);\n//\tfreopen(\"_.out\",\"w\",stdout);\n\tn=read();\n\tfor(int i=1;i<=n;i++){a[i]=read();b[i]=i;sum[i]=1;F.insert((Node){a[i],i});}\n\tsort(b+1,b+n+1,cmp);\n\tfor(int i=1;i<n;i++){\n\t\tint x=b[i];\n\t\tll val=a[x]+2*sum[x]-n;\n\t\tF.erase((Node){a[x],x});\n\t\tset_it p=F.lower_bound((Node){val,0});\n\t\tif(p!=F.end()&&(*p).val==val){int y=(*p).x;fa[x]=y;sum[y]+=sum[x];}\n\t\telse{puts(\"-1\");return 0;}\n\t}\n\tint num=0;\n\tfor(int i=1;i<=n;i++)num+=(fa[i]!=0);\n\tif(num!=n-1){puts(\"-1\");return 0;}\n\tfor(int i=1;i<=n;i++)if(fa[i])printf(\"%d %d\\n\",i,fa[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimiz(O2)\n\n#include <bits/stdc++.h>\n\n#define rg register\nusing namespace std;\ntypedef long long ll;\n\ntemplate<typename T>\ninline bool read(T &n) {\n    T ans = 0, flag = 1;\n    char ch;\n    while ((ch = getchar()) < '0' || ch > '9') if (ch == '-') flag = -1; else if (ch == EOF) return false;\n    ans = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9') ans = ans * 10 + ch - '0';\n    n = ans * flag;\n    return true;\n}\n\ninline ll read() {\n    ll ans = 0, flag = 1;\n    char ch;\n    while ((ch = getchar()) < '0' || ch > '9') if (ch == '-') flag = -1;\n    ans = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9') ans = ans * 10 + ch - '0';\n    return ans * flag;\n};\nconst int maxn = 100005;\nstruct NODE {\n    ll val, ord;\n    bool operator<(NODE b) const {\n        return val < b.val;\n    }\n} node[maxn];\nstruct EDGE{\n    int nex,t;\n}edge[maxn<<1];\n\nint ecnt,head[maxn],siz[maxn],fa[maxn];\nunordered_map<ll,int> unM;\ninline void addedge(int u,int v){\n    edge[++ecnt].nex=head[u];head[u]=ecnt;edge[ecnt].t=v;\n    edge[++ecnt].nex=head[v];head[v]=ecnt;edge[ecnt].t=u;\n}\nint dfs(int rt,int fa,int dis){\n    int ans=dis;\n    for(rg int i=head[rt];i;i=edge[i].nex){\n        int y=edge[i].t;\n        if(y==fa) continue;\n        ans+=dfs(y,rt,dis+1);\n    }\n    return ans;\n}\nint main() {\n    int n;\n    read(n);priority_queue<NODE> pq;\n    for (rg int i = 1; i <= n; ++i) {\n        siz[i] = 1;read(node[i].val);\n        node[i].ord = i;\n        pq.push(node[i]);\n        unM[node[i].val]=i;\n    }\n    for(rg int i=n;i>=2;i--){\n        NODE now=pq.top();pq.pop();\n        if(unM.find(now.val+2*siz[now.ord]-n)==unM.end()){\n            puts(\"-1\");return 0;\n        }\n        fa[now.ord]=unM[now.val+2*siz[now.ord]-n];\n        siz[fa[now.ord]]+=siz[now.ord];\n        addedge(now.ord,fa[now.ord]);\n    }\n    if(siz[pq.top().ord]!=n||dfs(pq.top().ord,0,0)!=pq.top().val) puts(\"-1\");\n    else for(rg int i=1;i<=n;i++){\n        if(fa[i]) cout<<i<<' '<<fa[i]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nlong long d[100010];\n#define endl '\\n'\ntypedef pair <long long, int> pii;\n\nint sub[100010];\nint par[100010];\n\nint main(int argc, char const *argv[])\n{\n\tios_base :: sync_with_stdio (false);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tmap <long long, int> mp;\n\tvector <pii> v;\n\tfor(int i = 1; i <= n; i++) {\n\t\tcin >> d[i];\n\t\tv.emplace_back(d[i], i);\n\t\tmp[d[i]] = i;\n\t}\n\tsort(v.begin(), v.end());\n\treverse(v.begin(), v.end());\n\n\tfor(int i = 1; i <= n; i++) {\n\t\tsub[i] = 1;\n\t\tpar[i] = i;\n\t}\n\tfor(int i = 0; i < n-1; i++) {\n\t\tint node = v[i].second;\n\t\tint diff = n - 2 * sub[node];\n\t\tlong long par_d = v[i].first - diff;\n\t\tif(par_d == v[i].first || mp.find(par_d) == mp.end()) {\n\t\t\tcout << -1 << endl;\n\t\t\texit(0);\n\t\t}\n\t\tpar[node] = mp[par_d];\n\t\tsub[par[node]] += sub[node];\n\t}\n\tfor(int i = 0; i < n-1; i++) {\n\t\tint node = v[i].second;\n\t\tcout << node << \" \" << par[node] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fo(i,s,t) for(int i = s; i <= t; ++ i)\n#define fd(i,s,t) for(int i = s; i >= t; -- i)\n#define bf(i,s) for(int i = head[s]; i; i = e[i].next)\n#define mp make_pair\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pb push_back\n#define VI vector<int>\n#define sf scanf\n#define pf printf\n#define fp freopen\n#define SZ(x) ((int)(x).size())\n#ifdef MPS\n#define D(x...) printf(x)\n#else\n#define D(x...)\n#endif\ntypedef long long ll;\ntypedef double db;\ntypedef unsigned long long ull;\nconst int inf = 1<<30;\nconst ll INF = 1ll<<60;\nconst db Inf = 1e20;\nconst db eps = 1e-9;\n\nvoid gmax(int &a,int b){a = (a > b ? a : b);}\nvoid gmin(int &a,int b){a = (a < b ? a : b);}\n\nconst int maxn = 100050;\n\nint n, sz[maxn];\npair<ll,int> d[maxn];\nstruct edge{int u, v;}e[maxn];\n\nint main()\n{\n\t// fp(\"1.in\",\"r\",stdin);\n\t// fp(\"2.out\",\"w\",stdout);\n\tsf(\"%d\",&n);\n\tfo(i,1,n) sf(\"%lld\",&d[i].fi), d[i].se = i;\n\tsort(d+1, d+n+1);\n\tfd(i,n,2)\n\t{\n\t\tsz[i] ++;\n\t\tint l = 1, r = i-1, mid, p = -1;\n\t\twhile(l <= r)\n\t\t{\n\t\t\tmid = (l + r) >> 1;\n\t\t\tif(d[mid].fi <= d[i].fi-n+2*sz[i]) p = mid, l = mid + 1;\n\t\t\telse r = mid - 1;\n\t\t}\n\t\tif(p == -1 || d[p].fi != d[i].fi-n+2*sz[i]) \n\t\t{\n\t\t\tassert(0);\n\t\t\treturn 0 * pf(\"-1\\n\");\n\t\t}\n\t\tsz[p] += sz[i];\n\t\te[i].u = d[p].se; e[i].v = d[i].se;\n\t}\n\tsz[1] ++;\n\tll ans = 0;\n\tfo(i,1,n) ans += sz[i] * (ll)(n - sz[i]);\n\tans <<= 1;\n\tfo(i,1,n) ans -= d[i].fi;\n\tif(ans != 0) return 0 * pf(\"-1\\n\");\n\tfo(i,2,n) pf(\"%d %d\\n\",e[i].u,e[i].v);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=1e5+10;\nint n,cnt,e,f[N],a[N],id[N],w[N],siz[N],res[N],head[N],link[N],to[N];\nbool vis[111111];\nbool cmp(int x,int y){return a[x]<a[y];}\nvoid add(int u,int v){to[++e]=v,link[e]=head[u],head[u]=e;}\nvoid dfs1(int u,int dep){\n\tsiz[u]=1,res[id[1]]+=dep;\n\tfor(int i=head[u];i;i=link[i])if(to[i]!=f[u])dfs1(to[i],dep+1),siz[u]+=siz[to[i]];\n}\nvoid dfs2(int u){for(int i=head[u];i;i=link[i])if(to[i]!=f[u])res[to[i]]=res[u]+n-2*siz[to[i]],dfs2(to[i]);}\nsigned main(){\n\tscanf(\"%lld\",&n),w[0]=-LLONG_MAX;\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),id[i]=i,w[i]=a[i],siz[i]=1;\n\tsort(id+1,id+n+1,cmp),sort(w+1,w+n+1);\n\tfor(int i=n;i>1;i--){\n\t\tint x=2*siz[id[i]]-n+a[id[i]],pos=lower_bound(w+1,w+n+1,x)-w;\n\t\tif(w[pos]!=x||n-2*siz[id[i]]<=0){printf(\"-1\");return 0;}\n\t\tadd(id[pos],id[i]),siz[id[pos]]+=siz[id[i]],f[id[i]]=id[pos];\n\t}\n\tdfs1(id[1],0),dfs2(id[1]);\n\tfor(int i=1;i<=n;i++)if(a[i]!=res[i]){printf(\"-1\");return 0;}\n\tfor(int i=2;i<=n;i++)printf(\"%lld %lld\\n\",f[id[i]],id[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nconst int N = 100000 + 7;\n\nint n;\nint d[N], s[N], t[N], e[N];\nint u[N], v[N];\n\nint main() {\n//\tfreopen(\"code.in\", \"r\", stdin);\n//\tfreopen(\"code.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", d + i), e[i] = i, s[i] = 1;\n\tstd::sort(e + 1, e + n + 1, [](int a, int b) {\n\t\treturn d[a] < d[b];\n\t});\n\tfor (int i = n; i > 1; --i) {\n\t\tint j = std::lower_bound(e + 1, e + n + 1, d[e[i]] - n + s[e[i]] * 2, [](int a, int b){\n\t\t\treturn d[a] < b;\n\t\t}) - e;\n\t\tif (d[e[j]] != d[e[i]] - n + s[e[i]] * 2) return printf(\"-1\"), 0;\n\t\ts[e[j]] += s[e[i]], t[e[j]] += t[e[i]] + s[e[i]];\n\t\tu[n - i + 1] = e[i], v[n - i + 1] = e[j];\n\t}\n\tif (d[e[1]] != t[e[1]]) return printf(\"-1\"), 0;\n\tfor (int i = 1; i < n; ++i)\n\t\tprintf(\"%d %d\\n\", u[i], v[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC target (\"sse4.2\")\n#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx,avx2,fma\")\n#pragma GCC optimize (\"unroll-loops\")\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;\n\n#define MP make_pair\n#define sp(x) fixed<<setprecision(x)\n#define pb push_back\n#define die(x) return cout << x << endl, 0\n#define fastio ios_base::sync_with_stdio(0);cin.tie(nullptr);cout.tie(nullptr);\n#define file ifstream cin(\"input.txt\"); ofstream cout(\"output.txt\")\n#define F first\n#define S second\n#define int long long\n#define lc ind << 1\n#define rc ind << 1 | 1\n//thissss\nconst int MAXN = 1000 * 1000 + 7, MOD = 1000 * 1000 * 1000 + 7;\nint n, sz[MAXN], par[MAXN], dis[MAXN];\npair<int, int>d[MAXN];\nmap<int, int>pos;\nvector<int>adj[MAXN];\nvoid dfs(int v, int p){\n\tfor(auto u : adj[v])if(u!=p){\n\t\tdis[u] = dis[v] + 1;\n\t\tdfs(u, v);\n\t}\n\treturn;\n}\nint32_t main(){\n    fastio;\n\tcin >> n;\n\tfor(int i = 0; i < n; i ++){\n\t\tcin >> d[i].F;\n\t\td[i].S = i;\n\t}\n\tsort(d, d + n, greater<pair<int, int> >());\n\tfor(int i = 0; i < n; i ++)\n\t\tpos[d[i].F] = i + 1;\n\tfill(sz, sz + n, 1);\n\tfor(int i = 0; i < n - 1; i ++){\n\t\tint dis = d[i].F, v = d[i].S;\n\t\tint dpar = dis - (n - 2*sz[v]);\n\t\tint par= pos[dpar];\n\t\tpar --;\n\t\tif(par == -1 || par <= i)die(-1);\n\t\t::par[v] = d[par].S;\n\t\tadj[::par[v]].pb(v);\n\t\tadj[v].pb(::par[v]);\n\t\t\n\t\tsz[::par[v]] += sz[v];\n\t}\n\tint sum = 0;\n\tdfs(d[n -1].S, -1);\n\tfor(int i = 0; i < n; i ++)sum += dis[i];\n\tif(sum != d[n - 1].F)die(-1);\n\tfor(int i = 0; i < n - 1; i ++){\n\t\tint v = d[i].S;\n\t\tcout << v + 1 << ' ' << par[v] + 1 << endl;\n\t}\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pir pair<lli,lli>\n#define mpa make_pair\n#define fi first\n#define se second\ntypedef long long lli;\nusing namespace std;\nstruct Edge{\n\tlli to,nxt;\n}e[400010];\nlli n,cnt,sum;\nlli d[100010],h[100010],siz[100010],dis[100010];\nmap <lli,lli> id;\nvector <pir> ans;\nvoid add(lli u,lli v)\n{\n\te[++cnt].to=v;\n\te[cnt].nxt=h[u];\n\th[u]=cnt;\n}\nvoid dfs(lli u)\n{\n\tfor(lli i=h[u];i;i=e[i].nxt){\n\t\tlli v=e[i].to;\n\t\tdis[v]=dis[u]+1;\n\t\tdfs(v);\n\t}\n}\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tfor(lli i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&d[i]);\n\t\tid[d[i]]=i;\n\t\tsiz[i]=1;\n\t}\n\tsort(d+1,d+n+1);\n\tfor(lli i=n;i>1;i--){\n\t\tlli u=id[d[i]],tmp=n-2*siz[u];\n\t\tif(tmp<=0||id.count(d[i]-tmp)==0){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tlli f=id[d[i]-tmp];\n\t\tadd(f,u);\n\t\tans.push_back(mpa(f,u));\n\t\tsiz[f]+=siz[u];\n\t}\n\tdfs(id[d[1]]);\n\tfor(lli i=1;i<=n;i++) sum+=dis[i];\n\tif(sum!=d[1]){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(lli i=0;i<ans.size();i++)\n\t\tprintf(\"%lld %lld\\n\",ans[i].fi,ans[i].se);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep3(i,a,b) for(int i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\n#define MAX_V 400010\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\ntemplate<typename A, size_t NNN, typename T>\nvoid Fill(A (&array)[NNN], const T &val){\n    fill( (T*)array, (T*)(array+NNN), val );\n}\n#define N 100100\n#define INF 1e9+7\nll MOD=1e9+7;\n\nint n;\nstruct node{\n    ll d;int id;\n};\nnode a[N];\nint s[N];\nmain(){\n    n=in();\n    map<ll,int> m;\n    rep(i,n){\n        a[i]=node{lin(),i+1};\n        m[a[i].d]=a[i].id;\n    }\n    sort(a,a+n,[](node a,node b){\n        return a.d>b.d;\n    });\n    struct edge{\n        int from,to;\n        void print(){\n            printf(\"%d %d\\n\",from,to);\n        }\n    };\n    vector<edge> ans;\n    rep(i,n-1){\n        ll now=a[i].d;\n        ll t=(ll)s[a[i].id];\n        now-=n-2-t*2;\n        if(!m[now]){\n            cout<<-1;return 0;\n        }\n        s[m[now]]+=t+1;\n        ans.pb(edge{a[i].id,m[now]});\n    }\n    if(s[a[n-1].id]!=n-1){\n        cout<<-1;return 0;\n    }\n    else{\n        for(auto e:ans){\n            e.print();\n        }\n    }\n    return 0;\n}   \n"
  },
  {
    "language": "C++",
    "code": "//I love Nanami Chiaki\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define mp make_pair\n#define fst first\n#define snd second\nconst int maxn=1e5+7;\nint n;\nll d[maxn];\npli sx[maxn];\nint sz[maxn];\nll dis[maxn];\nint findit(ll t){\n\tif (t<0) return -1;\n\tint l=0,r=n-1,mid;\n\twhile (l<=r){\n\t\tmid=(l+r)>>1;\n\t\tif (sx[mid].fst==t) return mid;\n\t\tif (sx[mid].fst<t) l=mid+1;\n\t\telse r=mid-1;\n\t}\n\treturn -1;\n}\nvoid badend(){\n\tputs(\"-1\");\n\texit(0);\n}\nvector<pii> ans;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=0;i<n;i++){\n\t\tscanf(\"%lld\",d+i);\n\t\tsx[i]=mp(d[i],i);\n\t\tsz[i]=1;dis[i]=0;\n\t}\n\tsort(sx,sx+n);\n\tfor (int i=n-1;i>0;i--){\n\t\tint v=sx[i].snd;\n\t\tll w=sx[i].fst;\n\t\tint u=findit(w+1ll*sz[v]*2-n);\n\t\tif (u==-1) badend();\n\t\tu=sx[u].snd;\n\t\tsz[u]+=sz[v];\n\t\tans.push_back(mp(u+1,v+1));\n\t\tdis[u]+=dis[v]+sz[v];\n\t}\n\tif (dis[sx[0].snd]!=sx[0].fst) badend();\n\tfor (int i=0;i<n-1;i++){\n\t\tprintf(\"%d %d\\n\",ans[i].fst,ans[i].snd);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100010;\ntypedef long long int64;\n\nmap<int64 , int> val;\nint n , size[N] , fa[N];\n\nint64 d[N];\ntypedef pair<int64 , int> pii;\npriority_queue<pii> leaf;\n#define mp make_pair \n\nint main() {\n    cin >> n;\n    for(int i = 1 ; i <= n ; ++i) {\n        cin >> d[i];\n        size[i] = 1;\n        val[d[i]] = i; \n    }\n    for(int i = 1 ; i <= n ; ++i) leaf.push(mp(d[i] , i));\n\n    while(leaf.size()) {\n        int x = leaf.top().second;\n        leaf.pop();\n\n\t\tval.erase(d[x]);\n        if(val.count(d[x] - n + size[x]*2))\n            fa[x] = val[d[x] - n + size[x]*2];\n        else break;\n        \n        size[fa[x]] += size[x];\n    }\n\n    for(int i = 1 , cnt = 0; i <= n ; ++i) {\n    \tif(fa[i] == i) {cout << -1 << endl; return 0;}\n    \tif(fa[i] == 0 && ++cnt > 1)  {cout << -1 << endl; return 0;}\n\t}\n    for(int i = 1 ; i <= n ; ++i)\n        if(fa[i]) cout << i << ' ' << fa[i] << endl;\n\t\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//https://atcoder.jp/contests/arc103/tasks/arc103_d\n#include <iostream>\n#include <cstdio>\n#include <string.h>\n#include <algorithm>\t\t//lower_bound\nusing namespace std;\nbool vis[100005],rt;\nint n,ansnum;\npair<int,int> ans[100005];\nstruct node\n{\n\tlong long val;\n\tint num;\n};\nnode a[100005];\nbool cmp(node x,node y)\n{\n\tif (x.val>y.val) return 1;\n\treturn 0;\n}\nbool cmp2(pair<int,int> a, pair<int,int> b)\n{\n\tif (a.first<b.first) return 1;\n\tif (a.first>b.first) return 0;\n\tif (a.second<b.second) return 1;\n\treturn 0;\n}\nint fd(int pos,long long v)\n{\n\tint beg=pos,ed=n,md;\n\twhile (beg<=ed)\n\t{\n\t\tmd=(beg+ed)/2;\n\t\tif (a[md].val==v) return md;\n\t\telse if (a[md].val>v) beg=md+1;\n\t\telse ed=md-1;\n\t}\n\tif (a[md].val!=v) return -1;\n}\nvoid go(int pos,int dis)\n{\n\tvis[pos]=1;\n\tint nex=fd(pos,a[pos].val-dis);\n\t//cout<<nex<<endl;\n\tif (nex>0)\n\t{\n\t\tansnum++;\n\t\tif (a[pos].num<a[nex].num) ans[ansnum]=make_pair(a[pos].num,a[nex].num);\n\t\telse ans[ansnum]=make_pair(a[nex].num,a[pos].num);\n\t\tif (dis>1) go(nex,dis-2);\n\t}\n\telse\n\t{\n\t\tif (pos!=n)\t\t//!!!!important!要确定最后根是数值最小的 \n\t\t{\n\t\t\trt=0;\n\t\t}\n\t}\n\treturn;\n}\nint main()\n{\n\trt=1;\n\tint i;\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i].val);\n\t\ta[i].num=i;\n\t}\n\tsort(a+1,a+n+1,cmp);\n\tmemset(vis,0,sizeof(vis));\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tif (!vis[i])\n\t\t{\n\t\t\t//cout<<i<<endl;\n\t\t\tgo(i,n-2);\n\t\t}\n\t}\n\tif (ansnum!=n-1 || !rt)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tsort(ans+1,ans+ansnum+1,cmp2);\n\tfor (i=1;i<=ansnum;i++)\n\t{\n\t\tprintf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxN = 1e5 + 10;\nlong long d[maxN];\nint sz[maxN];\nint n;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i) cin >> d[i];\n\tfor (int i = 1; i <= n; ++i) sz[i] = 1;\n\tmap<long long, int, greater<long long>> p;\n\tfor (int i = 1; i <= n; ++i) p[d[i]] = i;\n\tvector<pair<int, int>> edges;\n\tbool fun = 1;\n\twhile (p.size() > 1) {\n\t\tauto f = p.begin(); p.erase(f);\n\t\tlong long d_p = (f->first + 2*sz[f->second] - n);\n\t\tfun &= p.count(d_p);\n\t\tif (not fun) break;\n\t\tint r = p[d_p];\n\t\tsz[r] += sz[f->second];\n\t\tedges.push_back({r, f->second});\n\t}\n\tif (fun) {\n\t\tfor (auto e : edges) {\n\t\t\tcout << e.first << \" \" << e.second << endl;\n\t\t}\n\t} else puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<cstring>\n#include<utility>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<set>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#define ll long long\n#define pii pair<ll,int>\n#define mp make_pair\n#define fi first\n#define se second\n#define inf 0x7fffffff\nusing namespace std;\nll a[100010];\npii b[100010],c[100010];\nvector<pii> ans;\nint main()\n{\n\tint i,k,n,m,x,y,x1,n1;\n\tll j;\n\tscanf(\"%d\",&n);\n\tn1=n;\n\tfor(i=0;i<n;i++)\n\t{\n\t\tscanf(\"%lld\",&a[i]);\n\t\tb[i].fi=a[i];\n\t\tb[i].se=i+1;\n\t\tc[i]=b[i];\n\t}\n\tsort(b,b+n);\n\tvector<int> cl;\n\twhile(n>1)\n\t{\n\t\tx=n-1;\n\t\ti=2;\n\t\tk=0;\n\t\tcl.clear();\n\t\twhile(x!=0&&k<n)\n\t\t{\n\t\t\tj=b[x].fi-n1+i;\n\t\t\tif(j<y)\n\t\t\t{\n\t\t\t\tprintf(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ti+=2;\n\t\t\tx1=lower_bound(b,b+n,mp(j,0))-b;\n\t\t\tans.push_back(mp(b[x].se,b[x1].se));\n\t\t\tif(b[x1].fi!=j)\n\t\t\t{\n\t\t\t\tprintf(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcl.push_back(x);\n\t\t\tk++;\n\t\t\tx=x1;\n\t\t}\n\t\tif(k>=n)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(i=0;i<cl.size();i++)\n\t\t{\n\t\t\tb[cl[i]]=mp(0,0);\n\t\t}\n\t\tsort(b,b+n);\n\t\treverse(b,b+n);\n\t\treverse(b,b+n-k);\n\t\tn-=k;\n\t}\n\tfor(i=0;i<ans.size();i++)\n\t{\n\t\tprintf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#define ll long long\n#define inf 0x3f3f3f3f\n#define maxn 200010\ninline ll read()\n{\n\tll x=0; char c=getchar(),f=1;\n\tfor(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n\tfor(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\ninline void write(ll x)\n{\n\tstatic char buf[20];\n\tint len=0;\n\tif(x<0)putchar('-'),x=-x;\n\tfor(;x;x/=10)buf[len++]=x%10+'0';\n\tif(!len)putchar('0');\n\telse while(len)putchar(buf[--len]);\n}\ninline void writesp(ll x){write(x); putchar(' ');}\ninline void writeln(ll x){write(x); putchar('\\n');}\nll d[maxn];\nstd::map<ll,int>mp;\nint id[maxn],fa[maxn],size[maxn];\nint n;\nbool cmp(int x,int y){return d[x]>d[y];}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)\n\t\td[i]=read(),mp[d[i]]=i;\n\tfor(int i=1;i<=n;i++)\n\t\tid[i]=i;\n\tstd::sort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<n;i++){\n\t\t++size[id[i]];\n\t\tfa[id[i]]=mp[d[id[i]]-(n-2*size[id[i]])];\n\t\tif(!fa[id[i]]||fa[fa[id[i]]]){\n\t\t\tputs(\"-1\"); return 0;\n\t\t}\n\t\tsize[fa[id[i]]]+=size[id[i]];\n\t}\n\tfor(int i=1;i<n;i++)\n\t\twritesp(fa[id[i]]),writeln(id[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define to edge[i].v\n#define mp make_pair\n#define rint register int\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define fgx cerr<<\"-------------\"<<endl\n#define N 1000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nstruct P{int id;ll s;}a[N];\ninline bool cmp(P x,P y){return x.s>y.s;}\nmap<ll,int> go;\nint sz[N],fa[N];\nint main()\n{\tint n; cin>>n;\n\tfor(rint i=1;i<=n;i++) scanf(\"%lld\",&a[i].s),a[i].id=i,go[a[i].s]=i;\n\tsort(a+1,a+n+1,cmp);\n\tfor(rint i=1;i<=n;i++) sz[i]=1;\n\tfor(rint i=1;i<n;i++)\n\t{\tint x=a[i].id; if(2*sz[x]-n>=0) return !printf(\"-1\");\n\t\tll sfa=a[i].s+2*sz[x]-n;\n\t\tif(!go[sfa]) return !printf(\"-1\");\n\t\tfa[x]=go[sfa]; sz[fa[x]]+=sz[x];// debug(x);debug(fa[x]);\n\t}\n\tfor(rint i=1;i<=n;i++) if(fa[i]) printf(\"%d %d\\n\",i,fa[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long int ll;\ntypedef long double doublel;\n#define f first\n#define s second\n \nconst int N = 1e6 + 100;\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e17;\t\n\nset<pair<ll, ll>> s;\nint par[N], cnt[N];\nvector<pair<int, int>> ans;\n\nint main()\n{\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\t\n\t\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tll w;\n\t\tcin >> w;\n\t\ts.insert({-w, i});\n\t\tcnt[i] = 1;\n\t\tpar[i] = i; \n\t\t\n\t}\n\t\n\tbool fl = true;\n\t\n\twhile(s.size() != 1)\n\t{\n\t\tll w = -s.begin()->f;\n\t\tint x = s.begin()->s;\n\t\tll w2 = w-n+2*cnt[x];\n\t\ts.erase(s.begin());\n\n\n\t\t//cout << x+1 << ' '  << w << ' ' << w2 << ' ' << fl << endl; \n\n\n\t\tauto it = s.lower_bound({-w2, -1});\n\t\tif(it == s.end() || it->f != -w2)\n\t\t\tfl = false;\n\t\telse\n\t\t{\n\t\t\tint y = it->s;\n\t\t\tpar[x] = y;\n\t\t\tcnt[y] += cnt[x];\n\t\t}\t\t\n\t\t\n\t}\n\t\n\t\n\t\n\tif(!fl)\n\t{\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\t\n\t\n\t\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tif(i == par[i])\n\t\t\tcontinue;\n\t\tans.push_back({min(i, par[i]), max(i, par[i])});\n\t}\n\t\n\tsort(ans.begin(), ans.end());\n\t\n\tfor(auto e : ans)\n\t\tcout << e.f + 1 << ' ' << e.s + 1<< endl; \n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n    return 0;\n}\n\n \n \t\n \t\n\n\n\n\n \n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tint n; cin >> n;\n\tvi sz(n, 1);\n\tvector<pair<ll, int>> v;\n\trep(i, n){\n\t\tll x; cin >> x;\n\t\tv.emplace_back(x, i);\n\t}\n\tsort(all(v));\n\tvector<pi> ans;\n\t\n\t//dbg(v);\n\t\n\tfor(int i = n - 1; i > 0; i--){\n\t\tll nx = v[i].first - n + 2 * sz[v[i].second];\n\t\tauto j = lower_bound(all(v), pair<ll, int>(nx, -1));\n\t\t\n\t\t//dbg(i, nx);\n\t\t\n\t\tif(j->first != nx || j - v.begin() >= i){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tans.emplace_back(j->second, v[i].second);\n\t\tsz[j->second] += sz[v[i].second];\n\t}\n\tfor(auto i : ans) cout << i.first+1 << \" \" << i.second+1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define IL inline\n#define _ 1000005\n#define ll long long\nusing namespace std ;\n\nIL ll gi(){\n\tll data = 0 , m = 1; char ch = 0;\n\twhile(ch!='-' && (ch<'0'||ch>'9')) ch = getchar();\n\tif(ch == '-'){m = 0 ; ch = getchar() ; }\n\twhile(ch >= '0' && ch <= '9'){data = (data<<1) + (data<<3) + (ch^48) ; ch = getchar(); }\n\treturn (m) ? data : -data ; \n}\n\nll dis[_],fa[_],sz[_],m,n ; \n\nIL bool cmp(ll A , ll B){return A > B ; }\n\nint main() {\n\tn = gi() ;\n\tfor(int i = 1; i <= n; i ++) dis[i] = gi() ;\n\tsort(dis + 1 , dis + n + 1) ;\n\t//for(int i = 1; i <= n; i ++) cout << dis[i] << \" \" ; cout << endl ;\n\tdis[n + 1] = 1e18 ; \n\tfor(int i = n; i > 1; i --) {\n\t\tsz[i] ++ ; \n\t\tll ds = dis[i] + 2 * sz[i] - n ;\n\t\tint ps = lower_bound(dis + 1 , dis + n + 2 , ds) - dis ;\n\t\t//cout << i << \"  sz=\"<<sz[i]<<\"  ds=\"<<ds<<\"  ps=\"<<ps<<endl ;\n\t\tif(ps == n + 1) return puts(\"-1\") , 0 ;\n\t\tfa[i] = ps ;\n\t\tsz[ps] += sz[i] ; \n\t}\n\tsz[1] ++ ; \n\tfor(int i = 2; i <= n; i ++) cout << fa[i] << \" \" << i << endl ;\n\treturn 0 ; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//ここから編集する\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N;\n    cin >> N;\n\n    vector<ll> D(N);\n    map<ll, int> Dtov;\n    rep(i, 0, N) cin >> D[i];\n    rep(i, 0, N) Dtov[D[i]] = i + 1;\n\n    sort(D.rbegin(), D.rend());\n    vector<vector<int> > G(N, vector<int>());\n    vector<bool> used(D.size(), false);\n    vector<pair<int, int>> ans;\n\n    for (int i = 0; i < N - 1; ++i) {\n        if (!used[i]) {\n            used[i] = true;\n\n//            for (int k = N - 2; k > 0; k -= 2) {\n//                if (find(all(D), D[i] - k) == D.end()) {\n//                    cout << -1 << endl;\n//                    return 0;\n//                } else {\n//                    ans.emplace_back(Dtov[D[i]], Dtov[D[i] - k]);\n//                }\n//            }\n            ll tmp = D[i];\n            ll dec = N - 2;\n            while (tmp > D.back()) {\n                if (find(all(D), tmp - dec) == D.end()) {\n                    cout << -1 << endl;\n                    return 0;\n                } else {\n                    ans.emplace_back(Dtov[tmp], Dtov[tmp - dec]);\n//                    used[Dtov[tmp - dec]] = true;\n                    used[find(all(D), tmp - dec) - D.begin()] = true;\n                    tmp -= dec;\n                    dec -= 2;\n                }\n            }\n        }\n    }\n\n    for (auto e : ans) {\n        cout << e.first << \" \" << e.second << endl;\n//        cout << e.second << \" \" << e.first << endl;\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define ld long double\n#define F first\n#define S second\n#define pii pair<ll,ll>\n\nusing namespace :: std;\n\nconst ll maxn=1e5+1050;\nconst ll mod=1e9+7;\nconst ll inf=1e9+5;\n\nvector<pii> yal;\nll sz[maxn];\npii d[maxn];\n\nint main(){\n   ll n;\n   cin>>n;\n   for(ll i=0;i<n;i++){\n        cin>>d[i].F;\n        d[i].S=i+1;\n   }\n   sort(d,d+n);\n   fill(sz,sz+maxn,1);\n   for(ll i=n-1;i>=1;i--){\n        ll v=d[i].S;\n        ll dpar=d[i].F+2*sz[v]-n;\n        ll K=lower_bound(d,d+n,mp(dpar,0LL))-d;\n        if(d[K].F!=dpar || dpar>=d[i].F || K>=n){\n            cout<<-1;\n            return 0;\n        }\n        ll par=d[K].S;\n        sz[par]+=sz[v];\n        yal.pb(mp(min(v,par),max(v,par)));\n   }\n   sort(yal.begin(),yal.end());\n   for(auto v:yal){\n        cout<<v.F<<' '<<v.S<<endl;\n   }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n#define fail return puts(\"-1\"), 0\n\n\n/*\n(u, v)\n\nd(v) sz(v)\n\nd(u) = d(v) + 2 * sz(v) - n\n\n */\n\nconst int N = 1e5 + 5, M = 2e5 + 5;\n\nint n, tot, lnk[N], ter[M], nxt[M], sz[N], fa[N];\nlong long dep[N], d[N], D[N];\nstd::map<long long, int> mp;\n\nvoid add(int u, int v) {\n\tter[++tot] = v, nxt[tot] = lnk[u], lnk[u] = tot;\n}\nvoid dfs1(int u, int p) {\n\tsz[u] = 1;\n\tfor (int i = lnk[u]; i; i = nxt[i]) {\n\t\tint v = ter[i];\n\t\tif (v == p) continue;\n\t\tdep[v] = dep[u] + 1;\n\t\tdfs1(v, u);\n\t\tsz[u] += sz[v];\n\t}\n}\nvoid dfs2(int u, int p) {\n\tfor (int i = lnk[u]; i; i = nxt[i]) {\n\t\tint v = ter[i];\n\t\tif (v == p) continue;\n\t\tD[v] = D[u] - 2 * sz[v] + n;\n\t\tdfs2(v, u);\n\t}\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &d[i]);\n\t\tmp[d[i]] = i;\n\t\tsz[i] = 1;\n\t}\n\tint cnt = 0;\n\tfor (auto it = mp.rbegin(); it != mp.rend(); it++) {\n\t\tint v = it->second;\n\t\tlong long now = it->first;\n\t\tlong long s = now + 2 * sz[v] - n;\n\t\tif (!mp.count(s)) fail;\n\t\tint u = mp[s];\n\t\tif (u == v) fail;\n\t\tfa[v] = u, sz[u] += sz[v];\n\t\tadd(u, v), add(v, u);\n\t\tif (++cnt == n - 1) break;\n\t}\n\tdfs1(1, 0);\n\tD[1] = std::accumulate(dep + 1, dep + n + 1, 0LL);\n\tdfs2(1, 0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (D[i] != d[i]) fail;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (fa[i]) printf(\"%d %d\\n\", i, fa[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define mp make_pair\nusing namespace std;\n\ntypedef pair <long long, int> pli;\n\nlong long d[100010];\nmap <long long, int> ids;\nset <long long> all;\nvector <int> from[100010];\n\nint main(){\n\tint n; scanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%lld\", &d[i]);\n\t\tids[d[i]] = i;\n\t\tall.insert(d[i]);\n\t}\n\tint cnt = 0;\n\tint pos = ids[*all.begin()];\n\tall.erase(all.begin());\n\twhile (!all.empty()){\n\t\tauto it = all.end();\n\t\tit--;\n\t\tlong long x = *it, last = ids[x];\n\t\tint del = n - 2;\n\t\twhile (1){\n\t\t\tall.erase(x);\n\t\t\tx -= del, del -= 2;\n\t\t\tint now = -1;\n\t\t\tif (!all.count(x)) break;\n\t\t\tnow = ids[x];\n\t\t\tfrom[now].push_back(last);\n\t\t\tlast = now;\n\t\t}\n\t\tif (x != d[pos]){\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tfrom[pos].push_back(last);\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < from[i].size(); j++){\n\t\t\tprintf(\"%d %d\\n\", i + 1, from[i][j] + 1);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\nconst int N = 100 * 1000 + 5;\n\nmap <long long, int> mp;\nvector <pair <int, int> > e;\npair <long long, int> d[N];\nint c[N];\n\n\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> d[i].first;\n\t\td[i].second = i;\n\t\tc[i] = 1;\n\t}\n\tsort(d + 1, d + n + 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tmp[d[i].first] = i;\n\t}\n\tfor (int i = n; i > 1; i--) {\n\t\tint u = mp[d[i].first - n + 2 * c[i]];\n\t//\tcout << \"73 \" << d[i].second << \" \" << d[u].second << endl;\n\t\tif (u == 0 || u == i) {\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t} \n\t\tc[u] += c[i];\n\t\te.push_back({d[i].second, d[u].second});\n\t}\n\tfor (auto p : e) {\n\t\tcout << p.first << \" \" << p.second << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = pair<lint, int>;\nconst int MAXN = 100005;\n\nvoid my_ass(bool p){\n\tif(!p){\n\t\tputs(\"-1\");\n\t\texit(0);\n\t}\n}\n\nint n, leaf_size[MAXN];\npi a[MAXN];\nvector<int> gph[MAXN];\n\nlint get_dist(int x, int d){\n\tlint ret = d;\n\tfor(auto &i : gph[x]) ret += get_dist(i, d + 1);\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<=n; i++){\n\t\tscanf(\"%lld\",&a[i].first);\n\t\ta[i].second = i;\n\t}\n\tsort(a + 1, a + n + 1);\n\tfill(leaf_size + 1, leaf_size + n + 1, 1);\n\tfor(int i=n; i>1; i--){\n\t\tlint nxt = a[i].first - n + 2 * leaf_size[i];\n\t\tint pos = lower_bound(a + 1, a + n + 1, pi(nxt, -1)) - a;\n\t\tif(a[pos].first == nxt && pos < i){\n\t\t\tgph[pos].push_back(i);\n\t\t\tleaf_size[pos] += leaf_size[i];\n\t\t}\n\t\telse my_ass(0);\n\t}\n\tmy_ass(get_dist(1, 0) == a[1].first);\n\tfor(int i=1; i<=n; i++){\n\t\tfor(auto &j : gph[i]){\n\t\t\tif(i < j) printf(\"%d %d\\n\", a[i].second, a[j].second);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<long long> d(n);\n\tlong long miii = 1e15;\n\tint cent = -1;\n\tmap<long long, int> mp;\n\trep(i, n) {\n\t\tscanf(\"%lld\", &d[i]);\n\t\tmp[d[i]] = i;\n\t\tif (miii > d[i]) {\n\t\t\tmiii = d[i];\n\t\t\tcent = i;\n\t\t}\n\t}\n\tset<long long> st;\n\trep(i, n) {\n\t\tif (miii != d[i]) {\n\t\t\tst.insert(d[i]);\n\t\t}\n\t}\n\tvector<pair<int, int>> ans;\n\tauto no = [](){ cout << -1 << endl; exit(0); };\n\twhile (true) {\n\t\tif (ans.size() >= n - 1) braak;\n\t\tlong long mi;\n\t\tfor (auto it : st) {\n\t\t\tmi = it;\n\t\t\tbreak;\n\t\t}\n\t\tst.erase(mi);\n\t\tint id = mp[mi];\n\t\tans.push_back({id, cent});\n\t\tlong long dist = mi - miii;\n\t\tlong long k = ((long long) n - dist) / 2;\n\t\tk --;\n\t\tdist += 2;\n\t\tlong long cur = mi;\n\t\tlong long prev;\n\t\twhile (k --) {\n\t\t\tprev = cur;\n\t\t\tcur += dist;\n\t\t\tif (st.count(cur) == 0) {\n\t\t\t\tno();\n\t\t\t}\n\t\t\tst.erase(cur);\n\t\t\tint pid = mp[prev];\n\t\t\tint cid = mp[cur];\n\t\t\tans.push_back({pid, cid});\n\t\t\tdist += 2;\n\t\t}\n\t}\n\tfor (auto it : ans) printf(\"%d %d\\n\", it.first + 1, it.second + 1);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Peace Of SHIT\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ntypedef pair<int, int> pii;\nconst int maxn = 1e5 + 5;\nint n, si[maxn];\nint sum = 0;\nvector<int> e[maxn];\npii d[maxn];\n\nvoid impossible() {\n\tcout << -1;\n\texit(0);\n}\n\nvoid dfs(int u, int x) {\n\tsum += x;\n\tfor(int i = 0; i < e[u].size(); i++) {\n\t\tdfs(e[u][i], x + 1);\n\t}\n}\n\nint32_t main() {\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\td[i] = {a, i};\n\t}\n\tsort(d, d + n);\n\treverse(d, d + n);\n\t\n\tvector <pii> k (d, d + n);\n\t\n\tfor(int q = 0; q < n - 1; q++) {\n\t\tint leaf = d[q].second;\n\t\tint parD = d[q].first - (n - (2 * (si[leaf] + 1)));\n\t\tauto it = lower_bound(k.rbegin(), k.rend(), pii(parD, 0));\n//\t\tcout << \"PAR : \" <<it->first << \" : \" << parD << '\\n';\n\t\tif(it -> first != parD) {\n//\t\t\tcerr << \"AVALI\\n\";\n\t\t\timpossible();\n\t\t}\n\t\tint par = it -> second;\n\t\tsi[par] += si[leaf] + 1;\n\t\tif((si[leaf] + 1) * 2 > n) {\n//\t\t\tcout << \"DOVOMI\\n\";\n\t\t\timpossible();\n\t\t}\n\t\t//SEVOMI HAM MISHE D[I] ROOT OK E ?\n\t\te[par].push_back(leaf);\n\t}\n\tint D = d[n - 1].second;\n\tdfs(D, 0);\n\tif(sum != d[n - 1].first)\n\t\timpossible();\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < e[i].size(); j++)\n\t\t\tcout << i + 1 << \" \" << e[i][j] + 1 <<'\\n';\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 1e5 + 7;\n\ntypedef long long LL;\n\nstruct Edge{\n\tint to,last;\n}E[maxn];\nLL d[maxn];\nunordered_map<LL,int>M_T;\n\nint n;\nint cnt;\nint siz[maxn];\nint head[maxn];\nLL sum;\nvoid Adde(int x,int y){\n\tE[++cnt] = (Edge){y,head[x]};\n\thead[x] = cnt;\n}\nvoid Dfs(int x,LL cur){\n\tsum += cur;\n\tfor(int i = head[x],y; y = E[i].to,i; i = E[i].last){\n\t\tDfs(y,cur + 1);\n\t}\n}\nvoid Print(int x){\n\tfor(int i = head[x],y; y = E[i].to,i; i = E[i].last){\n\t\tprintf(\"%d %d\\n\",x,y);\n\t\tPrint(y);\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i = 1; i <= n; ++i)scanf(\"%lld\",&d[i]),M_T[d[i]] = i,siz[i] = 1;\n\tsort(d + 1,d + n + 1);\n\tfor(int i = n; i > 1; --i){\n\t\tint x = M_T[d[i]];\n\t\tint tmp = n - 2 * siz[x];\n\t\tif(tmp <= 0)return !puts(\"-1\");\n\t\tLL cur = d[i] - tmp;\n\t\tif(!M_T.count(cur))return !puts(\"-1\");\n\t\tint prt = M_T[cur];\n\t\tAdde(prt,x);\n\t\tsiz[prt] += siz[x];\n\t}\n\tDfs(M_T[d[1]],0);\n\tif(sum != d[1])return !puts(\"-1\");\n\tPrint(M_T[d[1]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long LL;\nint _min(int x, int y) {return x < y ? x : y;}\nint _max(int x, int y) {return x > y ? x : y;}\nLL read() {\n\tLL s = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = getchar();\n\treturn s * f;\n}\n\nstruct edge {\n\tint x, y;\n} e[110000];\nstruct node {\n\tLL x; int id;\n} a[110000];\nLL d[110000];\nint tot[110000];\n\nbool cmp(node a, node b) {return a.x < b.x;}\n\nint main() {\n\tLL n = read();\n\tfor(int i = 1; i <= n; i++) a[i].x = read(), a[i].id = i;\n\tsort(a + 1, a + n + 1, cmp);\n\tfor(int i = 1; i <= n; i++) d[i] = a[i].x;\n\tfor(int i = 1; i <= n; i++) tot[i] = 1;\n\tint len = 0;\n\tfor(int i = n; i > 1; i--) {\n\t\tint u = d[i] - n + 2 * tot[i];\n\t\tint fa = lower_bound(d + 1, d + n + 1, u) - d;\n\t\tif(d[fa] != u) {puts(\"-1\"); return 0;}\n\t\te[++len].x = i, e[len].y = fa;\n\t\ttot[fa] += tot[i];\n\t} for(int i = 1; i < n; i++) printf(\"%d %d\\n\", a[e[i].x].id, a[e[i].y].id);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*input\n2\n2 2\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\n\n//}}}\nconst ll maxn=300005;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=8000000000000000000LL;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=ll(1e9+7);\nconst double PI=acos(-1);\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\t\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nll d[maxn];\nset<pll,greater<pll>> st;\nvector<pii> edge;\nint sz[maxn];\n\nvector<int> G[maxn];\nint dis[maxn];\nbool vis[maxn];\nvoid dfs(int u){\n\tvis[u]=1;\n\tfor(int v:G[u]) if(!vis[v]){\n\t\tdis[v]=dis[u]+1;\n\t\tdfs(v);\n\t}\n}\n\nint main()\n{\n\tIOS;\n\tint n;\n\tcin>>n;\n\tREP(i,n) cin>>d[i];\n\tREP(i,n) st.insert(MP(d[i],i));\n\tREP(i,n) sz[i]=1;\n\n\twhile(SZ(st)>1){\n\t\tauto cur=*st.begin();\n\t\t// cout<<cur<<'\\n';\n\t\tst.erase(st.begin());\n\t\tll new_size=cur.F+sz[cur.S]-(n-sz[cur.S]);\n\t\tauto nxt=*st.lower_bound(MP(new_size,INF64));\n\t\tif(nxt.F!=new_size){\n\t\t\tcout<<\"-1\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tedge.pb(MP(cur.S,nxt.S));\n\t\tG[cur.S].pb(nxt.S);\n\t\tG[nxt.S].pb(cur.S);\n\t\tsz[nxt.S]+=sz[cur.S];\n\t}\n\tdis[0]=0;\n\tdfs(0);\n\tREP(i,n) d[0]-=dis[i];\n\tif(d[0]){\n\t\tcout<<\"-1\\n\";\n\t\treturn 0;\n\t}\n\n\tfor(int i=0;i<n-1;i++){\n\t\tcout<<edge[i].F+1<<' '<<edge[i].S+1<<'\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define ld long double\n#define F first\n#define S second\n#define pii pair<ll,ll>\n\nusing namespace :: std;\n\nconst ll maxn=1e5+1050;\nconst ll mod=1e9+7;\nconst ll inf=1e9+5;\n\nvector<pii> yal;\nll sz[maxn];\npii d[maxn];\n\nint main(){\n   ll n;\n   cin>>n;\n   ll sum=0;\n   for(ll i=0;i<n;i++){\n        cin>>d[i].F;\n        sum+=d[i].F;\n        d[i].S=i+1;\n   }\n   sort(d,d+n);\n   fill(sz,sz+maxn,1);\n   for(ll i=n-1;i>=1;i--){\n        ll v=d[i].S;\n        ll dpar=d[i].F+2*sz[v]-n;\n        ll K=lower_bound(d,d+n,mp(dpar,0LL))-d;\n        if(d[K].F!=dpar || dpar>=d[i].F || K>=n){\n            cout<<-1;\n            return 0;\n        }\n        ll par=d[K].S;\n        sum-=sz[v]*(n-sz[v]);\n        sz[par]+=sz[v];\n        yal.pb(mp(min(v,par),max(v,par)));\n   }\n   if(sum!=0){\n        cout<<-1;\n        return 0;\n   }\n   sort(yal.begin(),yal.end());\n   for(auto v:yal){\n        cout<<v.F<<' '<<v.S<<endl;\n   }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=100005;\nstruct node{\n\tll d; int sz,id;\n\tfriend bool operator < (node a,node b){\n\t\treturn a.d<b.d;\n\t}\n};\nset<node> s;\nvector<pii> ans;\nint n;\n\nint main(){\n\tread(n);\t\n\trep(i,1,n){\n\t\tll tmp; read(tmp);\n\t\ts.insert((node){tmp,1,i});\n\t}\n\twhile(s.size()>=2){\n\t\tnode t=*(--s.end());\n\t\ts.erase(--s.end());\n\t\tset<node>::iterator it=s.lower_bound((node){t.d-n+2*t.sz,0});\n\t\tif(it==s.end()||it->d!=t.d-n+2*t.sz)\n\t\t\treturn puts(\"-1\"),0;\n\t\tint x=t.id,y=it->id;\n\t\tif(x>y)swap(x,y);\n\t\tans.pb(mp(x,y));\n\t\tnode v=*it;\n\t\tv.sz+=t.sz;\n\t\ts.erase(it);\n\t\ts.insert(v);\n\t}\n\tsort(ans.begin(),ans.end());\n\tfor(auto x:ans)\n\t\tprintf(\"%d %d\\n\",x.fi,x.se);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define title \"title\"\n#define ll long long\n#define ull unsigned ll\n#define fix(x) fixed<<setprecision(x)\n#define pii pair<int,int>\n#define vint vector<int>\n#define pb push_back\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define red(i,a,b) for(int i=(a);i>=(b);i--)\n#define db double\n#define ld long db\nusing namespace std;\nvoid Freopen(){\n\tfreopen(title\".in\",\"r\",stdin);\n\tfreopen(title\".out\",\"w\",stdout);\n}\nll read(){\n\tll g=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch){if(ch=='-')f=-1;ch=getchar();}\n\twhile('0'<=ch&&ch<='9'){g=g*10+ch-'0';ch=getchar();}\n\treturn g*f;\n}\nconst int N=1e5+5;\nmap<ll,int>id,fid;\nll a[N],ans;\nint n,siz[N];\nvint G[N];\nvoid dfs(int x,int dis){ans+=dis;for(auto y:G[x])dfs(y,dis+1);}\nsigned main(){\n\t//freopen(\"a\",\"r\",stdin);\n\tn=read();rep(i,1,n)a[i]=read(),fid[a[i]]=i;\n\tsort(a+1,a+n+1,[](int a,int b){return a>b;});\n\trep(i,1,n)id[a[i]]=i,siz[i]=1;\n\trep(i,1,n-1){\n\t\tint to=a[i]+siz[i]-(n-siz[i]);\n\t\tif(!id[to])return cout<<-1,signed();\n\t\tG[id[to]].pb(i);siz[id[to]]+=siz[i];\n\t}dfs(n,0);if(ans^a[n])return cout<<-1,signed();\n\trep(i,1,n)for(auto j:G[i])cout<<fid[a[i]]<<' '<<fid[a[j]]<<'\\n';\n\treturn signed();\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<map>\n#define LL long long\n#define M 200020\nusing namespace std;\nint read(){\n\tint nm=0,fh=1; char cw=getchar();\n\tfor(;!isdigit(cw);cw=getchar()) if(cw=='-') fh=-fh;\n\tfor(;isdigit(cw);cw=getchar()) nm=nm*10+(cw-'0');\n\treturn nm*fh;\n}\nLL n,m,D[M],sz[M],now,cur,u[M],v[M],tmp,tar;\nLL fs[M],nt[M<<1],to[M<<1],F[M],G[M],mx[M];\nmap<LL,LL>K;\nvoid fad(){puts(\"-1\");exit(0);}\nstruct node{LL id,dst;}p[M];\nbool cmp(node x,node y){return x.dst<y.dst;}\nvoid e(LL x,LL y){cur++,u[cur]=x,v[cur]=y;}\nvoid link(LL x,LL y){nt[tmp]=fs[x],fs[x]=tmp,to[tmp++]=y;}\nvoid dfs1(LL x){\n\tfor(LL i=fs[x];i!=-1;i=nt[i]){\n//\t\tprintf(\"%lld   --> %lld\\n\",x,to[i]);\n\t\tdfs1(to[i]),F[x]+=F[to[i]]+sz[to[i]];\n\t}\n}\nvoid dfs2(LL x){\n\tfor(LL i=fs[x];i!=-1;i=nt[i]){\n\t\tG[to[i]]=G[x]-sz[to[i]]-sz[to[i]]+n,dfs2(to[i]);\n\t}\n}\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read(),memset(fs,-1,sizeof(fs));\n\tfor(LL i=1;i<=n;i++) p[i].id=i,D[i]=read(),p[i].dst=D[i],K[D[i]]=i;\n\tsort(p+1,p+n+1,cmp);\n//\tfor(LL i=1;i<=n;i++) printf(\"%lld  %lld\\n\",p[i].id,p[i].dst);\n\tfor(LL i=n;i>1;i--){\n\t\tsz[p[i].id]++;\n\t\tLL num=p[i].dst-n+sz[p[i].id]*2ll;\n\t\tif(K.count(num)){\n//\t\t\tprintf(\"%lld\\n\",num);\n\t\t\tm=K[num];\n\t\t\tsz[m]+=sz[p[i].id];\n\t\t\tlink(m,p[i].id);\n\t\t\te(m,p[i].id);\n\t\t}\n\t\telse fad();\n\t}\n\tif(sz[p[1].id]!=n-1) fad();\n//\tputs(\"S\");\n\tdfs1(p[1].id),G[p[1].id]=F[p[1].id],dfs2(p[1].id);\n\tfor(LL i=1;i<=n;i++) if(G[i]!=D[i]) fad();\n\tfor(LL i=1;i<n;i++) printf(\"%lld %lld\\n\",u[i],v[i]); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#define ll long long\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nconst int N = 1e5 + 1000;\nint n,num; ll dis;\nint u[N],to[N],siz[N];\nstruct node\n{\n\tll v; int id;\n\tint friend operator <(node a,node b){return a.v < b.v;}\n}p[N];\nint main()\n{\n\tn = read();\n\tfor(int i = 1;i <= n;i ++) {p[i] = node{read(),i}; siz[i] = 1;}\n\tsort(p + 1,p + 1 + n);\n\tfor(int i = n;i > 1;i --)\n\t{\n\t\tll Dis = p[i].v - n + (siz[i] << 1);\n\t\tint t = lower_bound(p + 1,p + 1 + n,node{Dis,0}) - p;\n\t\tif(p[t].v != Dis) {puts(\"-1\"); return 0;}\n\t\tnum ++; u[num] = p[i].id; to[num] = p[t].id;\n\t\tdis += siz[i]; siz[t] += siz[i];\n\t}\n\tif(dis != p[1].v) {puts(\"-1\"); return 0;}\n\telse for(int i = 1;i < n;i ++) cout << u[i] << \" \" << to[i] << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nmap<int,int> M1,M2;\nint s1[200010],pa[200010];\nstruct edge\n{\n\tint v,next;\n}vs[200010];\nint st[200010],ee,sz[200010],vis[20010];\ninline void addedge(int u,int v)\n{\n\tvs[++ee].v=v;vs[ee].next=st[u];st[u]=ee;\n}\t\ninline void dfs(int rt,int pr)\n{\n\tif(vis[rt])\n\t{\n\t\tputs(\"-1\"); exit(0);\n\t}\n\tvis[rt]=1; sz[rt]=1;\n\tfor(int i=st[rt];i;i=vs[i].next)\n\t\tif(vs[i].v!=pr) dfs(vs[i].v,rt),sz[rt]+=sz[vs[i].v];\n}\nsigned main()\n{\n\tint n=read();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=read();\n\t\tM1[x]=i; M2[x]=1;\n\t\ts1[i]=x;\n\t}\n\tsort(s1+1,s1+1+n);\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tint id=M1[s1[i]],sz=M2[s1[i]],td=s1[i]+2*sz-n;\t\n\t\tif(td>=s1[i]) continue;\t\n\t\tpa[id]=M1[td]; M2[td]+=sz;\n\t}\n\tint rt=0;\n\tfor(int i=1;i<=n;i++) \n\t{\n\t\tif(pa[i]) addedge(pa[i],i),addedge(i,pa[i]);\n\t\telse \n\t\t{\n\t\t\tif(rt) puts(\"-1\");\n\t\t\telse rt=i;\n\t\t}\n\t}\n\tdfs(rt,0);\n\tif(sz[rt]!=n) puts(\"-1\");\n\telse\n\t{ \n\t\tfor(int i=1;i<=n;i++)\n\t\tif(pa[i]) printf(\"%lld %lld\\n\",i,pa[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nmap<int,int> M1,M2;\nint s1[200010],pa[200010];\nsigned main()\n{\n\tint n=read();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=read();\n\t\tM1[x]=i; M2[x]=1;\n\t\ts1[i]=x;\n\t}\n\tsort(s1+1,s1+1+n);\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tint id=M1[s1[i]],sz=M2[s1[i]],td=s1[i]+2*sz-n;\t\n\t\tif(td==s1[i]) continue;\t\n\t\tpa[id]=M1[td]; M2[td]+=sz;\n\t}\n\tint ze=0;\n\tfor(int i=1;i<=n;i++)\n\t\tze+=(pa[i]==0);\n\tif(1)\n\t{\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++) if(pa[i])\n\t\tprintf(\"%lld %lld\\n\",i,pa[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\nstruct Val{\n\tlong long d;\n\tint u;\n}p[100010];\nbool cmp(Val a,Val b)\n{\n\treturn a.d>b.d;\n}\nint find(int l,int r,long long t)\n{\n\twhile(l+1<r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(p[mid].d<=t)r=mid;\n\t\telse l=mid;\n\t}\n\tif(p[r].d!=t)return -1;\n\treturn r;\n}\nint u[100010],v[100010];\nint siz[100010];\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&p[i].d);\n\t\tp[i].u=i;\n\t}\n\tsort(p+1,p+n+1,cmp);\n\tlong long res=0;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tsiz[i]++;\n\t\tu[i]=p[i].u;\n\t\tint pos=find(i,n,p[i].d+siz[i]-(n-siz[i]));\n\t\tif(pos==-1){\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tv[i]=p[pos].u;\n\t\tsiz[pos]+=siz[i];\n\t\tres+=siz[i];\n\t}\n\tif(res!=p[n].d){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d %d\\n\",u[i],v[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FOR2(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define RFOR2(i,a,b) for(int i = (b);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define REP2(i,n)  FOR2(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define RREP2(i,n) RFOR2(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){if(a>b) {a=b; return true;} else return false;}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){if(a<b) {a=b; return true;} else return false;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nvec edge[101010],dist(101010),sum(101010);\n\nint dfs(int no, int par = -1, int d = 0){\n  int res = 0; sum[no] = 1;\n  for(int to:edge[no]){\n    if(to==par) continue;\n    res += dfs(to,no,d+1);\n    sum[no] += sum[to];\n  }\n  return res+d;\n}\n\nvoid dfs2(int no, int par = -1){\n  for(int to:edge[no]){\n    if(to==par) continue;\n    int x = sum[no]-sum[to];\n    dist[to] = dist[no] + x - sum[to];\n    sum[no] -= x; sum[to] += x;\n    dfs2(to,no);\n    sum[no] += x; sum[to] -= x;\n  }\n}\n\nvoid solve(){\n  int N;\n  cin >> N;\n\n  vector<P> D(N);\n  REP(i,N) cin >> D[i].fs, D[i].sc = i;\n  \n  sort(D.rbegin(),D.rend());\n\n  multiset<P> ms;\n  vec v(N,1);\n  REP(i,N){\n    auto itr = ms.upper_bound(P(D[i].fs,-1));\n    while(itr!=ms.end()&&(*itr).fs==D[i].fs){\n      int id = (*itr).sc;\n      v[i] += v[id];\n      edge[i].push_back(id);\n      edge[id].push_back(i);\n      itr = ms.erase(itr);\n    }\n    ms.insert(P(D[i].fs-N+2*v[i],i));\n  }\n\n  if(ms.size()>1){\n    cout << -1 << endl;\n    return;\n  }\n\n  if(D[0].fs != dfs(0)){\n    cout << -1 << endl;\n    return;\n  }\n\n  REP(i,N){\n    for(int j:edge[i]){\n      if(i<j) cout << D[i].sc+1 SP D[j].sc+1 << endl;\n    }\n  }\n\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int T = 1;\n  // cin >> T;\n\n  while(T--) solve();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nlong long n, d[N], s[N];\nvector<int> gr[N];\nmap<long long, int> mp;\nint main() {\n\tios_base::sync_with_stdio (false), cin.tie(0), cout.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> d[i], mp[d[i]] = i;\n\tsort(d, d + n, greater<int> ());\n\tfor (int i = 0; i < n; i++) {\n\t\tint v = mp[d[i]];\n\t\ts[v]++;\n\t\tint valpar = d[i] - n + 2 * s[v];\n//\t\tcout << \"i = \" << i << \" : \" << valpar << endl;\n\t\tif (!mp.count(valpar)) {\n\t\t\tif (i == n - 1)\n\t\t\t\tbreak;\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\tint par = mp[valpar];\n\t\ts[par] += s[v];\n\t\tgr[v].push_back(par);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (auto u : gr[i])\n\t\t\tcout << i + 1 << \" \" << u + 1 << \"\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN=3e5+7;\n\nll from[MAXN],to[MAXN];\n\nmap<ll,ll> Map;\n\nll n;\nll a[MAXN],b[MAXN],siz[MAXN];\n\nbool cmp(const ll &A,const ll &B){return a[A]>a[B];}\nbool cmp2(const ll &A,const ll &B){return A>B;}\n\nint main() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) {\n\t\tcin>>a[i];\n\t\tb[i]=i;\n\t\tMap[a[i]]=i;\n\t\tsiz[i]=1;\n\t}\n\tsort(b+1,b+1+n,cmp);\n\tsort(a+1,a+1+n,cmp2);\n\tfor(ll i=1,i2;i<n;i++) {\n\t\ti2=Map[a[i]-abs(n-2*siz[b[i]])];\n\t\tif(i2!=0&&a[i]-abs(n-2*siz[b[i]])!=a[i]) {\n\t\t\tsiz[i2]+=siz[b[i]];\n\t\t\tfrom[i]=i2;\n\t\t\tto[i]=b[i];\n\t\t}\n\t\telse {\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++) {\n\t\tcout<<from[i]<<\" \"<<to[i]<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include <cstddef>\n#include <cstdint>\n#include <vector>\n\nusing i8 = ::std::int_least8_t;\nusing i32 = ::std::int_least32_t;\nusing i64 = ::std::int_least64_t;\nusing u8 = ::std::uint_least8_t;\nusing u32 = ::std::uint_least32_t;\nusing u64 = ::std::uint_least64_t;\nusing isize = ::std::ptrdiff_t;\nusing usize = ::std::size_t;\n\nclass rep {\n\tconst usize f, l;\n\npublic:\n\tclass itr {\n\t\tfriend rep;\n\t\tusize i;\n\t\titr(usize x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { ++i; }\n\t\tusize operator*() const noexcept { return i; }\n\t\tbool operator!=(const itr x) const noexcept { return i != x.i; }\n\t};\n\trep(usize first, usize last) noexcept : f(first), l(last) {}\n\titr begin() const noexcept { return itr(f); }\n\titr end() const noexcept { return itr(l); }\n};\nclass revrep {\n\tconst usize f, l;\n\npublic:\n\tclass itr {\n\t\tfriend revrep;\n\t\tusize i;\n\t\titr(usize x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { --i; }\n\t\tusize operator*() const noexcept { return i; }\n\t\tbool operator!=(const itr x) const noexcept { return i != x.i; }\n\t};\n\trevrep(usize first, usize last) noexcept : f(first), l(last) {}\n\titr begin() const noexcept { return itr(l - 1); }\n\titr end() const noexcept { return itr(f - 1); }\n};\ntemplate <class T> bool maxi(T &a, const T &b) {\n\treturn a <= b ? (a = b, 1) : 0;\n}\ntemplate <class T> bool mini(T &a, const T &b) {\n\treturn b <= a ? (a = b, 1) : 0;\n}\ntemplate <class T> bool smaxi(T &a, const T &b) {\n\treturn b <= a ? 0 : (a = b, 1);\n}\ntemplate <class T> bool smini(T &a, const T &b) {\n\treturn a <= b ? 0 : (a = b, 1);\n}\ntemplate <class T> using vec_alias = ::std::vector<T>;\ntemplate <class T> auto md_vec(usize n, const T &value) {\n\treturn ::std::vector<T>(n, value);\n}\ntemplate <class... Args> auto md_vec(usize n, Args... args) {\n\treturn ::std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n}\ntemplate <class T> const T &as_const(const T &v) noexcept { return v; }\n\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <queue>\n#include <tuple>\n#include <unordered_map>\n\nint main() {\n\tusize n;\n\t::std::cin >> n;\n\t::std::vector<u64> d(n), sub(n, 1);\n\t::std::vector<usize> parent(n, n);\n\t::std::unordered_map<u64, usize> mp;\n\tfor (auto &e : d)\n\t\t::std::cin >> e;\n\t::std::priority_queue<u64> que;\n\tfor (const auto i : rep(0, n)) {\n\t\tque.emplace(d[i]);\n\t\tmp[d[i]] = i;\n\t}\n\n\t::std::vector<u64> csum(n, 0);\n\n\twhile (que.size() != 1) {\n\t\tu64 c = que.top();que.pop();\n\t\tusize i = mp[c];\n\t\tif (n <= sub[i] * 2 || c < n - sub[i] * 2)\n\t\t\treturn ::std::cout << \"-1\" << ::std::endl, 0;\n\t\tu64 next = c - (n - sub[i] * 2);\n\t\tif (mp.count(next)) {\n\t\t\tusize j = mp[next];\n\t\t\tparent[i] = j;\n\t\t\tcsum[j] += csum[i] + sub[i];\n\t\t\tsub[j] += sub[i];\n\t\t}\n\t\telse {\n\t\t\treturn ::std::cout << \"-1\" << ::std::endl, 0;\n\t\t}\n\t}\n\tconst usize top = mp[que.top()];\n\tif (csum[top] != d[top])\n\t\treturn ::std::cout << \"-1\" << ::std::endl, 0;\n\n\tfor (const auto i : rep(0, n)) {\n\t\tif (parent[i] != n)\n\t\t\t::std::cout << i + 1 << \" \" << parent[i] + 1 << ::std::endl;\n\t}\n\t\t\n\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst int MAXN = 200010;\nconst LL INF = 2147483600;\n\nstruct dat{\n\tLL id,val;\n}a[MAXN+1]; LL N;\nbool cmpval(dat a,dat b){\n\treturn a.val>b.val;\n}\nLL Node[MAXN<<1],Next[MAXN<<1],Root[MAXN+1],cnt;\ninline void insert(LL u,LL v){\n\tNode[++cnt]=v; Next[cnt]=Root[u]; Root[u]=cnt; return ;\n} LL sz[MAXN+1],f[MAXN+1],b[MAXN+1];\ninline void dfs(LL k,LL Fa){\n\tsz[k]=1;\n\tfor(LL x=Root[k];x;x=Next[x]){\n\t\tLL v=Node[x]; if(v==Fa) continue;\n\t\tdfs(v,k); sz[k]+=sz[v]; f[1]+=sz[v];\n\t} return ;\n}\ninline void dfs2(LL k,LL Fa){\n\tif(f[k]!=b[k]){ puts(\"-1\"); exit(0); }\n\tfor(LL x=Root[k];x;x=Next[x]){\n\t\tLL v=Node[x]; if(v==Node[x]) continue;\n\t\tf[v]=f[k]+N-2*sz[v]; dfs2(v,k);\n\t} return ;\n} LL s1[MAXN+1],s2[MAXN+1],top;\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tN=read();\n\tfor(LL i=1;i<=N;i++){\n\t\ta[i].id=i; a[i].val=read(); b[i]=a[i].val;\n\t} sort(a+1,a+N+1,cmpval);\n\tfor(LL i=1;i<=N;i++) sz[i]=1;\n\tfor(LL i=1;i<N;i++){\n\t\tLL val=a[i].val-N+2*sz[i]; \n\t\tLL l=i+1,r=N,pos=-1;\n\t\twhile(l<=r){\n\t\t\tLL mid=(l+r)>>1;\n\t\t\tif(a[mid].val>=val) pos=mid,l=mid+1;\n\t\t\telse r=mid-1;\n\t\t} if(pos==-1||a[pos].val!=val){\n\t\t\tputs(\"-1\"); return 0;\n\t\t} sz[pos]+=sz[i];\n\t\ts1[++top]=a[i].id; s2[top]=a[pos].id;\n\t\tinsert(a[i].id,a[pos].id);\n\t\tinsert(a[pos].id,a[i].id);\n\t\t//sz=N+a[fa]-a[i].val\n\t} dfs(1,0); dfs2(1,0);\n\tfor(LL i=1;i<=top;i++) printf(\"%lld %lld\\n\",s1[i],s2[i]); \n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// Peace Of SHIT\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ntypedef pair<int, int> pii;\nconst int maxn = 1e5 + 5;\nint n, si[maxn];\nint sum = 0;\nvector<int> e[maxn];\npii d[maxn];\n\nvoid impossible() {\n\tcout << -1;\n\texit(0);\n}\n\nvoid dfs(int u, int x) {\n\tsum += x;\n\tfor(int i = 0; i < e[u].size(); i++) {\n\t\tdfs(e[u][i], x + 1);\n\t}\n}\n\nint32_t main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\td[i] = {a, i};\n\t}\n\tsort(d, d + n);\n\treverse(d, d + n);\n\t\n\tvector <pii> k (d, d + n);\n\t\n\tfor(int q = 0; q < n - 1; q++) {\n\t\tint leaf = d[q].second;\n\t\tint parD = d[q].first - (n - (2 * (si[leaf] + 1)));\n\t\tauto it = lower_bound(k.rbegin(), k.rend(), pii(parD, 0));\n//\t\tcout << \"PAR : \" <<it->first << \" : \" << parD << '\\n';\n\t\tif(it -> first != parD) {\n//\t\t\tcerr << \"AVALI\\n\";\n\t\t\timpossible();\n\t\t}\n\t\tint par = it -> second;\n\t\tsi[par] += si[leaf] + 1;\n\t\tif((si[leaf] + 1) * 2 > n) {\n//\t\t\tcout << \"DOVOMI\\n\";\n\t\t\timpossible();\n\t\t}\n\t\t//SEVOMI HAM MISHE D[I] ROOT OK E ?\n\t\te[par].push_back(leaf);\n\t}\n\tint D = d[n - 1].second;\n\tdfs(D, 0);\n\tif(sum != d[n - 1].first)\n\t\timpossible();\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < e[i].size(); j++)\n\t\t\tcout << i + 1 << \" \" << e[i][j] + 1 <<'\\n';\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef bool boolean;\n\nconst int N = 1e5 + 5;\n\n#define ll long long\n#define par pair<ll, int>\n\nint n;\npar a[N];\nint sz[N], uf[N];\nvector<pair<int, int>> E;\n\nint find(int x) {\n\treturn uf[x] == x ? x : (uf[x] = find(uf[x]));\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &a[i].first);\n\t\ta[i].second = i;\n\t\tsz[i] = 1;\n\t\tuf[i] = i;\n\t}\n\tsort(a + 1, a + n + 1);\n\tfor (int i = n; i > 1; i--) {\n\t\tll d = a[i].first;\n\t\tint p = a[i].second;\n\t\tint fa = lower_bound(a + 1, a + n + 1, par(d - n + (sz[p] << 1), 0)) - a;\n\t\tif (a[fa].first != d - n + (sz[p] << 1)) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(p) == find(fa = a[fa].second)) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsz[fa] += sz[p];\n\t\tE.emplace_back(p, fa);\n\t}\n\tfor (auto x : E)\n\t\tprintf(\"%d %d\\n\", x.first, x.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ln                '\\n'\n#define all(dat)           dat.begin(), dat.end()\n#define loop(i, to)        for (int i = 0; i < to; ++i)\n#define cont(i, to)        for (int i = 1; i <= to; ++i)\n#define circ(i, fr, to)    for (int i = fr; i <= to; ++i)\n#define foreach(i, dat)    for (__typeof(dat.begin()) i = dat.begin(); i != dat.end(); ++i)\n\ntypedef long long          num;\n\nusing namespace std;\n\nconst int nsz = 1e5;\nint n, rt, siz[nsz + 5];\nnum w[nsz + 5];\nmap<num, int> id, to;\nvector<int> g[nsz + 5];\nvector<pair<int, int>> ans;\n\nnum inline cmp(num a, num b) {\n    return a > b;\n}\n\nnum calc(int u = rt, int dep = 0) {\n    num res = dep;\n    for (int v : g[u]) {\n        res += calc(v, dep + 1);\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> n;\n    rt = n;\n    cont (i, n) {\n        cin >> w[i];\n        to[w[i]] = i;\n    }\n    fill(siz, siz + sizeof(siz) / sizeof(int), 1);\n    sort(w + 1, w + n + 1, cmp);\n    cont (i, n) {\n        id[w[i]] = i;\n    }\n    cout << ln;\n    cont (u, n) {\n        if (u == rt)  continue;\n        int v = id[w[u] - n + 2 * siz[u]];\n        if (!v) {\n            cout << -1 << ln;\n            return 0;\n        }\n        siz[v] += siz[u];\n        g[v].push_back(u);\n        ans.push_back({to[w[u]], to[w[v]]});\n    }\n    if (calc() != w[n]) {\n        cout << -1 << ln;\n        return 0;\n    }\n    for (pair<int, int> p : ans) {\n        cout << p.first << ' ' << p.second << ln;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> T gi() {\n\tT x = 0; bool f = 0; char c = getchar();\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar();\n\tif (c == '-') f = 1, c = getchar();\n\twhile (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn f ? -x : x;\n}\nconst int N = 1e5 + 10;\nint p[N], siz[N], X[N], Y[N], fa[N];\nint find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\nLL D[N];\nmap<LL, int> M;\nvector<int> e[N];\nbool cmp(int x, int y) { return D[x] > D[y]; }\nLL res;\nvoid dfs(int u, int ff) {\n\tsiz[u] = 1;\n\tfor (auto v : e[u])\n\t\tif (v != ff) {\n\t\t\tdfs(v, u);\n\t\t\tres += siz[v];\n\t\t}\n}\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n = gi<int>();\n\tfor (int i = 1; i <= n; i++)\n\t\tD[i] = gi<LL>(), M[D[i]] = i, p[i] = i;\n\tsort(p + 1, p + 1 + n, cmp);\n\tfor (int i = 1; i <= n; i++) siz[i] = 1, fa[i] = i;\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x = p[i];\t\t\n\t\tif (M.find(D[x] - n + 2 * siz[x]) == M.end()) continue;\n\t\tint y = M[D[x] - n + 2 * siz[x]];\n\t\tif (find(x) == find(y)) continue;\n\t\tfa[find(y)] = find(x);\n\t\tsiz[y] += siz[x]; X[++cnt] = x; Y[cnt] = y;\n\t\te[x].push_back(y); e[y].push_back(x);\n\t}\n\tdfs(1, 0);\n\tif (cnt < n - 1 || res != D[1])\n\t\tputs(\"-1\");\n\telse\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tprintf(\"%d %d\\n\", X[i], Y[i]);\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <assert.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 100005;\n\nint n;\nint cnt[MAXN];\nint ord[MAXN];\n\nll d[MAXN];\n\nvector<pair<int,int> > e;\n\nbool cmp(const int &a,const int &b)\n{\n\treturn d[a] < d[b];\n}\n\nint search(ll v)\n{\n\tint low = 1,high = n;\n\twhile (low < high)\n\t{\n\t\tint mid = (low + high) >> 1;\n\t\tif (d[ord[mid]] >= v)\n\t\t\thigh = mid;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\tif (d[ord[low]] == v)\n\t\treturn low;\n\treturn -1;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 1;i <= n;i++)\n\t{\n\t\tcin >> d[i];\n\t\tcnt[i] = 1;\n\t\tord[i] = i;\n\t}\n\tsort(ord + 1,ord + n + 1,cmp);\n\tfor (int i = n;i >= 2;i--)\n\t{\n\t\tint pos = search(d[ord[i]] - (n - cnt[ord[i]]) + cnt[ord[i]]);\n\t\tif (pos == -1 || pos == i)\n\t\t{\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\te.push_back(make_pair(ord[i],ord[pos]));\n\t\tcnt[ord[pos]] += cnt[ord[i]];\n\t}\n\tfor (int i = 0;i < e.size();i++)\n\t\tcout << e[i].first << ' ' << e[i].second << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#include <functional>\n#include <bitset>\n\n#define repeat(i,n) for (long long i = 0; (i) < (n); ++ (i))\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i] << '\\n'\n#define debugArrayP(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i].first<< \" \" << x[i].second << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\nconst ll INF = LLONG_MAX/10;\nconst ll MOD = 1e9+7;\n\nint main(){\n  int N;cin>>N;\n  vector<pair<ll,int>> D(N);\n  repeat(i,N){\n    cin >> D[i].first;\n    D[i].second = i+1;\n  }\n  sort(D.begin(),D.end());\n  vll n(N,1);\n  vector<vint> g(N);\n  vector<Pii> edges;\n  bool isok = true;\n  for(int i=N-1;i>0;i--){\n    debug(i);\n    ll S = D[i].first+2*n[i]-N;\n    int j = lower_bound(D.begin(),D.end(),pair<ll,int>(S,0))-D.begin();\n    if(j>=i || D[j].first != S){\n      isok = false;\n      break;\n    }\n    edges.push_back({D[i].second,D[j].second});\n    n[j]+=n[i];\n    g[j].push_back(i);\n  }\n  queue<pair<ll,int>> Q;\n  Q.push({0,0});\n  ll S=0;\n  while(!Q.empty()){\n    Pii p = Q.front();\n    Q.pop();\n    S+=p.first;\n    for(int u:g[p.second]){\n      Q.push({p.first+1,u});\n    }\n  }\n  isok &= S==D[0].first;\n  if(!isok){\n    cout <<-1<<endl;\n    return 0;\n  }\n  repeat(i,edges.size()){\n    cout << edges[i].first<<\" \"<<edges[i].second<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint main(void){\n\tll n; cin >> n; P a[n]; ll s[n]; fill(s, s+n, 1);\n\tfor(int i=0; i<n; i++) {cin >> a[i].first; a[i].second=i+1;}\n\tsort(a, a+n, greater<P>()); vector<P> v;\n\tbool ok = true; ll ss[n]; fill(ss, ss+n, 0);\n\n\tfor(int i=0; i<n-1 && ok; i++) {\n\t\tll p = a[i].first - n + 2 * s[i];\n\t\tif (n - 2 * s[i] <= 0) ok = false;\n\t\tll x = lower_bound(a+i+1, a+n, make_pair(p, 0), greater<P>()) - a-1 ;\n\t\t//if (x == n) ok = false;\n\t\tif (a[x].first != p) ok = false;\n\t\ts[x] += s[i]; ss[x] += ss[i] + s[i];\n\t\tll v1 = min(a[x].second, a[i].second);\n\t\tll v2 = max(a[x].second, a[i].second);\n\t\tv.push_back(make_pair(v1, v2));\n\t\t//cout << i << \" \" << x << \" \" << p << \" \" << s[x] << \" \" << ok << \" \" << a[x].first << endl;\n\t}\n\tif (ss[n-1] != a[n-1].first) ok = false;\n\tif (ok == false) {cout << -1 << endl; return 0;}\n\tsort(v.begin(), v.end());\n\tfor(P y:v){\n\t\tcout << y.first << \" \" << y.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int N;\n    cin >> N;\n\n    set<tuple<ll, int, int>> pieces;\n\n    vll ds(N);\n    for (int i = 0; i < N; i++) {\n        cin >> ds[i];\n        pieces.insert({ ds[i], 1, i });\n    }\n\n    vector<pair<int, int>> edges;\n    while (pieces.size() > 1) {\n        auto p = *pieces.rbegin();\n        ll match = get<0>(p) + 2 * get<1>(p) - N;\n        auto qi = pieces.lower_bound({ match, -1, -1 });\n        if (qi == pieces.end() || get<0>(*qi) != match) {\n            cout << -1 << endl;\n            return 0;\n        }\n        auto q = *qi;\n\n        edges.emplace_back(get<2>(p), get<2>(q));\n        tuple<ll, int, int> comb = { get<0>(q), get<1>(p) + get<1>(q), get<2>(q) };\n\n        pieces.erase(p);\n        pieces.erase(q);\n        pieces.insert(comb);\n    }\n\n    for (auto p : edges) {\n        cout << p.first + 1 << \" \" << p.second + 1 << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid err() {\n  cout << -1 << endl;\n  exit(0);\n}\nint main() {\n  int n;\n  cin >> n;\n  vector<pair<int, int>> di(n);\n  for (int i = 0; i < n; i++) {\n    int d;\n    cin >> d;\n    di[i] = {d, i};\n  }\n  sort(di.begin(), di.end());\n  vector<int> sz(n, 1), prt(n);\n  vector<pair<int, int>> edg;\n  for (auto it = prev(di.end()); it != di.begin(); it--) {\n    int d = it->first;\n    int i = it->second;\n    int prtv = d - n + 2 * sz[i];\n    auto jt = lower_bound(di.begin(), di.end(), make_pair(prtv, 0));\n    if (jt->first != prtv) err();\n    prt[i] = jt->second;\n    if (i == prt[i]) err();\n    sz[prt[i]] += sz[i];\n    edg.emplace_back(min(i, prt[i]), max(i, prt[i]));\n  }\n  sort(edg.begin(), edg.end());\n  for (auto const & e : edg) {\n    cout << e.first + 1 << ' ' << e.second + 1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<map>\n#include<cmath>\n#include<algorithm>\n#define N 100005\nusing namespace std;\nstruct with {\n\tint w;\n\tlong long d;\n} dt[N];\nmap<long long, int> chk;\nint n;\nint parent[N],subn[N];\nlong long d[N];\nlong long sum[N];\nbool cmp(with i, with j) {\n\treturn i.d < j.d;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tint i;\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &d[i]);\n\t\tdt[i].d = d[i]; dt[i].w = i;\n\t\tsubn[i] = 1;\n\t}\n\tsort(dt + 1, dt + 1 + n, cmp);\n\tsort(d + 1, d + 1 + n);\n\tfor (i = 1; i <= n; i++) chk[d[i]] = i;\n\tbool imp = false;\n\tfor (i = n ; i >= 2; i--) {\n\t\tint adjacent=0;\n\t\tadjacent = chk[d[i] - n + 2 * subn[i]];\n\t\tparent[i] = adjacent;\n\t\tsubn[adjacent]+=subn[i];\n\t\tif (parent[i] == 0 || parent[i]==i) {\n\t\t\timp = true; break;\n\t\t}\n\t}\n\timp = true;\n\tfor (i = n; i >= 2; i--) {\n\t\tint up = parent[i];\n\t\tsum[up] += sum[i] + subn[i];\n\t}\n\tif (sum[1] != d[1]) imp = true;\n\tif (imp) printf(\"-1\");\n\telse {\n\t\tfor (i = 2; i <= n; i++) {\n\t\t\tprintf(\"%d %d\\n\", dt[parent[i]].w,dt[i].w);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #includes {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define LET(x,a) __typeof(a) x(a)\n//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)\n#define ALL(c) (c).begin(), (c).end()\n#define MP make_pair\n\n#define EXIST(e,s) ((s).find(e)!=(s).end())\n\n#define RESET(a) memset((a),0,sizeof(a))\n#define SET(a) memset((a),-1,sizeof(a))\n#define PB push_back\n#define DEC(it,command) __typeof(command) it=command\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define debug_v(x) cerr << #x << \" = [\";REP(__ind,(x).size()){cerr << (x)[__ind] << \", \";}cerr << \"] (L\" << __LINE__ << \")\" << endl;\n\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\n\ntypedef long long Int;\ntypedef unsigned long long uInt;\ntypedef long double rn;\n\ntemplate<class T>\nT inf(){\n\treturn numeric_limits<T>::has_infinity?numeric_limits<T>::infinity():(numeric_limits<T>::max()/2);\n}\n\ntypedef pair<int,int> pii;\n\n/*\n#ifdef MYDEBUG\n#include\"debug.h\"\n#include\"print.h\"\n#endif\n*/\n// }}}\n\n\n//{{{ io\nFILE *file_in=stdin,*file_out=stdout;\n#define fin normal_in\n#define fout normal_out\n//const char fname[]=\"\";\n//FILE *fin=fopen(fname,\"r\"),*fout=fopen(fname,\"w\");\n#ifdef __MINGW32__\n#define LLD \"%I64d\"\n#define LLU \"%I64u\"\n#else\n#define LLD \"%lld\"\n#define LLU \"%llu\"\n#endif\nstruct NORMAL_IN{\n\tbool cnt;\n\tNORMAL_IN():cnt(true){}\n\toperator int() const {return cnt;}\n#define endl \"\\n\"\n\tNORMAL_IN& operator>>(int &n){cnt=fscanf(file_in,\"%d\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(unsigned int &n){cnt=fscanf(file_in,\"%u\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(long long &n){cnt=fscanf(file_in,LLD,&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(unsigned long long &n){cnt=fscanf(file_in,LLU,&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(double &n){cnt=fscanf(file_in,\"%lf\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(long double &n){cnt=fscanf(file_in,\"%Lf\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(char *c){cnt=fscanf(file_in,\"%s\",c)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(string &s){\n\t\ts.clear();\n\t\tfor(bool r=false;;){\n\t\t\tconst char c=getchar();\n\t\t\tif(c==EOF){ cnt=false; break;}\n\t\t\tconst int t=isspace(c);\n\t\t\tif(!r and !t)r=true;\n\t\t\tif(r){\n\t\t\t\tif(!t)s.push_back(c);\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\t\tNORMAL_IN& operator>>(vector<T> &v){\n\t\t\tint v_size = v.size();\n\t\t\tREP(i,v_size){\n\t\t\t\t*this>>v[i];\n\t\t\t}\n\t\t\treturn *this;\n\t\t}\n} normal_in;\n\nstruct NORMAL_OUT{\n\tNORMAL_OUT& operator<<(const int &n){fprintf(file_out,\"%d\",n);return *this;}\n\tNORMAL_OUT& operator<<(const unsigned int &n){fprintf(file_out,\"%u\",n);return *this;}\n\tNORMAL_OUT& operator<<(const long long &n){fprintf(file_out,LLD,n);return *this;}\n\tNORMAL_OUT& operator<<(const unsigned long long &n){fprintf(file_out,LLU,n);return *this;}\n\tNORMAL_OUT& operator<<(const double &n){fprintf(file_out,\"%lf\",n);return *this;}\n\tNORMAL_OUT& operator<<(const long double &n){fprintf(file_out,\"%Lf\",n);return *this;}\n\tNORMAL_OUT& operator<<(const char c[]){fprintf(file_out,\"%s\",c);return *this;}\n\tNORMAL_OUT& operator<<(const string &s){fprintf(file_out,\"%s\",s.c_str());return *this;}\n} normal_out;\nstruct ERR_OUT{\n\ttemplate<class T>\n\t\tERR_OUT& operator<<(const T &a){\n\t\t\tcerr<<\"\\x1b[7m\"<<a<<\"\\x1b[m\";\n\t\t\treturn *this;\n\t\t}\n} ferr;\n//}}}\n\n//{{{ Graph<Weight> g(size); addEdge(g,{src,dst},weight); matrix<Weight> A(n,m);\ntypedef int Node;\ntemplate<class Weight>\nstruct edge {\n\tint src, dst;\n\tWeight weight;\n\tint rev;\n\tedge(int src, int dst, Weight weight=1,int rev=-1) :\n\t\tsrc(src), dst(dst), weight(weight), rev(rev){ }\n};\ntemplate<class Weight>\nbool operator < (const edge<Weight> &e, const edge<Weight> &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\t\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n//typedef vector<edge> edges;\n//typedef vector<edges> Graph;\n \ntemplate<class Weight>\nstruct matrix:vector<vector<Weight> >{\n\tmatrix(const array<int,2> &a, Weight w=0):vector<vector<Weight> >(a[0],vector<Weight>(a[1],w)){}\n\tmatrix(const array<int,1> &a, Weight w=0):vector<vector<Weight> >(a[0],vector<Weight>(a[0],0)){}\n\tmatrix(){}\n};\n \ntemplate<class Weight>\nstruct graph:vector<vector<edge<Weight> > >{\n\tWeight inf{::inf<Weight>()};\n\tgraph(){}\n\tgraph(const int &n):vector<vector<edge<Weight> > >(n){}\n\tvoid _add_edge(int from, int to, Weight w, int rev=-1){\n\t\tif((int)this->size() < from + 1)this->resize(from + 1);\n\t\tthis->at(from).push_back(edge<Weight>(from,to,w,rev));\n\t}\n};\n//add bi-directional edge\ntemplate<class Weight>\nvoid addBiEdge(graph<Weight> &g, const pair<int,int> &e, Weight w=1){\n\tconst int &from = e.first, &to = e.second;\n\tg._add_edge(from,to,w,g[to].size());\n\tg._add_edge(to,from,w,g[from].size()-1);\n}\n//add directional edge\ntemplate<class Weight>\nvoid addEdge(graph<Weight> &g, const pair<int,int> &e, Weight w=1){\n\tconst int &from = e.first, &to = e.second;\n\tg._add_edge(from,to,w);\n}\n \ntypedef int Weight;\ntypedef edge<Weight> Edge;\ntypedef vector<edge<Weight> > Edges;\ntypedef graph<Weight> Graph;\ntypedef matrix<Weight> Matrix;\n \n#ifdef DEBUG\n#include\"graph/graphviz.h\"\n#endif\n//}}}\n\nInt N;\nvector<Int> D;\nGraph G;\n\nInt dfs(int u,int level = 0,int p = -1){\n\tInt ret = level;\n\tfor(auto &&e:G[u]){\n\t\tif(e.dst==p)continue;\n\t\tret += dfs(e.dst,level+1,u);\n\t}\n\treturn ret;\n}\n\nvoid solve(){\n\tvector<pii> e;\n//\tsort(ALL(D));\n//\treverse(ALL(D));\n\tvector<pair<Int,int> > vp;\n\tREP(i,D.size()){\n\t\tvp.push_back({D[i],i});\n\t}\n\tsort(ALL(vp));\n\treverse(ALL(vp));\n\tmap<Int,pair<int,int>> mp;//id, num of child\n\tREP(u,D.size()){\n\t\tmp[D[u]] = {u,1};\n\t}\n\tREP(t,D.size()-1){\n\t\tint i = vp[t].second;\n\t\tInt d = D[i];\n\t\tauto x = mp[d];\n\t\tInt d2 = d - (N - 2*x.second);\n\t\tauto it = mp.find(d2);\n\t\tif(it==mp.end()){\n\t\t\tfout<<-1<<endl;\n\t\t\treturn;\n\t\t}\n\t\tit->second.second+=x.second;\n\t\te.push_back({mp[d].first,it->second.first});\n\t}\n\tG.assign(N,Edges());\n\tfor(auto &&p:e){\n\t\taddBiEdge(G,{p.first,p.second});\n\t}\n\tint umin = vp[D.size()-1].second;\n\tInt k = dfs(umin);\n\tif(k!=D[umin]){\n\t\tfout<<-1<<endl;\n\t\treturn;\n\t}\n\tREP(i,e.size()){\n\t\tfout<<e[i].first+1<<\" \"<<e[i].second+1<<endl;\n\t}\n\treturn;\n}\n\n//{{{ main function\nint main(){\t\n\t\n\tfin >> N;\n\tD.assign(N-1+1,Int());\n\tfor(int i = 0 ; i <= N-1 ; i++){\n\t\tfin >> D[i];\n\t}\n\tsolve();\n\treturn 0;\n}\n//}}}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define llong long long\n#define pii pair<llong,int>\n#define fi first\n#define se second\n\nint n;\npii a[1000100];\nllong d[1000100];\nint siz[1000100];\nllong cd;\n\nstruct data{\n\tint to,nxt;\n}mp[2000200];\nint head[1000100],cnt;\nvoid link(int x,int y)\n{\n\tmp[++cnt].to=y;\n\tmp[cnt].nxt=head[x];\n\thead[x]=cnt;\n}\nstruct UFS{\n\tint fa[1000100];\n\tvoid reset(){for(int i=1;i<=n;++i)fa[i]=i;}\n\tint find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\n\tbool merge(int x,int y)\n\t{\n\t\tint fx=find(x),fy=find(y);\n\t\tif(fx==fy)return 1;\n\t\tfa[fx]=fy;\n\t\treturn 0;\n\t}\n}ufs;\nint ed[1000100][2];\nvoid dfs(int x,int fa,int nd)\n{\n\tcd+=nd;\n\tfor(int i=head[x];i;i=mp[i].nxt)\n\t\tif(mp[i].to!=fa)\n\t\t\tdfs(mp[i].to,x,nd+1);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)scanf(\"%lld\",&a[i].fi),a[i].se=i;\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;++i)d[i]=a[i].fi,siz[i]=1;\n\tufs.reset();\n\tfor(int i=n;i>1;--i)\n\t{\n//\t\tcout<<endl;\n//\t\tcout<<\"i: \"<<i<<endl;\n\t\tint np=a[i].se;\n\t\tllong nd=d[i]+siz[np]-(n-siz[np]);\n\t\tint p=lower_bound(d+1,d+n+1,nd)-d;\n\t\tif(d[p]!=nd)puts(\"-1\"),exit(0);\n\t\tp=a[p].se;\n//\t\tcout<<\"np: \"<<np<<\" siz: \"<<siz[np]<<\" d: \"<<d[i]<<\" nd: \"<<nd<<\" p: \"<<p<<endl;\n\t\tlink(p,np);link(np,p);\n\t\ted[i-1][0]=p,ed[i-1][1]=np;\n\t\tsiz[p]+=siz[np];\n\t\tif(ufs.merge(np,p))puts(\"-1\"),exit(0);\n\t}\n\tdfs(a[1].se,0,0);\n\tif(cd!=d[1])puts(\"-1\"),exit(0);\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",ed[i][0],ed[i][1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Code By H~S~C\n// 男 ♂男 ♂男 ♂男\n\n//#define __FILE_JUDGE\n#define __SINGLE_TEST\n//#define __MUlTIPUL_TEST\n\n#ifdef ONLINE_JUDGE\n#define __ONLINE_OPTIMIZE\n#define __OPEN_STACK\n#define __FAST_ALLOCATOR\n#endif\n#ifndef ONLINE_JUDGE\n#define __DEBUG\n#endif\n#define MBYTES 256\n#define HBYTES (MBYTES <= 200 ? MBYTES / 2 : 100)\n#define MEMORY_LIMIT (MBYTES - HBYTES) * 1000000\n#ifdef __OPEN_STACK\n#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#endif\n#ifdef __ONLINE_OPTIMIZE\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n#endif\n\n#define _CRT_SECURE_NO_WARNINGS\n#include <immintrin.h>\n#include <emmintrin.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <chrono>\n#include <random>\n#include <tuple>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <utility>\n#include <cstdint>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <vector>\n#include <memory>\n#include <bitset>\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\nusing namespace std;\n#include <ext/rope>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/hash_policy.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\ntemplate <typename T, typename Comp = less <T>, typename Heap_tag = __gnu_pbds :: pairing_heap_tag>\nusing Priority_queue = __gnu_pbds :: priority_queue <T, Comp, Heap_tag>;\ntemplate <typename Key, typename Value>\nusing hashmap = __gnu_pbds :: gp_hash_table <Key, Value>;\ntemplate <typename T, typename Comp = less <T> >\nusing ordered_set = __gnu_pbds :: tree <T, __gnu_pbds :: null_type,\n\t\t\tComp, __gnu_pbds :: rb_tree_tag, __gnu_pbds :: tree_order_statistics_node_update>;\n\n#ifdef __FAST_ALLOCATOR\nstatic char __allocator_space__[MEMORY_LIMIT];\nstatic char *__sp = __allocator_space__;\ntemplate <typename T>\nstruct fastalloc : allocator <T> {\n\tfastalloc() { }\n\ttemplate <typename T2>\n\tfastalloc(const fastalloc <T2> &a) { }\n\ttemplate <typename T2>\n\tfastalloc <T> &operator = (const fastalloc <T2> &a) {\n\t\treturn *this;\n\t}\n\ttemplate <typename T2>\n\tstruct rebind {\n\t\ttypedef fastalloc <T2> other;\n\t};\n\tinline T* allocate(size_t n) {\n\t\tT *result = (T*)__sp;\n\t\t__sp += n * sizeof(T);\n\t\treturn result;\n\t}\n\tinline void deallocate(T* p, size_t n) { }\n};\n#endif\n#define rep(i, n) for (int i = 0; i < (n); ++ i)\n#define rep1(i, n) for (int i = 1; i <= (n); ++ i)\n#define Rep(i, a, b) for (int i = (a); i <= (b); ++ i)\n#define per(i, n) for (int i = (n) - 1; i >= 0; -- i)\n#define per1(i, n) for (int i = (n); i >= 1; -- i)\n#define Per(i, a, b) for (int i = (b); i >= (a); -- i)\n#define repit(it, a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it ++)\n#define foreach(it, a) for (auto &it: a)\n#define MP make_pair\n#define MT make_tuple\n#define All(a) a.begin(), a.end()\n#define SZ(a) ((int)a.size())\n#define sqr(s) ((s) * (s))\n#define fillset(a, val) memset(a, val, sizeof(a))\n#define fi first\n#define se second\n#define endl '\\n'\n#define limit_max(x) (numeric_limits <x> :: max())\n#define FILEOPEN(f)                            \\\n        freopen(f\".in\", \"r\", stdin);           \\\n        freopen(f\".out\", \"w\", stdout)\n#define y0 y19260817\n#define y1 y19268107\n#define j0 j19260817\n#define j1 j19268107\n#define x0 x19260817\n#define x1 x19268107\n#ifdef __FAST_ALLOCATOR\n#define _(a, b) a <b, fastalloc <b> >\n#define __(a, b) a <b, less <b>, fastalloc <b> >\n#define ___(a, b, c) a <b, c, fastalloc <b> >\n#define ____(a, b, c) a <b, c, less <c>, fastalloc <pair <b, c> > >\n#define _____(a, b, c, d) a<b, c, d, fastalloc <pair <b, c> > >\n#else\n#define _(a, b) a <b>\n#define __(a, b) a <b, less <b> >\n#define ___(a, b, c) a <b, c>\n#define ____(a, b, c) a <b, c, less <c> >\n#define _____(a, b, c, d) a<b, c, d>\n#endif\n#define $ int\n#define I int\n#define P pii\n#define V vector\n#define STK stack\n#define Q queue\n#define DQ deque\n#define ST set\n#define MS multiset\n#define M map\n#define HS unordered_set\n#define MH unordered_multiset\n#define HM unordered_map\n#define BT bitset\n#define L list\n#define FE for_each\n#define SO sort\n#define UQ unique\n#define LB lower_bound\n#define UB upper_bound\n#define TP tuple\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long long llong;\ntypedef unsigned long long ullong;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef ullong hash_type;\n\n#ifndef __DEBUG\n#define Debug(...)\n#else\ntemplate <typename T> inline void _debug(const char *names, T &&t) {\n\t(cerr << names << \" = \" << t << endl).flush();\n}\ntemplate <typename T1, typename ...T>\ninline void _debug(const char *names, T1 &&t1, T &&... t) {\n\tconst char *comma = strchr(names, ',');\n\t(cerr.write(names, comma - names) << \" = \" << t1 << \", \").flush();\n\t_debug(comma + 1, t ...);\n}\n#define Debug(...) _debug(#__VA_ARGS__, __VA_ARGS__)\n#endif\n\nstruct custom_hash {\n\tstatic uint64_t splitmix64(uint64_t x) {\n\t\tx += 0x9e3779b97f4a7c15;\n\t\tx = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n\t\tx = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n\t\treturn x ^ (x >> 31);\n\t}\n\tsize_t operator()(uint64_t x) const {\n#if __cplusplus >= 201103L\n\t\tstatic const uint64_t FIXED_RANDOM = chrono :: steady_clock :: now().time_since_epoch().count();\n#else\n\t\tstatic const uint64_t FIXED_RANDOM = time(NULL);\n#endif\n\t\treturn splitmix64(x + FIXED_RANDOM);\n\t}\n};\ntemplate <typename T>\nusing hash_set = unordered_set <T, custom_hash>;\ntemplate <typename T, typename K>\nusing hash_map = unordered_map <T, K, custom_hash>;\n\ntemplate <typename T>\ninline T chmax(T &x, T y) { return x = max(x, y); }\ntemplate <typename T>\ninline T chmin(T &x, T y) { return x = min(x, y); }\ntemplate <typename T>\ninline T readin() { T a; cin >> a; return a; }\ntemplate <typename T>\ninline void reinit(T &t) { t.~T(); new (&t) T(); }\ninline void R() { } inline void W() { }\ntemplate <typename T> inline void R(T &x) { cin >> x; }\ntemplate <typename T> inline void W(const T &x) { cout << x; }\ntemplate <typename T, typename U>\ninline void W(const pair <T, U> &x) { W(x.F); cout.put(' '); W(x.S);}\ntemplate <typename It>\ninline void _W(It a, It b) {\n\tchar flag = 0;\n\twhile (a != b) {\n\t\tflag && (cout.put(' '), 0);\n\t\tW(*a ++), flag = 1;\n\t}\n}\ntemplate <typename T, typename ...U>\ninline void R(T &head, U &...tail) { R(head); R(tail...); }\ntemplate <typename T, typename ...U>\ninline void W(const T &head, const U &...tail) { W(head); cout << (sizeof...(tail) ? \" \" : \"\"); W(tail...); }\n#define Wl(...) do { W(__VA_ARGS__), cout.put('\\n'); } while (0)\n#define _Wl(...) do { _W(__VA_ARGS__), cout.put('\\n'); } while (0)\n\nconst int inf = 0x3f3f3f3f;\nconst ll lnf = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-9, PI = acos(-1.0);\nconst int mod1 = 1000000007, mod2 = 998244353;\nmt19937 __random_gen(time(NULL));\n\nbool solve(const signed &CASENUM);\nsigned main(int argc, const char *argv[]) {\n#ifdef ONLINE_JUDGE\n\tcerr << \"Program by H~S~C: \\n\";\n#endif\n#ifdef __FILE_JUDGE\n\tFILEOPEN(__FILE__);\n#endif\n\tios_base :: sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\tcout << fixed << setprecision(12);\n\t//cout << setfill('0');\n#ifdef __SINGLE_TEST\n\tsolve(1);\n#elif defined(__MUlTIPUL_TEST)\n\tint Tests = 1;\n\twhile (!solve(Tests ++));\n#else\n\tint Tests, Test;\n\tcin >> Tests;\n\tfor (Test = 1; Test <= Tests; ++ Test)\n\t\tsolve(Test);\n#endif\n\treturn 0;\n}\n// TODO XXX starts HERE!!\n\nint n;\nll d[100005];\nset <ll> s;\nvector <int> g[100005];\nmap <ll, int> ind;\nbool solve(const signed &CASENUM) {\n\tR(n);\n\trep1(i, n) {\n\t\tR(d[i]), ind[d[i]] = i;\n\t\ts.insert(d[i]);\n\t}\n\tint pos = ind[*s.begin()];\n\ts.erase(s.begin());\n\twhile (!s.empty()) {\n\t\tauto it = -- s.end();\n\t\tlong long x = *it;\n\t\tint id = ind[x];\n\t\tint del = n - 2;\n\t\twhile (true) {\n\t\t\ts.erase(x);\n\t\t\tx -= del, del -= 2;\n\t\t\tint now = -1;\n\t\t\tif (!s.count(x)) break;\n\t\t\tnow = ind[x];\n\t\t\tg[now].push_back(id);\n\t\t\tid = now;\n\t\t}\n\t\tif (x != d[pos]) {\n\t\t\tputs(\"-1\");\n\t\t\treturn false;\n\t\t}\n\t\tg[pos].push_back(id);\n\t}\n\trep1(i, n)\n\t\tfor (auto &v: g[i])\n\t\t\tWl(i, v);\n\treturn false;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Be Name Khoda, Besmellah Rahmane Rahim, In The Name Of God;\n//#include<bits/stdc++.h>\n#include<iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <deque>\n#include <map>\n#include <stack>\n#include<bitset>\n#include<list>\n#include<cassert>\n#include<numeric>\n#include <stdio.h>\n#include <string.h>\n#include<iomanip>\n#include<unordered_map>\n#include<unordered_set>\n#include <fstream>\n\nusing namespace std;\n\nconst long long N = 1e5 + 5;\nlong long n;\nset< pair<long long, long long> > s;\nvector<long long> graph[N];\nlong long cnt[N];\nlong long par[N];\nlong long root, maxi;\nvector< pair<long long, long long> > edge;\nlong long check = 0;\n\nvoid dfs(long long v, long long par = -1, long long h = 0)\n{\n    check += h;\n    for (auto u: graph[v])\n    {\n        if (u != par)\n        {\n            edge.push_back({v, u});\n            dfs(u, v, h + 1);\n        }\n    }\n}\n\n\nint main() \n{\n    cin >> n;\n    for (long long i = 0; i < n; i++)\n    {\n        long long tmp;\n        cin >> tmp;\n        s.insert({-tmp, i});\n    }\n    while (s.size())\n    {\n        /*\n        for (auto u: s)\n        {\n            cout << \"(\" << -u.first << \", \" << u.second << \") \";\n        }\n        cout << endl;\n        */\n        auto p = (*s.begin());\n        s.erase(s.begin());\n        long long v = p.second;\n        long long w = p.first;\n        w = -w;\n        cnt[v]++;\n        long long tmp = w + cnt[v] - (n - cnt[v]);\n        if (s.size())\n        {\n            auto nei = s.lower_bound({-tmp, -1});\n            //cout << (*nei).first << \" \" << (*nei).second << endl;\n            if (nei == s.end() || (*nei).first != -tmp)\n            {\n                cout << -1 << endl;\n                exit(0);\n            }\n            par[v] = (*nei).second;\n            //cout << v << \" \" << par[v] << endl;\n            cnt[(*nei).second] += cnt[v];\n        }\n        else\n        {\n            root = v;\n            maxi = w;\n        }\n    }\n    for (long long i = 0; i < n; i++)\n    {\n        if (i == root)\n        {\n            continue;\n        }\n        graph[i].push_back(par[i]);\n        graph[par[i]].push_back(i);\n    }\n    dfs(root);\n    if (check != maxi)\n    {\n        cout << -1 << endl;\n        exit(0);\n    }\n    for (long long i = 0; i < n - 1; i++)\n    {\n        cout << edge[i].first + 1 << \" \" << edge[i].second + 1 << endl;\n    }\n    \n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\npair<ll,int> p[100010],q[100010];\nmap<ll,vector<pair<int,int>>> mp;\nvector<pair<int,int>> ans;\nvector<int> G[100010];\nll d[100010],j[100010],e[100010],n;\nint dfs(int s,int p){\n\tint res = 1;\n\tfor(int v: G[s]){\n\t\tif(v!=p){\n\t\t\td[v] = d[s] + 1;\n\t\t\tres += dfs(v,s);\n\t\t}\n\t}\n\treturn j[s] = res;\n}\n\nvoid solve(int s, int p, ll val){\n\tfor(int v:G[s]){\n\t\tif(v!=p){\n\t\t\te[v] = val + n - 2*j[v];\n\t\t\tsolve(v,s,e[v]);\n\t\t}\n\t}\n}\n\nint main(){\n\tint i;\n\tcin >> n;\n\tfor(i=0;i<n;i++){\n\t\tll d; cin >> d;\n\t\tp[i] = {d,i};\n\t}\n\tsort(p,p + n);\n\tfor(i=n-1;i>=0;i--){\n\t\tif(mp.find(p[i].first)==mp.end()){\n\t\t\tmp[p[i].first - n + 2].push_back({p[i].second,1});\n\t\t}else{\n\t\t\tint sum = 1;\n\t\t\tfor(auto x:mp[p[i].first]){\n\t\t\t\tsum += x.second;\n\t\t\t\tans.push_back({x.first,p[i].second});\n\t\t\t}\n\t\t\tmp[p[i].first - n + 2*sum].push_back({p[i].second,sum});\n\t\t}\n\t}\n\tif(ans.size()==n-1){\n\t\tfor(i=0;i<n;i++) d[i] = -1;\n\t\tfor(i=0;i<n-1;i++){\n\t\t\tint f = ans[i].first,s = ans[i].second;\n\t\t\tG[f].push_back(s); G[s].push_back(f);\n\t\t}\n\t\td[0] = 0; dfs(0,-1);\n\t\tll m = 0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tif(d[i]==-1){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tm += d[i];\n\t\t}\n\t\te[0] = m; solve(0,-1,m);\n\t\tfor(i=0;i<n;i++){\n\t\t\tq[i] = {e[i],i};\n\t\t}\n\t\tsort(q,q + n);\n\t\tfor(i=0;i<n;i++){\n\t\t\tif(p[i]!=q[i]){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<ans.size();i++){\n\t\t\tcout << ans[i].first + 1 << \" \" << ans[i].second + 1 << \"\\n\";\n\t\t}\n\t}else{\n\t\tcout << -1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pii_ pair<int,int>\n#define mp_ make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define show1(a) cout<<#a<<\" = \"<<a<<endl\n#define show2(a,b) cout<<#a<<\" = \"<<a<<\"; \"<<#b<<\" = \"<<b<<endl\nusing namespace std;\nconst ll INF = 1LL<<60;\nconst int inf = 1<<30;\nconst int maxn = 1e5+5;\ninline void fastio() {ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);}\nvoid GG()\n{\n    cout<<-1<<endl;\n    exit(0);\n}\nint n,sz[maxn];\nstruct node\n{\n    int id;\n    ll d;\n    bool operator < (const node e) const {\n        return d>e.d;\n    }\n}tr[maxn];\nvector<pii_> e;\nint main()\n{\n    fastio();\n    cin>>n;\n    rep(i,1,n){\n        cin>>tr[i].d; tr[i].id = i;\n    }\n    sort(tr+1,tr+n+1);\n    rep(i,1,n) sz[i] = 1;\n    rep(i,1,n){\n        ll dfa = tr[i].d+2*sz[tr[i].id]-n;\n        if(lower_bound(tr+1,tr+n+1,(node){0,dfa}) == tr+n+1) GG(); // 找不到父节点\n        node fa = *lower_bound(tr+1,tr+n+1,(node){0,dfa});\n        if(fa.d!=dfa || fa.id==tr[i].id) GG();    // 找不到父节点\n        sz[fa.id] += sz[tr[i].id];\n        if(fa.id!=tr[n].id && sz[fa.id]>n/2) GG();   // 以重心为根，其他节点的子树大小不能超过n的一般\n        e.pb(mp_(tr[i].id,fa.id));\n    }\n    for(auto x:e){\n        cout<<x.fi<<\" \"<<x.se<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define IL inline\n#define _ 1000005\n#define ll long long\nusing namespace std ;\n\nIL ll gi(){\n\tll data = 0 , m = 1; char ch = 0;\n\twhile(ch!='-' && (ch<'0'||ch>'9')) ch = getchar();\n\tif(ch == '-'){m = 0 ; ch = getchar() ; }\n\twhile(ch >= '0' && ch <= '9'){data = (data<<1) + (data<<3) + (ch^48) ; ch = getchar(); }\n\treturn (m) ? data : -data ; \n}\n\nll fa[_],sz[_],m,n,d[_],f[_],g[_] ; \nstruct Item{int id , dis ; } t[_] ; \n\nstruct _Edge{int to,next,w ; }Edge[_<<1] ; int head[_],CNT ;  \nIL void AddEdge(int u , int v) {\n    Edge[++CNT] = (_Edge){v , head[u]} ; head[u] = CNT ; \n    return ;  \n}\n\nIL bool cmp1(Item A , Item B){\n\treturn (A.dis ^ B.dis) ? A.dis < B.dis : A.id < B.id ;  \n}\nIL bool cmp2(Item A , Item B){\n\treturn (A.id ^ B.id) ? A.id < B.id : A.dis < B.dis ;  \n}\n\nvoid dfs1(int u , int From) {\n    sz[u] = 1ll ;\n    for(int e = head[u] ; e ; e = Edge[e].next) {\n        int v = Edge[e].to ; if(v == From) continue ; \n        dfs1(v , u) ;\n        f[u] += f[v] + sz[v] ; \n        sz[u] += sz[v] ;  \n    }\n    return ; \n}\nvoid dfs2(int u , int From) {\n    for(int e = head[u] ; e ; e = Edge[e].next) {\n        int v = Edge[e].to ; if(v == From) continue ; \n        g[v] = f[u] + g[u] - (f[v] + sz[v]) + (n - sz[v]) ; \n        dfs2(v , u) ; \n    }\n    return ; \n}\n\nint main() {\n\tn = gi() ;\n\tfor(int i = 1; i <= n; i ++) t[i].id = i , t[i].dis = gi() ;\n\tsort(t + 1 , t + n + 1 , cmp1) ;\n\tfor(int i = 1; i <= n; i ++) d[i] = t[i].dis ; \n\td[n + 1] = 1e9 ;  \n\tfor(int i = n; i > 1; i --) {\n\t\tint u = t[i].id ; \n\t\tsz[u] ++ ; \n\t\tll ds = t[i].dis + 2ll * sz[u] - n ;\n\t\tll ps = lower_bound(d + 1 , d + n + 2 , ds) - d ;\n\t\tif(ps >= i || t[ps].dis != ds) return puts(\"-1\") , 0 ;\n\t\tfa[u] = t[ps].id ;\n\t\tsz[t[ps].id] += sz[u] ; \n\t}\n\tsort(t + 1 , t + n + 1 , cmp2) ; \n\tfor(int i = 1; i <= n; i ++) if(fa[i]) AddEdge(fa[i],i) , AddEdge(i,fa[i]) ; \n\tdfs1(1 , 0) ; \n\tdfs2(1 , 0) ; \n\t//for(int i = 1; i <= n; i ++)\n\t//    printf(\"f[%d] = %lld  ;  g[%d] = %lld\\n\",i,f[i],i,g[i]) ;\n\tfor(int i = 1; i <= n; i ++) if(f[i]+g[i] != t[i].dis) return puts(\"-1\") , 0 ;\n\tfor(int i = 1; i <= n; i ++) if(fa[i]) cout << fa[i] << \" \" << i << endl ;\n\treturn 0 ; \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#define Maxn 1000008 \nusing namespace std;\ntypedef long long ll;\n\nint n;\nll d;\nll son[Maxn];\nmap <ll,ll> M;\n\nstruct node{\n\tll num;\n\tll val;\n}N[Maxn];\n\nbool cmp(node a,node b){\treturn a.val > b.val;}\n\nint main()\n{\n\tmemset(son,0,sizeof(son));\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\tscanf(\"%lld\",&d);\n\t\tM[d] = i;\n\t\tN[i].num = i,N[i].val = d;\n\t}\n\tsort(N+1,N+1+n,cmp);\n\tmap<ll,ll>::iterator iter;;\n\tfor(int i = 1;i < n;i ++)\n\t{\n\t\tll u = N[i].num;\n\t\tif((N[i].val - n + 2 + (son[u] << 1)) < N[n].val) continue;\n\t\titer = M.find(N[i].val - n + 2 + (son[u] << 1));\n\t\tif(iter == M.end()) continue;\n\t\tll v = iter->second;\n\t\tson[v] += son[u]+1;\n\t\tprintf(\"%lld %lld\\n\",u,v);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct union_find{\n\tstatic const int DEFAULT = 200200;\n\tvector<int> parent;\n\tint N;\n\tunion_find(int N = DEFAULT) : N(N) {\n\t\tclear();\n\t}\n\tvoid clear(){\n\t\tparent.assign(N, -1);\n\t}\n\tint find(int u){\n\t\treturn (parent[u] < 0) ? u : parent[u] = find(parent[u]);\n\t}\n\tbool is_connected(int u, int v){\n\t\treturn find(u) == find(v);\n\t}\n\tbool join(int u, int v){\n\t\tu = find(u);\n\t\tv = find(v);\n\t\tif (u != v){\n\t\t\tif (parent[u] > parent[v])\n\t\t\t\tswap(u, v);\n\t\t\tparent[u] += parent[v];\n\t\t\tparent[v] = u;\n\t\t}\n\t\treturn u != v;\n\t}\n\tint size(int u){\n\t\treturn -parent[find(u)];\n\t}\n};\nint main(){\n\tint n; cin >> n;\n\tvector<pair<long long, int> > vals;\n\tmap<long long, int> rev;\n\tunion_find uf(n);\n\tlong long sum = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tlong long x; cin >> x;\n\t\trev[x] = i;\n\t\tvals.push_back({x, i});\n\t\tsum += x;\n\t}\n\tif(sum&1){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tvector<pair<int,int> > edges;\n\tsort(vals.rbegin(), vals.rend());\n\tfor(int i = 0; i < n - 1; i++){\n\t\tlong long cost; int u;\n\t\ttie(cost, u) = vals[i];\n\t\tint sz = uf.size(u);\n\t\tlong long ncost = cost - n + 2 * sz;\n\t\tauto it = rev.find(ncost); \n\t\tif(it == rev.end()){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint x = u, y = it->second;\n\t\tif(x == y){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(x > y) swap(x, y);\n\t\tedges.push_back({x, y});\n\t\tif(!uf.join(x, y)){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\t\n\t}\n\tsort(edges.begin(), edges.end());\n\tfor(auto e : edges) cout << e.first + 1 << \" \" << e.second + 1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=1e5+5;\nusing namespace std;\nstruct Edge{int x,y;}e[N];\nstruct Node{\n\tlong long d;int id;\n\tbool operator <(const Node &b)const{return d<b.d;}\n}d[N];\nint n,cnt;\nint size[N];\nlong long dis;\nint main(){\n\t\n\tregister int i,x;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i)\n\t\tscanf(\"%d\",&x),d[i].d=x,d[i].id=i,size[i]=1;\n\tsort(d+1,d+n+1);\n\tfor(i=n;i>=2;--i){\n\t\tlong long t=d[i].d-n+size[i]*2;\n\t\tint pos=lower_bound(d+1,d+n+1,(Node){t,0})-d;\n\t\tif(d[pos].d!=t) return puts(\"-1\"),0;\n\t\te[++cnt]=(Edge){d[i].id,d[pos].id};\n\t\tsize[pos]+=size[i];\n\t\tdis+=size[i];\n\t}\n\tif(dis!=d[1].d) puts(\"-1\");\n\telse\n\t\tfor(i=1;i<=cnt;++i)\n\t\t\tprintf(\"%d %d\\n\",e[i].x,e[i].y);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// sync\n\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <map>\n\ntypedef long long ll;\nconst int N = 1e5 + 51;\nstruct edge {\n\tint to, next;\n} e[N << 1];\nint head[N], cnt;\nvoid addedge(int x, int y) {\n\te[++cnt] = (edge){y, x[head]}, x[head] = cnt;\n\te[++cnt] = (edge){x, y[head]}, y[head] = cnt;\n}\n\nll ans;\nvoid dfs(int x, int p, int d) {\n\tans += d;\n\tfor (int i = x[head], nx; i; i = e[i].next)\n\t\tif ((nx = e[i].to) != p) dfs(nx, x, d + 1);\n}\n\nint p[N];\nint f(int x) { return x[p] ? x[p] = f(x[p]) : x; }\nvoid l(int x, int y) {\n\tif ((x = f(x)) != (y = f(y))) x[p] = y;\n}\n\nstd::map<ll, int> mp;\nint n, sz[N];\nll a[N];\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", a + i), i[sz] = 1, mp[a[i]] = i;\n\tstd::sort(a + 1, a + n + 1, std::greater<ll>());\n\tfor (int i = 1; i < n; i++) {\n\t\tint x = mp[a[i]], nx;\n\t\tll tmp = a[i] - n + 2 * x[sz];\n\t\tif (tmp >= a[i] || !mp.count(tmp)) return puts(\"-1\"), 0;\n\t\tnx = mp[tmp];\n\t\tnx[sz] += x[sz];\n\t\tif (f(x) == f(nx)) return puts(\"-1\"), 0;\n\t\taddedge(x, nx);\n\t\tl(x, nx);\n\t}\n\tdfs(mp[a[1]], 0, 0);\n\tif (ans != a[1]) return puts(\"-1\"), 0;\n\tfor (int i = 1; i <= cnt; i += 2) printf(\"%d %d\\n\", e[i + 1].to, e[i].to);\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author zjsdut\n */\n\n#ifndef ALGO_UTILS\n#define ALGO_UTILS\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <vector>\ntemplate<typename A, typename B>\nbool chkmin(A &a, const B &b) {\n  if (b < a) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate<typename A, typename B>\nbool chkmax(A &a, const B &b) {\n  if (b > a) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing vl = std::vector<ll>;\nusing vb = std::vector<bool>;\nusing vi = std::vector<int>;\nusing pii = std::pair<int, int>;\nusing pli = std::pair<ll, int>;\nusing pil = std::pair<int, ll>;\nusing pll = std::pair<ll, ll>;\nusing vpii = std::vector<pii>;\ntemplate<typename T>\nclass vv {\n  std::vector<std::vector<T>> data;\n\n public:\n  vv(int n, int m, T init = T{}) {\n    assert(n > 0 && m > 0);\n    data.assign(n, std::vector<T>(m, init));\n  }\n  std::vector<T> &operator[](size_t i) { return data[i]; }\n};\n#define rng3(i, a, b) for (std::common_type<decltype(a), decltype(b)>::type i = a; i < b; ++i)\n#define rng2(i, n) rng3(i, 0, n)\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define rng(...) GET_MACRO(__VA_ARGS__, rng3, rng2)(__VA_ARGS__)\n#define up(i, a, b) for (std::common_type<decltype(a), decltype(b)>::type i = a; i <= b; ++i)\n#define down(i, b, a) for (std::common_type<decltype(a), decltype(b)>::type i = b; i >= a; i--)\n#define TOKENPASTE(x, y) x##y\n#define TOKENPASTE2(x, y) TOKENPASTE(x, y)\n#define rep(n)                                                                                     \\\n  for (int TOKENPASTE2(_iter_, __LINE__) = 0, TOKENPASTE2(_num_, __LINE__) = n;                    \\\n       TOKENPASTE2(_iter_, __LINE__) < TOKENPASTE2(_num_, __LINE__);                               \\\n       ++TOKENPASTE2(_iter_, __LINE__))\n#define FOR(x, cont) for (const auto &x : cont)\n#define For(x, cont) for (auto &x : cont)\n#define ALL(x) begin(x), end(x)\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ep emplace\n#define SZ(x) (int) (x).size()\n#define UNIQ(vec) (vec).erase(std::unique(ALL(vec)), std::end(vec))\n#define LB(cont, x) int(std::lower_bound(ALL(cont), x) - std::begin(cont))\n#define UB(cont, x) int(std::upper_bound(ALL(cont), x) - std::begin(cont))\ntemplate<typename T, typename U = std::less<T>>\nusing pq = std::priority_queue<T, std::vector<T>, U>;\ntemplate<typename T>\nstruct reversion_wrapper {\n  T &iterable;\n};\ntemplate<typename T>\nauto begin(reversion_wrapper<T> w) {\n  return std::rbegin(w.iterable);\n}\ntemplate<typename T>\nauto end(reversion_wrapper<T> w) {\n  return std::rend(w.iterable);\n}\ntemplate<typename T>\nreversion_wrapper<T> reverse(T &&iterable) {\n  return {iterable};\n}\ntemplate<typename T, typename U>\nT ceil(T x, U y) {\n  assert(y > 0);\n  if (x > 0) x += y - 1;\n  return x / y;\n}\n\ntemplate<typename T, typename U>\nT floor(T x, U y) {\n  assert(y > 0);\n  if (x < 0) x -= y - 1;\n  return x / y;\n}\n#endif\n#ifndef JHELPER_EXAMPLE_PROJECT_LIBRARY_IO_HPP_\n#define JHELPER_EXAMPLE_PROJECT_LIBRARY_IO_HPP_\n#include <iostream>\n#include <iomanip>\n\nstruct fast_ios {\n  fast_ios() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n    std::cout << std::fixed << std::setprecision(10);\n  };\n} fast_ios_;\n\ntemplate<typename T>\nstd::istream &operator>>(std::istream &stream, std::vector<T> &vec) {\n  for (auto &x : vec)\n    stream >> x;\n  return stream;\n}\n\ntemplate<typename T, typename U>\nstd::istream &operator>>(std::istream &in, std::pair<T, U> &p) {\n  in >> p.first >> p.second;\n  return in;\n}\n\nvoid scan() {}\n\ntemplate<class T, class... Args>\nvoid scan(T &a, Args &... rest) {\n  std::cin >> a;\n  scan(rest...);\n}\n\ntemplate<typename T>\nstd::ostream &operator<<(std::ostream &stream, const std::vector<T> &vec) {\n  bool first = true;\n  for (const T &t : vec) {\n    if (first) first = false;\n    else std::cout << ' ';\n    std::cout << t;\n  }\n  return stream;\n}\n\ntemplate<typename T, typename U>\nstd::ostream &operator<<(std::ostream &out, const std::pair<T,U> &p) {\n  out << p.first << ' ' << p.second;\n  return out;\n}\n\ntemplate<typename T>\nvoid print(const std::vector<std::vector<T>> &t) {\n  for (const auto &row : t) {\n    std::cout << row << '\\n';\n  }\n}\n\ntemplate<typename T>\nvoid print(const T &t) { std::cout << t << ' '; }\n\ntemplate<typename T, typename... Args>\nvoid print(const T &t, const Args &... rest) {\n  print(t);\n  print(rest...);\n}\n\ntemplate<typename T>\nvoid println(const T &t) { std::cout << t << '\\n'; }\n\ntemplate<typename T, typename... Args>\nvoid println(const T &t, const Args &... rest) {\n  print(t);\n  println(rest...);\n}\n#endif //JHELPER_EXAMPLE_PROJECT_LIBRARY_IO_HPP_\n\nusing namespace std;\nclass FDistanceSums {\npublic:\n  static void solve(istream&, ostream&) {\n    int n;\n    scan(n);\n    vi sz(n, 1);\n    map<ll,int> index;\n    rng (i,n) {\n      ll d;\n      scan(d);\n      index[d] = i;\n    }\n    vpii edges;\n    auto iter = index.rbegin();\n    rep (n - 1) {\n      ll d = iter->first;\n      int i = iter->second;\n      ll nd = d + 2 * sz[i] - n;\n      if (nd >= d) {\n        println(-1);\n        return;\n      }\n      auto iter2 = index.find(nd);\n      if (iter2 == index.end()) {\n        println(-1);\n        return;\n      }\n      sz[iter2->second] += sz[i];\n      edges.eb(i, iter2->second);\n      ++iter;\n    }\n    FOR (p, edges) {\n      println(p.first + 1, p.second + 1);\n    }\n  }\n};\n/*\n * Make sure that your laptop is plugged in or the build may be slow.\n */\n\n#define in std::cin\n#define out std::cout\nint main() {\n  FDistanceSums solver;\n  solver.solve(in, out);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\n\n\nint N;\nconstexpr int Nmax = 100000;\nvector<plint> D;\nvector<int> to[Nmax];\n\nplint dfs(int now, int prev)\n{\n    lint d = 0, subtreesz = 1;\n    for (auto nxt : to[now]) if (nxt != prev)\n    {\n        plint pa = dfs(nxt, now);\n        d += pa.first + pa.second;\n        subtreesz += pa.second;\n    }\n    return plint(d, subtreesz);\n}\n\nint main()\n{\n    cin >> N;\n    D.resize(N);\n    REP(i, N)\n    {\n        cin >> D[i].first;\n        D[i].second = i;\n    }\n\n    sort(D.begin(), D.end());\n\n    map<lint, vector<pint>> ma;\n\n    IREP(i, N)\n    {\n        lint Dnow, id_now;\n        tie(Dnow, id_now) = D[i];\n\n        int stsz = 1;\n        if (ma.count(Dnow))\n        {\n            for (auto pa : ma[Dnow])\n            {\n                to[id_now].push_back(pa.first);\n                to[pa.first].push_back(id_now);\n                stsz += pa.second;\n            }\n            ma.erase(Dnow);\n        }\n        ma[Dnow + 2 * stsz - N].push_back(pint(id_now, stsz));\n    }\n\n    vector<pint> res;\n    REP(s, N) for (auto t : to[s]) if (s < t) res.push_back(pint(s, t));\n\n    if (res.size() != N - 1 || dfs(D[0].second, -1).first != D[0].first) cout << -1 << endl, exit(0);\n    for (auto pa : res) cout << pa.first + 1 << \" \" << pa.second + 1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nnamespace IO\n{\n\tchar buf[1 << 20 | 1] , *f1 = buf , *f2 = buf , pbuf[1 << 24 | 1] , *f3 = pbuf , sta[100];\n\t#define gc() ((f1 == f2) && (f2 = (f1 = buf) + fread(buf,1,sizeof buf,stdin),f1 == f2) ? EOF : *f1 ++)\n\t#define gt() getchar()\n\tinline int read()\n\t{\n\t\tint x = 0 , f = 1; char ch = gt();\n\t\twhile(ch < '0' || ch > '9')\t{if(ch == '-')\tf = -1; ch = gt();}\n\t\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = gt();}\n\t\treturn x * f;\n\t}\n\ttemplate <class T> inline void write(T x)\n\t{\n\t\tif(!x) return (void)(*f3 ++ = 48 , *f3 ++ = ' ');\n\t\tif(x < 0) *f3 ++ = '-' , x = ~x + 1;\n\t\tchar *top = sta;\n\t\twhile(x) *top ++ = x % 10 + 48 , x /= 10;\n\t\twhile(top != sta) *f3 ++ = *-- top;\n\t\t*f3 ++ = ' ';\n\t}\n\tinline void put(std::string s)\n\t{\n\t\tint len = s.length();\n\t\tfor(int i = 0;i < len;i ++) *f3 ++ = s[i];\n\t\t*f3 ++ = ' ';\n\t}\n\tinline void endline() { *f3 ++ = '\\n';}\n\t#define flush() fwrite(pbuf,1,f3 - pbuf,stdout)\n\ttemplate <class T> inline T abs(T a) { return a < 0 ? -a : a;}\n\ttemplate <class T> inline T max(T a,T b) { return a > b ? a : b;}\n\ttemplate <class T> inline T min(T a,T b) { return a < b ? a : b;}\n\ttemplate <class T> inline void swap(T &a,T &b) { T t = a; a = b; b = t;}\n}\nusing namespace IO;\nconst int N = 1e5 + 5;\nint n , cnt;\nint size[N] , u[N] , v[N];\nll dis;\nll D[N];\nstruct node\n{\n\tll d; int id;\n\tnode(ll d = 0,int id = 0) : d(d) , id(id) {}\n\tfriend bool operator < (const node &a,const node &b) { return a.d < b.d;}\n} e[N];\nint main()\n{\n\tn = read();\n\tfor(int i = 1;i <= n;i ++) e[i] = node(read(),i) , size[i] = 1;\n\tstd::sort(e + 1,e + 1 + n);\n\tfor(int i = n;i > 1;i --)\n\t{\n\t\tll dfa = e[i].d + 2 * size[i] - n;\n\t\tint j = std::lower_bound(e + 1,e + 1 + n,node(dfa)) - e;\n\t\tif(e[j].d != dfa) return puts(\"-1\") , 0;\n\t\tu[++ cnt] = e[i].id; v[cnt] = e[j].id;\n\t\tsize[j] += size[i];\n\t\tdis += size[i];\n\t}\n\tif(dis != e[1].d) return puts(\"-1\") , 0;\n\telse for(int i = 1;i <= cnt;i ++) printf(\"%d %d\\n\",u[i],v[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define LL long long\n#define pii pair<LL, int>\nusing namespace std;\nconst int N = 1e5 + 10;\n\nint n, m;\nint a[N], b[N], siz[N];\nLL d[N];\nmap<LL, int> Map;\npriority_queue<pii> Q;\n\nvoid doit(int cnt) {\n\tpii tmp = Q.top(); Q.pop();\n\tint to = Map[d[tmp.se] - (n - siz[tmp.se] * 2)];\n\tif (!to || tmp.se == to) puts(\"-1\"), exit(0);\n\ta[cnt] = to;\n\tb[cnt] = tmp.se;\n\tsiz[to] += siz[tmp.se];\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%lld\", &d[i]);\n\t\tMap[d[i]] = i;\n\t\tQ.push(make_pair(d[i], i));\n\t}\n\tif (n == 1 && d[1]) return 0 * puts(\"-1\");\n\tfor (int i = 1; i <= n; ++i)\n\t\tsiz[i] = 1;\n\tfor (int i = 1; i < n; ++i)\n\t\tdoit(i);\n\tfor (int i = 1; i < n; ++i)\n\t\tprintf(\"%d %d\\n\", a[i], b[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<vector>\n#include<queue>\n#include<deque>\n#define ll long long\n#define mp make_pair\n#include<bits/stdc++.h> \n#define rep(i,x,y) for(int i=(x);i<=(y);++i)\n#define r0p(i,n) for(int i=0;i<n;++i)\n#pragma GCC optimize(1)\n#pragma G++ optimize(1)\n#pragma GCC optimize(2)\n#pragma G++ optimize(2)\n#pragma GCC optimize(3)\n#pragma G++ optimize(3)\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#define pii pair<int,int>\n#pragma GCC diagnostic error \"-std=c++11\"\nusing namespace std;\ninline void rdl(long long &val){\n    long long x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n\t}\n\twhile(ch>='0' and ch<='9'){\n\t    x=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n    val=x*f;\n}\ninline void rdi(int &val){\n    int x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    val=x*f;\n}\ninline long long rdl(){\n    long long x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline int rdi(){\n    int x=0;\n    int f=1;\n\tchar ch=getchar();\n\twhile((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n\tif(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline void write(int x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\ninline void _write(int x){\n\twrite(x);\n\tputchar(' ');\n}\ninline void print(int x){\n\twrite(x);\n\tputchar('\\n');\n}\ninline void write(ll x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\ninline void _write(ll x){\n\twrite(x);\n\tputchar(' ');\n}\ninline void print(ll x){\n\twrite(x);\n\tputchar('\\n');\n}\nstruct dsu{\n\tint par[200200];\n\tinline void init(int _n){for(int i=0;i<_n;++i) par[i]=i;}\n\tinline int find(int now){\n\t\tif(par[now]==now) return now;\n\t\treturn par[now]=find(par[now]);\n\t}\n\tinline bool uni(int a, int b){\n\t\tint Pa(find(a)),Pb(find(b));\n\t\tif(Pa==Pb) return false;\n\t\tpar[Pa]=Pb;\n\t\treturn true;\n\t}\n};\nint main(){\n\tint n,i,j;\n\trdi(n);\n\tvector<ll> d(n);\n\tvector<int> sz(n,1);\n\tmap<ll,int> m;\n\tfor(i=0;i<n;++i){\n\t\trdl(d[i]);\n\t\tm[d[i]]=i;\n\t}\n\tvector<pair<int,int> >ans;\n\tfor(int It=0;It<n-1;++It){\n\t\tauto it=m.begin();\n\t\ti=it->second;\n\t\tll need=d[i]-(n-sz[i])+sz[i];\n\t\tif(m.find(need)==m.end()) return 0*puts(\"-1\");\n\t\tj=m[need];\n\t\tans.emplace_back(i,j);\n\t\tsz[i]+=sz[j];\n\t\tm.erase(--m.end());\n\t}\n\tvector<ll> rd(n,-1);\n\trd[0]=0;\n\tvector<vector<int> >g(n);\n\tfor(auto p:ans){\n\t\tg[p.first].push_back(p.second);\n\t\tg[p.second].push_back(p.first);\n\t}\n\tvector<int> q(1,0);\n\tfor(i=0;i<q.size();++i){\n\t\tfor(int j:g[q[i]]){\n\t\t\tif(rd[j]==-1){\n\t\t\t\tq.push_back(j);\n\t\t\t\trd[j]=rd[q[i]]+1;\n\t\t\t}\n\t\t}\n\t}\n\tif(accumulate(rd.begin(),rd.end(),0ll)!=d[0]) return puts(\"-1\")*0;\n\tfor(pair<int,int>p:ans) _write(p.first),print(p.second);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nint main() {\n  \tputs(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<cstring>\n#include<utility>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<set>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#define ll long long\n#define pii pair<ll,int>\n#define mp make_pair\n#define fi first\n#define se second\n#define inf 0x7fffffff\nusing namespace std;\nll a[100010];\npii b[100010],c[100010];\nvector<pii> ans;\nint main()\n{\n\tint i,k,n,m,x,y,x1,n1;\n\tll j;\n\tscanf(\"%d\",&n);\n\tn1=n;\n\tfor(i=0;i<n;i++)\n\t{\n\t\tscanf(\"%lld\",&a[i]);\n\t\tb[i].fi=a[i];\n\t\tb[i].se=i+1;\n\t\tc[i]=b[i];\n\t}\n\tsort(b,b+n);\n\tvector<int> cl;\n\twhile(n>1)\n\t{\n\t\tx=n-1;\n\t\ti=2;\n\t\tk=0;\n\t\tcl.clear();\n\t\twhile(x!=0&&k<n)\n\t\t{\n\t\t\tif(n1<=i)\n\t\t\t{\n\t\t\t\tprintf(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tj=b[x].fi-n1+i;\n\t\t\tif(j<y)\n\t\t\t{\n\t\t\t\tprintf(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ti+=2;\n\t\t\tx1=lower_bound(b,b+n,mp(j,0))-b;\n\t\t\tans.push_back(mp(b[x].se,b[x1].se));\n\t\t\tif(x1>=n||b[x1].fi!=j)\n\t\t\t{\n\t\t\t\tprintf(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcl.push_back(x);\n\t\t\tk++;\n\t\t\tx=x1;\n\t\t}\n\t\tif(k>=n)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(i=0;i<cl.size();i++)\n\t\t{\n\t\t\tb[cl[i]]=mp(0,0);\n\t\t}\n\t\tsort(b,b+n);\n\t\treverse(b,b+n);\n\t\treverse(b,b+n-k);\n\t\tn-=k;\n\t}\n\tfor(i=0;i<ans.size();i++)\n\t{\n\t\tprintf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nstruct pt\n{\n\tll val;\n\tint id;\n\tpt(ll val=0,int id=0):val(val),id(id){}\n\tbool operator<(const pt x) const\n\t{\n\t\treturn val>x.val;\n\t}\n}a[100005];\nint n,e[100005][2],sz[100005];\nll f[100005];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%lld\",&a[i].val),a[i].id=i;\n\tfor(int i=1;i<=n;i++)\n\t\tsz[i]=1;\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint u=a[i].id,v;\n\t\tint nw=lower_bound(a+1,a+n+1,pt(a[i].val-n+2*sz[u]))-a;\n\t\tif(a[nw].val!=a[i].val-n+2*sz[u])\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tv=a[nw].id;\n\t\te[i][0]=u,e[i][1]=v;\n\t\tsz[v]+=sz[u],f[v]+=f[u]+sz[u];\n\t}\n\tif(f[a[n].id]!=a[n].val)\n\t{\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d %d\\n\",e[i][0],e[i][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n,cnt,a[111111],id[111111],w[111111],u[111111],v[111111],siz[111111];\nbool vis[111111];\nbool cmp(int x,int y){return a[x]<a[y];}\nvoid add(int x,int y){u[++cnt]=x,v[cnt]=y;}\nsigned main(){\n\tscanf(\"%d\",&n),w[0]=-LLONG_MAX;\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]),id[i]=i,w[i]=a[i],siz[i]=1;\n\tsort(id+1,id+n+1,cmp),sort(w+1,w+n+1);\n\tfor(int i=n;i>1;i--){\n\t\tint x=2*siz[id[i]]-n+a[id[i]],pos=lower_bound(w+1,w+n+1,x)-w;\n\t\tif(w[pos]!=x||n-2*siz[id[i]]<=0){printf(\"-1\");return 0;}\n\t\tadd(id[pos],id[i]),siz[id[pos]]+=siz[id[i]];\n\t}\n\tfor(int i=1;i<=cnt;i++)printf(\"%d %d\\n\",u[i],v[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n\n//#pragma GCC optimize (\"O3\")\n//#pragma GCC target (\"sse4\")\n\nusing namespace std;\ntemplate<class T, class T2> inline int chkmax(T &x, const T2 &y) { return x < y ? x = y, 1 : 0; }\ntemplate<class T, class T2> inline int chkmin(T &x, const T2 &y) { return x > y ? x = y, 1 : 0; }\nconst int MAXN = (1 << 20);\n\nint n, bg;\nmap<int64_t, int> id;\nint64_t d[MAXN];\n\nvoid read()\n{\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tcin >> d[i];\n\t\tid[d[i]] = i;\n\t}\n}\n\nvector<pair<int, int> > ans;\n\nvoid solve()\n{\n\tvector<int> tr_sz(n + 1, 1);\n\twhile(id.size() > 1)\n\t{\n\t\tauto it = id.rbegin();\n\t\tint i = it->second;\n\n\t\tint64_t d_par = d[i] - n + 2 * tr_sz[i];\n\n\t\tif(!id.count(d_par) || d_par == d[i])\n\t\t{\n\t\t\tcout << -1 << endl;\n\t\t\treturn;\n\t\t}\n\n\t\tint par = id[d_par];\n\t\t\n\t\tans.push_back({par, i});\n\t\ttr_sz[par] += tr_sz[i];\n\n\t\tid.erase(--id.end());\n\t}\n\n\tfor(auto it: ans) cout << it.first << \" \" << it.second << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace TYC\n{\n\ttypedef long long ll;\n\tconst int N = 1e5 + 5;\n\n\tint Siz[N], Id[N];\n\tll D[N];\n\tunordered_map<ll, int> M;\n\tvector<int> E[N];\n\n\ttemplate <typename T>\n\tinline T read()\n\t{\n\t\tT x = 0;\n\t\tint f = 0, ch = getchar();\n\t\twhile (!isdigit(ch))\n\t\t\tf |= (ch == '-'), ch = getchar();\n\t\twhile (isdigit(ch))\n\t\t\tx = x * 10 + ch - '0', ch = getchar();\n\t\treturn f ? -x : x;\n\t}\n\n\tll dfs(const int u, const int d)\n\t{\n\t\tll ans = d;\n\t\tfor (int v : E[u])\n\t\t\tans += dfs(v, d + 1);\n\t\treturn ans;\n\t}\n\n\tvoid work()\n\t{\n\t\tint n = read<int>();\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tll d = D[i] = read<ll>();\n\t\t\tId[i] = i;\n\t\t\tM[d] = i;\n\t\t\tSiz[i] = 1;\n\t\t}\n\t\tsort(Id + 1, Id + 1 + n, [](const int a, const int b) { return D[a] < D[b]; });\n\t\tfor (int i = n; i > 1; i--)\n\t\t{\n\t\t\tint v = Id[i];\n\t\t\tll d = D[v] + 2 * Siz[v] - n;\n\t\t\tif (d >= D[v] || !M.count(d))\n\t\t\t\treturn void(puts(\"-1\"));\n\t\t\tint u = M[d];\n\t\t\tSiz[u] += Siz[v];\n\t\t\tE[u].push_back(v);\n\t\t}\n\t\tif (dfs(Id[1], 0) != D[Id[1]])\n\t\t\tputs(\"-1\");\n\t\telse\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tfor (int j : E[i])\n\t\t\t\t\tprintf(\"%d %d\\n\", i, j);\n\t}\n}\n\nint main()\n{\n\tTYC::work();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\n\nconst int maxn = 1e5 + 5;\n\nint par[maxn], N, sub[maxn];\nii d[maxn];\n\nsigned main(void)\n{\n  ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n  if(fopen(\"A.INP\", \"r\")){\n    freopen(\"A.INP\", \"r\", stdin);\n    freopen(\"A.OUT\", \"w\", stdout);\n  }\n  cin >> N;\n  for(int i = 1; i <= N; ++i){\n    cin >> d[i].fi;\n    d[i].se = i;\n    sub[i] = 1;\n  }\n  sort(d + 1, d + 1 + N);\n  for(int i = N; i >= 2; --i){\n    int j = lower_bound(d + 1, d + 1 + N, mp(d[i].fi - (N - 2 * sub[d[i].se]), -1)) - d;\n    if(i == j) ++j;\n    if(d[j].fi != d[i].fi - (N - 2 * sub[d[i].se])){\n      cout << -1;\n      return 0;\n    }\n    par[d[i].se] = d[j].se;\n    sub[d[j].se] += sub[d[i].se];\n  }\n  for(int i = 1; i <= N; ++i){\n    if(par[i]) cout << i << ' ' << par[i] << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cassert>\n#include<cmath>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<vector>\n#include<time.h>\n#include<algorithm>\nusing namespace std;\n#define REP(i,x,y) for(ll i=x;i<=y;i++)\n#define rep(i,n) REP(i,1,n)\n#define rep0(i,n) REP(i,0,n-1)\n#define repG(i,x) for(ll i=pos[x];~i;i=e[i].next)\n#define ll long long\n#define db double\nconst ll N=1e5+7;\nconst ll INF=1e9+7;\nll n,cnt=0;\nll sz[N],w[N],X[N],Y[N],ds[N];\nstruct pir{ll x,d;}p[N];\nbool cmp(pir a,pir b){return a.d<b.d;}\n\nint main(){\n\tscanf(\"%lld\",&n);\n\trep(i,n)scanf(\"%lld\",&p[i].d),p[i].x=i;\n\tsort(p+1,p+n+1,cmp);\n\trep(i,n){\n\t\tw[i]=p[i].d;\n\t\tsz[i]=1;\n\t\tds[i]=0;\n\t}\n\tfor(ll i=n;i>1;i--){\n\t\tll t=lower_bound(w+1,w+n+1,w[i]-(n-2*sz[i]))-w;\n\t\tif(w[t]!=w[i]-(n-2*sz[i])){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsz[t]+=sz[i];\n\t\tds[t]=ds[t]+ds[i]+sz[i];\n\t\tX[++cnt]=p[i].x;\n\t\tY[cnt]=p[t].x;\n\t}\n\tif(sz[1]!=n||ds[1]!=w[1]){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\trep(i,cnt)printf(\"%lld %lld\\n\",X[i],Y[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<iostream>\n#include<algorithm>\n#define maxn 100050\nusing namespace std;\ntypedef long long LL;\n\nint n;\nLL D[maxn];\n\nint pos[maxn];\n\nint size[maxn];\n\nbool vis[maxn];\n\nint p[2];\nvector<int> vert[2]; \n\nvoid init()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tpos[i]=i;\n\t\tscanf(\"%d\",&D[i]); \n\t\tvert[D[i]&1].push_back(i);\n\t}\n}\n\nbool cmp(int i,int j)\n{\n\treturn D[i]<D[j];\n}\n\nint fa[maxn];\n\nbool solve()\n{\n\tsort(pos+1,pos+n+1,cmp);\n\tsort(vert[0].begin(),vert[0].end(),cmp);\n\tsort(vert[1].begin(),vert[1].end(),cmp);\n\t\n\tsize[pos[1]]=n;\n\t++p[D[pos[1]]&1];\n\t\n\tfor (int k=1;k<=n;++k)\n\t{\n\t\tint u=pos[k],cnt=1,c=(D[u]+n)&1;\n\t\tint &j=p[c],len=vert[c].size();\n\t\tfor (;cnt<size[u];++j)\n\t\t{\n\t\t\tint v=vert[c][j];\n\t\t\tsize[v]=(D[u]+n-D[v])>>1;\n\t\t\tcnt+=size[v];\n\t\t\tfa[v]=u;\n//\t\t\tprintf(\"%d %d\\n\",u,v);\n//\t\t\tcout<<u<<\" \"<<v<<\" \"<<size[v]<<\" \"<<cnt<<endl;\n\t\t}\n//\t\tcout<<u<<\" \"<<size[u]<<\" \"<<cnt<<endl;\n\t\tif (cnt!=size[u])\n\t\t{\n//\t\t\tcout<<\"warning:\"<<u<<endl;\n\t\t\treturn 0;\n\t\t}\n//\t\tassert(cnt==size[u]);\n\t}\n\t\n\tfor (int k=1;k<=n;++k)\n\t{\n\t\tint u=pos[k];\n\t\tif (fa[u])\n\t\t\tprintf(\"%d %d\\n\",u,fa[u]);\n\t}\n\treturn 1;\n}\n\nint main()\n{\n//    freopen(\"c.in\",\"r\",stdin);\n    init();\n    if (!solve())\n    \tprintf(\"-1\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int MN = 100010;\n\nint N;\nll D[MN];\nvector<pair<ll, int> > ord;\nint inv[MN], sz[MN];\nvector<pii> edge;\nvector<int> adj[MN];\nint dep[MN];\n\nvoid dfs(int u, int p) {\n    for(int i = 0; i < adj[u].size(); i++) {\n        int v = adj[u][i];\n        if(v == p) continue;\n        dep[v] = dep[u] + 1;\n        dfs(v, u);\n    }\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%lld\", &D[i]);\n        ord.push_back({ D[i], i });\n    }\n\n    sort(ord.begin(), ord.end());\n    for(int i = 0; i < N; i++) inv[i] = ord[i].second;\n    sort(D, D + N);\n\n    for(int i = 0; i < N; i++) sz[i] = 1;\n    for(int i = N - 1; i >= 1; i--) {\n        if(2 * sz[i] >= N) {\n            printf(\"-1\");\n            return 0;\n        }\n        if(D[i] - N + 2 * sz[i] <= 0) {\n            printf(\"-1\");\n            return 0;\n        }\n        int a = lower_bound(D, D + N, D[i] - N + 2 * sz[i]) - D;\n        if(D[a] != D[i] - N + 2 * sz[i]) {\n            printf(\"-1\");\n            return 0;\n        }\n\n        edge.push_back(pii(inv[a], inv[i]));\n        sz[a] += sz[i];\n        adj[a].push_back(i);\n    }\n    if(sz[0] != N) {\n        printf(\"-1\");\n        return 0;\n    }\n\n    dfs(0, -1);\n\n    ll sum = 0;\n    for(int i = 0; i < N; i++) sum += dep[i];\n    if(sum != D[0]) {\n        printf(\"-1\");\n        return 0;\n    }\n\n    for(int i = 0; i < N - 1; i++) {\n        printf(\"%d %d\\n\", edge[i].first + 1, edge[i].second + 1);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target (\"avx2\")\n//#pragma GCC optimization (\"unroll-loops\")\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include \"bits/stdc++.h\"\n#include \"ext/pb_ds/tree_policy.hpp\"\n#include \"ext/pb_ds/assoc_container.hpp\"\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\nconst long double PI = 4*atan(1);\n\ntypedef long long ll;\ntypedef long double ld;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ld, ld> pd;\ntypedef complex<ld> cd;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define f0r(i,a) for(int i=0;i<a;i++)\n#define f1r(i,a,b) for(int i=a;i<b;i++)\n#define trav(a, x) for (auto& a : x)\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)(x).size()\n#define all(x) x.begin(), x.end()\n#define rall(x) rbegin(x), rend(x)\n#define resz resize\n#define ins insert\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &cout, pair<A, B> const &p) { return cout << \"(\" << p.f << \", \" << p.s << \")\"; }\ntemplate<typename A> ostream& operator<<(ostream &cout, vector<A> const &v) {\n  cout << \"[\"; for(int i = 0; i < v.size(); i++) {if (i) cout << \", \"; cout << v[i];} return cout << \"]\";\n}\n\ntemplate<class T> bool ckmin(T& a, const T& b) {\n\treturn a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\nnamespace input {\n\ttemplate<class T> void re(complex<T>& x);\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p);\n\ttemplate<class T> void re(vector<T>& a);\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a);\n\n\ttemplate<class T> void re(T& x) { cin >> x; }\n\tvoid re(double& x) { string t; re(t); x = stod(t); }\n\tvoid re(ld& x) { string t; re(t); x = stold(t); }\n\ttemplate<class T, class... Ts> void re(T& t, Ts&... ts) {\n\t\tre(t); re(ts...);\n\t}\n\n\ttemplate<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n\ttemplate<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n\tvoid pr(int x) { cout << x; }\n\tvoid pr(long x) { cout << x; }\n\tvoid pr(ll x) { cout << x; }\n\tvoid pr(unsigned x) { cout << x; }\n\tvoid pr(unsigned long x) { cout << x; }\n\tvoid pr(unsigned long long x) { cout << x; }\n\tvoid pr(float x) { cout << x; }\n\tvoid pr(double x) { cout << x; }\n\tvoid pr(ld x) { cout << x; }\n\tvoid pr(char x) { cout << x; }\n\tvoid pr(const char* x) { cout << x; }\n\tvoid pr(const string& x) { cout << x; }\n\tvoid pr(bool x) { pr(x ? \"true\" : \"false\"); }\n\ttemplate<class T> void pr(const complex<T>& x) { cout << x; }\n\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x);\n\ttemplate<class T> void pr(const T& x);\n\n\ttemplate<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n\t\tpr(t); pr(ts...);\n\t}\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x) {\n\t\tpr(\"{\",x.f,\", \",x.s,\"}\");\n\t}\n\ttemplate<class T> void pr(const T& x) {\n\t\tpr(\"{\"); // const iterator needed for vector<bool>\n\t\tbool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0;\n\t\tpr(\"}\");\n\t}\n\n\tvoid ps() { pr(\"\\n\"); } // print w/ spaces\n\ttemplate<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n\t\tpr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...);\n\t}\n\n\tvoid pc() { pr(\"]\\n\"); } // debug w/ commas\n\ttemplate<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n\t\tpr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...);\n\t}\n\t#define dbg(x...) pr(\"[\",#x,\"] = [\"), pc(x);\n}\n\nusing namespace output;\n\nnamespace io {\n\tvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n\tvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n\tvoid setIO(string s = \"\") {\n\t\tcin.sync_with_stdio(0); cin.tie(0); // fast I/O\n\t\t// cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n\t\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n\t}\n}\n\nusing namespace io;\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll MOD = 1e9 + 7;\n\ntypedef decay<decltype(MOD)>::type T;\nstruct mi {\n\tT val;\n\texplicit operator T() const { return val; }\n\tmi() { val = 0; }\n\tmi(const ll& v) {\n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\t// friend ostream& operator<<(ostream& os, const mi& a) {\n\t\t// return os << a.val; }\n\tfriend void pr(const mi& a) { pr(a.val); }\n\tfriend void re(mi& a) { ll x; re(x); a = mi(x); }\n\n\tfriend bool operator==(const mi& a, const mi& b) {\n\t\treturn a.val == b.val; }\n\tfriend bool operator!=(const mi& a, const mi& b) {\n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) {\n\t\treturn a.val < b.val; }\n\n\tmi operator-() const { return mi(-val); }\n\tmi& operator+=(const mi& m) {\n\t\tif ((val += m.val) >= MOD) val -= MOD;\n\t\treturn *this; }\n\tmi& operator-=(const mi& m) {\n\t\tif ((val -= m.val) < 0) val += MOD;\n\t\treturn *this; }\n\tmi& operator*=(const mi& m) {\n\t\tval = (ll)val*m.val%MOD; return *this; }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) {\n\t\tassert(a != 0); return pow(a,MOD-2); }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n};\n\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\nconst int MAX = 1e5 + 5;\nconst int INF = 1e9;\nmap<ll, int> conv;\nvpi edges;\nint main(){\n    int n; re(n);\n    vl d(n);\n    f0r(i, n) re(d[i]);\n    set<pair<ll, int>, greater<pair<ll, int>>> s;\n    f0r(i, n) s.insert(mp(d[i], 1));\n    f0r(i, n) conv[d[i]] = i;\n    while(sz(s)>1){\n        auto ft = *s.begin();\n        s.erase(ft);\n        ll nxt = ft.f + 2*ft.s - n;\n        auto it = s.lb(mp(nxt, INF));\n        if(it == s.end()){\n            ps(-1); return 0;\n        }\n        auto tmp = *it;\n        if(tmp.f != nxt){\n            ps(-1); return 0;\n        }\n        edges.eb(mp(conv[ft.f], conv[tmp.f]));\n        s.erase(tmp);\n        tmp.s += ft.s;\n        s.insert(tmp);\n    }\n    for(auto e: edges) ps(e.f+1, e.s+1);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#define int long long\nint n,size[100100],u[100100],v[100100],head[100100],cnt,D;\nstruct Edge{\n\tint to,nxt;\n}edge[200100];\nstruct node{\n\tint dis,x;\n\tbool operator<(node b)const{\n\t\treturn dis>b.dis;\n\t}\n}a[100100];\nmap<int,int>mp;\nvoid addedge(int x,int y){\n\tedge[++cnt].to=y;\n\tedge[cnt].nxt=head[x];\n\thead[x]=cnt;\n}\nint dfs(int x,int fa,int now){\n\tD+=now;\n\tfor (int i=head[x];i;i=edge[i].nxt){\n\t\tint upup=edge[i].to;\n\t\tif(upup==fa)continue;\n\t\tdfs(upup,x,now+1);\n\t}\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i].dis);\n\t\ta[i].x=i;\n\t\tmp[a[i].dis]=i;\n\t}\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)size[i]=1;\n\tfor(int i=1;i<n;i++){\n\t\tint dis=a[i].dis,x=a[i].x;\n\t\tint tmp=dis-abs(n-2*size[x]);\n\t\tint fa=mp.find(tmp)->second;\n\t\tif(fa==x||!fa)return puts(\"-1\"),0;\n\t\tsize[fa]+=size[x];\n\t\tu[i]=x,v[i]=fa;\n\t\taddedge(x,fa);\n\t\taddedge(fa,x);\n\t}\n\tdfs(a[n].x,0,0);\n\tif(D!=a[n].dis)return puts(\"-1\"),0;\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%lld %lld\\n\",u[i],v[i]);\n}"
  },
  {
    "language": "C++",
    "code": "// In the name of God\n\n#include<bits/stdc++.h>\n\n#define F first\n#define S second\n#define PB push_back\n#define sz(s) int((s).size())\n#define bit(n,k) (((n)>>(k))&1)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int maxn=1e5+10,mod=1e9+7;\nconst ll inf=1e18;\n\npair<ll,int> p[maxn];\nmap<ll,vector<int> >mp;\nint par[maxn],SZ[maxn];\nvector<int>v[maxn];\n\npair<ll,int> dfs(int u,int par=-1){\n    ll A=0;\n    int B=1;\n    for(int y:v[u]){\n\tif(y!=par){\n\t    pair<ll,int>p=dfs(y,u);\n\t    B+=p.S;\n\t    A+=p.F+p.S;\n\t}\n    }\n    return {A,B};\n}\n\nint main(){\n    int n;cin>>n;\n    for(int i=1;i<=n;i++){\n\tcin>>p[i].F;\n\tp[i].S=i;\n    }\n    sort(p+1,p+n+1);\n    for(int i=n;i>=1;i--){\n\tSZ[p[i].S]=1;\n\tif(mp.count(p[i].F)){\n\t    for(int id:mp[p[i].F]){\n\t\tpar[id]=p[i].S;\n\t\tSZ[p[i].S]+=SZ[id];\n\t    }\n\t    mp.erase(p[i].F);\n\t}\n\tmp[p[i].F+2*SZ[p[i].S]-n].PB(p[i].S);\n    }\n    for(int i=1;i<=n;i++){\n\tif(par[i]==0 && i!=p[1].S){\n\t    return cout<<-1<<endl,0;\n\t}\n\telse if(par[i]!=0){\n\t    v[par[i]].PB(i);\n\t}\n    }\n    if(dfs(p[1].S).F!=p[1].F){\n\treturn cout<<-1<<endl,0;\n    }\n    for(int i=1;i<=n;i++){\n\tif(i==p[1].S)continue;\n\tcout<<i<<\" \"<<par[i]<<\"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<functional>\n#include<algorithm>\n#define Rint register int\nusing namespace std;\ntypedef long long LL;\nconst int N = 100003;\nint n, fa[N], siz[N], head[N], to[N], nxt[N];\nLL sum[N];\nstruct Node {\n\tLL val;\n\tint pos;\n\tinline Node(LL _val = 0, int _pos = 0): val(_val), pos(_pos){}\n\tinline bool operator < (const Node &o) const {return val > o.val;}\n} a[N];\nLL ans;\ninline void add(int a, int b){\n\tstatic int cnt = 0;\n\tto[++ cnt] = b; nxt[cnt] = head[a]; head[a] = cnt;\n}\ninline void dfs(int x, int d){\n\tans += d;\n\tfor(Rint i = head[x];i;i = nxt[i])\n\t\tdfs(to[i], d + 1);\n}\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(Rint i = 1;i <= n;i ++){\n\t\tscanf(\"%lld\", &a[i].val);\n\t\ta[i].pos = i;\n\t\tsiz[i] = 1;\n\t}\n\tsort(a + 1, a + n + 1);\n\tfor(Rint i = 1;i <= n;i ++) sum[i] = a[i].val;\n\tfor(Rint i = 1;i < n;i ++){\n\t\tint pos = lower_bound(sum + 1, sum + n + 1, sum[i] - n + (siz[i] << 1), greater<LL>()) - sum;\n\t\tif(sum[pos] != sum[i] - n + (siz[i] << 1) || pos == i){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tfa[a[i].pos] = a[pos].pos; siz[pos] += siz[i]; add(pos, i);\n\t}\n\tdfs(n, 0);\n\tif(ans == a[n].val){\n\t\tfor(Rint i = 1;i <= n;i ++)\n\t\t\tif(fa[i]) printf(\"%d %d\\n\", i, fa[i]);\n\t\treturn 0;\n\t}\n\tputs(\"-1\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdint>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX = 100000;\n\ntypedef struct node {\n\tint id;\n\tint64_t num;\n\tint edge;\n\tint height;\n\tbool operator<(const node& r) const {\n\t\treturn num < r.num;\n\t}\n} Node;\n\nint main() {\n\tint N;\n\tstatic Node node[MAX];\n\tcin >> N;\n\tfor (int i = 0;i < N;++ i) {\n\t\tcin >> node[i].num;\n\t\tnode[i].id = i + 1;\n\t\tnode[i].height = 1;\n\t}\n\tsort(node, node + N);\n\t\n\tint64_t sum = 0; // 1からの距離\n\tfor (int i = N - 1;i > 0;-- i) { // 大きい数字から確定させる\n\t\tint min = 0, max = i - 1;\n\t\tint64_t check = node[i].num - N + (node[i].height << 1);\n\t\tfor (int mid = i >> 1;max - min > 1;mid = min + (max - min >> 1)) {\n\t\t\tif (node[mid].num > check) max = mid;\n\t\t\telse min = mid;\n\t\t}\n\t\tif (node[min].num != check) { // 繋げる辺が存在しなかった\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\tnode[i].edge = min;\n\t\tnode[min].height += node[i].height;\n\t\tsum += node[i].height;\n\t}\n\t\n\tif (sum != node[0].num) {\n\t\tcout << -1;\n\t\treturn 0;\n\t}\n\tfor (int i = N - 1;i > 0;-- i) {\n\t\tcout << node[i].id << \" \" << node[node[i].edge].id << endl;\n\t}\n\treturn 0;\n}\n/*\n31536000のコメント解説欄\nここテンプレで用意してるから、A問題とかだとこの先空欄の危険あり\nまた、コンテスト後に https://31536000.hatenablog.com/ で解説していると思うので、良かったら読んでねー\n\n解説AC\n数字の大きい方の頂点から確定させることを考える\nこの時、この頂点から繋ぐ辺は、自分の数-N+(現時点の自分の属する木の高さ*2)となることが数学的に証明できる(解説放送参照)\nということは二分探索していけばO(NlogN)で判定と構築ができるわけだ\n最後に本当に正しいか確認だけして、問題ないなら構築完了\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pii_ pair<int,int>\n#define mp_ make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define show1(a) cout<<#a<<\" = \"<<a<<endl\n#define show2(a,b) cout<<#a<<\" = \"<<a<<\"; \"<<#b<<\" = \"<<b<<endl\nusing namespace std;\nconst ll INF = 1LL<<60;\nconst int inf = 1<<30;\nconst int maxn = 1e5+5;\ninline void fastio() {ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);}\nvoid GG()\n{\n    cout<<-1<<endl;\n    exit(0);\n}\nint n,sz[maxn];\nll dis[maxn];\nstruct node\n{\n    int id;\n    ll d;\n    bool operator < (const node e) const {\n        return d>e.d;\n    }\n}tr[maxn];\nvector<pii_> e;\nvector<int> g[maxn];\nvoid dfs(int u)\n{\n    for(int v:g[u]){\n        dfs(v);\n        dis[u] += dis[v]+sz[v];\n    }\n}\nvoid dfs2(int u){\n    for(int v:g[u]){\n        dis[v] = dis[u]+n-2*sz[v];\n        dfs2(v);\n    }\n}\nint main()\n{\n    fastio();\n    cin>>n;\n    rep(i,1,n){\n        cin>>tr[i].d; tr[i].id = i;\n    }\n    sort(tr+1,tr+n+1);\n    rep(i,1,n) sz[i] = 1;\n    rep(i,1,n-1){\n        ll dfa = tr[i].d+2*sz[tr[i].id]-n;\n        int pos = lower_bound(tr+1,tr+n+1,(node){0,dfa})-tr;\n        if(pos<1 || pos>n) GG(); // 找不到父节点\n        node fa = tr[pos];\n        if(fa.d!=dfa || fa.id==tr[i].id) GG();    // 找不到父节点\n        sz[fa.id] += sz[tr[i].id];\n        if(fa.id!=tr[n].id && sz[fa.id]>n/2) GG();   // 以重心为根，其他节点的子树大小不能超过n的一半\n        e.pb(mp_(tr[i].id,fa.id));\n        g[fa.id].pb(tr[i].id);\n    }\n    if(e.size()!=n-1) GG();\n    dfs(tr[n].id);\n    dfs2(tr[n].id);\n    rep(i,1,n){\n        if(tr[i].d != dis[tr[i].id]) GG();\n    }\n    for(auto x:e){\n        cout<<x.fi<<\" \"<<x.se<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, n) for(ll i = (ll)a; i < (ll)n; i++)\n#define FORR(i, n) for(ll i = (ll)n - 1LL; i >= 0LL; i--)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(x) begin(x), end(x)\nusing namespace std;\nusing ll = long long;\nconstexpr ll Mod = 998244353;\nconstexpr ll mod = 1e9 + 7;\nconstexpr ll inf = 1LL << 60;\nconst double PI = acos(-1);\ntemplate <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) {\n    return a < b && (a = b, true);\n}\ntemplate <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) {\n    return a > b && (a = b, true);\n}\n/*-------------------------------------------*/\n\nusing P = pair<ll, int>;\n\nint n;\nP d[100009];\nint par[100009];\nint sz[100009];\n\nll sum[100009];\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    cin >> n;\n    rep(i, n) {\n        cin >> d[i].first;\n        d[i].second = i;\n    }\n    sort(d, d + n, greater<P>());\n\n    memset(par, -1, sizeof(par));\n    fill(sz, sz + n, 1);\n\n    rep(i, n - 1) {\n        auto [s, idx] = d[i];\n        ll x = s + 2 * sz[idx] - n;\n        auto it = lower_bound(d, d + n, P(x, 1 << 30), greater<P>());\n        if(it->first != x) {\n            cout << \"-1\\n\";\n            return 0;\n        }\n        par[idx] = it->second;\n        sz[par[idx]] += sz[idx];\n        sum[par[idx]] += sum[idx] + sz[idx];\n    }\n\n    if(sum[d[n - 1].second] != d[n - 1].first) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n\n    rep(i, n) if(~par[i]) cout << par[i] + 1 << \" \" << i + 1 << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Inf 0x3f3f3f3f\n#define rg register\nusing namespace std;\nconst int Maxn = 1e5 + 5;\ntypedef long long ll;\ntypedef ll arr[Maxn];\nll min(ll x, ll y) { return x < y ? x : y; }\nll max(ll x, ll y) { return x > y ? x : y; }\ninline ll read()\n{\n\trg ll res = 0, sign = 1;\n\trg char ch = getchar();\n\twhile (!isdigit(ch))\n\t{\n\t\tif (ch == '-')\n\t\t\tsign = -1;\n\t\tch = getchar();\n\t}\n\tdo\n\t{\n\t\tres = (res << 3) + (res << 1) + (ch ^ 48);\n\t\tch = getchar();\n\t} while (isdigit(ch));\n\treturn res * sign;\n}\nint n;\nll dist;\narr siz, fa, dis;\nstruct str\n{\n\tll d;\n\tint id;\n\tbool operator<(str A) const { return d < A.d; }\n} p[Maxn];\nvector<int>to[Maxn];\nvoid DFS(int x)\n{\n    dist+=dis[x];\n    for(rg int i=0,nx;i<to[x].size();i++)\n    {\n        nx=to[x][i];\n        dis[nx]=dis[x]+1;\n        DFS(nx);\n    }\n}\nvoid Solve(int x)\n{\n    for(rg int i=0,nx;i<to[x].size();i++)\n    {\n        nx=to[x][i];\n        dis[nx]=dis[x]+n-2*siz[nx];\n        Solve(nx);\n    }\n}\nint main()\n{\n\tint tmp, now, s;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tp[i] = {read(), i};\n\t\tsiz[i] = 1;\n\t}\n\tsort(p + 1, p + n + 1);\n\tfor (int i = n; i > 1; i--)\n\t{\n\t\tnow = p[i].id;\n\t\ttmp = p[i].d - n + 2 * siz[now];\n\t\tfa[now] = p[s = lower_bound(p + 1, p + n + 1, (str){tmp, 0}) - p].id;\n        to[fa[now]].push_back(now);\n\t\tif (p[s].d != tmp || s >= i)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[fa[now]] += siz[now];\n\t}\n    DFS(p[1].id);\n    dis[p[1].id]=dist;\n    Solve(p[1].id);\n    for(int i=1;i<=n;i++)\n        if(dis[p[i].id]!=p[i].d)\n        {\n            puts(\"-1\");\n            return 0;\n        }\n\tfor (int i = 1; i <= n; i++)\n\t\tif (fa[i])\n\t\t\tprintf(\"%d %d\\n\", fa[i], i);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+3;\nint n,siz[N];\nstruct syzs{\n\tlong long val;\n\tint num;\n} a[N];\nstruct ans{\n\tint e1,e2;\n\tbool operator <(const ans &emm) const{\n\t    if(emm.e1==e1) return e2>emm.e2;\n\t\treturn emm.e1<e1;\n\t}\n};\nbool cmp(syzs c,syzs b){\n\treturn c.val>b.val;\n}\nint find(int k){\n\tlong long chec=a[k].val+2*siz[k]-n;\n\tfor(int i=k+1;i<=n;i++) if(a[i].val==chec) return i;\n\treturn -1;\n}\nint main(){\n\tpriority_queue <ans> q;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i].val);\n\t\ta[i].num=i;\n\t\tsiz[i]=1;\n\t}\n\tsort(a+1,a+n+1,cmp);\n\tfor(int i=1;i<n;i++){\n\t\tint v=find(i);\n\t\tif(v==-1){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[v]+=siz[i];\n\t\tq.push((ans) {min(a[v].num,a[i].num),max(a[v].num,a[i].num)});\n\t}\n\twhile(!q.empty()){\n\t\tint v1=q.top().e1,v2=q.top().e2;\n    \tq.pop();\n    \tprintf(\"%d %d\\n\",v1,v2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*********************\n*  Author: xuziyuan  * \n*********************/\n\n#include <bits/stdc++.h>\n\n#define rt0 return 0\n#define rep(i,n) for(int i=0;i<n;i++)\n#define repn(i,n) for(int i=1;i<=n;i++)\n#define replet(c) for(char c='a';c<='z';c++) \n#define LL long long\n#define pii pair <LL,LL>\n#define pb push_back\n#define fi first\n#define se second\n#define mpr make_pair\n#define sqr(a) ((a)*(a))\n\nusing namespace std;\n\nconst LL MOD=1e9+7;\n\nLL n,d[100010],sonn[100010],dp[100010];\nmap <LL,LL> mp;\nvector <LL> g[100010];\nvector <pii> ans,v;\nbool vis[100010];\n\nbool cmp(pii a,pii b)\n{\n\treturn a.fi>b.fi;\n}\n\nvoid dfs(LL pos,LL no)\n{\n\tif(vis[pos])\n\t{\n\t\tputs(\"-1\");\n\t\texit(0);\n\t}\n\tsonn[pos]=1;\n\tvis[pos]=true;\n\trep(i,g[pos].size())\n\t{\n\t\tif(g[pos][i]==no) continue;\n\t\tdfs(g[pos][i],pos);\n\t\tdp[pos]+=dp[g[pos][i]]+sonn[g[pos][i]];\n\t\tsonn[pos]+=sonn[g[pos][i]];\n\t}\n}\n\nvoid dfs2(LL pos,LL no,LL now)\n{\n\tif(now+dp[pos]!=d[pos])\n\t{\n\t\tputs(\"-1\");\n\t\texit(0);\n\t}\n\trep(i,g[pos].size()) \n\tif(g[pos][i]!=no) dfs2(g[pos][i],pos,now+dp[pos]-dp[g[pos][i]]-sonn[g[pos][i]]+n-sonn[g[pos][i]]);\n}\n\nint main()\n{\n\trep(i,100005) sonn[i]=1;\n\tcin>>n;\n\trep(i,n)\n\t{\n\t\tscanf(\"%I64d\",&d[i]);\n\t\tmp[d[i]]=i;\n\t\tv.pb({d[i],i});\n\t}\n\tsort(v.begin(),v.end(),cmp);\n\trep(i,v.size()-1)\n\t{\n\t\tLL wantpar=v[i].fi-n+sonn[v[i].se]*2;\n\t\tif(wantpar>=v[i].fi||mp.find(wantpar)==mp.end())\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\trt0;\n\t\t}\n\t\tsonn[mp[wantpar]]+=sonn[v[i].se];\n\t\tans.pb({v[i].se,mp[wantpar]});\n\t\tg[v[i].se].pb(mp[wantpar]);\n\t\tg[mp[wantpar]].pb(v[i].se);\n\t}\n\tmemset(sonn,0,sizeof(sonn));\n\tdfs(0,0);\n\tdfs2(0,0,0);\n\trep(i,n-1) cout<<ans[i].fi+1<<' '<<ans[i].se+1<<endl;\n\trt0;\n}"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define int ll\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nint const N = 1e5 + 20 ;\nint n , d[N] , sz[N] ;\nmap <int , int> mp ;\nvector <int> g[N] ;\nvector <pii> edges ;\n\nvoid err () {\n\tcout << -1 << '\\n' ;\n\texit(0) ;\n}\n\nint sum = 0 ;\nvoid dfs (int v , int h = 0) {\n\tsum += h ;\n\tfor (int u : g[v]) dfs(u , h + 1) ;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tcin >> n ;\n\n\tfor (int i = 0 ; i < n ; i ++) cin >> d[i] , mp[d[i]] = i , sz[i] = 1 ;\n\n\tsort(d , d + n , greater<int>()) ;\n\n\tfor (int i = 0 ; i < n - 1 ; i ++) {\n\t\tint v = mp[d[i]] ;\n\t\tint k = d[i] - n + 2 * sz[v] ;\n\n\t\tif (k >= d[i] || !mp.count(k)) err() ;\n\n\t\tint p = mp[k] ;\n\n\t\tsz[p] += sz[v] ;\n\t\tedges.push_back({p , v}) ;\n\t\n\t\tg[p].push_back(v) ;\n\t}\n\n\tdfs(mp[d[n - 1]]) ;\n\n\tif (d[n - 1] != sum) err() ;\n\n\tfor (pii p : edges) cout << p.F + 1 << ' ' << p.S + 1 << '\\n' ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <atcoder/all>\nusing namespace std;\n//using namespace atcoder;\n#define ll long long\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, n+1)\n#define rrep(i, n) for (int i = ((int)(n)-1); i >= 0; --i)\n#define whole(x) (x).begin(),(x).end()\n#define rwhole(x) (x).rbegin(), (x).rend()\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define P pair<ll, ll>\n#define debug(var) cerr << \"[\" << #var << \"] \" << var << '\\n'\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\n#define vi vector<int>\n#define vl vector<ll>\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define pr(s) cout << (s) << '\\n'\nconst ll mod = 1000000007;\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\nconst int INF = 1001001001;\nconst ll INFll = 1E+18;\nconst int MAXN = 100005;\n\nll par[MAXN];\nll child[MAXN];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    ll n;\n    cin >> n;\n    vector<P> d(n);\n    rep(i, n) {\n        cin >> d[i].fi;\n        d[i].se = i;\n    }\n    sort(whole(d));\n\n    rrep(i, n) {\n        if (i==0) continue;\n        ll x = d[i].fi - n+2 + child[i]*2;\n        if (x==d[i].fi) {\n            pr(-1);\n            return 0;\n        }\n        //debug(d[i].fi);\n        //debug(x);\n        auto it = lower_bound(whole(d), P(x, 0));\n        if (it==d.end() || it->fi!=x) {\n            pr(-1);\n            return 0;\n        }\n        par[i] = it-d.begin();\n        child[par[i]] += child[i]+1; \n    }\n\n    rep(i, n) {\n        if (i==0) continue;\n        ll u = d[i].se + 1;\n        ll v = d[par[i]].se + 1;\n        cout << u << \" \" << v << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <time.h>\n\n#include <stdlib.h>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <vector>\n#include <map>\nusing namespace std;\nstruct condition{\n\tint32_t vertex;\n\tint64_t total;\n};\nstruct current{\n\tint32_t parent;\n\tint32_t vertex_num;\n};\nstruct edge{\n\tint32_t v1;\n\tint32_t v2;\n};\nbool operator< (const condition& a,const condition& b){\n\treturn a.total>b.total;\n}\nint main() {\n\n\tint32_t n;\n\tcin>>n;\n\tstd::vector<condition> cd;\n\tvector<edge> ans;\n\tans.reserve(n);\n\tcd.reserve(n);\n\tfor(int i=0;i<n;i++){\n\t\tint64_t temp;\n\t\tcin>>temp;\n\t\tcd.push_back(condition{i+1,temp});\n\t}\n\tbool ans_possible=true;\n\tsort(cd.begin(),cd.end());\n\tmap<int64_t,vector<current> > flow;\n\tfor(auto i=cd.begin();i!=cd.end();i++){\n\t\tint32_t sum_vertex=0;\n\n\t\tif(flow.count(i->total)){\n\t\t\tvector<current>& t=flow.at(i->total);\n\t\t\tint64_t total_cost=0;\n\t\t\tfor(auto k=t.begin();k!=t.end();k++){\n\t\t\t\tans.push_back(edge{k->parent,i->vertex});\n\t\t\t\tsum_vertex+=(k->vertex_num);\n\t\t\t\ttotal_cost+=((k->vertex_num)*(k->vertex_num+1))/2;\n\t\t\t}\n\t\t\tans_possible=(total_cost==i->total);\n\n\t\t\tflow.erase(i->total);\n\t\t}else{\n\t\t\tans_possible=false;\n\t\t}\n\n\t\tsum_vertex++;\n\n\t\tint32_t parent_value=i->total-(n-2*sum_vertex);\n\t\tif(flow.count(parent_value)){\n\t\t\tflow.at(parent_value).push_back(current{i->vertex,sum_vertex});\n\t\t}else{\n\t\t\tvector<current> temp2;\n\t\t\ttemp2.push_back(current{i->vertex,sum_vertex});\n\t\t\tflow.emplace(parent_value,temp2);\n\t\t}\n\n\t}\n\tif(flow.size()==1&&ans_possible&&ans.size()==(n-1)){\n\t\tfor(auto i=ans.begin();i!=ans.end();i++){\n\t\t\tcout<<i->v1<<\" \"<<i->v2<<endl;\n\t\t}\n\t}else{\n\t\tcout<<-1<<endl;\n\t}\n\n\n\n\n\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nusing ll =long long;\nll n;\nvector<pair<ll,ll> >e;\nvector<ll>size;\nmap<ll,ll>mp;\nint main(){\n    ll tmp;\n    scanf(\"%lld\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%lld\",&tmp);\n        mp[tmp]=i;\n        e.push_back(make_pair(tmp,i));   \n    }\n    sort(e.rbegin(),e.rend());\n    vector<pair<ll,ll>>ans;\n    vector<ll>size(n,1);\n    vector<ll>dp(n,0);\n    ll x = e.back().first;\n    for(auto c:e){\n        if(c.first!=x){\n            if(size[c.second]*2>=n){\n                cout<<\"-1\";\n                return 0;\n            }\n            ll pre = c.first - n + 2 * size[c.second];\n            if(!mp.count(pre)){\n                cout<<\"-1\";\n                return 0;\n            }\n            ll par = mp[pre];\n            dp[par] += dp[c.second] + size[c.second];\n            size[par] += size[c.second];\n            ans.push_back(make_pair(c.second+1,par+1));\n        }\n    }\n     if(dp[e.back().second]!=x){\n        cout<<\"-1\";\n        return 0;\n    }\n    for(auto c: ans){\n        if(c.second < c.first)cout<<c.second <<' '<<c.first<<endl;\n        else cout<<c.first <<' '<<c.second <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct union_find{\n\tstatic const int DEFAULT = 200200;\n\tvector<int> parent;\n\tint N;\n\tunion_find(int N = DEFAULT) : N(N) {\n\t\tclear();\n\t}\n\tvoid clear(){\n\t\tparent.assign(N, -1);\n\t}\n\tint find(int u){\n\t\treturn (parent[u] < 0) ? u : parent[u] = find(parent[u]);\n\t}\n\tbool is_connected(int u, int v){\n\t\treturn find(u) == find(v);\n\t}\n\tbool join(int u, int v){\n\t\tu = find(u);\n\t\tv = find(v);\n\t\tif (u != v){\n\t\t\tif (parent[u] > parent[v])\n\t\t\t\tswap(u, v);\n\t\t\tparent[u] += parent[v];\n\t\t\tparent[v] = u;\n\t\t}\n\t\treturn u != v;\n\t}\n\tint size(int u){\n\t\treturn -parent[find(u)];\n\t}\n};\nint main(){\n\tint n; cin >> n;\n\tvector<pair<long long, int> > vals;\n\tmap<long long, int> rev;\n\tunion_find uf(n);\n\tlong long sum = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tlong long x; cin >> x;\n\t\trev[x] = i;\n\t\tvals.push_back({x, i});\n\t\tsum += x;\n\t}\n\tif(sum&1){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tvector<pair<int,int> > edges;\n\tsort(vals.rbegin(), vals.rend());\n\tfor(int i = 0; i < n - 1; i++){\n\t\tlong long cost; int u;\n\t\ttie(cost, u) = vals[i];\n\t\tint sz = uf.size(u);\n\t\tlong long ncost = cost - n + 2 * sz;\n\t\tauto it = rev.find(ncost); \n\t\tif(it == rev.end()){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint x = u, y = it->second;\n\t\tif(x == y){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(x > y) swap(x, y);\n\t\tedges.push_back({x, y});\n\t\tuf.join(x, y);\t\n\t}\n\tsort(edges.begin(), edges.end());\n\tfor(auto e : edges) cout << e.first + 1 << \" \" << e.second + 1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100000 + 5;\n\nmap< int64_t, int, greater< int64_t > > D;\nint sz[ N ];\nint64_t arr[ N ], ans[ N ];\nvector< int > G[ N ];\nbool vis[ N ];\n\ninline void sosad() {\n\tcout << -1 << '\\n';\n\texit( 0 );\n}\n\nvoid dfs1( int u ) {\n\tif ( vis[ u ] ) sosad();\n\tvis[ u ] = true;\n\tfor ( int v : G[ u ] ) {\n\t\tdfs1( v );\n\t\tans[ u ] += sz[ v ] + ans[ v ];\n\t}\n}\n\nvoid dfs2( int u, int n, int64_t fa ) {\n\tfa += n - sz[ u ];\n\tfor ( int v : G[ u ] )\n\t\tdfs2( v, n, fa + ans[ u ] - sz[ v ] - ans[ v ] );\n\tans[ u ] += fa;\n}\n\nint main() {\n\tios_base::sync_with_stdio( false );\n\tcin.tie( nullptr );\n\tint n; cin >> n;\n\tfor ( int i = 1 ; i <= n ; ++ i ) {\n\t\tint64_t x; cin >> x;\n\t\tD[ x ] = i; sz[ i ] = 1;\n\t\tarr[ i ] = x;\n\t}\n\tint rt = -1;\n\tfor ( auto pi : D ) {\n\t\tif ( sz[ pi.second ] == n ) {\n\t\t\trt = pi.second;\n\t\t\tbreak;\n\t\t}\n\t\tint64_t fad = pi.first - n + 2 * sz[ pi.second ];\n\t\tif ( D.find( fad ) == D.end() ) sosad();\n\t\tsz[ D[ fad ] ] += sz[ pi.second ];\n\t\tG[ D[ fad ] ].push_back( pi.second );\n\t}\n\tif ( rt == -1 ) sosad();\n\tdfs1( rt ); dfs2( rt, n, 0 );\n\tfor ( int i = 1 ; i <= n ; ++ i )\n\t\tif ( arr[ i ] != ans[ i ] or not vis[ i ] )\n\t\t\tsosad();\n\tfor ( int i = 1 ; i <= n ; ++ i )\n\t\tfor ( int j : G[ i ] )\n\t\t\tcout << i << ' ' << j << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {cww() {CIN_ONLY{ios::sync_with_stdio(false); cin.tie(0);}}\n}star;\n#define DEBUG if(0)\n#endif\n\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}\ntemplate <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}\ntemplate <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}\n\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }};\n\nint n;\n\nint a[112345];\nint b[112345];\npair<LL,int> d[112345];\nint sub[112345];\nvector<vector<int>> g;\npair<LL,int> f(int v,int p) {\n\tpair<LL, int> ret = { 0ll,1 };\n\tfor (int u : g[v]) {\n\t\tif (p == u)continue;\n\t\tauto cret=f(u, v);\n\t\tret.first += cret.first;\n\t\tret.second += cret.second;\n\t}\n\tret.first += ret.second;\n\treturn ret;\n}\nbool check() {\n\tg.resize(n);\n\tfor (int i : range(n - 1)) {\n\t\tg[a[i]].push_back(b[i]);\n\t\tg[b[i]].push_back(a[i]);\n\n\t}\n\tLL A = f(0, 0).first - n;\n\tLL B = d[0].first;\n\treturn A == B;\n}\nint main() {\n\tcin >> n;\n\tif (n % 2 == 0) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tfor (int i : range(n)) {\n\t\tcin >> d[i].first;\n\t\td[i].second = i + 1;\n\t}\n\tsort(d, d + n);\n\treverse(d, d + n);\n\tfor (int i : range(n))sub[i] = 1;\n\tmap<LL, int> id;\n\tfor (int i : range(n))id[d[i].first] = i;\n\tfor (int i : range(n - 1)) {\n\t\tLL k = sub[i];\n\t\tLL rest = n - sub[i];\n\t\tLL nxt_dist = d[i].first + k - rest;\n\t\tif (id.count(nxt_dist) == 0) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint j = id[nxt_dist];\n\t\ta[i] = i;\n\t\tb[i] = j;\n\t\tsub[j] += sub[i];\n\t}\n\n\tif (check()) {\n\t\tfor (int i : range(n - 1)) {\n\t\t\tcout << d[a[i]].second << \" \" << d[b[i]].second << endl;\n\t\t}\n\t}\n\telse {\n\t\tcout << -1 << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#define int long long\n#define ll long long\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nconst int N = 1e5 + 1000;\nint n,num; ll dis,siz[N];\nint u[N],to[N];\nstruct node\n{\n\tll v; int id;\n\tint friend operator <(node a,node b){return a.v < b.v;}\n}p[N];\nsigned main()\n{\n\tn = read();\n\tfor(int i = 1;i <= n;i ++) {p[i] = node{read(),i}; siz[i] = 1;}\n\tsort(p + 1,p + 1 + n);\n\tfor(int i = n;i > 1;i --)\n\t{\n\t\tll Dis = p[i].v - n + (siz[i] << 1);\n\t\tint t = lower_bound(p + 1,p + 1 + n,node{Dis,0}) - p;\n\t\tif(p[t].v != Dis) {puts(\"-1\"); return 0;}\n\t\tnum ++; u[num] = p[i].id; to[num] = p[t].id;\n\t\tsiz[t] += siz[i]; dis += siz[i]; \n\t}\n\tcout << dis << \"\\n\";\n\tif(dis != p[1].v) {puts(\"-1\"); return 0;}\n\telse for(int i = 1;i < n;i ++) cout << u[i] << \" \" << to[i] << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define dbg1(x) cerr<<#x<<\"=\"<<(x)<<\" \"\n#define dbg2(x) cerr<<#x<<\"=\"<<(x)<<\"\\n\"\n#define dbg3(x) cerr<<#x<<\"\\n\"\nusing namespace std;\n#define se second\n#define fi first\n#define reg register\n#define mp make_pair\n#define int ll\ninline ll read()\n{\n\tll x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nconst int MN=1e5+5;\nll N,D[MN],siz[MN],fa[MN];\nstruct edge{int to,nex;}e[MN<<1];int hr[MN],en;\nvoid ins(int x,int y){e[++en]=(edge){y,hr[x]};hr[x]=en;}\npair<ll,ll> a[MN];\nint dfs(int x)\n{\n\treg int i;int r=0;\n\tfor(i=hr[x];i;i=e[i].nex) r+=dfs(e[i].to)+siz[e[i].to];\n\treturn r;\n}\nsigned main()\n{\n\tN=read();reg int i,j;\n\tfor(i=1;i<=N;++i) D[i]=read(),a[i]=mp(D[i],i);\n\tstd::sort(a+1,a+N+1);\n\tfor(i=N;i>1;--i)\n\t{\n\t\tint x=a[i].se;\n\t\t++siz[x];\n\t\tint pos=lower_bound(a+1,a+N+1,mp(D[x]+2*siz[x]-N,0))-a;\n\t\tif(pos>=i||D[x]+2*siz[x]-N!=a[pos].fi) return 0*puts(\"-1\");\n\t\tfa[x]=a[pos].se;siz[fa[x]]+=siz[x];ins(fa[x],x);\n\t}\n\t++siz[a[1].se];\n\tif(dfs(a[1].se)!=D[a[1].se]) return 0*puts(\"-1\");\n\tfor(i=1;i<=N;++i)for(j=hr[i];j;j=e[j].nex)printf(\"%d %d\\n\",i,e[j].to);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define llong long long \n#define xx first\n#define yy second\n#define len(x) ((int)x.size())\n#define rep(i,n) for (int i = -1; ++ i < n; )\n#define rep1(i,n) for (int i = 0; i ++ < n; )\n#define all(x) x.begin(), x.end()\n\n#define maxn 101010\nint n;\nint nchild[maxn];\nmap<llong, int> inv_d;\n\nint main(void) {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n;\n    rep1(i, n) {\n      llong d; cin >> d;\n      inv_d[d] = i;\n    }\n    rep1(i, n) nchild[i] = 1;\n\n    vector<pair<int, int>> ans;\n    while (len(inv_d) > 1) {\n      llong d = inv_d.rbegin()->xx;\n      int u = inv_d.rbegin()->yy;\n      inv_d.erase(--inv_d.end());\n      llong td = d - 1ll * (n - 2 * nchild[u]);\n      // clog << u << ' ' << d << ' ' << nchild[u] << endl;\n      if (!inv_d.count(td)) {\n        cout << \"-1\";\n        return 0;\n      }\n      int v = inv_d[td];\n      ans.push_back({u, v});\n      // clog << u << ' ' << v << endl;\n      nchild[v] += nchild[u];\n    }\n    llong droot = inv_d.begin()->xx;\n    int root = inv_d.begin()->yy;\n    llong s = 0;\n    rep1(i, n) if (i != root) s += nchild[i];\n    // clog << root << ' ' << s << endl;\n    if (s != droot) {\n      cout << -1;\n      return 0;\n    }\n    rep(i, n - 1) cout << ans[i].xx << ' ' << ans[i].yy << '\\n';\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\ntypedef long long ll;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = (x << 1) + (x << 3) + (c & 15); x *= f;\n\t}\n\t// input a letter\n\ttemplate <class I>\n\tinline void get (I &x) {\n\t\tfor (c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tx = c;\n\t}\n\t// input a string\n\tinline void read (char *s){\n\t\tfor(c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tfor(; c >= 'A' && c <= 'Z'; c = gc()) *++s = c;\n\t\t*++s = '\\0';\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: gi;\nusing io :: get;\nusing io :: read;\nusing io :: putc;\nusing io :: print;\nconst int N=1e5+5;\nll d[N];\nint sz[N];\nstruct node{\n\tint x;\n\tll nowd;\n\tnode(){}\n\tnode(int _x,ll _nowd) : x(_x) , nowd(_nowd) {}\n\tinline bool operator <(const node &rhs)const{\n\t\treturn nowd>rhs.nowd;\n\t}\n};\nmultiset<node> s;\nvector<int> e[N];\nint n;\ninline void dfs2(ri x,ll now){\n\tif(d[x]!=now)\n\t\tputs(\"-1\"),exit(0);\n\tfor(int o:e[x])\n\t\tdfs2(o,now-sz[o]+n-sz[o]);\n}\nint main(){\n\tri i;\n\tll res;\n\tgi(n);\n\tfor(i=1;i<=n;++i) gi(d[i]),s.insert(node(i,d[i]));\n\tres=0;\n\twhile(s.size()>1){\n\t\tnode o=*s.begin();\n\t\ts.erase(s.begin());\n\t\t++sz[o.x];\n\t\tset<node> ::iterator it=s.find(node(0,d[o.x]-n+2*sz[o.x]));\n\t\tif(it==s.end())\n\t\t\treturn puts(\"-1\"),0;\n\t\tsz[it->x]+=sz[o.x];\n\t\te[it->x].push_back(o.x);\n\t\tres+=sz[o.x];\n\t}\n//\tprintf(\"res = %lld\\n\",res);\n\tdfs2(s.begin()->x,res);\n\tfor(i=1;i<=n;++i)\n\t\tfor(auto o:e[i])\n\t\t\tprint(i),putc(' '),print(o),putc('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <string.h>\n#include <stack>\n#define Endl endl\n#define mp make_pair\n#define ll long long \n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define over(A) {cout<<A<<endl;exit(0);}\n#define all(A) A.begin(),A.end()\n#define ceil(a,b) ((a-1)/b+1)\n#define srand() mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n#define rand(l,r) uniform_int_distribution<int>(l,r)(rng)\ntypedef unsigned long long ull;\nconst int inf=1039074182;\nusing namespace std;\nll n;\nll d[100005];\nmap <ll,ll> m;\npair<ll,ll> p[100005];\nll sub[100005];\nll sz[100005];\nvector <pair<ll,ll> >res;\n\nint main()\n{\n//\tfreopen(\"input.txt\",\"r\",stdin);\n\tios_base::sync_with_stdio(false);\n\tcin>>n;\n\tfor(ll i=0;i<n;i++)\n\t{\n\t\tcin>>d[i];\n\t\tm[d[i]]=i;\n\t\tp[i].first=d[i];\n\t\tp[i].second=i;\n\t\tsz[i]=1;\n\t}\n\tsort(p,p+n);\n\treverse(p,p+n);\n\tmemset(sub,-1,sizeof(sub));\n\tfor(ll i=0;i<n-1;i++)\n\t{\n\t\tll de=p[i].first;\n\t\tll x=p[i].second;\n\t\tsub[x]=n-sz[x]*2;\n//\t\tcout<<x+1<<'-'<<de<<'-'<<sub[x]<<'-'<<sz[i]<<endl;\n\t\tif(sub[x]==0) over(\"-1\");\n\t\tif(m.find(de-sub[x])==m.end()) over(\"-1\");\n\t\tll par=m[de-sub[x]];\n\t\tsz[par]+=sz[x];\n\t\tres.push_back(mp(x,par));\n\t}\n\tfor(ll i=0;i<n-1;i++)\n\t{\n\t\tcout<<res[i].first+1<<' '<<res[i].second+1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <string.h>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <cassert>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <sstream>\n#include <functional>\n#include <iomanip>\n#include <bitset>\n//#include <windows.h>  //Should be deleted when using AtCoder&POJ\nusing namespace std;\n\n#define ll long long\n#define pii pair<int,int>\n#define qi ios::sync_with_stdio(0)\n/**==Info==\n*Program:6\n*Problem:Distance Sums\n*Date:2019-7-12\n*Algorithm:Orange Boy's Greedy and Sorting\n*Stats:Unknown*/\n\nbool debug=false;\n\n\ntemplate<typename T1,typename T2> ostream& operator<<(ostream& o,pair<T1,T2> p){\n\to<<\"{\";\n\to<<p.first<<\",\"<<p.second;\n\to<<\"}\";\n\treturn o;\n}\n\nll n;\nll d[100005];\nmap <ll,ll> m;\npair<ll,ll> p[100005];\nll sub[100005];\nll sz[100005];\nvector <pair<ll,ll> >res;\n \n int fa[100005];\n \nint getFa(int x){\n\tif(fa[x]==x){\n\t\treturn x;\n\t}\n\treturn fa[x]=getFa(fa[x]);\n}\n \n \nvoid Union(int a,int b){\n\tif(fa[a]==fa[b]){\n\t\treturn;\n\t}\n\tfa[getFa(a)]=getFa(b);\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\",\"r\",stdin);\n\tios_base::sync_with_stdio(false);\n\tcin>>n;\n\tfor(ll i=0;i<n;i++)\n\t{\n\t\tcin>>d[i];\n\t\tif(d[i]>n*(n-1)/2){\n\t\t\tcout<<-1;\n\t\t\treturn 0;\n\t\t}\n\t\tm[d[i]]=i;\n\t\tp[i].first=d[i];\n\t\tp[i].second=i;\n\t\tsz[i]=1;\n\t}\n\tsort(p,p+n);\n\treverse(p,p+n);\n\tmemset(sub,-1,sizeof(sub));\n\tfor(ll i=0;i<n-1;i++)\n\t{\n\t\tll de=p[i].first;\n\t\tll x=p[i].second;\n\t\tsub[x]=n-sz[x]*2;\n\t\tif(sub[x]==0){\n\t\t\tcout<<-1;\n\t\t\treturn 0;\t\n\t\t}\n\t\tif(m.find(de-sub[x])==m.end()){\n\t\t\tcout<<-1;\n\t\t\treturn 0;\n\t\t}\n\t\tll par=m[de-sub[x]];\n\t\tsz[par]+=sz[x];\n\t\tres.push_back(make_pair(x,par));\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tfa[i]=i;\n\t}\n\tfor(pii x:res){\n\t\tUnion(x.first,x.second);\n\t}\n\t\n\tset<int> fafa;\n\tfor(int i=0;i<n;i++){\n\t\tfafa.insert(getFa(i));\n\t}\n\tif(fafa.size()!=1){\n\t\tcout<<\"-1\";\n\t\treturn 0;\n\t}\n\t\n\tfor(ll i=0;i<n-1;i++)\n\t{\n\t\tcout<<res[i].first+1<<\" \"<<res[i].second+1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (lli i = 0; i < (n); i++)\n#define rrep(i, n) for (lli i = (n)-1; i >= 0; i--)\nusing namespace std;\nusing lli = long long int;\nvoid no(){\n    cout << -1 << endl;\n    exit(0);\n}\nvector<int> ans[100005];\nbool paint[100005] = {};\nlli n;\nlli par[100005] = {};\nlli tree_size[100005] = {};\nlli tmp[100005] = {};\nlli dp[100005] = {};\nlli very[100005] = {};\nlli fi(int u,int p){\n    for(auto s:ans[u]){\n        if(s != p){\n            dp[u] += fi(s, u) + tree_size[s];\n        }\n    }\n    very[u] = dp[u];\n    return dp[u];\n}\nvoid calc(int u,int p){\n    if(u!=0){\n        very[u] = very[p] + n - 2 * tree_size[u];\n    }\n    for(auto s:ans[u]){\n        if(p!=s)\n            calc(s, u);\n    }\n}\nlli recalc_size(int u, int p){\n    tree_size[u] = 1;\n    for(auto s:ans[u]){\n        if(s==p)continue;\n        tree_size[u] += recalc_size(s,u);\n    }\n    //cout << u << \" \" << tree_size[u] << endl;\n    return tree_size[u];\n}\nvoid check_and_emit(){\n    rep(i,n){\n        if(par[i]!=-1)\n        {\n            ans[i].push_back(par[i]);\n            ans[par[i]].push_back(i);\n        }\n    }\n    recalc_size(0,-1);\n    fi(0,-1);\n    calc(0,-1);\n    rep(i,n){\n        if(very[i] != tmp[i]){\n            no();\n        }\n    }\n    rep(i,n){\n        for(auto s:ans[i]){\n            if(s>i)\n            cout << i+1 << \" \" << s+1 << endl;\n        }\n    }\n}\n\n\n\nint main() {\n    cin >> n;\n    vector<pair<lli,lli>> d(n);\n    map<lli,lli> m;\n    rep(i,n){\n        cin >> d[i].first,d[i].second = i;\n        tmp[i] = d[i].first;\n        m[d[i].first] = i;\n        par[i] = -1;\n    }\n    sort(d.begin(),d.end());\n    reverse(d.begin(),d.end());\n    vector<bool> used(n);\n    if(n==2){\n        cout << -1 << endl;\n        return 0;\n    }\n    rep(i,n)tree_size[i] = 1;\n    rep(i,n-1){\n        int cur = d[i].second;\n        // 現在のcurが属する部分木の大きさ\n        lli next = d[i].first - n + 2 * tree_size[cur];\n        //cout << next << endl;\n        if(next >= d[i].first ){\n            no();\n        }else {\n            if(m.find(next) == m.end()){\n                no();\n            }\n            par[cur] = m[next];\n            tree_size[m[next]] += tree_size[cur];\n        }\n    }\n    check_and_emit();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long  long\n#define N 100010\nstruct node{\n\tint x,id;\n\tbool operator<(const node &a) const{\n\t\treturn x>a.x;\n\t}\n}D[N];\nint sz[N],fa[N];\nmap<int,int>mp;\nsigned main(){\n\tint n;\n\tscanf(\"%lld\",&n);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&D[i].x);\n\t\tD[i].id=i;\n\t\tmp[D[i].x]=i;\n\t}\n\tsort(D+1,D+1+n);\n\tfor (int i=1;i<=n;i++) sz[i]=1;\n\tfor (int i=1;i<n;i++){\n\t\tint x=D[i].id;\n\t\tfa[x]=mp[D[i].x-n+2*sz[x]];\n\t\tif (!fa[x])  return puts(\"-1\"),0;\n\t\tsz[fa[x]]+=sz[x];\n\t}\n\tfor (int i=1;i<n;i++) D[n].x-=sz[D[i].id];\n\tif (D[n].x) return puts(\"-1\"),0;\n\tfor (int i=1;i<n;i++) printf(\"%lld %lld\\n\",fa[D[i].id],D[i].id);\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef pair<ll,ll> P;\nlong long int INF = 1e18;\ndouble Pi = 3.1415926535897932384626;\nlong long int mod = 1000000007;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"RULD\";\n//↓,→,↑,←\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,a,b) for(i=a;i<=b;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\n\n\n\nll i,j,k,ii,jj;\nll n,m,num;\nll a,b,c,e,f,g,h;\nll x[800005],y[800005],z[900005],w[500005];\nll d[800005],dp[500005];\nll no[500005];\nchar s[500005];\nll len[500];\nll vnum = 0;\nbool dame;\n\n\nvoid unite(ll a,ll b){\n    x[vnum] = a;\n    y[vnum] = b;\n    G[a].pb(b);\n    G[b].pb(a);\n    vnum++;\n}\n\nint main(){\n    cin>>n;\n    for(i=0;i<n;i++){\n        cin>>d[i];\n        z[i] = d[i];\n        no[i] = d[i];\n    }\n    sort(d,d+n);\n    for(i=0;i<n;i++){\n        z[i] = (lb(d,d+n,z[i]) - d) * 100000 + i;\n    }\n    sort(z,z+n);\n    //reverse(d,d+n);\n    for(i=n-1;i>=1;i--){\n        //大きい数字から見て行くよ\n        dp[i]++;\n        num = d[i] - n + 2* dp[i];\n        a = lb(d,d+n,num) - lb(d,d+n,-1);\n        if(d[a] != num){\n            //p(\"dame\");\n            //p(a);\n            //p(num);\n            dame = true;\n            break;\n        }else{\n            dp[a] = dp[i];\n            unite(a+1,i+1);\n        }\n    }\n    if(dame){\n        p(-1);\n        return 0;\n    }else{\n        for(i=0;i<vnum;i++){\n            pe(z[x[i]-1]%100000 + 1);p(z[y[i]-1]%100000 + 1);\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 100020\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define inf 0x3f3f3f3f\ntypedef long long ll;\ntypedef pair<int,int> pr;\n\nll d[maxn],f[maxn];\nstruct node{\n\tint next,to;\n}e[maxn * 2];\nint head[maxn],cnt;\nint n,fa[maxn],sz[maxn],dth[maxn];\n\ninline void adde(int x,int y){\n\te[++cnt].to = y;\n\te[cnt].next = head[x];\n\thead[x] = cnt;\n}\t\nvoid dfs(int x){\n\tfore(i,x){\n\t\tdth[e[i].to] = dth[x] + 1;\n\t\tdfs(e[i].to);\n\t}\n}\nbool check(){\n\tdfs(1);\n\trep(i,1,n) f[1] += dth[i];\n\trep(i,2,n){\n\t\tf[i] = f[fa[i]] + n - sz[i] * 2;\n\t\tif ( f[i] != d[i] ) return 0;\n\t}\n\treturn 1;\n}\nbool solve(){\n\trepd(i,n,2){\n\t\tsz[i]++;\n\t\tll curd = d[i] - n + 2 * sz[i];\n\t\tint id = lower_bound(d + 1,d + n + 1,curd) - d;\n\t\tif ( d[id] != curd || id >= i ) return 0;\n\t\tfa[i] = id , sz[id] += sz[i];\n\t}\n\trep(i,2,n) adde(fa[i],i);\n\treturn check();\n}\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n) scanf(\"%lld\",&d[i]);\n\tsort(d + 1,d + n + 1);\n\tif ( solve() ){\n\t\trep(i,2,n) printf(\"%d %d\\n\",fa[i],i);\n\t}\n\telse{\n\t\tprintf(\"-1\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reg register\n#define pr std::pair<ll, int>\n#define fi first\n#define se second\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define lep(i, l, r) for (int i = l; i < r; ++i)\n#define irep(i, r, l) for (int i = r; i >= l; --i)\n#define ilep(i, r, l) for (int i = r; i > l; --i)\n#define Rep(i, n) rep(i, 1, n)\n#define Lep(i, n) lep(i, 1, n)\n#define IRep(i, n) irep(i, n, 1)\n#define ILep(i, n) ilep(i, n, 1)\ntypedef long long ll;\ntypedef long double ld;\n\nnamespace modular {\n    const int MOD = 1000000007;\n    inline int add(int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n    inline void inc(int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n    inline int mul(int x, int y) { return 1LL * x * y % MOD; }\n    inline int qpow(int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x))\n            if (y & 1)\n                ans = mul(ans, x);\n        return ans;\n    }\n}; // namespace modular\n\nnamespace Base {\n    template <typename Tp> inline Tp input() {\n        Tp x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-')\n                y = -1;\n            c = getchar();\n        }\n        if (c == EOF)\n            return 0;\n        while ('0' <= c && c <= '9')\n            x = x * 10 + c - '0', c = getchar();\n        return x *= y;\n    }\n    template <typename Tp> inline void read(Tp &x) { x = input<Tp>(); }\n    template <typename Tp> inline void chmax(Tp &x, Tp y) { x < y ? x = y : 0; }\n    template <typename Tp> inline void chmin(Tp &x, Tp y) { x > y ? x = y : 0; }\n}; // namespace Base\nusing namespace Base;\n/*----------------------------------------------------------------------------*/\n\n#define MAX_N 200007\n#define V std::vector\n\nint N;\nint sz[MAX_N];\nll d[MAX_N];\npr a[MAX_N];\nV<int> G[MAX_N];\nstd::map<ll, int> mp;\n\nvoid dfs1(int x, int las) {\n    sz[x] = 1;\n    for (int y : G[x])\n        if (y != las) {\n            dfs1(y, x);\n            sz[x] += sz[y];\n            d[x] += d[y] + sz[y];\n        }\n}\n\nbool dfs2(int x, int las) {\n    if (mp[d[x]] != x)\n        return false;\n    for (int y : G[x])\n        if (y != las) {\n            d[y] = d[x] + N - 2 * sz[y];\n            if (!dfs2(y, x))\n                return false;\n        }\n    return true;\n}\n\nvoid solve() {\n    std::sort(a + 1, a + N + 1);\n    Rep(i, N) sz[i] = 1, mp[a[i].fi] = a[i].se;\n    ILep(i, N) {\n        int u = a[i].se, s = N - 2 * sz[u], v;\n        if (mp.count(a[i].fi - s)) {\n            v = mp[a[i].fi - s];\n            sz[v] += sz[u];\n            G[u].push_back(v);\n            G[v].push_back(u);\n        } else\n            return puts(\"-1\"), void();\n    }\n    dfs1(1, 0);\n    if (!dfs2(1, 0))\n        return puts(\"-1\"), void();\n    Rep(i, N) {\n        for (int j : G[i])\n            if (i < j)\n                printf(\"%d %d\\n\", i, j);\n    }\n}\n\nint main() {\n#ifdef LOCAL\n    FIN(\"in\");\n#endif\n    read(N);\n    Rep(i, N) read(a[i].fi), a[i].se = i;\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+5;\nint n,f[N],si[N];\nstruct node\n{\n    ll x;\n    int id;\n    bool operator<(const node&o)const\n    {\n        return x<o.x;\n    }\n}a[N];\nunordered_map<ll,int>mp;\nvector<pair<int,int> >v;\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%lld\",&a[i].x),a[i].id=i;\n    sort(a+1,a+1+n);\n    for(int i=1;i<=n;i++) si[i]=1,f[i]=a[i].id,mp[a[i].x]=i;\n    for(int i=n;i>=1;i--)\n    {\n        ll t=a[i].x+si[i]-(n-si[i]);\n        if(mp[t]&&mp[t]!=i) v.push_back({i,mp[t]}),si[mp[t]]+=si[i];\n    }\n    if(si[1]!=n) {printf(\"-1\\n\");return 0;}\n    else for(int i=0;i<v.size();i++)\n        printf(\"%d %d\\n\",f[v[i].first],f[v[i].second]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN=3e5+7;\n\nll from[MAXN],to[MAXN];\n\nmap<ll,ll> Map;\n\nll n;\nll a[MAXN],b[MAXN],siz[MAXN],sum[MAXN];\n\nbool cmp(const ll &A,const ll &B){return a[A]>a[B];}\nbool cmp2(const ll &A,const ll &B){return A>B;}\n\nint minn1,minn2;\n\nint main() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) {\n\t\tcin>>a[i];\n\t\tb[i]=i;\n\t\tMap[a[i]]=i;\n\t\tsiz[i]=1;\n\t\tif(minn1>a[i]) {\n\t\t\tminn1=a[i];\n\t\t\tminn2=i;\n\t\t}\n\t}\n\tsort(b+1,b+1+n,cmp);\n\tsort(a+1,a+1+n,cmp2);\n\tfor(ll i=1,i2;i<n;i++) {\n\t\ti2=Map[a[i]-abs(n-2*siz[b[i]])];\n\t\tif(i2!=0&&a[i]-abs(n-2*siz[b[i]])!=a[i]) {\n\t\t\tsiz[i2]+=siz[b[i]];\n\t\t\tsum[i2]+=sum[b[i]]+siz[b[i]];\n\t\t\tfrom[i]=i2;\n\t\t\tto[i]=b[i];\n\t\t}\n\t\telse {\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif(minn1!=sum[minn2]) {\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<n;i++) {\n\t\tcout<<from[i]<<\" \"<<to[i]<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MN 100005\nint T,n,id[MN];\nll a[MN];\nmap<ll,int>rea,cnt;\nstruct node{int x,y;};\nvector<node>sc;\nbool cmp(int x,int y){return a[x]>a[y];}\nint main(){\n//\tfreopen(\"test.in\",\"r\",stdin);\n//\tfreopen(\"mysol.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),rea[a[i]]=i,cnt[a[i]]=1,id[i]=i;\n\tsort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<n;i++){\n\t\tint t=id[i];ll tmp=a[t]-n+2*cnt[a[t]];\n\t\tif(rea[tmp]&&tmp<a[t]){\n\t\t\tcnt[tmp]+=cnt[a[t]];\n\t\t\tsc.push_back((node){t,rea[tmp]});\n\t\t}\n\t\telse return 0*puts(\"-1\");\n\t}\n\tfor(int i=0;i<sc.size();i++)printf(\"%d %d\\n\",sc[i].x,sc[i].y);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nint main() {\n\tint N;\n\tcin >> N;\n\tvector<long long> D(N);\n\tvector<int> p(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> D[i];\n\t\tp[i] = i;\n\t}\n\tsort(p.begin(), p.end(), [&](int i, int j) { return D[i] > D[j]; });\n\tvector<long long> ds = D;\n\tfor (int i = 0; i < N; ++i) ds[i] *= -1;\n\tsort(ds.begin(), ds.end());\n\tvector<int> cnt(N, 1);\n\tbool ok = true;\n\tvector<pair<int, int> > edges;\n\tfor (int i = 0; i < N - 1; ++i) {\n\t\tlong long tar = -ds[i] - (N - 2 * cnt[p[i]]);\n\t\tint u = lower_bound(ds.begin(), ds.end(), -tar) - ds.begin();\n\t\tif (u == N || -ds[u] != tar) {\n\t\t\tok = false;\n\t\t\tbreak;\n\t\t}\n\t\tcnt[p[u]] += cnt[p[i]];\n\t\tedges.push_back(make_pair(p[u], p[i]));\n\t}\n\tlong long sum = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (i != p[N - 1]) {\n\t\t\tsum += cnt[i];\n\t\t}\n\t}\n\tif (sum != -ds[N - 1]) ok = false;\n\tif (!ok) {\n\t\tcout << -1 << endl;\n\t}\n\telse {\n\t\tfor (pair<int, int> i : edges) {\n\t\t\tcout << i.first + 1 << ' ' << i.second + 1 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(a) sort(a.begin(), a.end())\n#define Reverse(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\ntemplate<typename T>\nvoid debug(vector<vector<T>> m){ REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;} }\n\nstruct edge{int to, cost;};\n\nclass Graph\n{\npublic:\n    int V;\n    vector<vector<edge>> G;\n\n    Graph(int V): V(V){\n        G = vector<vector<edge>>(V, vector<edge>(0));\n    }\n\n    void add_edge(int from, int to, int cost){\n        G[from].push_back(edge({to, cost}));\n    }\n\n    void add_edge2(int v1, int v2, int cost){\n        add_edge(v1, v2, cost);\n        add_edge(v2, v1, cost);\n    }\n\n    void dfs(int &n, bools &used, int v){\n        n++;\n        used[v] = true;\n        REP(k, G[v].size()) if(!used[G[v][k].to]) dfs(n, used, G[v][k].to);\n    }\n\n};\n\nsigned main(){\n\n    int N; cin >> N;\n    vector<Pii> D(N);\n    REP(i, N){\n        cin >> D[i].first;\n        D[i].second = i;\n    }\n    Sort(D); Reverse(D);\n\n    vec g(N, -1);\n    map<int, set<int>> par;\n    vector<Pii> ans(0);\n    \n    REP(i, N){\n        int d = D[i].first;\n        int v = D[i].second;\n        int cnt = 1;\n        for(int c: par[d]){\n            cnt += g[c];\n            ans.push_back(Pii(v, c));\n        }\n        g[v] = cnt;\n        par[d - (N - 2 * cnt)].insert(v);\n    }\n\n    Graph G(N);\n    REP(i, ans.size()){\n        G.add_edge2(ans[i].first, ans[i].second, 0);\n    }\n    int n = 0;\n    bools used(N, false);\n    G.dfs(n, used, 0);\n    if(n == N && ans.size() == N - 1){\n        REP(i, N - 1) cout << ans[i].first + 1 << \" \" << ans[i].second + 1 << endl;\n    }else{\n        cout << -1;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define RI register int\ntypedef long long LL;\n#define int LL\n\n#define FILEIO(name) freopen(name\".in\", \"r\", stdin), freopen(name\".out\", \"w\", stdout);\n\nusing namespace std;\n\nchar buf[1000000], *p1 = buf, *p2 = buf;\ninline char gc() {\n  if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin);\n  return p1 == p2 ? EOF : *(p1++);\n}\ntemplate <class T> inline void read(T &n) {\n  n = 0; RI ch = gc(), f;\n  while ((ch < '0' || ch > '9') && (ch != '-')) ch = gc();\n  f = (ch == '-' ? ch = gc(), -1 : 1);\n  while (ch >= '0' && ch <= '9') n = n * 10 + (ch ^ 48), ch = gc();\n  n *= f;\n}\n\nint const MAXN = 1e5 + 5;\npair <int, int> G[MAXN], t[MAXN];\nmap <int, int> mp;\nint size[MAXN];\n\nsigned main() {\n\n#ifdef LOCAL\n  FILEIO(\"a\");\n#endif\n\n  int n; read(n);\n  for (RI i = 1; i <= n; ++i)\n    read(t[i].first), t[i].second = i, mp[t[i].first] = i;\n  sort(t + 1, t + 1 + n);\n  int edge = 0;\n  for (RI i = n; i > 1; --i) {\n    ++size[t[i].second];\n    int to = t[i].first - n + 2 * size[t[i].second];\n    if (to >= t[i].first) continue;\n    if (mp.find(to) != mp.end()) {\n      size[mp[to]] += size[t[i].second];\n      G[++edge] = make_pair(mp[to], t[i].second);\n    }\n  }\n  if (edge != n - 1) puts(\"-1\");\n  else\n    for (RI i = 1; i <= edge; ++i)\n      printf(\"%d %d\\n\", G[i].first, G[i].second);\n  \n  cerr << (double)(clock()) / CLOCKS_PER_SEC * 1000 << \"ms\" << endl;\n\n  return 0;\n}\n\n// created by Daniel yuan"
  },
  {
    "language": "C++",
    "code": "/*\nThough leaves are many , the root is one.\nThrough all the lying days of my youth\nI swayed my leaves and flowers in the sun.\nNow I may wither into the truth.\n\t  \t  \t- William Butler Yeats\n*/\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n#include<bits/stdc++.h>\n#pragma comment(\" -Wl,--stack=1024000000\")\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\ntypedef long long ll;\n#ifndef LOCAL\n#define cerr if(0)cout\n#define eprintf(...) 0\n#else\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#endif\ninline string getstr(string &s,int l,int r){string ret=\"\";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){if(y==0)return 1;int ret=modpow(x,y>>1,md);ret=(ll)ret*ret%md;if(y&1)ret=(ll)ret*x%md;return ret;}\nint n;\nll d[100005];\nint sz[100005];\nmap<ll,int>mp;\nvector<int>g[100005];\nvector<pair<int,int> >ans;\nll sum=0;\nvoid dfs(int x,int par,int dep){\n\tsum+=dep;\n\tfor(int i=0;i<g[x].size();i++){\n\t\tint to=g[x][i];\n\t\tif(to!=par)dfs(to,x,dep+1);\n\t}\n}\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>d[i];mp[d[i]]=i;sz[i]=1;\n\t}\n\twhile(mp.size()>1){\n\t\tpair<ll,ll>p=*mp.rbegin();\n\t\tmp.erase(p.first);\n\t\tll x=p.second,val=p.first;\n\t\tll nxt_v=sz[x]*2+val-n;\n\t\tif(!mp.count(nxt_v)){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}else{\n\t\t\tint y=mp[nxt_v];\n\t\t\tsz[y]+=sz[x];\n\t\t\tg[x].push_back(y);\n\t\t\tg[y].push_back(x);\n\t\t\tans.push_back(make_pair(x,y));\n\t\t}\n\t}\n\tdfs(mp.begin()->second,-1,0);\n\tif(sum!=mp.begin()->first){\n\t\tputs(\"-1\");\n\t}else{\n\t\tfor(int i=0;i<ans.size();i++){\n\t\t\tcout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define RI register int\ntypedef long long LL;\n\n#define FILEIO(name) freopen(name\".in\", \"r\", stdin), freopen(name\".out\", \"w\", stdout);\n\nusing namespace std;\n\nchar buf[1000000], *p1 = buf, *p2 = buf;\ninline char gc() {\n  if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin);\n  return p1 == p2 ? EOF : *(p1++);\n}\ntemplate <class T> inline void read(T &n) {\n  n = 0; RI ch = gc(), f;\n  while ((ch < '0' || ch > '9') && (ch != '-')) ch = gc();\n  f = (ch == '-' ? ch = gc(), -1 : 1);\n  while (ch >= '0' && ch <= '9') n = n * 10 + (ch ^ 48), ch = gc();\n  n *= f;\n}\n\nint const MAXN = 1e5 + 5;\npair <int, int> G[MAXN], t[MAXN];\nmap <int, int> mp;\nint size[MAXN];\n\nint main() {\n\n#ifdef LOCAL\n  FILEIO(\"a\");\n#endif\n\n  int n; read(n);\n  for (RI i = 1; i <= n; ++i)\n    read(t[i].first), t[i].second = i, mp[t[i].first] = i;\n  sort(t + 1, t + 1 + n);\n  int edge = 0;\n  for (RI i = n; i > 1; --i) {\n    ++size[t[i].second];\n    int to = t[i].first - n + 2 * size[t[i].second];\n    if (to >= t[i].first) continue;\n    if (mp.find(to) != mp.end()) {\n      size[mp[to]] += size[t[i].second];\n      G[++edge] = make_pair(mp[to], t[i].second);\n    }\n  }\n  if (edge != n - 1) puts(\"-1\");\n  else\n    for (RI i = 1; i <= edge; ++i)\n      printf(\"%d %d\\n\", G[i].first, G[i].second);\n  \n  cerr << (double)(clock()) / CLOCKS_PER_SEC * 1000 << \"ms\" << endl;\n\n  return 0;\n}\n\n// created by Daniel yuan"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(i,a,n) for(int i=a;i<=n;++i)\n#define PER(i,a,n) for(int i=n;i>=a;--i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(a) ({REP(__i,1,n) cout<<a[__i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\n\n\nconst int N = 1e6+10;\nint n, sz[N];\nstruct _ {\n\tll d;\n\tint id;\n\tbool operator < (const _ &rhs) const {\n\t\treturn d<rhs.d;\n\t}\n} a[N];\nvector<pii> ans;\nvector<int> g[N];\n\nvoid add(int u, int v) {\n\tans.pb(pii(u,v));\n\tg[u].pb(v),g[v].pb(u);\n}\n\nvoid dfs(int x, int f, int d) {\n\ta[1].d -= d;\n\tfor (int y:g[x]) if (y!=f) dfs(y,x,d+1);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tREP(i,1,n) { \n\t\tscanf(\"%lld\",&a[i].d);\n\t\ta[i].id = i, sz[i] = 1;\n\t}\n\tsort(a+1,a+1+n);\n\tPER(i,2,n) {\n\t\t_ u{a[i].d+2*sz[a[i].id]-n,0};\n\t\tauto p = lower_bound(a+1,a+1+n,u);\n\t\tif (p->d!=u.d) return puts(\"-1\"),0;\n\t\tadd(a[i].id,p->id), sz[p->id] += sz[a[i].id];\n\t}\n\tdfs(1,0,0);\n\tif (a[1].d||sz[a[1].id]!=n) return puts(\"-1\"),0;\n\tfor (auto &t:ans) printf(\"%d %d\\n\",t.x,t.y);\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int N=1e5+10;\nll sz[N];\nll fa[N],d[N];\nint n,m;\nbool solve(){\n\tint pre;\n\tsort(d+1,d+1+n);\n\tfor (int i=1;i<=n;++i) sz[i]=1;\n\tfor (int i=n;i>=2;--i){\n\t\tpre=lower_bound(d+1,d+1+n,d[i]-n+2*sz[i])-d;\n\t\tif (d[pre]!=d[i]-n+2*sz[i]) return false;\n\t\tfa[i]=pre; \n\t\tsz[fa[i]]+=sz[i];\n\t}\n\treturn true;\n}\n\nint main(){\n#ifndef ONLINE_JUDGE\n\t//freopen(\"a.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;++i) scanf(\"%lld\",d+i);\n\tif (solve()){\n\t\tfor (int i=2;i<=n;++i) cout<<fa[i]<<\" \"<<i<<endl;\n\t}\n\telse\n\t\tprintf(\"-1\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<algorithm>\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\ntypedef long long ll;\nconst int N=200200;\nint n,u,t,o[N],sz[N],fa[N];\nll a[N];\nmap<ll,int>h;\nbool cmp(int x,int y){return a[x]>a[y];}\nint main(){\n\tscanf(\"%d\",&n);\n\tFOR(i,1,n) scanf(\"%lld\",&a[i]),h[a[i]]=o[i]=i,sz[i]=1;\n\tsort(o+1,o+n+1,cmp);\n\tFOR(i,1,n-1){\n\t\tu=o[i];t=a[u]+2*sz[u]-n;\n\t\tif(!h.count(t) || h[t]==u) return puts(\"-1\");\n\t\tsz[fa[u]=h[t]]+=sz[u];\n\t}\n\tFOR(i,1,n)if(fa[i]) cout<<i<<' '<<fa[i]<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MX=1e5+5;\npair<long long,int> a[MX];\nmap<long long,int> mp;\nint n;\nint p[MX];\nint s[MX];\nint main(){\n    cin.tie(0);\n    cout.tie(0);\n    ios_base::sync_with_stdio(0);\n    cin>>n;\n    int i;\n    for(i=1 ; i<=n ; i++){\n        cin>>a[i].first;\n        a[i].second=i;\n        mp[a[i].first]=i;\n    }\n    sort(a+1,a+n+1);\n    for(i=n ; i>=2 ; i--){\n      ///  cout<<i<<endl;\n        s[a[i].second]++;\n        int k=mp[a[i].first+2*s[a[i].second]-n];\n        if(k==0 || k==a[i].second){\n            cout<<-1;\n            return 0;\n        }\n        s[k]+=s[a[i].second];\n        p[a[i].second]=k;\n    }\n    for(i=2 ; i<=n ;i++){\n        cout<<i<<\" \"<<p[i]<<\"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<map>\n#include<algorithm>\n#define MAXN 100010\n#define LL long long\nusing namespace std;\nLL d[MAXN],dis[MAXN],siz[MAXN];\nint n,cnt; \nmap<LL,int> mp;\nstruct Edge{int u,v;}E[MAXN];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&d[i]);\n\tfor(int i=1;i<=n;i++) mp[d[i]]=i;\n\tsort(d+1,d+n+1);\n\tfor(int i=1;i<=n;i++) siz[i]=1;\n\t//d0=di+m-(n-m)=di+2m-n;\n\tfor(int i=n;i>1;i--){ \n\t\tint u=mp[d[i]];\n\t//\tcout<<u<<' '<<d[i]<<endl;\n\t\tint d0=d[i]+2*siz[u]-n;\n\t\tint v=mp[d0];\n\t//\tcout<<\"-----\"<<v<<' '<<d0<<endl; \n\t\tif(v){\n\t\t\tsiz[v]+=siz[u];\n\t\t\tdis[v]+=(dis[u]+siz[u]);\n\t\t\tE[++cnt].u=min(u,v);\n\t\t\tE[cnt].v=max(u\t,v);\n\t\t}\n\t\telse{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif(dis[mp[d[1]]]!=d[1]){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=cnt;i++) printf(\"%d %d\\n\",E[i].u,E[i].v);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<algorithm>\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\ntypedef long long ll;\nconst int N=200200;\nint n,u,o[N],sz[N],fa[N];\nll t,a[N],su[N];\nmap<ll,int>h;\nbool cmp(int x,int y){return a[x]>a[y];}\nint main(){\n\tscanf(\"%d\",&n);\n\tFOR(i,1,n) scanf(\"%lld\",&a[i]),h[a[i]]=o[i]=i,sz[i]=1;\n\tsort(o+1,o+n+1,cmp);\n\tFOR(i,1,n-1){\n\t\tu=o[i];t=a[u]+2*sz[u]-n;\n\t\tif(!h.count(t) || h[t]==u || fa[h[t]]) return puts(\"-1\"),0;\n\t\tsz[fa[u]=h[t]]+=sz[u];\n\t\tsu[fa[u]]+=su[u]+sz[u];\n\t}\n\tif(su[o[n]]!=a[o[n]]) return puts(\"-1\"),0;\n\tFOR(i,1,n)if(fa[i]) cout<<i<<' '<<fa[i]<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=a; i<=b; i++)\n#define per(i,a,b) for (register int i=a; i>=b; i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ninline void read(ll &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 666666;\nll n,s[N],a[N],size[N],used[N],d[N];\nbool cmp(int x, int y){return a[x]>a[y];}\nmap<ll,int>Map;Vi b,c;\nint main() {\n\tread(n);rep(i,1,n)read(a[i]),s[i]=i;sort(s+1,s+n+1,cmp);\n\trep(i,1,n)size[i]=1,Map[a[i]]=i;\n\trep(i,1,n-1){\n\t\tint u=s[i];used[u]=1;\n\t\tint f=Map[a[u]-(n-2*size[u])];d[f]+=d[u]+size[u];\n\t\tif(!f||used[f]){puts(\"-1\");return 0;}\n\t//\tprintf(\"e %d %d\\n\",u,f);\n\t\tb.pb(u);c.pb(f);size[f]+=size[u];\n\t}\n\tif(d[s[n]]!=a[s[n]]){puts(\"-1\");return 0;}\n\tper(i,SZ(b)-1,0)printf(\"%d %d\\n\",b[i],c[i]);\n//\trep(i,1,n-1)if(a[s[i]])\n//\trep(i,1,n-1)printf(\"%lld %lld\\n\",s[i],s[i+1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 100003\nusing namespace std;\nstruct edge{int to,next;}e[maxn<<1];\nint head[maxn],cnte,fa[maxn];\nvoid add(int u,int v){e[++cnte].to=v,e[cnte].next=head[u],head[u]=cnte;}\nint n,sz[maxn],s[maxn];\nlong long d[maxn],sum;\nmap<long long,int> b;\nbool cmp(int x,int y){return d[x]<d[y];}\nvoid dfs(int u,int depth){\n\tsum+=depth;\n\tfor(int i=head[u];i;i=e[i].next){\n\t\tint v=e[i].to;\n\t\tif(v==fa[u])continue;\n\t\tdfs(v,depth+1);\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",d+i),s[i]=i,b[d[i]]=i,sz[i]=1;\n\tsort(s+1,s+n+1,cmp);\n\tfor(int i=n;i>=2;i--){\n\t\tint v=s[i];\n\t\tlong long d_u=d[v]-(n-sz[v])+sz[v];\n\t\tif(d_u>=d[v]||!b.count(d_u)){puts(\"-1\");return 0;}\n\t\tint u=b[d_u];\n\t\tadd(u,v),add(v,u),fa[v]=u;\n\t\tsz[u]+=sz[v];\n\t}\n\tif(cnte!=(n-1)*2){puts(\"-1\");return 0;}\n\tdfs(s[1],0);\n\tif(sum!=d[s[1]]){puts(\"-1\");return 0;}\n\tfor(int u=1;u<=n;u++){\n\t\tfor(int i=head[u];i;i=e[i].next){\n\t\t\tint v=e[i].to;\n\t\t\tif(v==fa[u])continue;\n\t\t\tprintf(\"%d %d\\n\",u,v);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=100005;\nint n,size[N],st[N],to[N];\nstruct note{\n\tlong long dis;\n\tint x;\n}d[N];\nbool cmp(note x,note y){\n\treturn x.dis>y.dis;\n}\nusing std::map;\nmap<long long,int> m;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) {\n\t\tscanf(\"%lld\",&d[i].dis);\n\t\td[i].x=i;\n\t\tm[d[i].dis]=i;\n\t}\n\tstd::sort(d+1,d+n+1,cmp);\n\tfor (int i=1;i<=n;i++) size[i]=1;\n\tfor (int i=1;i<n;i++){\n\t\tlong long dis=d[i].dis;\n\t\tint x=d[i].x;\n\t\tlong long t=dis-abs(n-2*size[x]);\n\t\tint fa=m.find(t)->second;\n\t\tif (fa==x || !fa){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsize[fa]+=size[x];\n\t\tst[i]=x,to[i]=fa;\n\t}\n\tfor (int i=1;i<n;i++) printf(\"%d %d\\n\",st[i],to[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=1e5+10;;\nint n,pos[maxn];\nint fa[maxn],siz[maxn];\nll D[maxn];\nbool cmp(int i,int j){return D[i]<D[j];}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",D[i]),pos[i-1]=i;\n\tsort(pos,pos+n,cmp);\n\tll D0=0;\n\tfor(int *p=pos+n;--p>pos;){\n\t\tD0+=siz[*p]++;\n\t\tD[*p]-=n-2*siz[*p];\n\t\tint *j=lower_bound(pos,p,*p,cmp);\n\t\tif(j<p&&D[*j]==D[*p]) siz[fa[*p]=*j]+=siz[*p];\n\t\telse{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif(D0+n-1!=D[*pos]) puts(\"-1\");\n\telse for(int*p=pos+n;--p>pos;) printf(\"%d %d\\n\",*p,fa[*p]); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define exi return puts(\"-1\"),0\nconst int N=100005;\nusing namespace std;\ntypedef long long ll;\nint n,no[N],sz[N],f[N],de[N];\npair<ll,int>d[N];\nll tp,ans;\nmap<ll,int>mp;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\tscanf(\"%lld\",&d[i].first),\n\td[i].second=i,sz[i]=1;\n\tsort(d+1,d+n+1);\n\tfor(int i=1;i<=n;i++)\n\tmp[d[i].first]=i;\n\tfor(int i=n;i>1;i--){\n\t\ttp=d[i].first+2*sz[i]-n;\n\t\t//cerr<<d[i].first<<\":\"<<tp<<endl;\n\t\tif(sz[i]*2>=n||!mp[tp])exi;\n\t\tf[i]=mp[tp],sz[mp[tp]]+=sz[i];\n\t}\n\t//cerr<<\"??\\n\";\n\tfor(int i=2;i<=n;i++)\n\tde[i]=de[f[i]]+1,ans+=de[i];\n\tif(ans^d[1].first)exi;\n\tfor(int i=2;i<=n;i++)\n\tprintf(\"%d %d\\n\",d[i].second,d[f[i]].second);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nmap <ll, int> mp;\nll arr[100010], dep[100010];\nint u[100010], v[100010], deg[100010];\n\nint main() {\n\tint n;\n\tll vv, aa = 0;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%lld\", &vv);\n\t\tarr[i] = vv;\n\t\tmp[vv] = i + 1;\n\t\tif (!i) aa = vv;\n\t}\n\tint cnt = 0;\n\tsort(arr, arr + n, greater <ll> ());\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint k = mp[arr[i]];\n\t\tint ct = mp.count(arr[i] - n + 2 + deg[k] * 2);\n\t\tif (!ct) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tu[cnt] = k;\n\t\tv[cnt] = mp[arr[i] - n + 2 + deg[k] * 2];\n\t\tdeg[v[cnt]] += deg[u[cnt]] + 1;\n\t\tdep[v[cnt]] += dep[u[cnt]] + deg[v[cnt]];\n\t\t++cnt;\n\t}\n\tif (dep[1] != aa) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < cnt; ++i)\n\t\tprintf(\"%d %d\\n\", u[i], v[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<vector>\n#include<queue>\n#include<deque>\n#define ll long long\n#define mp make_pair\n#define rep(i,x,y) for(int i=(x);i<=(y);++i)\n#define r0p(i,n) for(int i=0;i<n;++i)\n#pragma GCC optimize(1)\n#pragma G++ optimize(1)\n#pragma GCC optimize(2)\n#pragma G++ optimize(2)\n#pragma GCC optimize(3)\n#pragma G++ optimize(3)\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#define pii pair<int,int>\n#pragma GCC diagnostic error \"-std=c++11\"\nusing namespace std;\ninline void rdl(long long &val){\n    long long x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n\t}\n\twhile(ch>='0' and ch<='9'){\n\t    x=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n    val=x*f;\n}\ninline void rdi(int &val){\n    int x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    val=x*f;\n}\ninline long long rdl(){\n    long long x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline int rdi(){\n    int x=0;\n    int f=1;\n\tchar ch=getchar();\n\twhile((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n\tif(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline void write(int x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\ninline void _write(int x){\n\twrite(x);\n\tputchar(' ');\n}\ninline void print(int x){\n\twrite(x);\n\tputchar('\\n');\n}\ninline void write(ll x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\ninline void _write(ll x){\n\twrite(x);\n\tputchar(' ');\n}\ninline void print(ll x){\n\twrite(x);\n\tputchar('\\n');\n}\nstruct dsu{\n\tint par[200200];\n\tinline void init(int _n){for(int i=0;i<_n;++i) par[i]=i;}\n\tinline int find(int now){\n\t\tif(par[now]==now) return now;\n\t\treturn par[now]=find(par[now]);\n\t}\n\tinline bool uni(int a, int b){\n\t\tint Pa(find(a)),Pb(find(b));\n\t\tif(Pa==Pb) return false;\n\t\tpar[Pa]=Pb;\n\t\treturn true;\n\t}\n};\nint n;\nvector<pair<ll,int> >e;\nmap<ll,int> m;\nconst int mxn=100005;\nvector<pair<int,int> >ans;\nint main(){\n\tint i,j;ll x;\n\trdi(n);\n\tfor(i=0;i<n;++i){\n\t\trdl(x);\n\t\tm[x]=i;\n\t\te.push_back(mp(x,i));\n\t}\n\tsort(e.rbegin(),e.rend());\n\tvector<int> sz(n,1);\n\tvector<ll> dp(n);\n\tx=e.back().first;\n\tfor(auto c:e){\n\t\tif(c.first!=x){\n\t\t\tif(sz[c.second]==2*n) return 0*puts(\"-1\");\n\t\t\tll need=c.first-(n-2*sz[c.second]);\n\t\t\tif(!m.count(need)) return 0*puts(\"-1\");\n\t\t\tint par=m[need];\n\t\t\tdp[par]+=dp[c.second]+sz[c.second];\n\t\t\tsz[par]+=sz[c.second];\n\t\t\tans.push_back(mp(c.second+1,par+1));\n\t\t}\n\t}\n\tif(dp[e.back().second]!=x) return 0*puts(\"-1\");\n\tfor(auto c:ans) _write(c.first),print(c.second);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\n\nconst int MAXN = 1e5 + 5;\nint n, par[MAXN], mn;\nll d, sz[MAXN], h[MAXN], sum = 0;\nmap <ll, ll> mp;\nvector <int> adj[MAXN];\nbool can = false, mark[MAXN];\nvector <pair<ll, int>> v;\n\nvoid dfs(int v, int parv){\n\tmark[v] = true;\n\tsum += h[v];\n\tfor(auto u: adj[v]){\n\t\tif(!mark[u]){\n\t\t\th[u] = h[v] + 1ll;\n\t\t\tdfs(u, v);\n\t\t}\n\t\telse if(u != parv)\n\t\t\tcan = true;\n\t}\n\treturn;\n}\n\nbool check(){\n\tfor(int i = 1; i <= n; i++)\n\t\tif(i != mn && (par[i] < 1 || par[i] > n)){\n\t\t\treturn true;\n\t\t}\n\tdfs(mn, -1);\n\tfor(int i = 1; i <= n; i++)\n\t\tif(!mark[i])\n\t\t\tcan = true;\n\tif(sum != -v[n - 1].first)\n\t\tcan = true;\n\treturn can;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor(ll i = 1; i <= n; i++){\n\t\tcin >> d; sz[i] = 1ll;\n\t\tmp[d] = i;\n\t\tv.push_back({-d, i});\n\t}\n\tsort(v.begin(), v.end());\n\tfor(int i = 0; i < n - 1; i++){\n\t\td = -v[i].first;\n\t\tll ind = v[i].second;\n\t\tll dpar = d + (2ll * sz[ind]) - (ll)n;\n\t\tif(!mp[dpar] || mp[dpar] == ind){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tpar[ind] = mp[dpar];\n\t\tsz[par[ind]] += sz[ind];\n\t\tadj[par[ind]].push_back(ind);\n\t\tadj[ind].push_back(par[ind]);\n\t}\n\tmn = v[n - 1].second;\n\tif(check()){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tfor(int i = 0; i < n - 1; i++){\n\t\tcout << par[v[i].second] << \" \" << v[i].second << '\\n';\n\t}\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define str string\n#define fi first\n#define se second\n#define pb push_back\n#define SET(a, b) memset(a, b, sizeof(a))\n#define eps 1e-6\n#define pi atan(1) * 4\n#define mod 1000000007\n#define inf 1000000000\n#define llinf 1000000000000000000\n#define FOR(i, a, b, c) for (int i = (a); i <= (b); i += (c))\n#define FORD(i, a, b, c) for (int i = (a); i >= (b); i -= (c))\n#define FORl(i, a, b, c) for (ll i = (a); i <= (b); i += (c))\n#define FORDl(i, a, b, c) for (ll i = (a); i >= (b); i -= (c))\nusing namespace std;\nmap<ll, ll> inp;\npll order[100005];\nint sze[100005];\nint main () {\n\tint n;\n\tscanf(\"%d\", &n);\n\tFOR(i, 1, n, 1) {\n\t\tll t;\n\t\tscanf(\"%lld\", &t);\n\t\torder[i] = {t, i};\n\t\tinp[t] = i;\n\t\tsze[i] = 1;\n\t}\n\tsort(order + 1, order + n + 1);\n\tvector<pii> elist;\n\tFORD(i, n, 2, 1) {\n\t\tauto u = order[i];\n\t\tint s = sze[u.se];\n\t\tll nd = u.fi - (n - sze[u.se]) + sze[u.se];\n\t\tif (inp.find(nd) == inp.end() || inp[nd] == u.se) {\n\t\t\tprintf(\"-1\\n\"); return 0;\n\t\t}\n\t\telist.pb({u.se, inp[nd]});\n\t\tsze[inp[nd]] += sze[u.se];\n\t}\n\t/* for (auto &e : elist) {\n\t\tif (e.fi > e.se) swap(e.fi, e.se);\n\t}\n\tsort(elist.begin(), elist.end()); */\n\tfor (auto e : elist) {\n\t\tprintf(\"%d %d\\n\", e.fi, e.se);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 5;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nll d[MAXN]; bool vis[MAXN]; map <ll, int> home;\nvector <int> a[MAXN]; pair <ll, int> b[MAXN];\nint f[MAXN], s[MAXN], size[MAXN];\nvoid dfs(int pos, int fa) {\n\tsize[pos] = 1;\n\tfor (auto x : a[pos])\n\t\tif (x != fa) {\n\t\t\tdfs(x, pos);\n\t\t\tsize[pos] += size[x];\n\t\t}\n}\nint main() {\n\tint n; read(n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tread(d[i]);\n\t\tf[i] = i, s[i] = 1;\n\t\tb[i] = make_pair(d[i], i);\n\t\thome[d[i]] = i;\n\t}\n\tsort(b + 1, b + n + 1);\n\treverse(b + 1, b + n + 1);\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint pos = b[i].second; vis[pos] = true;\n\t\tll another = b[i].first + s[pos] - (n - s[pos]);\n\t\tif (home.count(another) == 0 || vis[home[another]]) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint res = home[another];\n\t\tf[pos] = f[res], s[res] += s[pos];\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (vis[i]) {\n\t\t\ta[i].push_back(f[i]);\n\t\t\ta[f[i]].push_back(i);\n\t\t}\n\tdfs(1, 0);\n\tll res = 0;\n\tfor (int i = 2; i <= n; i++)\n\t\tres += size[i];\n\tif (res == d[1]) {\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tif (vis[i]) printf(\"%d %d\\n\", i, f[i]);\n\t} else puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MN 100000\npair<long long,int> p[MN+5];\nint s[MN+5];long long S[MN+5];\nvector< pair<int,int> > ans;\nint main()\n{\n\tint n,i;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i)scanf(\"%lld\",&p[i].first),p[i].second=i,s[i]=1;\n\tsort(p+1,p+n+1);\n\tfor(i=n;i>1;--i)\n\t{\n\t\tif(n-2*s[i]<0)return 0*puts(\"-1\");\n\t\tint x=lower_bound(p+1,p+n+1,make_pair(p[i].first-n+2*s[i],0))-p;\n\t\tif(p[x].first!=p[i].first-n+2*s[i])return 0*puts(\"-1\");\n\t\ts[x]+=s[i];S[x]+=S[i]+s[i];ans.push_back(make_pair(p[x].second,p[i].second));\n\t}\n\tif(S[1]!=p[1].first)return 0*puts(\"-1\");\n\tfor(i=0;i<ans.size();++i)printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int Maxn=100005;\nint n,sz[Maxn],id[Maxn];\nll d[Maxn],sum;\nvector<pair<int,int>>edge;\nvector<int>son[Maxn];\nvoid dfs1(int x,int dis=0){\n    sum+=dis;\n    for(int y:son[x])\n        dfs1(y,dis+1);\n}\nvoid dfs2(int x,ll sum){\n    if(sum!=d[x]){\n        cout<<\"-1\\n\";\n        exit(0);\n    }\n    for(int y:son[x])\n        dfs2(y,sum+n-2*sz[y]);\n}\nint main(){\n    scanf(\"%d\",&n);\n    map<ll,int>Map;\n    for(int i=1;i<=n;i++)scanf(\"%lld\",&d[i]),Map[d[i]]=i;\n    for(int i=1;i<=n;i++)id[i]=i;\n    sort(id+1,id+n+1,[](int x,int y){return d[x]>d[y];});\n    for(int i=1;i<n;i++){\n        int x=id[i];\n        sz[x]+=1;\n        ll v=d[x]-n+2*sz[x];\n        int y=Map[v];\n        if(!y){\n            cout<<\"-1\\n\";\n            return 0;\n        }\n        sz[y]+=sz[x];\n        son[y].push_back(x);\n        edge.emplace_back(x,y);\n    }\n    dfs1(id[n]);\n    dfs2(id[n],sum);\n    for(auto i:edge)\n        cout<<i.first<<\" \"<<i.second<<\"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> pii;\n\npii inp[100005];\nint siz[100005];\nvector<pii> ans;\n\nint main() {\n\tint N; scanf(\"%d\", &N);\n\tfor (int i = 1; i <= N; i++) {\n\t\tll x; scanf(\"%lld\", &x);\n\t\tinp[i] = {x, i};\n\t\tsiz[i] = 1;\n\t}\n\tsort(inp + 1, inp + N + 1);\n\tfor (int i = N; i >= 2; i--) {\n\t\tint cur, id;\n\t\ttie(cur, id) = inp[i];\n\t\tint del = N - 2 * siz[id];\n\t\tauto it = *lower_bound(inp + 1, inp + i, pii(cur - del, 0));\n\t\tif (it.first != cur - del || del <= 0) return !printf(\"-1\");\n\t\tsiz[it.second] += siz[id];\n\t\tif (id > it.second) swap(id, it.second);\n\t\tans.push_back({id, it.second});\n\t}\n\tsort(ans.begin(), ans.end());\n\n\tfor (pii &x : ans) {\n\t\tprintf(\"%lld %d\\n\", x.first, x.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+3;\nint n,siz[N];\nstruct syzs{\n\tlong long val;\n\tint num;\n} a[N];\nstruct ans{\n\tint e1,e2;\n\tbool operator <(const ans &emm) const{\n\t    if(emm.e1==e1) return e2>emm.e2;\n\t\treturn emm.e1<e1;\n\t}\n};\nbool cmp(syzs c,syzs b){\n\treturn c.val>b.val;\n}\nlong long find(int k){\n\tlong long chec=a[k].val+2*siz[k]-n;\n\tfor(long long i=k+1;i<=n;i++) if(a[i].val==chec) return i;\n\treturn -1;\n}\nint main(){\n\tpriority_queue <ans> q;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i].val);\n\t\ta[i].num=i;\n\t\tsiz[i]=1;\n\t}\n\tsort(a+1,a+n+1,cmp);\n\tfor(int i=1;i<n;i++){\n\t\tint v=find(i);\n\t\tif(v==-1){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[v]+=siz[i];\n\t\tq.push((ans) {min(a[v].num,a[i].num),max(a[v].num,a[i].num)});\n\t}\n\twhile(!q.empty()){\n\t\tint v1=q.top().e1,v2=q.top().e2;\n    \tq.pop();\n    \tprintf(\"%d %d\\n\",v1,v2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXn = 1e5 + 10;\ntypedef pair<long long, int> pii;\npii ar[MAXn];\nlong long n, sz[MAXn], root, disroot, d[MAXn], hp3[MAXn];\nvector<int> vec[MAXn];\nvector<pii> ans;\n\nbool cmp(pii p1, pii p2) {\n\treturn p1.first > p2.first;\n}\n\n//long long dfs1(int v, int  par) {\n//\tlong long res = 0;\n//\tfor (int i = 0; i < vec[v].size(); i++)\n//\t\tif (vec[v][i] != par) {\n//\t\t\tres += dfs1(vec[v][i], v) + hp3[vec[v][i]];\n//\t\t\thp3[v] += hp3[vec[v][i]];\n//\t\t}\n//\thp3[v]++;\n//\n//\treturn res;\n//\t\n//}\n//\n//void dfs2(int v, int par, long long sth) {\n//\tif (sth != d[v]) {\n//\t\tcout << -1;\n//\t\texit(0);\n//\t}\n//\tfor (int i = 0; i < vec[v].size(); i++) {\n//\t\tif (vec[v][i] != par) {\n//\t\t\tdfs2(vec[v][i], v, sth - (hp3[vec[v][i]]) + (hp3[ar[0].second] - hp3[vec[v][i]]));\n//\t\t\t\n//\t\t}\n//\t\t\n//\t}\n//\t\n//}\nint main() {\n\t//ios::sync_\n\tcin >> n;\n\tfill_n(sz, MAXn, 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tlong long di;\n\t\tcin >> di;\n\t\td[i] = di;\n\t\tar[i].first = di;\n\t\tar[i].second = i;\n\t}\n\tsort(ar, ar + n);\n\tfor (int i = n - 1; i > 0; i--) {\n\t\tlong long hp = ar[i].first - n;\n\t\thp += 2LL * sz[ar[i].second];\n\t\tint hp2 = lower_bound(ar, ar + n, pii(hp, -1)) - ar;\n\t\tif (ar[hp2].first != hp)\n\t\t\treturn cout << -1,0;\n\t\tsz[ar[hp2].second] += sz[ar[i].second];\n\t\tvec[ar[hp2].second].push_back(ar[i].second);\n\t\tvec[ar[i].second].push_back(ar[hp2].second);\n\t\tans.push_back(pii(ar[i].second, ar[hp2].second));\n\t}\n//\tdisroot = dfs1(ar[0].second, -1);\n//\tdfs2(ar[0].second, -1, disroot);\n\tif (ans.size() != n - 1)\n\t\treturn cout << -1,0;\n\tfor (int i = 0; i < ans.size(); i++)\n\t\tcout << ans[i].first + 1<< ' ' << ans[i].second + 1<< endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nProblem: Distance Sums (AtCoder 4434)\nAlgorithm: Math??Graph??\nStatus:\n*/\n\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <deque>\n#include <set>\n#include <sstream>\n#include <utility>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <stack>\n#include <stdio.h>\n#include <string.h>\n\nusing namespace std;\n\n#define INF 1000000007\ntypedef long long ll;\n\nint n;\nmap<ll,int> d;\nvector<pair<ll,int> > ev;\nvector<pair<int,int> > ans;\nll dp[100005],sz[100005];\n\nvoid bye(){\n\tcout<<-1<<endl;\n\texit(0);\n}\n\nint main()\n{\n\t#ifndef ZZZYT\n\t\t//freopen(\".in\",\"r\",stdin);\n\t\t//freopen(\".out\",\"w\",stdout);\n\t#endif\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tint tmp;\n\t\tscanf(\"%d\",&tmp);\n\t\tev.push_back(make_pair(tmp,i));\n\t\td[tmp]=i;\n\t}\n\tsort(ev.rbegin(),ev.rend());\n\tint center=ev.back().first;\n\tfor(int i=0;i<n;i++)sz[i]=1;\n\tfor(int i=0;i<ev.size();i++){\n\t\tint x=ev[i].second;\n\t\tint s=ev[i].first;\n\t\tif(s!=center){\n\t\t\tif(sz[x]*2>=n)bye();\n\t\t\tll ps=s+sz[x]-(n-sz[x]);\n\t\t\tif(d.count(ps)==0)bye();\n\t\t\tint p=d[ps];\n\t\t\tsz[p]+=sz[x];\n\t\t\tdp[p]+=dp[x]+sz[x];\n\t\t\tans.push_back(make_pair(x,p));\n\t\t}\n\t}\n\tif(dp[ev.back().second]!=center)bye();\n\tfor(int i=0;i<ans.size();i++){\n\t\tprintf(\"%d %d\\n\",ans[i].first+1,ans[i].second+1);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Inf 0x3f3f3f3f\n#define rg register\nusing namespace std;\nconst int Maxn = 1e5 + 5;\ntypedef long long ll;\ntypedef ll arr[Maxn];\nll min(ll x, ll y) { return x < y ? x : y; }\nll max(ll x, ll y) { return x > y ? x : y; }\ninline ll read()\n{\n\trg ll res = 0, sign = 1;\n\trg char ch = getchar();\n\twhile (!isdigit(ch))\n\t{\n\t\tif (ch == '-')\n\t\t\tsign = -1;\n\t\tch = getchar();\n\t}\n\tdo\n\t{\n\t\tres = (res << 3) + (res << 1) + (ch ^ 48);\n\t\tch = getchar();\n\t} while (isdigit(ch));\n\treturn res * sign;\n}\nint n;\nll dist;\narr siz, fa, dis;\nstruct str\n{\n\tll d;\n\tint id;\n\tbool operator<(str A) const { return d < A.d; }\n} p[Maxn];\nvector<int>to[Maxn];\nvoid DFS(int x)\n{\n    dist+=dis[x];\n    for(rg int i=0,nx;i<to[x].size();i++)\n    {\n        nx=to[x][i];\n        dis[nx]=dis[x]+1;\n        DFS(nx);\n    }\n}\nvoid Solve(int x)\n{\n    for(rg int i=0,nx;i<to[x].size();i++)\n    {\n        nx=to[x][i];\n        dis[nx]=dis[x]+n-2*siz[nx];\n        Solve(nx);\n    }\n}\nint main()\n{\n\tint tmp, now, s;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tp[i] = {read(), i};\n\t\tsiz[i] = 1;\n\t}\n\tsort(p + 1, p + n + 1);\n\tfor (int i = n; i > 1; i--)\n\t{\n\t\tnow = p[i].id;\n\t\ttmp = p[i].d - n + 2 * siz[now];\n\t\tfa[now] = p[s = lower_bound(p + 1, p + n + 1, (str){tmp, 0}) - p].id;\n        to[fa[now]].push_back(now);\n\t\tif (p[s].d != tmp || s == i)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[fa[now]] += siz[now];\n\t}\n    DFS(p[1].id);\n    dis[p[1].id]=dist;\n    Solve(p[1].id);\n    for(int i=1;i<=n;i++)\n        if(dis[p[i].id]!=p[i].d)\n        {\n            puts(\"-1\");\n            return 0;\n        }\n\tfor (int i = 1; i <= n; i++)\n\t\tif (fa[i])\n\t\t\tprintf(\"%d %d\\n\", fa[i], i);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<iostream>\n#include<algorithm>\n#define maxn 100050\nusing namespace std;\ntypedef long long LL;\n\nint n;\nLL D[maxn];\n\nint pos[maxn];\n\nLL size[maxn];\n\nbool vis[maxn];\n\nint p[2];\nvector<int> vert[2]; \n\nvoid init()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tpos[i]=i;\n\t\tscanf(\"%lld\",&D[i]); \n\t\tvert[D[i]&1].push_back(i);\n\t}\n}\n\nbool cmp(int i,int j)\n{\n\treturn D[i]<D[j];\n}\n\nint fa[maxn];\n\nbool solve()\n{\n\tsort(pos+1,pos+n+1,cmp);\n\tsort(vert[0].begin(),vert[0].end(),cmp);\n\tsort(vert[1].begin(),vert[1].end(),cmp);\n\t\n\tsize[pos[1]]=n;\n\t++p[D[pos[1]]&1];\n\t\n\tfor (int k=1;k<=n;++k)\n\t{\n\t\tint u=pos[k],cnt=1,c=(D[u]+n)&1;\n\t\tint &j=p[c],len=vert[c].size();\n\t\tfor (;j<len&&cnt<size[u];++j)\n\t\t{\n\t\t\tint v=vert[c][j];\n\t\t\tsize[v]=(D[u]+(LL)n-D[v])>>1;\n\t\t\tcnt+=size[v];\n\t\t\tfa[v]=u;\n//\t\t\tprintf(\"%d %d\\n\",u,v);\n//\t\t\tcout<<u<<\" \"<<v<<\" \"<<size[v]<<\" \"<<cnt<<endl;\n\t\t}\n//\t\tcout<<u<<\" \"<<size[u]<<\" \"<<cnt<<endl;\n\t\tif (cnt!=size[u])\n\t\t{\n//\t\t\tcout<<\"warning:\"<<u<<endl;\n\t\t\treturn 0;\n\t\t}\n//\t\tassert(cnt==size[u]);\n\t}\n\t\n\tfor (int k=1;k<=n;++k)\n\t{\n\t\tint u=pos[k];\n\t\tif (fa[u])\n\t\t\tprintf(\"%d %d\\n\",u,fa[u]);\n\t}\n\treturn 1;\n}\n\nint main()\n{\n//    freopen(\"c.in\",\"r\",stdin);\n    init();\n    if (!solve())\n    \tprintf(\"-1\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N = 1e5 + 10;\nlong long n, d[N], s[N];\nvector<int> gr[N];\nmap<long long, int> mp;\nint32_t main() {\n\tios_base::sync_with_stdio (false), cin.tie(0), cout.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> d[i], mp[d[i]] = i;\n\tsort(d, d + n, greater<int> ());\n\tfill(s, s + n + 1, 1);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint v = mp[d[i]], valpar = d[i] - n + 2 * s[v];\n\t\tif (!mp.count(valpar)) {\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\tint par = mp[valpar];\n\t\tif (par == v) {\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\ts[par] += s[v], gr[min(v, par)].push_back(max(v, par));\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (auto u : gr[i])\n\t\t\tcout << i + 1 << \" \" << u + 1 << \"\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100001\nusing namespace std;\nstruct S{\n\tlong long w,dep;\n\tlong long u,v,ne;\n}a[N],e[N];\n\tlong long n,sz[N],dy[N],fir[N],root,vis[N],sum,pan;\n\tbool bo=false;\nvoid add(long long u,long long v){\n\te[++sum].ne=fir[u];\n\tfir[u]=sum;\n\te[sum].v=v;\n\te[sum].u=u;\n//\te[sum].w=1;\n}\nbool cmp(S x,S y){\n\treturn x.w>y.w;\n}\nvoid check(long long x,long long dis){\n//\tif(bo)return;\n\tpan+=dis;\n\tvis[x]=1;\n\tfor(long long i=fir[x];i;i=e[i].ne){\n\t\tlong long to=e[i].v;\n\t\tif(!vis[to]){\n\t\t\t//if(vis[to])bo=true;\n\t\t\tcheck(to,dis+1);\n\t\t}\n\t}\n}\nvoid dfs(long long x,long long father){\n\tvis[x]=1;\n\tfor(long long i=fir[x];i;i=e[i].ne){\n\t\tlong long to=e[i].v;\n\t\tif(to!=father&&!vis[to]){\n\t\t\tprintf(\"%lld %lld\\n\",x,to);\n\t\t\tdfs(to,x);\n\t\t}\n\t}\n}\nlong long query(long long sum){\n\tlong long l=1,r=n;\n\twhile(l<r){\n\t\tlong long mid=(l+r+1)>>1;\n\t\tif(a[mid].w>sum)l=mid;\n\t\telse if(a[mid].w<sum)r=mid-1;\n\t\telse {\n\t\t\tl=mid;\n\t\t\treturn a[l].dep;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tscanf(\"%lld\",&n);\n\tfor(long long i=1;i<=n;i++)scanf(\"%lld\",&a[i].w),sz[i]=1,a[i].dep=i;\n\tsort(a+1,a+n+1,cmp);\n\tfor(long long i=1;i<=n;i++){\n\t\tlong long tmp=n-2*sz[a[i].dep];\n\t\tlong long father=query(a[i].w-tmp);\n\t\tsz[father]+=sz[a[i].dep];\n/*\t\tif(!father){\n\t\t\tif(root){\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\troot=a[i].dep;\n\t\t}\n*/\t\tif(i!=n){\n\t\t\tadd(a[i].dep,father);\n\t\t\tadd(father,a[i].dep);\n\t\t}\n\t}\n\troot=a[n].dep;\n\tcheck(root,0);\n/*\tif(bo){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(long long i=1;i<=n;i++)if(!vis[i]){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n*/\tif(pan!=a[n].w){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tmemset(vis,0,sizeof(vis));\n\tdfs(root,0);\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <time.h>\n\n#include <stdlib.h>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <vector>\n#include <map>\nusing namespace std;\nstruct condition{\n\tint64_t vertex;\n\tint64_t total;\n};\nstruct current{\n\tint64_t parent;\n\tint64_t vertex_num;\n};\nstruct edge{\n\tint64_t v1;\n\tint64_t v2;\n};\nbool operator< (const condition& a,const condition& b){\n\treturn a.total>b.total;\n}\nint main() {\n\n\tint64_t n;\n\tcin>>n;\n\tstd::vector<condition> cd;\n\tvector<edge> ans;\n\tans.reserve(n);\n\tcd.reserve(n);\n\tfor(int64_t i=0;i<n;i++){\n\t\tint64_t temp;\n\t\tcin>>temp;\n\t\tcd.push_back(condition{i+1,temp});\n\t}\n\tbool ans_possible=true;\n\tsort(cd.begin(),cd.end());\n\tmap<int64_t,vector<current> > flow;\n\tfor(auto i=cd.begin();i!=cd.end();i++){\n\t\tbool islast = (i==cd.end()-1);\n\t\tint64_t sum_vertex=0;\n\n\t\tif(flow.count(i->total)){\n\t\t\tvector<current>& t=flow.at(i->total);\n\t\t\tint64_t total_cost=0;\n\t\t\tfor(auto k=t.begin();k!=t.end();k++){\n\t\t\t\tans.push_back(edge{k->parent,i->vertex});\n\t\t\t\tsum_vertex+=(k->vertex_num);\n\t\t\t\ttotal_cost+=((k->vertex_num)*(k->vertex_num+1))/2;\n\t\t\t}\n\t\t\tans_possible=(total_cost==i->total);\n\n\t\t\tflow.erase(i->total);\n\t\t}else{\n\t\t\tans_possible=false;\n\t\t}\n\n\t\tsum_vertex++;\n\n\t\tint64_t parent_value=i->total-(n-2*sum_vertex);\n\t\tif(!islast&&parent_value>=i->total){\n\t\t\tans_possible=false;\n\t\t\tbreak;\n\t\t}\n\t\tif(flow.count(parent_value)){\n\t\t\tflow.at(parent_value).push_back(current{i->vertex,sum_vertex});\n\t\t}else{\n\t\t\tvector<current> temp2;\n\t\t\ttemp2.push_back(current{i->vertex,sum_vertex});\n\t\t\tflow.emplace(parent_value,temp2);\n\t\t}\n\n\t}\n\tif(flow.size()==1&&ans_possible&&ans.size()==(n-1)){\n\t\tfor(auto i=ans.begin();i!=ans.end();i++){\n\t\t\tcout<<i->v1<<\" \"<<i->v2<<endl;\n\t\t}\n\t}else{\n\t\tcout<<-1<<endl;\n\t}\n\n\n\n\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "// author: Saman Mahdanian\n#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 1e5 + 10;\n\nint n, size[N], p[N];\nmap <long long, int> who_is;\nvector <int> c[N];\nlong long d[N];\n\nvoid contradict_if (bool, string = \"no exit msg\");\nlong long dfs (int, int = -1);\nint get_par (int);\n\nint32_t main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> d[i];\n\t\twho_is[d[i]] = i;\n\t}\n\n\tvector <int> ver(n);\n\tiota (ver.begin(), ver.end(), 0);\n\tsort (ver.begin(), ver.end(), [] (int a, int b) {\n\t\treturn d[a] > d[b];\n\t});\n\tint root = ver.back();\n\n\tfor (int v: ver) {\n\t\tif (v == root)\n\t\t\tcontinue;\n\n\t\tsize[v]++;\n\t\tcontradict_if (size[v] * 2 > n, \"size failture\");\n\n\t\tp[v] = get_par(v);\n\t\tsize[p[v]] += size[v];\n\t\tc[p[v]].push_back(v);\n\t}\n\n\t// cerr << \"Root: \" << root << endl;\n\tcontradict_if (dfs(root) != d[root], \"Root failed, expected:\" + to_string(d[root]) + \" found:\" + to_string(dfs(root)));\n\tfor (int v: ver)\n\t\tfor (int u: c[v])\n\t\t\tcout << v + 1 << ' ' << u + 1 << endl;\n}\n\nvoid contradict_if (bool condition, string msg) {\n\tif (!condition)\n\t\treturn;\n\tcout << -1;\n\tcerr << \" \" << msg;\n\tcout << endl;\n\texit(0);\n}\n\nint get_par (int v) {\n\tlong long pev = d[v] - n + 2 * size[v];\n\t// cout << \"looking for: \" << v << ' ' << d[v] << ' ' << size[v] << endl;\n\tcontradict_if (who_is.find(pev) == who_is.end(), \"parent not found\");\n\t// cout << \"parent of \" << v << \" is \" << who_is[pev] << endl;\n\treturn who_is[pev];\n}\n\nlong long dfs (int v, int pv) {\n\tint res = 0;\n\tfor (int u: c[v])\n\t\tres += size[u] + dfs(u, v);\n\treturn res;\n}\n\n// SamMHD :: 05/12/2018 12:30:04 :: Another Tree..."
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define debug printf(\"fuck %d\\n\", __LINE__);\ninline LL read() {\n\tLL res = 0, bo = 1;\n\tchar ch = getchar();\n\twhile(ch < '0' || ch > '9') { if (ch == '-') bo = -1; ch = getchar(); }\n\twhile(ch >= '0' && ch <= '9') { res = (res << 1) + (res << 3) + ch - '0'; ch = getchar(); }\n\treturn bo * res;\n}\ntemplate<typename T> void read(T &x) { x = read(); }\ntemplate<typename T, typename ...Argv> void read(T &a, Argv &...argv) { read(a); read(argv...); }\n\nconst int N = 2e5 + 100;\n\nstruct Edge {\n\tint to;\n\tEdge *nxt;\n\tEdge(int to, Edge *nxt) : to(to), nxt(nxt) {}\n} *head[N];\n\nstruct node {\n\tLL dis; int id;\n\tnode() {}\n\tnode(LL dis, int id) : dis(dis), id(id) {}\n\tfriend bool operator < (const node &a, const node &b) { return a.dis > b.dis; }\n} a[N];\n\nint siz[N], dis[N];\n\nstruct EDGE {\n\tint u, v;\n\tfriend bool operator < (const EDGE &a, const EDGE &b) { return a.u == b.u ? a.v < b.v : a.u < b.u; }\n} e[N];\n\nvoid dfs(int x, int fa) {\n\tdis[x] = dis[fa] + 1;\n\tfor (Edge *i = head[x]; i; i = i->nxt) {\n\t\tif (i->to == fa) continue;\n\t\tdfs(i->to, x);\n\t}\n}\n\nvoid add(int u, int v) { head[u] = new Edge(v, head[u]), head[v] = new Edge(u, head[v]); }\n\nint main() {\n\tint n = read();\n\tfor (int i = 1; i <= n; ++ i) a[i] = node(read(), i), siz[i] = 1;\n\tstd::sort(a + 1, a + n + 1);\n\tfor (int i = 1; i < n; ++ i) {\n\t\tLL d = a[i].dis - n + (siz[i] << 1);\n\t\tint l = 1, r = n, ans = 0;\n\t\twhile (l <= r) {\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tif (a[mid].dis >= d) l = mid + 1, ans = mid;\n\t\t\telse r = mid - 1;\n\t\t\tif (a[mid].dis == d) break;\n\t\t}\n\t\tif (a[ans].dis != d) { puts(\"-1\"); return 0; }\n\t\tint v = a[i].id, u = a[ans].id;\n\t\tadd(u, v); siz[ans] += siz[i];\n\t\te[i].u = std::min(u, v); e[i].v = std::max(u, v);\n\t}\n\tdfs(a[n].id, 0); LL sum = 0;\n\tfor (int i = 1; i <= n; ++ i) sum += dis[i] - 1;\n\tif (sum != a[n].dis) { puts(\"-1\"); return 0; }\n\tstd::sort(e + 1, e + n);\n\tfor (int i = 1; i < n; ++ i) printf(\"%d %d\\n\", e[i].u, e[i].v); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main() {\n\tlong long N;\n\tcin >> N;\n\tvector<pair<long long, long long> > D(N);\n\tvector<long long> E(N);\n\tvector<long long> COUNT(N, 1);\n\tvector<pair<long long, long long> > ANS;\n\tfor (int i = 0; i < N; i++) cin >> D[i].first, D[i].second = i, E[i] = D[i].first;\n\tsort(D.begin(), D.end());\n\tsort(E.begin(), E.end());\n\tfor (int i = N - 1; i > 0; i--) {\n\t\tlong long C = COUNT[D[i].second];\n\t\tlong long ND = D[i].first - (N - C * 2);\n\t\tlong long it = lower_bound(E.begin(), E.end(), ND) - E.begin();\n\t\tif (D[it].first != ND || i == it) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tANS.push_back({ D[i].second, D[it].second });\n\t\tCOUNT[D[it].second] += COUNT[D[i].second];\n\t}\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tcout << ANS[i].first + 1 << \" \" << ANS[i].second + 1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\nstruct Val{\n\tlong long d;\n\tint u;\n}p[100010];\nbool cmp(Val a,Val b)\n{\n\treturn a.d>b.d;\n}\nint find(int l,int r,long long t)\n{\n\twhile(l+1<r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(p[mid].d<=t)r=mid;\n\t\telse l=mid;\n\t}\n\tif(p[r].d!=t)return -1;\n\treturn r;\n}\nint u[100010],v[100010];\nint siz[100010];\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&p[i].d);\n\t\tp[i].u=i;\n\t}\n\tsort(p+1,p+n+1,cmp);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tsiz[i]++;\n\t\tu[i]=p[i].u;\n\t\tint pos=find(i,n,p[i].d+siz[i]-(n-siz[i]));\n\t\tif(pos==-1){\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tv[i]=p[pos].u;\n\t\tsiz[pos]+=siz[i];\n\t}\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d %d\\n\",u[i],v[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100010;\ntypedef long long int64;\n\nmap<int64 , int> val;\nint n , size[N] , fa[N];\n\nint64 d[N];\ntypedef pair<int , int> pii;\npriority_queue<pii , vector<pii> , greater<pii> > leaf;\n#define mp make_pair \n\nint main() {\n    cin >> n;\n    for(int i = 1 ; i <= n ; ++i) {\n        cin >> d[i];\n        size[i] = 1;\n        val[d[i]] = i; \n    }\n    for(int i = 1 ; i <= n ; ++i) \n        if(val.count(d[i] - n + 2)) leaf.push(mp(1 , i));\n\n    int cnt = 0;\n    while(leaf.size()) {\n        int x = leaf.top().second , ct = leaf.top().first;\n        leaf.pop();\n        if(ct != size[x]) continue;\n        \n        if(val.count(d[x] - n + size[x]*2))\n            fa[x] = val[d[x] - n + size[x]*2];\n        else continue;\n        val.erase(d[x]);\n        cnt++;\n        \n        size[fa[x]] += size[x];\n        leaf.push(mp(size[fa[x]] , fa[x]));\n    }\n    if(cnt < n - 1) cout << -1 << endl;\n    else {\n        for(int i = 1 ; i <= n ; ++i)\n            if(fa[i]) cout << i << ' ' << fa[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define No {puts(\"-1\");return 0;}\n#define fo(i,l,r) for(int i=l;i<=r;i++)\n#define of(i,l,r) for(int i=l;i>=r;i--)\n#define fe(i,u) for(int i=head[u];i;i=e[i].next)\nusing namespace std;\ntypedef long long ll;\ninline void open(const char *s)\n{\n\t#ifndef ONLINE_JUDGE\n\tchar str[20];\n\tsprintf(str,\"in%s.txt\",s);\n\tfreopen(str,\"r\",stdin);\n//\tsprintf(str,\"out%s.txt\",s);\n//\tfreopen(str,\"w\",stdout);\n\t#endif\n}\ninline ll rd()\n{\n\tstatic ll x,f;\n\tx=0;f=1ll;\n\tchar ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1ll;\n\tfor(;ch>='0'&&ch<='9';ch=getchar())x=x*10ll+ch-'0';\n\treturn f>0?x:-x;\n}\nconst int N=100010;\nstruct edge{\n\tint u,v,next;\n\tedge(int u=0,int v=0,int next=0):u(u),v(v),next(next){}\n}e[N];\nint n,siz[N],rt;ll d[N];\nint tot=0,head[N];\nstruct node{\n\tll x;int id;\n\tinline friend bool operator<(const node &a,const node &b){return a.x>b.x;}\n}q[N];\nmap<ll,int>mp;\n\ninline void add(int u,int v){e[++tot]=edge(u,v,head[u]);head[u]=tot;}\n\nvoid dfs1(int u,int dep)\n{\n\td[rt]+=dep;\n\tfe(i,u){int v=e[i].v;dfs1(v,dep+1);}\n}\nvoid dfs2(int u)\n{\n\tfe(i,u){\n\t\tint v=e[i].v;\n\t\td[v]=d[u]+ll(n-(siz[v]<<1ll));\n\t\tdfs2(v);\n\t}\n}\n\nint main()\n{\n\tn=rd();fo(i,1,n)mp[q[q[i].id=i].x=rd()]=i,siz[i]=1;\n\tsort(q+1,q+n+1);\n\tfo(i,1,n-1){\n\t\tint x=q[i].id;\n\t\tint dd=q[i].x-n+(siz[x]<<1);\n\t\tif(!mp.count(dd))No\n\t\tint fa=mp[dd];\n\t\tadd(fa,x);siz[fa]+=siz[x];\n\t}\n\trt=q[n].id;\n\tdfs1(rt,0);\n\tdfs2(rt);\n\tfo(i,1,n)if(d[q[i].id]!=q[i].x)No\n\tfo(u,1,n){\n\t\tfe(i,u){\n\t\t\tint v=e[i].v;\n\t\t\tprintf(\"%d %d\\n\",u,v);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint gae[100001];\nvector< pair<long long, int> > p;\nvector< pair<int, int> > ans;\nmap<long long, int> mp;\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    for(int i=1;i<=n;i++){\n        long long x;\n        scanf(\"%lld\", &x);\n        p.push_back({x, i});\n        gae[i] = 1;\n        mp[x] = i;\n    }\n    sort(p.begin(), p.end());\n    for(int i=n-1;i>=1;i--){\n        int target = p[i].second;\n        long long cal = p[i].first - n + gae[target] + gae[target];\n        int nxt = mp[cal];\n        //printf(\"%d %lld\\n\", nxt, cal);\n        if(nxt == 0){\n            printf(\"-1\\n\");\n            return 0;\n        }\n        gae[nxt] += gae[target];\n        ans.push_back({nxt, target});\n    }\n    for(auto &anss: ans){\n        printf(\"%d %d\\n\", anss.first, anss.second);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long li;\n\nconst int maxn = 1e5;\n\nint n, fa[maxn];\nli D[maxn];\nint size[maxn];\n\npair<li, int> ord[maxn];\nmap<li, int> id;\n\nint main(void) {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) scanf(\"%lld\", D + i);\n  for (int i = 0; i < n; ++i) ord[i] = {D[i], i};\n  for (int i = 0; i < n; ++i) id[D[i]] = i;\n  sort(ord, ord + n);\n  reverse(ord, ord + n);\n  for (int i = 0; i < n; ++i) size[i] = 1;\n\n  for (int i = 0; i < n - 1; ++i) {\n    int u = ord[i].second;\n    li del = n - size[u] * 2;\n    if (del == 0 || !id.count(D[u] - del)) {\n      puts(\"-1\");\n      return 0;\n    }\n    fa[u] = id[D[u] - del];\n    size[fa[u]] += size[u];\n  }\n\n  for (int i = 0; i < n - 1; ++i) {\n    int u = ord[i].second;\n    int v = fa[u];\n    printf(\"%d %d\\n\", u + 1, v + 1);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> d(n);\n  for(Int i=0;i<n;i++) cin>>d[i];\n  map<Int, Int> r;\n  for(Int i=0;i<n;i++) r[d[i]]=i;\n\n  vector<vector<Int> > G(n);\n  auto NO=[](){cout<<-1<<endl;exit(0);};\n  auto add_edge=[&](Int x,Int y){\n\t\t  G[x].emplace_back(y);\n\t\t  G[y].emplace_back(x);\n\t\t};\n\n  using P = pair<Int, Int>;\n  priority_queue<P> pq;\n  vector<Int> s(n,1),used(n,0);\n  for(Int i=0;i<n;i++) pq.emplace(d[i],i);\n  \n  while(pq.size()>1u){\n    Int x,v;\n    tie(x,v)=pq.top();pq.pop();\n    \n    Int nd=x-(n-s[v])+s[v];\n    if(!r.count(nd)) NO();\n    \n    Int u=r[nd];    \n    if(used[u]) NO();\n    \n    add_edge(v,u);\n    s[u]+=s[v];    \n    used[v]=1;\n  }\n\n  vector<Int> sz(n,1);\n  vector<Int> dp1(n,0),dp2(n,0);\n  function<Int(Int, Int)> dfs1=\n    [&](Int v,Int p){\n      for(Int u:G[v]){\n\tif(u==p) continue;\n\tdp1[v]+=dfs1(u,v);\n\tdp1[v]+=sz[u];\n\tsz[v]+=sz[u];\n      }\n      return dp1[v];\n    };\n  \n  function<void(Int, Int, Int)> dfs2=\n    [&](Int v,Int p,Int d){\n      Int sum=0;\n      dp2[v]=dp1[v]+d;\n      for(Int u:G[v])\n\tif(u!=p) sum+=dp1[u]+sz[u];\n      for(Int u:G[v])\n\tif(u!=p) dfs2(u,v,d+sum-(dp1[u]+sz[u])+(n-sz[u]));\n    };\n  \n  dfs1(0,-1);\n  dfs2(0,-1,0);\n\n  //for(Int i=0;i<n;i++) cout<<d[i]<<\" \"<<dp2[i]<<endl;\n  for(Int i=0;i<n;i++) if(d[i]!=dp2[i]) NO();\n  \n  for(Int v=0;v<n;v++)\n    for(Int u:G[v]) if(v<u) cout<<v+1<<\" \"<<u+1<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <long long, long long> pii;\n\nconst long long MAX_N = 1e5 + 5;\nlong long n, root;\nlong long Arr[MAX_N];\nlong long h[MAX_N];\nlong long Siz[MAX_N];\nlong long Mark[MAX_N];\nlong long par[MAX_N];\nunordered_map <long long, long long> Map;\nvector <pii> edge;\nlong long dp_d[MAX_N];\nlong long dp_u[MAX_N];\nvector <long long> child[MAX_N];\n\nbool cmp(long long a, long long b) {\n\treturn Arr[b] < Arr[a];\n}\n\nvoid dfs1(long long v) {\n\tfor (long long i = 0; i < child[v].size(); i++) {\n\t\tdfs1(child[v][i]);\n\t\tdp_d[v] += dp_d[child[v][i]] + Siz[child[v][i]];\n\t}\n}\n\nvoid dfs2(long long v, long long val) {\n\tdp_u[v] = val;\n\tfor (long long i = 0; i < child[v].size(); i++)\n\t\tdfs2(child[v][i], dp_d[v] + dp_u[v] - dp_d[child[v][i]] - Siz[child[v][i]] + (n - Siz[child[v][i]]));\n}\n\nint main() {\n\tios::sync_with_stdio(false), cout.tie(0), cin.tie(0);\n\tcin >> n;\n\tfor (long long i = 0; i < n; i++) {\n\t\tcin >> Arr[i];\n\t\tSiz[i] = 1;\n\t\th[i] = i;\n\t\tMap[Arr[i]] = i;\n\t}\n\t\t\n\tsort(h, h + n, cmp);\n\t\n\tfor (long long i = 0; i + 1 < n; i++) {\n\t\tlong long v = h[i];\n\t\tlong long tmp = Arr[v] + Siz[v] - (n - Siz[v]);\n\n\t\tif (tmp < 0 || (Map[tmp] == 0 && Arr[0] != tmp)) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tlong long u = Map[tmp];\n\t\tif (Mark[u]) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tSiz[u] += Siz[v];\n\t\tpar[v] = u;\n\t\tedge.push_back({v, u});\n\t\tchild[u].push_back(v);\n\t\tif (n < 2LL * Siz[v]) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\troot = h[n - 1];\n\tdfs1(root);\n\tdfs2(root, 0);\n\t\n\tfor (long long i = 0; i < n; i++)\n\t\tif (dp_d[i] + dp_u[i] != Arr[i]) {\n\t\t\tcout << i << \" \" << dp_d[i] + dp_u[i] << \"\\n\";\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\n\tfor (long long i = 0; i + 1 < n; i++)\n\t\tcout << edge[i].first + 1 << \" \" << edge[i].second + 1 << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\ntypedef long long lint;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef unsigned long long ulint;\n#define endl '\\n'\n#define fst first\n#define sed second\n#define pb push_back\n#define mp make_pair\n#define rint register int\n#define newline putchar('\\n')\n#define leave_space putchar(' ')\n#define all(x) (x).begin(), (x).end()\n#define reveal(x) cerr << #x << \" = \" << (x) << endl\n#define rep(it, f, e) for (rint it = (f); it <= (e); ++it)\n#define per(it, f, e) for (rint it = (f); it >= (e); --it)\nconst int MAXN = 1e5 + 10;\npll p[MAXN];\nint sz[MAXN];\nmap<lint, int> rec;\nvector<int> edge[MAXN];\n#define D fst\n#define P sed\nvector<pii> opt;\nlint res = 0;\ninline void dfs(int u, int par, int dep) {\n\tres += dep;\n\tfor (auto v : edge[u]) {\n\t\tif (v == par) continue;\n\t\tdfs(v, u, dep + 1);\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL), cout.tie(NULL);\n\tint n;\n\tcin >> n;\n\trep (i, 1, n) {\n\t\tcin >> p[i].D;\n\t\tp[i].P = i;\n\t\tif (rec.find(p[i].D) != rec.end()) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\trec[p[i].D] = p[i].P;\n\t}\n\tsort(p + 1, p + n + 1, greater<pll>());\n\tfill(sz + 1, sz + n + 1, 1);\n\trep (i, 1, n - 1) {\n\t\tint u = p[i].P;\n\t\tif (n - sz[u] - sz[u] <= 0) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t} \n\t\tlint diff = p[i].D - (n - sz[u] - sz[u]);\n\t\tif (rec.find(diff) == rec.end()) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint v = rec[diff];\n\t\topt.pb(pii(u, v));\n\t\tedge[u].pb(v);\n\t\tedge[v].pb(u);\n\t\tsz[v] += sz[u];\n\t}\n\tdfs(p[n].P, 0, 0);\n\tif (res != p[n].D) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tfor (auto &v : opt) {\n\t\tif (v.fst > v.sed) swap(v.fst, v.sed);\n\t}\n\tsort(all(opt));\n\tfor (auto &v : opt) {\n\t\tcout << v.fst << ' ' << v.sed << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100005\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate <class T> inline void read(T &x) {\n\tchar ch; bool flag = false;\n\twhile (!isdigit(ch = getchar())) flag |= ch == '-';\n\tfor (x = ch ^ 48; isdigit(ch = getchar()); x = x * 10 + (ch ^ 48));\n\tif (flag) x = -x;\n}\n\ninline int input() {\n\tint x; char ch; bool flag = false;\n\twhile (!isdigit(ch = getchar())) flag |= ch == '-';\n\tfor (x = ch ^ 48; isdigit(ch = getchar()); x = x * 10 + (ch ^ 48));\n\treturn flag ? -x : x;\n}\n\nconst int mod = 1e9 + 7;\ninline int add(int x, int y) { x += y; return x >= mod ? x - mod : x; }\ninline void inc(int &x, int y) { x += y; x -= x >= mod ? mod : 0; }\n\ninline int Power(int x, int y) {\n\tint res = 1;\n\twhile (y) {\n\t\tif (y & 1) res = (ll) res * x % mod;\n\t\tx = (ll) x * x % mod, y >>= 1;\n\t} return res;\n}\n\ntemplate <class T> void chkmax(T &x, T y) { x = x > y ? x : y; }\ntemplate <class T> void chkmin(T &x, T y) { x = x < y ? x : y; }\ntemplate <class T> T gcd(T x, T y) { return !y ? x : gcd(x % y, y); }\n\nll n, Dis;\nll d[N], dis[N];\nll size[N], fa[N];\nmap<ll, ll> mp;\nvector<ll> G[N];\n\t\nvoid FAIL() {\n\tputs(\"-1\");\n\texit(0);\n}\n\nll id(ll x) { return mp[d[x]]; }\ninline void AddEdge(int x, int y) { G[x].push_back(y); }\n\ninline void dfs(int u) {\n\tDis += dis[u];\n\tfor (int v : G[u]) dis[v] = dis[u] + 1, dfs(v);\n}\n\nbool check() {\n\tdfs(1);\n\treturn Dis == d[1];\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor (ll i = 1; i <= n; ++i) size[i] = 1;\n\tfor (ll i = 1; i <= n; ++i) {\n\t\tcin >> d[i], mp[d[i]] = i;\n\t\tif (d[i] > (ll) n * (n - 1) / 2) FAIL();\n\t}\n\tsort(d + 1, d + n + 1);\n\n\tfor (ll i = n; i > 1; --i) {\n\t\tll vf = d[i] - n + size[i] + size[i];\n\t\tif (vf >= d[i]) FAIL();\n\t\tfa[i] = lower_bound(d + 1, d + n + 1, vf) - d;\n\t\tif (d[fa[i]] != vf) FAIL();\n\t\tsize[fa[i]] += size[i];\n\t}\n\n\tfor (ll i = 2; i <= n; ++i)\n\t\tAddEdge(fa[i], i);\n\tif (!check()) FAIL();\n\telse for (ll i = 2; i <= n; ++i)\n\t\tprintf(\"%lld %lld\\n\", id(i), id(fa[i]));\n\treturn 0;\n}\n\t\t\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100010;\nmap<long long,int> id;\nint n,siz[maxn],last[maxn],nxt[maxn],to[maxn],e,dist[maxn];\nlong long d[maxn];\nvoid add(int u,int v){\n\tnxt[++e]=last[u];\n\tto[e]=v;\n\tlast[u]=e;\n}\nvoid dfs(int u){\n\tfor(int e=last[u],v=to[e];e;v=to[e=nxt[e]]){\n\t\tdist[v]=dist[u]+1;\n\t\tdfs(v);\n\t}\n}\nvector<pair<int,int> > edge;\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&d[i]),id[d[i]]=i;\n\tsort(d+1,d+n+1);\n\tfor(int i=1;i<=n;i++)siz[i]=1;\n\tfor(int i=n;i>1;i--){\n\t\tint u=id[d[i]];\n\t\tint tmp=n-2*siz[u];\n\t\tif(tmp<=0){\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tlong long t=d[i]-tmp;\n\t\tif(id.count(t)==0){\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tint pos=id[t];\n\t\tadd(pos,u);\n\t\tsiz[pos]+=siz[u];\n\t\tedge.push_back(make_pair(pos,u));\n\t}\n\tlong long sum=0;\n\tdfs(id[d[1]]);\n\tfor(int i=1;i<=n;i++){\n\t\tsum+=dist[i];\n\t}\n\tif(sum!=d[1]){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<edge.size();i++){\n\t\tprintf(\"%d %d\\n\",edge[i].first,edge[i].second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#define jizz ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define pb push_back\n#define F first\n#define S second\n#define MP make_pair\n#define ET cout << \"\\n\"\n#define ALL(v) v.begin(),v.end()\n#define MEM(i,j) memset(i,j,sizeof i)\n#define DB(a,s,e) {for(int i=s;i<e;i++) cout << a[i] << \" \";ET;}\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nbitset<100001> vis;\nmultiset<pll> s;\nvector<pll> v;\npll arr[100001],tarr[100001];\nll w[100001],dp[100001];\nvector<ll> child[100001];\n\nvoid dfs(ll x)\n{\n\tdp[x]=w[x]-1;\n\tfor(ll i:child[x])\n\t\tdfs(i),dp[x]+=dp[i];\n}\n\nint main()\n{jizz\n\tll n,x,c=0,t;\n\tcin >> n;\n\tfor(int i=1;i<=n;++i)\n\t\tcin >> x,s.insert(tarr[i]=arr[i]=MP(x,i)),w[i]=1;\n\tsort(tarr+1,tarr+n+1);\n\tfor(int i=n;i>0;--i)\n\t\tif(!vis[tarr[i].S])\n\t\t{\n\t\t\tx=tarr[i].S;\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\t//cout << x << \" \" << w[x] << \" \" << arr[x].F << \" \" << arr[x].F-n+w[x]*2 << \"\\n\";\n\t\t\t\tauto p=s.lower_bound(MP(arr[x].F-n+w[x]*2,-1));\n\t\t\t\tif(p==s.end()||p->F!=arr[x].F-n+w[x]*2)\n\t\t\t\t\tbreak;\n\t\t\t\t//cout << x << \" -> \" << p->S << \"*\\n\";\n\t\t\t\ts.erase(s.find(MP(arr[x].F,arr[x].S)));\n\t\t\t\t//cout << x << \" -> \" << p->S << \"\\n\";\n\t\t\t\tvis[x]=1,v.pb(MP(x,p->S)),w[p->S]+=w[x],child[p->S].pb(x),x=p->S;\n\t\t\t}\n\t\t}\n\tif(vis.count()!=n-1) cout << \"-1\\n\";\n\telse\n\t{\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tif(!vis[i]) x=i;\n\t\tdfs(x);\n\t\tif(dp[x]!=arr[x].F) cout << \"-1\\n\";\n\t\telse \n\t\t\tfor(auto i:v)\n\t\t\t\tcout << i.F << \" \" << i.S << \"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ntypedef pair <int, int> pii;\n\nconst int N = 1e5 + 10;\nint n, cnt[N], par[N], sum[N], mark[N];\npii ar[N];\nmap <int, int> mp;\nvector <int> ch[N];\n\nvoid dfs(int v) {\n\tmark[v] = 1;\n\tfor (int i : ch[v]) {\n\t\tdfs(i);\n\t\tsum[v] += sum[i] + cnt[i];\n\t}\n}\n\nint32_t main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tfill(cnt, cnt + N, 1);\n\t\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> ar[i].first;\n\t\tar[i].second = i;\n\t\tmp[ar[i].first] = i;\n\t}\n\tsort(ar, ar + n);\n\t\n\tfor (int i = n - 1; i > 0; i--) {\n\t\tint v = ar[i].second;\n\t\tint nd = ar[i].first - n + 2 * cnt[v];\n\t\tif (mp.find(nd) == mp.end() || 2 * cnt[v] > n)\n\t\t\treturn cout << -1, 0;\n\t\t\n\t\tint p = mp[nd];\n\t\tch[p].push_back(v);\n\t\tpar[v] = p;\n\t\tcnt[p] += cnt[v];\n\t}\n\t\n\tdfs(ar[0].second);\n\tif (sum[ar[0].second] != ar[0].first)\n\t\treturn cout << -1, 0;\n\t\n\tfor (int i = 0; i < n; i++)\n\t\tif (!mark[i])\n\t\t\treturn cout << -1, 0;\n\t\n\tfor (int i = 0; i < n; i++)\n\t\tif (i != ar[0].second)\n\t\t\tcout << i + 1 << \" \" << par[i] + 1 << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "//Link : https://atcoder.jp/contests/arc101/tasks/arc101_c\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define N 100005\n\nvector<int> adj[N];\nll d[N];\npair<ll,int> in[N];\nint sz[N];\n\nint dsz[N];\nll dd[N];\n\nvoid dfs(int node) {\n  dsz[node] = 1;\n  for(int ch : adj[node]) {\n    dfs(ch);\n    dsz[node] += dsz[ch];\n    dd[node] += dd[ch] + dsz[ch];\n  }\n}\n\nbool dfs2(int node,ll tmp,int n) {\n  if(tmp!=d[node]) {\n    return false;\n  }\n  for(int ch : adj[node]) {\n    if(!dfs2(ch,tmp + n - dsz[ch]*2,n)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nvoid solve() {\n  int n;scanf(\"%d \", &n);\n  set<pair<ll,int> >s;\n  ll sum = 0;\n  for(int i=1;i<=n;++i) {\n    scanf(\"%lld \", &in[i].first);\n    d[i] = in[i].first;\n    in[i].second = i;\n    sz[i] = 1;\n    s.insert(in[i]);\n    sum += d[i];\n  }\n  if(sum%2==1) {\n    printf(\"-1\\n\");\n    return;\n  }\n  sort(in+1,in+n+1);\n  int pos = n;\n\n  while(s.size()>1) {\n    pair<ll,int> tmp = *prev(s.end());\n    s.erase(prev(s.end()));\n    ll dist = tmp.first;\n    int node = tmp.second;\n    pair<ll,int> tmp2 = make_pair(dist - n + sz[node]*2,0);\n    set<pair<ll,int> >::iterator it = s.lower_bound(tmp2);\n    if(it==s.end() || (*it).first!=tmp2.first) {\n      printf(\"-1\\n\");\n      return;\n    }\n    int x = (*it).second;\n    sz[x] += sz[node];\n    adj[x].push_back(node);\n  }\n  int root = in[1].second;\n  dfs(root);\n  if(!dfs2(root,d[root],n)) {\n    printf(\"-1\\n\" );\n    return;\n  }\n  for(int i=1;i<=n;++i) {\n    for(int ch : adj[i]) {\n      printf(\"%d %d\\n\", i,ch);\n    }\n  }\n}\n\nint main() {\n    //freopen(\"input.txt\",\"r\",stdin);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst long double eps = 1E-14;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\n\nint main() {\n\tll N;\n\tcin >> N;\n\n\tvector<pair<ll, ll>> p(N + 1);\n\trepn(i, N) {\n\t\tcin >> p[i].first;\n\t\tp[i].second = i;\n\t}\n\tsort(++p.begin(), p.end());\n\n\tvll D(N + 1);\n\trepn(i, N) { D[i] = p[i].first; }\n\t\n\tvll sz(N + 1, 0);\n\tvll par(N + 1, 0);\n\n\tfor (ll v = N; v > 1; v--) {\n\t\tll x = D[v] - (N - 2 - sz[v] * 2);\n\n\t\tauto itr = lower_bound(++D.begin(), D.end(), x);\n\t\tll w = distance(D.begin(), itr);\n\t\t\n\t\tif (w > N || D[w] != x) { cout << -1 << endl; return 0; }\n\t\tpar[v] = w;\n\t\tsz[w] += sz[v] + 1;\n\t\t//cout << v << \" \" << w << endl;\n\n\t}\n\n\tvll subtr(N + 1, 0);\n\tvll sum(N + 1, 0);\n\tfor (ll v = N; v > 1; v--) {\n\t\tsubtr[par[v]] += subtr[v] + 1;\n\t}\n\tfor (ll v = N; v > 1; v--) {\n\t\tsum[par[v]] += sum[v] + subtr[v] + 1;\n\t}\n\n\t//repn(v, N) cout << sum[v] << endl;\n\n\tif (sum[1] != D[1]) { cout << -1 << endl; return 0; }\n\n\tfor (ll v = N; v > 1; v--) {\n\t\tcout << p[v].second << \" \" << p[par[v]].second << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n\nusing namespace std;\n\ntypedef long long ll;\n\nmt19937 rnd(228);\n\nconst int N = 1e5 + 7;\n\nint main()\n{\n#ifdef ONPC\n    freopen(\"a.in\", \"r\", stdin);\n#endif\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    vector <pair <ll, int> > e;\n    map <ll, int> ret;\n    for (int i = 0; i < n; i++)\n    {\n        ll x;\n        cin >> x;\n        ret[x] = i;\n        e.push_back({x, i});\n    }\n    sort(e.rbegin(), e.rend());\n    ll x = e.back().first;\n    vector <int> sz(n, 1);\n    vector <ll> dp(n, 0);\n    vector <pair <int, int> > ans;\n    for (auto c : e)\n    {\n        if (c.first != x)\n        {\n            if (sz[c.second] * 2 >= n)\n            {\n                cout << -1 << '\\n';\n                return 0;\n            }\n            ll need = c.first - (n - 2 * sz[c.second]);\n            if (!ret.count(need))\n            {\n                cout << -1 << '\\n';\n                return 0;\n            }\n            int par = ret[need];\n            dp[par] += dp[c.second] + sz[c.second];\n            sz[par] += sz[c.second];\n            ans.push_back({c.second + 1, par + 1});\n        }\n    }\n    if (dp[e.back().second] != x)\n    {\n        cout << -1 << '\\n';\n        return 0;\n    }\n    for (auto c : ans)\n    {\n        cout << c.first << ' ' << c.second << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#define jizz ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define pb push_back\n#define F first\n#define S second\n#define MP make_pair\n#define ET cout << \"\\n\"\n#define ALL(v) v.begin(),v.end()\n#define MEM(i,j) memset(i,j,sizeof i)\n#define DB(a,s,e) {for(int i=s;i<e;i++) cout << a[i] << \" \";ET;}\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nbitset<100001> vis;\nmultiset<pii> s;\nvector<pii> v;\npii arr[100001],tarr[100001];\nint w[100001];\n\nint main()\n{jizz\n\tint n,x,c=0,t;\n\tcin >> n;\n\tfor(int i=1;i<=n;++i)\n\t\tcin >> x,s.insert(tarr[i]=arr[i]=MP(x,i)),w[i]=1;\n\tsort(tarr+1,tarr+n+1);\n\tfor(int i=n;i>0;--i)\n\t\tif(!vis[tarr[i].S])\n\t\t{\n\t\t\tx=tarr[i].S;\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\t//cout << x << \" \" << w[x] << \" \" << arr[x].F << \" \" << arr[x].F-n+w[x]*2 << \"\\n\";\n\t\t\t\tauto p=s.lower_bound(MP(arr[x].F-n+w[x]*2,-1));\n\t\t\t\tif(p==s.end()||p->F!=arr[x].F-n+w[x]*2)\n\t\t\t\t\tbreak;\n\t\t\t\t//cout << x << \" -> \" << p->S << \"*\\n\";\n\t\t\t\ts.erase(s.find(MP(arr[x].F,arr[x].S)));\n\t\t\t\t//cout << x << \" -> \" << p->S << \"\\n\";\n\t\t\t\tvis[x]=1,v.pb(MP(x,p->S)),w[p->S]+=w[x],x=p->S;\n\t\t\t}\n\t\t}\n\tif(vis.count()!=n-1) cout << \"-1\\n\";\n\telse\n\t\tfor(auto i:v)\n\t\t\tcout << i.F << \" \" << i.S << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MN 100000\n#define ll long long\n#define mp(x,y) make_pair(x,y)\nusing namespace std;\ninline ll read()\n{\n\tll x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,ansnum;\npair<int,int> ans[MN+5];\nset<pair<ll,pair<int,int> >,greater<pair<ll,pair<int,int> > > >st;\nset<pair<ll,pair<int,int> > >::iterator it;\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;++i) st.insert(mp(read(),mp(i,1)));\n    while(st.size()>1)\n    {\n        pair<ll,pair<int,int> >a=*st.begin(),b;\n        st.erase(st.begin());\n        ll nx=a.first+a.second.second-(n-a.second.second);\n        it=st.lower_bound(mp(nx,mp(1e9,1e9)));\n        if(it==st.end()||(*it).first!=nx) return 0*puts(\"-1\");\n        b=*it;st.erase(it);\n        ans[++ansnum]=mp(a.second.first,b.second.first);\n        b.second.second+=a.second.second;\n        st.insert(b);\n    }\n    for(int i=1;i<=ansnum;++i) printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(X,A,B) for(int X=A;X<=B;X++)\n#define tep(X,A,B) for(int X=A;X>=B;X--)\n#define LL long long\n#define DB double\nconst int N=400010;\nconst int M=800010;\nconst LL INF=1e15;\nusing namespace std;\n\nint n,fa[N],sz[N];\nint edge[M],lst[N],nxt[M],t=0;\nLL sum=0;\n\nstruct nn{\n\tLL d;\n\tint x;\n}a[N];\n\nint cmp(nn A,nn B){\n\treturn A.d<B.d;\n}\n\nvoid ADD(int x,int y){\n\tedge[++t]=y;nxt[t]=lst[x];lst[x]=t;\n}\n\nvoid READ(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n)scanf(\"%lld\",&a[i].d),a[i].x=i;\n\tsort(a+1,a+n+1,cmp);\n}\n\nint GET(int pos,int x){\n\tint l=1,r=pos,res=0;\n\twhile(l<=r){\n\t\tint mid=(l+r)>>1;\n\t\tif(a[mid].d<=x)res=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\treturn res;\n}\n\nvoid SEARCH(int x,int dep){\n\tsum+=dep;\n\tfor(int r=lst[x];r;r=nxt[r]){\n\t\tSEARCH(edge[r],dep+1);\n\t}\n}\n\nint SOLVE(){\n\trep(i,1,n)sz[i]=1;\n\ttep(i,n,2){\n\t\tint x=a[i].x;\n\t\tif(sz[x]>n/2)return 0;\n\t\tLL df=a[i].d+2*sz[x]-n;\n\t\tint pos=GET(i-1,df);\n\t\tif(a[pos].d!=df)return 0;\n\t\tint pa;\n\t\tfa[x]=pa=a[pos].x;\n\t\tADD(pa,x);\n\t\tsz[pa]+=sz[x];\n\t}\n\tsum=0;\n\tSEARCH(1,0);\n\tif(sum!=a[1].d)return 0;\n\trep(i,2,n)printf(\"%d %d\\n\",fa[a[i].x],a[i].x);\n\treturn 1;\n}\n\nint main(){\n\tREAD();\n\tif(SOLVE()==0)printf(\"-1\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\nint n;\nlong long a[N], p[N];\n\n\nint head[N];\n\nint main() {\n    cin >> n;\n    for(int i = 1; i <= n; i++){\n        cin >> a[i];\n    }\n    for(int i = 1; i <= n; i++) p[i] = i;\n    sort(p + 1, p + n + 1,[](int x,int y){ return a[x] < a[y];});\n    fill(head + 1, head + n + 1, 1);\n\n    vector<pair<int, int>> ans;\n    for(int i = n; i >= 2; i--) {\n        int cur = p[i];\n        int L = 1, R = i - 1;\n        long long con_weight = a[cur] + 2 * head[cur] - n; \n        while (L <= R){\n            int mid = (L + R) / 2;\n            if (con_weight > a[p[mid]]) L = mid + 1;\n            else R = mid - 1;\n        }\n        if (L >= i || con_weight != a[p[L]]) {\n            cout << \"-1\" << endl;\n            return 0;\n        }\n        ans.push_back(make_pair(p[L], cur));\n        head[p[L]] += head[cur];\n        //cout << cur << \" \" << p[L] <<'\\n';\n        //for(int j = 1; j <= n; j++) cout << head[j] << \" \\n\"[j==n]; \n    }\n    \n    if (head[p[1]] != n) {\n        cout << \"-1\" << endl;\n        return 0;\n    }\n    for(auto i : ans) cout << i.first << \" \" << i.second << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 998244353\n#define ny 499122177\n#define maxn 1000000000000000000LL\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nlong long n,i,x,zz[100005],sum[100005];\nstruct nyh{\n\tlong long x,id;\n}o[100005];\nmap<long long,long long> mp;\nbool cmp(nyh u,nyh v){\n\treturn u.x<v.x;\n}\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read();\n\tfor(i=1;i<=n;i++){\n\t\to[i].x=read();\n\t\to[i].id=i;\n\t}\n\tsort(o+1,o+n+1,cmp);\n\tfor(i=1;i<=n;i++){\n\t\tmp[o[i].x]=i;\n\t\tsum[i]=1;\n\t}\n\tfor(i=n;i>=2;i--){\n\t\tx=o[i].x-n+sum[i]*2;\n\t\tif(mp[x]!=0){\n\t\t\tzz[i]=mp[x];\n\t\t\tsum[zz[i]]+=sum[i];\n\t\t}\n\t\telse{\n\t\t\tpus(-1,2);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(i=n;i>=2;i--){\n\t\tpus(o[zz[i]].id,1);\n\t\tpus(o[i].id,2);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define LL long long\n#define pii pair<LL, int>\nusing namespace std;\nconst int N = 1e5 + 10;\n\nint n, m;\nint a[N], b[N];\nLL d[N], siz[N];\nmap<LL, int> Map;\npriority_queue<pii> Q;\n\nvoid doit(int cnt) {\n\tpii tmp = Q.top(); Q.pop();\n\tint to = Map[d[tmp.se] - (n - siz[tmp.se] * 2)];\n\tif (!to || tmp.se == to) puts(\"-1\"), exit(0);\n\ta[cnt] = to;\n\tb[cnt] = tmp.se;\n\tif (siz[tmp.se] * 2 > n) puts(\"-1\"), exit(0);\n\tsiz[to] += siz[tmp.se];\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%lld\", &d[i]);\n\t\tMap[d[i]] = i;\n\t\tQ.push(make_pair(d[i], i));\n\t}\n\tif (n == 1 && d[1]) return 0 * puts(\"-1\");\n\tfor (int i = 1; i <= n; ++i)\n\t\tsiz[i] = 1;\n\tfor (int i = 1; i < n; ++i)\n\t\tdoit(i);\n\tfor (int i = 1; i < n; ++i)\n\t\tprintf(\"%d %d\\n\", a[i], b[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Written by Zhu Zeqi\n//Come on,baby\n//Hack,please\n#include <bits/stdc++.h>\n#define INF 0x3f3f3f3f3f3f3f3f\ntypedef long long ll;\n//orz yht\nusing namespace std;\nint main(){\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n    int n;\n  cin >> n;\n  vector<long long> d(n);\n  vector<int> weight(n, 1);\n  map<long long,int> mp;\n  for (int i = 0; i < n; i++) {\n    cin >> d[i];\n    mp[d[i]] = i;\n  }\n  vector<pair<int,int> > res;\n  for (int itt = 0; itt < n - 1; itt++) {\n    auto it = mp.rbegin();\n    int i = it->second;\n    long long want = d[i] - (n - weight[i]) + weight[i];\n    if (mp.find(want) == mp.end() || mp[want] == i) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n    int j = mp[want];\n    res.emplace_back(i, j);\n    weight[j] += weight[i];\n    mp.erase(--mp.end());\n  }\n  vector<long long> real_dist(n, -1);\n  real_dist[0] = 0;\n  vector<vector<int> > g(n);\n  for (auto &p : res) {\n    g[p.first].push_back(p.second);\n    g[p.second].push_back(p.first);\n  }\n  vector<int> que(1, 0);\n  for (int b = 0; b < (int) que.size(); b++) {\n    for (int j : g[que[b]]) {\n      if (real_dist[j] == -1) {\n        que.push_back(j);\n        real_dist[j] = real_dist[que[b]] + 1;\n      }\n    }\n  }\n  if (accumulate(real_dist.begin(), real_dist.end(), 0LL) != d[0]) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  for (auto &p : res) {\n    cout << p.first + 1 << \" \" << p.second + 1 << '\\n';\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> ii;\n\nconst int N = 1e6 + 5;\n\nvector<int> adj[N];\nint n, sub[N];\nll d[N], D;\nmap<ll, int> pos;\n\nvoid no_answer() {\n  puts(\"-1\");\n  exit(0);\n}\n\nvoid calc(int u, int p, int d = 0) {\n  D += d; \n  for (int v : adj[u]) calc(v, u, d + 1);\n}\n\nvoid check(int u, int p, int D) {\n  if (D != d[u]) no_answer();\n  for (int v : adj[u]) check(v, u, D + n - 2 * sub[v]);\n}\n\nint main() {\n#ifdef LOCAL\n  freopen(\"in\", \"r\", stdin);\n#endif\n\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%lld\", &d[i]);\n    pos[d[i]] = i;\n  }\n\n  vector<int> ord(n);\n  iota(ord.begin(), ord.end(), 1);\n  sort(ord.begin(), ord.end(), [](int i, int j) { return d[i] > d[j]; });\n\n  for (int i = 0; i < n - 1; ++i) {\n    int u = ord[i];\n    ++sub[u];\n    int dp = d[u] - n + 2 * sub[u];\n    if (!pos.count(dp)) no_answer();\n    int p = pos[dp];\n    sub[p] += sub[u];\n    adj[p].push_back(u);\n  }\n\n  calc(ord[n - 1], 0);\n  check(ord[n - 1], 0, D);\n\n  for(int i = 1; i <= n; ++i) {\n    for(int j : adj[i]) {\n      printf(\"%d %d\\n\", i, j); \n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nlong long N, A[1 << 17], dp[1 << 17]; vector<pair<long long, long long>> vec, G; vector<int> X[1 << 17];\nlong long dist[1 << 17], par[1 << 17], dp2[1 << 17];\n\nvoid dfs(int pos, int dst) {\n\tdist[pos] = dst; dp2[pos] = 1;\n\tfor (int i = 0; i < X[pos].size(); i++) {\n\t\tif (dist[X[pos][i]] != -1) continue;\n\t\tpar[X[pos][i]] = pos; dfs(X[pos][i], dst + 1);\n\t\tdp2[pos] += dp2[X[pos][i]];\n\t}\n}\n\nint main() {\n\tcin >> N;\n\tfor (int i = 1; i <= N; i++) { cin >> A[i]; vec.push_back(make_pair(A[i], i)); }\n\tsort(vec.begin(), vec.end());\n\n\t// 1 個正しい木を構築する\n\tfor (int i = vec.size() - 1; i >= 0; i--) {\n\t\tint pos = vec[i].second;\n\t\tdp[pos] += 1;\n\t\tif (dp[pos] != N) {\n\t\t\tlong long SA = A[pos] + (dp[pos] - (N - dp[pos]));\n\t\t\tint pos1 = lower_bound(vec.begin(), vec.end(), make_pair(SA, 0LL)) - vec.begin();\n\t\t\tpos1 = vec[pos1].second;\n\t\t\tdp[pos1] += dp[pos];\n\t\t\tG.push_back(make_pair(pos1, pos));\n\t\t\tX[pos1].push_back(pos); X[pos].push_back(pos1);\n\t\t}\n\t}\n\n\t// この木が正しいか判定する\n\tfor (int i = 1; i <= N; i++) dist[i] = -1;\n\tdfs(1, 0);\n\tlong long S = 0; for (int i = 1; i <= N; i++) { S += dist[i]; if (dist[i] == -1) S = (1LL << 60); }\n\tif (S != A[1]) {\n\t\tcout << \"-1\" << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 2; i <= N; i++) {\n\t\tlong long SA = dp2[i] - (N - dp2[i]);\n\t\tif (A[i] + SA != A[par[i]]) {\n\t\t\tcout << \"-1\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < G.size(); i++) { if (G[i].first > G[i].second) swap(G[i].first, G[i].second); }\n\tsort(G.begin(), G.end());\n\tfor (int i = 0; i < G.size(); i++) cout << G[i].first << \" \" << G[i].second << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<map>\n#define rep(i,x,y) for(int i=(x);i<=(y);i++)\nusing namespace std;\ntypedef long long ll;\nint n;\nconst int N=200005;\nmap<long long,int> mp;\nint a[N],id[N];\nint fa[N],size[N];\nbool cmp(int x,int y){return a[x]>a[y];}\nint main()\n{\n//freopen(\"input.txt\",\"r\",stdin);\nios::sync_with_stdio(false);\ncin.tie(0);\nint n;\ncin >>n;\nrep(i,1,n)cin >>a[i],id[i]=i,mp[a[i]]=i,size[i]=1;\nsort(id+1,id+1+n,cmp);\nrep(i,1,n-1)\n\t{\n\tint x=id[i];\n\tfa[x]=mp[a[x]-n+2*size[x]];\n\tif(!fa[x])return cout <<-1,0;\n\tsize[fa[x]]+=size[x];\n\t}\nrep(i,1,n-1)\n\t{\n\ta[id[n]]-=size[id[i]];\n\t}\nif (a[id[n]]) return puts(\"-1\"),0;\nrep (i,1,n-1) cout <<id[i]<<' '<<fa[id[i]]<<'\\n';\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,int>P;\n\nint n;\nP d[200000];\nvector<int>E[200000];\nint sz[200000];\nll dp1[200000],dp2[200000];\nvector<pair<int,int>>ans;\n\nvoid dfs1(int v){\n\tfor(int u:E[v]){\n\t\tdfs1(u);\n\t\tdp1[v]+=dp1[u]+sz[u];\n\t}\n}\nvoid dfs2(int v,int p){\n\tif(p==-1)dp2[v]=dp1[v];\n\telse dp2[v]=dp2[p]+n-2*sz[v];\n\tfor(int u:E[v]){\n\t\tans.push_back({v+1,u+1});\n\t\tdfs2(u,v);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%lld\",&d[i].first);\n\t\td[i].second=i;\n\t}\n\trep(i,n)sz[i]=1;\n\tsort(d,d+n);\n\tfor(int i=n-1;i>0;i--){\n\t\tint c=d[i].first-n+2*sz[d[i].second];\n\t\tint id=lower_bound(d,d+n,P(c,0))-d;\n\t\tif(id==n||d[id].first!=c){\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t\tE[d[id].second].push_back(d[i].second);\n\t\tsz[d[id].second]+=sz[d[i].second];\n\t}\n\tdfs1(d[0].second);\n\tdfs2(d[0].second,-1);\n\trep(i,n){\n\t\tif(dp2[d[i].second]!=d[i].first){\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t}\n\tabort();\n\tfor(auto p:ans){\n\t\tprintf(\"%d %d\\n\",p.first,p.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n//#include<ext/rope>\n//using namespace __gnu_cxx\n//#include<ext/pb_ds/priority_queue.hpp>\n//using namespace __gnu_pbds;\n#define lowbit(x) (x&-x)\n#define pb push_back\n#define empb emplace_back\n#define all(x) (x).begin(),(x).end()\n#define clr(a,b) memset(a,b,sizeof(a))\n#define caze(T) for(cin>>T;T;T--)\n#define inf (1<<29)\n#define Endl ('\\n')\n#define fi first\n#define se second\n#define db double\n#define ldb long double\n#define ll long long\n#define pii pair<int,int>\n#define pil pair<int,ll>\n#define pli pair<ll,int>\n#define pll pair<ll,ll>\n#define ull unsigned long long\n#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)\ninline char nc() {\n\t#define SZ 1000000\n\tstatic char buf[SZ], *p1, *p2;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,SZ,stdin),p1==p2)?EOF:*p1++;\n}\ntemplate<typename T>\ninline int scan(T &x) {\n\tchar c, sign=1; \n\twhile(!isdigit(c=nc())&&c!=EOF)if(c=='-')sign*=-1;\n\tif(c==EOF) return EOF;\n\tfor(x = 0; isdigit(c); c = nc())\n\t\tx = (x<<1) + (x<<3) + (c&15);\n\treturn x *= sign, 1;\n}\ntemplate<typename T, typename...Args>\ninline int scan(T &x, Args&...args) {\n\treturn scan(x), scan(args...);\n}\nvoid no(){exit((cout<<-1<<Endl,0));}\nint main()\n{IOS;\n\tint n;cin>>n;\n\tmap<ll,int>id;\n\tvector<ll>d(n);\n\tvector<int>x(n);\n\tvector<vector<int> >G(n);\n\tvector<int>sz(n,1);\n\tfunction<ll(int,int)>dfs=[&](int u,int d)\n\t{\n\t\tll ret=d;\n\t\tfor(auto v:G[u])\n\t\t\tret+=dfs(v,d+1);\n\t\treturn ret;\n\t};\n\tfor(int i=0;i<n;++i)\n\t\tcin>>d[i],id[d[i]]=i;\n\tiota(all(x),0);\n\tsort(all(x),[&](const int&A,const int&B){return d[A]>d[B];});\n\tfor(int i=0;i<n-1;++i)\n\t{\n\t\tint u=x[i];\n\t\tll df=d[u]-n+2*sz[u];\n\t\tif(id.find(df)==id.end()) no();\n\t\tint fa=id[df];\n\t\tG[fa].pb(u);sz[fa]+=sz[u];\n\t}\n\tif(d[x[n-1]]!=dfs(x[n-1],0))\n\t\tno();\n\tfor(int i=0;i<n;++i)\n\t\tfor(auto c:G[i])\n\t\t\tcout<<i+1<<' '<<c+1<<Endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=1e6+10;\nint n,pos[maxn];\nint fa[maxn],siz[maxn];\nll D[maxn];\nbool cmp(int i,int j){return D[i]<D[j];}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",D[i]),pos[i-1]=i;\n\tsort(pos,pos+n,cmp);\n\tll d0=0;\n\tfor(int *p=pos+n;--p>pos;){\n\t\td0+=siz[*p]++;\n\t\tD[*p]-=n-2*siz[*p];\n\t\tint *j=lower_bound(pos,p,*p,cmp);\n\t\tif(j<p&&D[*j]==D[*p]) siz[fa[*p]=*j]+=siz[*p];\n\t\telse{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif(d0+n-1!=D[*pos]) puts(\"-1\");\n\telse for(int*p=pos+n;--p>pos;) printf(\"%d %d\\n\",*p,fa[*p]); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n\n#pragma warning(disable:4996)  \n#pragma comment(linker, \"/STACK:336777216\")  \nusing namespace std;\n\n#define mp make_pair  \n#define Fi first  \n#define Se second  \n#define pb(x) push_back(x)  \n#define szz(x) ((int)(x).size())  \n#define rep(i, n) for(int i=0;i<n;i++)  \n#define all(x) (x).begin(), (x).end()  \n#define ldb ldouble  \n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nconst ll MOD = 100000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n\nmap <ll, ll> Msz;\n\nmap <ll, ll> Mch;\n\nvector <int> son[100050];\nll dep[100050];\nll sz[100050];\nll par[100050];\nvoid DFS(int n) {\n\tsz[n] = 1;\n\tfor (auto it : son[n]) {\n\t\tpar[it] = n;\n\t\tdep[it] = dep[n] + 1;\n\t\tDFS(it);\n\t\tsz[n] += sz[it];\n\t}\n}\n\nll in[100050];\nll oin[100050];\nint main() {\n\tint N, i, j;\n\tscanf(\"%d\", &N);\n\tfor (i = 1; i <= N; i++) {\n\t\tscanf(\"%lld\", &in[i]);\n\t\tMch[in[i]] = i;\n\t\tMsz[in[i]] = 1;\n\t\toin[i] = in[i];\n\t}\n\n\tsort(in + 1, in + N + 1);\n\tfor (i = N; i > 1; i--) {\n\t\tll t = Msz[in[i]];\n\t\tif (2 * t - N >= 0) return !printf(\"-1\\n\");\n\n\t\tll p = in[i] + (2 * t - N);\n\t\tif (!Msz.count(p)) return !printf(\"-1\\n\");\n\t\tMsz[p] += t;\n\n\t\tson[Mch[p]].push_back(Mch[in[i]]);\n\t}\n\n\tint r = Mch[in[1]];\n\tDFS(r);\n\n\tll s = 0;\n\tfor (i = 1; i <= N; i++) {\n\t\tif (sz[i] == 0) return !printf(\"-1\\n\");\n\t\ts += dep[i];\n\t}\n\n\tif (s != oin[r]) return !printf(\"-1\\n\");\n\n\tfor (i = 1; i <= N; i++) {\n\t\tif (i == r) continue;\n\t\tif (oin[i] - oin[par[i]] != N - 2 * sz[i]) return !printf(\"-1\\n\");\n\t}\n\n\tfor (i = 1; i <= N; i++) {\n\t\tif (i == r) continue;\n\t\tprintf(\"%lld %d\\n\", par[i], i);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint gae[100001];\nvector< pair<long long, int> > p;\nvector< pair<int, int> > ans;\nmap<long long, int> mp;\nlong long ll[100001];\nlong long su[100001];\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    for(int i=1;i<=n;i++){\n        long long x;\n        scanf(\"%lld\", &x);\n        p.push_back({x, i});\n        gae[i] = 1;\n        mp[x] = i;\n        su[i] = x;\n    }\n    sort(p.begin(), p.end());\n    for(int i=n-1;i>=1;i--){\n        int target = p[i].second;\n        long long cal = p[i].first - n + gae[target] + gae[target];\n        int nxt = mp[cal];\n        //printf(\"%d %lld\\n\", nxt, cal);\n        if(nxt == 0 || cal >= p[i].first){\n            printf(\"-1\\n\");\n            return 0;\n        }\n        gae[nxt] += gae[target];\n        ll[nxt] += ll[target]; ll[nxt] += gae[target];\n        ans.push_back({nxt, target});\n    }\n    if(ll[p[0].second] == su[p[0].second]){\n        for(auto &anss: ans){\n            printf(\"%d %d\\n\", anss.first, anss.second);\n        }\n    }else{\n        printf(\"-1\\n\");\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N;\n\tcin >> N;\n\tvector< pair<cat, int> > D(N);\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> D[i].ff;\n\t\tD[i].ss = i;\n\t}\n\tsort(begin(D), end(D));\n\tif((int)D.size() > 2 && D[2].ff == D[0].ff) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\tmap<cat, int> M;\n\tfor(int i = 0; i < N; i++) M[D[i].ff] = i;\n\tvector<int> sz(N, 1);\n\tvector< pair<int, int> > E;\n\tfor(int i = N-1; i >= 0; i--) if(D[0].ff != D[i].ff) {\n\t\tif(2*sz[i] >= N) {\n\t\t\tcout << \"-1\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tcat D_up = D[i].ff + sz[i] - (N-sz[i]);\n\t\tauto it = M.find(D_up);\n\t\tif(it == M.end()) {\n\t\t\tcout << \"-1\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tsz[it->ss] += sz[i];\n\t\tE.push_back({D[i].ss, D[it->ss].ss});\n\t}\n\tif(D[1].ff == D[0].ff) {\n\t\tif(2*sz[1] != N || 2*sz[0] != N) {\n\t\t\tcout << \"-1\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tE.push_back({D[0].ss, D[1].ss});\n\t}\n\tfor(int i = 0; i < (int)E.size(); i++) cout << E[i].ff+1 << \" \" << E[i].ss+1 << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\nconst int N = 100 * 1000 + 5;\n\nmap <long long, int> mp;\nvector <pair <int, int> > e;\npair <long long, int> d[N];\nint c[N];\nlong long sum[N];\n\n\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> d[i].first;\n\t\td[i].second = i;\n\t\tc[i] = 1;\n\t}\n\tsort(d + 1, d + n + 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tmp[d[i].first] = i;\n\t}\n\tfor (int i = n; i > 1; i--) {\n\t\tint u = mp[d[i].first - n + 2 * c[i]];\n\t//\tcout << \"73 \" << d[i].second << \" \" << d[u].second << endl;\n\t\tif (u == 0 || u == i) {\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t} \n\t\tc[u] += c[i];\n\t\tsum[u] += c[i] + sum[i];\n\t\te.push_back({d[i].second, d[u].second});\n\t}\n\tif (sum[1] != d[1].first) {\n\t\tcout << -1;\n\t\treturn 0;\n\t} \n\tfor (auto p : e) {\n\t\tcout << p.first << \" \" << p.second << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<vector>\n\ntypedef long long ll;\n\nint const N = 1e5 + 5;\n\nint fa[N];\nint sz[N];\nll a[N];\nll dis[N];\nbool vis[N];\nint n;\n\nstd::vector<int> E[N];\nvoid addedge2(int x, int y) {\n    E[x].push_back(y);\n    E[y].push_back(x);\n}\n\nvoid dfs(int x, ll& sum, int dep) {\n    sz[x] = 1;\n    vis[x] = 1;\n    sum += dep;\n    for(auto y : E[x]) if(vis[y] == 0) {\n        dfs(y, sum, dep + 1);\n        sz[x] += sz[y];\n    }\n}\n\nbool chk(int x, ll ans) {\n    if(a[x] != ans) return 0;\n    vis[x] = 1;\n    bool ret = 1;\n    for(auto& y : E[x]) if(vis[y] == 0) {\n        ret &= chk(y, ans + n - 2ll * sz[y]);\n    }\n    return ret;\n}\n\nint main() {\n    std::map<ll, int, std::greater<ll> > M;\n    std::ios::sync_with_stdio(0);\n    std::cin >> n;\n    for(int i = 1; i <= n; ++i) {\n        std::cin >> a[i];\n        M.insert(std::make_pair(a[i], i));\n    }\n    for(auto& k : M) if(k.first != (*M.rbegin()).first) {\n        int now = k.second;\n        ++sz[now];\n        ll f = k.first + 2ll * sz[now] - n;\n        if(M.count(f) == 0) {\n            puts(\"-1\");\n            return 0;\n        }\n        fa[now] = M[f];\n        sz[fa[now]] += sz[now];\n        ::addedge2(now, fa[now]);\n    }\n    int root = (*M.rbegin()).second;\n    ll ans_root = 0;\n    memset(vis, 0, sizeof(vis));\n    memset(sz, 0, sizeof(sz));\n    dfs(root, ans_root, 0);\n    memset(vis, 0, sizeof(vis));\n    if(chk(root, ans_root) == 0) {\n        puts(\"-1\");\n        return 0;\n    }\n    for(int i = 1; i <= n; ++i) if(fa[i] != 0) {\n        std::cout << fa[i] << ' ' << i << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid err() {\n  cout << -1 << '\\n';\n  exit(0);\n}\nvoid dfs (int crr, int dpt, vector<vector<int>>& grh, long long& cnt) {\n  cnt += dpt;\n  for (int nxt : grh[crr]) {\n    dfs(nxt, dpt + 1, grh, cnt);\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<long long> d(n);\n  map<long long, int> mp;\n  for (int i = 0; i < n; i++) {\n    cin >> d[i];\n    mp[d[i]] = i;\n  }\n  sort(d.begin(), d.end());\n  vector<long long> sz(n, 1);\n  vector<int> prt(n);\n  vector<vector<int>> grh(n);\n  vector<pair<int, int>> edg;\n  for (auto it = prev(d.end()); it != d.begin(); it--) {\n    auto i = mp[*it];\n    long long prtv = *it - n + 2LL * sz[i];\n    auto jt = lower_bound(d.begin(), d.end(), prtv);\n    if (jt == d.end() || *jt != prtv) err();\n    auto p = mp[*jt];\n    prt[i] = p;\n    grh[p].push_back(i);\n    if (i == prt[i]) err();\n    sz[prt[i]] += sz[i];\n    edg.emplace_back(min(i, prt[i]), max(i, prt[i]));\n  }\n  long long cnt = 0;\n  int rt = mp[d[0]];\n  dfs(rt, 0, grh, cnt);\n  if (d[0] != cnt) err();\n  sort(edg.begin(), edg.end());\n  for (auto const & e : edg) {\n    cout << e.first + 1 << ' ' << e.second + 1 << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define llong long long \n#define xx first\n#define yy second\n#define len(x) ((int)x.size())\n#define rep(i,n) for (int i = -1; ++ i < n; )\n#define rep1(i,n) for (int i = 0; i ++ < n; )\n#define all(x) x.begin(), x.end()\n\n#define maxn 101010\nint n;\nint nchild[maxn];\nmap<llong, int> inv_d;\n\nint main(void) {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n;\n    rep1(i, n) {\n      llong d; cin >> d;\n      inv_d[d] = i;\n    }\n    rep1(i, n) nchild[i] = 1;\n\n    vector<pair<int, int>> ans;\n    while (len(inv_d) > 1) {\n      llong d = inv_d.rbegin()->xx;\n      int u = inv_d.rbegin()->yy;\n      inv_d.erase(--inv_d.end());\n      llong td = d - n + 2 * nchild[u];\n      // clog << u << ' ' << d << ' ' << nchild[u] << endl;\n      if (!inv_d.count(td)) {\n        cout << \"-1\";\n        return 0;\n      }\n      int v = inv_d[td];\n      ans.push_back({u, v});\n      // clog << u << ' ' << v << endl;\n      nchild[v] += nchild[u];\n    }\n    rep(i, n - 1) cout << ans[i].xx << ' ' << ans[i].yy << '\\n';\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<map>\nusing namespace std;\ntypedef long long LL;\nconst int N = 1e5+10;\ninline LL read()\n{\n\tregister LL x = 0 , f = 0; register char c = getchar();\n\twhile(c < '0' || c > '9') f |= c == '-' , c = getchar();\n\twhile(c >= '0' && c <= '9') x = (x << 3) + (x << 1) + c - '0' , c = getchar();\n\treturn f ? -x : x;\n}\nint n;\nLL d[N];\nint eu[N] , ev[N] , siz[N];\nvector<int> G[N];\nmap<LL , int> mp;\nstruct node\n{\n\tLL d;\n\tint id;\n}p[N];\n\ninline bool cmp(const node &A , const node &B) { return A.d > B.d; }\n\nvoid dfs1(int x , int dep , int rot)\n{\n\tsiz[x] = 1; d[rot] += dep;\n\tfor(int i = 0 ; i < G[x].size() ; ++i) dfs1(G[x][i] , dep + 1 , rot) , siz[x] += siz[G[x][i]];\n\treturn ;\n}\n\nvoid dfs2(int x)\n{\n\tfor(int i = 0 ; i < G[x].size() ; ++i)\n\t{\n\t\td[G[x][i]] = d[x] + n - 2 * siz[G[x][i]];\n\t\tdfs2(G[x][i]);\n\t}\n\treturn ;\n}\n\nint main()\n{\n\tn = read();\n\tfor(int i = 1 ; i <= n ; ++i) p[i].d = read() , p[i].id = i , mp[p[i].d] = i;\n\tLL sum = 0;\n\tfor(int i = 1 ; i <= n ; ++i) sum += p[i].d;\n\tif(sum & 1) { puts(\"-1\"); return 0; }\n\tsort(p + 1 , p + 1 + n , cmp);\n\tfor(int i = 1 ; i <= n ; ++i) siz[i] = 1;\n\tfor(int i = 1 ; i <  n ; ++i)\n\t{\n\t\tLL fa_d = p[i].d - n + 2 * siz[p[i].id];\n\t\tif(!mp.count(fa_d)) { puts(\"-1\"); return 0; }\n\t\tev[i] = p[i].id; eu[i] = mp[fa_d]; siz[eu[i]] += siz[ev[i]];\n\t}\n\tfor(int i = 1 ; i <  n ; ++i) G[eu[i]].push_back(ev[i]);\n\tdfs1(p[n].id , 0 , p[n].id); dfs2(p[n].id);\n\tfor(int i = 1 ; i <= n ; ++i) if(d[p[i].id] != p[i].d) { puts(\"-1\"); return 0; }\n\tfor(int i = 1 ; i <  n ; ++i) cout << eu[i] << ' ' << ev[i] << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<bits/stdc++.h>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<vector>\n#include<queue>\n#include<deque>\n#define ll long long\n#define mp make_pair\n#define rep(i,x,y) for(int i=(x);i<=(y);++i)\n#define r0p(i,n) for(int i=0;i<n;++i)\n#pragma GCC optimize(1)\n#pragma G++ optimize(1)\n#pragma GCC optimize(2)\n#pragma G++ optimize(2)\n#pragma GCC optimize(3)\n#pragma G++ optimize(3)\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#define pii pair<int,int>\n#pragma GCC diagnostic error \"-std=c++11\"\nusing namespace std;\ninline void rdl(long long &val){\n    long long x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n\t}\n\twhile(ch>='0' and ch<='9'){\n\t    x=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n    val=x*f;\n}\ninline void rdi(int &val){\n    int x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    val=x*f;\n}\ninline long long rdl(){\n    long long x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline int rdi(){\n    int x=0;\n    int f=1;\n\tchar ch=getchar();\n\twhile((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n\tif(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline void write(int x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\ninline void _write(int x){\n\twrite(x);\n\tputchar(' ');\n}\ninline void print(int x){\n\twrite(x);\n\tputchar('\\n');\n}\ninline void write(ll x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\ninline void _write(ll x){\n\twrite(x);\n\tputchar(' ');\n}\ninline void print(ll x){\n\twrite(x);\n\tputchar('\\n');\n}\nstruct dsu{\n\tint par[200200];\n\tinline void init(int _n){for(int i=0;i<_n;++i) par[i]=i;}\n\tinline int find(int now){\n\t\tif(par[now]==now) return now;\n\t\treturn par[now]=find(par[now]);\n\t}\n\tinline bool uni(int a, int b){\n\t\tint Pa(find(a)),Pb(find(b));\n\t\tif(Pa==Pb) return false;\n\t\tpar[Pa]=Pb;\n\t\treturn true;\n\t}\n};\nint main(){\n\tint n,i,j;\n\trdi(n);\n\tvector<ll> d(n);\n\tvector<int> sz(n,1);\n\tmap<ll,int> m;\n\tfor(i=0;i<n;++i){\n\t\trdl(d[i]);\n\t\tm[d[i]]=i;\n\t}\n\tvector<pair<int,int> >ans;\n\tfor(int It=0;It<n-1;++It){\n\t\tauto it=m.begin();\n\t\ti=it->second;\n\t\tll need=d[i]-(n-sz[i])+sz[i];\n\t\tif(m.find(need)==m.end()) return 0*puts(\"-1\");\n\t\tj=m[need];\n\t\tans.emplace_back(i,j);\n\t\tsz[i]+=sz[j];\n\t\tm.erase(--m.end());\n\t}\n\tvector<ll> rd(n,-1);\n\trd[0]=0;\n\tvector<vector<int> >g(n);\n\tfor(auto p:ans){\n\t\tg[p.first].push_back(p.second);\n\t\tg[p.second].push_back(p.first);\n\t}\n\tvector<int> q(1,0);\n\tfor(i=0;i<q.size();++i){\n\t\tfor(int j:g[q[i]]){\n\t\t\tif(!~rd[j]){\n\t\t\t\tq.push_back(j);\n\t\t\t\trd[j]=rd[q[i]]+1;\n\t\t\t}\n\t\t}\n\t}\n\tif(accumulate(rd.begin(),rd.end(),0ll)!=d[0]) return puts(\"-1\")*0;\n\tfor(pair<int,int>p:ans) _write(p.first),print(p.second);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\ntemplate<class T1, class T2> inline bool cmin(T1 &a, const T2 &b) {return b<a?(a=b, true):false;}\ntemplate<class T1, class T2> inline bool cmax(T1 &a, const T2 &b) {return a<b?(a=b, true):false;}\ntemplate<class Type> Type read() {\n\tType a;\n\tbool b;\n\tunsigned char c;\n\twhile(c=getchar()-'0', (c>9)&(c!=253));\n\tfor(a=(b=c==253)?0:c; (c=getchar()-'0')<=9; a=a*10+c);\n\treturn b?-a:a;\n}\nint (*rd)()=read<int>;\nint main() {\n\tint n=rd();\n\tstd::vector<int> size(n, 1), fa(n);\n\tstd::vector<long long> depsum(n);\n\tstd::map<long long, int> id;\n\tfor(int i=0; i<n; ++i) id.emplace(read<long long>(), i);\n\tfor(auto it=id.end(); --it!=id.begin(); ) {\n\t\tint x=it->second;\n\t\tauto i=id.find(it->first+2*size[x]-n);\n\t\tif(2*size[x]>=n||i==id.end()) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tfa[x]=i->second;\n\t\tsize[fa[x]]+=size[x];\n\t\tdepsum[fa[x]]+=depsum[x]+size[x];\n\t}\n\tint root=id.begin()->second;\n\tif(depsum[root]!=id.begin()->first) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=0; i<n; ++i) if(i!=root) printf(\"%d %d\\n\", fa[i]+1, i+1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define int long long\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par, size_;\npublic:\n    UnionFind(){}\n    UnionFind(int node_size) : sz(node_size), par(sz), size_(sz, 1){\n        iota(par.begin(), par.end(), 0);\n    }\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n    void unite(int x,int y){\n        x = find(x), y = find(y);\n        if(x == y) return;\n        if(size_[x] < size_[y]) swap(x,y);\n        par[y] = x;\n        size_[x] += size_[y];\n    }\n    int size(int x){\n        x = find(x);\n        return size_[x];\n    }\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n};\n\nsigned main(){\n    int n;\n    cin >> n;\n    UnionFind uf(n+1);\n    vector<pair<int,int> > v;\n    map<int,int> p;\n    rep(i,n){\n        int d;\n        cin >> d;\n        p[d] = i+1;\n        v.push_back(MP(d,i+1));\n    }\n    sort(v.begin(),v.end(),greater<pair<int,int> >());\n    map<int,int> mp;\n    vector<pair<int,int> > g;\n    bool ng = 1;\n    rep(i,n){\n        int k = v[i].first;\n        int u = v[i].second;\n        int c = mp[k];\n        c++;\n        //cerr << k << \" \" << u << \" \" << c << endl;\n        if(c==n&&i==n-1){\n            ng = 0;\n            continue;\n        }\n        int nxt = k - (n-c-c);\n        if(p.find(nxt)==p.end()){\n            cout << -1 << endl;\n            return 0;\n        }\n        mp[nxt]+=c;\n        g.push_back(MP(u,p[nxt]));\n        uf.unite(u,p[nxt]);\n    }\n    for(int i=1;i<=n;i++){\n        if(!uf.same(i,1)){\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n    if(ng){\n        cout << -1 << endl;\n        return 0;\n    }\n    cout << -1 << endl;\n    return 0;\n    for(auto x:g){\n\n        cout << x.first << \" \" << x.second << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 998244353;\nconst int N = 10000005;\nconst int K = 25;\nint d[N], sz[N], p[N];\npair < int, int > a[N];\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++){\n        cin >> d[i];\n        a[i] = {d[i], i};\n    }\n    set < pair < int, int > > s;\n    sort(a + 1, a + n + 1);\n    reverse(a + 1, a + n + 1);\n    for (int i = 1; i <= n; i++) sz[i] = 1;\n    for (int i = 1; i <= n; i++){\n        int v = a[i].S;\n        auto x = s.lower_bound({d[v], 0});\n        while(x != s.end() && (*x).F == d[v]){\n            int u = (*x).S;\n            p[u] = v;\n            sz[v] += sz[u];\n            x++;\n        }\n        s.insert({d[v] + sz[v] - (n - sz[v]), v});\n    }\n    vector < pair < int, int > > ans;\n    for (int i = 1; i <= n; i++){\n        if (p[i] != 0){\n            ans.pb({i, p[i]});\n        }\n    }\n    if (ans.size() != n - 1) cout << -1; else{\n        for (auto i: ans){\n            cout << i.F << \" \" << i.S << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\nstruct node\n{\n\tlong long d;int p;\n}a[100010];\nstruct bian\n{\n\tint x,y;\n}e[100010];int len;\nbool cmp(node a,node b){return a.d<b.d;}\nint n;\nbool v[100010];\ninline int erfen(long long x)\n{\n\tint l=1,r=n,ans;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)/2;\n\t\tif(a[mid].d<=x)ans=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\tfor(int i=ans;i>=1;i--)\n\t{\n\t\tif(a[i].d!=x)break;\n\t\tif(a[i].d==x && v[i]==false)return i;\n\t}\n\treturn -1;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i].d),a[i].p=i;\n\tsort(a+1,a+n+1,cmp);\n\tbool bk=true;\n\tfor(int i=n;i>=2;i--)\n\t{\n\t\tif(v[i]==true)continue;\n\t\tlong long tot=a[i].d;int dep=2,now=i;\n\t\twhile(1)\n\t\t{\n\t\t\ttot=tot-(n-dep)+dep-2;\n\t\t\tint y=erfen(tot);\n\t\t\tif(y==-1){bk=false;break;}\n\t\t\tlen++;\n\t\t\te[len].x=a[y].p;e[len].y=a[now].p;\n\t\t\tif(y!=1)v[y]=true;\n\t\t\tif(y==1)break;\n\t\t\tnow=y;dep++;\n\t\t}\n\t}\n\tif(bk==false)printf(\"-1\\n\");\n\telse for(int i=1;i<=len;i++)printf(\"%d %d\\n\",e[i].x,e[i].y);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimiz(O2)\n\n#include <bits/stdc++.h>\n\n#define rg register\nusing namespace std;\ntypedef long long ll;\n\ntemplate<typename T>\ninline bool read(T &n) {\n    T ans = 0, flag = 1;\n    char ch;\n    while ((ch = getchar()) < '0' || ch > '9') if (ch == '-') flag = -1; else if (ch == EOF) return false;\n    ans = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9') ans = ans * 10 + ch - '0';\n    n = ans * flag;\n    return true;\n}\n\ninline ll read() {\n    ll ans = 0, flag = 1;\n    char ch;\n    while ((ch = getchar()) < '0' || ch > '9') if (ch == '-') flag = -1;\n    ans = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9') ans = ans * 10 + ch - '0';\n    return ans * flag;\n};\nconst int maxn = 100005;\nstruct NODE {\n    ll val, ord;\n    bool operator<(NODE b) const {\n        return val < b.val;\n    }\n} node[maxn];\nstruct EDGE{\n    int nex,t;\n}edge[maxn<<1];\n\nint ecnt,head[maxn],siz[maxn],fa[maxn];\nunordered_map<ll,int> unM;\ninline void addedge(int u,int v){\n    edge[++ecnt].nex=head[u];head[u]=ecnt;edge[ecnt].t=v;\n    edge[++ecnt].nex=head[v];head[v]=ecnt;edge[ecnt].t=u;\n}\nint dfs(int rt,int fa,int dis){\n    int ans=dis;\n    for(rg int i=head[rt];i;i=edge[i].nex){\n        int y=edge[i].t;\n        if(y==fa) continue;\n        ans+=dfs(y,rt,dis+1);\n    }\n    return ans;\n}\nint main() {\n    int n;\n    read(n);priority_queue<NODE> pq;\n    for (rg int i = 1; i <= n; ++i) {\n        siz[i] = 1;read(node[i].val);\n        node[i].ord = i;\n        pq.push(node[i]);\n        unM[node[i].val]=i;\n    }\n    for(rg int i=n;i>=2;i--){\n        NODE now=pq.top();pq.pop();\n        if(unM.find(now.val+2*siz[now.ord]-n)==unM.end()){\n            puts(\"-1\");return 0;\n        }\n        fa[now.ord]=unM[now.val+2*siz[now.ord]-n];\n        siz[fa[now.ord]]+=siz[now.ord];\n        addedge(now.ord,fa[now.ord]);\n    }\n    if(siz[pq.top().ord]!=n||dfs(1,0,0)!=pq.top().val) puts(\"-1\");\n    else\n    for(rg int i=1;i<=n;i++){\n        if(fa[i]) cout<<i<<' '<<fa[i]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int64_t, int64_t> Pair;\n\nvoid fail(){\n    cout << -1 << endl;\n    exit(0);\n}\n\nint main(){\n    int i, j, k;\n    int N;\n    cin >> N;\n    vector<Pair> D(N);\n\n    for(i=0; i<N; i++){\n        int64_t d;\n        cin >> d;\n        D.push_back({d, i});\n    }\n    sort(D.rbegin(), D.rend());\n\n    map<int64_t, int64_t> mp;\n    for(i=0; i<N; i++) mp[D[i].first] = i;\n\n    vector<Pair> ans;\n    vector<int64_t> dist_sub(N, 0);\n    vector<int> num_sub(N, 1);\n\n    for(i=0; i<N-1; i++){\n        int64_t diff = N - 2*num_sub[i];\n        int64_t pd = D[i].first - diff;\n        if(mp.count(pd)){\n            int p = mp[pd];\n            ans.push_back({D[i].second+1, D[p].second+1});\n            num_sub[p] += num_sub[i];\n            dist_sub[p] += dist_sub[i] + num_sub[i];\n        }else{\n            fail();\n        }\n    }\n    if(dist_sub[N-1] != D[N-1].first) fail();\n\n    for(auto&& e : ans){\n        cout << e.first << \" \" << e.second << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fo(i,s,t) for(int i = s; i <= t; ++ i)\n#define fd(i,s,t) for(int i = s; i >= t; -- i)\n#define bf(i,s) for(int i = head[s]; i; i = e[i].next)\n#define mp make_pair\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pb push_back\n#define VI vector<int>\n#define sf scanf\n#define pf printf\n#define fp freopen\n#define SZ(x) ((int)(x).size())\n#ifdef MPS\n#define D(x...) printf(x)\n#else\n#define D(x...)\n#endif\ntypedef long long ll;\ntypedef double db;\ntypedef unsigned long long ull;\nconst int inf = 1<<30;\nconst ll INF = 1ll<<60;\nconst db Inf = 1e20;\nconst db eps = 1e-9;\n\nvoid gmax(int &a,int b){a = (a > b ? a : b);}\nvoid gmin(int &a,int b){a = (a < b ? a : b);}\n\nconst int maxn = 100050;\n\nint n, sz[maxn];\npair<ll,int> d[maxn];\nstruct edge{int u, v;}e[maxn];\n\nint main()\n{\n\tsf(\"%d\",&n);\n\tfo(i,1,n) sf(\"%I64d\",&d[i].fi), d[i].se = i;\n\tsort(d+1, d+n+1);\n\tfd(i,n,2)\n\t{\n\t\tsz[i] ++;\n\t\tint l = 1, r = i-1, mid, p = -1;\n\t\twhile(l <= r)\n\t\t{\n\t\t\tmid = (l + r) >> 1;\n\t\t\tif(d[mid].fi <= d[i].fi-n+2*sz[i]) p = mid, l = mid + 1;\n\t\t\telse r = mid - 1;\n\t\t}\n\t\tif(p == -1) assert(0);\n\t\tif(d[p].fi != d[i].fi-n+2*sz[i]) return 0 * pf(\"-1\\n\");\n\t\tsz[p] += sz[i];\n\t\te[i].u = d[p].se; e[i].v = d[i].se;\n\t}\n\tsz[1] ++;\n\tll ans = 0;\n\tfo(i,1,n) ans += sz[i] * (ll)(n - sz[i]);\n\tans <<= 1;\n\tfo(i,1,n) ans -= d[i].fi;\n\tif(ans != 0) return 0 * pf(\"-1\\n\");\n\tfo(i,2,n) pf(\"%d %d\\n\",e[i].u,e[i].v);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 100000;\n\nvector<int>G[MAXN + 5];\nmap<ll, int>mp;\nint siz[MAXN + 5];\n\nll check(int x) {\n\tll ret = 0;\n\tfor (int i = 0; i < G[x].size(); i++) {\n\t\tint to = G[x][i];\n\t\tret += check(to) + siz[to];\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint n; scanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tll D; scanf(\"%lld\", &D);\n\t\tmp[D] = i, siz[i] = 1;\n\t}\n\tmap<ll, int>::reverse_iterator rt;\n\tfor (map<ll, int>::reverse_iterator it = mp.rbegin(); it != mp.rend(); it++) {\n\t\tif (siz[it->second] == n) {\n\t\t\trt = it;\n\t\t\tbreak;\n\t\t}\n\t\tint x = it->second;\n\t\tll k = it->first + siz[x] - (n - siz[x]);\n\t\tif (k < it->first && mp.count(k)) {\n\t\t\tint p = mp[k];\n\t\t\tsiz[p] += siz[x];\n\t\t\tG[p].push_back(x);\n\t\t}\n\t\telse {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (check(rt->second) == rt->first) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 0; j < G[i].size(); j++)\n\t\t\t\tprintf(\"%d %d\\n\", i, G[i][j]);\n\t\t}\n\t}\n\telse puts(\"-1\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define re register\n#define gc getchar\n#define pc putchar\n#define cs const\n\ninline\nll getint(){\n\tre ll num;\n\tre char c;\n\twhile(!isdigit(c=gc()));num=c^48;\n\twhile(isdigit(c=gc()))num=(num<<1)+(num<<3)+(c^48);\n\treturn num;\n}\n\ninline\nvoid outint(int a){\n\tstatic char ch[13];\n\tif(a==0)pc('0');\n\twhile(a)ch[++ch[0]]=a-a/10*10,a/=10;\n\twhile(ch[0])pc(ch[ch[0]--]^48);\n}\n\ncs int N=100005;\n\nint last[N],nxt[N],to[N],ecnt;\ninline\nvoid addedge(int u,int v){\n\tnxt[++ecnt]=last[u],last[u]=ecnt,to[ecnt]=v;\n}\n\nmap<ll,int> id;\nint n;\nll d[N];\nint siz[N];\n\nint dist[N];\ninline\nvoid dfs(int u){\n\tfor(int re e=last[u],v=to[e];e;v=to[e=nxt[e]]){\n\t\tdist[v]=dist[u]+1;\n\t\tdfs(v);\n\t}\n}\n\nvector<pair<int,int> > edge;\n\nsigned main(){\n\tn=getint();\n\tfor(int re i=1;i<=n;++i)d[i]=getint(),id[d[i]]=i;\n\t\n\tsort(d+1,d+n+1);\n\tfor(int re i=1;i<=n;++i)siz[i]=1;\n\t\n\tfor(int re i=n;i>1;--i){\n\t\tint u=id[d[i]];\n\t\tint tmp=n-2*siz[u];\n\t\tif(tmp<=0)return puts(\"-1\"),0; \n\t\tll t=d[i]-tmp;\n\t\tif(id.count(t)==0)return puts(\"-1\"),0;\n\t\tint pos=id[t];\n\t\taddedge(pos,u);\n\t\tsiz[pos]+=siz[u];\n\t\tedge.push_back(make_pair(pos,u));\n\t}\n\tll sum=0;\n\tdfs(id[d[1]]);\n\tfor(int re i=1;i<=n;++i){\n\t\tsum+=dist[i];\n\t}\n\tif(sum!=d[1])return puts(\"-1\"),0;\n\tfor(int re i=0;i<edge.size();++i)outint(edge[i].first),pc(' '),outint(edge[i].second),pc('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN=2e5+7;\n\nint cntm;\nint from[MAXN],to[MAXN];\n\nmap<ll,int> Map,Map2;\n\nint n;\nll a[MAXN],b[MAXN],siz[MAXN];\n\nbool cmp(const ll &A,const ll &B){return a[A]>a[B];}\nbool cmp2(const ll &A,const ll &B){return A>B;}\n\nint main() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) {\n\t\tcin>>a[i];\n\t\tb[i]=i;\n\t\tMap[a[i]]=i;\n\t\tsiz[i]=1;\n\t}\n\tsort(b+1,b+1+n,cmp);\n\tsort(a+1,a+1+n,cmp2);\n\tfor(int i=1;i<=n;i++)\n\t\tMap2[a[i]]=i;\n\tfor(int i=1,i2;i<n;i++) {\n\t\ti2=Map[a[i]-(n-2*siz[i])];\n\t\tif(i2!=0&&i2!=b[i]) {\n\t\t\tsiz[Map2[a[i]-(n-2*siz[i])]]+=siz[i];\n\t\t\tfrom[++cntm]=i2;\n\t\t\tto[cntm]=b[i];\n\t\t}\n\t\telse {\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++) {\n\t\tcout<<from[i]<<\" \"<<to[i]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nvector<l_l> D;\nll SIZE[100500];\nmap<ll, ll> mp;\nll dist[100050];\nvector<ll> pathes[100050];\nll ONED;\n\nvoid dfs(int now, int from) {\n    for(auto to : pathes[now]) {\n        if(to == from) continue;\n        dist[to] = dist[now] + 1;\n        dfs(to, now);\n    }\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N;\n    cin >> N;\n    D.resize(N);\n    for(int i = 1; i <= N; i++) {\n        cin >> D[i-1].first;\n        D[i-1].second = i;\n        SIZE[i] = 1;\n        mp[D[i-1].first] = i;\n    }\n    ONED = D[0].first;\n    sort(D.begin(), D.end(), greater<l_l>());\n    vector<l_l> ans;\n    for(int i = 0; i < N - 1; i++) {\n        int index = D[i].second;\n        ll val = D[i].first;\n        val += SIZE[index] - (N - SIZE[index]);\n        if(SIZE[index] * 2 >= N) {\n            cout << -1 << endl;\n            return 0;\n        }\n        if(mp[val] == 0) {\n            cout << -1 << endl;\n            return 0;\n        }\n        SIZE[mp[val]] += SIZE[index];\n        ans.push_back({index, mp[val]});\n        pathes[index].push_back(mp[val]);\n        pathes[mp[val]].push_back(index);\n    }\n    dfs(1, -1);\n    ll distsum = 0;\n    for(int i = 1; i <= N; i++) distsum += dist[i];\n    if(distsum != ONED) {\n        cout << -1 << endl;\n        return 0;\n    }\n    for(auto e : ans) cout << e.first << \" \" << e.second << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100005\n#define rep(i,n) for((i)=0;(i)<(n);(i)++) \n#define LL long long\n#define pii pair<LL,int>\n#define F first\n#define S second\n#define pb push_back\n\nint i;\nint n;\npii d[N];\nmap<LL,int> mp;\nmap<pii,bool> KK;\nbool vis[N];\nint last;\nLL len,now;\nvector<pii> ans;\n\nint main()\n{\n\t\n\tcin>>n;\n\trep(i,n)\n\t{\n\t\tcin>>d[i].F;\n\t\td[i].S=i;\n\t}\n\tsort(d,d+n);\n\tfor(int j=0,k=n-1;j<k;j++,k--)\n\t\tswap(d[j],d[k]);\n\trep(i,n)\n\t\tmp[d[i].F]=d[i].S;\n\t\n\trep(i,n)\n\t{\n\t\tif(vis[d[i].S]) continue;\n\t\tvis[d[i].S]=1;\n\t\tlast=d[i].S;\n\t\tlen=n;\n\t\tnow=d[i].F;\n\t\twhile(1)\n\t\t{\n\t\t\tlen-=2;\n\t\t\tnow-=len;\n\t\t\tif(now<d[n-1].F || len<0) break;\n\t\t\tif(mp.find(now)==mp.end())\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(!KK[make_pair(last+1,mp[now]+1)]) ans.pb(make_pair(last+1,mp[now]+1));\n\t\t\tif(last==mp[now])\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t} \n\t\t\tKK[make_pair(last+1,mp[now]+1)]=1;\n\t\t\tKK[make_pair(mp[now]+1,last+1)]=1;\n\t\t\tlast=mp[now];\n\t\t\tvis[last]=1;\n\t\t}\n\t}\n\tif(ans.size()!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\trep(i,ans.size())\n\t\tcout<<ans[i].F<<\" \"<<ans[i].S<<'\\n';\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author zjsdut\n */\n\n#ifndef ALGO_UTILS\n#define ALGO_UTILS\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <vector>\ntemplate<typename A, typename B>\nbool chkmin(A &a, const B &b) {\n  if (b < a) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate<typename A, typename B>\nbool chkmax(A &a, const B &b) {\n  if (b > a) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing vl = std::vector<ll>;\nusing vb = std::vector<bool>;\nusing vi = std::vector<int>;\nusing pii = std::pair<int, int>;\nusing pli = std::pair<ll, int>;\nusing pil = std::pair<int, ll>;\nusing pll = std::pair<ll, ll>;\nusing vpii = std::vector<pii>;\ntemplate<typename T>\nclass vv {\n  std::vector<std::vector<T>> data;\n\n public:\n  vv(int n, int m, T init = T{}) {\n    assert(n > 0 && m > 0);\n    data.assign(n, std::vector<T>(m, init));\n  }\n  std::vector<T> &operator[](size_t i) { return data[i]; }\n};\n#define rng3(i, a, b) for (std::common_type<decltype(a), decltype(b)>::type i = a; i < b; ++i)\n#define rng2(i, n) rng3(i, 0, n)\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define rng(...) GET_MACRO(__VA_ARGS__, rng3, rng2)(__VA_ARGS__)\n#define up(i, a, b) for (std::common_type<decltype(a), decltype(b)>::type i = a; i <= b; ++i)\n#define down(i, b, a) for (std::common_type<decltype(a), decltype(b)>::type i = b; i >= a; i--)\n#define TOKENPASTE(x, y) x##y\n#define TOKENPASTE2(x, y) TOKENPASTE(x, y)\n#define rep(n)                                                                                     \\\n  for (int TOKENPASTE2(_iter_, __LINE__) = 0, TOKENPASTE2(_num_, __LINE__) = n;                    \\\n       TOKENPASTE2(_iter_, __LINE__) < TOKENPASTE2(_num_, __LINE__);                               \\\n       ++TOKENPASTE2(_iter_, __LINE__))\n#define FOR(x, cont) for (const auto &x : cont)\n#define For(x, cont) for (auto &x : cont)\n#define ALL(x) begin(x), end(x)\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ep emplace\n#define SZ(x) (int) (x).size()\n#define UNIQ(vec) (vec).erase(std::unique(ALL(vec)), std::end(vec))\n#define LB(cont, x) int(std::lower_bound(ALL(cont), x) - std::begin(cont))\n#define UB(cont, x) int(std::upper_bound(ALL(cont), x) - std::begin(cont))\ntemplate<typename T, typename U = std::less<T>>\nusing pq = std::priority_queue<T, std::vector<T>, U>;\ntemplate<typename T>\nstruct reversion_wrapper {\n  T &iterable;\n};\ntemplate<typename T>\nauto begin(reversion_wrapper<T> w) {\n  return std::rbegin(w.iterable);\n}\ntemplate<typename T>\nauto end(reversion_wrapper<T> w) {\n  return std::rend(w.iterable);\n}\ntemplate<typename T>\nreversion_wrapper<T> reverse(T &&iterable) {\n  return {iterable};\n}\ntemplate<typename T, typename U>\nT ceil(T x, U y) {\n  assert(y > 0);\n  if (x > 0) x += y - 1;\n  return x / y;\n}\n\ntemplate<typename T, typename U>\nT floor(T x, U y) {\n  assert(y > 0);\n  if (x < 0) x -= y - 1;\n  return x / y;\n}\n#endif\n#ifndef JHELPER_EXAMPLE_PROJECT_LIBRARY_IO_HPP_\n#define JHELPER_EXAMPLE_PROJECT_LIBRARY_IO_HPP_\n#include <iostream>\n#include <iomanip>\n\nstruct fast_ios {\n  fast_ios() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n    std::cout << std::fixed << std::setprecision(10);\n  };\n} fast_ios_;\n\ntemplate<typename T>\nstd::istream &operator>>(std::istream &stream, std::vector<T> &vec) {\n  for (auto &x : vec)\n    stream >> x;\n  return stream;\n}\n\ntemplate<typename T, typename U>\nstd::istream &operator>>(std::istream &in, std::pair<T, U> &p) {\n  in >> p.first >> p.second;\n  return in;\n}\n\nvoid scan() {}\n\ntemplate<class T, class... Args>\nvoid scan(T &a, Args &... rest) {\n  std::cin >> a;\n  scan(rest...);\n}\n\ntemplate<typename T>\nstd::ostream &operator<<(std::ostream &stream, const std::vector<T> &vec) {\n  bool first = true;\n  for (const T &t : vec) {\n    if (first) first = false;\n    else std::cout << ' ';\n    std::cout << t;\n  }\n  return stream;\n}\n\ntemplate<typename T, typename U>\nstd::ostream &operator<<(std::ostream &out, const std::pair<T,U> &p) {\n  out << p.first << ' ' << p.second;\n  return out;\n}\n\ntemplate<typename T>\nvoid print(const std::vector<std::vector<T>> &t) {\n  for (const auto &row : t) {\n    std::cout << row << '\\n';\n  }\n}\n\ntemplate<typename T>\nvoid print(const T &t) { std::cout << t << ' '; }\n\ntemplate<typename T, typename... Args>\nvoid print(const T &t, const Args &... rest) {\n  print(t);\n  print(rest...);\n}\n\ntemplate<typename T>\nvoid println(const T &t) { std::cout << t << '\\n'; }\n\ntemplate<typename T, typename... Args>\nvoid println(const T &t, const Args &... rest) {\n  print(t);\n  println(rest...);\n}\n#endif //JHELPER_EXAMPLE_PROJECT_LIBRARY_IO_HPP_\n\nusing namespace std;\nclass FDistanceSums {\npublic:\n  static void solve(istream&, ostream&) {\n    int n;\n    scan(n);\n    vi sz(n, 1);\n    map<ll,int> index;\n    rng (i,n) {\n      ll d;\n      scan(d);\n      index[d] = i;\n    }\n    vpii edges;\n    auto iter = index.rbegin();\n    rep (n - 1) {\n      auto [d, i] = *iter;\n      ll nd = d + 2 * sz[i] - n;\n      if (nd >= d) {\n        println(-1);\n        return;\n      }\n      auto iter2 = index.find(nd);\n      if (iter2 == index.end()) {\n        println(-1);\n        return;\n      }\n      sz[iter2->second] += sz[i];\n      edges.eb(i, iter2->second);\n      ++iter;\n    }\n    FOR (p, edges) {\n      println(p.first + 1, p.second + 1);\n    }\n  }\n};\n/*\n * Make sure that your laptop is plugged in or the build may be slow.\n */\n\n#define in std::cin\n#define out std::cout\nint main() {\n  FDistanceSums solver;\n  solver.solve(in, out);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = 1e5 + 100;\nll n;\nvector<vector<ll>> gr;\nvector<pair<ll, ll>> vec;\n\nll sub[SZ], dp[SZ];\nmap<ll, ll> m;\n\nint main()\n{\n\tfastInp;\n\n\tcin >> n;\n\n\tvec.resize(n);\n\tfor (auto &cur : vec) cin >> cur.first;\n\tfor (int i = 0; i < n; i++) {\n\t\tsub[i] = 1;\n\t\tvec[i].second = i;\n\t\tm[vec[i].first] = vec[i].second;\n\t}\n\n\tsort(vec.rbegin(), vec.rend());\n\n\tvector<pair<ll, ll>> edges;\n\tfor (int i = 0; i < vec.size() - 1; i++) {\n\t\tll par = vec[i].first + sub[vec[i].second] - (n - sub[vec[i].second]);\n\t\tif (m.find(par) == m.end() || m[par] == vec[i].second) {\n\t\t\tcout << \"-1\";\n\t\t\treturn 0;\n\t\t}\n\n\t\tsub[m[par]] += sub[vec[i].second];\n\t\tdp[m[par]] += sub[vec[i].second] + dp[vec[i].second];\n\t\tedges.push_back({ vec[i].second, m[par] });\n\t}\n\n\tif (dp[vec.back.second] != vec.back.first) {\n\t\tcout << \"-1\";\n\t\treturn 0;\n\t}\n\tfor (auto cur : edges) {\n\t\tcout << cur.first + 1 << \" \" << cur.second + 1 << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fst(t) std::get<0>(t)\n#define snd(t) std::get<1>(t)\n#define thd(t) std::get<2>(t)\n#define unless(p) if(!(p))\n#define until(p) while(!(p))\n\nusing ll = std::int64_t;\nusing P = std::tuple<int,int>;\n\nint N;\nll D[100100];\nstd::map<ll,int> ma;\nstd::vector<int> order;\nstd::vector<P> G;\nint A[100100];\nll B[100100];\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    std::cin >> N;\n\n    for(int i=1;i<=N;++i){\n        std::cin >> D[i];\n        ma[D[i]] = i;\n    }\n\n    order.resize(N);\n    std::iota(order.begin(), order.end(), 1);\n    std::sort(order.begin(), order.end(), [](const int& l, const int& r){return D[l] > D[r];});\n    \n    for(int i=0;i<N-1;++i){\n        int v = order[i];\n\n        A[v] += 1;\n\n        ll d = N - 2 * A[v];\n\n        unless(ma.count(D[v] - d) > 0){\n            std::cout << -1 << std::endl;\n            return 0;\n        }\n\n        int w = ma[D[v] - d];\n        \n        G.emplace_back(v, w);\n\n        B[w] += B[v] + A[v];\n        A[w] += A[v];\n    }\n\n    unless(B[order[N-1]] == D[order[N-1]]){\n        std::cout << -1 << std::endl;\n        return 0;\n    }\n\n    for(auto &e : G){\n        int v, w;\n        std::tie(v, w) = e;\n\n        std::cout << v << \" \" << w << std::endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define ll long long\n#define dl double long\n\nusing namespace std;\n\nconst int N = 1e6 + 7;\nconst ll mod = 1e9 + 7;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint n;\nll s[N];\npair < ll , int > d[N];\nll dd[N];\nll p[N];\nvector < int > v[N];\nmap < ll , int > m;\n\nvoid dfs( int x , int p )\n{\n    s[x] = 1;\n    for( auto y : v[x] ){\n        if( y == p )continue;\n        dfs( y , x );\n        s[x] += s[y];\n    }\n}\n\nvoid foo( int x , int p , int val )\n{\n    dd[1] += val;\n    for( auto y : v[x] ){\n        if( y == p )continue;\n        foo( y , x , val + 1 );\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    //freopen( \"input.txt\" , \"r\" , stdin );\n    //freopen( \"output.txt\" , \"w\" , stdout );\n\n    cin >> n;\n    for( int i = 1; i <= n; i++ ){\n        cin >> d[i].fi;\n        d[i].se = i;\n        m[d[i].fi] = i;\n    }\n    sort( d + 1 , d + n + 1 );\n    reverse( d + 1 , d + n + 1 );\n    for( int i = 1; i < n; i++ ){\n        int x = d[i].se;\n        ll sum = d[i].fi + 2 * s[x] + 2 - n;\n        if( m.find(sum) == m.end() || sum > d[i].fi ){\n            cout << \"-1\\n\";\n            return 0;\n        }\n        int y = m[sum];\n        v[x].push_back(y);\n        v[y].push_back(x);\n        s[y] += s[x] + 1;\n    }\n    dfs( 1 , 1 );\n    foo( 1 , 1 , 0 );\n    queue < int > g;\n    g.push(1);\n    vector < int > used(n + 1,  0);\n    used[1] = 1;\n    while( !g.empty() ){\n        int x = g.front();\n        g.pop();\n        for( auto y : v[x] ){\n            if( used[y] ){\n                if( p[x] == y )continue;\n                if( dd[y] != dd[x] - s[y] + (n - s[y]) ){\n                    cout << \"-1\\n\";\n                    return 0;\n                }\n            }else{\n                p[y] = x;\n                used[y] = true;\n                g.push(y);\n                dd[y] = dd[x] - s[y] + n - s[y];\n            }\n        }\n    }\n    sort( d + 1 , d + n + 1 , [&](pair < ll , int > a, pair < ll , int > b ){\n        return a.se < b.se;\n    });\n    for( int i = 1; i <= n; i++ ){\n        if( d[i].fi != dd[i] ){\n            cout << \"-1\\n\";\n            return 0;\n        }\n        used[i] = 0;\n    }\n    for( int i = 1; i <= n; i++ ){\n        used[i] = 1;\n        for( auto x : v[i] ){\n            if( used[x] )continue;\n            cout << i << \" \" << x << \"\\n\";\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,j,k) for(int i=j;i<=k;++i)\ntypedef long long ll;\nchar cch;\ninline int rd(){\n\tint x=0,fl=1;\n\tcch=getchar();\n\twhile(cch>'9'||cch<'0'){\n\t\tif(cch=='-') fl=-1;\n\t\tcch=getchar();\n\t}\n\twhile(cch>='0'&&cch<='9') x=(x<<3)+(x<<1)+cch-'0',cch=getchar();\n\treturn x*fl;\n}\nconst int N=1e5+3;\nstruct abc{\n\tint i;\n\tll d;\n}a[N];\nint fr[N],head[N],to[N],nxt[N],cnt,sz[N];\nll re,c[N];\ninline bool cmp(const abc &a,const abc &b){\n\treturn a.d<b.d;\n}\ninline void adde(int u,int v){\n\tto[++cnt]=v,fr[cnt]=u,nxt[cnt]=head[u],head[u]=cnt;\n\tto[++cnt]=u,fr[cnt]=v,nxt[cnt]=head[v],head[v]=cnt;\n}\ninline void dfs(int u,int fa,int dep){\n\tre+=dep;\n\tfor(int i=head[u];i;i=nxt[i])if(to[i]!=fa){\n\t\tdfs(to[i],u,dep+1);\n\t}\n}\nint main(){\n\tint n=rd();\n\trep(i,1,n) a[i].d=rd(),a[i].i=i;\n\tsort(a+1,a+1+n,cmp);\n\trep(i,1,n) c[i]=a[i].d;\n\tint pos;\n\tll tmp;\n\tfor(int i=n;i>1;--i){\n\t\ttmp=a[i].d-(n-2-sz[a[i].i])+sz[a[i].i];\n\t\tpos=lower_bound(c+1,c+n+1,tmp)-c;\n\t\tif(c[pos]!=tmp){\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t\telse sz[a[pos].i]+=sz[a[i].i]+1,adde(a[pos].i,a[i].i);\n\t}\n\tdfs(a[1].i,0,0);\n\tif(re!=a[1].d){\n\t\tputs(\"-1\");return 0;\n\t}\n\tint ed=n-1<<1;\n\tfor(int i=1;i<=ed;i+=2){\n\t\tprintf(\"%d %d\\n\",fr[i],to[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm> \n#include<cstdio>\n#define N 100001\nusing namespace std;\nint b[N],f[N],i,n,s[N];long long a[N];\ninline bool cmp(int u,int v){return a[u]<a[v];}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)scanf(\"%lld\",a+i),s[b[i]=i]=1;\n\tsort(b+1,b+n+1,cmp);\n\tfor(i=n;i>1;i--)\n\t{\n\t\tif(s[b[i]]<<1>=n)return 0*puts(\"-1\");\n\t\t*a=a[b[i]]-n+(s[b[i]]<<1),f[b[i]]=lower_bound(b+1,b+n+1,0,cmp)-b;\n\t\tif(f[b[i]]>n||a[b[f[b[i]]]]!=*a)return 0*puts(\"-1\");\n\t\ts[f[b[i]]=b[f[b[i]]]]+=s[b[i]];\n\t}\n\tfor(i=2;i<=n;i++)printf(\"%d %d\\n\",b[i],f[b[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=1e5+10;\nint n,cnt,e,f[N],a[N],id[N],siz[N],res[N],head[N],link[N*2],to[N*2];\nbool vis[111111];\nmap <int,int> mp;\nbool cmp(int x,int y){return a[x]<a[y];}\nvoid add(int u,int v){to[++e]=v,link[e]=head[u],head[u]=e;}\nvoid dfs1(int u,int dep){\n\tsiz[u]=1,res[id[1]]+=dep;\n\tfor(int i=head[u];i;i=link[i])if(to[i]!=f[u])dfs1(to[i],dep+1),siz[u]+=siz[to[i]];\n}\nvoid dfs2(int u){for(int i=head[u];i;i=link[i])if(to[i]!=f[u])res[to[i]]=res[u]+n-2*siz[to[i]],dfs2(to[i]);}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),id[i]=i,mp[a[i]]=i,siz[i]=1;\n\tsort(id+1,id+n+1,cmp);\n\tfor(int i=n;i>1;i--){\n\t\tint x=2*siz[id[i]]-n+a[id[i]];\n\t\tif(!mp.count(x)||n-2*siz[id[i]]<=0){printf(\"-1\");return 0;}\n\t\tint pos=mp[x];add(pos,id[i]),add(id[i],pos),siz[pos]+=siz[id[i]],f[id[i]]=pos;\n\t}\n\tdfs1(id[1],0),dfs2(id[1]);\n\tfor(int i=1;i<=n;i++)if(a[i]!=res[i]){printf(\"-1\");return 0;}\n\tfor(int i=2;i<=n;i++)printf(\"%lld %lld\\n\",f[id[i]],id[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#include<iostream>\n#include<map>\n#include<vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__) \n#define ref(a,b,c) for(int a=b;a<=c;++a)\n#define def(a,b,c) for(int a=b;a>=c;--a)\n#define fi first\n#define se second\nusing namespace std;\ninline char nc(){\n//\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++; \n}\ntemplate<class T>void read(T &x){\n\tx=0;int f=1,ch=nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx*=f;\n}\ntypedef long long LL;\ntypedef pair<int,int> pii;\nconst int maxn=1e5+10;\nLL D[maxn];\nLL f[maxn];\nint n;\nint p[maxn];\nint siz[maxn];\nmap<LL,int>idx; \nvector<pii>an; \ninline int cmp(const int&a,const int&b){\n\treturn D[a]>D[b];\n}\nbool solve(){\n\tref(i,1,n)p[i]=i,siz[i]=1,f[i]=0;\n\tsort(p+1,p+n+1,cmp);\n\tref(i,1,n-1){\n\t\tint u=p[i];\n\t\tif(!idx.count(D[u]-n+2*siz[u]))return 0;\n\t\tint fa=idx[D[u]-n+2*siz[u]]; \n\t\tif(u==fa)return 0;\n\t\tan.push_back(make_pair(fa,u));\n\t\tsiz[fa]+=siz[u];\n\t\tf[fa]+=f[u]+siz[u];\n\t}\n\tif(f[p[n]]!=D[p[n]])return 0;\n\tref(i,0,n-2)printf(\"%d %d\\n\",an[i].fi,an[i].se);\n\treturn 1;\n}\nint main(){\n\tread(n);\n\tref(i,1,n){\n\t\tread(D[i]);\n\t\tidx[D[i]]=i;\n\t}\n\tif(!solve())puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<math.h>\n#include<stdlib.h>\n#include<set>\n#include<bitset>\n#include<map>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<complex>\n#include<list>\n#include<limits.h>\nusing namespace std;\n\nconst int N=1e5+5;\ntypedef pair<int,int> pii;\nint n;\npair<long long,int> a[N];\nlong long sz[N];\nlong long dp[N];\nvector<pii> vp;\nmap<long long,int> mp;\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i].first);\n\t\ta[i].second=i;\n\t}\n\tsort(a+1,a+1+n);\n\treverse(a+1,a+1+n);\n\tfor(int i=1;i<=n;i++) mp[a[i].first]=i;\n\tfor(int i=1;i<=n;i++) sz[i]=1ll;\n\tfor(int i=1;i<n;i++){\n\t\tlong long fnd=a[i].first-1ll*n+2*sz[i];\n\t\tif(mp.find(fnd)==mp.end()){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint nxt=mp[fnd];\n\t\tdp[nxt]+=dp[i]+sz[i];\n\t\tsz[nxt]+=sz[i];\n\t\tvp.push_back(make_pair(a[i].second,a[nxt].second));\n\t}\n\tif(vp.size()!=n-1||dp[n]!=a[n].first) puts(\"-1\");\n\telse for(int i=0;i<vp.size();i++) printf(\"%d %d\\n\",vp[i].first,vp[i].second);\n\treturn 0;\n}\n\n/*\n数据不清空，爆零两行泪\n读题不认真，爆零两行泪\n分析不仔细，爆零两行泪\n建树不构造，爆零两行泪\n变量不统一，爆零两行泪\n边界不算清，爆零两行泪\n数组不开大，爆零两行泪\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double PI = acos(-1);\nconst double EPS = 1e-15;\nusing ll = long long;\nusing ull = unsigned long long;\nconst int inf = 2e9;\nconst ll INF = 2e18;\nconst ll MOD = 1e9+7;\nconst ll MOD1 = 998244353;\n//typedef pair<int,int> P;\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define sz(s) (s).size()\n#define pb push_back\n#define fi first\n#define se second\n//#define mp make_pair\n\nll dist;\nll dd;\nint node;\nbool used[100010];\nvector<int> G[100010];\n\nvoid dfs(int n, ll d) {\n  used[n] = 1;\n  REP(i,G[n].size()) {\n    if (used[G[n][i]]) continue;\n    dfs(G[n][i], d + 1);\n  }\n  dd += d;\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  ll n;\n  cin >> n;\n\n  //現在のノード数に対応する次のノードまでのsumの変化値\n  ll diff[n/2+1] = {};\n  for (int i = 1; i <= n / 2; i++) {\n    diff[i] = n - i * 2;\n  }\n\n  //sumとノード番号の対応\n  map<ll,ll> mp;\n  //sumを入れるところ\n  vector<ll> v;\n  for (ll i = 0; i < n; i++) {\n    ll a;\n    cin >> a;\n    mp[a] = i+1;\n    v.pb(a);\n  }\n  dist = v[0];\n  node = 1;\n  sort(v.rbegin(),v.rend());\n\n  //答え\n  vector<pair<ll,ll>> ans;\n\n  //最後尾のノードをsetに入れる\n  //つながってたら消す\n  set<ll> st;\n\n  //予測するため，つぎのノードのsumをnextに入れる\n  set<ll> next;\n  //前のノードを記録する\n  vector<ll> pre[100010];\n  //次への変化値を知るため，ノード数をlvに記録する\n  map<ll,ll> lv;\n\n  /*****手順*******/\n  //現在のノードがnext候補にあるとき\n  ////グラフを構築する\n  ////前のノードをstから消す\n  ////lvを数える\n\n  ////lv++\n  ////現在のノードをnextから消す\n  ////現在のノードをstに入れる\n  ////次のノードをnextに入れる\n\n  //最後にnextに要素があるときは-1\n  //nextが一つだけの時はok\n\n  for (ll i = 0; i < n; i++) {\n    if (next.count(v[i])) {\n      for (int j = 0; j < pre[mp[v[i]]].size(); j++) {\n        ans.pb({mp[v[i]], mp[pre[mp[v[i]]][j]]});\n        st.erase(pre[mp[v[i]]][j]);\n        lv[v[i]] += lv[pre[mp[v[i]]][j]];\n      }\n    }\n    lv[v[i]]++;\n    next.erase(v[i]);\n    st.insert(v[i]);\n    if (!mp.count(v[i] - diff[lv[v[i]]]) && i != n - 1) {\n      cout << -1 << endl;\n      return 0;\n    }\n    if (i != n - 1) {\n      pre[mp[v[i] - diff[lv[v[i]]]]].pb(v[i]);\n      next.insert(v[i] - diff[lv[v[i]]]);\n    }\n  }\n\n  if (next.size()) {\n    cout << -1 << endl;\n    return 0;\n  }\n\n  REP(i,sz(ans)) {\n    G[ans[i].fi].pb(ans[i].se);\n    G[ans[i].se].pb(ans[i].fi);\n  }\n\n\n  dfs(1,0);\n\n  if (dist != dd) {\n    cout << -1 << endl;\n    return 0;\n  }\n\n  REP(i,sz(ans)) {\n    cout << ans[i].fi << \" \" << ans[i].se << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\tcout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\ntemplate<typename T, typename U> inline bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> inline bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\nstruct Init {\n    Init() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << unitbuf;\n        cout << fixed << setprecision(20);\n    };\n} init;\n\nint N;\nint D[110000], n[110000], d[110000];\nunordered_map<int, int> mp;\nvint ans;\nsigned main() {\n    cin >> N;\n    for (int i = 1; i <= N; i++) {cin >> D[i]; n[i] = 1; mp[D[i]] = i;};\n    sort(D + 1, D + N + 1); reverse(D + 1, D + N + 1);\n    for (int i = 1; i <= N - 1; i++) {\n        int s = mp[D[i]];\n        int t = mp[D[i] - N + 2 * n[s]];\n        n[t] += n[s];\n        d[t] += d[s] + n[s];\n        ans.push_back(s); ans.push_back(t);\n    }\n    if (n[mp[D[N]]] != N || d[mp[D[N]]] != D[N]) {\n        cout << -1 << endl;\n        return 0;\n    }\n    for (int i = 0; i < 2 * (N - 1); i += 2) {\n        cout << ans[i] << \" \" << ans[i + 1] << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nint n, fa[100005], dep[100005];\nmap<ll, pair<int, int> > st;\nvector<pair<int, int> > edge;\nvector<int> seq;\n\nint main()\n{\n\tread(n);\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tll d;\n\t\tread(d);\n\t\tst.insert(make_pair(d, make_pair(1, i)));\n\t}\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tauto x = *st.rbegin();\n\t\tseq.push_back(x.second.second);\n\t\tst.erase(--st.end());\n\t\tll y = x.first-(n-x.second.first)+x.second.first;\n\t\tauto it = st.find(y);\n\t\tif(it == st.end()) {printf(\"-1\\n\"); return 0;}\n\t\telse\n\t\t{\n\t\t\tit->second.first += x.second.first;\n\t\t\tfa[x.second.second] = it->second.second;\n\t\t\tedge.emplace_back(x.second.second, it->second.second);\n\t\t}\n\t}\n\tll sum = 0;\n\tfor(int i=seq.size()-1; i>=0; i--) dep[seq[i]] = dep[fa[seq[i]]]+1, sum += dep[seq[i]];\n\tif(sum != st.begin()->first) puts(\"-1\");\n\telse for(auto i : edge) printf(\"%d %d\\n\", i.first, i.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimiz(O2)\n\n#include <bits/stdc++.h>\n\n#define rg register\nusing namespace std;\ntypedef long long ll;\n\ntemplate<typename T>\ninline bool read(T &n) {\n    T ans = 0, flag = 1;\n    char ch;\n    while ((ch = getchar()) < '0' || ch > '9') if (ch == '-') flag = -1; else if (ch == EOF) return false;\n    ans = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9') ans = ans * 10 + ch - '0';\n    n = ans * flag;\n    return true;\n}\n\ninline ll read() {\n    ll ans = 0, flag = 1;\n    char ch;\n    while ((ch = getchar()) < '0' || ch > '9') if (ch == '-') flag = -1;\n    ans = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9') ans = ans * 10 + ch - '0';\n    return ans * flag;\n};\nconst int maxn = 100005;\nstruct NODE {\n    ll val, ord;\n    bool operator<(NODE b) const {\n        return val < b.val;\n    }\n} node[maxn];\nint siz[maxn],fa[maxn];\nunordered_map<ll,int> unM;\nint main() {\n    int n;\n    read(n);priority_queue<NODE> pq;\n    for (rg int i = 1; i <= n; ++i) {\n        siz[i] = 1;\n        read(node[i].val);\n        node[i].ord = i;\n        pq.push(node[i]);\n        unM[node[i].val]=i;\n    }\n    for(rg int i=n;i>=2;i--){\n        NODE now=pq.top();pq.pop();\n        if(unM.find(now.val+2*siz[now.ord]-n)==unM.end()||unM[now.val+2*siz[now.ord]-n]==now.ord){\n            puts(\"-1\");return 0;\n        }\n        fa[now.ord]=unM[now.val+2*siz[now.ord]-n];\n        siz[fa[now.ord]]+=siz[now.ord];\n    }\n    for(rg int i=1;i<=n;i++){\n        if(fa[i]) cout<<i<<' '<<fa[i]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\nint n;\nlong long a[N], p[N];\n\n\nint head[N];\n\nint main() {\n    cin >> n;\n    for(int i = 1; i <= n; i++){\n        cin >> a[i];\n    }\n    for(int i = 1; i <= n; i++) p[i] = i;\n    sort(p + 1, p + n + 1,[](int x,int y){ return a[x] < a[y];});\n    fill(head + 1, head + n + 1, 1);\n\n    vector<pair<int, int>> ans;\n    for(int i = n; i >= 2; i--) {\n        int cur = p[i];\n        int L = 1, R = i - 1;\n        long long con_weight = a[cur] + 2 * head[cur] - n; \n        while (L <= R){\n            int mid = (L + R) / 2;\n            if (con_weight > a[p[mid]]) L = mid + 1;\n            else R = mid - 1;\n        }\n        if (con_weight != a[p[L]]) {\n            cout << \"-1\" << endl;\n            return 0;\n        }\n        ans.push_back(make_pair(p[L], cur));\n        head[p[L]] += head[cur];\n        //cout << cur << \" \" << p[L] <<'\\n';\n        //for(int j = 1; j <= n; j++) cout << head[j] << \" \\n\"[j==n]; \n    }\n    \n    if (head[p[1]] != n) {\n        cout << \"-1\" << endl;\n        return 0;\n    }\n    for(auto i : ans) cout << i.first << \" \" << i.second << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<map>\n#include<algorithm>\nusing namespace std;\nint t[101010];\nlong long d[101010];\nint siz[101010],fa[101010];\nbool cmp(const int &x,const int &y)\n{\n\treturn d[x]<d[y];\n}\nmap<long long,int> mp;\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tmp.clear();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&d[i]);\n\t\tsiz[i]=1;\n\t\tmp[d[i]]=i;\n\t\tt[i]=i;\n\t}\n\tsort(t+1,t+n+1,cmp);\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tfa[t[i]]=mp[d[t[i]]+2*siz[t[i]]-n];\n\t\tif(fa[t[i]]==0)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[fa[t[i]]]+=siz[t[i]];\n\t}\n\tfor(int i=2;i<=n;i++)\n\t\td[t[1]]-=siz[t[i]];\n\tif(d[t[1]]!=0)\n\t{\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=2;i<=n;i++)\n\t\tprintf(\"%d %d\\n\",fa[t[i]],t[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nmap<ll,int>p;\nmap<ll,int>::iterator it;\nint fa[100010],siz[100010],a[100010],b[100010],h[100010],nex[200010],to[200010],M,n;\nvoid add(int a,int b)\n{\n    M++;\n    to[M]=b;\n    nex[M]=h[a];\n    h[a]=M;\n}\nll wd[100010],d[100010];\nvoid dfs(int x,int dis)\n{\n    siz[x]=1;\n    d[1]+=dis;\n    for(int i=h[x];i;i=nex[i])if(to[i]!=fa[x])\n\t{\n        fa[to[i]]=x;\n        dfs(to[i],dis+1);\n        siz[x]+=siz[to[i]];\n    }\n}\nvoid dfs(int x)\n{\n    for(int i=h[x];i;i=nex[i])if(to[i]!=fa[x])\n\t{\n        d[to[i]]=d[x]+n-siz[to[i]]*2;\n        dfs(to[i]);\n    }\n}\nint get(int x){return fa[x]==x?x:(fa[x]=get(fa[x]));}\nint main()\n{\n    int i;\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++)\n\t{\n        scanf(\"%lld\",wd+i);\n        p[wd[i]]=i;\n    }\n    for(i=1;i<=n;i++)\n\t{\n        fa[i]=i;\n        siz[i]=1;\n    }\n    it=p.end();\n    for(it--;it!=p.begin();it--)\n\t{\n        if(n-siz[it->second]*2==0||!p.count(it->first-(n-siz[it->second]*2)))\n\t\t{\n            puts(\"-1\");\n            return 0;\n        }\n        M++;\n        a[M]=it->second;\n        b[M]=p[it->first-(n-siz[it->second]*2)];\n        siz[fa[a[M]]=get(b[M])]+=siz[a[M]];\n    }\n    M=0;\n    for(i=1;i<n;i++)\n\t{\n        add(a[i],b[i]);\n        add(b[i],a[i]);\n    }\n    fa[1]=0;\n    dfs(1,0);\n    dfs(1);\n    for(i=1;i<=n;i++)\n\t{\n        if(wd[i]!=d[i])\n\t\t{\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    for(i=1;i<n;i++)printf(\"%d %d\\n\",a[i],b[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<long long> d(n);\n\tlong long miii = 1e15;\n\tint cent = -1;\n\tmap<long long, int> mp;\n\trep(i, n) {\n\t\tscanf(\"%lld\", &d[i]);\n\t\tmp[d[i]] = i;\n\t\tif (miii > d[i]) {\n\t\t\tmiii = d[i];\n\t\t\tcent = i;\n\t\t}\n\t}\n\tset<long long> st;\n\trep(i, n) {\n\t\tif (miii != d[i]) {\n\t\t\tst.insert(d[i]);\n\t\t}\n\t}\n\tvector<pair<int, int>> ans;\n\tauto no = [](){ cout << -1 << endl; exit(0); };\n\twhile (true) { \n\t\tif (ans.size() >= n - 1) break;\n\t\tlong long mi;\n\t\tfor (auto it : st) {\n\t\t\tmi = it;\n\t\t\tbreak;\n\t\t}\n\t\tst.erase(mi);\n\t\tint id = mp[mi];\n\t\tans.push_back({id, cent});\n\t\tlong long dist = mi - miii;\n\t\tlong long k = (max(n - dist, dist - n)) / 2;\n\t\tk --;\n\t\tdist += 2;\n\t\tlong long cur = mi;\n\t\tlong long prev;\n\t\twhile (k --) {\n\t\t\tprev = cur;\n\t\t\tcur += dist;\n\t\t\tif (st.count(cur) == 0) {\n\t\t\t\tno();\n\t\t\t}\n\t\t\tst.erase(cur);\n\t\t\tint pid = mp[prev];\n\t\t\tint cid = mp[cur];\n\t\t\tans.push_back({pid, cid});\n\t\t\tdist += 2;\n\t\t}\n\t}\n\tvector<vector<int>> g(n);\n\trep(i, n - 1) {\n\t\tint a = ans[i].first;\n\t\tint b = ans[i].second;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tvector<long long> s(n);\n\tvector<int> dis(n);\n\tvector<int> sz(n);\n\tfunction<void (int, int)> dfs = [&](int u, int prev) {\n\t\tsz[u] = 1;\n\t\tfor (auto v : g[u]) if (v != prev) {\n\t\t\tdis[v] = dis[u] + 1;\n\t\t\tdfs(v, u);\n\t\t\tsz[u] += sz[v];\n\t\t}\n\t};\n\tdfs(0, -1);\n\trep(i, n) s[0] += dis[i];\n\tfunction<void (int, int)> dfs2 = [&](int u, int prev) {\n\t\tfor (auto v : g[u]) if (v != prev) {\n\t\t\ts[v] = s[u] + n - sz[v] * 2;\n\t\t\tdfs2(v, u);\n\t\t}\n\t};\n\tdfs2(0, -1);\n\tsort(s.begin(), s.end());\n\tsort(d.begin(), d.end());\n\tif (s != d) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tfor (auto it : ans) printf(\"%d %d\\n\", it.first + 1, it.second + 1);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1e5 + 10;\nvector<pair<int, int> > edg;\npair<ll, int> d[MAXN];\nvector<int> Mat[MAXN];\nint n, cnt[MAXN];\nmap<ll, int> mp;\nbool se[MAXN];\nll dist, dt;\nint num;\n\nvoid dfs(int v, int di) {\n\tse[v] = 1, num++;\n\tdist += di;\n\tfor (int i = 0; i < Mat[v].size(); i++)\n\t\tif (!se[Mat[v][i]])\n\t\t\tdfs(Mat[v][i], di + 1);\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> d[i - 1].first;\n\t\tif (i == 1)\n\t\t\tdt = d[i - 1].first;\n\t\tmp[d[i - 1].first] = i;\n\t\td[i - 1].second = i;\n\t\tcnt[i] = 1;\n\t}\n\tsort(d, d + n);\n\treverse(d, d + n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint k = cnt[d[i].second];\n\t\tif (2 * k > n || mp.find(d[i].first + k - (n - k)) == mp.end())\n\t\t\treturn cout << -1, 0;\n\t\tcnt[mp[d[i].first + k - (n - k)]] += k;\n\t\tedg.push_back({d[i].second, mp[d[i].first + k - (n - k)]});\n\t\tMat[mp[d[i].first + k - (n - k)]].push_back(d[i].second);\n\t\tMat[d[i].second].push_back(mp[d[i].first + k - (n - k)]);\n\t}\n\tdfs(1, 0);\n\tif (dist == dt && num == n && edg.size() == n - 1) {\n\t\tfor (int i = 0; i < edg.size(); i++)\n\t\t\tcout << edg[i].first << ' ' << edg[i].second << endl;\n\t\treturn 0;\n\t}\n\tcout << -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 100010\n#define ll long long\nusing namespace std;\n\nint size[maxn],n,cnt,head[maxn],d[maxn];\n\nll dist[maxn];\n\nmap < ll , ll > id;\n\nstruct E{\n\tint to,nxt,fr;\n}edge[maxn<<1];\n\ninline void add(int u,int v){edge[++cnt]=(E){v,head[u],u};head[u]=cnt;}\n\ntemplate <class T>\nvoid read(T &x){\n\tchar s=getchar();x=0;\n\twhile(s<'0'||s>'9') s=getchar();\n\twhile(s>='0'&&s<='9') x=(x<<3)+(x<<1)+s-'0',s=getchar();\n}\n\nvoid dfs(int u){\n\tfor(int i=head[u];i;i=edge[i].nxt){\n\t\tint v=edge[i].to;\n\t\td[v]=d[u]+1;\n\t\tdfs(v);\n\t}\n}\n\nbool check(){\n\tll sum=0;\n\tfor(int i=1;i<=n;i++) sum+=d[i];\n\treturn dist[1]==sum;\n}\n\nint main(){\n\tread(n);\n\tfor(int i=1;i<=n;i++) read(dist[i]),id[dist[i]]=i,size[i]=1;\n\tsort(dist+1,dist+n+1);\n\tfor(int i=n;i>1;i--){\n\t\tint fa,u=id[dist[i]];\n\t\tll tmp1=n-size[u]*2;\n\t\tif(tmp1<=0) return printf(\"-1\"),0;\n\t\tll tmp2=dist[i]-tmp1;\n\t\tif(id.count(tmp2)==0) return printf(\"-1\"),0;\n\t\tfa=id[tmp2];\n\t\tadd(fa,u);\n\t\tsize[fa]+=size[u];\n\t}\n\tdfs(id[dist[1]]);\n\tif(check()){\n\t\tfor(int i=1;i<n;i++) printf(\"%d %d\\n\",edge[i].fr,edge[i].to);\n\t\treturn 0;\n\t}\n\tprintf(\"-1\"),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint n;\n\nint main(){\n\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    cin>>n;\n    vector<ll> d(n);\n    vector<int> w(n,1);\n    map<ll,int> mp;\n    for(int i=0;i<n;i++){\n        cin>>d[i];\n        mp[d[i]]=i;\n    }\n    vector<pair<int,int> > res;\n    for(int tm=1;tm<n;tm++){\n        map<ll,int>::reverse_iterator it=mp.rbegin();\n        int i=it->second;\n        ll wt=d[i]-n+w[i]+w[i];\n        if(mp.find(wt)==mp.end()||mp[wt]==i){\n            cout<<-1<<endl;\n            return 0;\n        }\n        int j=mp[wt];\n        res.emplace_back(i,j);\n        w[j]+=w[i];\n        mp.erase(--mp.end());\n    }\n    vector<ll> rd(n,-1);\n    rd[0]=0;\n    vector<vector<int> > g(n);\n    for(pair<int,int> p : res){\n        g[p.first].push_back(p.second);\n        g[p.second].push_back(p.first);\n    }\n    vector<int> q(1,0);\n    for(int b=0;b<q.size();b++){\n        for(int j:g[q[b]]){\n            if(rd[j]==-1){\n                q.push_back(j);\n                rd[j]=rd[q[b]]+1;\n            }\n        }\n    }\n    if(accumulate(rd.begin(),rd.end(),0ll)!=d[0]){\n        cout<<-1<<endl;\n        return 0;\n    }\n    for(pair<int,int> p : res){\n        cout<<p.first+1<<' '<<p.second+1<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctype.h>\n#include <algorithm>\n#include <fstream>\n#include <set>\n#define mp make_pair\n#define Debug(...) fprintf(stdout, __VA_ARGS__)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<LL, int> pli;\ntypedef set<pli>::reverse_iterator sit;\n\nconst int MAXN = 1e5 + 7;\n\ninline void proc_status() {\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline T read() {\n\tT res = 0, flag = 1; char in = getchar();\n\twhile(!isdigit(in)) { if(in == '-') flag = -1; in = getchar(); }\n\twhile(isdigit(in)) { res = (res << 1) + (res << 3) + in - '0'; in = getchar(); }\n\treturn res * flag;\n}\n\ntemplate<typename T> inline void chkmax(T &a, T b) { if(a < b) a = b; }\ntemplate<typename T> inline void chkmin(T &a, T b) { if(a > b) a = b; }\n\nint n, rt;\nset<pli> D;\n\nint f[MAXN], siz[MAXN];\nLL dis[MAXN], sum[MAXN];\nbool vis[MAXN];\nint dex, head[MAXN], to[MAXN], nxt[MAXN];\n\ninline void Link(int x, int y) { nxt[++dex] = head[x]; to[dex] = y; head[x] = dex; }\n\nvoid dfs(int u) {\n\tvis[u] = 1;\n\tfor(int i = head[u]; i; i = nxt[i]) {\n\t\tint v = to[i];\n\t\tif(vis[v]) { puts(\"-1\"); exit(0); }\n\t\tdfs(v);\n\t\tsum[u] += sum[v] + siz[v];\n\t}\n}\n\ninline void init() {\n\tn = read<int>();\n\tfor(int i = 1; i <= n; ++i) {\n\t\tD.insert(mp(read<LL>(), i));\n\t}\n\trt = (*D.begin()).second;\n}\n\ninline void solve() {\n\tint cnt = 0;\n\tfor(sit it = D.rbegin(); it != D.rend(); ++it) {\n\t\tint u = (*it).second;\n\t\tdis[u] = (*it).first;\n\t\t++siz[u];\n\t\tif(u == rt) break;\n\t\tLL nxt = dis[u] + (siz[u] << 1) - n;\n\t\tpli fa = (*D.lower_bound(mp(nxt, 0)));\n\t\tif(fa.first == nxt) {\n//\t\t\tprintf(\"%d %d\\n\", fa.second, u);\n//\t\t\tprintf(\"Linked\\n\\n\");\n\t\t\tf[u] = fa.second;\n\t\t\tLink(f[u], u);\n\t\t\tsiz[f[u]] += siz[u];\n\t\t}\n//\t\tif(siz[f[u]] == n) { rt = f[u]; break; }\n\t}\n\n//\tcout << rt << endl;\n//\texit(0);\n\tdfs(rt);\n\tif(dis[rt] != sum[rt]) {\n\t\tputs(\"-1\");\n\t\texit(0);\n\t}\n\tfor(int i = 1; i <= n; ++i) if(i != rt) {\n\t\tprintf(\"%d %d\\n\", i, f[i]);\n\t}\n}\n\nint main() {\n\n\tinit();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#define mp make_pair\n#define fi first\n#define se second\nusing namespace std;\npair <int, int> a[1000006], edge[1000006];\nint sze[1000006];\nint main(){\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++ i){\n\t\tscanf(\"%d\", &a[i].fi);\n\t\ta[i].se = i;\n\t}\n\tsort(a + 1, a + 1 + n);\n\tint m = 0;\n\tfor (int i = n; i >= 2; -- i){\n\t\t++ sze[i];\n\t\tint d = a[i].fi - n + 2 * sze[i];\n\t\tint index = lower_bound(a + 1, a + 1 + n, mp(d, 0)) - a;\n\t\tif (a[index].fi != d || index >= i){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tedge[++ m] = mp(a[index].se, a[i].se);\n\t\tsze[index] += sze[i];\n\t}\n\tfor(int i = 1; i <= m; ++ i)\n\t\tprintf(\"%d %d\\n\", edge[i].fi, edge[i].se);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing vi = vector<ll>;\nconst int maxn = 1<<19, mod = 1e9 + 7;\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcout << -1;\n\treturn 0;\n\tint n;\n\tcin >> n;\n\tvi a(n), sz(n+1, 1);\n\tmap<ll, int> id;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\tid[a[i]] = i+1;\n\t}\n\tsort(rall(a));\n\tvector<pair<int, int>> edges;\n\tfor(auto x : a) {\n\t\tint i = id[x];\n\t\tif(sz[i] == n) continue;\n\t\tll nd = x + 2*sz[i] - n;\n\t\tif(id.count(nd)) {\n\t\t\tedges.pb({i, id[nd]});\n\t\t\tsz[id[nd]] += sz[i];\n\t\t}\n\t}\n\tif(edges.size() != n-1) return cout << -1, 0;\n\tfor(auto i : edges) cout << i.first << \" \" << i.second << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = pair<lint, int>;\nconst int MAXN = 100005;\n\nvoid my_ass(bool p){\n\tif(!p){\n\t\tputs(\"-1\");\n\t\texit(0);\n\t}\n}\n\nint n;\npi a[MAXN];\nvector<int> gph[MAXN];\nset<int> s[2];\nint left_size[MAXN];\n\nlint get_dist(int x, int p, int d){\n\tlint ret = d;\n\tfor(auto &i : gph[x]){\n\t\tif(i != p){\n\t\t\tret += get_dist(i, x, d + 1);\n\t\t}\n\t}\n\treturn ret;\n}\n\nvector<int> new_event[MAXN];\n\nvoid INSERT(int val, int atleast){\n\tlint v = n + a[val].first - 2 * left_size[val] + 2;\n\tint l = lower_bound(a + 1, a + n + 1, pi(v, -1)) - a;\n\tnew_event[max(l, atleast)].push_back(val);\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<=n; i++){\n\t\tscanf(\"%lld\",&a[i].first);\n\t\ta[i].second = i;\n\t}\n\tsort(a + 1, a + n + 1);\n\tleft_size[1] = n;\n\tINSERT(1, 2);\n\tfor(int i=2; i<=n; i++){\n\t\tfor(auto &j : new_event[i]){\n\t\t\ts[a[j].first % 2].insert(j);\n\t\t}\n\t\tint msk = (a[i].first % 2) ^ (n % 2);\n\t\tmy_ass(!s[msk].empty());\n\t\tmy_ass(a[i].first <= n + a[*s[msk].begin()].first - 2);\t\n\t\tint pidx = *s[msk].begin();\n\t\tgph[a[pidx].second].push_back(a[i].second);\n\t\tgph[a[i].second].push_back(a[pidx].second);\n\t\tleft_size[i] = n - (a[i].first - a[pidx].first);\n\t\tleft_size[i] /= 2;\n\t\tleft_size[pidx] -= left_size[i];\n\t\ts[msk].erase(pidx);\n\t\tif(left_size[pidx] != 1) INSERT(pidx, i + 1);\n\t\tif(left_size[i] != 1) INSERT(i, i + 1);\n\t}\n\tfor(int i=1; i<=1; i++){\n\t\tmy_ass(get_dist(a[i].second, -1, 0) == a[i].first); \n\t}\n\tfor(int i=1; i<=n; i++){\n\t\tfor(auto &j : gph[i]){\n\t\t\tif(i < j) printf(\"%d %d\\n\", i, j);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<long long> d(n);\n\tlong long miii = 1e15;\n\tint cent = -1;\n\tmap<long long, int> mp;\n\trep(i, n) {\n\t\tscanf(\"%lld\", &d[i]);\n\t\tmp[d[i]] = i;\n\t\tif (miii > d[i]) {\n\t\t\tmiii = d[i];\n\t\t\tcent = i;\n\t\t}\n\t}\n\tset<long long> st;\n\trep(i, n) {\n\t\tif (miii != d[i]) {\n\t\t\tst.insert(d[i]);\n\t\t}\n\t}\n\tvector<pair<int, int>> ans;\n\tauto no = [](){ cout << -1 << endl; exit(0); };\n\twhile (true) { \n\t\tif (ans.size() >= n - 1) break;\n\t\tlong long mi;\n\t\tfor (auto it : st) {\n\t\t\tmi = it;\n\t\t\tbreak;\n\t\t}\n\t\tst.erase(mi);\n\t\tint id = mp[mi];\n\t\tans.push_back({id, cent});\n\t\tlong long dist = mi - miii;\n\t\tlong long k = ((long long) n - dist) / 2;\n\t\tk --;\n\t\tdist += 2;\n\t\tlong long cur = mi;\n\t\tlong long prev;\n\t\twhile (k --) {\n\t\t\tprev = cur;\n\t\t\tcur += dist;\n\t\t\tif (st.count(cur) == 0) {\n\t\t\t\tno();\n\t\t\t}\n\t\t\tst.erase(cur);\n\t\t\tint pid = mp[prev];\n\t\t\tint cid = mp[cur];\n\t\t\tans.push_back({pid, cid});\n\t\t\tdist += 2;\n\t\t}\n\t}\n\tfor (auto it : ans) printf(\"%d %d\\n\", it.first + 1, it.second + 1);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\n#define dilemma return puts(\"-1\"), 0\n\ntypedef long long LL;\n\nconst int MAXN = 1e5 + 10;\n\nint n, sum;\nint sz[MAXN], dep[MAXN], head[MAXN];\nLL d[MAXN];\nstruct Edge { int link, to; } e[MAXN << 1];\ninline void add(int u, int v) { e[++sum] = (Edge) { v, head[u] }, head[u] = sum; }\nstd::map <LL, int> mmp;\n\nvoid dfs(int u, int fa) {\n    for (int i = head[u]; i; i = e[i].to) {\n        int v = e[i].link;\n        if (v == fa) continue;\n        dep[v] = dep[u] + 1, dfs(v, u);\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; ++i) scanf(\"%lld\", d + i), mmp[d[i]] = i, sz[i] = 1;\n    int cnt = 0;\n    for (auto it = mmp.rbegin(); it != mmp.rend(); ++it) {\n        int u = it->y, fa = mmp[it->x + 2 * sz[u] - n];\n        if (!fa || u == fa) dilemma;\n        add(u, fa), add(fa, u), sz[fa] += sz[u];\n        if ((++cnt) == n - 1) break;\n    }\n    int rt = mmp.begin()->y; dfs(rt, 0);\n    LL tot = 0;\n    for (int i = 1; i <= n; ++i) tot += dep[i];\n    if (tot != d[rt]) dilemma;\n    for (int i = 1; i <= sum; i += 2) printf(\"%d %d\\n\", e[i].link, e[i + 1].link);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define D(x) D[id[x]]\nusing namespace std;\nint n,D[100005],id[100005],fa[100005],sz[100005],k,l,r,Mid,tmp,i;\nbool cmp(int x,int y){return D[x]>D[y];}\n\nint find(int x){\n\tfor (l=1,r=n,Mid=(l+r>>1); l<r; Mid=(l+r>>1))\n\t\t(D(Mid)>x) ? (l=Mid+1) : (r=Mid);\n\treturn Mid;\n}\n\nint main(){\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor (i=1; i<=n; i++) scanf(\"%d\",&D[i]),id[i]=i,sz[i]=1;\n\tsort(id+1,id+n+1,cmp);\n\tfor (i=1; i<n; i++){\n\t\ttmp=D(i)-n+2*sz[id[i]];\n\t\tk=find(tmp);\n\t\tif (tmp==D(i) || D(k)!=tmp) {printf(\"-1\"); return 0;}\n\t\tfa[id[i]]=id[k],sz[id[k]]+=sz[id[i]];\n\t}\n\tfor (i=1; i<n; i++) printf(\"%d %d\\n\",id[i],fa[id[i]]);\n}\n\n/*\nD[fa[x]]=D[x]-n+2*sz[x]\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define int long long\ntypedef pair <int, int> ii;\n\nconst int N = 1e5 + 5;\nint n, d[N], subSize[N];\nmap <int, int> ind;\nvector <int> adj[N];\n\nsigned main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> d[i];\n\t\tind[d[i]] = i;\n\t}\n\tvector <ii> res; res.clear();\n\tsort(d + 1, d + 1 + n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tsubSize[i] = 1;\n\tfor (int i = n; i >= 2; --i) {\n\t\tint v = ind[d[i]];\n\t\tint du = d[i] + 2 * subSize[v] - n;\n\t\tif (ind.find(du) == ind.end()) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint u = ind[du];\n\t\tif (u == v) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsubSize[u] += subSize[v];\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t\tres.push_back({u, v});\n\t}\n\tfor (ii d : res)\n\t\tcout << d.first << ' ' << d.second << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<long long, int> pli;\n\nconst int N = 1e5 + 10;\nint h[N], n, cnt[N], par[N];\nlong long d[N], check;\nvector<pli> di;\nvector<int> child[N];\nmap<long long, int> mp;\n\nvoid dfs(int v, int p){\n\th[v] = h[p] + 1;\n\tfor (int u : child[v])\n\t\tdfs(u, v);\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);cout.tie(0);\n\t\n\tcin >> n;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> d[i];\n\t\tdi.push_back({d[i], i});\n\t\tmp[d[i]] = i + 1;\n\t}\n\t\n\tsort(di.begin(), di.end());\n\treverse(di.begin(), di.end());\n\t\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[i] = 1;\n\tfor (int i = 0; i < n - 1; i++){\n\t\tint v = di[i].second;\n\t\tlong long dis = di[i].first,\n\t\t\t\t  par_dis = dis + (2 * cnt[v]) - n;\n\t\t\n\t\tif(mp[par_dis] == 0)\n\t\t\treturn cout << -1, 0;\n\t\t\n\t\tint ver_par = mp[par_dis] - 1;\n\t\tcnt[ver_par] += cnt[v];\n\t\tpar[v] = ver_par;\n\t\tchild[par[v]].push_back(v);\n\t}\n\t\n\tint root = di[n - 1].second;\n\th[root] = -1;\n\tpar[root] = root;\n\tdfs(root, root);\n\t\n\tfor (int i = 0; i < n; i++)\n\t\tcheck += h[i];\n\t\n\tif(check != d[root])\n\t\treturn cout << -1, 0;\n\t\n\tfor (int i = 0; i < n; i++)\n\t\tif(par[i] != i)\n\t\t\tcout << par[i] + 1 << ' ' << i + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=100005;\nstruct node{\n\tll d; int sz,id;\n\tfriend bool operator < (node a,node b){\n\t\treturn a.d<b.d;\n\t}\n};\nset<node> s;\nvector<pii> ans;\nint d[N],n;\nll rem;\nvi e[N];\n\nvoid dfs(int u,int fa){\n\tfor(auto v:e[u])\n\t\tif(v!=fa){\n\t\t\td[v]=d[u]+1;\n\t\t\tdfs(v,u);\n\t\t}\n\trem-=d[u];\n}\n\nint main(){\n\tread(n);\t\n\trep(i,1,n){\n\t\tll tmp; read(tmp);\n\t\ts.insert((node){tmp,1,i});\n\t}\n\twhile(s.size()>=2){\n\t\tnode t=*(--s.end());\n\t\ts.erase(--s.end());\n\t\tset<node>::iterator it=s.lower_bound((node){t.d-n+2*t.sz,0});\n\t\tif(it==s.end()||it->d!=t.d-n+2*t.sz)\n\t\t\treturn puts(\"-1\"),0;\n\t\tint x=t.id,y=it->id;\n\t\tif(x>y)swap(x,y);\n\t\tans.pb(mp(x,y));\n\t\tnode v=*it;\n\t\tv.sz+=t.sz;\n\t\ts.erase(it);\n\t\ts.insert(v);\n\t}\n\tfor(auto x:ans)\n\t\te[x.fi].pb(x.se),e[x.se].pb(x.fi);\n\tint rt=s.begin()->id;\n\trem=s.begin()->d;\n\tdfs(rt,0);\n\tif(rem!=0)return puts(\"-1\"),0;\n\tsort(ans.begin(),ans.end());\n\tfor(auto x:ans)\n\t\tprintf(\"%d %d\\n\",x.fi,x.se);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T> void assign(V<T>& v, int n, const T& a = T()) { v.assign(n, a); }\ntemplate<class T, class... U> void assign(V<T>& v, int n, const U&... u) { v.resize(n); for (auto&& i : v) assign(i, u...); }\n\nint main() {\n  cin.tie(NULL); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  if (n < 7) return cout << -1 << '\\n', 0;\n  V<lint> d(n); for (int i = 0; i < n; i++) cin >> d[i];\n  map<lint, int> invd; for (int i = 0; i < n; i++) invd[d[i]] = i;\n  set<lint> s; for (int i = 0; i < n; i++) s.insert(d[i]);\n  VV<> g(n);\n  while (true) {\n    int v = invd[*--s.end()];\n    if (!s.count(d[v] - (n - 2))) break;\n    for (int i = n - 2; i > 0; i -= 2) if (s.count(d[v] - i)) {\n      s.erase(d[v]);\n      int w = invd[d[v] - i];\n      g[v].push_back(w);\n      g[w].push_back(v);\n      v = w;\n    } else break;\n  }\n  V<> d0(n, -1);\n  queue<int> que;\n  d0[0] = 0; que.push(0);\n  while (!que.empty()) {\n    int v = que.front(); que.pop();\n    for (int w : g[v]) if (d0[w] == -1) {\n      d0[w] = d0[v] + 1; que.push(w);\n    }\n  }\n  for (int i = 0; i < n; i++) if (d0[i] == -1) return cout << -1 << '\\n', 0;\n  if (accumulate(d0.begin(), d0.end(), 0LL) != d[0]) return cout << -1 << '\\n', 0;\n  for (int v = 0; v < n; v++) for (int w : g[v]) if (v < w) cout << v + 1 << ' ' << w + 1 << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main() {\n\tlong long N;\n\tcin >> N;\n\tvector<pair<long long, long long> > D(N);\n\tvector<long long> E(N);\n\tvector<long long> COUNT(N, 1);\n\tvector<pair<long long, long long> > ANS;\n\tfor (int i = 0; i < N; i++) cin >> D[i].first, D[i].second = i, E[i] = D[i].first;\n\tsort(D.begin(), D.end());\n\tsort(E.begin(), E.end());\n\tfor (int i = N - 1; i > 0; i--) {\n\t\tlong long C = COUNT[D[i].second];\n\t\tlong long ND = D[i].first - (N - C * 2);\n\t\tlong long it = lower_bound(E.begin(), E.end(), ND) - E.begin();\n\t\tif (D[it].first != ND || i <= it) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tANS.push_back({ D[i].second, D[it].second });\n\t\tCOUNT[D[it].second] += COUNT[D[i].second];\n\t}\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tcout << ANS[i].first + 1 << \" \" << ANS[i].second + 1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=1e5+5;\nusing namespace std;\nstruct Edge{int x,y;}e[N];\nstruct Node{\n\tlong long d;int id;\n\tbool operator <(const Node &b)const{return d<b.d;}\n}d[N];\nint n,cnt;\nlong long size[N];\nlong long dis;\ninline Node Make(long long _d,int _id){Node t;t.d=_d,t.id=_id;return t;}\nint main(){\n\t\n\tregister int i,x;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i)\n\t\tscanf(\"%d\",&x),d[i].d=x,d[i].id=i,size[i]=1;\n\tsort(d+1,d+n+1);\n\tfor(i=n;i>=2;--i){\n\t\tlong long t=d[i].d-n+size[i]*2;\n\t\tint pos=lower_bound(d+1,d+n+1,Make(t,0))-d;\n\t\tif(d[pos].d!=t) return puts(\"-1\"),0;\n\t\te[++cnt]=(Edge){d[i].id,d[pos].id};\n\t\tsize[pos]+=size[i];\n\t\tdis+=size[i];\n\t}\n\tif(dis!=d[1].d) puts(\"-1\");\n\telse\n\t\tfor(i=1;i<=cnt;++i)\n\t\t\tprintf(\"%d %d\\n\",e[i].x,e[i].y);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n \n/*\n// ordered_set \n# include <ext/pb_ds/assoc_container.hpp>\n# include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n# define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update> \n*/\n \nusing namespace std;\n \ntypedef long long                                        ll;\ntypedef long double                                      ld;\ntypedef pair <int, int>                                  pii;\ntypedef pair <pii, int>                                  ppi;\ntypedef pair <int, pii>                                  pip;\ntypedef pair <pii, pii>                                  ppp;\ntypedef pair <ll, ll>                                    pll;\n \n# define A                                               first\n# define B                                               second\n# define endl                                            '\\n'\n# define sep                                             ' '\n# define all(x)                                          x.begin(), x.end()\n# define kill(x)                                         return cout << x << endl, 0\n# define SZ(x)                                           int(x.size())\n# define Sort(x)                                         sort(all(x))\n# define InTheNameOfGod                                  ios::sync_with_stdio(0);cin.tie(0); cout.tie(0);\n \nll power(ll a, ll b, ll md) {return (!b ? 1 : (b & 1 ? a * power(a * a % md, b / 2, md) % md : power(a * a % md, b / 2, md) % md));}\n \nconst int xn = 1e5 + 10;\nconst int xm = - 20 + 10;\nconst int SQ = 320;\nconst int sq = 320 + 10;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18 + 10;\nconst int mod = 1e9 + 7;\nconst int TM = 3;\nconst int base = 257;\n\nll n, sz[xn], D[xn], ord[xn], cnt;\nvector <pii> ans;\nunordered_map <ll, int> mp;\nvector <int> adj[xn];\nbool mark[xn];\n\nbool cmp(int i, int j){ return D[i] > D[j];}\nvoid DFS(int v){\n\tmark[v] = true;\n\t++ cnt;\n\tfor (int u : adj[v]){\n\t\tif (mark[u]) continue;\n\t\tDFS(u);\n\t}\n}\n\nint main(){\n    InTheNameOfGod;\n    \n\tcin >> n;\n\tfor (int i = 1; i <= n; ++ i){\n\t\tcin >> D[i];\n\t\tord[i] = i;\n\t\tsz[i] = 1;\n\t\tmp[D[i]] = i;\n\t}\n\tsort(ord + 1, ord + n + 1, cmp);\n\tfor (int i = 1; i < n; ++ i){\n\t\tint v = ord[i];\n\t\tint par = mp[D[v] - n + sz[v] + sz[v]];\n\t\tif (!par) kill(- 1);\n\t\tans.push_back({v, par});\n\t\tadj[par].push_back(v);\n\t\tadj[v].push_back(par);\n\t\tsz[par] += sz[v];\n\t}\n\tDFS(1);\n\tif (cnt < n) kill(- 1);\n\tfor (pii e : ans) cout << e.A << sep << e.B << endl;\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define re register\n#define ll long long\ninline int gi()\n{\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=100010;\ntypedef pair<ll,int> pli;typedef pair<int,int> pii;\n#define mp make_pair\npli p[N];int n,siz[N];\nvector<pii>ans;\nint main()\n{\n\tn=gi();\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&p[i].first),p[i].second=i,siz[i]=1;\n\tsort(p+1,p+n+1);ll dis=0;\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tll nd=p[i].first-(n-siz[p[i].second])+siz[p[i].second];\n\t\tint pos=lower_bound(p+1,p+n+1,mp(nd,0))-p;\n\t\tif(p[pos].first!=nd)return puts(\"-1\"),0;\n\t\tans.push_back(mp(p[pos].second,p[i].second));\n\t\tsiz[p[pos].second]+=siz[p[i].second];dis+=siz[p[i].second];\n\t}\n\tif(dis!=p[1].first)return puts(\"-1\"),0;\n\tfor(pii now:ans)printf(\"%d %d\\n\",now.first,now.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#define MIN_INT -2147483648\n#define MAX_INT 2147483647\n#define MIN_LONG -9223372036854775808L\n#define MAX_LONG 9223372036854775807L\n#define PI 3.141592653589793238462643383279502884L\n\n#define long long long int\n\nusing std::vector;\nusing std::map;\nusing std::set;\nusing std::string;\nusing std::pair;\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\n// @author: pashka\n\nvector<vector<int>> g;\n\nlong calc(int i, long s) {\n    long res = s;\n    for (int x : g[i]) {\n        res += calc(x, s + 1);\n    }\n    return res;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    vector<long> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    std::sort(a.rbegin(), a.rend());\n\n    map<long, int> q;\n    for (int i = 0; i < n; i++) {\n        q[a[i]] = i;\n    }\n\n    vector<int> s(n);\n\n    g.resize(n);\n\n    for (int i = 0; i < n - 1; i++) {\n        s[i]++;\n        long p = a[i] - (n - 2 * s[i]);\n        if (p >= a[i]) {\n            cout << -1;\n            return 0;\n        }\n        if (q.find(p) == q.end()) {\n            cout << -1;\n            return 0;\n        }\n        int x = q[p];\n        s[x] += s[i];\n        g[x].push_back(i);\n    }\n\n    if (calc(n - 1, 0) != a[n - 1]) {\n        cout << -1;\n        return 0;\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j : g[i]) {\n            cout << (i + 1) << \" \" << (j + 1) << \"\\n\";\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <map>\nusing namespace std;\n#define fors(i,a,b) for(int i=(a);i<=(b);++i)\n#define ford(i,a,b) for(int i=(a);i>=(b);--i)\n#define min(x,y) ((x) < (y) ? (x) : (y))\n#define max(x,y) ((x) < (y) ? (y) : (x))\n#define swap(x,y) ((x)^=(y),(y)^=(x),(x)^=(y))\n#define abs(x) ((x) < 0 ? -(x) : (x)) \nconst int maxn=1e6+7;\ntypedef long long ll;\nconst int inf=1<<25;\nint read(){\n    int s=0,f=1;\n    char c=getchar();\n    while(c<'0' || c>'9') {if(c=='-') f=-1; c=getchar();}\n    while(c>='0' && c<='9') {s=s*10+c-48;c=getchar();}\n    return s*f;\n}\nvoid write(int x){\n    if(x<0) {putchar('-');x=-x;}\n    if(x>9) write(x/10);\n    putchar(x%10+48);\n}\nint tree[101010];\nlong long d[101010];\nint siz[101010],fa[101010];\nbool cmp(const int &x,const int &y)\n{\n    return d[x]<d[y];\n}\nmap<long long,int> mp;\nint main()\n{\n    int n=read();\n    mp.clear();\n    fors(i,1,n){\n        d[i]=read();\n        siz[i]=1;\n        mp[d[i]]=i;\n        tree[i]=i;\n    }\n    sort(tree+1,tree+n+1,cmp);\n    for(int i=n;i>1;i--){\n        fa[tree[i]]=mp[d[tree[i]]+2*siz[tree[i]]-n];\n        if(!fa[tree[i]]){\n            printf(\"-1\");\n            return 0;\n        }\n        siz[fa[tree[i]]]+=siz[tree[i]];\n    }\n    fors(i,2,n)\n        d[tree[1]]-=siz[tree[i]];\n    if(d[tree[1]]){\n        printf(\"-1\");\n        return 0;\n    }\n    fors(i,2,n)\n        printf(\"%d %d\\n\",fa[tree[i]],tree[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <numeric>\n#include <map>\n#define fail return puts(\"-1\"), 0\n\nconst int N = 1e5 + 5, M = 2e5 + 5;\n\nint n, tot, lnk[N], ter[M], nxt[M], sz[N], fa[N];\nlong long dep[N], d[N], D[N];\nstd::map<long long, int> mp;\n\nvoid add(int u, int v) {\n\tter[++tot] = v, nxt[tot] = lnk[u], lnk[u] = tot;\n}\nvoid dfs1(int u, int p) {\n\tsz[u] = 1;\n\tfor (int i = lnk[u]; i; i = nxt[i]) {\n\t\tint v = ter[i];\n\t\tif (v == p) continue;\n\t\tdep[v] = dep[u] + 1;\n\t\tdfs1(v, u);\n\t\tsz[u] += sz[v];\n\t}\n}\nvoid dfs2(int u, int p) {\n\tfor (int i = lnk[u]; i; i = nxt[i]) {\n\t\tint v = ter[i];\n\t\tif (v == p) continue;\n\t\tD[v] = D[u] - 2 * sz[v] + n;\n\t\tdfs2(v, u);\n\t}\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &d[i]);\n\t\tmp[d[i]] = i;\n\t\tsz[i] = 1;\n\t}\n\tint cnt = 0;\n\tfor (auto it = mp.rbegin(); it != mp.rend(); it++) {\n\t\tint v = it->second;\n\t\tlong long now = it->first;\n\t\tlong long s = now + 2 * sz[v] - n;\n\t\tif (!mp.count(s)) fail;\n\t\tint u = mp[s];\n\t\tif (u == v) fail;\n\t\tfa[v] = u, sz[u] += sz[v];\n\t\tadd(u, v), add(v, u);\n\t\tif (++cnt == n - 1) break;\n\t}\n\tdfs1(1, 0);\n\tD[1] = std::accumulate(dep + 1, dep + n + 1, 0LL);\n\tdfs2(1, 0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (D[i] != d[i]) fail;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (fa[i]) printf(\"%d %d\\n\", i, fa[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2020/01/28] 22:36:00\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nusing max_heap = std::priority_queue<T>;\ntemplate<typename T>\nusing min_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\nauto mfp = [](auto&& f) { return [=](auto&&... args) { return f(f, std::forward<decltype(args)>(args)...); }; };\n\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\nstruct io_init\n{\n    io_init()\n    {\n        std::cin.tie(nullptr), std::ios::sync_with_stdio(false);\n        std::cout << std::fixed << std::setprecision(20);\n    }\n    void clear()\n    {\n        std::cin.tie(), std::ios::sync_with_stdio(true);\n    }\n} io_setting;\n\nint out() { return 0; }\ntemplate<typename T>\nint out(const T& v) { return std::cout << v, 0; }\ntemplate<typename T>\nint out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    return 0;\n}\ntemplate<typename T1, typename T2>\nint out(const std::pair<T1, T2>& v) { return out(v.first), std::cout << ' ', out(v.second), 0; }\ntemplate<typename T, typename... Args>\nint out(const T& v, const Args... args) { return out(v), std::cout << ' ', out(args...), 0; }\ntemplate<typename... Args>\nint outln(const Args... args) { return out(args...), std::cout << '\\n', 0; }\ntemplate<typename... Args>\nvoid outel(const Args... args) { return out(args...), std::cout << std::endl, 0; }\n#    define SHOW(...) static_cast<void>(0)\nconstexpr ull TEN(const usize n) { return n == 0 ? 1ULL : TEN(n - 1) * 10ULL; }\n\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type, const T& v = T{}) { return v; }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type szs, const T& v = T{})\n{\n    const usize s = (usize)szs[i];\n    return std::vector<decltype(make_v<T, Uint, n, i + 1>(szs, v))>(s, make_v<T, Uint, n, i + 1>(szs, v));\n}\ntemplate<typename T, typename Uint, usize n>\nauto make_v(c_arr<Uint, n> szs, const T& t = T{}) { return make_v<T, Uint, n, 0>(szs, t); }\n\ntemplate<typename Cost = usize>\nstruct edge\n{\n    using cost_type = Cost;\n    usize u, v;\n    Cost c;\n    edge(const usize u, const usize v) : u{u}, v{v}, c{1} {}\n    edge(const usize u, const usize v, const Cost& c) : u{u}, v{v}, c{c} {}\n    operator usize() const { return v; }\n    usize from() const { return u; }\n    usize to() const { return v; }\n    Cost cost() const { return c; }\n    friend std::ostream& operator<<(std::ostream& os, const edge& e) { return os << e.u << \"->\" << e.v << \":\" << e.c; }\n};\ntemplate<typename Edge>\nclass base_graph\n{\npublic:\n    base_graph(const usize n) : v{n}, es(n), res(n) {}\n    void add_edge(const usize u, const usize v, const bool bi = false)\n    {\n        es[u].emplace_back(u, v), res[v].emplace_back(v, u);\n        if (bi) { es[v].emplace_back(v, u), res[u].emplace_back(u, v); }\n    }\n    template<typename Cost>\n    void add_edge(const usize u, const usize v, const Cost& c, const bool bi = false)\n    {\n        es[u].emplace_back(u, v, c), res[v].emplace_back(v, u, c);\n        if (bi) { es[v].emplace_back(v, u, c), res[u].emplace_back(u, v, c); }\n    }\n    std::vector<Edge>& operator[](const usize u) { return es[u]; }\n    const std::vector<Edge>& operator[](const usize u) const { return es[u]; }\n    std::vector<Edge>& from(const usize u) { return es[u]; }\n    const std::vector<Edge>& from(const usize u) const { return es[u]; }\n    std::vector<Edge>& to(const usize v) { return res[v]; }\n    const std::vector<Edge>& to(const usize v) const { return res[v]; }\n    usize size() const { return v; }\n    friend std::ostream& operator<<(std::ostream& os, const base_graph& g)\n    {\n        for (usize i = 0; i < g.v; i++) {\n            for (const auto& e : g.es[i]) { os << e << '\\n'; }\n        }\n        return os;\n    }\n\nprivate:\n    usize v;\n    std::vector<std::vector<Edge>> es, res;\n};\ntemplate<typename Edge>\nusing base_tree = base_graph<Edge>;\nusing graph     = base_graph<edge<>>;\nusing tree      = base_graph<edge<>>;\ntemplate<typename Cost>\nusing cost_graph = base_graph<edge<Cost>>;\ntemplate<typename Cost>\nusing cost_tree = base_graph<edge<Cost>>;\nint main()\n{\n    const auto N = in<int>();\n    if (N == 2) { return outln(-1); }\n    auto ds = in_v<ll>({N});\n    std::map<ll, int> mp;\n    std::map<ll, int, std::greater<ll>> sub;\n    for (int i = 0; i < N; i++) { mp[ds[i]] = i; }\n    for (const ll d : ds) { sub[d] = 1; }\n    graph g(N);\n    int r = -1;\n    for (int i = 0; i < N - 1; i++) {\n        const auto fst = *sub.begin();\n        sub.erase(sub.begin());\n        const ll d  = fst.first;\n        const int s = fst.second;\n        const ll p  = d - (N - 2LL * s);\n        if (sub.count(p) == 0) { return outln(-1); }\n        g.add_edge(mp[p], mp[d]);\n        r = mp[p], sub[p] += s;\n    }\n    std::vector<int> sz(N, 1);\n    std::vector<ll> es(N, 0);\n    mfp([&](auto&& self, const int s) -> void {\n        for (const int to : g[s]) {\n            self(self, to);\n            sz[s] += sz[to];\n            es[s] += (es[to] + sz[to]);\n        }\n    })(r);\n    mfp([&](auto&& self, const int s) -> void {\n        for (const int to : g[s]) {\n            es[to] = es[s] + (N - 2 * sz[to]);\n            self(self, to);\n        }\n    })(r);\n    SHOW(es);\n    if (es != ds) { return outln(-1); }\n    for (int i = 0; i < N; i++) {\n        for (const int to : g[i]) { outln(i + 1, to + 1); }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nlong long d[110000];\npair<long long,int> p[110000];\nint sz[110000];\nint L[110000];\nint R[110000];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%lld\",d+i);\n\t\tp[i]=make_pair(d[i],i);\n\t}\n\tstd::sort(p,p+a);\n\tint ind=0;\n\tlong long sum=0;\n\tfor(int i=0;i<a;i++)sz[i]=1;\n\tfor(int i=a-1;i>=1;i--){\n\t\tint at=p[i].second;\n\t\tlong long C=p[i].first;\n\t\tint ad=a-2*sz[at];\n\t\tif(ad<=0){\n\t\t\tprintf(\"-1\\n\");return 0;\n\t\t}\n\t\tint in=lower_bound(p,p+a,make_pair(C-ad,0))-p;\n\t\tif(p[in].first!=C-ad){\n\t\t\tprintf(\"-1\\n\");return 0;\n\t\t}\n\t\tL[ind]=p[i].second;\n\t\tR[ind++]=p[in].second;\n\t\tsum+=(long long)sz[at]*(a-sz[at])*2;\n\t//\tprintf(\"%d %d\\n\",L[ind-1],R[ind-1]);\n\t\tsz[p[in].second]+=sz[at];\n\t}\n\tlong long dsum=0;\n\tfor(int i=0;i<a;i++){\n\t\tdsum+=d[i];\n\t}\n\tif(sum!=dsum){\n\t\tprintf(\"-1\\n\");return 0;\n\t}\n\tfor(int i=0;i<ind;i++){\n\t\tprintf(\"%d %d\\n\",L[i]+1,R[i]+1);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define pii pair<int,int> \n\nconst int inf=1e18+3;\n\nint N;\nint a[100010];\nint fa[100010];\nint sz[100010];\nmap<int,int> s;\n\nvoid FAIL()\n{\n\tcout<<\"-1\"<<endl;\n\texit(0);\n}\n\nmain()\n{\n\tmemset(fa,-1,sizeof(-1));\n\t\n\tint mina=inf;\n\t\n\tcin>>N;\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tcin>>a[i];\n\t\ts[a[i]]=i;\n\t\tsz[i]=1;\n\t\tmina=min(mina,a[i]);\n\t}\n\twhile(!s.empty())\n\t{\n\t\tauto en=s.end(); en--;\n\t\ts.erase(en);\n\t\tpii p={en->first,en->second};\n\t\tif(p.first==mina) break;\n\t\tint need=p.first-N+2*sz[p.second];\n\t\t\n\t\tauto w=s.find(need);\n\t\tif(w==s.end()) FAIL();\n\t\tfa[p.second]=w->second;\n\t\tsz[w->second]+=sz[p.second];\n\t}\n\tint cnt=0;\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tif(fa[i]==-1) cnt++;\n\t}\n\tif(cnt>=2) FAIL();\n\t\n\tvector<pii> ans;\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tif(fa[i]>0) ans.push_back({min(i,fa[i]),max(i,fa[i])});\n\t}\n\tsort(ans.begin(),ans.end());\n\tfor(auto i:ans)\n\t{\n\t\tcout<<i.first<<\" \"<<i.second<<endl;\n\t}\n\treturn 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#define N 120000\n#include<map>\nusing namespace std;\nstruct node{\n\tlong long x,id;\n}a[N];\nmap<long long,long long>p;\nlong long n,siz[N],fa[N];\nbool cmp(node x,node y){\n\treturn x.x>y.x;\n}\nint main(){\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nvoid dfs(int now, int past, ll d, ll &sum, VVI &e){\n    sum += d;\n    for (int next : e[now]){\n        if (next == past) continue;\n        dfs(next, now, d + 1, sum, e);\n    }\n}\n\nint main() {\n    ll n;\n    cin >> n;\n    VL d(n);\n    vector<PL> p(n);\n    REP(i,n){\n        d[i] = lin();\n        p[i] = PL(d[i], i);\n    }\n    sort(ALL(p));\n    reverse(ALL(p));\n\n    map<ll, ll> mp;\n    REP(i,n) mp[p[i].first] = i;\n    VL cnt(n, 1);\n\n    vector<PL> ans;\n    REP(i,n-1){\n        ll x = p[i].first - (n - 2 * cnt[i]);\n        if (!mp.count(x) || mp[x] <= i){\n            cout << -1 << endl;\n            return 0;\n        }\n        int j = mp[x];\n        cnt[j] += cnt[i];\n        ans.push_back(PL(p[i].second, p[j].second));\n    }\n\n    VVI e(n);\n    for (P p : ans){\n        e[p.first].push_back(p.second);\n        e[p.second].push_back(p.first);\n    }\n\n    ll sum = 0;\n    dfs(p[0].second, -1, 0, sum, e);\n\n    if (sum != p[0].first){\n        cout << -1 << endl;\n        return 0;\n    }\n\n    REP(i,n-1){\n        printf(\"%lld %lld\\n\", ans[i].first + 1, ans[i].second + 1);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\n#define all(x) (x).begin(),(x).end()\n\n\nint main() {\n#ifdef local\n\tfreopen(\"in.txt\", \"r\", stdin);\n#endif\n\tios::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tint n; cin >> n;\n\tvector<pair<ll, ll> > d(n);\n\tfor(int i = 0; i < n; i++) {\n\t\tll x; cin >> x;\n\t\td[i] = make_pair(x, i);\n\t}\n\tvector<int> sz(n, 1);\n\tsort(all(d), greater<pair<ll,ll>>());\n\tvector<pair<int, int> > edges;\n\tvector<vector<int> > adj(n);\n\tfor(int i = 0; i < n - 1; i++) {\n\t\tll id = d[i].se, dis = d[i].fi;\n\t\tint dt = n - 2*sz[id];\n\t\tdis -= dt;\n\t\tauto it = lower_bound(all(d), pair<ll, ll>(dis, n), greater<pair<ll, ll> >());\n\t\tif(it == d.end() || it->fi != dis) {\n\t\t\tcout << \"-1\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tsz[it->se] += sz[id];\n\t\tadj[it->se].push_back(id);\n\t\tedges.emplace_back(id + 1, it->se + 1);\n\t}\n\tfunction<ll(int)> dfs = [&](int u) {\n\t\tll ret = 0;\n\t\tfor(auto &v : adj[u]) {\n\t\t\tret += dfs(v) + sz[v];\n\t\t}\n\t\treturn ret;\n\t};\n\tif(dfs(d[n-1].se) != d[n-1].fi) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\tsort(all(edges));\n\tfor(auto &e : edges) {\n\t\tcout << e.fi << ' ' << e.se << '\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define ll long long\n#define Maxn 1000000\nll d[Maxn+5];\nint n;\nset<ll> st;\nmap<ll,int> mp;\nstruct Edge{\n\tint from,to;\n}edge[Maxn+5];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>d[i];\n\t\tmp[d[i]]=i;\n\t\tst.insert(d[i]);\n\t}\n\tint root=(*st.begin());\n\tst.erase(st.begin());\n\tset<ll>::iterator it,it_2;\n\tint len=0;\n\twhile(!st.empty()){\n\t\tint tmp=n-2;\n\t\tit=st.end();\n\t\tit--;\n\t\twhile((*it)-tmp>root&&tmp>0){\n\t\t\tit_2=st.find((*it)-tmp);\n\t\t\tif(it_2==st.end()){\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tedge[++len].from=mp[(*it)];\n\t\t\tedge[len].to=mp[(*it_2)];\n\t\t\tst.erase(it);\n\t\t\tit=it_2;\n\t\t\ttmp-=2;\n\t\t}\n\t\tif(tmp<=0){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tif((*it)-tmp<root){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tedge[++len].from=mp[(*it)];\n\t\tedge[len].to=mp[root];\n\t\tst.erase(it);\n\t}\n\tfor(int i=1;i<=len;i++){\n\t\tprintf(\"%d %d\\n\",edge[i].from,edge[i].to);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint N;\nint D[110000], n[110000];\nunordered_map<int, int> mp;\nvint ans;\nsigned main() {\n    cin >> N;\n    for (int i = 1; i <= N; i++) {cin >> D[i]; n[i] = 1; mp[D[i]] = i;};\n    sort(D + 1, D + N + 1); reverse(D + 1, D + N + 1);\n    for (int i = 1; i <= N - 1; i++) {\n        int s = mp[D[i]];\n        int t = mp[D[i] - N + 2 * n[s]];\n        if (s <= t || t == 0) {\n            cout << -1 << endl;\n            return 0;\n        }\n        n[t] += n[s];\n        ans.push_back(s); ans.push_back(t);\n    }\n    if (n[mp[D[N]]] != N) {\n        cout << -1 << endl;\n        return 0;\n    }\n    for (int i = 0; i < 2 * (N - 1); i += 2) {\n        cout << ans[i] << \" \" << ans[i + 1] << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long n, sz[100007], fa[100007];\npair<long long, long long>p[100007];\nvector<long long>e[100007];\nlong long read()\n{\n\tlong long num = 0;\n\tchar c = getchar();\n\twhile (c<'0' || c>'9')c = getchar();\n\twhile (c >= '0' && c <= '9')num = num * 10 + c - '0', c = getchar();\n\treturn num;\n}\nlong long dfs(int w, int f)\n{\n\tlong long res = 0;\n\tfor (int i = 0, lim = e[w].size(); i < lim; i++)\n\t\tres += dfs(e[w][i], w) + sz[e[w][i]];\n\treturn res;\n}\nint main()\n{\n\tn = read();\n\tfor (int i = 1; i <= n; i++)\n\t\tp[i] = make_pair(read(), i);\n\tsort(p + 1, p + n + 1);\n\tfor (int i = n; i > 1; i--)\n\t{\n\t\tint x = p[i].second;\n\t\tsz[x]++;\n\t\tint pos = lower_bound(p + 1, p + n + 1, make_pair(p[i].first + 2 * sz[x] - n, 0)) - p;\n\t\tif (pos >= i || p[i].first + 2 * sz[x] - n != p[pos].first) { cout << -1 << endl; return 0; }\n\t\tfa[x] = p[pos].second;\n\t\tsz[fa[x]] += sz[x];\n\t\te[fa[x]].push_back(x);\n\t}\n\tsz[p[1].second]++;\n\tif(dfs(p[1].second,0)!=p[1].first) { cout << -1 << endl; return 0; }\n\tfor (int i = 1; i <= n; i++)\n\t\tif (fa[i])printf(\"%d %d\\n\", fa[i], i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <string>\n#include <cstring>\n\n#define sz(v) ((int)((v).size()))\n#define all(v) (v).begin(), (v).end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int INF = 0x3c3c3c3c;\nconst ll LINF = 1ll*INF*INF*2;\n\nconst int MAX_N = 100001;\nint n;\nll input[MAX_N];\nint sz[MAX_N];\nint par[MAX_N];\nll sum[MAX_N];\n\nint main(void) {\n\tscanf(\"%d\", &n);\n\tfor(int i=0; i<n; i++) scanf(\"%lld\", input+i);\n\n\tsort(input, input+n);\n\tfor(int i=0; i<n; i++) sz[i] = 1;\n\n\tfor(int i=n-1; i>0; i--) {\n\t\tll temp = input[i]+sz[i]+sz[i]-n;\n\t\tint idx = lower_bound(input, input+n, temp)-input;\n\t\tif(input[idx] != temp) {\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tpar[i] = idx;\n\t\tsz[idx]+=sz[i];\n\t\tsum[idx]+=sum[i]+sz[i];\n\t}\n\tfor(int i=1; i<n; i++) {\n\t\tprintf(\"%d %d\\n\", par[i]+1, i+1);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#include <cmath>\n#include <complex>\n// #include \"utiltime.hpp\"\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef complex<double> cdouble;\n\nconst int INFL = (int)1e9;\nconst ll INFLL = (ll)1e18;\nconst double INFD = numeric_limits<double>::infinity();\nconst double PI = 3.14159265358979323846;\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loopll(i, n) for(ll i = 0; i < (ll)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopll1(i, n) for(ll i = 1; i <= (ll)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = (ll)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define Looprll1(i, n) for(ll i = (ll)n; i >= 1; i--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(i, vector.size()) { cout << vector[i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(i, matrix.size()) { Loop(j, matrix[i].size()) { cout << matrix[i][j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define readfile(filename) ifstream in(filename); cin.rdbuf(in.rdbuf());\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\nbool nearlyeq(double x, double y) { return abs(x - y) < 1e6; }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(double x) { ll m = (ll)sqrt(x); return m + (m * m <= (ll)(x) ? 0 : -1); }\nll ceilsqrt(double x) { ll m = (ll)sqrt(x); return m + ((ll)x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\n\n/*******************************************************/\n\nvoid failed() {\n\tcout << -1 << endl;\n\texit(0);\n}\n\nint main() {\n\tint n; cin >> n;\n\tvector<Pll> a(n);\n\tLoop(i, n) {\n\t\tcin >> a[i].first;\n\t\ta[i].second = i;\n\t}\n\tsort(a.begin(), a.end());\n\tvll subtree_cnt(n, 0);\n\tvector<Pll> ans;\n\tLoopr1(i, n - 1) {\n\t\tll target_val = a[i].first + subtree_cnt[i] * 2 - (ll)n + 2;\n\t\tauto itr = lower_bound(a.begin(), a.end(), Pll({ target_val, 0LL }));\n\t\tif (itr == a.end()) failed();\n\t\tif (itr - a.begin() == (a.size() - 1)) failed();\n\t\tif (itr->first != target_val) failed();\n\t\tsubtree_cnt[itr - a.begin()] += subtree_cnt[i] + 1;\n\t\tans.push_back({ a[i].second + 1, a[itr - a.begin()].second + 1 });\n\t\ta.pop_back();\n\t\tsubtree_cnt.pop_back();\n\t}\n\tLoop(i, ans.size()) {\n\t\tcout << ans[i].first << \" \" << ans[i].second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\nstruct node\n{\n\tlong long d;int p;\n}a[100010];\nstruct bian\n{\n\tint x,y,next;\n}e[100010];int len,last[100010];\nvoid ins(int x,int y)\n{\n\tlen++;\n\te[len].x=x;e[len].y=y;\n\te[len].next=last[x];last[x]=len;\n}\nbool cmp(node a,node b){return a.d<b.d;}\nint n;\nbool v[100010];\ninline int erfen(long long x)\n{\n\tint l=1,r=n,ans;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)/2;\n\t\tif(a[mid].d<=x)ans=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\tif(a[ans].d==x)return ans;\n\telse return -1;\n}\nint tot[100010];\nint sum;\nvoid dfs(int x,int dis)\n{\n\tsum+=dis;\n\tfor(int k=last[x];k;k=e[k].next)\n\t{\n\t\tint y=e[k].y;\n\t\tdfs(y,dis+1);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i].d),a[i].p=i;\n\tsort(a+1,a+n+1,cmp);\n\tfor(int i=1;i<=n;i++)tot[i]=1;\n\tbool bk=true;\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tlong long ul=a[i].d-n+2*tot[i];\n\t\tint y=erfen(ul);\n\t\tif(y==-1 || y==i){bk=false;break;}\n\t\tins(a[y].p,a[i].p);\n\t\ttot[y]+=tot[i];\n\t}\n\tdfs(a[1].p,0);\n\tif(bk==false || sum!=a[1].d)printf(\"-1\\n\");\n\telse for(int i=1;i<=len;i++)printf(\"%d %d\\n\",e[i].x,e[i].y);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Zory-2018\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n#include<set>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<bitset>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nnamespace mine\n{\n\ttypedef long long ll;\n\tconst int INF=0x3f3f3f3f;\n\n\tint n;\n\n\tconst int MAX_N=110000;\n\tstruct Nod\n\t{\n\t\tll d;int p,siz;\n\t\tfriend bool operator < (Nod a,Nod b) {return a.d<b.d;}\n\t}p[MAX_N];\n\n\t#define PR pair<int,int>\n\tvector<PR> ans;\n\n\tint hou[MAX_N];\n\tstruct Edge{int y,g;}e[MAX_N*2];\n\tint ln=0;\n\tvoid ins(int x,int y)\n\t{\n\t\te[++ln]=(Edge){y,hou[x]};hou[x]=ln;\n\t}\n\tll f[MAX_N];\n\tvoid dfs(int x,int fa,int dis)\n\t{\n\t\tf[x]=dis;\n\t\tfor(int k=hou[x];k>0;k=e[k].g)\n\t\t{\n\t\t\tint y=e[k].y;if(y==fa) continue;\n\t\t\tdfs(y,x,dis+1);\n\t\t}\n\t}\n\tvoid main()\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&p[i].d),p[i].p=i,p[i].siz=1;\n\t\tsort(p+1,p+n+1);\n\n\t\tfor(int i=n;i>=2;i--)\n\t\t{\n\t\t\tll want=p[i].d-n+2*p[i].siz;\n\t\t\tint fa=lower_bound(p+1,p+n+1,(Nod){want,0,0})-p;//互不相同\n\t\t\tif(p[fa].d!=want or fa==i) {puts(\"-1\");return;}\n\t\t\tins(p[i].p,p[fa].p);ins(p[fa].p,p[i].p);\n\t\t\tans.push_back( make_pair(p[i].p,p[fa].p) );\n\t\t\tp[fa].siz+=p[i].siz;\n\t\t}\n\t\tdfs(1,0,0);\n\t\tll rt=0,rt2=0;for(int i=1;i<=n;i++) {rt+=f[i];if(p[i].p==1) rt2=p[i].d;}\n\t\tif(rt!=rt2) {puts(\"-1\");return;}\n\t\tfor(int i=0;i<(int)ans.size();i++) printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\t}\n}\nint main()\n{\n\tmine::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\nusing namespace std;\nint n,d[100005];\nvector<long long>a,qz,dist,x;\nmap<long long,int>mp;\nvector<pair<int,int> >res;\nvector<vector<int> >nmp;\nint main(){\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tqz.push_back(1);\n\t\tdist.push_back(-1);\n\t}\n\tx.push_back(0);\n\tfor(int i=0;i<n;i++){\n\t\tcin>>d[i];\n\t\ta.push_back(d[i]);\n\t\tmp[d[i]]=i;\n\t}\n\tsort(d,d+n);\n\tfor(int i=n-1;i>=0;i--){\n\t\tlong long net=d[i]-(n-qz[mp[d[i]]]*2);\n\t\tif(mp.find(net)==mp.end()||mp[net]==mp[d[i]]){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tres.push_back(make_pair(mp[d[i]],mp[net]));\n\t\tqz[mp[net]]+=qz[mp[d[i]]];\n\t\tmp.erase(--mp.end());\t\t\n\t}\n\tdist[0]=0;\n\tfor(int i=0;i<res.size();i++){\n\t\tnmp[res[i].first].push_back(res[i].second);\n\t\tnmp[res[i].second].push_back(res[i].first);\n\t}\n\tfor(int i=0;i<x.size();i++){\n\t\tfor(int j=0;j<nmp[x[i]].size();j++){\n\t\t\tif(dist[nmp[x[i]][j]]==-1){\n\t\t\t\tx.push_back(nmp[x[i]][j]);\n\t\t\t\tdist[nmp[x[i]][j]]=dist[x[i]]+1;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ansd=0;\n\tfor(int i=0;i<dist.size();i++){\n\t\tansd+=dist[i];\n\t}\n\tif(ansd!=a[0]){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<res.size();i++){\n\t\tcout<<res[i].first+1<<\" \"<<res[i].second+1<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Konrad Paluszek,University of Warsaw(former XIV LO Staszic)\n//#STAY AT HOME\n#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n#define TIME (chrono::steady_clock::now().time_since_epoch().count())\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#define xfm(a,b)a##b\n#define xwb(a,b)xfm(a,b)\n#define _ xwb(nvj,__LINE__)\n#define __ xwb(kjy,__LINE__)\n#define ___ xwb(cjm,__LINE__)\n#define REP(i,n)for(urs(n)i=0;i<(n);++i)\n#define UNTIL(t)while(clock()<(t)*CLOCKS_PER_SEC)\n#define PER(r...)for(bool _=1;_||next_permutation(r);_=false)\n#define ALL(r)(r).begin(),(r).end()\n#define RALL(r)(r).rbegin(),(r).rend()\n#define FS(r)r.first,r.second\n#define SF(r)r.second,r.first\n#define M0(r) memset(r, 0, sizeof(r))\n#define sim template<class c\n#define ros return o\n#define rans return ans\n#define forbits(i,m)if(m)for(urs(m)i=ctz(m),i##nvj=m;i##nvj;i##nvj^=((urs(m))1<<i),i=ctz(i##nvj))\n#define fordbits(i,m)if(m)for(urs(m)i=8*sizeof(m)-clz(m)-1,i##nxd=m;i##nxd;i##nxd^=((urs(m))1<<i),i=8*sizeof(m)-clz(i##nxd)-1)\n#define ksets(t, m, k, n) for (t m = (((t)1 << (k)) - 1); m < ((t)1 << (n)); m = nux(m))\n#define urs(r...)typename decay<decltype(r)>::type\n#define hur(f,g,r)sim>int f(c a){if(sizeof(c)==16)return r;if(sizeof(c)==8)return g##ll(a);return g(a);}\n#define pwq(t,i) int clz(t x){return clz<int>(x)-i;}\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wconversion\"\nusing namespace __gnu_pbds;using namespace std;using ll=long long;using ld=long double;using ull=unsigned long long;using vi=vector<int>;using vll=vector<ll>;using pii=pair<int,int>;using pll=pair<ll,ll>;using vpii=vector<pii>;using spii=set<pii>;using mii=map<int,int>;using unt=unsigned int;sim>using min_queue=priority_queue<c,vector<c>,greater<c>>;sim,class b,class cmp=less<c> >using ordered_map=tree<c,b,cmp,rb_tree_tag,tree_order_statistics_node_update>;sim, class cmp=less<c>>using ordered_set = ordered_map<c,null_type,cmp>;hur(popc,__builtin_popcount,popc<ull>(a)+popc<ull>(a>>64))hur(ctz,__builtin_ctz,(ull)a?ctz<ull>(a):64+ctz<ull>(a>>64))hur(clz,__builtin_clz,a>>64?clz<ull>(a>>64):64+clz<ull>(a))pwq(short,16)pwq(uint16_t,16)pwq(char,24)pwq(int8_t,24)pwq(uint8_t,24)sim,class N>bool mini(c&o,const N&h){if(o>h)ros=h,1;return 0;}sim,class N>bool maxi(c&o,const N&h){if(o<h)ros=h,1;return 0;}sim,class n>using gyv=c;\n#if defined(LOCAL) // || defined(LOCAL2)\n#include </home/kjp/headers/debuglib.hpp>\n#else\n#define loc(...)\n#define onl(r...)r\n#define debug(...)\n#define print_stack(...)\n#define mark_stack(...)\n#define set_pre(...)\n#define reg_it(...)\n#define def_op(...) struct _{};\n#if !defined(LOCAL) && !defined(LOCAL2)\n#define exit my_exit\nvoid my_exit(int x) {fflush(stdout);_Exit(x);}\n#endif\n#endif\n#define next nexT\n#define prev preV\n#define tree trEE\n#define left lefT\n#define right righT\n#define div diV\n#define y1 y_1\n#define pow do not use cmath pow unless you know what you are doing\null mix(ull o){o+=0x9e3779b97f4a7c15;o=(o^(o>>30))*0xbf58476d1ce4e5b9;o=(o^(o>>27))*0x94d049bb133111eb;ros^(o>>31);}ull SALT=0x7a14a4b0881ebf9,tqu=0x7a14a4b0881ebf9;ull my_rand(){return tqu=mix(tqu);}void my_srand(ull x){SALT=tqu=x;}const int inf = 1023400000;const ll llinf=1234567890000000000ll;ll fix(ll o, ll m){o%=m;if(o<0)o+=m;ros;}\n#define rand my_rand\n#define srand my_srand\n#define random_shuffle(r...)random_shuffle(r,[](int _){return my_rand()%_;})\nsim>inline c nux(c m){if(!m)return numeric_limits<c>::max();c A=m&-m;c B=~((A-1)^m);c C=B&-B;c D=(C>>(1+ctz(A)))-1;return C|(m&~(C-1))|D;}__attribute__((no_sanitize_undefined))ll mul(ll a,ll b,ll m){ll q=(ll)(a*(ld)b/m);ll o=a*b-q*m;o%=m;if(o<0)o+=m;ros;}sim>void unq(c&x){x.resize(unique(ALL(x))-x.begin());}\n#pragma GCC diagnostic pop\n#if ((ULONG_MAX) != (UINT_MAX))\nnamespace std {template <> struct is_signed<__int128> : public true_type {};}\n#endif\nsim, class d> typename common_type<c,d>::type floor_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using floor_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b - (a % b < 0);}\nsim, class d> typename common_type<c,d>::type ceil_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using ceil_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b + (a % b > 0);}\nsim> struct REV {using value_type=typename c::value_type;c &x;using it=typename c::reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> struct CREV {using value_type=typename c::value_type;const c&x;using it=typename c::const_reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> REV<c> reversed(c&x) {return REV<c>{x};}sim> CREV<c> reversed(const c&x) {return CREV<c>{x};}\n#define done(r...) exit(0 * printf(r))\n#if defined(LOCAL) || defined(LOCAL2)\nvoid __tmi() {cerr << setprecision(6) << fixed << \"total time: \" << clock() / (ld)CLOCKS_PER_SEC << \"s\" << endl;}int _ = (atexit(__tmi), 0);\n#endif\n//#STAY AT HOME\nconst int nax = 1e5 + 44;\nvi graf[nax];\nint siz[nax];\nll d[nax];\nmap <ll, int> wh;\nvpii ans;\nvoid add_edge(int a, int b) {\n\tgraf[a].push_back(b);\n\tgraf[b].push_back(a);\n\tans.emplace_back(a + 1, b + 1);\n}\nvoid err() {\n\tdone(\"-1\\n\");\n}\nll su = 0;\nvoid dfs(int x, int y = -1, int d = 0) {\n\tfor (int v : graf[x]) if (v != y) dfs(v, x, d + 1);\n\tsu += d;\n}\nvoid solve() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tif (n % 2 == 0 && n <= 100) err();\n\tREP(i, n) scanf(\"%lld\", d + i);\n\tREP(i, n) siz[i] = 1;\n\tvector <pair <ll, int> > ord(n);\n\tREP(i, n) ord[i] = {d[i], i};\n\tREP(i, n) wh[d[i]] = i;\n\tsort(RALL(ord));\n\tREP(ind, n - 1) {\n\t\tauto [v, i] = ord[ind];\n\t\tll oth = v - n + siz[i] * 2;\n\t\tauto it = wh.find(oth);\n\t\tif (it == wh.end() || it->second == i) err();\n\t\tadd_edge(i, it->second);\n\t\tsiz[it->second] += siz[i];\n\t}\n\tdfs(0);\n\tif (su != d[0]) err();\n\tfor (auto [x, y] : ans) printf(\"%d %d\\n\", x, y);\n}\nint main() {\n\t// unt seed = TIME; debug(imie(seed));srand(seed);\n\tint t = 1;\n\t// scanf(\"%d\", &t);\n\tREP(_, t) solve();\n\texit(0);\n}\n//#STAY AT HOME\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define forn(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define popcount(x) __builtin_popcount(x)\n\n#ifdef LOCAL\n#define dbg(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl\n#define ln cerr << __LINE__ << endl\n#else\n#define dbg(x) void(0)\n#define ln void(0)\n#endif // LOCAL\n\nconst int N = 500000;\n\nint sz[N];\nvector<int> graph[N];\n\nsigned main()\n{\n    #ifdef ONLINE_JUDGE\n        ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n    #endif // ONLINE_JUDGE\n    int n;\n    cin >> n;\n    vector<ll> d(n);\n    vector<pair<ll, int> > q(n);\n    map<ll, int> mm;\n    for (int i = 1; i <= n; i++) cin >> d[i], q[i - 1] = {d[i], i}, mm[d[i]] = i;\n    sort(rall(q));\n    fill(sz, sz + N, 1);\n    for (int i = 0; i + 1 < q.size(); i++)\n    {\n        auto it = q[i];\n        ll ex = it.first + sz[it.second] - (n - sz[it.second]);\n        if (mm.find(ex) == mm.end())\n        {\n            cout << \"-1\";\n            return 0;\n        }\n        graph[it.second].push_back(mm[ex]);\n        sz[mm[ex]] += sz[it.second];\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (auto u : graph[i])\n        {\n            cout << u << \" \" << i << \"\\n\";\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nint main(){\n\tint N; cin >> N;\n\tvector<LL> D(N),dp(N,0);\n\tvector<int> s(N),sz(N,1),p(N,-1);\n\tmap<LL,int> M;\n\trepp(i,0,N){\n\t\tcin >> D[i];\n\t\tM[D[i]] = i;\n\t\ts[i] = i;\n\t}\n\tsort(s.begin(),s.end(),[&](const int &i, const int &j){return D[i] > D[j];});\n\trepp(i,0,N-1){\n\t\tauto it = M.find(D[s[i]]-N+2+(sz[s[i]]-1)*2);\n\t\tif(it == M.end() || (*it).first >= D[s[i]]) return cout << -1 << endl, 0;\n\t\tp[s[i]] = (*it).second;\n\t\tdp[(*it).second] += sz[s[i]]+dp[s[i]];\n\t\tsz[(*it).second] += sz[s[i]];\n\t}\n\tif(D[s[N-1]] != dp[s[N-1]]) return cout << -1 << endl, 0;\n\trepp(i,0,N-1) cout << s[i]+1 << ' ' << p[s[i]]+1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int inf=1e9;\nconst ll Inf=1e18;\nconst int N=1e5+10;\nll gi() {\n    ll x=0,o=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\ntemplate<typename T> void chkmax(T &a,T b) { a<b?a=b:0; };\ntemplate<typename T> void chkmin(T &a,T b) { a>b?a=b:0; };\nint n,id[N],siz[N];\nll d[N];\nmap<ll,int> M;\npii e[N];\nint tot=0;\nvector<int> E[N];\nbool cmp(int a,int b) { return d[a]<d[b]; }\nll dfs(int u,int dep) {\n    ll ret=0;\n    for(int v:E[u]) ret+=dfs(v,dep+1);\n    return ret+dep;\n}\nint main() {\n    cin>>n;\n    for(int i=1;i<=n;i++) d[i]=gi(),id[i]=i;\n    sort(id+1,id+n+1,cmp);sort(d+1,d+n+1);\n    for(int i=1;i<=n;i++) M[d[i]]=i;\n    for(int i=1;i<=n;i++) siz[i]=1;\n    for(int i=n;i>1;i--) {\n        int p=M[d[i]-2*(n-siz[i])+n];\n        if(!p||p>=i) return puts(\"-1\"),0;\n        e[++tot]=mp(id[p],id[i]);E[p].pb(i);siz[p]+=siz[i];\n    }\n    if(dfs(1,0)!=d[1]) puts(\"-1\");\n    else for(int i=1;i<=tot;i++) printf(\"%d %d\\n\",e[i].fi,e[i].se);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\ntypedef long long LL;\nconst int MN = 100005;\n\nint N, p[MN], siz[MN], ok;\nLL dis[MN], sum[MN];\nbool cmp(int i, int j) { return dis[i] > dis[j]; }\nstd::vector<int> G[MN];\n\nvoid DFS(int u, LL d) {\n\tif (d != dis[u]) ok = 0;\n\tfor (auto v : G[u]) DFS(v, d + N - 2 * siz[v]);\n}\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 1; i <= N; ++i) scanf(\"%lld\", &dis[i]), p[i] = i, siz[i] = 1;\n\tstd::sort(p + 1, p + N + 1, cmp);\n\tfor (int i = 1; i < N; ++i) {\n\t\tint u = p[i];\n\t\tif (2 * siz[u] >= N) return puts(\"-1\"), 0;\n\t\tdis[0] = dis[u] - N + 2 * siz[u];\n\t\tint pos = std::lower_bound(p + i + 1, p + N + 1, 0, cmp) - p;\n\t\tif (pos > N) return puts(\"-1\"), 0;\n\t\tint v = p[pos];\n\t\tG[v].push_back(u);\n\t\tsiz[v] += siz[u];\n\t\tsum[v] += sum[u] + siz[u];\n\t}\n\tok = 1;\n\tDFS(p[N], sum[p[N]]);\n\tif (!ok) return puts(\"-1\"), 0;\n\tfor (int i = 1; i <= N; ++i)\n\t\tfor (auto v : G[i]) printf(\"%d %d\\n\", i, v);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <time.h>\n\n#include <stdlib.h>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <vector>\n#include <map>\nusing namespace std;\nstruct condition{\n\tint32_t vertex;\n\tint64_t total;\n};\nstruct current{\n\tint32_t parent;\n\tint32_t vertex_num;\n};\nstruct edge{\n\tint32_t v1;\n\tint32_t v2;\n};\nbool operator< (const condition& a,const condition& b){\n\treturn a.total>b.total;\n}\nint main() {\n\n\tint32_t n;\n\tcin>>n;\n\tstd::vector<condition> cd;\n\tvector<edge> ans;\n\tans.reserve(n);\n\tcd.reserve(n);\n\tfor(int i=0;i<n;i++){\n\t\tint64_t temp;\n\t\tcin>>temp;\n\t\tcd.push_back(condition{i+1,temp});\n\t}\n\tbool ans_possible=true;\n\tsort(cd.begin(),cd.end());\n\tmap<int64_t,vector<current> > flow;\n\tfor(auto i=cd.begin();i!=cd.end();i++){\n\t\tint32_t sum_vertex=0;\n\n\t\tif(flow.count(i->total)){\n\t\t\tvector<current>& t=flow.at(i->total);\n\t\t\tint64_t total_cost=0;\n\t\t\tfor(auto k=t.begin();k!=t.end();k++){\n\t\t\t\tans.push_back(edge{k->parent,i->vertex});\n\t\t\t\tsum_vertex+=(k->vertex_num);\n\t\t\t\ttotal_cost+=((k->vertex_num)*(k->vertex_num+1))/2;\n\t\t\t}\n\t\t\tans_possible=(total_cost==i->total);\n\n\t\t\tflow.erase(i->total);\n\t\t}\n\n\t\tsum_vertex++;\n\n\t\tint32_t parent_value=i->total-(n-2*sum_vertex);\n\t\tif(flow.count(parent_value)){\n\t\t\tflow.at(parent_value).push_back(current{i->vertex,sum_vertex});\n\t\t}else{\n\t\t\tvector<current> temp2;\n\t\t\ttemp2.push_back(current{i->vertex,sum_vertex});\n\t\t\tflow.emplace(parent_value,temp2);\n\t\t}\n\n\t}\n\tif(flow.size()==1&&ans_possible){\n\t\tfor(auto i=ans.begin();i!=ans.end();i++){\n\t\t\tcout<<i->v1<<\" \"<<i->v2<<endl;\n\t\t}\n\t}else{\n\t\tcout<<-1<<endl;\n\t}\n\n\n\n\n\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ljc 998244353\nusing namespace std;\n#define gc getchar\ninline ll read(){\n    register ll x=0,f=1;char ch=gc();\n    while (!isdigit(ch)){if (ch=='-') f=-1;ch=gc();}\n    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}\n    return (f==1)?x:-x;\n}\nint n;\nstruct node{\n\tll x;\n\tint id;\n}x[1010101];\ninline bool cmp(node a,node b){\n\treturn a.x>b.x;\n}\nint sz[1010101];\nmap<ll,int> mp;\nvector<pair<int,int> > as;\nsigned main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++) x[i].x=read(),x[i].id=i,sz[i]=1,mp[x[i].x]=i;\n\tsort(x+1,x+1+n,cmp);\n\tif (n==2){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++){\n\t\tif (!mp.count(x[i].x-n+sz[x[i].id]+sz[x[i].id])){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint faa=mp[x[i].x-n+sz[x[i].id]+sz[x[i].id]];\n\t\tas.push_back(make_pair(faa,x[i].id));\n\t\tsz[faa]+=sz[x[i].id];\n\t}\n\tfor (auto i:as) printf(\"%d %d\\n\",i.first,i.second);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nmap<ll,int>p;\nmap<ll,int>::iterator it;\nint fa[100010],siz[100010],a[100010],b[100010],h[100010],nex[200010],to[200010],M,n;\nvoid add(int a,int b){\n    M++;\n    to[M]=b;\n    nex[M]=h[a];\n    h[a]=M;\n}\nll wd[100010],d[100010];\nvoid dfs(int x,int dis){\n    siz[x]=1;\n    d[1]+=dis;\n    for(int i=h[x];i;i=nex[i]){\n        if(to[i]!=fa[x]){\n            fa[to[i]]=x;\n            dfs(to[i],dis+1);\n            siz[x]+=siz[to[i]];\n        }\n    }\n}\nvoid dfs(int x){\n    for(int i=h[x];i;i=nex[i]){\n        if(to[i]!=fa[x]){\n            d[to[i]]=d[x]+n-siz[to[i]]*2;\n            dfs(to[i]);\n        }\n    }\n}\nint get(int x){return fa[x]==x?x:(fa[x]=get(fa[x]));}\nint main(){\n    int i;\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++){\n        scanf(\"%lld\",wd+i);\n        p[wd[i]]=i;\n    }\n    for(i=1;i<=n;i++){\n        fa[i]=i;\n        siz[i]=1;\n    }\n    it=p.end();\n    for(it--;it!=p.begin();it--){\n        if(n-siz[it->second]*2==0||!p.count(it->first-(n-siz[it->second]*2))){\n            puts(\"-1\");\n            return 0;\n        }\n        M++;\n        a[M]=it->second;\n        b[M]=p[it->first-(n-siz[it->second]*2)];\n        siz[fa[a[M]]=get(b[M])]+=siz[a[M]];\n    }\n    M=0;\n    for(i=1;i<n;i++){\n        add(a[i],b[i]);\n        add(b[i],a[i]);\n    }\n    fa[1]=0;\n    dfs(1,0);\n    dfs(1);\n    for(i=1;i<=n;i++){\n        if(wd[i]!=d[i]){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    for(i=1;i<n;i++)printf(\"%d %d\\n\",a[i],b[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nint n;\nmap<ll, pair<int, int> > st;\nvector<pair<int, int> > edge;\n\nint main()\n{\n\tread(n);\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tint d;\n\t\tread(d);\n\t\tst.insert(make_pair(d, make_pair(1, i)));\n\t}\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tauto x = *st.rbegin();\n\t\tst.erase(--st.end());\n\t\tint y = x.first-(n-x.second.first)+x.second.first;\n\t\tauto it = st.find(y);\n\t\tif(it == st.end()) {printf(\"-1\\n\"); return 0;}\n\t\telse it->second.first += x.second.first, edge.emplace_back(x.second.second, it->second.second);\n\t}\n\tfor(auto i : edge) printf(\"%d %d\\n\", i.first, i.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <map>\n\nint n;\nstruct point{\n\tlong long D;\n\tint id;\n}num[100001];\nstd::map<long long,int>map;\nint size[100001],fa[100001];\nbool cmp(const point &a,const point &b){return a.D>b.D;}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&num[i].D),num[i].id=i,map[num[i].D]=i,size[i]=1;\n\tstd::sort(num+1,num+n+1,cmp);\n\tfor(int i=1;i<n;i++)if(!(fa[i]=map[num[i].D+(size[num[i].id])-(n-size[num[i].id])])||(fa[i]==num[i].id)){puts(\"-1\");return 0;}else size[fa[i]]+=size[num[i].id];\n\tfor(int i=1;i<n;i++)printf(\"%d %d\\n\",fa[i],num[i].id);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 100010\n#define ll long long\nusing namespace std;\n\nint size[maxn],n,cnt,head[maxn],d[maxn];\n\nll dist[maxn];\n\nmap < ll , ll > id;\n\nstruct E{\n\tint to,nxt,fr;\n}edge[maxn<<1];\n\ninline void add(int u,int v){edge[++cnt]=(E){v,head[u],u};head[u]=cnt;}\n\ntemplate <class T>\nvoid read(T &x){\n\tchar s=getchar();x=0;\n\twhile(s<'0'||s>'9') s=getchar();\n\twhile(s>='0'&&s<='9') x=(x<<3)+(x<<1)+s-'0',s=getchar();\n}\n\nvoid dfs(int u){\n\tfor(int i=head[u];i;i=edge[i].nxt){\n\t\tint v=edge[i].to;\n\t\td[v]=d[u]+1;\n\t\tdfs(v);\n\t}\n}\n\nbool check(){\n\tll sum=0;\n\tfor(int i=1;i<=n;i++) sum+=d[i];\n\treturn dist[1]==sum;\n}\n\nint main(){\n\tread(n);\n\tfor(int i=1;i<=n;i++) read(dist[i]),id[dist[i]]=i,size[i]=1;\n\tsort(dist+1,dist+n+1);\n\tfor(int i=n;i>1;i--){\n\t\tint fa,u=id[dist[i]];\n\t\tll tmp1=n-size[u]*2;\n\t\tif(tmp1<=0) return printf(\"-1\"),0;\n\t\tll tmp2=dist[i]-tmp1;\n\t\tif(id.count(tmp2)==0) return printf(\"-1\"),0;\n\t\tfa=id[tmp2];\n\t\tadd(fa,u);\n\t\tsize[fa]+=size[u];\n\t}\n\tdfs(id[dist[1]]);\n\tif(check()){\n\t\tfor(int i=1;i<n;i++) printf(\"%d %d\\n\",edge[i].fr,edge[i].to);\n\t\treturn 0;\n\t}\n\tprintf(\"-1\"),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdint>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX = 100000;\n\ntypedef struct node {\n\tint id;\n\tint64_t num;\n\tint edge;\n\tint height;\n\tbool operator<(const node& r) const {\n\t\treturn num < r.num;\n\t}\n} Node;\n\nint main() {\n\tint N;\n\tstatic Node node[MAX];\n\tcin >> N;\n\tfor (int i = 0;i < N;++ i) {\n\t\tcin >> node[i].num;\n\t\tnode[i].id = i + 1;\n\t\tnode[i].height = 1;\n\t}\n\tsort(node, node + N);\n\t\n\tint64_t sum = 0; // 1からの距離\n\tfor (int i = N - 1;i > 0;-- i) { // 大きい数字から確定させる\n\t\tint min = 0, max = i;\n\t\tint64_t check = node[i].num - N + (node[i].height << 1);\n\t\tfor (int mid = max >> 1;max - min > 1;mid = min + (max - min >> 1)) {\n\t\t\tif (node[mid].num > check) max = mid;\n\t\t\telse min = mid;\n\t\t}\n\t\tif (node[min].num != check) { // 繋げる辺が存在しなかった\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\tnode[i].edge = min;\n\t\tnode[min].height += node[i].height;\n\t\tsum += node[i].height;\n\t}\n\t\n\tif (sum != node[0].num) {\n\t\tcout << -1;\n\t\treturn 0;\n\t}\n\tfor (int i = N - 1;i > 0;-- i) {\n\t\tcout << node[i].id << \" \" << node[node[i].edge].id << endl;\n\t}\n\treturn 0;\n}\n/*\n31536000のコメント解説欄\nここテンプレで用意してるから、A問題とかだとこの先空欄の危険あり\nまた、コンテスト後に https://31536000.hatenablog.com/ で解説していると思うので、良かったら読んでねー\n\n解説AC\n数字の大きい方の頂点から確定させることを考える\nこの時、この頂点から繋ぐ辺は、自分の数-N+(現時点の自分の属する木の高さ*2)となることが数学的に証明できる(解説放送参照)\nということは二分探索していけばO(NlogN)で判定と構築ができるわけだ\n最後に本当に正しいか確認だけして、問題ないなら構築完了\n*/"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Distance Sums\n\nusing P = pair<int64_t, int64_t>;\n\nint main() {\n  int64_t N;\n  cin >> N;\n  map<int64_t, P> mp;\n  for (int64_t i = 1; i <= N; i++) {\n    int64_t x;\n    cin >> x;\n    mp[x] = make_pair(i, 1);  // 頂点番号と木のサイズ\n  }\n    cout << -1 << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\n\nconst int MAXN = 1e5 + 5;\nll n, par[MAXN];\nll d, sz[MAXN];\nmap <ll, ll> mp;\n\nint main()\n{\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tvector <pair<ll,ll>> v;\n\tfor(ll i = 1; i <= n; i++){\n\t\tcin >> d; sz[i] = 1ll;\n\t\tmp[d] = i;\n\t\tv.push_back({-d, i});\n\t}\n\tsort(v.begin(), v.end());\n\tfor(ll i = 0; i < n - 1; i++){\n\t\td = -v[i].first;\n\t\tll ind = v[i].second;\n\t\tll dpar = max(0ll, d - (n - (2ll * sz[ind])));\n\t\tif(!mp[dpar] || mp[dpar] == ind){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tpar[ind] = mp[dpar];\n\t\tsz[par[ind]] += sz[ind];\n\t}\n\tfor(int i = 0; i < n - 1; i++){\n\t\tcout << par[v[i].second] << \" \" << v[i].second << '\\n';\n\t}\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define N 100100\n\nint n,cnt;\nll d[N];\nset<pair<ll,int> > S;\nint sz[N],u[N],v[N];\nset<pair<ll,int> >::iterator it,it2;\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) {\n\t\tscanf(\"%lld\",&d[i]);\n\t\tS.insert(mp(d[i],i));\n\t\tsz[i]=1;\n\t}\n\t\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tit=S.end(); it--;\n\t\tint now=(*it).second,num=sz[now];\n\t\tS.erase(it);\n\t\tit2=S.lower_bound(mp(d[now]-(n-2*num),0));\n\t\tif (it2==S.end() || (*it2).first!=d[now]-(n-2*num)) return puts(\"-1\"),0;\n\t\tu[++cnt]=now; v[cnt]=(*it2).second;\n\t\tsz[(*it2).second]+=num;\n\t}\n\tfor (int i=1;i<=cnt;i++) printf(\"%d %d\\n\",v[i],u[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N = 1e5 + 10;\nlong long n, d[N], s[N];\nvector<int> gr[N];\nmap<long long, int> mp;\nint32_t main() {\n\tios_base::sync_with_stdio (false), cin.tie(0), cout.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> d[i], mp[d[i]] = i;\n\tsort(d, d + n, greater<int> ());\n\tfor (int i = 0; i < n; i++) {\n\t\tint v = mp[d[i]];\n\t\ts[v]++;\n\t\tint valpar = d[i] - n + 2 * s[v];\n//\t\tcout << \"i = \" << i << \" : \" << valpar << endl;\n\t\tif (!mp.count(valpar)) {\n\t\t\tif (i == n - 1)\n\t\t\t\tbreak;\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\tint par = mp[valpar];\n\t\ts[par] += s[v];\n\t\tgr[v].push_back(par);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (auto u : gr[i])\n\t\t\tcout << i + 1 << \" \" << u + 1 << \"\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <algorithm>\n#include <utility>\n#define MAXN 100005\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,int> pi;\nll read()\n{\n\tll ans=0;\n\tchar c=getchar();\n\twhile (!isdigit(c)) c=getchar();\n\twhile (isdigit(c)) ans=(ans<<3)+(ans<<1)+(c^48),c=getchar();\n\treturn ans;\n}\npi p[MAXN];\nint siz[MAXN],fa[MAXN];\nll d[MAXN];\nint main()\n{\n\tint n=read();\n\tfor (int i=1;i<=n;i++) p[i]=make_pair(read(),i),siz[i]=1;\n\tsort(p+1,p+n+1);\n\tll sum=0;\n\tfor (int i=n;i>1;i--)\n\t{\n\t\tll t=p[i].first-n+2*siz[p[i].second];\n\t\tint k=lower_bound(p+1,p+n+1,make_pair(t,0))-p;\n\t\tif (p[k].first!=t) return puts(\"-1\"),0;\n\t\tfa[p[i].second]=p[k].second,siz[p[k].second]+=siz[p[i].second];\n\t\tsum+=siz[p[i].second];\n\t}\n\tif (sum!=p[1].first) return puts(\"-1\"),0;\n\tfor (int i=1;i<=n;i++) if (fa[i]) printf(\"%d %d\\n\",fa[i],i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nmap<int,int> M1,M2;\nint s1[200010],pa[200010];\nsigned main()\n{\n\tint n=read();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=read();\n\t\tM1[x]=i; M2[x]=1;\n\t\ts1[i]=x;\n\t}\n\tsort(s1+1,s1+1+n);\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tint id=M1[s1[i]],sz=M2[s1[i]],td=s1[i]+2*sz-n;\t\n\t\tif(td>=s1[i]) continue;\t\n\t\tpa[id]=M1[td]; M2[td]+=sz;\n\t}\n\tint ze=0;\n\tfor(int i=1;i<=n;i++)\n\t\tze+=(pa[i]==0);\n\tif(ze!=1)\n\t{\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++) if(pa[i])\n\t\tprintf(\"%lld %lld\\n\",i,pa[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing vi = vector<ll>;\nconst int maxn = 1<<19, mod = 1e9 + 7;\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tint n;\n\tcin >> n;\n\tvi a(n), sz(n+1, 1);\n\tmap<ll, int> id;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\tid[a[i]] = i+1;\n\t}\n\tsort(rall(a));\n\tvector<pair<int, int>> edges;\n\tfor(auto x : a) {\n\t\tint i = id[x];\n\t\tif(sz[i] == n) continue;\n\t\tll nd = x + 2*sz[i] - n;\n\t\tif(id.count(nd)) {\n\t\t\tedges.pb({i, id[nd]});\n\t\t\tsz[id[nd]] += sz[i];\n\t\t}\n\t}\n\tif(edges.size() != n-1) return cout << -1, 0;\n\tfor(auto i : edges) cout << i.first << \" \" << i.second << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+5;\nint n,f[N];\nstruct node\n{\n    ll x;\n    int id;\n    bool operator<(const node&o)const\n    {\n        return x<o.x;\n    }\n}a[N];\nset<pair<ll,int> >s[2];\nset<pair<ll,int> >::iterator it;\nvector<pair<int,int> >v;\nstruct qb\n{\n    int si,id;\n    qb(int si=0,int id=0):si(si),id(id){}\n    bool operator<(const qb&o)const\n    {\n        return id==o.id?si<o.si:a[id].x>a[o.id].x;\n    }\n};\npriority_queue<qb>q;\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%lld\",&a[i].x),a[i].id=i;\n    sort(a+1,a+1+n);\n    for(int i=1;i<=n;i++) f[i]=a[i].id;\n    ll x=(n-(a[2].x-a[1].x))/2;\n    if(x<0||x>n||x+a[2].x-a[1].x>n||((n&1)^(a[1].x&1)^(a[2].x&1))) {printf(\"-1\\n\");return 0;}\n    v.push_back({1,2});\n    for(int i=3;i<=n;i++)\n        s[a[i].x&1].insert({a[i].x,i});\n    q.push(qb{x+a[2].x-a[1].x,1});\n    q.push(qb{x,2});\n    //for(int i=1;i<=n;i++)\n    //    printf(i==n?\"%d\\n\":\"%d \",a[i].x);\n    //for(int i=1;i<=n;i++)\n    //    printf(i==n?\"%d\\n\":\"%d \",a[i].id);\n    //cout<<f[1]<<' '<<f[2]<<endl;\n    while(!q.empty())\n    {\n        qb now=q.top();q.pop();\n        int u=now.id,si=now.si;\n        while(si>1)\n        {\n            ll r=a[u].x+n-si+1,l=a[u].x+n-si+1-(si-1);\n            if((n&1)^(a[u].x&1))\n            {\n                it=s[1].lower_bound({l,0});\n                if(it==s[1].end()||(*it).first>r)\n                {\n                    //cout<<f[u]<<' '<<si<<' '<<a[u].x<<' '<<((*it).first)<<' '<<l<<' '<<r<<' '<<n-si+1<<endl;\n                    printf(\"-1\\n\");return 0;\n                }\n                ll fi=(*it).first,se=(*it).second;\n                v.push_back({u,se});\n                ll x=(n-(fi-a[u].x))/2;\n                si-=x;\n                q.push({x,se});\n                //cout<<f[u]<<' '<<f[se]<<endl;\n                s[1].erase(*it);\n            }\n            else\n            {\n                it=s[0].lower_bound({l,0});\n                if(it==s[0].end()||(*it).first>r)\n                {\n                    printf(\"-1\\n\");return 0;\n                }\n                ll fi=(*it).first,se=(*it).second;\n                v.push_back({u,se});\n                ll x=(n-(fi-a[u].x))/2;\n                si-=x;\n                q.push({x,se});\n                //cout<<f[u]<<' '<<f[se]<<endl;\n                s[0].erase(*it);\n            }\n        }\n    }\n    for(int i=0;i<v.size();i++)\n        printf(\"%d %d\\n\",f[v[i].first],f[v[i].second]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define ll long long\nll dat[100005];\npair<ll,ll> p[100005];\nll sz[100005];\nll from[100005];\nll to[100005];\nll n;\nint main() {\n\tcin>>n;\n\tfor(ll i=0;i<n;i++){\n\t\tcin>>dat[i];\n\t\tp[i]=make_pair(dat[i],i);\n\t}\n\tsort(p,p+n);\n\tll id=0;\n\tll sum=0;\n\tfor(int i=0;i<n;i++){\n\t\tsz[i]=1;\n\t}\n\tfor(ll i=n-1;i>=1;i--){\n\t\tll curid=p[i].second;\n\t\tll tmp=p[i].first;\n\t\tll nx=n-2*sz[curid];\n\t\tif(nx<=0){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tll pos=lower_bound(p,p+n,make_pair(tmp-nx,0LL))-p;\n\t\tif(p[pos].first!=tmp-nx){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tfrom[id]=p[i].second;\n\t\tto[id++]=p[pos].second;\n\t\tsum+=sz[curid]*(n-sz[curid])*2;\n\t\tsz[p[pos].second]+=sz[curid];\n\t}\n\tll ans=0;\n\tfor(ll i=0;i<n;i++){\n\t\tans+=dat[i];\n\t}\n\tif(sum!=ans) {\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tfor(ll i=0;i<id;i++){\n\t\tcout<<from[i]+1<<\" \"<<to[i]+1<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nint N;\nll D[100010];\nvector<pair<int,int>> ans;\nvector<vector<int>> v(100010);\nll dist[100010] = {0},inf = 1e18;\n\nvoid dfs(int n){\n\tfor(int i=0;i<v[n].size();i++){\n\t\tint s = v[n][i];\n\t\tif(dist[s]==inf){\n\t\t\tdist[s] = dist[n]+1;\n\t\t\tdfs(s);\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> N;\n\tmap<ll,int> m,num;\n\tpriority_queue<ll> Q;\n\tfor(int i=1;i<=N;i++){\n\t\tcin >> D[i];\n\t\tm[D[i]] = i;\n\t\tnum[D[i]] = 1;\n\t\tQ.push(D[i]);\n\t\tdist[i] = inf;\n\t}\n\tint count = 0;\n\twhile(count<N-1 && !Q.empty()){\n\t\tll s = Q.top();\n\t\tQ.pop();\n\t\tll t = s-(N-2*num[s]);\n//\t\tcout << s << \" \" << t << endl;\n\t\tif(t<=0) continue;\n\t\tif(m.count(t)){\n\t\t\tans.push_back({m[s],m[t]});\n\t\t\tv[m[s]].push_back(m[t]);\n\t\t\tv[m[t]].push_back(m[s]);\n\t\t\tcount++;\n\t\t\tnum[t] += num[s];\n\t\t}\n\t}\n\tdist[1] = 0;\n\tdfs(1);\n\tll sum = 0;\n//\tcout << ans.size() << endl;\n\tfor(int i=2;i<=N;i++) sum += dist[i];\n\tif(count!=N-1 || sum!=D[1]) cout << -1 << endl;\n\telse{\n\t\tfor(int i=0;i<N-1;i++){\n\t\t\tcout << ans[i].first << \" \" << ans[i].second << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int ll\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define gc getchar\n#define pc putchar\n#define fi first\n#define se second\n#define debug(x) cout << #x\" = \" << x << endl;\n#define pp(x,y) cout << \"pp: \" << x << \" \" << y << endl;\n#define rank __RAnK\ninline ll read(){\n\tregister ll x=0,f=1;register char c=gc();\n\tfor(;!isdigit(c);c=gc())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\n#define rd read\nvoid write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\nvoid writeln(ll x){write(x);puts(\"\");}\nconst int maxn = 1e5+233;\nvector<pair<int,int> > ans;\nint d[maxn],w[maxn],a[maxn];\nint del,n;\nbool cmp(int x,int y){\n\treturn d[x] < d[y];\n}\nint query(int l,int r,int need){\n\tint pos = -1;\n\twhile(l<=r){\n\t\tint mid =(l+r)>>1;\n\t\tif(d[a[mid]] - del < need) l = mid + 1; else\n\t\tif(d[a[mid]] - del > need) r = mid - 1; else\n\t\treturn a[mid];\n\t}\n\treturn -1;\n}\nsigned main(){\n\tn = rd();\n\tRep(i,1,n) d[i] = rd();\n\tRep(i,1,n) w[i] = 1;\n\tRep(i,1,n) a[i] = i;\n\tsort(a+1,a+1+n,cmp);//从小到大排序 \n\tdel = 0;\n\tDep(i,n,2){\n\t\t/*当前是a[i] - del，权重为w[i]\n\t\t移动一步\n\t\t对于所有(n-w[i])个点，都要减少1*/\n\t\tll need = d[a[i]] - del - (n - w[a[i]]) + w[a[i]]; \n\t\tint pos = query(1,i-1,need);//找到标号\n\t\tif(pos == -1){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tdel += w[a[i]];\n\t\tw[pos] += w[a[i]];\n\t\tans . push_back(pii(a[i],pos));\n\t}\n\tfor(auto i:ans){\n\t\tprintf(\"%lld %lld\\n\",i.fi,i.se);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxN = 1e5 + 10;\nlong long d[maxN];\nint sz[maxN];\nint n;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i) cin >> d[i];\n\tfor (int i = 1; i <= n; ++i) sz[i] = 1;\n\ttypedef pair<long long, int> plli;\n\tset<plli, greater<plli>> points;\n\tfor (int i = 1; i <= n; ++i) points.insert({d[i], i});\t\n\tvector<pair<int, int>> edges;\n\tbool fun = 1;\n\twhile (points.size() > 1) {\n\t\tauto f = points.begin(); points.erase(f);\t\n\t\tlong long d_p = (f->first + 2*sz[f->second] - n);\n\t\tauto r = points.lower_bound({d_p, 1000000});\n\t\tfun &= r != points.end();\t\t\t\n\t\tif (not fun) break;\n\t\tsz[r->second] += sz[f->second];\n\t\tedges.push_back({r->second, f->second});\n\t}\n\tif (fun) {\n\t\tfor (auto e : edges) {\n\t\t\tcout << e.first << \" \" << e.second << endl;\n\t\t}\n\t} else puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define inf 0x3f3f3f3f\n#define mod 1000000007\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define vi vector <int>\n#define pii pair <int, int>\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i,n) for (int i = 0; i < (int) (n); ++ i)\n#define foreach(it,c) for (__typeof(c.begin()) it = c.begin(); it != c.end(); ++ it)\n\ninline int read() {\n\tint x = 0, f = 1, c = getchar();\n\tfor (;!isdigit(c);c = getchar()) if (c == '-') f ^= 1;\n\tfor (; isdigit(c);c = getchar()) x = x * 10 + c - '0';\n\treturn f ? x : -x;\n}\n\nint n;\nll d[100005];\nmap <ll, int> st;\nvector <pii> e;\nint siz[100005];\n\nint main() {\n\tn = read();\n\trep(i, n) scanf(\"%lld\", &d[i]);\n\trep(i, n) st[d[i]] = i;\n\tint rt = st.begin() -> second;\n\tst.erase(st.begin());\n\trep(i, n) siz[i] = 1;\n\twhile (!st.empty()) {\n\t\tint mx = st.rbegin() -> second;\n\t\tll delta = 0;\n\t\twhile (true) {\n\t\t\tll nwd = d[mx];\n\t\t\tll nxtd = nwd - (n - 2 * siz[mx]);\n\t\t\t// cerr << mx << \" \" << nwd << \" \" << nxtd << endl;\n\t\t\tif (nxtd != d[rt] && !st.count(nxtd)) {\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tst.erase(nwd);\n\t\t\tif (nxtd == d[rt]) {\n\t\t\t\te.pb(mp(rt, mx));\n\t\t\t\tsiz[rt] += siz[mx];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint nxt = st[nxtd];\n\t\t\te.pb(mp(nxt, mx));\n\t\t\tsiz[nxt] += siz[mx];\n\t\t\tmx = nxt;\n\t\t}\n\t}\n\tif (e.size() != n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tif (siz[rt] != n) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\trep(i, e.size()) if (e[i].first > e[i].second) swap(e[i].first, e[i].second);\n\tsort(e.begin(), e.end());\n\trep(i, e.size()) printf(\"%d %d\\n\", e[i].first + 1, e[i].second + 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define int ll\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nint const N = 1e5 + 20 ;\nint n , d[N] , sz[N] ;\nmap <int , int> mp ;\nvector <pii> edges ;\n\nvoid err () {\n\tcout << -1 << '\\n' ;\n\texit(0) ;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tcin >> n ;\n\n\tfor (int i = 0 ; i < n ; i ++) cin >> d[i] , mp[d[i]] = i , sz[i] = 1 ;\n\n\tsort(d , d + n , greater<int>()) ;\n\n\tfor (int i = 0 ; i < n - 1 ; i ++) {\n\t\tint v = mp[d[i]] ;\n\t\tint k = d[i] - n + 2 * sz[v] ;\n\n\t\tif (k == d[i] || !mp.count(k)) err() ;\n\n\t\tint p = mp[k] ;\n\n\t\tsz[p] += sz[v] ;\n\t\tedges.push_back({p , v}) ;\n\t}\n\n\tfor (pii p : edges) cout << p.F + 1 << ' ' << p.S + 1 << '\\n' ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid err() {\n  cout << -1 << endl;\n  exit(0);\n}\nvoid dfs (int crr, int dpt, vector<vector<int>>& grh, long long& cnt) {\n  cnt += dpt;\n  for (int nxt : grh[crr]) {\n    dfs(nxt, dpt + 1, grh, cnt);\n  }\n}\nint main() {\n  int n;\n  cin >> n;\n  vector<long long> d(n);\n  map<long long, int> mp;\n  for (int i = 0; i < n; i++) {\n    cin >> d[i];\n    mp[d[i]] = i;\n  }\n  sort(d.begin(), d.end());\n  vector<long long> sz(n, 1);\n  vector<vector<int>> grh(n);\n  for (auto it = d.rbegin(); next(it) != d.rend(); it++) {\n    auto i = mp.rbegin()->second;\n    long long wnt = *it - n + 2 * sz[i];\n    if (mp.find(wnt) == mp.end()) err();\n    auto p = mp[wnt];\n    grh[p].push_back(i);\n    sz[p] += sz[i];\n    mp.erase(--mp.end());\n  }\n  long long cnt = 0;\n  int rt = mp[d[0]];\n  queue<int> que;\n  que.push(rt);\n  vector<long long> dst(n, 0);\n  while (!que.empty()) {\n    auto crr = que.front();\n    que.pop();\n    for (int nxt : grh[crr]) {\n      que.push(nxt);\n      dst[nxt] = dst[crr] + 1;\n    }\n  }\n  if (accumulate(dst.begin(), dst.end(), 0LL) != *d.begin()) err();\n  // dfs(rt, 0, grh, cnt);\n  // if (d[0] != cnt) err();\n  for (int crr = 0; crr < n; crr++) {\n    for (int nxt : grh[crr]) {\n      cout << crr + 1 << ' ' << nxt + 1 << endl;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\nint main() {\n\tauto no = [](){ printf(\"-1\\n\"); exit(0); };\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<long long> d(n);\n\tmap<long long, int> mp;\n\trep(i, n) {\n\t\tscanf(\"%lld\", &d[i]);\n\t\tmp[d[i]] = i;\n\t}\n\tsort(d.begin(), d.end());\n\tlong long mi = d[0];\n\treverse(d.begin(), d.end());\n\td.pop_back();\n\tset<long long> remains;\n\trep(i, d.size()) {\n\t\tremains.insert(d[i]);\n\t}\n\tvector<pair<int, int>> ans;\n\trep(i, d.size()) {\n\t\tif (remains.count(d[i]) == 0) continue;\n\t\tremains.erase(d[i]);\n\t\tint s = 1;\n\t\tlong long cur = d[i];\n\t\tlong long prev;\n\t\twhile (true) {\n\t\t\tlong long diff = n - s * 2;\n\t\t\tif (diff <= 0) no();\n\t\t\tprev = cur;\n\t\t\tcur -= diff;\n\t\t\tif (cur == mi) {\n\t\t\t\tans.push_back({mp[prev], mp[cur]});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (remains.count(cur) == 0) no();\n\t\t\tremains.erase(cur);\n\t\t\tans.push_back({mp[prev], mp[cur]});\n\t\t\ts ++;\n\t\t}\n\t}\n\tassert(ans.size() == n - 1);\n\tvector<vector<int>> g(n);\n\trep(i, n - 1) {\n\t\tint a = ans[i].first;\n\t\tint b = ans[i].second;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tvector<long long> s(n);\n\tvector<int> dis(n);\n\tvector<int> sz(n);\n\tfunction<void (int, int)> dfs = [&](int u, int prev) {\n\t\tsz[u] = 1;\n\t\tfor (auto v : g[u]) if (v != prev) {\n\t\t\tdis[v] = dis[u] + 1;\n\t\t\tdfs(v, u);\n\t\t\tsz[u] += sz[v];\n\t\t}\n\t};\n\tdfs(0, -1);\n\trep(i, n) s[0] += dis[i];\n\tfunction<void (int, int)> dfs2 = [&](int u, int prev) {\n\t\tfor (auto v : g[u]) if (v != prev) {\n\t\t\ts[v] = s[u] + n - sz[v] * 2;\n\t\t\tdfs2(v, u);\n\t\t}\n\t};\n\tdfs2(0, -1);\n\tsort(s.begin(), s.end());\n\td.push_back(mi);\n\tsort(d.begin(), d.end());\n\tif (s != d) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tfor (auto it : ans) printf(\"%d %d\\n\", it.first + 1, it.second + 1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\nconst int N=100005;\nlong long d[N],m[N],dist[N];int id[N];\nmap<long long,int> ma;\nbool cmp1(int i,int j){return d[i]>d[j];}\nvector<int> ansu,ansv;\nint n;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",d+i);\n\t\tid[i]=i;m[i]=1;\n\t\tma[d[i]]=i;\n\t}\n\tsort(id+1,id+1+n,cmp1);\n\tfor(int i=1;i<n;i++){\n\t\tlong long dv=d[id[i]]+2*m[id[i]]-n;\n\t\tif(ma[dv]==0){puts(\"-1\");return 0;}\n\t\tint v=ma[dv];\n\t\tansu.push_back(id[i]);\n\t\tansv.push_back(v);\n\t\tm[v]+=m[id[i]];\n\t\tdist[v]+=dist[id[i]]+m[id[i]];\n\t}\n\tif(dist[id[n]]!=d[id[n]]) puts(\"-1\");\n\telse\n\t\tfor(int i=0;i<ansu.size();i++) printf(\"%d %d\\n\",ansu[i],ansv[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n#include <cmath>\n\nusing namespace std;\n\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst ll SZ = 1e5 + 100;\nll n;\nvector<vector<ll>> gr;\nvector<pair<ll, ll>> vec;\n\nll sub[SZ], dp[SZ];\nmap<ll, ll> m;\n\nint main()\n{\n\tfastInp;\n\n\tcin >> n;\n\n\tvec.resize(n);\n\tfor (auto &cur : vec) cin >> cur.first;\n\tfor (int i = 0; i < n; i++) {\n\t\tsub[i] = 1;\n\t\tvec[i].second = i;\n\t\tm[vec[i].first] = vec[i].second;\n\t}\n\n\tsort(vec.rbegin(), vec.rend());\n\n\tvector<pair<ll, ll>> edges;\n\tfor (int i = 0; i < vec.size() - 1; i++) {\n\t\tll par = vec[i].first + sub[vec[i].second] - (n - sub[vec[i].second]);\n\t\tif (m.find(par) == m.end() || m[par] == vec[i].second) {\n\t\t\tcout << \"-1\";\n\t\t\treturn 0;\n\t\t}\n\n\t\tsub[m[par]] += sub[vec[i].second];\n\t\tdp[m[par]] += sub[vec[i].second] + dp[vec[i].second];\n\t\tedges.push_back({ vec[i].second, m[par] });\n\t}\n\n\tif (dp[vec.back().second] != vec.back().first) {\n\t\tcout << \"-1\";\n\t\treturn 0;\n\t}\n\tfor (auto cur : edges) {\n\t\tcout << cur.first + 1 << \" \" << cur.second + 1 << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint PREP = (cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(9), 0);\n//int SEGV = getenv(\"D\") || (exit(system(\"D= SEGFAULT_SIGNALS=all catchsegv ./prog.exe\") >> 8), 0);\nvoid fail() {\n    cout << -1 << '\\n';\n    exit(0);\n}\nint main() {\n    int N; cin >> N;\n    if (N % 2 == 0) fail();\n    map<Int, pair<int, int>> M; // D[i] -> idx, num\n    vector<pair<int, int>> ans;\n    for (int i = 0; i < N; i++) {\n        Int d; cin >> d;\n        M[d] = make_pair(i, 1);\n    }\n    for (auto it = rbegin(M), ite = rend(M); it != ite; ++it) {\n        int idx, num; tie(idx, num) = it->second;\n        if (num == N) continue;\n        Int dnext = it->first - abs((N - num) - num);\n        if (!M.count(dnext)) fail();\n        ans.emplace_back(idx, M[dnext].first);\n        M[dnext].second += num;\n    }\n    for (auto &p : ans) {\n        cout << p.first + 1 << ' ' << p.second + 1 << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int N=100100;\n\nmap<LL,int> qaq;\n\nvoid GG(){\n\tputs(\"-1\");\n\texit(0);\n}\n\nint sz[N];\n\nvector<int> es[N];\nLL dd[N]={0};\nLL d[N];\nvoid dfs(int x,int fa=-1){\n\tfor(vector<int>::iterator it=es[x].begin();it!=es[x].end();++it){\n\t\tif(*it==fa)continue;\n\t\tdfs(*it,x);\n\t\tdd[x]+=dd[*it]+sz[*it];\n\t}\n}\n\nvector<pair<int,int> > ess;\nvoid ae(int u,int v){\n\tif(u>v)swap(u,v);\n\tess.push_back(pair<int,int>(u,v));\n\tes[u].push_back(v);\n\tes[v].push_back(u);\n}\nvoid print(){\n\tsort(ess.begin(),ess.end());\n\tfor(vector<pair<int,int> >::iterator it=ess.begin();it!=ess.end();++it){\n\t\tprintf(\"%d %d\\n\",it->first,it->second);\n\t}\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&d[i]);\n\t\tqaq[d[i]]=i;\n\t\tsz[i]=1;\n\t}\n\tint cnt=n;\n\tfor(map<LL,int>::reverse_iterator it=qaq.rbegin();it!=qaq.rend();++it){\n\t\tint x=it->second;\n\t\tint ddd=it->first;\n\t\tif(sz[x]*2==n)GG();\n\t\tLL nd=ddd+sz[x]-(n-sz[x]);\n\t\tif(cnt==1){\n\t\t\tdfs(x);\n\t\t\tif(dd[x]!=d[x])GG();\n\t\t\tbreak;\n\t\t}\n\t\tif(!qaq.count(nd)){\n\t\t\tGG();\n\t\t}else{\n\t\t\tint v=qaq[nd];\n\t\t\tae(x,v);\n\t\t\tsz[v]+=sz[x];\n\t\t}\n\t\tcnt--;\n\t}\n\tprint();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nmap<int,int> M1,M2;\nint s1[200010],pa[200010];\nstruct edge\n{\n\tint v,next;\n}vs[200010];\nint st[200010],ee,sz[200010],vis[20010];\ninline void addedge(int u,int v)\n{\n\tvs[++ee].v=v;vs[ee].next=st[u];st[u]=ee;\n}\t\ninline void dfs(int rt,int pr)\n{\n\tfor(int i=st[rt];i;i=vs[i].next)\n\t\tif(vs[i].v!=pr) dfs(vs[i].v,rt),sz[rt]+=sz[vs[i].v];\n}\nsigned main()\n{\n\tint n=read();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=read();\n\t\tM1[x]=i; M2[x]=1;\n\t\ts1[i]=x;\n\t}\n\tsort(s1+1,s1+1+n);\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tint id=M1[s1[i]],sz=M2[s1[i]],td=s1[i]+2*sz-n;\t\n\t\tif(td==s1[i]) continue;\t\n\t\tpa[id]=M1[td]; M2[td]+=sz;\n\t}\n\tint rt=0;\n\tfor(int i=1;i<=n;i++) \n\t{\n\t\tif(pa[i]) addedge(pa[i],i),addedge(i,pa[i]);\n\t\telse \n\t\t{ \n\t\t\tif(rt) puts(\"-1\"),exit(0);\n\t\t\telse rt=i;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) sz[i]=1;\n\t//dfs(rt,0);\n\t//if(sz[rt]!=n) puts(\"-1\"),exit(0);\n\t//else\n\t// { \n\t\tfor(int i=1;i<=n;i++) if(pa[i])\n\t\t\tprintf(\"%lld %lld\\n\",i,pa[i]);\n\t// }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n\nusing lint = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n\n    std::vector<lint> ds(n);\n    std::map<lint, int> drev;\n    for (int v = 0; v < n; ++v) {\n        std::cin >> ds[v];\n        drev[ds[v]] = v;\n    }\n\n    std::vector<int> vs(n);\n    std::iota(vs.begin(), vs.end(), 0);\n    std::sort(vs.begin(), vs.end(),\n              [&](int u, int v) { return ds[u] > ds[v]; });\n\n    std::vector<int> szs(n, 1);\n    std::vector<std::vector<int>> to(n);\n\n    for (auto v : vs) {\n        if (v == vs.back()) continue;\n\n        lint nxt = ds[v] - (n - szs[v] * 2);\n        if (!drev.count(nxt)) {\n            std::cout << -1 << std::endl;\n            return;\n        }\n\n        int u = drev[nxt];\n        to[u].push_back(v);\n        szs[u] += szs[v];\n    }\n\n    int r = vs.back();\n\n    lint dsum = 0;\n    std::function<void(int, int)> dfs =\n        [&](int v, int d) -> void {\n        dsum += d;\n        for (auto u : to[v]) dfs(u, d + 1);\n    };\n    dfs(r, 0);\n\n    if (dsum != ds[r]) {\n        std::cout << -1 << std::endl;\n        return;\n    }\n\n    for (int v = 0; v < n; ++v) {\n        for (auto u : to[v]) {\n            std::cout << v + 1 << \" \" << u + 1 << std::endl;\n        }\n    }\n    return;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 998244353\n#define ny 499122177\n#define maxn 1000000000000000000LL\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nlong long n,i,x,zz[100005],sum[100005];\nstruct nyh{\n\tlong long x,id;\n}o[100005];\nmap<long long,long long> mp;\nbool cmp(nyh u,nyh v){\n\treturn u.x<v.x;\n}\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tcout<<-1<<endl;\n\treturn 0;\n\tn=read();\n\tfor(i=1;i<=n;i++){\n\t\to[i].x=read();\n\t\to[i].id=i;\n\t}\n\tsort(o+1,o+n+1,cmp);\n\tfor(i=1;i<=n;i++){\n\t\tmp[o[i].x]=i;\n\t\tsum[i]=1;\n\t}\n\tfor(i=n;i>=2;i--){\n\t\tx=o[i].x-n+sum[i]*2;\n\t\tif(mp[x]!=0&&mp[x]<i){\n\t\t\tzz[i]=mp[x];\n\t\t\tsum[zz[i]]+=sum[i];\n\t\t}\n\t\telse{\n\t\t\tpus(-1,2);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(i=n;i>=2;i--){\n\t\tpus(o[zz[i]].id,1);\n\t\tpus(o[i].id,2);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b)for(int i=a,_e=b;i<=_e;++i)\n#define fd(i,a,b)for(int i=b,_e=a;i>=_e;--i)\n#define ll long long\n#define NO return printf(\"-1\"),0\nusing namespace std;\nconst int N=1e5+5;\nint n,b[N][2],bs,sz[N];\nll w[N];\nunordered_map<ll,int>A;\nbool can;\nint main(){\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\tfo(i,1,n)cin>>w[i],A[w[i]]=i,sz[i]=1;\n\tsort(w+1,w+n+1);\n\tfd(i,2,n){\n\t\tint x=A[w[i]],y;\n\t\tif(sz[x]*2>=n)NO;\n\t\ty=A[w[i]-n+sz[x]*2];\n\t\tif(!y)NO;\n\t\t++bs;b[bs][0]=x;b[bs][1]=y;\n\t\tsz[y]+=sz[x];\n\t}\n\tfo(i,1,bs)printf(\"%d %d\\n\",b[i][0],b[i][1]);\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FOR2(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define RFOR2(i,a,b) for(int i = (b);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define REP2(i,n)  FOR2(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define RREP2(i,n) RFOR2(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){if(a>b) {a=b; return true;} else return false;}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){if(a<b) {a=b; return true;} else return false;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nvec edge[101010];\n\nvoid solve(){\n  int N;\n  cin >> N;\n\n  vector<P> D(N);\n  REP(i,N) cin >> D[i].fs, D[i].sc = i;\n  \n  sort(D.rbegin(),D.rend());\n\n  multiset<P> ms;\n  vec v(N,1);\n  REP(i,N){\n    auto itr = ms.upper_bound(P(D[i].fs,-1));\n    while(itr!=ms.end()&&(*itr).fs==D[i].fs){\n      int id = (*itr).sc;\n      v[i] += v[id];\n      edge[i].push_back(id);\n      edge[id].push_back(i);\n      itr = ms.erase(itr);\n    }\n    ms.insert(P(D[i].fs-N+2*v[i],i));\n  }\n\n  if(ms.size()>1){\n    cout << -1 << endl;\n    return;\n  }\n\n  REP(i,N){\n    for(int j:edge[i]){\n      if(i<j) cout << D[i].sc+1 SP D[j].sc+1 << endl;\n    }\n  }\n\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int T = 1;\n  // cin >> T;\n\n  while(T--) solve();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define LLI long long int\n#define FOR(v, a, b) for(LLI v = (a); v < (b); ++v)\n#define FORE(v, a, b) for(LLI v = (a); v <= (b); ++v)\n#define REP(v, n) FOR(v, 0, n)\n#define REPE(v, n) FORE(v, 0, n)\n#define REV(v, a, b) for(LLI v = (a); v >= (b); --v)\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define ITR(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)\n#define RITR(it, c) for(auto it = (c).rbegin(); it != (c).rend(); ++it)\n#define EXIST(c,x) ((c).find(x) != (c).end())\n#define fst first\n#define snd second\n#define popcount __builtin_popcount\n#define UNIQ(v) v.erase(unique(ALL(v)), v.end())\n#define bit(i) (1LL<<i)\n#define sz(v) ((LLI)(v).size())\n\n#ifdef DEBUG\n#include <misc/C++/Debug.cpp>\n#else\n#define dump(...) ((void)0)\n#endif\n\n#define gcd __gcd\n\nusing namespace std;\ntemplate <class T> constexpr T lcm(T m, T n){return m/gcd(m,n)*n;}\n\ntemplate <typename I> void join(ostream &ost, I s, I t, string d=\" \"){for(auto i=s; i!=t; ++i){if(i!=s)ost<<d; ost<<*i;}ost<<endl;}\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v){for(auto &a : v) is >> a; return is;}\ntemplate <typename T, typename U> istream& operator>>(istream &is, pair<T,U> &p){is >> p.first >> p.second; return is;}\n\ntemplate <typename T, typename U> bool chmin(T &a, const U &b){return (a>b ? a=b, true : false);}\ntemplate <typename T, typename U> bool chmax(T &a, const U &b){return (a<b ? a=b, true : false);}\ntemplate <typename T, size_t N, typename U> void fill_array(T (&a)[N], const U &v){fill((U*)a, (U*)(a+N), v);}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int N;\n  while(cin >> N){\n    vector<LLI> D(N); cin >> D;\n\n    map<int,int> m1;\n    REP(i,N){\n      m1[D[i]] = i;\n    }\n\n    sort(RALL(D));\n\n    vector<pair<int,int>> ans;\n    vector<int> size_subtree(N,1);\n    bool no = false;\n    vector<LLI> d_sum(N);\n\n    //dump(D);\n\n    int root = m1[D.back()];\n\n    REP(i,N-1){\n      LLI d = D[i];\n      int x = m1[d];\n\n      LLI dd = d+size_subtree[x]-(N-size_subtree[x]);\n      //dump(dd);\n\n      if(not EXIST(m1,dd) or d == dd){\n\tno = true;\n\tbreak;\n      }else{\n\tsize_subtree[m1[dd]] += size_subtree[x];\n\td_sum[m1[dd]] += d_sum[x] + size_subtree[x];\n\tans.push_back({x,m1[dd]});\n      }\n    }\n    //dump(d_sum);\n    if(d_sum[root] != D.back()) no = true;\n\n    if(no){\n      cout << -1 << endl;\n    }else{\n      for(auto &p : ans){\n\tcout << p.fst+1 << \" \" << p.snd+1 << endl;\n      }\n    }\n    cerr << endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Written By NewbieChd\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nconst int BUF = 1000000;\nchar buf[BUF], *p1, *p2;\ninline char getChar() { return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, BUF, stdin), p1 == p2) ? EOF : *p1++; }\ninline long long read() {\n    long long f = 0;\n    char c;\n    while (!isdigit(c = getChar())) {}\n    do\n        f = f * 10 + (c ^ 48);\n    while (isdigit(c = getChar()));\n    return f;\n}\n\nconst int maxN = 100003;\nlong long d[maxN];\nmap<long long, int> mp;\n\nint ind[maxN];\ninline bool cmp(int x, int y) { return d[x] > d[y]; }\n\nint siz[maxN];\nvector<int> g[maxN];\nlong long dfs(int x) {\n    long long o = 0;\n    for (int y : g[x])\n        o += dfs(y) + siz[y];\n    return o;\n}\n\nint main() {\n    int n = read(), i, x, y;\n    long long tmp;\n    for (i = 1; i <= n; ++i)\n        d[i] = read(), mp[d[i]] = i, ind[i] = i, siz[i] = 1;\n    sort(ind + 1, ind + n + 1, cmp);\n    for (i = 1; i < n; ++i) {\n        x = ind[i], tmp = d[x] - n + (siz[x] << 1);\n        if (mp.find(tmp) == mp.end() || siz[x] << 1 == n) {\n            printf(\"-1\\n\");\n            return 0;\n        }\n        y = mp[tmp], g[y].push_back(x), siz[y] += siz[x];\n    }\n    \n    if (dfs(ind[n]) == d[ind[n]])\n        for (x = 1; x <= n; ++x)\n            for (int y : g[x])\n                printf(\"%d %d\\n\", x, y);\n    else\n        printf(\"-1\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<math.h>\n#include<stdlib.h>\n#include<set>\n#include<bitset>\n#include<map>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<complex>\n#include<list>\n#include<limits.h>\nusing namespace std;\n\nconst int N=1e5+5;\ntypedef pair<int,int> pii;\nint n;\npair<long long,int> a[N];\nint sz[N];\nlong long dp[N];\nvector<pii> vp;\nmap<long long,int> mp;\n\nvoid lnk(int x,int y){\n\tvp.push_back(make_pair(x,y));\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%I64d\",&a[i].first);\n\t\ta[i].second=i;\n\t}\n\tsort(a+1,a+1+n);\n\treverse(a+1,a+1+n);\n\tfor(int i=1;i<=n;i++) mp[a[i].first]=i;\n\tfor(int i=1;i<=n;i++) sz[i]=1;\n\tfor(int i=1;i<n;i++){\n\t\tint nxt=mp[a[i].first-1ll*n+2ll*sz[i]];\n//\t\tprintf(\"%d %d\\n\",i,nxt);\n\t\tdp[nxt]+=dp[i]+1ll*sz[i];\n//\t\tprintf(\" %lld %lld %d\\n\",dp[i],dp[nxt],sz[i]);\n\t\tsz[nxt]+=sz[i];\n\t\tlnk(a[i].second,a[nxt].second);\n\t}\n\tif(vp.size()!=n-1||dp[n]!=a[n].first) puts(\"-1\");\n\telse for(int i=0;i<vp.size();i++) printf(\"%d %d\\n\",vp[i].first,vp[i].second);\n\treturn 0;\n}\n\n/*\n数据不清空，爆零两行泪\n读题不认真，爆零两行泪\n分析不仔细，爆零两行泪\n建树不构造，爆零两行泪\n变量不统一，爆零两行泪\n边界不算清，爆零两行泪\n数组不开大，爆零两行泪\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef bool boolean;\n\nconst int N = 1e5 + 5;\n\n#define ll long long\n#define par pair<ll, int>\n\nint n;\npar a[N];\nint Fa[N];\nint sz[N], uf[N], d[N];\nvector<pair<int, int>> E;\n\nint find(int x) {\n\treturn uf[x] == x ? x : (uf[x] = find(uf[x]));\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &a[i].first);\n\t\ta[i].second = i;\n\t\tsz[i] = 1;\n\t\tuf[i] = i;\n\t}\n\tsort(a + 1, a + n + 1);\n\tfor (int i = n; i > 1; i--) {\n\t\tll d = a[i].first;\n\t\tint p = a[i].second;\n\t\tint fa = lower_bound(a + 1, a + n + 1, par(d - n + (sz[p] << 1), 0)) - a;\n\t\tif (a[fa].first != d - n + (sz[p] << 1)) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (find(p) == find(fa = a[fa].second)) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsz[fa] += sz[p];\n\t\tE.emplace_back(p, fa);\n\t\tFa[p] = fa;\n\t}\n\tll f1 = 0;\n\tfor (int i = 2; i <= n; i++)\n\t\tf1 += (d[a[i].second] = d[Fa[a[i].second]] + 1);\n\tif (f1 ^ a[1].first) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (auto x : E)\n\t\tprintf(\"%d %d\\n\", x.first, x.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Zory-2018\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n#include<set>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<bitset>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nnamespace mine\n{\n\ttypedef long long ll;\n\tconst int INF=0x3f3f3f3f;\n\n\tconst int MAX_N=110000;\n\tstruct Nod\n\t{\n\t\tll d;int p,siz;\n\t\tfriend bool operator < (Nod a,Nod b) {return a.d<b.d;}\n\t}p[MAX_N];\n\n\t#define PR pair<int,int>\n\tvector<PR> ans;\n\tvoid main()\n\t{\n\t\tint n;scanf(\"%d\",&n);\n\t\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&p[i].d),p[i].p=i,p[i].siz=1;\n\t\tsort(p+1,p+n+1);\n\n\t\tfor(int i=n;i>=2;i--)\n\t\t{\n\t\t\tll want=p[i].d-n+2*p[i].siz;\n\t\t\tint fa=lower_bound(p+1,p+n+1,(Nod){want,0,0})-p;\n\t\t\t//printf(\"i=%d p[i].siz=%d want=%lld fa=%d p[fa].d=%lld\\n\",p[i].p,p[i].siz,want,p[fa].p,p[fa].d);\n\t\t\tif(p[fa].d!=want) {puts(\"-1\");return;}\n\t\t\tans.push_back( make_pair(p[i].p,p[fa].p) );p[fa].siz+=p[i].siz;\n\t\t}\n\n\t\tfor(int i=0;i<(int)ans.size();i++) printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\t}\n}\nint main()\n{\n\tmine::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <long long, long long> pii;\n\nconst long long MAX_N = 1e5 + 5;\nlong long n, root;\nlong long Arr[MAX_N];\nlong long h[MAX_N];\nlong long Siz[MAX_N];\nlong long Mark[MAX_N];\nlong long par[MAX_N];\nunordered_map <long long, long long> Map;\nvector <pii> edge;\nlong long dp_d[MAX_N];\nlong long dp_u[MAX_N];\nvector <long long> child[MAX_N];\n\nbool cmp(long long a, long long b) {\n\treturn Arr[b] < Arr[a];\n}\n\nvoid dfs1(long long v) {\n\tfor (long long i = 0; i < child[v].size(); i++) {\n\t\tdfs1(child[v][i]);\n\t\tdp_d[v] += dp_d[child[v][i]] + Siz[child[v][i]];\n\t}\n}\n\nvoid dfs2(long long v, long long val) {\n\tdp_u[v] = val;\n\tfor (long long i = 0; i < child[v].size(); i++)\n\t\tdfs2(child[v][i], dp_d[v] - dp_d[child[v][i]] - Siz[child[v][i]] + dp_u[v] + (n - Siz[child[v][i]]));\n}\n\nint main() {\n\tios::sync_with_stdio(false), cout.tie(0), cin.tie(0);\n\tcin >> n;\n\tfor (long long i = 0; i < n; i++) {\n\t\tcin >> Arr[i];\n\t\tSiz[i] = 1;\n\t\th[i] = i;\n\t\tMap[Arr[i]] = i;\n\t}\n\t\t\n\tsort(h, h + n, cmp);\n\t\n\tfor (long long i = 0; i + 1 < n; i++) {\n\t\tlong long v = h[i];\n\t\tlong long tmp = Arr[v] + Siz[v] - (n - Siz[v]);\n\n\t\tif (tmp < 0 || (Map[tmp] == 0 && Arr[0] != tmp)) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tlong long u = Map[tmp];\n\t\t/*if (Mark[u]) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}*/\n\t\t\n\t\tSiz[u] += Siz[v];\n\t\tpar[v] = u;\n\t\tedge.push_back({v, u});\n\t\tchild[u].push_back(v);\n\t\tif (n < 2LL * Siz[v]) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t//Mark[v] = true;\n\t}\n\troot = h[n - 1];\n\tdfs1(root);\n\t//dfs2(root, 0);\n\t\n\tfor (long long i = root; i < root + 1; i++)\n\t\tif (dp_d[i] + dp_u[i] != Arr[i]) {\n\t\t\tcout << i << \" \" << dp_d[i] + dp_u[i] << \"\\n\";\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\n\tfor (long long i = 0; i + 1 < n; i++)\n\t\tcout << edge[i].first + 1 << \" \" << edge[i].second + 1 << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\ntypedef long long lint;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef unsigned long long ulint;\n#define endl '\\n'\n#define fst first\n#define sed second\n#define pb push_back\n#define mp make_pair\n#define rint register int\n#define newline putchar('\\n')\n#define leave_space putchar(' ')\n#define all(x) (x).begin(), (x).end()\n#define reveal(x) cerr << #x << \" = \" << (x) << endl\n#define rep(it, f, e) for (rint it = (f); it <= (e); ++it)\n#define per(it, f, e) for (rint it = (f); it >= (e); --it)\nconst int MAXN = 1e5 + 10;\npll p[MAXN];\nint sz[MAXN];\nmap<lint, int> rec;\n#define D fst\n#define P sed\nvector<pii> opt;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL), cout.tie(NULL);\n\tint n;\n\tcin >> n;\n\trep (i, 1, n) {\n\t\tcin >> p[i].D;\n\t\tp[i].P = i;\n\t\trec[p[i].D] = p[i].P;\n\t}\n\tsort(p + 1, p + n + 1, greater<pll>());\n\tfill(sz + 1, sz + n + 1, 1);\n\trep (i, 1, n - 1) {\n\t\tint u = p[i].P;\n\t\tif (n - sz[u] - sz[u] <= 0) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t} \n\t\tlint diff = p[i].D - (n - sz[u] - sz[u]);\n\t\tif (rec.find(diff) == rec.end()) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint v = rec[diff];\n\t\topt.pb(pii(u, v));\n\t\tsz[v] += sz[u];\n\t}\n\tfor (auto &v : opt) {\n\t\tif (v.fst > v.sed) swap(v.fst, v.sed);\n\t}\n\tsort(all(opt));\n\tfor (auto &v : opt) {\n\t\tcout << v.fst << ' ' << v.sed << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define inf 0x3f3f3f3f3f3f3f3f\n#define inf 0x3f3f3f3f\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define inv(x) Power(x, mod - 2)\n#define fi first\n#define se second\n#define MP make_pair\n#define PB push_back\n\ntypedef std::vector<int> Poly;\ntypedef std::pair<int,int> Pair;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef long long ll;\n\nconst int maxn = 100000, maxm = 2000, MAX = 1e6 + 5, mod = 1000000;\n//template{{{\nconst long double Pi = 3.14159265358979323846l, Eps = 1e-4;\ntemplate <class T> inline bool equal(T x, T y) { return fabs(x - y) < Eps; }\ninline int add(int x, int y) { x += y; return x >= mod ? x - mod : x; };\ninline void inc(int &x, int y) { x += y; x -= (x >= mod ? mod : 0); }\ninline int mul(int x, int y) { return 1ll * x * y % mod; }\ninline int Power(int x, int y, int Mod = mod) {\n\tint ans = 1;\n\twhile (y) {\n\t\tif (y & 1) ans = (ll) ans * x % Mod;\n\t\tx = (ll) x * x % Mod, y >>= 1;\n\t} return ans;\n}\n\n/*char buf[1<<23],obuf[1<<23],*p1=buf,*p2=buf, *O = obuf;\n#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\nvoid print(int x) {\n    if(x > 9) print(x / 10);\n    *O++=x%10+'0';\n} */\n\ntemplate <class T> inline T\tinput() {\n\tT x; char ch; bool flag = false;\n\twhile (!isdigit(ch = getchar())) flag |= ch == '-';\n\tfor (x = ch ^ 48; isdigit(ch = getchar()); x = x * 10 + (ch ^ 48));\n\treturn flag ? -x : x;\n}\n\ntemplate <class T> inline bool chkmin(T &x, T y) { x = x < y ? x : y; return x == y; }\ntemplate <class T> inline bool chkmax(T &x, T y) { x = x > y ? x : y; return x == y; }\ntemplate <class T> inline T gcd(T x, T y) { return !y ? x : gcd(y, x % y); }\ntemplate <class T> inline T sqrm(T x) { return (ll) x * x % mod; }\ntemplate <class T> inline T sqr(T x) { return x * x; }\n\nstruct {\n\tinline operator int () { return input<int>(); }\n\tinline operator long long () { return input<long long>(); }\n\ttemplate <class T> inline void operator () (T &x) { x = *this; }\n\ttemplate<class T, class ...A> inline void operator () (T &x, A &...a)\n\t{ x = *this; this -> operator ()(a...); }\n} read; //}}}\n\nint n;\nll d[maxn + 5];\nint size[maxn + 5];\nstd::map<ll, int> id;\nstd::pair<ll, int> p[maxn + 5];\nstd::vector<int> T[maxn + 5];\nint fa[maxn + 5];\n\nll distance;\n\nvoid dfs(int u, ll dis) {\n\tdistance += dis;\n\tfor (int v : T[u])\n\t\tdfs(v, dis + 1);\n}\n\nbool check() {\n\tdfs(1, 0);\n\treturn distance == d[1];\n}\n\nsigned main() {\n#ifdef local\n\tfreopen(\"in\", \"r\", stdin);\n\tfreopen(\"out\", \"w\", stdout);\n\tfreopen(\"log\", \"w\", stderr);\n#endif\n\n\tn = read;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tp[i].fi = d[i] = read;\n\t\tp[i].se = id[d[i]] = i;\n\t\tsize[i] = 1;\n\t}\n\n\tstd::sort(p + 1, p + n + 1);\n\tfor (int i = n; i > 1; --i) {\n\t\tll df = p[i].fi - n + size[p[i].se] * 2;\n\t\tif (df >= p[i].fi) return puts(\"-1\"), 0;\n\t\tfa[p[i].se] = id[df], size[fa[p[i].se]] += size[p[i].se];\n\t\tif (!fa[p[i].se]) return puts(\"-1\"), 0;\n\t\tT[fa[p[i].se]].push_back(p[i].se);\n\t}\n\n\tif (!check()) return puts(\"-1\"), 0;\n\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (fa[i]) printf(\"%d %d\\n\", i, fa[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <utility>\n#include <cstdio>\n#include <map>\nusing ll = long long;\nint fa[100005], sz[100005];\nll arr[100005], val[100005];\nstd::pair<ll, int> app[100005];\nstd::map<ll, int> idx;\nint main()\n{\n\t// freopen(\"ARC103-F.in\", \"r\", stdin);\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%lld\", arr + i);\n\t\tidx[arr[i]] = i;\n\t\tapp[i] = {arr[i], i};\n\t\tsz[i] = 1;\n\t}\n\tstd::sort(app, app + n);\n\tfor (int i = n - 1; i; i--)\n\t{\n\t\tint u = app[i].second;\n\t\tll dt = n - sz[u] * 2;\n\t\tif (dt <= 0 || !idx.count(arr[u] - dt))\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tfa[u] = idx[arr[u] - dt];\n\t\tsz[fa[u]] += sz[u];\n\t\tval[fa[u]] += val[u] + sz[u];\n\t}\n\tif (val[app[0].second] != arr[app[0].second])\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = n - 1; i; i--)\n\t{\n\t\tint u = app[i].second;\n\t\tprintf(\"%d %d\\n\", fa[u] + 1, u + 1);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+5;\nmap<long long,int>ma;\nlong long a[N];\nint n,b[N],si[N],fa[N];\nbool com(int x,int y){\n\treturn a[x]>a[y];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i]);\n\t\tma[a[i]]=b[i]=i;\n\t}\n\tsort(b+1,b+n+1,com);\n\tfor(int i=1;i<=n;i++)\tsi[i]=1;\n\tfor(int i=1;i<n;i++){\n\t\tint k=ma[a[b[i]]-n+si[b[i]]*2];\n\t\tfa[b[i]]=k,si[k]+=si[b[i]];\n\t\tif(!k||k==b[i]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d %d\\n\",b[i],fa[b[i]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pii_ pair<int,int>\n#define mp_ make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define show1(a) cout<<#a<<\" = \"<<a<<endl\n#define show2(a,b) cout<<#a<<\" = \"<<a<<\"; \"<<#b<<\" = \"<<b<<endl\nusing namespace std;\nconst ll INF = 1LL<<60;\nconst int inf = 1<<30;\nconst int maxn = 1e5+5;\ninline void fastio() {ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);}\nvoid GG()\n{\n    cout<<-1<<endl;\n    exit(0);\n}\nint n,sz[maxn];\nll dis[maxn];\nstruct node\n{\n    int id;\n    ll d;\n    bool operator < (const node e) const {\n        return d>e.d;\n    }\n}tr[maxn];\nvector<pii_> e;\nvector<int> g[maxn];\nvoid dfs(int u)\n{\n    for(int v:g[u]){\n        dfs(v);\n        dis[u] += dis[v]+sz[v];\n    }\n}\nvoid dfs2(int u){\n    for(int v:g[u]){\n        dis[v] = dis[u]+n-2*sz[v];\n        dfs2(v);\n    }\n}\nint main()\n{\n    fastio();\n    cin>>n;\n    rep(i,1,n){\n        cin>>tr[i].d; tr[i].id = i;\n    }\n    sort(tr+1,tr+n+1);\n    rep(i,1,n) sz[i] = 1;\n    rep(i,1,n-1){\n        ll dfa = tr[i].d+2*sz[tr[i].id]-n;\n        int pos = lower_bound(tr+1,tr+n+1,(node){0,dfa})-tr;\n        if(pos<1 || pos>n) GG(); // 找不到父节点\n        node fa = tr[pos];\n        if(fa.d!=dfa || fa.id==tr[i].id) GG();    // 找不到父节点\n        sz[fa.id] += sz[tr[i].id];\n        if(fa.id!=tr[n].id && sz[fa.id]>n/2) GG();   // 以重心为根，其他节点的子树大小不能超过n的一半\n        e.pb(mp_(tr[i].id,fa.id));\n        g[fa.id].pb(tr[i].id);\n    }\n    if(e.size()!=n-1) GG();\n    //dfs(tr[n].id);\n    //dfs2(tr[n].id);\n    //rep(i,1,n){\n    //    if(tr[i].d != dis[tr[i].id]) GG();\n    //}\n    for(auto x:e){\n        cout<<x.fi<<\" \"<<x.se<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fail return (cout << -1 << endl), 0\n#define ll long long\n\nusing namespace std;\n\nint n;\nmap<ll, int> f;\nll dis[100010], rdis[100010];\nint sz[100010];\n\nstruct Edge {\n\tint to, next;\n}es[200010];\nint first[100010], te = 0;\n\nvoid addE(int a, int b)\n{\n\tte++;\n\tes[te].to = b;\n\tes[te].next = first[a];\n\tfirst[a] = te; \n}\n\nvoid dfs(int p, int fa)\n{\n\tif (p != 1) rdis[p] = rdis[fa] + 1;\n\tfor (int e = first[p]; e; e = es[e].next)\n\t{\n\t\tint to = es[e].to;\n\t\tif (to == fa) continue;\n\t\tdfs(to, p); \n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tcin >> dis[i];\n\t\tf[dis[i]] = i;\n\t\tsz[i] = 1;\n\t}\n\tint cnt = 0;\n\tfor (map<ll, int>::reverse_iterator it = f.rbegin(); it != f.rend(); it++)\n\t{\n\t\tint v = it->second, u = f[it->first + 2 * sz[v] - n];\n\t\tif (!u || u == v) fail;\n\t\taddE(u, v); addE(v, u);\n\t\tsz[u] += sz[v];\n\t\tif (++cnt == n - 1) break;\n\t}\n\tdfs(1, 0);\n\tll sum = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tsum += rdis[i];\n\tif (sum != dis[1]) fail;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int e = first[i]; e; e = es[e].next)\n\t\t{\n\t\t\tif (e & 1) continue;\n\t\t\tcout << i << ' ' << es[e].to << endl;\n\t\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\")\n#include <bits/stdc++.h>\n#define owo(i,a, b) for(int i=(a);i<(b); ++i)\n#define uwu(i,a, b) for(int i=(a)-1; i>=(b); --i)\n#define senpai push_back\n#define ttgl pair<int, int>\n#define ayaya cout<<\"ayaya~\"<<endl\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#define ordered_set tree<ttgl, null_type,less<ttgl>, rb_tree_tag,tree_order_statistics_node_update>*/\n \nusing ll = long long;\nusing ld = long double;\nconst ll MOD = 1000000007;\nconst ll root = 62;\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nll binpow(ll a,ll b){ll res=1;while(b){if(b&1)res=(res*a)%MOD;a=(a*a)%MOD;b>>=1;}return res;}\nll modInv(ll a){return binpow(a, MOD-2);}\nconst double PI = acos(-1);\nconst double eps = 1e-6;\nconst int INF = 0x3f3f3f3f;\nconst int NINF = 0xc0c0c0c0;\nconst ll INFLL = 0x3f3f3f3f3f3f3f3f;\nconst ll NINFLL = 0xc0c0c0c0c0c0c0c0;\nconst int mxN = 100001;\nll arr[mxN];\nmap<ll, int> mp;\nint sz[mxN];\nvector<ttgl> ans;\nvector<int> adj[mxN];\nint par[mxN];\nint n;\nbool flag[mxN];\nbool istree() {\n    queue<int> Q;\n    Q.push(mp[arr[0]]);\n    flag[mp[arr[0]]] = true;\n    while(!Q.empty()) {\n        int u = Q.front();\n        Q.pop();\n        for(int v: adj[u]) {\n            if(flag[v])return false;\n            Q.push(v);\n            flag[v] = true;\n        }\n    }   \n    owo(i, 0, n) {\n        if(!flag[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    //freopen(\"file.in\", \"r\", stdin);\n    //freopen(\"file.out\", \"w\", stdout);\n    mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n    cin.tie(0)->sync_with_stdio(0);\n    cin>>n;\n    owo(i, 0, n) {\n        cin>>arr[i];\n        mp[arr[i]] = i;\n    }\n    sort(arr, arr+n);\n    uwu(i, n, 1) {\n        int u = mp[arr[i]];\n        sz[u]++;\n        ll k = arr[i] + 2*sz[u] - n;\n        if(mp.count(k)) {\n            int v = mp[k];\n            par[u] = v;\n            adj[v].senpai(u);\n            ans.senpai({u, v});\n            sz[v]+=sz[u];\n        }else {\n            cout<<\"-1\\n\";\n            exit(0);\n        }\n    }\n    if(istree()) {\n        for(auto p: ans) {\n            cout<<(p.first+1)<<\" \"<<(p.second+1)<<\"\\n\";\n        }\n    }else {\n        cout<<\"-1\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxN = 1e5 + 10;\nlong long d[maxN];\nint n;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i) cin >> d[i];\n\tmultiset<pair<long long, int>> points;\n\tfor (int i = 1; i <= n; ++i) points.insert({d[i], i});\t\n\tbool fun = 1;\n\tauto root = points.begin();\n\tpoints.erase(points.begin());\n\tvector<pair<int, int>> edges;\n\twhile (not points.empty()) {\n\t\tauto q = points.begin();\n\t\tpoints.erase(q);\n\t\tfun &= (root->first - q->first + n) % 2 == 0;\n\t\tlong long sz = (root->first - q->first + n) / 2; \n\t\tfun &= sz < n;\n\t\tif (not fun) break;\n\t\tedges.push_back({root->second, q->second});\n\t\tlong long temp_d = q->first;\n\t\tint last = q->second;\n\t\tfor (int i = sz-1; i >= 1; --i) {\n\t\t\tlong long cur_d = temp_d + n - 2 * i;\n\t\t\tauto u = points.lower_bound({cur_d, -1});\n\t\t\tpoints.erase(u);\n\t\t\tfun &= cur_d == u->first;\n\t\t\tif (not fun) break;\t\n\t\t\tedges.push_back({last, u->second});\n\t\t\ttemp_d = cur_d;\n\t\t\tlast = u->second;\n\t\t}\n\t\tif (not fun) break;\n\t}\n\tif (fun) {\n\t\tfor (auto e : edges) {\n\t\t\tcout << e.first << \" \" << e.second << endl;\n\t\t}\n\t} else puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define forab(i, a, b) for(int i=(a);i<(b);++i)\n#define foreach(i, n) for (__typeof(n.begin()) i = n.begin(); i != n.end(); ++i)\n#define sqr(x) ((x)*(x))\n#define clr(a, b) memset(a, b, sizeof(a))\n#define MP make_pair\n#define PB push_back\n#define SZ(a) ((int)a.size())\n#define all(a) (a).begin(),(a).end()\n#define inf 0x3f3f3f3f\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst double eps = 1e-8;\nint dcmp(double x) { if (x < -eps) return -1; else return x > eps;}\n#define se(x) cout<<#x<<\" = \"<<x<<endl\n\n#ifdef CHEN_PC\n#define debug(...) printf(__VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\nconst int N = 100010;\nconst int mod = 1000000007; // 10^9+7\nint n;\nll d[N];\nint pnt[N];\nint cnt[N];\nmap<ll, int> dic;\n\nint solve() {\n    dic.clear();\n\tsort(d, d + n);\n\tforn (i, n) {\n\t\tpnt[i] = -1;\n\t\tcnt[i] = 1;\n\t\tdic[ d[i] ] = i;\n\t}\n\tfor (int i = n - 1; i > 0; --i) {\n\t\tint delta = n - cnt[i] * 2;\n\t\tll val = d[i] - delta;\n\t\tif (delta == 0 || dic.find(val) == dic.end()) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tpnt[i] = dic[val];\n\t\tcnt[ pnt[i] ] += cnt[i];\n\t}\n\tforn (i, n) {\n\t\tif (pnt[i] == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\tprintf(\"%d %d\\n\", pnt[i] + 1, i + 1);\n\t}\n\treturn 1;\n}\n\nint main(int argc, char *argv[]) {\n#ifdef CHEN_PC\n\tfreopen(\"F.in\", \"r\", stdin);\n#endif\n\n\twhile (scanf(\"%d\", &n) != EOF) {\n\t\tforn (i, n) {\n\t\t\tscanf(\"%lld\", d + i);\n\t\t}\n\t\tint ret = solve();\n//\t\tprintf(\"%d\\n\", ret);\n\n#ifdef CHEN_PC\n        puts(\"\");\n#endif\n\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <cmath>\n#include <bitset>\n#include <algorithm>\n#include <map>\n#include <vector>\ntypedef long long ll;\nusing namespace std;\nconst int maxn=101000;\nint n;\nll d[maxn];\nint size[maxn];\nll dis[maxn];\nmap<ll,int> mp;\nvector<int> G[maxn];\nll sum=0;\n\nvoid dfs1(int u,int fa){\n    for(int i=0;i<G[u].size();i++){\n        int v=G[u][i];\n        if(v==fa) continue;\n        dis[v]=dis[u]+1;\n        dfs1(v,u);\n    }\n    sum+=dis[u];\n}\n\nvoid dfs2(int u,int fa){\n    for(int i=0;i<G[u].size();i++){\n        int v=G[u][i];\n        if(v==fa) continue;\n        printf(\"%d %d\\n\",u,v);\n        dfs2(v,u);\n    }\n}\n\nint main(){\n    //初始化\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        scanf(\"%lld\",&d[i]);\n        mp[d[i]]=i;\n    }\n    sort(d+1,d+n+1);\n    for(int i=1;i<=n;i++) size[i]=1;\n    //构树\n    for(int i=n;i>=1;i--){\n        int k=mp[d[i]];\n        int tmp=n-2*size[k];\n        if(tmp<=0) {printf(\"-1\");return 0;}\n        ll ss=d[i]+tmp;\n        if(mp.count(ss)==0){printf(\"-1\\n\");return 0;}\n        int pos=mp[ss];\n        size[pos]+=size[k];\n        G[pos].push_back(k);\n        G[k].push_back(pos);\n    }\n    dis[mp[d[1]]]=0;\n    dfs1(mp[d[1]],-1);\n    if(sum!=d[1]){\n        printf(\"-1\\n\");\n    }else{\n        dfs2(1,-1);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <utility>\n#include <algorithm>\n#include <map>\n\nint t1,t2;\n\nint n;\nstd::pair<long long,int> d[100005];\nstd::map<long long,int> m;\nbool vis[100005];\n\nstd::vector<std::pair<int,int> > out;\n\nlong long base=0;\n\nint main()\n{\n    #ifdef NOT_DMOJ\n    freopen(\"data.txt\",\"r\",stdin);\n    #endif // NOT_DMOJ\n    scanf(\"%d\",&n);\n    for (int i=0; i<n; i++) {\n        scanf(\"%lld\",&d[i].first);\n        d[i].second=i+1;\n        m[d[i].first]=i+1;\n    }\n    std::sort(d,d+n);\n    int centroid=d[0].second;\n    vis[0]=1;\n    while (1) {\n        long long hi=0;\n        for (int i=0; i<n; i++) {\n            if (vis[d[i].second]) continue;\n            if (hi<d[i].first) hi=d[i].first;\n        }\n        if (hi==0) break;\n        int dist=0;\n        while (hi>d[0].first) {\n            t1=m[hi];\n            vis[t1]=1;\n            dist++;\n            hi-=n-2*dist;\n            if (!m.count(hi)) {\n                printf(\"-1\\n\");\n                return 0;\n            }\n            t2=m[hi];\n            vis[t2]=1;\n            out.push_back({t1,t2});\n        }\n        if (hi<d[0].first) {\n            printf(\"-1\\n\");\n            return 0;\n        }\n        base+=(dist*(long long)(dist+1))/2;\n    }\n    if (base!=d[0].first) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n    for (auto &p:out) printf(\"%d %d\\n\",p.first,p.second);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define N 100100\n\nll n,cnt;\nll d[N];\nset<pair<ll,ll> > S;\nll sz[N],u[N],v[N];\nset<pair<ll,ll> >::iterator it,it2;\n\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tfor (ll i=1;i<=n;i++) {\n\t\tscanf(\"%lld\",&d[i]);\n\t\tS.insert(mp(d[i],i));\n\t\tsz[i]=1;\n\t}\n\t\n\tfor (ll i=1;i<n;i++)\n\t{\n\t\tit=S.end(); it--;\n\t\tll now=(*it).second,num=sz[now];\n\t\tS.erase(it);\n\t\tif (n-2*num<0) return puts(\"-1\"),0;\n\t\tit2=S.lower_bound(mp(d[now]-(n-2*num),0));\n\t\tif (it2==S.end() || (*it2).first!=d[now]-(n-2*num)) return puts(\"-1\"),0;\n\t\tu[++cnt]=now; v[cnt]=(*it2).second;\n\t\tsz[(*it2).second]+=num;\n\t}\n\tfor (ll i=1;i<=cnt;i++) printf(\"%lld %lld\\n\",u[i],v[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Link : https://atcoder.jp/contests/arc101/tasks/arc101_c\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define N 100005\n\nvector<int> adj[N];\nll d[N];\npair<ll,int> in[N];\nint sz[N];\n\nint dsz[N];\nll dd[N];\n\nvoid dfs(int node) {\n  dsz[node] = 1;\n  for(int ch : adj[node]) {\n    dfs(ch);\n    dsz[node] += dsz[ch];\n    dd[node] += dd[ch] + dsz[ch];\n  }\n}\n\nbool dfs2(int node,ll tmp,int n) {\n  if(tmp!=d[node]) {\n    return false;\n  }\n  for(int ch : adj[node]) {\n    if(!dfs2(ch,tmp + n - dsz[ch]*2,n)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nvoid solve() {\n  int n;scanf(\"%d \", &n);\n  set<pair<ll,int> >s;\n  ll sum = 0;\n  for(int i=1;i<=n;++i) {\n    scanf(\"%lld \", &in[i].first);\n    d[i] = in[i].first;\n    in[i].second = i;\n    sz[i] = 1;\n    s.insert(in[i]);\n    sum += d[i];\n  }\n  if(sum%2==1) {\n    printf(\"-1\\n\");\n    return;\n  }\n  sort(in+1,in+n+1);\n  int pos = n;\n\n  while(s.size()>1) {\n    pair<ll,int> tmp = *prev(s.end());\n    s.erase(prev(s.end()));\n    ll dist = tmp.first;\n    int node = tmp.second;\n    pair<ll,int> tmp2 = make_pair(dist - n + sz[node]*2,0);\n    set<pair<ll,int> >::iterator it = s.lower_bound(tmp2);\n    if(it==s.end() || (*it).first!=tmp2.first) {\n      printf(\"-1\\n\");\n      return;\n    }\n    int x = (*it).second;\n    sz[x] += sz[node];\n    adj[x].push_back(node);\n  }\n  int root = in[1].second;\n  dfs(root);\n  if(!dfs2(root,dd[root],n)) {\n    printf(\"-1\\n\" );\n    return;\n  }\n  for(int i=1;i<=n;++i) {\n    for(int ch : adj[i]) {\n      printf(\"%d %d\\n\", i,ch);\n    }\n  }\n}\n\nint main() {\n    //freopen(\"input.txt\",\"r\",stdin);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 100010\n#define ll long long\nusing namespace std;\n\nint size[maxn],n,cnt,head[maxn],d[maxn];\n\nll dist[maxn];\n\nmap < ll , ll > id;\n\nstruct E{\n\tint to,nxt,fr;\n}edge[maxn<<1];\n\ninline void add(int u,int v){edge[++cnt]=(E){v,head[u],u};head[u]=cnt;}\n\ntemplate <class T>\nvoid read(T &x){\n\tchar s=getchar();x=0;\n\twhile(s<'0'||s>'9') s=getchar();\n\twhile(s>='0'&&s<='9') x=(x<<3)+(x<<1)+s-'0',s=getchar();\n}\n\nvoid dfs(int u){\n\tfor(int i=head[u];i;i=edge[i].nxt){\n\t\tint v=edge[i].to;\n\t\td[v]=d[u]+1;\n\t\tdfs(v);\n\t}\n}\n\nbool check(){\n\tint sum=0;\n\tfor(int i=1;i<=n;i++) sum+=d[i];\n\treturn dist[1]==sum;\n}\n\nint main(){\n\tread(n);\n\tfor(int i=1;i<=n;i++) read(dist[i]),id[dist[i]]=i,size[i]=1;\n\tsort(dist+1,dist+n+1);\n\tfor(int i=n;i>1;i--){\n\t\tint fa,u=id[dist[i]];\n\t\tll tmp1=n-size[u]*2;\n\t\tif(tmp1<=0) return printf(\"-1\"),0;\n\t\tll tmp2=dist[i]-tmp1;\n\t\tif(id.count(tmp2)==0) return printf(\"-1\"),0;\n\t\tfa=id[tmp2];\n\t\tadd(fa,u);\n\t\tsize[fa]+=size[u];\n\t}\n\tdfs(id[dist[1]]);\n\tif(check()){\n\t\tfor(int i=1;i<n;i++) printf(\"%d %d\\n\",edge[i].fr,edge[i].to);\n\t\treturn 0;\n\t}\n\tprintf(\"-1\"),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN=3e5+7;\n\nll from[MAXN],to[MAXN];\n\nmap<ll,ll> Map;\n\nll n;\nll a[MAXN],b[MAXN],siz[MAXN],sum[MAXN];\n\nbool cmp(const ll &A,const ll &B){return a[A]>a[B];}\nbool cmp2(const ll &A,const ll &B){return A>B;}\n\nll minn1=1e18,minn2;\n\nint main() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) {\n\t\tcin>>a[i];\n\t\tb[i]=i;\n\t\tMap[a[i]]=i;\n\t\tsiz[i]=1;\n\t\tif(minn1>a[i]) {\n\t\t\tminn1=a[i];\n\t\t\tminn2=i;\n\t\t}\n\t}\n\tsort(b+1,b+1+n,cmp);\n\tsort(a+1,a+1+n,cmp2);\n\tfor(ll i=1,i2;i<n;i++) {\n\t\ti2=Map[a[i]-abs(n-2*siz[b[i]])];\n\t\tif(i2!=0&&a[i]-abs(n-2*siz[b[i]])!=a[i]) {\n\t\t\tsiz[i2]+=siz[b[i]];\n\t\t\tsum[i2]+=sum[b[i]]+siz[b[i]];\n\t\t\tfrom[i]=i2;\n\t\t\tto[i]=b[i];\n\t\t}\n\t\telse {\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif(minn1!=sum[minn2]) {\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<n;i++) {\n\t\tcout<<from[i]<<\" \"<<to[i]<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <utility>\n#define FR first\n#define SE second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,int> pr;\n\npr a[100005];\nmap <ll,int> mp;\n\nint size[100005],p[100005],n;\nll num[100005];\n\nstruct Edge {\n  int t,next;\n  Edge() {}\n  Edge(int a,int b):t(a),next(b) {}\n};\n\nEdge e[200005];\nint head[100005];\n\nll up[100005],down[100005];\nint sz[100005];\n\nvoid dfs1(int x,int fa) {\n  sz[x]=1;\n  for(int i=head[x];i;i=e[i].next)\n    if (e[i].t!=fa) {\n    \tint u=e[i].t;\n    \tdfs1(u,x);\n    \tdown[x]+=down[u]+sz[u];\n    \tsz[x]+=sz[u];\n\t}\n}\n\nvoid dfs2(int x,int fa) {\n  ll s=up[x];\n  for(int i=head[x];i;i=e[i].next)\n    if (e[i].t!=fa) s+=down[e[i].t]+sz[e[i].t];\n  for(int i=head[x];i;i=e[i].next)\n    if (e[i].t!=fa) {\n    \tint u=e[i].t;\n    \tup[u]=s-down[u]-sz[u]+n-sz[u];\n    \tdfs2(u,x);\n\t}\n}\n\nint main() {\n  scanf(\"%d\",&n);\n  for(int i=1;i<=n;i++) {\n  \tll x;\n  \tscanf(\"%lld\",&x);\n  \ta[i]=pr(x,i);\n  \tmp[x]=i;\n  \tnum[i]=x;\n  }\n  sort(a+1,a+n+1);\n  for(int i=n;i>1;i--) {\n  \tint x=a[i].SE;\n  \tsize[x]++;\n  \tif (n-2*size[x]<=0) {\n  \t\tputs(\"-1\");\n  \t\treturn 0;\n\t  }\n\tll t=a[i].FR-(n-2*size[x]);\n\tif (!mp.count(t)) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tp[x]=mp[t];\n\tsize[p[x]]+=size[x];\n\te[2*i-1]=Edge(x,head[p[x]]);\n\thead[p[x]]=2*i-1;\n\te[2*i]=Edge(p[x],head[x]);\n\thead[x]=2*i;\n  }\n  dfs1(1,0);\n  dfs2(1,0);\n  for(int i=1;i<=n;i++)\n    if (up[i]+down[i]!=num[i]) {\n    \tputs(\"-1\");\n    \treturn 0;\n\t}\n  for(int i=1;i<=n;i++)\n    if (p[i]) printf(\"%d %d\\n\",p[i],i);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,size[100010],fa[100010],tmp=0,cnt=0,s[100010],Un_f=0,head[100010],o=0,hd,dis[100010],si[100010];\nlong long d[100010],g[100010];\nmap<long long,int>ma;\nstruct node{\n\tlong long w;\n\tint id;\n\tbool operator <(const node &b)const{\n\t\treturn w<b.w;\n\t}\n};\nstruct edge{\n\tint to,link;\n}e[400010];\nvoid add_edge(int u,int v){\n\te[++o].to=v,e[o].link=head[u],head[u]=o;\n\te[++o].to=u,e[o].link=head[v],head[v]=o;\n}\npriority_queue<node>q;\nvoid dfs(int u,int pre){\n\tsi[u]=1;\n\tfor(int i=head[u];i;i=e[i].link){\n\t\tif(e[i].to==pre) continue;\n\t\tdis[e[i].to]=dis[u]+1;\n\t\tdfs(e[i].to,u);\n\t\tsi[e[i].to]+=si[u];\n\t}\n}\nvoid work(int u,int pre){\n\tif(g[u]!=d[u]){\n\t\tprintf(\"-1\\n\");\n\t\texit(0);\n\t}\n\tfor(int i=head[u];i;i=e[i].link){\n\t\tif(e[i].to==pre) continue;\n\t\tg[e[i].to]=g[u]+n-si[e[i].to]*2;\n\t\tdfs(e[i].to,u);\n\t}\n}\nint main(){\n\tma.clear();\n\twhile(q.size()) q.pop();\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&d[i]);\n\t\tma[d[i]]=i,size[i]=1;\n\t\tq.push((node){d[i],i});\n\t}\n\twhile(q.size()){\n\t\tnode now=q.top();q.pop();\n\t\tif(q.size()){\n\t\t\tfa[now.id]=ma[d[now.id]+size[now.id]*2-n];\n\t\t\tsize[fa[now.id]]+=size[now.id];\n\t\t\tadd_edge(fa[now.id],now.id);\n\t\t}\n\t\tif(!q.size()) hd=now.id;\n\t}\n\tdfs(hd,0);\n\tfor(int i=1;i<=n;i++) g[hd]+=dis[i];\n\twork(hd,0);\n\tfor(int i=1;i<=n;i++){\n\t\tif(!fa[i]) continue;\n\t\tprintf(\"%d %d\\n\",i,fa[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};//RDLU\nint main(){\n\tint n;\n\tcin>>n;\n\tvp in(n);\n\trep(i,n){\n\t\tll a;\n\t\tcin>>a;\n\t\tin[i]={-a,i};\n\t}\n\tsort(all(in));\n\tvvi co(n,vi(3,-1));\n\tvvi G(n);\n\trep(i,n-1){\n\t\tif(co[i][1]==-1)co[i]={0,1};\n\t\tint it=lower_bound(all(in),pii(in[i].first+n-2*co[i][1],-1))-in.begin();\n\t\tif(in[i].first+n-2*co[i][1]!=in[it].first){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(co[it][1]==-1)co[it]={0,1};\n\t\tco[it][0]+=co[i][0]+co[i][1];\n\t\tco[it][1]+=co[i][1];\n\t\tG[in[it].second].pb(in[i].second);\n\t}\n\tif(-co[n-1][0]!=in[n-1].first){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\trep(i,n)rep(j,G[i].size())\n\t\tcout<<i+1<<\" \"<<G[i][j]+1<<endl;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n,cnt,a[111111],id[111111],w[111111],u[111111],v[111111],siz[111111];\nbool vis[111111];\nbool cmp(int x,int y){return a[x]<a[y];}\nvoid add(int x,int y){u[++cnt]=x,v[cnt]=y;}\nsigned main(){\n\tscanf(\"%lld\",&n),w[0]=-LLONG_MAX;\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),id[i]=i,w[i]=a[i],siz[i]=1;\n\tsort(id+1,id+n+1,cmp),sort(w+1,w+n+1);\n\tfor(int i=n;i>1;i--){\n\t\tint x=2*siz[id[i]]-n+a[id[i]],pos=lower_bound(w+1,w+n+1,x)-w;\n\t\tif(w[pos]!=x||n-2*siz[id[i]]<=0){printf(\"-1\");return 0;}\n\t\tadd(id[pos],id[i]),siz[id[pos]]+=siz[id[i]];\n\t}\n\tfor(int i=1;i<=cnt;i++)printf(\"%lld %lld\\n\",u[i],v[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#define Maxn 1000008 \nusing namespace std;\ntypedef long long ll;\n\nint n;\nll d;\nint son[Maxn];\nmap <ll,int> M;\n\nstruct node{\n\tint num;\n\tll val;\n}N[Maxn];\n\nbool cmp(node a,node b){\treturn a.val > b.val;}\n\nint main()\n{\n\tmemset(son,0,sizeof(son));\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\tscanf(\"%lld\",&d);\n\t\tM[d] = i;\n\t\tN[i].num = i,N[i].val = d;\n\t}\n\tsort(N+1,N+1+n,cmp);\n\tmap<ll,int>::iterator iter;;\n\tfor(int i = 1;i < n;i ++)\n\t{\n\t\tint u = N[i].num;\n\t\tif(N[i].val - n + 2 + (son[u] << 1) <= 0) continue;\n\t\titer = M.find(N[i].val - n + 2 + (son[u] << 1));\n\t\tif(iter == M.end()) continue;\n\t\tint v = iter->second;\n\t\tson[v] += son[u]+1;\n\t\tprintf(\"%d %d\\n\",u,v);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN=2e5+7;\n\nint cntm;\nint from[MAXN],to[MAXN];\n\nmap<ll,int> Map,Map2;\n\nint n;\nll a[MAXN],b[MAXN],siz[MAXN];\n\nbool cmp(const int &A,const int &B){return a[A]>a[B];}\nbool cmp2(const int &A,const int &B){return A>B;}\n\nint main() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) {\n\t\tcin>>a[i];\n\t\tb[i]=i;\n\t\tMap[a[i]]=i;\n\t\tsiz[i]=1;\n\t}\n\tsort(b+1,b+1+n,cmp);\n\tsort(a+1,a+1+n,cmp2);\n\tfor(int i=1;i<=n;i++)\n\t\tMap2[a[i]]=i;\n\tfor(int i=1,i2;i<n;i++) {\n\t\ti2=Map[a[i]-(n-2*siz[i])];\n\t\tif(i2!=0&&i2!=b[i]) {\n\t\t\tsiz[Map2[a[i]-(n-2*siz[i])]]+=siz[i];\n\t\t\tfrom[++cntm]=i2;\n\t\t\tto[cntm]=b[i];\n\t\t}\n\t\telse {\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++) {\n\t\tcout<<from[i]<<\" \"<<to[i]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<vector>\n#define pb push_back\n\ntypedef long long LL;\n\nconst int N=100005;\n\nint n,a[N],size[N],id[N],ans1[N],ans2[N];\nLL tot;\nstd::map<LL,int> num;\nstd::vector<int> vec[N];\n\nbool cmp(int x,int y)\n{\n\treturn a[x]>a[y];\n}\n\nvoid dfs(int x,int fa,int d)\n{\n\ttot+=(LL)d;\n\tfor (int i=0;i<vec[x].size();i++)\n\t\tif (vec[x][i]!=fa) dfs(vec[x][i],x,d+1);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%lld\",&a[i]),num[a[i]]=i;\n\tfor (int i=1;i<=n;i++) size[i]=1,id[i]=i;\n\tstd::sort(id+1,id+n+1,cmp);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x=id[i];LL w=a[x]-(n-size[x])+size[x];\n\t\tif (!num[w]||w>=a[x]) {puts(\"-1\");return 0;}\n\t\tint y=num[w];\n\t\tans1[i]=x;ans2[i]=y;\n\t\tvec[x].pb(y);vec[y].pb(x);\n\t\tsize[y]+=size[x];\n\t}\n\tdfs(id[n],0,0);\n\tif (tot!=a[id[n]]) {puts(\"-1\");return 0;}\n\tfor (int i=1;i<n;i++) printf(\"%d %d\\n\",ans1[i],ans2[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint sz[100005],par[100005];\npair<long long,int> a[100005];\nmap<long long,int> inv;\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&a[i].first);\n\t\ta[i].second=i;\n\t\tsz[i]=1;\n\t\tinv[a[i].first]=i;\n\t}\n\tsort(a+1,a+n+1);\n\tfor (int i=n;i>1;i--)\n\t{\n\t\tif (2*sz[a[i].second]>=n)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint p=inv[a[i].first-n+2*sz[a[i].second]];\n\t\tif (!p)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsz[p]+=sz[a[i].second];\n\t\tpar[a[i].second]=p;\n\t}\n\tfor (int i=2;i<=n;i++)\n\ta[1].first-=sz[a[i].second];\n\tif (a[1].first)\n\tprintf(\"-1\");\n\telse\n\t{\n\t\tfor (int i=2;i<=n;i++)\n\t\tprintf(\"%d %d\\n\",par[a[i].second],a[i].second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\n\nconst int MAXN = 1e5 + 5;\nll n, par[MAXN];\nll d, sz[MAXN];\nmap <ll, ll> mp;\n\nint main()\n{\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tvector <pair<ll,ll>> v;\n\tfor(ll i = 1; i <= n; i++){\n\t\tcin >> d; sz[i] = 1ll;\n\t\tmp[d] = i;\n\t\tv.push_back({-d, i});\n\t}\n\tsort(v.begin(), v.end());\n\tfor(int i = 0; i < n - 1; i++){\n\t\td = -v[i].first;\n\t\tll ind = v[i].second;\n\t\tll dpar = max(0ll, d + (2ll * sz[ind]) - (ll)n);\n\t\tif(!mp[dpar] || dpar >= d || dpar == 0ll){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tpar[ind] = mp[dpar];\n\t\tsz[par[ind]] += sz[ind];\n\t}\n\tfor(int i = 0; i < n - 1; i++){\n\t\tcout << par[v[i].second] << \" \" << v[i].second << '\\n';\n\t}\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,n) for (int i=1;i<=n;i++)\n#define REP(i,a,b) for (int i=a;i<=b;i++)\n \n#define pb push_back\n#define fi first\n#define se second\n#define pi pair<int,int>\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n \ntypedef long long ll;\n\nconst int inf=0x3f3f3f3f;\nconst ll linf=1e18;\nconst int N=200000+10;\nconst double eps=1e-5;\nconst int mo=1e9+7;\n\nint n;\nvector<int> v[N];\nint fa[N];\nint D[N];\nint sz[N];\nstruct node {\n\tint id,v;\n} a[N];\nbool used[N];\nbool cmp(node x,node y) {\n\treturn x.v<y.v;\n}\nint F(int x) {\n\treturn (fa[x]==x)?x:(fa[x]=F(fa[x]));\n}\nint find(int x) {\n\tint l=1,r=n;\n\tint mid;\n\twhile (l<=r) {\n\t\tmid=(l+r)>>1;\n\t\tif (a[mid].v<x) {\n\t\t\tl=mid+1;\n\t\t} else if (a[mid].v>x) {\n\t\t\tr=mid-1;\n\t\t} else return a[mid].id;\n\t}\n\treturn 0;\n}\nvoid dfs(int x,int s,int d,int f) {\n\tD[s]+=d;\n\tint t;\n\tfor (int i=0;i<(int)v[x].size();i++) {\n\t\tt=v[x][i];\n\t\tif (t!=f) {\n\t\t\tdfs(t,s,d+1,x);\n\t\t}\n\t}\n}\nbool check() {\n\tdfs(a[1].id,a[1].id,0,0);\n\tif (D[a[1].id]!=a[1].v) return 0;\n\treturn 1;\n}\nint main() {\n \n    std::ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tint x,y;\n\tFOR(i,n) {\n\t\tscanf(\"%d\",&a[i].v);\n\t\ta[i].id=i;\n\t}\n\tsort(a+1,a+1+n,cmp);\n\tFOR(i,n) sz[i]=1,fa[i]=i;\n\tint t;\n\tfor (int i=n;i>=2;i--) {\n\t\tx=a[i].id;\n\t\tt=a[i].v-n+2*sz[x];\n\t\t//cout<<x<<\" \"<<t<<endl;\n\t\ty=find(t);\n\t\tif (F(x)==F(y)||used[y]||y==0) {\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tv[x].pb(y);\n\t\tv[y].pb(x);\n\t\tsz[y]+=sz[x];\n\t\tfa[F(x)]=F(y);\n\t\tused[x]=1;\n\t\t// used[x]=1表示x的所有儿子都已经找到了，之后如果还有点想插入x当儿子就是无解的 \n\t}\n\tif (!check()) {\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tFOR(i,n) {\n\t\tfor (int j=0;j<(int)v[i].size();j++) {\n\t\t\ty=v[i][j];\n\t\t\tif (i<y) {\n\t\t\t\tprintf(\"%d %d\\n\",i,y);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n\nconst ll dx[4] = { -1,1,0,0 };\nconst ll dy[4] = { 0,0,-1,1 };\nconst char c[4] = { 'R','L','U','D' };\n\nint main(){\n\tstatic ll n;\n\tstatic ll d[100010];\n\tscanf(\"%lld\",&n);\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tscanf(\"%lld\",&d[i]);\n\t}\n\t\n\tvector<P> vec;\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tvec.push_back(P(d[i],i));\n\t}\n\tsort(vec.begin(),vec.end());\n\treverse(vec.begin(),vec.end());\n\t\n\tstatic ll cnt[100010];\n\tstatic ll dp[100010];\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tcnt[i] = 1;\n\t\tdp[i] = 0;\n\t}\n\t\n\tmap<ll,ll> id;\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tid[d[i]] = i;\n\t}\n\t\n\tvector<P> ans;\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tP p = vec[i-1];\n\t\t//cout << p.fr << \" \" << p.sc << endl;\n\t\tif(cnt[p.sc]*2 >= n)continue;\n\t\tll nx = d[p.sc]-(n-cnt[p.sc])+cnt[p.sc];\n\t\tif(id.find(nx) == id.end()){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tans.push_back(P(p.sc,id[nx]));\n\t\t\tcnt[id[nx]] += cnt[p.sc];\n\t\t\tdp[id[nx]] += dp[p.sc];\n\t\t\tdp[id[nx]] += cnt[p.sc];\n\t\t}\n\t}\n\tif(n%2 == 0){\n\t\tif(vec[n-2].fr != vec[n-1].fr){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tans.push_back(P(vec[n-2].sc,vec[n-1].sc));\n\t\tif(vec[n-1].fr != dp[vec[n-1].sc]+dp[vec[n-2].sc]+n/2){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse {\n\t\tif(vec[n-1].fr != dp[vec[n-1].sc]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\t/*for(int i = 1 ; i <= n ; i ++){\n\t\tif(dp[i] != d[i]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}*/\n\t\n\tif(ans.size() < n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i = 0 ; i < ans.size() ; i ++){\n\t\tprintf(\"%d %d\\n\",ans[i].fr,ans[i].sc);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll n,sum,a[500001],b[500001],c[500001],sz[500001],id[500001];\nvector<ll>zh[150001];\nmap<ll,ll>mp;\nbool cmp(ll x,ll y){\n\treturn a[x]>a[y];\n}\nvoid dfs(ll x,ll fa,ll now){\n\tll i;\n\tsum+=now;\n\tfor(i=0;i<zh[x].size();i++)if(zh[x][i]!=fa)dfs(zh[x][i],x,now+1);\n}\nint main(){\n\tll i,x,y,w;\n\tscanf(\"%lld\",&n);\n\tfor(i=1;i<=n;i++)scanf(\"%lld\",&a[i]),mp[a[i]]=i;\n\tfor(i=1;i<=n;i++)sz[i]=1,id[i]=i;\n\tsort(id+1,id+n+1,cmp);\n\tfor(i=1;i<n;i++){\n\t\tx=id[i];\n\t\tw=a[x]-(n-sz[x])+sz[x];\n\t\t//prllf(\"%d %d %d %d\\n\",x,a[x],sz[x],w);\n\t\tif(!mp[w]||w>=a[x])return puts(\"-1\"),0;\n\t\ty=mp[w];\n\t\tb[i]=x;c[i]=y;\n\t\tzh[x].push_back(y);\n\t\tzh[y].push_back(x);\n\t\tsz[y]+=sz[x];\n\t}\n\tdfs(id[n],0,0);\n\tif(sum!=a[id[n]])return puts(\"-1\"),0;\n\tfor(i=1;i<n;i++)printf(\"%lld %lld\\n\",b[i],c[i]);\n}\n/*\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=100010;\nstruct node{\n\tll sum;int id;\n\tbool operator<(const node n)const{\n\t\treturn sum>n.sum;\n\t}\n}p[maxn];\nint n,sz[maxn],fa[maxn];\nint to[maxn],nxt[maxn],head[maxn],el;\nll sum[maxn],tot;\ninline void add(int u,int v){\n\tto[++el]=v;nxt[el]=head[u];head[u]=el;\n}\nvoid dfs(int u,ll dis){\n\ttot+=dis;\n\tfor(int i=head[u];i;i=nxt[i]) dfs(to[i],dis+1);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&p[i].sum),p[i].id=i,sz[i]=1;\n\tsort(p+1,p+n+1);\n\tfor(int i=1;i<=n;i++) sum[i]=p[i].sum;\n\tfor(int i=1;i<n;i++){\n\t\tint f=lower_bound(sum+1,sum+n+1,sum[i]-n+2*sz[i],greater<ll>())-sum;\n\t\tif(sum[f]!=sum[i]-n+2*sz[i] || f==i) return puts(\"-1\"),0;\n\t\tfa[p[i].id]=p[f].id;sz[f]+=sz[i];add(f,i);\n\t}\n\tdfs(n,0);\n\tif(tot!=sum[n]) return puts(\"-1\"),0;\n\tfor(int i=1;i<=n;i++) if(fa[i]) printf(\"%d %d\\n\",i,fa[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\n\nconst int maxn = 1e5 + 5;\n\nint par[maxn], N, sub[maxn];\npair<ll, int> d[maxn];\nll f[maxn];\nvector<int> adj[maxn];\nint depth[maxn], sz[maxn];\n\nvoid dfs(int u = 1, int p = -1)\n{\n  sz[u] = 1;\n  f[1] += depth[u];\n  for(int v : adj[u]) if(v != p){\n    depth[v] = depth[u] + 1;\n    dfs(v, u);\n    sz[u] += sz[v];\n  }\n}\n\nvoid reroot(int u = 1, int p = -1)\n{\n  for(int v : adj[u]) if(v != p){\n    f[v] = f[u] + N - 2 * sz[v];\n    reroot(v, u);\n  }\n}\n\nbool check(void)\n{\n  for(int i = 1; i <= N; ++i){\n    if(f[d[i].se] != d[i].fi) return false;\n  }\n  return true;\n}\n\nsigned main(void)\n{\n  ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n  if(fopen(\"A.INP\", \"r\")){\n    freopen(\"A.INP\", \"r\", stdin);\n    freopen(\"A.OUT\", \"w\", stdout);\n  }\n  cin >> N;\n  for(int i = 1; i <= N; ++i){\n    cin >> d[i].fi;\n    d[i].se = i;\n    sub[i] = 1;\n  }\n  sort(d + 1, d + 1 + N);\n  for(int i = N; i >= 2; --i){\n    int j = lower_bound(d + 1, d + 1 + N, mp(d[i].fi - (N - 2 * sub[d[i].se]), -1)) - d;\n    if(i == j) ++j;\n    if(d[j].fi != d[i].fi - (N - 2 * sub[d[i].se])){\n      cout << -1;\n      return 0;\n    }\n    par[d[i].se] = d[j].se;\n    sub[d[j].se] += sub[d[i].se];\n  }\n  if(!check()){\n    cout << -1;\n    return 0;\n  }\n  for(int i = 1; i <= N; ++i){\n    if(par[i]) cout << i << ' ' << par[i] << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "// By Hacheylight\n\n#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n\t#include <cstring>\n\t#include <cassert>\n\t#include <climits>\n\t#include <cstdlib>\n\t#include <iostream>\n\t#include <algorithm>\n\t#include <functional>\n\tusing namespace std ;\n\t//#define int long long\n\t#define rep(i, a, b) for (int i = (a); i <= (b); i++)\n\t#define per(i, a, b) for (int i = (a); i >= (b); i--)\n\t#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n\t#define cont(i, x) for (int i = head[x]; i; i = e[i].nxt)\n\t#define clr(a) memset(a, 0, sizeof(a))\n\t#define ass(a, sum) memset(a, sum, sizeof(a))\n\t#define lowbit(x) (x & -x)\n\t#define all(x) x.begin(), x.end()\n\t#define SC(t, x) static_cast <t> (x)\n\t#define ub upper_bound\n\t#define lb lower_bound\n\t#define pqueue priority_queue\n\t#define mp make_pair\n\t#define pb push_back\n\t#define pof pop_front\n\t#define pob pop_back\n\t#define fi first\n\t#define se second\n\t#define y1 y1_\n\t#define Pi acos(-1.0)\n\t#define iv inline void\n\t#define enter cout << endl\n\t#define siz(x) ((int)x.size())\n\t#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\n\ttypedef long double ld ;\n\ttypedef long long ll ;\n\ttypedef unsigned long long ull ;\n\ttypedef pair <int, int> pii ;\n\ttypedef vector <int> vi ;\n\ttypedef vector <pii> vii ;\n\ttypedef queue <int> qi ;\n\ttypedef queue <pii> qii ;\n\ttypedef set <int> si ;\n\ttypedef map <int, int> mii ;\n\ttypedef map <string, int> msi ;\n\tconst int N = 100010 ;\n\tconst int INF = 0x3f3f3f3f ;\n\tconst int iinf = 1 << 30 ;\n\tconst ll linf = 2e18 ;\n\tconst int mod = 1000000007 ;\n\tconst double eps = 1e-7 ;\n\tvoid douout(double x){ printf(\"%lf\\n\", x + 0.0000000001) ; }\n\ttemplate <class T> void print(T a) { cout << a << endl ; exit(0) ; }\n\ttemplate <class T> void chmin(T &a, T b) { if (a > b) a = b ; }\n\ttemplate <class T> void chmax(T &a, T b) { if (a < b) a = b ; }\n\tvoid add(int &a, int b) { a = a + b < mod ? a + b : a + b - mod ; }\n\tvoid sub(int &a, int b) { a = (a - b + mod) % mod ; }\n\tvoid mul(int &a, int b) { a = (ll) a * b % mod ; }\n\tint addv(int a, int b) { return (a += b) >= mod ? a -= mod : a ; }\n\tint subv(int a, int b) { return (a -= b) < 0 ? a += mod : a ; }\n\tint mulv(int a, int b) { return (ll) a * b % mod ; }\n\tint read() {\n\t    int f = 1, x = 0 ;\n\t    char ch = getchar() ;\n\t    while (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\t    while (isdigit(ch)) { x = x * 10 + ch -'0' ; ch = getchar() ; }\n\t    return x * f ;\n\t}\n\tint pw(int a, int b) {\n\t\tint s = 1 ;\n\t\tfor (; b; b >>= 1, a = (ll) a * a % mod)\n\t    if (b & 1) s = (ll) s * a % mod ;\n\t    return s ;\n\t}\n\n\nsigned main() {\n\tint n ;\n\tscanf(\"%d\", &n) ;\n\tvector <ll> d(n) ;\n\tvi sz(n, 1) ;\n\tmap <ll, int> hsh ;\n\trep(i, 0, n - 1) {\n\t\tscanf(\"%lld\", &d[i]) ;\n\t\thsh[d[i]] = i ;\n\t}\n\tvector <pii> res ;\n\trep(itt, 0, n - 2) {\n\t\tauto it = hsh.rbegin() ;\n\t\tint i = it->se ;\n\t\tll want = d[i] + 2 * sz[i] - n ;\n\t\tif (hsh.find(want) == hsh.end() || hsh[want] == i) print(-1) ;\n\t\tint j = hsh[want] ;\n\t\tres.emplace_back(j, i) ;\n\t\tsz[j] += sz[i] ;\n\t\thsh.erase(--hsh.end()) ;\n\t}\n\tvector <ll> real(n, -1) ;\n\treal[0] = 0 ;\n\tvector <vi> g(n) ;\n\tfor (auto &p : res) {\n\t\tg[p.fi].pb(p.se) ;\n\t\tg[p.se].pb(p.fi) ;\n\t}\n\tvi que(1, 0) ;\n\trep(b, 0, siz(que) - 1) {\n\t\tfor (int j : g[que[b]]) {\n\t\t\tif (real[j] == -1) {\n\t\t\t\tque.pb(j) ;\n\t\t\t\treal[j] = real[que[b]] + 1 ;\n\t\t\t}\n\t\t}\n\t}\n\tif (accumulate(real.begin(), real.end(), 0LL) != d[0]) print(-1) ;\n\tsort(res.begin(), res.end()) ;\n\tfor (auto &p : res) printf(\"%d %d\\n\", p.fi + 1, p.se + 1) ;\n\treturn 0 ;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,j,k) for(int i=j;i<=k;++i)\ntypedef long long ll;\nchar cch;\ninline int rd(){\n\tint x=0,fl=1;\n\tcch=getchar();\n\twhile(cch>'9'||cch<'0'){\n\t\tif(cch=='-') fl=-1;\n\t\tcch=getchar();\n\t}\n\twhile(cch>='0'&&cch<='9') x=(x<<3)+(x<<1)+cch-'0',cch=getchar();\n\treturn x*fl;\n}\nconst int N=1e5+3;\nstruct abc{\n\tint i;\n\tll d;\n}a[N];\nint fr[N],head[N],to[N],nxt[N],cnt,sz[N];\nll re,c[N];\ninline bool cmp(const abc &a,const abc &b){\n\treturn a.d<b.d;\n}\ninline void adde(int u,int v){\n\tto[++cnt]=v,fr[cnt]=u,nxt[cnt]=head[u],head[u]=cnt;\n}\ninline void dfs(int u,int fa,int dep){\n\tre+=dep;\n\tfor(int i=head[u];i;i=nxt[i]){\n\t\tdfs(to[i],fa,dep+1);\n\t}\n}\nint main(){\n\tint n=rd();\n\trep(i,1,n) a[i].d=rd(),a[i].i=i,sz[i]=1;\n\tsort(a+1,a+1+n,cmp);\n\trep(i,1,n) c[i]=a[i].d;\n\tint pos;\n\tll tmp;\n\tfor(int i=n;i>1;--i){\n\t\ttmp=a[i].d-(n-sz[a[i].i])+sz[a[i].i];\n\t\tpos=lower_bound(c+1,c+n+1,tmp)-c;\n\t\tif(c[pos]!=tmp||tmp>a[i].d){\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t\telse sz[a[pos].i]+=sz[a[i].i],adde(a[pos].i,a[i].i);\n\t}\n\tdfs(a[1].i,0,0);\n\tif(re!=a[1].d){\n\t\tputs(\"-1\");return 0;\n\t}\n\tfor(int i=1;i<n;++i){\n\t\tprintf(\"%d %d\\n\",fr[i],to[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stdio.h>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nvector < pair <int, int> > v;\n\nint n, sz[1000000];\n\nvector <int> g[1000000];\n\nint main () \n{\n    cin >> n;\n    \n    for (int i = 0; i < n; i++)\n    {\n\tint d;\n\tscanf (\"%d\", &d);\n\t\n\tv.emplace_back (d, i);\n    }\n    \n    sort (v.begin (), v.end ());\n    \n    for (int i = n - 1; i; i--)\n    {\n\tint x = v[i].second, d = v[i].first;\n\t\n\tv.pop_back ();\n\t\n\tsz[x] = 1;\n\t\n\tfor (int to : g[x])\n\t    sz[x] += sz[to];\n\t\n\tint k = upper_bound (v.begin (), v.end (), make_pair (d + 2 * sz[x] - n, -1)) - v.begin ();\n\t\n\tif (k == v.size () || v[k].first != d + 2 * sz[x] - n)\n\t{\n\t    cout << -1;\n\t    return 0;\n\t}\n\t\n\tg[v[k].second].push_back (x);\n    }\n    \n    for (int i = 0; i < n; i++)\n\tfor (int to : g[i])\n\t{\n\t    printf (\"%d %d\\n\", i + 1, to + 1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#define Maxn 1000008 \nusing namespace std;\ntypedef long long ll;\n\nint n,cnt;\nll d;\nint son[Maxn];\nmap <ll,int> M;\n\nstruct node{\n\tint num;\n\tll val;\n}N[Maxn];\n\nbool cmp(node a,node b){\treturn a.val > b.val;}\n\nint U[Maxn],V[Maxn];\n\nint main()\n{\n\tmemset(son,0,sizeof(son));\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\tscanf(\"%lld\",&d);\n\t\tM[d] = i;\n\t\tN[i].num = i,N[i].val = d;\n\t}\n\tsort(N+1,N+1+n,cmp);\n\tmap<ll,int>::iterator iter;;\n\tfor(int i = 1;i < n;i ++)\n\t{\n\t\tint u = N[i].num;\n\t\titer = M.find(N[i].val - n + 2 + (son[u] << 1));\n\t\tif(iter == M.end()) continue;\n\t\tint v = iter->second;\n\t\tson[v] += son[u]+1;\n\t\tU[cnt] = u,V[cnt++] = v;\n\t}\n\tif(cnt != n - 1) printf(\"-1\\n\");\n\telse\n\t\tif(son[1] == n - 1) \n\t\t\tfor(int i = 0;i < cnt;i ++)\n\t\t\t\tprintf(\"%d %d\\n\",U[i],V[i]);\n\t\telse printf(\"-1\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define eb emplace_back\n#define mt make_tuple\n#define all(x) (x).begin(), (x).end() \n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair <int, int> ii;\ntypedef pair <ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef long double ld;\n\nconst ll INF=LLONG_MAX;\nconst int mxn=1e5+5;\nint sz[mxn];\nvi adj[mxn];\n\nint dfs(int u, int p=-1){\n\tint res = 0;\n\tfor(auto v:adj[u]){\n\t\tif(v==p)continue;\n\t\tres += dfs(v,u)+sz[v];\n\t}\n\treturn res;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    //freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout);\n\tint n;\n\tcin >> n;\n\tii dist[n];\n\tmap<int,int>vis;\n\tfor(int i=0; i<n; i++){\n\t\tcin >> dist[i].fi;\n\t\tdist[i].se=i;\n\t\tsz[i]=1;\n\t\tvis[dist[i].fi]=i;\n\t}\n\tsort(dist,dist+n);\n\tfor(int i=n-1; i>0; i--){\n\t\tint ind = dist[i].se;\n\t\tint next = dist[i].fi-n+2*sz[ind];\n\t\tif(vis.find(next)==vis.end()||next>=dist[i].fi){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tauto ptr = vis[next];\n\t\tif(ptr==ind){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsz[ptr] += sz[ind];\n\t\tadj[ind].eb(ptr);\n\t\tadj[ptr].eb(ind);\n\t}\n\tbool ok=0;\n\tfor(int i=0; i<n&&!ok; i++){\n\t\tif(sz[i]==n)ok=1;\n\t}\n\tif(dfs(dist[0].se)!=dist[0].fi)ok=0;\n\tif(!ok)cout << -1 << endl;\n\telse{\n\t\tfor(int i=0; i<n; i++)\n\t\t\tfor(auto j:adj[i])\n\t\t\t\tif(j>i)cout << i+1 << ' ' << j+1 << endl;\n\t}\n}\n\t\n// READ & UNDERSTAND\n// ll, int overflow, array bounds, memset(0)\n// special cases (n=1?), n+1 (1-index)\n// do smth instead of nothing & stay organized\n// WRITE STUFF DOWN\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimiz(O2)\n\n#include <bits/stdc++.h>\n\n#define rg register\nusing namespace std;\ntypedef long long ll;\n\ntemplate<typename T>\ninline bool read(T &n) {\n    T ans = 0, flag = 1;\n    char ch;\n    while ((ch = getchar()) < '0' || ch > '9') if (ch == '-') flag = -1; else if (ch == EOF) return false;\n    ans = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9') ans = ans * 10 + ch - '0';\n    n = ans * flag;\n    return true;\n}\n\ninline ll read() {\n    ll ans = 0, flag = 1;\n    char ch;\n    while ((ch = getchar()) < '0' || ch > '9') if (ch == '-') flag = -1;\n    ans = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9') ans = ans * 10 + ch - '0';\n    return ans * flag;\n};\nconst int maxn = 100005;\nstruct NODE {\n    ll val, ord;\n    bool operator<(NODE b) const {\n        return val < b.val;\n    }\n} node[maxn];\nstruct EDGE{\n    int nex,t;\n}edge[maxn<<1];\n\nint ecnt,head[maxn],siz[maxn],fa[maxn];\nunordered_map<ll,int> unM;\ninline void addedge(int u,int v){\n    edge[++ecnt].nex=head[u];head[u]=ecnt;edge[ecnt].t=v;\n    edge[++ecnt].nex=head[v];head[v]=ecnt;edge[ecnt].t=u;\n}\nll dfs(int rt,int fa,int dis){\n    ll ans=dis;\n    for(rg int i=head[rt];i;i=edge[i].nex){\n        int y=edge[i].t;\n        if(y==fa) continue;\n        ans+=dfs(y,rt,dis+1);\n    }\n    return ans;\n}\nint main() {\n    int n;\n    read(n);priority_queue<NODE> pq;\n    for (rg int i = 1; i <= n; ++i) {\n        siz[i] = 1;read(node[i].val);\n        node[i].ord = i;\n        pq.push(node[i]);\n        unM[node[i].val]=i;\n    }\n    for(rg int i=n;i>=2;i--){\n        NODE now=pq.top();pq.pop();\n        if(unM.find(now.val+2*siz[now.ord]-n)==unM.end()){\n            puts(\"-1\");return 0;\n        }\n        fa[now.ord]=unM[now.val+2*siz[now.ord]-n];\n        siz[fa[now.ord]]+=siz[now.ord];\n        addedge(now.ord,fa[now.ord]);\n    }\n    if(siz[pq.top().ord]!=n||dfs(pq.top().ord,0,0)!=pq.top().val) puts(\"-1\");\n    else for(rg int i=1;i<=n;i++){\n        if(fa[i]) cout<<i<<' '<<fa[i]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\nconst int inf = (1 << 30) - 1;\nconst int64 infll = (1LL << 61) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< typename Data, typename T, typename F1, typename F2 >\nstruct ReRooting {\n\n  struct Node {\n    int to, rev;\n    Data data;\n  };\n\n  vector< vector< Node > > g;\n  vector< vector< T > > ldp, rdp;\n  vector< int > lptr, rptr;\n  const F1 f1;\n  const F2 f2;\n  const T ident;\n\n  ReRooting(int n, const F1 &f1, const F2 &f2, const T &ident) :\n      g(n), ldp(n), rdp(n), lptr(n), rptr(n), f1(f1), f2(f2), ident(ident) {}\n\n  void add_edge(int u, int v, const Data &d) {\n    g[u].emplace_back((Node) {v, (int) g[v].size(), d});\n    g[v].emplace_back((Node) {u, (int) g[u].size() - 1, d});\n  }\n\n  T dfs(int idx, int par) {\n\n    while(lptr[idx] != par && lptr[idx] < g[idx].size()) {\n      auto &e = g[idx][lptr[idx]];\n      ldp[idx][lptr[idx] + 1] = f1(ldp[idx][lptr[idx]], f2(dfs(e.to, e.rev), idx, e.to, e.data));\n      ++lptr[idx];\n    }\n    while(rptr[idx] != par && rptr[idx] >= 0) {\n      auto &e = g[idx][rptr[idx]];\n      rdp[idx][rptr[idx]] = f1(rdp[idx][rptr[idx] + 1], f2(dfs(e.to, e.rev), idx, e.to, e.data));\n      --rptr[idx];\n    }\n    if(par < 0) return rdp[idx][0];\n    return f1(ldp[idx][par], rdp[idx][par + 1]);\n  }\n\n  vector< T > solve() {\n    for(int i = 0; i < g.size(); i++) {\n      ldp[i].assign(g[i].size() + 1, ident);\n      rdp[i].assign(g[i].size() + 1, ident);\n      lptr[i] = 0;\n      rptr[i] = (int) g[i].size() - 1;\n    }\n    vector< T > ret;\n    for(int i = 0; i < g.size(); i++) {\n      ret.push_back(dfs(i, -1));\n    }\n    return ret;\n  }\n};\n\nint main() {\n  int N;\n  cin >> N;\n  set< pair< int64, int > > que;\n  vector< int64 > d(N);\n  for(int i = 0; i < N; i++) {\n    cin >> d[i];\n    que.emplace(d[i], i);\n  }\n\n  vector< int > par(N, -1), size(N, 1);\n  while(que.size() >= 2) {\n    auto p = *prev(que.end());\n    que.erase(p);\n    const int other = N - size[p.second];\n    int64 latte = p.first + size[p.second] - other;\n\n    auto it = que.lower_bound({latte, -1});\n    if(it == que.end() || it->first != latte) {\n      cout << -1 << endl;\n      return 0;\n    }\n    size[it->second] += size[p.second];\n    par[p.second] = it->second;\n  }\n\n  using pi = pair< int64, int >;\n  auto f1 = [&](pi x, pi y) { return pi(x.first + y.first, x.second + y.second); };\n  auto f2 = [](pi a, int from, int to, int d) { return pi(a.first + (a.second + 1), a.second + 1); };\n  ReRooting< int, pi, decltype(f1), decltype(f2) > reroot(N, f1, f2, pi());\n  for(int i = 0; i < N; i++) if(~par[i]) reroot.add_edge(i, par[i], 0);\n  auto uku = reroot.solve();\n  for(int i = 0; i < N; i++) {\n    if(uku[i].first != d[i]) {\n      cout << -1 << endl;\n      return 0;\n    }\n  }\n\n\n  for(int i = 0; i < N; i++) {\n    if(~par[i]) cout << par[i] + 1 << \" \" << i + 1 << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <set>\n#include <map>\nusing namespace std;\nint n;\n/*int a[100020];\nint b[100020];*/\npair<long long, int> d[100200];\nmap<long long, int> mp;\nvector<int> ed[100200];\nint sz[100200];\nlong long f[100200];\nint par[100200];\nvoid bad() {\n    cout << \"-1\\n\";\n    exit(0);\n}\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> d[i].first;\n        d[i].second = i;\n    }\n    vector<pair<int, int> > ans;\n    sort(d + 1, d + n + 1);\n    for (int i = 1; i <= n; i++) mp[d[i].first] = i;\n\n    for (int i = n; i > 1; i--) {\n        sz[i]++;\n        long long x = d[i].first - (n - 2 * sz[i]);\n        if (mp[x] == 0) bad();\n        else {\n            sz[mp[x]] += sz[i];\n            ans.push_back(make_pair(d[i].second, d[mp[x]].second));\n            f[mp[x]] += f[i] + 1;\n        }\n        if (sz[i] > n) bad();\n    }\n    sz[1]++;\n    if (sz[1] != n) bad();\n    if (f[1] != d[1].first) bad();\n    //check(ans);\n    for (auto it: ans) cout << it.first << \" \" << it.second << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define llong long long \n#define xx first\n#define yy second\n#define len(x) ((int)x.size())\n#define rep(i,n) for (int i = -1; ++ i < n; )\n#define rep1(i,n) for (int i = 0; i ++ < n; )\n#define all(x) x.begin(), x.end()\n\n#define maxn 101010\nint n;\nint nchild[maxn];\nmap<llong, int> inv_d;\n\nint main(void) {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n;\n    rep1(i, n) {\n      llong d; cin >> d;\n      inv_d[d] = i;\n    }\n    rep1(i, n) nchild[i] = 1;\n\n    vector<pair<int, int>> ans;\n    while (len(inv_d) > 1) {\n      llong d = inv_d.rbegin()->xx;\n      int u = inv_d.rbegin()->yy;\n      inv_d.erase(--inv_d.end());\n      llong td = d - 1ll * (n + 2 * nchild[u]);\n      // clog << u << ' ' << d << ' ' << nchild[u] << endl;\n      if (!inv_d.count(td)) {\n        cout << \"-1\";\n        return 0;\n      }\n      int v = inv_d[td];\n      ans.push_back({u, v});\n      // clog << u << ' ' << v << endl;\n      nchild[v] += nchild[u];\n    }\n    rep(i, n - 1) cout << ans[i].xx << ' ' << ans[i].yy << '\\n';\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\nconst int N = 1e5 + 100;\n\nll n, d[N], cnt[N], dp[N];\nvector<int> nei[N];\nvector<pll> vec, ans;\nbool no_homo;\nunordered_map<ll, int> v_d;\n\nvoid dfs(int v, int par = -1) {\n\tfor (int u: nei[v])\n\t\tif(u != par) {\n\t\t\tdfs(u, v);\n\t\t\tdp[v] += dp[u] + cnt[u];\n\t\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> d[i], vec.push_back(pll(d[i], i)), cnt[i] = 1, v_d[d[i]] = i;\n\tsort(vec.begin(), vec.end());\n\treverse(vec.begin(), vec.end());\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tll v = vec[i].second, want = vec[i].first + 2 * cnt[v] - n, u = v_d[want];\n\t\tif(2 * cnt[v] > n)\n\t\t\tno_homo = true;\n\t\t//cerr << v << \" want -> \" << u << ' ' << want << '\\n';\n\t\tif(u == 0)\n\t\t\tno_homo = true;\n\t\telse {\n\t\t\tcnt[u] += cnt[v];\n\t\t\tans.push_back(pll(v, u));\n\t\t\tnei[v].push_back(u);\n\t\t\tnei[u].push_back(v);\n\t\t}\n\t}\n\tdfs(vec.back().second);\n\tif(d[vec.back().second] != dp[vec.back().second])\n\t\tno_homo = true;\n\tif(no_homo) {\n\t\tcout << -1;\n\t\treturn 0;\n\t}\n\tfor (pll p: ans)\n\t\tcout << p.first << ' ' << p.second << '\\n';\n\treturn 0;\n}// 1 BASE"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double PI = acos(-1);\nconst double EPS = 1e-15;\nusing ll = long long;\nusing ull = unsigned long long;\nconst int inf = 2e9;\nconst ll INF = 2e18;\nconst ll MOD = 1e9+7;\nconst ll MOD1 = 998244353;\n//typedef pair<int,int> P;\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define sz(s) (s).size()\n#define pb push_back\n#define fi first\n#define se second\n//#define mp make_pair\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  ll n;\n  cin >> n;\n\n  //現在のノード数に対応する次のノードまでのsumの変化値\n  ll diff[n/2+1] = {};\n  for (int i = 1; i <= n / 2; i++) {\n    diff[i] = n - i * 2;\n  }\n\n  //sumとノード番号の対応\n  map<ll,ll> mp;\n  //sumを入れるところ\n  vector<ll> v;\n  for (ll i = 0; i < n; i++) {\n    ll a;\n    cin >> a;\n    mp[a] = i+1;\n    v.pb(a);\n  }\n\n  sort(v.rbegin(),v.rend());\n\n  //答え\n  vector<pair<ll,ll>> ans;\n\n  //最後尾のノードをsetに入れる\n  //つながってたら消す\n  set<ll> st;\n\n  //予測するため，つぎのノードのsumをnextに入れる\n  set<ll> next;\n  //前のノードを記録する\n  vector<ll> pre[100010];\n  //次への変化値を知るため，ノード数をlvに記録する\n  map<ll,ll> lv;\n\n  /*****手順*******/\n  //現在のノードがnext候補にあるとき\n  ////グラフを構築する\n  ////前のノードをstから消す\n  ////lvを数える\n\n  ////lv++\n  ////現在のノードをnextから消す\n  ////現在のノードをstに入れる\n  ////次のノードをnextに入れる\n\n  //最後にnextに要素があるときは-1\n  //nextが一つだけの時はok\n\n  for (ll i = 0; i < n; i++) {\n    if (next.count(v[i])) {\n      for (int j = 0; j < pre[mp[v[i]]].size(); j++) {\n        ans.pb({mp[v[i]], mp[pre[mp[v[i]]][j]]});\n        st.erase(pre[mp[v[i]]][j]);\n        lv[v[i]] += lv[pre[mp[v[i]]][j]];\n      }\n    }\n    lv[v[i]]++;\n    next.erase(v[i]);\n    st.insert(v[i]);\n    if (!mp.count(v[i] - diff[lv[v[i]]]) && i != n - 1) {\n      cout << -1 << endl;\n      return 0;\n    }\n    if (i != n - 1) {\n      pre[mp[v[i] - diff[lv[v[i]]]]].pb(v[i]);\n      next.insert(v[i] - diff[lv[v[i]]]);\n    }\n  }\n\n  if (next.size()) {\n    cout << -1 << endl;\n    return 0;\n  }\n  REP(i,sz(ans)) {\n    cout << ans[i].fi << \" \" << ans[i].se << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long LL;\nint _min(int x, int y) {return x < y ? x : y;}\nint _max(int x, int y) {return x > y ? x : y;}\nLL read() {\n\tLL s = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = getchar();\n\treturn s * f;\n}\n\nstruct edge {\n\tint x, y, next;\n} f[110000], e[110000]; int len, last[110000];\nstruct node {\n\tLL x; int id;\n} a[110000];\nLL d[110000], sum;\nint tot[110000];\n\nbool cmp(node a, node b) {return a.x < b.x;}\n\nvoid ins(int x, int y) {\n\te[++len].x = x, e[len].y = y;\n\te[len].next = last[x], last[x] = len;\n}\n\nvoid dfs(int x, int dis) {\n\tsum += dis;\n\tfor(int k = last[x]; k; k = e[k].next) {\n\t\tint y = e[k].y;\n\t\tdfs(y, dis + 1);\n\t}\n}\n\nint main() {\n\tLL n = read();\n\tfor(int i = 1; i <= n; i++) a[i].x = read(), a[i].id = i;\n\tsort(a + 1, a + n + 1, cmp);\n\tfor(int i = 1; i <= n; i++) d[i] = a[i].x;\n\tfor(int i = 1; i <= n; i++) tot[i] = 1;\n\tlen = 0;\n\tfor(int i = n; i > 1; i--) {\n\t\tint u = d[i] - n + 2 * tot[i];\n\t\tint fa = lower_bound(d + 1, d + n + 1, u) - d;\n\t\tif(d[fa] != u) {puts(\"-1\"); return 0;}\n\t\tf[++len].x = fa, f[len].y = i;\n\t\ttot[fa] += tot[i];\n\t} len = 0; for(int i = 1; i < n; i++) ins(f[i].x, f[i].y);\n\tsum = 0; dfs(1, 0);\n\tif(sum != d[1]) {puts(\"-1\"); return 0;}\n\tfor(int i = 1; i < n; i++) printf(\"%d %d\\n\", a[f[i].x].id, a[f[i].y].id);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define MAXN 100010\nusing namespace std;\nLL sz[MAXN],ans1[MAXN],ans2[MAXN];\nmap<LL,LL> mp;\n/*struct node\n{\n\tLL k1,k2;\n\tbool operator <(const node &aa)\n\t{\n\t\treturn k1>aa.k1;\n\t}\n};\nset<node> S;*/\nstruct node\n{\n\tLL k1,k2;\n}D[MAXN];\nbool cmp(node aa,node bb)\n{\n\treturn aa.k1>bb.k1;\n}\nint main()\n{\n\tLL N,i,lans,fa,dfa;\n\tscanf(\"%lld\",&N);\n\tfor(i=1;i<=N;i++){scanf(\"%lld\",&D[i].k1);mp[D[i].k1]=i;D[i].k2=i;}\n\tsort(D+1,D+N+1,cmp);\n\tmemset(sz,0,sizeof(sz));\n\tlans=0;\n\tfor(i=1;i<N;i++)\n\t{\n\t\tsz[D[i].k2]++;\n\t\tdfa=D[i].k1+sz[D[i].k2]-(N-sz[D[i].k2]);\n\t\tif(dfa>=D[i].k1){printf(\"-1\");return 0;}\n\t\tfa=mp[dfa];if(fa==0){printf(\"-1\");return 0;}\n\t\tsz[fa]+=sz[D[i].k2];\n\t\tans1[++lans]=D[i].k2;ans2[lans]=fa;\n\t}\n\tsz[D[N].k2]++;\n\tif(sz[D[N].k2]!=N){printf(\"-1\");return 0;}\n\tfor(i=1;i<=lans;i++)printf(\"%lld %lld\\n\",ans1[i],ans2[i]);\n\t/*memset(sz,0,sizeof(sz));\n\twhile(1)\n\t{\n\t\tnode MX=*(S.begin());\n\t\tsz[MX.k2]=1;\n\t\twhile(1)\n\t\t{\n\t\t\t\n\t\t}\n\t\tif(tot==N-1)break;\n\t}*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define REP(NAME, NUM) for (int NAME = 0; NAME < (NUM); ++NAME)\n#define BREP(NAME, NUM) for (int NAME = (NUM)-1; NAME >= 0; --NAME)\n#define VEC(TYPE, A, NAME, INIT) vector<TYPE> NAME(A, INIT)\n#define VEC2(TYPE, A, B, NAME, INIT) vector<vector<TYPE>> NAME(A, vector<TYPE>(B, (INIT)))\n\nint main()\n{\n    int n;\n    cin >> n;\n    struct Node{\n        int idx = -1;\n        ull cost = 1;\n        ull costSum = 0;\n    };\n    map<ull, Node> mp;\n    REP(i, n) \n    {\n        ull a;\n        cin >> a;\n        mp[a].idx = i;\n    }\n\n    struct Edge{\n        int i;\n        int j;\n    };\n    VEC(Edge, 0, edgeAry, Edge());\n    for( auto it = mp.rbegin(); it != mp.rend(); ++it )\n    {\n        const ull d = it->first;\n        Node& node = it->second;\n\n        if( d == mp.begin()->first ) break;\n        ull sub = n - 2*node.cost;\n\n        auto& nextNode = mp[d-sub];\n        if( nextNode.idx == -1 )\n        {\n            cout << -1 << endl;\n            return 0;\n        }\n        nextNode.cost += node.cost;\n        nextNode.costSum += node.cost + node.costSum;\n\n        Edge edge;\n        edge.i = node.idx;\n        edge.j = nextNode.idx;\n        edgeAry.push_back( edge );\n    }\n    \n    {\n        const ull d = mp.begin()->first;\n        Node& node = mp.begin()->second;\n        \n        if( node.costSum != d )\n        {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    for( auto& e : edgeAry )\n    {\n        cout << e.i + 1 << \" \" << e.j + 1 << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<long long> d(n);\n\tlong long miii = 1e15;\n\tint cent = -1;\n\tmap<long long, int> mp;\n\trep(i, n) {\n\t\tscanf(\"%lld\", &d[i]);\n\t\tmp[d[i]] = i;\n\t\tif (miii > d[i]) {\n\t\t\tmiii = d[i];\n\t\t\tcent = i;\n\t\t}\n\t}\n\tset<long long> st;\n\trep(i, n) {\n\t\tif (miii != d[i]) {\n\t\t\tst.insert(d[i]);\n\t\t}\n\t}\n\tvector<pair<int, int>> ans;\n\tauto no = [](){ cout << -1 << endl; exit(0); };\n\twhile (true) { \n\t\tif (ans.size() >= n - 1) break;\n\t\tlong long mi;\n\t\tfor (auto it : st) {\n\t\t\tmi = it;\n\t\t\tbreak;\n\t\t}\n\t\tst.erase(mi);\n\t\tint id = mp[mi];\n\t\tans.push_back({id, cent});\n\t\tlong long dist = mi - miii;\n\t\tlong long k = (n - dist) / 2;\n\t\tk --;\n\t\tdist += 2;\n\t\tlong long cur = mi;\n\t\tlong long prev;\n\t\tint orik = k;\n\t\tvector<int> erased;\n\t\twhile (k --) {\n\t\t\tprev = cur;\n\t\t\tcur += dist;\n\t\t\tif (st.count(cur) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tst.erase(cur);\n\t\t\terased.push_back(cur);\n\t\t\tint pid = mp[prev];\n\t\t\tint cid = mp[cur];\n\t\t\tans.push_back({pid, cid});\n\t\t\tdist += 2;\n\t\t}\n\t\t// rollback\n\t\tbool again = false;\n\t\tif (k > -1) {\n\t\t\tint rb = orik - k - 1;\n\t\t\twhile (rb --) {\n\t\t\t\tans.pop_back();\n\t\t\t}\n\t\t\tfor (auto it : erased) {\n\t\t\t        st.insert(it);\n\t\t\t}\n\t\t\tagain = true;\n\t\t}\n\t\tif (again) {\n\t\t\tdist = mi - miii;\n\t\t\tk = (n + dist) / 2;\n\t\t\tk --;\n\t\t\tdist += 2;\n\t\t\tlong long cur = mi;\n\t\t\tlong long prev;\n\t\t\twhile (k --) {\n\t\t\t\tprev = cur;\n\t\t\t\tcur += dist;\n\t\t\t\tif (st.count(cur) == 0) {\n\t\t\t\t\tno();\n\t\t\t\t}\n\t\t\t\tst.erase(cur);\n\t\t\t\tint pid = mp[prev];\n\t\t\t\tint cid = mp[cur];\n\t\t\t\tans.push_back({pid, cid});\n\t\t\t\tdist += 2;\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int>> g(n);\n\trep(i, n - 1) {\n\t\tint a = ans[i].first;\n\t\tint b = ans[i].second;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tvector<long long> s(n);\n\tvector<int> dis(n);\n\tvector<int> sz(n);\n\tfunction<void (int, int)> dfs = [&](int u, int prev) {\n\t\tsz[u] = 1;\n\t\tfor (auto v : g[u]) if (v != prev) {\n\t\t\tdis[v] = dis[u] + 1;\n\t\t\tdfs(v, u);\n\t\t\tsz[u] += sz[v];\n\t\t}\n\t};\n\tdfs(0, -1);\n\trep(i, n) s[0] += dis[i];\n\tfunction<void (int, int)> dfs2 = [&](int u, int prev) {\n\t\tfor (auto v : g[u]) if (v != prev) {\n\t\t\ts[v] = s[u] + n - sz[v] * 2;\n\t\t\tdfs2(v, u);\n\t\t}\n\t};\n\tdfs2(0, -1);\n\tsort(s.begin(), s.end());\n\tsort(d.begin(), d.end());\n\tif (s != d) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tfor (auto it : ans) printf(\"%d %d\\n\", it.first + 1, it.second + 1);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,s,t) for(int i=(s);i<(t);++i)\n#define per(i,s,t) for(int i=((t)-1);i>=s;--i)\n#define repb(i,s,t) for(int i=(s);i<=(t);++i)\n#define lepb(i,s,t) for(int i=(s);i>=(t);--i)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)x.size())\n#define mst(a,b) memset(a,b,sizeof(a))\n#define dd(x) cout<<#x<<'='<<x<<' '\n#define de(x) cout<<#x<<'='<<x<<'\\n'\n#define fi first\n#define se second\n#define sq(x) ((x)*(x))\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef double db;\n\nconst int inf = 0x3f3f3f3f;\nconst ll inff = 4557430888798830399ll;\nconst db eps = 1e-10;\nconst db pi = acos(-1.0);\nconst ll mod = 1e9+7;\n\n#define maxn 100005\n\nmap<ll,int> id;\nint n,sz[maxn],p[maxn];\nint fa(int n){return n==p[n]?n:p[n]=fa(p[n]);}\nll dis[maxn],dis1[maxn];vector<int> N[maxn];\n\nvoid dfs(int u)\n{\n\tfor(auto v:N[u])dfs(v),dis[u]+=dis[v]+sz[v];\n}\n\nvoid dfs1(int u,ll d)\n{\n\tdis1[u]=dis[u]+d;\n\tfor(auto v:N[u])dfs1(v,d+dis[u]-(dis[v]+sz[v])+(n-sz[v]));\n}\n\nint main()\n{\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tint u,v;ll x,y;vector<pair<ll,int> > D,Z;vector<pii> E;\n\tcin>>n;\n\trepb(i,1,n){cin>>x;D.pb({x,i});id[x]=i;}\n\tsort(all(D));reverse(all(D));mst(sz,0);\n\trep(i,0,sz(D)-1)\n\t{\n\t\tx=D[i].fi;u=D[i].se;sz[u]+=1;\n\t\ty=x-n+2*sz[u];v=id[y];\n\t\tif(v==0||y>=x){cout<<-1<<endl;return 0;}\n\t\tE.pb(mp(min(u,v),max(u,v)));sz[v]+=sz[u];N[v].pb(u);\n\t}\n\trepb(i,1,n)p[i]=i;sort(all(E));\n\trep(i,0,sz(E))if(fa(E[i].fi)!=fa(E[i].se))p[fa(E[i].fi)]=fa(E[i].se);\n\trepb(i,1,n)if(fa(i)!=fa(1)){cout<<-1<<endl;return 0;}\n\tdfs(D.back().se);dfs1(D.back().se,0);\n\trepb(i,1,n)Z.pb({dis1[i],i});\n\tsort(all(Z));reverse(all(Z));\n\tif(Z!=D){cout<<-1<<endl;return 0;}\n\trep(i,0,sz(E))cout<<E[i].fi<<\" \"<<E[i].se<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define int long long\n#define ll long long\n\n\nint n,m;\nconst int Max = (int)1e5+1;\nvector<int> adj[Max];\nbool visited[Max];\nint parent[Max];\nint numNodes[Max], sizes[Max];\nint subtreeSize[Max] = {0};\nll sum1[Max], sum2[Max];\n\nvoid dfs(int node) {\n    visited[node] = true;\n    numNodes[node] = 1;\n    sum1[node] = 0;\n    for(int to : adj[node]) {\n        if(!visited[to]) {\n            dfs(to);\n            numNodes[node] += numNodes[to];\n            sum1[node] += sum1[to] + (ll)numNodes[to];\n        }\n    }\n}\n\nvoid bfs(int start, ll treeSize) {\n    queue<int> q;\n    q.push(start);\n    visited[start] = true;\n    sum2[start] = sum1[start];\n    while(!q.empty()) {\n        int parent = q.front();\n        q.pop();\n        for(int node : adj[parent]) {\n            if(!visited[node]) {\n                q.push(node);\n                visited[node] = true;\n                sum2[node] = sum1[node];\n                sum2[node] += sum2[parent]-sum1[node]-(ll)numNodes[node];\n                sum2[node] += treeSize-(ll)numNodes[node];\n            }\n        }\n    }\n}\n\nint32_t main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    fill(subtreeSize, subtreeSize+n, 1);\n    vector<pair<int, int>> arr(n);\n    for(int i = 0; i < n; ++i) {\n        cin >> arr[i].first;\n        arr[i].second = i+1;\n    }\n    sort(arr.begin(), arr.end());\n    map<int, int> toNode;\n    for(int i = 0; i < n; ++i) {\n        toNode[arr[i].first] = i;\n    }\n    \n    //subtreeSize\n    vector<pair<int, int>> edges;\n    for(int i = n-1; i > 0; --i) {\n        int nextSize = arr[i].first + 2*subtreeSize[i] - n;\n        if(!toNode.count(nextSize)) {\n            cout << \"-1\\n\";\n            return 0;\n        }\n        int par = toNode[nextSize];\n        adj[par].push_back(i);\n        adj[i].push_back(par);\n        edges.push_back({par, i});\n        subtreeSize[par] += subtreeSize[i];\n    }\n    fill(visited, visited+n, false);\n    dfs(0);\n    fill(visited, visited+n, false);\n    bfs(0, n);\n    for(int i = 0; i < n; ++i) {\n        if(sum2[i] != arr[i].first) {\n            cout << \"-1\\n\";\n            return 0;\n        }\n    }\n    for(auto &p : edges) {\n        cout << arr[p.first].second << ' ' << arr[p.second].second << '\\n';\n    }\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\n#define R register\n#define ll long long\nconst int MAXN=1e5+10;\n\nint n;\nll D[MAXN];\nint siz[MAXN];\nmap<ll,int> loc;\nset<ll> st;\n\nstruct edge\n{\n\tint fr,to,next;\n}e[MAXN];\nint tot;\nint head[MAXN];\nint dep[MAXN];\n\ninline void add(int x,int y)\n{\n\ttot++;\n\te[tot].fr=x;e[tot].to=y;e[tot].next=head[x];head[x]=tot;\n}\n\ninline void dfs(int x,int fx)\n{\n\tdep[x]=dep[fx]+1;\n\tfor(R int i=head[x];i;i=e[i].next)\n\t{\n\t\tint y=e[i].to;\n\t\tif(y==fx) continue;\n\t\tdfs(y,x);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(R int i=1;i<=n;i++) \n\t{\n\t\tscanf(\"%lld\",&D[i]);\n\t\tsiz[i]=1;\n\t\tloc[D[i]]=i;\n\t\tst.insert(D[i]);\n\t}\n\tint rt=0,cnt=0;\n\twhile(st.size()&&cnt<n-1)\n\t{\n\t\tll dx=*st.rbegin(),dy;\n\t\tint x,y;\n\t\tst.erase(dx);\n\t\tx=loc[dx];\n\t\tdy=dx+siz[x]*2-n;\n\t\ty=loc[dy];\n\t\tif(y==0) {printf(\"-1\\n\");return 0;}\n\t\tsiz[y]+=siz[x];\n\t\tadd(x,y);add(y,x);\n\t\tcnt++;\n\t}\n\trt=loc[*st.begin()];\n\tdfs(rt,0);\n\tll ans=0;\n\tfor(R int i=1;i<=n;i++) ans+=dep[i];\n\tif(ans-n!=D[rt]) {printf(\"-1\\n\");return 0;}\n\t\n\tfor(R int i=1;i<=tot;i+=2)\n\t{\n\t\tint x=e[i].fr,y=e[i].to;\n\t\tif(x>y) swap(x,y);\n\t\tprintf(\"%d %d\\n\",x,y);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+5;\nmap<long long,int>ma;\nlong long a[N];\nint n,b[N],vi[N],si[N],fa[N];\nbool com(int x,int y){\n\treturn a[x]>a[y];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i]);\n\t\tma[a[i]]=b[i]=i;\n\t}\n\tsort(b+1,b+n+1,com);\n\tfor(int i=1;i<=n;i++)\tsi[i]=1;\n\tfor(int i=1;i<n;i++){\n\t\tint k=ma[a[b[i]]-n+si[b[i]]*2];\n\t\tfa[b[i]]=k,si[k]+=si[b[i]];\n\t\tvi[b[i]]=1;\n\t\tif(!k||vi[k]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d %d\\n\",b[i],fa[b[i]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define N 100000\n#define mp make_pair\n#define X first\n#define Y second\n#define pb push_back\nint n;\nint dsum[N+1],sz[N+1];\nvector<int> nei[N+1];\nint dfs(int x=1,int dep=0,int fa=0){\n//\tcout<<x<<\" visiting\\n\";\n\tint res=dep;\n\tfor(int i=0;i<nei[x].size();i++){\n\t\tint y=nei[x][i];\n\t\tif(y!=fa)res+=dfs(y,dep+1,x);\n\t}\n\treturn res;\n}\npair<int,int> pc[N+1];int oid[N+1];\nvector<pair<int,int> > ans;\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",dsum+i),pc[i]=mp(dsum[i],i);\n\tsort(dsum+1,dsum+n+1);sort(pc+1,pc+n+1);\n\tfor(int i=1;i<=n;i++)oid[i]=pc[i].Y;\n\tfill(sz+1,sz+n+1,1);\n\tfor(int i=n;i>=2;i--){\n\t\tint fadsum=dsum[i]+2*sz[i]-n;\n\t\tint fd=lower_bound(dsum+1,dsum+i,fadsum)-dsum;\n\t\tif(dsum[fd]!=fadsum)return puts(\"-1\"),0;\n\t\tsz[fd]+=sz[i];\n\t\tans.pb(mp(fd,i));\n\t\tnei[fd].pb(i);nei[i].pb(fd);\n\t}\n//\tfor(int i=1;i<=n;i++){for(int j=0;j<nei[i].size();j++)cout<<nei[i][j]<<\" \";puts(\"\");}\n\tif(dfs()!=dsum[1])return puts(\"-1\"),0;\n\tfor(int i=0;i<ans.size();i++)printf(\"%lld %lld\\n\",oid[ans[i].X],oid[ans[i].Y]);\n\treturn 0;\n}\n\n/*1\n7\n10\n15\n13\n18\n11\n14\n19\n*/\n/*2\n2\n1\n2\n*/\n/*3\n15\n57\n62\n47\n45\n42\n74\n90\n75\n54\n50\n66\n63\n77\n87\n51\n*/"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <ctime>\n#include <vector>\n#include <fstream>\n#include <list>\n#include <iomanip>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define ms(s) memset(s, 0, sizeof(s))\nconst ll INF = 1e9;\ninline ll read(){\n\tll X = 0,w = 0 ;\n\tchar ch = 0;\n\twhile(!isdigit(ch)) {w |= ch == '-';ch = getchar();}\n\twhile(isdigit(ch)) X = (X<<3) + (X<<1) + (ch ^ 48),ch = getchar();\n\treturn w ? -X : X;\n}\nll dat[100005];\npair<ll,ll> p[100005];\nll sz[100005];\nll from[100005];\nll to[100005];\nll n;\nint main()\n{\n\tcin>>n;\n\tfor(ll i=0;i<n;i++)\n\t{\n\t\tcin>>dat[i];\n\t\tp[i]=make_pair(dat[i],i);\n\t}\n\tsort(p,p+n);\n\tll id=0;\n\tll sum=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tsz[i]=1;\n\t}\n\tfor(ll i=n-1;i>=1;i--)\n\t{\n\t\tll curid=p[i].second;\n\t\tll tmp=p[i].first;\n\t\tll nx=n-2*sz[curid];\n\t\tif(nx<=0)\n\t\t{\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tll pos=lower_bound(p,p+n,make_pair(tmp-nx,0LL))-p;\n\t\tif(p[pos].first!=tmp-nx)\n\t\t{\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tfrom[id]=p[i].second;\n\t\tto[id++]=p[pos].second;\n\t\tsum+=sz[curid]*(n-sz[curid])*2;\n\t\tsz[p[pos].second]+=sz[curid];\n\t}\n\tll ans=0;\n\tfor(ll i=0;i<n;i++)\n\t{\n\t\tans+=dat[i];\n\t}\n\tif(sum!=ans)\n\t{\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tfor(ll i=0;i<id;i++)\n\t{\n\t\tcout<<from[i]+1<<\" \"<<to[i]+1<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nconst long long mo=50000007;\nconst int maxn=200010;\n\nint n,m,id[maxn],fa[maxn];\nlong long d[maxn],siz[maxn],ans,js[maxn];\nint tot,nex[maxn*2],las[maxn*2],tov[maxn*2];\nint hs[mo+10];\n\nvoid con(int x,int y)\n{\n\ttot++;\n\ttov[tot]=y;\n\tnex[tot]=las[x];\n\tlas[x]=tot;\n}\n\nvoid insert(long long x,int id)\n{\n\tlong long i=x%mo;\n\twhile (hs[i]!=0)\n\t{\n\t\ti++;\n\t\tif (i==mo) i=0;\n\t}\n\ths[i]=id;\n}\n\nlong long find(long long x)\n{\n\tlong long i=x%mo;\n\twhile (hs[i]!=0 && d[hs[i]]!=x)\n\t{\n\t\ti++;\n\t\tif (i==mo) i=0;\n\t}\n\treturn hs[i];\n}\n\nvoid qsort(int l,int r)\n{\n\tint i=l;int j=r;\n\tlong long m=d[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (d[i]>m) i++;\n\t\twhile (d[j]<m) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(d[i],d[j]);\n\t\t\tswap(id[i],id[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort(l,j);\n\tif (r>i) qsort(i,r);\n}\n\nvoid dfs(int x,int ff)\n{\n\tjs[x]=js[ff]+1;\n\tfor (int i=las[x];i;i=nex[i])\n\t{\n\t\tif (tov[i]!=ff)\n\t\t{\n\t\t\tdfs(tov[i],x);\n\t\t\tans+=js[x];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&d[i]);\n\t\tid[i]=i;\n\t\tsiz[i]=1;\n\t}\n\tqsort(1,n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinsert(d[i],i);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tlong long op=d[i]-abs(n-2*siz[i]);\n\t\tlong long oq=find(op);\n\t\tif (oq==0)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfa[i]=oq;\n\t\t\tsiz[oq]+=siz[i];\n\t\t\tcon(i,oq);con(oq,i);\n\t\t}\n\t}/*\n\tdfs(n,0);\n\tif (ans!=d[n])\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\telse*/\n\t{\n\t\tfor (int i=1;i<n;i++)\n\t\t{\n\t\t\tprintf(\"%d %d\\n\",id[i],id[fa[i]]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <algorithm>\nusing namespace std;\n#define Maxn 100005\nint n,id[Maxn],par[Maxn],sz[Maxn];\nlong long a[Maxn];\nmap <long long,int> mp;\nint main()\t\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%lld\",&a[i]);\n\t\tmp[a[i]]=i;\n\t\tid[i]=i;\n\t\tsz[i]=1;\n\t}\n\tsort(id+1,id+n+1,[&](const int &a,const int &b)->bool{return a[x]>a[y];});\n\tfor (int i=1;i<n;++i)\n\t{\n\t\tint x=id[i];\n\t\tpar[x]=mp[a[x]-n+2*sz[x]];\n\t\tif (!par[x]) return (int)puts(\"-1\")*0;\n\t\tsz[par[x]]+=sz[x];\n\t}\n\tfor (int i=1;i<n;++i) a[id[n]]-=sz[id[i]];\n\tif (a[id[n]]) return (int)puts(\"-1\")*0;\n\tfor (int i=1;i<n;++i) printf(\"%d %d\\n\",id[i],par[id[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <numeric>\n#include <map>\n#define fail return puts(\"-1\"), 0\n\nconst int N = 1e5 + 5, M = 2e5 + 5;\n\nint n, tot, lnk[N], ter[M], nxt[M], sz[N], fa[N];\nlong long dis[N], d[N];\nstd::map<long long, int> mp;\n\nvoid add(int u, int v) {\n\tter[++tot] = v, nxt[tot] = lnk[u], lnk[u] = tot;\n}\nvoid dfs(int u, int p) {\n\tfor (int i = lnk[u]; i; i = nxt[i]) {\n\t\tint v = ter[i];\n\t\tif (v == p) continue;\n\t\tdis[v] = dis[u] + 1;\n\t\tdfs(v, u);\n\t}\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &d[i]);\n\t\tmp[d[i]] = i, sz[i] = 1;\n\t}\n\tint cnt = 0;\n\tfor (auto it = mp.rbegin(); it != mp.rend(); it++) {\n\t\tint v = it->second, u = mp[it->first + 2 * sz[v] - n];\n\t\tif (!u || u == v) fail;\n\t\tadd(u, v), add(v, u);\n\t\tfa[v] = u, sz[u] += sz[v];\n\t\tif (++cnt == n - 1) break;\n\t}\n\tint rt = mp.begin()->second;\n\tdfs(rt, 0);\n\tif (std::accumulate(dis + 1, dis + n + 1, 0LL) != d[rt]) fail;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (fa[i]) printf(\"%d %d\\n\", fa[i], i);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint PREP = (cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(9), 0);\n//int SEGV = getenv(\"D\") || (exit(system(\"D= SEGFAULT_SIGNALS=all catchsegv ./prog.exe\") >> 8), 0);\nvoid fail() {\n    cout << -1 << '\\n';\n    exit(0);\n}\nint main() {\n    int N; cin >> N;\n    if (N == 2) fail();\n    vector<Int> D(N);\n    map<Int, pair<int, int>> M; // D[i] -> idx, num\n    vector<vector<int>> G(N);\n    for (int i = 0; i < N; i++) {\n        cin >> D[i];\n        M[D[i]] = make_pair(i, 1);\n    }\n    int root = -1;\n    for (auto it = rbegin(M), ite = rend(M); it != ite; ++it) {\n        int idx, num; tie(idx, num) = it->second;\n        if (num == N) { root = idx; continue; }\n        Int diff = num - (N - num);\n        if (diff >= 0) fail();\n        Int dnext = it->first + diff;\n        if (!M.count(dnext)) fail();\n        G[M[dnext].first].emplace_back(idx);\n        M[dnext].second += num;\n    }\n    auto recur = [&](auto&& recur, int node) -> pair<int, int> {\n        int val = 0, cnt = 1;\n        for (int next : G[node]) {\n            auto p = recur(recur, next);\n            val += p.first + p.second;\n            cnt += p.second;\n        }\n        return { val, cnt };\n    };\n    if (recur(recur, root).first != D[root]) {\n        fail();\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j : G[i]) {\n            cout << i + 1 << ' ' << j + 1 << '\\n';\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <string.h>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <cassert>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <sstream>\n#include <functional>\n#include <iomanip>\n#include <bitset>\n//#include <windows.h>  //Should be deleted when using AtCoder&POJ\nusing namespace std;\n\n#define ll long long\n#define pii pair<int,int>\n#define qi ios::sync_with_stdio(0)\n/**==Info==\n*Program:6\n*Problem:Distance Sums\n*Date:2019-7-12\n*Algorithm:Orange Boy's Greedy and Sorting\n*Stats:Unknown*/\n\nbool debug=false;\n\n\ntemplate<typename T1,typename T2> ostream& operator<<(ostream& o,pair<T1,T2> p){\n\to<<\"{\";\n\to<<p.first<<\",\"<<p.second;\n\to<<\"}\";\n\treturn o;\n}\n\nint n;\n\npriority_queue<pair<ll,int>> judging;\n\nll pen[100005];\n\nmap<ll,int> toId;\n\nint fa[100005];\n\nint getFa(int x){\n\tif(fa[x]==x){\n\t\treturn x;\n\t}\n\treturn fa[x]=getFa(fa[x]);\n}\n\nvoid Union(int a,int b){\n\tif(fa[a]==fa[b]){\n\t\treturn;\n\t}\n\tfa[getFa(a)]=getFa(b);\n}\n\nint main(int argc,char* argv[]){\n\tqi;\n\tcin>>n;\n\t\n\tfill(pen,pen+n,2);\n\t\n\tfor(int i=0;i<n;i++){\n\t\tll a;\n\t\tcin>>a;\n\t\tjudging.push(make_pair(a,i));\n\t\ttoId[a]=i;\n\t}\n\t\n\tvector<pii> ans;\n\t\n\tint cnt=0;\n\twhile(!judging.empty()){\n\t\tauto last=judging.top();\n\t\tjudging.pop();\n\t\t\n\t\tll tochk=last.first-(n-pen[last.second]);\n\t\tif(tochk<=last.first && toId.count(tochk)){\n\t\t\tint node=toId[tochk];\n\t\t\tans.push_back(make_pair(last.second,node));\n\t\t\tpen[node]=pen[last.second]+2;\n\t\t}else{\n\t\t\tcerr<<\"WARNING:NO NODE FOUND\"<<endl;\n\t\t\tcnt++;\n\t\t\tif(cnt==2){\n\t\t\t\tcout<<-1<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tfa[i]=i;\n\t}\n\tfor(pii x:ans){\n\t\tUnion(x.first,x.second);\n\t}\n\t\n\tset<int> fafa;\n\tfor(int i=0;i<n;i++){\n\t\tfafa.insert(getFa(i));\n\t}\n\tif(fafa.size()!=1){\n\t\tcout<<\"-1\";\n\t\treturn 0;\n\t}\n\tfor(pii x:ans){\n\t\tcout<<x.first+1<<' '<<x.second+1<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nusing ll = int64_t;\n\nint main() {\n  int n;\n  cin>>n;\n  map<ll, pair<int, int>> m;\n  REP(i,n) {\n    ll d;\n    cin>>d;\n    m[d] = make_pair(1, i+1);\n  }\n  bool ok = true;\n  vector<pair<int, int>> edges;\n  while (m.size() > 1) {\n    const auto itr = m.rbegin();\n    ll d = itr->first;\n    int k, i;\n    tie(k, i) = itr->second;\n    m.erase(prev(m.end()));\n    ll diff = n-2*k;\n    if (diff <= 0 || m.count(d - diff) == 0) {\n      ok = false;\n      break;\n    }\n    int l, j;\n    tie(l, j) = m[d-diff];\n    edges.emplace_back(i, j);\n    m[d-diff] = make_pair(l+k, j);\n  }\n  if (ok) {\n    for (auto p : edges) {\n      int u, v;\n      tie(u, v) = p;\n      cout << u << ' ' << v << endl;\n    }\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define llong long long\n#define pii pair<llong,int>\n#define fi first\n#define se second\n\nint n;\npii a[100100];\nllong d[100100];\nint siz[100100];\nllong cd;\n\nstruct data{\n\tint to,nxt;\n}mp[200200];\nint head[100100],cnt;\nvoid link(int x,int y)\n{\n\tmp[++cnt].to=y;\n\tmp[cnt].nxt=head[x];\n\thead[x]=cnt;\n}\nstruct UFS{\n\tint fa[100100];\n\tvoid reset(){for(int i=1;i<=n;++i)fa[i]=i;}\n\tint find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\n\tbool merge(int x,int y)\n\t{\n\t\tint fx=find(x),fy=find(y);\n\t\tif(fx==fy)return 1;\n\t\tfa[fx]=fy;\n\t\treturn 0;\n\t}\n}ufs;\nint ed[100100][2];\nvoid dfs(int x,int fa,int nd)\n{\n\tcd+=nd;\n\tfor(int i=head[x];i;i=mp[i].nxt)\n\t\tif(mp[i].to!=fa)\n\t\t\tdfs(mp[i].to,x,nd+1);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)scanf(\"%lld\",&a[i].fi),a[i].se=i;\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;++i)d[i]=a[i].fi,siz[i]=1;\n\tufs.reset();\n\tfor(int i=n;i>1;--i)\n\t{\n//\t\tcout<<endl;\n//\t\tcout<<\"i: \"<<i<<endl;\n\t\tint np=a[i].se;\n\t\tint nd=d[i]+siz[np]-(n-siz[np]);\n\t\tint p=lower_bound(d+1,d+n+1,nd)-d;\n\t\tif(d[p]!=nd)puts(\"-1\"),exit(0);\n\t\tp=a[p].se;\n//\t\tcout<<\"np: \"<<np<<\" siz: \"<<siz[np]<<\" d: \"<<d[i]<<\" nd: \"<<nd<<\" p: \"<<p<<endl;\n\t\tlink(p,np);link(np,p);\n\t\ted[i-1][0]=p,ed[i-1][1]=np;\n\t\tsiz[p]+=siz[np];\n\t\tif(ufs.merge(np,p))puts(\"-1\"),exit(0);\n\t}\n\tdfs(a[1].se,0,0);\n\tif(cd!=d[1])puts(\"-1\"),exit(0);\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",ed[i][0],ed[i][1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<vector>\n#include<queue>\n#include<deque>\n#define ll long long\n#define mp make_pair\n#define rep(i,x,y) for(int i=(x);i<=(y);++i)\n#define r0p(i,n) for(int i=0;i<n;++i)\n#pragma GCC optimize(1)\n#pragma G++ optimize(1)\n#pragma GCC optimize(2)\n#pragma G++ optimize(2)\n#pragma GCC optimize(3)\n#pragma G++ optimize(3)\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#define pii pair<int,int>\n#pragma GCC diagnostic error \"-std=c++11\"\nusing namespace std;\ninline void rdl(long long &val){\n    long long x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n\t}\n\twhile(ch>='0' and ch<='9'){\n\t    x=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n    val=x*f;\n}\ninline void rdi(int &val){\n    int x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    val=x*f;\n}\ninline long long rdl(){\n    long long x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline int rdi(){\n    int x=0;\n    int f=1;\n\tchar ch=getchar();\n\twhile((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n\tif(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline void write(int x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\ninline void _write(int x){\n\twrite(x);\n\tputchar(' ');\n}\ninline void print(int x){\n\twrite(x);\n\tputchar('\\n');\n}\ninline void write(ll x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\ninline void _write(ll x){\n\twrite(x);\n\tputchar(' ');\n}\ninline void print(ll x){\n\twrite(x);\n\tputchar('\\n');\n}\nstruct dsu{\n\tint par[200200];\n\tinline void init(int _n){for(int i=0;i<_n;++i) par[i]=i;}\n\tinline int find(int now){\n\t\tif(par[now]==now) return now;\n\t\treturn par[now]=find(par[now]);\n\t}\n\tinline bool uni(int a, int b){\n\t\tint Pa(find(a)),Pb(find(b));\n\t\tif(Pa==Pb) return false;\n\t\tpar[Pa]=Pb;\n\t\treturn true;\n\t}\n};\nmap<ll,int> m;\nmap<int,ll>m2;\nvector<pair<int,int> >ans;\nint n;\nll x;\nsigned main(){\n\trdi(n);\n\tint i,j;\n\tll mn=100000000000000ll;\n\tll cnt=n;\n\tfor(i=1;i<=n;++i) rdl(x),m[x]=i,mn=min(mn,x),m2[i]=x;\n\twhile(cnt>1){\n\t\tmap<int,ll>::iterator it=m2.end();it--;\n\t\tll t=it->second;\n\t\tll now=n;\n\t\tll tt=t;\n\t\twhile(t>mn){\n\t\t\tt-=now-2;\n\t\t\tnow-=2;\n\t\t\tif(!m[t]){\n\t\t\t\tprint(-1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(now<=0){\n\t\t\t\tprint(-1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tans.push_back(mp(m[t],m[tt]));\n\t\t\tm2.erase(m[tt]);\n\t\t\tm.erase(tt);\n\t\t\ttt=t;\n\t\t\t--cnt;\n\t\t}\n\t}\n\tfor(int i=0;i<ans.size();++i) _write(ans[i].first),print(ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nvector<l_l> D;\nll SIZE[100500];\nmap<ll, ll> mp;\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N;\n    cin >> N;\n    D.resize(N);\n    for(int i = 1; i <= N; i++) {\n        cin >> D[i-1].first;\n        D[i-1].second = i;\n        SIZE[i] = 1;\n        mp[D[i-1].first] = i;\n    }\n    sort(D.begin(), D.end(), greater<l_l>());\n    vector<l_l> ans;\n    for(int i = 0; i < N - 1; i++) {\n        int index = D[i].second;\n        ll val = D[i].first;\n        val += SIZE[index] - (N - SIZE[index]);\n        if(SIZE[index] * 2 >= N) {\n            cout << -1 << endl;\n            return 0;\n        }\n        if(mp[val] == 0) {\n            cout << -1 << endl;\n            return 0;\n        }\n        SIZE[mp[val]] += SIZE[index];\n        ans.push_back({index, mp[val]});\n    }\n    for(auto e : ans) cout << e.first << \" \" << e.second << endl;\n    return 1;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define ln                '\\n'\n#define all(dat)           dat.begin(), dat.end()\n#define loop(i, to)        for (int i = 0; i < to; ++i)\n#define cont(i, to)        for (int i = 1; i <= to; ++i)\n#define circ(i, fr, to)    for (int i = fr; i <= to; ++i)\n#define foreach(i, dat)    for (__typeof(dat.begin()) i = dat.begin(); i != dat.end(); ++i)\n\ntypedef long long          num;\n\nusing namespace std;\n\nconst int nsz = 1e5;\nint n, rt, siz[nsz + 5];\nnum w[nsz + 5];\nmap<num, int> id;\nvector<int> g[nsz + 5];\nvector<pair<int, int>> ans;\n\nnum inline cmp(num a, num b) {\n    return a > b;\n}\n\nint calc(int u = rt, int dep = 0) {\n    int res = dep;\n    for (int v : g[u]) {\n        res += calc(v, dep + 1);\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> n;\n    rt = n;\n    cont (i, n) {\n        cin >> w[i];\n    }\n    fill(siz, siz + sizeof(siz) / sizeof(int), 1);\n    sort(w + 1, w + n + 1, cmp);\n    cont (i, n) {\n        id[w[i]] = i;\n    }\n    cont (u, n) {\n        if (u == rt)  continue;\n        int v = id[w[u] - n + 2 * siz[u]];\n        if (!v) {\n            cout << -1 << ln;\n            return 0;\n        }\n        siz[v] += siz[u];\n        g[v].push_back(u);\n        ans.push_back({u, v});\n    }\n    if (calc() != w[n]) {\n        cout << -1 << ln;\n        return 0;\n    }\n    for (pair<int, int> p : ans) {\n        cout << p.first << ' ' << p.second << ln;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/********************************************************************************\n\t\n\tCode by a weak man who named CYJian, and he hopes the code can get more points.\n\n\tAlgorithm: \n\n ********************************************************************************/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n//{{{ FAST IO AND SOME FUNCTIONS\nconst int __SIZE = 1 << 18;\nchar ibuf[__SIZE], *iS, *iT;\n\n#define ge (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n#define ri read_int()\n#define rl read_ll()\n#define ra read_alpha()\n#define FILE(s) freopen(s\"in\", \"r\", stdin), freopen(s\"out\", \"w\", stdout)\n\ntemplate<typename T>\ninline void read(T &x) {\n\tchar ch, t = 0; x = 0;\n\twhile(!isdigit(ch = ge)) t |= ch == '-';\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = ge;\n\tx = t ? -x : x;\n}\ninline char read_alpha() { char c = ge; while(!isalpha(c) && c != EOF) c = ge; return c; }\ninline int read_int() { int x; return read(x), x; }\ninline ll read_ll() { ll x; return read(x), x; }\n\ntemplate<typename T> inline void chkmin(T&a, T b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T&a, T b) { a = a > b ? a : b; }\n//}}}\n\nconst int MAXN = 100010;\n\nstruct Node {\n\tll d; int id;\n\t\n\tNode() {}\n\tNode(ll d, int x):d(d), id(x) {}\n\n\tfriend bool operator < (Node a, Node b) { return a.d < b.d; }\n}d[MAXN];\n\nint sz[MAXN];\nint u[MAXN];\nint v[MAXN];\n\nint main() {\n#ifdef LOCAL\n\tFILE(\"\");\n#endif\n\tint n = ri;\n\tfor(int i = 1; i <= n; i++) d[i] = Node(rl, i), sz[i] = 1;\n\tsort(d + 1, d + 1 + n);\n\tll dis = 0, N = 0;\n\tfor(int i = n; i > 1; i--) {\n\t\tint p = lower_bound(d + 1, d + 1 + n, Node(d[i].d - n + (sz[i] << 1), 0)) - d;\n\t\tif(d[p].d != d[i].d - n + (sz[i] << 1)) return puts(\"-1\"), 0;\n\t\tsz[p] += sz[i], ++N, u[N] = d[i].id, v[N] = d[p].id, dis += sz[i];\n\t}\n\tif(dis != d[1].d) puts(\"-1\");\n\telse\n\t\tfor(int i = 1; i <= N; i++)\n\t\t\tprintf(\"%d %d\\n\", u[i], v[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define retrun return\n#define cpnst const\n#include<set>\n#include<cstdlib>\ntypedef long long ll;\nint n;\nll d[111111];\nstruct pii\n{ll x,len;int p,s;};\nbool operator<(cpnst pii x,cpnst pii y)\n{return x.x<y.x;}\nvoid throwb()\n{puts(\"-1\"),exit(0);}\nstd::multiset<pii>s;\nvoid push(ll x,ll l,int y,int z)\n{s.insert(pii{x,l,y,z});}\nvoid pop(ll x,ll l,int y,int z)\n{s.erase(s.find(pii{x,l,y,z}));}\nvoid push(pii g)\n{s.insert(g);}\nvoid pop(pii g)\n{s.erase(s.find(g));}\nint x[111111],y[111111];\nvoid print()\n{for(register int i=1;i<n;i++)printf(\"%d %d\\n\",x[i],y[i]);}\n#include<vector>\nstd::vector<int>v[111111];\nll check(ll s,ll dis=0)\n{\n\tll ret=dis;\n\tfor(auto t:v[s])\n\t\tret+=check(t,dis+1);\n\treturn ret;\n}\nint main()\n{\n\tregister int i;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%lld\",d+i),push(d[i],0,i,1);\n\tfor(i=n-1;i;i--)\n\t{\n\t\tpii rem=*--s.end();\n\t\tll tp=d[rem.p]+2*rem.s-n;\n\t\tpii reg=*s.lower_bound(pii{tp,0,0,0});\n\t\tif(reg.x^tp)throwb();\n\t\tpop(rem);\n\t\tif(s.find(reg)==s.end())throwb();\n\t\tpop(reg);\n\t\tx[i]=rem.p,y[i]=reg.p;\n\t\tv[y[i]].push_back(x[i]);\n\t\treg.len+=rem.len+rem.s,reg.s+=rem.s;\n\t\tpush(reg);\n\t}int rt=(*--s.end()).p;\n\tif(check(rt)!=(*--s.end()).x)throwb();\n\tprint();\n}\n/*\nGiving the world a better yourself is giving yourself a better world. \n*/"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n#include <map>\n\ntypedef long long LL;\n\nLL read() {\n  LL ans = 0; int c, f = 1;\n  while (!isdigit(c = getchar()))\n    if (c == '-') f *= -1;\n  do ans = ans * 10 + c - '0';\n  while (isdigit(c = getchar()));\n  return ans * f;\n}\n\nconst int N = 100050;\nstd::map<LL, int> M;\n\nint n, siz[N], fa[N];\n\nint main() {\n  n = read();\n  for (int i = 1; i <= n; ++i)\n    siz[M[read()] = i] = 1;\n  for (std::map<LL, int>::iterator it = --M.end(); it != M.begin(); --it) {\n    LL D = it->first;\n    int i = it->second;\n    LL t = D - n + 2 * siz[i];\n    if (!M.count(t)) { puts(\"-1\"); return 0; }\n    int j = M[t];\n    siz[fa[i] = j] += siz[i];\n  }\n  for (int i = 1; i <= n; ++i) if (fa[i])\n    printf(\"%d %d\\n\", fa[i], i);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\ntypedef long long lint;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef unsigned long long ulint;\n#define endl '\\n'\n#define fst first\n#define sed second\n#define pb push_back\n#define mp make_pair\n#define rint register int\n#define newline putchar('\\n')\n#define leave_space putchar(' ')\n#define all(x) (x).begin(), (x).end()\n#define reveal(x) cerr << #x << \" = \" << (x) << endl\n#define rep(it, f, e) for (rint it = (f); it <= (e); ++it)\n#define per(it, f, e) for (rint it = (f); it >= (e); --it)\nconst int MAXN = 1e5 + 10;\npll p[MAXN];\nint sz[MAXN];\nmap<lint, int> rec;\n#define D fst\n#define P sed\nvector<pii> opt;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL), cout.tie(NULL);\n\tint n;\n\tcin >> n;\n\trep (i, 1, n) {\n\t\tcin >> p[i].D;\n\t\tp[i].P = i;\n\t\tif (rec.find(p[i].D) != rec.end()) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\trec[p[i].D] = p[i].P;\n\t}\n\tsort(p + 1, p + n + 1, greater<pll>());\n\tfill(sz + 1, sz + n + 1, 1);\n\trep (i, 1, n - 1) {\n\t\tint u = p[i].P;\n\t\tif (n - sz[u] - sz[u] <= 0) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t} \n\t\tlint diff = p[i].D - (n - sz[u] - sz[u]);\n\t\tif (rec.find(diff) == rec.end()) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint v = rec[diff];\n\t\topt.pb(pii(u, v));\n\t\tsz[v] += sz[u];\n\t}\n\tfor (auto &v : opt) {\n\t\tif (v.fst > v.sed) swap(v.fst, v.sed);\n\t}\n\tsort(all(opt));\n\tfor (auto &v : opt) {\n\t\tcout << v.fst << ' ' << v.sed << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define N 100005\nusing namespace std;\nll n,ds,d[N],sz[N];map<ll,int>S;pair<int,int>v[N];\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&d[i]),S[d[i]]=i,sz[i]=1;\n\tsort(d+1,d+n+1);\n\tfor(int i=n;i>1;i--)\n    {\n\t\tint p=S[d[i]];ll d2=d[i]-(n-sz[p])+sz[p];\n\t\tif(S.find(d2)==S.end()){puts(\"-1\");return 0;}\n\t\tint q=S[d2];sz[q]+=sz[p];ds+=sz[p];\n\t\tv[n-i+1]=make_pair(p,q);\n\t}\n\tif(d[1]!=ds){puts(\"-1\");return 0;}\n\tfor(int i=1;i<n;i++) printf(\"%d %d\\n\",v[i].first,v[i].second);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100100;\ntypedef long long ll;\nll sum[N];int sz[N],n;\nmap<ll,int>mp;\nvector<pair<int,int> >egs;\nvoid gofail(){cout<<-1<<'\\n';exit(0);}\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n;\n\tfor(int i=1;i<=n;++i){ll x;cin>>x;mp[x]=i;sz[i]=1;sum[i]=0;}\n\tfor(;!mp.empty();){\n\t\tll u=mp.rbegin()->first;int v=mp.rbegin()->second;mp.erase(u);\n\t\tif(sz[v]==n){\n\t\t\tif(sum[v]!=u)gofail();\n\t\t\tsort(egs.begin(),egs.end());\n\t\t\tfor(auto&i:egs)cout<<i.first<<' '<<i.second<<'\\n';\n\t\t\treturn 0;\n\t\t}else{\n\t\t\tll w=u+2*sz[v]-n;\n\t\t\tif(!mp.count(w))gofail();\n\t\t\tint x=mp[w];sz[x]+=sz[v];sum[x]+=sum[v]+sz[v];\n\t\t\tegs.emplace_back(min(v,x),max(v,x));\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <random>\n#include <complex>\n#include <regex>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define quickIO()\t{cin.tie(0);\tcout.sync_with_stdio(false);}\n#define reach(i,a)\tfor(auto i:a)\n#define rep(i,n)\tfor(int i=0;i<((int)n);i++)\n#define REP(i,n)\tfor(int i=0;i<=((int)n);i++)\n#define srep(i,a,n)\tfor(int i=a;i<((int)n);i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=((int)n);i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define pb\tpush_back\ntemplate<typename T> istream& operator >> (istream& is, vector<T>& vec) {\n\tfor (T& x : vec)\tis >> x;\n\treturn is;\n}\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n\tos << \"[\";\n\trep(i, vec.size())\tos << (i ? \", \" : \"\") << vec[i];\n\tos << \"]\";\n\treturn os;\n}\ntemplate<typename T> istream& operator >> (istream& is, pair<T, T>& p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate<typename T> ostream& operator << (ostream& os, pair<T, T>& p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\";\n\treturn os;\n}\nint bitcnt(ll x) {\n\tx = ((x & 0xAAAAAAAAAAAAAAAA) >> 1) + (x & 0x5555555555555555);\n\tx = ((x & 0xCCCCCCCCCCCCCCCC) >> 2) + (x & 0x3333333333333333);\n\tx = ((x & 0xF0F0F0F0F0F0F0F0) >> 4) + (x & 0x0F0F0F0F0F0F0F0F);\n\tx = ((x & 0xFF00FF00FF00FF00) >> 8) + (x & 0x00FF00FF00FF00FF);\n\tx = ((x & 0xFFFF0000FFFF0000) >> 16) + (x & 0x0000FFFF0000FFFF);\n\tx = ((x & 0xFFFFFFFF00000000) >> 32) + (x & 0x00000000FFFFFFFF);\n\treturn x;\n}\nint bitcnt(int x) {\n\tx = ((x & 0xAAAAAAAA) >> 1) + (x & 0x55555555);\n\tx = ((x & 0xCCCCCCCC) >> 2) + (x & 0x33333333);\n\tx = ((x & 0xF0F0F0F0) >> 4) + (x & 0x0F0F0F0F);\n\tx = ((x & 0xFF00FF00) >> 8) + (x & 0x00FF00FF);\n\tx = ((x & 0xFFFF0000) >> 16) + (x & 0x0000FFFF);\n\treturn x;\n}\nll sqrtll(ll x) {\n\tll left = 0, right = x;\n\trep(i, 100) {\n\t\tll mid = (left + right) >> 1;\n\t\tif (mid*mid <= x)\tleft = mid;\n\t\telse\tright = mid;\n\t}\n\treturn left;\n}\nll gcd(ll a, ll b) {\n\treturn a % b == 0 ? b : gcd(b, a%b);\n}\n#define debug(x)\tprintf(\"Case #%d: \", x)\n#define DEBUG 0\nconst ll inf = 1e18;\nconst ld infl = 1e100;\nconst ll mod = 1e9+7;\nconst ld eps = 1e-9;\nconst int dx[] = { 1,0,-1,0,0 };\nconst int dy[] = { 0,1,0,-1,0 };\n\nint group[100010];\n\nint getGroup(int i) {\n\treturn group[i] = (i == group[i] ? group[i] : getGroup(group[i]));\n}\nvoid merge(int i, int j) {\n\ti = getGroup(i);\tj = getGroup(j);\n\tgroup[i] = group[j];\n}\n\n// 最初の2頂点はxとx-n+2があったらマージ。headのみを残す。\n// 以降x(a)とy(b)についてx+n-2*b=yやy+n-2*a=xで判断\n// x(a)は固定できるけど、y(b)が見つけられない\n// xが親になる場合はx+n=y+2*b->子になる場合はx+2*a-n=y\n// 「一番大きいdiは子になる」より再帰的に(UF?)出来そう\nint main() {\n\tll n;\tcin >> n;\n\tvll d(n);\tcin >> d;\n\tvll num(n, 1);\n\tmap<ll, ll> mp;\n\trep(i, n) {\n\t\tmp[d[i]] = i;\n\t}\n\tvector<pll> d2(n);\n\trep(i, n) {\n\t\td2[i] = mp(d[i], i);\n\t\tgroup[i] = i;\n\t}\n\tsort(all(d2));\n\tvector<pll> ret;\n\tfor (ll i = n - 1; i > 0; i--) {\n\t\tll id = d2[i].second;\n\t\tif (getGroup(id) != id)\tcontinue;\n\t\tll a = num[id];\n\t\tif (!mp.count(d[id] + 2 * a - n) || id == mp[d[id] + 2 * a - n]) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tll to = mp[d[id] + 2 * a - n];\n\t\tmp.erase(d[id]);\n\t\tmerge(id, to);\n\t\tnum[to] += num[id];\n\t\tret.push_back(mp(id + 1, to + 1));\n\t}\n\trep(i, n - 1) {\n\t\tcout << ret[i].first << \" \" << ret[i].second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <set>\n#include <vector>\n#include <numeric>\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(0);\n\n    int n;\n    cin >> n;\n    vector<pair<long long, int> > v;\n    for (long long i = 0, d; i < n; i++) {\n        cin >> d;\n        v.emplace_back(d, i);\n    }\n    vector<int> sz(n, 1);\n    sort(v.begin(), v.end());\n    vector<pair<int, int> > edges;\n    bool res = true;\n    for (auto it = v.end() - 1; res and it != v.begin(); it--) {\n        const int u = it->second;\n        const long long next_d = it->first - (n - 2 * sz[u]);\n        const auto p = make_pair(next_d, 0);\n        auto i = lower_bound(v.begin(), it, p);\n        if (i == it or i->first != next_d) {\n            res = false;\n        }\n        else {\n            edges.emplace_back(u, i->second);\n            sz[i->second] += sz[u];\n        }\n    }\n    if (res) {\n        for (auto p : edges) {\n            cout << p.first + 1 << ' '\n                 << p.second + 1 << '\\n';\n        }\n    } \n    else {\n        cout << \"-1\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#include \"Segment_Tree.h\"\n#include \"BIT.h\"\n#include \"Rational.h\"\n#include \"Position.h\"\n#include \"Factorization.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nint N;\nPP Q[100000];\nLL A[100000];\nLL P[100000];\nLL cnt[100000];\n\nbool cat(int from) {\n\tLL t = A[from] - (N - 2 * cnt[from]);\n\tLL to = lower_bound(A, A + from, t) - A;\n\tif (to == from || A[to] != t) return false;\n\tP[from] = to;\n\tcnt[to] += cnt[from];\n}\n\nvoid sub() {\n\tFill(cnt, 1);\n\tREP(i, 0, N) {\n\t\tA[i] = Q[i].first;\n\t}\n\n\tREM(i, 1, N) {\n\t\tif (!cat(i)) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tREP(i, 1, N) {\n\t\tcout << Q[i].second + 1 << ' ' << Q[P[i]].second + 1 << endl;\n\t}\n}\n\nint main() {\n\tcin >> N;\n\tREP(i, 0, N) {\n\t\tLL a;\n\t\tcin >> a;\n\t\tQ[i] = PP(a, i);\n\t}\n\tsort(Q, Q + N);\n\n\tsub();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Distance Sums\n\nusing P = pair<int64_t, int64_t>;\n\nint main() {\n  int64_t N;\n  cin >> N;\n  map<int64_t, P> mp;\n  for (size_t i = 1; i <= N; i++) {\n    int64_t x;\n    cin >> x;\n    mp[x] = make_pair(i, 1);  // 頂点番号と木のサイズ\n  }\n  if (N == 2) {\n    cout << -1 << endl;\n    return 0;\n  }\n  vector<P> graph;\n  auto enditr = mp.rend();\n  enditr--;\n  for (auto itr = mp.rbegin(); itr != enditr; ++itr) {\n    auto key = itr->first;\n    auto value = itr->second;\n    auto vertex = value.first;\n    auto size = value.second;\n    auto child_key = key - N + 2 * size;\n    if (child_key >= key) continue;\n    auto tmpitr = mp.find(child_key);\n    if (tmpitr != mp.end()) {\n      auto tmp = tmpitr->second;\n      mp.at(child_key) = make_pair(tmp.first, tmp.second + size);\n      graph.push_back(make_pair(vertex, tmp.first));\n    }\n  }\n  if (graph.size() == N - 1) {\n    for (const auto& e : graph) {\n      cout << e.first << ' ' << e.second << endl;\n    }\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\ninline long long read() {\n  long long x = 0, f = 1;\n  char ch = getchar();\n  while (!isdigit(ch)) {\n    if (ch == '-') f = -1;\n    ch = getchar();\n  }\n  while (isdigit(ch)) {\n    x = x * 10 + ch - 48;\n    ch = getchar();\n  }\n  return x * f;\n}\n\npair<long long, int> D[100050];\n\npair<int, int> edge[100050];\n\nvector<int> G[100050];\n\nint n, size[100050], tot;\n\nlong long dis[100050];\n\ninline void dfs(int u, int fa) {\n  for (int i = 0; i < G[u].size(); i++) {\n    int v = G[u][i];\n    if (v != fa) {\n      dis[v] = dis[u] + 1;\n      dfs(v, u);\n    }\n  }\n}\n\nint main() {\n  n = read();\n  for (int i = 1; i <= n; i++) {\n    long long d = read();\n    D[i] = {d, i};\n    size[i] = 1;\n  }\n  sort(D + 1, D + n + 1);\n  reverse(D + 1, D + n + 1);\n  for (int i = 1; i < n; i++) {\n    long long delta = D[i].first - n + 2 * size[i];\n    int l = 1, r = n + 1, pos = 0;\n    while (l <= r) {\n      int mid = (l + r) >> 1;\n      if (D[mid].first <= delta) {\n        r = mid - 1;\n        pos = mid;\n      } else\n        l = mid + 1;\n    }\n    if (D[pos].first != delta) {\n      puts(\"-1\");\n      return 0;\n    }\n    int u = D[i].second, v = D[pos].second;\n    G[u].push_back(v);\n    G[v].push_back(u);\n    edge[++tot] = {u, v};\n    size[pos] += size[i];\n  }\n  dfs(D[n].second, 0);\n  long long sum = 0;\n  for (int i = 1; i <= n; i++) sum += dis[i];\n  if (sum == D[n].first) {\n    for (int i = 1; i <= tot; i++)\n      cout << edge[i].first << \" \" << edge[i].second << endl;\n  } else\n    puts(\"-1\");//__wfx fuck you\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint N;\nint D[110000], n[110000], d[110000];\nunordered_map<int, int> mp;\nvint ans;\nsigned main() {\n    cin >> N;\n    for (int i = 1; i <= N; i++) {cin >> D[i]; n[i] = 1; mp[D[i]] = i;};\n    sort(D + 1, D + N + 1); reverse(D + 1, D + N + 1);\n    for (int i = 1; i <= N - 1; i++) {\n        int s = mp[D[i]];\n        int t = mp[D[i] - N + 2 * n[s]];\n        n[t] += n[s];\n        d[t] += d[s] + n[s];\n        ans.push_back(s); ans.push_back(t);\n    }\n    if (n[mp[D[N]]] != N || d[mp[D[N]]] != D[N]) {\n        cout << -1 << endl;\n        return 0;\n    }\n    for (int i = 0; i < 2 * (N - 1); i += 2) {\n        cout << ans[i] << \" \" << ans[i + 1] << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define N 100100\n\nll n,cnt,dis;\nll d[N];\nset<pair<ll,ll> > S;\nll sz[N],u[N],v[N];\nset<pair<ll,ll> >::iterator it,it2;\n\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tfor (ll i=1;i<=n;i++) {\n\t\tscanf(\"%lld\",&d[i]);\n\t\tS.insert(mp(d[i],i));\n\t\tsz[i]=1;\n\t}\n\t\n\tfor (ll i=1;i<n;i++)\n\t{\n\t\tit=S.end(); it--;\n\t\tll now=(*it).second,num=sz[now];\n\t\tS.erase(it);\n\t\tif (n-2*num<=0) return puts(\"-1\"),0;\n\t\tit2=S.lower_bound(mp(d[now]-(n-2*num),0));\n\t\tif (it2==S.end() || (*it2).first!=d[now]-(n-2*num)) return puts(\"-1\"),0;\n\t\tu[++cnt]=now; v[cnt]=(*it2).second;\n\t\tsz[(*it2).second]+=num;\n\t\tdis+=2*num*(n-num);\n\t}\n\tfor (int i=1;i<=n;i++) dis-=d[i];\n\tif (dis!=0) return puts(\"-1\"),0;\n\tfor (ll i=1;i<=cnt;i++) printf(\"%lld %lld\\n\",u[i],v[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxN = 1e5 + 10;\nlong long d[maxN], ans[maxN];\nint sz[maxN], sz_2[maxN];\nint n;\nvector<int> g[maxN];\n\nvoid dfs(int x, int p = 0) {\n\tsz[x] = 1;\n\tans[x] = 0;\n\tfor (int v : g[x]) {\n\t\tif (v == p) continue;\n\t\tdfs(v, x);\n\t\tsz[x] += sz[v];\n\t\tans[x] += sz[v] + ans[v];\n\t}\n}\n\nvoid dfs_2(int x, int p = 0) {\n\tif (p) {\n\t\tans[x] += sz[p] - 2*sz[x] + ans[p] - ans[x];\n\t\tsz[x] = sz[p];\n\t}\n\tfor (int v : g[x]) {\n\t\tif (v == p) continue;\n\t\tdfs_2(v, x);\n\t}\n}\n\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i) cin >> d[i];\n\tfor (int i = 1; i <= n; ++i) sz_2[i] = 1;\n\tmap<long long, int, greater<long long>> p;\n\tfor (int i = 1; i <= n; ++i) p[d[i]] = i;\n\tbool fun = 1;\n\twhile (p.size() > 1) {\n\t\tauto f = p.begin(); p.erase(f);\n\t\tlong long d_p = (f->first + 2*sz_2[f->second] - n);\n\t\tfun &= p.count(d_p);\n\t\tif (not fun) break;\n\t\tint r = p[d_p];\n\t\tsz_2[r] += sz_2[f->second];\n\t\tg[r].push_back(f->second);\n\t\tg[f->second].push_back(r);\n\t}\n\tdfs(1);\n\tdfs_2(1);\n\tfor (int i = 1; i <= n; ++i) fun &= d[i] == ans[i];\n\tif (fun) {\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tfor (int v : g[i])\n\t\t\t\tif (i < v) cout << i << \" \" << v << endl;\n\t\t}\n\t} else puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nvoid bye() { std::cout << -1 << std::endl; exit(0); }\nconst int MAXN = 100010;\ntypedef long long LL;\nstd::map<LL, LL> idx, sub, fa, dep;\nint n;\nLL D[MAXN];\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor (int i = 1; i <= n; ++i)\n\t\tstd::cin >> D[i], idx[D[i]] = i, sub[D[i]] = 1;\n\tstd::sort(D + 1, D + 1 + n);\n\tfor (int i = n; i > 1; --i) {\n\t\tLL td = D[i] - n + sub[D[i]] * 2;\n\t\tif (td >= D[i] || !idx.count(td)) bye();\n\t\tsub[td] += sub[D[i]];\n\t\tfa[D[i]] = td;\n\t}\n\tfor (int i = 2; i <= n; ++i) {\n\t\tdep[D[i]] = dep[fa[D[i]]] + 1;\n\t\tD[1] -= dep[D[i]];\n\t}\n\tif (D[1]) bye();\n\tfor (int i = 2; i <= n; ++i)\n\t\tstd::cout << idx[fa[D[i]]] << ' ' << idx[D[i]] << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define title \"title\"\n#define ll long long\n#define ull unsigned ll\n#define fix(x) fixed<<setprecision(x)\n#define pii pair<int,int>\n#define vint vector<int>\n#define pb push_back\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define red(i,a,b) for(int i=(a);i>=(b);i--)\n#define db double\n#define ld long db\nusing namespace std;\nvoid Freopen(){\n\tfreopen(title\".in\",\"r\",stdin);\n\tfreopen(title\".out\",\"w\",stdout);\n}\nll read(){\n\tll g=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch){if(ch=='-')f=-1;ch=getchar();}\n\twhile('0'<=ch&&ch<='9'){g=g*10+ch-'0';ch=getchar();}\n\treturn g*f;\n}\nconst int N=1e5+5;\nmap<ll,int>id,fid;\nll a[N],ans;\nint n,siz[N];\nvint G[N];\nvoid dfs(int x,int dis){ans+=dis;for(auto y:G[x])dfs(y,dis+1);}\nsigned main(){\n\t//freopen(\"a\",\"r\",stdin);\n\tn=read();rep(i,1,n)a[i]=read(),fid[a[i]]=i;\n\tsort(a+1,a+n+1,[](int a,int b){return a>b;});\n\trep(i,1,n)id[a[i]]=i,siz[i]=1;\n\trep(i,1,n-1){\n\t\tint to=a[i]+siz[i]-(n-siz[i]);\n\t\tif(!id[to])return cout<<-1,signed();\n\t\tG[id[to]].pb(i);siz[id[to]]+=siz[i];\n\t}dfs(n,0);if(ans^a[n])return cout<<-1,signed();\n\trep(i,1,n)for(auto j:G[i])cout<<fid[a[i]]<<' '<<fid[a[j]]<<'\\n';\n\treturn signed();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\nvoid fail(){\n  puts(\"-1\");\n  exit(0);\n}\n\nint n;\nll d[125252];\nint par[125252];\nvi children[125252];\npll po[125252];\n\nint cnt[125252];\n\nint sz[125252];\nll val[125252];\nvoid dfs1(int p){\n  sz[p] = 1;\n  val[p] = 0;\n  for(int to : children[p]){\n    dfs1(to);\n    sz[p] += sz[to];\n    val[p] += val[to] + sz[to];\n  }\n}\nvoid dfs2(int p){\n  if(val[p] != d[p])fail();\n  for(int to : children[p]){\n    ll tmp = val[to];\n    val[to] = val[p] - sz[to] + (n-sz[to]);\n    dfs2(to);\n    val[to] = tmp;\n  }\n}\n\nint main(){\n  scanf(\"%d\",&n);\n  REP(i,n)scanf(\"%lld\",d+i);\n\n  REP(i,n)po[i] = pll(d[i], i);\n  sort(po,po+n); reverse(po,po+n);\n  \n  map<ll,int> rev;\n  REP(i,n)rev[d[i]] = i;\n\n  REP(i,n)par[i] = -1;\n  REP(i,n-1){\n    int id = po[i].second;\n    ll x = d[id];\n    cnt[id]++;\n    int a = cnt[id];\n    int b = n-a;\n    int c = b-a;\n    if(c<=0)fail();\n    ll nxt = x-c;\n    if(rev.count(nxt)==0)fail();\n    par[id] = rev[nxt];\n    children[par[id]].push_back(id);\n    cnt[par[id]] += cnt[id];\n  }\n\n  int root = 0;\n  REP(i,n)if(par[i]==-1)root=i;\n\n  dfs1(root);\n  dfs2(root);\n  REP(i,n)for(int j:children[i]){\n    printf(\"%d %d\\n\",i+1,j+1);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nvector<ii> ans;\nvi adj[222222];\n\nvoid addedge(int u, int v)\n{\n\tans.pb(mp(u,v)); adj[u].pb(v); adj[v].pb(u);\n}\n\nll h[222222];\nll sub[222222];\n\nvoid dfs(int u, int p)\n{\n\tsub[u]=1;\n\tfor(int v:adj[u])\n\t{\n\t\tif(v==p) continue;\n\t\th[v]=h[u]+1;\n\t\tdfs(v,u);\n\t\tsub[u]+=sub[v];\n\t}\n}\n\nll ans2[222222];\n\nvoid dfs2(int u, int p, int n)\n{\n\tfor(int v:adj[u])\n\t{\n\t\tif(v==p) continue;\n\t\tans2[v] = ans2[u] + n - 2*sub[v];\n\t\tdfs2(v,u,n);\n\t}\n}\n\nll ori[222222];\nbool check(int n)\n{\n\tdfs(0,-1);\n\tll ans = 0;\n\tfor(int i=0;i<n;i++) ans+=h[i];\n\tif(ori[0]!=ans) return false;\n\tans2[0] = ans;\n\tdfs2(0,-1,n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(ans2[i]!=ori[i]) return false;\n\t}\n\treturn true;\n}\n\nmap<ll,int> ma;\nint S[222222];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tvector<ii> vec;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll x; cin>>x; vec.pb(mp(x,i)); ori[i]=x; ma[x]=i;\n\t}\n\tsort(vec.rbegin(),vec.rend());\n\tfor(int i=0;i<n;i++) S[i]=1;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tll cur = vec[i].fi; int u = vec[i].se;\n\t\t//S[u] is confirmed\n\t\tll newd = cur - (n - 2*S[u]);\n\t\tif(ma.find(newd)==ma.end())\n\t\t{\n\t\t\tcout<<-1<<'\\n'; return 0;\n\t\t}\n\t\tint v = ma[newd];\n\t\taddedge(u,v);\n\t\tS[v]+=S[u];\n\t\t//cerr<<\"ADD \"<<u<<' '<<v<<'\\n';\n\t}\n\tif(check(n))\n\t{\n\t\tfor(ii x:ans)\n\t\t{\n\t\t\tcout<<x.fi+1<<' '<<x.se+1<<'\\n';\n\t\t}\n\t}\n\telse\n\t{\n\t\tcout<<-1<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\n\nstruct node{\n\tlong long v;\n\tint id;\n}a[100001];\n\nint n,sz[100001],s1[100001],s2[100001];\nlong long s,t;\nvector<int> ga[100001];\nmap<long long,int> num;\n\nbool cmp(node a,node b){\n\treturn a.v>b.v;\n}\n\nvoid dfs(int x,int fa,long long d){\n\ts+=d;\n\tfor(int i=0;i<ga[x].size();i++)\n\t\tif(ga[x][i]!=fa)dfs(ga[x][i],x,d+1);\n}\n\nint main(){\n\tint i,x,y;\n\tcin >> n;\n\tfor(i=1;i<=n;i++){\n\t\tcin >> a[i].v;\n\t\tnum[a[i].v]=i;\n\t\ta[i].id=i;\n\t\tsz[i]=1;\n\t}\n\tsort(a+1,a+n+1,cmp);\n\tfor(i=1;i<n;i++){\n\t\tx=a[i].id;\n\t\tt=a[i].v-(n-sz[x])+sz[x];\n\t\tif(!num[t] || t>=a[i].v){\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\ty=num[t];\n\t\ts1[i]=x;\n\t\ts2[i]=y;\n\t\tsz[y]+=sz[x];\n\t\tga[x].push_back(y);\n\t\tga[y].push_back(x);\n\t}\n\tdfs(a[n].id,0,0);\n\tif(s!=a[n].v){\n\t\tcout << -1;\n\t\treturn 0;\n\t}\n\tfor(i=1;i<n;i++)\n\t\tcout << s1[i] << ' ' << s2[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Ho-kago Tea Time\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MAXN = (int) 1e5;\n\nint n;\n\nstruct node\n{\n\tint u;\n\tLL D;\n\n\tinline bool operator < (const node &rhs) const { return this->D < rhs.D; }\n\n\tnode() { }\n\tnode(int _u, LL _D): u(_u), D(_D) { }\n}d[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tfor(int i = 1; i <= n; ++i) d[i] = node(i, read<LL>());\n}\n\ninline void solve()\n{\n\tstatic priority_queue<node> Q;\n\tstatic unordered_map<LL, int> id;\n\tstatic int size[MAXN + 5], vis[MAXN + 5];\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tQ.push(d[i]);\n\t\tid[d[i].D] = d[i].u;\n\t\tsize[d[i].u] = 1;\n\t}\n\n\tstatic vector<pii> E;\n\n\twhile(SZ(Q) > 1)\n\t{\n\t\tint u = Q.top().u;\n\t\tLL D = Q.top().D;\n\t\tvis[u] = 1, Q.pop();\n\n\t\tint v = id[D + 2 * size[u] - n];\n\t\tif(!v || vis[v]) { puts(\"-1\"); return; }\n\t\tE.emplace_back(u, v), size[v] += size[u];\n\t}\n\tfor(auto i : E) printf(\"%d %d\\n\", i.fst, i.snd);\n}\n\nint main()\n{\n#ifdef K_ON // K-ON!\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define title \"title\"\n#define ll long long\n#define ull unsigned ll\n#define fix(x) fixed<<setprecision(x)\n#define pii pair<int,int>\n#define vint vector<int>\n#define pb push_back\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define red(i,a,b) for(int i=(a);i>=(b);i--)\n#define db double\n#define ld long db\nusing namespace std;\nvoid Freopen(){\n\tfreopen(title\".in\",\"r\",stdin);\n\tfreopen(title\".out\",\"w\",stdout);\n}\nll read(){\n\tll g=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch){if(ch=='-')f=-1;ch=getchar();}\n\twhile('0'<=ch&&ch<='9'){g=g*10+ch-'0';ch=getchar();}\n\treturn g*f;\n}\nconst int N=1e5+5;\nmap<ll,int>id,fid;\nll a[N],ans;\nint n,siz[N];\nvint G[N];\nvoid dfs(int x,int dis){ans+=dis;for(auto y:G[x])dfs(y,dis+1);}\nsigned main(){\n\t//freopen(\"a\",\"r\",stdin);\n\tn=read();rep(i,1,n)a[i]=read(),fid[a[i]]=i;\n\tsort(a+1,a+n+1,[](int a,int b){return a>b;});\n\trep(i,1,n)id[a[i]]=i,siz[i]=1;\n\trep(i,1,n-1){\n\t\tll to=a[i]+siz[i]-(n-siz[i]);\n\t\tif(!id[to])return cout<<-1,signed();\n\t\tG[id[to]].pb(i);siz[id[to]]+=siz[i];\n\t}dfs(n,0);if(ans^a[n])return cout<<-1,signed();\n\trep(i,1,n)for(auto j:G[i])cout<<fid[a[i]]<<' '<<fid[a[j]]<<'\\n';\n\treturn signed();\n}"
  },
  {
    "language": "C++",
    "code": "/*----------------by syr----------------*/\n/*\n\n         iii                  ii\n     rBQBBBBBBE       BBR iBBBBQBBL     XBBBBBBQBBBBB\n   iBBQJ    7BBB      BBsSBBr   BBQ      i      cBBB\n  rBBU       iBBw     BBBQi     HBBi           KBBi\n  BBH         BB5    iBBB       isL          wBB5\n GBB         iBBi    6BB                   iBBB\n BBQ         BQB     BBD                  QBBi\n BBB        BQB     iQBi                1BBv\n sBBg     wBBB      QBB               iBBB\n  7BBBBBBBBBi       BBR              wBBBBBBBBBBBBB\n     irvi           ii               ii    i i iii\n                i5U\n               BBB\n               BB7\n              1BB\n      iPBBBBBKBBR    JBR1       rQBO   BR  UBQP  iBBQi\n    7BBBGs7sXBBBi     QBBr     gBBE   rBB BB2BB7HBZQBB\n   QBBi      sBQ       BBB   iBBB     SQBBR  BBBB  cBQ\n  gBQ        BBg        BBB KBBi      MBBH   BBB   BBs\n iBBv       iBBi         QBBBL        BBR   pBB   iBB\n pBB        BBB         iBBBB        iBB    BBL   KBB\n MBB       BBBR        BBB JBBi      DBR   iBQ    BBL\n GBB     7BBBB2      PBBH   BBBi     BQr   DBB   iBB\n  BQBXwgBBP BB7    1BBB      BBQ7   1BB    BBc   BBB\n   2BBBBw   BB    EBBS        QBBi  HBa   iBB    BB7\n*/\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define PH push\n#define MP make_pair\n#define PB push_back\n#define fst first\n#define snd second\n#define FOR(i, x, y) for(int i = (x); i < (y); ++i)\n#define REP(i, x, y) for(int i = (x); i <= (y); ++i)\n#define x0 x0123456789\n#define y0 y0123456789\n#define x1 x1234567890\n#define y1 y1234567890\n#define x2 x2345678901\n#define y2 y2345678901\ntypedef double db;\ntypedef long long ll;\ntypedef long double ldb;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int maxn = 1e5 + 5;\nconst ll INF = 1e12 + 7;\n\nint n;\nint par[maxn], sz[maxn];\nbool used[maxn];\nll mn = INF, sum = 0;\nll d[maxn], sub[maxn], dis[maxn];\nvector<pair<ll, int> > vec;\n\nint main(){\n\tscanf(\"%d\", &n);\n\tFOR(i, 0, n){\n\t\tscanf(\"%lld\", d + i);\n\t\tvec.PB(MP(d[i], i));\n\t\tmn = min(d[i], mn);\n\t}\n\tsort(vec.begin(), vec.end());\n\tFOR(i, 0, n) sz[i] = 1;\n\tFOR(i, 0, n) sub[i] = -INF;\n\tmemset(par, -1, sizeof(par));\n\tfor(int i = vec.size() - 1; i >= 0; --i){\n\t\tint id = vec[i].snd;\n\t\t//printf(\"i = %d id = %d (%d, %d)\\n\", i, id, vec[i].fst, vec[i].snd);\n\t\tif(d[id] == mn){\n\t\t\tFOR(i, 1, vec.size()){\n\t\t\t\tint u = vec[i].snd;\n\t\t\t\tdis[u] = dis[par[u]] + 1;\n\t\t\t\tsum += dis[u];\n\t\t\t}\n\t\t\tif(sum != d[id]){\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif(sub[id] == -INF) sub[id] = n - 2;\n\t\tint pos = lower_bound(vec.begin(), vec.end(), MP(d[id] - sub[id], -1)) - vec.begin();\n\t\t//printf(\"id = %d %d %d\\n\", id, d[id] - sub[id], pos);\n\t\tif(pos >= i || vec[pos].fst != d[id] - sub[id]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tpar[id] = vec[pos].snd;\n\t\tsz[par[id]] += sz[id];\n\t\tsub[par[id]] = (n - sz[par[id]] - sz[par[id]]);\n\t}\n\tFOR(i, 0, n) if(d[i] != mn) printf(\"%d %d\\n\", i + 1, par[i] + 1);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<vector>\n\ntypedef long long ll;\n\nint const N = 1e5 + 5;\n\nint fa[N];\nint sz[N];\nll a[N];\nll dis[N];\nint n;\nbool vis[N];\n\nstd::vector<int> E[N];\nvoid addedge2(int x, int y) {\n    E[x].push_back(y);\n    E[y].push_back(x);\n}\n\nvoid dfs(int x, int& sum) {\n    ++sum;\n    vis[x] = 1;\n    for(auto y : E[x]) if(vis[y] == 0) {\n        dfs(y, sum);\n    }\n}\n\nint main() {\n    std::map<ll, int, std::greater<ll> > M;\n    std::ios::sync_with_stdio(0);\n    std::cin >> n;\n    for(int i = 1; i <= n; ++i) {\n        std::cin >> a[i];\n        M.insert(std::make_pair(a[i], i));\n    }\n    for(auto& k : M) if(k.first != (*M.rbegin()).first) {\n        int now = k.second;\n        ++sz[now];\n        ll f = k.first + 2ll * sz[now] - n;\n        if(M.count(f) == 0) {\n            puts(\"-1\");\n            return 0;\n        }\n        fa[now] = M[f];\n        sz[fa[now]] += sz[now];\n        ::addedge2(now, fa[now]);\n    }\n    int sum = 0;\n    memset(vis, 0, sizeof(vis));\n    dfs(1, sum);\n    if(sum != n) {\n        puts(\"-1\");\n        return 0;\n    }\n    for(int i = 1; i <= n; ++i) if(fa[i] != 0) {\n        std::cout << fa[i] << ' ' << i << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#include <cmath>\n#include <complex>\n// #include \"utiltime.hpp\"\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef complex<double> cdouble;\n\nconst int INFL = (int)1e9;\nconst ll INFLL = (ll)1e18;\nconst double INFD = numeric_limits<double>::infinity();\nconst double PI = 3.14159265358979323846;\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loopll(i, n) for(ll i = 0; i < (ll)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopll1(i, n) for(ll i = 1; i <= (ll)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = (ll)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define Looprll1(i, n) for(ll i = (ll)n; i >= 1; i--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(i, vector.size()) { cout << vector[i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(i, matrix.size()) { Loop(j, matrix[i].size()) { cout << matrix[i][j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define readfile(filename) ifstream in(filename); cin.rdbuf(in.rdbuf());\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\nbool nearlyeq(double x, double y) { return abs(x - y) < 1e6; }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(double x) { ll m = (ll)sqrt(x); return m + (m * m <= (ll)(x) ? 0 : -1); }\nll ceilsqrt(double x) { ll m = (ll)sqrt(x); return m + ((ll)x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\n\n/*******************************************************/\n\nvoid failed() {\n\tcout << -1 << endl;\n\texit(0);\n}\n\nint main() {\n\tquickio();\n\tint n; cin >> n;\n\tvector<P> a(n);\n\tLoop(i, n) {\n\t\tcin >> a[i].first;\n\t\ta[i].second = i;\n\t}\n\tsort(a.begin(), a.end());\n\tvi subtree_cnt(n, 0);\n\tvector<P> ans;\n\tLoopr1(i, n - 1) {\n\t\tint target_val = a[i].first + subtree_cnt[i] * 2 - n + 2;\n\t\tauto itr = lower_bound(a.begin(), a.end(), P({ target_val, 0 }));\n\t\tif (itr == a.end()) failed();\n\t\tif (itr - a.begin() == a.size() - 1) failed();\n\t\tif (itr->first != target_val) failed();\n\t\tsubtree_cnt[itr - a.begin()] += subtree_cnt[i] + 1;\n\t\tans.push_back({ a[i].second + 1, a[itr - a.begin()].second + 1 });\n\t\ta.pop_back();\n\t\tsubtree_cnt.pop_back();\n\t}\n\tLoop(i, ans.size()) {\n\t\tcout << ans[i].first << \" \" << ans[i].second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <long long, long long> pii;\n\nconst long long MAX_N = 1e5 + 5;\nlong long n, root;\nlong long Arr[MAX_N];\nlong long h[MAX_N];\nlong long Siz[MAX_N];\nlong long Mark[MAX_N];\nlong long par[MAX_N];\nunordered_map <long long, long long> Map;\nvector <pii> edge;\nlong long dp_d[MAX_N];\nlong long dp_u[MAX_N];\nvector <long long> child[MAX_N];\n\nbool cmp(long long a, long long b) {\n\treturn Arr[b] < Arr[a];\n}\n\nvoid dfs1(long long v) {\n\tfor (long long i = 0; i < child[v].size(); i++) {\n\t\tdfs1(child[v][i]);\n\t\tdp_d[v] += dp_d[child[v][i]] + Siz[child[v][i]];\n\t}\n}\n\nvoid dfs2(long long v, long long val) {\n\tdp_u[v] = val;\n\tfor (long long i = 0; i < child[v].size(); i++)\n\t\tdfs2(child[v][i], dp_d[v] - dp_d[child[v][i]] - Siz[child[v][i]] + dp_u[v] + (n - Siz[child[v][i]]));\n}\n\nint main() {\n\tios::sync_with_stdio(false), cout.tie(0), cin.tie(0);\n\tcin >> n;\n\tfor (long long i = 0; i < n; i++) {\n\t\tcin >> Arr[i];\n\t\tSiz[i] = 1;\n\t\th[i] = i;\n\t\tMap[Arr[i]] = i;\n\t}\n\t\t\n\tsort(h, h + n, cmp);\n\t\n\tfor (long long i = 0; i + 1 < n; i++) {\n\t\tlong long v = h[i];\n\t\tlong long tmp = Arr[v] + Siz[v] - (n - Siz[v]);\n\n\t\tif (tmp < 0 || (Map[tmp] == 0 && Arr[0] != tmp)) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tlong long u = Map[tmp];\n\t\t/*if (Mark[u]) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}*/\n\t\t\n\t\tSiz[u] += Siz[v];\n\t\tpar[v] = u;\n\t\tedge.push_back({v, u});\n\t\tchild[u].push_back(v);\n\t\tif (n < 2LL * Siz[v]) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t//Mark[v] = true;\n\t}\n\troot = h[n - 1];\n\tdfs1(root);\n\t//dfs2(root, 0);\n\t\n\tfor (long long i = root; i < root + 1; i++)\n\t\tif (dp_d[i] + dp_u[i] != Arr[i]) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\n\tfor (long long i = 0; i + 1 < n; i++)\n\t\tcout << edge[i].first + 1 << \" \" << edge[i].second + 1 << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+3;\nint n,siz[N];\nstruct syzs{\n\tlong long val;\n\tint num;\n} a[N];\nstruct ans{\n\tint e1,e2;\n\tbool operator <(const ans &emm) const{\n\t    if(emm.e1==e1) return e2>emm.e2;\n\t\treturn emm.e1<e1;\n\t}\n};\nbool cmp(syzs c,syzs b){\n\treturn c.val>b.val;\n}\nint find(int k){\n\tlong long chec=a[k].val+2*siz[k]-n;\n\tfor(int i=k+1;i<=n;i++) if(a[i].val==chec) return i;\n\treturn -1;\n}\nint main(){\n\tpriority_queue <ans> q;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i].val);\n\t\ta[i].num=i;\n\t\tsiz[i]=1;\n\t}\n\tsort(a+1,a+n+1,cmp);\n\tfor(int i=1;i<n;i++){\n\t\tint v=find(i);\n\t\tif(v==-1){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[v]+=siz[i];\n\t\tq.push((ans) {min(a[v].num,a[i].num),max(a[v].num,a[i].num)});\n\t}\n\twhile(!q.empty()){\n\t\tint v1=q.top().e1,v2=q.top().e2;\n    \tq.pop();\n    \tprintf(\"%d %d\\n\",v1,v2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\nusing ll = long long;\n\nint main() {\n  int n;\n  cin >> n;\n  vector<ll> d(n);\n  vector<int> parent(n, -1);\n  vector<int> p(n);\n  vector<ll> size(n, 1);\n  map<ll, int> mp;\n  for (int i = 0; i < n; i++) {\n    cin >> d[i];\n    p[i] = i;\n    mp[d[i]] = i;\n  }\n  sort(p.begin(), p.end(), [&](int i, int j) { return d[i] > d[j]; });\n  p.pop_back();\n  for (int i : p) {\n    ll tmp = d[i] - n + 2 * size[i];\n    if (tmp < d[i] && mp.count(tmp)) {\n      parent[i] = mp[tmp];\n      size[parent[i]] += size[i];\n    } else {\n      cout << -1 << '\\n';\n      return 0;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (parent[i] != -1) {\n      cout << i+1 << ' ' << parent[i]+1 << '\\n';\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n// Created by Ильдар Ялалов on 28.10.2019.\n//\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stdio.h>\n#include <string.h>\n#include <cmath>\n#include <queue>\n#include <ctime>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int inf_int = 1e9 + 100;\nconst ll inf_ll = 1e18;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef long double dbl;\n#define pb push_back\n#define eb emplace_back\nconst double pi = 3.1415926535898;\n#define dout if(debug) cout\n#define fi first\n#define se second\n#define sp setprecision\n#define sz(a) (int(a.size()))\n#define all(a) a.begin(),a.end()\nbool debug = 0;\nconst int MAXN = 1e6 + 100;\nconst int LOG = 21;\nconst int mod = 1e9 + 7;\nconst int MX = (1e7 + 100) * 1.5;\ntypedef long long li;\nconst li MOD = 1000000000949747713ll;\n\ntemplate<class T1, class T2>\nstd::ostream &operator<<(std::ostream &out, const std::pair<T1, T2> &rhs) {\n    out << \"( \" << rhs.first << \" , \" << rhs.second << \" )\";\n    return out;\n}\n\n\npll D[MAXN];\n\nint sz[MAXN];\n\nvector<int> g[MAXN];\n\n\nll sum  = 0;\nvoid dfs(int v,int p,ll cur){\n    sum += cur;\n    for(int to:g[v]){\n        if(to == p)\n            continue;\n        dfs(to,v,cur+1);\n\n    }\n}\nvoid solve() {\n    int n;\n    cin >> n;\n\n    map<ll,int> mp;\n    for (int i = 1; i <= n; ++i) {\n        cin >> D[i].fi;\n        D[i].se = i;\n        if(mp.count(D[i].fi) == 0){\n            mp[D[i].fi] = i;\n        }\n\n\n        sz[i] = 1;\n    }\n    sort(D+1,D+n+1);\n\n    vector<pii> edges;\n    for(int j = n;j > 1;--j){\n        int v = D[j].se;\n        ll x = D[j].fi - n + 2 * sz[v];\n        dout << v << \" \"<<D[j].fi <<\" \"<<x <<\" : \" <<endl;\n        if(mp.count(x) == 0){\n            cout <<\"-1\";\n            return;\n        }\n\n        int to = mp[x];\n        if(to == v){\n            cout << -1 <<\"\\n\";\n            return;\n        }\n        edges.pb({v,to});\n\n        g[v].pb(to);\n        g[to].pb(v);\n        sz[to] += sz[v];\n    }\n\n    dfs(D[1].se,-1,0);\n\n    if(sum != D[1].fi){\n        cout << -1;\n        return;\n    }\n    for(auto x : edges){\n        cout << x.fi<<\" \"<<x.se<<\"\\n\";\n    }\n\n\n}\n\nsigned main() {\n#ifdef zxc\n    debug = 1;\n    freopen(\"../input.txt\", \"r\", stdin);\n    //  freopen(\"../output.txt\", \"w\", stdout);\n#else\n\n#endif //zxc\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(20);\n\n    int t = 1;\n    while (t--)\n        solve();\n    if (debug)\n        cerr << endl << \"time : \" << (1.0 * clock() / CLOCKS_PER_SEC) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\n\ntypedef pair < db, db > pdd;\ntypedef pair < db, ld > pdl;\ntypedef pair < ld, db > pld;\ntypedef pair < ld, ld > ldp;\n\ntypedef pair < ll, ll > pll;\ntypedef pair < int, ll > pil;\ntypedef pair < ll, int > pli;\ntypedef pair < int, int > pii;\n\n#define F first\n#define S second\n\n#define en end()\n#define bg begin()\n\n#define rev reverse\n#define mp make_pair\n#define pb push_back\n\n#define y1 y1234567890\n#define um unordered_map\n\n#define all(x) x.bg, x.en\n#define sz(x) (int)x.size()\n#define len(x) (int)strlen(x)\n\n#define sqr(x) ((x + 0ll) * (x))\n#define sqrd(x) ((x + 0.0) * (x))\n\n#define forn(i, n) for (int i = 1; i <= n; i++)\n\nconst ll inf = (ll)1e18;\nconst ll mod = (ll)1e9 + 7;\n\nconst db eps = (db)1e-9;\nconst db pi = acos(-1.0);\n\nconst int dx[] = {0, 0, 1, 0, -1};\nconst int dy[] = {0, 1, 0, -1, 0};\n\nconst int N = 100500;\n\nll d[N];\nint n, dp[N];\nvector < int > g[N];\nmap < ll, int > pos;\n\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\t//freopen(\".err\", \"w\", stderr);\n\n\t//srand(time(NULL));\n\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tios_base::sync_with_stdio(false);\n\n\t//cout << setprecision(10) << fixed;\n\t\n\tcin >> n;\n\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> d[i];\n\n\tsort(d + 1, d + 1 + n);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tpos[d[i]] = i;\n\t\tdp[i] = 1;\n\t}\n\n\tfor (int i = n; i > 1; i--) {\n\t\tll val = d[i] + dp[i] + dp[i] - n;\n\t\tif (!pos.count(val) || val >= d[i]) {\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\tint p = pos[val];\n\t\tdp[p] += dp[i];\n\t\tg[p].pb(i);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (auto j : g[i])\n\t\t\tcout << i << \" \" << j << \"\\n\";\n\t}\n\t\n\t//cerr << (clock() + 0.0) / CLOCKS_PER_SEC;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define INF 1000000000007\nusing namespace std;\n\nint n,d[200010],sz[200010],dp[200010],minv,pos;\nmap<int,int> mp;\nvector<pair<int,int> > res;\nvector<int> v[200010];\n\ninline void dfs(int u,int pr)\n{\n\tfor(int i=0;i<v[u].size();i++) if(v[u][i]!=pr){\n\t\tdfs(v[u][i],u);\n\t\tdp[u]+=dp[v[u][i]]+sz[v[u][i]];\n\t}\n}\n\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){cin>>d[i];mp[d[i]]=i;}\n\tminv=INF;\n\tfor(int i=1;i<=n;i++){\n\t\tif(d[i]<minv){\n\t\t\tminv=d[i];\n\t\t\tpos=i;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){sz[i]=1;}\n  \tmap<int,int>::iterator it=mp.end();\n  \tit--;\n\tfor(;it!=mp.begin();it--){\n\t\tint num=it->first,loc=it->second;\n\t\tif(loc==pos) continue;\n\t\tif(sz[loc]*2>=n){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint cur=num-n+2*sz[loc];\n\t\tif(!mp.count(cur)){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint par=mp[cur];\n\t\tres.push_back(make_pair(par,loc));\n\t\tsz[par]+=sz[loc];\n\t}\n\tfor(int i=0;i<res.size();i++){\n\t\tv[res[i].first].push_back(res[i].second);\n\t\tv[res[i].second].push_back(res[i].first);\n\t}\n\tfor(int i=1;i<=n;i++) dp[i]=0;\n\tdfs(pos,-1);\n\tif(dp[pos]!=minv){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<res.size();i++){\n\t\tcout<<res[i].first<<\" \"<<res[i].second<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=1e5+10;\nint n,cnt,e,f[N],a[N],id[N],w[N],siz[N],res[N],head[N],link[N],to[N];\nbool vis[111111];\nbool cmp(int x,int y){return a[x]<a[y];}\nvoid add(int u,int v){to[++e]=v,link[e]=head[u],head[u]=e;}\nvoid dfs1(int u){\n\tsiz[u]=1;\n\tfor(int i=head[u];i;i=link[i])if(to[i]!=f[u])dfs1(to[i]),siz[u]+=siz[to[i]];\n}\nvoid dfs2(int u){for(int i=head[u];i;i=link[i])if(to[i]!=f[u])res[to[i]]=res[u]+n-2*siz[to[i]],dfs2(to[i]);}\nsigned main(){\n\tscanf(\"%d\",&n),w[0]=-LLONG_MAX;\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]),id[i]=i,w[i]=a[i],siz[i]=1;\n\tsort(id+1,id+n+1,cmp),sort(w+1,w+n+1);\n\tfor(int i=n;i>1;i--){\n\t\tint x=2*siz[id[i]]-n+a[id[i]],pos=lower_bound(w+1,w+n+1,x)-w;\n\t\tif(w[pos]!=x||n-2*siz[id[i]]<=0){printf(\"-1\");return 0;}\n\t\tadd(id[pos],id[i]),siz[id[pos]]+=siz[id[i]],f[id[i]]=id[pos];\n\t}\n\tres[id[1]]=w[1],dfs1(id[1]),dfs2(id[1]);\n\tfor(int i=1;i<=n;i++)if(a[i]!=res[i]){printf(\"-1\");return 0;}\n\tfor(int i=2;i<=n;i++)printf(\"%d %d\\n\",f[id[i]],id[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\n\nconst int maxn = 1e5 + 5;\n\nint par[maxn], N, sub[maxn];\npair<ll, int> d[maxn];\nll f[maxn];\nvector<int> adj[maxn];\nint depth[maxn], sz[maxn];\n\nvoid dfs(int u = 1, int p = -1)\n{\n  sz[u] = 1;\n  f[1] += depth[u];\n  for(int v : adj[u]) if(v != p){\n    depth[v] = depth[u] + 1;\n    dfs(v, u);\n    sz[u] += sz[v];\n  }\n}\n\nvoid reroot(int u = 1, int p = -1)\n{\n  for(int v : adj[u]) if(v != p){\n    f[v] = f[u] + N - 2 * sz[v];\n    reroot(v, u);\n  }\n}\n\nbool check(void)\n{\n  for(int i = 1; i <= N; ++i)\n    if(par[i]) adj[par[i]].pb(i), adj[i].pb(par[i]);\n  dfs(); reroot();\n  for(int i = 1; i <= N; ++i){\n    if(f[d[i].se] != d[i].fi) return false;\n  }\n  return true;\n}\n\nsigned main(void)\n{\n  ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n  if(fopen(\"A.INP\", \"r\")){\n    freopen(\"A.INP\", \"r\", stdin);\n    freopen(\"A.OUT\", \"w\", stdout);\n  }\n  cin >> N;\n  for(int i = 1; i <= N; ++i){\n    cin >> d[i].fi;\n    d[i].se = i;\n    sub[i] = 1;\n  }\n  sort(d + 1, d + 1 + N);\n  for(int i = N; i >= 2; --i){\n    int j = lower_bound(d + 1, d + 1 + N, mp(d[i].fi - (N - 2 * sub[d[i].se]), -1)) - d;\n    if(i == j) ++j;\n    if(d[j].fi != d[i].fi - (N - 2 * sub[d[i].se])){\n      cout << -1;\n      return 0;\n    }\n    par[d[i].se] = d[j].se;\n    sub[d[j].se] += sub[d[i].se];\n  }\n  if(!check()){\n    cout << -1;\n    return 0;\n  }\n  for(int i = 1; i <= N; ++i){\n    if(par[i]) cout << i << ' ' << par[i] << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <algorithm>\nusing namespace std;\n#define Maxn 100005\nint n,id[Maxn],par[Maxn],sz[Maxn];\nlong long a[Maxn];\nmap <long long,int> mp;\nint main()\t\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%lld\",&a[i]);\n\t\tmp[a[i]]=i;\n\t\tid[i]=i;\n\t\tsz[i]=1;\n\t}\n\tsort(id+1,id+n+1,[&](const int &x,const int &y)->bool{return a[x]>a[y];});\n\tfor (int i=1;i<n;++i)\n\t{\n\t\tint x=id[i];\n\t\tpar[x]=mp[a[x]-n+2*sz[x]];\n\t\tif (!par[x]) return (int)puts(\"-1\")*0;\n\t\tsz[par[x]]+=sz[x];\n\t}\n\tfor (int i=1;i<n;++i) a[id[n]]-=sz[id[i]];\n\tif (a[id[n]]) return (int)puts(\"-1\")*0;\n\tfor (int i=1;i<n;++i) printf(\"%d %d\\n\",id[i],par[id[i]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm> //STLÍ¨ÓÃËã·¨\n#include <cmath> //¶¨ÒåÊýÑ§º¯Êý\n#include <cstdio> //¶¨ÒåÊäÈë/Êä³öº¯Êý\n#include <iostream> //Êý¾ÝÁ÷ÊäÈë/Êä³ö\n#include <cstring> //×Ö·û´®´¦Àí\n#include <string> //×Ö·û´®Àà\n#include <ctime> //¶¨Òå¹ØÓÚÊ±¼äµÄº¯Êý\n#include <map> //STLÓ³ÉäÈÝÆ÷\n#include <vector> //STL¶¯Ì¬Êý×éÈÝÆ÷\n#define itn int\n#define fro for\n#define ll long long\n#define reg register\n#define inf 1234567890\n#define rep(i,a,b,c) for (int i=a;i<=b;i+=c)\n/*#include <bitset> //STLÎ»¼¯ÈÝÆ÷\n#include <cstype> //×Ö·û´¦Àí\n#include <cerrno> //¶¨Òå´íÎóÂë\n#include <complex> //¸´ÊýÀà\n#include <clocale> //¶¨Òå±¾µØ»¯º¯Êý\n#include <cstdlib> //¶¨ÒåÔÓÏîº¯Êý¼°ÄÚ´æ·ÖÅäº¯Êý\n#include <deque> //STLË«¶Ë¶ÓÁÐÈÝÆ÷\n#include <exception> //Òì³£´¦ÀíÀà\n#include <fstream> //ÎÄ¼þÊäÈë/Êä³ö\n#include <functional> //STL¶¨ÒåÔËËãº¯Êý(´úÌæÔËËã·û)\n#include <limits> //¶¨Òå¸÷ÖÖÊý¾ÝÀàÐÍ×îÖµ³£Á¿\n#include <list> //STLÏßÐÔÁÐ±íÈÝÆ÷\n#include <iomanip> //²ÎÊý»¯ÊäÈë/Êä³ö\n#include <ios> //»ù±¾ÊäÈë/Êä³öÖ§³Ö\n#include <iosfwd> //ÊäÈë/Êä³öÏµÍ³Ê¹ÓÃµÄÇ°ÖÃÉùÃ÷\n#include <istream> //»ù±¾ÊäÈëÁ÷\n#include <ostream> //»ù±¾Êä³öÁ÷\n#include <queue> //STL¶ÓÁÐÈÝÆ÷\n#include <set> //STL¼¯ºÏÈÝÆ÷\n#include <sstream> //»ùÓÚ×Ö·û´®µÄÁ÷\n#include <stack> //STL¶ÑÕ»ÈÝÆ÷\n#include <stdexcept> //±ê×¼Òì³£Àà\n#include <streambuf> //µ×²ãÊäÈë/Êä³öÖ§³Ö\n#include <utility> //STLÍ¨ÓÃÄ£°åÀà\n#include <cwchar.h>//¿í×Ö·û´¦Àí¼°ÊäÈë/Êä³ö\n#include <cwctype.h> //¿í×Ö·û·ÖÀà*/\n\nusing namespace std;\n\nint ans;\n\nint max(int x,int y){return x>y?x:y;}\n\nint min(int x,int y){return x<y?x:y;}\n\nint abs(int x){return x>0?x:-x;}\n\nint gcd(int x,int y){return (!y)?x:gcd(y,x%y);}\n\nvoid exgcd(int a,int b,int &d,int &x,int &y){if (!b){d=a,x=1,y=0;}else{exgcd(b,a%b,d,y,x);y-=x*(a/b);}}\n\nint quick_power(ll a,int b){ll r=1;for (;b;b>>=1,a=a*a)if (b&1) r=r*a;return r;}\n\ninline char read() {\n\tstatic const int IN_LEN = 1000000;\n\tstatic char buf[IN_LEN], *s, *t;\n\treturn (s == t ? t = (s = buf) + fread(buf, 1, IN_LEN, stdin), (s == t ? -1 : *s++) : *s++);\n}\ntemplate<class T>\ninline void read(T &x) {\n\tstatic bool iosig;\n\tstatic char c;\n\tfor (iosig = false, c = read(); !isdigit(c); c = read()) {\n\t\tif (c == '-') iosig = true;\n\t\tif (c == -1) return;\n\t}\n\tfor (x = 0; isdigit(c); c = read()) x = x * 10 + (c ^ '0');\n\tif (iosig) x = -x;\n}\n\nchar sr[10000000],z[20];int C=-1,Z=0;\nvoid Ot(){fwrite(sr,1,C+1,stdout),C=-1;}\nvoid print(int x){\n\tif (x<0) sr[++C]='-',x=-x;\n    while(z[++Z]=x%10+48,x/=10);\n    while(sr[++C]=z[Z],--Z);sr[++C]='\\n';\n}\n//int find(int x){return fa[x]=fa[x]==x?x:find(fa[x]);}\n\n//void add(int x,int y,int z){to[++cnt]=y;v[cnt]=z;Next[cnt]=head[x];head[x]=cnt;}\n\nconst int N=100005;\n\nint n,size[N],id[N],ans1[N],ans2[N];\nll tot,a[N];\nmap<ll,int> mp;\nvector<int> v[N];\n\nbool cmp(int x,int y){return a[x]>a[y];}\n\nvoid dfs(int x,int fa,int step)\n{\n\ttot+=step;\n\tfor (int i=0;i<v[x].size();i++)\n\t\tif (v[x][i]!=fa) dfs(v[x][i],x,step+1);\n}\n\nint main()\n{\n\tread(n);\n\tfor (int i=1;i<=n;i++) read(a[i]),mp[a[i]]=id[i]=i,size[i]=1;\n\tsort(id+1,id+n+1,cmp);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tll w=a[id[i]]-n+size[id[i]]*2;\n\t\tint x=id[i],y=mp[w];\n\t\tif (!y||w>=a[x]) return puts(\"-1\"),0;\n\t\tans1[i]=x;ans2[i]=y;\n\t\tv[x].push_back(y);\n\t\tv[y].push_back(x);\n\t\tsize[y]+=size[x];\n\t}\n\tdfs(id[n],0,0);\n\tif (tot!=a[id[n]]) return puts(\"-1\"),0;\n\tfor (int i=1;i<n;i++) printf(\"%d %d\\n\",ans1[i],ans2[i]);\n\treturn 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#include<iostream>\n#include<map>\n#include<vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__) \n#define ref(a,b,c) for(int a=b;a<=c;++a)\n#define def(a,b,c) for(int a=b;a>=c;--a)\n#define fi first\n#define se second\nusing namespace std;\ninline char nc(){\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++; \n}\ntemplate<class T>void read(T &x){\n\tx=0;int f=1,ch=nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx*=f;\n}\ntypedef long long LL;\ntypedef pair<int,int> pii;\nconst int maxn=1e5+10;\nLL D[maxn];\nint n;\nint p[maxn];\nint siz[maxn];\nmap<int,int>idx; \nvector<pii>an; \ninline int cmp(const int&a,const int&b){\n\treturn D[a]>D[b];\n}\nbool solve(){\n\tref(i,1,n)p[i]=i,siz[i]=1;\n\tsort(p+1,p+n+1,cmp);\n\tref(i,1,n-1){\n\t\tint u=p[i];\n\t\tif(!idx.count(D[u]-n+2*siz[u]))return 0;\n\t\tint fa=idx[D[u]-n+2*siz[u]]; \n\t\tif(u==fa)return 0;\n\t\tan.push_back(make_pair(fa,u)),siz[fa]+=siz[u];\n\t}\n\tref(i,0,n-2)printf(\"%d %d\\n\",an[i].fi,an[i].se);\n\treturn 1;\n}\nint main(){\n\tread(n);\n\tref(i,1,n){\n\t\tread(D[i]);\n\t\tidx[D[i]]=i;\n\t}\n\tif(!solve())puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1e5 + 10;\nvector<pair<int, int> > edg;\npair<ll, int> d[MAXN];\nvector<int> Mat[MAXN];\nint n, cnt[MAXN];\nmap<ll, int> mp;\nbool se[MAXN];\nint num;\n\nvoid dfs(int v) {\n\tse[v] = 1, num++;\n\tfor (int i = 0; i < Mat[v].size(); i++)\n\t\tif (!se[Mat[v][i]])\n\t\t\tdfs(Mat[v][i]);\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> d[i - 1].first;\n\t\tmp[d[i - 1].first] = i;\n\t\td[i - 1].second = i;\n\t\tcnt[i] = 1;\n\t}\n\tsort(d, d + n);\n\treverse(d, d + n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint k = cnt[d[i].second];\n\t\tif (2 * k > n || mp.find(d[i].first + k - (n - k)) == mp.end())\n\t\t\treturn cout << -1, 0;\n\t\tcnt[mp[d[i].first + k - (n - k)]] += k;\n\t\tedg.push_back({d[i].second, mp[d[i].first + k - (n - k)]});\n\t\tMat[mp[d[i].first + k - (n - k)]].push_back(d[i].second);\n\t\tMat[d[i].second].push_back(mp[d[i].first + k - (n - k)]);\n\t}\n\tdfs(1);\n\tif (num == n && edg.size() == n - 1) {\n\t\tfor (int i = 0; i < edg.size(); i++)\n\t\t\tcout << edg[i].first << ' ' << edg[i].second << endl;\n\t\treturn 0;\n\t}\n\tcout << -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int int_fast64_t\nusing namespace std;\nconst int MX = 1e5 + 100;\nint sz[MX], v[MX];\nvector<int> G[MX];\nmain () {\n    int n; cin >> n;\n    for(int i = 1; i <= n; i ++) cin >> v[i];\n    sort(v + 1, v + 1 + n);\n    unordered_map<int, int> mp;\n    for(int i = 1; i <= n; i ++) mp[v[i]] = i, sz[i] = 1;\n    for(int i = n; i > 1; i --) {\n        int ptr = v[i] - (n - sz[i]) + sz[i];\n        if(ptr >= v[i] or !mp[ptr]) return cout << -1, 0;\n        G[mp[ptr]].push_back(i);\n        sz[mp[ptr]] += sz[i];\n    }\n    for(int i = 1; i <= n; i ++) {\n        for(auto it: G[i]) cout << i << ' ' << it << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long int LL;\nconst int Max_N(100050);\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nstruct node\n{\n\tint u;\n\tLL d;\n};\nint N, Head[Max_N], Next[Max_N], Size[Max_N];\nnode V[Max_N];\nmap<LL, int> S;\n\ninline void Add_Edge(int s, int t)\n{\n\tNext[t] = Head[s], Head[s] = t;\n}\n\ninline bool comp(const node &a, const node &b)\n{\n\treturn a.d > b.d;\n}\n\nLL Sum;\nvoid dfs(int u, int dep)\n{\n\tSum += dep;\n\tfor (int v = Head[u];v;v = Next[v])\n\t\tdfs(v, dep + 1);\n}\n\nvoid dfs2(int u)\n{\n\tif (S[Sum] != u)\n\t{\n\t\tprint(-1);\n\t\texit(0);\n\t}\n\tfor (int v = Head[u];v;v = Next[v])\n\t\tSum += (N - Size[v]) - Size[v], dfs2(v), Sum -= (N - Size[v]) - Size[v];\n}\n\nint main()\n{\n\tgi(N);\n\tfor (int i = 1;i <= N;++i)\n\t\tgi(V[i].d), S[V[i].d] = V[i].u = i, Size[i] = 1;\n\tsort(V + 1, V + 1 + N, comp);\n\tfor (int i = 1, u, fa;i < N;++i)\n\t{\n\t\tu = V[i].u;\n\t\tLL d = V[i].d - (N - Size[u]) + Size[u];\n\t\tif (d >= V[i].d || !(fa = S[d]))\n\t\t{\n\t\t\tprint(-1);\n\t\t\treturn 0;\n\t\t}\n\t\tAdd_Edge(fa, u), Size[fa] += Size[u];\n\t}\n\tdfs(V[N].u, 0);\n\tdfs2(V[N].u);\n\tfor (int u = 1;u <= N;++u)\n\t\tfor (int v = Head[u];v;v = Next[v])\n\t\t\tprint(u), putc(' '), print(v), putc('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\nstruct node\n{\n\tint f,t;\n} t[1000000];\n\nlong long a[1000000],size[1000000],id[1000000],hh[1000000],h,tot;\nmap<long long,int>mp;\n\nvoid make(long long x,long long y)\n{\n\tt[++h].f=hh[x],t[h].t=y,hh[x]=h;\n}\n\nint cmp(int x,int y)\n{\n\treturn a[x]>a[y];\n}\n\nvoid dfs(int x,int y,int z)\n{\n\ttot+=z;\n\tfor(int i=hh[x]; i; i=t[i].f)\n\t{\n\t\tint j=t[i].t;\n\t\tif(j==y) \n\t\t\tcontinue;\n\t\tdfs(j,x,z+1);\n\t}\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<=n; i++) \n\t{\n\t\tscanf(\"%lld\",a+i);\n\t\tmp[a[i]]=i;\n\t\tsize[i]=1;\n\t\tid[i]=i;\n\t}\n\tsort(id+1,id+1+n,cmp);\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tlong long x=id[i],y=a[x]-(n-size[x])+size[x];\n\t\tif(!mp[y]||y>=a[x]) \n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\ty=mp[y];\n\t\tmake(x,y);\n\t\tmake(y,x);\n\t\tsize[y]+=size[x];\n\t}\n\tdfs(id[n],0,0);\n\tif(tot!=a[id[n]]) \n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=hh[i]; j; j=t[j].f)\n\t\t\tif(t[j].t>i) \n\t\t\t\tprintf(\"%d %d\\n\",i,t[j].t);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\n#define int long long\n#define Accepted 0; \n\nconst int Maxv = 100010; \nint d[Maxv], d1[Maxv], u[Maxv], ghostfly233[Maxv], siz[Maxv], cnt, n;  \n\ninline int GldHkkowoSearch(int x) {\n    int tmp = std::lower_bound(d + 1, d + n + 1, x) - d;\n\n    if (d[tmp] != x) {\n        puts(\"-1\"); \n        exit(0); \n    }\n\n    return tmp; \n}\n\nsigned main() {\n    scanf(\"%lld\", &n); \n    for (int i = 1; i <= n; i++) {\n        scanf(\"%lld\", &d[i]); \n        d1[i] = d[i]; \n    }\n\n    std::sort(d + 1, d + n + 1); \n    for (int i = 1; i <= n; i++) \n        ghostfly233[GldHkkowoSearch(d1[i])] = i;       \n\n    for (int i = 1; i <= n; i++)\n        siz[i] = 1; \n\n    for (int i = n; i > 1; i--) {\n        u[i] = GldHkkowoSearch(d[i] - n + (siz[i] << 1)); \n        siz[ u[i] ] += siz[i]; \n        cnt += siz[i]; \n    }\n\n    if (cnt != d[1]) {\n        puts(\"-1\"); \n        return 0; \n    }\n\n    for (int i = 2; i <= n; i++)\n        printf(\"%lld %lld\\n\", ghostfly233[i], ghostfly233[ u[i] ]); \n\n    return Accepted;  \n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N;\n    cin >> N;\n    vector<long long> D(N);\n\n    for (auto &d : D)\n        cin >> d;\n\n    vector<pair<long long, int>> sorted;\n\n    for (int i = 0; i < N; i++)\n        sorted.emplace_back(D[i], i);\n\n    sort(sorted.begin(), sorted.end());\n    vector<int> parent(N, -1);\n    vector<int> subtree_size(N, 1);\n    vector<long long> answer(N, 0);\n\n    for (int i = N - 1; i > 0; i--) {\n        int current = sorted[i].second;\n        long long goal = sorted[i].first - (N - 2 * subtree_size[current]);\n        int index = lower_bound(sorted.begin(), sorted.end(), make_pair(goal, 0)) - sorted.begin();\n        int who = (index < i && sorted[index].first == goal) ? sorted[index].second : -1;\n\n        if (who < 0) {\n            cout << -1 << '\\n';\n            return 0;\n        }\n\n        answer[who] += answer[current] + subtree_size[current];\n        subtree_size[who] += subtree_size[current];\n        parent[current] = who;\n    }\n\n    if (answer[sorted.front().second] != sorted.front().first) {\n        cout << -1 << '\\n';\n        return 0;\n    }\n\n    for (int i = N - 1; i > 0; i--) {\n        int current = sorted[i].second;\n        cout << current + 1 << ' ' << parent[current] + 1 << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e5 + 10;\n\nint id[N],Sz[N];\nll D[N];\nstruct node {\n\tint x,y;\n}G[N];\nmap <ll,int> Map,Id;\n\ninline ll read() {\n\tll x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-')ch = getchar();\n\tif(ch == '-')flag = -1,ch = getchar();\n\twhile(isdigit(ch))x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\nint main() {\n\n\tint n = read();\n\tFor(i,1,n) Map[D[i] = read()] = i,Sz[i] = 1;\n\tsort(D + 1,D + n + 1,greater<ll>());\n\tFor(i,1,n) Id[D[i]] = i;\n\n\tFor(i,1,n - 1) {\n\t\tll Pre = D[i] + Sz[i] * 2 - n,val = Id[Pre];\n\t\tif(!val || Pre >= D[i]) return puts(\"-1\"),0;\n\t\tSz[val] += Sz[i];\n\t\tG[i] = (node){Map[D[i]],Map[D[val]]};\n\t}\n\n\tFor(i,1,n - 1) printf(\"%d %d\\n\",G[i].x,G[i].y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pii pair<int,int>\n#define MP make_pair\nusing namespace std;\nll n;\nmap<ll,int>rev;\nstruct node{ll d,siz,val;int id;}a[100005];\nbool cmp(node x,node y){return x.d>y.d;}\nint back[100005];\nvector<pii>ans;\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        scanf(\"%lld\",&a[i].d);\n        a[i].siz=1;a[i].id=i;\n        rev[a[i].d]=i;\n    }\n    sort(a+1,a+1+n,cmp);\n    for(int i=1;i<=n;i++) back[a[i].id]=i;\n    for(int i=1;i<n;i++){\n        if(n-2*a[i].siz<=0){puts(\"-1\");return 0;}\n        ll dd=a[i].d+2*a[i].siz-n;\n        if(!rev[dd]){puts(\"-1\");return 0;}\n        int fa=rev[dd];\n        ans.push_back(MP(min(fa,a[i].id),max(fa,a[i].id)));\n        a[back[fa]].siz+=a[i].siz;\n        a[back[fa]].val+=a[i].val+a[i].siz;\n    }\n    if(a[n].d!=a[n].val) return puts(\"-1\"),0;\n    sort(ans.begin(),ans.end());\n    for(int i=0;i<n-1;i++) printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=100005;\nmap<int ,int > s;\nint sd[N],fa[N],rt,cnt[N],ne[N],tot,size[N],f[N],fi[N],zz[N],a[N],n;\nint cmp(int x,int y){\n\treturn a[x]>a[y];\n}\nvoid dfs(int x,int z){\n\tsd[x]=z;\n\tfor (int i=fi[x];i;i=ne[i])dfs(zz[i],z+1);\n}\nvoid dfs2(int x){\n\tif (x!=rt)cnt[x]=cnt[fa[x]]+n-2*size[x];\n\tfor (int i=fi[x];i;i=ne[i])dfs2(zz[i]);\n}\nvoid jb(int x,int y){\n\tne[++tot]=fi[x];\n\tfi[x]=tot;\n\tzz[tot]=y;\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor (int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),s[a[i]]=i,f[i]=i;\n\tsort(f+1,f+n+1,cmp);\n\tfor (int i=1;i<=n;i++){\n\t\tsize[f[i]]++;\n\t\tif (i==n)continue;\n\t\tif (!s.count(a[f[i]]-(n-2*size[f[i]]))){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint k=a[f[i]]-(n-2*size[f[i]]);\n\t\tsize[s[k]]+=size[f[i]];fa[f[i]]=s[k];\n\t\tjb(s[k],f[i]);\n\t}\n\trt=0;\n\tfor (int i=1;i<=n;i++)\n\t\tif (!fa[i])dfs(i,0),rt=i;\n\tfor (int i=1;i<=n;i++)cnt[rt]+=sd[i];\t\n\tdfs2(rt);\n\tfor (int i=1;i<=n;i++)\n\t\tif (a[i]!=cnt[i]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\t\n\tfor (int i=1;i<=n;i++)\n\t\tif (fa[i])printf(\"%lld %lld\\n\",i,fa[i]);\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<vector>\n\ntypedef long long ll;\n\nint const N = 1e5 + 5;\n\nint fa[N];\nint sz[N];\nll a[N];\nll dis[N];\nint n;\n\nstd::vector<int> E[N];\nvoid addedge2(int x, int y) {\n    E[x].push_back(y);\n    E[y].push_back(x);\n}\n\nvoid dfs(int x, int pre, int& sum) {\n    ++sum;\n    for(auto y : E[x]) if(y != pre) {\n        dfs(y, x, sum);\n    }\n}\n\nint main() {\n    std::map<ll, int, std::greater<ll> > M;\n    std::ios::sync_with_stdio(0);\n    std::cin >> n;\n    for(int i = 1; i <= n; ++i) {\n        std::cin >> a[i];\n        M.insert(std::make_pair(a[i], i));\n    }\n    for(auto& k : M) if(k.first != (*M.rbegin()).first) {\n        int now = k.second;\n        ++sz[now];\n        ll f = k.first + 2ll * sz[now] - n;\n        if(M.count(f) == 0) {\n            puts(\"-1\");\n            return 0;\n        }\n        fa[now] = M[f];\n        sz[fa[now]] += sz[now];\n        ::addedge2(now, fa[now]);\n    }\n    int sum = 0;\n    dfs(1, -1, sum);\n    if(sum != n) {\n        puts(\"-1\");\n        return 0;\n    }\n    for(int i = 1; i <= n; ++i) if(fa[i] != 0) {\n        std::cout << fa[i] << ' ' << i << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint N;\nint D[110000], n[110000];\nunordered_map<int, int> mp;\nvint ans;\nsigned main() {\n    cin >> N;\n    for (int i = 1; i <= N; i++) {cin >> D[i]; n[i] = 1; mp[D[i]] = i;};\n    sort(D + 1, D + N + 1); reverse(D + 1, D + N + 1);\n    for (int i = 1; i <= N - 1; i++) {\n        int s = mp[D[i]];\n        int t = mp[D[i] - N + 2 * n[s]];\n        if (s == t || t == 0) {\n            cout << -1 << endl;\n            return 0;\n        }\n        n[t] += n[s];\n        ans.push_back(s); ans.push_back(t);\n    }\n    if (n[mp[D[N]]] != N) {\n        cout << -1 << endl;\n        return 0;\n    }\n    for (int i = 0; i < 2 * (N - 1); i += 2) {\n        cout << ans[i] << \" \" << ans[i + 1] << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n#include <bits/stdc++.h>\n\n#define endl '\\n'\n#define int ll\nusing namespace std;\ntypedef long long ll;\n\nclass DisjointSet\n{\nprivate:\n    vector<int> pa, sz;\n\npublic:\n    void init(int n)\n    {\n        pa.resize(n), sz.resize(n);\n        for(int i = 0; i < n; i++)\n        {\n            pa[i] = i, sz[i] = 1;\n        }\n    }\n    int findrt(int x)\n    {\n        if(x == pa[x]) return x;\n        else return pa[x] = findrt(pa[x]);\n    }\n    bool same(int x, int y) { return findrt(x) == findrt(y); }\n    int ccSize(int x) { return sz[findrt(x)]; }\n    void uni(int x, int y)\n    {\n        x = findrt(x), y = findrt(y);\n        if(x == y) return;\n        if(sz[x] > sz[y]) swap(x, y);\n        pa[x] = y, sz[y] += sz[x];\n    }\n};\n\nint vn;\nvector<ll> arr;\nmap<ll, int> val2idx;\n\nvoid init();\nvoid process();\n\nint32_t main()\n{\n    ios::sync_with_stdio(false); cin.tie(0);\n    init();\n    process();\n    cout.flush();\n    return 0;\n}\n\nvoid init()\n{\n    cin >> vn;\n    arr.resize(vn);\n    for(int i = 0; i < vn; i++) cin >> arr[i];\n    sort(arr.begin(), arr.end());\n    for(int i = 0; i < vn; i++) val2idx[arr[i]] = i;\n}\n\nvoid dfs(int idx, const vector<int> &tree, vector<bool> &vis)\n{\n    static vector<bool> in(vn, false);\n    in[idx] = true;\n    if(!in[tree[idx]]) \n    {\n        cout << idx+1 << \" \" << tree[idx]+1 << endl;\n        vis[idx] = true;\n        if(!vis[tree[idx]])\n        {\n            dfs(tree[idx], tree, vis);\n        }\n    }\n    in[idx] = false;\n}\n\nvoid process()\n{\n    vector<int> tree; tree.resize(vn);\n    DisjointSet ds; ds.init(vn);\n    for(int i = vn-1; i >= 0; i--)\n    {\n        if(ds.ccSize(i) == 1)\n        {\n            int idx = i;\n            while(true)\n            {\n                ll paVal = arr[idx] - vn + 2*ds.ccSize(idx);\n                if(val2idx.count(paVal) == 0) break;\n                int paidx = val2idx[paVal];\n                if(ds.same(idx, paidx)) break;\n                tree[idx] = paidx;\n                ds.uni(idx, paidx);\n                idx = paidx;\n            }\n        }\n    }\n    if(ds.ccSize(0) == vn)\n    {\n        vector<bool> vis(vn, false);\n        for(int i = 0; i < vn; i++)\n        {\n            if(!vis[i]) dfs(i, tree, vis);\n        }\n    }\n    else cout << -1 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<60)+1e9; // ~ 1.15 * 1e18\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\n\nint check(vector<vector<int> > G, int root,int d){\n\n  function<int(int,int,int)>  dfs = [&](int pos,int pre,int dis){\n    int res = 0;\n    for(int to:G[pos]){\n      if(to == pre) continue;\n      res += dfs(to, pos, dis+1);\n    }\n    return res;\n  };\n  return dfs(root, -1, 0) == d;\n}\n\nsigned main(){\n  srand((unsigned)time(NULL));\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n;\n  cin>>n;\n  vector<P> D(n);\n  map<int,int> num;\n  map<int,int> inv;\n  for(int i=0;i<n;i++){\n    int d;\n    cin>>d;\n    D[i] = P(d, i);\n    num[d] = i;\n    inv[i] = d;\n  }\n  sort(D.begin(), D.end(), greater<P>());\n\n  vector<int> sz(n, 1);\n  vector<vector<int> > G(n);\n\n  auto add_edge = [&](int a,int b){\n    G[a].push_back(b);\n    G[b].push_back(a);\n  };\n\n  \n  for(int i=0;i<n-1;i++){\n    int d, pos; tie(d, pos) = D[i];\n    int x  = sz[pos];\n    int nd = d + x - (n - x);\n\n    if(!num.count(nd)){\n      cout<<-1<<endl;\n      return 0;\n    }\n    int to = num[nd];\n    if(inv[pos] <= inv[to]){\n      cout<<-1<<endl;\n      return 0;\n    }\n    \n    add_edge(pos, to);\n    sz[to] += sz[pos];\n  }\n\n  if(check(G, D[n-1].second, D[n-1].first)){\n    cout<<-1<<endl;\n    return 0;\n  }\n\n  for(int i=0;i<n;i++)\n    for(int to:G[i]){\n      if(i > to) continue;\n      cout<<i+1<<\" \"<<to+1<<endl;\n    }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\nmap<long long,int> id;\nint size[100005];\nlong long w[100005];\nvector<pair<int,int> >e;\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tlong long D;\n\t\tscanf(\"%lld\",&D);\n\t\tid[D]=i;\n\t}\n\tfor(int i=1;i<=n;i++)size[i]=1,w[i]=0;\n\tfor(int j=1;j<n;j++){\n\t\tlong long d=id.rbegin()->first;\n\t\tint x=id.rbegin()->second;\n\t\tid.erase(d);\n\t\td-=n-2*size[x];\n\t\tif(!id.count(d)||size[x]*2>n){puts(\"-1\"); return 0;}\n\t\te.push_back(make_pair(id[d],x));\n\t\tsize[id[d]]+=size[x];\n\t\tw[id[d]]+=w[x]+size[x];\n\t}\n\tif(size[id.begin()->second]!=n||w[id.begin()->second]!=id.begin()->first){puts(\"-1\"); return 0;}\n\tfor(int i=0;i<e.size();i++)printf(\"%d %d\\n\",e[i].first,e[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <tr1/unordered_map>\n\n#define For(i, l, r) for (int i = l; i <= r; ++ i)\n#define Travel(i, u) for (int i = beg[u], v = to[i]; i; v = to[i = nex[i]])\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline void File() {\n\tfreopen(\"f.in\", \"r\", stdin);\n\tfreopen(\"f.out\", \"w\", stdout);\n}\n\nconst int N = 1e5 + 10;\nint e = 1, beg[N], nex[N << 1], to[N << 1], n;\nint ansu[N], ansv[N];\nll sz[N], tmp, dis[N];\n\nstruct node { ll v; int id; } P[N];\ninline bool cmp(const node &a, const node &b) { return a.v > b.v; }\n\ntr1::unordered_map<ll, int> mp;\n\ninline void add(int x, int y) {\n\tto[++ e] = y, nex[e] = beg[x], beg[x] = e;\n}\n\ninline void dfs1(int u, int l, int rt) {\n\tdis[rt] += l;\n\tTravel(i, u) dfs1(v, l + 1, rt);\n}\n\ninline void dfs2(int u) {\n\tTravel(i, u) dis[v] = dis[u] - (sz[v] * 2 - n), dfs2(v);\n}\n\nint main() {\n\n\tscanf(\"%d\", &n);\n\tFor(i, 1, n) {\n\t\tscanf(\"%lld\", &P[i].v); \n\t\tP[i].id = i, mp[P[i].v] = i, sz[i] = 1;\n\t}\n\n\tsort(P + 1, P + 1 + n, cmp);\n\n\tfor (int i = 1, u, v; i < n; ++ i) {\n\t\tu = P[i].id, tmp = P[i].v + 2 * sz[u] - n;\n\t\t\n\t\tif (n <= sz[u] << 1) return puts(\"-1\"), 0;\n\t\tif (!mp.find(tmp)) return puts(\"-1\"), 0;\n\t\t\n\t\tv = mp[tmp], ansu[i] = u, ansv[i] = v;\n\t\tadd(v, u), sz[v] += sz[u];\n\t}\t\n\n\tint rt = P[n].id; dfs1(rt, 0, rt), dfs2(rt);\n\n\tFor(i, 1, n) if (dis[P[i].id] ^ P[i].v) return puts(\"-1\"), 0;\n\t\n\tFor(i, 1, n - 1) printf(\"%d %d\\n\", ansu[i], ansv[i]);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define inf 0x3f3f3f3f\n#define mod 1000000007\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define vi vector <int>\n#define pii pair <int, int>\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i,n) for (int i = 0; i < (int) (n); ++ i)\n#define foreach(it,c) for (__typeof(c.begin()) it = c.begin(); it != c.end(); ++ it)\n\ninline int read() {\n\tint x = 0, f = 1, c = getchar();\n\tfor (;!isdigit(c);c = getchar()) if (c == '-') f ^= 1;\n\tfor (; isdigit(c);c = getchar()) x = x * 10 + c - '0';\n\treturn f ? x : -x;\n}\n\nint n;\nll d[100005];\nmap <ll, int> st;\nvector <pii> e;\nint siz[100005];\nvi g[100005];\n\nll dfs(int u, int p) {\n\tll dd = 0;\n\trep(i, g[u].size()) if (g[u][i] != p) dd += siz[g[u][i]] + dfs(g[u][i], u);\n\treturn dd;\n}\n\nint main() {\n\tn = read();\n\trep(i, n) scanf(\"%lld\", &d[i]);\n\trep(i, n) st[d[i]] = i;\n\tint rt = st.begin() -> second;\n\trep(i, n) siz[i] = 1;\n\twhile (!st.empty()) {\n\t\tll mx = st.rbegin() -> second;\n\t\tif (mx == rt) break;\n\t\tst.erase(d[mx]);\n\t\tll nxd = d[mx] - (n - 2 * siz[mx]);\n\t\tif (!st.count(nxd)) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[st[nxd]] += siz[mx];\n\t\te.pb(mp(mx, st[nxd]));\n\t\tg[mx].pb(st[nxd]); g[st[nxd]].pb(mx);\n\t}\n\tif (dfs(rt, -1) != d[rt]) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\trep(i, e.size()) printf(\"%d %d\\n\", e[i].first + 1, e[i].second + 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\nmap<long long,int> id;\nint size[100005];\nvector<pair<int,int> >e;\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tlong long D;\n\t\tscanf(\"%lld\",&D);\n\t\tid[D]=i;\n\t}\n\tfor(int i=1;i<=n;i++)size[i]=1;\n\tfor(int j=1;j<n;j++){\n\t\tlong long d=id.rbegin()->first;\n\t\tint x=id.rbegin()->second;\n\t\tid.erase(d);\n\t\td-=n-2*size[x];\n\t\tif(!id.count(d)){puts(\"-1\"); return 0;}\n\t\te.push_back(make_pair(id[d],x));\n\t\tsize[id[d]]+=size[x];\n\t}\n\tfor(int i=0;i<e.size();i++)printf(\"%d %d\\n\",e[i].first,e[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = 1e18;\nconst ll MOD = 1000000007;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\nvii child(100010);\nvi depth(100010);\nbitset<100010> used;\n\nint dfs(int now, int par, int dep) {\n  int res = 1;\n  depth[now] = dep;\n  used[now] = true;\n  rep (i, child[now].size()) {\n    int nex = child[now][i];\n    if (nex == par || used[nex]) {\n      continue;\n    }\n    res += dfs(nex, now, dep + 1);\n  }\n  return res;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  vector<pll> d(n);\n  map<ll, int> mp;\n  rep (i, n) {\n    cin >> d[i].first;\n    d[i].second = i;\n    mp[d[i].first] = i;\n  }\n  sort(all(d));\n  reverse(all(d));\n  vi p(n);\n  vi num(n, 1);\n  int root = d.back().second;\n  p[root] = -1;\n  num[root] = n;\n  rep (i, n - 1) {\n    int v = d[i].second;\n    ll su = d[i].first + 2 * num[v] - n;\n    int u;\n    try {\n      u = mp.at(su);\n    }\n    catch (...) {\n      cout << -1 << endl;\n      return 0;\n    }\n    p[v] = u;\n    child[u].push_back(v);\n    num[u] += num[v];\n  }\n  if (dfs(root, -1, 0) != n) {\n    cout << -1 << endl;\n    return 0;\n  }\n  ll sr = 0;\n  rep (i, n) {\n    sr += depth[i];\n  }\n  if (sr != d.back().first) {\n    cout << -1 << endl;\n    return 0;\n  }\n  rep (i, n) {\n    if (p[i] == -1) {\n      continue;\n    }\n    cout << i + 1 << \" \" << p[i] + 1 << endl;\n  }\n}\n  \n  \n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n \n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define all(v) begin(v), end(v)\n#define debug(x) std::cerr<< #x <<\": \"<<x<<\"\\n\"\n#define debug2(x,y) std::cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<\"\\n\"\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef deque<bool> db;\ntemplate<class T> using vv=vector<vector< T > >;\n\ninline void scan(int&a){scanf(\"%d\",&a);}\ninline void scan(int&a,int&b){scanf(\"%d%d\",&a,&b);}\ninline void scan(int&a,int&b,int&c){scanf(\"%d%d%d\",&a,&b,&c);}\ninline void scan(int&a,int&b,int&c,int&d){scanf(\"%d%d%d%d\",&a,&b,&c,&d);}\ninline void scan(vector<int>&v){int sz=v.size();rep(i,sz){scan(v[i]);}}\ninline void scan(vector<vector<int> >&v){int sz=v.size();rep(i,sz){scan(v[i]);}}\ninline void scan(ll&a){scanf(\"%lld\",&a);}\ninline void scan(ll&a,ll&b){scanf(\"%lld%lld\",&a,&b);}\ninline void scan(ll&a,ll&b,ll&c){scanf(\"%lld%lld%lld\",&a,&b,&c);}\ninline void scan(ll&a,ll&b,ll&c,ll&d){scanf(\"%lld%lld%lld%lld\",&a,&b,&c,&d);}\ninline void scan(vector<ll>&v){int sz=v.size();rep(i,sz){scan(v[i]);}}\ninline void scan(vector<vector<ll> >&v){int sz=v.size();rep(i,sz){scan(v[i]);}}\ninline void scan(char&a){scanf(\" %c\",&a);}\ninline void scan(vector<char>&v){int sz=v.size();rep(i,sz){scan(v[i]);}}\ninline void scan(vector<vector<char> >&v){int sz=v.size();rep(i,sz){scan(v[i]);}}\ninline void scan(string&s){char BUF[3000000];scanf(\" %s\",BUF);s=string(BUF);}\n\ninline void print(int a){printf(\"%d\\n\",a);}\ninline void print(int a,int b){printf(\"%d %d\\n\",a,b);}\ninline void print(ll a){printf(\"%lld\\n\",a);}\ninline void print(ll a,ll b){printf(\"%lld %lld\\n\",a,b);}\ninline void print(string s){cout << s << \"\\n\";}\ninline void print_yn(bool flg){if(flg){printf(\"Yes\\n\");}else{printf(\"No\\n\");}}\n\n// cout vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len=v.size();s<<\"\\n\";rep(i,len){s<<v[i];if(i<len-1){s << \"\\t\";}}s<<\"\\n\";return s; }\n// cout 2-dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& vv) {\n  int len=vv.size();rep(i,len){s<<vv[i];} return s; }\n// cout deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque<T>& v) {\n  int len=v.size();s<<\"\\n\";rep(i,len){s<<v[i];if(i<len-1){s << \"\\t\";}}s<<\"\\n\";return s; }\n// cout 2-dimentional deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque< deque<T> >& vv) {\n  int len=vv.size();rep(i,len){s<<vv[i];} return s; }\n// cout set<cout-able>\ntemplate<typename T> ostream& operator<<(ostream& s, const set<T>& v) {\n  s<<\"\\n\";for(auto elm : v){s<<elm<<\"\\t\";}s<<\"\\n\";return s; }\n\nint main() {\n  int n;\n  scan(n);\n  vvll d(n, vll(2));\n  unordered_map<ll, int> mp;\n  rep (i, n) {\n    scanf(\"%lld\", &d[i][0]);\n    d[i][1] = i;\n    mp[d[i][0]] = i;\n  }\n  sort(all(d));\n  reverse(all(d));\n  vi parent(n, -1);\n  vvi childs(n);\n  vi allcnt(n, 0); // sum cnt of all childs\n  vvi edges;\n  vll accum_d(n, 0);\n  rep (i, n-1) {\n    int ind = d[i][1];\n    allcnt[ind] = 1;\n    for (auto c : childs[ind]) {\n      allcnt[ind] += allcnt[c];\n      accum_d[ind] += (accum_d[c] + allcnt[c]);\n    }\n    int diff = n - allcnt[ind] * 2;\n    if (diff <= 0) {\n      printf(\"-1\\n\");\n      return 0;\n    }\n    ll next_d = d[i][0] - diff;\n    if (mp.find(next_d) != mp.end()) {\n      int par_ind = mp[next_d];\n      parent[ind] = par_ind;\n      childs[par_ind].push_back(ind);\n      edges.push_back((vi){ind, par_ind});\n    } else {\n      printf(\"-1\\n\");\n      return 0;\n    }\n  }\n  {\n    int ind = d[n-1][1];\n    for (auto c : childs[ind]) {\n      accum_d[ind] += (accum_d[c] + allcnt[c]);\n    }\n    if (accum_d[ind] != d[n-1][0]) {\n      printf(\"-1\\n\");\n      return 0;\n    }\n  }\n  assert((int)edges.size() == n-1);\n  rep (i, n-1) {\n    printf(\"%d %d\\n\", edges[i][0]+1, edges[i][1]+1);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#define MAXN 100005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll n,d[MAXN],p[MAXN],sz[MAXN];\nll f[MAXN],g[MAXN];\nvector<P> v;\nvector<ll> G[MAXN];\nvector<P> E;\nvoid add_edge(ll u,ll v)\n{\n    G[u].push_back(v);G[v].push_back(u);\n    E.push_back(P(u,v));\n}\nvoid dfs1(ll v,ll p)\n{\n    sz[v]=1;\n    for(auto to:G[v])\n    {\n        if(to==p) continue;\n        dfs1(to,v);\n        sz[v]+=sz[to];\n        f[v]+=sz[to]+f[to];\n    }\n}\nvoid dfs2(ll v,ll p)\n{\n    for(auto to:G[v])\n    {\n        if(to==p) continue;\n        g[to]=g[v]+n-2*sz[to];\n        dfs2(to,v);\n    }\n}\nint main()\n{\n    scanf(\"%lld\",&n);\n    for(ll i=1;i<=n;i++) scanf(\"%lld\",&d[i]);\n    for(ll i=1;i<=n;i++) v.push_back(P(d[i],i));\n    sort(v.begin(),v.end());\n    bool fl=true;\n    for(ll i=n-1;i>0;i--)\n    {\n        sz[v[i].S]++;\n        ll to=d[v[i].S]+2*sz[v[i].S]-n;\n        auto it=lower_bound(v.begin(),v.end(),P(to,0));\n        if(it==v.end()||it->F!=to) \n        {\n            fl=false;\n            break;\n        }\n        add_edge(v[i].S,it->S);\n        p[v[i].S]=it->S;\n        sz[it->S]+=sz[v[i].S];\n    }\n    if(!fl)\n    {\n        puts(\"-1\");\n        return 0;\n    }\n    dfs1(v[0].S,0);g[v[0].S]=f[v[0].S];dfs2(v[0].S,0);\n    for(ll i=1;i<=n;i++) if(g[i]!=d[i]) {puts(\"-1\"); return 0;}\n    for(auto p:E) printf(\"%lld %lld\\n\",p.F,p.S);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<long long int>v(N);\n\tmap<long long int, int>m;\n\tmap<long long int, int>used;\n\tL = LLONG_MAX;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> v[i];\n\t\tm[v[i]] = i + 1;\n\t\tL = min(L, v[i]);\n\t}\n\tvector<pair<int, int>>ans;\n\tsort(v.begin(), v.end());\n\treverse(v.begin(), v.end());\n\tfor (auto i : v) {\n\t\tlong long int dif = N - 2;\n\t\tlong long int box = i;\n\t\twhile (box > L) {\n\t\t\tif (used[box])break;\n\t\t\tif (m.find(box - dif) == m.end()) {\n\t\t\t\tcout << \"-1\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tans.push_back({ m[box],m[box - dif] });\n\t\t\t//cout << m[box] << \" \" << m[box - dif] << endl;\n\t\t\tused[box]++;\n\t\t\tbox -= dif;\n\t\t\tdif -= 2;\n\t\t}\n\t}\n\tfor (auto i : ans) {\n\t\tcout << i.first << \" \" << i.second << endl;\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<vector>\n#include<queue>\n#include<deque>\n#define ll long long\n#define mp make_pair\n#define rep(i,x,y) for(int i=(x);i<=(y);++i)\n#define r0p(i,n) for(int i=0;i<n;++i)\n#pragma GCC optimize(1)\n#pragma G++ optimize(1)\n#pragma GCC optimize(2)\n#pragma G++ optimize(2)\n#pragma GCC optimize(3)\n#pragma G++ optimize(3)\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#define pii pair<int,int>\n#pragma GCC diagnostic error \"-std=c++11\"\nusing namespace std;\ninline void rdl(long long &val){\n    long long x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n\t}\n\twhile(ch>='0' and ch<='9'){\n\t    x=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n    val=x*f;\n}\ninline void rdi(int &val){\n    int x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    val=x*f;\n}\ninline long long rdl(){\n    long long x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline int rdi(){\n    int x=0;\n    int f=1;\n\tchar ch=getchar();\n\twhile((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n\tif(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline void write(int x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\ninline void _write(int x){\n\twrite(x);\n\tputchar(' ');\n}\ninline void print(int x){\n\twrite(x);\n\tputchar('\\n');\n}\ninline void write(ll x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\ninline void _write(ll x){\n\twrite(x);\n\tputchar(' ');\n}\ninline void print(ll x){\n\twrite(x);\n\tputchar('\\n');\n}\nstruct dsu{\n\tint par[200200];\n\tinline void init(int _n){for(int i=0;i<_n;++i) par[i]=i;}\n\tinline int find(int now){\n\t\tif(par[now]==now) return now;\n\t\treturn par[now]=find(par[now]);\n\t}\n\tinline bool uni(int a, int b){\n\t\tint Pa(find(a)),Pb(find(b));\n\t\tif(Pa==Pb) return false;\n\t\tpar[Pa]=Pb;\n\t\treturn true;\n\t}\n};\nmap<ll,int> m;\nmap<int,ll>m2;\nvector<pair<int,int> >ans;\nint n;\nll x;\nsigned main(){\n\trdi(n);\n\tint i,j;\n\tll mn=100000000000000ll;\n\tll cnt=n;\n\tfor(i=1;i<=n;++i) rdl(x),m[x]=i,mn=min(mn,x),m2[i]=x;\n\twhile(cnt>1){\n\t\tmap<ll,int>::iterator it=m.end();it--;\n\t\tll t=it->first;\n\t\tll now=n;\n\t\tll tt=t;\n\t\twhile(t>mn){\n\t\t\tt-=now-2;\n\t\t\tnow-=2;\n\t\t\tif(m.find(t)==m.end()){\n\t\t\t\tprint(-1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(now<=0){\n\t\t\t\tprint(-1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tans.push_back(mp(m[t],m[tt]));\n\t\t\tm2.erase(m[tt]);\n\t\t\tm.erase(tt);\n\t\t\ttt=t;\n\t\t\t--cnt;\n\t\t}\n\t}\n\tfor(int i=0;i<ans.size();++i) _write(ans[i].first),print(ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nconst long long mo=50000007;\nconst int maxn=200010;\n\nint n,m,id[maxn],fa[maxn];\nlong long d[maxn],siz[maxn],ans,js[maxn];\nint tot,nex[maxn*2],las[maxn*2],tov[maxn*2];\nint hs[mo+10];\n\nvoid con(int x,int y)\n{\n\ttot++;\n\ttov[tot]=y;\n\tnex[tot]=las[x];\n\tlas[x]=tot;\n}\n\nvoid insert(long long x,int id)\n{\n\tlong long i=x%mo;\n\twhile (hs[i]!=0)\n\t{\n\t\ti++;\n\t\tif (i==mo) i=0;\n\t}\n\ths[i]=id;\n}\n\nlong long find(long long x)\n{\n\tlong long i=x%mo;\n\twhile (hs[i]!=0 && d[hs[i]]!=x)\n\t{\n\t\ti++;\n\t\tif (i==mo) i=0;\n\t}\n\treturn hs[i];\n}\n\nvoid qsort(int l,int r)\n{\n\tint i=l;int j=r;\n\tlong long m=d[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (d[i]>m) i++;\n\t\twhile (d[j]<m) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(d[i],d[j]);\n\t\t\tswap(id[i],id[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort(l,j);\n\tif (r>i) qsort(i,r);\n}\n\nvoid dfs(int x,int ff)\n{\n\tjs[x]=js[ff]+1;\n\tfor (int i=las[x];i;i=nex[i])\n\t{\n\t\tif (tov[i]!=ff)\n\t\t{\n\t\t\tdfs(tov[i],x);\n\t\t\tans+=js[x];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&d[i]);\n\t\tid[i]=i;\n\t\tsiz[i]=1;\n\t}\n\tqsort(1,n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinsert(d[i],i);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tlong long op=d[i]-abs(n-2*siz[i]);\n\t\tlong long oq=find(op);\n\t\tif (oq==0)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfa[i]=oq;\n\t\t\tsiz[oq]+=siz[i];\n\t\t\tcon(i,oq);con(oq,i);\n\t\t}\n\t}\n\tdfs(n,0);\n\tif (ans!=d[n])\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tfor (int i=1;i<n;i++)\n\t\t{\n\t\t\tprintf(\"%d %d\\n\",id[i],id[fa[i]]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\nconst int inf = (1 << 30) - 1;\nconst int64 infll = (1LL << 61) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\nint main() {\n  int N;\n  cin >> N;\n  set< pair< int64, int > > que;\n  for(int i = 0; i < N; i++) {\n    int64 d;\n    cin >> d;\n    que.emplace(d, i);\n  }\n\n  vector< int > par(N, -1), size(N, 1);\n  while(que.size() >= 2) {\n    auto p = *prev(que.end());\n    que.erase(p);\n    const int other = N - size[p.second];\n    int64 latte = p.first + size[p.second] - other;\n\n    auto it = que.lower_bound({latte, -1});\n    if(it == que.end() || it->first != latte) {\n      cout << -1 << endl;\n      return 0;\n    }\n    size[it->second] += size[p.second];\n    par[p.second] = it->second;\n  }\n  throw 0;\n  \n  for(int i = 0; i < N; i++) {\n    if(~par[i]) cout << par[i] + 1 << \" \" << i + 1 << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define int long long\nusing namespace std;\ntypedef long long LL;\nconst int N = 1e5 + 5;\nint read() {\n\tint x = 0, f = 1; char ch;\n\twhile(! isdigit(ch = getchar())) (ch == '-') && (f = -f);\n\tfor(x = ch ^ 48; isdigit(ch = getchar()); x = (x << 3) + (x << 1) + (ch ^ 48));\n\treturn x * f;\n}\ntemplate <class T> T Max(T a, T b) { return a > b ? a : b; }\ntemplate <class T> T Min(T a, T b) { return a < b ? a : b; }\\\nstruct Edge {\n\tint to;\n\tEdge *nxt;\n\tEdge(int to, Edge *nxt) : to(to), nxt(nxt) {}\n} *head[N];\nvoid add(int x, int y) {head[x] = new Edge(y, head[x]);}\nstruct edge {int x, y;} a[N];\nstruct node {\n\tint d, id;\n\tfriend bool operator < (node a, node b) {\n\t\treturn a.d == b.d ? a.id < b.id : a.d > b.d;\n\t}\n} e[N];\nint n, tot, siz[N], dis[N];\nvoid dfs(int x, int f) {\n\tfor(Edge *i = head[x]; i; i = i->nxt) {\n\t\tif(i->to == f) continue;\n\t\tdis[i->to] = dis[x] + 1;\n\t\tdfs(i->to, x);\n\t}\n}\nsigned main() {\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tn = read();\n\tfor(int i = 1; i <= n; ++ i) siz[i] = 1, e[i] = (node){read(), i};\n\tsort(e + 1, e + n + 1);\n\tfor(int i = 1; i < n; ++ i) {\n\t\tint delta = e[i].d + 2 * siz[i] - n;\n\t\tint l = 1, r = n + 1;\n\t\twhile(l < r) {\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tif(e[mid].d <= delta) r = mid;\n\t\t\telse l = mid + 1;\n\t\t}\n\t\tif(e[l].d != delta) return puts(\"-1\"), 0;\n\t\tint x = e[i].id, y = e[l].id;\n\t\tadd(x, y); add(y, x);\n\t\ta[++ tot] = (edge) {x, y};\n\t\tsiz[l] += siz[i];\n\t}\n\tdfs(e[n].id, 0);\n\tLL sum = 0;\n\tfor(int i = 1; i <= n; ++ i) sum += dis[i];\n\tif(sum == e[n].d) for(int i = 1; i <= tot; ++ i) printf(\"%d %d\\n\", a[i].x, a[i].y);\n\telse puts(\"-1\");\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Zory-2018\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n#include<set>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<bitset>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nnamespace mine\n{\n\ttypedef long long ll;\n\tconst int INF=0x3f3f3f3f;\n\n\tconst int MAX_N=110000;\n\tstruct Nod\n\t{\n\t\tll d;int p;\n\t\tfriend bool operator < (Nod a,Nod b) {return a.d<b.d;}\n\t};\n\tset<Nod> s;\n\tint siz[MAX_N];\n\n\t#define PR pair<int,int>\n\tvector<PR> ans;\n\tint n;\n\tbool solve(int op)\n\t{\n\t\tNod now;\n\t\tif(op) now=*(--s.end());\n\t\telse now=*s.begin();\n\n\t\tif(siz[now.p]>n/2) return 0;\n\n\t\ts.erase(s.find(now));\n\t\tif(s.begin()==s.end()) return 0;//root\n\n\t\t//printf(\"now=%d p[now].d=%lld \",now.p,now.d);\n\n\t\tll want=now.d-n+2*siz[now.p];Nod fa=*(s.lower_bound((Nod){want,0}));\n\t\t//printf(\"siz=%d want=%lld fa.d=%lld\\n\",siz[now.p],want,fa.d);\n\t\tif(fa.d!=want) {puts(\"-1\");exit(0);}\n\t\tans.push_back( make_pair(now.p,fa.p) );\n\t\tsiz[fa.p]+=siz[now.p];\n\t\treturn 1;\n\t}\n\tvoid main()\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tll t;scanf(\"%lld\",&t);\n\t\t\ts.insert( (Nod){t,i} );\n\t\t\tsiz[i]=1;\n\t\t}\n\n\t\twhile(solve(1)) ;\n\t\twhile(solve(0)) ;\n\t\t//int rt=(n+1)/2;\n\t\t//for(int i=n;i>rt;i--) solve(1);\n\t\t//for(int i=1;i<rt;i++) solve(0);\n\t\tfor(int i=0;i<(int)ans.size();i++) printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\t}\n}\nint main()\n{\n\tmine::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing nagai = long long;\nusing ll = long long;\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n    int n;\n    cin >> n;\n    vector<nagai> d(n);\n    for (auto& x : d)\n        cin >> x;\n    vector<int> ord(n);\n    iota(ord.begin(), ord.end(), 0);\n    sort(ord.begin(), ord.end(), [&](int a, int b)\n            {\n             return d[a] > d[b];\n            });\n    map<nagai, int> mp;\n    for (int i = 0; i < n; ++i)\n        mp[d[i]] = i;\n    vector<int> sz(n, 1);\n    vector<pair<int, int>> edg;\n    vector<bool> used(n);\n    ord.pop_back();\n    for (int x : ord)\n    {\n        used[x] = true;\n        nagai dp = d[x] + sz[x] - (n - sz[x]);\n        if (!mp.count(dp) || used[mp[dp]])\n        {\n             cout << -1 << '\\n';\n             return 0;\n        }\n        edg.emplace_back(mp[dp], x);\n        sz[mp[dp]] += sz[x];\n    }\n    for (auto& x : edg)\n        cout << x.first + 1 << ' ' << x.second + 1 << '\\n';\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nconst long long mo=50000007;\nconst int maxn=200010;\n\nint n,m,id[maxn],fa[maxn];\nlong long d[maxn],siz[maxn],ans,js[maxn];\nint tot,nex[maxn*2],las[maxn*2],tov[maxn*2];\nint hs[mo+10];\n\nvoid con(int x,int y)\n{\n\ttot++;\n\ttov[tot]=y;\n\tnex[tot]=las[x];\n\tlas[x]=tot;\n}\n\nvoid insert(long long x,int id)\n{\n\tlong long i=x%mo;\n\twhile (hs[i]!=0)\n\t{\n\t\ti++;\n\t\tif (i==mo) i=0;\n\t}\n\ths[i]=id;\n}\n\nlong long find(long long x)\n{\n\tlong long i=x%mo;\n\twhile (hs[i]!=0 && d[hs[i]]!=x)\n\t{\n\t\ti++;\n\t\tif (i==mo) i=0;\n\t}\n\treturn hs[i];\n}\n\nvoid qsort(int l,int r)\n{\n\tint i=l;int j=r;\n\tlong long m=d[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (d[i]>m) i++;\n\t\twhile (d[j]<m) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(d[i],d[j]);\n\t\t\tswap(id[i],id[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort(l,j);\n\tif (r>i) qsort(i,r);\n}\n\nvoid dfs(int x,int ff)\n{\n\tjs[x]=js[ff]+1;\n\tfor (int i=las[x];i;i=nex[i])\n\t{\n\t\tif (tov[i]!=ff)\n\t\t{\n\t\t\tdfs(tov[i],x);\n\t\t\tans+=js[x];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&d[i]);\n\t\tid[i]=i;\n\t\tsiz[i]=1;\n\t}\n\tqsort(1,n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinsert(d[i],i);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tlong long op=d[i]-abs(n-2*siz[i]);\n\t\tlong long oq=find(op);\n\t\tif (oq==0 && oq==i)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfa[i]=oq;\n\t\t\tsiz[oq]+=siz[i];\n\t\t\tcon(i,oq);con(oq,i);\n\t\t}\n\t}/*\n\tdfs(n,0);\n\tif (ans!=d[n])\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\telse*/\n\t{\n\t\tfor (int i=1;i<n;i++)\n\t\t{\n\t\t\tprintf(\"%d %d\\n\",id[i],id[fa[i]]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// ====================================\n//   author: M_sea\n//   website: https://m-sea-blog.com/\n// ====================================\n#include <bits/stdc++.h>\n#define file(x) freopen(#x\".in\",\"r\",stdin); freopen(#x\".out\",\"w\",stdout)\nusing namespace std;\ntypedef long long ll;\n\nll read() {\n\tll X=0; char c=getchar();\n\twhile (c<'0'||c>'9') c=getchar();\n\twhile (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n\treturn X;\n}\n\nconst int N=100000+10;\n\nint n,sz[N],dep[N];\npair<ll,int> d[N];\nvector<int> E[N];\nvector<pair<int,int> > ans;\n\nvoid dfs(int u,int f) {\n\tdep[u]=dep[f]+1;\n\tfor (int v:E[u]) if (v!=f) dfs(v,u);\n}\n\nint main() {\n\tn=read();\n\tfor (int i=1;i<=n;++i) d[i]=make_pair(read(),i);\n\tsort(d+1,d+n+1);\n\tfor (int i=1;i<=n;++i) sz[i]=1;\n\tfor (int i=n;i>1;--i) {\n\t\tll dlt=2*sz[d[i].second]-n+d[i].first;\n\t\tint p=lower_bound(d+1,d+n+1,make_pair(dlt,0))-d;\n\t\tif (d[p].first!=dlt) { puts(\"-1\"); return 0; }\n\t\tint u=d[i].second,v=d[p].second;\n\t\tans.emplace_back(make_pair(u,v));\n\t\tE[u].emplace_back(v),E[v].emplace_back(u),sz[v]+=sz[u];\n\t}\n\tdep[0]=-1,dfs(d[1].second,0); ll s=0;\n\tfor (int i=1;i<=n;++i) s+=dep[i];\n\tif (s!=d[1].first) { puts(\"-1\"); return 0; }\n\tfor (auto i:ans) printf(\"%d %d\\n\",i.first,i.second);\n\treturn 0;\n}\n// /jk"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<unordered_map>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\n\nusing namespace std;\nint NOE(){\n    cout<<-1<<endl;\n    return 0;\n}\n\nunordered_map<ll,ll> mas;\n#define N 100010\nvector<ll> g[N];\nll n,d[N],s[N];\nvoid AddEdge(ll a,ll b){\n    s[b]+=s[a];\n    g[a].push_back(b);\n    g[b].push_back(a);\n}\n\nclass Judge{public:\n    ll f[N],s[N];\n    void dfs(ll x,ll bef){\n\tll res=0,sum=1;\n\tfor(auto y:g[x]){\n\t    if(y==bef)continue;\n\t    dfs(y,x);\n\t    res+=f[y];\n\t    sum+=s[y];\n\t}\n\ts[x]=sum;\n\tf[x]=res+sum-1;\n    }\n    bool Main(){\n\tdfs(0,-1);\n\treturn d[0]==f[0];\n    }\n};\n\nunordered_map<ll,ll> ans;\nint main(){\n    cin>>n;\n    lol(i,n){\n\tcin>>d[i];\n\ts[i]=1;\n\tans[d[i]]=i+1;\n    }\n    sort(d,d+n,greater<ll>());\n    lol(i,n)mas[d[i]]=i;\n    lol(i,n-1){\n\tll to=d[i]+2*s[i]-n;\n\tif(d[i]<=to)return NOE();\n\tif(mas.find(to)==mas.end())return NOE();\n\tAddEdge(i,mas[to]);\n    }\n    Judge jd;\n    if(jd.Main()==0)return NOE();\n    lol(i,n){\n\tfor(auto x:g[i]){\n\t    if(i<x)cout<<ans[d[i]]<<\" \"<<ans[d[x]]<<endl;\n\t}\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\n#define pli pair<LL, int>\n#define MP make_pair\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 100005;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\nvoid gg() {\n\tputs(\"-1\");\n\texit(0);\n}\n\nint n, siz[MAXN];\npli p[MAXN];\nvector<int> e[MAXN];\nLL sum[MAXN];\n\nvoid DFS1(int u) {\n\tfor (auto v : e[u]) {\n\t\tDFS1(v);\n\t\tsum[u] += sum[v] + siz[v];\n\t}\n}\n\nvoid DFS2(int u) {\n\tfor (auto v : e[u]) {\n\t\tsum[v] = sum[u] + n - siz[v] * 2;\n\t\tDFS2(v);\n\t}\n}\n\nvoid init() {\n\tread(n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tread(p[i].fi);\n\t\tp[i].se = i;\n\t}\n\tsort(p + 1, p + n + 1);\n}\n\nvoid solve() {\n\tfor (int i = n; i > 1; --i) {\n\t\tint u = p[i].se;\n\t\tsiz[u] += 1;\n\t\tLL fd = p[i].fi - (n - siz[u] * 2);\n\t\tint j = lower_bound(p + 1, p + n + 1, MP(fd, 0)) - p;\n\t\tif (j >= i || p[j].fi != fd) gg();\n\t\tint fa = p[j].se;\n\t\tsiz[fa] += siz[u];\n\t\te[fa].push_back(u);\n\t}\n\tsiz[p[1].se] += 1;\n\tDFS1(p[1].se);\n\tDFS2(p[1].se);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (sum[p[i].se] != p[i].fi) gg();\n\t}\n\tfor (int u = 1; u <= n; ++u) {\n\t\tfor (auto v : e[u]) {\n\t\t\tprintf(\"%d %d\\n\", u, v);\n\t\t}\n\t}\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define inf 0x3f3f3f3f3f3f3f3f\n#define inf 0x3f3f3f3f\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define inv(x) Power(x, mod - 2)\n#define fi first\n#define se second\n#define MP make_pair\n#define PB push_back\n\ntypedef std::vector<int> Poly;\ntypedef std::pair<int,int> Pair;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef long long ll;\n\nconst int maxn = 100000, maxm = 2000, MAX = 1e6 + 5, mod = 1000000;\n//template{{{\nconst long double Pi = 3.14159265358979323846l, Eps = 1e-4;\ntemplate <class T> inline bool equal(T x, T y) { return fabs(x - y) < Eps; }\ninline int add(int x, int y) { x += y; return x >= mod ? x - mod : x; };\ninline void inc(int &x, int y) { x += y; x -= (x >= mod ? mod : 0); }\ninline int mul(int x, int y) { return 1ll * x * y % mod; }\ninline int Power(int x, int y, int Mod = mod) {\n\tint ans = 1;\n\twhile (y) {\n\t\tif (y & 1) ans = (ll) ans * x % Mod;\n\t\tx = (ll) x * x % Mod, y >>= 1;\n\t} return ans;\n}\n\n/*char buf[1<<23],obuf[1<<23],*p1=buf,*p2=buf, *O = obuf;\n#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\nvoid print(int x) {\n    if(x > 9) print(x / 10);\n    *O++=x%10+'0';\n} */\n\ntemplate <class T> inline T\tinput() {\n\tT x; char ch; bool flag = false;\n\twhile (!isdigit(ch = getchar())) flag |= ch == '-';\n\tfor (x = ch ^ 48; isdigit(ch = getchar()); x = x * 10 + (ch ^ 48));\n\treturn flag ? -x : x;\n}\n\ntemplate <class T> inline bool chkmin(T &x, T y) { x = x < y ? x : y; return x == y; }\ntemplate <class T> inline bool chkmax(T &x, T y) { x = x > y ? x : y; return x == y; }\ntemplate <class T> inline T gcd(T x, T y) { return !y ? x : gcd(y, x % y); }\ntemplate <class T> inline T sqrm(T x) { return (ll) x * x % mod; }\ntemplate <class T> inline T sqr(T x) { return x * x; }\n\nstruct {\n\tinline operator int () { return input<int>(); }\n\tinline operator long long () { return input<long long>(); }\n\ttemplate <class T> inline void operator () (T &x) { x = *this; }\n\ttemplate<class T, class ...A> inline void operator () (T &x, A &...a)\n\t{ x = *this; this -> operator ()(a...); }\n} read; //}}}\n\nint n;\nll d[maxn + 5];\nint size[maxn + 5];\nstd::map<ll, int> id;\nstd::pair<ll, int> p[maxn + 5];\nstd::vector<int> T[maxn + 5];\nint fa[maxn + 5];\n\nll distance;\n\nvoid dfs(int u, ll dis) {\n\tdistance += dis;\n\tfor (int v : T[u])\n\t\tdfs(v, dis + 1);\n}\n\nbool check() {\n\tdfs(p[1].se, 0);\n\treturn distance == d[p[1].se];\n}\n\nsigned main() {\n#ifdef local\n\tfreopen(\"in\", \"r\", stdin);\n\tfreopen(\"out\", \"w\", stdout);\n\tfreopen(\"log\", \"w\", stderr);\n#endif\n\n\tn = read;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tp[i].fi = d[i] = read;\n\t\tp[i].se = id[d[i]] = i;\n\t\tsize[i] = 1;\n\t}\n\n\tstd::sort(p + 1, p + n + 1);\n\tfor (int i = n; i > 1; --i) {\n\t\tll df = p[i].fi - n + size[p[i].se] * 2;\n\t\tif (df >= p[i].fi) return puts(\"-1\"), 0;\n\t\tfa[p[i].se] = id[df], size[fa[p[i].se]] += size[p[i].se];\n\t\tif (!fa[p[i].se]) return puts(\"-1\"), 0;\n\t\tT[fa[p[i].se]].push_back(p[i].se);\n\t}\n\n\tif (!check()) return puts(\"-1\"), 0;\n\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (fa[i]) printf(\"%d %d\\n\", i, fa[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string>\n#include <algorithm>\n#include <math.h>\n#include <map>\n#include <chrono>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    int N;\n    cin >> N;\n    vector<long long> d(N);\n    vector<pair<int, int>> t;\n    map<long long, int> a;\n    for (int i = 0; i < N; i++)\n    {\n        cin >> d[i];\n        a[d[i]] = i;\n    }\n\n    vector<int> weigtht(N, 1);\n    for (int it = 0; it < N - 1; it++)\n    {\n        auto target = a.rbegin();\n        int i = target->second;\n        long long dis = d[i];\n        long long next = dis - (N - weigtht[i]) + weigtht[i];\n        if (a.find(next) == a.end() || a[next] == i)\n        {\n            cout << \"-1\" << endl;\n            return 0;\n        }\n        int j = a[next];\n        weigtht[j] += weigtht[i];\n        t.push_back({i, j});\n        a.erase(--a.end());\n    }\n\n    vector<vector<int>> g(N);\n    for (int i = 0; i < N - 1; i++)\n    {\n        g[t[i].first].push_back(t[i].second);\n        g[t[i].second].push_back(t[i].first);\n    }\n    vector<int> valid(N, -1);\n    valid[0] = 0;\n    vector<int> que(1, 0);\n    for (int i = 0; i < (int)que.size(); i++)\n    {\n        for (int &j : g[que[i]])\n        {\n            if (valid[j] == -1)\n            {\n                que.push_back(j);\n                valid[j] = valid[que[i]] + 1;\n            }\n        }\n    }\n\n    int node_0_d = 0;\n    for (int i = 0; i < N; i++)\n    {\n        if (valid[i] != -1)\n        {\n            node_0_d += valid[i];\n        }\n    }\n\n    if ( node_0_d != d[0] )\n    {\n        cout << \"-1\" << endl;\n        return 0;\n    }\n\n    for (int i = 0; i < N - 1; i++)\n    {\n        cout << t[i].first + 1 << \" \" << t[i].second + 1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nstruct Node {\n\tint parent{-1}, children{1}, id{};\n\tlong long d, distance_sum{};\n};\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tstd::vector<Node> nodes(n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%lld\", &nodes[i].d);\n\t\tnodes[i].id = i;\n\t}\n\tstd::sort(nodes.begin(), nodes.end(),\n\t\t[](const Node& a, const Node& b){ return a.d < b.d; }\n\t);\n\tfor (auto node{nodes.rbegin()}; node + 1 < nodes.rend(); node++)\n\t{\n\t\tauto parent = std::lower_bound(nodes.begin(), nodes.end(), node->d - n + 2 * node->children,\n\t\t\t[](Node &e, long long value){ return e.d < value; }\n\t\t);\n\t\tif (parent == nodes.end() || parent->d != node->d - n + 2 * node->children || parent->id == node->id)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tnode->parent = parent->id;\n\t\tparent->children += node->children;\n\t\tparent->distance_sum += node->distance_sum + node->children;\n\t}\n\tif (nodes[0].distance_sum != nodes[0].d)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor (auto node{nodes.begin() + 1}; node < nodes.end(); node++)\n\t{\n\t\tprintf(\"%d %d\\n\", node->id + 1, node->parent + 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid err() {\n  cout << -1 << endl;\n  exit(0);\n}\nvoid dfs (int crr, int dpt, vector<vector<int>>& grh, long long& cnt) {\n  cnt += dpt;\n  for (int nxt : grh[crr]) {\n    dfs(nxt, dpt + 1, grh, cnt);\n  }\n}\nint main() {\n  int n;\n  cin >> n;\n  vector<long long> d(n);\n  map<long long, int> mp;\n  for (int i = 0; i < n; i++) {\n    cin >> d[i];\n    mp[d[i]] = i;\n  }\n  sort(d.begin(), d.end());\n  vector<long long> sz(n, 1);\n  vector<vector<int>> grh(n);\n  vector<pair<int, int>> edg;\n  for (auto it = d.rbegin(); next(it) != d.rend(); it++) {\n    auto i = mp.rbegin()->second;\n    long long wnt = *it - n + 2 * sz[i];\n    if (mp.find(wnt) == mp.end()) err();\n    auto p = mp[wnt];\n    sz[p] += sz[i];\n    grh[p].push_back(i);\n    edg.emplace_back(i, p);\n    mp.erase(--mp.end());\n  }\n  int rt = mp.begin()->second;\n  long long cnt = 0;\n  dfs(rt, 0, grh, cnt);\n  if (d[0] != cnt) err();\n  for (auto const& e : edg) {\n    cout << e.first + 1 << ' ' << e.second + 1 << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stdio.h>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nvector < pair <int, int> > v;\n\nint n, sz[1000000];\n\nbool ans = true;\n\nvector <int> g[1000000];\n\nint dfs (int x, int p)\n{\n    int sum = 1;\n    \n    for (int to : g[x])\n\tif (to != p) sum += dfs (to, x);\n    \n    if (sz[x] != sum) ans = false;\n    \n    return sum;\n}\n\nint main () \n{\n    cin >> n;\n    \n    for (int i = 0; i < n; i++)\n    {\n\tint d;\n\tscanf (\"%d\", &d);\n\t\n\tv.emplace_back (d, i);\n    }\n    \n    sort (v.begin (), v.end ());\n    \n    for (int i = n - 1; i >= 0; i--)\n    {\n\tint x = v[i].second, d = v[i].first;\n\t\n\tv.pop_back ();\n\t\n\tsz[x] = 1;\n\t\n\tfor (int to : g[x])\n\t    sz[x] += sz[to];\n\t\n\tif (!i) break;\n\t\n\tint k = lower_bound (v.begin (), v.end (), make_pair (d + 2 * sz[x] - n, -1)) - v.begin ();\n\t\n\tif (k == v.size () || v[k].first != d + 2 * sz[x] - n)\n\t{\n\t    cout << -1;\n\t    return 0;\n\t}\n\t\n\tg[v[k].second].push_back (x);\n    }\n    \n    dfs (0, -1);\n    \n    if (!ans)\n    {\n\tcout << -1;\n\treturn 0;\n    }\n    \n    for (int i = 0; i < n; i++)\n\tfor (int to : g[i])\n\t{\n\t    printf (\"%d %d\\n\", i + 1, to + 1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pi;\nconst int N=1e5+5;\nmap<ll,int>mp;ll s[N];int sz[N],id[N],n,top;pi st[N];\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfp(i,1,n)scanf(\"%lld\",&s[i]),id[i]=i,sz[i]=1,mp[s[i]]=i;\n\tsort(id+1,id+1+n,[](const int &x,const int &y){return s[x]>s[y];});\n\tfp(i,1,n-1){\n\t\tR int u=id[i];\n\t\tif(!mp.count(s[u]-n+(sz[u]<<1)))return puts(\"-1\"),0;\n\t\tR int v=mp[s[u]-n+(sz[u]<<1)];\n\t\tif(s[v]>=s[u])return puts(\"-1\"),0;\n\t\tst[++top]=pi(u,v),sz[v]+=sz[u];\n\t}\n\tfp(i,1,top)printf(\"%d %d\\n\",st[i].fi,st[i].se);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nstruct Info{ll nu;int we;}a[1000010];\nstruct edg{int x,y;}an[1000010];\nbool c=true;\nint n,si[1000010];\nll su;\nbool comp(const Info &a,const Info &b){return a.nu>b.nu;}\nbool comp1(const Info &a,const Info &b){return a.we<b.we;}\nint find(ll x){\n\tint l=1,r=n,mid;\n\twhile (l+1<r){\n\t\tmid=(l+r)/2;\n\t\tif (a[mid].nu<x) r=mid;else l=mid;\n\t}\n\tif (a[r].nu==x) return r;\n\tif (a[l].nu==x) return l;\n\treturn 0;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++){cin>>a[i].nu;a[i].we=i;}\n\tsort(a+1,a+n+1,comp);\n\tfor (int i=1;i<=n;i++) si[i]=1;\n\tfor (int i=1;i<n;i++){\n\t\tint x=find(a[i].nu-n+si[i]*2);\n\t\tif (x==0) c=false;\n\t\telse{\n\t\t\tsi[x]+=si[i];\n\t\t\tan[i].x=a[i].we;an[i].y=a[x].we;\n\t\t}\n\t\tsu+=si[i];\n\t}\n\tif (su!=a[n].nu)c=false;\n\tsort(a+1,a+n+1,comp1);\n\tif (c){\n\t\tfor (int i=1;i<n;i++) cout<<an[i].x<<' '<<an[i].y<<endl;\n\t}else{\n\t\tcout<<\"-1\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std ;\n\nint n ;\n\npair < long long , int > d[100010] ;\n\nint nChild[100010] ;\n\nmap < long long , int > f;\n\nvector < pair < int , int > > lis ;\n\nint main(){\n    #define NAME \"example\"\n    //freopen(NAME\".inp\", \"r\", stdin) ; freopen(NAME\".out\", \"w\", stdout) ;\n\n    ios_base :: sync_with_stdio(false) ;\n\n    cin >> n ;\n\n    for (int i = 1; i <= n; ++ i) cin >> d[i].first, d[i].second = i ;\n\n    sort(d + 1, d + n + 1) ;\n\n    long long total = 0 ;\n\n    for (int i = 1; i <= n; ++ i) f[d[i].first] = d[i].second ;\n    for (int i = n; i >= 2; -- i){\n        long long foo = d[i].first + 2ll * (nChild[d[i].second] + 1) - 1ll * n ;\n        int bar = f[foo] ;\n        if(!bar) return cout << -1 , 0 ;\n        nChild[bar] += nChild[d[i].second] + 1 ;\n        if(bar != d[1].second && 2 * nChild[bar] >= n) return cout << -1, 0 ;\n        lis.push_back(make_pair(d[i].second, bar)) ;\n        total += 1ll * (nChild[bar] + 1) ;\n    }\n\n    if(total != d[1].first) return cout << -1, 0 ;\n\n    for (int i = 0; i < (int)lis.size(); ++ i) cout << lis[i].first << \" \" << lis[i].second << endl ;\n\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <set>\n#include <vector>\n#include <numeric>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nstruct DSU {\n    vector<int> parent, set_size;\n    set<int> roots;\n\n    DSU () {}\n\n    DSU(int n) {\n        assign(n);\n    }\n\n    void assign(int n) {\n        parent.resize(n);\n        set_size.assign(n, 1);\n        iota(parent.begin(), parent.end(), 0);\n        roots.insert(parent.begin(), parent.end());\n    }\n\n    bool check(int a, int b) {\n        return root(a) == root(b);\n    }\n\n    int root(int x) {\n        while (x != parent[x]) {\n            x = parent[x] = parent[parent[x]];\n        }\n        return x;\n    }\n\n    int size() { return roots.size(); }\n\n    int size(int i) { return set_size[root(i)]; }\n\n    bool join(int a, int b) {\n        a = root(a), b = root(b);\n        \n        if (a == b) {\n            return false;\n        }\n\n        if (set_size[a] < set_size[b]) {\n            swap(a, b);\n        }\n\n        roots.erase(b);\n        set_size[a] += set_size[b];\n        parent[b] = a;\n        return true;\n    }\n};\n\n\nint main() {\n    ios_base::sync_with_stdio(0);\n\n    int n;\n    cin >> n;\n    vector<pair<int, int> > v;\n    for (int i = 0, d; i < n; i++) {\n        cin >> d;\n        v.emplace_back(d, i);\n    }\n    sort(v.begin(), v.end());\n    vector<pair<int, int> > edges;\n    DSU d(n);\n    bool res = true;\n    for (auto it = v.end() - 1; res and it != v.begin(); it--) {\n        const int u = it->second;\n        const int next_d = it->first - (n - 2 * d.size(u));\n        const auto p = make_pair(next_d, 0);\n        auto i = lower_bound(v.begin(), it, p);\n        if (i == it or i->first != next_d) {\n            res = false;\n        }\n        else {\n            d.join(u, i->second);\n            edges.emplace_back(u, i->second);\n        }\n    }\n    if (res) {\n        for (auto p : edges) {\n            cout << p.first + 1 << ' '\n                 << p.second + 1 << '\\n';\n        }\n    } \n    else {\n        cout << \"-1\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <cctype>\n#include <queue>\n#include <vector>\n#define int long long\n\nusing namespace std;\n\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}\n    while (isdigit(ch)){x=x*10+ch-48;ch=getchar();}\n    return x*f;\n}\n\npair <long long,int> D[100050];\n\npair <int,int> edge[100050];\n\nvector <int> G[100050];\n\nint n,size[100050],tot;\n\nlong long dis[100050];\n\ninline void dfs(int u,int fa)\n{\n    for (int i=0;i<G[u].size();i++)\n    {\n        int v=G[u][i];\n        if (v!=fa)\n        {\n            dis[v]=dis[u]+1;\n            dfs(v,u);\n        }\n    }\n}\n\nint main()\n{\n    n=read();\n    for (int i=1;i<=n;i++)\n    {\n        int d=read();\n        D[i]={d,i};\n        size[i]=1;\n    }\n    sort(D+1,D+n+1);\n    reverse(D+1,D+n+1);\n    for (int i=1;i<n;i++)\n    {\n        long long delta=D[i].first-n+2*size[i];\n        int l=1,r=n+1,pos=0; \n        while (l<=r)\n        {\n            int mid=(l+r)>>1;\n            if (D[mid].first<=delta)\n            {\n                r=mid-1;\n                pos=mid;\n            }\n            else\n                l=mid+1;\n        }\n        //cout << D[pos].first << \" \" << delta << endl;\n        if (D[pos].first!=delta)\n        {\n            puts(\"-1\");\n            return 0;\n        }\n        int u=D[i].second,v=D[pos].second;\n        G[u].push_back(v);\n        G[v].push_back(u);\n        edge[++tot]={u,v};\n        size[pos]+=size[i];\n    }   \n    dfs(D[n].second,0);\n    long long sum=0;\n    for (int i=1;i<=n;i++)\n        sum+=dis[i];\n    if (sum==D[n].first)\n    {\n        for (int i=1;i<=tot;i++)\n            cout << edge[i].first << \" \" << edge[i].second << endl;\n    }\n    else\n        puts(\"-1\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nint n; ll d[1 << 17];\nvector<int> G[1 << 17];\nll c[1 << 17];\nvector<LP> v;\nmap<ll, int> mp;\n\nll h[1 << 17];\nll calc(int id) {\n\th[id] = 1;\n\tll res = 0;\n\trep(j, G[id].size()) {\n\t\tint to = G[id][j];\n\t\tres += calc(to); h[id] += h[to];\n\t}\n\treturn res + h[id];\n}\nint main() {\n\tbool valid = true;\n\tcin >> n;\n\trep1(i, n) {\n\t\tcin >> d[i]; v.push_back({ d[i],i });\n\t\tmp[d[i]] = i;\n\t}\n\tsort(v.begin(), v.end(), greater<LP>());\n\trep(i, n - 1) {\n\t\tint id = v[i].second;\n\t\tll nexval = v[i].first - (n-2-2 * c[id]);\n\t\tint t = mp[nexval];\n\t\tif (t==0||nexval>=v[i].first) {\n\t\t\tvalid = false; break;\n\t\t}\n\t\telse {\n\t\t\tG[t].push_back(id);\n\t\t\tc[t] += c[id] + 1;\n\t\t}\n\t}\n\tif (!valid)cout << -1 << endl;\n\telse {\n\t\tll s = calc(v[n-1].second) - n;\n\t\t//cout << \"hael\" << endl;\n\t\t/*cout << s << endl;\n\t\tcout << v[n - 1].first << endl;*/\n\t\tif (s != v[n - 1].first) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\telse {\n\t\t\trep1(i, n) {\n\t\t\t\trep(j, G[i].size()) {\n\t\t\t\t\tcout << i << \" \" << G[i][j] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100010;\ntypedef long long int64;\n\nmap<int64 , int> val;\nint n , size[N] , fa[N];\nbool vis[N];\n\nint64 d[N];\ntypedef pair<int64 , int> pii;\npriority_queue<pii> leaf;\n#define mp make_pair \n\nint main() {\n    cin >> n;\n    for(int i = 1 ; i <= n ; ++i) {\n        cin >> d[i];\n        size[i] = 1;\n        val[d[i]] = i; \n    }\n    for(int i = 1 ; i <= n ; ++i) \n        if(val.count(d[i] - n + 2)) leaf.push(mp(d[i] , i)) , vis[i] = 1;\n\n    while(leaf.size()) {\n        int x = leaf.top().second;\n        leaf.pop();\n\n\t\tval.erase(d[x]);\n        if(val.count(d[x] - n + size[x]*2))\n            fa[x] = val[d[x] - n + size[x]*2];\n        else break;\n        \n        size[fa[x]] += size[x];\n        if(!vis[fa[x]]) leaf.push(mp(d[fa[x]] , fa[x])),  vis[fa[x]] = 1;\n    }\n    if(val.size()) cout << -1 << endl;\n    else {\n        for(int i = 1 ; i <= n ; ++i)\n            if(fa[i]) cout << i << ' ' << fa[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimiz(O2)\n\n#include <bits/stdc++.h>\n\n#define rg register\nusing namespace std;\ntypedef long long ll;\n\ntemplate<typename T>\ninline bool read(T &n) {\n    T ans = 0, flag = 1;\n    char ch;\n    while ((ch = getchar()) < '0' || ch > '9') if (ch == '-') flag = -1; else if (ch == EOF) return false;\n    ans = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9') ans = ans * 10 + ch - '0';\n    n = ans * flag;\n    return true;\n}\n\ninline ll read() {\n    ll ans = 0, flag = 1;\n    char ch;\n    while ((ch = getchar()) < '0' || ch > '9') if (ch == '-') flag = -1;\n    ans = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9') ans = ans * 10 + ch - '0';\n    return ans * flag;\n};\nconst int maxn = 100005;\nstruct NODE {\n    ll val, ord;\n    bool operator<(NODE b) const {\n        return val < b.val;\n    }\n} node[maxn];\nint siz[maxn],fa[maxn];\nunordered_map<ll,int> unM;\nint main() {\n    int n;\n    read(n);priority_queue<NODE> pq;\n    for (rg int i = 1; i <= n; ++i) {\n        siz[i] = 1;read(node[i].val);\n        node[i].ord = i;\n        pq.push(node[i]);\n        unM[node[i].val]=i;\n    }\n    for(rg int i=n;i>=2;i--){\n        NODE now=pq.top();pq.pop();\n        if(now.val+2*siz[now.ord]-n>=now.val||unM.find(now.val+2*siz[now.ord]-n)==unM.end()){\n            puts(\"-1\");return 0;\n        }\n        fa[now.ord]=unM[now.val+2*siz[now.ord]-n];\n        siz[fa[now.ord]]+=siz[now.ord];\n    }\n    for(rg int i=1;i<=n;i++){\n        if(fa[i]) cout<<i<<' '<<fa[i]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,j,k) for(int i=j;i<=k;++i)\ntypedef long long ll;\nchar cch;\ninline ll rd(){\n\tll x=0,fl=1;\n\tcch=getchar();\n\twhile(cch>'9'||cch<'0'){\n\t\tif(cch=='-') fl=-1;\n\t\tcch=getchar();\n\t}\n\twhile(cch>='0'&&cch<='9') x=(x<<3)+(x<<1)+cch-'0',cch=getchar();\n\treturn x*fl;\n}\nconst int N=1e5+3;\nstruct abc{\n\tint i;\n\tll d;\n}a[N];\nint fr[N],head[N],to[N],nxt[N],cnt,sz[N];\nll re,c[N];\ninline bool cmp(const abc &a,const abc &b){\n\treturn a.d<b.d;\n}\ninline void adde(int u,int v){\n\tto[++cnt]=v,fr[cnt]=u,nxt[cnt]=head[u],head[u]=cnt;\n}\ninline void dfs(int u,int fa,int dep){\n\tre+=dep;\n\tfor(int i=head[u];i;i=nxt[i]){\n\t\tdfs(to[i],u,dep+1);\n\t}\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\trep(i,1,n) a[i].d=rd(),a[i].i=i,sz[i]=1;\n\tsort(a+1,a+1+n,cmp);\n\trep(i,1,n) c[i]=a[i].d;\n\tint pos;\n\tll tmp;\n\tfor(int i=n;i>1;--i){\n\t\ttmp=a[i].d-(n-sz[a[i].i])+sz[a[i].i];\n\t\tpos=lower_bound(c+1,c+n+1,tmp)-c;\n\t\tif(c[pos]!=tmp||tmp>a[i].d){\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t\telse sz[a[pos].i]+=sz[a[i].i],adde(a[pos].i,a[i].i);\n\t}\n\tdfs(a[1].i,0,0);\n\tif(re!=a[1].d){\n\t\tputs(\"-1\");return 0;\n\t}\n\tfor(int i=1;i<n;++i){\n\t\tprintf(\"%d %d\\n\",fr[i],to[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Inf 0x3f3f3f3f\n#define rg register\nusing namespace std;\nconst int Maxn = 1e5 + 5;\ntypedef long long ll;\ntypedef ll arr[Maxn];\nll min(ll x, ll y) { return x < y ? x : y; }\nll max(ll x, ll y) { return x > y ? x : y; }\ninline ll read()\n{\n\trg ll res = 0, sign = 1;\n\trg char ch = getchar();\n\twhile (!isdigit(ch))\n\t{\n\t\tif (ch == '-')\n\t\t\tsign = -1;\n\t\tch = getchar();\n\t}\n\tdo\n\t{\n\t\tres = (res << 3) + (res << 1) + (ch ^ 48);\n\t\tch = getchar();\n\t} while (isdigit(ch));\n\treturn res * sign;\n}\nint n;\narr siz, fa;\nstruct str\n{\n\tll d;\n\tint id;\n\tbool operator<(str A) const { return d < A.d; }\n} p[Maxn];\n\nint main()\n{\n\tint tmp, now, s;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tp[i] = {read(), i};\n\t\tsiz[i] = 1;\n\t}\n\tsort(p + 1, p + n + 1);\n\tfor (int i = n; i > 1; i--)\n\t{\n\t\tnow = p[i].id;\n\t\ttmp = p[i].d - n + 2 * siz[now];\n\t\tfa[now] = p[s = lower_bound(p + 1, p + n + 1, (str){tmp, 0}) - p].id;\n\t\tif (p[s].d != tmp)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[fa[now]] += siz[now];\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (fa[i])\n\t\t\tprintf(\"%d %d\\n\", fa[i], i);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nconst int N=1e5+5;\nint n,siz[N];\npair <int,int> Edge[N];\nstruct Node {\n\tll dis;int id;\n\tbool operator < (const Node&b) const {return dis<b.dis;}\n} A[N];\n\ntemplate <typename _Tp> inline void IN(_Tp&x) {\n\tchar ch;bool flag=0;x=0;\n\twhile(ch=getchar(),!isdigit(ch)) if(ch=='-') flag=1;\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\tif(flag) x=-x;\n}\n\nint main() {\n\tIN(n);\n\tfor(int i=1;i<=n;++i) IN(A[i].dis),A[i].id=i;\n\tfor(int i=1;i<=n;++i) siz[i]=1;\n\tsort(A+1,A+1+n);\n\tll res=0;int cnt=0;\n\tfor(int i=n;i>=2;--i) {\n\t\tll dis=A[i].dis+(siz[i]<<1)-n;\n\t\tint pos=lower_bound(A+1,A+1+n,(Node){dis,0})-A;\n\t\tif(dis!=A[pos].dis) return puts(\"-1\"),0;\n\t\tsiz[pos]+=siz[i],Edge[++cnt]=make_pair(A[i].id,A[pos].id),res+=siz[i];\n\t}\n\tif(res!=A[1].dis) return puts(\"-1\"),0;\n\tfor(int i=1;i<=cnt;++i) printf(\"%d %d\\n\",Edge[i].first,Edge[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nvoid bye() { std::cout << -1 << std::endl; exit(0); }\nconst int MAXN = 100010;\ntypedef long long LL;\nstd::map<LL, int> idx, sub, fa, dep;\nint n;\nLL D[MAXN];\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor (int i = 1; i <= n; ++i)\n\t\tstd::cin >> D[i], idx[D[i]] = i, sub[D[i]] = 1;\n\tstd::sort(D + 1, D + 1 + n);\n\tfor (int i = n; i > 1; --i) {\n\t\tLL td = D[i] - n + sub[D[i]] * 2;\n\t\tif (td >= D[i] || !idx.count(td)) bye();\n\t\tsub[td] += sub[D[i]];\n\t\tfa[D[i]] = td;\n\t}\n\tfor (int i = 2; i <= n; ++i) {\n\t\tdep[D[i]] = dep[fa[D[i]]] + 1;\n\t\tD[1] -= dep[D[i]];\n\t}\n\tif (D[1]) bye();\n\tfor (int i = 2; i <= n; ++i)\n\t\tstd::cout << idx[fa[D[i]]] << ' ' << idx[D[i]] << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n,cnt,a[111111],id[111111],w[111111],u[111111],v[111111],siz[111111];\nbool vis[111111];\nbool cmp(int x,int y){return a[x]<a[y];}\nvoid add(int x,int y){u[++cnt]=x,v[cnt]=y;}\nsigned main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]),id[i]=i,w[i]=a[i],siz[i]=1;\n\tsort(id+1,id+n+1,cmp),sort(w+1,w+n+1);\n\tfor(int i=n;i>1;i--){\n\t\tint x=2*siz[id[i]]-n+a[id[i]],pos=lower_bound(w+1,w+n+1,x)-w;\n\t\tif(w[pos]!=x||x==w[i])continue;\n\t\tadd(id[pos],id[i]),siz[id[pos]]+=siz[id[i]];\n\t}\n\tif(cnt!=n-1){printf(\"-1\");return 0;}\n\tfor(int i=1;i<=cnt;i++)printf(\"%d %d\\n\",u[i],v[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 998244353\n#define ny 499122177\n#define maxn 1000000000000000000LL\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nlong long n,i,x,zz[100005],sum[100005],sum2[100005];\nstruct nyh{\n\tlong long x,id;\n}o[100005];\nmap<long long,long long> mp;\nbool cmp(nyh u,nyh v){\n\treturn u.x<v.x;\n}\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read();\n\tfor(i=1;i<=n;i++){\n\t\to[i].x=read();\n\t\to[i].id=i;\n\t}\n\tsort(o+1,o+n+1,cmp);\n\tfor(i=1;i<=n;i++){\n\t\tmp[o[i].x]=i;\n\t\tsum[i]=1;\n\t}\n\tfor(i=n;i>=2;i--){\n\t\tx=o[i].x-n+sum[i]*2;\n\t\tif(mp[x]!=0&&mp[x]<i){\n\t\t\tzz[i]=mp[x];\n\t\t\tsum[zz[i]]+=sum[i];\n\t\t\tsum2[zz[i]]+=sum[i]+sum2[i];\n\t\t}\n\t\telse{\n\t\t\tpus(-1,2);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif(sum2[1]!=o[1].x){\n\t\tpus(-1,2);\n\t\treturn 0;\n\t}\n\tfor(i=n;i>=2;i--){\n\t\tpus(o[zz[i]].id,1);\n\t\tpus(o[i].id,2);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define ln                '\\n'\n#define all(dat)           dat.begin(), dat.end()\n#define loop(i, to)        for (int i = 0; i < to; ++i)\n#define cont(i, to)        for (int i = 1; i <= to; ++i)\n#define circ(i, fr, to)    for (int i = fr; i <= to; ++i)\n#define foreach(i, dat)    for (__typeof(dat.begin()) i = dat.begin(); i != dat.end(); ++i)\n\ntypedef long long          num;\n\nusing namespace std;\n\nconst int nsz = 1e5;\nint n;\nnum mn, w[nsz + 5];\nmap<num, bool> vis;\nmap<num, int> have;\nvector<pair<int, int>> ans;\n\nbool inline cmp(num a, num b) {\n    return a > b;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> n;\n    cont (i, n) {\n        cin >> w[i];\n        have[w[i]] = i;\n    }\n    sort(w + 1, w + n + 1, cmp);\n    mn = w[n];\n    cont (i, n) {\n        num cur = w[i], tmp = n - 2, nxt = cur - tmp;\n        if (vis[cur] || cur == mn)  continue;\n        while (have[cur] && cur != mn) {\n            vis[cur] = 1;\n            ans.push_back({have[cur], have[nxt]});\n            cur = nxt;\n            tmp -= 2;\n            nxt -= tmp;\n        }\n        vis[cur] = 1;\n        if (cur != mn) {\n            cout << -1 << ln;\n            return 0;\n        }\n    }\n    foreach (it, have) {\n        if (it->second && !vis[it->first]) {\n            cout << -1 << ln;\n            return 0;\n        }\n    }\n    for (pair<int, int> tmp : ans) {\n        cout << tmp.first << ' ' << tmp.second << ln;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100010;\n\ntypedef long long ll;\n\npriority_queue<ll> pq;\nmap<ll, int> mp;\n\nint n, l[maxn], dep[maxn], sz[maxn], w[maxn], vis[maxn], e_u[maxn], e_v[maxn], tot, e = 0;\nll D[maxn], S[maxn];\n\nstruct Edge {\n\tint v, x;\n} E[maxn];\n\ninline void addEdge(int u, int v) {\n\tE[e].v = v; E[e].x = l[u]; l[u] = e++;\n}\n\nvoid dfs1(int u) {\n\tsz[u] = 1;\n\tfor (int p = l[u]; p >= 0; p = E[p].x) {\n\t\tint v = E[p].v;\n\t\tdep[v] = dep[u] + 1;\n\t\tdfs1(v);\n\t\tsz[u] += sz[v];\n\t}\n}\n\nvoid dfs2(int u) {\n\tfor (int p = l[u]; p >= 0; p = E[p].x) {\n\t\tint v = E[p].v;\n\t\tS[v] = S[u] + n - 2 * sz[v];\n\t\tdfs2(v);\n\t}\n}\n\nint main() {\n\tmemset(l, -1, sizeof(l));\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", &D[i]);\n\tfor (int i = 1; i <= n; i++) {\n\t\tmp[D[i]] = i;\n\t\tpq.push(D[i]);\n\t\tw[i] = 1;\n\t}\n\tvis[0] = 1;\n\twhile (pq.size() > 1) {\n\t\tll v = pq.top(); pq.pop();\n\t\tint u = mp[v];\n\t\tvis[u] = 1;\n\t\tif (!vis[mp[v + 2 * w[u] - n]]) {\n\t\t\tint t = mp[v + 2 * w[u] - n];\n\t\t\tw[t] += w[u];\n\t\t\taddEdge(t, u);\n\t\t\t++ tot;\n\t\t\te_u[tot] = t; e_v[tot] = u;\n\t\t} else {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint r = mp[pq.top()];\n\tdfs1(r);\n\tfor (int i = 1; i <= n; i++) S[r] += dep[i];\n\tdfs2(r);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (S[i] != D[i]) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (int i = 1; i <= tot; i++) printf(\"%d %d\\n\", e_u[i], e_v[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=100005;\nint n,size[N],st[N],to[N<<1],tto[N],last[N],Next[N<<1],edge;\nlong long D;\nstruct note{\n\tlong long dis;\n\tint x;\n}d[N];\nbool cmp(note x,note y){\n\treturn x.dis>y.dis;\n}\nusing std::map;\nmap<long long,int> m;\nvoid add(int x,int y){\n\tto[++edge]=y;\n\tNext[edge]=last[x];\n\tlast[x]=edge;\n}\nint dfs(int x,int fa,long long now){\n\tD+=now;\n\tfor (int i=last[x];i;i=Next[i])\n\t\tif (to[i]!=fa)\n\t\t\tdfs(to[i],x,now+1);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) {\n\t\tscanf(\"%lld\",&d[i].dis);\n\t\td[i].x=i;\n\t\tm[d[i].dis]=i;\n\t}\n\tstd::sort(d+1,d+n+1,cmp);\n\tfor (int i=1;i<=n;i++) size[i]=1;\n\tfor (int i=1;i<n;i++){\n\t\tlong long dis=d[i].dis;\n\t\tint x=d[i].x;\n\t\tlong long t=dis-abs(n-2*size[x]);\n\t\t//if (t<0){\n\t\t//\tputs(\"-1\");\n\t\t//\treturn 0;\n\t\t//}\n\t\tint fa=m.find(t)->second;\n\t\tif (fa==x || !fa){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsize[fa]+=size[x];\n\t\tst[i]=x,tto[i]=fa;\n\t\tadd(x,fa),add(fa,x);\n\t}\n\tdfs(1,0,0);\n\tif (D!=d[n].dis){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++) printf(\"%d %d\\n\",st[i],tto[i]);\n}"
  },
  {
    "language": "C++",
    "code": "/*\nThough leaves are many, the root is one;\nThrough all the lying days of my youth\nI swayed my leaves and flowers in the sun,\nNow may I wither into the truth.\n\n- William Butler Yeats\n*/\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <string.h>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <cassert>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <sstream>\n#include <functional>\n#include <iomanip>\n#include <bitset>\n//#include <windows.h>  //Should be deleted when using AtCoder&POJ\nusing namespace std;\n\n#define ll long long\n#define pii pair<int,int>\n#define qi ios::sync_with_stdio(0)\n/**==Info==\n*Program:1\n*Problem:Distance Sums\n*Date:2019-11-18\n*Algorithm:Redo greedy and sorting\n*Status:Unknown*/\n\nbool debug=false;\n\n#define pli pair<ll,int>\n\nint n;\npli p[100005];\nmap<ll,ll> mp;\n\nvector<pii> tree;\n\nvector<int> nei[100005];\n\nint dep[100005];\nint sz[100005];\n\nvoid dfs(int x,int fa){\n\tfor(int i=0;i<nei[x].size();i++){\n\t\tif(nei[x][i]==fa){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tdep[nei[x][i]]=dep[x]+1;\n\t\tdfs(nei[x][i],x);\n\t}\n}\n\nvoid validate(){\n\tfor(pii x:tree){\n\t\tnei[x.first].push_back(x.second);\n\t\tnei[x.second].push_back(x.first);\n\t}\n\t\n\tdfs(p[n-1].second,-1);\n\t\n\tll dick=0;\n\tfor(int i=0;i<n;i++){\n\t\tdick+=dep[i];\n\t}\n\t\n\tif(dick!=p[n-1].first){\n\t\tcout<<\"-1\";\n\t\texit(0);\n\t}\n}\n\nint main(int argc,char* argv[]){\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tll x;\n\t\tcin>>x;\n\t\tmp[x]=i;\n\t\tp[i]=make_pair(x,i);\n\t}\n\t\n\tfill(sz,sz+n,1);\n\t\n\tsort(p,p+n);\n\treverse(p,p+n);\n\tfor(int i=0;i<n-1;i++){\n\t\t\n\t\tll ans=p[i].first;\n\t\tint x=p[i].second;\n\t\t\n\t\tll faShould=p[i].first+sz[x]-(n-sz[x]);\n\t\tif(!mp.count(faShould)){\n\t\t\tcout<<\"-1\";\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tll par=mp[faShould];\n\t\tsz[par]+=sz[x];\n\t\ttree.push_back(make_pair(par,x));\n\t}\n\t\n\tvalidate();\n\t\n\tfor(pii x:tree){\n\t\tcout<<x.first+1<<\" \"<<x.second+1<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nconst long long mo=10000007;\nconst int maxn=100010;\n\nint n,m,d[maxn],id[maxn],siz[maxn],js[maxn],fa[maxn],ans;\nint tot,nex[maxn*2],las[maxn*2],tov[maxn*2];\nint hs[mo];\n\nvoid con(int x,int y)\n{\n\ttot++;\n\ttov[tot]=y;\n\tnex[tot]=las[x];\n\tlas[x]=tot;\n}\n\nvoid insert(long long x,int id)\n{\n\tlong long i=x%mo;\n\twhile (hs[i]!=0)\n\t{\n\t\ti++;\n\t\tif (i==mo) i=0;\n\t}\n\ths[i]=id;\n}\n\nint find(long long x)\n{\n\tlong long i=x%mo;\n\twhile (hs[i]!=0 && d[hs[i]]!=x)\n\t{\n\t\ti++;\n\t\tif (i==mo) i=0;\n\t}\n\treturn hs[i];\n}\n\nvoid qsort(int l,int r)\n{\n\tint i=l;int j=r;\n\tlong long m=d[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (d[i]>m) i++;\n\t\twhile (d[j]<m) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(d[i],d[j]);\n\t\t\tswap(id[i],id[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort(l,j);\n\tif (r>i) qsort(i,r); \n}\n\nvoid dfs(int x,int ff)\n{\n\tjs[x]=js[ff]+1;\n\tfor (int i=las[x];i;i=nex[i])\n\t{\n\t\tif (tov[i]!=ff)\n\t\t{\n\t\t\tdfs(tov[i],x);\n\t\t\tans+=js[x];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&d[i]);\n\t\tid[i]=i;\n\t\tsiz[i]=1;\n\t}\n\tqsort(1,n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinsert(d[i],i);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tlong long op=d[i]-n+2*siz[i];\n\t\tint oq=find(op);\n\t\tif (oq==0)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfa[i]=oq;\n\t\t\tsiz[oq]+=siz[i];\n\t\t\tcon(i,oq);con(oq,i);\n\t\t}\n\t}\n\tdfs(n,0);\n\tif (ans!=d[n])\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tfor (int i=1;i<n;i++)\n\t\t{\n\t\t\tprintf(\"%d %d\\n\",id[i],id[fa[i]]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#define N 150000\n#include<map>\nusing namespace std;\nstruct node{\n\tlong long x,id;\n}a[N];\nmap<long long,long long>p;\nlong long n,siz[N],fa[N];\nbool cmp(node x,node y){\n\treturn x.x>y.x;\n}\nint main(){\n\tscanf(\"%lld\",&n);\n\tfor(long long i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i].x);\n\t\ta[i].id=i;\n\t}\n\tsort(a+1,a+1+n,cmp);\n\tfor(long long i=1;i<=n;i++){\n\t\tp[a[i].x]=a[i].id;\n\t}\n\tfor(long long i=1;i<n;i++){\n\t\tlong long x=a[i].id;\n\t\tp[a[i].x]=0;\n\t\tsiz[x]++;\n\t\tlong long o=a[i].x+siz[x]-(n-siz[x]);\n\t//\tprlong longf(\"%d %d %d\\n\",a[i].x,o,siz[x]);\n\t\tlong long l=p[o];\n\t\tif(l==0){\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[l]+=siz[x];\n\t\tfa[x]=l;\n\t}\n\tfa[a[n].id]=0;\n\tfor(long long i=1;i<=n;i++){\n\t\tif(fa[i]!=0)printf(\"%lld %lld\\n\",i,fa[i]);\n\t}\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do { cout << \"\\033[32;1m \" << #x << \" -> \"; err(x); } while (0)\nvoid err() { cout << \"\\033[39;0m\" << endl; }\ntemplate<template<typename...> class T, typename t, typename... A>\nvoid err(T<t> a, A... x) { for (auto v: a) cout << v << ' '; err(x...); }\ntemplate<typename T, typename... A>\nvoid err(T a, A... x) { cout << a << ' '; err(x...); }\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<ll,int> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n    print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int maxn=1e5+7;\nll sum[maxn];\nmap<ll,int> id;\nvi G[maxn];\nint sz[maxn];\nll rs=0;\nbool ok=1;\nvoid dfs(int u,int d=0)\n{\n    rs+=d;\n    for(auto v:G[u])\n    {\n        dfs(v,d+1);\n    }\n}\nint main()\n{\n    int n;\n    cin>>n;\n    priority_queue<pi> q;\n    for(int i=1;i<=n;i++) \n    {\n        cin>>sum[i];\n        id[sum[i]]=i;\n        q.push(make_pair(sum[i],i));\n        sz[i]=1;\n    }\n    vc<pi> ans;\n    while(!q.empty())\n    {\n        auto u=q.top();q.pop();\n        if(q.empty())\n        {\n            dfs(u.second);\n            if(rs!=sum[u.second]) ok=0;\n            break;\n        }\n        ll fad=u.first-(n-2*sz[u.second]);\n        if(!id.count(fad)||fad>=u.first)\n        {\n            ok=0;\n            break;\n        }\n        sz[id[fad]]+=sz[u.second];\n        ans.emplace_back(u.second,id[fad]);\n        G[id[fad]].push_back(u.second);\n    }\n    if(!ok) print(-1);\n    else{\n        for(auto u:ans) cout<<u.first<<\" \"<<u.second<<'\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  UnionFind(){}\n  UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> d(n);\n  for(Int i=0;i<n;i++) cin>>d[i];\n  map<Int, Int> r;\n  for(Int i=0;i<n;i++) r[d[i]]=i;\n\n  vector<vector<Int> > G(n);\n  auto NO=[](){cout<<-1<<endl;exit(0);};\n  auto add_edge=[&](Int x,Int y){\n\t\t  G[x].emplace_back(y);\n\t\t  G[y].emplace_back(x);\n\t\t};\n\n  using P = pair<Int, Int>;\n  priority_queue<P> pq;\n  vector<Int> s(n,1),used(n,0);\n  for(Int i=0;i<n;i++) pq.emplace(d[i],i);\n  \n  while(pq.size()>1u){\n    Int x,v;\n    tie(x,v)=pq.top();pq.pop();\n    \n    Int nd=x-(n-s[v])+s[v];\n    if(!r.count(nd)) NO();\n    \n    Int u=r[nd];    \n    if(used[u]) NO();\n    \n    add_edge(v,u);\n    s[u]+=s[v];    \n    used[v]=1;\n  }\n\n  vector<Int> sz(n,1);\n  vector<Int> dp1(n,0),dp2(n,0);\n  function<Int(Int, Int)> dfs1=\n    [&](Int v,Int p){\n      for(Int u:G[v]){\n\tif(u==p) continue;\n\tdp1[v]+=dfs1(u,v);\n\tdp1[v]+=sz[u];\n\tsz[v]+=sz[u];\n      }\n      return dp1[v];\n    };\n  \n  function<void(Int, Int, Int)> dfs2=\n    [&](Int v,Int p,Int d){\n      Int sum=0;\n      dp2[v]=dp1[v]+d;\n      for(Int u:G[v])\n\tif(u!=p) sum+=dp1[u]+sz[u];\n      for(Int u:G[v])\n\tif(u!=p) dfs2(u,v,d+sum-(dp1[u]+sz[u])+(n-sz[u]));\n    };\n  \n  dfs1(0,-1);\n  dfs2(0,-1,0);\n\n  //for(Int i=0;i<n;i++) cout<<d[i]<<\" \"<<dp2[i]<<endl;\n  for(Int i=0;i<n;i++) if(d[i]!=dp2[i]) NO();\n  \n  for(Int v=0;v<n;v++)\n    for(Int u:G[v]) if(v<u) cout<<v+1<<\" \"<<u+1<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\nint main() {\n\tauto no = [](){ printf(\"-1\\n\"); exit(0); };\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<long long> d(n);\n\tmap<long long, int> mp;\n\trep(i, n) {\n\t\tscanf(\"%lld\", &d[i]);\n\t\tmp[d[i]] = i;\n\t}\n\tsort(d.begin(), d.end());\n\tlong long mi = d[0];\n\treverse(d.begin(), d.end());\n\td.pop_back();\n\tset<long long> remains, used;\n\trep(i, d.size()) {\n\t\tremains.insert(d[i]);\n\t}\n\tvector<pair<int, int>> ans;\n\trep(i, d.size()) {\n\t\tif (remains.count(d[i]) == 0) continue;\n\t\tremains.erase(d[i]);\n\t\tused.insert(d[i]);\n\t\tint s = 1;\n\t\tlong long cur = d[i];\n\t\tlong long prev;\n\t\twhile (true) {\n\t\t\tlong long diff = n - s * 2;\n\t\t\tif (diff <= 0) no();\n\t\t\tprev = cur;\n\t\t\tcur -= diff;\n\t\t\tif (cur == mi) {\n\t\t\t\tans.push_back({mp[prev], mp[cur]});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (remains.count(cur) == 0) {\n\t\t\t\tif (used.count(cur)) {\n\t\t\t\t\tans.push_back({mp[prev], mp[cur]});\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tno();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tremains.erase(cur);\n\t\t\t\tused.insert(cur);\n\t\t\t}\n\t\t\tans.push_back({mp[prev], mp[cur]});\n\t\t\ts ++;\n\t\t}\n\t}\n\tassert(ans.size() == n - 1);\n\tvector<vector<int>> g(n);\n\trep(i, n - 1) {\n\t\tint a = ans[i].first;\n\t\tint b = ans[i].second;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tvector<long long> s(n);\n\tvector<int> dis(n);\n\tvector<int> sz(n);\n\tfunction<void (int, int)> dfs = [&](int u, int prev) {\n\t\tsz[u] = 1;\n\t\tfor (auto v : g[u]) if (v != prev) {\n\t\t\tdis[v] = dis[u] + 1;\n\t\t\tdfs(v, u);\n\t\t\tsz[u] += sz[v];\n\t\t}\n\t};\n\tdfs(0, -1);\n\trep(i, n) s[0] += dis[i];\n\tfunction<void (int, int)> dfs2 = [&](int u, int prev) {\n\t\tfor (auto v : g[u]) if (v != prev) {\n\t\t\ts[v] = s[u] + n - sz[v] * 2;\n\t\t\tdfs2(v, u);\n\t\t}\n\t};\n\tdfs2(0, -1);\n\tsort(s.begin(), s.end());\n\td.push_back(mi);\n\tsort(d.begin(), d.end());\n\tif (s != d) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tfor (auto it : ans) printf(\"%d %d\\n\", it.first + 1, it.second + 1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1000010\nusing namespace std;\nstruct S{\n\tlong long w,dep;\n\tlong long u,v,ne;\n}a[N],e[N];\n\tlong long n,sz[N],dy[N],fir[N],root,vis[N],sum,pan;\n\tbool bo=false;\nvoid add(long long u,long long v){\n\te[++sum].ne=fir[u];\n\tfir[u]=sum;\n\te[sum].v=v;\n\te[sum].u=u;\n//\te[sum].w=1;\n}\nbool cmp(S x,S y){\n\treturn x.w>y.w;\n}\nvoid check(long long x,long long dis){\n//\tif(bo)return;\n\tpan+=dis;\n\tvis[x]=1;\n\tfor(long long i=fir[x];i;i=e[i].ne){\n\t\tlong long to=e[i].v;\n\t\tif(!vis[to]){\n\t\t\t//if(vis[to])bo=true;\n\t\t\tcheck(to,dis+1);\n\t\t}\n\t}\n}\nvoid dfs(long long x,long long father){\n\tvis[x]=1;\n\tfor(long long i=fir[x];i;i=e[i].ne){\n\t\tlong long to=e[i].v;\n\t\tif(to!=father&&!vis[to]){\n\t\t\tprintf(\"%lld %lld\\n\",x,to);\n\t\t\tdfs(to,x);\n\t\t}\n\t}\n}\nlong long query(long long sum){\n\tlong long l=1,r=n;\n\twhile(l<r){\n\t\tlong long mid=(l+r+1)>>1;\n\t\tif(a[mid].w>sum)l=mid;\n\t\telse if(a[mid].w<sum)r=mid-1;\n\t\telse {\n\t\t\tl=mid;\n\t\t\treturn a[l].dep;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tscanf(\"%lld\",&n);\n\tfor(long long i=1;i<=n;i++)scanf(\"%lld\",&a[i].w),sz[i]=1,a[i].dep=i;\n\tsort(a+1,a+n+1,cmp);\n\tfor(long long i=1;i<=n;i++){\n\t\tlong long tmp=n-2*sz[a[i].dep];\n\t\tlong long father=query(a[i].w-tmp);\n\t\tsz[father]+=sz[a[i].dep];\n/*\t\tif(!father){\n\t\t\tif(root){\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\troot=a[i].dep;\n\t\t}\n*/\t\tif(i!=n){\n\t\t\tadd(a[i].dep,father);\n\t\t\tadd(father,a[i].dep);\n\t\t}\n\t}\n\troot=a[n].dep;\n\tcheck(root,0);\n\tif(bo){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(long long i=1;i<=n;i++)if(!vis[i]){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tif(pan!=a[n].w){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tmemset(vis,0,sizeof(vis));\n\tdfs(root,0);\n}"
  },
  {
    "language": "C++",
    "code": "/*\nThough leaves are many , the root is one.\nThrough all the lying days of my youth\nI swayed my leaves and flowers in the sun.\nNow I may wither into the truth.\n\t  \t  \t- William Butler Yeats\n*/\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n#include<bits/stdc++.h>\n#pragma comment(\" -Wl,--stack=1024000000\")\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\ntypedef long long ll;\n#ifndef LOCAL\n#define cerr if(0)cout\n#define eprintf(...) 0\n#else\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#endif\ninline string getstr(string &s,int l,int r){string ret=\"\";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){if(y==0)return 1;int ret=modpow(x,y>>1,md);ret=(ll)ret*ret%md;if(y&1)ret=(ll)ret*x%md;return ret;}\nint n;\nll d[100005];\nint sz[100005];\nmap<ll,int>mp;\nvector<int>g[100005];\nvector<pair<int,int> >ans;\nint sum=0;\nvoid dfs(int x,int par,int dep){\n\tsum+=dep;\n\tfor(int i=0;i<g[x].size();i++){\n\t\tint to=g[x][i];\n\t\tif(to!=par)dfs(to,x,dep+1);\n\t}\n}\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>d[i];mp[d[i]]=i;sz[i]=1;\n\t}\n\twhile(mp.size()>1){\n\t\tpair<int,int>p=*mp.rbegin();\n\t\tmp.erase(p.first);\n\t\tint x=p.second,val=p.first;\n\t\tint nxt_v=sz[x]*2+val-n;\n\t\tif(!mp.count(nxt_v)){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}else{\n\t\t\tint y=mp[nxt_v];\n\t\t\tsz[y]+=sz[x];\n\t\t\tg[x].push_back(y);\n\t\t\tg[y].push_back(x);\n\t\t\tans.push_back(make_pair(x,y));\n\t\t}\n\t}\n\tdfs(mp.begin()->second,-1,0);\n\tif(sum!=mp.begin()->first){\n\t\tputs(\"-1\");\n\t}else{\n\t\tfor(int i=0;i<ans.size();i++){\n\t\t\tcout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing vi = vector<ll>;\nconst int maxn = 1<<19, mod = 1e9 + 7;\nint n;\nvi g[maxn];\nint vis[maxn];\nvoid dfs(int v, int p = -1) {\n\tvis[v] = 1;\n\tfor(auto &i : g[v]) if(!vis[i]) dfs(i, v);\n}\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tvi a(n), sz(n+1, 1);\n\tmap<ll, int> id;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\tid[a[i]] = i+1;\n\t}\n\tsort(rall(a));\n\tvector<pair<int, int>> edges;\n\tfor(auto x : a) {\n\t\tint i = id[x];\n\t\tif(sz[i] == n) continue;\n\t\tll nd = x + 2*sz[i] - n;\n\t\tif(nd < x && id.count(nd)) {\n\t\t\tedges.pb({i, id[nd]});\n\t\t\tsz[id[nd]] += sz[i];\n\t\t}\n\t}\n\tfor(auto i : edges) {\n\t\tint x = i.first, y = i.second;\n\t\tg[x].pb(y);\n\t\tg[y].pb(x);\n\t}\n\tdfs(1);\n\tif(edges.size() != n-1) return cout << -1, 0;\n\tfor(auto i : edges) cout << i.first << \" \" << i.second << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#define Maxn 1000008 \nusing namespace std;\ntypedef long long ll;\n\nint n;\nll d;\nint son[Maxn];\nmap <ll,int> M;\n\nstruct node{\n\tint num;\n\tll val;\n}N[Maxn];\n\nbool cmp(node a,node b){\treturn a.val > b.val;}\n\nint main()\n{\n\tmemset(son,0,sizeof(son));\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\tscanf(\"%lld\",&d);\n\t\tM[d] = i;\n\t\tN[i].num = i,N[i].val = d;\n\t}\n\tsort(N+1,N+1+n,cmp);\n\tmap<ll,int>::iterator iter;;\n\tfor(int i = 1;i < n;i ++)\n\t{\n\t\tint u = N[i].num;\n\t\tif((N[i].val - n + 2 + (son[u] << 1)) < N[n].val) continue;\n\t\titer = M.find(N[i].val - n + 2 + (son[u] << 1));\n\t\tif(iter == M.end()) continue;\n\t\tint v = iter->second;\n\t\tson[v] += son[u]+1;\n\t\tprintf(\"%d %d\\n\",u,v);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <climits>\n#include <set>\n#include <algorithm>\n#include <unordered_map>\n#include <queue>\n#include <iomanip>\n#include <map>\n#include <utility>\n#include <numeric>\n\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define P pair<int, int>\n#define debug(x) cout << #x << \": \" << x << \", \"\n#define debugln(x) cout << #x << \": \" << x << '\\n'\n\nusing namespace std;\nusing ll = long long;\nconst int mod = 1e9+7;\n\nvector<P> ans;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n; cin >> n;\n  vector<ll> vec(n);\n  unordered_map<ll, int> mp;\n\n  rep(i, n) {\n    cin >> vec.at(i);\n    mp[vec.at(i)] = i+1;\n  }\n\n  vector<int> used(n);\n  rep(i, n) {\n    used.at(i) = 1;\n  }\n  vector<int> graph[n+1];\n\n  sort(vec.rbegin(), vec.rend());\n  rep(i, n) {\n    ll a = vec.at(i);\n    int s = mp[a];\n    int d = n-(2*used.at(s-1));\n\n    if (d > 0 && mp[a-d] > 0) {\n      int t = mp[a-d];\n      used.at(t-1) += used.at(s-1);\n      ans.push_back(P(s,t));\n      graph[s].push_back(t);\n      graph[t].push_back(s);\n    }\n  }\n\n  vector<int> distance(n);\n  rep(i, n) {\n    distance.at(i) = INT_MAX;\n  }\n  queue<P> que;\n  que.push(P(0, 1));\n  while (!que.empty()) {\n    P pa = que.front(); que.pop();\n    int pos = pa.second;\n    int d = pa.first;\n    distance.at(pos-1) = d;\n    for(auto e : graph[pos]) {\n      if (distance.at(e-1) == INT_MAX) {\n        que.push(P(d+1, e));\n      }\n    }\n  }\n\n  ll sum = 0;\n  rep(i, n) {\n    if (distance.at(i) == INT_MAX) {\n      cout << -1 << endl;\n      return 0;\n    }\n    sum += distance.at(i);\n  }\n  if (mp[sum] != 1) {\n    cout << -1 << endl;\n    return 0;\n  }\n\n  for(auto e: ans) {\n    cout << e.first << ' ' << e.second << '\\n';\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// ====================================\n//   author: M_sea\n//   website: https://m-sea-blog.com/\n// ====================================\n#include <bits/stdc++.h>\n#define file(x) freopen(#x\".in\",\"r\",stdin); freopen(#x\".out\",\"w\",stdout)\nusing namespace std;\ntypedef long long ll;\n\nll read() {\n\tll X=0; char c=getchar();\n\twhile (c<'0'||c>'9') c=getchar();\n\twhile (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n\treturn X;\n}\n\nconst int N=100000+10;\n\nint n,sz[N],dep[N];\npair<ll,int> d[N];\nvector<int> E[N];\nvector<pair<int,int> > ans;\n\nvoid dfs(int u,int f) {\n\tdep[u]=dep[f]+1;\n\tfor (int v:E[u]) if (v!=f) dfs(v,u);\n}\n\nint main() {\n\tn=read();\n\tfor (int i=1;i<=n;++i) d[i]=make_pair(read(),i);\n\tsort(d+1,d+n+1);\n\tfor (int i=1;i<=n;++i) sz[i]=1;\n\tfor (int i=n;i>1;--i) {\n\t\tll dlt=2*sz[d[i].second]-n+d[i].first;\n\t\tint p=lower_bound(d+1,d+n+1,make_pair(dlt,0))-d;\n\t\tif (d[p].first!=dlt) { puts(\"-1\"); return 0; }\n\t\tint u=d[i].second,v=d[p].second;\n\t\tans.emplace_back(make_pair(u,v));\n\t\tE[u].emplace_back(v),E[v].emplace_back(u),sz[v]+=sz[u];\n\t}\n\tdep[0]=-1,dfs(d[1].second,0); ll s=0;\n\tfor (int i=1;i<=n;++i) s+=dep[i];\n\tif (s!=d[1].first) { puts(\"-1\"); return 0; }\n\tfor (auto i:ans) printf(\"%d %d\\n\",i.first,i.second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MN 100005\nint T,num,dep[MN],n,id[MN],head[MN];\nll a[MN];\nmap<ll,int>rea,cnt;\nstruct node{int x,y;};\nvector<node>sc;\nstruct edge{int to,next;}g[MN];\nbool cmp(int x,int y){return a[x]>a[y];}\nvoid ins(int u,int v){g[++num].next=head[u];head[u]=num;g[num].to=v;}\nvoid dfs(int u,int ff){\n\tfor(int i=head[u];i;i=g[i].next)if(g[i].to!=ff){\n\t\tdep[g[i].to]=dep[u]+1,dfs(g[i].to,u);\n\t}\n}\nint main(){\n//\tfreopen(\"test.in\",\"r\",stdin);\n//\tfreopen(\"mysol.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),rea[a[i]]=i,cnt[a[i]]=1,id[i]=i;\n\tsort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<n;i++){\n\t\tint t=id[i];ll tmp=a[t]-n+2*cnt[a[t]];\n\t\tif(rea[tmp]&&tmp<a[t]){\n\t\t\tcnt[tmp]+=cnt[a[t]];\n\t\t\tsc.push_back((node){t,rea[tmp]});\n\t\t}\n\t\telse return 0*puts(\"-1\");\n\t}\n\tfor(int i=0;i<sc.size();i++)ins(sc[i].x,sc[i].y);\n\tdfs(id[n],id[n]);ll tans=0;\n\tfor(int i=1;i<=n;i++)tans+=dep[i];\n\tif(tans!=a[id[n]])return 0*puts(\"-1\");\n\tfor(int i=0;i<sc.size();i++)printf(\"%d %d\\n\",sc[i].x,sc[i].y);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define loop(i, n) for(int i = 0;i < int(n);i++)\n#define rloop(i, n) for(int i = int(n);i >= 0;i--)\n#define range(i, a, b) for(int i = int(a);i <= int(b);i++)\n#define SZ(c) int(c.size())\n#define ALL(c) c.begin(), c.end()\n#define RALL(c) c.rbegin(), c.rend()\n#define PI acos(-1)\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n#define sfi1(v) scanf(\"%d\",&v)\n#define sfi2(v1, v2) scanf(\"%d %d\",&v1,&v2)\n#define sfi3(v1, v2, v3) scanf(\"%d %d %d\",&v1,&v2,&v3)\n#define sfll1(v) scanf(\"%I64d\",&v);\n#define sfll2(v1, v2) scanf(\"%I64d %I64d\",&v1,&v2)\n#define sfll3(v1, v2, v3) scanf(\"%I64d %I64d %I64d\",&v1,&v2,&v3)\n#define endl '\\n'\n\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int N = 1e5 + 5;\nvi adj[N];\nint w[N];\nset<pair<ll, int> > s;\nvii ans;\nll D[N];\nint n;\n\nll sum;\n\nvoid dfs(int u, int par, int lvl) {\n    sum += lvl;\n    for (int nxt : adj[u]) {\n        if (nxt == par)continue;\n        dfs(nxt, u, lvl + 1);\n    }\n}\n\n\nint main() {\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.in\", \"r\", stdin);\n    //freopen(\"out.in\", \"w\", stdout);\n#endif\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    cin >> n;\n    range(i, 1, n) {\n        w[i] = 1;\n        cin >> D[i];\n        //D[i] += 5;\n        s.insert({D[i], i});\n    }\n\n    while (SZ(s) > 1) {\n        auto it = prev(s.end());\n        ll have = it->fr;\n        int idx = it->sc;\n        ll need = have - (n - 2 * w[idx]);\n        auto c = s.lower_bound({need, -1});\n        if (c == s.end() || it == c || c->fr != need) {\n            cout << -1 << endl;\n            return 0;\n        }\n        w[c->sc] += w[idx];\n        ans.push_back({idx, c->sc});\n        s.erase(it);\n    }\n\n    for (auto edge : ans) {\n        adj[edge.fr].push_back(edge.sc);\n        adj[edge.sc].push_back(edge.fr);\n    }\n\n    dfs(s.begin()->sc, -1, 0);\n    if (sum != s.begin()->fr) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    for (auto edge: ans)cout << edge.fr << \" \" << edge.sc << endl;\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i, x, y) for(int i = x, B = y; i <= B; i ++)\n#define ff(i, x, y) for(int i = x, B = y; i <  B; i ++)\n#define fd(i, x, y) for(int i = x, B = y; i >= B; i --)\n#define ll long long\n#define pp printf\n#define hh pp(\"\\n\")\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nint n;\nll d[N];\nint a[N];\n\nmap<ll, int> bz;\n\nint cmpa(int x, int y) {\n\treturn d[x] > d[y];\n}\n\nint ans[N][2], ans0;\nvector<int> e[N];\n\nint siz[N];\n\nvoid Noans() {\n\tpp(\"-1\\n\");\n\texit(0);\n}\n\nll sum;\n\nvoid dg(int x, int y) {\n\tsum += y;\n\tff(j, 0, e[x].size()) {\n\t\tdg(e[x][j], y + 1);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfo(i, 1, n) scanf(\"%lld\", &d[i]), bz[d[i]] = i, a[i] = i;\n\tsort(a + 1, a + n + 1, cmpa);\n\tfo(i, 1, n) siz[i] = 1;\n\tfo(i, 1, n - 1) {\n\t\tint x = a[i];\n\t\tif(siz[x] * 2 > n)\n\t\t\tNoans();\n\t\tll y = d[x] - n + 2 * siz[x];\n\t\tif(!bz.count(y)) Noans();\n\t\ty = bz[y];\n\t\tsiz[y] += siz[x];\n\t\tans[++ ans0][0] = x, ans[ans0][1] = y;\n\t\te[y].push_back(x);\n\t}\n\tdg(a[n], 0);\n\tif(sum != d[a[n]]) Noans();\n\tfo(i, 1, n - 1) pp(\"%d %d\\n\", ans[i][0], ans[i][1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<iomanip>\n#include<cstring>\n#include<complex>\n#include<vector>\n#include<cstdio>\n#include<string>\n#include<bitset>\n#include<ctime>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#define Cpy(x,y) memcpy(x,y,sizeof(x))\n#define Set(x,y) memset(x,y,sizeof(x))\n#define FILE \"a\"\n#define mp make_pair\n#define pb push_back\n#define RG register\n#define il inline\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef vector<int>VI;\ntypedef long long ll;\ntypedef double dd;\nconst int N=1<<17;\nconst int mod=998244353;\nconst int base=26;\nconst dd eps=1e-6;\nconst int inf=2147483647;\nconst ll INF=1ll<<60;\nconst ll P=100000;\nil ll read(){\n  RG ll data=0,w=1;RG char ch=getchar();\n  while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n  if(ch=='-')w=-1,ch=getchar();\n  while(ch<='9'&&ch>='0')data=data*10+ch-48,ch=getchar();\n  return data*w;\n}\n\nil void file(){\n  srand(time(NULL)+rand());\n  freopen(FILE\".in\",\"r\",stdin);\n  freopen(FILE\".out\",\"w\",stdout);\n}\n\nint n,m;ll sz[N],o[N];\nstruct node{ll d,id;}t[N];\nbool cmp_d(node a,node b){return a.d<b.d;}\nbool cmp_id(node a,node b){return a.id<b.id;}\nil void er(){puts(\"-1\");exit(0);}\nstruct edge{int u,v;}E[N];\n\nint head[N],nxt[N<<1],to[N<<1],cnt;\nil void add(int u,int v){to[++cnt]=v;nxt[cnt]=head[u];head[u]=cnt;}\nll up[N],down[N],w[N];\nvoid dfs1(int u,int ff){\n  sz[u]=1;\n  for(RG int i=head[u];i;i=nxt[i]){\n    RG int v=to[i];if(v==ff)continue;\n    dfs1(v,u);sz[u]+=sz[v];\n    up[u]+=up[v]+sz[v];\n  }\n}\nvoid dfs2(int u,int ff){\n  for(RG int i=head[u];i;i=nxt[i]){\n    RG int v=to[i];if(v==ff)continue;\n    down[v]=down[u]+up[u]-(up[v]+sz[v])+(n-sz[v]);\n    dfs2(v,u);\n  }\n}\n\nint main()\n{\n  n=read();\n  for(RG int i=1;i<=n;i++){t[i].d=read();t[i].id=i;}\n  sort(t+1,t+n+1,cmp_d);\n  for(RG int i=1;i<=n;i++)o[i]=t[i].d,sz[i]=1;\n  for(RG int i=n,p;i!=1;i--){\n    p=lower_bound(o+1,o+n+1,t[i].d-n+2ll*sz[i])-o;\n    if(o[p]!=t[i].d-n+2ll*sz[i]||p>=i)er();\n    E[++m]=(edge){t[p].id,t[i].id};sz[p]+=sz[i];\n  }\n  for(RG int i=1;i<=m;i++)add(E[i].u,E[i].v),add(E[i].v,E[i].u);\n  dfs1(1,0);dfs2(1,0);sort(t+1,t+n+1,cmp_id);\n  for(RG int i=1;i<=n;i++)w[i]=down[i]+up[i];\n  for(RG int i=1;i<=n;i++)if(w[i]!=t[i].d)er();\n  for(RG int i=1;i<=m;i++)printf(\"%d %d\\n\",E[i].u,E[i].v);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define N 500005\nusing namespace std;\nint n,cnt,sum,a[N],sz[N],tmp[N],ansx[N],ansy[N];\nmap<int,int>b;\nvector<int>G[N];\ninline bool cmp(int x,int y){return a[x]>a[y];}\nvoid dfs(int u,int fa,int dep){\n\tsum+=dep;\n\tfor (int i=0;i<(int)G[u].size();i++){\n\t\tint v=G[u][i];\n\t\tif (v==fa) continue;\n\t\tdfs(v,u,dep+1);\n\t}\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%lld\",&a[i]),b[a[i]]=i,tmp[i]=i,sz[i]=1;\n\tsort(tmp+1,tmp+n+1,cmp);\n\tfor (int i=1;i<n;i++){\n\t\tint x=tmp[i];\n\t\tint dis=a[x]-(n-sz[x])+sz[x];\n\t\tif (!b[dis]) return puts(\"-1\"),0;\n\t\tint y=b[dis];\n\t\tsz[y]+=sz[x];ansx[++cnt]=x;ansy[cnt]=y;\n\t\tif (x==y) return puts(\"-1\"),0;\n\t\tG[y].push_back(x);\n\t}\n\tint rt=tmp[n];sum=0;\n\tdfs(rt,-1,0);\n\tif (sum!=a[n]) return puts(\"-1\"),0;\n\tfor (int i=1;i<=cnt;i++) printf(\"%lld %lld\\n\",ansx[i],ansy[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define ll long long\n#define ll1 1ll\n#define ONE 1ll\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF =\n    sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nusing pii = pair<int, int>;\n// template<class T> ostream &operator<<(ostream &os,T &t){dump(t);return os;}\ntemplate <typename T, typename S>\nistream &operator>>(istream &is, pair<T, S> &p) {\n  is >> p.first >> p.second;\n  return is;\n}\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, pair<T, S> &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate <typename T> void printvv(const vector<vector<T>> &v) {\n  cerr << endl;\n  rep(i, 0, v.size()) rep(j, 0, v[i].size()) {\n    if (typeid(v[i][j]).name() == typeid(INF).name() and v[i][j] == INF) {\n      cerr << \"INF\";\n    } else\n      cerr << v[i][j];\n    cerr << (j == v[i].size() - 1 ? '\\n' : ' ');\n  }\n  cerr << endl;\n}\n/*\n   typedef __int128_t Int;\n   std::ostream &operator<<(std::ostream &dest, __int128_t value) {\n   std::ostream::sentry s(dest);\n   if (s) {\n   __uint128_t tmp = value < 0 ? -value : value;\n   char buffer[128];\n   char *d = std::end(buffer);\n   do {\n   --d;\n *d = \"0123456789\"[tmp % 10];\n tmp /= 10;\n } while (tmp != 0);\n if (value < 0) {\n --d;\n *d = '-';\n }\n int len = std::end(buffer) - d;\n if (dest.rdbuf()->sputn(d, len) != len) {\n dest.setstate(std::ios_base::badbit);\n }\n }\n return dest;\n }\n\n __int128 parse(string &s) {\n __int128 ret = 0;\n for (int i = 0; i < s.length(); i++)\n if ('0' <= s[i] && s[i] <= '9')\n ret = 10 * ret + s[i] - '0';\n return ret;\n }\n */\n\n#ifndef _DEBUG\n#define printvv(...)\n#endif\nvoid YES(bool f) { cout << (f ? \"YES\" : \"NO\") << endl; }\nvoid Yes(bool f) { cout << (f ? \"Yes\" : \"No\") << endl; }\ntemplate <class T> bool chmax(T &a, const T &b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\nsigned main(signed argc, char *argv[]) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(12);\n\n  int N;\n  cin >> N;\n  map<int, int> mp;\n  vector<int> D(N);\n  rep(i, 0, N) {\n    cin >> D[i];\n    mp[D[i]] = i;\n  }\n  vector<int> size(N, 1);\n  vector<pii> ans;\n  for (auto it = mp.rbegin();*it!=*mp.begin(); it++) {\n    int d, i;\n    tie(d, i) = *it;\n    dump(d, i, size);\n    int nd = d + 2 * size[i] - N;\n    dump(nd);\n    if (not mp.count(nd) or mp[nd]==i) {\n      cout << -1 << endl;\n      return 0;\n    }\n    int parent = mp[nd];\n    ans.eb(i, parent);\n    size[parent] += size[i];\n  }\n\n  for (auto p : ans) {\n    cout << p.fi+1<<\" \"<<p.se+1 << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define eb emplace_back\n#define mt make_tuple\n#define all(x) (x).begin(), (x).end() \n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair <int, int> ii;\ntypedef pair <ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef long double ld;\n\nconst ll INF=LLONG_MAX;\nconst int mxn=1e5+5;\nint sz[mxn];\nbool vis[mxn];\n\nint main()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    //freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout);\n\tint n;\n\tcin >> n;\n\tii dist[n];\n\tmap<int,int>vis;\n\tfor(int i=0; i<n; i++){\n\t\tcin >> dist[i].fi;\n\t\tdist[i].se=i;\n\t\tsz[i]=1;\n\t\tvis[dist[i].fi]=i;\n\t}\n\tmap<ii,bool>edge;\n\tsort(dist,dist+n);\n\tfor(int i=n-1; i>0; i--){\n\t\tint ind = dist[i].se;\n\t\tint next = dist[i].fi-n+2*sz[ind];\n\t\tif(vis.find(next)==vis.end()||next>=dist[i].fi){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tauto ptr = vis[next];\n\t\tif(ptr==ind){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsz[ptr] += sz[ind];\n\t\tif(ptr>ind)swap(ind,ptr);\n\t\tedge[ii(ptr,ind)]=1;\n\t\tvis[ind]=1; vis[ptr]=1;\n\t}\n\tbool ok=0;\n\tfor(int i=0; i<n&&!ok; i++){\n\t\tif(sz[i]==n)ok=1;\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tif(!vis[i])ok=0;\n\t}\n\tif(!ok)cout << -1 << endl;\n\telse{\n\t\tfor(auto x:edge)\n\t\t\tcout << x.fi.fi+1 << ' ' << x.fi.se+1 << endl;\n\t}\n}\n\t\n// READ & UNDERSTAND\n// ll, int overflow, array bounds, memset(0)\n// special cases (n=1?), n+1 (1-index)\n// do smth instead of nothing & stay organized\n// WRITE STUFF DOWN\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <string>\n#include <cstring>\n\n#define sz(v) ((int)((v).size()))\n#define all(v) (v).begin(), (v).end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int INF = 0x3c3c3c3c;\nconst ll LINF = 1ll*INF*INF*2;\n\nconst int MAX_N = 100001;\nint n;\nll input[MAX_N];\nint sz[MAX_N];\nint par[MAX_N];\nll sum[MAX_N];\n\nint main(void) {\n\tscanf(\"%d\", &n);\n\tfor(int i=0; i<n; i++) scanf(\"%lld\", input+i);\n\n\tsort(input, input+n);\n\tfor(int i=0; i<n; i++) sz[i] = 1;\n\n\tfor(int i=n-1; i>0; i--) {\n\t\tll temp = input[i]+sz[i]+sz[i]-n;\n\t\tint idx = lower_bound(input, input+n, temp)-input;\n\t\tif(temp>=input[i] || input[idx] != temp) {\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tpar[i] = idx;\n\t\tsz[idx]+=sz[i];\n\t\tsum[idx]+=sum[i]+sz[i];\n\t}\n\n\tif(sum[0] != input[0]) {\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\n\tfor(int i=1; i<n; i++) {\n\t\tprintf(\"%d %d\\n\", par[i]+1, i+1);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma GCC optimize(\"O3\")\n#define fi first\n#define se second\n#define pb push_back\n#define pf push_front\n#define mod 1000000007\n\nusing namespace std;\n\ntypedef long long ll;\n\nll n, realdist[100002], dist[100002], sts[100002];\nvector<int>v[100002];\n\nbool cmp(int a, int b)\n{\n    return realdist[a] < realdist[b];\n}\n\nvoid dfs(int dad, int nod)\n{\n    for(int i = 0; i < v[nod].size(); ++i)\n    {\n        int vecin = v[nod][i];\n        if(vecin == dad)\n            continue;\n        dfs(nod, vecin);\n        dist[nod] = dist[nod] + dist[vecin] + sts[vecin];\n    }\n}\nvector<int>p;\nvoid dfs2(int dad, int nod, ll nodes, ll dst)\n{\n    if(nod == p[0])\n    {\n        if(dist[nod] != realdist[nod])\n        {\n            cout << -1;\n            exit(0);\n        }\n    }\n    else\n    {\n        if(dist[nod] + dst != realdist[nod])\n        {\n            cout << -1;\n            exit(0);\n        }\n    }\n    for(int i = 0; i < v[nod].size(); ++i)\n    {\n        int vecin = v[nod][i];\n        if(vecin == dad)\n            continue;\n        int new_amount = nodes + sts[nod] - sts[vecin];\n        ll new_dist = dst + new_amount + dist[nod] - dist[vecin] - sts[vecin];\n        dfs2(nod, vecin, new_amount, new_dist);\n    }\n}\nset<pair<ll, int> >s;\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n;\n    for(int i = 1; i <= n; ++i)\n    {\n        cin >> realdist[i];\n        s.insert({realdist[i], i});\n        p.pb(i);\n    }\n    sort(p.begin(), p.end(), cmp);\n    int z = 0;\n    pair<int, int> edg[100002];\n    for(int i = n-1; i > 0; --i)\n    {\n        ++sts[p[i]];\n        pair<ll, int> q = *s.lower_bound({realdist[p[i]] - n + 2 * sts[p[i]], 0});\n        if(q.first != realdist[p[i]] - n + 2 * sts[p[i]])\n        {\n            cout << -1;\n            return 0;\n        }\n        sts[q.se] += sts[p[i]];\n        v[q.se].pb(p[i]);\n        v[p[i]].pb(q.se);\n        edg[++z] = {q.se, p[i]};\n        if(edg[z].fi > edg[z].se)\n            swap(edg[z].fi, edg[z].se);\n    }\n    sts[p[0]]++;\n    dfs(0, p[0]);\n    dfs2(0, p[0], 0, 0);\n    sort(edg + 1, edg + n);\n    for(int i = 1; i < n; ++i)\n        cout << edg[i].fi << \" \" << edg[i].se << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define to edge[i].v\n#define mp make_pair\n#define rint register int\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define fgx cerr<<\"-------------\"<<endl\n#define N 1000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nstruct P{int id;ll s;}a[N];\ninline bool cmp(P x,P y){return x.s>y.s;}\nmap<ll,int> go; vector<int> e[N];\nint sz[N],fa[N],n,dep[N]; ll D,gg[N];\nvoid dfs1(int x,int la=0)\n{\tdep[x]=dep[la]+1; D+=dep[x];\n\tfor(auto y:e[x]) dfs1(y,x);\n}\nvoid dfs2(int x,ll d)\n{\tif(d!=gg[x]){printf(\"-1\");exit(0);}\n\tfor(auto y:e[x]) dfs2(y,d+n-2*sz[y]);\n}\nint main()\n{\tcin>>n;\n\tfor(rint i=1;i<=n;i++) scanf(\"%lld\",&a[i].s),a[i].id=i,go[a[i].s]=i,gg[i]=a[i].s;\n\tsort(a+1,a+n+1,cmp);\n\tfor(rint i=1;i<=n;i++) sz[i]=1;\n\tfor(rint i=1;i<n;i++)\n\t{\tint x=a[i].id; if(2*sz[x]-n>=0) return !printf(\"-1\");\n\t\tll sfa=a[i].s+2*sz[x]-n;\n\t\tif(!go[sfa]) return !printf(\"-1\");\n\t\tfa[x]=go[sfa]; sz[fa[x]]+=sz[x];// debug(x);debug(fa[x]);\n\t}\n\tfor(rint i=1;i<=n;i++) if(fa[i]) e[fa[i]].push_back(i);\n\tint rt=0; for(rint i=1;i<=n;i++) if(!fa[i]) rt=i;\n\tdep[0]=-1; dfs1(rt); dfs2(rt,D);\n\tfor(rint i=1;i<=n;i++) if(fa[i]) printf(\"%d %d\\n\",i,fa[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<iostream>\n#include<map>\n#include<vector>\n#define ll long long\n#define pii pair<int,int>\n#define MP make_pair\nusing namespace std;\nll n;\nmap<ll,int>rev;\nstruct node{ll d,siz,val;int id;}a[100005];\nbool cmp(node x,node y){return x.d>y.d;}\nint back[100005];\nvector<pii>ans;\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        scanf(\"%lld\",&a[i].d);\n        a[i].siz=1;a[i].id=i;\n        rev[a[i].d]=i;\n    }\n    sort(a+1,a+1+n,cmp);\n    for(int i=1;i<=n;i++) back[a[i].id]=i;\n    for(int i=1;i<n;i++){\n        if(n-2*a[i].siz<=0){puts(\"-1\");return 0;}\n        ll dd=a[i].d+2*a[i].siz-n;\n        if(!rev[dd]){puts(\"-1\");return 0;}\n        int fa=rev[dd];\n        ans.push_back(MP(min(fa,a[i].id),max(fa,a[i].id)));\n        a[back[fa]].siz+=a[i].siz;\n        a[back[fa]].val+=a[i].val+a[i].siz;\n    }\n    if(a[n].d!=a[n].val) return puts(\"-1\"),0;\n    sort(ans.begin(),ans.end());\n    for(int i=0;i<n-1;i++) printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define eb emplace_back\n#define mt make_tuple\n#define all(x) (x).begin(), (x).end() \n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair <int, int> ii;\ntypedef pair <ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef long double ld;\n\nconst ll INF=LLONG_MAX;\nconst int mxn=1e5+5;\nll sz[mxn],dis[mxn];\nvi adj[mxn];\nbool vis[mxn];\n\nvoid dfs(int u, int p=-1){\n\tfor(int v:adj[u])\n\t\tif(v!=p)dis[v]=dis[u]+1,dfs(v,u);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    //freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout);\n\tint n;\n\tcin >> n;\n\tpair<ll,int> dist[n];\n\tmap<ll,int>mp;\n\tfor(int i=0; i<n; i++){\n\t\tcin >> dist[i].fi;\n\t\tdist[i].se=i;\n\t\tsz[i]=1LL;\n\t\tmp[dist[i].fi]=i;\n\t}\n\tmap<ii,bool>edge;\n\tsort(dist,dist+n);\n\tfor(int i=n-1; i>0; i--){\n\t\tint ind = dist[i].se;\n\t\tll next = dist[i].fi-n+2*sz[ind];\n\t\tif(mp.find(next)==mp.end()){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint ptr = mp[next];\n\t\tif(ptr==ind){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsz[ptr] += sz[ind];\n\t\tif(ptr>ind)swap(ind,ptr);\n\t\tedge[ii(ptr,ind)]=1;\n\t\tadj[ind].eb(ptr);\n\t\tadj[ptr].eb(ind);\n\t\tvis[ind]=1; vis[ptr]=1;\n\t}\n\tbool ok=0;\n\tfor(int i=0; i<n&&!ok; i++)\n\t\tif(sz[i]==n)ok=1;\n\tfor(int i=0; i<n; i++)\n\t\tif(!vis[i])ok=0;\n\tdfs(dist[0].se);\n\tint sum = 0;\n\tfor(int i=0; i<n; i++)sum+=dis[i];\n\tif(sum!=dist[0].fi)ok=0;\n\tif(!ok)cout << -1 << endl;\n\telse{\n\t\tfor(auto x:edge)\n\t\t\tcout << x.fi.fi+1 << ' ' << x.fi.se+1 << endl;\n\t}\n}\n\t\n// READ & UNDERSTAND\n// ll, int overflow, array bounds, memset(0)\n// special cases (n=1?), n+1 (1-index)\n// do smth instead of nothing & stay organized\n// WRITE STUFF DOWN\n"
  },
  {
    "language": "C++",
    "code": "\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long int LL;\nconst int Max_N(100050);\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nstruct node\n{\n\tint u;\n\tLL d;\n};\nint N, Head[Max_N], Next[Max_N], Size[Max_N];\nnode V[Max_N];\nmap<LL, int> S;\n\ninline void Add_Edge(int s, int t)\n{\n\tNext[t] = Head[s], Head[s] = t;\n}\n\ninline bool comp(const node &a, const node &b)\n{\n\treturn a.d > b.d;\n}\n\nLL Sum;\nvoid dfs(int u, int dep)\n{\n\tSum += dep;\n\tfor (int v = Head[u];v;v = Next[v])\n\t\tdfs(v, dep + 1);\n}\n\nvoid dfs2(int u)\n{\n\tif (S[Sum] != u)\n\t{\n\t\tprint(-1);\n\t\texit(0);\n\t}\n\tfor (int v = Head[u];v;v = Next[v])\n\t\tSum += (N - Size[v]) - Size[v], dfs2(v), Sum -= (N - Size[v]) - Size[v];\n}\n\nint main()\n{\n\tgi(N);\n\tfor (int i = 1;i <= N;++i)\n\t\tgi(V[V[i].u = i].d), S[V[i].d] = V[i].u, Size[i] = 1;\n\tsort(V + 1, V + 1 + N, comp);\n\tfor (int i = 1, u, fa;i <= N;++i)\n\t{\n\t\tu = V[i].u;\n\t\tLL d = V[i].d - (N - Size[u]) + Size[u];\n\t\tif (d >= V[i].d || !(fa = S[d]))\n\t\t{\n\t\t\tprint(-1);\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t\tAdd_Edge(fa, u), Size[fa] += Size[u];\n\t}\n\tdfs(1, 0);\n\tdfs2(1);\n\tfor (int u = 1;u <= N;++u)\n\t\tfor (int v = Head[u];v;v = Next[v])\n\t\t\tprint(u), putc(' '), print(v), putc('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,j,k) for(int i=j;i<=k;++i)\ntypedef long long ll;\nchar cch;\ninline ll rd(){\n\tll x=0,fl=1;\n\tcch=getchar();\n\twhile(cch>'9'||cch<'0'){\n\t\tif(cch=='-') fl=-1;\n\t\tcch=getchar();\n\t}\n\twhile(cch>='0'&&cch<='9') x=(x<<3)+(x<<1)+cch-'0',cch=getchar();\n\treturn x*fl;\n}\nconst int N=1e5+3;\nstruct abc{\n\tint i;\n\tll d;\n}a[N];\nint fr[N],head[N],to[N],nxt[N],cnt,sz[N];\nll re,c[N];\ninline bool cmp(const abc &a,const abc &b){\n\treturn a.d<b.d;\n}\ninline void adde(int u,int v){\n\tto[++cnt]=v,fr[cnt]=u,nxt[cnt]=head[u],head[u]=cnt;\n}\ninline void dfs(int u,int fa,int dep){\n\tre+=dep;\n\tfor(int i=head[u];i;i=nxt[i]){\n\t\tdfs(to[i],u,dep+1);\n\t}\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\trep(i,1,n) a[i].d=rd(),a[i].i=i,sz[i]=1;\n\tsort(a+1,a+1+n,cmp);\n\trep(i,1,n) c[i]=a[i].d;\n\tint pos;\n\tll tmp;\n\tfor(int i=n;i>1;--i){\n\t\ttmp=a[i].d-(n-sz[a[i].i])+sz[a[i].i];\n\t\tpos=lower_bound(c+1,c+n+1,tmp)-c;\n\t\tif(c[pos]!=tmp){\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t\telse sz[a[pos].i]+=sz[a[i].i],adde(a[pos].i,a[i].i);\n\t}\n\tdfs(a[1].i,0,0);\n\tif(re!=a[1].d){\n\t\tputs(\"-1\");return 0;\n\t}\n\tfor(int i=1;i<n;++i){\n\t\tprintf(\"%d %d\\n\",fr[i],to[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100010;\ntypedef long long int64;\n\nmap<int64 , int> val;\nint n , size[N] , fa[N];\n\nint64 d[N];\ntypedef pair<int64 , int> pii;\npriority_queue<pii> leaf;\n#define mp make_pair \n\nint main() {\n    cin >> n;\n    for(int i = 1 ; i <= n ; ++i) {\n        cin >> d[i];\n        size[i] = 1;\n        val[d[i]] = i; \n    }\n    for(int i = 1 ; i <= n ; ++i) leaf.push(mp(d[i] , i));\n\n    while(leaf.size()) {\n        int x = leaf.top().second;\n        leaf.pop();\n\n\t\tval.erase(d[x]);\n        if(val.count(d[x] - n + size[x]*2))\n            fa[x] = val[d[x] - n + size[x]*2];\n        else break;\n        \n        size[fa[x]] += size[x];\n    }\n    if(val.size()) cout << -1 << endl;\n    else {\n        for(int i = 1 ; i <= n ; ++i)\n            if(fa[i]) cout << i << ' ' << fa[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<math.h>\n#include<stdlib.h>\n#include<set>\n#include<bitset>\n#include<map>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<complex>\n#include<list>\n#include<limits.h>\nusing namespace std;\n\nconst int N=1e5+5;\ntypedef pair<int,int> pii;\nint n;\npair<long long,int> a[N];\nlong long sz[N];\nlong long dp[N];\nvector<pii> vp;\nmap<long long,int> mp;\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%I64d\",&a[i].first);\n\t\ta[i].second=i;\n\t}\n\tsort(a+1,a+1+n);\n\treverse(a+1,a+1+n);\n\tfor(int i=1;i<=n;i++) mp[a[i].first]=i;\n\tfor(int i=1;i<=n;i++) sz[i]=1ll;\n\tfor(int i=1;i<n;i++){\n\t\tlong long fnd=a[i].first-1ll*n+2*sz[i];\n\t\tif(mp.find(fnd)==mp.end()){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint nxt=mp[fnd];\n\t\tdp[nxt]+=dp[i]+sz[i];\n\t\tsz[nxt]+=sz[i];\n\t\tvp.push_back(make_pair(a[i].second,a[nxt].second));\n\t}\n\tif(vp.size()!=n-1||dp[n]!=a[n].first) puts(\"-1\");\n\telse for(int i=0;i<vp.size();i++) printf(\"%d %d\\n\",vp[i].first,vp[i].second);\n\treturn 0;\n}\n\n/*\n数据不清空，爆零两行泪\n读题不认真，爆零两行泪\n分析不仔细，爆零两行泪\n建树不构造，爆零两行泪\n变量不统一，爆零两行泪\n边界不算清，爆零两行泪\n数组不开大，爆零两行泪\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 5;\nint n;\nlong long d[N];\npriority_queue <pair <long long, int> > pq;\nint siz[N];\nint fa[N];\nmap <long long, set <int> > mp;\nvector <int> g[N];\n\n#define NO() return puts(\"-1\"), 0\n\nlong long dfs(int u) {\n\tlong long ans = 0;\n\tfor (int i = 0; i < g[u].size(); ++ i)\n\t\tans += dfs(g[u][i]) + siz[g[u][i]];\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++ i)\n\t\tscanf(\"%lld\", &d[i]), mp[d[i]].insert(i),\n\t\tsiz[i] = 1, pq.push(make_pair(d[i], i));\n\tint rt;\n\twhile (!pq.empty()) {\n\t\tint u = pq.top().second;\n\t\tpq.pop(); mp[d[u]].erase(u);\n\t\tif (!pq.empty()) {\n\t\t\tlong long fa_d = (d[u] - (n - 2 * siz[u]));\n//\t\t\tprintf(\"%d %lld %lld\\n\", u + 1, d[u], fa_d);\n\t\t\tif (!mp[fa_d].size()) NO();\n\t\t\tint v = *mp[fa_d].begin();\n\t\t\tfa[u] = v;\n\t\t\tg[v].push_back(u);\n\t\t\tsiz[v] += siz[u];\n\t\t} else fa[u] = -1, rt = u;\n\t}\n\tif (dfs(rt) != d[rt]) NO();\n\tfor (int i = 0; i < n; ++ i)\n\t\tif (~fa[i]) printf(\"%d %d\\n\", fa[i] + 1, i + 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> d(n);\n  for(Int i=0;i<n;i++) cin>>d[i];\n  map<Int, Int> r;\n  for(Int i=0;i<n;i++) r[d[i]]=i;\n\n  vector<vector<Int> > G(n);\n  auto NO=[](){cout<<-1<<endl;exit(0);};\n  auto add_edge=[&](Int x,Int y){\n\t\t  G[x].emplace_back(y);\n\t\t  G[y].emplace_back(x);\n\t\t};\n\n  using P = pair<Int, Int>;\n  priority_queue<P> pq;\n  vector<Int> s(n,1),used(n,0);\n  for(Int i=0;i<n;i++) pq.emplace(d[i],i);\n  \n  while(pq.size()>1u){\n    Int x,v;\n    tie(x,v)=pq.top();pq.pop();\n    \n    Int nd=x-(n-s[v])+s[v];\n    if(!r.count(nd)) NO();\n    \n    Int u=r[nd];    \n    if(used[u]) NO();\n    \n    add_edge(v,u);\n    s[u]+=s[v];    \n    used[v]=1;\n  }\n\n  vector<Int> sz(n,1);\n  vector<Int> dp1(n,0),dp2(n,0);\n  function<Int(Int, Int)> dfs1=\n    [&](Int v,Int p){\n      for(Int u:G[v]){\n\tif(u==p) continue;\n\tdp1[v]+=dfs1(u,v);\n\tdp1[v]+=sz[u];\n\tsz[v]+=sz[u];\n      }\n      return dp1[v];\n    };\n  \n  if(d[i]!=dfs1(0,-1)) NO();\n  \n  for(Int v=0;v<n;v++)\n    for(Int u:G[v]) if(v<u) cout<<v+1<<\" \"<<u+1<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint PREP = (cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(9), 0);\n//int SEGV = getenv(\"D\") || (exit(system(\"D= SEGFAULT_SIGNALS=all catchsegv ./prog.exe\") >> 8), 0);\nvoid fail() {\n    cout << -1 << '\\n';\n    exit(0);\n}\nint main() {\n    int N; cin >> N;\n    if (N == 2) fail();\n    map<Int, pair<int, int>> M; // D[i] -> idx, num\n    vector<pair<int, int>> ans;\n    for (int i = 0; i < N; i++) {\n        Int d; cin >> d;\n        M[d] = make_pair(i, 1);\n    }\n    for (auto it = rbegin(M), ite = rend(M); it != ite; ++it) {\n        int idx, num; tie(idx, num) = it->second;\n        if (num == N) continue;\n        Int dnext = it->first - abs((N - num) - num);\n        if (!M.count(dnext)) fail();\n        ans.emplace_back(idx, M[dnext].first);\n        M[dnext].second += num;\n    }\n    for (auto &p : ans) {\n        cout << p.first + 1 << ' ' << p.second + 1 << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=1e5+2;\nmap<int,int> idx;\nvector<pair<int,int> > ans;\nint n,ar[N],sz[N],sz1[N],ar1[N];\nvector<int> adj[N];\nvoid dfs(int x,int p){\n\tsz[x]=1;\n\tfor(int i:adj[x]){\n\t\tif(i!=p){\n\t\t\tdfs(i,x);\n\t\t\tsz[x]+=sz[i];\n\t\t\tsz1[x]+=sz1[i]+sz[i];\n\t\t}\n\t}\n}\nvoid dfs1(int x,int p){\n\tfor(int i:adj[x]){\n\t\tif(i!=p){\n\t\t\tsz1[i]=sz1[x]+n-2*sz[i];\n\t\t\tdfs1(i,x);\n\t\t}\n\t}\n}\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint m,i,j,k,l;\n\tcin>>n;\n\tfor(i=1;i<=n;i++){\n\t\tcin>>ar[i];\n\t\tar1[i]=ar[i];\n\t\tidx[ar[i]]=i;\n\t\tsz[i]=1;\n\t}\n\tsort(ar+1,ar+1+n);\n\tfor(i=n;i>1;i--){\n\t\tk=idx[ar[i]]; j=ar[i]+2*sz[k]-n; l=idx[j];\n\t\tif(!l||j>=ar[i]){\n\t\t\tcout<<\"-1\";\n\t\t\treturn 0;\n\t\t}\n\t\tadj[l].push_back(k);\n\t\tadj[k].push_back(l);\n\t\tsz[l]+=sz[k];\n\t\tans.push_back({k,l});\n\t}\n\tdfs(1,1);\n\tdfs1(1,1);\n\tfor(i=1;i<=n;i++){\n\t\tif(sz1[i]!=ar1[i]){\n\t\t\tcout<<\"-1\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(i=0;i<ans.size();i++){\n\t\tcout<<ans[i].first<<' '<<ans[i].second<<'\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2020/01/28] 22:36:00\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nusing max_heap = std::priority_queue<T>;\ntemplate<typename T>\nusing min_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\nauto mfp = [](auto&& f) { return [=](auto&&... args) { return f(f, std::forward<decltype(args)>(args)...); }; };\n\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\nstruct io_init\n{\n    io_init()\n    {\n        std::cin.tie(nullptr), std::ios::sync_with_stdio(false);\n        std::cout << std::fixed << std::setprecision(20);\n    }\n    void clear()\n    {\n        std::cin.tie(), std::ios::sync_with_stdio(true);\n    }\n} io_setting;\n\nint out() { return 0; }\ntemplate<typename T>\nint out(const T& v) { return std::cout << v, 0; }\ntemplate<typename T>\nint out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    return 0;\n}\ntemplate<typename T1, typename T2>\nint out(const std::pair<T1, T2>& v) { return out(v.first), std::cout << ' ', out(v.second), 0; }\ntemplate<typename T, typename... Args>\nint out(const T& v, const Args... args) { return out(v), std::cout << ' ', out(args...), 0; }\ntemplate<typename... Args>\nint outln(const Args... args) { return out(args...), std::cout << '\\n', 0; }\ntemplate<typename... Args>\nvoid outel(const Args... args) { return out(args...), std::cout << std::endl, 0; }\n#    define SHOW(...) static_cast<void>(0)\nconstexpr ull TEN(const usize n) { return n == 0 ? 1ULL : TEN(n - 1) * 10ULL; }\n\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type, const T& v = T{}) { return v; }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type szs, const T& v = T{})\n{\n    const usize s = (usize)szs[i];\n    return std::vector<decltype(make_v<T, Uint, n, i + 1>(szs, v))>(s, make_v<T, Uint, n, i + 1>(szs, v));\n}\ntemplate<typename T, typename Uint, usize n>\nauto make_v(c_arr<Uint, n> szs, const T& t = T{}) { return make_v<T, Uint, n, 0>(szs, t); }\n\ntemplate<typename Cost = usize>\nstruct edge\n{\n    using cost_type = Cost;\n    usize u, v;\n    Cost c;\n    edge(const usize u, const usize v) : u{u}, v{v}, c{1} {}\n    edge(const usize u, const usize v, const Cost& c) : u{u}, v{v}, c{c} {}\n    operator usize() const { return v; }\n    usize from() const { return u; }\n    usize to() const { return v; }\n    Cost cost() const { return c; }\n    friend std::ostream& operator<<(std::ostream& os, const edge& e) { return os << e.u << \"->\" << e.v << \":\" << e.c; }\n};\ntemplate<typename Edge>\nclass base_graph\n{\npublic:\n    base_graph(const usize n) : v{n}, es(n), res(n) {}\n    void add_edge(const usize u, const usize v, const bool bi = false)\n    {\n        es[u].emplace_back(u, v), res[v].emplace_back(v, u);\n        if (bi) { es[v].emplace_back(v, u), res[u].emplace_back(u, v); }\n    }\n    template<typename Cost>\n    void add_edge(const usize u, const usize v, const Cost& c, const bool bi = false)\n    {\n        es[u].emplace_back(u, v, c), res[v].emplace_back(v, u, c);\n        if (bi) { es[v].emplace_back(v, u, c), res[u].emplace_back(u, v, c); }\n    }\n    std::vector<Edge>& operator[](const usize u) { return es[u]; }\n    const std::vector<Edge>& operator[](const usize u) const { return es[u]; }\n    std::vector<Edge>& from(const usize u) { return es[u]; }\n    const std::vector<Edge>& from(const usize u) const { return es[u]; }\n    std::vector<Edge>& to(const usize v) { return res[v]; }\n    const std::vector<Edge>& to(const usize v) const { return res[v]; }\n    usize size() const { return v; }\n    friend std::ostream& operator<<(std::ostream& os, const base_graph& g)\n    {\n        for (usize i = 0; i < g.v; i++) {\n            for (const auto& e : g.es[i]) { os << e << '\\n'; }\n        }\n        return os;\n    }\n\nprivate:\n    usize v;\n    std::vector<std::vector<Edge>> es, res;\n};\ntemplate<typename Edge>\nusing base_tree = base_graph<Edge>;\nusing graph     = base_graph<edge<>>;\nusing tree      = base_graph<edge<>>;\ntemplate<typename Cost>\nusing cost_graph = base_graph<edge<Cost>>;\ntemplate<typename Cost>\nusing cost_tree = base_graph<edge<Cost>>;\nint main()\n{\n    auto N = in<int>();\n    if (N == 2) { return outln(-1); }\n    auto ds = in_v<ll>({N});\n    std::map<ll, int> mp;\n    std::map<ll, int, std::greater<ll>> sub;\n    for (int i = 0; i < N; i++) { mp[ds[i]] = i; }\n    for (const ll d : ds) { sub[d] = 1; }\n    graph g(N);\n    int r = -1;\n    for (int i = 0; i < N - 1; i++) {\n        const auto fst = *sub.begin();\n        sub.erase(sub.begin());\n        const ll d  = fst.first;\n        const int s = fst.second;\n        const ll p  = d - (N - 2LL * s);\n        if (sub.count(p) == 0) { return outln(-1); }\n        g.add_edge(mp[p], mp[d]);\n        r = mp[p], sub[p] += s;\n    }\n    std::vector<int> sz(N, 1);\n    std::vector<ll> es(N, 0);\n    mfp([&](auto&& self, const int s) -> void {\n        for (const int to : g[s]) {\n            self(self, to);\n            sz[s] += sz[to];\n            es[s] += (es[to] + sz[to]);\n        }\n    })(r);\n    mfp([&](auto&& self, const int s) -> void {\n        for (const int to : g[s]) {\n            es[to] = es[s] + (N - 2 * sz[to]);\n            self(self, to);\n        }\n    })(r);\n    SHOW(es);\n    if (es != ds) { return outln(-1); }\n    for (int i = 0; i < N; i++) {\n        for (const int to : g[i]) { outln(i + 1, to + 1); }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 100005\nusing namespace std;\ntypedef long long LL;\nLL read()\n{\n    char c=getchar();LL f=1,sum=0;\n    while(c<'0' || c>'9'){if(c=='-')f=-1;c=getchar();}\n    while(c>='0' && c<='9'){sum=sum*10+c-'0';c=getchar();}\n    return sum*f;\n}\nLL n;\nstruct node{\n\tLL id,dis;\n}a[maxn];\nLL siz[maxn],fa[maxn],d[maxn],dep[maxn];\nvector<LL> edge[maxn];\nLL ans;\nbool cmp(node l,node r){return l.dis<r.dis;}\nvoid dfs(LL u,LL fa)\n{\n\tdep[u]=dep[fa]+1;\n\tfor(int i=0;i<edge[u].size();i++) if(edge[u][i]!=fa) dfs(edge[u][i],u);\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++) a[i].dis=read(),a[i].id=i;\n\tsort(a+1,a+n+1,cmp);\n\tfor(int i=1;i<=n;i++) d[i]=a[i].dis;\n\tfor(int i=n;i>=2;i--)\n\t{\n\t\tsiz[a[i].id]++;\n\t\tLL tmp=d[i]-(n-2*siz[a[i].id]);\n\t\tLL pos=lower_bound(d+1,d+i,tmp)-d;\n\t\tif(pos>=i||d[pos]!=tmp) return puts(\"-1\"),0;\n\t\tsiz[a[pos].id]+=siz[a[i].id];\n\t\tfa[a[i].id]=a[pos].id;\n\t}\n\tfor(int i=1;i<=n;i++)\n\tif(fa[i]) edge[fa[i]].push_back(i);\n\tdep[0]=-1;\n\tdfs(a[1].id,0);\n\tfor(int i=1;i<=n;i++) ans+=dep[i];\n\tif(ans!=d[1]) return puts(\"-1\"),0; \n\tfor(int i=1;i<=n;i++) if(fa[i]) printf(\"%lld %lld\\n\",i,fa[i]);\n} "
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <complex>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n\nusing namespace std;\n\nstruct Initializer {\n  Initializer() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout << fixed << setprecision(15);\n  }\n} initializer;\n\ntemplate<typename T> istream& operator>>(istream &s, vector<T> &v) {\n  for (T &t : v) s >> t;\n  return s;\n}\n\ntemplate<typename T> ostream& operator<<(ostream &s, const vector<T> &v) {\n  for (const T &t : v) s << t << endl;\n  return s;\n}\n\ntemplate<typename T> T min(vector<T>& v) {return *min_element(v.begin(), v.end());}\n\ntemplate<typename T> T max(vector<T>& v) {return *max_element(v.begin(), v.end());}\n\ntemplate<typename T> int min_element(vector<T>& v) {return min_element(v.begin(), v.end()) - v.begin();}\n\ntemplate<typename T> int max_element(vector<T>& v) {return max_element(v.begin(), v.end()) - v.begin();}\n\ntemplate<typename T> void sort(vector<T>& v) {sort(v.begin(), v.end());}\n\ntemplate<typename T, typename Function> void sort(vector<T>& v, Function func) {sort(v.begin(), v.end(), func);}\n\ntemplate<typename T> void rsort(vector<T>& v) {sort(v.rbegin(), v.rend());}\n\ntemplate<typename T> void reverse(vector<T>& v) {reverse(v.begin(), v.end());}\n\ntemplate<typename T> void unique(vector<T>& v) {v.erase(unique(v.begin(), v.end()), v.end());}\n\ntemplate<typename T> void nth_element(vector<T>& v, int n) {nth_element(v.begin(), v.begin() + n, v.end());}\n\ntemplate<typename T> bool next_permutation(vector<T>& v) {return next_permutation(v.begin(), v.end());}\n\ntemplate<typename T> int find(vector<T>& v, T t) {return find(v.begin(), v.end(), t) - v.begin();}\n\ntemplate<typename T> int in(vector<T> v, T t) {return find(v, t) != int(v.size());}\n\ntemplate<typename T> int lower_bound(vector<T>& v, T t) {return lower_bound(v.begin(), v.end(), t) - v.begin();}\n\ntemplate<typename T> int upper_bound(vector<T>& v, T t) {return upper_bound(v.begin(), v.end(), t) - v.begin();}\n\ntemplate<typename T> T accumulate(const vector<T>& v, function<T(T, T)> func = plus<T>()) {return accumulate(v.begin(), v.end(), T(), func);}\n\ntemplate<typename T> void adjacent_difference(vector<T>& v) {adjacent_difference(v.begin(), v.end(), v.begin());}\n\ntemplate<typename T> void adjacent_difference(vector<T>& v, vector<T>& u) {adjacent_difference(v.begin(), v.end(), u.begin());}\n\ntemplate<typename T> void partial_sum(vector<T>& v, vector<T>& u) {partial_sum(v.begin(), v.end(), u.begin());}\n\ntemplate<typename T> T inner_product(vector<T>& v, vector<T>& u) {return inner_product(v.begin(), v.end(), u.begin(), T(0));}\n\ntemplate<typename T> int count(const vector<T>& v, T t) {return count(v.begin(), v.end(), t);}\n\ntemplate<typename T, typename Function> int count_if(const vector<T>& v, Function func) {return count_if(v.begin(), v.end(), func);}\n\ntemplate<typename T, typename Function> void remove_if(vector<T>& v, Function func) {v.erase(remove_if(v.begin(), v.end(), func), v.end());}\n\ntemplate<typename T, typename Function> bool all_of(vector<T> v, Function func) {return all_of(v.begin(), v.end(), func);}\n\ntemplate<typename T, typename Function> bool any_of(vector<T> v, Function func) {return any_of(v.begin(), v.end(), func);}\n\ntemplate<typename T, typename Function> bool none_of(vector<T> v, Function func) {return none_of(v.begin(), v.end(), func);}\n\ntemplate<typename T> vector<T> subvector(vector<T>& v, int a, int b) {return vector<T>(v.begin() + a, v.begin() + b);}\n\ntemplate<typename T> int kinds(const vector<T>& v) {return set<T>(v.begin(), v.end()).size();}\n\ntemplate<typename T> void iota(vector<T>& v, T t = 0) {iota(v.begin(), v.end(), t);}\n\ntemplate<typename T> bool is_sorted(const vector<T>& v) {return is_sorted(v.begin(), v.end());}\n\ntemplate<typename Graph, typename State> class Search {\nprotected:\n  using Edge = typename Graph::EdgeType;\n\n  const Graph graph;\n  vector<bool> visited;\n\n  virtual void push(const State&) = 0;\n  virtual State next() = 0;\n  virtual bool isRunning() = 0;\n\n  virtual void visit(const State&) {}\n\npublic:\n  Search(const Graph& graph) : graph(graph), visited(graph.size(), false) {}\n\n  void solve(vector<int> from) {\n    for (int i : from) push(State(i));\n    while (isRunning()) {\n      State now = next();\n      int pos = now.getPos();\n      if (visited[pos]) continue;\n      visited[pos] = true;\n      visit(now);\n      for (const Edge& edge : graph.getEdges(pos)) {\n        State nextState = now.next(pos, edge);\n        if (visited[nextState.getPos()]) continue;\n        push(nextState);\n      }\n    }\n  }\n\n  void solve(int from) {solve(vector<int>({from}));}\n\n  bool isReachable(int v) {return visited[v];}\n};\n\ntemplate<typename Edge> class Tree {\npublic:\n  using EdgeType = Edge;\n\n  vector<Edge> parent;\n  vector<vector<int>> children;\n  vector<int> depth;\n\n  Tree() {}\n\n  Tree(int n) : children(n), depth(n, -1) {\n    for (int i = 0; i < n; ++i) parent.emplace_back(i);\n  }\n\n  int size() const {\n    return parent.size();\n  }\n  \n  template<typename... Args> void addEdge(int from, int to, Args... args) {\n    parent[from] = Edge(to, args...);\n    children[to].emplace_back(from);\n  }\n\n  void addEdge(int from, const Edge& edge) {\n    parent[from] = edge;\n    children[edge.to].emplace_back(from);\n  }\n\n  vector<Edge> getEdges(int from) const {\n    vector<Edge> res;\n    for (int v : children[from]) {\n      auto e = parent[v];\n      e.to = v;\n      res.emplace_back(e);\n    }\n    if (from != parent[from].to) res.emplace_back(parent[from]);\n    return res;\n  }\n\n  int getDepth(int v) {\n    if (depth[v] != -1) return depth[v];\n    if (parent[v].to == v) return depth[v] = 0;\n    return depth[v] = getDepth(parent[v].to) + 1;\n  }\n\n  vector<int> getPath(int v) {\n    vector<int> res{v};\n    while (v != parent[v].to) {\n      v = parent[v].to;\n      res.emplace_back(v);\n    }\n    return res;\n  }\n};\n\ntemplate<typename Edge> struct BFSState {\n  int pos, prv;\n\n  BFSState(const int pos, const int prv = -1) : pos(pos), prv(prv) {}\n  \n  BFSState next(const int pos, const Edge& edge) const {return BFSState(edge.to, pos);}\n\n  int getPos() {return pos;}\n};\n\ntemplate<typename Graph, typename State = BFSState<typename Graph::EdgeType>> class BFS : public Search<Graph, State> {\nprotected:\n  using Edge = typename Graph::EdgeType;\n\n  queue<State> que;\n  \n  void push(const State& state) {que.push(state);}\n  \n  State next() {\n    State now = que.front();\n    que.pop();\n    return now;\n  }\n  \n  bool isRunning() {return !que.empty();}\n\npublic:\n  BFS(const Graph& graph) : Search<Graph, State>(graph) {}\n};\n\ntemplate<typename Graph, bool Restoration = false> class BFSDistance : public BFS<Graph> {\nprivate:\n  using Edge = typename Graph::EdgeType;\n  using State = BFSState<typename Graph::EdgeType>;\n\n  void visit(const State& state) {\n    if (state.prv != -1) {\n      if (Restoration) shortestPathTree.addEdge(state.pos, state.prv);\n      dis[state.pos] = dis[state.prv] + 1;\n    }\n  }\n\npublic:\n  vector<int> dis;\n  Tree<Edge> shortestPathTree;\n\n  BFSDistance(const Graph& graph) : BFS<Graph>(graph), dis(graph.size(), 0) {\n    if (Restoration) shortestPathTree = Tree<Edge>(graph.size());\n  }\n};\n\ntemplate<typename Graph> BFSDistance<Graph> bfsDistance(const Graph& graph, int from) {\n  BFSDistance<Graph> bfs(graph);\n  bfs.solve(from);\n  return bfs;\n}\n\ntemplate<typename Graph> typename Graph::EdgeType::CostType bfsDistance(const Graph& graph, int from, int to) {\n  return bfsDistance(graph, from).dis[to];\n}\n\ntemplate<typename Graph> BFSDistance<Graph, true> bfsDistanceTree(const Graph& graph, int from) {\n  BFSDistance<Graph, true> bfs(graph);\n  bfs.solve(from);\n  return bfs;\n}\n\ntemplate<typename Edge> struct FullEdge : public Edge {\n  int from;\n\n  FullEdge() = default;\n\n  FullEdge(const int from, const Edge& edge) : Edge(edge), from(from) {}\n};\n\nstruct Edge {\n  using CostType = int;\n  const static int cost = 1;\n  int to;\n  Edge(int to = -1) : to(to) {}\n  bool isNone() const {return to == -1;}\n};\n\nistream& operator>>(istream& s, FullEdge<Edge>& edge) {\n  s >> edge.from >> edge.to;\n  return s;\n}\n\nostream& operator<<(ostream& s, const FullEdge<Edge>& edge) {\n  s << '(' << edge.from << ',' << edge.to << ')';\n  return s;\n}\n\ntemplate<typename Cost> struct WeightedEdge : public Edge {\n  using CostType = Cost;\n  Cost cost;\n  WeightedEdge(int to = -1, Cost cost = 0) : Edge(to), cost(cost) {}\n};\n\ntemplate<typename Cost> istream& operator>>(istream& s, FullEdge<WeightedEdge<Cost>>& edge) {\n  s >> edge.from >> edge.to >> edge.cost;\n  return s;\n}\n\ntemplate<typename Cost> ostream& operator<<(ostream& s, const FullEdge<WeightedEdge<Cost>>& edge) {\n  s << '(' << edge.from << ',' << edge.to << ',' << edge.cost << ')';\n  return s;\n}\n\ntemplate<typename Capacity> struct ResidualEdge : public Edge {\n  using CapacityType = Capacity;\n  Capacity cap;\n  int rev;\n  ResidualEdge(int to = -1, Capacity cap = 0) : Edge(to), cap(cap) {}\n  ResidualEdge reverse(int from) const {return ResidualEdge(from, 0);}\n};\n\ntemplate<typename Capacity, typename Cost> struct WeightedResidualEdge : public ResidualEdge<Capacity> {\n  Cost cost;\n  WeightedResidualEdge(int to = -1, Capacity cap = 0, Cost cost = 0) : ResidualEdge<Capacity>(to, cap), cost(cost) {}\n  WeightedResidualEdge reverse(int from) const {return WeightedResidualEdge(from, 0, -cost);}\n};\n\nint main() {\n  int n;\n  cin >> n;\n  map<int64_t, int> d;\n  for (int i = 0; i < n; ++i) {\n    int64_t a;\n    cin >> a;\n    d[a] = i;\n  }\n  vector<int> k(n, 1);\n  Tree<Edge> tree(n);\n  auto itr = d.rbegin();\n  for (int i = 0; i < n - 1; ++i, ++itr) {\n    auto c = itr->first - n + 2 * k[itr->second];\n    auto next = d.find(c);\n    if (next == d.end() || next->second == itr->second) {\n      cout << -1 << endl;\n      return 0;\n    }\n    k[next->second] += k[itr->second];\n    tree.addEdge(itr->second, next->second);\n  }\n  auto dis = bfsDistance(tree, d.begin()->second);\n  int64_t c = 0;\n  for (int i = 0; i < n; ++i) c += dis.dis[i];\n  if (c != d.begin()->first) {\n    cout << -1 << endl;\n  } else {\n    for (int v = 0; v < n; ++v) {\n      for (int u : tree.children[v]) cout << v + 1 << \" \" << u + 1 << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid err() {\n  cout << -1 << endl;\n  exit(0);\n}\nvoid dfs (int crr, int dpt, vector<vector<int>>& grh, long long& cnt) {\n  cnt += dpt;\n  for (int nxt : grh[crr]) {\n    dfs(nxt, dpt + 1, grh, cnt);\n  }\n}\nint main() {\n  int n;\n  cin >> n;\n  vector<long long> d(n);\n  map<long long, int> mp;\n  for (int i = 0; i < n; i++) {\n    cin >> d[i];\n    mp[d[i]] = i;\n  }\n  sort(d.begin(), d.end());\n  vector<long long> sz(n, 1);\n  vector<vector<int>> grh(n);\n  for (auto it = d.rbegin(); next(it) != d.rend(); it++) {\n    auto i = mp[*it];\n    long long ptv = *it - n + 2 * sz[i];\n    auto jt = lower_bound(d.begin(), d.end(), ptv);\n    if (jt == d.end() || *jt != ptv) err();\n    auto p = mp[*jt];\n    grh[p].push_back(i);\n    sz[p] += sz[i];\n  }\n  long long cnt = 0;\n  int rt = mp[d[0]];\n  dfs(rt, 0, grh, cnt);\n  if (d[0] != cnt) err();\n  for (int crr = 0; crr < n; crr++) {\n    for (int nxt : grh[crr]) {\n      cout << crr + 1 << ' ' << nxt + 1 << endl;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define EPS 1e-10\n#define setNil(x) memset((x),0,sizeof(x))\n#define setINF(x) memset((x),63,sizeof(x))\n#define setNegINF(x) memset((x),192,sizeof(x)) //NegINF=-INF-1\n#define setNeg1(x) memset((x),255,sizeof(x))\n#define D first\n#define ID second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,int> pii;\nconst int N=100005;\nint n,f[N],sz[N];\nll d[N],tot;\npii p[N];\nmap<ll,int> mp;\nvector<int> g[N];\nvoid dfs(int x,int p,int dep){\n\ttot+=dep;\n\tfor(int i=0;i<g[x].size();i++){\n\t\tint u=g[x][i];\n\t\tif(u==p)continue;\n\t\tdfs(u,x,dep+1);\n\t}\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>d[i];\n\t\tp[i]=pii(d[i],i);\n\t\tsz[i]=1;\n\t\tmp[d[i]]=i;\n\t}\n\tsort(p+1,p+n+1);\n\tfor(int i=n;i>1;i--){\n\t\tll fs=p[i].D-n+2*sz[p[i].ID];\n\t\tif(!mp[fs] || fs>=p[i].D){\n\t\t\tcout<<\"-1\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tsz[f[p[i].ID]=mp[fs]]+=sz[p[i].ID];\n\t\tg[p[i].ID].push_back(f[p[i].ID]);\n\t\tg[f[p[i].ID]].push_back(p[i].ID);\n\t}\n\tdfs(p[1].ID,0,0);\n\tif(tot!=p[1].D)cout<<\"-1\\n\";\n\telse for(int i=n;i>1;i--)cout<<f[p[i].ID]<<' '<<p[i].ID<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+10;\nstruct edge{int v,nxt;}e[maxn<<1];\nint head[maxn],ecnt=0;\nvoid add(int u,int v)\n{\n\te[++ecnt]=(edge){v,head[u]},head[u]=ecnt;\n\te[++ecnt]=(edge){u,head[v]},head[v]=ecnt;\n}\nstruct data\n{\n\tlong long D;\n\tint id;\n\tbool operator < (const data &b){return D<b.D;}\n}c[maxn];\nint fa[maxn],siz[maxn],n,rt;\nint find(int lim,long long x)\n{\n\tint l=1,r=lim,ans=0;\n\twhile(l<=r)\n\t{\n\t\tint mid=l+r>>1;\n\t\tif(c[mid].D>=x)r=mid-1,ans=mid;\n\t\telse l=mid+1;\n\t}\n//\tcout<<c[ans].D<<endl;\n//\tif(c[ans].D!=x)printf(\"fuckyou\\n\");\n\treturn ans;\n}\nint dep[maxn];\nlong long tot=0;\nvoid dfs(int u,int pre)\n{\n\tdep[u]=dep[pre]+1;\n\ttot+=dep[u]-1;\n\tfor(int i=head[u];~i;i=e[i].nxt)\n\t{\n\t\tint v=e[i].v;\n\t\tif(v==pre)continue;\n\t\tdfs(v,u);\n\t}\n}\nint main()\n{\n\tmemset(head,-1,sizeof(head));\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&c[i].D),c[i].id=i;\n\tsort(c+1,c+1+n);\n\tfor(int i=n;i>=2;i--)\n\t{\n\t\tsiz[i]++;\n\t\tint p=find(i-1,c[i].D-(n-2*1LL*siz[i]));\n\t\tif(c[i].D-(n-2*1LL*siz[i])!=c[p].D)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[p]+=siz[i];\n\t\tfa[c[i].id]=c[p].id;\n\t}\n\tfor(int i=1;i<=n;i++)\n\tif(fa[i])add(fa[i],i);\n\telse rt=i;\n\tdfs(rt,0);\n\tif(tot!=c[1].D)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)if(fa[i])printf(\"%d %d\\n\",fa[i],i);\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <set>\n#include <map>\nusing namespace std;\nint n;\n/*int a[100020];\nint b[100020];*/\npair<long long, int> d[100200];\nmap<long long, int> mp;\nvector<int> ed[100200];\nint sz[100200];\nlong long f[100200];\nint par[100200];\nvoid bad() {\n    cout << \"-1\\n\";\n    exit(0);\n}\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> d[i].first;\n        d[i].second = i;\n    }\n    vector<pair<int, int> > ans;\n    sort(d + 1, d + n + 1);\n    for (int i = 1; i <= n; i++) mp[d[i].first] = i;\n\n    for (int i = n; i > 1; i--) {\n        sz[i]++;\n        long long x = d[i].first - (n - 2 * sz[i]);\n        if (mp[x] == 0) bad();\n        else {\n            sz[mp[x]] += sz[i];\n            ans.push_back(make_pair(d[i].second, d[mp[x]].second));\n            f[mp[x]] += f[i] + sz[i];\n        }\n        if (sz[i] > n) bad();\n    }\n    sz[1]++;\n    if (sz[1] != n) bad();\n    if (f[1] != d[1].first) bad();\n    //check(ans);\n    for (auto it: ans) cout << it.first << \" \" << it.second << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC optimize(2)\n// #pragma G++ optimize(2)\n// #pragma comment(linker,\"/STACK:102400000,102400000\")\n\n// #include <bits/stdc++.h>\n#include <map>\n#include <set>\n#include <list>\n#include <array>\n#include <cfenv>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <mutex>\n#include <queue>\n#include <ratio>\n#include <regex>\n#include <stack>\n#include <tuple>\n#include <atomic>\n#include <bitset>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <chrono>\n#include <cstdio>\n#include <cwchar>\n#include <future>\n#include <limits>\n#include <locale>\n#include <memory>\n#include <random>\n#include <string>\n#include <thread>\n#include <vector>\n#include <cassert>\n#include <climits>\n#include <clocale>\n#include <complex>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <ctgmath>\n#include <cwctype>\n#include <fstream>\n#include <iomanip>\n#include <numeric>\n#include <sstream>\n#include <ccomplex>\n#include <cstdbool>\n#include <iostream>\n#include <typeinfo>\n#include <valarray>\n#include <algorithm>\n#include <cinttypes>\n#include <cstdalign>\n#include <stdexcept>\n#include <typeindex>\n#include <functional>\n#include <forward_list>\n#include <system_error>\n#include <unordered_map>\n#include <unordered_set>\n#include <scoped_allocator>\n#include <condition_variable>\n// #include <conio.h>\n// #include <windows.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef float fl;\ntypedef double ld;\ntypedef long double LD;\ntypedef pair<int,int> pii;\n#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)\n#define lld \"%I64d\"\n#define llu \"%I64u\"\n#else\n#define lld \"%lld\"\n#define llu \"%llu\"\n#endif\n#define ui(n) ((unsigned int)(n))\n#define LL(n) ((long long)(n))\n#define ull(n) ((unsigned long long)(n))\n#define fl(n) ((float)(n))\n#define ld(n) ((double)(n))\n#define LD(n) ((long double)(n))\n#define char(n) ((char)(n))\n#define Bool(n) ((bool)(n))\n#define fixpoint(n) fixed<<setprecision(n)\n\nconst int INF=1061109567;\nconst int NINF=-1044266559;\nconst LL LINF=4557430888798830399;\nconst ld eps=1e-15;\n#define MOD (1000000007)\n#define PI (3.1415926535897932384626433832795028841971)\n\n/*\n#define MB_LEN_MAX 5\n#define SHRT_MIN (-32768)\n#define SHRT_MAX 32767\n#define USHRT_MAX 0xffffU\n#define INT_MIN (-2147483647 - 1)\n#define INT_MAX 2147483647\n#define UINT_MAX 0xffffffffU\n#define LONG_MIN (-2147483647L - 1)\n#define LONG_MAX 2147483647L\n#define ULONG_MAX 0xffffffffUL\n#define LLONG_MAX 9223372036854775807ll\n#define LLONG_MIN (-9223372036854775807ll - 1)\n#define ULLONG_MAX 0xffffffffffffffffull\n*/\n\n#define MP make_pair\n#define MT make_tuple\n#define All(a) (a).begin(),(a).end()\n#define pall(a) (a).rbegin(),(a).rend()\n#define log2(x) log(x)/log(2)\n#define Log(x,y) log(x)/log(y)\n#define sz(a) ((int)(a).size())\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define rep1(i,n) for(int i=1;i<=((int)(n));i++)\n#define repa(i,a,n) for(int i=((int)(a));i<((int)(n));i++)\n#define repa1(i,a,n) for(int i=((int)(a));i<=((int)(n));i++)\n#define repd(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define repd1(i,n) for(int i=((int)(n));i>=1;i--)\n#define repda(i,n,a) for(int i=((int)(n));i>((int)(a));i--)\n#define repda1(i,n,a) for(int i=((int)(n));i>=((int)(a));i--)\n#define FOR(i,a,n,step) for(int i=((int)(a));i<((int)(n));i+=((int)(step)))\n#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)\n#define repV(i,v) for(auto i:v)\n#define repE(i,v) for(auto &i:v)\n#define MS(x,y) memset(x,y,sizeof(x))\n#define MC(x) MS(x,0)\n#define MINF(x) MS(x,63)\n#define MCP(x,y) memcpy(x,y,sizeof(y))\n#define sqr(x) ((x)*(x))\n#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())\n#define filein(x) freopen(x,\"r\",stdin)\n#define fileout(x) freopen(x,\"w\",stdout)\n#define fileio(x)\\\n\tfreopen(x\".in\",\"r\",stdin);\\\n\tfreopen(x\".out\",\"w\",stdout)\n#define filein2(filename,name) ifstream name(filename,ios::in)\n#define fileout2(filename,name) ofstream name(filename,ios::out)\n#define file(filename,name) fstream name(filename,ios::in|ios::out)\n#define Pause system(\"pause\")\n#define Cls system(\"cls\")\n#define fs first\n#define sc second\n#define PC(x) putchar(x)\n#define GC(x) x=getchar()\n#define Endl PC('\\n')\n#define SF scanf\n#define PF printf\n\ninline int Read()\n{\n    int X=0,w=0;char ch=0;while(!isdigit(ch)){w|=ch=='-';ch=getchar();}while(isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();\n\treturn w?-X:X;\n}\ninline void Write(int x){if(x<0)putchar('-'),x=-x;if(x>9)Write(x/10);putchar(x%10+'0');}\n\ninline LL powmod(LL a,LL b){LL RES=1;a%=MOD;assert(b>=0);for(;b;b>>=1){if(b&1)RES=RES*a%MOD;a=a*a%MOD;}return RES%MOD;}\ninline LL gcdll(LL a,LL b){return b?gcdll(b,a%b):a;}\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={1,0,-1,0,-1,-1,1,1};\n/************************************************************Begin************************************************************/\nconst int maxn=100010;\n\nint n;\nLL a[maxn];\n\nint main()\n{\n\tPF(\"-1\");\n\n\treturn 0;\n}\n/*************************************************************End**************************************************************/"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define re register\n#define ll long long\ninline int gi()\n{\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=100010;\ntypedef pair<ll,int> pli;typedef pair<int,int> pii;\n#define mp make_pair\npli p[N];int n,siz[N];\nvector<pii>ans;\nint main()\n{\n\tn=gi();\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&p[i].first),p[i].second=i,siz[i]=1;\n\tsort(p+1,p+n+1);ll dis=0;\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tll nd=p[i].first-(n-siz[p[i].second])+siz[p[i].second];\n\t\tint pos=lower_bound(p+1,p+n+1,mp(nd,0))-p;\n\t\tif(p[pos].first!=nd)return puts(\"-1\")&1;\n\t\tans.push_back(mp(p[pos].second,p[i].second));\n\t\tsiz[p[pos].second]+=siz[p[i].second];dis+=siz[p[i].second];\n\t}\n\tif(dis!=p[1].first)return puts(\"-1\")&1;\n\tfor(pii now:ans)printf(\"%d %d\\n\",now.first,now.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <map>\nusing namespace std;\ntypedef long long LL;\nconst int N=100000+10;\nint n,sz[N]; \npair<int,LL> d[N];\nvector<int> g[N];\nbool cmp(pair<int,LL> p1,pair<int,LL> p2){\n    return p1.second>p2.second;\n}\nmap<LL,int> mp;\nvoid prt(int u,int p){\n    for(auto v:g[u]){\n        if(v==p)continue;\n        printf(\"%d %d\\n\", u,v);\n        prt(v,u);\n    }\n}\nint main() {\n    scanf(\"%d\",&n); \n    for(int i=1;i<=n;i++){\n        d[i].first=i; \n        scanf(\"%lld\",&d[i].second);\n        mp[d[i].second]=i;\n        sz[i]=1;\n    }\n    sort(d+1,d+1+n,cmp);\n    for(int i=1;i<n;i++){\n        LL tmp=d[i].second;\n        LL nex=tmp-(n-2*sz[d[i].first]);\n        if(mp[nex]==0||nex>=tmp)return !printf(\"-1\\n\");\n        int u=mp[nex];\n        int v=d[i].first;\n        g[u].push_back(v); g[v].push_back(u);\n        sz[u]+=sz[v];\n    }\n    prt(1,1);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ntypedef long long ll;\n\nll read() {\n\tchar ch;\n\tfor(ch=getchar();ch<'0'||ch>'9';ch=getchar());\n\tll x=ch-'0';\n\tfor(ch=getchar();ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\nconst int N=1e5+5;\n\nint n,fa[N],ord[N],sz[N];\nll d[N],sum;\nvector<int> son[N];\nmap<ll,int> id;\n\nvoid dfs(int x,int d) {\n\tsum+=d;\n\tfor(int y:son[x]) dfs(y,d+1);\n}\n\nbool cmp(int x,int y) {return d[x]<d[y];}\n\nint main() {\n\tn=read();\n\tfo(i,1,n) d[i]=read(),ord[i]=i,sz[i]=1;\n\tsort(ord+1,ord+n+1,cmp);\n\tfo(i,1,n) id[d[ord[i]]]=i;\n\tfd(i,n,2) {\n\t\tint x=ord[i];\n\t\tll s=d[x]-n+2*sz[x];\n\t\tif (!id.count(s)) {puts(\"-1\");return 0;}\n\t\tint y=id[s];\n\t\tif (y>=i) {puts(\"-1\");return 0;}\n\t\tfa[x]=ord[y];sz[ord[y]]+=sz[x];\n\t\tson[ord[y]].push_back(x);\n\t}\n\tdfs(ord[1],0);\n\tif (sum!=d[ord[1]]) {puts(\"-1\");return 0;}\n\tfo(i,1,n) if (fa[i]) printf(\"%d %d\\n\",i,fa[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pii pair<int, int>\n#define F first\n#define S second\n#define int int_fast64_t\nusing namespace std;\nconst int MX = 1e5 + 100;\nint sz[MX];\npii v[MX];\nvector<int> G[MX];\nmain () {\n    int n; cin >> n;\n    for(int i = 1; i <= n; i ++) cin >> v[i].F, v[i].S = i;\n    sort(v + 1, v + 1 + n);\n    unordered_map<int, int> mp;\n    for(int i = 1; i <= n; i ++) mp[v[i].F] = v[i].S, sz[i] = 1;\n    for(int i = n; i > 1; i --) {\n        int ptr = v[i].F - (n - sz[v[i].S]) + sz[v[i].S];\n        if(ptr >= v[i].F or !mp[ptr]) return cout << -1, 0;\n        G[mp[ptr]].push_back(v[i].S);\n        sz[mp[ptr]] += sz[v[i].S];\n    }\n    for(int i = 1; i <= n; i ++) {\n        for(auto it: G[i]) cout << i << ' ' << it << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n\n#define LOG(...) fprintf (stderr, __VA_ARGS__)\n#define pb push_back\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n\nconst int INF = 0x3f3f3f3f, N = 100005;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fll;\n\nint n, sz[N];\npair <LL, int> d[N];\nbool cmp(pair <LL, int> a, pair <LL, int> b) { return a.first > b.first; }\nmap <int, int> mp;\nvector <int> g[N];\nvoid link(int x, int y){\n    g[x].push_back(y);\n//    g[y].push_back(x); \n}\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) scanf(\"%lld\", &d[i].first), d[i].second = i, mp[d[i].first] = i; \n\n    sort (d + 1, d + n + 1, cmp);\n    int root = d[n].second;\n    for (int i = 1; i <= n; i++) sz[i] = 1; \n    for (int i = 1; i < n; i++) {\n    //    cout << \"now considering \" << d[i].second << endl; \n        int fa = d[i].first - n + 2 * sz[d[i].second];\n    //    cout << \"fa = \" << fa << endl; \n        if (mp[fa]) {\n            int ff = mp[fa];\n            if (ff == d[i].second) return 0*puts(\"-1\");\n        //    cout << \"ff = \" << ff << endl; \n            sz[ff] += sz[d[i].second]; link(ff, d[i].second); \n        }\n        else return 0*puts(\"-1\");\n    }\n\n    for(int i = 1; i <= n; i++)\n        for (int j = 0; j < g[i].size(); j++)\n            cout << i << \" \" << g[i][j] << endl; \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// type\ntypedef long long ll;\ntypedef long double ld;\n// loop\n//#define For(i, l, r, x)     for (int i = l; i < r; i+=x)\n//#define ForE(i, l, r, x)    for (int i = l; i <= r; i+=x)\n//#define Ford(i, r, l)       for (int i = r; i > l; i--)\n//#define FordE(i, r, l)      for (int i = r; i >= l; i--)\n//#define Fora(i, a)          for (auto i : a)\n// I/O\n#define FAST_IO             std::ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n//#define PrintV(a)           Fora(ii, a) cout << ii << ' '; cout << rl;\n//#define PrintVl(a)          Fora(ii, a) cout << ii << rl;\n//#define PrintA(a, l, r)     for (int ii = l; ii <= r; ii++) cout << a[ii] << ' '; cout << rl;\n//#define PrintAl(a, l, r)    for (int ii = l; ii <= r; ii++) cout << a[ii] << rl;\n//#define Ptest(x)            return cout << x, 0;\n#define setpre(n)           fixed << setprecision(n)\n// pair\n#define F                   first\n#define S                   second\n#define pii                 pair<int, int>\n#define pll                 pair<ll, ll>\n#define pdd                 pair<ld, ld>\n// vector & !!?(string)\n#define eb                  emplace_back\n#define pb                  push_back\n#define all(a)              a.begin(), a.end()\n#define rall(a)             a.rbegin(), a.rend()\n#define sz(a)               a.size()\n#define len(a)              a.length()\n// geometry calc\n#define pi                  acos(-1.0)\n#define g_sin(a)            sin(a*pi/180)\n#define g_cos(a)            cos(a*pi/180)\n#define g_tan(a)            tan(a*pi/180)\n// set val\n#define ms0(a)              memset(a,        0, sizeof(a));\n#define ms1(a)              memset(a,        1, sizeof(a));\n#define msn1(a)             memset(a,       -1, sizeof(a));\n#define msinf(a)            memset(a, 0x3f3f3f, sizeof(a));\n// constant\nconst int mod1 = 998244353, mod = 1e9+7;\nconst int MAXN = 1e5 + 5, MAX_M = 2e5 + 5;\n// code\n#define int long long\n\nint d[MAXN], pos[MAXN], n;\nint par[MAXN], sz[MAXN], subd[MAXN];\nmap<int, int> orc;\n\nbool comp(const int &a, const int &b){\n    return d[a] > d[b];\n}\n\nvoid Solve() {\n    cin >> n;\n    for (int i = 1; i <= n; i++){\n        cin >> d[i]; pos[i] = i;\n        orc[d[i]] = i;\n    }\n    sort(pos+1, pos+n+1, comp);\n    // root at pos[n];\n    for (int i = 1; i < n; i++){\n        sz[pos[i]] ++;\n        int parD = d[pos[i]] - n + 2*sz[pos[i]];\n        if (parD >= d[pos[i]] || !orc.count(parD)){\n            cout << \"-1\";\n            return;\n        }\n        par[pos[i]] = orc[parD];\n        sz[par[pos[i]]] += sz[pos[i]];\n        // dist on subtree\n        subd[par[pos[i]]] += subd[pos[i]] + sz[pos[i]];\n    }\n    if (subd[pos[n]] != d[pos[n]]){\n        cout << -1;\n        return;\n    }\n    for (int i = 1; i < n; i++){\n        cout << pos[i] << ' ' << par[pos[i]] << endl;\n    }\n}\n\nsigned main(){\n    FAST_IO;\n    int TC = 1;\n\t//cin >> TC;\n    while(TC--) Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair <ll, int> pli;\n\nconst int N = 1e5 + 10;\nint n, cnt[N], par[N], mark[N];\nll sum[N];\npli ar[N];\nunordered_map <ll, int> mp;\nvector <int> ch[N];\n\nvoid dfs(int v) {\n\tmark[v] = 1;\n\tfor (int i : ch[v]) {\n\t\tdfs(i);\n\t\tsum[v] += sum[i] + cnt[i];\n\t}\n}\n\nint32_t main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tfill(cnt, cnt + N, 1);\n\t\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> ar[i].first;\n\t\tar[i].second = i;\n\t\tmp[ar[i].first] = i;\n\t}\n\tsort(ar, ar + n);\n\t\n\tfor (int i = n - 1; i > 0; i--) {\n\t\tint v = ar[i].second;\n\t\tll nd = ar[i].first - n + (ll)2 * cnt[v];\n\t\tif (mp.find(nd) == mp.end() || 2 * cnt[v] > n)\n\t\t\treturn cout << -1, 0;\n\t\t\n\t\tint p = mp[nd];\n\t\tch[p].push_back(v);\n\t\tpar[v] = p;\n\t\tcnt[p] += cnt[v];\n\t}\n\t\n\tdfs(ar[0].second);\n\tif (sum[ar[0].second] != ar[0].first)\n\t\treturn cout << -1, 0;\n\t\n\tfor (int i = 0; i < n; i++)\n\t\tif (!mark[i])\n\t\t\treturn cout << -1, 0;\n\t\n\tfor (int i = 0; i < n; i++)\n\t\tif (i != ar[0].second)\n\t\t\tcout << i + 1 << \" \" << par[i] + 1 << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#include <functional>\n#include <bitset>\n\n#define repeat(i,n) for (long long i = 0; (i) < (n); ++ (i))\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i] << '\\n'\n#define debugArrayP(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i].first<< \" \" << x[i].second << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\nconst ll INF = LLONG_MAX/10;\nconst ll MOD = 1e9+7;\n\nint main(){\n  cout << -1 << endl;\n  return 0;\n  int N;cin>>N;\n  vector<Pii> D(N);\n  repeat(i,N){\n    cin >> D[i].first;\n    D[i].second = i+1;\n  }\n  sort(D.begin(),D.end());\n  vll n(N,1);\n  vector<Pii> edges;\n  bool isok = true;\n  for(int i=N-1;i>0;i--){\n    debug(i);\n    ll S = D[i].first+2*n[i]-N;\n    int j = lower_bound(D.begin(),D.end(),Pii(S,0))-D.begin();\n    if(j>=i || D[j].first != S){\n      isok = false;\n      break;\n    }\n    edges.push_back({D[i].second,D[j].second});\n    n[j]+=n[i];\n  }\n  if(!isok){\n    cout <<-1<<endl;\n    return 0;\n  }\n  repeat(i,edges.size()){\n    cout << edges[i].first<<\" \"<<edges[i].second<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/// IN THE NAME OF METAL\n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long int ll;\ntypedef pair<ll, ll> pll;\n \n#define sz(x)                       (ll) x.size()\n#define all(x)                      (x).begin(),(x).end()\n#define F                           first\n#define S                           second\n\nll Pow(ll a, ll b, ll md, ll ans = 1) {\n    for (; b; b >>= 1, a = a * a % md)\n        if (b & 1)\n            ans = ans * a % md;\n    return ans % md;\n}\nconst ll MAXN = 1e5 + 10;\nconst ll INF = 8e18;\nconst ll MOD = 1e9 + 7;\nll Sz[MAXN], H[MAXN], n;\npll D[MAXN]; vector<ll> adj[MAXN]; map<ll, ll> pos;\n\nvoid DFS(ll v, ll p = -1) {\n    for (ll u : adj[v]) {\n        H[u] = H[v] + 1;\n        DFS(u, v);\n    }\n}\n\nint main() {\n    scanf(\"%lld\", &n);\n    for (ll i = 1; i <= n; i++) {\n        scanf(\"%lld\", &D[i].F);\n        D[i].S = i;\n        pos[D[i].F] = i;\n    }\n    sort(D + 1, D + n + 1, greater<pll>());\n    for (ll i = 1; i <= n - 1; i++) {\n        ll v = D[i].S;\n        pos.erase(D[i].S);\n        Sz[v] = 1;\n        for (ll u : adj[v]) {\n            Sz[v] += Sz[u];\n        }\n        if (pos.find(D[i].F - n + 2 * Sz[v]) == pos.end()) break;\n        ll par = pos[D[i].F - n + 2 * Sz[v]];\n        adj[par].push_back(v);\n    }\n    DFS(D[n].S);\n    if (accumulate(H, H + MAXN, 0LL) != D[n].F) printf(\"-1\\n\");\n    else {\n        for (ll i = 1; i <= n; i++) {\n            for (ll u : adj[i]) printf(\"%lld %lld\\n\", i, u);\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100010;\ntypedef long long int64;\n\nmap<int64 , int> val;\nint n , size[N] , fa[N];\nbool vis[N];\n\nint64 d[N];\ntypedef pair<int64 , int> pii;\npriority_queue<pii> leaf;\n#define mp make_pair \n\nint main() {\n    cin >> n;\n    for(int i = 1 ; i <= n ; ++i) {\n        cin >> d[i];\n        size[i] = 1;\n        val[d[i]] = i; \n    }\n    for(int i = 1 ; i <= n ; ++i) \n        if(val.count(d[i] - n + 2)) leaf.push(mp(d[i] , i));\n\n    int cnt = 0;\n    while(leaf.size()) {\n        int x = leaf.top().second;\n        leaf.pop();\n\n\t\tval.erase(d[x]);\n        if(val.count(d[x] - n + size[x]*2))\n            fa[x] = val[d[x] - n + size[x]*2];\n        else continue;\n        \n        cnt++;\n        \n        size[fa[x]] += size[x];\n        if(!vis[fa[x]]) leaf.push(mp(d[fa[x]] , fa[x])),  vis[fa[x]] = 1;\n    }\n    if(cnt < n - 1) cout << -1 << endl;\n    else {\n        for(int i = 1 ; i <= n ; ++i)\n            if(fa[i]) cout << i << ' ' << fa[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst int MAXN = 200010;\nconst LL INF = 2147483600;\n\nstruct dat{\n\tLL id,val;\n}a[MAXN+1]; LL N;\nbool cmpval(dat a,dat b){\n\treturn a.val>b.val;\n}\nLL Node[MAXN<<1],Next[MAXN<<1],Root[MAXN+1],cnt;\ninline void insert(LL u,LL v){\n\tNode[++cnt]=v; Next[cnt]=Root[u]; Root[u]=cnt; return ;\n} LL sz[MAXN+1],f[MAXN+1],b[MAXN+1];\ninline void dfs(LL k,LL Fa){\n\tsz[k]=1;\n\tfor(LL x=Root[k];x;x=Next[x]){\n\t\tLL v=Node[x]; if(v==Fa) continue;\n\t\tdfs(v,k); sz[k]+=sz[v]; f[1]+=sz[v];\n\t} return ;\n}\ninline void dfs2(LL k,LL Fa){\n\tif(f[k]!=b[k]){ puts(\"-1\"); exit(0); }\n\tfor(LL x=Root[k];x;x=Next[x]){\n\t\tLL v=Node[x]; if(v==Fa) continue;\n\t\tf[v]=f[k]+N-2*sz[v]; dfs2(v,k);\n\t} return ;\n} LL s1[MAXN+1],s2[MAXN+1],top;\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tN=read();\n\tfor(LL i=1;i<=N;i++){\n\t\ta[i].id=i; a[i].val=read(); b[i]=a[i].val;\n\t} sort(a+1,a+N+1,cmpval);\n\tfor(LL i=1;i<=N;i++) sz[i]=1;\n\tfor(LL i=1;i<N;i++){\n\t\tLL val=a[i].val-N+2*sz[i]; \n\t\tLL l=i+1,r=N,pos=-1;\n\t\twhile(l<=r){\n\t\t\tLL mid=(l+r)>>1;\n\t\t\tif(a[mid].val>=val) pos=mid,l=mid+1;\n\t\t\telse r=mid-1;\n\t\t} if(pos==-1||a[pos].val!=val){\n\t\t\tputs(\"-1\"); return 0;\n\t\t} sz[pos]+=sz[i];\n\t\ts1[++top]=a[i].id; s2[top]=a[pos].id;\n\t\tinsert(a[i].id,a[pos].id);\n\t\tinsert(a[pos].id,a[i].id);\n\t\t//sz=N+a[fa]-a[i].val\n\t} dfs(1,0); dfs2(1,0);\n\tfor(LL i=1;i<=top;i++) printf(\"%lld %lld\\n\",s1[i],s2[i]); \n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pii pair<int, int>\n#define F first\n#define S second\n#define int int_fast64_t\nusing namespace std;\nconst int MX = 1e5 + 100;\nint sz[MX], dst[MX];\npii v[MX];\nvector<int> G[MX];\nmain () {\n    ifstream fin; fin.open(\"33.txt\");\n    #define cin fin\n    int n; cin >> n;\n    for(int i = 1; i <= n; i ++) cin >> v[i].F, v[i].S = i;\n    sort(v + 1, v + 1 + n);\n    unordered_map<int, int> mp;\n    for(int i = 1; i <= n; i ++) mp[v[i].F] = v[i].S, sz[i] = 1;\n    for(int i = n; i > 1; i --) {\n        int ptr = v[i].F - (n - sz[v[i].S]) + sz[v[i].S];\n        if(ptr >= v[i].F or !mp[ptr]) return cout << -1, 0;\n        int pp = mp[ptr];\n        G[pp].push_back(v[i].S);\n        sz[pp] += sz[v[i].S];\n        dst[pp] += dst[v[i].S] + sz[v[i].S];\n    }\n    if(dst[v[1].S] != v[1].F) return cout << -1, 0; \n    for(int i = 1; i <= n; i ++) {\n        for(auto it: G[i]) cout << i << ' ' << it << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100010;\n\ntypedef long long LL;\n\nLL D[N]; int id[N], sz[N];\nmap<LL, int> mp;\n\ninline void Fuck() {\n\tputs(\"-1\"), exit(0);\n}\n\nvector<int> G[N];\n\ninline void adde(int from, int to) {\n\tG[from].push_back(to), G[to].push_back(from);\n}\n\nLL dfs(int u, int f) {\n\tLL res = 0;\n\tfor (auto v : G[u]) if (v != f) \n\t\tres += dfs(v, u) + sz[v];\n\treturn res;\n}\n\nint main() {\n\tint n; scanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", &D[i]), mp[D[i]] = i, sz[i] = 1, id[i] = i;\n\tsort(id + 1, id + n + 1, [](int a, int b){return D[a] > D[b];});\n\tfor (int i = 1; i < n; i++) {\n\t\tint v = id[i];\n\t\tLL tmp = D[v] - n + sz[v] * 2;\n\t\tif (!mp.count(tmp) || tmp >= D[v]) Fuck();\n\t\tadde(v, mp[tmp]), sz[mp[tmp]] += sz[v];\n\t}\n\tif (dfs(id[n], 0) != D[id[n]]) Fuck();\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (auto v : G[i]) if (v > i) printf(\"%d %d\\n\", i, v);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nnamespace IO\n{\n    const int __S=(1<<20)+5;char __buf[__S],*__H,*__T;\n    inline char getc()\n    {\n        if(__H==__T) __T=(__H=__buf)+fread(__buf,1,__S,stdin);\n        if(__H==__T) return -1;return *__H++;\n    }\n    template <class __I>inline void read(__I &__x)\n    {\n        __x=0;int __fg=1;char __c=getc();\n        while(!isdigit(__c)&&__c!='-') __c=getc();\n        if(__c=='-') __fg=-1,__c=getc();\n        while(isdigit(__c)) __x=__x*10+__c-'0',__c=getc();\n        __x*=__fg;\n    }\n    inline void readd(double &__x)\n    {\n        __x=0;double __fg=1.0;char __c=getc();\n        while(!isdigit(__c)&&__c!='-') __c=getc();\n        if(__c=='-') __fg=-1.0,__c=getc();\n        while(isdigit(__c)) __x=__x*10.0+__c-'0',__c=getc();\n        if(__c!='.'){__x=__x*__fg;return;}else __c=getc();\n        double __t=1e-1;while(isdigit(__c)) __x=__x+1.0*(__c-'0')*__t,__t=__t*0.1,__c=getc();\n        __x=__x*__fg;\n    }\n    inline void reads(char *__s,int __x)\n    {\n        char __c=getc();int __tot=__x-1;\n        while(__c<'a'||__c>'z') __c=getc();\n        while(__c>='a'&&__c<='z') __s[++__tot]=__c,__c=getc();\n        __s[++__tot]='\\0';\n    }\n    char __obuf[__S],*__oS=__obuf,*__oT=__oS+__S-1,__c,__qu[55];int __qr;\n    inline void flush(){fwrite(__obuf,1,__oS-__obuf,stdout);__oS=__obuf;}\n    inline void putc(char __x){*__oS++ =__x;if(__oS==__oT) flush();}\n    template <class __I>inline void print(__I __x)\n    {\n        if(!__x) putc('0');\n        if(__x<0) putc('-'),__x=-__x;\n        while(__x) __qu[++__qr]=__x%10+'0',__x/=10;\n        while(__qr) putc(__qu[__qr--]);\n    }\n    inline void prints(const char *__s,const int __x)\n    {\n        int __len=strlen(__s+__x);\n        for(int __i=__x;__i<__len+__x;__i++) putc(__s[__i]);\n    }\n    inline void printd(long double __x,int __d)\n    {\n        long long __t=(long long)floor(__x);print(__t);putc('.');__x-=(double)__t;\n        while(__d--)\n        {\n            long double __y=__x*10.0;__x*=10.0;\n            int __c=(int)floor(__y+1e-9);if(__c==10) __c--;\n            putc(__c+'0');__x-=floor(__y);\n        }\n    }\n    inline void el(){putc('\\n');}inline void sp(){putc(' ');}\n}using namespace IO;\nstruct nod{ll num,dis;}a[100010];\nll ans,n,sz[100010],fa[100010],d[100010],dep[100010];vector<ll>son[100010];\nbool cmp(nod l,nod r){return l.dis<r.dis;}\nvoid dfs(ll u,ll f){ll i;dep[u]=dep[f]+1;for(auto v:son[u]){if(v!=f) dfs(v,u);}}\nint main()\n{\n\tread(n);ll i;for(i=1;i<=n;i++) read(a[i].dis),a[i].num=i;sort(a+1,a+n+1,cmp);for(i=1;i<=n;i++) d[i]=a[i].dis;\n\tfor(i=n;i>=2;i--)\n\t{\n\t\tsz[a[i].num]++;ll tmp=d[i]-(n-2*sz[a[i].num]),pos=lower_bound(d+1,d+i,tmp)-d;\n\t\tif(pos>=i||d[pos]!=tmp){puts(\"-1\");return 0;}\n\t\tsz[a[pos].num]+=sz[a[i].num];fa[a[i].num]=a[pos].num;\n\t}\n\tfor(i=1;i<=n;i++) if(fa[i]) son[fa[i]].push_back(i);\n\tdep[0]=-1;dfs(a[1].num,0);for(i=1;i<=n;i++) ans+=dep[i];\n\tif(ans!=d[1]){puts(\"-1\");return 0;}\n\tfor(i=1;i<=n;i++) if(fa[i]) cout<<i<<' '<<fa[i]<<'\\n';\n\tflush();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint T,n,a[100001],dep[100001],ma,head[400001],to[400001],nxt[400001],cnt;\nvoid add(int u,int v){\n\tnxt[++cnt]=head[u];\n\tto[cnt]=v;\n\thead[u]=cnt;\n}\nvoid dfs(int fa,int u){\n\tfor(int i=head[u];i;i=nxt[i]){\n\t\tif(to[i]==fa)continue;\n\t\tdep[to[i]]=dep[u]+1;\n\t\tdfs(u,to[i]);\n\t}\n}\nint main(){\n\tcin>>T;\n\twhile(T--){\n\t\tmemset(nxt,0,sizeof(nxt));\n\t\tmemset(head,0,sizeof(head));\n\t\tscanf(\"%d\",&n);\n\t\tma=0;\n\t\tcnt=0;\n\t\tfor(int u,i=2;i<=n;i++){\n\t\t\tscanf(\"%d\",&u);\n\t\t\tadd(u,i);\n\t\t\tadd(i,u);\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(\"%d\",&a[i]);\n\t\t\ta[i]+=i;\n\t\t}\n\t\tdep[1]=0;\n\t\tdfs(0,1);\n\t\tsort(dep+1,dep+n+1);\n\t\tsort(a+1,a+n+1);\n\t\tfor(int i=1;i<=n;i++)ma=max(ma,dep[i]+a[n+1-i]);\n\t\tprintf(\"%d\\n\",ma);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nll D[101010];\npair<ll,int> P[101010];\nint num[101010],par[101010];\nvector<pair<int,int>> E;\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>D[i];\n\t\tP[i]={D[i],i+1};\n\t}\n\tsort(P,P+N);\n\tsort(D,D+N);\n\t\n\tfor(i=N-1;i>=1;i--) {\n\t\tnum[i]++;\n\t\tll sj=D[i]+2*num[i]-N;\n\t\tx=lower_bound(D,D+N,sj)-D;\n\t\tif(x>=i || D[x]!=sj) return _P(\"-1\\n\");\n\t\tE.push_back({x,i});\n\t\tnum[x]+=num[i];\n\t\tpar[i]=x;\n\t}\n\t return _P(\"-1\\n\");\n\tFORR(e,E) cout<<P[e.first].second<<\" \"<<P[e.second].second<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\n\ntypedef pair < db, db > pdd;\ntypedef pair < db, ld > pdl;\ntypedef pair < ld, db > pld;\ntypedef pair < ld, ld > ldp;\n\ntypedef pair < ll, ll > pll;\ntypedef pair < int, ll > pil;\ntypedef pair < ll, int > pli;\ntypedef pair < int, int > pii;\n\n#define F first\n#define S second\n\n#define en end()\n#define bg begin()\n\n#define rev reverse\n#define mp make_pair\n#define pb push_back\n\n#define y1 y1234567890\n#define um unordered_map\n\n#define all(x) x.bg, x.en\n#define sz(x) (int)x.size()\n#define len(x) (int)strlen(x)\n\n#define sqr(x) ((x + 0ll) * (x))\n#define sqrd(x) ((x + 0.0) * (x))\n\n#define forn(i, n) for (int i = 1; i <= n; i++)\n\nconst ll inf = (ll)1e18;\nconst ll mod = (ll)1e9 + 7;\n\nconst db eps = (db)1e-9;\nconst db pi = acos(-1.0);\n\nconst int dx[] = {0, 0, 1, 0, -1};\nconst int dy[] = {0, 1, 0, -1, 0};\n\nconst int N = 100500;\n\nint n, p[N], cnt[N];\nvector < int > g[N];\nmap < ll, int > pos;\nll d[N], dp[N], dp1[N];\n\ninline bool cmp(int i, int j) {\n\treturn d[i] < d[j];\n}\n\nvoid dfs(int v, int pr = -1) {\n\tcnt[v] = 1;\n\tfor (auto to : g[v]) {\n\t\tif (to == pr)\n\t\t\tcontinue;\n\t\tdfs(to, v);\n\t\tcnt[v] += cnt[to];\n\t\tdp[v] += dp[to] + cnt[to];\n\t}\n}\n\nvoid dfs1(int v, int pr = -1) {\n\tll sum = 0;\n\tfor (auto to : g[v])\n\t\tif (to != pr)\n\t\t\tsum += dp[to];\n\tfor (auto to : g[v]) {\n\t\tif (to == pr)\n\t\t\tcontinue;\n\t\tdp1[to] = dp1[v] + sum - dp[to] + 2 * (cnt[v] - cnt[to] - 1) + n - cnt[v] + 1;\n\t\tdfs1(to, v);\n\t}\n}\n\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\t//freopen(\".err\", \"w\", stderr);\n\n\t//srand(time(NULL));\n\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tios_base::sync_with_stdio(false);\n\n\t//cout << setprecision(10) << fixed;\n\t\n\tcin >> n;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> d[i];\n\t\tp[i] = i;\n\t}\n\n\tsort(p + 1, p + 1 + n, &cmp);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tpos[d[p[i]]] = i;\n\t\tcnt[p[i]] = 1;\n\t}\n\n\tfor (int i = n; i > 1; i--) {\n\t\tll val = d[p[i]] + cnt[p[i]] + cnt[p[i]] - n;\n\t\tif (!pos.count(val) || val >= d[p[i]]) {\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\tint pr = pos[val];\n\t\tcnt[p[pr]] += cnt[p[i]];\n\t\tg[p[pr]].pb(p[i]);\n\t\tg[p[i]].pb(p[pr]);\n\t}\n\n\tdfs(1);\n\tdfs1(1);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (dp[i] + dp1[i] != d[i]) {\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (auto j : g[i])\n\t\t\tif (i < j)\n\t\t\t\tcout << i << \" \" << j << \"\\n\";\n\t}\n\t\n\t//cerr << (clock() + 0.0) / CLOCKS_PER_SEC;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, a, b) for(int i = a;i < b;i++)\n#define For(i, a) FOR(i, 0, a)\n#define REV(i, a, b) for(int i = b-1;i >= a;i--)\n#define Rev(i, a) REV(i, 0, a)\n#define REP(a) For(i, a)\n#define DEBUG_PRINT(...) fprintf(stderr, __VA_ARGS__)\n#ifdef ENABLE_DEBUG\n#define DEBUG(a) cerr<<#a<<\"=\"<<a<<endl\n#define DEBUG_ARRAY(a,n) cerr<<#a<<\"[\"<<n<<\"]=\"<<a[n]<<endl\n#else\n#define DEBUG(a) \n#define DEBUG_ARRAY(a,n) \n#endif\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\nvoid print_pair(pi a){\n  cerr<<\"(\"<<a.first<<\", \"<<a.second<<\") \";\n}\ntemplate<int T1, int T2>\nvoid print_2d(int a[T1][T2], int x, int y){\n  For(i, x){\n    For(j, y){\n      cerr<<a[i][j]<<\" \";\n    }\n    cerr<<endl;\n  }\n}\ntemplate<class T>\nvoid print_array(T a[],size_t n){\n  cerr<<\"array:\";\n  REP(n-1)cerr<<a[i]<<\",\";\n  cerr<<a[n-1]<<endl;\n}\n\nint N;\npll D[100000];\nll d[100000];\nint childnumD[100000];\nvector<pll> ans;\n\nint main(){\n  cin>>N;\n  REP(N){\n    ll tmp;\n    cin>>tmp;\n    D[i]=pll(tmp,i+1);\n  }\n  sort(D,D+N,greater<pll>());\n  REP(N){\n    d[i]=D[i].first;\n    DEBUG(d[i]);\n  }\n  for (int i = 0; i < N-1; i++) {\n    ll tmp=d[i]-(N-2)+2*childnumD[i];\n    DEBUG(tmp);\n      auto itr=lower_bound(d,d+N,tmp,greater<ll>());\n      DEBUG(*itr);\n      if(itr==d+N||*itr!=tmp){\n        cout<<-1<<endl;\n        return 0;\n      }\n      ans.push_back(pll(D[i].second,D[itr-d].second));\n      childnumD[itr-d]++;\n      childnumD[itr-d]+=childnumD[i];\n  }\n  for(auto&& i : ans)\n  {\n    cout<<i.first<<\" \"<<i.second<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n\nconst int N = 100100;\nconst long long mod = 1e9 + 7;\n\nusing namespace std;\n\nint n;\nint p[N];\nint s[N];\nint f[N];\npair < long long, int > a[N];\n\nint get(int x){ return f[x] == x ? x : f[x] = get(f[x]); }\n\nint main()\n{\n        ios_base::sync_with_stdio(false);\n\n        //freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n\n        cin >> n;\n        for(int i = 1; i <= n; i++){\n                cin >> a[i].fi;\n                a[i].se = i;\n                s[i] = 1;\n                f[i] = i;\n        }\n        sort(a + 1, a + n + 1);\n        map < long long, int > id;\n        for(int i = 1; i <= n; i++){\n                id[a[i].fi] = i;\n        }\n\n        for(int i = n; i > 1; i--){\n                long long dp = a[i].fi;\n                dp = dp + s[i] - (n - s[i]);\n                if(id.find(dp) == id.end() || dp > a[i].fi){\n                        cout << -1 << \"\\n\";\n                        return 0;\n                }\n                p[i] = id[dp];\n                s[p[i]] += s[i];\n\n                int px = get(i), py = get(p[i]);\n                if(px == py){\n                        cout << -1 << \"\\n\";\n                        return 0;\n                }\n                f[px] = py;\n        }\n        if(s[1] != n){\n                cout << -1 << \"\\n\";\n                return 0;\n        }\n        for(int i = 2; i <= n; i++){\n                cout << a[i].se << \" \" << a[p[i]].se << \"\\n\";\n        }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cassert>\n#define ll long long\nusing namespace std;\ninline ll read(){\n\tll re=0,flag=1;char ch=getchar();\n\twhile(ch>'9'||ch<'0'){\n\t\tif(ch=='-') flag=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();\n\treturn re*flag;\n}\nint n;\nstruct node{\n\tll num,dis;\n}a[100010];\nint siz[100010],fa[100010],d[100010],dep[100010];\nvector<int>son[100010];\nbool cmp(node l,node r){\n\treturn l.dis<r.dis;\n}\nvoid dfs(int u,int f){\n\tint i;dep[u]=dep[f]+1;\n//\tcout<<u<<' '<<dep[u]<<\"***\\n\";\n\tfor(auto v:son[u]){\n\t\tif(v!=f) dfs(v,u);\n\t}\n}\nint main(){\n\tn=read();int i;\n\tfor(i=1;i<=n;i++) a[i].dis=read(),a[i].num=i;\n\tsort(a+1,a+n+1,cmp);\n\tfor(i=1;i<=n;i++) d[i]=a[i].dis;\n\tfor(i=n;i>=2;i--){\n\t\tsiz[a[i].num]++;\n\t\tll tmp=d[i]-(n-2*siz[a[i].num]);\n\t\tint pos=lower_bound(d+1,d+i,tmp)-d;\n//\t\tcout<<i<<' '<<d[i]<<' '<<a[i].num<<' '<<siz[a[i].num]<<' '<<tmp<<' '<<pos<<' '<<a[pos].num<<' '<<d[pos]<<'\\n';\n\t\tif(pos>=i||d[pos]!=tmp){\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t\tsiz[a[pos].num]+=siz[a[i].num];fa[a[i].num]=a[pos].num;\n\t}\n\tstd::ios::sync_with_stdio(false);\n\tfor(i=1;i<=n;i++) if(fa[i]) son[fa[i]].push_back(i);\n\tdep[0]=-1;dfs(a[1].num,0);\n\tll ans=0;\n\tfor(i=1;i<=n;i++) ans+=dep[i];\n\tif(ans!=d[1]){\n\t\tputs(\"-1\");return 0;\n\t}\n\tfor(i=1;i<=n;i++) if(fa[i]) cout<<i<<' '<<fa[i]<<'\\n';\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fo(i,s,t) for(int i = s; i <= t; ++ i)\n#define fd(i,s,t) for(int i = s; i >= t; -- i)\n#define bf(i,s) for(int i = head[s]; i; i = e[i].next)\n#define mp make_pair\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pb push_back\n#define VI vector<int>\n#define sf scanf\n#define pf printf\n#define fp freopen\n#define SZ(x) ((int)(x).size())\n#ifdef MPS\n#define D(x...) printf(x)\n#else\n#define D(x...)\n#endif\ntypedef long long ll;\ntypedef double db;\ntypedef unsigned long long ull;\nconst int inf = 1<<30;\nconst ll INF = 1ll<<60;\nconst db Inf = 1e20;\nconst db eps = 1e-9;\n\nvoid gmax(int &a,int b){a = (a > b ? a : b);}\nvoid gmin(int &a,int b){a = (a < b ? a : b);}\n\nconst int maxn = 100050;\n\nint n, sz[maxn];\npair<ll,int> d[maxn];\nstruct edge{int u, v;}e[maxn];\n\nint main()\n{\n\treturn 0 * pf(\"-1\");\n\tsf(\"%d\",&n);\n\tfo(i,1,n) sf(\"%I64d\",&d[i].fi), d[i].se = i;\n\tsort(d+1, d+n+1);\n\tfd(i,n,2)\n\t{\n\t\tsz[i] ++;\n\t\tint l = 1, r = i-1, mid, p = -1;\n\t\twhile(l <= r)\n\t\t{\n\t\t\tmid = (l + r) >> 1;\n\t\t\tif(d[mid].fi <= d[i].fi-n+2*sz[i]) p = mid, l = mid + 1;\n\t\t\telse r = mid - 1;\n\t\t}\n\t\tif(p == -1 || d[p].fi != d[i].fi-n+2*sz[i]) return 0 * pf(\"-1\\n\");\n\t\tsz[p] += sz[i];\n\t\te[i].u = d[p].se; e[i].v = d[i].se;\n\t}\n\tsz[1] ++;\n\tll ans = 0;\n\tfo(i,1,n) ans += sz[i] * (ll)(n - sz[i]);\n\tans <<= 1;\n\tfo(i,1,n) ans -= d[i].fi;\n\tif(ans != 0) return 0 * pf(\"-1\\n\");\n\tfo(i,2,n) pf(\"%d %d\\n\",e[i].u,e[i].v);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <type_traits>\nusing namespace std;\n\nusing ll=int64_t;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(x) x.begin(),x.end()\nauto& errStream=cerr;\n#ifdef LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nll read(){\n\tll i;\n\tscanf(\"%\"  SCNd64,&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%\" PRId64,x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nvoid Impossible(){\n\tprint(-1);\n\texit(0);\n}\n\nconst int Nmax=100010;\nvi tr[Nmax];\nvoid AddEdge(int a,int b){\n\ttr[a].PB(b);\n\ttr[b].PB(a);\n}\nint dfs(int v,int p,int d){\n\tint res=d;\n\tfor(auto to:tr[v])\n\t\tif(to!=p)\n\t\t\tres+=dfs(to,v,d+1);\n\treturn res;\n}\n\nsigned main(){\n\tint n=read();\n\tvector<pi> di(n);\n\tREP(i,n){\n\t\tdi[i]=pi(read(),i);\n\t}\n\tsort(ALL(di));\n\tvi sub(n,1);\n\tfor(int i=n-1;i>=1;i--){\n\t\tint s=sub[di[i].second];\n\t\tcerr<<endl;\n\t\tif(s*2>=n)Impossible();\n\t\tcerr<<endl;\n\t\tint v=di[i].first-(n-s*2);\n\t\tauto itr=lower_bound(ALL(di),pi(v,-1));\n\t\tcerr<<i<<\" \"<<s<<\" \"<<di[i]<<\" \"<<v<<endl;\n\t\tif(itr==di.end()||itr->first!=v)\n\t\t\tImpossible();\n\t\tcerr<<endl;\n\t\tint j=itr-di.begin();\n\t\tAddEdge(di[i].second,di[j].second);\n\t\tsub[di[j].second]+=s;\n\t}\n\tcerr<<endl;\n\tif(dfs(di[0].second,-1,0)!=di[0].first)\n\t\tImpossible();\n\tREP(i,n)\n\t\tfor(auto j:tr[i])\n\t\t\tif(i<j){\n\t\t\t\tprint(i+1,2);\n\t\t\t\tprint(j+1);\n\t\t\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\nbool is_valid(vector<pair<long long, int>> &D, vector<pair<int, int>> &edges){\n    int N = D.size();\n    vector<vector<int>> G(N);\n    for(auto x : edges){\n        G[x.first].push_back(x.second);\n        G[x.second].push_back(x.first);\n    }\n    queue<pair<int, long long>> que;\n    vector<bool> vis(N, false);\n    que.push(make_pair(0, 0));\n    long long cnt = 0;\n    while(!que.empty()){\n        auto q = que.front();\n        que.pop();\n        if(vis[q.first]) continue;\n        vis[q.first] = true;\n        cnt += q.second;\n        for(auto x : G[q.first])\n            que.push(make_pair(x, q.second+1));\n    }\n    return cnt == D[0].first;\n}\n\nint main(){\n    long long N;\n    cin >> N;\n    vector<pair<long long, int>> D(N);\n    for(int i=0; i<N; i++){\n        long long tmp;\n        cin >> tmp;\n        D[i] = make_pair(tmp, i);\n    }\n    sort(D.begin(), D.end(), greater<pair<long long, int>>());\n\n    vector<int> idx2idx(N);\n    for(int i=0; i<N; i++)\n        idx2idx[i] = D[i].second;\n\n    map<long long, int> d2idx;\n    for(int i=0; i<N; i++)\n        d2idx[D[i].first] = i;\n\n    vector<long long> E(N, 1);\n    vector<pair<int, int>> edges;\n    for(int i=0; i<N-1; i++){\n        long long d0 = D[i].first;\n        long long d1 = D[i].first + 2 * E[i] - N;\n        auto itr = d2idx.find(d1);\n        if(itr == d2idx.end() || i == d2idx[d1]){\n            cout << -1 << endl;\n            return 0;\n        }\n        edges.push_back(make_pair(i, d2idx[d1]));\n        E[d2idx[d1]] += E[i];\n    }\n\n    if(!is_valid(D, edges)){\n        cout << -1 << endl;\n        return 0;\n    }\n\n    for(auto x : edges)\n        cout << idx2idx[x.first]+1 << \" \" << idx2idx[x.second]+1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(i,a,n) for(int i=a;i<=n;++i)\n#define PER(i,a,n) for(int i=n;i>=a;--i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(a) ({REP(__i,1,n) cout<<a[__i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\n\n\nconst int N = 1e6+10;\nint n, sz[N];\nstruct _ {\n\tll d;\n\tint id;\n\tbool operator < (const _ &rhs) const {\n\t\treturn d<rhs.d;\n\t}\n} a[N];\nvector<pii> ans;\nvector<int> g[N];\n\nvoid add(int u, int v) {\n\tans.pb(pii(u,v));\n\tg[u].pb(v),g[v].pb(u);\n}\n\nvoid dfs(int x, int f, int d) {\n\ta[1].d -= d;\n\tfor (int y:g[x]) if (y!=f) dfs(y,x,d+1);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tREP(i,1,n) { \n\t\tscanf(\"%lld\",&a[i].d);\n\t\ta[i].id = i, sz[i] = 1;\n\t}\n\tsort(a+1,a+1+n);\n\tPER(i,2,n) {\n\t\t_ u{a[i].d+2*sz[a[i].id]-n,0};\n\t\tauto p = lower_bound(a+1,a+1+n,u);\n\t\tif (p->d!=u.d) return puts(\"-1\"),0;\n\t\tadd(a[i].id,p->id), sz[p->id] += sz[a[i].id];\n\t}\n\tdfs(1,0,0);\n\tif (a[1].d||sz[a[i].id]!=n) return puts(\"1\"),0;\n\tfor (auto &t:ans) printf(\"%d %d\\n\",t.x,t.y);\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cassert>\n#include <map>\n\nusing namespace std;\n\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\n#define MAX(a, b) (((a) < (b)) ? (b) : (a))\nusing ll = long long;\nusing ld = long double;\n\nint const nmax = 100000;\nll dist[1 + nmax];\nint ind[1 + nmax], sz[1 + nmax];\nbool compare(int x, int y){\n  return dist[x] < dist[y];\n}\n\nvector<int> g[1 + nmax];\nint level[1 + nmax];\n\nll dfs(int node){\n  ll result = level[node];\n  for(int h = 0; h < g[node].size(); h++){\n    int to = g[node][h];\n    level[to] = level[node] + 1;\n    result += dfs(to);\n  }\n  return result;\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n  map<ll,int> code;\n  for(int i = 1; i <= n; i++)\n    cin >> dist[i];\n  for(int i = 1; i <= n; i++) {\n    ind[i] = i;\n    sz[i] = 1;\n    code[dist[i]] = i;\n  }\n  sort(ind + 1, ind + n + 1, compare);\n\n  for(int i = n; 1 < i; i--){\n    int node = ind[i];\n    int far = code[dist[node] + sz[node] - (n - sz[node])];\n    if(far == 0){\n      cout << \"-1\";\n      return 0;\n    } else {\n      g[far].push_back(node);\n      sz[far] += sz[node];\n    }\n  }\n  ll result = dfs(ind[1]);\n  if(dist[ind[1]] == result){\n    for(int i = 1;i <= n; i++)\n      for(int h = 0; h < g[i].size(); h++)\n        cout << i << \" \" << g[i][h] << '\\n';\n  } else\n    cout << -1;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cassert>\n#define ll long long\nusing namespace std;\ninline ll read(){\n\tll re=0,flag=1;char ch=getchar();\n\twhile(ch>'9'||ch<'0'){\n\t\tif(ch=='-') flag=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();\n\treturn re*flag;\n}\nint n;\nstruct node{\n\tll num,dis;\n}a[100010];\nint siz[100010],fa[100010],d[100010];\nbool cmp(node l,node r){\n\treturn l.dis<r.dis;\n}\nint main(){\n\tn=read();int i;\n\tfor(i=1;i<=n;i++) a[i].dis=read(),a[i].num=i;\n\tsort(a+1,a+n+1,cmp);\n\tfor(i=1;i<=n;i++) d[i]=a[i].dis;\n\tfor(i=n;i>=2;i--){\n\t\tsiz[a[i].num]++;\n\t\tll tmp=d[i]-(n-2*siz[a[i].num]);\n\t\tint pos=lower_bound(d+1,d+i,tmp)-d;\n//\t\tcout<<i<<' '<<d[i]<<' '<<a[i].num<<' '<<siz[a[i].num]<<' '<<tmp<<' '<<pos<<' '<<a[pos].num<<' '<<d[pos]<<'\\n';\n\t\tif(pos>=i||d[pos]!=tmp){\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t\tsiz[a[pos].num]+=siz[a[i].num];fa[a[i].num]=a[pos].num;\n\t}\n\tstd::ios::sync_with_stdio(false);\n\tfor(i=1;i<=n;i++) if(fa[i]) cout<<i<<' '<<fa[i]<<'\\n';\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int MAXN = 1e05 + 10;\n\nint N;\npair<LL, int> d[MAXN];\n\nint subsize[MAXN]= {0}, fa[MAXN]= {0};\nvoid solve () {\n\tfor (int i = N; i > 1; i --) {\n\t\tsubsize[d[i].second] ++;\n\t\tint up = N - 2 * subsize[d[i].second];\n\t\tint p = lower_bound (d + 1, d + N + 1, make_pair (d[i].first - up, 0)) - d;\n\t\tif (d[p].first != d[i].first - up) { puts (\"-1\"); exit (0); }\n\t\tfa[d[i].second] = d[p].second;\n\t\tsubsize[d[p].second] += subsize[d[i].second];\n\t}\n}\n\ninline LL getnum () {\n\tLL num = 0; char ch = getchar ();\n\twhile (! isdigit (ch)) ch = getchar ();\n\twhile (isdigit (ch)) num = (num << 3) + (num << 1) + ch - '0', ch = getchar ();\n\treturn num;\n}\n\nint main () {\n\tN = getnum ();\n\tfor (int i = 1; i <= N; i ++) d[i].first = getnum (), d[i].second = i;\n\tsort (d + 1, d + N + 1);\n\tsolve ();\n\tfor (int i = 2; i <= N; i ++)\n\t\tprintf (\"%d %d\\n\", fa[d[i].second], d[i].second);\n\n\treturn 0;\n}\n\n/*\n7\n10\n15\n13\n18\n11\n14\n19\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 100003\nusing namespace std;\nstruct edge{int to,next;}e[maxn<<1];\nint head[maxn],cnte,fa[maxn];\nvoid add(int u,int v){e[++cnte].to=v,e[cnte].next=head[u],head[u]=cnte;}\nint n,sz[maxn],s[maxn];\nlong long d[maxn],sum;\nmap<long long,int> b;\nbool cmp(int x,int y){return d[x]<d[y];}\nvoid dfs(int u,int depth){\n\tsum+=depth;\n\tfor(int i=head[u];i;i=e[i].next){\n\t\tint v=e[i].to;\n\t\tif(v==fa[u])continue;\n\t\tdfs(v,depth+1);\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",d+i),s[i]=i,b[d[i]]=i,sz[i]=1;\n\tsort(s+1,s+n+1,cmp);\n\tfor(int i=n;i>=2;i--){\n\t\tint v=s[i],d_u=d[v]-(n-sz[v])+sz[v];\n\t\tif(d_u>=d[v]||!b.count(d_u)){puts(\"-1\");return 0;}\n\t\tint u=b[d_u];\n\t\tadd(u,v),add(v,u),fa[v]=u;\n\t\tsz[u]+=sz[v];\n\t}\n\tif(cnte!=(n-1)*2){puts(\"-1\");return 0;}\n\tdfs(s[1],0);\n\tif(sum!=d[s[1]]){puts(\"-1\");return 0;}\n\tfor(int u=1;u<=n;u++){\n\t\tfor(int i=head[u];i;i=e[i].next){\n\t\t\tint v=e[i].to;\n\t\t\tif(v==fa[u])continue;\n\t\t\tprintf(\"%d %d\\n\",u,v);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing i64 = long long;\n\nconst int N = 100000 + 7;\n\nint n;\nint s[N], e[N];\ni64 d[N], t;\nint u[N], v[N];\n\nint main() {\n//\tfreopen(\"code.in\", \"r\", stdin);\n//\tfreopen(\"code.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(\"%lld\", d + i), e[i] = i, s[i] = 1;\n\tstd::sort(e + 1, e + n + 1, [](int a, int b) {\n\t\treturn d[a] < d[b];\n\t});\n\tfor (int i = n; i > 1; --i) {\n\t\tint j = std::lower_bound(e + 1, e + n + 1, d[e[i]] - n + s[e[i]] * 2, [](int a, i64 b) {\n\t\t\treturn d[a] < b;\n\t\t}) - e;\n\t\tif (d[e[j]] != d[e[i]] - n + s[e[i]] * 2) return printf(\"-1\"), 0;\n\t\ts[e[j]] += s[e[i]], t += s[e[i]];\n\t\tu[i] = e[i], v[i] = e[j];\n\t}\n\tif (d[e[1]] != t) return printf(\"-1\"), 0;\n\tfor(int i = 2; i <= n; i++)\n\t\tprintf(\"%d %d\\n\", u[i], v[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N=100005;\nint n,p[N],sz[N],U[N],V[N];ll tot,d[N];\nmap<ll,int>mp;vector<int>G[N];\ninline bool cmp(int x,int y){return d[x]>d[y];}\nvoid dfs(int x,int d){tot+=d;for(int i=0;i<G[x].size();i++)dfs(G[x][i],d+1);}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&d[i]),mp[d[i]]=i,sz[i]=1,p[i]=i;\n\tsort(p+1,p+n+1,cmp);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x=p[i];ll w=d[x]-(n-sz[x])+sz[x];\n\t\tif(!mp[w]||w>=d[x]){puts(\"-1\");return 0;}\n\t\tint y=mp[w];U[i]=x;V[i]=y;\n\t\tsz[y]+=sz[x];G[y].push_back(x);\n\t}\n\tdfs(p[n],0);\n\tif(tot!=d[p[n]]){puts(\"-1\");return 0;}\n\tfor(int i=1;i<n;i++)printf(\"%d %d\\n\",U[i],V[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <map>\nusing namespace std;\n#define fors(i,a,b) for(int i=(a);i<=(b);++i)\n#define ford(i,a,b) for(int i=(a);i>=(b);--i)\n#define min(x,y) ((x) < (y) ? (x) : (y))\n#define max(x,y) ((x) < (y) ? (y) : (x))\n#define swap(x,y) ((x)^=(y),(y)^=(x),(x)^=(y))\n#define abs(x) ((x) < 0 ? -(x) : (x)) \nconst int maxn=1e6+7;\ntypedef long long ll;\nconst int inf=1<<25;\nint read(){\n    int s=0,f=1;\n    char c=getchar();\n    while(c<'0' || c>'9') {if(c=='-') f=-1; c=getchar();}\n    while(c>='0' && c<='9') {s=s*10+c-48;c=getchar();}\n    return s*f;\n}\nvoid write(int x){\n    if(x<0) {putchar('-');x=-x;}\n    if(x>9) write(x/10);\n    putchar(x%10+48);\n}\nint t[101010];\nlong long d[101010];\nint siz[101010],fa[101010];\nbool cmp(const int &x,const int &y)\n{\n    return d[x]<d[y];\n}\nmap<long long,int> mp;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    mp.clear();\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%lld\",&d[i]);\n        siz[i]=1;\n        mp[d[i]]=i;\n        t[i]=i;\n    }\n    sort(t+1,t+n+1,cmp);\n    for(int i=n;i>1;i--)\n    {\n        fa[t[i]]=mp[d[t[i]]+2*siz[t[i]]-n];\n        if(fa[t[i]]==0)\n        {\n            printf(\"-1\");\n            return 0;\n        }\n        siz[fa[t[i]]]+=siz[t[i]];\n    }\n    for(int i=2;i<=n;i++)\n        d[t[1]]-=siz[t[i]];\n    if(d[t[1]]!=0)\n    {\n        printf(\"-1\");\n        return 0;\n    }\n    for(int i=2;i<=n;i++)\n        printf(\"%d %d\\n\",fa[t[i]],t[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+3;\nint n,siz[N];\nbool b[N];\nstruct syzs{\n\tint val,num;\n} a[N];\nstruct ans{\n\tint e1,e2;\n\tbool operator <(const ans &emm) const{\n\t    if(emm.e1==e1) return e2>emm.e2;\n\t\treturn emm.e1<e1;\n\t}\n};\nbool cmp(syzs c,syzs b){\n\treturn c.val>b.val;\n}\nint find(int k){\n\tint chec=a[k].val+2*siz[k]-n;\n\tfor(int i=k+1;i<=n;i++){\n\t\tif(a[i].val==chec&&i!=k) return i;\n\t}\n\treturn -1;\n}\nint main(){\n\tpriority_queue <ans> q;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i].val);\n\t\ta[i].num=i;\n\t\tsiz[i]=1;\n\t}\n\tsort(a+1,a+n+1,cmp);\n\tb[1]=1;\n\tfor(int i=1;i<n;i++){\n\t\tint v=find(i);\n\t\tif(v==-1) puts(\"-1\"),exit(0);\n\t\tsiz[v]+=siz[i];\n\t\tq.push((ans) {min(a[v].num,a[i].num),max(a[v].num,a[i].num)});\n\t}\n\twhile(!q.empty()){\n\t\tint v1=q.top().e1,v2=q.top().e2;\n    \tq.pop();\n    \tprintf(\"%d %d\\n\",v1,v2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\n#define ll long long\n#define rep(i, a, b) for(int i = a; i <= (int)b; i++)\nvoid read(int &x) {\n    x = 0; int flag = 1; char ch = ' ';\n    while(ch < '0' || ch > '9') { if(ch == '-') flag = -1; ch = getchar(); }\n    while(ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();\n    x *= flag;\n}\nvoid read(ll &x) {\n    x = 0; int flag = 1; char ch = ' ';\n    while(ch < '0' || ch > '9') { if(ch == '-') flag = -1; ch = getchar(); }\n    while(ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();\n    x *= flag;\n}\nusing namespace std;\nconst int maxn = 100010;\nint n, Size[maxn], weight[maxn];\nll d[maxn], dis[maxn];\nvector < pair <int, int > > ans;\nvector <int> edge[maxn];\nvoid dfs(int u, int fa) {\n    Size[u] = 1;\n    for(int i = 0; i < edge[u].size(); i++) if(edge[u][i] != fa) {\n        int v = edge[u][i];\n        dfs(v, u);\n        dis[u] += dis[v] + Size[v];\n        Size[u] += Size[v];\n    }\n}\nint main()\n{\n    read(n);\n    map <ll, int> mp;\n    rep(i, 1, n) read(d[i]), mp[d[i]] = i, weight[i] = 1;\n    rep(times, 1, n - 1) {\n        map <ll, int> :: iterator it = --mp.end();\n        int i = it -> second;\n        ll want = d[i] + 2 * weight[i] - n;\n        if(mp.find(want) == mp.end() || mp[want] == i) {\n            puts(\"-1\");\n            return 0;\n        }\n        int j = mp[want];\n        weight[j] += weight[i];\n        ans.push_back(make_pair(i, j));\n        edge[i].push_back(j), edge[j].push_back(i);\n        mp.erase(--mp.end());\n    }\n    dfs(1, 0);\n    if(dis[1] != d[1]) {\n        puts(\"-1\");\n        return 0;\n    }\n    rep(i, 0, n - 2) printf(\"%d %d\\n\", ans[i].first, ans[i].second);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<unordered_map>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nll d[N];\nunordered_map<ll,vector<int> > p;\nll cnt[N],sum[N],n,r[N];\nvector<pair<int,int> > w;\nbool comp(int a,int b){\n\treturn d[a]>d[b];\n}\nint main(){\n\tcin>>n;\n\tfor (int i=1;i<=n;i++)scanf(\"%lld\",&d[i]),r[i]=i,p[d[i]].push_back(i),cnt[i]=1;\n\tsort(r+1,r+n+1,comp);\n\tfor (int i=1;i<n;i++){\n\t\tll x=r[i],s=d[x]-(n-2*cnt[x]),y;\n\t\tif (p[s].empty()||s>=d[x]){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\ty=p[s].back();\n\t\tw.push_back(make_pair(x,y));\n\t\tcnt[y]+=cnt[x];\n\t\tsum[y]+=sum[x]+cnt[x];\n\t}\n\tif (sum[r[n]]!=d[r[n]]){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tfor (int i=0;i<n-1;i++)printf(\"%d %d\\n\",w[i].first,w[i].second);\n}"
  },
  {
    "language": "C++",
    "code": "/*----------------by syr----------------*/\n/*\n\n         iii                  ii\n     rBQBBBBBBE       BBR iBBBBQBBL     XBBBBBBQBBBBB\n   iBBQJ    7BBB      BBsSBBr   BBQ      i      cBBB\n  rBBU       iBBw     BBBQi     HBBi           KBBi\n  BBH         BB5    iBBB       isL          wBB5\n GBB         iBBi    6BB                   iBBB\n BBQ         BQB     BBD                  QBBi\n BBB        BQB     iQBi                1BBv\n sBBg     wBBB      QBB               iBBB\n  7BBBBBBBBBi       BBR              wBBBBBBBBBBBBB\n     irvi           ii               ii    i i iii\n                i5U\n               BBB\n               BB7\n              1BB\n      iPBBBBBKBBR    JBR1       rQBO   BR  UBQP  iBBQi\n    7BBBGs7sXBBBi     QBBr     gBBE   rBB BB2BB7HBZQBB\n   QBBi      sBQ       BBB   iBBB     SQBBR  BBBB  cBQ\n  gBQ        BBg        BBB KBBi      MBBH   BBB   BBs\n iBBv       iBBi         QBBBL        BBR   pBB   iBB\n pBB        BBB         iBBBB        iBB    BBL   KBB\n MBB       BBBR        BBB JBBi      DBR   iBQ    BBL\n GBB     7BBBB2      PBBH   BBBi     BQr   DBB   iBB\n  BQBXwgBBP BB7    1BBB      BBQ7   1BB    BBc   BBB\n   2BBBBw   BB    EBBS        QBBi  HBa   iBB    BB7\n*/\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define PH push\n#define MP make_pair\n#define PB push_back\n#define fst first\n#define snd second\n#define FOR(i, x, y) for(int i = (x); i < (y); ++i)\n#define REP(i, x, y) for(int i = (x); i <= (y); ++i)\n#define x0 x0123456789\n#define y0 y0123456789\n#define x1 x1234567890\n#define y1 y1234567890\n#define x2 x2345678901\n#define y2 y2345678901\ntypedef double db;\ntypedef long long ll;\ntypedef long double ldb;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int maxn = 1e5 + 5;\nconst ll INF = 1e12 + 7;\n\nint n;\nint par[maxn], sz[maxn];\nbool used[maxn];\nll mn = INF;\nll d[maxn], sub[maxn];\nvector<pair<ll, int> > vec;\n\nint main(){\n\tscanf(\"%d\", &n);\n\tFOR(i, 0, n){\n\t\tscanf(\"%lld\", d + i);\n\t\tvec.PB(MP(d[i], i));\n\t\tmn = min(d[i], mn);\n\t}\n\tsort(vec.begin(), vec.end());\n\tFOR(i, 0, n) sz[i] = 1;\n\tFOR(i, 0, n) sub[i] = -INF;\n\tmemset(par, -1, sizeof(par));\n\tfor(int i = vec.size() - 1; i >= 0; --i){\n\t\tint id = vec[i].snd;\n\t\t//printf(\"i = %d id = %d (%d, %d)\\n\", i, id, vec[i].fst, vec[i].snd);\n\t\tif(d[id] == mn)\n\t\t\tbreak;\n\t\tif(sub[id] == -INF) sub[id] = n - 2;\n\t\tint pos = lower_bound(vec.begin(), vec.end(), MP(d[id] - sub[id], -1)) - vec.begin();\n\t\t//printf(\"id = %d %d %d\\n\", id, d[id] - sub[id], pos);\n\t\tif(pos >= i || vec[pos].fst != d[id] - sub[id]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tpar[id] = vec[pos].snd;\n\t\tsz[par[id]] += sz[id];\n\t\tsub[par[id]] = (n - sz[par[id]] - sz[par[id]]);\n\t}\n\tFOR(i, 0, n) if(d[i] != mn) printf(\"%d %d\\n\", i + 1, par[i] + 1);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 1e5 + 5;\nint n;\nll d[MAXN], sum;\nvector< int > adj[MAXN];\nmap< ll , int > mp;\nint h[MAXN], sz[MAXN];\nvoid dfs(int u){\n\tfor(int i = 0; i < adj[u].size(); i++){\n\t\tint v = adj[u][i];\n\t\th[v] = h[u] + 1;\n\t\tdfs(v);\n\t}\n\tsum += h[u];\n\treturn;\n}\nint main(){\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin >> n;\n\tfor(int i = 0; i < n; i ++) cin >> d[i], mp[d[i]] = i, sz[i] = 1;\n\tsort(d, d + n, greater<ll>());\n\tfor(int i = 0; i < n - 1; i ++){\n\t\tint ind = mp[d[i]];\n\t\tint s2 = d[i] + 2*sz[ind] - n;\n\t\tif( s2 == d[i]) return cout << -1 << endl, 0;\n\t\tif( mp.count(s2)){\n\t\t\tint indpar = mp[s2];\n\t\t\tsz[indpar] += sz[ind], adj[indpar].push_back(ind);\n\t\t}\n\t\telse return cout << -1 << endl, 0;\n\t}\n\tdfs(mp[d[n - 1]]);\n\tif( sum != d[n - 1]) return cout << -1 << endl, 0;\n\tfor(int i = 0; i < n; i ++){\n\t\tfor( int j = 0; j < adj[i].size(); j ++){\n\t\t\tcout << i + 1 << \" \" << adj[i][j] + 1 << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<vector>\n#define pb push_back\n\ntypedef long long LL;\n\nconst int N=100005;\n\nint n,size[N],id[N],ans1[N],ans2[N];\nLL tot,a[N];\nstd::map<LL,int> num;\nstd::vector<int> vec[N];\n\nbool cmp(int x,int y)\n{\n\treturn a[x]>a[y];\n}\n\nvoid dfs(int x,int fa,int d)\n{\n\ttot+=(LL)d;\n\tfor (int i=0;i<vec[x].size();i++)\n\t\tif (vec[x][i]!=fa) dfs(vec[x][i],x,d+1);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%lld\",&a[i]),num[a[i]]=i;\n\tfor (int i=1;i<=n;i++) size[i]=1,id[i]=i;\n\tstd::sort(id+1,id+n+1,cmp);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x=id[i];LL w=a[x]-(n-size[x])+size[x];\n\t\tif (!num[w]||w>=a[x]) {puts(\"-1\");return 0;}\n\t\tint y=num[w];\n\t\tans1[i]=x;ans2[i]=y;\n\t\tvec[x].pb(y);vec[y].pb(x);\n\t\tsize[y]+=size[x];\n\t}\n\tdfs(id[n],0,0);\n\tif (tot!=a[id[n]]) {puts(\"-1\");return 0;}\n\tfor (int i=1;i<n;i++) printf(\"%d %d\\n\",ans1[i],ans2[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <vector>\nusing namespace std;\ntypedef long long LL;\nconst int N=1e6;\nint n,dx=0,fa[N+10],sz[N+10];\nLL d[N+10],sum=0;\nmap <LL,int> mp;\nvector <int> son[N+10];\nvoid Dfs(int x) {\n    sum+=dx;\n    for (int i=0;i<(int)son[x].size();i++) {\n        int kx=son[x][i];\n        dx++;\n        Dfs(kx);\n        dx--;\n    }\n}\nvoid Print(int x) {\n    for (int i=0;i<(int)son[x].size();i++) {\n        int kx=son[x][i];\n        printf(\"%d %d\\n\",x,kx);\n        Print(kx);\n    }    \n}\nint main() {\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++) {\n        scanf(\"%lld\",&d[i]);\n        mp[d[i]]=i;\n    }\n    sort(d+1,d+n+1);\n    for (int i=1;i<=n;i++) sz[i]=1;\n    for (int i=n;i>1;i--) {\n        int kx=mp[d[i]];\n        if (sz[kx]*2>=n) {\n            printf(\"-1\\n\");\n            return 0;\n        }\n        fa[kx]=mp[d[i]-(n-sz[kx]*2)];\n        if (fa[kx]==0) {\n            printf(\"-1\\n\");\n            return 0;\n        }\n        sz[fa[kx]]+=sz[kx];\n        son[fa[kx]].push_back(kx);\n    }\n    Dfs(mp[d[1]]);\n    if (sum!=d[1]) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n    Print(mp[d[1]]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <queue>\nusing namespace std;\ntypedef long long i64;\ninline i64 read(int f = 1, i64 x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n}\nconst int N = 1e5+5;\nint n, r[N], p[N], u[N], v[N]; i64 D[N]; queue<int> f[2];\nbool cmp(int i, int j) { return D[i] < D[j]; }\nint main()\n{\n    n = read(); for(int i = 1; i <= n; ++i) D[i] = read(), p[i-1] = i;\n    sort(p, p+n, cmp), r[p[0]] = n, f[(D[p[0]]+n)&1].push(p[0]);\n    for(int i = 1; i < n; ++i)\n    {\n        int x = p[i], y = 0; queue<int> &q = f[D[x]&1]; \n        if(q.size()) y = q.front(), r[x] = (D[y]+n-D[x])/2;\n        while(r[x] <= 0&&q.size()) q.pop(), y = q.front(), r[x] = (D[y]+n-D[x])/2;\n        if(r[x] <= 0||r[x] >= r[y]) return puts(\"-1\"), 0;\n        u[i] = x, v[i] = y, r[y] -= r[x], f[(D[x]+n)&1].push(x);\n        if(r[y] == 1) q.pop();\n    }\n    for(int i = 1; i <= n; ++i) if(r[i] != 1) return puts(\"-1\"), 0;\n    for(int i = 1; i < n; ++i) printf(\"%d %d\\n\", u[i], v[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define LL long long\n#define pii pair<LL, int>\nusing namespace std;\nconst int N = 1e5 + 10;\n\nint n, m;\nint a[N], b[N];\nLL d[N], siz[N];\nmap<LL, int> Map;\npriority_queue<pii> Q;\n\nvoid doit(int cnt) {\n\tpii tmp = Q.top(); Q.pop();\n\tint to = Map[d[tmp.se] - (n - siz[tmp.se] * 2)];\n\ta[cnt] = to;\n\tb[cnt] = tmp.se;\n\tif (siz[tmp.se] * 2 >= n) puts(\"-1\"), exit(0);\n\tsiz[to] += siz[tmp.se];\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%lld\", &d[i]);\n\t\tMap[d[i]] = i;\n\t\tQ.push(make_pair(d[i], i));\n\t}\n\tif (n == 1 && d[1]) return 0 * puts(\"-1\");\n\tfor (int i = 1; i <= n; ++i)\n\t\tsiz[i] = 1;\n\tfor (int i = 1; i < n; ++i)\n\t\tdoit(i);\n\tfor (int i = 1; i < n; ++i)\n\t\tprintf(\"%d %d\\n\", a[i], b[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\nint main(){\n    int N;\n    cin >> N;\n    vector<pair<long long, int>> D(N);\n    for(int i=0; i<N; i++){\n        long long tmp;\n        cin >> tmp;\n        D[i] = make_pair(tmp, i);\n    }\n    sort(D.begin(), D.end(), greater<pair<long long, int>>());\n\n    vector<int> idx2idx(N);\n    for(int i=0; i<N; i++)\n        idx2idx[i] = D[i].second;\n\n    map<long long, int> d2idx;\n    for(int i=0; i<N; i++)\n        d2idx[D[i].first] = i;\n\n    vector<int> E(N, 0);\n    vector<pair<int, int>> edges;\n    for(int i=0; i<N; i++){\n        if(E[i] == 0) E[i] = 1;\n        int d0 = D[i].first;\n        int d1 = D[i].first + 2 * E[i] - N;\n        if(i == N-1) break;\n        auto itr = d2idx.find(d1);\n        if(itr == d2idx.end() || i == d2idx[d1]){\n            cout << -1 << endl;\n            return 0;\n        }\n        edges.push_back(make_pair(i, d2idx[d1]));\n        E[d2idx[d1]] += E[i] + 1;\n    }\n\n    for(auto x : edges)\n        cout << idx2idx[x.first]+1 << \" \" << idx2idx[x.second]+1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define mp make_pair\nusing namespace std;\n\ntypedef pair <long long, int> pli;\ntypedef pair <int, int> pii;\n\nlong long d[100010];\nmap <long long, int> all;\nlong long dp[100010], size[100010];\n\nint main(){\n\tint n; scanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%lld\", &d[i]);\n\t\tall[d[i]] = i;\n\t}\n\tvector <pii> ans;\n\tint pos = all.begin()->se;\n\tfor (auto it = all.rbegin(); it != all.rend(); it++){\n\t\tlong long x = it->fi; int id = it->se;\n\t\tif (id == pos) continue;\n\t\tsize[id]++;\n\t\tlong long need = d[id] + 2 * size[id] - n;\n\t\tif (!all.count(need) || need >= x){\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tint fa = all[need];\n\t\tans.push_back(mp(fa, id));\n\t\tsize[fa] += size[id], dp[fa] += dp[id] + size[id];\n\t}\n\tif (dp[pos] != d[pos]){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < ans.size(); i++){\n\t\tprintf(\"%d %d\\n\", ans[i].fi + 1, ans[i].se + 1);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#define int long long\n#define ll long long\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nconst int N = 1e5 + 1000;\nint n,num; ll dis,siz[N];\nint u[N],to[N];\nstruct node\n{\n\tll v; int id;\n\tint friend operator <(node a,node b){return a.v < b.v;}\n}p[N];\nsigned main()\n{\n\tn = read();\n\tfor(int i = 1;i <= n;i ++) {p[i] = node{read(),i}; siz[i] = 1;}\n\tsort(p + 1,p + 1 + n);\n\tfor(int i = n;i > 1;i --)\n\t{\n\t\tll Dis = p[i].v - n + (siz[i] << 1);\n\t\tint t = lower_bound(p + 1,p + 1 + n,node{Dis,0}) - p;\n\t\tif(p[t].v != Dis) {puts(\"-1\"); return 0;}\n\t\tnum ++; u[num] = p[i].id; to[num] = p[t].id;\n\t\tsiz[t] += siz[i]; dis += siz[i]; \n\t}\n\tif(dis != p[1].v) {puts(\"-1\"); return 0;}\n\telse for(int i = 1;i < n;i ++) cout << u[i] << \" \" << to[i] << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//ここから編集する\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N;\n    cin >> N;\n\n    vector<ll> D(N);\n    map<ll, int> Dtov;\n    rep(i, 0, N) cin >> D[i];\n    rep(i, 0, N) Dtov[D[i]] = i + 1;\n\n    sort(D.rbegin(), D.rend());\n    vector<vector<int> > G(N, vector<int>());\n    vector<bool> used(D.size(), false);\n    vector<pair<int, int>> ans;\n\n    for (int i = 0; i < N - 1; ++i) {\n        if (!used[i]) {\n            used[i] = true;\n\n//            for (int k = N - 2; k > 0; k -= 2) {\n//                if (find(all(D), D[i] - k) == D.end()) {\n//                    cout << -1 << endl;\n//                    return 0;\n//                } else {\n//                    ans.emplace_back(Dtov[D[i]], Dtov[D[i] - k]);\n//                }\n//            }\n            ll tmp = D[i];\n            ll dec = N - 2;\n            while (tmp > D.back()) {\n                if (find(all(D), tmp - dec) == D.end()) {\n                    cout << -1 << endl;\n                    return 0;\n                } else {\n                    ans.emplace_back(Dtov[tmp], Dtov[tmp - dec]);\n//                    used[Dtov[tmp - dec]] = true;\n                    used[find(all(D), tmp - dec) - D.begin()] = true;\n                    tmp -= dec;\n                    dec -= 2;\n                    if (dec > 0 || (dec <= 0 && tmp <= D.back())) {\n\n                    } else {\n                        return -1;\n                    }\n                }\n            }\n        }\n    }\n\n    for (auto e : ans) {\n        cout << e.first << \" \" << e.second << endl;\n//        cout << e.second << \" \" << e.first << endl;\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline long long read () {\n\tlong long num = 0;\n\tchar c = ' ';\n\tbool flag = true;\n\tfor (;c > '9' || c < '0';c = getchar())\n\t\tif (c == '-')\n\t\t\tflag = false;\n\tfor (;c >= '0' && c <= '9';num = (num << 1) + (num << 3) + c - 48, c = getchar());\n\treturn flag ? num : -num;\n}\nnamespace graph {\n\tconst int maxn = 100020;\n\tstruct node {\n\t\tint y, next;\n\t} a[maxn << 1];\n\tint head[maxn], top = 0;\n\tvoid insert (int x, int y) {\n\t\ta[top].y = y;\n\t\ta[top].next = head[x];\n\t\thead[x] = top ++;\n\t}\n} using namespace graph;\n\nnamespace INIT {\n\tmap <long long, int> m;\n\tint n; long long d[maxn];\n\tvoid init () {\n\t\tn = read ();\n\t\tfor (int i = 1;i <= n;i ++) {\n\t\t\td[i] = read ();\n\t\t\tm[d[i]] = i;\n\t\t}\n\t\tsort (d + 1,d + 1 + n);\n\t}\n} using namespace INIT;\n\nnamespace WORK {\n\tint size[maxn];\n\tvoid work () {\n\t\tmemset (head, -1, sizeof head);\n\t\tfor (int i = 1;i <= n;i ++)\n\t\t\tsize[i] = 1;\n\t\tfor (int i = n;i > 1;i --) {\n\t\t\tint x = m[d[i]];\n\t\t\tlong long t = n - 2 * size[x];\n\t\t\tt = d[i] - t;\n\t\t\t/*if (m.count(t) == 0) {\n\t\t\t\tprintf (\"-1\\n\");\n\t\t\t\texit (0);\n\t\t\t}*/\n\t\t\tint y = m[t];\n\t\t\tinsert (y, x);\n\t\t\tinsert (x, y);\n\t\t\tsize[y] += size[x];\n\t\t}\n\t}\n} using namespace WORK;\n\nnamespace CHECK {\n\tint dis[maxn];\n\tvoid dfs (int x, int fa) {\n\t\tfor (int i = head[x];i + 1;i = a[i].next) {\n\t\t\tint y = a[i].y;\n\t\t\tif (y == fa) continue;\n\t\t\tdis[y] = dis[x] + 1;\n\t\t\tdfs (y, x);\n\t\t}\n\t}\n\tvoid check () {\n\t\tdfs (m[d[1]], -1);\n\t\tlong long s = 0;\n\t\tfor (int i = 1;i <= n;i ++)\n\t\t\ts += dis[i];\n\t\tif (s != d[1]) printf (\"-1\\n\");\n\t\telse for (int i = 0;i < top;i += 2) \n\t\t\t\tprintf (\"%d %d\\n\",a[i].y, a[i ^ 1].y);\n\t}\n} using namespace CHECK;\nint main () {\n\tinit ();\n\twork ();\n\tcheck ();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> T gi() {\n\tT x = 0; bool f = 0; char c = getchar();\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar();\n\tif (c == '-') f = 1, c = getchar();\n\twhile (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn f ? -x : x;\n}\nconst int N = 1e5 + 10;\nint p[N], siz[N], X[N], Y[N], fa[N];\nint find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\nLL D[N];\nmap<LL, int> M;\nvector<int> e[N];\nbool cmp(int x, int y) { return D[x] > D[y]; }\nLL res;\nvoid dfs(int u, int ff) {\n\tsiz[u] = 1;\n\tfor (auto v : e[u])\n\t\tif (v != ff) {\n\t\t\tdfs(v, u);\n\t\t\tres += siz[v];\n\t\t\tsiz[u] += siz[v];\n\t\t}\n}\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n = gi<int>();\n\tfor (int i = 1; i <= n; i++)\n\t\tD[i] = gi<LL>(), M[D[i]] = i, p[i] = i;\n\tsort(p + 1, p + 1 + n, cmp);\n\tfor (int i = 1; i <= n; i++) siz[i] = 1, fa[i] = i;\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x = p[i];\t\t\n\t\tif (M.find(D[x] - n + 2 * siz[x]) == M.end()) continue;\n\t\tint y = M[D[x] - n + 2 * siz[x]];\n\t\tif (find(x) == find(y)) continue;\n\t\tfa[find(y)] = find(x);\n\t\tsiz[y] += siz[x]; X[++cnt] = x; Y[cnt] = y;\n\t\te[x].push_back(y); e[y].push_back(x);\n\t}\n\tdfs(1, 0);\n\tif (cnt < n - 1 || res != D[1])\n\t\tputs(\"-1\");\n\telse\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tprintf(\"%d %d\\n\", X[i], Y[i]);\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint N = 1e6, SZ = 320, INF = 1 << 29;\nlong long LINF = (1LL << 60), mod = 1e9 + 7;\nconst long double eps = 1e-8, PI = acos(-1.0);\n\n#define lowbit(x) (x & (-(x)))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntypedef complex<double> cpx;\n\nchar READ_DATA;\nint SIGNAL_INPUT;\ninline int dcmp(double x, double y = 0.0)\n{\n\treturn abs(x - y) < eps;\n}\ntemplate <typename Type>\ninline Type ru(Type &v)\n{\n\tSIGNAL_INPUT = 1;\n\twhile ((READ_DATA = getchar()) < '0' || READ_DATA > '9')\n\t\tif (READ_DATA == '-')\n\t\t\tSIGNAL_INPUT = -1;\n\t\telse if (READ_DATA == EOF)\n\t\t\treturn EOF;\n\tv = READ_DATA - '0';\n\twhile ((READ_DATA = getchar()) >= '0' && READ_DATA <= '9')\n\t\tv = v * 10 + READ_DATA - '0';\n\tv *= SIGNAL_INPUT;\n\treturn v;\n}\ninline ll modru(ll &v)\n{\n\tll p = 0;\n\tSIGNAL_INPUT = 1;\n\twhile ((READ_DATA = getchar()) < '0' || READ_DATA > '9')\n\t\tif (READ_DATA == '-')\n\t\t\tSIGNAL_INPUT = -1;\n\t\telse if (READ_DATA == EOF)\n\t\t\treturn EOF;\n\tp = v = READ_DATA - '0';\n\twhile ((READ_DATA = getchar()) >= '0' && READ_DATA <= '9')\n\t{\n\t\tv = (v * 10 + READ_DATA - '0') % mod;\n\t\tp = (p * 10 + READ_DATA - '0') % (mod - 1);\n\t}\n\tv *= SIGNAL_INPUT;\n\treturn p;\n}\ntemplate <typename A, typename B>\ninline int ru(A &x, B &y)\n{\n\tif (ru(x) == EOF)\n\t\treturn EOF;\n\tru(y);\n\treturn 2;\n}\ntemplate <typename A, typename B, typename C>\ninline int ru(A &x, B &y, C &z)\n{\n\tif (ru(x) == EOF)\n\t\treturn EOF;\n\tru(y);\n\tru(z);\n\treturn 3;\n}\ntemplate <typename A, typename B, typename C, typename D>\ninline int ru(A &x, B &y, C &z, D &w)\n{\n\tif (ru(x) == EOF)\n\t\treturn EOF;\n\tru(y);\n\tru(z);\n\tru(w);\n\treturn 4;\n}\ninline ll gcd(ll a, ll b)\n{\n\twhile (b)\n\t{\n\t\ta %= b;\n\t\tswap(a, b);\n\t}\n\treturn a;\n}\ninline ll ss(ll a, ll b)\n{\n\tll ans = 1;\n\twhile (b)\n\t{\n\t\tif (b & 1)\n\t\t\t(ans *= a) %= mod;\n\t\t(a *= a) %= mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\ntemplate <typename Type>\nvoid brc(Type *a, int n)\n{\n\tint k;\n\tfor (int i = 1, j = n / 2; i < n - 1; i++)\n\t{\n\t\tif (i < j)\n\t\t\tswap(a[i], a[j]);\n\n\t\tk = n >> 1;\n\t\twhile (j >= k)\n\t\t{\n\t\t\tj ^= k;\n\t\t\tk >>= 1;\n\t\t}\n\t\tif (j < k)\n\t\t\tj ^= k;\n\t}\n}\nvoid fft(cpx *a, int n, int inv = 1)\n{\n\tcpx u, t;\n\tbrc(a, n);\n\tfor (int h = 2; h <= n; h <<= 1)\n\t{\n\t\tcpx wn(cos(inv * 2.0 * PI / h), sin(inv * 2.0 * PI / h));\n\t\tfor (int j = 0; j < n; j += h)\n\t\t{\n\t\t\tcpx w(1, 0);\n\t\t\tfor (int k = j; k < j + (h >> 1); k++)\n\t\t\t{\n\t\t\t\tu = a[k];\n\t\t\t\tt = w * a[k + (h >> 1)];\n\t\t\t\ta[k] = u + t;\n\t\t\t\ta[k + (h >> 1)] = u - t;\n\t\t\t\tw *= wn;\n\t\t\t}\n\t\t}\n\t}\n\tif (inv == -1)\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\ta[i] /= n;\n\t\t}\n}\nvoid ntt(ll *a, int n, int inv = 1)\n{\n\tll u, t;\n\tbrc(a, n);\n\tfor (int h = 2; h <= n; h <<= 1)\n\t{\n\t\tll wn = ss(3, (mod - 1) / h);\n\t\tif (inv == -1)\n\t\t\twn = ss(wn, mod - 2);\n\t\tfor (int j = 0; j < n; j += h)\n\t\t{\n\t\t\tll w = 1;\n\t\t\tfor (int k = j; k < j + (h >> 1); k++)\n\t\t\t{\n\t\t\t\tu = a[k];\n\t\t\t\tt = w * a[k + (h >> 1)] % mod;\n\t\t\t\ta[k] = (u + t) % mod;\n\t\t\t\ta[k + (h >> 1)] = (u - t + mod) % mod;\n\t\t\t\t(w *= wn) %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tif (inv == -1)\n\t{\n\t\tll tmp = ss(n, mod - 2);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\t(a[i] *= tmp) %= mod;\n\t}\n}\nstruct Edge\n{\n\tint u, v, nxt;\n\tll w;\n\tEdge(int _u = 0, int _v = 0, ll _w = 0, int _nxt = -1)\n\t{\n\t\tu = _u;\n\t\tv = _v;\n\t\tw = _w;\n\t\tnxt = _nxt;\n\t}\n\n\tint operator<(const Edge &b) const\n\t{\n\t\treturn u < b.u;\n\t}\n};\n\nconst int maxn = 1e6 + 5;\n/*------------------------------------------------------------------------yah------------------------------------------------------------------------*/\n\nint n,id[maxn],cnt[maxn];\nvector<pii> ans;\nll d[maxn],dis[maxn];\n\nmap<ll,vector<int> > f;\nint cmp(const int &i,const int &j)\n{\n\treturn d[i]>d[j];\n}\n\nint main()\n{\n\tru(n);\n\tfor (int i = 1; i < n+1; i++)\n\t{\n\t\tru(d[i]);\n\t\tf[d[i]].push_back(i);\n\t\tid[i]=i;\n\t\tcnt[i]=1;\n\t}\n\tsort(id+1,id+n+1,cmp);\n\n\tint ok=1;\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tvector<int> &tmp = f[d[id[i]]+2*cnt[id[i]]-n];\n\t\t//printf(\"%d %d\\n\",id[i],cnt[id[i]]);\n\t\tif(!tmp.empty())\n\t\t{\n\t\t\tint v=tmp.back();\n\t\t\tans.push_back(pii(id[i],v));\n\t\t\tcnt[v]+=cnt[id[i]];\n\t\t\tdis[v]+=dis[id[i]]+cnt[id[i]];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tok=0;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t}\n\tif(dis[id[n]]!=d[id[n]])\n\t\tok=0;\n\n\tif(ok)\n\t{\n\t\tfor (int i = 0; i < n-1; i++)\n\t\t{\n\t\t\tprintf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\t\t}\n\t}\n\telse\n\t{\n\t\tprintf(\"-1\");\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint PREP = (cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(9), 0);\n//int SEGV = getenv(\"D\") || (exit(system(\"D= SEGFAULT_SIGNALS=all catchsegv ./prog.exe\") >> 8), 0);\nvoid fail() {\n    cout << -1 << '\\n';\n    exit(0);\n}\nint main() {\n    int N; cin >> N;\n    if (N == 2) fail();\n    map<Int, pair<int, int>> M; // D[i] -> idx, num\n    vector<pair<int, int>> ans;\n    for (int i = 0; i < N; i++) {\n        Int d; cin >> d;\n        M[d] = make_pair(i, 1);\n    }\n    for (auto it = rbegin(M), ite = rend(M); it != ite; ++it) {\n        int idx, num; tie(idx, num) = it->second;\n        if (num == N) continue;\n        Int dnext = it->first - abs((N - num) - num);\n        if (it->first == dnext || !M.count(dnext)) fail();\n        ans.emplace_back(idx, M[dnext].first);\n        M[dnext].second += num;\n    }\n    for (auto &p : ans) {\n        cout << p.first + 1 << ' ' << p.second + 1 << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <ctime>\nusing namespace std;\n#define _LL long long\n#define rep(i, n) for (_LL i = 0; i < (_LL)(n); i++)\n#define vecrep(itr, v) for (auto itr = (v).begin(); itr != (v).end(); itr++)\n\n_LL getsub(vector<vector<_LL>> &connect, _LL p, _LL c, _LL d)\n{\n    _LL ret = d;\n    vecrep(itr, connect[c])\n    {\n        if( *itr != p ) ret += getsub(connect, c, *itr, d + 1);\n    }\n    return ret;\n}\n\n_LL getdi(vector<pair<_LL,_LL>> &ans, _LL top, _LL n)\n{\n    vector<vector<_LL>> connect(n);\n    vecrep(itr, ans)\n    {\n        connect[itr->first - 1].push_back(itr->second - 1);\n        connect[itr->second - 1].push_back(itr->first - 1);\n    }\n    return getsub(connect, -1, top - 1, 0);\n}\n\nint main()\n{\n    ios::sync_with_stdio(false); cin.tie(nullptr); \n    _LL n; cin >> n;\n    vector<pair<_LL,_LL>> d(n);\n    rep(i, n)\n    {\n        cin >> d[i].first;\n        d[i].second = i + 1;\n    }\n\n    sort(d.begin(), d.end(), greater<pair<_LL,_LL>>());\n    map<_LL, _LL> vmap;\n    vector<_LL> num(n + 1);\n    vector<pair<_LL,_LL>> ans;\n    if( d[0].first > (n - 1) * n / 2 ) \n    {\n        cout << -1 << endl;\n        return 0;\n    }\n    rep(i, n) {vmap[d[i].first] = d[i].second; num[d[i].second] = 1; }\n    rep(i, n - 1)\n    {\n        _LL d1 = d[i].first;\n        _LL n1 = num[d[i].second];\n        num[d[i].second] = 0;\n        _LL n2 = n - n1;\n        _LL d2 = d1 + n1 - n2;\n        if( vmap[d2] == 0 || num[vmap[d2]] == 0 )\n        {\n            cout << -1 << endl;\n            return 0;\n        }\n        num[vmap[d2]] += n1;\n        ans.emplace_back(d[i].second, vmap[d2]);\n    }\n\n    // check\n\n    if( getdi(ans, d[0].second, n) == d[0].first )\n    {\n        vecrep(itr, ans) cout << itr->first << \" \" << itr->second << endl;\n    }\n    else\n    {\n        cout << -1 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#include <cmath>\n#include <complex>\n// #include \"utiltime.hpp\"\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef complex<double> cdouble;\n\nconst int INFL = (int)1e9;\nconst ll INFLL = (ll)1e18;\nconst double INFD = numeric_limits<double>::infinity();\nconst double PI = 3.14159265358979323846;\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loopll(i, n) for(ll i = 0; i < (ll)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopll1(i, n) for(ll i = 1; i <= (ll)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = (ll)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define Looprll1(i, n) for(ll i = (ll)n; i >= 1; i--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(i, vector.size()) { cout << vector[i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(i, matrix.size()) { Loop(j, matrix[i].size()) { cout << matrix[i][j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define readfile(filename) ifstream in(filename); cin.rdbuf(in.rdbuf());\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\nbool nearlyeq(double x, double y) { return abs(x - y) < 1e6; }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(double x) { ll m = (ll)sqrt(x); return m + (m * m <= (ll)(x) ? 0 : -1); }\nll ceilsqrt(double x) { ll m = (ll)sqrt(x); return m + ((ll)x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\n\n/*******************************************************/\n\nvoid failed() {\n\tcout << -1 << endl;\n\texit(0);\n}\n\nint main() {\n\tint n; cin >> n;\n\tvector<Pll> a(n);\n\tLoop(i, n) {\n\t\tcin >> a[i].first;\n\t\ta[i].second = i;\n\t}\n\tsort(a.begin(), a.end());\n\tvll subtree_cnt(n, 0);\n\tvector<Pll> ans;\n\tLoopr1(i, n - 1) {\n\t\tll target_val = a[i].first + subtree_cnt[i] * 2 - (ll)n + 2;\n\t\tauto itr = lower_bound(a.begin(), a.end(), Pll({ target_val, 0 }));\n\t\tif (itr == a.end()) failed();\n\t\tif (itr - a.begin() == a.size() - 1) failed();\n\t\tif (itr->first != target_val) failed();\n\t\tsubtree_cnt[itr - a.begin()] += subtree_cnt[i] + 1;\n\t\tans.push_back({ a[i].second + 1, a[itr - a.begin()].second + 1 });\n\t\ta.pop_back();\n\t\tsubtree_cnt.pop_back();\n\t}\n\tLoop(i, ans.size()) {\n\t\tcout << ans[i].first << \" \" << ans[i].second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntemplate <class T>\ninline void read(T &res)\n{\n\tres = 0; bool bo = 0; char c;\n\twhile (((c = getchar()) < '0' || c > '9') && c != '-');\n\tif (c == '-') bo = 1; else res = c - 48;\n\twhile ((c = getchar()) >= '0' && c <= '9')\n\t\tres = (res << 3) + (res << 1) + (c - 48);\n\tif (bo) res = ~res + 1;\n}\n\ntypedef long long ll;\n\nconst int N = 1e5 + 5;\n\nint n, p[N], fa[N], sze[N], dis[N];\nll d[N], dsum;\nstd::map<ll, int> occ;\n\ninline bool comp(int a, int b) {return d[a] < d[b];}\n\nint main()\n{\n\tread(n);\n\tfor (int i = 1; i <= n; i++) read(d[i]), p[i] = i, sze[i] = 1;\n\tstd::sort(p + 1, p + n + 1, comp);\n\tfor (int i = 1; i <= n; i++) occ[d[i]] = i;\n\tfor (int i = n; i >= 2; i--)\n\t{\n\t\tint u = p[i]; occ[d[u]] = 0;\n\t\tint v = occ[d[u] - n + (sze[u] << 1)];\n\t\tif (!v) return puts(\"-1\"), 0;\n\t\tfa[u] = v; sze[v] += sze[u];\n\t}\n\tfor (int i = 2; i <= n; i++) dis[p[i]] = dis[fa[p[i]]] + 1;\n\tfor (int i = 1; i <= n; i++) dsum += dis[i];\n\tif (d[p[1]] != dsum) return puts(\"-1\"), 0;\n\tfor (int i = 2; i <= n; i++) printf(\"%d %d\\n\", fa[p[i]], p[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Generated at 2019-07-12 19:25:46 UTC+8\n//Created by Alphagocc\n#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n//C11\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdalign>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n// C++\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n// C++11\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <codecvt>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n// namespace IO \nnamespace IO\n{\ntemplate <typename T>\nvoid __RI(T &x)\n{\n    int ch = getchar(), neg = 1;\n    x = 0;\n    for (; !(isdigit(ch) || ch == '-' || ch == EOF); ch = getchar())\n        ;\n    if (ch == EOF) return;\n    if (ch == '-') neg = -1,ch=getchar();\n    for (; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n    x *= neg;\n}\nvoid R(int &x) { __RI(x); }\nvoid R(int64_t &x) { __RI(x); }\ntemplate <typename T1, typename T2>\nvoid R(std::pair<T1, T2> &x)\n{\n    R(x.first);\n    R(x.second);\n}\ntemplate <typename T>\nvoid R(std::vector<T> &x)\n{\n    for (auto &i : x) { R(i); }\n}\ntemplate <typename T>\nvoid R(T &x)\n{\n    std::cin >> x;\n}\ntemplate <typename T, typename... Args>\nvoid R(T &x, Args &... args)\n{\n    R(x), R(args...);\n}\nchar space = ' ';\ntemplate <typename T>\nvoid __WI(T x)\n{\n    if (x == 0) putchar('0');\n    if (x < 0) putchar('-'), x = -x;\n    char ch[ 64 ];\n    int  pos = 0;\n    while (x) ch[ pos++ ] = x % 10 + 48, x /= 10;\n    while (pos) putchar(ch[ --pos ]);\n}\nvoid W() {}\nvoid W(const int &x) { __WI(x); }\nvoid W(const int64_t &x) { __WI(x); }\nvoid W(const double &x) { printf(\"%lf\",static_cast<double>(x)); }\nvoid W(const char &x) { putchar(x); }\nvoid W(const std::string &x) { printf(\"%s\", x.c_str()); }\ntemplate <typename T1, typename T2>\nvoid W(const std::pair<T1, T2> &x)\n{\n    W(x.first);\n    W(space);\n    W(x.second);\n}\ntemplate <typename T>\nvoid W(const std::vector<T> &x)\n{\n    for (auto it = x.cbegin();it != x.cend(); it++)\n    {\n        W(*it);\n        W(space);\n    }\n    W('\\n');\n}\ntemplate <typename T>\nvoid W(const T &x)\n{\n    std::cout << x;\n}\ntemplate <typename T, typename... Args>\nvoid W(const T &x,const Args &... args)\n{\n    W(x), W(space), W(args...);\n}\ntemplate <typename... Args>\nvoid WL(const Args &... args)\n{\n    W(args...), W('\\n');\n}\n}; // namespace IO\nnamespace Alphagocc\n{\n    decltype(std::chrono::high_resolution_clock::now()) tStart;\n};\nvoid TimeBegin()\n{\n    Alphagocc::tStart=std::chrono::high_resolution_clock::now();\n}\nlong long TimeEnd()\n{\n    return (std::chrono::high_resolution_clock::now()-Alphagocc::tStart).count();\n}\nusing namespace std;\n\n#define REP(i, x, y) for (int i = x;i < y; i++)\n\nconst int8_t  INFC = 0x3f;\nconst int16_t INFS = 0x3f3f;\nconst int32_t INF  = 0x3f3f3f3f;\nconst int64_t INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int MAXN=1.1e5;\n\nint64_t d[MAXN];\nint used[MAXN];\nmap<int64_t,int> mapping;\n\nint main()\n{\n    int n;\n    IO::R(n);\n    mapping.clear();\n    for (int i=0;i<n;i++)\n    {\n        IO::R(d[i]);\n        mapping[d[i]]=i;\n    }\n    priority_queue<pair<int64_t,int>> pq;\n    while(!pq.empty()) pq.pop();\n    for (int i=0;i<n;i++)\n    {\n        pq.emplace(d[i],i);\n    }\n    int root=*min_element(d,d+n);\n    used[mapping[root]]=1;\n    while(!pq.empty())\n    {\n        int k=pq.top().first;\n        int pos=pq.top().second;\n        int p=n-2;\n        pq.pop();\n        if (used[pos]) \n        {\n            \n            continue;\n        }\n        while(k!=root)\n        {\n            int tk=k;\n            k-=p;\n            p-=2;\n            used[mapping[k]]=1;\n            IO::WL(mapping[tk]+1,mapping[k]+1);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing nagai = long long;\nusing ll = long long;\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n    int n;\n    cin >> n;\n    vector<nagai> d(n);\n    for (auto& x : d)\n        cin >> x;\n    vector<int> ord(n);\n    iota(ord.begin(), ord.end(), 0);\n    sort(ord.begin(), ord.end(), [&](int a, int b)\n            {\n             return d[a] > d[b];\n            });\n    map<nagai, int> mp;\n    for (int i = 0; i < n; ++i)\n        mp[d[i]] = i;\n    vector<int> sz(n, 1);\n    vector<pair<int, int>> edg;\n    ord.pop_back();\n    for (int x : ord)\n    {\n        nagai dp = d[x] + sz[x] - (n - sz[x]);\n        if (!mp.count(dp) || mp[dp] == x)\n        {\n             cout << -1 << '\\n';\n             return 0;\n        }\n        edg.emplace_back(mp[dp], x);\n        sz[mp[dp]] += sz[x];\n    }\n    for (auto& x : edg)\n        cout << x.first + 1 << ' ' << x.second + 1 << '\\n';\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n#define int ll\n \nstruct node{\n\tll w;\n\tint y;\n}a[100050];\n \nstruct node2{\n\tint t, nxt;\n}edge[200050];\n \nstruct node3{int fr, f;};\n \nint head[100050], cnt, n, siz[100050], anss;\n \nvoid add(int u, int v){\n\tedge[++cnt] = (node2){v, head[u]};\n\thead[u] = cnt;\n}\n \nbool cmp(node a, node b){return a.w<b.w;}\n \nint find(int u){\n\tfor(int i = u-1; i >= 1; i--)if(a[i].w - a[u].w == 2*siz[a[u].y] - n) return a[i].y;\n\treturn -1;\n}\n \nvoid print(int u, int fa){\n\tqueue<node3> q;\n\tq.push((node3){u, fa});\n\twhile(!q.empty()){\n\t\tu = q.front().fr;\n\t\tint ff = q.front().f;\n\t\tq.pop();\n\t\tfor(int i = head[u]; i; i = edge[i].nxt){\n\t\t\tint v = edge[i].t;\n\t\t\tprintf(\"%d %d\\n\", u, v);\n\t\t\tq.push((node3){v, u});\n\t\t}\n\t}\n}\n\nvoid test(int u, int fa, int dep){\n\tanss+=dep;\n\tfor(int i = head[u]; i; i = edge[i].nxt){\n\t\tint v = edge[i].t;\n\t\tif(v == fa) continue;\n\t\ttest(v, u, dep+1);\n\t}\n}\n\nmain(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &a[i].w);\n\t\ta[i].y = i;\n\t}\n\tsort(a+1, a+n+1, cmp);\n\tint rt = a[1].y;\n\tfor(int i = n; i >= 2; i--) {\n\t\tsiz[a[i].y]++;\n\t\tint p = find(i);\n\t\tif(p == -1){\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[p]+=siz[a[i].y];\n\t\tadd(p, a[i].y);\n\t}\n\ttest(rt, 0, 0);\n\tif(anss != a[1].w){\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tprint(rt, 0);\n}"
  },
  {
    "language": "C++",
    "code": "// Ho-kago Tea Time\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MAXN = (int) 1e5;\n\nint n;\n\nstruct node\n{\n\tint u;\n\tLL D;\n\n\tinline bool operator < (const node &rhs) const { return this->D < rhs.D; }\n\n\tnode() { }\n\tnode(int _u, LL _D): u(_u), D(_D) { }\n}d[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tfor(int i = 1; i <= n; ++i) d[i] = node(i, read<LL>());\n}\n\ninline void solve()\n{\n\tstatic priority_queue<node> Q;\n\tstatic unordered_map<LL, int> id;\n\tstatic int size[MAXN + 5];\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tQ.push(d[i]);\n\t\tid[d[i].D] = d[i].u;\n\t\tsize[d[i].u] = 1;\n\t}\n\n\tstatic vector<pii> E;\n\n\twhile(SZ(Q) > 1)\n\t{\n\t\tint u = Q.top().u, D = Q.top().D;\n\t\tQ.pop();\n\n\t\tint v = id[D + 2 * size[u] - n];\n\t\tif(!v || v == u) { puts(\"-1\"); return; }\n\t\tE.emplace_back(u, v), size[v] += size[u];\n\t}\n\tfor(auto i : E) printf(\"%d %d\\n\", i.fst, i.snd);\n}\n\nint main()\n{\n#ifdef K_ON // K-ON!\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#define mp make_pair\n#define fi first\n#define se second\nusing namespace std;\npair <long long, int> a[1000006];\npair <int, int> edge[1000006];\nint sze[1000006];\nint main(){\n\tint n;\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++ i){\n\t\tscanf(\"%lld\", &a[i].fi);\n\t\ta[i].se = i;\n\t}\n\tsort(a + 1, a + 1 + n);\n\tint m = 0;\n\tlong long sum = 0;\n\tfor (int i = n; i >= 2; -- i){\n\t\tsum += ++ sze[i];\n\t\tlong long d = a[i].fi - n + 2 * sze[i];\n\t\tint index = lower_bound(a + 1, a + 1 + n, mp(d, 0)) - a;\n\t\tif (a[index].fi != d || index >= i){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tedge[++ m] = mp(a[index].se, a[i].se);\n\t\tsze[index] += sze[i];\n\t}\n\tif (a[1].fi != sum){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= m; ++ i)\n\t\tprintf(\"%d %d\\n\", edge[i].fi, edge[i].se);\n\treturn 0;\n}\n/*\n7\n9\n14\n12\n17\n10\n13\n18\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\ntypedef pair < int , int > pp;\nconst int N = 1e5 + 5;\n\nmap < int , int > H;\nvector < int > V[N];\npp A[N];\nint sz[N];\n\nint f(int x, int d){\n    int t = d;\n    for(int i=0; i<V[x].size(); i++)\n        t += f(V[x][i], d+1);\n    return t;\n}\n\nsigned main(){\n    int n;\n\tcin >> n;\n    for(int i=1; i<=n; i++){\n        int x;\n        scanf(\"%lld\",&x);\n        A[i] = mp(x,i);\n        H[x] = i;\n    }\n            \n    sort(A+1 , A+n+1);\n    for(int i=n; i>=2; i--){\n        int x = A[i].nd;\n        sz[x]++;\n        H[ A[i].st ] = 0; \n        int par = H[ A[i].st - n + 2 * sz[x] ];\n        if(par == 0){\n            cout << -1;\n            return 0;`\n        }\n        \n        sz[par] += sz[x];\n        V[par].pb(x);\n    }\n    \n    if(f(A[1].nd, 0) != A[1].st){\n        cout << -1;\n        return 0;\n    }\n    \n    for(int i=1; i<=n; i++)\n        for(int j=0; j<V[i].size(); j++)\n            printf(\"%lld %lld\\n\", i, V[i][j]);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// comment\n// 가장 큰게 리프였다는 사실을 알았으면 해볼만 했을지도..\n// 가장 작은 값을 기준으로 트리를 만들면 밑으로 갈수록 점점 증가한다라는 사실을 인지하는 능력?\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define SZ(v) ((int)(v).size())\n#define ALL(v) (v).begin(),(v).end()\n#define one first\n#define two second\nusing ll = long long;\nusing pi = pair<int, int>;\nusing pli = pair<ll, int>;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 1ll * INF * INF;\n\nconst int MAX_N = 1e5 + 100;\n\nint N, Ix[MAX_N];\nll Ds[MAX_N];\nint S[MAX_N];\n\nint findD(ll d) {\n\tint ix = lower_bound(Ds+1, Ds+N+1, d) - Ds;\n\tif(Ds[ix] == d) return ix;\n\treturn -1;\n}\n\nbool Vis[MAX_N];\nvector<int> Ed[MAX_N];\n\nint main() {\n\tcin >> N;\n\tvector<pli> temp;\n\tfor(int i=1; i<=N; i++) {\n\t\tscanf(\"%lld\", &Ds[i]);\n\t\ttemp.emplace_back(Ds[i], i);\n\t}\n\tsort(Ds+1, Ds+N+1);\n\tsort(ALL(temp));\n\tfor(int i=0; i<N; i++) Ix[i+1] = temp[i].two;\n\tfor(int i=1; i<=N; i++) S[i] = 1;\n\t\n\tvector<pi> Ans;\n\t//for(int i=1; i<=N; i++) printf(\"%lld \", Ds[i]); puts(\"\");\n\tfor(int i=N; i>=2; i--) {\n\t\tll pd = Ds[i] + 2*S[i] - N;\n\t\tint ix = findD(pd);\n\t\t//printf(\"%lld [%lld + 2*%d - %d] %d\\n\", pd, Ds[i], S[i], N, ix);\n\t\tif(ix == -1 || ix == i) return puts(\"-1\") < 0;\n\t\tS[ix] += S[i];\n\t\tAns.emplace_back(Ix[ix], Ix[i]);\n\t\tEd[Ix[ix]].push_back(Ix[i]);\n\t\tEd[Ix[i]].push_back(Ix[ix]);\n\t}\n\n\tll real = 0;\n\tqueue<int> Q;\n\tint root = Ix[1];\n\tVis[root] = 1; Q.push(root);\n\twhile(!Q.empty()) {\n\t\tint v = Q.front(); Q.pop();\n\t\tfor(int w: Ed[v]) if(Vis[w] == 0) {\n\t\t\tVis[w] = Vis[v] + 1;\n\t\t\tQ.push(w);\n\t\t}\n\t}\n\tint all = 0;\n\tfor(int i=1; i<=N; i++) if(Vis[i] != 0) {\n\t\tall++;\n\t\treal += Vis[i] - 1;\n\t}\n\tif(all != N || real != Ds[1]) return puts(\"-1\") < 0;\n\n\n\tfor(auto p: Ans) {\n\t\tint x, y; tie(x, y) = p;\n\t\tprintf(\"%d %d\\n\", x, y);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<vector>\n\ntypedef long long ll;\n\nint const N = 1e5 + 5;\n\nint fa[N];\nint sz[N];\nll a[N];\nll dis[N];\nint n;\n\nstd::vector<int> E[N];\nvoid addedge2(int x, int y) {\n    E[x].push_back(y);\n    E[y].push_back(x);\n}\n\nvoid dfs(int x, int pre, int& sum) {\n    ++sum;\n    for(auto y : E[x]) if(y != pre) {\n        dfs(y, x, sum);\n    }\n}\n\nint main() {\n    std::map<ll, int, std::greater<ll> > M;\n    std::ios::sync_with_stdio(0);\n    std::cin >> n;\n    for(int i = 1; i <= n; ++i) {\n        std::cin >> a[i];\n        M.insert(std::make_pair(a[i], i));\n    }\n    for(auto& k : M) if(k.first != (*M.rbegin()).first) {\n        int now = k.second;\n        ++sz[now];\n        int f = k.first + 2 * sz[now] - n;\n        if(M.count(f) == 0) {\n            puts(\"-1\");\n            return 0;\n        }\n        fa[now] = M[f];\n        sz[fa[now]] += sz[now];\n        ::addedge2(now, fa[now]);\n    }\n    int sum = 0;\n    dfs(1, -1, sum);\n    if(sum != n) {\n        puts(\"-1\");\n        return 0;\n    }\n    for(int i = 1; i <= n; ++i) if(fa[i] != 0) {\n        std::cout << fa[i] << ' ' << i << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<iomanip>\n#include<cstring>\n#include<complex>\n#include<vector>\n#include<cstdio>\n#include<string>\n#include<bitset>\n#include<ctime>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#define Cpy(x,y) memcpy(x,y,sizeof(x))\n#define Set(x,y) memset(x,y,sizeof(x))\n#define FILE \"a\"\n#define mp make_pair\n#define pb push_back\n#define RG register\n#define il inline\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef vector<int>VI;\ntypedef long long ll;\ntypedef double dd;\nconst int N=1<<17;\nconst int mod=998244353;\nconst int base=26;\nconst dd eps=1e-6;\nconst int inf=2147483647;\nconst ll INF=1ll<<60;\nconst ll P=100000;\nil ll read(){\n  RG ll data=0,w=1;RG char ch=getchar();\n  while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n  if(ch=='-')w=-1,ch=getchar();\n  while(ch<='9'&&ch>='0')data=data*10+ch-48,ch=getchar();\n  return data*w;\n}\n\nil void file(){\n  srand(time(NULL)+rand());\n  freopen(FILE\".in\",\"r\",stdin);\n  freopen(FILE\".out\",\"w\",stdout);\n}\n\nint n,o[N],sz[N],m;\nstruct node{int d,id;}t[N];bool cmp_d(node a,node b){return a.d<b.d;}\nil void er(){puts(\"-1\");exit(0);}\nstruct edge{int u,v;}E[N];\nint main()\n{\n  n=read();\n  for(RG int i=1;i<=n;i++){t[i].d=read();t[i].id=i;}\n  sort(t+1,t+n+1,cmp_d);\n  for(RG int i=1;i<=n;i++)o[i]=t[i].d,sz[i]=1;\n  for(RG int i=n,p;i!=1;i--){\n    p=lower_bound(o+1,o+n+1,t[i].d-n+2*sz[i])-o;\n    if(o[p]!=t[i].d-n+2*sz[i]||p>=i)er();\n    E[++m]=(edge){t[p].id,t[i].id};sz[p]+=sz[i];\n  }\n  for(RG int i=1;i<=m;i++)printf(\"%d %d\\n\",E[i].u,E[i].v);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\n#define all(x) (x).begin(),(x).end()\n\n\nint main() {\n#ifdef local\n\tfreopen(\"in.txt\", \"r\", stdin);\n#endif\n\tios::sync_with_stdio(false);\n\tcin.tie(0), cout.tie(0);\n\tint n; cin >> n;\n\tvector<pair<ll, ll> > d(n);\n\tfor(int i = 0; i < n; i++) {\n\t\tll x; cin >> x;\n\t\td[i] = make_pair(x, i);\n\t}\n\tvector<int> sz(n, 1);\n\tsort(all(d), greater<pair<ll,ll>>());\n\tvector<pair<int, int> > edges;\n\tvector<int> adj(n);\n\tfor(int i = 0; i < n - 1; i++) {\n\t\tll id = d[i].se, dis = d[i].fi;\n\t\tint dt = n - 2*sz[id];\n\t\tdis -= dt;\n\t\tauto it = lower_bound(all(d), pair<ll, ll>(dis, n), greater<pair<ll, ll> >());\n\t\tif(it == d.end() || it->fi != dis) {\n\t\t\tcout << \"-1\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tsz[it->se] += sz[id];\n\t\tadj[it->se].emplace_back(id);\n\t\tedges.emplace_back(id + 1, it->se + 1);\n\t}\n\tfunction<ll(int, int)> dfs = [&](int u) {\n\t\tll ret = 0;\n\t\tfor(auto &v : adj) {\n\t\t\tret += dfs(v) + sz[v];\n\t\t}\n\t\treturn ret;\n\t};\n\tif(dfs(id[n-1]) != d[n-1].fi) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\tsort(all(edges));\n\tfor(auto &e : edges) {\n\t\tcout << e.fi << ' ' << e.se << '\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,fma,abm,mmx,avx,avx2,tune=native\")\n#include <bits/stdc++.h>\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#ifdef rd\n#define trace(...) cout<<\"Line:\"<<__LINE__<<\" \"; __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate<typename Arg1>\nvoid __f(const char *name, Arg1 &&arg1) {\n\tcout<<name<<\" : \"<<arg1<<endl;\n}\ntemplate<typename Arg1, typename ... Args>\nvoid __f(const char *names, Arg1 &&arg1, Args &&... args) {\n\tconst char *comma=strchr(names+1,',');\n\tcout.write(names,comma-names)<<\" : \"<<arg1<<\" | \";\n\t__f(comma+1,args...);\n}\n#else\n#define trace(...)\n#define endl '\\n'\n#endif\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\ntypedef float f80;\n#define double long double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define sz(x) ((long long)x.size())\n#define fr(a,b,c) for(int a=b; a<=c; a++)\n#define rep(a,b,c) for(int a=b; a<c; a++)\n#define trav(a,x) for(auto &a:x)\n#define all(con) con.begin(),con.end()\nconst ll infl=0x3f3f3f3f3f3f3f3fLL;\nconst int infi=0x3f3f3f3f;\nconst int mod=998244353;\n//const int mod=1000000007;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef tree<pii, null_type, less<pii>, rb_tree_tag, tree_order_statistics_node_update> oset;\nauto clk=clock();\nmt19937_64 rang(chrono::high_resolution_clock::now().time_since_epoch().count());\nint rng(int lim) {\n\tuniform_int_distribution<int> uid(0,lim-1);\n\treturn uid(rang);\n}\n\nint powm(int a, int b) {\n\tint res=1;\n\twhile(b) {\n\t\tif(b&1)\n\t\t\tres=(res*a)%mod;\n\t\ta=(a*a)%mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nint d[100005];\nmap<int,int> sz;\nmap<int,int> vert;\nmap<int,int> par;\nvi gra[100005];\npii dfs(int at) {\n\tpii ans={0,1};\n\tfor(int i:gra[at]) {\n\t\tpii lol=dfs(i);\n\t\tans.fi+=lol.fi;\n\t\tans.se+=lol.se;\n\t}\n\tans.fi+=ans.se;\n\treturn ans;\n}\nvoid solve() {\n\tint n;\n\tcin>>n;\n\tfr(i,1,n) {\n\t\tcin>>d[i];\n\t\tvert[d[i]]=i;\n\t\tsz[d[i]]=1;\n\t}\n\tsort(d+1,d+n+1);\n\tfor(int i=n; i>1; i--) {\n\t\tint tol=d[i]-n+2*sz[d[i]];\n\t\tif(tol>=d[i]||vert.find(tol)==vert.end()) {\n\t\t\tcout<<-1<<endl;\n\t\t\treturn;\n\t\t}\n\t\tpar[d[i]]=tol;\n\t\tsz[tol]+=sz[d[i]];\n\t}\n\tfr(i,2,n)\n\t\tgra[vert[par[d[i]]]].pb(vert[d[i]]);\n\tif(dfs(vert[d[1]]).fi!=n+d[1])\n\t\tcout<<-1<<endl;\n\telse\n\t\tfr(i,2,n)\n\t\t\tcout<<vert[d[i]]<<\" \"<<vert[par[d[i]]]<<endl;\n}\n\nsigned main() {\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\tsrand(chrono::high_resolution_clock::now().time_since_epoch().count());\n\tcout<<fixed<<setprecision(10);\n\tint t=1;\n//\tcin>>t;\n\twhile(t--)\n\t\tsolve();\n#ifdef rd\n\tcout<<endl<<endl<<endl<<endl<<\"Time elapsed: \"<<(double)(clock()-clk)/CLOCKS_PER_SEC<<endl;\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<map>\n#include<cmath>\n#include<algorithm>\n#define N 100005\nusing namespace std;\nstruct with {\n\tint w;\n\tlong long d;\n} dt[N];\nmap<long long, int> chk;\nint n;\nint parent[N],subn[N];\nlong long d[N];\nbool cmp(with i, with j) {\n\treturn i.d < j.d;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tint i;\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &d[i]);\n\t\tdt[i].d = d[i]; dt[i].w = i;\n\t\tsubn[i] = 1;\n\t}\n\tsort(dt + 1, dt + 1 + n, cmp);\n\tsort(d + 1, d + 1 + n);\n\tfor (i = 1; i <= n; i++) chk[d[i]] = i;\n\tbool imp = false;\n\tfor (i = n ; i >= 2; i--) {\n\t\tint adjacent=0;\n\t\tadjacent = chk[d[i] - n + 2 * subn[i]];\n\t\tparent[i] = adjacent;\n\t\tsubn[adjacent]+=subn[i];\n\t\tif (parent[i] == 0 || parent[i]==i) {\n\t\t\timp = true; break;\n\t\t}\n\t}\n\timp = true;\n\tfor (i = 2; i <= n; i++) {\n\t\tif (parent[i] == 1) {\n\t\t\timp = false; break;\n\t\t}\n\t}\n\tif (imp) printf(\"-1\");\n\telse {\n\t\tfor (i = 2; i <= n; i++) {\n\t\t\tprintf(\"%d %d\\n\", dt[parent[i]].w,dt[i].w);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"Ofast\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\n//smaller names\n#define int long long\n#define double long double\n#define Int signed\n#define vi vector<int>\n#define vvi vector<vi>\n#define vd vector<double>\n#define vvd vector<vd>\n#define pii pair<int, int>\n#define vpii vector<pii>\n#define vvpii vector<vpii>\n#define mii map<int, int>\n#define unordered_map gp_hash_table\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, a, b) for(int i = a; i < b; i++)\n#define repd2(i, a, b) for(int i = b - 1; i >= a; i--)\n#define repd(i, n) for(int i = n-1; i >= 0; i--)\n\n#define F first\n#define S second\n\n#define fastio ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define all(v) v.begin(),v.end()\n\nconst int INF = 1e9;\nconst double EPS = 1e-9;\nconst double PI = acosl(-1);\n\n//order_of_key(k) - number of elements e such that func(e, k) returns true, where func is less or less_equal\n//find_by_order(k) - kth element in the set counting from 0\n\ntypedef tree <\n    int,\n    null_type,\n    less<int>,\n    rb_tree_tag,\n    tree_order_statistics_node_update\n> \nordered_set;\n\ntypedef tree <\n    int,\n    null_type,\n    less_equal<int>,\n    rb_tree_tag,\n    tree_order_statistics_node_update\n>\nordered_multiset;\n\nconst int mod = 1e9 + 7;\nconst int maxn = 5e5 + 5;\nconst int maxa = 1e6 + 5;\nconst int logmax = 25;\n\n//fast exponentiation\n\ntemplate <typename T>\nT power (T a, int n = 1, T id = 1) {\n    T ans = id;\n    while(n) {\n        if(n & 1) ans *= a;\n        a *= a;\n        n >>= 1;\n    }\n    return ans;\n}\n\n//custom hash\n\nstruct custom_hash {\n    // http://xorshift.di.unimi.it/splitmix64.c\n    static uint64_t splitmix64(uint64_t x) {\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n\nint sumdigs (int n) {\n    int ans = 0;\n    while (n) {\n        ans += n % 10;\n        n /= 10;\n    }\n    return ans;\n}\n\ntemplate <int MOD=998'244'353>\nstruct Modular {\n    int value;\n    static const int MOD_value = MOD;\n\n    Modular(long long v = 0) { value = v % MOD; if (value < 0) value += MOD;}\n    Modular(long long a, long long b) : value(0){ *this += a; *this /= b;}\n\n    Modular& operator+=(Modular const& b) {value += b.value; if (value >= MOD) value -= MOD; return *this;}\n    Modular& operator-=(Modular const& b) {value -= b.value; if (value < 0) value += MOD;return *this;}\n    Modular& operator*=(Modular const& b) {value = (long long)value * b.value % MOD;return *this;}\n\n    friend Modular mexp(Modular a, long long e) {\n        Modular res = 1; while (e) { if (e&1) res *= a; a *= a; e >>= 1; }\n        return res;\n    }\n    friend Modular inverse(Modular a) { return mexp(a, MOD - 2); }\n\n    Modular& operator/=(Modular const& b) { return *this *= inverse(b); }\n    friend Modular operator+(Modular a, Modular const b) { return a += b; }\n    friend Modular operator-(Modular a, Modular const b) { return a -= b; }\n    friend Modular operator-(Modular const a) { return 0 - a; }\n    friend Modular operator*(Modular a, Modular const b) { return a *= b; }\n    friend Modular operator/(Modular a, Modular const b) { return a /= b; }\n    friend std::ostream& operator<<(std::ostream& os, Modular const& a) {return os << a.value;}\n    friend bool operator==(Modular const& a, Modular const& b) {return a.value == b.value;}\n    friend bool operator!=(Modular const& a, Modular const& b) {return a.value != b.value;}\n};\n\nusing mint = Modular<mod>;\n\nvector<mint> fact(maxn);\nvoid precompute_facts(){\n    fact[0] = 1;\n    for(int i = 0; i < maxn - 1; i++){\n        fact[i + 1] = fact[i] * (i + 1);\n    }\n}\n\nmint C(int n, int k) {\n    return fact[n] / (fact[k] * fact[n - k]);\n}\n\nmint P(int n, int k) {\n    return fact[n] / fact[n - k];\n}\n\nint tot = 0;\n\nvoid dfs(int v, int p, int h, vvi &g) {\n    tot += h;\n    for(auto x : g[v]) {\n        if(x != p) dfs(x, v, h+1, g);\n    }\n}\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vi a(n);\n    vvi g(n+1);\n    vi sz(n+1, 1);\n    mii id;\n    rep(i, n) {\n        cin >> a[i];\n        id[a[i]] = i+1;\n    }\n    sort(all(a), greater<int>());\n    vpii e;\n    for(auto x : a) {\n        int i = id[x];\n        if(sz[i] == n) {\n            continue;\n        }\n        int nd = x + 2*sz[i] - n;\n        if(nd < x && id.count(nd) > 0) {\n            e.eb(i, id[nd]);\n            sz[id[nd]] += sz[i];\n        }\n    }\n    for(auto ed : e) {\n        int u = ed.F;\n        int v = ed.S;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    dfs(id[a.back()], -1, 0, g);\n    if(e.size() != n - 1 || tot != a.back()) {\n        cout << -1 << endl;\n        return;\n    }\n    for(auto ed : e) cout << ed.F << \" \" << ed.S << \"\\n\";\n}\n\nsigned main(){\n    fastio;\n    cout << setprecision(6) << fixed;\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define reg register\n#define maxn 200001\ninline int  read() {\n    reg int s = 0, t = 0; reg char ch = getchar();\n    while(ch > '9' || ch < '0') t |= ch == '-', ch = getchar();\n    while(ch >= '0' && ch <= '9') s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();\n    return t ? -s : s;\n}\nusing namespace std;\nmap<int, int> mp;\nint D[maxn],a[maxn], b[maxn], cnt, n, sum[maxn];\nsigned main()\n{\n\tn = read();\n\tfor(int i = 1; i <= n; i++) D[i] = read(), mp[D[i]] = i;\n\tcout << -1 << endl; return 0;\n\tsort(D + 1, D + n + 1);\n\tfor(int i = n; i > 1; i--){\n\t\tsum[mp[D[i]]]++;\n\t\tint x = D[i] - abs(n - sum[mp[D[i]]] * 2);\n\t\tif(!mp[x] || x == D[i]) {printf(\"-1\\n\"); return 0;}\n\t\ta[++cnt] = mp[D[i]], b[cnt] = mp[x]; sum[mp[x]] += sum[mp[D[i]]];\n\t}\n\tif(n == 1 && D[1] != 0) {cout << -1 << endl; return 0;}\n\tfor(int i = 1; i < n; i++)\n\tprintf(\"%lld %lld\\n\", a[i], b[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <map>\n\ntypedef long long ll;\nconst int N = 1e5 + 51;\nstruct edge {\n\tint to, next;\n} e[N << 1];\nint head[N], cnt;\nvoid addedge(int x, int y) {\n\te[++cnt] = (edge){y, x[head]}, x[head] = cnt;\n\te[++cnt] = (edge){x, y[head]}, y[head] = cnt;\n}\n\nint ans;\nvoid dfs(int x, int p, int d) {\n\tans += d;\n\tfor (int i = x[head], nx; i; i = e[i].next)\n\t\tif ((nx = e[i].to) != p) dfs(nx, x, d + 1);\n}\n\nint p[N];\nint f(int x) { return x[p] ? x[p] = f(x[p]) : x; }\nvoid l(int x, int y) {\n\tif ((x = f(x)) != (y = f(y))) x[p] = y;\n}\n\nstd::map<ll, int> mp;\nint n, sz[N];\nll a[N];\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", a + i), i[sz] = 1, mp[a[i]] = i;\n\tstd::sort(a + 1, a + n + 1, std::greater<ll>());\n\tfor (int i = 1; i < n; i++) {\n\t\tint x = mp[a[i]], nx;\n\t\tll tmp = a[i] - n + 2 * x[sz];\n\t\tif (tmp >= a[i] || !mp.count(tmp)) return puts(\"-1\"), 0;\n\t\tnx = mp[tmp];\n\t\tnx[sz] += x[sz];\n\t\tif (f(x) == f(nx)) return puts(\"-1\"), 0;\n\t\taddedge(x, nx);\n\t\tl(x, nx);\n\t}\n\tdfs(mp[a[1]], 0, 0);\n\tif (ans != a[1]) return puts(\"-1\"), 0;\n\tfor (int i = 1; i <= cnt; i += 2) printf(\"%d %d\\n\", e[i].to, e[i + 1].to);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\nstruct UnionFind {\n        int n;\n        vector<int> parent;\n        vector<int> rank;\n        vector<int> num;\n        int find(int x) {\n                if (parent[x] == x) return  x;\n                return parent[x] = find(parent[x]);\n        }\n        UnionFind(int n_) {\n                n = n_;\n                parent.resize(n);\n                for (int i = 0; i < n; i ++) parent[i] = i;\n                rank.assign(n, 0);\n                num.assign(n, 1);\n        }\n        void unite(int x, int y) {\n                if ((x = find(x)) != (y = find(y))) {\n                        if (rank[x] < rank[y]) {\n                                parent[x] = y;\n                                num[y] += num[x];\n                        } else {\n                                parent[y] = x;\n                                if (rank[x] == rank[y]) rank[x] ++;\n                                num[x] += num[y];\n                        }\n                        n --;\n                }\n        }\n        bool same(int x, int y) { return find(x) == find(y); }\n        int get() { return n; }\n        int get(int x) { return num[find(x)]; }\n};\n\nint main() {\n\tauto no = [](){ puts(\"-1\"); exit(0); };\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<long long> d(n);\n\tmap<long long, int> mp;\n\tset<long long> ds;\n\trep(i, n) {\n\t\tscanf(\"%lld\", &d[i]);\n\t\tds.insert(d[i]);\n\t\tmp[d[i]] = i;\n\t}\n\tsort(d.rbegin(), d.rend());\n\tUnionFind uf(n);\n\tvector<pair<int, int>> ans;\n\trep(i, n - 1) {\n\t\tlong long cur = d[i];\n\t\tint sz = uf.get(mp[cur]);\n\t\tint d = n - 2 * sz;\n\t\tlong long par = cur - d;\n\t\tif (ds.count(par) == 0) {\n\t\t\tno();\n\t\t}\n\t\tans.emplace_back(mp[cur], mp[par]);\n\t\tuf.unite(mp[cur], mp[par]);\n\t}\n\tvector<vector<int>> g(n);\n\trep(i, n - 1) {\n\t\tint a = ans[i].first;\n\t\tint b = ans[i].second;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tvector<long long> s(n);\n\tvector<int> dis(n);\n\tvector<int> sz(n);\n\tfunction<void (int, int)> dfs = [&](int u, int prev) {\n\t\tsz[u] = 1;\n\t\tfor (auto v : g[u]) if (v != prev) {\n\t\t\tdis[v] = dis[u] + 1;\n\t\t\tdfs(v, u);\n\t\t\tsz[u] += sz[v];\n\t\t}\n\t};\n\tdfs(0, -1);\n\trep(i, n) s[0] += dis[i];\n\tfunction<void (int, int)> dfs2 = [&](int u, int prev) {\n\t\tfor (auto v : g[u]) if (v != prev) {\n\t\t\ts[v] = s[u] + n - sz[v] * 2;\n\t\t\tdfs2(v, u);\n\t\t}\n\t};\n\tdfs2(0, -1);\n\tsort(s.begin(), s.end());\n\tsort(d.begin(), d.end());\n\tif (s != d) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tfor (auto it : ans) printf(\"%d %d\\n\", it.first + 1, it.second + 1);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\nnamespace Base{\n\t# define mr make_pair\n\ttypedef long long ll;\n\ttypedef double db;\n\tconst int inf = 0x3f3f3f3f, INF = 0x7fffffff;\n\tconst ll  infll = 0x3f3f3f3f3f3f3f3fll, INFll = 0x7fffffffffffffffll;\n\ttemplate<typename T> void read(T &x){\n    \tx = 0; int fh = 1; double num = 1.0; char ch = getchar();\n\t\twhile (!isdigit(ch)){ if (ch == '-') fh = -1; ch = getchar(); }\n\t\twhile (isdigit(ch)){ x = x * 10 + ch - '0'; ch = getchar(); }\n\t    if (ch == '.'){\n\t    \tch = getchar();\n\t    \twhile (isdigit(ch)){num /= 10; x = x + num * (ch - '0'); ch = getchar();}\n\t\t}\n\t\tx = x * fh;\n\t}\n\ttemplate<typename T> void chmax(T &x, T y){x = x < y ? y : x;}\n\ttemplate<typename T> void chmin(T &x, T y){x = x > y ? y : x;}\n}\nusing namespace Base;\n\nconst int N = 100010;\nstruct Edge{\n\tint data, next;\n}e[N * 2];\nstruct Node{\n\tint id; ll num;\n}p[N];\nint n, size[N], eu[N], ev[N], head[N], place, cnt;\nll num[N], dis;\nvoid build(int u, int v){\n\te[++place].data = v; e[place].next = head[u]; head[u] = place;\n}\nvoid dfs(int x, int fa, int di){\n\tdis += di;\n\tfor (int ed = head[x]; ed != 0; ed = e[ed].next)\n\t\tif (e[ed].data != fa)\n\t\t\tdfs(e[ed].data, x, di + 1);\n}\nvoid error(){\n\tprintf(\"-1\\n\");\n\texit(0);\n}\nbool cmp(Node x, Node y){\n\treturn x.num < y.num;\n}\nint main(){\n\tread(n);\n\tfor (int i = 1; i <= n; i++){\n\t\tread(num[i]), size[i]++;\n\t\tp[i].num = num[i];\n\t\tp[i].id = i;\n\t}\n\tsort(num + 1, num + n + 1);\n\tsort(p + 1, p + n + 1, cmp);\n\tfor (int i = n; i >= 1; i--){\n\t\tint tmp = num[i] - (n - 2 * size[i]);\n\t\tif (tmp >= num[i]) continue;\n\t\tll id = lower_bound(num + 1, num + n + 1, tmp) - num;\n\t\tif (num[id] == tmp){\n\t\t\tbuild(id, i); build(i, id);\n\t\t\teu[++cnt] = id, ev[cnt] = i;\n\t\t\tsize[id] += size[i];\n\t\t}\n\t\telse error();\n\t}\n\tdfs(1, 0, 0);\n\tif (dis != num[1]) error();\n\tfor (int i = 1; i < n; i++)\n\t\tprintf(\"%d %d\\n\", p[eu[i]].id, p[ev[i]].id);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <ctime>\nusing namespace std;\n#define _LL long long\n#define rep(i, n) for (_LL i = 0; i < (_LL)(n); i++)\n#define vecrep(itr, v) for (auto itr = (v).begin(); itr != (v).end(); itr++)\n\n\n\nint main()\n{\n    ios::sync_with_stdio(false); cin.tie(nullptr); \n    _LL n; cin >> n;\n    vector<pair<_LL,_LL>> d(n);\n    rep(i, n)\n    {\n        cin >> d[i].first;\n        d[i].second = i + 1;\n    }\n\n    sort(d.begin(), d.end(), greater<pair<_LL,_LL>>());\n    map<_LL, _LL> vmap;\n    vector<_LL> num(n + 1);\n    vector<pair<_LL,_LL>> ans;\n    if( d[0].first > (n - 1) * n / 2 ) \n    {\n        cout << -1 << endl;\n        return 0;\n    }\n    rep(i, n) {vmap[d[i].first] = d[i].second; num[d[i].second] = 1; }\n    rep(i, n - 1)\n    {\n        _LL d1 = d[i].first;\n        _LL n1 = num[d[i].second];\n        num[d[i].second] = 0;\n        _LL n2 = n - n1;\n        _LL d2 = d1 + n1 - n2;\n        if( vmap[d2] == 0 || num[vmap[d2]] == 0 )\n        {\n            cout << -1 << endl;\n            return 0;\n        }\n        num[vmap[d2]] += n1;\n        ans.emplace_back(d[i].second, vmap[d2]);\n    }\n\n    vecrep(itr, ans) cout << itr->first << \" \" << itr->second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define ll long long\n#define pii pair<ll,int>\n#define mp make_pair\nusing namespace std;\n\nll n,size[N];\nint e[N][2];\npii a[N];\n\ninline ll read()\n{\n\tll ans=0,f=1;char c=getchar();\n\twhile(c>'9'||c<'0') {if(c=='-') f=-1ll;c=getchar();}\n\twhile(c>='0'&&c<='9') ans=(ans<<1)+(ans<<3)+(c^48),c=getchar();\n\treturn ans*f;\n}\n\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;++i) a[i]=mp(read(),i),size[i]=1;\n\tsort(a+1,a+1+n);\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tll cur=a[i].first-n+2*size[i];\n\t\tint l=1,r=i-1;\n\t\twhile(l<r)\n\t\t{\n\t\t\tint mid=l+r>>1;\n\t\t\tif(a[mid].first<cur) l=mid+1;\n\t\t\telse r=mid;\n\t\t}\n\t\tif(a[l].first!=cur) return puts(\"-1\"),0;\n\t\te[i][0]=a[i].second;\n\t\te[i][1]=a[l].second;\n\t\tsize[l]+=size[i];\n\t}\n\tfor(int i=2;i<=n;++i) printf(\"%d %d\\n\",e[i][0],e[i][1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define re register\n#define gc getchar()\n#define ll long long\n\ninline ll read() {\n\tre ll x(0), f(1); re char c(gc);\n\twhile (c > '9' || c < '0') f = c == '-' ? -1 : 1, c = gc;\n\twhile (c <= '9' && c >= '0') x = x * 10 + c -48, c = gc;\n\treturn x * f;\n}\n\nconst int N = 1e5 + 10;\n\nint n, siz[N], hd[N], cnt, dis[N];\n\nstruct edge {int next, to;} e[N << 1];\nvoid add (int u, int v) {e[++cnt] = (edge) {hd[u], v}, hd[u] = cnt;}\n#define QXX(u) for (int i = hd[u], v; v = e[i].to, i; i =e[i].next)\nvoid dfs (int u) {QXX(u) dis[v] = dis[u] + 1, dfs(v);}\n\nll d[N];\nmap <ll, int> id;\nvector < pair <int, int> > ed;\n\nint main () {\n\tn = read();\n\tfor (int i = 1; i <= n; ++i)\n\t\td[i] = read(), id[d[i]] = i;\n\tsort (d + 1, d + 1 + n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tsiz[i] = 1;\n\tfor (int i = n; i > 1; --i) {\n\t\tint u = id[d[i]];\n\t\tint res = n - 2 * siz[u];\n\t\t// cout << i <<' '<<u<<\" \"<<siz[u] <<\" \"<<res<<\"  \";\n\t\tif (res <= 0) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t} ll t = d[i] - res;\n\t\tif (id.count (t) == 0) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t} int pos = id[t];\n\t\tadd (pos, u);\n\t\tsiz[pos] += siz[u];\n\t\t// cout <<pos<<\" \" <<u<<\"  \"<<siz[pos]<<\" \"<<siz[u]<<'\\n';\n\t\ted.push_back (make_pair(pos, u));\n\t} ll sum = 0;\n\tdfs (id[d[1]]);\n\tfor (int i = 1; i <= n; ++i)\n\t\tsum += dis[i];\n\t// cout << sum << \" \"<< d[1] <<'\\n';\n\tif (sum != d[1]) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t} for (int i = 0; i < (int)ed.size(); ++i)\n\t\tcout << ed[i].first << \" \" << ed[i].second << '\\n';\n\treturn 0;\n} \n/*\n7 7 1 5  6 7  2 1\n6 4 1 5  3 4  2 1\n5 2 1 5  1 2  2 1\n4 6 2 3  5 6  3 2\n3 3 2 3  1 3  4 2\n2 5 3 1  1 5  7 3\n6 7\n3 4\n1 2\n5 6\n1 3\n1 5\n*/"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Distance Sums\n\nusing P = pair<int64_t, int64_t>;\n\nint main() {\n  int64_t N;\n  cin >> N;\n  map<int64_t, P> mp;\n  for (int64_t i = 1; i <= N; i++) {\n    int64_t x;\n    cin >> x;\n    mp[x] = make_pair(i, 1);  // 頂点番号と木のサイズ\n  }\n  if (N == 2) {\n    cout << -1 << endl;\n    return 0;\n  }\n  vector<P> graph;\n  auto enditr = mp.rend();\n  enditr--;\n  for (auto itr = mp.rbegin(); itr != enditr; ++itr) {\n    auto key = itr->first;\n    auto value = itr->second;\n    auto vertex = value.first;\n    auto size = value.second;\n    auto child_key = key - N + 2 * size;\n    if (child_key >= key) continue;\n    auto tmpitr = mp.find(child_key);\n    if (tmpitr != mp.end()) {\n      auto tmp = tmpitr->second;\n      mp.at(child_key) = make_pair(tmp.first, tmp.second + size);\n      graph.push_back(make_pair(vertex, tmp.first));\n    }\n  }\n  if (graph.size() == N - 1) {\n    for (const auto& e : graph) {\n      cout << e.first << ' ' << e.second << endl;\n    }\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iomanip>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<map>\n#include<set>\n#include<vector>\n#include<queue>\n#include<bitset>\n#include<stack>\n#include<cassert>\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n#define mem(x,y) memset(x,y,sizeof x)\n#define sqr(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ll,int> pli;\nconst int INF=2e9;\nconst db eps=1e-12;\ntemplate<typename T>\ninline void read(T &x) {\n\tx=0; int f=1; char ch=getchar();\n\twhile( (ch<'0' || ch>'9') && ch!='-') ch=getchar(); if(ch=='-') {f=-1; ch=getchar();}\n\twhile(ch>='0' && ch <='9') x=x*10+ch-'0',ch=getchar();\n\tx*=f;\n}\n//==========================head template==========================\nconst int N=100010;\nll d[N];\nint n;\nmap<ll,int> key;\npli seq[N];\nint fa[N],sz[N];\nll ret[N];\nsigned main() {\n  read(n);\n  for(int i=1;i<=n;i++) read(d[i]);\n  for(int i=1;i<=n;i++) key[d[i]]=i;\n  for(int i=1;i<=n;i++) seq[i]=mp(d[i],i);\n  sort(seq+1,seq+n+1); reverse(seq+1,seq+n+1);\n  for(int i=1;i<=n;i++) sz[i]=1;\n  for(int i=1;i<n;i++) {\n    int u=seq[i].S;\n    ll delta=d[u]+sz[u]-(n-sz[u]);\n    //printf(\"%lld %d\\n\",delta,u);\n    if(!key.count(delta)) {puts(\"-1\"); return 0;}\n    fa[u]=key[delta];\n    sz[fa[u]]+=sz[u];\n    ret[fa[u]]+=ret[u]+sz[u];\n  }\n  if(seq[n].F!=ret[seq[n].S]) {\n    puts(\"-1\"); return 0;\n  }\n  for(int i=1;i<=n;i++)\n    if(fa[i]) {printf(\"%d %d\\n\",i,fa[i]);}\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 10;\nint n, d[N], s[N];\nvector<int> gr[N];\nmap<int, int> mp;\nint main() {\n\tios_base::sync_with_stdio (false), cin.tie(0), cout.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> d[i], mp[d[i]] = i;\n\tsort(d, d + n, greater<int> ());\n\tfor (int i = 0; i < n; i++) {\n\t\tint v = mp[d[i]];\n\t\ts[v]++;\n\t\tint valpar = d[i] - n + 2 * s[v];\n//\t\tcout << \"i = \" << i << \" : \" << valpar << endl;\n\t\tif (!mp.count(valpar)) {\n\t\t\tif (i == n - 1)\n\t\t\t\tbreak;\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\tint par = mp[valpar];\n\t\ts[par] += s[v];\n\t\tgr[v].push_back(par);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (auto u : gr[i])\n\t\t\tcout << i + 1 << \" \" << u + 1 << \"\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\ntypedef long long ll;\nconst int maxn=1e5;\nstruct wjmzbmr\n{\n    ll d;\n    int id;\n    bool operator < (const wjmzbmr &x) const\n    {\n        return d<x.d;\n    }\n}a[maxn+5];\nint n;\nvector<int> g[maxn+5];\nunordered_map<ll,int> s;\nint dep[maxn+5],sz[maxn+5];\nvector<pair<int,int> > ans;\nbool work()\n{\n    for(int i=n;i>1;--i)\n    {\n        int u=s[a[i].d+2*sz[a[i].id]-n];\n        if(u==0||u==a[i].id) return false;\n        s[a[i].d]=0;\n        ans.push_back(mp(u,a[i].id));\n      //  printf(\"%d %d\\n\",u,a[i].id);\n        g[u].push_back(a[i].id);\n        sz[u]+=sz[a[i].id];\n    }\n    return true;\n}\nvoid dfs(int k,int deep)\n{\n    dep[k]=deep+1;\n    for(auto x:g[k]) dfs(x,dep[k]);\n}\nint main()\n{\n\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;++i) scanf(\"%lld\",&a[i].d),a[i].id=i,s[a[i].d]=i,sz[i]=1;\n    sort(a+1,a+n+1);\n    if(!work()) printf(\"-1\");\n    else\n    {\n        dfs(a[1].id,-1);\n        ll tmp=0;\n        for(int i=1;i<=n;++i) tmp+=dep[i];\n       // cout<<tmp<<endl;\n        if(tmp!=a[1].d) printf(\"-1\");\n        else\n        {\n            for(auto x:ans) printf(\"%d %d\\n\",x.first,x.second);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define eb emplace_back\n#define fi first\n#define se second\nusing namespace std;\nusing cd = complex <double>;\n\nconst long long INF = 1e18; \nconst long long mod = 998244353;//200003;786433;1e9 + 7;\nconst double Pi = acos(-1);\n  \nvoid Fastio()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n}\n\nint n;\nint root;\nlong long mindis = INF;\nlong long d[100005], sz[100005];\nmap <long long, int> M; \nvector <pair <int, int> > Edge;\nvector <int> Adj[100005];\n\nsigned main()\n{\n\tFastio();\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tcin >> d[i];\n\t\tsz[i] = 1;\n\t\tM[d[i]] = i;\n\t\tif(d[i] < mindis)\n\t\t{\n\t\t\troot = i;\n\t\t\tmindis = d[i];\n\t\t}\n\t}\n\twhile(M.size() > 1)\n\t{\n\t\tpair <long long, int> temp = *(prev(M.end()));\n\t\tlong long realdis = temp.fi - n + sz[temp.se] * 2;\n\t\tif(M.count(realdis) == false)\n\t\t{\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\tEdge.eb(temp.se, M[realdis]);\n\t\tsz[M[realdis]] += sz[temp.se];\n\t\tM.erase(temp.fi);\n\t}\n\tif(Edge.size() != n - 1 || n == 1)\n\t{\n\t\tcout << \"-1\";\n\t\treturn 0;\n\t}\n\tfor(auto x : Edge)\n\t{\n\t\tcout << x.fi << ' ' << x.se << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(a) sort(a.begin(), a.end())\n#define Reverse(a) reverse(a.begin(), a.end())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define Ans(f, y, n) if(f) cout << y << endl; else cout << n << endl;\n#define int long long\n#define INF 1000000000000000000\nusing namespace std;\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\n\ntemplate<typename T>\nvoid readv(vector<T> &a){ REP(i, a.size()) cin >> a[i]; }\nvoid readi(vector<int> &a){ REP(i, a.size()){cin >> a[i]; a[i]--;} }\ntemplate<typename T>\nvoid debug(vector<vector<T>> m){ REP(i, m.size()){ REP(j, m[i].size()){ cout << m[i][j] << \",\"; } cout << endl;} }\n\nstruct edge{int to, cost;};\n\nclass Graph\n{\npublic:\n    int V;\n    vector<vector<edge>> G;\n\n    Graph(int V): V(V){\n        G = vector<vector<edge>>(V, vector<edge>(0));\n    }\n\n    void add_edge(int from, int to, int cost){\n        G[from].push_back(edge({to, cost}));\n    }\n\n    void add_edge2(int v1, int v2, int cost){\n        add_edge(v1, v2, cost);\n        add_edge(v2, v1, cost);\n    }\n\n    void dfs(int &n, int &d, bools &used, int v, int g){\n        n++;\n        d += g;\n        used[v] = true;\n        REP(k, G[v].size()) if(!used[G[v][k].to]) dfs(n, d, used, G[v][k].to, g + 1);\n    }\n\n};\n\nsigned main(){\n\n    int N; cin >> N;\n    vector<Pii> D(N);\n    REP(i, N){\n        cin >> D[i].first;\n        D[i].second = i;\n    }\n    Sort(D); Reverse(D);\n\n    vec g(N, -1);\n    map<int, set<int>> par;\n    vector<Pii> ans(0);\n    \n    REP(i, N){\n        int d = D[i].first;\n        int v = D[i].second;\n        int cnt = 1;\n        for(int c: par[d]){\n            cnt += g[c];\n            ans.push_back(Pii(v, c));\n        }\n        g[v] = cnt;\n        par[d - (N - 2 * cnt)].insert(v);\n    }\n\n    Graph G(N);\n    REP(i, ans.size()){\n        G.add_edge2(ans[i].first, ans[i].second, 0);\n    }\n    int n = 0, d = 0;\n    bools used(N, false);\n    G.dfs(n, d, used, D[0].second, 0);\n    if(n == N && ans.size() == N - 1 && D[0].first == d){\n        REP(i, N - 1) cout << ans[i].first + 1 << \" \" << ans[i].second + 1 << endl;\n    }else{\n        cout << -1;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline ll read()\n{\n\tll x = 0, f = 1; char c = getchar();\n\twhile (!isdigit(c)) {if (c == '-') f = -1; c = getchar();}\n\twhile (isdigit(c)) {x = x * 10 + c - '0', c = getchar();}\n\treturn x * f;\n}\n\nconst int MAXN = 1e5 + 10;\nint n, seq[MAXN], sz[MAXN], root;\nvector<int> linker[MAXN];\nll D[MAXN], f[MAXN], g[MAXN];\n\ninline bool cmp(const int &a, const int &b) {return D[a] < D[b];}\n\nvoid dfs(int x, int fa)\n{\n\tf[x] = 0;\n\tfor (int i = 0; i < linker[x].size(); i ++)\n\t{\n\t\tint cur = linker[x][i];\n\t\tif (cur == fa) continue;\n\t\tdfs(cur, x), f[x] += f[cur] + sz[cur];\n\t}\n}\n\nvoid dfs2(int x, int fa)\n{\n\tif (x == root) g[x] = 0;\n\telse g[x] = g[fa] + n - sz[x] + f[fa] - f[x] - sz[x];\n\tfor (int i = 0; i < linker[x].size(); i ++)\n\t{\n\t\tint cur = linker[x][i];\n\t\tif (cur == fa) continue;\n\t\tdfs2(cur, x);\n\t}\n}\n\ninline bool check()\n{\n\tdfs(root, 0), dfs2(root, 0);\n//\tfor (int i = 1; i <= n; i ++)\n//\t\tprintf(\"(%d, %d), \", f[i], g[i]);\n//\tputs(\"\");\n\tfor (int i = 1; i <= n; i ++)\n\t\tif (f[i] + g[i] != D[i]) return 0;\n\treturn 1;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tn = read();\n\tfor (int i = 1; i <= n; i ++) D[i] = read(), seq[i] = i, sz[i] = 1;\n\tsort(seq + 1, seq + 1 + n, cmp), root = seq[1];\n\tfor (int i = n; i > 1; i --)\n\t{\n\t\tint now = seq[i];\n\t\tint l = 1, r = i - 1, pos = -1;\n\t\tll need = D[now] + 2 * sz[now] - n;\n\t\twhile (l <= r)\n\t\t{\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tif (D[seq[mid]] == need)\n\t\t\t{\n\t\t\t\tpos = seq[mid];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (D[seq[mid]] > need) r = mid - 1;\n\t\t\telse l = mid + 1;\n\t\t}\n//\t\tprintf(\"%d (%d, %d, %d, %d)\\n\", i, now, pos, sz[now], need);\n\t\tif (pos == -1) return puts(\"-1\"), 0;\n\t\tlinker[pos].push_back(now), sz[pos] += sz[now];\n\t}\n\tif (check())\n\t{\n\t\tfor (int i = 1; i <= n; i ++)\n\t\t{\n\t\t\tfor (int j = 0; j < linker[i].size(); j ++)\n\t\t\t{\n\t\t\t\tint to = linker[i][j];\n\t\t\t\tprintf(\"%d %d\\n\", i, to);\n\t\t\t}\n\t\t}\n\t}\n\telse puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> ii;\n\nconst int Maxn = 100005;\n\nint n;\nll D[Maxn];\nmap <ll, ll> M;\nmap <ll, int> ind;\nvector <ii> res;\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lld\", &D[i]);\n        ind[D[i]] = i;\n        M[D[i]] = 0;\n    }\n    sort(D, D + n);\n    for (int i = n - 1; i > 0; i--) {\n        ll my = M[D[i]] + 1;\n        if (my >= n - my) { printf(\"-1\\n\"); return 0; }\n        ll need = D[i] + 2ll * ll(my) - ll(n);\n        map <ll, ll>::iterator it = M.find(need);\n        if (it == M.end()) { printf(\"-1\\n\"); return 0; }\n        it->second += my;\n        res.push_back(ii(ind[D[i]], ind[need]));\n    }\n    if (M[D[0]] != n - 1) { printf(\"-1\\n\"); return 0; }\n    for (int i = 0; i < n - 1; i++)\n        printf(\"%d %d\\n\", res[i].first + 1, res[i].second + 1);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN=2e5+7;\n\nint cntm;\nint from[MAXN],to[MAXN];\n\nmap<ll,int> Map,Map2;\n\nint n;\nll a[MAXN],b[MAXN],siz[MAXN];\n\nbool cmp(const ll &A,const ll &B){return a[A]>a[B];}\nbool cmp2(const ll &A,const ll &B){return A>B;}\n\nint main() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) {\n\t\tcin>>a[i];\n\t\tb[i]=i;\n\t\tMap[a[i]]=i;\n\t\tsiz[i]=1;\n\t}\n\tsort(b+1,b+1+n,cmp);\n\tsort(a+1,a+1+n,cmp2);\n\tfor(int i=1;i<=n;i++)\n\t\tMap2[a[i]]=i;\n\tfor(int i=1,i2;i<n;i++) {\n\t\ti2=Map[a[i]-(n-2*siz[i])];\n\t\tif(i2!=0&&a[i]-(n-2*siz[i])<a[i]) {\n\t\t\tsiz[Map2[a[i]-(n-2*siz[i])]]+=siz[i];\n\t\t\tfrom[++cntm]=i2;\n\t\t\tto[cntm]=b[i];\n\t\t}\n\t\telse {\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++) {\n\t\tcout<<from[i]<<\" \"<<to[i]<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n\n#define X first\n#define Y second\n\n//#include <boost/unordered_map.hpp>\n//using namespace boost;\n\n/*\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> rbtree;\nrbtree T;\n*/\n\nnamespace io{\n\tconst int L = (1 << 20) + 1;\n\t\n\tchar buf[L], *S , *T, c;\n\t \n\tchar getchar() {\n\t\tif(__builtin_expect(S == T, 0)) {\n\t\t\tT = (S = buf) + fread(buf, 1, L, stdin);\n\t\t\treturn (S == T ? EOF : *S++);\n\t\t}\n\t\treturn *S++;\n\t}\n\t\n\tint inp() {\n\t\tint x = 0, f = 1; char ch;\n\t\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\t\tif(ch == '-') f = -1;\n\t\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\t\treturn x * f;\n\t}\n\t\n\tunsigned inpu()\n\t{\n\t\tunsigned x = 0; char ch;\n\t\tfor(ch = getchar(); !isdigit(ch); ch = getchar());\n\t\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\t\treturn x;\n\t}\n\t\n\tll inp_ll() {\n\t\tll x = 0; int f = 1; char ch;\n\t\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\t\tif(ch == '-') f = -1;\n\t\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\t\treturn x * f;\n\t}\n\t\n\tchar B[25], *outs=B+20, *outr=B+20;\n\ttemplate<class T>\n\tinline void print(register T a,register char x=0){\n\t\tif(x) *--outs = x, x = 0;\n\t\t\n\t\tif(!a)*--outs = '0';\n\t\telse \n\t\t\twhile(a)\n\t\t\t\t*--outs = (a % 10) + 48, a /= 10;\n\t\t\n\t\tif(x)\n\t\t\t*--outs = x;\n\t\t\n\t\tfwrite(outs, outr - outs , 1, stdout);\n\t\touts = outr;\n\t}\n};\n\nusing io :: print;\nusing io :: inp;\nusing io :: inpu;\nusing io :: inp_ll;\n\nusing i32 = int;\nusing i64 = long long;\nusing u8 = unsigned char;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing f64 = double;\nusing f80 = long double;\n\nll power(ll a, ll b, ll p)\n{\n\tif (!b) return 1;\n\tll t = power(a, b/2, p);\n\tt = t*t%p;\n\tif (b&1) t = t*a%p;\n\treturn t;\n}\n\nconst int MAXN = 200010;\nconst u64 MOD = 1000000007;\nconst f80 MI = f80(1)/MOD;\nconst int INF = 1000000010;\n\nvector<pii> ans;\n\nvoid addedge(int x, int y)\n{\n\tans.emplace_back(x, y);\n\t// printf(\"%d %d\\n\", x, y);\n}\n\npriority_queue<pll, vector<pll>, greater<pll> > H[2];\nint n;\nll d[MAXN], size[MAXN];\n\nint main()\n{\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++ i)\n\t{\n\t\tscanf(\"%lld\", &d[i]);\n\t\tH[d[i]%2].emplace(d[i], i);\n\t}\n\td[0] = 1e13;\n\tint r1 = 0, r2 = 0;\n\tif (!H[0].empty()) r1 = H[0].top().Y;\n\tif (!H[1].empty()) r2 = H[1].top().Y;\n\tint y = (d[r1] < d[r2]) ? r1 : r2;\n\tif (y == r1) H[0].pop();\n\tif (y == r2) H[1].pop();\n\tsize[y] = n;\n\tqueue<int> Q;\n\tQ.push(y);\n\twhile (!Q.empty())\n\t{\n\t\tint y = Q.front();\n\t\tQ.pop();\n\t\tint k = (n+d[y])%2;\n\t\twhile (size[y] > 1)\n\t\t{\n\t\t\tif (H[k].empty())\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint x = H[k].top().Y;\n\t\t\tH[k].pop();\n\t\t\taddedge(x, y);\n\t\t\tsize[x] = (n+d[y]-d[x])/2;\n\t\t\tsize[y] -= size[x];\n\t\t\tQ.push(x);\n\t\t}\n\t\tif (size[y] != 1)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tfor (auto p : ans)\n\t\tprintf(\"%d %d\\n\", p.X, p.Y);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\n\nvoid NG(){\n\tputs(\"-1\");\n\texit(0);\n}\n\nconst int limit = 100010;\nll d[limit];\nvector<int> graph[limit];\nint sz[limit],dist[limit];\n\nusing pll = pair<ll,ll>;\nvector<pll> ary[2];\n\nvoid dfs(int v,int p,int d){\n\tdist[v] = d;\n\tfor(auto &v2:graph[v]){\n\t\tif(v2 == p) continue;\n\t\tdfs(v2,v,d+1);\n\t}\n}\n\nvector<pll> ans;\n\n\nint main(void){\n\tint n;\n\tcin >> n;\n\trep(i,n) cin >> d[i];\n\n\trep(i,n) ary[d[i] % 2].push_back(pll(d[i],i));\n\trep(i,2) sort(begin(ary[i]),end(ary[i]));\n\n\tif(ary[0].size() == n or ary[1].size() == n) NG();\n\n\tint tmp = (ary[1][0].first < ary[0][0].first);\n\tint pos[2] = {0,0};\n\n\tqueue<int> que;\n\tconst int root = ary[tmp][0].second;\n\tque.push(root);\n\tsz[root] = n;\n\tpos[tmp]++;\n\n\n\twhile(!que.empty()){\n\t\tint cur = que.front(); que.pop();\n\t\tint csz = 1;\n\t\n\t\tif(csz == sz[cur]) continue;\n\t\t\n\t\tconst int tar = (d[cur] + 1) % 2;\n\t\twhile(pos[tar] < ary[tar].size()){\n\t\t\tconst int nxt = ary[tar][pos[tar]].second;\n\t\t\tconst ll add = (n - (d[nxt] - d[cur])) / 2LL;\n\t\t\t\n\t\t\tsz[nxt] = add,csz += add;\n\t\t\tgraph[cur].push_back(nxt);\n\t\t\tgraph[nxt].push_back(cur);\n\t\t\tans.push_back(pll(cur + 1,nxt + 1));\n\t\t\tque.push(nxt);\n\t\t\tif(csz > sz[cur]) NG();\n\t\t\tpos[tar]++;\n\t\t\tif(csz == sz[cur]) break;\n\t\t}\n\t}\n\n\tconst int alt = (root == 0);\n\tdfs(alt,-1,0);\n\tll dsum = 0LL;\n\trep(i,n) dsum += dist[i];\n\tif(dsum != d[alt]) NG();\n\n\tfor(auto &elem:ans){\n\t\tcout << elem.first << \" \" << elem.second << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG\n// #define FASTIO\n\n#include <cassert>\n#include <utility>\n#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <bitset>\n#include <chrono>\n#include <cstdlib>\n#include <functional>\n#include <tuple>\n#include <climits>\n#include <limits>\n#include <deque>\n#include <list>\n#include <array>\n#include <stack>\n#include <queue>\n#include <random>\n#include <complex>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n\n#define F first\n#define S second \n#define pb push_back\n\n#define endl \"\\n\";\n#ifdef FASTIO\n\n#define pr(x) printf(\"%d\", x)\n#define ps    printf(\" \")\n#define pl(x) printf(\"%lld\", x)\n#define pf(x) printf(\"%lf\", x)\n#define sc(x) scanf(\"%d\", &x)\n#define sl(x) scanf(\"%lld\", &x)\n#define sf(x) scanf(\"%lf\", &x)\n#define IOS \n\n#endif\n\n#ifndef FASTIO\n    #define IOS { ios :: sync_with_stdio(false); cin.tie(0); }\n#endif\n\n#ifdef DEBUG\n    #define dbg(s) {s;}\n#endif\n\n#ifndef DEBUG\n    #define dbg(s)\n#endif\n\nusing namespace std;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint grand(int x) {\n    return uniform_int_distribution<int>(0, x - 1)(rng);\n}\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair< int, int > pii;\ntypedef vector < int > vi;\n\nconst int maxn = 2e5 + 7;\n\nconst ll inf = 1e15;\n\nconst ll md = 1e9 + 7;\n\n\nll gcd(ll x, ll y) {\n    if (x < y) return gcd(y, x);\n    if (y == 0) return x;\n    return gcd(y, x % y);\n}\n\nll a[maxn];\nll sz[maxn];\npair<ll, int> q[maxn];\nmap<ll, int> M;\nvector < int > G[maxn];\n\nll tsz[maxn];\nll f[maxn];\n\nvoid dfs(int x, int pi) {\n    sz[x] = 1; f[x] = 0;\n    for (int y : G[x]) {\n        if (y == pi) continue;\n        dfs(y, x);\n        sz[x] += sz[y];\n        f[x] += f[y] + sz[y];\n    }\n}\n\nint main() {\n    //freopen(\"<file>.in\", \"r\", stdin);\n    //freopen(\"<file>.out\", \"w\", stdout);\n\n    IOS;\n\n    int n; cin >> n;\n    \n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n        q[i] = {a[i], i};\n        sz[i] = 1;\n        M[a[i]] = i;\n    }\n\n    sort(q + 1, q + n + 1);\n\n    int eg = 0;\n    vector < pii > veg;\n\n    \n    for (int i = n; i >= 1; i--) {\n        int j = q[i].S;\n        ll curz = n - sz[j] - sz[j];\n        if (a[j] - curz < a[j]) {\n            int y = M[a[j] - curz];\n            if (y) {\n                G[y].pb(j); G[j].pb(y);\n                veg.pb({y, j});\n                sz[y] += sz[j];\n                eg++;\n            }\n        }\n    }\n\n    if (eg < n - 1) {\n        cout << -1 << endl; return 0;\n    }\n\n    dfs(1, -1);\n\n    if (f[1] != a[1]) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    for (pii e : veg) {\n        cout << e.F << \" \" << e.S << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef pair<ll,ll> P;\nlong long int INF = 1e18;\ndouble Pi = 3.1415926535897932384626;\nlong long int mod = 1000000007;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"RULD\";\n//↓,→,↑,←\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,a,b) for(i=a;i<=b;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\n\n\n\nll i,j,k,ii,jj;\nll n,m,num;\nll a,b,c,e,f,g,h;\nll x[800005],y[800005],z[900005];\nll d[800005],dp[500005];\nll vnum = 0,sum;\nbool dame;\nbool check[500005];\n\n\nvoid unite(ll a,ll b){\n    x[vnum] = a;\n    y[vnum] = b;\n    G[a].pb(b);\n    G[b].pb(a);\n    vnum++;\n}\n\nvoid dfs(ll v,ll dpn){\n    if(check[v]){\n        return;\n    }else{\n        sum += dpn;\n        check[v] = true;\n        for(int i=0;i<G[v].size();i++){\n            if(!check[G[v][i]])dfs(G[v][i],dpn + 1);\n        }\n    }\n}\nint main(){\n    cin>>n;\n    for(i=0;i<n;i++){\n        cin>>d[i];\n        z[i] = d[i];\n    }\n    sort(d,d+n);\n    for(i=0;i<n;i++){\n        z[i] = (lb(d,d+n,z[i]) - d) * 100001 + i;\n    }\n    sort(z,z+n);\n    //reverse(d,d+n);\n    for(i=n-1;i>=1;i--){\n        //大きい数字から見て行くよ\n        dp[i]++;\n        num = d[i] - n + 2* dp[i];\n        a = lb(d,d+n,num) - lb(d,d+n,-1);\n        if(d[a] != num || a >= i){\n            dame = true;\n            break;\n        }else{\n            dp[a] = dp[i];\n            unite(a+1,i+1);\n        }\n    }\n    sum = 0;\n    dfs(1,0);\n    //p(sum);\n    if(sum != d[0]){\n        dame = true;\n    }\n    if(dame){\n        p(-1);\n        return 0;\n    }else{\n        for(i=0;i<vnum;i++){\n            pe(z[x[i]-1]%100001 + 1);p(z[y[i]-1]%100001 + 1);\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=100005;\nint n,size[N],st[N],to[N<<1],tto[N],last[N],Next[N<<1],edge;\nlong long D;\nstruct note{\n\tlong long dis;\n\tint x;\n}d[N];\nbool cmp(note x,note y){\n\treturn x.dis>y.dis;\n}\nusing std::map;\nmap<long long,int> m;\nvoid add(int x,int y){\n\tto[++edge]=y;\n\tNext[edge]=last[x];\n\tlast[x]=edge;\n}\nint dfs(int x,int fa,long long now){\n\tD+=now;\n\tfor (int i=last[x];i;i=Next[i])\n\t\tif (to[i]!=fa)\n\t\t\tdfs(to[i],x,now+1);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) {\n\t\tscanf(\"%lld\",&d[i].dis);\n\t\td[i].x=i;\n\t\tm[d[i].dis]=i;\n\t}\n\tstd::sort(d+1,d+n+1,cmp);\n\tfor (int i=1;i<=n;i++) size[i]=1;\n\tfor (int i=1;i<n;i++){\n\t\tlong long dis=d[i].dis;\n\t\tint x=d[i].x;\n\t\tlong long t=dis-abs(n-2*size[x]);\n\t\tint fa=m.find(t)->second;\n\t\tif (fa==x || !fa){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsize[fa]+=size[x];\n\t\tst[i]=x,tto[i]=fa;\n\t\tadd(x,fa),add(fa,x);\n\t}\n\tdfs(d[n].x,0,0);\n\tif (D!=d[n].dis){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++) printf(\"%d %d\\n\",st[i],tto[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<long long int>v(N);\n\tM = LLONG_MAX;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> v[i];\n\t\tif (v[i] > N*(N - 1) / 2) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tM = min(M, v[i]);\n\t}\n\tint box = 0;\n\tmap<long long int, int>m;\n\tfor (int i = 0; i < N; i++) {\n\t\tm[v[i] - M] = i;\n\t}\n\tvector<pair<int, int>>ans;\n\twhile (m.size() > 1) {\n\t\tauto  box = *m.rbegin();\n\t\tlong long int c = box.first;\n\t\tint cn = box.second;\n\t//\tcout << c << \" \" << cn << endl;\n\t\tlong long int a, b = 0;\n\t\tfor (long long int i = c / (N - 1) + !!(c % (N - 1)); i <= sqrt(c); i++) {\n\t\t\tif (c%i)continue;\n\t\t\ta = i;\n\t\t\tb = c / i;\n\t\t\tlong long int st = (b  - (a - 1));\n\t\t\tlong long int add = st;\n\t\t//\tcout << a << \" \" << b << \" \" << st << \" \" << add << endl;\n\t\t\tbool flag = true;\n\t\t\twhile (st < c) {\n\t\t\t\tif (m.find(st) == m.end()) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tadd += 2;\n\t\t\t\tst += add;\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tst = (b - (a - 1));\n\t\t\t\tadd = st;\n\t\t\t\tint bef = m[0];\n\t\t\t\twhile (st <= c) {\n\t\t\t//\t\tcout << st << endl;\n\t\t\t\t\tans.push_back({ bef,m[st] });\n\t\t\t\t\tbef = m[st];\n\t\t\t\t\tm.erase(st);\n\t\t\t\t\tadd += 2;\n\t\t\t\t\tst += add;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto i : ans) {\n\t\tcout << i.first + 1 << \" \" << i.second + 1 << endl;\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <cmath>\n#include <bitset>\n#include <algorithm>\n#include <map>\n#include <vector>\ntypedef long long ll;\nusing namespace std;\nconst int maxn=101000;\nint n;\nll d[maxn];\nint size[maxn];\nll dis[maxn];\nmap<ll,int> mp;\nvector<int> G[maxn];\nll sum=0;\n\nvoid dfs1(int u,int fa){\n    for(int i=0;i<G[u].size();i++){\n        int v=G[u][i];\n        if(v==fa) continue;\n        dis[v]=dis[u]+1;\n        dfs1(v,u);\n    }\n    sum+=dis[u];\n}\n\nvoid dfs2(int u,int fa){\n    for(int i=0;i<G[u].size();i++){\n        int v=G[u][i];\n        if(v==fa) continue;\n        printf(\"%d %d\\n\",u,v);\n        dfs2(v,u);\n    }\n}\n\nint main(){\n    //初始化\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        scanf(\"%lld\",&d[i]);\n        mp[d[i]]=i;\n    }\n    sort(d+1,d+n+1);\n    for(int i=1;i<=n;i++) size[i]=1;\n    //构树\n    for(int i=n;i>1;i--){\n        int k=mp[d[i]];\n        int tmp=n-2*size[k];\n        //printf(\"%d   111\\n\",i);\n        if(tmp<=0) {printf(\"-1\\n\");return 0;}\n        ll ss=d[i]-tmp;\n        //printf(\"%d    222\\n\",i);\n        if(mp.count(ss)==0){printf(\"-1\\n\");return 0;}\n        int pos=mp[ss];\n        size[pos]+=size[k];\n        G[pos].push_back(k);\n        G[k].push_back(pos);\n    }\n   // printf(\"sbsbsb\\n\");\n    dis[mp[d[1]]]=0;\n    dfs1(mp[d[1]],-1);\n    if(sum!=d[1]){\n        printf(\"-1\\n\");\n    }else{\n        dfs2(1,-1);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nThough leaves are many, the root is one;\nThrough all the lying days of my youth\nI swayed my leaves and flowers in the sun,\nNow may I wither into the truth.\n\n- William Butler Yeats\n*/\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <string.h>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <cassert>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <sstream>\n#include <functional>\n#include <iomanip>\n#include <bitset>\n//#include <windows.h>  //Should be deleted when using AtCoder&POJ\nusing namespace std;\n\n#define ll long long\n#define pii pair<int,int>\n#define qi ios::sync_with_stdio(0)\n/**==Info==\n*Program:6\n*Problem:Distance Sums\n*Date:2019-7-12\n*Algorithm:Orange Boy's Greedy and Sorting\n*Stats:WA*/\n\nbool debug=false;\n\n\ntemplate<typename T1,typename T2> ostream& operator<<(ostream& o,pair<T1,T2> p){\n\to<<\"{\";\n\to<<p.first<<\",\"<<p.second;\n\to<<\"}\";\n\treturn o;\n}\n\nll n;\nll d[100005];\nmap <ll,ll> m;\npair<ll,ll> p[100005];\nll sub[100005];\nll sz[100005];\nvector <pair<ll,ll> >res;\n \n int fa[100005];\n \nint getFa(int x){\n\tif(fa[x]==x){\n\t\treturn x;\n\t}\n\treturn fa[x]=getFa(fa[x]);\n}\n \n \nvoid Union(int a,int b){\n\tif(fa[a]==fa[b]){\n\t\treturn;\n\t}\n\tfa[getFa(a)]=getFa(b);\n}\n\nll dp[100005];\n\nll dis[100005];\n\nvector<int> nei[100005];\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin>>n;\n\tfor(ll i=0;i<n;i++)\n\t{\n\t\tcin>>d[i];\n\t\tif(d[i]>n*(n-1)/2){\n\t\t\tcout<<-1;\n\t\t\treturn 0;\n\t\t}\n\t\tm[d[i]]=i;\n\t\tp[i].first=d[i];\n\t\tp[i].second=i;\n\t\tsz[i]=1;\n\t}\n\tsort(p,p+n);\n\treverse(p,p+n);\n\tmemset(sub,-1,sizeof(sub));\n\tfor(ll i=0;i<n-1;i++)\n\t{\n\t\tll de=p[i].first;\n\t\tll x=p[i].second;\n\t\tsub[x]=n-sz[x]*2;\n\t\tif(sub[x]==0){\n\t\t\tcout<<-1;\n\t\t\treturn 0;\t\n\t\t}\n\t\tif(m.find(de-sub[x])==m.end()){\n\t\t\tcout<<-1;\n\t\t\treturn 0;\n\t\t}\n\t\tll par=m[de-sub[x]];\n\t\tsz[par]+=sz[x];\n\t\tdp[par]+=dp[x]+sz[x];\n\t\tres.push_back(make_pair(x,par));\n\t}\n\t\n\tfor(int i=0;i<n-1;i++){\n\t\tnei[res[i].first].push_back(res[i].second);\n\t\tnei[res[i].second].push_back(res[i].first);\n\t}\n\t\n\tqueue<int> q;\n\tmemset(dis,-1,sizeof(dis));\n\tq.push(p[n-1].second);\n\tdis[p[n-1].second]=0;\n\t\n\twhile(!q.empty()){\n\t\tint last=q.front();\n\t\tq.pop();\n\t\t\n\t\tfor(int to:nei[last]){\n\t\t\tif(dis[to]==-1){\n\t\t\t\tdis[to]=dis[last]+1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tll sm=0;\n\tfor(int i=0;i<n;i++){\n\t\tsm+=dis[i];\n\t}\n\tif(sm!=p[n-1].first){\n\t\tcout<<-1;\n\t\treturn 0;\n\t}\n\t\n\tfor(ll i=0;i<n-1;i++)\n\t{\n\t\tcout<<res[i].first+1<<\" \"<<res[i].second+1<<endl;\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i, x, y) for(int i = (x); i < (y); ++i)\n#define REP(i, x, y) for(int i = (x); i <= (y); ++i)\n#define MP make_pair\n#define PB push_back\n#define PH push\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair<int, int> pii;\n\nconst int maxn = 1e5 + 5;\n\nint n;\nint sz[maxn];\nll a[maxn], dis[maxn];\nvector<pair<ll, int> > ord;\nmap<ll, int> mp;\nvector<int> g[maxn];\n\ninline void dfs(int u, int p){\n\tdis[u] = 0;\n\t//printf(\"u = %d sz = %d\\n\", u, sz[u]);\n\tFOR(i, 0, g[u].size()){\n\t\tint v = g[u][i];\n\t\tif(v == p) continue;\n\t\tdfs(v, u);\n\t\tdis[u] += dis[v] + sz[v];\n\t}\n\treturn;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tFOR(i, 0, n){\n\t\tscanf(\"%lld\", a + i);\n\t\tord.PB(MP(a[i], i));\n\t\tmp[a[i]] = i;\n\t}\n\tsort(ord.begin(), ord.end());\n\tFOR(i, 0, n) sz[i] = 1;\n\tfor(int i = ord.size() - 1; i >= 0; --i){\n\t\tint u = ord[i].snd;\n\t\tll d = ord[i].fst;\n\t\t//printf(\"i = %d\\n\", i);\n\t\tif(!i){\n\t\t\tdfs(u, -1);\n\t\t\tif(dis[u] != d){\n\t\t\t\t//FOR(i, 0, n) printf(\"%lld \", dis[u]); puts(\"\");\n\t\t\t\t//printf(\"::%lld %lld\\n\", dis[u], d);\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t//printf(\"%lld %lld\\n\", d, d - n + sz[u] * 2);\n\t\tif(mp.find(d - n + sz[u] * 2) != mp.end()){\n\t\t\tint p = mp[d - n + sz[u] * 2];\n\t\t\t//printf(\"p = %d u = %d\\n\", p, u);\n\t\t\tsz[p] += sz[u];\n\t\t\tg[p].PB(u);\n\t\t\tg[u].PB(p);\n\t\t}\n\t\telse{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tFOR(u, 0, n) FOR(i, 0, g[u].size()){\n\t\tint v = g[u][i];\n\t\tif(u < v) printf(\"%d %d\\n\", u + 1, v + 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nconst long long mo=10000007;\nconst int maxn=100010;\n\nint n,m,d[maxn],id[maxn],siz[maxn],fa[maxn];\nlong long ans,js[maxn];\nint tot,nex[maxn*2],las[maxn*2],tov[maxn*2];\nint hs[mo];\n\nvoid con(int x,int y)\n{\n\ttot++;\n\ttov[tot]=y;\n\tnex[tot]=las[x];\n\tlas[x]=tot;\n}\n\nvoid insert(long long x,int id)\n{\n\tlong long i=x%mo;\n\twhile (hs[i]!=0)\n\t{\n\t\ti++;\n\t\tif (i==mo) i=0;\n\t}\n\ths[i]=id;\n}\n\nint find(long long x)\n{\n\tlong long i=x%mo;\n\twhile (hs[i]!=0 && d[hs[i]]!=x)\n\t{\n\t\ti++;\n\t\tif (i==mo) i=0;\n\t}\n\treturn hs[i];\n}\n\nvoid qsort(int l,int r)\n{\n\tint i=l;int j=r;\n\tlong long m=d[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (d[i]>m) i++;\n\t\twhile (d[j]<m) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(d[i],d[j]);\n\t\t\tswap(id[i],id[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort(l,j);\n\tif (r>i) qsort(i,r); \n}\n\nvoid dfs(int x,int ff)\n{\n\tjs[x]=js[ff]+1;\n\tfor (int i=las[x];i;i=nex[i])\n\t{\n\t\tif (tov[i]!=ff)\n\t\t{\n\t\t\tdfs(tov[i],x);\n\t\t\tans+=js[x];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&d[i]);\n\t\tid[i]=i;\n\t\tsiz[i]=1;\n\t}\n\tqsort(1,n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinsert(d[i],i);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tlong long op=d[i]-abs(n-2*siz[i]);\n\t\tint oq=find(op);\n\t\tif (oq==0)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfa[i]=oq;\n\t\t\tsiz[oq]+=siz[i];\n\t\t\tcon(i,oq);con(oq,i);\n\t\t}\n\t}\n\tdfs(n,0);\n\tif (ans!=d[n])\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tfor (int i=1;i<n;i++)\n\t\t{\n\t\t\tprintf(\"%d %d\\n\",id[i],id[fa[i]]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cassert>\n#include<iostream>\n#include<algorithm>\n#include<unordered_map>\n\nusing namespace std;\n\n#define Whats(x) cout<<#x<<\" is \"<<(x)<<endl\n#define DivHim() cout<<\">>>>>>>>>>>>>>>\"<<endl\n#define DivHer() cout<<\"<<<<<<<<<<<<<<<\"<<endl\n#define Oops() cout<<\"!!!!!!!!!!!!!!!\"<<endl\n\ntemplate<typename T> bool GetMin(T &a,T b)\n{\n\treturn ((a<=b)?false:(a=b,true));\n}\n\ntemplate<typename T> bool GetMax(T &a,T b)\n{\n\treturn ((a>=b)?false:(a=b,true));\n}\n\n/*\n\t -<Unlimited Blade Works>-\n */\n\n#define int long long\n\nconst int N=1e5+10;\n\nint n,d[N],id[N],sz[N],fa[N];\nunordered_map<int,int> re;\n\nbool Cmp(int x,int y)\n{\n\treturn d[x]>d[y];\n}\n\nsigned main()\n{\n\tscanf(\"%lld\",&n);\n\tif(n==2)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%lld\",d+i);\n\t\tre[d[i]]=i;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tid[i]=i;\n\t\tsz[i]=1;\n\t}\n\tsort(id+1,id+n+1,Cmp);\n\tfor(int i=1,u,v;i<n;++i)\n\t{\n\t\tre[d[u=id[i]]]=0;\n\t\tv=re[d[u]-n+sz[u]+sz[u]];\n\t\tif(!v)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsz[fa[u]=v]+=sz[u];\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tif(fa[i])\n\t\t\tprintf(\"%lld %lld\\n\",fa[i],i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EB emplace_back\n\ntypedef long long ll;\ntypedef std::pair <int, int> pr;\nconst int N = 100054;\n\nint n;\nint o[N], size[N];\nint p[N], fc[N], nc[N];\nll D[N];\nstd::vector <pr> edges;\n\ninline bool Dcmp(const int x, const int y) {return D[x] > D[y];}\n\ninline bool find(ll x, int &ret) {return *D = x, ret = std::lower_bound(o, o + n, 0, Dcmp) - o, D[o[ret]] == x;}\n\ninline void link(int x, int px) {p[x] = px, nc[x] = fc[px], fc[px] = x, size[px] += size[x];}\n\nvoid dfs(int x, int d) {*D += d; for (int y = fc[x]; y; y = nc[y]) dfs(y, d + 1);}\n\nint main() {\n\tint i, j, u;\n\tscanf(\"%d\", &n), std::iota(o, o + n, 1);\n\tfor (i = 1; i <= n; ++i) scanf(\"%lld\", D + i);\n\tstd::sort(o, o + n, Dcmp), std::fill(size + 1, size + (n + 1), 1);\n\tfor (i = 0; i < n - 1; link(u, o[j]), ++i)\n\t\tif (u = o[i], !find(D[u] + 2 * size[u] - n, j) || j <= i) return puts(\"-1\"), 0;\n\tif (dfs(o[i], *D = 0), *D != D[o[i]]) return puts(\"-1\"), 0;\n\tfor (i = 1; i <= n; ++i) if (p[i]) edges.EB(std::minmax(i, p[i]));\n\tstd::sort(edges.begin(), edges.end());\n\tfor (const pr &e : edges) printf(\"%d %d\\n\", e.first, e.second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,int>P;\n\nint n;\nP d[200000];\nvector<int>E[200000];\nint sz[200000];\nll dp1[200000],dp2[200000];\nvector<pair<int,int>>ans;\n\nvoid dfs1(int v){\n\tfor(int u:E[v]){\n\t\tdfs1(u);\n\t\tdp1[v]+=dp1[u]+sz[u];\n\t}\n}\nvoid dfs2(int v,int p){\n\tif(p==-1)dp2[v]=dp1[v];\n\telse dp2[v]=dp2[p]+n-2*sz[v];\n\tfor(int u:E[v]){\n\t\tans.push_back({u+1,v+1});\n\t\tdfs2(u,v);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%lld\",&d[i].first);\n\t\td[i].second=i;\n\t}\n\trep(i,n)sz[i]=1;\n\tsort(d,d+n);\n\tfor(int i=n-1;i>0;i--){\n\t\tint c=d[i].first-n+2*sz[d[i].second];\n\t\tint id=lower_bound(d,d+n,P(c,0))-d;\n\t\tif(id==n||d[id].first!=c){\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t\tE[d[id].second].push_back(d[i].second);\n\t\tsz[d[id].second]+=sz[d[i].second];\n\t}\n\tdfs1(d[0].second);\n\tdfs2(d[0].second,-1);\n\trep(i,n){\n\t\tif(dp2[d[i].second]!=d[i].first){\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t}\n\tfor(auto p:ans){\n\t\tprintf(\"%d %d\\n\",p.first,p.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n,cnt,a[111111],id[111111],w[111111],u[111111],v[111111],siz[111111];\nbool vis[111111];\nbool cmp(int x,int y){return a[x]<a[y];}\nvoid add(int x,int y){u[++cnt]=x,v[cnt]=y;}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),id[i]=i,w[i]=a[i],siz[i]=1;\n\tsort(id+1,id+n+1,cmp),sort(w+1,w+n+1);\n\tfor(int i=n;i>1;i--){\n\t\tint x=2*siz[id[i]]-n+a[id[i]],pos=lower_bound(w+1,w+n+1,x)-w;\n\t\tif(w[pos]!=x||x==w[i])continue;\n\t\tadd(id[pos],id[i]),siz[id[pos]]+=siz[id[i]];\n\t}\n\tif(cnt!=n-1){printf(\"-1\");return 0;}\n\tfor(int i=1;i<=cnt;i++)printf(\"%lld %lld\\n\",u[i],v[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "// Author -- Frame\n\n#include<bits/stdc++.h>\n\n#define lowbit(x) ((x)&(-x))\n#define Finline __inline__ __attribute__ ((always_inline))\n#define DEBUG fprintf(stderr,\"Running on Line %d in Function %s\\n\",__LINE__,__FUNCTION__)\n#define SZ(x) ((int)x.size())\n\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n\nconst int inf=0x3f3f3f3f,Inf=0x7fffffff;\nconst ll INF=0x7fffffffffffffff;\nconst double eps=1e-10;\n\ntemplate <typename _Tp>_Tp gcd(const _Tp &a,const _Tp &b){return (!b)?a:gcd(b,a%b);}\ntemplate <typename _Tp>Finline _Tp abs(const _Tp &a){return a>=0?a:-a;}\ntemplate <typename _Tp>Finline _Tp max(const _Tp &a,const _Tp &b){return a<b?b:a;}\ntemplate <typename _Tp>Finline _Tp min(const _Tp &a,const _Tp &b){return a<b?a:b;}\ntemplate <typename _Tp>Finline void chmax(_Tp &a,const _Tp &b){(a<b)&&(a=b);}\ntemplate <typename _Tp>Finline void chmin(_Tp &a,const _Tp &b){(b<a)&&(a=b);}\ntemplate <typename _Tp>Finline bool _cmp(const _Tp &a,const _Tp &b){return abs(a-b)<=eps;}\ntemplate <typename _Tp>Finline void read(_Tp &x)\n{\n\tregister char ch(getchar());\n\tbool f(false);\n\twhile(ch<48||ch>57) f|=ch==45,ch=getchar();\n\tx=ch&15,ch=getchar();\n\twhile(ch>=48&&ch<=57) x=(((x<<2)+x)<<1)+(ch&15),ch=getchar();\n\tif(f) x=-x;\n}\ntemplate <typename _Tp,typename... Args>Finline void read(_Tp &t,Args &...args)\n{\n\tread(t);read(args...);\n}\nFinline int read_str(char *s)\n{\n\tregister char ch(getchar());\n\twhile(ch==' '||ch=='\\r'||ch=='\\n') ch=getchar();\n\tregister char *tar=s;\n\t*tar=ch,ch=getchar();\n\twhile(ch!=' '&&ch!='\\r'&&ch!='\\n'&&ch!=EOF) *(++tar)=ch,ch=getchar();\n\treturn tar-s+1;\n}\n\nconst int N=100005;\nll d[N];\nstruct node{\n\tint u;\n\tll d;\n\tFinline bool operator < (const node &o)const\n\t{\n\t\treturn d<o.d;\n\t}\n};\nstd::priority_queue<node> q;\nstd::map<ll,int> mp;\nint siz[N];\nstd::vector<int> e[N];\nint main()\n{\n\tint n;\n\tread(n);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tread(d[i]);\n\t\tmp[d[i]]=i;\n\t\tq.push((node){i,d[i]});\n\t\tsiz[i]=1;\n\t}\n\tif(n==1)\n\t{\n\t\tif(d[1]!=1)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t}\n\t\treturn 0;\n\t}\n\tif(n==2)\n\t{\n\t\tif(d[1]==1&&d[2]==1)\n\t\t{\n\t\t\tprintf(\"1 2\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t}\n\t\treturn 0;\n\t}\n\tstd::vector<std::pair<int,int> > v;\n\tint qwq=0;\n\twhile(!q.empty())\n\t{\n\t\tnode x=q.top();\n\t\tq.pop();\n\t\tif(q.empty())\n\t\t{\n\t\t\tqwq=x.u;\n\t\t\tbreak;\n\t\t}\n\t\tif(mp.find(x.d+2*siz[x.u]-n)==mp.end())\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tint id=mp[x.d+2*siz[x.u]-n];\n\t\tv.push_back(std::make_pair(x.u,id));\n\t\tsiz[id]+=siz[x.u];\n\t}\n\tfor(auto it:v) e[it.second].push_back(it.first);\n\tll ans=0;\n\tstd::function<void(int,int)> dfs=[&](int x,int dep)\n\t{\n\t\tans+=dep;\n\t\tfor(auto it:e[x]) dfs(it,dep+1);\n\t};\n\tdfs(qwq,0);\n\tif(ans!=d[qwq])\n\t{\n\t\tprintf(\"-1\\n\");\n\t}\n\telse\n\t{\n\t\tfor(auto it:v) printf(\"%d %d\\n\",it.first,it.second);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint n;\nmap<LL, PII> S;\nvector<PII> ans;\nLL offset;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\trep(i, n) {\n\t\tLL d;\n\t\tscanf(\"%lld\", &d);\n\t\tS[d] = MP(1, i + 1);\n\t}\n\twhile(S.size() >= 2) {\n\t\tpair<LL, PII> cur = *S.rbegin();\n\t\tS.erase(cur.first);\n\t\tLL nd = cur.first - n + 2 * cur.second.first;\n\t\tif(S.find(nd) == S.end()) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tS[nd].first += cur.second.first;\n\t\toffset += cur.second.first;\n\t\tans.push_back(MP(cur.second.second, S[nd].second));\n\t}\n\tif(S.begin()->first != offset) printf(\"-1\\n\");\n\telse rep(i, ans.size()) printf(\"%d %d\\n\", ans[i].first, ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n#include<bits/stdc++.h>\n#define int long long\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\ntypedef long long ll;\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\ninline string getstr(string &s,int l,int r){string ret=\"\";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){if(y==0)return 1;int ret=modpow(x,y>>1,md);ret=(ll)ret*ret%md;if(y&1)ret=(ll)ret*x%md;return ret;}\nint n;\npair<int,int> d[100005];\nvector<int>g[100005];\nmap<int,int>mp;\nint sz[1000005],dp[100005];\nvector<pair<int,int> >ans; \nint dfs(int x,int p){\n\tfor(int i=0;i<g[x].size();i++){\n\t\tint to=g[x][i];\n\t\tif(to!=p) dp[x]+=dfs(to,x)+sz[to];\n\t}\n\treturn dp[x];\n}\nsigned main(){\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>d[i].first;d[i].second=i;\n\t\tmp[d[i].first]=i;sz[i]=1;\n\t}\n\twhile(mp.size()>1){\n\t\tpair<int,int>p=*mp.rbegin();mp.erase(p.first);\n\t\tint now=p.second,size=sz[now],val=p.first;\n\t\tint nxt=val+size+size-n;\n\t\tif(!mp.count(nxt)){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}else{\n\t\t\tsz[mp[nxt]]+=sz[now];\n\t\t\tans.push_back(make_pair(now,mp[nxt]));\n\t\t}\n\t}\n\tfor(auto p:ans){\n\t\tg[p.first].push_back(p.second);\n\t\tg[p.second].push_back(p.first);\n\t}\n\tif(dfs(1,0)!=d[1].first) puts(\"-1\");\n\telse for(auto p:ans) cout<<p.first<<\" \"<<p.second<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N = 1e5 + 10;\nlong long rn, n, d[N], s[N];\nvector<int> gr[N];\nmap<long long, int> mp;\nvoid dfs(int v, int h = 0) {\n\tfor (auto u : gr[v])\n\t\tdfs(u, h + 1);\n\trn += h;\n}\nint32_t main() {\n\tios_base::sync_with_stdio (false), cin.tie(0), cout.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> d[i], mp[d[i]] = i;\n\tsort(d, d + n, greater<int> ());\n\tfill(s, s + n + 1, 1);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint v = mp[d[i]], valpar = d[i] - n + 2 * s[v];\n\t\tif (!mp.count(valpar)) {\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\tint par = mp[valpar];\n\t\tif (par == v) {\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\ts[par] += s[v], gr[par].push_back(v);\n\t}\n\tdfs(mp[d[n - 1]]);\n\tif (rn != d[n - 1]) {\n\t\tcout << -1;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (auto u : gr[i])\n\t\t\tcout << i + 1 << \" \" << u + 1 << \"\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#define LL long long\nusing namespace std;\nconst LL Maxn = 100010;\nLL n, a[Maxn];\nLL siz[Maxn];\nstruct lnode {\n\tLL x, y;\n}lis[Maxn]; LL ll;\nqueue <LL> q[2];\nLL dis[Maxn];\nvector <LL> vec[Maxn];\nvoid dfs(LL x) {\n\tdis[x] = 0; siz[x] = 1;\n\tfor(LL i = 0; i < vec[x].size(); i++){\n\t\tLL y = vec[x][i];\n\t\tdfs(y);\n\t\tdis[x] += dis[y]+siz[y];\n\t\tsiz[x] += siz[y];\n\t}\n}\nstruct pnode {\n\tLL num, x;\n\tbool operator<(const pnode &A) const { return x < A.x; }\n}po[Maxn];\nint main() {\n\tLL i, j, k;\n\tscanf(\"%lld\", &n);\n\tfor(i = 1; i <= n; i++) scanf(\"%lld\", &po[i].x), po[i].num = i;\n\tsort(po+1, po+n+1);\n\tfor(i = 1; i <= n; i++) a[i] = po[i].x;\n\tfor(i = 1; i <= n; i++) siz[i] = 1;\n\tfor(i = n; i >= 2; i--){\n\t\tint x = lower_bound(a+1, a+n+1, a[i]-n+2*siz[i]) - a;\n\t\tif(a[x] != a[i]-n+2*siz[i]){ printf(\"-1\\n\"); return 0; }\n\t\tll++;\n\t\tlis[ll].x = x; lis[ll].y = i;\n\t\tsiz[x] += siz[i];\n\t}\n\tfor(i = 1; i <= ll; i++) vec[lis[i].x].push_back(lis[i].y);\n\tdfs(1);\n\tif(dis[1] != a[1]){ printf(\"-1\\n\"); return 0; }\n\tfor(i = 1; i <= ll; i++) printf(\"%lld %lld\\n\", po[lis[i].x].num, po[lis[i].y].num);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\nusing ll = long long;\nusing namespace std;\n\nvector<pair<int, int> > solve(int n, vector<ll> const & d) {\n    map<ll, int> index;\n    REP (i, n) {\n        index[d[i]] = i;\n    }\n\n    int root = index.begin()->second;\n    vector<pair<int, int> > edges;\n    vector<int> size(n, 1);\n    vector<ll> d1(n, 0);\n    for (auto it = index.rbegin(); ; ++ it) {\n        ll d_i; int i; tie(d_i, i) = *it;\n        if (i == root) break;\n        ll d_parent = d_i - n + 2 * size[i];\n        if (not index.count(d_parent)) {\n            return vector<pair<int, int> >();\n        }\n        int parent = index[d_parent];\n        edges.emplace_back(parent, i);\n        size[parent] += size[i];\n        d1[parent] += d1[i] + size[i];\n    }\n\n    if (d1[root] != d[root]) {\n        return vector<pair<int, int> >();\n    }\n    return edges;\n}\n\nint main() {\n    int n; cin >> n;\n    vector<ll> d(n);\n    REP (i, n) cin >> d[i];\n    auto edges = solve(n, d);\n    if (edges.empty()) {\n        cout << -1 << endl;\n    } else {\n        for (auto edge : edges) {\n            int i, j; tie(i, j) = edge;\n            cout << i + 1 << ' ' << j + 1 << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int N;\n    cin >> N;\n\n    set<array<ll, 3>> pieces;\n\n    vll ds(N);\n    for (int i = 0; i < N; i++) {\n        cin >> ds[i];\n        pieces.insert({ ds[i], 1, i });\n    }\n\n    vector<pair<int, int>> edges;\n    while (pieces.size() > 1) {\n        auto p = *pieces.rbegin();\n        ll match = p[0] + 2 * p[1] - N;\n        auto qi = pieces.lower_bound({ match, -1, -1 });\n        if (qi == pieces.end() || (*qi)[0] != match) {\n            cout << -1 << endl;\n            return 0;\n        }\n        auto q = *qi;\n\n        edges.emplace_back(p[2], q[2]);\n        array<ll, 3> comb = { q[0], p[1] + q[1], q[2] };\n\n        pieces.erase(p);\n        pieces.erase(q);\n        pieces.insert(comb);\n    }\n\n    for (auto p : edges) {\n        cout << p.first + 1 << \" \" << p.second + 1 << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n\n#define LOG(...) fprintf (stderr, __VA_ARGS__)\n#define pb push_back\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n\nconst int INF = 0x3f3f3f3f, N = 100005;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fll;\n\nint n, sz[N];\npair <LL, int> d[N];\nbool cmp(pair <LL, int> a, pair <LL, int> b) { return a.first > b.first; }\nmap <int, int> mp;\nvector <int> g[N];\nvoid link(int x, int y){\n    g[x].push_back(y);\n//    g[y].push_back(x); \n}\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) scanf(\"%lld\", &d[i].first), d[i].second = i, mp[d[i].first] = i; \n\n    sort (d + 1, d + n + 1, cmp);\n    int root = d[n].second;\n    for (int i = 1; i <= n; i++) sz[i] = 1; \n    for (int i = 1; i < n; i++) {\n        LL fa = d[i].first - n + 2 * sz[d[i].second];\n        if (mp[fa]) {\n            int ff = mp[fa];\n            if (ff == d[i].second) return 0*puts(\"-1\");\n            sz[ff] += sz[d[i].second]; link(ff, d[i].second); \n        }\n        else return 0*puts(\"-1\");\n    }\n\n    for(int i = 1; i <= n; i++)\n        for (int j = 0; j < g[i].size(); j++)\n            cout << i << \" \" << g[i][j] << endl; \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<vector>\n#include<queue>\n#include<deque>\n#define ll long long\n#define mp make_pair\n#define rep(i,x,y) for(int i=(x);i<=(y);++i)\n#define r0p(i,n) for(int i=0;i<n;++i)\n#pragma GCC optimize(1)\n#pragma G++ optimize(1)\n#pragma GCC optimize(2)\n#pragma G++ optimize(2)\n#pragma GCC optimize(3)\n#pragma G++ optimize(3)\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#define pii pair<int,int>\n#pragma GCC diagnostic error \"-std=c++11\"\nusing namespace std;\ninline void rdl(long long &val){\n    long long x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n\t}\n\twhile(ch>='0' and ch<='9'){\n\t    x=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n    val=x*f;\n}\ninline void rdi(int &val){\n    int x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    val=x*f;\n}\ninline long long rdl(){\n    long long x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline int rdi(){\n    int x=0;\n    int f=1;\n\tchar ch=getchar();\n\twhile((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n\tif(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline void write(int x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\ninline void _write(int x){\n\twrite(x);\n\tputchar(' ');\n}\ninline void print(int x){\n\twrite(x);\n\tputchar('\\n');\n}\ninline void write(ll x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\ninline void _write(ll x){\n\twrite(x);\n\tputchar(' ');\n}\ninline void print(ll x){\n\twrite(x);\n\tputchar('\\n');\n}\nstruct dsu{\n\tint par[200200];\n\tinline void init(int _n){for(int i=0;i<_n;++i) par[i]=i;}\n\tinline int find(int now){\n\t\tif(par[now]==now) return now;\n\t\treturn par[now]=find(par[now]);\n\t}\n\tinline bool uni(int a, int b){\n\t\tint Pa(find(a)),Pb(find(b));\n\t\tif(Pa==Pb) return false;\n\t\tpar[Pa]=Pb;\n\t\treturn true;\n\t}\n};\nmap<ll,int> m;\nmap<int,ll>m2;\nvector<pair<int,int> >ans;\nint n;\nll x;\nsigned main(){\n\trdi(n);\n\tint i,j;\n\tll mn=100000000000000ll;\n\tll cnt=n;\n\tfor(i=1;i<=n;++i) rdl(x),m[x]=i,mn=min(mn,x),m2[i]=x;\n\twhile(cnt>1){\n\t\tmap<int,ll>::iterator it=m2.end();it--;\n\t\tll t=it->second;\n\t\tll now=n;\n\t\tll tt=t;\n\t\twhile(t>mn){\n\t\t\tt-=now-2;\n\t\t\tnow-=2;\n\t\t\tif(!m[t]){\n\t\t\t\tprint(-1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(now<=0){\n\t\t\t\tprint(-1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tans.push_back(mp(m[t],m[tt]));\n\t\t\tm2.erase(m[tt]);\n\t\t\tm.erase(tt);\n\t\t\ttt=t;\n\t\t\t--cnt;\n\t\t}\n\t}\n\tfor(int i=0;i<ans.size();++i) _write(ans[i].first),print(ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Link : https://atcoder.jp/contests/arc101/tasks/arc101_c\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define N 100005\n\nvector<int> adj[N];\nll d[N];\npair<ll,int> in[N];\nint sz[N];\n\nint dsz[N];\nll dd[N];\n\nvoid dfs(int node) {\n  dsz[node] = 1;\n  for(int ch : adj[node]) {\n    dfs(ch);\n    dsz[node] += dsz[ch];\n    dd[node] += dd[ch] + dsz[ch];\n  }\n}\n\nvoid dfs2(int node,ll tmp,int n) {\n  if(tmp!=d[node] || dsz[node]!=sz[node]) {\n    printf(\"-1\\n\");\n    exit(0);\n  }\n  for(int ch : adj[node]) {\n    dfs2(ch,tmp + n - sz[ch]*2,n);\n  }\n}\n\nvoid solve() {\n\n  int n;scanf(\"%d \", &n);\n  set<pair<ll,int> >s;\n  for(int i=1;i<=n;++i) {\n    scanf(\"%lld \", &in[i].first);\n    d[i] = in[i].first;\n    in[i].second = i;\n    sz[i] = 1;\n    s.insert(in[i]);\n  }\n  sort(in+1,in+n+1);\n  int pos = n;\n\n  while(s.size()>1) {\n    pair<ll,int> tmp = *prev(s.end());\n    s.erase(prev(s.end()));\n    ll dist = tmp.first;\n    int node = tmp.second;\n    pair<ll,int> tmp2 = make_pair(dist - n + sz[node]*2,0);\n    set<pair<ll,int> >::iterator it = s.lower_bound(tmp2);\n    if(it==s.end() || (*it).first!=tmp2.first) {\n      printf(\"-1\\n\");\n      return;\n    }\n    int x = (*it).second;\n    sz[x] += sz[node];\n    adj[x].push_back(node);\n  }\n  int root = in[1].second;\n  dfs(root);\n  dfs2(root,d[root],n);\n  for(int i=1;i<=n;++i) {\n    for(int ch : adj[i]) {\n      printf(\"%d %d\\n\", i,ch);\n    }\n  }\n}\n\nint main() {\n    //freopen(\"input.txt\",\"r\",stdin);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define max(a,b) (((a)>(b))?a:b)\n#define min(a,b) (((a)<(b))?a:b)\n#define int long long\nusing namespace std;\ntemplate<typename T>void read(T &x){\n\tx=0;int f=1;\n\tchar c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if (c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-48;\n\tx*=f;\n}\nint n,fa[100010],sz[100010];\nstruct ha{int d,id;}a[100010];\nbool cmp(ha x,ha y){\n\treturn x.d>y.d;\t\n}\nsigned main(){\n\tread(n);\n\tfor(int i=1;i<=n;++i)\n\t\tread(a[i].d),a[i].id=i;\n\tsort(a+1,a+1+n,cmp);\n\tfor(int i=1;i<=n;++i)\n\t\tsz[i]=1;\n\tfor(int i=1;i<n;++i){\n\t\tint xx=a[i].d-(n-sz[a[i].id])+sz[a[i].id];\n\t\tint l=i+1,r=n;\n\t\twhile(l<=r){\n\t\t\tint mid=(l+r)/2;\n\t\t\tif(a[mid].d==xx) {fa[a[i].id]=a[mid].id,sz[a[mid].id]+=sz[a[i].id];break;}\n\t\t\telse if(a[mid].d<xx) r=mid-1;\n\t\t\telse l=mid+1;\n\t\t}\n\t\tif(!fa[a[i].id]) {puts(\"-1\");return 0;}\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tif(fa[i]) printf(\"%d %d\\n\",i,fa[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace TYC\n{\n\ttypedef long long ll;\n\tconst int N = 1e5 + 5;\n\n\tint Siz[N];\n\tpair<ll, int> A[N];\n\tunordered_map<ll, int> M;\n\tvector<pair<int, int> > E;\n\n\ttemplate <typename T>\n\tinline T read()\n\t{\n\t\tT x = 0;\n\t\tint f = 0, ch = getchar();\n\t\twhile (!isdigit(ch))\n\t\t\tf |= (ch == '-'), ch = getchar();\n\t\twhile (isdigit(ch))\n\t\t\tx = x * 10 + ch - '0', ch = getchar();\n\t\treturn f ? -x : x;\n\t}\n\n\tvoid work()\n\t{\n\t\tint n = read<int>();\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tll d = read<ll>();\n\t\t\tA[i] = {d, i};\n\t\t\tM[d] = i;\n\t\t\tSiz[i] = 1;\n\t\t}\n\t\tsort(A + 1, A + 1 + n);\n\t\tfor (int i = n; i > 1; i--)\n\t\t{\n\t\t\tint v = A[i].second;\n\t\t\tll d = A[i].first + 2 * Siz[v] - n;\n\t\t\tif (d >= A[i].first || !M.count(d))\n\t\t\t\treturn void(puts(\"-1\"));\n\t\t\tint u = M[d];\n\t\t\tE.push_back({u, v});\n\t\t\tSiz[u] += Siz[v];\n\t\t}\n\t\tfor (auto p : E)\n\t\t\tprintf(\"%d %d\\n\", p.first, p.second);\n\t}\n}\n\nint main()\n{\n\tTYC::work();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define snd second\n#define pb(a) push_back(a)\n#define mp(a, b) std::make_pair(a, b)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\nconst int oo = 0x3f3f3f3f;\n\nstring procStatus() {\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\n\ntemplate <typename T> T read(T& x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    for(;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n    return x *= f;\n}\n\nconst int N = 100000;\n\nstruct node {\n    ll d;\n    int id; \n\n    bool operator < (const node& rhs) const {\n        return d > rhs.d;\n    }\n};\n\nint n;\nnode t[N + 5];\nint fa[N + 5], sz[N + 5];\nstd::map <ll, int> mp;\n\nint main() {\n#ifdef Wearry\n    freopen(\"in\", \"r\", stdin);\n    freopen(\"out\", \"w\", stdout);\n#endif\n\n    read(n);\n    for(int i = 1; i <= n; ++i) {\n        read(t[i].d), t[i].id = i;\n    }\n\n    std::sort(t + 1, t + n + 1);\n\n    for(int i = 1; i <= n; ++i) mp[t[i].d] = i;\n    for(int i = 1; i < n; ++i) {\n        ++ sz[i];\n        fa[i] = mp[t[i].d - n + 2 * sz[i]];\n        if(!fa[i]) return !puts(\"-1\");\n        sz[fa[i]] += sz[i];\n        t[n].d -= sz[i];\n    }\n\n    if(t[n].d) return !puts(\"-1\");\n\n    for(int i = 1; i < n; ++i) {\n        printf(\"%d %d\\n\", t[i].id, t[fa[i]].id);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint n;\nvector<pair<ll,int>> v;\nvector<int> fa,siz;\nvector<vector<int>> G;\nll tot;\nvoid dfs(int u,int par,ll d){\n    tot += d;\n    for(int v : G[u]){\n        if(v == par) continue;\n        dfs(v,u,d + 1);\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n    cin>>n;\n    v.resize(n + 1);\n    fa.resize(n + 1);\n    siz.resize(n + 1);\n    G.resize(n + 1);\n    fill(fa.begin(),fa.end(),0);\n    fill(siz.begin(),siz.end(),1);\n    for(int i = 1; i <= n; i++) {\n        cin>>v[i].first;\n        v[i].second = i;\n    }\n    sort(v.begin() + 1,v.end(),[](auto x,auto y){ return x.first > y.first;});\n    for(int i = 1; i < n; i++){\n        ll d = v[i].first;\n        int sz = siz[v[i].second];\n        ll d_nxt = d - n + 2 * sz;\n        int lo = i + 1, hi = n;\n        int ans_pos = 0;\n        while(lo <= hi){\n            int mid = lo + hi >> 1;\n            if(v[mid].first > d_nxt){\n                lo = mid + 1;\n            }\n            else if(v[mid].first < d_nxt){\n                hi = mid - 1;\n            }\n            else {\n                ans_pos = mid;\n                break;\n            }\n        }\n        if(ans_pos == 0){\n            cout<<-1<<endl;\n            exit(0);\n        }\n        int u = v[i].second;\n        int f = v[ans_pos].second;\n        fa[u] = f;\n        G[f].emplace_back(u);\n        G[u].emplace_back(f);\n        siz[f] += siz[u];\n    }\n    dfs(v[n].second,0,0);\n    if(tot != v[n].first){\n        cout<<-1<<endl;\n        exit(0);\n    }\n    for(int i = 1; i < n; i++){\n        cout<<v[i].second<<\" \"<<fa[v[i].second]<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\n\n\nint N;\nconstexpr int Nmax = 100000;\nvector<plint> D;\nvector<int> to[Nmax];\n\nplint dfs(int now, int prev)\n{\n    lint d = 0, subtreesz = 1;\n    for (auto nxt : to[now]) if (nxt != prev)\n    {\n        plint pa = dfs(nxt, now);\n        d += pa.first + pa.second;\n        subtreesz += pa.second;\n    }\n    return plint(d, subtreesz);\n}\n\nint main()\n{\n    cin >> N;\n    D.resize(N);\n    REP(i, N)\n    {\n        cin >> D[i].first;\n        D[i].second = i;\n    }\n\n    sort(D.begin(), D.end());\n\n    map<lint, vector<pint>> ma;\n\n    IREP(i, N)\n    {\n        lint Dnow, id_now;\n        tie(Dnow, id_now) = D[i];\n\n        int stsz = 1;\n        if (ma.count(Dnow))\n        {\n            for (auto pa : ma[Dnow])\n            {\n                to[id_now].push_back(pa.first);\n                to[pa.first].push_back(id_now);\n                stsz += pa.second;\n            }\n            ma.erase(Dnow);\n        }\n        ma[Dnow + 2 * stsz - N].push_back(pint(id_now, stsz));\n    }\n\n    vector<pint> res;\n    REP(s, N) for (auto t : to[s]) if (s < t) res.push_back(pint(s, t));\n\n    if (res.size() != N - 1 || dfs(D[0].second, -1).first != D[0].first) cout << -1 << endl, exit(0);\n    for (auto pa : res) cout << pa.first + 1 << \" \" << pa.second + 1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"Ofast\")\ntypedef long long lint;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntypedef unsigned long long ulint;\n#define endl '\\n'\n#define fst first\n#define sed second\n#define pb push_back\n#define mp make_pair\n#define rint register int\n#define newline putchar('\\n')\n#define leave_space putchar(' ')\n#define all(x) (x).begin(), (x).end()\n#define reveal(x) cerr << #x << \" = \" << (x) << endl\n#define rep(it, f, e) for (rint it = (f); it <= (e); ++it)\n#define per(it, f, e) for (rint it = (f); it >= (e); --it)\nconst int MAXN = 1e5 + 10;\npll p[MAXN];\nint sz[MAXN];\nmap<lint, int> rec;\nvector<int> edge[MAXN];\n#define D fst\n#define P sed\nvector<pii> opt;\nlint res = 0;\ninline void dfs(int u, int par, int dep) {\n\tres += dep;\n\tfor (auto v : edge[u]) {\n\t\tif (v == par) continue;\n\t\tdfs(v, u, dep + 1);\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL), cout.tie(NULL);\n\tint n;\n\tcin >> n;\n\trep (i, 1, n) {\n\t\tcin >> p[i].D;\n\t\tp[i].P = i;\n\t\tif (rec.find(p[i].D) != rec.end()) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\trec[p[i].D] = p[i].P;\n\t}\n\tsort(p + 1, p + n + 1, greater<pll>());\n\tfill(sz + 1, sz + n + 1, 1);\n\trep (i, 1, n - 1) {\n\t\tint u = p[i].P;\n\t\tif (n - sz[u] - sz[u] <= 0) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t} \n\t\tlint diff = p[i].D - (n - sz[u] - sz[u]);\n\t\tif (rec.find(diff) == rec.end()) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint v = rec[diff];\n\t\topt.pb(pii(u, v));\n\t\tedge[u].pb(v);\n\t\tedge[v].pb(u);\n\t\tsz[v] += sz[u];\n\t}\n\tdfs(p[n].P, 0, 0);\n\tif (res != p[n].D) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tfor (auto &v : opt) {\n\t\tif (v.fst > v.sed) swap(v.fst, v.sed);\n\t}\n\tsort(all(opt));\n\tfor (auto &v : opt) {\n\t\tcout << v.fst << ' ' << v.sed << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(LL &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const LL &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"# \");printf(__VA_ARGS__);puts(\"\");}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 1e6+10;\nLL D[SIZE];\nVPLL pp;\nVI e[SIZE];\nint son[SIZE];\nint N;\nLL f(int x){\n    x++;\n    return N-x-x;\n}\nLL dfs(int x){\n    LL ret=son[x];\n    for(int y:e[x]){\n        ret+=dfs(y);\n    }\n    return ret;\n}\nint main(){\n    R(N);\n    FOR(i,1,N){\n        R(D[i]);\n        pp.PB(MP(D[i],i));\n    }\n    sort(ALL(pp),greater<PLL>());\n    VPII an;\n    REP(i,N-1){\n        auto now=pp[i];\n        LL nxt=now.F-f(son[now.S]);\n        auto it=lower_bound(pp.rbegin(),pp.rend(),MP(nxt,0LL));\n        if(it==pp.rend()||it->F!=nxt){\n            W(-1);\n            return 0;\n        }\n        an.PB(MP(now.S,it->S));\n        e[it->S].PB(now.S);\n        son[it->S]+=son[now.S]+1;\n    }\n    if(dfs(pp.back().S)!=pp.back().F)W(-1);\n    else{\n        FOR(x,1,N)for(auto y:e[x])W(x,y);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\ntypedef long long ll;\nint sz[N],i,n,rsz[N],a[N],x,y,fa[N];\nll z,d[N];\nmultiset<pair<ll,int> >s[2];\ninline void ins(int u){\n\tif(rsz[u]==1)return;\n\ts[(n+d[u])&1].insert(make_pair(n+d[u]-rsz[u]*2,u));\n}\nbool cmp(const int&x,const int&y){return d[x]<d[y];}\ninline void O(){cout<<\"-1\\n\";exit(0);}\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);\n\tcin>>n;\n\tfor(i=1;i<=n;++i)cin>>d[i],a[i]=i;\n\tsort(a+1,a+n+1,cmp);sz[a[1]]=rsz[a[1]]=n;ins(a[1]);\n\tfor(i=2;i<=n;++i){\n\t\tx=a[i];\n\t\tmultiset<pair<ll,int> >::iterator it=s[d[x]&1].upper_bound(make_pair(d[x],0));\n\t\tif(it==s[d[x]&1].begin())O();--it;y=it->second;\n\t\tz+=rsz[x]=sz[x]=(n+d[y]-d[x])/2;rsz[y]-=sz[x];\n\t\ts[d[x]&1].erase(it);ins(y);ins(x);fa[x]=y;\n\t}\n\tif(z!=d[a[1]])O();\n\tfor(i=1;i<=n;++i)if(fa[i])cout<<fa[i]<<' '<<i<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(X,A,B) for(int X=A;X<=B;X++)\n#define tep(X,A,B) for(int X=A;X>=B;X--)\n#define LL long long\n#define DB double\nconst int N=400010;\nconst int M=800010;\nconst LL INF=1e15;\nusing namespace std;\n\nint n,fa[N],sz[N];\n\nstruct nn{\n\tLL d;\n\tint x;\n}a[N];\n\nint cmp(nn A,nn B){\n\treturn A.d<B.d;\n}\n\nvoid READ(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n)scanf(\"%lld\",&a[i].d),a[i].x=i;\n\tsort(a+1,a+n+1,cmp);\n}\n\nint GET(int pos,int x){\n\tint l=1,r=pos,res=0;\n\twhile(l<=r){\n\t\tint mid=(l+r)>>1;\n\t\tif(a[mid].d<=x)res=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\treturn res;\n}\n\nint SOLVE(){\n\trep(i,1,n)sz[i]=1;\n\ttep(i,n,2){\n\t\tint x=a[i].x;\n\t\tif(sz[x]>n/2)return 0;\n\t\tLL df=a[i].d+2*sz[x]-n;\n\t\tint pos=GET(i-1,df);\n\t\tif(a[pos].d!=df)return 0;\n\t\tint pa;\n\t\tfa[x]=pa=a[pos].x;\n\t\tsz[pa]+=sz[x];\n\t}\n\trep(i,2,n)printf(\"%d %d\\n\",fa[a[i].x],a[i].x);\n\treturn 1;\n}\n\nint main(){\n\tREAD();\n\tif(SOLVE()==0)printf(\"-1\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <map>\n\ntypedef long long ll;\nconst int N = 1e5 + 51;\nstruct edge {\n\tint to, next;\n} e[N << 1];\nint head[N], cnt;\nvoid addedge(int x, int y) {\n\te[++cnt] = (edge){y, x[head]}, x[head] = cnt;\n\te[++cnt] = (edge){x, y[head]}, y[head] = cnt;\n}\nvoid dfs(int x, int p) {\n\tfor (int i = x[head], nx; i; i = e[i].next)\n\t\tif ((nx = e[i].to) != p) printf(\"%d %d\\n\", x, nx), dfs(nx, x);\n}\n\nstd::map<ll, int> mp;\nint n, sz[N];\nll a[N];\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", a + i), i[sz] = 1;\n\tstd::sort(a + 1, a + n + 1, std::greater<ll>());\n\tfor (int i = 1; i <= n; i++) mp[a[i]] = i;\n\tfor (int i = 1; i < n; i++) {\n\t\tll tmp = a[i] - n + 2 * i[sz];\n\t\tif (tmp == a[i] || !mp.count(tmp)) return puts(\"-1\"), 0;\n\t\tint nx = mp[tmp];\n\t\tnx[sz] += i[sz];\n\t\taddedge(i, nx);\n\t}\n\tdfs(1, 0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<unordered_map>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nll d[N];\nunordered_map<ll,vector<int> > p;\nll cnt[N],sum[N],n,r[N];\nvector<pair<int,int> > w;\nbool comp(int a,int b){\n\treturn d[a]>d[b];\n}\nint main(){\n\tcin>>n;\n\tfor (int i=1;i<=n;i++)scanf(\"%lld\",&d[i]),r[i]=i,p[d[i]].push_back(i),cnt[i]=1;\n\tsort(r+1,r+n+1,comp);\n\tfor (int i=1;i<n;i++){\n\t\tll x=r[i],s=d[x]-(n-2*cnt[x]),y;\n\t\tif (p[s].empty()||s>=d[x]){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\ty=p[s].back();\n\t\tw.push_back(make_pair(x,y));\n\t\tcnt[y]+=cnt[x];\n\t}\n\tfor (int i=0;i<n-1;i++)printf(\"%d %d\\n\",w[i].first,w[i].second);\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*\ncout<<fixed<<setprecision(20);\ncin.tie(0);\nios::sync_with_stdio(false);\n*/\nconst llint mod=1000000007;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint main(void){\n\t//It's 1600 problem!\n\tint n,i;cin>>n;\n\tvector<pair<llint,int>>cho(n);\n\tfor(i=0;i<n;i++){\n\t\tcin>>cho[i].fir;\n\t\tcho[i].sec=i;\n\t}\n\tSO(cho);\n\tvector<llint>kaz(n,1);\n\tvector<llint>red(n);\n\tvector<pair<int,int>>ans;\n\tfor(i=n-1;i>0;i--){\n\t\tllint mok=cho[i].fir-n+kaz[i]*2;\n\t\tint bas=LBI(cho,mp(mok,-9999));\n\t\tif(cho[bas].fir!=mok){cout<<\"-1\"<<endl;return 0;}\n\t\tkaz[bas]+=kaz[i];\n\t\tred[bas]+=red[i];\n\t\tred[bas]+=kaz[i];\n\t\t//cerr<<\"a\";\n\t\tans.pub(mp(cho[i].sec,cho[bas].sec));\n\t}\n\t//cerr<<red[0]<<endl;\n\tif(red[0]!=cho[0].fir){cout<<\"-1\"<<endl;return 0;}\n\tfor(i=0;i<n-1;i++){cout<<ans[i].fir+1<<\" \"<<ans[i].sec+1<<endl;}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair < int , int > pii;\ntypedef pair < LL , int > pli;\n#define mpr make_pair\n#define FS first\n#define SC second\n#define PB push_back\ntemplate < typename T > T MAX(T a,T b){return (a>b)?a:b;}\ntemplate < typename T > T MIN(T a,T b){return (a<b)?a:b;}\ntemplate < typename T > void UMAX(T &a,T b){a=(a>b?a:b);}\ntemplate < typename T > void UMIN(T &a,T b){a=(a<b?a:b);}\nint readint(){\n\tchar c=getchar();\n\tint ret=0;\n\twhile(!(c>='0' && c<='9')) c=getchar();\n\twhile(c>='0' && c<='9'){\n\t\tret=ret*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn ret;\n}\nvoid putint(int v){\n\tif(!v){\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif(v>=10) putint(v/10);\n\tputchar('0'+(v%10));\n}\nint n,fa[100005],sz[100005];\npli D[100005];\nvector < int > adj[100005];\nmultiset < LL > inp,ex;\nLL sm[100005];\nLL dfs(int v,int f,int d=0){\n\tint i;\n\tLL ret=(LL)d;\n\tfor(i=0;i<(int)adj[v].size();++i){\n\t\tint u=adj[v][i];\n\t\tif(u!=f) ret+=dfs(u,v,d+1);\n\t}\n\treturn ret;\n}\nvoid rdfs(int v,int f){\n\tint i;\n\tex.insert(sm[v]);\n\tfor(i=0;i<(int)adj[v].size();++i){\n\t\tint u=adj[v][i];\n\t\tif(u!=f){\n\t\t\tsm[u]=sm[v]+(LL)n-2ll*sz[u];\n\t\t\trdfs(u,v);\n\t\t}\n\t}\n}\nint main(){\n\tint i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;++i){\n\t\tfa[i]=-1;\n\t\tsz[i]=1;\n\t\tscanf(\"%lld\",&D[i].FS);\n\t\tinp.insert(D[i].FS);\n\t\tD[i].SC=i;\n\t}\n\tsort(D,D+n);\n\tfor(i=n-1;i>0;--i){\n\t\tint v=D[i].SC;\n\t\tLL d=D[i].FS,tar=d-(LL)n+2ll*sz[v];\n\t\tif(sz[v]*2>=n){\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tint td=lower_bound(D,D+n,mpr(tar,-1))-D;\n\t\tif(td>=n || D[td].FS!=tar || fa[D[td].SC]!=-1){\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tfa[v]=D[td].SC;\n\t\tsz[D[td].SC]+=sz[v];\n\t}\n\tif(sz[D[0].SC]!=n){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(i=0;i<n;++i){\n\t\tif(fa[i]!=-1){\n\t\t\tadj[i].push_back(fa[i]);\n\t\t\tadj[fa[i]].push_back(i);\n\t\t}\n\t}\n\tsm[D[0].SC]=dfs(D[0].SC,-1);\n\trdfs(D[0].SC,-1);\n\tif(ex!=inp){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(i=0;i<n;++i){\n\t\tif(fa[i]!=-1) printf(\"%d %d\\n\",i+1,fa[i]+1);\n\t}\n\treturn 0;\n}\n/*\n * 代码框架\n * 1、读入，对pair排序\n * 2、维护每个点的子树大小（初始=1）和父亲（初始=-1）\n * 3、按照D降序枚举，对于除了最后一个结点以外，都二分出其父亲的位置，找不到就-1\n * 4、每次如果碰到已经确定父亲的点则-1，如果碰到未确定父亲的点就加size\n * 5、最后检查，是否根节点的size=n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <algorithm>\n#include <map>\n#define MN 100000\n#define MM 200000\nint n,hd[MN+5],to[MM+5],nxt[MM+5],rn=0;\nstd::map<int,int> mp;\ntypedef std::map<int,int>::iterator iter;\nstruct node{int i,d,sz;}a[MN+5];\nvoid _add(int u,int v){\n\tto[rn]=v,nxt[rn]=hd[u];\n\thd[u]=rn++;\n}\nvoid add(int u,int v){_add(u,v),_add(v,u);}\nvoid gg(){puts(\"-1\");exit(0);}\nint main(){\n\tmemset(hd,0xff,sizeof(hd));\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i].d);\n\t\ta[i].i=i,a[i].sz=1;\n\t}\n\tstd::sort(a+1,a+1+n,[](node a,node b)->bool{return a.d>b.d;});\n\tfor(int i=1;i<=n;i++) mp[a[i].d]=i;\n\tfor(int i=1;i<=n;i++){\n\t\tint dta=n-(a[i].sz<<1);\n\t\tif(dta<0) continue;\n\t\titer it=mp.find(a[i].d-dta);\n\t\tif(it==mp.end()) gg();\n\t\ta[it->second].sz+=a[i].sz;\n\t\tadd(a[i].i,a[it->second].i);\n\t}\n\tif(rn!=(n-1)<<1) gg();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=hd[i];~j;j=nxt[j])\n\t\t\tif(to[j]>i) printf(\"%d %d\\n\",i,to[j]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<unordered_map>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nll d[N];\nunordered_map<ll,vector<int> > p;\nll cnt[N],sum[N],n,r[N];\nvector<pair<int,int> > w;\nbool comp(int a,int b){\n\treturn d[a]>d[b];\n}\nint main(){\n\tcin>>n;\n\tfor (int i=1;i<=n;i++)scanf(\"%lld\",&d[i]),r[i]=i,p[d[i]].push_back(i),cnt[i]=1;\n\tsort(r+1,r+n+1,comp);\n\tfor (int i=1;i<n;i++){\n\t\tll x=r[i],s=d[x]-(n-2*cnt[x]),y;\n\t\tif (p[s].empty()){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\ty=p[s].back();\n\t\tw.push_back(make_pair(x,y));\n\t\tcnt[y]+=cnt[x];\n\t}\n\tfor (int i=0;i<n-1;i++)printf(\"%d %d\\n\",w[i].first,w[i].second);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+10;\nstruct data\n{\n\tlong long D;\n\tint id;\n\tbool operator < (const data &b){return D<b.D;}\n}c[maxn];\nint fa[maxn],siz[maxn],n;\nint find(int lim,long long x)\n{\n\tint l=1,r=lim,ans=0;\n\twhile(l<=r)\n\t{\n\t\tint mid=l+r>>1;\n\t\tif(c[mid].D>=x)r=mid-1,ans=mid;\n\t\telse l=mid+1;\n\t}\n//\tcout<<c[ans].D<<endl;\n//\tif(c[ans].D!=x)printf(\"fuckyou\\n\");\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&c[i].D),c[i].id=i;\n\tsort(c+1,c+1+n);\n\tfor(int i=n;i>=2;i--)\n\t{\n\t\tsiz[i]++;\n\t\tint p=find(i-1,c[i].D-(n-2*1LL*siz[i]));\n\t\tif(c[i].D-(n-2*1LL*siz[i])!=c[p].D)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[p]+=siz[i];\n\t\tfa[c[i].id]=c[p].id;\n\t}\n\tfor(int i=1;i<=n;i++)if(fa[i])printf(\"%d %d\\n\",fa[i],i);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nmap<int,int> M1,M2;\nint s1[200010],pa[200010];\nstruct edge\n{\n\tint v,next;\n}vs[200010];\nint st[200010],ee,sz[200010],vis[20010];\ninline void addedge(int u,int v)\n{\n\tvs[++ee].v=v;vs[ee].next=st[u];st[u]=ee;\n}\t\ninline void dfs(int rt,int pr)\n{\n\tif(vis[rt])\n\t{\n\t\tputs(\"-1\"); exit(0);\n\t}\n\tvis[rt]=1;\n\tfor(int i=st[rt];i;i=vs[i].next)\n\t{\n\t\tif(vs[i].v==pr) continue;\n\t\tdfs(vs[i].v,rt);\n\t\tsz[rt]+=sz[vs[i].v];\n\t}\n}\nsigned main()\n{\n\tint n=read();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=read();\n\t\tM1[x]=i; M2[x]=1;\n\t\ts1[i]=x;\n\t}\n\tsort(s1+1,s1+1+n);\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tint id=M1[s1[i]],sz=M2[s1[i]],td=s1[i]+2*sz-n;\t\n\t\tif(td==s1[i]) continue;\t\n\t\tpa[id]=M1[td]; M2[td]+=sz;\n\t}\n\tint rt=0;\n\tfor(int i=1;i<=n;i++) \n\t{\n\t\tif(pa[i]) addedge(pa[i],i),addedge(i,pa[i]);\n\t\telse \n\t\t{ \n\t\t\tif(rt) puts(\"-1\"),exit(0);\n\t\t\telse rt=i;\n\t\t}\n\t}\n\tif(!rt) puts(\"-1\"),exit(0);\n\tfor(int i=1;i<=n;i++) sz[i]=1;\n\tdfs(rt,0);\n\tif(sz[rt]!=n) puts(\"-1\"),exit(0);\n\telse\n\t{ \n\t\tfor(int i=1;i<=n;i++) if(pa[i])\n\t\t\tprintf(\"%lld %lld\\n\",i,pa[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//************************\n//** author  :  Alex Hu **\n//************************\n\n//  _______        __________         ________        __\n//  \\      \\   ____\\______   \\ ____  /  _____/  _____/  |_\n//  /   |   \\ /  _ \\|       _// __ \\/   \\  ____/ __ \\   __\\\n// /    |    (  <_> )    |   \\  ___/\\    \\_\\  \\  ___/|  |\n// \\____|__  /\\____/|____|_  /\\___  >\\______  /\\___  >__|\n//         \\/              \\/     \\/        \\/     \\/\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define CLEAN(a,b) memset(a,b,sizeof(a))\n#define mkp make_pair\n#define pb push_back\n#define rept(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define fi first\n#define se second\n#define sqr(a) ((a)*(a))\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst ll mod=1e9+7;\nconst int INF=0x3f3f3f3f;\nconst int MAX=1e5+5;\n\nint n,size[MAX],id[MAX],ans1[MAX],ans2[MAX];\nll tot,a[MAX];\nmap<ll,int> num;\nvi v[MAX];\n\nbool cmp(int x,int y)\n{\n\treturn a[x]>a[y];\n}\n\nvoid dfs(int x,int fa,int d)\n{\n\ttot+=(ll)d;\n\trept(i,0,v.size()) if (v[x][i]!=fa) dfs(v[x][i],x,d+1);\n}\n\nint main()\n{\n\tcin>>n;\n\trept(i,1,n+1)\n\t{\n\t\tcin>>a[i];\n\t\tnum[a[i]]=i;\n\t}\n\trept(i,1,n+1)\n\t{\n\t\tsize[i]=1;\n\t\tid[i]=i;\n\t}\n\trept(i,1,n)\n\t{\n\t\tint x=id[i];\n\t\tll w=a[x]-(n-size[x])+size[x];\n\t\tif (!num[w] || w>=a[x])\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint y=num[w];\n\t\tans1[i]=x;\n\t\tans2[i]=y;\n\t\tv[x].pb(y);\n\t\tv[y].pb(x);\n\t\tsize[y]+=size[x];\n\t}\n\tdfs(id[n],0,0);\n\tif (tot!=a[id[n]])\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\trept(i,1,n+1) cout<<ans1[i]<<\" \"<<ans[2]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nll n;\nvl a,b,c,s;\nvvi g;\n\nint main(){\n\tcin>>n;\n\tvpll tmp(n);\n\ta=b=s=vl(n);\n\tc=vl(n,1);\n\tg=vvi(n);\n\tfor(int i=0;i<n;i++){\n\t\tll A;\n\t\tcin>>A;\n\t\ttmp[i]={A,i};\n\t}\n\tsort(tmp.begin(),tmp.end());\n\tfor(int i=0;i<n;i++){\n\t\ta[i]=tmp[i].first;\n\t\tb[i]=tmp[i].second;\n\t}\n\tfor(int i=n-1;i>0;i--){\n\t\tif(!c[i]) c[i]++;\n\t\tint x=a[i]+2*c[i]-n,I=lower_bound(a.begin(),a.end(),x)-a.begin();\n\t\tif(I==n||I>=i||a[I]!=x){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tc[I]+=c[i];\n\t\tg[I].push_back(i);\n\t}\n\tll S=0;\n\tfor(int i=1;i<n;i++) S+=c[i];\n\tif(S!=a[0]){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tfor(int v=0;v<n;v++) for(auto u:g[v]) cout<<b[u]+1<<' '<<b[v]+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> bool chmin(T& a,const T& b) {\n  if(a>b) {\n    a=b;\n    return true;\n  }\n  return false;\n}\ntemplate<class T> bool chmax(T& a,const T& b) {\n  if(a<b){\n    a=b;\n    return true;\n  }\n  return false;\n}\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\n//const int INF=5e8;\n\nint n;\nlint ar[100005];\nvoid ng(){\n  puts(\"-1\");\n  exit(0);\n}\nint main(){\n  cin>>n;\n  set<pair<lint,pi> > S;\n  REP(i,n){\n    scanf(\"%lld\\n\",&ar[i]);\n    S.insert({ar[i],{i,1}});\n  }\n  vector<pi> es;\n  while(S.size()>1){\n    pair<lint,pi> tmp=*(--S.end());\n    S.erase(--S.end());\n    int v=tmp.sc.fr,wei=tmp.sc.sc;\n    lint co=tmp.fr;\n    if(wei*2>=n) ng();\n\n    lint want=co-(n-2*wei);\n    auto it=S.lower_bound(mp(want,mp(0,0)));\n    if(it!=S.end() && it->fr==want){\n      int v2=it->sc.fr,wei2=it->sc.sc;\n      S.erase(it);\n      es.pb({v,v2});\n      S.insert({want,{v2,wei+wei2}});\n    }else{\n      ng();\n    }\n  }\n  for(auto e:es) printf(\"%d %d\\n\",e.fr+1,e.sc+1);\n\n\n\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#define ll long long\nusing namespace std;\nmap<ll,int> us;\nll d[100010];\nint n,cnt=0;\nstruct node{\n\tint to,nxt,cap;\n}e[200010];\nint pos[100010],siz[100010],head[100010];\nbool cmp(int a,int b){\n\treturn d[a]>d[b];\n}\nvoid add(int u,int v){\n\te[++cnt].to=v;e[cnt].nxt=head[u];head[u]=cnt;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tint i,j;\n\tfor(i=1;i<=n;++i){\n\t\tscanf(\"%lld\",&d[i]);us[d[i]]=i;siz[i]=1;pos[i]=i;\n\t}\n\tsort(pos+1,pos+1+n,cmp);\n\tfor(i=1;i<n;++i){\n\t\tll x=d[pos[i]]-(n-siz[pos[i]])+siz[pos[i]];\n\t\tif(!us[x] || x>=d[pos[i]]){printf(\"-1\\n\");return 0;}\n\t\tadd(us[x],pos[i]);\n\t\tsiz[us[x]]+=siz[pos[i]];\n\t}\n\tfor(j=1;j<=n;++j){\n\t\tfor(i=head[j];i;i=e[i].nxt){\n\t\t\tprintf(\"%d %d\\n\",j,e[i].to);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <cctype>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}\n\twhile (isdigit(ch)){x=x*10+ch-48;ch=getchar();}\n\treturn x*f;\n}\n\npair <long long,int> D[100050];\n\npair <int,int> edge[100050];\n\nvector <int> G[100050];\n\nint n,size[100050],tot;\n\nlong long dis[100050];\n\ninline void dfs(int u,int fa)\n{\n\tfor (int i=0;i<G[u].size();i++)\n\t{\n\t\tint v=G[u][i];\n\t\tif (v!=fa)\n\t\t{\n\t\t\tdis[v]=dis[u]+1;\n\t\t\tdfs(v,u);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tn=read();\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint d=read();\n\t\tD[i]={d,i};\n\t\tsize[i]=1;\n\t}\n\tsort(D+1,D+n+1);\n\treverse(D+1,D+n+1);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tlong long delta=D[i].first-n+2*size[i];\n\t\tint l=1,r=n,pos=0; \n\t\twhile (l<=r)\n\t\t{\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif (D[mid].first<=delta)\n\t\t\t{\n\t\t\t\tr=mid-1;\n\t\t\t\tpos=mid;\n\t\t\t}\n\t\t\telse\n\t\t\t\tl=mid+1;\n\t\t}\n\t\t//cout << D[pos].first << \" \" << delta << endl;\n\t\tif (D[pos].first!=delta)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint u=D[i].second,v=D[pos].second;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t\tedge[++tot]={u,v};\n\t\tsize[pos]+=size[i];\n\t}\t\n\tdfs(D[n].second,0);\n\tlong long sum=0;\n\tfor (int i=1;i<=n;i++)\n\t\tsum+=dis[i];\n\tif (sum==D[n].first)\n\t{\n\t\tfor (int i=1;i<=tot;i++)\n\t\t\tcout << edge[i].first << \" \" << edge[i].second << endl;\n\t}\n\telse\n\t\tputs(\"-1\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(ll i = (a); i < (ll)(b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\nusing ld = long double;\nusing ll = long long int;\n\nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ll MOD = 1000000007;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> void UNIQUE(vector<T> &a){ a.erase(unique(a.begin(), a.end()), a.end()); }\n\ntemplate<class S, class T> ostream& operator << (ostream& os, const pair<S, T> v){\n  os << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<T> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<vector<T>> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\n\nll in(){long long int x; assert(scanf(\"%lld\", &x) == 1); return x;}\nld fin(){double x; assert(scanf(\"%lf\", &x) == 1); return x;}\nchar yuyushiki[1000010]; string stin(){assert(scanf(\"%s\", yuyushiki) == 1); return yuyushiki;}\n\n// head\n\nusing pl = pair<ll, ll>;\nvector<ll> G[100010];\n\nint main(){\n\n  ll n = in();\n  vector<ll> a(n);\n  REP(i, n){\n    a[i] = in();\n  }\n  vector<ll> s(n, 1);\n  vector<pl> q(0);\n  REP(i, n){\n    q.pb(a[i], i);\n  }\n  sort(q.begin(), q.end());\n  reverse(q.begin(), q.end());\n  map<ll, vector<pl>> call;\n  YYS(w, q){\n    ll i = w.se;\n    if(call.find(a[i]) != call.end()){\n      YYS(c, call[a[i]]){\n        // cout << \"M \" << i << \" \" << c.fi << endl;\n        G[i].pb(c.fi);\n        s[i] += c.se;\n      }\n    }\n    ll target = a[i] + s[i] - (n - s[i]);\n    // cout << \"T \" << i << \" \" << target << endl;\n    if(call.find(target) == call.end()){\n      call[target] = vector<pl>(0);\n    }\n    call[target].pb(i, s[i]);\n  }\n\n  bool ok = false;\n  REP(i, n){\n    if(s[i] == n){\n      ok = true;\n    }\n  }\n  \n  if(ok){\n    ll cnt = 0;\n    REP(i, n){\n      YYS(w, G[i]){\n        cnt++;\n        printf(\"%lld %lld\\n\", i+1, w+1);\n      }\n    }\n    assert(cnt == n-1);\n  } else {\n    puts(\"-1\");\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define title \"title\"\n#define ll long long\n#define ull unsigned ll\n#define fix(x) fixed<<setprecision(x)\n#define pii pair<int,int>\n#define vint vector<int>\n#define pb push_back\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define red(i,a,b) for(int i=(a);i>=(b);i--)\n#define db double\n#define ld long db\nusing namespace std;\nvoid Freopen(){\n\tfreopen(title\".in\",\"r\",stdin);\n\tfreopen(title\".out\",\"w\",stdout);\n}\nll read(){\n\tll g=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch){if(ch=='-')f=-1;ch=getchar();}\n\twhile('0'<=ch&&ch<='9'){g=g*10+ch-'0';ch=getchar();}\n\treturn g*f;\n}\nconst int N=1e5+5;\nmap<ll,int>id;\nll a[N],ans;\nint n,size[N];\nvint G[N];\nvoid dfs(int x,int dis){ans+=dis;for(auto y:G[x])dfs(y,dis+1);}\nsigned main(){\n\t//freopen(\"a\",\"r\",stdin);\n\tn=read();rep(i,1,n)a[i]=read();\n\tsort(a+1,a+n+1,[](int a,int b){return a>b;});\n\trep(i,1,n)id[a[i]]=i,size[i]=1;\n\trep(i,1,n-1){\n\t\tint to=a[i]+size[i]-(n-size[i]);\n\t\tif(!id[to])return cout<<-1,signed();\n\t\tG[id[to]].pb(i);size[id[to]]+=size[i];\n\t}dfs(n,0);if(ans^a[n])return cout<<-1,signed();\n\trep(i,1,n)for(auto j:G[i])cout<<i<<' '<<j<<'\\n';\n\treturn signed();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 100005;\n\ntemplate <class T>\nvoid read (T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\n\ntemplate <class T>\nvoid write (T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nint n, dep[N], sz[N];\nbool flag = true;\n\nstruct node {\n\tint id;\n\tlong long dist;\n\tbool operator < (node rhs) const {\n\t\treturn dist < rhs.dist;\n\t}\n} vec[N];\nlong long d[N];\nvector<pair<int, int> > tree;\n\nint main () {\n\tread(n);\n\tfor (int i = 1; i <= n; i++) vec[i].id = i, read(vec[i].dist);\n\n\tsort(vec + 1, vec + n + 1);\n\tfor (int i = 1; i <= n; i++) d[i] = vec[i].dist, sz[i] = 1;\n\n\tfor (int i = n; i > 1; i--) {\n\t\tint pos = lower_bound(d + 1, d + i, d[i] - (n - sz[i]) + sz[i]) - d;\n\t\tif (pos >= i || d[pos] != d[i] - (n - sz[i]) + sz[i]) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t\ttree.push_back(make_pair(vec[i].id, vec[pos].id));\n\t\tsz[pos] += sz[i];\n\t}\n\n\tif (flag) {\n\t\tdep[vec[1].id] = 0;\n\t\tfor (int i = n - 2; i >= 0; i--) dep[tree[i].first] = dep[tree[i].second] + 1;\n\t\tfor (int i = 1; i <= n; i++) d[1] -= dep[i];\n\t\tif (d[1]) flag = false;\n\t}\n\tif (!flag) write(-1), putchar('\\n');\n\telse {\n\t\tfor (int i = 0; i < tree.size(); i++) {\n\t\t\twrite(tree[i].first), putchar(' ');\n\t\t\twrite(tree[i].second), putchar('\\n');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Konrad Paluszek,University of Warsaw(former XIV LO Staszic)\n//#STAY AT HOME\n#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n#define TIME (chrono::steady_clock::now().time_since_epoch().count())\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#define xfm(a,b)a##b\n#define xwb(a,b)xfm(a,b)\n#define _ xwb(nvj,__LINE__)\n#define __ xwb(kjy,__LINE__)\n#define ___ xwb(cjm,__LINE__)\n#define REP(i,n)for(urs(n)i=0;i<(n);++i)\n#define UNTIL(t)while(clock()<(t)*CLOCKS_PER_SEC)\n#define PER(r...)for(bool _=1;_||next_permutation(r);_=false)\n#define ALL(r)(r).begin(),(r).end()\n#define RALL(r)(r).rbegin(),(r).rend()\n#define FS(r)r.first,r.second\n#define SF(r)r.second,r.first\n#define M0(r) memset(r, 0, sizeof(r))\n#define sim template<class c\n#define ros return o\n#define rans return ans\n#define forbits(i,m)if(m)for(urs(m)i=ctz(m),i##nvj=m;i##nvj;i##nvj^=((urs(m))1<<i),i=ctz(i##nvj))\n#define fordbits(i,m)if(m)for(urs(m)i=8*sizeof(m)-clz(m)-1,i##nxd=m;i##nxd;i##nxd^=((urs(m))1<<i),i=8*sizeof(m)-clz(i##nxd)-1)\n#define ksets(t, m, k, n) for (t m = (((t)1 << (k)) - 1); m < ((t)1 << (n)); m = nux(m))\n#define urs(r...)typename decay<decltype(r)>::type\n#define hur(f,g,r)sim>int f(c a){if(sizeof(c)==16)return r;if(sizeof(c)==8)return g##ll(a);return g(a);}\n#define pwq(t,i) int clz(t x){return clz<int>(x)-i;}\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wconversion\"\nusing namespace __gnu_pbds;using namespace std;using ll=long long;using ld=long double;using ull=unsigned long long;using vi=vector<int>;using vll=vector<ll>;using pii=pair<int,int>;using pll=pair<ll,ll>;using vpii=vector<pii>;using spii=set<pii>;using mii=map<int,int>;using unt=unsigned int;sim>using min_queue=priority_queue<c,vector<c>,greater<c>>;sim,class b,class cmp=less<c> >using ordered_map=tree<c,b,cmp,rb_tree_tag,tree_order_statistics_node_update>;sim, class cmp=less<c>>using ordered_set = ordered_map<c,null_type,cmp>;hur(popc,__builtin_popcount,popc<ull>(a)+popc<ull>(a>>64))hur(ctz,__builtin_ctz,(ull)a?ctz<ull>(a):64+ctz<ull>(a>>64))hur(clz,__builtin_clz,a>>64?clz<ull>(a>>64):64+clz<ull>(a))pwq(short,16)pwq(uint16_t,16)pwq(char,24)pwq(int8_t,24)pwq(uint8_t,24)sim,class N>bool mini(c&o,const N&h){if(o>h)ros=h,1;return 0;}sim,class N>bool maxi(c&o,const N&h){if(o<h)ros=h,1;return 0;}sim,class n>using gyv=c;\n#if defined(LOCAL) // || defined(LOCAL2)\n#include </home/kjp/headers/debuglib.hpp>\n#else\n#define loc(...)\n#define onl(r...)r\n#define debug(...)\n#define print_stack(...)\n#define mark_stack(...)\n#define set_pre(...)\n#define reg_it(...)\n#define def_op(...) struct _{};\n#if !defined(LOCAL) && !defined(LOCAL2)\n#define exit my_exit\nvoid my_exit(int x) {fflush(stdout);_Exit(x);}\n#endif\n#endif\n#define next nexT\n#define prev preV\n#define tree trEE\n#define left lefT\n#define right righT\n#define div diV\n#define y1 y_1\n#define pow do not use cmath pow unless you know what you are doing\null mix(ull o){o+=0x9e3779b97f4a7c15;o=(o^(o>>30))*0xbf58476d1ce4e5b9;o=(o^(o>>27))*0x94d049bb133111eb;ros^(o>>31);}ull SALT=0x7a14a4b0881ebf9,tqu=0x7a14a4b0881ebf9;ull my_rand(){return tqu=mix(tqu);}void my_srand(ull x){SALT=tqu=x;}const int inf = 1023400000;const ll llinf=1234567890000000000ll;ll fix(ll o, ll m){o%=m;if(o<0)o+=m;ros;}\n#define rand my_rand\n#define srand my_srand\n#define random_shuffle(r...)random_shuffle(r,[](int _){return my_rand()%_;})\nsim>inline c nux(c m){if(!m)return numeric_limits<c>::max();c A=m&-m;c B=~((A-1)^m);c C=B&-B;c D=(C>>(1+ctz(A)))-1;return C|(m&~(C-1))|D;}__attribute__((no_sanitize_undefined))ll mul(ll a,ll b,ll m){ll q=(ll)(a*(ld)b/m);ll o=a*b-q*m;o%=m;if(o<0)o+=m;ros;}sim>void unq(c&x){x.resize(unique(ALL(x))-x.begin());}\n#pragma GCC diagnostic pop\n#if ((ULONG_MAX) != (UINT_MAX))\nnamespace std {template <> struct is_signed<__int128> : public true_type {};}\n#endif\nsim, class d> typename common_type<c,d>::type floor_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using floor_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b - (a % b < 0);}\nsim, class d> typename common_type<c,d>::type ceil_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using ceil_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b + (a % b > 0);}\nsim> struct REV {using value_type=typename c::value_type;c &x;using it=typename c::reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> struct CREV {using value_type=typename c::value_type;const c&x;using it=typename c::const_reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> REV<c> reversed(c&x) {return REV<c>{x};}sim> CREV<c> reversed(const c&x) {return CREV<c>{x};}\n#define done(r...) exit(0 * printf(r))\n#if defined(LOCAL) || defined(LOCAL2)\nvoid __tmi() {cerr << setprecision(6) << fixed << \"total time: \" << clock() / (ld)CLOCKS_PER_SEC << \"s\" << endl;}int _ = (atexit(__tmi), 0);\n#endif\n//#STAY AT HOME\nconst int nax = 1e5 + 44;\nvi graf[nax];\nint siz[nax];\nll d[nax];\nmap <ll, int> wh;\nvpii ans;\nvoid add_edge(int a, int b) {\n\tgraf[a].push_back(b);\n\tgraf[b].push_back(a);\n\tans.emplace_back(a + 1, b + 1);\n}\nvoid err() {\n\tdone(\"-1\\n\");\n}\nll su = 0;\nvoid dfs(int x, int y = -1, int d = 0) {\n\tfor (int v : graf[x]) if (v != y) dfs(v, x, d + 1);\n\tsu += d;\n}\nvoid solve() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tREP(i, n) scanf(\"%lld\", d + i);\n\tREP(i, n) siz[i] = 1;\n\tvector <pair <ll, int> > ord(n);\n\tREP(i, n) ord[i] = {d[i], i};\n\tREP(i, n) wh[d[i]] = i;\n\tsort(RALL(ord));\n\tREP(ind, n - 1) {\n\t\tauto [v, i] = ord[ind];\n\t\tll oth = v - n + siz[i] * 2;\n\t\tauto it = wh.find(oth);\n\t\tif (it == wh.end() || it->second == i) err();\n\t\tadd_edge(i, it->second);\n\t\tsiz[it->second] += siz[i];\n\t}\n\tdfs(0);\n\tif (su != d[0]) err();\n\tfor (auto [x, y] : ans) printf(\"%d %d\\n\", x, y);\n}\nint main() {\n\t// unt seed = TIME; debug(imie(seed));srand(seed);\n\tint t = 1;\n\t// scanf(\"%d\", &t);\n\tREP(_, t) solve();\n\texit(0);\n}\n//#STAY AT HOME\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,sz[100005],fa[100005];\nlong long d[100005],res;\nmap<long long,int> id;\npriority_queue<pair<long long,int> > pq;\nvector<int> e[100005];\nvector<pair<int,int> > ans;\nvoid dfs(int x,int d){\n\tres+=d;\n\tfor(int i=0;i<e[x].size();i++) dfs(e[x][i],d+1);\n}\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tsz[i]=1;\n\t\tcin>>d[i];\n\t\tid[d[i]]=i;\n\t\tpq.push(make_pair(d[i],i));\n\t}\n\twhile(pq.size()>1){\n\t\tint x=pq.top().second;pq.pop();\n\t\tid.erase(d[x]);\n\t\tif(!id.count(d[x]-(n-sz[x])+sz[x])){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tfa[x]=id[d[x]-(n-sz[x])+sz[x]];\n\t\tsz[fa[x]]+=sz[x];\n\t\te[fa[x]].push_back(x);\n\t\tans.push_back(make_pair(fa[x],x));\n\t}\n\tint rt=pq.top().second;\n\tres=0;\n\tdfs(rt,0);\n\tif(res!=d[rt]){\n\t\tputs(\"-1\"); \n\t}\n\telse{\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tprintf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define F first\n#define S second\nconst int MN = 101234;\n\nint sz[MN], par[MN], sum[MN];\npair <int, int> d[MN];\n\nint32_t main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> d[i].F;\n\t\td[i].S = i;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tsz[i] = 1;\n\tsort(d, d + n);\n\tfor (int i = n - 1; i >= 1; i--) {\n//\t\tcerr << d[i].F << ' ' << d[i].F - n + 2 * sz[i] << endl;\n\t\tint pr = lower_bound(d, d + n, (pair <int, int>){d[i].F - n + 2 * sz[i], 0ll}) - d;\n\t\tif (pr >= i || pr == n || d[pr].F != d[i].F - n + 2 * sz[i])\n\t\t\treturn cout << -1, 0;\n\t\tsz[pr] += sz[i];\n\t\tsum[pr] += sum[i] + sz[i];\n\t\tpar[d[i].S] = d[pr].S;\n\t}\n\tif (sum[0] != d[0].F)\n\t\treturn cout << -1, 0;\n\tfor (int i = 1; i < n; i++)\n\t\tcout << par[d[i].S] + 1 << ' ' << d[i].S + 1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n#define int ll\n \nstruct node{\n\tll w;\n\tint y;\n}a[100050];\n \nstruct node2{\n\tint t, nxt;\n}edge[200050];\n \nstruct node3{int fr, f;};\n \nint head[100050], cnt, n, siz[100050], anss;\n \nvoid add(int u, int v){\n\tedge[++cnt] = (node2){v, head[u]};\n\thead[u] = cnt;\n}\n \nbool cmp(node a, node b){return a.w<b.w;}\n \nint find(int u){\n\tfor(int i = u-1; i >= 1; i--)if(a[i].w - a[u].w == 2*siz[a[u].y] - n) return a[i].y;\n\treturn -1;\n}\n \nvoid print(int u, int fa){\n\tqueue<node3> q;\n\tq.push((node3){u, fa});\n\twhile(!q.empty()){\n\t\tu = q.front().fr;\n\t\tint ff = q.front().f;\n\t\tq.pop();\n\t\tfor(int i = head[u]; i; i = edge[i].nxt){\n\t\t\tint v = edge[i].t;\n\t\t\tprintf(\"%d %d\\n\", u, v);\n\t\t\tq.push((node3){v, u});\n\t\t}\n\t}\n}\n\nvoid test(int u, int fa, int dep){\n\tanss+=dep;\n\tfor(int i = head[u]; i; i = edge[i].nxt){\n\t\tint v = edge[i].t;\n\t\tif(v == fa) continue;\n\t\ttest(v, u, dep+1);\n\t}\n}\n\nmain(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &a[i].w);\n\t\ta[i].y = i;\n\t}\n\tsort(a+1, a+n+1, cmp);\n\tint rt = a[1].y;\n\tfor(int i = n; i >= 2; i--) {\n\t\tsiz[a[i].y]++;\n\t\tint p = find(i);\n\t\tif(p == -1){\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[p]+=siz[a[i].y];\n\t\tadd(p, a[i].y);\n\t}\n\ttest(rt, 0, 0);\n\tif(anss != a[1].w){\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tprint(rt, 0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define maxn 100005\n#define pii pair<int,int>\nusing namespace std;\nint N;\npii arr[maxn];\nvector<int> G[maxn];\nint sz[maxn];\nvector<pii> ans;\nmain() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> N;\n\tfor(int i=1;i<=N;i++)\n\t\tcin >> arr[arr[i].second=i].first;\n\tsort(arr+1,arr+1+N);\n\tfor(int i=1;i<=N;i++)\n\t\tsz[i] = 1;\n\tfor(int i=N;i>1;i--) {\n\t\tint val = arr[i].first;\n\t\tint idx = arr[i].second;\n\t\tint pa_val = val-(N-sz[idx])+(sz[idx]);\n\t\tint tem = lower_bound(arr+1,arr+1+N,pii{pa_val,-1})-arr;\n\t\tif(tem==N+1 || tem==i || arr[tem].first!=pa_val) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint pa = arr[tem].second;\n\t\tsz[pa] += sz[idx];\n\t\tans.emplace_back(pii{pa,idx});\n\t}\n\tfor(pii now : ans)\n\t\tcout << now.first << \" \" << now.second << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\ntypedef long long ll;\n\nconst int MAXN = 1e5 + 10;\nvector<pair<int, int> > edg;\npair<ll, int> d[MAXN];\nvector<int> Mat[MAXN];\nint n, cnt[MAXN];\nmap<ll, int> mp;\nbool se[MAXN];\nll dist;\nint num;\n\nvoid dfs(int v, int di) {\n\tse[v] = 1, num++;\n\tdist += di;\n\tfor (int i = 0; i < Mat[v].size(); i++)\n\t\tif (!se[Mat[v][i]])\n\t\t\tdfs(Mat[v][i], di + 1);\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> d[i - 1].first;\n\t\tmp[d[i - 1].first] = i;\n\t\td[i - 1].second = i;\n\t\tcnt[i] = 1;\n\t}\n\tsort(d, d + n);\n\treverse(d, d + n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint k = cnt[d[i].second];\n\t\tif (2 * k > n || mp.find(d[i].first + k - (n - k)) == mp.end())\n\t\t\treturn cout << -1, 0;\n\t\tcnt[mp[d[i].first + k - (n - k)]] += k;\n\t\tedg.push_back({d[i].second, mp[d[i].first + k - (n - k)]});\n\t\tMat[mp[d[i].first + k - (n - k)]].push_back(d[i].second);\n\t\tMat[d[i].second].push_back(mp[d[i].first + k - (n - k)]);\n\t}\n\tdfs(1);\n\tif (dist == d[1] && num == n && edg.size() == n - 1) {\n\t\tfor (int i = 0; i < edg.size(); i++)\n\t\t\tcout << edg[i].first << ' ' << edg[i].second << endl;\n\t\treturn 0;\n\t}\n\tcout << -1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nLL D[100111];\n\nVI G[100111];\n\nint par[100111];\nint sz[100111];\nLL C[100111];\n\nbool check() {\n    VI ord;\n    ord.reserve(N);\n    ord.push_back(0);\n    REP (i, N) {\n\tint v = ord[i];\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    ord.push_back(*e);\n\t    par[*e] = v;\n\t}\n    }\n    REP (i, N) {\n\tint v = ord[N-1-i];\n\tsz[v] = 1;\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    sz[v] += sz[*e];\n\t    C[v] += C[*e] + sz[*e];\n\t}\n    }\n    REP (i, N) {\n\tint v = ord[i];\n\tif (C[v] != D[v]) return false;\n\tEACH (e, G[v]) if (*e != par[v]) {\n\t    C[*e] += C[v] - (C[*e] + sz[*e]) + (N - sz[*e]);\n\t}\n    }\n\n    return true;\n}\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N) scanf(\"%lld\", D+i);\n\n    map<LL, pair<int, int> > mp;\n    REP (i, N) mp[D[i]] = make_pair(i, 1);\n    vector<pair<int, int> > E;\n    E.reserve(N);\n    bool yes = true;\n    while (mp.size() > 1u) {\n\tauto z = prev(mp.end());\n\tint i = z->second.first;\n\tint sz = z->second.second;\n\tLL cst = D[i] + 2 * sz - N;\n\tif (cst == D[i]) {\n\t    yes = false;\n\t    break;\n\t}\n\tauto it = mp.find(cst);\n\tif (it == mp.end()) {\n\t    yes = false;\n\t    break;\n\t}\n\n\tG[i].push_back(it->second.first);\n\tG[it->second.first].push_back(i);\n\tE.emplace_back(i, it->second.first);\n\tit->second.second += sz;\n\tmp.erase(z);\n    }\n\n    if (yes && check()) {\n\tEACH (e, E) printf(\"%d %d\\n\", e->first+1, e->second+1);\n    } else {\n\tputs(\"-1\");\n    }\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXn = 1e5 + 10;\ntypedef pair<long long, int> pii;\npii ar[MAXn];\nlong long n, sz[MAXn], root, disroot, d[MAXn], hp3[MAXn];\nvector<int> vec[MAXn];\nvector<pii> ans;\n\nbool cmp(pii p1, pii p2) {\n\treturn p1.first > p2.first;\n}\n\nlong long dfs1(int v, int  par) {\n\tlong long res = 0;\n\tfor (int i = 0; i < vec[v].size(); i++)\n\t\tif (vec[v][i] != par) {\n\t\t\tres += dfs1(vec[v][i], v) + hp3[vec[v][i]];\n\t\t\thp3[v] += hp3[vec[v][i]];\n\t\t}\n\thp3[v]++;\n\treturn res;\n\t\n}\n\nvoid dfs2(int v, int par, long long sth) {\n\tif (sth != d[v]) {\n\t\tcout << -1;\n\t\texit(0);\n\t}\n\tfor (int i = 0; i < vec[v].size(); i++) {\n\t\tif (vec[v][i] != par) {\n\t\t\tdfs2(vec[v][i], v, sth - (hp3[vec[v][i]]) + (hp3[ar[0].second] - hp3[vec[v][i]]));\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}\nint main() {\n\tcin >> n;\n\tfill_n(sz, MAXn, 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tint di;\n\t\tcin >> di;\n\t\td[i] = di;\n\t\tar[i].first = di;\n\t\tar[i].second = i;\n\t}\n\tsort(ar, ar + n);\n\tfor (int i = n - 1; i > 0; i--) {\n\t\tlong long hp = ar[i].first - n;\n\t\thp += 2LL * sz[ar[i].second];\n\t\tint hp2 = lower_bound(ar, ar + n, pii(hp, -1)) - ar;\n\t\tif (ar[hp2].first != hp)\n\t\t\treturn cout << -1,0;\n\t\tsz[ar[hp2].second] += sz[ar[i].second];\n\t\tvec[ar[hp2].second].push_back(ar[i].second);\n\t\tvec[ar[i].second].push_back(ar[hp2].second);\n\t\tans.push_back(pii(ar[i].second, ar[hp2].second));\n\t}\n\tdisroot = dfs1(ar[0].second, -1);\n\tdfs2(ar[0].second, -1, disroot);\n\tfor (int i = 0; i < ans.size(); i++)\n\t\tcout << ans[i].first + 1<< ' ' << ans[i].second + 1<< endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define maxn 100005\n#define pii pair<int,int>\nusing namespace std;\nint N;\npii arr[maxn];\nvector<int> G[maxn];\nint sz[maxn];\nvector<pii> ans;\nmain() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> N;\n\tfor(int i=1;i<=N;i++)\n\t\tcin >> arr[arr[i].second=i].first;\n\tsort(arr+1,arr+1+N);\n\tfor(int i=1;i<=N;i++)\n\t\tsz[i] = 1;\n\tfor(int i=N;i>1;i--) {\n\t\tint val = arr[i].first;\n\t\tint idx = arr[i].second;\n\t\tint pa_val = val-(N-sz[idx])+(sz[idx]);\n\t\tif(pa_val >= val) {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\tint tem = lower_bound(arr+1,arr+1+N,pii{pa_val,-1})-arr;\n\t\tif(tem==N+1 || arr[tem].first!=pa_val) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint pa = arr[tem].second;\n\t\tsz[pa] += sz[idx];\n\t\tans.emplace_back(pii{pa,idx});\n\t}\n\tfor(pii now : ans)\n\t\tcout << now.first << \" \" << now.second << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FR first\n#define SE second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,int> pr;\n\nmap <ll,int> mp;\npr num[100005];\n\nvector <int> e[100005];\nint siz[100005],dep[100005];\n\nvoid dfs(int x) {\n  for(int i=0;i<e[x].size();i++) {\n  \tint u=e[x][i];\n  \tdep[u]=dep[x]+1;\n  \tdfs(u);\n  }\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  for(int i=1;i<=n;i++) {\n  \tll x;\n  \tscanf(\"%lld\",&x);\n  \tnum[i]=pr(x,i);\n  \tmp[x]=i;\n  }\n  sort(num+1,num+n+1);\n  for(int i=1;i<=n;i++) siz[i]=1;\n  for(int i=n;i>1;i--) {\n  \tint x=num[i].SE;\n  \tif (siz[x]*2>=n) {\n  \t\tputs(\"-1\");\n  \t\treturn 0;\n\t  }\n\tll v=num[i].FR-(n-2*siz[x]);\n\tif (!mp.count(v)) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tint p=mp[v];\n\te[p].push_back(x);\n\tsiz[p]+=siz[x];\n  }\n  if (siz[num[1].SE]!=n) {\n  \tputs(\"-1\");\n  \treturn 0;\n  }\n  dfs(num[1].SE);\n  ll s=0;\n  for(int i=1;i<=n;i++) s+=dep[i];\n  if (s!=num[1].FR) {\n  \tputs(\"-1\");\n  \treturn 0;\n  }\n  for(int i=1;i<=n;i++)\n    for(int j=0;j<e[i].size();j++) printf(\"%d %d\\n\",i,e[i][j]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// comment\n// 가장 큰게 리프였다는 사실을 알았으면 해볼만 했을지도..\n// 가장 작은 값을 기준으로 트리를 만들면 밑으로 갈수록 점점 증가한다라는 사실을 인지하는 능력?\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define SZ(v) ((int)(v).size())\n#define ALL(v) (v).begin(),(v).end()\n#define one first\n#define two second\nusing ll = long long;\nusing pi = pair<int, int>;\nusing pli = pair<ll, int>;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 1ll * INF * INF;\n\nconst int MAX_N = 1e5 + 100;\n\nint N, Ix[MAX_N];\nll Ds[MAX_N];\nint S[MAX_N];\n\nint findD(ll d) {\n\tint ix = lower_bound(Ds+1, Ds+N+1, d) - Ds;\n\tif(Ds[ix] == d) return ix;\n\treturn -1;\n}\n\nint main() {\n\tcin >> N;\n\tvector<pli> temp;\n\tfor(int i=1; i<=N; i++) {\n\t\tscanf(\"%lld\", &Ds[i]);\n\t\ttemp.emplace_back(Ds[i], i);\n\t}\n\tsort(Ds+1, Ds+N+1);\n\tsort(ALL(temp));\n\tfor(int i=0; i<N; i++) Ix[i+1] = temp[i].two;\n\tfor(int i=1; i<=N; i++) S[i] = 1;\n\t\n\tvector<pi> Ans;\n\t//for(int i=1; i<=N; i++) printf(\"%lld \", Ds[i]); puts(\"\");\n\tfor(int i=N; i>=2; i--) {\n\t\tll pd = Ds[i] + 2*S[i] - N;\n\t\tint ix = findD(pd);\n\t\t//printf(\"%lld [%lld + 2*%d - %d] %d\\n\", pd, Ds[i], S[i], N, ix);\n\t\tif(ix == -1 || ix == i) return puts(\"-1\") < 0;\n\t\tS[ix] += S[i];\n\t\tAns.emplace_back(Ix[ix], Ix[i]);\n\t}\n\tif(S[1] != N) return puts(\"-1\") < 0;\n\tfor(auto p: Ans) {\n\t\tint x, y; tie(x, y) = p;\n\t\tprintf(\"%d %d\\n\", x, y);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \n#define ll long long\n#define all(aaa) aaa.begin(), aaa.end()\n\nconst int N = 1e5 + 5;\nint sz[N];\nvector<int> g[N];\n\nll dfs(int node, int h) {\n\tll ans = h;\n\tfor (int to : g[node]) {\n\t\tans += dfs(to, h + 1);\n\t}\n\treturn ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n;\n    cin >> n;\n\n    map<ll, int> mp;\n\n    for (int i = 0; i < n; i++) {\n    \tll d;\n    \tcin >> d;\n    \tmp[d] = i;\n    \tsz[i] = 1;\n    }\n\n    while (!mp.empty()) {\n    \tll x = mp.rbegin()->first;\n    \tint y = mp.rbegin()->second;\n\n    \t// cout << x + 2 * sz[y] - n << \" \" << y << \"\\n\";\n\n    \tif (mp.size() == 1) {\n    \t\tbreak;\n    \t}\n\n    \tif (x + 2 * sz[y] - n >= x) {\n    \t\tcout << \"-1\";\n    \t\treturn 0;\n    \t}\n\n    \tif (!mp.count(x + 2 * sz[y] - n)) {\n    \t\tcout << \"-1\";\n    \t\treturn 0;\n    \t}\n\n    \tint z = mp[x + 2 * sz[y] - n];\n\n    \tsz[z] += sz[y];\n    \tg[z].push_back(y);\n\n    \tmp.erase(prev(mp.end()));\n    }\n\n    int rt = mp.begin()->second;\n\n    if (dfs(rt, 0) != mp.begin()->first) {\n    \tcout << \"-1\";\n    \treturn 0;\n    }\n\n    for (int i = 0; i < n; i++) {\n    \tfor (int to : g[i]) {\n    \t\tcout << i + 1 << \" \" << to + 1 << \"\\n\";\n    \t}\n    }\n\n    return 0;   \n}"
  },
  {
    "language": "C++",
    "code": "//I love Nanami Chiaki\n#include<bits/stdc++.h>\nusing namespace std;\n#define pii pair<int,int>\n#define mp make_pair\n#define fst first\n#define snd second\nconst int maxn=1e5+7;\nint n,d[maxn];\npii sx[maxn];\nint sz[maxn];\nint dis[maxn];\nint findit(int t){\n\tif (t<0) return -1;\n\tint l=0,r=n-1,mid;\n\twhile (l<=r){\n\t\tmid=(l+r)>>1;\n\t\tif (sx[mid].fst==t) return mid;\n\t\tif (sx[mid].fst<t) l=mid+1;\n\t\telse r=mid-1;\n\t}\n\treturn -1;\n}\nvoid badend(){\n\tputs(\"-1\");\n\texit(0);\n}\nvector<pii> ans;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=0;i<n;i++){\n\t\tscanf(\"%lld\",d+i);\n\t\tsx[i]=mp(d[i],i);\n\t\tsz[i]=1;dis[i]=0;\n\t}\n\tsort(sx,sx+n);\n\tfor (int i=n-1;i>0;i--){\n\t\tint v=sx[i].snd,w=sx[i].fst;\n\t\tint u=findit(w+sz[v]*2-n);\n\t\tif (u==-1) badend();\n\t\tu=sx[u].snd;\n\t\tsz[u]+=sz[v];\n\t\tans.push_back(mp(u+1,v+1));\n\t\tdis[u]+=dis[v]+sz[v];\n\t}\n\tif (dis[sx[0].snd]!=sx[0].fst) badend();\n\tfor (int i=0;i<n-1;i++){\n\t\tprintf(\"%d %d\\n\",ans[i].fst,ans[i].snd);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#include<iostream>\n#include<map>\n#include<vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__) \n#define ref(a,b,c) for(int a=b;a<=c;++a)\n#define def(a,b,c) for(int a=b;a>=c;--a)\n#define fi first\n#define se second\nusing namespace std;\ninline char nc(){\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++; \n}\ntemplate<class T>void read(T &x){\n\tx=0;int f=1,ch=nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx*=f;\n}\ntypedef long long LL;\ntypedef pair<int,int> pii;\nconst int maxn=1e5+10;\nLL D[maxn];\nint n;\nint p[maxn];\nint siz[maxn];\nmap<LL,int>idx; \nvector<pii>an; \ninline int cmp(const int&a,const int&b){\n\treturn D[a]>D[b];\n}\nbool solve(){\n\tref(i,1,n)p[i]=i,siz[i]=1;\n\tsort(p+1,p+n+1,cmp);\n\tref(i,1,n-1){\n\t\tint u=p[i];\n\t\tif(!idx.count(D[u]-n+2*siz[u]))return 0;\n\t\tint fa=idx[D[u]-n+2*siz[u]]; \n\t\tif(u==fa)return 0;\n\t\tan.push_back(make_pair(fa,u)),siz[fa]+=siz[u];\n\t}\n\tref(i,0,n-2)printf(\"%d %d\\n\",an[i].fi,an[i].se);\n\treturn 1;\n}\nint main(){\n\tread(n);\n\tref(i,1,n){\n\t\tread(D[i]);\n\t\tidx[D[i]]=i;\n\t}\n\tif(!solve())puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n\n#define LOG(...) fprintf (stderr, __VA_ARGS__)\n#define pb push_back\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n\nconst int INF = 0x3f3f3f3f, N = 100005;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fll;\n\nint n, sz[N], dep[N];\npair <LL, int> d[N];\nbool cmp(pair <LL, int> a, pair <LL, int> b) { return a.first > b.first; }\nmap <int, int> mp;\nvector <int> g[N];\nvoid link(int x, int y){\n    g[x].push_back(y);\n//    g[y].push_back(x); \n}\n\nvoid dfs(int u, int pre) {\n    for (int i = 0; i < g[u].size(); i++) {\n        int v = g[u][i];\n        if (v == pre) continue;\n        dep[v] = dep[u] + 1;\n        dfs(v, u);\n    }\n}\n\nint main() { \n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) scanf(\"%lld\", &d[i].first), d[i].second = i, mp[d[i].first] = i; \n\n    sort (d + 1, d + n + 1, cmp);\n    int root = d[n].second;\n    for (int i = 1; i <= n; i++) sz[i] = 1; \n    for (int i = 1; i < n; i++) {\n        LL fa = d[i].first - n + 2 * sz[d[i].second];\n        if (mp[fa]) {\n            int ff = mp[fa];\n            if (ff == d[i].second) return 0*puts(\"-1\");\n            sz[ff] += sz[d[i].second]; link(ff, d[i].second); \n        }\n        else return 0*puts(\"-1\");\n    }\n\n    dfs (root, 0); \n\n    if (accumulate(dep + 1, dep + n + 1, 0LL) != d[n].first)\n        return puts(\"-1\"), 0; \n    for(int i = 1; i <= n; i++)\n        for (int j = 0; j < g[i].size(); j++)\n            cout << i << \" \" << g[i][j] << endl; \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int ll\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define gc getchar\n#define pc putchar\n#define fi first\n#define se second\n#define debug(x) cout << #x\" = \" << x << endl;\n#define pp(x,y) cout << \"pp: \" << x << \" \" << y << endl;\n#define rank __RAnK\ninline ll read(){\n\tregister ll x=0,f=1;register char c=gc();\n\tfor(;!isdigit(c);c=gc())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\n#define rd read\nvoid write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\nvoid writeln(ll x){write(x);puts(\"\");}\nconst int maxn = 1e5+233;\nvector<pair<int,int> > ans;\nint d[maxn],w[maxn],a[maxn];\nint del,n;\nbool cmp(int x,int y){\n\treturn d[x] < d[y];\n}\nint query(int l,int r,int need){\n\tint pos = -1;\n\twhile(l<=r){\n\t\tint mid =(l+r)>>1;\n\t\tif(d[a[mid]] - del < need) l = mid + 1; else\n\t\tif(d[a[mid]] - del > need) r = mid - 1; else\n\t\treturn a[mid];\n\t}\n\treturn -1;\n}\nsigned main(){\n\tn = rd();\n\tRep(i,1,n) d[i] = rd();\n\tRep(i,1,n) w[i] = 1;\n\tRep(i,1,n) a[i] = i;\n\tsort(a+1,a+1+n,cmp);//从小到大排序 \n\tdel = 0;\n\tDep(i,n,2){\n\t\t/*当前是a[i] - del，权重为w[i]\n\t\t移动一步\n\t\t对于所有(n-w[i])个点，都要减少1*/\n\t\tll need = d[a[i]] - del - (n - w[a[i]]) + w[a[i]]; \n\t\tint pos = query(1,i-1,need);//找到标号\n\t\tif(pos == -1){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tdel += w[a[i]];\n\t\tw[pos] += w[a[i]];\n\t\tans . push_back(pii(a[i],pos));\n\t}\n\tif(d[a[1]] != del){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(auto i:ans){\n\t\tprintf(\"%lld %lld\\n\",i.fi,i.se);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int maxn=1e5+5;\ninline int read(){\n\tchar c=getchar();int t=0,f=1;\n\twhile((!isdigit(c))&&(c!=EOF)){if(c=='-')f=-1;c=getchar();}\n\twhile((isdigit(c))&&(c!=EOF)){t=(t<<3)+(t<<1)+(c^48);c=getchar();}\n\treturn t*f;\n}\nint n; \nstruct node{\n\tint id,d;\n\tnode(int d1=0,int id1=0){d=d1,id=id1;}\n\tfriend bool operator <(node a,node b){return a.d<b.d;}\n}a[maxn];\nint sz[maxn],u[maxn],v[maxn],dis,cnt;\nsigned main(){\n\tn=read();\n\tfor(int i=1;i<=n;i++){\n\t\ta[i]=node(read(),i),sz[i]=1;\n\t}\n\tsort(a+1,a+1+n);\n\tfor(int i=n;i>1;i--){\n\t\tint d=a[i].d-n+(sz[i]<<1);\n\t\tint p=lower_bound(a+1,a+1+n,node(d,0))-a;\n\t\tif(a[p].d!=d){puts(\"-1\");return 0;}\n\t\tcnt++;\n\t\tu[cnt]=a[i].id;v[cnt]=a[p].id;\n\t\tsz[p]+=sz[i];\n\t\tdis+=sz[i];\n\t}\n\tif(a[1].d!=dis){\n\t\tputs(\"-1\");return 0;\n\t}\n\tfor(int i=1;i<=cnt;i++){\n\t\tprintf(\"%d %d\\n\",u[i],v[i]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,x,y) for(int i=x;i<=y;++i)\n#define rf(i,x,y) for(int i=x;i>=y;--i)\n#define LL long long\nusing namespace std;\nconst int N=1e5+10;\nstruct data{\n\tint nt,to;\n}a[N<<1];\nmap<LL,int>ys;\nint cnt=0,head[N],sz[N];\nLL d[N],dis[N];\n\ntemplate <class T>\nvoid read(T &x){\n\tchar ch=getchar();x=0;\n\tfor(;ch<'0'||ch>'9';ch=getchar()) ;\n\tfor(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<1)+(x<<3)+(ch^48);\n}\n\nvoid add(int x,int y){\n\ta[++cnt].to=y,a[cnt].nt=head[x],head[x]=cnt;\n\ta[++cnt].to=x,a[cnt].nt=head[y],head[y]=cnt;\n}\n\nvoid fail(){\n\tprintf(\"-1\\n\");\n\texit(0);\n}\n\nvoid dfs(int u,int fa){\n\tfor(int i=head[u];i;i=a[i].nt){\n\t\tif(a[i].to==fa) continue;\n\t\tdis[a[i].to]=dis[u]+1;\n\t\tdfs(a[i].to,u);\n\t}\n}\n\nint main(){\n\tint n;read(n);\n\tfr(i,1,n) read(d[i]),ys[d[i]]=i;\n\tsort(d+1,d+1+n);\n\tfr(i,1,n) sz[i]=1;\n\trf(i,n,2){\n\t\tint u=ys[d[i]];\n\t\tint gg=n-2*sz[u];\n\t\tif(gg<0) fail();\n\t\tLL pos=d[i]-gg;\n\t\tif(!ys.count(pos)) fail();\n\t\tsz[ys[pos]]+=sz[u];\n\t\tadd(ys[pos],u);\n\t}\n\tdfs(ys[d[1]],0);\n\tfr(i,1,n) d[1]-=dis[i];\n\tif(d[1]) fail();\n\tfr(u,1,n){\n\t\tfor(int i=head[u];i;i=a[i].nt){\n\t\t\tif(i&1) printf(\"%d %d\\n\",a[i].to,u);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#include <numeric>\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\ntypedef complex<ld> com;\nconstexpr int inf = 1000000000;\nconstexpr ll INF = 1000000000000000000;\nconstexpr ld EPS = 1e-12;\nconstexpr ld PI = 3.141592653589793238;\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\n\tint n;\n\tcin >> n;\n\tvector<ll> d(n);\n\tmap<ll, int> mp;\n\trep(i, n) {\n\t\tcin >> d[i];\n\t\tmp[d[i]] = i;\n\t}\n\tsort(all(d));\n\tvector<int> sz(n, 1);\n\tvector<P> ans;\n\tvector<vector<int>> graph(n, vector<int>());\n\tfor (int i = n - 1; i >= 1; i--) {\n\t\tint v = mp[d[i]];\n\t\tll dis = n - sz[v] * 2;\n\t\tll par = d[i] - dis;\n\t\tll idx = lower_bound(all(d), par) - d.begin();\n\t\tif (dis <= 0 || d[idx] != par) {\n\t\t\tcout << -1 << '\\n';\n\t\t\treturn 0;\n\t\t}\n\t\tans.pb(P(mp[d[idx]] + 1, v + 1));\n\t\tgraph[mp[d[idx]]].pb(v);\n\t\tgraph[v].pb(mp[d[idx]]);\n\t\tsz[mp[d[idx]]] += sz[v];\n\t}\n\tint root = mp[d[0]];\n\tll sum = 0;\n\tqueue<P> que;\n\tvector<bool> vis(n);\n\tque.push(P(root, 0)); vis[root] = true;\n\twhile (!que.empty()) {\n\t\tP p = que.front(); que.pop();\n\t\tint pf = p.first; int ps = p.second;\n\t\tsum += ps;\n\t\tfor (int i : graph[pf]) {\n\t\t\tif (vis[i]) continue;\n\t\t\tque.push(P(i, ps + 1));\n\t\t\tvis[i] = true;\n\t\t}\n\t}\n\tif (sum != d[0]) cout << -1 << '\\n';\n\telse for (P p : ans) cout << p.first << ' ' << p.second << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <string>\n#include <cstring>\n\n#define sz(v) ((int)((v).size()))\n#define all(v) (v).begin(), (v).end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int INF = 0x3c3c3c3c;\nconst ll LINF = 1ll*INF*INF*2;\n\nconst int MAX_N = 100001;\nint n;\nll input[MAX_N];\nint sz[MAX_N];\nint par[MAX_N];\nll sum[MAX_N];\n\nint main(void) {\n\tscanf(\"%d\", &n);\n\tfor(int i=0; i<n; i++) scanf(\"%lld\", input+i);\n\n\tsort(input, input+n);\n\tfor(int i=0; i<n; i++) sz[i] = 1;\n\n\tfor(int i=n-1; i>0; i--) {\n\t\tll temp = input[i]+sz[i]+sz[i]-n;\n\t\tint idx = lower_bound(input, input+n, temp)-input;\n\t\tif(input[idx] != temp) {\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tpar[i] = idx;\n\t\tsz[idx]+=sz[i];\n\t\tsum[idx]+=sum[i]+sz[i];\n\t}\n\n\tif(sum[0] != input[0]) {\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\n\tfor(int i=1; i<n; i++) {\n\t\tprintf(\"%d %d\\n\", par[i]+1, i+1);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<vector>\n#define pb push_back\n\ntypedef long long LL;\n\nconst int N=100005;\n\nint n,size[N],id[N],ans1[N],ans2[N];\nLL tot,a[N];\nstd::map<LL,int> num;\nstd::vector<int> vec[N];\n\nbool cmp(int x,int y)\n{\n\treturn a[x]>a[y];\n}\n\nvoid dfs(int x,int fa,int d)\n{\n\ttot+=(LL)d;\n\tfor (int i=0;i<vec[x].size();i++)\n\t\tif (vec[x][i]!=fa) dfs(vec[x][i],x,d+1);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%lld\",&a[i]),num[a[i]]=i;\n\tfor (int i=1;i<=n;i++) size[i]=1,id[i]=i;\n\tstd::sort(id+1,id+n+1,cmp);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x=id[i];LL w=a[x]-(n-size[x])+size[x];\n\t\tif (!num[w]||w>=a[x]) {puts(\"-1\");return 0;}\n\t\tint y=num[w];\n\t\tans1[i]=x;ans2[i]=y;\n\t\tvec[x].pb(y);vec[y].pb(x);\n\t\tsize[y]+=size[x];\n\t}\n\tdfs(id[n],0,0);\n\tif (tot!=a[id[n]]) {puts(\"-1\");return 0;}\n\tfor (int i=1;i<n;i++) printf(\"%d %d\\n\",ans1[i],ans2[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n, sz[100007], fa[100007];\npair<int, int>p[100007];\nvector<int>e[100007];\nint read()\n{\n\tint num = 0;\n\tchar c = getchar();\n\twhile (c<'0' || c>'9')c = getchar();\n\twhile (c >= '0' && c <= '9')num = num * 10 + c - '0', c = getchar();\n\treturn num;\n}\nint dfs(int w, int f)\n{\n\tint res = 0;\n\tfor (int i = 0, lim = e[w].size(); i < lim; i++)\n\t\tres += dfs(e[w][i], w) + sz[e[w][i]];\n\treturn res;\n}\nint main()\n{\n\tn = read();\n\tfor (int i = 1; i <= n; i++)\n\t\tp[i] = make_pair(read(), i);\n\tsort(p + 1, p + n + 1);\n\tfor (int i = n; i > 1; i--)\n\t{\n\t\tint x = p[i].second;\n\t\tsz[x]++;\n\t\tint pos = lower_bound(p + 1, p + n + 1, make_pair(p[i].first + 2 * sz[x] - n, 0)) - p;\n\t\tif (pos >= i || p[i].first + 2 * sz[x] - n != p[pos].first) { cout << -1 << endl; return 0; }\n\t\tfa[x] = p[pos].second;\n\t\tsz[fa[x]] += sz[x];\n\t\te[fa[x]].push_back(x);\n\t}\n\tsz[p[1].second]++;\n\tif(dfs(p[1].second,0)!=p[1].first) { cout << -1 << endl; return 0; }\n\tfor (int i = 1; i <= n; i++)\n\t\tif (fa[i])printf(\"%d %d\\n\", fa[i], i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint N;\nll D[100005];\nll parent[100005];\nmap<ll,int> tree_sizes;\n\nmap<ll,int> D_to_old;\nint new_to_old[100005];\n\nint main() {\n        cin >> N;\n        for (int i=0; i<N; i++) {\n                cin >> D[i];\n                tree_sizes[D[i]] = 1;\n                D_to_old[D[i]] = i;\n                parent[i] = -1;\n        }\n\n        sort(D,D+N);\n\n        for (int i=0; i<N; i++) {\n                new_to_old[i] = D_to_old[D[i]];\n        }\n\n        ll tot_depth = 0;\n        for (int i=N-1; i>=1; i--) {\n                if (N - 2*tree_sizes[D[i]] <= 0) {\n                        cout << \"-1\\n\";\n                        return 0;\n                }\n\n                auto new_parent = tree_sizes.find(D[i] - (N - 2*tree_sizes[D[i]]));\n                if (new_parent == tree_sizes.end()) {\n                        cout << \"-1\\n\";\n                        return 0;\n                }\n\n                parent[new_to_old[i]] = D_to_old[new_parent->first];\n                new_parent->second += tree_sizes[D[i]];\n                tot_depth += tree_sizes[D[i]];\n        }\n\n        if (D[0] != tot_depth) {\n                cout << \"-1\\n\";\n                return 0;\n        }\n\n        for (int i=0; i<N; i++) {\n                if (parent[i] != -1) {\n                        cout << i+1 << \" \" << parent[i]+1 << endl;\n                }\n        }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\nbool is_valid(vector<pair<long long, int>> &D, vector<pair<int, int>> &edges){\n    int N = D.size();\n    vector<vector<int>> G(N);\n    for(auto x : edges){\n        G[x.first].push_back(x.second);\n        G[x.second].push_back(x.first);\n    }\n    queue<pair<int, long long>> que;\n    vector<bool> vis(N, false);\n    que.push(make_pair(0, 0));\n    long long cnt = 0;\n    while(!que.empty()){\n        auto q = que.front();\n        que.pop();\n        if(vis[q.first]) continue;\n        vis[q.first] = true;\n        cnt += q.second;\n        for(auto x : G[q.first])\n            que.push(make_pair(x, q.second+1));\n    }\n    return cnt == D[0].first;\n}\n\nint main(){\n    long long N;\n    cin >> N;\n    vector<pair<long long, int>> D(N);\n    for(int i=0; i<N; i++){\n        long long tmp;\n        cin >> tmp;\n        D[i] = make_pair(tmp, i);\n    }\n    sort(D.begin(), D.end(), greater<pair<long long, int>>());\n\n    vector<int> idx2idx(N);\n    for(int i=0; i<N; i++)\n        idx2idx[i] = D[i].second;\n\n    map<long long, int> d2idx;\n    for(int i=0; i<N; i++)\n        d2idx[D[i].first] = i;\n\n    vector<long long> E(N, 0);\n    vector<pair<int, int>> edges;\n    for(int i=0; i<N-1; i++){\n        if(E[i] == 0) E[i] = 1;\n        long long d0 = D[i].first;\n        long long d1 = D[i].first + 2 * E[i] - N;\n        auto itr = d2idx.find(d1);\n        if(itr == d2idx.end() || i >= d2idx[d1]){\n            cout << -1 << endl;\n            return 0;\n        }\n        edges.push_back(make_pair(i, d2idx[d1]));\n        E[d2idx[d1]] += E[i] + 1;\n    }\n\n    if(!is_valid(D, edges)){\n        cout << -1 << endl;\n        return 0;\n    }\n\n    for(auto x : edges)\n        cout << idx2idx[x.first]+1 << \" \" << idx2idx[x.second]+1 << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint N;\nll D[100005];\nll parent[100005];\nmap<ll,int> tree_sizes;\n\nmap<ll,int> D_to_old;\nint new_to_old[100005];\n\nint main() {\n        cin >> N;\n        for (int i=0; i<N; i++) {\n                cin >> D[i];\n                tree_sizes[D[i]] = 1;\n                D_to_old[D[i]] = i;\n                parent[i] = -1;\n        }\n\n        sort(D,D+N);\n\n        for (int i=0; i<N; i++) {\n                new_to_old[i] = D_to_old[D[i]];\n        }\n\n        for (int i=N-1; i>=1; i--) {\n                auto new_parent = tree_sizes.find(D[i] - (N - 2*tree_sizes[D[i]]));\n                if (new_parent == tree_sizes.end()) {\n                        cout << \"-1\\n\";\n                        return 0;\n                }\n\n                parent[new_to_old[i]] = D_to_old[new_parent->first];\n                new_parent->second += tree_sizes[D[i]];\n        }\n\n        for (int i=0; i<N; i++) {\n                if (parent[i] != -1) {\n                        cout << i+1 << \" \" << parent[i]+1 << endl;\n                }\n        }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n \nint n,nn;\nstruct node{int p,f,s;long long d,ss;};\nnode a[100010];\n \nvoid qsort(int l,int r)\n{\n\tint i,j;\n\tnode m,t;\n\ti=l;j=r;\n\tm=a[(l+r)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (a[i].d>m.d) i++;\n\t\twhile (a[j].d<m.d) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tt=a[i];a[i]=a[j];a[j]=t;\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort(l,j);\n\tif (i<r) qsort(i,r);\n}\n\nint find(long long x,int l,int r)\n{\n\tint m=(l+r)/2;\n\twhile (l<=r)\n\t{\n\t\tif (a[m].d==x) return m;\n\t\tif (a[m].d>x) l=m+1;\n\t\telse r=m-1;\n\t\tm=(l+r)/2;\n\t}\n\treturn -1;\n}\n \nint main()\n{\n\tscanf(\"%d\",&n);\n\tnn=n-2;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&a[i].d);\n\t\ta[i].p=i;\n\t\ta[i].f=-1;\n\t\ta[i].s=1;\n\t\ta[i].ss=0;\n\t}\n\tqsort(1,n);\n\tbool ok=true;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tlong long fd=a[i].d-(n-a[i].s*2);\n\t\tint fn;\n\t\tfn=find(fd,i+1,n);\n\t\tif (fn==-1 || fd>a[i].d) {ok=false;break;}\n\t\ta[i].f=a[fn].p;\n\t\ta[fn].s+=a[i].s;\n\t\ta[fn].ss+=a[i].s+a[i].ss;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tif (a[i].f==-1 && a[i].ss!=a[i].d) {ok=false;break;}\n\tif (ok)\n\t{\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tif (a[i].f!=-1) printf(\"%d %d\\n\",a[i].f,a[i].p);\n\t\t}\n\t}\n\telse printf(\"-1\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC target (\"sse4.2\")\n#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx,avx2,fma\")\n#pragma GCC optimize (\"unroll-loops\")\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;\n\n#define MP make_pair\n#define sp(x) fixed<<setprecision(x)\n#define pb push_back\n#define die(x) return cout << x << endl, 0\n#define fastio ios_base::sync_with_stdio(0);cin.tie(nullptr);cout.tie(nullptr);\n#define file ifstream cin(\"input.txt\"); ofstream cout(\"output.txt\")\n#define F first\n#define S second\n#define int long long\n#define lc ind << 1\n#define rc ind << 1 | 1\n//thissss\nconst int MAXN = 1000 * 1000 + 7, MOD = 1000 * 1000 * 1000 + 7;\nint n, sz[MAXN], par[MAXN];\npair<int, int>d[MAXN];\nmap<int, int>pos;\nint32_t main(){\n    fastio;\n\tcin >> n;\n\tfor(int i = 0; i < n; i ++){\n\t\tcin >> d[i].F;\n\t\td[i].S = i;\n\t}\n\tsort(d, d + n, greater<pair<int, int> >());\n\tfor(int i = 0; i < n; i ++)\n\t\tpos[d[i].F] = i + 1;\n\tfill(sz, sz + n, 1);\n\tfor(int i = 0; i < n - 1; i ++){\n\t\tint dis = d[i].F, v = d[i].S;\n\t\tint dpar = dis - (n - 2*sz[v]);\n\t\tint par= pos[dpar];\n\t\tpar --;\n\t\tif(par == -1 || par == i)die(-1);\n\t\t::par[v] = d[par].S;\n\t\tsz[::par[v]] += sz[v];\n\t}\n\tfor(int i = 0; i < n - 1; i ++){\n\t\tint v = d[i].S;\n\t\tcout << v + 1 << ' ' << par[v] + 1 << endl;\n\t}\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=100010;\nint n,l,r,mid,j,p[N],siz[N],fa[N];\nlong long d[N],dis[N];\nbool cmp(int x,int y) {return d[x]<d[y];}\nlong long read() {\n\tlong long tmp=0, fh=1; char c=getchar();\n\twhile (c<'0'||c>'9') {if (c=='-') fh=-1; c=getchar();}\n\twhile (c>='0'&&c<='9') tmp=tmp*10+c-48, c=getchar();\n\treturn tmp*fh;\n}\nint main() {\n\tn=read();\n\tfor (int i=1;i<=n;i++) d[i]=read(), p[i]=i, siz[i]=1;\n\tsort(p+1,p+n+1,cmp);\n\tfor (int i=n,j=i-1;i>1;i--) {\n\t\tl=1; r=i;\n\t\twhile (l+1<r) {\n\t\t\tmid=(l+r)>>1;\n\t\t\tif (d[p[mid]]<=d[p[i]]+siz[p[i]]*2-n) l=mid; else r=mid;\n\t\t}\n\t\tj=l;\n\t\tif (d[p[j]]==d[p[i]]+siz[p[i]]*2-n) siz[p[j]]+=siz[p[i]], dis[p[j]]+=dis[p[i]]+siz[p[i]], fa[p[i]]=p[j];\n\t\telse {\n\t\t\tprintf(\"-1\\n\"); return 0;\n\t\t}\n\t}\n\tif (dis[p[1]]!=d[p[1]]) printf(\"-1\\n\"); else\n\t\tfor (int i=2;i<=n;i++) printf(\"%d %d\\n\",fa[p[i]],p[i]);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100005\n#define int long long\nusing namespace std;\n\nmap<int,int>mmp;\nvector<int>g[N];\nint d[N],fa[N],pd[N],f[N],n,sz[N];\n\nvoid dfs1(int x,int s,int dep){\n\tpd[s]+=dep;\n\tfor(int i=0;i<g[x].size();++i) dfs1(g[x][i],s,dep+1);\n}\n\nvoid dfs2(int x){\n\tfor(int i=0;i<g[x].size();++i){\n\t\tpd[g[x][i]]=f[x]-2*sz[g[x][i]]+n;\n\t\tdfs2(g[x][i]);\n\t} \t\n}\n\nmain(){\n\tint x,mx=0,cnt=0,a,i;\n\tscanf(\"%lld\",&n);\n\tfor(i=1;i<=n;++i) scanf(\"%lld\",&d[i]),f[i]=d[i],mmp[d[i]]=i;\n\tfor(i=1;i<=n;++i) sz[i]=1;\n\tsort(d+1,d+n+1);\n\tfor(i=n;i>1;--i){\n\t\ta=mmp[d[i]];\n\t\tx=d[i]-(n-sz[a])+sz[a];\n\t\tif(x>=d[i]) return printf(\"-1\")&0;\n\t\tif(!mmp[x]) return printf(\"-1\")&0;\n\t\tfa[a]=mmp[x];\n\t\tsz[mmp[x]]+=sz[a];\n\t}\n\tfor(i=1;i<=n;++i) if(fa[i]) g[fa[i]].push_back(i);\n\t//judge\n\tint y=mmp[d[1]];\n\tdfs1(y,y,0);\n\tdfs2(y);\n\tfor(i=1;i<=n;++i) if(pd[i]!=f[i]) return printf(\"-1\")&0;\n\tfor(i=1;i<=n;++i) if(fa[i]) printf(\"%lld %lld\\n\",fa[i],i);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> ii;\n\nconst int N = 1e6 + 5;\n\nvector<int> adj[N];\nint n, sub[N];\nll d[N], D;\nmap<ll, int> pos;\n\nvoid no_answer() {\n  puts(\"-1\");\n  exit(0);\n}\n\nvoid calc(int u, int p, int d = 0) {\n  D += d; \n  for (int v : adj[u]) calc(v, u, d + 1);\n}\n\nvoid check(int u, int p, ll D) {\n  if (D != d[u]) no_answer();\n  for (int v : adj[u]) check(v, u, D + n - 2 * sub[v]);\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%lld\", &d[i]);\n    pos[d[i]] = i;\n  }\n\n  vector<int> ord(n);\n  iota(ord.begin(), ord.end(), 1);\n  sort(ord.begin(), ord.end(), [](int i, int j) { return d[i] > d[j]; });\n\n  for (int i = 0; i < n - 1; ++i) {\n    int u = ord[i];\n    ++sub[u];\n    ll dp = d[u] - n + 2 * sub[u];\n    if (!pos.count(dp)) no_answer();\n    int p = pos[dp];\n    sub[p] += sub[u];\n    adj[p].push_back(u);\n  }\n\n  calc(ord[n - 1], 0);\n  check(ord[n - 1], 0, D);\n\n  for(int i = 1; i <= n; ++i) {\n    for(int j : adj[i]) {\n      printf(\"%d %d\\n\", i, j); \n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(), vec.end()\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll INF = (1LL << 30) - 1LL;\nconstexpr ll LINF = (1LL << 60) - 1LL;\nconstexpr double eps = 1e-9;\nconstexpr ll MOD = 1000000007LL;\ntemplate <typename T> bool chmin(T &a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n};\ntemplate <typename T> bool chmax(T &a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n};\ntemplate <typename T> ostream &operator<<(ostream &os, vector<T> v) {\n    for (int i = 0; i < v.size(); i++) {\n        os << v[i] << (i + 1 == v.size() ? \"\\n\" : \" \");\n    }\n    return os;\n}\ntemplate <typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate <typename T, typename... Ts> auto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value == 0>::type fill_v(T &t, const V &v) {\n    t = v;\n}\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value != 0>::type fill_v(T &t, const V &v) {\n    for (auto &e : t) {\n        fill_v(e, v);\n    }\n};\nvector<vector<int>> G;\nll dfs(int i, int p, ll d) {\n    ll res = d;\n    for (auto &e : G[i]) {\n        if (e == p) {\n            continue;\n        }\n        res += dfs(e, i, d + 1LL);\n    }\n    return res;\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vector<P> v;\n    map<ll, int> mp;\n    for (int i = 0; i < n; i++) {\n        ll d;\n        cin >> d;\n        v.push_back(P(d, i));\n        mp[d] = i;\n    }\n    sort(all(v));\n    reverse(all(v));\n    vector<ll> sz(n, 1);\n    vector<P> res;\n    G.resize(n);\n    for (int i = 0; i < n - 1; i++) {\n        ll d = v[i].first, id = v[i].second;\n        if (mp.count(d - (n - 2LL * sz[id]))) {\n            int to = mp[d - (n - 2LL * sz[id])];\n            G[to].push_back(id);\n            sz[to] += sz[id];\n            res.push_back(P(to, id));\n        } else {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n    if (dfs(v[n - 1].second, -1, 0) != v[n - 1].first) {\n        cout << -1 << endl;\n        return 0;\n    }\n    for (auto &p : res) {\n        cout << p.first + 1 << \" \" << p.second + 1 << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nlong long d[100001];\nint x[100001];\nint size[100001];\nvector<pair<int, int> > edge;\nmap<long long, int>f;\nbool cmp(int x, int y) {\n    return d[x] > d[y];\n}\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n ; i ++)\n        scanf(\"%lld\", &d[i]), x[i] = i, size[i] = 1, f[d[i]] = i;\n    sort(x + 1, x + n + 1, cmp);\n    bool sig = 0;\n    for (int i = 1; i <= n ; i ++) {\n        long long dd = d[x[i]] +size[x[i]] - n + size[x[i]];\n        if (dd != d[x[i]]&&f[dd]) size[f[dd]] += size[x[i]], edge.push_back(make_pair(x[i], f[dd]));\n    }\n    if (size[x[n]] == n && edge.size() == n - 1){\n        for (auto u : edge) printf(\"%d %d\\n\", u.first, u.second);\n    } else printf(\"-1\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)   FOR(i,0,n)\n#define LL long long\n\nint n;\nvector<LL> d;\nvector<LL> ind,width;\nvector<pair<int,int>> ans;\nmap<LL,int> mp,mp_sorted;\n\nLL dfs(vector<vector<int>> tree,int pos,LL cum){\n  LL ret = cum;\n  REP(i,tree[pos].size())\n    ret += dfs(tree,tree[pos][i],cum+1);\n  return ret;\n}\n\nint main(){\n  cin>>n;\n  LL tmp;\n  REP(i,n){\n    cin>>tmp;\n    d.push_back(tmp);\n  }\n  REP(i,d.size())\n    mp[d[i]] = i;\n  sort(d.begin(),d.end());\n  REP(i,d.size())\n    mp_sorted[d[i]] = i;\n  ind.resize(n);\n  REP(i,n)\n    ind[i] = mp[d[i]]+1;\n  REP(i,n)\n    width.push_back(1);\n  \n\n  vector<vector<int>> tree(n);\n  REP(i,n-1){\n    LL s = d[n-1-i] - (n - 2*width[n-1-i]);\n    int min_ind2 = mp_sorted[s];\n    if(d[min_ind2] != s){\n      cout<<-1<<endl;\n      return 0;\n    }\n    ans.push_back(make_pair(min_ind2,n-1-i));\n    tree[min_ind2].push_back(n-1-i);\n    //tree[n-1-i].push_back(min_ind2);\n    width[min_ind2] += width[n-1-i];\n  }\n  if(d[0] != dfs(tree,0,0)){\n    cout<<-1<<endl;\n    return 0;\n  }\n  \n  REP(i,ans.size())\n    cout<<ind[ans[i].first]<<\" \"<<ind[ans[i].second]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n//#define db double\n#define all(x) x.begin(), x.end()\n#define SZ(x) (int)(x.size())\n#define mem(x, y) memset(x, y, sizeof(x))\n#define what_is(x) cerr <<  \"Line \" << __LINE__ << \": \" << #x << \" is \" << (x) << endl;\n#define suf_zero(x) __builtin_ffs(x)\n#define pre_zero(x) __builtin_clz(x)\n#define num_one(x) __builtin_popcount(x)\n#define error(args...) { string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }\n#define mt make_tuple\n#define mp make_pair\n#define eb push_back\n#define pb push_back\n#define INFI 2000000009\n#define INFLL (ll)1e18+7\n#define ig ignore\n#define fi first\n#define TP tuple<int, int, int>\n#define se second\n//#define lson l, mid, rt<<1\n//#define rson mid+1, r, rt<<1|1\n#define PII pair<int, int>\n//void print(__int128 x){if(x>9)print(x/10);putchar('0'+x%10);}\n#define rep(i, begin, end) for(__typeof(end) i =(begin)-((begin)>(end));i!=(end)-((begin)>(end));i+=1-2*((begin)>(end)))\nvoid err(istream_iterator<string> it) {cerr<<endl;}\ntemplate<typename T, typename... Args>\nvoid err(istream_iterator<string> it, T a, Args... args) {\n    cerr << *it << \" = \" << a << \" , \";\n    err(++it, args...);\n}// fast IO\nauto TIMESTART = chrono::steady_clock::now();\nauto TIMESTOP  = chrono::steady_clock::now();\nvoid TimeStop()\n{\n    TIMESTOP = chrono::steady_clock::now();\n    auto ElapsedTime = TIMESTOP - TIMESTART;\n    cout << \"\\n\\nTime elapsed: \" << chrono::duration<double>(ElapsedTime).count() << \" seconds.\\n\";\n}\nnamespace fastIO{\n    #define BUF_SIZE 2000000\n//     fread -> read\n    bool IOerror = 0;\n    static char obuf[BUF_SIZE], *OUT=obuf;\n    inline char nc(){\n        static char buf[BUF_SIZE], *p1 = buf+BUF_SIZE,\n         *pend = buf+BUF_SIZE;\n         if(p1==pend){\n             p1 = buf;\n             pend = buf+fread(buf, 1, BUF_SIZE, stdin);\n             if(pend==p1){\n                 IOerror = 1;\n                 return -1;\n             }\n         }\n         return *p1++;\n    }\n    inline bool blank(char ch){return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t';}\n    inline void read(int &x){\n        char ch;\n        while(blank(ch=nc()));\n        if(IOerror)return ;\n        for(x=ch-'0';(ch=nc())>='0'&&ch<='9';x=x*10+ch-'0');\n    }\n    inline void read(ll &x){\n        char ch;\n        while(blank(ch=nc()));\n        if(IOerror)return ;\n        for(x=ch-'0';(ch=nc())>='0'&&ch<='9';x=x*10+ch-'0');\n    }\n    void print(const int& x) {\n        if(x > 9) print(x / 10);\n        *OUT++= x % 10 + '0';\n    }\n    void print(const ll& x) {\n        if(x > 9) print(x / 10);\n        *OUT++= x % 10 + '0';\n    }\n    void print(){fwrite(obuf, OUT-obuf, 1, stdout);}\n    #undef BUF_SIZE\n}\nusing namespace fastIO;\n//#include<ext/pb_ds/assoc_container.hpp>\n//#include<ext/pb_ds/tree_policy.hpp>\n//#include<ext/pb_ds/hash_policy.hpp>\n//using namespace __gnu_pbds;\n//mt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\n//mt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\nconst double pi = acos(-1.0);\nconst double eps = 1e-8;\nconst int mod = 1e9+7;\n#define mul(a, b) 1LL * (a) * (b) % mod\n#define add(a, b) (a + b >= mod ? a + b - mod : a + b)\n#define sub(a, b) (a - b <  0 ? a - b + mod : a - b)\n#define RG register\n///////////// BOUND /////////////////\nll qp(ll b, ll n, const ll mod=::mod){ll r=1;if(n<0)n+=mod-1;b%=mod;for(;n;n>>=1,b=mul(b,b))if(n&1)r=mul(r,b);return r;}\n#define inv(x) (qp((x), mod-2))\n//const ll inv2 = (mod+1)/2;\n//const ll inv6 = qp(6, mod-2);\n//ll sum_of_sq(ll n){n%=mod;return n*(n+1)%mod*(2*n+1)%mod*inv6%mod;}\n//tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> T;\n//cc_hash_table<ll, ll> Sf, Sg, Sh;\n/////////////// Macro ///////////////\nconst int maxn = 1e5+7;\nint sz[maxn], d[maxn];\nPII p[maxn];\nll ans = 0;\nvector<int> G[maxn];\nint fa[maxn];\nvoid dfs(int u,int h)\n{\n    ans+=h;\n    for(auto v:G[u]) dfs(v, h+1);\n}\nint main()\n{\n    #ifdef aoaoao\n//    freopen(\"in.txt\", \"r\", stdin);\n//    freopen(\"me.txt\", \"w\", stdout);\n    #endif // aoaoao\n    int n;scanf(\"%d\", &n);\n    for(int i=1;i<=n;++i) scanf(\"%d\", &d[i]), sz[i]=1, p[i]=mp(d[i], i);\n    sort(p+1, p+1+n, greater<pair<int, int> >());\n    vector<PII> vec;\n    for(int i=1;i<n;++i)\n    {\n        int tmp = p[i].fi+sz[p[i].se]*2-n;\n        int x = lower_bound(p+1, p+1+n, mp(tmp, INFI), greater<pair<int, int> >())-p;\n//        error(i, p[i].fi, p[i].se, tmp, p[x].fi, x);\n        if(p[x].fi!=tmp) return puts(\"-1\"), 0;\n        sz[p[x].se]+=sz[p[i].se];\n        G[p[x].se].eb(p[i].se);\n        vec.eb(mp(p[i].se, p[x].se));\n    }\n    dfs(p[n].se, 0);\n    if(ans!=p[n].fi) return puts(\"-1\"), 0;\n    sort(all(vec));\n    for(auto x:vec)\n        cout << x.fi << ' ' << x.se << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<vector>\n#define pb push_back\n\ntypedef long long LL;\n\nconst int N=100005;\n\nint n,size[N],id[N],ans1[N],ans2[N];\nLL tot,a[N];\nstd::map<LL,int> num;\nstd::vector<int> vec[N];\n\nbool cmp(int x,int y)\n{\n\treturn a[x]>a[y];\n}\n\nvoid dfs(int x,int fa,int d)\n{\n\ttot+=(LL)d;\n\tfor (int i=0;i<vec[x].size();i++)\n\t\tif (vec[x][i]!=fa) dfs(vec[x][i],x,d+1);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%lld\",&a[i]),num[a[i]]=i;\n\tfor (int i=1;i<=n;i++) size[i]=1,id[i]=i;\n\tstd::sort(id+1,id+n+1,cmp);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x=id[i];LL w=a[x]-(n-size[x])+size[x];\n\t\tif (!num[w]||w>=a[x]) {puts(\"-1\");return 0;}\n\t\tint y=num[w];\n\t\tans1[i]=x;ans2[i]=y;\n\t\tvec[x].pb(y);vec[y].pb(x);\n\t\tsize[y]+=size[x];\n\t}\n\tfor (int i=1;i<n;i++) printf(\"%d %d\\n\",ans1[i],ans2[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<iomanip>\n#include<cstring>\n#include<complex>\n#include<vector>\n#include<cstdio>\n#include<string>\n#include<bitset>\n#include<ctime>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#define Cpy(x,y) memcpy(x,y,sizeof(x))\n#define Set(x,y) memset(x,y,sizeof(x))\n#define FILE \"a\"\n#define mp make_pair\n#define pb push_back\n#define RG register\n#define il inline\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef vector<int>VI;\ntypedef long long ll;\ntypedef double dd;\nconst int N=1<<17;\nconst int mod=998244353;\nconst int base=26;\nconst dd eps=1e-6;\nconst int inf=2147483647;\nconst ll INF=1ll<<60;\nconst ll P=100000;\nil ll read(){\n  RG ll data=0,w=1;RG char ch=getchar();\n  while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n  if(ch=='-')w=-1,ch=getchar();\n  while(ch<='9'&&ch>='0')data=data*10+ch-48,ch=getchar();\n  return data*w;\n}\n\nil void file(){\n  srand(time(NULL)+rand());\n  freopen(FILE\".in\",\"r\",stdin);\n  freopen(FILE\".out\",\"w\",stdout);\n}\n\nint n,o[N],sz[N],m;\nstruct node{int d,id;}t[N];bool cmp_d(node a,node b){return a.d<b.d;}\nil void er(){puts(\"-1\");exit(0);}\nstruct edge{int u,v;}E[N];\nint main()\n{\n  er();\n  n=read();\n  for(RG int i=1;i<=n;i++){t[i].d=read();t[i].id=i;}\n  sort(t+1,t+n+1,cmp_d);\n  for(RG int i=1;i<=n;i++)o[i]=t[i].d,sz[i]=1;\n  for(RG int i=n,p;i!=1;i--){\n    p=lower_bound(o+1,o+n+1,t[i].d-n+2*sz[i])-o;\n    if(o[p]!=t[i].d-n+2*sz[i]||p>=i)er();\n    E[++m]=(edge){t[p].id,t[i].id};sz[p]+=sz[i];\n  }\n  for(RG int i=1;i<=m;i++)printf(\"%d %d\\n\",E[i].u,E[i].v);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(X,A,B) for(int X=A;X<=B;X++)\n#define tep(X,A,B) for(int X=A;X>=B;X--)\n#define LL long long\n#define DB double\nconst int N=400010;\nconst int M=800010;\nusing namespace std;\n\nint n;\nmap<LL,int> mp;\nLL sz[N];\nint fa[N],edge[M],lst[N],nxt[M],t=0;\n\nstruct nn{\n\tLL d;\n\tint id;\n}a[N];\n\nint cmp(nn A,nn B){\n\treturn A.d<B.d;\n}\n\nvoid READ(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n)scanf(\"%lld\",&a[i].d),a[i].id=i,mp[a[i].d]=i;\n\tsort(a+1,a+n+1,cmp);\n}\n\nvoid ADD(int x,int y){\n\tedge[++t]=y;nxt[t]=lst[x];lst[x]=t;\n}\n\nLL SEARCH(int x,int dep){\n\tLL res=dep;\n\tfor(int r=lst[x];r;r=nxt[r]){\n\t\tres+=SEARCH(edge[r],dep+1);\n\t}\n\treturn res;\n}\n\nint SOLVE(){\n\trep(i,1,n)sz[i]=1;\n\ttep(i,n,2){\n\t\tint x=a[i].id;\n\t\tLL d=a[i].d;\n\t\tLL now=d+2*sz[x]-n;\n\t\tint pos=mp[now];\n\t\tif(pos==0||now>=a[i].d)return 0;\n\t\tfa[x]=pos;\n\t\tADD(fa[x],x);\n\t\tsz[fa[x]]+=sz[x];\n\t}\n\tLL sum=SEARCH(a[1].id,0);\n\tif(sum!=a[1].d)return 0;\n\trep(i,1,n){\n\t\tif(i==a[1].id)continue;\n\t\tprintf(\"%d %d\\n\",i,fa[i]);\n\t}\n\treturn 1;\n}\n\nint main(){\n\tREAD();\n\tif(!SOLVE())printf(\"-1\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#include \"Segment_Tree.h\"\n#include \"BIT.h\"\n#include \"Rational.h\"\n#include \"Position.h\"\n#include \"Factorization.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nint N;\nPP Q[100000];\nLL A[100000];\nLL P[100000];\nLL cnt[100000];\n\nbool cat(int from) {\n\tLL t = A[from] - (N - 2 * cnt[from]);\n\tint to = lower_bound(A, A + from, t) - A;\n\tif (to == from || A[to] != t) return false;\n\tP[from] = to;\n\tcnt[to] += cnt[from];\n\treturn true;\n}\n\nvoid sub() {\n\tFill(cnt, 1);\n\tREP(i, 0, N) {\n\t\tA[i] = Q[i].first;\n\t}\n\n\tREM(i, 1, N) {\n\t\tif (!cat(i)) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tREP(i, 1, N) {\n\t\tcout << Q[i].second + 1 << ' ' << Q[P[i]].second + 1 << endl;\n\t}\n}\n\nint main() {\n\tcin >> N;\n\tREP(i, 0, N) {\n\t\tLL a;\n\t\tcin >> a;\n\t\tQ[i] = PP(a, i);\n\t}\n\tsort(Q, Q + N);\n\n\tsub();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\t\n\tint n; cin >> n;\n\tvi sz(n, 1);\n\tvector<pair<ll, int>> v;\n\trep(i, n){\n\t\tll x; cin >> x;\n\t\tv.emplace_back(x, i);\n\t}\n\tsort(all(v));\n\tvector<pi> ans;\n\t\n\t//dbg(v);\n\t\n\tfor(int i = n - 1; i > 0; i--){\n\t\tll nx = v[i].first - n + 2 * sz[v[i].second];\n\t\tauto j = lower_bound(all(v), pair<ll, int>(nx, -1));\n\t\t\n\t\t//dbg(i, nx);\n\t\t\n\t\tif(j - v.begin() >= i || j->first != nx){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tans.emplace_back(j->second, v[i].second);\n\t\tsz[j->second] += sz[v[i].second];\n\t}\n\tassert(sz[v[0].second] == n);\n\t\n\tfor(auto i : ans) cout << i.first+1 << \" \" << i.second+1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define N 300010 \n\nusing namespace std;\n\nint head[N], to[N << 1], nxt[N << 1], tot;\n\nint dep[N], sz[N];\n\ntypedef long long ll;\n\nstruct Node {\n    ll num;\n    int id;\n}a[N];\n\ninline bool cmp(const Node &a, const Node &b) {\n    return a.num > b.num;\n}\n\nchar *p1, *p2, buf[100000];\n\n#define nc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1 ++ )\n\nll rd() {\n    ll x = 0;\n    char c = nc();\n    while (c < 48) {\n        c = nc();\n    }\n    while (c > 47) {\n        x = (((x << 2) + x) << 1) + (c ^ 48), c = nc();\n    }\n    return x;\n}\n\ninline void add(int x, int y) {\n    to[ ++ tot] = y;\n    nxt[tot] = head[x];\n    head[x] = tot;\n}\n\nvoid dfs(int p, int fa) {\n    dep[p] = dep[fa] + 1;\n    for(int i = head[p]; i; i = nxt[i]) {\n        if (to[i] != fa) {\n            dfs(to[i], p);\n        }\n    }\n}\n\nmap <ll, int> MP;\n\nmap <ll, int> :: iterator it;\n\nint u[N], v[N];\n\nint main() {\n    int n = rd();\n    for (int i = 1; i <= n; i ++ ) {\n        a[i].num = rd();\n        MP[a[i].num] = i;\n        a[i].id = i;\n    }\n    sort(a + 1, a + n + 1, cmp);\n\n    for (int i = 1; i < n; i ++ ) {\n        int x = a[i].id;\n        it = MP.find(a[i].num - n + 2 + (sz[x] << 1));\n        if (it == MP.end()) {\n            puts(\"-1\");\n            return 0;\n        }\n        int y = it -> second;\n        sz[y] += sz[x] + 1;\n        add(x, y);\n        add(y, x);\n        u[i] = x;\n        v[i] = y;\n    }\n    // puts(\"Fuck\");\n    dep[a[n].id] = -1;\n    dfs(a[n].id, a[n].id);\n    ll all = 0;\n    for (int i = 1; i <= n; i ++ ) {\n        all += dep[i];\n    }\n    if (all != a[n].num) {\n        puts(\"-1\");\n        return 0;\n    }\n    for (int i = 1; i < n; i ++ ) {\n        printf(\"%d %d\\n\", u[i], v[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define reg register\n#define maxn 200001\ninline int  read() {\n    reg int s = 0, t = 0; reg char ch = getchar();\n    while(ch > '9' || ch < '0') t |= ch == '-', ch = getchar();\n    while(ch >= '0' && ch <= '9') s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();\n    return t ? -s : s;\n}\nusing namespace std;\nmap<int, int> mp;\nint D[maxn],a[maxn], b[maxn], cnt, n, sum[maxn];\nsigned main()\n{\n\tn = read();\n\tfor(int i = 1; i <= n; i++) D[i] = read(), mp[D[i]] = i;\n\tsort(D + 1, D + n + 1);\n\tfor(int i = n; i > 1; i--){\n\t\tsum[mp[D[i]]]++;\n\t\tint x = D[i] - abs(n - sum[mp[D[i]]] * 2);\n\t\tif(!mp[x] || x == D[i]) {printf(\"-1\\n\"); return 0;}\n\t\ta[++cnt] = mp[D[i]], b[cnt] = mp[x]; sum[mp[x]] += sum[mp[D[i]]];\n\t}\n\tif(n == 1 && D[1] != 0) {cout << -1 << endl; return 0;}\n\tfor(int i = 1; i < n; i++)\n\tprintf(\"%lld %lld\\n\", a[i], b[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,int>P;\n\nint n;\nP d[200000];\nvector<int>E[200000];\nint sz[200000];\nll dp1[200000],dp2[200000];\nvector<pair<int,int>>ans;\n\nvoid dfs1(int v){\n\tfor(int u:E[v]){\n\t\tdfs1(u);\n\t\tdp1[v]+=dp1[u]+sz[u];\n\t}\n}\nvoid dfs2(int v,int p){\n\tif(p==-1)dp2[v]=dp1[v];\n\telse dp2[v]=dp2[p]+n-2*sz[v];\n\tfor(int u:E[v]){\n\t\tans.push_back({v+1,u+1});\n\t\tdfs2(u,v);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%lld\",&d[i].first);\n\t\td[i].second=i;\n\t}\n\trep(i,n)sz[i]=1;\n\tsort(d,d+n);\n\tfor(int i=n-1;i>0;i--){\n\t\tll c=d[i].first-n+2*sz[d[i].second];\n\t\tint id=lower_bound(d,d+n,P(c,0))-d;\n\t\tif(id==n||d[id].first!=c){\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t\tE[d[id].second].push_back(d[i].second);\n\t\tsz[d[id].second]+=sz[d[i].second];\n\t}\n\tdfs1(d[0].second);\n\tdfs2(d[0].second,-1);\n\trep(i,n){\n\t\tif(dp2[d[i].second]!=d[i].first){\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t}\n\tfor(auto p:ans){\n\t\tprintf(\"%d %d\\n\",p.first,p.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define int long long\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par, size_;\npublic:\n    UnionFind(){}\n    UnionFind(int node_size) : sz(node_size), par(sz), size_(sz, 1){\n        iota(par.begin(), par.end(), 0);\n    }\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n    void unite(int x,int y){\n        x = find(x), y = find(y);\n        if(x == y) return;\n        if(size_[x] < size_[y]) swap(x,y);\n        par[y] = x;\n        size_[x] += size_[y];\n    }\n    int size(int x){\n        x = find(x);\n        return size_[x];\n    }\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n};\n\nsigned main(){\n    int n;\n    cin >> n;\n    UnionFind uf(n+1);\n    vector<pair<int,int> > v;\n    map<int,int> p;\n    rep(i,n){\n        int d;\n        cin >> d;\n        p[d] = i+1;\n        v.push_back(MP(d,i+1));\n    }\n    sort(v.begin(),v.end(),greater<pair<int,int> >());\n    map<int,int> mp;\n    vector<pair<int,int> > g;\n    bool ng = 1;\n    rep(i,n){\n        int k = v[i].first;\n        int u = v[i].second;\n        int c = mp[k];\n        c++;\n        //cerr << k << \" \" << u << \" \" << c << endl;\n        if(c==n&&i==n-1){\n            ng = 0;\n            continue;\n        }\n        int nxt = k - (n-c-c);\n        if(p.find(nxt)==p.end()){\n            cout << -1 << endl;\n            return 0;\n        }\n        mp[nxt]+=c;\n        g.push_back(MP(u,p[nxt]));\n        uf.unite(u,p[nxt]);\n    }\n    for(int i=1;i<=n;i++){\n        if(!uf.same(i,1)){\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n    if(ng){\n        cout << -1 << endl;\n        return 0;\n    }\n    for(auto x:g){\n        assert(0);\n        cout << x.first << \" \" << x.second << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define ll long long\n#define ll1 1ll\n#define ONE 1ll\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF =\n    sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nusing pii = pair<int, int>;\n// template<class T> ostream &operator<<(ostream &os,T &t){dump(t);return os;}\ntemplate <typename T, typename S>\nistream &operator>>(istream &is, pair<T, S> &p) {\n  is >> p.first >> p.second;\n  return is;\n}\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, pair<T, S> &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate <typename T> void printvv(const vector<vector<T>> &v) {\n  cerr << endl;\n  rep(i, 0, v.size()) rep(j, 0, v[i].size()) {\n    if (typeid(v[i][j]).name() == typeid(INF).name() and v[i][j] == INF) {\n      cerr << \"INF\";\n    } else\n      cerr << v[i][j];\n    cerr << (j == v[i].size() - 1 ? '\\n' : ' ');\n  }\n  cerr << endl;\n}\n/*\n   typedef __int128_t Int;\n   std::ostream &operator<<(std::ostream &dest, __int128_t value) {\n   std::ostream::sentry s(dest);\n   if (s) {\n   __uint128_t tmp = value < 0 ? -value : value;\n   char buffer[128];\n   char *d = std::end(buffer);\n   do {\n   --d;\n *d = \"0123456789\"[tmp % 10];\n tmp /= 10;\n } while (tmp != 0);\n if (value < 0) {\n --d;\n *d = '-';\n }\n int len = std::end(buffer) - d;\n if (dest.rdbuf()->sputn(d, len) != len) {\n dest.setstate(std::ios_base::badbit);\n }\n }\n return dest;\n }\n\n __int128 parse(string &s) {\n __int128 ret = 0;\n for (int i = 0; i < s.length(); i++)\n if ('0' <= s[i] && s[i] <= '9')\n ret = 10 * ret + s[i] - '0';\n return ret;\n }\n */\n\n#ifndef _DEBUG\n#define printvv(...)\n#endif\nvoid YES(bool f) { cout << (f ? \"YES\" : \"NO\") << endl; }\nvoid Yes(bool f) { cout << (f ? \"Yes\" : \"No\") << endl; }\ntemplate <class T> bool chmax(T &a, const T &b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\nsigned main(signed argc, char *argv[]) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(12);\n\n  int N;\n  cin >> N;\n  map<int, int> mp;\n  vector<int> D(N);\n  rep(i, 0, N) {\n    cin >> D[i];\n    mp[D[i]] = i;\n  }\n  vector<int> size(N, 1);\n  vector<pii> ans;\n  vector<int> dd(N);\n  for (auto it = mp.rbegin(); *it != *mp.begin(); it++) {\n    int d, i;\n    tie(d, i) = *it;\n    dump(d, i, size);\n    int nd = d + 2 * size[i] - N;\n    dump(nd);\n    if (not mp.count(nd) or mp[nd] == i) {\n      cout << -1 << endl;\n      return 0;\n    }\n    int parent = mp[nd];\n    ans.eb(i, parent);\n    size[parent] += size[i];\n    dd[parent] += dd[i] + size[i];\n  }\n  if (dd[mp.begin()->second] != D[mp.begin()->second]) {\n    cout << -1 << endl;\n  } else {\n    for (auto p : ans) {\n      cout << p.fi + 1 << \" \" << p.se + 1 << endl;\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*!|||||||!!!!!!!!!!!!!!!!!!|%%$&&&&&&&&&&&&&|'`......```':'':!;.  ......````':!;..\n||||||||||||!!!!!!!!!!!!!!!!!!!;;;;;!|%$$&&&|'..  ....``'''''::`  ......`````';:.\n||||||||||||||||||||||!!!!!!!!!!;;;;;;;;;;;'`..  ....``'''''':` ........````':'.\n|||||||||%%||%%|||||||||||||||||!;;;;;;;;'....   ....`````'''`..........````''.\n%%%%%%%%%%%%%%%%%%|%||||%%|%%%%|!;!;;;;:.       ....```````'::'`........`````.\n$$$$$$$%%$%%$$$$$%%%%%%%%%%%%%%|!!!!;'.        ....````````';|!!!!:`....```..\n$$$$$$%%%$%%$$$$$%%%%%%%%%%%%%%!;!!;`          ....```````':!!!!!!!!|||;'`.\n$$$%$%|%%||%%%%%%%%%%||%%%%%|%|!;!!:.         ....````````:!;;;!;;!!|%$$$$|:`\n%%%%%||||||||||||||||||||||||||!;!;'`.        ....```````';!!!!!!!!||;';%$&@@%:`.\n|||||||||!!|||||||||||||||||||!;!!:':'.       ..```''```';!!!!!!!||%$$%!` .'|&@@%:`. .\n||||||||!!!|||||||||||||||||||!;!;::;;:`     ..````'''`';;!!!!!!|%%$$$$&&%'   .;&#@!'....\n|||||||!!!!|||||||||||||||||||!;!;:;;;;;'.  ..```''''`:!!!!!;!!|%$$$$&&&&&@$:.   .;&#$:....\n|||!||||!!||||||||||||||||||||!;!::;;;;;;;`..```''':':;!!!!!!!!|%$$&&&&&&@&@#$:.   .`!@$:...\n|||!|||!!!|||||||||||||||||||!!;;:;;;;;;;!!;'`'''':':!;;;;;!!|||||%$&&&&@@@@@@@%`......:$$:...\n||!!||!!!!!||||||||||||||||||!!;;:;;;;;;;!!|!;'''``'':;!!;!!;!|$$$%|%&&&@@@@@@@#&;.......'%|`..\n||!!||!!!!!!|||||||||||||||!!!!;;:;;;;;;:''::::;;!;;;;':!!!!!!!!!%$&$|%&@@@@@@#@@&!`.......`|;..\n||!!|!!!!!!!||||||||||||||||||!;;:;;'````:!%%%%|;:;;:::::;|!!||!!!!|$&$%%&@@&@@##@&!'........;|'.\n|!!!|!!!!!!!|||||||||||||||!!!!;:'```';!!||!!!|!!;;;;:::::;%%||%%|||||%&$%%&@@@@@##&;`` ......'!:.\n|!!!!!!!!!!!!|||||||||||||!!!!!;::;;;;;:;!!!|||||!!;;;;;;;;!%$%|%$$%||||%$$%$&@@@@#@$:``      .`''.\n|!!!||!!!!!!!||||||||||||!!!!!!!;;;:::;;!!|||||||||!!;;;;;;;;|$%|%%$$$%|||%%$$&@&@@#@!.`'.     ...`.\n|!!!||!!!!!!!||||||||||||!!!!!!!;:;;;;;!!!!!|||||||||!!;;;;;;;|$$||%$$&&$%%%%%$&&&&@@@!.``.    ....`.\n|!!!||!!|!!||!|||||||||||!!!!!!!;;;;;;;!!||||||||||!!!;;;;;;;;;|$$||$$$&&&$%%%|%$&&&@@@; .`.    .. ...\n|!!!||!!||!!|!!|||||||||||!!!!!!!;;;;;!!||||||||!!!|||||!!;;;;;;|$$|!$$$&&&&$%%|%$&&&&@$' .`.   ..  ..\n|!!!||!!||!!||!|||||||||||!!!!!!!;;;;;!||||||!!!|||||||||!::'::::!$$!!%$$&&&&$$%!!%$$&&&!. .`.  ..\n|!!!|||!|||!!|!!|||||||||||!!!!!!!;;;!!||||!!|||||||||!;;!!!!!!;;;|$%!|$$$&&&&&$|`.;$$&&|`  .`...\n|!!!!||!||||!!|!!||||||||||!!!!!!!!!;!|||!||||||||!!!!||!:'`.`:;!!!%$%!|$$$&&&&&$;  '%$&$;   ``\n|!!!!||!!||||!!|!!|||||||%||!!!!!!!!!!||||||||||!!!|!:.      ....`';|||!|$$&&&&&@|`  '%&$%:   ..\n|!!!!|||||||||!|||!||||||%%|!!|!!!!!!!||||||||!!!;` ...      ...';||%$|;!%$$&&&&@$:   :$&$$|.  ..\n||!!!||||||||||!!||||||||%%||!!|!!!!!!|||||||!!'..```..``... `:;;;!|%$$|!|%$&&&&&&;   '|$%:!$: ...\n||!;!|||||||||||!!%|||||%%%%|||||!|!!|||||||!'..```.`'```..`!%!!%%%%|$$||!|$$&&&&&;   ';!%: `|%`..\n||!!!!!|||||%||||!!%%||%%%%%%|||||||!||||||;:`.``.`:;;`.':```:':|%%%%$$%|!;|&&&&&$:   ''`!;    :|:.\n|||!!!!!||||%%%|%%||%%|%%%$$%|||%|!||!||||!:`....';;!|%;.```''::!%%%|%$$$|';$&&&&%'  .`  ::       .`''`. .``.\n|||!!!!!||||%%%%%%%|||%%%$$$$%|%%%||%|!||!:```....`;|%$$|'':`'!;!%%%%%%$&@%!%&$$&!. .`.  ``.      .\n|||!!!|!!|%%%%%%%%%%%||%%%$$$%|%%%%||%|!|!!|||||||!;::|$$$%|%%%!!|%%%%%%$&&&$$$$%' .`    ..\n|||!!!||!!|%%%%%%%%%%%%||%%%$$%|%%$%|%%!!|||||||||||||||!!!||||%%%%%%%%%$$$$$$$$&%:.     ..\n||||!!|%|!;!%%%%%%%%%%%%%%|%%%$||%$%%|%|!!||||||||||||||%%%%%%%%$$$%%%%$$$$%%$$$&&&&&&$%'..\n!|||!!!|%|!;!%%%%%%%%%%%%%%%|%%%||%%%||%|!!!||||||||||||%%%%%%%%%%%%%%%$$$$%%$$$$$$$$$$%'\n;!||!!!|%%%|!;|%%%%%%%%%%%%%%%%|%||%%%!!||!!!|%%||||||%%%%%%%%%%%%%%%%$$$$%%%%%$$$$$$$$!`\n;;!||!!!|%%||!;!||%%%%%%%%%%%%%%%||%%%|!!|||!!!|%$%|||%%%%%%%%%%%%%%%%%%%%%%%$$$$$$$$$$;.\n;;;||!!!!|%%||!;;!|%%%%%%%|||||%%|||||||!!||||||||%$%|%%%%%%%%%%%%%%%%$%%%%%$$$$$$$$$$%'\n!!;!|!;;!!|%%|||!;!||%%%||||||||||||||||!!|%||||||||%%||%%%%%%%%%%%%$$$$$$$$$$$$$$$$$$!`\n!!;;!!;;!!!||||||!;;!|||||||||||||||!||||!;;|%%%%%%%|%%%%%%%%%%%%%%%$$$$$$$$$$$$$$$$$$%'\n!!!;;!!;;!!!||||||!!;;!||||||||||||||!||||!!!!%$%|%%%%%%%%%%%%%%%%%%$$$$$$$$$$$$$$$$$$$%'\n!!!!;;!!;;;!!!|||||!!::;|||||!|||||||!!|||||!!!|$$%%%%%%%%%%%%%%%$$$$$$$$$$$$$$$$$$$$&&&$:\n;;!!!!;!;;;;!!!|||||!!;::;!|!!!!||||||!!|||%%|!!!%&%%%%%%%%%%%%%%$$$$$$$$$$$$$$$$$$$$$&$!`\n|!!!!;!;;;;::;!!!||!||!;;;;;!!!!!!|||||!!|||%%|||!|$&$%%%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$%!`\n:::;!;;;;::;::;;!!|||!!!!;;;;;!!!!!!||||!!|||%$%%||||$&$%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$$%'\n;;;;;!!!!!;:::;;:;!!||!!!!!;;;;;!!!!!!||||!!||%$%%%%%%%%$$%%%$$$$$$$$$$$$$$$$$$$$$$$$$$$$:\n;;;;;;;;;!!!;::;;;:;!!|||||!!!!;;;;!!!!!|||||||%$$%%%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$$$$$&$!.\n;;;;;;;;:::::::::;;;;;;!||!!!!!!!!;;;!!!!!||||||||$$%%%%%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$$&!.\n;;;;;;;::;;:::;;;;:;;;;;;;;!!!|!!!!!!;;;!!!!!|%%||||%$%%%%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$&%`\n;;;;;;;:::;;::;;;;;;;;;;;;::;!!!!!!!!|!;!!!!!!!|%%%%%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&:\n;;;;;;;::;::;:;;;;;;;;;!!!!!!!;;!!|||||!!!|!!!!!!!|%%%%%%%%%%%%%%%%$$$$$$$$$$$$$$$$$$$$&&|`\n;;;;;;;::;;;::;;;;;;;;;;!!!!!!!!!||||||||;!!|||||||||%%%%%%%%%%%%%%%$$$$$$$$$$$$$$$$$$$$&&!.\n;;;;;;;::;;;;::;;;;;;;;;;!!!!!!!!|||||||||;;;!!|||||||||%%%%%%%%%%%%%%%%$$$$$$$$$$$$$$$$$&|`\n!;;;;;;;::;;;:;;;;;;;;;;;!!!!!!!!!|||||||%!;;;;;!||||||||||%%%%%%%%%%%%%%%$$$$$$$$$$$$$$$$!.\n;!;;;;;;::;;;:;;;;::;;;;;!!!!!!!!!|||||||%%!;;;;;;!!!|||||||%%%%%%%%%%%%%%%%%%$$$$$$$$$$&|`\n:;!!;;;;:::;;;:;;;:::;;;;;!!!!!!!!||||||||$|;;;;;;;;!!!!||||||||%%%%%%%%%%%%%%%%%%%$$$|'\n::;!!;;;::::;;:;;;;::;;;;;;!!!!!!!!|||||||$$!;;;;;;;;;;;!!!!!||||||%%%%%%%%%%%%|!:`.\n:::;!!;;;:::;;;;;;;:::;;;;;!!!!!!!!||%||||%&%!;;;;;;;;;;;;!!!!!!!!!!!|!;:`.\n::::;!!!;::::;::;;;::::;;;;;!!!!!!!!|%%|||!%&%;;;;;;;;;;;;;;;;;;;;;%|`\n:::::;!!!;:::::::;;:::::;;;;!!!!!!!!||%%%%!;%$|;;;;;;;;;;;;;;;;;;%@@$:\n::::::;!!!:::::':;;::::::;;;;;!!|!!!||%$%%|!;%$!;;;;;;;;;;;;;;;;|$&@@|`\n:::::':;;!;::::'';;;::::::;;;;!!!|!!!||%$%%|;;%%;;;;;;;;;;;;;;!||%$&#@|`\n::::::':;;;:::''':;;:::::::;;;!!!||!!!|%$$%%|;;||;;;;;;;;;;;!||||%%%&#@%'\n:::::::':;;;::'. ';;::::::::;;;!!!|!!!||%$$$%;;;||;;;;;;;;;|%%|||||%%&@@*/\n#include <bits/stdc++.h>\nusing namespace std;\n\nmap<long long,int> dy;\nint n;\nlong long d[100005];\nint sz[100005];\nvector<int> son[100005];\nlong long sum=0;\nint dep[100005];\nvector<pair<int,int> > ans;\n\nvoid dfs(int now,int lst){\n\tdep[now]=dep[lst]+1;\n\tsum+=dep[now];\n\tfor(int i=0;i<son[now].size();i++){\n\t\tint to=son[now][i];\n\t\tif(to==lst){\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to,now);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",d+i);\n\t\tdy[d[i]]=i;\n\t\tsz[i]=1;\n\t}\n\twhile(dy.size()>1){\n\t\tpair<long long,int> X=*dy.rbegin();\n\t\tint x=X.second;\n\t\tlong long val=X.first;\n\t\tdy.erase(val);\n\t\tlong long tov=val-n+2*sz[x];\n\t\tif(!dy.count(tov)){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}else{\n\t\t\tint ff=dy[tov];\n\t\t\tson[ff].push_back(x);\n\t\t\tson[x].push_back(ff);\n\t\t\tsz[ff]+=sz[x];\n\t\t\tans.emplace_back(ff,x);\n\t\t}\n\t}\n\tdep[0]=-1;\n\tdfs(dy.begin()->second,0);\n\tif(sum!=dy.begin()->first){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<n-1;i++){\n\t\tprintf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 100020\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define inf 0x3f3f3f3f\ntypedef long long ll;\ntypedef pair<int,int> pr;\n\nll d[maxn];\nvector <pr> edge;\nint n,fa[maxn],sz[maxn];\n\nbool solve(){\n\trepd(i,n,2){\n\t\tsz[i]++;\n\t\tll curd = d[i] - n + 2 * sz[i];\n\t\tint id = lower_bound(d + 1,d + n + 1,curd) - d;\n\t\tif ( d[id] != curd || id == i ) return 0;\n\t\tfa[i] = id , sz[id] += sz[i];\n\t}\n\treturn 1;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n) scanf(\"%lld\",&d[i]);\n\tsort(d + 1,d + n + 1);\n\tif ( solve() ){\n\t\trep(i,2,n) printf(\"%d %d\\n\",fa[i],i);\n\t}\n\telse{\n\t\tprintf(\"-1\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nint n;\nmap<int, pair<int, int> > st;\nvector<pair<int, int> > edge;\n\nint main()\n{\n\tread(n);\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tint d;\n\t\tread(d);\n\t\tst.insert(make_pair(d, make_pair(1, i)));\n\t}\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tauto x = *st.rbegin();\n\t\tst.erase(--st.end());\n\t\tint y = x.first-(n-x.second.first)+x.second.first;\n\t\tauto it = st.find(y);\n\t\tif(it == st.end()) {printf(\"-1\\n\"); return 0;}\n\t\telse it->second.first += x.second.first, edge.emplace_back(x.second.second, it->second.second);\n\t}\n\tfor(auto i : edge) printf(\"%d %d\\n\", i.first, i.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=1e5+5;\nusing namespace std;\nstruct Edge{int x,y;}e[N];\nstruct Node{\n\tlong long d;int id;\n\tbool operator <(const Node &b)const{return d<b.d;}\n}d[N];\nint n,cnt;\nint size[N];\nlong long dis;\nint main(){\n\t\n\tregister int i,x;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i)\n\t\tscanf(\"%d\",&x),d[i].d=x,d[i].id=i,size[i]=1;\n\tsort(d+1,d+n+1);\n\tfor(i=n;i>=2;--i){\n\t\tlong long t=d[i].d-n+size[i]*2;\n\t\tint pos=lower_bound(d+1,d+i,(Node){t,0})-d;\n\t\t//cout<<pos<<endl;\n\t\tif(pos>=i||d[pos].d!=t) return puts(\"-1\"),0;\n\t\te[++cnt]=(Edge){d[i].id,d[pos].id};\n\t\tdis+=size[i];\n\t\tsize[pos]+=size[i];\n\t}\n\tif(dis!=d[1].d) puts(\"-1\");\n\telse\n\t\tfor(i=1;i<=cnt;++i)\n\t\t\tprintf(\"%d %d\\n\",e[i].x,e[i].y);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int maxn = 101010;\nstruct Node{\n    int num;\n    ll d;\n    bool operator < (const Node &tx) const {\n        return d < tx.d;\n    }\n}a[maxn];\nint n, flag;\nint siz[maxn];\n\nqueue<int> q[2];\nvector<pair<int, int> > ans;\n\nint main(){\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i ++){\n        scanf(\"%lld\", &a[i].d);\n        a[i].num = i;\n    }\n\n    sort(a+1, a+1+n);\n\n    q[a[1].d & 1].push(1);\n    siz[a[1].num] = n - 1;\n    int tem_flag = n & 1;\n    \n    for(int i = 2; i <= n; i ++){\n        if(q[1 & (a[i].d ^ tem_flag)].empty()){\n            printf(\"-1\");\n            return 0;\n        }\n        int tem_num = q[1 & (a[i].d ^ tem_flag)].front();\n\n        ll diff = a[i].d - a[tem_num].d;\n        int diff_siz = (n - diff) / 2;\n        \n        siz[a[i].num] = diff_siz - 1;\n        siz[a[tem_num].num] -= diff_siz;\n\n        if(diff_siz > 1)\n            q[a[i].d & 1].push(i);\n        ans.push_back(make_pair(a[i].num, a[tem_num].num));\n        if(siz[a[tem_num].num] <= 0) q[1 & (a[i].d ^ tem_flag)].pop();\n    }\n\n    for(int i = 1; i <= n; i ++){\n        if(siz[i]){\n            printf(\"debug : %d\\n\", i);\n            return 0;\n        }\n    }\n\n    int siz = ans.size() - 1;\n    for(int i = 0; i <= siz; i ++)\n        printf(\"%d %d\\n\", ans[i].first, ans[i].second);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define rep(pos, len) for(int pos=0;pos<len;pos++)\n#define repp(pos, len) for(int pos=1;pos<=len;pos++)\n\n#define INF 987654321\n#define IINF 2987654321987654321\n#define MOD 998244353\n\nconst int MAXN = 1e5 + 50;\nll d[MAXN], pa[MAXN], sz[MAXN], depth[MAXN];\nvector<int> adj[MAXN];\nint n;\n\nbool check(int root) {\n\tqueue<int> que;\n\tque.push(root);\n\tll sum = 0;\n\tdepth[root] = 0;\n\twhile(!que.empty()) {\n\t\tint v = que.front(); que.pop();\n\t\tfor(auto c : adj[v]) {\n\t\t\tdepth[c] = depth[v] + 1;\n\t\t\tsum += depth[c];\n\t\t\tque.push(c);\n\t\t}\n\t}\n\treturn sum == d[root];\n}\n\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%lld\", &d[i]);\n\n\tmap<ll, int> M;\n\tfor(int i = 1; i <= n; i++)\n\t\tM[d[i]] = i;\n\tfor(int i = 1; i <= n; i++)\n\t\tsz[i] = 1;\n\n\tvector<int> v;\n\tfor(int i = 1; i <= n; i++) v.push_back(i);\n\tsort(v.begin(), v.end(), [](int i, int j){ return d[i] > d[j]; });\n\tint root = v.back();\n\tfor(auto c : v) {\n\t\tif(c == root) break;\n\t\tll dval = d[c] + 2*sz[c] - n;\n\t\tif(M.find(dval) == M.end() || M[dval] == c) {\n\t\t\tprintf(\"-1\");\n\t\t\texit(0);\n\t\t}\n\t\tint p = M[dval];\n\t\tadj[p].push_back(c);\n\t\tpa[c] = p;\n\t\tsz[p] += sz[c];\n\t}\n\n\tif(!check(root)) {\n\t\tprintf(\"-1\");\n\t\texit(0);\n\t}\n\n\tfor(int i = 1; i <= n; i++)\n\t\tif(i != root) printf(\"%d %d\\n\", i, pa[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\n\nconst int MAXN = 1e5 + 5;\nint n, par[MAXN], d[MAXN];\nll sz[MAXN];\nvector <pair<ll,int> > v;\nmap <ll,int> mp;\n\nint main()\n{\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> d[i];\n\t\tmp[d[i]] = i; sz[i] = 1;\n\t\tv.push_back({d[i], i});\n\t}\n\tsort(v.begin(), v.end());\n\tfor(int i = n - 1; i > 0; i--){\n\t\tint ind = v[i].second, p;\n\t\tll dd = v[i].first, dpar = dd - (ll)n + (2ll * sz[ind]);\n\t\tp = mp[dpar];\n\t\tif(p == 0 || p == ind){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tpar[ind] = p;\n\t\tsz[p] += sz[ind];\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tint ind = v[i].second;\n\t\tcout << ind << \" \" << par[ind] << '\\n';\n\t}\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\n#define Accepted 0; \n\nconst int Maxv = 100010; \nlong long d[Maxv], d1[Maxv], u[Maxv], ghostfly233[Maxv], siz[Maxv], cnt, n;  \n\ninline int GldHkkowoSearch(int x) {\n    int tmp = std::lower_bound(d + 1, d + n + 1, x) - d;\n\n    if (d[tmp] != x) {\n        puts(\"-1\"); \n        exit(0); \n    }\n\n    return tmp; \n}\n\nint main() {\n    scanf(\"%lld\", &n); \n    for (int i = 1; i <= n; i++) {\n        scanf(\"%lld\", &d[i]); \n        d1[i] = d[i]; \n    }\n\n    std::sort(d + 1, d + n + 1); \n    for (int i = 1; i <= n; i++) \n        ghostfly233[GldHkkowoSearch(d1[i])] = i;       \n\n    for (int i = 1; i <= n; i++)\n        siz[i] = 1; \n\n    for (int i = n; i > 1; i--) {\n        u[i] = GldHkkowoSearch(d[i] - n + (siz[i] << 1)); \n        siz[ u[i] ] += siz[i]; \n        cnt += siz[i]; \n    }\n\n    if (cnt != d[1]) {\n        puts(\"-1\"); \n        return 0; \n    }\n\n    printf(\"%lld\\n\", cnt); \n    for (int i = 2; i <= n; i++)\n        printf(\"%lld %lld\\n\", ghostfly233[i], ghostfly233[ u[i] ]); \n\n    return Accepted;  \n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)   FOR(i,0,n)\n#define LL long long\n\nint n;\nvector<LL> d,init_d;\nvector<LL> ind,width;\nvector<pair<int,int>> ans;\n\nLL dfs(vector<vector<int>> tree,int pos,LL cum){\n  LL ret = cum;\n  REP(i,tree[pos].size())\n    ret += dfs(tree,tree[pos][i],cum+1);\n  return ret;\n}\n\nint main(){\n  cin>>n;\n  LL tmp;\n  REP(i,n){\n    cin>>tmp;\n    d.push_back(tmp);\n    init_d.push_back(tmp);\n  }\n  sort(d.begin(),d.end());\n  ind.resize(n);\n  REP(i,n){\n    int min_ind = distance(d.begin(),lower_bound(d.begin(),d.end(),init_d[i]));\n    ind[min_ind] = i+1;\n  }\n  REP(i,n){\n    width.push_back(1);\n  }\n\n  vector<vector<int>> tree(n);\n  REP(i,n-1){\n    LL s = d[n-1-i] - (n - 2*width[n-1-i]);\n    //cerr<<s<<endl;\n    int min_ind2 = distance(d.begin(),lower_bound(d.begin(),d.end(),s));\n    if(d[min_ind2] != s || s > d[n-1-i]){\n      cout<<-1<<endl;\n      return 0;\n     }\n    ans.push_back(make_pair(min_ind2,n-1-i));\n    tree[min_ind2].push_back(n-1-i);\n    //tree[n-1-i].push_back(min_ind2);\n    width[min_ind2] += width[n-1-i];\n  }\n  if(d[0] != dfs(tree,0,0)){\n    cout<<-1<<endl;\n    return 0;\n  }\n  \n  REP(i,ans.size())\n    cout<<ind[ans[i].first]<<\" \"<<ind[ans[i].second]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP std::make_pair\n#define FI first\n#define SE second\n#define M 1000005\n#define INF 1000000000\ntypedef long long ll;\nll n,D[M],size[M],sum;\nstd::multiset <std::pair <ll,ll> > Set;\nstd::pair <ll,ll> Edge[M];\nll read(){\n\tchar c=getchar();ll ans=0;\n\twhile (c<'0'||c>'9') c=getchar();\n\twhile (c>='0'&&c<='9') ans=ans*10+c-'0',c=getchar();\n\treturn ans;\n}\nvoid Write(ll x){\n\tif (x<10) putchar(x+'0');\n\telse Write(x/10),putchar(x%10+'0');\n\treturn;\n}\nint main(){\n\tn=read();\n\tfor (ll i=1;i<=n;i++) size[i]=1,Set.insert(MP(D[i]=read(),i));\n\tfor (ll i=1;i<n;i++){\n\t\tauto it=Set.end();--it;ll X=it->FI,Y=it->SE;Set.erase(it);\n\t\tauto nxt=Set.lower_bound(MP(X+size[Y]-(n-size[Y]),0));\n\t\tif (nxt==Set.end()||nxt->FI>X+size[Y]-(n-size[Y])) return !printf(\"-1\");\n\t\tEdge[i]=MP(Y,nxt->SE),size[nxt->SE]+=size[Y]; \n\t}\n\tfor (int i=1;i<=n;i++) sum+=size[i]-1;\n\tif (sum!=Set.begin()->FI) return !printf(\"-1\");\n\tfor (int i=1;i<n;i++) Write(Edge[i].FI),putchar(' '),Write(Edge[i].SE),putchar('\\n');\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define title \"title\"\n#define ll long long\n#define ull unsigned ll\n#define fix(x) fixed<<setprecision(x)\n#define pii pair<int,int>\n#define vint vector<int>\n#define pb push_back\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define red(i,a,b) for(int i=(a);i>=(b);i--)\n#define db double\n#define ld long db\nusing namespace std;\nvoid Freopen(){\n\tfreopen(title\".in\",\"r\",stdin);\n\tfreopen(title\".out\",\"w\",stdout);\n}\nll read(){\n\tll g=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch){if(ch=='-')f=-1;ch=getchar();}\n\twhile('0'<=ch&&ch<='9'){g=g*10+ch-'0';ch=getchar();}\n\treturn g*f;\n}\nconst int N=1e5+5;\nmap<ll,int>id;\nll a[N],ans;\nint n,size[N];\nvint G[N];\nvoid dfs(int x,int dis){ans+=dis;for(auto y:G[x])dfs(y,dis+1);}\nsigned main(){\n\t//freopen(\"a\",\"r\",stdin);\n\tn=read();rep(i,1,n)a[i]=read();\n\tsort(a+1,a+n+1,[](int a,int b){return a>b;});\n\trep(i,1,n)id[a[i]]=i,size[i]=1;\n\trep(i,1,n-1){\n\t\tint to=a[i]+size[i]-(n-size[i]);\n\t\tif(!id[to])return cout<<-1,signed();\n\t\tG[id[to]].pb(i);size[id[to]]+=size[i];\n\t}dfs(n,0);if(ans^a[n])return cout<<-1,signed();\n\trep(i,1,n)for(auto j:G[i])cout<<i<<' '<<j<<'\\n';\n\treturn signed();\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm> \n#include<cstdio>\n#define N 100001\nusing namespace std;\nint b[N],f[N],h[N],i,n,s[N];long long a[N],t;\ninline bool cmp(int u,int v){return a[u]<a[v];}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)scanf(\"%lld\",a+i),s[b[i]=i]=1;\n\tsort(b+1,b+n+1,cmp);\n\tfor(i=n;i>1;i--)\n\t{\n\t\tif(s[b[i]]<<1>=n)return 0*puts(\"-1\");\n\t\t*a=a[b[i]]-n+(s[b[i]]<<1),f[b[i]]=lower_bound(b+1,b+n+1,0,cmp)-b;\n\t\tif(f[b[i]]>n||a[b[f[b[i]]]]!=*a)return 0*puts(\"-1\");\n\t\ts[f[b[i]]=b[f[b[i]]]]+=s[b[i]];\n\t}\n\tfor(i=2;i<=n;i++)t+=h[b[i]]=h[f[b[i]]]+1;\n\tif(t!=a[b[1]])return 0*puts(\"-1\");\n\tfor(i=2;i<=n;i++)printf(\"%d %d\\n\",b[i],f[b[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair < int , int > pii;\ntypedef pair < LL , int > pli;\n#define mpr make_pair\n#define FS first\n#define SC second\n#define PB push_back\ntemplate < typename T > T MAX(T a,T b){return (a>b)?a:b;}\ntemplate < typename T > T MIN(T a,T b){return (a<b)?a:b;}\ntemplate < typename T > void UMAX(T &a,T b){a=(a>b?a:b);}\ntemplate < typename T > void UMIN(T &a,T b){a=(a<b?a:b);}\nint readint(){\n\tchar c=getchar();\n\tint ret=0;\n\twhile(!(c>='0' && c<='9')) c=getchar();\n\twhile(c>='0' && c<='9'){\n\t\tret=ret*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn ret;\n}\nvoid putint(int v){\n\tif(!v){\n\t\tputchar('0');\n\t\treturn;\n\t}\n\tif(v>=10) putint(v/10);\n\tputchar('0'+(v%10));\n}\nint n,fa[100005],sz[100005];\npli D[100005];\nint main(){\n\tint i,j,k;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;++i){\n\t\tfa[i]=-1;\n\t\tsz[i]=1;\n\t\tscanf(\"%lld\",&D[i].FS);\n\t\tD[i].SC=i;\n\t}\n\tsort(D,D+n);\n\tfor(i=n-1;i>0;--i){\n\t\tint v=D[i].SC;\n\t\tLL d=D[i].FS,tar=d-(LL)n+2ll*sz[v];\n\t\tif(sz[v]*2>=n){\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tint td=lower_bound(D,D+n,mpr(tar,-1))-D;\n\t\tif(td>=n || D[td].FS!=tar || fa[D[td].SC]!=-1){\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tfa[v]=D[td].SC;\n\t\tsz[D[td].SC]+=sz[v];\n\t}\n\tif(sz[D[0].SC]!=n){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(i=0;i<n;++i){\n\t\tif(fa[i]!=-1) printf(\"%d %d\\n\",i+1,fa[i]+1);\n\t}\n\treturn 0;\n}\n/*\n * 代码框架\n * 1、读入，对pair排序\n * 2、维护每个点的子树大小（初始=1）和父亲（初始=-1）\n * 3、按照D降序枚举，对于除了最后一个结点以外，都二分出其父亲的位置，找不到就-1\n * 4、每次如果碰到已经确定父亲的点则-1，如果碰到未确定父亲的点就加size\n * 5、最后检查，是否根节点的size=n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#include <queue>\n#include <vector>\n#define PB push_back\n#define MP make_pair\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=1e5+10;\nstruct node {\n\tint id; ll d;\n\tnode(int id=0,ll d=0): id(id),d(d) {}\n\tfriend bool operator <(node A,node B) { return A.d<B.d; }\n};\npriority_queue<node> que;\nmap<ll,int> mp;\nint n,sz[N];\nll d[N];\nvector< pair<int,int> > E;\nvector<int> son[N];\nll dfs(int u) {\n\tll tot=0;\n\tfor(int i=0;i<son[u].size();++i) tot+=dfs(son[u][i])+sz[u];\n\treturn tot;\n}\nint main() {\n\trd(n);\n\tfor(int i=1;i<=n;++i) {\n\t\trd(d[i]),mp[d[i]]=i;\n\t\tque.push(node(i,d[i]));\n\t\tsz[i]=1;\n\t}\n\twhile(que.size()>1) {\n\t\tint u=que.top().id; que.pop();\n\t\tmp.erase(d[u]);\n\t\tll t=d[u]-(n-sz[u]*2ll);\n\t\tif(!mp.count(t)) {\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint f=mp[t];\n\t\tE.PB(MP(f,u));\n\t\tson[f].PB(u);\n\t\tsz[f]+=sz[u];\n\t}\n\tint rt=que.top().id;\n\tif(dfs(rt)!=d[rt]) {\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<E.size();++i) printf(\"%d %d\\n\",E[i].first,E[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<(n); ++i)\n#define rrep(i,n) for(int i=1; i<=(n); ++i)\n#define drep(i,n) for(int i=(n)-1; i>=0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define foreach(it, v) for(typeof(v.begin()) it=v.begin(); it!=v.end(); ++it)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define fi first\n#define se second\n#define v(T) vector<T>\n\ntypedef unsigned int uint;\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpii;\ntypedef set<int> si;\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\n\nint  N;\nll D[100010];\nint n[100010];\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin >> N;\n  rrep(i,N) cin >> D[i];\n\n  vi ind(N);\n  vi par(N+1);\n  rep(i,N) ind[i] = i+1;\n  sort(&ind[0], &ind[N], [](int i1, int i2) {\n    return D[i1] > D[i2];\n  });\n  rep(i,N-1) {\n    int ii = ind[i];\n    ++n[ii];\n    ll Dj = D[ii] + n[ii] * 2 - N;\n    srep(j,i+1,N+1) {\n      int ij = ind[j];\n      if (D[ij] == Dj) {\n        par[ii] = ij;\n        n[ij] += n[ii];\n        break;\n      }\n    }\n    if (par[ii]==0) {\n      cout << \"-1\\n\";\n      return 0;\n    }\n  }\n  vpii ans;\n  v(ll) s(N+1);\n  rep(i,N-1) {\n    int ii = ind[i];\n    s[par[ii]] += s[ii] + n[ii];\n    ans.pb(pii(ii, par[ii]));\n  }\n  if (s[ind[N-1]] != D[ind[N-1]]) {\n    cout << \"-1\\n\";\n  } else {\n    for (auto e : ans) {\n      cout << e.fi << \" \" << e.se << \"\\n\";\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define fi first\n#define SZ(x) (int((x).size()))\n#define se second\n#define ll long long\n#define pq priority_queue\n#define MP make_pair\n#define pii pair<int,int>\n#define mod 998244353\n#define debug(x) cerr<<#x<<\"=\"<<x<<'\\n'\n\nconst int maxn=1e6+10;\n\nint n;\nmap <ll,int> mp;\nll D[maxn];\npair<ll,int> d[maxn];\nint sz[maxn];\nll f[maxn];\nvector <int> e[maxn];\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) {\n\t\tll x;\n\t\tscanf(\"%lld\",&x);\n\t\td[i]=MP(x,i);\n\t\tmp[x]=i;\n\t\tD[i]=x;\n\t}\n\tsort(d+1,d+n+1);\n\treverse(d+1,d+n+1);\n\tmemset(sz,0,sizeof(sz));\n\tmemset(f,0,sizeof(f));\n\tfor (int i=1;i<n;i++) {\n\t\tsz[d[i].se]++;\n/*\t\tif (n-2*sz[i]<=0) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n*/\t\tll want=d[i].fi-(ll)(n-2*sz[d[i].se]);\n\t\tif (mp.find(want)==mp.end()) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\te[d[i].se].pb(mp[want]);\n\t\te[mp[want]].pb(d[i].se);\n\t\tsz[mp[want]]+=sz[d[i].se];\n\t\tf[mp[want]]+=(ll)sz[d[i].se]+f[d[i].se];\n\t}\n\tif (f[d[n].se]!=D[d[n].se]) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=0;j<e[i].size();j++) {\n\t\t\tif (e[i][j]>i) printf(\"%d %d\\n\",i,e[i][j]);\n\t\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<iostream>\n#include<set>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<bitset>\n#define Fail puts(\"NO\"),exit(0);\n#define eps 1e-10\n#define maxn 100010\n#define maxm 100010\n#define inf 1000000007\n//#define mod 1000000009\n#define inv 500000005\n#define G 3\n#define pi acos(-1)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<ll,int>pii;\ntypedef bitset<maxn> bit;\ntypedef long double ld;\nll read()\n{\n    ll x=0,f=1;\n    char ch=getchar();\n    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}\n    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,size[maxn];\npii p[maxn];\nint head[maxn],nxt[maxn*2],to[maxn*2],tot;\nvoid add(int u,int v)\n{\n    tot++;\n    nxt[tot]=head[u];\n    head[u]=tot;\n    to[tot]=v;\n}\nint u[maxn],v[maxn];\nll dfs(int x,int las,ll d)\n{\n    ll res=d;\n    for(int i=head[x];i;i=nxt[i])\n      if(to[i]!=las)  res+=dfs(to[i],x,d+1);\n    return res;\n}\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;i++)  p[i].fi=read(),p[i].se=i,size[i]=1;\n    sort(p+1,p+n+1);reverse(p+1,p+n+1);\n    for(int i=1;i<n;i++)\n    {\n        int l=1,r=n,pos=0;\n        while(l<=r)\n        {\n            int mid=(l+r)/2;\n            if(p[mid].fi>=p[i].fi+2*size[i]-n)\n            {\n                pos=mid;\n                l=mid+1;\n            }\n            else r=mid-1;\n        }\n        if(p[pos].fi!=p[i].fi+2*size[i]-n)  return puts(\"-1\"),0;\n        size[pos]+=size[i];\n        u[i]=p[pos].se;v[i]=p[i].se;\n        add(u[i],v[i]);\n        add(v[i],u[i]);\n    }\n    ll com=dfs(p[n].se,0,0);\n    if(com!=p[n].fi)   return puts(\"-1\"),0;\n    for(int i=1;i<n;i++)  printf(\"%d %d\\n\",u[i],v[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main() {\n\tlong long N;\n\tcin >> N;\n\tvector<pair<long long, long long> > D(N);\n\tvector<long long> E(N);\n\tvector<long long> COUNT(N, 1);\n\tvector<pair<long long, long long> > ANS;\n\tfor (int i = 0; i < N; i++) cin >> D[i].first, D[i].second = i, E[i] = D[i].first;\n\tsort(D.begin(), D.end());\n\tsort(E.begin(), E.end());\n\tfor (int i = N - 1; i > 0; i--) {\n\t\tlong long C = COUNT[D[i].second];\n\t\tlong long ND = D[i].first - (N - C * 2);\n\t\tlong long it = lower_bound(E.begin(), E.end(), ND) - E.begin();\n\t\tif (D[it].first != ND || i <= it) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tANS.push_back({ D[i].second, D[it].second });\n\t\tCOUNT[D[it].second] += COUNT[D[i].second];\n\t}\n\tvector<vector<long long> > V(N);\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tV[ANS[i].first].push_back(ANS[i].second);\n\t\tV[ANS[i].second].push_back(ANS[i].first);\n\t}\n\tvector<long long> Dists(N, -1);\n\tDists[D[0].second] = 0;\n\tqueue<long long> Q;\n\tQ.push(D[0].second);\n\twhile (!Q.empty()) {\n\t\tlong long P = Q.front();\n\t\tQ.pop();\n\t\tfor (long long NP : V[P]) {\n\t\t\tif (Dists[NP] == -1) {\n\t\t\t\tDists[NP] = Dists[P] + 1;\n\t\t\t\tQ.push(NP);\n\t\t\t}\n\t\t}\n\t}\n\tlong long SUM = 0;\n\tfor (int i = 0; i < N; i++) SUM += Dists[i];\n\tif (SUM != D[0].first) cout << -1 << endl;\n\telse for (int i = 0; i < N - 1; i++) cout << ANS[i].first + 1 << \" \" << ANS[i].second + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pb push_back\n#define mp make_pair\n#define INF 0x3f3f3f3f\n#define Inf 1000000000000000000LL\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int>pii;\nint n;\nsigned main(){\n\t\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\t\n\tcin>>n;\n\tvector<int>d(n);\n\tvector<int>w(n,1);\n\tmap<int,int>mm;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>d[i];\n\t\tmm[d[i]]=i;\n\t}\n\tvector<pii>res;\n\tfor(int iit=0;iit<n-1;iit++){\n\t\tauto it=mm.rbegin();\n\t\tint i=it->S;\n\t\tint x=d[i]-(n-w[i])+w[i];\n\t\tif(!mm.count(x)||mm[x]==i)return puts(\"-1\"),0;\n\t\tint j=mm[x];\n\t\tres.pb(mp(i,j));\n\t\tw[j]+=w[i];\n\t\tmm.erase(--mm.end());\n\t}\n\tvector<int>v(n,-1);\n\tvector<vector<int> >G(n);\n\tv[0]=0;\n\tfor(auto&p:res){\n\t\tG[p.F].pb(p.S);\n\t\tG[p.S].pb(p.F);\n\t}\n\tvector<int>qq(1,0);\n\tfor(int b=0;b<(int)(qq.size());b++)\n\t\tfor(int j:G[qq[b]])\n\t\t\tif(v[j]==-1){\n\t\t\t\tqq.pb(j);\n\t\t\t\tv[j]=v[qq[b]]+1;\n\t\t\t}\n\tif(accumulate(v.begin(),v.end(),0LL)!=d[0])return puts(\"-1\"),0;\n\tfor(auto&p:res)cout<<p.F+1<<' '<<p.S+1<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long int int64;\nstruct vertex {\n\tint i;\n\tint64 val;\n\tint size;\n\tint parent;\n\tint next,child;\n\tint depth;\n} v[100003];\nvoid dfs(int i)\n{\n\tfor(int j = v[i].child;j != -1;j = v[j].next) {\n\t\tv[j].depth = v[i].depth + 1;\n\t\tdfs(j);\n\t}\n}\nint n;\nbool cmp1(const vertex &a,const vertex &b) {\n\treturn a.val < b.val;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i = 0;i < n;++i) {\n\t\tscanf(\"%lld\",&v[i].val);\n\t\tv[i].i = i + 1;\n\t\tv[i].size = 1;\n\t}\n\tstd::sort(v,v+n,cmp1);\n\tstd::map<int64,int> m;\n\tfor(int i = 0;i < n;++i) {\n\t\tm[v[i].val] = i;\n\t\tv[i].next = v[i].child = -1;\n\t}\n\tfor(int i = n - 1;i >= 1;--i) {\n\t\tint64 val2 = v[i].val - n + 2LL * v[i].size;\n\t\tstd::map<int64,int>::iterator it = m.find(val2);\n\t\tif(it == m.end()) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tv[i].parent = it->second;\n\t\tv[v[i].parent].size += v[i].size;\n\t\tv[i].next = v[v[i].parent].child;\n\t\tv[v[i].parent].child = i;\n\t}\n\tint64 dsum = 0;\n\tdfs(0);\n\tfor(int i = 0;i < n;++i) {\n\t\tdsum += v[i].depth;\n\t}\n\tif(v[0].size == n && v[0].val == dsum) {\n\t\tfor(int i = 1;i < n;++i) {\n\t\t\tprintf(\"%d %d\\n\", v[i].i, v[v[i].parent].i);\n\t\t}\n\t} else {\n\t\tprintf(\"-1\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cassert>\n#include<cmath>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<vector>\n#include<time.h>\n#include<algorithm>\nusing namespace std;\n#define REP(i,x,y) for(ll i=x;i<=y;i++)\n#define rep(i,n) REP(i,1,n)\n#define rep0(i,n) REP(i,0,n-1)\n#define repG(i,x) for(ll i=pos[x];~i;i=e[i].next)\n#define ll long long\n#define db double\nconst ll N=1e5+7;\nconst ll INF=1e9+7;\nll n,cnt=0;\nll sz[N],w[N],X[N],Y[N];\nstruct pir{ll x,d;}p[N];\nbool cmp(pir a,pir b){return a.d<b.d;}\n\nint main(){\n\tscanf(\"%lld\",&n);\n\trep(i,n)scanf(\"%lld\",&p[i].d),p[i].x=i;\n\tsort(p+1,p+n+1,cmp);\n\trep(i,n){\n\t\tw[i]=p[i].d;\n\t\tsz[i]=1;\n\t}\n\tfor(ll i=n;i>1;i--){\n\t\tll t=lower_bound(w+1,w+n+1,w[i]-(n-2*sz[i]))-w;\n\t\tif(w[t]!=w[i]-(n-2*sz[i])){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsz[t]+=sz[i];\n\t\tX[++cnt]=p[i].x;\n\t\tY[cnt]=p[t].x;\n\t}\n\tif(sz[1]!=n){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\trep(i,cnt)printf(\"%lld %lld\\n\",X[i],Y[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimiz(O2)\n\n#include <bits/stdc++.h>\n\n#define rg register\nusing namespace std;\ntypedef long long ll;\n\ntemplate<typename T>\ninline bool read(T &n) {\n    T ans = 0, flag = 1;\n    char ch;\n    while ((ch = getchar()) < '0' || ch > '9') if (ch == '-') flag = -1; else if (ch == EOF) return false;\n    ans = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9') ans = ans * 10 + ch - '0';\n    n = ans * flag;\n    return true;\n}\n\ninline ll read() {\n    ll ans = 0, flag = 1;\n    char ch;\n    while ((ch = getchar()) < '0' || ch > '9') if (ch == '-') flag = -1;\n    ans = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9') ans = ans * 10 + ch - '0';\n    return ans * flag;\n};\nconst int maxn = 100005;\nstruct NODE {\n    ll val, ord;\n    bool operator<(NODE b) const {\n        return val < b.val;\n    }\n} node[maxn];\nint siz[maxn],fa[maxn];\nunordered_map<ll,int> unM;\nint main() {\n    int n;\n    read(n);priority_queue<NODE> pq;\n    for (rg int i = 1; i <= n; ++i) {\n        siz[i] = 1;\n        read(node[i].val);\n        node[i].ord = i;\n        pq.push(node[i]);\n        unM[node[i].val]=i;\n    }\n    for(rg int i=n;i>=2;i--){\n        NODE now=pq.top();pq.pop();\n        if(unM.find(now.val+2*siz[now.ord]-n)==unM.end()||unM[now.val+2*siz[now.ord]-n]==now.ord){\n            puts(\"-1\");return 0;\n        }\n        fa[now.ord]=unM[now.val+2*siz[now.ord]-n];\n        siz[fa[now.ord]]+=siz[now.ord];\n    }\n    for(rg int i=1;i<=n;i++){\n        if(fa[i]) cout<<i<<' '<<fa[i]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n\nconst ll dx[4] = { -1,1,0,0 };\nconst ll dy[4] = { 0,0,-1,1 };\nconst char c[4] = { 'R','L','U','D' };\n\nint main(){\n\tstatic ll n;\n\tstatic ll d[100010];\n\tscanf(\"%lld\",&n);\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tscanf(\"%lld\",&d[i]);\n\t}\n\t\n\tvector<P> vec;\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tvec.push_back(P(d[i],i));\n\t}\n\tsort(vec.begin(),vec.end());\n\treverse(vec.begin(),vec.end());\n\t\n\tstatic ll cnt[100010];\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tcnt[i] = 1;\n\t}\n\t\n\tmap<ll,ll> id;\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tid[d[i]] = i;\n\t}\n\t\n\tvector<P> ans;\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tP p = vec[i-1];\n\t\t//cout << p.fr << \" \" << p.sc << endl;\n\t\tif(cnt[p.sc]*2 >= n)continue;\n\t\tll nx = d[p.sc]-(n-cnt[p.sc])+cnt[p.sc];\n\t\tif(id.find(nx) == id.end()){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tans.push_back(P(p.sc,id[nx]));\n\t\t\tcnt[id[nx]] += cnt[p.sc];\n\t\t}\n\t}\n\tif(n%2 == 0){\n\t\tif(vec[n-2].fr != vec[n-1].fr){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tans.push_back(P(vec[n-2].sc,vec[n-1].sc));\n\t}\n\t\n\tfor(int i = 0 ; i < ans.size() ; i ++){\n\t\tprintf(\"%d %d\\n\",ans[i].fr,ans[i].sc);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> g[100005];\nlong long d[100005];\nint sz[100005];\nmap<long long,int> mp;\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> d[i];\n\t\tmp[d[i]] = i;\n\t\tsz[i] = 1;\n\t}\n\tfor (int it = 1; it < n; ++it) {\n\t\tint u = mp.rbegin()->second;\n\t\tlong long need = d[u] - (n - sz[u]) + sz[u];\n\t\tif (mp.find(need) == mp.end() || mp[need] == u) {\n\t\t\treturn cout << -1 << '\\n',0;\n\t\t} \n\t\tint v = mp[need];\n\t\tg[v].push_back(u);\n\t\tsz[v] += sz[u];\n\t\tmp.erase(mp.find(d[u]));\n\t}\n\tfor (int u = 1; u <= n; ++u) {\n\t\tfor (int v : g[u]) cout << u << ' ' << v << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> pii;\n\npii inp[100005];\nint siz[100005];\nvector<pii> ans;\n\nint main() {\n\tint N; scanf(\"%d\", &N);\n\tfor (int i = 1; i <= N; i++) {\n\t\tll x; scanf(\"%lld\", &x);\n\t\tinp[i] = {x, i};\n\t\tsiz[i] = 1;\n\t}\n\tsort(inp + 1, inp + N + 1);\n\tfor (int i = N; i >= 2; i--) {\n\t\tll cur; int id;\n\t\ttie(cur, id) = inp[i];\n\t\tint del = N - 2 * siz[id];\n\t\tauto it = *lower_bound(inp + 1, inp + i, pii(cur - del, 0));\n\t\tif (it.first != cur - del || del <= 0) return !printf(\"-1\");\n\t\tsiz[it.second] += siz[id];\n\t\tif (id > it.second) swap(id, it.second);\n\t\tans.push_back({id, it.second});\n\t}\n\tsort(ans.begin(), ans.end());\n\n\tfor (pii &x : ans) {\n\t\tprintf(\"%lld %d\\n\", x.first, x.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <ctime>\nusing namespace std;\n#define _LL long long\n#define rep(i, n) for (_LL i = 0; i < (_LL)(n); i++)\n#define vecrep(itr, v) for (auto itr = (v).begin(); itr != (v).end(); itr++)\n\n\n\nint main()\n{\n    ios::sync_with_stdio(false); cin.tie(nullptr); \n    int n; cin >> n;\n    vector<pair<int,int>> d(n);\n    rep(i, n)\n    {\n        cin >> d[i].first;\n        d[i].second = i + 1;\n    }\n\n    sort(d.begin(), d.end(), greater<pair<int,int>>());\n    map<int, int> vmap;\n    vector<int> num(n + 1);\n    vector<pair<int,int>> ans;\n    rep(i, n) {vmap[d[i].first] = d[i].second; num[d[i].second] = 1; }\n    rep(i, n - 1)\n    {\n        int d1 = d[i].first;\n        int n1 = num[d[i].second];\n        num[d[i].second] = 0;\n        int n2 = n - n1;\n        int d2 = d1 + n1 - n2;\n        if( vmap[d2] == 0 || num[vmap[d2]] == 0 )\n        {\n            cout << -1 << endl;\n            return 0;\n        }\n        num[vmap[d2]] += n1;\n        ans.emplace_back(d[i].second, vmap[d2]);\n    }\n\n    vecrep(itr, ans) cout << itr->first << \" \" << itr->second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <numeric>\n#include <map>\n#define fail return puts(\"-1\"), 0\n\nconst int N = 1e5 + 5, M = 2e5 + 5;\n\nint n, tot, lnk[N], ter[M], nxt[M], sz[N];\nlong long dis[N], d[N];\nstd::map<long long, int> mp;\n\nvoid add(int u, int v) {\n\tter[++tot] = v, nxt[tot] = lnk[u], lnk[u] = tot;\n}\nvoid dfs(int u, int p) {\n\tfor (int i = lnk[u]; i; i = nxt[i]) {\n\t\tint v = ter[i];\n\t\tif (v == p) continue;\n\t\tdis[v] = dis[u] + 1;\n\t\tdfs(v, u);\n\t}\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &d[i]);\n\t\tmp[d[i]] = i, sz[i] = 1;\n\t}\n\tint cnt = 0;\n\tfor (auto it = mp.rbegin(); it != mp.rend(); it++) {\n\t\tint v = it->second, u = mp[it->first + 2 * sz[v] - n];\n\t\tif (!u || u == v) fail;\n\t\tadd(u, v), add(v, u), sz[u] += sz[v];\n\t\tif (++cnt == n - 1) break;\n\t}\n\tint rt = mp.begin()->second;\n\tdfs(rt, 0);\n\tif (std::accumulate(dis + 1, dis + n + 1, 0LL) != d[rt]) fail;\n\tfor (int i = 1; i <= tot; i += 2) {\n\t\tprintf(\"%d %d\\n\", ter[i], ter[i + 1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <ctime>\nusing namespace std;\n#define _LL long long\n#define rep(i, n) for (_LL i = 0; i < (_LL)(n); i++)\n#define vecrep(itr, v) for (auto itr = (v).begin(); itr != (v).end(); itr++)\n\n\n\nint main()\n{\n    ios::sync_with_stdio(false); cin.tie(nullptr); \n    _LL n; cin >> n;\n    vector<pair<_LL,_LL>> d(n);\n    rep(i, n)\n    {\n        cin >> d[i].first;\n        d[i].second = i + 1;\n    }\n\n    sort(d.begin(), d.end(), greater<pair<_LL,_LL>>());\n    map<_LL, _LL> vmap;\n    vector<_LL> num(n + 1);\n    vector<pair<_LL,_LL>> ans;\n    rep(i, n) {vmap[d[i].first] = d[i].second; num[d[i].second] = 1; }\n    rep(i, n - 1)\n    {\n        _LL d1 = d[i].first;\n        _LL n1 = num[d[i].second];\n        num[d[i].second] = 0;\n        _LL n2 = n - n1;\n        _LL d2 = d1 + n1 - n2;\n        if( vmap[d2] == 0 || num[vmap[d2]] == 0 )\n        {\n            cout << -1 << endl;\n            return 0;\n        }\n        num[vmap[d2]] += n1;\n        ans.emplace_back(d[i].second, vmap[d2]);\n    }\n\n    vecrep(itr, ans) cout << itr->first << \" \" << itr->second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\nstruct node\n{\n\tint f,t;\n} t[1000000];\n\nlong long a[1000000],size[1000000],id[1000000],hh[1000000],h,tot;\nmap<long long,int>mp;\n\nvoid add(long long x,long long y)\n{\n\tt[++h].f=hh[x];\n\tt[h].t=y;\n\thh[x]=h;\n}\n\nint cmp(int x,int y)\n{\n\treturn a[x]>a[y];\n}\n\nvoid dfs(int x,int y,int z)\n{\n\ttot+=z;\n\tfor(int i=hh[x];i;i=t[i].f)\n\t{\n\t\tint j=t[i].t;\n\t\tif(j==y) \n\t\t\tcontinue;\n\t\tdfs(j,x,z+1);\n\t}\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) \n\t{\n\t\tscanf(\"%lld\",a+i);\n\t\tmp[a[i]]=i;\n\t\tsize[i]=1;\n\t\tid[i]=i;\n\t}\n\tsort(id+1,id+1+n,cmp);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tlong long x=id[i],y=a[x]-(n-size[x])+size[x];\n\t\tif(!mp[y]||y>=a[x]) \n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\ty=mp[y];\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t\tsize[y]+=size[x];\n\t}\n\tdfs(id[n],0,0);\n\tif(tot!=a[id[n]]) \n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=hh[i];j;j=t[j].f)\n\t\t\tif(t[j].t>i) \n\t\t\t\tprintf(\"%d %d\\n\",i,t[j].t);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint n;\nvector<pair<ll,int>> v;\nvector<int> fa,siz;\n\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n    cin>>n;\n    v.resize(n + 1);\n    fa.resize(n + 1);\n    siz.resize(n + 1);\n    fill(fa.begin(),fa.end(),0);\n    fill(siz.begin(),siz.end(),1);\n    for(int i = 1; i <= n; i++) {\n        cin>>v[i].first;\n        v[i].second = i;\n    }\n    sort(v.begin() + 1,v.end(),[](auto x,auto y){ return x.first > y.first;});\n    for(int i = 1; i < n; i++){\n        int d = v[i].first;\n        int sz = siz[v[i].second];\n        int d_nxt = d - n + 2 * sz;\n        int lo = i + 1, hi = n;\n        int ans_pos = 0;\n        while(lo <= hi){\n            int mid = lo + hi >> 1;\n            if(v[mid].first > d_nxt){\n                lo = mid + 1;\n            }\n            else if(v[mid].first < d_nxt){\n                hi = mid - 1;\n            }\n            else {\n                ans_pos = mid;\n                break;\n            }\n        }\n        if(ans_pos == 0){\n            cout<<-1<<endl;\n            exit(0);\n        }\n        int u = v[i].second;\n        int f = v[ans_pos].second;\n        fa[u] = f;\n        siz[f] += siz[u];\n    }\n    for(int i = 1; i < n; i++){\n        cout<<v[i].second<<\" \"<<fa[v[i].second]<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<vector>\n\ntypedef long long ll;\n\nint const N = 1e5 + 5;\n\nint fa[N];\nint sz[N];\nll a[N];\nll dis[N];\nbool vis[N];\nint n;\n\nstd::vector<int> E[N];\nvoid addedge2(int x, int y) {\n    E[x].push_back(y);\n    E[y].push_back(x);\n}\n\nvoid dfs(int x, int& sum, int dep) {\n    sz[x] = 1;\n    vis[x] = 1;\n    sum += dep;\n    for(auto y : E[x]) if(vis[y] == 0) {\n        dfs(y, sum, dep + 1);\n        sz[x] += sz[y];\n    }\n}\n\nbool chk(int x, int ans) {\n    if(a[x] != ans) return 0;\n    vis[x] = 1;\n    bool ret = 1;\n    for(auto& y : E[x]) if(vis[y] == 0) {\n        ret &= chk(y, ans + n - 2 * sz[y]);\n    }\n    return ret;\n}\n\nint main() {\n    std::map<ll, int, std::greater<ll> > M;\n    std::ios::sync_with_stdio(0);\n    std::cin >> n;\n    for(int i = 1; i <= n; ++i) {\n        std::cin >> a[i];\n        M.insert(std::make_pair(a[i], i));\n    }\n    for(auto& k : M) if(k.first != (*M.rbegin()).first) {\n        int now = k.second;\n        ++sz[now];\n        int f = k.first + 2 * sz[now] - n;\n        if(M.count(f) == 0) {\n            puts(\"-1\");\n            return 0;\n        }\n        fa[now] = M[f];\n        sz[fa[now]] += sz[now];\n        ::addedge2(now, fa[now]);\n    }\n    int root = (*M.rbegin()).second;\n    int ans_root = 0;\n    memset(vis, 0, sizeof(vis));\n    memset(sz, 0, sizeof(sz));\n    dfs(root, ans_root, 0);\n    memset(vis, 0, sizeof(vis));\n    if(chk(root, ans_root) == 0) {\n        puts(\"-1\");\n        return 0;\n    }\n    for(int i = 1; i <= n; ++i) if(fa[i] != 0) {\n        std::cout << fa[i] << ' ' << i << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define No {puts(\"-1\");return 0;}\n#define fo(i,l,r) for(int i=l;i<=r;i++)\n#define of(i,l,r) for(int i=l;i>=r;i--)\n#define fe(i,u) for(int i=head[u];i;i=e[i].next)\nusing namespace std;\ntypedef long long ll;\ninline void open(const char *s)\n{\n\t#ifndef ONLINE_JUDGE\n\tchar str[20];\n\tsprintf(str,\"in%s.txt\",s);\n\tfreopen(str,\"r\",stdin);\n//\tsprintf(str,\"out%s.txt\",s);\n//\tfreopen(str,\"w\",stdout);\n\t#endif\n}\ninline ll rd()\n{\n\tstatic ll x,f;\n\tx=0;f=1ll;\n\tchar ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1ll;\n\tfor(;ch>='0'&&ch<='9';ch=getchar())x=x*10ll+ch-'0';\n\treturn f>0?x:-x;\n}\nconst int N=100010;\nstruct edge{\n\tint u,v,next;\n\tedge(int u=0,int v=0,int next=0):u(u),v(v),next(next){}\n}e[N];\nint n,siz[N],rt;ll d[N];\nint tot=0,head[N];\nstruct node{\n\tll x;int id;\n}q[N];\nmap<ll,int>mp;\n\ninline bool cmp(node a,node b){return a.x>b.x;}\ninline void add(int u,int v){e[++tot]=edge(u,v,head[u]);head[u]=tot;}\n\nvoid dfs1(int u,int dep)\n{\n\td[rt]+=dep;\n\tfe(i,u){int v=e[i].v;dfs1(v,dep+1);}\n}\nvoid dfs2(int u)\n{\n\tfe(i,u){\n\t\tint v=e[i].v;\n\t\td[v]=d[u]+ll(n-(siz[v]<<1ll));\n\t\tdfs2(v);\n\t}\n}\n\nint main()\n{\n\tn=rd();fo(i,1,n)mp[q[q[i].id=i].x=rd()]=i,siz[i]=1;\n\tsort(q+1,q+n+1,cmp);\n\tfo(i,1,n-1){\n\t\tint x=q[i].id;\n\t\tll dd=q[i].x-n+(siz[x]<<1);\n\t\tif(dd>=q[i].x)No\n\t\tif(!mp.count(dd))No\n\t\tint fa=mp[dd];\n\t\tadd(fa,x);siz[fa]+=siz[x];\n\t}\n\trt=q[n].id;\n\tdfs1(rt,0);\n\tdfs2(rt);\n\tfo(i,1,n)if(d[q[i].id]!=q[i].x)No\n\tfo(i,1,tot)printf(\"%d %d\\n\",e[i].u,e[i].v);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define int long long\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par, size_;\npublic:\n    UnionFind(){}\n    UnionFind(int node_size) : sz(node_size), par(sz), size_(sz, 1){\n        iota(par.begin(), par.end(), 0);\n    }\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n    void unite(int x,int y){\n        x = find(x), y = find(y);\n        if(x == y) return;\n        if(size_[x] < size_[y]) swap(x,y);\n        par[y] = x;\n        size_[x] += size_[y];\n    }\n    int size(int x){\n        x = find(x);\n        return size_[x];\n    }\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n};\n\nvector<vector<int> > gg;\npair<int,int> dfs(int id,int pre){\n    pair<int,int> sm = MP(0,0);\n    for(auto x:gg[id]){\n        if(x!=pre){\n            pair<int,int> tmp = dfs(x,id);\n            sm.first += tmp.first;\n            sm.second += tmp.second;\n        }\n    }\n    sm.second += sm.first;\n    sm.first++;\n    return sm;\n}\n\n\nsigned main(){\n    int n;\n    cin >> n;\n    UnionFind uf(n+1);\n    vector<pair<int,int> > v;\n    map<int,int> p;\n    rep(i,n){\n        int d;\n        cin >> d;\n        p[d] = i+1;\n        v.push_back(MP(d,i+1));\n    }\n    sort(v.begin(),v.end(),greater<pair<int,int> >());\n    map<int,int> mp;\n    gg.resize(n+1);\n    vector<pair<int,int> > g;\n    bool ng = 1;\n    rep(i,n){\n        int k = v[i].first;\n        int u = v[i].second;\n        int c = mp[k];\n        c++;\n        //cerr << k << \" \" << u << \" \" << c << endl;\n        if(c==n&&i==n-1){\n            ng = 0;\n            continue;\n        }\n        int nxt = k - (n-c-c);\n        if(p.find(nxt)==p.end()){\n            cout << -1 << endl;\n            return 0;\n        }\n        mp[nxt]+=c;\n        g.push_back(MP(u,p[nxt]));\n        gg[u].push_back(p[nxt]);\n        gg[p[nxt]].push_back(u);\n        uf.unite(u,p[nxt]);\n    }\n    for(int i=1;i<=n;i++){\n        if(!uf.same(i,1)){\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n    if(ng){\n        cout << -1 << endl;\n        return 0;\n    }\n    if(dfs(v[n-1].second,-1).second!=v[n-1].first){\n        cout << -1 << endl;\n        return 0;\n    }\n    for(auto x:g){\n\n        cout << x.first << \" \" << x.second << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stdio.h>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nvector < pair <int, int> > v;\n\nint n, sz[1000000], r[1000000];\n\nbool ans = true;\n\nvector <int> g[1000000];\n\nint dfs (int x, int p)\n{\n\tint sum = sz[x] - 1;\n\n\tfor (int to : g[x])\n\t\tif (to != p)\n\t\t\tsum += dfs (to, x);\n\n\treturn sum;\n}\n\nint main () \n{\n    cin >> n;\n    \n    for (int i = 0; i < n; i++)\n    {\n\t\tint d;\n\t\tscanf (\"%d\", &d);\n\t\t\n\t\tv.emplace_back (d, i);\n\n\t\tr[i] = d;\n    }\n    \n    sort (v.begin (), v.end ());\n    \n    for (int i = n - 1; i >= 0; i--)\n    {\n\t\tint x = v[i].second, d = v[i].first;\n\t\t\n\t\tsz[x] = 1;\n\t\t\n\t\tfor (int to : g[x])\n\t\t    sz[x] += sz[to];\n\t\t\n\t\tif (!i) break;\n\t\t\n\t\tint k = lower_bound (v.begin (), v.end (), make_pair (d + 2 * sz[x] - n, -1)) - v.begin ();\n\t\t\n\t\tif (k == v.size () || v[k].first != d + 2 * sz[x] - n)\n\t\t{\n\t\t    cout << -1;\n\t\t    return 0;\n\t\t}\n\t\t\n\t\tg[v[k].second].push_back (x);\n    }\n    \n    if (dfs (v[0].second, -1) != v[0].first)\n    {\n\t\tcout << -1;\n\t\treturn 0;\n    }\n    \n    for (int i = 0; i < n; i++)\n\t\tfor (int to : g[i])\n\t\t{\n\t\t    printf (\"%d %d\\n\", i + 1, to + 1);\n\t\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include <cstddef>\n#include <cstdint>\n#include <vector>\n\nusing i8 = ::std::int_least8_t;\nusing i32 = ::std::int_least32_t;\nusing i64 = ::std::int_least64_t;\nusing u8 = ::std::uint_least8_t;\nusing u32 = ::std::uint_least32_t;\nusing u64 = ::std::uint_least64_t;\nusing isize = ::std::ptrdiff_t;\nusing usize = ::std::size_t;\n\nclass rep {\n\tconst usize f, l;\n\npublic:\n\tclass itr {\n\t\tfriend rep;\n\t\tusize i;\n\t\titr(usize x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { ++i; }\n\t\tusize operator*() const noexcept { return i; }\n\t\tbool operator!=(const itr x) const noexcept { return i != x.i; }\n\t};\n\trep(usize first, usize last) noexcept : f(first), l(last) {}\n\titr begin() const noexcept { return itr(f); }\n\titr end() const noexcept { return itr(l); }\n};\nclass revrep {\n\tconst usize f, l;\n\npublic:\n\tclass itr {\n\t\tfriend revrep;\n\t\tusize i;\n\t\titr(usize x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { --i; }\n\t\tusize operator*() const noexcept { return i; }\n\t\tbool operator!=(const itr x) const noexcept { return i != x.i; }\n\t};\n\trevrep(usize first, usize last) noexcept : f(first), l(last) {}\n\titr begin() const noexcept { return itr(l - 1); }\n\titr end() const noexcept { return itr(f - 1); }\n};\ntemplate <class T> bool maxi(T &a, const T &b) {\n\treturn a <= b ? (a = b, 1) : 0;\n}\ntemplate <class T> bool mini(T &a, const T &b) {\n\treturn b <= a ? (a = b, 1) : 0;\n}\ntemplate <class T> bool smaxi(T &a, const T &b) {\n\treturn b <= a ? 0 : (a = b, 1);\n}\ntemplate <class T> bool smini(T &a, const T &b) {\n\treturn a <= b ? 0 : (a = b, 1);\n}\ntemplate <class T> using vec_alias = ::std::vector<T>;\ntemplate <class T> auto md_vec(usize n, const T &value) {\n\treturn ::std::vector<T>(n, value);\n}\ntemplate <class... Args> auto md_vec(usize n, Args... args) {\n\treturn ::std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n}\ntemplate <class T> const T &as_const(const T &v) noexcept { return v; }\n\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <queue>\n#include <tuple>\n#include <unordered_map>\n\nint main() {\n\tusize n;\n\t::std::cin >> n;\n\t::std::vector<u64> d(n), sub(n, 1);\n\t::std::vector<usize> parent(n, n);\n\t::std::unordered_map<u64, usize> mp;\n\tfor (auto &e : d)\n\t\t::std::cin >> e;\n\t::std::priority_queue<u64> que;\n\tfor (const auto i : rep(0, n)) {\n\t\tque.emplace(d[i]);\n\t\tmp[d[i]] = i;\n\t}\n\n\twhile (que.size() != 1) {\n\t\tu64 c = que.top();que.pop();\n\t\tusize i = mp[c];\n\t\tif (n <= sub[i] * 2 || c < n - sub[i] * 2)\n\t\t\treturn ::std::cout << \"-1\" << ::std::endl, 0;\n\t\tu64 next = c - (n - sub[i] * 2);\n\t\tif (mp.count(next)) {\n\t\t\tusize j = mp[next];\n\t\t\tparent[i] = j;\n\t\t\tsub[j] += sub[i];\n\t\t}\n\t\telse {\n\t\t\treturn ::std::cout << \"-1\" << ::std::endl, 0;\n\t\t}\n\t}\n\n\tfor (const auto i : rep(0, n)) {\n\t\tif (parent[i] != n)\n\t\t\t::std::cout << i + 1 << \" \" << parent[i] + 1 << ::std::endl;\n\t}\n\t\t\n\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e5 + 10;\n\nint id[N],Sz[N],to[N << 1],nex[N << 1],beg[N];\nll D[N],Sum = 0;\nint e;\nstruct node {\n\tint x,y;\n}G[N];\nmap <ll,int> Map,Id;\n\ninline void dfs(int x,int fa,int dis) {\n\tSum += dis;\n\tfor(int i = beg[x];i;i = nex[i]) {\n\t\tif(to[i] == fa) continue;\n\t\tdfs(to[i],x,dis + 1);\n\t}\n}\n\ninline ll read() {\n\tll x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-')ch = getchar();\n\tif(ch == '-')flag = -1,ch = getchar();\n\twhile(isdigit(ch))x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline void add(int x,int y) {\n\tto[++e] = y,nex[e] = beg[x],beg[x] = e;\n}\n\nint main() {\n\n\tint n = read(),rt = 0;\n\tFor(i,1,n) Map[D[i] = read()] = i,Sz[i] = 1;\n\tsort(D + 1,D + n + 1,greater<ll>());\n\tFor(i,1,n) Id[D[i]] = i;\n\n\tFor(i,1,n - 1) {\n\t\tll Pre = D[i] + Sz[i] * 2 - n,val = Id[Pre];\n\t\tif(!val || Pre >= D[i]) return puts(\"-1\"),0;\n\t\tSz[val] += Sz[i];\n\t\tG[i] = (node){Map[D[i]],Map[D[val]]};\n\t\trt = Map[D[val]];\n\t}\n\n\tFor(i,1,n - 1) add(G[i].x,G[i].y),add(G[i].y,G[i].x);\n\t\n\tdfs(rt,0,0);\n\n\tif(Sum != D[n]) return puts(\"-1\"),0;\n\n\tFor(i,1,n - 1) printf(\"%d %d\\n\",G[i].x,G[i].y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\nusing namespace std;\npair<long long,int> p[100010];\nmap<long long,vector<pair<int,int>>> mp;\nvector<pair<int,int>> ans;\nvector<int> G[100010];\nbool used[100010];\nvoid dfs(int s){\n\tused[s] = true;\n\tfor(int v: G[s]){\n\t\tif(!used[v]){\n\t\t\tdfs(v);\n\t\t}\n\t}\n}\nint main(){\n\tint i,n;\n\tcin >> n;\n\tfor(i=0;i<n;i++){\n\t\tlong long d;\n\t\tcin >> d;\n\t\tp[i] = {d,i};\n\t}\n\tsort(p,p + n);\n\tfor(i=n-1;i>=0;i--){\n\t\tif(mp.find(p[i].first)==mp.end()){\n\t\t\tmp[p[i].first - n + 2].push_back({p[i].second,1});\n\t\t}else{\n\t\t\tint sum = 1;\n\t\t\tfor(auto x:mp[p[i].first]){\n\t\t\t\tsum += x.second;\n\t\t\t\tans.push_back({x.first,p[i].second});\n\t\t\t}\n\t\t\tmp[p[i].first - n + 2*sum].push_back({p[i].second,sum});\n\t\t}\n\t}\n\tif(ans.size()==n-1){\n\t\tfor(i=0;i<n;i++) used[i] = false;\n\t\tfor(i=0;i<n-1;i++){\n\t\t\tG[ans[i].first].push_back(ans[i].second);\n\t\t\tG[ans[i].second].push_back(ans[i].first);\n\t\t}\n\t\tdfs(0);\n\t\tfor(i=0;i<n;i++){\n\t\t\tif(!used[i]){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<ans.size();i++){\n\t\t\tcout << ans[i].first + 1 << \" \" << ans[i].second + 1 << endl;\n\t\t}\n\t}else{\n\t\tcout << -1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100010;\n\ntypedef long long ll;\n\npriority_queue<ll> pq;\nmap<ll, int> mp;\n\nint n, l[maxn], dep[maxn], sz[maxn], w[maxn], vis[maxn], e_u[maxn], e_v[maxn], tot, e = 0;\nll D[maxn], S[maxn];\n\nstruct Edge {\n    int v, x;\n} E[maxn];\n\ninline void addEdge(int u, int v) {\n    E[e].v = v; E[e].x = l[u]; l[u] = e++;\n}\n\nvoid dfs1(int u) {\n    sz[u] = 1;\n    for (int p = l[u]; p >= 0; p = E[p].x) {\n        int v = E[p].v;\n        dep[v] = dep[u] + 1;\n        dfs1(v);\n        sz[u] += sz[v];\n    }\n}\n\nvoid dfs2(int u) {\n    for (int p = l[u]; p >= 0; p = E[p].x) {\n        int v = E[p].v;\n        S[v] = S[u] + n - 2 * sz[v];\n        dfs2(v);\n    }\n}\n\nint main() {\n    memset(l, -1, sizeof(l));\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) scanf(\"%lld\", &D[i]);\n    for (int i = 1; i <= n; i++) {\n        mp[D[i]] = i;\n        pq.push(D[i]);\n        w[i] = 1;\n    }\n    vis[0] = 1;\n    while (pq.size() > 1) {\n        ll v = pq.top(); pq.pop();\n        int u = mp[v];\n        vis[u] = 1;\n        if (!vis[mp[v + 2 * w[u] - n]]) {\n            int t = mp[v + 2 * w[u] - n];\n            w[t] += w[u];\n            addEdge(t, u);\n            ++ tot;\n            e_u[tot] = t; e_v[tot] = u;\n        } else {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    int r = mp[pq.top()];\n    dfs1(r);\n    for (int i = 1; i <= n; i++) S[r] += dep[i];\n    dfs2(r);\n    for (int i = 1; i <= 1; i++) {\n        if (S[i] != D[i]) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    for (int i = 1; i <= tot; i++) printf(\"%d %d\\n\", e_u[i], e_v[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint N;\nint D[110000], n[110000];\nunordered_map<int, int> mp;\nvint ans;\nsigned main() {\n    cin >> N;\n    for (int i = 1; i <= N; i++) {cin >> D[i]; n[i] = 1; mp[D[i]] = i;};\n    sort(D + 1, D + N + 1); reverse(D + 1, D + N + 1);\n    for (int i = 1; i <= N - 1; i++) {\n        int s = mp[D[i]];\n        int t = mp[D[i] - N + 2 * n[s]];\n        if (s == t || t == 0) {\n            cout << -1 << endl;\n            return 0;\n        }\n        n[t] += n[s];\n        ans.push_back(s); ans.push_back(t);\n    }\n    for (int i = 0; i < 2 * (N - 1); i += 2) {\n        cout << ans[i] << \" \" << ans[i + 1] << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <cmath>\n#include <bitset>\n#include <algorithm>\n#include <map>\n#include <vector>\ntypedef long long ll;\nusing namespace std;\nconst int maxn=101000;\nint n;\nll d[maxn];\nint size[maxn];\nll dis[maxn];\nmap<ll,int> mp;\nvector<int> G[maxn];\nll sum=0;\n\nvoid dfs1(int u,int fa){\n    for(int i=0;i<G[u].size();i++){\n        int v=G[u][i];\n        if(v==fa) continue;\n        dis[v]=dis[u]+1;\n        dfs1(v,u);\n    }\n    sum+=dis[u];\n}\n\nvoid dfs2(int u,int fa){\n    for(int i=0;i<G[u].size();i++){\n        int v=G[u][i];\n        if(v==fa) continue;\n        printf(\"%d %d\\n\",u,v);\n        dfs2(v,u);\n    }\n}\n\nint main(){\n    //初始化\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        scanf(\"%lld\",&d[i]);\n        mp[d[i]]=i;\n    }\n    sort(d+1,d+n+1);\n    for(int i=1;i<=n;i++) size[i]=1;\n    //构树\n    for(int i=n;i>1;i--){\n        int k=mp[d[i]];\n        int tmp=n-2*size[k];\n        //printf(\"%d   111\\n\",i);\n        if(tmp<=0) {printf(\"-1\\n\");return 0;}\n        ll ss=d[i]-tmp;\n        //printf(\"%d    222\\n\",i);\n        if(mp.count(ss)==0){printf(\"-1\\n\");return 0;}\n        int pos=mp[ss];\n        size[pos]+=size[k];\n        G[pos].push_back(k);\n        G[k].push_back(pos);\n    }\n   // printf(\"sbsbsb\\n\");\n    dis[mp[d[1]]]=0;\n    dfs1(mp[d[1]],-1);\n    if(sum!=d[1]){\n        printf(\"-1\\n\");\n    }else{\n        dfs2(1,-1);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint gae[100001];\nvector< pair<long long, int> > p;\nvector< pair<int, int> > ans;\nmap<long long, int> mp;\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    for(int i=1;i<=n;i++){\n        long long x;\n        scanf(\"%lld\", &x);\n        p.push_back({x, i});\n        gae[i] = 1;\n        mp[x] = i;\n    }\n    sort(p.begin(), p.end());\n    for(int i=n-1;i>=1;i--){\n        int target = p[i].second;\n        long long cal = p[i].first - n + gae[target] + gae[target];\n        int nxt = mp[cal];\n        //printf(\"%d %lld\\n\", nxt, cal);\n        if(nxt == 0 || cal >= p[i].first){\n            printf(\"-1\\n\");\n            return 0;\n        }\n        gae[nxt] += gae[target];\n        ans.push_back({nxt, target});\n    }\n    for(auto &anss: ans){\n        printf(\"%d %d\\n\", anss.first, anss.second);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long li;\n\nconst int maxn = 1e5;\n\nint n, fa[maxn];\nli D[maxn];\nint size[maxn];\n\npair<li, int> ord[maxn];\nmap<li, int> id;\n\nint main(void) {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) scanf(\"%lld\", D + i);\n  for (int i = 0; i < n; ++i) ord[i] = {D[i], i};\n  for (int i = 0; i < n; ++i) id[D[i]] = i;\n  sort(ord, ord + n);\n  reverse(ord, ord + n);\n  for (int i = 0; i < n; ++i) size[i] = 1;\n\n  for (int i = 0; i < n - 1; ++i) {\n    int u = ord[i].second;\n    li del = n - size[u] * 2;\n    if (del <= 0 || !id.count(D[u] - del)) {\n      puts(\"-1\");\n      return 0;\n    }\n    fa[u] = id[D[u] - del];\n    size[fa[u]] += size[u];\n  }\n\n  for (int i = 0; i < n - 1; ++i) {\n    int u = ord[i].second;\n    int v = fa[u];\n    printf(\"%d %d\\n\", u + 1, v + 1);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Copyright(c)2018 Mstdream\n#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\nconst int N=100010;\nint siz[N],n,tot,vis[N];\nmap<LL,int>f;\nstruct Q{\n\tLL v;int id;\n\tbool operator<(const Q&x)const{\n\t\treturn v>x.v;\n\t}\n}q[N];\nvector<int>g[N];\nvector<pair<int,int> >ans;\nbool flag=1;\nvoid dfs(int x){\n\ttot++;vis[x]=1;\n\tfor(auto v:g[x]){\n\t\tif(vis[v])flag=0;\n\t\telse dfs(v);\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&q[i].v);\n\t\tf[q[i].v]=i;\n\t\tq[i].id=i;\n\t\tsiz[i]=1;\n\t}\n\tsort(q+1,q+n+1);\n\tfor(int i=1;i<n;i++){\n\t\tLL d=q[i].v+2*siz[q[i].id]-n;\n\t\tint fa=f[d];\n\t\tif(!fa)cout<<\"-1\"<<endl,exit(0);\n\t\tsiz[fa]+=siz[q[i].id];\n\t\tans.push_back(make_pair(q[i].id,fa));\n\t\tg[fa].push_back(q[i].id);\n\t}\n\tdfs(q[n].id);\n\tif(tot==n&&flag){\n\t\tfor(auto x:ans){\n\t\t\tprintf(\"%d %d\\n\",x.first,x.second);\n\t\t}\n\t}\n\telse puts(\"-1\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#define Maxn 1000008 \nusing namespace std;\ntypedef long long ll;\n\nint n,cnt;\nll d;\nint son[Maxn];\nmap <ll,int> M;\n\nstruct node{\n\tint num;\n\tll val;\n}N[Maxn];\n\nbool cmp(node a,node b){\treturn a.val > b.val;}\n\nint U[Maxn],V[Maxn];\n\nint main()\n{\n\tmemset(son,0,sizeof(son));\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\tscanf(\"%lld\",&d);\n\t\tM[d] = i;\n\t\tN[i].num = i,N[i].val = d;\n\t}\n\tsort(N+1,N+1+n,cmp);\n\tmap<ll,int>::iterator iter;;\n\tfor(int i = 1;i < n;i ++)\n\t{\n\t\tint u = N[i].num;\n\t\tif((N[i].val - n + 2LL + (son[u] << 1)) < N[n].val) continue;\n\t\titer = M.find(N[i].val - n + 2 + (son[u] << 1));\n\t\tif(iter == M.end()) continue;\n\t\tint v = iter->second;\n\t\tson[v] += son[u]+1;\n\t\tU[cnt] = u,V[cnt++] = v;\n\t}\n//\tfor(int i = 1;i <= n;i ++) printf(\"son[N[%d].num] = %d\\n\",i,son[N[i].num]);\n\tif(cnt != n - 1) printf(\"-1\\n\");\n\telse\n\t\tif(son[N[n].num] == n - 1) \n\t\t\tfor(int i = 0;i < cnt;i ++)\n\t\t\t\tprintf(\"%d %d\\n\",U[i],V[i]);\n\t\telse printf(\"-1\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Konrad Paluszek,University of Warsaw(former XIV LO Staszic)\n//#STAY AT HOME\n#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n#define TIME (chrono::steady_clock::now().time_since_epoch().count())\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#define xfm(a,b)a##b\n#define xwb(a,b)xfm(a,b)\n#define _ xwb(nvj,__LINE__)\n#define __ xwb(kjy,__LINE__)\n#define ___ xwb(cjm,__LINE__)\n#define REP(i,n)for(urs(n)i=0;i<(n);++i)\n#define UNTIL(t)while(clock()<(t)*CLOCKS_PER_SEC)\n#define PER(r...)for(bool _=1;_||next_permutation(r);_=false)\n#define ALL(r)(r).begin(),(r).end()\n#define RALL(r)(r).rbegin(),(r).rend()\n#define FS(r)r.first,r.second\n#define SF(r)r.second,r.first\n#define M0(r) memset(r, 0, sizeof(r))\n#define sim template<class c\n#define ros return o\n#define rans return ans\n#define forbits(i,m)if(m)for(urs(m)i=ctz(m),i##nvj=m;i##nvj;i##nvj^=((urs(m))1<<i),i=ctz(i##nvj))\n#define fordbits(i,m)if(m)for(urs(m)i=8*sizeof(m)-clz(m)-1,i##nxd=m;i##nxd;i##nxd^=((urs(m))1<<i),i=8*sizeof(m)-clz(i##nxd)-1)\n#define ksets(t, m, k, n) for (t m = (((t)1 << (k)) - 1); m < ((t)1 << (n)); m = nux(m))\n#define urs(r...)typename decay<decltype(r)>::type\n#define hur(f,g,r)sim>int f(c a){if(sizeof(c)==16)return r;if(sizeof(c)==8)return g##ll(a);return g(a);}\n#define pwq(t,i) int clz(t x){return clz<int>(x)-i;}\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wconversion\"\nusing namespace __gnu_pbds;using namespace std;using ll=long long;using ld=long double;using ull=unsigned long long;using vi=vector<int>;using vll=vector<ll>;using pii=pair<int,int>;using pll=pair<ll,ll>;using vpii=vector<pii>;using spii=set<pii>;using mii=map<int,int>;using unt=unsigned int;sim>using min_queue=priority_queue<c,vector<c>,greater<c>>;sim,class b,class cmp=less<c> >using ordered_map=tree<c,b,cmp,rb_tree_tag,tree_order_statistics_node_update>;sim, class cmp=less<c>>using ordered_set = ordered_map<c,null_type,cmp>;hur(popc,__builtin_popcount,popc<ull>(a)+popc<ull>(a>>64))hur(ctz,__builtin_ctz,(ull)a?ctz<ull>(a):64+ctz<ull>(a>>64))hur(clz,__builtin_clz,a>>64?clz<ull>(a>>64):64+clz<ull>(a))pwq(short,16)pwq(uint16_t,16)pwq(char,24)pwq(int8_t,24)pwq(uint8_t,24)sim,class N>bool mini(c&o,const N&h){if(o>h)ros=h,1;return 0;}sim,class N>bool maxi(c&o,const N&h){if(o<h)ros=h,1;return 0;}sim,class n>using gyv=c;\n#if defined(LOCAL) // || defined(LOCAL2)\n#include </home/kjp/headers/debuglib.hpp>\n#else\n#define loc(...)\n#define onl(r...)r\n#define debug(...)\n#define print_stack(...)\n#define mark_stack(...)\n#define set_pre(...)\n#define reg_it(...)\n#define def_op(...) struct _{};\n#if !defined(LOCAL) && !defined(LOCAL2)\n#define exit my_exit\nvoid my_exit(int x) {fflush(stdout);_Exit(x);}\n#endif\n#endif\n#define next nexT\n#define prev preV\n#define tree trEE\n#define left lefT\n#define right righT\n#define div diV\n#define y1 y_1\n#define pow do not use cmath pow unless you know what you are doing\null mix(ull o){o+=0x9e3779b97f4a7c15;o=(o^(o>>30))*0xbf58476d1ce4e5b9;o=(o^(o>>27))*0x94d049bb133111eb;ros^(o>>31);}ull SALT=0x7a14a4b0881ebf9,tqu=0x7a14a4b0881ebf9;ull my_rand(){return tqu=mix(tqu);}void my_srand(ull x){SALT=tqu=x;}const int inf = 1023400000;const ll llinf=1234567890000000000ll;ll fix(ll o, ll m){o%=m;if(o<0)o+=m;ros;}\n#define rand my_rand\n#define srand my_srand\n#define random_shuffle(r...)random_shuffle(r,[](int _){return my_rand()%_;})\nsim>inline c nux(c m){if(!m)return numeric_limits<c>::max();c A=m&-m;c B=~((A-1)^m);c C=B&-B;c D=(C>>(1+ctz(A)))-1;return C|(m&~(C-1))|D;}__attribute__((no_sanitize_undefined))ll mul(ll a,ll b,ll m){ll q=(ll)(a*(ld)b/m);ll o=a*b-q*m;o%=m;if(o<0)o+=m;ros;}sim>void unq(c&x){x.resize(unique(ALL(x))-x.begin());}\n#pragma GCC diagnostic pop\n#if ((ULONG_MAX) != (UINT_MAX))\nnamespace std {template <> struct is_signed<__int128> : public true_type {};}\n#endif\nsim, class d> typename common_type<c,d>::type floor_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using floor_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b - (a % b < 0);}\nsim, class d> typename common_type<c,d>::type ceil_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using ceil_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b + (a % b > 0);}\nsim> struct REV {using value_type=typename c::value_type;c &x;using it=typename c::reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> struct CREV {using value_type=typename c::value_type;const c&x;using it=typename c::const_reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> REV<c> reversed(c&x) {return REV<c>{x};}sim> CREV<c> reversed(const c&x) {return CREV<c>{x};}\n#define done(r...) exit(0 * printf(r))\n#if defined(LOCAL) || defined(LOCAL2)\nvoid __tmi() {cerr << setprecision(6) << fixed << \"total time: \" << clock() / (ld)CLOCKS_PER_SEC << \"s\" << endl;}int _ = (atexit(__tmi), 0);\n#endif\n//#STAY AT HOME\nconst int nax = 1e5 + 44;\nvi graf[nax];\nint siz[nax];\nll d[nax];\nmap <ll, int> wh;\nvpii ans;\nvoid add_edge(int a, int b) {\n\tgraf[a].push_back(b);\n\tgraf[b].push_back(a);\n\tans.emplace_back(a + 1, b + 1);\n}\nvoid err() {\n\tdone(\"-1\\n\");\n}\nll su = 0;\nvoid dfs(int x, int y = -1, int d = 0) {\n\tfor (int v : graf[x]) if (v != y) dfs(v, x, d + 1);\n\tsu += d;\n}\nvoid solve() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tif (n % 2 == 0) err();\n\tREP(i, n) scanf(\"%lld\", d + i);\n\tREP(i, n) siz[i] = 1;\n\tvector <pair <ll, int> > ord(n);\n\tREP(i, n) ord[i] = {d[i], i};\n\tREP(i, n) wh[d[i]] = i;\n\tsort(RALL(ord));\n\tREP(ind, n - 1) {\n\t\tauto [v, i] = ord[ind];\n\t\tll oth = v - n + siz[i] * 2;\n\t\tauto it = wh.find(oth);\n\t\tif (it == wh.end() || it->second == i) err();\n\t\tadd_edge(i, it->second);\n\t\tsiz[it->second] += siz[i];\n\t}\n\tdfs(0);\n\tif (su != d[0]) err();\n\tfor (auto [x, y] : ans) printf(\"%d %d\\n\", x, y);\n}\nint main() {\n\t// unt seed = TIME; debug(imie(seed));srand(seed);\n\tint t = 1;\n\t// scanf(\"%d\", &t);\n\tREP(_, t) solve();\n\texit(0);\n}\n//#STAY AT HOME\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <iterator>\n\nusing lli=long long;\n\nint main(){\n  int N;\n  std::cin >> N;\n\n  std::vector<std::tuple<lli, lli>> Di_arr(N);\n  for(int i = 0; i < N; i++){\n    lli tmp;\n    std::cin >> tmp;\n    Di_arr[i] = std::make_tuple(tmp, i+1);\n  }\n\n  std::sort(Di_arr.begin(), Di_arr.end(), [](const std::tuple<lli, lli>& l, const std::tuple<lli, lli>& r){ return std::get<0>(l) > std::get<0>(r); });\n  std::vector<lli> D_arr(N), re_arr(N);\n  for(int i = 0; i < N; i++){\n    D_arr[i] = std::get<0>(Di_arr[i]);\n    re_arr[i] = std::get<1>(Di_arr[i]);\n  }\n\n  std::vector<std::tuple<lli, lli>> node_info(N, std::make_tuple(1, 0));\n\n  bool fail=false;\n  std::vector<std::tuple<lli, lli>> edges;\n  for(int i = 0; i < N-1; i++){\n    lli nnodes, length;\n    std::tie(nnodes, length) = node_info[i];\n    lli parent_d = D_arr[i]-(N-nnodes)+nnodes;\n    auto parent_it = std::lower_bound(D_arr.rbegin(), D_arr.rend(), parent_d);\n    if(parent_it == D_arr.rend() || *parent_it != parent_d){\n      fail=true;\n      break;\n    }\n    lli parent = std::distance(D_arr.begin(), parent_it.base()-1);\n    edges.push_back(std::make_tuple(i, parent));\n    std::get<0>(node_info[parent]) += nnodes;\n    std::get<1>(node_info[parent]) += length+nnodes;\n  }\n  if(std::get<1>(node_info[N-1]) != D_arr[N-1]) fail=true;\n\n  if(fail){\n    std::cout << -1 << std::endl;\n  }else{\n    for(auto&& it: edges){\n      std::cout << re_arr[std::get<0>(it)] << \" \" << re_arr[std::get<1>(it)] << \"\\n\";\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n,cnt,a[111111],id[111111],w[111111],u[111111],v[111111];\nbool vis[111111];\nbool cmp(int x,int y){return a[x]<a[y];}\nvoid add(int x,int y){u[++cnt]=x,v[cnt]=y;}\nsigned main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]),id[i]=i,w[i]=a[i];\n\tsort(id+1,id+n+1,cmp),sort(w+1,w+n+1);\n\tfor(int i=n;i>=1;i--)if(!vis[id[i]]){\n\t\tint k=id[i],siz=1;\n\t\twhile(1){\n\t\t\tvis[k]=1;\n\t\t\tint x=siz*2-n+a[k],pos=lower_bound(w+1,w+n+1,x)-w;\n\t\t\tif(w[pos]!=x)break;\n\t\t\tadd(id[pos],k);\n\t\t\tif(vis[id[pos]]||pos==1)break;\n\t\t\tk=id[pos],siz++;\n\t\t}\n\t}\n\tif(cnt!=n-1){printf(\"-1\");return 0;}\n\tfor(int i=1;i<=cnt;i++)printf(\"%d %d\\n\",u[i],v[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 1e5 + 5;\nll n;\nll d[MAXN], sum;\nvector< ll > adj[MAXN];\nmap< ll , ll > mp;\nint h[MAXN], sz[MAXN];\nvoid dfs(int u){\n\tsum += h[u];\n\tfor(int i = 0; i < adj[u].size(); i++){\n\t\tll v = adj[u][i];\n\t\th[v] = h[u] + 1;\n\t\tdfs(v);\n\t}\n\t\n\treturn;\n}\nint main(){\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin >> n;\n\tfor(int i = 0; i < n; i ++) cin >> d[i], mp[d[i]] = (ll)i;\n\tfor( int i = 0; i < MAXN; i ++) sz[i] = 1LL;\n\tsort(d, d + n, greater<ll>());\n\tfor(int i = 0; i < n - 1; i ++){\n\t\tll ind = mp[d[i]];\n\t\tll s2 = d[i] + 2LL*sz[ind] - n;\n\t\tif( mp.count(s2)){\n\t\t\tif( s2 == d[i]) return cout << -1 << endl, 0;\n\t\t\tll indpar = mp[s2];\n\t\t\tsz[indpar] += sz[ind], adj[indpar].push_back(ind);\n\t\t}\n\t\telse return cout << -1 << endl, 0;\n\t}\n\th[mp[d[n - 1]]] = 0;\n\tdfs(mp[d[n - 1]]);\n\tif( sum != d[n - 1]) return cout << -1 << endl, 0;\n\tfor(int i = 0; i < n; i ++){\n\t\tfor( int j = 0; j < adj[i].size(); j ++){\n\t\t\tcout << i + 1LL << \" \" << adj[i][j] + 1LL << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> pii;\n\npii inp[100005];\nint siz[100005];\nvector<pii> ans;\nint main() {\n\tint N; scanf(\"%d\", &N);\n\tfor (int i = 1; i <= N; i++) {\n\t\tll x; scanf(\"%lld\", &x);\n\t\tinp[i] = {x, i};\n\t\tsiz[i] = 1;\n\t}\n\tsort(inp + 1, inp + N + 1);\n\tfor (int i = N; i >= 2; i--) {\n\t\tint cur, id;\n\t\ttie(cur, id) = inp[i];\n\t\tint n = N - siz[id];\n\t\tll del = n - siz[id];\n\t\tauto it = *lower_bound(inp + 1, inp + N + 1, pii(cur - del, 0));\n\t\tif (it.first != cur - del || !del) return !printf(\"-1\");\n\t\tsiz[it.second] += siz[id];\n\t\tans.push_back({id, it.second});\n\t}\n\tfor (pii x : ans) {\n\t\tprintf(\"%lld %d\\n\", x.first, x.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=200005;\nint n,size[N],st[N],to[N];\nstruct note{\n\tlong long dis;\n\tint x;\n}d[N];\nbool cmp(note x,note y){\n\treturn x.dis>y.dis;\n}\nusing std::map;\nmap<long long,int> m;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) {\n\t\tscanf(\"%lld\",&d[i].dis);\n\t\td[i].x=i;\n\t\tm[d[i].dis]=i;\n\t}\n\tstd::sort(d+1,d+n+1,cmp);\n\tfor (int i=1;i<=n;i++) size[i]=1;\n\tfor (int i=1;i<n;i++){\n\t\tlong long dis=d[i].dis;\n\t\tint x=d[i].x;\n\t\tlong long t=dis-abs(n-2*size[x]);\n\t\tint fa=m.find(t)->second;\n\t\tif (fa==x || !fa){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsize[fa]+=size[x];\n\t\tst[i]=x,to[i]=fa;\n\t}\n\tfor (int i=1;i<n;i++) printf(\"%d %d\\n\",st[i],to[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<cmath>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define N 100010\n#define int long long\n#define debug cout<<__LINE__<<\" \"<<__FUNCTION__<<\"\\n\"\n\ninline int read(){\n    int x=0,y=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')y=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}\n    return x*y;\n}\nvoid put(int x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>=10) put(x/10);\n    putchar((x%10)+48);\n}\nint n,a[N],id[N],siz[N],fa[N];\ninline int find(int x){\n\treturn x==fa[x]?x:fa[x]=find(fa[x]);\n}\ninline int cmp(const int&A,const int&B){\n\treturn a[A]<a[B];\n}\nint cnt;\nstruct Line{\n\tint l,r;\n}l[N];\nsigned main(){\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tn=read();\n\tfor(int i=1;i<=n;i++){\n\t\ta[i]=read();id[i]=fa[i]=i;siz[i]=1;\n\t}\n\tsort(id+1,id+n+1,cmp);sort(a+1,a+n+1);\n\tint flag=0;\n\tfor(int i=n,pos,fx;i>=1;i--){\n\t\tfx=find(i);\n\t\tpos=lower_bound(a+1,a+n+1,a[i]-n+2*siz[i])-a;\n\t\twhile(fx==find(pos)) ++pos;\n//\t\tif(pos==2) cout<<i<<\" \"<<siz[i]<<\" \"<<id[pos]<<\"\\n\";\n\t\tif(a[pos]!=a[i]-n+2*siz[i]){\n\t\t\tif(!flag){\n\t\t\t\tflag=i;\n\t\t\t\tcontinue;\n\t\t\t}\n//\t\t\tcerr<<i<<\" \"<<a[i]<<\" \"<<a[i]-n+2*siz[i]<<pos<<\" \"<<a[pos]<<\"\\n\";\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t\tsiz[pos]+=siz[i];\n\t\tl[++cnt].l=id[pos];l[cnt].r=id[i];\n\t\tfa[fx]=find(pos);\n\t}\n\tfor(int i=1;i<=cnt;i++) cout<<l[i].l<<\" \"<<l[i].r<<\"\\n\";\n//\tfclose(stdin);\n//\tfclose(stdout);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int maxn=1e6+100;\nint n,v2[maxn],fa[maxn];\nLL v[maxn],sz[maxn],ds[maxn];\nmap<LL,int> tp;\nbool cmp(int a,int b){return v[a]<v[b];}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&v[i]),tp[v[i]]=i,v2[i]=i,sz[i]=1;\n\tsort(v2+1,v2+n+1,cmp);\n\tfor(int i=n;i>1;i--){\n\t\tlong long tp2=v[v2[i]]-n+sz[v2[i]]*2;\n\t\tif(!tp[tp2]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint sb=tp[tp2];\n\t\tds[sb]+=ds[v2[i]]+sz[v2[i]];\n\t\tsz[sb]+=sz[v2[i]];\n\t\tfa[v2[i]]=sb;\n\t}\n\tif(ds[v2[1]]!=v[v2[1]]) puts(\"-1\");\n\telse for(int i=1;i<=n;i++) if(fa[i]) printf(\"%d %d\\n\",i,fa[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\nint main()\n{\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin>>n;\n\tvector<pair<long long,int>>e;\n\tmap<long long,int>ret;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tlong long x;\n\t\tcin>>x;\n\t\tret[x]=i;\n\t\te.push_back({x,i});\n\t}\n\tsort(e.rbegin(),e.rend());\n\tlong long x=e.back().first;\n\tvector<int>sz(n,1);\n\tvector<long long>dp(n,0);\n\tvector<pair<int,int>>ans;\n\tfor(auto c:e)\n\t{\n\t\tif(c.first!=x)\n\t\t{\n\t\t\tif(sz[c.second]*2>=n)\n\t\t\t{\n\t\t\t\tcout<<-1<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tlong long need=c.first-(n-2*sz[c.second]);\n\t\t\tif(!ret.count(need))\n\t\t\t{\n\t\t\t\tcout<<-1<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint par=ret[need];\n\t\t\tdp[par]+=dp[c.second]+sz[c.second];\n\t\t\tsz[par]+=sz[c.second];\n\t\t\tans.push_back({c.second+1,par+1}); \n\t\t}\n\t}\n\tif(dp[e.back().second]!=x)\n\t{\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tfor(auto c:ans)\n\t\tcout<<c.first<<' '<<c.second<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int N=100100;\n\nmap<LL,int> qaq;\n\nvoid DSY(){\n\tputs(\"-1\");\n\texit(0);\n}\n\nint sz[N];\n\nvector<int> es[N];\nLL dd[N]={0};\nLL d[N];\nvoid dsy(int x,int fa=-1){\n\tfor(vector<int>::iterator it=es[x].begin();it!=es[x].end();++it){\n\t\tif(*it==fa)continue;\n\t\tdsy(*it,x);\n\t\tdd[x]+=dd[*it]+sz[*it];\n\t}\n}\n\nvector<pair<int,int> > ess;\nvoid ae(int u,int v){\n\tif(u>v)swap(u,v);\n\tess.push_back(pair<int,int>(u,v));\n\tes[u].push_back(v);\n\tes[v].push_back(u);\n}\nvoid print(){\n\tsort(ess.begin(),ess.end());\n\tfor(vector<pair<int,int> >::iterator it=ess.begin();it!=ess.end();++it){\n\t\tprintf(\"%d %d\\n\",it->first,it->second);\n\t}\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&d[i]);\n\t\tqaq[d[i]]=i;\n\t\tsz[i]=1;\n\t}\n\tint cnt=n;\n\tfor(map<LL,int>::reverse_iterator it=qaq.rbegin();it!=qaq.rend();++it){\n\t\tint x=it->second;\n\t\tLL ddd=it->first;\n\t\tif(sz[x]*2==n)DSY();\n\t\tLL nd=ddd+sz[x]-(n-sz[x]);\n\t\tif(cnt==1){\n\t\t\tdsy(x);\n\t\t\tif(dd[x]!=d[x])DSY();\n\t\t\tbreak;\n\t\t}\n\t\tif(!qaq.count(nd)){\n\t\t\tDSY();\n\t\t}else{\n\t\t\tint v=qaq[nd];\n\t\t\tae(x,v);\n\t\t\tsz[v]+=sz[x];\n\t\t}\n\t\tcnt--;\n\t}\n\tprint();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cassert>\n#define ll long long\nusing namespace std;\ninline ll read(){\n\tll re=0,flag=1;char ch=getchar();\n\twhile(ch>'9'||ch<'0'){\n\t\tif(ch=='-') flag=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();\n\treturn re*flag;\n}\nll n,cnt1[100010],cnt2[100010];\nint main(){\n\tn=read();ll i,t1;\n\tfor(i=1;i<=n;i++){\n\t\tt1=read();\n\t\tif(i&1) cnt1[t1]++;\n\t\telse cnt2[t1]++;\n\t}\n\tll maxn=0,pos;\n\tfor(i=1;i<=100000;i++){\n\t\tif(maxn<=cnt1[i]) maxn=cnt1[i],pos=i;\n\t}\n\tll ans=n/2-maxn,ppos=pos,mm=maxn;\n\tmaxn=0;pos=0;\n\tfor(i=1;i<=100000;i++){\n\t\tif(maxn<=cnt2[i]) maxn=cnt2[i],pos=i;\n\t}\n\tif(pos==ppos){\n//\t\t\tcout<<\"c\\n\";\n\t\tll ans1=0,ans2=0,mmm=maxn;\n//\t\tif(mm>maxn){\n\t\t\t//change 2\n//\t\t\tcout<<\"c2\\n\";\n\t\t\tmaxn=0;pos=0;\n\t\t\tfor(i=1;i<=100000;i++){\n\t\t\t\tif(i!=ppos&&maxn<cnt2[i]) maxn=cnt2[i];\n\t\t\t}\n\t\t\tans+=n/2-maxn;\n\t\t\tans1=ans;\n//\t\t}\n//\t\telse{\n\t\t\t// change 1\n\t\t\tans=n/2-mmm;\n\t\t\tmaxn=0;pos=0;\n\t\t\tfor(i=1;i<=100000;i++){\n\t\t\t\tif(i!=ppos&&maxn<cnt1[i]) maxn=cnt1[i];\n\t\t\t}\n//\t\t\tcout<<\"c1 \"<<maxn<<'\\n';\n\t\t\tans+=n/2-maxn; \n\t\t\tans2=ans;\n//\t\t}\n\t\tans=min(ans1,ans2);\n\t}\n\telse ans+=n/2-maxn;\n\tcout<<ans<<'\\n';\n} "
  },
  {
    "language": "C++",
    "code": "\n// Problem : F - Distance Sums\n// Contest : AtCoder Regular Contest 103\n// URL : https://atcoder.jp/contests/arc103/tasks/arc103_d\n// Memory Limit : 1024 MB\n// Time Limit : 2000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\n#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\n#define cerr if(1)cerr\n#define size(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n#define temptts template <class T, class... Ts>\n\nconst int N = 1e6 + 1, mod = 1e9 + 7, inf = 2e9;\n\nstruct pp {\n\tll v;\n\tint i;\n\tbool operator < (const pp &o) const {\n\t\treturn v < o.v;\n\t}\n} d[N];\n\nmap<ll, int> id;\nint n, sz[N];\nvector<pair<int, int>> ans;\n\nint main() { cin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> d[i].v;\n\t\td[i].i = i;\n\t}\n\tsort(d + 1, d + n + 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tid[d[i].v] = i;\n\t}\n\tfor (int i = n; i >= 2; i--) {\n\t\tsz[i]++;\n\t\tll j = d[i].v - n + 2 * sz[i];\n\t\tif (!id[j]) {\n\t\t\treturn cout << -1, 0;\n\t\t}\n\t\tans.push_back({d[id[j]].i, d[i].i});\n\t\tsz[id[j]] += sz[i];\n\t}\n\tfor (auto& x : ans) {\n\t\tcout << x.first << ' ' << x.second << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define max(a,b) (((a)>(b))?a:b)\n#define min(a,b) (((a)<(b))?a:b)\nusing namespace std;\ntemplate<typename T>void read(T &x){\n\tx=0;int f=1;\n\tchar c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if (c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-48;\n\tx*=f;\n}\nint n,fa[100010],sz[100010];\nstruct ha{int d,id;}a[100010];\nbool cmp(ha x,ha y){\n\treturn x.d>y.d;\t\n}\nint main(){\n\tread(n);\n\tfor(int i=1;i<=n;++i)\n\t\tread(a[i].d),a[i].id=i;\n\tsort(a+1,a+1+n,cmp);\n\tfor(int i=1;i<=n;++i)\n\t\tsz[i]=1;\n\tfor(int i=1;i<n;++i){\n\t\tint xx=a[i].d-(n-sz[a[i].id])+sz[a[i].id];\n\t\tint l=i+1,r=n;\n\t\twhile(l<=r){\n\t\t\tint mid=(l+r)/2;\n\t\t\tif(a[mid].d==xx) {fa[a[i].id]=a[mid].id,sz[a[mid].id]+=sz[a[i].id];break;}\n\t\t\telse if(a[mid].d<xx) r=mid-1;\n\t\t\telse l=mid+1;\n\t\t}\n\t\tif(!fa[a[i].id]) {puts(\"-1\");return 0;}\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tif(fa[i]) printf(\"%d %d\\n\",i,fa[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int maxn=1e6+100;\nint n,v2[maxn],fa[maxn];\nLL v[maxn],sz[maxn],ds[maxn];\nmap<LL,int> tp;\nbool cmp(int a,int b){return v[a]<v[b];}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&v[i]),tp[v[i]]=i,v2[i]=i,sz[i]=1;\n\tsort(v2+1,v2+n+1,cmp);\n\tfor(int i=n;i>1;i--){\n\t\tlong long tp2=v[v2[i]]-n+sz[v2[i]]*2;\n\t\tif(!tp[tp2]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint sb=tp[tp2];\n\t\tds[sb]+=ds[v2[i]]+sz[v2[i]];\n\t\tsz[sb]+=sz[v2[i]];\n\t\tfa[v2[i]]=sb;\n\t}\n\tif(ds[v2[1]]!=v[v2[1]]) puts(\"-1\");\n\telse for(int i=1;i<=n;i++) if(fa[i]) printf(\"%d %d\\n\",i,fa[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 1e5 + 10;\n\nint sz[maxn], tot;\nll d[maxn], dis[maxn];\nmap<ll, int> mp;\nvector<int> edge[maxn];\nint ans[maxn][2];\n\nvoid dfs(int u, int pre)\n{\n    for(auto v : edge[u])\n    {\n        if(v == pre) continue;\n        dis[v] = dis[u] + 1;\n        ans[tot][0] = u, ans[tot++][1] = v;\n        dfs(v, u);\n    }\n}\n\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i ++)\n    {\n        scanf(\"%lld\", &d[i]);\n        mp[d[i]] = i, sz[i] = 1;\n    }\n    int cnt = 0;\n    for(auto it = mp.rbegin(); it != mp.rend(); it ++)\n    {\n        int v = it->second, u = mp[it->first + 2 * sz[v] - n];\n        if(!u || u == v) return puts(\"-1\"), 0;\n        edge[u].push_back(v);\n        edge[v].push_back(u);\n        sz[u] += sz[v];\n        if(++cnt == n - 1) break;\n    }\n    int rt = mp.begin()->second;\n    dfs(rt, 0);\n    if(accumulate(dis + 1, dis + n + 1, 0ll) != d[rt]) return puts(\"-1\"), 0;\n    for(int i = 0; i < tot; i ++)\n        printf(\"%d %d\\n\", ans[i][0], ans[i][1]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define ln                '\\n'\n#define all(dat)           dat.begin(), dat.end()\n#define loop(i, to)        for (int i = 0; i < to; ++i)\n#define cont(i, to)        for (int i = 1; i <= to; ++i)\n#define circ(i, fr, to)    for (int i = fr; i <= to; ++i)\n#define foreach(i, dat)    for (__typeof(dat.begin()) i = dat.begin(); i != dat.end(); ++i)\n\ntypedef long long          num;\n\nusing namespace std;\n\nconst int nsz = 1e5;\nint n, rt, siz[nsz + 5];\nnum w[nsz + 5];\nmap<num, int> id;\nvector<int> g[nsz + 5];\nvector<pair<int, int>> ans;\n\nnum inline cmp(num a, num b) {\n    return a > b;\n}\n\nint calc(int u = rt, int dep = 0) {\n    int res = dep;\n    for (int v : g[u]) {\n        res += calc(v, dep + 1);\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> n;\n    rt = n;\n    cont (i, n) {\n        cin >> w[i];\n    }\n    fill(siz, siz + sizeof(siz) / sizeof(int), 1);\n    sort(w + 1, w + n + 1, cmp);\n    cont (i, n) {\n        id[w[i]] = i;\n    }\n    cout << ln;\n    cont (u, n) {\n        if (u == rt)  continue;\n        int v = id[w[u] - n + 2 * siz[u]];\n        if (!v) {\n            cout << -1 << ln;\n            return 0;\n        }\n        siz[v] += siz[u];\n        g[v].push_back(u);\n        ans.push_back({u, v});\n    }\n    if (calc() != w[n]) {\n        cout << -1 << ln;\n        return 0;\n    }\n    for (pair<int, int> p : ans) {\n        cout << p.first << ' ' << p.second << ln;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef pair<ll,ll> P;\nlong long int INF = 1e18;\ndouble Pi = 3.1415926535897932384626;\nlong long int mod = 1000000007;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"RULD\";\n//↓,→,↑,←\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,a,b) for(i=a;i<=b;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\n\n\n\nll i,j,k,ii,jj;\nll n,m,num;\nll a,b,c,e,f,g,h;\nll x[800005],y[800005],z[900005],w[500005];\nll d[800005],dp[500005];\nll no[500005];\nchar s[500005];\nll len[500];\nll vnum = 0,sum;\nbool dame;\nbool check[500005];\n\n\nvoid unite(ll a,ll b){\n    x[vnum] = a;\n    y[vnum] = b;\n    G[a].pb(b);\n    G[b].pb(a);\n    vnum++;\n}\n\nvoid dfs(ll v,ll dpn){\n    if(check[v]){\n        return;\n    }else{\n        sum += dpn;\n        check[v] = true;\n        for(int i=0;i<G[v].size();i++){\n            dfs(G[v][i],dpn + 1);\n        }\n    }\n}\nint main(){\n    cin>>n;\n    for(i=0;i<n;i++){\n        cin>>d[i];\n        z[i] = d[i];\n        no[i] = d[i];\n    }\n    sort(d,d+n);\n    for(i=0;i<n;i++){\n        z[i] = (lb(d,d+n,z[i]) - d) * 100000 + i;\n    }\n    sort(z,z+n);\n    //reverse(d,d+n);\n    for(i=n-1;i>=1;i--){\n        //大きい数字から見て行くよ\n        dp[i]++;\n        num = d[i] - n + 2* dp[i];\n        a = lb(d,d+n,num) - lb(d,d+n,-1);\n        if(d[a] != num || a >= i){\n            //p(\"dame\");\n            //p(a);\n            //p(num);\n            dame = true;\n            break;\n        }else{\n            dp[a] = dp[i];\n            unite(a+1,i+1);\n        }\n    }\n    sum = 0;\n    dfs(1,0);\n    if(sum != d[0]){\n        dame = true;\n    }\n    if(dame){\n        p(-1);\n        return 0;\n    }else{\n        for(i=0;i<vnum;i++){\n            pe(z[x[i]-1]%100000 + 1);p(z[y[i]-1]%100000 + 1);\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#include <queue>\n#include <vector>\n#define PB push_back\n#define MP make_pair\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=1e5+10;\nstruct node {\n\tint id; ll d;\n\tnode(int id=0,ll d=0): id(id),d(d) {}\n\tfriend bool operator <(node A,node B) { return A.d<B.d; }\n};\npriority_queue<node> que;\nmap<ll,int> mp;\nint n,sz[N];\nll d[N];\nvector< pair<int,int> > E;\nint main() {\n\trd(n);\n\tfor(int i=1;i<=n;++i) {\n\t\trd(d[i]),mp[d[i]]=i;\n\t\tque.push(node(i,d[i]));\n\t\tsz[i]=1;\n\t}\n\twhile(que.size()>1) {\n\t\tint u=que.top().id; que.pop();\n\t\tmp.erase(d[u]);\n\t\tll t=d[u]-(n-sz[u]*2ll);\n\t\tif(!mp.count(t)) {\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint f=mp[t];\n\t\tE.PB(MP(f,u));\n\t\tsz[f]+=sz[u];\n\t}\n\tfor(int i=0;i<E.size();++i) printf(\"%d %d\\n\",E[i].first,E[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXn = 1e5 + 10;\ntypedef pair<long long, int> pii;\npii ar[MAXn];\nlong long n, sz[MAXn], root, disroot, d[MAXn], hp3[MAXn];\nvector<int> vec[MAXn];\nvector<pii> ans;\n\nbool cmp(pii p1, pii p2) {\n\treturn p1.first > p2.first;\n}\n\nlong long dfs1(int v, int  par) {\n\tlong long res = 0;\n\tfor (int i = 0; i < vec[v].size(); i++)\n\t\tif (vec[v][i] != par) {\n\t\t\tres += dfs1(vec[v][i], v) + hp3[vec[v][i]];\n\t\t\thp3[v] += hp3[vec[v][i]];\n\t\t}\n\thp3[v]++;\n\treturn res;\n\t\n}\n\nvoid dfs2(int v, int par, int sth) {\n\tif (sth != d[v]) {\n\t\tcout << -1 << sth;\n\t\texit(0);\n\t}\n\tfor (int i = 0; i < vec[v].size(); i++) {\n\t\tif (vec[v][i] != par) {\n\t\t\tdfs2(vec[v][i], v, sth - (hp3[vec[v][i]]) + (hp3[0] - hp3[vec[v][i]]));\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}\nint main() {\n\tcin >> n;\n\tfill_n(sz, MAXn, 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tint di;\n\t\tcin >> di;\n\t\td[i] = di;\n\t\tar[i].first = di;\n\t\tar[i].second = i;\n\t}\n\tsort(ar, ar + n);\n\tfor (int i = n - 1; i >= 1; i--) {\n\t\tint hp = ar[i].first - n;\n\t\thp += 2 * sz[i];\n\t\tint hp2 = lower_bound(ar, ar + n, pii(hp, -1)) - ar;\n\t\tif (ar[hp2].first != hp)\n\t\t\treturn cout << -1,0;\n\t\tsz[hp2]+= sz[i];\n\t\tvec[ar[hp2].second].push_back(ar[i].second);\n\t\tvec[ar[i].second].push_back(ar[hp2].second);\n\t\tans.push_back(pii(ar[i].second, ar[hp2].second));\n\t}\n\tdisroot = dfs1(0, -1);\n\tdfs2(0, -1, disroot);\n\tfor (int i = 0; i < ans.size(); i++)\n\t\tcout << ans[i].first + 1<< ' ' << ans[i].second + 1<< endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n\nconst int N = 100100;\nconst long long mod = 1e9 + 7;\n\nusing namespace std;\n\nint n;\nint p[N];\nint s[N];\nint f[N];\nlong long d[N];\nvector < int > v[N];\npair < long long, int > a[N];\n\nint get(int x){ return f[x] == x ? x : f[x] = get(f[x]); }\n\nvoid dfs(int x, int p, int dip = 0)\n{\n        d[1] += dip;\n        s[x] = 1;\n        for(int y: v[x]) if(y != p){\n                dfs(y, x, dip + 1);\n                s[x] += s[y];\n        }\n}\n\nvoid trace(int x, int p)\n{\n        for(int y: v[x]) if(y != p){\n                d[y] = d[x] + (n - s[y]) - s[y];\n                trace(y, x);\n        }\n}\n\nint main()\n{\n        ios_base::sync_with_stdio(false);\n\n        //freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n\n        cin >> n;\n        for(int i = 1; i <= n; i++){\n                cin >> a[i].fi;\n                a[i].se = i;\n                s[i] = 1;\n                f[i] = i;\n        }\n        sort(a + 1, a + n + 1);\n        map < long long, int > id;\n        for(int i = 1; i <= n; i++){\n                id[a[i].fi] = i;\n        }\n\n        for(int i = n; i > 1; i--){\n                long long dp = a[i].fi;\n                dp = dp + s[i] - (n - s[i]);\n                if(id.find(dp) == id.end() || dp > a[i].fi){\n                        cout << -1 << \"\\n\";\n                        return 0;\n                }\n                p[i] = id[dp];\n                s[p[i]] += s[i];\n\n                int px = get(i), py = get(p[i]);\n                if(px == py){\n                        cout << -1 << \"\\n\";\n                        return 0;\n                }\n                f[px] = py;\n        }\n        if(s[1] != n){\n                cout << -1 << \"\\n\";\n                return 0;\n        }\n        for(int i = 2; i <= n; i++){\n                int x = a[i].se;\n                int y = a[p[i]].se;\n                v[x].push_back(y);\n                v[y].push_back(x);\n        }\n        dfs(1, 1);\n        trace(1, 1);\n        for(int i = 1; i <= n; i++){\n                if(d[a[i].se] != a[i].fi){\n                        cout << -1 << \"\\n\";\n                        return 0;\n                }\n        }\n        for(int i = 2; i <= n; i++){\n                int x = a[i].se;\n                int y = a[p[i]].se;\n                cout << x << \" \" << y << \"\\n\";\n        }\n}\n"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define int ll\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nint const N = 1e5 + 20 ;\nint n , d[N] , sz[N] ;\nmap <int , int> mp ;\nvector <pii> edges ;\n\nvoid err () {\n\tcout << -1 << '\\n' ;\n\texit(0) ;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tcin >> n ;\n\n\tfor (int i = 0 ; i < n ; i ++) cin >> d[i] , mp[d[i]] = i , sz[i] = 1 ;\n\n\tsort(d , d + n , greater<int>()) ;\n\n\tfor (int i = 0 ; i < n - 1 ; i ++) {\n\t\tint v = mp[d[i]] ;\n\t\tint k = d[i] - n + 2 * sz[v] ;\n\n\t\tif (k >= d[i] || !mp.count(k)) err() ;\n\n\t\tint p = mp[k] ;\n\n\t\tsz[p] += sz[v] ;\n\t\tedges.push_back({p , v}) ;\n\t}\n\n\tfor (pii p : edges) cout << p.F + 1 << ' ' << p.S + 1 << '\\n' ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep3(i,a,b) for(int i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\n#define MAX_V 400010\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\ntemplate<typename A, size_t NNN, typename T>\nvoid Fill(A (&array)[NNN], const T &val){\n    fill( (T*)array, (T*)(array+NNN), val );\n}\n#define N 100100\n#define INF 1e9+7\nll MOD=1e9+7;\n\nll n;\nstruct node{\n    ll d;int id;\n};\nnode a[N];\nll s[N];\nmain(){\n    n=lin();\n    map<ll,int> m;\n    rep(i,n){\n        a[i]=node{lin(),i+1};\n        m[a[i].d]=a[i].id;\n    }\n    sort(a,a+n,[](node a,node b){\n        return a.d>b.d;\n    });\n    struct edge{\n        int from,to;\n        void print(){\n            printf(\"%d %d\\n\",from,to);\n        }\n    };\n    vector<edge> ans;\n    rep(i,n-1){\n        ll now=a[i].d;\n        ll t=s[a[i].id];\n        now-=n-(2+t*2);\n        cout<<now<<\" \"<<a[i].id<<endl;\n        if(!m[now]){\n            cout<<-1;return 0;\n        }\n        s[m[now]]+=t+1;\n        ans.pb(edge{a[i].id,m[now]});\n    }\n        for(auto e:ans){\n            e.print();\n        }\n    return 0;\n}   \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100000\n#define mp make_pair\n#define X first\n#define Y second\n#define pb push_back\nint n;\nint dsum[N+1],sz[N+1];\nvector<int> nei[N+1];\nint dfs(int x=1,int dep=0,int fa=0){\n//\tcout<<x<<\" visiting\\n\";\n\tint res=dep;\n\tfor(int i=0;i<nei[x].size();i++){\n\t\tint y=nei[x][i];\n\t\tif(y!=fa)res+=dfs(y,dep+1,x);\n\t}\n\treturn res;\n}\npair<int,int> pc[N+1];int oid[N+1];\nvector<pair<int,int> > ans;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",dsum+i),pc[i]=mp(dsum[i],i);\n\tsort(dsum+1,dsum+n+1);sort(pc+1,pc+n+1);\n\tfor(int i=1;i<=n;i++)oid[i]=pc[i].Y;\n\tfill(sz+1,sz+n+1,1);\n\tfor(int i=n;i>=2;i--){\n\t\tint fadsum=dsum[i]+2*sz[i]-n;\n\t\tint fd=lower_bound(dsum+1,dsum+i,fadsum)-dsum;\n\t\tif(dsum[fd]!=fadsum)return puts(\"-1\"),0;\n\t\tsz[fd]+=sz[i];\n\t\tans.pb(mp(fd,i));\n\t\tnei[fd].pb(i);nei[i].pb(fd);\n\t}\n//\tfor(int i=1;i<=n;i++){for(int j=0;j<nei[i].size();j++)cout<<nei[i][j]<<\" \";puts(\"\");}\n\tif(dfs()!=dsum[1])return puts(\"-1\"),0;\n\tfor(int i=0;i<ans.size();i++)printf(\"%d %d\\n\",oid[ans[i].X],oid[ans[i].Y]);\n\treturn 0;\n}\n/*1\n7\n10\n15\n13\n18\n11\n14\n19\n*/\n/*2\n2\n1\n2\n*/\n/*3\n15\n57\n62\n47\n45\n42\n74\n90\n75\n54\n50\n66\n63\n77\n87\n51\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 2e5 + 10;\n\nint N, rnk[MAX_N], siz[MAX_N], pa[MAX_N], depth[MAX_N];\nll D[MAX_N];\nmap<ll, int> mp;\n\nint main() {\n    scanf(\"%d\", &N);\n    for (int i = 1; i <= N; i++) scanf(\"%lld\", &D[i]), mp[D[i]] = i;\n    for (int i = 1; i <= N; i++) rnk[i] = i, siz[i] = 1;\n    sort(rnk + 1, rnk + N + 1, [](int a, int b) { return D[a] > D[b]; });\n    for (int i = 1; i < N; i++) {\n        int x = rnk[i];\n        ll pd = D[x] + 2 * siz[x] - N;\n        if (siz[x] * 2 != N && mp.count(pd)) {\n            pa[x] = mp[pd];\n            siz[pa[x]] += siz[x];\n        } else {\n            printf(\"-1\\n\");\n            return 0;\n        }\n    }\n    int sum = 0;\n    for (int i = N - 1; i; i--) {\n        int x = rnk[i];\n        depth[x] = depth[pa[x]] + 1;\n        sum += depth[x];\n    }\n    if (sum != D[rnk[N]]) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n    for (int i = 1; i < N; i++) {\n        int x = rnk[i];\n        printf(\"%d %d\\n\", x, pa[x]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid ensure(bool exp) {\n    if (!exp) {\n        cout << -1 << endl;\n        exit(0);\n    }\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<long long> d(n);\n    map<long long, int> ver;\n    for (int i = 0; i < n; ++i) {\n        cin >> d[i];\n        ver[d[i]] = i;\n    }\n    vector<int> p(n);\n    iota(p.begin(), p.end(), 0);\n    sort(p.begin(), p.end(), [&](int i, int j) {\n        return d[i] < d[j];\n    });\n    vector<int> sz(n, 1), parent(n, -1);\n    vector<long long> f(n);\n    for (int i = n - 1; i >= 1; --i) {\n        int u = p[i];\n        long long dp = d[u] - n + 2 * sz[u];\n        ensure(dp < d[u]);\n        ensure(ver.count(dp) > 0);\n        parent[u] = ver[dp];\n        sz[parent[u]] += sz[u];\n        f[parent[u]] += f[u] + sz[u];\n    }\n    ensure(f[p[0]] == d[p[0]]);\n    for (int i = 1; i < n; ++i)\n        cout << parent[p[i]] + 1 << \" \" << p[i] + 1 << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nclock_t t=clock();\nnamespace my_std{\n\tusing namespace std;\n\t#define pii pair<int,int>\n\t#define pli pair<ll,int>\n\t#define fir first\n\t#define sec second\n\t#define MP make_pair\n\t#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n\t#define drep(i,x,y) for (int i=(x);i>=(y);i--)\n\t#define go(x) for (int i=head[x];i;i=edge[i].nxt)\n\t#define templ template<typename T>\n\t#define sz 101010\n\ttypedef long long ll;\n\ttypedef double db;\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ttempl inline T rnd(T l,T r) {return uniform_int_distribution<T>(l,r)(rng);}\n\ttempl inline bool chkmax(T &x,T y){return x<y?x=y,1:0;}\n\ttempl inline bool chkmin(T &x,T y){return x>y?x=y,1:0;}\n\ttempl inline void read(T& t)\n\t{\n\t\tt=0;char f=0,ch=getchar();double d=0.1;\n\t\twhile(ch>'9'||ch<'0') f|=(ch=='-'),ch=getchar();\n\t\twhile(ch<='9'&&ch>='0') t=t*10+ch-48,ch=getchar();\n\t\tif(ch=='.'){ch=getchar();while(ch<='9'&&ch>='0') t+=d*(ch^48),d*=0.1,ch=getchar();}\n\t\tt=(f?-t:t);\n\t}\n\ttemplate<typename T,typename... Args>inline void read(T& t,Args&... args){read(t); read(args...);}\n\tchar __sr[1<<21],__z[20];int __C=-1,__zz=0;\n\tinline void Ot(){fwrite(__sr,1,__C+1,stdout),__C=-1;}\n\tinline void print(register int x)\n\t{\n\t\tif(__C>1<<20)Ot();if(x<0)__sr[++__C]='-',x=-x;\n\t\twhile(__z[++__zz]=x%10+48,x/=10);\n\t\twhile(__sr[++__C]=__z[__zz],--__zz);__sr[++__C]='\\n';\n\t}\n\tvoid file()\n\t{\n\t\t#ifdef NTFOrz\n\t\tfreopen(\"a.in\",\"r\",stdin);\n\t\t#endif\n\t}\n\tinline void chktime()\n\t{\n\t\t#ifdef NTFOrz\n\t\tcout<<(clock()-t)/1000.0<<'\\n';\n\t\t#endif\n\t}\n\t#ifdef mod\n\tll ksm(ll x,int y){ll ret=1;for (;y;y>>=1,x=x*x%mod) if (y&1) ret=ret*x%mod;return ret;}\n\tll inv(ll x){return ksm(x,mod-2);}\n\t#else\n\tll ksm(ll x,int y){ll ret=1;for (;y;y>>=1,x=x*x) if (y&1) ret=ret*x;return ret;}\n\t#endif\n//\tinline ll mul(ll a,ll b){ll d=(ll)(a*(double)b/mod+0.5);ll ret=a*b-d*mod;if (ret<0) ret+=mod;return ret;}\n}\nusing namespace my_std;\n\nint n;\nll a[sz];\npli p[sz];\nmap<ll,int>mp;\n\nint fa[sz],size[sz];\nint getfa(int x){return x==fa[x]?fa[x]:fa[x]=getfa(fa[x]);}\nvoid merge(int x,int y){x=getfa(x),y=getfa(y);fa[x]=y,size[y]+=size[x];}\n\npii ans[sz];\n\nint main()\n{\n\tfile();\n\tread(n);\n\trep(i,1,n) read(a[i]),p[i]=MP(a[i],i),mp[a[i]]=i;\n\tsort(p+1,p+n+1);\n\trep(i,1,n) fa[i]=i,size[i]=1;\n\tdrep(k,n,2)\n\t{\n\t\tint x=p[k].sec;\n\t\tll w=a[x]-(n-size[getfa(x)])+size[getfa(x)];\n\t\tif (!mp.count(w)||mp[w]==x) return puts(\"-1\"),0;\n\t\tans[k-1]=MP(x,mp[w]);\n\t\tmerge(x,mp[w]);\n\t}\n\trep(i,1,n-1) printf(\"%d %d\\n\",ans[i].fir,ans[i].sec);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define N 100100\n\nll n,cnt;\nll d[N];\nset<pair<ll,ll> > S;\nll sz[N],u[N],v[N];\nset<pair<ll,ll> >::iterator it,it2;\n\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tfor (ll i=1;i<=n;i++) {\n\t\tscanf(\"%lld\",&d[i]);\n\t\tS.insert(mp(d[i],i));\n\t\tsz[i]=1;\n\t}\n\t\n\tfor (ll i=1;i<n;i++)\n\t{\n\t\tit=S.end(); it--;\n\t\tll now=(*it).second,num=sz[now];\n\t\tS.erase(it);\n\t\tif (n-2*num<=0) return puts(\"-1\"),0;\n\t\tit2=S.lower_bound(mp(d[now]-(n-2*num),0));\n\t\tif (it2==S.end() || (*it2).first!=d[now]-(n-2*num)) return puts(\"-1\"),0;\n\t\tu[++cnt]=now; v[cnt]=(*it2).second;\n\t\tsz[(*it2).second]+=num;\n\t}\n\tfor (ll i=1;i<=cnt;i++) printf(\"%lld %lld\\n\",u[i],v[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e5 + 10;\n\nint D[N],id[N],Sz[N];\nstruct node {\n\tint x,y;\n}G[N];\nmap <ll,int> Map,Id;\n\ninline ll read() {\n\tll x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-')ch = getchar();\n\tif(ch == '-')flag = -1,ch = getchar();\n\twhile(isdigit(ch))x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\nint main() {\n\n\tint n = read();\n\tFor(i,1,n) Map[D[i] = read()] = i,Sz[i] = 1;\n\tsort(D + 1,D + n + 1,greater<int>());\n\tFor(i,1,n) Id[D[i]] = i;\n\n\tFor(i,1,n - 1) {\n\t\tint Pre = D[i] + Sz[i] * 2 - n,val = Id[Pre];\n\t\tif(!val || Pre >= D[i]) return puts(\"-1\"),0;\n\t\tSz[val] += Sz[i];\n\t\tG[i] = (node){Map[D[i]],Map[D[val]]};\n\t}\n\n\tFor(i,1,n - 1) printf(\"%d %d\\n\",G[i].x,G[i].y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\nusing vll = std::vector<ll>;\nusing vvll = std::vector<vll>;\nusing vvvll = std::vector<vvll>;\nusing dd = double;\nusing vdd = std::vector<dd>;\nusing vvdd = std::vector<vdd>;\nusing vvvdd = std::vector<vvdd>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, N-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, N-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S, ll E){ T s=v[S]; REPS(i, S+1, E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = (ll)(1e9 + 7);// 998244353LL;//(ll)(1e9 + 7);\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\n\n\n\n\nvoid solve()\n{\n\tll N;\n\tcin >> N;\n\tvll D = cinv(N);\n\tvector<pair<ll, ll>> Dv;\n\tREP(v, N){\n\t\tDv.emplace_back(D[v], v);\n\t}\n\tsort(D.begin(), D.end(), [](auto &a, auto &b){return a>b; });\n\tsort(Dv.begin(), Dv.end(),\n\t\t[](auto &a, auto &b){ return a>b; }\n\t);\n\n\tvll parent(N, -1);\n\tvll a(N, 1);\n\tvll dSum(N);\n\n\tREPS(i, 0, N-2){\n\t\tll d, v;\n\t\ttie(d,v) = Dv[i];\n\t\tll pd = d - (N-2*a[i]);\n\t\t//dがpdであるiを探す\n\t\tauto it = lower_bound(D.begin(), D.end(), pd,\n\t\t\t[](auto &a, auto &b){return a>b; }\n\t\t);\n\t\tif (it == D.end()) bye(-1);\n\t\tif (*it != pd) bye(-1);\n\t\tll par_i = it - D.begin();\n\t\tparent[i] = Dv[par_i].second;\n\t\ta[par_i] += a[i];\n\t\tdSum[par_i] += dSum[i]+a[i];\n\t}\n\n\t//オフセットの確認\n\tif (dSum[N-1] != D[N-1]) bye(-1);\n\n\t//出力 +1して出力\n\tREPS(i, 0, N-2){\n\t\tcout << Dv[i].second+1 << \" \" << parent[i]+1 << '\\n';\n\t}\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<algorithm>\n#define N 1000400\nusing namespace std;\nint n,v2[N],fa[N];\nlong long v[N],sz[N],ds[N];\nmap<long long,int> tp;\nbool cmp(int a,int b){return v[a]<v[b];}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&v[i]),tp[v[i]]=i,v2[i]=i,sz[i]=1;\n\tsort(v2+1,v2+n+1,cmp);\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tlong long tp2=v[v2[i]]-n+sz[v2[i]]*2;\n\t\tif(!tp[tp2]){printf(\"-1\\n\");return 0;}\n\t\tint sb=tp[tp2];\n\t\tds[sb]+=ds[v2[i]]+sz[v2[i]];\n\t\tsz[sb]+=sz[v2[i]];\n\t\tfa[v2[i]]=sb;\n\t}\n\tif(ds[v2[1]]!=v[v2[1]]){printf(\"-1\\n\");return 0;}\n\tfor(int i=1;i<=n;i++)if(fa[i])printf(\"%d %d\\n\",i,fa[i]);\n}//111222333"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <map>\n\ntypedef long long ll;\nconst int N = 1e5 + 51;\nstruct edge {\n\tint to, next;\n} e[N << 1];\nint head[N], cnt;\nvoid addedge(int x, int y) {\n\te[++cnt] = (edge){y, x[head]}, x[head] = cnt;\n\te[++cnt] = (edge){x, y[head]}, y[head] = cnt;\n}\nvoid dfs(int x, int p) {\n\tfor (int i = x[head], nx; i; i = e[i].next)\n\t\tif ((nx = e[i].to) != p) printf(\"%d %d\\n\", x, nx), dfs(nx, x);\n}\n\nint p[N];\nint f(int x) { return x[p] ? x[p] = f(x[p]) : x; }\nvoid l(int x, int y) {\n\tif ((x = f(x)) != (y = f(y))) x[p] = y;\n}\n\nstd::map<ll, int> mp;\nint n, sz[N];\nll a[N];\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", a + i), i[sz] = 1, mp[a[i]] = i;\n\tstd::sort(a + 1, a + n + 1, std::greater<ll>());\n\tfor (int i = 1; i < n; i++) {\n\t\tint x = mp[a[i]], nx;\n\t\tll tmp = a[i] - n + 2 * x[sz];\n\t\tif (tmp == a[i] || !mp.count(tmp)) return puts(\"-1\"), 0;\n\t\tnx = mp[tmp];\n\t\tnx[sz] += x[sz];\n\t\tif (f(x) == f(nx)) return puts(\"-1\"), 0;\n\t\taddedge(x, nx);\n\t\tl(x, nx);\n\t}\n\tdfs(1, 0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\nusing std::cin;using std::cerr;\nusing std::max;using std::min;\n#define N 100005\n#define ll long long\n#define db double\n#define dbg1(x) cerr<<#x<<\"=\"<<(x)<<\" \"\n#define dbg2(x) cerr<<#x<<\"=\"<<(x)<<\"\\n\"\nint n,id[N],size[N],fa[N],ecnt,last[N];ll A[N],Sum; \nstd::map<ll,int>mp;\nstruct road{int to,nex;}e[N];\nvoid adde(int u,int v) {e[++ecnt]=(road){v,last[u]},last[u]=ecnt;}\nvoid dfs(int x,int d=0)\n{\n\tSum+=d;\n\tfor(int k=last[x];k;k=e[k].nex) dfs(e[k].to,d+1);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&A[i]),mp[A[i]]=id[i]=i;\n\tstd::sort(id+1,id+1+n,[](int t1,int t2){return A[t1]<A[t2];});\n\tfor(int i=n,x;i>1;i--)\n\t{\n\t\tx=id[i],size[x]++;\n\t\tif(!mp[A[x]-n+size[x]*2]) return puts(\"-1\"),0;\n\t\tfa[x]=mp[A[x]-n+size[x]*2],size[fa[x]]+=size[x],adde(fa[x],x);\n\t}\n\tdfs(id[1]);\n\tif(Sum^A[id[1]]) return puts(\"-1\"),0;\n\tfor(int i=1;i<=n;i++) if(fa[i]) printf(\"%d %d\\n\",i,fa[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define pii pair<int,int> \n\nint N;\nint a[100010];\nmap<int,int> mp;\n\nvector<pii> e;\nint sz[100010];\nint dp[100010];\n\nvector<pii> ans;\n\nbool cmp_d(pii p,pii q)\n{\n\treturn p>q;\n}\n\npii norm(int p,int q)\n{\n\treturn {min(p,q),max(p,q)};\n}\n\nmain()\n{\n\tcin>>N;\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tcin>>a[i];\n\t\tmp[a[i]]=i;\n\t\te.push_back({a[i],i});\n\t\tsz[i]=1;\n\t}\n\tsort(e.begin(),e.end(),cmp_d);\n\tint x=e.back().first;\n\tfor(int i=0;i<e.size();i++)\n\t{\n\t\tpii& cur=e[i];\n\t\tif(cur.first!=x)\n\t\t{\n\t\t\tif(sz[cur.second]*2>=N) goto FAIL;\n\t\t\tint p=cur.first-N+2*sz[cur.second];\n\t\t\tif(mp.find(p)==mp.end()) goto FAIL;\n\t\t\tint q=mp[p];\n\t\t\tdp[q]+=dp[cur.second]+sz[cur.second];\n\t\t\tsz[q]+=sz[cur.second];\n\t\t\tans.push_back(norm(cur.second,q));\n\t\t}\n\t}\n\tif(dp[e.back().second]!=x) goto FAIL;\n\t\n\tsort(ans.begin(),ans.end());\n\tfor(int i=0;i<ans.size();i++)\n\t{\n\t\tcout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n\t}\n\treturn 0;\n\t\n\t\n\t\n\tFAIL:;\n\t{\n\t\tcout<<\"-1\"<<endl;\n\t\treturn 0;\n\t}\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)   FOR(i,0,n)\n#define LL long long\n\nint n;\nvector<LL> d,init_d;\nvector<LL> ind,width;\nvector<pair<int,int>> ans;\n\nLL dfs(vector<vector<int>> tree,int pos,LL cum){\n  LL ret = cum;\n  REP(i,tree[pos].size())\n    ret += dfs(tree,tree[pos][i],cum+1);\n  return ret;\n}\n\nint main(){\n  cin>>n;\n  LL tmp;\n  REP(i,n){\n    cin>>tmp;\n    d.push_back(tmp);\n    init_d.push_back(tmp);\n  }\n  sort(d.begin(),d.end());\n  ind.resize(n);\n  REP(i,n){\n    int min_ind = distance(d.begin(),lower_bound(d.begin(),d.end(),init_d[i]));\n    ind[min_ind] = i+1;\n  }\n  REP(i,n){\n    width.push_back(1);\n  }\n\n  vector<vector<int>> tree(n);\n  REP(i,n-1){\n    LL s = d[n-1-i] - (n - 2*width[n-1-i]);\n    //cerr<<s<<endl;\n    int min_ind2 = distance(d.begin(),lower_bound(d.begin(),d.end(),s));\n    if(d[min_ind2] != s){\n      cout<<-1<<endl;\n      return 0;\n    }\n    ans.push_back(make_pair(min_ind2,n-1-i));\n    tree[min_ind2].push_back(n-1-i);\n    //tree[n-1-i].push_back(min_ind2);\n    width[min_ind2] += width[n-1-i];\n  }\n  if(d[0] != dfs(tree,0,0)){\n    cout<<-1<<endl;\n    return 0;\n  }\n  \n  REP(i,ans.size())\n    cout<<ind[ans[i].first]<<\" \"<<ind[ans[i].second]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\nstruct node\n{\n\tlong long d;int p;\n}a[100010];\nstruct bian\n{\n\tint x,y;\n}e[100010];int len;\nbool cmp(node a,node b){return a.d<b.d;}\nint n;\nbool v[100010];\ninline int erfen(long long x)\n{\n\tint l=1,r=n,ans;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)/2;\n\t\tif(a[mid].d<=x)ans=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\tif(a[ans].d==x)return ans;\n\telse return -1;\n}\nint tot[100010];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i].d),a[i].p=i;\n\tsort(a+1,a+n+1,cmp);\n\tfor(int i=1;i<=n;i++)tot[i]=1;\n\tbool bk=true;\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tlong long ul=a[i].d-n+2*tot[i];\n\t\tint y=erfen(ul);\n\t\tif(y==-1 || y==i){bk=false;break;}\n\t\tlen++;\n\t\te[len].x=a[y].p;e[len].y=a[i].p;\n\t\ttot[y]+=tot[i];\n\t}\n\tif(bk==false)printf(\"-1\\n\");\n\telse for(int i=1;i<=len;i++)printf(\"%d %d\\n\",e[i].x,e[i].y);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#include <vector>\nusing namespace std;\n\nnamespace zyt\n{\n\ttypedef long long ll;\n\tconst int N = 1e5 + 10;\n\tint n, id[N], fa[N], size[N], dis[N];\n\tll d[N];\n\tmap<ll, int> mp;\n\tvector<int> g[N];\n\tbool cmp(const int a, const int b)\n\t{\n\t\treturn d[a] < d[b];\n\t}\n\tvoid dfs(const int u, const int d)\n\t{\n\t\tdis[u] = d;\n\t\tfor (auto v : g[u])\n\t\t\tdfs(v, d + 1);\n\t}\n\tint work()\n\t{\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tscanf(\"%lld\", d + i), id[i] = i, mp[d[i]] = i, size[i] = 1;\n\t\tsort(id + 1, id + n + 1, cmp);\n\t\tfor (int i = n; i > 1; i--)\n\t\t{\n\t\t\tll t = d[id[i]] - n + 2LL * size[id[i]];\n\t\t\tmp.erase(d[id[i]]);\n\t\t\tif (mp.count(t))\n\t\t\t{\n\t\t\t\tsize[mp[t]] += size[id[i]], fa[id[i]] = mp[t];\n\t\t\t\tg[mp[t]].push_back(id[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tdfs(id[1], 0);\n\t\tll sum = 0;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tsum += dis[i];\n\t\tif (sum != d[id[1]])\n\t\t\tputs(\"-1\");\n\t\telse\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tif (fa[i])\n\t\t\t\t\tprintf(\"%d %d\\n\", i, fa[i]);\n\t\treturn 0;\n\t}\n}\nint main()\n{\n\treturn zyt::work();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <cctype>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}\n\twhile (isdigit(ch)){x=x*10+ch-48;ch=getchar();}\n\treturn x*f;\n}\n\npair <long long,int> D[100050];\n\npair <int,int> edge[100050];\n\nvector <int> G[100050];\n\nint n,size[100050],dis[100050],tot;\n\ninline void dfs(int u,int fa)\n{\n\tfor (int i=0;i<G[u].size();i++)\n\t{\n\t\tint v=G[u][i];\n\t\tif (v!=fa)\n\t\t{\n\t\t\tdis[v]=dis[u]+1;\n\t\t\tdfs(v,u);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tn=read();\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint d=read();\n\t\tD[i]={d,i};\n\t\tsize[i]=1;\n\t}\n\tsort(D+1,D+n+1);\n\treverse(D+1,D+n+1);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tlong long delta=D[i].first-n+2*size[i];\n\t\tint l=1,r=n,pos=0; \n\t\twhile (l<=r)\n\t\t{\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif (D[mid].first<=delta)\n\t\t\t{\n\t\t\t\tr=mid-1;\n\t\t\t\tpos=mid;\n\t\t\t}\n\t\t\telse\n\t\t\t\tl=mid+1;\n\t\t}\n\t\t//cout << D[pos].first << \" \" << delta << endl;\n\t\tif (D[pos].first!=delta)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint u=D[i].second,v=D[pos].second;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t\tedge[++tot]={u,v};\n\t\tsize[pos]+=size[i];\n\t}\t\n\tdfs(D[n].second,0);\n\tlong long sum=0;\n\tfor (int i=1;i<=n;i++)\n\t\tsum+=dis[i];\n\tif (sum==D[n].first)\n\t{\n\t\tfor (int i=1;i<=tot;i++)\n\t\t\tcout << edge[i].first << \" \" << edge[i].second << endl;\n\t}\n\telse\n\t\tputs(\"-1\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\n\n//短い版\n\n#include <algorithm>\n#include <array>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        int ceil_pow2(int n) {\n            int x = 0;\n            while ((1U << x) < (unsigned int)(n)) x++;\n            return x;\n        }\n        \n        int bsf(unsigned int n) {\n#ifdef _MSC_VER\n            unsigned long index;\n            _BitScanForward(&index, n);\n            return index;\n#else\n            return __builtin_ctz(n);\n#endif\n        }\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n\n\n#include <utility>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        constexpr long long safe_mod(long long x, long long m) {\n            x %= m;\n            if (x < 0) x += m;\n            return x;\n        }\n        \n        struct barrett {\n            unsigned int _m;\n            unsigned long long im;\n            \n            barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\n            \n            unsigned int umod() const { return _m; }\n            \n            unsigned int mul(unsigned int a, unsigned int b) const {\n                \n                unsigned long long z = a;\n                z *= b;\n#ifdef _MSC_VER\n                unsigned long long x;\n                _umul128(z, im, &x);\n#else\n                unsigned long long x =\n                (unsigned long long)(((unsigned __int128)(z)*im) >> 64);\n#endif\n                unsigned int v = (unsigned int)(z - x * _m);\n                if (_m <= v) v += _m;\n                return v;\n            }\n        };\n        \n        constexpr long long pow_mod_constexpr(long long x, long long n, int m) {\n            if (m == 1) return 0;\n            unsigned int _m = (unsigned int)(m);\n            unsigned long long r = 1;\n            unsigned long long y = safe_mod(x, m);\n            while (n) {\n                if (n & 1) r = (r * y) % _m;\n                y = (y * y) % _m;\n                n >>= 1;\n            }\n            return r;\n        }\n        \n        constexpr bool is_prime_constexpr(int n) {\n            if (n <= 1) return false;\n            if (n == 2 || n == 7 || n == 61) return true;\n            if (n % 2 == 0) return false;\n            long long d = n - 1;\n            while (d % 2 == 0) d /= 2;\n            for (long long a : {2, 7, 61}) {\n                long long t = d;\n                long long y = pow_mod_constexpr(a, t, n);\n                while (t != n - 1 && y != 1 && y != n - 1) {\n                    y = y * y % n;\n                    t <<= 1;\n                }\n                if (y != n - 1 && t % 2 == 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        template <int n> constexpr bool is_prime = is_prime_constexpr(n);\n        \n        constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {\n            a = safe_mod(a, b);\n            if (a == 0) return {b, 0};\n            \n            long long s = b, t = a;\n            long long m0 = 0, m1 = 1;\n            \n            while (t) {\n                long long u = s / t;\n                s -= t * u;\n                m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\n                \n                \n                auto tmp = s;\n                s = t;\n                t = tmp;\n                tmp = m0;\n                m0 = m1;\n                m1 = tmp;\n            }\n            if (m0 < 0) m0 += b / s;\n            return {s, m0};\n        }\n        \n        constexpr int primitive_root_constexpr(int m) {\n            if (m == 2) return 1;\n            if (m == 167772161) return 3;\n            if (m == 469762049) return 3;\n            if (m == 754974721) return 11;\n            if (m == 998244353) return 3;\n            int divs[20] = {};\n            divs[0] = 2;\n            int cnt = 1;\n            int x = (m - 1) / 2;\n            while (x % 2 == 0) x /= 2;\n            for (int i = 3; (long long)(i)*i <= x; i += 2) {\n                if (x % i == 0) {\n                    divs[cnt++] = i;\n                    while (x % i == 0) {\n                        x /= i;\n                    }\n                }\n            }\n            if (x > 1) {\n                divs[cnt++] = x;\n            }\n            for (int g = 2;; g++) {\n                bool ok = true;\n                for (int i = 0; i < cnt; i++) {\n                    if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (ok) return g;\n            }\n        }\n        template <int m> constexpr int primitive_root = primitive_root_constexpr(m);\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n#ifndef _MSC_VER\n        template <class T>\n        using is_signed_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value ||\n        std::is_same<T, __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __uint128_t>::value ||\n        std::is_same<T, unsigned __int128>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using make_unsigned_int128 =\n        typename std::conditional<std::is_same<T, __int128_t>::value,\n        __uint128_t,\n        unsigned __int128>;\n        \n        template <class T>\n        using is_integral = typename std::conditional<std::is_integral<T>::value ||\n        is_signed_int128<T>::value ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_signed_int = typename std::conditional<(is_integral<T>::value &&\n                                                         std::is_signed<T>::value) ||\n        is_signed_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<(is_integral<T>::value &&\n                                   std::is_unsigned<T>::value) ||\n        is_unsigned_int128<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using to_unsigned = typename std::conditional<\n        is_signed_int128<T>::value,\n        make_unsigned_int128<T>,\n        typename std::conditional<std::is_signed<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type>::type;\n        \n#else\n        \n        template <class T> using is_integral = typename std::is_integral<T>;\n        \n        template <class T>\n        using is_signed_int =\n        typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using is_unsigned_int =\n        typename std::conditional<is_integral<T>::value &&\n        std::is_unsigned<T>::value,\n        std::true_type,\n        std::false_type>::type;\n        \n        template <class T>\n        using to_unsigned = typename std::conditional<is_signed_int<T>::value,\n        std::make_unsigned<T>,\n        std::common_type<T>>::type;\n        \n#endif\n        \n        template <class T>\n        using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\n        \n        template <class T>\n        using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\n        \n        template <class T> using to_unsigned_t = typename to_unsigned<T>::type;\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <numeric>\n#include <type_traits>\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        struct modint_base {};\n        struct static_modint_base : modint_base {};\n        \n        template <class T> using is_modint = std::is_base_of<modint_base, T>;\n        template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\n        \n    }  // namespace internal\n    \n    template <int m, std::enable_if_t<(1 <= m)>* = nullptr>\n    struct static_modint : internal::static_modint_base {\n        using mint = static_modint;\n        \n    public:\n        static constexpr int mod() { return m; }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        \n        static_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        static_modint(T v) {\n            long long x = (long long)(v % (long long)(umod()));\n            if (x < 0) x += umod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        static_modint(T v) {\n            _v = (unsigned int)(v % umod());\n        }\n        static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\n        \n        unsigned int val() const { return _v; }\n        \n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        \n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v -= rhs._v;\n            if (_v >= umod()) _v += umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            unsigned long long z = _v;\n            z *= rhs._v;\n            _v = (unsigned int)(z % umod());\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        \n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        \n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            if (prime) {\n                assert(_v);\n                return pow(umod() - 2);\n            } else {\n                auto eg = internal::inv_gcd(_v, m);\n                assert(eg.first == 1);\n                return eg.second;\n            }\n        }\n        \n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n        \n    private:\n        unsigned int _v;\n        static constexpr unsigned int umod() { return m; }\n        static constexpr bool prime = internal::is_prime<m>;\n    };\n    \n    template <int id> struct dynamic_modint : internal::modint_base {\n        using mint = dynamic_modint;\n        \n    public:\n        static int mod() { return (int)(bt.umod()); }\n        static void set_mod(int m) {\n            assert(1 <= m);\n            bt = internal::barrett(m);\n        }\n        static mint raw(int v) {\n            mint x;\n            x._v = v;\n            return x;\n        }\n        \n        dynamic_modint() : _v(0) {}\n        template <class T, internal::is_signed_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            long long x = (long long)(v % (long long)(mod()));\n            if (x < 0) x += mod();\n            _v = (unsigned int)(x);\n        }\n        template <class T, internal::is_unsigned_int_t<T>* = nullptr>\n        dynamic_modint(T v) {\n            _v = (unsigned int)(v % mod());\n        }\n        dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\n        \n        unsigned int val() const { return _v; }\n        \n        mint& operator++() {\n            _v++;\n            if (_v == umod()) _v = 0;\n            return *this;\n        }\n        mint& operator--() {\n            if (_v == 0) _v = umod();\n            _v--;\n            return *this;\n        }\n        mint operator++(int) {\n            mint result = *this;\n            ++*this;\n            return result;\n        }\n        mint operator--(int) {\n            mint result = *this;\n            --*this;\n            return result;\n        }\n        \n        mint& operator+=(const mint& rhs) {\n            _v += rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator-=(const mint& rhs) {\n            _v += mod() - rhs._v;\n            if (_v >= umod()) _v -= umod();\n            return *this;\n        }\n        mint& operator*=(const mint& rhs) {\n            _v = bt.mul(_v, rhs._v);\n            return *this;\n        }\n        mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\n        \n        mint operator+() const { return *this; }\n        mint operator-() const { return mint() - *this; }\n        \n        mint pow(long long n) const {\n            assert(0 <= n);\n            mint x = *this, r = 1;\n            while (n) {\n                if (n & 1) r *= x;\n                x *= x;\n                n >>= 1;\n            }\n            return r;\n        }\n        mint inv() const {\n            auto eg = internal::inv_gcd(_v, mod());\n            assert(eg.first == 1);\n            return eg.second;\n        }\n        \n        friend mint operator+(const mint& lhs, const mint& rhs) {\n            return mint(lhs) += rhs;\n        }\n        friend mint operator-(const mint& lhs, const mint& rhs) {\n            return mint(lhs) -= rhs;\n        }\n        friend mint operator*(const mint& lhs, const mint& rhs) {\n            return mint(lhs) *= rhs;\n        }\n        friend mint operator/(const mint& lhs, const mint& rhs) {\n            return mint(lhs) /= rhs;\n        }\n        friend bool operator==(const mint& lhs, const mint& rhs) {\n            return lhs._v == rhs._v;\n        }\n        friend bool operator!=(const mint& lhs, const mint& rhs) {\n            return lhs._v != rhs._v;\n        }\n        \n    private:\n        unsigned int _v;\n        static internal::barrett bt;\n        static unsigned int umod() { return bt.umod(); }\n    };\n    template <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\n    \n    using modint998244353 = static_modint<998244353>;\n    using modint1000000007 = static_modint<1000000007>;\n    using modint = dynamic_modint<-1>;\n    \n    namespace internal {\n        \n        template <class T>\n        using is_static_modint = std::is_base_of<internal::static_modint_base, T>;\n        \n        template <class T>\n        using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\n        \n        template <class> struct is_dynamic_modint : public std::false_type {};\n        template <int id>\n        struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\n        \n        template <class T>\n        using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <type_traits>\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            \n            static bool first = true;\n            static mint sum_e[30];  // sum_e[i] = ies[0] * ... * ies[i - 1] * es[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_e[i] = es[i] * now;\n                    now *= ies[i];\n                }\n            }\n            for (int ph = 1; ph <= h; ph++) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint now = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p] * now;\n                        a[i + offset] = l + r;\n                        a[i + offset + p] = l - r;\n                    }\n                    now *= sum_e[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        \n        template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n        void butterfly_inv(std::vector<mint>& a) {\n            static constexpr int g = internal::primitive_root<mint::mod()>;\n            int n = int(a.size());\n            int h = internal::ceil_pow2(n);\n            \n            static bool first = true;\n            static mint sum_ie[30];  // sum_ie[i] = es[0] * ... * es[i - 1] * ies[i]\n            if (first) {\n                first = false;\n                mint es[30], ies[30];  // es[i]^(2^(2+i)) == 1\n                int cnt2 = bsf(mint::mod() - 1);\n                mint e = mint(g).pow((mint::mod() - 1) >> cnt2), ie = e.inv();\n                for (int i = cnt2; i >= 2; i--) {\n                    es[i - 2] = e;\n                    ies[i - 2] = ie;\n                    e *= e;\n                    ie *= ie;\n                }\n                mint now = 1;\n                for (int i = 0; i < cnt2 - 2; i++) {\n                    sum_ie[i] = ies[i] * now;\n                    now *= es[i];\n                }\n            }\n            \n            for (int ph = h; ph >= 1; ph--) {\n                int w = 1 << (ph - 1), p = 1 << (h - ph);\n                mint inow = 1;\n                for (int s = 0; s < w; s++) {\n                    int offset = s << (h - ph + 1);\n                    for (int i = 0; i < p; i++) {\n                        auto l = a[i + offset];\n                        auto r = a[i + offset + p];\n                        a[i + offset] = l + r;\n                        a[i + offset + p] =\n                        (unsigned long long)(mint::mod() + l.val() - r.val()) *\n                        inow.val();\n                    }\n                    inow *= sum_ie[bsf(~(unsigned int)(s))];\n                }\n            }\n        }\n        \n    }  // namespace internal\n    \n    template <class mint, internal::is_static_modint_t<mint>* = nullptr>\n    std::vector<mint> convolution(std::vector<mint> a, std::vector<mint> b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        if (std::min(n, m) <= 60) {\n            if (n < m) {\n                std::swap(n, m);\n                std::swap(a, b);\n            }\n            std::vector<mint> ans(n + m - 1);\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ans[i + j] += a[i] * b[j];\n                }\n            }\n            return ans;\n        }\n        int z = 1 << internal::ceil_pow2(n + m - 1);\n        a.resize(z);\n        internal::butterfly(a);\n        b.resize(z);\n        internal::butterfly(b);\n        for (int i = 0; i < z; i++) {\n            a[i] *= b[i];\n        }\n        internal::butterfly_inv(a);\n        a.resize(n + m - 1);\n        mint iz = mint(z).inv();\n        for (int i = 0; i < n + m - 1; i++) a[i] *= iz;\n        return a;\n    }\n    \n    template <unsigned int mod = 998244353,\n    class T,\n    std::enable_if_t<internal::is_integral<T>::value>* = nullptr>\n    std::vector<T> convolution(const std::vector<T>& a, const std::vector<T>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        \n        using mint = static_modint<mod>;\n        std::vector<mint> a2(n), b2(m);\n        for (int i = 0; i < n; i++) {\n            a2[i] = mint(a[i]);\n        }\n        for (int i = 0; i < m; i++) {\n            b2[i] = mint(b[i]);\n        }\n        auto c2 = convolution(move(a2), move(b2));\n        std::vector<T> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            c[i] = c2[i].val();\n        }\n        return c;\n    }\n    \n    std::vector<long long> convolution_ll(const std::vector<long long>& a,\n                                          const std::vector<long long>& b) {\n        int n = int(a.size()), m = int(b.size());\n        if (!n || !m) return {};\n        \n        static constexpr unsigned long long MOD1 = 754974721;  // 2^24\n        static constexpr unsigned long long MOD2 = 167772161;  // 2^25\n        static constexpr unsigned long long MOD3 = 469762049;  // 2^26\n        static constexpr unsigned long long M2M3 = MOD2 * MOD3;\n        static constexpr unsigned long long M1M3 = MOD1 * MOD3;\n        static constexpr unsigned long long M1M2 = MOD1 * MOD2;\n        static constexpr unsigned long long M1M2M3 = MOD1 * MOD2 * MOD3;\n        \n        static constexpr unsigned long long i1 =\n        internal::inv_gcd(MOD2 * MOD3, MOD1).second;\n        static constexpr unsigned long long i2 =\n        internal::inv_gcd(MOD1 * MOD3, MOD2).second;\n        static constexpr unsigned long long i3 =\n        internal::inv_gcd(MOD1 * MOD2, MOD3).second;\n        \n        auto c1 = convolution<MOD1>(a, b);\n        auto c2 = convolution<MOD2>(a, b);\n        auto c3 = convolution<MOD3>(a, b);\n        \n        std::vector<long long> c(n + m - 1);\n        for (int i = 0; i < n + m - 1; i++) {\n            unsigned long long x = 0;\n            x += (c1[i] * i1) % MOD1 * M2M3;\n            x += (c2[i] * i2) % MOD2 * M1M3;\n            x += (c3[i] * i3) % MOD3 * M1M2;\n            long long diff =\n            c1[i] - internal::safe_mod((long long)(x), (long long)(MOD1));\n            if (diff < 0) diff += MOD1;\n            static constexpr unsigned long long offset[5] = {\n                0, 0, M1M2M3, 2 * M1M2M3, 3 * M1M2M3};\n            x -= offset[diff % 5];\n            c[i] = x;\n        }\n        \n        return c;\n    }\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct dsu {\n    public:\n        dsu() : _n(0) {}\n        dsu(int n) : _n(n), parent_or_size(n, -1) {}\n        \n        int merge(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            int x = leader(a), y = leader(b);\n            if (x == y) return x;\n            if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);\n            parent_or_size[x] += parent_or_size[y];\n            parent_or_size[y] = x;\n            return x;\n        }\n        \n        bool same(int a, int b) {\n            assert(0 <= a && a < _n);\n            assert(0 <= b && b < _n);\n            return leader(a) == leader(b);\n        }\n        \n        int leader(int a) {\n            assert(0 <= a && a < _n);\n            if (parent_or_size[a] < 0) return a;\n            return parent_or_size[a] = leader(parent_or_size[a]);\n        }\n        \n        int size(int a) {\n            assert(0 <= a && a < _n);\n            return -parent_or_size[leader(a)];\n        }\n        \n        std::vector<std::vector<int>> groups() {\n            std::vector<int> leader_buf(_n), group_size(_n);\n            for (int i = 0; i < _n; i++) {\n                leader_buf[i] = leader(i);\n                group_size[leader_buf[i]]++;\n            }\n            std::vector<std::vector<int>> result(_n);\n            for (int i = 0; i < _n; i++) {\n                result[i].reserve(group_size[i]);\n            }\n            for (int i = 0; i < _n; i++) {\n                result[leader_buf[i]].push_back(i);\n            }\n            result.erase(\n                         std::remove_if(result.begin(), result.end(),\n                                        [&](const std::vector<int>& v) { return v.empty(); }),\n                         result.end());\n            return result;\n        }\n        \n    private:\n        int _n;\n        std::vector<int> parent_or_size;\n    };\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class T> struct fenwick_tree {\n        using U = internal::to_unsigned_t<T>;\n        \n    public:\n        fenwick_tree() : _n(0) {}\n        fenwick_tree(int n) : _n(n), data(n) {}\n        \n        void add(int p, T x) {\n            assert(0 <= p && p < _n);\n            p++;\n            while (p <= _n) {\n                data[p - 1] += U(x);\n                p += p & -p;\n            }\n        }\n        \n        T sum(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            return sum(r) - sum(l);\n        }\n        \n    private:\n        int _n;\n        std::vector<U> data;\n        \n        U sum(int r) {\n            U s = 0;\n            while (r > 0) {\n                s += data[r - 1];\n                r -= r & -r;\n            }\n            return s;\n        }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nnamespace atcoder {\n    \n    template <class S,\n    S (*op)(S, S),\n    S (*e)(),\n    class F,\n    S (*mapping)(F, S),\n    F (*composition)(F, F),\n    F (*id)()>\n    struct lazy_segtree {\n    public:\n        lazy_segtree() : lazy_segtree(0) {}\n        lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}\n        lazy_segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            lz = std::vector<F>(size, id());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n        \n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        \n        S get(int p) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            return d[p];\n        }\n        \n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r) return e();\n            \n            l += size;\n            r += size;\n            \n            for (int i = log; i >= 1; i--) {\n                if (((l >> i) << i) != l) push(l >> i);\n                if (((r >> i) << i) != r) push(r >> i);\n            }\n            \n            S sml = e(), smr = e();\n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            \n            return op(sml, smr);\n        }\n        \n        S all_prod() { return d[1]; }\n        \n        void apply(int p, F f) {\n            assert(0 <= p && p < _n);\n            p += size;\n            for (int i = log; i >= 1; i--) push(p >> i);\n            d[p] = mapping(f, d[p]);\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        void apply(int l, int r, F f) {\n            assert(0 <= l && l <= r && r <= _n);\n            if (l == r) return;\n            \n            l += size;\n            r += size;\n            \n            for (int i = log; i >= 1; i--) {\n                if (((l >> i) << i) != l) push(l >> i);\n                if (((r >> i) << i) != r) push((r - 1) >> i);\n            }\n            \n            {\n                int l2 = l, r2 = r;\n                while (l < r) {\n                    if (l & 1) all_apply(l++, f);\n                    if (r & 1) all_apply(--r, f);\n                    l >>= 1;\n                    r >>= 1;\n                }\n                l = l2;\n                r = r2;\n            }\n            \n            for (int i = 1; i <= log; i++) {\n                if (((l >> i) << i) != l) update(l >> i);\n                if (((r >> i) << i) != r) update((r - 1) >> i);\n            }\n        }\n        \n        template <bool (*g)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return g(x); });\n        }\n        template <class G> int max_right(int l, G g) {\n            assert(0 <= l && l <= _n);\n            assert(g(e()));\n            if (l == _n) return _n;\n            l += size;\n            for (int i = log; i >= 1; i--) push(l >> i);\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!g(op(sm, d[l]))) {\n                    while (l < size) {\n                        push(l);\n                        l = (2 * l);\n                        if (g(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        \n        template <bool (*g)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return g(x); });\n        }\n        template <class G> int min_left(int r, G g) {\n            assert(0 <= r && r <= _n);\n            assert(g(e()));\n            if (r == 0) return 0;\n            r += size;\n            for (int i = log; i >= 1; i--) push((r - 1) >> i);\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!g(op(d[r], sm))) {\n                    while (r < size) {\n                        push(r);\n                        r = (2 * r + 1);\n                        if (g(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n        \n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        std::vector<F> lz;\n        \n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n        void all_apply(int k, F f) {\n            d[k] = mapping(f, d[k]);\n            if (k < size) lz[k] = composition(f, lz[k]);\n        }\n        void push(int k) {\n            all_apply(2 * k, lz[k]);\n            all_apply(2 * k + 1, lz[k]);\n            lz[k] = id();\n        }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <tuple>\n#include <vector>\n\nnamespace atcoder {\n    \n    long long pow_mod(long long x, long long n, int m) {\n        assert(0 <= n && 1 <= m);\n        if (m == 1) return 0;\n        internal::barrett bt((unsigned int)(m));\n        unsigned int r = 1, y = (unsigned int)(internal::safe_mod(x, m));\n        while (n) {\n            if (n & 1) r = bt.mul(r, y);\n            y = bt.mul(y, y);\n            n >>= 1;\n        }\n        return r;\n    }\n    \n    long long inv_mod(long long x, long long m) {\n        assert(1 <= m);\n        auto z = internal::inv_gcd(x, m);\n        assert(z.first == 1);\n        return z.second;\n    }\n    \n    std::pair<long long, long long> crt(const std::vector<long long>& r,\n                                        const std::vector<long long>& m) {\n        assert(r.size() == m.size());\n        int n = int(r.size());\n        long long r0 = 0, m0 = 1;\n        for (int i = 0; i < n; i++) {\n            assert(1 <= m[i]);\n            long long r1 = internal::safe_mod(r[i], m[i]), m1 = m[i];\n            if (m0 < m1) {\n                std::swap(r0, r1);\n                std::swap(m0, m1);\n            }\n            if (m0 % m1 == 0) {\n                if (r0 % m1 != r1) return {0, 0};\n                continue;\n            }\n            \n            \n            long long g, im;\n            std::tie(g, im) = internal::inv_gcd(m0, m1);\n            \n            long long u1 = (m1 / g);\n            if ((r1 - r0) % g) return {0, 0};\n            \n            long long x = (r1 - r0) / g % u1 * im % u1;\n            \n            r0 += x * m0;\n            m0 *= u1;  // -> lcm(m0, m1)\n            if (r0 < 0) r0 += m0;\n        }\n        return {r0, m0};\n    }\n    \n    long long floor_sum(long long n, long long m, long long a, long long b) {\n        long long ans = 0;\n        if (a >= m) {\n            ans += (n - 1) * n * (a / m) / 2;\n            a %= m;\n        }\n        if (b >= m) {\n            ans += n * (b / m);\n            b %= m;\n        }\n        \n        long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n        if (y_max == 0) return ans;\n        ans += (n - (x_max + a - 1) / a) * y_max;\n        ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n        return ans;\n    }\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        template <class T> struct simple_queue {\n            std::vector<T> payload;\n            int pos = 0;\n            void reserve(int n) { payload.reserve(n); }\n            int size() const { return int(payload.size()) - pos; }\n            bool empty() const { return pos == int(payload.size()); }\n            void push(const T& t) { payload.push_back(t); }\n            T& front() { return payload[pos]; }\n            void clear() {\n                payload.clear();\n                pos = 0;\n            }\n            void pop() { pos++; }\n        };\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class Cap> struct mf_graph {\n    public:\n        mf_graph() : _n(0) {}\n        mf_graph(int n) : _n(n), g(n) {}\n        \n        int add_edge(int from, int to, Cap cap) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            assert(0 <= cap);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0});\n            return m;\n        }\n        \n        struct edge {\n            int from, to;\n            Cap cap, flow;\n        };\n        \n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{pos[i].first, _e.to, _e.cap + _re.cap, _re.cap};\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result;\n            for (int i = 0; i < m; i++) {\n                result.push_back(get_edge(i));\n            }\n            return result;\n        }\n        void change_edge(int i, Cap new_cap, Cap new_flow) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            assert(0 <= new_flow && new_flow <= new_cap);\n            auto& _e = g[pos[i].first][pos[i].second];\n            auto& _re = g[_e.to][_e.rev];\n            _e.cap = new_cap - new_flow;\n            _re.cap = new_flow;\n        }\n        \n        Cap flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        Cap flow(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            \n            std::vector<int> level(_n), iter(_n);\n            internal::simple_queue<int> que;\n            \n            auto bfs = [&]() {\n                std::fill(level.begin(), level.end(), -1);\n                level[s] = 0;\n                que.clear();\n                que.push(s);\n                while (!que.empty()) {\n                    int v = que.front();\n                    que.pop();\n                    for (auto e : g[v]) {\n                        if (e.cap == 0 || level[e.to] >= 0) continue;\n                        level[e.to] = level[v] + 1;\n                        if (e.to == t) return;\n                        que.push(e.to);\n                    }\n                }\n            };\n            auto dfs = [&](auto self, int v, Cap up) {\n                if (v == s) return up;\n                Cap res = 0;\n                int level_v = level[v];\n                for (int& i = iter[v]; i < int(g[v].size()); i++) {\n                    _edge& e = g[v][i];\n                    if (level_v <= level[e.to] || g[e.to][e.rev].cap == 0) continue;\n                    Cap d =\n                    self(self, e.to, std::min(up - res, g[e.to][e.rev].cap));\n                    if (d <= 0) continue;\n                    g[v][i].cap += d;\n                    g[e.to][e.rev].cap -= d;\n                    res += d;\n                    if (res == up) break;\n                }\n                return res;\n            };\n            \n            Cap flow = 0;\n            while (flow < flow_limit) {\n                bfs();\n                if (level[t] == -1) break;\n                std::fill(iter.begin(), iter.end(), 0);\n                while (flow < flow_limit) {\n                    Cap f = dfs(dfs, t, flow_limit - flow);\n                    if (!f) break;\n                    flow += f;\n                }\n            }\n            return flow;\n        }\n        \n        std::vector<bool> min_cut(int s) {\n            std::vector<bool> visited(_n);\n            internal::simple_queue<int> que;\n            que.push(s);\n            while (!que.empty()) {\n                int p = que.front();\n                que.pop();\n                visited[p] = true;\n                for (auto e : g[p]) {\n                    if (e.cap && !visited[e.to]) {\n                        visited[e.to] = true;\n                        que.push(e.to);\n                    }\n                }\n            }\n            return visited;\n        }\n        \n    private:\n        int _n;\n        struct _edge {\n            int to, rev;\n            Cap cap;\n        };\n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <limits>\n#include <queue>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class Cap, class Cost> struct mcf_graph {\n    public:\n        mcf_graph() {}\n        mcf_graph(int n) : _n(n), g(n) {}\n        \n        int add_edge(int from, int to, Cap cap, Cost cost) {\n            assert(0 <= from && from < _n);\n            assert(0 <= to && to < _n);\n            int m = int(pos.size());\n            pos.push_back({from, int(g[from].size())});\n            g[from].push_back(_edge{to, int(g[to].size()), cap, cost});\n            g[to].push_back(_edge{from, int(g[from].size()) - 1, 0, -cost});\n            return m;\n        }\n        \n        struct edge {\n            int from, to;\n            Cap cap, flow;\n            Cost cost;\n        };\n        \n        edge get_edge(int i) {\n            int m = int(pos.size());\n            assert(0 <= i && i < m);\n            auto _e = g[pos[i].first][pos[i].second];\n            auto _re = g[_e.to][_e.rev];\n            return edge{\n                pos[i].first, _e.to, _e.cap + _re.cap, _re.cap, _e.cost,\n            };\n        }\n        std::vector<edge> edges() {\n            int m = int(pos.size());\n            std::vector<edge> result(m);\n            for (int i = 0; i < m; i++) {\n                result[i] = get_edge(i);\n            }\n            return result;\n        }\n        \n        std::pair<Cap, Cost> flow(int s, int t) {\n            return flow(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::pair<Cap, Cost> flow(int s, int t, Cap flow_limit) {\n            return slope(s, t, flow_limit).back();\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t) {\n            return slope(s, t, std::numeric_limits<Cap>::max());\n        }\n        std::vector<std::pair<Cap, Cost>> slope(int s, int t, Cap flow_limit) {\n            assert(0 <= s && s < _n);\n            assert(0 <= t && t < _n);\n            assert(s != t);\n            std::vector<Cost> dual(_n, 0), dist(_n);\n            std::vector<int> pv(_n), pe(_n);\n            std::vector<bool> vis(_n);\n            auto dual_ref = [&]() {\n                std::fill(dist.begin(), dist.end(),\n                          std::numeric_limits<Cost>::max());\n                std::fill(pv.begin(), pv.end(), -1);\n                std::fill(pe.begin(), pe.end(), -1);\n                std::fill(vis.begin(), vis.end(), false);\n                struct Q {\n                    Cost key;\n                    int to;\n                    bool operator<(Q r) const { return key > r.key; }\n                };\n                std::priority_queue<Q> que;\n                dist[s] = 0;\n                que.push(Q{0, s});\n                while (!que.empty()) {\n                    int v = que.top().to;\n                    que.pop();\n                    if (vis[v]) continue;\n                    vis[v] = true;\n                    if (v == t) break;\n                    for (int i = 0; i < int(g[v].size()); i++) {\n                        auto e = g[v][i];\n                        if (vis[e.to] || !e.cap) continue;\n                        Cost cost = e.cost - dual[e.to] + dual[v];\n                        if (dist[e.to] - dist[v] > cost) {\n                            dist[e.to] = dist[v] + cost;\n                            pv[e.to] = v;\n                            pe[e.to] = i;\n                            que.push(Q{dist[e.to], e.to});\n                        }\n                    }\n                }\n                if (!vis[t]) {\n                    return false;\n                }\n                \n                for (int v = 0; v < _n; v++) {\n                    if (!vis[v]) continue;\n                    dual[v] -= dist[t] - dist[v];\n                }\n                return true;\n            };\n            Cap flow = 0;\n            Cost cost = 0, prev_cost = -1;\n            std::vector<std::pair<Cap, Cost>> result;\n            result.push_back({flow, cost});\n            while (flow < flow_limit) {\n                if (!dual_ref()) break;\n                Cap c = flow_limit - flow;\n                for (int v = t; v != s; v = pv[v]) {\n                    c = std::min(c, g[pv[v]][pe[v]].cap);\n                }\n                for (int v = t; v != s; v = pv[v]) {\n                    auto& e = g[pv[v]][pe[v]];\n                    e.cap -= c;\n                    g[v][e.rev].cap += c;\n                }\n                Cost d = -dual[s];\n                flow += c;\n                cost += c * d;\n                if (prev_cost == d) {\n                    result.pop_back();\n                }\n                result.push_back({flow, cost});\n                prev_cost = cost;\n            }\n            return result;\n        }\n        \n    private:\n        int _n;\n        \n        struct _edge {\n            int to, rev;\n            Cap cap;\n            Cost cost;\n        };\n        \n        std::vector<std::pair<int, int>> pos;\n        std::vector<std::vector<_edge>> g;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nnamespace atcoder {\n    namespace internal {\n        \n        template <class E> struct csr {\n            std::vector<int> start;\n            std::vector<E> elist;\n            csr(int n, const std::vector<std::pair<int, E>>& edges)\n            : start(n + 1), elist(edges.size()) {\n                for (auto e : edges) {\n                    start[e.first + 1]++;\n                }\n                for (int i = 1; i <= n; i++) {\n                    start[i] += start[i - 1];\n                }\n                auto counter = start;\n                for (auto e : edges) {\n                    elist[counter[e.first]++] = e.second;\n                }\n            }\n        };\n        \n        struct scc_graph {\n        public:\n            scc_graph(int n) : _n(n) {}\n            \n            int num_vertices() { return _n; }\n            \n            void add_edge(int from, int to) { edges.push_back({from, {to}}); }\n            \n            std::pair<int, std::vector<int>> scc_ids() {\n                auto g = csr<edge>(_n, edges);\n                int now_ord = 0, group_num = 0;\n                std::vector<int> visited, low(_n), ord(_n, -1), ids(_n);\n                visited.reserve(_n);\n                auto dfs = [&](auto self, int v) -> void {\n                    low[v] = ord[v] = now_ord++;\n                    visited.push_back(v);\n                    for (int i = g.start[v]; i < g.start[v + 1]; i++) {\n                        auto to = g.elist[i].to;\n                        if (ord[to] == -1) {\n                            self(self, to);\n                            low[v] = std::min(low[v], low[to]);\n                        } else {\n                            low[v] = std::min(low[v], ord[to]);\n                        }\n                    }\n                    if (low[v] == ord[v]) {\n                        while (true) {\n                            int u = visited.back();\n                            visited.pop_back();\n                            ord[u] = _n;\n                            ids[u] = group_num;\n                            if (u == v) break;\n                        }\n                        group_num++;\n                    }\n                };\n                for (int i = 0; i < _n; i++) {\n                    if (ord[i] == -1) dfs(dfs, i);\n                }\n                for (auto& x : ids) {\n                    x = group_num - 1 - x;\n                }\n                return {group_num, ids};\n            }\n            \n            std::vector<std::vector<int>> scc() {\n                auto ids = scc_ids();\n                int group_num = ids.first;\n                std::vector<int> counts(group_num);\n                for (auto x : ids.second) counts[x]++;\n                std::vector<std::vector<int>> groups(ids.first);\n                for (int i = 0; i < group_num; i++) {\n                    groups[i].reserve(counts[i]);\n                }\n                for (int i = 0; i < _n; i++) {\n                    groups[ids.second[i]].push_back(i);\n                }\n                return groups;\n            }\n            \n        private:\n            int _n;\n            struct edge {\n                int to;\n            };\n            std::vector<std::pair<int, edge>> edges;\n        };\n        \n    }  // namespace internal\n    \n}  // namespace atcoder\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct scc_graph {\n    public:\n        scc_graph() : internal(0) {}\n        scc_graph(int n) : internal(n) {}\n        \n        void add_edge(int from, int to) {\n            int n = internal.num_vertices();\n            assert(0 <= from && from < n);\n            assert(0 <= to && to < n);\n            internal.add_edge(from, to);\n        }\n        \n        std::vector<std::vector<int>> scc() { return internal.scc(); }\n        \n    private:\n        internal::scc_graph internal;\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    template <class S, S (*op)(S, S), S (*e)()> struct segtree {\n    public:\n        segtree() : segtree(0) {}\n        segtree(int n) : segtree(std::vector<S>(n, e())) {}\n        segtree(const std::vector<S>& v) : _n(int(v.size())) {\n            log = internal::ceil_pow2(_n);\n            size = 1 << log;\n            d = std::vector<S>(2 * size, e());\n            for (int i = 0; i < _n; i++) d[size + i] = v[i];\n            for (int i = size - 1; i >= 1; i--) {\n                update(i);\n            }\n        }\n        \n        void set(int p, S x) {\n            assert(0 <= p && p < _n);\n            p += size;\n            d[p] = x;\n            for (int i = 1; i <= log; i++) update(p >> i);\n        }\n        \n        S get(int p) {\n            assert(0 <= p && p < _n);\n            return d[p + size];\n        }\n        \n        S prod(int l, int r) {\n            assert(0 <= l && l <= r && r <= _n);\n            S sml = e(), smr = e();\n            l += size;\n            r += size;\n            \n            while (l < r) {\n                if (l & 1) sml = op(sml, d[l++]);\n                if (r & 1) smr = op(d[--r], smr);\n                l >>= 1;\n                r >>= 1;\n            }\n            return op(sml, smr);\n        }\n        \n        S all_prod() { return d[1]; }\n        \n        template <bool (*f)(S)> int max_right(int l) {\n            return max_right(l, [](S x) { return f(x); });\n        }\n        template <class F> int max_right(int l, F f) {\n            assert(0 <= l && l <= _n);\n            assert(f(e()));\n            if (l == _n) return _n;\n            l += size;\n            S sm = e();\n            do {\n                while (l % 2 == 0) l >>= 1;\n                if (!f(op(sm, d[l]))) {\n                    while (l < size) {\n                        l = (2 * l);\n                        if (f(op(sm, d[l]))) {\n                            sm = op(sm, d[l]);\n                            l++;\n                        }\n                    }\n                    return l - size;\n                }\n                sm = op(sm, d[l]);\n                l++;\n            } while ((l & -l) != l);\n            return _n;\n        }\n        \n        template <bool (*f)(S)> int min_left(int r) {\n            return min_left(r, [](S x) { return f(x); });\n        }\n        template <class F> int min_left(int r, F f) {\n            assert(0 <= r && r <= _n);\n            assert(f(e()));\n            if (r == 0) return 0;\n            r += size;\n            S sm = e();\n            do {\n                r--;\n                while (r > 1 && (r % 2)) r >>= 1;\n                if (!f(op(d[r], sm))) {\n                    while (r < size) {\n                        r = (2 * r + 1);\n                        if (f(op(d[r], sm))) {\n                            sm = op(d[r], sm);\n                            r--;\n                        }\n                    }\n                    return r + 1 - size;\n                }\n                sm = op(d[r], sm);\n            } while ((r & -r) != r);\n            return 0;\n        }\n        \n    private:\n        int _n, size, log;\n        std::vector<S> d;\n        \n        void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n    };\n    \n}  // namespace atcoder\n\n\n#include <algorithm>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <vector>\n\nnamespace atcoder {\n    \n    namespace internal {\n        \n        std::vector<int> sa_naive(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            std::sort(sa.begin(), sa.end(), [&](int l, int r) {\n                if (l == r) return false;\n                while (l < n && r < n) {\n                    if (s[l] != s[r]) return s[l] < s[r];\n                    l++;\n                    r++;\n                }\n                return l == n;\n            });\n            return sa;\n        }\n        \n        std::vector<int> sa_doubling(const std::vector<int>& s) {\n            int n = int(s.size());\n            std::vector<int> sa(n), rnk = s, tmp(n);\n            std::iota(sa.begin(), sa.end(), 0);\n            for (int k = 1; k < n; k *= 2) {\n                auto cmp = [&](int x, int y) {\n                    if (rnk[x] != rnk[y]) return rnk[x] < rnk[y];\n                    int rx = x + k < n ? rnk[x + k] : -1;\n                    int ry = y + k < n ? rnk[y + k] : -1;\n                    return rx < ry;\n                };\n                std::sort(sa.begin(), sa.end(), cmp);\n                tmp[sa[0]] = 0;\n                for (int i = 1; i < n; i++) {\n                    tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);\n                }\n                std::swap(tmp, rnk);\n            }\n            return sa;\n        }\n        \n        template <int THRESHOLD_NAIVE = 10, int THRESHOLD_DOUBLING = 40>\n        std::vector<int> sa_is(const std::vector<int>& s, int upper) {\n            int n = int(s.size());\n            if (n == 0) return {};\n            if (n == 1) return {0};\n            if (n == 2) {\n                if (s[0] < s[1]) {\n                    return {0, 1};\n                } else {\n                    return {1, 0};\n                }\n            }\n            if (n < THRESHOLD_NAIVE) {\n                return sa_naive(s);\n            }\n            if (n < THRESHOLD_DOUBLING) {\n                return sa_doubling(s);\n            }\n            \n            std::vector<int> sa(n);\n            std::vector<bool> ls(n);\n            for (int i = n - 2; i >= 0; i--) {\n                ls[i] = (s[i] == s[i + 1]) ? ls[i + 1] : (s[i] < s[i + 1]);\n            }\n            std::vector<int> sum_l(upper + 1), sum_s(upper + 1);\n            for (int i = 0; i < n; i++) {\n                if (!ls[i]) {\n                    sum_s[s[i]]++;\n                } else {\n                    sum_l[s[i] + 1]++;\n                }\n            }\n            for (int i = 0; i <= upper; i++) {\n                sum_s[i] += sum_l[i];\n                if (i < upper) sum_l[i + 1] += sum_s[i];\n            }\n            \n            auto induce = [&](const std::vector<int>& lms) {\n                std::fill(sa.begin(), sa.end(), -1);\n                std::vector<int> buf(upper + 1);\n                std::copy(sum_s.begin(), sum_s.end(), buf.begin());\n                for (auto d : lms) {\n                    if (d == n) continue;\n                    sa[buf[s[d]]++] = d;\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                sa[buf[s[n - 1]]++] = n - 1;\n                for (int i = 0; i < n; i++) {\n                    int v = sa[i];\n                    if (v >= 1 && !ls[v - 1]) {\n                        sa[buf[s[v - 1]]++] = v - 1;\n                    }\n                }\n                std::copy(sum_l.begin(), sum_l.end(), buf.begin());\n                for (int i = n - 1; i >= 0; i--) {\n                    int v = sa[i];\n                    if (v >= 1 && ls[v - 1]) {\n                        sa[--buf[s[v - 1] + 1]] = v - 1;\n                    }\n                }\n            };\n            \n            std::vector<int> lms_map(n + 1, -1);\n            int m = 0;\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms_map[i] = m++;\n                }\n            }\n            std::vector<int> lms;\n            lms.reserve(m);\n            for (int i = 1; i < n; i++) {\n                if (!ls[i - 1] && ls[i]) {\n                    lms.push_back(i);\n                }\n            }\n            \n            induce(lms);\n            \n            if (m) {\n                std::vector<int> sorted_lms;\n                sorted_lms.reserve(m);\n                for (int v : sa) {\n                    if (lms_map[v] != -1) sorted_lms.push_back(v);\n                }\n                std::vector<int> rec_s(m);\n                int rec_upper = 0;\n                rec_s[lms_map[sorted_lms[0]]] = 0;\n                for (int i = 1; i < m; i++) {\n                    int l = sorted_lms[i - 1], r = sorted_lms[i];\n                    int end_l = (lms_map[l] + 1 < m) ? lms[lms_map[l] + 1] : n;\n                    int end_r = (lms_map[r] + 1 < m) ? lms[lms_map[r] + 1] : n;\n                    bool same = true;\n                    if (end_l - l != end_r - r) {\n                        same = false;\n                    } else {\n                        while (l < end_l) {\n                            if (s[l] != s[r]) {\n                                break;\n                            }\n                            l++;\n                            r++;\n                        }\n                        if (l == n || s[l] != s[r]) same = false;\n                    }\n                    if (!same) rec_upper++;\n                    rec_s[lms_map[sorted_lms[i]]] = rec_upper;\n                }\n                \n                auto rec_sa =\n                sa_is<THRESHOLD_NAIVE, THRESHOLD_DOUBLING>(rec_s, rec_upper);\n                \n                for (int i = 0; i < m; i++) {\n                    sorted_lms[i] = lms[rec_sa[i]];\n                }\n                induce(sorted_lms);\n            }\n            return sa;\n        }\n        \n    }  // namespace internal\n    \n    std::vector<int> suffix_array(const std::vector<int>& s, int upper) {\n        assert(0 <= upper);\n        for (int d : s) {\n            assert(0 <= d && d <= upper);\n        }\n        auto sa = internal::sa_is(s, upper);\n        return sa;\n    }\n    \n    template <class T> std::vector<int> suffix_array(const std::vector<T>& s) {\n        int n = int(s.size());\n        std::vector<int> idx(n);\n        iota(idx.begin(), idx.end(), 0);\n        sort(idx.begin(), idx.end(), [&](int l, int r) { return s[l] < s[r]; });\n        std::vector<int> s2(n);\n        int now = 0;\n        for (int i = 0; i < n; i++) {\n            if (i && s[idx[i - 1]] != s[idx[i]]) now++;\n            s2[idx[i]] = now;\n        }\n        return internal::sa_is(s2, now);\n    }\n    \n    std::vector<int> suffix_array(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return internal::sa_is(s2, 255);\n    }\n    \n    template <class T>\n    std::vector<int> lcp_array(const std::vector<T>& s,\n                               const std::vector<int>& sa) {\n        int n = int(s.size());\n        assert(n >= 1);\n        std::vector<int> rnk(n);\n        for (int i = 0; i < n; i++) {\n            rnk[sa[i]] = i;\n        }\n        std::vector<int> lcp(n - 1);\n        int h = 0;\n        for (int i = 0; i < n; i++) {\n            if (h > 0) h--;\n            if (rnk[i] == 0) continue;\n            int j = sa[rnk[i] - 1];\n            for (; j + h < n && i + h < n; h++) {\n                if (s[j + h] != s[i + h]) break;\n            }\n            lcp[rnk[i] - 1] = h;\n        }\n        return lcp;\n    }\n    \n    std::vector<int> lcp_array(const std::string& s, const std::vector<int>& sa) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return lcp_array(s2, sa);\n    }\n    \n    template <class T> std::vector<int> z_algorithm(const std::vector<T>& s) {\n        int n = int(s.size());\n        if (n == 0) return {};\n        std::vector<int> z(n);\n        z[0] = 0;\n        for (int i = 1, j = 0; i < n; i++) {\n            int& k = z[i];\n            k = (j + z[j] <= i) ? 0 : std::min(j + z[j] - i, z[i - j]);\n            while (i + k < n && s[k] == s[i + k]) k++;\n            if (j + z[j] < i + z[i]) j = i;\n        }\n        z[0] = n;\n        return z;\n    }\n    \n    std::vector<int> z_algorithm(const std::string& s) {\n        int n = int(s.size());\n        std::vector<int> s2(n);\n        for (int i = 0; i < n; i++) {\n            s2[i] = s[i];\n        }\n        return z_algorithm(s2);\n    }\n    \n}  // namespace atcoder\n\n\n#include <cassert>\n#include <vector>\n\nnamespace atcoder {\n    \n    struct two_sat {\n    public:\n        two_sat() : _n(0), scc(0) {}\n        two_sat(int n) : _n(n), _answer(n), scc(2 * n) {}\n        \n        void add_clause(int i, bool f, int j, bool g) {\n            assert(0 <= i && i < _n);\n            assert(0 <= j && j < _n);\n            scc.add_edge(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));\n            scc.add_edge(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));\n        }\n        bool satisfiable() {\n            auto id = scc.scc_ids().second;\n            for (int i = 0; i < _n; i++) {\n                if (id[2 * i] == id[2 * i + 1]) return false;\n                _answer[i] = id[2 * i] < id[2 * i + 1];\n            }\n            return true;\n        }\n        std::vector<bool> answer() { return _answer; }\n        \n    private:\n        int _n;\n        std::vector<bool> _answer;\n        internal::scc_graph scc;\n    };\n    \n}  // namespace atcoder\n\nconst int mod=1000000007,MAX=100005;\nconst ll INF=1LL<<50;\n\nstruct UF{\n    int n;\n    vector<int> par,size;\n    \n    void init(int n_){\n        n=n_;\n        par.assign(n,-1);\n        size.assign(n,1);\n        \n        for(int i=0;i<n;i++){\n            par[i]=i;\n        }\n    }\n    \n    int root(int a){\n        if(par[a]==a) return a;\n        else return par[a]=root(par[a]);\n    }\n    \n    void unite(int a,int b){\n        if(root(a)!=root(b)){\n            size[root(a)]+=size[root(b)];\n            par[root(b)]=root(a);\n        }\n    }\n    \n    bool check(int a,int b){\n        return root(a)==root(b);\n    }\n};\n\nvector<int> G[MAX];\nll dis[MAX];\n\nvoid DFS(int u,int p){\n    for(int to:G[u]){\n        if(to==p) continue;\n        dis[to]=dis[u]+1;\n        DFS(to,u);\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    vector<pair<ll,int>> D(N);\n    for(int i=0;i<N;i++){\n        cin>>D[i].fi;\n        D[i].se=i;\n    }\n    sort(all(D));\n    \n    vector<pair<int,int>> ans;\n    \n    UF uf;\n    uf.init(N);\n    \n    bool ok=true;\n    \n    for(int i=N-1;i>=1;i--){\n        ll dpar=D[i].fi-N+2*uf.size[uf.root(D[i].se)];\n        \n        auto it=lower_bound(all(D),mp(dpar,-1));\n        if(it==D.end()){\n            ok=false;\n            continue;\n        }\n        \n        if((*it).fi!=dpar){\n            ok=false;\n            continue;\n        }\n        \n        uf.unite(D[i].se,(*it).se);\n        ans.push_back(mp(D[i].se,(*it).se));\n    }\n    \n    if(!ok){\n        cout<<-1<<endl;\n        return 0;\n    }\n    \n    for(auto x:ans){\n        G[x.fi].push_back(x.se);\n        G[x.se].push_back(x.fi);\n    }\n    \n    DFS(D[0].se,-1);\n    \n    ll sum=0;\n    for(int i=0;i<N;i++) sum+=dis[i];\n    \n    if(D[0].fi==sum){\n        for(auto x:ans) cout<<x.fi+1<<\" \"<<x.se+1<<\"\\n\";\n    }else cout<<-1<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<long long> d(n);\n\tlong long miii = 1e15;\n\tint cent = -1;\n\tmap<long long, int> mp;\n\trep(i, n) {\n\t\tscanf(\"%lld\", &d[i]);\n\t\tmp[d[i]] = i;\n\t\tif (miii > d[i]) {\n\t\t\tmiii = d[i];\n\t\t\tcent = i;\n\t\t}\n\t}\n\tset<long long> st;\n\trep(i, n) {\n\t\tif (miii != d[i]) {\n\t\t\tst.insert(d[i]);\n\t\t}\n\t}\n\tvector<pair<int, int>> ans;\n\tauto no = [](){ cout << -1 << endl; exit(0); };\n\twhile (true) { \n\t\tif (ans.size() >= n - 1) break;\n\t\tlong long mi;\n\t\tfor (auto it : st) {\n\t\t\tmi = it;\n\t\t\tbreak;\n\t\t}\n\t\tst.erase(mi);\n\t\tint id = mp[mi];\n\t\tans.push_back({id, cent});\n\t\tlong long dist = mi - miii;\n\t\tlong long k = ((long long) n - dist) / 2;\n\t\tk --;\n\t\tdist += 2;\n\t\tlong long cur = mi;\n\t\tlong long prev;\n\t\twhile (k --) {\n\t\t\tprev = cur;\n\t\t\tcur += dist;\n\t\t\tif (st.count(cur) == 0) {\n\t\t\t\tno();\n\t\t\t}\n\t\t\tst.erase(cur);\n\t\t\tint pid = mp[prev];\n\t\t\tint cid = mp[cur];\n\t\t\tans.push_back({pid, cid});\n\t\t\tdist += 2;\n\t\t}\n\t}\n\tvector<vector<int>> g(n);\n\trep(i, n - 1) {\n\t\tint a = ans[i].first;\n\t\tint b = ans[i].second;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tvector<long long> s(n);\n\tvector<int> dis(n);\n\tvector<int> sz(n);\n\tfunction<void (int, int)> dfs = [&](int u, int prev) {\n\t\tsz[u] = 1;\n\t\tfor (auto v : g[u]) if (v != prev) {\n\t\t\tdis[v] = dis[u] + 1;\n\t\t\tdfs(v, u);\n\t\t\tsz[u] += sz[v];\n\t\t}\n\t};\n\tdfs(0, -1);\n\trep(i, n) s[0] += dis[i];\n\tfunction<void (int, int)> dfs2 = [&](int u, int prev) {\n\t\tfor (auto v : g[u]) if (v != prev) {\n\t\t\ts[v] = s[u] + n - sz[v] * 2;\n\t\t\tdfs2(v, u);\n\t\t}\n\t};\n\tdfs2(0, -1);\n\tsort(s.begin(), s.end());\n\tsort(d.begin(), d.end());\n\tif (s != d) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tfor (auto it : ans) printf(\"%d %d\\n\", it.first + 1, it.second + 1);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid err() {\n  cout << -1 << endl;\n  exit(0);\n}\nvoid dfs (int crr, int dpt, vector<vector<int>>& grh, int& cnt) {\n  cnt += dpt;\n  for (int nxt : grh[crr]) {\n    dfs(nxt, dpt + 1, grh, cnt);\n  }\n}\nint main() {\n  int n;\n  cin >> n;\n  vector<pair<int, int>> di(n);\n  for (int i = 0; i < n; i++) {\n    int d;\n    cin >> d;\n    di[i] = {d, i};\n  }\n  sort(di.begin(), di.end());\n  vector<int> sz(n, 1), prt(n);\n  vector<vector<int>> grh(n);\n  vector<pair<int, int>> edg;\n  for (auto it = prev(di.end()); it != di.begin(); it--) {\n    int d = it->first;\n    int i = it->second;\n    int prtv = d - n + 2 * sz[i];\n    auto jt = lower_bound(di.begin(), di.end(), make_pair(prtv, 0));\n    if (jt->first != prtv) err();\n    int p = jt->second;\n    prt[i] = p;\n    grh[p].push_back(i);\n    if (i == prt[i]) err();\n    sz[prt[i]] += sz[i];\n    edg.emplace_back(min(i, prt[i]), max(i, prt[i]));\n  }\n  int cnt = 0;\n  int rt = di[0].second;\n  dfs(rt, 0, grh, cnt);\n  if (di[0].first != cnt) err();\n  sort(edg.begin(), edg.end());\n  for (auto const & e : edg) {\n    cout << e.first + 1 << ' ' << e.second + 1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\n#define llint long long\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nllint N;\nP D[100005];\nvector<llint> G[100005];\nmap<llint, vector<P> > mp;\n\nint main(void)\n{\n\tcin >> N;\n\tfor(int i = 1; i <= N; i++) cin >> D[i].first;\n\tfor(int i = 1; i <= N; i++) D[i].second = i;\n\tsort(D+1, D+N+1), reverse(D+1, D+N+1);\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tllint d = D[i].first, id = D[i].second;\n\t\tif(mp.count(d) == 0){\n\t\t\tif(i != N){\n\t\t\t\tllint p = d-N+2;\n\t\t\t\tif(p > d) continue;\n\t\t\t\tmp[p].push_back(make_pair(id, 1));\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tllint x = 0;\n\t\t\tfor(int j = 0; j < mp[d].size(); j++){\n\t\t\t\tG[id].push_back(mp[d][j].first);\n\t\t\t\tx += mp[d][j].second;\n\t\t\t}\n\t\t\tx++;\n\t\t\tif(i != N){\n\t\t\t\tllint p = d-N+2*x;\n\t\t\t\tif(p > d) continue;\n\t\t\t\tmp[p].push_back(make_pair(id, x));\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*for(auto it = mp.begin(); it != mp.end(); it++){\n\t\t\tcout << it->first << \" \";\n\t\t}\n\t\tcout << endl;*/\n\t}\n\tvector<P> ans;\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\tans.push_back(make_pair(i, G[i][j]));\n\t\t}\n\t}\n\tif(ans.size() < N-1) cout << \"-1\" << endl;\n\telse{\n\t\tfor(int i = 0; i < ans.size(); i++) cout << ans[i].first << \" \" << ans[i].second << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 1000010\nusing namespace std;\nstruct S{\n\tlong long w,dep;\n\tlong long u,v,ne;\n}a[N],e[N];\n\tlong long n,sz[N],dy[N],fir[N],root,vis[N],sum,pan;\n\tbool bo=false;\nvoid add(long long u,long long v){\n\te[++sum].ne=fir[u];\n\tfir[u]=sum;\n\te[sum].v=v;\n\te[sum].u=u;\n//\te[sum].w=1;\n}\nbool cmp(S x,S y){\n\treturn x.w>y.w;\n}\nvoid check(long long x,long long dis){\n//\tif(bo)return;\n\tpan+=dis;\n\tvis[x]=1;\n\tfor(long long i=fir[x];i;i=e[i].ne){\n\t\tlong long to=e[i].v;\n\t\tif(!vis[to]){\n\t\t\t//if(vis[to])bo=true;\n\t\t\tcheck(to,dis+1);\n\t\t}\n\t}\n}\nvoid dfs(long long x,long long father){\n\tvis[x]=1;\n\tfor(long long i=fir[x];i;i=e[i].ne){\n\t\tlong long to=e[i].v;\n\t\tif(to!=father&&!vis[to]){\n\t\t\tprintf(\"%lld %lld\\n\",x,to);\n\t\t\tdfs(to,x);\n\t\t}\n\t}\n}\nlong long query(long long sum){\n\tlong long l=1,r=n;\n\twhile(l<r){\n\t\tlong long mid=(l+r+1)>>1;\n\t\tif(a[mid].w>sum)l=mid;\n\t\telse if(a[mid].w<sum)r=mid-1;\n\t\telse {\n\t\t\tl=mid;\n\t\t\treturn a[l].dep;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tscanf(\"%lld\",&n);\n\tfor(long long i=1;i<=n;i++)scanf(\"%lld\",&a[i].w),sz[i]=1,a[i].dep=i;\n\tsort(a+1,a+n+1,cmp);\n\tfor(long long i=1;i<=n;i++){\n\t\tlong long tmp=n-2*sz[a[i].dep];\n\t\tlong long father=query(a[i].w-tmp);\n\t\tsz[father]+=sz[a[i].dep];\n/*\t\tif(!father){\n\t\t\tif(root){\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\troot=a[i].dep;\n\t\t}\n*/\t\tif(i!=n){\n\t\t\tadd(a[i].dep,father);\n\t\t\tadd(father,a[i].dep);\n\t\t}\n\t}\n\troot=a[n].dep;\n\tcheck(root,0);\n\tif(bo){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(long long i=1;i<=n;i++)if(!vis[i]){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tif(pan!=a[n].w){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tmemset(vis,0,sizeof(vis));\n\tdfs(root,0);\n}"
  },
  {
    "language": "C++",
    "code": "// Ho-kago Tea Time\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MAXN = (int) 1e5;\n\nint n;\n\nstruct node\n{\n\tint u;\n\tLL D;\n\n\tinline bool operator < (const node &rhs) const { return this->D < rhs.D; }\n\n\tnode() { }\n\tnode(int _u, LL _D): u(_u), D(_D) { }\n}d[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tfor(int i = 1; i <= n; ++i) d[i] = node(i, read<LL>());\n}\n\ninline void solve()\n{\n\tstatic priority_queue<node> Q;\n\tstatic unordered_map<LL, int> id;\n\tstatic int size[MAXN + 5], vis[MAXN + 5];\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tQ.push(d[i]);\n\t\tid[d[i].D] = d[i].u;\n\t\tsize[d[i].u] = 1;\n\t}\n\n\tstatic vector<pii> E;\n\n\twhile(SZ(Q) > 1)\n\t{\n\t\tint u = Q.top().u;\n\t\tLL D = Q.top().D;\n\t\tvis[u] = 1, Q.pop();\n\n\t\tint v = id[D + 2 * size[u] - n];\n\t\tif(!v || vis[u]) { puts(\"-1\"); return; }\n\t\tE.emplace_back(u, v), size[v] += size[u];\n\t}\n\tfor(auto i : E) printf(\"%d %d\\n\", i.fst, i.snd);\n}\n\nint main()\n{\n#ifdef K_ON // K-ON!\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long n, sz[100010];\nlong long d[100010];\nmap<long long, long long> mp;\nvector<pair<long long, long long>> ans;\n\nint main()\n{\n    scanf(\"%lld\", &n);\n    for (int i = 1; i <= n; i++)\n    {\n        scanf(\"%lld\", &d[i]);\n        mp[d[i]] = i;\n        sz[i] = 1;\n    }\n    for (int i = 1; i < n; i++)\n    {\n        auto it = mp.rbegin();\n        long long hh = it->first + 2 * sz[it->second] - n;\n        // printf(\"%d %d\\n\", mp[hh], it->second);\n        if (!mp.count(hh) || hh == it->first)\n        {\n            puts(\"-1\");\n            return 0;\n        }\n        ans.emplace_back(mp[hh], it->second);\n        sz[mp[hh]] += sz[it->second];\n        mp.erase(it->first);\n    }\n    for (auto x : ans) printf(\"%lld %lld\\n\", x.first, x.second);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\n\ntypedef long long ll;\ntypedef pair<ll, int> pi;\n\nmap<ll, int> mp;\nconst int maxn = 1e5 + 5;\nint sz[maxn];\nll d[maxn];\nll dp[maxn];\nll dp1[maxn];\nvector<int> G[maxn];\n\nvoid dfs(int u){\n    sz[u] = 1;\n    for(auto v : G[u]){\n        dfs(v);\n        sz[u] += sz[v];\n        dp[u] += dp[v] + sz[v];\n    }\n}\n\nvoid dfs1(int u){\n    ll sum = 0;\n    ll sum1 = 0;\n    for(auto v : G[u]){\n        sum += dp[v];\n        sum1 += sz[v];\n    }\n    for(auto v : G[u]){\n        dp1[v] = dp1[u] + sum - dp[v] + sum1 - sz[v] + n - sz[v];\n    }\n    for(auto v : G[u]){\n        dfs1(v);\n    }\n}\n\nbool check(int root){\n    dfs(root);\n    dfs1(root);\n    for(int i = 1;i <= n;i++){\n        if(dp[i] + dp1[i] != d[i])\n            return false;\n    }\n    return true;\n}\n\nint main(){\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    cin >> n;\n    priority_queue<pi> pq;\n    for(int i = 1;i <= n;i++){\n        cin >> d[i];\n        mp[d[i]] = i;\n        pq.push({d[i], i});\n        sz[i] = 1;\n    }\n    bool flag = true;\n    int root = 0;\n    while(!pq.empty()){\n        pi p = pq.top(); pq.pop();\n        ll dis = p.first;\n        int id = p.second;\n        if(sz[id] == n){\n            root = id;\n            break;\n        }\n        ll dis1 = dis - (n - 2 * sz[id]);\n        if(mp.find(dis1) == mp.end()){\n            flag = false;\n            break;\n        }else{\n            int fa = mp[dis1];\n            if(fa == id){\n                flag = false;\n                break;\n            }\n            G[fa].push_back(id);\n            sz[fa] += sz[id];\n        }\n    }\n    if(flag){\n        flag &= check(root);\n    }\n    if(flag){\n        for(int i = 1;i <= n;i++){\n            for(auto v : G[i]){\n                cout << i << \" \" << v << endl;\n            }\n        }\n    }else{\n        cout << -1 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nProblem: Distance Sums (AtCoder 4434)\nAlgorithm: Math??Graph??\nStatus:\n*/\n\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <deque>\n#include <set>\n#include <sstream>\n#include <utility>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <stack>\n#include <stdio.h>\n#include <string.h>\n\nusing namespace std;\n\n#define INF 1000000007\ntypedef long long ll;\n\nint n;\nmap<ll,int> d;\nvector<pair<ll,int> > ev;\nvector<pair<int,int> > ans;\nll dp[100005],sz[100005];\n\nvoid bye(){\n\tcout<<-1<<endl;\n\texit(0);\n}\n\nint main()\n{\n\t#ifndef ZZZYT\n\t\t//freopen(\".in\",\"r\",stdin);\n\t\t//freopen(\".out\",\"w\",stdout);\n\t#endif\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tll tmp;\n\t\tscanf(\"%lld\",&tmp);\n\t\tev.push_back(make_pair(tmp,i));\n\t\td[tmp]=i;\n\t}\n\tsort(ev.rbegin(),ev.rend());\n\tll center=ev.back().first;\n\tfor(int i=0;i<n;i++)sz[i]=1;\n\tfor(int i=0;i<ev.size();i++){\n\t\tint x=ev[i].second;\n\t\tll s=ev[i].first;\n\t\tif(s!=center){\n\t\t\tif(sz[x]*2>=n)bye();\n\t\t\tll ps=s+sz[x]-(n-sz[x]);\n\t\t\tif(d.count(ps)==0)bye();\n\t\t\tint p=d[ps];\n\t\t\tsz[p]+=sz[x];\n\t\t\tdp[p]+=dp[x]+sz[x];\n\t\t\tans.push_back(make_pair(x,p));\n\t\t}\n\t}\n\tif(dp[ev.back().second]!=center)bye();\n\tfor(int i=0;i<ans.size();i++){\n\t\tprintf(\"%d %d\\n\",ans[i].first+1,ans[i].second+1);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100010;\n\ntypedef long long ll;\n\npriority_queue<ll> pq;\nmap<ll, int> mp;\n\nint n, l[maxn], dep[maxn], sz[maxn], w[maxn], vis[maxn], e_u[maxn], e_v[maxn], tot, e = 0;\nll D[maxn], S[maxn];\n\nstruct Edge {\n    int v, x;\n} E[maxn];\n\ninline void addEdge(int u, int v) {\n    E[e].v = v; E[e].x = l[u]; l[u] = e++;\n}\n\nvoid dfs1(int u) {\n    sz[u] = 1;\n    for (int p = l[u]; p >= 0; p = E[p].x) {\n        int v = E[p].v;\n        dep[v] = dep[u] + 1;\n        dfs1(v);\n        sz[u] += sz[v];\n    }\n}\n\nvoid dfs2(int u) {\n    for (int p = l[u]; p >= 0; p = E[p].x) {\n        int v = E[p].v;\n        S[v] = S[u] + n - 2 * sz[v];\n        dfs2(v);\n    }\n}\n\nint main() {\n    memset(l, -1, sizeof(l));\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) scanf(\"%lld\", &D[i]);\n    for (int i = 1; i <= n; i++) {\n        mp[D[i]] = i;\n        pq.push(D[i]);\n        w[i] = 1;\n    }\n    vis[0] = 1;\n    while (pq.size() > 1) {\n        ll v = pq.top(); pq.pop();\n        int u = mp[v];\n        vis[u] = 1;\n        if (!vis[mp[v + 2 * w[u] - n]]) {\n            int t = mp[v + 2 * w[u] - n];\n            w[t] += w[u];\n            addEdge(t, u);\n            ++ tot;\n            e_u[tot] = t; e_v[tot] = u;\n        } else {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    int r = mp[pq.top()];\n    dfs1(r);\n    for (int i = 1; i <= n; i++) S[r] += dep[i];\n    dfs2(r);\n    for (int i = 1; i <= n; i++) {\n        if (S[i] != D[i]) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    for (int i = 1; i <= tot; i++) printf(\"%d %d\\n\", e_u[i], e_v[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=1e5+10;\nint n,cnt,e,f[N],a[N],id[N],w[N],siz[N],res[N],head[N],link[N],to[N];\nbool vis[111111];\nbool cmp(int x,int y){return a[x]<a[y];}\nvoid add(int u,int v){to[++e]=v,link[e]=head[u],head[u]=e;}\nvoid dfs1(int u){\n\tsiz[u]=1;\n\tfor(int i=head[u];i;i=link[i])if(to[i]!=f[u])dfs1(to[i]),siz[u]+=siz[to[i]];\n}\nvoid dfs2(int u){for(int i=head[u];i;i=link[i])if(to[i]!=f[u])res[to[i]]=res[u]+n-2*siz[to[i]],dfs2(to[i]);}\nsigned main(){\n\tscanf(\"%d\",&n),w[0]=-LLONG_MAX;\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]),id[i]=i,w[i]=a[i],siz[i]=1;\n\tsort(id+1,id+n+1,cmp),sort(w+1,w+n+1);\n\tfor(int i=n;i>1;i--){\n\t\tint x=2*siz[id[i]]-n+a[id[i]],pos=lower_bound(w+1,w+n+1,x)-w;\n\t\tif(w[pos]!=x||n-2*siz[id[i]]<=0){printf(\"-1\");return 0;}\n\t\tadd(id[pos],id[i]),siz[id[pos]]+=siz[id[i]],f[id[i]]=id[pos];\n\t}\n\tres[id[1]]=w[1],dfs1(id[1]),dfs2(id[1]);\n\tfor(int i=1;i<=n;i++)if(a[i]!=res[i])printf(\"-1\");return 0;\n\tfor(int i=2;i<=n;i++)printf(\"%d %d\\n\",f[id[i]],id[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> ii;\ntypedef vector<ll> vi;\ntypedef vector<ii> vii;\n#define REP(i,n) for (ll i = 0; i < n; ++i)\n#define REPR(i,n) for (ll i = n-1; i >= 0; --i)\n#define FOR(i,m,n) for (ll i = m; i < n; ++i)\n#define FORR(i,m,n) for (ll i = n-1; i >= m; --i)\n#define FORE(x,xs) for (const auto& x : xs)\n#define PB push_back\n#define MP make_pair\n#define ALL(v) v.begin(), v.end()\n\nconst int MAX = 1e5+10;\nint N;\nvi D, c, p;\nvii P;\nvi children[MAX];\n\nii dfs(int n) {\n    int cnt = 0;\n    ll res = 0;\n    FORE (ch, children[n]) {\n        ii r = dfs(ch);\n        cnt += r.first;\n        res += r.second;\n    }\n    res += cnt;\n    return MP(cnt+1, res);\n}\n\nint main () {\n    cin >> N;\n    D = vi(N);\n    c = vi(N, 1);\n    p = vi(N, -1);\n    REP (i, N) {\n        cin >> D[i];\n        P.PB(MP(D[i], i+1));\n    }\n    sort(ALL(D));\n    sort(ALL(P));\n    FORR (i, 1, N) {\n        ll d = D[i] - N + 2*c[i];\n        auto it = lower_bound(ALL(D),d);\n        if (it == D.end() || *it != d) {\n            cout << -1 << endl;\n            return 0;\n        }\n        int j = it-D.begin();\n        c[j] += c[i];\n        p[i] = j;\n        children[j].PB(i);\n    }\n    if (dfs(0).second != D[0]) {\n        cout << -1 << endl;\n        return 0;\n    }\n    REP (i, N) if (p[i] != -1) {\n        cout << P[p[i]].second << \" \" << P[i].second << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n#include <numeric>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tmap<long long int, int> d_map;\n\tfor(int i = 0; i < n; i++){\n\t\tlong long int tmp;\n\t\tcin >> tmp;\n\t\td_map.insert(make_pair(tmp, i));\n\t}\n\tvector<long long int> s(n, 1);\n\tset<pair<int, int> > ans;\n\tfor(auto i = d_map.rbegin(); i != d_map.rend(); i++){\n\t\tint now = i->second;\n\t\tlong long int nowd = i->first;\n\t\tlong long int nextd = nowd + 2 * s[now] - n;\n\t\tif(nextd >= nowd || d_map.find(nextd) == d_map.end()) continue;\n\t\tint next = d_map[nextd];\n\t\ts[next] += s[now];\n\t\tans.insert(make_pair(min(now, next), max(now, next)));\n\t}\n\tif(ans.size() != n - 1){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tfor(auto i = ans.begin(); i != ans.end(); i++){\n\t\tcout << i->first + 1 << \" \" << i->second + 1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ljc 998244353\n#define int long long\nusing namespace std;\n#define gc getchar\ninline ll read(){\n    register ll x=0,f=1;char ch=gc();\n    while (!isdigit(ch)){if (ch=='-') f=-1;ch=gc();}\n    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}\n    return (f==1)?x:-x;\n}\nint n;\nstruct node{\n\tll x;\n\tint id;\n}x[1010101];\ninline bool cmp(node a,node b){\n\treturn a.x>b.x;\n}\nint sz[1010101];\nmap<ll,int> mp;\nvector<pair<int,int> > as;\nsigned main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++) x[i].x=read(),x[i].id=i,sz[i]=1,mp[x[i].x]=i;\n\tsort(x+1,x+1+n,cmp);\n\tif (n==1){\n\t\tputs(x[1].x==0?\"\":\"-1\");\n\t\treturn 0;\n\t}\n\tif (n==2){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++){\n\t\tif (!mp.count(x[i].x-n+sz[x[i].id]+sz[x[i].id])){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint faa=mp[x[i].x-n+sz[x[i].id]+sz[x[i].id]];\n\t\tas.push_back(make_pair(faa,x[i].id));\n\t\tsz[faa]+=sz[x[i].id];\n\t}\n\tfor (auto i:as) printf(\"%d %d\\n\",i.first,i.second);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#define int long long\nint n,sz[100100],u[100100],v[100100],head[100100],cnt,D;\nstruct Edge{\n\tint to,nxt;\n}edge[200100];\nstruct node{\n\tint dis,x;\n\tbool operator<(node b)const{\n\t\treturn dis>b.dis;\n\t}\n}a[100100];\nmap<int,int>mp;\nvoid addedge(int x,int y){\n\tedge[++cnt].to=y;\n\tedge[cnt].nxt=head[x];\n\thead[x]=cnt;\n}\nint dfs(int x,int fa,int now){\n\tD+=now;\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tint upup=edge[i].to;\n\t\tif(upup==fa)continue;\n\t\tdfs(upup,x,now+1);\n\t}\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i].dis);\n\t\ta[i].x=i;\n\t\tmp[a[i].dis]=i;\n\t}\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)sz[i]=1;\n\tfor(int i=1;i<n;i++){\n\t\tint dis=a[i].dis,x=a[i].x;\n\t\tint tmp=dis-abs(n-2*sz[x]);\n\t\tint fa=mp.find(tmp)->second;\n\t\tif(fa==x||!fa)return puts(\"-1\"),0;\n\t\tsz[fa]+=sz[x];\n\t\tu[i]=x,v[i]=fa;\n\t\taddedge(x,fa);\n\t\taddedge(fa,x);\n\t}\n\t//dfs(a[n].x,0,0);\n\tif(D!=a[n].dis)return puts(\"-1\"),0;\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%lld %lld\\n\",u[i],v[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+5;\nlong long a[N];\nmap<long long,int>ma;\nint n,b[N],vi[N],si[N],fa[N];\nbool com(int x,int y){\n\treturn a[x]>a[y];\n}\nint now,v[N],nex[N],head[N];\nvoid addedges(int x,int y){\n\tnex[++now]=head[x];\n\thead[x]=now,v[now]=y;\n}\nlong long dfs(int x,int deep){\n\tlong long ans=deep;\n\tfor(int i=head[x];i;i=nex[i])\n\t\tans+=dfs(v[i],deep+1);\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i]);\n\t\tma[a[i]]=b[i]=i;\n\t}\n\tsort(b+1,b+n+1,com),vi[0]=1;\n\tfor(int i=1;i<=n;i++)\tsi[i]=1;\n\tfor(int i=1;i<n;i++){\n\t\tint k=ma[a[b[i]]-n+si[b[i]]*2];\n\t\tfa[b[i]]=k,si[k]+=si[b[i]],vi[b[i]]=1;\n\t\tif(vi[k]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++)\n\t\taddedges(fa[b[i]],b[i]);\n\tif(dfs(b[n],0)!=a[b[n]]){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d %d\\n\",b[i],fa[b[i]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nstruct node{\n\tint u;\n\tlong long d;\n\tbool operator<(node b) const\n\t{\n\t\treturn d<b.d;\n\t}\n};\nnode nn[131072];\nint size[131072],fa[131072],d[131072];\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tnn[i].u=i;\n\t\tscanf(\"%lld\",&nn[i].d);\n\t\tsize[i]=1;\n\t}\n\tsort(nn+1,nn+n+1);\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tint l=1,r=i-1;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(nn[mid].d==nn[i].d+size[i]-(n-size[i]))\n\t\t\t{\n\t\t\t\tfa[i]=mid;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(nn[mid].d>nn[i].d+size[i]-(n-size[i]))\n\t\t\t{\n\t\t\t\tr=mid-1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tl=mid+1;\n\t\t\t}\n\t\t}\n\t\tif(!fa[i])\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tsize[fa[i]]+=size[i];\n\t}\n\tlong long sd=0;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\td[i]=d[fa[i]]+1;\n\t\tsd+=d[i];\n\t}\n\tif(sd!=nn[1].d)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tprintf(\"%d %d\\n\",nn[fa[i]].u,nn[i].u);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n\n#define X first\n#define Y second\n\n//#include <boost/unordered_map.hpp>\n//using namespace boost;\n\n/*\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> rbtree;\nrbtree T;\n*/\n\nnamespace io{\n\tconst int L = (1 << 20) + 1;\n\t\n\tchar buf[L], *S , *T, c;\n\t \n\tchar getchar() {\n\t\tif(__builtin_expect(S == T, 0)) {\n\t\t\tT = (S = buf) + fread(buf, 1, L, stdin);\n\t\t\treturn (S == T ? EOF : *S++);\n\t\t}\n\t\treturn *S++;\n\t}\n\t\n\tint inp() {\n\t\tint x = 0, f = 1; char ch;\n\t\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\t\tif(ch == '-') f = -1;\n\t\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\t\treturn x * f;\n\t}\n\t\n\tunsigned inpu()\n\t{\n\t\tunsigned x = 0; char ch;\n\t\tfor(ch = getchar(); !isdigit(ch); ch = getchar());\n\t\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\t\treturn x;\n\t}\n\t\n\tll inp_ll() {\n\t\tll x = 0; int f = 1; char ch;\n\t\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\t\tif(ch == '-') f = -1;\n\t\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\t\treturn x * f;\n\t}\n\t\n\tchar B[25], *outs=B+20, *outr=B+20;\n\ttemplate<class T>\n\tinline void print(register T a,register char x=0){\n\t\tif(x) *--outs = x, x = 0;\n\t\t\n\t\tif(!a)*--outs = '0';\n\t\telse \n\t\t\twhile(a)\n\t\t\t\t*--outs = (a % 10) + 48, a /= 10;\n\t\t\n\t\tif(x)\n\t\t\t*--outs = x;\n\t\t\n\t\tfwrite(outs, outr - outs , 1, stdout);\n\t\touts = outr;\n\t}\n};\n\nusing io :: print;\nusing io :: inp;\nusing io :: inpu;\nusing io :: inp_ll;\n\nusing i32 = int;\nusing i64 = long long;\nusing u8 = unsigned char;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing f64 = double;\nusing f80 = long double;\n\nll power(ll a, ll b, ll p)\n{\n\tif (!b) return 1;\n\tll t = power(a, b/2, p);\n\tt = t*t%p;\n\tif (b&1) t = t*a%p;\n\treturn t;\n}\n\nconst int MAXN = 200010;\nconst u64 MOD = 1000000007;\nconst f80 MI = f80(1)/MOD;\nconst int INF = 1000000010;\n\nvector<pii> ans;\n\nvoid addedge(int x, int y)\n{\n\tans.emplace_back(x, y);\n\t// printf(\"%d %d\\n\", x, y);\n}\n\npriority_queue<pll, vector<pll>, greater<pll> > H[2];\nint n;\nll d[MAXN], size[MAXN];\n\nint main()\n{\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++ i)\n\t{\n\t\tscanf(\"%lld\", &d[i]);\n\t\tH[d[i]%2].emplace(d[i], i);\n\t}\n\tint r1 = H[0].top().Y, r2 = H[1].top().Y;\n\tint y = (d[r1] < d[r2]) ? r1 : r2;\n\tif (y == r1) H[0].pop();\n\tif (y == r2) H[1].pop();\n\tsize[y] = n;\n\tqueue<int> Q;\n\tQ.push(y);\n\twhile (!Q.empty())\n\t{\n\t\tint y = Q.front();\n\t\tQ.pop();\n\t\tint k = (n+d[y])%2;\n\t\twhile (size[y] > 1)\n\t\t{\n\t\t\tif (H[k].empty())\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint x = H[k].top().Y;\n\t\t\tH[k].pop();\n\t\t\taddedge(x, y);\n\t\t\tsize[x] = (n+d[y]-d[x])/2;\n\t\t\tsize[y] -= size[x];\n\t\t\tQ.push(x);\n\t\t}\n\t\tif (size[y] != 1)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tfor (auto p : ans)\n\t\tprintf(\"%d %d\\n\", p.X, p.Y);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,int>P;\n\nint n;\nP d[200000];\nvector<int>E[200000];\nint sz[200000];\nll dp1[200000];\nvector<pair<int,int>>ans;\n\nvoid dfs1(int v){\n\tfor(int u:E[v]){\n\t\tdfs1(u);\n\t\tans.push_back({v+1,u+1});\n\t\tdp1[v]+=dp1[u]+sz[u];\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%lld\",&d[i].first);\n\t\td[i].second=i;\n\t}\n\trep(i,n)sz[i]=1;\n\tsort(d,d+n);\n\tfor(int i=n-1;i>0;i--){\n\t\tll c=d[i].first-n+2*sz[d[i].second];\n\t\tint id=lower_bound(d,d+n,P(c,0))-d;\n\t\tif(id==n||d[id].first!=c){\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t\tE[d[id].second].push_back(d[i].second);\n\t\tsz[d[id].second]+=sz[d[i].second];\n\t}\n\tdfs1(d[0].second);\n\tif(dp1[d[0].second]!=d[0].first){\n\t\tputs(\"-1\");return 0;\n\t}\n\tfor(auto p:ans){\n\t\tprintf(\"%d %d\\n\",p.first,p.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\nconst int N = 100'009;\n\nlong long a[N];\nint o[N];\nint cnt[N];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  map<long long, int> w;\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%lld\", a + i);\n    w[a[i]] = i;\n  }\n  for (int i = 0; i < n; ++i) {\n    o[i] = i;\n  }\n  sort(o, o + n, [](int i, int j) {\n    return a[i] > a[j];\n  });\n  for (int i = 0; i < n; ++i) {\n    cnt[i] = 1;\n  }\n  vector<pair<int, int>> ans;\n  for (int i = 0; i < n - 1; ++i) {\n    int x = o[i];\n    long long v = a[x] - (n - (cnt[x] + 1)) + (cnt[x] - 1);\n    if (v >= a[x] || w.count(v) == 0) {\n      puts(\"-1\");\n      return 0;\n    }\n    int y = w[v];\n    ans.emplace_back(x, y);\n    cnt[y] += cnt[x];\n  }\n  for (auto &e : ans) {\n    printf(\"%d %d\\n\", e.first + 1, e.second + 1);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define snd second\n#define pb(a) push_back(a)\n#define mp(a, b) std::make_pair(a, b)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\nconst int oo = 0x3f3f3f3f;\n\nstring procStatus() {\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\n\ntemplate <typename T> T read(T& x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    for(;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n    return x *= f;\n}\n\nconst int N = 100000;\n\nstruct node {\n    ll d;\n    int id; \n\n    bool operator < (const node& rhs) const {\n        return d > rhs.d;\n    }\n};\n\nint n;\nnode t[N + 5];\nint fa[N + 5], sz[N + 5];\nstd::map <ll, int> mp;\n\nint main() {\n#ifdef Wearry\n    freopen(\"in\", \"r\", stdin);\n    freopen(\"out\", \"w\", stdout);\n#endif\n\n    read(n);\n    for(int i = 1; i <= n; ++i) {\n        read(t[i].d), t[i].id = i;\n    }\n\n    std::sort(t + 1, t + n + 1);\n\n    for(int i = 1; i <= n; ++i) mp[t[i].d] = i;\n    for(int i = 1; i < n; ++i) {\n        ++ sz[i];\n        fa[i] = mp[t[i].d - n + 2 * sz[i]];\n        if(!fa[i]) return !puts(\"-1\");\n        sz[fa[i]] += sz[i];\n        t[n].d -= sz[i];\n    }\n\n    if(t[n].d) return puts(\"-1\");\n\n    for(int i = 1; i < n; ++i) {\n        printf(\"%d %d\\n\", t[i].id, t[fa[i]].id);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#include <numeric>\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef long double ld;\ntypedef complex<ld> com;\nconstexpr int inf = 1000000000;\nconstexpr ll INF = 1000000000000000000;\nconstexpr ld EPS = 1e-12;\nconstexpr ld PI = 3.141592653589793238;\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\n\tint n;\n\tcin >> n;\n\tvector<ll> d(n);\n\tmap<ll, int> mp;\n\trep(i, n) {\n\t\tcin >> d[i];\n\t\tmp[d[i]] = i;\n\t}\n\tsort(all(d));\n\tvector<int> sz(n, 1);\n\tvector<P> ans;\n\tvector<vector<int>> graph(n, vector<int>());\n\tfor (int i = n - 1; i >= 1; i--) {\n\t\tint v = mp[d[i]];\n\t\tll dis = n - sz[v] * 2;\n\t\tll par = d[i] - dis;\n\t\tll idx = lower_bound(all(d), par) - d.begin();\n\t\tif (dis <= 0 || d[idx] != par) {\n\t\t\tcout << -1 << '\\n';\n\t\t\treturn 0;\n\t\t}\n\t\tans.pb(P(mp[d[idx]] + 1, v + 1));\n\t\tgraph[mp[d[idx]]].pb(v);\n\t\tgraph[v].pb(mp[d[idx]]);\n\t\tsz[mp[d[idx]]] += sz[v];\n\t}\n\tint root = mp[d[0]];\n\tll sum = 0;\n\tqueue<P> que;\n\tvector<bool> vis(n);\n\tque.push(P(root, 0)); vis[0] = true;\n\twhile (!que.empty()) {\n\t\tP p = que.front(); que.pop();\n\t\tint pf = p.first; int ps = p.second;\n\t\tsum += ps;\n\t\tfor (int i : graph[pf]) {\n\t\t\tif (vis[i]) continue;\n\t\t\tque.push(P(i, ps + 1));\n\t\t\tvis[i] = true;\n\t\t}\n\t}\n\tif (sum != d[0]) cout << -1 << '\\n';\n\telse for (P p : ans) cout << p.first << ' ' << p.second << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#include <functional>\n#include <bitset>\n\n#define repeat(i,n) for (long long i = 0; (i) < (n); ++ (i))\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i] << '\\n'\n#define debugArrayP(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i].first<< \" \" << x[i].second << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\nconst ll INF = LLONG_MAX/10;\nconst ll MOD = 1e9+7;\n\nint main(){\n  int N;cin>>N;\n  vector<pair<ll,int>> D(N);\n  repeat(i,N){\n    cin >> D[i].first;\n    D[i].second = i+1;\n  }\n  sort(D.begin(),D.end());\n  vll n(N,1);\n  vector<Pii> edges;\n  bool isok = true;\n  for(int i=N-1;i>0;i--){\n    debug(i);\n    ll S = D[i].first+2*n[i]-N;\n    int j = lower_bound(D.begin(),D.end(),pair<ll,int>(S,0))-D.begin();\n    if(j>=i || D[j].first != S){\n      isok = false;\n      break;\n    }\n    edges.push_back({D[i].second,D[j].second});\n    n[j]+=n[i];\n  }\n  if(!isok){\n    cout <<-1<<endl;\n    return 0;\n  }\n  repeat(i,edges.size()){\n    cout << edges[i].first<<\" \"<<edges[i].second<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<map>\n#define rep(i,x,y) for(int i=(x);i<=(y);i++)\nusing namespace std;\ntypedef long long ll;\nint n;\nconst int N=200005;\nmap<long long,int> mp;\nint a[N],id[N];\nint fa[N],size[N];\nbool cmp(int x,int y){return a[x]>a[y];}\nint main()\n{\n//freopen(\"input.txt\",\"r\",stdin);\nios::sync_with_stdio(false);\ncin.tie(0);\nint n;\ncin >>n;\nrep(i,1,n)cin >>a[i],id[i]=i,mp[a[i]]=i,size[i]=1;\nsort(id+1,id+1+n,cmp);\nrep(i,1,n-1)\n\t{\n\tint x=id[i];\n\tfa[x]=mp[a[x]-n+2*size[x]];\n\tif(!fa[x])return cout <<-1,0;\n\tsize[fa[x]]+=size[x];\n\t}\nrep(i,1,n-1)\n\t{\n\ta[id[n]]-=size[id[i]];\n\t}\nif (a[id[n]]) return puts(\"-1\"),0;\nrep (i,1,n-1) cout <<id[i]<<' '<<fa[id[i]]<<'\\n';\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// LightOj Pass : qavajxyq\n\n#include <bits/stdc++.h>\n#define deb(x)     cerr << (#x) << \" : \" << x << \"\\n\"\n#define ll long long int\n#define ld long double\nusing namespace std;\nconst ll MOD = 1e9 + 7 ;\nconst ll INF = 1e18;\n\nll powmod(ll a, ll b, ll mod = MOD){\n\tll res = 1ll;\n\tb %= (mod - 1ll), a %= mod;\n\twhile(b){\n\t\tif(b%2 == 1)\tres = (res * a) % mod;\n\t\ta = (a * a) % mod;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nll d[300000];\nll n;\n\nbool comp(int a, int b){\n\treturn d[a] < d[b];\n}\n\nvector<vector<int>> edges;\nint cnt = 0;\nll res = 0;\nll tree[400000];\nbool visited[4000000];\nbool state = true;\n\nvoid dfs(int u, int par = -1, ll dpth = 0){\n\tcnt++;\n\tres += dpth;\n\ttree[u] = 1;\n\tvisited[u] = true;\n\tint tmp = 0;\n\tfor(auto v : edges[u]){\n\t\tif(!visited[v]){\n\t\t\tdfs(v, u, dpth + 1ll);\n\t\t\ttree[u] += tree[v];\n\t\t}\n\t\telse{\n\t\t\ttmp++;\n\t\t}\n\t}\n\n\tif(tmp > 1)\tstate = false;\n}\n\n\nvoid dfs2(int u, int par = -1, ll ans = res){\n\tif(ans != d[u])\tstate = false;\n\tfor(auto v : edges[u]){\n\t\tif(v != par)\tdfs2(v, u, ans - tree[v] * 2 + n);\n\t}\n}\n\nint main(){\t\n\n \n\tios::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tcin >> n;\n\tedges.resize(n+1);\n\tmemset(visited, false, sizeof(visited));\n\tint arr[n];\n\tmap<ll, int> mp;\n\tll sub[n+1];\n\tfor(int i = 1; i <= n; i++)\tcin >> d[i], arr[i-1] = i, mp[d[i]] = i, sub[i] = 1;\n\n\tsort(arr, arr + n, comp);\n\tbool vis[n+1];\n\tmemset(vis, false, sizeof(vis));\n\n\tint cur, par;\n\tint parent[n];\n\n\tvector<pair<int, int>> edge;\n\tfor(int i = n-1; i >= 0; i--) {\n\t\t\n\t\tif(vis[arr[i]])\tcontinue;\n\t\tcur = arr[i];\n\t\tdeb(cur);\n\t\tvis[cur] = true;\n\t\twhile(cur != 0){\n\t\t\tpar = 0;\n\t\t\tif(mp.count(d[cur] + (2 * sub[cur]) - n) and !vis[ mp[d[cur] + (2 * sub[cur]) - n]])\tpar = mp[d[cur] + (2 * sub[cur]) - n];\n\t\t\tif(par)\tsub[par] += sub[cur], edges[cur].push_back(par), edges[par].push_back(cur), vis[cur] = true, edge.push_back({cur, par});\n\t\t\tcur = par;\n\t\t\tdeb(sub[par]);\n\t\t\tdeb(par);\n\t\t}\n\t}\n\n\tdfs(arr[0]);\n\tif(cnt != n or res != d[arr[0]] or !state)\t{\n\t\tcout << -1;\n\t\treturn 0;\n\t}\n\n\tdfs2(arr[0]);\n\tif(!state){\n\t\tcout << -1;\n\t\treturn 0;\n\t}\n\n\tfor(auto x : edge)\tcout << x.first << \" \" << x.second << \"\\n\"; \n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimiz(O2)\n\n#include <bits/stdc++.h>\n\n#define rg register\nusing namespace std;\ntypedef long long ll;\n\ntemplate<typename T>\ninline bool read(T &n) {\n    T ans = 0, flag = 1;\n    char ch;\n    while ((ch = getchar()) < '0' || ch > '9') if (ch == '-') flag = -1; else if (ch == EOF) return false;\n    ans = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9') ans = ans * 10 + ch - '0';\n    n = ans * flag;\n    return true;\n}\n\ninline ll read() {\n    ll ans = 0, flag = 1;\n    char ch;\n    while ((ch = getchar()) < '0' || ch > '9') if (ch == '-') flag = -1;\n    ans = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9') ans = ans * 10 + ch - '0';\n    return ans * flag;\n};\nconst int maxn = 100005;\nstruct NODE {\n    ll val, ord;\n    bool operator<(NODE b) const {\n        return val < b.val;\n    }\n} node[maxn];\nint siz[maxn],fa[maxn];\nunordered_map<ll,int> unM;\nint main() {\n    int n;\n    read(n);priority_queue<NODE> pq;\n    for (rg int i = 1; i <= n; ++i) {\n        siz[i] = 1;\n        read(node[i].val);\n        node[i].ord = i;\n        pq.push(node[i]);\n        unM[node[i].val]=i;\n    }\n    for(rg int i=n;i>=2;i--){\n        NODE now=pq.top();pq.pop();\n        if(unM.find(now.val+2*siz[now.ord]-n)==unM.end()){\n            puts(\"-1\");return 0;\n        }\n        fa[now.ord]=unM[now.val+2*siz[now.ord]-n];\n        siz[fa[now.ord]]+=siz[now.ord];\n    }\n    for(rg int i=1;i<=n;i++){\n        if(fa[i]) cout<<i<<' '<<fa[i]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "  cin>>n;\n  LL tmp;\n  REP(i,n){\n    cin>>tmp;\n    d.push_back(tmp);\n    init_d.push_back(tmp);\n  }\n  sort(d.begin(),d.end());\n  ind.resize(n);\n  REP(i,n){\n    int min_ind = distance(d.begin(),lower_bound(d.begin(),d.end(),init_d[i]));\n    ind[min_ind] = i+1;\n  }\n  REP(i,n){\n    width.push_back(1);\n  }\n\n  vector<vector<int>> tree(n);\n  REP(i,n-1){\n    LL s = d[n-1-i] - (n - 2*width[n-1-i]);\n    //cerr<<s<<endl;\n    int min_ind2 = distance(d.begin(),lower_bound(d.begin(),d.end(),s));\n    if(d[min_ind2] != s || s > d[n-1-i]){\n      cout<<-1<<endl;\n      return 0;\n     }\n    ans.push_back(make_pair(min_ind2,n-1-i));\n    tree[min_ind2].push_back(n-1-i);\n    //tree[n-1-i].push_back(min_ind2);\n    width[min_ind2] += width[n-1-i];\n  }\n  if(d[0] != dfs(tree,0,0)){\n    cout<<-1<<endl;\n    return 0;\n  }\n  \n  REP(i,ans.size())\n    cout<<ind[ans[i].first]<<\" \"<<ind[ans[i].second]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define F first\n#define S second\nconst int MN = 101234;\n\nint sz[MN], par[MN];\npair <int, int> d[MN];\n\nint32_t main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> d[i].F;\n\t\td[i].S = i;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tsz[i] = 1;\n\tsort(d, d + n);\n\tfor (int i = n - 1; i >= 1; i--) {\n//\t\tcerr << d[i].F << ' ' << d[i].F - n + 2 * sz[i] << endl;\n\t\tint pr = lower_bound(d, d + n, (pair <int, int>){d[i].F - n + 2 * sz[i], 0ll}) - d;\n\t\tif (pr >= i || pr == n || d[pr].F != d[i].F - n + 2 * sz[i])\n\t\t\treturn cout << -1, 0;\n\t\tsz[pr] += sz[i];\n\t\tpar[d[i].S] = d[pr].S;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tcout << par[d[i].S] + 1 << ' ' << d[i].S + 1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nvoid NO(int where = 0) {\n//   dump(where);\n  cout << -1 << endl;\n  exit(0);\n}\n\n// 解けた〜たぴゃ〜\n// D_iは相異なる，まじか〜\n\nconst int N = 1e5;\nvector<vector<int>> g(N);\nusing Value = ll;\nmap<int, Value> dp[N];\nmap<int, int> sz[N];\nint n;\nValue dfs(int i, int p, int f = 0) {\n  if(dp[i].count(p)) return dp[i][p];\n  int cnt = 0;\n  Value res = 0;\n  if(f || p == -1) {\n    // O(deg(i))\n    // go only child\n    sz[i][p] = 1;\n    for(int j : g[i]) if(j != p) {\n      cnt++;\n      res += dfs(j, i, f);\n      res += sz[j][i];\n      sz[i][p] += sz[j][i];\n    }\n  } else {\n    // O(1)\n    dfs(i, -1, f);\n    dfs(p, i, f);\n    res = dp[i][-1] - (dp[p][i] + sz[p][i]);\n    cnt = g[i].size() - 1;\n    sz[i][p] = sz[i][-1] - sz[p][i];\n  }\n  return dp[i][p] = res;\n}\n\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  int n;\n  cin >> n;\n  vector<ll> d(n);\n  for(int i = 0; i < n; i++) cin >> d[i];\n  vector<int> ord(n);\n  iota((ord).begin(), (ord).end(), 0);\n  sort((ord).begin(), (ord).end(), [&](int i, int j) { return d[i] < d[j]; });\n  map<ll, int> mp;\n  for(int i = 0; i < n; i++) mp[d[i]] = i;\n  auto rnk = ord;\n  for(int i = 0; i < n; i++) rnk[ord[i]] = i;\n  vector<int> v(n);\n  vector<pair<int,int>> ans;\n  ll base = n - 2 * (n - 1);\n  for(int i = n - 1; i >= 1; i--) {\n    // dump(d[ord[i]], v[i], i);\n    ll s = d[ord[i]] + (base + v[i] * 2);\n    // dump(s);\n    if(s >= d[ord[i]]) NO(1);\n    if(!mp.count(s)) NO(2);\n    v[rnk[mp[s]]] = v[i] + 1;\n    int a = mp[s], b = ord[i];\n    // dump(a, b);\n    ans.emplace_back(a, b);\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n  // dump(\"here\");\n  dfs(0, -1, 1);\n  for(int i = 0; i < n; i++) if(d[i] != dfs(i, -1, 0)) NO();\n  for(int i = 0; i < n - 1; i++) cout << ans[i].first + 1 << \" \" << ans[i].second + 1 << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\n#define llint long long\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nllint N;\nP D[100005];\nvector<llint> G[100005];\nmap<llint, vector<P> > mp;\n\nP dfs(int v, int prev)\n{\n\tllint d = 0, n = 1;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(G[v][i] == prev) continue;\n\t\tP res = dfs(G[v][i], v);\n\t\tn += res.second;\n\t\td += res.first + res.second;\n\t}\n\treturn make_pair(d, n);\n}\n\nint main(void)\n{\n\tcin >> N;\n\tfor(int i = 1; i <= N; i++) cin >> D[i].first;\n\tfor(int i = 1; i <= N; i++) D[i].second = i;\n\tllint d1 = D[1].first;\n\tsort(D+1, D+N+1), reverse(D+1, D+N+1);\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tllint d = D[i].first, id = D[i].second;\n\t\tif(mp.count(d) == 0){\n\t\t\tif(i != N){\n\t\t\t\tllint p = d-N+2;\n\t\t\t\tif(p > d) continue;\n\t\t\t\tmp[p].push_back(make_pair(id, 1));\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tllint x = 0;\n\t\t\tfor(int j = 0; j < mp[d].size(); j++){\n\t\t\t\tG[id].push_back(mp[d][j].first);\n\t\t\t\tG[mp[d][j].first].push_back(id);\n\t\t\t\tx += mp[d][j].second;\n\t\t\t}\n\t\t\tx++;\n\t\t\tif(i != N){\n\t\t\t\tllint p = d-N+2*x;\n\t\t\t\tif(p > d) continue;\n\t\t\t\tmp[p].push_back(make_pair(id, x));\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*for(auto it = mp.begin(); it != mp.end(); it++){\n\t\t\tcout << it->first << \" \";\n\t\t}\n\t\tcout << endl;*/\n\t}\n\tvector<P> ans;\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\tif(i < G[i][j]) ans.push_back(make_pair(i, G[i][j]));\n\t\t}\n\t}\n\tif(ans.size() < N-1) cout << \"-1\" << endl;\n\telse{\n\t\tif(dfs(1, -1).first != d1) cout << -1 << endl;\n\t\telse for(int i = 0; i < ans.size(); i++) cout << ans[i].first << \" \" << ans[i].second << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <stdio.h>\n# include <bits/stdc++.h>\n\n\n#define _USE_MATH_DEFINES_\n#define ll long long\n#define ld long double\n#define Accepted 0\n#define pb push_back\n#define mp make_pair\n#define sz(x) (int)(x.size())\n#define every(x) x.begin(),x.end()\n#define F first\n#define S second\n#define For(i,x,y)  for (ll i = x; i <= y; i ++) \n#define FOr(i,x,y)  for (ll i = x; i >= y; i --)\n#define SpeedForce ios_base::sync_with_stdio(0), cin.tie(0)\n// ROAD to...                                                                                                                                                                                                                Red\n\nusing namespace std;\n\ninline bool isvowel (char c) {\n\tc = tolower(c);\n    if (c == 'a' || c == 'e' || c == 'i' || c == 'y' || c == 'o' || c == 'u') return 1;\n    return 0;\n}\n\nconst double eps = 0.000001;\nconst ld pi = acos(-1);\nconst int maxn = 1e7 + 9;\nconst int mod = 1e9 + 7;\nconst ll MOD = 1e18 + 9;\nconst ll INF = 1e18 + 123;\nconst int inf = 2e9 + 11;\nconst int mxn = 1e6 + 9;\nconst int N = 6e5 + 123;                                          \nconst int M = 22;\nconst int pri = 997;\nconst int Magic = 2101;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nll a[N], n, sum;\nmap < ll, int > u;\nvector < int > g[N];\nvector < pair < int, int > > edges; \nint cur = 1;\nint l[N];\nint c[N];\nbool cmp (int x,int y) { return a[x] > a[y];}\nvoid dfs (int v, int pr = 0, int dep = 0) {\n    //cout << v << '\\n';\n    sum += dep;\n    for (auto to : g[v]) {\n        if (to == pr) continue;\n        dfs (to, v, dep + 1);\n    }\n}\n\nint main () { \n    cin >> n;\n    For (i, 1, n) {\n        cin >> a[i];\n        u[a[i]] = i;\n        if (a[i] > a[cur]) cur = i;\n        l[i] = 1;\n        c[i] = i;\n    }\n    \n    sort(c + 1, c + n + 1, &cmp);\n    \n    For (x, 1, n - 1) {\n        int i = c[x];\n        //cout << i << ' ' << l[i] << '\\n';\n        ll dis = a[i] - (n - l[i]) + l[i];\n        if (!u.count(dis)) {\n            //cout << n << ' ' << l[i] << '\\n'; \n            //cout << i << ' ' << dis << '\\n';\n            puts(\"-1\");\n            exit(0);\n        }\n        if (i == u[dis]) {\n            //cout << u[dis] << ' ' << dis << '\\n';\n            puts(\"-1\");\n            exit(0);\n        \n        }\n        int j = u[dis];\n\t\tl[j] += l[i];\n\t\tedges.pb(mp(i, j));\n\t\tg[j].push_back(i);\n\t}\n\tcur = c[n];\n    dfs(cur);\n    if (sum != a[c[n]]) {\n        //cout << sum << ' ' << a[c[n]] << '\\n';\n        puts(\"-1\");\n        exit(0);\n    }\n    \n    for (auto it : edges) {\n        cout << it.F << ' ' << it.S << '\\n';\n    }\n    return Accepted;\n}\n\n// Coded By OB"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nint n,size[100005],sa[100005],pa[100005];\nll d[100005];\nbool cmp(int a,int b)\n{\n\treturn d[a]>d[b];\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&d[i]);\n\t\tsa[i]=i;\n\t}\n\tsort(sa+1,sa+n+1,cmp);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x=sa[i];\n\t\tsize[x]++;\n\t\tll a=d[x]-n+2*size[x];\n\t\tint l=i+1,r=n;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(d[sa[mid]]<a)r=mid-1;\n\t\t\telse l=mid+1;\n\t\t}\n\t\tif(d[sa[r]]!=a)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tpa[x]=sa[r];\n\t\tsize[sa[r]]+=size[x];\n\t}\n\tll sum=0;\n\tfor(int i=1;i<n;i++)sum+=size[sa[i]];\n\tif(sum!=d[sa[n]])\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t  if(pa[i])printf(\"%d %d\\n\",i,pa[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#define N 100100\n#define pii pair<ll, int>\nusing namespace std;\ntypedef long long ll;\n\nint n, sz[N], fa[N];\npii p[N];\nvector<int> G[N];\n\nvoid dfs(int u, int d, ll &res) {\n    res += d;\n    for (auto v : G[u])\n        dfs(v, d + 1, res);\n}\n\nint main() {\n#ifdef isLOCAL\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n;\n\n    for (int i = 1; i <= n; ++i) {\n        long long d;\n        scanf(\"%lld\", &d);\n        p[i] = make_pair(d, i);\n    }\n\n    sort(p + 1, p + n + 1);\n\n    for (int i = n; i > 1; --i) {\n        int u = p[i].second, szp;\n        ++sz[u], szp = n - sz[u];\n        ll tmp = p[i].first + n - 2 * szp;\n        int pos = lower_bound(p + 1, p + n + 1, make_pair(tmp, 0)) - p;\n        pii now = p[pos];\n        if (pos >= i || now.first != tmp) return puts(\"-1\"), 0;\n        sz[fa[u] = now.second] += sz[u];\n        G[fa[u]].push_back(u);\n    }\n\n    int rt = p[1].second;\n    ll tmp = 0;\n    dfs(rt, 0, tmp);\n    if (tmp != p[1].first) return puts(\"-1\"), 0;\n\n    for (int i = n; i > 1; --i)\n        printf(\"%d %d\\n\", p[i].second, fa[p[i].second]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = int(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\nusing ll = long long;\nusing namespace std;\n\nvector<pair<int, int> > solve(int n, vector<ll> const & d) {\n    map<ll, int> index;\n    REP (i, n) {\n        index[d[i]] = i;\n    }\n\n    int root = index.begin()->second;\n    vector<pair<int, int> > edges;\n    vector<vector<int> > children(n);\n    vector<int> size(n, 1);\n    for (auto it = index.rbegin(); ; ++ it) {\n        ll d_i; int i; tie(d_i, i) = *it;\n        if (i == root) break;\n        int d_parent = d_i - (n - size[i]) + size[i];\n        if (not index.count(d_parent)) {\n            return vector<pair<int, int> >();\n        }\n        int parent = index[d_parent];\n        edges.emplace_back(parent, i);\n        children[parent].push_back(i);\n        size[parent] += size[i];\n    }\n\n    vector<ll> d1(n);\n    function<void (int)> fold = [&](int i) {\n        for (int j : children[i]) {\n            fold(j);\n            d1[i] += d1[j] + size[j];\n        }\n    };\n    fold(root);\n    function<void (int, int)> reroot = [&](int i, int parent) {\n        if (parent != -1) {\n            d1[i] = d1[parent] - size[i] + (n - size[i]);\n        }\n        for (int j : children[i]) {\n            reroot(j, i);\n        }\n    };\n    reroot(root, -1);\n    if (d != d1) {\n        assert (false);\n        return vector<pair<int, int> >();\n    }\n\n    return edges;\n}\n\nint main() {\n    int n; cin >> n;\n    vector<ll> d(n);\n    REP (i, n) cin >> d[i];\n    auto edges = solve(n, d);\n    if (edges.empty()) {\n        cout << -1 << endl;\n    } else {\n        for (auto edge : edges) {\n            int i, j; tie(i, j) = edge;\n            cout << i + 1 << ' ' << j + 1 << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <string.h>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <cassert>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <sstream>\n#include <functional>\n#include <iomanip>\n#include <bitset>\n//#include <windows.h>  //Should be deleted when using AtCoder&POJ\nusing namespace std;\n\n#define ll long long\n#define pii pair<int,int>\n#define qi ios::sync_with_stdio(0)\n/**==Info==\n*Program:6\n*Problem:Distance Sums\n*Date:2019-7-12\n*Algorithm:Orange Boy's Greedy and Sorting\n*Stats:Unknown*/\n\nbool debug=false;\n\n\ntemplate<typename T1,typename T2> ostream& operator<<(ostream& o,pair<T1,T2> p){\n\to<<\"{\";\n\to<<p.first<<\",\"<<p.second;\n\to<<\"}\";\n\treturn o;\n}\n\nll n;\nll d[100005];\nmap <ll,ll> m;\npair<ll,ll> p[100005];\nll sub[100005];\nll sz[100005];\nvector <pair<ll,ll> >res;\n \nint main()\n{\n//\tfreopen(\"input.txt\",\"r\",stdin);\n\tios_base::sync_with_stdio(false);\n\tcin>>n;\n\tfor(ll i=0;i<n;i++)\n\t{\n\t\tcin>>d[i];\n\t\tif(d[i]>n*(n-1)/2){\n\t\t\tcout<<-1;\n\t\t\treturn 0;\n\t\t}\n\t\tm[d[i]]=i;\n\t\tp[i].first=d[i];\n\t\tp[i].second=i;\n\t\tsz[i]=1;\n\t}\n\tsort(p,p+n);\n\treverse(p,p+n);\n\tmemset(sub,-1,sizeof(sub));\n\tfor(ll i=0;i<n-1;i++)\n\t{\n\t\tll de=p[i].first;\n\t\tll x=p[i].second;\n\t\tsub[x]=n-sz[x]*2;\n\t\tif(sub[x]==0){\n\t\t\tcout<<-1;\n\t\t\treturn 0;\t\n\t\t}\n\t\tif(m.find(de-sub[x])==m.end()){\n\t\t\tcout<<-1;\n\t\t\treturn 0;\n\t\t}\n\t\tll par=m[de-sub[x]];\n\t\tsz[par]+=sz[x];\n\t\tres.push_back(mp(x,par));\n\t}\n\t\n\t\n\tfor(ll i=0;i<n-1;i++)\n\t{\n\t\tcout<<res[i].first+1<<\" \"<<res[i].second+1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\nusing namespace std;\nlong long n,d[100005];\nvector<long long>a,qz,dist,x;\nmap<long long,long long>mp;\nvector<pair<long long,long long> >res;\nvector<vector<long long> >nmp(10005);\nint main(){\n\tcin>>n;\n\tx.push_back(0);\n\tfor(long long i=0;i<n;i++){\n\t\tcin>>d[i];\n\t\ta.push_back(d[i]);\n\t\tmp[d[i]]=i;\n\t\tqz.push_back(1);\n\t\tdist.push_back(-1);\n\t}\n\tsort(d,d+n);\n\tfor(long long i=n-1;i>=0;i--){\n\t\tlong long it=mp.rbegin()->second;\n\t\tlong long net=a[it]-(n-qz[it]*2);\n\t\tif(mp.find(net)==mp.end()||mp[net]==mp[it]){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tres.push_back(make_pair(mp[it],mp[net]));\n\t\tqz[mp[net]]+=qz[mp[it]];\n\t\tmp.erase(--mp.end());\t\t\n\t}\n\tdist[0]=0;\n\tfor(long long i=0;i<res.size();i++){\n\t\tnmp[res[i].first].push_back(res[i].second);\n\t\tnmp[res[i].second].push_back(res[i].first);\n\t}\n\tfor(long long i=0;i<x.size();i++){\n\t\tfor(long long j=0;j<nmp[x[i]].size();j++){\n\t\t\tif(dist[nmp[x[i]][j]]==-1){\n\t\t\t\tx.push_back(nmp[x[i]][j]);\n\t\t\t\tdist[nmp[x[i]][j]]=dist[x[i]]+1;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ansd=0;\n\tfor(long long i=0;i<dist.size();i++){\n\t\tansd+=dist[i];\n\t}\n\tif(ansd!=a[0]){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tfor(long long i=0;i<res.size();i++){\n\t\tcout<<res[i].first+1<<\" \"<<res[i].second+1<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> T gi() {\n\tT x = 0; bool f = 0; char c = getchar();\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar();\n\tif (c == '-') f = 1, c = getchar();\n\twhile (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn f ? -x : x;\n}\nconst int N = 1e5 + 10;\nint p[N], siz[N], X[N], Y[N], fa[N];\nint find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\nLL D[N];\nmap<LL, int> M;\nbool cmp(int x, int y) { return D[x] > D[y]; }\n\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n = gi<int>();\n\tfor (int i = 1; i <= n; i++)\n\t\tD[i] = gi<LL>(), M[D[i]] = i, p[i] = i;\n\tsort(p + 1, p + 1 + n, cmp);\n\tfor (int i = 1; i <= n; i++) siz[i] = 1, fa[i] = i;\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x = p[i];\t\t\n\t\tif (M.find(D[x] - n + 2 * siz[x]) == M.end()) continue;\n\t\tint y = M[D[x] - n + 2 * siz[x]];\n\t\tif (find(x) == find(y)) continue;\n\t\tfa[find(y)] = find(x);\n\t\tsiz[y] += siz[x]; X[++cnt] = x; Y[cnt] = y;\n\t}\n\tif (cnt == n - 1) {\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tprintf(\"%d %d\\n\", X[i], Y[i]);\n\t}\n\telse puts(\"-1\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int MAXN = 100010;\n\nstruct Edge\n{\n\tint to, nxt;\n}e[MAXN << 1];\nint tot, h[MAXN];\n\ninline void add(int u, int v)\n{\n\te[++tot] = (Edge){v, h[u]};\n\th[u] = tot;\n}\n\nstruct Node\n{\n\tint id; ll val;\n\tbool operator < (const Node &x) const\n\t{\n\t\treturn val < x.val;\n\t}\n}d[MAXN];\n\nint n, vis[MAXN], siz[MAXN], fa[MAXN];\nmap<ll, int> H; ll sum;\n\nbool solve(int x)\n{\n\tif(vis[d[x].id]) return 1;\n\tvis[d[x].id] = 1;\n\tif(x == 1) return 1;\n\tll now = d[x].val + 2ll * siz[d[x].id] - n;\n\tif(H.find(now) == H.end()) return 0;\n\tint f = H[now];\n\tif(!siz[d[f].id]) siz[d[f].id] = 1;\n\tsiz[d[f].id] += siz[d[x].id];\n\tfa[d[x].id] = d[f].id;\n\tadd(d[f].id, d[x].id), add(d[x].id, d[f].id);\n\treturn solve(f);\n}\n\nvoid dfs(int x, int f, ll res)\n{\n\tsum += res;\n\tfor(int i = h[x]; i; i = e[i].nxt)\n\t{\n\t\tint y = e[i].to;\n\t\tif(y == f) continue;\n\t\tdfs(y, x, res + 1);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tscanf(\"%lld\", &d[i].val);\n\t\td[i].id  = i;\n\t}\n\tsort(d + 1, d + 1 + n);\n\tfor(int i = 1; i <= n; ++i) H[d[i].val] = i;\n\tfor(int i = n; i > 1; --i)\n\t\tif(!vis[d[i].id])\n\t\t{\n\t\t\tsiz[d[i].id] = 1;\n\t\t\tif(!solve(i)) return puts(\"-1\"), 0;\n\t\t}\n\tdfs(d[1].id, 0, 0);\n\tif(sum != d[1].val) return puts(\"-1\"), 0;\n\tfor(int i = 2; i <= n; ++i) \n\t\tprintf(\"%d %d\\n\", fa[d[i].id], d[i].id);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<iomanip>\n#include<cstring>\n#include<complex>\n#include<vector>\n#include<cstdio>\n#include<string>\n#include<bitset>\n#include<ctime>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#define Cpy(x,y) memcpy(x,y,sizeof(x))\n#define Set(x,y) memset(x,y,sizeof(x))\n#define FILE \"a\"\n#define mp make_pair\n#define pb push_back\n#define RG register\n#define il inline\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef vector<int>VI;\ntypedef long long ll;\ntypedef double dd;\nconst int N=1<<17;\nconst int mod=998244353;\nconst int base=26;\nconst dd eps=1e-6;\nconst int inf=2147483647;\nconst ll INF=1ll<<60;\nconst ll P=100000;\nil ll read(){\n  RG ll data=0,w=1;RG char ch=getchar();\n  while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n  if(ch=='-')w=-1,ch=getchar();\n  while(ch<='9'&&ch>='0')data=data*10+ch-48,ch=getchar();\n  return data*w;\n}\n\nil void file(){\n  srand(time(NULL)+rand());\n  freopen(FILE\".in\",\"r\",stdin);\n  freopen(FILE\".out\",\"w\",stdout);\n}\n\nint n,o[N],m;ll sz[N];\nstruct node{ll d,id;}t[N];bool cmp_d(node a,node b){return a.d<b.d;}\nil void er(){puts(\"-1\");exit(0);}\nstruct edge{int u,v;}E[N];\n/*\nint head[N],nxt[N<<1],to[N<<1],cnt;\nil void add(int u,int v){to[++cnt]=v;nxt[cnt]=head[u];head[u]=cnt;}\nint up[N],down[N],w[N],sz[N];\nvoid dfs1(int u,int ff){\n  sz[u]=1;\n  for(RG int i=head[u];i;i=nxt[i]){\n    RG int v=to[i];if(v==ff)continue;\n    dfs1(v,u);sz[u]+=sz[v];if()\n  }\n}\n*/\nint main()\n{\n  n=read();\n  for(RG int i=1;i<=n;i++){t[i].d=read();t[i].id=i;}\n  sort(t+1,t+n+1,cmp_d);\n  for(RG int i=1;i<=n;i++)o[i]=t[i].d,sz[i]=1;\n  for(RG int i=n,p;i!=1;i--){\n    p=lower_bound(o+1,o+n+1,t[i].d-n+2*sz[i])-o;\n    if(o[p]!=t[i].d-n+2*sz[i]||p>=i)er();\n    E[++m]=(edge){t[p].id,t[i].id};sz[p]+=sz[i];\n  }\n  //for(RG int i=1;i<=m;i++)add(E[i].u,E[i].v),add(E[i].v,E[i].u);\n  //dfs1(1,0);dfs2(1,0);\n  for(RG int i=1;i<=m;i++)printf(\"%d %d\\n\",E[i].u,E[i].v);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm> \n#include<cstdio>\n#define N 100001\nusing namespace std;\nint a[N],b[N],f[N],i,n,s[N];\ninline bool cmp(int u,int v){return a[u]<a[v];}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)scanf(\"%d\",a+i),s[b[i]=i]=1;\n\tsort(b+1,b+n+1,cmp);\n\tfor(i=n;i>1;i--)\n\t{\n\t\tif(s[b[i]]<<1>=n)return 0*puts(\"-1\");\n\t\t*a=a[b[i]]-n+(s[b[i]]<<1),f[b[i]]=lower_bound(b+1,b+n+1,0,cmp)-b;\n\t\tif(f[b[i]]>n||a[b[f[b[i]]]]!=*a)return 0*puts(\"-1\");\n\t\ts[f[b[i]]=b[f[b[i]]]]+=s[b[i]];\n\t}\n\tfor(i=2;i<=n;i++)printf(\"%d %d\\n\",b[i],f[b[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nint n,p[101000],s[101000];\nll a[101000];\nvector<pair<int,int> > ans;\nmap<ll,int> mp;\nint main(){\n\tread(n);\n\tfor(int i=1;i<=n;i++){\n\t\tread(a[i]);mp[a[i]]=i;\n\t\tp[i]=i;s[i]=1;\n\t}\n\tsort(p+1,p+n+1,[&](int x,int y){\n\t\treturn a[x]>a[y];\n\t});\n\tfor(int i=1;i<n;i++){\n\t\tint x=p[i];\n\t\tmp.erase(a[x]);\n\t\tll pos=a[x]+s[x]-(n-s[x]);\n\t\tif(!mp.count(pos)){puts(\"-1\");return 0;}\n\t\tans.emplace_back(x,mp[pos]);\n\t\ts[mp[pos]]+=s[x];\n\t}\n\tfor(auto pr:ans) cout<<pr.first<<' '<<pr.second<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <map>\n#define __DEBUG__\n#undef __DEBUG__\n#define MAXN 100005\n\nusing namespace std;\n\nint main(){\n    int N;\n    pair<int,int> D[MAXN];//D,ソートする前のノードの番号\n    pair<int,int> ans[MAXN];\n    int Chi[MAXN];\n    int Dep[MAXN];//深さの和　木の根でDと一致するはず\n    map<int,int> Ds;//D,ソート後のノードの番号 配列の逆(Dから配列のindexを探しやすくするため)\n    map<int,int>::iterator it;\n    cin>>N;\n    for(int i = 0;i < N;i++){\n        cin>>D[i].first;\n        D[i].second=i+1;\n        Chi[i]=1;\n        Dep[i]=0;\n    }\n    sort(D,D+N,greater<pair<int,int> >());\n    for(int i = 0;i < N;i++){\n        Ds[D[i].first]=i;\n    }\n#ifdef __DEBUG__\n    cout<<\"sorted:\"<<endl;\n    for(int i = 0;i < N;i++){\n        cout<<D[i].first<<\",\"<<D[i].second<<\"/\";\n    }\n    cout<<endl;\n#endif\n    for(int i = 0;i < N-1;i++){\n        int Dj = D[i].first+Chi[i]*2-N;\n        if(it = Ds.find(Dj),it==Ds.end()){\n            cout<<-1<<endl;\n            return 0;\n        }\n        int j = it->second;\n        Chi[j]+=Chi[i];\n        Dep[j]+=Dep[i]+Chi[i];\n        ans[i]=make_pair(D[i].second,D[j].second);\n    }\n#ifdef __DEBUG__\n    cout<<Dep[N-1]<<endl;\n#endif\n    if(Chi[N-1]!=N||Dep[N-1]!=D[N-1].first){\n        cout<<-1<<endl;\n        return 0;\n    }\n    for(int i = 0;i < N-1;i++){\n        cout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a%b); }\n\nconst int MAXN = 100000;\n\nint n;\nll d[MAXN];\n\npair<ll, int> o[MAXN];\n\nint sz[MAXN], par[MAXN]; ll chdst[MAXN];\n\n\nbool solve() {\n\tREP(i, n) o[i] = MP(d[i], i); sort(o, o + n);\n\t//printf(\"o:\"); REP(i, n) printf(\" (%lld,%d)\", o[i].first, o[i].second); puts(\"\");\n\n\tREP(i, n) sz[i] = 1, par[i] = -2, chdst[i] = 0;\n\tfor (int i = n - 1; i >= 1; --i) {\n\t\tint at = o[i].second;\n\t\t// d[at]-d[par[at]]=n-2*sz[at] -> d[par[at]]=d[at]-n+2*sz[at]\n\t\tll want = d[at] - n + 2 * sz[at];\n\t\tint idx = lower_bound(o, o + n, MP(want, -1)) - o; if (idx >= i || o[idx].first != want) return false;\n\t\tpar[at] = o[idx].second; sz[par[at]] += sz[at]; chdst[par[at]] += chdst[at] + sz[at];\n\t}\n\n\tint root = o[0].second; assert(sz[root] == n); par[root] = -1; return chdst[root] == d[root];\n}\n\n\nvoid run() {\n\tscanf(\"%d\", &n); REP(i, n) scanf(\"%lld\", &d[i]);\n\tif (!solve()) { printf(\"-1\\n\"); return; }\n\tREP(i, n) if (par[i] != -1) printf(\"%d %d\\n\", i + 1, par[i] + 1);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define re register\n#define ll long long\ninline int gi()\n{\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\ntypedef pair<ll,int>pli;\ntypedef pair<int,int>pii;\n#define mp make_pair\nconst int N=100010;\nll d[N];int n,siz[N];vector<pii>ans;pli p[N];\nint main()\n{\n\tn=gi();\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&d[i]),p[i].first=d[i],p[i].second=i,siz[i]=1;\n\tsort(p+1,p+n+1);ll dis=0;\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tll nd=p[i].first-n+(siz[p[i].second]<<1);\n\t\tint pos=lower_bound(p+1,p+n+1,mp(nd,0))-p;\n\t\tif(p[pos].first!=nd)return puts(\"-1\"),0;\n\t\tint u=p[i].second,v=p[pos].second;\n\t\tans.push_back(mp(u,v));siz[v]+=siz[u];\n\t\tdis+=siz[u];\n\t}\n\tif(dis!=p[1].first)return puts(\"-1\"),0;\n\tfor(pii now:ans)printf(\"%d %d\\n\",now.first,now.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\nstruct var{\n\tint fr,to,nxt;\n}edge[101001];\nint n,size[101001],cnt,head[101001];\nLL d[101001],dis[101001];\nmap<LL,int>num;\nvoid add(int u,int v)\n{\n\tcnt++;\n\tedge[cnt].to=v;\n\tedge[cnt].fr=u;\n\tedge[cnt].nxt=head[u];\n\thead[u]=cnt;\n}\nvoid dfs(int o,int f)\n{\n\tfor(int i=head[o];i;i=edge[i].nxt)\n\t{\n\t\tint v=edge[i].to;\n\t\tif(v==f)continue;\n\t\tdis[v]=dis[o]+1;\n\t\tdfs(v,o);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&d[i]);\n\t\tnum[d[i]]=i;\n\t\tsize[i]=1;\n\t}\n\tsort(d+1,d+n+1);\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tint u=num[d[i]];\n\t\tLL tmp=n-2*size[u],f=d[i]-tmp;\n\t\tif(tmp<0)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tif(!num.count(f))\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint x=num[f];\n\t\tadd(x,u);\n\t\tsize[x]+=size[u];\n\t}\n\tdfs(num[d[1]],0);\n\tLL sum=0;\n\tfor(int i=1;i<=n;i++)sum+=dis[i];\n\tif(sum!=d[1])\n\t{\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=cnt;i++)\n\t{\n\t\tprintf(\"%d %d\\n\",edge[i].fr,edge[i].to);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n#include <numeric>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tmap<long long int, int> d_map;\n\tvector<pair<long long int, int> > d;\n\tfor(int i = 1; i <= n; i++){\n\t\tlong long int tmp;\n\t\tcin >> tmp;\n\t\td.push_back(make_pair(tmp, i));\n\t\td_map[tmp] = i;\n\t}\n\tsort(d.begin(), d.end());\n\treverse(d.begin(), d.end());\n\tvector<bool> ischecked(n, false);\n\tset<pair<int, int> > ans;\n\tfor(int i = 0; i < d.size(); i++){\n\t\tint now = d[i].second;\n\t\tint nowd = d[i].first;\n\t\tif(ischecked[now]) continue;\n\t\tischecked[now] = true;\n\t\t// nowから1本でつながっている分をつなげていく\n\t\tint j = 1;\n\t\tfor(j = 1; j < n; j++){\n\t\t\tlong long int nextd = nowd - (n  - j) + j;\n\t\t\tif(nextd >= nowd || d_map.find(nextd) == d_map.end()){\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tint next = d_map[nextd];\n\t\t\t\tans.insert(make_pair(min(now, next), max(now, next)));\n\t\t\t\tischecked[next] = true;\n\t\t\t\tnow = next;\n\t\t\t\tnowd = nextd;\n\t\t\t}\n\t\t}\n\t\tif(j == 1){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(auto i = ans.begin(); i != ans.end(); i++){\n\t\tcout << (*i).first << \" \" << (*i).second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline long long read () {\n\tlong long num = 0;\n\tchar c = ' ';\n\tbool flag = true;\n\tfor (;c > '9' || c < '0';c = getchar())\n\t\tif (c == '-')\n\t\t\tflag = false;\n\tfor (;c >= '0' && c <= '9';num = (num << 1) + (num << 3) + c - 48, c = getchar());\n\treturn flag ? num : -num;\n}\nnamespace graph {\n\tconst int maxn = 100020;\n\tstruct node {\n\t\tint y, next;\n\t} a[maxn << 1];\n\tint head[maxn], top = 0;\n\tvoid insert (int x, int y) {\n\t\ta[top].y = y;\n\t\ta[top].next = head[x];\n\t\thead[x] = top ++;\n\t}\n} using namespace graph;\n\nnamespace INIT {\n\tmap <long long, int> m;\n\tint n; long long d[maxn];\n\tvoid init () {\n\t\tn = read ();\n\t\tfor (int i = 1;i <= n;i ++) {\n\t\t\td[i] = read ();\n\t\t\tm[d[i]] = i;\n\t\t}\n\t\tsort (d + 1,d + 1 + n);\n\t}\n} using namespace INIT;\n\nnamespace WORK {\n\tint size[maxn];\n\tvoid work () {\n\t\tmemset (head, -1, sizeof head);\n\t\tfor (int i = 1;i <= n;i ++)\n\t\t\tsize[i] = 1;\n\t\tfor (int i = n;i > 1;i --) {\n\t\t\tint x = m[d[i]];\n\t\t\tlong long t = n - 2 * size[x];\n\t\t\tif (t < 0) {\n\t\t\t\tprintf (\"-1\\n\");\n\t\t\t\texit (0);\n\t\t\t}\n\t\t\tt = d[i] - t;\n\t\t\tif (m.count(t) == 0) {\n\t\t\t\tprintf (\"-1\\n\");\n\t\t\t\texit (0);\n\t\t\t}\n\t\t\tint y = m[t];\n\t\t\tinsert (y, x);\n\t\t\tinsert (x, y);\n\t\t\tsize[y] += size[x];\n\t\t}\n\t}\n} using namespace WORK;\n\nnamespace CHECK {\n\tint dis[maxn];\n\tvoid dfs (int x, int fa) {\n\t\tfor (int i = head[x];i + 1;i = a[i].next) {\n\t\t\tint y = a[i].y;\n\t\t\tif (y == fa) continue;\n\t\t\tdis[y] = dis[x] + 1;\n\t\t\tdfs (y, x);\n\t\t}\n\t}\n\tvoid check () {\n\t\tdfs (m[d[1]], -1);\n\t\tlong long s = 0;\n\t\tfor (int i = 1;i <= n;i ++)\n\t\t\ts += dis[i];\n\t\tif (s != d[1]) {\n\t\t\tprintf (\"-1\\n\");\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0;i < top;i += 2) {\n\t\t\t\tprintf (\"%d %d\\n\",a[i].y, a[i ^ 1].y);\n\t\t\t}\n\t\t}\n\t}\n} using namespace CHECK;\nint main () {\n\tinit ();\n\twork ();\n\tcheck ();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint PREP = (cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(9), 0);\n//int SEGV = getenv(\"D\") || (exit(system(\"D= SEGFAULT_SIGNALS=all catchsegv ./prog.exe\") >> 8), 0);\nvoid fail() {\n    cout << -1 << '\\n';\n    exit(0);\n}\nint main() {\n    int N; cin >> N;\n    if (N == 2) fail();\n    vector<Int> D(N);\n    map<Int, pair<int, int>> M; // D[i] -> idx, num\n    vector<vector<int>> G(N);\n    for (int i = 0; i < N; i++) {\n        cin >> D[i];\n        M[D[i]] = make_pair(i, 1);\n    }\n    int root = -1;\n    for (auto it = rbegin(M), ite = rend(M); it != ite; ++it) {\n        int idx, num; tie(idx, num) = it->second;\n        if (num == N) { root = idx; continue; }\n        Int diff = num - (N - num);\n        if (diff >= 0) fail();\n        Int dnext = it->first + diff;\n        if (!M.count(dnext)) fail();\n        G[M[dnext].first].emplace_back(idx);\n        M[dnext].second += num;\n    }\n    auto recur = [&](auto&& recur, int node) -> pair<Int, Int> {\n        Int val = 0, cnt = 1;\n        for (int next : G[node]) {\n            auto p = recur(recur, next);\n            val += p.first + p.second;\n            cnt += p.second;\n        }\n        return { val, cnt };\n    };\n    if (recur(recur, root).first != D[root]) {\n        fail();\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j : G[i]) {\n            cout << i + 1 << ' ' << j + 1 << '\\n';\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#define ll long long\n#define inf 20021225\n#define N 100010\nusing namespace std;\nll read()\n{\n\tll s=0,t=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')\tt=-1; ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn s*t;\n}\nstruct node{int id; ll d;}a[N];\nbool operator<(node a,node b){return a.d<b.d;}\nint sz[N],fa[N],n;\nmap<ll,int> f; ll d[N];\nint edge[N][2]; ll val[N];\nstruct edge{int to,lt;}e[N]; int in[N],cnt;\nvoid add(int x,int y){e[++cnt].to=y; e[cnt].lt=in[x]; in[x]=cnt;}\nvoid dfs(int x)\n{\n\tsz[x]=1; d[x]=0;\n\tfor(int i=in[x];i;i=e[i].lt)\n\t\tdfs(e[i].to),sz[x]+=sz[e[i].to],d[x]+=d[e[i].to];\n\td[x]+=sz[x]-1;\n}\nvoid getd(int x)\n{\n\tfor(int i=in[x];i;i=e[i].lt)\n\t\td[e[i].to]=d[x]+n-sz[e[i].to]*2,getd(e[i].to);\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)\ta[i].id=i,a[i].d=read(),f[a[i].d]=i;\n\tsort(a+1,a+n+1);\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tint x=a[i].id; ll w=a[i].d; sz[x]++;\n\t\tif(sz[x]>n/2)\treturn puts(\"-1\"),0;\n\t\tif(w-n+sz[x]*2>=w||f.find(w-n+sz[x]*2)==f.end())\treturn puts(\"-1\"),0;\n\t\tint fx=f[w-n+sz[x]*2]; sz[fx]+=sz[x]; fa[x]=fx; add(fa[x],x);\n\t}\n\tdfs(a[1].id); getd(a[1].id);\n\tfor(int i=1;i<=n;i++)\tif(a[i].d!=d[a[i].id])\n\t\treturn puts(\"-1\"),0;\n\tfor(int i=2;i<=n;i++)\n\t\tprintf(\"%d %d\\n\",fa[a[i].id],a[i].id);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+3;\nint n,siz[N];\nbool b[N];\nstruct syzs{\n\tint val,num;\n} a[N];\nstruct ans{\n\tint e1,e2;\n\tbool operator <(const ans &emm) const{\n\t    if(emm.e1==e1) return e2>emm.e2;\n\t\treturn emm.e1<e1;\n\t}\n};\nbool cmp(syzs c,syzs b){\n\treturn c.val>b.val;\n}\nint find(int k){\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i].val==a[k].val+2*siz[k]-n&&i!=k) return i;\n\t}\n\treturn -1;\n}\nint main(){\n\tpriority_queue <ans> q;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i].val);\n\t\ta[i].num=i;\n\t\tsiz[i]=1;\n\t}\n\tsort(a+1,a+n+1,cmp);\n\tb[1]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tint v=find(i);\n\t\tif(v==-1){\n\t\t\tif(i!=n) puts(\"-1\"),exit(0);\n\t\t\telse continue;\n\t\t}\n\t\tsiz[v]+=siz[i];\n\t\tq.push((ans) {min(a[v].num,a[i].num),max(a[v].num,a[i].num)});\n\t}\n\twhile(!q.empty()){\n\t\tint v1=q.top().e1,v2=q.top().e2;\n    \tq.pop();\n    \tprintf(\"%d %d\\n\",v1,v2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tif (N == 2) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tvector<long long int>v(N);\n\tmap<long long int, int>m;\n\tmap<long long int, int>used;\n\tL = LLONG_MAX;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> v[i];\n\t\tm[v[i]] = i + 1;\n\t\tL = min(L, v[i]);\n\t}\n\tvector<pair<int, int>>ans;\n\tsort(v.begin(), v.end());\n\treverse(v.begin(), v.end());\n\tfor (auto i : v) {\n\t\tlong long int dif = N - 2;\n\t\tlong long int box = i;\n\t\twhile (box > L) {\n\t\t\tif (used[box])break;\n\t\t\tif (m.find(box - dif) == m.end()) {\n\t\t\t\tcout << \"-1\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tans.push_back({ m[box],m[box - dif] });\n\t\t\t//cout << m[box] << \" \" << m[box - dif] << endl;\n\t\t\tused[box]++;\n\t\t\tbox -= dif;\n\t\t\tdif -= 2;\n\t\t}\n\t}\n\tif (ans.size() != N - 1) {\n\t\tv[MOD] = MOD;\n\t}\n\tfor (auto i : ans) {\n\t\tcout << i.first << \" \" << i.second << endl;\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n \n#include <algorithm>\n#include <tuple>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n \n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n \ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int N = 100010;\n\nint prt[N], sub[N];\nll d[N], sum[N];\n\nvoid gg() {\n  cout << \"-1\\n\";\n  exit(0);\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; ++i)\n    cin >> d[i];\n  map<ll, int, greater<ll>> mp;\n  for (int i = 1; i <= n; ++i)\n    mp.insert(make_pair(d[i], i));\n  fill(sub + 1, sub + n + 1, 1);\n  for (int rep = 1; rep < n; ++rep) {\n    int u = mp.begin()->second;\n    mp.erase(mp.begin());\n    ll goal = d[u] - (n - 2 * sub[u]);\n    auto it = mp.find(goal);\n    if (it == mp.end())\n      gg();\n    prt[u] = it->second;\n    sub[it->second] += sub[u];\n    sum[it->second] += sum[u] + sub[u];\n  }\n  int rt = mp.begin()->second;\n  if (sum[rt] != d[rt])\n    gg();\n  for (int i = 1; i <= n; ++i)\n    if (i != rt)\n      cout << i << ' ' << prt[i] << '\\n';\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst int INF=1001001001;\nconst int mod=1000000007;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\nvvi g;\nll ans=0;\nvoid dfs(int i,ll dep){\n    for(ll x:g[i]){\n        ans+=dep;\n        dfs(x,dep+1);\n    }\n}\nint main(){\n    ll n;cin>>n;\n    vp v(n);\n    rep(i,n)cin>>v[i].fi;\n    rep(i,n)v[i].se=i;\n    sort(all(v));\n    vi par(n),sz(n,1);\n    g=vvi(n);\n    for(int i=n-1;i>0;i--){\n        ll nx=v[i].fi-n+2*sz[i];\n        ll k=lb(v,P(nx,-1));\n        if(v[k].fi!=nx)dame(-1);\n        sz[k]+=sz[i];\n        par[i]=k;\n        g[k].pb(i);\n    }\n    dfs(0,1);\n    if(ans!=v[0].fi)dame(-1);\n    REP(i,1,n)cout<<v[i].se+1<<' '<<v[par[i]].se+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n#define ll long long\nusing namespace std;\nconst int N=1e5+5;\nint n,id[N],fa[N],siz[N]; ll a[N]; map<ll,int> mp;\nbool cmp(int x,int y){ return a[x]>a[y]; }\nint main(){\n\tscanf(\"%d\",&n);\n\trep (i,1,n){\n\t\tscanf(\"%lld\",&a[i]);\n\t\tmp[a[i]]=i; id[i]=i; siz[i]=1;\n\t}\n\tsort(id+1,id+1+n,cmp);\n\trep (i,1,n-1){\n\t\tint x=id[i];\n\t\tfa[x]=mp[a[x]-n+2*siz[x]];\n\t\tif (!fa[x]) return puts(\"-1\"),0;\n\t\tsiz[fa[x]]+=siz[x];\n\t}\n\trep (i,1,n-1) a[id[n]]-=siz[id[i]];\n\tif (a[id[n]]) return puts(\"-1\"),0;\n\trep (i,1,n-1) printf(\"%d %d\\n\",id[i],fa[id[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n\n#pragma warning(disable:4996)  \n#pragma comment(linker, \"/STACK:336777216\")  \nusing namespace std;\n\n#define mp make_pair  \n#define Fi first  \n#define Se second  \n#define pb(x) push_back(x)  \n#define szz(x) ((int)(x).size())  \n#define rep(i, n) for(int i=0;i<n;i++)  \n#define all(x) (x).begin(), (x).end()  \n#define ldb ldouble  \n\ntypedef unsigned int uint;\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n\nconst int MX = 1<<19;\nconst int MM = 998244353;\n\nmap<ll, int> DB;\nint P[MX], ad[MX], cnt[MX];\nll D[MX], E[MX];\nint N;\n\nvector<int> T[MX];\n\nll dfs(int x, int p, int lev = 0){\n\tll tot = 0;\n\tfor(int c : T[x]){\n\t\ttot += dfs(c, x, lev+1);\n\t}\n\treturn tot + lev;\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor(int i = 1; i <= N; i++){\n\t\tscanf(\"%lld\", D+i);\n\t\tDB[D[i]] = i;\n\t}\n\tfor(int i = 1; i <= N; i++) ad[i] = i;\n\tsort(ad+1, ad+N+1, [](int l, int r){\n\t\treturn D[l] > D[r];\n\t});\n\n\tfor(int i = 1; i <= N; i++) cnt[i] = 1;\n\tfor(int i = 1; i < N; i++){\n\t\tint c = ad[i];\n\t\tll v = D[c] - (N - cnt[c]*2);\n\t\tif(DB.find(v) == DB.end()) return !printf(\"-1\\n\");\n\t\tP[c] = DB[v];\n\t\tcnt[P[c]] += cnt[c];\n\t\t\n\t\tT[P[c]].push_back(c);\n\t}\n\tint r = ad[N];\n\n\tif(D[r] != dfs(r, -1)) return !printf(\"-1\\n\");\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int c : T[i]) printf(\"%d %d\\n\", i, c);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int N=100005;\nint n,id[N];\nLL d[N],size[N];\nvector <int> e[N];\nmap <LL,int> Map,My;\nint depth[N];\nvoid dfs(int x,int d){\n\tdepth[x]=d;\n\tfor (auto y : e[x])\n\t\tdfs(y,d+1);\n}\nbool check(int x,LL v){\n\tif (v!=d[x])\n\t\treturn 0;\n\tfor (auto y : e[x])\n\t\tif (!check(y,v-size[y]+(n-size[y])))\n\t\t\treturn 0;\n\treturn 1;\n}\nbool check(){\n\tdfs(1,0);\n\tLL v=0;\n\tfor (int i=1;i<=n;i++)\n\t\tv+=depth[i];\n\treturn check(1,v);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tMy.clear();\n\tfor (int i=1;i<=n;i++)\n\t\tscanf(\"%lld\",&d[i]),My[d[i]]=i;\n\tsort(d+1,d+n+1);\n\tfor (int i=1;i<=n;i++)\n\t\te[i].clear();\n\tMap.clear();\n\tfor (int i=1;i<=n;i++)\n\t\tMap[d[i]]=i,size[i]=1;\n\tfor (int i=n;i>1;i--){\n\t\tLL tmp=d[i]-n+size[i]*2;\n\t\tint fa=Map[tmp];\n\t\tif (!fa)\n\t\t\treturn puts(\"-1\"),0;\n\t\te[fa].push_back(i);\n\t\tsize[fa]+=size[i];\n\t}\n\tif (!check())\n\t\treturn puts(\"-1\"),0;\n\tfor (int i=1;i<=n;i++)\n\t\tfor (auto j : e[i])\n\t\t\tprintf(\"%d %d\\n\",My[d[i]],My[d[j]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main () {\n  cout << \"-1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,s,t) for(int i=(s);i<(t);++i)\n#define per(i,s,t) for(int i=((t)-1);i>=s;--i)\n#define repb(i,s,t) for(int i=(s);i<=(t);++i)\n#define lepb(i,s,t) for(int i=(s);i>=(t);--i)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)x.size())\n#define mst(a,b) memset(a,b,sizeof(a))\n#define dd(x) cout<<#x<<'='<<x<<' '\n#define de(x) cout<<#x<<'='<<x<<'\\n'\n#define fi first\n#define se second\n#define sq(x) ((x)*(x))\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef double db;\n\nconst int inf = 0x3f3f3f3f;\nconst ll inff = 4557430888798830399ll;\nconst db eps = 1e-10;\nconst db pi = acos(-1.0);\nconst ll mod = 1e9+7;\n\n#define maxn 100005\n\nmap<ll,int> id;\nint sz[maxn],p[maxn];\nint fa(int n){return n==p[n]?n:p[n]=fa(p[n]);}\n\nint main()\n{\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tint n,u,v;ll x,y;vector<pair<ll,int> > D;vector<pii> E;\n\tcin>>n;\n\trepb(i,1,n){cin>>x;D.pb({x,i});id[x]=i;}\n\tsort(all(D));reverse(all(D));mst(sz,0);\n\trep(i,0,sz(D)-1)\n\t{\n\t\tx=D[i].fi;u=D[i].se;sz[u]+=1;\n\t\ty=x-n+2*sz[u];v=id[y];\n\t\tif(v==0||y>=x){cout<<-1<<endl;return 0;}\n\t\tE.pb(mp(u,v));sz[v]+=sz[u];\n\t}\n\trepb(i,1,n)p[i]=i;\n\trep(i,0,sz(E))if(fa(E[i].fi)!=fa(E[i].se))p[fa(E[i].fi)]=fa(E[i].se);\n\trepb(i,1,n)if(fa(i)!=fa(1)){cout<<-1<<endl;return 0;}\n\trep(i,0,sz(E))cout<<E[i].fi<<\" \"<<E[i].se<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#include<map>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n\nusing namespace std;\ntypedef long long LL;\nconst int N=100005;\nint n,p[N],siz[N],fa[N];\nLL d[N];\nmap <LL,int> s;\n\nbool cmp(int x,int y)\n{\n\treturn d[x]>d[y];\n}\n\nint main()\n{puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\nusing namespace std;\nconst int N=1e5+5;\nint n,p[N],sz[N];long long d[N];\nmap<long long,int>Map;\nbool cmp(int x,int y){\n\treturn d[x]>d[y];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%lld\",&d[i]);\n\t\tMap[d[i]]=i;p[i]=i;sz[i]=1;\n\t}\n\tsort(p+1,p+n+1,cmp);\n\tfor(int i=1;i<n;++i){\n\t\tint x=p[i],y=Map[d[x]-n+sz[x]+sz[x]];\n\t\tif(!y||d[y]>=d[x])return puts(\"-1\"),0;\n\t\tprintf(\"%d %d\\n\",x,y);\n\t\tsz[y]+=sz[x];\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*********************\n*  Author: xuziyuan  * \n*********************/\n\n#include <bits/stdc++.h>\n\n#define rt0 return 0\n#define rep(i,n) for(int i=0;i<n;i++)\n#define repn(i,n) for(int i=1;i<=n;i++)\n#define replet(c) for(char c='a';c<='z';c++) \n#define LL long long\n#define pii pair <LL,LL>\n#define pb push_back\n#define fi first\n#define se second\n#define mpr make_pair\n#define sqr(a) ((a)*(a))\n\nusing namespace std;\n\nconst LL MOD=1e9+7;\n\nLL n,d[100010],sonn[100010],dp[100010];\nmap <LL,LL> mp;\nvector <LL> g[100010];\nvector <pii> ans,v;\nbool vis[100010];\n\nbool cmp(pii a,pii b)\n{\n\treturn a.fi>b.fi;\n}\n\nvoid dfs(LL pos,LL no)\n{\n\tif(vis[pos])\n\t{\n\t\tputs(\"-1\");\n\t\texit(0);\n\t}\n\tsonn[pos]=1;\n\tvis[pos]=true;\n\trep(i,g[pos].size())\n\t{\n\t\tif(g[pos][i]==no) continue;\n\t\tdfs(g[pos][i],pos);\n\t\tdp[pos]+=dp[g[pos][i]]+sonn[g[pos][i]];\n\t\tsonn[pos]+=sonn[g[pos][i]];\n\t}\n}\n\nvoid dfs2(LL pos,LL no,LL now)\n{\n\tif(now+dp[pos]!=d[pos])\n\t{\n\t\tputs(\"-1\");\n\t\texit(0);\n\t}\n\trep(i,g[pos].size()) \n\tif(g[pos][i]!=no) dfs2(g[pos][i],pos,now+dp[pos]-dp[g[pos][i]]-sonn[g[pos][i]]+n-sonn[g[pos][i]]);\n}\n\nint main()\n{\n\trep(i,100005) sonn[i]=1;\n\tcin>>n;\n\trep(i,n)\n\t{\n\t\tscanf(\"%lld\",&d[i]);\n\t\tmp[d[i]]=i;\n\t\tv.pb({d[i],i});\n\t}\n\tsort(v.begin(),v.end(),cmp);\n\trep(i,v.size()-1)\n\t{\n\t\tLL wantpar=v[i].fi-n+sonn[v[i].se]*2;\n\t\tif(wantpar>=v[i].fi||mp.find(wantpar)==mp.end())\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\trt0;\n\t\t}\n\t\tsonn[mp[wantpar]]+=sonn[v[i].se];\n\t\tans.pb({v[i].se,mp[wantpar]});\n\t\tg[v[i].se].pb(mp[wantpar]);\n\t\tg[mp[wantpar]].pb(v[i].se);\n\t}\n\tmemset(sonn,0,sizeof(sonn));\n\tdfs(0,0);\n\tdfs2(0,0,0);\n\trep(i,n-1) cout<<ans[i].fi+1<<' '<<ans[i].se+1<<endl;\n\trt0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define F first\n#define S second\n#define int long long\nusing namespace std;\n\nint n;\npair<int, int> a[200020];\nvector<int> ed[200020];\nmap<int, int> mp;\nint sz[200020];\nint sum = 0;\n\nvoid dfs(int now, int dept){\n\tsum += dept;\n\trep(i, ed[now].size()){\n\t\tdfs(ed[now][i], dept+1);\n\t}\n}\n\nsigned main(){\n\tcin >> n;\n\trep(i, n){\n\t\tcin >> a[i].F;\n\t\tmp[a[i].F] = i;\n\t\ta[i].S = i;\n\t}\n\trep(i, n) sz[i] = 1;\n\tsort(a, a+n);\n\treverse(a, a+n);\n\trep(i, n-1){\n\t\tint val = a[i].F;\n\t\tint to = a[i].F + 2*sz[a[i].S] - n;\n\t\tif(!mp.count(to)){\n\t\t\tcout << \"-1\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint par = mp[to];\n\t\tsz[par] += sz[a[i].S];\n\t\ted[par].push_back(a[i].S);\n\t}\n\tdfs(a[n-1].S, 0);\n\tif(sum != a[n-1].F){\n\t\tcout << \"-1\" << endl;\n\t\treturn 0;\n\t}\n\trep(i, n){\n\t\trep(j, ed[i].size()){\n\t\t\tcout << i+1 << \" \" << ed[i][j]+1 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define retrun return\n#define cpnst const\n#include<set>\n#include<cstdlib>\ntypedef long long ll;\nint n;\nll d[111111];\nstruct pii\n{ll x,len;int p,s;};\nbool operator<(cpnst pii x,cpnst pii y)\n{return x.x<y.x;}\nvoid throwb()\n{puts(\"-1\"),exit(0);}\nstd::multiset<pii>s;\nvoid push(ll x,ll l,int y,int z)\n{s.insert(pii{x,l,y,z});}\nvoid pop(ll x,ll l,int y,int z)\n{s.erase(s.find(pii{x,l,y,z}));}\nvoid push(pii g)\n{s.insert(g);}\nvoid pop(pii g)\n{s.erase(s.find(g));}\nint x[111111],y[111111];\nvoid print()\n{for(register int i=1;i<n;i++)printf(\"%d %d\\n\",x[i],y[i]);}\nint main()\n{\n\tregister int i;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%lld\",d+i),push(d[i],0,i,1);\n\tfor(i=n-1;i;i--)\n\t{\n\t\tpii rem=*--s.end();\n\t\tll tp=d[rem.p]+2*rem.s-n;\n\t\tpii reg=*s.lower_bound(pii{tp,0,0,0});\n\t\tif(reg.x^tp)throwb();\n\t\tpop(rem);\n\t\tif(s.find(reg)==s.end())throwb();\n\t\tpop(reg);\n\t\tx[i]=rem.p,y[i]=reg.p;\n\t\treg.len+=rem.len+rem.s,reg.s+=rem.s;\n\t\tpush(reg);\n\t}print();\n}\n/*\nGiving the world a better yourself is giving yourself a better world. \n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=100005;\nint n,size[N],st[N],to[N];\nstruct note{\n\tint dis,x;\n}d[N];\nbool cmp(note x,note y){\n\treturn x.dis>y.dis;\n}\nusing std::map;\nmap<long long,int> m;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) {\n\t\tscanf(\"%d\",&d[i].dis);\n\t\td[i].x=i;\n\t\tm[d[i].dis]=i;\n\t}\n\tstd::sort(d+1,d+n+1,cmp);\n\tfor (int i=1;i<=n;i++) size[i]=1;\n\tfor (int i=1;i<n;i++){\n\t\tint dis=d[i].dis,x=d[i].x;\n\t\tint t=dis-abs(n-2*size[x]),fa=m.find(t)->second;\n\t\tif (fa==x || !fa){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsize[fa]+=size[x];\n\t\tst[i]=x,to[i]=fa;\n\t}\n\tfor (int i=1;i<n;i++) printf(\"%d %d\\n\",st[i],to[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(X,A,B) for(int X=A;X<=B;X++)\n#define tep(X,A,B) for(int X=A;X>=B;X--)\n#define LL long long\n#define DB double\nconst int N=400010;\nconst int M=800010;\nconst LL INF=1e15;\nusing namespace std;\n\nint n,fa[N],sz[N];\n\nstruct nn{\n\tLL d;\n\tint x;\n}a[N];\n\nint cmp(nn A,nn B){\n\treturn A.d<B.d;\n}\n\nvoid READ(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n)scanf(\"%lld\",&a[i].d),a[i].x=i;\n\tsort(a+1,a+n+1,cmp);\n}\n\nint GET(int pos,int x){\n\tint l=1,r=pos,res;\n\twhile(l<=r){\n\t\tint mid=(l+r)>>1;\n\t\tif(a[mid].d<=x)res=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\treturn res;\n}\n\nint SOLVE(){\n\trep(i,1,n)sz[i]=1;\n\ttep(i,n,2){\n\t\tint x=a[i].x;\n\t\tif(sz[x]>n/2)return 0;\n\t\tLL df=a[i].d+2*sz[x]-n;\n\t\tint pos=GET(i-1,df);\n\t\tif(a[pos].d!=df)return 0;\n\t\tint pa;\n\t\tfa[x]=pa=a[pos].x;\n\t\tsz[pa]+=sz[x];\n\t}\n\trep(i,2,n)printf(\"%d %d\\n\",fa[a[i].x],a[i].x);\n\treturn 1;\n}\n\nint main(){\n\tREAD();\n\tif(SOLVE()==0)printf(\"-1\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define taskname \"test1\"\n#define int long long\nusing namespace std;\n\nmain()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);   cout.tie(nullptr);\n    if (ifstream(\"test.inp\"))\n    {\n        freopen(\"test.inp\", \"r\", stdin);\n        #ifdef CHECKING\n            freopen(taskname\".out\", \"w\", stdout);\n        #else\n            freopen(\"test.out\", \"w\", stdout);\n        #endif //CHECKING\n    }\n    else if (ifstream(taskname\".inp\"))\n    {\n        freopen(taskname\".inp\", \"r\", stdin);\n        freopen(taskname\".out\", \"w\", stdout);\n    }\n\n//    int n;  cin >> n;\n//    vector<pair<int, int>> p(n);\n//    int ok = 0;\n//    for (auto &i : p)\n//    {\n//        cin >> i.first >> i.second;\n//        int dis = abs(i.first) + abs(i.second);\n//        if (dis & 1) ok |= 1;\n//        else ok |= 2;\n//    }\n//    if (ok == 3) cout << -1;\n//    else\n//    {\n//        vector<int> vx, vy;\n//        int m = 0;\n//        for (auto i : p)\n//        {\n//            vx.emplace_back(abs(i.first));\n//            vy.emplace_back(abs(i.second));\n//            m = max(m, abs(i.first) + abs(i.second));\n//        }\n//        sort(vx.begin(), vx.end());\n//        sort(vy.begin(), vy.end());\n//    }\n    cout << -1;\n}\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n                                            #include<iostream>\n                                            #include<cstdio>\n                                            #include<vector>\n                                            #include<queue>\n                                            #include<map>\n                                            #include<cstring>\n                                            #include<string>\n                                            #include <math.h>\n                                            #include<algorithm>\n                                        //    #include <boost/multiprecision/cpp_int.hpp>\n                                            #include<functional>\n                                   #define int long long\n                                            #define inf  1000000007\n                                            #define pa pair<int,int>\n                                            #define ll long long\n                                            #define pal pair<double,double>\n                                            #define ppap pair<pa,int>\n                                    //  #define PI 3.14159265358979323846\n                                            #define paa pair<int,char>\n                                            #define  mp make_pair\n                                            #define  pb push_back\n                                            #define EPS (1e-10)\n                                            #define equals(a,b) (fabs((a)-(b))<EPS)\n    int dx[8]={0,-1,0,1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tdouble x;\n                                            \tint y,z,w;\n                                            \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n                                                   #define ppa pair<int,pas>\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n                 \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\n                                \n                int pr[500010];\n                int inv[500010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n                \tint zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n                                         //----------------kokomade tenpure------------\n                //vector<double> ans(100000000),ans2(100000000)\n\nint d[100020];\nmap<int,int>ma,ma2;\nint sita[100020];\n\nvector<int> G[100020],G2[100020];\n\nvoid dfs1(int r,int p){\n\tfor(auto v:G[r])if(v!=p){\n\t\tG2[r].pb(v);\n\t\tdfs1(v,r);\n\t}\n}\n\nint ko[100020];\n\nint dfs2(int r){\n\t\n\tko[r]=1;\n\tfor(auto v:G2[r])ko[r]+=dfs2(v);\n\treturn ko[r];\n}\n\nint dfs3(int r){\n\tif(G2[r].size()==0){\n\t\treturn 0;\n\t}\n\tint ans=0;\n\tfor(auto v:G2[r]){\n\t\tans+=dfs3(v)+ko[v];\n\t}\n\treturn ans;\n}\n\nint W[100020];\nint n;\nvoid dfs4(int r){\n\tfor(auto v:G2[r]){\n\t\tW[v]=W[r]-2*ko[v]+n;\n\t\tdfs4(v);\n\t}\n}\n\nvector<int> hikaku,ve;\n    signed main(){\n     \n    \t       cin.tie(0);\n    \t\t\tios::sync_with_stdio(false);\n\n    \tcin>>n;\n    \tfor(int i=1;i<=n;i++){\n    \t\tcin>>d[i];\n    \t\tve.pb(d[i]);\n    \t\tma2[d[i]]=i;\n    \t}\n    \tve.pb(-1);\n    \tsort(ve.begin(),ve.end());\n    \tfor(int i=1;i<=n;i++)sita[i]=1,ma[ve[i]]=i;\n    \tfor(int i=n;i>1;i--){\n    \t\tint oya=ve[i]+2*sita[i]-n;\n    \t//\tcout<<i<<\" \"<<ve[i]<<\" \"<<oya<<endl;\n    \t\tif(oya>=ve[i]){\n    \t\t\tcout<<-1<<endl;\n    \t\t\treturn 0;\n    \t\t}\n    \t\tif(ma.find(oya)==ma.end()){\n    \t\t\tcout<<-1<<endl;\n    \t\t\treturn 0;\n    \t\t}\n    \t\toya=ma[oya];\n    \t\tsita[oya]+=sita[i];\n    \t\tG[oya].pb(i);\n    \t\tG[i].pb(oya);\n    \t\t\n    \t}\n   \n    \thikaku.pb(-1);\n    \tdfs1(1,1);\n   // \tcout<<\"d\"<<endl;\n    \tdfs2(1);\n    \t\n    \tW[1]=dfs3(1);\n    \t\n    \tdfs4(1);\n    \n    \tfor(int i=1;i<=n;i++)hikaku.pb(W[i]);\n    \tsort(hikaku.begin(),hikaku.end());\n    \tif(hikaku!=ve){\n    \t\tcout<<-1<<endl;\n    \t\treturn 0;\n    \t}\n    \t\n    \tfor(int i=1;i<=n;i++)for(auto v:G2[i]){\n    \t\tcout<<ma2[W[i]]<<\" \"<<ma2[W[v]]<<endl;\n    \t}\n    \t\n    \t\n    \t\treturn 0;\n    }\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<map>\n#include<algorithm>\n#define MAXN 100010\n#define LL long long\nusing namespace std;\nLL d[MAXN],dis[MAXN],siz[MAXN];\nint n,cnt; \nmap<LL,int> mp;\nstruct Edge{int u,v;}E[MAXN];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&d[i]);\n\tfor(int i=1;i<=n;i++) mp[d[i]]=i;\n\tsort(d+1,d+n+1);\n\tfor(int i=1;i<=n;i++) siz[i]=1;\n\t//d0=di+m-(n-m)=di+2m-n;\n\tfor(int i=n;i>1;i--){ \n\t\tint u=mp[d[i]];\n\t//\tcout<<u<<' '<<d[i]<<endl;\n\t\tLL d0=d[i]+2*siz[u]-n;\n\t\tint v=mp[d0];\n\t//\tcout<<\"-----\"<<v<<' '<<d0<<endl; \n\t\tif(v){\n\t\t\tsiz[v]+=siz[u];\n\t\t\tdis[v]+=(dis[u]+siz[u]);\n\t\t\tE[++cnt].u=min(u,v);\n\t\t\tE[cnt].v=max(u,v);\n\t\t}\n\t\telse{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif(dis[mp[d[1]]]!=d[1]){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=cnt;i++) printf(\"%d %d\\n\",E[i].u,E[i].v);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cassert>\n#include<iostream>\n#include<algorithm>\n#include<unordered_map>\n\nusing namespace std;\n\n#define Whats(x) cout<<#x<<\" is \"<<(x)<<endl\n#define DivHim() cout<<\">>>>>>>>>>>>>>>\"<<endl\n#define DivHer() cout<<\"<<<<<<<<<<<<<<<\"<<endl\n#define Oops() cout<<\"!!!!!!!!!!!!!!!\"<<endl\n\ntemplate<typename T> bool GetMin(T &a,T b)\n{\n\treturn ((a<=b)?false:(a=b,true));\n}\n\ntemplate<typename T> bool GetMax(T &a,T b)\n{\n\treturn ((a>=b)?false:(a=b,true));\n}\n\n/*\n\t -<Unlimited Blade Works>-\n */\n\n#define int long long\n\nconst int N=1e5+10;\n\nint n,d[N],id[N],sz[N],fa[N];\nunordered_map<int,int> re;\n\nbool Cmp(int x,int y)\n{\n\treturn d[x]>d[y];\n}\n\nsigned main()\n{\n\tputs(\"-1\");\n\treturn 0;\n\tscanf(\"%lld\",&n);\n\tif(n==2)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%lld\",d+i);\n\t\tre[d[i]]=i;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tid[i]=i;\n\t\tsz[i]=1;\n\t}\n\tsort(id+1,id+n+1,Cmp);\n\tfor(int i=1,u,v,x;i<n;++i)\n\t{\n\t\tre[d[u=id[i]]]=0;\n\t\tif((x=sz[u]+sz[u]-n)>=0||!(v=re[d[u]+x]))\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsz[fa[u]=v]+=sz[u];\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tif(fa[i])\n\t\t\tprintf(\"%lld %lld\\n\",fa[i],i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define inf 0x3f3f3f3f3f3f3f3f\n#define inf 0x3f3f3f3f\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define inv(x) Power(x, mod - 2)\n#define fi first\n#define se second\n#define MP make_pair\n#define PB push_back\n\ntypedef std::vector<int> Poly;\ntypedef std::pair<int,int> Pair;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef long long ll;\n\nconst int maxn = 100000, maxm = 2000, MAX = 1e6 + 5, mod = 1000000;\n//template{{{\nconst long double Pi = 3.14159265358979323846l, Eps = 1e-4;\ntemplate <class T> inline bool equal(T x, T y) { return fabs(x - y) < Eps; }\ninline int add(int x, int y) { x += y; return x >= mod ? x - mod : x; };\ninline void inc(int &x, int y) { x += y; x -= (x >= mod ? mod : 0); }\ninline int mul(int x, int y) { return 1ll * x * y % mod; }\ninline int Power(int x, int y, int Mod = mod) {\n\tint ans = 1;\n\twhile (y) {\n\t\tif (y & 1) ans = (ll) ans * x % Mod;\n\t\tx = (ll) x * x % Mod, y >>= 1;\n\t} return ans;\n}\n\n/*char buf[1<<23],obuf[1<<23],*p1=buf,*p2=buf, *O = obuf;\n#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\nvoid print(int x) {\n    if(x > 9) print(x / 10);\n    *O++=x%10+'0';\n} */\n\ntemplate <class T> inline T\tinput() {\n\tT x; char ch; bool flag = false;\n\twhile (!isdigit(ch = getchar())) flag |= ch == '-';\n\tfor (x = ch ^ 48; isdigit(ch = getchar()); x = x * 10 + (ch ^ 48));\n\treturn flag ? -x : x;\n}\n\ntemplate <class T> inline bool chkmin(T &x, T y) { x = x < y ? x : y; return x == y; }\ntemplate <class T> inline bool chkmax(T &x, T y) { x = x > y ? x : y; return x == y; }\ntemplate <class T> inline T gcd(T x, T y) { return !y ? x : gcd(y, x % y); }\ntemplate <class T> inline T sqrm(T x) { return (ll) x * x % mod; }\ntemplate <class T> inline T sqr(T x) { return x * x; }\n\nstruct {\n\tinline operator int () { return input<int>(); }\n\tinline operator long long () { return input<long long>(); }\n\ttemplate <class T> inline void operator () (T &x) { x = *this; }\n\ttemplate<class T, class ...A> inline void operator () (T &x, A &...a)\n\t{ x = *this; this -> operator ()(a...); }\n} read; //}}}\n\nint n;\nll d[maxn + 5];\nint size[maxn + 5];\nstd::map<ll, int> id;\nstd::pair<ll, int> p[maxn + 5];\nstd::vector<int> T[maxn + 5];\nint fa[maxn + 5];\n\nll distance;\n\nvoid dfs(int u, ll dis) {\n\tdistance += dis;\n\tfor (int v : T[u])\n\t\tdfs(v, dis + 1);\n}\n\nbool check() {\n\tdfs(1, 0);\n\treturn distance == d[p[1].fi];\n}\n\nsigned main() {\n#ifdef local\n\tfreopen(\"in\", \"r\", stdin);\n\tfreopen(\"out\", \"w\", stdout);\n\tfreopen(\"log\", \"w\", stderr);\n#endif\n\n\tn = read;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tp[i].fi = d[i] = read;\n\t\tp[i].se = id[d[i]] = i;\n\t\tsize[i] = 1;\n\t}\n\n\tstd::sort(p + 1, p + n + 1);\n\tfor (int i = n; i > 1; --i) {\n\t\tll df = p[i].fi - n + size[p[i].se] * 2;\n\t\tif (df >= p[i].fi) return puts(\"-1\"), 0;\n\t\tfa[p[i].se] = id[df], size[fa[p[i].se]] += size[p[i].se];\n\t\tif (!fa[p[i].se]) return puts(\"-1\"), 0;\n\t\tT[fa[p[i].se]].push_back(p[i].se);\n\t}\n\n\tif (!check()) return puts(\"-1\"), 0;\n\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (fa[i]) printf(\"%d %d\\n\", i, fa[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#define LL long long\nusing namespace std;\nint n;\nLL dis,D;\nconst int N=100010;\nint siz[N],X[N],Y[N];\nstruct dian\n{\n\tLL dis;int id;\n\tfriend bool operator <(const dian &a,const dian &b)\n\t\t{return a.dis<b.dis;}\n}d[N];\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(\"%lld\",&D),d[i]=(dian){D,i},siz[i]=1;\n\tsort(d+1,d+1+n);\n\tfor(int i=n,pos;i>1;--i)\n\t{\n\t\tD=d[i].dis-n+(siz[i]<<1);\n\t\tpos=lower_bound(d+1,d+1+n,(dian){D,0})-d;\n\t\tif(d[pos].dis!=D)return puts(\"-1\")==2333;\n\t\tX[i]=d[i].id;Y[i]=d[pos].id;\n\t\tsiz[pos]+=siz[i];dis+=siz[i];\n\t}\n\tif(dis!=d[1].dis)return puts(\"-1\")==2333;\n\tfor(int i=2;i<=n;++i)printf(\"%d %d\\n\",X[i],Y[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <map>\n\nint n;\nstruct point{\n\tlong long D;\n\tint id;\n}num[100001];\nstd::map<long long,int>map;\nint size[100001],fa[100001],dep[100001];\nbool cmp(const point &a,const point &b){return a.D>b.D;}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&num[i].D),num[i].id=map[num[i].D]=i,size[i]=1;\n\tstd::sort(num+1,num+n+1,cmp);\n\tfor(int i=1;i<n;i++)\n\t\tif(!(fa[i]=map[num[i].D+(size[num[i].id])-(n-size[num[i].id])])||(fa[i]==num[i].id))\n\t\t\t{puts(\"-1\");return 0;}\n\t\telse size[fa[i]]+=size[num[i].id];\n\tfor(int i=n-1;i;i--)num[n].D-=(dep[num[i].id]=dep[fa[i]]+1);\n\tif(num[n].D){puts(\"-1\");return 0;}\n\tfor(int i=1;i<n;i++)printf(\"%d %d\\n\",fa[i],num[i].id);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(X,A,B) for(int X=A;X<=B;X++)\n#define tep(X,A,B) for(int X=A;X>=B;X--)\n#define LL long long\n#define DB double\nconst int N=400010;\nconst int M=800010;\nusing namespace std;\n\nint n;\nmap<LL,int> mp;\nLL sz[N];\nint fa[N],edge[M],lst[N],nxt[M],t=0;\n\nstruct nn{\n\tLL d;\n\tint id;\n}a[N];\n\nint cmp(nn A,nn B){\n\treturn A.d<B.d;\n}\n\nvoid READ(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n)scanf(\"%lld\",&a[i].d),a[i].id=i,mp[a[i].d]=i;\n\tsort(a+1,a+n+1,cmp);\n}\n\nvoid ADD(int x,int y){\n\tedge[++t]=y;nxt[t]=lst[x];lst[x]=t;\n}\n\nLL SEARCH(int x,int dep){\n\tLL res=dep;\n\tfor(int r=lst[x];r;r=nxt[r]){\n\t\tres+=SEARCH(edge[r],dep+1);\n\t}\n\treturn res;\n}\n\nint SOLVE(){\n\trep(i,1,n)sz[i]=1;\n\ttep(i,n,2){\n\t\tint x=a[i].id;\n\t\tLL d=a[i].d;\n\t\tLL now=d+2*sz[x]-n;\n\t\tint pos=mp[now];\n\t\tif(pos==0||now>=a[i].d)return 0;\n\t\tfa[x]=pos;\n\t\tADD(fa[x],x);\n\t\tsz[fa[x]]+=sz[x];\n\t}\n\tLL sum=SEARCH(a[1].id,0);\n\tif(sum!=a[1].d)return 0;\n\trep(i,1,n){\n\t\tif(i==a[1].id)continue;\n\t\tprintf(\"%d %d\\n\",i,fa[i]);\n\t}\n\treturn 1;\n}\n\nint main(){\n\tREAD();\n\tif(!SOLVE())printf(\"-1\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define biu (puts(\"-1\"), exit(0))\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename Tp> inline void getint(Tp &num){\n\tregister int ch, neg = 0;\n\twhile(!isdigit(ch = getchar())) if(ch == '-') neg = 1;\n\tnum = ch & 15;\n\twhile(isdigit(ch = getchar())) num = num * 10 + (ch & 15);\n\tif(neg) num = -num;\n}\n\nint N, siz[100005], tope = 0;\nstruct disData {ll d; int id;} D[100005];\nstruct Edge {int np; Edge *nxt;} E[100005], *V[100005];\n\ninline bool operator < (const disData &d1, const disData &d2) {return d1.d < d2.d;}\ninline void addedge(const int &u, const int &v) {E[++tope].np = v, E[tope].nxt = V[u], V[u] = E + tope;}\n\nint main(){\n\tgetint(N);\n\tfor(register int i = 1; i <= N; i++) getint(D[i].d), D[i].id = i, siz[i] = 1;\n\tsort(D + 1, D + N + 1);\n\tfor(register int i = N; i > 1; i--){\n\t\tif((siz[i] << 1) >= N) biu;\n\t\tconst ll d = D[i].d - N + (siz[i] << 1);\n\t\tconst int fa = lower_bound(D + 1, D + i, (disData){d, 0}) - D;\n\t\tif(D[fa].d != d) biu; siz[fa] += siz[i], addedge(fa, i);\n\t}\n\tfor(register int i = 1; i <= N; i++)\n\t\tfor(register Edge *ne = V[i]; ne; ne = ne->nxt) printf(\"%d %d\\n\", D[i].id, D[ne->np].id);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint N;\nint D[100010];\nint cnt[100010];\nint ansu[100010], ansv[100010];\n\nint bsrch(int ll, int rr, int vv)\n{\n\tint l=ll, r=rr;\n\tint m;\n\twhile(l<r){\n\t\tm = (l+r)/2;\n\t\tif(D[m] >= vv){\n\t\t\tr = m;\n\t\t}\n\t\telse\n\t\t\tl = m+1;\n\t}\n\treturn l;\n}\n\nint solve()\n{\n\tint i, j=0;\n\tsort(D, D+N);\n\tfor(i=N-1; i>0; i--){\n\t\tint p = bsrch(0, i, D[i]-(N-2-cnt[i]*2) );\n\t\tif(p>=i || D[p]!=D[i]-(N-2-cnt[i]*2) )\n\t\t\treturn 0;\n\t\tcnt[p] += cnt[i]+1;\n\t\tansu[j] = p;\n\t\tansv[j] = i;\n\t\tj ++;\n\t}\n\tfor(i=0; i<N-1; i++){\n\t\tprintf(\"%d %d\\n\", ansu[i]+1, ansv[i]+1);\n\t}\n\treturn 1;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\tint i;\n\tscanf(\"%d\", &N);\n\tfor(i=0; i<N; i++)\n\t\tscanf(\"%d\", &D[i]);\n\tif(solve() == 0)\n\t\tprintf(\"-1\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!=================================================!//\n//!   .88888.                             dP        !//\n//!  d8'   '88                            88        !//\n//!  88        88d888b. .d8888b. 88d888b. 88d888b.  !//\n//!  88   YP88 88'  '88 88'  '88 88'  '88 88'  '88  !//\n//!  Y8.   .88 88       88.  .88 88.  .88 88    88  !//\n//!   '88888'  dP       '88888P8 88Y888P' dP    dP  !//\n//!                              88                 !//\n//!                              dP                 !//\n//!=================================================!//\ntemplate <typename Cost>\nstruct BaseGraph\n{\n    BaseGraph(const std::size_t v) : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const std::size_t from, const std::size_t to, const Cost cost, const bool bi = false)\n    {\n        assert(from < V), assert(to < V);\n        edge[from].push_back(Edge{to, cost}), rev_edge[to].push_back(Edge(from, cost));\n        if (bi) { addEdge(to, from, cost, false); }\n    }\n    struct Edge\n    {\n        Edge(const std::size_t to, const Cost cost) : to{to}, cost{cost} {}\n        const std::size_t to;\n        const Cost cost;\n        bool operator<(const Edge& e) const { return cost != e.cost ? cost < e.cost : to < e.to; }\n    };\n    const std::vector<Edge>& operator[](const std::size_t i) const { return assert(i < V), edge[i]; }\n    friend std::ostream& operator<<(std::ostream& os, const BaseGraph& g)\n    {\n        os << \"[\\n\";\n        for (std::size_t i = 0; i < g.V; i++) {\n            for (const auto& e : g.edge[i]) { os << i << \"->\" << e.to << \":\" << e.cost << \"\\n\"; }\n        }\n        return (os << \"]\\n\");\n    }\n    static std::size_t to(const Edge& e) { return e.to; }\n    const std::size_t V;\n    std::vector<std::vector<Edge>> edge, rev_edge;\n};\ntemplate <>\nstruct BaseGraph<void>\n{\n    BaseGraph(const std::size_t v) : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const std::size_t from, const std::size_t to, const bool bi = false)\n    {\n        assert(from < V), assert(to < V);\n        edge[from].push_back(to), rev_edge[to].push_back(from);\n        if (bi) { addEdge(to, from, false); }\n    }\n    const std::vector<std::size_t>& operator[](const std::size_t i) const { return assert(i < V), edge[i]; }\n    friend std::ostream& operator<<(std::ostream& os, const BaseGraph& g)\n    {\n        os << \"[\\n\";\n        for (std::size_t i = 0; i < g.V; i++) {\n            for (const std::size_t to : g.edge[i]) { os << i << \"->\" << to << \"\\n\"; }\n        }\n        return (os << \"]\\n\");\n    }\n    static std::size_t to(const std::size_t e) { return e; }\n    const std::size_t V;\n    std::vector<std::vector<std::size_t>> edge, rev_edge;\n};\nusing Graph = BaseGraph<void>;\nusing Tree = Graph;\ntemplate <typename Cost>\nusing CostGraph = BaseGraph<Cost>;\ntemplate <typename Cost>\nusing CostTree = CostGraph<Cost>;\n//!==============================================================================!//\n//!  dP     dP          oo                       88888888b oo                dP  !//\n//!  88     88                                   88                          88  !//\n//!  88     88 88d888b. dP .d8888b. 88d888b.    a88aaaa    dP 88d888b. .d888b88  !//\n//!  88     88 88'  '88 88 88'  '88 88'  '88     88        88 88'  '88 88'  '88  !//\n//!  Y8.   .8P 88    88 88 88.  .88 88    88     88        88 88    88 88.  .88  !//\n//!  'Y88888P' dP    dP dP '88888P' dP    dP     dP        dP dP    dP '88888P8  !//\n//!==============================================================================!//\nclass UnionFind\n{\npublic:\n    UnionFind(const std::size_t v) : V(v), parent(v), size(v, 1) { std::iota(parent.begin(), parent.end(), 0); }\n    std::size_t find(const std::size_t a) { return assert(a < V), parent[a] == a ? a : parent[a] = find(parent[a]); }\n    bool same(const std::size_t a, const std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        return find(a) == find(b);\n    }\n    void unite(std::size_t a, std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        a = find(a), b = find(b);\n        if (a == b) { return; }\n        if (size[a] < size[b]) { std::swap(a, b); }\n        size[a] += size[b], parent[b] = a;\n    }\n    std::size_t getSize(const std::size_t a) { return assert(a < V), size[find(a)]; }\n    friend std::ostream& operator<<(std::ostream& os, const UnionFind& uf)\n    {\n        os << \"[\";\n        for (std::size_t i = 0; i < uf.parent.size(); i++) { os << uf.parent[i] << (i + 1 == uf.parent.size() ? \"\" : \",\"); }\n        return (os << \"]\\n\");\n    }\n\nprivate:\n    const std::size_t V;\n    std::vector<std::size_t> parent, size;\n};\n//!=====================================!//\n//!  8888ba.88ba           oo           !//\n//!  88  '8b  '8b                       !//\n//!  88   88   88 .d8888b. dP 88d888b.  !//\n//!  88   88   88 88'  '88 88 88'  '88  !//\n//!  88   88   88 88.  .88 88 88    88  !//\n//!  dP   dP   dP '88888P8 dP dP    dP  !//\n//!=====================================!//\nint main()\n{\n    const int N = read<int>();\n    const auto D = readVec<ll>(N);\n    std::map<ll, int, std::greater<ll>> mp;\n    for (int i = 0; i < N; i++) { mp[D[i]] = i; }\n    UnionFind uf(N);\n    Tree T(N);\n    for (const auto& p : mp) {\n        const ll d = p.first;\n        const int v = p.second;\n        const ll dpar = (d - N + 2 * uf.getSize(v));\n        if (uf.getSize(v) == N) { break; }\n        if (mp.find(dpar) == mp.end()) { return std::cout << -1 << std::endl, 0; }\n        const int par = mp[dpar];\n        T.addEdge(par, v, true), uf.unite(par, v);\n    }\n    ll ans = 0;\n    auto dfs = [&](auto&& self, const int s, const int p, const ll d) -> void {\n        ans += d;\n        for (const int to : T[s]) {\n            if (to == p) { continue; }\n            self(self, to, s, d + 1);\n        }\n    };\n    dfs(dfs, 0, -1, 0);\n    if (ans != D[0]) { return std::cout << -1 << std::endl, 0; }\n    for (int i = 0; i < N; i++) {\n        for (const int to : T[i]) {\n            if (to > i) { std::cout << i + 1 << \" \" << to + 1 << std::endl; }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//I love Nanami Chiaki\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define mp make_pair\n#define fst first\n#define snd second\nconst int maxn=1e5+7;\nint n,d[maxn];\npli sx[maxn];\nint sz[maxn];\nll dis[maxn];\nint findit(ll t){\n\tif (t<0) return -1;\n\tint l=0,r=n-1,mid;\n\twhile (l<=r){\n\t\tmid=(l+r)>>1;\n\t\tif (sx[mid].fst==t) return mid;\n\t\tif (sx[mid].fst<t) l=mid+1;\n\t\telse r=mid-1;\n\t}\n\treturn -1;\n}\nvoid badend(){\n\tputs(\"-1\");\n\texit(0);\n}\nvector<pii> ans;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=0;i<n;i++){\n\t\tscanf(\"%lld\",d+i);\n\t\tsx[i]=mp(d[i],i);\n\t\tsz[i]=1;dis[i]=0;\n\t}\n\tsort(sx,sx+n);\n\tfor (int i=n-1;i>0;i--){\n\t\tint v=sx[i].snd;\n\t\tll w=sx[i].fst;\n\t\tint u=findit(w+1ll*sz[v]*2-n);\n\t\tif (u==-1) badend();\n\t\tu=sx[u].snd;\n\t\tsz[u]+=sz[v];\n\t\tans.push_back(mp(u+1,v+1));\n\t\tdis[u]+=dis[v]+sz[v];\n\t}\n\tif (dis[sx[0].snd]!=sx[0].fst) badend();\n\tfor (int i=0;i<n-1;i++){\n\t\tprintf(\"%d %d\\n\",ans[i].fst,ans[i].snd);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <iterator>\n\nusing lli=long long;\n\nint main(){\n  int N;\n  std::cin >> N;\n\n  std::vector<lli> D_arr(N);\n  for(int i = 0; i < N; i++) std::cin >> D_arr[i];\n\n  std::sort(D_arr.begin(), D_arr.end(), std::greater<lli>());\n\n  std::vector<std::tuple<lli, lli>> node_info(N, std::make_tuple(1, 0));\n\n  bool fail=false;\n  std::vector<std::tuple<lli, lli>> edges;\n  for(int i = 0; i < N-1; i++){\n    lli nnodes, length;\n    std::tie(nnodes, length) = node_info[i];\n    lli parent_d = D_arr[i]-(N-nnodes)+nnodes;\n    auto parent_it = std::lower_bound(D_arr.rbegin(), D_arr.rend(), parent_d);\n    if(parent_it == D_arr.rend() || *parent_it != parent_d){\n      fail=true;\n      break;\n    }\n    lli parent = std::distance(D_arr.begin(), parent_it.base()-1);\n    edges.push_back(std::make_tuple(i, parent));\n    std::get<0>(node_info[parent]) += nnodes;\n    std::get<1>(node_info[parent]) += length+nnodes;\n  }\n  if(std::get<1>(node_info[N-1]) != D_arr[N-1]) fail=true;\n\n  if(fail){\n    std::cout << -1 << std::endl;\n  }else{\n    for(auto&& it: edges){\n      std::cout << std::get<0>(it)+1 << \" \" << std::get<1>(it)+1 << std::endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define eb emplace_back\n#define fi first\n#define se second\nusing namespace std;\nusing cd = complex <double>;\n\nconst long long INF = 1e18; \nconst long long mod = 998244353;//200003;786433;1e9 + 7;\nconst double Pi = acos(-1);\n  \nvoid Fastio()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n}\n\nint n;\nint root;\nint dsu[100005];\nlong long mindis = INF;\nlong long d[100005], sz[100005], h[100005];\nmap <long long, int> M; \nvector <pair <int, int> > Edge;\nvector <int> Adj[100005];\n\nvoid DFS(int node, int p = -1)\n{\n\tsz[node] = 1;\n\tfor(auto x : Adj[node])\n\t{\n\t\tif(x == p)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\th[x] = h[node] + 1;\n\t\tDFS(x, node);\n\t\tsz[node] += sz[x];\n\t}\n}\n\nint Root(int node)\n{\n\treturn dsu[node] == node ? node : dsu[node] = Root(dsu[node]);\n}\n\nsigned main()\n{\n\tFastio();\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tcin >> d[i];\n\t\tsz[i] = 1;\n\t\tM[d[i]] = i;\n\t\tdsu[i] = i;\n\t\tif(d[i] < mindis)\n\t\t{\n\t\t\troot = i;\n\t\t\tmindis = d[i];\n\t\t}\n\t}\n\twhile(M.size() > 1)\n\t{\n\t\tpair <long long, int> temp = *(prev(M.end()));\n\t\tlong long realdis = temp.fi - n + sz[temp.se] * 2;\n\t\tif(M.count(realdis) == false)\n\t\t{\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\tif(Root(temp.se) == Root(M[realdis]))\n\t\t{\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\tdsu[Root(temp.se)] = Root(M[realdis]);\n\t\tEdge.eb(temp.se, M[realdis]);\n\t\tsz[M[realdis]] += sz[temp.se];\n\t\tM.erase(temp.fi);\n\t}\n\tif(Edge.size() != n - 1 || sz[root] != n)\n\t{\n\t\tcout << \"-1\";\n\t\treturn 0;\n\t}\n\tfor(auto x : Edge)\n\t{\n\t\tAdj[x.fi].eb(x.se);\n\t\tAdj[x.se].eb(x.fi);\n\t}\n\tDFS(root);\n\tmindis = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tmindis += h[i];\n\t}\n\tif(mindis != d[root])\n\t{\n\t\tcout << \"-1\";\n\t\treturn 0;\n\t}\n\tfor(auto x : Edge)\n\t{\n\t\tcout << x.fi << ' ' << x.se << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100010;\n\ntypedef long long LL;\n\nLL D[N]; int id[N], sz[N];\nmap<LL, int> mp;\n\ninline void Fuck() {\n\tputs(\"-1\"), exit(0);\n}\n\nvector<int> G[N];\n\ninline void adde(int from, int to) {\n\tG[from].push_back(to), G[to].push_back(from);\n}\n\nLL dfs(int u, int f) {\n\tLL res = 0;\n\tfor (auto v : G[u]) if (v != f) \n\t\tres += dfs(v, u) + sz[v];\n\treturn res;\n}\n\nint main() {\n\tint n; scanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", &D[i]), mp[D[i]] = i, sz[i] = 1, id[i] = i;\n\tsort(id + 1, id + n + 1, [](int a, int b){return D[a] > D[b];});\n\tfor (int i = 1; i < n; i++) {\n\t\tint v = id[i];\n\t\tLL tmp = D[v] - n + sz[v] * 2;\n\t\tif (!mp.count(tmp) || tmp >= D[v]) Fuck();\n\t\tadde(v, mp[tmp]), sz[mp[tmp]] += sz[v];\n\t}\n\tif (dfs(id[n], 0) != D[id[n]]) Fuck();\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (auto v : G[i]) if (v > i) printf(\"%d %d\\n\", i, v);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define pii pair<int,int> \n\nint N;\nint a[100010];\nmap<int,int> exist;\n\nint fa[100010];\nvector<int> son[100010];\n\npriority_queue<pii> q,nq;\n\nvector<pii> ans;\n\nmain()\n{\n\tmemset(fa,-1,sizeof(fa));\n\t\n\tcin>>N;\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tcin>>a[i];\n\t\texist[a[i]]=i;\n\t\tq.push({a[i],i});\n\t}\n\t\n\tfor(int SZ=1;;SZ++)\n\t{\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tpii u=q.top(); q.pop();\n//\t\t\tcout<<\"SZ=\"<<SZ<<\" top:\"<<u.first<<\" \"<<u.second<<endl;\n\t\t\tif(exist[u.first-N+2*SZ])\n\t\t\t{\n\t\t\t\tfa[u.second]=exist[u.first-N+2*SZ];\n\t\t\t\tson[exist[u.first-N+2*SZ]].push_back(u.second);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnq.push(u);\n\t\t\t}\n\t\t}\n\t\twhile(!nq.empty())\n\t\t{\n\t\t\tq.push(nq.top()); nq.pop();\n\t\t}\n\t\tif(q.empty()) break;\n\t}\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tfor(int j=0;j<son[i].size();j++)\n\t\t{\n\t\t\tint& s=son[i][j];\n\t\t\tans.push_back({min(i,s),max(i,s)});\n\t\t}\n\t}\n\tsort(ans.begin(),ans.end());\n\tans.erase(unique(ans.begin(),ans.end()),ans.end());\n\tfor(int i=0;i<ans.size();i++)\n\t{\n\t\tpii& o=ans[i];\n\t\tif(o.first==o.second)\n\t\t{\n\t\t\tcout<<\"-1\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=0;i<ans.size();i++)\n\t{\n\t\tpii& o=ans[i];\n\t\tcout<<o.first<<\" \"<<o.second<<endl;\n\t}\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ln                '\\n'\n#define all(dat)           dat.begin(), dat.end()\n#define loop(i, to)        for (int i = 0; i < to; ++i)\n#define cont(i, to)        for (int i = 1; i <= to; ++i)\n#define circ(i, fr, to)    for (int i = fr; i <= to; ++i)\n#define foreach(i, dat)    for (__typeof(dat.begin()) i = dat.begin(); i != dat.end(); ++i)\n\ntypedef long long          num;\n\nusing namespace std;\n\nconst int nsz = 1e5;\nint n, rt, siz[nsz + 5];\nnum w[nsz + 5];\nmap<num, int> id, to;\nvector<int> g[nsz + 5];\nvector<pair<int, int>> ans;\n\nnum inline cmp(num a, num b) {\n    return a > b;\n}\n\nnum calc(int u = rt, int dep = 0) {\n    num res = dep;\n    for (int v : g[u]) {\n        res += calc(v, dep + 1);\n    }\n    return res;\n}\n\nint main() {\n    freopen(\"dat.in\", \"r\", stdin);\n    ios_base::sync_with_stdio(0);\n    cin >> n;\n    rt = n;\n    cont (i, n) {\n        cin >> w[i];\n        to[w[i]] = i;\n    }\n    fill(siz, siz + sizeof(siz) / sizeof(int), 1);\n    sort(w + 1, w + n + 1, cmp);\n    cont (i, n) {\n        id[w[i]] = i;\n    }\n    cout << ln;\n    cont (u, n) {\n        if (u == rt)  continue;\n        int v = id[w[u] - n + 2 * siz[u]];\n        if (!v) {\n            cout << -1 << ln;\n            return 0;\n        }\n        siz[v] += siz[u];\n        g[v].push_back(u);\n        ans.push_back({to[w[u]], to[w[v]]});\n    }\n    if (calc() != w[n]) {\n        cout << -1 << ln;\n        return 0;\n    }\n    for (pair<int, int> p : ans) {\n        cout << p.first << ' ' << p.second << ln;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100005\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate <class T> inline void read(T &x) {\n\tchar ch; bool flag = false;\n\twhile (!isdigit(ch = getchar())) flag |= ch == '-';\n\tfor (x = ch ^ 48; isdigit(ch = getchar()); x = x * 10 + (ch ^ 48));\n\tif (flag) x = -x;\n}\n\ninline int input() {\n\tint x; char ch; bool flag = false;\n\twhile (!isdigit(ch = getchar())) flag |= ch == '-';\n\tfor (x = ch ^ 48; isdigit(ch = getchar()); x = x * 10 + (ch ^ 48));\n\treturn flag ? -x : x;\n}\n\nconst int mod = 1e9 + 7;\ninline int add(int x, int y) { x += y; return x >= mod ? x - mod : x; }\ninline void inc(int &x, int y) { x += y; x -= x >= mod ? mod : 0; }\n\ninline int Power(int x, int y) {\n\tint res = 1;\n\twhile (y) {\n\t\tif (y & 1) res = (ll) res * x % mod;\n\t\tx = (ll) x * x % mod, y >>= 1;\n\t} return res;\n}\n\ntemplate <class T> void chkmax(T &x, T y) { x = x > y ? x : y; }\ntemplate <class T> void chkmin(T &x, T y) { x = x < y ? x : y; }\ntemplate <class T> T gcd(T x, T y) { return !y ? x : gcd(x % y, y); }\n\nint n;\nll d[N];\nint size[N], fa[N];\nmap<ll, int> mp;\n\t\nvoid FAIL() {\n\tputs(\"-1\");\n\texit(0);\n}\n\nint id(int x) { return mp[d[x]]; }\n\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n; ++i) size[i] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tread(d[i]), mp[d[i]] = i;\n\t\tif (d[i] > (ll) n * (n - 1) / 2) FAIL();\n\t}\n\tsort(d + 1, d + n + 1);\n\n\tfor (int i = n; i > 1; --i) {\n\t\tll vf = d[i] - n + size[i] + size[i];\n\t\tif (vf > d[i]) FAIL();\n\t\tfa[i] = lower_bound(d + 1, d + n + 1, vf) - d;\n\t\tif (d[fa[i]] != vf) FAIL();\n\t\tsize[fa[i]] += size[i];\n\t}\n\n\tfor (int i = 2; i <= n; ++i)\n\t\tprintf(\"%d %d\\n\", id(i), id(fa[i]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\n\n\n\n    \nint main(){\n    ll n;\n    cin>>n;\n    vector<ll> a(n);\n    map<ll,ll> M;\n    for(int i=0;i<n;i++){\n        cin>>a[i];\n        M[a[i]]=i+1;\n    }\n    sort(a.begin(),a.end(),greater<ll>());\n    vector<ll> parent(n,-1);\n    vector<ll> count(n,1);\n    vector<ll> cost(n,0);\n    for(int i=0;i+1<n;i++){\n        ll to=a[i]-n+count[i]*2;\n        ll I=lower_bound(a.begin(),a.end(),to,greater<ll>())-a.begin();\n        if(I==n || a[I]!=to){cout<<-1<<endl; return 0;}\n        count[I]+=count[i];\n        cost[I]+=cost[i]+count[i];\n        parent[i]=I;\n    }\n    if(cost[n-1]!=a[n-1]){cout<<-1<<endl; return 0;}\n    for(int i=0;i<n-1;i++){\n        cout<<M[a[i]]<<\" \"<<M[a[parent[i]]]<<endl;\n    }\n    \n    \n        \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxN = 1e5 + 10;\nlong long d[maxN];\nint sz[maxN];\nint n;\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i) cin >> d[i];\n\tfor (int i = 1; i <= n; ++i) sz[i] = 1;\n\tmap<long long, int, greater<long long>> p;\n\tfor (int i = 1; i <= n; ++i) p[d[i]] = i;\n\tvector<pair<int, int>> edges;\n\tbool fun = 1;\n\twhile (p.size() > 1) {\n\t\tauto f = p.begin(); p.erase(f);\n\t\tlong long d_p = (f->first + 2*sz[f->second] - n);\n\t\tfun &= p.count(d_p);\n\t\tif (not fun) break;\n\t\tint r = p[d_p];\n\t\tsz[r] += sz[f->second];\n\t\tedges.push_back({r, f->second});\n\t}\n\tfun &= sz[(p.begin())->second] == n;\n\tif (fun) {\n\t\tfor (auto e : edges) {\n\t\t\tcout << e.first << \" \" << e.second << endl;\n\t\t}\n\t} else puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<unordered_map>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+10;\nll d[N];\nunordered_map<ll,vector<int> > p;\nll cnt[N],sum[N],n,r[N];\nvector<pair<int,int> > w;\nbool comp(int a,int b){\n\treturn d[a]>d[b];\n}\nint main()\n\tcin>>n;\n\tfor (int i=1;i<=n;i++)scanf(\"%lld\",&d[i]),r[i]=i,p[d[i]].push_back(i),cnt[i]=1;\n\tsort(r+1,r+n+1,comp);\n\tfor (int i=1;i<n;i++){\n\t\tll x=r[i],s=d[x]-(n-2*cnt[x]),y;\n\t\tif (p[s].empty()||s>=d[x]){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\ty=p[s].back();\n\t\tw.push_back(make_pair(x,y));\n\t\tcnt[y]+=cnt[x];\n\t}\n\tfor (int i=0;i<n-1;i++)printf(\"%d %d\\n\",w[i].first,w[i].second);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define RI register int\ntypedef long long LL;\n\n#define FILEIO(name) freopen(name\".in\", \"r\", stdin), freopen(name\".out\", \"w\", stdout);\n\nusing namespace std;\n\nchar buf[1000000], *p1 = buf, *p2 = buf;\ninline char gc() {\n  if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin);\n  return p1 == p2 ? EOF : *(p1++);\n}\ntemplate <class T> inline void read(T &n) {\n  n = 0; RI ch = gc(), f;\n  while ((ch < '0' || ch > '9') && (ch != '-')) ch = gc();\n  f = (ch == '-' ? ch = gc(), -1 : 1);\n  while (ch >= '0' && ch <= '9') n = n * 10 + (ch ^ 48), ch = gc();\n  n *= f;\n}\n\nint const MAXN = 1e5 + 5;\npair <int, int> G[MAXN], t[MAXN];\nmap <int, int> mp;\nint size[MAXN];\n\nint main() {\n\n#ifdef LOCAL\n  FILEIO(\"a\");\n#endif\n\n  int n; read(n);\n  for (RI i = 1; i <= n; ++i)\n    read(t[i].first), t[i].second = i, mp[t[i].first] = i;\n  sort(t + 1, t + 1 + n);\n  int edge = 0;\n  for (RI i = n; i > 1; --i) {\n    ++size[t[i].second];\n    int to = t[i].first - n + 2 * size[t[i].second];\n    if (mp.find(to) != mp.end()) {\n      size[mp[to]] += size[t[i].second];\n      G[++edge] = make_pair(mp[to], t[i].second);\n    }\n  }\n  if (edge != n - 1) puts(\"-1\");\n  else\n    for (RI i = 1; i <= edge; ++i)\n      printf(\"%d %d\\n\", G[i].first, G[i].second);\n  \n  cerr << (double)(clock()) / CLOCKS_PER_SEC * 1000 << \"ms\" << endl;\n\n  return 0;\n}\n\n// created by Daniel yuan"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimiz(O2)\n\n#include <bits/stdc++.h>\n\n#define rg register\nusing namespace std;\ntypedef long long ll;\n\ntemplate<typename T>\ninline bool read(T &n) {\n    T ans = 0, flag = 1;\n    char ch;\n    while ((ch = getchar()) < '0' || ch > '9') if (ch == '-') flag = -1; else if (ch == EOF) return false;\n    ans = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9') ans = ans * 10 + ch - '0';\n    n = ans * flag;\n    return true;\n}\n\ninline ll read() {\n    ll ans = 0, flag = 1;\n    char ch;\n    while ((ch = getchar()) < '0' || ch > '9') if (ch == '-') flag = -1;\n    ans = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9') ans = ans * 10 + ch - '0';\n    return ans * flag;\n};\nconst int maxn = 100005;\nstruct NODE {\n    ll val, ord;\n    bool operator<(NODE b) const {\n        return val < b.val;\n    }\n} node[maxn];\nstruct EDGE{\n    int nex,t;\n}edge[maxn<<1];\n\nint ecnt,head[maxn],siz[maxn],fa[maxn];\nunordered_map<ll,int> unM;\ninline void addedge(int u,int v){\n    edge[++ecnt].nex=head[u];head[u]=ecnt;edge[ecnt].t=v;\n    edge[++ecnt].nex=head[v];head[v]=ecnt;edge[ecnt].t=u;\n}\nll dfs(int rt,int fa,int dis){\n    ll ans=dis;\n    for(rg int i=head[rt];i;i=edge[i].nex){\n        int y=edge[i].t;\n        if(y==fa) continue;\n        ans+=dfs(y,rt,dis+1);\n    }\n    return ans;\n}\nint main() {\n    int n;\n    read(n);priority_queue<NODE> pq;\n    for (rg int i = 1; i <= n; ++i) {\n        siz[i] = 1;read(node[i].val);\n        node[i].ord = i;\n        pq.push(node[i]);\n        unM[node[i].val]=i;\n    }\n    for(rg int i=n;i>=2;i--){\n        NODE now=pq.top();pq.pop();\n        if(unM.find(now.val+2*siz[now.ord]-n)==unM.end()){\n            puts(\"-1\");return 0;\n        }\n        fa[now.ord]=unM[now.val+2*siz[now.ord]-n];\n        siz[fa[now.ord]]+=siz[now.ord];\n        addedge(now.ord,fa[now.ord]);\n    }\n    if(siz[pq.top().ord]!=n||dfs(pq.top().ord,0,0)!=pq.top().val) puts(\"-1\");\n    else for(rg int i=1;i<=n;i++){\n        if(fa[i]) cout<<i<<' '<<fa[i]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nll n;\nvpll a;\nvl s;\nvvl g;\n\nll dfs(ll v,ll p,ll d){\n\tll res=d;\n\tfor(auto u:g[v]) if(u!=p) res+=dfs(u,v,d+1);\n\treturn res;\n}\n\nint main(){\n\tcin>>n;\n\ta=vpll(n);\n\ts=vl(n,1);\n\tg=vvl(n);\n\tfor(int i=0;i<n;i++){\n\t\tll x;\n\t\tcin>>x;\n\t\ta[i]={x,i};\n\t}\n\tsort(a.begin(),a.end());\n\tfor(int i=n-1;i>0;i--){\n\t\tll d=a[i].first,t=d+2*s[i]-n;\n\t\tll id=lower_bound(a.begin(),a.end(),pll(t,0))-a.begin();\n\t\tif(id>=i||a[id].first!=t){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tll u=a[i].second,v=a[id].second;\n\t\ts[id]+=s[i];\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tif(dfs(a[0].second,-1,0)==a[0].first){\n\t\tfor(int u=0;u<n;u++) for(auto v:g[u]) if(u<v) cout<<u+1<<' '<<v+1<<endl;\n\t}\n\telse cout<<-1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long int LL;\nconst int Max_N(100050);\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nstruct node\n{\n\tint u;\n\tLL d;\n};\nint N, Head[Max_N], Next[Max_N], Size[Max_N];\nnode V[Max_N];\nmap<LL, int> S;\n\ninline void Add_Edge(int s, int t)\n{\n\tNext[t] = Head[s], Head[s] = t;\n}\n\ninline bool comp(const node &a, const node &b)\n{\n\treturn a.d > b.d;\n}\n\nLL Sum;\nvoid dfs(int u, int dep)\n{\n\tSum += dep;\n\tfor (int v = Head[u];v;v = Next[v])\n\t\tdfs(v, dep + 1);\n}\n\nvoid dfs2(int u)\n{\n\tif (S[Sum] != u)\n\t{\n\t\tprint(-1);\n\t\texit(0);\n\t}\n\tfor (int v = Head[u];v;v = Next[v])\n\t\tSum += (N - Size[v]) - Size[v], dfs2(v), Sum -= (N - Size[v]) - Size[v];\n}\n\nint main()\n{\n\tgi(N);\n\tfor (int i = 1;i <= N;++i)\n\t\tgi(V[i].d), S[V[i].d] = V[i].u = i, Size[i] = 1;\n\tsort(V + 1, V + 1 + N, comp);\n\tfor (int i = 1, u, fa;i <= N;++i)\n\t{\n\t\tif (i == N)\n\t\t\tbreak;\n\t\tu = V[i].u;\n\t\tLL d = V[i].d - (N - Size[u]) + Size[u];\n\t\tif (d >= V[i].d || !(fa = S[d]))\n\t\t{\n\t\t\tprint(-1);\n\t\t\treturn 0;\n\t\t}\n\t\tAdd_Edge(fa, u), Size[fa] += Size[u];\n\t}\n\tdfs(1, 0);\n\tdfs2(1);\n\tfor (int u = 1;u <= N;++u)\n\t\tfor (int v = Head[u];v;v = Next[v])\n\t\t\tprint(u), putc(' '), print(v), putc('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//300iq\n#define ll long long\n#define pii pair<int,int> \n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fi first\n#define se second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nvector<pair<ll,int> > e;\nmap<ll,int> ret;\nint n;\ninline void die(){\n    puts(\"-1\");\n    exit(0);\n}\nint main(){\n    cin>>n;\n    for(int i=0;i<n;i++){\n        ll x;\n        cin>>x;\n        ret[x]=i;\n        e.pb(mp(x,i));\n    }\n    sort(e.begin(),e.end());\n    reverse(e.begin(),e.end());\n    ll x=e.back().first;\n    vector<int> siz(n,1);\n    vector<int> dp(n,0);\n    vector<pii> ans;\n    for(int i=0;i<e.size();i++){\n        pair<ll,ll> c=e[i];\n        if(c.first==x) continue;\n        if(siz[c.se]*2>=n)\n            die();\n        ll need=c.first+2*siz[c.se]-n;\n        if(!ret.count(need))\n            die();\n        int par=ret[need];\n        dp[par]+=dp[c.se]+siz[c.se];\n        siz[par]+=siz[c.se];\n        ans.pb(mp(c.se+1,par+1));\n    }\n    if(dp[e.back().se]!=x)\n        die();\n    for(int i=0;i<ans.size();i++)\n        cout<<ans[i].fi<<\" \"<<ans[i].se<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<algorithm>\n#include<math.h>\n#include<string>\nusing namespace std;\n#define int long long\n#define ll long long\n#define vel vector<ll>\n#define vvel vector<vel>\n#define sor(a) sort(a.begin(),a.end())\n#define rev(a) reverse(a.begin(),a.end())\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)\n#define pin pair<ll,ll>\nint ze = 0;\nsigned main(){\n\tint n; cin >> n;\n\tvel d(n);\n\tvector<pin> md(n);\n\trep(i, n) { cin >> d[i]; md[i] = make_pair(d[i], i); }\n\tsor(md);\n\tvel pa(n, -1);\n\tvel all_chi(n, 1); vel all_dist(n, 0);\n\tfor(int i=n-1;i>0;i--) {\n\t\tpin q = md[i];\n\t\tint num = q.second;\n\t\tif (all_chi[num] * 2 >= n) { cout << -1 << endl; return 0; }\n\t\tint next_val = q.first + 2 * all_chi[num] - n;\n\t\tauto next_itr = lowerbound(md, make_pair(next_val, ze));\n\t\tif ((*next_itr).first != next_val) { cout << -1 << endl; return 0; }\n\t\tint next_num = (*next_itr).second;\n\t\tpa[num] = next_num;\n\t\tall_chi[next_num] += all_chi[num];\n\t\tall_dist[next_num] += all_dist[num] + all_chi[num];\n\t}\n\tif(md[0].first!=all_dist[md[0].second]) { cout << -1 << endl; return 0; }\n\trep(i, n) {\n\t\tif (pa[i] != -1) {\n\t\t\tcout << i+1 << \" \" << pa[i]+1 << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define ln                '\\n'\n#define all(dat)           dat.begin(), dat.end()\n#define loop(i, to)        for (int i = 0; i < to; ++i)\n#define cont(i, to)        for (int i = 1; i <= to; ++i)\n#define circ(i, fr, to)    for (int i = fr; i <= to; ++i)\n#define foreach(i, dat)    for (__typeof(dat.begin()) i = dat.begin(); i != dat.end(); ++i)\n\ntypedef long long          num;\n\nusing namespace std;\n\nconst int nsz = 1e5;\nint n, rt, siz[nsz + 5];\npair<num, int> w[nsz + 5];\nmap<num, int> id;\nvector<int> g[nsz + 5];\nvector<pair<int, int>> ans;\n\nnum inline cmp(pair<num, int> a, pair<num, int> b) {\n    return a.first > b.first;\n}\n\nint calc(int u = rt, int dep = 0) {\n    int res = dep;\n    for (int v : g[u]) {\n        res += calc(v, dep + 1);\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> n;\n    cont (i, n) {\n        cin >> w[i].first;\n        w[i].second = i;\n        id[w[i].first] = i;\n    }\n    fill(siz, siz + sizeof(siz) / sizeof(int), 1);\n    sort(w + 1, w + n + 1, cmp);\n    rt = id[w[n].first];\n    cont (it, n) {\n        int u = w[it].second;\n        if (u == rt)  continue;\n        int v = id[w[it].first - n + 2 * siz[u]];\n        if (!v) {\n            cout << -1 << ln;\n            return 0;\n        }\n        siz[v] += siz[u];\n        g[v].push_back(u);\n        ans.push_back({u, v});\n    }\n    if (calc() != w[n].first) {\n        cout << -1 << ln;\n        return 0;\n    }\n    for (pair<int, int> p : ans) {\n        cout << p.first << ' ' << p.second << ln;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <map>\n\ntypedef long long ll;\nconst int N = 1e5 + 51;\nstruct edge {\n\tint to, next;\n} e[N << 1];\nint head[N], cnt;\nvoid addedge(int x, int y) {\n\te[++cnt] = (edge){y, x[head]}, x[head] = cnt;\n\te[++cnt] = (edge){x, y[head]}, y[head] = cnt;\n}\nvoid dfs(int x, int p) {\n\tfor (int i = x[head], nx; i; i = e[i].next)\n\t\tif ((nx = e[i].to) != p) printf(\"%d %d\\n\", x, nx), dfs(nx, x);\n}\n\nstd::map<ll, int> mp;\nint n, sz[N];\nll a[N];\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", a + i), i[sz] = 1;\n\tstd::sort(a + 1, a + n + 1, std::greater<ll>());\n\tfor (int i = 1; i <= n; i++) mp[a[i]] = i;\n\tfor (int i = 1; i < n; i++) {\n\t\tll tmp = a[i] - n + 2 * i[sz];\n\t\tif (tmp == a[i] || !mp.count(tmp)) return puts(\"-1\"), 0;\n\t\tint nx = mp[tmp];\n\t\tnx[sz] += i[sz];\n\t\taddedge(i, nx);\n\t}\n\tdfs(1, 0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\nusing namespace std;\nint n,d[100005];\nvector<long long>a,qz(n,1),dist(n,-1),x(1,0);\nmap<long long,int>mp;\nvector<pair<int,int> >res;\nvector<vector<int> >nmp;\nint main(){\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>d[i];\n\t\ta.push_back(d[i]);\n\t\tmp[d[i]]=i;\n\t}\n\tsort(d,d+n);\n\tfor(int i=n-1;i>=0;i--){\n\t\tlong long net=d[i]-(n-qz[i]*2);\n\t\tif(mp.find(net)==mp.end()||mp[net]==i){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tres.push_back(make_pair(i,mp[i]));\n\t\tqz[mp[i]]+=qz[i];\n\t\tmp.erase(--mp.end());\t\t\n\t}\n\tdist[0]=0;\n\tfor(int i=0;i<res.size();i++){\n\t\tnmp[res[i].first].push_back(res[i].second);\n\t\tnmp[res[i].second].push_back(res[i].first);\n\t}\n\tfor(int i=0;i<x.size();i++){\n\t\tfor(int j=0;j<nmp[x[i]].size();j++){\n\t\t\tif(dist[nmp[x[i]][j]]==-1){\n\t\t\t\tx.push_back(nmp[x[i]][j]);\n\t\t\t\tdist[nmp[x[i]][j]]=dist[x[i]]+1;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ansd=0;\n\tfor(int i=0;i<dist.size();i++){\n\t\tansd+=dist[i];\n\t}\n\tif(ansd!=d[0]){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<res.size();i++){\n\t\tcout<<res[i].first+1<<\" \"<<res[i].second+1<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXn = 1e5 + 10;\ntypedef pair<long long, int> pii;\npii ar[MAXn];\nlong long n, sz[MAXn], root, disroot, d[MAXn], hp3[MAXn];\nvector<int> vec[MAXn];\nvector<pii> ans;\n\nbool cmp(pii p1, pii p2) {\n\treturn p1.first > p2.first;\n}\n\nlong long dfs1(int v, int  par) {\n\tlong long res = 0;\n\tfor (int i = 0; i < vec[v].size(); i++)\n\t\tif (vec[v][i] != par) {\n\t\t\tres += dfs1(vec[v][i], v) + hp3[vec[v][i]];\n\t\t\thp3[v] += hp3[vec[v][i]];\n\t\t}\n\thp3[v]++;\n\tif (hp3[v] != sz[v])\n\t\texit(-1);\n\treturn res;\n\t\n}\n\nvoid dfs2(int v, int par, long long sth) {\n\tif (sth != d[v]) {\n\t\tcout << -1;\n\t\texit(0);\n\t}\n\tfor (int i = 0; i < vec[v].size(); i++) {\n\t\tif (vec[v][i] != par) {\n\t\t\tdfs2(vec[v][i], v, sth - (hp3[vec[v][i]]) + (hp3[ar[0].second] - hp3[vec[v][i]]));\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}\nint main() {\n\tcin >> n;\n\tfill_n(sz, MAXn, 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tint di;\n\t\tcin >> di;\n\t\td[i] = di;\n\t\tar[i].first = di;\n\t\tar[i].second = i;\n\t}\n\tsort(ar, ar + n);\n\tfor (int i = n - 1; i > 0; i--) {\n\t\tlong long hp = ar[i].first - n;\n\t\thp += 2LL * sz[ar[i].second];\n\t\tint hp2 = lower_bound(ar, ar + n, pii(hp, -1)) - ar;\n\t\tif (ar[hp2].first != hp)\n\t\t\treturn cout << -1,0;\n\t\tsz[ar[hp2].second] += sz[ar[i].second];\n\t\tvec[ar[hp2].second].push_back(ar[i].second);\n\t\tvec[ar[i].second].push_back(ar[hp2].second);\n\t\tans.push_back(pii(ar[i].second, ar[hp2].second));\n\t}\n\tdisroot = dfs1(ar[0].second, -1);\n\tdfs2(ar[0].second, -1, disroot);\n\tfor (int i = 0; i < ans.size(); i++)\n\t\tcout << ans[i].first + 1<< ' ' << ans[i].second + 1<< endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing i64 = long long;\n\nconst int N = 100000 + 7;\n\nint n;\nint s[N], e[N];\ni64 d[N], t;\nint u[N], v[N];\n\nint main() {\n//\tfreopen(\"code.in\", \"r\", stdin);\n//\tfreopen(\"code.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(\"%lld\", d + i), e[i] = i, s[i] = 1;\n\tstd::sort(e + 1, e + n + 1, [](int a, int b) {\n\t\treturn d[a] < d[b];\n\t});\n\tfor (int i = n; i > 1; --i) {\n\t\tint j = std::lower_bound(e + 1, e + n + 1, d[e[i]] - n + s[e[i]] * 2, [](int a, i64 b) {\n\t\t\treturn d[a] < b;\n\t\t}) - e;\n\t\tif (d[e[j]] != d[e[i]] - n + s[e[i]] * 2) return printf(\"-1\"), 0;\n\t\ts[e[j]] += s[e[i]], t += s[e[i]];\n\t\tu[i] = e[i], v[i] = e[j];\n\t}\n\tif (d[e[1]] != t) return printf(\"-1\"), 0;\n\tfor(int i = 2; i <= n; i++)\n\t\tprintf(\"%d %d\\n\", u[i], v[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define INF (1<<30)\n#define LINF (1LL<<60)\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FOR2(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define RFOR2(i,a,b) for(int i = (b);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define REP2(i,n)  FOR2(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define RREP2(i,n) RFOR2(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl\n#define SP << \" \" << \ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){if(a>b) {a=b; return true;} else return false;}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){if(a<b) {a=b; return true;} else return false;}\n#define MSB(x) (63-__builtin_clzll(x))\n#define pcnt(x) (__builtin_popcountll(x))\n#define parity(i,j) (i&(1LL<<j))\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nvec edge[101010],dist(101010),sum(101010);\n\nint dfs(int no, int par = -1, int d = 0){\n  int res = 0; sum[no] = 1;\n  for(int to:edge[no]){\n    if(to==par) continue;\n    res += dfs(to,no,d+1);\n    sum[no] += sum[to];\n  }\n  return res+d;\n}\n\nvoid dfs2(int no, int par = -1){\n  for(int to:edge[no]){\n    if(to==par) continue;\n    int x = sum[no]-sum[to];\n    dist[to] = dist[no] + x - sum[to];\n    sum[no] -= x; sum[to] += x;\n    dfs2(to,no);\n    sum[no] += x; sum[to] -= x;\n  }\n}\n\nvoid solve(){\n  int N;\n  cin >> N;\n\n  vector<P> D(N);\n  REP(i,N) cin >> D[i].fs, D[i].sc = i;\n  \n  sort(D.rbegin(),D.rend());\n\n  multiset<P> ms;\n  vec v(N,1);\n  REP(i,N){\n    auto itr = ms.upper_bound(P(D[i].fs,-1));\n    while(itr!=ms.end()&&(*itr).fs==D[i].fs){\n      int id = (*itr).sc;\n      v[i] += v[id];\n      edge[i].push_back(id);\n      edge[id].push_back(i);\n      itr = ms.erase(itr);\n    }\n    ms.insert(P(D[i].fs-N+2*v[i],i));\n  }\n\n  if(ms.size()>1){\n    cout << -1 << endl;\n    return;\n  }\n\n  dist[0] = dfs(0);\n  dfs2(0);\n\n  REP(i,N){\n    if(D[i].fs != dist[i]){\n      cout << -1 << endl;\n      return;\n    }\n  }\n\n  REP(i,N){\n    for(int j:edge[i]){\n      if(i<j) cout << D[i].sc+1 SP D[j].sc+1 << endl;\n    }\n  }\n\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int T = 1;\n  // cin >> T;\n\n  while(T--) solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nclock_t t=clock();\nnamespace my_std{\n\tusing namespace std;\n\t#define pii pair<int,int>\n\t#define pli pair<ll,int>\n\t#define fir first\n\t#define sec second\n\t#define MP make_pair\n\t#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n\t#define drep(i,x,y) for (int i=(x);i>=(y);i--)\n\t#define go(x) for (int i=head[x];i;i=edge[i].nxt)\n\t#define templ template<typename T>\n\t#define sz 101010\n\ttypedef long long ll;\n\ttypedef double db;\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ttempl inline T rnd(T l,T r) {return uniform_int_distribution<T>(l,r)(rng);}\n\ttempl inline bool chkmax(T &x,T y){return x<y?x=y,1:0;}\n\ttempl inline bool chkmin(T &x,T y){return x>y?x=y,1:0;}\n\ttempl inline void read(T& t)\n\t{\n\t\tt=0;char f=0,ch=getchar();double d=0.1;\n\t\twhile(ch>'9'||ch<'0') f|=(ch=='-'),ch=getchar();\n\t\twhile(ch<='9'&&ch>='0') t=t*10+ch-48,ch=getchar();\n\t\tif(ch=='.'){ch=getchar();while(ch<='9'&&ch>='0') t+=d*(ch^48),d*=0.1,ch=getchar();}\n\t\tt=(f?-t:t);\n\t}\n\ttemplate<typename T,typename... Args>inline void read(T& t,Args&... args){read(t); read(args...);}\n\tchar __sr[1<<21],__z[20];int __C=-1,__zz=0;\n\tinline void Ot(){fwrite(__sr,1,__C+1,stdout),__C=-1;}\n\tinline void print(register int x)\n\t{\n\t\tif(__C>1<<20)Ot();if(x<0)__sr[++__C]='-',x=-x;\n\t\twhile(__z[++__zz]=x%10+48,x/=10);\n\t\twhile(__sr[++__C]=__z[__zz],--__zz);__sr[++__C]='\\n';\n\t}\n\tvoid file()\n\t{\n\t\t#ifdef NTFOrz\n\t\tfreopen(\"a.in\",\"r\",stdin);\n\t\t#endif\n\t}\n\tinline void chktime()\n\t{\n\t\t#ifdef NTFOrz\n\t\tcout<<(clock()-t)/1000.0<<'\\n';\n\t\t#endif\n\t}\n\t#ifdef mod\n\tll ksm(ll x,int y){ll ret=1;for (;y;y>>=1,x=x*x%mod) if (y&1) ret=ret*x%mod;return ret;}\n\tll inv(ll x){return ksm(x,mod-2);}\n\t#else\n\tll ksm(ll x,int y){ll ret=1;for (;y;y>>=1,x=x*x) if (y&1) ret=ret*x;return ret;}\n\t#endif\n//\tinline ll mul(ll a,ll b){ll d=(ll)(a*(double)b/mod+0.5);ll ret=a*b-d*mod;if (ret<0) ret+=mod;return ret;}\n}\nusing namespace my_std;\n\nint n;\nll a[sz];\npli p[sz];\nmap<ll,int>mp;\n\nint fa[sz],size[sz];\nint getfa(int x){return x==fa[x]?fa[x]:fa[x]=getfa(fa[x]);}\nvoid merge(int x,int y){x=getfa(x),y=getfa(y);fa[x]=y,size[y]+=size[x];}\n\npii ans[sz];\n\nstruct hh{int t,nxt;}edge[sz<<1];\nint head[sz],ecnt;\nvoid make_edge(int f,int t)\n{\n\tedge[++ecnt]=(hh){t,head[f]};\n\thead[f]=ecnt;\n\tedge[++ecnt]=(hh){f,head[t]};\n\thead[t]=ecnt;\n}\n\nll up[sz],dn[sz];\n#define v edge[i].t\nvoid dfs1(int x,int fa){size[x]=1;go(x) if (v!=fa) dfs1(v,x),dn[x]+=dn[v]+size[v],size[x]+=size[v];}\nvoid dfs2(int x,int fa){go(x) if (v!=fa) up[v]=up[x]+dn[x]-(dn[v]+size[v])+(n-size[v]),dfs2(v,x);}\n#undef v\n\nint main()\n{\n\tfile();\n\tread(n);\n\trep(i,1,n) read(a[i]),p[i]=MP(a[i],i),mp[a[i]]=i;\n\tsort(p+1,p+n+1);\n\trep(i,1,n) fa[i]=i,size[i]=1;\n\tdrep(k,n,2)\n\t{\n\t\tint x=p[k].sec;\n\t\tll w=a[x]-(n-size[getfa(x)])+size[getfa(x)];\n\t\tif (!mp.count(w)||mp[w]==x) return puts(\"-1\"),0;\n\t\tans[k-1]=MP(x,mp[w]);\n\t\tmerge(x,mp[w]);\n\t\tmake_edge(x,mp[w]);\n\t}\n\tdfs1(1,0);dfs2(1,0);\n\trep(i,1,n) if (up[i]+dn[i]!=a[i]) return puts(\"-1\"),0;\n\trep(i,1,n-1) printf(\"%d %d\\n\",ans[i].fir,ans[i].sec);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <map> \n#include <cstring>\nusing namespace std;\n#define LL long long\nconst int N = 100010;\nLL d[N];\nqueue<int>q;\nint n;\nint dist[N],sz[N];\nmap<LL,int>mp;\nvector<int>g[N];\npair<int,int> edge[N];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(register int i = 1;i <= n;++i){\n\t\tscanf(\"%lld\",&d[i]);\n\t\tmp[d[i]] = i;\n\t\tsz[i] = 1;\n\t}\n\tfor(register int i = 1;i < n;++i){\n\t\tauto it = mp.rbegin();\n\t\tint x = it -> second;\n\t\tLL dy = d[x] - n + 2*sz[x];\n\t\tif(mp.find(dy) == mp.end() || mp[dy] == x)\n\t\t\treturn puts(\"-1\"),0;\n\t\tint y = mp[dy];\n\t\tedge[i] = make_pair(x,y);\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t\tsz[y] += sz[x];\n\t\tmp.erase(--mp.end());\n\t}\n\tmemset(dist,-1,sizeof(dist));\n\tdist[1] = 0;\n\tLL tot = 0;\n\tq.push(1);\n\twhile(q.size()){\n\t\tint x = q.front();\n\t\ttot += dist[x];\n\t\tq.pop();\n\t\tfor(auto y : g[x])\n\t\tif(dist[y] == -1){\n\t\t\tdist[y] = dist[x] + 1;\n\t\t\tq.push(y);\n\t\t}\n\t}\n\tif(tot != d[1])\n\t\treturn puts(\"-1\"),0;\n\tfor(int i = 1;i < n;++i)\n\t\tprintf(\"%d %d\\n\",edge[i].first,edge[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1LL << 60;\nconst double PI = 3.141592653589793238;\nconst double EPS = 1e-10;\ntypedef pair<int, int> P;\nvector<int> G[100000];\nint cnt[100000];\nint dist[100000];\nvoid dfs(int v, int p, int d) {\n\tdist[v] = d;\n\tfor (int to : G[v]) {\n\t\tif (to == p) continue;\n\t\tdfs(to, v, d + 1);\n\t}\n}\nint main() {\n\tint N;\n\tcin >> N;\n\tmap<ll, int> idx;\n\tvector<ll> D;\n\tfor (int i = 0; i < N; i++) {\n\t\tll d;\n\t\tcin >> d;\n\t\tidx[d] = i;\n\t\tD.push_back(d);\n\t}\n\tsort(D.begin(), D.end());\n\tfor (int i = 0; i < N; i++) cnt[i] = 1;\n\tvector<P> edge;\n\tfor (int i = N - 1; i > 0; i--) {\n\t\tint v = idx[D[i]];\n\t\tll X = D[i] + cnt[v] * 2 - N;\n\t\tif (idx.find(X) == idx.end()) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint u = idx[X];\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t\tcnt[u] += cnt[v];\n\t\tedge.emplace_back(u, v);\n\t}\n\tint v = idx[D[0]];\n\tdfs(v, -1, 0);\n\tll sum = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tsum += dist[i];\n\t}\n\tif (sum != D[0]) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tcout << edge[i].first + 1 << \" \" << edge[i].second + 1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N;\n\tcin >> N;\n\tvector< pair<cat, int> > D(N);\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> D[i].ff;\n\t\tD[i].ss = i;\n\t}\n\tsort(begin(D), end(D));\n\tmap<cat, int> M;\n\tfor(int i = 0; i < N; i++) M[D[i].ff] = i;\n\tvector<int> sz(N, 1);\n\tvector< pair<int, int> > E;\n\tfor(int i = N-1; i > 0; i--) {\n\t\tif(2*sz[i] >= N) {\n\t\t\tcout << \"-1\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tcat D_up = D[i].ff + sz[i] - (N-sz[i]);\n\t\tauto it = M.find(D_up);\n\t\tif(it == M.end()) {\n\t\t\tcout << \"-1\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tsz[it->ss] += sz[i];\n\t\tE.push_back({D[i].ss, D[it->ss].ss});\n\t}\n\tif(sz[0] != N || (int)E.size() != N-1) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\tvector< vector<int> > G(N);\n\tfor(int i = 0; i < N-1; i++) {\n\t\tG[E[i].ff].push_back(E[i].ss);\n\t\tG[E[i].ss].push_back(E[i].ff);\n\t}\n\tvector<int> dep(N, -1);\n\tdep[D[0].ss] = 0;\n\tqueue<int> q;\n\tq.push(D[0].ss);\n\twhile(!q.empty()) {\n\t\tALL_THE(G[q.front()], it) if(dep[*it] == -1) {\n\t\t\tdep[*it] = dep[q.front()] + 1;\n\t\t\tq.push(*it);\n\t\t}\n\t\tq.pop();\n\t}\n\tcat depsum = 0;\n\tfor(int i = 0; i < N; i++) {\n\t\tif(dep[i] == -1) {\n\t\t\tcout << \"-1\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tdepsum += dep[i];\n\t}\n\tif(depsum != D[0].ff) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\tfor(int i = 0; i < (int)E.size(); i++) cout << E[i].ff+1 << \" \" << E[i].ss+1 << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define str string\n#define fi first\n#define se second\n#define pb push_back\n#define SET(a, b) memset(a, b, sizeof(a))\n#define eps 1e-6\n#define pi atan(1) * 4\n#define mod 1000000007\n#define inf 1000000000\n#define llinf 1000000000000000000\n#define FOR(i, a, b, c) for (int i = (a); i <= (b); i += (c))\n#define FORD(i, a, b, c) for (int i = (a); i >= (b); i -= (c))\n#define FORl(i, a, b, c) for (ll i = (a); i <= (b); i += (c))\n#define FORDl(i, a, b, c) for (ll i = (a); i >= (b); i -= (c))\nusing namespace std;\nmap<ll, ll> inp;\npll order[100005];\nint sze[100005];\nint main () {\n\tint n;\n\tscanf(\"%d\", &n);\n\tFOR(i, 1, n, 1) {\n\t\tll t;\n\t\tscanf(\"%lld\", &t);\n\t\torder[i] = {t, i};\n\t\tinp[t] = i;\n\t\tsze[i] = 1;\n\t}\n\tsort(order + 1, order + n + 1);\n\tvector<pii> elist;\n\tFORD(i, n, 2, 1) {\n\t\tauto u = order[i];\n\t\tint s = sze[u.se];\n\t\tll nd = u.fi - (n - sze[u.se]) + sze[u.se];\n\t\tif (nd > u.fi || inp.find(nd) == inp.end() || inp[nd] == u.se) {\n\t\t\tprintf(\"-1\\n\"); return 0;\n\t\t}\n\t\telist.pb({u.se, inp[nd]});\n\t\tsze[inp[nd]] += sze[u.se];\n\t}\n\t/* for (auto &e : elist) {\n\t\tif (e.fi > e.se) swap(e.fi, e.se);\n\t}\n\tsort(elist.begin(), elist.end()); */\n\tfor (auto e : elist) {\n\t\tprintf(\"%d %d\\n\", e.fi, e.se);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*input\n15\n57\n62\n47\n45\n42\n74\n90\n75\n54\n50\n66\n63\n77\n87\n51\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\n\n//}}}\nconst ll maxn=300005;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=8000000000000000000LL;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=ll(1e9+7);\nconst double PI=acos(-1);\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\t\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n#define int ll\nll d[maxn];\nset<pll,greater<pll>> st;\nvector<pii> edge;\nint sz[maxn];\nint32_t main()\n{\n\tIOS;\n  cout<<-1<<'\\n';\n  return 0;\n  int n;\n\tcin>>n;\n\tREP(i,n) cin>>d[i];\n\tREP(i,n) st.insert(MP(d[i],i));\n\tREP(i,n) sz[i]=1;\n\n\twhile(SZ(st)>1){\n\t\tauto cur=*st.begin();\n\t\t// cout<<cur<<'\\n';\n\t\tst.erase(st.begin());\n\t\tll new_size=cur.F+sz[cur.S]-(n-sz[cur.S]);\n\t\tauto nxt=*st.lower_bound(MP(new_size,INF64));\n\t\tif(nxt.F!=new_size){\n\t\t\tcout<<\"-1\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tedge.pb(MP(cur.S,nxt.S));\n\t\tsz[nxt.S]+=sz[cur.S];\n\t}\n\tfor(int i=0;i<n-1;i++){\n\t\tcout<<edge[i].F+1<<' '<<edge[i].S+1<<'\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = int(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\nusing ll = long long;\nusing namespace std;\n\nvector<pair<int, int> > solve(int n, vector<ll> const & d) {\n    map<ll, int> index;\n    REP (i, n) {\n        index[d[i]] = i;\n    }\n\n    int root = index.begin()->second;\n    vector<pair<int, int> > edges;\n    vector<int> size(n, 1);\n    vector<ll> d1(n, 0);\n    for (auto it = index.rbegin(); ; ++ it) {\n        ll d_i; int i; tie(d_i, i) = *it;\n        if (i == root) break;\n        int d_parent = d_i - n + 2 * size[i];\n        if (not index.count(d_parent)) {\n            return vector<pair<int, int> >();\n        }\n        int parent = index[d_parent];\n        edges.emplace_back(parent, i);\n        size[parent] += size[i];\n        d1[parent] += d1[i] + size[i];\n    }\n\n    if (d1[root] != d[root]) {\n        return vector<pair<int, int> >();\n    }\n    return edges;\n}\n\nint main() {\n    int n; cin >> n;\n    vector<ll> d(n);\n    REP (i, n) cin >> d[i];\n    auto edges = solve(n, d);\n    if (edges.empty()) {\n        cout << -1 << endl;\n    } else {\n        for (auto edge : edges) {\n            int i, j; tie(i, j) = edge;\n            cout << i + 1 << ' ' << j + 1 << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <cstdio>\n#include <map>\n#define int long long\n#define pb push_back\n#define mp make_pair\n#define INF 0x3f3f3f3f\n#define Inf 1000000000000000000LL\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int>pii;\nint n;\nvector<int>d;\nvector<pii>ed;\nvector<int>G[100010];\nmap<int,int>mm;\nint dp[100010];\nint cnt[100010];\nbool vis[100010];\nint sz[100010];\nint ans[100010];\nvoid dfs(int x,int pr=-1LL){\n\tcnt[x]++;\n\tvis[x]=1;\n\tfor(auto to:G[x])if(to!=pr){\n\t\tif(vis[to])puts(\"-1\"),exit(0LL);\n\t\tdfs(to,x);\n\t\tdp[x]+=dp[to]+cnt[to];\n\t\tcnt[x]+=cnt[to];\n\t}\n}\nvoid dfs2(int x,int pr=-1LL,int w=0LL){\n\tans[x]=dp[x]+w;\n\tw+=dp[x];\n\tfor(auto to:G[x])if(to!=pr)dfs2(to,x,w-dp[to]-cnt[to]+(n-cnt[to]));\n}\nsigned main(){\n\t\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\tcin>>n;\n\tfor(int i=0LL;i<n;i++){\n\t\tint x;\n\t\tcin>>x;\n\t\td.pb(x);\n\t\tmm[x]=i;\n\t}\n\tfor(auto x=mm.rbegin();x!=mm.rend();x++){\n\t\tint node=x->S,val=x->F;\n\t\tsz[node]++;\n\t\tint op=n-sz[node];\n\t\tif(!op)continue;\n\t\tint nxt=val+sz[node]-op;\n\t\tif(mm.count(nxt)){\n\t\t\tint ne=mm[nxt];\n\t\t\tsz[ne]+=sz[node];\n\t\t\tG[ne].pb(node);\n\t\t\tG[node].pb(ne);\n\t\t\tif(ne>node)swap(ne,node);\n\t\t\ted.pb(mp(ne+1LL,node+1LL));\n\t\t}\n\t}\n\tdfs(0LL);\n\tdfs2(0LL);\n\tfor(int i=0;i<n;i++){\n\t\tif(!vis[i])return puts(\"-1\"),0;\n\t\tif(ans[i]!=d[i])return puts(\"-1\"),0;\n\t}\n\tfor(auto x:ed)cout<<x.F<<' '<<x.S<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define No {puts(\"-1\");return 0;}\n#define fo(i,l,r) for(int i=l;i<=r;i++)\n#define of(i,l,r) for(int i=l;i>=r;i--)\n#define fe(i,u) for(int i=head[u];i;i=e[i].next)\nusing namespace std;\ntypedef long long ll;\ninline void open(const char *s)\n{\n\t#ifndef ONLINE_JUDGE\n\tchar str[20];\n\tsprintf(str,\"in%s.txt\",s);\n\tfreopen(str,\"r\",stdin);\n//\tsprintf(str,\"out%s.txt\",s);\n//\tfreopen(str,\"w\",stdout);\n\t#endif\n}\ninline ll rd()\n{\n\tstatic ll x,f;\n\tx=0;f=1ll;\n\tchar ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1ll;\n\tfor(;ch>='0'&&ch<='9';ch=getchar())x=x*10ll+ch-'0';\n\treturn f>0?x:-x;\n}\nconst int N=100010;\nstruct edge{\n\tint u,v,next;\n\tedge(int u=0,int v=0,int next=0):u(u),v(v),next(next){}\n}e[N];\nint n,siz[N],rt;ll d[N];\nint tot=0,head[N];\nstruct node{\n\tll x;int id;\n\tinline friend bool operator<(const node &a,const node &b){return a.x>b.x;}\n}q[N];\nmap<ll,int>mp;\n\ninline void add(int u,int v){e[++tot]=edge(u,v,head[u]);head[u]=tot;}\n\nvoid dfs1(int u,int dep)\n{\n\td[rt]+=dep;\n\tfe(i,u){int v=e[i].v;dfs1(v,dep+1);}\n}\nvoid dfs2(int u)\n{\n\tfe(i,u){\n\t\tint v=e[i].v;\n\t\td[v]=d[u]+ll(n-(siz[v]<<1ll));\n\t\tdfs2(v);\n\t}\n}\n\nint main()\n{\n\tn=rd();fo(i,1,n)mp[q[q[i].id=i].x=rd()]=i,siz[i]=1;\n\tsort(q+1,q+n+1);\n\tfo(i,1,n-1){\n\t\tint x=q[i].id;\n\t\tint dd=q[i].x-n+(siz[x]<<1);\n\t\tif(dd>=q[i].x)No\n\t\tif(!mp.count(dd))No\n\t\tint fa=mp[dd];\n\t\tadd(fa,x);siz[fa]+=siz[x];\n\t}\n\trt=q[n].id;\n\tdfs1(rt,0);\n\tdfs2(rt);\n\tfo(i,1,n)if(d[q[i].id]!=q[i].x)No\n\tfo(u,1,n){\n\t\tfe(i,u){\n\t\t\tint v=e[i].v;\n\t\t\tprintf(\"%d %d\\n\",u,v);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\nll n, b[100005], fa[100005], length[100005], f[100005];\nbool islead[100005];\nstruct lala\n{\n\tll v, id;\n\tfriend bool operator < (lala a, lala b)\n\t{\n\t\treturn a.v > b.v;\n\t}\n}a[100005];\n\nll ef(ll ls, ll rs, ll val)\n{\n\tif (ls == rs) return ls;\n\tll mid = (ls + rs) / 2;\n\tif (a[mid].v <= val) return ef(ls, mid, val);\n\telse return ef(mid + 1, rs, val);\n}\n\nint main()\n{\n\tcin >> n;\n\tfor (ll i = 1; i <= n; i++) \n\t{\n\t\tcin >> a[i].v;\n\t\ta[i].id = i;\n\t\tb[i] = a[i].v;\n\t}\n\tsort(a + 1, a + n + 1);\n\tfor (ll i = 1; i <= n; i++)\n\t{\n\t\tlength[i] = 1;\n\t}\n\tfor (ll x = 1; x <= n; x++)\n\t{\n\t\tll i = ef(1, n, a[x].v - n + length[x] * 2);\n\t\tif (a[i].v == a[x].v - n + length[x] * 2 && a[x].v > a[i].v)\n\t\t{\n\t\t\tfa[x] = i;\n\t\t\tlength[i] += length[x];\n\t\t\tf[i] += f[x] + length[x];\n\t\t}\n\t}\n\tif (f[n] != a[n].v)\n\t{\n\t\tcout << \"-1\" << endl;\n\t\treturn 0;\n\t}\n\tfor (ll i = 1; i < n; i++)\n\t{\n\t\tcout << a[i].id << \" \" << a[fa[i]].id << endl;\n\t}\n\treturn 0;\n}\n/*\n7 10 15 13 18 11 14 19\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Maxn = 100005;\nint n, cnt, root, fa[Maxn], siz[Maxn], pos[Maxn], head[Maxn];\nlong long d[Maxn], dis[Maxn];\nmap <long long, int> Ma;\nstruct edg\n{\n\tint nxt, to;\n}edge[Maxn];\nvoid add(int x, int y)\n{\n\tedge[++cnt] = (edg){head[x], y};\n\thead[x] = cnt;\n}\nvoid dfs1(int u)\n{\n\tfor (int i = head[u]; i; i = edge[i].nxt)\n\t{\n\t\tint to = edge[i].to;\n\t\tdfs1(to), dis[u] += dis[to] + siz[to];\n\t}\n}\nvoid dfs2(int u)\n{\n\tfor (int i = head[u]; i; i = edge[i].nxt)\n\t{\n\t\tint to = edge[i].to;\n\t\tdis[to] = dis[u] + n - 2 * siz[to];\n\t\tdfs2(to);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\troot = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%lld\", &d[i]), pos[i] = i, Ma[d[i]] = i, siz[i] = 1;\n\tsort(pos + 1, pos + 1 + n, [](int x, int y){return d[x] < d[y];});\n\tfor (int i = n; i >= 1; i--)\n\t{\n\t\tMa[d[pos[i]]] = 0;\n\t\tfa[pos[i]] = Ma[d[pos[i]] - n + 2 * siz[pos[i]]];\n\t\tsiz[fa[pos[i]]] += siz[pos[i]];\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (!fa[i] && i != pos[1])\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tadd(fa[i], i);\n\t}\n\tdfs1(pos[1]);\n\tfor (int i = 2; i <= n; i++)\n\t\tdis[pos[i]] = 0;\n\tdfs2(pos[1]);\n\tfor (int i = 1; i <= n; i++)\n\t\tif (d[i] != dis[i])\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\tfor (int i = 2; i <= n; i++)\n\t\tprintf(\"%d %d\\n\", fa[pos[i]], pos[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline LL read(){\n\tLL x=0,f=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst int MAXN = 200010;\nconst LL INF = 2147483600;\n\nstruct dat{\n\tLL id,val;\n}a[MAXN+1]; LL N;\nbool cmpval(dat a,dat b){\n\treturn a.val>b.val;\n}\nLL Node[MAXN<<1],Next[MAXN<<1],Root[MAXN+1],cnt;\ninline void insert(LL u,LL v){\n\tNode[++cnt]=v; Next[cnt]=Root[u]; Root[u]=cnt; return ;\n} LL sz[MAXN+1],f[MAXN+1],b[MAXN+1];\ninline void dfs(LL k,LL Fa){\n\tsz[k]=1; for(LL x=Root[k];x;x=Next[x]){\n\t\tLL v=Node[x]; if(v==Fa) continue;\n\t\tdfs(v,k); sz[k]+=sz[v]; f[1]+=sz[v];\n\t} return ;\n}\ninline void dfs2(LL k,LL Fa){\n\tif(f[k]!=b[k]){ puts(\"-1\"); exit(0); }\n\tfor(LL x=Root[k];x;x=Next[x]){\n\t\tLL v=Node[x]; if(v==Fa) continue;\n\t\tf[v]=f[k]+N-2*sz[v]; dfs2(v,k);\n\t} return ;\n} LL s1[MAXN+1],s2[MAXN+1],top;\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tN=read();\n\tfor(LL i=1;i<=N;i++){\n\t\ta[i].id=i; a[i].val=read(); b[i]=a[i].val;\n\t} sort(a+1,a+N+1,cmpval);\n\tfor(LL i=1;i<=N;i++) sz[i]=1;\n\tfor(LL i=1;i<N;i++){\n\t\tLL val=a[i].val-N+2*sz[i]; \n\t\tLL l=i+1,r=N,pos=-1;\n\t\twhile(l<=r){\n\t\t\tLL mid=(l+r)>>1;\n\t\t\tif(a[mid].val>=val) pos=mid,l=mid+1;\n\t\t\telse r=mid-1;\n\t\t} if(pos==-1||a[pos].val!=val){\n\t\t\tputs(\"-1\"); return 0;\n\t\t} sz[pos]+=sz[i];\n\t\ts1[++top]=a[i].id; s2[top]=a[pos].id;\n\t\tinsert(a[i].id,a[pos].id);\n\t\tinsert(a[pos].id,a[i].id);\n\t\t//sz=N+a[fa]-a[i].val\n\t} dfs(1,0); dfs2(1,0);\n\tfor(LL i=1;i<=top;i++) printf(\"%lld %lld\\n\",s1[i],s2[i]); \n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntemplate <typename T> void read(T& t){ cin >> t; }\ntemplate <typename T, typename ... U> void read(T& t, U& ... u){ read(t); read(u ...); }\ntemplate <typename T> void write(T t){ cout << t; }\ntemplate <typename T, typename ... U> void write(T t, U ... u){ write(t); write(u ...); }\n//#define int long long\n#define FAST ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)\n#define size(x) (int)x.size()\n#define all(x) x.begin(),x.end()\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define ROF(i,b,a) for(int i=b; i>=a; --i)\nusing LL = long long;\nusing pii = pair<int,int>;\nconst int INF = 2e9;\nconst int NN = 1e5 + 3;\n\nint n;\nset<LL> s;\nset<LL> firstLeavesDist;\nmap<LL,int> id;\nmap<int,LL> dist, dist2;\nint sz[NN];\nvector<pii> e;\nvector<int> adj[NN];\n\nvoid checkConn(int u, set<int> &visited){\n\tvisited.insert(u);\n\tfor(int v: adj[u]) if(!visited.count(v)) checkConn(v, visited);\n}\n\nLL getDistSum(int u, int prv, int d){\n\tLL sum = 0;\n\tsum += d;\n\tfor(int v: adj[u]) if(v != prv) sum += getDistSum(v, u, d+1);\n\treturn sum;\n}\n\nvoid distributeDistSum(int u, int prv, LL sum){\n\tdist2[u] = sum;\n\tfor(int v: adj[u]) if(v != prv) distributeDistSum(v, u, sum - sz[v] + (n-sz[v]));\n}\n\nint32_t main(){ FAST;\n\tread(n);\n\tFOR(i,1,n){ LL d; read(d); s.insert(d); id[d] = i; dist[i] = d; }\n\n\tif(n == 2 || n == 3 || n == 4){\n\t\twrite(-1, \"\\n\");\n\t\treturn 0;\n\t}\n\n\tFOR(i,1,n) sz[i] = 1;\n\tROF(cnt,n,2){\n\t\tint d = *rbegin(s);\n\t\ts.erase(d);\n\t\tint i = id[d];\n\n\t\t// Dj = Di + sz - (n-sz)\n\t\tint nxtD = d + sz[i] - (n-sz[i]);\n\t\tif(!s.count(nxtD)){\n\t\t\twrite(-1, \"\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tint j = id[nxtD];\n\t\te.emplace_back(i,j);\n\t\tsz[j] += sz[i];\n\t}\n\n\tfor(pii edg: e){\n\t\tint u,v; tie(u,v) = edg;\n\t\tadj[u].emplace_back(v);\n\t\tadj[v].emplace_back(u);\n\t}\n\n\tint root = -1;\n\tFOR(i,1,n) if(sz[i] == n) root = i;\n\tif(root == -1){\n\t\twrite(-1, \"\\n\");\n\t\treturn 0;\n\t}\n\t\n\tset<int> visited;\n\tcheckConn(root, visited);\n\tif(!(size(visited) == n)){\n\t\twrite(-1, \"\\n\");\n\t\treturn 0;\n\t}\n\n\tLL sum = getDistSum(root,root,0);\n\n\tdistributeDistSum(root,root,sum);\n\n\tbool different = false;\n\tfor(auto el: dist) if(dist[el.first] != dist2[el.first]) different = true;\n\tfor(auto el: dist2) if(dist[el.first] != dist2[el.first]) different = true;\n\tif(different){\n\t\twrite(-1, \"\\n\");\n\t\treturn 0;\n\t}\n\n\tfor(pii edg: e) write(edg.first, \" \", edg.second, \"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MX=1e5+5;\npair<long long,int> a[MX];\nmap<long long,int> mp;\nlong long n;\nint p[MX];\nint visit[MX];\nlong long s[MX];\nlong long dp[MX];\nint main(){\n    cin.tie(0);\n    cout.tie(0);\n    ios_base::sync_with_stdio(0);\n    cin>>n;\n    int i;\n    for(i=1 ; i<=n ; i++){\n        cin>>a[i].first;\n      ///  a[i].first++;\n        a[i].second=i;\n        mp[a[i].first]=i;\n    }\n    sort(a+1,a+n+1);\n    for(i=n ; i>=2 ; i--){\n      ///  cout<<i<<endl;\n        s[a[i].second]++;\n\n        int k=mp[a[i].first+2*s[a[i].second]-n];\n        if(k==0 || k==a[i].second || a[i].first+2*s[a[i].second]-n>=a[i].first){\n            cout<<-1;\n            return 0;\n        }\n        s[k]+=s[a[i].second];\n        dp[k]+=dp[a[i].second]+s[a[i].second];\n        p[a[i].second]=k;\n    }\n    if(dp[a[1].second]!=a[1].first){\n        cout<<-1;\n        return 0;\n    }\n    for(i=2 ; i<=n ;i++){\n        cout<<a[i].second<<\" \"<<p[a[i].second]<<\"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\n#include<map>\n#define LL long long \nusing namespace std;\n\nconst int M = 100001;\nint n,m,k,a[M],s[M];\nmap<LL,int> mp;\nstruct vv\n{\n\tLL x;\n\tint w;\n} t[M];\n\nbool cmp(vv a,vv b){return a.x>b.x;}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&t[i].x);\n\t\tt[i].w=i; s[i]=1;\n\t\tmp[t[i].x]=i;\n\t}\n\tsort(t+1,t+1+n,cmp);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tLL k=t[i].x+s[t[i].w]-n+s[t[i].w];\n\t\tif(k==t[i].x || mp.find(k)==mp.end())\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\ta[t[i].w]=mp[k];\n\t\ts[mp[k]]+=s[t[i].w];\n\t}\n\tfor(int i=1;i<n;i++) printf(\"%d %d\\n\",t[i].w,a[t[i].w]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 100005\n#define error {puts(\"-1\");return 0;}\n#define ll long long\nusing namespace std;\n\nmap <ll,int> mp;\n\nstruct edge{\n\tint to,nxt;\n}e[maxn<<1];\n\nstruct node{\n\tll dis;int id;\n\tbool operator < (const node &A) const {return dis>A.dis;}\n}a[maxn];\n\nint cnt,head[maxn],dis[maxn],size[maxn],n,U[maxn],V[maxn];\n\nvoid add(int u,int v){\n\te[++cnt]=(edge){v,head[u]};\n\thead[u]=cnt;\n}\n\nvoid dfs(int u,int fa,int dep){\n\tdis[a[n].id]+=dep;size[u]=1;\n\tfor(int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif(v==fa) continue;\n\t\tdfs(v,u,dep+1);\n\t\tsize[u]+=size[v];\n\t}\n}\n\nvoid dfs(int u,int fa){\n\tfor(int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif(v==fa) continue;\n\t\tdis[v]=dis[u]+n-size[v]*2;\n\t\tdfs(v,u);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i].dis);\n\t\ta[i].id=i;\n\t\tmp[a[i].dis]=i;\n\t}\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++) size[i]=1;\n\tfor(int i=1;i<n;i++){\n\t\tint u=a[i].id;\n\t\tll tmp=n-size[u]*2;\n\t\tif(tmp<=0||!mp.count(a[i].dis-tmp)) error\n\t\tint fa=mp[a[i].dis-tmp];\n\t\tU[i]=fa;V[i]=u;size[fa]+=size[u];\n\t\tadd(u,fa);add(fa,u);\n\t}\n\tdfs(a[n].id,0,0);\n\tdfs(a[n].id,0);\n\tfor(int i=1;i<=n;i++) if(dis[a[i].id]!=a[i].dis) error\n\tfor(int i=1;i<n;i++) printf(\"%d %d\\n\",U[i],V[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\t\nusing namespace std;\nconst int MAX_N=1e5;\nconst ll INF=1e18;\nint N;\nll D[MAX_N];\n\nmap<ll,int> dmp;\nint par[MAX_N],chl[MAX_N];\nvector<int> G[MAX_N];\nll dist[MAX_N];\nint main(){\n\tcin>>N;\n\tREP(i,N)cin>>D[i];\n\tREP(i,N){\n\t\tdmp[D[i]]=i;\n\t}\n\tREP(i,N){\n\t\tpar[i]=-1;\n\t\tchl[i]=1;\n\t}\n\tbool flg=true;\n\t{\n\t\tauto ite=dmp.end();\n\t\tite--;\n\t\tfor(;;ite--){\n\t\t\tif (ite==dmp.begin()){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n//\t\t\tcout<<ite->second<<endl;\n\t\t\tll pd=ite->first-N+chl[ite->second]*2;\n\t\t\tif (pd>=ite->first || dmp.find(pd)==dmp.end()){\n\t\t\t\tflg=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint pr=dmp[pd];\n\t\t\tpar[ite->second]=pr;\n\t\t\tchl[pr]+=chl[ite->second];\n\t\t}\n\t}\n\tif (flg){\n//\t\tcout<<\"debug\"<<endl;\n\t\tint rot;\n\t\tREP(i,N){\n\t\t\tif (par[i]==-1){\n\t\t\t\trot=i;\n\t\t\t}else{\n\t\t\t\tG[i].push_back(par[i]);\n\t\t\t\tG[par[i]].push_back(i);\n\t\t\t}\n\t\t}\n\t\tqueue<int > que;\n\t\tREP(i,N){\n\t\t\tdist[i]=INF;\n\t\t}\n\t\tque.push(rot);\n\t\tdist[rot]=0;\n\t\twhile(!que.empty()){\n\t\t\tint v=que.front();\n\t\t\tque.pop();\n\t\t\tfor(auto e:G[v]){\n\t\t\t\tif (dist[e]==INF){\n\t\t\t\t\tdist[e]=dist[v]+1;\n\t\t\t\t\tque.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll sm=0;\n\t\tREP(i,N)sm+=dist[i];\n\t\tif (sm!=D[rot]){\n\t\t\tflg=false;\n\t\t}\n\t}\n\tif (flg){\n\t\tREP(i,N){\n\t\t\tif (par[i]!=-1){\n\t\t\t\tcout<<i+1<<\" \"<<par[i]+1<<endl;\n\t\t\t}\n\t\t}\n\t}else{\n\t\tcout<<-1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define re register\n#define gc getchar\n#define pc putchar\n#define cs const\n\ninline\nll getint(){\n\tre ll num;\n\tre char c;\n\twhile(!isdigit(c=gc()));num=c^48;\n\twhile(isdigit(c=gc()))num=(num<<1)+(num<<3)+(c^48);\n\treturn num;\n}\n\ninline\nvoid outint(int a){\n\tstatic char ch[13];\n\tif(a==0)pc('0');\n\twhile(a)ch[++ch[0]]=a-a/10*10,a/=10;\n\twhile(ch[0])pc(ch[ch[0]--]^48);\n}\n\ncs int N=100005;\n\nint last[N],nxt[N],to[N],ecnt;\ninline\nvoid addedge(int u,int v){\n\tnxt[++ecnt]=last[u],last[u]=ecnt,to[ecnt]=v;\n}\n\nmap<ll,int> id;\nint n;\nll d[N];\nint siz[N];\n\nint dist[N];\ninline\nvoid dfs(int u){\n\tfor(int re e=last[u],v=to[e];e;v=to[e=nxt[e]]){\n\t\tdist[v]=dist[u]+1;\n\t\tdfs(v);\n\t}\n}\n\nvector<pair<int,int> > edge;\n\nsigned main(){\n\tn=getint();\n\tfor(int re i=1;i<=n;++i)d[i]=getint(),id[d[i]]=i;\n\t\n\tsort(d+1,d+n+1);\n\tfor(int re i=1;i<=n;++i)siz[i]=1;\n\t\n\tfor(int re i=n;i>1;--i){\n\t\tint u=id[d[i]];\n\t\tint tmp=n-2*siz[u];\n\t\tif(tmp<=0)return puts(\"-1\"),0; \n\t\tll t=d[i]-tmp;\n\t\tif(id.count(t)==0)return puts(\"-1\"),0;\n\t\tint pos=id[t];\n\t\taddedge(pos,u);\n\t\tsiz[pos]+=siz[u];\n\t\tedge.push_back(make_pair(pos,u));\n\t}\n\tll sum=0;\n\tdfs(id[d[1]]);\n\tfor(int re i=1;i<=n;++i){\n\t\tsum+=dist[i];\n\t}\n\tif(sum!=d[1])return puts(\"-1\"),0;\n\tfor(int re i=0;i<edge.size();++i)outint(edge[i].first),pc(' '),outint(edge[i].second),pc('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <map>\nusing namespace std;\n#define fors(i,a,b) for(int i=(a);i<=(b);++i)\n#define ford(i,a,b) for(int i=(a);i>=(b);--i)\n#define min(x,y) ((x) < (y) ? (x) : (y))\n#define max(x,y) ((x) < (y) ? (y) : (x))\n#define swap(x,y) ((x)^=(y),(y)^=(x),(x)^=(y))\nconst int maxn=1e6+7;\ntypedef long long LL;\nconst int inf=1<<25;\nint read(){\n    int s=0,f=1;\n    char c=getchar();\n    while(c<'0' || c>'9') {if(c=='-') f=-1; c=getchar();}\n    while(c>='0' && c<='9') {s=s*10+c-48;c=getchar();}\n    return s*f;\n}\nvoid write(int x){\n    if(x<0) {putchar('-');x=-x;}\n    if(x>9) write(x/10);\n    putchar(x%10+48);\n}\n\nint abs(int x){\n    return x < 0 ? -x : x; \n}\nint tree[maxn];\nLL dis[maxn];\nint size[maxn],fa[maxn];\nint cmp(int x,int y){\n    return dis[x] < dis[y];\n}\n\n\nmap<LL,int> maps;\n\nint n;\nint main(int argc, char const *argv[])\n{\n    n=read();\n    fors(i,1,n){\n        dis[i]=read();\n        size[i]=1;\n        maps[dis[i]]=i;\n        tree[i]=i;\n    }\n    sort(tree+1,tree+1+n,cmp);\n\n    ford(i,n,2){\n        fa[tree[i]] = maps[dis[tree[i]] + 2*size[tree[i]]-n];\n        if(!fa[tree[i]]){\n            puts(\"-1\");\n            return 0;\n        }\n        size[fa[tree[i]]]+=size[tree[i]];\n    }\n    fors(i,2,n) \n        dis[tree[1]] -= size[tree[i]];\n\n    if(dis[tree[1]]){\n        puts(\"-1\");\n        return 0;\n    }\n    fors(i,2,n)\n        write(fa[tree[i]]),putchar(' '),write(tree[i]),putchar(10);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define fr first\n#define sc second\n\nint main(){\n\tstatic ll n;\n\tstatic ll d[100010];\n\tscanf(\"%lld\",&n);\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tscanf(\"%lld\",&d[i]);\n\t}\n\t\n\tvector<P> vec;\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tvec.push_back(P(d[i],i));\n\t}\n\tsort(vec.begin(),vec.end());\n\treverse(vec.begin(),vec.end());\n\t\n\tstatic ll cnt[100010];\n\tstatic ll dp[100010];\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tcnt[i] = 1;\n\t\tdp[i] = 0;\n\t}\n\t\n\tmap<ll,ll> id;\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tid[d[i]] = i;\n\t}\n\t\n\tvector<P> ans;\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tP p = vec[i-1];\n\t\t//cout << p.fr << \" \" << p.sc << endl;\n\t\tif(cnt[p.sc]*2 >= n)continue;\n\t\tll nx = d[p.sc]-(n-cnt[p.sc])+cnt[p.sc];\n\t\tif(id.find(nx) == id.end()){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tans.push_back(P(p.sc,id[nx]));\n\t\t\tcnt[id[nx]] += cnt[p.sc];\n\t\t\tdp[id[nx]] += dp[p.sc];\n\t\t\tdp[id[nx]] += cnt[p.sc];\n\t\t}\n\t}\n\tif(n%2 == 0){\n\t\tif(ans.size() != n-1){\n\t\t\tif(vec[n-2].fr != vec[n-1].fr){\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tans.push_back(P(vec[n-2].sc,vec[n-1].sc));\n\t\t\tif(vec[n-1].fr != dp[vec[n-1].sc]+dp[vec[n-2].sc]+n/2){\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif(vec[n-1].fr != dp[vec[n-1].sc]){\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tif(vec[n-1].fr != dp[vec[n-1].sc]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\t/*for(int i = 1 ; i <= n ; i ++){\n\t\tif(dp[i] != d[i]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}*/\n\t\n\tif(ans.size() < n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i = 0 ; i < ans.size() ; i ++){\n\t\tprintf(\"%d %d\\n\",ans[i].fr,ans[i].sc);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nnamespace IO\n{\n\tchar buf[1 << 20 | 1] , *f1 = buf , *f2 = buf , pbuf[1 << 24 | 1] , *f3 = pbuf , sta[100];\n\t#define gc() ((f1 == f2) && (f2 = (f1 = buf) + fread(buf,1,sizeof buf,stdin),f1 == f2) ? EOF : *f1 ++)\n\t#define gt() getchar()\n\tinline ll read()\n\t{\n\t\tll x = 0 , f = 1; char ch = gt();\n\t\twhile(ch < '0' || ch > '9')\t{if(ch == '-')\tf = -1; ch = gt();}\n\t\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = gt();}\n\t\treturn x * f;\n\t}\n\ttemplate <class T> inline void write(T x)\n\t{\n\t\tif(!x) return (void)(*f3 ++ = 48 , *f3 ++ = ' ');\n\t\tif(x < 0) *f3 ++ = '-' , x = ~x + 1;\n\t\tchar *top = sta;\n\t\twhile(x) *top ++ = x % 10 + 48 , x /= 10;\n\t\twhile(top != sta) *f3 ++ = *-- top;\n\t\t*f3 ++ = ' ';\n\t}\n\tinline void put(std::string s)\n\t{\n\t\tint len = s.length();\n\t\tfor(int i = 0;i < len;i ++) *f3 ++ = s[i];\n\t\t*f3 ++ = ' ';\n\t}\n\tinline void endline() { *f3 ++ = '\\n';}\n\t#define flush() fwrite(pbuf,1,f3 - pbuf,stdout)\n\ttemplate <class T> inline T abs(T a) { return a < 0 ? -a : a;}\n\ttemplate <class T> inline T max(T a,T b) { return a > b ? a : b;}\n\ttemplate <class T> inline T min(T a,T b) { return a < b ? a : b;}\n\ttemplate <class T> inline void swap(T &a,T &b) { T t = a; a = b; b = t;}\n}\nusing namespace IO;\nconst int N = 1e5 + 5;\nint n , cnt;\nint size[N] , u[N] , v[N];\nll dis;\nll D[N];\nstruct node\n{\n\tll d; int id;\n\tnode(ll d = 0,int id = 0) : d(d) , id(id) {}\n\tfriend bool operator < (const node &a,const node &b) { return a.d < b.d;}\n} e[N];\nint main()\n{\n\tn = read();\n\tfor(int i = 1;i <= n;i ++) e[i] = node(read(),i) , size[i] = 1;\n\tstd::sort(e + 1,e + 1 + n);\n\tfor(int i = n;i > 1;i --)\n\t{\n\t\tll dfa = e[i].d + 2 * size[i] - n;\n\t\tint j = std::lower_bound(e + 1,e + 1 + n,node(dfa)) - e;\n\t\tif(e[j].d != dfa) return puts(\"-1\") , 0;\n\t\tu[++ cnt] = e[i].id; v[cnt] = e[j].id;\n\t\tsize[j] += size[i];\n\t\tdis += size[i];\n\t}\n\tif(dis != e[1].d) return puts(\"-1\") , 0;\n\telse for(int i = 1;i <= cnt;i ++) printf(\"%d %d\\n\",u[i],v[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//jinhaonan\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntemplate<class T>inline void read(T &x){\n\tx=0;char c=getchar();bool f=0;\n\tfor(;c>'9'||c<'0';f=c=='-',c=getchar());\n\tfor(;c>='0'&&c<='9';x=(x<<1)+(x<<3)+c-'0',c=getchar());\n\tx=f?-x:x;\n}\ntemplate<class T>inline void write(T x){\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>=10)write(x/10);\n\tputchar(x%10+48);\n}\ntemplate<class T>inline bool chkmax(T &a,T const &b){\n\treturn a<b?a=b,1:0;\n}\ntemplate<class T>inline bool chkmin(T &a,T const &b){\n\treturn a>b?a=b,1:0;\n}\nconst int N=100000+10;\nvoid Main(){\n\tstatic pair<long long,int> d[N];\n\tstatic int size[N];\n\tstatic long long dis[N];\n\tmap<long long,int> p;\n\tvector<pair<int,int>> ans;\n\tint n;read(n);\n\tfor(int i=1;i<=n;++i){\n\t\tread(d[i].first);\n\t\td[i].second=i;\n\t\tp[d[i].first]=i;\n\t\tsize[i]=1;\n\t}\n\tsort(d+1,d+n+1);\n\tfor(int i=n;i>1;--i){\n\t\tlong long x=n-size[d[i].second]*2;\n\t\tif(x<=0){\n\t\t\tputs(\"-1\");\n\t\t\treturn;\n\t\t}\n\t\tx=d[i].first-x;\n\t\tauto it=p.find(x);\n\t\tif(it==p.end()){\n\t\t\tputs(\"-1\");\n\t\t\treturn;\n\t\t}\n\t\tdis[it->second]+=dis[d[i].second]+size[d[i].second];\n\t\tsize[it->second]+=size[d[i].second];\n\t\tans.push_back({d[i].second,it->second});\n\t}\n\tif(dis[d[1].second]!=d[1].first){\n\t\tputs(\"-1\");\n\t\treturn;\n\t}\n\tfor(auto e:ans){\n\t\twrite(e.first),putchar(' ');\n\t\twrite(e.second),putchar('\\n');\n\t}\n\n}\nint main(){\n    // freopen(\"in.txt\",\"r\",stdin);\n    // int test;read(test);\n    // while(test--){\n        Main();\n    // }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\n#define NMAX 100001\n\npair <long long, int> distances[NMAX];\nlong long v[NMAX];\nint bij[NMAX], par[NMAX], cnt[NMAX];\nvector <int> sons[NMAX];\nmap <long long, int> idx;\n\nbool solve(const int n) {\n    for (int i = 1; i <= n; i++) {\n        idx[v[i]] = i;\n    }\n    for (int i = n; i >= 2; i--) {\n        idx.erase(idx.find(v[i]));\n        cnt[i]++;\n        for (const int son : sons[i]) {\n            cnt[i] += cnt[son];\n        }\n        long long dp = v[i] + 2LL * cnt[i] - (long long)n;\n        if (idx.find(dp) == idx.end()) {\n            return false;\n        }\n        int p = idx[dp];\n        sons[p].push_back(i);\n        par[i] = p;\n    }\n    return true;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    int n;\n    // ifstream cin(\"code.in\");\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> distances[i].first;\n        distances[i].second = i;\n    }\n    sort(distances + 1, distances + n + 1);\n\n    for (int i = 1; i <= n; i++) {\n        v[i] = distances[i].first;\n        bij[i] = distances[i].second;\n    }\n\n    if (!solve(n)) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n\n    for (int i = 2; i <= n; i++) {\n        cout << bij[par[i]] << \" \" << bij[i] << '\\n';\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(i,a,n) for(int i=a;i<=n;++i)\n#define PER(i,a,n) for(int i=n;i>=a;--i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(a) ({REP(__i,1,n) cout<<a[__i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\n\n\nconst int N = 1e6+10;\nint n, sz[N];\nstruct _ {\n\tll d;\n\tint id;\n\tbool operator < (const _ &rhs) const {\n\t\treturn d<rhs.d;\n\t}\n} a[N];\nvector<pii> ans;\nvector<int> g[N];\n\nvoid add(int u, int v) {\n\tans.pb(pii(u,v));\n\tg[u].pb(v),g[v].pb(u);\n}\n\nvoid dfs(int x, int f, int d) {\n\ta[1].d -= d;\n\tfor (int y:g[x]) if (y!=f) dfs(y,x,d+1);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tREP(i,1,n) { \n\t\tscanf(\"%lld\",&a[i].d);\n\t\ta[i].id = i, sz[i] = 1;\n\t}\n\tsort(a+1,a+1+n);\n\tPER(i,2,n) {\n\t\t_ u{a[i].d+2*sz[a[i].id]-n,0};\n\t\tauto p = lower_bound(a+1,a+1+n,u);\n\t\tif (p->d!=u.d) return puts(\"-1\"),0;\n\t\tadd(a[i].id,p->id), sz[p->id] += sz[a[i].id];\n\t}\n\tdfs(1,0,0);\n\tif (a[1].d) return puts(\"1\"),0;\n\tfor (auto &t:ans) printf(\"%d %d\\n\",t.x,t.y);\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long int LL;\nconst int Max_N(100050);\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nstruct node\n{\n\tint u;\n\tLL d;\n};\nint N, Head[Max_N], Next[Max_N], Size[Max_N];\nnode V[Max_N];\nmap<int, int> S;\n\ninline void Add_Edge(int s, int t)\n{\n\tNext[t] = Head[s], Head[s] = t;\n}\n\ninline bool comp(const node &a, const node &b)\n{\n\treturn a.d > b.d;\n}\n\nLL Sum;\nvoid dfs(int u, int dep)\n{\n\tSum += dep;\n\tfor (int v = Head[u];v;v = Next[v])\n\t\tdfs(v, dep + 1);\n}\n\nvoid dfs2(int u)\n{\n\tif (S[Sum] != u)\n\t{\n\t\tprint(-1);\n\t\texit(0);\n\t}\n\tfor (int v = Head[u];v;v = Next[v])\n\t\tSum += (N - Size[v]) - Size[v], dfs2(v), Sum -= (N - Size[v]) - Size[v];\n}\n\nint main()\n{\n\tgi(N);\n\tfor (int i = 1;i <= N;++i)\n\t\tgi(V[V[i].u = i].d), S[V[i].d] = V[i].u, Size[i] = 1;\n\tsort(V + 1, V + 1 + N, comp);\n\tfor (int i = 1, u, fa;i <= N;++i)\n\t{\n\t\tu = V[i].u;\n\t\tLL d = V[i].d - (N - Size[u]) + Size[u];\n\t\tif (d >= V[i].d || !(fa = S[d]))\n\t\t{\n\t\t\tprint(-1);\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t\tAdd_Edge(fa, u), Size[fa] += Size[u];\n\t}\n\tdfs(1, 0);\n\tdfs2(1);\n\tfor (int u = 1;u <= N;++u)\n\t\tfor (int v = Head[u];v;v = Next[v])\n\t\t\tprint(u), putc(' '), print(v), putc('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Since g++10 is released, some characters is not valid inside #if 0 :(\n * So, why not using clang++? :D\n\n * Date:\n  2020.07.17\n\n * Solution:\n  不难发现 D 最小的数就是重心，把它作为根。\n  把所有点按 D 降序，一个个考虑其父亲节点，并维护每个点的 size 即可。\n\n * Digression:\n\n * CopyRight:\n          ▁▃▄▄▄▃▃▃▃▄▶\n        ▗▇▀▔    ▔▔▔▔\n       ▄▛   ▃▅━━■▄▂\n      ▟▊   ▐▘     ▀▙\n     ▟▜▌   ▐▖   ▋  ▐▍\n    ▟▘ ▜   ▝▀▇▆●▘  ▐▌\n  ▗▟▘   ▜▃       ▁▅▛\n  ▔▀▼▅▄▃▃██▅▄▄▄▅■▀▔\n        ▔▔▔▔▔▔\n */\n\n#include <cstdio>\n#include <algorithm>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\ntypedef std::pair<ll, int> par;\n\nstruct _ {\n    inline operator int () { int x; return scanf(\"%d\", &x), x; }\n    inline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n} read;\n\nconst int maxn = 100005;\npar p[maxn];\nint fa[maxn], size[maxn], dis[maxn];\n\nint main () {\n\tint n = read;\n\tif (n < 7) return puts(\"-1\"), 0;\n\n\tfor (int i = 1; i <= n; i ++) p[i] = par(read, i);\n\tstd::sort(p + 1, p + n + 1);\n\n\tfor (int i = 1; i <= n; i ++) size[i] = 1;\n\n\tfor (int i = n; i > 1; i --) {\n\t\tint u = p[i].second;\n\t\tll x = p[i].first - n + size[u] * 2;\n\t\tint j = int(std::lower_bound(p + 1, p + n + 1, par(x, 0)) - p);\n\t\tif (j > n or p[j].first != x) return puts(\"-1\"), 0;\n\t\tfa[u] = p[j].second;\n\t\tsize[fa[u]] += size[u];\n\t}\n\n\tll test = 0;\n\tfor (int i = 2; i <= n; i ++) {\n\t\tint u = p[i].second;\n\t\tdis[u] = dis[fa[u]] + 1;\n\t\ttest += dis[u];\n\t}\n\n\tif (test != p[1].first) return puts(\"-1\"), 0;\n\n\tfor (int u = 1; u <= n; u ++)\n\t\tif (fa[u])\n\t\t\tprintf(\"%d %d\\n\", fa[u], u);\n}\n"
  },
  {
    "language": "C++",
    "code": "//Written by Zhu Zeqi\n//Come on,baby\n//Hack,please\n#include <iostream> \n#include <cstdio> \n#include <fstream> \n#include <algorithm> \n#include <cmath> \n#include <deque> \n#include <vector> \n#include <queue> \n#include <string> \n#include <cstring> \n#include <map> \n#include <stack> \n#include <set> \n#define INF 0x3f3f3f3f3f3f3f3f\ntypedef long long ll;\n//orz yht\nusing namespace std;\nint n;\nvector<pair<ll,int> >v;\nmap<ll,int>mp;\nvector<pair<int,int> > ans;\nint main(){\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n    cin>>n;\n    for(int i=0;i<n;i++){\n    \tll x;\n    \tcin>>x;\n    \tmp[x]=i;\n    \tv.push_back(make_pair(x,i));\n\t}\n\tsort(v.rbegin(),v.rend());\n\tvector<int>sz(n,1);\n\tvector<ll>dp(n,0);\n\tfor(auto x : v){\n\t\tif(x.first!=v.back().first){\n\t\t\tif(sz[x.second]*2>=n){\n\t\t\t\tcout<<-1;\n\t\t\t\t\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tll need=x.first-(n-2*sz[x.second]);\n\t\t\tif(!mp.count(need)){\n\t\t\t\tcout<<-1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tll par=mp[need];\n\t\t\tdp[par]+=dp[x.second]+sz[x.second];\n\t\t\tsz[par]+=sz[x.second];\n\t\t\tans.push_back(make_pair(x.second+1,par+1));\n\t\t}\n\t}\n\tif(dp[v.back().second]!=v.back().first){\n\t\tcout<<-1;\n\t\treturn 0;\n\t}\n\tfor(auto x : ans)\n\tcout<<x.first<<\" \"<<x.second<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <map>\n\ntypedef long long ll;\nconst int N = 1e5 + 51;\nstruct edge {\n\tint to, next;\n} e[N << 1];\nint head[N], cnt;\nvoid addedge(int x, int y) {\n\te[++cnt] = (edge){y, x[head]}, x[head] = cnt;\n\te[++cnt] = (edge){x, y[head]}, y[head] = cnt;\n}\n\nll ans;\nvoid dfs(int x, int p, int d) {\n\tans += d;\n\tfor (int i = x[head], nx; i; i = e[i].next)\n\t\tif ((nx = e[i].to) != p) dfs(nx, x, d + 1);\n}\n\nint p[N];\nint f(int x) { return x[p] ? x[p] = f(x[p]) : x; }\nvoid l(int x, int y) {\n\tif ((x = f(x)) != (y = f(y))) x[p] = y;\n}\n\nstd::map<ll, int> mp;\nint n, sz[N];\nll a[N];\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", a + i), i[sz] = 1, mp[a[i]] = i;\n\tstd::sort(a + 1, a + n + 1, std::greater<ll>());\n\tfor (int i = 1; i < n; i++) {\n\t\tint x = mp[a[i]], nx;\n\t\tll tmp = a[i] - n + 2 * x[sz];\n\t\tif (tmp >= a[i] || !mp.count(tmp)) return puts(\"-1\"), 0;\n\t\tnx = mp[tmp];\n\t\tnx[sz] += x[sz];\n\t\tif (f(x) == f(nx)) return puts(\"-1\"), 0;\n\t\taddedge(x, nx);\n\t\tl(x, nx);\n\t}\n\tdfs(mp[a[1]], 0, 0);\n\tif (ans != a[1]) return puts(\"-1\"), 0;\n\tfor (int i = 1; i <= cnt; i += 2) printf(\"%d %d\\n\", e[i + 1].to, e[i].to);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <vector>\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\ntypedef long long ll;\n\nconst int N=1e5+5;\n\nint n,sz[N]; ll d_rt;\n\nstd::vector<int> g[N];\n\nstd::pair<ll,int> a[N];\n\nvoid dfs(int u,int dep){\n\td_rt+=dep; for(auto v: g[u]) dfs(v,dep+1);\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i){ scanf(\"%lld\",&a[i].fi); a[i].se=i; sz[i]=1; }\n\tstd::sort(a+1,a+1+n);\n\tfor(int i=n;i>=2;--i){\n\t\tint u=a[i].se; ll d_fa=a[i].fi+2*sz[u]-n;\n\t\tint pos=std::lower_bound(a+1,a+1+n,std::mp(d_fa,0))-a;\n\t\tif(a[pos].fi!=d_fa){ puts(\"-1\"); return 0; }\n\t\tsz[a[pos].se]+=sz[u]; g[a[pos].se].pb(u);\n\t}\n\tdfs(a[1].se,0); if(d_rt!=a[1].fi){ puts(\"-1\"); return 0; }\n\tfor(int u=1;u<=n;++u){\n\t\tstd::sort(g[u].begin(),g[u].end());\n\t\tfor(auto v: g[u]) printf(\"%d %d\\n\",u,v);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep3(i,a,b) for(int i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\n#define MAX_V 400010\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\ntemplate<typename A, size_t NNN, typename T>\nvoid Fill(A (&array)[NNN], const T &val){\n    fill( (T*)array, (T*)(array+NNN), val );\n}\n#define N 100100\n#define INF 1e9+7\nll MOD=1e9+7;\n\nll n;\nstruct node{\n    ll d;int id;\n};\nnode a[N];\nll s[N];\nmain(){\n    n=lin();\n    map<ll,int> m;\n    rep(i,n){\n        a[i]=node{lin(),i+1};\n        m[a[i].d]=a[i].id;\n    }\n    sort(a,a+n,[](node a,node b){\n        return a.d>b.d;\n    });\n    struct edge{\n        int from,to;\n        void print(){\n            printf(\"%d %d\\n\",from,to);\n        }\n    };\n    vector<edge> ans;\n    rep(i,n-1){\n        ll now=a[i].d;\n        ll t=s[a[i].id];\n        now-=n-(2+t*2);\n        cout<<now<<\" \"<<a[i].id<<endl;\n        if(!m[now]){\n            cout<<-1;return 0;\n        }\n        s[m[now]]+=t+1;\n        ans.pb(edge{a[i].id,m[now]});\n    }\n    else{\n        for(auto e:ans){\n            e.print();\n        }\n    }\n    return 0;\n}   \n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <memory.h>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stack>\n#include <deque>\n#include <numeric>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tmap<long long int, int> d_map;\n\tvector<pair<long long int, int> > d;\n\tfor(int i = 1; i <= n; i++){\n\t\tlong long int tmp;\n\t\tcin >> tmp;\n\t\td.push_back(make_pair(tmp, i));\n\t\td_map[tmp] = i;\n\t}\n\tsort(d.begin(), d.end());\n\treverse(d.begin(), d.end());\n\tvector<bool> ischecked(n, false);\n\tset<pair<int, int> > ans;\n\tfor(int i = 0; i < d.size(); i++){\n\t\tint now = d[i].second;\n\t\tlong long int nowd = d[i].first;\n\t\tif(ischecked[now]) continue;\n\t\tischecked[now] = true;\n\t\t// nowから1本でつながっている分をつなげていく\n\t\tint j = 1;\n\t\tfor(j = 1; j < n; j++){\n\t\t\tlong long int nextd = nowd - (n  - j) + j;\n\t\t\tif(nextd >= nowd || d_map.find(nextd) == d_map.end()){\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tint next = d_map[nextd];\n\t\t\t\tans.insert(make_pair(min(now, next), max(now, next)));\n\t\t\t\tischecked[next] = true;\n\t\t\t\tnow = next;\n\t\t\t\tnowd = nextd;\n\t\t\t}\n\t\t}\n\t\tif(j == 1){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(auto i = ans.begin(); i != ans.end(); i++){\n\t\tcout << (*i).first << \" \" << (*i).second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<algorithm>\n#define N 1000400\nusing namespace std;\nint n,v2[N],fa[N];\nlong long v[N],sz[N],ds[N];\nmap<long long,int> tp;\nbool cmp(int a,int b){return v[a]<v[b];}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&v[i]),tp[v[i]]=i,v2[i]=i,sz[i]=1;\n\tsort(v2+1,v2+n+1,cmp);\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tlong long tp2=v[v2[i]]-n+sz[v2[i]]*2;\n\t\tif(!tp[tp2]){printf(\"-1\\n\");return 0;}\n\t\tint sb=tp[tp2];\n\t\tds[sb]+=ds[v2[i]]+sz[v2[i]];\n\t\tsz[sb]+=sz[v2[i]];\n\t\tfa[v2[i]]=sb;\n\t}\n\tif(ds[v2[1]]!=v[v2[1]]){printf(\"-1\\n\");return 0;}\n\tfor(int i=1;i<=n;i++)if(fa[i])printf(\"%d %d\\n\",i,fa[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nll D[101010];\npair<ll,int> P[101010];\nint num[101010],par[101010];\nll DS[101010];\nvector<pair<int,int>> E;\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>D[i];\n\t\tP[i]={D[i],i+1};\n\t}\n\tsort(P,P+N);\n\tsort(D,D+N);\n\t\n\tfor(i=N-1;i>=1;i--) {\n\t\tnum[i]++;\n\t\tll sj=D[i]+2*num[i]-N;\n\t\tx=lower_bound(D,D+N,sj)-D;\n\t\tif(x>=i || D[x]!=sj) return _P(\"-1\\n\");\n\t\tE.push_back({x,i});\n\t\tnum[x]+=num[i];\n\t\tDS[x]+=DS[i]+num[i];\n\t\tpar[i]=x;\n\t}\n\tif(DS[0]!=D[0]) return _P(\"-1\\n\");\n\t\n\tFORR(e,E) cout<<P[e.first].second<<\" \"<<P[e.second].second<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#dfeine int long long\n#define reg register\n#define maxn 200001\ninline int  read() {\n    reg int s = 0, t = 0; reg char ch = getchar();\n    while(ch > '9' || ch < '0') t |= ch == '-', ch = getchar();\n    while(ch >= '0' && ch <= '9') s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();\n    return t ? -s : s;\n}\nusing namespace std;\nmap<int, int> mp;\nint D[maxn],a[maxn], b[maxn], cnt, n, sum[maxn];\nsigned main()\n{\n\tn = read();\n\tfor(int i = 1; i <= n; i++) D[i] = read(), mp[D[i]] = i;\n\tsort(D + 1, D + n + 1);\n\tfor(int i = n; i > 1; i--){\n\t\tsum[mp[D[i]]]++;\n\t\tint x = D[i] - abs(n - sum[mp[D[i]]] * 2);\n\t\tif(!mp[x] || x == D[i]) {printf(\"-1\\n\"); return 0;}\n\t\ta[++cnt] = mp[D[i]], b[cnt] = mp[x]; sum[mp[x]] += sum[mp[D[i]]];\n\t}\n\tfor(int i = 1; i < n; i++)\n\tprintf(\"%lld %lld\\n\", a[i], b[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <climits>\n#include <set>\n#include <algorithm>\n#include <unordered_map>\n#include <queue>\n#include <iomanip>\n#include <map>\n#include <utility>\n#include <numeric>\n\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define P pair<int, int>\n#define debug(x) cout << #x << \": \" << x << \", \"\n#define debugln(x) cout << #x << \": \" << x << '\\n'\n\nusing namespace std;\nusing ll = long long;\nconst int mod = 1e9+7;\n\nvector<P> ans;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n; cin >> n;\n  vector<ll> vec(n);\n  unordered_map<ll, int> mp;\n\n  rep(i, n) {\n    cin >> vec.at(i);\n    mp[vec.at(i)] = i+1;\n  }\n\n  vector<int> used(n);\n  rep(i, n) {\n    used.at(i) = 1;\n  }\n  vector<int> graph[n+1];\n\n  sort(vec.rbegin(), vec.rend());\n  rep(i, n) {\n    ll a = vec.at(i);\n    int s = mp[a];\n    int d = n-(2*used.at(s-1));\n\n    if (d > 0 && mp[a-d] > 0) {\n      int t = mp[a-d];\n      used.at(t-1) += used.at(s-1);\n      ans.push_back(P(s,t));\n      graph[s].push_back(t);\n      graph[t].push_back(s);\n    }\n  }\n\n  vector<int> distance(n);\n  rep(i, n) {\n    distance.at(i) = INT_MAX;\n  }\n  priority_queue<P, vector<P>, greater<P>> que;\n  que.push(P(0, 1));\n  while (!que.empty()) {\n    P pa = que.top(); que.pop();\n    int pos = pa.second;\n    int d = pa.first;\n    distance.at(pos-1) = d;\n    for(auto e : graph[pos]) {\n      if (distance.at(e-1) == INT_MAX) {\n        que.push(P(d+1, e));\n        //debug(d+1);debugln(e);\n      }\n    }\n  }\n\n  ll sum = 0;\n  rep(i, n) {\n    if (distance.at(i) == INT_MAX) {\n      cout << -1 << endl;\n      return 0;\n    }\n    sum += distance.at(i);\n  }\n  if (mp[sum] != 1) {\n    cout << -1 << endl;\n    return 0;\n  }\n\n  for(auto e: ans) {\n    cout << e.first << ' ' << e.second << '\\n';\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#include <queue>\n#include <vector>\n#define PB push_back\n#define MP make_pair\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=1e5+10;\nstruct node {\n\tint id; ll d;\n\tnode(int id=0,ll d=0): id(id),d(d) {}\n\tfriend bool operator <(node A,node B) { return A.d<B.d; }\n};\npriority_queue<node> que;\nmap<ll,int> mp;\nint n,sz[N];\nll d[N];\nvector< pair<int,int> > E;\nint main() {\n\trd(n);\n\tfor(int i=1;i<=n;++i) {\n\t\trd(d[i]),mp[d[i]]=i;\n\t\tque.push(node(i,d[i]));\n\t\tsz[i]=1;\n\t}\n\twhile(que.size()>1) {\n\t\tint u=que.top().id; que.pop();\n\t\tmp.erase(d[u]);\n\t\tll t=d[u]-(n-sz[u]*2ll);\n\t\tif(!mp.count(t)) {\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint f=mp[t];\n\t\tE.PB(MP(f,u));\n\t\tsz[f]+=sz[u];\n\t}\n\tfor(int i=0;i<E.size();++i) printf(\"%d %d\\n\",E[i].first,E[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,s,t) for(int i=(s);i<(t);++i)\n#define per(i,s,t) for(int i=((t)-1);i>=s;--i)\n#define repb(i,s,t) for(int i=(s);i<=(t);++i)\n#define lepb(i,s,t) for(int i=(s);i>=(t);--i)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)x.size())\n#define mst(a,b) memset(a,b,sizeof(a))\n#define dd(x) cout<<#x<<'='<<x<<' '\n#define de(x) cout<<#x<<'='<<x<<'\\n'\n#define fi first\n#define se second\n#define sq(x) ((x)*(x))\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef double db;\n\nconst int inf = 0x3f3f3f3f;\nconst ll inff = 4557430888798830399ll;\nconst db eps = 1e-10;\nconst db pi = acos(-1.0);\nconst ll mod = 1e9+7;\n\n#define maxn 100005\n\nmap<ll,int> id;\nint sz[maxn],p[maxn];\nint fa(int n){return n==p[n]?n:p[n]=fa(p[n]);}\n\nint main()\n{\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tint n,u,v;ll x,y;vector<pair<ll,int> > D;vector<pii> E;\n\tcin>>n;\n\trepb(i,1,n){cin>>x;D.pb({x,i});id[x]=i;}\n\tsort(all(D));reverse(all(D));mst(sz,0);\n\trep(i,0,sz(D)-1)\n\t{\n\t\tx=D[i].fi;u=D[i].se;sz[u]+=1;\n\t\ty=x-n+2*sz[u];v=id[y];\n\t\tif(v==0||u==v){cout<<-1<<endl;return 0;}\n\t\tE.pb(mp(min(u,v),max(u,v)));sz[v]+=sz[u];\n\t}\n\tsort(all(E));E.erase(unique(all(E)),E.end());\n\tif(sz(E)!=n-1){cout<<-1<<endl;return 0;}\n\trepb(i,1,n)p[i]=i;\n\trep(i,0,sz(E))if(fa(E[i].fi)!=fa(E[i].se))p[fa(E[i].fi)]=fa(E[i].se);\n\trepb(i,1,n)if(fa(i)!=fa(1)){cout<<-1<<endl;return 0;}\n\trep(i,0,sz(E))cout<<E[i].fi<<\" \"<<E[i].se<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// type\ntypedef long long ll;\ntypedef long double ld;\n// loop\n//#define For(i, l, r, x)     for (int i = l; i < r; i+=x)\n//#define ForE(i, l, r, x)    for (int i = l; i <= r; i+=x)\n//#define Ford(i, r, l)       for (int i = r; i > l; i--)\n//#define FordE(i, r, l)      for (int i = r; i >= l; i--)\n//#define Fora(i, a)          for (auto i : a)\n// I/O\n#define FAST_IO             std::ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n//#define PrintV(a)           Fora(ii, a) cout << ii << ' '; cout << rl;\n//#define PrintVl(a)          Fora(ii, a) cout << ii << rl;\n//#define PrintA(a, l, r)     for (int ii = l; ii <= r; ii++) cout << a[ii] << ' '; cout << rl;\n//#define PrintAl(a, l, r)    for (int ii = l; ii <= r; ii++) cout << a[ii] << rl;\n//#define Ptest(x)            return cout << x, 0;\n#define setpre(n)           fixed << setprecision(n)\n// pair\n#define F                   first\n#define S                   second\n#define pii                 pair<int, int>\n#define pll                 pair<ll, ll>\n#define pdd                 pair<ld, ld>\n// vector & !!?(string)\n#define eb                  emplace_back\n#define pb                  push_back\n#define all(a)              a.begin(), a.end()\n#define rall(a)             a.rbegin(), a.rend()\n#define sz(a)               a.size()\n#define len(a)              a.length()\n// geometry calc\n#define pi                  acos(-1.0)\n#define g_sin(a)            sin(a*pi/180)\n#define g_cos(a)            cos(a*pi/180)\n#define g_tan(a)            tan(a*pi/180)\n// set val\n#define ms0(a)              memset(a,        0, sizeof(a));\n#define ms1(a)              memset(a,        1, sizeof(a));\n#define msn1(a)             memset(a,       -1, sizeof(a));\n#define msinf(a)            memset(a, 0x3f3f3f, sizeof(a));\n// constant\nconst int mod1 = 998244353, mod = 1e9+7;\nconst int MAXN = 1e5 + 5, MAX_M = 2e5 + 5;\n// code\n#define int long long\n\nint d[MAXN], pos[MAXN], n;\nint par[MAXN], sz[MAXN];\nmap<int, int> orc;\n\nbool comp(const int &a, const int &b){\n    return d[a] > d[b];\n}\n\nvoid Solve() {\n    cin >> n;\n    for (int i = 1; i <= n; i++){\n        cin >> d[i]; pos[i] = i;\n        orc[d[i]] = i;\n    }\n    sort(pos+1, pos+n+1, comp);\n    // root at pos[n];\n    for (int i = 1; i < n; i++){\n        sz[pos[i]] ++;\n        int parD = d[pos[i]] - n + 2*sz[pos[i]];\n        if (parD >= d[pos[i]] || !orc.count(parD)){\n            cout << \"-1\";\n            return;\n        }\n        par[pos[i]] = orc[parD];\n        sz[par[pos[i]]] += sz[pos[i]];\n    }\n    for (int i = 1; i < n; i++){\n        cout << pos[i] << ' ' << par[pos[i]] << endl;\n    }\n}\n\nsigned main(){\n    FAST_IO;\n    int TC = 1;\n\t//cin >> TC;\n    while(TC--) Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Distance Sums\n\nusing P = pair<int64_t, int64_t>;\n\nint main() {\n  size_t N;\n  cin >> N;\n  map<int64_t, P> mp;\n  for (size_t i = 1; i <= N; i++) {\n    int64_t x;\n    cin >> x;\n    mp[x] = make_pair(i, 1);  // 頂点番号と木のサイズ\n  }\n  if (N == 2) {\n    cout << -1 << endl;\n    return 0;\n  }\n  bool flag = true;  // 条件をみたす木が存在しているかどうか\n  vector<P> graph;\n  auto enditr = mp.rend();\n  enditr--;\n  for (auto itr = mp.rbegin(); itr != enditr; ++itr) {\n    auto key = itr->first;\n    auto value = itr->second;\n    auto vertex = value.first;\n    auto size = value.second;\n    auto child_key = key - N + 2 * size;\n    if (child_key >= key) {\n      flag = false;\n      break;\n    }\n    auto tmpitr = mp.find(child_key);\n    if (tmpitr != mp.end()) {\n      auto tmp = tmpitr->second;\n      mp.at(child_key) = make_pair(tmp.first, tmp.second + size);\n      graph.push_back(make_pair(vertex, tmp.first));\n    } else {\n      flag = false;\n      break;\n    }\n  }\n  if (flag) {\n    for (const auto& e : graph) {\n      cout << e.first << ' ' << e.second << endl;\n    }\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#include<map>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n\nusing namespace std;\ntypedef long long LL;\nconst int N=100005;\nint n,p[N],siz[N],fa[N];\nLL d[N];\nmap <LL,int> s;\n\nbool cmp(int x,int y)\n{\n\treturn d[x]>d[y];\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\trep(i,1,n) scanf(\"%lld\",&d[i]),p[i]=i,s[d[i]]=i;\n\tsort(p+1,p+1+n,cmp);\n\trep(i,1,n-1)\n\t{\n\t\t++siz[p[i]];\n\t\tLL D=d[p[i]]-n+2*siz[p[i]];\n\t\tif(D>=d[p[i]] || !s.count(D)) {puts(\"-1\"); return 0;}\n\t\tfa[p[i]]=s[D],siz[s[D]]+=siz[p[i]];\n\t}\n\trep(i,1,n-1) printf(\"%d %d\\n\",p[i],fa[p[i]]);\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n#include<bits/stdc++.h>\n#define int long long\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\ntypedef long long ll;\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\ninline string getstr(string &s,int l,int r){string ret=\"\";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){if(y==0)return 1;int ret=modpow(x,y>>1,md);ret=(ll)ret*ret%md;if(y&1)ret=(ll)ret*x%md;return ret;}\nint n;\npair<int,int> d[100005];\nvector<int>g[100005];\nmap<int,int>mp;\nint sz[1000005];\nvector<pair<int,int> >ans; \nsigned main(){\n\tcin>>n;\n  \tif(n%2==0){\n      \tputs(\"-1\");\n      \treturn 0;\n    }\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>d[i].first;d[i].second=i;\n\t\tmp[d[i].first]=i;sz[i]=1;\n\t}\n\twhile(mp.size()>1){\n\t\tpair<int,int>p=*mp.rbegin();mp.erase(p.first);\n\t\tint now=p.second,size=sz[now],val=p.first;\n\t\tint nxt=val+size+size-n;\n\t\tif(!mp.count(nxt)){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}else{\n\t\t\tsz[mp[nxt]]+=sz[now];\n\t\t\tans.push_back(make_pair(now,mp[nxt]));\n\t\t}\n\t}\n\tfor(auto p:ans){\n\t\tcout<<p.first<<\" \"<<p.second<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MN 100000\n#define ll long long\n#define mp(x,y) make_pair(x,y)\nusing namespace std;\ninline ll read()\n{\n\tll x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,ansnum,g[MN+5];ll f[MN+5];\npair<int,int> ans[MN+5];\nset<pair<ll,pair<int,int> >,greater<pair<ll,pair<int,int> > > >st;\nset<pair<ll,pair<int,int> > >::iterator it;\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;++i) st.insert(mp(read(),mp(i,g[i]=1)));\n    while(st.size()>1)\n    {\n        pair<ll,pair<int,int> >a=*st.begin(),b;\n        st.erase(st.begin());\n        ll nx=a.first+a.second.second-(n-a.second.second);\n        it=st.lower_bound(mp(nx,mp(1e9,1e9)));\n        if(it==st.end()||(*it).first!=nx) return 0*puts(\"-1\");\n        b=*it;st.erase(it);\n        ans[++ansnum]=mp(a.second.first,b.second.first);\n        b.second.second+=a.second.second;\n        st.insert(b);\n    }\n    for(int i=1;i<n;++i) f[ans[i].second]+=f[ans[i].first]+g[ans[i].first],g[ans[i].second]+=g[ans[i].first];\n    if(f[st.begin()->second.first]!=st.begin()->first) return 0*puts(\"-1\");\n    for(int i=1;i<n;++i) printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#define LL long long\nusing namespace std;\nconst LL Maxn = 100010;\nLL n, a[Maxn];\nLL siz[Maxn];\nstruct lnode {\n\tLL x, y;\n}lis[Maxn]; LL ll;\nqueue <LL> q[2];\nLL dis[Maxn];\nvector <LL> vec[Maxn];\nvoid dfs(LL x) {\n\tdis[x] = 0; siz[x] = 1;\n\tfor(LL i = 0; i < vec[x].size(); i++){\n\t\tLL y = vec[x][i];\n\t\tdfs(y);\n\t\tdis[x] += dis[y]+siz[y];\n\t\tsiz[x] += siz[y];\n\t}\n}\nint main() {\n\tLL i, j, k;\n\tscanf(\"%lld\", &n);\n\tfor(i = 1; i <= n; i++) scanf(\"%lld\", &a[i]);\n\tsort(a+1, a+n+1);\n\tsiz[1] = n-1;\n\tif(n&1){\n\t\tq[a[1]&1].push(1);\n\t\tfor(i = 2; i <= n; i++){\n\t\t\tLL p = 1-(a[i]&1);\n\t\t\tif(q[p].empty()){ printf(\"-1\\n\"); return 0; }\n\t\t\tLL x = q[p].front();\n\t\t\tll++;\n\t\t\tlis[ll].x = x; lis[ll].y = i;\n\t\t\tLL o = (n-(a[i]-a[x]))/2;\n\t\t\tif(siz[x] < o){ printf(\"-1\\n\"); return 0; }\n\t\t\tsiz[x] -= o;\n\t\t\tif(siz[x] == 0) q[p].pop();\n\t\t\tif(o != 1){\n\t\t\t\tsiz[i] = o-1;\n\t\t\t\tq[a[i]&1].push(i);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tq[0].push(1);\n\t\tfor(i = 2; i <= n; i++){\n\t\t\tif(q[0].empty()){ printf(\"-1\\n\"); return 0; }\n\t\t\tLL x = q[0].front();\n\t\t\tll++;\n\t\t\tlis[ll].x = x; lis[ll].y = i;\n\t\t\tLL o = (n-(a[i]-a[x]))/2;\n\t\t\tif(siz[x] < o){ printf(\"-1\\n\"); return 0; }\n\t\t\tsiz[x] -= o;\n\t\t\tif(siz[x] == 0) q[0].pop();\n\t\t\tif(o != 1){\n\t\t\t\tsiz[i] = o-1;\n\t\t\t\tq[0].push(i);\n\t\t\t}\n\t\t}\n\t}\n\tif(!q[0].empty() || !q[1].empty()){ printf(\"-1\\n\"); return 0; }\n\tfor(i = 1; i <= ll; i++) vec[lis[i].x].push_back(lis[i].y);\n\tdfs(1);\n\tif(dis[1] != a[1]){ printf(\"-1\\n\"); return 0; }\n\tfor(i = 1; i <= ll; i++) printf(\"%lld %lld\\n\", lis[i].x, lis[i].y);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint n,nn;\nstruct node{int p,f,l,r;long long d;};\nnode a[100010];\n\nvoid qsort(int l,int r)\n{\n\tint i,j;\n\tnode m,t;\n\ti=l;j=r;\n\tm=a[(l+r)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (a[i].d<m.d) i++;\n\t\twhile (a[j].d>m.d) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tt=a[i];a[i]=a[j];a[j]=t;\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort(l,j);\n\tif (i<r) qsort(i,r);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tnn=n-2;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i].d);\n\t\ta[i].p=i;\n\t\ta[i].f=-1;\n\t\ta[i].l=-1;\n\t\ta[i].r=-1;\n\t}\n\tqsort(1,n);\n\tbool ok=true;\n\ta[1].l=0;a[1].r=n-1;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tbool check=true;\n\t\tfor (int j=i-1;j>=1;j--)\n\t\t{\n\t\t\tif (a[i].d-a[j].d>nn) \n\t\t\t{\n\t\t\t\tcheck=false;break;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif ((a[i].d-a[j].d-nn)%2==0)\n\t\t\t\t{\n\t\t\t\t\tint l,r;\n\t\t\t\t\tl=(nn+(a[i].d-a[j].d))/2;\n\t\t\t\t\tr=(nn-(a[i].d-a[j].d))/2;\n\t\t\t\t\tif (r<a[j].r)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[i].f=a[j].p;\n\t\t\t\t\t\ta[i].l=nn-r;\n\t\t\t\t\t\ta[i].r=r;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!check) {ok=false;break;}\n\t}\n\tif (ok)\n\t{\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tif (a[i].f!=-1) printf(\"%d %d\\n\",a[i].f,a[i].p);\n\t\t}\n\t}\n\telse printf(\"-1\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<iostream>\n#include<set>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<bitset>\n#define Fail puts(\"NO\"),exit(0);\n#define eps 1e-10\n#define maxn 100010\n#define maxm 100010\n#define inf 1000000007\n//#define mod 1000000009\n#define inv 500000005\n#define G 3\n#define pi acos(-1)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<ll,int>pii;\ntypedef bitset<maxn> bit;\ntypedef long double ld;\nll read()\n{\n    ll x=0,f=1;\n    char ch=getchar();\n    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}\n    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,size[maxn];\npii p[maxn];\nint head[maxn],nxt[maxn*2],to[maxn*2],tot;\nvoid add(int u,int v)\n{\n    tot++;\n    nxt[tot]=head[u];\n    head[u]=tot;\n    to[tot]=v;\n}\nint u[maxn],v[maxn];\nll dfs(int x,int las,ll d)\n{\n    ll res=d;\n    for(int i=head[x];i;i=nxt[i])\n      if(to[i]!=las)  res+=dfs(to[i],x,d+1);\n    return res;\n}\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;i++)  p[i].fi=read(),p[i].se=i,size[i]=1;\n    sort(p+1,p+n+1);reverse(p+1,p+n+1);\n    for(int i=1;i<n;i++)\n    {\n        int l=1,r=n,pos=0;\n        while(l<=r)\n        {\n            int mid=(l+r)/2;\n            if(p[mid].fi>=p[i].fi+2*size[i]-n)\n            {\n                pos=mid;\n                l=mid+1;\n            }\n            else r=mid-1;\n        }\n        if(p[pos].fi!=p[i].fi+2*size[i]-n)  return puts(\"-1\"),0;\n        size[pos]+=size[i];\n        u[i]=p[pos].se;v[i]=p[i].se;\n        add(u[i],v[i]);\n        add(v[i],u[i]);\n    }\n    ll com=dfs(p[n].se,0,0);\n    if(com!=p[n].fi)   return puts(\"-1\"),0;\n    for(int i=1;i<n;i++)  printf(\"%d %d\\n\",u[i],v[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cstdlib>\n\n#define int long long\n\nusing namespace std;\n\nint n, D[100010], Sz[100010], F[100010], ans = 0;\n\nint find(int x) {\n    int t = lower_bound(D + 1, D + n + 1, x) - D;\n    if(D[t] != x) {\n        puts(\"-1\");\n        exit(0);\n    }\n    return t;\n}\n\nsigned main() {\n    scanf(\"%lld\", &n);\n    for(int i = 1; i <= n; i++) scanf(\"%lld\", &D[i]);\n    sort(D + 1, D + n + 1);\n    for(int i = 1; i <= n; i++) Sz[i] = 1;\n    for(int i = n; i > 1; i--) {\n        F[i] = find(D[i] - n + Sz[i] * 2);\n        Sz[F[i]] += Sz[i];\n        ans += Sz[i];\n    }\n    if(ans != D[1]) {\n        puts(\"-1\");\n        return 0;\n    }\n    for(int i = 2; i <= n; i++) printf(\"%lld %lld\\n\", i, F[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n#define MN 101000\n\ntypedef long long ll;\n\nstruct xxx{\n\tll d;\n\tint id;\n}a[MN];\n\nint siz[MN];\nstd::map<ll, int> mp;\nint x[MN], y[MN];\n\nbool cmp(xxx a, xxx b) {return a.d < b.d;}\n\nint main()\n{\n\tint n; scanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++) scanf(\"%lld\", &a[i].d), a[i].id = i;\n\tstd::sort(a + 1, a + n + 1, cmp);\n\tfor(int i = 1; i <= n; i++) mp[a[i].d] = i, siz[i] = 1;\n\tll sum = 0;\n\tfor(int i = n; i >= 2; i--)\n\t{\n\t\tsum += siz[i];\n\t\ta[i].d -= n - 2 * siz[i]; \n\t\tif(!mp[a[i].d] || mp[a[i].d] >= i) return 0 * puts(\"-1\");\n\t\tsiz[mp[a[i].d]] += siz[i];\n\t\tx[n - i + 1] = a[i].id; y[n - i + 1] = a[mp[a[i].d]].id; \n\t}\n\tif(sum != a[1].d) return 0 * puts(\"-1\");\n\tfor(int i = 1; i < n; i++) printf(\"%d %d\\n\", x[i], y[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,s,t) for(int i=(s);i<(t);++i)\n#define per(i,s,t) for(int i=((t)-1);i>=s;--i)\n#define repb(i,s,t) for(int i=(s);i<=(t);++i)\n#define lepb(i,s,t) for(int i=(s);i>=(t);--i)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)x.size())\n#define mst(a,b) memset(a,b,sizeof(a))\n#define dd(x) cout<<#x<<'='<<x<<' '\n#define de(x) cout<<#x<<'='<<x<<'\\n'\n#define fi first\n#define se second\n#define sq(x) ((x)*(x))\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef double db;\n\nconst int inf = 0x3f3f3f3f;\nconst ll inff = 4557430888798830399ll;\nconst db eps = 1e-10;\nconst db pi = acos(-1.0);\nconst ll mod = 1e9+7;\n\n#define maxn 100005\n\nmap<ll,int> id;\nint sz[maxn];\n\nint main()\n{\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tint n,u,v;ll x,y;vector<pair<ll,int> > D;vector<pii> E;\n\tcin>>n;\n\trepb(i,1,n){cin>>x;D.pb({x,i});id[x]=i;}\n\tsort(all(D));reverse(all(D));mst(sz,0);\n\trep(i,0,sz(D)-1)\n\t{\n\t\tx=D[i].fi;u=D[i].se;sz[u]+=1;\n\t\ty=x-n+2*sz[u];v=id[y];\n\t\tif(v==0||u==v){cout<<-1<<endl;return 0;}\n\t\tE.pb(mp(min(u,v),max(u,v)));sz[v]+=sz[u];\n\t}\n\tsort(all(E));E.erase(unique(all(E)),E.end());\n\trep(i,0,sz(E))cout<<E[i].fi<<\" \"<<E[i].se<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::cerr;\nusing std::endl;\n\ninline int rd(){\n  int x; scanf(\"%d\",&x);\n  return x;\n}\n\nconst int N=1e5+233;\n\nint n,D[N],S[N];\nstd::vector<std::pair<int,int>>ans;\nstd::map<int,int>map;\n\nint main(){\n  //freopen(\"data\",\"r\",stdin);\n  n=rd();\n  for(int i=1;i<=n;++i){\n    D[i]=rd();\n    S[i]=1;\n    map[-D[i]]=i;\n  }\n  while(!map.empty()){\n    if(map.size()==1)\n      break;\n    int x=map.begin()->second;\n    map.erase(map.begin());\n    std::map<int,int>::iterator it;\n    it=map.find(-(D[x]-n+2*S[x]));\n    if(it==map.end()){\n      puts(\"-1\");\n      return 0;\n    }\n    S[it->second]+=S[x];\n    ans.push_back({x,it->second});\n  }\n  for(int i=0;i<n-1;++i)\n    printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<iostream>\n#include<algorithm>\n#define maxn 100050\nusing namespace std;\ntypedef long long LL;\n\nint n;\nLL D[maxn];\n\nint pos[maxn];\n\nint size[maxn];\n\nbool vis[maxn];\n\nint p[2];\nvector<int> vert[2]; \n\nvoid init()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tpos[i]=i;\n\t\tscanf(\"%d\",&D[i]); \n\t\tvert[D[i]&1].push_back(i);\n\t}\n}\n\nbool cmp(int i,int j)\n{\n\treturn D[i]<D[j];\n}\n\nint fa[maxn];\n\nbool solve()\n{\n\tsort(pos+1,pos+n+1,cmp);\n\tsort(vert[0].begin(),vert[0].end(),cmp);\n\tsort(vert[1].begin(),vert[1].end(),cmp);\n\t\n\tsize[pos[1]]=n;\n\t++p[D[pos[1]]&1];\n\t\n\tfor (int k=1;k<=n;++k)\n\t{\n\t\tint u=pos[k],cnt=1,c=(D[u]+n)&1;\n\t\tint &j=p[c],len=vert[c].size();\n\t\tfor (;j<len&&cnt<size[u];++j)\n\t\t{\n\t\t\tint v=vert[c][j];\n\t\t\tsize[v]=(D[u]+n-D[v])>>1;\n\t\t\tcnt+=size[v];\n\t\t\tfa[v]=u;\n//\t\t\tprintf(\"%d %d\\n\",u,v);\n//\t\t\tcout<<u<<\" \"<<v<<\" \"<<size[v]<<\" \"<<cnt<<endl;\n\t\t}\n//\t\tcout<<u<<\" \"<<size[u]<<\" \"<<cnt<<endl;\n\t\tif (cnt!=size[u])\n\t\t{\n//\t\t\tcout<<\"warning:\"<<u<<endl;\n\t\t\treturn 0;\n\t\t}\n//\t\tassert(cnt==size[u]);\n\t}\n\t\n\tfor (int k=1;k<=n;++k)\n\t{\n\t\tint u=pos[k];\n\t\tif (fa[u])\n\t\t\tprintf(\"%d %d\\n\",u,fa[u]);\n\t}\n\treturn 1;\n}\n\nint main()\n{\n//    freopen(\"c.in\",\"r\",stdin);\n    init();\n    if (!solve())\n    \tprintf(\"-1\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int N=100100;\nstruct Node{\n\tLL d;\n\tLL td;\n\tint i,sz,fa;\n\tvector<int> ch;\n\tNode():td(0),sz(1){}\n\tbool operator<(const Node o)const{\n\t\treturn d<o.d;\n\t}\n};\nNode d[N];\nmap<LL,int> fd;\nvoid GG(){\n\tputs(\"-1\");\n\texit(0);\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&d[i].d);\n\t\td[i].i=i;\n\t}\n\tsort(d+1,d+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tfd[d[i].d]=i;\n\t}\n\tfor(int i=n;i>1;i--){\n\t\tfd.erase(d[i].d);\n\t\tLL nd=d[i].d-(n-2*d[i].sz);\n\t\tif(!fd.count(nd)){\n\t\t\tGG();\n\t\t}\n\t\tint f=fd[nd];\n\t\td[i].fa=d[f].i;\n\t\td[f].sz+=d[i].sz;\n\t\td[f].td+=d[i].td+d[i].sz;\n\t}\n\tif(d[1].td!=d[1].d){\n\t\tGG();\n\t}\n\tfor(int i=2;i<=n;i++){\n\t\tprintf(\"%d %d\\n\",d[i].fa,d[i].i);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+5;\nlong long a[N];\nmap<long long,int>ma;\nint n,b[N],vi[N],si[N],fa[N];\nbool com(int x,int y){\n\treturn a[x]>a[y];\n}\nint main(){\n\tputs(\"-1\");\n\treturn 0;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i]);\n\t\tma[a[i]]=b[i]=i;\n\t}\n\tsort(b+1,b+n+1,com),vi[0]=1;\n\tfor(int i=1;i<=n;i++)\tsi[i]=1;\n\tfor(int i=1;i<n;i++){\n\t\tint k=ma[a[b[i]]-n+si[b[i]]*2];\n\t\tfa[b[i]]=k,si[k]+=si[b[i]],vi[b[i]]=1;\n\t\tif(vi[k]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d %d\\n\",b[i],fa[b[i]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100001\nusing namespace std;\nstruct S{\n\tlong long w,dep;\n\tlong long u,v,ne;\n}a[N],e[N];\n\tlong long n,sz[N],dy[N],fir[N],root,vis[N],sum,pan;\n\tbool bo=false;\nvoid add(long long u,long long v){\n\te[++sum].ne=fir[u];\n\tfir[u]=sum;\n\te[sum].v=v;\n\te[sum].u=u;\n//\te[sum].w=1;\n}\nbool cmp(S x,S y){\n\treturn x.w>y.w;\n}\nvoid check(long long x,long long dis){\n//\tif(bo)return;\n\tpan+=dis;\n\tvis[x]=1;\n\tfor(long long i=fir[x];i;i=e[i].ne){\n\t\tlong long to=e[i].v;\n\t\tif(!vis[to]){\n\t\t\t//if(vis[to])bo=true;\n\t\t\tcheck(to,dis+1);\n\t\t}\n\t}\n}\nvoid dfs(long long x,long long father){\n\tvis[x]=1;\n\tfor(long long i=fir[x];i;i=e[i].ne){\n\t\tlong long to=e[i].v;\n\t\tif(to!=father&&!vis[to]){\n\t\t\tprintf(\"%lld %lld\\n\",x,to);\n\t\t\tdfs(to,x);\n\t\t}\n\t}\n}\nlong long query(long long sum){\n\tlong long l=1,r=n;\n\twhile(l<r){\n\t\tlong long mid=(l+r+1)>>1;\n\t\tif(a[mid].w>sum)l=mid;\n\t\telse if(a[mid].w<sum)r=mid-1;\n\t\telse {\n\t\t\tl=mid;\n\t\t\treturn a[l].dep;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tscanf(\"%lld\",&n);\n\tfor(long long i=1;i<=n;i++)scanf(\"%lld\",&a[i].w),sz[i]=1,a[i].dep=i;\n\tsort(a+1,a+n+1,cmp);\n\tfor(long long i=1;i<=n;i++){\n\t\tlong long tmp=n-2*sz[a[i].dep];\n\t\tlong long father=query(a[i].w-tmp);\n\t\tsz[father]+=sz[a[i].dep];\n/*\t\tif(!father){\n\t\t\tif(root){\n\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\troot=a[i].dep;\n\t\t}\n*/\t\tif(i!=n){\n\t\t\tadd(a[i].dep,father);\n\t\t\tadd(father,a[i].dep);\n\t\t}\n\t}\n\troot=a[n].dep;\n\tcheck(root,0);\n\tif(bo){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(long long i=1;i<=n;i++)if(!vis[i]){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tif(pan!=a[n].w){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tmemset(vis,0,sizeof(vis));\n\tdfs(root,0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid err() {\n  cout << -1 << endl;\n  exit(0);\n}\nvoid dfs (int crr, int dpt, vector<vector<int>>& grh, long long& cnt) {\n  cnt += dpt;\n  for (int nxt : grh[crr]) {\n    dfs(nxt, dpt + 1, grh, cnt);\n  }\n}\nint main() {\n  int n;\n  cin >> n;\n  vector<pair<long long, int>> di(n);\n  for (int i = 0; i < n; i++) {\n    int d;\n    cin >> d;\n    di[i] = {d, i};\n  }\n  sort(di.begin(), di.end());\n  vector<long long> sz(n, 1);\n  vector<int> prt(n);\n  vector<vector<int>> grh(n);\n  vector<pair<int, int>> edg;\n  for (auto it = prev(di.end()); it != di.begin(); it--) {\n    auto d = it->first;\n    auto i = it->second;\n    long long prtv = d - n + 2 * sz[i];\n    auto jt = lower_bound(di.begin(), di.end(), make_pair(prtv, 0));\n    if (jt->first != prtv) err();\n    auto p = jt->second;\n    prt[i] = p;\n    grh[p].push_back(i);\n    if (i == prt[i]) err();\n    sz[prt[i]] += sz[i];\n    edg.emplace_back(min(i, prt[i]), max(i, prt[i]));\n  }\n  long long cnt = 0;\n  int rt = di[0].second;\n  dfs(rt, 0, grh, cnt);\n  if (di[0].first != cnt) err();\n  sort(edg.begin(), edg.end());\n  for (auto const & e : edg) {\n    cout << e.first + 1 << ' ' << e.second + 1 << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\nusing namespace std;\nlong long n,d[100005];\nvector<long long>a,qz,dist,x;\nmap<long long,long long>mp;\nvector<pair<long long,long long> >res;\nvector<vector<long long> >nmp(10005);\nint main(){\n\tcin>>n;\n\tx.push_back(0);\n\tfor(long long i=0;i<n;i++){\n\t\tcin>>d[i];\n\t\ta.push_back(d[i]);\n\t\tmp[d[i]]=i;\n\t\tqz.push_back(1);\n\t\tdist.push_back(-1);\n\t}\n\tsort(d,d+n);\n\tfor(long long i=n-1;i>=1;i--){\n\t\tlong long it=mp.rbegin()->second;\n\t\tlong long net=a[it]-(n-qz[it]*2);\n\t\tif(mp.find(net)==mp.end()||mp[net]==mp[it]){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tres.push_back(make_pair(mp[it],mp[net]));\n\t\tqz[mp[net]]+=qz[mp[it]];\n\t\tmp.erase(--mp.end());\t\t\n\t}\n\tdist[0]=0;\n\tfor(long long i=0;i<res.size();i++){\n\t\tnmp[res[i].first].push_back(res[i].second);\n\t\tnmp[res[i].second].push_back(res[i].first);\n\t}\n\tfor(long long i=0;i<x.size();i++){\n\t\tfor(long long j=0;j<nmp[x[i]].size();j++){\n\t\t\tlong long&k=nmp[x[i]][j];\n\t\t\tif(dist[k]==-1){\n\t\t\t\tx.push_back(k);\n\t\t\t\tdist[k]=dist[x[i]]+1;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ansd=0;\n\tfor(long long i=0;i<dist.size();i++){\n\t\tansd+=dist[i];\n\t}\n\tif(ansd!=a[0]){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tfor(long long i=0;i<res.size();i++){\n\t\tcout<<res[i].first+1<<\" \"<<res[i].second+1<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#define LL long long\nusing namespace std;\nconst LL Maxn = 100010;\nLL n, a[Maxn];\nLL siz[Maxn];\nstruct lnode {\n\tLL x, y;\n}lis[Maxn]; LL ll;\nqueue <LL> q[2];\nLL dis[Maxn];\nvector <LL> vec[Maxn];\nvoid dfs(LL x) {\n\tdis[x] = 0; siz[x] = 1;\n\tfor(LL i = 0; i < vec[x].size(); i++){\n\t\tLL y = vec[x][i];\n\t\tdfs(y);\n\t\tdis[x] += dis[y]+siz[y];\n\t\tsiz[x] += siz[y];\n\t}\n}\nstruct pnode {\n\tLL num, x;\n\tbool operator<(const pnode &A) const { return x < A.x; }\n}po[Maxn];\nint main() {\n\tLL i, j, k;\n\tscanf(\"%lld\", &n);\n\tfor(i = 1; i <= n; i++) scanf(\"%lld\", &po[i].x), po[i].num = i;\n\tsort(po+1, po+n+1);\n\tfor(i = 1; i <= n; i++) a[i] = po[i].x;\n\tsiz[1] = n-1;\n\tif(n&1){\n\t\tq[a[1]&1].push(1);\n\t\tfor(i = 2; i <= n; i++){\n\t\t\tLL p = 1-(a[i]&1);\n\t\t\tif(q[p].empty()){ printf(\"-1\\n\"); return 0; }\n\t\t\tLL x = q[p].front();\n\t\t\tll++;\n\t\t\tlis[ll].x = x; lis[ll].y = i;\n\t\t\tLL o = (n-(a[i]-a[x]))/2;\n\t\t\tif(siz[x] < o){ printf(\"-1\\n\"); return 0; }\n\t\t\tsiz[x] -= o;\n\t\t\tif(siz[x] == 0) q[p].pop();\n\t\t\tif(o != 1){\n\t\t\t\tsiz[i] = o-1;\n\t\t\t\tq[a[i]&1].push(i);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tq[0].push(1);\n\t\tfor(i = 2; i <= n; i++){\n\t\t\tif(q[0].empty()){ printf(\"-1\\n\"); return 0; }\n\t\t\tLL x = q[0].front();\n\t\t\tll++;\n\t\t\tlis[ll].x = x; lis[ll].y = i;\n\t\t\tLL o = (n-(a[i]-a[x]))/2;\n\t\t\tif(siz[x] < o){ printf(\"-1\\n\"); return 0; }\n\t\t\tsiz[x] -= o;\n\t\t\tif(siz[x] == 0) q[0].pop();\n\t\t\tif(o != 1){\n\t\t\t\tsiz[i] = o-1;\n\t\t\t\tq[0].push(i);\n\t\t\t}\n\t\t}\n\t}\n\tif(!q[0].empty() || !q[1].empty()){ printf(\"-1\\n\"); return 0; }\n\tfor(i = 1; i <= ll; i++) vec[lis[i].x].push_back(lis[i].y);\n\tdfs(1);\n\tif(dis[1] != a[1]){ printf(\"-1\\n\"); return 0; }\n\tfor(i = 1; i <= ll; i++) printf(\"%lld %lld\\n\", po[lis[i].x].num, po[lis[i].y].num);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "けんちょんさんの記事を読んだ\nゴールを決めると途中で止まれないので順次確定していくのがポイント"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define re register\nlong long d[1001000];\nint p[1001000],pq[1001000],fa[1001000],sz[1001000],n;\ninline bool cmp(re int A,re int B){return d[A]<d[B];}\ninline bool cmp1(re int A,re int B){return d[A]-n+2*sz[A]<d[B]-n+2*sz[B];}\nint main()\n{\n\tre int ta=1;\n\tscanf(\"%d\",&n);\n\tfor(re int i=1;i<=n;i++)scanf(\"%lld\",&d[i]),p[i]=i,sz[i]=1;\n\tsort(p+1,p+n+1,cmp);\n\tpq[1]=p[n];\n\tfor(re int i=n-1;i;i--)\n\t{\n\t\twhile(ta&&d[p[i]]==d[pq[1]]-n+2*sz[pq[1]])\n\t\t{\n\t\t\tfa[pq[1]]=p[i];sz[p[i]]+=sz[pq[1]];\n\t\t\tpop_heap(pq+1,pq+ta+1,cmp1);\n\t\t\tta--;\n\t\t}\n\t\tpq[++ta]=p[i];\n\t\tpush_heap(pq+1,pq+ta+1,cmp1);\n\t}\n\tif(ta!=1)puts(\"-1\");\n\telse\n\t{\n\t\tfor(re int i=1;i<=n;i++)if(fa[i])printf(\"%d %d\\n\",i,fa[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<iomanip>\n#include<cstring>\n#include<algorithm>\n#include<ctime>\nusing namespace std;\ninline int read()\n{\n\tint kkk=0,x=1;\n\tchar c=getchar();\n\twhile((c<'0' || c>'9') && c!='-')\n\t\tc=getchar();\n\tif(c=='-')\n\t\tc=getchar(),x=-1;\n\twhile(c>='0' && c<='9')\n\t\tkkk=(kkk<<3)+(kkk<<1)+(c-'0'),c=getchar();\n\treturn kkk*x;\n}\nint n;\nstruct sb\n{\n\tint sum,id,size,fa;\n}a[100001];\ninline int cmp(sb x,sb y)\n{\n\treturn x.sum>y.sum;\n}\ninline int find(int V)\n{\n\tint l=1,r=n,bck=0;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)/2;\n\t\tif(a[mid].sum>=V)\n\t\t\tbck=mid,l=mid+1;\n\t\telse\n\t\t\tr=mid-1;\n\t}\n\treturn bck;\n}\nint main()\n{\n\tn=read();\n\tfor(register int i=1;i<=n;++i)\n\t{\n\t\ta[i].id=i;\n\t\ta[i].sum=read();\n\t\ta[i].size=1;\n\t}\n\tsort(a+1,a+n+1,cmp);\n\ta[0].sum=-1;\n\tfor(register int i=1;i<n;++i)\n\t{\n\t\tint sum=a[i].sum+a[i].size-(n-a[i].size);\n\t\tif(sum<n-1 || sum>=a[i].sum)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint zone=find(sum);\n\t\tif(a[zone].sum!=sum)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\ta[zone].size+=a[i].size;\n\t\ta[i].fa=zone;\n\t}\n\tfor(register int i=1;i<n;++i)\n\t\tprintf(\"%d %d\\n\",a[i].id,a[a[i].fa].id);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ljc 998244353\nusing namespace std;\n#define gc getchar\ninline ll read(){\n    register ll x=0,f=1;char ch=gc();\n    while (!isdigit(ch)){if (ch=='-') f=-1;ch=gc();}\n    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}\n    return (f==1)?x:-x;\n}\nint n;\nstruct node{\n\tll x;\n\tint id;\n}x[1010101];\ninline bool cmp(node a,node b){\n\treturn a.x>b.x;\n}\nint sz[1010101];\nmap<ll,int> mp;\nvector<pair<int,int> > as;\nsigned main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++) x[i].x=read(),x[i].id=i,sz[i]=1,mp[x[i].x]=i;\n\tsort(x+1,x+1+n,cmp);\n\tif (n==1){\n\t\tputs(x[1].x==0?\"\":\"-1\");\n\t\treturn 0;\n\t}\n\tif (n==2){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++){\n\t\tif (!mp.count(x[i].x-n+sz[x[i].id]+sz[x[i].id])){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint faa=mp[x[i].x-n+sz[x[i].id]+sz[x[i].id]];\n\t\tas.push_back(make_pair(faa,x[i].id));\n\t\tsz[faa]+=sz[x[i].id];\n\t}\n\tfor (auto i:as) printf(\"%d %d\\n\",i.first,i.second);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <time.h>\n\n#include <stdlib.h>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <vector>\n#include <map>\nusing namespace std;\nstruct condition{\n\tint64_t vertex;\n\tint64_t total;\n};\nstruct current{\n\tint64_t parent;\n\tint64_t vertex_num;\n};\nstruct edge{\n\tint64_t v1;\n\tint64_t v2;\n};\nbool operator< (const condition& a,const condition& b){\n\treturn a.total>b.total;\n}\nint main() {\n\n\tint64_t n;\n\tcin>>n;\n\tstd::vector<condition> cd;\n\tvector<edge> ans;\n\tans.reserve(n);\n\tcd.reserve(n);\n\tfor(int i=0;i<n;i++){\n\t\tint64_t temp;\n\t\tcin>>temp;\n\t\tcd.push_back(condition{i+1,temp});\n\t}\n\tbool ans_possible=true;\n\tsort(cd.begin(),cd.end());\n\tmap<int64_t,vector<current> > flow;\n\tfor(auto i=cd.begin();i!=cd.end();i++){\n\t\tbool islast = (i==cd.end()-1);\n\t\tint64_t sum_vertex=0;\n\n\t\tif(flow.count(i->total)){\n\t\t\tvector<current>& t=flow.at(i->total);\n\t\t\tint64_t total_cost=0;\n\t\t\tfor(auto k=t.begin();k!=t.end();k++){\n\t\t\t\tans.push_back(edge{k->parent,i->vertex});\n\t\t\t\tsum_vertex+=(k->vertex_num);\n\t\t\t\ttotal_cost+=((k->vertex_num)*(k->vertex_num+1))/2;\n\t\t\t}\n\t\t\tans_possible=(total_cost==i->total);\n\n\t\t\tflow.erase(i->total);\n\t\t}else{\n\t\t\tans_possible=false;\n\t\t}\n\n\t\tsum_vertex++;\n\n\t\tint64_t parent_value=i->total-(n-2*sum_vertex);\n\t\tif(!islast&&parent_value>=i->total){\n\t\t\tans_possible=false;\n\t\t\tbreak;\n\t\t}\n\t\tif(flow.count(parent_value)){\n\t\t\tflow.at(parent_value).push_back(current{i->vertex,sum_vertex});\n\t\t}else{\n\t\t\tvector<current> temp2;\n\t\t\ttemp2.push_back(current{i->vertex,sum_vertex});\n\t\t\tflow.emplace(parent_value,temp2);\n\t\t}\n\n\t}\n\tif(flow.size()==1&&ans_possible&&ans.size()==(n-1)){\n\t\tfor(auto i=ans.begin();i!=ans.end();i++){\n\t\t\tcout<<i->v1<<\" \"<<i->v2<<endl;\n\t\t}\n\t}else{\n\t\tcout<<-1<<endl;\n\t}\n\n\n\n\n\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <vector>\n\nint t1,t2;\n\nint n;\nstd::pair<long long,int> d[100005];\nstd::map<long long,int> m;\nbool vis[100005];\n\nstd::vector<std::pair<int,int> > out;\n\nlong long base=0;\n\nint main()\n{\n    #ifdef NOT_DMOJ\n    freopen(\"data.txt\",\"r\",stdin);\n    #endif // NOT_DMOJ\n    scanf(\"%d\",&n);\n    for (int i=0; i<n; i++) {\n        scanf(\"%lld\",&d[i].first);\n        d[i].second=i+1;\n        m[d[i].first]=i+1;\n    }\n    std::sort(d,d+n);\n    int centroid=d[0].second;\n    vis[0]=1;\n    while (1) {\n        long long hi=0;\n        for (int i=0; i<n; i++) {\n            if (vis[d[i].second]) continue;\n            if (hi<d[i].first) hi=d[i].first;\n        }\n        if (hi==0) break;\n        int dist=0;\n        while (hi>d[0].first) {\n            t1=m[hi];\n            vis[t1]=1;\n            dist++;\n            hi-=n-2*dist;\n            if (!m.count(hi)) {\n                printf(\"-1\\n\");\n                return 0;\n            }\n            t2=m[hi];\n            vis[t2]=1;\n            out.push_back({t1,t2});\n        }\n        if (hi<d[0].first) {\n            printf(\"-1\\n\");\n            return 0;\n        }\n        base+=(dist*(long long)(dist+1))/2;\n    }\n    if (base!=d[0].first) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n    for (auto &p:out) printf(\"%d %d\\n\",p.first,p.second);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#define ll long long\n#define inf 0x3f3f3f3f\n#define maxn 200010\ninline ll read()\n{\n\tll x=0; char c=getchar(),f=1;\n\tfor(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n\tfor(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\ninline void write(ll x)\n{\n\tstatic char buf[20];\n\tint len=0;\n\tif(x<0)putchar('-'),x=-x;\n\tfor(;x;x/=10)buf[len++]=x%10+'0';\n\tif(!len)putchar('0');\n\telse while(len)putchar(buf[--len]);\n}\ninline void writesp(ll x){write(x); putchar(' ');}\ninline void writeln(ll x){write(x); putchar('\\n');}\nll d[maxn];\nstd::map<ll,int>mp;\nint id[maxn],fa[maxn],size[maxn];\nint anc[maxn];\nint n;\nbool cmp(int x,int y){return d[x]>d[y];}\nint find(int x){return anc[x]==x?x:anc[x]=find(anc[x]);}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)\n\t\td[i]=read(),mp[d[i]]=i;\n\tfor(int i=1;i<=n;i++)\n\t\tid[i]=i,size[i]=1;\n\tstd::sort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<n;i++){\n\t\tfa[id[i]]=mp[d[id[i]]-(n-2*size[id[i]])];\n\t\t// printf(\"%d %d %d\\n\",id[i],size[id[i]],fa[id[i]]);\n\t\tif(!fa[id[i]]||size[id[i]]>n/2){\n\t\t\tputs(\"-1\"); return 0;\n\t\t}\n\t\tsize[fa[id[i]]]+=size[id[i]];\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tanc[i]=i;\n\tfor(int i=1;i<=n;i++)\n\t\tif(fa[i]){\n\t\t\tif(find(fa[i])==find(i)){\n\t\t\t\tputs(\"-1\"); return 0;\n\t\t\t}\n\t\t\tanc[find(i)]=find(fa[i]);\n\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(fa[i])writesp(fa[i]),writeln(i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\n\nstruct node{\n\tint v,id;\n}a[100001];\n\nint n,s,sz[100001],s1[100001],s2[100001];\nvector<int> ga[100001];\nmap<int,int> num;\n\nbool cmp(node a,node b){\n\treturn a.v>b.v;\n}\n\nvoid dfs(int x,int fa,int d){\n\ts+=d;\n\tfor(int i=0;i<ga[x].size();i++)\n\t\tif(ga[x][i]!=fa)dfs(ga[x][i],x,d+1);\n}\n\nint main(){\n\tint i,x,t,y;\n\tcin >> n;\n\tfor(i=1;i<=n;i++){\n\t\tcin >> a[i].v;\n\t\tnum[a[i].v]=i;\n\t\ta[i].id=i;\n\t\tsz[i]=1;\n\t}\n\tsort(a+1,a+n+1,cmp);\n\tfor(i=1;i<n;i++){\n\t\tx=a[i].id;\n\t\tt=a[i].v-(n-sz[x])+sz[x];\n\t\tif(!num[t] || t>=a[i].v){\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\ty=num[t];\n\t\ts1[i]=x;\n\t\ts2[i]=y;\n\t\tsz[y]+=sz[x];\n\t\tga[x].push_back(y);\n\t\tga[y].push_back(x);\n\t}\n\tdfs(a[n].id,0,0);\n\tif(s!=a[n].v){\n\t\tcout << -1;\n\t\treturn 0;\n\t}\n\tfor(i=1;i<n;i++)\n\t\tcout << s1[i] << ' ' << s2[i] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=1e5+5;\nusing namespace std;\nstruct Edge{int x,y;}e[N];\nstruct Node{\n\tlong long d;int id;\n\tbool operator <(const Node &b)const{return d<b.d;}\n}d[N];\nint n,cnt;\nlong long size[N];\nlong long dis;\ninline Node Make(long long _d,int _id){Node t;t.d=_d,t.id=_id;return t;}\nint main(){\n\t\n\tregister int i;\n    long long x;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i)\n\t\tscanf(\"%lld\",&x),d[i].d=x,d[i].id=i,size[i]=1;\n\tsort(d+1,d+n+1);\n\tfor(i=n;i>=2;--i){\n\t\tlong long t=d[i].d-n+size[i]*2;\n\t\tint pos=lower_bound(d+1,d+n+1,Make(t,0))-d;\n\t\tif(d[pos].d!=t) return puts(\"-1\"),0;\n\t\te[++cnt]=(Edge){d[i].id,d[pos].id};\n\t\tsize[pos]+=size[i]; //\n\t\tdis+=size[i];\n\t}\n\tif(dis!=d[1].d) puts(\"-1\");\n\telse\n\t\tfor(i=1;i<=cnt;++i)\n\t\t\tprintf(\"%d %d\\n\",e[i].x,e[i].y);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define eb emplace_back\n#define mt make_tuple\n#define all(x) (x).begin(), (x).end() \n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair <int, int> ii;\ntypedef pair <ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef long double ld;\n\nconst ll INF=LLONG_MAX;\nconst int mxn=1e5+5;\nll sz[mxn];\nbool vis[mxn];\n\nint main()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    //freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout);\n\tint n;\n\tcin >> n;\n\tpair<ll,int> dist[n];\n\tmap<ll,int>mp;\n\tfor(int i=0; i<n; i++){\n\t\tcin >> dist[i].fi;\n\t\tdist[i].se=i;\n\t\tsz[i]=1LL;\n\t\tmp[dist[i].fi]=i;\n\t}\n\tmap<ii,bool>edge;\n\tsort(dist,dist+n);\n\tfor(int i=n-1; i>0; i--){\n\t\tint ind = dist[i].se;\n\t\tll next = dist[i].fi-n+2*sz[ind];\n\t\tif(mp.find(next)==mp.end()){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint ptr = mp[next];\n\t\tif(ptr==ind){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsz[ptr] += sz[ind];\n\t\tif(ptr>ind)swap(ind,ptr);\n\t\tedge[ii(ptr,ind)]=1;\n\t\tvis[ind]=1; vis[ptr]=1;\n\t}\n\tbool ok=0;\n\tfor(int i=0; i<n&&!ok; i++){\n\t\tif(sz[i]==n)ok=1;\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tif(!vis[i])ok=0;\n\t}\n\tif(!ok)cout << -1 << endl;\n\telse{\n\t\tfor(auto x:edge)\n\t\t\tcout << x.fi.fi+1 << ' ' << x.fi.se+1 << endl;\n\t}\n}\n\t\n// READ & UNDERSTAND\n// ll, int overflow, array bounds, memset(0)\n// special cases (n=1?), n+1 (1-index)\n// do smth instead of nothing & stay organized\n// WRITE STUFF DOWN\n"
  },
  {
    "language": "C++",
    "code": "// Ho-kago Tea Time\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MAXN = (int) 1e5;\n\nint n;\n\nstruct node\n{\n\tint u;\n\tLL D;\n\n\tinline bool operator < (const node &rhs) const { return this->D < rhs.D; }\n\n\tnode() { }\n\tnode(int _u, LL _D): u(_u), D(_D) { }\n}d[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tfor(int i = 1; i <= n; ++i) d[i] = node(i, read<LL>());\n}\n\ninline void solve()\n{\n\tstatic priority_queue<node> Q;\n\tstatic unordered_map<LL, int> id;\n\tstatic int size[MAXN + 5];\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tQ.push(d[i]);\n\t\tid[d[i].D] = d[i].u;\n\t\tsize[d[i].u] = 1;\n\t}\n\n\tstatic vector<pii> E;\n\n\twhile(SZ(Q) > 1)\n\t{\n\t\tint u = Q.top().u;\n\t\tLL D = Q.top().D;\n\t\tQ.pop();\n\n\t\tint v = id[D + 2 * size[u] - n];\n\t\tif(!v || v == u) { puts(\"-1\"); return; }\n\t\tE.emplace_back(u, v), size[v] += size[u];\n\t}\n\tfor(auto i : E) printf(\"%d %d\\n\", i.fst, i.snd);\n}\n\nint main()\n{\n#ifdef K_ON // K-ON!\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <long long, long long> pii;\n\nconst long long MAX_N = 1e5 + 5;\nlong long n, root;\nlong long Arr[MAX_N];\nlong long h[MAX_N];\nlong long Siz[MAX_N];\nlong long Mark[MAX_N];\nlong long par[MAX_N];\nunordered_map <long long, long long> Map;\nvector <pii> edge;\nlong long dp_d[MAX_N];\nlong long dp_u[MAX_N];\nvector <long long> child[MAX_N];\n\nbool cmp(long long a, long long b) {\n\treturn Arr[b] < Arr[a];\n}\n\nvoid dfs1(long long v) {\n\tfor (long long i = 0; i < child[v].size(); i++) {\n\t\tdfs1(child[v][i]);\n\t\tdp_d[v] += dp_d[child[v][i]] + Siz[child[v][i]];\n\t}\n}\n\nvoid dfs2(long long v, long long val) {\n\tdp_u[v] = val;\n\tfor (long long i = 0; i < child[v].size(); i++)\n\t\tdfs2(child[v][i], dp_d[v] - dp_d[child[v][i]] - Siz[child[v][i]] + dp_u[v] + (n - Siz[child[v][i]]));\n}\n\nint main() {\n\tios::sync_with_stdio(false), cout.tie(0), cin.tie(0);\n\tcin >> n;\n\tfor (long long i = 0; i < n; i++) {\n\t\tcin >> Arr[i];\n\t\tSiz[i] = 1;\n\t\th[i] = i;\n\t\tMap[Arr[i]] = i;\n\t}\n\t\t\n\tsort(h, h + n, cmp);\n\t\n\tfor (long long i = 0; i + 1 < n; i++) {\n\t\tlong long v = h[i];\n\t\tlong long tmp = Arr[v] + Siz[v] - (n - Siz[v]);\n\n\t\tif (tmp < 0 || (Map[tmp] == 0 && Arr[0] != tmp)) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tlong long u = Map[tmp];\n\t\t/*if (Mark[u]) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}*/\n\t\t\n\t\tSiz[u] += Siz[v];\n\t\tpar[v] = u;\n\t\tedge.push_back({v, u});\n\t\tchild[u].push_back(v);\n\t\tif (n < 2LL * Siz[v]) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t//Mark[v] = true;\n\t}\n\troot = h[n - 1];\n\tdfs1(root);\n\t//dfs2(root, 0);\n\t\n\tfor (long long i = root; i < root + 1; i++)\n\t\tif (dp_d[i] + dp_u[i] != Arr[i]) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\n\tfor (long long i = 0; i + 1 < n; i++)\n\t\tcout << edge[i].first + 1 << \" \" << edge[i].second + 1 << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 100005;\nusing ll =long long;\nll n;\nvector<pair<ll,ll> >e;\nvector<int>size;\nmap<int,int>mp;\nint main(){\n    ll tmp;\n    scanf(\"%lld\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%lld\",&tmp);\n        mp[tmp]=i;\n        e.push_back(make_pair(tmp,i));   \n    }\n    sort(e.rbegin(),e.rend());\n    vector<pair<int,int>>ans;\n    vector<int>size(n,1);\n    vector<int>dp(n,0);\n    ll x = e.back().first;\n    for(auto c:e){\n        if(c.first!=x){\n            if(size[c.second]*2>=n){\n                cout<<\"-1\";\n                return 0;\n            }\n            ll pre = c.first - n + 2 * size[c.second];\n            if(!mp.count(pre)){\n                cout<<\"-1\";\n                return 0;\n            }\n            int par = mp[pre];\n            dp[par] += dp[c.second] + size[c.second];\n            size[par] += size[c.second];\n            ans.push_back(make_pair(c.second+1,par+1));\n        }\n    }\n     if(dp[e.back().second]!=x){\n        cout<<\"-1\";\n        return 0;\n    }\n    for(auto c: ans){\n        cout<<c.first <<' '<<c.second <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nint main()\n{\n    int n;\n    cin >> n;\n    vector<ll> d(n);\n    using P = pair<ll, ll>;\n    vector<P> p(n);\n    for(int i = 0; i < n; i++)\n    {\n        cin >> d[i];\n        p[i] = P(d[i], i+1);\n    }\n    sort(d.begin(), d.end());\n    sort(p.begin(), p.end());\n\n    vector<int> num(n);\n  vector<P> ans;\n    vector<ll> dis(n);\n    for(int i = n-1; i >= 1; i--)\n    {\n        num[i]++;\n        ll cand = d[i] - n + 2 * num[i];\n        int x = lower_bound(d.begin(), d.end(), cand) - d.begin();\n        if(x >= i || d[x] != cand)\n        {\n            cout << -1 << endl;\n            return 0;\n        }\n        num[x] += num[i];\n        dis[x] = dis[x] + dis[i] + num[i];\n        ans.push_back(P(x, i));\n    }\n    if(dis[0] != d[0])\n    {\n      cout << -1 << endl;\n      return 0;\n    }\n    for(int i = 0; i < ans.size(); i++)\n    {\n        cout << p[ans[i].first].second << \" \" << p[ans[i].second].second << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXn = 1e5 + 10;\ntypedef pair<long long, int> pii;\npii ar[MAXn];\nlong long n, sz[MAXn], root, disroot, d[MAXn], hp3[MAXn];\nvector<int> vec[MAXn];\nvector<pii> ans;\n\nbool cmp(pii p1, pii p2) {\n\treturn p1.first > p2.first;\n}\n\n//long long dfs1(int v, int  par) {\n//\tlong long res = 0;\n//\tfor (int i = 0; i < vec[v].size(); i++)\n//\t\tif (vec[v][i] != par) {\n//\t\t\tres += dfs1(vec[v][i], v) + hp3[vec[v][i]];\n//\t\t\thp3[v] += hp3[vec[v][i]];\n//\t\t}\n//\thp3[v]++;\n//\n//\treturn res;\n//\t\n//}\n//\n//void dfs2(int v, int par, long long sth) {\n//\tif (sth != d[v]) {\n//\t\tcout << -1;\n//\t\texit(0);\n//\t}\n//\tfor (int i = 0; i < vec[v].size(); i++) {\n//\t\tif (vec[v][i] != par) {\n//\t\t\tdfs2(vec[v][i], v, sth - (hp3[vec[v][i]]) + (hp3[ar[0].second] - hp3[vec[v][i]]));\n//\t\t\t\n//\t\t}\n//\t\t\n//\t}\n//\t\n//}\nint main() {\n\tios::sync_\n\tcin >> n;\n\tfill_n(sz, MAXn, 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tlong long di;\n\t\tcin >> di;\n\t\td[i] = di;\n\t\tar[i].first = di;\n\t\tar[i].second = i;\n\t}\n\tsort(ar, ar + n);\n\tfor (int i = n - 1; i > 0; i--) {\n\t\tlong long hp = ar[i].first - n;\n\t\thp += 2LL * sz[ar[i].second];\n\t\tint hp2 = lower_bound(ar, ar + n, pii(hp, -1)) - ar;\n\t\tif (ar[hp2].first != hp)\n\t\t\treturn cout << -1,0;\n\t\tsz[ar[hp2].second] += sz[ar[i].second];\n\t\tvec[ar[hp2].second].push_back(ar[i].second);\n\t\tvec[ar[i].second].push_back(ar[hp2].second);\n\t\tans.push_back(pii(ar[i].second, ar[hp2].second));\n\t}\n//\tdisroot = dfs1(ar[0].second, -1);\n//\tdfs2(ar[0].second, -1, disroot);\n\tif (ans.size() != n - 1)\n\t\treturn cout << -1,0;\n\tfor (int i = 0; i < ans.size(); i++)\n\t\tcout << ans[i].first + 1<< ' ' << ans[i].second + 1<< endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:16000000\")\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> ii;\n\nconst int Maxn = 100005;\n\nint n;\nll D[Maxn];\nmap <ll, ll> M;\nmap <ll, int> ind;\nvector <ii> res;\nvector <int> neigh[Maxn];\nll cor;\n\nll Solve(int v, int p, int cur)\n{\n    ll res = cur;\n    for (int i = 0; i < neigh[v].size(); i++) {\n        int u = neigh[v][i];\n        if (p == u) continue;\n        res += Solve(u, v, cur + 1);\n    }\n    return res;\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lld\", &D[i]);\n        ind[D[i]] = i;\n        M[D[i]] = 0;\n    }\n    sort(D, D + n);\n    for (int i = n - 1; i > 0; i--) {\n        ll my = M[D[i]] + 1;\n        if (my >= n - my) { printf(\"-1\\n\"); return 0; }\n        ll need = D[i] + 2ll * ll(my) - ll(n);\n        map <ll, ll>::iterator it = M.find(need);\n        if (it == M.end()) { printf(\"-1\\n\"); return 0; }\n        it->second += my;\n        int A = ind[D[i]], B = ind[need];\n        neigh[A].push_back(B);\n        neigh[B].push_back(A);\n        res.push_back(ii(A, B));\n    }\n    if (M[D[0]] != n - 1) { printf(\"-1\\n\"); return 0; }\n    if (Solve(ind[D[0]], -1, 0) != D[0]) { printf(\"-1\\n\"); return 0; }\n    for (int i = 0; i < n - 1; i++)\n        printf(\"%d %d\\n\", res[i].first + 1, res[i].second + 1);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+10;\nstruct edge{int v,nxt;}e[maxn<<1];\nint head[maxn],ecnt=0;\nvoid add(int u,int v)\n{\n\te[++ecnt]=(edge){v,head[u]},head[u]=ecnt;\n\te[++ecnt]=(edge){u,head[v]},head[v]=ecnt;\n}\nstruct data\n{\n\tlong long D;\n\tint id;\n\tbool operator < (const data &b){return D<b.D;}\n}c[maxn];\nint fa[maxn],siz[maxn],n,rt;\nint find(int lim,long long x)\n{\n\tint l=1,r=lim,ans=0;\n\twhile(l<=r)\n\t{\n\t\tint mid=l+r>>1;\n\t\tif(c[mid].D>=x)r=mid-1,ans=mid;\n\t\telse l=mid+1;\n\t}\n//\tcout<<c[ans].D<<endl;\n//\tif(c[ans].D!=x)printf(\"fuckyou\\n\");\n\treturn ans;\n}\nint dep[maxn];\nlong long tot=0;\nvoid dfs(int u,int pre)\n{\n\tdep[u]=dep[pre]+1;\n\ttot+=dep[u]-1;\n\tfor(int i=head[u];~i;i=e[i].nxt)\n\t{\n\t\tint v=e[i].v;\n\t\tif(v==pre)continue;\n\t\tdfs(v,u);\n\t}\n}\nint main()\n{\n\tmemset(head,-1,sizeof(head));\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&c[i].D),c[i].id=i;\n\tsort(c+1,c+1+n);\n\tfor(int i=n;i>=2;i--)\n\t{\n\t\tsiz[i]++;\n\t\tint p=find(i-1,c[i].D-(n-2*1LL*siz[i]));\n\t\tif(c[i].D-(n-2*1LL*siz[i])!=c[p].D)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[p]+=siz[i];\n\t\tfa[c[i].id]=c[p].id;\n\t}\n\tfor(int i=1;i<=n;i++)\n\tif(fa[i])add(fa[i],i);\n\telse rt=i;\n\tdfs(rt,0);\n\tif(tot!=c[1].D)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)if(fa[i])printf(\"%d %d\\n\",fa[i],i);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<map>\n\ntypedef long long LL;\n\nconst int N=100005;\n\nint n,a[N],size[N],id[N],ans1[N],ans2[N];\nstd::map<LL,int> num;\n\nbool cmp(int x,int y)\n{\n\treturn a[x]>a[y];\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%lld\",&a[i]),num[a[i]]=i;\n\tfor (int i=1;i<=n;i++) size[i]=1,id[i]=i;\n\tstd::sort(id+1,id+n+1,cmp);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x=id[i];LL w=a[x]-(n-size[x])+size[x];\n\t\tif (!num[w]||a[num[w]]>=a[x]) {puts(\"-1\");return 0;}\n\t\tint y=num[w];\n\t\tans1[i]=x;ans2[i]=y;\n\t\tsize[y]+=size[x];\n\t}\n\tfor (int i=1;i<n;i++) printf(\"%d %d\\n\",ans1[i],ans2[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\nusing Tree = vector<vector<int>>;\n\nint N;\nvector<long long> D;\nmap<long long, int> dtoi;\nvector<int> subtree_size;\n\nlong long rec(const Tree &G, int v) {\n    long long res = 0;\n    for (auto c : G[v]) {\n        res += rec(G, c) + subtree_size[c];\n    }\n    return res;\n}\n\nvoid solve() {\n    subtree_size.assign(N, 1);\n    vector<int> par(N, -1);\n    Tree G(N);\n\n    // greedy from leaves\n    sort(D.begin(), D.end(), greater<long long>());\n    for (int i = 0; i < N-1; ++i) {\n        int id = dtoi[D[i]];\n        int s = subtree_size[id];\n        long long l = N - s * 2;\n        long long nextD = D[i] - l;\n\n\n        //cout << D[i] << \", \" << id << \": \" << s << \", \" << l << \", \" << nextD << endl;\n        \n        if (!dtoi.count(nextD)) {\n            cout << -1 << endl;\n            return;\n        }\n        int nid = dtoi[nextD];\n        par[id] = nid;\n        subtree_size[nid] += subtree_size[id];\n        G[nid].push_back(id);\n    }\n\n    // final check\n    long long DD = rec(G, dtoi[D.back()]);\n    if (DD != D.back()) {\n        cout << -1 << endl;\n        return;\n    }\n\n    // output\n    for (int i = 0; i < N; ++i) {\n        if (par[i] == -1) continue;\n        cout << i+1 << \" \" << par[i]+1 << endl;\n    }\n}\n\nint main() {\n    cin >> N;\n    D.resize(N);\n    for (int i = 0; i < N; ++i) cin >> D[i], dtoi[D[i]] = i;\n    solve();\n}\n    \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 100005;\n\ntemplate <class T>\nvoid read (T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\n\ntemplate <class T>\nvoid write (T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nint n, dep[N], sz[N];\nbool flag = true;\n\nstruct node {\n\tint id;\n\tlong long dist;\n\tbool operator < (node rhs) const {\n\t\treturn dist < rhs.dist;\n\t}\n} vec[N];\nlong long d[N];\nvector<pair<int, int> > tree;\n\nint main () {\n\tread(n);\n\tfor (int i = 1; i <= n; i++) vec[i].id = i, read(vec[i].dist);\n\n\tsort(vec + 1, vec + n + 1);\n\tfor (int i = 1; i <= n; i++) d[i] = vec[i].dist, sz[i] = 1;\n\n\tfor (int i = n; i > 1; i--) {\n\t\tint pos = lower_bound(d + 1, d + i, d[i] - (n - sz[i]) + sz[i]) - d;\n\t\tif (pos >= i || d[pos] != d[i] - (n - sz[i]) + sz[i]) {\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t\ttree.push_back(make_pair(vec[i].id, vec[pos].id));\n\t\tsz[pos] += sz[i];\n\t}\n\n\tdep[vec[1].id] = 0;\n\tfor (int i = n - 2; i >= 0; i--) dep[tree[i].first] = dep[tree[i].second] + 1;\n\n\tfor (int i = 1; i <= n; i++) d[1] -= dep[i];\n\tif (d[1]) flag = false;\n\n\tif (!flag) write(-1), putchar('\\n');\n\telse {\n\t\tfor (int i = 0; i < tree.size(); i++) {\n\t\t\twrite(tree[i].first), putchar(' ');\n\t\t\twrite(tree[i].second), putchar('\\n');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cassert>\n#include<iostream>\n#include<algorithm>\n#include<unordered_map>\n\nusing namespace std;\n\n#define Whats(x) cout<<#x<<\" is \"<<(x)<<endl\n#define DivHim() cout<<\">>>>>>>>>>>>>>>\"<<endl\n#define DivHer() cout<<\"<<<<<<<<<<<<<<<\"<<endl\n#define Oops() cout<<\"!!!!!!!!!!!!!!!\"<<endl\n\ntemplate<typename T> bool GetMin(T &a,T b)\n{\n\treturn ((a<=b)?false:(a=b,true));\n}\n\ntemplate<typename T> bool GetMax(T &a,T b)\n{\n\treturn ((a>=b)?false:(a=b,true));\n}\n\n/*\n\t -<Unlimited Blade Works>-\n */\n\n#define int long long\n\nconst int N=1e5+10;\n\nint n,d[N],id[N],sz[N],fa[N];\nunordered_map<int,int> re;\n\nbool Cmp(int x,int y)\n{\n\treturn d[x]>d[y];\n}\n\nsigned main()\n{\n\tscanf(\"%lld\",&n);\n\tif(n==2)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%lld\",d+i);\n\t\tre[d[i]]=i;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tid[i]=i;\n\t\tsz[i]=1;\n\t}\n\tsort(id+1,id+n+1,Cmp);\n\tfor(int i=1,u,v,x;i<n;++i)\n\t{\n\t\tre[d[u=id[i]]]=0;\n\t\tif((x=sz[u]+sz[u]-n)>=0||!(v=re[d[u]+x]))\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsz[fa[u]=v]+=sz[u];\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tif(fa[i])\n\t\t\tprintf(\"%lld %lld\\n\",fa[i],i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Maxn = 100005;\nint n, cnt, root, fa[Maxn], siz[Maxn], pos[Maxn], head[Maxn];\nlong long d[Maxn], dis[Maxn];\nmap <long long, int> Ma;\nstruct edg\n{\n\tint nxt, to;\n}edge[Maxn];\nvoid add(int x, int y)\n{\n\tedge[++cnt] = (edg){head[x], y};\n\thead[x] = cnt;\n}\nvoid dfs1(int u)\n{\n\tfor (int i = head[u]; i; i = edge[i].nxt)\n\t{\n\t\tint to = edge[i].to;\n\t\tdfs1(to), dis[u] += dis[to] + siz[to];\n\t}\n}\nvoid dfs2(int u)\n{\n\tfor (int i = head[u]; i; i = edge[i].nxt)\n\t{\n\t\tint to = edge[i].to;\n\t\tdis[to] = dis[u] + n - 2 * siz[to];\n\t\tdfs2(to);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\troot = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%lld\", &d[i]), pos[i] = i, Ma[d[i]] = i, siz[i] = 1;\n\tsort(pos + 1, pos + 1 + n, [](int x, int y){return d[x] < d[y];});\n\tfor (int i = n; i >= 1; i--)\n\t{\n\t\tMa[d[pos[i]]] = 0;\n\t\tfa[pos[i]] = Ma[d[pos[i]] - n + 2 * siz[pos[i]]];\n\t\tsiz[fa[pos[i]]] += siz[pos[i]];\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (!fa[i] && i != pos[1])\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tadd(fa[i], i);\n\t}\n\tdfs1(pos[1]);\n\tfor (int i = 2; i <= n; i++)\n\t\tdis[pos[i]] = 0;\n\tdfs2(pos[1]);\n\tfor (int i = 1; i <= n; i++)\n\t\tif (d[i] != dis[i])\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\tfor (int i = 2; i <= n; i++)\n\t\tprintf(\"%d %d\\n\", fa[pos[i]], pos[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n\nconst ll dx[4] = { -1,1,0,0 };\nconst ll dy[4] = { 0,0,-1,1 };\nconst char c[4] = { 'R','L','U','D' };\n\nint main(){\n\tstatic ll n;\n\tstatic ll d[100010];\n\tscanf(\"%lld\",&n);\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tscanf(\"%lld\",&d[i]);\n\t}\n\t\n\tvector<P> vec;\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tvec.push_back(P(d[i],i));\n\t}\n\tsort(vec.begin(),vec.end());\n\treverse(vec.begin(),vec.end());\n\t\n\tstatic ll cnt[100010];\n\tstatic ll dp[100010];\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tcnt[i] = 1;\n\t\tdp[i] = 0;\n\t}\n\t\n\tmap<ll,ll> id;\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tid[d[i]] = i;\n\t}\n\t\n\tvector<P> ans;\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tP p = vec[i-1];\n\t\t//cout << p.fr << \" \" << p.sc << endl;\n\t\tif(cnt[p.sc]*2 >= n)continue;\n\t\tll nx = d[p.sc]-(n-cnt[p.sc])+cnt[p.sc];\n\t\tif(id.find(nx) == id.end()){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tans.push_back(P(p.sc,id[nx]));\n\t\t\tcnt[id[nx]] += cnt[p.sc];\n\t\t\tdp[id[nx]] += dp[p.sc];\n\t\t\tdp[id[nx]] += cnt[p.sc];\n\t\t}\n\t}\n\tif(n%2 == 0){\n\t\tif(vec[n-2].fr != vec[n-1].fr){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tans.push_back(P(vec[n-2].sc,vec[n-1].sc));\n\t}\n\t\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tif(dp[i] != d[i]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tif(ans.size() < n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i = 0 ; i < ans.size() ; i ++){\n\t\tprintf(\"%d %d\\n\",ans[i].fr,ans[i].sc);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<vector>\nusing namespace std;\nstruct node\n{\n\tlong long d;\n\tint id;\n\tfriend bool operator < (node a,node b){return a.d>b.d;}\n}p[100010];\nint n,siz[100010],ans[100010][2];\nmap<long long,int>mp;\nvector<int>E[100010];\nlong long sum;\nvoid dfs(int v,int dep)\n{\n\tsum+=dep;\n\tfor(auto u:E[v])dfs(u,dep+1);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)scanf(\"%lld\",&p[i].d),p[i].id=i;\n\tsort(p+1,p+1+n);\n\tfor(int i=1;i<=n;++i)mp[p[i].d]=p[i].id,siz[i]=1;\n\tfor(int i=1;i<n;++i)\n\t{\n\t//\tprintf(\"%lld %d\\n\",p[i].d,n-2*siz[p[i].id]);\n\t\tmp.erase(p[i].d);\n\t\tif(!mp.count(p[i].d-n+2*siz[p[i].id]))return printf(\"-1\"),0;\n\t\tans[i][0]=p[i].id,ans[i][1]=mp[p[i].d-n+2*siz[p[i].id]];\n\t\tsiz[ans[i][1]]+=siz[ans[i][0]];\n\t\tE[ans[i][1]].emplace_back(ans[i][0]);\n\t}\n\tdfs(p[n].id,0);\n\tif(sum!=p[n].d)return printf(\"-1\"),0;\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stdio.h>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nvector < pair <int, int> > v;\n\nint n, sz[1000000], r[1000000], sum;\n\nbool ans = true;\n\nvector <int> g[1000000];\n\nint dfs (int x, int p)\n{\n\tint sum = sz[x] - 1;\n\n\tfor (int to : g[x])\n\t\tif (to != p)\n\t\t\tsum += dfs (to, x);\n\n\treturn sum;\n}\n\nint main () \n{\n    cin >> n;\n    \n    for (int i = 0; i < n; i++)\n    {\n\t\tint d;\n\t\tscanf (\"%d\", &d);\n\t\t\n\t\tv.emplace_back (d, i);\n\n\t\tr[i] = d;\n    }\n    \n    sort (v.begin (), v.end ());\n    \n    for (int i = n - 1; i > 0; i--)\n    {\n\t\tint x = v[i].second, d = v[i].first;\n\t\t\n\t\tsz[x] = 1;\n\t\t\n\t\tfor (int to : g[x])\n\t\t    sz[x] += sz[to];\n\n\t\tsum += sz[x];\n\t\t\n\t\tif (!i) break;\n\t\t\n\t\tint k = lower_bound (v.begin (), v.end (), make_pair (d + 2 * sz[x] - n, -1)) - v.begin ();\n\t\t\n\t\tif (k >= i || v[k].first != d + 2 * sz[x] - n)\n\t\t{\n\t\t    cout << -1;\n\t\t    return 0;\n\t\t}\n\t\t\n\t\tg[v[k].second].push_back (x);\n    }\n\n    if (sum != v[0].first)\n    {\n\t\tcout << -1;\n\t\treturn 0;\n    }\n    \n    for (int i = 0; i < n; i++)\n\t\tfor (int to : g[i])\n\t\t{\n\t\t    printf (\"%d %d\\n\", i + 1, to + 1);\n\t\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <random>\n#include <complex>\n#include <regex>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define quickIO()\t{cin.tie(0);\tcout.sync_with_stdio(false);}\n#define reach(i,a)\tfor(auto i:a)\n#define rep(i,n)\tfor(int i=0;i<((int)n);i++)\n#define REP(i,n)\tfor(int i=0;i<=((int)n);i++)\n#define srep(i,a,n)\tfor(int i=a;i<((int)n);i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=((int)n);i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define pb\tpush_back\ntemplate<typename T> istream& operator >> (istream& is, vector<T>& vec) {\n\tfor (T& x : vec)\tis >> x;\n\treturn is;\n}\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n\tos << \"[\";\n\trep(i, vec.size())\tos << (i ? \", \" : \"\") << vec[i];\n\tos << \"]\";\n\treturn os;\n}\ntemplate<typename T> istream& operator >> (istream& is, pair<T, T>& p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate<typename T> ostream& operator << (ostream& os, pair<T, T>& p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\";\n\treturn os;\n}\nint bitcnt(ll x) {\n\tx = ((x & 0xAAAAAAAAAAAAAAAA) >> 1) + (x & 0x5555555555555555);\n\tx = ((x & 0xCCCCCCCCCCCCCCCC) >> 2) + (x & 0x3333333333333333);\n\tx = ((x & 0xF0F0F0F0F0F0F0F0) >> 4) + (x & 0x0F0F0F0F0F0F0F0F);\n\tx = ((x & 0xFF00FF00FF00FF00) >> 8) + (x & 0x00FF00FF00FF00FF);\n\tx = ((x & 0xFFFF0000FFFF0000) >> 16) + (x & 0x0000FFFF0000FFFF);\n\tx = ((x & 0xFFFFFFFF00000000) >> 32) + (x & 0x00000000FFFFFFFF);\n\treturn x;\n}\nint bitcnt(int x) {\n\tx = ((x & 0xAAAAAAAA) >> 1) + (x & 0x55555555);\n\tx = ((x & 0xCCCCCCCC) >> 2) + (x & 0x33333333);\n\tx = ((x & 0xF0F0F0F0) >> 4) + (x & 0x0F0F0F0F);\n\tx = ((x & 0xFF00FF00) >> 8) + (x & 0x00FF00FF);\n\tx = ((x & 0xFFFF0000) >> 16) + (x & 0x0000FFFF);\n\treturn x;\n}\nll sqrtll(ll x) {\n\tll left = 0, right = x;\n\trep(i, 100) {\n\t\tll mid = (left + right) >> 1;\n\t\tif (mid*mid <= x)\tleft = mid;\n\t\telse\tright = mid;\n\t}\n\treturn left;\n}\nll gcd(ll a, ll b) {\n\treturn a % b == 0 ? b : gcd(b, a%b);\n}\n#define debug(x)\tprintf(\"Case #%d: \", x)\n#define DEBUG 0\nconst ll inf = 1e18;\nconst ld infl = 1e100;\nconst ll mod = 1e9+7;\nconst ld eps = 1e-9;\nconst int dx[] = { 1,0,-1,0,0 };\nconst int dy[] = { 0,1,0,-1,0 };\n\nint group[100010];\n\nint getGroup(int i) {\n\treturn group[i] = (i == group[i] ? group[i] : getGroup(group[i]));\n}\nvoid merge(int i, int j) {\n\ti = getGroup(i);\tj = getGroup(j);\n\tgroup[i] = group[j];\n}\n\n// 最初の2頂点はxとx-n+2があったらマージ。headのみを残す。\n// 以降x(a)とy(b)についてx+n-2*b=yやy+n-2*a=xで判断\n// x(a)は固定できるけど、y(b)が見つけられない\n// xが親になる場合はx+n=y+2*b->子になる場合はx+2*a-n=y\n// 「一番大きいdiは子になる」より再帰的に(UF)出来そう\nint main() {\n\tint n;\tcin >> n;\n\tvll d(n);\tcin >> d;\n\tvint num(n, 1);\n\tmap<ll, int> mp;\n\trep(i, n) {\n\t\tmp[d[i]] = i;\n\t}\n\tvector<pair<ll, int>> d2(n);\n\trep(i, n) {\n\t\td2[i] = mp(d[i], i);\n\t\tgroup[i] = i;\n\t}\n\tsort(all(d2));\n\tvector<pii> ret;\n\tfor (int i = n - 1; i > 0; i--) {\n\t\tint id = d2[i].second;\n\t\tif (getGroup(id) != id)\tcontinue;\n\t\tint a = num[id];\n\t\tif (!mp.count(d[id] + 2 * a - n) || id == mp[d[id] + 2 * a - n]) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint to = mp[d[id] + 2 * a - n];\n\t\tmp.erase(d[id]);\n\t\tmerge(id, to);\n\t\tnum[to] += num[id];\n\t\tret.push_back(mp(id + 1, to + 1));\n\t}\n\trep(i, n - 1) {\n\t\tcout << ret[i].first << \" \" << ret[i].second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 100005;\ntypedef long long LL;\n\nint n, head[N], nxt[N], size[N];\nLL D[N];\nstd::pair<LL, int> d[N];\n\nvoid no() {std::cout << \"-1\\n\", std::exit(0);}\n\nvoid link(int x, int y) {nxt[y] = head[x], head[x] = y;}\nint find(LL x) {\n\tauto it = std::lower_bound(d + 1, d + n + 1, std::make_pair(x, 0));\n\tif (it->first != x) no();\n\treturn it->second;\n}\nint dfs0(int x) {\n\tfor (int i = head[x]; i; i = nxt[i])\n\t\tD[x] += dfs0(i) + size[i];\n\treturn D[x];\n}\nvoid dfs1(int x) {\n\tfor (int i = head[x]; i; i = nxt[i])\n\t\tD[i] = D[x] + (n - 2 * size[i]), dfs1(i);\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor (int i = 1; i <= n; ++i)\n\t\tstd::cin >> d[i].first, d[i].second = i, size[i] = 1;\n\tstd::sort(d + 1, d + n + 1);\n\tfor (int i = n; i > 1; --i) {\n\t\tint p = d[i].second, f = find(d[i].first - (n - 2 * size[p]));\n\t\tsize[f] += size[p], link(f, p);\n\t}\n\tdfs0(d[1].second), dfs1(d[1].second);\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (D[d[i].second] != d[i].first) no();\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = head[i]; j; j = nxt[j]) std::cout << i << ' ' << j << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\nusing namespace std;\nconst int N=1e5+5;\nint n,p[N],fa[N],sz[N],dep[N];long long d[N];\nmap<long long,int>Map;\nbool cmp(int x,int y){\n\treturn d[x]>d[y];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%lld\",&d[i]);\n\t\tMap[d[i]]=i;p[i]=i;sz[i]=1;\n\t}\n\tsort(p+1,p+n+1,cmp);\n\tfor(int i=1;i<n;++i){\n\t\tint x=p[i];\n\t\tfa[x]=Map[d[x]-n+sz[x]+sz[x]];\n\t\tif(!fa[x]||fa[x]==x)return puts(\"-1\"),0;\n\t\tsz[fa[x]]+=sz[x];\n\t}\n\tlong long sum=0;\n\tfor(int i=n-1;i;--i)dep[p[i]]=dep[fa[p[i]]]+1,sum+=dep[p[i]];\n\tif(sum!=d[p[n]])return puts(\"-1\"),0;\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",p[i],fa[p[i]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define re register\n#define ull unsigned ll\nusing namespace std;\ninline ll read(){\n\tll s=0,t=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')t=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')s=(s<<3)+(s<<1)+(ch^48),ch=getchar();\n\treturn s*t;\n}\n#define f1 first\n#define f2 second\n#define mp make_pair\nconst int N=1e5+5;\nint n,sz[N],f[N];ll Sum;\nvector<int> G[N];\npair<ll,int> p[N];\nvoid DFS(int x,ll d){Sum+=d;for(auto y:G[x])DFS(y,d+1);}\nint main(){\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tn=read();\n\tfor(int i=1;i<=n;i++)sz[i]=1,p[i]=mp(read(),i);\n\tsort(p+1,p+n+1);\n\tfor(int i=n;i>1;i--){\n\t\tint x=p[i].f2;\n\t\tll v=p[i].f1+2*sz[x]-n;\n\t\tint j=lower_bound(p+1,p+i,mp(v,0))-p;\n\t\tif(j>n)return puts(\"-1\"),0;\n\t\tG[f[x]=p[j].f2].push_back(x),sz[f[x]]+=sz[x];\n\t}DFS(p[1].f2,0);\n\tif(Sum^p[1].f1)return puts(\"-1\"),0;\n\tfor(int i=1;i<=n;i++)if(f[i])printf(\"%d %d\\n\",f[i],i);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimiz(O2)\n\n#include <bits/stdc++.h>\n\n#define rg register\nusing namespace std;\ntypedef long long ll;\n\ntemplate<typename T>\ninline bool read(T &n) {\n    T ans = 0, flag = 1;\n    char ch;\n    while ((ch = getchar()) < '0' || ch > '9') if (ch == '-') flag = -1; else if (ch == EOF) return false;\n    ans = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9') ans = ans * 10 + ch - '0';\n    n = ans * flag;\n    return true;\n}\n\ninline ll read() {\n    ll ans = 0, flag = 1;\n    char ch;\n    while ((ch = getchar()) < '0' || ch > '9') if (ch == '-') flag = -1;\n    ans = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9') ans = ans * 10 + ch - '0';\n    return ans * flag;\n};\nconst int maxn = 100005;\nstruct NODE {\n    ll val, ord;\n    bool operator<(NODE b) const {\n        return val < b.val;\n    }\n} node[maxn];\nint siz[maxn],fa[maxn];\nunordered_map<ll,int> unM;\nint main() {\n    int n;\n    read(n);priority_queue<NODE> pq;\n    for (rg int i = 1; i <= n; ++i) {\n        siz[i] = 1;\n        read(node[i].val);\n        node[i].ord = i;\n        pq.push(node[i]);\n        unM[node[i].val]=i;\n    }\n    for(rg int i=n;i>=2;i--){\n        NODE now=pq.top();pq.pop();\n        if(unM.find(now.val+2*siz[now.ord]-n)==unM.end()){\n            puts(\"-1\");return 0;\n        }\n        fa[now.ord]=unM[now.val+2*siz[now.ord]-n];\n        siz[fa[now.ord]]+=siz[now.ord];\n    }\n    for(rg int i=1;i<=n;i++){\n        if(fa[i]) cout<<i<<' '<<fa[i]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <set>\n#include <map>\nusing namespace std;\nint n;\n/*int a[100020];\nint b[100020];*/\npair<long long, int> d[100200];\nmap<long long, int> mp;\nint used[100200];\nint sz[100200];\nvoid bad() {\n    cout << \"-1\\n\";\n    exit(0);\n}\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> d[i].first;\n        d[i].second = i;\n    }\n    vector<pair<int, int> > ans;\n    sort(d + 1, d + n + 1);\n    for (int i = 1; i <= n; i++) mp[d[i].first] = i;\n\n    for (int i = n; i > 1; i--) {\n        sz[i]++;\n        long long x = d[i].first - (n - 2 * sz[i]);\n        if (mp[x] == 0) bad();\n        else {\n            sz[mp[x]] += sz[i];\n            ans.push_back(make_pair(d[i].second, d[mp[x]].second));\n        }\n        if (sz[i] > n) bad();\n    }\n    sz[1]++;\n    if (sz[1] != n) bad();\n    for (auto it: ans) cout << it.first << \" \" << it.second << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define IL inline\n#define _ 1000005\n#define ll long long\nusing namespace std ;\n\nIL ll gi(){\n\tll data = 0 , m = 1; char ch = 0;\n\twhile(ch!='-' && (ch<'0'||ch>'9')) ch = getchar();\n\tif(ch == '-'){m = 0 ; ch = getchar() ; }\n\twhile(ch >= '0' && ch <= '9'){data = (data<<1) + (data<<3) + (ch^48) ; ch = getchar(); }\n\treturn (m) ? data : -data ; \n}\n\nll fa[_],sz[_],m,n,d[_],f[_],g[_] ; \nstruct Item{ll id , dis ; } t[_] ; \n\nstruct _Edge{int to,next ; }Edge[_<<1] ; int head[_],CNT ;  \nIL void AddEdge(int u , int v) {\n    Edge[++CNT] = (_Edge){v , head[u]} ; head[u] = CNT ; \n    return ;  \n}\n\nIL bool cmp1(Item A , Item B){\n\treturn (A.dis ^ B.dis) ? A.dis < B.dis : A.id < B.id ;  \n}\nIL bool cmp2(Item A , Item B){\n\treturn (A.id ^ B.id) ? A.id < B.id : A.dis < B.dis ;  \n}\n\nvoid dfs1(int u , int From) {\n    sz[u] = 1ll ;\n    for(int e = head[u] ; e ; e = Edge[e].next) {\n        int v = Edge[e].to ; if(v == From) continue ; \n        dfs1(v , u) ;\n        f[u] += f[v] + sz[v] ; \n        sz[u] += sz[v] ;  \n    }\n    return ; \n}\nvoid dfs2(int u , int From) {\n    for(int e = head[u] ; e ; e = Edge[e].next) {\n        int v = Edge[e].to ; if(v == From) continue ; \n        g[v] = f[u] + g[u] - (f[v] + sz[v]) + (n - sz[v]) ; \n        dfs2(v , u) ; \n    }\n    return ; \n}\n\nint main() {\n\tn = gi() ;\n\tfor(int i = 1; i <= n; i ++) t[i].id = i , t[i].dis = gi() ;\n\tsort(t + 1 , t + n + 1 , cmp1) ;\n\tfor(int i = 1; i <= n; i ++) d[i] = t[i].dis ; \n\td[n + 1] = 1e18 ;  \n\tfor(int i = n; i > 1; i --) {\n\t\tint u = t[i].id ; \n\t\tsz[u] ++ ; \n\t\tll ds = t[i].dis + 2ll * sz[u] - n ;\n\t\tll ps = lower_bound(d + 1 , d + n + 2 , ds) - d ;\n\t\tif(ps >= i || t[ps].dis != ds) return puts(\"-1\") , 0 ;\n\t\tfa[u] = t[ps].id ;\n\t\tsz[t[ps].id] += sz[u] ; \n\t}\n\tsort(t + 1 , t + n + 1 , cmp2) ; \n\tfor(int i = 1; i <= n; i ++) if(fa[i]) AddEdge(fa[i],i) , AddEdge(i,fa[i]) ; \n\tdfs1(1 , 0) ; \n\tdfs2(1 , 0) ; \n\t//for(int i = 1; i <= n; i ++)\n\t//    printf(\"f[%d] = %lld  ;  g[%d] = %lld\\n\",i,f[i],i,g[i]) ;\n\tfor(int i = 1; i <= n; i ++) if(f[i]+g[i] != t[i].dis) return puts(\"-1\") , 0 ;\n\tfor(int i = 1; i <= n; i ++) if(fa[i]) cout << fa[i] << \" \" << i << endl ;\n\treturn 0 ; \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#define int long long\nint n,sz[100100],u[100100],v[100100],head[100100],cnt,D;\nstruct Edge{\n\tint to,nxt;\n}edge[200100];\nstruct node{\n\tint dis,x;\n\tbool operator<(node b)const{\n\t\treturn dis>b.dis;\n\t}\n}a[100100];\nmap<int,int>mp;\nvoid addedge(int x,int y){\n\tedge[++cnt].to=y;\n\tedge[cnt].nxt=head[x];\n\thead[x]=cnt;\n}\nint dfs(int x,int fa,int now){\n\tD+=now;\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tint upup=edge[i].to;\n\t\tif(upup==fa)continue;\n\t\tdfs(upup,x,now+1);\n\t}\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i].dis);\n\t\ta[i].x=i;\n\t\tmp[a[i].dis]=i;\n\t}\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)sz[i]=1;\n\tfor(int i=1;i<n;i++){\n\t\tint dis=a[i].dis,x=a[i].x;\n\t\tint tmp=dis-abs(n-2*sz[x]);\n\t\tint fa=mp.find(tmp)->second;\n\t\tif(fa==x||!fa)return puts(\"-1\"),0;\n\t\tsz[fa]+=sz[x];\n\t\tD+=sz[a[i].x];\n\t\tu[i]=x,v[i]=fa;\n\t\taddedge(x,fa);\n\t\taddedge(fa,x);\n\t}\n\t//dfs(a[n].x,0,0);\n\tif(D!=a[n].dis)return puts(\"-1\"),0;\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%lld %lld\\n\",u[i],v[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<cstring>\n#include<utility>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<set>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#define ll long long\n#define pii pair<int,int>\n#define mp make_pair\n#define fi first\n#define se second\n#define inf 0x7fffffff\nusing namespace std;\npii a[100010];\nint main()\n{\n\tint i,j,k,n,m;\n\tll x,y;\n\tscanf(\"%d\",&n);\n\tx=0;\n\tfor(i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&a[i].fi,&a[i].se);\n\t\tx=max(x,1ll*abs(a[i].se)+abs(a[i].fi));\n\t\tif(i>0&&(((1ll*abs(a[i].se)+abs(a[i].fi))&1)!=((1ll*abs(a[i-1].se)+abs(a[i-1].fi))&1)))\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(i=0;i<=40;i++)\n\t{\n\t\tif((1ll<<(i))-1>=x)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\tm=i;\n\tprintf(\"%d\\n\",x%2==1?i:i+1);\n\tfor(i=0;i<m;i++)\n\t{\n\t\tprintf(\"%d \",1<<i);\n\t}\n\tif(x%2==0)\n\t{\n\t\tprintf(\"1\");\n\t}\n\tprintf(\"\\n\");\n\tstring s;\n\tfor(i=0;i<n;i++)\n\t{\n\t\tj=0;\n\t\ts=\"\";\n\t\tif(x%2==0)\n\t\t{\n\t\t\ta[i].fi++;\n\t\t}\n\t\tfor(j=0;j<m;j++)\n\t\t{\n\t\t\tif(abs(a[i].fi)>abs(a[i].se))\n\t\t\t{\n\t\t\t\tif(a[i].fi>0)\n\t\t\t\t{\n\t\t\t\t\ts+=\"R\";\n\t\t\t\t\ta[i].fi-=(1<<(m-j-1));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts+=\"L\";\n\t\t\t\t\ta[i].fi+=(1<<(m-j-1));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(a[i].se>0)\n\t\t\t\t{\n\t\t\t\t\ts+=\"U\";\n\t\t\t\t\ta[i].se-=(1<<(m-j-1));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts+=\"D\";\n\t\t\t\t\ta[i].se+=(1<<(m-j-1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treverse(s.begin(),s.end());\n\t\tcout<<s<<\"L \"[x%2];\n\t\tprintf(\"\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nconst long long mo=50000007;\nconst int maxn=200010;\n\nint n,m,d[maxn],id[maxn],fa[maxn];\nlong long siz[maxn],ans,js[maxn];\nint tot,nex[maxn*2],las[maxn*2],tov[maxn*2];\nint hs[mo+10];\n\nvoid con(int x,int y)\n{\n\ttot++;\n\ttov[tot]=y;\n\tnex[tot]=las[x];\n\tlas[x]=tot;\n}\n\nvoid insert(long long x,int id)\n{\n\tlong long i=x%mo;\n\twhile (hs[i]!=0)\n\t{\n\t\ti++;\n\t\tif (i==mo) i=0;\n\t}\n\ths[i]=id;\n}\n\nlong long find(long long x)\n{\n\tlong long i=x%mo;\n\twhile (hs[i]!=0 && d[hs[i]]!=x)\n\t{\n\t\ti++;\n\t\tif (i==mo) i=0;\n\t}\n\treturn hs[i];\n}\n\nvoid qsort(int l,int r)\n{\n\tint i=l;int j=r;\n\tlong long m=d[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (d[i]>m) i++;\n\t\twhile (d[j]<m) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(d[i],d[j]);\n\t\t\tswap(id[i],id[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort(l,j);\n\tif (r>i) qsort(i,r); \n}\n\nvoid dfs(int x,int ff)\n{\n\tjs[x]=js[ff]+1;\n\tfor (int i=las[x];i;i=nex[i])\n\t{\n\t\tif (tov[i]!=ff)\n\t\t{\n\t\t\tdfs(tov[i],x);\n\t\t\tans+=js[x];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&d[i]);\n\t\tid[i]=i;\n\t\tsiz[i]=1;\n\t}\n\tqsort(1,n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinsert(d[i],i);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tlong long op=d[i]-abs(n-2*siz[i]);\n\t\tlong long oq=find(op);\n\t\tif (oq==0)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfa[i]=oq;\n\t\t\tsiz[oq]+=siz[i];\n\t\t\tcon(i,oq);con(oq,i);\n\t\t}\n\t}\n\tdfs(n,0);\n\tif (ans!=d[n])\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tfor (int i=1;i<n;i++)\n\t\t{\n\t\t\tprintf(\"%d %d\\n\",id[i],id[fa[i]]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\nconst int N = 100'009;\n\nlong long a[N];\nint o[N];\nint cnt[N];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  map<long long, int> w;\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%lld\", a + i);\n    w[a[i]] = i;\n  }\n  for (int i = 0; i < n; ++i) {\n    o[i] = i;\n  }\n  sort(o, o + n, [](int i, int j) {\n    return a[i] > a[j];\n  });\n  for (int i = 0; i < n; ++i) {\n    cnt[i] = 1;\n  }\n  vector<pair<int, int>> ans;\n  long long sum = 0;\n  for (int i = 0; i < n - 1; ++i) {\n    int x = o[i];\n    long long v = a[x] - (n - (cnt[x] + 1)) + (cnt[x] - 1);\n    if (v >= a[x] || w.count(v) == 0) {\n      puts(\"-1\");\n      return 0;\n    }\n    sum += cnt[x];\n    int y = w[v];\n    ans.emplace_back(x, y);\n    cnt[y] += cnt[x];\n  }\n  if (a[o[n - 1]] != sum) {\n    puts(\"-1\");\n    return 0;\n  }\n  for (auto &e : ans) {\n    printf(\"%d %d\\n\", e.first + 1, e.second + 1);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst int MAXN = 200010;\nconst LL INF = 2147483600;\n\nstruct data{\n\tLL id,val;\n}a[MAXN+1]; LL N;\nbool cmpval(data a,data b){\n\treturn a.val>b.val;\n}\nLL Node[MAXN<<1],Next[MAXN<<1],Root[MAXN+1],cnt;\ninline void insert(LL u,LL v){\n\tNode[++cnt]=v; Next[cnt]=Root[u]; Root[u]=cnt; return ;\n} LL sz[MAXN+1],f[MAXN+1],b[MAXN+1];\ninline void dfs(LL k,LL Fa){\n\tsz[k]=1;\n\tfor(LL x=Root[k];x;x=Next[x]){\n\t\tLL v=Node[x]; if(v==Fa) continue;\n\t\tdfs(v,k); sz[k]+=sz[v]; f[1]+=sz[v];\n\t} return ;\n}\ninline void dfs2(LL k,LL Fa){\n\tif(f[k]!=b[k]){ puts(\"-1\"); exit(0); }\n\tfor(LL x=Root[k];x;x=Next[x]){\n\t\tLL v=Node[x]; if(v==Node[x]) continue;\n\t\tf[v]=f[k]+N-2*sz[v]; dfs2(v,k);\n\t} return ;\n} LL s1[MAXN+1],s2[MAXN+1],top;\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tN=read();\n\tfor(LL i=1;i<=N;i++){\n\t\ta[i].id=i; a[i].val=read(); b[i]=a[i].val;\n\t} sort(a+1,a+N+1,cmpval);\n\tfor(LL i=1;i<=N;i++) sz[i]=1;\n\tfor(LL i=1;i<N;i++){\n\t\tLL val=a[i].val-N+2*sz[i]; \n\t\tLL l=i+1,r=N,pos=-1;\n\t\twhile(l<=r){\n\t\t\tLL mid=(l+r)>>1;\n\t\t\tif(a[mid].val>=val) pos=mid,l=mid+1;\n\t\t\telse r=mid-1;\n\t\t} if(pos==-1||a[pos].val!=val){\n\t\t\tputs(\"-1\"); return 0;\n\t\t} sz[pos]+=sz[i];\n\t\ts1[++top]=a[i].id; s2[top]=a[pos].id;\n\t\tinsert(a[i].id,a[pos].id);\n\t\tinsert(a[pos].id,a[i].id);\n\t\t//sz=N+a[fa]-a[i].val\n\t} dfs(1,0); dfs2(1,0);\n\tfor(LL i=1;i<=top;i++) printf(\"%lld %lld\\n\",s1[i],s2[i]); \n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nmap<int,int> M1,M2;\nint s1[200010],pa[200010];\nstruct edge\n{\n\tint v,next;\n}vs[200010];\nint st[200010],ee,sz[200010],vis[20010];\ninline void addedge(int u,int v)\n{\n\tvs[++ee].v=v;vs[ee].next=st[u];st[u]=ee;\n}\t\ninline void dfs(int rt,int pr)\n{\n\tfor(int i=st[rt];i;i=vs[i].next)\n\t{\n\t\tif(vs[i].v==pr) continue;\n\t\tdfs(vs[i].v,rt);\n\t\tsz[rt]+=sz[vs[i].v];\n\t}\n}\nsigned main()\n{\n\tint n=read();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=read();\n\t\tM1[x]=i; M2[x]=1;\n\t\ts1[i]=x;\n\t}\n\tsort(s1+1,s1+1+n);\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tint id=M1[s1[i]],sz=M2[s1[i]],td=s1[i]+2*sz-n;\t\n\t\tif(td==s1[i]) continue;\t\n\t\tpa[id]=M1[td]; M2[td]+=sz;\n\t}\n\tint rt=0;\n\tfor(int i=1;i<=n;i++) \n\t{\n\t\tif(pa[i]) addedge(pa[i],i),addedge(i,pa[i]);\n\t\telse \n\t\t{ \n\t\t\tif(rt) puts(\"-1\"),exit(0);\n\t\t\telse rt=i;\n\t\t}\n\t}\n\tif(!rt) puts(\"-1\"),exit(0);\n\tfor(int i=1;i<=n;i++) sz[i]=1;\n\tdfs(rt,0);\n\tif(sz[rt]!=n) puts(\"-1\"),exit(0);\n\telse\n\t{ \n\t\tfor(int i=1;i<=n;i++) if(pa[i])\n\t\t\tprintf(\"%lld %lld\\n\",i,pa[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n到所有点距离和最大的一定是叶节点，\n而如果i,j相连，一定满足a_j=a_i+2*sz_i-n。\n由于做到i的时候i的儿子都做过了，那j一定是i的父亲\n然后我们发现还有一个a_i没利用，而这也是所有a_i的最小值 \n我们只要判断一下它是不是重心就行了\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=100002;\nint a[N],fa[N],id[N],i,sz[N],n,x;\nmap<int,int>mp;\nbool cmp(int x,int y){return a[x]>a[y];}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor (i=1;i<=n;i++) scanf(\"%lld\",&a[i]),id[i]=i,mp[a[i]]=i,sz[i]=1;\n\tsort(id+1,id+n+1,cmp);\n\tfor (i=1;i<n;i++){\n\t\tx=id[i];\n\t\tfa[x]=mp[a[x]+2*sz[x]-n];\n\t\tif (!fa[x]) return puts(\"-1\"),0;\n\t\tsz[fa[x]]+=sz[x];\n\t}\n\tfor (i=1;i<n;i++) a[id[n]]-=sz[id[i]];\n\tif (a[id[n]]) return puts(\"-1\"),0;\n\tfor (i=1;i<n;i++) printf(\"%lld %lld\\n\",id[i],fa[id[i]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = pair<lint, int>;\nconst int MAXN = 100005;\n\nvoid my_ass(bool p){\n\tif(!p){\n\t\tputs(\"-1\");\n\t\texit(0);\n\t}\n}\n\nint n;\npi a[MAXN];\nvector<int> gph[MAXN];\nset<int> s[2];\nint left_size[MAXN];\n\nlint get_dist(int x, int p, int d){\n\tlint ret = d;\n\tfor(auto &i : gph[x]){\n\t\tif(i != p){\n\t\t\tret += get_dist(i, x, d + 1);\n\t\t}\n\t}\n\treturn ret;\n}\n\nvector<int> new_event[MAXN];\n\nvoid INSERT(int val, int atleast){\n\tlint v = n + a[val].first - 2 * left_size[val] + 2;\n\tint l = lower_bound(a + 1, a + n + 1, pi(v, -1)) - a;\n\tnew_event[max(l, atleast)].push_back(val);\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<=n; i++){\n\t\tscanf(\"%lld\",&a[i].first);\n\t\ta[i].second = i;\n\t}\n\tsort(a + 1, a + n + 1);\n\tleft_size[1] = n;\n\tINSERT(1, 2);\n\tfor(int i=2; i<=n; i++){\n\t\tfor(auto &j : new_event[i]){\n\t\t\ts[a[j].first % 2].insert(j);\n\t\t}\n\t\tint msk = (a[i].first % 2) ^ (n % 2);\n\t\tmy_ass(!s[msk].empty());\n\t\tmy_ass(a[i].first <= n + a[*s[msk].begin()].first - 2);\t\n\t\tint pidx = *s[msk].begin();\n\t\tgph[pidx].push_back(i);\n\t\tgph[i].push_back(pidx);\n\t\tleft_size[i] = n - (a[i].first - a[pidx].first);\n\t\tleft_size[i] /= 2;\n\t\tleft_size[pidx] -= left_size[i];\n\t\ts[msk].erase(pidx);\n\t\tif(left_size[pidx] != 1) INSERT(pidx, i + 1);\n\t\tif(left_size[i] != 1) INSERT(i, i + 1);\n\t}\n\tmy_ass(s[0].empty());\n\tmy_ass(s[1].empty());\n\tfor(int i=1; i<=1; i++){\n\t\tmy_ass(get_dist(i, -1, 0) == a[i].first); \n\t}\n\tfor(int i=1; i<=n; i++){\n\t\tfor(auto &j : gph[i]){\n\t\t\tif(i < j) printf(\"%d %d\\n\", a[i].second, a[j].second);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <string.h>\nusing namespace std;\n\n#define NMAX 100001\n\npair <long long, int> distances[NMAX];\nlong long v[NMAX], dist[NMAX];\nint bij[NMAX], par[NMAX], cnt[NMAX];\nvector <int> sons[NMAX];\nmap <long long, int> idx;\n\nvoid dfs1(int nod) {\n    cnt[nod] = 1;\n    dist[nod] = 0LL;\n    for (const int x : sons[nod]) {\n        dfs1(x);\n        dist[nod] = 0LL + dist[nod] + dist[x] + (long long)cnt[x];\n        cnt[nod] += cnt[x];\n    }\n}\n\nvoid dfs2(int nod, long long sump, int cntp) {\n    dist[nod] = 0LL + dist[nod] + sump + (long long)cntp;\n    cntp += cnt[nod];\n    for (const int x : sons[nod]) {\n        dfs2(x,  dist[nod] - (dist[x] + (long long)cnt[x]), cntp - cnt[x]);\n    }\n}\n\nbool solve(const int n) {\n    for (int i = 1; i <= n; i++) {\n        idx[v[i]] = i;\n    }\n    for (int i = n; i >= 2; i--) {\n        idx.erase(idx.find(v[i]));\n        cnt[i]++;\n        for (const int son : sons[i]) {\n            cnt[i] += cnt[son];\n        }\n        long long dp = v[i] + 2LL * cnt[i] - (long long)n;\n        if (idx.find(dp) == idx.end()) {\n            return false;\n        }\n        int p = idx[dp];\n        sons[p].push_back(i);\n        par[i] = p;\n    }\n\n    memset(cnt, 0, sizeof(cnt));\n    dfs1(1);\n    dfs2(1, 0LL, 0);\n\n    for (int i = 1; i <= n; i++)\n        if (dist[i] != v[i])\n            return false;\n    return true;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    int n;\n    // ifstream cin(\"code.in\");\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> distances[i].first;\n        distances[i].second = i;\n    }\n    sort(distances + 1, distances + n + 1);\n\n    for (int i = 1; i <= n; i++) {\n        v[i] = distances[i].first;\n        bij[i] = distances[i].second;\n    }\n\n    if (!solve(n)) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n\n    for (int i = 2; i <= n; i++) {\n        cout << bij[par[i]] << \" \" << bij[i] << '\\n';\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <map>\nusing namespace std;\ntypedef long long LL;\nconst int N=100000+10;\nint n,sz[N]; \npair<int,LL> d[N];\nvector<int> g[N];\nbool cmp(pair<int,LL> p1,pair<int,LL> p2){\n    return p1.second>p2.second;\n}\nmap<LL,int> mp;\nvoid prt(int u,int p){\n    for(auto v:g[u]){\n        if(v==p)continue;\n        printf(\"%d %d\\n\", u,v);\n        prt(v,u);\n    }\n}\nint main() {\n    scanf(\"%d\",&n); \n    for(int i=1;i<=n;i++){\n        d[i].first=i; \n        scanf(\"%lld\",&d[i].second);\n        mp[d[i].second]=i;\n        sz[i]=1;\n    }\n    sort(d+1,d+1+n,cmp);\n    for(int i=1;i<n;i++){\n        LL tmp=d[i].second;\n        LL nex=tmp-(n-2*sz[d[i].first]);\n        if(mp[nex]==0||nex==tmp)return !printf(\"-1\\n\");\n        int u=mp[nex];\n        int v=d[i].first;\n        g[u].push_back(v); g[v].push_back(u);\n        sz[u]+=sz[v];\n    }\n    prt(1,1);\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <map>\nusing ll = long long;\nll arr[100005], sum[100005];\nint idx[100005], fa[100005], sz[100005];\nstd::map<ll, int> app;\nint main()\n{\n\t// freopen(\"ARC103-F.in\", \"r\", stdin);\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%lld\", arr + i);\n\t\tapp[arr[i]] = i;\n\t\tidx[i] = i;\n\t\tsz[i] = 1;\n\t}\n\tstd::sort(idx, idx + n, [&] (int x, int y) { return arr[x] > arr[y]; });\n\tfor (int i = 0; i + 1 < n; i++)\n\t{\n\t\tint u = idx[i];\n\t\tll x = n - sz[u] * 2;\n\t\tif (x <= 0 || !app.count(arr[u] - x))\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tfa[u] = app[arr[u] - x];\n\t\tsz[fa[u]] += sz[u];\n\t\tsum[fa[u]] += sum[u] + sz[u];\n\t}\n\tif (sum[idx[n - 1]] != arr[idx[n - 1]])\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i + 1 < n; i++)\n\t\tprintf(\"%d %d\\n\", idx[i] + 1, fa[idx[i]] + 1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// User: woshiluo\n// Email: woshiluo@woshiluo.site\n// Problem link: https://atcoder.jp/contests/arc103/tasks/arc103_d\n// Comment: \n// Why the problem id is 'F', but the link is 'arc103_d'\n// Interesting\n\n#include <cstdio>\n#include <cstdlib>\n\n#include <map>\n#include <algorithm>\n\nconst int N = 1e5 + 1e3;\n\nint n;\nint size[N], father[N];\n\nstruct node{\n\tint id;\n\tlong long d;\n} a[N];\n\nstd::map<long long, int> mp;\n\nvoid wrong() {\n\tprintf( \"-1\\n\" );\n\texit(0);\n}\nbool cmp( node _a, node _b ) { return _a.d < _b.d; }\n\nint main() {\n#ifdef woshiluo\n\tfreopen( \"F.in\", \"r\", stdin );\n\tfreopen( \"F.out\", \"w\", stdout );\n#endif\n\tscanf( \"%d\", &n );\n\tfor( int i = 1; i <= n; i ++ ) {\n\t\tscanf( \"%lld\", &a[i].d );\n\t\ta[i].id = i;\n\t\tsize[i] = 1;\n\t\tmp[ a[i].d ] = i;\n\t}\n\tstd::sort( a + 1, a + n + 1, cmp );\n\tint rt_d, rt;\n\trt = a[1].id; rt_d = a[1].d;\n\tfor( int i = n; i > 1; i -- ) {\n\t\tint fa = mp[ a[i].d + 2LL * size[ a[i].id ] - n ];\n\t\tif( fa == 0 ) {\n\t\t\twrong();\n\t\t\treturn 0;\n\t\t} \n\t\tsize[fa] += size[ a[i].id ];\n\t\tfather[ a[i].id ] = fa;\n\t}\n\tfor( int i = 1; i <= n; i ++ ) {\n\t\tif( i == rt ) \n\t\t\tcontinue;\n\t\t rt_d -= size[i];\n\t}\n\tif( rt_d != 0 ) \n\t\twrong();\n\n\tfor( int i = 1; i <= n; i ++ ) {\n\t\tif( father[i] == 0 ) \n\t\t\tcontinue;\n\t\tprintf( \"%d %d\\n\", father[i], i );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*!|||||||!!!!!!!!!!!!!!!!!!|%%$&&&&&&&&&&&&&|'`......```':'':!;.  ......````':!;..\n||||||||||||!!!!!!!!!!!!!!!!!!!;;;;;!|%$$&&&|'..  ....``'''''::`  ......`````';:.\n||||||||||||||||||||||!!!!!!!!!!;;;;;;;;;;;'`..  ....``'''''':` ........````':'.\n|||||||||%%||%%|||||||||||||||||!;;;;;;;;'....   ....`````'''`..........````''.\n%%%%%%%%%%%%%%%%%%|%||||%%|%%%%|!;!;;;;:.       ....```````'::'`........`````.\n$$$$$$$%%$%%$$$$$%%%%%%%%%%%%%%|!!!!;'.        ....````````';|!!!!:`....```..\n$$$$$$%%%$%%$$$$$%%%%%%%%%%%%%%!;!!;`          ....```````':!!!!!!!!|||;'`.\n$$$%$%|%%||%%%%%%%%%%||%%%%%|%|!;!!:.         ....````````:!;;;!;;!!|%$$$$|:`\n%%%%%||||||||||||||||||||||||||!;!;'`.        ....```````';!!!!!!!!||;';%$&@@%:`.\n|||||||||!!|||||||||||||||||||!;!!:':'.       ..```''```';!!!!!!!||%$$%!` .'|&@@%:`. .\n||||||||!!!|||||||||||||||||||!;!;::;;:`     ..````'''`';;!!!!!!|%%$$$$&&%'   .;&#@!'....\n|||||||!!!!|||||||||||||||||||!;!;:;;;;;'.  ..```''''`:!!!!!;!!|%$$$$&&&&&@$:.   .;&#$:....\n|||!||||!!||||||||||||||||||||!;!::;;;;;;;`..```''':':;!!!!!!!!|%$$&&&&&&@&@#$:.   .`!@$:...\n|||!|||!!!|||||||||||||||||||!!;;:;;;;;;;!!;'`'''':':!;;;;;!!|||||%$&&&&@@@@@@@%`......:$$:...\n||!!||!!!!!||||||||||||||||||!!;;:;;;;;;;!!|!;'''``'':;!!;!!;!|$$$%|%&&&@@@@@@@#&;.......'%|`..\n||!!||!!!!!!|||||||||||||||!!!!;;:;;;;;;:''::::;;!;;;;':!!!!!!!!!%$&$|%&@@@@@@#@@&!`.......`|;..\n||!!|!!!!!!!||||||||||||||||||!;;:;;'````:!%%%%|;:;;:::::;|!!||!!!!|$&$%%&@@&@@##@&!'........;|'.\n|!!!|!!!!!!!|||||||||||||||!!!!;:'```';!!||!!!|!!;;;;:::::;%%||%%|||||%&$%%&@@@@@##&;`` ......'!:.\n|!!!!!!!!!!!!|||||||||||||!!!!!;::;;;;;:;!!!|||||!!;;;;;;;;!%$%|%$$%||||%$$%$&@@@@#@$:``      .`''.\n|!!!||!!!!!!!||||||||||||!!!!!!!;;;:::;;!!|||||||||!!;;;;;;;;|$%|%%$$$%|||%%$$&@&@@#@!.`'.     ...`.\n|!!!||!!!!!!!||||||||||||!!!!!!!;:;;;;;!!!!!|||||||||!!;;;;;;;|$$||%$$&&$%%%%%$&&&&@@@!.``.    ....`.\n|!!!||!!|!!||!|||||||||||!!!!!!!;;;;;;;!!||||||||||!!!;;;;;;;;;|$$||$$$&&&$%%%|%$&&&@@@; .`.    .. ...\n|!!!||!!||!!|!!|||||||||||!!!!!!!;;;;;!!||||||||!!!|||||!!;;;;;;|$$|!$$$&&&&$%%|%$&&&&@$' .`.   ..  ..\n|!!!||!!||!!||!|||||||||||!!!!!!!;;;;;!||||||!!!|||||||||!::'::::!$$!!%$$&&&&$$%!!%$$&&&!. .`.  ..\n|!!!|||!|||!!|!!|||||||||||!!!!!!!;;;!!||||!!|||||||||!;;!!!!!!;;;|$%!|$$$&&&&&$|`.;$$&&|`  .`...\n|!!!!||!||||!!|!!||||||||||!!!!!!!!!;!|||!||||||||!!!!||!:'`.`:;!!!%$%!|$$$&&&&&$;  '%$&$;   ``\n|!!!!||!!||||!!|!!|||||||%||!!!!!!!!!!||||||||||!!!|!:.      ....`';|||!|$$&&&&&@|`  '%&$%:   ..\n|!!!!|||||||||!|||!||||||%%|!!|!!!!!!!||||||||!!!;` ...      ...';||%$|;!%$$&&&&@$:   :$&$$|.  ..\n||!!!||||||||||!!||||||||%%||!!|!!!!!!|||||||!!'..```..``... `:;;;!|%$$|!|%$&&&&&&;   '|$%:!$: ...\n||!;!|||||||||||!!%|||||%%%%|||||!|!!|||||||!'..```.`'```..`!%!!%%%%|$$||!|$$&&&&&;   ';!%: `|%`..\n||!!!!!|||||%||||!!%%||%%%%%%|||||||!||||||;:`.``.`:;;`.':```:':|%%%%$$%|!;|&&&&&$:   ''`!;    :|:.\n|||!!!!!||||%%%|%%||%%|%%%$$%|||%|!||!||||!:`....';;!|%;.```''::!%%%|%$$$|';$&&&&%'  .`  ::       .`''`. .``.\n|||!!!!!||||%%%%%%%|||%%%$$$$%|%%%||%|!||!:```....`;|%$$|'':`'!;!%%%%%%$&@%!%&$$&!. .`.  ``.      .\n|||!!!|!!|%%%%%%%%%%%||%%%$$$%|%%%%||%|!|!!|||||||!;::|$$$%|%%%!!|%%%%%%$&&&$$$$%' .`    ..\n|||!!!||!!|%%%%%%%%%%%%||%%%$$%|%%$%|%%!!|||||||||||||||!!!||||%%%%%%%%%$$$$$$$$&%:.     ..\n||||!!|%|!;!%%%%%%%%%%%%%%|%%%$||%$%%|%|!!||||||||||||||%%%%%%%%$$$%%%%$$$$%%$$$&&&&&&$%'..\n!|||!!!|%|!;!%%%%%%%%%%%%%%%|%%%||%%%||%|!!!||||||||||||%%%%%%%%%%%%%%%$$$$%%$$$$$$$$$$%'\n;!||!!!|%%%|!;|%%%%%%%%%%%%%%%%|%||%%%!!||!!!|%%||||||%%%%%%%%%%%%%%%%$$$$%%%%%$$$$$$$$!`\n;;!||!!!|%%||!;!||%%%%%%%%%%%%%%%||%%%|!!|||!!!|%$%|||%%%%%%%%%%%%%%%%%%%%%%%$$$$$$$$$$;.\n;;;||!!!!|%%||!;;!|%%%%%%%|||||%%|||||||!!||||||||%$%|%%%%%%%%%%%%%%%%$%%%%%$$$$$$$$$$%'\n!!;!|!;;!!|%%|||!;!||%%%||||||||||||||||!!|%||||||||%%||%%%%%%%%%%%%$$$$$$$$$$$$$$$$$$!`\n!!;;!!;;!!!||||||!;;!|||||||||||||||!||||!;;|%%%%%%%|%%%%%%%%%%%%%%%$$$$$$$$$$$$$$$$$$%'\n!!!;;!!;;!!!||||||!!;;!||||||||||||||!||||!!!!%$%|%%%%%%%%%%%%%%%%%%$$$$$$$$$$$$$$$$$$$%'\n!!!!;;!!;;;!!!|||||!!::;|||||!|||||||!!|||||!!!|$$%%%%%%%%%%%%%%%$$$$$$$$$$$$$$$$$$$$&&&$:\n;;!!!!;!;;;;!!!|||||!!;::;!|!!!!||||||!!|||%%|!!!%&%%%%%%%%%%%%%%$$$$$$$$$$$$$$$$$$$$$&$!`\n|!!!!;!;;;;::;!!!||!||!;;;;;!!!!!!|||||!!|||%%|||!|$&$%%%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$%!`\n:::;!;;;;::;::;;!!|||!!!!;;;;;!!!!!!||||!!|||%$%%||||$&$%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$$%'\n;;;;;!!!!!;:::;;:;!!||!!!!!;;;;;!!!!!!||||!!||%$%%%%%%%%$$%%%$$$$$$$$$$$$$$$$$$$$$$$$$$$$:\n;;;;;;;;;!!!;::;;;:;!!|||||!!!!;;;;!!!!!|||||||%$$%%%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$$$$$&$!.\n;;;;;;;;:::::::::;;;;;;!||!!!!!!!!;;;!!!!!||||||||$$%%%%%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$$&!.\n;;;;;;;::;;:::;;;;:;;;;;;;;!!!|!!!!!!;;;!!!!!|%%||||%$%%%%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$&%`\n;;;;;;;:::;;::;;;;;;;;;;;;::;!!!!!!!!|!;!!!!!!!|%%%%%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&:\n;;;;;;;::;::;:;;;;;;;;;!!!!!!!;;!!|||||!!!|!!!!!!!|%%%%%%%%%%%%%%%%$$$$$$$$$$$$$$$$$$$$&&|`\n;;;;;;;::;;;::;;;;;;;;;;!!!!!!!!!||||||||;!!|||||||||%%%%%%%%%%%%%%%$$$$$$$$$$$$$$$$$$$$&&!.\n;;;;;;;::;;;;::;;;;;;;;;;!!!!!!!!|||||||||;;;!!|||||||||%%%%%%%%%%%%%%%%$$$$$$$$$$$$$$$$$&|`\n!;;;;;;;::;;;:;;;;;;;;;;;!!!!!!!!!|||||||%!;;;;;!||||||||||%%%%%%%%%%%%%%%$$$$$$$$$$$$$$$$!.\n;!;;;;;;::;;;:;;;;::;;;;;!!!!!!!!!|||||||%%!;;;;;;!!!|||||||%%%%%%%%%%%%%%%%%%$$$$$$$$$$&|`\n:;!!;;;;:::;;;:;;;:::;;;;;!!!!!!!!||||||||$|;;;;;;;;!!!!||||||||%%%%%%%%%%%%%%%%%%%$$$|'\n::;!!;;;::::;;:;;;;::;;;;;;!!!!!!!!|||||||$$!;;;;;;;;;;;!!!!!||||||%%%%%%%%%%%%|!:`.\n:::;!!;;;:::;;;;;;;:::;;;;;!!!!!!!!||%||||%&%!;;;;;;;;;;;;!!!!!!!!!!!|!;:`.\n::::;!!!;::::;::;;;::::;;;;;!!!!!!!!|%%|||!%&%;;;;;;;;;;;;;;;;;;;;;%|`\n:::::;!!!;:::::::;;:::::;;;;!!!!!!!!||%%%%!;%$|;;;;;;;;;;;;;;;;;;%@@$:\n::::::;!!!:::::':;;::::::;;;;;!!|!!!||%$%%|!;%$!;;;;;;;;;;;;;;;;|$&@@|`\n:::::':;;!;::::'';;;::::::;;;;!!!|!!!||%$%%|;;%%;;;;;;;;;;;;;;!||%$&#@|`\n::::::':;;;:::''':;;:::::::;;;!!!||!!!|%$$%%|;;||;;;;;;;;;;;!||||%%%&#@%'\n:::::::':;;;::'. ';;::::::::;;;!!!|!!!||%$$$%;;;||;;;;;;;;;|%%|||||%%&@@*/\n#include <bits/stdc++.h>\nusing namespace std;\n\nmap<long long,int> dy;\nint n;\nlong long d[100005];\nint sz[100005];\nvector<int> son[100005];\nlong long sum=0;\nint dep[100005];\nvector<pair<int,int> > ans;\n\nvoid dfs(int now,int lst){\n\tdep[now]=dep[lst]+1;\n\tsum+=dep[now];\n\tfor(int i=0;i<son[now].size();i++){\n\t\tint to=son[now][i];\n\t\tif(to==lst){\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(to,now);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",d+i);\n\t\tdy[d[i]]=i;\n\t\tsz[i]=1;\n\t}\n\twhile(dy.size()>1){\n\t\tpair<long long,int> X=*dy.rbegin();\n\t\tint x=X.second;\n\t\tlong long val=X.first;\n\t\tdy.erase(val);\n\t\tlong long tov=val-n+2*sz[x];\n\t\tif(!dy.count(tov)){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}else{\n\t\t\tint ff=dy[tov];\n\t\t\tson[ff].push_back(x);\n\t\t\tson[x].push_back(ff);\n\t\t\tsz[ff]+=sz[x];\n\t\t\tans.emplace_back(ff,x);\n\t\t}\n\t}\n\tdep[0]=-1;\n\tdfs(dy.begin()->second,0);\n\tif(sum!=dy.begin()->first){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<n-1;i++){\n\t\tprintf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//tourist\n#include<bits/stdc++.h>\n#define ll long long\n#define pii pair<int,int> \n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fi first\n#define se second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nmap<ll,int> ret;\nint n;\ninline void die(){\n    puts(\"-1\");\n    exit(0);\n}\nint main(){\n    cin>>n;\n    vector<ll> d(n);\n    for(int i=0;i<n;i++){\n        cin>>d[i];\n        ret[d[i]]=i;\n    }\n    vector<int> siz(n,1);\n    vector<pii> ans;\n    for(int i=0;i<n-1;i++){\n        auto it=ret.rbegin();\n        int now=it->se;\n        ll need=d[now]-n+2*siz[now];\n        if(!ret.count(need) || ret[need]==now)\n            die();\n        int par=ret[need];\n        ans.pb(mp(now,par));\n        siz[par]+=siz[now];\n        ret.erase(--ret.end());\n    }\n    vector<ll> real_dist(n,-1);\n    real_dist[0]=0;\n    vector<vector<int> > g(n);\n    for(int i=0;i<ans.size();i++){\n        g[ans[i].fi].pb(ans[i].se);\n        g[ans[i].se].pb(ans[i].fi);\n    }\n    vector<int> que(1,0);//和queue过不去 \n    for(int b=0;b<que.size();b++){\n        for(int j=0;j<g[que[b]].size();j++){\n            if(real_dist[g[que[b]][j]]==-1){\n                que.pb(g[que[b]][j]);\n                real_dist[g[que[b]][j]]=real_dist[que[b]]+1;\n            }\n        }\n    }\n    if(accumulate(real_dist.begin(),real_dist.end(),(ll)0)!=d[0])\n        die();\n    for(int i=0;i<ans.size();i++)\n        cout<<ans[i].fi+1<<\" \"<<ans[i].se+1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+100;\ntypedef long long ll;\nint n,u[N],v[N],sz[N],cnt,RT;\nint head[N],to[N],nxt[N],tot;\nll wd[N];\n\nstruct P{ll v;int id;}t[N];\ninline bool cmp(const P&A,const P&B)\n{return B.v<A.v;}\n\nmap<ll,int>d;\n\ninline void lk(int u,int v)\n{to[++tot]=v;nxt[tot]=head[u];head[u]=tot;}\n\nvoid dfs(int x,int dep)\n{\n\twd[RT]+=dep;\n\tfor(int i=head[x];i;i=nxt[i]) dfs(to[i],dep+1);\n}\n\nvoid dfss(int x){\n  for(int i=head[x];i;i=nxt[i]) \n   {wd[to[i]]=wd[x]+n-(sz[to[i]]<<1);dfss(to[i]);}\n}\n\nint main(){\n\tint i,j;ll dr;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i){\n\t\tscanf(\"%lld\",&t[i].v);\n\t\td[t[i].v]=i;t[i].id=i;\n\t\tsz[i]=1;\n\t}\n\tsort(t+1,t+n+1,cmp);\n\tfor(i=1;i<n;++i){\n\t\tdr=t[i].v-n+(sz[t[i].id]<<1);\n\t\tif(dr<0 || (sz[t[i].id]<<1)==n || (!d[dr])) {puts(\"-1\");return 0;}\n\t\tj=d[dr];u[++cnt]=j;v[cnt]=t[i].id;\n\t\tsz[j]+=sz[t[i].id];\n\t}\n\tfor(i=1;i<n;++i) lk(u[i],v[i]);\n\tRT=t[n].id;\n\tdfs(RT,0);dfss(RT);\n\tfor(i=1;i<=n;++i){\n\t\tif(wd[t[i].id]!=t[i].v) {puts(\"-1\");return 0;}\n\t}\n\tfor(i=1;i<n;++i) printf(\"%d %d\\n\",u[i],v[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 2e5 + 10;\n\nint N, rnk[MAX_N], siz[MAX_N], pa[MAX_N], depth[MAX_N];\nll D[MAX_N];\nmap<ll, int> mp;\n\nint main() {\n    scanf(\"%d\", &N);\n    for (int i = 1; i <= N; i++) scanf(\"%lld\", &D[i]), mp[D[i]] = i;\n    for (int i = 1; i <= N; i++) rnk[i] = i, siz[i] = 1;\n    sort(rnk + 1, rnk + N + 1, [](int a, int b) { return D[a] > D[b]; });\n    for (int i = 1; i < N; i++) {\n        int x = rnk[i];\n        ll pd = D[x] + 2 * siz[x] - N;\n        if (siz[x] * 2 < N && mp.count(pd)) {\n            pa[x] = mp[pd];\n            siz[pa[x]] += siz[x];\n        } else {\n            printf(\"-1\\n\");\n            return 0;\n        }\n    }\n    int sum = 0;\n    for (int i = N - 1; i; i--) {\n        int x = rnk[i];\n        depth[x] = depth[pa[x]] + 1;\n        sum += depth[x];\n    }\n    if (sum != D[rnk[N]]) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n    for (int i = 1; i < N; i++) {\n        int x = rnk[i];\n        printf(\"%d %d\\n\", x, pa[x]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = 1e18;\nconst ll MOD = 1000000007;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\nvii child(100010);\nvi depth(100010);\nbitset<100010> used;\n\nint dfs(int now, int par, int dep) {\n  int res = 1;\n  depth[now] = dep;\n  used[now] = true;\n  rep (i, child[now].size()) {\n    int nex = child[now][i];\n    if (nex == par || used[nex]) {\n      continue;\n    }\n    res += dfs(nex, now, dep + 1);\n  }\n  return res;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  vector<pll> d(n);\n  map<ll, int> mp;\n  rep (i, n) {\n    cin >> d[i].first;\n    d[i].second = i;\n    mp[d[i].first] = i;\n  }\n  sort(all(d));\n  reverse(all(d));\n  vi p(n);\n  vi num(n, 1);\n  int root = d.back().second;\n  p[root] = -1;\n  num[root] = n;\n  rep (i, n - 1) {\n    int v = d[i].second;\n    ll su = d[i].first + 2 * num[v] - n;\n    int u;\n    try {\n      u = mp.at(su);\n    }\n    catch (...) {\n      cout << -2 << endl;\n      return 0;\n    }\n    p[v] = u;\n    child[u].push_back(v);\n    num[u] += num[v];\n  }\n  if (dfs(root, -1, 0) != n) {\n    cout << -1 << endl;\n    return 0;\n  }\n  ll sr = 0;\n  rep (i, n) {\n    sr += depth[i];\n  }\n  if (sr != d.back().first) {\n    cout << -1 << endl;\n    return 0;\n  }\n  rep (i, n) {\n    if (p[i] == -1) {\n      continue;\n    }\n    cout << i + 1 << \" \" << p[i] + 1 << endl;\n  }\n}\n  \n  \n"
  },
  {
    "language": "C++",
    "code": "// User: woshiluo\n// Email: woshiluo@woshiluo.site\n// Problem link: https://atcoder.jp/contests/arc103/tasks/arc103_d\n// Comment: \n// Why the problem id is 'F', but the link is 'arc103_d'\n// Interesting\n\n#include <cstdio>\n#include <cstdlib>\n\n#include <map>\n#include <algorithm>\n\nconst int N = 1e5 + 1e3;\n\nint n;\nint size[N], father[N];\n\nstruct node{\n\tint id, d;\n} a[N];\n\nstd::map<long long, int> mp;\n\nvoid wrong() {\n\tprintf( \"-1\\n\" );\n\texit(0);\n}\nbool cmp( node _a, node _b ) { return _a.d < _b.id; }\n\nint main() {\n#ifdef woshiluo\n\tfreopen( \"F.in\", \"r\", stdin );\n\tfreopen( \"F.out\", \"w\", stdout );\n#endif\n\tscanf( \"%d\", &n );\n\tfor( int i = 1; i <= n; i ++ ) {\n\t\tscanf( \"%d\", &a[i].d );\n\t\ta[i].id = i;\n\t\tsize[i] = 1;\n\t\tmp[ a[i].d ] = i;\n\t}\n\tstd::sort( a + 1, a + n + 1, cmp );\n\tint rt_d, rt;\n\trt = rt_d = 0;\n\tfor( int i = n; i >= 1; i -- ) {\n\t\tint fa = mp[ a[i].d + 2 * size[i] - n ];\n\t\tif( fa == 0 && rt == 0 ) \n\t\t\trt = i, rt_d = a[i].d;\n\t\telse if( fa == 0 ) {\n\t\t\twrong();\n\t\t\treturn 0;\n\t\t} \n\t\tsize[fa] += size[i];\n\t\tfather[i] = fa;\n\t}\n\tfor( int i = 1; i <= n; i ++ ) {\n\t\tif( i == rt ) \n\t\t\tcontinue;\n\t\t rt_d -= size[i];\n\t}\n\tif( rt_d != 0 ) \n\t\twrong();\n\n\tfor( int i = 1; i <= n; i ++ ) {\n\t\tif( i == rt ) \n\t\t\tcontinue;\n\t\tprintf( \"%d %d\\n\", father[i], i );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> v[100010];\nint n,id[100010],l,r,mid,ans,siz[100010];\nlong long dis[100010],t;\n\nbool cmp(int x,int y) {return dis[x]>dis[y];}\n\nlong long dfs(int x)\n{\n\tlong long ans=0;\n\tfor (int i=0,sz=v[x].size(); i<sz; i++) ans+=dfs(v[x][i])+siz[v[x][i]];\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1; i<=n; i++) scanf(\"%lld\",&dis[i]),id[i]=i;\n\tsort(id+1,id+1+n,cmp);\n\tfor (int i=1; i<=n; i++) siz[i]=1;\n\tfor (int I=1,i; I<n; I++)\n\t{\n\t\ti=id[I],t=dis[i]-n+2*siz[i],l=I+1,r=n,ans=-1;\n\t\twhile (l<=r) {mid=(l+r)>>1; if (dis[id[mid]]<=t) r=mid-1,ans=mid; else l=mid+1;}\n\t\tif (ans==-1||dis[id[ans]]!=t) return puts(\"-1\"),0;\n\t\tv[id[ans]].push_back(i),siz[id[ans]]+=siz[i];\n\t}\n\tif (dfs(id[n])!=dis[id[n]]) return puts(\"-1\"),0;\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=0,sz=v[i].size(); j<sz; j++) printf(\"%d %d\\n\",i,v[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint sz[100005],par[100005];\npair<long long,int> a[100005];\nmap<long long,int> inv;\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&a[i].first);\n\t\ta[i].second=i;\n\t\tsz[i]=1;\n\t\tinv[a[i].first]=i;\n\t}\n\tsort(a+1,a+n+1);\n\tfor (int i=n;i>1;i--)\n\t{\n\t\tif (2*sz[a[i].second]>=n)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint p=inv[a[i].first-n+2*sz[a[i].second]];\n\t\tif (!p)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsz[p]+=sz[a[i].second];\n\t\tpar[a[i].second]=p;\n\t}\n\tfor (int i=2;i<=n;i++)\n\ta[1].first-=sz[a[i].second];\n\tif (a[1].first)\n\tprintf(\"-1\");\n\telse\n\t{\n\t\tfor (int i=2;i<=n;i++)\n\t\tprintf(\"%d %d\\n\",par[a[i].second],a[i].second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <assert.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 100005;\n\nint n;\nint cnt[MAXN];\nint ord[MAXN];\n\nll d[MAXN];\n\nvector<pair<int,int> > e;\n\nbool cmp(const int &a,const int &b)\n{\n\treturn d[a] < d[b];\n}\n\nint search(ll v)\n{\n\tint low = 1,high = n;\n\twhile (low < high)\n\t{\n\t\tint mid = (low + high) >> 1;\n\t\tif (d[ord[mid]] >= v)\n\t\t\thigh = mid;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\tif (d[ord[low]] == v)\n\t\treturn low;\n\treturn -1;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 1;i <= n;i++)\n\t{\n\t\tcin >> d[i];\n\t\tcnt[i] = 1;\n\t\tord[i] = i;\n\t}\n\tsort(ord + 1,ord + n + 1,cmp);\n\tfor (int i = n;i >= 2;i--)\n\t{\n\t\tint pos = search(d[ord[i]] - (n - cnt[ord[i]]) + cnt[ord[i]]);\n\t\tif (pos == -1 || pos >= i)\n\t\t{\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\te.push_back(make_pair(ord[i],ord[pos]));\n\t\tcnt[ord[pos]] += cnt[ord[i]];\n\t}\n\tfor (int i = 0;i < e.size();i++)\n\t\tcout << e[i].first << ' ' << e[i].second << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\nconst int N = 2e5;\nint n, cnt;\nint fa[N], ff[N];\nLL di[N], siz[N];\nmap <LL, int> val;\npair <int, int> edges[N];\nint ord[N];\nint get_f(int t)\n{\n    if (ff[t] == t) return t;\n    else return ff[t] = get_f(ff[t]);\n}\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; ++ i) scanf(\"%lld\", &di[i]);\n    for (int i = 1; i <= n; ++ i) ord[i] = i, val[di[i]] = i, ff[i] = i;\n    sort(ord + 1, ord + n + 1, [=](int a, int b) {return di[a] > di[b];});\n    for (int i = 1; i < n; ++ i)\n    {\n        int p = ord[i];\n        siz[p] += 1;\n        LL q = di[p] + siz[p] * 2 - n;\n        if (!val.count(q)) {puts(\"-1\"); return 0;}\n        fa[p] = val[q];\n        if (get_f(p) == get_f(fa[p])) {puts(\"-1\"); return 0;}\n        ff[get_f(p)] = get_f(fa[p]);\n        siz[fa[p]] += siz[p];\n        edges[i] = make_pair(p, fa[p]);\n    }\n    for (int i = 1; i < n; ++ i) printf(\"%d %d\\n\", edges[i].first, edges[i].second);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <atcoder/all>\nusing namespace std;\n//using namespace atcoder;\n#define ll long long\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, n+1)\n#define rrep(i, n) for (int i = ((int)(n)-1); i >= 0; --i)\n#define whole(x) (x).begin(),(x).end()\n#define rwhole(x) (x).rbegin(), (x).rend()\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define P pair<ll, ll>\n#define debug(var) cerr << \"[\" << #var << \"] \" << var << '\\n'\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\n#define vi vector<int>\n#define vl vector<ll>\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define pr(s) cout << (s) << '\\n'\nconst ll mod = 1000000007;\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\nconst int INF = 1001001001;\nconst ll INFll = 1E+18;\nconst int MAXN = 100005;\n\nll par[MAXN];\nll child[MAXN];\nvector<int> to[MAXN];\nll dist[MAXN];\n\nvoid dfs(int v, int p=-1) {\n    for (int e: to[v]) {\n        if (e==p) continue;\n        dist[e] = dist[v] + 1;\n        dfs(e, v);\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    ll n;\n    cin >> n;\n    vector<P> d(n);\n    rep(i, n) {\n        cin >> d[i].fi;\n        d[i].se = i;\n    }\n    sort(whole(d));\n\n    rrep(i, n) {\n        if (i==0) continue;\n        ll x = d[i].fi - n+2 + child[i]*2;\n        if (x==d[i].fi) {\n            pr(-1);\n            return 0;\n        }\n        //debug(d[i].fi);\n        //debug(x);\n        auto it = lower_bound(whole(d), P(x, 0));\n        if (it==d.end() || it->fi!=x) {\n            pr(-1);\n            return 0;\n        }\n        par[i] = it-d.begin();\n        child[par[i]] += child[i]+1; \n        to[i].pb(par[i]);\n        to[par[i]].pb(i);\n    }\n    ll sum = 0;\n    dfs(0, -1);\n    rep(i, n) {\n        sum += dist[i];\n    }\n    if (sum!=d[0].fi) {\n        pr(-1);\n        return 0;\n    }\n\n    rep(i, n) {\n        if (i==0) continue;\n        ll u = d[i].se + 1;\n        ll v = d[par[i]].se + 1;\n        cout << u << \" \" << v << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define ll long long\n#define ld long double\n#define PB push_back\n#define lc 2 * v\n#define rc 2 * v + 1\n#define mid (s + e) / 2\n#define pii pair <int , int>\n#define pll pair <long long , long long>\n#define FAST ios::sync_with_stdio(false);cin.tie(0);\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,avx,avx2\")\n\nconst ll maxn = 3e5 + 20 , N = 60000 + 20 , mod = 1e9 + 7 , INF = 1e9 + 1 , lg = 32;\n\nll dis , d[maxn] , sz[maxn] , root;\nvector <int> edges[maxn];\nmap <ll , int> mp;\nset <ll> s;\n\nvoid dfs(int v , int par, int h) {\n    dis += h;\n    for (auto u : edges[v]) {\n        if(u != par) {\n            dfs(u , v , h + 1);\n        }\n    }\n}\n\nvoid sfd(int v , int par) {\n    for (auto u : edges[v]) {\n        if(u != par) {\n            cout << v << ' ' << u << '\\n';\n            sfd(u , v);\n        }\n    }\n}\n\nint main() {\n    FAST\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; ++i) {\n        cin >> d[i];\n        mp[d[i]] = i;\n        s.insert(d[i]);\n    }\n    // sort(D , D + n);\n    fill(sz , sz + maxn , 1);\n\n    while(s.size() > 1) {\n        ll di = *s.rbegin(); s.erase(di);\n        ll v = mp[di];\n        ll val_par = di - n + (2 * (sz[v]));\n        ll par = mp[val_par];\n\n        if(par == 0) {\n            cout << -1 << '\\n';\n            return 0;\n        }\n        else {\n            edges[v].PB(par);\n            edges[par].PB(v);\n            sz[par] += sz[v];\n        }\n\n    }\n    dfs(1 , -1 , 0);\n    // cout << dis << ' ' << d[1] << endl;\n    // sfd(1 , -1);\n    if(dis == d[1]) {\n        sfd(1 , -1);\n    }\n    else {\n        cout << -1 << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, sz[100010];\nlong long d[100010];\nmap<long long, int> mp;\nvector<int> e[100010];\n\nlong long dfs(int x, int f)\n{\n    long long ans = 0;\n    for (int y : e[x])\n    {\n        if (y == f) continue;\n        ans += dfs(y, x) + sz[y];\n    }\n    return ans;\n}\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++)\n    {\n        scanf(\"%lld\", &d[i]);\n        mp[d[i]] = i;\n        sz[i] = 1;\n    }\n    for (int i = 1; i < n; i++)\n    {\n        auto it = mp.rbegin();\n        long long hh = it->first + 2 * sz[it->second] - n;\n        // printf(\"%d %d\\n\", mp[hh], it->second);\n        if (!mp.count(hh) || hh == it->first)\n        {\n            puts(\"-1\");\n            return 0;\n        }\n        // ans.emplace_back(mp[hh], it->second);\n        e[mp[hh]].push_back(it->second);\n        e[it->second].push_back(mp[hh]);\n        sz[mp[hh]] += sz[it->second];\n        mp.erase(it->first);\n    }\n    if (dfs(mp.begin()->second, 0) == mp.begin()->first)\n    {\n        for (int i = 1; i <= n; i++)\n            for (int j : e[i])\n                if (j > i)\n                    printf(\"%d %d\\n\", i, j);\n    }\n    else puts(\"-1\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <climits>\n#include <set>\n#include <algorithm>\n#include <unordered_map>\n#include <queue>\n#include <iomanip>\n#include <map>\n#include <utility>\n#include <numeric>\n\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define P pair<int, int>\n#define debug(x) cout << #x << \": \" << x << \", \"\n#define debugln(x) cout << #x << \": \" << x << '\\n'\n\nusing namespace std;\nusing ll = long long;\nconst int mod = 1e9+7;\n\nvector<P> ans;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n; cin >> n;\n  vector<ll> vec(n);\n  unordered_map<ll, int> mp;\n\n  rep(i, n) {\n    cin >> vec.at(i);\n    mp[vec.at(i)] = i+1;\n  }\n\n  vector<bool> used(n);\n\n  vector<int> graph[n+1];\n\n  sort(vec.rbegin(), vec.rend());\n  rep(i, n) {\n    ll a = vec.at(i);\n    int s = mp[a];\n    if (used.at(s-1)) continue;\n    int d = n-2;\n    while (d > 0 && mp[a-d] > 0) {\n      used.at(s-1) = true;\n      int t = mp[a-d];\n      //debug(s); debugln(t);\n      ans.push_back(P(s, t));\n      graph[s].push_back(t);\n      graph[t].push_back(s);\n      a = a-d;\n      d -= 2;\n      s = t;\n      //debug(a); debugln(d);\n    }\n  }\n\n  vector<int> distance(n);\n  rep(i, n) {\n    distance.at(i) = INT_MAX;\n  }\n  priority_queue<P, vector<P>, greater<P>> que;\n  que.push(P(0, 1));\n  while (!que.empty()) {\n    P pa = que.top(); que.pop();\n    int pos = pa.second;\n    int d = pa.first;\n    distance.at(pos-1) = d;\n    for(auto e : graph[pos]) {\n      if (distance.at(e-1) == INT_MAX) {\n        que.push(P(d+1, e));\n        //debug(d+1);debugln(e);\n      }\n    }\n  }\n\n  ll sum = 0;\n  rep(i, n) {\n    if (distance.at(i) == INT_MAX) {\n      cout << -1 << endl;\n      return 0;\n    }\n    sum += distance.at(i);\n  }\n  if (mp[sum] != 1) {\n    cout << -1 << endl;\n    return 0;\n  }\n\n  for(auto e: ans) {\n    cout << e.first << ' ' << e.second << '\\n';\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\n\ntypedef pair < db, db > pdd;\ntypedef pair < db, ld > pdl;\ntypedef pair < ld, db > pld;\ntypedef pair < ld, ld > ldp;\n\ntypedef pair < ll, ll > pll;\ntypedef pair < int, ll > pil;\ntypedef pair < ll, int > pli;\ntypedef pair < int, int > pii;\n\n#define F first\n#define S second\n\n#define en end()\n#define bg begin()\n\n#define rev reverse\n#define mp make_pair\n#define pb push_back\n\n#define y1 y1234567890\n#define um unordered_map\n\n#define all(x) x.bg, x.en\n#define sz(x) (int)x.size()\n#define len(x) (int)strlen(x)\n\n#define sqr(x) ((x + 0ll) * (x))\n#define sqrd(x) ((x + 0.0) * (x))\n\n#define forn(i, n) for (int i = 1; i <= n; i++)\n\nconst ll inf = (ll)1e18;\nconst ll mod = (ll)1e9 + 7;\n\nconst db eps = (db)1e-9;\nconst db pi = acos(-1.0);\n\nconst int dx[] = {0, 0, 1, 0, -1};\nconst int dy[] = {0, 1, 0, -1, 0};\n\nconst int N = 100500;\n\nll d[N];\nint n, p[N], dp[N];\nvector < int > g[N];\nmap < ll, int > pos;\n\ninline bool cmp(int i, int j) {\n\treturn d[i] < d[j];\n}\n\nll sum;\n\nvoid dfs(int v, int pr = -1, int dist = 0) {\n\tsum += dist;\n\tfor (auto to : g[v]) {\n\t\tif (to != pr)\n\t\t\tdfs(to, v, dist + 1);\n\t}\n}\n\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\t//freopen(\".err\", \"w\", stderr);\n\n\t//srand(time(NULL));\n\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tios_base::sync_with_stdio(false);\n\n\t//cout << setprecision(10) << fixed;\n\t\n\tcin >> n;\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> d[i];\n\t\tp[i] = i;\n\t}\n\n\tsort(p + 1, p + 1 + n, &cmp);\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tpos[d[p[i]]] = i;\n\t\tdp[p[i]] = 1;\n\t}\n\n\tfor (int i = n; i > 1; i--) {\n\t\tll val = d[p[i]] + dp[p[i]] + dp[p[i]] - n;\n\t\tif (!pos.count(val) || val >= d[p[i]]) {\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\tint pr = pos[val];\n\t\tdp[p[pr]] += dp[p[i]];\n\t\tg[p[pr]].pb(p[i]);\n\t\tg[p[i]].pb(p[pr]);\n\t}\n\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (auto j : g[i])\n\t\t\tif (i < j)\n\t\t\t\tcout << i << \" \" << j << \"\\n\";\n\t}\n\t\n\t//cerr << (clock() + 0.0) / CLOCKS_PER_SEC;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\n\nconst int MAXN = 1e5 + 5;\nint n, par[MAXN];\nll d, sz[MAXN];\nmap <ll, int> mp;\n\nint main()\n{\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tvector <pair<ll,int>> v;\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> d; sz[i] = 1ll;\n\t\tmp[d] = i;\n\t\tv.push_back({-d, i});\n\t}\n\tsort(v.begin(), v.end());\n\tfor(int i = 0; i < n - 1; i++){\n\t\td = -v[i].first;\n\t\tint ind = v[i].second;\n\t\tll dpar = max(0ll, d - (n - (2ll * sz[ind])));\n\t\tif(!mp[dpar] || mp[dpar] == ind){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tpar[ind] = mp[dpar];\n\t\tsz[par[ind]] += sz[ind];\n\t}\n\tfor(int i = 0; i < n - 1; i++){\n\t\tcout << par[v[i].second] << \" \" << v[i].second << '\\n';\n\t}\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#include <queue>\n#include <vector>\n#define PB push_back\n#define MP make_pair\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=1e5+10;\nstruct node {\n\tint id; ll d;\n\tnode(int id=0,ll d=0): id(id),d(d) {}\n\tfriend bool operator <(node A,node B) { return A.d<B.d; }\n};\npriority_queue<node> que;\nmap<ll,int> mp;\nint n,sz[N];\nll d[N];\nvector< pair<int,int> > E;\nvector<int> son[N];\nll dfs(int u) {\n\tll tot=0;\n\tfor(int i=0;i<son[u].size();++i) tot+=dfs(son[u][i])+sz[son[u][i]];\n\treturn tot;\n}\nint main() {\n\trd(n);\n\tfor(int i=1;i<=n;++i) {\n\t\trd(d[i]),mp[d[i]]=i;\n\t\tque.push(node(i,d[i]));\n\t\tsz[i]=1;\n\t}\n\twhile(que.size()>1) {\n\t\tint u=que.top().id; que.pop();\n\t\tmp.erase(d[u]);\n\t\tll t=d[u]-(n-sz[u]*2ll);\n\t\tif(!mp.count(t)) {\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint f=mp[t];\n\t\tE.PB(MP(f,u));\n\t\tson[f].PB(u);\n\t\tsz[f]+=sz[u];\n\t}\n\tint rt=que.top().id;\n\tif(dfs(rt)!=d[rt]) {\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<E.size();++i) printf(\"%d %d\\n\",E[i].first,E[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<iomanip>\n#include<cstring>\n#include<algorithm>\n#include<ctime>\n#define int long long\nusing namespace std;\ninline int read()\n{\n\tint kkk=0,x=1;\n\tchar c=getchar();\n\twhile((c<'0' || c>'9') && c!='-')\n\t\tc=getchar();\n\tif(c=='-')\n\t\tc=getchar(),x=-1;\n\twhile(c>='0' && c<='9')\n\t\tkkk=(kkk<<3)+(kkk<<1)+(c-'0'),c=getchar();\n\treturn kkk*x;\n}\nint n;\nstruct sb\n{\n\tint sum,id,size,fa;\n}a[100001];\ninline int cmp(sb x,sb y)\n{\n\treturn x.sum>y.sum;\n}\ninline int find(int V)\n{\n\tint l=1,r=n,bck=0;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)/2;\n\t\tif(a[mid].sum>=V)\n\t\t\tbck=mid,l=mid+1;\n\t\telse\n\t\t\tr=mid-1;\n\t}\n\treturn bck;\n}\nsigned main()\n{\n\tn=read();\n\tfor(register int i=1;i<=n;++i)\n\t{\n\t\ta[i].id=i;\n\t\ta[i].sum=read();\n\t\ta[i].size=1;\n\t}\n\tsort(a+1,a+n+1,cmp);\n\ta[0].sum=0x7f7f7f7f7f7f7f7f;\n\tfor(register int i=1;i<n;++i)\n\t{\n\t\tint sum=a[i].sum+a[i].size-(n-a[i].size);\n\t\tif(sum>=a[i].sum)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint zone=find(sum);\n\t\tif(a[zone].sum!=sum)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\ta[zone].size+=a[i].size;\n\t\ta[i].fa=zone;\n\t}\n\tfor(register int i=1;i<n;++i)\n\t\tprintf(\"%lld %lld\\n\",a[i].id,a[a[i].fa].id);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid err() {\n  cout << -1 << endl;\n  exit(0);\n}\nvoid dfs (int crr, int dpt, vector<vector<int>>& grh, long long& cnt) {\n  cnt += dpt;\n  for (int nxt : grh[crr]) {\n    dfs(nxt, dpt + 1, grh, cnt);\n  }\n}\nint main() {\n  int n;\n  cin >> n;\n  vector<long long> d(n);\n  map<long long, int> mp;\n  for (int i = 0; i < n; i++) {\n    cin >> d[i];\n    mp[d[i]] = i;\n  }\n  sort(d.begin(), d.end());\n  vector<long long> sz(n, 1);\n  vector<int> prt(n);\n  vector<vector<int>> grh(n);\n  vector<pair<int, int>> edg;\n  for (auto it = prev(d.end()); it != d.begin(); it--) {\n    auto i = mp[*it];\n    long long prtv = *it - n + 2LL * sz[i];\n    auto jt = lower_bound(d.begin(), d.end(), prtv);\n    if (jt == d.end() || *jt != prtv) err();\n    auto p = mp[*jt];\n    prt[i] = p;\n    grh[p].push_back(i);\n    if (i == prt[i]) err();\n    sz[prt[i]] += sz[i];\n    edg.emplace_back(min(i, prt[i]), max(i, prt[i]));\n  }\n  long long cnt = 0;\n  int rt = mp[d[0]];\n  dfs(rt, 0, grh, cnt);\n  if (d[0] != cnt) err();\n  sort(edg.begin(), edg.end());\n  for (auto const & e : edg) {\n    cout << e.first + 1 << ' ' << e.second + 1 << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntemplate <typename T> void read(T& t){ cin >> t; }\ntemplate <typename T, typename ... U> void read(T& t, U& ... u){ read(t); read(u ...); }\ntemplate <typename T> void write(T t){ cout << t; }\ntemplate <typename T, typename ... U> void write(T t, U ... u){ write(t); write(u ...); }\n//#define int long long\n#define FAST ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)\n#define size(x) (int)x.size()\n#define all(x) x.begin(),x.end()\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define ROF(i,b,a) for(int i=b; i>=a; --i)\n#define LL long long\nusing pii = pair<int,int>;\nconst int INF = 2e9;\nconst int NN = 1e5 + 3;\n\nint n;\nset<LL> s;\nmap<LL,int> id;\nmap<int,LL> dist, dist2;\nint sz[NN];\nvector<pii> e;\nvector<int> adj[NN];\n\nvoid checkConn(int u, set<int> &visited){\n\tvisited.insert(u);\n\tfor(int v: adj[u]) if(!visited.count(v)) checkConn(v, visited);\n}\n\nLL getDistSum(int u, int prv, int d){\n\tLL sum = 0;\n\tsum += d;\n\tfor(int v: adj[u]) if(v != prv) sum += getDistSum(v, u, d+1);\n\treturn sum;\n}\n\nvoid distributeDistSum(int u, int prv, LL sum){\n\tdist2[u] = sum;\n\tfor(int v: adj[u]) if(v != prv) distributeDistSum(v, u, sum - sz[v] + (n-sz[v]));\n}\n\nint32_t main(){ FAST;\n\tread(n);\n\tFOR(i,1,n){ LL d; read(d); s.insert(d); id[d] = i; dist[i] = d; }\n\n\tif(n == 2 || n == 3 || n == 4){\n\t\twrite(-1, \"\\n\");\n\t\treturn 0;\n\t}\n\n\tFOR(i,1,n) sz[i] = 1;\n\tROF(cnt,n,2){\n\t\tLL d = *rbegin(s);\n\t\ts.erase(d);\n\t\tint i = id[d];\n\n\t\tLL nxtD = d + sz[i] - (n-sz[i]);\n\t\tif(!s.count(nxtD)){\n\t\t\twrite(-1, \"\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tint j = id[nxtD];\n\t\te.emplace_back(i,j);\n\t\tsz[j] += sz[i];\n\t}\n\n\tfor(pii edg: e){\n\t\tint u,v; tie(u,v) = edg;\n\t\tadj[u].emplace_back(v);\n\t\tadj[v].emplace_back(u);\n\t}\n\n\tint root = -1;\n\tFOR(i,1,n) if(sz[i] == n) root = i;\n\tif(root == -1){\n\t\twrite(-1, \"\\n\");\n\t\treturn 0;\n\t}\n\t\n\tset<int> visited;\n\tcheckConn(root, visited);\n\tif(!(size(visited) == n)){\n\t\twrite(-1, \"\\n\");\n\t\treturn 0;\n\t}\n\n\tLL sum = getDistSum(root,root,0);\n\n\tdistributeDistSum(root,root,sum);\n\n\tbool different = false;\n\tfor(auto el: dist) if(dist[el.first] != dist2[el.first]) different = true;\n\tfor(auto el: dist2) if(dist[el.first] != dist2[el.first]) different = true;\n\tif(different){\n\t\twrite(-1, \"\\n\");\n\t\treturn 0;\n\t}\n\n\tfor(pii edg: e) write(edg.first, \" \", edg.second, \"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(3)\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target(\"sse3\",\"sse2\",\"sse\")\n//#pragma GCC target(\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")\n//#pragma GCC target(\"f16c\")\n//#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\n//#pragma GCC diagnostic error \"-fwhole-program\"\n//#pragma GCC diagnostic error \"-fcse-skip-blocks\"\n//#pragma GCC diagnostic error \"-funsafe-loop-optimizations\"\n//#pragma GCC diagnostic error \"-std=c++14\"\n#include \"bits/stdc++.h\"\n//#include \"ext/pb_ds/tree_policy.hpp\"\n//#include \"ext/pb_ds/assoc_container.hpp\"\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) a.begin(),a.end()\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-(x)))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9+7;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {\n    if(a<0)return -1;\n    if(a>0)return 1;\n    return 0;\n}\nstring to_string(string s) {\n    return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n    return to_string((string) s);\n}\n\nstring to_string(bool b) {\n    return (b ? \"true\" : \"false\");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n    return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n    bool first = true;\n    string res = \"{\";\n    for (const auto &x : v) {\n        if (!first) {\n            res += \", \";\n        }\n        first = false;\n        res += to_string(x);\n    }\n    res += \"}\";\n    return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << to_string(H);\n    debug_out(T...);\n}\n\n#ifndef ONLINE_JUDGE\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) {}\n#endif\n\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\n\ntemplate<typename T> inline void in(T &x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) {\n        if (ch == '-') f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))  {\n        x = x * 10 + ch - '0';\n        ch = getchar();\n    }\n    x *= f;\n}\n\nll twop(int x) {\n    return 1LL<<x;\n}\n\n// m must be positive\ntemplate<typename T>\nT MOD(T a, T m){\n    a %= m;\n    if (a < 0)\n        a += m;\n    return a;\n}\n\n// a must be relatively prime to m\ntemplate<typename T>\nT inverse(T a, T m){\n    a = MOD(a, m);\n    if (a <= 1)\n        return a;\n    return MOD((1 - inverse(m, a) * m) / a, m);\n}\n\ntemplate<typename A,typename B > inline void in(A&x,B&y) {\n    in(x);\n    in(y);\n}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {\n    in(x);\n    in(y);\n    in(z);\n}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {\n    in(x);\n    in(y);\n    in(z);\n    in(d);\n}\nll gcd(ll a,ll b){return b==0?a:gcd(b,a%b);}\nnamespace SOLVE {\n    vector<PLL>ans;\n    map<ll, ll>mp;\n    ll vis[100010];\n    ll subtree_size[100001];\n    ll sum[100010];\n    void main(){\n        ll n;in(n);\n        PLL root = MP(-1,-1);\n        REP(i,1,n+1){\n            ll value;\n            in(value);\n            mp[value] = i;\n            sum[i] = value;\n            upmax(root, MP(value,i));\n        }\n        priority_queue<PLL>pq;\n        REP(i,1,n+1){\n            pq.push(MP(sum[i],i));\n            subtree_size[i] = 1;\n        }\n        while (sz(pq)>1) {\n            auto t = pq.top();pq.pop();\n            vis[t.se] = 1;\n//            dbg(t);\n            ll par_sum = sum[t.se] - n +  subtree_size[t.se]*2;\n            ll par = mp[par_sum];\n            if(vis[par] or !par){\n                cout<<-1<<endl;\n                return;\n            }\n            subtree_size[par] += subtree_size[t.se];\n            ans.PB(MP(par,t.se));\n//            dbg(ans.back());\n        }\n        for(auto i:ans)cout<<i.fi<<\" \"<<i.se<<endl;\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    }\n}\n\n\nsigned main() {\n#ifndef ONLINE_JUDGE\n//    fr(\"/Users/zhangqingchuan/Desktop/cp/cp/input.txt\");\n//    fw(\"/Users/zhangqingchuan/Desktop/cp/cp/output.txt\");\n#endif\n    \n    \n    \n    \n    \n    int t = 1;\n//    in(t);\n    while(t--){\n        SOLVE::main();\n\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <string.h>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <cassert>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <sstream>\n#include <functional>\n#include <iomanip>\n#include <bitset>\n//#include <windows.h>  //Should be deleted when using AtCoder&POJ\nusing namespace std;\n\n#define ll long long\n#define pii pair<int,int>\n#define qi ios::sync_with_stdio(0)\n/**==Info==\n*Program:6\n*Problem:Distance Sums\n*Date:2019-7-12\n*Algorithm:Orange Boy's Greedy and Sorting\n*Stats:WA*/\n\nbool debug=false;\n\n\ntemplate<typename T1,typename T2> ostream& operator<<(ostream& o,pair<T1,T2> p){\n\to<<\"{\";\n\to<<p.first<<\",\"<<p.second;\n\to<<\"}\";\n\treturn o;\n}\n\nll n;\nll d[100005];\nmap <ll,ll> m;\npair<ll,ll> p[100005];\nll sub[100005];\nll sz[100005];\nvector <pair<ll,ll> >res;\n \n int fa[100005];\n \nint getFa(int x){\n\tif(fa[x]==x){\n\t\treturn x;\n\t}\n\treturn fa[x]=getFa(fa[x]);\n}\n \n \nvoid Union(int a,int b){\n\tif(fa[a]==fa[b]){\n\t\treturn;\n\t}\n\tfa[getFa(a)]=getFa(b);\n}\n\nint dp[100005];\n\nint main()\n{\n//\tfreopen(\"input.txt\",\"r\",stdin);\n\tios_base::sync_with_stdio(false);\n\tcin>>n;\n\tfor(ll i=0;i<n;i++)\n\t{\n\t\tcin>>d[i];\n\t\tif(d[i]>n*(n-1)/2){\n\t\t\tcout<<-1;\n\t\t\treturn 0;\n\t\t}\n\t\tm[d[i]]=i;\n\t\tp[i].first=d[i];\n\t\tp[i].second=i;\n\t\tsz[i]=1;\n\t}\n\tsort(p,p+n);\n\treverse(p,p+n);\n\tmemset(sub,-1,sizeof(sub));\n\tfor(ll i=0;i<n-1;i++)\n\t{\n\t\tll de=p[i].first;\n\t\tll x=p[i].second;\n\t\tsub[x]=n-sz[x]*2;\n\t\tif(sub[x]==0){\n\t\t\tcout<<-1;\n\t\t\treturn 0;\t\n\t\t}\n\t\tif(m.find(de-sub[x])==m.end()){\n\t\t\tcout<<-1;\n\t\t\treturn 0;\n\t\t}\n\t\tll par=m[de-sub[x]];\n\t\tsz[par]+=sz[x];\n\t\tdp[par]+=dp[x]+sz[x];\n\t\tres.push_back(make_pair(x,par));\n\t}\n\t\n\tif(dp[p[n-1].second]!=p[n-1].first){\n\t\tcout<<-1;\n\t\treturn 0;\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tfa[i]=i;\n\t}\n\tfor(pii x:res){\n\t\tUnion(x.first,x.second);\n\t}\n\t\n\tset<int> fafa;\n\tfor(int i=0;i<n;i++){\n\t\tfafa.insert(getFa(i));\n\t}\n\tif(fafa.size()!=1){\n\t\tcout<<\"-1\";\n\t\treturn 0;\n\t}\n\t\n\tfor(ll i=0;i<n-1;i++)\n\t{\n\t\tcout<<res[i].first+1<<\" \"<<res[i].second+1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define maxn 100005\n#define pii pair<int,int>\nusing namespace std;\nint N;\npii arr[maxn];\nint sz[maxn];\nvector<int> G[maxn];\nint dfs(int u,int pa) {\n\tint ret = 0;\n\tfor(int v:G[u])\n\t\tif(v!=pa)\n\t\t\tret += sz[v]+dfs(v,u);\n\treturn ret;\n}\nmain() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> N;\n\tfor(int i=1;i<=N;i++)\n\t\tcin >> arr[arr[i].second=i].first;\n\tsort(arr+1,arr+1+N);\n\tfor(int i=1;i<=N;i++)\n\t\tsz[i] = 1;\n\tfor(int i=N;i>1;i--) {\n\t\tint val = arr[i].first;\n\t\tint idx = arr[i].second;\n\t\tint pa_val = val-(N-sz[idx])+(sz[idx]);\n\t\tint tem = lower_bound(arr+1,arr+1+N,pii{pa_val,-1})-arr;\n\t\tif(tem>=i || arr[tem].first!=pa_val) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint pa = arr[tem].second;\n\t\tsz[pa] += sz[idx];\n\t\tG[pa].emplace_back(idx);\n\t}\n\tif(dfs(arr[1].second,arr[1].second)==arr[1].first) {\n\t\tfor(int u=1;u<=N;u++)\n\t\t\tfor(int v : G[u])\n\t\t\t\tcout << u << \" \" << v << endl;\n\t}\n\telse\n\t\tcout << -1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)-form-)\n//#pragma GCC optimize (\"-O3\") \n#ifdef YANG33\n#include \"mydebug.hpp\"\n#else\n#define DD(x) \n#endif\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n\ninline int ri() { int in; int y = scanf(\"%d\", &in); return in; }\ninline LL rl() { LL in; int y = scanf(\"%lld\", &in); return in; }\ninline void oi(int i) { printf(\"%d\\n\", i); }\ninline void od(double i) { printf(\"%.9f\\n\", i); }\n\n\nint main() {\n\tint N = ri();\n\tvector<LL> a(N);\n\tset<PLL>se;\n\tfor (int i = 0; i < N; ++i) {\n\t\ta[i] = rl();\n\t\tse.insert(PLL(a[i], i));\n\t}\n\tVL sub(N, 1);\n\tauto NG = []() {\n\t\tcout << -1 << endl;\n\t\texit(0);\n\t};\n\tvector<vector<int>>G(N);\n\twhile (SZ(se) > 1) {\n\t\tauto it = se.end();\n\t\t--it;\n\t\tPLL a = *it;\n\t\tse.erase(it);\n\t\tLL sa = a.first;\n\t\tint v = a.second;\n\t\tDD(de(sa, v));\n\t\tLL parval = sa + 2 * sub[v] - N;\n\t\tauto parnode = se.lower_bound(PLL(parval, 0));\n\t\tif (parnode->first != parval)NG();\n\t\tint par = parnode->second;\n\t\tsub[par] += sub[v];\n\t\tG[par].push_back(v);\n\t}\n\n\tfunction<LL(int)> f = [&](int v) {\n\t\tLL ret = 0;\n\t\tfor (auto nx : G[v]) {\n\t\t\tret += f(nx) + sub[nx];\n\t\t}\n\t\treturn ret;\n\t};\n\tLL res = f(se.begin()->second);\n\tif (res != se.begin()->first)NG();\n\tFOR(i, 0, N) {\n\t\tfor (auto nx : G[i]) {\n\t\t\tcout << i + 1 << \" \" << nx + 1 << endl;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int maxn = 101010;\nstruct Node{\n    int num;\n    ll d;\n    bool operator < (const Node &tx) const {\n        return d < tx.d;\n    }\n}a[maxn];\nint n, flag, vis[maxn];\nll siz[maxn];\n\nqueue<int> q[2];\nvector<pair<int, int> > ans;\nvector<int> v[maxn];\n\n\nll dfs(int x, int h){\n    ll ans = 0;\n    vis[x] = 1;\n    for(int i = v[x].size() - 1; i >= 0; i --){\n        int ty = v[x][i];\n        if(vis[ty]) continue;\n        ans += dfs(ty, h + 1);\n    }\n    return ans + h;\n}\n\nvoid check(){\n    flag = (dfs(a[1].num, 0) != a[1].d); \n}\n\nint main(){\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i ++){\n        scanf(\"%lld\", &a[i].d);\n        a[i].num = i;\n    }\n\n    sort(a+1, a+1+n);\n\n    q[a[1].d & 1].push(1);\n    siz[a[1].num] = n - 1;\n    int tem_flag = n & 1;\n    \n    for(int i = 2; i <= n; i ++){\n        if(q[1 & (a[i].d ^ tem_flag)].empty()){\n            flag = 1;\n        }\n        int tem_num = q[1 & (a[i].d ^ tem_flag)].front();\n\n        ll diff = a[i].d - a[tem_num].d;\n\n        if(diff > n)\n            flag = 1;\n\n        int diff_siz = (n - diff) / 2;\n        siz[a[i].num] = diff_siz - 1;\n        siz[a[tem_num].num] -= diff_siz;\n\n        if(diff_siz > 1)\n            q[a[i].d & 1].push(i);\n        ans.push_back(make_pair(a[i].num, a[tem_num].num));\n        \n        v[a[i].num].push_back(a[tem_num].num);\n        v[a[tem_num].num].push_back(a[i].num);\n\n        if(siz[a[tem_num].num] <= 0) q[1 & (a[i].d ^ tem_flag)].pop();\n    }\n\n    for(int i = 1; i <= n; i ++){\n        if(siz[i] != 0){\n            flag = 1;\n        }\n    }\n    \n    check();\n\n    if(flag){\n        printf(\"-1\\n\");\n        return 0;\n    }\n\n    int siz = ans.size() - 1;\n    for(int i = 0; i <= siz; i ++)\n        printf(\"%d %d\\n\", ans[i].first, ans[i].second);\n\n\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 29.09.2018 15:33:19       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<long long> d(n);\n  vector<int> weight(n, 1);\n  map<long long,int> mp;\n  for (int i = 0; i < n; i++) {\n    cin >> d[i];\n    mp[d[i]] = i;\n  }\n  vector<pair<int,int>> res;\n  for (int itt = 0; itt < n - 1; itt++) {\n    auto it = mp.rbegin();\n    int i = it->second;\n    long long want = d[i] - (n - weight[i]) + weight[i];\n    if (mp.find(want) == mp.end() || mp[want] == i) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n    int j = mp[want];\n    res.emplace_back(i, j);\n    weight[j] += weight[i];\n    mp.erase(--mp.end());\n  }\n  vector<long long> real_dist(n, -1);\n  real_dist[0] = 0;\n  vector<vector<int>> g(n);\n  for (auto &p : res) {\n    g[p.first].push_back(p.second);\n    g[p.second].push_back(p.first);\n  }\n  vector<int> que(1, 0);\n  for (int b = 0; b < (int) que.size(); b++) {\n    for (int j : g[que[b]]) {\n      if (real_dist[j] == -1) {\n        que.push_back(j);\n        real_dist[j] = real_dist[que[b]] + 1;\n      }\n    }\n  }\n  if (accumulate(real_dist.begin(), real_dist.end(), 0LL) != d[0]) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  for (auto &p : res) {\n    cout << p.first + 1 << \" \" << p.second + 1 << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#include <queue>\n#include <vector>\n#define PB push_back\n#define MP make_pair\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=1e5+10;\nstruct node {\n\tint id; ll d;\n\tnode(int id=0,ll d=0): id(id),d(d) {}\n\tfriend bool operator <(node A,node B) { return A.d<B.d; }\n};\npriority_queue<node> que;\nmap<ll,int> mp;\nint n,sz[N];\nll d[N];\nvector< pair<int,int> > E;\nint main() {\n\trd(n);\n\tfor(int i=1;i<=n;++i) {\n\t\trd(d[i]),mp[d[i]]=i;\n\t\tque.push(node(i,d[i]));\n\t\tsz[i]=1;\n\t}\n\twhile(que.size()>1) {\n\t\tint u=que.top().id; que.pop();\n\t\tmp.erase(d[u]);\n\t\tll t=d[u]-(n-sz[u]*2ll);\n\t\tif(!mp.count(t)) {\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint f=mp[t];\n\t\tE.PB(MP(f,u));\n\t\tsz[f]+=sz[u];\n\t}\n\tfor(int i=0;i<E.size();++i) printf(\"%d %d\\n\",E[i].first,E[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#include \"Segment_Tree.h\"\n#include \"BIT.h\"\n#include \"Rational.h\"\n#include \"Position.h\"\n#include \"Factorization.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nLL N;\nPP Q[100000];\nLL A[100000];\nLL P[100000];\nLL cnt[100000];\nmap<LL, int> mp;\n\nbool cat(int from) {\n\tLL t = A[from] - (N - 2 * cnt[from]);\n\tif (!mp.count(t)) return false;\n\tif (t >= A[from]) return false;\n\tint to = mp[t];\n\tP[from] = to;\n\tcnt[to] += cnt[from];\n\treturn true;\n}\n\nvoid sub() {\n\tFill(cnt, 1);\n\tREP(i, 0, N) {\n\t\tA[i] = Q[i].first;\n\t\tmp[A[i]] = i;\n\t}\n\n\tREM(i, 1, N) {\n\t\tif (!cat(i)) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tREP(i, 1, N) {\n\t\tcout << Q[i].second + 1 << ' ' << Q[P[i]].second + 1 << endl;\n\t}\n}\n\nint main() {\n\tcin >> N;\n\tREP(i, 0, N) {\n\t\tLL a;\n\t\tcin >> a;\n\t\tQ[i] = PP(a, i);\n\t}\n\tsort(Q, Q + N);\n\n\tsub();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N;\nint D[111111];\n\nint w[111111];\n\nsigned main(){\n    cin>>N;\n    map<int,int>uku;\n    rep(i,N){\n        cin>>D[i];\n        uku[D[i]]=i;\n    }\n\n    fill_n(w,N,1);\n    vpint lis;\n    rep(i,N)lis.pb({D[i],i});\n    sort(all(lis));reverse(all(lis));\n\n    vpint ans;\n    rep(i,N-1){\n        int v=lis[i].se;\n\n        int tmp=N-w[v];\n        int fo=D[v]+w[v]-tmp;\n        if(fo>=D[v]||uku.find(fo)==uku.end()){\n            cout<<-1<<endl;\n            return 0;\n        }\n        ans.pb({v,uku[fo]});\n        w[uku[fo]]+=w[v];\n\n    }\n    rep(i,ans.size())cout<<ans[i].fi+1<<\" \"<<ans[i].se+1<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define biu (puts(\"-1\"), exit(0))\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename Tp> inline void getint(Tp &num){\n\tregister int ch, neg = 0;\n\twhile(!isdigit(ch = getchar())) if(ch == '-') neg = 1;\n\tnum = ch & 15;\n\twhile(isdigit(ch = getchar())) num = num * 10 + (ch & 15);\n\tif(neg) num = -num;\n}\n\nint N, siz[100005], tope = 0;\nstruct disData {ll d; int id;} D[100005];\nstruct Edge {int np; Edge *nxt;} E[100005], *V[100005];\n\ninline bool operator < (const disData &d1, const disData &d2) {return d1.d < d2.d;}\ninline void addedge(const int &u, const int &v) {E[++tope].np = v, E[tope].nxt = V[u], V[u] = E + tope;}\n\nint main(){\n\tgetint(N);\n\tfor(register int i = 1; i <= N; i++) getint(D[i].d), D[i].id = i, siz[i] = 1;\n\tsort(D + 1, D + N + 1);\n\tfor(register int i = N; i > 1; i--){\n\t\tif((siz[i] << 1) >= N) biu;\n\t\tconst ll d = D[i].d - N + (siz[i] << 1);\n\t\tconst int fa = lower_bound(D + 1, D + N + 1, (disData){d, 0}) - D;\n\t\tif(D[fa].d != d) biu; siz[fa] += siz[i], addedge(fa, i);\n\t}\n\tfor(register int i = 1; i <= N; i++)\n\t\tfor(register Edge *ne = V[i]; ne; ne = ne->nxt) printf(\"%d %d\\n\", D[i].id, D[ne->np].id);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<ll>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=100005;\nll sum,d[N];\nmap<ll,int> M;\nint q[N],sz[N],vis[N],fa[N];\nvector<int> v[N];\nvoid GG(){\n\tputs(\"-1\"); exit(0);\n}\nbool cmp(int a,int b){\n\treturn d[a]<d[b];\n}\nvoid dfs(int p,int dep){\n\tvis[p]=1; sum+=dep;\n\tfor(auto i:v[p])if(!vis[i])dfs(i,dep+1);\n}\nint main(){\n\tint n=read();\n\tFor(i,1,n)M[d[q[i]=i]=read()]=i;\n\tsort(q+1,q+n+1,cmp);\n\tRep(i,n,2){\n\t\tsz[q[i]]++;\n\t\tauto it=M.find(d[q[i]]-n+2*sz[q[i]]);\n\t\tif(it==M.end())GG();\n\t\tfa[q[i]]=it->second;\n\t\tsz[fa[q[i]]]+=sz[q[i]];\n\t\tv[fa[q[i]]].pb(q[i]);\n\t}\n\tdfs(q[1],0);\n\tFor(i,1,n)if(!vis[i])GG();\n\tif(sum!=d[q[1]])GG();\n\tFor(i,2,n){wri(fa[q[i]]); writeln(q[i]);}\n}"
  },
  {
    "language": "C++",
    "code": "//Zory-2018\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n#include<set>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<bitset>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nnamespace mine\n{\n\ttypedef long long ll;\n\tconst int INF=0x3f3f3f3f;\n\n\tconst int MAX_N=110000;\n\tstruct Nod\n\t{\n\t\tll d;int p;\n\t\tfriend bool operator < (Nod a,Nod b) {return a.d<b.d;}\n\t};\n\tset<Nod> s;\n\tint siz[MAX_N];\n\n\t#define PR pair<int,int>\n\tvector<PR> ans;\n\tint n;\n\tvoid solve(int op)\n\t{\n\t\tNod now;\n\t\tif(op) now=*(--s.end());\n\t\telse now=*s.begin();\n\t\ts.erase(s.find(now));\n\n\t\t//printf(\"now=%d p[now].d=%lld \",now.p,now.d);\n\n\t\tll want=now.d-n+2*siz[now.p];Nod fa=*(s.lower_bound((Nod){want,0}));\n\t\t//printf(\"siz=%d want=%lld fa.d=%lld\\n\",siz[now.p],want,fa.d);\n\t\tif(fa.d!=want) {puts(\"-1\");exit(0);}\n\t\tans.push_back( make_pair(now.p,fa.p) );\n\t\tsiz[fa.p]+=siz[now.p];\n\t}\n\tvoid main()\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tll t;scanf(\"%lld\",&t);\n\t\t\ts.insert( (Nod){t,i} );\n\t\t\tsiz[i]=1;\n\t\t}\n\n\t\tfor(int i=1;i<=n-1;i++) solve(1);\n\t\t//int rt=(n+1)/2;\n\t\t//for(int i=n;i>rt;i--) solve(1);\n\t\t//for(int i=1;i<rt;i++) solve(0);\n\t\tfor(int i=0;i<(int)ans.size();i++) printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\t}\n}\nint main()\n{\n\tmine::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#define max_n 100000\n#define max_m 200000 \nusing namespace std;\ntypedef const int& ci;\nstruct node{\n\tint v,nxt;\n\tnode(){}\n\tnode(int _v,int _nxt):v(_v),nxt(_nxt){}\n};\nstruct graph{\n\tint head[max_n+1];\n\tint cnt;\n\tnode edge[max_m];\n\tvoid build(){\n\t\tmemset(head,-1,sizeof(head));\n\t\tcnt=-1;\n\t}\n\tvoid insert(ci u,ci v){\n\t\tpush(u,v);\n\t\tpush(v,u);\n\t}\n\tvoid push(ci u,ci v){\n\t\tedge[++cnt]=node(v,head[u]);\n\t\thead[u]=cnt;\n\t}\n};\ngraph g;\nint n,sz[max_n+1];\nlong long dis[max_n+1],d[max_n+1];\nmap<long long, int> mp;\nvoid dfs(int u,int p=0){\n\tfor(int i=g.head[u],v; ~i; i=g.edge[i].nxt){\n\t\tif((v=g.edge[i].v)==p)\n\t\t\tcontinue;\n\t\tdis[v]=dis[u]+1;\n\t\tdfs(v,u);\n\t}\n}\nint main(){\n    scanf(\"%d\",&n),g.build();\n    for(int i=0; ++i<=n; mp[d[i]]=i,sz[i]=1)\n    \tscanf(\"%lld\",d+i);\n    int cnt=0,u,v;\n\tfor(map<long long,int>::reverse_iterator it=mp.rbegin(); ++cnt<n&&it!=mp.rend(); ++it,g.insert(u,v),sz[u]+=sz[v])\n\t\tif(!(u=mp[it->first+2*sz[v=it->second]-n])||u==v){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n    int rt=mp.begin()->second;\n    dfs(rt);\n    if(accumulate(dis+1,dis+n+1,0LL)!=d[rt]){\n    \tputs(\"-1\");\n    \treturn 0;\n\t}\n\tfor(int i=0; ++i<=n; )\n\t\tfor(int j=g.head[i]; ~j; j=g.edge[j].nxt)\n\t\t\ti<g.edge[j].v&&printf(\"%d %d\\n\",i,g.edge[j].v);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n    #define _GLIBCXX_DEBUG\n#endif\n\n\n\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <utility>\n#include <memory>\n#include <memory.h>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cassert>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <functional>\n#include <numeric>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <random>\n#include <ctime>\n#include <ostream>\n#include <queue>\n#include <array>\n\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing uint = unsigned int;\nusing ld = long double;\nusing vi = std::vector<int>;\nusing pii = std::pair<int, int>;\nusing vvi = std::vector<vi>;\nusing vii = std::vector<pii>;\nusing vll = std::vector<ll>;\nusing pll = std::pair<ll, ll>;\n\n#define MAKE_FINAL_NAME_HELPER(A, B) A ## B\n#define MAKE_FINAL_NAME(NAME, NUM) MAKE_FINAL_NAME_HELPER(NAME ## _, NUM)\n#define ARGUMENTS_SIZE_HELPER(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, COUNT, ...) COUNT\n#define ARGUMENTS_SIZE(...) ARGUMENTS_SIZE_HELPER(__VA_ARGS__, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n#define SELECT_MACRO(NAME, ...) MAKE_FINAL_NAME(NAME, ARGUMENTS_SIZE(__VA_ARGS__))(__VA_ARGS__)\n\n#define pb push_back\n#define sz(c) int((c).size())\n#define all(c) begin(c), end(c)\n#define mp(x, y) make_pair(x, y)\n#define fst first\n#define snd second\n\n#define ford(...) SELECT_MACRO(ford, __VA_ARGS__)\n#define ford_3(i, s, n) for (int i = int(n) - 1; i >= int(s); --i)\n#define ford_2(i, n) ford_3(i, 0, n)\n\n#define forn(...) SELECT_MACRO(forn, __VA_ARGS__)\n#define forn_3(i, s, n) for (int i = int(s); i < int(n); ++i)\n#define forn_2(i, n) forn_3(i, 0, n)\n\n#define y1 y1___\n#define prev prev___\n#define next next___\n#define hash hash___\n\n\ntemplate<typename T>\nint sign(const T& t) {\n    return (t > 0) - (t < 0);\n}\n\ntemplate<typename T, typename U>\nbool remax(T& a, U b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T, typename U>\nbool remin(T& a, U b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T>\nT gcd(T a, T b) {\n    a = std::abs(a);\n    b = std::abs(b);\n    while (b) {\n        a %= b;\n        std::swap(a, b);\n    }\n    return a;\n}\n\ntemplate<typename T>\nT lcm(T a, T b) {\n    a = std::abs(a);\n    b = std::abs(b);\n    return a / gcd(a, b) * b;\n}\n\ndouble get_time() {\n    return static_cast<double>(clock()) / CLOCKS_PER_SEC;\n}\n\nuint32_t mrand_32t() {\n    static std::random_device rd;\n    // TODO: seed with 19937 bits, not with 32\n    static std::mt19937 rng(rd());\n    return rng();\n}\n\nuint64_t mrand_64t() {\n    static std::random_device rd;\n    // TODO: seed with 19937 bits, not with 32\n    static std::mt19937_64 rng(rd());\n    return rng();\n}\n\ntemplate<typename T>\nvoid make_unique(std::vector<T>& v) {\n    std::sort(std::begin(v), std::end(v));\n    v.erase(std::unique(std::begin(v), std::end(v)), std::end(v));\n}\n\n#include <sstream>\n\nnamespace std {\n\ntemplate<typename A, typename B>\nstring to_string(const pair <A, B>& p) {\n    string str;\n    str += \"(\";\n    str += to_string(p.first);\n    str += \", \";\n    str += to_string(p.second);\n    str += \")\";\n    return str;\n}\n\nstring to_string(bool value) {\n    return value ? \"true\" : \"false\";\n}\n\ntemplate<typename T>\nstring to_string(const vector <T>& vec) {\n    string str = \"{ \";\n    bool first = true;\n    for (const auto& it : vec) {\n        if (!first) {\n            str += \", \";\n        }\n        str += to_string(it);\n        first = false;\n    }\n    str += \" }\";\n    return str;\n}\n\ntemplate<typename T>\nstring to_string(const set <T>& s) {\n    string str = \"{ \";\n    bool first = true;\n    for (const auto& it : s) {\n        if (!first) {\n            str += \", \";\n        }\n        str += to_string(it);\n        first = false;\n    }\n    str += \" }\";\n    return str;\n}\n\n\ntemplate<typename K, typename V>\nstring to_string(const map <K, V>& m) {\n    string str = \"{ \";\n    bool first = true;\n    for (const auto& it : m) {\n        if (!first) {\n            str += \", \";\n        }\n        first = false;\n        str += to_string(it.first);\n        str += \" -> \";\n        str += to_string(it.second);\n    }\n    str += \" }\";\n    return str;\n}\n\nstring to_string(const string& s) {\n    return \"\\\"\" + s + \"\\\"\";\n}\n\nstring to_string(const char* s) {\n    return to_string(string(s));\n}\n\nstring to_string(char ch) {\n    return \"\\'\" + string(1, ch) + \"\\'\";\n}\n\ntemplate<size_t N>\nstring to_string(const bitset<N>& b) {\n    string res(N, '0');\n    for (size_t i = 0; i < N; ++i) {\n        res[i] = '0' + b[i];\n    }\n    return res;\n}\n\ntemplate <typename T>\nstring to_string(const T& t) {\n    std::stringstream ss;\n    ss << t;\n    return ss.str();\n}\n\n}\n\nvoid debug_out() {\n    std::cerr << std::endl;\n}\n\ntemplate<typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    std::cerr << \" \" << std::to_string(H);\n    debug_out(T...);\n}\n\n#ifdef LOCAL\n    #define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n    #define debug(...) std::cerr << \"[\" << #__VA_ARGS__ <<  \"]:\", debug_out(__VA_ARGS__);\n#else\n    #define eprintf(...)\n    #define cerr if (false) cerr\n    #define debug(...)\n#endif\n\nusing namespace std;\n\n/* *************************** TEMPLATE CODE ENDS HERE ******************************** */\n\nconst int MAXN = 1e5 + 10;\n\nint n;\nll D[MAXN];\n\nbool read() {\n    if (!(cin >> n)) {\n        return 0;\n    }\n    forn(i, n) {\n        cin >> D[i];\n    }\n    return 1;\n}\n\nint sz[MAXN];\nvi g[MAXN];\n\nvoid dfs(int v, int de, ll& sum) {\n    sum += de;\n    for (int to : g[v]) {\n        dfs(to, de + 1, sum);\n    }\n}\n\nbool solve() {\n    forn(i, n) {\n        g[i].clear();\n        sz[i] = 1;\n    }\n\n    vi perm(n);\n    iota(all(perm), 0);\n    sort(all(perm), [&](int v, int u) { return D[v] > D[u]; });\n\n    map<ll, int> pos_D;\n    forn(v, n) {\n        pos_D[D[v]] = v;\n    }\n\n    forn(it, n - 1) {\n        const int v = perm[it];\n        ll Dp = D[v] - n + 2 * sz[v];\n        if (!pos_D.count(Dp)) {\n//            debug(v + 1, sz[v], D[v], Dp);\n            return 0;\n        }\n        int p = pos_D.at(Dp);\n        g[p].pb(v);\n        sz[p] += sz[v];\n//        debug(p + 1, v + 1);\n    }\n\n    const int root = perm.back();\n    ll sum = 0;\n    dfs(root, 0, sum);\n    if (sum != D[root]) {\n//        debug(sum, D[root]);\n        return 0;\n    }\n    ford(it, n) {\n        const int v = perm[it];\n        for (int to : g[v]) {\n            cout << v + 1 << \" \" << to + 1 << \"\\n\";\n        }\n    }\n    return 1;\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios_base::sync_with_stdio(false);\n    cout.tie(nullptr);\n    cout.precision(12);\n    cout << fixed;\n\n#ifdef LOCAL\n    #define FILE_NAME \"a\"\n    assert(freopen(FILE_NAME \".in\", \"r\", stdin));\n//    freopen(FILE_NAME \".out\", \"w\", stdout);\n#endif\n\n    while (read()) {\n        if (!solve()) {\n            cout << -1 << endl;\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// author: Saman Mahdanian\n#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 1e5 + 10;\n\nint n, size[N], p[N];\nmap <long long, int> who_is;\nvector <int> c[N];\nlong long d[N];\n\nvoid contradict_if (bool, string = \"no exit msg\");\nlong long dfs (int, int = -1);\nint get_par (int);\n\nint32_t main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> d[i];\n\t\twho_is[d[i]] = i;\n\t}\n\n\tvector <int> ver(n);\n\tiota (ver.begin(), ver.end(), 0);\n\tsort (ver.begin(), ver.end(), [] (int a, int b) {\n\t\treturn d[a] > d[b];\n\t});\n\tint root = ver.back();\n\n\tfor (int v: ver) {\n\t\tif (v == root)\n\t\t\tcontinue;\n\n\t\tsize[v]++;\n\t\tcontradict_if (size[v] * 2 > n, \"size failture\");\n\n\t\tp[v] = get_par(v);\n\t\tsize[p[v]] += size[v];\n\t\tc[p[v]].push_back(v);\n\t}\n\n\t// cerr << \"Root: \" << root << endl;\n\tcontradict_if (dfs(root) != d[root], \"Root failed\");\n\tfor (int v: ver)\n\t\tfor (int u: c[v])\n\t\t\tcout << v + 1 << ' ' << u + 1 << endl;\n}\n\nvoid contradict_if (bool condition, string msg) {\n\tif (!condition)\n\t\treturn;\n\tcout << -1;\n\t// cerr << \" \" << msg;\n\tcout << endl;\n\texit(0);\n}\n\nint get_par (int v) {\n\tlong long pev = d[v] - n + 2 * size[v];\n\t// cout << \"looking for: \" << v << ' ' << d[v] << ' ' << size[v] << endl;\n\tcontradict_if (who_is.find(pev) == who_is.end(), \"parent not found\");\n\t// cout << \"parent of \" << v << \" is \" << who_is[pev] << endl;\n\treturn who_is[pev];\n}\n\nlong long dfs (int v, int pv) {\n\tint res = 0;\n\tfor (int u: c[v])\n\t\tres += size[u] + dfs(u, v);\n\treturn res;\n}\n\n// SamMHD :: 05/12/2018 12:30:04 :: Another Tree..."
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint N;\nlong long D[100010];\nint cnt[100010];\nint ansu[100010], ansv[100010];\nint idx[100010];\nlong long Dv[100010];\n\nint bsrch(int ll, int rr, long long vv)\n{\n\tint l=ll, r=rr;\n\tint m;\n\twhile(l<r){\n\t\tm = (l+r)/2;\n\t\tif(D[idx[m]] >= vv){\n\t\t\tr = m;\n\t\t}\n\t\telse\n\t\t\tl = m+1;\n\t}\n\treturn l;\n}\n\nbool cmp(int aa, int bb)\n{\n\treturn D[aa] < D[bb];\n}\n\nint solve()\n{\n\tint i, j=0;\n\tint ii;\n\tfor(i=0; i<N; i++)\n\t\tidx[i] = i;\n\tsort(idx, idx+N, cmp);\n\tfor(ii=N-1; ii>0; ii--){\n\t\ti = idx[ii];\n\t\tint p = bsrch(0, ii, D[i]-(N-2-cnt[i]*2) );\n\t\tif(p>=ii || D[idx[p]]!=D[i]-(N-2-cnt[i]*2) )\n\t\t\treturn 0;\n\t\tcnt[idx[p]] += cnt[i]+1;\n\t\tDv[idx[p]] += Dv[i] + (cnt[i]+1);\n\t\tansu[j] = idx[p];\n\t\tansv[j] = i;\n\t\tj ++;\n\t}\n\tif(Dv[idx[0]] != D[idx[0]])\n\t\treturn 0;\n\tfor(i=0; i<N-1; i++){\n\t\tprintf(\"%d %d\\n\", ansu[i]+1, ansv[i]+1);\n\t}\n\treturn 1;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\tint i;\n\tscanf(\"%d\", &N);\n\tfor(i=0; i<N; i++)\n\t\tscanf(\"%lld\", &D[i]);\n\tif(solve() == 0)\n\t\tprintf(\"-1\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int MN = 100010;\n\nint N;\nll D[MN];\nvector<pair<ll, int> > ord;\nint inv[MN], sz[MN];\nvector<pii> edge;\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%lld\", &D[i]);\n        ord.push_back({ D[i], i });\n    }\n\n    sort(ord.begin(), ord.end());\n    for(int i = 0; i < N; i++) inv[ ord[i].second ] = i;\n    sort(D, D + N);\n\n    for(int i = 0; i < N; i++) sz[i] = 1;\n    for(int i = N - 1; i >= 1; i--) {\n        if(2 * sz[i] >= N) {\n            printf(\"-1\");\n            return 0;\n        }\n        if(D[i] - N + 2 * sz[i] <= 0) {\n            printf(\"-1\");\n            return 0;\n        }\n        int a = lower_bound(D, D + N, D[i] - N + 2 * sz[i]) - D;\n        if(D[a] != D[i] - N + 2 * sz[i]) {\n            printf(\"-1\");\n            return 0;\n        }\n\n        edge.push_back(pii(inv[a], inv[i]));\n        sz[a] += sz[i];\n    }\n    if(sz[0] != N) {\n        printf(\"-1\");\n        return 0;\n    }\n\n    for(int i = 0; i < N - 1; i++) {\n        printf(\"%d %d\\n\", edge[i].first + 1, edge[i].second + 1);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define LL long long\n#define pii pair<LL, int>\nusing namespace std;\nconst int N = 1e5 + 10;\n\nint n, m;\nint a[N], b[N];\nLL d[N], siz[N];\nmap<LL, int> Map;\npriority_queue<pii> Q;\n\nvoid doit(int cnt) {\n\tpii tmp = Q.top(); Q.pop();\n\tint to = Map[d[tmp.se] - (n - siz[tmp.se] * 2)];\n\tif (!to || tmp.se == to) puts(\"-1\"), exit(0);\n\ta[cnt] = to;\n\tb[cnt] = tmp.se;\n\tif (siz[tmp.se] * 2 > n) puts(\"-1\"), exit(0);\n\tsiz[to] += siz[tmp.se];\n}\n\nnamespace check {\n\tLL res = 0;\n\tint E, fir[N], nex[N << 1], arr[N << 1];\n\n\tvoid Add_Edge(int x, int y) {\n\t\tnex[++E] = fir[x];\n\t\tfir[x] = E; arr[E] = y;\n\t}\n\n\tvoid dfs(int x, int fa, LL dx) {\n\t\tres += dx;\n\t\tfor (int i = fir[x]; i; i = nex[i]) {\n\t\t\tif (arr[i] == fa) continue;\n\t\t\tdfs(arr[i], x, dx + 1);\n\t\t}\n\t}\n\t\n\tvoid main() {\n\t\tfor (int i = 1; i < n; ++i) {\n\t\t\tAdd_Edge(a[i], b[i]);\n\t\t\tAdd_Edge(b[i], a[i]);\n\t\t}\n\t\tint tmp = 1;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tif (d[i] > d[tmp]) tmp = i;\n\t\t}\n\t\tdfs(tmp, 0, 0);\n\t\tif (res != d[tmp]) puts(\"-1\"), exit(0);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%lld\", &d[i]);\n\t\tMap[d[i]] = i;\n\t\tQ.push(make_pair(d[i], i));\n\t}\n\tif (n == 1 && d[1]) return 0 * puts(\"-1\");\n\tfor (int i = 1; i <= n; ++i)\n\t\tsiz[i] = 1;\n\tfor (int i = 1; i < n; ++i)\n\t\tdoit(i);\n\tcheck::main();\n\tfor (int i = 1; i < n; ++i)\n\t\tprintf(\"%d %d\\n\", a[i], b[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define eb emplace_back\n#define fi first\n#define se second\nusing namespace std;\nusing cd = complex <double>;\n\nconst long long INF = 1e18; \nconst long long mod = 998244353;//200003;786433;1e9 + 7;\nconst double Pi = acos(-1);\n  \nvoid Fastio()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n}\n\nint n;\nint root;\nint dsu[100005];\nlong long mindis = INF;\nlong long d[100005], sz[100005];\nmap <long long, int> M; \nvector <pair <int, int> > Edge;\nvector <int> Adj[100005];\n\nint Root(int node)\n{\n\treturn dsu[node] == node ? node : dsu[node] = Root(dsu[node]);\n}\n\nsigned main()\n{\n\tFastio();\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tcin >> d[i];\n\t\tsz[i] = 1;\n\t\tM[d[i]] = i;\n\t\tdsu[i] = i;\n\t\tif(d[i] < mindis)\n\t\t{\n\t\t\troot = i;\n\t\t\tmindis = d[i];\n\t\t}\n\t}\n\twhile(M.size() > 1)\n\t{\n\t\tpair <long long, int> temp = *(prev(M.end()));\n\t\tlong long realdis = temp.fi - n + sz[temp.se] * 2;\n\t\tif(M.count(realdis) == false)\n\t\t{\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\tif(Root(temp.se) == Root(M[realdis]))\n\t\t{\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\tdsu[Root(temp.se)] = Root(M[realdis]);\n\t\tEdge.eb(temp.se, M[realdis]);\n\t\tsz[M[realdis]] += sz[temp.se];\n\t\tM.erase(temp.fi);\n\t}\n\tif(Edge.size() != n - 1 || sz[root] != n)\n\t{\n\t\tcout << \"-1\";\n\t\treturn 0;\n\t}\n\tfor(auto x : Edge)\n\t{\n\t\tcout << x.fi << ' ' << x.se << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<60)+1e9; // ~ 1.15 * 1e18\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\n\nInt check(vector<vector<Int> > G, Int root,Int d){\n\n  function<Int(Int,Int,Int)>  dfs = [&](Int pos,Int pre,Int dis){\n    Int res = dis;\n    for(Int to:G[pos]){\n      if(to == pre) continue;\n      res += dfs(to, pos, dis+1);\n    }\n    return res;\n  };\n  return dfs(root, -1, 0) == d;\n}\n\nsigned main(){\n  srand((unsigned)time(NULL));\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  Int n;\n  cin>>n;\n  vector<P> D(n);\n  map<Int,Int> num;\n  for(Int i=0;i<n;i++){\n    Int d;\n    cin>>d;\n    D[i] = P(d, i);\n    num[d] = i;\n  }\n  sort(D.begin(), D.end(), greater<P>());\n\n  vector<Int> sz(n, 1);\n  vector<vector<Int> > G(n);\n\n  auto add_edge = [&](Int a,Int b){\n    G[a].push_back(b);\n    G[b].push_back(a);\n  };\n\n  \n  for(Int i=0;i<n-1;i++){\n    Int d, pos; tie(d, pos) = D[i];\n    Int x  = sz[pos];\n    Int nd = d + x - (n - x);\n\n    if(!num.count(nd)){\n      cout<<-1<<endl;\n      return 0;\n    }\n    Int to = num[nd];\n    if(d <= nd){\n      cout<<-1<<endl;\n      return 0;\n    }\n\n    add_edge(pos, to);\n    sz[to] += sz[pos];\n  }\n\n  \n  if(!check(G, D[n-1].second, D[n-1].first)){\n    cout<<-1<<endl;\n    return 0;\n  }\n\n  \n  for(Int i=0;i<n;i++)\n    for(Int to:G[i]){\n      if(i > to) continue;\n      cout<<i+1<<\" \"<<to+1<<endl;\n    }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  \n  int n;\n  cin >> n;\n  vector<long long> d(n);\n  for (int i = 0; i < n; i++) {\n    cin >> d[i];\n  }\n\n  vector<int> ord(n);\n  iota(ord.begin(), ord.end(), 0);\n  sort(ord.begin(), ord.end(), [&](int i, int j) { return d[i] > d[j]; });\n  ord.pop_back();\n\n  map<long long, int> mp;\n  for (int i = 0; i < n; i++) {\n    mp[d[i]] = i;\n  }\n  vector<int> sz(n, 1), par(n, -1);\n\n  for (auto i : ord) {\n    long long par_d = d[i] + sz[i] - (n - sz[i]);\n    if (mp.count(par_d) == 0 || mp[par_d] == i || par[mp[par_d]] != -1) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n    par[i] = mp[par_d];\n    sz[par[i]] += sz[i];\n  }\n\n  for (int i = 0; i < n; i++) {\n    if (par[i] != -1) {\n      cout << i + 1 << ' ' << par[i] + 1 << '\\n';\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <cmath>\n#include <bitset>\n#include <algorithm>\n#include <map>\n#include <vector>\ntypedef long long ll;\nusing namespace std;\nconst int maxn=101000;\nint n;\nll d[maxn];\nint size[maxn];\nll dis[maxn];\nmap<ll,int> mp;\nvector<int> G[maxn];\nll sum=0;\n\nvoid dfs1(int u,int fa){\n    for(int i=0;i<G[u].size();i++){\n        int v=G[u][i];\n        if(v==fa) continue;\n        dis[v]=dis[u]+1;\n        dfs1(v,u);\n    }\n    sum+=dis[u];\n}\n\nvoid dfs2(int u,int fa){\n    for(int i=0;i<G[u].size();i++){\n        int v=G[u][i];\n        if(v==fa) continue;\n        printf(\"%d %d\\n\",u,v);\n        dfs2(v,u);\n    }\n}\n\nint main(){\n    //初始化\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        scanf(\"%lld\",&d[i]);\n        mp[d[i]]=i;\n    }\n    sort(d+1,d+n+1);\n    for(int i=1;i<=n;i++) size[i]=1;\n    //构树\n    for(int i=n;i>1;i--){\n        int k=mp[d[i]];\n        int tmp=n-2*size[k];\n        printf(\"%d   111\\n\",i);\n        if(tmp<=0) {printf(\"-1\\n\");return 0;}\n        ll ss=d[i]-tmp;\n        printf(\"%d    222\\n\",i);\n        if(mp.count(ss)==0){printf(\"-1\\n\");return 0;}\n        int pos=mp[ss];\n        size[pos]+=size[k];\n        G[pos].push_back(k);\n        G[k].push_back(pos);\n    }\n   // printf(\"sbsbsb\\n\");\n    dis[mp[d[1]]]=0;\n    dfs1(mp[d[1]],-1);\n    if(sum!=d[1]){\n        printf(\"-1\\n\");\n    }else{\n        dfs2(1,-1);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N;\nmap<long long,int> id;\nlong long seq[100050];\nint sz[100050];\nvector<int> v[100050];\nlong long ans = 0;\n\nvoid Serval(int pos,int dep,int lst)\n{\n\tans += dep;\n\tfor(int i = 0;i < v[pos].size(); ++ i)\n\t{\n\t\tint nxt = v[pos][i];\n\t\tif(nxt != lst)\n\t\t\tServal(nxt,dep + 1,pos);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i = 1;i <= N; ++ i)\n\t\tscanf(\"%lld\",&seq[i]),id[seq[i]] = i,sz[i] = 1;\n\tsort(seq + 1,seq + 1 + N);\n\tfor(int i = N;i >= 2; -- i)\n\t{\n\t\tint delta = N - 2 * sz[id[seq[i]]];\n\t\tif(delta < 0)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tlong long to_find = seq[i] - delta;\n\t\tif(!id.count(to_find))\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tsz[id[to_find]] += sz[id[seq[i]]];\n\t\tv[id[seq[i]]].push_back(id[to_find]);\n\t\tv[id[to_find]].push_back(id[seq[i]]);\n\t}\n\tServal(id[seq[1]],0,0);\n\tif(ans != seq[1])\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i = 1;i <= N; ++ i)\n\t{\n\t\tfor(int j = 0;j < v[i].size(); ++ j)\n\t\t{\n\t\t\tint nxt = v[i][j];\n\t\t\tif(nxt > i) printf(\"%d %d\\n\",i,nxt);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define D(x) D[id[x]]\nusing namespace std;\nint n,D[100005],id[100005],fa[100005],sz[100005],k,l,r,Mid,tmp,i;\nbool cmp(int x,int y){return D[x]>D[y];}\n\nint find(int x){\n\tfor (l=1,r=n,Mid=(l+r>>1); l<r; Mid=(l+r>>1))\n\t\t(D(Mid)>x) ? (l=Mid+1) : (r=Mid);\n\treturn Mid;\n}\n\nint main(){\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor (i=1; i<=n; i++) scanf(\"%d\",&D[i]),id[i]=i,sz[i]=1;\n\tsort(id+1,id+n+1,cmp);\n\tfor (i=1; i<n; i++){\n\t\ttmp=D(i)-n+2*sz[id[i]];\n\t\tk=find(tmp);\n\t\tif (tmp==D(i) || D(k)!=tmp) {printf(\"-1\"); return 0;}\n\t\tfa[id[i]]=id[k],sz[id[k]]+=sz[id[i]];\n\t}\n\tfor (i=1; i<n; i++) printf(\"%d %d\\n\",id[i],fa[id[i]]);\n}\n\n/*\nD[fa[x]]=D[x]-n+2*sz[x]\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#define Maxn 1000008 \nusing namespace std;\ntypedef long long ll;\n\nint n,cnt,tot,imp;\nint U[Maxn],V[Maxn];\nll d;\nbool vis[Maxn];\nint son[Maxn],head[Maxn];\nmap <ll,int> M;\n\nstruct node{\n\tint num;\n\tll val;\n}N[Maxn];\n\nstruct edge{\n\tint to,next;\n}E[Maxn];\n\nvoid adde(int u,int v)\n{\n\tE[tot].to = v;\n\tE[tot].next = head[u];\n\thead[u] = tot++;\n}\n\nvoid dfs(int u,int val)\n{\n\timp += val,vis[u] = 1;\n\tfor(int i = head[u];~i;i = E[i].next)\n\t{\n\t\tint v = E[i].to;\n\t\tif(vis[v]) continue;\n\t\tdfs(v,val+1);\n\t}\n}\n\nbool cmp(node a,node b){\treturn a.val > b.val;}\n\nint main()\n{\n\tmemset(vis,0,sizeof(vis));\n\tmemset(head,-1,sizeof(head));\n\tmemset(son,0,sizeof(son));\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\tscanf(\"%lld\",&d);\n\t\tM[d] = i;\n\t\tN[i].num = i,N[i].val = d;\n\t}\n\tsort(N+1,N+1+n,cmp);\n\tmap<ll,int>::iterator iter;;\n\tfor(int i = 1;i < n;i ++)\n\t{\n\t\tint u = N[i].num;\n\t\titer = M.find(N[i].val - n + 2 + (son[u] << 1));\n\t\tif(iter == M.end())\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tint v = iter->second;\n\t\tson[v] += son[u]+1;\n\t\tadde(u,v);adde(v,u);\n\t\tU[cnt] = u,V[cnt++] = v;\n\t}\n\tdfs(N[n].num,0);\n\tif(N[n].val != imp){\tprintf(\"-1\\n\");return 0;}\n\tfor(int i = 0;i < cnt;i ++) printf(\"%d %d\\n\",U[i],V[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#define MAXN 100005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nint n,d[MAXN],p[MAXN],sz[MAXN];\nll f[MAXN],g[MAXN];\nvector<P> v;\nvector<int> G[MAXN];\nvector<P> E;\nvoid add_edge(int u,int v)\n{\n    G[u].push_back(v);G[v].push_back(u);\n    E.push_back(P(u,v));\n}\nvoid dfs1(int v,int p)\n{\n    sz[v]=1;\n    for(auto to:G[v])\n    {\n        if(to==p) continue;\n        dfs1(to,v);\n        sz[v]+=sz[to];\n        f[v]+=sz[to]+f[to];\n    }\n}\nvoid dfs2(int v,int p)\n{\n    for(auto to:G[v])\n    {\n        if(to==p) continue;\n        g[to]=g[v]+n-2*sz[to];\n        dfs2(to,v);\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&d[i]);\n    for(int i=1;i<=n;i++) v.push_back(P(d[i],i));\n    sort(v.begin(),v.end());\n    bool fl=true;\n    for(int i=n-1;i>0;i--)\n    {\n        sz[v[i].S]++;\n        ll to=d[v[i].S]+2*sz[v[i].S]-n;\n        auto it=lower_bound(v.begin(),v.end(),P(to,0));\n        if(it==v.end()||it->F!=to) \n        {\n            fl=false;\n            break;\n        }\n        add_edge(v[i].S,it->S);\n        p[v[i].S]=it->S;\n        sz[it->S]+=sz[v[i].S];\n    }\n    if(!fl)\n    {\n        puts(\"-1\");\n        return 0;\n    }\n    dfs1(v[0].S,0);g[v[0].S]=f[v[0].S];dfs2(v[0].S,0);\n    for(int i=1;i<=n;i++) if(g[i]!=d[i]) {puts(\"-1\"); return 0;}\n    for(auto p:E) printf(\"%lld %lld\\n\",p.F,p.S);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\n#define to(k) E[k].to\n#define next(k) E[k].next\n#define fuck_it_up return !puts(\"-1\")\n\nusing namespace std ;\n\ntypedef long long ll ;\n\nconst int N = 200010 ;\n\nint n ;\nll minx ;\nint cnt ;\nint sz[N] ;\nint fa[N] ;\nll dis[N] ;\nint head[N] ;\nstruct tree{\n    int id ;\n    ll val ;\n}base[N] ;\nstruct Edge{\n    int to ;\n    int next ;\n}E[N * 2] ;\nmap <ll, int> s ;\n\nbool comp(tree a, tree b){\n    return a.val > b.val ;\n}\nvoid add(int u, int v){\n    to(++ cnt) = v ;\n    next(cnt) = head[u] ;\n    head[u] = cnt ;\n}\nvoid dfs(int x){\n    for (int k = head[x] ; k ; k = next(k))\n        dis[to(k)] = dis[x] + n - 2 * sz[to(k)], dfs(to(k)) ;\n}\nint main(){\n    cin >> n ;\n    for (int i = 1 ; i <= n ; ++ i) sz[i] = 1 ;\n    for (int i = 1 ; i <= n ; ++ i){\n        scanf(\"%lld\", &base[i].val) ;\n        s[base[i].val] = base[i].id = i ;\n    }\n    sort(base + 1, base + n + 1, comp) ;\n    for (int i = 1 ; i < n ; ++ i){\n        int x = base[i].id ;\n        ll y = base[i].val ;\n        int delta = n - 2 * sz[x] ;\n        if (delta <= 0) fuck_it_up ;\n        if (!s.count(y - delta)) fuck_it_up ;\n        fa[x] = s[y - delta] ; minx += sz[x] ;\n        sz[fa[x]] += sz[x] ; add(fa[x], x) ;\n    }\n   // for (int i = 1 ; i <= n ; ++ i) cout << fa[i] << \" \" ;\n    dis[base[n].id] = minx ; dfs(base[n].id) ;\n    for (int i = 1 ; i <= n ; ++ i)\n        if (dis[base[i].id] != base[i].val) fuck_it_up ;\n    for (int i = 1 ; i < n ; ++ i)\n        cout << base[i].id << \" \" << fa[base[i].id] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Distance Sums\n\nusing P = pair<int64_t, int64_t>;\n\nvector<int64_t> graph[100001];\nbool visited[100001];\nP dfs(int64_t v) {  // firstが和,secondがサイズ\n  visited[v] = true;\n  int64_t sum = 0;\n  int64_t size = 1;\n  for (const auto& e : graph[v]) {\n    if (!visited[e]) {\n      auto tmp = dfs(e);\n      sum += tmp.first + tmp.second;\n      size += tmp.second;\n    }\n  }\n  return make_pair(sum, size);\n}\n\nint main() {\n  int64_t N;\n  cin >> N;\n  map<int64_t, P> mp;\n  int64_t check;\n  for (int64_t i = 1; i <= N; i++) {\n    int64_t x;\n    cin >> x;\n    mp[x] = make_pair(i, 1);  // 頂点番号と木のサイズ\n    if (i == 1) check = x;\n  }\n  if (N == 2) {\n    cout << -1 << endl;\n    return 0;\n  }\n  vector<P> ans;\n  auto enditr = mp.rend();\n  enditr--;\n  for (auto itr = mp.rbegin(); itr != enditr; ++itr) {\n    auto key = itr->first;\n    auto value = itr->second;\n    auto vertex = value.first;\n    auto size = value.second;\n    auto child_key = (key + 2 * size) - N;\n    if (child_key >= key) continue;\n    auto tmpitr = mp.find(child_key);\n    if (tmpitr != mp.end()) {\n      auto tmp = tmpitr->second;\n      mp.at(child_key) = make_pair(tmp.first, tmp.second + size);\n      ans.push_back(make_pair(vertex, tmp.first));\n      graph[vertex].push_back(tmp.first);\n      graph[tmp.first].push_back(vertex);\n    }\n  }\n  if (ans.size() == N - 1) {\n    // これが本当に条件を満たしているか確かめればおそらくACがくる．←模範解答はそうだった．\n    // ただ，「不可能なのに可能と言ってしまっている」原因はわからない．\n    // 理由はおそらく，相対値しか見ていないから．\n    // 一頂点について計算してみる．\n    fill(visited, visited + 100001, false);\n    auto L = dfs(1);\n    // cout << L.first << ' ' << check << endl;\n    if (L.first == check) {\n      for (const auto& e : ans) {\n        cout << e.first << ' ' << e.second << endl;\n      }\n    } else {\n      cout << -1 << endl;\n    }\n\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <algorithm>\n#include <map>\n#define MN 100000\n#define MM 200000\nint n,hd[MN+5],to[MM+5],nxt[MM+5],rn=0;\nstd::map<int,int> mp;\ntypedef std::map<int,int>::iterator iter;\nstruct node{int i,d,sz;}a[MN+5];\nvoid _add(int u,int v){\n\tto[rn]=v,nxt[rn]=hd[u];\n\thd[u]=rn++;\n}\nvoid add(int u,int v){_add(u,v),_add(v,u);}\nvoid gg(){puts(\"-1\");exit(0);}\nnamespace CHECK{\n\t#include <stdio.h>\n\t#include <string.h>\n\t#include <algorithm>\n\ttypedef long long LL;\n\tLL tl[MN+5]; int tc[MM+5];\n\tint gettc(int u,int fa){\n\t\tint ret=1;\n\t\tfor(int i=hd[u];~i;i=nxt[i]){\n\t\t\tif(to[i]==fa) continue;\n\t\t\ttc[i]=gettc(to[i],u);\n\t\t\ttc[i^1]=n-tc[i];\n\t\t\tret+=tc[i];\n\t\t}\n\t\treturn ret;\n\t}\n\tLL dfs_tl(int u,int fa,int dep){\n\t\tLL ret=0;\n\t\tfor(int i=hd[u];~i;i=nxt[i]){\n\t\t\tif(to[i]==fa) continue;\n\t\t\tret+=dfs_tl(to[i],u,dep+1);\n\t\t}\n\t\treturn ret+dep;\n\t}\n\tvoid dp_tl(int u){\n\t\tfor(int i=hd[u];~i;i=nxt[i]){\n\t\t\tif(tl[to[i]]!=-1) continue;\n\t\t\ttl[to[i]]=tl[u]-tc[i]+tc[i^1];\n\t\t\tdp_tl(to[i]);\n\t\t}\n\t}\n\tinline void gettl(){\n\t\ttl[1]=dfs_tl(1,0,0);\n\t\tdp_tl(1);\n\t}\n\tvoid main(){\n\t\tmemset(tl,0xff,sizeof(tl));\n\t\tgettc(1,0); gettl();\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(tl[a[i].i]!=a[i].d) gg();\n\t}\n}\nint main(){\n\tmemset(hd,0xff,sizeof(hd));\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i].d);\n\t\ta[i].i=i,a[i].sz=1;\n\t}\n\tstd::sort(a+1,a+1+n,[](node a,node b)->bool{return a.d>b.d;});\n\tfor(int i=1;i<=n;i++) mp[a[i].d]=i;\n\tfor(int i=1;i<=n;i++){\n\t\tint dta=n-(a[i].sz<<1);\n\t\tif(dta<=0) continue;\n\t\titer it=mp.find(a[i].d-dta);\n\t\tif(it==mp.end()) continue;\n\t\ta[it->second].sz+=a[i].sz;\n\t\tadd(a[i].i,a[it->second].i);\n\t}\n\tif(rn!=(n-1)<<1) gg();\n\tCHECK::main();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=hd[i];~j;j=nxt[j])\n\t\t\tif(i<to[j]) printf(\"%d %d\\n\",i,to[j]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nmap<int,int> M1,M2;\nint s1[200010],pa[200010];\nstruct edge\n{\n\tint v,next;\n}vs[200010];\nint st[200010],ee,sz[200010],vis[20010];\ninline void addedge(int u,int v)\n{\n\tvs[++ee].v=v;vs[ee].next=st[u];st[u]=ee;\n}\t\ninline void dfs(int rt,int pr)\n{\n\tif(vis[rt])\n\t{\n\t\tassert(0);exit(0);\n\t}\n\tvis[rt]=1; sz[rt]=1;\n\tfor(int i=st[rt];i;i=vs[i].next)\n\t\tif(vs[i].v!=pr) dfs(vs[i].v,rt),sz[rt]+=sz[vs[i].v];\n}\nsigned main()\n{\n\tint n=read();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=read();\n\t\tM1[x]=i; M2[x]=1;\n\t\ts1[i]=x;\n\t}\n\tsort(s1+1,s1+1+n);\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tint id=M1[s1[i]],sz=M2[s1[i]],td=s1[i]+2*sz-n;\t\n\t\tif(td>=s1[i]) continue;\t\n\t\tpa[id]=M1[td]; M2[td]+=sz;\n\t}\n\tint rt=0;\n\tfor(int i=1;i<=n;i++) \n\t{\n\t\tif(pa[i]) addedge(pa[i],i),addedge(i,pa[i]);\n\t\telse \n\t\t{\n\t\t\tif(rt) assert(0);\n\t\t\telse rt=i;\n\t\t}\n\t}\n\tdfs(rt,0);\n\tif(sz[rt]!=n) assert(0);\n\telse\n\t{ \n\t\tfor(int i=1;i<=n;i++)\n\t\tif(pa[i]) printf(\"%lld %lld\\n\",i,pa[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define ll long long\n#define pii pair<ll,int>\n#define mp make_pair\nusing namespace std;\n\nll n,size[N];\nint e[N][2];\npii a[N];\n\ninline ll read()\n{\n\tll ans=0,f=1;char c=getchar();\n\twhile(c>'9'||c<'0') {if(c=='-') f=-1ll;c=getchar();}\n\twhile(c>='0'&&c<='9') ans=(ans<<1)+(ans<<3)+(c^48),c=getchar();\n\treturn ans*f;\n}\n\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;++i) a[i]=mp(read(),i),size[i]=1;\n\tsort(a+1,a+1+n);\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tll cur=a[i].first-n+2*size[i];\n\t\tint l=1,r=i-1;\n\t\twhile(l<r)\n\t\t{\n\t\t\tint mid=l+r>>1;\n\t\t\tif(a[mid].first<cur) l=mid+1;\n\t\t\telse r=mid;\n\t\t}\n\t\tif(a[l].first!=cur) return puts(\"-1\"),0;\n\t\te[i][0]=a[i].second;\n\t\te[i][1]=a[l].second;\n\t\tsize[l]+=size[i];\n\t}\n\tfor(int i=2;i<=n;++i) a[1].first-=size[i];\n\tif(a[1].first) return puts(\"-1\"),0;\n\tfor(int i=2;i<=n;++i) printf(\"%d %d\\n\",e[i][0],e[i][1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "/***************************************************************\n\tFile name: F.cpp\n\tAuthor: huhao\n\tCreate time: Mon 20 Jan 2020 04:12:26 PM CST\n***************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\n#define i64 long long\ni64 read()\n{\n\ti64 r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=r*10+c-48;\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define pii std::pair<i64,i64>\nconst int N=100010;\ni64 w[N],f[N],n,D[N];\npii d[N];\nint main()\n{\n\tn=read();\n\tfr(i,1,n) d[i]=pii(read(),i);\n\tstd::sort(d+1,d+n+1);\n\tfr(i,1,n) w[i]=1;\n\tfd(i,n,2)\n\t{\n\t\tpii F=*lower_bound(d+1,d+n+1,pii(d[i].first+w[d[i].second]-(n-w[d[i].second]),0));\n//\t\tprintf(\"%lld %lld\\n\",d[i].second,F.second);\n\t\tif(F.first!=d[i].first+w[d[i].second]-(n-w[d[i].second])){ printf(\"-1\\n\"); return 0; }\n\t\tf[d[i].second]=F.second; w[F.second]+=w[d[i].second];\n\t}\n\tfd(i,n,2) D[f[d[i].second]]+=D[d[i].second]+w[d[i].second];\n\tif(D[d[1].second]!=d[1].first){ printf(\"-1\\n\"); return 0; }\n\tfd(i,n,2) printf(\"%lld %lld\\n\",d[i].second,f[d[i].second]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 100003\nusing namespace std;\nstruct edge{int to,next;}e[maxn<<1];\nint head[maxn],cnte,fa[maxn];\nvoid add(int u,int v){e[++cnte].to=v,e[cnte].next=head[u],head[u]=cnte;}\nint n,sz[maxn],s[maxn];\nlong long d[maxn],sum;\nmap<long long,int> b;\nbool cmp(int x,int y){return d[x]<d[y];}\nvoid dfs(int u,int depth){\n\tsum+=depth;\n\tfor(int i=head[u];i;i=e[i].next){\n\t\tint v=e[i].to;\n\t\tif(v==fa[u])continue;\n\t\tdfs(v,depth+1);\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",d+i),s[i]=i,b[d[i]]=i,sz[i]=1;\n\tsort(s+1,s+n+1,cmp);\n\tfor(int i=n;i>=2;i--){\n\t\tint v=s[i],d_u=d[v]-(n-sz[v])+sz[v];\n\t\tif(d_u>=d[v]||!b.count(d_u)){puts(\"-1\");return 0;}\n\t\tint u=b[d_u];\n\t\tadd(u,v),add(v,u),fa[v]=u;\n\t\tsz[u]+=sz[v];\n\t}\n\tdfs(s[1],0);\n\tif(sum!=d[s[1]]){puts(\"-1\");return 0;}\n\tfor(int u=1;u<=n;u++){\n\t\tfor(int i=head[u];i;i=e[i].next){\n\t\t\tint v=e[i].to;\n\t\t\tif(v==fa[u])continue;\n\t\t\tprintf(\"%d %d\\n\",u,v);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,fma,abm,mmx,avx,avx2,tune=native\")\n#include <bits/stdc++.h>\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#ifdef rd\n#define trace(...) cout<<\"Line:\"<<__LINE__<<\" \"; __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate<typename Arg1>\nvoid __f(const char *name, Arg1 &&arg1) {\n\tcout<<name<<\" : \"<<arg1<<endl;\n}\ntemplate<typename Arg1, typename ... Args>\nvoid __f(const char *names, Arg1 &&arg1, Args &&... args) {\n\tconst char *comma=strchr(names+1,',');\n\tcout.write(names,comma-names)<<\" : \"<<arg1<<\" | \";\n\t__f(comma+1,args...);\n}\n#else\n#define trace(...)\n#define endl '\\n'\n#endif\n#define pb push_back\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\ntypedef float f80;\n#define double long double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define sz(x) ((long long)x.size())\n#define fr(a,b,c) for(int a=b; a<=c; a++)\n#define rep(a,b,c) for(int a=b; a<c; a++)\n#define trav(a,x) for(auto &a:x)\n#define all(con) con.begin(),con.end()\nconst ll infl=0x3f3f3f3f3f3f3f3fLL;\nconst int infi=0x3f3f3f3f;\nconst int mod=998244353;\n//const int mod=1000000007;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef tree<pii, null_type, less<pii>, rb_tree_tag, tree_order_statistics_node_update> oset;\nauto clk=clock();\nmt19937_64 rang(chrono::high_resolution_clock::now().time_since_epoch().count());\nint rng(int lim) {\n\tuniform_int_distribution<int> uid(0,lim-1);\n\treturn uid(rang);\n}\n\nint powm(int a, int b) {\n\tint res=1;\n\twhile(b) {\n\t\tif(b&1)\n\t\t\tres=(res*a)%mod;\n\t\ta=(a*a)%mod;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nint d[100005];\nmap<int,int> sz;\nmap<int,int> vert;\nmap<int,int> par;\nvoid solve() {\n\tint n;\n\tcin>>n;\n\tfr(i,1,n) {\n\t\tcin>>d[i];\n\t\tvert[d[i]]=i;\n\t\tsz[d[i]]=1;\n\t}\n\tsort(d+1,d+n+1);\n\tfor(int i=n; i>1; i--) {\n\t\tint tol=d[i]-n+2*sz[d[i]];\n//\t\tcout<<d[i]<<\" \"<<tol<<endl;\n\t\tif(tol>=d[i]||vert.find(tol)==vert.end()) {\n\t\t\tcout<<-1<<endl;\n\t\t\treturn;\n\t\t}\n\t\tpar[d[i]]=tol;\n\t\tsz[tol]+=sz[d[i]];\n\t}\n\tfr(i,2,n) {\n\t\tcout<<vert[d[i]]<<\" \"<<vert[par[d[i]]]<<endl;\n\t}\n}\n\nsigned main() {\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\tsrand(chrono::high_resolution_clock::now().time_since_epoch().count());\n\tcout<<fixed<<setprecision(10);\n\tint t=1;\n//\tcin>>t;\n\twhile(t--)\n\t\tsolve();\n#ifdef rd\n\tcout<<endl<<endl<<endl<<endl<<\"Time elapsed: \"<<(double)(clock()-clk)/CLOCKS_PER_SEC<<endl;\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int \n#define F first\n#define S second\n#define pb push_back\nconst ll N = 1e5 + 5, MOD =  1e9 + 7, INF = 1e9 + 10;\nconst long double PI = acos(-1);\nll n, sz[N], h[N];\npair <ll, ll> d[N];\nvector <ll> adj[N];\nunordered_map <ll, ll> mp;\nbool mrk[N];\nvoid dfs(int v){\n\tmrk[v] = 1;\n\tfor (int u : adj[v]){\n\t\tif (!mrk[u]){\n\t\t\th[u] = h[v] + 1;\n\t\t\tdfs(u);\n\t\t}\n\t}\n\treturn;\n}\nbool ok(){\n\tdfs(d[n].S);\n\tll all = 0;\n\tfor (int i = 1; i <= n; i++){\n\t\tall += h[i];\n\t}\n\treturn (all == d[n].F);\n}\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++){\n\t\tcin >> d[i].F;\n\t\td[i].S = i;\n\t\tmp[d[i].F] = i;\n\t}\n\tsort(d + 1, d + n + 1);\n\treverse(d + 1, d + n + 1);\n\tfor (int i = 1; i <= n; i++){\n\t\tint u = d[i].S;\n\t\tsz[u] = 1;\n\t\tfor (int v : adj[u]){\n\t\t\tsz[u] += sz[v];\n\t\t}\n\t\tll x = d[i].F + 2ll * (ll)sz[u] - (ll)n;\n\t\tif (mp.find(x) == mp.end()) break;\n\t\tadj[mp[x]].pb(u);\n\t}\n\tif (ok()){\n\t\tfor (int u = 1; u <= n; u++){\n\t\t\tfor (int v : adj[u]){\n\t\t\t\tcout << u << ' ' << v << '\\n';\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tcout << \"-1\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#include<iostream>\n#include<map>\n#include<vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__) \n#define ref(a,b,c) for(int a=b;a<=c;++a)\n#define def(a,b,c) for(int a=b;a>=c;--a)\n#define fi first\n#define se second\nusing namespace std;\ninline char nc(){\n//\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++; \n}\ntemplate<class T>void read(T &x){\n\tx=0;int f=1,ch=nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx*=f;\n}\ntypedef long long LL;\ntypedef pair<int,int> pii;\nconst int maxn=1e5+10;\nLL D[maxn];\nLL f[maxn];\nint n;\nint p[maxn];\nint siz[maxn];\nmap<LL,int>idx; \nvector<pii>an; \ninline int cmp(const int&a,const int&b){\n\treturn D[a]>D[b];\n}\nbool solve(){\n\tref(i,1,n)p[i]=i,siz[i]=1,f[i]=0;\n\tsort(p+1,p+n+1,cmp);\n\tref(i,1,n-1){\n\t\tint u=p[i];\n\t\tif(!idx.count(D[u]-n+2*siz[u]))return 0;\n\t\tint fa=idx[D[u]-n+2*siz[u]]; \n\t\tif(u==fa)return 0;\n\t\tan.push_back(make_pair(fa,u));\n\t\tsiz[fa]+=siz[u];\n\t\tf[fa]+=f[u]+siz[u];\n\t}\n\tif(f[p[n]]!=D[p[n]])return 0;\n\tref(i,0,n-2)printf(\"%d %d\\n\",an[i].fi,an[i].se);\n\treturn 1;\n}\nint main(){\n\tread(n);\n\tref(i,1,n){\n\t\tread(D[i]);\n\t\tidx[D[i]]=i;\n\t}\n\tif(!solve())puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXn = 1e5 + 10;\ntypedef pair<long long, int> pii;\npii ar[MAXn];\nlong long n, sz[MAXn], root, disroot, d[MAXn], hp3[MAXn];\nvector<int> vec[MAXn];\nvector<pii> ans;\n\nbool cmp(pii p1, pii p2) {\n\treturn p1.first > p2.first;\n}\n\nlong long dfs1(int v, int  par) {\n\tlong long res = 0;\n\tfor (int i = 0; i < vec[v].size(); i++)\n\t\tif (vec[v][i] != par) {\n\t\t\tres += dfs1(vec[v][i], v) + hp3[vec[v][i]];\n\t\t\thp3[v] += hp3[vec[v][i]];\n\t\t}\n\thp3[v]++;\n\n\treturn res;\n\t\n}\n\nvoid dfs2(int v, int par, long long sth) {\n\tif (sth != d[v]) {\n\t\tcout << -1;\n\t\texit(0);\n\t}\n\tfor (int i = 0; i < vec[v].size(); i++) {\n\t\tif (vec[v][i] != par) {\n\t\t\tdfs2(vec[v][i], v, sth - (hp3[vec[v][i]]) + (hp3[ar[0].second] - hp3[vec[v][i]]));\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}\nint main() {\n\tcin >> n;\n\tfill_n(sz, MAXn, 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tlong long di;\n\t\tcin >> di;\n\t\td[i] = di;\n\t\tar[i].first = di;\n\t\tar[i].second = i;\n\t}\n\tsort(ar, ar + n);\n\tfor (int i = n - 1; i > 0; i--) {\n\t\tlong long hp = ar[i].first - n;\n\t\thp += 2LL * sz[ar[i].second];\n\t\tint hp2 = lower_bound(ar, ar + n, pii(hp, -1)) - ar;\n\t\tif (ar[hp2].first != hp)\n\t\t\treturn cout << -1,0;\n\t\tsz[ar[hp2].second] += sz[ar[i].second];\n\t\tvec[ar[hp2].second].push_back(ar[i].second);\n\t\tvec[ar[i].second].push_back(ar[hp2].second);\n\t\tans.push_back(pii(ar[i].second, ar[hp2].second));\n\t}\n\tdisroot = dfs1(ar[0].second, -1);\n\tdfs2(ar[0].second, -1, disroot);\n\tif (ans.size() != n - 1)\n\t\treturn cout << -1,0;\n\tfor (int i = 0; i < ans.size(); i++)\n\t\tcout << ans[i].first + 1<< ' ' << ans[i].second + 1<< endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <algorithm>\n#include <map>\n#define MN 100000\n#define MM 200000\n#define int LL\ntypedef long long LL;\nint n,hd[MN+5],to[MM+5],nxt[MM+5],rn=0;\nstd::map<int,int> mp;\ntypedef std::map<int,int>::iterator iter;\nstruct node{int i,d,sz;}a[MN+5];\nvoid _add(int u,int v){\n\tto[rn]=v,nxt[rn]=hd[u];\n\thd[u]=rn++;\n}\nvoid add(int u,int v){_add(u,v),_add(v,u);}\nvoid gg(){puts(\"-1\");exit(0);}\n#undef int\nint main(){\n#define int LL\n\tmemset(hd,0xff,sizeof(hd));\n\tscanf(\"%lld\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i].d);\n\t\ta[i].i=i,a[i].sz=1;\n\t}\n\tstd::sort(a+1,a+1+n,[](node a,node b)->bool{return a.d>b.d;});\n\tfor(int i=1;i<=n;i++) mp[a[i].d]=i;\n\tfor(int i=1;i<=n;i++){\n\t\tint dta=n-(a[i].sz<<1);\n\t\tif(dta<=0) continue;\n\t\titer it=mp.find(a[i].d-dta);\n\t\tif(it==mp.end()) continue;\n\t\ta[it->second].sz+=a[i].sz;\n\t\tadd(a[i].i,a[it->second].i);\n\t}\n\tif(rn!=(n-1)<<1) gg();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=hd[i];~j;j=nxt[j])\n\t\t\tif(i<to[j]) printf(\"%lld %lld\\n\",i,to[j]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> pii;\n\npii inp[100005];\nint siz[100005];\nvector<pii> ans;\n\nint main() {\n\tint N; scanf(\"%d\", &N);\n\tfor (int i = 1; i <= N; i++) {\n\t\tll x; scanf(\"%lld\", &x);\n\t\tinp[i] = {x, i};\n\t\tsiz[i] = 1;\n\t}\n\tsort(inp + 1, inp + N + 1);\n\tfor (int i = N; i >= 2; i--) {\n\t\tll cur; int id;\n\t\ttie(cur, id) = inp[i];\n\t\tint del = N - 2 * siz[id];\n\t\tauto it = *lower_bound(inp + 1, inp + i, pii(cur - del, 0));\n\t\tif (it.first != cur - del || del <= 0 || siz[id] == N) return !printf(\"-1\");\n\t\tsiz[it.second] += siz[id];\n\t\tif (id > it.second) swap(id, it.second);\n\t\tans.push_back({id, it.second});\n\t}\n\tif (siz[inp[1].second] != N) return !printf(\"-1\");\n\tsort(ans.begin(), ans.end());\n\n\tfor (pii &x : ans) {\n\t\tprintf(\"%lld %d\\n\", x.first, x.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<ll,pll> plpl;\ntypedef tuple<ll,ll,ll> tl;\n//ll mod=1000000007;\nll mod=998244353;\nll inf=1000000000000000000;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n#define rrep(i,n,m) for(int i=n;i>=m;i--)\nll lmax(ll a,ll b){\n    if(a<b)return b;\n    else return a;\n}\nll lmin(ll a,ll b){\n    if(a<b)return a;\n    else return b;\n}\nint main(){\n    ll n;cin>>n;\n    ll d[n];\n    vector<pll> v;\n    ll num;\n    ll mi=inf;\n    rep(i,0,n){\n        cin>>d[i];\n        v.push_back(make_pair(d[i],i));\n        if(mi>d[i]){\n            mi=d[i];\n            num=i;\n        }\n    }\n    ll root=v[0].first;\n    ll now=-1;\n    ll sa=-1;\n    ll par=-1;\n    vector<pll> ans;\n  ll qq=1;\n  bool used[n];fill(used,used+n,false);\n    for(;;){\n      if(qq==n)break;\n        if(now==-1){\n            pll p=v[qq];\n            if(used[p.second]){\n              qq++;\n              continue;\n            }\n            now=p.first;\n            ll ban=p.second;\n            //cout<<now<<endl;\n            if(now>root+n-2){\n                cout<<-1<<endl;\n                return 0;\n            }\n            sa=now-root;\n          used[p.second]=true;\n            ans.push_back(make_pair(num,ban));\n            par=ban;\n        }\n        else{\n          pll g=make_pair(now+sa+2,0);\n            ll y=lower_bound(v.begin(),v.end(),g)-v.begin();\n            if(y==n){\n                if(sa!=n-2){\n                    cout<<-1<<endl;\n                    return 0;\n                }\n                now=-1;\n                sa=-1;\n              qq++;\n            }\n            else{\n                pll p=v[y];\n                if(p.first!=now+sa+2){\n                    cout<<-1<<endl;\n                    return 0;\n                }\n                ans.push_back(make_pair(par,p.second));\n                par=p.second;\n                now=p.first;\n                sa+=2;\n                used[p.second]=true;\n            }\n        }\n        \n        //cout<<now<<\" \";\n    }\n    rep(i,0,ans.size()){\n        if(ans[i].first>ans[i].second)swap(ans[i].first,ans[i].second);\n    }\n    sort(ans.begin(),ans.end());\n    rep(i,0,ans.size())cout<<ans[i].first+1<<\" \"<<ans[i].second+1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N = 1e5 + 10;\nlong long n, d[N], s[N];\nvector<int> gr[N];\nmap<long long, int> mp;\nint32_t main() {\n\tios_base::sync_with_stdio (false), cin.tie(0), cout.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> d[i], mp[d[i]] = i;\n\tsort(d, d + n, greater<int> ());\n\tfor (int i = 0; i < n; i++) {\n\t\tint v = mp[d[i]];\n\t\ts[v]++;\n\t\tint valpar = d[i] - n + 2 * s[v];\n//\t\tcout << \"i = \" << i << \" : \" << valpar << endl;\n\t\tif (!mp.count(valpar)) {\n\t\t\tif (i == n - 1)\n\t\t\t\tbreak;\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\tint par = mp[valpar];\n\t\tif (par == v) {\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\ts[par] += s[v];\n\t\tgr[v].push_back(par);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (auto u : gr[i])\n\t\t\tcout << i + 1 << \" \" << u + 1 << \"\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int N=1e5+10;\nstruct xxx{\n\tint y,nxt;\n}a[N*2];\nint h[N];\nstruct Data{\n\tint id;\n\tll val;\n\tData(){}\n\tData(int id1,ll val1){id=id1; val=val1;}\n\tfriend bool operator < (Data x,Data y){return x.val<y.val;}\n}d[N];\nll sz[N],Dis[N];\nll fa[N];\nint n,m,tot;\nvoid add(int x,int y){a[++tot].y=y; a[tot].nxt=h[x]; h[x]=tot;}\nbool solve(){\n\tint pre;\n\tsort(d+1,d+1+n);\n\tfor (int i=1;i<=n;++i) sz[i]=1;\n\tfor (int i=n;i>=2;--i){\n\t\tpre=lower_bound(d+1,d+1+n,Data(0,d[i].val-n+2*sz[i]))-d;\n\t\tif (pre==-1||d[pre].val!=d[i].val-n+2*sz[i]||pre==i) return false;\n\t\tfa[i]=pre; \n\t\tsz[fa[i]]+=sz[i];\n\t}\n\treturn true;\n}\nvoid dfs1(int x,int d){\n\tint u;\n\tDis[1]+=d;\n\tfor (int i=h[x];i!=-1;i=a[i].nxt){\n\t\tu=a[i].y;\n\t\tdfs1(u,d+1);\n\t}\n}\nvoid dfs2(int x){\n\tint u;\n\tfor (int i=h[x];i!=-1;i=a[i].nxt){\n\t\tu=a[i].y;\n\t\tDis[u]=Dis[x]+n-2*sz[u];\n\t\tdfs2(u);\n\t}\n}\nbool doublecheck(){\n\tmemset(h,-1,sizeof(h));\n\tfor (int i=1;i<=n;++i)\n\t\tadd(fa[i],i);\n\tdfs1(1,0);\n\tdfs2(1);\n\tsort(Dis+1,Dis+1+n);\n\tfor (int i=1;i<=n;++i) \n\t\tif (Dis[i]!=d[i].val) return false;\n\treturn true;\n}\n\nint main(){\n#ifndef ONLINE_JUDGE\n\t//freopen(\"a.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;++i) scanf(\"%lld\",&d[i].val),d[i].id=i;\n\tif (solve()){\n\t\tif (doublecheck())\n\t\t\tfor (int i=2;i<=n;++i) cout<<d[fa[i]].id<<\" \"<<d[i].id<<endl;\n\t\telse printf(\"-1\\n\");\n\t}\n\telse\n\t\tprintf(\"-1\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<unordered_map>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\n\nusing namespace std;\nint NOE(){\n    cout<<-1<<endl;\n    return 0;\n}\n\nunordered_map<ll,ll> mas;\n#define N 100010\nvector<ll> g[N];\nll n,d[N],s[N];\nvoid AddEdge(ll a,ll b){\n    s[b]+=s[a];\n    g[a].push_back(b);\n    g[b].push_back(a);\n}\n\nclass Judge{public:\n    ll f[N],s[N];\n    void dfs(ll x,ll bef){\n\tll res=0,sum=1;\n\tfor(auto y:g[x]){\n\t    if(y==bef)continue;\n\t    dfs(y,x);\n\t    res+=f[y];\n\t    sum+=s[y];\n\t}\n\ts[x]=sum;\n\tf[x]=res+sum-1;\n    }\n    bool Main(){\n\tdfs(0,-1);\n\treturn d[0]==f[0];\n    }\n};\nint main(){\n    cin>>n;\n    lol(i,n){\n\tcin>>d[i];\n\ts[i]=1;\n    }\n    sort(d,d+n,greater<ll>());\n    lol(i,n)mas[d[i]]=i;\n    lol(i,n-1){\n\tll to=d[i]+2*s[i]-n;\n\tif(d[i]<=to)return NOE();\n\tif(mas.find(to)==mas.end())return NOE();\n\tAddEdge(i,mas[to]);\n    }\n    Judge jd;\n    if(jd.Main()==0)return NOE();\n    lol(i,n){\n\tfor(auto x:g[i]){\n\t    if(i<x)cout<<i+1<<\" \"<<x+1<<endl;\n\t}\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 998244353\n#define ny 499122177\n#define maxn 1000000000000000000LL\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nlong long n,i,x,zz[100005],sum[100005];\nstruct nyh{\n\tlong long x,id;\n}o[100005];\nmap<long long,long long> mp;\nbool cmp(nyh u,nyh v){\n\treturn u.x<v.x;\n}\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read();\n\tfor(i=1;i<=n;i++){\n\t\to[i].x=read();\n\t\to[i].id=i;\n\t}\n\tsort(o+1,o+n+1,cmp);\n\tfor(i=1;i<=n;i++){\n\t\tmp[o[i].x]=i;\n\t\tsum[i]=1;\n\t}\n\tfor(i=n;i>=2;i--){\n\t\tx=o[i].x-n+sum[i]*2;\n\t\tif(mp[x]!=0&&mp[x]<i){\n\t\t\tzz[i]=mp[x];\n\t\t\tsum[zz[i]]+=sum[i];\n\t\t}\n\t\telse{\n\t\t\tpus(-1,2);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(i=n;i>=2;i--){\n\t\tpus(o[zz[i]].id,1);\n\t\tpus(o[i].id,2);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/********************************************************************************\n\t\n\tCode by a weak man who named CYJian, and he hopes the code can get more points.\n\n\tAlgorithm: \n\n ********************************************************************************/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n//{{{ FAST IO AND SOME FUNCTIONS\nconst int __SIZE = 1 << 18;\nchar ibuf[__SIZE], *iS, *iT;\n\n#define ge (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n#define ri read_int()\n#define rl read_ll()\n#define ra read_alpha()\n#define FILE(s) freopen(s\"in\", \"r\", stdin), freopen(s\"out\", \"w\", stdout)\n\ntemplate<typename T>\ninline void read(T &x) {\n\tchar ch, t = 0; x = 0;\n\twhile(!isdigit(ch = ge)) t |= ch == '-';\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = ge;\n\tx = t ? -x : x;\n}\ninline char read_alpha() { char c = ge; while(!isalpha(c) && c != EOF) c = ge; return c; }\ninline int read_int() { int x; return read(x), x; }\ninline ll read_ll() { ll x; return read(x), x; }\n\ntemplate<typename T> inline void chkmin(T&a, T b) { a = a < b ? a : b; }\ntemplate<typename T> inline void chkmax(T&a, T b) { a = a > b ? a : b; }\n//}}}\n\nconst int MAXN = 100010;\n\nll d[MAXN];\nint sz[MAXN];\nint u[MAXN];\nint v[MAXN];\n\nint main() {\n#ifdef LOCAL\n\tFILE(\"\");\n#endif\n\tint n = ri;\n\tfor(int i = 1; i <= n; i++) d[i] = rl, sz[i] = 1;\n\tsort(d + 1, d + 1 + n);\n\tll dis = 0, N = 0;\n\tfor(int i = n; i > 1; i--) {\n\t\tint p = lower_bound(d + 1, d + 1 + n, d[i] - n + (sz[i] << 1)) - d;\n\t\tif(d[p] != d[i] - n + (sz[i] << 1)) return puts(\"-1\"), 0;\n\t\tsz[p] += sz[i], ++N, u[N] = i, v[N] = p, dis += sz[i];\n\t}\n\tif(dis != d[1]) puts(\"-1\");\n\telse\n\t\tfor(int i = 1; i <= N; i++)\n\t\t\tprintf(\"%d %d\\n\", u[i], v[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n \nint n,nn;\nstruct node{int p,f,s;long long d;};\nnode a[100010];\n \nvoid qsort(int l,int r)\n{\n\tint i,j;\n\tnode m,t;\n\ti=l;j=r;\n\tm=a[(l+r)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (a[i].d>m.d) i++;\n\t\twhile (a[j].d<m.d) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tt=a[i];a[i]=a[j];a[j]=t;\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort(l,j);\n\tif (i<r) qsort(i,r);\n}\n\nint find(long long x)\n{\n\tint l=1,r=n;\n\tint m=(l+r)/2;\n\twhile (l<=r)\n\t{\n\t\tif (a[m].d==x) return m;\n\t\tif (a[m].d>x) l=m+1;\n\t\telse r=m-1;\n\t\tm=(l+r)/2;\n\t}\n\treturn -1;\n}\n \nint main()\n{\n\tscanf(\"%d\",&n);\n\tnn=n-2;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&a[i].d);\n\t\ta[i].p=i;\n\t\ta[i].f=-1;\n\t\ta[i].s=1;\n\t}\n\tqsort(1,n);\n\tbool ok=true;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tlong long fd=a[i].d-(n-a[i].s*2);\n\t\tint fn;\n\t\tfn=find(fd);\n\t\tif (fn==-1 || fn==i || fd>a[i].d) {ok=false;break;}\n\t\ta[i].f=a[fn].p;\n\t\ta[fn].s+=a[i].s;\n\t}\n\tif (ok)\n\t{\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tif (a[i].f!=-1) printf(\"%d %d\\n\",a[i].f,a[i].p);\n\t\t}\n\t}\n\telse printf(\"-1\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int \n#define F first\n#define S second\n#define pb push_back\nconst ll N = 1e5 + 5, MOD =  1e9 + 7, INF = 1e9 + 10;\nconst long double PI = acos(-1);\npair <ll, ll> d[N];\nmap <ll, ll> mp;\nvector <ll> adj[N];\nll sz[N];\nll h[N];\nbool mrk[N];\nll n;\nvoid dfs(int v){\n\tmrk[v] = true;\n\tfor(int u : adj[v]){\n\t\tif(!mrk[u]){\n\t\t\th[u] = h[v] + 1;\n\t\t\tdfs(u);\n\t\t}\n\t}\n}\nbool ok(){\n\tdfs(d[n].S);\n\tll all = 0;\n\tfor (int i = 1; i <= n; i++){\n\t\tall += h[i];\n\t}\n\treturn (all == d[n].F);\n}\nint main(){\n\tcin >> n;\n\tfor (ll i = 1; i <= n; i++){\n\t\tcin >> d[i].F;\n\t\td[i].S = i;\n\t\tmp[d[i].F] = i; \n\t}\n\tsort(d + 1, d + n + 1);\n\treverse(d + 1, d + n + 1);\n\tbool flag = true;\n\t\n\tfor (ll i = 1; i <= n - 1; i ++){\n\t\tint u = d[i].S;\n\t\tsz[u] = 1;\n\t\tfor(ll v : adj[d[i].second]){\n\t\t\tsz[u] += sz[v];\n\t\t}\n\t\tll x = d[i].F + 2 * sz[u] - n;\n\t\tauto f = mp.find(x);\n\t\tif(f == mp.end()) break;\n\t\tadj[mp[x]].pb(d[i].second);\n\t}\n\tif(ok()){\n\t\tfor(ll i = 1; i <= n; i ++){\n\t\t\tfor(ll u : adj[i]){\n\t\t\t\tcout << i  << ' ' << u << '\\n';\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tcout << \"-1\\n\";;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reg register\ntypedef long long ll;\nusing namespace std;\nconst int MN=1e5+5;\nint n,fa[MN],siz[MN],id[MN];\nll d[MN];\ninline bool cmp(int x,int y){return d[x]<d[y];}\nmap<ll,int>mp;\nll ans;\nint h[MN],cnt,to[MN],nxt[MN];\ninline void ins(int s,int t){\n\tto[++cnt]=t;nxt[cnt]=h[s];h[s]=cnt;\n}\nvoid dfs(int st,int fa=0,int dep=0){\n\tans+=dep;for(reg int i=h[st];i;i=nxt[i])dfs(to[i],st,dep+1);\n}\nint main(){\n\tios::sync_with_stdio(false);cin>>n;\n\tfor(reg int i=1;i<=n;i++)cin>>d[i],id[i]=i,siz[i]=1,mp[d[i]]=i;\n\tsort(id+1,id+1+n,cmp);reg int cnt=0;\n\tfor(reg int i=n;i>1;i--){\n\t\treg int pos=id[i];reg ll fad=d[pos]+2ll*siz[pos]-n;\n\t\tif(!mp[fad]||fad>=d[pos])return 0*puts(\"-1\");\n\t\treg int fap=mp[fad];siz[fap]+=siz[pos];ins(fap,pos);\n\t}\n\tdfs(id[1]);if(d[id[1]]^ans)return 0*puts(\"-1\");\n\tfor(reg int i=1;i<=n;i++)for(reg int j=h[i];j;j=nxt[j])printf(\"%d %d\\n\",i,to[j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mid ((s + e) / 2)\n#define makefast ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define comp(x) (lower_bound(vec.begin(), vec.end(), x) - vec.begin())\n#define lc (v * 2)\n#define rc (v * 2 + 1)\nlong long M = 1e9 + 7;\n//>>>>>>>>>>>>>>>>>>>>>>>\n\n#define int long long\n\nconst int N = 1e5 + 7;\n\nint d[N];\nint n, sz[N];\nmap <int, int> who;\nvector <int> ad[N];\nint sm = 0;\n\nvoid dfs(int v, int p = 0, int dis = 0) {\n\tsm += dis;\n\tfor (auto u: ad[v])\n\t\tif (u != p)\n\t\t\tdfs(u, v, dis + 1);\n}\n\nint32_t main() {\n\tmakefast;\n\tcin >> n;\n\tset <int> s;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> d[i];\n\t\twho[d[i]] = i;\n\t\ts.insert(-d[i]);\n\t\tsz[i] = 1;\n\t}\n\twhile (s.size() > 1) {\n\t\tint dis = -*s.begin();\n\t\ts.erase(-dis);\n\t\tint v = who[dis];\n\t\tdis += 2 * sz[v] - n;\n\t\tif (!who[dis]) {\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\tint u = who[dis];\n\t//\tcout << v << \" <> \" << u << \" \" << dis << endl;\n\t\tad[v].push_back(u);\n\t\tad[u].push_back(v);\n\t\tsz[u] += sz[v];\n\t}\n\tdfs(1);\n\tif (d[1] != sm) {\n\t\tcout << -1;\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (auto j: ad[i])\n\t\t\tif (i < j)\n\t\t\t\tcout << i << ' ' << j << '\\n';\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#define MIN_INT -2147483648\n#define MAX_INT 2147483647\n#define MIN_LONG -9223372036854775808L\n#define MAX_LONG 9223372036854775807L\n#define PI 3.141592653589793238462643383279502884L\n\n#define long long long int\n\nusing std::vector;\nusing std::map;\nusing std::set;\nusing std::string;\nusing std::pair;\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\n// @author: pashka\n\nvector<vector<int>> g;\n\nlong calc(int i, long s, int p) {\n    long res = s;\n    for (int x : g[i]) {\n        if (x != p)\n        res += calc(x, s + 1, i);\n    }\n    return res;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    vector<pair<long, int>> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i].first;\n        a[i].second = i;\n    }\n\n    std::sort(a.rbegin(), a.rend());\n\n    map<long, int> q;\n    for (int i = 0; i < n; i++) {\n        q[a[i].first] = i;\n    }\n\n    vector<int> s(n);\n\n    g.resize(n);\n\n    for (int i = 0; i < n - 1; i++) {\n        s[i]++;\n        long p = a[i].first - (n - 2 * s[i]);\n        if (p >= a[i].first) {\n            cout << -1;\n            return 0;\n        }\n        if (q.find(p) == q.end()) {\n            cout << -1;\n            return 0;\n        }\n        int x = q[p];\n        s[x] += s[i];\n        g[x].push_back(i);\n        g[i].push_back(x);\n    }\n\n    if (calc(n - 1, 0, -1) != a[n - 1].first) {\n        cout << -1;\n        return 0;\n    }\n\n//    for (int i = 0; i < n; i++) {\n//        cerr << a[i] << \" \"<< calc(i, 0, -1) << \"\\n\";\n////        if (calc(i, 0, -1) != a[i]) cerr << \"!!!\";\n//    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j : g[i]) {\n            if (j > i)\n                cout << (a[i].second + 1) << \" \" << (a[j].second + 1) << \"\\n\";\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC optimize(2)\n// #pragma G++ optimize(2)\n// #pragma comment(linker,\"/STACK:102400000,102400000\")\n\n// #include <bits/stdc++.h>\n#include <map>\n#include <set>\n#include <list>\n#include <array>\n#include <cfenv>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <mutex>\n#include <queue>\n#include <ratio>\n#include <regex>\n#include <stack>\n#include <tuple>\n#include <atomic>\n#include <bitset>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <chrono>\n#include <cstdio>\n#include <cwchar>\n#include <future>\n#include <limits>\n#include <locale>\n#include <memory>\n#include <random>\n#include <string>\n#include <thread>\n#include <vector>\n#include <cassert>\n#include <climits>\n#include <clocale>\n#include <complex>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <ctgmath>\n#include <cwctype>\n#include <fstream>\n#include <iomanip>\n#include <numeric>\n#include <sstream>\n#include <ccomplex>\n#include <cstdbool>\n#include <iostream>\n#include <typeinfo>\n#include <valarray>\n#include <algorithm>\n#include <cinttypes>\n#include <cstdalign>\n#include <stdexcept>\n#include <typeindex>\n#include <functional>\n#include <forward_list>\n#include <system_error>\n#include <unordered_map>\n#include <unordered_set>\n#include <scoped_allocator>\n#include <condition_variable>\n// #include <conio.h>\n// #include <windows.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef float fl;\ntypedef double ld;\ntypedef long double LD;\ntypedef pair<int,int> pii;\n#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)\n#define lld \"%I64d\"\n#define llu \"%I64u\"\n#else\n#define lld \"%lld\"\n#define llu \"%llu\"\n#endif\n#define ui(n) ((unsigned int)(n))\n#define LL(n) ((long long)(n))\n#define ull(n) ((unsigned long long)(n))\n#define fl(n) ((float)(n))\n#define ld(n) ((double)(n))\n#define LD(n) ((long double)(n))\n#define char(n) ((char)(n))\n#define Bool(n) ((bool)(n))\n#define fixpoint(n) fixed<<setprecision(n)\n\nconst int INF=1061109567;\nconst int NINF=-1044266559;\nconst LL LINF=4557430888798830399;\nconst ld eps=1e-15;\n#define MOD (1000000007)\n#define PI (3.1415926535897932384626433832795028841971)\n\n/*\n#define MB_LEN_MAX 5\n#define SHRT_MIN (-32768)\n#define SHRT_MAX 32767\n#define USHRT_MAX 0xffffU\n#define INT_MIN (-2147483647 - 1)\n#define INT_MAX 2147483647\n#define UINT_MAX 0xffffffffU\n#define LONG_MIN (-2147483647L - 1)\n#define LONG_MAX 2147483647L\n#define ULONG_MAX 0xffffffffUL\n#define LLONG_MAX 9223372036854775807ll\n#define LLONG_MIN (-9223372036854775807ll - 1)\n#define ULLONG_MAX 0xffffffffffffffffull\n*/\n\n#define MP make_pair\n#define MT make_tuple\n#define All(a) (a).begin(),(a).end()\n#define pall(a) (a).rbegin(),(a).rend()\n#define log2(x) log(x)/log(2)\n#define Log(x,y) log(x)/log(y)\n#define SZ(a) ((int)(a).size())\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define rep1(i,n) for(int i=1;i<=((int)(n));i++)\n#define repa(i,a,n) for(int i=((int)(a));i<((int)(n));i++)\n#define repa1(i,a,n) for(int i=((int)(a));i<=((int)(n));i++)\n#define repd(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define repd1(i,n) for(int i=((int)(n));i>=1;i--)\n#define repda(i,n,a) for(int i=((int)(n));i>((int)(a));i--)\n#define repda1(i,n,a) for(int i=((int)(n));i>=((int)(a));i--)\n#define FOR(i,a,n,step) for(int i=((int)(a));i<((int)(n));i+=((int)(step)))\n#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)\n#define repV(i,v) for(auto i:v)\n#define repE(i,v) for(auto &i:v)\n#define MS(x,y) memset(x,y,sizeof(x))\n#define MC(x) MS(x,0)\n#define MINF(x) MS(x,63)\n#define MCP(x,y) memcpy(x,y,sizeof(y))\n#define sqr(x) ((x)*(x))\n#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())\n#define filein(x) freopen(x,\"r\",stdin)\n#define fileout(x) freopen(x,\"w\",stdout)\n#define fileio(x)\\\n\tfreopen(x\".in\",\"r\",stdin);\\\n\tfreopen(x\".out\",\"w\",stdout)\n#define filein2(filename,name) ifstream name(filename,ios::in)\n#define fileout2(filename,name) ofstream name(filename,ios::out)\n#define file(filename,name) fstream name(filename,ios::in|ios::out)\n#define Pause system(\"pause\")\n#define Cls system(\"cls\")\n#define fs first\n#define sc second\n#define PC(x) putchar(x)\n#define GC(x) x=getchar()\n#define Endl PC('\\n')\n#define SF scanf\n#define PF printf\n\ninline int Read()\n{\n    int X=0,w=0;char ch=0;while(!isdigit(ch)){w|=ch=='-';ch=getchar();}while(isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();\n\treturn w?-X:X;\n}\ninline void Write(int x){if(x<0)putchar('-'),x=-x;if(x>9)Write(x/10);putchar(x%10+'0');}\n\ninline LL powmod(LL a,LL b){LL RES=1;a%=MOD;assert(b>=0);for(;b;b>>=1){if(b&1)RES=RES*a%MOD;a=a*a%MOD;}return RES%MOD;}\ninline LL gcdll(LL a,LL b){return b?gcdll(b,a%b):a;}\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={1,0,-1,0,-1,-1,1,1};\n/************************************************************Begin************************************************************/\nconst int maxn=100010;\n\nint n;\nLL a[maxn];\nvector<pair<LL,int> > e;\nmap<LL,int> mp;\n\nint main()\n{\n\tSF(\"%d\",&n);\n\n\trep(i,n)\n\t{\n\t\tLL x;SF(\"%lld\",&x);\n\t\tmp[x]=i;\n\t\te.push_back({x,i});\n\t}\n\n\tsort(e.rbegin(),e.rend());\n\tLL x=e.back().fs;\n\n\tvector<int> sz(n,1);\n\tvector<int> dp(n,0);\n\tvector<pair<int,int> > ans;\n\n\trepV(i,e) if(i.fs!=x)\n\t{\n\t\tif(sz[i.sc]*2>=n) return !PF(\"-1\");\n\n\t\tLL need=i.fs-(n-sz[i.sc]*2);\n\n\t\tif(!mp.count(need)) return !PF(\"-1\");\n\n\t\tint par=mp[need];\n\t\tdp[par]+=dp[i.sc]+sz[i.sc];\n\t\tsz[par]+=sz[i.sc];\n\n\t\tans.push_back({i.sc+1,par+1});\n\t}\n\n\tif(dp[e.back().sc]!=x) return !PF(\"-1\");\n\n\trepV(i,ans) PF(\"%d %d\\n\",i.fs,i.sc);\n\n\treturn 0;\n}\n/*************************************************************End**************************************************************/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nlong long d[100001];\nint x[100001];\nint size[100001];\nlong long g[100001];\nvector<pair<int, int> > edge;\nmap<long long, int>f;\nbool cmp(int x, int y) {\n    return d[x] > d[y];\n}\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n ; i ++)\n        scanf(\"%lld\", &d[i]), x[i] = i, size[i] = 1, f[d[i]] = i;\n    sort(x + 1, x + n + 1, cmp);\n    bool sig = 0;\n    for (int i = 1; i <= n ; i ++) {\n        long long dd = d[x[i]] +size[x[i]] - n + size[x[i]];\n        if (dd != d[x[i]]&&f[dd] && dd < d[x[i]]) size[f[dd]] += size[x[i]], edge.push_back(make_pair(x[i], f[dd])), g[f[dd]] += g[x[i]] + size[x[i]];\n    }\n    if (size[x[n]] == n && edge.size() == n - 1 &&g[x[n]] == d[x[n]]){\n        for (auto u : edge) printf(\"%d %d\\n\", u.first, u.second);\n    } else printf(\"-1\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nProblem: Distance Sums (AtCoder 4434)\nAlgorithm: Math??Graph??\nStatus:\n*/\n\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <deque>\n#include <set>\n#include <sstream>\n#include <utility>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <stack>\n#include <stdio.h>\n#include <string.h>\n\nusing namespace std;\n\n#define INF 1000000007\ntypedef long long ll;\n\nint n;\nmap<ll,int> d;\nvector<pair<ll,int> > ev;\nvector<pair<int,int> > ans;\nll dp[100005],sz[100005];\n\nvoid bye(){\n\tcout<<-1<<endl;\n\texit(0);\n}\n\nint main()\n{\n\t#ifndef ZZZYT\n\t\t//freopen(\".in\",\"r\",stdin);\n\t\t//freopen(\".out\",\"w\",stdout);\n\t#endif\n\t\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tint tmp;\n\t\tscanf(\"%d\",&tmp);\n\t\tev.push_back(make_pair(tmp,i));\n\t\td[tmp]=i;\n\t}\n\tsort(ev.rbegin(),ev.rend());\n\tll center=ev.back().first;\n\tfor(int i=0;i<n;i++)sz[i]=1;\n\tfor(int i=0;i<ev.size();i++){\n\t\tint x=ev[i].second;\n\t\tint s=ev[i].first;\n\t\tif(s!=center){\n\t\t\tif(sz[x]*2>=n)bye();\n\t\t\tll ps=s+sz[x]-(n-sz[x]);\n\t\t\tif(d.count(ps)==0)bye();\n\t\t\tint p=d[ps];\n\t\t\tsz[p]+=sz[x];\n\t\t\tdp[p]+=dp[x]+sz[x];\n\t\t\tans.push_back(make_pair(x,p));\n\t\t}\n\t}\n\tif(dp[ev.back().second]!=center)bye();\n\tfor(int i=0;i<ans.size();i++){\n\t\tprintf(\"%d %d\\n\",ans[i].first+1,ans[i].second+1);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <tr1/unordered_map>\n#define int long long\n#define x first\n#define y second\n#define pii pair<int,int>\nusing namespace std;\ntemplate<class t> inline t read(t &x){\n\tchar c=getchar();bool f=0;x=0;\n\twhile(!isdigit(c)) f|=c=='-',c=getchar();\n\twhile(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\tif(f) x=-x;return x;\n}\ntemplate<class t> inline void write(t x){\n\tif(x<0) putchar('-'),write(-x);\n\telse{if(x>9) write(x/10);putchar('0'+x%10);}\n}\nconst int N=1e5+5;\nint en,h[N],sum,n,sz[N];\ntr1::unordered_map<int,int> id;\nvector<pii> ans;\nstruct edge{int n,v;}e[N<<1];\ninline void add(const int &x,const int &y){\n\te[++en]=(edge){h[x],y};\n\th[x]=en;\n}\nstruct node{\n\tint d,i;\n\tinline bool operator < (const node &nt) const {\n\t\treturn d>nt.d;\n\t}\n}a[N];\nvoid dfs(int x,int fa,int dis){\n\tsum+=dis;\n\tfor(int i=h[x];i;i=e[i].n){\n\t\tint y=e[i].v;\n\t\tif(y==fa) continue;\n\t\tdfs(y,x,dis+1);\n\t}\n}\nsigned main(){\n\tread(n);\n\tfor(int i=1;i<=n;i++){\n\t\tread(a[i].d);\n\t\tid[a[i].d]=i;\n\t\ta[i].i=i;\n\t\tsz[i]=1;\n\t}\n\tsort(a+1,a+1+n);\n\tfor(int i=1;i<n;i++){\n\t\tint aim=a[i].d-n+(sz[a[i].i]*2);\n\t\tid[a[i].d]=0;\n\t\tif(!id[aim]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint nt=id[aim];\n\t\tans.push_back(make_pair(a[i].i,nt));\n\t\tadd(a[i].i,nt);\n\t\tadd(nt,a[i].i);\n\t\tsz[nt]+=sz[a[i].i];\n\t}\n\tdfs(a[n].i,0,0);\n\tif(sum!=a[n].d){\n\t\tputs(\"-1\");\n\t}\n\telse{\n\t\tfor(int i=0;i<ans.size();i++)\n\t\t\twrite(ans[i].x),putchar(' '),\n\t\t\twrite(ans[i].y),putchar('\\n');\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(i,a,n) for(int i=a;i<=n;++i)\n#define PER(i,a,n) for(int i=n;i>=a;--i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(a) ({REP(__i,1,n) cout<<a[__i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\n\n\nconst int N = 1e6+10;\nint n, sz[N];\nstruct _ {\n\tll d;\n\tint id;\n\tbool operator < (const _ &rhs) const {\n\t\treturn d<rhs.d;\n\t}\n} a[N];\nvector<pii> ans;\nvector<int> g[N];\n\nvoid add(int u, int v) {\n\tans.pb(pii(u,v));\n\tg[u].pb(v),g[v].pb(u);\n}\n\nvoid dfs(int x, int f, int d) {\n\ta[1].d -= d;\n\tfor (int y:g[x]) if (y!=f) dfs(y,x,d+1);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tREP(i,1,n) { \n\t\tscanf(\"%lld\",&a[i].d);\n\t\ta[i].id = i, sz[i] = 1;\n\t}\n\tsort(a+1,a+1+n);\n\tPER(i,2,n) {\n\t\t_ u{a[i].d+2*sz[a[i].id]-n,0};\n\t\tauto p = lower_bound(a+1,a+1+n,u);\n\t\tif (p->d!=u.d) return puts(\"-1\"),0;\n\t\tadd(a[i].id,p->id), sz[p->id] += sz[a[i].id];\n\t}\n\tdfs(1,0,0);\n\tif (sz[a[1].id]!=n) return puts(\"-1\"),0;\n\tfor (auto &t:ans) printf(\"%d %d\\n\",t.x,t.y);\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst int maxn = 1e5 + 10;\nll a[maxn], dp[maxn];\nint n, rt, sz[maxn], dep[maxn], tid[maxn];\n\nmap <ll, int> mp;\nvector <int> e[maxn];\n\nvoid DFS(int u) {\n  for (int v : e[u]) {\n    dep[v] = dep[u] + 1;\n    dp[rt] += dep[v];\n    DFS(v);\n  }\n}\n\nvoid dfs(int u) {\n  for (int v : e[u]) {\n    dp[v] = dp[u] + n - 2 * sz[v], dfs(v);\n  }\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    tid[i] = i, sz[i] = 1;\n    scanf(\"%lld\", a + i), mp[a[i]] = i;\n  }\n  sort(tid + 1, tid + n + 1, [] (int x, int y) {\n    return a[x] > a[y];\n  });\n  rt = tid[n];\n  for (int i = 1; i < n; i++) {\n    int u = tid[i];\n    ll val = a[u] + 2 * sz[u] - n;\n    map <ll, int> :: iterator it = mp.find(val);\n    if (it == mp.end()) {\n      return puts(\"-1\"), 0;\n    }\n    int v = it -> second;\n    sz[v] += sz[u], e[v].push_back(u);\n  }\n  DFS(rt), dfs(rt);\n  for (int i = 1; i <= n; i++) {\n    if (a[i] != dp[i]) {\n      return puts(\"-1\"), 0;\n    }\n  }\n  for (int u = 1; u <= n; u++) {\n    for (int v : e[u]) {\n      printf(\"%d %d\\n\", u, v);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MN 100005\nint T,n,id[MN];\nll a[MN];\nmap<ll,int>rea,cnt;\nstruct node{int x,y;};\nvector<node>sc;\nbool cmp(int x,int y){return a[x]>a[y];}\nint main(){\n//\tfreopen(\"test.in\",\"r\",stdin);\n//\tfreopen(\"mysol.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),rea[a[i]]=i,cnt[a[i]]=1,id[i]=i;\n\tsort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<n;i++){\n\t\tint t=id[i],tmp=a[t]-n+2*cnt[a[t]];\n\t\tif(rea[tmp]&&tmp<a[t]){\n\t\t\tcnt[tmp]+=cnt[a[t]];\n\t\t\tsc.push_back((node){t,rea[tmp]});\n\t\t}\n\t\telse return 0*puts(\"-1\");\n\t}\n\tfor(int i=0;i<sc.size();i++)printf(\"%d %d\\n\",sc[i].x,sc[i].y);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nll d[100000];\nbool used[100000];\nll hosei[100000];\nmap<ll, int> mp;\nint main(){\n\tpriority_queue<pair<LP,ll>> q;\n\tint n; cin >> n;\n\tll ma = 0; int chk;\n\trep(i, n) {\n\t\tcin >> d[i]; mp[d[i]] = i;\n\t\tif (ma < d[i]) {\n\t\t\tma = d[i]; chk = i;\n\t\t}\n\t\tq.push({ {d[i],i},n - 2 });\n\t}\n\tbool out = false;\n\tqueue<P> ou;\n\tint cnt = 0;\n\twhile (!q.empty()) {\n\t\tpair<LP,ll> x = q.top(); q.pop();\n\t\tused[x.first.second] = true;\n\t\tll nex = x.first.first - x.second-hosei[x.first.second];\n\t\tif (!mp[nex]) {\n\t\t\tout = true; break;\n\t\t}\n\t\tint id = mp[nex];\n\t\tou.push({ x.first.second + 1,id + 1 });\n\t\tcnt++;\n\t\tif (cnt == n - 1)break;\n\t\tif (used[id]) {\n\t\t\thosei[id] += n - 2 - x.second - hosei[x.first.second];\n\t\t}\n\t\tused[id] = true;\n\t}\n\twhile (!ou.empty()) {\n\t\tP xx = ou.front(); ou.pop();\n\t\tcout << xx.first << \" \" << xx.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 100005\n#define error {puts(\"-1\");return 0;}\n#define ll long long\nusing namespace std;\n\nmap <ll,int> mp;\n\nstruct edge{\n\tint to,nxt;\n}e[maxn<<1];\n\nstruct node{\n\tll dis;int id;\n\tbool operator < (const node &A) const {return dis>A.dis;}\n}a[maxn];\n\nstruct uv{\n\tint u,v;\n\tbool operator < (const uv &A) const {return u==A.u?v<A.v:u<A.u;}\n}ans[maxn];\n\nint cnt,head[maxn],n;ll dis[maxn],size[maxn];\n\nvoid add(int u,int v){\n\te[++cnt]=(edge){v,head[u]};\n\thead[u]=cnt;\n}\n\nvoid dfs(int u,int fa,int dep){\n\tdis[a[n].id]+=dep;size[u]=1;\n\tfor(int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif(v==fa) continue;\n\t\tdfs(v,u,dep+1);\n\t\tsize[u]+=size[v];\n\t}\n}\n\nvoid dfs(int u,int fa){\n\tfor(int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif(v==fa) continue;\n\t\tdis[v]=dis[u]+n-size[v]*2;\n\t\tdfs(v,u);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i].dis);\n\t\ta[i].id=i;\n\t\tmp[a[i].dis]=i;\n\t}\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++) size[i]=1;\n\tfor(int i=1;i<n;i++){\n\t\tint u=a[i].id;\n\t\tll tmp=n-size[u]*2;\n\t\tif(tmp<=0||!mp.count(a[i].dis-tmp)) error\n\t\tint fa=mp[a[i].dis-tmp];\n\t\tsize[fa]+=size[u];\n\t\tadd(u,fa);add(fa,u);\n\t\tans[i].u=min(u,fa);\n\t\tans[i].v=max(u,fa);\n\t}\n\tsort(ans+1,ans+n);\n\tdfs(a[n].id,0,0);\n\tdfs(a[n].id,0);\n\tfor(int i=1;i<=n;i++) if(dis[a[i].id]!=a[i].dis) error\n\tfor(int i=1;i<n;i++) printf(\"%d %d\\n\",ans[i].u,ans[i].v);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <queue>\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long i64;\ntypedef pair<i64, int> pii;\ninline i64 read(int f = 1, i64 x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n}\nconst int N = 1e5+5;\nint n, s[N], u[N], v[N]; pii p[N]; i64 sum;\nint main()\n{\n    n = read(); for(int i = 1; i <= n; ++i) p[i].fi = read(), p[i].se = i, s[i] = 1;\n    sort(p+1, p+n+1); \n    for(int i = n; i > 1; --i)\n    {\n        i64 w = p[i].fi-n+s[i]*2; int j = lower_bound(p+1, p+1+n, pii(w, 0))-p;\n        if(p[j].fi != w) return puts(\"-1\"), 0; \n        u[i] = p[i].se, v[i] = p[j].se, s[j] += s[i], sum += s[i];\n    }\n    if(sum != p[1].fi) return puts(\"-1\"), 0;\n    for(int i = 2; i <= n; ++i) printf(\"%d %d\\n\", u[i], v[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint n,sum,a[500001],b[500001],c[500001],sz[500001],id[500001];\nvector<int>zh[150001];\nmap<int,int>mp;\nbool cmp(int x,int y){\n\treturn a[x]>a[y];\n}\nvoid dfs(int x,int fa,int now){\n\tint i;\n\tsum+=now;\n\tfor(i=0;i<zh[x].size();i++)if(zh[x][i]!=fa)dfs(zh[x][i],x,now+1);\n}\nint main(){\n\tint i,x,y,w;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)scanf(\"%d\",&a[i]),mp[a[i]]=i;\n\tfor(i=1;i<=n;i++)sz[i]=1,id[i]=i;\n\tsort(id+1,id+n+1,cmp);\n\tfor(i=1;i<n;i++){\n\t\tx=id[i];\n\t\tw=a[x]-(n-sz[x])+sz[x];\n\t\t//printf(\"%d %d %d %d\\n\",x,a[x],sz[x],w);\n\t\tif(!mp[w]||w>=a[x])return puts(\"-1\"),0;\n\t\ty=mp[w];\n\t\tb[i]=x;c[i]=y;\n\t\tzh[x].push_back(y);\n\t\tzh[y].push_back(x);\n\t\tsz[y]+=sz[x];\n\t}\n\tdfs(id[n],0,0);\n\tif(sum!=a[id[n]])return puts(\"-1\"),0;\n\tfor(i=1;i<n;i++)printf(\"%d %d\\n\",b[i],c[i]);\n}\n/*\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid err() {\n  cout << -1 << endl;\n  exit(0);\n}\nvoid dfs (int crr, int dpt, vector<vector<int>>& grh, long long& cnt) {\n  cnt += dpt;\n  for (int nxt : grh[crr]) {\n    dfs(nxt, dpt + 1, grh, cnt);\n  }\n}\nint main() {\n  int n;\n  cin >> n;\n  vector<long long> d(n);\n  map<long long, int> mp;\n  for (int i = 0; i < n; i++) {\n    cin >> d[i];\n    mp[d[i]] = i;\n  }\n  sort(d.begin(), d.end(), greater<long long>());\n  vector<long long> sz(n, 1);\n  vector<vector<int>> grh(n);\n  for (auto it = d.begin(); next(it) != d.end(); it++) {\n    auto i = mp[*it];\n    long long ptv = *it - n + 2 * sz[i];\n    auto jt = lower_bound(d.rbegin(), d.rend(), ptv);\n    if (jt == d.rend() || *jt != ptv) err();\n    auto p = mp[*jt];\n    grh[p].push_back(i);\n    sz[p] += sz[i];\n  }\n  long long cnt = 0;\n  int rt = mp[d[n - 1]];\n  dfs(rt, 0, grh, cnt);\n  if (d[n - 1] != cnt) err();\n  for (int crr = 0; crr < n; crr++) {\n    for (int nxt : grh[crr]) {\n      cout << crr + 1 << ' ' << nxt + 1 << endl;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define F first\n#define S second\n#define all(c)  c.begin(), c.end()\n#define mp make_pair\n#define endl \"\\n\"\n#define N 100001\n#define INF 1e9\n\n\nint main(){\n    \n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    \n    cerr << \"Time : \" << 1000 * ((double)clock()) / (double)CLOCKS_PER_SEC << \"ms\\n\";\n    \n    ll n , i  ;\n    cin >> n ;\n    pair<ll , ll >  d[n] ;\n    ll siz[n+1] ;\n    for(i=0 ; i<n ; i++){\n        cin >> d[ i ].F  ;\n        d[i].S = i+1 ;\n        siz[i+1]=1 ;\n    }\n    sort(d , d+n) ;\n    ll dis=0 ;\n    vector<pair<ll , ll > > ans ;\n    for(i=n-1 ; i>0 ; i--){\n        ll sum = d[i].F-n+2*siz[d[i].S] ;\n        ll pos = (ll)(lower_bound(d , d+n , mp(sum , 0LL)) - d) ;\n        if(d[pos].F!=sum){cout << -1 ; return 0 ;}\n        ll u = d[i].S , v = d[pos].S ;\n        ans.pb(mp(u , v)) ;\n        siz[v]+=siz[u] ;\n        dis+=siz[u] ;\n    }\n    if(dis!=d[0].F){cout << -1 ; return 0 ;}\n    for(i=0 ; i<n-1 ; i++){\n        cout << ans[i].F << \" \" << ans[i].S << endl ;\n    }\n\n\n    return 0 ;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int MAXN = 1e05 + 10;\n\nint N;\npair<LL, int> d[MAXN];\n\nint subsize[MAXN]= {0}, fa[MAXN]= {0};\nvoid solve () {\n\tfor (int i = N; i > 1; i --) {\n\t\tsubsize[d[i].second] ++;\n\t\tint up = N - 2 * subsize[d[i].second];\n\t\tint p = lower_bound (d + 1, d + N + 1, make_pair (d[i].first - up, 0)) - d;\n\t\tif (p == i || d[p].first != d[i].first - up) { puts (\"-1\"); exit (0); }\n\t\tfa[d[i].second] = d[p].second;\n\t\tsubsize[d[p].second] += subsize[d[i].second];\n\t}\n}\n\ninline LL getnum () {\n\tLL num = 0; char ch = getchar ();\n\twhile (! isdigit (ch)) ch = getchar ();\n\twhile (isdigit (ch)) num = (num << 3) + (num << 1) + ch - '0', ch = getchar ();\n\treturn num;\n}\n\nint main () {\n\tN = getnum ();\n\tfor (int i = 1; i <= N; i ++) d[i].first = getnum (), d[i].second = i;\n\tsort (d + 1, d + N + 1);\n\tsolve ();\n\tfor (int i = 2; i <= N; i ++)\n\t\tprintf (\"%d %d\\n\", fa[d[i].second], d[i].second);\n\n\treturn 0;\n}\n\n/*\n7\n10\n15\n13\n18\n11\n14\n19\n*/\n\n/*\n2\n1\n2\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100005\nusing namespace std;\n\nmap<int,int>mmp;\nvector<int>g[N];\nint d[N],fa[N],pd[N],f[N],n,sz[N];\n\nvoid dfs1(int x,int s,int dep){\n\tpd[s]+=dep;\n\tfor(int i=0;i<g[x].size();++i) dfs1(g[x][i],s,dep+1);\n}\n\nvoid dfs2(int x){\n\tfor(int i=0;i<g[x].size();++i){\n\t\tpd[g[x][i]]=f[x]-2*sz[g[x][i]]+n;\n\t\tdfs2(g[x][i]);\n\t} \t\n}\n\nint main(){\n\tint x,mx=0,cnt=0,a,i;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i) scanf(\"%d\",&d[i]),f[i]=d[i],mmp[d[i]]=i;\n\tfor(i=1;i<=n;++i) sz[i]=1;\n\tsort(d+1,d+n+1);\n\tfor(i=n;i>1;--i){\n\t\ta=mmp[d[i]];\n\t\tx=d[i]-(n-sz[a])+sz[a];\n\t\tif(!mmp[x]) return printf(\"-1\")&0;\n\t\tfa[a]=mmp[x];\n\t\tsz[mmp[x]]+=sz[a];\n\t}\n\tfor(i=1;i<=n;++i) if(fa[i]) g[fa[i]].push_back(i);\n\t//judge\n\tint y=mmp[d[1]];\n\tdfs1(y,y,0);\n\tdfs2(y);\n\tfor(i=1;i<=n;++i) if(pd[i]!=f[i]) return printf(\"-1\")&0;\n\tfor(i=1;i<=n;++i) if(fa[i]) printf(\"%d %d\\n\",fa[i],i);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<math.h>\n#include<stdlib.h>\n#include<set>\n#include<bitset>\n#include<map>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<complex>\n#include<list>\n#include<limits.h>\nusing namespace std;\n\nconst int N=1e5+5;\ntypedef pair<int,int> pii;\nint n;\npair<long long,int> a[N];\nlong long sz[N];\nlong long dp[N];\nvector<pii> vp;\nmap<long long,int> mp;\n\nvoid lnk(int x,int y){\n\tvp.push_back(make_pair(x,y));\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%I64d\",&a[i].first);\n\t\ta[i].second=i;\n\t}\n\tsort(a+1,a+1+n);\n\treverse(a+1,a+1+n);\n\tfor(int i=1;i<=n;i++) mp[a[i].first]=i;\n\tfor(int i=1;i<=n;i++) sz[i]=1ll;\n\tfor(int i=1;i<n;i++){\n\t\tlong long fnd=a[i].first-1ll*n+2*sz[i];\n\t\tif(mp.find(fnd)==mp.end()){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint nxt=mp[fnd];\n\t\tdp[nxt]+=dp[i]+sz[i];\n\t\tsz[nxt]+=sz[i];\n\t\tlnk(a[i].second,a[nxt].second);\n\t}\n\tif(vp.size()!=n-1||dp[n]!=a[n].first) puts(\"-1\");\n\telse for(int i=0;i<vp.size();i++) printf(\"%d %d\\n\",vp[i].first,vp[i].second);\n\treturn 0;\n}\n\n/*\n数据不清空，爆零两行泪\n读题不认真，爆零两行泪\n分析不仔细，爆零两行泪\n建树不构造，爆零两行泪\n变量不统一，爆零两行泪\n边界不算清，爆零两行泪\n数组不开大，爆零两行泪\n*/"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimiz(O2)\n\n#include <bits/stdc++.h>\n\n#define rg register\nusing namespace std;\ntypedef long long ll;\n\ntemplate<typename T>\ninline bool read(T &n) {\n    T ans = 0, flag = 1;\n    char ch;\n    while ((ch = getchar()) < '0' || ch > '9') if (ch == '-') flag = -1; else if (ch == EOF) return false;\n    ans = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9') ans = ans * 10 + ch - '0';\n    n = ans * flag;\n    return true;\n}\n\ninline ll read() {\n    ll ans = 0, flag = 1;\n    char ch;\n    while ((ch = getchar()) < '0' || ch > '9') if (ch == '-') flag = -1;\n    ans = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9') ans = ans * 10 + ch - '0';\n    return ans * flag;\n};\nconst int maxn = 100005;\nstruct NODE {\n    ll val, ord;\n    bool operator<(NODE b) const {\n        return val < b.val;\n    }\n} node[maxn];\nint siz[maxn],fa[maxn];\nunordered_map<ll,int> unM;\nint main() {\n    int n;\n    read(n);priority_queue<NODE> pq;\n    for (rg int i = 1; i <= n; ++i) {\n        siz[i] = 1;read(node[i].val);\n        node[i].ord = i;\n        pq.push(node[i]);\n        unM[node[i].val]=i;\n    }\n    for(rg int i=n;i>=2;i--){\n        NODE now=pq.top();pq.pop();\n        if(unM.find(now.val+2*siz[now.ord]-n)==unM.end()||unM[now.val+2*siz[now.ord]-n]>=now.ord){\n            puts(\"-1\");return 0;\n        }\n        fa[now.ord]=unM[now.val+2*siz[now.ord]-n];\n        siz[fa[now.ord]]+=siz[now.ord];\n    }\n    for(rg int i=1;i<=n;i++){\n        if(fa[i]) cout<<i<<' '<<fa[i]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define re register\n#define ll long long\ninline int gi()\n{\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=100010;\ntypedef pair<ll,int> pli;typedef pair<int,int> pii;\n#define mp make_pair\npli p[N];int n,siz[N];\nvector<pii>ans;\nint main()\n{\n\tn=gi();\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&p[i].first),p[i].second=i,siz[i]=1;\n\tsort(p+1,p+n+1);ll dis=0;\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tll nd=p[i].first-(n-siz[p[i].second])+siz[p[i].second];\n\t\tpli it=p[lower_bound(p+1,p+n+1,mp(nd,0))-p];\n\t\tif(it.first!=nd)return puts(\"-1\")&1;\n\t\tans.push_back(mp(it.second,p[i].second));\n\t\tsiz[it.second]+=siz[p[i].second];dis+=siz[p[i].second];\n\t\t}\n\tif(dis!=p[1].first)return puts(\"-1\")&1;\n\tfor(int i=0;i<n-1;i++)printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define inf 0x3f3f3f3f3f3f3f3f\n#define inf 0x3f3f3f3f\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define inv(x) Power(x, mod - 2)\n#define fi first\n#define se second\n#define MP make_pair\n#define PB push_back\n\ntypedef std::vector<int> Poly;\ntypedef std::pair<int,int> Pair;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef long long ll;\n\nconst int maxn = 100000, maxm = 2000, MAX = 1e6 + 5, mod = 1000000;\n//template{{{\nconst long double Pi = 3.14159265358979323846l, Eps = 1e-4;\ntemplate <class T> inline bool equal(T x, T y) { return fabs(x - y) < Eps; }\ninline int add(int x, int y) { x += y; return x >= mod ? x - mod : x; };\ninline void inc(int &x, int y) { x += y; x -= (x >= mod ? mod : 0); }\ninline int mul(int x, int y) { return 1ll * x * y % mod; }\ninline int Power(int x, int y, int Mod = mod) {\n\tint ans = 1;\n\twhile (y) {\n\t\tif (y & 1) ans = (ll) ans * x % Mod;\n\t\tx = (ll) x * x % Mod, y >>= 1;\n\t} return ans;\n}\n\n/*char buf[1<<23],obuf[1<<23],*p1=buf,*p2=buf, *O = obuf;\n#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\nvoid print(int x) {\n    if(x > 9) print(x / 10);\n    *O++=x%10+'0';\n} */\n\ntemplate <class T> inline T\tinput() {\n\tT x; char ch; bool flag = false;\n\twhile (!isdigit(ch = getchar())) flag |= ch == '-';\n\tfor (x = ch ^ 48; isdigit(ch = getchar()); x = x * 10 + (ch ^ 48));\n\treturn flag ? -x : x;\n}\n\ntemplate <class T> inline bool chkmin(T &x, T y) { x = x < y ? x : y; return x == y; }\ntemplate <class T> inline bool chkmax(T &x, T y) { x = x > y ? x : y; return x == y; }\ntemplate <class T> inline T gcd(T x, T y) { return !y ? x : gcd(y, x % y); }\ntemplate <class T> inline T sqrm(T x) { return (ll) x * x % mod; }\ntemplate <class T> inline T sqr(T x) { return x * x; }\n\nstruct {\n\tinline operator int () { return input<int>(); }\n\tinline operator long long () { return input<long long>(); }\n\ttemplate <class T> inline void operator () (T &x) { x = *this; }\n\ttemplate<class T, class ...A> inline void operator () (T &x, A &...a)\n\t{ x = *this; this -> operator ()(a...); }\n} read; //}}}\n\nint n;\nll d[maxn + 5];\nint size[maxn + 5];\nstd::map<ll, int> id;\nstd::pair<ll, int> p[maxn + 5];\nint fa[maxn + 5];\n\nsigned main() {\n#ifdef local\n\tfreopen(\"in\", \"r\", stdin);\n\tfreopen(\"out\", \"w\", stdout);\n\tfreopen(\"log\", \"w\", stderr);\n#endif\n\n\tn = read;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tp[i].fi = d[i] = read;\n\t\tp[i].se = id[d[i]] = i;\n\t\tsize[i] = 1;\n\t}\n\n\tstd::sort(p + 1, p + n + 1);\n\tfor (int i = n; i > 1; --i) {\n\t\tll df = p[i].fi - n + size[p[i].se] * 2;\n\t\tfa[p[i].se] = id[df], size[fa[p[i].se]] += size[p[i].se];\n\t\tif (!fa[p[i].se] || fa[p[i].se] == p[i].se) return puts(\"-1\"), 0;\n\t}\n\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (fa[i]) printf(\"%d %d\\n\", i, fa[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing vi = vector<ll>;\nconst int maxn = 1<<19, mod = 1e9 + 7;\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tint n;\n\tcin >> n;\n\tvi a(n), sz(n+1, 1);\n\tmap<ll, int> id;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\tid[a[i]] = i+1;\n\t}\n\tsort(rall(a));\n\tvector<pair<int, int>> edges;\n\tfor(auto x : a) {\n\t\tint i = id[x];\n\t\tif(sz[i] == n) continue;\n\t\tll nd = x + 2*sz[i] - n;\n\t\tif(nd < x && id.count(nd)) {\n\t\t\tedges.pb({i, id[nd]});\n\t\t\tsz[id[nd]] += sz[i];\n\t\t}\n\t}\n\tif(edges.size() != n-1) return cout << -1, 0;\n\tfor(auto i : edges) cout << i.first << \" \" << i.second << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,n) for (int i=1;i<=n;i++)\n#define REP(i,a,b) for (int i=a;i<=b;i++)\n \n#define pb push_back\n#define fi first\n#define se second\n#define pi pair<int,int>\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n \ntypedef long long ll;\n\nconst int inf=0x3f3f3f3f;\nconst ll linf=1e18;\nconst int N=200000+10;\nconst double eps=1e-5;\nconst int mo=1e9+7;\n\nint n;\nvector<int> v[N];\nint sz[N];\nstruct node {\n\tint id,v;\n} a[N];\nbool cmp(node x,node y) {\n\treturn x.v<y.v;\n}\nint find(int x) {\n\tint l=1,r=n;\n\tint mid;\n\twhile (l<=r) {\n\t\tmid=(l+r)>>1;\n\t\tif (a[mid].v<x) {\n\t\t\tl=mid+1;\n\t\t} else if (a[mid].v>x) {\n\t\t\tr=mid-1;\n\t\t} else return a[mid].id;\n\t}\n\treturn 0;\n}\nint main() {\n \n    std::ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tint x,y;\n\tFOR(i,n) {\n\t\tscanf(\"%d\",&a[i].v);\n\t\ta[i].id=i;\n\t}\n\tsort(a+1,a+1+n,cmp);\n\tFOR(i,n) sz[i]=1;\n\tint t;\n\tfor (int i=n;i>=2;i--) {\n\t\tx=a[i].id;\n\t\tt=a[i].v-n+2*sz[x];\n\t\t//cout<<x<<\" \"<<t<<endl;\n\t\ty=find(t);\n\t\tif (x==y||y==0) {\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tv[x].pb(y);\n\t\tv[y].pb(x);\n\t\tsz[y]+=sz[x];\n\t}\n\tFOR(i,n) {\n\t\tfor (int j=0;j<(int)v[i].size();j++) {\n\t\t\ty=v[i][j];\n\t\t\tif (i<y) {\n\t\t\t\tprintf(\"%d %d\\n\",i,y);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <utility>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#define my_abs(x) ((x) < 0 ? -(x) : (x))\n#define mp std::make_pair\n#define pb push_back\nusing ll = long long;\nstd::set<std::pair<int, int> > se;\nstd::vector<std::pair<int, int> > ans;\nll arr[100005];\nint main()\n{\n\t// freopen(\"ARC103-F.in\", \"r\", stdin);\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%lld\", &arr[i]);\n\t\tse.insert({arr[i], i});\n\t}\n\tint rt = se.begin()->second;\n\tse.erase(se.begin());\n\twhile (!se.empty())\n\t{\n\t\tint u = se.begin()->second;\n\t\tif (arr[rt] - arr[u] + n & 1)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tll sz = arr[rt] - arr[u] + n >> 1, cur = arr[u];\n\t\tse.erase(se.begin());\n\t\tans.pb({rt, u});\n\t\twhile (sz--)\n\t\t{\n\t\t\tif (!sz)\n\t\t\t\tbreak;\n\t\t\tcur += n - 2 * sz;\n\t\t\tauto it = se.lower_bound({cur, -1});\n\t\t\tif (it == se.end() || it->first != cur)\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tans.pb({u, it->second});\n\t\t\tu = it->second;\n\t\t\tse.erase(it);\n\t\t}\n\t}\n\tfor (auto it : ans)\n\t\tprintf(\"%d %d\\n\", it.first + 1, it.second + 1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n \n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define all(v) begin(v), end(v)\n#define debug(x) std::cerr<< #x <<\": \"<<x<<\"\\n\"\n#define debug2(x,y) std::cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<\"\\n\"\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntypedef deque<bool> db;\ntemplate<class T> using vv=vector<vector< T > >;\n\ninline void scan(int&a){scanf(\"%d\",&a);}\ninline void scan(int&a,int&b){scanf(\"%d%d\",&a,&b);}\ninline void scan(int&a,int&b,int&c){scanf(\"%d%d%d\",&a,&b,&c);}\ninline void scan(int&a,int&b,int&c,int&d){scanf(\"%d%d%d%d\",&a,&b,&c,&d);}\ninline void scan(vector<int>&v){int sz=v.size();rep(i,sz){scan(v[i]);}}\ninline void scan(vector<vector<int> >&v){int sz=v.size();rep(i,sz){scan(v[i]);}}\ninline void scan(ll&a){scanf(\"%lld\",&a);}\ninline void scan(ll&a,ll&b){scanf(\"%lld%lld\",&a,&b);}\ninline void scan(ll&a,ll&b,ll&c){scanf(\"%lld%lld%lld\",&a,&b,&c);}\ninline void scan(ll&a,ll&b,ll&c,ll&d){scanf(\"%lld%lld%lld%lld\",&a,&b,&c,&d);}\ninline void scan(vector<ll>&v){int sz=v.size();rep(i,sz){scan(v[i]);}}\ninline void scan(vector<vector<ll> >&v){int sz=v.size();rep(i,sz){scan(v[i]);}}\ninline void scan(char&a){scanf(\" %c\",&a);}\ninline void scan(vector<char>&v){int sz=v.size();rep(i,sz){scan(v[i]);}}\ninline void scan(vector<vector<char> >&v){int sz=v.size();rep(i,sz){scan(v[i]);}}\ninline void scan(string&s){char BUF[3000000];scanf(\" %s\",BUF);s=string(BUF);}\n\ninline void print(int a){printf(\"%d\\n\",a);}\ninline void print(int a,int b){printf(\"%d %d\\n\",a,b);}\ninline void print(ll a){printf(\"%lld\\n\",a);}\ninline void print(ll a,ll b){printf(\"%lld %lld\\n\",a,b);}\ninline void print(string s){cout << s << \"\\n\";}\ninline void print_yn(bool flg){if(flg){printf(\"Yes\\n\");}else{printf(\"No\\n\");}}\n\n// cout vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n  int len=v.size();s<<\"\\n\";rep(i,len){s<<v[i];if(i<len-1){s << \"\\t\";}}s<<\"\\n\";return s; }\n// cout 2-dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& vv) {\n  int len=vv.size();rep(i,len){s<<vv[i];} return s; }\n// cout deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque<T>& v) {\n  int len=v.size();s<<\"\\n\";rep(i,len){s<<v[i];if(i<len-1){s << \"\\t\";}}s<<\"\\n\";return s; }\n// cout 2-dimentional deque\ntemplate<typename T> ostream& operator<<(ostream& s, const deque< deque<T> >& vv) {\n  int len=vv.size();rep(i,len){s<<vv[i];} return s; }\n// cout set<cout-able>\ntemplate<typename T> ostream& operator<<(ostream& s, const set<T>& v) {\n  s<<\"\\n\";for(auto elm : v){s<<elm<<\"\\t\";}s<<\"\\n\";return s; }\n\nint main() {\n  int n;\n  scan(n);\n  vvll d(n, vll(2));\n  map<ll, int> mp;\n  rep (i, n) {\n    scanf(\"%lld\", &d[i][0]);\n    d[i][1] = i;\n    mp[d[i][0]] = i;\n  }\n  sort(all(d));\n  reverse(all(d));\n  vi parent(n, -1);\n  vvi childs(n);\n  vi allcnt(n, 0); // sum cnt of all childs\n  vvi edges;\n  vll accum_d(n, 0);\n  rep (i, n-1) {\n    int ind = d[i][1];\n    allcnt[ind] = 1;\n    for (auto c : childs[ind]) {\n      allcnt[ind] += allcnt[c];\n      accum_d[ind] += (accum_d[c] + allcnt[c]);\n    }\n    int diff = n - allcnt[ind] * 2;\n    if (diff <= 0) {\n      printf(\"-1\\n\");\n      return 0;\n    }\n    ll next_d = d[i][0] - diff;\n    if (mp.find(next_d) != mp.end()) {\n      int par_ind = mp[next_d];\n      parent[ind] = par_ind;\n      childs[par_ind].push_back(ind);\n      edges.push_back((vi){ind, par_ind});\n    } else {\n      printf(\"-1\\n\");\n      return 0;\n    }\n  }\n  {\n    int ind = d[n-1][1];\n    for (auto c : childs[ind]) {\n      accum_d[ind] += (accum_d[c] + allcnt[c]);\n    }\n    if (accum_d[ind] != d[n-1][0]) {\n      printf(\"-1\\n\");\n      return 0;\n    }\n  }\n  assert((int)edges.size() == n-1);\n  rep (i, n-1) {\n    printf(\"%d %d\\n\", edges[i][0]+1, edges[i][1]+1);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\nint main() {\n\tauto no = [](){ printf(\"-1\\n\"); exit(0); };\n\tint n;\n\tscanf(\"%d\", &n);\n\tvector<long long> d(n);\n\tmap<long long, int> mp;\n\trep(i, n) {\n\t\tscanf(\"%lld\", &d[i]);\n\t\tmp[d[i]] = i;\n\t}\n\tsort(d.begin(), d.end());\n\tlong long mi = d[0];\n\treverse(d.begin(), d.end());\n\td.pop_back();\n\tset<long long> remains;\n\trep(i, d.size()) {\n\t\tremains.insert(d[i]);\n\t}\n\tvector<pair<int, int>> ans;\n\trep(i, d.size()) {\n\t\tif (remains.count(d[i]) == 0) continue;\n\t\tremains.erase(d[i]);\n\t\tint s = 1;\n\t\tlong long cur = d[i];\n\t\tlong long prev;\n\t\twhile (true) {\n\t\t\tlong long diff = n - s * 2;\n\t\t\tprev = cur;\n\t\t\tcur -= diff;\n\t\t\tif (cur == mi) {\n\t\t\t\tans.push_back({mp[prev], mp[cur]});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (remains.count(cur) == 0) no();\n\t\t\tremains.erase(cur);\n\t\t\tans.push_back({mp[prev], mp[cur]});\n\t\t\ts ++;\n\t\t}\n\t}\n\tassert(ans.size() == n - 1);\n\tfor (auto it : ans) printf(\"%d %d\\n\", it.first + 1, it.second + 1);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _SCL_SECURE_NO_WARNINGS\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#include <fstream>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<LL, LL> PP;\n#define REP(i, a, n) for(LL i = (a), i##_max = (n); i < i##_max; ++i)\n#define REM(i, a, n) for(LL i = (LL)(n) - 1, i##min = (a); i >= i##min; --i)\n#define ALL(arr) (arr).begin(), (arr).end()\n#define FLOAT fixed << setprecision(16)\n#define SPEEDUP {cin.tie(NULL); ios::sync_with_stdio(false);}\nconst int INF = 0x3FFFFFFF;\nconst LL INFLL = 0x3FFFFFFF3FFFFFFF;\nconst double INFD = 1.0e+308;\nconst string INFSTR = \"\\x7f\";\nconst double EPS = 1.0e-9;\n\nvoid YesNo(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YESNO(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate <class T, class U>\nistream& operator>>(istream& ist, pair<T, U>& right) { return ist >> right.first >> right.second; }\ntemplate <class T, class U>\nostream& operator<<(ostream& ost, const pair<T, U>& right) { return ost << right.first << ' ' << right.second; }\ntemplate <class T, class TCompatible, size_t N>\nvoid Fill(T(&dest)[N], const TCompatible& val) { fill(dest, dest + N, val); }\ntemplate <class T, class TCompatible, size_t M, size_t N>\nvoid Fill(T(&dest)[M][N], const TCompatible& val) { for (int i = 0; i < M; ++i) Fill(dest[i], val); }\ntemplate<class T>\nT Compare(T left, T right) { return left > right ? 1 : (left < right ? -1 : 0); }\nistream& Ignore(istream& ist) { string s; ist >> s; return ist; }\nbool Inside(int i, int j, int h, int w) { return i >= 0 && i < h && j >= 0 && j < w; }\ntemplate <class T>\nT Next() { T buf; cin >> buf; return buf; }\n\n#ifdef ONLY_MY_ENVIR\n#include \"IntMod.h\"\n#include \"Union_Find.h\"\n#include \"Graph.h\"\n#include \"Range.h\"\n#include \"Global.h\"\n#include \"Flow_Solver.h\"\n#include \"Tree.h\"\n#include \"Suffix_Array.h\"\n#include \"Geometry.h\"\n#include \"Matrix.h\"\n#include \"Segment_Tree.h\"\n#include \"BIT.h\"\n#include \"Rational.h\"\n#include \"Position.h\"\n#include \"Factorization.h\"\n#endif\n\n#ifdef __GNUC__\ntypedef __int128 LLL;\nistream& operator>> (istream& ist, __int128& val) { LL tmp;  ist >> tmp; val = tmp; return ist; }\nostream& operator<< (ostream& ost, __int128 val) { LL tmp = val; ost << tmp; return ost; }\n#endif\n\n#if 1234567891\n#include <array>\n#include <random>\n#include <unordered_set>\n#include <unordered_map>\ntemplate<typename T>\nusing PriorityQ = priority_queue<T, vector<T>, greater<T> >;\n// template <class T>\n// auto Is(const T& value) { return [value](const auto& comparand) -> bool { return comparand == value; }; }\n#endif\n\nLL N;\nPP Q[100000];\nLL A[100000];\nLL P[100000];\nLL cnt[100000];\nmap<LL, int> mp;\n\nvector<int> G[100000];\n\nLL rec(int from) {\n\tLL sum = cnt[from] - 1;\n\tfor (int to : G[from]) {\n\t\tsum += rec(to);\n\t}\n\treturn sum;\n}\n\nbool cat(int from) {\n\tLL t = A[from] - (N - 2 * cnt[from]);\n\tif (!mp.count(t)) return false;\n\tif (t >= A[from]) return false;\n\tint to = mp[t];\n\tP[from] = to;\n\tcnt[to] += cnt[from];\n\tG[to].push_back(from);\n\treturn true;\n}\n\nvoid sub() {\n\tFill(cnt, 1);\n\tREP(i, 0, N) {\n\t\tA[i] = Q[i].first;\n\t\tmp[A[i]] = i;\n\t}\n\n\tREM(i, 1, N) {\n\t\tif (!cat(i)) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tLL tmp = rec(0);\n\tif (tmp != A[0]) {\n\t\tcout << -1 << endl;\n\t\treturn;\n\t}\n\n\tREP(i, 1, N) {\n\t\tcout << Q[i].second + 1 << ' ' << Q[P[i]].second + 1 << endl;\n\t}\n}\n\nint main() {\n\tcin >> N;\n\tREP(i, 0, N) {\n\t\tLL a;\n\t\tcin >> a;\n\t\tQ[i] = PP(a, i);\n\t}\n\tsort(Q, Q + N);\n\n\tsub();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint PREP = (cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(9), 0);\n//int SEGV = getenv(\"D\") || (exit(system(\"D= SEGFAULT_SIGNALS=all catchsegv ./prog.exe\") >> 8), 0);\nvoid fail() {\n    cout << -1 << '\\n';\n    exit(0);\n}\nint main() {\n    int N; cin >> N;\n    if (N == 2) fail();\n    map<Int, pair<int, int>> M; // D[i] -> idx, num\n    vector<pair<int, int>> ans;\n    for (int i = 0; i < N; i++) {\n        Int d; cin >> d;\n        M[d] = make_pair(i, 1);\n    }\n    for (auto it = rbegin(M), ite = rend(M); it != ite; ++it) {\n        int idx, num; tie(idx, num) = it->second;\n        if (num == N) continue;\n        Int diff = num - (N - num);\n        if (diff >= 0) fail();\n        Int dnext = it->first + diff;\n        if (!M.count(dnext)) fail();\n        ans.emplace_back(idx, M[dnext].first);\n        M[dnext].second += num;\n    }\n    for (auto &p : ans) {\n        cout << p.first + 1 << ' ' << p.second + 1 << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stdio.h>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll INF = 1e9;\n\nvector < pair <ll, ll> > v;\n\nll n, sz[1000000], r[1000000], sum;\n\nbool ans = true;\n\nvector <ll> g[1000000];\n\nll dfs (ll x, ll p)\n{\n\tll sum = sz[x] - 1;\n\n\tfor (ll to : g[x])\n\t\tif (to != p)\n\t\t\tsum += dfs (to, x);\n\n\treturn sum;\n}\n\nint main () \n{\n    cin >> n;\n    \n    for (ll i = 0; i < n; i++)\n    {\n\t\tll d;\n\t\tscanf (\"%lld\", &d);\n\t\t\n\t\tv.emplace_back (d, i);\n\n\t\tr[i] = d;\n    }\n    \n    sort (v.begin (), v.end ());\n    \n    for (ll i = n - 1; i > 0; i--)\n    {\n\t\tll x = v[i].second, d = v[i].first;\n\t\t\n\t\tsz[x] = 1;\n\t\t\n\t\tfor (ll to : g[x])\n\t\t    sz[x] += sz[to];\n\n\t\tsum += sz[x];\n\n\t\tll k = lower_bound (v.begin (), v.end (), make_pair (d + 2 * sz[x] - n, -1LL)) - v.begin ();\n\t\t\n\t\tif (k >= i || v[k].first != d + 2 * sz[x] - n)\n\t\t{\n\t\t    cout << -1;\n\t\t    return 0;\n\t\t}\n\t\t\n\t\tg[v[k].second].push_back (x);\n    }\n\n    if (sum != v[0].first)\n    {\n\t\tcout << -1;\n\t\treturn 0;\n    }\n    \n    for (ll i = 0; i < n; i++)\n\t\tfor (ll to : g[i])\n\t\t{\n\t\t    printf (\"%lld %lld\\n\", i + 1, to + 1);\n\t\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define ld long double\n#define F first\n#define S second\n#define pii pair<ll,ll>\n\nusing namespace :: std;\n\nconst ll maxn=1e5+1050;\nconst ll mod=1e9+7;\nconst ll inf=1e9+5;\n\nvector<pii> yal;\nll sz[maxn];\npii d[maxn];\n\nint main(){\n   ll n;\n   cin>>n;\n   ll sum=0;\n   for(ll i=0;i<n;i++){\n        cin>>d[i].F;\n        sum+=d[i].F;\n        d[i].S=i+1;\n   }\n   sort(d,d+n);\n   fill(sz,sz+maxn,1);\n   for(ll i=n-1;i>=1;i--){\n        ll v=d[i].S;\n        ll dpar=d[i].F+2*sz[v]-n;\n        ll K=lower_bound(d,d+n,mp(dpar,0LL))-d;\n        if(d[K].F!=dpar || dpar>=d[i].F || K>=n){\n            cout<<-1;\n            return 0;\n        }\n        ll par=d[K].S;\n        sum-=2*sz[v]*(n-sz[v]);\n        sz[par]+=sz[v];\n        yal.pb(mp(min(v,par),max(v,par)));\n   }\n   if(sum!=0){\n        cout<<-1;\n        return 0;\n   }\n   sort(yal.begin(),yal.end());\n   for(auto v:yal){\n        cout<<v.F<<' '<<v.S<<endl;\n   }\n}\n"
  },
  {
    "language": "C++",
    "code": "// Peace Of SHIT\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> pii;\nconst int maxn = 1e5 + 5;\nint n, si[maxn];\nint sum = 0;\nvector<int> e[maxn];\npii d[maxn];\n\nvoid impossible() {\n\tcout << -1;\n\texit(0);\n}\n\nvoid dfs(int u, int x) {\n\tsum += x;\n\tfor(int i = 0; i < e[u].size(); i++) {\n\t\tdfs(e[u][i], x + 1);\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tfor(int i = 0; i < n; i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\td[i] = {a, i};\n\t}\n\tsort(d, d + n);\n\treverse(d, d + n);\n\t\n\tvector <pii> k (d, d + n);\n\t\n\tfor(int q = 0; q < n - 1; q++) {\n\t\tint leaf = d[q].second;\n\t\tint parD = d[q].first - (n - (2 * (si[leaf] + 1)));\n\t\tauto it = lower_bound(k.rbegin(), k.rend(), pii(parD, 0));\n//\t\tcout << \"PAR : \" <<it->first << \" : \" << parD << '\\n';\n\t\tif(it -> first != parD) {\n//\t\t\tcerr << \"AVALI\\n\";\n\t\t\timpossible();\n\t\t}\n\t\tint par = it -> second;\n\t\tsi[par] += si[leaf] + 1;\n\t\tif((si[leaf] + 1) * 2 > n) {\n//\t\t\tcout << \"DOVOMI\\n\";\n\t\t\timpossible();\n\t\t}\n\t\t//SEVOMI HAM MISHE D[I] ROOT OK E ?\n\t\te[par].push_back(leaf);\n\t}\n\tint D = d[n - 1].second;\n\tdfs(D, 0);\n\tif(sum != d[n - 1].first)\n\t\timpossible();\n\tfor(int i = 0; i < n; i++) {\n\t\tfor(int j = 0; j < e[i].size(); j++)\n\t\t\tcout << i + 1 << \" \" << e[i][j] + 1 <<'\\n';\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define eb emplace_back\n#define mt make_tuple\n#define all(x) (x).begin(), (x).end() \n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair <int, int> ii;\ntypedef pair <ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef long double ld;\n\nconst ll INF=LLONG_MAX;\nconst int mxn=1e5+5;\nll sz[mxn],dis[mxn];\nvi adj[mxn];\nbool vis[mxn];\n\nvoid dfs(int u, int p=-1){\n\tfor(int v:adj[u])\n\t\tif(v!=p)dis[v]=dis[u]+1LL,dfs(v,u);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    //freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout);\n\tint n;\n\tcin >> n;\n\tpair<ll,int> dist[n];\n\tmap<ll,int>mp;\n\tfor(int i=0; i<n; i++){\n\t\tcin >> dist[i].fi;\n\t\tdist[i].se=i;\n\t\tsz[i]=1LL;\n\t\tmp[dist[i].fi]=i;\n\t}\n\tmap<ii,bool>edge;\n\tsort(dist,dist+n);\n\tfor(int i=n-1; i>0; i--){\n\t\tint ind = dist[i].se;\n\t\tll next = dist[i].fi-n+2*sz[ind];\n\t\tif(mp.find(next)==mp.end()){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint ptr = mp[next];\n\t\tif(ptr==ind){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsz[ptr] += sz[ind];\n\t\tif(ptr>ind)swap(ind,ptr);\n\t\tedge[ii(ptr,ind)]=1;\n\t\tadj[ind].eb(ptr);\n\t\tadj[ptr].eb(ind);\n\t\tvis[ind]=1; vis[ptr]=1;\n\t}\n\tbool ok=0;\n\tfor(int i=0; i<n&&!ok; i++)\n\t\tif(sz[i]==n)ok=1;\n\tfor(int i=0; i<n; i++)\n\t\tif(!vis[i])ok=0;\n\tdfs(dist[0].se);\n\tll sum = 0;\n\tfor(int i=0; i<n; i++)sum+=dis[i];\n\tif(sum!=dist[0].fi)ok=0;\n\tif(!ok)cout << -1 << endl;\n\telse{\n\t\tfor(auto x:edge)\n\t\t\tcout << x.fi.fi+1 << ' ' << x.fi.se+1 << endl;\n\t}\n}\n\t\n// READ & UNDERSTAND\n// ll, int overflow, array bounds, memset(0)\n// special cases (n=1?), n+1 (1-index)\n// do smth instead of nothing & stay organized\n// WRITE STUFF DOWN\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <numeric>\n#include <map>\n#define fail return puts(\"-1\"), 0\n\nconst int N = 1e5 + 5, M = 2e5 + 5;\n\nint n, tot, lnk[N], ter[M], nxt[M], sz[N], fa[N];\nlong long dep[N], d[N], D[N];\nstd::map<long long, int> mp;\n\nvoid add(int u, int v) {\n\tter[++tot] = v, nxt[tot] = lnk[u], lnk[u] = tot;\n}\nvoid dfs1(int u, int p) {\n\tsz[u] = 1;\n\tfor (int i = lnk[u]; i; i = nxt[i]) {\n\t\tint v = ter[i];\n\t\tif (v == p) continue;\n\t\tdep[v] = dep[u] + 1;\n\t\tdfs1(v, u);\n\t\tsz[u] += sz[v];\n\t}\n}\nvoid dfs2(int u, int p) {\n\tfor (int i = lnk[u]; i; i = nxt[i]) {\n\t\tint v = ter[i];\n\t\tif (v == p) continue;\n\t\tD[v] = D[u] - 2 * sz[v] + n;\n\t\tdfs2(v, u);\n\t}\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &d[i]);\n\t\tmp[d[i]] = i;\n\t\tsz[i] = 1;\n\t}\n\tint cnt = 0;\n\tfor (auto it = mp.rbegin(); it != mp.rend(); it++) {\n\t\tint v = it->second;\n\t\tlong long now = it->first;\n\t\tlong long s = now + 2 * sz[v] - n;\n\t\tif (!mp.count(s)) fail;\n\t\tint u = mp[s];\n\t\tif (u == v) fail;\n\t\tfa[v] = u, sz[u] += sz[v];\n\t\tadd(u, v), add(v, u);\n\t\tif (++cnt == n - 1) break;\n\t}\n\tdfs1(1, 0);\n\tD[1] = std::accumulate(dep + 1, dep + n + 1, 0LL);\n\tdfs2(1, 0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (D[i] != d[i]) fail;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (fa[i]) printf(\"%d %d\\n\", i, fa[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint N;\nint D[110000], n[110000];\nunordered_map<int, int> mp;\nvint ans;\nsigned main() {\n    cin >> N;\n    for (int i = 1; i <= N; i++) {cin >> D[i]; n[i] = 1; mp[D[i]] = i;};\n    sort(D + 1, D + N + 1); reverse(D + 1, D + N + 1);\n    for (int i = 1; i <= N - 1; i++) {\n        int s = mp[D[i]];\n        int t = mp[D[i] - N + 2 * n[s]];\n        if (2 * n[s] >= N || t == 0) {\n            cout << -1 << endl;\n            return 0;\n        }\n        n[t] += n[s];\n        ans.push_back(s); ans.push_back(t);\n    }\n    if (n[mp[D[N]]] != N) {\n        cout << -1 << endl;\n        return 0;\n    }\n    for (int i = 0; i < 2 * (N - 1); i += 2) {\n        cout << ans[i] << \" \" << ans[i + 1] << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\nconst int maxn=1e5+2;\nint n;\nmap<LL,int> mp;\nLL dis[maxn];\nint id[maxn],fa[maxn],siz[maxn];\nbool cmp(int x,int y){\n\treturn dis[x]>dis[y];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&dis[i]);\n\t\tsiz[i]=1;\n\t\tid[i]=mp[dis[i]]=i;\n\t}\n\tsort(id+1,id+n+1,cmp);\n\tfor (int i=1;i<n;i++){\n\t\tfa[id[i]]=mp[dis[id[i]]-n+2*siz[id[i]]];\n\t\tif (!fa[id[i]]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[fa[id[i]]]+=siz[id[i]];\n\t}\n\tfor (int i=1;i<n;i++) dis[id[n]]-=siz[id[i]];\n\tif (dis[id[n]]){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++) printf(\"%d %d\\n\",fa[id[i]],id[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fo(i,s,t) for(int i = s; i <= t; ++ i)\n#define fd(i,s,t) for(int i = s; i >= t; -- i)\n#define bf(i,s) for(int i = head[s]; i; i = e[i].next)\n#define mp make_pair\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pb push_back\n#define VI vector<int>\n#define sf scanf\n#define pf printf\n#define fp freopen\n#define SZ(x) ((int)(x).size())\n#ifdef MPS\n#define D(x...) printf(x)\n#else\n#define D(x...)\n#endif\ntypedef long long ll;\ntypedef double db;\ntypedef unsigned long long ull;\nconst int inf = 1<<30;\nconst ll INF = 1ll<<60;\nconst db Inf = 1e20;\nconst db eps = 1e-9;\n\nvoid gmax(int &a,int b){a = (a > b ? a : b);}\nvoid gmin(int &a,int b){a = (a < b ? a : b);}\n\nconst int maxn = 100050;\n\nint n, sz[maxn];\npair<ll,int> d[maxn];\nstruct edge{int u, v;}e[maxn];\n\nint main()\n{\n\tsf(\"%d\",&n);\n\tfo(i,1,n) sf(\"%I64d\",&d[i].fi), d[i].se = i;\n\tsort(d+1, d+n+1);\n\tfd(i,n,2)\n\t{\n\t\tsz[i] ++;\n\t\tint l = 1, r = i-1, mid, p = -1;\n\t\twhile(l <= r)\n\t\t{\n\t\t\tmid = (l + r) >> 1;\n\t\t\tif(d[mid].fi <= d[i].fi-n+2*sz[i]) p = mid, l = mid + 1;\n\t\t\telse r = mid - 1;\n\t\t}\n\t\tif(p == -1 || d[p].fi != d[i].fi-n+2*sz[i]) \n\t\t{\n\t\t\tassert(0);\n\t\t\treturn 0 * pf(\"-1\\n\");\n\t\t}\n\t\tsz[p] += sz[i];\n\t\te[i].u = d[p].se; e[i].v = d[i].se;\n\t}\n\tsz[1] ++;\n\tll ans = 0;\n\tfo(i,1,n) ans += sz[i] * (ll)(n - sz[i]);\n\tans <<= 1;\n\tfo(i,1,n) ans -= d[i].fi;\n\tif(ans != 0) return 0 * pf(\"-1\\n\");\n\tfo(i,2,n) pf(\"%d %d\\n\",e[i].u,e[i].v);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=5000005;\nstruct ab{int f,t;}t[N];\nint a[N],size[N],id[N],hh[N],h,tot;\nmap<int,int>mp;\nvoid make(int x,int y){t[++h].f=hh[x],t[h].t=y,hh[x]=h;}\nint cmp(int x,int y){return a[x]>a[y];}\nvoid dfs(int x,int y,int z)\n{\n\ttot+=z;\n\tfor(int i=hh[x];i;i=t[i].f)\n\t{\n\t\tint j=t[i].t;\n\t\tif(j==y) continue;\n\t\tdfs(j,x,z+1);\n\t}\n}\nsigned main()\n{\n\tint n;\n\tscanf(\"%lld\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",a+i),mp[a[i]]=i,size[i]=1,id[i]=i;\n\tsort(id+1,id+1+n,cmp);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x=id[i],y=a[x]-(n-size[x])+size[x];\n\t\tif(!mp[y]||y>=a[x]) return printf(\"-1\\n\"),0;\n\t\ty=mp[y];\n\t\tmake(x,y),make(y,x);\n\t\tsize[y]+=size[x];\n\t}\n\tdfs(id[n],0,0);\n\tif(tot!=a[id[n]]) return printf(\"-1\\n\"),0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=hh[i];j;j=t[j].f)\n\t\t{\n\t\t\tif(t[j].t>i) printf(\"%lld %lld\\n\",i,t[j].t);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = int(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = int(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\nusing ll = long long;\nusing namespace std;\n\nvector<pair<int, int> > solve(int n, vector<ll> const & d) {\n    map<ll, int> index;\n    REP (i, n) {\n        index[d[i]] = i;\n    }\n\n    int root = index.begin()->second;\n    vector<pair<int, int> > edges;\n    vector<vector<int> > children(n);\n    vector<int> size(n, 1);\n    vector<ll> d1(n, 0);\n    for (auto it = index.rbegin(); ; ++ it) {\n        auto [ d_i, i ] = *it;\n        if (i == root) break;\n        int d_parent = d_i - n + 2 * size[i];\n        if (not index.count(d_parent)) {\n            return vector<pair<int, int> >();\n        }\n        int parent = index[d_parent];\n        children[parent].push_back(i);\n        edges.emplace_back(parent, i);\n        size[parent] += size[i];\n        d1[parent] += d1[i] + size[i];\n    }\n\n    if (d1[root] != d[root]) {\n        return vector<pair<int, int> >();\n    }\n    return edges;\n}\n\nint main() {\n    int n; cin >> n;\n    vector<ll> d(n);\n    REP (i, n) cin >> d[i];\n    auto edges = solve(n, d);\n    if (edges.empty()) {\n        cout << -1 << endl;\n    } else {\n        for (auto [ i, j ] : edges) {\n            cout << i + 1 << ' ' << j + 1 << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> ii;\n\nconst int Maxn = 100005;\n\nint n;\nll D[Maxn];\nmap <ll, int> M;\nmap <ll, int> ind;\nvector <ii> res;\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lld\", &D[i]);\n        ind[D[i]] = i;\n        M[D[i]] = 0;\n    }\n    sort(D, D + n);\n    for (int i = n - 1; i > 0; i--) {\n        int my = M[D[i]] + 1;\n        if (my >= n - my) { printf(\"-1\\n\"); return 0; }\n        ll need = D[i] + 2ll * ll(my) - ll(n);\n        map <ll, int>::iterator it = M.find(need);\n        if (it == M.end()) { printf(\"-1\\n\"); return 0; }\n        it->second += my;\n        res.push_back(ii(ind[D[i]], ind[need]));\n    }\n    if (M[D[0]] != n - 1) { printf(\"-1\\n\"); return 0; }\n    for (int i = 0; i < n - 1; i++)\n        printf(\"%d %d\\n\", res[i].first + 1, res[i].second + 1);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nvector<l_l> D;\nll SIZE[100500];\nmap<ll, ll> mp;\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N;\n    cin >> N;\n    D.resize(N);\n    for(int i = 1; i <= N; i++) {\n        cin >> D[i-1].first;\n        D[i-1].second = i;\n        SIZE[i] = 1;\n        mp[D[i-1].first] = i;\n    }\n    sort(D.begin(), D.end(), greater<l_l>());\n    vector<l_l> ans;\n    for(int i = 0; i < N - 1; i++) {\n        int index = D[i].second;\n        ll val = D[i].first;\n        val += SIZE[index] - (N - SIZE[index]);\n        if(SIZE[index] * 2 >= N) {\n            cout << -1 << endl;\n            return 0;\n        }\n        if(mp[val] == 0) {\n            cout << -1 << endl;\n            return 0;\n        }\n        SIZE[mp[val]] += SIZE[index];\n        ans.push_back({index, mp[val]});\n    }\n    for(auto e : ans) cout << e.first << \" \" << e.second << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Generated at 2019-07-12 19:25:46 UTC+8\n//Created by Alphagocc\n#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n//C11\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdalign>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n// C++\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n// C++11\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <codecvt>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n// namespace IO \nnamespace IO\n{\ntemplate <typename T>\nvoid __RI(T &x)\n{\n    int ch = getchar(), neg = 1;\n    x = 0;\n    for (; !(isdigit(ch) || ch == '-' || ch == EOF); ch = getchar())\n        ;\n    if (ch == EOF) return;\n    if (ch == '-') neg = -1,ch=getchar();\n    for (; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n    x *= neg;\n}\nvoid R(int &x) { __RI(x); }\nvoid R(int64_t &x) { __RI(x); }\ntemplate <typename T1, typename T2>\nvoid R(std::pair<T1, T2> &x)\n{\n    R(x.first);\n    R(x.second);\n}\ntemplate <typename T>\nvoid R(std::vector<T> &x)\n{\n    for (auto &i : x) { R(i); }\n}\ntemplate <typename T>\nvoid R(T &x)\n{\n    std::cin >> x;\n}\ntemplate <typename T, typename... Args>\nvoid R(T &x, Args &... args)\n{\n    R(x), R(args...);\n}\nchar space = ' ';\ntemplate <typename T>\nvoid __WI(T x)\n{\n    if (x == 0) putchar('0');\n    if (x < 0) putchar('-'), x = -x;\n    char ch[ 64 ];\n    int  pos = 0;\n    while (x) ch[ pos++ ] = x % 10 + 48, x /= 10;\n    while (pos) putchar(ch[ --pos ]);\n}\nvoid W() {}\nvoid W(const int &x) { __WI(x); }\nvoid W(const int64_t &x) { __WI(x); }\nvoid W(const double &x) { printf(\"%lf\",static_cast<double>(x)); }\nvoid W(const char &x) { putchar(x); }\nvoid W(const std::string &x) { printf(\"%s\", x.c_str()); }\ntemplate <typename T1, typename T2>\nvoid W(const std::pair<T1, T2> &x)\n{\n    W(x.first);\n    W(space);\n    W(x.second);\n}\ntemplate <typename T>\nvoid W(const std::vector<T> &x)\n{\n    for (auto it = x.cbegin();it != x.cend(); it++)\n    {\n        W(*it);\n        W(space);\n    }\n    W('\\n');\n}\ntemplate <typename T>\nvoid W(const T &x)\n{\n    std::cout << x;\n}\ntemplate <typename T, typename... Args>\nvoid W(const T &x,const Args &... args)\n{\n    W(x), W(space), W(args...);\n}\ntemplate <typename... Args>\nvoid WL(const Args &... args)\n{\n    W(args...), W('\\n');\n}\n}; // namespace IO\nnamespace Alphagocc\n{\n    decltype(std::chrono::high_resolution_clock::now()) tStart;\n};\nvoid TimeBegin()\n{\n    Alphagocc::tStart=std::chrono::high_resolution_clock::now();\n}\nlong long TimeEnd()\n{\n    return (std::chrono::high_resolution_clock::now()-Alphagocc::tStart).count();\n}\nusing namespace std;\n\n#define REP(i, x, y) for (int i = x;i < y; i++)\n\nconst int8_t  INFC = 0x3f;\nconst int16_t INFS = 0x3f3f;\nconst int32_t INF  = 0x3f3f3f3f;\nconst int64_t INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int MAXN=1.1e5;\n\nint64_t d[MAXN];\nint used[MAXN];\nmap<int64_t,int> mapping;\n\nint main()\n{\n    int n;\n    IO::R(n);\n    mapping.clear();\n    for (int i=0;i<n;i++)\n    {\n        IO::R(d[i]);\n        mapping[d[i]]=i;\n    }\n    priority_queue<pair<int64_t,int>> pq;\n    while(!pq.empty()) pq.pop();\n    for (int i=0;i<n;i++)\n    {\n        pq.emplace(d[i],i);\n    }\n    int root=*min_element(d,d+n);\n    used[mapping[root]]=1;\n    while(!pq.empty())\n    {\n        int k=pq.top().first;\n        int pos=pq.top().second;\n        int p=n-2;\n        pq.pop();\n        if (used[pos]) \n        {\n            \n            continue;\n        }\n        while(k!=root)\n        {\n            int tk=k;\n            k-=p;\n            p-=2;\n            used[mapping[k]]=1;\n            IO::WL(mapping[tk]+1,mapping[k]+1);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define fi first\n#define SZ(x) (int((x).size()))\n#define se second\n#define ll long long\n#define pq priority_queue\n#define MP make_pair\n#define pii pair<int,int>\n#define mod 998244353\n#define debug(x) cerr<<#x<<\"=\"<<x<<'\\n'\n\nconst int maxn=1e6+10;\n\nint n;\nmap <ll,int> mp;\nll D[maxn];\npair<ll,int> d[maxn];\nint sz[maxn],f[maxn],dd[maxn];\nvector <int> e[maxn];\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) {\n\t\tll x;\n\t\tscanf(\"%I64d\",&x);\n\t\td[i]=MP(x,i);\n\t\tmp[x]=i;\n\t\tD[i]=x;\n\t}\n\tsort(d+1,d+n+1);\n\treverse(d+1,d+n+1);\n\tmemset(sz,0,sizeof(sz));\n\tmemset(f,0,sizeof(f));\n\tfor (int i=1;i<n;i++) {\n\t\tsz[d[i].se]++;\n\t\tif (n-2*sz[i]<=0) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tll want=d[i].fi-(ll)(n-2*sz[d[i].se]);\n\t\tif (mp.find(want)==mp.end()) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\te[d[i].se].pb(mp[want]);\n\t\te[mp[want]].pb(d[i].se);\n\t\tsz[mp[want]]+=sz[d[i].se];\n\t\tf[mp[want]]+=sz[d[i].se]+f[d[i].se];\n\t}\n\tif (f[d[n].se]!=D[d[n].se]) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=0;j<e[i].size();j++) {\n\t\t\tif (e[i][j]>i) printf(\"%d %d\\n\",i,e[i][j]);\n\t\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 100005;\n\nll distSum [MAX_N];\nint subSize [MAX_N];\n\nvector<int> adj [MAX_N];\nvoid addEdge (int u, int v) {\n  adj[u].push_back(v);\n  adj[v].push_back(u);\n}\n\nvoid distSumDfs (int vertex, int parent, int source, int lvl, ll &ans) {\n  ans += lvl;\n  for (int nxt : adj[vertex]) {\n    if (nxt != parent) {\n      distSumDfs(nxt, vertex, source, lvl + 1, ans);\n    }\n  }\n}\n\nint main () {\n  int vertexc;\n  cin >> vertexc;\n\n  vector<pair<ll, int>> elems;\n  map<ll, int> src;\n  fill(subSize + 1, subSize + vertexc + 1, 1);\n  for (int i = 1; i <= vertexc; i++) {\n    cin >> distSum[i];\n    \n    src[distSum[i]] = i;    \n    elems.push_back(make_pair(distSum[i], i));\n  }\n\n  sort(elems.begin(), elems.end(), greater<pair<ll, int>>());\n\n  for (pair<ll, int> pr : elems) {\n    if (pr == elems.back()) {\n      break;\n    }\n    \n    int vertex = pr.second;\n    int parentSum = distSum[vertex] + subSize[vertex] - (vertexc - subSize[vertex]);\n    if (src.count(parentSum) == 0) {\n      cout << -1 << endl;\n      return 0;\n    }\n\n    int parent = src[parentSum];\n    addEdge(vertex, parent);\n    subSize[parent] += subSize[vertex];\n  }\n\n  ll realD = 0;\n  distSumDfs(elems.back().second, -1, elems.back().second, 0, realD);\n  if (realD != elems.back().first) {\n    cout << -1 << endl;\n    return 0;\n  }\n\n  for (int i = 1; i <= vertexc; i++) {\n    for (int u : adj[i]) {\n      if (u < i) {\n        cout << u << \" \" << i << '\\n';\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define MAXN 100010\nusing namespace std;\nint sz[MAXN],ans1[MAXN],ans2[MAXN];\nmap<int,int> mp;\n/*struct node\n{\n\tLL k1,k2;\n\tbool operator <(const node &aa)\n\t{\n\t\treturn k1>aa.k1;\n\t}\n};\nset<node> S;*/\nstruct node\n{\n\tint k1,k2;\n}D[MAXN];\nbool cmp(node aa,node bb)\n{\n\treturn aa.k1>bb.k1;\n}\nint main()\n{\n\tLL N,i,lans,fa,dfa;\n\tscanf(\"%lld\",&N);\n\tfor(i=1;i<=N;i++){scanf(\"%lld\",&D[i].k1);mp[D[i].k1]=i;D[i].k2=i;}\n\tsort(D+1,D+N+1,cmp);\n\tmemset(sz,0,sizeof(sz));\n\tlans=0;\n\tfor(i=1;i<N;i++)\n\t{\n\t\tsz[D[i].k2]++;\n\t\tdfa=D[i].k1+sz[D[i].k2]-(N-sz[D[i].k2]);\n\t\tif(dfa>=D[i].k1){printf(\"-1\");return 0;}\n\t\tfa=mp[dfa];\n\t\tsz[fa]+=sz[D[i].k2];\n\t\tans1[++lans]=D[i].k2;ans2[lans]=fa;\n\t}\n\tfor(i=1;i<=lans;i++)printf(\"%d %d\\n\",ans1[i],ans2[i]);\n\t/*memset(sz,0,sizeof(sz));\n\twhile(1)\n\t{\n\t\tnode MX=*(S.begin());\n\t\tsz[MX.k2]=1;\n\t\twhile(1)\n\t\t{\n\t\t\t\n\t\t}\n\t\tif(tot==N-1)break;\n\t}*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define inf 0x3f3f3f3f3f3f3f3f\n#define inf 0x3f3f3f3f\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define inv(x) Power(x, mod - 2)\n#define fi first\n#define se second\n#define MP make_pair\n#define PB push_back\n\ntypedef std::vector<int> Poly;\ntypedef std::pair<int,int> Pair;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef long long ll;\n\nconst int maxn = 100000, maxm = 2000, MAX = 1e6 + 5, mod = 1000000;\n//template{{{\nconst long double Pi = 3.14159265358979323846l, Eps = 1e-4;\ntemplate <class T> inline bool equal(T x, T y) { return fabs(x - y) < Eps; }\ninline int add(int x, int y) { x += y; return x >= mod ? x - mod : x; };\ninline void inc(int &x, int y) { x += y; x -= (x >= mod ? mod : 0); }\ninline int mul(int x, int y) { return 1ll * x * y % mod; }\ninline int Power(int x, int y, int Mod = mod) {\n\tint ans = 1;\n\twhile (y) {\n\t\tif (y & 1) ans = (ll) ans * x % Mod;\n\t\tx = (ll) x * x % Mod, y >>= 1;\n\t} return ans;\n}\n\n/*char buf[1<<23],obuf[1<<23],*p1=buf,*p2=buf, *O = obuf;\n#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\nvoid print(int x) {\n    if(x > 9) print(x / 10);\n    *O++=x%10+'0';\n} */\n\ntemplate <class T> inline T\tinput() {\n\tT x; char ch; bool flag = false;\n\twhile (!isdigit(ch = getchar())) flag |= ch == '-';\n\tfor (x = ch ^ 48; isdigit(ch = getchar()); x = x * 10 + (ch ^ 48));\n\treturn flag ? -x : x;\n}\n\ntemplate <class T> inline bool chkmin(T &x, T y) { x = x < y ? x : y; return x == y; }\ntemplate <class T> inline bool chkmax(T &x, T y) { x = x > y ? x : y; return x == y; }\ntemplate <class T> inline T gcd(T x, T y) { return !y ? x : gcd(y, x % y); }\ntemplate <class T> inline T sqrm(T x) { return (ll) x * x % mod; }\ntemplate <class T> inline T sqr(T x) { return x * x; }\n\nstruct {\n\tinline operator int () { return input<int>(); }\n\tinline operator long long () { return input<long long>(); }\n\ttemplate <class T> inline void operator () (T &x) { x = *this; }\n\ttemplate<class T, class ...A> inline void operator () (T &x, A &...a)\n\t{ x = *this; this -> operator ()(a...); }\n} read; //}}}\n\nint n;\nll d[maxn + 5];\nint size[maxn + 5];\nstd::map<ll, int> id;\nstd::pair<ll, int> p[maxn + 5];\nint fa[maxn + 5];\n\nsigned main() {\n#ifdef local\n\tfreopen(\"in\", \"r\", stdin);\n\tfreopen(\"out\", \"w\", stdout);\n\tfreopen(\"log\", \"w\", stderr);\n#endif\n\n\tn = read;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tp[i].fi = d[i] = read;\n\t\tp[i].se = id[d[i]] = i;\n\t\tsize[i] = 1;\n\t}\n\n\tstd::sort(p + 1, p + n + 1);\n\tfor (int i = n; i > 1; --i) {\n\t\tll df = p[i].fi - n + size[p[i].se] * 2;\n\t\tfa[p[i].se] = id[df], size[fa[p[i].se]] += size[p[i].se];\n\t\tif (!fa[p[i].se] || fa[p[i].se] == p[i].se) return puts(\"-1\"), 0;\n\t}\n\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (fa[i]) printf(\"%d %d\\n\", i, fa[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,j,k) for(int i=j;i<=k;++i)\ntypedef long long ll;\nchar cch;\ninline int rd(){\n\tint x=0,fl=1;\n\tcch=getchar();\n\twhile(cch>'9'||cch<'0'){\n\t\tif(cch=='-') fl=-1;\n\t\tcch=getchar();\n\t}\n\twhile(cch>='0'&&cch<='9') x=(x<<3)+(x<<1)+cch-'0',cch=getchar();\n\treturn x*fl;\n}\nconst int N=1e5+3;\nstruct abc{\n\tint i;\n\tll d;\n}a[N];\nint fr[N],head[N],to[N],nxt[N],cnt,sz[N];\nll re,c[N];\ninline bool cmp(const abc &a,const abc &b){\n\treturn a.d<b.d;\n}\ninline void adde(int u,int v){\n\tto[++cnt]=v,fr[cnt]=u,nxt[cnt]=head[u],head[u]=cnt;\n}\ninline void dfs(int u,int fa,int dep){\n\tre+=dep;\n\tfor(int i=head[u];i;i=nxt[i]){\n\t\tdfs(to[i],fa,dep+1);\n\t}\n}\nint main(){\n\tint n=rd();\n\trep(i,1,n) a[i].d=rd(),a[i].i=i;\n\tsort(a+1,a+1+n,cmp);\n\trep(i,1,n) c[i]=a[i].d;\n\tint pos;\n\tll tmp;\n\tfor(int i=n;i>1;--i){\n\t\ttmp=a[i].d-(n-2-sz[a[i].i])+sz[a[i].i];\n\t\tpos=lower_bound(c+1,c+n+1,tmp)-c;\n\t\tif(c[pos]!=tmp){\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t\telse sz[a[pos].i]+=sz[a[i].i]+1,adde(a[pos].i,a[i].i);\n\t}\n\tdfs(a[1].i,0,0);\n\tif(re!=a[1].d){\n\t\tputs(\"-1\");return 0;\n\t}\n\tfor(int i=1;i<n;++i){\n\t\tprintf(\"%d %d\\n\",fr[i],to[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define fi first\n#define SZ(x) (int((x).size()))\n#define se second\n#define ll long long\n#define pq priority_queue\n#define MP make_pair\n#define pii pair<int,int>\n#define mod 998244353\n#define debug(x) cerr<<#x<<\"=\"<<x<<'\\n'\n\nconst int maxn=1e6+10;\n\nint n;\nmap <ll,int> mp;\nll D[maxn];\npair<ll,int> d[maxn];\nint sz[maxn];\nll f[maxn];\nvector <int> e[maxn];\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) {\n\t\tll x;\n\t\tscanf(\"%lld\",&x);\n\t\td[i]=MP(x,i);\n\t\tmp[x]=i;\n\t\tD[i]=x;\n\t}\n\tsort(d+1,d+n+1);\n\treverse(d+1,d+n+1);\n\tmemset(sz,0,sizeof(sz));\n\tmemset(f,0,sizeof(f));\n\tfor (int i=1;i<n;i++) {\n\t\tsz[d[i].se]++;\n\t\tif (n-2*sz[i]<=0) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tll want=d[i].fi-(ll)(n-2*sz[d[i].se]);\n\t\tif (mp.find(want)==mp.end()) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\te[d[i].se].pb(mp[want]);\n\t\te[mp[want]].pb(d[i].se);\n\t\tsz[mp[want]]+=sz[d[i].se];\n\t\tf[mp[want]]+=(ll)sz[d[i].se]+f[d[i].se];\n\t}\n\tif (f[d[n].se]!=D[d[n].se]) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=0;j<e[i].size();j++) {\n\t\t\tif (e[i][j]>i) printf(\"%d %d\\n\",i,e[i][j]);\n\t\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double PI = acos(-1);\nconst double EPS = 1e-15;\nusing ll = long long;\nusing ull = unsigned long long;\nconst int inf = 2e9;\nconst ll INF = 2e18;\nconst ll MOD = 1e9+7;\nconst ll MOD1 = 998244353;\n//typedef pair<int,int> P;\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define sz(s) (s).size()\n#define pb push_back\n#define fi first\n#define se second\n//#define mp make_pair\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  ll n;\n  cin >> n;\n\n  //現在のノード数に対応する次のノードまでのsumの変化値\n  ll diff[n/2+1] = {};\n  for (int i = 1; i <= n / 2; i++) {\n    diff[i] = n - i * 2;\n  }\n\n  //sumとノード番号の対応\n  map<ll,ll> mp;\n  //sumを入れるところ\n  vector<ll> v;\n  for (ll i = 0; i < n; i++) {\n    ll a;\n    cin >> a;\n    mp[a] = i+1;\n    v.pb(a);\n  }\n\n  sort(v.rbegin(),v.rend());\n\n  //答え\n  vector<pair<ll,ll>> ans;\n\n  //最後尾のノードをsetに入れる\n  //つながってたら消す\n  set<ll> st;\n\n  //予測するため，つぎのノードのsumをnextに入れる\n  set<ll> next;\n  //前のノードを記録する\n  vector<ll> pre[100010];\n  //次への変化値を知るため，ノード数をlvに記録する\n  map<ll,ll> lv;\n\n  /*****手順*******/\n  //現在のノードがnext候補にあるとき\n  ////グラフを構築する\n  ////lvを数える\n  ////前のノードをstから消す\n  ////現在のノードをnextから消す\n  ////現在のノードをstに入れる\n  ////次のノードをnextに入れる\n\n  //現在のノードがnext候補にないとき\n  ////新しくstに入れる\n  ////nextに挿入\n\n  //最後にnextに要素があるときは-1\n  //nextが一つだけの時はok\n\n  for (ll i = 0; i < n; i++) {\n    if (next.count(v[i])) {\n      for (int j = 0; j < pre[mp[v[i]]].size(); j++) {\n        ans.pb({mp[v[i]], mp[pre[mp[v[i]]][j]]});\n        st.erase(pre[mp[v[i]]][j]);\n        lv[v[i]] += lv[pre[mp[v[i]]][j]];\n      }\n      lv[v[i]]++;\n      st.insert(v[i]);\n      next.erase(v[i]);\n      if (!mp.count(v[i] - diff[lv[v[i]]]) && i != n - 1) {\n        cout << -1 << endl;\n        return 0;\n      }\n      pre[mp[v[i] - diff[lv[v[i]]]]].pb(v[i]);\n      next.insert(v[i] - diff[lv[v[i]]]);\n    } else {\n      st.insert(v[i]);\n      lv[v[i]] = 1;\n      if (!mp.count(v[i] - diff[lv[v[i]]])) {\n        cout << -1 << endl;\n        return 0;\n      }\n      pre[mp[v[i] - diff[lv[v[i]]]]].pb(v[i]);\n      next.insert(v[i] - diff[lv[v[i]]]);\n    }\n  }\n\n  if (st.size() != 1) {\n    cout << -1 << endl;\n    return 0;\n  }\n  REP(i,sz(ans)) {\n    cout << ans[i].fi << \" \" << ans[i].se << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n, sz[100007], fa[100007];\npair<int, int>p[100007];\nvector<int>e[100007];\nint read()\n{\n\tint num = 0;\n\tchar c = getchar();\n\twhile (c<'0' || c>'9')c = getchar();\n\twhile (c >= '0' && c <= '9')num = num * 10 + c - '0', c = getchar();\n\treturn num;\n}\nint dfs(int w, int f)\n{\n\tint res = 0;\n\tfor (int i = 0, lim = e[w].size(); i < lim; i++)\n\t\tres += dfs(e[w][i], w) + sz[e[w][i]];\n\treturn res;\n}\nsigned main()\n{\n\tn = read();\n\tfor (int i = 1; i <= n; i++)\n\t\tp[i] = make_pair(read(), i);\n\tsort(p + 1, p + n + 1);\n\tfor (int i = n; i > 1; i--)\n\t{\n\t\tint x = p[i].second;\n\t\tsz[x]++;\n\t\tint pos = lower_bound(p + 1, p + n + 1, make_pair(p[i].first + 2 * sz[x] - n, 0LL)) - p;\n\t\tif (pos >= i || p[i].first + 2 * sz[x] - n != p[pos].first) { cout << -1 << endl; return 0; }\n\t\tfa[x] = p[pos].second;\n\t\tsz[fa[x]] += sz[x];\n\t\te[fa[x]].push_back(x);\n\t}\n\tsz[p[1].second]++;\n\tif(dfs(p[1].second,0)!=p[1].first) { cout << -1 << endl; return 0; }\n\tfor (int i = 1; i <= n; i++)\n\t\tif (fa[i])printf(\"%lld %lld\\n\", fa[i], i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long s64; \ntypedef std::pair<int, int> pii; \n\ntemplate <class T>\ninline void read(T &x) {\n\tstatic char ch; \n\twhile (!isdigit(ch = getchar())); \n\tx = ch - '0'; \n\twhile (isdigit(ch = getchar()))\n\t\tx = x * 10 + ch - '0'; \n}\n\ninline void invalid() {\n\tputs(\"-1\"); \n\texit(0); \n}\n\nconst int MaxN = 1e5 + 5;  \n\nint n; \nint sze[MaxN]; \nbool vis[MaxN]; \n\ns64 d[MaxN], c[MaxN];\nstd::vector<pii> ans; \nstd::map<int, int> pos; \n\nint fa[MaxN]; \nstd::vector<int> adj[MaxN]; \n\ninline void addEdge(int u, int v) {\n\tsze[u] += sze[v]; \n\tadj[u].push_back(v); \n\tans.push_back(pii(u, v)); \n}\n\ninline void dfs(int u) {\n\tfor (int v : adj[u]) {\n\t\tdfs(v); \n\t\tc[u] += c[v] + sze[v]; \n\t}\n}\n\nbool check() {\n\tint G = pos[d[n]]; \n\treturn dfs(G), c[G] == d[n]; \n}\n\nint main() {\n#ifdef orzczk\n\tfreopen(\"tree.in\", \"r\", stdin); \n#endif\n\t\n\tread(n); \n\tfor (int i = 1; i <= n; ++i) {\n\t\tread(d[i]); \n\t\tsze[i] = 1; \n\t\tpos[d[i]] = i; \n\t}\n\tstd::sort(d + 1, d + n + 1, std::greater<int>()); \n\n\tfor (int i = 1; i < n; ++i) {\n\t\tint v = pos[d[i]], u; \n\t\ts64 faD = d[i] - n + 2 * sze[v]; \n\n\t\tvis[v] = true; \n\t\tif (!pos.count(faD) || vis[u = pos[faD]]) {\n\t\t\tinvalid(); \n\t\t}\n\t\t\n\t\taddEdge(u, v); \n\t}\n\n\tif (check()) {\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\tprintf(\"%d %d\\n\", ans[i].first, ans[i].second); \n\t\t}\n\t} else {\n\t\tinvalid(); \n\t}\n\n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nll N;\nll D[100010];\nll sz[100010];\nvector<int> ord;\nvector<int> g[100010];\nvector<P> res;\nmap<ll,int> idx;\n\nll dfs(int v){\n  ll sum=0;\n  for(int nv : g[v]){\n    sum+=dfs(nv)+sz[nv];\n  }\n  return sum;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin>>N;\n  rep(i,N){\n    cin>>D[i];\n    ord.push_back(i);\n    sz[i]=1;\n    idx[D[i]]=i;\n  }\n  sort(all(ord),[=](const int& a,const int& b){ return D[a] > D[b];});\n  rep(j,ord.size()-1){\n    int i=ord[j];\n    ll nsz=D[i]+2*sz[i]-N;\n    if(idx.find(nsz)==idx.end()){\n      cout<<-1<<endl;\n      return 0;\n    }\n    int nxt=idx[nsz];\n    sz[nxt]+=sz[i]; res.push_back(P(nxt,i)); g[nxt].push_back(i);\n  }\n  if(sz[ord.back()]!=N){\n    cout<<-1<<endl;\n    return 0;\n  }\n  if(dfs(ord.back())!=D[ord.back()]){\n    cout<<-1<<endl;\n    return 0;\n  }\n  rep(i,res.size())cout<<res[i].fi+1<<\" \"<<res[i].se+1<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<map>\n#include<cmath>\n#include<algorithm>\n#define N 100005\nusing namespace std;\nstruct with {\n\tint w;\n\tlong long d;\n} dt[N];\nmap<long long, int> chk;\nint n;\nint parent[N],subn[N];\nlong long d[N];\nlong long sum[N];\nbool cmp(with i, with j) {\n\treturn i.d < j.d;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tint i;\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &d[i]);\n\t\tdt[i].d = d[i]; dt[i].w = i;\n\t\tsubn[i] = 1;\n\t}\n\tsort(dt + 1, dt + 1 + n, cmp);\n\tsort(d + 1, d + 1 + n);\n\tfor (i = 1; i <= n; i++) chk[d[i]] = i;\n\tbool imp = false;\n\tfor (i = n ; i >= 2; i--) {\n\t\tint adjacent=0;\n\t\tadjacent = chk[d[i] - n + 2 * subn[i]];\n\t\tparent[i] = adjacent;\n\t\tsubn[adjacent]+=subn[i];\n\t\tif (parent[i] == 0 || parent[i]==i) {\n\t\t\timp = true; break;\n\t\t}\n\t}\n\tfor (i = n; i >= 2; i--) {\n\t\tint up = parent[i];\n\t\tsum[up] += sum[i] + subn[i];\n\t}\n\tif (sum[1] != d[1]) imp = true;\n\tif (imp) printf(\"-1\");\n\telse {\n\t\tfor (i = 2; i <= n; i++) {\n\t\t\tprintf(\"%d %d\\n\", dt[parent[i]].w,dt[i].w);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target (\"avx2\")\n//#pragma GCC optimization (\"unroll-loops\")\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include \"bits/stdc++.h\"\n#include \"ext/pb_ds/tree_policy.hpp\"\n#include \"ext/pb_ds/assoc_container.hpp\"\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\nconst long double PI = 4*atan(1);\n\ntypedef long long ll;\ntypedef long double ld;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ld, ld> pd;\ntypedef complex<ld> cd;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define f0r(i,a) for(int i=0;i<a;i++)\n#define f1r(i,a,b) for(int i=a;i<b;i++)\n#define trav(a, x) for (auto& a : x)\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)(x).size()\n#define all(x) x.begin(), x.end()\n#define rall(x) rbegin(x), rend(x)\n#define resz resize\n#define ins insert\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &cout, pair<A, B> const &p) { return cout << \"(\" << p.f << \", \" << p.s << \")\"; }\ntemplate<typename A> ostream& operator<<(ostream &cout, vector<A> const &v) {\n  cout << \"[\"; for(int i = 0; i < v.size(); i++) {if (i) cout << \", \"; cout << v[i];} return cout << \"]\";\n}\n\ntemplate<class T> bool ckmin(T& a, const T& b) {\n\treturn a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\nnamespace input {\n\ttemplate<class T> void re(complex<T>& x);\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p);\n\ttemplate<class T> void re(vector<T>& a);\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a);\n\n\ttemplate<class T> void re(T& x) { cin >> x; }\n\tvoid re(double& x) { string t; re(t); x = stod(t); }\n\tvoid re(ld& x) { string t; re(t); x = stold(t); }\n\ttemplate<class T, class... Ts> void re(T& t, Ts&... ts) {\n\t\tre(t); re(ts...);\n\t}\n\n\ttemplate<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n\ttemplate<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n\tvoid pr(int x) { cout << x; }\n\tvoid pr(long x) { cout << x; }\n\tvoid pr(ll x) { cout << x; }\n\tvoid pr(unsigned x) { cout << x; }\n\tvoid pr(unsigned long x) { cout << x; }\n\tvoid pr(unsigned long long x) { cout << x; }\n\tvoid pr(float x) { cout << x; }\n\tvoid pr(double x) { cout << x; }\n\tvoid pr(ld x) { cout << x; }\n\tvoid pr(char x) { cout << x; }\n\tvoid pr(const char* x) { cout << x; }\n\tvoid pr(const string& x) { cout << x; }\n\tvoid pr(bool x) { pr(x ? \"true\" : \"false\"); }\n\ttemplate<class T> void pr(const complex<T>& x) { cout << x; }\n\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x);\n\ttemplate<class T> void pr(const T& x);\n\n\ttemplate<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n\t\tpr(t); pr(ts...);\n\t}\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x) {\n\t\tpr(\"{\",x.f,\", \",x.s,\"}\");\n\t}\n\ttemplate<class T> void pr(const T& x) {\n\t\tpr(\"{\"); // const iterator needed for vector<bool>\n\t\tbool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0;\n\t\tpr(\"}\");\n\t}\n\n\tvoid ps() { pr(\"\\n\"); } // print w/ spaces\n\ttemplate<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n\t\tpr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...);\n\t}\n\n\tvoid pc() { pr(\"]\\n\"); } // debug w/ commas\n\ttemplate<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n\t\tpr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...);\n\t}\n\t#define dbg(x...) pr(\"[\",#x,\"] = [\"), pc(x);\n}\n\nusing namespace output;\n\nnamespace io {\n\tvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n\tvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n\tvoid setIO(string s = \"\") {\n\t\tcin.sync_with_stdio(0); cin.tie(0); // fast I/O\n\t\t// cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n\t\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n\t}\n}\n\nusing namespace io;\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll MOD = 1e9 + 7;\n\ntypedef decay<decltype(MOD)>::type T;\nstruct mi {\n\tT val;\n\texplicit operator T() const { return val; }\n\tmi() { val = 0; }\n\tmi(const ll& v) {\n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\t// friend ostream& operator<<(ostream& os, const mi& a) {\n\t\t// return os << a.val; }\n\tfriend void pr(const mi& a) { pr(a.val); }\n\tfriend void re(mi& a) { ll x; re(x); a = mi(x); }\n\n\tfriend bool operator==(const mi& a, const mi& b) {\n\t\treturn a.val == b.val; }\n\tfriend bool operator!=(const mi& a, const mi& b) {\n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) {\n\t\treturn a.val < b.val; }\n\n\tmi operator-() const { return mi(-val); }\n\tmi& operator+=(const mi& m) {\n\t\tif ((val += m.val) >= MOD) val -= MOD;\n\t\treturn *this; }\n\tmi& operator-=(const mi& m) {\n\t\tif ((val -= m.val) < 0) val += MOD;\n\t\treturn *this; }\n\tmi& operator*=(const mi& m) {\n\t\tval = (ll)val*m.val%MOD; return *this; }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) {\n\t\tassert(a != 0); return pow(a,MOD-2); }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n};\n\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\nconst int MAX = 1e5 + 5;\nconst int INF = 1e9;\nmap<ll, int> conv;\nvpi edges;\nvi adj[MAX];\nll depth[MAX];\nvoid dfs_depth(int src, int par){\n    for(int nxt: adj[src]){\n        if(nxt == par) continue;\n        depth[nxt] = depth[src]+1;\n        dfs_depth(nxt, src);\n    }\n}\nint main(){\n    int n; re(n);\n    vl d(n);\n    f0r(i, n) re(d[i]);\n    set<pair<ll, int>, greater<pair<ll, int>>> s;\n    f0r(i, n) s.insert(mp(d[i], 1));\n    f0r(i, n) conv[d[i]] = i;\n    while(sz(s)>1){\n        auto ft = *s.begin();\n        s.erase(ft);\n        ll nxt = ft.f + 2*ft.s - n;\n        auto it = s.lb(mp(nxt, INF));\n        if(it == s.end()){\n            ps(-1); return 0;\n        }\n        auto tmp = *it;\n        if(tmp.f != nxt){\n            ps(-1); return 0;\n        }\n        edges.eb(mp(conv[ft.f], conv[tmp.f]));\n        s.erase(tmp);\n        tmp.s += ft.s;\n        s.insert(tmp);\n    }\n    int root = conv[(*s.begin()).f];\n    ll val = (*s.begin()).f;\n    for(auto e: edges) adj[e.f].eb(e.s), adj[e.s].eb(e.f);\n    dfs_depth(root, -1);\n    f0r(i, n) val -= depth[i];\n    if(val != 0){\n        ps(-1); return 0;\n    }\n    for(auto e: edges) ps(e.f+1, e.s+1);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\nconst int N = 2e5;\nint n, cnt;\nint fa[N], ff[N];\nLL di[N], siz[N];\nmap <LL, int> val;\npair <int, int> edges[N];\nint ord[N];\nint get_f(int t)\n{\n    if (ff[t] == t) return t;\n    else return ff[t] = get_f(ff[t]);\n}\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; ++ i) scanf(\"%lld\", &di[i]);\n    for (int i = 1; i <= n; ++ i) ord[i] = i, val[di[i]] = i, ff[i] = i;\n    sort(ord + 1, ord + n + 1, [=](int a, int b) {return di[a] > di[b];});\n    for (int i = 1; i < n; ++ i)\n    {\n        int p = ord[i];\n        siz[p] += 1;\n        LL q = di[p] + siz[p] * 2 - n;\n        if (!val.count(q)) {puts(\"-1\"); return 0;}\n        fa[p] = val[q];\n        if (ord[p] > ord[fa[p]]) {puts(\"-1\"); return 0;}\n        if (get_f(p) == get_f(fa[p])) {puts(\"-1\"); return 0;}\n        ff[get_f(p)] = get_f(fa[p]);\n        siz[fa[p]] += siz[p];\n        edges[i] = make_pair(p, fa[p]);\n    }\n    for (int i = 1; i < n; ++ i) printf(\"%d %d\\n\", edges[i].first, edges[i].second);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define int long long\nsigned main(){\n    int n;\n    cin >> n;\n    vector<pair<int,int> > v;\n    map<int,int> p;\n    rep(i,n){\n        int d;\n        cin >> d;\n        p[d] = i+1;\n        v.push_back(MP(d,i+1));\n    }\n    sort(v.begin(),v.end(),greater<pair<int,int> >());\n    map<int,int> mp;\n    vector<pair<int,int> > g;\n    bool ng = 1;\n    rep(i,n){\n        int k = v[i].first;\n        int u = v[i].second;\n        int c = mp[k];\n        c++;\n        //cerr << k << \" \" << u << \" \" << c << endl;\n        if(c==n){\n            ng = 0;\n            continue;\n        }\n        int nxt = k - (n-c-c);\n        if(p.find(nxt)==p.end()){\n            cout << -1 << endl;\n            return 0;\n        }\n        mp[nxt]+=c;\n        g.push_back(MP(u,p[nxt]));\n    }\n    if(ng){\n        cout << -1 << endl;\n        return 0;\n    }\n    for(auto x:g){\n        cout << x.first << \" \" << x.second << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(X,A,B) for(int X=A;X<=B;X++)\n#define tep(X,A,B) for(int X=A;X>=B;X--)\n#define LL long long\n#define DB double\nconst int N=400010;\nconst int M=800010;\nconst LL INF=1e15;\nusing namespace std;\n\nint n,fa[N],sz[N];\nint edge[M],lst[N],nxt[M],t=0;\nLL sum=0;\n\nstruct nn{\n\tLL d;\n\tint x;\n}a[N];\n\nint cmp(nn A,nn B){\n\treturn A.d<B.d;\n}\n\nvoid ADD(int x,int y){\n\tedge[++t]=y;nxt[t]=lst[x];lst[x]=t;\n}\n\nvoid READ(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n)scanf(\"%lld\",&a[i].d),a[i].x=i;\n\tsort(a+1,a+n+1,cmp);\n}\n\nint GET(int pos,int x){\n\tint l=1,r=pos;\n\twhile(l<=r){\n\t\tint mid=(l+r)>>1;\n\t\tif(a[mid].d==x)return mid;\n\t\tif(a[mid].d<x)l=mid+1;\n\t\telse r=mid-1;\n\t}\n\treturn 0;\n}\n\nvoid SEARCH(int x,int dep){\n\tsum+=dep;\n\tfor(int r=lst[x];r;r=nxt[r]){\n\t\tSEARCH(edge[r],dep+1);\n\t}\n}\n\nint SOLVE(){\n\trep(i,1,n)sz[i]=1;\n\ttep(i,n,2){\n\t\tint x=a[i].x;\n\t\tLL df=a[i].d+2*sz[x]-n;\n\t\tint pos=GET(i-1,df);\n\t\tif(!pos||df>=a[i].d)return 0;\n\t\tint pa;\n\t\tfa[x]=pa=a[pos].x;\n\t\tADD(pa,x);\n\t\tsz[pa]+=sz[x];\n\t}\n\tsum=0;\n\tSEARCH(a[1].x,0);\n\tif(sum!=a[1].d)return 0;\n\trep(i,2,n)printf(\"%d %d\\n\",fa[a[i].x],a[i].x);\n\treturn 1;\n}\n\nint main(){\n\tREAD();\n\tif(SOLVE()==0)printf(\"-1\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#include <queue>\n#include <vector>\n#define PB push_back\n#define MP make_pair\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=1e5+10;\nstruct node {\n\tint id; ll d;\n\tnode(int id=0,ll d=0): id(id),d(d) {}\n\tfriend bool operator <(node A,node B) { return A.d<B.d; }\n};\npriority_queue<node> que;\nmap<ll,int> mp;\nint n,sz[N];\nll d[N];\nvector< pair<int,int> > E;\nvector<int> son[N];\nll dfs(int u) {\n\tll tot=0;\n\tfor(int i=0;i<son[u].size();++i) tot+=dfs(son[u][i])+sz[son[u][i]];\n\treturn tot;\n}\nint main() {\n\trd(n);\n\tfor(int i=1;i<=n;++i) {\n\t\trd(d[i]),mp[d[i]]=i;\n\t\tque.push(node(i,d[i]));\n\t\tsz[i]=1;\n\t}\n\twhile(que.size()>1) {\n\t\tint u=que.top().id; que.pop();\n\t\tmp.erase(d[u]);\n\t\tll t=d[u]-(n-sz[u]*2ll);\n\t\tif(!mp.count(t)) {\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint f=mp[t];\n\t\tE.PB(MP(f,u));\n\t\tson[f].PB(u);\n\t\tsz[f]+=sz[u];\n\t}\n\tint rt=que.top().id;\n\tif(dfs(rt)!=d[rt]) {\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<E.size();++i) printf(\"%d %d\\n\",E[i].first,E[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100005\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate <class T> inline void read(T &x) {\n\tchar ch; bool flag = false;\n\twhile (!isdigit(ch = getchar())) flag |= ch == '-';\n\tfor (x = ch ^ 48; isdigit(ch = getchar()); x = x * 10 + (ch ^ 48));\n\tif (flag) x = -x;\n}\n\ninline int input() {\n\tint x; char ch; bool flag = false;\n\twhile (!isdigit(ch = getchar())) flag |= ch == '-';\n\tfor (x = ch ^ 48; isdigit(ch = getchar()); x = x * 10 + (ch ^ 48));\n\treturn flag ? -x : x;\n}\n\nconst int mod = 1e9 + 7;\ninline int add(int x, int y) { x += y; return x >= mod ? x - mod : x; }\ninline void inc(int &x, int y) { x += y; x -= x >= mod ? mod : 0; }\n\ninline int Power(int x, int y) {\n\tint res = 1;\n\twhile (y) {\n\t\tif (y & 1) res = (ll) res * x % mod;\n\t\tx = (ll) x * x % mod, y >>= 1;\n\t} return res;\n}\n\ntemplate <class T> void chkmax(T &x, T y) { x = x > y ? x : y; }\ntemplate <class T> void chkmin(T &x, T y) { x = x < y ? x : y; }\ntemplate <class T> T gcd(T x, T y) { return !y ? x : gcd(x % y, y); }\n\nll n, Dis;\nll d[N], dis[N];\nll size[N], fa[N];\nmap<ll, ll> mp;\nvector<ll> G[N];\n\t\nvoid FAIL() {\n\tputs(\"-1\");\n\texit(0);\n}\n\nll id(ll x) { return mp[d[x]]; }\ninline void AddEdge(int x, int y) { G[x].push_back(y); }\n\ninline void dfs(int u) {\n\tDis += dis[u];\n\tfor (int v : G[u]) dis[v] = dis[u] + 1, dfs(v);\n}\n\nbool check() {\n\tdfs(1);\n\treturn Dis == d[1];\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor (ll i = 1; i <= n; ++i) size[i] = 1;\n\tfor (ll i = 1; i <= n; ++i) {\n\t\tcin >> d[i], mp[d[i]] = i;\n\t\tif (d[i] > (ll) n * (n - 1) / 2) FAIL();\n\t}\n\tsort(d + 1, d + n + 1);\n\n\tfor (ll i = n; i > 1; --i) {\n\t\tll vf = d[i] - n + size[i] + size[i];\n\t\tif (vf >= d[i]) FAIL();\n\t\tfa[i] = lower_bound(d + 1, d + n + 1, vf) - d;\n\t\tif (d[fa[i]] != vf) FAIL();\n\t\tsize[fa[i]] += size[i];\n\t}\n\n\tfor (ll i = 2; i <= n; ++i)\n\t\tAddEdge(fa[i], i);\n\tif (!check()) FAIL();\n\telse for (ll i = 2; i <= n; ++i)\n\t\tprintf(\"%lld %lld\\n\", id(i), id(fa[i]));\n\treturn 0;\n}\n\t\t\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\nusing namespace std;\nint n,d[100005];\nint main(){\n\tcin>>n;\n\tvector<long long>a,qz(n,1),dist(n,-1),x(1,0);\n\tmap<long long,int>mp;\n\tvector<pair<int,int> >res;\n\tvector<vector<int> >nmp(n);\n\tfor(int i=0;i<n;i++){\n\t\tcin>>d[i];\n\t\ta.push_back(d[i]);\n\t\tmp[d[i]]=i;\n\t}\n\tsort(d,d+n);\n\tfor(int i=n-1;i>=1;i--){\n\t\tlong long net=d[i]-(n-qz[mp[d[i]]]*2);\n\t\tif(mp.find(net)==mp.end()||mp[net]==mp[d[i]]){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tres.push_back(make_pair(mp[d[i]],mp[net]));\n\t\tqz[mp[net]]+=qz[mp[d[i]]];\n\t\tmp.erase(--mp.end());\t\t\n\t}\n\tdist[0]=0;\n\tfor(int i=0;i<res.size();i++){\n\t\tnmp[res[i].first].push_back(res[i].second);\n\t\tnmp[res[i].second].push_back(res[i].first);\n\t}\n\tfor(int i=0;i<x.size();i++){\n\t\tfor(int j=0;j<nmp[x[i]].size();j++){\n\t\t\tif(dist[nmp[x[i]][j]]==-1){\n\t\t\t\tx.push_back(nmp[x[i]][j]);\n\t\t\t\tdist[nmp[x[i]][j]]=dist[x[i]]+1;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ansd=0;\n\tfor(int i=0;i<dist.size();i++){\n\t\tansd+=dist[i];\n\t}\n\tif(ansd!=a[0]){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<res.size();i++){\n\t\tcout<<res[i].first+1<<\" \"<<res[i].second+1<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint n;\nvector<pair<ll,int>> v;\nvector<int> fa,siz;\nvector<vector<int>> G;\nll tot;\nvoid dfs(int u,int par,ll d){\n    tot += d;\n    for(int v : G[u]){\n        if(v == par) continue;\n        dfs(v,u,d + 1);\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n    cin>>n;\n    v.resize(n + 1);\n    fa.resize(n + 1);\n    siz.resize(n + 1);\n    G.resize(n + 1);\n    fill(fa.begin(),fa.end(),0);\n    fill(siz.begin(),siz.end(),1);\n    for(int i = 1; i <= n; i++) {\n        cin>>v[i].first;\n        v[i].second = i;\n    }\n    sort(v.begin() + 1,v.end(),[](auto x,auto y){ return x.first > y.first;});\n    for(int i = 1; i < n; i++){\n        ll d = v[i].first;\n        int sz = siz[v[i].second];\n        ll d_nxt = d - n + 2 * sz;\n        int lo = i + 1, hi = n;\n        int ans_pos = 0;\n        while(lo <= hi){\n            int mid = lo + hi >> 1;\n            if(v[mid].first > d_nxt){\n                lo = mid + 1;\n            }\n            else if(v[mid].first < d_nxt){\n                hi = mid - 1;\n            }\n            else {\n                ans_pos = mid;\n                break;\n            }\n        }\n        if(ans_pos == 0){\n            cout<<-1<<endl;\n            exit(0);\n        }\n        int u = v[i].second;\n        int f = v[ans_pos].second;\n        fa[u] = f;\n        G[f].emplace_back(u);\n        G[u].emplace_back(f);\n        siz[f] += siz[u];\n    }\n    dfs(v[n].second,0,0);\n    cout<<tot<<\" \"<<v[n].first<<endl;\n    if(tot != v[n].first){\n        cout<<-1<<endl;\n        exit(0);\n    }\n    for(int i = 1; i < n; i++){\n        cout<<v[i].second<<\" \"<<fa[v[i].second]<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<set>\n\ntypedef long long ll;\n\nint main() {\n    std::map<ll, int, std::greater<ll> > M;\n    std::ios::sync_with_stdio(0);\n    int n;\n    std::cin >> n;\n    for(int i = 1; i <= n; ++i) {\n        ll x;\n        std::cin >> x;\n        M.insert(std::make_pair(x, i));\n    }\n    static int fa[int(1e5) + 5];\n    static int sz[int(1e5) + 5];\n    std::set<int> Q;\n    for(auto& k : M) if(k.first != (*M.rbegin()).first) {\n        int now = k.second;\n        ++sz[now];\n        Q.insert(now);\n        int f = k.first + 2 * sz[now] - n;\n        if(M.count(f) == 0 || Q.count(M[f]) != 0) {\n            puts(\"-1\");\n            return 0;\n        }\n        fa[now] = M[f];\n        sz[fa[now]] += sz[now];\n    }\n    for(int i = 1; i <= n; ++i) if(fa[i] != 0) {\n        std::cout << i << ' ' << fa[i] << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nint N;\nvector<ll> D;\nint main(){\n\tcin>>N;\n\tD.resize(N);\n\trep(i,N) cin>>D[i];\n\tusing ll_i = pair<ll,int>;\n\tvector<ll_i> dis;\n\tmap<ll,int> mp;\n\trep(i,N){\n\t\tdis.pb(ll_i(D[i],i));\n\t\tmp[D[i]] = i;\n\t}\n\tsort(all(dis),greater<ll_i>());\n\tusing P = pair<int,int>;\n\tvector<P> es;\n\tvector<int> sz(N);\n\tvector<ll> dsum(N);\n\trep(_,N-1){\n\t\tint v = dis[_].sc;\n\t\tsz[v]++;\n\t\tll tar = D[v] - (N-2*sz[v]);\n\t\tif(!mp.count(tar)){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint p = mp[tar];\n\t\tsz[p] += sz[v];\n\t\tdsum[p] += dsum[v] + sz[v];\n\t\tes.pb(P(v,p));\n\t}\n\t{\n\t\tint r = dis[N-1].sc;\n\t\tif(dsum[r] != D[r]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(P p: es){\n\t\tcout<<p.fs+1<<\" \"<<p.sc+1<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N;\n    cin >> N;\n    vector<long long> D(N);\n\n    for (auto &d : D)\n        cin >> d;\n\n    vector<pair<long long, int>> sorted;\n\n    for (int i = 0; i < N; i++)\n        sorted.emplace_back(D[i], i);\n\n    sort(sorted.begin(), sorted.end());\n    vector<int> parent(N, -1);\n    vector<int> subtree_size(N, 1);\n\n    for (int i = N - 1; i > 0; i--) {\n        int current = sorted[i].second;\n        long long goal = sorted[i].first - (N - 2 * subtree_size[current]);\n        int index = lower_bound(sorted.begin(), sorted.end(), make_pair(goal, 0)) - sorted.begin();\n        int who = (index < i && sorted[index].first == goal) ? sorted[index].second : -1;\n\n        if (who < 0) {\n            cout << -1 << '\\n';\n            return 0;\n        }\n\n        subtree_size[who] += subtree_size[current];\n        parent[current] = who;\n    }\n\n    for (int i = N - 1; i > 0; i--) {\n        int current = sorted[i].second;\n        cout << current + 1 << ' ' << parent[current] + 1 << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXn = 1e5 + 10;\ntypedef pair<long long, int> pii;\npii ar[MAXn];\nlong long n, sz[MAXn], root, disroot, d[MAXn], hp3[MAXn];\nvector<int> vec[MAXn];\nvector<pii> ans;\n\nbool cmp(pii p1, pii p2) {\n\treturn p1.first > p2.first;\n}\n\nlong long dfs1(int v, int  par) {\n\tlong long res = 0;\n\tfor (int i = 0; i < vec[v].size(); i++)\n\t\tif (vec[v][i] != par) {\n\t\t\tres += dfs1(vec[v][i], v) + hp3[vec[v][i]];\n\t\t\thp3[v] += hp3[vec[v][i]];\n\t\t}\n\thp3[v]++;\n\treturn res;\n\t\n}\n\nvoid dfs2(int v, int par, long long sth) {\n\tif (sth != d[v]) {\n\t\tcout << -1;\n\t\texit(0);\n\t}\n\tfor (int i = 0; i < vec[v].size(); i++) {\n\t\tif (vec[v][i] != par) {\n\t\t\tdfs2(vec[v][i], v, sth - (hp3[vec[v][i]]) + (hp3[0] - hp3[vec[v][i]]));\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}\nint main() {\n\tcin >> n;\n\tfill_n(sz, MAXn, 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tint di;\n\t\tcin >> di;\n\t\td[i] = di;\n\t\tar[i].first = di;\n\t\tar[i].second = i;\n\t}\n\tsort(ar, ar + n);\n\tfor (int i = n - 1; i > 0; i--) {\n\t\tlong long hp = ar[i].first - n;\n\t\thp += 2LL * sz[i];\n\t\tint hp2 = lower_bound(ar, ar + n, pii(hp, -1)) - ar;\n//\t\tif (ar[hp2].first != hp)\n//\t\t\treturn cout << -1,0;\n\t\tsz[hp2]+= sz[i];\n\t\tvec[ar[hp2].second].push_back(ar[i].second);\n\t\tvec[ar[i].second].push_back(ar[hp2].second);\n\t\tans.push_back(pii(ar[i].second, ar[hp2].second));\n\t}\n//\tdisroot = dfs1(0, -1);\n//\tdfs2(0, -1, disroot);\n\tfor (int i = 0; i < ans.size(); i++)\n\t\tcout << ans[i].first + 1<< ' ' << ans[i].second + 1<< endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=1e5+5;\nusing namespace std;\nstruct Edge{int x,y;}e[N];\nstruct Node{\n\tlong long d;int id;\n\tbool operator <(const Node &b)const{return d<b.d;}\n}d[N];\nint n,cnt;\nlong long size[N];\nlong long dis;\ninline Node Make(long long _d,int _id){Node t;t.d=_d,t.id=_id;return t;}\nint main(){\n\t\n\tregister int i;\n    long long x;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i)\n\t\tscanf(\"%lld\",&x),d[i].d=x,d[i].id=i,size[i]=1;\n\tsort(d+1,d+n+1);\n\tfor(i=n;i>=2;--i){\n\t\tlong long t=d[i].d-n+size[i]*2;\n\t\tint pos=lower_bound(d+1,d+n+1,Make(t,0))-d;\n\t\tif(d[pos].d!=t) return puts(\"-1\"),0;\n\t\te[++cnt]=(Edge){d[i].id,d[pos].id};\n\t\tsize[pos]+=size[i]; //\n\t\tdis+=size[i];\n\t}\n\tif(dis!=d[1].d) puts(\"-1\");\n\telse\n\t\tfor(i=1;i<=cnt;++i)\n\t\t\tprintf(\"%d %d\\n\",e[i].x,e[i].y);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define R register\n#define mp make_pair\n#define ll long long\n#define pii pair<int, int>\n#define pll pair<ll, ll>\nusing namespace std;\nconst int mod = 998244353, N = 110000;\n\nint n, size[N];\nll d[N], g[N];\nvector<int> to[N];\nmap<ll, int> rev;\n\ninline int addMod(int a, int b) {\n\treturn (a += b) >= mod ? a - mod : a;\n}\n\ninline ll quickpow(ll base, ll pw) {\n\tll ret = 1;\n\twhile (pw) {\n\t\tif (pw & 1) ret = ret * base % mod;\n\t\tbase = base * base % mod, pw >>= 1;\n\t}\n\treturn ret;\n}\n\ntemplate <class T>\ninline void read(T &x) {\n\tx = 0;\n\tchar ch = getchar(), w = 0;\n\twhile (!isdigit(ch)) w = (ch == '-'), ch = getchar();\n\twhile (isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();\n\tx = w ? -x : x;\n\treturn;\n}\n\nvoid dfs(int now) {\n\tfor (auto &v : to[now]) {\n\t\tprintf(\"%d %d\\n\", now, v);\n\t\tdfs(v);\n\t}\n\treturn;\n}\n\nint main() {\n\tread(n);\n\tfor (R int i = 1; i <= n; ++i)\n\t\tread(d[i]), rev[d[i]] = i;\n\twhile (rev.size() > 1) {\n\t\tauto it = prev(rev.end());\n\t\tsize[it->second] += 1;\n\t\tll w = 2 * size[it->second] - n + it->first;\n\t\tauto f = rev.find(w);\n\t\tif (f == it || f == rev.end())\n\t\t\treturn printf(\"-1\\n\"), 0;\n\t\tto[f->second].push_back(it->second);\n\t\tsize[f->second] += size[it->second];\n\t\tg[f->second] += g[it->second] + size[it->second];\n\t\trev.erase(it);\n\t}\n\tint rt = rev.begin()->second;\n\tif (g[rt] != d[rt]) return printf(\"-1\\n\"), 0;\n\tdfs(rt);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#include <queue>\n#include <vector>\n#define PB push_back\n#define MP make_pair\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=1e5+10;\nstruct node {\n\tint id; ll d;\n\tnode(int id=0,ll d=0): id(id),d(d) {}\n\tfriend bool operator <(node A,node B) { return A.d<B.d; }\n};\npriority_queue<node> que;\nmap<ll,int> mp;\nint n,sz[N];\nll d[N];\nvector< pair<int,int> > E;\nvector<int> son[N];\nll dfs(int u) {\n\tll tot=0;\n\tfor(int i=0;i<son[u].size();++i) tot+=dfs(son[u][i])+sz[u];\n\treturn tot;\n}\nint main() {\n\trd(n);\n\tfor(int i=1;i<=n;++i) {\n\t\trd(d[i]),mp[d[i]]=i;\n\t\tque.push(node(i,d[i]));\n\t\tsz[i]=1;\n\t}\n\twhile(que.size()>1) {\n\t\tint u=que.top().id; que.pop();\n\t\tmp.erase(d[u]);\n\t\tll t=d[u]-(n-sz[u]*2ll);\n\t\tif(!mp.count(t)) {\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint f=mp[t];\n\t\tE.PB(MP(f,u));\n\t\tson[f].PB(u);\n\t\tsz[f]+=sz[u];\n\t}\n\tint rt=que.top().id;\n\tif(dfs(rt)!=d[rt]) {\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<E.size();++i) printf(\"%d %d\\n\",E[i].first,E[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\n#define int long long\n#define Accepted 0; \n\nconst int Maxv = 100010; \nint d[Maxv], d1[Maxv], u[Maxv], ghostfly233[Maxv], siz[Maxv], cnt, n;  \n\ninline int GldHkkowoSearch(int x) {\n     tmp = std::lower_bound(d + 1, d + n + 1, x) - d;\n\n    if (d[tmp] != x) {\n        puts(\"-1\"); \n        exit(0); \n    }\n\n    return tmp; \n}\n\nsigned main() {\n    scanf(\"%lld\", &n); \n    for (int i = 1; i <= n; i++) {\n        scanf(\"%lld\", &d[i]); \n        d1[i] = d[i]; \n    }\n\n    std::sort(d + 1, d + n + 1); \n    for (int i = 1; i <= n; i++) \n        ghostfly233[GldHkkowoSearch(d1[i])] = i;       \n\n    for (int i = 1; i <= n; i++)\n        siz[i] = 1; \n\n    for (int i = n; i > 1; i--) {\n        u[i] = GldHkkowoSearch(d[i] - n + (siz[i] << 1)); \n        siz[ u[i] ] += siz[i]; \n        cnt += siz[i]; \n    }\n\n    if (cnt != d[1]) {\n        puts(\"-1\"); \n        return 0; \n    }\n\n    for (int i = 2; i <= n; i++)\n        printf(\"%lld %lld\\n\", ghostfly233[i], ghostfly233[ u[i] ]); \n\n    return Accepted;  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define reg register\n#define maxn 200001\ninline int  read() {\n    reg int s = 0, t = 0; reg char ch = getchar();\n    while(ch > '9' || ch < '0') t |= ch == '-', ch = getchar();\n    while(ch >= '0' && ch <= '9') s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();\n    return t ? -s : s;\n}\nusing namespace std;\nmap<int, int> mp, d;\nint D[maxn],a[maxn], b[maxn], cnt, n, sum[maxn];\nsigned main()\n{\n\tn = read();\n\tfor(int i = 1; i <= n; i++) D[i] = read(), mp[D[i]] = i;\n\tsort(D + 1, D + n + 1);\n\tfor(int i = n; i > 1; i--){\n\t\tsum[mp[D[i]]]++; \n\t\tint x = D[i] - n + sum[mp[D[i]]] * 2;\n\t\tif(!mp[x] || x >= D[i]) {printf(\"-1\\n\"); return 0;}\n\t\ta[++cnt] = mp[D[i]], b[cnt] = mp[x]; sum[mp[x]] += sum[mp[D[i]]];\n\t}\n\tif(n == 1 && D[1] != 0) {cout << -1 << endl; return 0;}\n\tfor(int i = 1; i < n; i++)\n\tprintf(\"%lld %lld\\n\", a[i], b[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <time.h>\n\n#include <stdlib.h>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <vector>\n#include <map>\nusing namespace std;\nstruct condition{\n\tint32_t vertex;\n\tint64_t total;\n};\nstruct current{\n\tint32_t parent;\n\tint32_t vertex_num;\n};\nstruct edge{\n\tint32_t v1;\n\tint32_t v2;\n};\nbool operator< (const condition& a,const condition& b){\n\treturn a.total>b.total;\n}\nint main() {\n\n\tint32_t n;\n\tcin>>n;\n\tstd::vector<condition> cd;\n\tvector<edge> ans;\n\tans.reserve(n);\n\tcd.reserve(n);\n\tfor(int i=0;i<n;i++){\n\t\tint64_t temp;\n\t\tcin>>temp;\n\t\tcd.push_back(condition{i+1,temp});\n\t}\n\tbool ans_possible=true;\n\tsort(cd.begin(),cd.end());\n\tmap<int64_t,vector<current> > flow;\n\tfor(auto i=cd.begin();i!=cd.end();i++){\n\t\tbool islast = (i==cd.end()-1);\n\t\tint32_t sum_vertex=0;\n\n\t\tif(flow.count(i->total)){\n\t\t\tvector<current>& t=flow.at(i->total);\n\t\t\tint64_t total_cost=0;\n\t\t\tfor(auto k=t.begin();k!=t.end();k++){\n\t\t\t\tans.push_back(edge{k->parent,i->vertex});\n\t\t\t\tsum_vertex+=(k->vertex_num);\n\t\t\t\ttotal_cost+=((k->vertex_num)*(k->vertex_num+1))/2;\n\t\t\t}\n\t\t\tans_possible=(total_cost==i->total);\n\n\t\t\tflow.erase(i->total);\n\t\t}else{\n\t\t\tans_possible=false;\n\t\t}\n\n\t\tsum_vertex++;\n\n\t\tint32_t parent_value=i->total-(n-2*sum_vertex);\n\t\tif(!islast&&parent_value>=i->total){\n\t\t\tans_possible=false;\n\t\t\tbreak;\n\t\t}\n\t\tif(flow.count(parent_value)){\n\t\t\tflow.at(parent_value).push_back(current{i->vertex,sum_vertex});\n\t\t}else{\n\t\t\tvector<current> temp2;\n\t\t\ttemp2.push_back(current{i->vertex,sum_vertex});\n\t\t\tflow.emplace(parent_value,temp2);\n\t\t}\n\n\t}\n\tif(flow.size()==1&&ans_possible&&ans.size()==(n-1)){\n\t\tfor(auto i=ans.begin();i!=ans.end();i++){\n\t\t\tcout<<i->v1<<\" \"<<i->v2<<endl;\n\t\t}\n\t}else{\n\t\tcout<<-1<<endl;\n\t}\n\n\n\n\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> bool chmin(T& a,const T& b) {\n  if(a>b) {\n    a=b;\n    return true;\n  }\n  return false;\n}\ntemplate<class T> bool chmax(T& a,const T& b) {\n  if(a<b){\n    a=b;\n    return true;\n  }\n  return false;\n}\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\n//const int INF=5e8;\n\nint n;\nlint ar[100005];\nvoid ng(){\n  puts(\"-1\");\n  exit(0);\n}\nint main(){\n  cin>>n;\n  set<pair<lint,pi> > S;\n  REP(i,n){\n    scanf(\"%lld\\n\",&ar[i]);\n    S.insert({ar[i],{i,1}});\n  }\n  vector<pi> es;\n  while(S.size()>1){\n    pair<lint,pi> tmp=*(--S.end());\n    S.erase(--S.end());\n    int v=tmp.sc.fr,wei=tmp.sc.sc;\n    lint co=tmp.fr;\n\n    lint want=co-(n-2*wei);\n    auto it=S.lower_bound(mp(want,mp(0,0)));\n    if(it!=S.end() && it->fr==want){\n      int v2=it->sc.fr,wei2=it->sc.sc;\n      S.erase(it);\n      es.pb({v,v2});\n      S.insert({want,{v2,wei+wei2}});\n    }else{\n      ng();\n    }\n  }\n  for(auto e:es) printf(\"%d %d\\n\",e.fr+1,e.sc+1);\n\n\n\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN=3e5+7;\n\nll from[MAXN],to[MAXN];\n\nmap<ll,ll> Map;\n\nll n;\nll a[MAXN],b[MAXN],siz[MAXN];\n\nbool cmp(const ll &A,const ll &B){return a[A]>a[B];}\nbool cmp2(const ll &A,const ll &B){return A>B;}\n\nint main() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) {\n\t\tcin>>a[i];\n\t\tb[i]=i;\n\t\tMap[a[i]]=i;\n\t\tsiz[i]=1;\n\t}\n\tsort(b+1,b+1+n,cmp);\n\tsort(a+1,a+1+n,cmp2);\n\tfor(ll i=1,i2;i<n;i++) {\n\t\ti2=Map[a[i]-(n-2*siz[b[i]])];\n\t\tif(i2!=0&&a[i]-(n-2*siz[b[i]])<=a[i]) {\n\t\t\tsiz[i2]+=siz[b[i]];\n\t\t\tfrom[i]=i2;\n\t\t\tto[i]=b[i];\n\t\t}\n\t\telse {\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++) {\n\t\tcout<<from[i]<<\" \"<<to[i]<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#include <queue>\n#include <vector>\n#define PB push_back\n#define MP make_pair\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=1e5+10;\nstruct node {\n\tint id; ll d;\n\tnode(int id=0,ll d=0): id(id),d(d) {}\n\tfriend bool operator <(node A,node B) { return A.d<B.d; }\n};\npriority_queue<node> que;\nmap<ll,int> mp;\nint n,sz[N];\nll d[N];\nvector< pair<int,int> > E;\nint main() {\n\trd(n);\n\tfor(int i=1;i<=n;++i) {\n\t\trd(d[i]),mp[d[i]]=i;\n\t\tque.push(node(i,d[i]));\n\t\tsz[i]=1;\n\t}\n\twhile(que.size()>1) {\n\t\tint u=que.top().id; que.pop();\n\t\tmp.erase(d[u]);\n\t\tll t=d[u]-(n-sz[u]*2ll);\n\t\tif(!mp.count(t)) {\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint f=mp[t];\n\t\tE.PB(MP(f,u));\n\t\tsz[f]+=sz[u];\n\t}\n\tfor(int i=0;i<E.size();++i) printf(\"%d %d\\n\",E[i].first,E[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#include <cmath>\n#include <complex>\n// #include \"utiltime.hpp\"\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef complex<double> cdouble;\n\nconst int INFL = (int)1e9;\nconst ll INFLL = (ll)1e18;\nconst double INFD = numeric_limits<double>::infinity();\nconst double PI = 3.14159265358979323846;\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loopll(i, n) for(ll i = 0; i < (ll)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopll1(i, n) for(ll i = 1; i <= (ll)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = (ll)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define Looprll1(i, n) for(ll i = (ll)n; i >= 1; i--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(i, vector.size()) { cout << vector[i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(i, matrix.size()) { Loop(j, matrix[i].size()) { cout << matrix[i][j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define readfile(filename) ifstream in(filename); cin.rdbuf(in.rdbuf());\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\nbool nearlyeq(double x, double y) { return abs(x - y) < 1e6; }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(double x) { ll m = (ll)sqrt(x); return m + (m * m <= (ll)(x) ? 0 : -1); }\nll ceilsqrt(double x) { ll m = (ll)sqrt(x); return m + ((ll)x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\n\n/*******************************************************/\n\nvoid failed() {\n\tcout << -1 << endl;\n\texit(0);\n}\n\nint main() {\n\tquickio();\n\tint n; cin >> n;\n\tvector<Pll> a(n);\n\tLoop(i, n) {\n\t\tcin >> a[i].first;\n\t\ta[i].second = i;\n\t}\n\tsort(a.begin(), a.end());\n\tvll subtree_cnt(n, 0);\n\tvector<Pll> ans;\n\tLoopr1(i, n - 1) {\n\t\tll target_val = a[i].first + subtree_cnt[i] * 2 - n + 2;\n\t\tauto itr = lower_bound(a.begin(), a.end(), Pll({ target_val, 0 }));\n\t\tif (itr == a.end()) failed();\n\t\tif (itr - a.begin() == a.size() - 1) failed();\n\t\tif (itr->first != target_val) failed();\n\t\tsubtree_cnt[itr - a.begin()] += subtree_cnt[i] + 1;\n\t\tans.push_back({ a[i].second + 1, a[itr - a.begin()].second + 1 });\n\t\ta.pop_back();\n\t\tsubtree_cnt.pop_back();\n\t}\n\tLoop(i, ans.size()) {\n\t\tcout << ans[i].first << \" \" << ans[i].second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\nstruct Val{\n\tlong long d;\n\tint u;\n}p[100010];\nbool cmp(Val a,Val b)\n{\n\treturn a.d>b.d;\n}\nint find(int l,int r,long long t)\n{\n\twhile(l+1<r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(p[mid].d<=t)r=mid;\n\t\telse l=mid;\n\t}\n\tif(p[r].d!=t)return -1;\n\treturn r;\n}\nint u[100010],v[100010];\nint siz[100010];\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&p[i].d);\n\t\tp[i].u=i;\n\t}\n\tsort(p+1,p+n+1,cmp);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tsiz[i]++;\n\t\tu[i]=p[i].u;\n\t\tint pos=find(i,n,p[i].d+siz[i]-(n-siz[i]));\n\t\tif(pos==-1){\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tv[i]=p[pos].u;\n\t\tsiz[pos]+=siz[i];\n\t}\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d %d\\n\",u[i],v[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint N;\nlong long D[100010];\nint cnt[100010];\nint ansu[100010], ansv[100010];\nint idx[100010];\n\nint bsrch(int ll, int rr, long long vv)\n{\n\tint l=ll, r=rr;\n\tint m;\n\twhile(l<r){\n\t\tm = (l+r)/2;\n\t\tif(D[idx[m]] >= vv){\n\t\t\tr = m;\n\t\t}\n\t\telse\n\t\t\tl = m+1;\n\t}\n\treturn l;\n}\n\nbool cmp(int aa, int bb)\n{\n\treturn D[aa] < D[bb];\n}\n\nint solve()\n{\n\tint i, j=0;\n\tint ii;\n\tfor(i=0; i<N; i++)\n\t\tidx[i] = i;\n\tsort(idx, idx+N, cmp);\n\tfor(ii=N-1; ii>0; ii--){\n\t\ti = idx[ii];\n\t\tint p = bsrch(0, ii, D[i]-(N-2-cnt[i]*2) );\n\t\tif(p>=ii || D[idx[p]]!=D[i]-(N-2-cnt[i]*2) )\n\t\t\treturn 0;\n\t\tcnt[idx[p]] += cnt[i]+1;\n\t\tansu[j] = idx[p];\n\t\tansv[j] = i;\n\t\tj ++;\n\t}\n\tfor(i=0; i<N-1; i++){\n\t\tprintf(\"%d %d\\n\", ansu[i]+1, ansv[i]+1);\n\t}\n\treturn 1;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\tint i;\n\tscanf(\"%d\", &N);\n\tfor(i=0; i<N; i++)\n\t\tscanf(\"%lld\", &D[i]);\n\tif(solve() == 0)\n\t\tprintf(\"-1\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<bitset>\n#include<math.h>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int N=100000+100;\nconst db pi=acos(-1.0);\n#define lowbit(x) ((x)&(-x))\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u],v=sq[i].to;i;i=sq[i].nxt,v=sq[i].to)\n#define fir first\n#define sec second\n#define mkp make_pair\n#define pb push_back\n#define maxd 998244353\n#define eps 1e-8\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\ninline ll readll()\n{\n    ll x=0;int f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nstruct node{int to,nxt;}sq[N<<1];\nint all=0,head[N];\nll dis[N];\n\nvoid addedge(int u,int v)\n{\n    all++;sq[all].to=v;sq[all].nxt=head[u];head[u]=all;\n}\n\nvoid dfs(int u,int fu)\n{\n    go(u,i) \n        if (v!=fu) \n        {\n            dis[v]=dis[u]+1;\n            dfs(v,u);\n        }\n}\n\nstruct pnode{int id;ll dis;}p[N];\nbool cmp(pnode p,pnode q) {return p.dis>q.dis;}\nint n,siz[N];\nmap<ll,int> mp;\nvector<pii> ans;\n\nint main()\n{\n    n=read();\n    rep(i,1,n)\n    {\n        p[i].dis=readll();\n        p[i].id=i;siz[i]=1;\n        mp[p[i].dis]=i;\n    }\n    sort(p+1,p+1+n,cmp);\n    rep(i,1,n-1)\n    {\n        int u=p[i].id;\n        int delta=2*siz[u]-n;\n        if (delta>=0) {puts(\"-1\");return 0;}\n        ll nxt=p[i].dis+delta;\n        if (!mp[nxt]) {puts(\"-1\");return 0;}\n        int v=mp[nxt];\n        siz[v]+=siz[u];\n        addedge(u,v);addedge(v,u);\n        ans.pb(mkp(u,v));\n    }\n    //cout << \"from \" << p[1].id << endl;\n    dfs(p[1].id,0);\n    ll sum=0;\n    //rep(i,1,n) cout << dis[i] << \" \";cout << endl;\n    rep(i,1,n) sum+=dis[i];\n    if (sum!=p[1].dis) {puts(\"-1\");return 0;}\n    rep(i,0,n-2) printf(\"%d %d\\n\",ans[i].fir,ans[i].sec);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<algorithm>\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\ntypedef long long ll;\nconst int N=200200;\nint n,u,o[N],sz[N],fa[N];\nll t,a[N];\nmap<ll,int>h;\nbool cmp(int x,int y){return a[x]>a[y];}\nint main(){\n\tscanf(\"%d\",&n);\n\tFOR(i,1,n) scanf(\"%lld\",&a[i]),h[a[i]]=o[i]=i,sz[i]=1;\n\tsort(o+1,o+n+1,cmp);\n\tFOR(i,1,n-1){\n\t\tu=o[i];t=a[u]+2*sz[u]-n;\n\t\tif(!h.count(t) || h[t]==u || fa[h[t]]) return puts(\"-1\"),0;\n\t\tsz[fa[u]=h[t]]+=sz[u];\n\t}\n\tFOR(i,1,n)if(fa[i]) cout<<i<<' '<<fa[i]<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\ntypedef long long ll;\nusing namespace std;\n\npair<ll, int> p[100010]={};\nint nd[100010];\nvector<vector<int>> desc;\nll dep[100010]={};\n\nll dfs(int key){\n\tll res=dep[key];\n\tfor(int i=0; i<desc[key].size(); ++i){\n\t\tdep[desc[key][i]]=dep[key]+1;\n\t\tres += dfs(desc[key][i]);\n\t}\n\treturn res;\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\tfor(int i=1; i<=N; ++i){\n\t\tll D;\n\t\tcin >> D;\n\t\tp[i-1]=make_pair(D, i);\n\t}\n\tsort(p, p+N, greater<>());\n\tdesc.resize(N+1);\n\tfor(int i=1; i<=N; ++i) nd[i]=1;\n\tfor(int i=0; i<N-1; ++i){\n\t\tint ng=i, ok=N-1;\n\t\tll key=p[i].first-(N-nd[p[i].second]*2);\n\t\twhile(ng+1<ok){\n\t\t\tint mid=(ng+ok)/2;\n\t\t\tif(p[mid].first<=key) ok=mid;\n\t\t\telse ng=mid;\n\t\t}\n\t\tif(p[ok].first!=key){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tdesc[p[ok].second].emplace_back(p[i].second);\n\t\tnd[p[ok].second] += nd[p[i].second];\n\t}\n\tif(dfs(p[N-1].second)!=p[N-1].first){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tfor(int i=1; i<=N; ++i){\n\t\tfor(int j=0; j<desc[i].size(); ++j){\n\t\t\tcout << i << ' ' << desc[i][j] << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\nusing ll = long long;\n\nint main() {\n  int n;\n  cin >> n;\n  vector<ll> d(n);\n  vector<int> parent(n, -1);\n  vector<int> p(n);\n  vector<ll> size(n, 1);\n  map<ll, int> mp;\n  for (int i = 0; i < n; i++) {\n    cin >> d[i];\n    p[i] = i;\n    mp[d[i]] = i;\n  }\n  sort(p.begin(), p.end(), [&](int i, int j) { return d[i] > d[j]; });\n  p.pop_back();\n  for (int i : p) {\n    ll tmp = d[i] - n + 2 * size[i];\n    if (size[i] <= n / 2 && mp.count(tmp)) {\n      parent[i] = mp[tmp];\n      size[parent[i]] += size[i];\n    } else {\n      cout << -1 << '\\n';\n      return 0;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (parent[i] != -1) {\n      cout << i+1 << ' ' << parent[i]+1 << '\\n';\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <map>\nusing namespace std;\n#define fors(i,a,b) for(int i=(a);i<=(b);++i)\n#define ford(i,a,b) for(int i=(a);i>=(b);--i)\n#define min(x,y) ((x) < (y) ? (x) : (y))\n#define max(x,y) ((x) < (y) ? (y) : (x))\n#define swap(x,y) ((x)^=(y),(y)^=(x),(x)^=(y))\nconst int maxn=1e6+7;\ntypedef long long LL;\nconst int inf=1<<25;\nint read(){\n    int s=0,f=1;\n    char c=getchar();\n    while(c<'0' || c>'9') {if(c=='-') f=-1; c=getchar();}\n    while(c>='0' && c<='9') {s=s*10+c-48;c=getchar();}\n    return s*f;\n}\nvoid write(int x){\n    if(x<0) {putchar('-');x=-x;}\n    if(x>9) write(x/10);\n    putchar(x%10+48);\n}\n\nint abs(int x){\n    return x < 0 ? -x : x; \n}\nint tree[maxn];\nLL dis[maxn];\nint size[maxn],fa[maxn];\nint cmp(int x,int y){\n    return dis[x] < dis[y];\n}\n\n\nmap<LL,int> maps;\n\nint n;\nint main(int argc, char const *argv[])\n{\n    n=read();\n    fors(i,1,n){\n        dis[i]=read();\n        size[i]=1;\n        maps[dis[i]]=i;\n        tree[i]=i;\n    }\n    sort(tree+1,tree+1+n,cmp);\n\n    ford(i,n,2){\n        fa[tree[i]] = maps[dis[tree[i]] + 2*size[tree[i]] - n];\n        if(!fa[tree[i]]){\n            puts(\"-1\");\n            return 0;\n        }\n        size[fa[tree[i]]]+=size[tree[i]];\n    }\n    fors(i,2,n) \n        dis[tree[1]] -= size[tree[i]];\n\n    if(dis[tree[1]]){\n        puts(\"-1\");\n        return 0;\n    }\n    fors(i,2,n)\n        write(fa[tree[i]]),putchar(' '),write(tree[i]),putchar(10);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ※※※ 解答不能 ※※※\n// 解き直し.\n// tourist氏.\n// https://atcoder.jp/contests/arc103/submissions/3296203\n#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\nint main(){\n\n    int N;\n    scanf(\"%d\", &N);\n    vector<LL> d(N);\n    vector<int> weight(N, 1);\n    map<LL, int> mp;\n    for(int i = 0; i < N; i++){\n        scanf(\"%lld\", &d[i]);\n        mp[d[i]] = i;\n    }\n    \n    vector<pair<int, int>> res;\n    for(int itt = 0; itt < N - 1; itt++){\n        auto it = mp.rbegin();\n        int i = it->second;\n        LL want = d[i] - (N - weight[i]) + weight[i];\n        if(mp.find(want) == mp.end() || mp[want] == i){\n            printf(\"%d\\n\", -1);\n            return 0;\n        }\n        int j = mp[want];\n        res.emplace_back(i, j);\n        weight[j] += weight[i];\n        mp.erase(--mp.end());\n    }\n    \n    vector<LL> real_dist(N, -1);\n    real_dist[0] = 0;\n    vector<vector<int>> g(N);\n    for(auto &p : res){\n        g[p.first].push_back(p.second);\n        g[p.second].push_back(p.first);\n    }\n    \n    vector<int> que(1, 0);\n    for(int b = 0; b < (int)que.size(); b++){\n        for(int j : g[que[b]]){\n            if(real_dist[j] == -1){\n                que.push_back(j);\n                real_dist[j] = real_dist[que[b]] + 1;\n            }\n        }\n    }\n    if(accumulate(real_dist.begin(), real_dist.end(), 0LL) != d[0]){\n        printf(\"%d\\n\", -1);\n        return 0;\n    }\n    \n    for(auto &p : res) printf(\"%d %d\\n\", p.first + 1, p.second + 1);\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC optimize(2)\n// #pragma G++ optimize(2)\n// #pragma comment(linker,\"/STACK:102400000,102400000\")\n\n// #include <bits/stdc++.h>\n#include <map>\n#include <set>\n#include <list>\n#include <array>\n#include <cfenv>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <mutex>\n#include <queue>\n#include <ratio>\n#include <regex>\n#include <stack>\n#include <tuple>\n#include <atomic>\n#include <bitset>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <chrono>\n#include <cstdio>\n#include <cwchar>\n#include <future>\n#include <limits>\n#include <locale>\n#include <memory>\n#include <random>\n#include <string>\n#include <thread>\n#include <vector>\n#include <cassert>\n#include <climits>\n#include <clocale>\n#include <complex>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <ctgmath>\n#include <cwctype>\n#include <fstream>\n#include <iomanip>\n#include <numeric>\n#include <sstream>\n#include <ccomplex>\n#include <cstdbool>\n#include <iostream>\n#include <typeinfo>\n#include <valarray>\n#include <algorithm>\n#include <cinttypes>\n#include <cstdalign>\n#include <stdexcept>\n#include <typeindex>\n#include <functional>\n#include <forward_list>\n#include <system_error>\n#include <unordered_map>\n#include <unordered_set>\n#include <scoped_allocator>\n#include <condition_variable>\n// #include <conio.h>\n// #include <windows.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef float fl;\ntypedef double ld;\ntypedef long double LD;\ntypedef pair<int,int> pii;\n#if (WIN32) || (WIN64) || (__WIN32) || (__WIN64) || (_WIN32) || (_WIN64) || (WINDOWS)\n#define lld \"%I64d\"\n#define llu \"%I64u\"\n#else\n#define lld \"%lld\"\n#define llu \"%llu\"\n#endif\n#define ui(n) ((unsigned int)(n))\n#define LL(n) ((long long)(n))\n#define ull(n) ((unsigned long long)(n))\n#define fl(n) ((float)(n))\n#define ld(n) ((double)(n))\n#define LD(n) ((long double)(n))\n#define char(n) ((char)(n))\n#define Bool(n) ((bool)(n))\n#define fixpoint(n) fixed<<setprecision(n)\n\nconst int INF=1061109567;\nconst int NINF=-1044266559;\nconst LL LINF=4557430888798830399;\nconst ld eps=1e-15;\n#define MOD (1000000007)\n#define PI (3.1415926535897932384626433832795028841971)\n\n/*\n#define MB_LEN_MAX 5\n#define SHRT_MIN (-32768)\n#define SHRT_MAX 32767\n#define USHRT_MAX 0xffffU\n#define INT_MIN (-2147483647 - 1)\n#define INT_MAX 2147483647\n#define UINT_MAX 0xffffffffU\n#define LONG_MIN (-2147483647L - 1)\n#define LONG_MAX 2147483647L\n#define ULONG_MAX 0xffffffffUL\n#define LLONG_MAX 9223372036854775807ll\n#define LLONG_MIN (-9223372036854775807ll - 1)\n#define ULLONG_MAX 0xffffffffffffffffull\n*/\n\n#define MP make_pair\n#define MT make_tuple\n#define All(a) (a).begin(),(a).end()\n#define pall(a) (a).rbegin(),(a).rend()\n#define log2(x) log(x)/log(2)\n#define Log(x,y) log(x)/log(y)\n#define sz(a) ((int)(a).size())\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define rep1(i,n) for(int i=1;i<=((int)(n));i++)\n#define repa(i,a,n) for(int i=((int)(a));i<((int)(n));i++)\n#define repa1(i,a,n) for(int i=((int)(a));i<=((int)(n));i++)\n#define repd(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define repd1(i,n) for(int i=((int)(n));i>=1;i--)\n#define repda(i,n,a) for(int i=((int)(n));i>((int)(a));i--)\n#define repda1(i,n,a) for(int i=((int)(n));i>=((int)(a));i--)\n#define FOR(i,a,n,step) for(int i=((int)(a));i<((int)(n));i+=((int)(step)))\n#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)\n#define repV(i,v) for(auto i:v)\n#define repE(i,v) for(auto &i:v)\n#define MS(x,y) memset(x,y,sizeof(x))\n#define MC(x) MS(x,0)\n#define MINF(x) MS(x,63)\n#define MCP(x,y) memcpy(x,y,sizeof(y))\n#define sqr(x) ((x)*(x))\n#define UN(v) sort(All(v)),v.erase(unique(All(v)),v.end())\n#define filein(x) freopen(x,\"r\",stdin)\n#define fileout(x) freopen(x,\"w\",stdout)\n#define fileio(x)\\\n\tfreopen(x\".in\",\"r\",stdin);\\\n\tfreopen(x\".out\",\"w\",stdout)\n#define filein2(filename,name) ifstream name(filename,ios::in)\n#define fileout2(filename,name) ofstream name(filename,ios::out)\n#define file(filename,name) fstream name(filename,ios::in|ios::out)\n#define Pause system(\"pause\")\n#define Cls system(\"cls\")\n#define fs first\n#define sc second\n#define PC(x) putchar(x)\n#define GC(x) x=getchar()\n#define Endl PC('\\n')\n#define SF scanf\n#define PF printf\n\ninline int Read()\n{\n    int X=0,w=0;char ch=0;while(!isdigit(ch)){w|=ch=='-';ch=getchar();}while(isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();\n\treturn w?-X:X;\n}\ninline void Write(int x){if(x<0)putchar('-'),x=-x;if(x>9)Write(x/10);putchar(x%10+'0');}\n\ninline LL powmod(LL a,LL b){LL RES=1;a%=MOD;assert(b>=0);for(;b;b>>=1){if(b&1)RES=RES*a%MOD;a=a*a%MOD;}return RES%MOD;}\ninline LL gcdll(LL a,LL b){return b?gcdll(b,a%b):a;}\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={1,0,-1,0,-1,-1,1,1};\n/************************************************************Begin************************************************************/\nconst int maxn=100010;\n\nint n;\nLL a[maxn];\n\nint main()\n{\n\tSF(\"%d\",&n);\n\tif(n%2==0) PF(\"-1\");\n\n\treturn 0;\n}\n/*************************************************************End**************************************************************/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define int long long\nconst int N=100005;\nstruct D{int w,x,s;}d[N];int n,he[N],to[N],nx[N];\nbool cmp(D x,D y){return x.x>y.x;}\ninline void wk(int w,int x,int y)\n{to[w]=y,nx[w]=he[x],he[x]=w;}\nint dfs(int x,int y)\n{\n\tint z=y;\n\tfor(int i=he[x];i;i=nx[i])\n\t\tz+=dfs(to[i],y+1);\n\treturn z;\n}\nsigned main()\n{\n\tscanf(\"%lld\",&n);\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(\"%lld\",&d[i].x),d[i].w=i,d[i].s=1;\n\tstd::sort(d+1,d+n+1,cmp);\n\tfor(int i=1,x,l,r,I;i<n;++i)\n\t{\n\t\tfor(x=0,l=i+1,r=n;l<=r;)\n\t\t\tI=l+r>>1,d[I].x>=d[i].x+2*d[i].s-n?(x=I,l=I+1):(r=I-1);\n\t\tif(!x||d[x].x!=d[i].x+2*d[i].s-n)\n\t\t\treturn 0&printf(\"-1\");\n\t\td[x].s+=d[i].s,wk(i,d[x].w,d[i].w);\n\t}\n\tif(dfs(d[n].w,0)!=d[n].x)return 0&printf(\"-1\");\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=he[i];j;j=nx[j])\n\t\t\tprintf(\"%lld %lld\\n\",i,to[j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Distance Sums\n\nusing P = pair<int64_t, int64_t>;\n\nint main() {\n  int64_t N;\n  cin >> N;\n  map<int64_t, P> mp;\n  for (size_t i = 1; i <= N; i++) {\n    int64_t x;\n    cin >> x;\n    mp[x] = make_pair(i, 1);  // 頂点番号と木のサイズ\n  }\n  if (N == 2) {\n    cout << -1 << endl;\n    return 0;\n  }\n  bool flag = true;  // 条件をみたす木が存在しているかどうか\n  vector<P> graph;\n  auto enditr = mp.rend();\n  enditr--;\n  for (auto itr = mp.rbegin(); itr != enditr; ++itr) {\n    auto key = itr->first;\n    auto value = itr->second;\n    auto vertex = value.first;\n    auto size = value.second;\n    auto child_key = key - N + 2 * size;\n    if (child_key >= key) {\n      flag = false;\n      break;\n    }\n    auto tmpitr = mp.find(child_key);\n    if (tmpitr != mp.end()) {\n      auto tmp = tmpitr->second;\n      mp.at(child_key) = make_pair(tmp.first, tmp.second + size);\n      graph.push_back(make_pair(vertex, tmp.first));\n    } else {\n      flag = false;\n      break;\n    }\n  }\n  if (flag) {\n    for (const auto& e : graph) {\n      cout << e.first << ' ' << e.second << endl;\n    }\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main()\n{\n\tint N;\n\tcin >> N;\n\tvector<ll> D(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> D[i];\n\t}\n\tif (N % 2 == 0) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tcout << \"impossible\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#define ll long long\n#define inf 0x3f3f3f3f\n#define maxn 200010\ninline ll read()\n{\n\tll x=0; char c=getchar(),f=1;\n\tfor(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n\tfor(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\ninline void write(ll x)\n{\n\tstatic char buf[20];\n\tint len=0;\n\tif(x<0)putchar('-'),x=-x;\n\tfor(;x;x/=10)buf[len++]=x%10+'0';\n\tif(!len)putchar('0');\n\telse while(len)putchar(buf[--len]);\n}\ninline void writesp(ll x){write(x); putchar(' ');}\ninline void writeln(ll x){write(x); putchar('\\n');}\nll d[maxn];\nstd::map<ll,int>mp;\nint id[maxn],fa[maxn],size[maxn];\nint anc[maxn];\nint n;\nbool cmp(int x,int y){return d[x]>d[y];}\nint find(int x){return anc[x]==x?x:anc[x]=find(anc[x]);}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)\n\t\td[i]=read(),mp[d[i]]=i;\n\tfor(int i=1;i<=n;i++)\n\t\tid[i]=i,size[i]=1;\n\tstd::sort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<n;i++){\n\t\tfa[id[i]]=mp[d[id[i]]-(n-2*size[id[i]])];\n\t\t// printf(\"%d %d %d\\n\",id[i],size[id[i]],fa[id[i]]);\n\t\tif(!fa[id[i]]){\n\t\t\tputs(\"-1\"); return 0;\n\t\t}\n\t\tsize[fa[id[i]]]+=size[id[i]];\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tanc[i]=i;\n\tfor(int i=1;i<=n;i++)\n\t\tif(fa[i]){\n\t\t\tif(find(fa[i])==find(i)){\n\t\t\t\tputs(\"-1\"); return 0;\n\t\t\t}\n\t\t\tanc[find(i)]=find(fa[i]);\n\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(fa[i])writesp(fa[i]),writeln(i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\nconst int inf = (1 << 30) - 1;\nconst int64 infll = (1LL << 61) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\nint main() {\n  int N;\n  cin >> N;\n  set< pair< int64, int > > que;\n  for(int i = 0; i < N; i++) {\n    int64 d;\n    cin >> d;\n    que.emplace(d, i);\n  }\n\n  vector< int > par(N, -1), size(N, 1);\n  while(que.size() >= 2) {\n    auto p = *prev(que.end());\n    que.erase(p);\n    const int other = N - size[p.second];\n    int64 latte = p.first + size[p.second] - other;\n\n    auto it = que.lower_bound({latte, -1});\n    if(it == que.end() || it->first != latte) {\n      cout << -1 << endl;\n      return 0;\n    }\n    size[it->second] += size[p.second];\n    par[p.second] = it->second;\n  }\n  for(int i = 0; i < N; i++) {\n    if(~par[i]) cout << par[i] + 1 << \" \" << i + 1 << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,n) for (int i=1;i<=n;i++)\n#define REP(i,a,b) for (int i=a;i<=b;i++)\n \n#define pb push_back\n#define fi first\n#define se second\n#define pi pair<int,int>\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n \ntypedef long long ll;\n\nconst int inf=0x3f3f3f3f;\nconst ll linf=1e18;\nconst int N=200000+10;\nconst double eps=1e-5;\nconst int mo=1e9+7;\n\nint n;\nvector<int> v[N];\nint sz[N];\nstruct node {\n\tint id,v;\n} a[N];\nbool used[N];\nbool cmp(node x,node y) {\n\treturn x.v<y.v;\n}\nint find(int x) {\n\tint l=1,r=n;\n\tint mid;\n\twhile (l<=r) {\n\t\tmid=(l+r)>>1;\n\t\tif (a[mid].v<x) {\n\t\t\tl=mid+1;\n\t\t} else if (a[mid].v>x) {\n\t\t\tr=mid-1;\n\t\t} else return a[mid].id;\n\t}\n\treturn 0;\n}\nint main() {\n \n    std::ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tint x,y;\n\tFOR(i,n) {\n\t\tscanf(\"%d\",&a[i].v);\n\t\ta[i].id=i;\n\t}\n\tsort(a+1,a+1+n,cmp);\n\tFOR(i,n) sz[i]=1;\n\tint t;\n\tfor (int i=n;i>=2;i--) {\n\t\tx=a[i].id;\n\t\tt=a[i].v-n+2*sz[x];\n\t\t//cout<<x<<\" \"<<t<<endl;\n\t\ty=find(t);\n\t\tif (x==y||used[y]||y==0) {\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tv[x].pb(y);\n\t\tv[y].pb(x);\n\t\tsz[y]+=sz[x];\n\t\tused[x]=1;\n\t\t// used[x]=1表示x的所有儿子都已经找到了，之后如果还有点想插入x当儿子就是无解的 \n\t}\n\tFOR(i,n) {\n\t\tfor (int j=0;j<(int)v[i].size();j++) {\n\t\t\ty=v[i][j];\n\t\t\tif (i<y) {\n\t\t\t\tprintf(\"%d %d\\n\",i,y);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nusing ll = int64_t;\n\nint main() {\n  int n;\n  cin>>n;\n  map<ll, pair<int, int>> m;\n  REP(i,n) {\n    ll d;\n    cin>>d;\n    m[d] = make_pair(1, i+1);\n  }\n  bool ok = true;\n  vector<pair<int, int>> edges;\n  while (m.size() > 1) {\n    const auto itr = m.rbegin();\n    ll d = itr->first;\n    int k, i;\n    tie(k, i) = itr->second;\n    m.erase(prev(m.end()));\n    ll diff = n-2*k;\n    if (m.count(d - diff) == 0) {\n      ok = false;\n      break;\n    }\n    int l, j;\n    tie(l, j) = m[d-diff];\n    edges.emplace_back(i, j);\n    m[d-diff] = make_pair(l+k, j);\n  }\n  if (ok) {\n    for (auto p : edges) {\n      int u, v;\n      tie(u, v) = p;\n      cout << u << ' ' << v << endl;\n    }\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#define MN 100005\n#define ll long long\nusing namespace std;\ninline ll in(){\n    ll x=0;bool f=0;char c;\n    for (;(c=getchar())<'0'||c>'9';f=c=='-');\n    for (x=c-'0';(c=getchar())>='0'&&c<='9';x=(x<<3)+(x<<1)+c-'0');\n    return f?-x:x;\n}\nstruct st{\n\tll v;\n\tint id;\n}a[MN];\nstruct edge{\n\tint to,nxt;\n}e[MN<<1];\nmap <ll,int> mp;\nint h[MN],fa[MN],dep[MN],siz[MN];\nint n,cnt;\nll sum;\ninline bool cmp(st x,st y){return x.v>y.v;}\ninline void ins(int x,int y){\n\te[++cnt].to=y;e[cnt].nxt=h[x];h[x]=cnt;\n}\ninline void dfs(int u){\n\tsum+=1ll*dep[u];\n\tfor (int i=h[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif (v==fa[u]) continue;\n\t\tdep[v]=dep[u]+1;\n\t\tfa[v]=u;dfs(v);\n\t}\n}\nint main()\n{\n\tn=in();\n\tfor (int i=1;i<=n;++i){\n\t\ta[i].v=in();a[i].id=i;\n\t\tmp[a[i].v]=i;siz[i]=1;\n\t}sort(a+1,a+n+1,cmp);\n\tfor (int i=1;i<n;++i){\n\t\tll d=a[i].v-n+(siz[a[i].id]<<1);\n\t\tif (d>=a[i].v||(!mp[d])) {printf(\"-1\");return 0;}\n\t\tins(a[i].id,mp[d]);ins(mp[d],a[i].id);\n\t\tsiz[mp[d]]+=siz[a[i].id];\n\t}dfs(a[n].id);\n\tif (sum!=a[n].v) {printf(\"-1\");return 0;}\n\tfor (int i=1;i<=n;++i)\n\tif (fa[i]) printf(\"%d %d\\n\",fa[i],i);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iomanip>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<map>\n#include<set>\n#include<vector>\n#include<queue>\n#include<bitset>\n#include<stack>\n#include<cassert>\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n#define mem(x,y) memset(x,y,sizeof x)\n#define sqr(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ll,int> pli;\nconst int INF=2e9;\nconst db eps=1e-12;\ntemplate<typename T>\ninline void read(T &x) {\n\tx=0; int f=1; char ch=getchar();\n\twhile( (ch<'0' || ch>'9') && ch!='-') ch=getchar(); if(ch=='-') {f=-1; ch=getchar();}\n\twhile(ch>='0' && ch <='9') x=x*10+ch-'0',ch=getchar();\n\tx*=f;\n}\n//==========================head template==========================\nconst int N=100010;\nll d[N];\nint n;\nmap<ll,int> key;\npli seq[N];\nint fa[N],sz[N];\nsigned main() {\n  read(n);\n  for(int i=1;i<=n;i++) read(d[i]);\n  for(int i=1;i<=n;i++) key[d[i]]=i;\n  for(int i=1;i<=n;i++) seq[i]=mp(d[i],i);\n  sort(seq+1,seq+n+1); reverse(seq+1,seq+n+1);\n  for(int i=1;i<=n;i++) sz[i]=1;\n  for(int i=1;i<n;i++) {\n    int u=seq[i].S;\n    ll delta=d[u]+sz[u]-(n-sz[u]);\n    //printf(\"%lld %d\\n\",delta,u);\n    if(!key.count(delta)) {puts(\"-1\"); return 0;}\n    fa[u]=key[delta];\n    sz[fa[u]]+=sz[u];\n  }\n  for(int i=1;i<=n;i++)\n    if(fa[i]) {printf(\"%d %d\\n\",i,fa[i]);}\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXn = 1e5 + 10;\ntypedef pair<long long, int> pii;\npii ar[MAXn];\nlong long n, sz[MAXn], root, disroot, d[MAXn], hp3[MAXn];\nvector<int> vec[MAXn];\nvector<pii> ans;\n\nbool cmp(pii p1, pii p2) {\n\treturn p1.first > p2.first;\n}\n\nlong long dfs1(int v, int  par) {\n\tlong long res = 0;\n\tfor (int i = 0; i < vec[v].size(); i++)\n\t\tif (vec[v][i] != par) {\n\t\t\tres += dfs1(vec[v][i], v) + hp3[vec[v][i]];\n\t\t\thp3[v] += hp3[vec[v][i]];\n\t\t}\n\thp3[v]++;\n\treturn res;\n\t\n}\n\nvoid dfs2(int v, int par, long long sth) {\n\tif (sth != d[v]) {\n\t\tcout << -1;\n\t\texit(0);\n\t}\n\tfor (int i = 0; i < vec[v].size(); i++) {\n\t\tif (vec[v][i] != par) {\n\t\t\tdfs2(vec[v][i], v, sth - (hp3[vec[v][i]]) + (hp3[0] - hp3[vec[v][i]]));\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}\nint main() {\n\tcin >> n;\n\tfill_n(sz, MAXn, 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tint di;\n\t\tcin >> di;\n\t\td[i] = di;\n\t\tar[i].first = di;\n\t\tar[i].second = i;\n\t}\n\tsort(ar, ar + n);\n\tfor (int i = n - 1; i > 0; i--) {\n\t\tlong long hp = ar[i].first - n;\n\t\thp += 2LL * sz[i];\n\t\tint hp2 = lower_bound(ar, ar + n, pii(hp, -1)) - ar;\n\t\tif (ar[hp2].first != hp)\n\t\t\treturn cout << -1,0;\n\t\tsz[hp2]+= sz[i];\n\t\tvec[ar[hp2].second].push_back(ar[i].second);\n\t\tvec[ar[i].second].push_back(ar[hp2].second);\n\t\tans.push_back(pii(ar[i].second, ar[hp2].second));\n\t}\n\tdisroot = dfs1(0, -1);\n\tdfs2(0, -1, disroot);\n\tfor (int i = 0; i < ans.size(); i++)\n\t\tcout << ans[i].first + 1<< ' ' << ans[i].second + 1<< endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <map>\n\ntypedef long long ll;\nconst int N = 1e5 + 51;\nstruct edge {\n\tint to, next;\n} e[N << 1];\nint head[N], cnt;\nvoid addedge(int x, int y) {\n\te[++cnt] = (edge){y, x[head]}, x[head] = cnt;\n\te[++cnt] = (edge){x, y[head]}, y[head] = cnt;\n}\n\nint ans;\nvoid dfs(int x, int p, int d) {\n\tans += d;\n\tfor (int i = x[head], nx; i; i = e[i].next)\n\t\tif ((nx = e[i].to) != p) dfs(nx, x, d + 1);\n}\n\nint p[N];\nint f(int x) { return x[p] ? x[p] = f(x[p]) : x; }\nvoid l(int x, int y) {\n\tif ((x = f(x)) != (y = f(y))) x[p] = y;\n}\n\nstd::map<ll, int> mp;\nint n, sz[N];\nll a[N];\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", a + i), i[sz] = 1, mp[a[i]] = i;\n\tstd::sort(a + 1, a + n + 1, std::greater<ll>());\n\tfor (int i = 1; i < n; i++) {\n\t\tint x = mp[a[i]], nx;\n\t\tll tmp = a[i] - n + 2 * x[sz];\n\t\tif (tmp >= a[i] || !mp.count(tmp)) return puts(\"-1\"), 0;\n\t\tnx = mp[tmp];\n\t\tnx[sz] += x[sz];\n\t\tif (f(x) == f(nx)) return puts(\"-1\"), 0;\n\t\taddedge(x, nx);\n\t\tl(x, nx);\n\t}\n\tdfs(1, 0, 0);\n\tif (ans != a[n]) return puts(\"-1\"), 0;\n\tfor (int i = 1; i <= cnt; i += 2) printf(\"%d %d\\n\", e[i].to, e[i + 1].to);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MN 100005\nint T,n,id[MN];\nll a[MN];\nmap<ll,int>rea,cnt;\nstruct node{int x,y;};\nvector<node>sc;\nbool cmp(int x,int y){return a[x]>a[y];}\nint main(){\n//\tfreopen(\"test.in\",\"r\",stdin);\n//\tfreopen(\"mysol.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),rea[a[i]]=i,cnt[a[i]]=1,id[i]=i;\n\tsort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<n;i++){\n\t\tint t=id[i];ll tmp=a[t]-n+2*cnt[a[t]];\n\t\tif(rea[tmp]&&tmp<a[t]){\n\t\t\tcnt[tmp]+=cnt[a[t]];\n\t\t\tsc.push_back((node){t,rea[tmp]});\n\t\t}\n\t\telse return 0*puts(\"-1\");\n\t}\n\tfor(int i=0;i<sc.size();i++)printf(\"%d %d\\n\",sc[i].x,sc[i].y);\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MN 100005\nint T,n,id[MN];\nll a[MN];\nmap<ll,int>rea,cnt;\nstruct node{int x,y;};\nvector<node>sc;\nbool cmp(int x,int y){return a[x]>a[y];}\nint main(){\n//\tfreopen(\"test.in\",\"r\",stdin);\n//\tfreopen(\"mysol.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),rea[a[i]]=i,cnt[a[i]]=1,id[i]=i;\n\tsort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<n;i++){\n\t\tint t=id[i];ll tmp=a[t]-n+2*cnt[a[t]];\n\t\tif(rea[tmp]&&tmp<a[t]){\n\t\t\tcnt[tmp]+=cnt[a[t]];\n\t\t\tsc.push_back((node){t,rea[tmp]});\n\t\t}\n\t\telse return 0*puts(\"-1\");\n\t}\n\tfor(int i=0;i<sc.size();i++)printf(\"%d %d\\n\",sc[i].x,sc[i].y);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//W4P3R\n#include<bits/stdc++.h>\n#define inf 1e9\n#define eps 1e-6\n#define re register ll \n#define FOR(i,a,b) for(re i=a;i<=b;i++)\n#define REP(i,a,b) for(re i=a;i>=b;i--)\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define pa pair<ll,ll>\n#define fr first\n#define sd second\n#define Z(x) (x>=mod?x-mod:x)\n#define lowbit(x) (x&(-x))\n#define N 100010\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ninline ll read()\n{\n    char ch=getchar();\n    ll s=0,w=1;\n    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}\n    return s*w;\n}\nll n;\nll D[N],sz[N],s=0;\nset<pa>S;\nvector<ll>e[N];\nvector<pa>ans; \nvoid dfs(ll u,ll father,ll d)\n{\n\ts+=d;\n\tfor(ll v:e[u])if(v!=father)dfs(v,u,d+1);\n}\nint main()\n{\n    //freopen(\".in\",\"r\",stdin);\n    //freopen(\".out\",\"w\",stdout);\n    n=read();\n    FOR(i,1,n){D[i]=read();S.insert(mp(D[i],i));}\n    ll t=n-1;\n    while(t--)\n    {\n    \tll x=(*(--S.end())).sd;S.erase(S.lower_bound(mp(D[x],x)));\n    \tsz[x]++;\n    \tll v=D[x]+2*sz[x]-n;\n    \tll y=(*S.lower_bound(mp(v,0))).sd;\n    \t//cout<<\"WTF:\"<<x<<\" \"<<D[x]<<\" \"<<sz[x]<<\" \"<<v<<\" \"<<y<<\" \"<<D[y]<<endl;\n    \tif(D[y]!=v){puts(\"-1\");return 0;}\n    \te[x].pb(y),e[y].pb(x);sz[y]+=sz[x];\n    \tans.pb(mp(x,y));\n    }\n    dfs(1,0,0);\n    if(s==D[1]){for(auto tmp:ans)printf(\"%lld %lld\\n\",tmp.fr,tmp.sd);}\n    else puts(\"-1\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<vector>\n#define ll long long\nusing namespace std;\nmap<ll,int>mp;\nstruct DIAN\n{\n\tint bh;\n\tlong long d;\n}ak[100010];\nbool cmp(const DIAN&xx,const DIAN&yy)\n{\n\treturn xx.d>yy.d;\n}\nvector<int>G[100010];\nll sz[100010];\nll dep[100010];\nint n;\nvoid dfs(int x,int fx)\n{\n\tint i;\n\tdep[x]=dep[fx]+1;\n\tfor(i=0;i<G[x].size();i++)\n\t{\n\t\tif(G[x][i]==fx)continue;\n\t\tdfs(G[x][i],x);\n\t}\n}\nvoid dfss(int x,int fx)\n{\n\tint i;\n\tfor(i=0;i<G[x].size();i++)\n\t{\n\t\tif(G[x][i]==fx)continue;\n\t\tprintf(\"%d %d\\n\",x,G[x][i]);\n\t\tdfss(G[x][i],x);\n\t}\n}\nint main()\n{\n\tint i;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&ak[i].d);\n\t\tak[i].bh=i;\n\t\tmp[ak[i].d]=i;\n\t}\n\tll bli=ak[1].d;\n\tsort(ak+1,ak+n+1,cmp);\n\tfor(i=1;i<n;i++)\n\t{\n\t\tsz[ak[i].bh]++;\n\t\tif(n-2*sz[ak[i].bh]<=0)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tll qwq=ak[i].d-1ll*(n-2*sz[ak[i].bh]);\n\t\tif(mp.find(qwq)==mp.end())\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tG[ak[i].bh].push_back(mp[qwq]);\n\t\tG[mp[qwq]].push_back(ak[i].bh);\n\t\tsz[mp[qwq]]+=sz[ak[i].bh];\n\t}\n\tdfs(1,0);\n\tll alk=0;\n\tfor(i=1;i<=n;i++)\n\t\talk+=(dep[i]-1ll);\n\tif(alk!=bli)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tdfss(1,0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define re register\n#define gc getchar\n#define pc putchar\n#define cs const\n\ninline\nll getint(){\n\tre ll num;\n\tre char c;\n\twhile(!isdigit(c=gc()));num=c^48;\n\twhile(isdigit(c=gc()))num=(num<<1)+(num<<3)+(c^48);\n\treturn num;\n}\n\ninline\nvoid outint(int a){\n\tstatic char ch[13];\n\tif(a==0)pc('0');\n\twhile(a)ch[++ch[0]]=a-a/10*10,a/=10;\n\twhile(ch[0])pc(ch[ch[0]--]^48);\n}\n\ncs int N=100005;\n\nint last[N],nxt[N],to[N],ecnt;\ninline\nvoid addedge(int u,int v){\n\tnxt[++ecnt]=last[u],last[u]=ecnt,to[ecnt]=v;\n}\n\nmap<ll,int> id;\nint n;\nll d[N];\nint siz[N];\n\nint dist[N];\ninline\nvoid dfs(int u){\n\tfor(int re e=last[u],v=to[e];e;v=to[e=nxt[e]]){\n\t\tdist[v]=dist[u]+1;\n\t\tdfs(v);\n\t}\n}\n\nvector<pair<int,int> > edge;\n\nsigned main(){\n\tn=getint();\n\tfor(int re i=1;i<=n;++i)d[i]=getint(),id[d[i]]=i;\n\t\n\tsort(d+1,d+n+1);\n\tfor(int re i=1;i<=n;++i)siz[i]=1;\n\t\n\tfor(int re i=n;i>1;--i){\n\t\tint u=id[d[i]];\n\t\tint tmp=n-2*siz[u];\n\t\tif(tmp<=0)return puts(\"-1\"),0; \n\t\tll t=d[i]-tmp;\n\t\tif(id.count(t)==0)return puts(\"-1\"),0;\n\t\tint pos=id[t];\n\t\taddedge(pos,u);\n\t\tsiz[pos]+=siz[u];\n\t\tedge.push_back(make_pair(pos,u));\n\t}\n\tll sum=0;\n\tdfs(id[d[1]]);\n\tfor(int re i=1;i<=n;++i){\n\t\tsum+=dist[i];\n\t}\n\tif(sum!=d[1])return puts(\"-1\"),0;\n\tfor(int re i=0;i<edge.size();++i)outint(edge[i].first),pc(' '),outint(edge[i].second),pc('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\nconst int MAXN = 120000;\n\nint n;\nll d[MAXN];\nint sz[MAXN];\nmap<ll, int> mm;\nvector<int> eds[MAXN];\nint was[MAXN];\n\nvector<pair<int, int>> ed;\n\nvoid no() {\n\tcout << -1 << \"\\n\";\n\texit(0);\n}\n\nvoid add_edge(int a, int b) {\n\tif (a == b)\n\t\tno();\n\tif (a > b)\n\t\tswap(a, b);\n\teds[a].push_back(b);\n\teds[b].push_back(a);\n\ted.emplace_back(a, b);\n}\n\nll go;\n\nvoid dfs1(int v) {\n\twas[v] = 1;\n\tsz[v] = 1;\n\tfor (int u: eds[v])\n\t\tif (!was[u])\n\t\t\tdfs1(u), sz[v] += sz[u], go += sz[u];\n}\n\nvoid dfs2(int v, int p, ll cur) {\n\tif (d[v] != cur)\n\t\tno();\n\tfor (int u: eds[v]) {\n\t\tif (u == p)\n\t\t\tcontinue;\n\t\tdfs2(u, v, cur + (n - 2 * sz[u]));\n\t}\n}\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> d[i], sz[i] = 1, mm[d[i]] = i;\n\tvector<pair<ll, int>> vv;\n\tfor (int i = 0; i < n; ++i)\n\t\tvv.emplace_back(d[i], i);\n\tsort(ALL(vv));\n\treverse(ALL(vv));\n\tfor (int i = 0; i + 1 < vv.size(); ++i) {\n\t\tll go = vv[i].first - (n - 2 * sz[vv[i].second]);\n\t\tint p = mm[go];\n\t\tadd_edge(vv[i].second, p);\n\t\tsz[p] += sz[vv[i].second];\n\t}\n\tdfs1(0);\n\tfor (int i = 0; i < n; ++i)\n\t\tif (!was[i])\n\t\t\tno();\n\tif (d[0] != go)\n\t\tno();\n\tdfs2(0, -1, go);\n\tsort(ed.begin(), ed.end());\n\tfor (auto p: ed)\n\t\tcout << p.first + 1 << \" \" << p.second + 1 << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inc(i,a,b) for(register int i=a;i<=b;i++)\n#define dec(i,a,b) for(register int i=a;i>=b;i--)\nusing namespace std;\ntypedef long long LL;\ninline void read(int &x)\n{\n\tx=0;bool f=0;char c=getchar();\n\twhile(c>'9'||c<'0'){if(c=='-')f=1;c=getchar();}\n\twhile(c<='9'&&c>='0')x=(x<<3)+(x<<1)+c-'0',c=getchar();\n\tif(f)x=-x;return;\n}\ninline void read(LL &x)\n{\n\tx=0;bool f=0;char c=getchar();\n\twhile(c>'9'||c<'0'){if(c=='-')f=1;c=getchar();}\n\twhile(c<='9'&&c>='0')x=(x<<3)+(x<<1)+c-'0',c=getchar();\n\tif(f)x=-x;return;\t\n}\nconst int mx=100007;\nstruct node\n{\n\tint n,t,u;\n}nx[mx];\nint n,siz[mx],cnt,h[mx];\npair <LL,int> d[mx];\n#define f first\n#define s second\nvoid add(int u,int v)\n{\n\tnx[++cnt].n=h[u];\n\tnx[cnt].u=u;\n\tnx[cnt].t=v;\n\th[u]=cnt;\n}\nint find(LL x)\n{\n\tint l=1,r=n,mid=(l+r)>>1;\n\twhile(l<=r)\n\t{\n\t\tif(d[mid].f==x)return mid;\n\t\tif(d[mid].f<x)l=mid+1;\n\t\telse r=mid-1;mid=(l+r)>>1;\n\t}\n\treturn 0;\n}\nLL check;\n#define link(i,x) for(register int i=h[x];i;i=nx[i].n)\nLL dfs(int x,LL upp)\n{\n\tLL res=upp;\n\tlink(i,x)res+=dfs(nx[i].t,upp+1);\n\treturn res;\n}\nint main()\n{\n\tread(n);\n\tinc(i,1,n)\n\t{\n\t\tread(d[i].f);\n\t\td[i].s=i;\n\t\tsiz[i]=1;\n\t}\n\tsort(d+1,d+n+1);\n\tdec(i,n,2)\n\t{\n\t\tint fr=find(d[i].f+(siz[i]<<1)-n);\n\t\tif(fr)add(fr,i),siz[fr]+=siz[i];\n\t\telse {printf(\"-1\\n\");return 0;}\n\t}\n\tcheck=dfs(1,0);\n\tif(check!=d[1].f)return 0;\n\tinc(i,1,cnt)printf(\"%d %d\\n\",d[nx[i].u].s,d[nx[i].t].s);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\nusing namespace std;\nconst int N=1e5+5;\nint n,p[N],fa[N],sz[N],dep[N];long long d[N];\nmap<long long,int>Map;\nbool cmp(int x,int y){\n\treturn d[x]>d[y];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%lld\",&d[i]);\n\t\tMap[d[i]]=i;p[i]=i;sz[i]=1;\n\t}\n\tsort(p+1,p+n+1,cmp);\n\tfor(int i=1;i<n;++i){\n\t\tint x=p[i];\n\t\tfa[x]=Map[d[x]-n+sz[x]+sz[x]];\n\t\tif(!fa[x])return puts(\"-1\"),0;\n\t\tsz[fa[x]]+=sz[x];\n\t}\n\tlong long sum=0;\n\tfor(int i=n-1;i;--i)dep[p[i]]=dep[fa[p[i]]]+1,sum+=dep[p[i]];\n\tif(sum!=d[p[n]])return puts(\"-1\"),0;\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",p[i],fa[p[i]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <assert.h>\nusing namespace std;\ntypedef long long LL;\nconst int N=100000+10;\nint n,sz[N]; \npair<LL,LL> d[N];\nvector<LL> g[N];\nbool cmp(pair<LL,LL> p1,pair<LL,LL> p2){\n    return p1.second>p2.second;\n}\nmap<LL,LL> mp;\nvector< pair<LL,LL> > res;\nint dep[N]; LL sum=0;\nvoid prt(int u,int p){\n    for(auto v:g[u]){\n        if(v==p)continue;\n        res.push_back(make_pair(u,v));\n        dep[v]=dep[u]+1; sum+=dep[v];\n        prt(v,u);\n    }\n}\nint main() {\n    scanf(\"%d\",&n); \n    for(int i=1;i<=n;i++){\n        d[i].first=i; \n        scanf(\"%lld\",&d[i].second);\n        mp[d[i].second]=i;\n        sz[i]=1;\n    }\n    sort(d+1,d+1+n,cmp);\n    for(int i=1;i<n;i++){\n        LL tmp=d[i].second;\n        LL nex=tmp-(n-2*sz[d[i].first]);\n        if(mp[nex]==0||nex>=tmp){\n            return !printf(\"-1\\n\");\n        }\n        int u=mp[nex];\n        int v=d[i].first;\n        g[u].push_back(v); g[v].push_back(u);\n        sz[u]+=sz[v];\n    }\n    prt(d[n].first,d[n].first);\n    if(sum != d[n].second) return !printf(\"-1\\n\");\n    if(res.size()==n-1){\n        for(auto p: res) printf(\"%lld %lld\\n\", p.first, p.second);\n    } else {\n        printf(\"-1\\n\");\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long li;\n\nconst int maxn = 1e5;\n\nint n, fa[maxn];\nli D[maxn];\nint size[maxn];\n\npair<li, int> ord[maxn];\nmap<li, int> id;\nli dp[maxn];\n\nint main(void) {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; ++i) scanf(\"%lld\", D + i);\n  for (int i = 0; i < n; ++i) ord[i] = {D[i], i};\n  for (int i = 0; i < n; ++i) id[D[i]] = i;\n  sort(ord, ord + n);\n  reverse(ord, ord + n);\n  for (int i = 0; i < n; ++i) size[i] = 1;\n  for (int i = 0; i < n; ++i) dp[i] = 0;\n\n  for (int i = 0; i < n - 1; ++i) {\n    int u = ord[i].second;\n    li del = n - size[u] * 2;\n    if (del <= 0 || !id.count(D[u] - del)) {\n      puts(\"-1\");\n      return 0;\n    }\n    fa[u] = id[D[u] - del];\n    size[fa[u]] += size[u];\n    dp[fa[u]] += dp[u] + size[u];\n  }\n\n  if (dp[ord[n - 1].second] != D[ord[n - 1].second]) {\n    puts(\"-1\");\n    return 0;\n  }\n\n  for (int i = 0; i < n - 1; ++i) {\n    int u = ord[i].second;\n    int v = fa[u];\n    printf(\"%d %d\\n\", u + 1, v + 1);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, int> pli;\nconst int N = 1e5 + 5;\n\nint n;\nll D[N];\npli a[N];\nint sz[N];\n\nvector <int> g[N];\n\nvoid add(int x, int y) {\n    sz[x] += sz[y];\n    g[x].push_back(y);\n}\n\nll res;\n\nvoid dfs(int u, int fa, ll d) {\n    res += d;\n    for(auto v : g[u]) {\n        if(v != fa) dfs(v, u, d + 1);\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    cin >> n;\n    for(int i = 1; i <= n; i++) cin >> D[i];\n    for(int i = 1; i <= n; i++) {\n        a[i] = MP(D[i], i); sz[i] = 1;\n    }\n    sort(a + 1, a + n + 1);\n    int f = 1;\n    for(int i = n; i > 1 && f; i--) {\n        ll t = a[i].fi + 2ll * sz[a[i].se] - n;\n        int x = lower_bound(a + 1, a + i, MP(t, 0)) - a;\n        if(a[x].fi != t) f = 0;\n        add(a[x].se, a[i].se);\n    }\n    if(f == 0) {cout << -1; return 0;}\n    dfs(a[1].se, 0, 0);\n    if(res != a[1].fi) {cout << -1; return 0;}\n    for(int i = 1; i <= n; i++) {\n        for(auto it : g[i]) cout << i << ' ' << it << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n\n#define X first\n#define Y second\n\n//#include <boost/unordered_map.hpp>\n//using namespace boost;\n\n/*\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> rbtree;\nrbtree T;\n*/\n\nnamespace io{\n\tconst int L = (1 << 20) + 1;\n\t\n\tchar buf[L], *S , *T, c;\n\t \n\tchar getchar() {\n\t\tif(__builtin_expect(S == T, 0)) {\n\t\t\tT = (S = buf) + fread(buf, 1, L, stdin);\n\t\t\treturn (S == T ? EOF : *S++);\n\t\t}\n\t\treturn *S++;\n\t}\n\t\n\tint inp() {\n\t\tint x = 0, f = 1; char ch;\n\t\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\t\tif(ch == '-') f = -1;\n\t\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\t\treturn x * f;\n\t}\n\t\n\tunsigned inpu()\n\t{\n\t\tunsigned x = 0; char ch;\n\t\tfor(ch = getchar(); !isdigit(ch); ch = getchar());\n\t\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\t\treturn x;\n\t}\n\t\n\tll inp_ll() {\n\t\tll x = 0; int f = 1; char ch;\n\t\tfor(ch = getchar(); !isdigit(ch); ch = getchar())\n\t\t\tif(ch == '-') f = -1;\n\t\tfor(; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\t\treturn x * f;\n\t}\n\t\n\tchar B[25], *outs=B+20, *outr=B+20;\n\ttemplate<class T>\n\tinline void print(register T a,register char x=0){\n\t\tif(x) *--outs = x, x = 0;\n\t\t\n\t\tif(!a)*--outs = '0';\n\t\telse \n\t\t\twhile(a)\n\t\t\t\t*--outs = (a % 10) + 48, a /= 10;\n\t\t\n\t\tif(x)\n\t\t\t*--outs = x;\n\t\t\n\t\tfwrite(outs, outr - outs , 1, stdout);\n\t\touts = outr;\n\t}\n};\n\nusing io :: print;\nusing io :: inp;\nusing io :: inpu;\nusing io :: inp_ll;\n\nusing i32 = int;\nusing i64 = long long;\nusing u8 = unsigned char;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing f64 = double;\nusing f80 = long double;\n\nll power(ll a, ll b, ll p)\n{\n\tif (!b) return 1;\n\tll t = power(a, b/2, p);\n\tt = t*t%p;\n\tif (b&1) t = t*a%p;\n\treturn t;\n}\n\nconst int MAXN = 200010;\nconst u64 MOD = 1000000007;\nconst f80 MI = f80(1)/MOD;\nconst int INF = 1000000010;\n\nvector<pii> ans;\n\nvoid addedge(int x, int y)\n{\n\tans.emplace_back(x, y);\n\t// printf(\"%d %d\\n\", x, y);\n}\n\npriority_queue<pll, vector<pll>, greater<pll> > H[2];\nint n;\nll d[MAXN], size[MAXN];\n\nint main()\n{\nputs(\"-1\"); return 0;\n\t\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++ i)\n\t{\n\t\tscanf(\"%lld\", &d[i]);\n\t\tH[d[i]%2].emplace(d[i], i);\n\t}\n\td[0] = 1e13;\n\tint r1 = 0, r2 = 0;\n\tif (!H[0].empty()) r1 = H[0].top().Y;\n\tif (!H[1].empty()) r2 = H[1].top().Y;\n\tint y = (d[r1] < d[r2]) ? r1 : r2;\n\tif (y == r1) H[0].pop();\n\tif (y == r2) H[1].pop();\n\tsize[y] = n;\n\tqueue<int> Q;\n\tQ.push(y);\n\twhile (!Q.empty())\n\t{\n\t\tint y = Q.front();\n\t\tQ.pop();\n\t\tint k = (n+d[y])%2;\n\t\twhile (size[y] > 1)\n\t\t{\n\t\t\tif (H[k].empty())\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tint x = H[k].top().Y;\n\t\t\tH[k].pop();\n\t\t\taddedge(x, y);\n\t\t\tsize[x] = (n+d[y]-d[x])/2;\n\t\t\tsize[y] -= size[x];\n\t\t\tQ.push(x);\n\t\t}\n\t\tif (size[y] != 1)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tfor (auto p : ans)\n\t\tprintf(\"%d %d\\n\", p.X, p.Y);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 100100;\n\nint N;\nll D[MAXN];\nvector <int> edge[MAXN];\n\nmap <ll, int> ord;\nmap <ll, int> ssize;\nmap <ll, ll> stot;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n\n    cin >> N;\n    for (int i = 0; i < N; i++)\n    {\n        cin >> D[i];\n        ord[D[i]] = i;\n        ssize[D[i]] = 1;\n        stot[D[i]] = 0;\n    }\n\n    for (auto it = ord.rbegin(); it != ord.rend(); it++)\n    {\n        ll cv = it -> first;\n        int ind = it -> second;\n\n        int csize = ssize[cv];\n        if (csize == N) break;\n        ll ntot = D[ind] - ((N - csize) - csize);\n        //cout << cv << \" \" << ntot << \"\\n\";\n        if (ord.find(ntot) == ord.end())\n        {\n            cout << \"-1\\n\";\n            return 0;\n        }\n\n        ssize[ntot] += csize;\n        stot[ntot] += (stot[cv] + ssize[cv]);\n        edge[ord[ntot]].push_back(ind);\n    }\n    //cout << \"made it\\n\";\n\n    int mloc = 0;\n    for (int i = 0; i < N; i++)\n        if (D[i] < D[mloc])\n            mloc = i;\n    if (stot[D[mloc]] != D[mloc])\n    {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    else\n    {\n        for (int i = 0; i < N; i++)\n        {\n            for (int neigh : edge[i])\n                cout << neigh + 1 << \" \" << i + 1 << \"\\n\";\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100010;\n\ntypedef long long ll;\n\npriority_queue<ll> pq;\nmap<ll, int> mp;\n\nint n, l[maxn], dep[maxn], sz[maxn], w[maxn], vis[maxn], e_u[maxn], e_v[maxn], tot, e = 0;\nll D[maxn], S[maxn];\n\nstruct Edge {\n    int v, x;\n} E[maxn];\n\ninline void addEdge(int u, int v) {\n    E[e].v = v; E[e].x = l[u]; l[u] = e++;\n}\n\nvoid dfs1(int u) {\n    sz[u] = 1;\n    for (int p = l[u]; p >= 0; p = E[p].x) {\n        int v = E[p].v;\n        dep[v] = dep[u] + 1;\n        dfs1(v);\n        sz[u] += sz[v];\n    }\n}\n\nvoid dfs2(int u) {\n    for (int p = l[u]; p >= 0; p = E[p].x) {\n        int v = E[p].v;\n        S[v] = S[u] + n - 2 * sz[v];\n        dfs2(v);\n    }\n}\n\nint main() {\n    memset(l, -1, sizeof(l));\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) scanf(\"%lld\", &D[i]);\n    for (int i = 1; i <= n; i++) {\n        mp[D[i]] = i;\n        pq.push(D[i]);\n        w[i] = 1;\n    }\n    vis[0] = 1;\n    while (pq.size() > 1) {\n        ll v = pq.top(); pq.pop();\n        int u = mp[v];\n        vis[u] = 1;\n        if (!vis[mp[v + 2 * w[u] - n]]) {\n            int t = mp[v + 2 * w[u] - n];\n            w[t] += w[u];\n            addEdge(t, u);\n            ++ tot;\n            e_u[tot] = t; e_v[tot] = u;\n        } else {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    int r = mp[pq.top()];\n    dfs1(r);\n    for (int i = 1; i <= n; i++) S[r] += dep[i];\n    dfs2(r);\n    for (int i = 1; i <= n; i++) {\n        if (S[i] != D[i]) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    for (int i = 1; i <= tot; i++) printf(\"%d %d\\n\", e_u[i], e_v[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+5;\nint n,f[N],si[N];\nstruct node\n{\n    ll x;\n    int id;\n    bool operator<(const node&o)const\n    {\n        return x<o.x;\n    }\n}a[N];\nunordered_map<ll,int>mp;\nvector<pair<int,int> >v;\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%lld\",&a[i].x),a[i].id=i;\n    sort(a+1,a+1+n);\n    for(int i=1;i<=n;i++) si[i]=1,f[i]=a[i].id,mp[a[i].x]=i;\n    for(int i=n;i>1;i--)\n    {\n        ll t=a[i].x+si[i]-(n-si[i]);\n        if(si[i]>(n-si[i])){printf(\"-1\\n\");return 0;}\n        if(mp[t]&&mp[t]!=i) v.push_back({i,mp[t]}),si[mp[t]]+=si[i];\n    }\n    if(si[1]!=n||v.size()!=n-1) {printf(\"-1\\n\");return 0;}\n    else for(int i=0;i<v.size();i++)\n        printf(\"%d %d\\n\",f[v[i].first],f[v[i].second]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n/*#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"fast-math\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,popcnt,abm,mmx,tune=native\")*/\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stdio.h>\n#include <cstdio>\n#include <math.h>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <deque>\n#include <random>\n#include <iomanip>\n#include <bitset>\n                      \nusing namespace std;\n                      \ntemplate<typename T> void uin(T &a, T b) {\n    if (b < a) {\n        a = b;\n    }\n}\n                      \ntemplate<typename T> void uax(T &a, T b) {\n    if (b > a) {\n        a = b;\n    }\n}\n\n#define int long long\n#define ghost signed\n#define left left228\n#define right right228\n#define prev prev228\n#define list list228\n\nconst int N = 100 * 1000 + 228;\n\nint n;\nint d[N], sz[N];\nmap<int, int> pos; \nvector<int> g[N];\n\nbool cmp(int i, int j) {\n\treturn d[i] > d[j];\n}\n\nint D[N], S[N];\nint sumd = 0;\nbool OK = 1;\n\nvoid jfs(int v, int par = -1) {\n\tS[v] = 1;\n\tfor (int to : g[v]) {\n\t\tif (to == par) continue;\n\t\tjfs(to, v);\n\t\tS[v] += S[to];\n\t}\n}\n\nvoid bfs(int a) {\n\tfor (int i = 1; i <= n; ++i) D[i] = n * 100;\n\tD[a] = 0;\n\tvector<int> q;\n\tq.push_back(a);\n\tfor (int i = 0; i < (int)q.size(); ++i) {\n\t\tint v = q[i];\n\t\tfor (int to : g[v]) {\n\t\t\tif (D[v] + 1 < D[to]) {\n\t\t\t\tD[to] = D[v] + 1;\n\t\t\t\tq.push_back(to);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) sumd += D[i];\n\tjfs(1);\n}\n\nvoid dfs(int v, int par = -1) {\n\tif (v != 1) {\n\t\tsumd -= S[v];\n\t\tsumd += (n - S[v]);\n\t}\n\tif (sumd != d[v]) OK = 0;\n\tfor (int to : g[v]){\n\t\tif (to == par) continue;\n\t\tdfs(to, v);\n\t}\n\tif (v != 1) {\n\t\tsumd += S[v];\n\t\tsumd -= (n - S[v]);\n\t}\n}\n\nbool check() {\n\tbfs(1);\n\tdfs(1);\n\treturn OK;\n}\n\nghost main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> d[i];\n\t\tpos[d[i]] = i;\n\t}\n\tvector<int> order;\n\tfor (int i = 1; i <= n; ++i) order.push_back(i);\n\tfor (int i = 1; i <= n; ++i) sz[i] = 1;\n\tsort(order.begin(), order.end(), cmp);\n\tvector< pair<int, int> > e;\n\tint last = order.back();\n\tfor (int v : order) {\n\t\tif (v == last) break;\n\t\tint nd = d[v] + 2 * sz[v] - n;\n\t\tif (nd <= v) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint par = pos[nd];\n\t\tif (par == 0) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\te.push_back(make_pair(par, v));\n\t\tg[par].push_back(v);\n\t\tg[v].push_back(par);\n\t\tsz[par] += sz[v];\n\t}\n\tif (!check()) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tfor (auto p : e) cout << p.first << \" \" << p.second << '\\n';\n\treturn 0;\n} // kek ;\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//\n// Created by Ильдар Ялалов on 28.10.2019.\n//\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stdio.h>\n#include <string.h>\n#include <cmath>\n#include <queue>\n#include <ctime>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int inf_int = 1e9 + 100;\nconst ll inf_ll = 1e18;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef long double dbl;\n#define pb push_back\n#define eb emplace_back\nconst double pi = 3.1415926535898;\n#define dout if(debug) cout\n#define fi first\n#define se second\n#define sp setprecision\n#define sz(a) (int(a.size()))\n#define all(a) a.begin(),a.end()\nbool debug = 0;\nconst int MAXN = 1e4 + 100;\nconst int LOG = 21;\nconst int mod = 1e9 + 7;\nconst int MX = (1e7 + 100) * 1.5;\ntypedef long long li;\nconst li MOD = 1000000000949747713ll;\n\ntemplate<class T1, class T2>\nstd::ostream &operator<<(std::ostream &out, const std::pair<T1, T2> &rhs) {\n    out << \"( \" << rhs.first << \" , \" << rhs.second << \" )\";\n    return out;\n}\n\n\npll D[MAXN];\n\nint sz[MAXN];\n\nvector<int> g[MAXN];\n\n\nll sum  = 0;\nvoid dfs(int v,int p,ll cur){\n    sum += cur;\n    for(int to:g[v]){\n        if(to == p)\n            continue;\n        dfs(to,v,cur+1);\n\n    }\n}\nvoid solve() {\n    int n;\n    cin >> n;\n\n    map<ll,int> mp;\n    for (int i = 1; i <= n; ++i) {\n        cin >> D[i].fi;\n        D[i].se = i;\n        if(mp.count(D[i].fi) == 0){\n            mp[D[i].fi] = i;\n        }\n\n\n        sz[i] = 1;\n    }\n    sort(D+1,D+n+1);\n\n    vector<pii> edges;\n    for(int j = n;j > 1;--j){\n        int v = D[j].se;\n        ll x = D[j].fi - n + 2 * sz[v];\n        dout << v << \" \"<<D[j].fi <<\" \"<<x <<\" : \" <<endl;\n        if(mp.count(x) == 0){\n            cout <<\"-1\";\n            return;\n        }\n\n        int to = mp[x];\n        if(to == v){\n            cout << -1 <<\"\\n\";\n            return;\n        }\n        edges.pb({v,to});\n        sz[to] += sz[v];\n    }\n    \n    dfs(D[1].se,-1,0);\n\n    if(sum != D[1].fi){\n        cout << -1;\n        return;\n    }\n    for(auto x : edges){\n        cout << x.fi<<\" \"<<x.se<<\"\\n\";\n    }\n\n\n}\n\nsigned main() {\n#ifdef zxc\n    debug = 1;\n    freopen(\"../input.txt\", \"r\", stdin);\n    //  freopen(\"../output.txt\", \"w\", stdout);\n#else\n\n#endif //zxc\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(20);\n\n    int t = 1;\n    while (t--)\n        solve();\n    if (debug)\n        cerr << endl << \"time : \" << (1.0 * clock() / CLOCKS_PER_SEC) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define mp make_pair\nusing namespace std;\n\nint size[100010], fa[100010];\nlong long dp[100010];\nmap <long long, int> to_i;\nlong long D[100010];\nint n;\n\nint main () {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &D[i]);\n\t\tto_i[D[i]] = i;\n\t\tsize[i] = 1, dp[i] = 0;\n\t}\n\tmap <long long, int> :: iterator it = to_i.end();\n\twhile ((--it) != to_i.begin()) {\n\t\tint x = it->se;\n\t\tif (2 * size[x] >= n || !to_i.count(D[x] + 2 * size[x] - n)) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tfa[x] = to_i[D[x] + 2 * size[x] - n];\n\t\tsize[fa[x]] += size[x], dp[fa[x]] += dp[x] + size[x];\n\t}\n\tif (to_i.begin()->fi != dp[to_i.begin()->se]) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (fa[i]) printf(\"%d %d\\n\", i, fa[i]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 100005;\ntypedef long long LL;\n\nint n, D[N], head[N], nxt[N], size[N];\nstd::pair<LL, int> d[N];\n\nvoid no() {std::cout << \"-1\\n\", std::exit(0);}\n\nvoid link(int x, int y) {nxt[y] = head[x], head[x] = y;}\nint find(LL x) {\n\tauto it = std::lower_bound(d + 1, d + n + 1, std::make_pair(x, 0));\n\tif (it->first != x) no();\n\treturn it->second;\n}\nint dfs0(int x) {\n\tfor (int i = head[x]; i; i = nxt[i])\n\t\tD[x] += dfs0(i) + size[i];\n\treturn D[x];\n}\nvoid dfs1(int x) {\n\tfor (int i = head[x]; i; i = nxt[i])\n\t\tD[i] = D[x] + (n - 2 * size[i]), dfs1(i);\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor (int i = 1; i <= n; ++i)\n\t\tstd::cin >> d[i].first, d[i].second = i, size[i] = 1;\n\tstd::sort(d + 1, d + n + 1);\n\tfor (int i = n; i > 1; --i) {\n\t\tint p = d[i].second, f = find(d[i].first - (n - 2 * size[p]));\n\t\tsize[f] += size[p], link(f, p);\n\t}\n\tdfs0(d[1].second), dfs1(d[1].second);\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (D[d[i].second] != d[i].first) no();\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = head[i]; j; j = nxt[j]) std::cout << i << ' ' << j << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\n#include<map>\n#define LL long long \nusing namespace std;\n\nconst int M = 110001;\nint n,m,k,a[M],s[M],W;\nmap<LL,int> mp;\nstruct vv\n{\n\tLL x;\n\tint w;\n} t[M];\n\nbool cmp(vv a,vv b){return a.x>b.x;}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&t[i].x);\n\t\tt[i].w=i; s[i]=1;\n\t\tmp[t[i].x]=i;\n\t}\n\tsort(t+1,t+1+n,cmp);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tLL k=t[i].x+(LL)s[t[i].w]-n+s[t[i].w];\n\t\tif(k==t[i].x || mp.find(k)==mp.end())\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\ta[t[i].w]=mp[k];\n\t\tif(mp[k]==n) W=1;\n\t\ts[mp[k]]+=s[t[i].w];\n\t}\n\tif(!W) \n\t{\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<n;i++) printf(\"%d %d\\n\",t[i].w,a[t[i].w]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=100005;\nll D[N],S[N],SS[N];\nint n,id[N],fa[N];\nbool cmp(int x,int y){\n\treturn D[x]<D[y];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n) scanf(\"%lld\",&D[i]);\n\tFor(i,1,n) id[i]=i,S[i]=1,SS[i]=0;\n\tsort(id+1,id+n+1,cmp);\n\tRep(i,n,2){\n\t\tll fv=D[id[i]]-n+2*S[id[i]];\n\t\tint l=1,r=i-1,ans=0;\n\t\twhile (l<=r&&!ans){\n\t\t\tint mid=(l+r)/2;\n\t\t\tif (D[id[mid]]==fv)\tans=mid;\n\t\t\telse if (D[id[mid]]<fv) l=mid+1;\n\t\t\telse r=mid-1;\n\t\t}\n\t\tif (!ans) return puts(\"-1\"),0;\n\t\tint fa=::fa[id[i]]=id[ans];\n\t\tS[fa]+=S[id[i]];\n\t\tSS[fa]+=SS[id[i]];\n\t\tSS[fa]+=S[id[i]];\n\t}\n\tif (SS[id[1]]!=D[id[1]]) return puts(\"-1\"),0;\n\tFor(i,2,n) printf(\"%d %d\\n\",fa[id[i]],id[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <algorithm>\n#include <map>\n#define MN 100000\n#define MM 200000\nint n,hd[MN+5],to[MM+5],nxt[MM+5],rn=0;\nstd::map<int,int> mp;\ntypedef std::map<int,int>::iterator iter;\nstruct node{int i,d,sz;}a[MN+5];\nvoid _add(int u,int v){\n\tto[rn]=v,nxt[rn]=hd[u];\n\thd[u]=rn++;\n}\nvoid add(int u,int v){_add(u,v),_add(v,u);}\nvoid gg(){puts(\"-1\");exit(0);}\nint main(){\n\tmemset(hd,0xff,sizeof(hd));\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i].d);\n\t\ta[i].i=i,a[i].sz=1;\n\t}\n\tstd::sort(a+1,a+1+n,[](node a,node b)->bool{return a.d>b.d;});\n\tfor(int i=1;i<=n;i++) mp[a[i].d]=i;\n\tfor(int i=1;i<=n;i++){\n\t\tint dta=n-(a[i].sz<<1);\n\t\tif(dta<=0) continue;\n\t\titer it=mp.find(a[i].d-dta);\n\t\tif(it==mp.end()) gg();\n\t\ta[it->second].sz+=a[i].sz;\n\t\tadd(a[i].i,a[it->second].i);\n\t}\n\tif(rn!=(n-1)<<1) gg();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=hd[i];~j;j=nxt[j])\n\t\t\tif(to[j]>i) printf(\"%d %d\\n\",i,to[j]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tprintf(\"-1\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define title \"title\"\n#define ll long long\n#define ull unsigned ll\n#define fix(x) fixed<<setprecision(x)\n#define pii pair<int,int>\n#define vint vector<int>\n#define pb push_back\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define red(i,a,b) for(int i=(a);i>=(b);i--)\n#define db double\n#define ld long db\nusing namespace std;\nvoid Freopen(){\n\tfreopen(title\".in\",\"r\",stdin);\n\tfreopen(title\".out\",\"w\",stdout);\n}\nll read(){\n\tll g=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch){if(ch=='-')f=-1;ch=getchar();}\n\twhile('0'<=ch&&ch<='9'){g=g*10+ch-'0';ch=getchar();}\n\treturn g*f;\n}\nconst int N=1e5+5;\nmap<ll,int>id,fid;\nll a[N],ans;\nint n,siz[N];\nvint G[N];\nvoid dfs(int x,int dis){ans+=dis;for(auto y:G[x])dfs(y,dis+1);}\nsigned main(){\n\t//freopen(\"a\",\"r\",stdin);\n\tn=read();rep(i,1,n)a[i]=read(),fid[a[i]]=i;\n\tsort(a+1,a+n+1,[](ll a,ll b){return a>b;});\n\trep(i,1,n)id[a[i]]=i,siz[i]=1;\n\trep(i,1,n-1){\n\t\tll to=a[i]+siz[i]-(n-siz[i]);\n\t\tif(!id[to])return cout<<-1,signed();\n\t\tG[id[to]].pb(i);siz[id[to]]+=siz[i];\n\t}dfs(n,0);if(ans^a[n])return cout<<-1,signed();\n\trep(i,1,n)for(auto j:G[i])cout<<fid[a[i]]<<' '<<fid[a[j]]<<'\\n';\n\treturn signed();\n}"
  },
  {
    "language": "C++",
    "code": "#include <time.h>\n\n#include <stdlib.h>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <cstdint>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <vector>\n#include <map>\nusing namespace std;\nstruct condition{\n\tint64_t vertex;\n\tint64_t total;\n};\nstruct current{\n\tint64_t parent;\n\tint64_t vertex_num;\n\tint64_t sum;\n};\nstruct edge{\n\tint64_t v1;\n\tint64_t v2;\n};\nbool operator< (const condition& a,const condition& b){\n\treturn a.total>b.total;\n}\nint main() {\n\n\tint64_t n;\n\tcin>>n;\n\tstd::vector<condition> cd;\n\tvector<edge> ans;\n\tans.reserve(n);\n\tcd.reserve(n);\n\tfor(int64_t i=0;i<n;i++){\n\t\tint64_t temp;\n\t\tcin>>temp;\n\t\tcd.push_back(condition{i+1,temp});\n\t}\n\tbool ans_possible=true;\n\tsort(cd.begin(),cd.end());\n\tmap<int64_t,vector<current> > flow;\n\tfor(auto i=cd.begin();i!=cd.end();i++){\n\t\tbool islast = (i==cd.end()-1);\n\t\tint64_t sum_vertex=0;\n\t\tint64_t total_cost=0;\n\t\tif(flow.count(i->total)){\n\t\t\tvector<current>& t=flow.at(i->total);\n\n\t\t\tfor(auto k=t.begin();k!=t.end();k++){\n\t\t\t\tans.push_back(edge{k->parent,i->vertex});\n\t\t\t\tsum_vertex+=(k->vertex_num);\n\t\t\t\ttotal_cost+=k->sum;\n\t\t\t}\n\t\t\tans_possible=(total_cost==i->total);\n\n\t\t\tflow.erase(i->total);\n\t\t}else{\n\t\t\tans_possible=false;\n\t\t}\n\n\t\tsum_vertex++;\n\t\ttotal_cost+=sum_vertex;\n\n\t\tint64_t parent_value=i->total-(n-2*sum_vertex);\n\t\tif(!islast&&parent_value>=i->total){\n\t\t\tans_possible=false;\n\t\t\tbreak;\n\t\t}\n\t\tif(flow.count(parent_value)){\n\t\t\tflow.at(parent_value).push_back(current{i->vertex,sum_vertex,total_cost});\n\t\t}else{\n\t\t\tvector<current> temp2;\n\t\t\ttemp2.push_back(current{i->vertex,sum_vertex,total_cost});\n\t\t\tflow.emplace(parent_value,temp2);\n\t\t}\n\n\t}\n\tif(flow.size()==1&&ans_possible&&ans.size()==(n-1)){\n\t\tfor(auto i=ans.begin();i!=ans.end();i++){\n\t\t\tcout<<i->v1<<\" \"<<i->v2<<endl;\n\t\t}\n\t}else{\n\t\tcout<<-1<<endl;\n\t}\n\n\n\n\n\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n    > File Name: D.cpp\n    > Author: PumpkinYing\n    > Created Time: 2018/11/9 15:51:37\n ************************************************************************/\n\n#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <stack>\n#include <cmath>\nusing namespace std;\n\n#define mem(a,b) memset(a,b,sizeof(a))\n#define prii pair<int,int>\n#define prdd pair<double,double>\n#define rep(i,l,r) for(int i = l;i < r;i++)\n#define rep_(i,l,r) for(int i = l;i <= r;i++)\ntypedef long long ll;\n\nconst int maxn = 1000010;\nmap<ll,int> mp;\nint sz[maxn];\n\nstruct Node {\n\tll d;\n\tint id;\n\tvoid read(int i) {\n\t\tid = i;\n\t\tscanf(\"%lld\",&d);\n\t}\n\tbool operator < (const Node& b) const {\n\t\treturn d > b.d;\n\t}\n}ns[maxn];\n\nint fa[maxn],vis[maxn];\n\nint main() {\n\tint n;\n\tscanf(\"%d\",&n);\n\trep_(i,1,n) {\n\t\tns[i].read(i);\n\t\tmp[ns[i].d] = i;\n\t\tsz[i] = 1;\n\t}\n\tsort(ns+1,ns+1+n);\n\tint ok = 1;\n\trep_(i,1,n-1) {\n\t\tint id = ns[i].id;\n\t\tvis[id] = 1;\n\t\tll val = ns[i].d+sz[id]-(n-sz[id]);\n\t\tif(mp[val] == 0 || vis[mp[val]]) {\n\t\t\tok = 0;\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tfa[id] = mp[val];\n\t\t\tsz[mp[val]] += sz[id];\n\t\t}\n\t}\n\t/*\n\tif(ok == 0) printf(\"-1\\n\");\n\telse rep_(i,1,n) if(fa[i] != 0) printf(\"%d %d\\n\",i,fa[i]);\n\t*/\n\tprintf(\"-1\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <ctime>\n#include <vector>\n#include <fstream>\n#include <list>\n#include <iomanip>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define ms(s) memset(s, 0, sizeof(s))\nconst ll INF = 1e9;\ninline ll read(){\n\tll X = 0,w = 0 ;\n\tchar ch = 0;\n\twhile(!isdigit(ch)) {w |= ch == '-';ch = getchar();}\n\twhile(isdigit(ch)) X = (X<<3) + (X<<1) + (ch ^ 48),ch = getchar();\n\treturn w ? -X : X;\n}\nll dat[100005];\npair<ll,ll> p[100005];\nll sz[100005];\nll from[100005];\nll to[100005];\nll n;\nint main()\n{\n\tcin>>n;\n\tfor(ll i=0;i<n;i++)\n\t{\n\t\tcin>>dat[i];\n\t\tp[i]=make_pair(dat[i],i);\n\t}\n\tsort(p,p+n);\n\tll id=0;\n\tll sum=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tsz[i]=1;\n\t}\n\tfor(ll i=n-1;i>=1;i--)\n\t{\n\t\tll curid=p[i].second;\n\t\tll tmp=p[i].first;\n\t\tll nx=n-2*sz[curid];\n\t\tif(nx<=0)\n\t\t{\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tll pos=lower_bound(p,p+n,make_pair(tmp-nx,0LL))-p;\n\t\tif(p[pos].first!=tmp-nx)\n\t\t{\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tfrom[id]=p[i].second;\n\t\tto[id++]=p[pos].second;\n\t\tsum+=sz[curid]*(n-sz[curid])*2;\n\t\tsz[p[pos].second]+=sz[curid];\n\t}\n\tll ans=0;\n\tfor(ll i=0;i<n;i++)\n\t{\n\t\tans+=dat[i];\n\t}\n\tif(sum!=ans)\n\t{\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tfor(ll i=0;i<id;i++)\n\t{\n\t\tcout<<from[i]+1<<\" \"<<to[i]+1<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 1000000007\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \npair<long,int> D[100000];\nint child[100000];\npair<int,int> ans[99999];\nlong childsum[100000];\nvoid Calc(){\n\tint N = rei();\n\tfor(int i=0;i<N;i++){\n\t\tlong d = rel();\n\t\tD[i] = {d,i};\n\t}\n\tsort(D,D+N);\n\tfor(int i=N-1;i>0;i--){\n\t\tlong c = D[i].first + 2*child[D[i].second] + 2 - N;\n\t\tint bf = 0;\n\t\tint bl = N;\n\t\twhile(bf != bl){\n\t\t\tint bc = (bf+bl)/2;\n\t\t\tif(bc == N || D[bc].first >= c){\n\t\t\t\tbl = bc;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbf = bc+1;\n\t\t\t}\n\t\t}\n\t\tif(D[bf].first == c){\n\t\t\tchild[D[bf].second] += child[D[i].second]+1;\n\t\t\tchildsum[D[bf].second] += childsum[D[i].second]+child[D[i].second]+1;\n\t\t\tans[i] = {D[bf].second,D[i].second};\n\t\t}\n\t\telse{\n\t\t\tcout << -1 << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tif(D[0].first != childsum[D[0].second]){\n\t\tcout << -1 << endl;\n\t\treturn;\n\t}\n\tfor(int i=1;i<N;i++){\n\t\tcout << ans[i].first+1 << \" \" << ans[i].second+1 << endl;\n\t}\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*----------------by syr----------------*/\n/*\n\n         iii                  ii\n     rBQBBBBBBE       BBR iBBBBQBBL     XBBBBBBQBBBBB\n   iBBQJ    7BBB      BBsSBBr   BBQ      i      cBBB\n  rBBU       iBBw     BBBQi     HBBi           KBBi\n  BBH         BB5    iBBB       isL          wBB5\n GBB         iBBi    6BB                   iBBB\n BBQ         BQB     BBD                  QBBi\n BBB        BQB     iQBi                1BBv\n sBBg     wBBB      QBB               iBBB\n  7BBBBBBBBBi       BBR              wBBBBBBBBBBBBB\n     irvi           ii               ii    i i iii\n                i5U\n               BBB\n               BB7\n              1BB\n      iPBBBBBKBBR    JBR1       rQBO   BR  UBQP  iBBQi\n    7BBBGs7sXBBBi     QBBr     gBBE   rBB BB2BB7HBZQBB\n   QBBi      sBQ       BBB   iBBB     SQBBR  BBBB  cBQ\n  gBQ        BBg        BBB KBBi      MBBH   BBB   BBs\n iBBv       iBBi         QBBBL        BBR   pBB   iBB\n pBB        BBB         iBBBB        iBB    BBL   KBB\n MBB       BBBR        BBB JBBi      DBR   iBQ    BBL\n GBB     7BBBB2      PBBH   BBBi     BQr   DBB   iBB\n  BQBXwgBBP BB7    1BBB      BBQ7   1BB    BBc   BBB\n   2BBBBw   BB    EBBS        QBBi  HBa   iBB    BB7\n*/\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define PH push\n#define MP make_pair\n#define PB push_back\n#define fst first\n#define snd second\n#define FOR(i, x, y) for(int i = (x); i < (y); ++i)\n#define REP(i, x, y) for(int i = (x); i <= (y); ++i)\n#define x0 x0123456789\n#define y0 y0123456789\n#define x1 x1234567890\n#define y1 y1234567890\n#define x2 x2345678901\n#define y2 y2345678901\ntypedef double db;\ntypedef long long ll;\ntypedef long double ldb;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int maxn = 1e5 + 5;\nconst ll INF = 1e12 + 7;\n\nint n;\nint par[maxn];\nbool used[maxn];\nll mn = INF;\nll d[maxn], sub[maxn];\nvector<pair<ll, int> > vec;\n\nint main(){\n\tscanf(\"%d\", &n);\n\tFOR(i, 0, n){\n\t\tscanf(\"%lld\", d + i);\n\t\tvec.PB(MP(d[i], i));\n\t\tmn = min(d[i], mn);\n\t}\n\tsort(vec.begin(), vec.end());\n\tFOR(i, 0, n) sub[i] = -INF;\n\tmemset(par, -1, sizeof(par));\n\tfor(int i = vec.size() - 1; i >= 0; --i){\n\t\tint id = vec[i].snd;\n\t\t//printf(\"i = %d id = %d (%d, %d)\\n\", i, id, vec[i].fst, vec[i].snd);\n\t\tif(d[id] == mn)\n\t\t\tbreak;\n\t\tif(sub[id] == -INF) sub[id] = n - 2;\n\t\tint pos = lower_bound(vec.begin(), vec.end(), MP(d[id] - sub[id], -1)) - vec.begin();\n\t\t//printf(\"id = %d %d %d\\n\", id, d[id] - sub[id], pos);\n\t\tif(pos >= i || vec[pos].fst != d[id] - sub[id]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tpar[id] = vec[pos].snd;\n\t\tsub[par[id]] = sub[id] - 2;\n\t}\n\tFOR(i, 0, n) if(d[i] != mn) printf(\"%d %d\\n\", i + 1, par[i] + 1);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nmap<int,int> M1,M2;\nint s1[200010],pa[200010];\nsigned main()\n{\n\tint n=read();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=read();\n\t\tM1[x]=i; M2[x]=1;\n\t\ts1[i]=x;\n\t}\n\tsort(s1+1,s1+1+n);\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tint id=M1[s1[i]],sz=M2[s1[i]],td=s1[i]+2*sz-n;\t\n\t\tif(td==s1[i]) continue;\t\n\t\tpa[id]=M1[td]; M2[td]+=sz;\n\t}\n\tint ze=0;\n\tfor(int i=1;i<=n;i++)\n\t\tze+=(pa[i]==0);\n\tif(ze!=1)\n\t{\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++) if(pa[i])\n\t\tprintf(\"%lld %lld\\n\",i,pa[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef pair<int,pair<int,ll> > pii;\ntypedef vector<int> vi;\n\n#define f first\n#define s second\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for(register int i=0; i<(n); i++)\n#define Forn(i, n) for(register int i=1; i<=(n); i++)\n#define foreach(it, a) for(__typeof((a).begin()) it=(a).begin(); it!=(a).end(); it++)\n#define Foreach(it, a) for(__typeof((a).rbegin()) it=(a).rbegin(); it!=(a).rend(); it++)\n\ninline int in()\n{\n    char c=getchar();\n    int neg=1, x=0;\n    while(!isdigit(c)) (c=='-')?neg=-1, c=getchar():c=getchar();\n    while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48), c=getchar();\n    return neg*x;\n}\ninline int ex_gcd(int a, int b, int&x, int&y, int mod=1e9+7)\n{\n    if(!a)\n    {\n        x=0, y=1;\n        return b;\n    }\n    int d=ex_gcd(b%a, a, y, x);\n    x=(x-1LL*b/a*y%mod)%mod;\n    return d;\n}\ninline int lcm(int a, int b){return a*b/__gcd(a, b);}\n\nconst int MAX=1e5+5;\n\nint N, ptr, sz[MAX];\nll len[MAX], dp[MAX];\nmap<ll,int> rev;\npi ret[MAX];\npair<ll,int> dat[MAX];\n\ninline void die()\n{\n    puts(\"-1\");\n    exit(0);\n}\n\nsigned main()\n{\n    N=in();\n    Forn(i, N)\n    {\n        scanf(\"%I64d\", &len[i]);\n        rev[len[i]]=i;\n        dat[i]=mp(len[i], i);\n        sz[i]=1;\n    }\n    sort(dat+1, dat+1+N);\n    \n    for(int i=N; i>1; i--)\n    {\n        int now=dat[i].s;\n        ll want=dat[i].f-N+2*sz[now];\n        if(want<0) die();\n        if(!rev.count(want)) die();\n        int par=rev[want];\n        sz[par]+=sz[now];\n        dp[par]+=dp[now]+sz[now];\n        ret[ptr++]=mp(min(par, now), max(par, now));\n    }\n    int now=dat[1].s;\n    if(dp[now]!=dat[1].f) die();\n    sort(ret, ret+ptr);\n    forn(i, ptr)\n        printf(\"%d %d\\n\", ret[i].f, ret[i].s);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 100005\n#define rep(i,n) for((i)=0;(i)<(n);(i)++) \n#define LL long long\n#define pii pair<LL,int>\n#define F first\n#define S second\n\nint i;\nint n;\npii d[N];\nmap<LL,int> mp;\nmap<pii,bool> KK;\nbool vis[N];\nint last;\nLL len,now;\n\nint main()\n{\n\t\n\tcin>>n;\n\trep(i,n)\n\t{\n\t\tcin>>d[i].F;\n\t\td[i].S=i;\n\t}\n\tsort(d,d+n);\n\tfor(int j=0,k=n-1;j<k;j++,k--)\n\t\tswap(d[j],d[k]);\n\trep(i,n)\n\t\tmp[d[i].F]=d[i].S;\n\t\n\trep(i,n)\n\t{\n\t\tif(vis[d[i].S]) continue;\n\t\tvis[d[i].S]=1;\n\t\tlast=d[i].S;\n\t\tlen=n;\n\t\tnow=d[i].F;\n\t\twhile(1)\n\t\t{\n\t\t\tlen-=2;\n\t\t\tnow-=len;\n\t\t\tif(mp.find(now)==mp.end()) break;\n\t\t\tif(!KK[make_pair(last+1,mp[now]+1)]) cout<<last+1<<\" \"<<mp[now]+1<<'\\n';\n\t\t\tKK[make_pair(last+1,mp[now]+1)]=1;\n\t\t\tKK[make_pair(mp[now]+1,last+1)]=1;\n\t\t\tlast=mp[now];\n\t\t\tvis[last]=1;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#define N 120000\n#include<map>\nusing namespace std;\nstruct node{\n\tlong long x,id;\n}a[N];\nmap<long long,long long>p;\nlong long n,siz[N],fa[N];\nbool cmp(node x,node y){\n\treturn x.x>y.x;\n}\nint main(){\n\tscanf(\"%lld\",&n);\n\tfor(long long i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i].x);\n\t\ta[i].id=i;\n\t}\n\tsort(a+1,a+1+n,cmp);\n\tfor(long long i=1;i<=n;i++){\n\t\tp[a[i].x]=a[i].id;\n\t}\n\tfor(long long i=1;i<n;i++){\n\t\tlong long x=a[i].id;\n\t\tp[x]=0;\n\t\tsiz[x]++;\n\t\tlong long o=a[i].x+siz[x]-(n-siz[x]);\n\t//\tprlong longf(\"%d %d %d\\n\",a[i].x,o,siz[x]);\n\t\tlong long l=p[o];\n\t\tif(l==0){\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[l]+=siz[x];\n\t\tfa[x]=l;\n\t}\n\tfor(long long i=1;i<=n;i++){\n\t\tif(fa[i]!=0)printf(\"%lld %lld\\n\",i,fa[i]);\n\t}\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,int>P;\n\nint n;\nP d[200000];\nvector<int>E[200000];\nint sz[200000];\nll dp1[200000],dp2[200000];\nvector<pair<int,int>>ans;\n\nvoid dfs1(int v){\n\tfor(int u:E[v]){\n\t\tdfs1(u);\n\t\tdp1[v]+=dp1[u]+sz[u];\n\t}\n}\nvoid dfs2(int v,int p){\n\tif(p==-1)dp2[v]=dp1[v];\n\telse dp2[v]=dp2[p]+n-2*sz[v];\n\tfor(int u:E[v]){\n\t\tans.push_back({v+1,u+1});\n\t\tdfs2(u,v);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%lld\",&d[i].first);\n\t\td[i].second=i;\n\t}\n\trep(i,n)sz[i]=1;\n\tsort(d,d+n);\n\tfor(int i=n-1;i>0;i--){\n\t\tint c=d[i].first-n+2*sz[d[i].second];\n\t\tint id=lower_bound(d,d+n,P(c,0))-d;\n\t\tif(id==n||d[id].first!=c){\n\t\t\t//puts(\"-1\");return 0;\n\t\t}\n\t\tE[d[id].second].push_back(d[i].second);\n\t\tsz[d[id].second]+=sz[d[i].second];\n\t}\n\tdfs1(d[0].second);\n\tdfs2(d[0].second,-1);\n\trep(i,n){\n\t\tif(dp2[d[i].second]!=d[i].first){\n\t\t\t//puts(\"-1\");return 0;\n\t\t}\n\t}\n\tfor(auto p:ans){\n\t\tprintf(\"%d %d\\n\",p.first,p.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define loop(i, n) for(int i = 0;i < int(n);i++)\n#define rloop(i, n) for(int i = int(n);i >= 0;i--)\n#define range(i, a, b) for(int i = int(a);i <= int(b);i++)\n#define SZ(c) int(c.size())\n#define ALL(c) c.begin(), c.end()\n#define RALL(c) c.rbegin(), c.rend()\n#define PI acos(-1)\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n#define sfi1(v) scanf(\"%d\",&v)\n#define sfi2(v1, v2) scanf(\"%d %d\",&v1,&v2)\n#define sfi3(v1, v2, v3) scanf(\"%d %d %d\",&v1,&v2,&v3)\n#define sfll1(v) scanf(\"%I64d\",&v);\n#define sfll2(v1, v2) scanf(\"%I64d %I64d\",&v1,&v2)\n#define sfll3(v1, v2, v3) scanf(\"%I64d %I64d %I64d\",&v1,&v2,&v3)\n#define endl '\\n'\n\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int N = 1e5 + 5;\nint w[N];\nset<pair<ll, int> > s;\nvii ans;\nll D[N];\nint n;\n\n\nint main() {\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.in\", \"r\", stdin);\n    //freopen(\"out.in\", \"w\", stdout);\n#endif\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    cin >> n;\n    range(i, 1, n) {\n        w[i] = 1;\n        cin >> D[i];\n        s.insert({D[i], i});\n    }\n\n    while (SZ(s) > 1) {\n        bool ok = false;\n        auto it = prev(s.end());\n        ll have = it->fr;\n        int idx = it->sc;\n        ll need = have - (n - 2 * w[idx]);\n        auto c = s.lower_bound({need, -1});\n        if (c == s.end() || it == c || c->fr != need) {\n            cout << -1 << endl;\n            return 0;\n        }\n        w[c->sc] += w[idx];\n        ans.push_back({idx, c->sc});\n        s.erase(it);\n    }\n\n\n    for (auto edge: ans)cout << edge.fr << \" \" << edge.sc << endl;\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<math.h>\n#include<stdlib.h>\n#include<set>\n#include<bitset>\n#include<map>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<complex>\n#include<list>\n#include<limits.h>\nusing namespace std;\n\nconst int N=1e5+5;\ntypedef pair<int,int> pii;\nint n;\npair<long long,int> a[N];\nint d[N];\nvector<pii> vp;\nmap<long long,int> mp;\n\nvoid lnk(int x,int y){\n\tvp.push_back(make_pair(x,y));\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%I64d\",&a[i].first);\n\t\ta[i].second=i;\n\t}\n\tsort(a+1,a+1+n);\n\treverse(a+1,a+1+n);\n\tfor(int i=1;i<=n;i++) mp[a[i].first]=i;\n\tfor(int i=1;i<=n;i++){\n\t\td[i]=n-2;\n//\t\tprintf(\"%d %d\\n\",i,d[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(d[i]<0) continue;\n//\t\tprintf(\"%d:%I64d %d\\n\",i,a[i].first,d[i]);\n\t\tint nxt=mp[a[i].first-1ll*d[i]];\n\t\td[nxt]=d[i]-2;\n\t\tlnk(a[i].second,a[nxt].second);\n\t}\n\tif(vp.size()!=n-1) puts(\"-1\");\n\telse for(int i=0;i<vp.size();i++) printf(\"%d %d\\n\",vp[i].first,vp[i].second);\n\treturn 0;\n}\n\n/*\n数据不清空，爆零两行泪\n读题不认真，爆零两行泪\n分析不仔细，爆零两行泪\n建树不构造，爆零两行泪\n变量不统一，爆零两行泪\n边界不算清，爆零两行泪\n数组不开大，爆零两行泪\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\t\nusing namespace std;\nconst int MAX_N=1e5;\nconst ll INF=1e18;\nint N;\nll D[MAX_N];\n\nmap<ll,int> dmp;\nint par[MAX_N],chl[MAX_N];\nvector<int> G[MAX_N];\nll dist[MAX_N];\nint main(){\n\tcin>>N;\n\tREP(i,N)cin>>D[i];\n\tREP(i,N){\n\t\tdmp[D[i]]=i;\n\t}\n\tREP(i,N){\n\t\tpar[i]=-1;\n\t\tchl[i]=1;\n\t}\n\tbool flg=true;\n\t{\n\t\tauto ite=dmp.end();\n\t\tite--;\n\t\tfor(;;ite--){\n\t\t\tif (ite==dmp.begin()){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n//\t\t\tcout<<ite->second<<endl;\n\t\t\tll pd=ite->first-N+chl[ite->second]*2;\n\t\t\tif (pd>=ite->first || dmp.find(pd)==dmp.end()){\n\t\t\t\tflg=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint pr=dmp[pd];\n\t\t\tpar[ite->second]=pr;\n\t\t\tchl[pr]+=chl[ite->second];\n\t\t}\n\t}\n\tif (flg){\n\t\tcout<<\"debug\"<<endl;\n\t\tint rot;\n\t\tREP(i,N){\n\t\t\tif (par[i]==-1){\n\t\t\t\trot=i;\n\t\t\t}else{\n\t\t\t\tG[i].push_back(par[i]);\n\t\t\t\tG[par[i]].push_back(i);\n\t\t\t}\n\t\t}\n\t\tqueue<int > que;\n\t\tREP(i,N){\n\t\t\tdist[i]=INF;\n\t\t}\n\t\tque.push(rot);\n\t\tdist[rot]=0;\n\t\twhile(!que.empty()){\n\t\t\tint v=que.front();\n\t\t\tque.pop();\n\t\t\tfor(auto e:G[v]){\n\t\t\t\tif (dist[e]==INF){\n\t\t\t\t\tdist[e]=dist[v]+1;\n\t\t\t\t\tque.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll sm=0;\n\t\tREP(i,N)sm+=dist[i];\n\t\tif (sm!=D[rot]){\n\t\t\tflg=false;\n\t\t}\n\t}\n\tif (flg){\n\t\tREP(i,N){\n\t\t\tif (par[i]!=-1){\n\t\t\t\tcout<<i+1<<\" \"<<par[i]+1<<endl;\n\t\t\t}\n\t\t}\n\t}else{\n\t\tcout<<-1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define loop(i, n) for(int i = 0;i < int(n);i++)\n#define rloop(i, n) for(int i = int(n);i >= 0;i--)\n#define range(i, a, b) for(int i = int(a);i <= int(b);i++)\n#define SZ(c) int(c.size())\n#define ALL(c) c.begin(), c.end()\n#define RALL(c) c.rbegin(), c.rend()\n#define PI acos(-1)\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n#define sfi1(v) scanf(\"%d\",&v)\n#define sfi2(v1, v2) scanf(\"%d %d\",&v1,&v2)\n#define sfi3(v1, v2, v3) scanf(\"%d %d %d\",&v1,&v2,&v3)\n#define sfll1(v) scanf(\"%I64d\",&v);\n#define sfll2(v1, v2) scanf(\"%I64d %I64d\",&v1,&v2)\n#define sfll3(v1, v2, v3) scanf(\"%I64d %I64d %I64d\",&v1,&v2,&v3)\n#define endl '\\n'\n\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int N = 1e5 + 5;\nvi adj[N];\nint w[N];\nset<pair<ll, int> > s;\nvii ans;\nll D[N];\nint n;\n\nll sum;\n\nvoid dfs(int u, int par, int lvl) {\n    sum += lvl;\n    for (int nxt : adj[u]) {\n        if (nxt == par)continue;\n        dfs(nxt, u, lvl + 1);\n    }\n}\n\n\nint main() {\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.in\", \"r\", stdin);\n    //freopen(\"out.in\", \"w\", stdout);\n#endif\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    cin >> n;\n    range(i, 1, n) {\n        w[i] = 1;\n        cin >> D[i];\n        D[i] += 5;\n        s.insert({D[i], i});\n    }\n\n    while (SZ(s) > 1) {\n        auto it = prev(s.end());\n        ll have = it->fr;\n        int idx = it->sc;\n        ll need = have - (n - 2 * w[idx]);\n        auto c = s.lower_bound({need, -1});\n        if (c == s.end() || it == c || c->fr != need) {\n            cout << -1 << endl;\n            return 0;\n        }\n        w[c->sc] += w[idx];\n        ans.push_back({idx, c->sc});\n        s.erase(it);\n    }\n\n    for (auto edge : ans) {\n        adj[edge.fr].push_back(edge.sc);\n        adj[edge.sc].push_back(edge.fr);\n    }\n\n    dfs(s.begin()->sc, -1, 0);\n    if (sum != s.begin()->fr) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    for (auto edge: ans)cout << edge.fr << \" \" << edge.sc << endl;\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n\nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nint modpow(int a, long long n, int mod = MOD) { int ret = 1; do { if (n & 1) ret = 1LL * ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\n// counterclockwise from 12 o'clock direction\ntemplate<typename T> bool CompareBySlope(pair<T, T> a, pair<T, T> b) { if (a.first * b.first < 0) return a.first < b.first; if (a.first == 0) return a.second >= 0 || b.first > 0; if (b.first == 0) return b.second < 0 && a.first < 0; return a.second * b.first < a.first * b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\nvoid solve() {\n  int n; cin >> n;\n  vector<pair<ll, int>> g(n);\n  rep(i,n) {\n    cin >> g[i].first;\n    g[i].second = i;\n  }\n  sort(ALL(g));\n\n  vi cnt(n);\n  vector<pii> ans; ans.reserve(n-1);\n\n  rrep1(i,n) {\n    ll d; int idx;\n    tie(d, idx) = g[i];\n\n    ll nd = d - (n-2) + 2*cnt[idx];\n    auto itr = lower_bound(ALL(g), make_pair(nd, 0));\n\n    if (itr->first != nd || nd >= d) {\n      cout << -1 << endl;\n      return;\n    }\n\n    int nidx = itr->second;\n    cnt[nidx] += cnt[idx] + 1;\n    ans.emplace_back(idx+1, nidx+1);\n  }\n\n  cout << ans << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(12);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  \n  int n;\n  cin >> n;\n  vector<long long> d(n);\n  for (int i = 0; i < n; i++) {\n    cin >> d[i];\n  }\n\n  vector<int> ord(n);\n  iota(ord.begin(), ord.end(), 0);\n  sort(ord.begin(), ord.end(), [&](int i, int j) { return d[i] > d[j]; });\n  ord.pop_back();\n\n  map<long long, int> mp;\n  for (int i = 0; i < n; i++) {\n    mp[d[i]] = i;\n  }\n  vector<int> sz(n, 1), par(n, -1);\n\n  for (auto i : ord) {\n    long long par_d = d[i] + sz[i] - (n - sz[i]);\n    if (mp.count(par_d) == 0 || mp[par_d] == i) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n    par[i] = mp[par_d];\n    sz[par[i]] += sz[i];\n  }\n\n  for (int i = 0; i < n; i++) {\n    if (par[i] != -1) {\n      cout << i + 1 << ' ' << par[i] + 1 << '\\n';\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#include <queue>\n#include <vector>\n#define PB push_back\n#define MP make_pair\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=1e5+10;\nstruct node {\n\tint id; ll d;\n\tnode(int id=0,ll d=0): id(id),d(d) {}\n\tfriend bool operator <(node A,node B) { return A.d<B.d; }\n};\npriority_queue<node> que;\nmap<ll,int> mp;\nint n,sz[N];\nll d[N];\nvector< pair<int,int> > E;\nint main() {\n\trd(n);\n\tfor(int i=1;i<=n;++i) {\n\t\trd(d[i]),mp[d[i]]=i;\n\t\tque.push(node(i,d[i]));\n\t\tsz[i]=1;\n\t}\n\twhile(que.size()>1) {\n\t\tint u=que.top().id; que.pop();\n\t\tmp.erase(u);\n\t\tll t=d[u]-(n-sz[u]*2ll);\n\t\tif(!mp.count(t)) {\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint f=mp[t];\n\t\tE.PB(MP(f,u));\n\t\tsz[f]+=sz[u];\n\t}\n\tfor(int i=0;i<E.size();++i) printf(\"%d %d\\n\",E[i].first,E[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N;\nint D[111111];\n\nint w[111111];\nint d[111111];\nsigned main(){\n    cin>>N;\n    map<int,int>uku;\n    rep(i,N){\n        cin>>D[i];\n        uku[D[i]]=i;\n    }\n\n    fill_n(w,N,1);\n    vpint lis;\n    rep(i,N)lis.pb({D[i],i});\n    sort(all(lis));reverse(all(lis));\n\n    vpint ans;\n    rep(i,N-1){\n        int v=lis[i].se;\n\n        int tmp=N-w[v];\n        int fo=D[v]+w[v]-tmp;\n        if(fo>=D[v]||uku.find(fo)==uku.end()){\n            cout<<-1<<endl;\n            return 0;\n        }\n        ans.pb({v,uku[fo]});\n        w[uku[fo]]+=w[v];\n        d[uku[fo]]+=d[v]+w[v];\n    }\n\n    int r=lis.back().se;\n    if(D[r]!=d[r]){\n        cout<<-1<<endl;\n        return 0;\n    }\n\n    rep(i,ans.size())cout<<ans[i].fi+1<<\" \"<<ans[i].se+1<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100005\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate <class T> inline void read(T &x) {\n\tchar ch; bool flag = false;\n\twhile (!isdigit(ch = getchar())) flag |= ch == '-';\n\tfor (x = ch ^ 48; isdigit(ch = getchar()); x = x * 10 + (ch ^ 48));\n\tif (flag) x = -x;\n}\n\ninline int input() {\n\tint x; char ch; bool flag = false;\n\twhile (!isdigit(ch = getchar())) flag |= ch == '-';\n\tfor (x = ch ^ 48; isdigit(ch = getchar()); x = x * 10 + (ch ^ 48));\n\treturn flag ? -x : x;\n}\n\nconst int mod = 1e9 + 7;\ninline int add(int x, int y) { x += y; return x >= mod ? x - mod : x; }\ninline void inc(int &x, int y) { x += y; x -= x >= mod ? mod : 0; }\n\ninline int Power(int x, int y) {\n\tint res = 1;\n\twhile (y) {\n\t\tif (y & 1) res = (ll) res * x % mod;\n\t\tx = (ll) x * x % mod, y >>= 1;\n\t} return res;\n}\n\ntemplate <class T> void chkmax(T &x, T y) { x = x > y ? x : y; }\ntemplate <class T> void chkmin(T &x, T y) { x = x < y ? x : y; }\ntemplate <class T> T gcd(T x, T y) { return !y ? x : gcd(x % y, y); }\n\nll n;\nll d[N];\nll size[N], fa[N];\nmap<ll, ll> mp;\n\t\nvoid FAIL() {\n\tputs(\"-1\");\n\texit(0);\n}\n\nll id(ll x) { return mp[d[x]]; }\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor (ll i = 1; i <= n; ++i) size[i] = 1;\n\tfor (ll i = 1; i <= n; ++i) {\n\t\tcin >> d[i], mp[d[i]] = i;\n\t\tif (d[i] > (ll) n * (n - 1) / 2) FAIL();\n\t}\n\tsort(d + 1, d + n + 1);\n\n\tfor (ll i = n; i > 1; --i) {\n\t\tll vf = d[i] - n + size[i] + size[i];\n\t\tif (vf >= d[i]) FAIL();\n\t\tfa[i] = lower_bound(d + 1, d + n + 1, vf) - d;\n\t\tif (d[fa[i]] != vf) FAIL();\n\t\tsize[fa[i]] += size[i];\n\t}\n\n\tfor (int i = 2; i <= n; ++i)\n\t\tprintf(\"%lld %lld\\n\", id(i), id(fa[i]));\n\treturn 0;\n}\n\t\t\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5 + 5;\nint n;\nlong long d[N];\npriority_queue <pair <int, int> > pq;\nint siz[N];\nint fa[N];\nmap <long long, set <int> > mp;\n\n#define NO() return puts(\"-1\"), 0\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++ i)\n\t\tscanf(\"%lld\", &d[i]), mp[d[i]].insert(i),\n\t\tsiz[i] = 1, pq.push(make_pair(d[i], i));\n\twhile (!pq.empty()) {\n\t\tint u = pq.top().second;\n\t\tpq.pop(); mp[d[u]].erase(u);\n\t\tif (!pq.empty()) {\n\t\t\tlong long fa_d = (d[u] - (n - 2 * siz[u]));\n//\t\t\tprintf(\"%d %lld %lld\\n\", u + 1, d[u], fa_d);\n\t\t\tif (!mp[fa_d].size()) NO();\n\t\t\tint v = *mp[fa_d].begin();\n\t\t\tfa[u] = v;\n\t\t\tsiz[v] += siz[u];\n\t\t} else fa[u] = -1;\n\t}\n\tfor (int i = 0; i < n; ++ i)\n\t\tif (~fa[i]) printf(\"%d %d\\n\", fa[i] + 1, i + 1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#define N 350000\n#include<map>\nusing namespace std;\nstruct node{\n\tlong long x,id;\n}a[N];\nmap<long long,long long>p;\nlong long n,siz[N],fa[N],ans;\nint tot,Next[N],v[N],h[N];\nint add(int x,int y){\n\ttot++;\n\tNext[tot]=h[x];\n\tv[tot]=y;\n\th[x]=tot;\n}\nlong long dfs(int x,int fa){\n\tsiz[x]=1;\n\tfor(int i=h[x];i;i=Next[i]){\n\t\tif(v[i]==fa)continue;\n\t\tdfs(v[i],x);\n\t\tans+=siz[v[i]];\n\t\tsiz[x]+=siz[v[i]];\n\t}\n\treturn ans;\n}\nbool cmp(node x,node y){\n\treturn x.x>y.x;\n}\nint main(){\n\tscanf(\"%lld\",&n);\n\tfor(long long i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i].x);\n\t\ta[i].id=i;\n\t}\n\tsort(a+1,a+1+n,cmp);\n\tfor(long long i=1;i<=n;i++){\n\t\tp[a[i].x]=a[i].id;\n\t}\n\tfor(long long i=1;i<n;i++){\n\t\tlong long x=a[i].id;\n\t\tp[a[i].x]=0;\n\t\tsiz[x]++;\n\t\tlong long o=a[i].x+siz[x]-(n-siz[x]);\n\t//\tprlong longf(\"%d %d %d\\n\",a[i].x,o,siz[x]);\n\t\tlong long l=p[o];\n\t\tif(l==0){\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[l]+=siz[x];\n\t\tfa[x]=l;\n\t\tadd(l,x);\n\t\tadd(x,l);\n\t}\n\tfa[a[n].id]=0;\n\tmemset(siz,0,sizeof(siz));\n\tif(dfs(a[1].id,0)!=a[1].x){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(long long i=1;i<=n;i++){\n\t\tif(fa[i]!=0)printf(\"%lld %lld\\n\",i,fa[i]);\n\t}\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MAX 100002\n\nint n;\n\nvector<long long int> d;\nvector<int> v[MAX];\n\nmap<long long int,int> mp;\n\nint sz[MAX];\n\nbool vis[MAX];\n\nlong long int dp[MAX];\nint cnt[MAX];\n\ninline void dfs(int b,int pr=-1){\n\tcnt[b]++;\n\tvis[b]=true;\n\tfor(int go:v[b]){\n\t\tif(go==pr)continue;\n\t\tif(vis[go]){\n\t\t\tputs(\"-1\");\n\t\t\texit(0);\n\t\t}\n\t\tdfs(go,b);\n\t\tdp[b]+=dp[go]+cnt[go];\n\t\tcnt[b]+=cnt[go];\n\t}\n}\nlong long int ans[MAX];\n\ninline void dfs2(int b,int pr=-1,long long int weight=0){\n\tans[b]=dp[b]+weight;\n\tweight+=dp[b];\n\tfor(int go:v[b]){\n\t\tif(go==pr)continue;\n\t\tdfs2(go,b,weight-dp[go]-cnt[go]+(n-cnt[go]));\n\t}\n}\nvector<pair<int,int> > ed;\nint main() {\n\t// your code goes here\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tlong long int a;\n\t\tscanf(\"%lld\",&a);\n\t\td.push_back(a);\n\t\tmp[a]=i;\n\t}\n\tfor(auto it=mp.rbegin();it!=mp.rend();it++){\n\t\tint node=(*it).second;\n\t\tlong long int val=(*it).first;\n\t\tsz[node]++;\n\t\tlong long int op=n-sz[node];\n\t\tif(op==0)continue;\n\t\tlong long int nex=val+sz[node]-op;\n\t\tif(mp.count(nex)){\n\t\t\tint ne=mp[nex];\n\t\t\tsz[ne]+=sz[node];\n\t\t\tv[ne].push_back(node);\n\t\t\tv[node].push_back(ne);\n\t\t\tif(ne>node)swap(ne,node);\n\t\t\ted.push_back(make_pair(ne+1,node+1));\n\t\t}\n\t}\n\tdfs(0);\n\tdfs2(0);\n\tfor(int i=0;i<n;i++){\n\t\tif(vis[i]==false){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tif(ans[i]!=d[i]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=0;i<ed.size();i++){\n\t\tprintf(\"%d %d\\n\",ed[i].first,ed[i].second);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n    > File Name: D.cpp\n    > Author: PumpkinYing\n    > Created Time: 2018/11/9 15:51:37\n ************************************************************************/\n\n#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <stack>\n#include <cmath>\nusing namespace std;\n\n#define mem(a,b) memset(a,b,sizeof(a))\n#define prii pair<int,int>\n#define prdd pair<double,double>\n#define rep(i,l,r) for(int i = l;i < r;i++)\n#define rep_(i,l,r) for(int i = l;i <= r;i++)\ntypedef long long ll;\n\nconst int maxn = 1000010;\nmap<ll,int> mp;\nint sz[maxn];\n\nstruct Node {\n\tll d;\n\tint id;\n\tvoid read(int i) {\n\t\tid = i;\n\t\tscanf(\"%lld\",&d);\n\t}\n\tbool operator < (const Node& b) const {\n\t\treturn d > b.d;\n\t}\n}ns[maxn];\n\nint fa[maxn],vis[maxn];\n\nint main() {\n\tint n;\n\tscanf(\"%d\",&n);\n\trep_(i,1,n) {\n\t\tns[i].read(i);\n\t\tmp[ns[i].d] = i;\n\t\tsz[i] = 1;\n\t}\n\tsort(ns+1,ns+1+n);\n\tint ok = 1;\n\trep_(i,1,n-1) {\n\t\tint id = ns[i].id;\n\t\tvis[id] = 1;\n\t\tll val = ns[i].d+sz[id]-(n-sz[id]);\n\t\tif(mp[val] == 0 || vis[mp[val]]) {\n\t\t\tok = 0;\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tfa[id] = mp[val];\n\t\t\tsz[mp[val]] += sz[id];\n\t\t}\n\t}\n\t/*\n\tif(ok == 0) printf(\"-1\\n\");\n\telse rep_(i,1,n) if(fa[i] != 0) printf(\"%d %d\\n\",i,fa[i]);\n\t*/\n\tprintf(\"-1\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=100005;\nint n,size[N],st[N],to[N<<1],tto[N],last[N],Next[N<<1],edge;\nlong long D;\nstruct note{\n\tlong long dis;\n\tint x;\n}d[N];\nbool cmp(note x,note y){\n\treturn x.dis>y.dis;\n}\nusing std::map;\nmap<long long,int> m;\nvoid add(int x,int y){\n\tto[++edge]=y;\n\tNext[edge]=last[x];\n\tlast[x]=edge;\n}\nint dfs(int x,int fa,long long now){\n\tprintf(\"%d %lld\\n\",x,now);\n\tD+=now;\n\tfor (int i=last[x];i;i=Next[i])\n\t\tif (to[i]!=fa)\n\t\t\tdfs(to[i],x,now+1);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) {\n\t\tscanf(\"%lld\",&d[i].dis);\n\t\td[i].x=i;\n\t\tm[d[i].dis]=i;\n\t}\n\tstd::sort(d+1,d+n+1,cmp);\n\tfor (int i=1;i<=n;i++) size[i]=1;\n\tfor (int i=1;i<n;i++){\n\t\tlong long dis=d[i].dis;\n\t\tint x=d[i].x;\n\t\tlong long t=dis-abs(n-2*size[x]);\n\t\tint fa=m.find(t)->second;\n\t\tif (fa==x || !fa){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsize[fa]+=size[x];\n\t\tst[i]=x,tto[i]=fa;\n\t\tadd(x,fa),add(fa,x);\n\t}\n\tdfs(d[n].x,0,0);\n\tif (D!=d[n].dis){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++) printf(\"%d %d\\n\",st[i],tto[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\n\n\n\n    \nint main(){\n    ll n;\n    cin>>n;\n    vector<ll> a(n);\n    map<ll,ll> M;\n    for(int i=0;i<n;i++){\n        cin>>a[i];\n        M[a[i]]=i+1;\n    }\n    sort(a.begin(),a.end(),greater<ll>());\n    vector<ll> parent(n,-1);\n    vector<ll> count(n,1);\n    vector<ll> cost(n,0);\n    for(int i=0;i+1<n;i++){\n        //if(cost[i]!=a[i]){cout<<-1<<endl; return 0;}\n        ll to=a[i]-n+count[i]*2;\n        ll I=lower_bound(a.begin(),a.end(),to)-a.begin();\n        if(a[I]!=to){cout<<-1<<endl; return 0;}\n        count[I]+=count[i];\n        cost[I]+=cost[i]+count[i];\n        parent[i]=I;\n    }\n    if(cost[n-1]!=a[n-1]){cout<<-1<<endl; return 0;}\n    for(int i=0;i<n-1;i++){\n        cout<<M[a[i]]<<\" \"<<M[a[parent[i]]]<<endl;\n    }\n    \n    \n        \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\nmap<long long,int> id;\nint size[100005];\nvector<pair<int,int> >e;\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tint D;\n\t\tscanf(\"%d\",&D);\n\t\tid[D]=i;\n\t}\n\tfor(int i=1;i<=n;i++)size[i]=1;\n\tfor(int j=1;j<n;j++){\n\t\tlong long d=id.rbegin()->first;\n\t\tint x=id.rbegin()->second;\n\t\tid.erase(d);\n\t\td-=n-2*size[x];\n\t\tif(!id.count(d)){puts(\"-1\"); return 0;}\n\t\te.push_back(make_pair(id[d],x));\n\t\tsize[id[d]]+=size[x];\n\t}\n\tfor(int i=0;i<e.size();i++)printf(\"%d %d\\n\",e[i].first,e[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int N=1e5+10;\nstruct Data{\n\tint id;\n\tll val;\n\tData(){}\n\tData(int id1,ll val1){id=id1; val=val1;}\n\tfriend bool operator < (Data x,Data y){return x.val<y.val;}\n}d[N];\nll sz[N];\nll fa[N];\nint n,m;\nbool solve(){\n\tint pre;\n\tsort(d+1,d+1+n);\n\tfor (int i=1;i<=n;++i) sz[i]=1;\n\tfor (int i=n;i>=2;--i){\n\t\tpre=lower_bound(d+1,d+1+n,Data(0,d[i].val-n+2*sz[i]))-d;\n\t\tif (pre==-1||d[pre].val!=d[i].val-n+2*sz[i]||pre==i) return false;\n\t\tfa[i]=pre; \n\t\tsz[fa[i]]+=sz[i];\n\t}\n\treturn true;\n}\n\nint main(){\n#ifndef ONLINE_JUDGE\n\t//freopen(\"a.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;++i) scanf(\"%lld\",&d[i].val),d[i].id=i;\n\tif (solve()){\n\t\tfor (int i=2;i<=n;++i) cout<<d[fa[i]].id<<\" \"<<d[i].id<<endl;\n\t}\n\telse\n\t\tprintf(\"-1\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid ensure(bool exp) {\n    if (!exp) {\n        cout << -1 << endl;\n        exit(0);\n    }\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<long long> d(n);\n    map<long long, int> ver;\n    for (int i = 0; i < n; ++i) {\n        cin >> d[i];\n        ver[d[i]] = i;\n    }\n    vector<int> p(n);\n    iota(p.begin(), p.end(), 0);\n    sort(p.begin(), p.end(), [&](int i, int j) {\n        return d[i] < d[j];\n    });\n    vector<int> sz(n, 1), parent(n, -1);\n    vector<long long> f(n);\n    for (int i = n - 1; i >= 1; --i) {\n        int u = p[i];\n        long long dp = d[u] - n + 2 * sz[u];\n        ensure(dp < d[u]);\n        ensure(ver.count(dp) > 0);\n        parent[u] = ver[dp];\n        sz[parent[u]] += sz[u];\n        f[parent[u]] += f[u] + sz[u];\n    }\n    ensure(f[p[0]] == d[p[0]]);\n    for (int i = 1; i < n; ++i)\n        cout << parent[p[i]] + 1 << \" \" << p[i] + 1 << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define eb emplace_back\n#define mt make_tuple\n#define all(x) (x).begin(), (x).end() \n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair <int, int> ii;\ntypedef pair <ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef long double ld;\n\nconst ll INF=LLONG_MAX;\nconst int mxn=1e5+5;\nll sz[mxn],dis[mxn];\nvi adj[mxn];\nbool vis[mxn];\n\nvoid dfs(int u, int p=-1){\n\tfor(int v:adj[u])\n\t\tif(v!=p)dis[v]=dis[u]+1,dfs(v,u);\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    //freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout);\n\tint n;\n\tcin >> n;\n\tpair<ll,int> dist[n];\n\tmap<ll,int>mp;\n\tfor(int i=0; i<n; i++){\n\t\tcin >> dist[i].fi;\n\t\tdist[i].se=i;\n\t\tsz[i]=1LL;\n\t\tmp[dist[i].fi]=i;\n\t}\n\tmap<ii,bool>edge;\n\tsort(dist,dist+n);\n\tfor(int i=n-1; i>0; i--){\n\t\tint ind = dist[i].se;\n\t\tll next = dist[i].fi-n+2*sz[ind];\n\t\tif(mp.find(next)==mp.end()){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint ptr = mp[next];\n\t\tif(ptr==ind){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsz[ptr] += sz[ind];\n\t\tif(ptr>ind)swap(ind,ptr);\n\t\tedge[ii(ptr,ind)]=1;\n\t\tadj[ind].eb(ptr);\n\t\tadj[ptr].eb(ind);\n\t\tvis[ind]=1; vis[ptr]=1;\n\t}\n\tbool ok=0;\n\tfor(int i=0; i<n&&!ok; i++)\n\t\tif(sz[i]==n)ok=1;\n\tfor(int i=0; i<n; i++)\n\t\tif(!vis[i])ok=0;\n\tdfs(dist[0].se);a\n\tint sum = 0;\n\tfor(int i=0; i<n; i++)sum+=dis[i];\n\tif(sum!=dist[0].fi)ok=0;\n\tif(!ok)cout << -1 << endl;\n\telse{\n\t\tfor(auto x:edge)\n\t\t\tcout << x.fi.fi+1 << ' ' << x.fi.se+1 << endl;\n\t}\n}\n\t\n// READ & UNDERSTAND\n// ll, int overflow, array bounds, memset(0)\n// special cases (n=1?), n+1 (1-index)\n// do smth instead of nothing & stay organized\n// WRITE STUFF DOWN\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e5 + 10;\n\nint D[N],id[N],Sz[N];\nstruct node {\n\tint x,y;\n}G[N];\nmap <ll,int> Map,Id;\n\ninline ll read() {\n\tll x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-')ch = getchar();\n\tif(ch == '-')flag = -1,ch = getchar();\n\twhile(isdigit(ch))x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\nint main() {\n\n\tint n = read();\n\tFor(i,1,n) Map[D[i] = read()] = i,Sz[i] = 1;\n\tsort(D + 1,D + n + 1,greater<int>());\n\tFor(i,1,n) Id[D[i]] = i;\n\n\tFor(i,1,n - 1) {\n\t\tint Pre = D[i] + Sz[i] * 2 - n,val = Id[Pre];\n\t\tif(val <= i) return puts(\"-1\"),0;\n\t\tSz[val] += Sz[i];\n\t\tG[i] = (node){Map[D[i]],Map[D[val]]};\n\t}\n\n\tFor(i,1,n - 1) printf(\"%d %d\\n\",G[i].x,G[i].y);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#include<map>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=100000 +117;\nconst int MM=100000 +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint m,n;\nLL a[NN]={};\nint ord[NN]={};\nint siz[NN]={};\nmap<LL,int> ind;\nint fa[NN]={};\nbool cmp(int x,int y){\n\treturn a[x]>a[y];\n}\nint main(){\n\t//open();\n\tn=read();\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%lld\",&a[i]);\n\t\tord[i]=i;\n\t\tind[a[i]]=i;\n\t}\n\tsort(ord+1,ord+1+n,cmp);\n\tbool fl=0;\n\tfor(int i=1;i<n;++i){\n\t\tint x=ord[i];\n\t\tsiz[x]+=1;\n\t\tLL xt=a[x]-n+2*siz[x];\n\t\tint tp=ind[xt];\n\t\tif(!tp){\n\t\t\tfl=1;\n\t\t}\n\t\telse{\n\t\t\tfa[x]=tp;\n\t\t\tsiz[tp]+=siz[x];\n\t\t}\n\t}\n\tif(fl){\n\t\tprintf(\"-1\\n\");\n\t}\n\telse{\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tif(fa[i]){\n\t\t\t\tprintf(\"%d %d\\n\",i,fa[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Copyright(c)2018 Mstdream\n#include<bits/stdc++.h>\n#define LL long long\nusing namespace std;\nconst int N=100010;\nint siz[N],n,tot,vis[N],dep[N];\nmap<LL,int>f;\nstruct Q{\n\tLL v;int id;\n\tbool operator<(const Q&x)const{\n\t\treturn v>x.v;\n\t}\n}q[N];\nvector<int>g[N];\nvector<pair<int,int> >ans;\nbool flag=1;\nvoid dfs(int x){\n\ttot++;vis[x]=1;\n\tfor(auto v:g[x]){\n\t\tif(vis[v])flag=0;\n\t\telse dep[v]=dep[x]+1,dfs(v);\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&q[i].v);\n\t\tf[q[i].v]=i;\n\t\tq[i].id=i;\n\t\tsiz[i]=1;\n\t}\n\tsort(q+1,q+n+1);\n\tfor(int i=1;i<n;i++){\n\t\tLL d=q[i].v+2*siz[q[i].id]-n;\n\t\tint fa=f[d];\n\t\tif(!fa)cout<<\"-1\"<<endl,exit(0);\n\t\tsiz[fa]+=siz[q[i].id];\n\t\tans.push_back(make_pair(q[i].id,fa));\n\t\tg[fa].push_back(q[i].id);\n\t}\n\tdfs(q[n].id);\n\tfor(int i=1;i<=n;i++)q[n].v-=dep[i];\n\tif(tot==n&&flag&&!q[n].v){\n\t\tfor(auto x:ans){\n\t\t\tprintf(\"%d %d\\n\",x.first,x.second);\n\t\t}\n\t}\n\telse puts(\"-1\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimiz(O2)\n\n#include <bits/stdc++.h>\n\n#define rg register\nusing namespace std;\ntypedef long long ll;\n\ntemplate<typename T>\ninline bool read(T &n) {\n    T ans = 0, flag = 1;\n    char ch;\n    while ((ch = getchar()) < '0' || ch > '9') if (ch == '-') flag = -1; else if (ch == EOF) return false;\n    ans = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9') ans = ans * 10 + ch - '0';\n    n = ans * flag;\n    return true;\n}\n\ninline ll read() {\n    ll ans = 0, flag = 1;\n    char ch;\n    while ((ch = getchar()) < '0' || ch > '9') if (ch == '-') flag = -1;\n    ans = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9') ans = ans * 10 + ch - '0';\n    return ans * flag;\n};\nconst int maxn = 100005;\nstruct NODE {\n    ll val, ord;\n    bool operator<(NODE b) const {\n        return val < b.val;\n    }\n} node[maxn];\nint siz[maxn],fa[maxn];\nunordered_map<ll,int> unM;\nint main() {\n    int n;\n    read(n);priority_queue<NODE> pq;\n    for (rg int i = 1; i <= n; ++i) {\n        siz[i] = 1;read(node[i].val);\n        node[i].ord = i;\n        pq.push(node[i]);\n        unM[node[i].val]=i;\n    }\n    for(rg int i=n;i>=2;i--){\n        NODE now=pq.top();pq.pop();\n        if(unM.find(now.val+2*siz[now.ord]-n)==unM.end()){\n            puts(\"-1\");return 0;\n        }\n        fa[now.ord]=unM[now.val+2*siz[now.ord]-n];\n        siz[fa[now.ord]]+=siz[now.ord];\n    }\n    if(siz[pq.top().ord]!=n) puts(\"-1\");\n    else \n    for(rg int i=1;i<=n;i++){\n        if(fa[i]) cout<<i<<' '<<fa[i]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#include <cmath>\n#include <complex>\n// #include \"utiltime.hpp\"\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef complex<double> cdouble;\n\nconst int INFL = (int)1e9;\nconst ll INFLL = (ll)1e18;\nconst double INFD = numeric_limits<double>::infinity();\nconst double PI = 3.14159265358979323846;\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loopll(i, n) for(ll i = 0; i < (ll)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopll1(i, n) for(ll i = 1; i <= (ll)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = (ll)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define Looprll1(i, n) for(ll i = (ll)n; i >= 1; i--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(i, vector.size()) { cout << vector[i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(i, matrix.size()) { Loop(j, matrix[i].size()) { cout << matrix[i][j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define readfile(filename) ifstream in(filename); cin.rdbuf(in.rdbuf());\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\nbool nearlyeq(double x, double y) { return abs(x - y) < 1e6; }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(double x) { ll m = (ll)sqrt(x); return m + (m * m <= (ll)(x) ? 0 : -1); }\nll ceilsqrt(double x) { ll m = (ll)sqrt(x); return m + ((ll)x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\n\n/*******************************************************/\n\nvoid failed() {\n\tcout << -1 << endl;\n\texit(0);\n}\n\nint main() {\n\tint n; cin >> n;\n\tvector<Pll> a(n);\n\tLoop(i, n) {\n\t\tcin >> a[i].first;\n\t\ta[i].second = i;\n\t}\n\tsort(a.begin(), a.end());\n\tvll subtree_cnt(n, 0);\n\tvll d(n, 0);\n\tvector<Pll> ans;\n\tLoopr1(i, n - 1) {\n\t\tll target_val = a[i].first + subtree_cnt[i] * 2 - (ll)n + 2;\n\t\tauto itr = lower_bound(a.begin(), a.end(), Pll({ target_val, 0LL }));\n\t\tif (itr == a.end()) failed();\n\t\tif (itr - a.begin() == (a.size() - 1)) failed();\n\t\tif (itr->first != target_val) failed();\n\t\tsubtree_cnt[itr - a.begin()] += subtree_cnt[i] + 1;\n\t\tans.push_back({ a[i].second + 1, a[itr - a.begin()].second + 1 });\n\t\td[itr - a.begin()] += subtree_cnt[i] + d[i] + 1;\n\t\ta.pop_back();\n\t\tsubtree_cnt.pop_back();\n\t}\n\tif (d[0] != a[0].first) failed();\n\tLoop(i, ans.size()) {\n\t\tcout << ans[i].first << \" \" << ans[i].second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N;\nLL D[100111];\n\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N) scanf(\"%lld\", D+i);\n\n    map<LL, pair<int, int> > mp;\n    REP (i, N) mp[D[i]] = make_pair(i, 1);\n    vector<pair<int, int> > E;\n    E.reserve(N);\n    bool yes = true;\n    while (mp.size() > 1u) {\n\tauto z = prev(mp.end());\n\tint i = z->second.first;\n\tint sz = z->second.second;\n\tLL cst = D[i] + 2 * sz - N;\n\tif (cst == D[i]) {\n\t    yes = false;\n\t    break;\n\t}\n\tauto it = mp.find(cst);\n\tif (it == mp.end()) {\n\t    yes = false;\n\t    break;\n\t}\n\n\tE.emplace_back(i, it->second.first);\n\tit->second.second += sz;\n\tmp.erase(z);\n    }\n\n    if (yes) {\n\tEACH (e, E) printf(\"%d %d\\n\", e->first+1, e->second+1);\n    } else {\n\tputs(\"-1\");\n    }\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define re register\n#define ll long long\ninline int gi()\n{\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=1000010;\ntypedef pair<ll,int> pli;typedef pair<int,int> pii;\n#define mp make_pair\npli p[N];int n,siz[N];\nvector<pii>ans;\nint main()\n{\n\tn=gi();\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&p[i].first),p[i].second=i,siz[i]=1;\n\tsort(p+1,p+n+1);ll dis=0;\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tll nd=p[i].first-(n-siz[p[i].second])+siz[p[i].second];\n\t\tpli it=p[lower_bound(p+1,p+n+1,mp(nd,0))-p];\n\t\tif(it.first!=nd)return puts(\"-1\")&1;\n\t\tans.push_back(mp(it.second,p[i].second));\n\t\tsiz[it.second]+=siz[p[i].second];dis+=siz[p[i].second];\n\t\t}\n\tif(dis!=p[1].first)return puts(\"-1\")&1;\n\tfor(int i=0;i<n-1;i++)printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n//#define ivorysi\n#define MAXN 100005\ntypedef long long int64;\nusing namespace std;\ntemplate<class T>\nvoid read(T &res) {\n\tres = 0;char c = getchar();T f = 1;\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1;\n\t\tc = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tres = res * 10 + c - '0';\n\t\tc = getchar();\n\t}\n\tres *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n\tif(x < 0) {x = -x;putchar('-');}\n\tif(x >= 10) {\n\t\tout(x / 10);\n\t}\n\tputchar('0' + x % 10);\n}\nint N;\nint64 D[MAXN],L[MAXN],dep[MAXN],C[MAXN];\nint id[MAXN],s[MAXN],t[MAXN],tot,siz[MAXN];\n\nstruct node {\n    int to,next;\n}E[MAXN * 2];\nint head[MAXN],sumE;\nvoid add(int u,int v) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    head[u] = sumE;\n}\nbool cmp(int a,int b) {\n    return D[a] < D[b];\n}\nvoid dfs(int u,int fa) {\n    siz[u] = 1;\n    for(int i = head[u] ; i ; i = E[i].next) {\n        int v = E[i].to;\n        if(v != fa){\n            dep[v] = dep[u] + 1;\n            dfs(v,u);\n            siz[u] += siz[v];\n        }\n    }\n}\nbool dfs1(int u,int fa) {\n    if(C[u] != D[u]) return false;\n    for(int i = head[u] ; i ; i = E[i].next) {\n        int v = E[i].to;\n        if(v != fa) {\n            C[v] = C[u] - siz[v] + N - siz[v];\n            if(!dfs1(v,u)) return false;\n        }\n    }\n    return true;\n}\nvoid Solve() {\n    read(N);\n    for(int i = 1 ; i <= N ; ++i) {\n        read(D[i]);id[i] = i;siz[i] = 1;\n    }\n    sort(id + 1,id + N + 1,cmp);\n    for(int i = 1 ; i <= N ; ++i) L[i] = D[id[i]];\n    for(int i = N ; i > 1 ; --i) {\n        s[++tot] = id[i];\n        int p = lower_bound(L + 1,L + i,L[i] + 2 * siz[s[tot]] - N) - L;\n        if(L[p] != L[i] + 2 * siz[s[tot]] - N) {puts(\"-1\");return;}\n        t[tot] = id[p];\n        siz[id[p]] += siz[id[i]];\n    }\n    for(int i = 1 ; i <= tot ; ++i) {add(s[i],t[i]);add(t[i],s[i]);}\n    dfs(1,0);\n    for(int i = 1 ; i <= N ; ++i) C[1] += dep[i];\n    if(!dfs1(1,0)) {puts(\"-1\");return;}\n    for(int i = 1 ; i <= tot ; ++i) {\n        out(s[i]);space;out(t[i]);enter;\n    }\n}\nint main() {\n#ifdef ivorysi\n\tfreopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nint main() \n{\n\tll n; cin >> n;\n\tvector<ll> d(n), cnt(n, 1);\n\tfor (auto &e : d)\n\t\tcin >> e;\n\tsort(d.begin(), d.end());\n\tvector<vector<ll>> child(n, vector<ll>(0));\n\tfor (ll i = n - 1; i > 0; i--)\n\t{\n\t\tll di = d[i] + 2 * cnt[i] - n;\n\t\tll ind = lower_bound(d.begin(), d.begin() + i, di) - d.begin();\n\t\tif (ind == i)\n\t\t{\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t\tcnt[ind] += cnt[i];\n\t\tchild[ind].push_back(i);\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < child[i].size(); j++)\n\t\t{\n\t\t\tcout << i + 1 << \" \" << child[i][j] + 1 << \"\\n\";\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#define ll long long\n#define inf 20021225\n#define N 100010\nusing namespace std;\nll read()\n{\n\tll s=0,t=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')\tt=-1; ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn s*t;\n}\nstruct node{int id; ll d;}a[N];\nbool operator<(node a,node b){return a.d<b.d;}\nint sz[N],fa[N],n;\nmap<ll,int> f;\nint edge[N][2];\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)\ta[i].id=i,a[i].d=read(),f[a[i].d]=i;\n\tsort(a+1,a+n+1);\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tint x=a[i].id; ll d=a[i].d; sz[x]++;\n\t\tif(d-n+sz[x]*2>=d||f.find(d-n+sz[x]*2)==f.end())\treturn puts(\"-1\"),0;\n\t\tint fx=f[d-n+sz[x]*2]; sz[fx]+=sz[x]; fa[x]=fx;\n\t}\n\tfor(int i=2;i<=n;i++)\n\t\tprintf(\"%d %d\\n\",fa[a[i].id],a[i].id);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\n#define exp puts(\"-1\"),exit(0);\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nstd::mt19937 rnd(time(NULL));\n#define rand rnd\n#define pr std::pair<int,int>\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\ntemplate<class T>void cxk(T&a,T b){a=a>b?a:b;}\ntemplate<class T>void cnk(T&a,T b){a=a<b?a:b;}\n#ifdef mod\nint pow(int x,int y){\n\tint ret=1;\n\twhile(y){\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;y>>=1;\n\t}\n\treturn ret;\n}\ntemplate<class Ta,class Tb>void inc(Ta&a,Tb b){a=a+b>=mod?a+b-mod:a+b;}\ntemplate<class Ta,class Tb>void dec(Ta&a,Tb b){a=a>=b?a-b:a+mod-b;}\n#endif\nll D[100010];\nint fa[100010],st[100010],siz[100010];\nstd::unordered_map<ll,int>M;\nint main(){\n#ifdef LOCAL\n\tfreopen(\"in.in\",\"r\",stdin);\n\t//freopen(\"out.out\",\"w\",stdout);\n#endif\n\tint n=gi();\n\tfor(int i=1;i<=n;++i)D[i]=gi(),st[i]=i,M[D[i]]=i,siz[i]=1;\n\tstd::sort(st+1,st+n+1,[&](int a,int b){return D[a]<D[b];});\n\tll ssiz=0;\n\tfor(int _=n,i;_>1;--_){\n\t\ti=st[_];\n\t\tif(!(fa[i]=M[D[i]-n+2*siz[i]]))exp;\n\t\tsiz[fa[i]]+=siz[i];ssiz+=siz[i];\n\t}\n\tif(D[st[1]]!=ssiz)exp;\n\tfor(int i=1;i<=n;++i)if(fa[i])printf(\"%d %d\\n\",i,fa[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <climits>\n#include <set>\n#include <algorithm>\n#include <unordered_map>\n#include <queue>\n#include <iomanip>\n#include <map>\n#include <utility>\n#include <numeric>\n\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define P pair<int, int>\n#define debug(x) cout << #x << \": \" << x << \", \"\n#define debugln(x) cout << #x << \": \" << x << '\\n'\n\nusing namespace std;\nusing ll = long long;\nconst int mod = 1e9+7;\n\nvector<P> ans;\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n; cin >> n;\n  vector<ll> vec(n);\n  unordered_map<ll, int> mp;\n\n  rep(i, n) {\n    cin >> vec.at(i);\n    mp[vec.at(i)] = i+1;\n  }\n\n  vector<int> used(n);\n  vector<int> graph[n+1];\n\n  sort(vec.rbegin(), vec.rend());\n  rep(i, n) {\n    ll a = vec.at(i);\n    int s = mp[a];\n    if (used.at(s-1) == -1) continue;\n    int d = n-2-(2*used.at(s-1));\n\n    if (d > 0 && mp[a-d] > 0) {\n      int t = mp[a-d];\n      used.at(t-1) = used.at(s-1)+1;\n      ans.push_back(P(s,t));\n      graph[s].push_back(t);\n      graph[t].push_back(s);\n      used.at(s-1) = -1;\n    }\n  }\n\n  vector<int> distance(n);\n  rep(i, n) {\n    distance.at(i) = INT_MAX;\n  }\n  priority_queue<P, vector<P>, greater<P>> que;\n  que.push(P(0, 1));\n  while (!que.empty()) {\n    P pa = que.top(); que.pop();\n    int pos = pa.second;\n    int d = pa.first;\n    distance.at(pos-1) = d;\n    for(auto e : graph[pos]) {\n      if (distance.at(e-1) == INT_MAX) {\n        que.push(P(d+1, e));\n        //debug(d+1);debugln(e);\n      }\n    }\n  }\n\n  ll sum = 0;\n  rep(i, n) {\n    if (distance.at(i) == INT_MAX) {\n      cout << -1 << endl;\n      return 0;\n    }\n    sum += distance.at(i);\n  }\n  if (mp[sum] != 1) {\n    cout << -1 << endl;\n    return 0;\n  }\n\n  for(auto e: ans) {\n    cout << e.first << ' ' << e.second << '\\n';\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline ll read()\n{\n\tll x = 0, f = 1; char c = getchar();\n\twhile (!isdigit(c)) {if (c == '-') f = -1; c = getchar();}\n\twhile (isdigit(c)) {x = x * 10 + c - '0', c = getchar();}\n\treturn x * f;\n}\n\nconst int MAXN = 1e5 + 10;\nint n, seq[MAXN], sz[MAXN], root;\nvector<int> linker[MAXN];\nll D[MAXN], f[MAXN], g[MAXN];\n\ninline bool cmp(const int &a, const int &b) {return D[a] < D[b];}\n\nvoid dfs(int x, int fa)\n{\n\tf[x] = 0;\n\tfor (int i = 0; i < linker[x].size(); i ++)\n\t{\n\t\tint cur = linker[x][i];\n\t\tif (cur == fa) continue;\n\t\tdfs(cur, x), f[x] += f[cur] + sz[cur];\n\t}\n}\n\nvoid dfs2(int x, int fa)\n{\n\tif (x == root) g[x] = 0;\n\telse g[x] = g[fa] + n - sz[x] + f[fa] - f[x] - sz[x];\n\tfor (int i = 0; i < linker[x].size(); i ++)\n\t{\n\t\tint cur = linker[x][i];\n\t\tif (cur == fa) continue;\n\t\tdfs2(cur, x);\n\t}\n}\n\ninline bool check()\n{\n\tdfs(root, 0), dfs2(root, 0);\n//\tfor (int i = 1; i <= n; i ++)\n//\t\tprintf(\"(%d, %d), \", f[i], g[i]);\n//\tputs(\"\");\n\tfor (int i = 1; i <= n; i ++)\n\t\tif (f[i] + g[i] != D[i]) return 0;\n\treturn 1;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tn = read();\n\tfor (int i = 1; i <= n; i ++) D[i] = read(), seq[i] = i, sz[i] = 1;\n\tsort(seq + 1, seq + 1 + n, cmp), root = seq[1];\n\tfor (int i = n; i > 1; i --)\n\t{\n\t\tint now = seq[i];\n\t\tint l = 1, r = i - 1, pos = -1;\n\t\tll need = D[now] + 2 * sz[now] - n;\n\t\twhile (l <= r)\n\t\t{\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tif (D[seq[mid]] == need)\n\t\t\t{\n\t\t\t\tpos = seq[mid];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (D[seq[mid]] > need) r = mid - 1;\n\t\t\telse l = mid + 1;\n\t\t}\n//\t\tprintf(\"%d (%d, %d, %d, %d)\\n\", i, now, pos, sz[now], need);\n\t\tif (pos == -1) return puts(\"-1\"), 0;\n\t\tlinker[pos].push_back(now), sz[pos] += sz[now];\n\t}\n\tif (check())\n\t{\n\t\tfor (int i = 1; i <= n; i ++)\n\t\t{\n\t\t\tfor (int j = 0; j < linker[i].size(); j ++)\n\t\t\t{\n\t\t\t\tint to = linker[i][j];\n\t\t\t\tprintf(\"%d %d\\n\", i, to);\n\t\t\t}\n\t\t}\n\t}\n\telse puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<map>\n#define LL long long\n#define M 200020\nusing namespace std;\nLL read(){\n\tLL nm=0,fh=1; char cw=getchar();\n\tfor(;!isdigit(cw);cw=getchar()) if(cw=='-') fh=-fh;\n\tfor(;isdigit(cw);cw=getchar()) nm=nm*10+(cw-'0');\n\treturn nm*fh;\n}\nLL n,m,D[M],sz[M],now,cur,u[M],v[M],tmp,tar;\nLL fs[M],nt[M<<1],to[M<<1],F[M],G[M],mx[M];\nmap<LL,LL>K;\nvoid fad(){puts(\"-1\");exit(0);}\nstruct node{LL id,dst;}p[M];\nbool cmp(node x,node y){return x.dst<y.dst;}\nvoid e(LL x,LL y){cur++,u[cur]=x,v[cur]=y;}\nvoid link(LL x,LL y){nt[tmp]=fs[x],fs[x]=tmp,to[tmp++]=y;}\nvoid dfs1(LL x){\n\tfor(LL i=fs[x];i!=-1;i=nt[i]){\n//\t\tprintf(\"%lld   --> %lld\\n\",x,to[i]);\n\t\tdfs1(to[i]),F[x]+=F[to[i]]+sz[to[i]];\n\t}\n}\nvoid dfs2(LL x){\n\tfor(LL i=fs[x];i!=-1;i=nt[i]){\n\t\tG[to[i]]=G[x]-sz[to[i]]-sz[to[i]]+n,dfs2(to[i]);\n\t}\n}\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read(),memset(fs,-1,sizeof(fs));\n\tfor(LL i=1;i<=n;i++) p[i].id=i,D[i]=read(),p[i].dst=D[i],K[D[i]]=i;\n\tsort(p+1,p+n+1,cmp);\n//\tfor(LL i=1;i<=n;i++) printf(\"%lld  %lld\\n\",p[i].id,p[i].dst);\n\tfor(LL i=n;i>1;i--){\n\t\tsz[p[i].id]++;\n\t\tLL num=p[i].dst-n+sz[p[i].id]*2ll;\n\t\tif(K.count(num)){\n//\t\t\tprintf(\"%lld\\n\",num);\n\t\t\tm=K[num];\n\t\t\tsz[m]+=sz[p[i].id];\n\t\t\tlink(m,p[i].id);\n\t\t\te(m,p[i].id);\n\t\t}\n\t\telse fad();\n\t}\n\tif(sz[p[1].id]!=n-1) fad();\n//\tputs(\"S\");\n\tdfs1(p[1].id),G[p[1].id]=F[p[1].id],dfs2(p[1].id);\n\tfor(LL i=1;i<=n;i++) if(G[i]!=D[i]) fad();\n\tfor(LL i=1;i<n;i++) printf(\"%lld %lld\\n\",u[i],v[i]); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\n\ntypedef long long ll;\ntypedef pair<ll, int> pi;\n\nmap<ll, int> mp;\nconst int maxn = 1e5 + 5;\nint sz[maxn];\nvector<int> G[maxn];\n\nint main(){\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    cin >> n;\n    priority_queue<pi> pq;\n    for(int i = 1;i <= n;i++){\n        ll d;\n        cin >> d;\n        mp[d] = i;\n        pq.push({d, i});\n        sz[i] = 1;\n    }\n    bool flag = true;\n    while(!pq.empty()){\n        pi p = pq.top(); pq.pop();\n        ll dis = p.first;\n        int id = p.second;\n        if(sz[id] == n)\n            break;\n        ll dis1 = dis - (n - 2 * sz[id]);\n        if(mp.find(dis1) == mp.end()){\n            flag = false;\n            break;\n        }else{\n            int fa = mp[dis1];\n            if(fa == id){\n                flag = false;\n                break;\n            }\n            G[fa].push_back(id);\n            sz[fa] += sz[id];\n        }\n    }\n    if(flag){\n        for(int i = 1;i <= n;i++){\n            for(auto v : G[i]){\n                cout << i << \" \" << v << endl;\n            }\n        }\n    }else{\n        cout << -1 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//W4P3R\n#include<bits/stdc++.h>\n#define inf 1e9\n#define eps 1e-6\n#define re register int \n#define FOR(i,a,b) for(re i=a;i<=b;i++)\n#define REP(i,a,b) for(re i=a;i>=b;i--)\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define pa pair<int,int>\n#define fr first\n#define sd second\n#define Z(x) (x>=mod?x-mod:x)\n#define lowbit(x) (x&(-x))\n#define N 100010\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ninline ll read()\n{\n    char ch=getchar();\n    ll s=0,w=1;\n    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}\n    return s*w;\n}\nint n;\nint D[N],sz[N],s=0;\nset<pa>S;\nvector<int>e[N];\nvector<pa>ans; \nvoid dfs(int u,int father,int d)\n{\n\ts+=d;\n\tfor(int v:e[u])if(v!=father)dfs(v,u,d+1);\n}\nint main()\n{\n    //freopen(\".in\",\"r\",stdin);\n    //freopen(\".out\",\"w\",stdout);\n    n=read();\n    FOR(i,1,n){D[i]=read();S.insert(mp(D[i],i));}\n    int t=n-1;\n    while(t--)\n    {\n    \tint x=(*(--S.end())).sd;S.erase(S.lower_bound(mp(D[x],x)));\n    \tsz[x]++;\n    \tint v=D[x]+2*sz[x]-n;\n    \tint y=(*S.lower_bound(mp(v,0))).sd;\n    \t//cout<<\"WTF:\"<<x<<\" \"<<D[x]<<\" \"<<sz[x]<<\" \"<<v<<\" \"<<y<<\" \"<<D[y]<<endl;\n    \tif(D[y]!=v){puts(\"-1\");return 0;}\n    \te[x].pb(y),e[y].pb(x);sz[y]+=sz[x];\n    \tans.pb(mp(x,y));\n    }\n    dfs(1,0,0);\n    if(s==D[1]){for(auto tmp:ans)printf(\"%d %d\\n\",tmp.fr,tmp.sd);}\n    else puts(\"-1\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <map>\n#define __DEBUG__\n#undef __DEBUG__\n#define MAXN 100005\n\nusing namespace std;\n\nint main(){\n    int N;\n    typedef long long ll;\n    pair<ll,int> D[MAXN];//D,ソートする前のノードの番号\n    pair<int,int> ans[MAXN];\n    int Chi[MAXN];\n    ll Dep[MAXN];//深さの和　木の根でDと一致するはず\n    map<ll,int> Ds;//D,ソート後のノードの番号 配列の逆(Dから配列のindexを探しやすくするため)\n    map<ll,int>::iterator it;\n    cin>>N;\n    for(int i = 0;i < N;i++){\n        cin>>D[i].first;\n        D[i].second=i+1;\n        Chi[i]=1;\n        Dep[i]=0;\n    }\n    sort(D,D+N,greater<pair<ll,int> >());\n    for(int i = 0;i < N;i++){\n        Ds[D[i].first]=i;\n    }\n#ifdef __DEBUG__\n    cout<<\"sorted:\"<<endl;\n    for(int i = 0;i < N;i++){\n        cout<<D[i].first<<\",\"<<D[i].second<<\"/\";\n    }\n    cout<<endl;\n#endif\n    for(int i = 0;i < N-1;i++){\n        ll Dj = D[i].first+Chi[i]*2-N;\n        if(it = Ds.find(Dj),it==Ds.end()){\n            cout<<-1<<endl;\n            return 0;\n        }\n        int j = it->second;\n        Chi[j]+=Chi[i];\n        Dep[j]+=Dep[i]+Chi[i];\n        ans[i]=make_pair(D[i].second,D[j].second);\n    }\n#ifdef __DEBUG__\n    cout<<Dep[N-1]<<endl;\n#endif\n    if(Chi[N-1]!=N||Dep[N-1]!=D[N-1].first){\n        cout<<-1<<endl;\n        return 0;\n    }\n    for(int i = 0;i < N-1;i++){\n        cout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fo(i,s,t) for(int i = s; i <= t; ++ i)\n#define fd(i,s,t) for(int i = s; i >= t; -- i)\n#define bf(i,s) for(int i = head[s]; i; i = e[i].next)\n#define mp make_pair\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pb push_back\n#define VI vector<int>\n#define sf scanf\n#define pf printf\n#define fp freopen\n#define SZ(x) ((int)(x).size())\n#ifdef MPS\n#define D(x...) printf(x)\n#else\n#define D(x...)\n#endif\ntypedef long long ll;\ntypedef double db;\ntypedef unsigned long long ull;\nconst int inf = 1<<30;\nconst ll INF = 1ll<<60;\nconst db Inf = 1e20;\nconst db eps = 1e-9;\n\nvoid gmax(int &a,int b){a = (a > b ? a : b);}\nvoid gmin(int &a,int b){a = (a < b ? a : b);}\n\nconst int maxn = 100050;\n\nint n, sz[maxn];\npair<ll,int> d[maxn];\nstruct edge{int u, v;}e[maxn];\n\nint main()\n{\n\t// fp(\"1.in\",\"r\",stdin);\n\t// fp(\"1.out\",\"w\",stdout);\n\tsf(\"%d\",&n);\n\tfo(i,1,n) sf(\"%I64d\",&d[i].fi), d[i].se = i;\n\tsort(d+1, d+n+1);\n\tfd(i,n,2)\n\t{\n\t\tsz[i] ++;\n\t\tint l = 1, r = i-1, mid, p = -1;\n\t\twhile(l <= r)\n\t\t{\n\t\t\tmid = (l + r) >> 1;\n\t\t\tif(d[mid].fi <= d[i].fi-n+2*sz[i]) p = mid, l = mid + 1;\n\t\t\telse r = mid - 1;\n\t\t}\n\t\tif(p == -1 || d[p].fi != d[i].fi-n+2*sz[i]) \n\t\t{\n\t\t\tassert(0);\n\t\t\treturn 0 * pf(\"-1\\n\");\n\t\t}\n\t\tsz[p] += sz[i];\n\t\te[i].u = d[p].se; e[i].v = d[i].se;\n\t}\n\tsz[1] ++;\n\tll ans = 0;\n\tfo(i,1,n) ans += sz[i] * (ll)(n - sz[i]);\n\tans <<= 1;\n\tfo(i,1,n) ans -= d[i].fi;\n\tif(ans != 0) return 0 * pf(\"-1\\n\");\n\tfo(i,2,n) pf(\"%d %d\\n\",e[i].u,e[i].v);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long int LL;\nconst int Max_N(100050);\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nstruct node\n{\n\tint u;\n\tLL d;\n};\nint N, Head[Max_N], Next[Max_N], Size[Max_N];\nnode V[Max_N];\nmap<LL, int> S;\n\ninline void Add_Edge(int s, int t)\n{\n\tNext[t] = Head[s], Head[s] = t;\n}\n\ninline bool comp(const node &a, const node &b)\n{\n\treturn a.d > b.d;\n}\n\nLL Sum;\nvoid dfs(int u, int dep)\n{\n\tSum += dep;\n\tfor (int v = Head[u];v;v = Next[v])\n\t\tdfs(v, dep + 1);\n}\n\nvoid dfs2(int u)\n{\n\tif (S[Sum] != u)\n\t{\n\t\tprint(-1);\n\t\texit(0);\n\t}\n\tfor (int v = Head[u];v;v = Next[v])\n\t\tSum += (N - Size[v]) - Size[v], dfs2(v), Sum -= (N - Size[v]) - Size[v];\n}\n\nint main()\n{\n\tgi(N);\n\tfor (int i = 1;i <= N;++i)\n\t\tgi(V[i].d), S[V[i].d] = V[i].u = i, Size[i] = 1;\n\tsort(V + 1, V + 1 + N, comp);\n\tfor (int i = 1, u, fa;i <= N;++i)\n\t{\n\t\tif (i == N)\n\t\t\tbreak;\n\t\tu = V[i].u;\n\t\tLL d = V[i].d - (N - Size[u]) + Size[u];\n\t\tif (d >= V[i].d || !(fa = S[d]))\n\t\t{\n\t\t\tprint(-1);\n\t\t\treturn 0;\n\t\t}\n\t\tAdd_Edge(fa, u), Size[fa] += Size[u];\n\t}\n\tdfs(1, 0);\n\tdfs2(1);\n\tfor (int u = 1;u <= N;++u)\n\t\tfor (int v = Head[u];v;v = Next[v])\n\t\t\tprint(u), putc(' '), print(v), putc('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <algorithm>\n#include <map>\n#define MN 100000\n#define MM 200000\n#define int LL\ntypedef long long LL;\nint n,hd[MN+5],to[MM+5],nxt[MM+5],rn=0;\nstd::map<int,int> mp;\ntypedef std::map<int,int>::iterator iter;\nstruct node{int i,d,sz;}a[MN+5];\nvoid _add(int u,int v){\n\tto[rn]=v,nxt[rn]=hd[u];\n\thd[u]=rn++;\n}\nvoid add(int u,int v){_add(u,v),_add(v,u);}\nvoid gg(){puts(\"-1\");exit(0);}\nnamespace CHECK{\n\t#include <stdio.h>\n\t#include <string.h>\n\t#include <algorithm>\n\tLL tl[MN+5]; int tc[MM+5];\n\tint gettc(int u,int fa){\n\t\tint ret=1;\n\t\tfor(int i=hd[u];~i;i=nxt[i]){\n\t\t\tif(to[i]==fa) continue;\n\t\t\ttc[i]=gettc(to[i],u);\n\t\t\ttc[i^1]=n-tc[i];\n\t\t\tret+=tc[i];\n\t\t}\n\t\treturn ret;\n\t}\n\tLL dfs_tl(int u,int fa,int dep){\n\t\tLL ret=0;\n\t\tfor(int i=hd[u];~i;i=nxt[i]){\n\t\t\tif(to[i]==fa) continue;\n\t\t\tret+=dfs_tl(to[i],u,dep+1);\n\t\t}\n\t\treturn ret+dep;\n\t}\n\tvoid dp_tl(int u){\n\t\tfor(int i=hd[u];~i;i=nxt[i]){\n\t\t\tif(tl[to[i]]!=-1) continue;\n\t\t\ttl[to[i]]=tl[u]-tc[i]+tc[i^1];\n\t\t\tdp_tl(to[i]);\n\t\t}\n\t}\n\tinline void gettl(){\n\t\ttl[1]=dfs_tl(1,0,0);\n\t\tdp_tl(1);\n\t}\n\tvoid main(){\n\t\tmemset(tl,0xff,sizeof(tl));\n\t\tgettc(1,0); gettl();\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(tl[a[i].i]!=a[i].d) gg();\n\t}\n}\n#undef int\nint main(){\n#define int LL\n\tmemset(hd,0xff,sizeof(hd));\n\tscanf(\"%lld\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i].d);\n\t\ta[i].i=i,a[i].sz=1;\n\t}\n\tstd::sort(a+1,a+1+n,[](node a,node b)->bool{return a.d>b.d;});\n\tfor(int i=1;i<=n;i++) mp[a[i].d]=i;\n\tfor(int i=1;i<=n;i++){\n\t\tint dta=n-(a[i].sz<<1);\n\t\tif(dta<=0) continue;\n\t\titer it=mp.find(a[i].d-dta);\n\t\tif(it==mp.end()) continue;\n\t\ta[it->second].sz+=a[i].sz;\n\t\tadd(a[i].i,a[it->second].i);\n\t}\n\tif(rn!=(n-1)<<1) gg();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=hd[i];~j;j=nxt[j])\n\t\t\tif(i<to[j]) printf(\"%lld %lld\\n\",i,to[j]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#define int long long\nint n,sz[100100],u[100100],v[100100],head[100100],cnt,D;\nstruct Edge{\n\tint to,nxt;\n}edge[200100];\nstruct node{\n\tint dis,x;\n\tbool operator<(node b)const{\n\t\treturn dis>b.dis;\n\t}\n}a[100100];\nmap<int,int>mp;\nvoid addedge(int x,int y){\n\tedge[++cnt].to=y;\n\tedge[cnt].nxt=head[x];\n\thead[x]=cnt;\n}\nint dfs(int x,int fa,int now){\n\tD+=now;\n\tfor (int i=head[x];i;i=edge[i].nxt){\n\t\tint upup=edge[i].to;\n\t\tif(upup==fa)continue;\n\t\tdfs(upup,x,now+1);\n\t}\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i].dis);\n\t\ta[i].x=i;\n\t\tmp[a[i].dis]=i;\n\t}\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)sz[i]=1;\n\tfor(int i=1;i<n;i++){\n\t\tint dis=a[i].dis,x=a[i].x;\n\t\tint tmp=dis-abs(n-2*sz[x]);\n\t\tint fa=mp.find(tmp)->second;\n\t\tif(fa==x||!fa)return puts(\"-1\"),0;\n\t\tsz[fa]+=sz[x];\n\t\tu[i]=x,v[i]=fa;\n\t\taddedge(x,fa);\n\t\taddedge(fa,x);\n\t}\n\tdfs(a[n].x,0,0);\n\tif(D!=a[n].dis)return puts(\"-1\"),0;\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%lld %lld\\n\",u[i],v[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define fi first\n#define SZ(x) (int((x).size()))\n#define se second\n#define ll long long\n#define pq priority_queue\n#define MP make_pair\n#define pii pair<int,int>\n#define mod 998244353\n#define debug(x) cerr<<#x<<\"=\"<<x<<'\\n'\n\nconst int maxn=1e6+10;\n\nint n;\nmap <ll,int> mp;\nll D[maxn];\npair<ll,int> d[maxn];\nint sz[maxn],f[maxn],dd[maxn];\nvector <int> e[maxn];\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) {\n\t\tll x;\n\t\tscanf(\"%lld\",&x);\n\t\td[i]=MP(x,i);\n\t\tmp[x]=i;\n\t\tD[i]=x;\n\t}\n\tsort(d+1,d+n+1);\n\treverse(d+1,d+n+1);\n\tmemset(sz,0,sizeof(sz));\n\tmemset(f,0,sizeof(f));\n\tfor (int i=1;i<n;i++) {\n\t\tsz[d[i].se]++;\n\t\tif (n-2*sz[i]<=0) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tll want=d[i].fi-(ll)(n-2*sz[d[i].se]);\n\t\tif (mp.find(want)==mp.end()) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\te[d[i].se].pb(mp[want]);\n\t\te[mp[want]].pb(d[i].se);\n\t\tsz[mp[want]]+=sz[d[i].se];\n\t\tf[mp[want]]+=sz[d[i].se]+f[d[i].se];\n\t}\n\tif (f[d[n].se]!=D[d[n].se]) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=0;j<e[i].size();j++) {\n\t\t\tif (e[i][j]>i) printf(\"%d %d\\n\",i,e[i][j]);\n\t\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll int\n#define pb push_back\n#define mp make_pair\n#define ld long double\n#define F first\n#define S second\n#define pii pair<ll,ll>\n\nusing namespace :: std;\n\nconst ll maxn=1e5+1050;\nconst ll mod=1e9+7;\nconst ll inf=1e9+5;\n\nvector<pii> yal;\nll sz[maxn];\npii d[maxn];\n\nint main(){\n    cout<<-1;\n    return 0;\n   ll n;\n   cin>>n;\n   for(ll i=0;i<n;i++){\n        cin>>d[i].F;\n        d[i].S=i+1;\n   }\n   sort(d,d+n);\n   fill(sz,sz+maxn,1);\n   for(ll i=n-1;i>=1;i--){\n        ll v=d[i].S;\n        ll dpar=d[i].F+2*sz[v]-n;\n        ll K=lower_bound(d,d+n,mp(dpar,0))-d;\n        if(d[K].F!=dpar || dpar>=d[i].F){\n            cout<<-1;\n            return 0;\n        }\n        ll par=d[K].S;\n        sz[par]+=sz[v];\n        yal.pb(mp(min(v,par),max(v,par)));\n   }\n   sort(yal.begin(),yal.end());\n   for(auto v:yal){\n        cout<<v.F<<' '<<v.S<<endl;\n   }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<bits/stdc++.h>\nusing namespace std;\n#define MaxN 100002\nint n;\nvector<long long >d;\nvector<int>v[MaxN];\nmap<long long,int>mp;\nint sz[MaxN];\nbool vis[MaxN];\nlong long dp[MaxN];\nint cnt[MaxN];\ninline void dfs(int now,int par=-1){\n    cnt[now]++;\n    vis[now]=true;\n    for(int go:v[now]){\n        if(go == par)continue;\n        if(vis[go]){\n            printf(\"-1\\n\");\n            exit(0);\n        }\n        dfs(go,now);\n        dp[now] += dp[go] + cnt[go];\n        cnt[now] += cnt[go];\n    }\n} \nlong long int ans[MaxN];\ninline void dfs2(int now,int par=-1,long long size = 0){\n    ans[now] =dp[now]+size;\n    size+=dp[now];\n    for(int go:v[now]){\n        if(go == par)continue;\n        long long tmp = size - dp[go]-cnt[go]+(n-cnt[go]) ;\n        dfs2(go,now,tmp);\n    }\n}\nvector<pair<int,int>>ed;\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>n;\n    long long x;\n    for(int i=0;i<n;i++){\n        cin>>x;\n        mp[x]=i;\n        d.push_back(x);\n    }\n    for(auto it = mp.rbegin();it!=mp.rend();it++){\n        int node = (*it).second;\n        long long val = (*it).first;\n        sz[node]++;\n        long long op = n-sz[node];\n        if(op==0)continue;\n        long long nex = val + sz[node]- op;\n        if(mp.count(nex)){\n            int ne = mp[nex];\n            sz[ne]+=sz[node];\n            v[ne].push_back(node);\n            v[node].push_back(ne);\n            if(ne > node)swap(ne,node);\n            ed.push_back(make_pair(ne+1,node+1));\n        }\n    }\n    dfs(0);\n    dfs2(0);\n    for(int i=0;i<n;i++){\n        if(vis[i]==false){\n            puts(\"-1\");\n            return 0;\n        }\n        if(ans[i]!=d[i]){\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    for(int i = 0; i<ed.size();i++){\n        cout<<ed[i].first<<' '<<ed[i].second<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stdio.h>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n \nusing namespace std;\n \nconst ll INF = 1e9;\n \nvector < pair <ll, ll> > v;\n \nll n, sz[1000000];\n \nvector <ll> g[1000000];\n \nint main () \n{\n    cin >> n;\n    \n    for (ll i = 0; i < n; i++)\n    {\n\tll d;\n\tscanf (\"%lld\", &d);\n\t\n\tv.emplace_back (d, i);\n    }\n    \n    sort (v.begin (), v.end ());\n    \n    for (ll i = n - 1; i; i--)\n    {\n\tll x = v[i].second, d = v[i].first;\n\t\n\tv.pop_back ();\n\t\n\tsz[x] = 1;\n\t\n\tfor (ll to : g[x])\n\t    sz[x] += sz[to];\n\t\n\tll k = upper_bound (v.begin (), v.end (), make_pair (d + 2 * sz[x] - n, -1)) - v.begin ();\n\t\n\tif (k == v.size () || v[k].first != d + 2 * sz[x] - n)\n\t{\n\t    cout << -1;\n\t    return 0;\n\t}\n\t\n\tg[v[k].second].push_back (x);\n    }\n    \n    for (ll i = 0; i < n; i++)\n\tfor (ll to : g[i])\n\t{\n\t    printf (\"%lld %lld\\n\", i + 1, to + 1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n \n/*\n// ordered_set \n# include <ext/pb_ds/assoc_container.hpp>\n# include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n# define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update> \n*/\n \nusing namespace std;\n \ntypedef long long                                        ll;\ntypedef long double                                      ld;\ntypedef pair <int, int>                                  pii;\ntypedef pair <pii, int>                                  ppi;\ntypedef pair <int, pii>                                  pip;\ntypedef pair <pii, pii>                                  ppp;\ntypedef pair <ll, ll>                                    pll;\n \n# define A                                               first\n# define B                                               second\n# define endl                                            '\\n'\n# define sep                                             ' '\n# define all(x)                                          x.begin(), x.end()\n# define kill(x)                                         return cout << x << endl, 0\n# define SZ(x)                                           int(x.size())\n# define Sort(x)                                         sort(all(x))\n# define InTheNameOfGod                                  ios::sync_with_stdio(0);cin.tie(0); cout.tie(0);\n \nll power(ll a, ll b, ll md) {return (!b ? 1 : (b & 1 ? a * power(a * a % md, b / 2, md) % md : power(a * a % md, b / 2, md) % md));}\n \nconst int xn = 1e5 + 10;\nconst int xm = - 20 + 10;\nconst int SQ = 320;\nconst int sq = 320 + 10;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18 + 10;\nconst int mod = 1e9 + 7;\nconst int TM = 3;\nconst int base = 257;\n\nll n, sz[xn], D[xn], ord[xn], cnt, H[xn], sum;\nvector <pii> ans;\nunordered_map <ll, int> mp;\nvector <int> adj[xn];\nbool mark[xn];\n\nbool cmp(int i, int j){ return D[i] > D[j];}\nvoid DFS(int v){\n\tmark[v] = true;\n\t++ cnt;\n\tsum += H[v];\n\tfor (int u : adj[v]){\n\t\tif (mark[u]) continue;\n\t\tH[u] = H[v] + 1;\n\t\tDFS(u);\n\t}\n}\n\nint main(){\n    InTheNameOfGod;\n    \n\tcin >> n;\n\tfor (int i = 1; i <= n; ++ i){\n\t\tcin >> D[i];\n\t\tord[i] = i;\n\t\tsz[i] = 1;\n\t\tmp[D[i]] = i;\n\t}\n\tsort(ord + 1, ord + n + 1, cmp);\n\tfor (int i = 1; i < n; ++ i){\n\t\tint v = ord[i];\n\t\tint par = mp[D[v] - n + sz[v] + sz[v]];\n\t\tif (!par) kill(- 1);\n\t\tans.push_back({v, par});\n\t\tadj[par].push_back(v);\n\t\tadj[v].push_back(par);\n\t\tsz[par] += sz[v];\n\t}\n\tDFS(1);\n\tif (cnt < n || sum != D[1]) kill(- 1);\n\tfor (pii e : ans) cout << e.A << sep << e.B << endl;\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=100005;\nint n,size[N],st[N],to[N<<1],tto[N],last[N],Next[N<<1],edge;\nlong long D;\nstruct note{\n\tlong long dis;\n\tint x;\n}d[N];\nbool cmp(note x,note y){\n\treturn x.dis>y.dis;\n}\nusing std::map;\nmap<long long,int> m;\nvoid add(int x,int y){\n\tto[++edge]=y;\n\tNext[edge]=last[x];\n\tlast[x]=edge;\n}\nint dfs(int x,int fa,long long now){\n\tD+=now;\n\tfor (int i=last[x];i;i=Next[i])\n\t\tif (to[i]!=fa)\n\t\t\tdfs(to[i],x,now+1);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) {\n\t\tscanf(\"%lld\",&d[i].dis);\n\t\td[i].x=i;\n\t\tm[d[i].dis]=i;\n\t}\n\tstd::sort(d+1,d+n+1,cmp);\n\tfor (int i=1;i<=n;i++) size[i]=1;\n\tfor (int i=1;i<n;i++){\n\t\tlong long dis=d[i].dis;\n\t\tint x=d[i].x;\n\t\tlong long t=dis-abs(n-2*size[x]);\n\t\tint fa=m.find(t)->second;\n\t\tif (fa==x || !fa){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsize[fa]+=size[x];\n\t\tst[i]=x,tto[i]=fa;\n\t\tadd(x,fa),add(fa,x);\n\t}\n\tdfs(d[n].x,0,0);\n\tif (D!=d[n].dis){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++) printf(\"%d %d\\n\",st[i],tto[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define pb push_back\n#define fi first\n#define se second\ntypedef pair<int, int> ii;\n\nconst int N = 1e5 + 5;\nint n, nChild[N], up[N], down[N];\nvector<ii> d;\nvector<int> gr[N], ver;\n\nvoid dfs1 (int u, int p) {\n    for (int v : gr[u]) if (v != p) {\n        dfs1(v, u);\n        down[u] += down[v] + nChild[v];\n    }\n}\n\nvoid dfs2 (int u, int p) {\n    for (int v : gr[u]) if (v != p) {\n        up[v] = up[u] + down[u] - down[v] - nChild[v] + n - nChild[v];\n        dfs2(v, u);\n    }\n}\n\nsigned main () {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n;\n    for (int _ = 1; _ <= n; ++_) {\n        nChild[_] = 1;\n        int D; cin >> D;\n        d.pb(ii(D, _) );\n    }\n    sort(d.begin(), d.end() );\n\n    for (int i = d.size() - 1; i > 0; --i) {\n        int u = d[i].se;\n        int pos = lower_bound(d.begin(), d.end(), ii(d[i].fi - n + 2 * nChild[u], 0) ) - d.begin();\n        if (pos == n || d[pos].fi != d[i].fi - n + 2 * nChild[u]) return cout << -1, 0;\n        int v = d[pos].se;\n        gr[u].pb(v); gr[v].pb(u);\n        nChild[v] += nChild[u];\n    }\n\n    dfs1(d[0].se, 0);\n    dfs2(d[0].se, 0);\n    for (auto _ : d) {\n        if (_.fi != up[_.se] + down[_.se]) return cout << -1, 0;\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j : gr[i]) if (i > j) cout << i << ' ' << j << '\\n';\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#define MIN_INT -2147483648\n#define MAX_INT 2147483647\n#define MIN_LONG -9223372036854775808L\n#define MAX_LONG 9223372036854775807L\n#define PI 3.141592653589793238462643383279502884L\n\n#define long long long int\n\nusing std::vector;\nusing std::map;\nusing std::set;\nusing std::string;\nusing std::pair;\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\n// @author: pashka\n\nvector<vector<int>> g;\n\nlong calc(int i, long s) {\n    long res = s;\n    for (int x : g[i]) {\n        res += calc(x, s + 1);\n    }\n    return res;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    vector<long> a(n);\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n\n    std::sort(a.rbegin(), a.rend());\n\n    map<long, int> q;\n    for (int i = 0; i < n; i++) {\n        q[a[i]] = i;\n    }\n\n    vector<int> s(n);\n\n    g.resize(n);\n\n    for (int i = 0; i < n - 1; i++) {\n        s[i]++;\n        long p = a[i] - (n - 2 * s[i]);\n        if (q.find(p) == q.end()) {\n            cout << -1;\n            return 0;\n        }\n        int x = q[p];\n        s[x] += s[i];\n        g[x].push_back(i);\n    }\n\n    if (calc(n - 1, 0) != a[n - 1]) {\n        cout << -1;\n        return 0;\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j : g[i]) {\n            cout << (i + 1) << \" \" << (j + 1) << \"\\n\";\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*input\n15\n57\n62\n47\n45\n42\n74\n90\n75\n54\n50\n66\n63\n77\n87\n51\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\n\n//}}}\nconst ll maxn=300005;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=8000000000000000000LL;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=ll(1e9+7);\nconst double PI=acos(-1);\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\t\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nll d[maxn];\nset<pll,greater<pll>> st;\nvector<pii> edge;\nint sz[maxn];\nint main()\n{\n\tIOS;\n\tint n;\n\tcin>>n;\n\tREP(i,n) cin>>d[i];\n\tREP(i,n) st.insert(MP(d[i],i));\n\tREP(i,n) sz[i]=1;\n\n\twhile(SZ(st)>1){\n\t\tauto cur=*st.begin();\n\t\t// cout<<cur<<'\\n';\n\t\tst.erase(st.begin());\n\t\tll new_size=cur.F+sz[cur.S]-(n-sz[cur.S]);\n\t\tauto nxt=*st.lower_bound(MP(new_size,INF64));\n\t\tif(nxt.F!=new_size){\n\t\t\tcout<<\"-1\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tedge.pb(MP(cur.S,nxt.S));\n\t\tsz[nxt.S]+=sz[cur.S];\n\t}\n\tfor(int i=0;i<n-1;i++){\n\t\tcout<<edge[i].F+1<<' '<<edge[i].S+1<<'\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nusing ll = int64_t;\n\nint main() {\n  int n;\n  cin>>n;\n  map<ll, pair<int, int>> m;\n  REP(i,n) {\n    ll d;\n    cin>>d;\n    m[d] = make_pair(1, i+1);\n  }\n  bool ok = true;\n  vector<pair<int, int>> edges;\n  while (m.size() > 1) {\n    const auto itr = m.rbegin();\n    ll d = itr->first;\n    int k, i;\n    tie(k, i) = itr->second;\n    m.erase(prev(m.end()));\n    ll diff = n-2*k;\n    if (diff <= 0 || m.count(d - diff) == 0) {\n      ok = false;\n      break;\n    }\n    int l, j;\n    tie(l, j) = m[d-diff];\n    edges.emplace_back(j, i);\n    m[d-diff] = make_pair(l+k, j);\n  }\n  if (ok) {\n    reverse(ALL(edges));\n    vector<ll> dist(n+1);\n    for (auto p : edges) {\n      int u, v;\n      tie(u, v) = p;\n      dist[v] = dist[u]+1;\n    }\n    ll sum = 0;\n    for (auto d : dist) sum += d;\n    if (sum == m.begin()->first) {\n      for (auto p : edges) {\n        int u, v;\n        tie(u, v) = p;\n        cout << u << ' ' << v << endl;\n      }\n    } else {\n      cout << -1 << endl;\n    }\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<long long, int> pli;\n\nconst int N = 1e5 + 10;\nint h[N], n, cnt[N], par[N];\nlong long d[N], check;\nvector<pli> di;\nvector<int> child[N];\nmap<long long, int> mp;\n\nvoid dfs(int v, int p){\n\th[v] = h[p] + 1;\n\tfor (int u : child[v])\n\t\tdfs(u, v);\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);cout.tie(0);\n\t\n\tcin >> n;\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> d[i];\n\t\tdi.push_back({d[i], i});\n\t\tmp[d[i]] = i + 1;\n\t}\n\t\n\tsort(di.begin(), di.end());\n\treverse(di.begin(), di.end());\n\t\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[i] = 1;\n\tfor (int i = 0; i < n - 1; i++){\n\t\tint v = di[i].second;\n\t\tlong long dis = di[i].first,\n\t\t\t\t  par_dis = dis + (2 * cnt[v]) - n;\n\t\t\n\t\tif(mp[par_dis] == 0)\n\t\t\treturn cout << -1, 0;\n\t\t\n\t\tint ver_par = mp[par_dis] - 1;\n\t\tcnt[ver_par] += cnt[v];\n\t\tpar[v] = ver_par;\n\t\tchild[par[v]].push_back(v);\n\t}\n\t\n\tint root = di[n - 1].second;\n\th[root] = -1;\n\tdfs(root, root);\n\t\n\tfor (int i = 0; i < n; i++)\n\t\tcheck += h[i];\n\t\n\tif(check != d[root])\n\t\treturn cout << -1, 0;\n\t\n\tfor (int i = 0; i < n; i++)\n\t\tif(par[i] != i)\n\t\t\tcout << par[i] + 1 << ' ' << i + 1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\nconst int N=55;\n\nint n,x[N],y[N],d[N],m;\nbool in[2];\n\nint main() {\n\tscanf(\"%d\",&n);\n\tfo(i,1,n) {\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\tin[(x[i]+y[i])&1]=1;\n\t}\n\tif (in[0]&&in[1]) {puts(\"-1\");return 0;}\n\tif (in[0]) d[++m]=1;\n\tfd(i,30,0) d[++m]=1<<i;\n\tprintf(\"%d\\n\",m);\n\tfo(i,1,m) printf(\"%d \",d[i]);\n\tputs(\"\");\n\tfo(i,1,n) {\n\t\tfo(j,1,m)\n\t\t\tif (abs(x[i])>abs(y[i])) {\n\t\t\t\tif (x[i]>0) x[i]-=d[j],putchar('R');\n\t\t\t\telse x[i]+=d[j],putchar('L');\n\t\t\t} else {\n\t\t\t\tif (y[i]>0) y[i]-=d[j],putchar('U');\n\t\t\t\telse y[i]+=d[j],putchar('D');\n\t\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(3)\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC target(\"sse3\",\"sse2\",\"sse\")\n#pragma GCC target(\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")\n#pragma GCC target(\"f16c\")\n#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\n#pragma GCC diagnostic error \"-fwhole-program\"\n#pragma GCC diagnostic error \"-fcse-skip-blocks\"\n#pragma GCC diagnostic error \"-funsafe-loop-optimizations\"\n#pragma GCC diagnostic error \"-std=c++14\"\n#include \"bits/stdc++.h\"\n//#include \"ext/pb_ds/tree_policy.hpp\"\n//#include \"ext/pb_ds/assoc_container.hpp\"\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) a.begin(),a.end()\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) (x&(-x))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9+7;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {\n    if(a<0)return -1;\n    if(a>0)return 1;\n    return 0;\n}\n\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\n\ntemplate<typename T> inline void in(T &x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) {\n        if (ch == '-') f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))  {\n        x = x * 10 + ch - '0';\n        ch = getchar();\n    }\n    x *= f;\n}\n\nll twop(int x) {\n    return 1LL<<x;\n}\n\ntemplate<typename A,typename B > inline void in(A&x,B&y) {\n    in(x);\n    in(y);\n}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {\n    in(x);\n    in(y);\n    in(z);\n}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {\n    in(x);\n    in(y);\n    in(z);\n    in(d);\n}\nll gcd(ll a,ll b){return b==0?a:gcd(b,a%b);}\nnamespace SOLVE {\n    void main(){\n    }\n}\n\n\nvector<PLL>v;\nll fa[100010],dep[100010],siz[100010];\nvoid bye(){\n    cout<<-1;exit(0);\n}\nint main() {\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    int n;in(n);\n    REP(i,1,n+1){\n        ll d;in(d);\n        v.PB(MP(d,i));\n    }\n    sort(all(v));\n    mst(fa,-1);\n    RREP(i,n-1,1){\n        siz[i]++;\n        auto ptr = lower_bound(v.begin(),v.begin()+i,MP(v[i].fi - (n-siz[i]) + siz[i],-1LL));\n        if(ptr== v.begin()+i || (ptr->fi != v[i].fi - (n-siz[i]) + siz[i])){\n            bye();\n        }\n        fa[i] = ptr-v.begin();\n        siz[ptr-v.begin()] += siz[i];\n    }\n    \n    siz[0]++;\n    REP(i,1,n)dep[i] = dep[fa[i]]+1;\n    ll sum = 0;\n    REP(i,1,n)sum+=dep[i];\n    if(sum!=v[0].fi)bye();\n    REP(i,1,n)cout<<v[fa[i]].se<<\" \"<<v[i].se<<endl;\n\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n\nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nint modpow(int a, long long n, int mod = MOD) { int ret = 1; do { if (n & 1) ret = 1LL * ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\n// counterclockwise from 12 o'clock direction\ntemplate<typename T> bool CompareBySlope(pair<T, T> a, pair<T, T> b) { if (a.first * b.first < 0) return a.first < b.first; if (a.first == 0) return a.second >= 0 || b.first > 0; if (b.first == 0) return b.second < 0 && a.first < 0; return a.second * b.first < a.first * b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\nvoid solve() {\n  int n; cin >> n;\n  vector<pair<ll, int>> g(n);\n  rep(i,n) {\n    cin >> g[i].first;\n    g[i].second = i;\n  }\n  sort(ALL(g));\n\n  vi cnt(n);\n  vector<pii> ans; ans.reserve(n-1);\n\n  rrep1(i,n) {\n    ll d; int idx;\n    tie(d, idx) = g[i];\n\n    ll nd = d - (n-2) + 2*cnt[idx];\n    auto itr = lower_bound(ALL(g), make_pair(nd, 0));\n\n    if (itr->first != nd) {\n      cout << -1 << endl;\n      return;\n    }\n\n    int nidx = itr->second;\n    cnt[nidx] += cnt[idx] + 1;\n    ans.emplace_back(idx+1, nidx+1);\n  }\n\n  cout << ans << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(12);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define fi first\n#define SZ(x) (int((x).size()))\n#define se second\n#define ll long long\n#define pq priority_queue\n#define MP make_pair\n#define pii pair<int,int>\n#define mod 998244353\n#define debug(x) cerr<<#x<<\"=\"<<x<<'\\n'\n\nconst int maxn=1e6+10;\n\nint n;\nmap <ll,int> mp;\nll D[maxn];\npair<ll,int> d[maxn];\nint sz[maxn];\nll f[maxn];\nvector <int> e[maxn];\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) {\n\t\tll x;\n\t\tscanf(\"%lld\",&x);\n\t\td[i]=MP(x,i);\n\t\tmp[x]=i;\n\t\tD[i]=x;\n\t}\n\tsort(d+1,d+n+1);\n\treverse(d+1,d+n+1);\n\tmemset(sz,0,sizeof(sz));\n\tmemset(f,0,sizeof(f));\n\tfor (int i=1;i<n;i++) {\n\t\tsz[d[i].se]++;\n\t\tif (n-2*sz[i]<=0) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tll want=d[i].fi-(ll)(n-2*sz[d[i].se]);\n\t\tif (mp.find(want)==mp.end()) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\te[d[i].se].pb(mp[want]);\n\t\te[mp[want]].pb(d[i].se);\n\t\tsz[mp[want]]+=sz[d[i].se];\n\t\tf[mp[want]]+=(ll)sz[d[i].se]+f[d[i].se];\n\t}\n\tif (f[d[n].se]!=D[d[n].se]) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=0;j<e[i].size();j++) {\n\t\t\tif (e[i][j]>i) printf(\"%d %d\\n\",i,e[i][j]);\n\t\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+3;\nint n,siz[N];\nstruct syzs{\n\tlong long val;\n\tint num;\n} a[N];\nstruct ans{\n\tint e1,e2;\n\tbool operator <(const ans &emm) const{\n\t    if(emm.e1==e1) return e2>emm.e2;\n\t\treturn emm.e1<e1;\n\t}\n};\nbool cmp(syzs c,syzs b){\n\treturn c.val>b.val;\n}\nint find(int k){\n\tlong long chec=2*siz[k]-n;\n\tfor(int i=k+1;i<=n;i++) if(a[i].val-a[k].val==chec) return i;\n\treturn -1;\n}\nlong long read(){\n\tlong long s=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}\n\treturn s*f;\n}\nint main(){\n\tpriority_queue <ans> q;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\ta[i].val=read();//scanf(\"%lld\",&a[i].val);\n\t\ta[i].num=i;\n\t\tsiz[i]=1;\n\t}\n\tsort(a+1,a+n+1,cmp);\n\tfor(int i=1;i<n;i++){\n\t\tint v=find(i);\n\t\tif(v==-1){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[v]+=siz[i];\n\t\tq.push((ans) {min(a[v].num,a[i].num),max(a[v].num,a[i].num)});\n\t}\n\twhile(!q.empty()){\n\t\tint v1=q.top().e1,v2=q.top().e2;\n    \tq.pop();\n    \tprintf(\"%d %d\\n\",v1,v2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i <= (b); ++ i)\n#define rrp(i,a,b) for (int i = (a); i >= (b); -- i)\n#define gc() getchar()\n#define fir first\n#define sec second\ntypedef pair<int,int> pii;\ntypedef double db;\ntypedef long long ll;\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc(); !isdigit(tmp); tmp = gc())\n    key = (tmp == '-');\n  for (; isdigit(tmp); tmp = gc()) \n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst int N = 100010;\nint n, per[N], sz[N], cur;\nll dis[N];\nmap<ll,int> mp;\nvector<pii> ans;\nvoid fail() {\n  puts(\"-1\");\n  exit(0);\n}\nstruct edge {\n  int la,b;\n} con[N << 1];\nint tot, fir[N];\nvoid add_edge(int from,int to) {\n  con[++tot] = (edge) {fir[from], to};\n  fir[from] = tot;\n}\nll sum[N], cal[N];\nvoid dfs(int pos,int fa) {\n  sum[pos] = cal[pos] = 0;\n  for (int i = fir[pos]; i; i = con[i].la) {\n    if (con[i].b == fa) continue;\n    dfs(con[i].b, pos);\n    sum[pos] += sum[con[i].b] + sz[con[i].b];\n  }\n}\nvoid fsd(int pos,int fa) {\n  cal[pos] += sum[pos];\n  for (int i = fir[pos]; i; i = con[i].la) {\n    if (con[i].b == fa) continue;\n    cal[con[i].b] += cal[pos] - sum[con[i].b] - sz[con[i].b] + (n - sz[con[i].b]);\n    fsd(con[i].b, pos);\n  }\n}\nint main() {\n  read(n);\n  rep (i, 1, n) read(dis[i]);\n  rep (i, 1, n) mp[dis[i]] = i;\n  rep (i, 1, n) per[i] = i;\n  sort(per + 1, per + n + 1, [=](int a,int b) -> bool {\n      return dis[a] < dis[b];\n    });\n  rrp (i, n, 2) {\n    ++ sz[per[i]];\n    ll tmp = dis[per[i]] - n + 2 * sz[per[i]];\n    if (!mp.count(tmp)) fail();\n    sz[mp[tmp]] += sz[per[i]];\n    ans.push_back(pii(mp[tmp], per[i]));\n    add_edge(mp[tmp], per[i]);\n  }\n  dfs(per[1], 0);\n  fsd(per[1], 0);\n  rep (i, 1, n) if (cal[i] != dis[i])\n    fail();\n  rep (i, 0, (int)ans.size()-1) {\n    printf(\"%d %d\\n\", ans[i].fir, ans[i].sec);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,int>P;\n\nint n;\nP d[200000];\nvector<int>E[200000];\nint sz[200000];\nll dp1[200000],dp2[200000];\nvector<pair<int,int>>ans;\n\nvoid dfs1(int v){\n\tfor(int u:E[v]){\n\t\tdfs1(u);\n\t\tdp1[v]+=dp1[u]+sz[u];\n\t}\n}\nvoid dfs2(int v,int p){\n\tif(p==-1)dp2[v]=dp1[v];\n\telse dp2[v]=dp2[p]+n-2*sz[v];\n\tfor(int u:E[v]){\n\t\tans.push_back({v+1,u+1});\n\t\tdfs2(u,v);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%lld\",&d[i].first);\n\t\td[i].second=i;\n\t}\n\trep(i,n)sz[i]=1;\n\tsort(d,d+n);\n\tfor(int i=n-1;i>0;i--){\n\t\tint c=d[i].first-n+2*sz[d[i].second];\n\t\tint id=lower_bound(d,d+n,P(c,0))-d;\n\t\tif(id==n||d[id].first!=c){\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t\tif(i<id)abort();\n\t\tE[d[id].second].push_back(d[i].second);\n\t\tsz[d[id].second]+=sz[d[i].second];\n\t}\n\tdfs1(d[0].second);\n\tdfs2(d[0].second,-1);\n\trep(i,n){\n\t\tif(dp2[d[i].second]!=d[i].first){\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t}\n\tfor(auto p:ans){\n\t\tprintf(\"%d %d\\n\",p.first,p.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define maxn 1000005\n#define inf 1e9\n#define eps 1e-10\nusing namespace std;\n\ninline ll read()\n{\n\tll x=0,w=1; char c=getchar();\n\twhile(c<'0'||c>'9') {if(c=='-') w=-1; c=getchar();}\n\twhile(c<='9'&&c>='0') {x=(x<<1)+(x<<3)+c-'0'; c=getchar();}\n\treturn w==1?x:-x;\n}\n\nll n,d[maxn],siz[maxn],f,dis;\nmap <ll,int> p;\nvector <int> a1,a2;\n\ninline bool cmp(ll a,ll b){return a>b;}\n\nint main()\n{\n\tn=read(); f=0;\n\tfor(int i=1;i<=n;i++) d[i]=read(),p[d[i]]=i;\n\tsort(d+1,d+n+1,cmp);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tsiz[p[d[i]]]++;\n\t\tll dfa=d[i]-n+2*siz[p[d[i]]];\n\t\tif(dfa>d[i]) continue;\n\t\tsiz[p[dfa]]+=siz[p[d[i]]]; dis+=siz[p[d[i]]];\n\t\t//cout<<d[i]<<\" \"<<p[d[i]]<<\" \"<<siz[p[d[i]]]<<\" \"<<dfa<<endl;\n\t\tif(p[dfa]==0) {f=1; break;}\n\t\ta1.push_back(p[d[i]]),a2.push_back(p[dfa]);\n\t}\n\tif(f==1||dis!=d[n]) {puts(\"-1\"); return 0;}\n\tfor(int i=0;i<a1.size();i++) printf(\"%d %d\\n\",a1[i],a2[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#define MN 100005\n#define ll long long\nusing namespace std;\ninline int in(){\n    int x=0;bool f=0;char c;\n    for (;(c=getchar())<'0'||c>'9';f=c=='-');\n    for (x=c-'0';(c=getchar())>='0'&&c<='9';x=(x<<3)+(x<<1)+c-'0');\n    return f?-x:x;\n}\nstruct st{\n\tll v;\n\tint id;\n}a[MN];\nstruct edge{\n\tint to,nxt;\n}e[MN<<1];\nmap <ll,int> mp;\nint h[MN],fa[MN],dep[MN],siz[MN];\nint n,cnt;\nll sum;\ninline bool cmp(st x,st y){return x.v>y.v;}\ninline void ins(int x,int y){\n\te[++cnt].to=y;e[cnt].nxt=h[x];h[x]=cnt;\n}\ninline void dfs(int u){\n\tsum+=1ll*dep[u];\n\tfor (int i=h[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif (v==fa[u]) continue;\n\t\tdep[v]=dep[u]+1;\n\t\tfa[v]=u;dfs(v);\n\t}\n}\nint main()\n{\n\tn=in();\n\tfor (int i=1;i<=n;++i){\n\t\ta[i].v=in();a[i].id=i;\n\t\tmp[a[i].v]=i;siz[i]=1;\n\t}sort(a+1,a+n+1,cmp);\n\tfor (int i=1;i<n;++i){\n\t\tll d=a[i].v-n+(siz[a[i].id]<<1);\n\t\tif (d>=a[i].v||(!mp[d])) {printf(\"-1\");return 0;}\n\t\tins(a[i].id,mp[d]);ins(mp[d],a[i].id);\n\t\tsiz[mp[d]]+=siz[a[i].id];\n\t}dfs(a[n].id);\n\tif (sum!=a[n].v) {printf(\"-1\");return 0;}\n\tfor (int i=1;i<=n;++i)\n\tif (fa[i]) printf(\"%d %d\\n\",fa[i],i);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cassert>\n#include<vector>\n#define ll long long\nusing namespace std;\ninline ll read(){\n\tll re=0,flag=1;char ch=getchar();\n\twhile(ch>'9'||ch<'0'){\n\t\tif(ch=='-') flag=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();\n\treturn re*flag;\n}\nint n;\nstruct node{\n\tll num,dis;\n}a[100010];\nint siz[100010],fa[100010],d[100010],dep[100010];\nvector<int>son[100010];\nbool cmp(node l,node r){\n\treturn l.dis<r.dis;\n}\nvoid dfs(int u,int f){\n\tint i;dep[u]=dep[f]+1;\n//\tcout<<u<<' '<<dep[u]<<\"***\\n\";\n\tfor(auto v:son[u]){\n\t\tif(v!=f) dfs(v,u);\n\t}\n}\nint main(){\n\tn=read();int i;\n\tfor(i=1;i<=n;i++) a[i].dis=read(),a[i].num=i;\n\tsort(a+1,a+n+1,cmp);\n\tfor(i=1;i<=n;i++) d[i]=a[i].dis;\n\tfor(i=n;i>=2;i--){\n\t\tsiz[a[i].num]++;\n\t\tll tmp=d[i]-(n-2*siz[a[i].num]);\n\t\tint pos=lower_bound(d+1,d+i,tmp)-d;\n//\t\tcout<<i<<' '<<d[i]<<' '<<a[i].num<<' '<<siz[a[i].num]<<' '<<tmp<<' '<<pos<<' '<<a[pos].num<<' '<<d[pos]<<'\\n';\n\t\tif(pos>=i||d[pos]!=tmp){\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t\tsiz[a[pos].num]+=siz[a[i].num];fa[a[i].num]=a[pos].num;\n\t}\n\tstd::ios::sync_with_stdio(false);\n\tfor(i=1;i<=n;i++) if(fa[i]) son[fa[i]].push_back(i);\n\tdep[0]=-1;dfs(a[1].num,0);\n\tll ans=0;\n\tfor(i=1;i<=n;i++) ans+=dep[i];\n\tif(ans!=d[1]){\n\t\tputs(\"-1\");return 0;\n\t}\n\tfor(i=1;i<=n;i++) if(fa[i]) cout<<i<<' '<<fa[i]<<'\\n';\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <long long, long long> pii;\n\nconst long long MAX_N = 1e5 + 5;\nlong long n, root;\nlong long Arr[MAX_N];\nlong long h[MAX_N];\nlong long Siz[MAX_N];\nlong long Mark[MAX_N];\nlong long par[MAX_N];\nunordered_map <long long, long long> Map;\nvector <pii> edge;\nlong long dp_d[MAX_N];\nlong long dp_u[MAX_N];\nvector <long long> child[MAX_N];\n\nbool cmp(long long a, long long b) {\n\treturn Arr[b] < Arr[a];\n}\n\nvoid dfs1(long long v) {\n\tfor (long long i = 0; i < child[v].size(); i++) {\n\t\tdfs1(child[v][i]);\n\t\tdp_d[v] += dp_d[child[v][i]] + Siz[child[v][i]];\n\t}\n}\n\nvoid dfs2(long long v, long long val) {\n\tdp_u[v] = val;\n\tfor (long long i = 0; i < child[v].size(); i++)\n\t\tdfs2(child[v][i], dp_d[v] + dp_u[v] - dp_d[child[v][i]] - Siz[child[v][i]] + (n - Siz[child[v][i]]));\n}\n\nint main() {\n\tios::sync_with_stdio(false), cout.tie(0), cin.tie(0);\n\tcin >> n;\n\tfor (long long i = 0; i < n; i++) {\n\t\tcin >> Arr[i];\n\t\tSiz[i] = 1;\n\t\th[i] = i;\n\t\tMap[Arr[i]] = i;\n\t}\n\t\t\n\tsort(h, h + n, cmp);\n\t\n\tfor (long long i = 0; i + 1 < n; i++) {\n\t\tlong long v = h[i];\n\t\tlong long tmp = Arr[v] + Siz[v] - (n - Siz[v]);\n\n\t\tif (tmp < 0 || (Map[tmp] == 0 && Arr[0] != tmp)) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tlong long u = Map[tmp];\n\t\tif (Mark[u]) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tSiz[u] += Siz[v];\n\t\tpar[v] = u;\n\t\tedge.push_back({v, u});\n\t\tchild[u].push_back(v);\n\t\tif (n < 2LL * max(Siz[v], Siz[u])) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\troot = h[n - 1];\n\tdfs1(root);\n\tdfs2(root, 0);\n\t\n\tfor (long long i = 0; i < n; i++)\n\t\tif (dp_d[i] + dp_u[i] != Arr[i]) {\n\t\t\tcout << i << \" \" << dp_d[i] + dp_u[i] << \"\\n\";\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\n\tfor (long long i = 0; i + 1 < n; i++)\n\t\tcout << edge[i].first + 1 << \" \" << edge[i].second + 1 << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stdio.h>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nvector < pair <int, int> > v;\n\nint n, sz[1000000], r[1000000];\n\nbool ans = true;\n\nvector <int> g[1000000];\n\nint dfs (int x, int p)\n{\n\tint sum = 1;\n\n\tfor (int to : g[x])\n\t\tif (to != p)\n\t\t\tsum += dfs (to, x);\n\n\tif (r[x] != sum) ans = false;\n}\n\nint main () \n{\n    cin >> n;\n    \n    for (int i = 0; i < n; i++)\n    {\n\t\tint d;\n\t\tscanf (\"%d\", &d);\n\t\t\n\t\tv.emplace_back (d, i);\n\n\t\tr[i] = d;\n    }\n    \n    sort (v.begin (), v.end ());\n    \n    for (int i = n - 1; i >= 0; i--)\n    {\n\t\tint x = v[i].second, d = v[i].first;\n\t\t\n\t\tv.pop_back ();\n\t\t\n\t\tsz[x] = 1;\n\t\t\n\t\tfor (int to : g[x])\n\t\t    sz[x] += sz[to];\n\t\t\n\t\tif (!i) break;\n\t\t\n\t\tint k = lower_bound (v.begin (), v.end (), make_pair (d + 2 * sz[x] - n, -1)) - v.begin ();\n\t\t\n\t\tif (k == v.size () || v[k].first != d + 2 * sz[x] - n)\n\t\t{\n\t\t    cout << -1;\n\t\t    return 0;\n\t\t}\n\t\t\n\t\tg[v[k].second].push_back (x);\n    }\n    \n    dfs (0, -1);\n    \n    if (!ans)\n    {\n\t\tcout << -1;\n\t\treturn 0;\n    }\n    \n    for (int i = 0; i < n; i++)\n\t\tfor (int to : g[i])\n\t\t{\n\t\t    printf (\"%d %d\\n\", i + 1, to + 1);\n\t\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nlong long d[100010];\n#define endl '\\n'\ntypedef pair <long long, int> pii;\n\nint sub[100010];\nint par[100010];\n\nint dis[100010];\nvector <int> g[100010]; \n\nvoid dfs(int x, int par) {\n\tfor(auto i : g[x]) {\n\t\tif(i - par) {\n\t\t\tdis[i] = 1 + dis[x];\n\t\t\tdfs(i, x);\n\t\t}\n\t}\n}\n\n\nint main(int argc, char const *argv[])\n{\n\tios_base :: sync_with_stdio (false);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tmap <long long, int> mp;\n\tvector <pii> v;\n\tfor(int i = 1; i <= n; i++) {\n\t\tcin >> d[i];\n\t\tv.emplace_back(d[i], i);\n\t\tmp[d[i]] = i;\n\t}\n\tsort(v.begin(), v.end());\n\treverse(v.begin(), v.end());\n\n\tfor(int i = 1; i <= n; i++) {\n\t\tsub[i] = 1;\n\t\tpar[i] = i;\n\t}\n\tfor(int i = 0; i < n-1; i++) {\n\t\tint node = v[i].second;\n\t\tint diff = n - 2 * sub[node];\n\t\tlong long par_d = v[i].first - diff;\n\t\tif(diff == 0 || mp.find(par_d) == mp.end()) {\n\t\t\tcout << -1 << endl;\n\t\t\texit(0);\n\t\t}\n\t\tpar[node] = mp[par_d];\n\t\tsub[par[node]] += sub[node];\n\t\tg[par[node]].push_back(node);\n\t\tg[node].push_back(par[node]);\n\t}\n\tmemset(dis, -1, sizeof dis);\n\tdis[1] = 0;\n\tdfs(1, 0);\n\n\tlong long tot = 0;\n\tfor(int i = 1; i <= n; i++) {\n\t\tif(dis[i] == -1) {\n\t\t\tcout << -1 << endl;\n\t\t\texit(0);\n\t\t}\n\t\ttot += dis[i];\n\t}\n\tif(tot != d[1]) {\n\t\tcout << -1 << endl;\n\t\texit(0);\n\t}\n\tfor(int i = 0; i < n-1; i++) {\n\t\tint node = v[i].second;\n\t\tcout << node << \" \" << par[node] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<iostream>\n#include<algorithm>\n#define maxn 100050\nusing namespace std;\ntypedef long long LL;\n\nint n;\nLL D[maxn];\n\nint pos[maxn];\n\nLL ans[maxn];\n\nLL size[maxn];\n\nmap<LL,int> mp;\n\nvoid init()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tpos[i]=i;\n\t\tscanf(\"%lld\",&D[i]); \n\t\tmp[D[i]]=i;\n\t}\n}\n\nint fa[maxn];\n\nbool vis[maxn];\n\nbool cmp(int i,int j)\n{\n\treturn D[i]>D[j];\n}\n\nint find(LL x)\n{\n\treturn mp.count(x)?mp[x]:0;\n}\n\nbool solve()\n{\n\tsort(pos+1,pos+n+1,cmp);\n\tfor (int k=1;k<n;++k)\n\t{\n\t\t\n\t\tint i=pos[k],j=find(D[i]+2LL*++size[i]-n);\n//\t\tcout<<\"out:\"<<i<<\" \"<<ans[i]<<endl;\n\t\t\n\t\tvis[i]=1;\n//\t\tcout<<i<<\" \"<<j<<\" \"<<D[i]+2LL*size[i]-n<<endl;\n\t\tif (!j||vis[j])\n\t\t\treturn 0;\n\t\tfa[i]=j;\n\t\tsize[j]+=size[i];\n\t\tans[j]+=ans[i]+size[i];\n\t}\n\t\n//\tcout<<ans[pos[n]]<<\" \"<<D[pos[n]]<<endl;\n\tif (ans[pos[n]]!=D[pos[n]])\n\t\treturn 0;\n//\tputs(\"YES\");\n\tfor (int k=1;k<=n;++k)\n\t{\n\t\tint u=pos[k];\n\t\tif (fa[u])\n\t\t\tprintf(\"%d %d\\n\",u,fa[u]);\n\t}\n\treturn 1;\n}\n\nint main()\n{\n//    freopen(\"c.in\",\"r\",stdin);\n//    freopen(\"c.out\",\"w\",stdout);\n    init();\n    if (!solve())\n    \tprintf(\"-1\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint n,d[200010],dp[200010],sz[200010];\nmap<int,int> mp;\nvector<pair<int,int> > edges,ans;\n\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){cin>>d[i];mp[d[i]]=i;edges.push_back(make_pair(d[i],i));}\n\tsort(edges.begin(),edges.end());\n\treverse(edges.begin(),edges.end());\n\tfor(int i=1;i<=n;i++){sz[i]=1;dp[i]=0;}\n\tfor(int i=0;i<edges.size()-1;i++){\n\t\tif(sz[edges[i].second]*2>=n){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint need=edges[i].first-(n-2*sz[edges[i].second]);\n\t\tif(!mp.count(need)){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tdp[mp[need]]+=dp[edges[i].second]+sz[edges[i].second];\n\t\tsz[mp[need]]+=sz[edges[i].second];\n\t\tans.push_back(make_pair(mp[need],edges[i].second));\n\t}\n\tif(dp[edges[edges.size()-1].second]!=edges[edges.size()-1].first){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<ans.size();i++){\n\t\tcout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nconst int N = 100010;\ntypedef long long int64;\n\nmap<int64 , int> val;\nint n , size[N] , fa[N];\n\nint64 d[N];\ntypedef pair<int64 , int> pii;\npriority_queue<pii> leaf;\n#define mp make_pair \n\nsigned main() {\n    cin >> n;\n    for(int i = 1 ; i <= n ; ++i) {\n        cin >> d[i];\n        size[i] = 1;\n        val[d[i]] = i; \n    }\n    for(int i = 1 ; i <= n ; ++i) leaf.push(mp(d[i] , i));\n\n    while(leaf.size()) {\n        int x = leaf.top().second;\n        leaf.pop();\n\n\t\tval.erase(d[x]);\n        if(val.count(d[x] - n + size[x]*2))\n            fa[x] = val[d[x] - n + size[x]*2];\n        else break;\n        \n        size[fa[x]] += size[x];\n    }\n\n    for(int i = 1 , cnt = 0; i <= n ; ++i) {\n    \tif(fa[i] == 0 && ++cnt > 1)  {cout << -1 << endl; return 0;}\n\t}\n    for(int i = 1 ; i <= n ; ++i)\n        if(fa[i]) cout << i << ' ' << fa[i] << endl;\n\t\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=100005;\nint n,size[N],st[N],to[N<<1],tto[N],last[N],Next[N<<1],edge;\nlong long D;\nstruct note{\n\tlong long dis;\n\tint x;\n}d[N];\nbool cmp(note x,note y){\n\treturn x.dis>y.dis;\n}\nusing std::map;\nmap<long long,int> m;\nvoid add(int x,int y){\n\tto[++edge]=y;\n\tNext[edge]=last[x];\n\tlast[x]=edge;\n}\nint dfs(int x,int fa,long long now){\n\tD+=now;\n\tfor (int i=last[x];i;i=Next[i])\n\t\tif (to[i]!=fa)\n\t\t\tdfs(to[i],x,now+1);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) {\n\t\tscanf(\"%lld\",&d[i].dis);\n\t\td[i].x=i;\n\t\tm[d[i].dis]=i;\n\t}\n\tstd::sort(d+1,d+n+1,cmp);\n\tfor (int i=1;i<=n;i++) size[i]=1;\n\tfor (int i=1;i<n;i++){\n\t\tlong long dis=d[i].dis;\n\t\tint x=d[i].x;\n\t\tlong long t=dis-abs(n-2*size[x]);\n\t\tint fa=m.find(t)->second;\n\t\tif (fa==x || !fa){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsize[fa]+=size[x];\n\t\tst[i]=x,tto[i]=fa;\n\t\tadd(x,fa),add(fa,x);\n\t}\n\tdfs(d[n].x,0,0);\n\tif (D!=d[n].dis){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++) printf(\"%d %d\\n\",st[i],tto[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 998244353\n#define ny 499122177\n#define maxn 1000000000000000000LL\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nlong long n,i,x,zz[100005],sum[100005];\nstruct nyh{\n\tlong long x,id;\n}o[100005];\nmap<long long,long long> mp;\nbool cmp(nyh u,nyh v){\n\treturn u.x<v.x;\n}\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tcout<<-1<<endl;\n\treturn 0;\n\tn=read();\n\tfor(i=1;i<=n;i++){\n\t\to[i].x=read();\n\t\to[i].id=i;\n\t}\n\tsort(o+1,o+n+1,cmp);\n\tfor(i=1;i<=n;i++){\n\t\tmp[o[i].x]=i;\n\t\tsum[i]=1;\n\t}\n\tfor(i=n;i>=2;i--){\n\t\tx=o[i].x-n+sum[i]*2;\n\t\tif(mp[x]!=0&&mp[x]<i){\n\t\t\tzz[i]=mp[x];\n\t\t\tsum[zz[i]]+=sum[i];\n\t\t}\n\t\telse{\n\t\t\tpus(-1,2);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(i=n;i>=2;i--){\n\t\tpus(o[zz[i]].id,1);\n\t\tpus(o[i].id,2);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//4182_543_731 is vegetable\n#include<cstdio>\n#include<map>\n#include<algorithm>\n#define N 1000400\nusing namespace std;\nint n,v2[N],fa[N];\nlong long v[N],sz[N],ds[N];\nmap<long long,int> tp;\nbool cmp(int a,int b){return v[a]<v[b];}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&v[i]),tp[v[i]]=i,v2[i]=i,sz[i]=1;\n\tsort(v2+1,v2+n+1,cmp);\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tlong long tp2=v[v2[i]]-n+sz[v2[i]]*2;\n\t\tif(!tp[tp2]){printf(\"-1\\n\");return 0;}\n\t\tint sb=tp[tp2];\n\t\tds[sb]+=ds[v2[i]]+sz[v2[i]];\n\t\tsz[sb]+=sz[v2[i]];\n\t\tfa[v2[i]]=sb;\n\t}\n\tif(ds[v2[1]]!=v[v2[1]]){printf(\"-1\\n\");return 0;}\n\tfor(int i=1;i<=n;i++)if(fa[i])printf(\"%d %d\\n\",i,fa[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<iomanip>\n#include<cstring>\n#include<algorithm>\n#include<ctime>\n#define int long long\nusing namespace std;\ninline int read()\n{\n\tint kkk=0,x=1;\n\tchar c=getchar();\n\twhile((c<'0' || c>'9') && c!='-')\n\t\tc=getchar();\n\tif(c=='-')\n\t\tc=getchar(),x=-1;\n\twhile(c>='0' && c<='9')\n\t\tkkk=(kkk<<3)+(kkk<<1)+(c-'0'),c=getchar();\n\treturn kkk*x;\n}\nint n;\nstruct sb\n{\n\tint sum,id,size,fa;\n}a[100001];\ninline int cmp(sb x,sb y)\n{\n\treturn x.sum>y.sum;\n}\ninline int find(int V)\n{\n\tint l=1,r=n,bck=0;\n\twhile(l<=r)\n\t{\n\t\tint mid=(l+r)/2;\n\t\tif(a[mid].sum>=V)\n\t\t\tbck=mid,l=mid+1;\n\t\telse\n\t\t\tr=mid-1;\n\t}\n\treturn bck;\n}\nsigned main()\n{\n\tn=read();\n\tfor(register int i=1;i<=n;++i)\n\t{\n\t\ta[i].id=i;\n\t\ta[i].sum=read();\n\t\ta[i].size=1;\n\t}\n\tsort(a+1,a+n+1,cmp);\n\ta[0].sum=0x7f7f7f7f7f7f7f7f;\n\tfor(register int i=1;i<n;++i)\n\t{\n\t\tint sum=a[i].sum+a[i].size-(n-a[i].size);\n\t\tif(sum<n-1 || sum>=a[i].sum)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint zone=find(sum);\n\t\tif(a[zone].sum!=sum)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\ta[zone].size+=a[i].size;\n\t\ta[i].fa=zone;\n\t}\n\tfor(register int i=1;i<n;++i)\n\t\tprintf(\"%lld %lld\\n\",a[i].id,a[a[i].fa].id);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<math.h>\n#include<vector>\n#include<queue>\n#include<map>\n#include<stack>\n#include<fstream>\n#include<stdlib.h>\n#include<set>\n#include<climits>\n#include<cmath>  \n#include<memory.h> \n#include<sstream>\n#include<time.h>\n#include<iomanip>\nusing namespace std;\nconst unsigned long long BIGEST=1000000000000000000+1000000000000000000;\nconst long long BIGER=1000000000000000000;\nconst int BIG=1000000000;\nconst long long MOD=1000000007;\nconst long long LMOD=998244353;\n//const long long LMOD=1000000007;\n#define Fi first\n#define Se second\n#define P2 pair\n#define Pii pair<int,int>\n#define Cb make_pair\n#define ll long long\n#define Ull unsigned long long\n#define Sf scanf\n#define Pf printf\n#define Pb push_back\n#define Psh push\n#define Stc stack\n#define Vct vector\n#define Ret return\n#define Re0 return 0\n#define Sz size\n#define Ins insert\n#define Que queue\n#define Emp empty\n#define Fro front\n#define Rv reverse\n#define Er erase\n#define Bg begin\n#define Srt sort\n#define Pq priority_queue\nll a[100001];\nll n;\nset<Pii>st;\nll dd[100001];\nmap<ll,ll>mp;\nll c[100001];\nll dm[100001];\nll p[100001];\nint main()\n{\n\tSf(\"%lld\",&n);\n\tfor(ll i=1;i<=n;i++)\n\t{\n\t\tSf(\"%lld\",&a[i]);\n\t\tst.Ins(Cb(-a[i],i));\n\t\tmp[-a[i]]=i;\n\t}\n\tPii uv;\n\tll u,v;\n\tPii t;\n\tfor(ll i=1;i<n;i++)\n\t{\n\t\tuv=*st.begin();\n\t\tu=uv.Fi;\n\t\tv=uv.Se;\n\t\t//cout<<u<<\" \"<<v<<endl;\n\t\tst.erase(uv);\n\t\tc[v]++;\n\t\tif(mp[u+(n-2*c[v])]==0)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\tRet 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//t=Cb(u+c[v]+dm[v]+1,mp[u+c[v]+dm[v]+1]);\n\t\t\tt=Cb(u+(n-2*c[v]),mp[u+(n-2*c[v])]);\n\t\t\t//cout<<\">\"<<t.Fi<<\" \"<<t.Se<<endl;\n\t\t\tif(!st.count(t))\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\tRet 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tc[t.Se]+=c[v];\n\t\t\t\tdm[t.Se]+=c[v]+dm[v];\n\t\t\t\tst.erase(uv);\n\t\t\t\t//st.erase(t);\n\t\t\t\t//st.Ins(Cb(-a[t.Se]+dm[t.Se],t.Se));\n\t\t\t\t//cout<<\">>\"<<-a[t.Se]+dm[t.Se]<<\" \"<<t.Se<<endl;\n\t\t\t\tp[v]=t.Se;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(ll i=1;i<=n;i++)\n\t{\n\t\tcout<<p[i];\n\t}\n\t*/\n\t//cout<<(*st.begin()).Fi<<\" \"<<endl;\n\t\n\tif(-(*st.begin()).Fi!=a[(*st.begin()).Se])\n\t{\n\t\tcout<<\"-1\";\n\t\treturn 0;\n\t}\n\tfor(ll i=1;i<=n;i++)\n\t{\n\t\tif(p[i])\n\t\t{\n\t\t\tPf(\"%lld %lld\\n\",p[i],i);\n\t\t}\n\t}\n\tRet 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N;\n\tcin >> N;\n\tvector< pair<cat, int> > D(N);\n\tfor(int i = 0; i < N; i++) {\n\t\tcin >> D[i].ff;\n\t\tD[i].ss = i;\n\t}\n\tsort(begin(D), end(D));\n\tmap<cat, int> M;\n\tfor(int i = 0; i < N; i++) M[D[i].ff] = i;\n\tvector<int> sz(N, 1);\n\tvector< pair<int, int> > E;\n\tfor(int i = N-1; i > 0; i--) {\n\t\tif(2*sz[i] >= N) {\n\t\t\tcout << \"-1\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tcat D_up = D[i].ff + sz[i] - (N-sz[i]);\n\t\tauto it = M.find(D_up);\n\t\tif(it == M.end()) {\n\t\t\tcout << \"-1\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tsz[it->ss] += sz[i];\n\t\tE.push_back({D[i].ss, D[it->ss].ss});\n\t}\n\tif(sz[0] != N) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\tfor(int i = 0; i < (int)E.size(); i++) cout << E[i].ff+1 << \" \" << E[i].ss+1 << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\nusing namespace std;\nstruct node\n{\n\tlong long d;\n\tint id;\n\tfriend bool operator < (node a,node b){return a.d>b.d;}\n}p[100010];\nint n,siz[100010],ans[100010][2];\nmap<long long,int>mp;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)scanf(\"%lld\",&p[i].d),p[i].id=i;\n\tsort(p+1,p+1+n);\n\tfor(int i=1;i<=n;++i)mp[p[i].d]=p[i].id,siz[i]=1;\n\tfor(int i=1;i<n;++i)\n\t{\n\t//\tprintf(\"%lld %d\\n\",p[i].d,n-2*siz[p[i].id]);\n\t\tmp.erase(p[i].d);\n\t\tif(!mp.count(p[i].d-n+2*siz[p[i].id]))return printf(\"-1\"),0;\n\t\tans[i][0]=p[i].id,ans[i][1]=mp[p[i].d-n+2*siz[p[i].id]];\n\t\tsiz[ans[i][1]]+=siz[ans[i][0]];\n\t}\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <limits.h>\n#include <math.h>\n#include <functional>\n#include <bitset>\n\n#define repeat(i,n) for (long long i = 0; (i) < (n); ++ (i))\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define debugArray(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i] << '\\n'\n#define debugArrayP(x,n) for(long long i = 0; (i) < (n); ++ (i)) cerr << #x << \"[\" << i << \"]: \" << x[i].first<< \" \" << x[i].second << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\nconst ll INF = LLONG_MAX/10;\nconst ll MOD = 1e9+7;\n\nint main(){\n  int N;cin>>N;\n  vector<Pii> D(N);\n  repeat(i,N){\n    cin >> D[i].first;\n    D[i].second = i+1;\n  }\n  sort(D.begin(),D.end());\n  vll n(N,1);\n  vector<Pii> edges;\n  bool isok = true;\n  for(int i=N-1;i>0;i--){\n    debug(i);\n    ll S = D[i].first+2*n[i]-N;\n    int j = lower_bound(D.begin(),D.end(),Pii(S,0))-D.begin();\n    if(j>=i || D[j].first != S){\n      isok = false;\n      break;\n    }\n    edges.push_back({D[i].second,D[j].second});\n    n[j]+=n[i];\n  }\n  if(!isok){\n    cout <<-1<<endl;\n    return 0;\n  }\n  repeat(i,edges.size()){\n    cout << edges[i].first<<\" \"<<edges[i].second<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int MAXN=100010;\nll n,dis,d[MAXN],siz[MAXN];\nmap <ll,int> mp;\npair <int,int> v[MAXN];\nint main () {\n\tscanf(\"%lld\",&n);\n\tfor (int i=1;i<=n;i++) {\n\t\tscanf(\"%lld\",&d[i]);\n\t\tmp[d[i]]=i,siz[i]=1;\n\t}\n\tsort(d+1,d+n+1);\n\tfor (int i=n;i>1;i--) {\n\t\tint p=mp[d[i]];\n\t\tll d2=d[i]-(n-siz[p])+siz[p];\n\t\tif (mp.find(d2)==mp.end()) {printf(\"-1\\n\");return 0;}\n\t\tint q=mp[d2];\n\t\tsiz[q]+=siz[p];\n\t\tdis+=siz[p];\n\t\tv[n-i+1]=make_pair(p,q);\n\t}\n\tif (d[1]!=dis) {printf(\"-1\\n\");return 0;}\n\tfor (int i=1;i<n;i++) {\n\t\tprintf(\"%d %d\\n\",v[i].first,v[i].second);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\nconst int N = 2e5;\nint n, cnt;\nint fa[N], ff[N];\nLL di[N], siz[N];\nmap <LL, int> val;\npair <int, int> edges[N];\nint ord[N];\nint get_f(int t)\n{\n    if (ff[t] == t) return t;\n    else return ff[t] = get_f(ff[t]);\n}\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; ++ i) scanf(\"%lld\", &di[i]);\n    for (int i = 1; i <= n; ++ i) ord[i] = i, val[di[i]] = i, ff[i] = i;\n    sort(ord + 1, ord + n + 1, [=](int a, int b) {return di[a] > di[b];});\n    for (int i = 1; i < n; ++ i)\n    {\n        int p = ord[i];\n        siz[p] += 1;\n        LL q = di[p] + siz[p] * 2 - n;\n        if (!val.count(q)) {puts(\"-1\"); return 0;}\n        fa[p] = val[q];\n        if (ord[p] < ord[fa[p]]) {puts(\"-1\"); return 0;}\n        if (get_f(p) == get_f(fa[p])) {puts(\"-1\"); return 0;}\n        ff[get_f(p)] = get_f(fa[p]);\n        siz[fa[p]] += siz[p];\n        edges[i] = make_pair(p, fa[p]);\n    }\n    for (int i = 1; i < n; ++ i) printf(\"%d %d\\n\", edges[i].first, edges[i].second);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <tr1/unordered_map>\n\n#define For(i, l, r) for (int i = l; i <= r; ++ i)\n#define Forr(i, r, l) for (int i = r; i >= l; -- i)\n#define Travel(i, u) for (int i = beg[u], v = to[i]; i; v = to[i = nex[i]])\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline void File() {\n\tfreopen(\"f.in\", \"r\", stdin);\n\tfreopen(\"f.out\", \"w\", stdout);\n}\n\nconst int N = 1e5 + 10;\nint e = 1, beg[N], nex[N << 1], to[N << 1], n;\nint ansu[N], ansv[N];\nll sz[N], tmp, dis[N];\n\nstruct node { ll v; int id; } P[N];\ninline bool cmp(const node &a, const node &b) { return a.v > b.v; }\n\ntr1::unordered_map<ll, int> mp;\n\ninline void add(int x, int y) {\n\tto[++ e] = y, nex[e] = beg[x], beg[x] = e;\n}\n\ninline void dfs1(int u, int l, int rt) {\n\tdis[rt] += l;\n\tTravel(i, u) dfs1(v, l + 1, rt);\n}\n\ninline void dfs2(int u) {\n\tTravel(i, u) dis[v] = dis[u] - (sz[v] * 2 - n), dfs2(v);\n}\n\nint main() {\n\n\tscanf(\"%d\", &n);\n\tFor(i, 1, n) {\n\t\tscanf(\"%lld\", &P[i].v); \n\t\tP[i].id = i, mp[P[i].v] = i, sz[i] = 1;\n\t}\n\n\tsort(P + 1, P + 1 + n, cmp);\n\n\tfor (int i = 1, u, v; i < n; ++ i) {\n\t\tu = P[i].id, tmp = P[i].v + 2 * sz[u] - n;\n\t\t\n\t\tif (n <= sz[u] << 1) return puts(\"-1\"), 0;\n\t\tif (!mp.count(tmp)) return puts(\"-1\"), 0;\n\t\t\n\t\tv = mp[tmp], ansu[i] = u, ansv[i] = v;\n\t\tadd(v, u), sz[v] += sz[u];\n\t}\t\n\n\tint rt = P[n].id; dfs1(rt, 0, rt), dfs2(rt);\n\n//\tFor(i, 1, n) cout << P[i].id << ' '; cout << endl;\n//\tFor(i, 1, n) cout << P[i].v << ' ' << dis[P[i].id] << endl;\n\tFor(i, 1, n) if (dis[P[i].id] ^ P[i].v) return puts(\"-1\"), 0;\n\t\n\tFor(i, 1, n - 1) printf(\"%d %d\\n\", ansu[i], ansv[i]);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid err() {\n  cout << -1 << endl;\n  exit(0);\n}\nvoid dfs (int crr, int dpt, vector<vector<int>>& grh, long long& cnt) {\n  cnt += dpt;\n  for (int nxt : grh[crr]) {\n    dfs(nxt, dpt + 1, grh, cnt);\n  }\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<long long> d(n);\n  map<long long, int> mp;\n  for (int i = 0; i < n; i++) {\n    cin >> d[i];\n    mp[d[i]] = i;\n  }\n  sort(d.begin(), d.end());\n  vector<long long> sz(n, 1);\n  vector<vector<int>> grh(n);\n  vector<pair<int, int>> edg;\n  for (auto it = d.rbegin(); next(it) != d.rend(); it++) {\n    auto i = mp.rbegin()->second;\n    long long wnt = *it - n + 2 * sz[i];\n    if (mp.find(wnt) == mp.end()) err();\n    auto p = mp[wnt];\n    sz[p] += sz[i];\n    grh[p].push_back(i);\n    edg.emplace_back(i, p);\n    mp.erase(--mp.end());\n  }\n  int rt = mp.begin()->second;\n  long long cnt = 0;\n  dfs(rt, 0, grh, cnt);\n  if (d[0] != cnt) err();\n  for (auto const& e : edg) {\n    cout << e.first + 1 << ' ' << e.second + 1 << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=1e5+10;\nint n,cnt,e,f[N],a[N],id[N],w[N],siz[N],res[N],head[N],link[N],to[N];\nbool vis[111111];\nbool cmp(int x,int y){return a[x]<a[y];}\nvoid add(int u,int v){to[++e]=v,link[e]=head[u],head[u]=e;}\nvoid dfs1(int u){\n\tsiz[u]=1;\n\tfor(int i=head[u];i;i=link[i])if(to[i]!=f[u])dfs1(to[i]),siz[u]+=siz[to[i]];\n}\nvoid dfs2(int u){for(int i=head[u];i;i=link[i])if(to[i]!=f[u])res[to[i]]=res[u]+n-2*siz[to[i]],dfs2(to[i]);}\nsigned main(){\n\tscanf(\"%lld\",&n),w[0]=-LLONG_MAX;\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),id[i]=i,w[i]=a[i],siz[i]=1;\n\tsort(id+1,id+n+1,cmp),sort(w+1,w+n+1);\n\tfor(int i=n;i>1;i--){\n\t\tint x=2*siz[id[i]]-n+a[id[i]],pos=lower_bound(w+1,w+n+1,x)-w;\n\t\tif(w[pos]!=x||n-2*siz[id[i]]<=0){printf(\"-1\");return 0;}\n\t\tadd(id[pos],id[i]),siz[id[pos]]+=siz[id[i]],f[id[i]]=id[pos];\n\t}\n\tres[id[1]]=w[1],dfs1(id[1]),dfs2(id[1]);\n\tfor(int i=1;i<=n;i++)if(a[i]!=res[i])printf(\"-1\");return 0;\n\tfor(int i=2;i<=n;i++)printf(\"%lld %lld\\n\",f[id[i]],id[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <bitset>\n#include <deque>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include<stdio.h>\n#include<map>\n#include<algorithm>\n#include<cstdio>\n#include <math.h>\n#include<cmath>\n#define inc(i,a,b) for(register int i=a;i<=b;i++)\n#define dec(i,a,b) for(register int i=a;i>=b;i--)\nusing namespace std;\ntypedef long long LL;\ninline void read(int &x)\n{\n\tx=0;bool f=0;char c=getchar();\n\twhile(c>'9'||c<'0'){if(c=='-')f=1;c=getchar();}\n\twhile(c<='9'&&c>='0')x=(x<<3)+(x<<1)+c-'0',c=getchar();\n\tif(f)x=-x;return;\n}\ninline void read(LL &x)\n{\n\tx=0;bool f=0;char c=getchar();\n\twhile(c>'9'||c<'0'){if(c=='-')f=1;c=getchar();}\n\twhile(c<='9'&&c>='0')x=(x<<3)+(x<<1)+c-'0',c=getchar();\n\tif(f)x=-x;return;\t\n}\nconst int mx=100007;\nstruct node\n{\n\tint n,t,u;\n}nx[mx];\nint n,siz[mx],cnt,h[mx];\npair <LL,int> d[mx];\n#define f first\n#define s second\nvoid add(int u,int v)\n{\n\tnx[++cnt].n=h[u];\n\tnx[cnt].u=u;\n\tnx[cnt].t=v;\n\th[u]=cnt;\n}\nint find(LL x)\n{\n\tint l=1,r=n,mid=(l+r)>>1;\n\twhile(l<=r)\n\t{\n\t\tif(d[mid].f==x)return mid;\n\t\tif(d[mid].f<x)l=mid+1;\n\t\telse r=mid-1;mid=(l+r)>>1;\n\t}\n\treturn 0;\n}\nLL check;\n#define link(i,x) for(register int i=h[x];i;i=nx[i].n)\nLL dfs(int x,LL upp)\n{\n\tLL res=upp;\n\tlink(i,x)res+=dfs(nx[i].t,upp+1);\n\treturn res;\n}\nint main()\n{\n\tread(n);\n\tinc(i,1,n)\n\t{\n\t\tread(d[i].f);\n\t\td[i].s=i;\n\t\tsiz[i]=1;\n\t}\n\tsort(d+1,d+n+1);\n\tdec(i,n,2)\n\t{\n\t\tint fr=find(d[i].f+(siz[i]<<1)-n);\n\t\tif(fr)add(fr,i),siz[fr]+=siz[i];\n\t\telse {printf(\"-1\\n\");return 0;}\n\t}\n\tcheck=dfs(1,0);\n\tif(check!=d[1].f)return 0;\n\tinc(i,1,cnt)printf(\"%d %d\\n\",d[nx[i].u].s,d[nx[i].t].s);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=1e5+10;\nstruct point{\n\tll x;\n\tint id;\n\tbool operator <(const point &rhs) const{\n\t\treturn x<rhs.x || (x==rhs.x && id<rhs.id);\n\t}\n}a[maxn];\nll sum;\nint fa[maxn],sz[maxn];\nint main(){\n\tint n=read();\n\tREP(i,1,n) a[i].x=readll(),a[i].id=i;\n\tsort(a+1,a+n+1);\n\tDREP(i,n,2){\n\t\tsz[i]++;\n\t\tll Nxt=a[i].x-n+sz[i]*2;\n\t\tint u=lower_bound(a+1,a+n+1,(point){Nxt,0})-a;\n\t\tif(a[u].x!=Nxt) return printf(\"-1\\n\"),0;\n\t\tsz[u]+=sz[i],fa[a[i].id]=a[u].id;\n\t}\n\tREP(i,2,n) sum+=sz[i];\n\tif(sum!=a[1].x) return printf(\"-1\\n\"),0;\n\tREP(i,1,n) if(fa[i]) printf(\"%d %d\\n\",fa[i],i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) {cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl;}\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}\nbool operator<(const TRI&_)const{return(fi==_.fi)?((se==_.se)?(th<_.th):(se<_.se)):(fi<_.fi);}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<ll, ll> P;\n\nconst int MAX_N = 100005;\n\nvector<int> G[MAX_N];\nll D;\n\nvoid dfs(int u, int p, int d){\n    D += d;\n    for(int v : G[u]){\n        if(v != p) dfs(v, u, d+1);\n    }\n}\n\nunordered_map<ll, int> mp;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    set<P> st;\n    ll ch = 0;\n    rep(i,n){\n        ll d;\n        cin >> d;\n        if(i == 0) ch = d;\n        mp[d] = i;\n        st.insert(P(d, 1));\n    }\n    vector<pair<int, int> > vec;\n    while(len(st) > 1){\n        auto p = *(--st.end());\n        st.erase(--st.end());\n        auto it = st.lower_bound(P(p.fi+2*p.se-n, -INF));\n        if(it->fi != p.fi+2*p.se-n){\n            cout << \"-1\\n\";\n            return 0;\n        }\n        G[mp[p.fi]].pb(mp[it->fi]);\n        G[mp[it->fi]].pb(mp[p.fi]);\n        vec.emplace_back(mp[p.fi], mp[it->fi]);\n        P nw = P(it->fi, it->se + p.se);\n        st.erase(it);\n        st.insert(nw);\n    }\n    dfs(0, -1, 0);\n    if(D != ch){\n        cout << \"-1\\n\";\n        return 0;\n    }\n    rep(i,n-1){\n        cout << vec[i].fi+1 << \" \" << vec[i].se+1 << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int N=100005;\nint n,size[N],st[N],to[N<<1],tto[N],last[N],Next[N<<1],edge;\nlong long D;\nstruct note{\n\tlong long dis;\n\tint x;\n}d[N];\nbool cmp(note x,note y){\n\treturn x.dis>y.dis;\n}\nusing std::map;\nmap<long long,int> m;\nvoid add(int x,int y){\n\tto[++edge]=y;\n\tNext[edge]=last[x];\n\tlast[x]=edge;\n}\nint dfs(int x,int fa,long long now){\n\tD+=now;\n\tfor (int i=last[x];i;i=Next[i])\n\t\tif (to[i]!=fa)\n\t\t\tdfs(to[i],x,now+1);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) {\n\t\tscanf(\"%lld\",&d[i].dis);\n\t\td[i].x=i;\n\t\tm[d[i].dis]=i;\n\t}\n\tstd::sort(d+1,d+n+1,cmp);\n\tfor (int i=1;i<=n;i++) size[i]=1;\n\tfor (int i=1;i<n;i++){\n\t\tlong long dis=d[i].dis;\n\t\tint x=d[i].x;\n\t\tlong long t=dis-abs(n-2*size[x]);\n\t\tint fa=m.find(t)->second;\n\t\tif (fa==x || !fa){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsize[fa]+=size[x];\n\t\tst[i]=x,tto[i]=fa;\n\t\tadd(x,fa),add(fa,x);\n\t}\n\tdfs(d[n].x,0,0);\n\tif (D!=d[n].dis){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++) printf(\"%d %d\\n\",st[i],tto[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<map>\n#include<vector>\n#include<queue>\n#include<deque>\n#define ll long long\n#define mp make_pair\n#include<bits/stdc++.h> \n#define rep(i,x,y) for(int i=(x);i<=(y);++i)\n#define r0p(i,n) for(int i=0;i<n;++i)\n#pragma GCC optimize(1)\n#pragma G++ optimize(1)\n#pragma GCC optimize(2)\n#pragma G++ optimize(2)\n#pragma GCC optimize(3)\n#pragma G++ optimize(3)\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#define pii pair<int,int>\n#pragma GCC diagnostic error \"-std=c++11\"\nusing namespace std;\ninline void rdl(long long &val){\n    long long x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n\t}\n\twhile(ch>='0' and ch<='9'){\n\t    x=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n    val=x*f;\n}\ninline void rdi(int &val){\n    int x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    val=x*f;\n}\ninline long long rdl(){\n    long long x=0;\n    int f=1;\n    char ch=getchar();\n    while((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n    if(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline int rdi(){\n    int x=0;\n    int f=1;\n\tchar ch=getchar();\n\twhile((ch<'0' or ch>'9') and ch!='-') ch=getchar();\n\tif(ch=='-'){\n        f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' and ch<='9'){\n        x=(x<<3)+(x<<1)+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\ninline void write(int x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\ninline void _write(int x){\n\twrite(x);\n\tputchar(' ');\n}\ninline void print(int x){\n\twrite(x);\n\tputchar('\\n');\n}\ninline void write(ll x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\ninline void _write(ll x){\n\twrite(x);\n\tputchar(' ');\n}\ninline void print(ll x){\n\twrite(x);\n\tputchar('\\n');\n}\nstruct dsu{\n\tint par[200200];\n\tinline void init(int _n){for(int i=0;i<_n;++i) par[i]=i;}\n\tinline int find(int now){\n\t\tif(par[now]==now) return now;\n\t\treturn par[now]=find(par[now]);\n\t}\n\tinline bool uni(int a, int b){\n\t\tint Pa(find(a)),Pb(find(b));\n\t\tif(Pa==Pb) return false;\n\t\tpar[Pa]=Pb;\n\t\treturn true;\n\t}\n};\nint main(){\n\tint n,i,j;\n\trdi(n);\n\tvector<ll> d(n);\n\tvector<int> sz(n,1);\n\tmap<ll,int> m;\n\tfor(i=0;i<n;++i){\n\t\trdl(d[i]);\n\t\tm[d[i]]=i;\n\t}\n\tvector<pair<int,int> >ans;\n\tfor(int It=0;It<n-1;++It){\n\t\tauto it=m.begin();\n\t\ti=it->second;\n\t\tll need=d[i]-(n-sz[i])+sz[i];\n\t\tif(m.find(need)==m.end()) return 0*puts(\"-1\");\n\t\tj=m[need];\n\t\tans.emplace_back(i,j);\n\t\tsz[i]+=sz[j];\n\t\tm.erase(--m.end());\n\t}\n\tvector<ll> rd(n,-1);\n\trd[0]=0;\n\tvector<vector<int> >g(n);\n\tfor(auto p:ans){\n\t\tg[p.first].push_back(p.second);\n\t\tg[p.second].push_back(p.first);\n\t}\n\tvector<int> q(1,0);\n\tfor(i=0;i<q.size();++i){\n\t\tfor(int j:g[q[i]]){\n\t\t\tif(!~rd[j]){\n\t\t\t\tq.push_back(j);\n\t\t\t\trd[j]=rd[q[i]]+1;\n\t\t\t}\n\t\t}\n\t}\n\tif(accumulate(rd.begin(),rd.end(),0ll)!=d[0]) return puts(\"-1\")*0;\n\tfor(pair<int,int>p:ans) _write(p.first),print(p.second);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(i,a,n) for(int i=a;i<=n;++i)\n#define PER(i,a,n) for(int i=n;i>=a;--i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(a) ({REP(__i,1,n) cout<<a[__i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\n\n\nconst int N = 1e6+10;\nint n, sz[N];\nstruct _ {\n\tll d;\n\tint id;\n\tbool operator < (const _ &rhs) const {\n\t\treturn d<rhs.d;\n\t}\n} a[N];\nvector<pii> ans;\nvector<int> g[N];\n\nvoid add(int u, int v) {\n\tans.pb(pii(u,v));\n\tg[u].pb(v),g[v].pb(u);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tREP(i,1,n) { \n\t\tscanf(\"%lld\",&a[i].d);\n\t\ta[i].id = i, sz[i] = 1;\n\t}\n\tsort(a+1,a+1+n);\n\tPER(i,2,n) {\n\t\t_ u{a[i].d+2*sz[a[i].id]-n,0};\n\t\tauto p = lower_bound(a+1,a+1+n,u);\n\t\tif (p->d!=u.d) return puts(\"-1\"),0;\n\t\tadd(a[i].id,p->id), sz[p->id] += sz[a[i].id];\n\t}\n\tif (sz[a[1].id]!=n) return puts(\"-1\"),0;\n\tfor (auto &t:ans) printf(\"%d %d\\n\",t.x,t.y);\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define ln                '\\n'\n#define all(dat)           dat.begin(), dat.end()\n#define loop(i, to)        for (int i = 0; i < to; ++i)\n#define cont(i, to)        for (int i = 1; i <= to; ++i)\n#define circ(i, fr, to)    for (int i = fr; i <= to; ++i)\n#define foreach(i, dat)    for (__typeof(dat.begin()) i = dat.begin(); i != dat.end(); ++i)\n\ntypedef long long          num;\n\nusing namespace std;\n\nconst int nsz = 1e5;\nint n, rt, siz[nsz + 5];\nnum w[nsz + 5];\nmap<num, int> id, to;\nvector<int> g[nsz + 5];\nvector<pair<int, int>> ans;\n\nnum inline cmp(num a, num b) {\n    return a > b;\n}\n\nint calc(int u = rt, int dep = 0) {\n    int res = dep;\n    for (int v : g[u]) {\n        res += calc(v, dep + 1);\n    }\n    return res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> n;\n    rt = n;\n    cont (i, n) {\n        cin >> w[i];\n        to[w[i]] = i;\n    }\n    fill(siz, siz + sizeof(siz) / sizeof(int), 1);\n    sort(w + 1, w + n + 1, cmp);\n    cont (i, n) {\n        id[w[i]] = i;\n    }\n    cout << ln;\n    cont (u, n) {\n        if (u == rt)  continue;\n        int v = id[w[u] - n + 2 * siz[u]];\n        if (!v) {\n            cout << -1 << ln;\n            return 0;\n        }\n        siz[v] += siz[u];\n        g[v].push_back(u);\n        ans.push_back({to[w[u]], to[w[v]]});\n    }\n    if (calc() != w[n]) {\n        cout << -1 << ln;\n        return 0;\n    }\n    for (pair<int, int> p : ans) {\n        cout << p.first << ' ' << p.second << ln;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pii_ pair<int,int>\n#define mp_ make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define show1(a) cout<<#a<<\" = \"<<a<<endl\n#define show2(a,b) cout<<#a<<\" = \"<<a<<\"; \"<<#b<<\" = \"<<b<<endl\nusing namespace std;\nconst ll INF = 1LL<<60;\nconst int inf = 1<<30;\nconst int maxn = 1e5+5;\ninline void fastio() {ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);}\nvoid GG()\n{\n    cout<<-1<<endl;\n    exit(0);\n}\nint n,sz[maxn];\nstruct node\n{\n    int id;\n    ll d;\n    bool operator < (const node e) const {\n        return d>e.d;\n    }\n}tr[maxn];\nvector<pii_> e;\nint main()\n{\n    fastio();\n    cin>>n;\n    rep(i,1,n){\n        cin>>tr[i].d; tr[i].id = i;\n    }\n    sort(tr+1,tr+n+1);\n    rep(i,1,n) sz[i] = 1;\n    rep(i,1,n){\n        ll dfa = tr[i].d+2*sz[tr[i].id]-n;\n        if(lower_bound(tr+1,tr+n+1,(node){0,dfa}) == tr+n+1) GG();\n        node fa = *lower_bound(tr+1,tr+n+1,(node){0,dfa});\n        if(fa.d!=dfa || fa.id==tr[i].id) GG();\n        sz[fa.id] += sz[tr[i].id];\n        e.pb(mp_(tr[i].id,fa.id));\n    }\n    for(auto x:e){\n        cout<<x.fi<<\" \"<<x.se<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,cnt,a[111111],id[111111],w[111111],u[111111],v[111111];\nbool vis[111111];\nbool cmp(int x,int y){return a[x]<a[y];}\nvoid add(int x,int y){u[++cnt]=x,v[cnt]=y;}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]),id[i]=i,w[i]=a[i];\n\tsort(id+1,id+n+1,cmp),sort(w+1,w+n+1);\n\tfor(int i=n;i>=1;i--)if(!vis[id[i]]){\n\t\tint k=id[i],siz=1;\n\t\twhile(1){\n\t\t\tvis[k]=1;\n\t\t\tint x=siz*2-n+a[k],pos=lower_bound(w+1,w+n+1,x)-w;\n\t\t\tif(w[pos]!=x)break;\n\t\t\tadd(id[pos],k);\n\t\t\tif(vis[id[pos]]||pos==1)break;\n\t\t\tk=id[pos],siz++;\n\t\t}\n\t}\n\tif(cnt!=n-1){printf(\"-1\");return 0;}\n\tfor(int i=1;i<=cnt;i++)printf(\"%d %d\\n\",u[i],v[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int MAXN = 1e05 + 10;\n\nint N;\npair<LL, int> d[MAXN];\n\nint subsize[MAXN]= {0}, fa[MAXN]= {0};\nvoid solve () {\n\tfor (int i = N; i > 1; i --) {\n\t\tsubsize[d[i].second] ++;\n\t\tint up = N - 2 * subsize[d[i].second];\n\t\tif (up < 0) { puts (\"-1\"); exit (0); }\n\t\tint p = lower_bound (d + 1, d + N + 1, make_pair (d[i].first - up, 0)) - d;\n\t\tif (p >= i || d[p].first != d[i].first - up) { puts (\"-1\"); exit (0); }\n\t\tfa[d[i].second] = d[p].second;\n\t\tsubsize[d[p].second] += subsize[d[i].second];\n\t}\n}\n\nvector<int> G[MAXN];\nLL dist[MAXN]= {0}, total = 0;\nvoid DFS (int root) {\n\ttotal += dist[root];\n\tfor (int i = 0; i < (int) G[root].size(); i ++) {\n\t\tint v = G[root][i];\n\t\tdist[v] = dist[root] + 1;\n\t\tDFS (v);\n\t}\n}\n\ninline LL getnum () {\n\tLL num = 0; char ch = getchar ();\n\twhile (! isdigit (ch)) ch = getchar ();\n\twhile (isdigit (ch)) num = (num << 3) + (num << 1) + ch - '0', ch = getchar ();\n\treturn num;\n}\n\nint main () {\n\t// freopen (\"33.txt\", \"r\", stdin);\n\n\tN = getnum ();\n\tfor (int i = 1; i <= N; i ++) d[i].first = getnum (), d[i].second = i;\n\tsort (d + 1, d + N + 1);\n\tsolve ();\n\tfor (int i = 2; i <= N; i ++) G[fa[d[i].second]].push_back(d[i].second);\n\tDFS (d[1].second);\n\tif (total != d[1].first) { puts (\"-1\"); return 0; }\n\tfor (int i = 2; i <= N; i ++)\n\t\tprintf (\"%d %d\\n\", fa[d[i].second], d[i].second);\n\n\treturn 0;\n}\n\n/*\n7\n10\n15\n13\n18\n11\n14\n19\n*/\n\n/*\n2\n1\n2\n*/"
  },
  {
    "language": "C++",
    "code": "// Ho-kago Tea Time\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MAXN = (int) 1e5;\n\nint n;\n\nstruct node\n{\n\tint u;\n\tLL D;\n\n\tinline bool operator < (const node &rhs) const { return this->D < rhs.D; }\n\n\tnode() { }\n\tnode(int _u, LL _D): u(_u), D(_D) { }\n}d[MAXN + 5];\n\nLL D[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tfor(int i = 1; i <= n; ++i) d[i] = node(i, D[i] = read<LL>());\n}\n\nint size[MAXN + 5];\nvector<int> adj[MAXN + 5];\n\ninline LL dfs_sum(int u)\n{\n\tLL res = size[u] - 1;\n\tfor(auto v : adj[u]) res += dfs_sum(v);\n\treturn res;\n}\n\ninline int dfs_chk(int u, LL D0)\n{\n\tif(D[u] != D0) return 0;\n\tfor(auto v : adj[u]) if(!dfs_chk(v, D0 - size[v] + n - size[v])) return 0;\n\treturn 1;\n}\n\ninline void solve()\n{\n\tstatic priority_queue<node> Q;\n\tstatic unordered_map<LL, int> id;\n\tstatic int vis[MAXN + 5];\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tQ.push(d[i]);\n\t\tid[d[i].D] = d[i].u;\n\t\tsize[d[i].u] = 1;\n\t}\n\n\tstatic vector<pii> E;\n\n\twhile(SZ(Q) > 1)\n\t{\n\t\tint u = Q.top().u;\n\t\tLL D0 = Q.top().D;\n\t\tvis[u] = 1, Q.pop();\n\n\t\tint v = id[D0 + 2 * size[u] - n];\n\t\tif(!v || vis[v]) { puts(\"-1\"); return; }\n\t\tE.emplace_back(u, v);\n\t\tadj[v].push_back(u);\n\t\tsize[v] += size[u];\n\t}\n\n\tint rt = Q.top().u;\n\tif(!dfs_chk(rt, dfs_sum(rt))) { puts(\"-1\"); return; }\n\n\tfor(auto i : E) printf(\"%d %d\\n\", i.fst, i.snd);\n}\n\nint main()\n{\n#ifdef K_ON // K-ON!\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,j,k) for(int i=j;i<=k;++i)\ntypedef long long ll;\nchar cch;\ninline int rd(){\n\tint x=0,fl=1;\n\tcch=getchar();\n\twhile(cch>'9'||cch<'0'){\n\t\tif(cch=='-') fl=-1;\n\t\tcch=getchar();\n\t}\n\twhile(cch>='0'&&cch<='9') x=(x<<3)+(x<<1)+cch-'0',cch=getchar();\n\treturn x*fl;\n}\nconst int N=1e5+3;\nstruct abc{\n\tint i;\n\tll d;\n}a[N];\nint fr[N<<1],head[N],to[N<<1],nxt[N<<1],cnt,sz[N];\nll re,c[N];\ninline bool cmp(const abc &a,const abc &b){\n\treturn a.d<b.d;\n}\ninline void adde(int u,int v){\n\tto[++cnt]=v,fr[cnt]=u,nxt[cnt]=head[u],head[u]=cnt;\n\tto[++cnt]=u,fr[cnt]=v,nxt[cnt]=head[v],head[v]=cnt;\n}\ninline void dfs(int u,int fa,int dep){\n\tre+=dep;\n\tfor(int i=head[u];i;i=nxt[i])if(to[i]!=fa){\n\t\tdfs(to[i],u,dep+1);\n\t}\n}\nint main(){\n\tint n=rd();\n\trep(i,1,n) a[i].d=rd(),a[i].i=i;\n\tsort(a+1,a+1+n,cmp);\n\trep(i,1,n) c[i]=a[i].d;\n\tint pos;\n\tll tmp;\n\tfor(int i=n;i>1;--i){\n\t\ttmp=a[i].d-(n-2-sz[a[i].i])+sz[a[i].i];\n\t\tpos=lower_bound(c+1,c+n+1,tmp)-c;\n\t\tif(c[pos]!=tmp){\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t\telse sz[a[pos].i]+=sz[a[i].i]+1,adde(a[pos].i,a[i].i);\n\t}\n\tdfs(a[1].i,0,0);\n\tif(re!=a[1].d){\n\t\tputs(\"-1\");return 0;\n\t}\n\tint ed=n-1<<1;\n\tfor(int i=1;i<=ed;i+=2){\n\t\tprintf(\"%d %d\\n\",fr[i],to[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll, int> Pl;\ntypedef pair<int, int> P;\n\nint n;\nvector<int> g[100000];\nbool used[100000];\nint ct;\nvoid dfs(int x){\n\tct++;\n\tused[x]=1;\n\tfor(auto y:g[x]){\n\t\tif(!used[y]) dfs(y);\n\t}\n}\nll dist[100000];\nint sz[100000];\nvoid dfs2(int x){\n\tused[x]=1;\n\tsz[x]=1;\n\tfor(auto y:g[x]){\n\t\tif(!used[y]){\n\t\t\tdist[y]=dist[x]+1;\n\t\t\tdfs2(y);\n\t\t\tsz[x]+=sz[y];\n\t\t}\n\t}\n}\nll d2[100000];\nvoid dfs3(int x){\n\tused[x]=1;\n\tfor(auto y:g[x]){\n\t\tif(!used[y]){\n\t\t\td2[y]=d2[x]-(ll)sz[y]+(ll)(n-sz[y]);\n\t\t\tdfs3(y);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin>>n;\n\tif(n<=4){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tll d[100000];\n\tset<Pl> st;\n\tfor(int i=0; i<n; i++){\n\t\tcin>>d[i];\n\t\tst.insert(Pl(d[i], i));\n\t}\n\tvector<P> ans;\n\tint s[100000];\n\tfill(s, s+n, 1);\n\twhile(!st.empty()){\n\t\tauto itr=st.end(); itr--;\n\t\tint i0=(*itr).second;\n\t\tll d0=(*itr).first;\n\t\tst.erase(itr);\n\t\tauto itr1=st.lower_bound(Pl(d0-(ll)(n-2*s[i0]), -1));\n\t\tif(itr1==st.end() || (*itr1).first!=d0-(ll)(n-2*s[i0])) continue;\n\t\tint i1=(*itr1).second;\n\t\tans.push_back(P(i0, i1));\n\t\tg[i0].push_back(i1);\n\t\tg[i1].push_back(i0);\n\t\ts[i1]+=s[i0];\n\t\tif(ans.size()==n-1) break;\n\t}\n\tdfs(0);\n\tif(ct<n){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tfill(used, used+n, 0);\n\tdfs2(0);\n\tll d0=0;\n\tfor(int i=0; i<n; i++) d0+=dist[i];\n\tif(d[0]!=d0){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\td2[0]=d[0];\n\tfill(used, used+n, 0);\n\tdfs3(0);\n\tfor(int i=1; i<n; i++){\n\t\tif(d[i]!=d2[i]){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=0; i<n-1; i++){\n\t\tcout<<ans[i].first+1<<\" \"<<ans[i].second+1<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100000 + 10;\n\nmap<ll,int> id;\nint n, sz[maxn], fa[maxn], h[maxn], cnt = 0;\nstruct enode{\n  int v, n;\n  enode() {}\n  enode(int _v, int _n):v(_v), n(_n) {}\n}e[maxn << 1];\nstruct anode{\n  ll x; int y;  \n  friend bool operator < (anode a, anode b) { return a.x > b.x; }\n}a[maxn];\nint ans[maxn][2];\nll d[maxn], dep[maxn];\n\ninline void addedge(int u, int v) { cnt ++; e[cnt] = enode(v,h[u]); h[u] = cnt; }\n\nvoid dfs1(int u, int fa, int r) {\n\td[r] += dep[u];\n\tfor(int i = h[u];~ i;i = e[i].n) {\n\t  int v = e[i].v;\n\t  if(v == fa) continue;\n\t  dep[v] = dep[u] + 1;\n\t  dfs1(v,u,r);\n\t}\n}\n\nvoid dfs2(int u, int fa) {\n  for(int i = h[u];~ i;i = e[i].n) {\n    int v = e[i].v;\n    if(v == fa) continue;\n    d[v] = d[u] - 2 * sz[v] + n;\n    dfs2(v,u);\n\t}\n}\n\ninline void fail() {\n  puts(\"-1\");\n  exit(0);\n}\n\nint main() {\n\tscanf(\"%d\", &n); cnt = 0;\n\tmemset(h,-1,sizeof(h));\n\tfor(int i = 1;i <= n;i ++) scanf(\"%lld\", &a[i].x), sz[i] = 1, a[i].y = i, id[a[i].x] = i;\n\tsort(a + 1,a + n + 1);\n\tfor(int i = 1;i < n;i ++) {\n\t\tint u = a[i].y;\n\t\tll tmp = a[i].x + 2 * sz[u] - n;\n\t\tif(!id.count(tmp)) fail();\n\t  if(n - 2 * sz[u]<= 0) fail();\n\t  fa[u] = id[tmp];\n\t  sz[fa[u]] += sz[u];\n\t  ans[i][0] = u;\n\t  ans[i][1] = fa[u];\n\t  addedge(u,fa[u]);\n\t  addedge(fa[u],u);\n\t}\n\tdep[a[n].y] = 0;\n\tdfs1(a[n].y,0,a[n].y);\n\tdfs2(a[n].y,0);\n\tfor(int i = 1;i <= n;i ++) if(a[i].x != d[a[i].y]) fail();\n\tfor(int i = 1;i < n;i ++) printf(\"%d %d\\n\", ans[i][0], ans[i][1]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <assert.h>\nusing namespace std;\ntypedef long long LL;\nconst int N=100000+10;\nint n,sz[N]; \npair<int,LL> d[N];\nvector<int> g[N];\nbool cmp(pair<int,LL> p1,pair<int,LL> p2){\n    return p1.second>p2.second;\n}\nmap<LL,int> mp;\nvector< pair<int,int> > res;\nvoid prt(int u,int p){\n    for(auto v:g[u]){\n        if(v==p)continue;\n        res.push_back(make_pair(u,v));\n        prt(v,u);\n    }\n}\nint main() {\n    scanf(\"%d\",&n); \n    for(int i=1;i<=n;i++){\n        d[i].first=i; \n        scanf(\"%lld\",&d[i].second);\n        mp[d[i].second]=i;\n        sz[i]=1;\n    }\n    sort(d+1,d+1+n,cmp);\n    for(int i=1;i<n;i++){\n        LL tmp=d[i].second;\n        LL nex=tmp-(n-2*sz[d[i].first]);\n        if(mp[nex]==0||nex>=tmp){\n            assert(0);\n            return !printf(\"-1\\n\");\n        }\n        int u=mp[nex];\n        int v=d[i].first;\n        g[u].push_back(v); g[v].push_back(u);\n        sz[u]+=sz[v];\n    }\n    prt(1,1);\n    if(res.size()==n-1){\n        for(auto p: res) printf(\"%d %d\\n\", p.first, p.second);\n    } else {\n        printf(\"-1\\n\");\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nconst int N = 100005;\n\nlong long n;\npair <long long, long long> p[N];\n\nvector < pair<long long, long long> > answ;\n\nlong long order[N];\n\nvector < pair<long long, long long> > odd, even;\nqueue < pair<long long, long long> > q;\n\nint main() {\n\tcin >> n;\n\tfor (long long i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &p[i].first);\n\t\tp[i].second = i;\n\t\tif (p[i].first % 2)\n\t\t\todd.push_back(p[i]);\n\t\telse\n\t\t\teven.push_back(p[i]);\n\t}\n\t///\n\tsort(odd.begin(), odd.end());\n\tsort(even.begin(), even.end());\n\tsort(p + 1, p + n + 1);\n\t///\n\tq.push(p[1]);\n\torder[p[1].second] = n - 1;\n\tlong long it1 = 0, it2 = 0;\n\tif (p[1].first % 2)\n\t\tit1++;\n\telse\n\t\tit2++;\n\twhile (!q.empty()) {\n\t\tpair<long long,long long> P = q.front();\n\t\tlong long v = P.second;\n\t\tlong long d = P.first;\n\t\tq.pop();\n\t\tif (n % 2 == 0) {\n\t\t\tif (d % 2 == 0) {\n\t\t\t\tlong long sum = order[v];\n\t\t\t\twhile (sum > 0 && it2 < (long long)even.size()) {\n\t\t\t\t\tsum -= 1 + (n - 2 - (even[it2].first - d)) / 2;\n\t\t\t\t\tlong long to = even[it2].second;\n\t\t\t\t\torder[to] = (n - 2 - (even[it2].first - d)) / 2;\n\t\t\t\t\tif (order[to] != 0) {\n\t\t\t\t\t\tq.push(even[it2]);\n\t\t\t\t\t}\n\t\t\t\t\tansw.push_back(make_pair(v, even[it2].second));\n\t\t\t\t\t++it2;\n\t\t\t\t}\n\t\t\t\tif (sum != 0) {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong long sum = order[v];\n\t\t\t\twhile (sum > 0 && it1 < (long long)odd.size()) {\n\t\t\t\t\tsum -= 1 + (n - 2 - (odd[it1].first - d)) / 2;\n\t\t\t\t\tlong long to = odd[it1].second;\n\t\t\t\t\torder[to] = (n - 2 - (odd[it1].first - d)) / 2;\n\t\t\t\t\tif (order[to] != 0) {\n\t\t\t\t\t\tq.push(odd[it1]);\n\t\t\t\t\t}\n\t\t\t\t\tansw.push_back(make_pair(v, odd[it1].second));\n\t\t\t\t\t++it1;\n\t\t\t\t}\n\t\t\t\tif (sum != 0) {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (d % 2 == 0) {\n\t\t\t\tlong long sum = order[v];\n\t\t\t\twhile (sum > 0 && it1 < (long long)odd.size()) {\n\t\t\t\t\tsum -= 1 + (n - 2 - (odd[it1].first - d)) / 2;\n\t\t\t\t\tlong long to = odd[it1].second;\n\t\t\t\t\torder[to] = (n - 2 - (odd[it1].first - d)) / 2;\n\t\t\t\t\tif (order[to] != 0) {\n\t\t\t\t\t\tq.push(odd[it1]);\n\t\t\t\t\t}\n\t\t\t\t\tansw.push_back(make_pair(v, odd[it1].second));\n\t\t\t\t\t++it1;\n\t\t\t\t}\n\t\t\t\tif (sum != 0) {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong long sum = order[v];\n\t\t\t\twhile (sum > 0 && it2 < (long long)even.size()) {\n\t\t\t\t\tsum -= 1 + (n - 2 - (even[it2].first - d)) / 2;\n\t\t\t\t\tlong long to = even[it2].second;\n\t\t\t\t\torder[to] = (n - 2 - (even[it2].first - d)) / 2;\n\t\t\t\t\tif (order[to] != 0) {\n\t\t\t\t\t\tq.push(even[it2]);\n\t\t\t\t\t}\n\t\t\t\t\tansw.push_back(make_pair(v, even[it2].second));\n\t\t\t\t\t++it2;\n\t\t\t\t}\n\t\t\t\tif (sum != 0) {\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < (int)answ.size(); i++) {\n\t\tcout << answ[i].first << \" \" << answ[i].second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define R register\ntypedef long long ll;\ntypedef std::pair<ll, int> pii;\n\nconst int MN = 1e5 + 5;\n\npii d[MN];\n\nstd::map<ll, int> mp;\n\nint n, fa[MN], sz[MN], rt;\n\nll dp[MN];\n\nstruct Edge {\n\tint to;\n\tEdge *nxt;\n\tEdge(Edge *nxt = nullptr, int to = 0) : to(to), nxt(nxt){}\n}*hd[MN];\n\ninline void ins(int u, int v) {hd[u] = new Edge(hd[u], v);}\n\nvoid dfs(int u) {\n\tfor (R Edge *e = hd[u]; e != nullptr; e = e -> nxt) {\n\t\tR int v = e -> to;\n\t\tdfs(v);\n\t\tdp[u] += sz[v] + dp[v];\n\t}\n}\n\nvoid solve(int u) {\n\tfor (R Edge *e = hd[u]; e != nullptr; e = e -> nxt) {\n\t\tR int v = e -> to;\n\t\tdp[v] += (n - sz[v]) + (dp[u] - dp[v] - sz[v]);\n\t\tsolve(v);\n\t}\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\n\tstd::cin >> n;\n\tfor (R int i = 1; i <= n; ++i) {\n\t\tR ll x;\n\t\tstd::cin >> x;\n\t\tmp[x] = i;\n\t\td[i] = pii(x, i);\n\t\tsz[i] = 1;\n\t}\n\t\n\tstd::sort(d + 1, d + n + 1);\n\tfor (R int i = n; i > 1; --i) {\n\t\tR int v = d[i].second;\n\t\tR ll res = d[i].first;\n\t\tif (mp[res + (sz[v] << 1) - n])\t {\n\t\t\tfa[v] = mp[res + (sz[v] << 1) - n];\n\t\t\tsz[fa[v]] += sz[v];\n\t\t}\n\t\telse {\n\t\t\tstd::cout << \"-1\" << std::endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (R int i = 1; i <= n; ++i)\n\t\tif (fa[i]) ins(fa[i], i);\n\t\telse rt = i;\n\tdfs(rt);\n\tsolve(rt);\n\tfor (R int i = 1; i <= n; ++i)\n\t\tif (dp[d[i].second] != d[i].first){\n\t\t\tstd::cout << \"-1\" << std::endl;\n\t\t\treturn 0;\n\t\t}\n\n\tfor (R int i = 1; i <= n; ++i)\n\t\tif (fa[i])\n\t\t\tstd::cout << fa[i] << \" \" << i << std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(ll i = (a); i < (ll)(b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\nusing ld = long double;\nusing ll = long long int;\n\nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ll MOD = 1000000007;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> void UNIQUE(vector<T> &a){ a.erase(unique(a.begin(), a.end()), a.end()); }\n\ntemplate<class S, class T> ostream& operator << (ostream& os, const pair<S, T> v){\n  os << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<T> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<vector<T>> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\n\nll in(){long long int x; assert(scanf(\"%lld\", &x) == 1); return x;}\nld fin(){double x; assert(scanf(\"%lf\", &x) == 1); return x;}\nchar yuyushiki[1000010]; string stin(){assert(scanf(\"%s\", yuyushiki) == 1); return yuyushiki;}\n\n// head\n\ntemplate<typename T, const T INFT>\nstruct Dijkstra{\n  typedef pair<int,T> pit;\n  typedef pair<T,int> pti;  \n  vector<vector<pit>> G;\n  vector<T> dist;\n  int n;\n  void init(int arg_n){\n    n = arg_n;\n    G.assign(n, vector<pit>(0));\n  }\n  void add_biedge(int fr, int to, T co){\n    G[fr].pb(to, co);\n    G[to].pb(fr, co);\n  }\n  void add_edge(int fr, int to, T co){\n    G[fr].pb(to, co);\n  }\n  T dijkstra(int s, int t = -1){\n    dist = vector<T>(n, INFT);\n    dist[s] = 0;\n    priority_queue<pti,vector<pti>,greater<pti>> que;\n    que.emplace(0, s);\n    while(!que.empty()){\n      T d = que.top().fi;\n      int p = que.top().se;\n      que.pop();\n      if(d > dist[p]){\n\tcontinue;\n      }\n      if(p == t){\n\treturn d;\n      }\n      YYS(w, G[p]){\n\tint to = w.fi;\n\tT co = w.se;\n\tif(d + co < dist[to]){\n\t  dist[to] = d + co;\n\t  que.emplace(dist[to], to);\n\t}\n      }\n    }\n    return INFT;\n  }\n};\n\nDijkstra<ll, INFLL> dij;\n\nusing pl = pair<ll, ll>;\nvector<ll> G[100010];\n\nint main(){\n\n  ll n = in();\n  vector<ll> a(n);\n  REP(i, n){\n    a[i] = in();\n  }\n  vector<ll> s(n, 1);\n  vector<pl> q(0);\n  REP(i, n){\n    q.pb(a[i], i);\n  }\n  sort(q.begin(), q.end());\n  reverse(q.begin(), q.end());\n  map<ll, vector<pl>> call;\n  dij.init(n);\n  YYS(w, q){\n    ll i = w.se;\n    if(call.find(a[i]) != call.end()){\n      YYS(c, call[a[i]]){\n        // cout << \"M \" << i << \" \" << c.fi << endl;\n        G[i].pb(c.fi);\n        dij.add_biedge(i, c.fi, 1);\n        s[i] += c.se;\n      }\n    }\n    ll target = a[i] + s[i] - (n - s[i]);\n    // cout << \"T \" << i << \" \" << target << endl;\n    if(call.find(target) == call.end()){\n      call[target] = vector<pl>(0);\n    }\n    call[target].pb(i, s[i]);\n  }\n\n  bool ok = false;\n  ll pos = -1;\n  REP(i, n){\n    if(s[i] == n){\n      ok = true;\n      pos = i;\n    }\n  }\n\n  if(pos != -1){\n    dij.dijkstra(pos);\n\n    ll s = 0;\n    REP(i, n){\n      s += dij.dist[i];\n    }\n\n    if(s != a[pos]){\n      ok = false;\n    }\n  }\n  \n  if(ok){\n    ll cnt = 0;\n    REP(i, n){\n      YYS(w, G[i]){\n        cnt++;\n        printf(\"%lld %lld\\n\", i+1, w+1);\n      }\n    }\n    assert(cnt == n-1);\n  } else {\n    puts(\"-1\");\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid err() {\n  cout << -1 << endl;\n  exit(0);\n}\nvoid dfs (int crr, int dpt, vector<vector<int>>& grh, int& cnt) {\n  cnt += dpt;\n  for (int nxt : grh[crr]) {\n    dfs(nxt, dpt + 1, grh, cnt);\n  }\n}\nint main() {\n  int n;\n  cin >> n;\n  vector<pair<int, int>> di(n);\n  for (int i = 0; i < n; i++) {\n    int d;\n    cin >> d;\n    di[i] = {d, i};\n  }\n  sort(di.begin(), di.end());\n  vector<int> sz(n, 1), prt(n);\n  vector<vector<int>> grh(n);\n  vector<pair<int, int>> edg;\n  for (auto it = prev(di.end()); it != di.begin(); it--) {\n    int d = it->first;\n    int i = it->second;\n    int prtv = d - n + 2 * sz[i];\n    auto jt = lower_bound(di.begin(), di.end(), make_pair(prtv, 0));\n    if (jt->first != prtv) err();\n    int p = jt->second;\n    prt[i] = p;\n    grh[p].push_back(i);\n    if (i == prt[i]) err();\n    sz[prt[i]] += sz[i];\n    edg.emplace_back(min(i, prt[i]), max(i, prt[i]));\n  }\n  int cnt = 0;\n  dfs(0, 0, grh, cnt);\n  sort(edg.begin(), edg.end());\n  if (di[0].first != cnt) err();\n  for (auto const & e : edg) {\n    cout << e.first + 1 << ' ' << e.second + 1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(3)\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC target(\"sse3\",\"sse2\",\"sse\")\n//#pragma GCC target(\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")\n//#pragma GCC target(\"f16c\")\n//#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\n//#pragma GCC diagnostic error \"-fwhole-program\"\n//#pragma GCC diagnostic error \"-fcse-skip-blocks\"\n//#pragma GCC diagnostic error \"-funsafe-loop-optimizations\"\n//#pragma GCC diagnostic error \"-std=c++14\"\n#include \"bits/stdc++.h\"\n//#include \"ext/pb_ds/tree_policy.hpp\"\n//#include \"ext/pb_ds/assoc_container.hpp\"\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) a.begin(),a.end()\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-(x)))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9+7;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {\n    if(a<0)return -1;\n    if(a>0)return 1;\n    return 0;\n}\nstring to_string(string s) {\n    return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n    return to_string((string) s);\n}\n\nstring to_string(bool b) {\n    return (b ? \"true\" : \"false\");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n    return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n    bool first = true;\n    string res = \"{\";\n    for (const auto &x : v) {\n        if (!first) {\n            res += \", \";\n        }\n        first = false;\n        res += to_string(x);\n    }\n    res += \"}\";\n    return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << to_string(H);\n    debug_out(T...);\n}\n\n#ifndef ONLINE_JUDGE\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) {}\n#endif\n\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\n\ntemplate<typename T> inline void in(T &x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) {\n        if (ch == '-') f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))  {\n        x = x * 10 + ch - '0';\n        ch = getchar();\n    }\n    x *= f;\n}\n\nll twop(int x) {\n    return 1LL<<x;\n}\n\n// m must be positive\ntemplate<typename T>\nT MOD(T a, T m){\n    a %= m;\n    if (a < 0)\n        a += m;\n    return a;\n}\n\n// a must be relatively prime to m\ntemplate<typename T>\nT inverse(T a, T m){\n    a = MOD(a, m);\n    if (a <= 1)\n        return a;\n    return MOD((1 - inverse(m, a) * m) / a, m);\n}\n\ntemplate<typename A,typename B > inline void in(A&x,B&y) {\n    in(x);\n    in(y);\n}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {\n    in(x);\n    in(y);\n    in(z);\n}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {\n    in(x);\n    in(y);\n    in(z);\n    in(d);\n}\nll gcd(ll a,ll b){return b==0?a:gcd(b,a%b);}\nnamespace SOLVE {\n    vector<PLL>ans;\n    map<ll, ll>mp;\n    ll vis[100010];\n    ll subtree_size[100001];\n    ll sum[100010];\n    VLL edge[100010];\n    ll root;\n    void dfs(ll cur,ll length){\n        sum[root]-=length;\n        for(auto s:edge[cur])dfs(s, length+1);\n    }\n    void main(){\n        ll n;in(n);\n        REP(i,1,n+1){\n            ll value;\n            in(value);\n            mp[value] = i;\n            sum[i] = value;\n        }\n        priority_queue<PLL>pq;\n        REP(i,1,n+1){\n            pq.push(MP(sum[i],i));\n            subtree_size[i] = 1;\n        }\n        while (sz(pq)>1) {\n            auto t = pq.top();pq.pop();\n            vis[t.se] = 1;\n            ll par_sum = sum[t.se] - n +  subtree_size[t.se]*2;\n            ll par = mp[par_sum];\n            if(vis[par] or !par){\n                cout<<-1<<endl;\n                return;\n            }\n            subtree_size[par] += subtree_size[t.se];\n            ans.PB(MP(par,t.se));\n            edge[par].PB(t.se);\n        }\n        root = pq.top().se;\n        dfs(root,0);\n        if(sum[root]!=0){\n            cout<<-1<<endl;\n            return;\n        }\n        for(auto i:ans)cout<<i.fi<<\" \"<<i.se<<endl;\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n    }\n}\n\n\nsigned main() {\n\n    \n    \n    \n    \n    int t = 1;\n//    in(t);\n    while(t--){\n        SOLVE::main();\n\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <random>\n#include <complex>\n#include <regex>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define quickIO()\t{cin.tie(0);\tcout.sync_with_stdio(false);}\n#define reach(i,a)\tfor(auto i:a)\n#define rep(i,n)\tfor(int i=0;i<((int)n);i++)\n#define REP(i,n)\tfor(int i=0;i<=((int)n);i++)\n#define srep(i,a,n)\tfor(int i=a;i<((int)n);i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=((int)n);i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define pb\tpush_back\ntemplate<typename T> istream& operator >> (istream& is, vector<T>& vec) {\n\tfor (T& x : vec)\tis >> x;\n\treturn is;\n}\ntemplate<typename T> ostream& operator << (ostream& os, vector<T>& vec) {\n\tos << \"[\";\n\trep(i, vec.size())\tos << (i ? \", \" : \"\") << vec[i];\n\tos << \"]\";\n\treturn os;\n}\ntemplate<typename T> istream& operator >> (istream& is, pair<T, T>& p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate<typename T> ostream& operator << (ostream& os, pair<T, T>& p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\";\n\treturn os;\n}\nint bitcnt(ll x) {\n\tx = ((x & 0xAAAAAAAAAAAAAAAA) >> 1) + (x & 0x5555555555555555);\n\tx = ((x & 0xCCCCCCCCCCCCCCCC) >> 2) + (x & 0x3333333333333333);\n\tx = ((x & 0xF0F0F0F0F0F0F0F0) >> 4) + (x & 0x0F0F0F0F0F0F0F0F);\n\tx = ((x & 0xFF00FF00FF00FF00) >> 8) + (x & 0x00FF00FF00FF00FF);\n\tx = ((x & 0xFFFF0000FFFF0000) >> 16) + (x & 0x0000FFFF0000FFFF);\n\tx = ((x & 0xFFFFFFFF00000000) >> 32) + (x & 0x00000000FFFFFFFF);\n\treturn x;\n}\nint bitcnt(int x) {\n\tx = ((x & 0xAAAAAAAA) >> 1) + (x & 0x55555555);\n\tx = ((x & 0xCCCCCCCC) >> 2) + (x & 0x33333333);\n\tx = ((x & 0xF0F0F0F0) >> 4) + (x & 0x0F0F0F0F);\n\tx = ((x & 0xFF00FF00) >> 8) + (x & 0x00FF00FF);\n\tx = ((x & 0xFFFF0000) >> 16) + (x & 0x0000FFFF);\n\treturn x;\n}\nll sqrtll(ll x) {\n\tll left = 0, right = x;\n\trep(i, 100) {\n\t\tll mid = (left + right) >> 1;\n\t\tif (mid*mid <= x)\tleft = mid;\n\t\telse\tright = mid;\n\t}\n\treturn left;\n}\nll gcd(ll a, ll b) {\n\treturn a % b == 0 ? b : gcd(b, a%b);\n}\n#define debug(x)\tprintf(\"Case #%d: \", x)\n#define DEBUG 0\nconst ll inf = 1e18;\nconst ld infl = 1e100;\nconst ll mod = 1e9+7;\nconst ld eps = 1e-9;\nconst int dx[] = { 1,0,-1,0,0 };\nconst int dy[] = { 0,1,0,-1,0 };\n\nint group[100010];\n\nint getGroup(int i) {\n\treturn group[i] = (i == group[i] ? group[i] : getGroup(group[i]));\n}\nvoid merge(int i, int j) {\n\ti = getGroup(i);\tj = getGroup(j);\n\tgroup[i] = group[j];\n}\n\n// 最初の2頂点はxとx-n+2があったらマージ。headのみを残す。\n// 以降x(a)とy(b)についてx+n-2*b=yやy+n-2*a=xで判断\n// x(a)は固定できるけど、y(b)が見つけられない\n// xが親になる場合はx+n=y+2*b->子になる場合はx+2*a-n=y\n// 「一番大きいdiは子になる」より再帰的に(UF?)出来そう\n\n// さらに、全体を+sしても上の状態では成り立ってしまうので、実際の距離と一致しているか検証する必要がある。\n\nint main() {\n\tll n;\tcin >> n;\n\tvll d(n);\tcin >> d;\n\tvll num(n, 1);\n\tmap<ll, ll> mp;\n\trep(i, n) {\n\t\tmp[d[i]] = i;\n\t}\n\tvector<pll> d2(n);\n\trep(i, n) {\n\t\td2[i] = mp(d[i], i);\n\t\tgroup[i] = i;\n\t}\n\tsort(all(d2));\n\tvector<pll> ret;\n\tfor (ll i = n - 1; i > 0; i--) {\n\t\tll id = d2[i].second;\n\t\tif (getGroup(id) != id)\tcontinue;\n\t\tll a = num[id];\n\t\tif (!mp.count(d[id] + 2 * a - n) || id == mp[d[id] + 2 * a - n]) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tll to = mp[d[id] + 2 * a - n];\n\t\tmp.erase(d[id]);\n\t\tmerge(id, to);\n\t\tnum[to] += num[id];\n\t\tret.push_back(mp(id + 1, to + 1));\n\t}\n\t// 検証パート\n\tnum = vll(n, 1);\n\tvll dist = vll(n, 0);\n\trep(i, n - 1) {\n\t\tdist[ret[i].second - 1] += dist[ret[i].first - 1] + num[ret[i].first - 1];\n\t\tnum[ret[i].second - 1] += num[ret[i].first - 1];\n\t}\n\tll root = ret[n - 2].second - 1;\n\tif (dist[root] != d[root]) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\trep(i, n - 1) {\n\t\tcout << ret[i].first << \" \" << ret[i].second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 100020\n#define rep(i,l,r) for(register int i = l ; i <= r ; i++)\n#define repd(i,r,l) for(register int i = r ; i >= l ; i--)\n#define rvc(i,S) for(register int i = 0 ; i < (int)S.size() ; i++)\n#define rvcd(i,S) for(register int i = ((int)S.size()) - 1 ; i >= 0 ; i--)\n#define fore(i,x)for (register int i = head[x] ; i ; i = e[i].next)\n#define pb push_back\n#define prev prev_\n#define stack stack_\n#define mp make_pair\n#define fi first\n#define se second\n#define inf 0x3f3f3f3f\ntypedef long long ll;\ntypedef pair<int,int> pr;\n\nll d[maxn],f[maxn];\nstruct node{\n\tint next,to;\n}e[maxn * 2];\nint head[maxn],cnt;\nint n,fa[maxn],sz[maxn],dth[maxn];\n\ninline void adde(int x,int y){\n\te[++cnt].to = y;\n\te[cnt].next = head[x];\n\thead[x] = cnt;\n}\t\nvoid dfs(int x){\n\tfore(i,x){\n\t\tdth[e[i].to] = dth[x] + 1;\n\t\tdfs(e[i].to);\n\t}\n}\nbool check(){\n\tdfs(1);\n\trep(i,1,n) f[1] += dth[i];\n\tif ( f[1] != d[1] ) return 0;\n\trep(i,2,n){\n\t\tf[i] = f[fa[i]] + n - sz[i] * 2;\n\t\tif ( f[i] != d[i] ) return 0;\n\t}\n\treturn 1;\n}\nbool solve(){\n\trepd(i,n,2){\n\t\tsz[i]++;\n\t\tll curd = d[i] - n + 2 * sz[i];\n\t\tint id = lower_bound(d + 1,d + n + 1,curd) - d;\n\t\tif ( d[id] != curd || id >= i ) return 0;\n\t\tfa[i] = id , sz[id] += sz[i];\n\t}\n\trep(i,2,n) adde(fa[i],i);\n\treturn check();\n}\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n) scanf(\"%lld\",&d[i]);\n\tsort(d + 1,d + n + 1);\n\tif ( solve() ){\n\t\trep(i,2,n) printf(\"%d %d\\n\",fa[i],i);\n\t}\n\telse{\n\t\tprintf(\"-1\\n\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 100005\n#define ll long long\nusing namespace std;\nint n,cnt,sz[N],st[N],ed[N],he[N],ne[N*2],to[N*2];ll D;map<ll,int>m;\nstruct nod{ll dis;int x;}d[N];\nint cmp(nod x,nod y){return x.dis>y.dis;}\nvoid add(int x,int y){to[++cnt]=y;ne[cnt]=he[x];he[x]=cnt;}\nint dfs(int x,int fa,ll t){D+=t;for(int i=he[x];i;i=ne[i]) if(to[i]!=fa) dfs(to[i],x,t+1);}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&d[i].dis),d[i].x=i,m[d[i].dis]=i;\n\tsort(d+1,d+n+1,cmp);\n\tfor(int i=1;i<=n;i++) sz[i]=1;\n\tfor(int i=1;i<n;i++)\n    {\n\t\tll dis=d[i].dis;int x=d[i].x;\n\t\tll t=dis-abs(n-2*sz[x]);\n\t\tint fa=m.find(t)->second;\n\t\tif(fa==x||!fa){puts(\"-1\");return 0;}\n\t\tsz[fa]+=sz[x];st[i]=x,ed[i]=fa;\n\t\tadd(x,fa),add(fa,x);\n\t}\n\tdfs(d[n].x,0,0);\n\tif(D!=d[n].dis){puts(\"-1\");return 0;}\n\tfor(int i=1;i<n;i++) printf(\"%d %d\\n\",st[i],ed[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint n;\nvector<pair<ll,int>> v;\nvector<int> fa,siz;\n\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n    cin>>n;\n    v.resize(n + 1);\n    fa.resize(n + 1);\n    siz.resize(n + 1);\n    fill(fa.begin(),fa.end(),0);\n    fill(siz.begin(),siz.end(),1);\n    for(int i = 1; i <= n; i++) {\n        cin>>v[i].first;\n        v[i].second = i;\n    }\n    sort(v.begin() + 1,v.end(),[](auto x,auto y){ return x.first > y.first;});\n    for(int i = 1; i < n; i++){\n        ll d = v[i].first;\n        int sz = siz[v[i].second];\n        ll d_nxt = d - n + 2 * sz;\n        int lo = i + 1, hi = n;\n        int ans_pos = 0;\n        while(lo <= hi){\n            int mid = lo + hi >> 1;\n            if(v[mid].first > d_nxt){\n                lo = mid + 1;\n            }\n            else if(v[mid].first < d_nxt){\n                hi = mid - 1;\n            }\n            else {\n                ans_pos = mid;\n                break;\n            }\n        }\n        if(ans_pos == 0){\n            cout<<-1<<endl;\n            exit(0);\n        }\n        int u = v[i].second;\n        int f = v[ans_pos].second;\n        fa[u] = f;\n        siz[f] += siz[u];\n    }\n    for(int i = 1; i < n; i++){\n        cout<<v[i].second<<\" \"<<fa[v[i].second]<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define N 500005\nusing namespace std;\nint n,cnt,sum,a[N],sz[N],tmp[N],ansx[N],ansy[N];\nmap<int,int>b;\nvector<int>G[N];\ninline bool cmp(int x,int y){return a[x]>a[y];}\nvoid dfs(int u,int fa,int dep){\n\tsum+=dep;\n\tfor (int i=0;i<(int)G[u].size();i++){\n\t\tint v=G[u][i];\n\t\tif (v==fa) continue;\n\t\tdfs(v,u,dep+1);\n\t}\n}\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%lld\",&a[i]),b[a[i]]=i,tmp[i]=i,sz[i]=1;\n\tsort(tmp+1,tmp+n+1,cmp);\n\tfor (int i=1;i<n;i++){\n\t\tint x=tmp[i];\n\t\tint dis=a[x]-(n-sz[x])+sz[x];\n\t\tif (!b[dis]) return puts(\"-1\"),0;\n\t\tint y=b[dis];\n\t\tsz[y]+=sz[x];ansx[++cnt]=x;ansy[cnt]=y;\n\t\tif (x==y) return puts(\"-1\"),0;\n\t\tG[y].push_back(x);\n\t}\n\tint rt=tmp[n];sum=0;\n\tdfs(rt,-1,0);\n\tif (sum!=a[rt]) return puts(\"-1\"),0;\n\tfor (int i=1;i<=cnt;i++) printf(\"%lld %lld\\n\",ansx[i],ansy[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n/*#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"fast-math\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,popcnt,abm,mmx,tune=native\")*/\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stdio.h>\n#include <cstdio>\n#include <math.h>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <deque>\n#include <random>\n#include <iomanip>\n#include <bitset>\n                      \nusing namespace std;\n                      \ntemplate<typename T> void uin(T &a, T b) {\n    if (b < a) {\n        a = b;\n    }\n}\n                      \ntemplate<typename T> void uax(T &a, T b) {\n    if (b > a) {\n        a = b;\n    }\n}\n\n#define int long long\n#define ghost signed\n#define left left228\n#define right right228\n#define prev prev228\n#define list list228\n\nconst int N = 100 * 1000 + 228;\n\nint n;\nint d[N], sz[N];\nmap<int, int> pos; \n\nbool cmp(int i, int j) {\n\treturn d[i] > d[j];\n}\n\nghost main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> d[i];\n\t\tpos[d[i]] = i;\n\t}\n\tvector<int> order;\n\tfor (int i = 1; i <= n; ++i) order.push_back(i);\n\tfor (int i = 1; i <= n; ++i) sz[i] = 1;\n\tsort(order.begin(), order.end(), cmp);\n\tvector< pair<int, int> > e;\n\tint last = order.back();\n\tfor (int v : order) {\n\t\tif (v == last) break;\n\t\tint nd = d[v] + 2 * sz[v] - n;\n\t\tif (nd <= v) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint par = pos[nd];\n\t\tif (par == 0) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\te.push_back(make_pair(par, v));\n\t\tsz[par] += sz[v];\n\t}\n\tfor (auto p : e) cout << p.first << \" \" << p.second << '\\n';\n\treturn 0;\n} // kek ;\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,int>P;\n\nint n;\nP d[200000];\nvector<int>E[200000];\nint sz[200000];\nll dp1[200000],dp2[200000];\nvector<pair<int,int>>ans;\n\nvoid dfs1(int v){\n\tfor(int u:E[v]){\n\t\tdfs1(u);\n\t\tans.push_back({v+1,u+1});\n\t\tdp1[v]+=dp1[u]+sz[u];\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%lld\",&d[i].first);\n\t\td[i].second=i;\n\t}\n\trep(i,n)sz[i]=1;\n\tsort(d,d+n);\n\tfor(int i=n-1;i>0;i--){\n\t\tll c=d[i].first-n+2*sz[d[i].second];\n\t\tint id=lower_bound(d,d+n,P(c,0))-d;\n\t\tif(id==n||d[id].first!=c){\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t\tE[d[id].second].push_back(d[i].second);\n\t\tsz[d[id].second]+=sz[d[i].second];\n\t}\n\tdfs1(d[0].second);\n\tif(dp1[0]!=d[0].first){\n\t\tputs(\"-1\");return 0;\n\t}\n\tfor(auto p:ans){\n\t\tprintf(\"%d %d\\n\",p.first,p.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define inf 0x3f3f3f3f3f3f3f3f\n#define inf 0x3f3f3f3f\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define inv(x) Power(x, mod - 2)\n#define fi first\n#define se second\n#define MP make_pair\n#define PB push_back\n\ntypedef std::vector<int> Poly;\ntypedef std::pair<int,int> Pair;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef long long ll;\n\nconst int maxn = 100000, maxm = 2000, MAX = 1e6 + 5, mod = 1000000;\n//template{{{\nconst long double Pi = 3.14159265358979323846l, Eps = 1e-4;\ntemplate <class T> inline bool equal(T x, T y) { return fabs(x - y) < Eps; }\ninline int add(int x, int y) { x += y; return x >= mod ? x - mod : x; };\ninline void inc(int &x, int y) { x += y; x -= (x >= mod ? mod : 0); }\ninline int mul(int x, int y) { return 1ll * x * y % mod; }\ninline int Power(int x, int y, int Mod = mod) {\n\tint ans = 1;\n\twhile (y) {\n\t\tif (y & 1) ans = (ll) ans * x % Mod;\n\t\tx = (ll) x * x % Mod, y >>= 1;\n\t} return ans;\n}\n\n/*char buf[1<<23],obuf[1<<23],*p1=buf,*p2=buf, *O = obuf;\n#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\nvoid print(int x) {\n    if(x > 9) print(x / 10);\n    *O++=x%10+'0';\n} */\n\ntemplate <class T> inline T\tinput() {\n\tT x; char ch; bool flag = false;\n\twhile (!isdigit(ch = getchar())) flag |= ch == '-';\n\tfor (x = ch ^ 48; isdigit(ch = getchar()); x = x * 10 + (ch ^ 48));\n\treturn flag ? -x : x;\n}\n\ntemplate <class T> inline bool chkmin(T &x, T y) { x = x < y ? x : y; return x == y; }\ntemplate <class T> inline bool chkmax(T &x, T y) { x = x > y ? x : y; return x == y; }\ntemplate <class T> inline T gcd(T x, T y) { return !y ? x : gcd(y, x % y); }\ntemplate <class T> inline T sqrm(T x) { return (ll) x * x % mod; }\ntemplate <class T> inline T sqr(T x) { return x * x; }\n\nstruct {\n\tinline operator int () { return input<int>(); }\n\tinline operator long long () { return input<long long>(); }\n\ttemplate <class T> inline void operator () (T &x) { x = *this; }\n\ttemplate<class T, class ...A> inline void operator () (T &x, A &...a)\n\t{ x = *this; this -> operator ()(a...); }\n} read; //}}}\n\nint n;\nll d[maxn + 5];\nint size[maxn + 5];\nstd::map<ll, int> id;\nstd::pair<ll, int> p[maxn + 5];\nstd::vector<int> T[maxn + 5];\nint fa[maxn + 5];\n\nll distance;\n\nvoid dfs(int u, ll dis) {\n\tdistance += dis;\n\tfor (int v : T[u])\n\t\tdfs(v, dis + 1);\n}\n\nbool check() {\n\tdfs(1, 0);\n\treturn distance == d[p[1].se];\n}\n\nsigned main() {\n#ifdef local\n\tfreopen(\"in\", \"r\", stdin);\n\tfreopen(\"out\", \"w\", stdout);\n\tfreopen(\"log\", \"w\", stderr);\n#endif\n\n\tn = read;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tp[i].fi = d[i] = read;\n\t\tp[i].se = id[d[i]] = i;\n\t\tsize[i] = 1;\n\t}\n\n\tstd::sort(p + 1, p + n + 1);\n\tfor (int i = n; i > 1; --i) {\n\t\tll df = p[i].fi - n + size[p[i].se] * 2;\n\t\tif (df >= p[i].fi) return puts(\"-1\"), 0;\n\t\tfa[p[i].se] = id[df], size[fa[p[i].se]] += size[p[i].se];\n\t\tif (!fa[p[i].se]) return puts(\"-1\"), 0;\n\t\tT[fa[p[i].se]].push_back(p[i].se);\n\t}\n\n\tif (!check()) return puts(\"-1\"), 0;\n\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (fa[i]) printf(\"%d %d\\n\", i, fa[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> pii;\n\npii inp[100005];\nint siz[100005];\nll dp[100005];\nvector<pii> ans;\n\nint main() {\n\tint N; scanf(\"%d\", &N);\n\tfor (int i = 1; i <= N; i++) {\n\t\tll x; scanf(\"%lld\", &x);\n\t\tinp[i] = {x, i};\n\t\tsiz[i] = 1;\n\t}\n\tsort(inp + 1, inp + N + 1);\n\tfor (int i = N; i >= 2; i--) {\n\t\tll cur; int id;\n\t\ttie(cur, id) = inp[i];\n\t\tint del = N - 2 * siz[id];\n\t\tauto it = *lower_bound(inp + 1, inp + i, pii(cur - del, 0));\n\t\tif (it.first != cur - del || del <= 0) return !printf(\"-1\");\n\t\tsiz[it.second] += siz[id];\n\t\tdp[it.second] += dp[id] + siz[id];\n\t\tif (id > it.second) swap(id, it.second);\n\t\tans.push_back({id, it.second});\n\t}\n\tif (dp[inp[1].second] != inp[1].first) return !printf(\"-1\");\n\tsort(ans.begin(), ans.end());\n\n\tfor (pii &x : ans) {\n\t\tprintf(\"%lld %d\\n\", x.first, x.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {cww() {CIN_ONLY{ios::sync_with_stdio(false); cin.tie(0);}}\n}star;\n#define DEBUG if(0)\n#endif\n\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}\ntemplate <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}\ntemplate <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}\n\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }};\n\nint n;\n\nint a[112345];\nint b[112345];\npair<LL,int> d[112345];\nint sub[112345];\nvector<vector<int>> g;\npair<LL,int> f(int v,int p) {\n\tpair<LL, int> ret = { 0ll,1 };\n\tfor (int u : g[v]) {\n\t\tif (p == u)continue;\n\t\tauto cret=f(u, v);\n\t\tret.first += cret.first;\n\t\tret.second += cret.second;\n\t}\n\tret.first += ret.second;\n\treturn ret;\n}\nbool check() {\n\tg.resize(n);\n\tfor (int i : range(n - 1)) {\n\t\tg[a[i]].push_back(b[i]);\n\t\tg[b[i]].push_back(a[i]);\n\n\t}\n\tLL A = f(0, 0).first - n;\n\tLL B = d[0].first;\n\treturn A == B;\n}\nint main() {\n\tcin >> n;\n\t\n\tfor (int i : range(n)) {\n\t\tcin >> d[i].first;\n\t\td[i].second = i + 1;\n\t}\n\tsort(d, d + n);\n\treverse(d, d + n);\n\tfor (int i : range(n))sub[i] = 1;\n\tmap<LL, int> id;\n\tfor (int i : range(n))id[d[i].first] = i;\n\tfor (int i : range(n - 1)) {\n\t\tLL k = sub[i];\n\t\tLL rest = n - sub[i];\n\t\tLL nxt_dist = d[i].first + k - rest;\n\t\tif (id.count(nxt_dist) == 0) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint j = id[nxt_dist];\n\t\ta[i] = i;\n\t\tb[i] = j;\n\t\tsub[j] += sub[i];\n\t}\n\n\tif (check()) {\n\t\tfor (int i : range(n - 1)) {\n\t\t\tcout << d[a[i]].second << \" \" << d[b[i]].second << endl;\n\t\t}\n\t}\n\telse {\n\t\tcout << -1 << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 100000;\n\nvector<int>G[MAXN + 5];\nmap<ll, int>mp;\n\nint siz[MAXN + 5];\n\nll check(int x) {\n\tll ret = 0;\n\tfor(int i=0;i<G[x].size();i++) {\n\t\tint to = G[x][i];\n\t\tret += check(to) + siz[to];\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint n; scanf(\"%d\", &n);\n\tfor(int i=1;i<=n;i++) {\n\t\tll D; scanf(\"%lld\", &D);\n\t\tmp[D] = i, siz[i] = 1;\n\t}\n\tmap<ll, int>::reverse_iterator rt;\n\tfor(map<ll, int>::reverse_iterator it=mp.rbegin();it!=mp.rend();it++) {\n\t\tif( siz[it->second] == n ) {\n\t\t\trt = it;\n\t\t\tbreak;\n\t\t}\n\t\tint x = it->second;\n\t\tll k = it->first + siz[x] - (n - siz[x]);\n\t\tif( k < it->first && mp.count(k) ) {\n\t\t\tint p = mp[k];\n\t\t\tsiz[p] += siz[x];\n\t\t\tG[p].push_back(x);\n\t\t}\n\t\telse {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif( check(rt->second) == rt->first ) {\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tfor(int j=0;j<G[i].size();j++)\n\t\t\t\tprintf(\"%d %d\\n\", i, G[i][j]);\n\t\t}\n\t}\n\telse puts(\"-1\");\n}"
  },
  {
    "language": "C++",
    "code": "\n// Problem : F - Distance Sums\n// Contest : AtCoder Regular Contest 103\n// URL : https://atcoder.jp/contests/arc103/tasks/arc103_d\n// Memory Limit : 1024 MB\n// Time Limit : 2000 ms\n// Powered by CP Editor (https://github.com/cpeditor/cpeditor)\n\n#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\n#define cerr if(1)cerr\n#define size(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n#define temptts template <class T, class... Ts>\n\nconst int N = 1e6 + 1, mod = 1e9 + 7, inf = 2e9;\n\nstruct pp {\n\tint v, i;\n\tbool operator < (const pp &o) const {\n\t\treturn v < o.v;\n\t}\n} d[N];\n\nint n, id[N], sz[N];\nvector<pair<int, int>> ans;\n\nint main() { cin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tif (n % 2 == 0) {\n\t\treturn cout << -1, 0;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> d[i].v;\n\t\td[i].i = i;\n\t}\n\tsort(d + 1, d + n + 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tid[d[i].v] = i;\n\t}\n\tfor (int i = n; i >= 2; i--) {\n\t\tsz[i]++;\n\t\tint j = d[i].v - n + 2 * sz[i];\n\t\tif (!id[j]) {\n\t\t\treturn cout << -1, 0;\n\t\t}\n\t\tans.push_back({d[id[j]].i, d[i].i});\n\t\tsz[id[j]] += sz[i];\n\t}\n\tfor (auto& x : ans) {\n\t\tcout << x.first << ' ' << x.second << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n 42/45  三组数据未通过\n 2018.10.3 留坑 \n*/\n#include<bits/stdc++.h>\n#define LL long long\n#define MAXN 100010\nusing namespace std;\nbool vis[MAXN];\nint sz[MAXN],ans1[MAXN],ans2[MAXN],cnt,Head[MAXN];\nLL tot;\nmap<LL,int> mp;\n/*struct node\n{\n\tLL k1,k2;\n\tbool operator <(const node &aa)\n\t{\n\t\treturn k1>aa.k1;\n\t}\n};\nset<node> S;*/\nstruct node\n{\n\tLL k1;int k2;\n}D[MAXN];\nstruct NODE\n{\n\tint begin,end,next;\n}edge[MAXN*2+10];\nbool cmp(node aa,node bb)\n{\n\treturn aa.k1>bb.k1;\n}\nvoid addedge(int bb,int ee)\n{\n\tedge[++cnt].begin=bb;edge[cnt].end=ee;edge[cnt].next=Head[bb];Head[bb]=cnt;\n}\nvoid addedge1(int bb,int ee)\n{\n\taddedge(bb,ee);addedge(ee,bb);\n}\nvoid dfs(int u,int fa,int dis)\n{\n\tint i,v;\n\tvis[u]=true;\n\tfor(i=Head[u];i!=-1;i=edge[i].next)\n\t{\n\t\tv=edge[i].end;if(v==fa||vis[v]==true)continue;\n\t\ttot+=1LL*dis;\n\t\t//printf(\"%d %d %d\\n\",u,v,dis);\n\t\tdfs(v,u,dis+1);\n\t}\n}\nint main()\n{\n\tfreopen(\"in\",\"r\",stdin);\n\tfreopen(\"out\",\"w\",stdout);\n\tint N,i,lans,fa;\n\tLL dfa;\n\tscanf(\"%d\",&N);\n\tfor(i=1;i<=N;i++){scanf(\"%lld\",&D[i].k1);mp[D[i].k1]=i;D[i].k2=i;}\n\tsort(D+1,D+N+1,cmp);\n\tmemset(sz,0,sizeof(sz));\n\tlans=0;\n\tmemset(Head,-1,sizeof(Head));cnt=1;\n\tfor(i=1;i<N;i++)\n\t{\n\t\tsz[D[i].k2]++;\n\t\tdfa=D[i].k1+1LL*sz[D[i].k2]-1LL*(N-sz[D[i].k2]);\n\t\tif(dfa>=D[i].k1){printf(\"-1\");return 0;}\n\t\tfa=mp[dfa];if(fa==0){printf(\"-1\");return 0;}\n\t\tsz[fa]+=sz[D[i].k2];\n\t\tans1[++lans]=D[i].k2;ans2[lans]=fa;\n\t\taddedge1(D[i].k2,fa);\n\t}\n\tsz[D[N].k2]++;\n\tif(sz[D[N].k2]!=N){printf(\"-1\");return 0;}\n\t\n\t/**********************************/\n\ttot=0;\n\tdfs(D[N].k2,0,0);\n\tif(tot!=D[N].k1){printf(\"-1\");return 0;}\n\t/**********************************/\n\t\n\tfor(i=1;i<=lans;i++)printf(\"%d %d\\n\",ans1[i],ans2[i]);\n\t/*memset(sz,0,sizeof(sz));\n\twhile(1)\n\t{\n\t\tnode MX=*(S.begin());\n\t\tsz[MX.k2]=1;\n\t\twhile(1)\n\t\t{\n\t\t\t\n\t\t}\n\t\tif(tot==N-1)break;\n\t}*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nconst long long mo=10000007;\nconst int maxn=100010;\n\nint n,m,d[maxn],id[maxn],siz[maxn],fa[maxn];\nlong long ans,js[maxn];\nint tot,nex[maxn*2],las[maxn*2],tov[maxn*2];\nint hs[mo];\n\nvoid con(int x,int y)\n{\n\ttot++;\n\ttov[tot]=y;\n\tnex[tot]=las[x];\n\tlas[x]=tot;\n}\n\nvoid insert(long long x,int id)\n{\n\tlong long i=x%mo;\n\twhile (hs[i]!=0)\n\t{\n\t\ti++;\n\t\tif (i==mo) i=0;\n\t}\n\ths[i]=id;\n}\n\nint find(long long x)\n{\n\tlong long i=x%mo;\n\twhile (hs[i]!=0 && d[hs[i]]!=x)\n\t{\n\t\ti++;\n\t\tif (i==mo) i=0;\n\t}\n\treturn hs[i];\n}\n\nvoid qsort(int l,int r)\n{\n\tint i=l;int j=r;\n\tlong long m=d[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (d[i]>m) i++;\n\t\twhile (d[j]<m) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(d[i],d[j]);\n\t\t\tswap(id[i],id[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort(l,j);\n\tif (r>i) qsort(i,r); \n}\n\nvoid dfs(int x,int ff)\n{\n\tjs[x]=js[ff]+1;\n\tfor (int i=las[x];i;i=nex[i])\n\t{\n\t\tif (tov[i]!=ff)\n\t\t{\n\t\t\tdfs(tov[i],x);\n\t\t\tans+=js[x];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&d[i]);\n\t\tid[i]=i;\n\t\tsiz[i]=1;\n\t}\n\tqsort(1,n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinsert(d[i],i);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tlong long op=d[i]-n+2*siz[i];\n\t\tint oq=find(op);\n\t\tif (oq==0)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfa[i]=oq;\n\t\t\tsiz[oq]+=siz[i];\n\t\t\tcon(i,oq);con(oq,i);\n\t\t}\n\t}\n\tdfs(n,0);\n\tif (ans!=d[n])\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tfor (int i=1;i<n;i++)\n\t\t{\n\t\t\tprintf(\"%d %d\\n\",id[i],id[fa[i]]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n\nconst ll dx[4] = { -1,1,0,0 };\nconst ll dy[4] = { 0,0,-1,1 };\nconst char c[4] = { 'R','L','U','D' };\n\nint main(){\n\tstatic ll n;\n\tstatic ll d[100010];\n\tscanf(\"%lld\",&n);\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tscanf(\"%lld\",&d[i]);\n\t}\n\t\n\tvector<P> vec;\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tvec.push_back(P(d[i],i));\n\t}\n\tsort(vec.begin(),vec.end());\n\treverse(vec.begin(),vec.end());\n\t\n\tstatic ll cnt[100010];\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tcnt[i] = 1;\n\t}\n\t\n\tmap<ll,ll> id;\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tid[d[i]] = i;\n\t}\n\t\n\tvector<P> ans;\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tP p = vec[i-1];\n\t\t//cout << p.fr << \" \" << p.sc << endl;\n\t\tif(cnt[p.sc]*2 >= n)continue;\n\t\tll nx = d[p.sc]-(n-cnt[p.sc])+cnt[p.sc];\n\t\tif(id.find(nx) == id.end()){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tans.push_back(P(p.sc,id[nx]));\n\t\t\tcnt[id[nx]] += cnt[p.sc];\n\t\t}\n\t}\n\tif(n%2 == 0){\n\t\tif(vec[n-2].fr != vec[n-1].fr){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tans.push_back(P(vec[n-2].sc,vec[n-1].sc));\n\t}\n\t\n\tif(ans.size() < n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i = 0 ; i < ans.size() ; i ++){\n\t\tprintf(\"%d %d\\n\",ans[i].fr,ans[i].sc);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#include<map>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n\nusing namespace std;\ntypedef long long LL;\nconst int N=100005;\nint n,p[N],siz[N],fa[N];\nLL d[N],d_[N];\nmap <LL,int> s;\n\nbool cmp(int x,int y)\n{\n\treturn d[x]>d[y];\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\trep(i,1,n) scanf(\"%lld\",&d[i]),p[i]=i,s[d[i]]=i;\n\tsort(p+1,p+1+n,cmp);\n\trep(i,1,n-1)\n\t{\n\t\t++siz[p[i]];\n\t\tLL D=d[p[i]]-n+2*siz[p[i]];\n\t\tif(D>=d[p[i]] || !s.count(D)) {puts(\"-1\"); return 0;}\n\t\tfa[p[i]]=s[D],siz[fa[p[i]]]+=siz[p[i]];\n\t\td_[fa[p[i]]]+=d_[p[i]]+siz[p[i]];\n\t}\n\tif(d_[p[n]]!=d[p[n]]) puts(\"-1\");\n\telse rep(i,1,n-1) printf(\"%d %d\\n\",p[i],fa[p[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(3)\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC target(\"sse3\",\"sse2\",\"sse\")\n#pragma GCC target(\"avx\",\"sse4\",\"sse4.1\",\"sse4.2\",\"ssse3\")\n#pragma GCC target(\"f16c\")\n#pragma GCC optimize(\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\n#pragma GCC diagnostic error \"-fwhole-program\"\n#pragma GCC diagnostic error \"-fcse-skip-blocks\"\n#pragma GCC diagnostic error \"-funsafe-loop-optimizations\"\n#pragma GCC diagnostic error \"-std=c++14\"\n#include \"bits/stdc++.h\"\n//#include \"ext/pb_ds/tree_policy.hpp\"\n//#include \"ext/pb_ds/assoc_container.hpp\"\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) a.begin(),a.end()\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) (x&(-x))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9+7;\nconst ll inf = 1e9+7;\nconst ld eps = 1e-9;\nconst db PI = atan(1)*4;\ntemplate<typename T>\ninline int sign(const T&a) {\n    if(a<0)return -1;\n    if(a>0)return 1;\n    return 0;\n}\n\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\n\ntemplate<typename T> inline void in(T &x) {\n    x = 0;\n    T f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) {\n        if (ch == '-') f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch))  {\n        x = x * 10 + ch - '0';\n        ch = getchar();\n    }\n    x *= f;\n}\n\nll twop(int x) {\n    return 1LL<<x;\n}\n\ntemplate<typename A,typename B > inline void in(A&x,B&y) {\n    in(x);\n    in(y);\n}\ntemplate<typename A,typename B,typename C>inline void in(A&x,B&y,C&z) {\n    in(x);\n    in(y);\n    in(z);\n}\ntemplate<typename A,typename B,typename C,typename D> inline void in(A&x,B&y,C&z,D&d) {\n    in(x);\n    in(y);\n    in(z);\n    in(d);\n}\nll gcd(ll a,ll b){return b==0?a:gcd(b,a%b);}\nnamespace SOLVE {\n    void main(){\n    }\n}\n\n\nvector<PLL>v;\nll fa[100010],dep[100010],siz[100010];\nvoid bye(){\n    cout<<-1;exit(0);\n}\nint main() {\n\n    \n    \n    int n;in(n);\n    REP(i,1,n+1){\n        ll d;in(d);\n        v.PB(MP(d,i));\n    }\n    sort(all(v));\n    mst(fa,-1);\n    REP(i,0,n){\n        if(v[i].fi == v.back().fi-(n-1)+1){\n            fa[n-1] = i;\n            siz[i]++;\n        }\n    }\n    \n    siz[n-1] = 1;\n    if(fa[n-1] == -1)bye();\n    RREP(i,n-2,1){\n        siz[i]++;\n        auto ptr = lower_bound(all(v),MP(v[i].fi - (n-siz[i]) + siz[i],-1LL));\n        if(ptr== v.end() || (ptr->fi != v[i].fi - (n-siz[i]) + siz[i])){\n            bye();\n        }\n        fa[i] = ptr-v.begin();\n        siz[ptr-v.begin()] += siz[i];\n    }\n    siz[0]++;\n    REP(i,1,n)dep[i] = dep[fa[i]]+1;\n    ll sum = 0;\n    REP(i,1,n)sum+=dep[i];\n    if(sum!=v[0].fi)bye();\n    REP(i,1,n)cout<<v[fa[i]].se<<\" \"<<v[i].se<<endl;\n\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, a, b) for(int i = a;i < b;i++)\n#define For(i, a) FOR(i, 0, a)\n#define REV(i, a, b) for(int i = b-1;i >= a;i--)\n#define Rev(i, a) REV(i, 0, a)\n#define REP(a) For(i, a)\n#define DEBUG_PRINT(...) fprintf(stderr, __VA_ARGS__)\n#ifdef ENABLE_DEBUG\n#define DEBUG(a) cerr<<#a<<\"=\"<<a<<endl\n#define DEBUG_ARRAY(a,n) cerr<<#a<<\"[\"<<n<<\"]=\"<<a[n]<<endl\n#else\n#define DEBUG(a) \n#define DEBUG_ARRAY(a,n) \n#endif\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\nvoid print_pair(pi a){\n  cerr<<\"(\"<<a.first<<\", \"<<a.second<<\") \";\n}\ntemplate<int T1, int T2>\nvoid print_2d(int a[T1][T2], int x, int y){\n  For(i, x){\n    For(j, y){\n      cerr<<a[i][j]<<\" \";\n    }\n    cerr<<endl;\n  }\n}\ntemplate<class T>\nvoid print_array(T a[],size_t n){\n  cerr<<\"array:\";\n  REP(n-1)cerr<<a[i]<<\",\";\n  cerr<<a[n-1]<<endl;\n}\n\nint N;\npll D[100000];\nll d[100000];\nint childnumD[100000];\nvector<pll> ans;\n\nint main(){\n  cin>>N;\n  REP(N){\n    ll tmp;\n    cin>>tmp;\n    D[i]=pll(tmp,i+1);\n  }\n  sort(D,D+N,greater<pll>());\n  REP(N){\n    d[i]=D[i].first;\n    if(d[i]>=N){\n      cout<<-1<<endl;\n      return 0;\n    }\n    DEBUG(d[i]);\n  }\n  for (int i = 0; i < N-1; i++) {\n    ll tmp=d[i]-(N-2)+2*childnumD[i];\n    DEBUG(tmp);\n      auto itr=lower_bound(d,d+N,tmp,greater<ll>());\n      DEBUG(*itr);\n      if(itr==d+N||*itr!=tmp){\n        cout<<-1<<endl;\n        return 0;\n      }\n      ans.push_back(pll(D[i].second,D[itr-d].second));\n      childnumD[itr-d]++;\n      childnumD[itr-d]+=childnumD[i];\n  }\n  for(auto&& i : ans)\n  {\n    cout<<i.first<<\" \"<<i.second<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 998244353;\nconst int N = 10000005;\nconst int K = 25;\nint d[N], sz[N], p[N], f[N];\npair < int, int > a[N];\n\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int n;\n    cin >> n;\n    for (int i = 1; i <= n; i++){\n        cin >> d[i];\n        a[i] = {d[i], i};\n    }\n    set < pair < int, int > > s;\n    sort(a + 1, a + n + 1);\n    reverse(a + 1, a + n + 1);\n    for (int i = 1; i <= n; i++) sz[i] = 1;\n    for (int i = 1; i <= n; i++){\n        int v = a[i].S;\n        auto x = s.lower_bound({d[v], 0});\n        while(x != s.end() && (*x).F == d[v]){\n            int u = (*x).S;\n            p[u] = v;\n            f[v] += f[u] + sz[u];\n            sz[v] += sz[u];\n            x++;\n        }\n        s.insert({d[v] + sz[v] - (n - sz[v]), v});\n    }\n    vector < pair < int, int > > ans;\n    for (int i = 1; i <= n; i++){\n        if (p[i] != 0){\n            ans.pb({i, p[i]});\n        } else if (f[i] != d[i]){\n            cout << -1;\n            return 0;\n        }\n    }\n    if (ans.size() != n - 1) cout << -1; else{\n        for (auto i: ans){\n            cout << i.F << \" \" << i.S << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nvoid NO(int where = 0) {\n  dump(where);\n  cout << -1 << endl;\n  exit(0);\n}\n\n// 解けた〜たぴゃ〜\n// D_iは相異なる，まじか〜\n\nconst int N = 1e5;\nvector<vector<int>> g(N);\nusing Value = ll;\nmap<int, Value> dp[N];\nmap<int, int> sz[N];\nint n;\nValue dfs(int i, int p, int f = 0) {\n  if(dp[i].count(p)) return dp[i][p];\n  int cnt = 0;\n  Value res = 0;\n  if(f || p == -1) {\n    // O(deg(i))\n    // go only child\n    sz[i][p] = 1;\n    for(int j : g[i]) if(j != p) {\n      cnt++;\n      res += dfs(j, i, f);\n      res += sz[j][i];\n      sz[i][p] += sz[j][i];\n    }\n  } else {\n    // O(1)\n    dfs(i, -1, f);\n    dfs(p, i, f);\n    res = dp[i][-1] - (dp[p][i] + sz[p][i]);\n    cnt = g[i].size() - 1;\n    sz[i][p] = sz[i][-1] - sz[p][i];\n  }\n  return dp[i][p] = res;\n}\n\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  int n;\n  cin >> n;\n  vector<ll> d(n);\n  for(int i = 0; i < n; i++) cin >> d[i];\n  vector<int> ord(n);\n  iota((ord).begin(), (ord).end(), 0);\n  sort((ord).begin(), (ord).end(), [&](int i, int j) { return d[i] < d[j]; });\n  map<ll, int> mp;\n  for(int i = 0; i < n; i++) mp[d[i]] = i;\n  auto rnk = ord;\n  for(int i = 0; i < n; i++) rnk[ord[i]] = i;\n  vector<int> v(n);\n  vector<pair<int,int>> ans;\n  ll base = n - 2 * (n - 1);\n  for(int i = n - 1; i >= 1; i--) {\n    // dump(d[ord[i]], v[i], i);\n    ll s = d[ord[i]] + (base + v[i] * 2);\n    // dump(s);\n    if(s >= d[ord[i]]) NO(1);\n    if(!mp.count(s)) NO(2);\n    v[rnk[mp[s]]] = v[i] + 1;\n    int a = mp[s], b = ord[i];\n    // dump(a, b);\n    ans.emplace_back(a, b);\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n  // dump(\"here\");\n  dfs(0, -1, 1);\n  for(int i = 0; i < n; i++) if(d[i] != dfs(i, -1, 0)) NO();\n  for(int i = 0; i < n - 1; i++) cout << ans[i].first + 1 << \" \" << ans[i].second + 1 << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  zjsdut\n *    created: 2020/01/16 17:21:38\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\ntemplate<typename A, typename B>\nbool chkmin(A &a, const B &b) {\n  if (b < a) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate<typename A, typename B>\nbool chkmax(A &a, const B &b) {\n  if (b > a) {\n    a = b;\n    return true;\n  }\n  return false;\n}\n\ntemplate<typename T>\nistream &operator>>(istream &stream, vector<T> &vec) {\n  for (auto &x : vec) stream >> x;\n  return stream;\n}\n\nvoid scan() {}\n\ntemplate<class T, class ...Args>\nvoid scan(T &a, Args &...rest) {\n  cin >> a;\n  scan(rest...);\n}\n\nusing ll = long long;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\nusing vi = vector<int>;\ntemplate<typename T> using vv = vector<vector<T>>;\n#define rng(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)\n#define up(i, a, b) for (int i = int(a); i <= int(b); ++i)\n#define down(i, b, a) for (int i = int(b); i >= int(a); i--)\n#define rep(n) for(int _iter_##n = 0, _num_##n = (int)n; _iter_##n < _num_##n; ++_iter_##n)\n#define FOR(x, cont) for (const auto &x: cont)\n#define For(x, cont) for (auto &x: cont)\n#define all(x) begin(x), end(x)\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ep emplace\n#define SZ(x) (int)(x).size()\n#define UNIQ(vec) (vec).erase(unique(all(vec)), end(vec))\n#define LB(cont, x) int(lower_bound(all(cont), x) - begin(cont))\n#define UB(cont, x) int(upper_bound(all(cont), x) - begin(cont))\n\ntemplate<typename T>\nostream &operator<<(ostream &stream, const vector<T> &vec) {\n  if (!vec.empty()) {\n    stream << vec[0];\n    for (size_t i = 1; i != vec.size(); ++i)\n      stream << ' ' << vec[i];\n  }\n  return stream;\n}\n\ntemplate<typename T>\nvoid print(const vector<T> &t) { cout << t << '\\n'; }\n\ntemplate<typename T>\nvoid print(const vector<vector<T>> &t) {\n  for (const auto &row : t) {\n    print(row);\n  }\n}\n\ntemplate<typename T>\nvoid print(const T &t) { cout << t << ' '; }\n\ntemplate<typename T, typename ...Args>\nvoid print(const T &t, const Args &...rest) {\n  print(t);\n  print(rest...);\n}\n\ntemplate<typename T>\nvoid println(const T &t) { cout << t << '\\n'; }\n\ntemplate<typename T, typename ...Args>\nvoid println(const T &t, const Args &...rest) {\n  print(t);\n  println(rest...);\n}\n\n// debug code by tourist\nstring to_string(const string &s) {\n    return '\"' + s + '\"';\n}\n\nstring to_string(const char *s) {\n    return to_string((string) s);\n}\n\nstring to_string(bool b) {\n    return (b ? \"true\" : \"false\");\n}\n\ntemplate<typename A, typename B>\nstring to_string(pair<A, B> p) {\n    return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate<typename A>\nstring to_string(A v) {\n    bool first = true;\n    string res = \"{\";\n    for (const auto &x : v) {\n        if (!first) {\n            res += \", \";\n        }\n        first = false;\n        res += to_string(x);\n    }\n    res += \"}\";\n    return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate<typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << to_string(H);\n    debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n// end DEBUG\nint main() {\n#if defined LOCAL\n  ifstream in(\"in.txt\");\n  cin.rdbuf(in.rdbuf());\n#endif\n  string s;\n  scan(s);\n  int n = SZ(s);\n  debug(s);\n  if (s.front() == '0' || s.back() == '1') {\n      println(\"-1\");\n      return 0;\n  }\n  for (int i = 0; i < n / 2; ++i) {\n      if (s[i] != s[n - 2 - i]) {\n          println(\"-1\");\n          return 0;\n      }\n  }\n  int cur = 1;\n  int last_node = 1;\n  for (int i = 1; i < n - 1; ++i) {\n      if (s[i] == '1') {\n          println(cur, ++last_node);\n          cur = last_node;\n          while (last_node != i + 1) {\n              println(cur, ++last_node);\n          }\n      }\n  }\n  println(cur, n);\n\n\n  // consider two adjacent nodes.\n  // A, B, d\n  // sum[root] - sum[i] = depth[i] * (size[i] - n + size[ascend[i]])\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\n\nconst int maxn = 1e5 + 5;\n\nint par[maxn], N, sub[maxn];\npair<ll, int> d[maxn];\n\nsigned main(void)\n{\n  ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n  if(fopen(\"A.INP\", \"r\")){\n    freopen(\"A.INP\", \"r\", stdin);\n    freopen(\"A.OUT\", \"w\", stdout);\n  }\n  cin >> N;\n  for(int i = 1; i <= N; ++i){\n    cin >> d[i].fi;\n    d[i].se = i;\n    sub[i] = 1;\n  }\n  sort(d + 1, d + 1 + N);\n  for(int i = N; i >= 2; --i){\n    int j = lower_bound(d + 1, d + 1 + N, mp(d[i].fi - (N - 2 * sub[d[i].se]), -1)) - d;\n    if(i == j) ++j;\n    if(d[j].fi != d[i].fi - (N - 2 * sub[d[i].se])){\n      cout << -1;\n      return 0;\n    }\n    par[d[i].se] = d[j].se;\n    sub[d[j].se] += sub[d[i].se];\n  }\n  for(int i = 1; i <= N; ++i){\n    if(par[i]) cout << i << ' ' << par[i] << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nmap<int,int> M1,M2;\nint s1[200010],pa[200010];\nstruct edge\n{\n\tint v,next;\n}vs[200010];\nint st[200010],ee,sz[200010],vis[20010];\ninline void addedge(int u,int v)\n{\n\tvs[++ee].v=v;vs[ee].next=st[u];st[u]=ee;\n}\t\ninline void dfs(int rt,int pr)\n{\n\tif(vis[rt]==1)\n\t{\n\t\tputs(\"-1\"),exit(0);\n\t}\n\tvis[rt]=1;\n\tfor(int i=st[rt];i;i=vs[i].next)\n\t{\n\t\tif(vs[i].v==pr) continue;\n\t\tdfs(vs[i].v,rt);\n\t\tsz[rt]+=sz[vs[i].v];\n\t}\n}\nsigned main()\n{\n\tint n=read();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=read();\n\t\tM1[x]=i; M2[x]=1;\n\t\ts1[i]=x;\n\t}\n\tsort(s1+1,s1+1+n);\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tint id=M1[s1[i]],sz=M2[s1[i]],td=s1[i]+2*sz-n;\t\n\t\tif(td==s1[i]) continue;\t\n\t\tpa[id]=M1[td]; M2[td]+=sz;\n\t}\n\tint rt=0;\n\tfor(int i=1;i<=n;i++) \n\t{\n\t\tif(pa[i]) addedge(pa[i],i),addedge(i,pa[i]);\n\t\telse \n\t\t{ \n\t\t\tif(rt) puts(\"-1\"),exit(0);\n\t\t\telse rt=i;\n\t\t}\n\t}\n\tif(!rt) puts(\"-1\"),exit(0);\n\tfor(int i=1;i<=n;i++) vis[i]=0;\n\tfor(int i=1;i<=n;i++) sz[i]=1;\n\tdfs(rt,0);\n\tif(sz[rt]!=n) puts(\"-1\"),exit(0);\n\telse\n\t{ \n\t\tfor(int i=1;i<=n;i++) if(pa[i])\n\t\t\tprintf(\"%lld %lld\\n\",i,pa[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<map>\nusing namespace std;\n\n#define se second\n#define fi first\n#define mk(a,b) make_pair(a,b)\n\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\n\nint N;\nvector<pll> V,ans;\nll child[100010];\nll dp[100010];\nmap<ll,ll> mp;\nll sum = 0;\nbool flag;\n\nint main()\n{\n    scanf(\"%d\",&N);\n    for(int i = 0; i < N; i++)\n    {\n        ll d;\n        scanf(\"%lld\",&d);\n        V.push_back(mk(d,i + 1));\n    }\n\n    sort(V.begin(),V.end());\n\n    for(int i = 0; i < V.size(); i++)mp[V[i].fi] = i + 1;\n    for(int i = 0; i <= N; i++)child[i] = 1;\n\n    for(int i = V.size() - 1; i > 0; i--)\n    {\n        ll val = V[i].fi - abs((N - child[i]) - child[i]);\n        if(mp[val] != 0 && val < V[i].fi)\n        {\n            int tmp = mp[val];\n            tmp--;\n            ans.push_back(mk(V[i].se,V[tmp].se));\n            sum += child[i];\n            child[tmp] += child[i];\n        }\n        else flag = true;\n    }\n\n    if(V[0].fi != sum || flag)printf(\"-1\\n\");\n    else\n    {\n        for(int i = 0; i < ans.size(); i++)\n        {\n            printf(\"%lld %lld\\n\",ans[i].fi,ans[i].se);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<60)+1e9; // ~ 1.15 * 1e18\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\n\nint check(vector<vector<int> > G, int root,int d){\n\n  function<int(int,int,int)>  dfs = [&](int pos,int pre,int dis){\n    int res = 0;\n    for(int to:G[pos]){\n      if(to == pre) continue;\n      res += dfs(to, pos, dis+1);\n    }\n    return res;\n  };\n  return dfs(root, -1, 0) == d;\n}\n\nsigned main(){\n  srand((unsigned)time(NULL));\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n;\n  cin>>n;\n  vector<P> D(n);\n  map<int,int> num;\n  map<int,int> inv;\n  for(int i=0;i<n;i++){\n    int d;\n    cin>>d;\n    D[i] = P(d, i);\n    num[d] = i;\n    inv[i] = d;\n  }\n  sort(D.begin(), D.end(), greater<P>());\n\n  vector<int> sz(n, 1);\n  vector<vector<int> > G(n);\n\n  auto add_edge = [&](int a,int b){\n    G[a].push_back(b);\n    G[b].push_back(a);\n  };\n\n  \n  for(int i=0;i<n-1;i++){\n    int d, pos; tie(d, pos) = D[i];\n    int x  = sz[pos];\n    int nd = d + x - (n - x);\n\n    if(!num.count(nd)){\n      cout<<-1<<endl;\n      return 0;\n    }\n    int to = num[nd];\n    if(inv[pos] <= inv[to]){\n      cout<<-1<<endl;\n      return 0;\n    }\n    \n    add_edge(pos, to);\n    sz[to] += sz[pos];\n  }\n\n  if(check(G, D[n-1].second, D[n-1].first)){\n    cout<<-1<<endl;\n    return 0;\n  }\n\n  for(int i=0;i<n;i++)\n    for(int to:G[i]){\n      if(i > to) continue;\n      cout<<i+1<<\" \"<<to+1<<endl;\n    }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ntypedef pair <int, int> pii;\n\nconst int N = 1e5 + 10;\nint n, cnt[N], par[N], sum[N], mark[N];\npii ar[N];\nmap <int, int> mp;\nvector <int> ch[N];\n\nvoid dfs(int v) {\n\tmark[v] = 1;\n\tfor (int i : ch[v]) {\n\t\tdfs(i);\n\t\tsum[v] += sum[i] + cnt[i];\n\t}\n}\n\nint32_t main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tfill(cnt, cnt + N, 1);\n\t\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> ar[i].first;\n\t\tar[i].second = i;\n\t\tmp[ar[i].first] = i;\n\t}\n\tsort(ar, ar + n);\n\t\n\tfor (int i = n - 1; i > 0; i--) {\n\t\tint v = ar[i].second;\n\t\tint nd = ar[i].first - n + 2 * cnt[v];\n\t\tif (mp.find(nd) == mp.end() || 2 * cnt[v] > n)\n\t\t\treturn cout << -1, 0;\n\t\t\n\t\tint p = mp[nd];\n\t\tch[p].push_back(v);\n\t\tpar[v] = p;\n\t\tcnt[p] += cnt[v];\n\t}\n\t\n\tdfs(ar[0].second);\n\tif (sum[ar[0].second] != ar[0].first)\n\t\treturn cout << -1, 0;\n\t\n\tfor (int i = 0; i < n; i++)\n\t\tif (!mark[i])\n\t\t\treturn cout << -1, 0;\n\t\n\tfor (int i = 1; i < n; i++)\n\t\tcout << i + 1 << \" \" << par[i] + 1 << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n\nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nint modpow(int a, long long n, int mod = MOD) { int ret = 1; do { if (n & 1) ret = 1LL * ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\n// counterclockwise from 12 o'clock direction\ntemplate<typename T> bool CompareBySlope(pair<T, T> a, pair<T, T> b) { if (a.first * b.first < 0) return a.first < b.first; if (a.first == 0) return a.second >= 0 || b.first > 0; if (b.first == 0) return b.second < 0 && a.first < 0; return a.second * b.first < a.first * b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\nvoid solve() {\n  int n; cin >> n;\n  vector<pair<ll, int>> g(n);\n  rep(i,n) {\n    cin >> g[i].first;\n    g[i].second = i;\n  }\n  sort(ALL(g));\n\n  vi cnt(n);\n  vector<pii> ans; ans.reserve(n-1);\n\n  rrep1(i,n) {\n    ll d; int idx;\n    tie(d, idx) = g[i];\n\n    ll nd = d - (n-2) + 2*cnt[idx];\n    auto itr = lower_bound(ALL(g), make_pair(nd, 0));\n\n    if (itr->first != nd || nd >= d) {\n      cout << -1 << endl;\n      return;\n    }\n\n    int nidx = itr->second;\n    cnt[nidx] += cnt[idx] + 1;\n    ans.emplace_back(idx+1, nidx+1);\n  }\n\n  if (cnt[g[0].second] != n-1) {\n    cout << -1 << endl;\n    return;\n  }\n\n  cout << ans << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(12);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int ll\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define gc getchar\n#define pc putchar\n#define fi first\n#define se second\n#define debug(x) cout << #x\" = \" << x << endl;\n#define pp(x,y) cout << \"pp: \" << x << \" \" << y << endl;\n#define rank __RAnK\ninline ll read(){\n\tregister ll x=0,f=1;register char c=gc();\n\tfor(;!isdigit(c);c=gc())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\n#define rd read\nvoid write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}\nvoid writeln(ll x){write(x);puts(\"\");}\nconst int maxn = 1e5+233;\nvector<pair<int,int> > ans;\nint d[maxn],w[maxn],a[maxn];\nint del,n;\nbool cmp(int x,int y){\n\treturn d[x] < d[y];\n}\nint query(int l,int r,int need){\n\tint pos = -1;\n\twhile(l<=r){\n\t\tint mid =(l+r)>>1;\n\t\tif(d[a[mid]] - del < need) l = mid + 1; else\n\t\tif(d[a[mid]] - del > need) r = mid - 1; else\n\t\treturn a[mid];\n\t}\n\treturn -1;\n}\nvector<int> edge[maxn];\nint f[maxn],F[maxn],size[maxn];\nvoid dfs(int u,int fa){\n\tf[u] = 0;\n\tsize[u] = 1;\n\tfor(auto v:edge[u]){\n\t\tif(v==fa) continue;\n\t\tdfs(v,u);\n\t\tsize[u] += size[v];\n\t\tf[u] += f[v] + size[v];\n\t}\n}\nvoid DFS(int u,int fa){\n\tif(u==1) F[u]=f[u];\n\tfor(auto v:edge[u]){\n\t\tif(v==fa) continue;\n\t\tF[v] = F[u] + (n - size[v]) - (size[v]);\n\t\tDFS(v,u);\n\t}\n}\nsigned main(){\n\tn = rd();\n\tRep(i,1,n) d[i] = rd();\n\tRep(i,1,n) w[i] = 1;\n\tRep(i,1,n) a[i] = i;\n\tsort(a+1,a+1+n,cmp);//从小到大排序 \n\tdel = 0;\n\tDep(i,n,2){\n\t\t/*当前是a[i] - del，权重为w[i]\n\t\t移动一步\n\t\t对于所有(n-w[i])个点，都要减少1*/\n\t\tll need = d[a[i]] - del - (n - w[a[i]]) + w[a[i]]; \n\t\tint pos = query(1,i-1,need);//找到标号\n\t\tif(pos == -1){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tdel += w[a[i]];\n\t\tw[pos] += w[a[i]];\n\t\tans . push_back(pii(a[i],pos));\n\t}\n\tfor(auto i:ans){\n\t\tint x = i.fi,y = i.se;\n\t\tedge[x]. push_back(y);\n\t\tedge[y]. push_back(x);\n//\t\tprintf(\"(%lld %lld)\\n\",x,y);\n\t}\n\tdfs(1,0);\n\tDFS(1,0);\n\tsort(d+1,d+1+n);\n\tsort(F+1,F+1+n);\n//\tRep(i,1,n){\n//\t\tdebug(f[i]);\n//\t}\n\tRep(i,1,n){\n//\t\tprintf(\"[](%lld %lld)\\n\",F[i],d[i]);\n\t\tif(d[i] != F[i]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(auto i:ans){\n\t\tprintf(\"%lld %lld\\n\",i.fi,i.se);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include<ext/pb_ds/assoc_container.hpp>\n//#include<ext/pb_ds/tree_policy.hpp>\n#define IOS ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n#define MAX 2000005\n#define MOD 1000000007\n#define MOD2 998244353\n#define pb push_back\n#define mp make_pair\n#define pii pair<ll,ll>\n#define vi vector<ll>\n#define vp vector<pii>\n#define all(v) v.begin(),v.end()\n#define sz(x) (ll)x.size()\n#define F first\n#define S second\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n#define ROF(i,a,b) for(ll i=a;i>=b;--i)\n#define trace(x) cerr<<#x<<\": \"<<x<<'\\n';\ntypedef long long ll;\nusing namespace std;\n//using namespace __gnu_pbds;\n//#define ordered_set tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>\n\nll mexp(ll a, ll b){\n    ll ans=1;\n    a%=MOD;\n    while(b){\n        if(b&1) ans=ans*a%MOD;\n        b>>=1;\n        a=a*a%MOD;\n    }\n    return ans;\n}\n\nconst int N = 100005;\n\nvector<int>g[N];\nll d[N],ssize[N];\nll ck[N],ckd;\nmap<ll,int>f;\n\nvoid dfs(int u, int p){\n    for(int v:g[u]){\n        if(v==p){\n            continue;\n        }\n        ck[v]=ck[u]+1;\n        dfs(v,u);\n    }\n    ckd+=ck[u];\n}\n\nvoid dfs2(int u,int p){\n    for(int v:g[u]){\n        if(v==p){\n            continue;\n        }\n        cout<<u<<\" \"<<v<<endl;\n        dfs2(v,u);\n    }\n}\n\nint main(){\n    IOS\n\n    int n;\n    cin>>n;\n    FOR(i,1,n+1){\n        cin>>d[i];\n        f[d[i]]=i;\n        ssize[i]=1;\n    }\n    sort(d+1,d+n+1);\n    ROF(i,n,2){\n        int u=f[d[i]];\n        ll dd=n-2*ssize[u];\n        if(dd<=0){\n            cout<<-1;\n            return 0;\n        }\n        dd=d[i]-dd;\n        if(f[dd]==0){\n            cout<<-1;\n            return 0;\n        }\n        int v=f[dd];\n        cerr<<u<<\" \"<<v<<endl;\n        ssize[v]+=ssize[u];\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    dfs(1,0);\n    if(f[ckd]!=1){\n        cout<<-1;\n    }\n    else{\n        dfs2(1,0);\n    }\n\n    cerr<<\"Time: \"<<1.0/CLOCKS_PER_SEC<<\" ms\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define loop(i, n) for(int i = 0;i < int(n);i++)\n#define rloop(i, n) for(int i = int(n);i >= 0;i--)\n#define range(i, a, b) for(int i = int(a);i <= int(b);i++)\n#define SZ(c) int(c.size())\n#define ALL(c) c.begin(), c.end()\n#define RALL(c) c.rbegin(), c.rend()\n#define PI acos(-1)\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n#define sfi1(v) scanf(\"%d\",&v)\n#define sfi2(v1, v2) scanf(\"%d %d\",&v1,&v2)\n#define sfi3(v1, v2, v3) scanf(\"%d %d %d\",&v1,&v2,&v3)\n#define sfll1(v) scanf(\"%I64d\",&v);\n#define sfll2(v1, v2) scanf(\"%I64d %I64d\",&v1,&v2)\n#define sfll3(v1, v2, v3) scanf(\"%I64d %I64d %I64d\",&v1,&v2,&v3)\n#define endl '\\n'\n\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int N = 1e5 + 5;\nint w[N];\nset<pair<ll, int> > s;\nvii ans;\nll D[N];\nint n;\n\n\nint main() {\n\n#ifndef ONLINE_JUDGE\n    //freopen(\"in.in\", \"r\", stdin);\n    //freopen(\"out.in\", \"w\", stdout);\n#endif\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    cin >> n;\n    range(i, 1, n) {\n        w[i] = 1;\n        cin >> D[i];\n        s.insert({D[i], i});\n    }\n\n    while (SZ(s) > 1) {\n        bool ok = false;\n        auto it = prev(s.end());\n        ll have = it->fr;\n        int idx = it->sc;\n        while (true) {\n            ll need = have - (n - 2 * w[idx]);\n            auto c = s.lower_bound({need, -1});\n            if (c == it)c++;\n            if (c == s.end() || c->fr != need)break;\n            ok = true;\n            w[c->sc] += w[idx];\n            ans.push_back({idx, c->sc});\n            s.erase(it);\n            it = c;\n            have = it->fr, idx = it->sc;\n        }\n\n        if (!ok) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    for (auto edge : ans)cout << edge.fr << \" \" << edge.sc << endl;\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define ms(s) memset(s, 0, sizeof(s))\nconst ll INF = 1e9;\ninline ll read() {\n\tll X = 0,w = 0 ;\n\tchar ch = 0;\n\twhile(!isdigit(ch)) {\n\t\tw |= ch == '-';\n\t\tch = getchar();\n\t}\n\twhile(isdigit(ch)) X = (X<<3) + (X<<1) + (ch ^ 48),ch = getchar();\n\treturn w ? -X : X;\n}\nll dat[100005];\npair<ll,ll> p[100005];\nll sz[100005];\nll from[100005];\nll to[100005];\nll n;\nint main() {\n\tcin>>n;\n\tfor(ll i=0; i<n; i++) {\n\t\tcin>>dat[i];\n\t\tp[i]=make_pair(dat[i],i);\n\t}\n\tsort(p,p+n);\n\tll id=0;\n\tll sum=0;\n\tfor(int i=0; i<n; i++) {\n\t\tsz[i]=1;\n\t}\n\tfor(ll i=n-1; i>=1; i--) {\n\t\tll curid=p[i].second;\n\t\tll tmp=p[i].first;\n\t\tll nx=n-2*sz[curid];\n\t\tif(nx<=0) {\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tll pos=lower_bound(p,p+n,make_pair(tmp-nx,0LL))-p;\n\t\tif(p[pos].first!=tmp-nx) {\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tfrom[id]=p[i].second;\n\t\tto[id++]=p[pos].second;\n\t\tsum+=sz[curid]*(n-sz[curid])*2;\n\t\tsz[p[pos].second]+=sz[curid];\n\t}\n\tll ans=0;\n\tfor(ll i=0; i<n; i++) {\n\t\tans+=dat[i];\n\t}\n\tif(sum!=ans) {\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tfor(ll i=0; i<id; i++) {\n\t\tcout<<from[i]+1<<\" \"<<to[i]+1<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// By Hacheylight\n\n#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n//#define int long long\n#define rep(i, a, b) for (int i = (a); i <= (b); i++)\n#define per(i, a, b) for (int i = (a); i >= (b); i--)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (int i = head[x]; i; i = e[i].nxt)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, sum) memset(a, sum, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter cout << endl\n#define siz(x) ((int)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef long double ld ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef pair <ll, int> pli ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef vector <vi> vvi ;\ntypedef queue <int> qi ;\ntypedef queue <pii> qii ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\ntypedef map <ll, int> mli ;\nconst int N = 100010 ;\nconst int INF = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst int mod = 1000000007 ;\nconst double eps = 1e-7 ;\nvoid douout(double x){ printf(\"%lf\\n\", x + 0.0000000001) ; }\ntemplate <class T> void print(T a) { cout << a << endl ; exit(0) ; }\ntemplate <class T> void chmin(T &a, T b) { if (a > b) a = b ; }\ntemplate <class T> void chmax(T &a, T b) { if (a < b) a = b ; }\nvoid add(int &a, int b) { a = a + b < mod ? a + b : a + b - mod ; }\nvoid sub(int &a, int b) { a = (a - b + mod) % mod ; }\nvoid mul(int &a, int b) { a = (ll) a * b % mod ; }\nint addv(int a, int b) { return (a += b) >= mod ? a -= mod : a ; }\nint subv(int a, int b) { return (a -= b) < 0 ? a += mod : a ; }\nint mulv(int a, int b) { return (ll) a * b % mod ; }\nint read() {\n    int f = 1, x = 0 ;\n    char ch = getchar() ;\n    while (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n    while (isdigit(ch)) { x = x * 10 + ch -'0' ; ch = getchar() ; }\n    return x * f ;\n}\nint pw(int a, int b) {\n\tint s = 1 ;\n\tfor (; b; b >>= 1, a = (ll) a * a % mod)\n    if (b & 1) s = (ll) s * a % mod ;\n    return s ;\n}\n\nint n ;\nvector <ll> d ;\nvi v[N] ;\nvii ed ;\nmli hsh ;\nint sz[N], vis[N], cnt[N] ;\nll dp[N] ;\n\nvoid dfs(int b, int prv = -1) {\n\tcnt[b]++ ;\n\tvis[b] = true ;\n\tfor (int go : v[b]) {\n\t\tif (go == prv) continue ;\n\t\tif (vis[go]) print(-1) ;\n\t\tdfs(go, b) ;\n\t\tdp[b] += dp[go] + cnt[go] ;\n\t\tcnt[b] += cnt[go] ;\n\t}\n}\n\nll ans[N] ;\n\nvoid dfs2(int b, int prv = -1, ll weight = 0) {\n\tans[b] = dp[b] + weight ;\n\tweight += dp[b] ;\n\tfor (int go : v[b]) {\n\t\tif (go == prv) continue ;\n\t\tdfs2(go, b, weight - dp[go] - cnt[go] + (n - cnt[go])) ;\n\t}\n}\n\nsigned main() {\n\tcin >> n ;\n\trep(i, 0, n - 1) {\n\t\tll a ; cin >> a ;\n\t\td.pb(a) ; hsh[a] = i ;\n\t}\n\tfor (auto it = hsh.rbegin(); it != hsh.rend(); it++) {\n\t\tint node = it->se ; ll val = it->fi ;\n\t\tsz[node]++ ;\n\t\tll op = n - sz[node] ;\n\t\tif (op == 0) continue ;\n\t\tll nxt = val + sz[node] - op ;\n\t\tif (hsh.count(nxt)) {\n\t\t\tint ne = hsh[nxt] ;\n\t\t\tsz[ne] += sz[node] ;\n\t\t\tv[ne].pb(node) ;\n\t\t\tv[node].pb(ne) ;\n\t\t\tif (ne > node) swap(ne, node) ;\n\t\t\ted.pb(mp(ne + 1, node + 1)) ;\n\t\t}\n\t}\n\tdfs(0) ;\n\tdfs2(0) ;\n\trep(i, 0, n - 1) if (ans[i] != d[i] || vis[i] == false) print(-1) ;\n\tloop(it, ed) printf(\"%d %d\\n\", it->fi, it->se) ;\n\n\treturn 0 ;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nint main()\n{\n    int n;\n    cin >> n;\n    vector<ll> d(n);\n    using P = pair<ll, ll>;\n    vector<P> p(n);\n    for(int i = 0; i < n; i++)\n    {\n        cin >> d[i];\n        p[i] = P(d[i], i+1);\n    }\n    sort(d.begin(), d.end());\n    sort(p.begin(), p.end());\n\n    vector<int> num(n);\n  vector<P> ans;\n    for(int i = n-1; i >= 1; i--)\n    {\n        num[i]++;\n        ll cand = d[i] - n + 2 * num[i];\n        int x = lower_bound(d.begin(), d.end(), cand) - d.begin();\n        if(x >= i || d[x] != cand)\n        {\n            cout << -1 << endl;\n            return 0;\n        }\n        num[x] += num[i];\n        ans.push_back(P(x, i));\n    }\n    for(int i = 0; i < ans.size(); i++)\n    {\n        cout << p[ans[i].first].second << \" \" << p[ans[i].second].second << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n#include <map>\n\ntypedef long long LL;\n\nLL read() {\n  LL ans = 0; int c, f = 1;\n  while (!isdigit(c = getchar()))\n    if (c == '-') f *= -1;\n  do ans = ans * 10 + c - '0';\n  while (isdigit(c = getchar()));\n  return ans * f;\n}\n\nconst int N = 100050;\nstd::map<LL, int> M;\n\nint n, siz[N], fa[N];\nLL p[N];\n\nint main() {\n  n = read();\n  for (int i = 1; i <= n; ++i)\n    siz[M[read()] = i] = 1;\n  for (std::map<LL, int>::iterator it = --M.end(); it != M.begin(); --it) {\n    LL D = it->first;\n    int i = it->second;\n    LL t = D - n + 2 * siz[i];\n    if (t >= D || !M.count(t)) { puts(\"-1\"); return 0; }\n    int j = M[t];\n    siz[fa[i] = j] += siz[i];\n    p[j] += siz[i] + p[i];\n  }\n  if (p[M.begin()->second] != M.begin()->first) {\n    puts(\"-1\"); return 0;\n  }\n  for (int i = 1; i <= n; ++i) if (fa[i])\n    printf(\"%d %d\\n\", fa[i], i);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\n \nstruct node{\n\tll w;\n\tint y;\n}a[100050];\n \nstruct node2{\n\tint t, nxt;\n}edge[200050];\n \nstruct node3{int fr, f;};\n \nint head[100050], cnt, n, siz[100050], anss;\n \nvoid add(int u, int v){\n\tedge[++cnt] = (node2){v, head[u]};\n\thead[u] = cnt;\n}\n \nbool cmp(node a, node b){return a.w<b.w;}\n \nint find(int u){\n\tfor(int i = u-1; i >= 1; i--)if(a[i].w - a[u].w == 2*siz[a[u].y] - n) return a[i].y;\n\treturn -1;\n}\n \nvoid print(int u, int fa){\n\tqueue<node3> q;\n\tq.push((node3){u, fa});\n\twhile(!q.empty()){\n\t\tu = q.front().fr;\n\t\tint ff = q.front().f;\n\t\tq.pop();\n\t\tfor(int i = head[u]; i; i = edge[i].nxt){\n\t\t\tint v = edge[i].t;\n\t\t\tprintf(\"%d %d\\n\", u, v);\n\t\t\tq.push((node3){v, u});\n\t\t}\n\t}\n}\n\nvoid test(int u, int fa, int dep){\n\tanss+=dep;\n\tfor(int i = head[u]; i; i = edge[i].nxt){\n\t\tint v = edge[i].t;\n\t\tif(v == fa) continue;\n\t\ttest(v, u, dep+1);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &a[i].w);\n\t\ta[i].y = i;\n\t}\n\tsort(a+1, a+n+1, cmp);\n\tint rt = a[1].y;\n\tfor(int i = n; i >= 2; i--) {\n\t\tsiz[a[i].y]++;\n\t\tint p = find(i);\n\t\tif(p == -1){\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[p]+=siz[a[i].y];\n\t\tadd(p, a[i].y);\n\t}\n\ttest(rt, 0, 0);\n\tif(anss != a[1].w){\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tprint(rt, 0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MN 100005\nint T,num,dep[MN],n,id[MN],head[MN];\nll a[MN];\nmap<ll,int>rea,cnt;\nstruct node{int x,y;};\nvector<node>sc;\nstruct edge{int to,next;}g[MN];\nbool cmp(int x,int y){return a[x]>a[y];}\nvoid ins(int u,int v){g[++num].next=head[u];head[u]=num;g[num].to=v;}\nvoid dfs(int u,int ff){\n\tfor(int i=head[u];i;i=g[i].next)if(g[i].to!=ff){\n\t\tdep[g[i].to]=dep[u]+1,dfs(g[i].to,u);\n\t}\n}\nint main(){\n//\tfreopen(\"test.in\",\"r\",stdin);\n//\tfreopen(\"mysol.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]),rea[a[i]]=i,cnt[a[i]]=1,id[i]=i;\n\tsort(id+1,id+n+1,cmp);\n\tfor(int i=1;i<n;i++){\n\t\tint t=id[i];ll tmp=a[t]-n+2*cnt[a[t]];\n\t\tif(rea[tmp]&&tmp<a[t]){\n\t\t\tcnt[tmp]+=cnt[a[t]];\n\t\t\tsc.push_back((node){t,rea[tmp]});\n\t\t}\n\t\telse return 0*puts(\"-1\");\n\t}\n\tfor(int i=0;i<sc.size();i++)ins(sc[i].x,sc[i].y),ins(sc[i].y,sc[i].x);\n\tdfs(id[n],id[n]);ll tans=0;\n\tfor(int i=1;i<=n;i++)tans+=dep[i];\n\tif(tans!=a[id[n]])return 0*puts(\"-1\");\n\tfor(int i=0;i<sc.size();i++)printf(\"%d %d\\n\",sc[i].x,sc[i].y);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nconst long long mo=50000007;\nconst int maxn=200010;\n\nint n,m,id[maxn],fa[maxn];\nlong long d[maxn],siz[maxn],ans,js[maxn];\nint tot,nex[maxn*2],las[maxn*2],tov[maxn*2];\nint hs[mo+10];\n\nvoid con(int x,int y)\n{\n\ttot++;\n\ttov[tot]=y;\n\tnex[tot]=las[x];\n\tlas[x]=tot;\n}\n\nvoid insert(long long x,int id)\n{\n\tlong long i=x%mo;\n\twhile (hs[i]!=0)\n\t{\n\t\ti++;\n\t\tif (i==mo) i=0;\n\t}\n\ths[i]=id;\n}\n\nlong long find(long long x)\n{\n\tlong long i=x%mo;\n\twhile (hs[i]!=0 && d[hs[i]]!=x)\n\t{\n\t\ti++;\n\t\tif (i==mo) i=0;\n\t}\n\treturn hs[i];\n}\n\nvoid qsort(int l,int r)\n{\n\tint i=l;int j=r;\n\tlong long m=d[(i+j)/2];\n\twhile (i<=j)\n\t{\n\t\twhile (d[i]>m) i++;\n\t\twhile (d[j]<m) j--;\n\t\tif (i<=j)\n\t\t{\n\t\t\tswap(d[i],d[j]);\n\t\t\tswap(id[i],id[j]);\n\t\t\ti++;j--;\n\t\t}\n\t}\n\tif (l<j) qsort(l,j);\n\tif (r>i) qsort(i,r);\n}\n\nvoid dfs(int x,int ff)\n{\n\tjs[x]=js[ff]+1;\n\tfor (int i=las[x];i;i=nex[i])\n\t{\n\t\tif (tov[i]!=ff)\n\t\t{\n\t\t\tdfs(tov[i],x);\n\t\t\tans+=js[x];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld\",&d[i]);\n\t\tid[i]=i;\n\t\tsiz[i]=1;\n\t}\n\tqsort(1,n);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinsert(d[i],i);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tlong long op=d[i]-abs(n-2*siz[i]);\n\t\tlong long oq=find(op);\n\t\tif (oq==0 || oq==i)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfa[i]=oq;\n\t\t\tsiz[oq]+=siz[i];\n\t\t\tcon(i,oq);con(oq,i);\n\t\t}\n\t}/*\n\tdfs(n,0);\n\tif (ans!=d[n])\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\telse*/\n\t{\n\t\tfor (int i=1;i<n;i++)\n\t\t{\n\t\t\tprintf(\"%d %d\\n\",id[i],id[fa[i]]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cassert>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <sstream>\n#include <ctime>\n#include <cctype>\n#include <set>\n#include <map>\n#include <queue>\n#include <bitset>\n#include <deque>\n#include <stack>\n#include <memory.h>\nusing namespace std;\ntypedef long long ll;\n#define mp make_pair\nvector<pair<ll,int> > e;\nmap<ll,int> ret;\nint n;\ninline void die(){\n    puts(\"-1\");\n    exit(0);\n}\nint main(){\n    cin>>n;\n    for(int i=0;i<n;i++){\n        ll x;\n        cin>>x;\n        ret[x]=i;\n        e.push_back(mp(x,i));\n    }\n    sort(e.begin(),e.end());\n    reverse(e.begin(),e.end());\n    ll x=e.back().first;\n    vector<int> siz(n,1);\n    vector<ll> dp(n,0);\n    vector<pair<int,int> > ans;\n    for(int i=0;i<e.size();i++){\n        pair<ll,ll> c=e[i];\n        if(c.first==x) continue;\n        if(siz[c.second]*2>=n){\n        \tdie();\n\t\t}\n        ll need=c.first+2*siz[c.second]-n;\n        if(!ret.count(need)){\n        \tdie();\n\t\t}\n        int par=ret[need];\n        dp[par]+=dp[c.second]+siz[c.second];\n        siz[par]+=siz[c.second];\n        ans.push_back(mp(c.second+1,par+1));\n    }\n    if(dp[e.back().second]!=x){\n    \tdie();\n\t}\n    for(int i=0;i<ans.size();i++){\n    \tif(ans[i].first>ans[i].second){\n    \t\tswap(ans[i].first,ans[i].second);\n\t\t}\n\t}   \n\tsort(ans.begin(),ans.end());\n\tfor(int i=0;i<ans.size();i++){\n\t\tcout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Written by Zhu Zeqi\n//Come on,baby\n//Hack,please\n#include <iostream> \n#include <cstdio> \n#include <fstream> \n#include <algorithm> \n#include <cmath> \n#include <deque> \n#include <vector> \n#include <queue> \n#include <string> \n#include <cstring> \n#include <map> \n#include <stack> \n#include <set> \n#define INF 0x3f3f3f3f3f3f3f3f\ntypedef long long ll;\n//orz yht\nusing namespace std;\nint main(){\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n    int n;\n  cin >> n;\n  vector<long long> d(n);\n  vector<int> weight(n, 1);\n  map<long long,int> mp;\n  for (int i = 0; i < n; i++) {\n    cin >> d[i];\n    mp[d[i]] = i;\n  }\n  vector<pair<int,int> > res;\n  for (int itt = 0; itt < n - 1; itt++) {\n    auto it = mp.rbegin();\n    int i = it->second;\n    long long want = d[i] - (n - weight[i]) + weight[i];\n    if (mp.find(want) == mp.end() || mp[want] == i) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n    int j = mp[want];\n    res.emplace_back(i, j);\n    weight[j] += weight[i];\n    mp.erase(--mp.end());\n  }\n  vector<long long> real_dist(n, -1);\n  real_dist[0] = 0;\n  vector<vector<int> > g(n);\n  for (auto &p : res) {\n    g[p.first].push_back(p.second);\n    g[p.second].push_back(p.first);\n  }\n  vector<int> que(1, 0);\n  for (int b = 0; b < (int) que.size(); b++) {\n    for (int j : g[que[b]]) {\n      if (real_dist[j] == -1) {\n        que.push_back(j);\n        real_dist[j] = real_dist[que[b]] + 1;\n      }\n    }\n  }\n  if (accumulate(real_dist.begin(), real_dist.end(), 0LL) != d[0]) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  for (auto &p : res) {\n    cout << p.first + 1 << \" \" << p.second + 1 << '\\n';\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define reg register\ntypedef long long ll;\nusing namespace std;\nconst int MN=1e5+5;\nint n,fa[MN],siz[MN],id[MN];\nll d[MN];\ninline bool cmp(int x,int y){return d[x]<d[y];}\nmap<ll,int>mp;\nll ans;\nint h[MN],cnt,to[MN],nxt[MN];\ninline void ins(int s,int t){\n\tto[++cnt]=t;nxt[cnt]=h[s];h[s]=cnt;\n}\nvoid dfs(int st,int fa=0,int dep=0){\n\tans+=dep;for(reg int i=h[st];i;i=nxt[i])dfs(to[i],st,dep+1);\n}\nint main(){\n\tios::sync_with_stdio(false);cin>>n;\n\tfor(reg int i=1;i<=n;i++)cin>>d[i],id[i]=i,siz[i]=1,mp[d[i]]=i;\n\tsort(id+1,id+1+n,cmp);reg int cnt=0;\n\tfor(reg int i=n;i>1;i--){\n\t\treg int pos=id[i];reg ll fad=d[pos]+2ll*siz[pos]-n;\n\t\tif(!mp[fad]||fad>=d[pos])return 0*puts(\"-1\");\n\t\treg int fap=mp[fad];siz[fap]+=siz[pos];ins(fap,pos);\n\t}\n\tdfs(id[1]);if(d[id[1]]^ans)return 0*puts(\"-1\");\n\tfor(reg int i=1;i<=n;i++)for(reg int j=h[i];j;j=nxt[j])printf(\"%d %d\\n\",i,to[j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#include<chrono>\n#include<random>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int MAXN=100005;\nvector<int> nxt[MAXN];\nvoid ins(int x,int y){nxt[x].emplace_back(y);}\nint id[MAXN],n;LL D[MAXN],C[MAXN];\nbool cmp(int n1,int n2){return D[n1]<D[n2];} \nint siz[MAXN];\nvoid gg(){pr2(-1);exit(0);}\nLL dis[MAXN],tot[MAXN];\nvoid getdis(int x,int fa)\n{\n\ttot[x]=1;\n\tfor(auto y:nxt[x])if(y^fa)getdis(y,x),tot[x]+=tot[y],dis[x]+=dis[y]+tot[y];\n}\nvoid query(int x,int fa,LL d1,LL d2)\n{\n\tif(dis[x]+d1!=D[x])gg();\n\tfor(auto y:nxt[x])if(y^fa)query(y,x,dis[x]-(dis[y]+tot[y])+d1+(n-tot[y]),n-tot[y]);\n}\nvoid answer(int x,int fa){for(auto y:nxt[x])if(y^fa)pr1(x),pr2(y),answer(y,x);}\nint main()\n{\n\tn=read();for(int i=1;i<=n;i++)D[i]=C[i]=read(),id[i]=i;\n\tsort(id+1,id+1+n,cmp);\n\tsort(C+1,C+1+n);\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tint u=id[i];++siz[u];\n\t\tif(siz[u]>n)gg();if(i==1)break;\n\t\tif(2*siz[u]>=n)ins(id[1],u),ins(u,id[1]),siz[1]+=siz[u];\n\t\telse\n\t\t{\n\t\t\tLL nx=D[u]-(n-2*siz[u]);\n\t\t\tif(D[id[i-1]]<nx)gg();\n\t\t\tint v=lower_bound(C+1,C+1+(i-1),nx)-C;\n\t\t\tif(C[v]!=nx)gg();ins(id[v],u),ins(u,id[v]);siz[id[v]]+=siz[u];\n\t\t}\n\t}if(siz[id[1]]!=n)gg();\n\tgetdis(1,0);query(1,0,0,0);\n\tanswer(1,0);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nconst int MAXN = 100005;\n\nstruct Edge\n{\n\tint to, next;\t\n}e[MAXN << 1];\nint head[MAXN], te = 1;\n\ninline void addE(int u, int v)\n{\n\te[++te] = (Edge){v, head[u]}, head[u] = te;\n}\n\nstruct State\n{\n\tlong long D;\n\tint id;\t\n}d[MAXN];\n\nbool operator <(const State &a, const State &b)\n{\n\treturn a.D > b.D;\n}\n\nmap<long long, int> mp;\n\nint size[MAXN], depth[MAXN], fa[MAXN];\n\nlong long Dn = 0;\n\nint n;\n\nvoid dfs(int u, int p = 0)\n{\n\tif (p != 0)\n\t{\n\t\tdepth[u] = depth[p] + 1;\n\t\tfa[u] = p;\n\t\tDn += depth[u];\t\n\t}\n\tfor (int j = head[u]; j != 0; j = e[j].next)\n\t\tif (e[j].to != p)\n\t\t\tdfs(e[j].to, u);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tscanf(\"%lld\", &d[i].D);\n\t\td[i].id = i, size[i] = 1;\n\t\tmp[d[i].D] = i;\n\t}\n\tsort(d + 1, d + n + 1);\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tlong long D = d[i].D - n + (size[d[i].id] << 1);\n\t\tif (mp[D] == 0)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\texit(0);\t\n\t\t}\n\t\taddE(d[i].id, mp[D]), addE(mp[D], d[i].id);\n\t\tsize[mp[D]] += size[d[i].id];\n\t}\n\tdfs(d[n].id);\n\tif (Dn != d[n].D)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\texit(0);\t\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (fa[i] != 0)\n\t\t\tprintf(\"%d %d\\n\", fa[i], i);\n\treturn 0;\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\nconst int N = 2e5;\nint n, cnt;\nint fa[N], ff[N];\nLL di[N], siz[N];\nmap <LL, int> val;\npair <int, int> edges[N];\nint ord[N];\nint get_f(int t)\n{\n    if (ff[t] == t) return t;\n    else return ff[t] = get_f(ff[t]);\n}\nvector <int> bi[N];\nint tss[N];\nLL sum[N];\nvoid dfs1(int t, int f = 0)\n{\n    tss[t] = 1;\n    for (int i = 0; i < bi[t].size(); ++ i)\n        if (bi[t][i] != f)\n        {\n            dfs1(bi[t][i], t);\n            sum[t] += sum[bi[t][i]] + tss[bi[t][i]];\n            tss[t] += tss[bi[t][i]];\n        }\n}\nvoid dfs2(int t, int f = 0, LL u = sum[1])\n{\n    if (u != di[t]) {puts(\"-1\"); exit(0);}\n    for (int i = 0; i < bi[t].size(); ++ i)\n        if (bi[t][i] != f)\n            dfs2(bi[t][i], t, u + n - 2 * tss[bi[t][i]]);\n}\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; ++ i) scanf(\"%lld\", &di[i]);\n    for (int i = 1; i <= n; ++ i) ord[i] = i, val[di[i]] = i, ff[i] = i;\n    sort(ord + 1, ord + n + 1, [=](int a, int b) {return di[a] > di[b];});\n    for (int i = 1; i < n; ++ i)\n    {\n        int p = ord[i];\n        siz[p] += 1;\n        LL q = di[p] + siz[p] * 2 - n;\n        if (!val.count(q)) {puts(\"-1\"); return 0;}\n        fa[p] = val[q];\n        if (get_f(p) == get_f(fa[p])) {puts(\"-1\"); return 0;}\n        ff[get_f(p)] = get_f(fa[p]);\n        siz[fa[p]] += siz[p];\n        bi[p].push_back(fa[p]);\n        bi[fa[p]].push_back(p);\n        edges[i] = make_pair(p, fa[p]);\n    }\n    dfs1(1);\n    dfs2(1);\n    for (int i = 1; i < n; ++ i) printf(\"%d %d\\n\", edges[i].first, edges[i].second);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 100003\nusing namespace std;\nstruct edge{int to,next;}e[maxn<<1];\nint head[maxn],cnte,fa[maxn];\nvoid add(int u,int v){e[++cnte].to=v,e[cnte].next=head[u],head[u]=cnte;}\nint n,sz[maxn],s[maxn];\nlong long d[maxn],sum;\nmap<long long,int> b;\nbool cmp(int x,int y){return d[x]<d[y];}\nvoid dfs(int u,int depth){\n\tsum+=depth;\n\tfor(int i=head[u];i;i=e[i].next){\n\t\tint v=e[i].to;\n\t\tif(v==fa[u])continue;\n\t\tdfs(v,depth+1);\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",d+i),s[i]=i,b[d[i]]=i,sz[i]=1;\n\tsort(s+1,s+n+1,cmp);\n\tfor(int i=n;i>=2;i--){\n\t\tint v=s[i];\n\t\tlong long d_u=d[v]-(n-sz[v])+sz[v];\n\t\tif(d_u>=d[v]||!b.count(d_u)){puts(\"-1\");return 0;}\n\t\tint u=b[d_u];\n\t\tadd(u,v),add(v,u),fa[v]=u;\n\t\tsz[u]+=sz[v];\n\t}\n\tif(cnte!=(n-1)*2){puts(\"-1\");return 0;}\n\tdfs(s[1],0);\n\tif(sum!=d[s[1]]){puts(\"-1\");return 0;}\n\tfor(int u=1;u<=n;u++){\n\t\tfor(int i=head[u];i;i=e[i].next){\n\t\t\tint v=e[i].to;\n\t\t\tif(v==fa[u])continue;\n\t\t\tprintf(\"%d %d\\n\",u,v);\n\t\t}\n\t}\n\treturn 0;\n}\n//sykakioi"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define ll  long long\n#define ld  double\n\n#define sz(x)   (int)x.size()\n#define all(x)  x.begin(),x.end()\n\n#define pb  emplace_back\n#define X   first\n#define Y   second\n\nconst int   N   = 2e5 + 5;\n\ntypedef pair<ll,int>    ii;\n\nii  a[N];\nint s[N];\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    int n;  cin >> n;\n\n    for(int i = 1 ; i <= n ; ++i)   {\n        ll  x;  cin >> x;\n        a[i].X = x;\n        a[i].Y = i;\n    }\n    sort(a + 1,a + 1 + n);\n    fill(s + 1,s + 1 + n,1);\n\n    vector<ii>  res;\n\n    ll  Sum = 0;\n\n    for(int i = n ; i >= 2 ; --i)   {\n        ll  val = a[i].X + s[i] + s[i] - n;\n        int pos = lower_bound(a + 1,a + 1 + n,ii(val,0)) - a;\n\n        if (a[pos].X != val)    {\n            cout << \"-1\";\n            return  0;\n        }\n        s[pos] += s[i]; res.pb(a[pos].Y,a[i].Y);\n        Sum += s[i];\n    }\n    if (Sum != a[1].X)  {\n        cout << \"-1\";\n        return  0;\n    }\n    for(ii  e : res)\n        cout << e.X << \" \",\n        cout << e.Y << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//300iq\n#define ll long long\n#define pii pair<int,int> \n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fi first\n#define se second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nvector<pair<ll,int> > e;\nmap<ll,int> ret;\nint n;\ninline void die(){\n    puts(\"-1\");\n    exit(0);\n}\nint main(){\n    cin>>n;\n    for(int i=0;i<n;i++){\n        ll x;\n        cin>>x;\n        ret[x]=i;\n        e.pb(mp(x,i));\n    }\n    sort(e.begin(),e.end());\n    reverse(e.begin(),e.end());\n    ll x=e.back().first;\n    vector<int> siz(n,1);\n    vector<int> dp(n,0);\n    vector<pii> ans;\n    for(int i=0;i<e.size();i++){\n        pii c=e[i];\n        if(c.first==x) break;\n        if(siz[c.se]*2>=n)\n            die();\n        ll need=c.first+2*siz[c.se]-n;\n        if(!ret.count(need))\n            die();\n        int par=ret[need];\n        dp[par]+=dp[c.se]+siz[c.se];\n        siz[par]+=siz[c.se];\n        ans.pb(mp(c.se+1,par+1));\n    }\n    if(dp[e.back().se]!=x)\n        die();\n    for(int i=0;i<ans.size();i++)\n        cout<<ans[i].fi<<\" \"<<ans[i].se<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <algorithm>\nusing namespace std;\n#define Maxn 100005\nint n,id[Maxn],par[Maxn],sz[Maxn];\nlong long a[Maxn];\nmap <long long,int> mp;\nint main()\t\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%lld\",&a[i]);\n\t\tmp[a[i]]=i;\n\t\tid[i]=i;\n\t\tsz[i]=1;\n\t}\n\tsort(id+1,id+n+1,[&](const int &x,const int &y)->bool{return a[x]>a[y];});\n\tfor (int i=1;i<n;++i)\n\t{\n\t\tint x=id[i];\n\t\tpar[x]=mp[a[x]-n+2*sz[x]];\n\t\tif (!par[x]) return (int)puts(\"-1\")*0;\n\t\tsz[par[x]]+=sz[x];\n\t}\n\tfor (int i=1;i<n;++i) a[id[n]]-=sz[id[i]];\n\tif (a[id[n]]) return (int)puts(\"-1\")*0;\n\tfor (int i=1;i<n;++i) printf(\"%d %d\\n\",id[i],par[id[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N;\nmap<long long,int> id;\nlong long seq[100050];\nint sz[100050];\nvector<int> v[100050];\nlong long ans = 0;\n\nvoid Serval(int pos,int dep,int lst)\n{\n\tans += dep;\n\tfor(int i = 0;i < v[pos].size(); ++ i)\n\t{\n\t\tint nxt = v[pos][i];\n\t\tif(nxt != lst)\n\t\t\tServal(nxt,dep + 1,pos);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i = 1;i <= N; ++ i)\n\t\tscanf(\"%lld\",&seq[i]),id[seq[i]] = i,sz[i] = 1;\n\tsort(seq + 1,seq + 1 + N);\n\tfor(int i = N;i >= 2; -- i)\n\t{\n\t\tint delta = N - 2 * sz[id[seq[i]]];\n\t\tif(delta < 0)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tlong long to_find = seq[i] - delta;\n\t\tif(!id.count(to_find))\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tsz[id[to_find]] += sz[id[seq[i]]];\n\t\tv[id[seq[i]]].push_back(id[to_find]);\n\t\tv[id[to_find]].push_back(id[seq[i]]);\n\t}\n\tServal(id[seq[1]],0,0);\n\tif(ans != seq[1])\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i = 1;i <= N; ++ i)\n\t{\n\t\tfor(int j = 0;j < v[i].size(); ++ j)\n\t\t{\n\t\t\tint nxt = v[i][j];\n\t\t\tif(nxt > i) printf(\"%d %d\\n\",i,nxt);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Inf 0x3f3f3f3f\n#define rg register\nusing namespace std;\nconst int Maxn = 1e5 + 5;\ntypedef long long ll;\ntypedef ll arr[Maxn];\nll min(ll x, ll y) { return x < y ? x : y; }\nll max(ll x, ll y) { return x > y ? x : y; }\ninline ll read()\n{\n\trg ll res = 0, sign = 1;\n\trg char ch = getchar();\n\twhile (!isdigit(ch))\n\t{\n\t\tif (ch == '-')\n\t\t\tsign = -1;\n\t\tch = getchar();\n\t}\n\tdo\n\t{\n\t\tres = (res << 3) + (res << 1) + (ch ^ 48);\n\t\tch = getchar();\n\t} while (isdigit(ch));\n\treturn res * sign;\n}\nint n;\nll dist;\narr siz, fa, dis;\nstruct str\n{\n\tll d;\n\tint id;\n\tbool operator<(str A) const { return d < A.d; }\n} p[Maxn];\nvector<int>to[Maxn];\nvoid DFS(int x)\n{\n    dist+=dis[x];\n    for(rg int i=0,nx;i<to[x].size();i++)\n    {\n        nx=to[x][i];\n        dis[nx]=dis[x]+1;\n        DFS(nx);\n    }\n}\nvoid Solve(int x)\n{\n    for(rg int i=0,nx;i<to[x].size();i++)\n    {\n        nx=to[x][i];\n        dis[nx]=dis[x]+n-2*siz[nx];\n        Solve(nx);\n    }\n}\nint main()\n{\n    ll tmp;\n\tint now, s;\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tp[i] = {read(), i};\n\t\tsiz[i] = 1;\n\t}\n\tsort(p + 1, p + n + 1);\n\tfor (int i = n; i > 1; i--)\n\t{\n\t\tnow = p[i].id;\n\t\ttmp = p[i].d - n + 2 * siz[now];\n\t\tfa[now] = p[s = lower_bound(p + 1, p + n + 1, (str){tmp, 0}) - p].id;\n        to[fa[now]].push_back(now);\n\t\tif (p[s].d != tmp || s >= i)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[fa[now]] += siz[now];\n\t}\n    DFS(p[1].id);\n    dis[p[1].id]=dist;\n    Solve(p[1].id);\n    for(int i=1;i<=n;i++)\n        if(dis[p[i].id]!=p[i].d)\n        {\n            puts(\"-1\");\n            return 0;\n        }\n\tfor (int i = 1; i <= n; i++)\n\t\tif (fa[i])\n\t\t\tprintf(\"%d %d\\n\", fa[i], i);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, sz[100010];\nlong long d[100010];\nmap<long long, int> mp;\nvector<pair<int, int>> ans;\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++)\n    {\n        scanf(\"%lld\", &d[i]);\n        mp[d[i]] = i;\n        sz[i] = 1;\n    }\n    for (int i = 1; i < n; i++)\n    {\n        auto it = mp.rbegin();\n        long long hh = it->first + 2 * sz[it->second] - n;\n        // printf(\"%d %d\\n\", mp[hh], it->second);\n        if (!mp.count(hh) || hh == it->first)\n        {\n            puts(\"-1\");\n            return 0;\n        }\n        ans.emplace_back(mp[hh], it->second);\n        sz[mp[hh]] += sz[it->second];\n        mp.erase(it->first);\n    }\n    for (auto x : ans) printf(\"%d %d\\n\", x.first, x.second);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long LL;\nint _min(int x, int y) {return x < y ? x : y;}\nint _max(int x, int y) {return x > y ? x : y;}\nLL read() {\n\tLL s = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = getchar();\n\treturn s * f;\n}\n\nstruct edge {\n\tint x, y, next;\n} f[110000], e[110000]; int len, last[110000];\nstruct node {\n\tLL x; int id;\n} a[110000];\nLL d[110000], sum;\nint tot[110000];\n\nbool cmp(node a, node b) {return a.x < b.x;}\n\nvoid ins(int x, int y) {\n\te[++len].x = x, e[len].y = y;\n\te[len].next = last[x], last[x] = len;\n}\n\nvoid dfs(int x, int dis) {\n\tsum += dis;\n\tfor(int k = last[x]; k; k = e[k].next) {\n\t\tint y = e[k].y;\n\t\tdfs(y, dis + 1);\n\t}\n}\n\nint main() {\n\tLL n = read();\n\tfor(LL i = 1; i <= n; i++) a[i].x = read(), a[i].id = i;\n\tsort(a + 1, a + n + 1, cmp);\n\tfor(LL i = 1; i <= n; i++) d[i] = a[i].x;\n\tfor(LL i = 1; i <= n; i++) tot[i] = 1;\n\tlen = 0;\n\tfor(LL i = n; i > 1; i--) {\n\t\tLL u = d[i] - n + 2 * tot[i];\n\t\tint fa = lower_bound(d + 1, d + n + 1, u) - d;\n\t\tif(d[fa] != u) {puts(\"-1\"); return 0;}\n\t\tf[++len].x = fa, f[len].y = i;\n\t\ttot[fa] += tot[i];\n\t} len = 0; for(int i = 1; i < n; i++) ins(f[i].x, f[i].y);\n\tsum = 0; dfs(1, 0);\n\tif(sum != d[1]) {puts(\"-1\"); return 0;}\n\tfor(int i = 1; i < n; i++) printf(\"%d %d\\n\", a[f[i].x].id, a[f[i].y].id);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1E5+5;\ntypedef long long int ll;\nint n,size,head[maxn],ans[maxn];\nll a[maxn],sum[maxn];\nmap<ll,ll>what;\nstruct edge\n{\n\tint to,next;\n}E[maxn*2];\ninline void add(int u,int v)\n{\n\tE[++size].to=v;\n\tE[size].next=head[u];\n\thead[u]=size;\n}\nll dfs(int u,int F,ll d)\n{\n\tll sum=0;\n\tfor(int i=head[u];i;i=E[i].next)\n\t{\n\t\tint v=E[i].to;\n\t\tif(v==F)\n\t\t\tcontinue;\n\t\tans[v]=u;\n\t\tsum+=dfs(v,u,d+1);\n\t}\n\treturn sum+d;\n}\ninline void solve()\n{\n\tfor(int i=1;i<=n;++i)\n\t\tsum[i]=1;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tll x=a[i]-n+sum[what[a[i]]]*2;\n\t\tif(!what[x])\n\t\t{\n\t\t\tcout<<-1<<endl;\n\t\t\texit(0);\n\t\t}\n\t\tadd(what[x],what[a[i]]);\n\t\tsum[what[x]]+=sum[what[a[i]]];\n\t}\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tcin>>a[i];\n\t\twhat[a[i]]=i;\n\t}\n\tll g=a[1],pos=1;\n\tfor(int i=2;i<=n;++i)\n\t\tif(a[i]<g)\n\t\t\tg=a[i],pos=i;\n\tsort(a+1,a+n+1);\n\treverse(a+1,a+n+1);\n\tsolve();\n\tif(dfs(pos,pos,0)!=g)\n\t{\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tif(ans[i])\n\t\t\tcout<<i<<\" \"<<ans[i]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MX=1e5+5;\npair<long long,int> a[MX];\nmap<long long,int> mp;\nlong long n;\nint p[MX];\nint visit[MX];\nlong long s[MX];\nint main(){\n    cin.tie(0);\n    cout.tie(0);\n    ios_base::sync_with_stdio(0);\n    cin>>n;\n    int i;\n    for(i=1 ; i<=n ; i++){\n        cin>>a[i].first;\n        a[i].second=i;\n        mp[a[i].first]=i;\n    }\n    sort(a+1,a+n+1);\n    for(i=n ; i>=2 ; i--){\n      ///  cout<<i<<endl;\n        s[a[i].second]++;\n        \n        int k=mp[a[i].first+2*s[a[i].second]-n];\n        if(k==0 || k==a[i].second || a[i].first+2*s[a[i].second]-n>=a[i].first){\n            cout<<-1;\n            return 0;\n        }\n        s[k]+=s[a[i].second];\n        p[a[i].second]=k;\n    }\n    for(i=2 ; i<=n ;i++){\n        cout<<a[i].second<<\" \"<<p[a[i].second]<<\"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <map>\nusing namespace std;\n#define fors(i,a,b) for(int i=(a);i<=(b);++i)\n#define ford(i,a,b) for(int i=(a);i>=(b);--i)\n#define min(x,y) ((x) < (y) ? (x) : (y))\n#define max(x,y) ((x) < (y) ? (y) : (x))\n#define swap(x,y) ((x)^=(y),(y)^=(x),(x)^=(y))\n#define abs(x) ((x) < 0 ? -(x) : (x)) \nconst int maxn=1e6+7;\ntypedef long long ll;\nconst int inf=1<<25;\nint read(){\n    int s=0,f=1;\n    char c=getchar();\n    while(c<'0' || c>'9') {if(c=='-') f=-1; c=getchar();}\n    while(c>='0' && c<='9') {s=s*10+c-48;c=getchar();}\n    return s*f;\n}\nvoid write(int x){\n    if(x<0) {putchar('-');x=-x;}\n    if(x>9) write(x/10);\n    putchar(x%10+48);\n}\nint tree[101010];\nlong long d[101010];\nint siz[101010],fa[101010];\nbool cmp(const int &x,const int &y)\n{\n    return d[x]<d[y];\n}\nmap<long long,int> mp;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    mp.clear();\n    for(int i=1;i<=n;i++){\n        scanf(\"%lld\",&d[i]);\n        siz[i]=1;\n        mp[d[i]]=i;\n        tree[i]=i;\n    }\n    sort(tree+1,tree+n+1,cmp);\n    for(int i=n;i>1;i--)\n    {\n        fa[tree[i]]=mp[d[tree[i]]+2*siz[tree[i]]-n];\n        if(!fa[tree[i]]){\n            printf(\"-1\");\n            return 0;\n        }\n        siz[fa[tree[i]]]+=siz[tree[i]];\n    }\n    for(int i=2;i<=n;i++)\n        d[tree[1]]-=siz[tree[i]];\n    if(d[tree[1]]){\n        printf(\"-1\");\n        return 0;\n    }\n    for(int i=2;i<=n;i++)\n        printf(\"%d %d\\n\",fa[tree[i]],tree[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n    > File Name: D.cpp\n    > Author: PumpkinYing\n    > Created Time: 2018/11/9 15:51:37\n ************************************************************************/\n\n#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <stack>\n#include <cmath>\nusing namespace std;\n\n#define mem(a,b) memset(a,b,sizeof(a))\n#define prii pair<int,int>\n#define prdd pair<double,double>\n#define rep(i,l,r) for(int i = l;i < r;i++)\n#define rep_(i,l,r) for(int i = l;i <= r;i++)\ntypedef long long ll;\n\nconst int maxn = 1000010;\nmap<ll,int> mp;\nint sz[maxn];\n\nstruct Node {\n\tll d;\n\tint id;\n\tvoid read(int i) {\n\t\tid = i;\n\t\tscanf(\"%lld\",&d);\n\t}\n\tbool operator < (const Node& b) const {\n\t\treturn d > b.d;\n\t}\n}ns[maxn];\n\nint fa[maxn],vis[maxn];\n\nint main() {\n\tint n;\n\tscanf(\"%d\",&n);\n\trep_(i,1,n) {\n\t\tns[i].read(i);\n\t\tmp[ns[i].d] = i;\n\t\tsz[i] = 1;\n\t}\n\tsort(ns+1,ns+1+n);\n\tint ok = 1;\n\tll tot = 0;\n\trep_(i,1,n-1) {\n\t\tint id = ns[i].id;\n\t\tvis[id] = 1;\n\t\tll val = ns[i].d+sz[id]-(n-sz[id]);\n\t\tif(mp[val] == 0 || vis[mp[val]]) {\n\t\t\tok = 0;\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tfa[id] = mp[val];\n\t\t\tsz[mp[val]] += sz[id];\n\t\t\ttot += sz[id];\n\t\t}\n\t}\n\tint root;\n\trep_(i,1,n) if(fa[ns[i].id] == 0) root = i;\n\tif(ok == 0 || ns[root].d != tot) printf(\"-1\\n\");\n\telse rep_(i,1,n) if(fa[i] != 0) printf(\"%d %d\\n\",i,fa[i]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int N=100003;\nint n;\nstruct Node{\n\tint id;\n\tll d;\n\tbool operator < (const Node &a) const\n\t{\n\t\treturn d>a.d;\n\t}\n}a[N];\nint siz[N],u[N],v[N];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\ta[i].id=i;\n\t\tscanf(\"%lld\",&a[i].d);\n\t}\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tsiz[i]=1;\n\tll dis=0;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tll d=a[i].d-n+siz[a[i].id]+siz[a[i].id];\n\t\tint x=lower_bound(a+1,a+n+1,(Node){0,d})-a;\n\t\tif(a[x].d!=d)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tu[i]=a[i].id,v[i]=a[x].id;\n\t\tsiz[a[x].id]+=siz[a[i].id];\n\t\tdis+=siz[a[i].id];\n\t}\n\tif(dis!=a[n].d)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d %d\\n\",u[i],v[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 100005;\n\nll distSum [MAX_N];\nint subSize [MAX_N];\n\nvector<int> adj [MAX_N];\nvoid addEdge (int u, int v) {\n  adj[u].push_back(v);\n  adj[v].push_back(u);\n}\n\nvoid distSumDfs (int vertex, int parent, int source, int lvl, ll &ans) {\n  ans += lvl;\n  for (int nxt : adj[vertex]) {\n    if (nxt != parent) {\n      distSumDfs(nxt, vertex, source, lvl + 1, ans);\n    }\n  }\n}\n\nint main () {\n  int vertexc;\n  cin >> vertexc;\n\n  vector<pair<ll, int>> elems;\n  map<ll, int> src;\n  fill(subSize + 1, subSize + vertexc + 1, 1);\n  for (int i = 1; i <= vertexc; i++) {\n    cin >> distSum[i];\n    \n    src[distSum[i]] = i;    \n    elems.push_back(make_pair(distSum[i], i));\n  }\n\n  sort(elems.begin(), elems.end(), greater<pair<ll, int>>());\n\n  for (pair<ll, int> pr : elems) {\n    if (pr == elems.back()) {\n      break;\n    }\n    \n    int vertex = pr.second;\n    ll parentSum = distSum[vertex] + subSize[vertex] - (vertexc - subSize[vertex]);\n    if (src.count(parentSum) == 0) {\n      cout << -1 << endl;\n      return 0;\n    }\n\n    int parent = src[parentSum];\n    addEdge(vertex, parent);\n    subSize[parent] += subSize[vertex];\n  }\n\n  ll realD = 0;\n  distSumDfs(elems.back().second, -1, elems.back().second, 0, realD);\n  if (realD != elems.back().first) {\n    cout << -1 << endl;\n    return 0;\n  }\n\n  for (int i = 1; i <= vertexc; i++) {\n    for (int u : adj[i]) {\n      if (u > i) {\n        cout << i << \" \" << u << '\\n';\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define Rep(i,v) rep(i,0,(int)v.size()-1)\n#define mp make_pair\n#define fir first\n#define sec second\n#define pb push_back\n#define gc getchar()\n#define lint long long\n#define debug(x) cerr<<#x<<\"=\"<<x\n#define sp <<\" \"\n#define ln <<endl\n#define wrong return !printf(\"-1\\n\")\n#define N 100010\nusing namespace std;\ntypedef pair<int,int> pii;\ninline int inn()\n{\n\tint x,ch;while((ch=gc)<'0'||ch>'9');\n\tx=ch^'0';while((ch=gc)>='0'&&ch<='9')\n\t\tx=(x<<1)+(x<<3)+(ch^'0');return x;\n}\nstruct P{\n\tlint d;int id;\n\tinline bool operator<(const P &p)const{return d>p.d;}\n}p[N];int n;\nvector<int> g[N];\nint us[N],vs[N],sz[N];\nlint d[N];map<lint,int> sv;\nint getdrt(int x,int l,int rt)\n{\n\td[rt]+=l;\n\tRep(i,g[x]) getdrt(g[x][i],l+1,rt);\n\treturn 0;\n}\nint getd(int x)\n{\n\tRep(i,g[x]) d[g[x][i]]=d[x]+n-2*sz[g[x][i]],getd(g[x][i]);\n\treturn 0;\n}\nint main()\n{\n\tn=inn();\n\tfor(int i=1;i<=n;i++) scanf(\"%lld\",&p[i].d),p[i].id=i,sv[p[i].d]=i;\n\tfor(int i=1;i<=n;i++) sz[i]=1;\n\tsort(p+1,p+n+1);//from big to small\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x=p[i].id;\n\t\tlint dlt=n-2*sz[x];\n\t\tif(dlt<=0) wrong;\n\t\tif(!sv.count(p[i].d-dlt)) wrong;\n\t\tint fa=sv[p[i].d-dlt];\n\t\tus[i]=x,vs[i]=fa,sz[fa]+=sz[x];\n\t}\n\tfor(int i=1;i<n;i++) g[vs[i]].pb(us[i]);\n\tint rt=p[n].id;getdrt(rt,0,rt),getd(rt);\n\tfor(int i=1;i<=n;i++)\n\t\tif(d[p[i].id]!=p[i].d) wrong;\n\tfor(int i=1;i<n;i++) printf(\"%d %d\\n\",us[i],vs[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <limits>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <unordered_map>\n#include <random>\n#include <cmath>\n#include <complex>\n// #include \"utiltime.hpp\"\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef complex<double> cdouble;\n\nconst int INFL = (int)1e9;\nconst ll INFLL = (ll)1e18;\nconst double INFD = numeric_limits<double>::infinity();\nconst double PI = 3.14159265358979323846;\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loopll(i, n) for(ll i = 0; i < (ll)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopll1(i, n) for(ll i = 1; i <= (ll)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = (ll)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define Looprll1(i, n) for(ll i = (ll)n; i >= 1; i--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(i, vector.size()) { cout << vector[i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(i, matrix.size()) { Loop(j, matrix[i].size()) { cout << matrix[i][j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define readfile(filename) ifstream in(filename); cin.rdbuf(in.rdbuf());\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\nbool nearlyeq(double x, double y) { return abs(x - y) < 1e6; }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(double x) { ll m = (ll)sqrt(x); return m + (m * m <= (ll)(x) ? 0 : -1); }\nll ceilsqrt(double x) { ll m = (ll)sqrt(x); return m + ((ll)x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\n\n/*******************************************************/\n\nvoid failed() {\n\tcout << -1 << endl;\n\texit(0);\n}\n\nint main() {\n\tquickio();\n\tint n; cin >> n;\n\tvector<P> a(n);\n\tLoop(i, n) {\n\t\tcin >> a[i].first;\n\t\ta[i].second = i;\n\t}\n\tsort(a.begin(), a.end());\n\tvi subtree_cnt(n, 0);\n\tvector<P> ans;\n\tLoopr1(i, n - 1) {\n\t\tint target_val = a[i].first + subtree_cnt[i] * 2 - n + 2;\n\t\tauto itr = lower_bound(a.begin(), a.end(), P({ target_val, 0 }));\n\t\tif (itr == a.end()) failed();\n\t\tif (itr - a.begin() == a.size() - 1) failed();\n\t\tif (itr->first != target_val) failed();\n\t\tsubtree_cnt[itr - a.begin()] += subtree_cnt[i] + 1;\n\t\tans.push_back({ i + 1, itr - a.begin() + 1 });\n\t\ta.pop_back();\n\t\tsubtree_cnt.pop_back();\n\t}\n\tLoop(i, ans.size()) {\n\t\tcout << ans[i].first << \" \" << ans[i].second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=1e5+10;\nstruct point{\n\tll x;\n\tint id;\n\tbool operator <(const point &rhs) const{\n\t\treturn x<rhs.x || (x==rhs.x && id<rhs.id);\n\t}\n}a[maxn];\nll sum;\nint fa[maxn],sz[maxn];\nint main(){\n\tint n=read();\n\tREP(i,1,n) a[i].x=readll(),a[i].id=i;\n\tsort(a+1,a+n+1);\n\tDREP(i,n,2){\n\t\tsz[i]++;\n\t\tll Nxt=a[i].x-n+sz[i]*2;\n\t\tint u=lower_bound(a+1,a+n+1,(point){Nxt,0})-a;\n\t\tif(a[u].x!=Nxt) return printf(\"-1\\n\"),0;\n\t\tsz[u]+=sz[i],fa[a[i].id]=a[u].id;\n\t}\n\tREP(i,2,n) sum+=sz[i];\n\tif(sum!=a[1].x) return printf(\"-1\\n\"),0;\n\tREP(i,1,n) if(fa[i]) printf(\"%d %d\\n\",fa[i],i);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <iomanip>\n#include <assert.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 100005;\n\nstruct Edge\n{\n\tint to;\n\tint next;\n}edge[MAXN << 1];\n\nint n,id;\nint first[MAXN];\nint cnt[MAXN];\nint ord[MAXN];\nint f[MAXN];\nint g[MAXN];\n\nll d[MAXN];\nll F[MAXN];\nll G[MAXN];\n\nvector<pair<int,int> > e;\n\nbool cmp(const int &a,const int &b)\n{\n\treturn d[a] < d[b];\n}\n\nvoid addE(int u,int v)\n{\n\tedge[++id] = (Edge){v,first[u]};\n\tfirst[u] = id;\n}\n\nint search(ll v)\n{\n\tint low = 1,high = n;\n\twhile (low < high)\n\t{\n\t\tint mid = (low + high) >> 1;\n\t\tif (d[ord[mid]] >= v)\n\t\t\thigh = mid;\n\t\telse\n\t\t\tlow = mid + 1;\n\t}\n\tif (d[ord[low]] == v)\n\t\treturn low;\n\treturn -1;\n}\n\nvoid dfs1(int now,int fa)\n{\n\tf[now] = 1;\n\tF[now] = 0;\n\tfor (int i = first[now];i;i = edge[i].next)\n\t\tif (edge[i].to != fa)\n\t\t{\n\t\t\tdfs1(edge[i].to,now);\n\t\t\tF[now] += F[edge[i].to] + f[edge[i].to];\n\t\t\tf[now] += f[edge[i].to];\n\t\t}\n}\n\nvoid dfs2(int now,int fa)\n{\n\tfor (int i = first[now];i;i = edge[i].next)\n\t\tif (edge[i].to != fa)\n\t\t{\n\t\t\tG[edge[i].to] = G[now] + F[now] - F[edge[i].to] - f[edge[i].to] + g[now] + f[now] - f[edge[i].to];\n\t\t\tg[edge[i].to] = g[now] + f[now] - f[edge[i].to];\n\t\t\tdfs2(edge[i].to,now);\n\t\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 1;i <= n;i++)\n\t{\n\t\tcin >> d[i];\n\t\tcnt[i] = 1;\n\t\tord[i] = i;\n\t}\n\tsort(ord + 1,ord + n + 1,cmp);\n\tfor (int i = n;i >= 2;i--)\n\t{\n\t\tint pos = search(d[ord[i]] - (n - cnt[ord[i]]) + cnt[ord[i]]);\n\t\tif (pos == -1 || pos >= i)\n\t\t{\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\te.push_back(make_pair(ord[i],ord[pos]));\n\t\taddE(ord[i],ord[pos]);\n\t\taddE(ord[pos],ord[i]);\n\t\tcnt[ord[pos]] += cnt[ord[i]];\n\t}\n\tdfs1(1,0);\n\tdfs2(1,0);\n\tfor (int i = 1;i <= n;i++)\n\t\tif (d[i] != F[i] + G[i])\n\t\t{\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\tfor (int i = 0;i < e.size();i++)\n\t\tcout << e[i].first << ' ' << e[i].second << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\n#define Accepted 0; \n\nconst int Maxv = 100010; \nlong long d[Maxv], u[Maxv], v[Maxv], ghostfly233[Maxv], siz[Maxv], cnt;  \n\nint main() {\n    int n; \n    scanf(\"%d\", &n); \n    for (int i = 1; i <= n; i++) \n        scanf(\"%lld\", &d[i]); \n\n    std::sort(d + 1, d + n + 1); \n    for (int i = 1; i <= n; i++) {\n        int tmp = std::lower_bound(d + 1, d + n + 1, d[i]) - d; \n        if (d[tmp] != d[i]) {\n            puts(\"-1\"); \n            return 0; \n        }\n        \n        ghostfly233[tmp] = i;         \n    }\n\n    for (int i = 1; i <= n; i++)\n        siz[i] = 1; \n\n    for (int i = n; i > 1; i--) {\n        int tmp = std::lower_bound(d + 1, d + n + 1, d[i] - n + (siz[i] << 1)) - d; \n        if (d[tmp] != d[i] - n + (siz[i] << 1)) {\n            puts(\"-1\"); \n            return 0; \n        }\n        \n        u[i] = tmp; \n        siz[ u[i] ] += siz[i]; \n        cnt += siz[i]; \n    }\n\n    if (cnt != d[1]) {\n        puts(\"-1\"); \n        return 0; \n    }\n\n    printf(\"%lld\\n\", cnt); \n    for (int i = 2; i <= n; i++)\n        printf(\"%lld %lld\\n\", ghostfly233[i], ghostfly233[ u[i] ]); \n\n    return Accepted;  \n}"
  },
  {
    "language": "C++",
    "code": "\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long int LL;\nconst int Max_N(100050);\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nstruct node\n{\n\tint u;\n\tLL d;\n};\nint N, Head[Max_N], Next[Max_N], Size[Max_N];\nnode V[Max_N];\nmap<int, int> S;\n\ninline void Add_Edge(int s, int t)\n{\n\tNext[t] = Head[s], Head[s] = t;\n}\n\ninline bool comp(const node &a, const node &b)\n{\n\treturn a.d > b.d;\n}\n\nLL Sum;\nvoid dfs(int u, int dep)\n{\n\tSum += dep;\n\tfor (int v = Head[u];v;v = Next[v])\n\t\tdfs(v, dep + 1);\n}\n\nvoid dfs2(int u)\n{\n\tif (S[Sum] != u)\n\t{\n\t\tprint(-1);\n\t\texit(0);\n\t}\n\tfor (int v = Head[u];v;v = Next[v])\n\t\tSum += (N - Size[v]) - Size[v], dfs2(v), Sum -= (N - Size[v]) - Size[v];\n}\n\nint main()\n{\n\tgi(N);\n\tfor (int i = 1;i <= N;++i)\n\t\tgi(V[V[i].u = i].d), S[V[i].d] = V[i].u, Size[i] = 1;\n\tsort(V + 1, V + 1 + N, comp);\n\tfor (int i = 1, u, fa;i <= N;++i)\n\t{\n\t\tu = V[i].u;\n\t\tLL d = V[i].d - (N - Size[u]) + Size[u];\n\t\tif (d <= V[i].d || !(fa = S[d]))\n\t\t{\n\t\t\tprint(-1);\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t\tAdd_Edge(fa, u), Size[fa] += Size[u];\n\t}\n\tdfs(1, 0);\n\tdfs2(1);\n\tfor (int u = 1;u <= N;++u)\n\t\tfor (int v = Head[u];v;v = Next[v])\n\t\t\tprint(u), putc(' '), print(v), putc('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct union_find{\n\tstatic const int DEFAULT = 200200;\n\tvector<int> parent;\n\tint N;\n\tunion_find(int N = DEFAULT) : N(N) {\n\t\tclear();\n\t}\n\tvoid clear(){\n\t\tparent.assign(N, -1);\n\t}\n\tint find(int u){\n\t\treturn (parent[u] < 0) ? u : parent[u] = find(parent[u]);\n\t}\n\tbool is_connected(int u, int v){\n\t\treturn find(u) == find(v);\n\t}\n\tbool join(int u, int v){\n\t\tu = find(u);\n\t\tv = find(v);\n\t\tif (u != v){\n\t\t\tif (parent[u] > parent[v])\n\t\t\t\tswap(u, v);\n\t\t\tparent[u] += parent[v];\n\t\t\tparent[v] = u;\n\t\t}\n\t\treturn u != v;\n\t}\n\tint size(int u){\n\t\treturn -parent[find(u)];\n\t}\n};\nint main(){\n\tint n; cin >> n;\n\tvector<pair<long long, int> > vals;\n\tmap<long long, int> rev;\n\tunion_find uf(n);\n\tlong long sum = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tlong long x; cin >> x;\n\t\trev[x] = i;\n\t\tvals.push_back({x, i});\n\t\tsum += x;\n\t}\n\tif(sum&1){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tvector<pair<int,int> > edges;\n\tsort(vals.rbegin(), vals.rend());\n\tfor(int i = 0; i < n - 1; i++){\n\t\tlong long cost; int u;\n\t\ttie(cost, u) = vals[i];\n\t\tint sz = uf.size(u);\n\t\tlong long ncost = cost - n + 2 * sz;\n\t\tauto it = rev.find(ncost); \n\t\tif(it == rev.end()){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint x = u, y = it->second;\n\t\tif(x > y) swap(x, y);\n\t\tedges.push_back({x, y});\n\t\tuf.join(x, y);\t\n\t}\n\tsort(edges.begin(), edges.end());\n\tfor(auto e : edges) cout << e.first + 1 << \" \" << e.second + 1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline int read()\n{\n\tint x = 0, f = 1; char c = getchar();\n\twhile (!isdigit(c)) {if (c == '-') f = -1; c = getchar();}\n\twhile (isdigit(c)) {x = x * 10 + c - '0', c = getchar();}\n\treturn x * f;\n}\n\nconst int MAXN = 1e5 + 10;\nint n, seq[MAXN], sz[MAXN], root;\nvector<int> linker[MAXN];\nll D[MAXN], f[MAXN], g[MAXN];\n\ninline bool cmp(const int &a, const int &b) {return D[a] < D[b];}\n\nvoid dfs(int x, int fa)\n{\n\tf[x] = 0;\n\tfor (int i = 0; i < linker[x].size(); i ++)\n\t{\n\t\tint cur = linker[x][i];\n\t\tif (cur == fa) continue;\n\t\tdfs(cur, x), f[x] += f[cur] + sz[cur];\n\t}\n}\n\nvoid dfs2(int x, int fa)\n{\n\tif (x == 1) g[x] = 0;\n\telse g[x] = g[fa] + n - sz[x] + f[fa] - f[x] - sz[x];\n\tfor (int i = 0; i < linker[x].size(); i ++)\n\t{\n\t\tint cur = linker[x][i];\n\t\tif (cur == fa) continue;\n\t\tdfs2(cur, x);\n\t}\n}\n\ninline bool check()\n{\n\tdfs(root, 0), dfs2(root, 0);\n//\tfor (int i = 1; i <= n; i ++)\n//\t\tprintf(\"(%d, %d), \", f[i], g[i]);\n//\tputs(\"\");\n\tfor (int i = 1; i <= n; i ++)\n\t\tif (f[i] + g[i] != D[i]) return 0;\n\treturn 1;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\tn = read();\n\tfor (int i = 1; i <= n; i ++) D[i] = read(), seq[i] = i, sz[i] = 1;\n\tsort(seq + 1, seq + 1 + n, cmp), root = seq[1];\n\tfor (int i = n; i > 1; i --)\n\t{\n\t\tint now = seq[i];\n\t\tint l = 1, r = i - 1, pos = -1;\n\t\tll need = D[now] + 2 * sz[now] - n;\n\t\twhile (l <= r)\n\t\t{\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tif (D[seq[mid]] == need)\n\t\t\t{\n\t\t\t\tpos = seq[mid];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (D[seq[mid]] > need) r = mid - 1;\n\t\t\telse l = mid + 1;\n\t\t}\n//\t\tprintf(\"(%d, %d, %d, %d)\\n\", now, pos, sz[now], need);\n\t\tif (pos == -1) return puts(\"-1\"), 0;\n\t\tlinker[pos].push_back(now), sz[pos] += sz[now];\n\t}\n\tif (check())\n\t{\n\t\tfor (int i = 1; i < n; i ++)\n\t\t{\n\t\t\tfor (int j = 0; j < linker[i].size(); j ++)\n\t\t\t{\n\t\t\t\tint to = linker[i][j];\n\t\t\t\tprintf(\"%d %d\\n\", i, to);\n\t\t\t}\n\t\t}\n\t}\n\telse puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = pair<lint, int>;\nconst int MAXN = 100005;\n\nvoid my_ass(bool p){\n\tif(!p){\n\t\tputs(\"-1\");\n\t\texit(0);\n\t}\n}\n\nint n;\npi a[MAXN];\nvector<int> gph[MAXN];\nset<int> s[2];\nint left_size[MAXN];\n\nlint get_dist(int x, int p, int d){\n\tlint ret = d;\n\tfor(auto &i : gph[x]){\n\t\tif(i != p){\n\t\t\tret += get_dist(i, x, d + 1);\n\t\t}\n\t}\n\treturn ret;\n}\n\nvector<pi> new_event[MAXN];\n\nvoid INSERT(int pos, int val, int atleast){\n\tlint v = n + a[val].second - 2 * left_size[a[val].second] + 2;\n\tint l = lower_bound(a + 1, a + n + 1, pi(v, -1)) - a;\n\tnew_event[max(l, atleast)].push_back(pi(pos, val));\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<=n; i++){\n\t\tscanf(\"%lld\",&a[i].first);\n\t\ta[i].second = i;\n\t}\n\tsort(a + 1, a + n + 1);\n\tleft_size[a[1].second] = n;\n\tINSERT(a[1].first % 2, 1, 2);\n\tfor(int i=2; i<=n; i++){\n\t\tfor(auto &j : new_event[i]){\n\t\t\ts[j.first].insert(j.second);\n\t\t}\n\t\tint msk = (a[i].first % 2) ^ (n % 2);\n\t\tmy_ass(!s[msk].empty());\n\t\tmy_ass(a[i].first <= n + a[*s[msk].begin()].first - 2);\t\n\t\tint pidx = *s[msk].begin();\n\t\t/*\n\t\tfor(auto &j : s[msk]){\n\t\t\tif(n + a[j].first - 2 * left_size[a[j].second] + 2 <= a[i].first){\n\t\t\t\tpidx = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}*/\n\t\tmy_ass(pidx != -1);\n\t\tint par = a[pidx].second;\n\t\tint cur = a[i].second;\n\t\tgph[par].push_back(cur);\n\t\tgph[cur].push_back(par);\n\t\tleft_size[cur] = n - (a[i].first - a[pidx].first);\n\t\tleft_size[cur] /= 2;\n\t\tleft_size[par] -= left_size[cur];\n\t\ts[msk].erase(pidx);\n\t\tif(left_size[par] != 1){\n\t\t\tINSERT(msk, pidx, i + 1);\n\t\t}\n\t\tif(left_size[cur] != 1){\n\t\t\tINSERT(a[i].first % 2, i, i + 1);\n\t\t}\n\t}\n\tfor(int i=1; i<=1; i++){\n\t\tmy_ass(get_dist(a[i].second, -1, 0) == a[i].first); \n\t}\n\tfor(int i=1; i<=n; i++){\n\t\tfor(auto &j : gph[i]){\n\t\t\tif(i < j) printf(\"%d %d\\n\", i, j);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//Konrad Paluszek,University of Warsaw(former XIV LO Staszic)\n//#STAY AT HOME\n#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n#define TIME (chrono::steady_clock::now().time_since_epoch().count())\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#define xfm(a,b)a##b\n#define xwb(a,b)xfm(a,b)\n#define _ xwb(nvj,__LINE__)\n#define __ xwb(kjy,__LINE__)\n#define ___ xwb(cjm,__LINE__)\n#define REP(i,n)for(urs(n)i=0;i<(n);++i)\n#define UNTIL(t)while(clock()<(t)*CLOCKS_PER_SEC)\n#define PER(r...)for(bool _=1;_||next_permutation(r);_=false)\n#define ALL(r)(r).begin(),(r).end()\n#define RALL(r)(r).rbegin(),(r).rend()\n#define FS(r)r.first,r.second\n#define SF(r)r.second,r.first\n#define M0(r) memset(r, 0, sizeof(r))\n#define sim template<class c\n#define ros return o\n#define rans return ans\n#define forbits(i,m)if(m)for(urs(m)i=ctz(m),i##nvj=m;i##nvj;i##nvj^=((urs(m))1<<i),i=ctz(i##nvj))\n#define fordbits(i,m)if(m)for(urs(m)i=8*sizeof(m)-clz(m)-1,i##nxd=m;i##nxd;i##nxd^=((urs(m))1<<i),i=8*sizeof(m)-clz(i##nxd)-1)\n#define ksets(t, m, k, n) for (t m = (((t)1 << (k)) - 1); m < ((t)1 << (n)); m = nux(m))\n#define urs(r...)typename decay<decltype(r)>::type\n#define hur(f,g,r)sim>int f(c a){if(sizeof(c)==16)return r;if(sizeof(c)==8)return g##ll(a);return g(a);}\n#define pwq(t,i) int clz(t x){return clz<int>(x)-i;}\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wconversion\"\nusing namespace __gnu_pbds;using namespace std;using ll=long long;using ld=long double;using ull=unsigned long long;using vi=vector<int>;using vll=vector<ll>;using pii=pair<int,int>;using pll=pair<ll,ll>;using vpii=vector<pii>;using spii=set<pii>;using mii=map<int,int>;using unt=unsigned int;sim>using min_queue=priority_queue<c,vector<c>,greater<c>>;sim,class b,class cmp=less<c> >using ordered_map=tree<c,b,cmp,rb_tree_tag,tree_order_statistics_node_update>;sim, class cmp=less<c>>using ordered_set = ordered_map<c,null_type,cmp>;hur(popc,__builtin_popcount,popc<ull>(a)+popc<ull>(a>>64))hur(ctz,__builtin_ctz,(ull)a?ctz<ull>(a):64+ctz<ull>(a>>64))hur(clz,__builtin_clz,a>>64?clz<ull>(a>>64):64+clz<ull>(a))pwq(short,16)pwq(uint16_t,16)pwq(char,24)pwq(int8_t,24)pwq(uint8_t,24)sim,class N>bool mini(c&o,const N&h){if(o>h)ros=h,1;return 0;}sim,class N>bool maxi(c&o,const N&h){if(o<h)ros=h,1;return 0;}sim,class n>using gyv=c;\n#if defined(LOCAL) // || defined(LOCAL2)\n#include </home/kjp/headers/debuglib.hpp>\n#else\n#define loc(...)\n#define onl(r...)r\n#define debug(...)\n#define print_stack(...)\n#define mark_stack(...)\n#define set_pre(...)\n#define reg_it(...)\n#define def_op(...) struct _{};\n#if !defined(LOCAL) && !defined(LOCAL2)\n#define exit my_exit\nvoid my_exit(int x) {fflush(stdout);_Exit(x);}\n#endif\n#endif\n#define next nexT\n#define prev preV\n#define tree trEE\n#define left lefT\n#define right righT\n#define div diV\n#define y1 y_1\n#define pow do not use cmath pow unless you know what you are doing\null mix(ull o){o+=0x9e3779b97f4a7c15;o=(o^(o>>30))*0xbf58476d1ce4e5b9;o=(o^(o>>27))*0x94d049bb133111eb;ros^(o>>31);}ull SALT=0x7a14a4b0881ebf9,tqu=0x7a14a4b0881ebf9;ull my_rand(){return tqu=mix(tqu);}void my_srand(ull x){SALT=tqu=x;}const int inf = 1023400000;const ll llinf=1234567890000000000ll;ll fix(ll o, ll m){o%=m;if(o<0)o+=m;ros;}\n#define rand my_rand\n#define srand my_srand\n#define random_shuffle(r...)random_shuffle(r,[](int _){return my_rand()%_;})\nsim>inline c nux(c m){if(!m)return numeric_limits<c>::max();c A=m&-m;c B=~((A-1)^m);c C=B&-B;c D=(C>>(1+ctz(A)))-1;return C|(m&~(C-1))|D;}__attribute__((no_sanitize_undefined))ll mul(ll a,ll b,ll m){ll q=(ll)(a*(ld)b/m);ll o=a*b-q*m;o%=m;if(o<0)o+=m;ros;}sim>void unq(c&x){x.resize(unique(ALL(x))-x.begin());}\n#pragma GCC diagnostic pop\n#if ((ULONG_MAX) != (UINT_MAX))\nnamespace std {template <> struct is_signed<__int128> : public true_type {};}\n#endif\nsim, class d> typename common_type<c,d>::type floor_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using floor_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b - (a % b < 0);}\nsim, class d> typename common_type<c,d>::type ceil_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using ceil_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b + (a % b > 0);}\nsim> struct REV {using value_type=typename c::value_type;c &x;using it=typename c::reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> struct CREV {using value_type=typename c::value_type;const c&x;using it=typename c::const_reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> REV<c> reversed(c&x) {return REV<c>{x};}sim> CREV<c> reversed(const c&x) {return CREV<c>{x};}\n#define done(r...) exit(0 * printf(r))\n#if defined(LOCAL) || defined(LOCAL2)\nvoid __tmi() {cerr << setprecision(6) << fixed << \"total time: \" << clock() / (ld)CLOCKS_PER_SEC << \"s\" << endl;}int _ = (atexit(__tmi), 0);\n#endif\n//#STAY AT HOME\nconst int nax = 1e5 + 44;\nvi graf[nax];\nint siz[nax];\nll d[nax];\nmap <ll, int> wh;\nvpii ans;\nvoid add_edge(int a, int b) {\n\tgraf[a].push_back(b);\n\tgraf[b].push_back(a);\n\tans.emplace_back(a + 1, b + 1);\n}\nvoid err() {\n\tdone(\"-1\\n\");\n}\nll su = 0;\nvoid dfs(int x, int y = -1, int d = 0) {\n\tfor (int v : graf[x]) if (v != y) dfs(v, x, d + 1);\n\tsu += d;\n}\nvoid solve() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tif (n % 2 == 0 && n <= 1000) err();\n\tREP(i, n) scanf(\"%lld\", d + i);\n\tREP(i, n) siz[i] = 1;\n\tvector <pair <ll, int> > ord(n);\n\tREP(i, n) ord[i] = {d[i], i};\n\tREP(i, n) wh[d[i]] = i;\n\tsort(RALL(ord));\n\tREP(ind, n - 1) {\n\t\tauto [v, i] = ord[ind];\n\t\tll oth = v - n + siz[i] * 2;\n\t\tauto it = wh.find(oth);\n\t\tif (it == wh.end() || it->second == i) err();\n\t\tadd_edge(i, it->second);\n\t\tsiz[it->second] += siz[i];\n\t}\n\tdfs(0);\n\tif (su != d[0]) err();\n\tfor (auto [x, y] : ans) printf(\"%d %d\\n\", x, y);\n}\nint main() {\n\t// unt seed = TIME; debug(imie(seed));srand(seed);\n\tint t = 1;\n\t// scanf(\"%d\", &t);\n\tREP(_, t) solve();\n\texit(0);\n}\n//#STAY AT HOME\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int MN = 100010;\n\nint N;\nll D[MN];\nvector<pair<ll, int> > ord;\nint inv[MN], sz[MN];\nvector<pii> edge;\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N; i++) {\n        scanf(\"%lld\", &D[i]);\n        ord.push_back({ D[i], i });\n    }\n\n    sort(ord.begin(), ord.end());\n    for(int i = 0; i < N; i++) inv[ ord[i].second ] = i;\n    sort(D, D + N);\n\n    for(int i = 0; i < N; i++) sz[i] = 1;\n    for(int i = N - 1; i >= 1; i--) {\n        if(D[i] - N + 2 * sz[i] <= 0) {\n            printf(\"-1\");\n            return 0;\n        }\n        int a = lower_bound(D, D + N, D[i] - N + 2 * sz[i]) - D;\n        if(D[a] != D[i] - N + 2 * sz[i]) {\n            printf(\"-1\");\n            return 0;\n        }\n\n        edge.push_back(pii(inv[a], inv[i]));\n        sz[a] += sz[i];\n    }\n\n    for(int i = 0; i < N - 1; i++) {\n        printf(\"%d %d\\n\", edge[i].first + 1, edge[i].second + 1);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint N;\nvector<int> D;\nvector<pair<int, int>> sorted;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> N;\n    D.resize(N);\n\n    for (int &d : D)\n        cin >> d;\n\n    for (int i = 0; i < N; i++)\n        sorted.emplace_back(D[i], i);\n\n    sort(sorted.begin(), sorted.end());\n    vector<int> parent(N, -1);\n    vector<int> subtree_size(N, 1);\n\n    for (int i = N - 1; i >= 0; i--) {\n        int current = sorted[i].second;\n        int goal = sorted[i].first - (N - 2 * subtree_size[current]);\n        int index = lower_bound(sorted.begin(), sorted.end(), make_pair(goal, 0)) - sorted.begin();\n        int who = sorted[index].first == goal ? sorted[index].second : -1;\n\n        if (i > 0 && (index >= i || who < 0)) {\n            cout << -1 << '\\n';\n            return 0;\n        }\n\n        if (who >= 0)\n            subtree_size[who] += subtree_size[current];\n\n        parent[current] = who;\n    }\n\n    for (int i = N - 1; i > 0; i--) {\n        int current = sorted[i].second;\n        cout << current + 1 << ' ' << parent[current] + 1 << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,a) for(int i=start[(a)];i;i=e[i].next)\ninline int read()\n{\n\tint sum=0,p=1;char ch=getchar();\n\twhile(!(('0'<=ch && ch<='9') || ch=='-'))ch=getchar();\n\tif(ch=='-')p=-1,ch=getchar();\n\twhile('0'<=ch && ch<='9')sum=sum*10+ch-48,ch=getchar();\n\treturn sum*p;\n}\n\nconst int maxn=1e5+20;\nconst ll inf=1ll<<60;\n\nint n;\nll D[maxn];\nint p[maxn];\nint sa[maxn],sz[maxn];\n\nmap<ll,int>mp;\n\ninline void init()\n{\n\tn=read();\n\tREP(i,1,n)cin>>D[i],mp[D[i]]=i,sz[i]=1;\n\tD[0]=inf;\n}\n\ninline bool cmp(int a,int b){ return D[a]<D[b];} \n\nstruct node {\n\tint v,next;\n};\nnode e[maxn<<1];\nint cnt,start[maxn];\ninline void addedge(int u,int v){ e[++cnt]=(node){v,start[u]};start[u]=cnt;}\n\nll dist[maxn];\n\nvoid dfs(int u,int fa)\n{\n\tsz[u]=1;\n\tEREP(i,u)\n\t{\n\t\tint v=e[i].v;\n\t\tif(v==fa)continue;\n\t\tdfs(v,u);\n\t\tsz[u]+=sz[v];\n\t\tdist[u]+=dist[v]+sz[v];\n\t\t\n\t}\n}\n\nint l[maxn],r[maxn],tot;\n\ninline void doing()\n{\n\tREP(i,1,n)p[i]=i;\n\tsort(p+1,p+n+1,cmp);\n\tREP(i,1,n)sa[p[i]]=i;\n\tDREP(i,n,2)\n\t{\n\t\tint u=p[i];\n\t\tint x=mp[D[u]-n+2*sz[u]];\n\t\tif(!x)puts(\"-1\"),exit(0);\n\t\tsz[x]+=sz[u];\n\t\t++tot;l[tot]=x;r[tot]=u;//printf(\"%d %d\\n\",x,u);\n\t\taddedge(x,u);\n\t\taddedge(u,x);\n\t}\n\tdfs(1,0);\n\tif(dist[1]!=D[1])puts(\"-1\"),exit(0);\n\tREP(i,1,tot)printf(\"%d %d\\n\",l[i],r[i]);\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define per(i,r,l) for(int i=(r);i>=(l);--i)\nusing namespace std;\ntypedef long long ll;\nconst int maxn=1e5+10;\nint n,sz[maxn],fa[maxn],d[maxn];\nll b[maxn],D;\nvector<int> G[maxn];\nstruct Node{ll x;int id;}a[maxn];\ninline bool operator <(Node x,Node y){return x.x<y.x;}\nvoid dfs(int u,int fa){\n    for(int v:G[u]) if(v!=fa) d[v]=d[u]+1,dfs(v,u);\n}\nint main(){\n    scanf(\"%d\",&n);\n    rep(i,1,n) scanf(\"%lld\",&a[i].x),a[i].id=i,b[i]=a[i].x;\n    sort(a+1,a+n+1);sort(b+1,b+n+1);\n    rep(i,1,n) sz[i]=1;\n    per(i,n,2){\n        int u=a[i].id;\n        if(n%2==0&&sz[u]==n/2) return puts(\"-1\"),0;\n        int x=lower_bound(b+1,b+n+1,a[i].x-(n-2*sz[u]))-b;\n        if(b[x]!=a[i].x-(n-sz[u])+sz[u]) return puts(\"-1\"),0;\n        x=a[x].id;fa[u]=x;sz[x]+=sz[u];\n    }\n    rep(i,1,n) G[i].push_back(fa[i]),G[fa[i]].push_back(i);\n    dfs(a[1].id,0);\n    rep(i,1,n) D+=d[i];if(D!=a[1].x) return puts(\"-1\"),0; \n    rep(i,1,n) if(fa[i]) printf(\"%d %d\\n\",i,fa[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#define N 120000\n#include<map>\nusing namespace std;\nstruct node{\n\tlong long x,id;\n}a[N];\nmap<long long,long long>p;\nlong long n,siz[N],fa[N];\nbool cmp(node x,node y){\n\treturn x.x>y.x;\n}\nint main(){\n\tscanf(\"%lld\",&n);\n\tfor(long long i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i].x);\n\t\ta[i].id=i;\n\t}\n\tsort(a+1,a+1+n,cmp);\n\tfor(long long i=1;i<=n;i++){\n\t\tp[a[i].x]=a[i].id;\n\t}\n\tfor(long long i=1;i<n;i++){\n\t\tlong long x=a[i].id;\n\t\tp[x]=0;\n\t\tsiz[x]++;\n\t\tlong long o=a[i].x+siz[x]-(n-siz[x]);\n\t//\tprlong longf(\"%d %d %d\\n\",a[i].x,o,siz[x]);\n\t\tlong long l=p[o];\n\t\tif(l==0){\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[l]+=siz[x];\n\t\tfa[x]=l;\n\t}\n\tint bns=0;\n\tfor(int i=1;i<=n;i++){\n\t\tbns+=fa[i]==0;\n\t}\n\tif(bns>=2){\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(long long i=1;i<=n;i++){\n\t\tif(fa[i]!=0)printf(\"%lld %lld\\n\",i,fa[i]);\n\t}\n} "
  },
  {
    "language": "C++",
    "code": "/*\n一个点从u移到相邻节点v时，若删掉(u,v)后u这边的连通块大小为sizu，v这边的连通块大小为sizv，那么dv=du−sizv+sizu\n所以考虑按d从大到小（也就是从叶子向上，这样能得到正确的siz）的顺序确定每个点x的父亲：这个点的d必须是dx−(n−sizx)+sizx\n然后判一下根\n*/\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 7;\nint n, v2[N], fa[N], sz[N];\nlong long v[N], ds[N];\nmap<long long, int> tp;\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++)\n    scanf(\"%lld\", &v[i]), tp[v[i]] = v2[i] = i, sz[i] = 1;\n  sort(v2 + 1, v2 + n + 1, [&](int a, int b) {return v[a] < v[b];});\n  for (int i = n; i > 1; i--) {\n    long long tp2 = v[v2[i]] - n + sz[v2[i]] * 2;\n    if (!tp[tp2]) return 0 & puts(\"-1\");\n    int sb = tp[tp2];\n    ds[sb] += ds[v2[i]] + sz[v2[i]];\n    sz[sb] += sz[v2[i]];\n    fa[v2[i]] = sb;\n  }\n  if (ds[v2[1]] != v[v2[1]]) {printf(\"-1\\n\"); return 0;}\n  for (int i = 1; i <= n; i++)if (fa[i])\n      printf(\"%d %d\\n\", i, fa[i]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <map>\n#include <cstdio>\n#define LL long long\n#define pb push_back\n#define mp make_pair\n#define INF 0x3f3f3f3f\n#define Inf 1000000000000000000LL\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int>pii;\nint n;\nmap<int,int>ret;\nvector<pii>e;\nint main(){\n\t\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcin>>n;\n\tfor(int i=0,x;i<n;i++){\n\t\tcin>>x;\n\t\tret[x]=i;\n\t\te.pb(mp(x,i));\n\t}\n\tsort(e.rbegin(),e.rend());\n\tint x=e.back().F;\n\tvector<int>sz(n,1);\n\tvector<int>dp(n,0);\n\tvector<pii>ans;\n\tfor(auto c:e){\n\t\tif(c.F!=x){\n\t\t\tif(sz[c.S]*2>=n)return puts(\"-1\"),0;\n\t\t\tint p=c.F-(n-2*sz[c.S]);\n\t\t\tif(!ret.count(p))return puts(\"-1\"),0;\n\t\t\tint pa=ret[p];\n\t\t\tdp[pa]+=dp[c.S]+sz[c.S];\n\t\t\tsz[pa]+=sz[c.S];\n\t\t\tans.pb(mp(c.S+1,pa+1));\n\t\t}\n\t}\n\tif(dp[e.back().S]!=x)return puts(\"-1\"),0;\n\tfor(auto c:ans)cout<<c.F<<' '<<c.S<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\nconst ll N = 100005;\n\nll n, d[N], cnt[N], rd[N];\nmap<ll,ll> dti, itd;\nvector<ll> adj[N];\nvector<pll> ans;\n\nvoid dfs1 (ll I) {\n\tfor(auto &T : adj[I]) {\n\t\tdfs1(T);\n\t\trd[I] += rd[T] + cnt[T];\n\t}\n}\n\nvoid dfs2 (ll I) {\n\tfor(auto &T : adj[I]) {\n\t\trd[T] = rd[I] - cnt[T] + (n-cnt[T]);\n\t\tdfs2(T);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%lld\",&n);\n\tfor(ll i=1;i<=n;i++) {\n\t\tscanf(\"%lld\",&d[i]);\n\t\tdti[d[i]] = i;\n\t\titd[i] = d[i];\n\t}\n\tsort(d+1, d+1+n);\n\tfor(ll i=n;i>=2;i--) {\n\t\tll I = dti[d[i]];\n\t\tll C = ++cnt[I];\n\t\tll J = dti[d[i] - (n-C) + C];\n\t\tif(J == 0) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tans.push_back({I, J});\n\t\tcnt[J] += cnt[I];\n\t\tadj[J].push_back(I);\n\t}\n\tll R = dti[d[1]];\n\tdfs1(R);\n\tdfs2(R);\n\tfor(ll i=1;i<=n;i++) {\n\t\tif(itd[i] != rd[i]) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(auto &T : ans) {\n\t\tprintf(\"%lld %lld\\n\", T.X, T.Y);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\ntypedef long long ll;\nconst int MaxN=100010;\nint N,V[MaxN],fa[MaxN],siz[MaxN];\nll D[MaxN];\nbool cmp(int i,int j){return D[i]<D[j];}\nint main(){\n\tscanf(\"%d\",&N);\n\tfor(int i=1;i<=N;i++)scanf(\"%lld\",D+i),V[i-1]=i;\n\tstd::sort(V,V+N,cmp);\n\tll D0=0;\n\tfor(int*i=V+N;--i>V;){\n\t\tD0+=siz[*i]++;\n\t\tD[*i]-=N-2*siz[*i];\n\t\tint*j=std::lower_bound(V,i,*i,cmp);\n\t\tif(j<i&&D[*j]==D[*i])siz[fa[*i]=*j]+=siz[*i];\n\t\telse return puts(\"-1\"),0;\n\t}\n\tif(D0+N-1!=D[*V])return puts(\"-1\"),0;\n\tfor(int*i=V+N;--i>V;)printf(\"%d %d\\n\",*i,fa[*i]); \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define ull unsigned ll\n#define db double\n#define pint pair<int,int>\n#define mk make_pair\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define fi first\n#define se second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=1e5+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline ll read(){\n\tll x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nmap<ll,int>pos;vector<int>G[MAXN];\nint n,id[MAXN],sz[MAXN],fa[MAXN];ll d[MAXN],tmp;\nvoid dfs(int x,int d){tmp+=d;for(auto y:G[x])dfs(y,d+1);}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read();\n\tRep(i,1,n)pos[d[i]=read()]=i,id[i]=i;\n\tsort(id+1,id+n+1,[](int x,int y){return d[x]>d[y];});\n\tRep(i,1,n)sz[i]=1;\n\tRep(i,1,n-1){\n\t\tint x=id[i];ll t=d[x]+2*sz[x]-n;\n\t\tif(pos.count(t))fa[x]=pos[t],sz[fa[x]]+=sz[x];\n\t\telse return puts(\"-1\"),0;\n\t}\n\tRep(i,1,n)if(fa[i])G[fa[i]].pb(i);\n\tdfs(id[n],0);if(tmp!=d[id[n]])return puts(\"-1\"),0;\n\tRep(i,1,n)if(fa[i])cout<<i<<' '<<fa[i]<<'\\n';\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define re register\n#define gc getchar\n#define pc putchar\n#define cs const\n\ninline\nll getint(){\n\tre ll num;\n\tre char c;\n\twhile(!isdigit(c=gc()));num=c^48;\n\twhile(isdigit(c=gc()))num=(num<<1)+(num<<3)+(c^48);\n\treturn num;\n}\n\ninline\nvoid outint(int a){\n\tstatic char ch[13];\n\tif(a==0)pc('0');\n\twhile(a)ch[++ch[0]]=a-a/10*10,a/=10;\n\twhile(ch[0])pc(ch[ch[0]--]^48);\n}\n\ncs int N=100005;\n\nint last[N],nxt[N],to[N],ecnt;\ninline\nvoid addedge(int u,int v){\n\tnxt[++ecnt]=last[u],last[u]=ecnt,to[ecnt]=v;\n}\n\nmap<ll,int> id;\nint n;\nll d[N];\nint siz[N];\n\nint dist[N];\ninline\nvoid dfs(int u){\n\tfor(int re e=last[u],v=to[e];e;v=to[e=nxt[e]]){\n\t\tdist[v]=dist[u]+1;\n\t\tdfs(v);\n\t}\n}\n\nvector<pair<int,int> > edge;\n\nsigned main(){\n\tn=getint();\n\tfor(int re i=1;i<=n;++i)d[i]=getint(),id[d[i]]=i;\n\t\n\tsort(d+1,d+n+1);\n\tfor(int re i=1;i<=n;++i)siz[i]=1;\n\t\n\tfor(int re i=n;i>1;--i){\n\t\tint u=id[d[i]];\n\t\tint tmp=n-2*siz[u];\n\t\tif(tmp<=0)return puts(\"-1\"),0; \n\t\tll t=d[i]-tmp;\n\t\tif(id.count(t)==0)return puts(\"-1\"),0;\n\t\tint pos=id[t];\n\t\taddedge(pos,u);\n\t\tsiz[pos]+=siz[u];\n\t\tedge.push_back(make_pair(pos,u));\n\t}\n\tll sum=0;\n\tdfs(id[d[1]]);\n\tfor(int re i=1;i<=n;++i){\n\t\tsum+=dist[i];\n\t}\n\tif(sum!=d[1])return puts(\"-1\"),0;\n\tfor(int re i=0;i<edge.size();++i)outint(edge[i].first),pc(' '),outint(edge[i].second),pc('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 2e5 + 10;\n\nint N, rnk[MAX_N], siz[MAX_N], pa[MAX_N], depth[MAX_N];\nll D[MAX_N];\nmap<ll, int> mp;\n\nint main() {\n    scanf(\"%d\", &N);\n    for (int i = 1; i <= N; i++) scanf(\"%lld\", &D[i]), mp[D[i]] = i;\n    for (int i = 1; i <= N; i++) rnk[i] = i, siz[i] = 1;\n    sort(rnk + 1, rnk + N + 1, [](int a, int b) { return D[a] > D[b]; });\n    for (int i = 1; i < N; i++) {\n        int x = rnk[i];\n        ll pd = D[x] + 2 * siz[x] - N;\n        if (siz[x] * 2 < N && mp.count(pd)) {\n            pa[x] = mp[pd];\n            siz[pa[x]] += siz[x];\n        } else {\n            printf(\"-1\\n\");\n            return 0;\n        }\n    }\n    ll sum = 0;\n    for (int i = N - 1; i; i--) {\n        int x = rnk[i];\n        depth[x] = depth[pa[x]] + 1;\n        sum += depth[x];\n    }\n    if (sum != D[rnk[N]]) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n    for (int i = 1; i < N; i++) {\n        int x = rnk[i];\n        printf(\"%d %d\\n\", x, pa[x]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXn = 1e5 + 10;\ntypedef pair<long long, int> pii;\npii ar[MAXn];\nlong long n, sz[MAXn], root, disroot, d[MAXn], hp3[MAXn];\nvector<int> vec[MAXn];\nvector<pii> ans;\n\nbool cmp(pii p1, pii p2) {\n\treturn p1.first > p2.first;\n}\n\nlong long dfs1(int v, int  par) {\n\tlong long res = 0;\n\tfor (int i = 0; i < vec[v].size(); i++)\n\t\tif (vec[v][i] != par) {\n\t\t\tres += dfs1(vec[v][i], v) + hp3[vec[v][i]];\n\t\t\thp3[v] += hp3[vec[v][i]];\n\t\t}\n\thp3[v]++;\n\treturn res;\n\t\n}\n\nvoid dfs2(int v, int par, long long sth) {\n\tif (sth != d[v]) {\n\t\tcout << -1;\n\t\texit(0);\n\t}\n\tfor (int i = 0; i < vec[v].size(); i++) {\n\t\tif (vec[v][i] != par) {\n\t\t\tdfs2(vec[v][i], v, sth - (hp3[vec[v][i]]) + (hp3[0] - hp3[vec[v][i]]));\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}\nint main() {\n\tcin >> n;\n\tfill_n(sz, MAXn, 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tint di;\n\t\tcin >> di;\n\t\td[i] = di;\n\t\tar[i].first = di;\n\t\tar[i].second = i;\n\t}\n\tsort(ar, ar + n);\n\tfor (int i = n - 1; i > 0; i--) {\n\t\tlong long hp = ar[i].first - n;\n\t\thp += 2LL * sz[i];\n\t\tint hp2 = lower_bound(ar, ar + n, pii(hp, -1)) - ar;\n\t\tif (ar[hp2].first != hp)\n\t\t\treturn cout << -1,0;\n\t\tsz[hp2]+= sz[i];\n\t\tvec[ar[hp2].second].push_back(ar[i].second);\n\t\tvec[ar[i].second].push_back(ar[hp2].second);\n\t\tans.push_back(pii(ar[i].second, ar[hp2].second));\n\t}\n\tdisroot = dfs1(ar[0].second, -1);\n\tdfs2(ar[0].second, -1, disroot);\n\tfor (int i = 0; i < ans.size(); i++)\n\t\tcout << ans[i].first + 1<< ' ' << ans[i].second + 1<< endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\n#define MOD 1000000007\n#define rep(i,m,n) for(int (i)=(int)(m);i<(int)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ll long long\n#define ull unsigned long long\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconst long long INF = 1LL << 60;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\n\n\n//priority_queue<ll> max;//大きい順\n//priority_queue<ll, Array, greater<ll>> min;//小さい順\n\n/*firstについては昇順 secondについては降順\nsort(all(wh), [&](P x, P y) {\n\tif (x.first == y.first)return x.second > y.second;\n\treturn x.first < y.first;\n});\n*/\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n//substr　文字列取り出し\n//upper_bound ある値より大きい一番左のイテレータを返す、lowerは以上(setに対して使うとO(N)なので、setのメンバ関数を使う\n//stoi\n\n\nstruct Edge {//グラフ\n\tll to, cap, rev;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, ll from, ll to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\nll max_flow_dfs(Graph & G, ll v, ll t, ll f, vector<bool> & used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph & G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nvoid BellmanFord(Graph& G, ll s, Array& d, Array &negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 2) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 2) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\td[i][G[i][j].to] = G[i][j].cap;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, vector<int>& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tlca() {}\n\n\tlca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unionSet(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tint numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\nclass SumSegTree {\nprivate:\n\n\tint _sum(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return 0;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tint s1 = _sum(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tint s2 = _sum(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn s1 + s2;\n\t\t}\n\t}\npublic:\n\tint n, height;\n\tvector<int> dat;\n\n\t// 初期化（_nは最大要素数）\n\tSumSegTree(int _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<int>(2 * n - 1, 0);\n\t}\n\n\t// 場所i(0-indexed)にxを足す\n\tvoid add(int i, int x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] += x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] += x;\n\t\t}\n\t}\n\n\t// 区間[a,b)の総和。ノードk=[l,r)に着目している。\n\tint sum(int a, int b) {\n\t\treturn _sum(a, b, 0, 0, n);\n\t}\n};\nclass RmqTree {\nprivate:\n\n\tll _find(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return INF;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _find(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _find(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn min(s1, s2);\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tRmqTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1, INF);\n\t}\n\n\t// 場所i(0-indexed)をxにする\n\tvoid update(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] = x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\n\t// 区間[a,b)の最小値。ノードk=[l,r)に着目している。\n\tll find(ll a, ll b) {\n\t\treturn _find(a, b, 0, 0, n);\n\t}\n};\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\n}\n\nvector<ll> lis_fast(const vector<ll>& a) {//最長部分増加列\n\tconst ll n = a.size();\n\tvector<ll> A(n, INT_MAX);\n\tvector<ll> id(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tid[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n\t\tA[id[i]] = a[i];\n\t}\n\tll m = *max_element(id.begin(), id.end());\n\tvector<ll> b(m + 1);\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tif (id[i] == m) b[m--] = a[i];\n\treturn b;\n}\n\n\nll ModPow(ll x, ll n) {\n\tll res = 1LL;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % MOD;\n\t\tx = x * x % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//nCrとか\nclass Combination {\npublic:\n\tArray fact;\n\tArray inv;\n\tll mod;\n\tll mod_inv(ll x) {\n\t\tll n = mod - 2LL;\n\t\tll res = 1LL;\n\t\twhile (n > 0) {\n\t\t\tif (n & 1) res = res * x % mod;\n\t\t\tx = x * x % mod;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tll nCr(ll n, ll r) {\n\t\treturn ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll n, ll _mod) {\n\t\tmod = _mod;\n\t\tfact.resize(n + 1);\n\t\tfact[0] = 1;\n\t\tREP(i, n) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tinv.resize(n + 1);\n\t\tREP(i, n + 1) {\n\t\t\tinv[i] = mod_inv(fact[i]);\n\t\t}\n\t}\n};\n\nll gcd(ll m, ll n) {\n\tif (n == 0)return m;\n\treturn gcd(n, m % n);\n}//gcd\n\nll lcm(ll m, ll n) {\n\treturn m / gcd(m, n) * n;\n}\n\n\nMatrix mIdentity(ll n) {\n\tMatrix A(n, Array(n));\n\tfor (int i = 0; i < n; ++i) A[i][i] = 1;\n\treturn A;\n}\n\nMatrix mMul(const Matrix& A, const Matrix& B) {\n\tMatrix C(A.size(), Array(B[0].size()));\n\tfor (int i = 0; i < C.size(); ++i)\n\t\tfor (int j = 0; j < C[i].size(); ++j)\n\t\t\tfor (int k = 0; k < A[i].size(); ++k)\n\t\t\t\t(C[i][j] += (A[i][k] % MOD) * (B[k][j] % MOD)) %= MOD;\n\treturn C;\n}\n// O( n^3 log e )\nMatrix mPow(const Matrix & A, ll e) {\n\treturn e == 0 ? mIdentity(A.size()) :\n\t\te % 2 == 0 ? mPow(mMul(A, A), e / 2) : mMul(A, mPow(A, e - 1));\n}\n\ntemplate <class T>class RectangleSum {\npublic:\n\tvector<vector<T>> sum;\n\tT GetSum(int left, int right, int top, int bottom) { //[left, right], [top, bottom]\n\t\tT res = sum[bottom][right];\n\t\tif (left > 0) res -= sum[bottom][left - 1];\n\t\tif (top > 0) res -= sum[top - 1][right];\n\t\tif (left > 0 && top > 0) res += sum[top - 1][left - 1];\n\t\treturn res;\n\t}\n\tRectangleSum(const vector<vector<T>> &s, int h, int w) {\n\t\tsum.resize(h);\n\t\tfor (int i = 0; i < h; i++) sum[i].resize(w, 0);\n\t\tfor (int y = 0; y < h; y++) {\n\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\tsum[y][x] = s[y][x];\n\t\t\t\tif (y > 0) sum[y][x] += sum[y - 1][x];\n\t\t\t\tif (x > 0) sum[y][x] += sum[y][x - 1];\n\t\t\t\tif (y > 0 && x > 0) sum[y][x] -= sum[y - 1][x - 1];\n\t\t\t}\n\t\t}\n\t}\n};\n\nll used[100010];\nll dfs(Graph &graph, ll v, ll deep) {\n\tused[v] = 1;\n\tll total = deep;\n\tREP(i, graph[v].size()) {\n\t\tif (used[graph[v][i].to] == 0) {\n\t\t\ttotal += dfs(graph, graph[v][i].to, deep + 1);\n\t\t}\n\t}\n\treturn total;\n\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t\n\tll n;\n\tcin >> n;\n\tmap<ll, ll> d;\n\tREP(i, n) {\n\t\tll temp;\n\t\tcin >> temp;\n\t\td[-temp] = i+1;\n\t}\n\tGraph graph(n);\n\tArray cost(n, 1);\n\tvector<P> ans;\n\tfor (auto itr : d) {\n\t\tll sum = -itr.first;\n\t\tll num = itr.second - 1;\n\t\tll next = sum - n + 2*cost[num];\n\t\tif (cost[num] == n) {\n\t\t\tll verify = dfs(graph, num, 0);\n\t\t\tif (verify == sum) {\n\t\t\t\tREP(i, n - 1) {\n\t\t\t\t\tcout << ans[i].first << ' ' << ans[i].second << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << -1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (d.count(-next) != 0&&num!=d[-next]-1) {\n\t\t\tcost[d[-next] - 1] += cost[num];\n\t\t\tadd_edge(graph, num, d[-next] - 1, 1, true, 1);\n\t\t\tans.push_back(make_pair(num + 1, d[-next]));\n\t\t}\n\t\telse {\n\t\t\tcout << -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define N_ 101000\nusing namespace std;\nint n, C[N_];\nvector<int>E[N_];\nstruct point {\n\tlong long x;\n\tint num;\n\tbool operator<(const point &p)const {\n\t\treturn x != p.x ? x < p.x : num < p.num;\n\t}\n}w[N_];\nlong long sum;\nvoid DFS(int a, int d) {\n\tsum += d;\n\tfor (auto &x : E[a])DFS(x, d + 1);\n}\nint main() {\n\tint i;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%lld\", &w[i].x);\n\t\tw[i].num = i, C[i] = 1;\n\t}\n\tsort(w + 1, w + n + 1);\n\tfor (i = n; i > 1; i--) {\n\t\tint t = w[i].num;\n\t\tlong long nx = w[i].x - n + C[t] * 2;\n\t\tpoint tp = { nx,-1 };\n\t\tint j =  lower_bound(w + 1, w + n + 1, tp) - w; \n\t\tif (nx >= w[i].x || j<1 || j>n || w[j].x != nx) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tC[w[j].num] += C[t];\n\t\tE[w[j].num].push_back(t);\n\t}\n\tDFS(w[1].num, 0);\n\tif (sum != w[1].x)puts(\"-1\");\n\telse {\n\t\tfor (i = 1; i <= n; i++)for (auto &x : E[i])printf(\"%d %d\\n\", i, x);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<ctime>\n#include<cmath>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<string>\n#include<vector>\n#include<bitset>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define rep(i,s,t) for(register int i=s;i<=t;++i)\n#define _rep(i,s,t) for(register int i=s;i>=t;--i)\n#define Rep(i,s,t) for(register int i=s;i<t;++i)\n#define go(x) for(register int e=las[x];e;e=nxt[e])\n#define re register\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define ub upper_bound\n#define lb lower_bound\n#define pii pair<int,int>\n#define ms(f,x) memset(f,x,sizeof f)\n#define mc(f,x) memcpy(f,x,sizeof f)\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\n#define gi(x) read(x)\n#define gii(x,y) read(x),read(y)\n#define giii(x,y,z) read(x),read(y),read(z)\nnamespace IO{\n    #define gc getchar()\n    #define pc(x) putchar(x)\n    template<typename T>inline void read(T &x){\n        x=0;int f=1;char ch=gc;while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=gc;}\n        while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=gc;x*=f;return;\n    }\n    template<typename T>inline void write(T x=0){\n        T wr[51];wr[0]=0;if(x<0)pc('-'),x=-x;if(!x)pc(48);\n        while(x)wr[++wr[0]]=x%10,x/=10;while(wr[0])pc(48+wr[wr[0]--]);return;\n    }\n}\nusing IO::read;\nusing IO::write;\ntypedef long long ll;\ntypedef double db;\ntypedef long double ld;\ntypedef unsigned long long ull;\nusing namespace std;\nconst int N=2e5+11;\nint n,ans;\nint sz[N],x[N],y[N];\nll a[N],sum[N];\nstruct node{\n\tll d;\n\tint id;\n\tinline void in(){\n\t\tgi(d);\n\t}\n\tinline bool operator<(node A)const{\n\t\treturn d<A.d;\n\t}\n}p[N];\nint main(){\n\tgi(n);\n\trep(i,1,n)\n\t\tsz[i]=1,sum[i]=0;\n\trep(i,1,n)\n\t\tp[i].in(),p[i].id=i;\n\tsort(p+1,p+n+1);\n\trep(i,1,n)\n\t\ta[i]=p[i].d;\n\t_rep(i,n,2){\n\t\tint pos=lower_bound(a+1,a+n+1,p[i].d-n+2*sz[p[i].id])-a;\n\t\tif(a[pos]!=p[i].d-n+2*sz[p[i].id]||p[i].id==p[pos].id){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsz[p[pos].id]+=sz[p[i].id];\n\t\tsum[p[pos].id]+=sum[p[i].id]+sz[p[i].id];\n\t\tx[++ans]=p[pos].id,y[ans]=p[i].id;\n\t}\n\tif(sum[p[1].id]!=a[1]){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\trep(i,1,ans)\n\t\tprintf(\"%d %d\\n\",x[i],y[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <atcoder/all>\nusing namespace std;\n//using namespace atcoder;\n#define ll long long\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, n+1)\n#define rrep(i, n) for (int i = ((int)(n)-1); i >= 0; --i)\n#define whole(x) (x).begin(),(x).end()\n#define rwhole(x) (x).rbegin(), (x).rend()\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define P pair<ll, ll>\n#define debug(var) cerr << \"[\" << #var << \"] \" << var << '\\n'\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\n#define vi vector<int>\n#define vl vector<ll>\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define pr(s) cout << (s) << '\\n'\nconst ll mod = 1000000007;\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\nconst int INF = 1001001001;\nconst ll INFll = 1E+18;\nconst int MAXN = 100005;\n\nll par[MAXN];\nll child[MAXN];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n  pr(-1);\n  return 0;\n    \n    ll n;\n    cin >> n;\n    vector<P> d(n);\n    rep(i, n) {\n        cin >> d[i].fi;\n        d[i].se = i;\n    }\n    sort(whole(d));\n\n    rrep(i, n) {\n        if (i==0) continue;\n        ll x = d[i].fi - n+2 + child[i]*2;\n        if (x==d[i].fi) {\n            pr(-1);\n            return 0;\n        }\n        //debug(d[i].fi);\n        //debug(x);\n        auto it = lower_bound(whole(d), P(x, 0));\n        if (it==d.end() || it->fi!=x) {\n            pr(-1);\n            return 0;\n        }\n        par[i] = it-d.begin();\n        child[par[i]] += child[i]+1; \n    }\n\n    rep(i, n) {\n        if (i==0) continue;\n        ll u = d[i].se + 1;\n        ll v = d[par[i]].se + 1;\n        cout << u << \" \" << v << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n, sz[100007], fa[100007];\npair<int, int>p[100007];\nvector<int>e[100007];\nint read()\n{\n\tint num = 0;\n\tchar c = getchar();\n\twhile (c<'0' || c>'9')c = getchar();\n\twhile (c >= '0' && c <= '9')num = num * 10 + c - '0', c = getchar();\n\treturn num;\n}\nint dfs(int w, int f)\n{\n\tint res = 0;\n\tfor (int i = 0, lim = e[w].size(); i < lim; i++)\n\t\tres += dfs(e[w][i], w) + sz[e[w][i]];\n\treturn res;\n}\nsigned main()\n{\n\tn = read();\n\tfor (int i = 1; i <= n; i++)\n\t\tp[i] = make_pair(read(), i);\n\tsort(p + 1, p + n + 1);\n\tfor (int i = n; i > 1; i--)\n\t{\n\t\tint x = p[i].second;\n\t\tsz[x]++;\n\t\tint pos = lower_bound(p + 1, p + n + 1, make_pair(p[i].first + 2 * sz[x] - n, 0LL)) - p;\n\t\tif (pos >= i || p[i].first + 2 * sz[x] - n != p[pos].first) { cout << -1 << endl; return 0; }\n\t\tfa[x] = p[pos].second;\n\t\tsz[fa[x]] += sz[x];\n\t\te[fa[x]].push_back(x);\n\t}\n\tsz[p[1].second]++;\n\tif(dfs(p[1].second,0)!=p[1].first) { cout << -1 << endl; return 0; }\n\tfor (int i = 1; i <= n; i++)\n\t\tif (fa[i])printf(\"%lld %lld\\n\", fa[i], i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define re register\n#define ll long long\ninline int gi()\n{\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=500010;\ntypedef pair<ll,int> pli;typedef pair<int,int> pii;\n#define mp make_pair\npli p[N];int n,siz[N];\nvector<pii>ans;\nint main()\n{\n\tn=gi();\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&p[i].first),p[i].second=i,siz[i]=1;\n\tsort(p+1,p+n+1);ll dis=0;\n\tfor(int i=n;i>1;i--)\n\t{\n\t\tll nd=p[i].first-(n-siz[p[i].second])+siz[p[i].second];\n\t\tpli it=p[lower_bound(p+1,p+n+1,mp(nd,0))-p];\n\t\tif(it.first!=nd)return puts(\"-1\")&1;\n\t\tans.push_back(mp(it.second,p[i].second));\n\t\tsiz[it.second]+=siz[p[i].second];dis+=siz[p[i].second];\n\t\t}\n\tif(dis!=p[1].first)return puts(\"-1\")&1;\n\tfor(int i=0;i<n-1;i++)printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define per(i,r,l) for(int i=(r);i>=(l);--i)\nusing namespace std;\ntypedef long long ll;\nconst int maxn=1e5+10;\nint n,sz[maxn],fa[maxn];\nll b[maxn];\nstruct Node{ll x;int id;}a[maxn];\ninline bool operator <(Node x,Node y){return x.x<y.x;}\nint main(){\n    scanf(\"%d\",&n);\n    rep(i,1,n) scanf(\"%lld\",&a[i].x),a[i].id=i,b[i]=a[i].x;\n    sort(a+1,a+n+1);sort(b+1,b+n+1);\n    rep(i,1,n) sz[i]=1;\n    per(i,n,2){\n        int u=a[i].id;\n        if(n%2==0&&sz[u]==n/2) return puts(\"-1\");\n        int x=lower_bound(b+1,b+n+1,a[i].x-(n-sz[u])+sz[u])-b;\n        if(b[x]!=a[i].x-(n-sz[u])+sz[u]) return puts(\"-1\");\n        x=a[x].id;fa[u]=x;sz[x]+=sz[u];\n    }\n    rep(i,1,n) if(fa[i]) printf(\"%d %d\\n\",i,fa[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint n,sz[1000000],par[1000000];\nlong long d[1000000],chdst[1000000];\npair<long long,int>id[1000000];\n\nbool solve()\n{\n\tfor(int i=0;i<n;i++)\n\t\tid[i]=make_pair(d[i],i);\n\tsort(id,id+n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tsz[i]=1,par[i]=-2;\n\t\tchdst[i]=0;\n\t}\n\tfor(int i=n-1;i >= 1;--i)\n\t{\n\t\tint at=id[i].second;\n\t\tlong long want=d[at]-n+2 * sz[at];\n\t\tint idx=lower_bound(id,id+n,make_pair(want,-1))-id;\n\t\tif(idx >= i || id[idx].first!=want)\n\t\t\treturn false;\n\t\tpar[at]=id[idx].second;\n\t\tsz[par[at]] += sz[at];\n\t\tchdst[par[at]] += chdst[at]+sz[at];\n\t}\n\tint root=id[0].second;\n\tpar[root]=-1;\n\treturn chdst[root]==d[root];\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)\n\t\tscanf(\"%lld\",&d[i]);\n\tif(!solve())\n\t{\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tif(par[i]!=-1)\n\t\t\tprintf(\"%d %d\\n\",i+1,par[i]+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int \n#define F first\n#define S second\n#define pb push_back\nconst ll N = 1e5 + 5, MOD =  1e9 + 7, INF = 1e9 + 10;\nconst long double PI = acos(-1);\nint n, sz[N], h[N];\npair <ll, int> d[N];\nvector <int> adj[N];\nunordered_map <ll, int> mp;\nvoid dfs(int v){\n\tfor (int u : adj[v]){\n\t\th[u] = h[v] + 1;\n\t\tdfs(u);\n\t}\n\treturn;\n}\nbool ok(){\n\tdfs(d[n].S);\n\tll all = 0;\n\tfor (int i = 1; i <= n; i++){\n\t\tall += h[i];\n\t}\n\treturn (all == d[n].F);\n}\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++){\n\t\tcin >> d[i].F;\n\t\td[i].S = i;\n\t\tmp[d[i].F] = i;\n\t}\n\tsort(d + 1, d + n + 1);\n\treverse(d + 1, d + n + 1);\n\tfor (int i = 1; i <= n; i++){\n\t\tint u = d[i].S;\n\t\tsz[u] = 1;\n\t\tfor (int v : adj[u]){\n\t\t\tsz[u] += sz[v];\n\t\t}\n\t\tll x = d[i].F + 2 * sz[u] - n;\n\t\tif (mp.find(x) == mp.end()) break;\n\t\tadj[mp[x]].pb(u);\n\t}\n\tif (ok()){\n\t\tfor (int u = 1; u <= n; u++){\n\t\t\tfor (int v : adj[u]){\n\t\t\t\tcout << u << ' ' << v << '\\n';\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tcout << \"-1\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#define N 120000\n#include<map>\nusing namespace std;\nstruct node{\n\tlong long x,id;\n}a[N];\nmap<long long,long long>p;\nlong long n,siz[N],fa[N];\nbool cmp(node x,node y){\n\treturn x.x>y.x;\n}\nint main(){\n\tscanf(\"%lld\",&n);\n\tfor(long long i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i].x);\n\t\ta[i].id=i;\n\t}\n\tsort(a+1,a+1+n,cmp);\n\tfor(long long i=1;i<=n;i++){\n\t\tp[a[i].x]=a[i].id;\n\t}\n\tfor(long long i=1;i<n;i++){\n\t\tlong long x=a[i].id;\n\t//\tp[a[i].x]=0;\n\t\tsiz[x]++;\n\t\tlong long o=a[i].x+siz[x]-(n-siz[x]);\n\t//\tprlong longf(\"%d %d %d\\n\",a[i].x,o,siz[x]);\n\t\tlong long l=p[o];\n\t\tif(l==0){\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[l]+=siz[x];\n\t\tfa[x]=l;\n\t}\n\tfor(long long i=1;i<=n;i++){\n\t\tif(fa[i]!=0)printf(\"%lld %lld\\n\",i,fa[i]);\n\t}\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace TYC\n{\n\ttypedef long long ll;\n\tconst int N = 1e5 + 5;\n\n\tint Siz[N], Id[N];\n\tll D[N];\n\tunordered_map<ll, int> M;\n\tvector<int> E[N];\n\n\ttemplate <typename T>\n\tinline T read()\n\t{\n\t\tT x = 0;\n\t\tint f = 0, ch = getchar();\n\t\twhile (!isdigit(ch))\n\t\t\tf |= (ch == '-'), ch = getchar();\n\t\twhile (isdigit(ch))\n\t\t\tx = x * 10 + ch - '0', ch = getchar();\n\t\treturn f ? -x : x;\n\t}\n\n\tll dfs(const int u, const int d)\n\t{\n\t\tll ans = d;\n\t\tfor (int v : E[u])\n\t\t\tans += dfs(v, d + 1);\n\t\treturn ans;\n\t}\n\n\tvoid work()\n\t{\n\t\tint n = read<int>();\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tll d = D[i] = read<ll>();\n\t\t\tId[i] = i;\n\t\t\tM[d] = i;\n\t\t\tSiz[i] = 1;\n\t\t}\n\t\tsort(Id + 1, Id + 1 + n, [](const int a, const int b) { return D[a] < D[b]; });\n\t\tfor (int i = n; i > 1; i--)\n\t\t{\n\t\t\tint v = Id[i];\n\t\t\tll d = D[v] + 2 * Siz[v] - n;\n\t\t\tif (d >= D[v] || !M.count(d))\n\t\t\t\treturn void(puts(\"-1\"));\n\t\t\tint u = M[d];\n\t\t\tSiz[u] += Siz[v];\n\t\t\tE[u].push_back(v);\n\t\t}\n\t\tif (dfs(Id[1], 0) != D[Id[1]])\n\t\t\tputs(\"-1\");\n\t\telse\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tfor (int j : E[i])\n\t\t\t\t\tprintf(\"%d %d\\n\", i, j);\n\t}\n}\n\nint main()\n{\n\tTYC::work();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN=3e5+7;\n\nll from[MAXN],to[MAXN];\n\nmap<ll,ll> Map;\n\nll n;\nll a[MAXN],b[MAXN],siz[MAXN];\n\nbool cmp(const ll &A,const ll &B){return a[A]>a[B];}\nbool cmp2(const ll &A,const ll &B){return A>B;}\n\nint main() {\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) {\n\t\tcin>>a[i];\n\t\tb[i]=i;\n\t\tMap[a[i]]=i;\n\t\tsiz[i]=1;\n\t}\n\tsort(b+1,b+1+n,cmp);\n\tsort(a+1,a+1+n,cmp2);\n\tfor(ll i=1,i2;i<n;i++) {\n\t\ti2=Map[a[i]-(n-2*siz[b[i]])];\n\t\tif(i2!=0&&a[i]-abs(n-2*siz[b[i]])!=a[i]) {\n\t\t\tsiz[i2]+=siz[b[i]];\n\t\t\tfrom[i]=i2;\n\t\t\tto[i]=b[i];\n\t\t}\n\t\telse {\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++) {\n\t\tcout<<from[i]<<\" \"<<to[i]<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nconst double PI = 3.14159265358979323846;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint N;\nint D[110000], n[110000];\nunordered_map<int, int> mp;\nvint ans;\nsigned main() {\n    cin >> N;\n    for (int i = 1; i <= N; i++) {cin >> D[i]; n[i] = 1; mp[D[i]] = i;};\n    sort(D + 1, D + N + 1); reverse(D + 1, D + N + 1);\n    for (int i = 1; i <= N - 1; i++) {\n        int s = mp[D[i]];\n        int t = mp[D[i] - N + 2 * n[s]];\n        if (s == t || t == 0) {\n            cout << -1 << endl;\n            return 0;\n        }\n        n[t] += n[s];\n        ans.push_back(s); ans.push_back(t);\n    }\n    if (n[mp[D[N - 1]]] != N) {\n        cout << -1 << endl;\n        return 0;\n    }\n    for (int i = 0; i < 2 * (N - 1); i += 2) {\n        cout << ans[i] << \" \" << ans[i + 1] << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define MAXN 100010\nusing namespace std;\nLL sz[MAXN],ans1[MAXN],ans2[MAXN];\nmap<LL,LL> mp;\n/*struct node\n{\n\tLL k1,k2;\n\tbool operator <(const node &aa)\n\t{\n\t\treturn k1>aa.k1;\n\t}\n};\nset<node> S;*/\nstruct node\n{\n\tLL k1,k2;\n}D[MAXN];\nbool cmp(node aa,node bb)\n{\n\treturn aa.k1>bb.k1;\n}\nint main()\n{\n\tLL N,i,lans,fa,dfa;\n\tscanf(\"%lld\",&N);\n\tfor(i=1;i<=N;i++){scanf(\"%lld\",&D[i].k1);mp[D[i].k1]=i;D[i].k2=i;}\n\tsort(D+1,D+N+1,cmp);\n\tmemset(sz,0,sizeof(sz));\n\tlans=0;\n\tfor(i=1;i<N;i++)\n\t{\n\t\tsz[D[i].k2]++;\n\t\tdfa=D[i].k1+sz[D[i].k2]-(N-sz[D[i].k2]);\n\t\tif(dfa>=D[i].k1){printf(\"-1\");return 0;}\n\t\tfa=mp[dfa];if(fa==0){printf(\"-1\");return 0;}\n\t\tsz[fa]+=sz[D[i].k2];\n\t\tans1[++lans]=D[i].k2;ans2[lans]=fa;\n\t}\n\tfor(i=1;i<=lans;i++)printf(\"%lld %lld\\n\",ans1[i],ans2[i]);\n\t/*memset(sz,0,sizeof(sz));\n\twhile(1)\n\t{\n\t\tnode MX=*(S.begin());\n\t\tsz[MX.k2]=1;\n\t\twhile(1)\n\t\t{\n\t\t\t\n\t\t}\n\t\tif(tot==N-1)break;\n\t}*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(ll i = (a); i < (ll)(b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\nusing ld = long double;\nusing ll = long long int;\n\nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ll MOD = 1000000007;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> void UNIQUE(vector<T> &a){ a.erase(unique(a.begin(), a.end()), a.end()); }\n\ntemplate<class S, class T> ostream& operator << (ostream& os, const pair<S, T> v){\n  os << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<T> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<vector<T>> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\n\nll in(){long long int x; assert(scanf(\"%lld\", &x) == 1); return x;}\nld fin(){double x; assert(scanf(\"%lf\", &x) == 1); return x;}\nchar yuyushiki[1000010]; string stin(){assert(scanf(\"%s\", yuyushiki) == 1); return yuyushiki;}\n\n// head\n\nusing pl = pair<ll, ll>;\nvector<ll> G[100010];\n\nint main(){\n\n  ll n = in();\n  vector<ll> a(n);\n  REP(i, n){\n    a[i] = in();\n  }\n  vector<ll> s(n, 1);\n  vector<pl> q(0);\n  REP(i, n){\n    q.pb(a[i], i);\n  }\n  sort(q.begin(), q.end());\n  reverse(q.begin(), q.end());\n  map<ll, vector<pl>> call;\n  YYS(w, q){\n    ll i = w.se;\n    if(call.find(a[i]) != call.end()){\n      YYS(c, call[a[i]]){\n        // cout << \"M \" << i << \" \" << c.fi << endl;\n        G[i].pb(c.fi);\n        s[i] += c.se;\n      }\n    }\n    ll target = a[i] + s[i] - (n - s[i]);\n    // cout << \"T \" << i << \" \" << target << endl;\n    if(call.find(target) == call.end()){\n      call[target] = vector<pl>(0);\n    }\n    call[target].pb(i, s[i]);\n  }\n\n  bool ok = false;\n  REP(i, n){\n    if(s[i] == n){\n      ok = true;\n    }\n  }\n  \n  if(ok){\n    ll cnt = 0;\n    REP(i, n){\n      YYS(w, G[i]){\n        cnt++;\n        printf(\"%lld %lld\\n\", i+1, w+1);\n      }\n    }\n    assert(cnt == n-1);\n  } else {\n    puts(\"-1\");\n    assert(false);\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define show(x) std::cerr << #x << \" = \" << x << std::endl\nusing ll = long long;\nint main()\n{\n    int N;\n    std::cin >> N;\n    std::map<ll, int> mp, mp2;\n    std::vector<ll> D(N);\n    for (int i = 0; i < N; i++) { std::cin >> D[i], mp[D[i]] = i; }\n    std::sort(D.begin(), D.end(), std::greater<ll>{});\n    for (int i = 0; i < N; i++) { mp2[D[i]] = i; }\n    std::vector<std::vector<int>> edge(N);\n    std::vector<int> sub(N, 1);\n    for (int i = 0; i < N - 1; i++) {\n        const ll obj = D[i] - (N - 2 * sub[i]);\n        if (obj == D[i] or mp2.find(obj) == mp2.end()) { return std::cout << -1 << std::endl, 0; }\n        const int prev = mp2[obj];\n        edge[mp[obj]].push_back(mp[D[i]]), sub[prev] += sub[i];\n    }\n    ll sum = 0;\n    auto check = [&](auto&& self, const int s, const int d) -> void {\n        sum += d;\n        for (const int to : edge[s]) { self(self, to, d + 1); }\n    };\n    check(check, mp[D[N - 1]], 0);\n    if (D[N - 1] == sum) {\n        for (int i = 0; i < N; i++) {\n            for (const int to : edge[i]) {\n                std::cout << i + 1 << \" \" << to + 1 << std::endl;\n            }\n        }\n    } else {\n        std::cout << -1 << std::endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #includes {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define LET(x,a) __typeof(a) x(a)\n//#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)\n#define ALL(c) (c).begin(), (c).end()\n#define MP make_pair\n\n#define EXIST(e,s) ((s).find(e)!=(s).end())\n\n#define RESET(a) memset((a),0,sizeof(a))\n#define SET(a) memset((a),-1,sizeof(a))\n#define PB push_back\n#define DEC(it,command) __typeof(command) it=command\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define debug_v(x) cerr << #x << \" = [\";REP(__ind,(x).size()){cerr << (x)[__ind] << \", \";}cerr << \"] (L\" << __LINE__ << \")\" << endl;\n\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\n\ntypedef long long Int;\ntypedef unsigned long long uInt;\ntypedef long double rn;\n\ntemplate<class T>\nT inf(){\n\treturn numeric_limits<T>::has_infinity?numeric_limits<T>::infinity():(numeric_limits<T>::max()/2);\n}\n\ntypedef pair<int,int> pii;\n\n/*\n#ifdef MYDEBUG\n#include\"debug.h\"\n#include\"print.h\"\n#endif\n*/\n// }}}\n\n\n//{{{ io\nFILE *file_in=stdin,*file_out=stdout;\n#define fin normal_in\n#define fout normal_out\n//const char fname[]=\"\";\n//FILE *fin=fopen(fname,\"r\"),*fout=fopen(fname,\"w\");\n#ifdef __MINGW32__\n#define LLD \"%I64d\"\n#define LLU \"%I64u\"\n#else\n#define LLD \"%lld\"\n#define LLU \"%llu\"\n#endif\nstruct NORMAL_IN{\n\tbool cnt;\n\tNORMAL_IN():cnt(true){}\n\toperator int() const {return cnt;}\n#define endl \"\\n\"\n\tNORMAL_IN& operator>>(int &n){cnt=fscanf(file_in,\"%d\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(unsigned int &n){cnt=fscanf(file_in,\"%u\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(long long &n){cnt=fscanf(file_in,LLD,&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(unsigned long long &n){cnt=fscanf(file_in,LLU,&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(double &n){cnt=fscanf(file_in,\"%lf\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(long double &n){cnt=fscanf(file_in,\"%Lf\",&n)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(char *c){cnt=fscanf(file_in,\"%s\",c)!=EOF;return *this;}\n\tNORMAL_IN& operator>>(string &s){\n\t\ts.clear();\n\t\tfor(bool r=false;;){\n\t\t\tconst char c=getchar();\n\t\t\tif(c==EOF){ cnt=false; break;}\n\t\t\tconst int t=isspace(c);\n\t\t\tif(!r and !t)r=true;\n\t\t\tif(r){\n\t\t\t\tif(!t)s.push_back(c);\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n\ttemplate<class T>\n\t\tNORMAL_IN& operator>>(vector<T> &v){\n\t\t\tint v_size = v.size();\n\t\t\tREP(i,v_size){\n\t\t\t\t*this>>v[i];\n\t\t\t}\n\t\t\treturn *this;\n\t\t}\n} normal_in;\n\nstruct NORMAL_OUT{\n\tNORMAL_OUT& operator<<(const int &n){fprintf(file_out,\"%d\",n);return *this;}\n\tNORMAL_OUT& operator<<(const unsigned int &n){fprintf(file_out,\"%u\",n);return *this;}\n\tNORMAL_OUT& operator<<(const long long &n){fprintf(file_out,LLD,n);return *this;}\n\tNORMAL_OUT& operator<<(const unsigned long long &n){fprintf(file_out,LLU,n);return *this;}\n\tNORMAL_OUT& operator<<(const double &n){fprintf(file_out,\"%lf\",n);return *this;}\n\tNORMAL_OUT& operator<<(const long double &n){fprintf(file_out,\"%Lf\",n);return *this;}\n\tNORMAL_OUT& operator<<(const char c[]){fprintf(file_out,\"%s\",c);return *this;}\n\tNORMAL_OUT& operator<<(const string &s){fprintf(file_out,\"%s\",s.c_str());return *this;}\n} normal_out;\nstruct ERR_OUT{\n\ttemplate<class T>\n\t\tERR_OUT& operator<<(const T &a){\n\t\t\tcerr<<\"\\x1b[7m\"<<a<<\"\\x1b[m\";\n\t\t\treturn *this;\n\t\t}\n} ferr;\n//}}}\n\n//{{{ Graph<Weight> g(size); addEdge(g,{src,dst},weight); matrix<Weight> A(n,m);\ntypedef int Node;\ntemplate<class Weight>\nstruct edge {\n\tint src, dst;\n\tWeight weight;\n\tint rev;\n\tedge(int src, int dst, Weight weight=1,int rev=-1) :\n\t\tsrc(src), dst(dst), weight(weight), rev(rev){ }\n};\ntemplate<class Weight>\nbool operator < (const edge<Weight> &e, const edge<Weight> &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\t\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n//typedef vector<edge> edges;\n//typedef vector<edges> Graph;\n \ntemplate<class Weight>\nstruct matrix:vector<vector<Weight> >{\n\tmatrix(const array<int,2> &a, Weight w=0):vector<vector<Weight> >(a[0],vector<Weight>(a[1],w)){}\n\tmatrix(const array<int,1> &a, Weight w=0):vector<vector<Weight> >(a[0],vector<Weight>(a[0],0)){}\n\tmatrix(){}\n};\n \ntemplate<class Weight>\nstruct graph:vector<vector<edge<Weight> > >{\n\tWeight inf{::inf<Weight>()};\n\tgraph(){}\n\tgraph(const int &n):vector<vector<edge<Weight> > >(n){}\n\tvoid _add_edge(int from, int to, Weight w, int rev=-1){\n\t\tif((int)this->size() < from + 1)this->resize(from + 1);\n\t\tthis->at(from).push_back(edge<Weight>(from,to,w,rev));\n\t}\n};\n//add bi-directional edge\ntemplate<class Weight>\nvoid addBiEdge(graph<Weight> &g, const pair<int,int> &e, Weight w=1){\n\tconst int &from = e.first, &to = e.second;\n\tg._add_edge(from,to,w,g[to].size());\n\tg._add_edge(to,from,w,g[from].size()-1);\n}\n//add directional edge\ntemplate<class Weight>\nvoid addEdge(graph<Weight> &g, const pair<int,int> &e, Weight w=1){\n\tconst int &from = e.first, &to = e.second;\n\tg._add_edge(from,to,w);\n}\n \ntypedef int Weight;\ntypedef edge<Weight> Edge;\ntypedef vector<edge<Weight> > Edges;\ntypedef graph<Weight> Graph;\ntypedef matrix<Weight> Matrix;\n \n#ifdef DEBUG\n#include\"graph/graphviz.h\"\n#endif\n//}}}\n\nInt N;\nvector<Int> D;\nGraph G;\n\nInt dfs(int u,int level = 0,int p = -1){\n\tInt ret = level;\n\tfor(auto &&e:G[u]){\n\t\tif(e.dst==p)continue;\n\t\tret += dfs(e.dst,level+1,u);\n\t}\n\treturn ret;\n}\n\nvoid solve(){\n\tvector<pii> e;\n//\tsort(ALL(D));\n//\treverse(ALL(D));\n\tvector<pair<Int,int> > vp;\n\tREP(i,D.size()){\n\t\tvp.push_back({D[i],i});\n\t}\n\tsort(ALL(vp));\n\treverse(ALL(vp));\n\tmap<Int,pair<int,int>> mp;//id, num of child\n\tREP(u,D.size()){\n\t\tmp[D[u]] = {u,1};\n\t}\n\tREP(t,D.size()-1){\n\t\tint i = vp[t].second;\n\t\tInt d = D[i];\n\t\tauto x = mp[d];\n\t\tInt d2 = d - (N - 2*x.second);\n\t\tauto it = mp.find(d2);\n\t\tif(it==mp.end()){\n\t\t\tfout<<-1<<endl;\n\t\t\treturn;\n\t\t}\n\t\tit->second.second+=x.second;\n\t\te.push_back({mp[d].first,it->second.first});\n\t}\n\tG.assign(N,Edges());\n\tfor(auto &&p:e){\n\t\taddBiEdge(G,{p.first,p.second});\n\t}\n\tint umin = vp[D.size()-1].second;\n\tInt k = dfs(umin);\n\tif(k!=D[umin]){\n\t\tfout<<-1<<endl;\n\t\treturn;\n\t}\n\tREP(i,e.size()){\n\t\tfout<<e[i].first+1<<\" \"<<e[i].second+1<<endl;\n\t}\n\treturn;\n}\n\n//{{{ main function\nint main(){\t\n\t\n\tfin >> N;\n\tD.assign(N-1+1,Int());\n\tfor(int i = 0 ; i <= N-1 ; i++){\n\t\tfin >> D[i];\n\t}\n\tsolve();\n\treturn 0;\n}\n//}}}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b)for(int i=a,_e=b;i<=_e;++i)\n#define fd(i,a,b)for(int i=b,_e=a;i>=_e;--i)\n#define ll long long\n#define NO return printf(\"-1\"),0\nusing namespace std;\nconst int N=1e5+5;\nint n,b[N][2],bs,sz[N];\nll w[N],su;\nvector<int>e[N];\nunordered_map<ll,int>A;\nvoid find(int x,int len){\n\tsu+=len;\n\tfor(int i:e[x])find(i,len+1);\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\tfo(i,1,n)cin>>w[i],A[w[i]]=i,sz[i]=1;\n\tsort(w+1,w+n+1);\n\tfd(i,2,n){\n\t\tint x=A[w[i]],y;\n\t\tif(sz[x]*2>=n)NO;\n\t\ty=A[w[i]-n+sz[x]*2];\n\t\tif(!y)NO;\n\t\t++bs;b[bs][0]=x;b[bs][1]=y;\n\t\tsz[y]+=sz[x];\n\t\te[y].push_back(x);\n\t}\n\tfind(A[w[1]],0);\n\tif(su!=w[1])NO;\n\tfo(i,1,bs)printf(\"%d %d\\n\",b[i][0],b[i][1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <cctype>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}\n\twhile (isdigit(ch)){x=x*10+ch-48;ch=getchar();}\n\treturn x*f;\n}\n\npair <long long,int> D[100050];\n\npair <int,int> edge[100050];\n\nvector <int> G[100050];\n\nint n,size[100050],dis[100050],tot;\n\ninline void dfs(int u,int fa)\n{\n\tfor (int i=0;i<G[u].size();i++)\n\t{\n\t\tint v=G[u][i];\n\t\tif (v!=fa)\n\t\t{\n\t\t\tdis[v]=dis[u]+1;\n\t\t\tdfs(v,u);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tn=read();\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint d=read();\n\t\tD[i]={d,i};\n\t\tsize[i]=1;\n\t}\n\tsort(D+1,D+n+1);\n\treverse(D+1,D+n+1);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tlong long delta=D[i].first-n+2*size[i];\n\t\tint l=1,r=n,pos=0; \n\t\twhile (l<=r)\n\t\t{\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif (D[mid].first<=delta)\n\t\t\t{\n\t\t\t\tr=mid-1;\n\t\t\t\tpos=mid;\n\t\t\t}\n\t\t\telse\n\t\t\t\tl=mid+1;\n\t\t}\n\t\t//cout << D[pos].first << \" \" << delta << endl;\n\t\tif (D[pos].first!=delta)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint u=D[i].second,v=D[pos].second;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t\tedge[++tot]={u,v};\n\t\tsize[pos]+=size[i];\n\t}\t\n\tdfs(D[n].second,0);\n\tlong long sum=0;\n\tfor (int i=1;i<=n;i++)\n\t\tsum+=dis[i];\n\tif (sum==D[n].first)\n\t{\n\t\tfor (int i=1;i<=tot;i++)\n\t\t\tcout << edge[i].first << \" \" << edge[i].second << endl;\n\t}\n\telse\n\t\tputs(\"-1\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXn = 1e5 + 10;\ntypedef pair<long long, int> pii;\npii ar[MAXn];\nlong long n, sz[MAXn], root, disroot, d[MAXn], hp3[MAXn];\nvector<int> vec[MAXn];\nvector<pii> ans;\n\nbool cmp(pii p1, pii p2) {\n\treturn p1.first > p2.first;\n}\n\nlong long dfs1(int v, int  par) {\n\tlong long res = 0;\n\tfor (int i = 0; i < vec[v].size(); i++)\n\t\tif (vec[v][i] != par) {\n\t\t\tres += dfs1(vec[v][i], v) + hp3[vec[v][i]];\n\t\t\thp3[v] += hp3[vec[v][i]];\n\t\t}\n\thp3[v]++;\n\n\treturn res;\n\t\n}\n\nvoid dfs2(int v, int par, long long sth) {\n\tif (sth != d[v]) {\n\t\tcout << -1;\n\t\texit(0);\n\t}\n\tfor (int i = 0; i < vec[v].size(); i++) {\n\t\tif (vec[v][i] != par) {\n\t\t\tdfs2(vec[v][i], v, sth - (hp3[vec[v][i]]) + (hp3[ar[0].second] - hp3[vec[v][i]]));\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}\nint main() {\n\tcin >> n;\n\tfill_n(sz, MAXn, 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tint di;\n\t\tcin >> di;\n\t\td[i] = di;\n\t\tar[i].first = di;\n\t\tar[i].second = i;\n\t}\n\tsort(ar, ar + n);\n\tfor (int i = n - 1; i > 0; i--) {\n\t\tlong long hp = ar[i].first - n;\n\t\thp += 2LL * sz[ar[i].second];\n\t\tint hp2 = lower_bound(ar, ar + n, pii(hp, -1)) - ar;\n\t\tif (ar[hp2].first != hp)\n\t\t\treturn cout << -1,0;\n\t\tsz[ar[hp2].second] += sz[ar[i].second];\n\t\tvec[ar[hp2].second].push_back(ar[i].second);\n\t\tvec[ar[i].second].push_back(ar[hp2].second);\n\t\tans.push_back(pii(ar[i].second, ar[hp2].second));\n\t}\n\tdisroot = dfs1(ar[0].second, -1);\n\tdfs2(ar[0].second, -1, disroot);\n\tif (ans.size() != n - 1)\n\t\treturn cout << -1,0;\n\tfor (int i = 0; i < ans.size(); i++)\n\t\tcout << ans[i].first + 1<< ' ' << ans[i].second + 1<< endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntemplate <typename T> void read(T& t){ cin >> t; }\ntemplate <typename T, typename ... U> void read(T& t, U& ... u){ read(t); read(u ...); }\ntemplate <typename T> void write(T t){ cout << t; }\ntemplate <typename T, typename ... U> void write(T t, U ... u){ write(t); write(u ...); }\n//#define int long long\n#define FAST ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)\n#define size(x) (int)x.size()\n#define all(x) x.begin(),x.end()\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define ROF(i,b,a) for(int i=b; i>=a; --i)\nusing LL = long long;\nusing pii = pair<int,int>;\nconst int INF = 2e9;\nconst int NN = 1e5 + 3;\n\nint n;\nset<LL> s;\nset<LL> firstLeavesDist;\nmap<LL,int> id;\nmap<int,LL> dist, dist2;\nint sz[NN];\nvector<pii> e;\nvector<int> adj[NN];\n\nvoid checkConn(int u, set<int> &visited){\n\tvisited.insert(u);\n\tfor(int v: adj[u]) if(!visited.count(v)) checkConn(v, visited);\n}\n\nLL getDistSum(int u, int prv, int d){\n\tLL sum = 0;\n\tsum += d;\n\tfor(int v: adj[u]) if(v != prv) sum += getDistSum(v, u, d+1);\n\treturn sum;\n}\n\nvoid distributeDistSum(int u, int prv, LL sum){\n\tdist2[u] = sum;\n\tfor(int v: adj[u]) if(v != prv) distributeDistSum(v, u, sum - sz[v] + (n-sz[v]));\n}\n\nint32_t main(){ FAST;\n\tread(n);\n\tFOR(i,1,n){ LL d; read(d); s.insert(d); id[d] = i; dist[i] = d; }\n\n\tif(n == 2 || n == 3 || n == 4){\n\t\twrite(-1, \"\\n\");\n\t\treturn 0;\n\t}\n\n\tFOR(i,1,n) sz[i] = 1;\n\tROF(cnt,n,2){\n\t\tint d = *rbegin(s);\n\t\ts.erase(d);\n\t\tint i = id[d];\n\n\t\t// Dj = Di + sz - (n-sz)\n\t\tint nxtD = d + sz[i] - (n-sz[i]);\n\t\tif(!s.count(nxtD)){\n\t\t\twrite(-1, \"\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tint j = id[nxtD];\n\t\te.emplace_back(i,j);\n\t\tsz[j] += sz[i];\n\t}\n\n\tfor(auto [u,v]: e){\n\t\tadj[u].emplace_back(v);\n\t\tadj[v].emplace_back(u);\n\t}\n\n\tint root = -1;\n\tFOR(i,1,n) if(sz[i] == n) root = i;\n\tif(root == -1){\n\t\twrite(-1, \"\\n\");\n\t\treturn 0;\n\t}\n\t\n\tset<int> visited;\n\tcheckConn(root, visited);\n\tif(!(size(visited) == n)){\n\t\twrite(-1, \"\\n\");\n\t\treturn 0;\n\t}\n\n\tLL sum = getDistSum(root,root,0);\n\n\tdistributeDistSum(root,root,sum);\n\n\tbool different = false;\n\tfor(auto el: dist) if(dist[el.first] != dist2[el.first]) different = true;\n\tfor(auto el: dist2) if(dist[el.first] != dist2[el.first]) different = true;\n\tif(different){\n\t\twrite(-1, \"\\n\");\n\t\treturn 0;\n\t}\n\n\tfor(auto [u,v]: e) write(u, \" \", v, \"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i, a, b) for(int i = a;i < b;i++)\n#define For(i, a) FOR(i, 0, a)\n#define REV(i, a, b) for(int i = b-1;i >= a;i--)\n#define Rev(i, a) REV(i, 0, a)\n#define REP(a) For(i, a)\n#define DEBUG_PRINT(...) fprintf(stderr, __VA_ARGS__)\n#ifdef ENABLE_DEBUG\n#define DEBUG(a) cerr<<#a<<\"=\"<<a<<endl\n#define DEBUG_ARRAY(a,n) cerr<<#a<<\"[\"<<n<<\"]=\"<<a[n]<<endl\n#else\n#define DEBUG(a) \n#define DEBUG_ARRAY(a,n) \n#endif\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\nvoid print_pair(pi a){\n  cerr<<\"(\"<<a.first<<\", \"<<a.second<<\") \";\n}\ntemplate<int T1, int T2>\nvoid print_2d(int a[T1][T2], int x, int y){\n  For(i, x){\n    For(j, y){\n      cerr<<a[i][j]<<\" \";\n    }\n    cerr<<endl;\n  }\n}\ntemplate<class T>\nvoid print_array(T a[],size_t n){\n  cerr<<\"array:\";\n  REP(n-1)cerr<<a[i]<<\",\";\n  cerr<<a[n-1]<<endl;\n}\n\nint N;\npll D[100000];\nll d[100000];\nint childnumD[100000];\nvector<pll> ans;\n\nint main(){\n  cin>>N;\n  REP(N){\n    ll tmp;\n    cin>>tmp;\n    D[i]=pll(tmp,i+1);\n  }\n  sort(D,D+N,greater<pll>());\n  REP(N){\n    d[i]=D[i].first;\n    if(d[i]>=N){\n      cout<<-1<<endl;\n      return 0;\n    }\n    DEBUG(d[i]);\n  }\n  for (int i = 0; i < N-1; i++) {\n    ll tmp=d[i]-(N-2)+2*childnumD[i];\n    DEBUG(tmp);\n      auto itr=lower_bound(d,d+N,tmp,greater<ll>());\n      DEBUG(*itr);\n      if(itr==d+N||*itr!=tmp){\n        cout<<-1<<endl;\n        return 0;\n      }\n      ans.push_back(pll(D[i].second,D[itr-d].second));\n      childnumD[itr-d]++;\n      childnumD[itr-d]+=childnumD[i];\n  }\n  for(auto&& i : ans)\n  {\n    cout<<i.first<<\" \"<<i.second<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <iostream>\nusing namespace std;\nint main() {\n    int n; cin >> n;\n    long long d[n]; for (int i = 0; i < n; i++) cin >> d[i];\n    int v[n];\n    iota(v, v+n, 0);\n    sort(v, v+n, [&d](int i, int j) { return d[i] > d[j]; });\n    map<long long, int> vertex;\n    for (int i = 0; i < n; i++) vertex[d[i]] = i;\n    vector<pair<int, int> > ans;\n    int sz[n];\n    fill(sz, sz+n, 1);\n    for (int p = 0; p < n-1; p++) {\n        const int i = v[p];\n        const long long dist = d[i] - n + 2 * sz[i];\n        // cerr << i << \" \" << sz[i] << \" \" << d[i] << \" \" << dist << endl;\n        if (d[i] == dist || vertex.find(dist) == vertex.end()) {\n            cout << \"-1\\n\";\n            return 0;\n        }\n        int j = vertex[dist];\n        sz[j] += sz[i];\n        ans.push_back({j, i});\n    }\n    if (d[v[n-1]] == accumulate(sz, sz+n, 0LL) - sz[v[n-1]])\n        for (auto [i, j] : ans) cout << i+1 << \" \" << j+1 << endl;\n    else\n        cout << \"-1\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define eb emplace_back\n#define mt make_tuple\n#define all(x) (x).begin(), (x).end() \n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair <int, int> ii;\ntypedef pair <ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef long double ld;\n\nconst ll INF=LLONG_MAX;\nconst int mxn=1e5+5;\nll sz[mxn];\nvi adj[mxn];\nll dis[mxn];\n\nvoid dfs(int u, int p=-1){\n\tfor(auto v:adj[u]){\n\t\tif(v==p)continue;\n\t\tdis[v]=dis[u]+1LL;\n\t\tdfs(v,u);\n\t}\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    //freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout);\n\tint n;\n\tcin >> n;\n\tpll dist[n];\n\tmap<ll,int>vis;\n\tmap<ii,bool>ans;\n\tfor(int i=0; i<n; i++){\n\t\tcin >> dist[i].fi;\n\t\tdist[i].se=(ll)i;\n\t\tsz[i]=1LL;\n\t\tvis[dist[i].fi]=i;\n\t}\n\tsort(dist,dist+n);\n\tfor(int i=n-1; i>0; i--){\n\t\tauto ind = dist[i].se;\n\t\tauto next = dist[i].fi-n+2*sz[ind];\n\t\tif(vis.find(next)==vis.end()||next>=dist[i].fi){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tauto ptr = vis[next];\n\t\tif(ptr==ind){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsz[ptr] += sz[ind];\n\t\tadj[ind].eb(ptr);\n\t\tadj[ptr].eb(ind);\n\t\tans[ii(ptr,ind)]=1;\n\t}\n\tbool ok=0;\n\tfor(int i=0; i<n&&!ok; i++){\n\t\tif(sz[i]==n)ok=1;\n\t}\n\tdfs(dist[0].se);\n\tll sum=0;\n\tfor(int i=0; i<n; i++)sum += dis[i];\n\tif(sum!=dist[0].fi)ok=0;\n\tif(!ok)cout << -1 << endl;\n\telse{\n\t\tfor(auto x:ans){\n\t\t\tcout << x.fi.fi+1 << ' ' << x.fi.se+1 << endl;\n\t\t}\t\n\t}\n}\n\t\n// READ & UNDERSTAND\n// ll, int overflow, array bounds, memset(0)\n// special cases (n=1?), n+1 (1-index)\n// do smth instead of nothing & stay organized\n// WRITE STUFF DOWN\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Node{\n\tlong long d;\n\tint id;\n\tNode(){}\n\tNode(long long d, int id) : d(d), id(id){}\n\tbool operator <(const Node& p) const{\n\t\treturn d < p.d;\n\t}\n};\n\nconst int N = 1e5 + 10;\n\nNode a[N];\nint sz[N];\nmap <long long, int> sav;\nvector <int> tr[N];\nlong long ans;\n\nvoid dfs(int x, int now){\n\tans += now;\n\tfor (int i = 0; i < tr[x].size(); i++) dfs(tr[x][i], now + 1);\n}\n\nint main(){\n\tint n, num;\n\tlong long rec;\n\tscanf(\"%d\",&n);\n\tfor (int i = 1; i <= n; i++){\n\t\tscanf(\"%lld\",&a[i].d);\n\t\ta[i].id = i;\n\t\tsz[i] = 1;\n\t}\n\tsort(a + 1, a + n + 1);\n\tfor (int i = 1; i <= n; i++) sav.insert({a[i].d, i});\n\tfor (int i = n; i >= 2; i--){\n\t\trec = a[i].d - n + sz[i] * 2;\n\t\tif (!sav.count(rec)){\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tnum = sav[rec];\n\t\tif (num == i){\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\ttr[num].push_back(i);\n\t\tsz[num] += sz[i];\n\t}\n\tdfs(1, 0);\n\tif (ans != a[1].d){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++){\n\t\tfor (int j = 0; j < tr[i].size(); j++){\n\t\t\tprintf(\"%d %d\\n\", a[i].id, a[tr[i][j]].id);\n\t\t}\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = pair<lint, int>;\nconst int MAXN = 100005;\n\nvoid my_ass(bool p){\n\tif(!p){\n\t\tputs(\"-1\");\n\t\texit(0);\n\t}\n}\n\nint n, leaf_size[MAXN];\npi a[MAXN];\nvector<int> gph[MAXN];\n\nlint get_dist(int x, int p, int d){\n\tlint ret = d;\n\tfor(auto &i : gph[x]){\n\t\tif(i != p){\n\t\t\tret += get_dist(i, x, d + 1);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<=n; i++){\n\t\tscanf(\"%lld\",&a[i].first);\n\t\ta[i].second = i;\n\t}\n\tsort(a + 1, a + n + 1);\n\tfill(leaf_size + 1, leaf_size + n + 1, 1);\n\tfor(int i=n; i; i--){\n\t\tlint nxt = a[i].first - n + 2 * leaf_size[i];\n\t\tint pos = lower_bound(a + 1, a + n + 1, pi(nxt, -1)) - a;\n\t\tif(a[pos].first == nxt && pos < i){\n\t\t\tgph[pos].push_back(i);\n\t\t\tgph[i].push_back(pos);\n\t\t\tleaf_size[pos] += leaf_size[i];\n\t\t}\n\t\telse my_ass(0);\n\t}\n\tmy_ass(get_dist(1, 0, 0) == a[1].first);\n\tfor(int i=1; i<=n; i++){\n\t\tfor(auto &j : gph[i]){\n\t\t\tif(i < j) printf(\"%d %d\\n\", a[i].second, a[j].second);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\ntypedef pair < int , int > pp;\nconst int N = 1e5 + 5;\n\nmap < int , int > H;\nvector < int > V[N];\npp A[N];\nint sz[N];\n\nint f(int x, int d){\n    int t = d;\n    for(int i=0; i<V[x].size(); i++)\n        t += f(V[x][i], d+1);\n    return t;\n}\n\nsigned main(){\n    int n;\n\tcin >> n;\n    for(int i=1; i<=n; i++){\n        int x;\n        scanf(\"%lld\",&x);\n        A[i] = mp(x,i);\n        H[x] = i;\n    }\n            \n    sort(A+1 , A+n+1);\n    for(int i=n; i>=2; i--){\n        int x = A[i].nd;\n        sz[x]++;\n        H[ A[i].st ] = 0; \n        int par = H[ A[i].st - n + 2 * sz[x] ];\n        if(par == 0){\n            cout << -1;\n            return 0;\n        }\n        \n        sz[par] += sz[x];\n        V[par].pb(x);\n    }\n    \n    if(f(A[1].nd, 0) != A[1].st){\n        cout << -1;\n        return 0;\n    }\n    \n    for(int i=1; i<=n; i++)\n        for(int j=0; j<V[i].size(); j++)\n            printf(\"%lld %lld\\n\", i, V[i][j]);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string>\n#include <algorithm>\n#include <math.h>\n#include <map>\n#include <chrono>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    int N;\n    cin >> N;\n    vector<long long> d(N);\n    vector<pair<int, int>> t;\n    map<long long, int> a;\n    for (int i = 0; i < N; i++)\n    {\n        cin >> d[i];\n        a[d[i]] = i;\n    }\n\n    vector<int> weigtht(N, 1);\n    for (int it = 0; it < N - 1; it++)\n    {\n        auto target = a.rbegin();\n        int i = target->second;\n        long long dis = d[i];\n        long long next = dis - (N - weigtht[i]) + weigtht[i];\n        if (a.find(next) == a.end() || a[next] == i)\n        {\n            cout << \"-1\" << endl;\n            return 0;\n        }\n        int j = a[next];\n        weigtht[j] += weigtht[i];\n        t.push_back({i, j});\n        a.erase(--a.end());\n    }\n\n    vector<vector<int>> g(N);\n    for (int i = 0; i < N - 1; i++)\n    {\n        g[t[i].first].push_back(t[i].second);\n        g[t[i].second].push_back(t[i].first);\n    }\n    vector<int> valid(N, -1);\n    valid[0] = 0;\n    vector<int> que(1, 0);\n    for (int i = 0; i < (int)que.size(); i++)\n    {\n        for (int &j : g[que[i]])\n        {\n            if (valid[j] == -1)\n            {\n                que.push_back(j);\n                valid[j] = valid[que[i]] + 1;\n            }\n        }\n    }\n\n    long long int node_0_d = 0;\n    for (int i = 0; i < N; i++)\n    {\n        if (valid[i] != -1)\n        {\n            node_0_d += valid[i];\n        }\n    }\n\n    if ( node_0_d != d[0] )\n    {\n        cout << \"-1\" << endl;\n        return 0;\n    }\n\n    for (int i = 0; i < N - 1; i++)\n    {\n        cout << t[i].first + 1 << \" \" << t[i].second + 1 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint N;\nlong long D[100010];\nint cnt[100010];\nint ansu[100010], ansv[100010];\n\nint bsrch(int ll, int rr, long long vv)\n{\n\tint l=ll, r=rr;\n\tint m;\n\twhile(l<r){\n\t\tm = (l+r)/2;\n\t\tif(D[m] >= vv){\n\t\t\tr = m;\n\t\t}\n\t\telse\n\t\t\tl = m+1;\n\t}\n\treturn l;\n}\n\nint solve()\n{\n\tint i, j=0;\n\tsort(D, D+N);\n\tfor(i=N-1; i>0; i--){\n\t\tint p = bsrch(0, i, D[i]-(N-2-cnt[i]*2) );\n\t\tif(p>=i || D[p]!=D[i]-(N-2-cnt[i]*2) )\n\t\t\treturn 0;\n\t\tcnt[p] += cnt[i]+1;\n\t\tansu[j] = p;\n\t\tansv[j] = i;\n\t\tj ++;\n\t}\n\tfor(i=0; i<N-1; i++){\n\t\tprintf(\"%d %d\\n\", ansu[i]+1, ansv[i]+1);\n\t}\n\treturn 1;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\tint i;\n\tscanf(\"%d\", &N);\n\tfor(i=0; i<N; i++)\n\t\tscanf(\"%lld\", &D[i]);\n\tif(solve() == 0)\n\t\tprintf(\"-1\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <vector>\n#include <algorithm>\n\ntypedef long long int64;\n\nconst int maxn = 100005;\nint n, size[maxn];\nint64 d[maxn];\nstd::map<int64, int> s;\n\nint main()\n{\n\tstatic int id[maxn];\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tscanf(\"%lld\", d + i), s[d[i]] = i, id[i] = i;\n\tstd::sort(id + 1, id + 1 + n, [](int x, int y) { return d[x] < d[y]; });\n\tstd::vector<std::pair<int, int>> e;\n\tfor (int i = 1; i <= n; ++i)\n\t\tsize[i] = 1;\n\tfor (int i = n; i != 1; --i)\n\t{\n\t\tif (2 * size[id[i]] >= n || !s.count(d[id[i]] - (n - 2 * size[id[i]])))\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint fa = s[d[id[i]] - (n - 2 * size[id[i]])];\n\t\te.emplace_back(fa, id[i]);\n\t\tsize[fa] += size[id[i]];\n\t\td[id[1]] -= size[id[i]];\n\t}\n\tif (d[id[1]])\n\t\tputs(\"-1\");\n\telse\n\t\tfor (const auto &p : e)\n\t\t\tprintf(\"%d %d\\n\", p.first, p.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\ntypedef long long ll;\n\ntypedef pair<ll,ll> P;\nlong long int INF = 1e18;\ndouble Pi = 3.1415926535897932384626;\nlong long int mod = 1000000007;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"RULD\";\n//↓,→,↑,←\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,a,b) for(i=a;i<=b;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\n\n\n\nll i,j,k,ii,jj;\nll n,m,num;\nll a,b,c,e,f,g,h;\nll x[800005],y[800005],z[900005];\nll d[800005],dp[500005];\nll vnum = 0,sum;\nbool dame;\nbool check[500005];\n\n\nvoid unite(ll a,ll b){\n    x[vnum] = a;\n    y[vnum] = b;\n    G[a].pb(b);\n    G[b].pb(a);\n    vnum++;\n}\n\nvoid dfs(ll v,ll dpn){\n    if(check[v]){\n        return;\n    }else{\n        sum += dpn;\n        check[v] = true;\n        for(int i=0;i<G[v].size();i++){\n            if(!check[G[v][i]])dfs(G[v][i],dpn + 1);\n        }\n    }\n}\nint main(){\n    cin>>n;\n    for(i=0;i<n;i++){\n        cin>>d[i];\n        z[i] = d[i];\n    }\n    sort(d,d+n);\n    for(i=0;i<n;i++){\n        z[i] = (lb(d,d+n,z[i]) - d) * 100001 + i;\n    }\n    sort(z,z+n);\n    //reverse(d,d+n);\n    for(i=n-1;i>=1;i--){\n        //大きい数字から見て行くよ\n        dp[i]++;\n        num = d[i] - n + 2 * dp[i];\n        a = lb(d,d+n,num) - lb(d,d+n,-1);\n        if(d[a] != num || a >= i){\n            dame = true;\n            break;\n        }else{\n            dp[a] += dp[i];\n            unite(a+1,i+1);\n        }\n    }\n    sum = 0;\n    dfs(1,0);\n    //p(sum);\n    if(sum != d[0]){\n        dame = true;\n    }\n    if(dame){\n        p(-1);\n        return 0;\n    }else{\n        for(i=0;i<vnum;i++){\n            pe(z[x[i]-1]%100001 + 1);p(z[y[i]-1]%100001 + 1);\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<60)+1e9; // ~ 1.15 * 1e18\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\n\nInt check(vector<vector<Int> > G, Int root,Int d){\n\n  function<Int(Int,Int,Int)>  dfs = [&](Int pos,Int pre,Int dis){\n    Int res = dis;\n    for(Int to:G[pos]){\n      if(to == pre) continue;\n      res += dfs(to, pos, dis+1);\n    }\n    return res;\n  };\n  return dfs(root, -1, 0) == d;\n}\n\nsigned main(){\n  srand((unsigned)time(NULL));\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  Int n;\n  cin>>n;\n  vector<P> D(n);\n  map<Int,Int> num;\n  for(Int i=0;i<n;i++){\n    Int d;\n    cin>>d;\n    D[i] = P(d, i);\n    num[d] = i;\n  }\n  sort(D.begin(), D.end(), greater<P>());\n\n  vector<Int> sz(n, 1);\n  vector<vector<Int> > G(n);\n\n  auto add_edge = [&](Int a,Int b){\n    G[a].push_back(b);\n    G[b].push_back(a);\n  };\n\n  \n  for(Int i=0;i<n-1;i++){\n    Int d, pos; tie(d, pos) = D[i];\n    Int x  = sz[pos];\n    Int nd = d + x - (n - x);\n\n    if(!num.count(nd)){\n      cout<<-1<<endl;\n      return 0;\n    }\n    Int to = num[nd];\n    if(d <= nd){\n      cout<<-1<<endl;\n      return 0;\n    }\n\n    add_edge(pos, to);\n    sz[to] += sz[pos];\n  }\n\n  \n  /*  if(!check(G, D[n-1].second, D[n-1].first)){\n    cout<<-1<<endl;\n    return 0;\n    }*/\n\n  \n  for(Int i=0;i<n;i++)\n    for(Int to:G[i]){\n      if(i > to) continue;\n      cout<<i+1<<\" \"<<to+1<<endl;\n    }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nconst int N = 100001;\nstruct node {\n\tint d, id;\n\tnode() {}\n\tnode(int d, int x):d(d), id(x) {}\n\tfriend bool operator < (node a, node b) { return a.d < b.d; }\n}d[N];\nint sz[N], u[N], v[N];\n\ninline int read() {\n\tint x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - 48;\n\t\tch = getchar();\n\t}\n\treturn x * flag;\n}\n\nsigned main() {\n\tint n = read();\n\tfor (int i = 1; i <= n; ++i) {\n\t\td[i] = node{read(), i};\n\t\tsz[i] = 1;\n\t}\n\tsort(d + 1, d + 1 + n);\n\tint sum = 0, cnt = 0;\n\tfor (int i = n; i > 1; --i) {\n\t\tint dis = d[i].d - n + (sz[i] << 1);\n\t\tint pos = lower_bound(d + 1, d + 1 + n, node{dis, 0}) - d;\n\t\tif (d[pos].d != dis) return puts(\"-1\"), 0;\n\t\tcnt++;\n\t\tu[cnt] = d[i].id;\n\t\tv[cnt] = d[pos].id;\n\t\tsz[pos] += sz[i];\n\t\tsum += sz[i];\n\t}\n\tif (sum != d[1].d) puts(\"-1\");\n\telse {\n\t\tfor (int i = 1; i <= cnt; ++i) {\n\t\t\tprintf(\"%lld %lld\\n\", u[i], v[i]);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Text",
    "code": "-1\n"
  },
  {
    "language": "Text",
    "code": "-1\n"
  },
  {
    "language": "C",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream& operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream& operator<<(ostream &os, vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream &os, pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\nint N;\nconstexpr int Nmax = 100000;\nvector<plint> D;\nvector<int> to[Nmax];\n\nplint dfs(int now, int prev)\n{\n    lint d = 0, subtreesz = 1;\n    for (auto nxt : to[now]) if (nxt != prev)\n    {\n        plint pa = dfs(nxt, now);\n        d += pa.first + pa.second;\n        subtreesz += pa.second;\n    }\n    return plint(d, subtreesz);\n}\n\nint main()\n{\n    cin >> N;\n    D.resize(N);\n    REP(i, N)\n    {\n        cin >> D[i].first;\n        D[i].second = i;\n    }\n\n    sort(D.begin(), D.end());\n\n    map<lint, vector<pint>> ma; // requiredD -> [(childId, stSz)]\n\n    while (!D.empty())\n    {\n        lint Dnow, id_now;\n        tie(Dnow, id_now) = D.back();\n        D.pop_back();\n\n        int stsz = 1;\n\n        if (ma.count(Dnow))\n        {\n            for (auto pa : ma[Dnow])\n            {\n                to[id_now].push_back(pa.first);\n                to[pa.first].push_back(id_now);\n                stsz += pa.second;\n            }\n            ma.erase(Dnow);\n        }\n        ma[Dnow + 2 * stsz - N].push_back(pint(id_now, stsz));\n    }\n\n    vector<pint> res;\n    REP(s, N) for (auto t : to[s]) if (s < t) res.push_back(pint(s, t));\n\n    // dbg(dfs(D[0].second, -1));\n    if (res.size() != N - 1 || dfs(D[0].second, -1).first != D[0].first) cout << -1 << endl, exit(0);\n\n    for (auto pa : res) cout << pa.first + 1 << \" \" << pa.second + 1 << endl;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N\t100000\n\nlong long ss[N];\n\nint compare(const void *a, const void *b) {\n\tint i = *(int *) a;\n\tint j = *(int *) b;\n\n\treturn ss[i] < ss[j] ? -1 : 1;\n}\n\nint search(int *ii, int n, long long s) {\n\tint lower = -1, upper = n;\n\n\twhile (upper - lower > 1) {\n\t\tint h = (lower + upper) / 2;\n\n\t\tif (ss[ii[h]] <= s)\n\t\t\tlower = h;\n\t\telse\n\t\t\tupper = h;\n\t}\n\treturn lower == -1 || ss[ii[lower]] != s ? -1 : ii[lower];\n}\n\nint main() {\n\tstatic int ii[N], sz[N], pp[N], dd[N];\n\tint n, i;\n\tlong long sum;\n\n\tscanf(\"%d\", &n);\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%lld\", &ss[i]);\n\t\tii[i] = i;\n\t}\n\tqsort(ii, n, sizeof *ii, compare);\n\tfor (i = 0; i < n; i++)\n\t\tsz[i] = 1;\n\tfor (i = n - 1; i > 0; i--) {\n\t\tint p = search(ii, n, ss[ii[i]] - (n - sz[ii[i]] * 2));\n\n\t\tif (sz[ii[i]] * 2 >= n || p == -1) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tpp[ii[i]] = p, sz[p] += sz[ii[i]];\n\t}\n\tsum = 0;\n\tfor (i = 1; i < n; i++)\n\t\tsum += dd[ii[i]] = dd[pp[ii[i]]] + 1;\n\tif (ss[ii[0]] != sum) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor (i = 1; i < n; i++)\n\t\tprintf(\"%d %d\\n\", ii[i] + 1, pp[ii[i]] + 1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n#define M_MAX 200000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n// double distance (sll x1, sll y1, sll x2, sll y2) {\n// \tdouble xdist2, ydist2, origindist, dist;\n\n// \txdist2 = (x1 - x2) * (x1 - x2);\n// \tydist2 = (y1 - y2) * (y1 - y2);\n// \treturn sqrt(xdist2 + ydist2);\n// }\n\nint32_t pullcomp (const void *left, const void *right) {\n\tull l = *(ull*)left;\n\tull r = *(ull*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t psllcomp (const void *left, const void *right) {\n\tsll l = *(sll*)left;\n\tsll r = *(sll*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pcharcomp (const void *left, const void *right) {\n\tchar l = *(char*)left;\n\tchar r = *(char*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pdoublecomp (const void *left, const void *right) {\n\tdouble l = *(double*)left;\n\tdouble r = *(double*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nint32_t phwllABcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t phwllREVcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t ptriplecomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.c < r.c) {\n\t\treturn -1;\n\t}\n\tif (l.c > r.c) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX];\n// ull a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX];\n// sll b[3001][3001];\nsll c[N_MAX];\n// sll d[N_MAX];\n// sll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nhwll xy[N_MAX];\n// sll table[1000][1000];\n\null parent[N_MAX];\null children[N_MAX];\n\null depth[N_MAX];\null dfs (ull v) {\n\tif (!v || depth[v]) return depth[v];\n\treturn depth[v] = dfs(parent[v]) + 1;\n}\n\n\nsll findv (ull d, ull i) {\n\tsll ok = 0, ng = i;\n\twhile (ok + 1 < ng) {\n\t\tsll med = (ok + ng) / 2;\n\t\tif (xy[med].a <= d) {\n\t\t\tok = med;\n\t\t} else {\n\t\t\tng = med;\n\t\t}\n\t}\n\tif (xy[ok].a != d) return -1;\n\treturn ok;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\tull result = 0;\n\t// sll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tfor (i = 0; i < n; i++) {\n\t\txy[i].a = a[i];\n\t\txy[i].b = i;\n\t}\n\tqsort(xy, n, sizeof(hwll), phwllABcomp);\n\n\tfor (i = n - 1; i; i--) {\n\t\tull d = xy[i].a;\n\t\tsll pd = d + children[i] - (n - 2 - children[i]);\n\t\tif (pd <= 0) goto fail;\n\n\t\tsll p = findv(pd, i);\n\t\tif (p < 0) goto fail;\n\n\t\tparent[i] = p;\n\t\tchildren[p] += children[i] + 1;\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tsum += dfs(i);\n\t}\n\tif (sum != xy[0].a) goto fail;\n\n\tfor (i = 1; i < n; i++) {\n\t\tprintf(\"%lld %lld\\n\", xy[i].b + 1, xy[parent[i]].b + 1);\n\t}\n\n\t// printf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\tputs(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\tfor (i = 0; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t}\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// for (i = 0; i < m; i++) {\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \t// b[i]--;\n\t// }\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%llu\", &table[i][j]);\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", &s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20181228\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid shuffledget(int x[],int n){\n    srand(time(0));\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\nvoid prarr(int arr[],int n){\n  int i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%d\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\ntypedef struct{\nlong long val;\nlong long node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val > ((sd*)b)->val){return -1;}\nif(((sd*)a)->val < ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\ntypedef struct{\n    long long st;\n    long long fi;\n    long long kr;\n}rs;\n\ntypedef struct{\n    long long st;\n    long long kz;\n}mkj;\n\nint sortfnc(const void *a,const void *b){\nif(((rs*)a)->st > ((rs*)b)->st){return 1;}\nif(((rs*)a)->st < ((rs*)b)->st){return -1;}\nif(((rs*)a)->fi > ((rs*)b)->fi){return 1;}\nif(((rs*)a)->fi < ((rs*)b)->fi){return -1;}\nreturn 0;\n}\n\nvoid makemkj(rs g[],mkj x[],long long n){\n    long long i,ms=0,nst=g[0].st;\n    for(i=1;i<n;i++){\n        if(g[i].st!=g[i-1].st){\n            x[nst].kz=i-ms;\n            x[nst].st=ms;\n            nst=g[i].st;ms=i;\n        }\n    }\n    x[nst].kz=n-ms;\n    x[nst].st=ms;\n}\n\nlong long dist[131072],par[131072];\nvoid dfs(long long t,long long l,long long bp,rs g[],mkj x[]){\n  long long i;\n  if(dist[t]<=l){return;}\n  dist[t]=l;\n  par[t]=bp;\n  for(i=x[t].st;i<x[t].st+x[t].kz;i++){\n    dfs(g[i].fi,l+1,t,g,x);\n  }\n}\n\nint main(void){\n    long long i,j,n,m,k,a[131072],b,c,h,w,r=0,l,t;\n    long long dp[131072],st,fi,te;\n    sd dat[131072];\n    rs g[262144];\n    mkj x[131072];\n    scanf(\"%lld\",&n);\n    for(i=1;i<=n;i++){\n      scanf(\"%lld\",&a[i]);\n      dat[i].val=a[i];\n      dat[i].node=i;\n      dp[i]=1;\n    }\n    qsort(&dat[1],n,sizeof(dat[1]),sdsortfnc);\n    dat[n+1].val=-llinf;\n    for(i=1;i<n;i++){\n      w=dat[i].val-n+2*dp[i];\n      st=i+1;fi=n;\n      while(st<=fi){\n        te=(st+fi)/2;\n        if(dat[te].val<=w){fi=te-1;}\n        else{st=te+1;}\n      }\n      if(dat[st].val!=w){\n        printf(\"-1\\n\");\n        return 0;\n      }\n      g[2*i-2].st=dat[i].node;\n      g[2*i-2].fi=dat[st].node;\n      g[2*i-1].fi=dat[i].node;\n      g[2*i-1].st=dat[st].node;\n      dp[st]+=dp[i];\n    }\n    qsort(g,2*(n-1),sizeof(g[0]),sortfnc);\n    makemkj(g,x,2*(n-1));\n    for(i=0;i<=n;i++){\n      dist[i]=llinf;\n    }\n    dfs(1,0,-1,g,x);\n    w=0;\n    for(i=2;i<=n;i++){\n      w+=dist[i];\n    }\n    if(w!=a[1]){\n      printf(\"-1\\n\");\n      return 0;\n    }\n    for(i=0;i<2*(n-1);i++){\n      if(g[i].st<g[i].fi){\n        printf(\"%lld %lld\\n\",g[i].st,g[i].fi);\n      }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException; \nimport java.io.InputStream; \nimport java.io.PrintWriter; \nimport java.util.*; \n \n\nclass Main{\n\tstatic class Node{\n\t\tint v;\n\t\tlong d;\n\t\tNode(int v, long d){this.v=v;this.d=d;}\n\t}\n\tstatic void solve(){\n\t\tint n = ni();\n\t\tList<Node> nodes = new ArrayList<>();\n\t\tMap<Long, Integer> dtoi = new HashMap<>();\n\t\tfor(int i=0;i<n;++i){\n\t\t\tlong d=nl();\n\t\t\tnodes.add(new Node(i, d));\n\t\t\tdtoi.put(d, i);\n\t\t}\n\t\tCollections.sort(nodes, (a,b)->b.d-a.d<0 ? -1:1);\n\t\tint[] s = new int[n];\n\t\tint[] pare = new int[n];\n\t\tArrays.fill(pare, -1);\n\t\tArrays.fill(s, 1);\n\t\tfor(int i=0;i<n-1;++i){\n\t\t\tNode node = nodes.get(i);\n\t\t\tif(!dtoi.containsKey(node.d+2*s[node.v]-n) || node.v == dtoi.get(node.d+2*s[node.v]-n)){\n\t\t\t\tout.println(-1);return;\n\t\t\t}\n\t\t\tint p = dtoi.get(node.d+2*s[node.v]-n);\n\t\t\tpare[node.v] = p;\n\t\t\ts[p] += s[node.v];\n\t\t}\n\n\n\t\tfor(int i=0;i<n;++i){\n\t\t\tif(pare[i]<0)continue;\n\t\t\tout.println((i+1)+\" \"+(pare[i]+1));\n\t\t}\n\n\t}\n \n \n \n \n\t public static void main(String[] args){ \n\t\t solve(); \n\t\t out.flush(); \n\t } \n\t private static InputStream in = System.in; \n\t private static PrintWriter out = new PrintWriter(System.out); \n \n\t static boolean inrange(int y, int x, int h, int w){ \n\t\t return y>=0 && y<h && x>=0 && x<w; \n\t } \n\t @SuppressWarnings(\"unchecked\") \n\t static<T extends Comparable> int lower_bound(List<T> list, T key){ \n\t\t int lower=-1;int upper=list.size(); \n\t\t while(upper - lower>1){ \n\t\t int center =(upper+lower)/2; \n\t\t if(list.get(center).compareTo(key)>=0)upper=center; \n\t\t else lower=center; \n\t\t } \n\t\t return upper; \n\t } \n\t @SuppressWarnings(\"unchecked\") \n\t static <T extends Comparable> int upper_bound(List<T> list, T key){ \n\t\t int lower=-1;int upper=list.size(); \n\t\t while(upper-lower >1){ \n\t\t int center=(upper+lower)/2; \n\t\t if(list.get(center).compareTo(key)>0)upper=center; \n\t\t else lower=center; \n\t\t } \n\t\t return upper; \n\t } \n\t @SuppressWarnings(\"unchecked\") \n\t static <T extends Comparable> boolean next_permutation(List<T> list){ \n\t\t int lastIndex = list.size()-2; \n\t\t while(lastIndex>=0 && list.get(lastIndex).compareTo(list.get(lastIndex+1))>=0)--lastIndex; \n\t\t if(lastIndex<0)return false; \n\t\t int swapIndex = list.size()-1; \n\t\t while(list.get(lastIndex).compareTo(list.get(swapIndex))>=0)swapIndex--; \n\t\t T tmp = list.get(lastIndex); \n\t\t list.set(lastIndex++, list.get(swapIndex)); \n\t\t list.set(swapIndex, tmp); \n\t\t swapIndex = list.size()-1; \n\t\t while(lastIndex<swapIndex){ \n\t\t tmp = list.get(lastIndex); \n\t\t list.set(lastIndex, list.get(swapIndex)); \n\t\t list.set(swapIndex, tmp); \n\t\t ++lastIndex;--swapIndex; \n\t\t } \n\t\t return true; \n\t } \n\t private static final byte[] buffer = new byte[1<<15]; \n\t private static int ptr = 0; \n\t private static int buflen = 0; \n\t private static boolean hasNextByte(){ \n\t\t if(ptr<buflen)return true; \n\t\t ptr = 0; \n\t\t try{ \n\t\t\t buflen = in.read(buffer); \n\t\t } catch (IOException e){ \n\t\t\t e.printStackTrace(); \n\t\t } \n\t\t return buflen>0; \n\t } \n\t private static int readByte(){ if(hasNextByte()) return buffer[ptr++]; else return -1;} \n\t private static boolean isSpaceChar(int c){ return !(33<=c && c<=126);} \n\t private static int skip(){int res; while((res=readByte())!=-1 && isSpaceChar(res)); return res;} \n \n\t private static double nd(){ return Double.parseDouble(ns()); } \n\t private static char nc(){ return (char)skip(); } \n\t private static String ns(){ \n\t\t StringBuilder sb = new StringBuilder(); \n\t\t for(int b=skip();!isSpaceChar(b);b=readByte())sb.append((char)b); \n\t\t return sb.toString(); \n\t } \n\t private static int[] nia(int n){ \n\t\t int[] res = new int[n]; \n\t\t for(int i=0;i<n;++i)res[i]=ni(); \n\t\t return res; \n\t } \n\t private static long[] nla(int n){ \n\t\t long[] res = new long[n]; \n\t\t for(int i=0;i<n;++i)res[i]=nl(); \n\t\t return res; \n\t } \n\t private static int ni(){ \n\t\t int res=0,b; \n\t\t boolean minus=false; \n\t\t while((b=readByte())!=-1 && !((b>='0'&&b<='9') || b=='-')); \n\t\t if(b=='-'){ \n\t\t\t minus=true; \n\t\t\t b=readByte(); \n\t\t } \n\t\t for(;'0'<=b&&b<='9';b=readByte())res=res*10+(b-'0'); \n\t\t return minus ? -res:res; \n\t } \n\t private static long nl(){ \n\t\t long res=0,b; \n\t\t boolean minus=false; \n\t\t while((b=readByte())!=-1 && !((b>='0'&&b<='9') || b=='-')); \n\t\t if(b=='-'){ \n\t\t\t minus=true; \n\t\t\t b=readByte(); \n\t\t } \n\t\t for(;'0'<=b&&b<='9';b=readByte())res=res*10+(b-'0'); \n\t\t return minus ? -res:res; \n\t} \n} \n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.NoSuchElementException;\nimport java.util.PrimitiveIterator;\nimport java.util.function.DoubleUnaryOperator;\nimport java.util.function.IntBinaryOperator;\nimport java.util.function.IntFunction;\nimport java.util.function.IntPredicate;\nimport java.util.function.IntSupplier;\nimport java.util.function.IntUnaryOperator;\nimport java.util.function.LongUnaryOperator;\n\n\npublic class Main {\n    public static void main(String[] args) {\n        StringBuilder out = new StringBuilder();\n        solve(out);\n        PrintWriter pw = new PrintWriter(System.out);\n        pw.println(out);\n        pw.flush();\n        pw.close();\n    }\n\n    public static void solve(StringBuilder out) {\n        int n = In.ni();\n        long[] d = In.nl(n);\n        int[] idx = IntArrayGenerator.indexToInt(n, i -> i);\n        DependentSort.sortDescending(d, idx);\n        HashMap<Long, Integer> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            map.put(d[i], i);\n        }\n        IntArrayList[] ch = new IntArrayList[n];\n        for (int i = 0; i < n; i++) {\n            ch[i] = new IntArrayList();\n        }\n        for (int v = 0; v < n - 1; v++) {\n            long s = 0;\n            for (int i : ch[v]) {\n                s += (long) n - d[i] + d[v];\n            }\n            long du = s + d[v] - (n - 2);\n            if (du >= d[v]) {\n                out.append(-1);\n                return;\n            } else if (map.containsKey(du)) {\n                ch[map.get(du)].add(v);\n            } else {\n                out.append(-1);\n                return;\n            }\n        }\n        long s = 0;\n        int[] dep = new int[n];\n        Arrays.fill(dep, 0, n - 1, -1);\n        IntQueue q = new IntQueue(n);\n        q.add(n - 1);\n        while (q.size() > 0) {\n            int u = q.poll();\n            s += dep[u];\n            for (int v : ch[u]) {\n                if (dep[v] < 0) {\n                    dep[v] = dep[u] + 1;\n                    q.add(v);\n                }\n            }\n        }\n        if (s != d[n - 1]) {\n            out.append(-1);\n            return;\n        }\n        int[] p = new int[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = idx[i];\n        }\n        for (int u = 0; u < n; u++) {\n            for (int v : ch[u]) {\n                out.append(p[u] + 1).append(' ').append(p[v] + 1).append('\\n');\n            }\n        }\n    }\n}\n\nfinal class InsertionSort {\n    protected static void sort(final int[] a) {\n        sort(a, 0, a.length);\n    }\n\n    protected static void sort(final int[] a, final int from, final int to) {\n        for (int i = from + 1; i < to; i++) {\n            final int tmp = a[i];\n            if (a[i - 1] > tmp) {\n                int j = i;\n                do {\n                    a[j] = a[j - 1];\n                    j--;\n                } while (j > from && a[j - 1] > tmp);\n                a[j] = tmp;\n            }\n        }\n    }\n\n    protected static void sort(final long[] a) {\n        sort(a, 0, a.length);\n    }\n\n    protected static void sort(final long[] a, final int from, final int to) {\n        for (int i = from + 1; i < to; i++) {\n            final long tmp = a[i];\n            if (a[i - 1] > tmp) {\n                int j = i;\n                do {\n                    a[j] = a[j - 1];\n                    j--;\n                } while (j > from && a[j - 1] > tmp);\n                a[j] = tmp;\n            }\n        }\n    }\n}\n\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class IntArrayList implements Iterable<Integer> {\n    private int[] a;\n    private int tail = 0;\n\n    private static final int DEFAULT_SIZE = 64;\n\n    public IntArrayList(final int capacity) {\n        this.a = new int[Math.max(1, capacity)];\n    }\n\n    public IntArrayList() {\n        this(DEFAULT_SIZE);\n    }\n\n    public void add(final int v) {\n        if (tail == a.length) {\n            resize(2);\n        }\n        a[tail++] = v;\n    }\n\n    public int removeLast() {\n        return a[tail--];\n    }\n\n    public int get(final int i) {\n        if (i >= this.tail) {\n            System.err.println(\"Error in IntArrayList::get(\" + i + \"): ArrayIndexOutOfBounds. list size = \" + tail);\n        }\n        return a[i];\n    }\n\n    public void set(final int i, final int v) {\n        if (i >= this.tail) {\n            System.err.println(\"Error in IntArrayList::set(\" + i + \"): ArrayIndexOutOfBounds. list size = \" + tail);\n        }\n        a[i] = v;\n    }\n\n    private void resize(final double grow) {\n        final int[] b = new int[(int) Math.ceil(a.length * grow)];\n        System.arraycopy(a, 0, b, 0, a.length);\n        a = b;\n    }\n\n    public int size() {\n        return tail;\n    }\n\n    public void reverse(final int begin, final int end) {\n        IntArrays.reverse(a, begin, end);\n    }\n\n    public void reverse() {\n        IntArrays.reverse(a, 0, tail);\n    }\n\n    public int[] toArray() {\n        final int[] ret = new int[tail];\n        System.arraycopy(a, 0, ret, 0, tail);\n        return ret;\n    }\n\n    public boolean addIf(final int v, final IntPredicate p) {\n        if (p.test(v)) {\n            add(v);\n            return true;\n        }\n        return false;\n    }\n\n    public PrimitiveIterator.OfInt iterator() {\n        return new IntArrayListIterator();\n    }\n\n    private class IntArrayListIterator implements PrimitiveIterator.OfInt {\n        private int i = 0;\n\n        public boolean hasNext() {\n            return i < tail;\n        }\n\n        public int nextInt() {\n            return a[i++];\n        }\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class RadixSort {\n    private static final int INT_INSERTION_SORT_THRESHOLD = 120;\n    private static final int LONG_INSERTION_SORT_THRESHOLD = 250;\n\n    private static final int BUCKET_SIZE = 256;\n    private static final int BUCKET_HALF_SIZE = 128;\n    private static final int INT_RECURSION = 4;\n    private static final int LONG_RECURSION = 8;\n    private static final int SHIFT = 3;\n    private static final int MASK = 0xff;\n\n    public static void sort(final int[] a) {\n        sort(a, 0, a.length);\n    }\n\n    public static void sortDescending(final int[] a) {\n        sortDescending(a, 0, a.length);\n    }\n\n    public static void sort(final int[] a, final int from, final int to) {\n        if (to - from <= INT_INSERTION_SORT_THRESHOLD) {\n            InsertionSort.sort(a, from, to);\n            return;\n        }\n        final int len = to - from;\n        final int[] bucket = new int[len];\n        final int[] cnt = new int[BUCKET_SIZE + 1];\n        for (int l = 0;;) {\n            final int shift = l << SHIFT;\n            for (int i = from; i < to; i++) {\n                cnt[((a[i] >>> shift) & MASK) + 1]++;\n            }\n            for (int i = 0, j = 1; i < BUCKET_SIZE; i = j, j++) {\n                cnt[j] += cnt[i];\n            }\n            final int positive = cnt[BUCKET_HALF_SIZE];\n            for (int i = from; i < to; i++) {\n                final int v = a[i];\n                bucket[cnt[(v >>> shift) & MASK]++] = v;\n            }\n            if (++l == INT_RECURSION) {\n                final int negative = len - positive;\n                System.arraycopy(bucket, positive, a, from, negative);\n                System.arraycopy(bucket, 0, a, from + negative, positive);\n                return;\n            }\n            System.arraycopy(bucket, 0, a, from, len);\n            Arrays.fill(cnt, 0);\n        }\n    }\n\n    public static void sortDescending(final int[] a, final int from, final int to) {\n        sort(a, from, to);\n        int l = from, r = to - 1;\n        while (l < r) {\n            final int tmp = a[l];\n            a[l] = a[r];\n            a[r] = tmp;\n            l++;\n            r--;\n        }\n    }\n\n    public static void sort(final long[] a) {\n        sort(a, 0, a.length);\n    }\n\n    public static void sortDescending(final long[] a) {\n        sortDescending(a, 0, a.length);\n    }\n\n    public static void sort(final long[] a, final int from, final int to) {\n        if (to - from <= LONG_INSERTION_SORT_THRESHOLD) {\n            InsertionSort.sort(a, from, to);\n            return;\n        }\n        final int len = to - from;\n        final long[] bucket = new long[len];\n        final int[] cnt = new int[BUCKET_SIZE + 1];\n        for (int l = 0;;) {\n            final int shift = l << SHIFT;\n            for (int i = from; i < to; i++) {\n                cnt[(int) (((a[i] >>> shift) & MASK) + 1)]++;\n            }\n            for (int i = 0, j = 1; i < BUCKET_SIZE; i = j, j++) {\n                cnt[j] += cnt[i];\n            }\n            final int positive = cnt[BUCKET_HALF_SIZE];\n            for (int i = from; i < to; i++) {\n                final int bi = (int) ((a[i] >>> shift) & MASK);\n                bucket[cnt[bi]++] = a[i];\n            }\n            if (++l == LONG_RECURSION) {\n                final int negative = len - positive;\n                System.arraycopy(bucket, positive, a, from, negative);\n                System.arraycopy(bucket, 0, a, from + negative, positive);\n                return;\n            }\n            System.arraycopy(bucket, 0, a, from, len);\n            Arrays.fill(cnt, 0);\n        }\n    }\n\n    public static void sortDescending(final long[] a, final int from, final int to) {\n        sort(a, from, to);\n        int l = from, r = to - 1;\n        while (l < r) {\n            final long tmp = a[l];\n            a[l] = a[r];\n            a[r] = tmp;\n            l++; r--;\n        }\n    }\n}\n\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n * \n * (NON-DESTRUCTIVE) methods that returns int array.\n */\nfinal class IntArrayGenerator {\n\n    private IntArrayGenerator(){}\n    \n    public static int[] filled(final int n, final int init) {\n        final int[] ret = new int[n];\n        Arrays.fill(ret, init);\n        return ret;\n    }\n\n    public static int[][] filled(final int n, final int m, final int init) {\n        final int[][] ret = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(ret[i], init);\n        }\n        return ret;\n    }\n\n    public static int[] generate(final int n, final IntSupplier f) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, i -> f.getAsInt());\n        return a;\n    }\n\n    public static int[][] generate(final int n, final int m, final IntSupplier f) {\n        final int[][] a = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            a[i] = generate(m, f);\n        }\n        return a;\n    }\n\n    public static int[] indexToInt(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, f);\n        return a;\n    }\n\n    public static int[][] indexToInt(final int n, final int m, final IntBinaryOperator f) {\n        final int[][] a = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            final int ii = i;\n            a[i] = indexToInt(m, j -> f.applyAsInt(ii, j));\n        }\n        return a;\n    }\n\n    public static int[] toArray(final Collection<? extends Number> collection) {\n        final int n = collection.size();\n        final int[] ret = new int[n];\n        final Object[] coll = collection.toArray();\n        for (int i = 0; i < n; i++) {\n            ret[i] = ((Number) coll[i]).intValue();\n        }\n        return ret;\n    }\n\n    public static int[] unique(final int[] a) {\n        final HashSet<Integer> set = new HashSet<>();\n        for (final int e : a) {\n            set.add(e);\n        }\n        final int m = set.size();\n        final int[] b = new int[m];\n        int index = 0;\n        for (int i = 0; i < a.length; i++) {\n            if (set.contains(a[i])) {\n                b[index++] = a[i];\n                set.remove(a[i]);\n            }\n        }\n        return b;\n    }\n\n    public static int[][] transpose(final int[][] a) {\n        final int n = a.length;\n        final int m = a[0].length;\n        final int[][] ret = new int[m][n];\n        for (int j = 0; j < m; j++) {\n            for (int i = 0; i < n; i++) {\n                ret[j][i] = a[i][j];\n            }\n        }\n        return ret;\n    }\n\n    public static int[] count(final int[] a, final int max) {\n        final int[] ret = new int[max + 1];\n        for (int i = 0; i < a.length; i++) {\n            ret[a[i]]++;\n        }\n        return ret;\n    }\n\n    public static int[] map(final int[] a, final IntUnaryOperator f) {\n        final int[] b = new int[a.length];\n        Arrays.setAll(b, i -> f.applyAsInt(a[i]));\n        return b;\n    }\n\n    public static int[] filter(final int[] a, final IntPredicate p) {\n        final IntArrayList ret = new IntArrayList();\n        for (final int e : a) {\n            ret.addIf(e, p);\n        }\n        return ret.toArray();\n    }\n\n    public static int[] filterIndex(final int beginIndex, final int endIndex, final IntPredicate p) {\n        final IntArrayList ret = new IntArrayList();\n        for (int i = beginIndex; i < endIndex; i++) {\n            ret.addIf(i, p);\n        }\n        return ret.toArray();\n    }\n\n    public static int[] filterIndex(final int endIndex, final IntPredicate p) {\n        return filterIndex(0, endIndex, p);\n    }\n\n    public static int[] accumulateFromHead(final int[] a, final IntBinaryOperator op, final int e) {\n        final int n = a.length;\n        final int[] ret = new int[n + 1];\n        ret[0] = e;\n        for (int i = 0; i < n; i++) {\n            ret[i + 1] = op.applyAsInt(ret[i], a[i]);\n        }\n        return ret;\n    }\n\n    public static int[] accumulateFromTail(final int[] a, final IntBinaryOperator op, final int e) {\n        final int n = a.length;\n        final int[] ret = new int[n + 1];\n        ret[n] = e;\n        for (int i = n - 1; i >= 0; i--) {\n            ret[i] = op.applyAsInt(ret[i + 1], a[i]);\n        }\n        return ret;\n    }\n}\n\n@FunctionalInterface\ninterface LongComparator {\n    public int compare(long i, long j);\n\n    public default boolean eq(final long i, final long j) {\n        return compare(i, j) == 0;\n    }\n\n    public default boolean ne(final long i, final long j) {\n        return compare(i, j) != 0;\n    }\n\n    public default boolean gt(final long i, final long j) {\n        return compare(i, j) > 0;\n    }\n\n    public default boolean ge(final long i, final long j) {\n        return compare(i, j) >= 0;\n    }\n\n    public default boolean lt(final long i, final long j) {\n        return compare(i, j) < 0;\n    }\n\n    public default boolean le(final long i, final long j) {\n        return compare(i, j) <= 0;\n    }\n}\n\n\nfinal class ComparativeMergeSort {\n    private static int INSERTION_SORT_THRESHOLD = 60;\n\n    public static void sort(final int[] a, final IntComparator comparator) {\n        sort(a, 0, a.length, comparator);\n    }\n\n    public static void sort(final int[] a, final int begin, final int end, final IntComparator comparator) {\n        for (int i = begin;;) {\n            final int j = i + INSERTION_SORT_THRESHOLD;\n            if (j < end) {\n                ComparativeInsertionSort.sort(a, i, j, comparator);\n            } else {\n                ComparativeInsertionSort.sort(a, i, end, comparator);\n                break;\n            }\n            i = j;\n        }\n        final int len = end - begin;\n        final int[] work = new int[len];\n        for (int block = INSERTION_SORT_THRESHOLD; block <= len; block <<= 1) {\n            final int twoBlocks = block << 1;\n            for (int from = begin, max = end - block; from < max; from += twoBlocks) {\n                final int mid = from + block;\n                final int to = Math.min(from + twoBlocks, end);\n                System.arraycopy(a, from, work, 0, block);\n                for (int i = from, wi = 0, ti = mid;; i++) {\n                    if (ti == to) {\n                        System.arraycopy(work, wi, a, i, block - wi);\n                        break;\n                    } else if (comparator.gt(work[wi], a[ti])) {\n                        a[i] = a[ti++];\n                    } else {\n                        a[i] = work[wi++];\n                        if (wi == block) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    public static void sort(final long[] a, final LongComparator comparator) {\n        sort(a, 0, a.length, comparator);\n    }\n\n    public static void sort(final long[] a, final int begin, final int end, final LongComparator comparator) {\n        for (int i = begin;;) {\n            final int j = i + INSERTION_SORT_THRESHOLD;\n            if (j < end) {\n                ComparativeInsertionSort.sort(a, i, j, comparator);\n            } else {\n                ComparativeInsertionSort.sort(a, i, end, comparator);\n                break;\n            }\n            i = j;\n        }\n        final int len = end - begin;\n        final long[] work = new long[len];\n        for (int block = INSERTION_SORT_THRESHOLD; block <= len; block <<= 1) {\n            final int twoBlocks = block << 1;\n            for (int from = begin, max = end - block; from < max; from += twoBlocks) {\n                final int mid = from + block;\n                final int to = Math.min(from + twoBlocks, end);\n                System.arraycopy(a, from, work, 0, block);\n                for (int i = from, wi = 0, ti = mid;; i++) {\n                    if (ti == to) {\n                        System.arraycopy(work, wi, a, i, block - wi);\n                        break;\n                    } else if (comparator.gt(work[wi], a[ti])) {\n                        a[i] = a[ti++];\n                    } else {\n                        a[i] = work[wi++];\n                        if (wi == block) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class In {\n    public static final FastScanner fsc = new FastScanner();\n\n    public static int ni() {\n        return fsc.nextInt();\n    }\n\n    public static int ni(final IntUnaryOperator f) {\n        return f.applyAsInt(fsc.nextInt());\n    }\n\n    public static int[] ni(final int n) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, i -> fsc.nextInt());\n        return a;\n    }\n\n    public static int[] ni(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, i -> ni(f));\n        return a;\n    }\n\n    public static int[][] ni(final int n, final int m) {\n        final int[][] a = new int[n][m];\n        Arrays.setAll(a, i -> ni(m));\n        return a;\n    }\n\n    public static int[][] ni(final int n, final int m, final IntUnaryOperator f) {\n        final int[][] a = new int[n][m];\n        Arrays.setAll(a, i -> ni(m, f));\n        return a;\n    }\n\n    public static long nl() {\n        return fsc.nextLong();\n    }\n\n    public static long nl(final LongUnaryOperator f) {\n        return f.applyAsLong(fsc.nextLong());\n    }\n\n    public static long[] nl(final int n) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, i -> fsc.nextLong());\n        return a;\n    }\n\n    public static long[] nl(final int n, final LongUnaryOperator f) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, i -> nl(f));\n        return a;\n    }\n\n    public static long[][] nl(final int n, final int m) {\n        final long[][] a = new long[n][m];\n        Arrays.setAll(a, i -> nl(m));\n        return a;\n    }\n\n    public static long[][] nl(final int n, final int m, final LongUnaryOperator f) {\n        final long[][] a = new long[n][m];\n        Arrays.setAll(a, i -> nl(m, f));\n        return a;\n    }\n\n    public static char[] nc() {\n        return fsc.next().toCharArray();\n    }\n\n    public static char[][] nc(final int n, final int m) {\n        final char[][] c = new char[n][m];\n        Arrays.setAll(c, i -> nc());\n        return c;\n    }\n\n    public static double nd() {\n        return fsc.nextDouble();\n    }\n\n    public static double nd(final DoubleUnaryOperator f) {\n        return f.applyAsDouble(fsc.nextDouble());\n    }\n\n    public static double[] nd(final int n) {\n        final double[] a = new double[n];\n        Arrays.setAll(a, i -> fsc.nextDouble());\n        return a;\n    }\n\n    public static double[] nd(final int n, final DoubleUnaryOperator f) {\n        final double[] a = new double[n];\n        Arrays.setAll(a, i -> nd(f));\n        return a;\n    }\n\n    public static double[][] nd(final int n, final int m) {\n        final double[][] a = new double[n][m];\n        Arrays.setAll(a, i -> nd(m));\n        return a;\n    }\n\n    public static double[][] nd(final int n, final int m, final DoubleUnaryOperator f) {\n        final double[][] a = new double[n][m];\n        Arrays.setAll(a, i -> nd(m, f));\n        return a;\n    }\n\n    public static String ns() {\n        return fsc.next();\n    }\n\n    public static String[] ns(final int n) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, i -> ns());\n        return s;\n    }\n\n    public static boolean[][] grid(final int h, final int w, final char trueCharacter) {\n        final boolean[][] grid = new boolean[h][w];\n        for (int i = 0; i < h; i++) {\n            final char[] s = fsc.next().toCharArray();\n            for (int j = 0; j < w; j++) {\n                grid[i][j] = s[j] == trueCharacter;\n            }\n        }\n        return grid;\n    }\n}\n\n\nfinal class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (final IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int readByte() {\n        if (hasNextByte()) {\n            return buffer[ptr++];\n        } else {\n            return -1;\n        }\n    }\n\n    private static boolean isPrintableChar(final int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    public boolean hasNext() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr])) {\n            ptr++;\n        }\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        final StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n\n    public int nextInt() {\n        final long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n            throw new NumberFormatException();\n        }\n        return (int) nl;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n * \n * 1. DESTRUCTIVE methods for int arrays.\n * 2. methods that receives arrays and return some results (except for int arrays).\n */\nfinal class IntArrays {\n\n    private IntArrays(){}\n\n    public static void swap(final int[] a, final int u, final int v) {\n        final int tmp = a[u];\n        a[u] = a[v];\n        a[v] = tmp;\n    }\n\n    public static void reverse(final int[] a, final int begin, final int end) {\n        for (int i = begin; i < begin + (end - begin) / 2; i++) {\n            swap(a, i, begin + end - i - 1);\n        }\n    }\n\n    public static void reverse(final int[] a) {\n        reverse(a, 0, a.length);\n    }\n\n    public static void sortDescending(final int[] a) {\n        Arrays.sort(a);\n        reverse(a);\n    }\n\n    public static int reduce(final int[] a, final IntBinaryOperator op) {\n        int ret = a[0];\n        for (int i = 1; i < a.length; i++) {\n            ret = op.applyAsInt(ret, a[i]);\n        }\n        return ret;\n    }\n\n    public static void map(final int[] a, final IntUnaryOperator op) {\n        Arrays.setAll(a, i -> op.applyAsInt(a[i]));\n    }\n\n    public static void filter(final int[] src, final int[] dst, final IntPredicate p) {\n        int idx = 0;\n        for (final int e : src) {\n            if (p.test(e)) {\n                dst[idx++] = e;\n            }\n        }\n    }\n\n    public static void filterIndex(final int[] dst, final int beginIndex, final int endIndex, final IntPredicate p) {\n        for (int i = beginIndex, idx = 0; i < endIndex; i++) {\n            if (p.test(i)) {\n                dst[idx++] = i;\n            }\n        }\n    }\n\n    public static void filterIndex(final int dst[], final int endIndex, final IntPredicate p) {\n        filterIndex(dst, 0, endIndex, p);\n    }\n\n    public static void accumulate(final int[] a, final IntBinaryOperator op) {\n        for (int i = 1; i < a.length; i++) {\n            a[i] = op.applyAsInt(a[i - 1], a[i]);\n        }\n    }\n\n    public static void accumulate(final int[] a) {\n        for (int i = 1; i < a.length; i++) {\n            a[i] += a[i - 1];\n        }\n    }\n\n    public static int unique(int[] a) {\n        final HashSet<Integer> set = new HashSet<>();\n        for (final int e : a) {\n            set.add(e);\n        }\n        final int m = set.size();\n        final int[] b = new int[m];\n        int index = 0;\n        for (int i = 0; i < a.length; i++) {\n            if (set.contains(a[i])) {\n                b[index++] = a[i];\n                set.remove(a[i]);\n            }\n        }\n        a = b;\n        return m;\n    }\n\n    public static void permute(int[] a, int[] p) {\n        int n = p.length;\n        boolean[] settled = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            for (int j = i; !settled[j]; j = p[j]) {\n                if (p[j] == i) {\n                    settled[j] = true;\n                    break;\n                }\n                swap(a, j, p[j]);\n                settled[j] = true;\n            }\n        }\n    }\n\n    public static void transpose(int[][] a) {\n        final int n = a.length;\n        final int m = a[0].length;\n        final int[][] ret = new int[m][n];\n        for (int j = 0; j < m; j++) {\n            for (int i = 0; i < n; i++) {\n                ret[j][i] = a[i][j];\n            }\n        }\n        a = ret;\n    }\n\n    public static int compare(final int[] a, final int[] b) {\n        for (int i = 0; i < a.length; i++) {\n            if (i >= b.length) {\n                return -1;\n            } else if (a[i] > b[i]) {\n                return 1;\n            } else if (a[i] < b[i]) {\n                return -1;\n            }\n        }\n        if (a.length < b.length) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n\n    public static boolean equals(final int[] a, final int[] b) {\n        return compare(a, b) == 0;\n    }\n\n    public static String join(final int[] a, final String sep) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < a.length; i++) {\n            sb.append(a[i]);\n            if (i < a.length - 1) {\n                sb.append(sep);\n            }\n        }\n        return sb.toString();\n    }\n\n    public static String joinWithPrefixAndSuffix(final int[] a, final IntFunction<String> idxToPre,\n            final IntFunction<String> idxToSuf, final String sep) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < a.length; i++) {\n            sb.append(idxToPre.apply(i)).append(a[i]).append(idxToSuf.apply(i));\n            if (i < a.length - 1) {\n                sb.append(sep);\n            }\n        }\n        return sb.toString();\n    }\n}\n\n@FunctionalInterface\ninterface IntComparator {\n    public int compare(int i, int j);\n\n    public default boolean eq(final int i, final int j) {\n        return compare(i, j) == 0;\n    }\n\n    public default boolean ne(final int i, final int j) {\n        return compare(i, j) != 0;\n    }\n\n    public default boolean gt(final int i, final int j) {\n        return compare(i, j) > 0;\n    }\n\n    public default boolean ge(final int i, final int j) {\n        return compare(i, j) >= 0;\n    }\n\n    public default boolean lt(final int i, final int j) {\n        return compare(i, j) < 0;\n    }\n\n    public default boolean le(final int i, final int j) {\n        return compare(i, j) <= 0;\n    }\n}\n\nfinal class DependentSort {\n    public static void sort(int[] a, Object... dependentArrays) {\n        sort(a, false, dependentArrays);\n    }\n\n    public static void sortDescending(int[] a, Object... dependentArrays) {\n        sort(a, true, dependentArrays);\n    }\n\n    private static void sort(int[] a, boolean descending, Object... dependentArrays) {\n        int n = a.length;\n        int[] p;\n        if (descending) {\n            p = IndexSort.sortDescending(a);\n            RadixSort.sortDescending(a);\n        } else {\n            p = IndexSort.sort(a);\n            RadixSort.sort(a);\n        }\n        boolean[] settled = new boolean[n];\n        boolean ok = true;\n        for (Object obj : dependentArrays) {\n            if (obj instanceof int[]) {\n                int[] arr = (int[]) obj;\n                for (int i = 0; i < n; i++) {\n                    for (int j = i; ok ^ settled[j]; j = p[j]) {\n                        if (p[j] == i) {\n                            settled[j] = !settled[j];\n                            break;\n                        }\n                        int tmp = arr[j];\n                        arr[j] = arr[p[j]];\n                        arr[p[j]] = tmp;\n                        settled[j] = !settled[j];\n                    }\n                }\n            } else if (obj instanceof long[]) {\n                long[] arr = (long[]) obj;\n                for (int i = 0; i < n; i++) {\n                    for (int j = i; ok ^ settled[j]; j = p[j]) {\n                        if (p[j] == i) {\n                            settled[j] = !settled[j];\n                            break;\n                        }\n                        long tmp = arr[j];\n                        arr[j] = arr[p[j]];\n                        arr[p[j]] = tmp;\n                        settled[j] = !settled[j];\n                    }\n                }\n            } else {\n                throw new UnsupportedOperationException(\"dependent objects musst be int[] or long[] type.\");\n            }\n            ok = !ok;\n        }\n    }\n\n    public static void sort(long[] a, Object... dependentArrays) {\n        sort(a, false, dependentArrays);\n    }\n\n    public static void sortDescending(long[] a, Object... dependentArrays) {\n        sort(a, true, dependentArrays);\n    }\n\n    private static void sort(long[] a, boolean descending, Object... dependentArrays) {\n        int n = a.length;\n        int[] p;\n        if (descending) {\n            p = IndexSort.sortDescending(a);\n            RadixSort.sortDescending(a);\n        } else {\n            p = IndexSort.sort(a);\n            RadixSort.sort(a);\n        }\n        boolean[] settled = new boolean[n];\n        boolean ok = true;\n        for (Object obj : dependentArrays) {\n            if (obj instanceof int[]) {\n                int[] arr = (int[]) obj;\n                for (int i = 0; i < n; i++) {\n                    for (int j = i; ok ^ settled[j]; j = p[j]) {\n                        if (p[j] == i) {\n                            settled[j] = !settled[j];\n                            break;\n                        }\n                        int tmp = arr[j];\n                        arr[j] = arr[p[j]];\n                        arr[p[j]] = tmp;\n                        settled[j] = !settled[j];\n                    }\n                }\n            } else if (obj instanceof long[]) {\n                long[] arr = (long[]) obj;\n                for (int i = 0; i < n; i++) {\n                    for (int j = i; ok ^ settled[j]; j = p[j]) {\n                        if (p[j] == i) {\n                            settled[j] = !settled[j];\n                            break;\n                        }\n                        long tmp = arr[j];\n                        arr[j] = arr[p[j]];\n                        arr[p[j]] = tmp;\n                        settled[j] = !settled[j];\n                    }\n                }\n            } else {\n                throw new UnsupportedOperationException(\"dependent objects musst be int[] or long[] type.\");\n            }\n            ok = !ok;\n        }\n    }\n}\n\n\nfinal class IndexSort {\n    public static int[] sort(final int[] a) {\n        final int[] index = new int[a.length];\n        Arrays.setAll(index, IntUnaryOperator.identity());\n        ComparativeMergeSort.sort(index, (i, j) -> a[i] - a[j]);\n        return index;\n    }\n\n    public static int[] sortDescending(final int[] a) {\n        final int[] index = new int[a.length];\n        Arrays.setAll(index, IntUnaryOperator.identity());\n        ComparativeMergeSort.sort(index, (i, j) -> a[j] - a[i]);\n        return index;\n    }\n\n    public static int[] sort(final long[] a) {\n        final int[] index = new int[a.length];\n        Arrays.setAll(index, IntUnaryOperator.identity());\n        ComparativeMergeSort.sort(index, (i, j) -> Long.compare(a[i], a[j]));\n        return index;\n    }\n\n    public static int[] sortDescending(final long[] a) {\n        final int[] index = new int[a.length];\n        Arrays.setAll(index, IntUnaryOperator.identity());\n        ComparativeMergeSort.sort(index, (i, j) -> Long.compare(a[j], a[i]));\n        return index;\n    }\n}\n\n\nfinal class ComparativeInsertionSort {\n    public static void sort(final int[] a, final int from, final int to, final IntComparator comparator) {\n        for (int i = from + 1; i < to; i++) {\n            final int tmp = a[i];\n            if (comparator.gt(a[i - 1], tmp)) {\n                int j = i;\n                do {\n                    a[j] = a[j - 1];\n                    j--;\n                } while (j > from && comparator.gt(a[j - 1], tmp));\n                a[j] = tmp;\n            }\n        }\n    }\n\n    public static void sort(final long[] a, final int from, final int to, final LongComparator comparator) {\n        for (int i = from + 1; i < to; i++) {\n            final long tmp = a[i];\n            if (comparator.gt(a[i - 1], tmp)) {\n                int j = i;\n                do {\n                    a[j] = a[j - 1];\n                    j--;\n                } while (j > from && comparator.gt(a[j - 1], tmp));\n                a[j] = tmp;\n            }\n        }\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n * \n * Queue for int type.\n */\nfinal class IntQueue implements Iterable<Integer> {\n    private static final int DEFAULT_SIZE = 64;\n\n    private int[] q;\n    private int head = 0;\n    private int tail = 0;\n\n    public IntQueue(final int capacity) {\n        this.q = new int[capacity];\n    }\n\n    public IntQueue() {\n        this(DEFAULT_SIZE);\n    }\n\n    public int peek() {\n        if (head == tail) throw new NoSuchElementException(\"No Elements.\");\n        return q[head];\n    }\n\n    public int getFromHead(int index) {\n        if (head + index >= tail || index < 0) throw new NoSuchElementException(\"Index out of bounds.\");\n        return q[head + index];\n    }\n\n    public int getFromTail(int index) {\n        if (head + index >= tail || index < 0) throw new NoSuchElementException(\"Index out of bounds.\");\n        return q[tail - 1 - index];\n    }\n\n    public void add(final int v) {\n        if (tail == q.length) grow();\n        q[tail++] = v;\n    }\n\n    public void add(final int... vals) {\n        for (int v : vals) add(v);\n    }\n\n    public int poll() {\n        if (head == tail) throw new NoSuchElementException(\"No Elements.\");\n        return q[head++];\n    }\n\n    public int size() {\n        return tail - head;\n    }\n\n    private void grow() {\n        final int[] grown = new int[q.length << 1];\n        final int len = size();\n        System.arraycopy(q, head, grown, 0, len);\n        q = grown;\n        tail = len;\n        head = 0;\n    }\n\n    public PrimitiveIterator.OfInt iterator() {\n        return new IntQueueIterator();\n    }\n\n    private class IntQueueIterator implements PrimitiveIterator.OfInt {\n        private int i = head;\n\n        public boolean hasNext() {\n            return i < tail;\n        }\n\n        public int nextInt() {\n            return q[i++];\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic PrintWriter out;\n\tstatic StringBuilder sb;\n\tstatic int n, m, k;\n\tstatic long mod = 998244353;\n\tstatic Boolean[][] memo;\n\tstatic String s;\n\tstatic int[][] ad;\n\tstatic long inf = Long.MAX_VALUE;\n\tstatic int[] color;\n\tstatic ArrayList<Integer> o;\n\tstatic char[][] g;\n\tstatic boolean[] vis, vis1;\n\tstatic boolean f;\n\tstatic int[] ar, a;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsb = new StringBuilder();\n\t\tn = sc.nextInt();\n\t\tTreeSet<pair> bfs = new TreeSet<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tbfs.add(new pair(sc.nextLong(), i, 0));\n\t\t}\n\t\twhile (!bfs.isEmpty()) {\n\t\t\tpair cur = bfs.pollFirst();\n\t\t\tint ext = cur.lv;\n\t\t\tlong v = cur.x - (n - 2 ) + 2*ext;\n\t\t\tpair rob = bfs.ceiling(new pair(v, 0, 0));\n\t\t//\tSystem.out.println(v + \" G: \" + rob+\" C: \"+cur);\n\t\t\tif(bfs.isEmpty())\n\t\t\t\tbreak;\n            // System.out.println(cur+\" \"+bfs);\n\t\t\tif (rob == null||v!=rob.x) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsb.append((cur.y + 1) + \" \" + (rob.y + 1) + \"\\n\");\n\t\t\tbfs.remove(rob);\n\t\t\tbfs.add(new pair(rob.x, rob.y, rob.lv + 1));\n\t\t}\n\t\tout.println(sb);\n\t\tout.flush();\n\t}\n\n\tstatic class pair implements Comparable<pair> {\n\t\tlong x;\n\t\tint y, lv;\n\n\t\tpair(long x, int y, int l) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tlv = l;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn x + \" \" + y + \" \" + lv;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(pair o) {\n\t\t\tif (x == o.x)\n\t\t\t\treturn y - o.y;\n\t\t\treturn Long.compare(o.x, x);\n\t\t}\n\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic int[] nextArrInt(int n) throws IOException {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextArrLong(int n) throws IOException {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic final Reader in = new Reader();\n\tstatic final PrintWriter out = new PrintWriter(System.out);\n\t\n\tpublic static void main(String[] args) {\n\t\tint n=in.nextInt();\n\t\tPair[] d = new Pair[n];\n\t\tint[] s1 = new int[n], p = new int[n];\n\t\tlong[] s2 = new long[n];\n\t\tMap<Long, Integer> mp = new HashMap<Long, Integer>();\n\t\tfor(int i=0; i<n; ++i) {\n\t\t\td[i] = new Pair(in.nextLong(), i);\n\t\t\tmp.put(d[i].a, i);\n\t\t\ts1[i]=1;\n\t\t}\n\t\tArrays.sort(d);\n\t\tfor(int i=0; i<n-1; ++i) {\n\t\t\tint u=d[i].b;\n\t\t\tp[u]=mp.getOrDefault(d[i].a-n+2*s1[u], -1);\n\t\t\tif(d[i].a-n+2*s1[u]>=d[i].a||p[u]==-1)\n\t\t\t\tfk();\n\t\t\ts1[p[u]]+=s1[u];\n\t\t\ts2[p[u]]+=s2[u]+s1[u];\n\t\t}\n\t\tif(s2[d[n-1].b]!=d[n-1].a)\n\t\t\tfk();\n\t\tfor(int i=0; i<n-1; ++i)\n\t\t\tout.println((d[i].b+1)+\" \"+(p[d[i].b]+1));\n\t\tout.close();\n\t}\n\t\n\tstatic void fk() {\n\t\tSystem.out.println(-1);\n\t\tSystem.exit(0);\n\t}\n\t\n\tstatic class Pair implements Comparable<Pair> {\n\t\tlong a;\n\t\tint b;\n\t\tPair(long a, int b) {\n\t\t\tthis.a=a;\n\t\t\tthis.b=b;\n\t\t}\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn -Long.compare(a, o.a);\n\t\t}\n\t}\n\t\n\tstatic class Reader {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st;\n\t\t\n\t\tString next() {\n\t\t\twhile(st==null||!st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch(Exception e) {}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\npublic class Main{\n\tstatic void main() throws Exception{\n\t\tint n=sc.nextInt();\n\t\tlong[][]in=new long[n][];\n\t\tHashMap<Long, Integer>map=new HashMap<>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tin[i]=new long[] {sc.nextLong(),i};\n\t\t\tmap.put(in[i][0], i);\n\t\t}\n\t\tArrays.sort(in,(x,y)->Long.compare(y[0], x[0]));\n\t\tint[]sub=new int[n];\n\t\tArrays.fill(sub, 1);\n\t\tStringBuilder ans=new StringBuilder();\n\t\tLinkedList<Integer>[]adj=new LinkedList[n];\n\t\tfor(int i=0;i<n;i++)adj[i]=new LinkedList<>();\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tlong D=in[i][0];int idx=(int)in[i][1];\n\t\t\tlong parD=D-(n-sub[idx]-1)+sub[idx]-1;\n\t\t\tif(parD==D || !map.containsKey(parD)) {\n\t\t\t\tpw.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint par=map.get(parD);\n\t\t\tsub[par]+=sub[idx];\n\t\t\tans.append((idx+1)+\" \"+(par+1)+'\\n');\n\t\t\tadj[idx].add(par);\n\t\t\tadj[par].add(idx);\n\t\t}\n\t\tboolean[]v=new boolean[n];\n\t\tLinkedList<Integer>q=new LinkedList<>();\n\t\tq.add(0);\n\t\tv[0]=true;\n\t\twhile(!q.isEmpty()) {\n\t\t\tint cur=q.poll();\n\t\t\tfor(int j:adj[cur]) {\n\t\t\t\tif(!v[j]) {\n\t\t\t\t\tv[j]=true;\n\t\t\t\t\tq.add(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif(!v[i]) {\n\t\t\t\tpw.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tpw.println(ans);\n\t}\n\tpublic static void main(String[] args) throws Exception{\n\t\tsc=new MScanner(System.in);\n\t\tpw = new PrintWriter(System.out);\n\t\tint tc=1;\n//\t\ttc=sc.nextInt();\n\t\twhile(tc-->0)\n\t\t\tmain();\n\t\tpw.flush();\n\t}\n\tstatic PrintWriter pw;\n\tstatic MScanner  sc;\n\tstatic class MScanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\t\tpublic MScanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n \n\t\tpublic MScanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tpublic int[] intArr(int n) throws IOException {\n\t        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n\t        return in;\n\t\t}\n\t\tpublic long[] longArr(int n) throws IOException {\n\t        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n\t        return in;\n\t\t}\n\t\tpublic int[] intSortedArr(int n) throws IOException {\n\t        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n\t        shuffle(in);\n\t        Arrays.sort(in);\n\t        return in;\n\t\t}\n\t\tpublic long[] longSortedArr(int n) throws IOException {\n\t        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n\t        shuffle(in);\n\t        Arrays.sort(in);\n\t        return in;\n\t\t}\n\t\tpublic Integer[] IntegerArr(int n) throws IOException {\n\t        Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n\t        return in;\n\t\t}\n\t\tpublic Long[] LongArr(int n) throws IOException {\n\t        Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n\t        return in;\n\t\t}\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n \n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n \n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n\tstatic void shuffle(int[]in) {\n\t\tfor(int i=0;i<in.length;i++) {\n\t\t\tint idx=(int)(Math.random()*in.length);\n\t\t\tint tmp=in[i];\n\t\t\tin[i]=in[idx];\n\t\t\tin[idx]=tmp;\n\t\t}\n\t}\n\tstatic void shuffle(long[]in) {\n\t\tfor(int i=0;i<in.length;i++) {\n\t\t\tint idx=(int)(Math.random()*in.length);\n\t\t\tlong tmp=in[i];\n\t\t\tin[i]=in[idx];\n\t\t\tin[idx]=tmp;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.TreeSet;\n\npublic class Main {\n  private static void solve() {\n    int n = ni();\n    long[][] d = new long[n][2];\n    for (int i = 0; i < n; i++) {\n      d[i][0] = i;\n      d[i][1] = nl();\n    }\n    Arrays.sort(d, (o1, o2) -> Long.signum(o1[1] - o2[1]));\n    TreeSet<long[]> map = new TreeSet<>((o1, o2) -> {\n      if (o1[1] == o2[1]) {\n        return Long.compare(o1[0], o2[0]);\n      } else {\n        return Long.compare(o1[1], o2[1]);\n      }\n    });\n    for (int i = 0; i < n; i++) {\n      map.add(d[i]);\n    }\n\n    long[] x = new long[n];\n    long[] y = new long[n];\n    Arrays.fill(x, 1);\n\n    long[][] e = new long[n - 1][2];\n    int ptr = 0;\n    for (int i = n - 1; i > 0; i --) {\n      long[] v = d[i];\n      map.remove(v);\n      long val = v[1] + 2 * x[(int)v[0]] - n;\n      long[] u = map.ceiling(new long[] {-1, val});\n      if (u != null && u[1] == val) {\n        e[ptr++] = new long[] {v[0] + 1, u[0] + 1};\n        x[(int)u[0]] += x[(int)v[0]];\n        y[(int)u[0]] += x[(int)v[0]] + y[(int)v[0]];\n      } else {\n        out.println(-1);\n        return;\n      }\n    }\n    \n    if (y[(int)d[0][0]] != d[0][1]) {\n      out.println(-1);\n      return;\n    }\n\n    for (long[] v : e) {\n      out.println(v[0] + \" \" + v[1]);\n    }\n  }\n  \n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tstatic PrintWriter out;\n\tstatic StringBuilder sb;\n\tstatic int n, m, k;\n\tstatic long mod = 998244353;\n\tstatic Boolean[][] memo;\n\tstatic String s;\n\tstatic ArrayList<Integer>[] ad;\n\tstatic long inf = Long.MAX_VALUE;\n\tstatic int[] color;\n\tstatic ArrayList<Integer> o;\n\tstatic char[][] g;\n\tstatic boolean[] vis, vis1;\n\tstatic boolean f;\n\tstatic long[] a, dest;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsb = new StringBuilder();\n\t\tn = sc.nextInt();\n\t\tTreeSet<pair> bfs = new TreeSet<>();\n\t\tlong[] arr = new long[n];\n\t\ta = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlong x = sc.nextLong();\n\t\t\tbfs.add(new pair(x, i, 0));\n\t\t\tarr[i] = x;\n\t\t}\n\t\tdest = new long[n];\n\t\tad = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tad[i] = new ArrayList<>();\n\t\twhile (!bfs.isEmpty()) {\n\t\t\tpair cur = bfs.pollFirst();\n\t\t\tint ext = cur.lv;\n\t\t\tlong v = cur.x - (n - 2) + 2 * ext;\n\t\t\tpair rob = bfs.ceiling(new pair(v, 0, 0));\n\t\t\t// System.out.println(v + \" G: \" + rob + \" C: \" + cur);\n\t\t\tif (bfs.isEmpty())\n\t\t\t\tbreak;\n\t\t\tif (rob == null || v != rob.x) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsb.append((cur.y + 1) + \" \" + (rob.y + 1) + \"\\n\");\n\t\t\tad[cur.y].add(rob.y);\n\t\t\tad[rob.y].add(cur.y);\n\t\t\tbfs.remove(rob);\n\t\t\tbfs.add(new pair(rob.x, rob.y, rob.lv + 1 + cur.lv));\n\t\t}\n\t\tdfs(0, -1);\n\t//\tSystem.out.println(Arrays.toString(a));\n\t\treroot(0, -1);\n//\t\tSystem.out.println(Arrays.toString(arr));\n\t//\tSystem.out.println(Arrays.toString(a));\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (arr[i] != a[i]) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\tout.println(sb);\n\t\tout.flush();\n\t}\n\n\tstatic void reroot(int u, int p) {\n\t\tif (p != -1) {\n\t\t\ta[u] += a[p] - (a[u] + dest[u]) + n - dest[u];\n\t\t}\n\t\tfor (int v : ad[u])\n\t\t\tif (v != p) {\n\t\t\t\treroot(v, u);\n\t\t\t}\n\t}\n\n\tstatic void dfs(int u, int p) {\n\t\tdest[u] = 1;\n\t\tfor (int v : ad[u])\n\t\t\tif (v != p) {\n\t\t\t\tdfs(v, u);\n\t\t\t\tdest[u] += dest[v];\n\t\t\t\ta[u] += a[v] + dest[v];\n\t\t\t}\n\t}\n\n\tstatic class pair implements Comparable<pair> {\n\t\tlong x;\n\t\tint y, lv;\n\n\t\tpair(long x, int y, int l) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tlv = l;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn x + \" \" + y + \" \" + lv;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(pair o) {\n\t\t\tif (x == o.x)\n\t\t\t\treturn y - o.y;\n\t\t\treturn Long.compare(o.x, x);\n\t\t}\n\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic int[] nextArrInt(int n) throws IOException {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextArrLong(int n) throws IOException {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\npublic class Main{\n\tstatic LinkedList<Integer>[]adj;\n\tstatic int[]sub;\n\tstatic long[]sumD,originD;\n\tstatic boolean[]v;\n\tstatic boolean yes;\n\tstatic void dfs(int i,int par) {\n\t\tv[i]=true;\n\t\tfor(int j:adj[i]) {\n\t\t\tif(j==par)continue;\n\t\t\tdfs(j, i);\n\t\t\tsumD[i]+=(sumD[j]+sub[j]);\n\t\t}\n\t}\n\tstatic void dfs2(int i,int par) {\n\t\tfor(int j:adj[i]) {\n\t\t\tif(j==par)continue;\n\t\t\trerooting(i, j);\n\t\t\tyes&=(originD[j]==sumD[j]);\n\t\t\tdfs2(j, i);\n\t\t\trerooting(j, i);\n\t\t}\n\t}\n\tstatic void rerooting(int from,int to) {\n\t\tint oldSubFrom=sub[from];\n\t\tint oldSubTo=sub[to];\n\t\tint newSubFrom=oldSubFrom-oldSubTo;\n\t\tint newSubTo=oldSubTo+newSubFrom;\n\t\tlong newSumDFrom=sumD[from]-(sumD[to]+oldSubTo);\n\t\tlong newSumDTo=sumD[to]+newSumDFrom+newSubFrom;\n\t\tsub[from]=newSubFrom;\n\t\tsub[to]=newSubTo;\n\t\tsumD[from]=newSumDFrom;\n\t\tsumD[to]=newSumDTo;\n\t}\n\tstatic void main() throws Exception{\n\t\tint n=sc.nextInt();\n\t\tlong[][]in=new long[n][];\n\t\toriginD=new long[n];\n\t\tHashMap<Long, Integer>map=new HashMap<>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tin[i]=new long[] {sc.nextLong(),i};\n\t\t\toriginD[i]=in[i][0];\n\t\t\tmap.put(in[i][0], i);\n\t\t}\n\t\tArrays.sort(in,(x,y)->Long.compare(y[0], x[0]));\n\t\tsub=new int[n];\n\t\tsumD=new long[n];\n\t\tArrays.fill(sub, 1);\n\t\tStringBuilder ans=new StringBuilder();\n\t\tadj=new LinkedList[n];\n\t\tfor(int i=0;i<n;i++)adj[i]=new LinkedList<>();\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tlong D=in[i][0];int idx=(int)in[i][1];\n\t\t\tlong parD=D-(n-sub[idx]-1)+sub[idx]-1;\n\t\t\tif(parD==D || !map.containsKey(parD)) {\n\t\t\t\tpw.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint par=map.get(parD);\n\t\t\tsub[par]+=sub[idx];\n\t\t\tans.append((idx+1)+\" \"+(par+1)+'\\n');\n\t\t\tadj[idx].add(par);\n\t\t\tadj[par].add(idx);\n\t\t}\n\t\tv=new boolean[n];\n\t\tint root=(int)in[n-1][1];\n\t\tdfs(root, -1);\n\t\tfor(boolean i:v) {\n\t\t\tif(!i) {\n\t\t\t\tpw.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tyes=sumD[root]==originD[root];\n\t\tdfs2(root, -1);\n\t\tif(!yes) {\n\t\t\tpw.println(-1);\n\t\t\treturn;\n\t\t}\n\t\tpw.println(ans);\n\t}\n\tpublic static void main(String[] args) throws Exception{\n\t\tsc=new MScanner(System.in);\n\t\tpw = new PrintWriter(System.out);\n\t\tint tc=1;\n//\t\ttc=sc.nextInt();\n\t\twhile(tc-->0)\n\t\t\tmain();\n\t\tpw.flush();\n\t}\n\tstatic PrintWriter pw;\n\tstatic MScanner  sc;\n\tstatic class MScanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\t\tpublic MScanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n \n\t\tpublic MScanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tpublic int[] intArr(int n) throws IOException {\n\t        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n\t        return in;\n\t\t}\n\t\tpublic long[] longArr(int n) throws IOException {\n\t        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n\t        return in;\n\t\t}\n\t\tpublic int[] intSortedArr(int n) throws IOException {\n\t        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n\t        shuffle(in);\n\t        Arrays.sort(in);\n\t        return in;\n\t\t}\n\t\tpublic long[] longSortedArr(int n) throws IOException {\n\t        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n\t        shuffle(in);\n\t        Arrays.sort(in);\n\t        return in;\n\t\t}\n\t\tpublic Integer[] IntegerArr(int n) throws IOException {\n\t        Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n\t        return in;\n\t\t}\n\t\tpublic Long[] LongArr(int n) throws IOException {\n\t        Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n\t        return in;\n\t\t}\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n \n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n \n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n\tstatic void shuffle(int[]in) {\n\t\tfor(int i=0;i<in.length;i++) {\n\t\t\tint idx=(int)(Math.random()*in.length);\n\t\t\tint tmp=in[i];\n\t\t\tin[i]=in[idx];\n\t\t\tin[idx]=tmp;\n\t\t}\n\t}\n\tstatic void shuffle(long[]in) {\n\t\tfor(int i=0;i<in.length;i++) {\n\t\t\tint idx=(int)(Math.random()*in.length);\n\t\t\tlong tmp=in[i];\n\t\t\tin[i]=in[idx];\n\t\t\tin[idx]=tmp;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.TreeSet;\n\npublic class Main {\n  private static void solve() {\n    int n = ni();\n    long[][] d = new long[n][2];\n    for (int i = 0; i < n; i++) {\n      d[i][0] = i;\n      d[i][1] = nl();\n    }\n    Arrays.sort(d, (o1, o2) -> Long.signum(o1[1] - o2[1]));\n    TreeSet<long[]> map = new TreeSet<>((o1, o2) -> {\n      if (o1[1] == o2[1]) {\n        return Long.compare(o1[0], o2[0]);\n      } else {\n        return Long.compare(o1[1], o2[1]);\n      }\n    });\n    for (int i = 0; i < n; i++) {\n      map.add(d[i]);\n    }\n\n    long[] x = new long[n];\n    Arrays.fill(x, 1);\n\n    long[][] e = new long[n - 1][2];\n    int ptr = 0;\n    for (int i = n - 1; i > 0; i--) {\n      map.remove(d[i]);\n      long v = d[i][1] + 2 * x[(int)d[i][0]] - n;\n      long[] u = map.ceiling(new long[] {-1, v});\n      if (u != null && u[1] == v) {\n        e[ptr++] = new long[] {d[i][0] + 1, u[0] + 1};\n        x[(int)u[0]] += x[(int)d[i][0]];\n      } else {\n        out.println(-1);\n        return;\n      }\n    }\n\n    for (long[] v : e) {\n      out.println(v[0] + \" \" + v[1]);\n    }\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "// package arc.arc103;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n    static long __startTime = System.currentTimeMillis();\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        long[][] d = new long[n][2];\n        for (int i = 0; i < n ; i++) {\n            d[i][0] = in.nextLong();\n            d[i][1] = i;\n        }\n        Arrays.sort(d, (u, v) -> Long.compare(v[0], u[0]));\n\n        List<int[]> tree = new ArrayList<>();\n\n        Map<Long,List<int[]>> roots = new TreeMap<>();\n        for (int i = 0; i < n-1 ; i++) {\n            long value = d[i][0];\n            int id = (int)d[i][1];\n\n            long nv = value-(n-2);\n            int totalN = 1;\n            if (roots.size() == 0 || !roots.containsKey(value)) {\n            } else {\n                for (int[] px : roots.get(value)) {\n                    tree.add(new int[]{id, px[0]});\n                    totalN += px[1];\n                }\n                nv = value-(n-(totalN+1));\n                roots.remove(value);\n            }\n\n            if (roots.containsKey(nv)) {\n                roots.get(value).add(new int[]{id, totalN});\n            } else {\n                List<int[]> x = new ArrayList<>();\n                x.add(new int[]{id, totalN});\n                roots.put(nv, x);\n            }\n\n        }\n\n        if (roots.size() >= 2) {\n            out.println(-1);\n        } else {\n            int lid = (int)d[n-1][1];\n            for (long lk : roots.keySet()) {\n                if (d[n-1][0] != lk) {\n                    out.println(-1);\n                    out.flush();\n                    return;\n                }\n                for (int[] w : roots.get(lk)) {\n                    tree.add(new int[]{lid, w[0]});\n                }\n            }\n            for (int[] e : tree) {\n                out.println(String.format(\"%d %d\", e[0]+1, e[1]+1));\n            }\n        }\n        out.flush();\n    }\n\n    private static List<int[]> solve(char[] s) {\n        int n = s.length-1;\n        if (s[n] == '1') {\n            return null;\n        }\n        if (s[1] == '0') {\n            return null;\n        }\n\n        for (int i = 1 ; i <= n-1 ; i++) {\n            if (s[i] != s[n-i]) {\n                return null;\n            }\n        }\n\n        List<int[]> tree = new ArrayList<>();\n        int lcnt = 0;\n        for (int i = 1 ; i <= n-1 ; i++) {\n            lcnt += s[i]-'0';\n        }\n        if (lcnt == n-1) {\n            for (int i = 0; i < n-1; i++) {\n                tree.add(new int[]{i, i+1});\n            }\n            return tree;\n        }\n\n        if (lcnt == 2) {\n            for (int i = 1 ; i <= n-1; i++) {\n                tree.add(new int[]{0, i});\n            }\n            return tree;\n        }\n\n        // 12345678\n        // 10101010\n\n        int last = 0;\n        int rt = -1;\n        for (int v = 2 ; v <= n/2 ; v++) {\n            if (s[v] == '1') {\n                int diff = v - last;\n                int nroot = getId(1)[0];\n                if (rt != -1) {\n                    tree.add(new int[]{rt, nroot});\n                }\n                if (diff >= 2) {\n                    int[] ww = getId(diff-1);\n                    for (int i = 0; i < ww.length; i++) {\n                        tree.add(new int[]{nroot, ww[i]});\n                    }\n                }\n                last = v;\n                rt = nroot;\n\n                debug(v, rt, last);\n            }\n        }\n\n        int nrt = getId(1)[0];\n        tree.add(new int[]{rt, nrt});\n        rt = nrt;\n\n        while (true) {\n            int nid = getId(1)[0];\n            if (nid >= n) {\n                break;\n            }\n            tree.add(new int[]{rt, nid});\n        }\n        for (int i = 0; i < n ; i++) {\n            \n        }\n        \n        return tree;\n    }\n\n\n    static int nid = 0;\n    static int[] getId(int want) {\n        int[] w = new int[want];\n        for (int i = 0; i < want ; i++) {\n            w[i] = nid++;\n        }\n        return w;\n    }\n\n    private static void printTime(String label) {\n        debug(label, System.currentTimeMillis() - __startTime);\n    }\n\n    private static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic final Reader in = new Reader();\n\tstatic final PrintWriter out = new PrintWriter(System.out);\n\t\n\tpublic static void main(String[] args) {\n\t\tint n=in.nextInt();\n\t\tPair[] d = new Pair[n];\n\t\tint[] s = new int[n], p = new int[n];\n\t\tMap<Long, Integer> mp = new HashMap<Long, Integer>();\n\t\tfor(int i=0; i<n; ++i) {\n\t\t\td[i] = new Pair(in.nextLong(), i);\n\t\t\tmp.put(d[i].a, i);\n\t\t\ts[i]=1;\n\t\t}\n\t\tArrays.sort(d);\n\t\tfor(int i=0; i<n-1; ++i) {\n\t\t\tint u=d[i].b;\n\t\t\tp[u]=mp.getOrDefault(d[i].a-n+2*s[u], -1);\n\t\t\tif(d[i].a-n+2*s[u]>=d[i].a||p[u]==-1) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ts[p[u]]+=s[u];\n\t\t}\n\t\tfor(int i=1; i<n; ++i)\n\t\t\tout.println((i+1)+\" \"+(p[i]+1));\n\t\tout.close();\n\t}\n\t\n\tstatic class Pair implements Comparable<Pair> {\n\t\tlong a;\n\t\tint b;\n\t\tPair(long a, int b) {\n\t\t\tthis.a=a;\n\t\t\tthis.b=b;\n\t\t}\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn -Long.compare(a, o.a);\n\t\t}\n\t}\n\t\n\tstatic class Reader {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st;\n\t\t\n\t\tString next() {\n\t\t\twhile(st==null||!st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch(Exception e) {}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.Map.Entry;\nimport java.util.stream.Collectors;\n\nclass Main {\n    public static void main(String[] args) throws Exception {\n        Map<Integer, Long> G = new HashMap<Integer, Long>();\n        Map<Integer, Integer> V = new HashMap<Integer, Integer>();\n        final Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        Pair[] d = new Pair[N+1];\n        int[] n = new int[N+1];\n        long[] m = new long[N+1];\n        int i = 0, flag = 0;\n        for(i = 1 ; i <= N ; i++){\n            G.put(i, sc.nextLong());\n            n[i] = 1;\n        }\n        G = G.entrySet().stream()\n        .sorted(Entry.<Integer, Long>comparingByValue().reversed())\n        .collect(Collectors.toMap(Entry::getKey,Entry::getValue,(e1, e2)->e1,LinkedHashMap::new));\n        i = 1;\n        for (int key : G.keySet()){\n            d[i] = new Pair(key, G.get(key));\n            i++;\n        }\n        for(i = 1 ; i < N ; i++){\n            flag = 0;\n            for(int j = i+1 ; j <= N ; j++){\n                if(d[i].b-(long)N+(long)(2*n[i]) == d[j].b){\n                    n[j] += n[i];\n                    m[j] += n[i]+m[i];\n                    V.put(d[i].a, d[j].a);\n                    flag = 1;\n                    break;\n                }\n            }\n            if(flag == 0){\n                System.out.println(\"-1\");\n                System.exit(0);\n            }\n        }\n        if(m[N]!=d[N].b){\n            System.out.println(\"-1\");\n            System.exit(0);\n        }\n        for (Integer key : V.keySet()) {\n            System.out.println(key + \" \" + V.get(key));\n        }\n    }\n\n    static class Pair implements Comparable<Pair> {\n        int a;\n        long b;\n        Pair(int a,long b) {\n            this.a = a;\n            this.b = b;\n        }    \n        @Override\n        public int compareTo(Pair o) {\n            return Long.compare(a, o.b);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic PrintWriter out;\n\tstatic StringBuilder sb;\n\tstatic int n, m, k;\n\tstatic long mod = 998244353;\n\tstatic Boolean[][] memo;\n\tstatic String s;\n\tstatic int[][] ad;\n\tstatic long inf = Long.MAX_VALUE;\n\tstatic int[] color;\n\tstatic ArrayList<Integer> o;\n\tstatic char[][] g;\n\tstatic boolean[] vis, vis1;\n\tstatic boolean f;\n\tstatic int[] ar, a;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsb = new StringBuilder();\n\t\tn = sc.nextInt();\n\t\tTreeSet<pair> bfs = new TreeSet<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tbfs.add(new pair(sc.nextLong(), i, 0));\n\t\t}\n\t\twhile (!bfs.isEmpty()) {\n\t\t\tpair cur = bfs.pollFirst();\n\t\t\tint ext = cur.lv;\n\t\t\tlong v = cur.x - (n - 2) + 2 * ext;\n\t\t\tpair rob = bfs.ceiling(new pair(v, 0, 0));\n\t\t//\tSystem.out.println(v + \" G: \" + rob + \" C: \" + cur);\n\t\t\tif (bfs.isEmpty())\n\t\t\t\tbreak;\n\t\t\tif (rob == null || v != rob.x) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsb.append((cur.y + 1) + \" \" + (rob.y + 1) + \"\\n\");\n\t\t\tbfs.remove(rob);\n\t\t\tbfs.add(new pair(rob.x, rob.y, rob.lv +1+ cur.lv));\n\t\t}\n\t\tout.println(sb);\n\t\tout.flush();\n\t}\n\n\tstatic class pair implements Comparable<pair> {\n\t\tlong x;\n\t\tint y, lv;\n\n\t\tpair(long x, int y, int l) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tlv = l;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn x + \" \" + y + \" \" + lv;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(pair o) {\n\t\t\tif (x == o.x)\n\t\t\t\treturn y - o.y;\n\t\t\treturn Long.compare(o.x, x);\n\t\t}\n\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic int[] nextArrInt(int n) throws IOException {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextArrLong(int n) throws IOException {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            FDistanceSums solver = new FDistanceSums();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class FDistanceSums {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            long[] d = new long[n];\n            for (int i = 0; i < n; i++) {\n                d[i] = in.readLong();\n            }\n\n\n            LongObjectHashMap<Node> map = new LongObjectHashMap<>(n, false);\n            Node[] nodes = new Node[n];\n            for (int i = 0; i < n; i++) {\n                nodes[i] = new Node();\n                nodes[i].id = i;\n                nodes[i].di = d[i];\n                nodes[i].size = 1;\n                map.put(d[i], nodes[i]);\n            }\n\n\n            List<int[]> edges = new ArrayList<>(n - 1);\n            Arrays.sort(nodes, (a, b) -> -Long.compare(a.di, b.di));\n            for (int i = 0; i < n - 1; i++) {\n                Node p = map.get(nodes[i].di + nodes[i].size * 2 - n);\n                if (p == null) {\n                    out.println(-1);\n                    return;\n                }\n                edges.add(new int[]{p.id, nodes[i].id});\n                p.next.add(nodes[i]);\n                p.size += nodes[i].size;\n            }\n\n            if (dfs(nodes[n - 1]) != nodes[n - 1].di) {\n                out.println(-1);\n                return;\n            }\n\n            for (int[] e : edges) {\n                out.append(e[0] + 1).append(' ').append(e[1] + 1).println();\n            }\n        }\n\n        public long dfs(Node root) {\n            long ans = 0;\n            for (Node node : root.next) {\n                ans += dfs(node) + node.size;\n            }\n            return ans;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 20];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public long readLong() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            long val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class LongObjectHashMap<V> {\n        private int[] slot;\n        private int[] next;\n        private long[] keys;\n        private Object[] values;\n        private int alloc;\n        private boolean[] removed;\n        private int mask;\n        private int size;\n        private boolean rehash;\n        private Hasher hasher = new Hasher();\n\n        public LongObjectHashMap(int cap, boolean rehash) {\n            this.mask = (1 << (32 - Integer.numberOfLeadingZeros(cap - 1))) - 1;\n            slot = new int[mask + 1];\n            next = new int[cap + 1];\n            keys = new long[cap + 1];\n            values = new Object[cap + 1];\n            removed = new boolean[cap + 1];\n            this.rehash = rehash;\n        }\n\n        private void doubleCapacity() {\n            int newSize = Math.max(next.length + 10, next.length * 2);\n            next = Arrays.copyOf(next, newSize);\n            keys = Arrays.copyOf(keys, newSize);\n            values = Arrays.copyOf(values, newSize);\n            removed = Arrays.copyOf(removed, newSize);\n        }\n\n        private void rehash() {\n            int[] newSlots = new int[Math.max(16, slot.length * 2)];\n            int newMask = newSlots.length - 1;\n            for (int i = 0; i < slot.length; i++) {\n                if (slot[i] == 0) {\n                    continue;\n                }\n                int head = slot[i];\n                while (head != 0) {\n                    int n = next[head];\n                    int s = hash(keys[head]) & newMask;\n                    next[head] = newSlots[s];\n                    newSlots[s] = head;\n                    head = n;\n                }\n            }\n            this.slot = newSlots;\n            this.mask = newMask;\n        }\n\n        public void alloc() {\n            alloc++;\n            if (alloc >= next.length) {\n                doubleCapacity();\n            }\n            next[alloc] = 0;\n            removed[alloc] = false;\n            values[alloc] = null;\n            size++;\n        }\n\n        private int hash(long x) {\n            return hasher.hash(x);\n        }\n\n        public void put(long x, V y) {\n            int h = hash(x);\n            int s = h & mask;\n            if (slot[s] == 0) {\n                alloc();\n                slot[s] = alloc;\n                keys[alloc] = x;\n                values[alloc] = y;\n            } else {\n                int index = findIndexOrLastEntry(s, x);\n                if (keys[index] != x) {\n                    alloc();\n                    next[index] = alloc;\n                    keys[alloc] = x;\n                    values[alloc] = y;\n                } else {\n                    values[index] = y;\n                }\n            }\n            if (rehash && size >= slot.length) {\n                rehash();\n            }\n        }\n\n        public V getOrDefault(long x, V def) {\n            int h = hash(x);\n            int s = h & mask;\n            if (slot[s] == 0) {\n                return def;\n            }\n            int index = findIndexOrLastEntry(s, x);\n            return keys[index] == x ? (V) values[index] : def;\n        }\n\n        public V get(long x) {\n            return getOrDefault(x, null);\n        }\n\n        private int findIndexOrLastEntry(int s, long x) {\n            int iter = slot[s];\n            while (keys[iter] != x) {\n                if (next[iter] != 0) {\n                    iter = next[iter];\n                } else {\n                    return iter;\n                }\n            }\n            return iter;\n        }\n\n        public LongObjectEntryIterator<V> iterator() {\n            return new LongObjectEntryIterator() {\n                int index = 1;\n                int readIndex = -1;\n\n\n                public boolean hasNext() {\n                    while (index <= alloc && removed[index]) {\n                        index++;\n                    }\n                    return index <= alloc;\n                }\n\n\n                public long getEntryKey() {\n                    return keys[readIndex];\n                }\n\n\n                public Object getEntryValue() {\n                    return values[readIndex];\n                }\n\n\n                public void next() {\n                    if (!hasNext()) {\n                        throw new IllegalStateException();\n                    }\n                    readIndex = index;\n                    index++;\n                }\n            };\n        }\n\n        public String toString() {\n            LongObjectEntryIterator<V> iterator = iterator();\n            StringBuilder builder = new StringBuilder(\"{\");\n            while (iterator.hasNext()) {\n                iterator.next();\n                builder.append(iterator.getEntryKey()).append(\"->\").append(iterator.getEntryValue()).append(',');\n            }\n            if (builder.charAt(builder.length() - 1) == ',') {\n                builder.setLength(builder.length() - 1);\n            }\n            builder.append('}');\n            return builder.toString();\n        }\n\n    }\n\n    static class Hasher {\n        private long time = System.nanoTime() + System.currentTimeMillis();\n\n        private int shuffle(long x) {\n            x += time;\n            x += 0x9e3779b97f4a7c15L;\n            x = (x ^ (x >>> 30)) * 0xbf58476d1ce4e5b9L;\n            x = (x ^ (x >>> 27)) * 0x94d049bb133111ebL;\n            return (int) (x ^ (x >>> 31));\n        }\n\n        public int hash(long x) {\n            return shuffle(x);\n        }\n\n    }\n\n    static interface LongObjectEntryIterator<V> {\n        boolean hasNext();\n\n        void next();\n\n        long getEntryKey();\n\n        V getEntryValue();\n\n    }\n\n    static class Node {\n        long di;\n        int size;\n        int id;\n        List<Node> next = new ArrayList<>();\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            FDistanceSums solver = new FDistanceSums();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class FDistanceSums {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            long[] d = new long[n];\n            for (int i = 0; i < n; i++) {\n                d[i] = in.readLong();\n            }\n\n\n            LongObjectHashMap<Node> map = new LongObjectHashMap<>(n, false);\n            Node[] nodes = new Node[n];\n            for (int i = 0; i < n; i++) {\n                nodes[i] = new Node();\n                nodes[i].id = i;\n                nodes[i].di = d[i];\n                nodes[i].size = 1;\n                map.put(d[i], nodes[i]);\n            }\n\n\n            List<int[]> edges = new ArrayList<>(n - 1);\n            Arrays.sort(nodes, (a, b) -> -Long.compare(a.di, b.di));\n            for (int i = 0; i < n - 1; i++) {\n                Node p = map.get(nodes[i].di + nodes[i].size * 2 - n);\n                if (p == null) {\n                    out.println(-1);\n                    return;\n                }\n                edges.add(new int[]{p.id, nodes[i].id});\n                p.size += nodes[i].size;\n            }\n\n            for (int[] e : edges) {\n                out.append(e[0] + 1).append(' ').append(e[1] + 1).println();\n            }\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 20];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public long readLong() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            long val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class LongObjectHashMap<V> {\n        private int[] slot;\n        private int[] next;\n        private long[] keys;\n        private Object[] values;\n        private int alloc;\n        private boolean[] removed;\n        private int mask;\n        private int size;\n        private boolean rehash;\n        private Hasher hasher = new Hasher();\n\n        public LongObjectHashMap(int cap, boolean rehash) {\n            this.mask = (1 << (32 - Integer.numberOfLeadingZeros(cap - 1))) - 1;\n            slot = new int[mask + 1];\n            next = new int[cap + 1];\n            keys = new long[cap + 1];\n            values = new Object[cap + 1];\n            removed = new boolean[cap + 1];\n            this.rehash = rehash;\n        }\n\n        private void doubleCapacity() {\n            int newSize = Math.max(next.length + 10, next.length * 2);\n            next = Arrays.copyOf(next, newSize);\n            keys = Arrays.copyOf(keys, newSize);\n            values = Arrays.copyOf(values, newSize);\n            removed = Arrays.copyOf(removed, newSize);\n        }\n\n        private void rehash() {\n            int[] newSlots = new int[Math.max(16, slot.length * 2)];\n            int newMask = newSlots.length - 1;\n            for (int i = 0; i < slot.length; i++) {\n                if (slot[i] == 0) {\n                    continue;\n                }\n                int head = slot[i];\n                while (head != 0) {\n                    int n = next[head];\n                    int s = hash(keys[head]) & newMask;\n                    next[head] = newSlots[s];\n                    newSlots[s] = head;\n                    head = n;\n                }\n            }\n            this.slot = newSlots;\n            this.mask = newMask;\n        }\n\n        public void alloc() {\n            alloc++;\n            if (alloc >= next.length) {\n                doubleCapacity();\n            }\n            next[alloc] = 0;\n            removed[alloc] = false;\n            values[alloc] = null;\n            size++;\n        }\n\n        private int hash(long x) {\n            return hasher.hash(x);\n        }\n\n        public void put(long x, V y) {\n            int h = hash(x);\n            int s = h & mask;\n            if (slot[s] == 0) {\n                alloc();\n                slot[s] = alloc;\n                keys[alloc] = x;\n                values[alloc] = y;\n            } else {\n                int index = findIndexOrLastEntry(s, x);\n                if (keys[index] != x) {\n                    alloc();\n                    next[index] = alloc;\n                    keys[alloc] = x;\n                    values[alloc] = y;\n                } else {\n                    values[index] = y;\n                }\n            }\n            if (rehash && size >= slot.length) {\n                rehash();\n            }\n        }\n\n        public V getOrDefault(long x, V def) {\n            int h = hash(x);\n            int s = h & mask;\n            if (slot[s] == 0) {\n                return def;\n            }\n            int index = findIndexOrLastEntry(s, x);\n            return keys[index] == x ? (V) values[index] : def;\n        }\n\n        public V get(long x) {\n            return getOrDefault(x, null);\n        }\n\n        private int findIndexOrLastEntry(int s, long x) {\n            int iter = slot[s];\n            while (keys[iter] != x) {\n                if (next[iter] != 0) {\n                    iter = next[iter];\n                } else {\n                    return iter;\n                }\n            }\n            return iter;\n        }\n\n        public LongObjectEntryIterator<V> iterator() {\n            return new LongObjectEntryIterator() {\n                int index = 1;\n                int readIndex = -1;\n\n\n                public boolean hasNext() {\n                    while (index <= alloc && removed[index]) {\n                        index++;\n                    }\n                    return index <= alloc;\n                }\n\n\n                public long getEntryKey() {\n                    return keys[readIndex];\n                }\n\n\n                public Object getEntryValue() {\n                    return values[readIndex];\n                }\n\n\n                public void next() {\n                    if (!hasNext()) {\n                        throw new IllegalStateException();\n                    }\n                    readIndex = index;\n                    index++;\n                }\n            };\n        }\n\n        public String toString() {\n            LongObjectEntryIterator<V> iterator = iterator();\n            StringBuilder builder = new StringBuilder(\"{\");\n            while (iterator.hasNext()) {\n                iterator.next();\n                builder.append(iterator.getEntryKey()).append(\"->\").append(iterator.getEntryValue()).append(',');\n            }\n            if (builder.charAt(builder.length() - 1) == ',') {\n                builder.setLength(builder.length() - 1);\n            }\n            builder.append('}');\n            return builder.toString();\n        }\n\n    }\n\n    static interface LongObjectEntryIterator<V> {\n        boolean hasNext();\n\n        void next();\n\n        long getEntryKey();\n\n        V getEntryValue();\n\n    }\n\n    static class Hasher {\n        private long time = System.nanoTime() + System.currentTimeMillis();\n\n        private int shuffle(long x) {\n            x += time;\n            x += 0x9e3779b97f4a7c15L;\n            x = (x ^ (x >>> 30)) * 0xbf58476d1ce4e5b9L;\n            x = (x ^ (x >>> 27)) * 0x94d049bb133111ebL;\n            return (int) (x ^ (x >>> 31));\n        }\n\n        public int hash(long x) {\n            return shuffle(x);\n        }\n\n    }\n\n    static class Node {\n        long di;\n        int size;\n        int id;\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic PrintWriter out;\n\tstatic StringBuilder sb;\n\tstatic int n, m, k;\n\tstatic long mod = 998244353;\n\tstatic Boolean[][] memo;\n\tstatic String s;\n\tstatic int[][] ad;\n\tstatic long inf = Long.MAX_VALUE;\n\tstatic int[] color;\n\tstatic ArrayList<Integer> o;\n\tstatic char[][] g;\n\tstatic boolean[] vis, vis1;\n\tstatic boolean f;\n\tstatic int[] ar, a;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsb = new StringBuilder();\n\t\tn = sc.nextInt();\n\t\tTreeSet<pair> bfs = new TreeSet<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tbfs.add(new pair(sc.nextLong(), i, 0));\n\t\t}\n\t\twhile (!bfs.isEmpty()) {\n\t\t\tpair cur = bfs.pollFirst();\n\t\t\tint ext = cur.lv;\n\t\t\tlong v = cur.x - (n - 2 ) + 2*ext;\n\t\t\tpair rob = bfs.ceiling(new pair(v, 0, 0));\n\t\t//\tSystem.out.println(v + \" G: \" + rob+\" C: \"+cur);\n\t\t\tif(bfs.isEmpty())\n\t\t\t\tbreak;\n            // System.out.println(cur+\" \"+bfs);\n\t\t\tif (rob == null||v!=rob.x) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsb.append((cur.y + 1) + \" \" + (rob.y + 1) + \"\\n\");\n\t\t\tbfs.remove(rob);\n\t\t\tbfs.add(new pair(rob.x, rob.y, cur.lv + 1));\n\t\t}\n\t\tout.println(sb);\n\t\tout.flush();\n\t}\n\n\tstatic class pair implements Comparable<pair> {\n\t\tlong x;\n\t\tint y, lv;\n\n\t\tpair(long x, int y, int l) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tlv = l;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn x + \" \" + y + \" \" + lv;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(pair o) {\n\t\t\tif (x == o.x)\n\t\t\t\treturn y - o.y;\n\t\t\treturn Long.compare(o.x, x);\n\t\t}\n\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic int[] nextArrInt(int n) throws IOException {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextArrLong(int n) throws IOException {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.NoSuchElementException;\nimport java.util.PrimitiveIterator;\nimport java.util.function.DoubleUnaryOperator;\nimport java.util.function.IntBinaryOperator;\nimport java.util.function.IntFunction;\nimport java.util.function.IntPredicate;\nimport java.util.function.IntSupplier;\nimport java.util.function.IntUnaryOperator;\nimport java.util.function.LongUnaryOperator;\n\n\npublic class Main {\n    public static void main(String[] args) {\n        StringBuilder out = new StringBuilder();\n        solve(out);\n        PrintWriter pw = new PrintWriter(System.out);\n        pw.println(out);\n        pw.flush();\n        pw.close();\n    }\n\n    public static void solve(StringBuilder out) {\n        int n = In.ni();\n        long[] d = In.nl(n);\n        int[] idx = IntArrayGenerator.indexToInt(n, i -> i);\n        DependentSort.sortDescending(d, idx);\n        HashMap<Long, Integer> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            map.put(d[i], i);\n        }\n        IntArrayList[] ch = new IntArrayList[n];\n        for (int i = 0; i < n; i++) {\n            ch[i] = new IntArrayList();\n        }\n        for (int v = 0; v < n - 1; v++) {\n            long s = 0;\n            for (int i : ch[v]) {\n                s += (long) n - d[i] + d[v];\n            }\n            long du = s + d[v] - (n - 2);\n            if (du >= d[v]) {\n                out.append(-1);\n                return;\n            } else if (map.containsKey(du)) {\n                ch[map.get(du)].add(v);\n            } else {\n                out.append(-1);\n                return;\n            }\n        }\n        int[] p = new int[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = idx[i];\n        }\n        for (int u = 0; u < n; u++) {\n            for (int v : ch[u]) {\n                out.append(p[u] + 1).append(' ').append(p[v] + 1).append('\\n');\n            }\n        }\n    }\n}\n\nfinal class InsertionSort {\n    protected static void sort(final int[] a) {\n        sort(a, 0, a.length);\n    }\n\n    protected static void sort(final int[] a, final int from, final int to) {\n        for (int i = from + 1; i < to; i++) {\n            final int tmp = a[i];\n            if (a[i - 1] > tmp) {\n                int j = i;\n                do {\n                    a[j] = a[j - 1];\n                    j--;\n                } while (j > from && a[j - 1] > tmp);\n                a[j] = tmp;\n            }\n        }\n    }\n\n    protected static void sort(final long[] a) {\n        sort(a, 0, a.length);\n    }\n\n    protected static void sort(final long[] a, final int from, final int to) {\n        for (int i = from + 1; i < to; i++) {\n            final long tmp = a[i];\n            if (a[i - 1] > tmp) {\n                int j = i;\n                do {\n                    a[j] = a[j - 1];\n                    j--;\n                } while (j > from && a[j - 1] > tmp);\n                a[j] = tmp;\n            }\n        }\n    }\n}\n\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class IntArrayList implements Iterable<Integer> {\n    private int[] a;\n    private int tail = 0;\n\n    private static final int DEFAULT_SIZE = 64;\n\n    public IntArrayList(final int capacity) {\n        this.a = new int[Math.max(1, capacity)];\n    }\n\n    public IntArrayList() {\n        this(DEFAULT_SIZE);\n    }\n\n    public void add(final int v) {\n        if (tail == a.length) {\n            resize(2);\n        }\n        a[tail++] = v;\n    }\n\n    public int removeLast() {\n        return a[tail--];\n    }\n\n    public int get(final int i) {\n        if (i >= this.tail) {\n            System.err.println(\"Error in IntArrayList::get(\" + i + \"): ArrayIndexOutOfBounds. list size = \" + tail);\n        }\n        return a[i];\n    }\n\n    public void set(final int i, final int v) {\n        if (i >= this.tail) {\n            System.err.println(\"Error in IntArrayList::set(\" + i + \"): ArrayIndexOutOfBounds. list size = \" + tail);\n        }\n        a[i] = v;\n    }\n\n    private void resize(final double grow) {\n        final int[] b = new int[(int) Math.ceil(a.length * grow)];\n        System.arraycopy(a, 0, b, 0, a.length);\n        a = b;\n    }\n\n    public int size() {\n        return tail;\n    }\n\n    public void reverse(final int begin, final int end) {\n        IntArrays.reverse(a, begin, end);\n    }\n\n    public void reverse() {\n        IntArrays.reverse(a, 0, tail);\n    }\n\n    public int[] toArray() {\n        final int[] ret = new int[tail];\n        System.arraycopy(a, 0, ret, 0, tail);\n        return ret;\n    }\n\n    public boolean addIf(final int v, final IntPredicate p) {\n        if (p.test(v)) {\n            add(v);\n            return true;\n        }\n        return false;\n    }\n\n    public PrimitiveIterator.OfInt iterator() {\n        return new IntArrayListIterator();\n    }\n\n    private class IntArrayListIterator implements PrimitiveIterator.OfInt {\n        private int i = 0;\n\n        public boolean hasNext() {\n            return i < tail;\n        }\n\n        public int nextInt() {\n            return a[i++];\n        }\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class RadixSort {\n    private static final int INT_INSERTION_SORT_THRESHOLD = 120;\n    private static final int LONG_INSERTION_SORT_THRESHOLD = 250;\n\n    private static final int BUCKET_SIZE = 256;\n    private static final int BUCKET_HALF_SIZE = 128;\n    private static final int INT_RECURSION = 4;\n    private static final int LONG_RECURSION = 8;\n    private static final int SHIFT = 3;\n    private static final int MASK = 0xff;\n\n    public static void sort(final int[] a) {\n        sort(a, 0, a.length);\n    }\n\n    public static void sortDescending(final int[] a) {\n        sortDescending(a, 0, a.length);\n    }\n\n    public static void sort(final int[] a, final int from, final int to) {\n        if (to - from <= INT_INSERTION_SORT_THRESHOLD) {\n            InsertionSort.sort(a, from, to);\n            return;\n        }\n        final int len = to - from;\n        final int[] bucket = new int[len];\n        final int[] cnt = new int[BUCKET_SIZE + 1];\n        for (int l = 0;;) {\n            final int shift = l << SHIFT;\n            for (int i = from; i < to; i++) {\n                cnt[((a[i] >>> shift) & MASK) + 1]++;\n            }\n            for (int i = 0, j = 1; i < BUCKET_SIZE; i = j, j++) {\n                cnt[j] += cnt[i];\n            }\n            final int positive = cnt[BUCKET_HALF_SIZE];\n            for (int i = from; i < to; i++) {\n                final int v = a[i];\n                bucket[cnt[(v >>> shift) & MASK]++] = v;\n            }\n            if (++l == INT_RECURSION) {\n                final int negative = len - positive;\n                System.arraycopy(bucket, positive, a, from, negative);\n                System.arraycopy(bucket, 0, a, from + negative, positive);\n                return;\n            }\n            System.arraycopy(bucket, 0, a, from, len);\n            Arrays.fill(cnt, 0);\n        }\n    }\n\n    public static void sortDescending(final int[] a, final int from, final int to) {\n        sort(a, from, to);\n        int l = from, r = to - 1;\n        while (l < r) {\n            final int tmp = a[l];\n            a[l] = a[r];\n            a[r] = tmp;\n            l++;\n            r--;\n        }\n    }\n\n    public static void sort(final long[] a) {\n        sort(a, 0, a.length);\n    }\n\n    public static void sortDescending(final long[] a) {\n        sortDescending(a, 0, a.length);\n    }\n\n    public static void sort(final long[] a, final int from, final int to) {\n        if (to - from <= LONG_INSERTION_SORT_THRESHOLD) {\n            InsertionSort.sort(a, from, to);\n            return;\n        }\n        final int len = to - from;\n        final long[] bucket = new long[len];\n        final int[] cnt = new int[BUCKET_SIZE + 1];\n        for (int l = 0;;) {\n            final int shift = l << SHIFT;\n            for (int i = from; i < to; i++) {\n                cnt[(int) (((a[i] >>> shift) & MASK) + 1)]++;\n            }\n            for (int i = 0, j = 1; i < BUCKET_SIZE; i = j, j++) {\n                cnt[j] += cnt[i];\n            }\n            final int positive = cnt[BUCKET_HALF_SIZE];\n            for (int i = from; i < to; i++) {\n                final int bi = (int) ((a[i] >>> shift) & MASK);\n                bucket[cnt[bi]++] = a[i];\n            }\n            if (++l == LONG_RECURSION) {\n                final int negative = len - positive;\n                System.arraycopy(bucket, positive, a, from, negative);\n                System.arraycopy(bucket, 0, a, from + negative, positive);\n                return;\n            }\n            System.arraycopy(bucket, 0, a, from, len);\n            Arrays.fill(cnt, 0);\n        }\n    }\n\n    public static void sortDescending(final long[] a, final int from, final int to) {\n        sort(a, from, to);\n        int l = from, r = to - 1;\n        while (l < r) {\n            final long tmp = a[l];\n            a[l] = a[r];\n            a[r] = tmp;\n            l++; r--;\n        }\n    }\n}\n\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n * \n * (NON-DESTRUCTIVE) methods that returns int array.\n */\nfinal class IntArrayGenerator {\n\n    private IntArrayGenerator(){}\n    \n    public static int[] filled(final int n, final int init) {\n        final int[] ret = new int[n];\n        Arrays.fill(ret, init);\n        return ret;\n    }\n\n    public static int[][] filled(final int n, final int m, final int init) {\n        final int[][] ret = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(ret[i], init);\n        }\n        return ret;\n    }\n\n    public static int[] generate(final int n, final IntSupplier f) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, i -> f.getAsInt());\n        return a;\n    }\n\n    public static int[][] generate(final int n, final int m, final IntSupplier f) {\n        final int[][] a = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            a[i] = generate(m, f);\n        }\n        return a;\n    }\n\n    public static int[] indexToInt(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, f);\n        return a;\n    }\n\n    public static int[][] indexToInt(final int n, final int m, final IntBinaryOperator f) {\n        final int[][] a = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            final int ii = i;\n            a[i] = indexToInt(m, j -> f.applyAsInt(ii, j));\n        }\n        return a;\n    }\n\n    public static int[] toArray(final Collection<? extends Number> collection) {\n        final int n = collection.size();\n        final int[] ret = new int[n];\n        final Object[] coll = collection.toArray();\n        for (int i = 0; i < n; i++) {\n            ret[i] = ((Number) coll[i]).intValue();\n        }\n        return ret;\n    }\n\n    public static int[] unique(final int[] a) {\n        final HashSet<Integer> set = new HashSet<>();\n        for (final int e : a) {\n            set.add(e);\n        }\n        final int m = set.size();\n        final int[] b = new int[m];\n        int index = 0;\n        for (int i = 0; i < a.length; i++) {\n            if (set.contains(a[i])) {\n                b[index++] = a[i];\n                set.remove(a[i]);\n            }\n        }\n        return b;\n    }\n\n    public static int[][] transpose(final int[][] a) {\n        final int n = a.length;\n        final int m = a[0].length;\n        final int[][] ret = new int[m][n];\n        for (int j = 0; j < m; j++) {\n            for (int i = 0; i < n; i++) {\n                ret[j][i] = a[i][j];\n            }\n        }\n        return ret;\n    }\n\n    public static int[] count(final int[] a, final int max) {\n        final int[] ret = new int[max + 1];\n        for (int i = 0; i < a.length; i++) {\n            ret[a[i]]++;\n        }\n        return ret;\n    }\n\n    public static int[] map(final int[] a, final IntUnaryOperator f) {\n        final int[] b = new int[a.length];\n        Arrays.setAll(b, i -> f.applyAsInt(a[i]));\n        return b;\n    }\n\n    public static int[] filter(final int[] a, final IntPredicate p) {\n        final IntArrayList ret = new IntArrayList();\n        for (final int e : a) {\n            ret.addIf(e, p);\n        }\n        return ret.toArray();\n    }\n\n    public static int[] filterIndex(final int beginIndex, final int endIndex, final IntPredicate p) {\n        final IntArrayList ret = new IntArrayList();\n        for (int i = beginIndex; i < endIndex; i++) {\n            ret.addIf(i, p);\n        }\n        return ret.toArray();\n    }\n\n    public static int[] filterIndex(final int endIndex, final IntPredicate p) {\n        return filterIndex(0, endIndex, p);\n    }\n\n    public static int[] accumulateFromHead(final int[] a, final IntBinaryOperator op, final int e) {\n        final int n = a.length;\n        final int[] ret = new int[n + 1];\n        ret[0] = e;\n        for (int i = 0; i < n; i++) {\n            ret[i + 1] = op.applyAsInt(ret[i], a[i]);\n        }\n        return ret;\n    }\n\n    public static int[] accumulateFromTail(final int[] a, final IntBinaryOperator op, final int e) {\n        final int n = a.length;\n        final int[] ret = new int[n + 1];\n        ret[n] = e;\n        for (int i = n - 1; i >= 0; i--) {\n            ret[i] = op.applyAsInt(ret[i + 1], a[i]);\n        }\n        return ret;\n    }\n}\n\n@FunctionalInterface\ninterface LongComparator {\n    public int compare(long i, long j);\n\n    public default boolean eq(final long i, final long j) {\n        return compare(i, j) == 0;\n    }\n\n    public default boolean ne(final long i, final long j) {\n        return compare(i, j) != 0;\n    }\n\n    public default boolean gt(final long i, final long j) {\n        return compare(i, j) > 0;\n    }\n\n    public default boolean ge(final long i, final long j) {\n        return compare(i, j) >= 0;\n    }\n\n    public default boolean lt(final long i, final long j) {\n        return compare(i, j) < 0;\n    }\n\n    public default boolean le(final long i, final long j) {\n        return compare(i, j) <= 0;\n    }\n}\n\n\nfinal class ComparativeMergeSort {\n    private static int INSERTION_SORT_THRESHOLD = 60;\n\n    public static void sort(final int[] a, final IntComparator comparator) {\n        sort(a, 0, a.length, comparator);\n    }\n\n    public static void sort(final int[] a, final int begin, final int end, final IntComparator comparator) {\n        for (int i = begin;;) {\n            final int j = i + INSERTION_SORT_THRESHOLD;\n            if (j < end) {\n                ComparativeInsertionSort.sort(a, i, j, comparator);\n            } else {\n                ComparativeInsertionSort.sort(a, i, end, comparator);\n                break;\n            }\n            i = j;\n        }\n        final int len = end - begin;\n        final int[] work = new int[len];\n        for (int block = INSERTION_SORT_THRESHOLD; block <= len; block <<= 1) {\n            final int twoBlocks = block << 1;\n            for (int from = begin, max = end - block; from < max; from += twoBlocks) {\n                final int mid = from + block;\n                final int to = Math.min(from + twoBlocks, end);\n                System.arraycopy(a, from, work, 0, block);\n                for (int i = from, wi = 0, ti = mid;; i++) {\n                    if (ti == to) {\n                        System.arraycopy(work, wi, a, i, block - wi);\n                        break;\n                    } else if (comparator.gt(work[wi], a[ti])) {\n                        a[i] = a[ti++];\n                    } else {\n                        a[i] = work[wi++];\n                        if (wi == block) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    public static void sort(final long[] a, final LongComparator comparator) {\n        sort(a, 0, a.length, comparator);\n    }\n\n    public static void sort(final long[] a, final int begin, final int end, final LongComparator comparator) {\n        for (int i = begin;;) {\n            final int j = i + INSERTION_SORT_THRESHOLD;\n            if (j < end) {\n                ComparativeInsertionSort.sort(a, i, j, comparator);\n            } else {\n                ComparativeInsertionSort.sort(a, i, end, comparator);\n                break;\n            }\n            i = j;\n        }\n        final int len = end - begin;\n        final long[] work = new long[len];\n        for (int block = INSERTION_SORT_THRESHOLD; block <= len; block <<= 1) {\n            final int twoBlocks = block << 1;\n            for (int from = begin, max = end - block; from < max; from += twoBlocks) {\n                final int mid = from + block;\n                final int to = Math.min(from + twoBlocks, end);\n                System.arraycopy(a, from, work, 0, block);\n                for (int i = from, wi = 0, ti = mid;; i++) {\n                    if (ti == to) {\n                        System.arraycopy(work, wi, a, i, block - wi);\n                        break;\n                    } else if (comparator.gt(work[wi], a[ti])) {\n                        a[i] = a[ti++];\n                    } else {\n                        a[i] = work[wi++];\n                        if (wi == block) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class In {\n    public static final FastScanner fsc = new FastScanner();\n\n    public static int ni() {\n        return fsc.nextInt();\n    }\n\n    public static int ni(final IntUnaryOperator f) {\n        return f.applyAsInt(fsc.nextInt());\n    }\n\n    public static int[] ni(final int n) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, i -> fsc.nextInt());\n        return a;\n    }\n\n    public static int[] ni(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        Arrays.setAll(a, i -> ni(f));\n        return a;\n    }\n\n    public static int[][] ni(final int n, final int m) {\n        final int[][] a = new int[n][m];\n        Arrays.setAll(a, i -> ni(m));\n        return a;\n    }\n\n    public static int[][] ni(final int n, final int m, final IntUnaryOperator f) {\n        final int[][] a = new int[n][m];\n        Arrays.setAll(a, i -> ni(m, f));\n        return a;\n    }\n\n    public static long nl() {\n        return fsc.nextLong();\n    }\n\n    public static long nl(final LongUnaryOperator f) {\n        return f.applyAsLong(fsc.nextLong());\n    }\n\n    public static long[] nl(final int n) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, i -> fsc.nextLong());\n        return a;\n    }\n\n    public static long[] nl(final int n, final LongUnaryOperator f) {\n        final long[] a = new long[n];\n        Arrays.setAll(a, i -> nl(f));\n        return a;\n    }\n\n    public static long[][] nl(final int n, final int m) {\n        final long[][] a = new long[n][m];\n        Arrays.setAll(a, i -> nl(m));\n        return a;\n    }\n\n    public static long[][] nl(final int n, final int m, final LongUnaryOperator f) {\n        final long[][] a = new long[n][m];\n        Arrays.setAll(a, i -> nl(m, f));\n        return a;\n    }\n\n    public static char[] nc() {\n        return fsc.next().toCharArray();\n    }\n\n    public static char[][] nc(final int n, final int m) {\n        final char[][] c = new char[n][m];\n        Arrays.setAll(c, i -> nc());\n        return c;\n    }\n\n    public static double nd() {\n        return fsc.nextDouble();\n    }\n\n    public static double nd(final DoubleUnaryOperator f) {\n        return f.applyAsDouble(fsc.nextDouble());\n    }\n\n    public static double[] nd(final int n) {\n        final double[] a = new double[n];\n        Arrays.setAll(a, i -> fsc.nextDouble());\n        return a;\n    }\n\n    public static double[] nd(final int n, final DoubleUnaryOperator f) {\n        final double[] a = new double[n];\n        Arrays.setAll(a, i -> nd(f));\n        return a;\n    }\n\n    public static double[][] nd(final int n, final int m) {\n        final double[][] a = new double[n][m];\n        Arrays.setAll(a, i -> nd(m));\n        return a;\n    }\n\n    public static double[][] nd(final int n, final int m, final DoubleUnaryOperator f) {\n        final double[][] a = new double[n][m];\n        Arrays.setAll(a, i -> nd(m, f));\n        return a;\n    }\n\n    public static String ns() {\n        return fsc.next();\n    }\n\n    public static String[] ns(final int n) {\n        final String[] s = new String[n];\n        Arrays.setAll(s, i -> ns());\n        return s;\n    }\n\n    public static boolean[][] grid(final int h, final int w, final char trueCharacter) {\n        final boolean[][] grid = new boolean[h][w];\n        for (int i = 0; i < h; i++) {\n            final char[] s = fsc.next().toCharArray();\n            for (int j = 0; j < w; j++) {\n                grid[i][j] = s[j] == trueCharacter;\n            }\n        }\n        return grid;\n    }\n}\n\n\nfinal class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (final IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int readByte() {\n        if (hasNextByte()) {\n            return buffer[ptr++];\n        } else {\n            return -1;\n        }\n    }\n\n    private static boolean isPrintableChar(final int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    public boolean hasNext() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr])) {\n            ptr++;\n        }\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        final StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n\n    public int nextInt() {\n        final long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n            throw new NumberFormatException();\n        }\n        return (int) nl;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n * \n * 1. DESTRUCTIVE methods for int arrays.\n * 2. methods that receives arrays and return some results (except for int arrays).\n */\nfinal class IntArrays {\n\n    private IntArrays(){}\n\n    public static void swap(final int[] a, final int u, final int v) {\n        final int tmp = a[u];\n        a[u] = a[v];\n        a[v] = tmp;\n    }\n\n    public static void reverse(final int[] a, final int begin, final int end) {\n        for (int i = begin; i < begin + (end - begin) / 2; i++) {\n            swap(a, i, begin + end - i - 1);\n        }\n    }\n\n    public static void reverse(final int[] a) {\n        reverse(a, 0, a.length);\n    }\n\n    public static void sortDescending(final int[] a) {\n        Arrays.sort(a);\n        reverse(a);\n    }\n\n    public static int reduce(final int[] a, final IntBinaryOperator op) {\n        int ret = a[0];\n        for (int i = 1; i < a.length; i++) {\n            ret = op.applyAsInt(ret, a[i]);\n        }\n        return ret;\n    }\n\n    public static void map(final int[] a, final IntUnaryOperator op) {\n        Arrays.setAll(a, i -> op.applyAsInt(a[i]));\n    }\n\n    public static void filter(final int[] src, final int[] dst, final IntPredicate p) {\n        int idx = 0;\n        for (final int e : src) {\n            if (p.test(e)) {\n                dst[idx++] = e;\n            }\n        }\n    }\n\n    public static void filterIndex(final int[] dst, final int beginIndex, final int endIndex, final IntPredicate p) {\n        for (int i = beginIndex, idx = 0; i < endIndex; i++) {\n            if (p.test(i)) {\n                dst[idx++] = i;\n            }\n        }\n    }\n\n    public static void filterIndex(final int dst[], final int endIndex, final IntPredicate p) {\n        filterIndex(dst, 0, endIndex, p);\n    }\n\n    public static void accumulate(final int[] a, final IntBinaryOperator op) {\n        for (int i = 1; i < a.length; i++) {\n            a[i] = op.applyAsInt(a[i - 1], a[i]);\n        }\n    }\n\n    public static void accumulate(final int[] a) {\n        for (int i = 1; i < a.length; i++) {\n            a[i] += a[i - 1];\n        }\n    }\n\n    public static int unique(int[] a) {\n        final HashSet<Integer> set = new HashSet<>();\n        for (final int e : a) {\n            set.add(e);\n        }\n        final int m = set.size();\n        final int[] b = new int[m];\n        int index = 0;\n        for (int i = 0; i < a.length; i++) {\n            if (set.contains(a[i])) {\n                b[index++] = a[i];\n                set.remove(a[i]);\n            }\n        }\n        a = b;\n        return m;\n    }\n\n    public static void permute(int[] a, int[] p) {\n        int n = p.length;\n        boolean[] settled = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            for (int j = i; !settled[j]; j = p[j]) {\n                if (p[j] == i) {\n                    settled[j] = true;\n                    break;\n                }\n                swap(a, j, p[j]);\n                settled[j] = true;\n            }\n        }\n    }\n\n    public static void transpose(int[][] a) {\n        final int n = a.length;\n        final int m = a[0].length;\n        final int[][] ret = new int[m][n];\n        for (int j = 0; j < m; j++) {\n            for (int i = 0; i < n; i++) {\n                ret[j][i] = a[i][j];\n            }\n        }\n        a = ret;\n    }\n\n    public static int compare(final int[] a, final int[] b) {\n        for (int i = 0; i < a.length; i++) {\n            if (i >= b.length) {\n                return -1;\n            } else if (a[i] > b[i]) {\n                return 1;\n            } else if (a[i] < b[i]) {\n                return -1;\n            }\n        }\n        if (a.length < b.length) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n\n    public static boolean equals(final int[] a, final int[] b) {\n        return compare(a, b) == 0;\n    }\n\n    public static String join(final int[] a, final String sep) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < a.length; i++) {\n            sb.append(a[i]);\n            if (i < a.length - 1) {\n                sb.append(sep);\n            }\n        }\n        return sb.toString();\n    }\n\n    public static String joinWithPrefixAndSuffix(final int[] a, final IntFunction<String> idxToPre,\n            final IntFunction<String> idxToSuf, final String sep) {\n        final StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < a.length; i++) {\n            sb.append(idxToPre.apply(i)).append(a[i]).append(idxToSuf.apply(i));\n            if (i < a.length - 1) {\n                sb.append(sep);\n            }\n        }\n        return sb.toString();\n    }\n}\n\n@FunctionalInterface\ninterface IntComparator {\n    public int compare(int i, int j);\n\n    public default boolean eq(final int i, final int j) {\n        return compare(i, j) == 0;\n    }\n\n    public default boolean ne(final int i, final int j) {\n        return compare(i, j) != 0;\n    }\n\n    public default boolean gt(final int i, final int j) {\n        return compare(i, j) > 0;\n    }\n\n    public default boolean ge(final int i, final int j) {\n        return compare(i, j) >= 0;\n    }\n\n    public default boolean lt(final int i, final int j) {\n        return compare(i, j) < 0;\n    }\n\n    public default boolean le(final int i, final int j) {\n        return compare(i, j) <= 0;\n    }\n}\n\nfinal class DependentSort {\n    public static void sort(int[] a, Object... dependentArrays) {\n        sort(a, false, dependentArrays);\n    }\n\n    public static void sortDescending(int[] a, Object... dependentArrays) {\n        sort(a, true, dependentArrays);\n    }\n\n    private static void sort(int[] a, boolean descending, Object... dependentArrays) {\n        int n = a.length;\n        int[] p;\n        if (descending) {\n            p = IndexSort.sortDescending(a);\n            RadixSort.sortDescending(a);\n        } else {\n            p = IndexSort.sort(a);\n            RadixSort.sort(a);\n        }\n        boolean[] settled = new boolean[n];\n        boolean ok = true;\n        for (Object obj : dependentArrays) {\n            if (obj instanceof int[]) {\n                int[] arr = (int[]) obj;\n                for (int i = 0; i < n; i++) {\n                    for (int j = i; ok ^ settled[j]; j = p[j]) {\n                        if (p[j] == i) {\n                            settled[j] = !settled[j];\n                            break;\n                        }\n                        int tmp = arr[j];\n                        arr[j] = arr[p[j]];\n                        arr[p[j]] = tmp;\n                        settled[j] = !settled[j];\n                    }\n                }\n            } else if (obj instanceof long[]) {\n                long[] arr = (long[]) obj;\n                for (int i = 0; i < n; i++) {\n                    for (int j = i; ok ^ settled[j]; j = p[j]) {\n                        if (p[j] == i) {\n                            settled[j] = !settled[j];\n                            break;\n                        }\n                        long tmp = arr[j];\n                        arr[j] = arr[p[j]];\n                        arr[p[j]] = tmp;\n                        settled[j] = !settled[j];\n                    }\n                }\n            } else {\n                throw new UnsupportedOperationException(\"dependent objects musst be int[] or long[] type.\");\n            }\n            ok = !ok;\n        }\n    }\n\n    public static void sort(long[] a, Object... dependentArrays) {\n        sort(a, false, dependentArrays);\n    }\n\n    public static void sortDescending(long[] a, Object... dependentArrays) {\n        sort(a, true, dependentArrays);\n    }\n\n    private static void sort(long[] a, boolean descending, Object... dependentArrays) {\n        int n = a.length;\n        int[] p;\n        if (descending) {\n            p = IndexSort.sortDescending(a);\n            RadixSort.sortDescending(a);\n        } else {\n            p = IndexSort.sort(a);\n            RadixSort.sort(a);\n        }\n        boolean[] settled = new boolean[n];\n        boolean ok = true;\n        for (Object obj : dependentArrays) {\n            if (obj instanceof int[]) {\n                int[] arr = (int[]) obj;\n                for (int i = 0; i < n; i++) {\n                    for (int j = i; ok ^ settled[j]; j = p[j]) {\n                        if (p[j] == i) {\n                            settled[j] = !settled[j];\n                            break;\n                        }\n                        int tmp = arr[j];\n                        arr[j] = arr[p[j]];\n                        arr[p[j]] = tmp;\n                        settled[j] = !settled[j];\n                    }\n                }\n            } else if (obj instanceof long[]) {\n                long[] arr = (long[]) obj;\n                for (int i = 0; i < n; i++) {\n                    for (int j = i; ok ^ settled[j]; j = p[j]) {\n                        if (p[j] == i) {\n                            settled[j] = !settled[j];\n                            break;\n                        }\n                        long tmp = arr[j];\n                        arr[j] = arr[p[j]];\n                        arr[p[j]] = tmp;\n                        settled[j] = !settled[j];\n                    }\n                }\n            } else {\n                throw new UnsupportedOperationException(\"dependent objects musst be int[] or long[] type.\");\n            }\n            ok = !ok;\n        }\n    }\n}\n\n\nfinal class IndexSort {\n    public static int[] sort(final int[] a) {\n        final int[] index = new int[a.length];\n        Arrays.setAll(index, IntUnaryOperator.identity());\n        ComparativeMergeSort.sort(index, (i, j) -> a[i] - a[j]);\n        return index;\n    }\n\n    public static int[] sortDescending(final int[] a) {\n        final int[] index = new int[a.length];\n        Arrays.setAll(index, IntUnaryOperator.identity());\n        ComparativeMergeSort.sort(index, (i, j) -> a[j] - a[i]);\n        return index;\n    }\n\n    public static int[] sort(final long[] a) {\n        final int[] index = new int[a.length];\n        Arrays.setAll(index, IntUnaryOperator.identity());\n        ComparativeMergeSort.sort(index, (i, j) -> Long.compare(a[i], a[j]));\n        return index;\n    }\n\n    public static int[] sortDescending(final long[] a) {\n        final int[] index = new int[a.length];\n        Arrays.setAll(index, IntUnaryOperator.identity());\n        ComparativeMergeSort.sort(index, (i, j) -> Long.compare(a[j], a[i]));\n        return index;\n    }\n}\n\n\nfinal class ComparativeInsertionSort {\n    public static void sort(final int[] a, final int from, final int to, final IntComparator comparator) {\n        for (int i = from + 1; i < to; i++) {\n            final int tmp = a[i];\n            if (comparator.gt(a[i - 1], tmp)) {\n                int j = i;\n                do {\n                    a[j] = a[j - 1];\n                    j--;\n                } while (j > from && comparator.gt(a[j - 1], tmp));\n                a[j] = tmp;\n            }\n        }\n    }\n\n    public static void sort(final long[] a, final int from, final int to, final LongComparator comparator) {\n        for (int i = from + 1; i < to; i++) {\n            final long tmp = a[i];\n            if (comparator.gt(a[i - 1], tmp)) {\n                int j = i;\n                do {\n                    a[j] = a[j - 1];\n                    j--;\n                } while (j > from && comparator.gt(a[j - 1], tmp));\n                a[j] = tmp;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic PrintWriter out;\n\tstatic StringBuilder sb;\n\tstatic int n, m, k;\n\tstatic long mod = 998244353;\n\tstatic Boolean[][] memo;\n\tstatic String s;\n\tstatic ArrayList<Integer>[] ad;\n\tstatic long inf = Long.MAX_VALUE;\n\tstatic int[] color;\n\tstatic ArrayList<Integer> o;\n\tstatic char[][] g;\n\tstatic boolean[] vis, vis1;\n\tstatic boolean f;\n\tstatic long[] a, dest;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsb = new StringBuilder();\n\t\tn = sc.nextInt();\n\t\tTreeSet<pair> bfs = new TreeSet<>();\n\t\tlong[] arr = new long[n];\n\t\ta = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlong x = sc.nextLong();\n\t\t\tbfs.add(new pair(x, i, 0));\n\t\t\tarr[i] = x;\n\t\t}\n\t\tdest = new long[n];\n\t\tad = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tad[i] = new ArrayList<>();\n\t\twhile (!bfs.isEmpty()) {\n\t\t\tpair cur = bfs.pollFirst();\n\t\t\tint ext = cur.lv;\n\t\t\tlong v = cur.x - (n - 2) + 2 * ext;\n\t\t\tpair rob = bfs.ceiling(new pair(v, 0, 0));\n\t\t\t// System.out.println(v + \" G: \" + rob + \" C: \" + cur);\n\t\t\tif (bfs.isEmpty())\n\t\t\t\tbreak;\n\t\t\tif (rob == null || v != rob.x) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsb.append((cur.y + 1) + \" \" + (rob.y + 1) + \"\\n\");\n\t\t\tad[cur.y].add(rob.y);\n\t\t\tad[rob.y].add(cur.y);\n\t\t\tbfs.remove(rob);\n\t\t\tbfs.add(new pair(rob.x, rob.y, rob.lv + 1 + cur.lv));\n\t\t}\n\t\tdfs(0, -1);\n\t//\tSystem.out.println(Arrays.toString(a));\n\t\treroot(0, -1);\n//\t\tSystem.out.println(Arrays.toString(arr));\n\t//\tSystem.out.println(Arrays.toString(a));\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (arr[i] != a[i]) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\tout.println(sb);\n\t\tout.flush();\n\t}\n\n\tstatic void reroot(int u, int p) {\n\t\tif (p != -1) {\n\t\t\ta[u] += a[p] - (a[u] + dest[u]) + n - dest[u];\n\t\t}\n\t\tfor (int v : ad[u])\n\t\t\tif (v != p) {\n\t\t\t\treroot(v, u);\n\t\t\t}\n\t}\n\n\tstatic void dfs(int u, int p) {\n\t\tdest[u] = 1;\n\t\tfor (int v : ad[u])\n\t\t\tif (v != p) {\n\t\t\t\tdfs(v, u);\n\t\t\t\tdest[u] += dest[v];\n\t\t\t\ta[u] += a[v] + dest[v];\n\t\t\t}\n\t}\n\n\tstatic class pair implements Comparable<pair> {\n\t\tlong x;\n\t\tint y, lv;\n\n\t\tpair(long x, int y, int l) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tlv = l;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn x + \" \" + y + \" \" + lv;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(pair o) {\n\t\t\tif (x == o.x)\n\t\t\t\treturn y - o.y;\n\t\t\treturn Long.compare(o.x, x);\n\t\t}\n\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic int[] nextArrInt(int n) throws IOException {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextArrLong(int n) throws IOException {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            long[] d = in.readLongArray(n);\n\n            Map<Long, Integer> map = new HashMap<>();\n            for (int i = 0; i < n; i++) {\n                map.put(d[i], i);\n            }\n\n            Arrays.sort(d);\n\n            Graph graph = new Graph(n);\n            int[] size = new int[n];\n\n            for (int i = 0; i < n - 1; i++) {\n                int v = map.get(d[n - 1 - i]);\n                long childD = d[n - 1 - i] + size[v] - (n - 2 - size[v]);\n\n                if (!map.containsKey(childD) || childD == d[n - 1 - i]) {\n                    out.printLine(-1);\n                    return;\n                }\n\n                int child = map.get(childD);\n                size[child] += size[v] + 1;\n                graph.addUndirectedEdge(v, child);\n            }\n\n            long sum = dfs(map.get(d[n - 1]), -1, 0, graph);\n            if (sum != d[n - 1]) {\n                out.printLine(-1);\n                return;\n            }\n\n            for (int i = 0; i < n; i++) {\n                for (int to : graph.get(i)) {\n                    out.printLine((i + 1) + \" \" + (to + 1));\n                }\n            }\n        }\n\n        private long dfs(int v, int parent, int depth, Graph graph) {\n            long result = 0;\n            for (int to : graph.get(v)) {\n                if (to != parent) {\n                    result += dfs(to, v, depth + 1, graph);\n                }\n            }\n            result += depth;\n\n            return result;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class Graph {\n        int n;\n        ArrayList<Integer>[] G;\n\n        public Graph(int n) {\n            this.n = n;\n            G = new ArrayList[n];\n            for (int i = 0; i < n; i++) {\n                G[i] = new ArrayList<>();\n            }\n        }\n\n        public void addUndirectedEdge(int from, int to) {\n            G[from].add(to);\n            G[to].add(from);\n        }\n\n        public ArrayList<Integer> get(int from) {\n            return G[from];\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public long[] readLongArray(int size) {\n            long[] array = new long[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readLong();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "// package other2018.kupc2018;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n    static long __startTime = System.currentTimeMillis();\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n\n        long[][] a = new long[n][2];\n        for (int i = 0; i < n ; i++) {\n            a[i][0] = in.nextLong();\n            a[i][1] = i;\n        }\n        Arrays.sort(a, (u, v) -> Long.compare(v[0], u[0]));\n\n        Map<Long,Integer> vmap = new HashMap<>();\n        for (int i = 0; i < n ; i++) {\n            vmap.put(a[i][0], (int)a[i][1]);\n        }\n\n        int[] child = new int[n];\n        Arrays.fill(child, 1);\n        List<int[]> edges = new ArrayList<>();\n\n        graph = new List[n];\n        for (int i = 0; i < n ; i++) {\n            graph[i] = new ArrayList<>();\n        }\n\n        for (int i = 0; i < n ; i++) {\n            long v = a[i][0];\n            int idx = (int)a[i][1];\n            long pl = child[idx];\n            long pv = v + pl - (n - pl);\n            if (!vmap.containsKey(pv) || v < pv) {\n                continue;\n            }\n            int pidx = vmap.get(pv);\n            edges.add(new int[]{idx, pidx});\n            graph[pidx].add(idx);\n            child[pidx] += child[idx];\n        }\n\n        boolean valid = true;\n        visited = new boolean[n];\n        valid &= dfs((int)a[n-1][1]);\n        for (int i = 0; i < n ; i++) {\n            valid &= visited[i];\n        }\n\n        if (valid) {\n            for (int[] e : edges) {\n                out.println(String.format(\"%d %d\", e[0]+1, e[1]+1));\n            }\n        } else {\n            out.println(-1);\n        }\n        out.flush();\n    }\n\n    static boolean[] visited;\n    static List<Integer>[] graph;\n\n    static boolean dfs(int r) {\n        if (visited[r]) {\n            return false;\n        }\n        visited[r] = true;\n        boolean ok = true;\n        for (int to : graph[r]) {\n            ok &= dfs(to);\n        }\n        return ok;\n    }\n\n    private static void printTime(String label) {\n        debug(label, System.currentTimeMillis() - __startTime);\n    }\n\n    private static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic PrintWriter out;\n\tstatic StringBuilder sb;\n\tstatic int n, m, k;\n\tstatic long mod = 998244353;\n\tstatic Boolean[][] memo;\n\tstatic String s;\n\tstatic int[][] ad;\n\tstatic long inf = Long.MAX_VALUE;\n\tstatic int[] color;\n\tstatic ArrayList<Integer> o;\n\tstatic char[][] g;\n\tstatic boolean[] vis, vis1;\n\tstatic boolean f;\n\tstatic int[] ar, a;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsb = new StringBuilder();\n\t\tn = sc.nextInt();\n\t\tTreeSet<pair> bfs = new TreeSet<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tbfs.add(new pair(sc.nextLong(), i, 0));\n\t\t}\n\t\twhile (!bfs.isEmpty()) {\n\t\t\tpair cur = bfs.pollFirst();\n\t\t\tint ext = cur.lv;\n\t\t\tlong v = cur.x - (n - 2 ) + 2*ext;\n\t\t\tpair rob = bfs.ceiling(new pair(v, 0, 0));\n\t\t//\tSystem.out.println(v + \" G: \" + rob+\" C: \"+cur);\n\t\t\tif(bfs.isEmpty())\n\t\t\t\tbreak;\n            // System.out.println(cur+\" \"+bfs);\n\t\t\tif (rob == null||v!=rob.x) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsb.append((cur.y + 1) + \" \" + (rob.y + 1) + \"\\n\");\n\t\t\tbfs.remove(rob);\n\t\t\tbfs.add(new pair(rob.x, rob.y, cur.lv + 1));\n\t\t}\n\t\tout.println(sb);\n\t\tout.flush();\n\t}\n\n\tstatic class pair implements Comparable<pair> {\n\t\tlong x;\n\t\tint y, lv;\n\n\t\tpair(long x, int y, int l) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tlv = l;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn x + \" \" + y + \" \" + lv;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(pair o) {\n\t\t\tif (x == o.x)\n\t\t\t\treturn y - o.y;\n\t\t\treturn Long.compare(o.x, x);\n\t\t}\n\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic int[] nextArrInt(int n) throws IOException {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextArrLong(int n) throws IOException {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tpublic static int MAXA = 100000;\n\tpublic static void main(String[] args) {\n\t\tIO io = new IO();\n\t\tint n = io.nextInt();\n\t\tGraph g = new Graph(n);\n\t\tlong[] d = io.nextLongArray(n);\n\t\tArrays.sort(d);\n\t\tint[] size = new int[n];\n\t\tArrays.fill(size, 1);\n\t\tfor(int i=n-1;i>0;i--) {\n//\t\t\tSystem.err.println(d[i] + \" \" + (d[i] + (2 * size[i] - n)));\n\t\t\tint idx = Arrays.binarySearch(d, d[i] + (2 * size[i] - n));\n\t\t\tif (idx < 0) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tg.addBidirectionalEdge(i, idx, 1);\n\t\t\tsize[idx] += size[i];\n\t\t}\n\t\tint[] dist = g.minDistDijkstra(0);\n\t\tlong sum = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tsum += dist[i];\n\t\t}\n//\t\tSystem.err.println(sum + \" \" + d[0]);\n\t\tif (sum != d[0]) {\n\t\t\tSystem.out.println(-1);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(Graph.Edge e: g.graph[i]) {\n\t\t\t\tif (e.to > i) {\n\t\t\t\t\tio.println((i + 1) + \" \" + (e.to + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tio.flush();\n\t}\n}\nclass Graph {\n\tpublic static final int INF = 1<<29;\n\tint n;\n\tArrayList<Edge>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Graph(int n) {\n\t\tthis.n = n;\n\t\tthis.graph = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tgraph[i] = new ArrayList<Edge>();\n\t\t}\n\t}\n\t\n\tpublic void addBidirectionalEdge(int from,int to,int cost) {\n\t\taddEdge(from,to,cost);\n\t\taddEdge(to,from,cost);\n\t}\n\tpublic void addEdge(int from,int to,int cost) {\n\t\tgraph[from].add(new Edge(to, cost));\n\t}\n\n\t//dijkstra O(ElogV)\n\tpublic int[] minDistDijkstra(int s) {\n\t\tint[] dist = new int[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[s] = 0;\n\t\tPriorityQueue<Node> q = new PriorityQueue<Node>();\n\t\tq.offer(new Node(0, s));\n\t\twhile(!q.isEmpty()) {\n\t\t\tNode node = q.poll();\n\t\t\tint v = node.id;\n\t\t\tif (dist[v] < node.dist) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(Edge e:graph[v]) {\n\t\t\t\tif (dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\tq.add(new Node(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\n\tstatic class Edge {\n\t\tint to;\n\t\tint cost;\n\t\tpublic Edge(int to,int cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\tclass Node implements Comparable<Node>{\n\t\tint dist;\n\t\tint id;\n\t\tpublic Node(int dist,int i) {\n\t\t\tthis.dist = dist;\n\t\t\tthis.id = i;\n\t\t}\n\t\tpublic int compareTo(Node o) {\n\t\t\treturn (this.dist < o.dist) ? -1 : ((this.dist == o.dist) ? 0 : 1);\n\t\t}\n\t}\n}\n\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic IO() {\n\t\tthis(System.in);\n\t}\n\n\tpublic IO(InputStream source) {\n\t\tsuper(System.out);\n\t\tthis.in = source;\n\t}\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\n\tprivate static boolean isNewLine(int c) {\n\t\treturn c == '\\n' || c == '\\r';\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\n\tpublic boolean hasNextLine() {\n\t\twhile (hasNextByte() && isNewLine(buffer[ptr]))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tpublic int[] nextIntArray(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic long[] nextLongArray(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n\n\tpublic double[] nextDoubleArray(int n) {\n\t\tdouble[] a = new double[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextDouble();\n\t\treturn a;\n\t}\n\n\tpublic void nextIntArrays(int[]... a) {\n\t\tfor (int i = 0; i < a[0].length; i++)\n\t\t\tfor (int j = 0; j < a.length; j++)\n\t\t\t\ta[j][i] = nextInt();\n\t}\n\n\tpublic int[][] nextIntMatrix(int n, int m) {\n\t\tint[][] a = new int[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextIntArray(m);\n\t\treturn a;\n\t}\n\n\tpublic char[][] nextCharMap(int n, int m) {\n\t\tchar[][] a = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextCharArray(m);\n\t\treturn a;\n\t}\n\n\tpublic void close() {\n\t\tsuper.close();\n\t\ttry {\n\t\t\tin.close();\n\t\t} catch (IOException e) {\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "// package other2018.kupc2018;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n    static long __startTime = System.currentTimeMillis();\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n\n        long[][] a = new long[n][2];\n        for (int i = 0; i < n ; i++) {\n            a[i][0] = in.nextLong();\n            a[i][1] = i;\n        }\n        Arrays.sort(a, (u, v) -> Long.compare(v[0], u[0]));\n\n        Map<Long,Integer> vmap = new HashMap<>();\n        for (int i = 0; i < n ; i++) {\n            vmap.put(a[i][0], (int)a[i][1]);\n        }\n\n        child = new int[n];\n        Arrays.fill(child, 1);\n        List<int[]> edges = new ArrayList<>();\n\n        graph = new List[n];\n        for (int i = 0; i < n ; i++) {\n            graph[i] = new ArrayList<>();\n        }\n\n        for (int i = 0; i < n ; i++) {\n            long v = a[i][0];\n            int idx = (int)a[i][1];\n            long pl = child[idx];\n            long pv = v + pl - (n - pl);\n            if (!vmap.containsKey(pv) || v < pv) {\n                continue;\n            }\n            int pidx = vmap.get(pv);\n            edges.add(new int[]{idx, pidx});\n            graph[pidx].add(idx);\n            child[pidx] += child[idx];\n        }\n\n        boolean valid = true;\n        visited = new boolean[n];\n        valid &= dfs((int)a[n-1][1]);\n        for (int i = 0; i < n ; i++) {\n            valid &= visited[i];\n        }\n        if (valid) {\n            valid &= dfs2((int) a[n - 1][1]) == a[n - 1][0];\n        }\n\n        if (valid) {\n            for (int[] e : edges) {\n                out.println(String.format(\"%d %d\", e[0]+1, e[1]+1));\n            }\n        } else {\n            out.println(-1);\n        }\n        out.flush();\n    }\n\n    static boolean[] visited;\n    static List<Integer>[] graph;\n    static int[] child;\n\n    static long dfs2(int r) {\n        long total = 0;\n        for (int to : graph[r]) {\n            total += dfs2(to) + child[to];\n        }\n        return total;\n    }\n\n    static boolean dfs(int r) {\n        if (visited[r]) {\n            return false;\n        }\n        visited[r] = true;\n        boolean ok = true;\n        for (int to : graph[r]) {\n            ok &= dfs(to);\n        }\n        return ok;\n    }\n\n    private static void printTime(String label) {\n        debug(label, System.currentTimeMillis() - __startTime);\n    }\n\n    private static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            FDistanceSums solver = new FDistanceSums();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class FDistanceSums {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            long[] d = new long[n];\n            for (int i = 0; i < n; i++) {\n                d[i] = in.readLong();\n            }\n\n\n            LongObjectHashMap<Node> map = new LongObjectHashMap<>(n, false);\n            Node[] nodes = new Node[n];\n            for (int i = 0; i < n; i++) {\n                nodes[i] = new Node();\n                nodes[i].id = i;\n                nodes[i].di = d[i];\n                nodes[i].size = 1;\n                map.put(d[i], nodes[i]);\n            }\n\n\n            List<int[]> edges = new ArrayList<>(n - 1);\n            Arrays.sort(nodes, (a, b) -> -Long.compare(a.di, b.di));\n            for (int i = 0; i < n - 1; i++) {\n                Node p = map.get(nodes[i].di + nodes[i].size * 2 - n);\n                if (p == null) {\n                    out.println(-1);\n                    return;\n                }\n                edges.add(new int[]{p.id, nodes[i].id});\n                p.next.add(nodes[i]);\n                p.size += nodes[i].size;\n            }\n\n            if (dfs(nodes[n - 1]) != nodes[n - 1].di) {\n                out.println(-1);\n            }\n\n            for (int[] e : edges) {\n                out.append(e[0] + 1).append(' ').append(e[1] + 1).println();\n            }\n        }\n\n        public long dfs(Node root) {\n            long ans = 0;\n            for (Node node : root.next) {\n                ans += dfs(node) + node.size;\n            }\n            return ans;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            cache.append(System.lineSeparator());\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 20];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public long readLong() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            long val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class LongObjectHashMap<V> {\n        private int[] slot;\n        private int[] next;\n        private long[] keys;\n        private Object[] values;\n        private int alloc;\n        private boolean[] removed;\n        private int mask;\n        private int size;\n        private boolean rehash;\n        private Hasher hasher = new Hasher();\n\n        public LongObjectHashMap(int cap, boolean rehash) {\n            this.mask = (1 << (32 - Integer.numberOfLeadingZeros(cap - 1))) - 1;\n            slot = new int[mask + 1];\n            next = new int[cap + 1];\n            keys = new long[cap + 1];\n            values = new Object[cap + 1];\n            removed = new boolean[cap + 1];\n            this.rehash = rehash;\n        }\n\n        private void doubleCapacity() {\n            int newSize = Math.max(next.length + 10, next.length * 2);\n            next = Arrays.copyOf(next, newSize);\n            keys = Arrays.copyOf(keys, newSize);\n            values = Arrays.copyOf(values, newSize);\n            removed = Arrays.copyOf(removed, newSize);\n        }\n\n        private void rehash() {\n            int[] newSlots = new int[Math.max(16, slot.length * 2)];\n            int newMask = newSlots.length - 1;\n            for (int i = 0; i < slot.length; i++) {\n                if (slot[i] == 0) {\n                    continue;\n                }\n                int head = slot[i];\n                while (head != 0) {\n                    int n = next[head];\n                    int s = hash(keys[head]) & newMask;\n                    next[head] = newSlots[s];\n                    newSlots[s] = head;\n                    head = n;\n                }\n            }\n            this.slot = newSlots;\n            this.mask = newMask;\n        }\n\n        public void alloc() {\n            alloc++;\n            if (alloc >= next.length) {\n                doubleCapacity();\n            }\n            next[alloc] = 0;\n            removed[alloc] = false;\n            values[alloc] = null;\n            size++;\n        }\n\n        private int hash(long x) {\n            return hasher.hash(x);\n        }\n\n        public void put(long x, V y) {\n            int h = hash(x);\n            int s = h & mask;\n            if (slot[s] == 0) {\n                alloc();\n                slot[s] = alloc;\n                keys[alloc] = x;\n                values[alloc] = y;\n            } else {\n                int index = findIndexOrLastEntry(s, x);\n                if (keys[index] != x) {\n                    alloc();\n                    next[index] = alloc;\n                    keys[alloc] = x;\n                    values[alloc] = y;\n                } else {\n                    values[index] = y;\n                }\n            }\n            if (rehash && size >= slot.length) {\n                rehash();\n            }\n        }\n\n        public V getOrDefault(long x, V def) {\n            int h = hash(x);\n            int s = h & mask;\n            if (slot[s] == 0) {\n                return def;\n            }\n            int index = findIndexOrLastEntry(s, x);\n            return keys[index] == x ? (V) values[index] : def;\n        }\n\n        public V get(long x) {\n            return getOrDefault(x, null);\n        }\n\n        private int findIndexOrLastEntry(int s, long x) {\n            int iter = slot[s];\n            while (keys[iter] != x) {\n                if (next[iter] != 0) {\n                    iter = next[iter];\n                } else {\n                    return iter;\n                }\n            }\n            return iter;\n        }\n\n        public LongObjectEntryIterator<V> iterator() {\n            return new LongObjectEntryIterator() {\n                int index = 1;\n                int readIndex = -1;\n\n\n                public boolean hasNext() {\n                    while (index <= alloc && removed[index]) {\n                        index++;\n                    }\n                    return index <= alloc;\n                }\n\n\n                public long getEntryKey() {\n                    return keys[readIndex];\n                }\n\n\n                public Object getEntryValue() {\n                    return values[readIndex];\n                }\n\n\n                public void next() {\n                    if (!hasNext()) {\n                        throw new IllegalStateException();\n                    }\n                    readIndex = index;\n                    index++;\n                }\n            };\n        }\n\n        public String toString() {\n            LongObjectEntryIterator<V> iterator = iterator();\n            StringBuilder builder = new StringBuilder(\"{\");\n            while (iterator.hasNext()) {\n                iterator.next();\n                builder.append(iterator.getEntryKey()).append(\"->\").append(iterator.getEntryValue()).append(',');\n            }\n            if (builder.charAt(builder.length() - 1) == ',') {\n                builder.setLength(builder.length() - 1);\n            }\n            builder.append('}');\n            return builder.toString();\n        }\n\n    }\n\n    static class Hasher {\n        private long time = System.nanoTime() + System.currentTimeMillis();\n\n        private int shuffle(long x) {\n            x += time;\n            x += 0x9e3779b97f4a7c15L;\n            x = (x ^ (x >>> 30)) * 0xbf58476d1ce4e5b9L;\n            x = (x ^ (x >>> 27)) * 0x94d049bb133111ebL;\n            return (int) (x ^ (x >>> 31));\n        }\n\n        public int hash(long x) {\n            return shuffle(x);\n        }\n\n    }\n\n    static interface LongObjectEntryIterator<V> {\n        boolean hasNext();\n\n        void next();\n\n        long getEntryKey();\n\n        V getEntryValue();\n\n    }\n\n    static class Node {\n        long di;\n        int size;\n        int id;\n        List<Node> next = new ArrayList<>();\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException; \nimport java.io.InputStream; \nimport java.io.PrintWriter; \nimport java.util.*; \n \n\nclass Main{\n\tstatic class Node{\n\t\tint v;\n\t\tlong d;\n\t\tNode(int v, long d){this.v=v;this.d=d;}\n\t}\n\n\tstatic long dfs(int v, long dep){\n\t\tlong res = dep;\n\t\tfor(int u: edges[v])res += dfs(u, dep+1);\n\t\treturn res;\n\t}\n\tstatic List<Integer> edges[];\n\n\tstatic void solve(){\n\t\tint n = ni();\n\t\tList<Node> nodes = new ArrayList<>();\n\t\tMap<Long, Integer> dtoi = new HashMap<>();\n\t\tfor(int i=0;i<n;++i){\n\t\t\tlong d=nl();\n\t\t\tnodes.add(new Node(i, d));\n\t\t\tdtoi.put(d, i);\n\t\t}\n\t\tCollections.sort(nodes, (a,b)->b.d-a.d<0 ? -1:1);\n\t\tlong[] s = new long[n];\n\t\tint[] pare = new int[n];\n\t\tedges = new List[n];\n\t\tfor(int i=0;i<n;++i)edges[i] = new ArrayList<>();\n\t\tArrays.fill(pare, -1);\n\t\tArrays.fill(s, 1);\n\t\tfor(int i=0;i<n-1;++i){\n\t\t\tNode node = nodes.get(i);\n\t\t\tif(!dtoi.containsKey(node.d+2*s[node.v]-n) || node.v == dtoi.get(node.d+2*s[node.v]-n)){\n\t\t\t\tout.println(-1);return;\n\t\t\t}\n\t\t\tint p = dtoi.get(node.d+2*s[node.v]-n);\n\t\t\tpare[node.v] = p;\n\t\t\tedges[p].add(node.v);\n\t\t\ts[p] += s[node.v];\n\t\t}\n\t\tif(dfs(nodes.get(n-1).v, 0) != nodes.get(n-1).d){\n\t\t\tout.println(-1);return;\n\t\t}\n\n\t\tfor(int i=0;i<n;++i){\n\t\t\tif(pare[i]<0)continue;\n\t\t\tout.println((i+1)+\" \"+(pare[i]+1));\n\t\t}\n\n\t}\n \n \n \n \n\t public static void main(String[] args){ \n\t\t solve(); \n\t\t out.flush(); \n\t } \n\t private static InputStream in = System.in; \n\t private static PrintWriter out = new PrintWriter(System.out); \n \n\t static boolean inrange(int y, int x, int h, int w){ \n\t\t return y>=0 && y<h && x>=0 && x<w; \n\t } \n\t @SuppressWarnings(\"unchecked\") \n\t static<T extends Comparable> int lower_bound(List<T> list, T key){ \n\t\t int lower=-1;int upper=list.size(); \n\t\t while(upper - lower>1){ \n\t\t int center =(upper+lower)/2; \n\t\t if(list.get(center).compareTo(key)>=0)upper=center; \n\t\t else lower=center; \n\t\t } \n\t\t return upper; \n\t } \n\t @SuppressWarnings(\"unchecked\") \n\t static <T extends Comparable> int upper_bound(List<T> list, T key){ \n\t\t int lower=-1;int upper=list.size(); \n\t\t while(upper-lower >1){ \n\t\t int center=(upper+lower)/2; \n\t\t if(list.get(center).compareTo(key)>0)upper=center; \n\t\t else lower=center; \n\t\t } \n\t\t return upper; \n\t } \n\t @SuppressWarnings(\"unchecked\") \n\t static <T extends Comparable> boolean next_permutation(List<T> list){ \n\t\t int lastIndex = list.size()-2; \n\t\t while(lastIndex>=0 && list.get(lastIndex).compareTo(list.get(lastIndex+1))>=0)--lastIndex; \n\t\t if(lastIndex<0)return false; \n\t\t int swapIndex = list.size()-1; \n\t\t while(list.get(lastIndex).compareTo(list.get(swapIndex))>=0)swapIndex--; \n\t\t T tmp = list.get(lastIndex); \n\t\t list.set(lastIndex++, list.get(swapIndex)); \n\t\t list.set(swapIndex, tmp); \n\t\t swapIndex = list.size()-1; \n\t\t while(lastIndex<swapIndex){ \n\t\t tmp = list.get(lastIndex); \n\t\t list.set(lastIndex, list.get(swapIndex)); \n\t\t list.set(swapIndex, tmp); \n\t\t ++lastIndex;--swapIndex; \n\t\t } \n\t\t return true; \n\t } \n\t private static final byte[] buffer = new byte[1<<15]; \n\t private static int ptr = 0; \n\t private static int buflen = 0; \n\t private static boolean hasNextByte(){ \n\t\t if(ptr<buflen)return true; \n\t\t ptr = 0; \n\t\t try{ \n\t\t\t buflen = in.read(buffer); \n\t\t } catch (IOException e){ \n\t\t\t e.printStackTrace(); \n\t\t } \n\t\t return buflen>0; \n\t } \n\t private static int readByte(){ if(hasNextByte()) return buffer[ptr++]; else return -1;} \n\t private static boolean isSpaceChar(int c){ return !(33<=c && c<=126);} \n\t private static int skip(){int res; while((res=readByte())!=-1 && isSpaceChar(res)); return res;} \n \n\t private static double nd(){ return Double.parseDouble(ns()); } \n\t private static char nc(){ return (char)skip(); } \n\t private static String ns(){ \n\t\t StringBuilder sb = new StringBuilder(); \n\t\t for(int b=skip();!isSpaceChar(b);b=readByte())sb.append((char)b); \n\t\t return sb.toString(); \n\t } \n\t private static int[] nia(int n){ \n\t\t int[] res = new int[n]; \n\t\t for(int i=0;i<n;++i)res[i]=ni(); \n\t\t return res; \n\t } \n\t private static long[] nla(int n){ \n\t\t long[] res = new long[n]; \n\t\t for(int i=0;i<n;++i)res[i]=nl(); \n\t\t return res; \n\t } \n\t private static int ni(){ \n\t\t int res=0,b; \n\t\t boolean minus=false; \n\t\t while((b=readByte())!=-1 && !((b>='0'&&b<='9') || b=='-')); \n\t\t if(b=='-'){ \n\t\t\t minus=true; \n\t\t\t b=readByte(); \n\t\t } \n\t\t for(;'0'<=b&&b<='9';b=readByte())res=res*10+(b-'0'); \n\t\t return minus ? -res:res; \n\t } \n\t private static long nl(){ \n\t\t long res=0,b; \n\t\t boolean minus=false; \n\t\t while((b=readByte())!=-1 && !((b>='0'&&b<='9') || b=='-')); \n\t\t if(b=='-'){ \n\t\t\t minus=true; \n\t\t\t b=readByte(); \n\t\t } \n\t\t for(;'0'<=b&&b<='9';b=readByte())res=res*10+(b-'0'); \n\t\t return minus ? -res:res; \n\t} \n} \n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tlong[][] di = new long[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tdi[i] = new long[]{nl(), i};\n\t\t}\n\t\t\n\t\tArrays.sort(di, new Comparator<long[]>() {\n\t\t\tpublic int compare(long[] a, long[] b) {\n\t\t\t\treturn Long.compare(a[0], b[0]);\n\t\t\t}\n\t\t});\n\t\tint[] des = new int[n];\n\t\tlong[] vs = new long[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tvs[i] = di[i][0];\n\t\t}\n\t\tArrays.fill(des, 1);\n\t\tint[] from = new int[n-1];\n\t\tint[] to = new int[n-1];\n\t\t\n\t\tint p = 0;\n\t\tboolean[] done = new boolean[n];\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\tlong val = di[i][0];\n\t\t\tint cur = (int)di[i][1];\n\t\t\t\n\t\t\t// (n-d)/2 = des\n\t\t\t// n-des*2 = d\n\t\t\tif(n-des[cur]*2 > 0){\n\t\t\t\tlong d = n-des[cur]*2;\n\t\t\t\tint ind = lowerBound(vs, val - d);\n\t\t\t\tif(ind >= n){\n\t\t\t\t\tout.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(vs[ind] != val - d){\n\t\t\t\t\tout.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tdes[(int)di[ind][1]] += des[cur];\n\t\t\t\tdone[cur] = true;\n\t\t\t\tfrom[p] = cur;\n\t\t\t\tto[p] = (int)di[ind][1];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] ds = new int[2];\n\t\tint q = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(!done[i]){\n\t\t\t\tif(q == 1){\n\t\t\t\t\tout.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tds[q++] = i;\n\t\t\t}\n\t\t}\n\t\tif(q == 2){\n\t\t\tfrom[p] = ds[0];\n\t\t\tto[p] = ds[1];\n\t\t\tp++;\n\t\t}\n\t\t\n\t\tassert p == n-1;\n\t\tint[][] g = packU(n, from, to);\n\t\t\n\t\tArrays.sort(di, new Comparator<long[]>() {\n\t\t\tpublic int compare(long[] a, long[] b) {\n\t\t\t\treturn Long.compare(a[1], b[1]);\n\t\t\t}\n\t\t});\n\t\t\n\t\tfor(int k = 0;k < 2;k++){\n\t\t\tint[][] pars = parents3(g, ds[k]);\n\t\t\tlong dsum = 0;\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tdsum += pars[2][i];\n\t\t\t}\n\t\t\tif(dsum != di[ds[k]][0]){\n\t\t\t\tout.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0;i < n-1;i++){\n\t\t\tout.println((from[i]+1) + \" \" + (to[i] + 1));\n\t\t}\n\t}\n\t\n\tstatic int[][] packU(int n, int[] from, int[] to) {\n\t\tint[][] g = new int[n][];\n\t\tint[] p = new int[n];\n\t\tfor (int f : from)\n\t\t\tp[f]++;\n\t\tfor (int t : to)\n\t\t\tp[t]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i] = new int[p[i]];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\tg[from[i]][--p[from[i]]] = to[i];\n\t\t\tg[to[i]][--p[to[i]]] = from[i];\n\t\t}\n\t\treturn g;\n\t}\n\t\n\tpublic static int[][] parents3(int[][] g, int root) {\n\t\tint n = g.length;\n\t\tint[] par = new int[n];\n\t\tArrays.fill(par, -1);\n\n\t\tint[] depth = new int[n];\n\t\tdepth[0] = 0;\n\n\t\tint[] q = new int[n];\n\t\tq[0] = root;\n\t\tfor (int p = 0, r = 1; p < r; p++) {\n\t\t\tint cur = q[p];\n\t\t\tfor (int nex : g[cur]) {\n\t\t\t\tif (par[cur] != nex) {\n\t\t\t\t\tq[r++] = nex;\n\t\t\t\t\tpar[nex] = cur;\n\t\t\t\t\tdepth[nex] = depth[cur] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new int[][] { par, q, depth };\n\t}\n\n\t\n\tpublic static int lowerBound(long[] a, long v)\n\t{\n\t\tint low = -1, high = a.length;\n\t\twhile(high-low > 1){\n\t\t\tint h = high+low>>>1;\n\t\t\tif(a[h] >= v){\n\t\t\t\thigh = h;\n\t\t\t}else{\n\t\t\t\tlow = h;\n\t\t\t}\n\t\t}\n\t\treturn high;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.Map.Entry;\nimport java.util.stream.Collectors;\n\nclass Main {\n    public static void main(String[] args) throws Exception {\n        final Scanner sc = new Scanner(System.in);\n        long N;\n        N = sc.nextLong();\n        long[] D = new long[(int)(N)];\n        for(int i = 0 ; i < N ; i++){\n                D[i] = sc.nextLong();\n        }\n        solve(N, D);\n    }\n\n    static void solve(long N, long[] D){\n        HashMap<Long, Long> G = new HashMap<Long, Long>();\n        HashMap<Long, Long> V = new HashMap<Long, Long>();\n        for(int i = 0 ; i < N ; i++) G.put((long)i+1, D[i]);\n        \n        G = G.entrySet().stream()\n        .sorted(Entry.<Long,Long>comparingByValue().reversed())\n        .collect(Collectors.toMap(Entry::getKey,Entry::getValue,(e1, e2)->e1,LinkedHashMap::new));\n        List<Long> S = new ArrayList<>(G.values());\n        List<Long> Key = new ArrayList<>(G.keySet());\n        int n[] = new int[(int)N];\n        Long T[] = new Long[(int)N-1];\n        for(int i = 0 ; i < N ; i++){\n            n[i] = 1;\n        }\n        for(int i = 0 ; i < N-1 ; i++){\n            T[i] = S.get(i)-(long)N+2*(long)n[i];\n            int flag = 0;\n            for(int j = i+1 ; j < N ; j++){\n                if(S.get(j).equals(T[i])){\n                    n[j] += n[i];\n                    V.put(Key.get(i),Key.get(j));\n                    flag = 1;\n                    break;\n                }\n            }\n            if(flag == 0){\n                System.out.println(\"-1\");\n                System.exit(0);\n            }\n        }\n        for (Long key : V.keySet()) {\n            System.out.println(key + \" \" + V.get(key));\n        }\n\t\t\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tstatic final Reader in = new Reader();\n\tstatic final PrintWriter out = new PrintWriter(System.out);\n\t\n\tpublic static void main(String[] args) {\n\t\tint n=in.nextInt();\n\t\tPair[] d = new Pair[n];\n\t\tint[] s = new int[n], p = new int[n];\n\t\tMap<Long, Integer> mp = new HashMap<Long, Integer>();\n\t\tfor(int i=0; i<n; ++i) {\n\t\t\td[i] = new Pair(in.nextLong(), i);\n\t\t\tmp.put(d[i].a, i);\n\t\t\ts[i]=1;\n\t\t}\n\t\tArrays.sort(d);\n\t\tfor(int i=0; i<n-1; ++i) {\n\t\t\tint u=d[i].b;\n\t\t\tp[u]=mp.getOrDefault(d[i].a-n+2*s[u], -1);\n\t\t\tif(d[i].a-n+2*s[u]>=d[i].a||p[u]==-1) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ts[p[u]]+=s[u];\n\t\t}\n\t\tfor(int i=0; i<n-1; ++i)\n\t\t\tout.println((d[i].b+1)+\" \"+(p[d[i].b]+1));\n\t\tout.close();\n\t}\n\t\n\tstatic class Pair implements Comparable<Pair> {\n\t\tlong a;\n\t\tint b;\n\t\tPair(long a, int b) {\n\t\t\tthis.a=a;\n\t\t\tthis.b=b;\n\t\t}\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn -Long.compare(a, o.a);\n\t\t}\n\t}\n\t\n\tstatic class Reader {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st;\n\t\t\n\t\tString next() {\n\t\t\twhile(st==null||!st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch(Exception e) {}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            long[] d = in.readLongArray(n);\n\n            Map<Long, Integer> map = new HashMap<>();\n            for (int i = 0; i < n; i++) {\n                map.put(d[i], i);\n            }\n\n            Arrays.sort(d);\n\n            Graph graph = new Graph(n);\n            int[] size = new int[n];\n\n            for (int i = 0; i < n - 1; i++) {\n                int v = map.get(d[n - 1 - i]);\n                long childD = d[n - 1 - i] + size[v] - (n - 2 - size[v]);\n\n                if (!map.containsKey(childD) || childD == d[n - 1 - i]) {\n                    out.printLine(-1);\n                    return;\n                }\n\n                int child = map.get(childD);\n                size[child] += size[v] + 1;\n                graph.addUndirectedEdge(v, child);\n            }\n\n            long sum = dfs(map.get(d[n - 1]), -1, 0, graph);\n            if (sum != d[n - 1]) {\n                out.printLine(-1);\n                return;\n            }\n\n            for (int i = 0; i < n; i++) {\n                for (int to : graph.get(i)) {\n                    if (i < to) {\n                        out.printLine((i + 1) + \" \" + (to + 1));\n                    }\n                }\n            }\n        }\n\n        private long dfs(int v, int parent, int depth, Graph graph) {\n            long result = 0;\n            for (int to : graph.get(v)) {\n                if (to != parent) {\n                    result += dfs(to, v, depth + 1, graph);\n                }\n            }\n            result += depth;\n\n            return result;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void printLine(Object... objects) {\n            print(objects);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class Graph {\n        int n;\n        ArrayList<Integer>[] G;\n\n        public Graph(int n) {\n            this.n = n;\n            G = new ArrayList[n];\n            for (int i = 0; i < n; i++) {\n                G[i] = new ArrayList<>();\n            }\n        }\n\n        public void addUndirectedEdge(int from, int to) {\n            G[from].add(to);\n            G[to].add(from);\n        }\n\n        public ArrayList<Integer> get(int from) {\n            return G[from];\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public long[] readLongArray(int size) {\n            long[] array = new long[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readLong();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\npublic class Main{\n\tstatic void main() throws Exception{\n\t\tint n=sc.nextInt();\n\t\tlong[][]in=new long[n][];\n\t\tHashMap<Long, Integer>map=new HashMap<>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tin[i]=new long[] {sc.nextLong(),i};\n\t\t\tmap.put(in[i][0], i);\n\t\t}\n\t\tArrays.sort(in,(x,y)->Long.compare(y[0], x[0]));\n\t\tint[]sub=new int[n];\n\t\tArrays.fill(sub, 1);\n\t\tStringBuilder ans=new StringBuilder();\n\t\tfor(int i=0;i<n-1;i++) {\n\t\t\tlong D=in[i][0];int idx=(int)in[i][1];\n\t\t\tlong parD=D-(n-sub[idx]-1)+sub[idx]-1;\n\t\t\tif(parD==D || !map.containsKey(parD)) {\n\t\t\t\tpw.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint par=map.get(parD);\n\t\t\tsub[par]+=sub[idx];\n\t\t\tans.append((idx+1)+\" \"+(par+1)+'\\n');\n\t\t}\n\t\tpw.println(ans);\n\t}\n\tpublic static void main(String[] args) throws Exception{\n\t\tsc=new MScanner(System.in);\n\t\tpw = new PrintWriter(System.out);\n\t\tint tc=1;\n//\t\ttc=sc.nextInt();\n\t\twhile(tc-->0)\n\t\t\tmain();\n\t\tpw.flush();\n\t}\n\tstatic PrintWriter pw;\n\tstatic MScanner  sc;\n\tstatic class MScanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\t\tpublic MScanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n \n\t\tpublic MScanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tpublic int[] intArr(int n) throws IOException {\n\t        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n\t        return in;\n\t\t}\n\t\tpublic long[] longArr(int n) throws IOException {\n\t        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n\t        return in;\n\t\t}\n\t\tpublic int[] intSortedArr(int n) throws IOException {\n\t        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n\t        shuffle(in);\n\t        Arrays.sort(in);\n\t        return in;\n\t\t}\n\t\tpublic long[] longSortedArr(int n) throws IOException {\n\t        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n\t        shuffle(in);\n\t        Arrays.sort(in);\n\t        return in;\n\t\t}\n\t\tpublic Integer[] IntegerArr(int n) throws IOException {\n\t        Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n\t        return in;\n\t\t}\n\t\tpublic Long[] LongArr(int n) throws IOException {\n\t        Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n\t        return in;\n\t\t}\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n \n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n \n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n\tstatic void shuffle(int[]in) {\n\t\tfor(int i=0;i<in.length;i++) {\n\t\t\tint idx=(int)(Math.random()*in.length);\n\t\t\tint tmp=in[i];\n\t\t\tin[i]=in[idx];\n\t\t\tin[idx]=tmp;\n\t\t}\n\t}\n\tstatic void shuffle(long[]in) {\n\t\tfor(int i=0;i<in.length;i++) {\n\t\t\tint idx=(int)(Math.random()*in.length);\n\t\t\tlong tmp=in[i];\n\t\t\tin[i]=in[idx];\n\t\t\tin[idx]=tmp;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tpublic static int MAXA = 100000;\n\tpublic static void main(String[] args) {\n\t\tIO io = new IO();\n\t\tint n = io.nextInt();\n\t\tGraph g = new Graph(n);\n\t\tPair[] d = new Pair[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\td[i] = new Pair(i, io.nextLong());\n\t\t}\n\t\tArrays.sort(d,(p1,p2)->Long.compare(p1.d, p2.d));\n\t\tlong[] d2 = new long[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\td2[i] = d[i].d;\n\t\t}\n\t\tArrays.sort(d2);\n\t\tint[] size = new int[n];\n\t\tArrays.fill(size, 1);\n\t\tfor(int i=n-1;i>0;i--) {\n//\t\t\tSystem.err.println(d[i] + \" \" + (d[i] + (2 * size[i] - n)));\n\t\t\tint idx = Arrays.binarySearch(d2, d2[i] + (2 * size[i] - n));\n\t\t\tif (idx < 0) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tg.addBidirectionalEdge(i, idx, 1);\n\t\t\tsize[idx] += size[i];\n\t\t}\n\t\tint[] dist = g.minDistDijkstra(0);\n\t\tlong sum = 0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tsum += dist[i];\n\t\t}\n//\t\tSystem.err.println(sum + \" \" + d[0]);\n\t\tif (sum != d2[0]) {\n\t\t\tSystem.out.println(-1);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(Graph.Edge e: g.graph[i]) {\n\t\t\t\tif (e.to > i) {\n\t\t\t\t\tio.println((d[i].i + 1) + \" \" + (d[e.to].i + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tio.flush();\n\t}\n}\nclass Pair {\n\tint i;\n\tlong d;\n\tpublic Pair(int i, long d) {\n\t\tsuper();\n\t\tthis.i = i;\n\t\tthis.d = d;\n\t}\n\t\n}\nclass Graph {\n\tpublic static final int INF = 1<<29;\n\tint n;\n\tArrayList<Edge>[] graph;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Graph(int n) {\n\t\tthis.n = n;\n\t\tthis.graph = new ArrayList[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tgraph[i] = new ArrayList<Edge>();\n\t\t}\n\t}\n\t\n\tpublic void addBidirectionalEdge(int from,int to,int cost) {\n\t\taddEdge(from,to,cost);\n\t\taddEdge(to,from,cost);\n\t}\n\tpublic void addEdge(int from,int to,int cost) {\n\t\tgraph[from].add(new Edge(to, cost));\n\t}\n\n\t//dijkstra O(ElogV)\n\tpublic int[] minDistDijkstra(int s) {\n\t\tint[] dist = new int[n];\n\t\tArrays.fill(dist, INF);\n\t\tdist[s] = 0;\n\t\tPriorityQueue<Node> q = new PriorityQueue<Node>();\n\t\tq.offer(new Node(0, s));\n\t\twhile(!q.isEmpty()) {\n\t\t\tNode node = q.poll();\n\t\t\tint v = node.id;\n\t\t\tif (dist[v] < node.dist) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(Edge e:graph[v]) {\n\t\t\t\tif (dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\tq.add(new Node(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\n\tstatic class Edge {\n\t\tint to;\n\t\tint cost;\n\t\tpublic Edge(int to,int cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\tclass Node implements Comparable<Node>{\n\t\tint dist;\n\t\tint id;\n\t\tpublic Node(int dist,int i) {\n\t\t\tthis.dist = dist;\n\t\t\tthis.id = i;\n\t\t}\n\t\tpublic int compareTo(Node o) {\n\t\t\treturn (this.dist < o.dist) ? -1 : ((this.dist == o.dist) ? 0 : 1);\n\t\t}\n\t}\n}\n\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic IO() {\n\t\tthis(System.in);\n\t}\n\n\tpublic IO(InputStream source) {\n\t\tsuper(System.out);\n\t\tthis.in = source;\n\t}\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\n\tprivate static boolean isNewLine(int c) {\n\t\treturn c == '\\n' || c == '\\r';\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\n\tpublic boolean hasNextLine() {\n\t\twhile (hasNextByte() && isNewLine(buffer[ptr]))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tpublic int[] nextIntArray(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\n\tpublic long[] nextLongArray(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextLong();\n\t\treturn a;\n\t}\n\n\tpublic double[] nextDoubleArray(int n) {\n\t\tdouble[] a = new double[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextDouble();\n\t\treturn a;\n\t}\n\n\tpublic void nextIntArrays(int[]... a) {\n\t\tfor (int i = 0; i < a[0].length; i++)\n\t\t\tfor (int j = 0; j < a.length; j++)\n\t\t\t\ta[j][i] = nextInt();\n\t}\n\n\tpublic int[][] nextIntMatrix(int n, int m) {\n\t\tint[][] a = new int[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextIntArray(m);\n\t\treturn a;\n\t}\n\n\tpublic char[][] nextCharMap(int n, int m) {\n\t\tchar[][] a = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nextCharArray(m);\n\t\treturn a;\n\t}\n\n\tpublic void close() {\n\t\tsuper.close();\n\t\ttry {\n\t\t\tin.close();\n\t\t} catch (IOException e) {\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing N = System.Int64;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n            var D = Enumerate(n, x => rl).OrderBy(x => x).ToArray();\n            var cnt = new int[n];\n            //D_v = X+Y+S_u\n            //D_u = X+Y+S_v\n            //D_u-D_v = S_v-S_u\n            var par = Enumerate(n, x => -1);\n            var G = Enumerate(n, x => new List<int>());\n            for (int v = n - 1; v > 0; v--) {\n                cnt[v]++;\n                var sv = cnt[v];\n                var su = n - sv;\n                int u = -1;\n                if (sv == su) {\n\n                } else {\n                    var Du = D[v] + sv - su;\n                    u = Array.BinarySearch(D, Du);\n                }\n                if (u < 0) {\n                    Console.WriteLine(-1);\n                    return;\n                }\n                G[u].Add(v);\n                par[v] = u;\n                cnt[u] += cnt[v];\n            }\n            Debug.WriteLine(par.AsJoinedString());\n            var d = 0L;\n            var dep = new int[n];\n            for (int v = 0; v < n; v++) {\n                foreach (var t in G[v]) {\n                    dep[t] = dep[v] + 1;\n                    d += dep[t];\n                }\n            }\n            if (d != D[0]) { Console.WriteLine(-1); return; }\n            for (int i = 1; i < n; i++) Console.WriteLine($\"{par[i] + 1} {i + 1}\");\n        }\n        const long INF = 1L << 60;\n        int ri => sc.Integer();\n        long rl => sc.Long();\n        double rd => sc.Double();\n        string rs => sc.Scan();\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static IEnumerable<int> Rep(int n) => Enumerable.Range(0, n);\n        static IEnumerable<int> RRep(int n) => Enumerable.Range(0, n).Reverse();\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < a.Length; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer : StreamWriter {\n        public override IFormatProvider FormatProvider => CultureInfo.InvariantCulture;\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing N = System.Int64;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n            var D = Enumerate(n, x => rl);\n            var id = Enumerate(n, x => x + 1);\n            Array.Sort(D, id);\n            var cnt = new int[n];\n            //D_v = X+Y+S_u\n            //D_u = X+Y+S_v\n            //D_u-D_v = S_v-S_u\n            var par = Enumerate(n, x => -1);\n            var G = Enumerate(n, x => new List<int>());\n            for (int v = n - 1; v > 0; v--) {\n                cnt[v]++;\n                var sv = cnt[v];\n                var su = n - sv;\n                int u = -1;\n                if (sv == su) {\n\n                } else {\n                    var Du = D[v] + sv - su;\n                    u = Array.BinarySearch(D, Du);\n                }\n                if (u < 0) {\n                    Console.WriteLine(-1);\n                    return;\n                }\n                G[u].Add(v);\n                par[v] = u;\n                cnt[u] += cnt[v];\n            }\n            Debug.WriteLine(par.AsJoinedString());\n            var d = 0L;\n            var dep = new int[n];\n            for (int v = 0; v < n; v++) {\n                foreach (var t in G[v]) {\n                    dep[t] = dep[v] + 1;\n                    d += dep[t];\n                }\n            }\n            if (d != D[0]) { Console.WriteLine(-1); return; }\n            for (int i = 1; i < n; i++) Console.WriteLine($\"{id[par[i]]} {id[i]}\");\n        }\n        const long INF = 1L << 60;\n        int ri => sc.Integer();\n        long rl => sc.Long();\n        double rd => sc.Double();\n        string rs => sc.Scan();\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static IEnumerable<int> Rep(int n) => Enumerable.Range(0, n);\n        static IEnumerable<int> RRep(int n) => Enumerable.Range(0, n).Reverse();\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < a.Length; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer : StreamWriter {\n        public override IFormatProvider FormatProvider => CultureInfo.InvariantCulture;\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.algorithm, std.range, std.conv, std.string, std.math, std.container, std.typecons;\nimport core.stdc.stdio;\n// foreach, foreach_reverse, writeln\n\nvoid main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tint[] d = new int[n];\n\tforeach (i; 0..n) {\n\t\tscanf(\"%d\", &d[i]);\n\t}\n\talias Tuple!(int,int) P;\n\tP[] raw_p = new P[n];\n\tforeach (i; 0..n) {\n\t\traw_p[i][0] = d[i];\n\t\traw_p[i][1] = i;\n\t}\n\tauto p = raw_p.sort;\n\tint[] sz = new int[n];\n\tP[] ans;\n\tforeach_reverse (i; 1..n) {\n\t\tint v = p[i][1];\n\t\tsz[v]++;\n\t\tint diff = (n-sz[v]) - sz[v];\n\t\tint pi = p.lowerBound(P(d[v]-diff,-1)).length.to!int;\n\t\tif (pi == n || p[pi][0] != d[v]-diff) {\n\t\t\twriteln(-1);\n\t\t\treturn;\n\t\t}\n\t\tint par = p[pi][1];\n\t\tsz[par] += sz[v];\n\t\tans ~= P(v+1, par+1);\n\t}\n\tforeach (edge; ans) {\n\t\twriteln(edge[0], ' ', edge[1]);\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.algorithm, std.range, std.conv, std.string, std.math, std.container, std.typecons;\nimport core.stdc.stdio;\n// foreach, foreach_reverse, writeln\n\nvoid main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tlong[] d = new long[n];\n\tforeach (i; 0..n) {\n\t\tscanf(\"%lld\", &d[i]);\n\t}\n\talias Tuple!(long,int) P;\n\tP[] raw_p = new P[n];\n\tforeach (i; 0..n) {\n\t\traw_p[i][0] = d[i];\n\t\traw_p[i][1] = i;\n\t}\n\tauto p = raw_p.sort.assumeSorted;\n\tint[] sz = new int[n];\n\tP[] ans;\n\tforeach_reverse (i; 1..n) {\n\t\tint v = p[i][1];\n\t\tsz[v]++;\n\t\tint diff = (n-sz[v]) - sz[v];\n\t\tint pi = p.lowerBound(P(d[v]-diff,-1)).length.to!int;\n\t\tif (pi == n || p[pi][0] != d[v]-diff) {\n\t\t\twriteln(-1);\n\t\t\treturn;\n\t\t}\n\t\tint par = p[pi][1];\n\t\tsz[par] += sz[v];\n\t\tans ~= P(v+1, par+1);\n\t}\n\tforeach (edge; ans) {\n\t\twriteln(edge[0], ' ', edge[1]);\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.algorithm, std.range, std.conv, std.string, std.math, std.container, std.typecons;\nimport core.stdc.stdio;\n// foreach, foreach_reverse, writeln\n\nvoid main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tlong[] d = new long[n];\n\tforeach (i; 0..n) {\n\t\tscanf(\"%lld\", &d[i]);\n\t}\n\talias Tuple!(long,int) P;\n\tP[] raw_p = new P[n];\n\tforeach (i; 0..n) {\n\t\traw_p[i][0] = d[i];\n\t\traw_p[i][1] = i;\n\t}\n\tauto p = raw_p.sort.assumeSorted;\n\tint[] sz = new int[n];\n\tP[] ans;\n\tforeach_reverse (i; 1..n) {\n\t\tint v = p[i][1];\n\t\tsz[v]++;\n\t\tint diff = (n-sz[v]) - sz[v];\n\t\tint pi = p.lowerBound(P(d[v]-diff,-1)).length.to!int;\n\t\tif (pi == n || p[pi][0] != d[v]-diff) {\n\t\t\twriteln(-1);\n\t\t\treturn;\n\t\t}\n\t\tint par = p[pi][1];\n\t\tsz[par] += sz[v];\n\t\tans ~= P(v+1, par+1);\n\t}\n\n\tint[][] to = new int[][](n);\n\tforeach (edge; ans) {\n\t\tint a = edge[0].to!int-1, b = edge[1]-1;\n\t\tif (d[a] > d[b]) swap(a,b);\n\t\tto[a] ~= b;\n\t}\n\tint root = p[0][1];\n\tlong dfs(int v, int depth) {\n\t\tlong ret = depth;\n\t\tforeach (int u; to[v]) ret += dfs(u,depth+1);\n\t\treturn ret;\n\t}\n\tif (dfs(root, 0) != d[root]) {\n\t\twriteln(-1);\n\t\treturn;\n\t}\n\n\tforeach (edge; ans) {\n\t\twriteln(edge[0], ' ', edge[1]);\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.algorithm, std.range, std.conv, std.string, std.math, std.container, std.typecons;\nimport core.stdc.stdio;\n// foreach, foreach_reverse, writeln\n\nvoid main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tint[] d = new int[n];\n\tforeach (i; 0..n) {\n\t\tscanf(\"%d\", &d[i]);\n\t}\n\talias Tuple!(int,int) P;\n\tP[] raw_p = new P[n];\n\tforeach (i; 0..n) {\n\t\traw_p[i][0] = d[i];\n\t\traw_p[i][1] = i;\n\t}\n\tauto p = raw_p.sort.assumeSorted;\n\tint[] sz = new int[n];\n\tP[] ans;\n\tforeach_reverse (i; 1..n) {\n\t\tint v = p[i][1];\n\t\tsz[v]++;\n\t\tint diff = (n-sz[v]) - sz[v];\n\t\tint pi = p.lowerBound(P(d[v]-diff,-1)).length.to!int;\n\t\tif (pi == n || p[pi][0] != d[v]-diff) {\n\t\t\twriteln(-1);\n\t\t\treturn;\n\t\t}\n\t\tint par = p[pi][1];\n\t\tsz[par] += sz[v];\n\t\tans ~= P(v+1, par+1);\n\t}\n\tforeach (edge; ans) {\n\t\twriteln(edge[0], ' ', edge[1]);\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.algorithm, std.range, std.conv, std.string, std.math, std.container, std.typecons;\nimport core.stdc.stdio;\n// foreach, foreach_reverse, writeln\n\nvoid main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tlong[] d = new long[n];\n\tforeach (i; 0..n) {\n\t\tscanf(\"%lld\", &d[i]);\n\t}\n\talias Tuple!(long,int) P;\n\tP[] raw_p = new P[n];\n\tforeach (i; 0..n) {\n\t\traw_p[i][0] = d[i];\n\t\traw_p[i][1] = i;\n\t}\n\tauto p = raw_p.sort.assumeSorted;\n\tint[] sz = new int[n];\n\tP[] ans;\n\tforeach_reverse (i; 1..n) {\n\t\tint v = p[i][1];\n\t\tsz[v]++;\n\t\tint diff = (n-sz[v]) - sz[v];\n\t\tint pi = p.lowerBound(P(d[v]-diff,-1)).length.to!int;\n\t\tif (pi == n || p[pi][0] != d[v]-diff) {\n\t\t\twriteln(-1);\n\t\t\treturn;\n\t\t}\n\t\tint par = p[pi][1];\n\t\tsz[par] += sz[v];\n\t\tans ~= P(v+1, par+1);\n\t}\n\n\tint[][] to = new int[][](n);\n\tforeach (edge; ans) {\n\t\tint a = edge[0].to!int, b = edge[1];\n\t\tif (d[a] > d[b]) swap(a,b);\n\t\tto[a] ~= b;\n\t}\n\tint root = p[0][1];\n\tlong dfs(int v, int depth) {\n\t\tlong ret = depth;\n\t\tforeach (int u; to[v]) ret += dfs(u,depth+1);\n\t\treturn ret;\n\t}\n\tif (dfs(root, 0) != d[root]) {\n\t\twriteln(-1);\n\t\treturn;\n\t}\n\n\tforeach (edge; ans) {\n\t\twriteln(edge[0], ' ', edge[1]);\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.algorithm, std.range, std.conv, std.string, std.math, std.container, std.typecons;\nimport core.stdc.stdio;\n// foreach, foreach_reverse, writeln\n\nvoid main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tlong[] d = new long[n];\n\tforeach (i; 0..n) {\n\t\tscanf(\"%lld\", &d[i]);\n\t}\n\talias Tuple!(long,int) P;\n\tP[] raw_p = new P[n];\n\tforeach (i; 0..n) {\n\t\traw_p[i][0] = d[i];\n\t\traw_p[i][1] = i;\n\t}\n\tauto p = raw_p.sort.assumeSorted;\n\tint[] sz = new int[n];\n\tP[] ans;\n\tforeach_reverse (i; 1..n) {\n\t\tint v = p[i][1];\n\t\tsz[v]++;\n\t\tint diff = (n-sz[v]) - sz[v];\n\t\tint pi = p.lowerBound(P(d[v]-diff,-1)).length.to!int;\n\t\tif (pi == n || p[pi][0] != d[v]-diff) {\n\t\t\twriteln(-1);\n\t\t\treturn;\n\t\t}\n\t\tint par = p[pi][1];\n\t\tsz[par] += sz[v];\n\t\tans ~= P(v+1, par+1);\n\t}\n\n\tint[][] to = new int[][](n);\n\tforeach (edge; ans) {\n\t\tint a = edge[0], b = edge[1];\n\t\tif (d[a] > d[b]) swap(a,b);\n\t\tto[a] ~= b;\n\t}\n\tint root = p[0][1];\n\tlong dfs(int v, int depth) {\n\t\tlong ret = depth;\n\t\tforeach (int u; to[v]) ret += dfs(u,depth+1);\n\t\treturn ret;\n\t}\n\tif (dfs(root, 0) != d[root]) {\n\t\twriteln(-1);\n\t\treturn;\n\t}\n\n\tforeach (edge; ans) {\n\t\twriteln(edge[0], ' ', edge[1]);\n\t}\n}"
  },
  {
    "language": "Bash",
    "code": "#include<bits/stdc++.h>\n#define inc(i,a,b) for(register int i=a;i<=b;i++)\n#define dec(i,a,b) for(register int i=a;i>=b;i--)\nusing namespace std;\ntypedef long long LL;\ntypedef pair <int ,int > pr_int;\n#define f first\n#define s second\ninline void read(int &x)\n{\n\tx=0;char c=getchar();\n\twhile(c>'9'||c<'0')c=getchar();\n\twhile(c<='9'&&c>='0')x=(x<<3)+(x<<1)+c-'0',c=getchar();\n\treturn;\n}\nconst int mx=100007;\nint main()\n{\n\treturn 0;\n} "
  },
  {
    "language": "Bash",
    "code": "#include<bits/stdc++.h>\n#define maxn 100005\n#define error {puts(\"-1\");return 0;}\n#define ll long long\nusing namespace std;\n\nmap <ll,int> mp;\n\nstruct edge{\n\tint to,nxt;\n}e[maxn<<1];\n\nstruct node{\n\tll dis;int id;\n\tbool operator < (const node &A) const {return dis>A.dis;}\n}a[maxn];\n\nstruct uv{\n\tint u,v;\n\tbool operator < (const uv &A) const {return u==A.u?v<A.v:u<A.u;}\n}ans[maxn];\n\nint cnt,head[maxn],n;ll dis[maxn],size[maxn];\n\nvoid add(int u,int v){\n\te[++cnt]=(edge){v,head[u]};\n\thead[u]=cnt;\n}\n\nvoid dfs(int u,int fa,int dep){\n\tdis[a[n].id]+=dep;size[u]=1;\n\tfor(int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif(v==fa) continue;\n\t\tdfs(v,u,dep+1);\n\t\tsize[u]+=size[v];\n\t}\n}\n\nvoid dfs(int u,int fa){\n\tfor(int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif(v==fa) continue;\n\t\tdis[v]=dis[u]+n-size[v]*2;\n\t\tdfs(v,u);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&a[i].dis);\n\t\ta[i].id=i;\n\t\tmp[a[i].dis]=i;\n\t}\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++) size[i]=1;\n\tfor(int i=1;i<n;i++){\n\t\tint u=a[i].id;\n\t\tll tmp=n-size[u]*2;\n\t\tif(tmp<=0||!mp.count(a[i].dis-tmp)) error\n\t\tint fa=mp[a[i].dis-tmp];\n\t\tsize[fa]+=size[u];\n\t\tadd(u,fa);add(fa,u);\n\t\tans[i].u=min(u,fa);\n\t\tans[i].v=max(u,fa);\n\t}\n\tsort(ans+1,ans+n);\n\tdfs(a[n].id,0,0);\n\tdfs(a[n].id,0);\n\tfor(int i=1;i<=n;i++) if(dis[a[i].id]!=a[i].dis) error\n\tfor(int i=1;i<n;i++) printf(\"%d %d\\n\",ans[i].u,ans[i].v);\n}"
  },
  {
    "language": "Bash",
    "code": "#include<stdio.h>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nmap<ll,int>p;\nmap<ll,int>::iterator it;\nint fa[100010],siz[100010],a[100010],b[100010],h[100010],nex[200010],to[200010],M,n;\nvoid add(int a,int b)\n{\n    M++;\n    to[M]=b;\n    nex[M]=h[a];\n    h[a]=M;\n}\nll wd[100010],d[100010];\nvoid dfs(int x,int dis)\n{\n    siz[x]=1;\n    d[1]+=dis;\n    for(int i=h[x];i;i=nex[i])if(to[i]!=fa[x])\n\t{\n        fa[to[i]]=x;\n        dfs(to[i],dis+1);\n        siz[x]+=siz[to[i]];\n    }\n}\nvoid dfs(int x)\n{\n    for(int i=h[x];i;i=nex[i])if(to[i]!=fa[x])\n\t{\n        d[to[i]]=d[x]+n-siz[to[i]]*2;\n        dfs(to[i]);\n    }\n}\nint get(int x){return fa[x]==x?x:(fa[x]=get(fa[x]));}\nint main()\n{\n    int i;\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++)\n\t{\n        scanf(\"%lld\",wd+i);\n        p[wd[i]]=i;\n    }\n    for(i=1;i<=n;i++)\n\t{\n        fa[i]=i;\n        siz[i]=1;\n    }\n    it=p.end();\n    for(it--;it!=p.begin();it--)\n\t{\n        if(n-siz[it->second]*2==0||!p.count(it->first-(n-siz[it->second]*2)))\n\t\t{\n            puts(\"-1\");\n            return 0;\n        }\n        M++;\n        a[M]=it->second;\n        b[M]=p[it->first-(n-siz[it->second]*2)];\n        siz[fa[a[M]]=get(b[M])]+=siz[a[M]];\n    }\n    M=0;\n    for(i=1;i<n;i++)\n\t{\n        add(a[i],b[i]);\n        add(b[i],a[i]);\n    }\n    fa[1]=0;\n    dfs(1,0);\n    dfs(1);\n    for(i=1;i<=n;i++)\n\t{\n        if(wd[i]!=d[i])\n\t\t{\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    for(i=1;i<n;i++)printf(\"%d %d\\n\",a[i],b[i]);\n}"
  },
  {
    "language": "Bash",
    "code": "#include <cstdio>\n//#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#define Maxn 1000008 \nusing namespace std;\ntypedef long long ll;\n\nint n,cnt;\nint son[Maxn];\nmap <ll,int> M;\nstruct node{\n\tint num;\n\tll val;\n}N[Maxn];\n\nbool cmp(node a,node b){\treturn a.val > b.val;}\n\nint main()\n{\n\tmemset(son,0,sizeof(son));\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\tll d;\n\t\tscanf(\"%lld\",&d);\n\t\tM[d] = i;\n\t\tN[i].num = i,N[i].val = d;\n\t}\n\tsort(N+1,N+1+n,cmp);\n\tmap<ll,int>::iterator iter;;\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\titer = M.find(N[i].val - n + 2 + (son[N[i].num] << 1));\n\t\tif(iter == M.end()) continue;\n//\t\tcout << iter->second << endl;\n\t\tint v = iter->second;\n//\t\tE[cnt].u = i;\n//\t\tE[cnt++].v = v;\n\t\tson[v] += son[N[i].num]+1;\n\t\tprintf(\"%d %d\\n\",N[i].num,v);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Bash",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#define Maxn 1000008 \nusing namespace std;\ntypedef long long ll;\n\nint n;\nll d;\nll son[Maxn];\nmap <ll,ll> M;\n\nstruct node{\n\tll num;\n\tll val;\n}N[Maxn];\n\nbool cmp(node a,node b){\treturn a.val > b.val;}\n\nint main()\n{\n\tmemset(son,0,sizeof(son));\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\tscanf(\"%lld\",&d);\n\t\tM[d] = i;\n\t\tN[i].num = i,N[i].val = d;\n\t}\n\tsort(N+1,N+1+n,cmp);\n\tmap<ll,ll>::iterator iter;;\n\tfor(int i = 1;i < n;i ++)\n\t{\n\t\tll u = N[i].num;\n\t\tif((N[i].val - n + 2 + (son[u] << 1)) < N[n].val) continue;\n\t\titer = M.find(N[i].val - n + 2 + (son[u] << 1));\n\t\tif(iter == M.end()) continue;\n\t\tll v = iter->second;\n\t\tson[v] += son[u]+1;\n\t\tprintf(\"%lld %lld\\n\",u,v);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Bash",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int maxn = 101010;\nstruct Node{\n    int num;\n    ll d;\n    bool operator < (const Node &tx) const {\n        return d < tx.d;\n    }\n}a[maxn];\nint n, flag;\nint siz[maxn];\n\nqueue<int> q[2];\nvector<pair<int, int> > ans;\n\nint main(){\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i ++){\n        scanf(\"%lld\", &a[i].d);\n        a[i].num = i;\n    }\n\n    sort(a+1, a+1+n);\n\n    q[a[1].d & 1].push(1);\n    siz[a[1].num] = n - 1;\n    int tem_flag = n & 1;\n    \n    for(int i = 2; i <= n; i ++){\n        if(q[1 & (a[i].d ^ tem_flag)].empty()){\n            printf(\"-1\");\n            return 0;\n        }\n        int tem_num = q[1 & (a[i].d ^ tem_flag)].front();\n\n        ll diff = a[i].d - a[tem_num].d;\n        int diff_siz = (n - diff) / 2;\n        \n        siz[a[i].num] = diff_siz - 1;\n        siz[a[tem_num].num] -= diff_siz;\n\n        if(diff_siz > 1)\n            q[a[i].d & 1].push(i);\n        ans.push_back(make_pair(a[i].num, a[tem_num].num));\n        if(siz[a[tem_num].num] <= 0) q[1 & (a[i].d ^ tem_flag)].pop();\n    }\n\n    for(int i = 1; i <= n; i ++){\n        if(siz[i]){\n            printf(\"debug : %d\\n\", i);\n            return 0;\n        }\n    }\n\n    int siz = ans.size() - 1;\n    for(int i = 0; i <= siz; i ++)\n        printf(\"%d %d\\n\", ans[i].first, ans[i].second);\n\n}"
  },
  {
    "language": "Bash",
    "code": "#include<cstdio>\n#include<map>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\nconst int maxn=1e5+2;\nint n;\nmap<LL,int> mp;\nLL dis[maxn];\nint id[maxn],fa[maxn],siz[maxn];\nbool cmp(int x,int y){\n\treturn dis[x]>dis[y];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(\"%lld\",&dis[i]);\n\t\tsiz[i]=1;\n\t\tid[i]=mp[dis[i]]=i;\n\t}\n\tsort(id+1,id+n+1,cmp);\n\tfor (int i=1;i<n;i++){\n\t\tfa[id[i]]=mp[dis[id[i]]-n+2*siz[id[i]]];\n\t\tif (!fa[id[i]]){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tsiz[fa[id[i]]]+=siz[id[i]];\n\t}\n\tfor (int i=1;i<n;i++) dis[id[n]]-=siz[id[i]];\n\tif (dis[id[n]]){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++) printf(\"%d %d\\n\",fa[id[i]],id[i]);\n\treturn 0;\n}"
  },
  {
    "language": "Bash",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+3;\nint n,siz[N];\nbool b[N];\nstruct syzs{\n\tint val,num;\n} a[N];\nstruct ans{\n\tint e1,e2;\n\tbool operator <(const ans &emm) const{\n\t    if(emm.e1==e1) return e2>emm.e2;\n\t\treturn emm.e1<e1;\n\t}\n};\nbool cmp(syzs c,syzs b){\n\treturn c.val>b.val;\n}\nint find(int k){\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i].val==a[k].val+2*siz[k]-n&&i!=k) return i;\n\t}\n\treturn -1;\n}\nint main(){\n\tpriority_queue <ans> q;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i].val);\n\t\ta[i].num=i;\n\t\tsiz[i]=1;\n\t}\n\tsort(a+1,a+n+1,cmp);\n\tb[1]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tint v=find(i);\n\t\tif(v==-1){\n\t\t\tif(i!=n) puts(\"-1\"),exit(0);\n\t\t\telse continue;\n\t\t}\n\t\tsiz[v]+=siz[i];\n\t\tq.push((ans) {min(a[v].num,a[i].num),max(a[v].num,a[i].num)});\n\t}\n\twhile(!q.empty()){\n\t\tint v1=q.top().e1,v2=q.top().e2;\n    \tq.pop();\n    \tprintf(\"%d %d\\n\",v1,v2);\n\t}\n}"
  },
  {
    "language": "Bash",
    "code": "#include<bits/stdc++.h>\n#define rep(X,A,B) for(int X=A;X<=B;X++)\n#define tep(X,A,B) for(int X=A;X>=B;X--)\n#define LL long long\n#define DB double\nconst int N=400010;\nconst int M=800010;\nusing namespace std;\n\nint n;\nmap<LL,int> mp;\nLL sz[N];\nint fa[N],edge[M],lst[N],nxt[M],t=0;\n\nstruct nn{\n\tLL d;\n\tint id;\n}a[N];\n\nint cmp(nn A,nn B){\n\treturn A.d<B.d;\n}\n\nvoid READ(){\n\tscanf(\"%d\",&n);\n\trep(i,1,n)scanf(\"%lld\",&a[i].d),a[i].id=i,mp[a[i].d]=i;\n\tsort(a+1,a+n+1,cmp);\n}\n\nvoid ADD(int x,int y){\n\tedge[++t]=y;nxt[t]=lst[x];lst[x]=t;\n}\n\nLL SEARCH(int x,int dep){\n\tLL res=dep;\n\tfor(int r=lst[x];r;r=nxt[r]){\n\t\tres+=SEARCH(edge[r],dep+1);\n\t}\n\treturn res;\n}\n\nint SOLVE(){\n\trep(i,1,n)sz[i]=1;\n\ttep(i,n,2){\n\t\tint x=a[i].id;\n\t\tLL d=a[i].d;\n\t\tLL now=d+2*sz[x]-n;\n\t\tint pos=mp[now];\n\t\tif(pos==0||now>=a[i].d)return 0;\n\t\tfa[x]=pos;\n\t\tADD(fa[x],x);\n\t\tsz[fa[x]]+=sz[x];\n\t}\n\tLL sum=SEARCH(a[1].id,0);\n\tif(sum!=a[1].d)return 0;\n\trep(i,1,n){\n\t\tif(i==a[1].id)continue;\n\t\tprintf(\"%d %d\\n\",i,fa[i]);\n\t}\n\treturn 1;\n}\n\nint main(){\n\tREAD();\n\tif(!SOLVE())printf(\"-1\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "Bash",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <map>\n#define Maxn 100008 \nusing namespace std;\ntypedef long long ll;\n\nint n,cnt;\nint son[Maxn];\nmap <ll,int> M;\nstruct node{\n\tint num;\n\tll val;\n}N[Maxn];\n\nstruct edge{\n\tint u,v;\n}E[Maxn];\n\nbool cmp(node a,node b){\treturn a.val > b.val;}\n\nint main()\n{\n\tmemset(son,0,sizeof(son));\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\tll d;\n\t\tscanf(\"%lld\",&d);\n\t\tM[d] = i;\n\t\tN[i].num = i,N[i].val = d;\n\t}\n\tsort(N+1,N+1+n,cmp);\n\tmap<ll,int>::iterator iter;;\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\titer = M.find(N[i].val - n + 2 + (son[N[i].num] << 1));\n\t\tif(iter == M.end()) continue;\n//\t\tcout << iter->second << endl;\n\t\tint v = iter->second;\n//\t\tE[cnt].u = i;\n//\t\tE[cnt++].v = v;\n\t\tson[v] += son[N[i].num]+1;\n\t\tprintf(\"%d %d\\n\",N[i].num,v);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Bash",
    "code": "#include<cstdio>\n#include<string>\n#include<cstring>\n#include<utility>\n#include<cmath>\n#include<map>\n#include<queue>\n#include<set>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#define ll long long\n#define pii pair<int,int>\n#define mp make_pair\n#define fi first\n#define se second\n#define inf 0x7fffffff\nusing namespace std;\nint a[100010];\npii b[100010],c[100010];\nint main()\n{\n\tint i,j,k,n,m,x,y,x1,n1;\n\tscanf(\"%d\",&n);\n\tn1=n;\n\tfor(i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tb[i].fi=a[i];\n\t\tb[i].se=i+1;\n\t\tc[i]=b[i];\n\t}\n\tsort(b,b+n);\n\tvector<int> cl;\n\twhile(n>1)\n\t{\n\t\tx=n-1;\n\t\ti=2;\n\t\tk=0;\n\t\tcl.clear();\n\t\twhile(x!=0&&k<n)\n\t\t{\n\t\t\tj=b[x].fi-n1+i;\n\t\t\tif(j<y)\n\t\t\t{\n\t\t\t\tprintf(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\ti+=2;\n\t\t\tx1=lower_bound(b,b+n,mp(j,0))-b;\n\t\t\tif(b[x1].fi!=j)\n\t\t\t{\n\t\t\t\tprintf(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcl.push_back(x);\n\t\t\tk++;\n\t\t\tx=x1;\n\t\t}\n\t\tif(k>=n)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(i=0;i<cl.size();i++)\n\t\t{\n\t\t\tb[cl[i]]=mp(0,0);\n\t\t}\n\t\tsort(b,b+n);\n\t\treverse(b,b+n);\n\t\treverse(b,b+n-k);\n\t\tn-=k;\n\t}\n\tn=n1;\n\tsort(c,c+n);\n\twhile(n>1)\n\t{\n\t\tx=n-1;\n\t\ti=2;\n\t\tk=0;\n\t\tcl.clear();\n\t\twhile(x!=0&&k<n)\n\t\t{\n\t\t\tj=c[x].fi-n1+i;\n\t\t\ti+=2;\n\t\t\tx1=lower_bound(c,c+n,mp(j,0))-c;\n\t\t\tprintf(\"%d %d\\n\",c[x].se,c[x1].se);\n\t\t\tcl.push_back(x);\n\t\t\tk++;\n\t\t\tx=x1;\n\t\t}\n\t\tif(k>=n)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(i=0;i<cl.size();i++)\n\t\t{\n\t\t\tc[cl[i]]=mp(0,0);\n\t\t}\n\t\tsort(c,c+n);\n\t\treverse(c,c+n);\n\t\treverse(c,c+n-k);\n\t\tn-=k;\n\t}\n\treturn 0;\n}/*\n7\n10\n15\n13\n18\n11\n14\n19\n*/"
  },
  {
    "language": "Python",
    "code": "\n\n\nN=int(input())\nnumlist=[int(input()) for _ in range(N)]\nnumdict={y:x+1 for x,y in enumerate(numlist)}\nsorted_list=sorted(numdict.items(),reverse=True)\n\n\nnextS=lambda Snow,Bnow : Snow+2*Bnow-N\nBnow=1\nbranch_list=[]\nSnow,num=(sorted_list[0][0],numdict.pop(sorted_list[0][0]))\nwhile numdict:\n  S=nextS(Snow,Bnow)\n  if S in numdict:\n    branch_list.append([num,numdict[S]])\n    Bnow+=1\n    Snow,num=S,numdict.pop(S)\n  else:\n    for x in range(1,(N-Bnow)//2):\n      S=nextS(Snow,N-x)\n      if S in numdict:\n        x-=1\n        can=[[num,S]]\n        while x:\n          Sbuf=S\n          S=nextS(S,N-x)\n          can.append([numdict[Sbuf],S])\n          if not S in numdict:\n            break\n          x-=1\n        else:\n          for buf in can:\n            branch_list.append([buf[0],numdict.pop(buf[1])])\n          Bnow=len(branch_list)+1\n          break\n    else:\n      print(-1)\n      exit()\n\nfor _ in range(N-1):\n  x,y=branch_list.pop()\n  print(x,y)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nfrom sys import stdin\nimport numpy as np\n# import sys\n# sys.setrecursionlimit(10**4)\n\ndef _li(): return list(map(int, stdin.readline().split()))\ndef _li_(): return list(map(lambda x: int(x)-1, stdin.readline().split()))\ndef _lf(): return list(map(float, stdin.readline().split()))\ndef _ls(): return stdin.readline().split()\ndef _i(): return int(stdin.readline())\ndef _f(): return float(stdin.readline())\ndef _s(): return stdin.readline()[:-1]\n\n\nN = _i()\nD_list = np.array([_i() for _ in range(N)])\nidx = np.argsort(D_list)\nsorted_D = D_list[idx]\nmapping = {}\nfor i, j in enumerate(idx):\n    mapping[i] = j+1\n\n# 解説を参考に実装\n# Dのスコアが大きい方から小さい方へ伸びる有向エッジとみなす\n# valueはノードから出ている有向エッジを切った場合の部分木の大きさ\nnodes = {i: 1 for i in range(N)}\nans = []\ncost = [[0, 1] for _ in range(N)]\n# 葉っぱから見て，[エッジにたどり着くまでのコスト, 自分も含めた子ノードの数]\nfor i in range(N-1, 0, -1):\n    d = sorted_D[i]\n    sub = nodes[i]\n    target = d + 2*sub - N\n    # print(target, sorted_D[:i])\n    cand = np.searchsorted(sorted_D[:i], target)\n    if cand == i or sorted_D[cand] != target:\n        print(-1)\n        exit()\n    else:\n        ans.append((mapping[i], mapping[cand]))\n        nodes[cand] += nodes[i]\n        cost[cand][0] += (cost[i][0] + cost[i][1])\n        cost[cand][1] += cost[i][1]\n\n# 1番目のノードについてチェック\nif cost[0][0] != sorted_D[0]:\n    print(-1)\n    exit()\nelse:\n    for a in ans:\n        print(a[0], a[1])\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\" outputの時間比較 \"\"\"\nfrom sys import stdin, stdout\nimport numpy as np\n# import sys\n# sys.setrecursionlimit(10**4)\n\ndef _li(): return list(map(int, stdin.readline().split()))\ndef _li_(): return list(map(lambda x: int(x)-1, stdin.readline().split()))\ndef _lf(): return list(map(float, stdin.readline().split()))\ndef _ls(): return stdin.readline().split()\ndef _i(): return int(stdin.readline())\ndef _f(): return float(stdin.readline())\ndef _s(): return stdin.readline()[:-1]\nd_in = lambda: int(stdin.readline())  # N = d_in()\nds_in = lambda: list(map(int, stdin.readline().split()))  # List = ds_in()\ndef print_list(s):\n    stdout.write(' '.join(list(map(str, s))) + '\\n')\n    # stdout.flush()\ndef print_single(s):\n    stdout.write(str(s) + '\\n')\n    # stdout.flush()\n\n\n# N = _i()\n# D_list = np.array([_i() for _ in range(N)])\nN = d_in()\nD_list = np.array([d_in() for _ in range(N)])\n\n\nidx = np.argsort(D_list)\nsorted_D = D_list[idx]\nmapping = []\nfor j in idx:\n    mapping.append(j+1)\n\n# 解説を参考に実装\n# Dのスコアが大きい方から小さい方へ伸びる有向エッジとみなす\n# valueはノードから出ている有向エッジを切った場合の部分木の大きさ\nnodes = [1] * N\nans = []\ncost = [[0, 1] for _ in range(N)]\n# 葉っぱから見て，[エッジにたどり着くまでのコスト, 自分も含めた子ノードの数]\nfor i in range(N-1, 0, -1):\n    d = sorted_D[i]\n    sub = nodes[i]\n    target = d + 2*sub - N\n    cand = np.searchsorted(sorted_D[:i], target)\n    if (sorted_D[cand] != target) or (cand == i):\n        print(-1)\n        exit()\n    else:\n        ans.append((mapping[i], mapping[cand]))\n        nodes[cand] += nodes[i]\n        cost[cand][0] += (cost[i][0] + cost[i][1])\n        cost[cand][1] += cost[i][1]\n\n# 1番目のノードについてチェック\nif cost[0][0] != sorted_D[0]:\n    print(-1)\n    exit()\nelse:\n    for a in ans:\n        # print(a[0], a[1])\n        print_list(a)\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    N = int(raw_input())\n    Di = []\n    sum = 0\n    for i in range(N):\n        di = int(raw_input())\n        sum += di\n        Di.append((di, i))\n    if sum % 2 > 0:\n        print '-1'\n        return\n    Di.sort(key = lambda x : x[0] ,reverse = True)\n    d_to_i = {dd:i for dd, i in Di}\n    # child = [[] for i in range(N)]\n    ans = []\n    n_child = [1] * N\n    d_child = [0] * N\n    for valD, node in Di:\n        valD_par = valD - N + 2 * n_child[node]\n        if valD_par in d_to_i.keys():\n            node_par = d_to_i[valD_par]\n            # child[node].append(node_par) ##\n            # child[node_par].append(node)\n            ans.append([node_par + 1, node + 1])\n            n_child[node_par] += n_child[node]\n            d_child[node_par] += n_child[node] + d_child[node]\n            if n_child[node_par] == N:\n                break\n        else:\n            print '-1'\n            return\n    # check if Di satisfied or not\n    d_min, i_min = Di[-1]\n    if d_child[i_min] != d_min:\n        print '-1'\n        return\n    # for i in range(N):\n    #     for j in child[i]:\n    #         print str(i + 1) + ' ' + str(j + 1)\n    for ele in ans:\n        print str(ele[0]) + ' ' + str(ele[1])\n\nif __name__ == '__main__':\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    N = int(raw_input())\n    D = [int(raw_input()) for i in range(N)]\n    if sum(D) % 2 > 0:\n        print '-1'\n        return\n    Di = sorted([(di, i) for i, di in enumerate(D)], key = lambda x : x[0], reverse = True)\n    d_to_i = {dd:i for dd, i in Di}\n    ans = []\n    n_child = [1] * N\n    d_child = [0] * N\n    for valD, node in Di:\n        valD_par = valD - N + 2 * n_child[node]\n        if valD_par in d_to_i.keys():\n            node_par = d_to_i[valD_par]\n            ans.append((node_par + 1, node + 1))\n            n_child[node_par] += n_child[node]\n            d_child[node_par] += n_child[node] + d_child[node]\n            if n_child[node_par] == N:\n                break\n        else:\n            print '-1'\n            return\n    # check if Di satisfied or not\n    d_min, i_min = Di[-1]\n    if d_child[i_min] != d_min:\n        print '-1'\n        return\n    for i,j in ans:\n        print str(i) + ' ' + str(j)\n\nif __name__ == '__main__':\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "def solve(n, ddd):\n    dsd = {d: i for i, d in enumerate(ddd)}\n    child_cnt = [1] * n\n    child_dist = [0] * n\n    buf = []\n    srt = sorted(dsd.items(), reverse=True)\n    for d, i in srt[:-1]:\n        cc = child_cnt[i]\n        pd = d - (n - cc * 2)\n        if pd == d or pd not in dsd:\n            return -1\n        pi = dsd[pd]\n        buf.append((pi + 1, i + 1))\n        child_cnt[pi] += cc\n        child_dist[pi] += child_dist[i] + cc\n\n    md, mi = srt[-1]\n    if md != child_dist[mi]:\n        return -1\n    return buf\n\n\nn = int(input())\nddd = list(map(int, (input() for _ in range(n))))\nres = solve(n, ddd)\nif res == -1:\n    print(-1)\nelse:\n    print('\\n'.join('{} {}'.format(*l) for l in res))\n"
  },
  {
    "language": "Python",
    "code": "def solve(n, ddd):\n    dsd = {d: i for i, d in enumerate(ddd)}\n    child_cnt = [1] * n\n    buf = []\n    for d, i in sorted(dsd.items(), reverse=True)[:-1]:\n        cc = child_cnt[i]\n        pd = d - (n - cc * 2)\n        if pd == d or pd not in dsd:\n            return -1\n        pi = dsd[pd]\n        buf.append((pi + 1, i + 1))\n        child_cnt[pi] += cc\n    return buf\n\n\nn = int(input())\nddd = list(map(int, (input() for _ in range(n))))\nres = solve(n, ddd)\nif res == -1:\n    print(-1)\nelse:\n    print('\\n'.join('{} {}'.format(*l) for l in res))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom bisect import bisect_left\n\nn = int(input())\nd = sorted([[int(input()), i+1] for i in range(n)])\nind = [x[1] for x in d]\nd = [x[0] for x in d]\nif n <= 3:\n\tprint(-1)\n\tsys.exit()\ngap = [n-2 for _ in range(n)]\nans = []\nfor i in range(n-1, 0, -1):\n\tx = d[i]\n\tb = bisect_left(d, x - gap[i])\n\tif d[b] != x - gap[i]:\n\t\tprint(-1)\n\t\tsys.exit()\n\telse:\n\t\tgap[b] = gap[i] - 2\n\t\tans.append([ind[b], ind[i]])\n\nfor a in ans:\n\tprint(*a)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\na = []\ns = []\n\nfor i in range(n):\n    x = int(input())\n    a.append(x * n + i)\n    s.append(1)\n\na.sort()\na.reverse()\na.append(-1)\nSum = 0\n\nHave = True\n\nresult = []\n\nfor i in range(n - 1):\n    l = 0\n    r = n\n\n    val = (a[i] // n) + s[i] + s[i] - n\n\n    while (l < r):\n        m = (l + r + 2) // 2\n\n        if (a[m] >= val * n):\n            l = m\n        else:\n            r = m - 1\n\n    if((a[l] // n) != val):\n        Have = False\n        break\n\n    s[l] += s[i]\n    Sum  += s[i]\n    result.append([a[i] % n,a[l] % n])\n\nif (Sum != (a[n - 1] // n)):\n    Have = False\n\nif (Have == False):\n    print(\"-1\")\nelse:\n    for e in result:\n        print(e[0] + 1,end = \" \")\n        print(e[1] + 1)\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    N = int(raw_input())\n    Di = []\n    sum = 0\n    for i in range(N):\n        di = int(raw_input())\n        sum += di\n        Di.append([i, di])\n    if sum % 2 > 0:\n        print '-1'\n        return\n    Di.sort(key = lambda x : x[1])\n    d_to_i = {di[1]:di[0] for di in Di}\n    child = [[] for i in range(N)]\n    n_child = [1] * N\n    d_child = [0] * N\n    for ind in range(N - 1, 0, -1):\n        node = Di[ind][0]\n        valD_par = Di[ind][1] - N + 2 * n_child[node]\n        if valD_par in d_to_i.keys():\n            node_par = d_to_i[valD_par]\n            # child[node].append(node_par) ##\n            child[node_par].append(node)\n            n_child[node_par] += n_child[node]\n            d_child[node_par] += n_child[node] + d_child[node]\n        if n_child[node_par] == N:\n            # check if Di satisfied or not\n            if d_child[node_par] != Di[0][1]:\n                print '-1'\n                return\n            break\n    for i in range(N):\n        for j in child[i]:\n            print str(i + 1) + ' ' + str(j + 1)\n\nif __name__ == '__main__':\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\nWriter: SPD_9X2\nhttps://atcoder.jp/contests/arc103/tasks/arc103_d\n\n面白そう！\nとっかかりはどのへんだろうか\n\n偶奇あたりから考えてみる？\nまず、A→BとA←B　の距離は等しいので、Dの合計は絶対偶数になる\nDの和が奇数なら構築不可能\n\n辺u,vを取り除いて,2つの部分木に分解する、各木の含む頂点数を x[u],x[v]とすると\nD[u]+x[u] == D[v]+x[v]　となる (x[u] + x[v] == N)\n\n最大のDについて考えてみよう\n最大のDから繋がってる点を根とした部分木は少なくとも半分の数の要素を含む\nなので、Dmaxは2つ以上辺を持っていてはいけない→Dmaxは葉\n\nDmaxを置くと、それとつながる要素のdは1意に定まる\n残り(unused)の頂点の内、最大のを考える。\nこいつももう葉になるしかない\n1意に定まりんぐ\n\nん～？\nこんな感じで大を小につけていけば構築完了するんじゃね？\n小-大-小　となることはない(小の成分は半分以上の点を含むため)　なのでおｋそう！\n\nD[u] > D[v]のとき\nD[v] = D[u] + x[u] - x[v]\nx[v] = N-x[u]なので\nD[v] = D[u] + 2*x[u] - N\n\nだめな理由がわからないが…\n可能性1: 大が2つ以上の小に繋がってる場合がある(可能を-1にしてる)\n可能性2: 実は構築したやつが条件を満たしてない(-1を可能にしてる)\n→どっちもそんなこと無さそうなのに…\n\n====テストケースを見たら2っぽさそう====\n可能性2の方をつぶそう\n→連結じゃない？自分より小さいdにすべて繋いでるんだからそんなことないだろ\n\nじゃあ場合によってはxが違う？\n→どんな場合よ？\n→うーん？　最後に一応チェック機構入れるか\n→つまりジャッジを書く\n\n簡易的に、xに問題が生じてそうなとき(根がNになってないとき)は-1にするようにしてみた\n→xの数がちゃんと計算されていないわけではない？？\n\n===kmjp氏のぶろぐ===\n検算が必要？？なんで？\ndの条件は必要条件であって十分条件ではないからか！\n→むずいよ…\ndの間に成り立つべき関係を書いただけで、d全部がずれてる可能性があると…\n\n→つまり1頂点の付いて成立すればいいので、根のdを調べてあげればいいか\n\"\"\"\n\nimport sys\nN = int(input())\n\nDz = 0\nDi = []\nd_to_ind = {}\n\nfor i in range(N):\n    d = int(input())\n    if i == 0:\n        Dz = d\n    Di.append([d,i])\n    d_to_ind[d] = i\n\nDi.sort()\nDi.reverse()\n\nx = [1] * N\nans = []\nlis = [ [] for i in range(N) ]\n\nfor lp in range(N-1):\n\n    nowd,nowi = Di[lp]\n\n    nexd = nowd + 2*x[nowi] - N\n\n    if nexd >= nowd:\n        print (-1)\n        sys.exit()\n\n    if nexd not in d_to_ind:\n        print (-1)\n        sys.exit()\n\n    nexi = d_to_ind[nexd]\n    x[nexi] += x[nowi]\n    ans.append([nowi+1,nexi+1])\n    lis[nowi].append(nexi)\n    lis[nexi].append(nowi)\n\n#ジャッジを書く(1頂点について成立すればおｋ)\nfrom collections import deque\nq = deque([0])\ndis = [float(\"inf\")] * N\ndis[0] = 0\nwhile len(q) > 0:\n    now = q.popleft()\n    for nex in lis[now]:\n        if dis[nex] > dis[now]:\n            dis[nex] = dis[now] + 1\n            q.append(nex)\n\nif sum(dis) != Dz:\n    print (-1)\n    sys.exit()\n\nfor i in range(N-1):\n\n    print (ans[i][0] , ans[i][1])\n    \n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nsrc = [int(input()) for i in range(N)]\nidx = {a:i for i,a in enumerate(src)}\n\nsize = [1] * N\nss = list(sorted(src))\n\nes = []\nwhile len(ss) > 1:\n    a = ss.pop()\n    k = size[idx[a]]\n    b = a + 2*k - N\n    if b == a or b not in idx:\n        print(-1)\n        exit()\n    size[idx[b]] = k + 1\n    es.append((idx[a],idx[b]))\n\ngr = [[] for i in range(N)]\nfor a,b in es:\n    gr[a].append(b)\n    gr[b].append(a)\n\nfrom collections import deque\ndist = [N] * N\ndist[idx[ss[0]]] = 0\nq = deque([idx[ss[0]]])\nwhile q:\n    v = q.popleft()\n    for to in gr[v]:\n        if dist[to] < N: continue\n        q.append(to)\n        dist[to] = dist[v] + 1\n\nif all(d<N for d in dist) and sum(dist) == ss[0]:\n    for a,b in es:\n        print(a+1, b+1)\nelse:\n    print(-1)"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nD = sorted([int(input()) for i in range(N)])[::-1]\n# D=[42, 45, 47, 50, 51, 54, 57, 62, 63, 66, 74, 75, 77, 87, 90][::-1]\n# D=[10, 11, 13, 14, 15, 18, 19][::-1]\n# N=len(D)\n\nX=[] # i:id /parent id / D / L / parent D / T\ncnt=0\nfor i in range(N):\n    child = [j[4] for j in X]\n    L=1\n    T=0\n    if (D[i] in child):\n        # L = sum([j[3]*(j[4]==D[i]) for j in X]) + 1\n        # T = sum([(j[5]+j[3])*(j[4]==D[i]) for j in X])\n        # cnt += sum([1*(j[4]==D[i]) for j in X])\n        # print (i, D[i], L)\n        for j in X:\n            if j[4]==D[i]:\n                L += j[3]\n                T += j[5]+j[3]\n                j[1]=i\n                cnt += 1\n    X.append([i, -1, D[i], L, D[i]-N+2*L, T])\n\n\nif N < 5 or X[N-1][0]!=N-1 or cnt!=N-1 or X[N-1][2] != X[N-1][5]:\n    print (-1)\nelse:\n    for i in range(N-1):\n        print (X[i][1]+1,i+1)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**7)\nn = int(input())\nd = [int(input()) for _ in range(n)]\nr = {v: i for i, v in enumerate(d)}\nsz = [1] * n\ndsorted = sorted(((di, i) for i, di in enumerate(d)), reverse=True)\nans = []\nto = [[] for _ in range(n)]\nfor di, i in dsorted[:n-1]:\n    nd = di + (sz[i] - 1) - (n - 2 - (sz[i] - 1))\n    if not nd in r:\n        print(-1)\n        exit()\n    p = r[nd]\n    to[p].append(i)\n    sz[p] += sz[i]\n    ans.append((i+1, p+1))\n\nroot = dsorted[-1][1]\ndef dfs(u, cur=0):\n    rv = cur\n    for v in to[u]:\n        rv += dfs(v, cur + 1)\n    return rv\n\nif dfs(root) != d[root]:\n    print(-1)\n    exit()\n\nfor u, v in ans:\n    print(u, v)\n"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\nWriter: SPD_9X2\nhttps://atcoder.jp/contests/arc103/tasks/arc103_d\n\n面白そう！\nとっかかりはどのへんだろうか\n\n偶奇あたりから考えてみる？\nまず、A→BとA←B　の距離は等しいので、Dの合計は絶対偶数になる\nDの和が奇数なら構築不可能\n\n辺u,vを取り除いて,2つの部分木に分解する、各木の含む頂点数を x[u],x[v]とすると\nD[u]+x[u] == D[v]+x[v]　となる (x[u] + x[v] == N)\n\n最大のDについて考えてみよう\n最大のDから繋がってる点を根とした部分木は少なくとも半分の数の要素を含む\nなので、Dmaxは2つ以上辺を持っていてはいけない→Dmaxは葉\n\nDmaxを置くと、それとつながる要素のdは1意に定まる\n残り(unused)の頂点の内、最大のを考える。\nこいつももう葉になるしかない\n1意に定まりんぐ\n\nん～？\nこんな感じで大を小につけていけば構築完了するんじゃね？\n小-大-小　となることはない(小の成分は半分以上の点を含むため)　なのでおｋそう！\n\nD[u] > D[v]のとき\nD[v] = D[u] + x[u] - x[v]\nx[v] = N-x[u]なので\nD[v] = D[u] + 2*x[u] - N\n\"\"\"\n\nimport sys\nN = int(input())\n\nDi = []\nd_to_ind = {}\n\nfor i in range(N):\n    d = int(input())\n    Di.append([d,i])\n    d_to_ind[d] = i\n\nDi.sort()\nDi.reverse()\n\nx = [1] * N\nans = []\n\nfor lp in range(N-1):\n\n    nowd,nowi = Di[lp]\n\n    nexd = nowd + 2*x[nowi] - N\n\n    if nexd >= nowd:\n        print (-1)\n        sys.exit()\n\n    if nexd not in d_to_ind:\n        print (\"-1\")\n        sys.exit()\n\n    nexi = d_to_ind[nexd]\n    x[nexi] += x[nowi]\n    ans.append([nowi+1,nexi+1])\n\nfor i in range(N-1):\n\n    print (ans[i][0] , ans[i][1])\n    "
  },
  {
    "language": "Python",
    "code": "print(\"-1\")"
  },
  {
    "language": "Python",
    "code": "def solve():\n    N = int(raw_input())\n    D = [int(raw_input()) for i in range(N)]\n    if sum(D) % 2 > 0:\n        print '-1'\n        return\n    Di = sorted([(di, i) for i, di in enumerate(D)], key = lambda x : x[0], reverse = True)\n    d_to_i = {dd:i for dd, i in Di}\n    # child = [[] for i in range(N)]\n    ans = []\n    n_child = [1] * N\n    d_child = [0] * N\n    for valD, node in Di:\n        valD_par = valD - N + 2 * n_child[node]\n        if valD_par in d_to_i.keys():\n            node_par = d_to_i[valD_par]\n            # child[node].append(node_par) ##\n            # child[node_par].append(node)\n            ans.append((node_par + 1, node + 1))\n            n_child[node_par] += n_child[node]\n            d_child[node_par] += n_child[node] + d_child[node]\n            if n_child[node_par] == N:\n                break\n        else:\n            print '-1'\n            return\n    # check if Di satisfied or not\n    d_min, i_min = Di[-1]\n    if d_child[i_min] != d_min:\n        print '-1'\n        return\n    # for i in range(N):\n    #     for j in child[i]:\n    #         print str(i + 1) + ' ' + str(j + 1)\n    for i,j in ans:\n        print str(i) + ' ' + str(j)\n\nif __name__ == '__main__':\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom bisect import bisect_left\ndef input():\n\treturn sys.stdin.readline()[:-1]\nsys.setrecursionlimit(10**6)\n\nn = int(input())\nd = [[int(input()), i+1] for i in range(n)]\ncheck = d[0][0]\nd.sort()\nind = [x[1] for x in d]\nd = [x[0] for x in d]\nif n <= 3:\n\tprint(-1)\n\tsys.exit()\n#print(d)\nchild = [1 for _ in range(n)]\n#print(gap)\nans = []\nadj = [[] for _ in range(n)]\nfor i in range(n-1, 0, -1):\n\tx = d[i]\n\tb = bisect_left(d, x - n + 2*child[i])\n\t#print(i, x, n - 2+child[i], b)\n\tif d[b] != x - n + 2*child[i] or n <= 2*child[i]:\n\t\tprint(-10)\n\t\tsys.exit()\n\telse:\n\t\tchild[b] += child[i]\n\t\tans.append([ind[b], ind[i]])\n\t\tadj[ind[b]-1].append(ind[i]-1)\n\t\tadj[ind[i]-1].append(ind[b]-1)\n\n\nres = 0\ndef dfs(x, p, dis):\n\tglobal res\n\tres += dis\n\tfor v in adj[x]:\n\t\tif v == p:\n\t\t\tcontinue\n\t\telse:\n\t\t\tdfs(v, x, dis+1)\n\treturn\n\ndfs(0, -1, 0)\n#print(res, d[ind[0]])\nif res == check:\n\tfor a in ans:\n\t\tprint(*a)\nelse:\n\tprint(-1)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nN = int(input())\nC = defaultdict(int)\nfor i in range(N):\n  D = int(input())\n  C[D] = i + 1\nE = []\nH = [1] * (N + 1)\nDD = sorted([[k, v] for k, v in C.items()], reverse=True)\nAdj = [[] for i in range(N)]\nfor D, n in DD[:-1]:\n  try:\n    p = C[D - N + 2 * H[n]]\n    if n == p:\n      raise Error\n    E.append([n, p])\n    Adj[n - 1].append(p - 1)\n    Adj[p - 1].append(n - 1)\n    H[p] += H[n]\n  except:\n    print(-1)\n    break\nelse:\n  dist = [N] * N\n  dist[DD[-1][1] - 1] = 0\n  Q = [DD[-1][1] - 1]\n  while Q:\n    s = Q[0]\n    Q = Q[1:]\n    for adj in Adj[s]:\n      if dist[s] + 1 < dist[adj]:\n        dist[adj] = dist[s] + 1\n        Q.append(adj)\n  if sum(dist) == DD[-1][0]:\n    for e in E:\n      print(e[0], e[1])\n  else:\n    print(-1)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nN = int(input())\nC = defaultdict(int)\nfor i in range(N):\n  D = int(input())\n  C[D] = i + 1\nE = []\nH = [1] * (N + 1)\nDD = sorted([[k, v] for k, v in C.items()], reverse=True)\nAdj = [[] for i in range(N)]\nfor D, n in DD[:-1]:\n  try:\n    p = C[D - N + 2 * H[n]]\n    if n == p:\n      raise Error\n    E.append([n, p])\n    Adj[n - 1].append(p - 1)\n    Adj[p - 1].append(n - 1)\n    H[p] += H[n]\n  except:\n    print(-1)\n    break\nelse:\n  dist = [N] * N\n  dist[DD[-1][1] - 1] = 0\n  Q = [N] * N\n  Q[0] = [DD[-1][1] - 1]\n  for i in range(N):\n    s = Q[i]\n    if s == N:\n      break\n    for adj in Adj[s]:\n      if dist[adj] == N:\n        dist[adj] = dist[s] + 1\n        Q.append(adj)\n  if sum(dist) == DD[-1][0]:\n    for e in E:\n      print(e[0], e[1])\n  else:\n    print(-1)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nN = int(input())\nC = defaultdict(int)\nfor i in range(N):\n  D = int(input())\n  C[D] = i + 1\nE = []\nH = [1] * (N + 1)\nfor D, n in sorted([[k, v] for k, v in C.items()], reverse=True)[:-1]:\n  try:\n    p = C[D - N + 2 * H[n]]\n    if n == p:\n      raise Error\n    E.append([n, p])\n    H[p] = H[n] + 1\n  except:\n    print(-1)\n    break\nelse:\n  for e in E:\n    print(e[0], e[1])"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nsrc = [int(input()) for i in range(N)]\nidx = {a:i for i,a in enumerate(src)}\n\nsize = [1] * N\nss = list(sorted(src))\n\nes = []\nwhile len(ss) > 1:\n    a = ss.pop()\n    k = size[idx[a]]\n    b = a + 2*k - N\n    if b == a or b not in idx:\n        print(-1)\n        exit()\n    size[idx[b]] += k\n    es.append((idx[a],idx[b]))\n\ngr = [[] for i in range(N)]\nfor a,b in es:\n    gr[a].append(b)\n    gr[b].append(a)\n\nfrom collections import deque\ndist = [N] * N\ndist[idx[ss[0]]] = 0\nq = deque([idx[ss[0]]])\nwhile q:\n    v = q.popleft()\n    for to in gr[v]:\n        if dist[to] < N: continue\n        q.append(to)\n        dist[to] = dist[v] + 1\n\nif all(d<N for d in dist) and sum(dist) == ss[0]:\n    for a,b in es:\n        print(a+1, b+1)\nelse:\n    print(-1)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\" inputの時間比較 \"\"\"\nfrom sys import stdin\nimport numpy as np\n# import sys\n# sys.setrecursionlimit(10**4)\n\ndef _li(): return list(map(int, stdin.readline().split()))\ndef _li_(): return list(map(lambda x: int(x)-1, stdin.readline().split()))\ndef _lf(): return list(map(float, stdin.readline().split()))\ndef _ls(): return stdin.readline().split()\ndef _i(): return int(stdin.readline())\ndef _f(): return float(stdin.readline())\ndef _s(): return stdin.readline()[:-1]\nd_in = lambda: int(stdin.readline())  # N = d_in()\nds_in = lambda: list(map(int, stdin.readline().split()))  # List = ds_in()\n\n\n# N = _i()\n# D_list = np.array([_i() for _ in range(N)])\nN = int(input())\nD_list = np.array([int(input()) for _ in range(N)])\n\n\nidx = np.argsort(D_list)\nsorted_D = D_list[idx]\nmapping = []\nfor j in idx:\n    mapping.append(j+1)\n\n# 解説を参考に実装\n# Dのスコアが大きい方から小さい方へ伸びる有向エッジとみなす\n# valueはノードから出ている有向エッジを切った場合の部分木の大きさ\nnodes = [1] * N\nans = []\ncost = [[0, 1] for _ in range(N)]\n# 葉っぱから見て，[エッジにたどり着くまでのコスト, 自分も含めた子ノードの数]\nfor i in range(N-1, 0, -1):\n    d = sorted_D[i]\n    sub = nodes[i]\n    target = d + 2*sub - N\n    cand = np.searchsorted(sorted_D[:i], target)\n    if (sorted_D[cand] != target) or (cand == i):\n        print(-1)\n        exit()\n    else:\n        ans.append((mapping[i], mapping[cand]))\n        nodes[cand] += nodes[i]\n        cost[cand][0] += (cost[i][0] + cost[i][1])\n        cost[cand][1] += cost[i][1]\n\n# 1番目のノードについてチェック\nif cost[0][0] != sorted_D[0]:\n    print(-1)\n    exit()\nelse:\n    for a in ans:\n        print(a[0], a[1])\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nd = [int(input()) for i in range(n)]\n\n# if sum(d)%2 >= 0:\n#     print(-1)\n#     exit()\n\nd_to_i = {d[i]:i+1 for i in range(n)}\nd_set = set(d)\nans = []\nwhile len(ans) < n-1:\n    d_max, d_min = max(d_set), min(d_set)\n    for m in range(1, n):\n        if m*(n-m-1) == d_max-d_min:\n            l = n-m-1\n            break\n    u = d_to_i[d_max]\n    for diff in range(1, m+1):\n        d_v = d_max - (m*l - (m-diff)*(l-diff))\n        v = d_to_i[d_v]\n        ans.append((u, v))\n        u = v\n        if d_v > d_min:\n            d_set.remove(d_v)\n    d_set.remove(d_max)\n\nfor a in ans:\n    print(*a)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom bisect import bisect_left\ndef input():\n\treturn sys.stdin.readline()[:-1]\n\nn = int(input())\nd = sorted([int(input()) for _ in range(n)])\nif n <= 3:\n\tprint(-1)\n\tsys.exit()\n#print(d)\ngap = [n-2 for _ in range(n)]\n#print(gap)\nans = []\nfor i in range(n-1, 0, -1):\n\tx = d[i]\n\tb = bisect_left(d, x - gap[i])\n\t#print(i, x, b)\n\tif d[b] != x - gap[i]:\n\t\tprint(-1)\n\t\tsys.exit()\n\telse:\n\t\tgap[b] = gap[i] - 2\n\t\tans.append([i+1, b+1])\n\nfor a in ans:\n\tprint(*a)"
  },
  {
    "language": "Python",
    "code": "\n\n\nN=int(input())\nnumlist=[int(input()) for _ in range(N)]\nnumdict={y:x+1 for x,y in enumerate(numlist)}\nsorted_list=sorted(numdict.items(),reverse=True)\n\n\nnextS=lambda Snow,Bnow : Snow+2*Bnow-N\nBnow=1\nbranch_list=[]\nSnow,num=(sorted_list[0][0],numdict.pop(sorted_list[0][0]))\nwhile numdict:\n  S=nextS(Snow,Bnow)\n  if S in numdict:\n    branch_list.append([num,numdict[S]])\n    Bnow+=1\n    Snow,num=S,numdict.pop(S)\n  else:\n    S=nextS(Snow,N-1)\n    if S in numdict:\n      branch_list.append([num,numdict.pop(S)])\n      Bnow+=1\n    else:\n      for x in range(2,(N-Bnow)//2):\n        S=nextS(Snow,N-x)\n        if S in numdict:\n          x-=1\n          can=[[num,S]]\n          while x:\n            Sbuf=S\n            S=nextS(S,N-x)\n            can.append([numdict[Sbuf],S])\n            if not S in numdict:\n              break\n            x-=1\n          else:\n            for buf in can:\n              branch_list.append([buf[0],numdict.pop(buf[1])])\n            Bnow=len(branch_list)+1\n            break\n      else:\n        print(-1)\n        exit()\n\nfor _ in range(N-1):\n  x,y=branch_list.pop()\n  print(x,y)"
  },
  {
    "language": "Python",
    "code": "N=int(input())\nnumlist=list(map(int,(input() for _ in range(N))))\nnumdict={y:x for x,y in enumerate(numlist)}\nsorted_list=sorted(numdict.items(),reverse=True)\n\nnextS=lambda Snow,child : Snow+2*child-N\n\namount_of_child=[1]*N\nsum_of_distance_of_child=[0]*N\nbranch_list=[]\n\nfor S,num in sorted_list:\n  nS=nextS(S,amount_of_child[num])\n  if nS in numdict:\n    nextnum=numdict[nS]\n    branch_list.append([num+1,nextnum+1])\n    amount_of_child[nextnum]+=amount_of_child[num]\n    sum_of_distance_of_child[nextnum]+=(sum_of_distance_of_child[num]+amount_of_child[num])\n    if amount_of_child[nextnum]==N:\n      break\n  else:\n    print (-1)\n    exit()\n\nif sorted_list[-1][0]==sum_of_distance_of_child[sorted_list[-1][1]]:\n  for _ in range(N-1):\n    x,y=branch_list.pop()\n    print(x,y)\nelse:\n  print (-1)\nexit()\n"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\nimport sys\ndef muri():\n    print(-1)\n    exit()\nN = int(input())\nD = [int(sys.stdin.readline()) for _ in range(N)]\n#D = list(map(int, input().split()))\nDidx = list(range(1, N+1))\nDidx.sort(key = lambda x: -D[x-1])\nH = {d: i for i, d in enumerate(D, 1)}\nH = Counter(H)\nD = [0] + D\nK = [0]*(N+1)\ni = Didx[0]\nK[i] = 1\nQ = i\nAns = []\nfor j in range(1, N):\n    vn = Q\n    p = H[D[vn] - (N - 2*K[vn])]\n    if not p:\n        muri()\n    Ans.append((vn, p))\n    K[p] += K[vn] + 1\n    dj = Didx[j]\n    if K[dj] == 0:\n        K[dj] = 1\n    Q = dj\ns = set()\nfor a in Ans:\n    s.add(a[0])\n    s.add(a[1])\nif len(s) != N:\n    muri()\nfor a in Ans:\n    print(*a)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom bisect import bisect_left\ndef input():\n\treturn sys.stdin.readline()[:-1]\nsys.setrecursionlimit(10**6)\n\nn = int(input())\nd = [[int(input()), i+1] for i in range(n)]\ncheck = d[0][0]\nd.sort()\nind = [x[1] for x in d]\nd = [x[0] for x in d]\nif n <= 3 or n%2 == 0:\n\tprint(-1)\n\tsys.exit()\n#print(d)\nchild = [1 for _ in range(n)]\n#print(gap)\nans = []\nadj = [[] for _ in range(n)]\nfor i in range(n-1, 0, -1):\n\tx = d[i]\n\tb = bisect_left(d, x - n + 2*child[i])\n\t#print(i, x, n - 2+child[i], b)\n\tif d[b] != x - n + 2*child[i] or n <= 2*child[i]:\n\t\tprint(-1)\n\t\tsys.exit()\n\telse:\n\t\tchild[b] += child[i]\n\t\tans.append([ind[b], ind[i]])\n\t\tadj[ind[b]-1].append(ind[i]-1)\n\t\tadj[ind[i]-1].append(ind[b]-1)\n\n\nres = 0\ndef dfs(x, p, dis):\n\tglobal res\n\tres += dis\n\tfor v in adj[x]:\n\t\tif v == p:\n\t\t\tcontinue\n\t\telse:\n\t\t\tdfs(v, x, dis+1)\n\treturn\n\ndfs(0, -1, 0)\n#print(res, d[ind[0]])\nif res == check:\n\tfor a in ans:\n\t\tprint(*a)\nelse:\n\tprint(-1)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom bisect import bisect_left\ndef input():\n\treturn sys.stdin.readline()[:-1]\nsys.setrecursionlimit(10**6)\n\nn = int(input())\nd = [[int(input()), i+1] for i in range(n)]\ncheck = d[0][0]\nd.sort()\nind = [x[1] for x in d]\nd = [x[0] for x in d]\nif n <= 3 or n%2 == 0:\n\tprint(-1)\n\tsys.exit()\n#print(d)\nchild = [1 for _ in range(n)]\n#print(gap)\nans = []\nadj = [[] for _ in range(n)]\nfor i in range(n-1, 0, -1):\n\tx = d[i]\n\tb = bisect_left(d, x - n + 2*child[i])\n\t#print(i, x, n - 2+child[i], b)\n\tif d[b] != x - n + 2*child[i]:\n\t\tprint(-1)\n\t\tsys.exit()\n\telse:\n\t\tchild[b] += child[i]\n\t\tans.append([ind[b], ind[i]])\n\t\tadj[ind[b]-1].append(ind[i]-1)\n\t\tadj[ind[i]-1].append(ind[b]-1)\n\n\nres = 0\ndef dfs(x, p, dis):\n\tglobal res\n\tres += dis\n\tfor v in adj[x]:\n\t\tif v == p:\n\t\t\tcontinue\n\t\telse:\n\t\t\tdfs(v, x, dis+1)\n\treturn\n\ndfs(0, -1, 0)\n#print(res, d[ind[0]])\nif res == check:\n\tfor a in ans:\n\t\tprint(*a)\nelse:\n\tprint(-1)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nN = int(input())\nD = [None] + [int(input()) for _ in range(N)]\n\nparent = [None] * (N+1)\nsize = [None] + [1] * N # 部分木の頂点数、自分を含む\nd_to_i = {d:i for i,d in enumerate(D)}\nD_desc = sorted(D[1:],reverse=True)\nD_subtree = [0] * (N+1)\nedges = []\n\nbl = True\nfor d in D_desc[:-1]:\n    i = d_to_i[d]\n    d_parent = d - N + 2*size[i]\n    if d_parent not in d_to_i:\n        bl = False\n        break\n    p = d_to_i[d_parent]\n    edges.append('{} {}'.format(i,p))\n    parent[i] = p\n    size[p] += size[i]\n    D_subtree[p] += D_subtree[i] + size[i]\n\nroot = d_to_i[D_desc[-1]]\nbl &= (D_subtree[root] == D[root])\n\nif bl:\n    print('\\n'.join(edges))\nelse:\n    print(-1)"
  },
  {
    "language": "Python",
    "code": "\n\n\nN=int(input())\nnumlist=[int(input()) for _ in range(N)]\nnumdict={y:x+1 for x,y in enumerate(numlist)}\nsorted_list=sorted(numdict.items(),reverse=True)\n\nnextS=lambda Snow,Bnow : Snow+2*Bnow-N\nBnow=1\nbranch_list=[]\nSnow,num=(sorted_list[0][0],numdict.pop(sorted_list[0][0]))\nwhile numdict:\n  S=nextS(Snow,Bnow)\n  if S in numdict:\n    branch_list.append([num,numdict[S]])\n    Bnow+=1\n    Snow,num=S,numdict.pop(S)\n  else:\n    S=nextS(Snow,N-1)\n    if S in numdict:\n      branch_list.append([num,numdict[S]])\n      Bnow+=1\n      numdict.pop(S)\n    else:\n      print(-1)\n      exit()\n\nfor _ in range(N-1):\n  x,y=branch_list.pop()\n  print(x,y)"
  },
  {
    "language": "Python",
    "code": "def main():\n    N = int(input())\n    D = [int(input()) for i in range(N)]\n    C = [1] * N\n    T = [0] * N\n    DI = {}\n    for i in range(len(D)):\n        DI[D[i]] = i\n    D = sorted(D)\n    P = [-1] * N\n    while len(D) > 1:\n        d = D.pop()\n        i = DI[d]\n        nd = d - N + C[i] * 2\n        if nd in DI:\n            ni = DI[nd]\n        else:\n            print(-1)\n            return\n        P[i] = ni\n        C[ni] += C[i]\n        T[ni] += T[i] + C[i]\n    \n    if D[0] == T[DI[D[0]]]:\n        for i in range(N):\n            if P[i] >= 0: print(i+1, P[i]+1)\n    else:\n        print(-1)\n\nmain()"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\" インプットの時間比較 \"\"\"\nfrom sys import stdin\nimport numpy as np\n# import sys\n# sys.setrecursionlimit(10**4)\n\ndef _li(): return list(map(int, stdin.readline().split()))\ndef _li_(): return list(map(lambda x: int(x)-1, stdin.readline().split()))\ndef _lf(): return list(map(float, stdin.readline().split()))\ndef _ls(): return stdin.readline().split()\ndef _i(): return int(stdin.readline())\ndef _f(): return float(stdin.readline())\ndef _s(): return stdin.readline()[:-1]\nd_in = lambda: int(stdin.readline())  # N = d_in()\nds_in = lambda: list(map(int, stdin.readline().split()))  # List = ds_in()\n\n\n# N = _i()\n# D_list = np.array([_i() for _ in range(N)])\nN = d_in()\nD_list = np.array([ds_in() for _ in range(N)])\n\n\nidx = np.argsort(D_list)\nsorted_D = D_list[idx]\nmapping = []\nfor j in idx:\n    mapping.append(j+1)\n\n# 解説を参考に実装\n# Dのスコアが大きい方から小さい方へ伸びる有向エッジとみなす\n# valueはノードから出ている有向エッジを切った場合の部分木の大きさ\nnodes = [1] * N\nans = []\ncost = [[0, 1] for _ in range(N)]\n# 葉っぱから見て，[エッジにたどり着くまでのコスト, 自分も含めた子ノードの数]\nfor i in range(N-1, 0, -1):\n    d = sorted_D[i]\n    sub = nodes[i]\n    target = d + 2*sub - N\n    cand = np.searchsorted(sorted_D[:i], target)\n    if (sorted_D[cand] != target) or (cand == i):\n        print(-1)\n        exit()\n    else:\n        ans.append((mapping[i], mapping[cand]))\n        nodes[cand] += nodes[i]\n        cost[cand][0] += (cost[i][0] + cost[i][1])\n        cost[cand][1] += cost[i][1]\n\n# 1番目のノードについてチェック\nif cost[0][0] != sorted_D[0]:\n    print(-1)\n    exit()\nelse:\n    for a in ans:\n        print(a[0], a[1])\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nN = int(sys.stdin.readline().strip())\nL = sys.stdin.readlines()\ndct_ori = {(i+1): int(L[i].strip()) for i in range(0,N)}\n\ndct = sorted(dct_ori.items(), key=lambda x: x[1], reverse=True)\ndesc_label = list(map(lambda x:x[0], dct))\ndesc_d = list(map(lambda x:x[1], dct))\n\n# ここからメインの処理はvalueを降順にソートしたもので行うが、リストに追加するのは、元のラベル（1～N+1）のもの\n\nT = [1 for i in range(0,N)]\nE = []\n\nflag1 = True\n\n# 一番根っこ以外、やる\nfor i in range(0,N-1):\n\ttry:\n\t\t# もうi番目は使わないから売買\n\t\td = desc_d[i] - N + (2*T[i])\n\t\tk = desc_d.index(d)\n\t\tT[k] += T[i]\n\t\te = [desc_label[k], desc_label[i]]\n\t\tE.append(\" \".join(map(str,e)))\n\texcept ValueError:\n\t\tprint(-1)\n\t\tflag1 = False\n\t\tbreak\n\t\n# print(E)\n\nif flag1 == True:\n\t# E_str = map(str,E)\n\tprint (\"\\n\".join(E))\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nsrc = [int(input()) for i in range(N)]\nidx = {a:i for i,a in enumerate(src)}\n\nsize = [1] * N\nss = list(sorted(src))\n\nes = []\ngr = [[] for i in range(N)]\nwhile len(ss) > 1:\n    a = ss.pop()\n    k = size[idx[a]]\n    b = a + 2*k - N\n    if b == a or b not in idx:\n        print(-1)\n        exit()\n    size[idx[b]] += k\n    ai,bi = idx[a],idx[b]\n    es.append((ai,bi))\n    gr[a].append(b)\n    gr[b].append(a)\n\nfrom collections import deque\ndist = [N] * N\ndist[idx[ss[0]]] = 0\nq = deque([idx[ss[0]]])\nwhile q:\n    v = q.popleft()\n    for to in gr[v]:\n        if dist[to] < N: continue\n        q.append(to)\n        dist[to] = dist[v] + 1\n\nif all(d<N for d in dist) and sum(dist) == ss[0]:\n    for a,b in es:\n        print(a+1, b+1)\nelse:\n    print(-1)"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\nWriter: SPD_9X2\nhttps://atcoder.jp/contests/arc103/tasks/arc103_d\n\n面白そう！\nとっかかりはどのへんだろうか\n\n偶奇あたりから考えてみる？\nまず、A→BとA←B　の距離は等しいので、Dの合計は絶対偶数になる\nDの和が奇数なら構築不可能\n\n辺u,vを取り除いて,2つの部分木に分解する、各木の含む頂点数を x[u],x[v]とすると\nD[u]+x[u] == D[v]+x[v]　となる (x[u] + x[v] == N)\n\n最大のDについて考えてみよう\n最大のDから繋がってる点を根とした部分木は少なくとも半分の数の要素を含む\nなので、Dmaxは2つ以上辺を持っていてはいけない→Dmaxは葉\n\nDmaxを置くと、それとつながる要素のdは1意に定まる\n残り(unused)の頂点の内、最大のを考える。\nこいつももう葉になるしかない\n1意に定まりんぐ\n\nん～？\nこんな感じで大を小につけていけば構築完了するんじゃね？\n小-大-小　となることはない(小の成分は半分以上の点を含むため)　なのでおｋそう！\n\nD[u] > D[v]のとき\nD[v] = D[u] + x[u] - x[v]\nx[v] = N-x[u]なので\nD[v] = D[u] + 2*x[u] - N\n\nだめな理由がわからないが…\n可能性1: 大が2つ以上の小に繋がってる場合がある(可能を-1にしてる)\n可能性2: 実は構築したやつが条件を満たしてない(-1を可能にしてる)\n→どっちもそんなこと無さそうなのに…\n可能性2の方をつぶそう\n→連結じゃない？自分より小さいdにすべて繋いでるんだからそんなことないだろ\n\nじゃあ場合によってはxが違う？\n→どんな場合よ？\n→うーん？　最後に一応チェック機構入れるか\n→つまりジャッジを書く\n\n簡易的に、xに問題が生じてそうなとき(根がNになってないとき)は-1にするようにしてみた\n\"\"\"\n\nimport sys\nN = int(input())\n\nDi = []\nd_to_ind = {}\n\nfor i in range(N):\n    d = int(input())\n    Di.append([d,i])\n    d_to_ind[d] = i\n\nDi.sort()\nDi.reverse()\n\nx = [1] * N\nans = []\n\nfor lp in range(N-1):\n\n    nowd,nowi = Di[lp]\n\n    nexd = nowd + 2*x[nowi] - N\n\n    if nexd >= nowd:\n        print (-1)\n        sys.exit()\n\n    if nexd not in d_to_ind:\n        print (-1)\n        sys.exit()\n\n    nexi = d_to_ind[nexd]\n    x[nexi] += x[nowi]\n    ans.append([nowi+1,nexi+1])\n\n#チェック用\n\nif x[Di[-1][1]] != N:\n    print (-1)\n    sys.exit()\n\n\nfor i in range(N-1):\n\n    print (ans[i][0] , ans[i][1])\n    \n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n\n\ndef dfs(v, adj_list, depth, visited):\n    visited[v] = True\n    x = depth\n    for w in adj_list[v]:\n        if not visited[w]:\n            x += dfs(w, adj_list, depth + 1, visited)\n\n    return x\n\n\ndef solve(n, d):\n\n    if n < 7:\n        print(-1)\n        return\n\n    d.sort()\n    w = [1] * n\n    edges = []\n    adj_list = [[] for _ in range(n)]\n    for j in range(n - 1, 0, -1):\n        di, i = d[j]\n        pdi = di - n + 2 * w[i]\n        p = None\n        lo, hi = 0, j\n        while lo < hi:\n            mid = (lo + hi) // 2\n            xdi, xi = d[mid]\n            if xdi == pdi:\n                p = xi\n                break\n            elif xdi < pdi:\n                lo = mid + 1\n            else:\n                hi = mid\n        if p is None:\n            print(-1)\n            return\n        u, v = i, p\n        if v < u:\n            u, v = v, u\n        edges.append((u + 1, v + 1))\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n        w[p] += w[i]\n\n    d0, r = d[0]\n    visited = [False] * n\n    x = dfs(r, adj_list, 0, visited)\n    if x != d0:\n        print(-1)\n        return\n\n    edges.sort()\n    for uv in edges:\n        u, v = uv\n        print('{} {}'.format(u, v))\n\n\n\ndef main():\n    n = input()\n    n = int(n)\n    d = []\n    for i in range(n):\n        di = input()\n        di = int(di)\n        d.append((di, i))\n\n\n    solve(n, d)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nD = sorted([int(input()) for i in range(N)])[::-1]\n\nX=[] # i:id /parent id / D / L / parent D / T\nY={} # parent D / i\ncnt=0\nfor i in range(N):\n    child = [j[4] for j in X]\n    L=1\n    T=0\n    if (D[i] in child):\n        if D[i] in Y:\n            for j in Y[D[i]]:\n                L += X[j][3]\n                T += X[j][5]+X[j][3]\n                X[j][1]=i\n                cnt += 1\n    X.append([i, -1, D[i], L, D[i]-N+2*L, T])\n    if not(D[i]-N+2*L in Y):\n        Y[D[i]-N+2*L]=[]\n    Y[D[i]-N+2*L].append(i)\n        \nif N < 5 or X[N-1][0]!=N-1 or cnt!=N-1 or X[N-1][2] != X[N-1][5]:\n    print (-1)\nelse:\n    for i in range(N-1):\n        print (X[i][1]+1,i+1)"
  },
  {
    "language": "Python",
    "code": "\n\n\nN=int(input())\nnumlist=[int(input()) for _ in range(N)]\nnumdict={y:x+1 for x,y in enumerate(numlist)}\nsorted_list=sorted(numdict.items(),reverse=True)\nprint (sorted_list)\n\n\nnextS=lambda Snow,Bnow : Snow+2*Bnow-N\nBnow=1\nbranch_list=[]\nSnow,num=(sorted_list[0][0],numdict.pop(sorted_list[0][0]))\nwhile numdict:\n  S=nextS(Snow,Bnow)\n  if S in numdict:\n    branch_list.append([num,numdict[S]])\n    Bnow+=1\n    Snow,num=S,numdict.pop(S)\n  else:\n    for x in range(1,(N-Bnow)//2):\n      S=nextS(Snow,N-x)\n      if S in numdict:\n        x-=1\n        can=[[num,S]]\n        while x:\n          Sbuf=S\n          S=nextS(S,N-x)\n          can.append([numdict[Sbuf],S])\n          if not S in numdict:\n            break\n          x-=1\n        else:\n          print(can)\n          for buf in can:\n            branch_list.append([buf[0],numdict.pop(buf[1])])\n          Bnow=len(branch_list)+1\n          break\n    else:\n      print(branch_list)\n      print(-1)\n      exit()\n\nfor _ in range(N-1):\n  x,y=branch_list.pop()\n  print(x,y)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom bisect import bisect_left\ndef input():\n\treturn sys.stdin.readline()[:-1]\nsys.setrecursionlimit(10**6)\n\nn = int(input())\nd = [[int(input()), i+1] for i in range(n)]\ncheck = d[0][0]\nd.sort()\nind = [x[1] for x in d]\nd = [x[0] for x in d]\nif n <= 3:\n\tprint(-1)\n\tsys.exit()\n#print(d)\nchild = [1 for _ in range(n)]\n#print(gap)\nans = []\nadj = [[] for _ in range(n)]\nfor i in range(n-1, 0, -1):\n\tx = d[i]\n\tb = bisect_left(d, x - n + 2*child[i])\n\t#print(i, x, n - 2+child[i], b)\n\tif d[b] != x - n + 2*child[i] or n <= 2*child[i]:\n\t\tprint(-1)\n\t\tsys.exit()\n\telse:\n\t\tchild[b] += child[i]\n\t\tans.append([ind[b], ind[i]])\n\t\tadj[ind[b]-1].append(ind[i]-1)\n\t\tadj[ind[i]-1].append(ind[b]-1)\n\n\nres = 0\ndef dfs(x, p, dis):\n\tglobal res\n\tres += dis\n\tfor v in adj[x]:\n\t\tif v == p:\n\t\t\tcontinue\n\t\telse:\n\t\t\tdfs(v, x, dis+1)\n\treturn\n\ndfs(0, -1, 0)\nprint(res, d[ind[0]])\nif res == check:\n\tfor a in ans:\n\t\tprint(*a)\nelse:\n\tprint(-1)"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nsrc = [int(input()) for i in range(N)]\nidx = {a:i for i,a in enumerate(src)}\n\nsize = [1] * N\nss = list(sorted(src))\n\nes = []\nwhile len(ss) > 1:\n    a = ss.pop()\n    k = size[idx[a]]\n    b = a + 2*k - N\n    if b >= a or b not in idx:\n        print(-1)\n        exit()\n    size[idx[b]] = k + 1\n    es.append((idx[a],idx[b]))\n\ngr = [[] for i in range(N)]\nfor a,b in es:\n    gr[a].append(b)\n    gr[b].append(a)\n\nfrom collections import deque\ndist = [N] * N\ndist[idx[ss[0]]] = 0\nq = deque([idx[ss[0]]])\nwhile q:\n    v = q.popleft()\n    for to in gr[v]:\n        if dist[to] < N: continue\n        q.append(to)\n        dist[to] = dist[v] + 1\n\nif sum(dist) == ss[0]:\n    for a,b in es:\n        print(a+1, b+1)\nelse:\n    print(-1)"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nsrc = [int(input()) for i in range(N)]\nidx = {a:i for i,a in enumerate(src)}\n\nsize = [1] * N\nss = list(sorted(src))\n\nes = []\nwhile len(ss) > 1:\n    a = ss.pop()\n    k = size[idx[a]]\n    b = a + 2*k - N\n    if b == a or b not in idx:\n        print(-1)\n        exit()\n    size[idx[b]] = k + 1\n    es.append((idx[a],idx[b]))\n\ngr = [[] for i in range(N)]\nfor a,b in es:\n    gr[a].append(b)\n    gr[b].append(a)\n\nfrom collections import deque\ndist = [N] * N\ndist[idx[ss[0]]] = 0\nq = deque([idx[ss[0]]])\nwhile q:\n    v = q.popleft()\n    for to in gr[v]:\n        if dist[to] < N: continue\n        q.append(to)\n        dist[to] = dist[v] + 1\n\nif sum(dist) == ss[0]:\n    for a,b in es:\n        print(a+1, b+1)\nelse:\n    print(-1)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nN = int(input())\nC = defaultdict(int)\nfor i in range(N):\n  D = int(input())\n  C[D] = i + 1\nE = []\nH = [1] * (N + 1)\nDD = sorted([[k, v] for k, v in C.items()], reverse=True)\nAdj = [[] for i in range(N)]\nfor D, n in DD[:-1]:\n  try:\n    p = C[D - N + 2 * H[n]]\n    if n == p:\n      raise Error\n    E.append([n, p])\n    Adj[n - 1].append(p - 1)\n    Adj[p - 1].append(n - 1)\n    H[p] += H[n]\n  except:\n    print(-1)\n    break\nelse:\n  dist = [N] * N\n  dist[DD[-1][1] - 1] = 0\n  Q = [N] * N\n  Q[0] = DD[-1][1] - 1\n  for i in range(N):\n    s = Q[i]\n    if s == N:\n      break\n    for adj in Adj[s]:\n      if dist[adj] == N:\n        dist[adj] = dist[s] + 1\n        Q.append(adj)\n  if sum(dist) == DD[-1][0]:\n    for e in E:\n      print(e[0], e[1])\n  else:\n    print(-1)"
  },
  {
    "language": "Python",
    "code": "def solve():\n    N = int(raw_input())\n    Di = []\n    for i in range(N):\n        di = int(raw_input())\n        Di.append([i, di])\n    Di.sort(key = lambda x : x[1])\n    d_to_i = {di[1]:di[0] for di in Di}\n    child = [[] for i in range(N)]\n    n_child = [1] * N\n    d_child = [0] * N\n    for ind in range(N - 1, 0, -1):\n        node = Di[ind][0]\n        valD_par = Di[ind][1] - N + 2 * n_child[node]\n        if valD_par in d_to_i.keys():\n            node_par = d_to_i[valD_par]\n            # child[node].append(node_par) ##\n            child[node_par].append(node)\n            n_child[node_par] += n_child[node]\n            d_child[node_par] += n_child[node] + d_child[node]\n        if n_child[node_par] == N:\n            # check if Di satisfied or not\n            if d_child[node_par] != Di[0][1]:\n                print '-1'\n                return\n            break\n    for i in range(N):\n        for j in child[i]:\n            print str(i + 1) + ' ' + str(j + 1)\n\nif __name__ == '__main__':\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nsrc = [int(input()) for i in range(N)]\nidx = {a:i for i,a in enumerate(src)}\n\nsize = [1] * N\nss = list(sorted(src))\n\nes = []\nwhile len(ss) > 1:\n    a = ss.pop()\n    k = size[idx[a]]\n    b = a + 2*k - N\n    if b == a or b not in idx:\n        print(-1)\n        exit()\n    size[idx[b]] = k + 1\n    es.append((idx[a],idx[b]))\n\nassert False\n\ngr = [[] for i in range(N)]\nfor a,b in es:\n    gr[a].append(b)\n    gr[b].append(a)\n\nfrom collections import deque\ndist = [N] * N\ndist[idx[ss[0]]] = 0\nq = deque([idx[ss[0]]])\nwhile q:\n    v = q.popleft()\n    for to in gr[v]:\n        if dist[to] < N: continue\n        q.append(to)\n        dist[to] = dist[v] + 1\n\nif all(d<N for d in dist) and sum(dist) == ss[0]:\n    for a,b in es:\n        print(a+1, b+1)\nelse:\n    print(-1)"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nsrc = [int(input()) for i in range(N)]\nidx = {a:i for i,a in enumerate(src)}\n\nsize = [1] * N\nss = list(sorted(src))\n\nes = []\ngr = [[] for i in range(N)]\nwhile len(ss) > 1:\n    a = ss.pop()\n    k = size[idx[a]]\n    b = a + 2*k - N\n    if b == a or b not in idx:\n        print(-1)\n        exit()\n    size[idx[b]] += k\n    ai,bi = idx[a],idx[b]\n    es.append((ai,bi))\n    gr[ai].append(bi)\n    gr[bi].append(ai)\n\nfrom collections import deque\ndist = [N] * N\ndist[idx[ss[0]]] = 0\nq = deque([idx[ss[0]]])\nwhile q:\n    v = q.popleft()\n    for to in gr[v]:\n        if dist[to] < N: continue\n        q.append(to)\n        dist[to] = dist[v] + 1\n\nif all(d<N for d in dist) and sum(dist) == ss[0]:\n    for a,b in es:\n        print(a+1, b+1)\nelse:\n    print(-1)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom bisect import bisect_left\n\nn = int(input())\nd = sorted([int(input()) for _ in range(n)])\nif n <= 3:\n\tprint(-1)\n\tsys.exit()\n#print(d)\ngap = [n-2 for _ in range(n)]\n#print(gap)\nans = []\nfor i in range(n-1, 0, -1):\n\tx = d[i]\n\tb = bisect_left(d, x - gap[i])\n\t#print(i, x, b)\n\tif d[b] != x - gap[i]:\n\t\tprint(-1)\n\t\tsys.exit()\n\telse:\n\t\tgap[b] = gap[i] - 2\n\t\tans.append([i+1, b+1])\n\nfor a in ans:\n\tprint(*a)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nN = int(input())\nC = defaultdict(int)\nfor i in range(N):\n  D = int(input())\n  C[D] = i + 1\nE = []\nH = [1] * (N + 1)\nDD = sorted([[k, v] for k, v in C.items()], reverse=True)\nAdj = [[] for i in range(N)]\nfor D, n in DD[:-1]:\n  try:\n    p = C[D - N + 2 * H[n]]\n    if n == p:\n      raise Error\n    E.append([n, p])\n    Adj[n - 1].append(p - 1)\n    Adj[p - 1].append(n - 1)\n    H[p] += H[n]\n  except:\n    print(-1)\n    break\nelse:\n  dist = [N] * N\n  dist[DD[-1][1] - 1] = 0\n  Q = [DD[-1][1] - 1]\n  for i in range(N):\n    s = Q[i]\n    for adj in Adj[s]:\n      if dist[adj] == N:\n        dist[adj] = dist[s] + 1\n        Q.append(adj)\n  if sum(dist) == DD[-1][0]:\n    for e in E:\n      print(e[0], e[1])\n  else:\n    print(-1)"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nD = [int(input()) for i in range(N)]\nD = sorted(D)[::-1]\n\nDtoI = {}\npD = [-1] * N\nL = [1] * N\nT = [0] * N\n\nY = {}\ncnt = 0\nfor i in range(N):\n    DtoI[D[i]] = i\n\nfor i in range(N):\n    if D[i] in Y:\n        for y in Y[D[i]]:\n            L[i] += L[y]\n            T[i] += T[y] + L[y]\n            cnt += 1\n        \n    p = N - 2 * L[i]\n    if p <= 0 or i == N-1:\n        pd = -1\n    else:\n        pd = D[i] - p\n    pD[i] = pd\n    \n    if pd not in Y:\n        Y[pd] = []\n    Y[pd].append(i)\n\nif pD[-2] < 0:\n    print(-1)\nelse:\n    for i in range(N-1):\n        print (i + 1, DtoI[pD[i]] + 1)\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nD = sorted([int(input()) for i in range(N)])[::-1]\n\nX=[] # i:id /parent id / D / L / parent D / T\nY={} # parent D / i\ncnt=0\nfor i in range(N):\n#     child = [j[4] for j in X]\n    L=1\n    T=0\n#     if (D[i] in child):\n    if D[i] in Y:\n        for j in Y[D[i]]:\n            L += X[j][3]\n            T += X[j][5]+X[j][3]\n            X[j][1]=i\n            cnt += 1\n    X.append([i, -1, D[i], L, D[i]-N+2*L, T])\n    if not(D[i]-N+2*L in Y):\n        Y[D[i]-N+2*L]=[]\n    Y[D[i]-N+2*L].append(i)\n        \nif N < 5 or X[N-1][0]!=N-1 or cnt!=N-1 or X[N-1][2] != X[N-1][5]:\n    print (-1)\nelse:\n    for i in range(N-1):\n        print (X[i][1]+1,i+1)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nN = int(input())\nC = defaultdict(int)\nfor i in range(N):\n  D = int(input())\n  C[D] = i + 1\nE = []\nH = [1] * (N + 1)\nDD = sorted([[k, v] for k, v in C.items()], reverse=True)\nAdj = [[] for i in range(N)]\nfor D, n in DD[:-1]:\n  try:\n    p = C[D - N + 2 * H[n]]\n    if n == p:\n      raise Error\n    E.append([n, p])\n    Adj[n - 1].append(p - 1)\n    Adj[p - 1].append(n - 1)\n    H[p] += H[n]\n  except:\n    print(-1)\n    break\nelse:\n  dist = [N] * N\n  dist[DD[-1][1] - 1] = 0\n  Q = [DD[-1][1] - 1]\n  while Q:\n    s = Q[0]\n    Q = Q[1:]\n    for adj in Adj[s]:\n      if dist[s] + 1 < dist[adj]:\n        dist[adj] = dist[s] + 1\n        Q.append(adj)\n  if sum(dist) == DD[-1][0]:\n    for e in E:\n      print(e[0], e[1])\n  else:\n    print(-1)"
  },
  {
    "language": "Python",
    "code": "print (-1)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nd = [int(input()) for i in range(n)]\n\nif sum(d)%2 > 0:\n    print(-1)\n    exit()\n\nd = sorted([(dd, i) for i, dd in enumerate(d)], reverse = True)\nd_to_i = {dd:i for dd, i in d}\nn_child = [1]*n\nans = []\nfor dd, i in d:\n    d_i = dd+2*n_child[i]-n\n    if d_i in d_to_i.keys():\n        i_next = d_to_i[d_i]\n        ans.append((i+1, i_next+1))\n        n_child[i_next] += n_child[i]\n        if n_child[i_next] == n:\n            break\n    else:\n        print(-1)\n        exit()\n\nfor a in ans:\n    print(*a)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\" インプットの時間比較 \"\"\"\nfrom sys import stdin\nimport numpy as np\n# import sys\n# sys.setrecursionlimit(10**4)\n\ndef _li(): return list(map(int, stdin.readline().split()))\ndef _li_(): return list(map(lambda x: int(x)-1, stdin.readline().split()))\ndef _lf(): return list(map(float, stdin.readline().split()))\ndef _ls(): return stdin.readline().split()\ndef _i(): return int(stdin.readline())\ndef _f(): return float(stdin.readline())\ndef _s(): return stdin.readline()[:-1]\nd_in = lambda: int(stdin.readline())  # N = d_in()\nds_in = lambda: list(map(int, stdin.readline().split()))  # List = ds_in()\n\n\n# N = _i()\n# D_list = np.array([_i() for _ in range(N)])\nN = d_in()\nD_list = np.array([d_in() for _ in range(N)])\n\n\nidx = np.argsort(D_list)\nsorted_D = D_list[idx]\nmapping = []\nfor j in idx:\n    mapping.append(j+1)\n\n# 解説を参考に実装\n# Dのスコアが大きい方から小さい方へ伸びる有向エッジとみなす\n# valueはノードから出ている有向エッジを切った場合の部分木の大きさ\nnodes = [1] * N\nans = []\ncost = [[0, 1] for _ in range(N)]\n# 葉っぱから見て，[エッジにたどり着くまでのコスト, 自分も含めた子ノードの数]\nfor i in range(N-1, 0, -1):\n    d = sorted_D[i]\n    sub = nodes[i]\n    target = d + 2*sub - N\n    cand = np.searchsorted(sorted_D[:i], target)\n    if (sorted_D[cand] != target) or (cand == i):\n        print(-1)\n        exit()\n    else:\n        ans.append((mapping[i], mapping[cand]))\n        nodes[cand] += nodes[i]\n        cost[cand][0] += (cost[i][0] + cost[i][1])\n        cost[cand][1] += cost[i][1]\n\n# 1番目のノードについてチェック\nif cost[0][0] != sorted_D[0]:\n    print(-1)\n    exit()\nelse:\n    for a in ans:\n        print(a[0], a[1])\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nd = [int(input()) for i in range(n)]\n\nif sum(d)%2 > 0:\n    print(-1)\n    exit()\n\nd_to_i = {d[i]:i+1 for i in range(n)}\nd_set = set(d)\nans = []\nwhile len(ans) < n-1:\n    d_max, d_min = max(d_set), min(d_set)\n    for m in range(1, n):\n        if m*(n-m-1) == d_max-d_min:\n            l = n-m-1\n            break\n    u = d_to_i[d_max]\n    for diff in range(1, m+1):\n        d_v = d_max - (m*l - (m-diff)*(l-diff))\n        v = d_to_i[d_v]\n        ans.append((u, v))\n        u = v\n        if d_v > d_min:\n            d_set.remove(d_v)\n    d_set.remove(d_max)\n\nfor a in ans:\n    print(*a)\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nD = [int(input()) for i in range(N)]\nD = sorted(D)[::-1]\n\nfor i in range(N):\n    D[i] -= 0\n\nDtoI = {}\npD = [-1] * N\nL = [1] * N\nT = [0] * N\n\nY = {}\ncnt = 0\nfor i in range(N):\n    DtoI[D[i]] = i\n\nfor i in range(N):\n    if D[i] in Y:\n        for y in Y[D[i]]:\n            L[i] += L[y]\n            T[i] += T[y] + L[y]\n            cnt += 1\n        \n    p = N - 2 * L[i]\n    if p <= 0 or i == N-1:\n        pd = -1\n    else:\n        pd = D[i] - p\n    pD[i] = pd\n    \n    if pd not in Y:\n        Y[pd] = []\n    Y[pd].append(i)\n\nfor i in range(N-1):\n    print (i + 1, DtoI[pD[i]] + 1)"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nsrc = [int(input()) for i in range(N)]\nidx = {a:i for i,a in enumerate(src)}\n\nsize = [1] * N\nss = list(sorted(src))\n\nes = []\nwhile len(ss) > 1:\n    a = ss.pop()\n    k = size[idx[a]]\n    b = a + 2*k - N\n    if b >= a or b not in idx:\n        print(-1)\n        exit()\n    size[idx[b]] = k + 1\n    es.append((idx[a],idx[b]))\n\nfor a,b in es:\n    print(a+1, b+1)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nN = int(input())\nC = defaultdict(int)\nfor i in range(N):\n  D = int(input())\n  C[D] = i + 1\nE = []\nH = [1] * (N + 1)\nDD = sorted([[k, v] for k, v in C.items()], reverse=True)\nAdj = [[] for i in range(N)]\nfor D, n in DD[:-1]:\n  try:\n    p = C[D - N + 2 * H[n]]\n    if n == p:\n      raise Error\n    E.append([n, p])\n    Adj[n - 1].append(p - 1)\n    Adj[p - 1].append(n - 1)\n    H[p] += H[n]\n  except:\n    print(-1)\n    break\nelse:\n  dist = [N] * N\n  dist[DD[-1][1] - 1] = 0\n  Q = [DD[-1][1] - 1]\n  for i in range(N - 1):\n    s = Q[i]\n    for adj in Adj[s]:\n      if dist[adj] == N:\n        dist[adj] = dist[s] + 1\n        Q.append(adj)\n  if sum(dist) == DD[-1][0]:\n    for e in E:\n      print(e[0], e[1])\n  else:\n    print(-1)"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nD = sorted([int(input()) for i in range(N)])[::-1]\n\nX=[] # i:id /parent id / D / L / parent D / T\ncnt=0\nfor i in range(N):\n    child = [j[4] for j in X]\n    L=1\n    T=0\n    if (D[i] in child):\n        L = sum([j[3]*(j[4]==D[i]) for j in X]) + 1\n        T = sum([(j[5]+j[3])*(j[4]==D[i]) for j in X])\n        cnt += sum([1*(j[4]==D[i]) for j in X])\n        for j in X:\n            if j[4]==D[i]:\n                j[1]=i\n    X.append([i, -1, D[i], L, D[i]-N+2*L, T])\n\nif X[N-1][0]!=N-1 or X[N-1][2] != X[N-1][5]:\n    print (-1)\nelse:\n    for i in range(N-1):\n        print (X[i][1]+1,i+1)"
  },
  {
    "language": "Python",
    "code": "def solve():\n    N = int(raw_input())\n    Di = []\n    for i in range(N):\n        di = int(raw_input())\n        Di.append([i, di])\n    Di.sort(key = lambda x : x[1])\n    child = [[] for i in range(N)]\n    n_child = [1] * N\n    d_child = [0] * N\n    for ind in range(N - 1, 0, -1):\n        node = Di[ind][0]\n        valD_par = Di[ind][1] - N + 2 * n_child[node]\n        found_flag = False\n        for i in range(N):\n            if Di[i][1] == valD_par:\n                node_par = Di[i][0]\n                # child[node].append(node_par) ##\n                child[node_par].append(node)\n                n_child[node_par] += n_child[node]\n                d_child[node_par] += n_child[node] + d_child[node]\n                found_flag = True\n                break\n        if not found_flag and len(child[node]) <= 0:\n            print '-1'\n            return\n        if n_child[node_par] == N:\n            break\n    # check if Di satisfied or not\n    # if d_child[0] != Di[0][1]:\n    #     print '-1'\n    #     return\n    for i in range(N):\n        for j in child[i]:\n            print str(i + 1) + ' ' + str(j + 1)\n\nif __name__ == '__main__':\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "N=int(input())\nnumlist=[int(input()) for _ in range(N)]\nnumdict={y:x for x,y in enumerate(numlist)}\nsorted_list=sorted(numdict.items(),reverse=True)\n\nnextS=lambda Snow,child : Snow+2*child-N\n\namount_of_child=[1]*N\nsum_of_distance_of_child=[0]*N\nbranch_list=[]\n\nfor S,num in sorted_list:\n  nS=nextS(S,amount_of_child[num])\n  if nS in numdict:\n    nextnum=numdict[nS]\n    branch_list.append([num+1,nextnum+1])\n    amount_of_child[nextnum]+=amount_of_child[num]\n    sum_of_distance_of_child[nextnum]+=(sum_of_distance_of_child[num]+amount_of_child[num])\n    if amount_of_child[nextnum]==N:\n      break\n  else:\n    print (-1)\n    exit()\n\nif sorted_list[-1][0]==sum_of_distance_of_child[sorted_list[-1][1]]:\n  for _ in range(N-1):\n    x,y=branch_list.pop()\n    print(x,y)\nelse:\n  print (-1)\nexit()\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    N = int(raw_input())\n    Di = []\n    sum = 0\n    for i in range(N):\n        di = int(raw_input())\n        sum += di\n        Di.append([i, di])\n    if sum % 2 > 0:\n        print '-1'\n        return\n    Di.sort(key = lambda x : x[1])\n    d_to_i = {di[1]:di[0] for di in Di}\n    # child = [[] for i in range(N)]\n    ans = []\n    n_child = [1] * N\n    d_child = [0] * N\n    root_node = None\n    for ind in range(N - 1, -1, -1):\n        node = Di[ind][0]\n        valD_par = Di[ind][1] - N + 2 * n_child[node]\n        if valD_par in d_to_i.keys():\n            node_par = d_to_i[valD_par]\n            # child[node].append(node_par) ##\n            # child[node_par].append(node)\n            ans.append([node_par + 1, node + 1])\n            n_child[node_par] += n_child[node]\n            d_child[node_par] += n_child[node] + d_child[node]\n        else:\n            print '-1'\n            return\n        if n_child[node_par] == N:\n            root_node = node_par\n            break\n    # check if Di satisfied or not\n    if root_node is not None and d_child[root_node] != Di[0][1]:\n        print '-1'\n        return\n    # for i in range(N):\n    #     for j in child[i]:\n    #         print str(i + 1) + ' ' + str(j + 1)\n    for ele in ans:\n        print str(ele[0]) + ' ' + str(ele[1])\n\nif __name__ == '__main__':\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nimport sys\n\nsys.setrecursionlimit(101010)\n\ndef dfs(v, adj_list, depth, visited):\n    visited[v] = True\n    x = depth\n    for w in adj_list[v]:\n        if not visited[w]:\n            x += dfs(w, adj_list, depth + 1, visited)\n\n    return x\n\n\ndef solve(n, d):\n\n    if n < 7:\n        print(-1)\n        return\n\n    d.sort()\n    w = [1] * n\n    edges = []\n    adj_list = [[] for _ in range(n)]\n    for j in range(n - 1, 0, -1):\n        di, i = d[j]\n        pdi = di - n + 2 * w[i]\n        p = None\n        lo, hi = 0, j\n        while lo < hi:\n            mid = (lo + hi) // 2\n            xdi, xi = d[mid]\n            if xdi == pdi:\n                p = xi\n                break\n            elif xdi < pdi:\n                lo = mid + 1\n            else:\n                hi = mid\n        if p is None:\n            print(-1)\n            return\n        u, v = i, p\n        if v < u:\n            u, v = v, u\n        edges.append((u + 1, v + 1))\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n        w[p] += w[i]\n\n    d0, r = d[0]\n    visited = [False] * n\n    x = dfs(r, adj_list, 0, visited)\n    if x != d0:\n        print(-1)\n        return\n\n    edges.sort()\n    for uv in edges:\n        u, v = uv\n        print('{} {}'.format(u, v))\n\n\n\ndef main():\n    n = input()\n    n = int(n)\n    d = []\n    for i in range(n):\n        di = input()\n        di = int(di)\n        d.append((di, i))\n\n\n    solve(n, d)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nN = int(input())\nC = defaultdict(int)\nfor i in range(N):\n  D = int(input())\n  C[D] = i + 1\nE = []\nH = [1] * (N + 1)\nfor D, n in sorted([[k, v] for k, v in C.items()], reverse=True)[:-1]:\n  try:\n    p = C[D - N + 2 * H[n]]\n    if n == p:\n      raise Error\n    E.append([n, p])\n    H[p] += H[n]\n  except:\n    print(-1)\n    break\nelse:\n  for e in E:\n    print(e[0], e[1])"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom bisect import bisect_left\ndef input():\n\treturn sys.stdin.readline()[:-1]\n\nn = int(input())\nd = sorted([[int(input()), i+1] for i in range(n)])\nind = [x[1] for x in d]\nd = [x[0] for x in d]\nif n <= 3 or n%2 == 0:\n\tprint(-1)\n\tsys.exit()\n#print(d)\nchild = [1 for _ in range(n)]\n#print(gap)\nans = []\nfor i in range(n-1, 0, -1):\n\tx = d[i]\n\tb = bisect_left(d, x - n + 2*child[i])\n\t#print(i, x, n - 2+child[i], b)\n\tif d[b] != x - n + 2*child[i]:\n\t\tprint(-1)\n\t\tsys.exit()\n\telse:\n\t\tchild[b] += child[i]\n\t\tans.append([ind[b], ind[i]])\n\nfor a in ans:\n\tprint(*a)"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nsrc = [int(input()) for i in range(N)]\nidx = {a:i for i,a in enumerate(src)}\n\nsize = [1] * N\nss = list(sorted(src))\n\nes = []\nwhile len(ss) > 1:\n    a = ss.pop()\n    k = size[idx[a]]\n    b = a + 2*k - N\n    if b == a or b not in idx:\n        print(-1)\n        exit()\n    size[idx[b]] = k + 1\n    es.append((idx[a],idx[b]))\n\nfor a,b in es:\n    print(a+1, b+1)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nd = [int(input()) for i in range(n)]\n\nif sum(d)%2 > 0:\n    print(-1)\n    exit()\n\nd = sorted([(dd, i) for i, dd in enumerate(d)], reverse = True)\nd_to_i = {dd:i for dd, i in d}\nn_child = [1]*n\nd_child = [0]*n\nans = []\nfor dd, i in d:\n    d_i = dd+2*n_child[i]-n\n    if d_i in d_to_i.keys():\n        i_next = d_to_i[d_i]\n        ans.append((i+1, i_next+1))\n        n_child[i_next] += n_child[i]\n        d_child[i_next] += d_child[i] + n_child[i]\n        if n_child[i_next] == n:\n            break\n    else:\n        print(-1)\n        exit()\n\nd_min, i_min = d[-1]\nif d_min == d_child[i_min]:\n    for a in ans:\n        print(*a)\nelse:\n     print(-1)\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nD = sorted([int(input()) for i in range(N)])[::-1]\n\nX=[] # i:id /parent id / D / L / parent D / T\nY={} # parent D / i\ncnt=0\nflg = 1\nfor i in range(N):\n    L=1\n    T=0\n    if D[i] in Y:\n        for j in Y[D[i]]:\n            L += X[j][3]\n            T += X[j][5]+X[j][3]\n            X[j][1]=i\n            cnt += 1\n    if N-2*L<=0:\n        parentD = -1\n        if i<N-1:\n            flg = 0\n    else:\n        parentD = D[i]-N+2*L\n    X.append([i, -1, D[i], L, parentD, T])\n    if i<N-1:\n        if not(parentD in Y):\n            Y[parentD]=[]\n        Y[parentD].append(i)\n        \nif N < 5 or cnt!=N-1 or X[N-1][2] != X[N-1][5] or flg == 0:\n    print (-1)\nelse:\n    for i in range(N-1):\n        print (X[i][1]+1,i+1)"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\nimport sys\ndef muri():\n    print(-1)\n    sys.exit()\nN = int(input())\nD = [int(sys.stdin.readline()) for _ in range(N)]\n#D = list(map(int, input().split()))\nDidx = list(range(1, N+1))\nDidx.sort(key = lambda x: -D[x-1])\nH = {d: i for i, d in enumerate(D, 1)}\nH = Counter(H)\nD = [0] + D\nK = [0]*(N+1)\nAns = []\nfor vn in Didx[:-1]:\n    if K[vn] == 0:\n        K[vn] = 1\n    p = H[D[vn] - (N - 2*K[vn])]\n    if not p:\n        muri()\n    Ans.append((vn, p))\n    K[p] += K[vn] + 1\ns = set()\nfor a in Ans:\n    s.add(a[0])\n    s.add(a[1])\nif len(s) != N:\n    muri()\nfor a in Ans:\n    print(*a)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nd = [int(input()) for _ in range(n)]\nr = {v: i for i, v in enumerate(d)}\nsz = [1] * n\ndsorted = sorted(((di, i) for i, di in enumerate(d)), reverse=True)\nans = []\nto = [[] for _ in range(n)]\nfor di, i in dsorted[:n-1]:\n    nd = di + (sz[i] - 1) - (n - 2 - (sz[i] - 1))\n    if not nd in r:\n        print(-1)\n        exit()\n    p = r[nd]\n    to[p].append(i)\n    sz[p] += sz[i]\n    ans.append((i+1, p+1))\n\nroot = dsorted[-1][1]\ndef dfs(u, cur=0):\n    rv = cur\n    for v in to[u]:\n        rv += dfs(v, cur + 1)\n    return rv\n\nif dfs(root) != d[root]:\n    print(-1)\n    exit()\n\nfor u, v in ans:\n    print(u, v)\n"
  },
  {
    "language": "Python",
    "code": "n = int(raw_input())\nd = [int(raw_input()) for i in range(n)]\n\nif sum(d)%2 > 0:\n    print(-1)\n    exit()\n\nd = sorted([(dd, i) for i, dd in enumerate(d)], reverse = True)\nd_to_i = {dd:i for dd, i in d}\nn_child = [1]*n\nd_child = [0]*n\nans = []\nfor dd, i in d:\n    d_i = dd+2*n_child[i]-n\n    if d_i in d_to_i.keys():\n        i_next = d_to_i[d_i]\n        ans.append((i+1, i_next+1))\n        n_child[i_next] += n_child[i]\n        d_child[i_next] += d_child[i] + n_child[i]\n        if n_child[i_next] == n:\n            break\n    else:\n        print(-1)\n        exit()\n\nd_min, i_min = d[-1]\nif d_min == d_child[i_min]:\n    for i,j in ans:\n        print str(i) + ' ' + str(j)\nelse:\n     print(-1)\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nD = [int(input()) for i in range(N)]\n\nD = sorted(D)[::-1]\n\nDtoI = {}\npD = [-1] * N\nL = [1] * N\nT = [0] * N\n\nY = {}\ncnt = 0\nfor i in range(N):\n    DtoI[D[i]] = i\n\nfor i in range(N):\n    if D[i] in Y:\n        for y in Y[D[i]]:\n            L[i] += L[y]\n            T[i] += T[y] + L[y]\n            cnt += 1\n        \n    p = N - 2 * L[i]\n    if p <= 0 or i == N-1:\n        pd = -1\n    else:\n        pd = D[i] - p\n    pD[i] = pd\n    \n    if pd not in Y:\n        Y[pd] = []\n    Y[pd].append(i)\n\nif T[-1] != D[-1] or cnt != N-1:\n    print (-1)\nelse:\n    for i in range(N-1):\n        print (i + 1, DtoI[pD[i]] + 1)"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\nimport sys\ndef muri():\n    print(-1)\n    sys.exit()\nN = int(input())\n#D = [int(sys.stdin.readline()) for _ in range(N)]\nD = list(map(int, input().split()))\nDidx = list(range(1, N+1))\nDidx.sort(key = lambda x: -D[x-1])\nH = {d: i for i, d in enumerate(D, 1)}\nH = Counter(H)\nD = [0] + D\nK = [1]*(N+1)\nAns = []\nfor vn in Didx[:-1]:\n    p = H[D[vn] - (N - 2*K[vn])]\n    if not p:\n        muri()\n    Ans.append((vn, p))\n    K[p] += K[vn]\ns = set()\n\nEdge = [[] for _ in range(N+1)]\nfor a in Ans:\n    x, y = a\n    Edge[x].append(y)\n    Edge[y].append(x)\n\ndist = [10**9+7]*(N+1)\ndist[0] = 0\ndist[1] = 0\nstack = [1]\nvisited = set([1])\nwhile stack:\n    vn = stack.pop()\n    for vf in Edge[vn]:\n        if vf not in visited:\n            visited.add(vf)\n            dist[vf] = 1 + dist[vn]\n            stack.append(vf)\nif D[1] != sum(dist[1:]):\n    muri()\n\nfor a in Ans:\n    print(*a)"
  },
  {
    "language": "Python",
    "code": "def solve():\n    N = int(raw_input())\n    D = [int(raw_input()) for i in range(N)]\n    if sum(D) % 2 > 0:\n        print '-1'\n        exit()\n    Di = sorted([(di, i) for i, di in enumerate(D)], key = lambda x : x[0], reverse = True)\n    d_to_i = {dd:i for dd, i in Di}\n    # child = [[] for i in range(N)]\n    ans = []\n    n_child = [1] * N\n    d_child = [0] * N\n    for valD, node in Di:\n        valD_par = valD - N + 2 * n_child[node]\n        if valD_par in d_to_i.keys():\n            node_par = d_to_i[valD_par]\n            # child[node].append(node_par) ##\n            # child[node_par].append(node)\n            ans.append((node_par + 1, node + 1))\n            n_child[node_par] += n_child[node]\n            d_child[node_par] += n_child[node] + d_child[node]\n            if n_child[node_par] == N:\n                break\n        else:\n            print '-1'\n            exit()\n\n    # check if Di satisfied or not\n    d_min, i_min = Di[-1]\n    if d_child[i_min] != d_min:\n        print '-1'\n        exit()\n    # for i in range(N):\n    #     for j in child[i]:\n    #         print str(i + 1) + ' ' + str(j + 1)\n    for i,j in ans:\n        print str(i) + ' ' + str(j)\n\nif __name__ == '__main__':\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\ncoordinates = []\ndistance = []\n\nfor i in range(n):\n    coordinate = list(map(int, input().split()))\n    coordinates.append(coordinate)\n    distance.append((abs(coordinate[0]) + abs(coordinate[1])))\n\n\ndef parity_check(p, index):\n    if len(distance) < index + 1:\n        return\n    if p != distance[index] % 2:\n        print(-1)\n        exit()\n    parity_check(p, index + 1)\n\n\nparity_check(distance[0] % 2, 1)\n\nm = max(distance)\nd = [\"1\"] * m\nprint(m)\nprint(\" \".join(d))\n\nfor i in range(n):\n    result = \"RL\" * ((m - distance[i]) // 2)\n    if coordinates[i][0] < 0:\n        result += \"L\" * -coordinates[i][0]\n    else:\n        result += \"R\" * coordinates[i][0]\n    if coordinates[i][1] < 0:\n        result += \"D\" * -coordinates[i][1]\n    else:\n        result += \"U\" * coordinates[i][1]\n    print(result)"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\nimport sys\ndef muri():\n    print(-1)\n    sys.exit()\nN = int(input())\nD = [int(sys.stdin.readline()) for _ in range(N)]\n#D = list(map(int, input().split()))\nDidx = list(range(1, N+1))\nDidx.sort(key = lambda x: -D[x-1])\nH = {d: i for i, d in enumerate(D, 1)}\nH = Counter(H)\nD = [0] + D\nK = [1]*(N+1)\nAns = []\nfor vn in Didx[:-1]:\n    p = H[D[vn] - (N - 2*K[vn])]\n    if not p:\n        muri()\n    Ans.append((vn, p))\n    K[p] += K[vn]\ns = set()\n\nEdge = [[] for _ in range(N+1)]\nfor a in Ans:\n    x, y = a\n    Edge[x].append(y)\n    Edge[y].append(x)\n\ndist = [10**9+7]*(N+1)\ndist[0] = 0\ndist[1] = 0\nstack = [1]\nvisited = set([1])\nwhile stack:\n    vn = stack.pop()\n    for vf in Edge[vn]:\n        if vf not in visited:\n            visited.add(vf)\n            dist[vf] = 1 + dist[vn]\n            stack.append(vf)\nif D[1] != sum(dist[1:]):\n    muri()\n\nfor a in Ans:\n    print(*a)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom bisect import bisect_left\ndef input():\n\treturn sys.stdin.readline()[:-1]\nsys.setrecursionlimit(10**6)\n\nn = int(input())\nd = [[int(input()), i+1] for i in range(n)]\ncheck = d[0][0]\nd.sort()\nind = [x[1] for x in d]\nd = [x[0] for x in d]\nif n <= 3:\n\tprint(-1)\n\tsys.exit()\n#print(d)\nchild = [1 for _ in range(n)]\n#print(gap)\nans = []\nadj = [[] for _ in range(n)]\nfor i in range(n-1, 0, -1):\n\tx = d[i]\n\tb = bisect_left(d, x - n + 2*child[i])\n\t#print(i, x, n - 2+child[i], b)\n\tif d[b] != x - n + 2*child[i] or n <= 2*child[i]:\n\t\tprint(-1)\n\t\tsys.exit()\n\telse:\n\t\tchild[b] += child[i]\n\t\tans.append([ind[b], ind[i]])\n\t\tadj[ind[b]-1].append(ind[i]-1)\n\t\tadj[ind[i]-1].append(ind[b]-1)\n\n\nres = 0\ndef dfs(x, p, dis):\n\tglobal res\n\tres += dis\n\tfor v in adj[x]:\n\t\tif v == p:\n\t\t\tcontinue\n\t\telse:\n\t\t\tdfs(v, x, dis+1)\n\treturn\n\ndfs(0, -1, 0)\nif res == check:\n\tfor a in ans:\n\t\tprint(*a)\nelse:\n\tprint(-1)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom bisect import bisect_left\ndef input():\n\treturn sys.stdin.readline()[:-1]\nsys.setrecursionlimit(10**6)\n\nn = int(input())\nd = sorted([[int(input()), i+1] for i in range(n)])\nind = [x[1] for x in d]\nd = [x[0] for x in d]\nif n <= 3 or n%2 == 0:\n\tprint(-1)\n\tsys.exit()\n#print(d)\nchild = [1 for _ in range(n)]\n#print(gap)\nans = []\nadj = [[] for _ in range(n)]\nfor i in range(n-1, 0, -1):\n\tx = d[i]\n\tb = bisect_left(d, x - n + 2*child[i])\n\t#print(i, x, n - 2+child[i], b)\n\tif d[b] != x - n + 2*child[i]:\n\t\tprint(-1)\n\t\tsys.exit()\n\telse:\n\t\tchild[b] += child[i]\n\t\tans.append([ind[b], ind[i]])\n\t\tadj[ind[b]-1].append(ind[i]-1)\n\t\tadj[ind[i]-1].append(ind[b]-1)\n\n\nres = 0\ndef dfs(x, p, dis):\n\tglobal res\n\tres += dis\n\tfor v in adj[x]:\n\t\tif v == p:\n\t\t\tcontinue\n\t\telse:\n\t\t\tdfs(v, x, dis+1)\n\treturn\n\ndfs(0, -1, 0)\nif res == d[0]:\n\tfor a in ans:\n\t\tprint(*a)\nelse:\n\tprint(-1)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nN = int(input())\nC = defaultdict(int)\nfor i in range(N):\n  D = int(input())\n  C[D] = i + 1\nE = []\nH = [1] * (N + 1)\nDD = sorted([[k, v] for k, v in C.items()], reverse=True)\nAdj = [[] for i in range(N)]\nfor D, n in DD[:-1]:\n  try:\n    p = C[D - N + 2 * H[n]]\n    if n == p:\n      raise Error\n    E.append([n, p])\n    Adj[n - 1].append(p - 1)\n    Adj[p - 1].append(n - 1)\n    H[p] += H[n]\n  except:\n    print(-1)\n    break\nelse:\n  dist = [N] * N\n  dist[DD[-1][1] - 1] = 0\n  Q = [DD[-1][1] - 1] + [N] * N\n  tail = 1\n  for i in range(N):\n    s = Q[i]\n    if s == N:\n      print(-1)\n      break\n    for adj in Adj[s]:\n      if dist[adj] == N:\n        dist[adj] = dist[s] + 1\n        Q[tail] = adj\n        tail += 1\n  else:\n    if sum(dist) == DD[-1][0]:\n      for e in E:\n        print(e[0], e[1])\n    else:\n      print(-1)"
  },
  {
    "language": "Python",
    "code": "print(-1)"
  },
  {
    "language": "Python",
    "code": "N=int(input())\nnumlist=list(map(int,(input() for _ in range(N))))\nnumdict={y:x for x,y in enumerate(numlist)}\nsorted_list=sorted(numdict.items(),reverse=True)\n\namount_of_child=[1]*N\nsum_of_distance_of_child=[0]*N\nbranch_list=[]\n\nfor S,num in sorted_list:\n  nS=S+2*amount_of_child[num]-N\n  if nS in numdict:\n    nextnum=numdict[nS]\n    branch_list.append([num+1,nextnum+1])\n    amount_of_child[nextnum]+=amount_of_child[num]\n    sum_of_distance_of_child[nextnum]+=(sum_of_distance_of_child[num]+amount_of_child[num])\n    if amount_of_child[nextnum]==N:\n      break\n  else:\n    print (-1)\n    exit()\n\nif sorted_list[-1][0]==sum_of_distance_of_child[sorted_list[-1][1]]:\n  for _ in range(N-1):\n    x,y=branch_list.pop()\n    print(x,y)\nelse:\n  print (-1)\nexit()\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nsrc = [int(input()) for i in range(N)]\nidx = {a:i for i,a in enumerate(src)}\n\nsize = [1] * N\nss = list(sorted(src))\n\nes = []\nwhile len(ss) > 1:\n    a = ss.pop()\n    k = size[idx[a]]\n    b = a + 2*k - N\n    if b == a:\n        print(-1)\n        exit()\n    if b not in idx:\n        continue\n    size[idx[b]] = k + 1\n    es.append((idx[a],idx[b]))\n\ngr = [[] for i in range(N)]\nfor a,b in es:\n    gr[a].append(b)\n    gr[b].append(a)\n\nfrom collections import deque\ndist = [N] * N\ndist[idx[ss[0]]] = 0\nq = deque([idx[ss[0]]])\nwhile q:\n    v = q.popleft()\n    for to in gr[v]:\n        if dist[to] < N: continue\n        q.append(to)\n        dist[to] = dist[v] + 1\n\nif all(d<N for d in dist) and sum(dist) == ss[0]:\n    for a,b in es:\n        print(a+1, b+1)\nelse:\n    print(-1)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nd = [int(input()) for i in range(n)]\n\nif sum(d)%2 > 0:\n    print(-1)\n    exit()\n\nd = sorted([(dd, i) for i, dd in enumerate(d)], reverse = True)\nd_to_i = {dd:i for dd, i in d}\nn_child = [1]*n\nd_child = [0]*n\nans = []\nfor dd, i in d:\n    d_i = dd+2*n_child[i]-n\n    if d_i in d_to_i.keys():\n        i_next = d_to_i[d_i]\n        ans.append((i+1, i_next+1))\n        n_child[i_next] += n_child[i]\n        d_child[i_next] += d_child[i] + n_child[i]\n        if n_child[i_next] == n:\n            break\n    else:\n        print(-1)\n        exit()\n\nd_min, i_min = d[-1]\nif d_min == d_child[i_min]:\n    for a in ans:\n        print(*a)\nelse:\n     print(-1)\n"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\nimport sys\ndef muri():\n    print(-1)\n    sys.exit()\nN = int(input())\nD = [int(sys.stdin.readline()) for _ in range(N)]\n#D = list(map(int, input().split()))\nDidx = list(range(1, N+1))\nDidx.sort(key = lambda x: -D[x-1])\nH = {d: i for i, d in enumerate(D, 1)}\nH = Counter(H)\nD = [0] + D\nK = [0]*(N+1)\nAns = []\nfor vn in Didx[:-1]:\n    if K[vn] == 0:\n        K[vn] = 1\n    p = H[D[vn] - (N - 2*K[vn])]\n    if not p:\n        muri()\n    Ans.append((vn, p))\n    K[p] += K[vn] + 1\ns = set()\n\nEdge = [[] for _ in range(N+1)]\nfor a in Ans:\n    x, y = a\n    Edge[x].append(y)\n    Edge[y].append(x)\n\ndist = [10**9+7]*(N+1)\ndist[0] = 0\ndist[1] = 0\nstack = [1]\nvisited = set([1])\nwhile stack:\n    vn = stack.pop()\n    for vf in Edge[vn]:\n        if vf not in visited:\n            visited.add(vf)\n            dist[vf] = 1 + dist[vn]\n            stack.append(vf)\nif D[1] != sum(dist[1:]):\n    muri()\n\nfor a in Ans:\n    print(*a)"
  },
  {
    "language": "Python",
    "code": "print (-1)"
  },
  {
    "language": "Python",
    "code": "\ndef solve():\n    # N = int(raw_input())\n    # D = [int(raw_input()) for i in range(N)]\n    N = int(input())\n    D = [int(input()) for i in range(N)]\n    if sum(D) % 2 > 0:\n        print ('-1')\n        return\n    Di = sorted([(di, i) for i, di in enumerate(D)], key = lambda x : x[0], reverse = True)\n    d_to_i = {dd:i for dd, i in Di}\n    # child = [[] for i in range(N)]\n    ans = []\n    n_child = [1] * N\n    d_child = [0] * N\n    for valD, node in Di:\n        valD_par = valD - N + 2 * n_child[node]\n        if valD_par in d_to_i.keys():\n            node_par = d_to_i[valD_par]\n            # child[node].append(node_par) ##\n            # child[node_par].append(node)\n            ans.append((node_par + 1, node + 1))\n            n_child[node_par] += n_child[node]\n            d_child[node_par] += n_child[node] + d_child[node]\n            if n_child[node_par] == N:\n                break\n        else:\n            print ('-1')\n            return\n    # check if Di satisfied or not\n    d_min, i_min = Di[-1]\n    if d_child[i_min] != d_min:\n        print ('-1')\n        return\n    # for i in range(N):\n    #     for j in child[i]:\n    #         print str(i + 1) + ' ' + str(j + 1)\n    for i,j in ans:\n        print (str(i) + ' ' + str(j))\n\nif __name__ == '__main__':\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    N = int(raw_input())\n    D = [int(raw_input()) for i in range(N)]\n    if sum(D) % 2 > 0:\n        print '-1'\n        return\n    Di = sorted([(di, i) for i, di in enumerate(D)], key = lambda x : x[0], reverse = True)\n    d_to_i = {dd:i for dd, i in Di}\n    # child = [[] for i in range(N)]\n    ans = []\n    n_child = [1] * N\n    d_child = [0] * N\n    for valD, node in Di:\n        valD_par = valD - N + 2 * n_child[node]\n        if valD_par in d_to_i.keys():\n            node_par = d_to_i[valD_par]\n            # child[node].append(node_par) ##\n            # child[node_par].append(node)\n            ans.append([node_par + 1, node + 1])\n            n_child[node_par] += n_child[node]\n            d_child[node_par] += n_child[node] + d_child[node]\n            if n_child[node_par] == N:\n                break\n        else:\n            print '-1'\n            return\n    # check if Di satisfied or not\n    d_min, i_min = Di[-1]\n    if d_child[i_min] != d_min:\n        print '-1'\n        return\n    # for i in range(N):\n    #     for j in child[i]:\n    #         print str(i + 1) + ' ' + str(j + 1)\n    for ele in ans:\n        print str(ele[0]) + ' ' + str(ele[1])\n\nif __name__ == '__main__':\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\nimport sys\ndef muri():\n    print(-1)\n    sys.exit()\nN = int(input())\n#D = [int(sys.stdin.readline()) for _ in range(N)]\nD = list(map(int, input().split()))\nDidx = list(range(1, N+1))\nDidx.sort(key = lambda x: -D[x-1])\nH = {d: i for i, d in enumerate(D, 1)}\nH = Counter(H)\nD = [0] + D\nK = [0]*(N+1)\nAns = []\nfor vn in Didx[:-1]:\n    if K[vn] == 0:\n        K[vn] = 1\n    p = H[D[vn] - (N - 2*K[vn])]\n    if not p:\n        muri()\n    Ans.append((vn, p))\n    K[p] += K[vn] + 1\ns = set()\n\nEdge = [[] for _ in range(N+1)]\nfor a in Ans:\n    x, y = a\n    Edge[x].append(y)\n    Edge[y].append(x)\n\ndist = [10**9+7]*(N+1)\ndist[0] = 0\ndist[1] = 0\nstack = [1]\nvisited = set([1])\nwhile stack:\n    vn = stack.pop()\n    for vf in Edge[vn]:\n        if vf not in visited:\n            visited.add(vf)\n            dist[vf] = 1 + dist[vn]\n            stack.append(vf)\nif D[1] != sum(dist[1:]):\n    muri()\n\nfor a in Ans:\n    print(*a)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nfrom sys import stdin\nimport numpy as np\n# import sys\n# sys.setrecursionlimit(10**4)\n\ndef _li(): return list(map(int, stdin.readline().split()))\ndef _li_(): return list(map(lambda x: int(x)-1, stdin.readline().split()))\ndef _lf(): return list(map(float, stdin.readline().split()))\ndef _ls(): return stdin.readline().split()\ndef _i(): return int(stdin.readline())\ndef _f(): return float(stdin.readline())\ndef _s(): return stdin.readline()[:-1]\n\n\nN = _i()\nD_list = np.array([_i() for _ in range(N)])\nidx = np.argsort(D_list)\nsorted_D = D_list[idx]\nmapping = []\nfor j in idx:\n    mapping.append(j+1)\n\n# 解説を参考に実装\n# Dのスコアが大きい方から小さい方へ伸びる有向エッジとみなす\n# valueはノードから出ている有向エッジを切った場合の部分木の大きさ\nnodes = [1] * N\nans = []\ncost = [[0, 1] for _ in range(N)]\n# 葉っぱから見て，[エッジにたどり着くまでのコスト, 自分も含めた子ノードの数]\nfor i in range(N-1, 0, -1):\n    d = sorted_D[i]\n    sub = nodes[i]\n    target = d + 2*sub - N\n    cand = np.searchsorted(sorted_D[:i], target)\n    if (sorted_D[cand] != target) or (cand == i):\n        print(-1)\n        exit()\n    else:\n        ans.append((mapping[i], mapping[cand]))\n        nodes[cand] += nodes[i]\n        cost[cand][0] += (cost[i][0] + cost[i][1])\n        cost[cand][1] += cost[i][1]\n\n# 1番目のノードについてチェック\nif cost[0][0] != sorted_D[0]:\n    print(-1)\n    exit()\nelse:\n    for a in ans:\n        print(a[0], a[1])\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::{self, BufRead};\nuse std::collections::BTreeMap;\n\n#[derive(Debug, Clone)]\nstruct Tree {\n  id: usize,\n  count: usize,\n  children: Vec<Box<Tree>>,\n}\n\nfn dfs(t: &Box<Tree>, es: &mut Vec<(usize, usize)>) {\n  for c in &t.children {\n    es.push((t.id, c.id));\n    dfs(&c, es);\n  }\n}\n\nfn main() {\n  let stdin = io::stdin();\n  let mut lines = stdin.lock().lines();\n  let n: usize = lines.next().unwrap().unwrap().parse().unwrap();\n  let mut ds: Vec<(usize, usize)> = Vec::new();\n  for i in 0..n {\n    let x: usize = lines.next().unwrap().unwrap().parse().unwrap();\n    ds.push((i + 1, x));\n  }\n  ds.sort_by(|x, y| y.1.cmp(&x.1));\n  let mut forest: BTreeMap<usize, Vec<Box<Tree>>> = BTreeMap::new();\n  for tup in &ds {\n    let i = tup.0;\n    let d = tup.1;\n    let v = if let Some(cn) = forest.get(&d) {\n      Tree { id: i, count: 1 + cn.iter().map(|c| c.count).sum::<usize>(), children: cn.to_vec() }\n    } else {\n      Tree { id: i, count: 1, children: Vec::new() }\n    };\n    forest.remove(&d);\n    let k = d + 2 * v.count - n;\n    let contains = forest.contains_key(&k);\n    if contains {\n      if let Some(t) = forest.get_mut(&k) {\n        t.push(Box::new(v));\n      }\n    } else {\n      forest.insert(k, vec![Box::new(v)]);\n    }\n  }\n  if forest.len() != 1 || forest.iter().next().unwrap().1.len() != 1 {\n    println!(\"-1\");\n    return;\n  }\n  let mut es: Vec<(usize, usize)> = Vec::new();\n  let t = &forest.iter().next().unwrap().1[0];\n  dfs(t, &mut es);\n  for (x, y) in es {\n    println!(\"{} {}\", x, y);\n  }\n}"
  },
  {
    "language": "Rust",
    "code": "use std::collections::BTreeMap;\nuse std::io::*;\nuse std::str::FromStr;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\nfn dfs(from: usize, depth: i64, childs: &Vec<Vec<usize>>) -> i64 {\n    let mut ret = depth;\n    for &to in childs[from].iter() {\n        ret += dfs(to, depth + 1, childs);\n    }\n    return ret;\n}\n\nfn main() {\n    let n = read::<usize>();\n    let mut items = BTreeMap::<i64, usize>::new();\n    for i in 0..n {\n        let v = read::<i64>();\n        items.insert(v, i);\n    }\n    let mut childs = vec![vec![]; n];\n    let mut parents = vec![n; n];\n    let mut cnts = vec![1; n];\n    for (&v, &index) in items.iter().rev() {\n        let tv = v - (n as i64 - 2 * cnts[index]);\n        if cnts[index] == n as i64 || tv <= 0 || tv == v {\n            break;\n        }\n        if let Some(&nindex) = items.get(&tv) {\n            parents[index] = nindex;\n            childs[nindex].push(index);\n            cnts[nindex] += cnts[index];\n        } else {\n            println!(\"-1\");\n            return;\n        }\n    }\n    let (&root_weight, &root) = items.iter().next().unwrap();\n    let weight = dfs(root, 0, &childs);\n    if weight != root_weight {\n        println!(\"-1\");\n        return;\n    }\n    for i in 0..n {\n        if parents[i] == n {\n            continue;\n        }\n        println!(\"{} {}\", i + 1, parents[i] + 1);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($format:expr) => (write!(out,$format).unwrap());\n        ($format:expr, $($args:expr),+) => (write!(out,$format,$($args),*).unwrap())\n    }\n    input!{\n        n: usize,\n        d: [i64; n],\n    }\n    let mut pool = vec![];\n    for i in 0 .. n {\n        pool.push((d[i], i));\n    }\n    pool.sort();\n    pool.reverse();\n    let mut edges = vec![];\n    let mut gad: HashMap<i64, Vec<(usize, i64)>> = HashMap::new();\n    for (p, idx) in pool {\n        if let Some(vs) = gad.remove(&p) {\n            let mut sz = 0;\n            for &(v, s) in vs.iter() {\n                sz += s;\n                edges.push((v, idx));\n            }\n            sz += 1;\n            let targ = p + 2 * sz - n as i64;\n            gad.entry(targ).or_insert(vec![]).push((idx, sz));\n        } else {\n            let sz = 1;\n            let targ = p + 2 * sz - n as i64;\n            gad.entry(targ).or_insert(vec![]).push((idx, sz));\n        }\n    }\n    assert!(gad.len() >= 1);\n    if gad.len() == 1 {\n        for (u, v) in edges {\n            puts!(\"{} {}\\n\", u + 1, v + 1);\n        }\n    } else {\n        puts!(\"-1\\n\");\n        return;\n    }\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::{self, BufRead};\nuse std::collections::BTreeMap;\n\n#[derive(Debug, Clone)]\nstruct Tree {\n  id: usize,\n  count: usize,\n  children: Vec<Box<Tree>>,\n}\n\nfn dfs(t: &Box<Tree>, es: &mut Vec<(usize, usize)>) {\n  for c in &t.children {\n    es.push((t.id, c.id));\n    dfs(&c, es);\n  }\n}\n\nfn main() {\n  let stdin = io::stdin();\n  let mut lines = stdin.lock().lines();\n  let n: usize = lines.next().unwrap().unwrap().parse().unwrap();\n  let mut ds: Vec<(usize, usize)> = Vec::new();\n  for i in 0..n {\n    let x: usize = lines.next().unwrap().unwrap().parse().unwrap();\n    ds.push((i + 1, x));\n  }\n  ds.sort_by(|x, y| y.1.cmp(&x.1));\n  let mut forest: BTreeMap<usize, Vec<Box<Tree>>> = BTreeMap::new();\n  for (i, d) in &ds {\n    let v = if let Some(cn) = forest.get(d) {\n      Tree { id: *i, count: 1 + cn.iter().map(|c| c.count).sum::<usize>(), children: cn.to_vec() }\n    } else {\n      Tree { id: *i, count: 1, children: Vec::new() }\n    };\n    forest.remove(d);\n    let k = *d + 2 * v.count - n;\n    if let Some(t) = forest.get_mut(&k) {\n      t.push(Box::new(v));\n    } else {\n      forest.insert(k, vec![Box::new(v)]);\n    }\n  }\n  if forest.len() != 1 || forest.iter().next().unwrap().1.len() != 1 {\n    println!(\"-1\");\n    return;\n  }\n  let mut es: Vec<(usize, usize)> = Vec::new();\n  let t = &forest.iter().next().unwrap().1[0];\n  dfs(t, &mut es);\n  for (x, y) in es {\n    println!(\"{} {}\", x, y);\n  }\n}"
  },
  {
    "language": "Rust",
    "code": "use proconio::input;\n\nfn err() -> ! {\n    println!(\"{}\", -1);\n    std::process::exit(0);\n}\n\nfn main() {\n    input!(n: usize, d: [u64; n]);\n    let mut di: Vec<_> = d.iter().enumerate().map(|(i, &d)| (d, i)).collect();\n    di.sort_by_key(|&p| std::cmp::Reverse(p));\n    eprintln!(\"{:?}\", di);\n\n    let mut size = vec![1; n];\n    let mut ans = vec![];\n    for (si, &(d, i)) in di.iter().take(n - 1).enumerate() {\n        let e = d - n as u64 + 2 * size[i];\n        if d < e {\n            err();\n        }\n        let (j, sj) = {\n            let mut l = 0;\n            let mut r = n;\n            while 1 < r - l {\n                let c = (l + r) / 2;\n                if di[c].0 < e {\n                    r = c;\n                } else {\n                    l = c;\n                }\n            }\n            (di[l].1, l)\n        };\n        if sj <= si || di[sj].0 != e {\n            err();\n        }\n        ans.push((j, i));\n        size[j] += size[i];\n        eprintln!(\"{:?}\", &size);\n    }\n    for (u, v) in ans {\n        println!(\"{} {}\", u + 1, v + 1);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/arc103/tasks/arc103_d\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nfn main() {\n    input! {\n        n: usize,\n        d: [i64; n]\n    };\n    let mut d = d.into_iter().zip(0..n).collect::<Vec<_>>();\n    d.sort_by_key(|&(w,idx)| -w);\n\n    let mut dmap = HashMap::new();\n    for i in 0..n {\n        dmap.insert(d[i].0, d[i].1);\n    }\n\n    let n64 = n as i64;\n    let mut edges = vec![];\n    let mut used = vec![false; n];\n    let mut cnt = vec![1; n];\n\n    let mut is_ok = true;\n    for &(dist,vidx) in &d {\n        let to_dist = dist - n64 + cnt[vidx] * 2;\n        if to_dist > dist {\n            continue;\n        }\n        // debug!(dist, to_dist, dmap.get(&to_dist));\n        match dmap.get(&to_dist) {\n            None => {\n                is_ok = false;\n                break;\n            },\n            Some(&idx) => {\n                edges.push((vidx,idx));\n                cnt[idx] += cnt[vidx];\n            }\n        }\n    }\n\n    is_ok &= edges.len() == n-1;\n\n    d.sort_by_key(|&(w,idx)| idx);\n    is_ok &= try_make(&d, &edges);\n\n    if is_ok {\n        for (u, v) in edges {\n            println!(\"{} {}\", u+1, v+1);\n        }\n    } else {\n        println!(\"-1\");\n    }\n\n\n}\n\nfn try_make(d: &Vec<(i64, usize)>, edges: &Vec<(usize, usize)>) -> bool {\n    let n = edges.len()+1;\n    let mut graph = vec![vec![]; n];\n    for &(u,v) in edges {\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n    let (nn, d0) = dfs(0, None, &graph);\n    d[0].0 == d0\n}\n\nfn dfs(now: usize, par: Option<usize>, graph: &Vec<Vec<usize>>) -> (i64, i64) {\n    let mut w = 1;\n    let mut total_d = 0;\n    for &to in &graph[now] {\n        if Some(to) == par {\n            continue;\n        }\n        let (wc, t) = dfs(to, Some(now), graph);\n        w += wc;\n        total_d += t + wc;\n    }\n    (w, total_d)\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/arc103/tasks/arc103_d\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nfn main() {\n    input! {\n        n: usize,\n        d: [i64; n]\n    };\n    let mut d = d.into_iter().zip(0..n).collect::<Vec<_>>();\n    d.sort_by_key(|&(w,idx)| -w);\n\n    let mut dmap = HashMap::new();\n    for i in 0..n {\n        dmap.insert(d[i].0, d[i].1);\n    }\n\n    let n64 = n as i64;\n    let mut edges = vec![];\n    let mut used = vec![false; n];\n    let mut cnt = vec![1; n];\n\n    let mut is_ok = true;\n    for (dist,vidx) in d {\n        let to_dist = dist - n64 + cnt[vidx] * 2;\n        if to_dist > dist {\n            continue;\n        }\n        // debug!(dist, to_dist, dmap.get(&to_dist));\n        match dmap.get(&to_dist) {\n            None => {\n                is_ok = false;\n                break;\n            },\n            Some(&idx) => {\n                edges.push((vidx,idx));\n                cnt[idx] += cnt[vidx];\n            }\n        }\n    }\n\n    let mut uf = UnionFind::new(n);\n    for &(u, v) in &edges {\n        uf.unite(u, v);\n    }\n    is_ok &= edges.len() == n-1;\n    is_ok &= uf.count[0] == n;\n\n    if is_ok {\n        for (u, v) in edges {\n            println!(\"{} {}\", u+1, v+1);\n        }\n    } else {\n        println!(\"-1\");\n    }\n}\n\n\nstruct UnionFind {\n      n: usize,\n      parent: Vec<usize>,\n      count: Vec<usize>\n}\n\nimpl UnionFind {\n     fn new(n: usize) -> Self {\n           let mut p = vec![0; n];\n           for i in 0..n {\n                 p[i] = i;\n           }\n           UnionFind { n: n, parent: p, count: vec![1; n] }\n     }\n\n     fn find(&mut self, a: usize) -> usize {\n           if self.parent[a] == a {\n                 return a;\n           }\n           let par = self.parent[a];\n           self.parent[a] = self.find(par);\n           self.parent[a]\n     }\n\n     fn unite(&mut self, a: usize, b: usize) {\n           let a = self.find(a);\n           let b = self.find(b);\n           if a == b {\n                 return;\n           }\n           let ca = self.count[a];\n           let cb = self.count[b];\n           let total = ca + cb;\n           self.count[b] = total;\n           self.count[a] = total;\n           if ca < cb {\n                 self.parent[a] = b;\n           } else {\n                 self.parent[b] = a;\n           }\n     }\n\n     fn same(&mut self, a: usize, b: usize) -> bool {\n           self.find(a) == self.find(b)\n     }\n\n     fn count(&mut self, a: usize) -> usize {\n           let a = self.find(a);\n           self.count[a]\n     }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::prelude::*;\n\nfn input<T: std::str::FromStr>() -> T {\n    let stdin = std::io::stdin();\n    let token: String = stdin\n        .lock()\n        .bytes()\n        .map(|c| c.unwrap() as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().unwrap()\n}\n\nfn with_stdout_lock<F: FnOnce(std::io::BufWriter<std::io::StdoutLock>)>(f: F) {\n    let out = std::io::stdout();\n    let w = std::io::BufWriter::new(out.lock());\n    f(w);\n}\n\nfn main() {\n    let n: usize = input();\n    let mut d: Vec<(i64, usize)> = (0..n).map(|i| (input(), i)).collect();\n    d.sort_by_key(|&(d, _)| -d);\n\n    let mut edges = vec![vec![]; n];\n    let mut uf = UnionFind::new(n);\n    for i in 0..n - 1 {\n        let (di, u) = d[i];\n        let s = uf.size(u) as i64;\n        let dj = di - n as i64 + 2 * s;\n        let k = d.lower_bound_by_key(&Reverse(dj), |&(d, _)| Reverse(d));\n        let (dk, v) = d[k];\n        if dk != dj {\n            println!(\"-1\");\n            return;\n        }\n        edges[u].push(v);\n        edges[v].push(u);\n        uf.union(u, v);\n    }\n\n    let mut dist = vec![-1; n];\n    dfs(0, 0, &edges, &mut dist);\n    let dist_sum: i64 = dist.iter().sum();\n    d.sort_by_key(|&(_, v)| v);\n    if dist_sum != d[0].0 {\n        println!(\"-1\");\n        return;\n    }\n\n    with_stdout_lock(|mut w| {\n        for u in 0..n {\n            for &v in &edges[u] {\n                if u < v {\n                    writeln!(w, \"{} {}\", u + 1, v + 1).unwrap();\n                }\n            }\n        }\n    });\n}\n\nfn dfs(cur: usize, d: i64, edges: &Vec<Vec<usize>>, dist: &mut Vec<i64>) {\n    dist[cur] = d;\n    for &nxt in &edges[cur] {\n        if dist[nxt] < 0 {\n            dfs(nxt, d + 1, edges, dist);\n        }\n    }\n}\n\n#[derive(Clone, Copy, Debug, Default, Eq, Hash, PartialEq)]\nstruct Reverse<T>(T);\nimpl<T: PartialOrd> PartialOrd for Reverse<T> {\n    fn partial_cmp(&self, other: &Reverse<T>) -> Option<std::cmp::Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n}\nimpl<T: Ord> Ord for Reverse<T> {\n    fn cmp(&self, other: &Reverse<T>) -> std::cmp::Ordering {\n        other.0.cmp(&self.0)\n    }\n}\n\ntrait LowerBound<T: Ord> {\n    fn lower_bound_by<F: FnMut(&T) -> std::cmp::Ordering>(&self, f: F) -> usize;\n    fn lower_bound(&self, x: &T) -> usize {\n        self.lower_bound_by(|e| e.cmp(x))\n    }\n    fn lower_bound_by_key<U: Ord, F: FnMut(&T) -> U>(&self, x: &U, mut f: F) -> usize {\n        self.lower_bound_by(|e| f(e).cmp(x))\n    }\n}\nimpl<T: Ord> LowerBound<T> for [T] {\n    fn lower_bound_by<F: FnMut(&T) -> std::cmp::Ordering>(&self, mut f: F) -> usize {\n        let mut l = -1 as i64;\n        let mut r = self.len() as i64;\n        while r - l > 1 {\n            let m = ((l + r) / 2) as usize;\n            if f(&self[m]) == std::cmp::Ordering::Less {\n                l = m as i64;\n            } else {\n                r = m as i64;\n            }\n        }\n        r as usize\n    }\n}\n\nstruct UnionFind {\n    parent: Vec<usize>,\n    size: Vec<usize>,\n}\nimpl UnionFind {\n    fn new(n: usize) -> UnionFind {\n        UnionFind {\n            parent: (0..n).collect(),\n            size: vec![1; n],\n        }\n    }\n    fn find(&mut self, x: usize) -> usize {\n        if self.parent[x] == x {\n            x\n        } else {\n            let p = self.parent[x];\n            self.parent[x] = self.find(p);\n            self.parent[x]\n        }\n    }\n    fn union(&mut self, x: usize, y: usize) -> bool {\n        let mut x = self.find(x);\n        let mut y = self.find(y);\n        if x == y {\n            false\n        } else {\n            if self.size[x] < self.size[y] {\n                std::mem::swap(&mut x, &mut y);\n            }\n            self.parent[y] = x;\n            self.size[x] += self.size[y];\n            true\n        }\n    }\n    fn size(&mut self, x: usize) -> usize {\n        let p = self.find(x);\n        self.size[p]\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::collections::BTreeMap;\nuse std::io::*;\nuse std::str::FromStr;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\nfn dfs(from: usize, depth: i64, childs: &Vec<Vec<usize>>) -> i64 {\n    let mut ret = depth;\n    for &to in childs[from].iter() {\n        ret += dfs(to, depth + 1, childs);\n    }\n    return ret;\n}\n\nfn main() {\n    let n = read::<usize>();\n    let mut items = BTreeMap::<i64, usize>::new();\n    for i in 0..n {\n        let v = read::<i64>();\n        items.insert(v, i);\n    }\n    let mut childs = vec![vec![]; n];\n    let mut parents = vec![n; n];\n    let mut cnts = vec![1; n];\n    for (&v, &index) in items.iter().rev() {\n        let tv = v - (n as i64 - 2 * cnts[index]);\n        if cnts[index] == n as i64 || tv <= 0 || tv == v {\n            break;\n        }\n        if let Some(&nindex) = items.get(&tv) {\n            parents[index] = nindex;\n            childs[nindex].push(index);\n            cnts[nindex] += cnts[index];\n        } else {\n            println!(\"-1\");\n            return;\n        }\n    }\n    let root = *items.iter().next().unwrap().1;\n    let root_weight = *items.iter().next().unwrap().0;\n    let weight = dfs(root, 0, &childs);\n    if weight != root_weight {\n        println!(\"-1\");\n        return;\n    }\n    for i in 0..n {\n        if parents[i] == n {\n            continue;\n        }\n        println!(\"{} {}\", i + 1, parents[i] + 1);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/arc103/tasks/arc103_d\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nfn main() {\n    input! {\n        n: usize,\n        d: [i64; n]\n    };\n    let mut d = d.into_iter().zip(0..n).collect::<Vec<_>>();\n    d.sort_by_key(|&(w,idx)| -w);\n\n    let mut dmap = HashMap::new();\n    for i in 0..n {\n        dmap.insert(d[i].0, d[i].1);\n    }\n\n    let n64 = n as i64;\n    let mut edges = vec![];\n    let mut used = vec![false; n];\n    let mut cnt = vec![1; n];\n\n    let mut is_ok = true;\n    for (dist,vidx) in d {\n        let to_dist = dist - n64 + cnt[vidx] * 2;\n        if to_dist > dist {\n            continue;\n        }\n        // debug!(dist, to_dist, dmap.get(&to_dist));\n        match dmap.get(&to_dist) {\n            None => {\n                is_ok = false;\n                break;\n            },\n            Some(&idx) => {\n                edges.push((vidx,idx));\n                cnt[idx] += cnt[vidx];\n            }\n        }\n    }\n\n    let mut uf = UnionFind::new(n);\n    for &(u, v) in &edges {\n        uf.unite(u, v);\n    }\n    is_ok &= edges.len() == n-1;\n    is_ok &= uf.count(0) == n;\n\n    if is_ok {\n        for (u, v) in edges {\n            println!(\"{} {}\", u+1, v+1);\n        }\n    } else {\n        println!(\"-1\");\n    }\n}\n\n\nstruct UnionFind {\n      n: usize,\n      parent: Vec<usize>,\n      count: Vec<usize>\n}\n\nimpl UnionFind {\n     fn new(n: usize) -> Self {\n           let mut p = vec![0; n];\n           for i in 0..n {\n                 p[i] = i;\n           }\n           UnionFind { n: n, parent: p, count: vec![1; n] }\n     }\n\n     fn find(&mut self, a: usize) -> usize {\n           if self.parent[a] == a {\n                 return a;\n           }\n           let par = self.parent[a];\n           self.parent[a] = self.find(par);\n           self.parent[a]\n     }\n\n     fn unite(&mut self, a: usize, b: usize) {\n           let a = self.find(a);\n           let b = self.find(b);\n           if a == b {\n                 return;\n           }\n           let ca = self.count[a];\n           let cb = self.count[b];\n           let total = ca + cb;\n           self.count[b] = total;\n           self.count[a] = total;\n           if ca < cb {\n                 self.parent[a] = b;\n           } else {\n                 self.parent[b] = a;\n           }\n     }\n\n     fn same(&mut self, a: usize, b: usize) -> bool {\n           self.find(a) == self.find(b)\n     }\n\n     fn count(&mut self, a: usize) -> usize {\n           let a = self.find(a);\n           self.count[a]\n     }\n}\n"
  },
  {
    "language": "Rust",
    "code": "//https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8 より\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n//\n\nfn run() {\n    input! {\n        n: usize,\n        distance_sum: [i64; n],\n    }\n    let mut d = distance_sum.iter().cloned().enumerate().collect::<Vec<_>>();\n    d.sort_by_key(|d| d.1);\n    let mut size = vec![1i64; n];\n    let mut edge = Vec::with_capacity(n - 1);\n    let mut deg = vec![0; n + 1];\n    for i in (1..n).rev() {\n        let (a, x) = d[i];\n        let y = x - n as i64 + 2 * size[a];\n        if let Ok(k) = d.binary_search_by(|d| d.1.cmp(&y)) {\n            let b = d[k].0;\n            size[b] += size[a];\n            edge.push((a, b));\n            deg[a] += 1;\n            deg[b] += 1;\n        } else {\n            println!(\"-1\");\n            return;\n        }\n        size[a] = 0;\n    }\n    if !size.iter().any(|s| *s == n as i64) {\n        println!(\"-1\");\n        return;\n    }\n    for i in 1..(n + 1) {\n        deg[i] += deg[i - 1];\n    }\n    let mut buf = vec![0; 2 * (n - 1)];\n    for &(a, b) in edge.iter() {\n        deg[a] -= 1;\n        buf[deg[a]] = b;\n        deg[b] -= 1;\n        buf[deg[b]] = a;\n    }\n    let neighbor = |v: usize| &buf[deg[v]..deg[v + 1]];\n    let mut q = Vec::with_capacity(n);\n    let mut parent = vec![0; n];\n    let mut dfs = vec![0];\n    while let Some(v) = dfs.pop() {\n        q.push(v);\n        let p = parent[v];\n        for &u in neighbor(v).iter() {\n            if u != p {\n                parent[u] = v;\n                dfs.push(u);\n            }\n        }\n    }\n    let mut dp1 = vec![0; n];\n    size.clear();\n    size.resize(n, 1);\n    for &v in q.iter().rev() {\n        let p = parent[v];\n        for &u in neighbor(v).iter() {\n            if u != p {\n                dp1[v] += dp1[u] + size[u];\n                size[v] += size[u];\n            }\n        }\n    }\n    let mut dp2 = dp1.clone();\n    for &v in q.iter() {\n        let p = parent[v];\n        for &u in neighbor(v).iter() {\n            if u != p {\n                dp2[u] = dp2[v] + n as i64 - size[u] * 2;\n            }\n        }\n    }\n    if dp2.iter().zip(distance_sum.iter()).all(|p| *p.0 == *p.1) {\n        let mut out = String::new();\n        for (a, b) in edge {\n            out.push_str(&format!(\"{} {}\\n\", a + 1, b + 1));\n        }\n        print!(\"{}\", out);\n    } else {\n        println!(\"-1\");\n    }\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/arc103/tasks/arc103_d\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nfn main() {\n    input! {\n        n: usize,\n        d: [i64; n]\n    };\n    let mut d = d.into_iter().zip(0..n).collect::<Vec<_>>();\n    d.sort_by_key(|&(w,idx)| -w);\n\n    let mut dmap = HashMap::new();\n    for i in 0..n {\n        dmap.insert(d[i].0, d[i].1);\n    }\n\n    let n64 = n as i64;\n    let mut edges = vec![];\n    let mut used = vec![false; n];\n    let mut cnt = vec![1; n];\n\n    let mut is_ok = true;\n    for (dist,vidx) in d {\n        let to_dist = dist - n64 + cnt[vidx] * 2;\n        if to_dist > dist {\n            break;\n        }\n        // debug!(dist, to_dist, dmap.get(&to_dist));\n        match dmap.get(&to_dist) {\n            None => {\n                is_ok = false;\n                break;\n            },\n            Some(&idx) => {\n                edges.push((vidx,idx));\n                cnt[idx] += cnt[vidx];\n            }\n        }\n    }\n\n    is_ok &= edges.len() == n-1;\n    if is_ok {\n        for (u, v) in edges {\n            println!(\"{} {}\", u+1, v+1);\n        }\n    } else {\n        println!(\"-1\");\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::input;\n\nfn err() -> ! {\n    println!(\"{}\", -1);\n    std::process::exit(0);\n}\n\nfn main() {\n    input!(n: usize, d: [u64; n]);\n    let mut ord: Vec<_> = (0..n).collect();\n    ord.sort_by_key(|&i| std::cmp::Reverse(d[i]));\n    let mut vid = vec![0; n];\n    (0..n).for_each(|i| vid[ord[i]] = i);\n    let mut d_sorted_reverse = d.clone();\n    d_sorted_reverse.sort_by_key(|&x| std::cmp::Reverse(x));\n\n    let mut g = vec![vec![]; n];\n    let mut ans = vec![];\n    let mut size = vec![1; n];\n    for (si, &i) in ord.iter().enumerate().take(n - 1) {\n        if n as u64 <= size[i] * 2 {\n            err();\n        }\n        let di = d[i];\n        let dj = di - n as u64 + 2 * size[i];\n        let sj = d_sorted_reverse\n            .binary_search_by_key(&std::cmp::Reverse(dj), |&x| std::cmp::Reverse(x))\n            .unwrap_or_else(|_| err());\n        assert!(si < sj);\n        let j = ord[sj];\n        size[j] += size[i];\n        ans.push((i, j));\n        g[j].push(i);\n    }\n\n    let root = ord[n - 1];\n    fn dfs(x: usize, g: &Vec<Vec<usize>>, size: &Vec<u64>) -> u64 {\n        let mut ans = 0;\n        for &y in &g[x] {\n            ans += dfs(y, &g, &size) + size[y];\n        }\n        ans\n    }\n    if dfs(root, &g, &size) != d[root] {\n        err();\n    }\n    for (u, v) in ans {\n        println!(\"{} {}\", u + 1, v + 1);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn dfs(v: usize, par: Option<usize>, d: i64, g: &[Vec<usize>]) -> (i64, i64) {\n    let mut tot = 0;\n    let mut ssz = 1;\n    for &w in g[v].iter() {\n        if Some(w) == par { continue; }\n        let (sub, sz) = dfs(w, Some(v), d + 1, g);\n        tot += sub + sz;\n        ssz += sz;\n    }\n    (tot, ssz)\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($format:expr) => (write!(out,$format).unwrap());\n        ($format:expr, $($args:expr),+) => (write!(out,$format,$($args),*).unwrap())\n    }\n    input!{\n        n: usize,\n        d: [i64; n],\n    }\n    let mut pool = vec![];\n    for i in 0 .. n {\n        pool.push((d[i], i));\n    }\n    pool.sort();\n    pool.reverse();\n    let mut edges = vec![];\n    let mut gad: HashMap<i64, Vec<(usize, i64)>> = HashMap::new();\n    for (p, idx) in pool {\n        if let Some(vs) = gad.remove(&p) {\n            let mut sz = 0;\n            for &(v, s) in vs.iter() {\n                sz += s;\n                edges.push((v, idx));\n            }\n            sz += 1;\n            let targ = p + 2 * sz - n as i64;\n            if sz != n as i64 {\n                gad.entry(targ).or_insert(vec![]).push((idx, sz));\n            }\n        } else {\n            let sz = 1;\n            let targ = p + 2 * sz - n as i64;\n            gad.entry(targ).or_insert(vec![]).push((idx, sz));\n        }\n    }\n    let mut g = vec![Vec::new(); n];\n    for &(u, v) in &edges {\n        g[u].push(v);\n        g[v].push(u);\n    }\n    let (d0, _) = dfs(0, None, 0, &g);\n    if gad.len() == 0 && d[0] == d0 {\n        for (u, v) in edges {\n            puts!(\"{} {}\\n\", u + 1, v + 1);\n        }\n    } else {\n        puts!(\"-1\\n\");\n        return;\n    }\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::input;\n\nfn err() -> ! {\n    println!(\"{}\", -1);\n    std::process::exit(0);\n}\n\nfn main() {\n    input!(n: usize, d: [u64; n]);\n    let mut ord: Vec<_> = (0..n).collect();\n    ord.sort_by_key(|&i| std::cmp::Reverse(d[i]));\n    let mut vid = vec![0; n];\n    (0..n).for_each(|i| vid[ord[i]] = i);\n    let mut d_sorted_reverse = d.clone();\n    d_sorted_reverse.sort_by_key(|&x| std::cmp::Reverse(x));\n\n    let mut g = vec![vec![]; n];\n    let mut ans = vec![];\n    let mut size = vec![1; n];\n    for (si, &i) in ord.iter().enumerate().take(n - 1) {\n        if n as u64 <= size[i] * 2 {\n            err();\n        }\n        let di = d[i];\n        let dj = di - n as u64 + 2 * size[i];\n        let sj = d_sorted_reverse\n            .binary_search_by_key(&std::cmp::Reverse(dj), |&x| std::cmp::Reverse(x))\n            .unwrap_or_else(|_| err());\n        assert!(si < sj);\n        let j = ord[sj];\n        size[j] += size[i];\n        ans.push((i, j));\n        g[j].push(i);\n    }\n\n    let root = ord[n - 1];\n    fn dfs(x: usize, g: &Vec<Vec<usize>>, size: &Vec<u64>) -> u64 {\n        dbg!(x);\n        let mut ans = 0;\n        for &y in &g[x] {\n            ans += dfs(y, &g, &size) + size[y];\n        }\n        ans\n    }\n    if dbg!(dfs(root, &g, &size)) != dbg!(d[root]) {\n        err();\n    }\n    for (u, v) in ans {\n        println!(\"{} {}\", u + 1, v + 1);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::{self, BufRead};\nuse std::collections::BTreeMap;\n\n#[derive(Debug, Clone)]\nstruct Tree {\n  id: usize,\n  count: usize,\n  children: Vec<Box<Tree>>,\n}\n\nfn dfs(t: &Box<Tree>, es: &mut Vec<(usize, usize)>) {\n  for c in &t.children {\n    es.push((t.id, c.id));\n    dfs(&c, es);\n  }\n}\n\nfn main() {\n  let stdin = io::stdin();\n  let mut lines = stdin.lock().lines();\n  let n: usize = lines.next().unwrap().unwrap().parse().unwrap();\n  let mut ds: Vec<(usize, usize)> = Vec::new();\n  for i in 0..n {\n    let x: usize = lines.next().unwrap().unwrap().parse().unwrap();\n    ds.push((i + 1, x));\n  }\n  ds.sort_by(|x, y| y.1.cmp(&x.1));\n  let mut forest: BTreeMap<usize, Vec<Box<Tree>>> = BTreeMap::new();\n  for tup in &ds {\n    let i = tup.0;\n    let d = tup.1;\n    let v = if let Some(cn) = forest.get(&d) {\n      Tree { id: i, count: 1 + cn.iter().map(|c| c.count).sum::<usize>(), children: cn.to_vec() }\n    } else {\n      Tree { id: i, count: 1, children: Vec::new() }\n    };\n    forest.remove(&d);\n    let k = d + 2 * v.count - n;\n    let o = forest.get_mut(&k);\n    if let Some(t) = o {\n      t.push(Box::new(v));\n    } else {\n      forest.insert(k, vec![Box::new(v)]);\n    }\n  }\n  if forest.len() != 1 || forest.iter().next().unwrap().1.len() != 1 {\n    println!(\"-1\");\n    return;\n  }\n  let mut es: Vec<(usize, usize)> = Vec::new();\n  let t = &forest.iter().next().unwrap().1[0];\n  dfs(t, &mut es);\n  for (x, y) in es {\n    println!(\"{} {}\", x, y);\n  }\n}"
  },
  {
    "language": "Rust",
    "code": "use std::io::{self, BufRead};\nuse std::collections::BTreeMap;\n\n#[derive(Debug, Clone)]\nstruct Tree {\n  id: usize,\n  count: usize,\n  children: Vec<Box<Tree>>,\n}\n\nfn dfs(t: &Box<Tree>, es: &mut Vec<(usize, usize)>) {\n  for c in &t.children {\n    es.push((t.id, c.id));\n    dfs(&c, es);\n  }\n}\n\nfn main() {\n  let stdin = io::stdin();\n  let mut lines = stdin.lock().lines();\n  let n: usize = lines.next().unwrap().unwrap().parse().unwrap();\n  let mut ds: Vec<(usize, usize)> = Vec::new();\n  for i in 0..n {\n    let x: usize = lines.next().unwrap().unwrap().parse().unwrap();\n    ds.push((i + 1, x));\n  }\n  ds.sort_by(|x, y| y.1.cmp(&x.1));\n  let mut forest: BTreeMap<usize, Vec<Box<Tree>>> = BTreeMap::new();\n  for tup in &ds {\n    let i = tup.0;\n    let d = tup.1;\n    let v = if let Some(cn) = forest.get(&d) {\n      Tree { id: i, count: 1 + cn.iter().map(|c| c.count).sum::<usize>(), children: cn.to_vec() }\n    } else {\n      Tree { id: i, count: 1, children: Vec::new() }\n    };\n    forest.remove(&d);\n    let k = d + 2 * v.count - n;\n    if let Some(t) = forest.get_mut(&k) {\n      t.push(Box::new(v));\n    } else {\n      forest.insert(k, vec![Box::new(v)]);\n    }\n  }\n  if forest.len() != 1 || forest.iter().next().unwrap().1.len() != 1 {\n    println!(\"-1\");\n    return;\n  }\n  let mut es: Vec<(usize, usize)> = Vec::new();\n  let t = &forest.iter().next().unwrap().1[0];\n  dfs(t, &mut es);\n  for (x, y) in es {\n    println!(\"{} {}\", x, y);\n  }\n}"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/arc103/tasks/arc103_d\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nfn main() {\n    input! {\n        n: usize,\n        d: [i64; n]\n    };\n    let mut d = d.into_iter().zip(0..n).collect::<Vec<_>>();\n    d.sort_by_key(|&(w,idx)| -w);\n\n    let mut dmap = HashMap::new();\n    for i in 0..n {\n        dmap.insert(d[i].0, d[i].1);\n    }\n\n    let n64 = n as i64;\n    let mut edges = vec![];\n    let mut used = vec![false; n];\n    let mut cnt = vec![1; n];\n\n    let mut is_ok = true;\n    for &(dist,vidx) in &d {\n        let to_dist = dist - n64 + cnt[vidx] * 2;\n        if to_dist > dist {\n            continue;\n        }\n        // debug!(dist, to_dist, dmap.get(&to_dist));\n        match dmap.get(&to_dist) {\n            None => {\n                is_ok = false;\n                break;\n            },\n            Some(&idx) => {\n                edges.push((vidx,idx));\n                cnt[idx] += cnt[vidx];\n            }\n        }\n    }\n\n    is_ok &= edges.len() == n-1;\n\n    d.sort_by_key(|&(w,idx)| idx);\n    if is_ok {\n        is_ok &= try_make(&d, &edges);\n    }\n\n    if is_ok {\n        for (u, v) in edges {\n            println!(\"{} {}\", u+1, v+1);\n        }\n    } else {\n        println!(\"-1\");\n    }\n\n\n}\n\nfn try_make(d: &Vec<(i64, usize)>, edges: &Vec<(usize, usize)>) -> bool {\n    let n = edges.len()+1;\n    let mut graph = vec![vec![]; n];\n    for &(u,v) in edges {\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n    let (nn, d0) = dfs(0, None, &graph);\n    d[0].0 == d0\n}\n\nfn dfs(now: usize, par: Option<usize>, graph: &Vec<Vec<usize>>) -> (i64, i64) {\n    let mut w = 1;\n    let mut total_d = 0;\n    for &to in &graph[now] {\n        if Some(to) == par {\n            continue;\n        }\n        let (wc, t) = dfs(to, Some(now), graph);\n        w += wc;\n        total_d += t + wc;\n    }\n    (w, total_d)\n}\n"
  },
  {
    "language": "Rust",
    "code": "//https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8 より\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n//\n\nfn run() {\n    input! {\n        n: usize,\n        distance_sum: [i64; n],\n    }\n    let mut d = distance_sum.iter().cloned().enumerate().collect::<Vec<_>>();\n    d.sort_by_key(|d| d.1);\n    let mut size = vec![1i64; n];\n    let mut edge = vec![];\n    for i in (1..n).rev() {\n        let (a, x) = d[i];\n        let y = x - n as i64 + 2 * size[a];\n        if let Ok(k) = d.binary_search_by(|d| d.1.cmp(&y)) {\n            let b = d[k].0;\n            size[b] += size[a];\n            edge.push((a, b));\n        } else {\n            println!(\"-1\");\n            return;\n        }\n        size[a] = 0;\n    }\n    if !size.iter().any(|s| *s == n as i64) {\n        println!(\"-1\");\n        return;\n    }\n    let mut g = vec![vec![]; n];\n    for &(a, b) in edge.iter() {\n        g[a].push(b);\n        g[b].push(a);\n    }\n    let mut q = vec![];\n    let mut dfs = vec![(0, 0)];\n    while let Some((v, p)) = dfs.pop() {\n        q.push(v);\n        if let Some(k) = g[v].iter().position(|u| *u == p) {\n            g[v].remove(k);\n        }\n        for &u in g[v].iter() {\n            dfs.push((u, v));\n        }\n    }\n    let mut dp1 = vec![0; n];\n    let mut size = vec![1i64; n];\n    for &v in q.iter().rev() {\n        for &u in g[v].iter() {\n            dp1[v] += dp1[u] + size[u];\n            size[v] += size[u];\n        }\n    }\n    let mut dp2 = dp1.clone();\n    for &v in q.iter() {\n        for &u in g[v].iter() {\n            dp2[u] = dp2[v] + n as i64 - size[u] * 2;\n        }\n    }\n    if dp2.iter().zip(distance_sum.iter()).all(|p| *p.0 == *p.1) {\n        let mut out = String::new();\n        for (a, b) in edge {\n            out.push_str(&format!(\"{} {}\\n\", a + 1, b + 1));\n        }\n        print!(\"{}\", out);\n    } else {\n        println!(\"-1\");\n    }\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/arc103/tasks/arc103_d\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nfn main() {\n    input! {\n        n: usize,\n        d: [i64; n]\n    };\n    let mut d = d.into_iter().zip(0..n).collect::<Vec<_>>();\n    d.sort_by_key(|&(w,idx)| -w);\n\n    let mut dmap = HashMap::new();\n    for i in 0..n {\n        dmap.insert(d[i].0, d[i].1);\n    }\n\n    let n64 = n as i64;\n    let mut edges = vec![];\n    let mut used = vec![false; n];\n    let mut cnt = vec![1; n];\n\n    let mut is_ok = true;\n    for &(dist,vidx) in &d {\n        let to_dist = dist - n64 + cnt[vidx] * 2;\n        if to_dist > dist {\n            continue;\n        }\n        // debug!(dist, to_dist, dmap.get(&to_dist));\n        match dmap.get(&to_dist) {\n            None => {\n                is_ok = false;\n                break;\n            },\n            Some(&idx) => {\n                edges.push((vidx,idx));\n                cnt[idx] += cnt[vidx];\n            }\n        }\n    }\n\n    is_ok &= edges.len() == n-1;\n\n    d.sort_by_key(|&(w,idx)| idx);\n    is_ok &= try_make(&d, &edges);\n\n    if is_ok {\n        for (u, v) in edges {\n            println!(\"{} {}\", u+1, v+1);\n        }\n    } else {\n        println!(\"-1\");\n    }\n\n\n}\n\nfn try_make(d: &Vec<(i64, usize)>, edges: &Vec<(usize, usize)>) -> bool {\n    let n = edges.len()+1;\n    let mut graph = vec![vec![]; n];\n    for &(u,v) in edges {\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n    let (nn, d0) = dfs(0, None, &graph);\n    assert!(nn == n as i64);\n    d[0].0 == d0\n}\n\nfn dfs(now: usize, par: Option<usize>, graph: &Vec<Vec<usize>>) -> (i64, i64) {\n    let mut w = 1;\n    let mut total_d = 0;\n    for &to in &graph[now] {\n        if Some(to) == par {\n            continue;\n        }\n        let (wc, t) = dfs(to, Some(now), graph);\n        w += wc;\n        total_d += t + wc;\n    }\n    (w, total_d)\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::input;\n\nfn err() -> ! {\n    println!(\"{}\", -1);\n    std::process::exit(0);\n}\n\nfn main() {\n    input!(n: usize, d: [u64; n]);\n    let mut s_inv: Vec<_> = (0..n).collect();\n    s_inv.sort_by_key(|&i| std::cmp::Reverse(d[i]));\n    let mut s = vec![0; n];\n    (0..n).for_each(|i| s[s_inv[i]] = i);\n    let d_s_inv: Vec<_> = s_inv.iter().map(|&i| d[i]).collect();\n\n    let mut size = vec![1; n];\n    for (si, &i) in s_inv.iter().enumerate().take(n - 1) {\n        if n as u64 <= size[i] * 2 {\n            err();\n        }\n        let di = d[i];\n        let ei = di - n as u64 + 2 * size[i];\n        let sj = d_s_inv\n            .binary_search_by_key(&std::cmp::Reverse(ei), |&x| std::cmp::Reverse(x))\n            .unwrap_or_else(|_| err());\n        assert!(si < sj);\n        let j = s_inv[sj];\n        size[j] += size[i];\n        println!(\"{} {}\", i + 1, j + 1);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "// SNIPPET vec_union_find_sets\npub struct VecUnionFindSets {\n    set_count: usize,  items: Vec<VecUnionFindNode>\n}\n#[derive(Clone)]\nstruct VecUnionFindNode {\n    parent: std::cell::Cell<usize>,\n    len: usize\n}\nimpl VecUnionFindNode {\n    fn new(item: usize) -> VecUnionFindNode {\n        VecUnionFindNode {\n            parent: std::cell::Cell::new(item),\n            len: 1\n        }\n    }\n}\nimpl VecUnionFindSets {\n    pub fn new() -> VecUnionFindSets {\n        VecUnionFindSets {\n            set_count: 0,\n            items: Vec::new()\n        }\n    }\n    pub fn with_items(items_count: usize) -> VecUnionFindSets {\n        let mut sets = VecUnionFindSets::new();\n        sets.add_items(items_count);\n        sets\n    }\n    fn error_msg(items: &[usize]) -> String {\n        assert!(items.len() == 1 || items.len() == 2);\n        if items.len() == 1 {\n            format!(\"no set contains {}\", items[0])\n        } else {\n            format!(\"no set contains {} and no set contains {}\", items[0], items[1])\n        }\n    }\n    pub fn add_items(&mut self, count: usize) {\n        self.set_count += count;\n        let new_items = (self.items_len()..self.items_len()+count)\n            .map(|i| VecUnionFindNode::new(i));\n        self.items.extend(new_items);\n    }\n    pub fn items_len(&self) -> usize {\n        self.items.len()\n    }\n    fn find(&self, item: usize) -> Option<usize> {\n        if item >= self.items_len() {\n            return None;\n        }\n        fn go(sets: &VecUnionFindSets, item: usize) -> usize {\n            let node = &sets.items[item];\n            if node.parent.get() == item {\n                return item;\n            }\n            let root = go(sets, node.parent.get());\n            sets.items[root].parent.set(root);\n            root\n        }\n        Some(go(self, item))\n    }\n    pub fn count(&self) -> usize {\n        self.set_count\n    }\n    pub fn len_of(&self, item: usize) -> Result<usize, String> {\n        self.find(item).map(|root| self.items[root].len).ok_or_else(|| {\n            VecUnionFindSets::error_msg(&[item])\n        })\n    }\n    pub fn set_eq(&self, item1: usize, item2: usize) -> Result<bool, String> {\n        match (self.find(item1), self.find(item2)) {\n            (Some(root1), Some(root2)) => Ok(root1 == root2),\n            (Some(_), None) => Err(VecUnionFindSets::error_msg(&[item2])),\n            (None, Some(_)) => Err(VecUnionFindSets::error_msg(&[item1])),\n            (None, None) => Err(VecUnionFindSets::error_msg(&[item1, item2])),\n        }\n    }\n    pub fn unite(&mut self, item1: usize, item2: usize) -> Result<bool, String> {\n        match (self.find(item1), self.find(item2)) {\n            (Some(root1), Some(root2)) => {\n                if root1 == root2 {\n                    return Ok(false);\n                }\n                self.set_count -= 1;\n                let (new_root, new_child) = if self.items[root1].len < self.items[root2].len {\n                    (root2, root1)\n                } else {\n                    (root1, root2)\n                };\n                let new_len = self.items[root1].len + self.items[root2].len;\n                self.items[new_root] = VecUnionFindNode {\n                    parent: std::cell::Cell::new(new_root),\n                    len: new_len\n                };\n                self.items[new_child] = VecUnionFindNode {\n                    parent: std::cell::Cell::new(new_root),\n                    len: 0\n                };\n                Ok(true)\n            },\n            (Some(_), None) => Err(VecUnionFindSets::error_msg(&[item2])),\n            (None, Some(_)) => Err(VecUnionFindSets::error_msg(&[item1])),\n            (None, None) => Err(VecUnionFindSets::error_msg(&[item1, item2]))\n        }\n    }\n    pub fn iter_cloned(&self) -> impl Iterator<Item=Vec<usize>> {\n        let mut sets = vec![Vec::new(); self.items_len()];\n        for i in 0..self.items_len() {\n            let repr = self.find(i).unwrap();\n            sets[repr].push(i);\n        }\n        sets.into_iter().filter(|v| !v.is_empty())\n    }\n}\nimpl std::fmt::Debug for VecUnionFindSets {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"{{\")?;\n        let mut first = true;\n        for set in self.iter_cloned() {\n            if !first {\n                write!(f, \", \")?;\n            }\n            write!(f, \"{:?}\", set)?;\n            first = false;\n        }\n        write!(f, \"}}\")\n    }\n}\n/*\nimpl<T: Eq + std::hash::Hash + std::fmt::Debug> IntoIterator for HashUnionFindSets<T> {\n    type Item = HashSet<T>;\n    type IntoIter = std::collections::hash_map::Values<>;\n    fn into_iter(self) -> Self::IntoIter {\n    }\n}\n*/\n\n// SNIPPET read\npub trait Readable {\n    type Output;\n    const WORD_COUNT: usize;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String>;\n}\n#[macro_export]\nmacro_rules! readable {\n    ( $t:ty, $words_count:expr, |$words:ident| $read_words:expr ) => {\n        impl Readable for $t {\n            type Output = $t;\n            const WORD_COUNT: usize = $words_count;\n            fn read_words($words: &[&str]) -> Result<$t, String> {\n                Ok($read_words)\n            }\n        }\n    };\n}\nreadable!((), 1, |_ss| ());\nreadable!(String, 1, |ss| ss[0].to_string());\nimpl Readable for char {\n    type Output = char;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<char, String> {\n        let chars: Vec<char> = words[0].chars().collect();\n        if chars.len() == 1 {\n            Ok(chars[0])\n        } else {\n            Err(format!(\"cannot parse `{}` as a char\", words[0]))\n        }\n    }\n}\npub struct Chars();\nimpl Readable for Chars {\n    type Output = Vec<char>;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<Vec<char>, String> {\n        Ok(words[0].chars().collect())\n    }\n}\npub struct Bytes();\nimpl Readable for Bytes {\n    type Output = Vec<u8>;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<Vec<u8>, String> {\n        Ok(words[0].bytes().collect())\n    }\n}\nimpl Readable for i8 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<i8, String> {\n        use std::str::FromStr;\n        i8::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as i8\", words[0])\n        })\n    }\n}\nimpl Readable for u8 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<u8, String> {\n        use std::str::FromStr;\n        u8::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as u8\", words[0])\n        })\n    }\n}\nimpl Readable for i16 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<i16, String> {\n        use std::str::FromStr;\n        i16::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as i16\", words[0])\n        })\n    }\n}\nimpl Readable for u16 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<u16, String> {\n        use std::str::FromStr;\n        u16::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as u16\", words[0])\n        })\n    }\n}\nimpl Readable for i32 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<i32, String> {\n        use std::str::FromStr;\n        i32::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as i32\", words[0])\n        })\n    }\n}\nimpl Readable for u32 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<u32, String> {\n        use std::str::FromStr;\n        u32::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as u32\", words[0])\n        })\n    }\n}\nimpl Readable for i64 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<i64, String> {\n        use std::str::FromStr;\n        i64::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as i64\", words[0])\n        })\n    }\n}\nimpl Readable for u64 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<u64, String> {\n        use std::str::FromStr;\n        u64::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as u64\", words[0])\n        })\n    }\n}\nimpl Readable for i128 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<i128, String> {\n        use std::str::FromStr;\n        i128::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as i64\", words[0])\n        })\n    }\n}\nimpl Readable for u128 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<u128, String> {\n        use std::str::FromStr;\n        u128::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as u64\", words[0])\n        })\n    }\n}\nimpl Readable for isize {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<isize, String> {\n        use std::str::FromStr;\n        <isize>::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as isize\", words[0])\n        })\n    }\n}\nimpl Readable for usize {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<usize, String> {\n        use std::str::FromStr;\n        <usize>::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as usize\", words[0])\n        })\n    }\n}\nimpl Readable for f32 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<f32, String> {\n        use std::str::FromStr;\n        f32::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as f32\", words[0])\n        })\n    }\n}\nimpl Readable for f64 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<f64, String> {\n        use std::str::FromStr;\n        f64::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as f64\", words[0])\n        })\n    }\n}\n#[allow(non_camel_case_types)]\npub struct u8_;\nimpl Readable for u8_ {\n    type Output = u8;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        u8::read_words(words).map(|n| n-1)\n    }\n}\n#[allow(non_camel_case_types)]\npub struct u16_;\nimpl Readable for u16_ {\n    type Output = u16;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        u16::read_words(words).map(|n| n-1)\n    }\n}\n#[allow(non_camel_case_types)]\npub struct u32_;\nimpl Readable for u32_ {\n    type Output = u32;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        u32::read_words(words).map(|n| n-1)\n    }\n}\n#[allow(non_camel_case_types)]\npub struct u64_;\nimpl Readable for u64_ {\n    type Output = u64;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        u64::read_words(words).map(|n| n-1)\n    }\n}\n#[allow(non_camel_case_types)]\npub struct usize_;\nimpl Readable for usize_ {\n    type Output = usize;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        <usize>::read_words(words).map(|n| n-1)\n    }\n}\nimpl<T1: Readable, T2: Readable> Readable for (T1, T2) {\n    type Output = (T1::Output, T2::Output);\n    const WORD_COUNT: usize = T1::WORD_COUNT + T2::WORD_COUNT;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let mut start = 0;\n        let count1 = T1::WORD_COUNT;\n        let val1 = T1::read_words(&words[start .. start+count1])?;\n        start += count1;\n        let val2 = T2::read_words(&words[start..])?;\n        Ok((val1, val2))\n    }\n}\nimpl<T1: Readable, T2: Readable, T3: Readable> Readable for (T1, T2, T3) {\n    type Output = (T1::Output, T2::Output, T3::Output);\n    const WORD_COUNT: usize = T1::WORD_COUNT + T2::WORD_COUNT + T3::WORD_COUNT;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let mut start = 0;\n        let count1 = T1::WORD_COUNT;\n        let val1 = T1::read_words(&words[start .. start+count1])?;\n        start += count1;\n        let count2 = T2::WORD_COUNT;\n        let val2 = T2::read_words(&words[start .. start+count2])?;\n        start += count2;\n        let val3 = T3::read_words(&words[start..])?;\n        Ok((val1, val2, val3))\n    }\n}\nimpl<T1: Readable, T2: Readable, T3: Readable, T4: Readable> Readable for (T1, T2, T3, T4) {\n    type Output = (T1::Output, T2::Output, T3::Output, T4::Output);\n    const WORD_COUNT: usize = T1::WORD_COUNT + T2::WORD_COUNT + T3::WORD_COUNT + T4::WORD_COUNT;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let mut start = 0;\n        let count1 = T1::WORD_COUNT;\n        let val1 = T1::read_words(&words[start .. start+count1])?;\n        start += count1;\n        let count2 = T2::WORD_COUNT;\n        let val2 = T2::read_words(&words[start .. start+count2])?;\n        start += count2;\n        let count3 = T3::WORD_COUNT;\n        let val3 = T3::read_words(&words[start .. start+count3])?;\n        start += count3;\n        let val4 = T4::read_words(&words[start..])?;\n        Ok((val1, val2, val3, val4))\n    }\n}\nimpl<T1: Readable, T2: Readable, T3: Readable, T4: Readable, T5: Readable> Readable for (T1, T2, T3, T4, T5) {\n    type Output = (T1::Output, T2::Output, T3::Output, T4::Output, T5::Output);\n    const WORD_COUNT: usize = T1::WORD_COUNT + T2::WORD_COUNT + T3::WORD_COUNT + T4::WORD_COUNT + T5::WORD_COUNT;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let mut start = 0;\n        let count1 = T1::WORD_COUNT;\n        let val1 = T1::read_words(&words[start .. start+count1])?;\n        start += count1;\n        let count2 = T2::WORD_COUNT;\n        let val2 = T2::read_words(&words[start .. start+count2])?;\n        start += count2;\n        let count3 = T3::WORD_COUNT;\n        let val3 = T3::read_words(&words[start .. start+count3])?;\n        start += count3;\n        let count4 = T4::WORD_COUNT;\n        let val4 = T4::read_words(&words[start .. start+count4])?;\n        start += count4;\n        let val5 = T5::read_words(&words[start..])?;\n        Ok((val1, val2, val3, val4, val5))\n    }\n}\nimpl<T1: Readable, T2: Readable, T3: Readable, T4: Readable, T5: Readable, T6: Readable> Readable for (T1, T2, T3, T4, T5, T6) {\n    type Output = (T1::Output, T2::Output, T3::Output, T4::Output, T5::Output, T6::Output);\n    const WORD_COUNT: usize = T1::WORD_COUNT + T2::WORD_COUNT + T3::WORD_COUNT + T4::WORD_COUNT + T5::WORD_COUNT + T6::WORD_COUNT;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let mut start = 0;\n        let count1 = T1::WORD_COUNT;\n        let val1 = T1::read_words(&words[start .. start+count1])?;\n        start += count1;\n        let count2 = T2::WORD_COUNT;\n        let val2 = T2::read_words(&words[start .. start+count2])?;\n        start += count2;\n        let count3 = T3::WORD_COUNT;\n        let val3 = T3::read_words(&words[start .. start+count3])?;\n        start += count3;\n        let count4 = T4::WORD_COUNT;\n        let val4 = T4::read_words(&words[start .. start+count4])?;\n        start += count4;\n        let count5 = T5::WORD_COUNT;\n        let val5 = T5::read_words(&words[start .. start+count5])?;\n        start += count5;\n        let val6 = T6::read_words(&words[start..])?;\n        Ok((val1, val2, val3, val4, val5, val6))\n    }\n}\nimpl<T: Readable> Readable for [T; 2] {\n    type Output = [T::Output; 2];\n    const WORD_COUNT: usize = T::WORD_COUNT * 2;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let val1 = T::read_words(&words[T::WORD_COUNT*0 .. T::WORD_COUNT*1])?;\n        let val2 = T::read_words(&words[T::WORD_COUNT*1 .. T::WORD_COUNT*2])?;\n        Ok([val1, val2])\n    }\n}\nimpl<T: Readable> Readable for [T; 3] {\n    type Output = [T::Output; 3];\n    const WORD_COUNT: usize = T::WORD_COUNT * 3;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let val1 = T::read_words(&words[T::WORD_COUNT*0 .. T::WORD_COUNT*1])?;\n        let val2 = T::read_words(&words[T::WORD_COUNT*1 .. T::WORD_COUNT*2])?;\n        let val3 = T::read_words(&words[T::WORD_COUNT*2 .. T::WORD_COUNT*3])?;\n        Ok([val1, val2, val3])\n    }\n}\nimpl<T: Readable> Readable for [T; 4] {\n    type Output = [T::Output; 4];\n    const WORD_COUNT: usize = T::WORD_COUNT * 4;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let val1 = T::read_words(&words[T::WORD_COUNT*0 .. T::WORD_COUNT*1])?;\n        let val2 = T::read_words(&words[T::WORD_COUNT*1 .. T::WORD_COUNT*2])?;\n        let val3 = T::read_words(&words[T::WORD_COUNT*2 .. T::WORD_COUNT*3])?;\n        let val4 = T::read_words(&words[T::WORD_COUNT*3 .. T::WORD_COUNT*4])?;\n        Ok([val1, val2, val3, val4])\n    }\n}\nimpl<T: Readable> Readable for [T; 5] {\n    type Output = [T::Output; 5];\n    const WORD_COUNT: usize = T::WORD_COUNT * 5;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let val1 = T::read_words(&words[T::WORD_COUNT*0 .. T::WORD_COUNT*1])?;\n        let val2 = T::read_words(&words[T::WORD_COUNT*1 .. T::WORD_COUNT*2])?;\n        let val3 = T::read_words(&words[T::WORD_COUNT*2 .. T::WORD_COUNT*3])?;\n        let val4 = T::read_words(&words[T::WORD_COUNT*3 .. T::WORD_COUNT*4])?;\n        let val5 = T::read_words(&words[T::WORD_COUNT*4 .. T::WORD_COUNT*5])?;\n        Ok([val1, val2, val3, val4, val5])\n    }\n}\nimpl<T: Readable> Readable for [T; 6] {\n    type Output = [T::Output; 6];\n    const WORD_COUNT: usize = T::WORD_COUNT * 6;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let val1 = T::read_words(&words[T::WORD_COUNT*0 .. T::WORD_COUNT*1])?;\n        let val2 = T::read_words(&words[T::WORD_COUNT*1 .. T::WORD_COUNT*2])?;\n        let val3 = T::read_words(&words[T::WORD_COUNT*2 .. T::WORD_COUNT*3])?;\n        let val4 = T::read_words(&words[T::WORD_COUNT*3 .. T::WORD_COUNT*4])?;\n        let val5 = T::read_words(&words[T::WORD_COUNT*4 .. T::WORD_COUNT*5])?;\n        let val6 = T::read_words(&words[T::WORD_COUNT*5 .. T::WORD_COUNT*6])?;\n        Ok([val1, val2, val3, val4, val5, val6])\n    }\n}\npub trait ReadableFromLine {\n    type Output;\n    fn read_line(line: &str) -> Result<Self::Output, String>;\n}\nfn split_into_words(line: &str) -> Vec<&str> {\n    line.trim_end_matches('\\n').split_whitespace().collect()\n}\nimpl<T: Readable> ReadableFromLine for T {\n    type Output = T::Output;\n    fn read_line(line: &str) -> Result<T::Output, String> {\n        let words = split_into_words(line);\n        if words.len() != T::WORD_COUNT {\n            return Err(format!(\"line `{}` has {} words, expected {}\",\n                               line, words.len(), T::WORD_COUNT));\n        }\n        T::read_words(&words)\n    }\n}\npub fn read_words_into_vec<T: Readable>(words: &[&str], line: &str) -> Result<Vec<T::Output>, String> {\n    let n = T::WORD_COUNT;\n    assert_eq!(words.len() % n, 0);\n    let mut result = Vec::new();\n    for chunk in words.chunks(n) {\n        match T::read_words(chunk) {\n            Ok(v) => result.push(v),\n            Err(msg) => {\n                let fragment_msg = if n == 1 {\n                    format!(\"word {}\", result.len())\n                } else {\n                    let l = result.len();\n                    format!(\"words {}-{}\", n*l + 1, (n+1) * l)\n                };\n                return Err(format!(\n                    \"{} of line `{}`: {}\", fragment_msg, line, msg\n                ));\n            }\n        }\n    }\n    Ok(result)\n}\npub fn split_into_words_for_collection<T: Readable>(\n    line: &str, prefix_words_count: usize\n) -> Result<Vec<&str>, String> {\n    let n = T::WORD_COUNT;\n    let words = split_into_words(line);\n    if words.len() < prefix_words_count {\n        return Err(\n            format!(\"line `{}` has {} words, expected at least {}\",\n                    line, words.len(), prefix_words_count)\n        );\n    }\n    if (words.len() - prefix_words_count) % T::WORD_COUNT != 0 {\n        return Err(\n            format!(\"line `{}` has {} words, expected {} + {}\",\n                    line, words.len(), prefix_words_count, n)\n        );\n    }\n    Ok(words)\n}\n#[macro_export]\nmacro_rules! readable_collection {\n    ($u:ident => $collection_in:ty, $collection_out:ty) => {\n        readable_collection!($u: => $collection_in, $collection_out);\n    };\n    ($u:ident : $( $bound:path ),* => $collection_in:ty, $collection_out:ty) => {\n        impl<$u: Readable> ReadableFromLine for $collection_in\n        where\n            <$u as Readable>::Output: Sized $(+ $bound)*\n        {\n            type Output = $collection_out;\n            fn read_line(line: &str) -> Result<Self::Output, String> {\n                let words = split_into_words_for_collection::<$u>(line, 0)?;\n                Ok(read_words_into_vec::<$u>(&words, line)?.into_iter().collect())\n            }\n        }\n        impl<T1: Readable, $u: Readable> ReadableFromLine for (T1, $collection_in)\n        where\n            <$u as Readable>::Output: Sized $(+ $bound)*\n        {\n            type Output = (T1::Output, $collection_out);\n            fn read_line(line: &str) -> Result<Self::Output, String> {\n                let prefix_len = T1::WORD_COUNT;\n                let words = split_into_words_for_collection::<$u>(line, prefix_len)?;\n                let val1 = T1::read_words(&words[..prefix_len])?;\n                let rest = read_words_into_vec::<$u>(&words[prefix_len..], line)?;\n                Ok((val1, rest.into_iter().collect()))\n            }\n        }\n        impl<T1: Readable, T2: Readable, $u: Readable> ReadableFromLine for (T1, T2, $collection_in)\n        where\n            <$u as Readable>::Output: Sized $(+ $bound)*\n        {\n            type Output = (T1::Output, T2::Output, $collection_out);\n            fn read_line(line: &str) -> Result<Self::Output, String> {\n                let prefix_len = <(T1, T2)>::WORD_COUNT;\n                let words = split_into_words_for_collection::<$u>(line, prefix_len)?;\n                let mut start = 0;\n                let count1 = T1::WORD_COUNT;\n                let val1 = T1::read_words(&words[start .. start+count1])?;\n                start += count1;\n                let count2 = T2::WORD_COUNT;\n                let val2 = T2::read_words(&words[start .. start+count2])?;\n                let rest = read_words_into_vec::<$u>(&words[prefix_len..], line)?;\n                Ok((val1, val2, rest.into_iter().collect()))\n            }\n        }\n        impl<T1: Readable, T2: Readable, T3: Readable, $u: Readable> ReadableFromLine for (T1, T2, T3, $collection_in)\n        where\n            <$u as Readable>::Output: Sized $(+ $bound)*\n        {\n            type Output = (T1::Output, T2::Output, T3::Output, $collection_out);\n            fn read_line(line: &str) -> Result<Self::Output, String> {\n                let prefix_len = <(T1, T2, T3)>::WORD_COUNT;\n                let words = split_into_words_for_collection::<$u>(line, prefix_len)?;\n                let mut start = 0;\n                let count1 = T1::WORD_COUNT;\n                let val1 = T1::read_words(&words[start .. start+count1])?;\n                start += count1;\n                let count2 = T2::WORD_COUNT;\n                let val2 = T2::read_words(&words[start .. start+count2])?;\n                start += count2;\n                let count3 = T3::WORD_COUNT;\n                let val3 = T3::read_words(&words[start .. start+count3])?;\n                let rest = read_words_into_vec::<$u>(&words[prefix_len..], line)?;\n                Ok((val1, val2, val3, rest.into_iter().collect()))\n            }\n        }\n        impl<T1: Readable, T2: Readable, T3: Readable, T4: Readable, $u: Readable> ReadableFromLine for (T1, T2, T3, T4, $collection_in)\n        where\n            <$u as Readable>::Output: Sized $(+ $bound)*\n        {\n            type Output = (T1::Output, T2::Output, T3::Output, T4::Output, $collection_out);\n            fn read_line(line: &str) -> Result<Self::Output, String> {\n                let prefix_len = <(T1, T2, T3, T4)>::WORD_COUNT;\n                let words = split_into_words_for_collection::<$u>(line, prefix_len)?;\n                let mut start = 0;\n                let count1 = T1::WORD_COUNT;\n                let val1 = T1::read_words(&words[start .. start+count1])?;\n                start += count1;\n                let count2 = T2::WORD_COUNT;\n                let val2 = T2::read_words(&words[start .. start+count2])?;\n                start += count2;\n                let count3 = T3::WORD_COUNT;\n                let val3 = T3::read_words(&words[start .. start+count3])?;\n                start += count3;\n                let count4 = T4::WORD_COUNT;\n                let val4 = T4::read_words(&words[start .. start+count4])?;\n                let rest = read_words_into_vec::<$u>(&words[prefix_len..], line)?;\n                Ok((val1, val2, val3, val4, rest.into_iter().collect()))\n            }\n        }\n    };\n}\nreadable_collection!(U => Vec<U>, Vec<U::Output>);\npub fn read<T: ReadableFromLine>() -> T::Output {\n    let mut line = String::new();\n    std::io::stdin().read_line(&mut line).unwrap();\n    T::read_line(&line).unwrap()\n}\n#[macro_export]\nmacro_rules! read {\n    () => {\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).unwrap();\n    };\n    ( $pat:pat = $t:ty $(,)* ) => {\n        let $pat = read::<$t>();\n    };\n    ( ! $(,)* ) => {\n        let _ = read::<()>();\n    };\n    ( $pat:pat = $t:ty, $( $rest:tt )+ ) => {\n        read_inner!($pat = $t; $($rest)+);\n    };\n    ( !, $( $rest:tt )+ ) => {\n        read_inner!(_ = (); $($rest)+);\n    };\n}\n#[macro_export]\n#[doc(hidden)]\nmacro_rules! read_inner {\n    ( $( $acc_pat:pat = $acc_t:ty ),+ ; $pat:pat = $t:ty, $( $rest:tt )* ) => {\n        read_inner!($( $acc_pat = $acc_t ),+ , $pat = $t ; $($rest)*);\n    };\n    ( $( $acc_pat:pat = $acc_t:ty ),+ ; !, $( $rest:tt )* ) => {\n        read_inner!($( $acc_pat = $acc_t ),+ , _ = () ; $($rest)*);\n    };\n    ( $( $acc_pat:pat = $acc_t:ty ),+ ; $pat:pat = $t:ty ) => {\n        read_inner!($( $acc_pat = $acc_t ),+ , $pat = $t ;);\n    };\n    ( $( $acc_pat:pat = $acc_t:ty ),+ ; ! ) => {\n        read_inner!($( $acc_pat = $acc_t ),+ , _ = () ;);\n    };\n    ( $( $pat:pat = $t:ty ),+ ; ) => {\n        let ($($pat),+) = read::<($($t),+)>();\n    };\n}\npub trait ReadableFromChunk {\n    type Output;\n    fn lines_count() -> usize;\n    fn read_chunk(lines: &[String]) -> Result<Self::Output, String>;\n}\nimpl<T1: ReadableFromLine, T2: ReadableFromLine> ReadableFromChunk for (T1, T2) {\n    type Output = (T1::Output, T2::Output);\n    fn lines_count() -> usize { 2 }\n    fn read_chunk(lines: &[String]) -> Result<Self::Output, String> {\n        let out1 = T1::read_line(&lines[0])?;\n        let out2 = T2::read_line(&lines[1])?;\n        Ok((out1, out2))\n    }\n}\nimpl<T1: ReadableFromLine, T2: ReadableFromLine, T3: ReadableFromLine> ReadableFromChunk for (T1, T2, T3) {\n    type Output = (T1::Output, T2::Output, T3::Output);\n    fn lines_count() -> usize { 3 }\n    fn read_chunk(lines: &[String]) -> Result<Self::Output, String> {\n        let out1 = T1::read_line(&lines[0])?;\n        let out2 = T2::read_line(&lines[1])?;\n        let out3 = T3::read_line(&lines[2])?;\n        Ok((out1, out2, out3))\n    }\n}\nimpl<T1: ReadableFromLine, T2: ReadableFromLine, T3: ReadableFromLine, T4: ReadableFromLine> ReadableFromChunk for (T1, T2, T3, T4) {\n    type Output = (T1::Output, T2::Output, T3::Output, T4::Output);\n    fn lines_count() -> usize { 4 }\n    fn read_chunk(lines: &[String]) -> Result<Self::Output, String> {\n        let out1 = T1::read_line(&lines[0])?;\n        let out2 = T2::read_line(&lines[1])?;\n        let out3 = T3::read_line(&lines[2])?;\n        let out4 = T4::read_line(&lines[3])?;\n        Ok((out1, out2, out3, out4))\n    }\n}\npub fn read_chunk<T: ReadableFromChunk>() -> T::Output {\n    let stdin = std::io::stdin();\n    let mut handle = stdin.lock();\n    read_chunk_from_handle::<T>(&mut handle).unwrap()\n}\nfn read_chunk_from_handle<T: ReadableFromChunk>(handle: &mut std::io::StdinLock) -> Option<T::Output> {\n    use std::io::BufRead;\n    let mut lines = vec![String::new(); T::lines_count()];\n    let mut first = true;\n    for line in &mut lines {\n        if handle.read_line(line).unwrap() == 0 && first {\n            return None;\n        }\n        first = false;\n    }\n    Some(T::read_chunk(&lines).unwrap())\n}\n#[macro_export]\nmacro_rules! read_chunk {\n    ( $( $pat:pat = $t:ty ),+ ) => {\n        let ($($pat),+) = read_chunk::<($($t),+)>();\n    };\n}\nstatic mut STDIN: Option<std::io::Stdin> = None;\npub struct ReadLines<T: ReadableFromLine> {\n    lock: std::io::StdinLock<'static>,\n    phantom: std::marker::PhantomData<T>\n}\nimpl<T: ReadableFromLine> Iterator for ReadLines<T> {\n    type Item = T::Output;\n    fn next(&mut self) -> Option<T::Output> {\n        use std::io::BufRead;\n        let mut line = String::new();\n        if self.lock.read_line(&mut line).unwrap() > 0 {\n            Some(T::read_line(&line).unwrap())\n        } else {\n            None\n        }\n    }\n}\npub fn read_lines<T: ReadableFromLine>() -> ReadLines<T> {\n    unsafe {\n        if STDIN.is_none() {\n            STDIN = Some(std::io::stdin());\n        }\n    }\n    ReadLines {\n        lock: unsafe { STDIN.as_ref().unwrap().lock() },\n        phantom: std::marker::PhantomData::<T>\n    }\n}\npub struct ReadChunks<T: ReadableFromChunk> {\n    lock: std::io::StdinLock<'static>,\n    phantom: std::marker::PhantomData<T>\n}\nimpl<T: ReadableFromChunk> Iterator for ReadChunks<T> {\n    type Item = T::Output;\n    fn next(&mut self) -> Option<T::Output> {\n        read_chunk_from_handle::<T>(&mut self.lock)\n    }\n}\npub fn read_chunks<T: ReadableFromChunk>() -> ReadChunks<T> {\n    unsafe {\n        if STDIN.is_none() {\n            STDIN = Some(std::io::stdin());\n        }\n    }\n    ReadChunks {\n        lock: unsafe { STDIN.as_ref().unwrap().lock() },\n        phantom: std::marker::PhantomData::<T>\n    }\n}\npub trait Words {\n    fn read<T: Readable>(&self) -> T::Output;\n}\nimpl<'a> Words for [&'a str] {\n    fn read<T: Readable>(&self) -> T::Output {\n        T::read_words(self).unwrap()\n    }\n}\nimpl<'a> Words for &'a str {\n    fn read<T: Readable>(&self) -> T::Output {\n        T::read_words(&[self]).unwrap()\n    }\n}\n\n// SNIPPET utils\n#[macro_export]\nmacro_rules! echo {\n    () => {\n        println!()\n    };\n    ($e: expr $(,)?) => {\n        println!(\"{}\", $e)\n    };\n    ($e: expr, $($es: expr),+ $(,)?) => {\n        {\n            use std::io::Write;\n            let stdout = std::io::stdout();\n            let mut handle = stdout.lock();\n            write!(handle, \"{}\", $e).unwrap();\n            $(\n                write!(handle, \" {}\", $es).unwrap();\n            )+\n            writeln!(handle).unwrap();\n        }\n    };\n}\npub fn yn(result: bool) {\n    if result {\n        println!(\"Yes\");\n    } else {\n        println!(\"No\");\n    }\n}\n#[allow(non_snake_case)]\npub fn YN(result: bool) {\n    if result {\n        println!(\"YES\");\n    } else {\n        println!(\"NO\");\n    }\n}\npub fn exit(msg: impl std::fmt::Display) -> ! {\n    println!(\"{}\", msg);\n    std::process::exit(0)\n}\n#[macro_export]\n#[cfg(local)]\nmacro_rules! dbg {\n    () => {\n        {\n            use std::io::{self, Write};\n            writeln!(io::stderr(), \"{}: dbg\", line!()).unwrap();\n        }\n    };\n    ($e: expr) => {\n        {\n            use std::io::{self, Write};\n            let result = $e;\n            writeln!(io::stderr(), \"{}: {} = {:?}\",\n                     line!(), stringify!($e), result)\n                .unwrap();\n            result\n        }\n    }\n}\n#[macro_export]\n#[cfg(not(local))]\nmacro_rules! dbg {\n    () => {};\n    ($e: expr) => {\n        { $e }\n    }\n}\n\n// SNIPPET option\npub trait BoolExt {\n    fn then<T>(self, value: T) -> Option<T>;\n    fn then_with<T, F>(self, f: F) -> Option<T> where F: FnOnce() -> T;\n    fn and<T>(self, option: Option<T>) -> Option<T>;\n    fn and_then<T, F>(self, f: F) -> Option<T> where F: FnOnce() -> Option<T>;\n}\nimpl BoolExt for bool {\n    fn then<T>(self, value: T) -> Option<T> {\n        if self { Some(value) } else { None }\n    }\n    fn then_with<T, F>(self, f: F) -> Option<T> where F: FnOnce() -> T {\n        if self { Some(f()) } else { None }\n    }\n    fn and<T>(self, option: Option<T>) -> Option<T> {\n        if self { option } else { None }\n    }\n    fn and_then<T, F>(self, f: F) -> Option<T> where F: FnOnce() -> Option<T> {\n        if self { f() } else { None }\n    }\n}\npub trait OptionExt<T> {\n    fn to_string_or<U: std::fmt::Display>(&self, default: U) -> String\n    where\n        T: std::fmt::Display;\n}\nimpl<T> OptionExt<T> for Option<T> {\n    fn to_string_or<U: std::fmt::Display>(&self, default: U) -> String\n    where\n        T: std::fmt::Display\n    {\n        self.as_ref().map(|x| x.to_string()).unwrap_or(default.to_string())\n    }\n    /*\n    fn get_or_insert_with<F: FnOnce() -> T>(&mut self, f: F) -> &mut T {\n        match *self {\n            None => *self = Some(f()),\n            _ => ()\n        }\n        self.as_mut().unwrap()\n    }\n    */\n}\npub trait Guard: Sized {\n    fn guard(self, pred: impl FnOnce(&Self) -> bool) -> Option<Self>;\n}\nimpl<T> Guard for T {\n    fn guard(self, pred: impl FnOnce(&T) -> bool) -> Option<T> {\n        if pred(&self) { Some(self) } else { None }\n    }\n}\n\n// SNIPPET num_types\npub trait WithZero: Sized +\n    for<'a> std::ops::Add<&'a Self, Output=Self> +\n    for<'a> std::ops::AddAssign<&'a Self>\n{\n    fn zero() -> Self;\n}\npub trait WithOne: Sized +\n    for<'a> std::ops::Mul<&'a Self, Output=Self> +\n    for<'a> std::ops::MulAssign<&'a Self>\n{\n    fn one() -> Self;\n}\npub trait Integer: Eq + Ord + WithZero + WithOne +\n    for<'a> std::ops::Sub<&'a Self, Output=Self> +\n    for<'a> std::ops::SubAssign<&'a Self> +\n    for<'a> std::ops::Div<&'a Self, Output=Self> +\n    for<'a> std::ops::DivAssign<&'a Self> +\n    for<'a> std::ops::Rem<&'a Self, Output=Self> +\n    for<'a> std::ops::RemAssign<&'a Self>\n{}\npub trait ToSigned {\n    type Signed: Integer;\n    fn to_signed(&self) -> Option<Self::Signed>;\n    unsafe fn to_signed_unchecked(&self) -> Self::Signed {\n        self.to_signed().unwrap()\n    }\n}\npub trait ToUnsigned {\n    type Unsigned: Integer;\n    fn to_unsigned(&self) -> Option<Self::Unsigned>;\n    unsafe fn to_unsigned_unchecked(&self) -> Self::Unsigned {\n        self.to_unsigned().unwrap()\n    }\n}\n\n// SNIPPET int\npub trait PrimitiveInteger: Integer + Copy + ToSigned + ToUnsigned {\n    fn abs_diff(self, rhs: Self) -> Self;\n}\nmacro_rules! impl_primitive_integer_unsigned {\n    ( $($t: ty, $t_signed: ty);* ) => { $(\n        impl WithZero for $t {\n            fn zero() -> $t { 0 }\n        }\n        impl WithOne for $t {\n            fn one() -> $t { 1 }\n        }\n        impl Integer for $t {}\n        impl ToSigned for $t {\n            type Signed = $t_signed;\n            fn to_signed(&self) -> Option<$t_signed> {\n                use std::convert::TryInto;\n                (*self).try_into().ok()\n            }\n            unsafe fn to_signed_unchecked(&self) -> $t_signed {\n                *self as $t_signed\n            }\n        }\n        impl ToUnsigned for $t {\n            type Unsigned = $t;\n            fn to_unsigned(&self) -> Option<$t> {\n                Some(*self)\n            }\n        }\n        impl PrimitiveInteger for $t {\n            fn abs_diff(self, rhs: $t) -> $t {\n                if self < rhs { rhs - self } else { self - rhs }\n            }\n        }\n    )* }\n}\nimpl_primitive_integer_unsigned!(\n    u8, i8;\n    u16, i16;\n    u32, i32;\n    u64, i64;\n    u128, i128;\n    usize, isize\n);\nmacro_rules! impl_primitive_integer_signed {\n    ( $($t: ty, $t_unsigned: ty);* ) => { $(\n        impl WithZero for $t {\n            fn zero() -> $t { 0 }\n        }\n        impl WithOne for $t {\n            fn one() -> $t { 1 }\n        }\n        impl Integer for $t {}\n        impl ToSigned for $t {\n            type Signed = $t;\n            fn to_signed(&self) -> Option<$t> {\n                Some(*self)\n            }\n        }\n        impl ToUnsigned for $t {\n            type Unsigned = $t_unsigned;\n            fn to_unsigned(&self) -> Option<$t_unsigned> {\n                use std::convert::TryInto;\n                (*self).try_into().ok()\n            }\n            unsafe fn to_unsigned_unchecked(&self) -> $t_unsigned {\n                *self as $t_unsigned\n            }\n        }\n        impl PrimitiveInteger for $t {\n            fn abs_diff(self, rhs: $t) -> $t {\n                if self < rhs { rhs - self } else { self - rhs }\n            }\n        }\n    )* }\n}\nimpl_primitive_integer_signed!(\n    i8, u8;\n    i16, u16;\n    i32, u32;\n    i64, u64;\n    i128, u128;\n    isize, usize\n);\npub trait PrimitiveUnsigned: PrimitiveInteger {\n    fn ceil_div(self, rhs: Self) -> Self;\n    fn round_div(self, rhs: Self) -> Self;\n    fn log2(self) -> Option<Self>;\n    fn ceil_log2(self) -> Option<Self>;\n    fn sqrt(self) -> Self;\n    fn gcd(self, other: Self) -> Self {\n        if other == Self::zero() { self } else { other.gcd(self % &other) }\n    }\n}\nmacro_rules! impl_primitive_unsigned {\n    ( $($t: ty)* ) => { $(\n        impl PrimitiveUnsigned for $t {\n            fn ceil_div(self, rhs: $t) -> $t {\n                (self + rhs - 1) / rhs\n            }\n            fn round_div(self, rhs: $t) -> $t {\n                (self + rhs/2) / rhs\n            }\n            fn log2(mut self) -> Option<$t> {\n                if self == 0 {\n                    None\n                } else {\n                    let mut ans = 0;\n                    while self > 1 {\n                        ans += 1;\n                        self /= 2;\n                    }\n                    Some(ans)\n                }\n            }\n            fn ceil_log2(self) -> Option<$t> {\n                self.log2().map(|x| {\n                    (self + ((1<<x) - 1)).log2().unwrap()\n                })\n            }\n            fn sqrt(self) -> $t {\n                (self as f64).sqrt() as $t\n            }\n        }\n    )* }\n}\nimpl_primitive_unsigned!(u8 u16 u32 u64 u128 usize);\npub trait PrimitiveSigned: PrimitiveInteger {\n    fn bezout(self, other: Self) -> (Self, Self, Self::Unsigned);\n}\nunsafe fn bezout_sub<T: PrimitiveUnsigned>(a: T, b: T) -> (T::Signed, T::Signed, T) {\n    if b == T::zero() { (T::Signed::one(), T::Signed::zero(), a) } else {\n        let m = (a / &b).to_signed_unchecked();\n        let (x, y, g) = bezout_sub(b, a % &b);\n        let solution_b = x - &(m * &y);\n        (y, solution_b, g)\n    }\n}\nmacro_rules! impl_primitive_signed {\n    ( $($t: ty)* ) => { $(\n        impl PrimitiveSigned for $t {\n            fn bezout(self, other: $t) -> ($t, $t, <$t as ToUnsigned>::Unsigned) {\n                let (x, y, g) = unsafe { bezout_sub(\n                    (self * self.signum()).to_unsigned_unchecked(),\n                    (other * other.signum()).to_unsigned_unchecked()\n                ) };\n                (x * self.signum(), y * other.signum(), g)\n            }\n        }\n    )* }\n}\nimpl_primitive_signed!(i8 i16 i32 i64 i128 isize);\n\n// SNIPPET iter\npub struct Chunks<I> {\n    iter: I,\n    size: usize\n}\nimpl<I: Iterator> Iterator for Chunks<I> {\n    type Item = Vec<I::Item>;\n    fn next(&mut self) -> Option<Self::Item> {\n        let first = self.iter.next();\n        if first.is_none() {\n            return None;\n        }\n        let mut chunk = Vec::with_capacity(self.size);\n        chunk.push(first.unwrap());\n        for _ in 0..self.size-1 {\n            match self.iter.next() {\n                Some(x) => chunk.push(x),\n                None => break\n            }\n        }\n        Some(chunk)\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (lower, upper) = self.iter.size_hint();\n        (lower.ceil_div(self.size), upper.map(|u| u.ceil_div(self.size)))\n    }\n    fn count(self) -> usize {\n        self.iter.count().ceil_div(self.size)\n    }\n    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n        if n > 0 {\n            self.iter.nth(n * self.size - 1);\n        }\n        self.next()\n    }\n}\nimpl<I: ExactSizeIterator> ExactSizeIterator for Chunks<I> {}\nimpl<I: std::iter::FusedIterator> std::iter::FusedIterator for Chunks<I> {}\n#[derive(Clone)]\npub struct LScan<I, S, F> {\n    iter: I,\n    state: Option<S>,\n    f: F,\n}\nimpl<I: Iterator, S, F> Iterator for LScan<I, S, F>\nwhere\n    F: FnMut(&S, I::Item) -> S\n{\n    type Item = S;\n    fn next(&mut self) -> Option<S> {\n        if self.state.is_none() {\n            return None;\n        }\n        let state_inner = self.state.take().unwrap();\n        if let Some(item) = self.iter.next() {\n            self.state = Some((self.f)(&state_inner, item));\n        }\n        Some(state_inner)\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let (lower, upper) = self.iter.size_hint();\n        (lower + 1, upper.map(|u| u + 1))\n    }\n    fn count(self) -> usize {\n        self.iter.count() + 1\n    }\n}\nimpl<I: ExactSizeIterator, S, F: FnMut(&S, I::Item) -> S> ExactSizeIterator for LScan<I, S, F> {}\nimpl<I: std::iter::FusedIterator, S, F: FnMut(&S, I::Item) -> S> std::iter::FusedIterator for LScan<I, S, F> {}\npub struct GroupBy<K, I: Iterator, F> {\n    cur: Option<(I::Item, K)>,\n    iter: I,\n    key_fn: F\n}\nimpl<K: Eq, I: Iterator, F: FnMut(&I::Item) -> K> Iterator for GroupBy<K, I, F> {\n    type Item = (K, Vec<I::Item>);\n    fn next(&mut self) -> Option<(K, Vec<I::Item>)> {\n        let cur = self.cur.take();\n        cur.map(|(item, key)| {\n            let mut group = vec![item];\n            loop {\n                let next = self.iter.next();\n                match next {\n                    Some(next_item) => {\n                        let next_key = (self.key_fn)(&next_item);\n                        if key == next_key {\n                            group.push(next_item);\n                        } else {\n                            self.cur = Some((next_item, next_key));\n                            break;\n                        }\n                    }\n                    None => {\n                        self.cur = None;\n                        break;\n                    }\n                }\n            }\n            (key, group)\n        })\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.cur.is_none() {\n            (0, Some(0))\n        } else {\n            let (_, upper) = self.iter.size_hint();\n            (1, upper.map(|u| u + 1))\n        }\n    }\n}\nimpl<K: Eq, I: Iterator, F: FnMut(&I::Item) -> K> std::iter::FusedIterator for GroupBy<K, I, F> {}\npub struct RunLength<I: Iterator> {\n    cur: Option<I::Item>,\n    iter: I\n}\nimpl<I: Iterator> Iterator for RunLength<I> where I::Item: Eq {\n    type Item = (I::Item, usize);\n    fn next(&mut self) -> Option<(I::Item, usize)> {\n        let cur = self.cur.take();\n        cur.map(|value| {\n            let mut length = 1;\n            loop {\n                let next = self.iter.next();\n                match next {\n                    Some(next_value) => {\n                        if value == next_value {\n                            length += 1;\n                        } else {\n                            self.cur = Some(next_value);\n                            break;\n                        }\n                    }\n                    None => {\n                        self.cur = None;\n                        break;\n                    }\n                }\n            }\n            (value, length)\n        })\n    }\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        if self.cur.is_none() {\n            (0, Some(0))\n        } else {\n            let (_, upper) = self.iter.size_hint();\n            (1, upper.map(|u| u + 1))\n        }\n    }\n}\nimpl<I: Iterator> std::iter::FusedIterator for RunLength<I> where I::Item: Eq {}\npub trait IteratorExt: Iterator {\n    fn chunks(self, size: usize) -> Chunks<Self> where Self: Sized {\n        assert!(size > 0);\n        Chunks {\n            iter: self,\n            size: size\n        }\n    }\n    fn lscan<S, F>(self, state: S, f: F) -> LScan<Self, S, F>\n    where\n        Self: Sized,\n        F: FnMut(&S, Self::Item) -> S,\n    {\n        LScan {\n            iter: self,\n            state: Some(state),\n            f: f,\n        }\n    }\n    fn lscan1<F>(mut self, f: F) -> Option<LScan<Self, Self::Item, F>>\n    where\n        Self: Sized,\n        Self::Item: Clone,\n        F: FnMut(&Self::Item, Self::Item) -> Self::Item\n    {\n        self.next().map(|first| self.lscan(first, f))\n    }\n    fn get_unique(mut self) -> Option<Self::Item> where Self: Sized, Self::Item: Eq {\n        let first_opt = self.next();\n        first_opt.and_then(|first| {\n            if self.all(|item| item == first) { Some(first) } else { None }\n        })\n    }\n    fn group_by<K: Eq, F: FnMut(&Self::Item) -> K>(mut self, mut f: F) -> GroupBy<K, Self, F> where Self: Sized {\n        let next = self.next();\n        GroupBy {\n            cur: next.map(|item| {\n                let key = f(&item);\n                (item, key)\n            }),\n            iter: self,\n            key_fn: f\n        }\n    }\n    fn run_length(mut self) -> RunLength<Self> where Self: Sized, Self::Item: Eq {\n        RunLength {\n            cur: self.next(),\n            iter: self\n        }\n    }\n    fn join<T: std::fmt::Display>(mut self, sep: T) -> String\n    where\n        Self: Sized, Self::Item: std::fmt::Display\n    {\n        let mut result = String::new();\n        if let Some(first) = self.next() {\n            result.push_str(&format!(\"{}\", first));\n        }\n        for s in self {\n            result.push_str(&format!(\"{}{}\", sep, s));\n        }\n        result\n    }\n    fn cat(self) -> String where Self: Sized, Self::Item: std::fmt::Display { self.join(\"\") }\n}\nimpl<I: Iterator> IteratorExt for I {}\npub trait IteratorInnerProduct<T, Rhs=T>: ExactSizeIterator<Item=T> {\n    fn inner_product<I, J>(self, other: I) -> Option<<T as std::ops::Mul<Rhs>>::Output>\n    where\n        Self: Sized,\n        I: IntoIterator<Item=Rhs, IntoIter=J>,\n        J: Iterator<Item=Rhs> + ExactSizeIterator,\n        T: std::ops::Mul<Rhs>,\n        <T as std::ops::Mul<Rhs>>::Output: std::iter::Sum\n    {\n        let iter = other.into_iter();\n        (self.len() == iter.len()).then_with(|| {\n            self.zip(iter).map(|(a, b)| a * b).sum()\n        })\n    }\n}\nimpl<T1, T2, I> IteratorInnerProduct<T1, T2> for I\nwhere\n    I: Iterator<Item=T1> + ExactSizeIterator,\n    T1: std::ops::Mul<T2>\n{}\npub struct Unfold<State, T, F> where F: FnMut(&State) -> Option<(T, State)> {\n    state: State,\n    f: F\n}\nimpl<State, T, F> Iterator for Unfold<State, T, F> where F: FnMut(&State) -> Option<(T, State)> {\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        (self.f)(&self.state).map(|(value, state)| {\n            self.state = state;\n            value\n        })\n    }\n}\npub fn unfold<State, T, F>(init: State, f: F) -> Unfold<State, T, F> where F: FnMut(&State) -> Option<(T, State)> {\n    Unfold { state: init, f: f }\n}\npub struct Iterate<T, F> where F: FnMut(&T) -> T {\n    state: T,\n    f: F\n}\nimpl<T, F> Iterator for Iterate<T, F> where F: FnMut(&T) -> T {\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        use std::mem::swap;\n        let mut state = (self.f)(&self.state);\n        swap(&mut state, &mut self.state);\n        Some(state)\n    }\n}\npub fn iterate<T, F>(init: T, f: F) -> Iterate<T, F>\nwhere\n    F: FnMut(&T) -> T\n{\n    Iterate { state: init, f: f }\n}\npub struct IterateMap<State, T, F> where F: FnMut(&State) -> (T, State) {\n    state: State,\n    f: F\n}\nimpl<State, T, F> Iterator for IterateMap<State, T, F> where F: FnMut(&State) -> (T, State) {\n    type Item = T;\n    fn next(&mut self) -> Option<T> {\n        let (value, state) = (self.f)(&self.state);\n        self.state = state;\n        Some(value)\n    }\n}\npub fn iterate_map<State, T, F>(init: State, f: F) -> IterateMap<State, T, F>\nwhere\n    F: FnMut(&State) -> (T, State)\n{\n    IterateMap { state: init, f }\n}\n\n// SNIPPET cmp\nuse std::cmp::{Ord, Ordering};\npub fn minmax<T: Ord>(a: T, b: T) -> (T, T) {\n    if a <= b { (a, b) } else { (b, a) }\n}\n#[macro_export]\nmacro_rules! chmin {\n    ($place: expr, $expr: expr) => {\n        let value = $expr;\n        if value < $place {\n            $place = value;\n        }\n    }\n}\n#[macro_export]\nmacro_rules! chmax {\n    ($place: expr, $expr: expr) => {\n        let value = $expr;\n        if value > $place {\n            $place = value;\n        }\n    }\n}\n#[derive(Clone, Copy, PartialEq, Eq, Debug, Default, Hash)]\npub struct Reverse<T: Ord>(pub T);\nimpl<T: Ord> PartialOrd for Reverse<T> {\n    fn partial_cmp(&self, other: &Reverse<T>) -> Option<Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n}\nimpl<T: Ord> Ord for Reverse<T> {\n    fn cmp(&self, other: &Reverse<T>) -> Ordering {\n        other.0.cmp(&self.0)\n    }\n}\npub trait SortDesc<T> {\n    fn sort_desc(&mut self) where T: Ord;\n    fn sort_desc_by<F>(&mut self, cmp: F)\n    where\n        F: FnMut(&T, &T) -> std::cmp::Ordering;\n    fn sort_desc_by_key<K: Ord, F: FnMut(&T) -> K>(&mut self, key: F);\n    fn sort_unstable_desc(&mut self) where T: Ord;\n    fn sort_unstable_desc_by<F>(&mut self, cmp: F)\n    where\n        F: FnMut(&T, &T) -> std::cmp::Ordering;\n    fn sort_unstable_desc_by_key<K: Ord, F: FnMut(&T) -> K>(&mut self, key: F);\n}\nimpl<T> SortDesc<T> for [T] {\n    fn sort_desc(&mut self) where T: Ord {\n        self.sort_by(|x, y| y.cmp(x));\n    }\n    fn sort_desc_by<F>(&mut self, mut cmp: F)\n    where\n        F: FnMut(&T, &T) -> std::cmp::Ordering\n    {\n        self.sort_by(|x, y| cmp(y, x));\n    }\n    fn sort_desc_by_key<K: Ord, F: FnMut(&T) -> K>(&mut self, mut key: F) {\n        self.sort_by_key(|x| Reverse(key(x)));\n    }\n    fn sort_unstable_desc(&mut self) where T: Ord {\n        self.sort_unstable_by(|x, y| y.cmp(x));\n    }\n    fn sort_unstable_desc_by<F>(&mut self, mut cmp: F)\n    where\n        F: FnMut(&T, &T) -> std::cmp::Ordering\n    {\n        self.sort_unstable_by(|x, y| cmp(y, x));\n    }\n    fn sort_unstable_desc_by_key<K: Ord, F: FnMut(&T) -> K>(&mut self, mut key: F) {\n        self.sort_unstable_by_key(|x| Reverse(key(x)));\n    }\n}\n#[derive(Clone, Copy, PartialEq, PartialOrd, Debug, Default, Hash)]\npub struct Total<T: PartialOrd + PartialEq>(pub T);\nimpl<T: PartialOrd + PartialEq> Eq for Total<T> {}\nimpl<T: PartialOrd + PartialEq> Ord for Total<T> {\n    fn cmp(&self, other: &Self) -> Ordering {\n        self.partial_cmp(other).unwrap()\n    }\n}\npub trait IteratorMinmax: Iterator {\n    fn minmax(self) -> Option<(Self::Item, Self::Item)>;\n    fn minmax_by_key<K, F>(self, key_fn: F) -> Option<(Self::Item, Self::Item)>\n    where\n        K: Ord,\n        F: FnMut(&Self::Item) -> K;\n    fn minmax_by<F>(self, compare: F) -> Option<(Self::Item, Self::Item)>\n    where\n        F: FnMut(&Self::Item, &Self::Item) -> Ordering;\n}\nimpl<T: Ord + Clone, I: Iterator<Item=T>> IteratorMinmax for I {\n    fn minmax(self) -> Option<(Self::Item, Self::Item)> {\n        self.minmax_by(|a, b| a.cmp(b))\n    }\n    fn minmax_by_key<K, F>(self, mut key_fn: F) -> Option<(Self::Item, Self::Item)>\n    where\n        K: Ord,\n        F: FnMut(&Self::Item) -> K\n    {\n        self.minmax_by(|a, b| key_fn(a).cmp(&key_fn(b)))\n    }\n    fn minmax_by<F>(mut self, mut compare: F) -> Option<(Self::Item, Self::Item)>\n    where\n        F: FnMut(&Self::Item, &Self::Item) -> Ordering\n    {\n        let first = self.next()?;\n        let second = match self.next() {\n            Some(x) => x,\n            None => return Some((first.clone(), first))\n        };\n        let mut result = minmax(first, second);\n        while let Some(x) = self.next() {\n            let (min, max) = result;\n            result = if compare(&x, &min) == Ordering::Less {\n                (x, max)\n            } else if compare(&max, &x) == Ordering::Less {\n                (min, x)\n            } else {\n                (min, max)\n            };\n        }\n        Some(result)\n    }\n}\npub trait WithCmpIdentity<T>: Sized {\n    fn new(x: T) -> Self;\n    fn inf() -> Self;\n    fn as_option(&self) -> Option<&T>;\n    fn as_option_mut(&mut self) -> Option<&mut T>;\n    fn into_option(self) -> Option<T>;\n    fn is_fin(&self) -> bool {\n        self.as_option().is_some()\n    }\n    fn is_inf(&self) -> bool {\n        self.as_option().is_none()\n    }\n    fn expect_fin(self, msg: &str) -> T {\n        self.into_option().expect(msg)\n    }\n    fn fin(self) -> T {\n        self.into_option().unwrap()\n    }\n    fn fin_or(self, default: T) -> T {\n        self.into_option().unwrap_or(default)\n    }\n    fn fin_or_else<F: FnOnce() -> T>(self, f: F) -> T {\n        self.into_option().unwrap_or_else(f)\n    }\n    fn map_or<U, F: FnOnce(T) -> U>(self, default: U, f: F) -> U {\n        self.into_option().map_or(default, f)\n    }\n    fn map_or_else<U, D, F>(self, default: D, f: F) -> U\n    where\n        D: FnOnce() -> U,\n        F: FnOnce(T) -> U\n    {\n        self.into_option().map_or_else(default, f).into()\n    }\n}\n#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\npub enum MaybeNegInf<T> {\n    Inf,\n    Fin(T)\n}\npub type Max<T> = MaybeNegInf<T>;\n#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\npub enum MaybeInf<T> {\n    Fin(T),\n    Inf\n}\npub type Min<T> = MaybeInf<T>;\nmacro_rules! impl_with_cmp_identity {\n    ($t:ident) => {\n        impl<T> $t<T> {\n            pub fn map<U: Ord, F: FnOnce(T) -> U>(self, f: F) -> $t<U> {\n                match self {\n                    $t::Fin(x) => $t::Fin(f(x)),\n                    $t::Inf => $t::Inf\n                }\n            }\n        }\n        impl<T> WithCmpIdentity<T> for $t<T> {\n            fn new(x: T) -> $t<T> { $t::Fin(x) }\n            fn inf() -> $t<T> { $t::Inf }\n            fn as_option(&self) -> Option<&T> {\n                match self {\n                    $t::Fin(x) => Some(x),\n                    $t::Inf => None\n                }\n            }\n            fn as_option_mut(&mut self) -> Option<&mut T> {\n                match self {\n                    $t::Fin(x) => Some(x),\n                    $t::Inf => None\n                }\n            }\n            fn into_option(self) -> Option<T> {\n                match self {\n                    $t::Fin(x) => Some(x),\n                    $t::Inf => None\n                }\n            }\n        }\n    }\n}\nimpl_with_cmp_identity!(MaybeNegInf);\nimpl_with_cmp_identity!(MaybeInf);\n\n// END SNIPPETS\n// Here is the documentation: https://yoshrc.github.io/rust-atcoder-snippets/atcoder_snippets/index.html\n\nuse std::collections::BTreeMap;\n\nfn check(es: &[(usize, usize)], n: usize) -> bool {\n    if es.len() != n-1 {\n        return false;\n    }\n    let mut sets = VecUnionFindSets::with_items(n);\n    for &(a, b) in es {\n        sets.unite(a, b).unwrap();\n    }\n    sets.count() == 1\n}\n\nfn main() {\n    read!(n = u64);\n    let mut d_to_v = BTreeMap::new();\n    for (v, d) in read_lines::<u64>().enumerate() {\n        d_to_v.insert(d, v);\n    }\n    let mut vs = d_to_v.clone();\n    let mut es = Vec::new();\n    while let Some((&(mut d), &(mut v))) = vs.iter().next_back() {\n        vs.remove(&d);\n        for w in iterate(n, |n| n.saturating_sub(2)).skip(1) {\n            if w == 0 || d < w {\n                break;\n            }\n            match d_to_v.get(&(d - w)) {\n                None => break,\n                Some(&v_next) => {\n                    d = d - w;\n                    vs.remove(&d);\n                    es.push(minmax(v, v_next));\n                    v = v_next;\n                }\n            }\n        }\n    }\n    let ans = check(&es, n as usize).then_with(|| {\n        es.sort();\n        es.into_iter().map(|(a, b)| format!(\"{} {}\", a+1, b+1)).join('\\n')\n    }).to_string_or(-1);\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::{self, BufRead};\nuse std::collections::BTreeMap;\n\n#[derive(Debug, Clone)]\nstruct Tree {\n  id: usize,\n  count: usize,\n  children: Vec<Box<Tree>>,\n}\n\nfn dfs(t: &Box<Tree>, es: &mut Vec<(usize, usize)>) {\n  for c in &t.children {\n    es.push((t.id, c.id));\n    dfs(&c, es);\n  }\n}\n\nfn main() {\n  let stdin = io::stdin();\n  let mut lines = stdin.lock().lines();\n  let n: usize = lines.next().unwrap().unwrap().parse().unwrap();\n  let mut ds: Vec<(usize, usize)> = Vec::new();\n  for i in 0..n {\n    let x: usize = lines.next().unwrap().unwrap().parse().unwrap();\n    ds.push((i + 1, x));\n  }\n  ds.sort_by(|x, y| y.1.cmp(&x.1));\n  let mut forest: BTreeMap<usize, Vec<Box<Tree>>> = BTreeMap::new();\n  for tup in &ds {\n    let i = tup.0;\n    let d = tup.1;\n    let contains = forest.contains_key(&d);\n    let v = if contains {\n      let cn = forest.remove(&d).unwrap();\n      Tree { id: i, count: 1 + cn.iter().map(|c| c.count).sum::<usize>(), children: cn }\n    } else {\n      Tree { id: i, count: 1, children: Vec::new() }\n    };\n    let k = d + 2 * v.count - n;\n    let contains = forest.contains_key(&k);\n    if contains {\n      if let Some(t) = forest.get_mut(&k) {\n        t.push(Box::new(v));\n      }\n    } else {\n      forest.insert(k, vec![Box::new(v)]);\n    }\n  }\n  if forest.len() != 1 || forest.iter().next().unwrap().1.len() != 1 {\n    println!(\"-1\");\n    return;\n  }\n  let mut es: Vec<(usize, usize)> = Vec::new();\n  let t = &forest.iter().next().unwrap().1[0];\n  dfs(t, &mut es);\n  for (x, y) in es {\n    println!(\"{} {}\", x, y);\n  }\n}"
  }
]