[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100005\n\nint n;\nlong long D[MAX_N];\nint parent[MAX_N];\nint edges[MAX_N][2];\n\nint cmp(const void* a, const void* b) {\n    return (*(long long*)a - *(long long*)b);\n}\n\nint find(int x) {\n    if (parent[x] != x) \n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nvoid unite(int x, int y) {\n    parent[find(x)] = find(y);\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%lld\", &D[i]);\n        parent[i] = i;\n    }\n\n    qsort(D + 1, n, sizeof(long long), cmp);\n\n    for (int i = 1; i <= n; i++) {\n        if (D[i] < n - 1 || D[i] > (long long)(n - 1) * (n - 1)) {\n            printf(\"-1\\n\");\n            return 0;\n        }\n    }\n\n    long long total = 0;\n    for (int i = 1; i <= n; i++) \n        total += D[i];\n\n    if (total != (long long)2 * (n - 1) * (n - 1)) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n\n    int edge_count = 0;\n    for (int root = 1; root <= n; root++) {\n        for (int i = 1; i <= n; i++) \n            parent[i] = i;\n        edge_count = 0;\n\n        for (int i = 1; i <= n; i++) {\n            if (i == root) continue;\n            int u = root;\n            int v = i;\n            if (find(u) != find(v)) {\n                unite(u, v);\n                edges[edge_count][0] = u;\n                edges[edge_count][1] = v;\n                edge_count++;\n            }\n        }\n\n        if (edge_count == n - 1) {\n            printf(\"%d\\n\", n - 1);\n            for (int i = 0; i < n - 1; i++) \n                printf(\"%d %d\\n\", edges[i][0], edges[i][1]);\n            return 0;\n        }\n    }\n\n    printf(\"-1\\n\");\n    return 0;\n}",
    "timestamp": "2025-08-05 23:02:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int d;\n    int idx;\n} Node;\n\nint cmp(const void *a, const void *b) {\n    return ((Node*)b)->d - ((Node*)a)->d;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Node *nodes = (Node*)malloc(N * sizeof(Node));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &nodes[i].d);\n        nodes[i].idx = i + 1;\n    }\n    qsort(nodes, N, sizeof(Node), cmp);\n\n    int *parent = (int*)malloc(N * sizeof(int));\n    int *size = (int*)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        parent[i] = -1;\n        size[i] = 1;\n    }\n\n    int possible = 1;\n    for (int i = 0; i < N - 1; i++) {\n        int d = nodes[i].d;\n        int u = nodes[i].idx;\n        int target_d = d - (N - 2 * size[i]);\n        int found = 0;\n        for (int j = i + 1; j < N; j++) {\n            if (nodes[j].d == target_d) {\n                parent[i] = j;\n                size[j] += size[i];\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            possible = 0;\n            break;\n        }\n    }\n\n    if (possible && nodes[N-1].d == 0) {\n        for (int i = 0; i < N - 1; i++) {\n            printf(\"%d %d\\n\", nodes[i].idx, nodes[parent[i]].idx);\n        }\n    } else {\n        printf(\"-1\\n\");\n    }\n\n    free(nodes);\n    free(parent);\n    free(size);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:02:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<pair<int, int>> D(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> D[i].first;\n        D[i].second = i + 1;\n    }\n    sort(D.begin(), D.end(), greater<pair<int, int>>());\n\n    map<int, int> size;\n    map<int, int> parent;\n    vector<pair<int, int>> edges;\n\n    for (int i = 0; i < N; ++i) {\n        size[D[i].second] = 1;\n    }\n\n    for (int i = 0; i < N - 1; ++i) {\n        int u = D[i].second;\n        int d = D[i].first;\n        int required = d - (N - 2 * size[u]);\n        if (size.find(required) == size.end()) {\n            cout << -1 << endl;\n            return 0;\n        }\n        int v = parent[required] ? parent[required] : (required == D.back().first ? D.back().second : 0);\n        if (v == 0) {\n            cout << -1 << endl;\n            return 0;\n        }\n        edges.emplace_back(u, v);\n        size[v] += size[u];\n        parent[u] = v;\n    }\n\n    vector<int> realD(N + 1, 0);\n    vector<vector<int>> adj(N + 1);\n    for (auto &e : edges) {\n        adj[e.first].push_back(e.second);\n        adj[e.second].push_back(e.first);\n    }\n\n    for (int i = 1; i <= N; ++i) {\n        vector<int> dist(N + 1, -1);\n        dist[i] = 0;\n        vector<int> q = {i};\n        for (int j = 0; j < q.size(); ++j) {\n            int u = q[j];\n            for (int v : adj[u]) {\n                if (dist[v] == -1) {\n                    dist[v] = dist[u] + 1;\n                    q.push_back(v);\n                }\n            }\n        }\n        for (int j = 1; j <= N; ++j) {\n            realD[i] += dist[j];\n        }\n    }\n\n    for (int i = 0; i < N; ++i) {\n        if (realD[D[i].second] != D[i].first) {\n            cout << -1 << endl;\n            return 0;\n        }\n    }\n\n    for (auto &e : edges) {\n        cout << e.first << \" \" << e.second << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:03:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Pair implements Comparable<Pair> {\n        int d, idx;\n        Pair(int d, int idx) {\n            this.d = d;\n            this.idx = idx;\n        }\n        public int compareTo(Pair o) {\n            return Integer.compare(o.d, this.d);\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int N = Integer.parseInt(br.readLine());\n        Pair[] pairs = new Pair[N];\n        String[] tokens = br.readLine().split(\" \");\n        for (int i = 0; i < N; i++) {\n            pairs[i] = new Pair(Integer.parseInt(tokens[i]), i + 1);\n        }\n        Arrays.sort(pairs);\n\n        Map<Integer, Integer> size = new HashMap<>();\n        Map<Integer, Integer> parent = new HashMap<>();\n        List<String> edges = new ArrayList<>();\n\n        for (int i = 0; i < N; i++) {\n            size.put(pairs[i].idx, 1);\n        }\n\n        boolean possible = true;\n        for (int i = 0; i < N - 1; i++) {\n            int currentD = pairs[i].d;\n            int currentIdx = pairs[i].idx;\n            int requiredParentD = currentD - (N - 2 * size.get(currentIdx));\n            if (!size.containsKey(requiredParentD)) {\n                possible = false;\n                break;\n            }\n            int parentIdx = -1;\n            for (int j = i + 1; j < N; j++) {\n                if (pairs[j].d == requiredParentD) {\n                    parentIdx = pairs[j].idx;\n                    break;\n                }\n            }\n            if (parentIdx == -1) {\n                possible = false;\n                break;\n            }\n            parent.put(currentIdx, parentIdx);\n            edges.add(currentIdx + \" \" + parentIdx);\n            size.put(parentIdx, size.get(parentIdx) + size.get(currentIdx));\n        }\n\n        if (!possible) {\n            System.out.println(-1);\n            return;\n        }\n\n        // Verify root's D\n        int rootIdx = pairs[N-1].idx;\n        long total = 0;\n        Map<Integer, List<Integer>> tree = new HashMap<>();\n        for (String edge : edges) {\n            String[] uv = edge.split(\" \");\n            int u = Integer.parseInt(uv[0]);\n            int v = Integer.parseInt(uv[1]);\n            tree.computeIfAbsent(u, k -> new ArrayList<>()).add(v);\n            tree.computeIfAbsent(v, k -> new ArrayList<>()).add(u);\n        }\n\n        int[] dist = new int[N+1];\n        Arrays.fill(dist, -1);\n        dist[rootIdx] = 0;\n        Queue<Integer> q = new LinkedList<>();\n        q.add(rootIdx);\n        while (!q.isEmpty()) {\n            int u = q.poll();\n            for (int v : tree.getOrDefault(u, new ArrayList<>())) {\n                if (dist[v] == -1) {\n                    dist[v] = dist[u] + 1;\n                    q.add(v);\n                }\n            }\n        }\n        long sum = 0;\n        for (int i = 1; i <= N; i++) {\n            sum += dist[i];\n        }\n        if (sum != pairs[N-1].d) {\n            System.out.println(-1);\n            return;\n        }\n\n        for (String edge : edges) {\n            System.out.println(edge);\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:03:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TreeConstruction {\n    public static void solve(int[] D) {\n        int N = D.length;\n        \n        // Check if solution is possible\n        int[] sortedD = Arrays.copyOf(D, N);\n        Arrays.sort(sortedD);\n        \n        for (int i = 0; i < N; i++) {\n            if (sortedD[i] < 2 * (N - 1) || sortedD[i] > (N - 1) * (N - 1)) {\n                System.out.println(\"No solution\");\n                return;\n            }\n        }\n        \n        // Sort and track original indices\n        Integer[] indices = new Integer[N];\n        for (int i = 0; i < N; i++) {\n            indices[i] = i;\n        }\n        Arrays.sort(indices, (a, b) -> Integer.compare(D[a], D[b]));\n        \n        // Construct tree\n        List<int[]> edges = new ArrayList<>();\n        int[] degree = new int[N];\n        \n        for (int k = 0; k < N - 1; k++) {\n            int u = indices[k];\n            int v = indices[k + 1];\n            edges.add(new int[]{u, v});\n            degree[u]++;\n            degree[v]++;\n        }\n        \n        // Output results\n        System.out.println(\"Yes\");\n        for (int[] edge : edges) {\n            System.out.println((edge[0] + 1) + \" \" + (edge[1] + 1));\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[] D = new int[N];\n        for (int i = 0; i < N; i++) {\n            D[i] = scanner.nextInt();\n        }\n        solve(D);\n    }\n}",
    "timestamp": "2025-08-05 23:04:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<long long> D(N);\n    for (int i = 0; i < N; i++) {\n        cin >> D[i];\n    }\n    \n    vector<long long> sortedD = D;\n    sort(sortedD.begin(), sortedD.end());\n    \n    long long totalSum = 0;\n    for (int i = 0; i < N; i++) {\n        totalSum += sortedD[i];\n    }\n    \n    if (totalSum != 1LL * N * (N - 1)) {\n        cout << \"No\" << endl;\n        return 0;\n    }\n    \n    vector<int> parent(N, -1);\n    vector<int> u(N - 1), v(N - 1);\n    \n    int root = 0;\n    for (int i = 1; i < N; i++) {\n        if (sortedD[i] > sortedD[root]) {\n            root = i;\n        }\n    }\n    \n    vector<bool> used(N, false);\n    used[root] = true;\n    \n    int edges = 0;\n    for (int i = 0; i < N; i++) {\n        if (i == root) continue;\n        \n        int bestParent = -1;\n        for (int j = 0; j < N; j++) {\n            if (used[j] && (bestParent == -1 || parent[j] > parent[bestParent])) {\n                bestParent = j;\n            }\n        }\n        \n        parent[i] = bestParent;\n        u[edges] = bestParent + 1;\n        v[edges] = i + 1;\n        edges++;\n        used[i] = true;\n    }\n    \n    cout << \"Yes\" << endl;\n    for (int i = 0; i < N - 1; i++) {\n        cout << u[i] << \" \" << v[i] << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:04:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def construct_tree(N, distances):\n    if N == 1:\n        return [(0, 0)]\n    \n    if N == 2:\n        return [(1, 2)]\n\n    distance_indices = sorted(range(1, N + 1), key=lambda i: distances[i - 1])\n    left_tree = distance_indices[:N // 2]\n    right_tree = distance_indices[N // 2:]\n\n    edge_list = []\n    for i in range(1, len(left_tree)):\n        edge_list.append((left_tree[i - 1], left_tree[i]))\n    for i in range(1, len(right_tree)):\n        edge_list.append((right_tree[i - 1], right_tree[i]))\n    \n    edge_list.append((left_tree[-1], right_tree[0]))\n    \n    return edge_list\n\ndef print_tree(N, D):\n    edges = construct_tree(N, D)\n    for u, v in edges:\n        print(u, v)\n\n# Example Usage\nN = 3\nD = [2, 2, 2]\nprint_tree(N, D)",
    "timestamp": "2025-08-13 13:25:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class TreeDistance {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        \n        int N = Integer.parseInt(br.readLine());\n        int[] D = new int[N];\n        for (int i = 0; i < N; i++) {\n            D[i] = Integer.parseInt(br.readLine());\n        }\n        \n        int[] vertices = new int[N];\n        for (int i = 0; i < N; i++) {\n            vertices[i] = i + 1;\n        }\n        \n        int[] originalD = D.clone();\n        Arrays.sort(D);\n        Arrays.sort(vertices, (a, b) -> Integer.compare(originalD[a - 1], originalD[b - 1]));\n        \n        if (N == 2) {\n            if (D[0] == D[1]) {\n                System.out.println(vertices[0] + \" \" + vertices[1]);\n            } else {\n                System.out.println(\"-1\");\n            }\n            return;\n        }\n        \n        ArrayList<int[]> edges = new ArrayList<>();\n        int totalSum = Arrays.stream(D).sum();\n        \n        if (totalSum != N * (N - 1)) {\n            System.out.println(\"-1\");\n            return;\n        }\n        \n        ArrayList<Integer> leaves = new ArrayList<>();\n        for (int i = 0; i < N - 1; i++) {\n            leaves.add(vertices[i]);\n        }\n        \n        int lastVertex = vertices[N - 1];\n        \n        for (int i = 0; i < N - 2; i++) {\n            edges.add(new int[] {leaves.get(i), leaves.get(i + 1)});\n        }\n        \n        for (int leaf : leaves) {\n            edges.add(new int[] {leaf, lastVertex});\n        }\n        \n        for (int[] edge : edges) {\n            System.out.println(edge[0] + \" \" + edge[1]);\n        }\n    }\n}",
    "timestamp": "2025-08-13 13:25:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int index;\n    int value;\n} Node;\n\nint compare(const void *a, const void *b) {\n    return ((Node *)a)->value - ((Node *)b)->value;\n}\n\nvoid construct_tree(Node nodes[], int N) {\n    printf(\"Yes\\n\");\n    for (int i = 1; i < N; ++i) {\n        printf(\"%d %d\\n\", nodes[i - 1].index + 1, nodes[i].index + 1);\n    }\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Node nodes[N];\n    \n    for (int i = 0; i < N; ++i) {\n        nodes[i].index = i;\n        scanf(\"%d\", &nodes[i].value);\n    }\n    \n    // Sort nodes based on D_i values\n    qsort(nodes, N, sizeof(Node), compare);\n\n    construct_tree(nodes, N);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 13:26:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function constructTree(N, D) {\n    // Calculate the root node (the one with maximum D)\n    let rootIndex = 0;\n    for (let i = 1; i < N; i++) {\n        if (D[i] > D[rootIndex]) {\n            rootIndex = i;\n        }\n    }\n\n    let degrees = Array(N).fill(1);\n    degrees[rootIndex] = 0;\n\n    let edges = [];\n    let currentLeaves = [rootIndex];\n\n    for (let i = 0; i < N; i++) {\n        if (i !== rootIndex) {\n            let newLeaf = i;\n            let found = false;\n\n            for (let j = 0; j < currentLeaves.length; j++) {\n                let currLeaf = currentLeaves[j];\n                if (degrees[currLeaf] + 1 <= D[currLeaf]) {\n                    edges.push([currLeaf, newLeaf]);\n                    degrees[currLeaf]++;\n                    degrees[newLeaf]++;\n                    found = true;\n                    break;\n                }\n            }\n\n            if (!found) return null;\n\n            if (degrees[newLeaf] + 1 <= D[newLeaf]) {\n                currentLeaves.push(newLeaf);\n            }\n        }\n    }\n\n    return edges;\n}\n\nfunction main(N, D) {\n    const tree = constructTree(N, D);\n    if (tree) {\n        console.log(\"Tree exists:\");\n        for (const edge of tree) {\n            console.log(edge[0] + 1, edge[1] + 1); // printing 1-based index\n        }\n    } else {\n        console.log(\"No tree exists.\");\n    }\n}\n\n// Testing the function (example usage)\nconst N = 4;\nconst D = [6, 4, 4, 4];\nmain(N, D);",
    "timestamp": "2025-08-13 13:26:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(D):\n    N = len(D)\n    if N == 1:\n        return [()]\n    \n    # Find total sum of all D_i\n    total_sum = sum(D)\n    \n    # Check total sum condition\n    if total_sum != (N-1) * (N-1):\n        return None\n    \n    # Sort D in descending order with original indices\n    sorted_D = sorted(enumerate(D), key=lambda x: -x[1])\n    \n    # Start with vertex with max distance value\n    root = sorted_D[0][0]\n    used = [False] * N\n    used[root] = True\n    \n    edges = []\n    remaining_vertices = N - 1\n    \n    # Try to connect vertices to form tree\n    for i in range(1, N):\n        curr_vertex = sorted_D[i][0]\n        best_parent = -1\n        min_dist = float('inf')\n        \n        for j in range(N):\n            if j != curr_vertex and used[j]:\n                temp_dist = sum(1 for e in edges if e[0] == j or e[1] == j) + 1\n                if temp_dist < min_dist:\n                    min_dist = temp_dist\n                    best_parent = j\n        \n        if best_parent == -1:\n            return None\n        \n        edges.append((best_parent, curr_vertex))\n        used[curr_vertex] = True\n        remaining_vertices -= 1\n    \n    return edges\n\ndef main():\n    N = int(input())\n    D = list(map(int, input().split()))\n    \n    result = solve(D)\n    \n    if result is None:\n        print(-1)\n    else:\n        print(1)\n        for u, v in result:\n            print(u+1, v+1)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 13:26:13"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function constructTree(distances) {\n    const N = distances.length;\n    const graph = Array.from({ length: N }, () => []);\n    const degree = new Array(N).fill(0);\n    const edgeList = [];\n\n    // Sort vertices by their total distance\n    const vertices = distances.map((dist, idx) => ({ dist, idx }))\n        .sort((a, b) => a.dist - b.dist);\n\n    // Start with vertices that have minimal total distance\n    let root = vertices[0].idx;\n    let remainingVertices = new Set(vertices.map(v => v.idx));\n    remainingVertices.delete(root);\n\n    function addEdge(u, v) {\n        graph[u].push(v);\n        graph[v].push(u);\n        degree[u]++;\n        degree[v]++;\n        edgeList.push([u, v]);\n    }\n\n    // Greedy tree construction\n    while (remainingVertices.size > 0) {\n        let bestVertex = null;\n        let bestScore = Infinity;\n\n        for (let v of remainingVertices) {\n            if (checkVertexFit(v, root)) {\n                bestVertex = v;\n                break;\n            }\n        }\n\n        if (bestVertex === null) return null;\n\n        addEdge(root, bestVertex);\n        remainingVertices.delete(bestVertex);\n        root = bestVertex;\n    }\n\n    function checkVertexFit(vertex, parent) {\n        let totalDist = 0;\n        const visited = new Set([parent]);\n        const queue = [[parent, 1]];\n\n        while (queue.length > 0) {\n            const [curr, dist] = queue.shift();\n            totalDist += dist;\n\n            for (let neighbor of graph[curr]) {\n                if (!visited.has(neighbor)) {\n                    visited.add(neighbor);\n                    queue.push([neighbor, dist + 1]);\n                }\n            }\n        }\n\n        return totalDist === distances[vertex];\n    }\n\n    return edgeList.length === N - 1 ? edgeList : null;\n}",
    "timestamp": "2025-08-13 13:26:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    N = int(sys.stdin.readline())\n    D = list(map(int, sys.stdin.readline().split()))\n    nodes = sorted([(d, i+1) for i, d in enumerate(D)], reverse=True)\n    d_dict = {node[1]: node[0] for node in nodes}\n    \n    if N == 1:\n        if D[0] == 0:\n            print()\n        else:\n            print(-1)\n        return\n    \n    total = sum(D)\n    if total % (2 * (N - 1)) != 0:\n        print(-1)\n        return\n    \n    size = defaultdict(int)\n    parent = defaultdict(int)\n    edges = []\n    \n    for d, u in nodes[:-1]:\n        v = d - (total // (2 * (N - 1)) - (N - 1 - size[u])) + (N - 1 - size[u])\n        if v not in d_dict or v == u or parent.get(u, 0) == v:\n            print(-1)\n            return\n        edges.append((u, v))\n        size[v] = size.get(v, 0) + size[u] + 1\n        parent[v] = u\n    \n    last_node = nodes[-1][1]\n    if size.get(last_node, 0) != N - 1:\n        print(-1)\n        return\n    \n    # Verify the D values\n    # Build adjacency list\n    adj = defaultdict(list)\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    # BFS for each node to compute sum of distances\n    valid = True\n    for i in range(1, N+1):\n        visited = [False] * (N + 1)\n        q = [(i, 0)]\n        visited[i] = True\n        total_dist = 0\n        while q:\n            node, dist = q.pop(0)\n            for neighbor in adj[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    total_dist += dist + 1\n                    q.append((neighbor, dist + 1))\n        if total_dist != D[i-1]:\n            valid = False\n            break\n    \n    if not valid:\n        print(-1)\n    else:\n        for u, v in edges:\n            print(u, v)\n\nsolve()",
    "timestamp": "2025-08-13 13:26:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const fs = require('fs');\nconst input = fs.readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n\nfunction solve() {\n    const N = parseInt(input[0], 10);\n    const D = input[1].split(' ').map((d, i) => ({ d: parseInt(d, 10), idx: i + 1 }));\n    D.sort((a, b) => b.d - a.d);\n\n    const sumD = D.reduce((acc, curr) => acc + curr.d, 0);\n    if (sumD !== 2 * (N - 1)) {\n        console.log(-1);\n        return;\n    }\n\n    const edges = [];\n    const parentMap = new Map();\n    const childrenCount = new Map();\n    let possible = true;\n\n    for (let i = 0; i < N; i++) {\n        childrenCount.set(D[i].idx, 0);\n    }\n\n    let current = 0;\n    const queue = [];\n    for (let i = 0; i < N - 1; i++) {\n        const node = D[i];\n        const d = node.d;\n        const idx = node.idx;\n\n        if (i === 0) {\n            if (d < 1) {\n                possible = false;\n                break;\n            }\n            childrenCount.set(idx, d);\n            queue.push(idx);\n        } else {\n            while (current < queue.length) {\n                const u = queue[current];\n                const remaining = childrenCount.get(u);\n                if (remaining <= 0) {\n                    current++;\n                    continue;\n                }\n                childrenCount.set(u, remaining - 1);\n                parentMap.set(idx, u);\n                edges.push([u, idx]);\n                const newCount = childrenCount.get(idx) - 1;\n                childrenCount.set(idx, newCount);\n                if (newCount > 0) {\n                    queue.push(idx);\n                }\n                break;\n            }\n            if (!parentMap.has(idx)) {\n                possible = false;\n                break;\n            }\n        }\n    }\n\n    if (!possible || edges.length !== N - 1) {\n        console.log(-1);\n    } else {\n        edges.forEach(edge => console.log(edge[0], edge[1]));\n    }\n}\n\nsolve();",
    "timestamp": "2025-08-13 13:26:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Vertex {\n    int d;\n    int index;\n};\n\nbool compare(const Vertex& a, const Vertex& b) {\n    return a.d < b.d;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<Vertex> vertices(N);\n    \n    for (int i = 0; i < N; ++i) {\n        cin >> vertices[i].d;\n        vertices[i].index = i + 1;\n    }\n    \n    if (N == 1) {\n        if (vertices[0].d == 0) {\n            cout << \"YES\\n\";\n        } else {\n            cout << \"NO\\n\";\n        }\n        return 0;\n    }\n\n    sort(vertices.begin(), vertices.end(), compare);\n\n    // Build a path from largest to smallest\n    vector<pair<int, int>> edges;\n    \n    if (vertices[0].d != N - 1 || vertices[1].d != N - 2) {\n        cout << \"NO\\n\";\n        return 0;\n    }\n    \n    for (int i = 1; i < N; ++i) {\n        edges.emplace_back(vertices[i - 1].index, vertices[i].index);\n    }\n\n    cout << \"YES\\n\";\n    for (const auto& edge : edges) {\n        cout << edge.first << \" \" << edge.second << \"\\n\";\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:39:37"
  }
]