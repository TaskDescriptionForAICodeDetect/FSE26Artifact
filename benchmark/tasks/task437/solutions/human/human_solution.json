[
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n#define MOD 1000000007 // prime\nconst int SIZE = 100100;\nll inv[SIZE+10],fac[SIZE+10],facinv[SIZE+10];\nll Pow[1010],kai[210];\nll val[210];\nll nCr(int n,int r)\n{\n\tif(n<r)return -1;\n\tif(n<0||r<0)return -1;\n\treturn ((fac[n]*facinv[r]%MOD)*facinv[n-r])%MOD;\n}\nll func(int n)\n{\n\tll ret = 0ll;\n\tfor(int i=0;i<=n;i++)ret = (ret+(nCr(n,i)*kai[i])%MOD)%MOD;\n\treturn ret;\n}\nvoid init()\n{\n\tfac[0]=1ll;\n\tfor(int i=1;i<=SIZE;i++)fac[i]=(fac[i-1]*i)%MOD;\n\tinv[1]=1ll;\n\tfor(int i=2;i<=SIZE;i++)inv[i]=((-(MOD/i)*inv[MOD%i])%MOD+MOD)%MOD;\n\tfacinv[0]=1ll;\n\tfor(int i=1;i<=SIZE;i++)facinv[i]=(facinv[i-1]*inv[i])%MOD;\n\tPow[0]=1ll;\n\tfor(int i=0;i<1000;i++)Pow[i+1]=(Pow[i]*10ll)%MOD;\n\tkai[0]=1ll;\n\tfor(int i=1;i<=200;i++)kai[i]=(kai[i-1]*i)%MOD;\n\tfor(int i=0;i<=200;i++)val[i]=func(i);\n}\nint cnt_digit(ll x)\n{\n\tif(x==0ll)return 1;\n\tint ret = 0;\n\twhile(x){ret++;x/=10ll;}\n\treturn ret;\n}\nll dp[210][1010];\nint n;\nll a[210];\nint dig[210];\nll digit_sum[5];\nint del[5];\nint zero=-1;\nint N;\nvoid culc_dp(int unuse)\n{\n\tmemset(dp,0,sizeof(dp));\n\tdp[0][0]=1ll;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tif(i==unuse)continue;\n\t\tfor(int j=i;j>=0;j--)\n\t\t{\n\t\t\tfor(int k=0;k<=j*4;k++)\n\t\t\t{\n\t\t\t\tif(dp[j][k]==0)continue;\n\t\t\t\tdp[j+1][k+dig[i]]+=dp[j][k];\n\t\t\t\tdp[j+1][k+dig[i]]%=MOD;\n\t\t\t}\n\t\t}\n\t}\n}\nll solve()\n{\n\tll ans = 0ll;\n\tfor(int d=1;d<=4;d++)\n\t{\n\t\tif(del[d]==-1)continue;\n\t\tculc_dp(del[d]);\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=4*N;j++)\n\t\t\t{\n\t\t\t\tif(dp[i][j]==0)continue;\n\t\t\t\tans += (((((((val[N-i-1]*kai[i])%MOD)*digit_sum[d])%MOD)*dp[i][j])%MOD)*Pow[j])%MOD;\n\t\t\t\tans %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tinit();\n\tmemset(del,-1,sizeof(del));\n\tscanf(\"%d\",&n);\n\tN=n;\n\tfor(int i=0;i<n;i++)scanf(\"%lld\",&a[i]);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tdig[i]=cnt_digit(a[i]);\n\t\tdigit_sum[dig[i]]+=a[i];\n\t\tdel[dig[i]]=i;\n\t\tif(a[i]==0)zero=i;\n\t}\n\tll ans = solve();\n\t//cout << solve() << ' ';\n\tif(zero!=-1)\n\t{\n\t\tswap(a[zero],a[n-1]);\n\t\tN--;\n\t\tmemset(del,-1,sizeof(del));\n\t\tmemset(digit_sum,0,sizeof(digit_sum));\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tdig[i]=cnt_digit(a[i]);\n\t\t\tdigit_sum[dig[i]]+=a[i];\n\t\t\tdel[dig[i]]=i;\n\t\t}\n\t\tans -= solve();\n\t\t//cout << solve() << endl;\n\t\tans = ((ans%MOD)+MOD)%MOD;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint dp[12][92][202][202];\n\n#define int long long\n\nconst int M=1000000007;\nint C[202][202];\n\nint solve(vector<int> v){\n  int nd[5]={};\n  int s[5]={};\n  for(auto e:v){\n    int x=(e>=10)+(e>=100)+(e>=1000)+1;\n    nd[x]++;\n    s[x]=(s[x]+e)%M;\n  }\n  int t[223]={1};\n  int rp[223]={1};\n  int fact[223]={1};\n  for(int i=0;i<200;i++){\n    t[i+1]=t[i]*10LL%M;\n    rp[i+1]=(rp[i]*(i+1LL)+1)%M;\n    fact[i+1]=fact[i]*(i+1LL)%M;\n  }\n  dp[0][0][0][0]=1;\n  int r=0;\n  for(int i=0;i<=nd[1];i++){\n    for(int j=0;j<=nd[2];j++){\n      for(int k=0;k<=nd[3];k++){\n\tfor(int l=0;l<=nd[4];l++){\n\t  if(i!=nd[1]){\n\t    r=(r+t[i+j*2+k*3+l*4]*1LL*s[1]%M*rp[v.size()-1-i-j-k-l]%M*fact[i+j+l+k]%M*C[nd[1]-1][i]%M*C[nd[2]][j]%M*C[nd[3]][k]%M*C[nd[4]][l]%M)%M;\n\t  }\n\t  if(j!=nd[2]){\n\t    r=(r+t[i+j*2+k*3+l*4]*1LL*s[2]%M*rp[v.size()-1-i-j-k-l]%M*fact[i+j+l+k]%M*C[nd[1]][i]%M*C[nd[2]-1][j]%M*C[nd[3]][k]%M*C[nd[4]][l]%M)%M;\n\t  }\t    \n\t  if(k!=nd[3]){\n\t    r=(r+t[i+j*2+k*3+l*4]*1LL*s[3]%M*rp[v.size()-1-i-j-k-l]%M*fact[i+j+l+k]%M*C[nd[1]][i]%M*C[nd[2]][j]%M*C[nd[3]-1][k]%M*C[nd[4]][l]%M)%M;\n\t  }\t    \n\t  if(l!=nd[4]){\n\t    r=(r+t[i+j*2+k*3+l*4]*1LL*s[4]%M*rp[v.size()-1-i-j-k-l]%M*fact[i+j+l+k]%M*C[nd[1]][i]%M*C[nd[2]][j]%M*C[nd[3]][k]%M*C[nd[4]-1][l]%M)%M;\n\t  }\n\t  int d=dp[i][j][k][l]*1LL*(i+j+k+l)%M;\n\t  dp[i+1][j][k][l]=(dp[i+1][j][k][l]+d)%M;\n\t  dp[i][j+1][k][l]=(dp[i][j+1][k][l]+d)%M;\n\t  dp[i][j][k+1][l]=(dp[i][j][k+1][l]+d)%M;\n\t  dp[i][j][k][l+1]=(dp[i][j][k][l+1]+d)%M;\n\t}\n      }\n    }\n  }\n  return r;\n}\n\t  \nsigned main(){\n  C[0][0]=1;\n  for(int i=1;i<=200;i++){\n    C[i][0]=1;\n    for(int j=1;j<=i;j++){\n      C[i][j]=(C[i-1][j-1]+C[i-1][j])%M;\n    }\n  }\n  int n;\n  cin>>n;\n  vector<int> v(n);\n  for(int i=0;i<n;i++){\n    cin>>v[i];\n  }\n  sort(begin(v),end(v));\n  int ans=solve(v);\n  if(v[0]==0){\n    v.erase(v.begin());\n    ans=(ans-solve(v)+M)%M;\n  }\n  cout<<ans<<endl;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst long long mod=1000000007;\n\nlong long pw[1000];\nlong long sum[300];\nlong long fact[300];\n\nvoid init(){\n\tpw[0]=1;\n\tfor(int i=1;i<1000;i++) pw[i]=(pw[i-1]*10)%mod;\n\tfact[0]=1;\n\tfor(int i=1;i<300;i++) fact[i]=(fact[i-1]*i)%mod;\n\tfor(int i=0;i<300;i++){\n\t\tif(i==0){\n\t\t\tsum[i]=1;\n\t\t\tcontinue;\n\t\t}\n\t\tlong long tmp=1;\n\t\tsum[i]=1;\n\t\tfor(int j=i;j>=0;j--){\n\t\t\ttmp=(tmp*j)%mod;\n\t\t\tsum[i]=(sum[i]+tmp)%mod;\n\t\t}\n\t}\n}\n\nint getDig(int n){\n\tif(n==0) return 1;\n\tint c=0;\n\twhile(n>0){\n\t\tn/=10;\n\t\tc++;\n\t}\n\treturn c;\n}\n\nvector<int> digs;\nlong long dp[2][201][801];\n\nlong long solve(vector<int> vec){\n\tlong long res=0;\n\tint N=vec.size();\n\tfor(int i=0;i<N;i++){\n\t\tint x=vec[i];\n\t\tdigs.clear();\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(i==j) continue;\n\t\t\tdigs.push_back(getDig(vec[j]));\n\t\t}\n\t\tfor(int a=0;a<=200;a++) for(int b=0;b<=800;b++) dp[0][a][b]=0;\n\t\tdp[0][0][0]=1;\n\t\tint t=0;\n\t\tfor(int j=0;j<N-1;j++){\n\t\t\tfor(int a=0;a<=200;a++) for(int b=0;b<=800;b++) dp[1-t][a][b]=0;\n\t\t\tfor(int a=0;a<=200;a++) for(int b=0;b<=800;b++){\n\t\t\t\tdp[1-t][a][b]+=dp[t][a][b];\n\t\t\t\tif(a+1<=200&&b+digs[j]<=800){\n\t\t\t\t\tdp[1-t][a+1][b+digs[j]]+=dp[t][a][b];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int a=0;a<=200;a++) for(int b=0;b<=800;b++){\n\t\t\t\tdp[1-t][a][b]%=mod;\n\t\t\t}\n\t\t\tt=1-t;\n\t\t}\n\t\tfor(int a=0;a<=200;a++) for(int b=0;b<=800;b++){\n\t\t\tint c=N-1-a;\n\t\t\tlong long coe1=sum[c];\n\t\t\tlong long coe2=pw[b];\n\t\t\tlong long coe3=dp[t][a][b];\n\t\t\tlong long tmp=(coe1*coe2)%mod;\n\t\t\ttmp*=coe3;\n\t\t\ttmp%=mod;\n\t\t\ttmp*=fact[a];\n\t\t\ttmp%=mod;\n\t\t\ttmp*=vec[i];\n\t\t\ttmp%=mod;\n\t\t\tres=(res+tmp)%mod;\n\t\t}\n\t}\n\treturn res;\n}\n\nint a[200];\n\nint main(){\n\tinit();\n\tint N;\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++) scanf(\"%d\",a+i);\n\tif(N==1){\n\t\tprintf(\"%d\\n\",a[0]);\n\t\treturn 0;\n\t}\n\tlong long ans=0;\n\tvector<int> tmp1,tmp2;\n\tfor(int i=0;i<N;i++){\n\t\ttmp1.push_back(a[i]);\n\t\tif(a[i]!=0) tmp2.push_back(a[i]);\n\t}\n\tans=solve(tmp1);\n\tif(tmp1.size()!=tmp2.size()) ans-=solve(tmp2);\n\tans%=mod;\n\tans+=mod;\n\tans%=mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\n\nll add(ll a,ll b){ return (a+b)%mod; }\n\nvoid Add(int &a,ll b){\n  ll tmp=(a+b)%mod;\n  a=tmp;\n}\n\nll mul(ll a,ll b){ return (a*b)%mod; }\n\n\nll mpow(ll a,ll b){\n  ll res=1;\n  while(b){\n    if(b%2==1)res=mul(res,a);\n    a=mul(a,a);\n    b/=2;\n  }\n  return res;\n}\n\nll divi( ll a,ll b){\n  return mul(a, mpow(b,mod-2) );\n}\n\n\n\nint n;\nint a[200];\n\nll Z=0;\nll cnt[10];\nll cntinv[10];\n\nll sum[10];\n\n//ll dp[50][50][50][50][2];\n//ll DP[50][50][50][50][2];\nvector< vector< vector< vector< vector< int > > > >  > dp,DP;\n\nvoid update(int a,int b,int c,int d,int z){\n\n  int na=a%2;\n  int ma=1-na;\n  \n  /*  cout<<a<<' '<<b<<' '<<c<<' '<<d<<' '<<z<<endl;\n  cout<<dp[a][b][c][d][z]<<endl;\n  cout<<DP[a][b][c][d][z]<<endl;\n  cout<<endl;    */\n  if(a<cnt[1]){\n    int cc=cnt[1]-a;\n    ll pp=mul(dp[na][b][c][d][z], cc);\n    Add( dp[ma][b][c][d][z], pp );\n    Add( DP[ma][b][c][d][z], mul(DP[na][b][c][d][z], 10*cc )    );\n    Add( DP[ma][b][c][d][z], mul( mul(pp,cntinv[1]),sum[1]) );\n  }\n  \n  if(b<cnt[2]){\n    int cc=cnt[2]-b;\n    ll pp=mul(dp[na][b][c][d][z], cc);\n    Add( dp[na][b+1][c][d][z], pp );\n    Add( DP[na][b+1][c][d][z], mul(DP[na][b][c][d][z], 100*cc )    );\n    Add( DP[na][b+1][c][d][z], mul(mul(pp,cntinv[2]),sum[2]) );\n  }\n  if(c<cnt[3]){\n    int cc=cnt[3]-c;\n    ll pp=mul(dp[na][b][c][d][z], cc);\n    Add( dp[na][b][c+1][d][z], mul(dp[na][b][c][d][z], cc) );\n    Add( DP[na][b][c+1][d][z], mul(DP[na][b][c][d][z], 1000*cc )    );\n    Add( DP[na][b][c+1][d][z], mul(mul(pp,cntinv[3]),sum[3]) );\n  }\n  if(d<cnt[4]){\n    int cc=cnt[4]-d;\n    ll pp=mul(dp[na][b][c][d][z], cc);\n    Add( dp[na][b][c][d+1][z], mul(dp[na][b][c][d][z], cc) );\n    Add( DP[na][b][c][d+1][z], mul(DP[na][b][c][d][z], 10000*cc )    );\n    Add( DP[na][b][c][d+1][z], mul(mul(pp,cntinv[4]),sum[4]) );\n  }\n  \n  if(z<Z && a+b+c+d>0){\n    Add( dp[na][b][c][d][z+1], dp[na][b][c][d][z] );\n    Add( DP[na][b][c][d][z+1], mul(DP[na][b][c][d][z], 10 )    );\n  }\n}\n\nll solve(){\n  dp.resize(2);\n  for(int i=0;i<(int)dp.size();i++){\n    dp[i].resize(cnt[2]+1);\n    for(int j=0;j<(int)dp[i].size();j++){\n      dp[i][j].resize(cnt[3]+1);\n      for(int k=0;k<(int)dp[i][j].size();k++){\n        dp[i][j][k].resize(cnt[4]+1);\n        for(int l=0;l<(int)dp[i][j][k].size();l++){\n          dp[i][j][k][l].resize(2);\n        }\n      }\n    }\n  }\n  DP=dp;\n\n  dp[0][0][0][0][0]=1;\n\n  int ans=0;\n  \n  for(int a=0;a<=cnt[1];a++){\n    for(int b=0;b<=cnt[2];b++)\n      for(int c=0;c<=cnt[3];c++)\n        for(int d=0;d<=cnt[4];d++)\n          for(int z=0;z<=Z;z++){\n            update(a,b,c,d,z);\n            Add( ans, DP[a%2][b][c][d][z] );\n\n            dp[a%2][b][c][d][z]=0;\n            DP[a%2][b][c][d][z]=0;\n          }\n  }\n\n  return ans;\n}\n\nint countDisit(int x){\n  int res=0;\n  while(x){\n    res++;\n    x/=10;\n  }\n  return res;\n}\n\nint main(){\n  cin>>n;\n  \n  for(int i=0;i<n;i++){\n    cin>>a[i];\n    int D=countDisit(a[i]);\n    if(a[i]==0){\n      Z++;\n      continue;\n    }\n    cnt[D]++;\n    sum[D]+=a[i];\n  }\n\n  for(int i=1;i<=4;i++)\n    if(cnt[i]>0)\n      cntinv[i]=divi(1,cnt[i]);\n  cout<< solve() <<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n  \nusing namespace std;\n  \n\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n  \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void unique(vector<T>& c) { c.erase(unique(c.begin(), c.end()), c.end()); }\ntemplate <class T> void sort_unique(vector<T>& c) { sort(c); unique(c); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n  \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n \nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n  \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\n\nconst int M = 210 * 5;\nll fact[210];\nll combi[210][210];\nll ten_pow[M];\n\nvoid add(ll& a, ll b)\n{\n    a += b;\n    if (a >= mod)\n        a -= mod;\n}\nvector<vector<ll> > digits_dp(const vector<int>& digits)\n{\n    int n = digits.size();\n\n    static ll dp[210][M + 30];\n    CL(dp, 0);\n    dp[0][0] = 1;\n    for (int i = 0; i < n; ++i)\n        for (int j = i; j >= 0; --j)\n            for (int k = 5 * i; k >= 0; --k)\n                add(dp[j + 1][k + digits[i]], dp[j][k]);\n\n    vector<vector<ll> > res(n + 1, vector<ll>(M));\n    for (int i = 0; i <= n; ++i)\n        for (int j = 0; j < M; ++j)\n            res[i][j] = dp[i][j];\n    return res;\n}\nll gao(const vector<int>& a, const vector<int>& digits)\n{\n    int n = a.size();\n\n    ll pat[210] = {};\n    for (int i = 0; i <= n - 1; ++i)\n        for (int j = 0; j <= (n - 1) - i; ++j)\n            (pat[i] += (combi[(n - 1) - i][j] * fact[j] % mod) * fact[i]) %= mod;\n\n    ll res = 0;\n    for (int i = 0; i < n; ++i)\n    {\n        vector<int> d;\n        for (int j = 0; j < n; ++j)\n            if (i != j)\n                d.push_back(digits[j]);\n        vector<vector<ll> > d_pat = digits_dp(d);\n\n        for (int j = 0; j < n; ++j)\n        {\n            for (int k = 0; k < M; ++k)\n            {\n                ll p = pat[j] * d_pat[j][k];\n                (res += ((a[i] * ten_pow[k]) % mod) * p) %= mod;\n            }\n        }\n    }\n\n    return res;\n}\nint main()\n{\n    fact[0] = 1;\n    for (int i = 1; i < 210; ++i)\n        fact[i] = (fact[i - 1] * i) % mod;\n\n    for (int i = 0; i < 210; ++i)\n    {\n        combi[i][0] = 1;\n        for (int j = 1; j <= i; ++j)\n            combi[i][j] = (combi[i - 1][j] + combi[i - 1][j - 1]) % mod;\n    }\n\n    ten_pow[0] = 1;\n    for (int i = 1; i < M; ++i)\n        ten_pow[i] = (ten_pow[i - 1] * 10) % mod;\n\n    int n;\n    vector<int> a, d;\n    cin >> n;\n    for (int i = 0; i < n; ++i)\n    {\n        string s;\n        cin >> s;\n        d.push_back(s.size());\n        a.push_back(to_T<int>(s));\n    }\n\n    ll res = gao(a, d);\n    if (find(all(a), 0) != a.end())\n    {\n        vector<int> _a, _d;\n        for (int i = 0; i < n; ++i)\n        {\n            if (a[i] != 0)\n            {\n                _a.push_back(a[i]);\n                _d.push_back(d[i]);\n            }\n        }\n\n        ll sub = gao(_a, _d);\n        res = (res - sub + mod) % mod;\n    }\n\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nclass range {\n    struct Iterator {\n        int val, inc;\n        int operator*() {return val;}\n        bool operator!=(Iterator& rhs) {return val < rhs.val;}\n        void operator++() {val += inc;}\n    };\n    Iterator i, n;\n    public:\n    range(int e) : i({0, 1}), n({e, 1}) {}\n    range(int b, int e) : i({b, 1}), n({e, 1}) {}\n    range(int b, int e, int inc) : i({b, inc}), n({e, inc}) {}\n    Iterator& begin() {return i;}\n    Iterator& end() {return n;}\n};\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\nconst int MOD = 1e9 + 7;\nvoid add(int& x, int y) {\n    x += y;\n    if(x >= MOD) x-= MOD;\n}\nint solve(vector<int> a) {\n    int n = a.size();\n    vector<int> d(n);\n    REP(i, n) d[i] = to_string(a[i]).size();\n\n    int ans = 0;\n\n    const int P = 4 * n + 1;\n    int ways[802][202] = {};\n    ways[0][0] = 1;\n    REP(i, n){\n        int nways[802][202] = {};\n        REP(l, P) REP(k, i+1) {\n            add(nways[l][k], ways[l][k]);\n            if(l + d[i] < P) add(nways[l+d[i]][k+1], ways[l][k]);\n        }\n        memcpy(ways, nways, sizeof(ways));\n    }\n    // REP(l, P) REP(k, n+1) if(ways[l][k] > 0) {\n    //     cout << \"length: \" << l << endl;\n    //     cout << \"count: \" << k << endl;\n    //     cout << \"ways: \" << ways[l][k] << endl;\n    // }\n\n    REP(i, n){\n        int base10 = 1;\n        const int P = 4*(n-1) + 1;\n\n        int dp[802][202] = {};\n        REP(l, P) REP(k, n) {\n            dp[l][k] = ways[l][k];\n            if(l-d[i]>=0 && k-1 >= 0) {\n                dp[l][k] -= dp[l-d[i]][k-1];\n                if(dp[l][k] < 0) dp[l][k] += MOD;\n            }\n            // if(dp[l][k] > 0) {\n            //     cout << \"not use: \" << i << endl;\n            //     cout << \"length: \" << l << endl;\n            //     cout << \"count: \" << k << endl;\n            //     cout << \"ways: \" << dp[l][k] << endl;\n            // }\n        }\n        REP(l, P) REP(k, n) {\n            REP(j, k) dp[l][k] = (LL)(j+1) * dp[l][k] % MOD;\n        }\n\n\n        int dp2[802] = {};\n        REP(k, n) {\n            int rest = (n-1) - k;\n            LL K = 1;\n            REP(i, rest+1) {\n                REP(l, P) add(dp2[l], K * dp[l][k] % MOD);\n                K = K * (rest - i) % MOD;\n            }\n        }\n\n        REP(p, P) {\n            // if(dp2[p] > 0) {\n            //     cout << \"i: \" << i << endl;\n            //     cout << \"10^\" << p << endl;\n            //     cout << \"dp: \" << dp2[p] << endl;\n            // }\n\n            add(ans, (LL)dp2[p] * base10 % MOD * a[i] % MOD);\n            base10 = 10LL * base10 % MOD;\n        }\n    }\n    return ans;\n}\nint main(){\n    iostream_init();\n    int n;\n    while(cin >> n) {\n        vector<int> a(n);\n        REP(i, n) cin >> a[i];\n        sort(a.begin(), a.end());\n        int ans = solve(a);\n        if(a[0] == 0) {\n            vector<int> b;\n            REP(i, n-1) b.push_back(a[i+1]);\n            ans -= solve(b);\n            if(ans < 0) ans += MOD;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n/* vim:set foldmethod=marker: */"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntemplate<int M>\nclass Cyclic {\n\tusing ll = long long;\n\tint n;\n\tstatic ll inv(ll a, ll p) { return (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p); }\npublic:\n\tCyclic() : n(0) { ; }\n\tCyclic(int m) : n(m) {\n\t\tif (n >= M) n %= M;\n\t\telse if (n < 0) n = (n % M + M) % M;\n\t}\n\toperator int() const { return n; }\n\tbool operator==(const Cyclic &a) const { return n == a.n; }\n\tCyclic operator+=(const Cyclic &a) { n += a.n; if (n >= M) n -= M; return *this; }\n\tCyclic operator-=(const Cyclic &a) { n -= a.n; if (n < 0) n += M; return *this; }\n\tCyclic operator*=(const Cyclic &a) { n = (ll(n) * a.n) % M; return *this; }\n\tCyclic operator+(const Cyclic &a) const { Cyclic res = *this; return res += a; }\n\tCyclic operator-(const Cyclic &a) const { Cyclic res = *this; return res -= a; }\n\tCyclic operator*(const Cyclic &a) const { Cyclic res = *this; return res *= a; }\n\tCyclic operator/(const Cyclic &a) const { return *this * Cyclic<M>(inv(a, M)); }\n\tCyclic operator^(int n) const {\n\t\tif (n == 0) return Cyclic(1);\n\t\tconst Cyclic a = *this;\n\t\tCyclic res = (a * a) ^ (n / 2);\n\t\treturn n % 2 ? res * a : res;\n\t}\n};\n\ntemplate<int M> Cyclic<M> fact(int n, bool sw = true) {\n\tstatic vector<Cyclic<M>> v1 = { 1 }, v2 = { 1 };\n\tif (n >= (int)v1.size()) {\n\t\tconst int from = v1.size(), to = n + 1024;\n\t\tv1.reserve(to);\n\t\tv2.reserve(to);\n\t\tfor (int i = from; i < to; ++i) {\n\t\t\tv1.push_back(v1.back() * Cyclic<M>(i));\n\t\t\tv2.push_back(v2.back() / Cyclic<M>(i));\n\t\t}\n\t}\n\treturn sw ? v1[n] : v2[n];\n}\n\ntemplate<int M> Cyclic<M> comb(int a, int b) {\n\treturn fact<M>(a, true) * fact<M>(b, false) * fact<M>(a - b, false);\n}\n\ntemplate<int M> Cyclic<M> perm(int a, int b) {\n\treturn fact<M>(a, true) * fact<M>(a - b, false);\n}\n\nconst int mod = 1000000007;\nusing Mod = Cyclic<mod>;\n\nMod pow(Mod x, int n)\n{\n\tMod res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1) res = res * x;\n\t\tx = x*x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nint n;\nvi a, len(6);\nMod dp[11][11][888][222];\n\nMod rec(int sz, int i, int keta, int used, const vi& v)\n{\n\tif (dp[sz][i][keta][used] >= 0) return dp[sz][i][keta][used];\n\tMod res = 0;\n\tif (i == 5)\n\t{\n\t\tif (keta == 0)\n\t\t{\n\t\t\tMod tmp = fact<mod>(used);\n\t\t\tint rem = n - 1 - used;\n\t\t\tREP(j, rem + 1)\n\t\t\t{\n\t\t\t\tres += tmp * perm<mod>(rem, j);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tREP(j, v[i] + 1)\n\t\t{\n\t\t\tif (keta < i * j) break;\n\t\t\tres += rec(sz, i + 1, keta - i*j, used + j, v) * comb<mod>(v[i], j);\n\t\t}\n\t}\n\treturn dp[sz][i][keta][used] = res;\n}\n\nMod calc(int sz, int right)\n{\n\tvi v = len;\n\tif (v[sz] == 0) return 0;\n\tv[sz]--;\n\tMod res = rec(sz, 1, right, 0, v);\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tMS(dp, -1);\n\tcin >> n;\n\ta.resize(n);\n\tREP(i, n)\n\t{\n\t\tcin >> a[i];\n\t\tif (a[i] == 0) len[0]++;\n\t\tlen[to_string(a[i]).size()]++;\n\t}\n\tMod ans = 0;\n\tREP(i, n)\n\t{\n\t\tstring s = to_string(a[i]);\n\t\tREP(j, 801)\n\t\t{\n\t\t\tMod cal = calc(s.size(), j);\n\t\t\tREP(k, s.size())\n\t\t\t{\n\t\t\t\tMod tmp = (s[k] - '0') * pow(Mod(10), j + s.size() - k - 1) * cal;\n\t\t\t\tans += tmp;\n\t\t\t}\n\t\t\t//cout << j <<\" \"<< cal <<\" \"<<ans << endl;\n\t\t}\n\t}\n\n\tMod zero = 0;\n\tMS(dp, -1);\n\tn--;\n\tlen[1]--;\n\tREP(i, n + 1)\n\t{\n\t\tstring s = to_string(a[i]);\n\t\tREP(j, 801)\n\t\t{\n\t\t\tMod cal = calc(s.size(), j);\n\t\t\tREP(k, s.size())\n\t\t\t{\n\t\t\t\tzero += (s[k] - '0') * pow(Mod(10), j + s.size() - k - 1) * cal;\n\t\t\t}\n\t\t}\n\t}\n\tzero *= len[0];\n\tcout << ans - zero << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <numeric>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< (int)(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define iter(c) __typeof((c).begin())\n#define pb(e) push_back(e)\n#define foreach(c, i) for(iter(c) i = (c).begin(); i != c.end(); ++i)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst ll mod  = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nconst int maxn = 210;\nconst int sz = 1000;\nll p10[sz];\nll comb[maxn][maxn];\nll perm[maxn];\nll pattern[maxn];\nmap<vector<ll>, ll> memo;\n\nint digits(int n){\n  int res = 0;\n  do{ \n    res++;\n    n /= 10;\n  }while(n > 0);\n  return res;\n}\n\nll recur(vector<ll> num){\n  if(*max_element(num.begin(), num.end()) == 0) return 1;\n  if(memo.find(num) != memo.end()) return memo[num];\n  \n  ll &res = memo[num] = 0;\n  rep(i, num.size()){\n    if(num[i] > 0){\n      num[i]--;\n      res = (res + recur(num) * (num[i] + 1)) % mod;\n      num[i]++;\n    }\n  }\n  return res;\n} \n\nll pattern_num(const vector<ll> &rest){\n  int n = accumulate(rest.begin(), rest.end(), 0);\n  return pattern[n];\n}\n\nll dfs(vector<ll> cnt, const vector<ll> &num, ll sum, int c){\n  ll res = 0;\n  if(c == (int)num.size()){\n    int len = 0;\n    vector<ll> rest(cnt.size(), 0);\n    rep(i, cnt.size()){\n      rest[i] = num[i] - cnt[i];\n      len += cnt[i] * (i + 1);\n    }\n    \n    ll p = recur(cnt) * pattern_num(rest) % mod;\n    rep(i, cnt.size()) p = (p * comb[num[i]][cnt[i]]) % mod;\n    p = (p * p10[len]) % mod;\n    return sum * p % mod;\n  }\n  \n  rep(i, num[c] + 1){\n    cnt[c] = i;\n    res = (res + dfs(cnt, num, sum, c + 1)) % mod;\n  }\n  return res;\n}\n\nll calc(vector<int> v){\n  vector<ll> sum(4, 0), cnt(4, 0), num(4, 0);\n  \n  rep(i, v.size()){\n    sum[digits(v[i])-1] += v[i];\n    num[digits(v[i])-1]++;\n  }\n  memo.clear();\n  ll res = 0;\n  rep(i, num.size()){\n    num[i]--;\n    res = (res + dfs(cnt, num, sum[i], 0)) % mod;\n    num[i]++;\n  }\n  return res;\n}\n\nvoid init(){\n  p10[0] = 1;\n  rep(i, sz - 1) p10[i+1] = p10[i] * 10 % mod;\n  rep(n, maxn)rep(r, maxn){\n    if(n < r) comb[n][r] = 0;\n    else if(r == 0) comb[n][r] = 1;\n    else comb[n][r] = (comb[n-1][r] + comb[n-1][r-1]) % mod;\n  }\n\n  perm[0] = 1;\n  rep(i, maxn - 1) perm[i+1] = perm[i] * (i + 1) % mod;\n  rep(i, maxn){\n    rep(j, i + 1){\n      pattern[i] = (pattern[i] + comb[i][j] * perm[j]) % mod;\n    }\n  }\n}\n\nint main(){\n  int n, a;\n  ll res = 0;\n  vector<int> v;\n  init();\n  cin >> n;\n  rep(i, n){\n    cin >> a;\n    v.push_back(a);\n  }\n  sort(v.begin(), v.end());\n  res = calc(v);\n  if(v[0] == 0) res = (res + mod - calc(vector<int>(v.begin() + 1, v.end()))) % mod;\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define F first\n#define S second\nconst long long MOD = 1e9+7;\ntypedef vector<int> vint;\ntypedef vector<vint> vvint;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n// Mod int\n// const int MOD = 1000000007;\nstruct mint{\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%MOD+MOD)%MOD){}\n  mint operator+=(const mint& a){ if((x+=a.x)>=MOD) x-=MOD; return *this;}\n  mint operator-=(const mint& a){ if((x+=MOD-a.x)>=MOD) x-=MOD; return *this;}\n  mint operator*=(const mint& a){ (x*=a.x)%=MOD; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nmint powmod(mint x,ll y){\n\tmint a(1);\n\twhile(y){\n\t\tif(y&1) a=a*x;\n\t\tx=x*x;\n\t\ty/=2;\n\t}\n\treturn a;\n}\nvector<vector<mint>> dp[5];\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<pii> v(n);\n\tbool zero=false;\n\trep(i,n) cin>>v[i].F;\n\trep(i,n){\n\t\tif(v[i].F==0){\n\t\t\tzero=true;\n\t\t\tv[i].S=1;\n\t\t}\n\t\telse{\n\t\t\tint cnt=0;\n\t\t\tint t=v[i].F;\n\t\t\twhile(t){\n\t\t\t\tt/=10;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tv[i].S=cnt;\n\t\t}\n\t}\n\tint cc[5]={};\n\trep(i,n){\n\t\tcc[v[i].S]++;\n\t}\n\tmint ans[2];\n\trep(i,2) ans[i].x=0;\n\tvector<mint> fun(210,mint(0LL));\n\tvector<mint> fun_sum(210,mint(0LL));\n\tfun[0]+=mint(1);\n\treep(i,1,210){\n\t\tfun[i]=mint(i)*fun[i-1];\n\t}\n\tmint combi[210][210];\n\trep(i,210) rep(j,210) combi[i][j].x=0LL;\n\trep(i,210){\n\t\tcombi[i][0]=combi[i][i]=mint(1);\n\t\treep(j,1,i){\n\t\t\tcombi[i][j]=combi[i-1][j]+combi[i-1][j-1];\n\t\t}\n\t}\n\trep(i,210){\n\t\tif(i==0){\n\t\t\tfun_sum[0]=mint(1);\n\t\t\tcontinue;\n\t\t}\n\t\trep(j,i+1){\n\t\t\tfun_sum[i]+=combi[i][j]*fun[j];\n\t\t}\n\t}\n\trep(o,2){\n\t\tif(o){\n\t\t\tif(!zero) continue;\n\t\t\telse cc[1]--;\n\t\t}\n\t\trep(i,5) dp[i]=vector<vector<mint>>(1000,vector<mint>(210));\n\t\trep(i,5){\n\t\t\tdp[i][0][0].x=1;\n\t\t\tif(!cc[i]) continue;\n\t\t\tcc[i]--;\n\t\t\trep(j,5){\n\t\t\t\trep(k,cc[j]){\n\t\t\t\t\tvector<vector<mint>> tmp=dp[i];\n\t\t\t\t\tfor(int p=999;p>=0;p--){\n\t\t\t\t\t\tfor(int q=209;q>=0;q--){\n\t\t\t\t\t\t\tif(!tmp[p][q].x) continue;\n\t\t\t\t\t\t\tdp[i][p+j][q+1]+=tmp[p][q];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcc[i]++;\n\t\t}\n\t\trep(i,n){\n\t\t\t// cout<<ans.x<<endl;\n\t\t\trep(j,1000){\n\t\t\t\tll t=0;\n\t\t\t\trep(k,210){\n\t\t\t\t\tt+=(dp[v[i].S][j][k]*fun[k]*fun_sum[n-o-k-1]).x;\n\t\t\t\t}\n\t\t\t\tans[o]+=mint(v[i].F)*powmod(mint(10),j)*mint(t);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<(ans[0]-ans[1]).x<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\n#define mod 1000000007\n\nusing namespace std;\n\n\n// ------ 0. Variables, Functions ------ //\n\nint n;\n\nvector<int> fact;\nvector<int> power2;\nvector<int> power10;\n\nint digit(int n)\n{\n\tif (n < 10) return 1;\n\n\treturn digit(n / 10) + 1;\n}\n\nint solve(vector<int> a)\n{\n\tvector<vector<int> > d(5, vector<int>(2, 0));\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\td[digit(a[i])][0] += 1;\n\t\td[digit(a[i])][1] += a[i];\n\t}\n\n\tint ret = 0;\n\n\tfor (int i = 1; i <= 4; i++)\n\t{\n\t\tvector<vector<vector<int> > > dp(5, vector<vector<int> >(n, vector<int>(n * 4, 0)));\n\n\t\tdp[0][0][0] = 1;\n\n\t\tif (d[i][0] != 0)\n\t\t{\n\t\t\td[i][0]--;\n\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t{\n\t\t\t\t\tfor (int l = 0; l < n * 4; l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dp[j][k][l] != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int m = 0; m <= d[j + 1][0]; m++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdp[j + 1][k + m][l + (j + 1) * m]++;\n\t\t\t\t\t\t\t\tdp[j + 1][k + m][l + (j + 1) * m] %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\td[i][0]++;\n\n\t\t\tint res = 0;\n\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < n * 4; k++)\n\t\t\t\t{\n\t\t\t\t\tres = (res + 1LL * dp[4][j][k] * fact[j] % mod * power10[k] % mod * power2[n - j - 1] % mod) % mod;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = (ret + 1LL * res * d[i][1]) % mod;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\t// ------ 1. init ------ //\n\n\tfact.push_back(1);\n\n\tfor (int i = 1; i <= 200; i++) fact.push_back(1LL * fact[i - 1] * i % mod);\n\n\tpower2.push_back(1);\n\n\tfor (int i = 1; i <= 200; i++) power2.push_back(1LL * power2[i - 1] * 2 % mod);\n\n\tpower10.push_back(1);\n\n\tfor (int i = 1; i <= 800; i++) power10.push_back(1LL * power10[i - 1] * 10 % mod);\n\n\n\t// ------ 2. Input ------ //\n\n\tscanf(\"%d\", &n);\n\n\tvector<int> a(n);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tprintf(\"%d\\n\", solve(a));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n  \nusing namespace std;\n  \n\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n  \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void unique(vector<T>& c) { c.erase(unique(c.begin(), c.end()), c.end()); }\ntemplate <class T> void sort_unique(vector<T>& c) { sort(c); unique(c); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n  \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n \nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n  \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\n\nconst int M = 210 * 5;\nll fact[210];\nll combi[210][210];\nll ten_pow[M];\n\nvoid add(ll& a, ll b)\n{\n    a += b;\n    if (a >= mod)\n        a -= mod;\n}\nvector<vector<ll> > digits_dp(const vector<int>& digits)\n{\n    int n = digits.size();\n\n    static ll dp[210][M + 30];\n    CL(dp, 0);\n    dp[0][0] = 1;\n    for (int i = 0; i < n; ++i)\n        for (int j = i; j >= 0; --j)\n            for (int k = 5 * i; k >= 0; --k)\n                add(dp[j + 1][k + digits[i]], dp[j][k]);\n\n    vector<vector<ll> > res(n + 1, vector<ll>(M));\n    for (int i = 0; i <= n; ++i)\n        for (int j = 0; j < M; ++j)\n            res[i][j] = dp[i][j];\n    return res;\n}\nll gao(const vector<int>& a, const vector<int>& digits)\n{\n    int n = a.size();\n\n    ll res = 0;\n    for (int i = 0; i < n; ++i)\n    {\n        vector<int> d;\n        for (int j = 0; j < n; ++j)\n            if (i != j)\n                d.push_back(digits[j]);\n        vector<vector<ll> > d_pat = digits_dp(d);\n\n        for (int j = 0; j < n; ++j)\n        {\n            for (int k = 0; k < M; ++k)\n            {\n                ll pat = 0;\n                for (int u = 0; u <= (n - 1) - j; ++u)\n                    (pat += (combi[(n - 1) - j][u] * fact[u] % mod) * fact[j]) %= mod;\n                (pat *= d_pat[j][k]) %= mod;\n\n                (res += ((a[i] * ten_pow[k]) % mod) * pat) %= mod;\n            }\n        }\n    }\n\n    return res;\n}\nint main()\n{\n    fact[0] = 1;\n    for (int i = 1; i < 210; ++i)\n        fact[i] = (fact[i - 1] * i) % mod;\n\n    for (int i = 0; i < 210; ++i)\n    {\n        combi[i][0] = 1;\n        for (int j = 1; j <= i; ++j)\n            combi[i][j] = (combi[i - 1][j] + combi[i - 1][j - 1]) % mod;\n    }\n\n    ten_pow[0] = 1;\n    for (int i = 1; i < M; ++i)\n        ten_pow[i] = (ten_pow[i - 1] * 10) % mod;\n\n\n    int n;\n    vector<int> a, d;\n    cin >> n;\n    for (int i = 0; i < n; ++i)\n    {\n        string s;\n        cin >> s;\n        d.push_back(s.size());\n        a.push_back(to_T<int>(s));\n    }\n\n    ll res = gao(a, d);\n    if (find(all(a), 0) != a.end())\n    {\n        vector<int> _a, _d;\n        for (int i = 0; i < n; ++i)\n        {\n            if (a[i] != 0)\n            {\n                _a.push_back(a[i]);\n                _d.push_back(d[i]);\n            }\n        }\n\n        ll sub = gao(_a, _d);\n        res = (res - sub + mod) % mod;\n    }\n\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint M=1000000007;\n\nint f(vector<int> v,int s){\n  int dp[823][223]={};\n  dp[0][0]=1;\n  for(int i=0;i<4;i++){\n    for(int j=0;j<v[i];j++){\n      for(int k=800;k>=i+1;k--){\n\tfor(int l=200;l>0;l--){\n\t  dp[k][l]=(dp[k][l]+dp[k-(i+1)][l-1]*1LL*l)%M;\n\t}\n      }\n    }\n  }\n  int head[223]={1};\n  for(int i=1;i<=200;i++){\n    head[i]=(head[i-1]*1LL*i+1)%M;\n  }\n  int ans=0;\n  int n=v[0]+v[1]+v[2]+v[3];\n  int t=1;\n  for(int i=0;i<=800;i++,t=(t*10)%M){\n    for(int j=0;j<=n;j++){\n      ans=(ans+dp[i][j]*1LL*head[n-j]%M*s%M*t%M)%M;\n    }\n  }\n  return ans;\n}\n\nint solve(vector<int> a){\n  int nd[4]={};\n  int ds[4]={};\n  for(auto e:a){\n    int x=(e>=10)+(e>=100)+(e>=1000);\n    nd[x]++;\n    ds[x]=(ds[x]+e)%M;\n  }\n  int r=0;\n  r=(r+(nd[0]?f({nd[0]-1,nd[1],nd[2],nd[3]},ds[0]):0))%M;\n  r=(r+(nd[1]?f({nd[0],nd[1]-1,nd[2],nd[3]},ds[1]):0))%M;\n  r=(r+(nd[2]?f({nd[0],nd[1],nd[2]-1,nd[3]},ds[2]):0))%M;\n  r=(r+(nd[3]?f({nd[0],nd[1],nd[2],nd[3]-1},ds[3]):0))%M;\n  return r;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  vector<int> a(n);\n  vector<int> nz;\n  for(int i=0;i<n;i++){\n    cin>>a[i];\n    if(a[i]){\n      nz.push_back(a[i]);\n    }\n  }\n  int ans=solve(a);\n  if(nz.size()<n){\n    ans=(ans-solve(nz)+M)%M;\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n#define MOD 1000000007 // prime\nconst int SIZE = 100100;\nll inv[SIZE+10],fac[SIZE+10],facinv[SIZE+10];\nll Pow[1010],kai[210];\nll val[210];\nll nCr(int n,int r)\n{\n\tif(n<r)return -1;\n\tif(n<0||r<0)return -1;\n\treturn ((fac[n]*facinv[r]%MOD)*facinv[n-r])%MOD;\n}\nll func(int n)\n{\n\tll ret = 0ll;\n\tfor(int i=0;i<=n;i++)ret = (ret+(nCr(n,i)*kai[i])%MOD)%MOD;\n\treturn ret;\n}\nvoid init()\n{\n\tfac[0]=1ll;\n\tfor(int i=1;i<=SIZE;i++)fac[i]=(fac[i-1]*i)%MOD;\n\tinv[1]=1ll;\n\tfor(int i=2;i<=SIZE;i++)inv[i]=((-(MOD/i)*inv[MOD%i])%MOD+MOD)%MOD;\n\tfacinv[0]=1ll;\n\tfor(int i=1;i<=SIZE;i++)facinv[i]=(facinv[i-1]*inv[i])%MOD;\n\tPow[0]=1ll;\n\tfor(int i=0;i<1000;i++)Pow[i+1]=(Pow[i]*10ll)%MOD;\n\tkai[0]=1ll;\n\tfor(int i=1;i<=200;i++)kai[i]=(kai[i-1]*i)%MOD;\n\tfor(int i=0;i<=200;i++)val[i]=func(i);\n}\nint cnt_digit(ll x)\n{\n\tif(x==0ll)return 1;\n\tint ret = 0;\n\twhile(x){ret++;x/=10ll;}\n\treturn ret;\n}\nint dp[210][1010];\nint n;\nll a[210];\nint dig[210];\nll digit_sum[5];\nint del[5];\nint zero=-1;\nint N;\nvoid culc_dp(int unuse)\n{\n\tmemset(dp,0,sizeof(dp));\n\tdp[0][0]=1;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tif(i==unuse)continue;\n\t\tfor(int j=i;j>=0;j--)\n\t\t{\n\t\t\tfor(int k=0;k<=j*4;k++)\n\t\t\t{\n\t\t\t\tif(dp[j][k]==0)continue;\n\t\t\t\tdp[j+1][k+dig[i]]+=dp[j][k];\n\t\t\t}\n\t\t}\n\t}\n}\nll solve()\n{\n\tll ans = 0ll;\n\tfor(int d=1;d<=4;d++)\n\t{\n\t\tif(del[d]==-1)continue;\n\t\tculc_dp(del[d]);\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=4*N;j++)\n\t\t\t{\n\t\t\t\tif(dp[i][j]==0)continue;\n\t\t\t\tans += (((((((val[N-i-1]*kai[i])%MOD)*digit_sum[d])%MOD)*dp[i][j])%MOD)*Pow[j])%MOD;\n\t\t\t\tans %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tinit();\n\tmemset(del,-1,sizeof(del));\n\tscanf(\"%d\",&n);\n\tN=n;\n\tfor(int i=0;i<n;i++)scanf(\"%lld\",&a[i]);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tdig[i]=cnt_digit(a[i]);\n\t\tdigit_sum[dig[i]]+=a[i];\n\t\tdel[dig[i]]=i;\n\t\tif(a[i]==0)zero=i;\n\t}\n\tll ans = solve();\n\tif(zero!=-1)\n\t{\n\t\tswap(a[zero],a[n-1]);\n\t\tN--;\n\t\tmemset(del,-1,sizeof(del));\n\t\tmemset(digit_sum,0,sizeof(digit_sum));\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tdig[i]=cnt_digit(a[i]);\n\t\t\tdigit_sum[dig[i]]+=a[i];\n\t\t\tdel[dig[i]]=i;\n\t\t}\n\t\tans -= solve();\n\t\tans = ((ans%MOD)+MOD)%MOD;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n#define MOD 1000000007 // prime\nconst int SIZE = 100100;\nll inv[SIZE+10],fac[SIZE+10],facinv[SIZE+10];\nll Pow[1010],kai[210];\nll val[210];\nll nCr(int n,int r)\n{\n\tif(n<r)return -1;\n\tif(n<0||r<0)return -1;\n\treturn ((fac[n]*facinv[r]%MOD)*facinv[n-r])%MOD;\n}\nll func(int n)\n{\n\tll ret = 0ll;\n\tfor(int i=0;i<=n;i++)ret = (ret+(nCr(n,i)*kai[i])%MOD)%MOD;\n\treturn ret;\n}\nvoid init()\n{\n\tfac[0]=1ll;\n\tfor(int i=1;i<=SIZE;i++)fac[i]=(fac[i-1]*i)%MOD;\n\tinv[1]=1ll;\n\tfor(int i=2;i<=SIZE;i++)inv[i]=((-(MOD/i)*inv[MOD%i])%MOD+MOD)%MOD;\n\tfacinv[0]=1ll;\n\tfor(int i=1;i<=SIZE;i++)facinv[i]=(facinv[i-1]*inv[i])%MOD;\n\tPow[0]=1ll;\n\tfor(int i=0;i<1000;i++)Pow[i+1]=(Pow[i]*10ll)%MOD;\n\tkai[0]=1ll;\n\tfor(int i=1;i<=200;i++)kai[i]=(kai[i-1]*i)%MOD;\n\tfor(int i=0;i<=200;i++)val[i]=func(i);\n}\nint cnt_digit(ll x)\n{\n\tif(x==0ll)return 1;\n\tint ret = 0;\n\twhile(x){ret++;x/=10ll;}\n\treturn ret;\n}\nint dp[210][1010];\nint n;\nll a[210];\nint dig[210];\nint digit_sum[5];\nint del[5];\nint zero=-1;\nint N;\nvoid culc_dp(int unuse)\n{\n\tmemset(dp,0,sizeof(dp));\n\tdp[0][0]=1;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tif(i==unuse)continue;\n\t\tfor(int j=i;j>=0;j--)\n\t\t{\n\t\t\tfor(int k=0;k<=j*4;k++)\n\t\t\t{\n\t\t\t\tif(dp[j][k]==0)continue;\n\t\t\t\tdp[j+1][k+dig[i]]+=dp[j][k];\n\t\t\t}\n\t\t}\n\t}\n}\nll solve()\n{\n\tll ans = 0ll;\n\tfor(int d=1;d<=4;d++)\n\t{\n\t\tif(del[d]==-1)continue;\n\t\tculc_dp(del[d]);\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=4*N;j++)\n\t\t\t{\n\t\t\t\tif(dp[i][j]==0)continue;\n\t\t\t\tans += (((((((val[N-i-1]*kai[i])%MOD)*digit_sum[d])%MOD)*dp[i][j])%MOD)*Pow[j])%MOD;\n\t\t\t\tans %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tinit();\n\tmemset(del,-1,sizeof(del));\n\tscanf(\"%d\",&n);\n\tN=n;\n\tfor(int i=0;i<n;i++)scanf(\"%lld\",&a[i]);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tdig[i]=cnt_digit(a[i]);\n\t\tdigit_sum[dig[i]]+=a[i];\n\t\tdel[dig[i]]=i;\n\t\tif(a[i]==0)zero=i;\n\t}\n\tll ans = solve();\n\tif(zero!=-1)swap(a[zero],a[n-1]);\n\tN--;\n\tmemset(del,-1,sizeof(del));\n\tmemset(digit_sum,0,sizeof(digit_sum));\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tdig[i]=cnt_digit(a[i]);\n\t\tdigit_sum[dig[i]]+=a[i];\n\t\tdel[dig[i]]=i;\n\t}\n\tans -= solve();\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint n;\nvector<ll> a,d;\nint dp[2][801][201];\nint dp2[801][201];\nll fac[202],pow10[1000],fsum[202];\n\nll solve(){\n  int crt=0,nxt=1;\n  memset(dp,0,sizeof(dp));\n  dp[crt][0][0]=1;\n  n=a.size();\n  rep(i,n){\n    memset(dp[nxt],0,sizeof(dp[nxt]));\n    rep(j,801){\n      rep(k,201){\n        if(j+d[i]<=800&&k+1<=200)(dp[nxt][j+d[i]][k+1]+=dp[crt][j][k])%=mod;\n        (dp[nxt][j][k]+=dp[crt][j][k])%=mod;\n      }\n    }\n    swap(crt,nxt);\n  }\n\n  ll res=0;\n  rep(i,n){\n    memset(dp2,0,sizeof(dp2));\n    rep(j,801){\n      rep(k,201){\n        if(j-d[i]>=0&&k>=1) dp2[j][k]=(dp[crt][j][k]-dp2[j-d[i]][k-1]+mod)%mod;\n        else dp2[j][k]=dp[crt][j][k];\n        if(n-1-k>=0)(res+=((((a[i]*pow10[j])%mod)*fac[k]%mod)*dp2[j][k]%mod)*fsum[n-1-k]%mod)%=mod;\n      }\n    }\n  }\n\n  return res;\n}\n\nint main(){\n  fac[0]=fac[1]=1;\n  repl(i,1,200)fac[i+1]=fac[i]*(i+1)%mod;\n  rep(i,201){\n    ll p=1;\n    rep(j,i+1){\n      (fsum[i]+=p)%=mod;\n      (p*=i-j)%=mod;\n    }\n  }\n  pow10[0]=1;\n  rep(i,800)pow10[i+1]=pow10[i]*10%mod;\n\n  cin>>n;\n  rep(i,n){\n    ll aa;\n    cin>>aa;\n    a.push_back(aa);\n  }\n  sort(all(a)); reverse(all(a));\n  rep(i,n){\n    d.push_back(to_string(a[i]).size());\n  }\n  if(a[n-1]==0){\n    ll resa=solve();\n    a.pop_back(); d.pop_back();\n    ll resb=solve();\n    cout<<(resa-resb+mod)%mod<<endl;\n  }else{\n    cout<<solve()<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\n\nint power[1000];\n\nint N;\nint sum[5],cnt[5];\n\nint table[205][1005];\nint table2[205][205];\nint C[500][500];\nint F[500];\n\nint calc(){\n    memset(table,0,sizeof(table));\n    rep(i1,cnt[1]+1){\n        rep(i2,cnt[2]+1){\n            rep(i3,cnt[3]+1){\n                rep(i4,cnt[4]+1){\n                    int t=C[cnt[1]][i1]*C[cnt[2]][i2]%mod*C[cnt[3]][i3]%mod*C[cnt[4]][i4]%mod;\n                    table[i1+i2+i3+i4][i1+i2*2+i3*3+i4*4]=(table[i1+i2+i3+i4][i1+i2*2+i3*3+i4*4]+t)%mod;\n                }\n            }\n        }\n    }\n\n    int ret=0;\n    for(int z=0;z<=cnt[0];z++){\n        for(int c=0;c<N-cnt[0];c++){\n            for(int s=0;s<N*4;s++){\n                int t=table[c][s]*C[cnt[0]][z]%mod;\n                t=t*F[c+z]%mod;\n                int lc=N-cnt[0]-1-c;\n                int lz=cnt[0]-z;\n                t=t*table2[lc][lz]%mod;\n                ret=(ret+t*power[s+z])%mod;\n            }\n        }\n    }\n\n    return ret;\n}\n\nsigned main(){\n    power[0]=1;\n    for(int i=1;i<1000;i++)power[i]=power[i-1]*10%mod;\n    C[0][0]=1;\n    for(int i=1;i<500;i++){\n        C[i][0]=C[i][i]=1;\n        for(int j=1;j<i;j++)C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n    }\n    F[0]=1;\n    for(int i=1;i<500;i++)F[i]=F[i-1]*i%mod;\n\n    for(int i=0;i<=200;i++){\n        for(int j=0;j<=200;j++){\n            table2[i][j]=1;\n            if(i){\n                int s=i+j-1;\n                for(int k=0;k<=s;k++){\n                    int t=C[s][k]*F[k]%mod;\n                    t=t*i%mod;\n                    table2[i][j]=(table2[i][j]+t)%mod;\n                }\n            }\n        }\n    }\n\n    cin>>N;\n    rep(i,N){\n        int a;\n        cin>>a;\n        if(a==0){\n            cnt[0]++;\n        }\n        else{\n            stringstream ss;\n            ss<<a;\n            int d=ss.str().size();\n            sum[d]+=a;\n            cnt[d]++;\n        }\n    }\n\n    int ans=0;\n    for(int i=1;i<5;i++){\n        if(cnt[i]==0)continue;\n        cnt[i]--;\n        int tmp=calc();\n        cnt[i]++;\n        ans=(ans+tmp*sum[i])%mod;\n    }\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename Ostream,typename Container>\nOstream& operator<<(Ostream& os,const Container& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nll solve_naive(vi as)\n{\n\tint n=as.size();\n\tll sum=0,zero=0;\n\trepi(i,1,1<<n){\n\t\tvi is;\n\t\trep(j,n) if(i>>j&1) is.push_back(j);\n\t\tdo{\n\t\t\tstring s;\n\t\t\tfor(int i:is) s+=to_string(as[i]);\n\t\t\tll x=0;\n\t\t\tfor(char c:s) (x=x*10+c-'0')%=MOD;\n\t\t\t(sum+=x)%=MOD;\n\t\t\t//dump(x);\n\t\t\tif(s[0]=='0') (zero+=x)%=MOD;\n\t\t}while(next_permutation(all(is)));\n\t}\n\tdump(mp(sum,zero));\n\treturn (sum-zero+MOD)%MOD;\n}\n\nint ncr(int n,int r)\n{\n\tstatic int memo[300][300];\n\tif(memo[n][r]) return memo[n][r];\n\tif(r==0 || r==n) return 1;\n\treturn memo[n][r]=(ncr(n-1,r-1)+ncr(n-1,r))%MOD;\n}\n\nint solve(vi as)\n{\n\tvi tinvs(1000,1); // tinvs[i]=10^i mod m\n\trepi(i,1,tinvs.size()) tinvs[i]=(ll)tinvs[i-1]*10%MOD;\n\tvi finvs(200,1); // finvs[i]=i! mod m\n\trepi(i,1,finvs.size()) finvs[i]=(ll)finvs[i-1]*i%MOD;\n\t\n\tint n=as.size();\n\tvi ls(n);\n\trep(i,n){\n\t\tif(as[i]==0) ls[i]=1;\n\t\tfor(int x=as[i];x;x/=10) ls[i]++;\n\t}\n\tarray<int,5> hist={{}};\n\trep(i,n) hist[ls[i]]++;\n\t\n\tll res=0;\n\trep(c1,hist[1]+1) rep(c2,hist[2]+1) rep(c3,hist[3]+1) rep(c4,hist[4]+1){\n\t\tarray<int,5> uses={-1,c1,c2,c3,c4};\n\t\tint locnt=0,lolen=0;\n\t\trepi(len,1,5) locnt+=uses[len],lolen+=len*uses[len];\n\t\trepi(len,1,5) if(uses[len]<hist[len]){\n\t\t\thist[len]--;\n\t\t\tll lopat=finvs[c1+c2+c3+c4];\n\t\t\trepi(j,1,5) (lopat*=ncr(hist[j],uses[j]))%=MOD;\n\t\t\thist[len]++;\n\t\t\tll hipat=0;\n\t\t\trep(j,n-locnt) (hipat+=(ll)ncr(n-locnt-1,j)*finvs[j]%MOD)%=MOD;\n\t\t\trep(j,n) if(ls[j]==len){\n\t\t\t\tll val=(ll)as[j]*tinvs[lolen]%MOD*lopat%MOD*hipat%MOD;\n\t\t\t\t(res+=val)%=MOD;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvi as(n);\n\t\trep(i,n) cin>>as[i];\n\t\t\n\t\tll res=solve(as);\n\t\tif(count(all(as),0)){\n\t\t\tas.erase(find(all(as),0));\n\t\t\tll tmp=solve(as);\n\t\t\tres=(res-tmp+MOD)%MOD;\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VEC;\ntypedef vector<VEC> MAT;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define EPS 1e-8\n#define MOD 1000000007\n\nint a[222];\nLL s[4];\nLL cnt[4];\nLL fact[222];\nLL invfact[222];\nLL powten[1000];\nLL f[222];\n\nLL extgcd(LL a, LL b, LL &x, LL &y){\n\tLL d = a;\n\tif(b){\n\t\td = extgcd(b, a % b, y, x);\n\t\ty -= a/b * x;\n\t}\n\telse x = 1, y = 0;\n\treturn d;\n}\n\nLL mod_inverse(LL a, LL m){\n\tLL x, y;\n\textgcd(a, m, x, y);\n\treturn (m + x%m) % m;\n}\n\ninline LL P(int n, int r){\n\tif(n<=0)return 0LL;\n\treturn (fact[n]*invfact[n-r])%MOD;\n}\n\ninline LL C(int n, int r){\n\tif(n<0)return 0LL;\n\treturn (P(n,r)*invfact[r])%MOD;\n}\nLL solve(int n){\n\tLL ret=0;\n\tint loop[4];\n\tfor(loop[0]=0; loop[0]<=cnt[0]; loop[0]++){\n\t\tfor(loop[1]=0; loop[1]<=cnt[1]; loop[1]++){\n\t\t\tfor(loop[2]=0; loop[2]<=cnt[2]; loop[2]++){\n\t\t\t\tfor(loop[3]=0; loop[3]<=cnt[3]; loop[3]++){\n\t\t\t\t\tint sum1 = loop[0]+loop[1]+loop[2]+loop[3];\n\t\t\t\t\tint sum2 = loop[0]+2*loop[1]+3*loop[2]+4*loop[3];\n\t\t\t\t\tLL tmp = 0;\n\t\t\t\t\tREP(i,4){\n\t\t\t\t\t\tif(loop[i]==cnt[i])continue;\n\t\t\t\t\t\tLL tmp2=0;\n\t\t\t\t\t\tREP(j,4){\n\t\t\t\t\t\t\ttmp2 += C(cnt[j]-(i==j), loop[j]);\n\t\t\t\t\t\t\ttmp2 %= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp += tmp2*s[i];\n\t\t\t\t\t\ttmp %= MOD;\n\t\t\t\t\t}\n\t\t\t\t\tif(n-sum1-1<0)tmp=0;\n\t\t\t\t\telse tmp *= f[n-sum1-1];\n\t\t\t\t\ttmp %= MOD;\n\t\t\t\t\ttmp *= fact[sum1];\n\t\t\t\t\ttmp %= MOD;\n\t\t\t\t\ttmp *= powten[sum2];\n\t\t\t\t\ttmp %= MOD;\n\t\t\t\t\tret = (ret+tmp)%MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tfact[0]=fact[1]=invfact[0]=invfact[1]=1;\n\tFOR(i,2,222)fact[i]=(fact[i-1]*i)%MOD;\n\tFOR(i,2,222)invfact[i]=mod_inverse(fact[i], MOD);\n\tpowten[0]=1;\n\tFOR(i,1,1000)powten[i] = (powten[i-1]*10)%MOD;\n\tf[0]=1;\n\tFOR(i,1,222){\n\t\tf[i]=1;\n\t\tFOR(j,1,i+1)f[i]=(f[i]+P(i,j))%MOD;\n\t}\n\tint n;\n\tcin>>n;\n\tREP(i,n)scanf(\"%d\", a+i);\n\tif(n==1){\n\t\tcout << a[0] << endl;\n\t\treturn 0;\n\t}\n\tsort(a,a+n);\n\tint c=10;\n\tREP(i,n){\n\t\tREP(j,4){\n\t\t\tif(a[i]<c){\n\t\t\t\tcnt[j]++;\n\t\t\t\ts[j]+=a[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tc*=10;\n\t\t}\n\t}\n\tLL ret = solve(n);\n\tif(a[0]==0){\n\t\tcnt[0]--;\n\t\tret -= solve(n-1);\n\t}\n\twhile(ret<0)ret+=MOD;\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint mod=1000000007;\nint b[210];\nint kt[210];\nint c[10];\nlong long dp[1100][1100];\nlong long C[1100][1100];\nlong long fact[1100];\nlong long inv[1100];\nlong long factinv[1100];\nlong long ks[1100];\nint calc(vector<int>v){\n\tint n=v.size();\n\tfor(int i=0;i<v.size();i++){\n\t\tkt[i]=0;\n\t\tint tmp=v[i];\n\t\twhile(tmp){\n\t\t\ttmp/=10;\n\t\t\tkt[i]++;\n\t\t}\n\t\tif(kt[i]==0)kt[i]++;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tks[i]=0;\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tks[i]=(ks[i]+fact[i]*factinv[i-j])%mod;\n\t\t}\n\t}\n\tfor(int i=0;i<10;i++)c[i]=0;\n\tfor(int i=0;i<n;i++)c[kt[i]]++;\n\tlong long ret=0;\n\tfor(int i=1;i<=5;i++){\n\t\tif(!c[i])continue;\n\t\tfor(int j=0;j<1100;j++)for(int k=0;k<1100;k++)dp[j][k]=0;\n\t\tdp[0][0]=1;\n\t\tfor(int j=1;j<=5;j++){\n\t\t\tint has=c[j];\n\t\t\tif(i==j)has--;\n\t\t\twhile(has--){\n\t\t\t\tfor(int k=n-1;k>=0;k--)for(int l=0;l<810;l++){\n\t\t\t\t\tif(!dp[k][l])continue;\n\t\t\t\t\tdp[k+1][l+j]=(dp[k+1][l+j]+dp[k][l]*(k+1))%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long sum=0;\n\t\tfor(int j=0;j<n;j++)if(i==kt[j])sum+=v[j];\n\t\tfor(int j=0;j<810;j++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t//\tif(dp[k][j]*sum%mod*ks[n-k-1])printf(\"%d %d %d: %lld %lld %lld\\n\",i,j,k,dp[k][j],ks[n-k-1],dp[k][j]*sum%mod*ks[n-k-1]%mod);\n\t\t\t\tret=(ret+dp[k][j]*sum%mod*ks[n-k-1])%mod;\n\t\t\t}\n\t\t\tsum=sum*10%mod;\n\t\t}\n\t}\n\treturn (int)ret;\n}\nint main(){\n\tC[0][0]=1;\n\tfact[0]=1;\n\tinv[1]=1;\n\tfor(int i=2;i<1100;i++)inv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\tfactinv[0]=1;\n\tfor(int i=1;i<1100;i++)factinv[i]=factinv[i-1]*inv[i]%mod;\n\tfor(int i=1;i<1100;i++)fact[i]=fact[i-1]*i%mod;\n\tfor(int i=0;i<1050;i++){\n\t\tfor(int j=0;j<=i;j++){\n\t\t\tC[i+1][j]=(C[i+1][j]+C[i][j])%mod;\n\t\t\tC[i+1][j+1]=(C[i+1][j+1]+C[i][j])%mod;\n\t\t}\n\t}\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++)scanf(\"%d\",b+i);\n\tbool zr=false;\n\tvector<int>tmp;\n\tfor(int i=0;i<a;i++){\n\t\tif(!b[i])zr=true;\n\t\telse tmp.push_back(b[i]);\n\t}\n\tint ret=0;\n\tif(zr){\n\t\tret=mod-calc(tmp);\n\t\ttmp.push_back(0);\n\t}\n\tret=(ret+calc(tmp))%mod;\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint dp[12][92][202][202];\nconst int M=1000000007;\nint C[202][202];\n\nint solve(vector<int> v){\n  int nd[5]={};\n  int s[5]={};\n  for(auto e:v){\n    int x=(e>=10)+(e>=100)+(e>=1000)+1;\n    nd[x]++;\n    s[x]=(s[x]+e)%M;\n  }\n  int t[223]={1};\n  int rp[223]={1};\n  int fact[223]={1};\n  for(int i=0;i<200;i++){\n    t[i+1]=t[i]*10LL%M;\n    rp[i+1]=(rp[i]*(i+1LL)+1)%M;\n    fact[i+1]=fact[i]*(i+1LL)%M;\n  }\n  dp[0][0][0][0]=1;\n  int r=0;\n  for(int i=0;i<=nd[1];i++){\n    for(int j=0;j<=nd[2];j++){\n      for(int k=0;k<=nd[3];k++){\n\tfor(int l=0;l<=nd[4];l++){\n\t  if(i!=nd[1]){\n\t    r=(r+t[i+j*2+k*3+l*4]*1LL*s[1]%M*rp[v.size()-1-i-j-k-l]%M*fact[i+j+l+k]%M*C[nd[1]-1][i]%M*C[nd[2]][j]%M*C[nd[3]][k]%M*C[nd[4]][l]%M)%M;\n\t  }\n\t  if(j!=nd[2]){\n\t    r=(r+t[i+j*2+k*3+l*4]*1LL*s[2]%M*rp[v.size()-1-i-j-k-l]%M*fact[i+j+l+k]%M*C[nd[1]][i]%M*C[nd[2]-1][j]%M*C[nd[3]][k]%M*C[nd[4]][l]%M)%M;\n\t  }\t    \n\t  if(k!=nd[3]){\n\t    r=(r+t[i+j*2+k*3+l*4]*1LL*s[3]%M*rp[v.size()-1-i-j-k-l]%M*fact[i+j+l+k]%M*C[nd[1]][i]%M*C[nd[2]][j]%M*C[nd[3]-1][k]%M*C[nd[4]][l]%M)%M;\n\t  }\t    \n\t  if(l!=nd[4]){\n\t    r=(r+t[i+j*2+k*3+l*4]*1LL*s[4]%M*rp[v.size()-1-i-j-k-l]%M*fact[i+j+l+k]%M*C[nd[1]][i]%M*C[nd[2]][j]%M*C[nd[3]][k]%M*C[nd[4]-1][l]%M)%M;\n\t  }\n\t  int d=dp[i][j][k][l]*1LL*(i+j+k+l)%M;\n\t  dp[i+1][j][k][l]=(dp[i+1][j][k][l]+d)%M;\n\t  dp[i][j+1][k][l]=(dp[i][j+1][k][l]+d)%M;\n\t  dp[i][j][k+1][l]=(dp[i][j][k+1][l]+d)%M;\n\t  dp[i][j][k][l+1]=(dp[i][j][k][l+1]+d)%M;\n\t}\n      }\n    }\n  }\n  return r;\n}\n\t  \nint main(){\n  C[0][0]=1;\n  for(int i=1;i<=200;i++){\n    C[i][0]=1;\n    for(int j=1;j<=i;j++){\n      C[i][j]=(C[i-1][j-1]+C[i-1][j])%M;\n    }\n  }\n  int n;\n  cin>>n;\n  vector<int> v(n);\n  for(int i=0;i<n;i++){\n    cin>>v[i];\n  }\n  sort(begin(v),end(v));\n  int ans=solve(v);\n  if(v[0]==0){\n    v.erase(v.begin());\n    ans=(ans-solve(v)+M)%M;\n  }\n  cout<<ans<<endl;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\n#define ll long long\n\nusing namespace std;\n\nint inv[805], fac[805], finv[805];\n\nvoid make()\n{\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i=2;i<805;i++){\n        inv[i] = MOD - (ll)inv[MOD%i] * (MOD/i) % MOD;\n        fac[i] = (ll)fac[i-1] * i % MOD;\n        finv[i] = (ll)finv[i-1] * inv[i] % MOD;\n    }\n}\n\nint comb(int a, int b)\n{\n    if(a < b){\n        return 0;\n    }else{\n        return fac[a] * ((ll)finv[b] * finv[a-b] % MOD) % MOD;\n    }\n}\n\nint add(int a, int b)\n{\n    return (a + b) % MOD;\n}\n\nint sub(int a, int b)\n{\n    return (a - b + MOD) % MOD;\n}\n\nint mul(int a, int b)\n{\n    return (ll)a*b%MOD;\n}\n\n// i 個で j 桁の数で 0 含む\nint dp[205][805], dp2[205][805];\nint a[205], keta[205];\nint zyu[805];\nint bar[205];\n\nint dig(int num)\n{\n    int res = 1;\n    while(num >= 10){\n        res++;\n        num /= 10;\n    }\n    return res;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    int zero = 0, wa = 0;\n    for(int i = 0; i < n; i++){\n        cin >> a[i];\n        if(a[i] == 0) zero++;\n        keta[i] = dig(a[i]);\n    }\n    zyu[0] = 1;\n    for(int i = 0; i < 804; i++){\n        zyu[i+1] = mul(zyu[i], 10);\n    }\n    dp[0][0] = 1;\n    for(int k = 0; k < n; k++){\n        for(int i = k; i >= 0; i--){\n            for(int j = 0; j <= wa; j++){\n                dp[i+1][j+keta[k]] = add(dp[i+1][j+keta[k]], mul(dp[i][j], i+1));\n            }\n        }\n        wa += keta[k];\n    }\n    make();\n    for(int i = 0; i < 205; i++){\n        for(int j = 0; j <= i; j++){\n            bar[i] = add(bar[i], mul(fac[i], finv[i-j]));\n        }\n    }\n    int ans = 0;\n    for(int i = 0; i < n; i++){\n        if(a[i] == 0) continue;\n        for(int j = 0; j <= n; j++){\n            for(int k = 0; k <= wa; k++){\n                dp2[j][k] = dp[j][k];\n            }\n        }\n        for(int j = 0; j < n; j++){\n            for(int k = 0; k <= wa-keta[i]; k++){\n                dp2[j+1][k+keta[i]] = sub(dp2[j+1][k+keta[i]], mul(dp2[j][k], j+1));\n            }\n        }\n        for(int j = 0; j <= n-1; j++){\n            for(int k = 0; k <= wa-keta[i]; k++){\n                ans = add(ans, mul(mul(dp2[j][k], bar[n-j-1]), mul(a[i], zyu[k])));\n            }\n        }\n    }\n    if(zero == 0){\n        cout << ans << \"\\n\";\n    }else{\n        vector<int> A;\n        vector<int> ket;\n        bool flag = false;\n        for(int i = 0; i <= n; i++){\n            for(int j = 0; j <= wa; j++){\n                dp[i][j] = 0;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            if(a[i] == 0 && !flag){\n                flag = true;\n                continue;\n            }\n            A.push_back(a[i]);\n            ket.push_back(dig(A.back()));\n        }\n        --n;\n        dp[0][0] = 1;\n        int wa = 0;\n        for(int k = 0; k < n; k++){\n            for(int i = k; i >= 0; i--){\n                for(int j = 0; j <= wa; j++){\n                    dp[i+1][j+ket[k]] = add(dp[i+1][j+ket[k]], mul(dp[i][j], i+1));\n                }\n            }\n            wa += ket[k];\n        }\n        int ans1 = 0;\n        for(int i = 0; i < n; i++){\n            if(A[i] == 0) continue;\n            for(int j = 0; j <= n; j++){\n                for(int k = 0; k <= wa; k++){\n                    dp2[j][k] = dp[j][k];\n                }\n            }\n            for(int j = 0; j < n; j++){\n                for(int k = 0; k <= wa-ket[i]; k++){\n                    dp2[j+1][k+ket[i]] = sub(dp2[j+1][k+ket[i]], mul(dp2[j][k], j+1));\n                }\n            }\n            for(int j = 0; j <= n-1; j++){\n                for(int k = 0; k <= wa-ket[i]; k++){\n                    ans1 = add(ans1, mul(mul(dp2[j][k], bar[n-j-1]), mul(A[i], zyu[k])));\n                }\n            }\n        }\n        cout << sub(ans, mul(zero, ans1)) << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst ll mod = 1e9+7;\n\nint len[11][91][201][201];\n\nint ct[5]={};\nll sum[5]={};\n\ninline int LEN(int x){\n    if(x==0) return 0;\n    if(x<10) return 1;\n    if(x<100) return 2;\n    if(x<1000) return 3;\n    return 4;\n}\n\nll f[202];\nll C[202][202];\n\nll pre_P[202];\n\nll TEN[2000];\n\n\nll mod_pow(ll x, ll n){\n    ll ret = 1;\n    while(n){\n        if(n&1) (ret*=x)%=mod;\n        (x*=x)%=mod;\n        n>>=1;\n    }\n    return ret;\n}\n\nll mod_inv(ll x){\n    return mod_pow(x,mod-2);\n}\n\n\nint main(){\n    f[0] = 1;\n    rep(i,202-1) f[i+1] = (f[i]*(i+1))%mod;\n\n    rep(i,202){\n        rep(j,i+1){\n            C[i][j] = f[i];\n            (C[i][j] *= mod_inv(f[j])) %= mod;\n            (C[i][j] *= mod_inv(f[i-j])) %= mod;\n        }\n    }\n\n    rep(i,202){\n        rep(j,i+1) (pre_P[i] += (f[i]*mod_inv(f[i-j]))%mod) %= mod;\n    }\n\n    TEN[0] = 1;\n    rep(i,2000-1) TEN[i+1] = (TEN[i]*10)%mod;\n\n    int n;\n    cin >>n;\n    vector<int> a(n);\n    rep(i,n) cin >>a[i];\n\n    rep(i,n){\n        ++ct[LEN(a[i])];\n        sum[LEN(a[i])] += a[i];\n    }\n\n    ll ans = 0;\n    for(int d=1; d<=4; ++d){\n        --ct[d];\n\n        ll p = 0;\n        rep(i0,ct[0]+1)rep(i1,ct[1]+1)rep(i2,ct[2]+1)rep(i3,ct[3]+1)rep(i4,ct[4]+1){\n            int L = i0 + i1 + 2*i2 + 3*i3 + 4*i4;\n\n            ll add = 1;\n            (add *= C[ct[1]][i1]) %= mod;\n            (add *= C[ct[2]][i2]) %= mod;\n            (add *= C[ct[3]][i3]) %= mod;\n            (add *= C[ct[4]][i4]) %= mod;\n\n            int rsz = i0+i1+i2+i3+i4;\n            (add *= f[rsz]) %= mod;\n\n            // 全部選ぶ必要はない\n            int lsz = n-1-rsz;\n            if(ct[0]==1 && i0==0) (add *= (pre_P[lsz]-pre_P[lsz-1]+mod)%mod) %= mod;\n            else (add *= pre_P[lsz]) %= mod;\n\n            (p += (TEN[L]*add)%mod) %= mod;\n        }\n\n        (ans += sum[d]*p) %= mod;\n        ++ct[d];\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n;\nll dp[201][1001];\nll P[1001];\nll P2[1001];\n\nint solve(vector<string> &a, int t){\n\tmemset(dp, 0, sizeof(dp));\n\tint r = atoi(a[t].c_str());\n\tdp[0][0] = 1;\n\tREP(i, a.size()){\n\t\tif(i == t) continue;\n\t\tRREP(j, i+1)RREP(k, 800){\n\t\t\tdp[j+1][k+a[i].size()] += dp[j][k];\n\t\t}\n\t}\n\tll sum=0;\n\tll tenp = 1;\n\tREP(j, 800){\n\t\tREP(i, a.size()){\n\t\t\t(sum += ((tenp*dp[i][j])%MOD) * ((P2[a.size()-1-i] * P[i])%MOD)) %= MOD;\n\t\t}\n\t\ttenp = tenp*10%MOD;\n\t}\n\treturn (r*sum)%MOD;\n}\n\nll C[1010][1010];\nvoid make_C(){\n    memset(C, 0, (int)sizeof(C));    \n    REP(i, 1000){\n        C[i][0] = C[i][i] = 1;\n        for(int j = 1; j < i; j++) C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;\n    }\n    REP(i, 1000)for(int j = 0; j <= i; j++) P2[i] = (P2[i] + C[i][j]*P[i-j]) % MOD;\n}\nmain(){\n\tP[0] = 1;\n\tREP(i, 1000) P[i+1] = (P[i] * (i+1))%MOD;\n\tmake_C();\n\twhile(cin >> n){\n\t\tvector<string> a(n);\n\t\tREP(i, n) cin >> a[i];\n\t\tsort(RALL(a));\n\t\tll sum = 0;\n\t\tREP(i, n) sum += solve(a, i);\n\t\tif(a.back() == \"0\"){\n\t\t\ta.resize(a.size()-1);\n\t\t\tREP(i, n) sum -= solve(a, i);\n\t\t}\n\t\tcout << (sum%MOD+MOD)%MOD << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\n#define mod 1000000007\n\nusing namespace std;\n\n\n// ------ 0. Variables, Functions ------ //\n\nint n;\n\nvector<int> fact;\nvector<int> power2;\nvector<int> power10;\n\nint digit(int n)\n{\n\tif (n < 10) return 1;\n\n\treturn digit(n / 10) + 1;\n}\n\nint solve(vector<int> a)\n{\n\tvector<vector<int> > d(5, vector<int>(2, 0));\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\td[digit(a[i])][0] += 1;\n\t\td[digit(a[i])][1] += a[i];\n\t}\n\n\tint ret = 0;\n\n\tfor (int i = 1; i <= 4; i++)\n\t{\n\t\tvector<vector<vector<int> > > dp(5, vector<vector<int> >(n, vector<int>(n * 4, 0)));\n\n\t\tdp[0][0][0] = 1;\n\n\t\tif (d[i][0] != 0)\n\t\t{\n\t\t\td[i][0]--;\n\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t{\n\t\t\t\t\tfor (int l = 0; l < n * 4; l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dp[j][k][l] != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int m = 0; m <= d[j + 1][0]; m++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdp[j + 1][k + m][l + (j + 1) * m]++;\n\t\t\t\t\t\t\t\tdp[j + 1][k + m][l + (j + 1) * m] %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\td[i][0]++;\n\n\t\t\tint res = 0;\n\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < n * 4; k++)\n\t\t\t\t{\n\t\t\t\t\tres = (res + 1LL * dp[4][j][k] * fact[j] % mod * power10[k] % mod * power2[n - j - 1] % mod) % mod;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = (ret + 1LL * res * d[i][1]) % mod;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\t// ------ 1. init ------ //\n\n\tfact.push_back(1);\n\n\tfor (int i = 1; i <= 200; i++) fact.push_back(1LL * fact[i - 1] * i % mod);\n\n\tpower2.push_back(1);\n\n\tfor (int i = 1; i <= 200; i++) power2.push_back(1LL * power2[i - 1] * 2 % mod);\n\n\tpower10.push_back(1);\n\n\tfor (int i = 1; i <= 800; i++) power10.push_back(1LL * power10[i - 1] * 10 % mod);\n\n\n\t// ------ 2. Input ------ //\n\n\tscanf(\"%d\", &n);\n\n\tvector<int> a(n);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tsort(a.begin(), a.end(), greater<int>());\n\n\tint res = solve(a);\n\n\tif (a[n - 1] == 0)\n\t{\n\t\ta.pop_back(); n--;\n\n\t\tres += (mod - solve(a));\n\t\tres %= mod;\n\t}\n\n\tprintf(\"%d\\n\", res);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nll dp[201][805], tmp[201][805];\nll pw[805], tab[201], tab_zero[201];\n \nsigned main() {\n    int N; cin >> N;\n    pw[0] = 1;\n    for(int i=1; i<805; i++) {\n        pw[i] = (pw[i-1] * 10) % MOD;\n    }\n\n    // tab[i] = iP0 + iP1 + ... iPi\n    for(int i=0; i<=N; i++) {\n        tab[i] = 1;\n        ll P = 1;\n        for(int k=1; k<=i; k++) {\n            (P *= i - k + 1) %= MOD;\n            (tab[i] += P) %= MOD;\n            (tab_zero[i] += P * k % MOD) %= MOD;\n        }\n    }\n\n    bool exist_zero = false;\n    vector<int> A, digits;\n    for(int i=0; i<N; i++) {\n        int val; cin >> val;\n        if(val == 0) {\n            exist_zero = true;\n            continue;\n        }\n        else A.push_back(val);\n\n        int d = 0; while(val) d++, val /= 10;\n        digits.push_back(d);\n    }\n\n    int M = A.size(), sum = 0;\n    dp[0][0] = 1;\n    for(int i=0; i<M; i++) {\n        for(int j=i; j>=0; j--) {\n            for(int k=sum; k>=0; k--) {\n                (dp[j+1][k+digits[i]] += dp[j][k] * (j + 1)) %= MOD;\n            }\n        }\n        sum += digits[i];\n    }\n\n    // i 番目を使わない場合\n    ll ans = 0, show_debug = false;\n    for(int i=0; i<M; i++) {\n        fill(tmp[0], tmp[M+1], 0);\n        for(int j=0; j<M; j++) {\n            for(int k=0; k<=sum; k++) {\n                tmp[j][k] = dp[j][k];\n                if(j - 1 >= 0 and k - digits[i] >= 0) {\n                    (tmp[j][k] += MOD - (tmp[j-1][k - digits[i]] * j % MOD)) %= MOD;\n                }\n\n                // j 個を使って合計 k 桁 (これを i 番目の下に置くイメージ)\n                // 残っているのは M-j-1 個\n                {\n                    // 0 を使わない場合\n                    ll comb = tab[M-j-1] * tmp[j][k] % MOD;\n                    ll val = A[i] * pw[k] % MOD;\n                    ll add = val * comb % MOD;\n                    (ans += add) %= MOD;\n                    // fprintf(stderr, \"val = %d, comb = %lld * %lld\\n\", val, tab[M-j-1], tmp[j][k]);\n                    if(add and show_debug) fprintf(stderr, \"#1: i = %d, j = %d, k = %d, add = %lld\\n\", i, j, k, add);\n                }\n\n                if(exist_zero) {\n                    // 0 を使う場合 (i 番目の下に置く)\n                    {\n                        ll comb = tab[M-j-1] * tmp[j][k] % MOD * (j+1) % MOD;\n                        ll val = A[i] * pw[k + 1] % MOD;\n                        ll add = val * comb % MOD;\n                        (ans += add) %= MOD;\n                        if(add and show_debug) fprintf(stderr, \"#2: i = %d, j = %d, k = %d, add = %lld\\n\", i, j, k, add);\n                    }\n\n                    // 0 を使う場合 (i 番目の上に置く)\n                    {\n                        ll comb = tab_zero[M-j-1] * tmp[j][k] % MOD;\n                        ll val = A[i] * pw[k] % MOD;\n                        ll add = val * comb % MOD;\n                        (ans += add) %= MOD;\n                        if(add and show_debug) fprintf(stderr, \"#3: i = %d, j = %d, k = %d, add = %lld\\n\", i, j, k, add);\n                    }\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n;\nll dp[201][1001];\nll P[1001];\nll P2[1001];\nll P3[1001];\n\nll solve(vector<string> &a, int t){\n\tmemset(dp, 0, sizeof(dp));\n\tint r = atoi(a[t].c_str());\n\tdp[0][0] = 1;\n\tREP(i, a.size()){\n\t\tif(i == t) continue;\n\t\tRREP(j, i+1)RREP(k, (i+1)*4){\n\t\t\tdp[j+1][k+a[i].size()] += dp[j][k];\n\t\t\tif(dp[j+1][k+a[i].size()] > MOD) dp[j+1][k+a[i].size()]-=MOD;\n\t\t}\n\t}\n\tll sum=0;\n\tll tenp = 1;\n\tREP(j, 800){\n\t\tREP(i, a.size()){\n\t\t\tsum += (tenp*dp[i][j])%MOD * P3[i];\n\t\t\tif(sum > MOD) sum %= MOD;\n\t\t}\n\t\ttenp *= 10;\n\t\tif(tenp > MOD) tenp %= MOD;\n\t}\n\treturn (r*sum)%MOD;\n}\n\nll C[1010][1010];\nvoid make_C(){\n    memset(C, 0, (int)sizeof(C));    \n    REP(i, 1000){\n        C[i][0] = C[i][i] = 1;\n        for(int j = 1; j < i; j++) C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;\n    }\n    REP(i, 1000)for(int j = 0; j <= i; j++) P2[i] = (P2[i] + C[i][j]*P[i-j]) % MOD;\n}\n\nmain(){\n\tP[0] = 1;\n\tREP(i, 1000) P[i+1] = (P[i] * (i+1))%MOD;\n\tmake_C();\n\twhile(cin >> n){\n\t\tvector<string> a(n);\n\t\tREP(i, n) cin >> a[i];\n\t\tsort(RALL(a));\n\t\tll sum = 0;\n\t\tREP(i, a.size()) P3[i] = (P2[n-1-i] * P[i])%MOD;\n\t\tREP(i, n) sum += solve(a, i);\n\t\tif(a.back() == \"0\"){\n\t\t\ta.resize(a.size()-1);\n\t\t\tREP(i, a.size()) P3[i] = (P2[a.size()-1-i] * P[i])%MOD;\n\t\t\tREP(i, a.size()) sum -= solve(a, i);\n\t\t}\n\t\tcout << (sum%MOD+MOD)%MOD << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename Ostream,typename Container>\nOstream& operator<<(Ostream& os,const Container& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\ninline int ncr(int n,int r)\n{\n\tstatic int memo[201][201];\n\tif(memo[n][r]) return memo[n][r];\n\tif(r==0 || r==n) return 1;\n\treturn memo[n][r]=(ncr(n-1,r-1)+ncr(n-1,r))%MOD;\n}\ninline int npr(int n,int r)\n{\n\tstatic int memo[201][201];\n\tif(memo[n][r]) return memo[n][r];\n\tif(r==0) return 1;\n\treturn memo[n][r]=n*(ll)npr(n-1,r-1)%MOD;\n}\n\nint solve(vi as)\n{\n\tarray<int,801> ts={1}; // ts[i]=10^i mod m\n\trepi(i,1,ts.size()) ts[i]=(ll)ts[i-1]*10%MOD;\n\tarray<int,201> fs={1}; // fs[i]=i! mod m\n\trepi(i,1,fs.size()) fs[i]=(ll)fs[i-1]*i%MOD;\n\t\n\tsort(all(as));\n\t\n\tint n=as.size();\n\tvi ls(n);\n\trep(i,n){\n\t\tif(as[i]==0) ls[i]=1;\n\t\tfor(int x=as[i];x;x/=10) ls[i]++;\n\t}\n\tarray<int,5> hist={0};\n\trep(i,n) hist[ls[i]]++;\n\t\n\tarray<int,5> bs,es;\n\trepi(i,1,5){\n\t\tbs[i]=lower_bound(all(ls),i)-begin(ls);\n\t\tes[i]=upper_bound(all(ls),i)-begin(ls);\n\t}\n\t\n\tll res=0;\n\trep(c1,hist[1]+1) rep(c2,hist[2]+1) rep(c3,hist[3]+1) rep(c4,hist[4]+1){\n\t\tarray<int,5> uses={-1,c1,c2,c3,c4};\n\t\tconst int locnt=c1+c2+c3+c4;\n\t\tconst int lolen=c1+2*c2+3*c3+4*c4;\n\t\trepi(len,1,5) if(uses[len]<hist[len]){\n\t\t\thist[len]--;\n\t\t\tint lopat=fs[locnt];\n\t\t\trepi(j,1,5) lopat=(lopat*(ll)ncr(hist[j],uses[j]))%MOD;\n\t\t\thist[len]++;\n\t\t\tll hipat=0;\n\t\t\trep(j,n-locnt) hipat+=npr(n-locnt-1,j);\n\t\t\thipat%=MOD;\n\t\t\tll coeff=(ll)ts[lolen]*lopat%MOD*hipat%MOD;\n\t\t\trepi(j,bs[len],es[len])\n\t\t\t\tres+=as[j]*coeff%MOD;\n\t\t\tres%=MOD;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvi as(n);\n\t\trep(i,n) cin>>as[i];\n\t\t\n\t\tint res=solve(as);\n\t\tif(count(all(as),0)){\n\t\t\tas.erase(find(all(as),0));\n\t\t\tres=(res-solve(as)+MOD)%MOD;\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nllint fact[1005], fact_inv[1005];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < 1005; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfor(int i = 0; i < 1005; i++){\n\t\tfact_inv[i] = modpow(fact[i], mod-2);\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nllint n;\nllint a[205];\nllint keta[205];\nllint beki[1005];\nllint num[205];\nllint cnt[6];\nllint dp[6][205][1005];\n\nllint calc2(int x)\n{\n\tcnt[x]--; n--;\n\t\n\tfor(int i = 0; i <= 5; i++){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\tfor(int k = 0; k < 1005; k++){\n\t\t\t\tdp[i][j][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tdp[0][0][0] = 1;\n\t\n\tfor(int i = 0; i < 5; i++){\n\t\tfor(int j = 0; j <= n; j++){\n\t\t\tfor(int k = 0; k < 1005; k++){\n\t\t\t\tfor(int l = 0; l <= cnt[i+1]; l++){\n\t\t\t\t\tif(j+l <= n && k+l*(i+1) < 1005){\n\t\t\t\t\t\tdp[i+1][j+l][k+l*(i+1)] += dp[i][j][k] * comb(cnt[i+1], l) % mod;\n\t\t\t\t\t\tdp[i+1][j+l][k+l*(i+1)] %= mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tllint ret = 0;\n\tfor(int j = 0; j <= n; j++){\n\t\tfor(int k = 0; k < 1005; k++){\n\t\t\tllint tmp = dp[5][j][k] * fact[j] % mod;\n\t\t\ttmp *= num[n-j], tmp %= mod;\n\t\t\ttmp *= beki[k], tmp %= mod;\n\t\t\tret += tmp, ret %= mod;\n\t\t}\n\t}\n\tcnt[x]++; n++;\n\t\n\treturn ret;\n}\n\nllint calc()\n{\n\tfor(int i = 1; i <= 5; i++) cnt[i] = 0;\n\tfor(int i = 1; i <= n; i++) cnt[keta[i]]++;\n\t\n\tllint ret = 0;\n\tfor(int i = 1; i <= 5; i++){\n\t\tllint tmp = calc2(i);\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\tif(keta[j] == i){\n\t\t\t\tret += tmp * a[j] % mod;\n\t\t\t\tret %= mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nllint getketa(llint x)\n{\n\tif(x == 0) return 1;\n\tllint ret = 0;\n\tfor(;x;x/=10) ret++;\n\treturn ret;\n}\n\nint main(void)\n{\n\tmake_fact();\n\t\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++) cin >> a[i];\n\tsort(a+1, a+n+1);\n\treverse(a+1, a+n+1);\n\t\n\tif(n == 1){\n\t\tcout << a[1] << endl;\n\t\treturn 0;\n\t}\n\t\n\tbeki[0] = 1;\n\tfor(int i = 1; i < 1005; i++) beki[i] = beki[i-1]*10%mod;\n\tfor(int i = 1; i <= n; i++) keta[i] = getketa(a[i]);\n\tfor(int i = 0; i <= n; i++){\n\t\tfor(int j = 0; j <= i; j++){\n\t\t\tnum[i] += comb(i, j) * fact[j] % mod;\n\t\t\tnum[i] %= mod;\n\t\t}\n\t}\n\t\n\tllint ans = calc(), zcnt = 0;\n\tfor(int i = 1; i <= n; i++) if(a[i] == 0) zcnt++;\n\tn--;\n\tans += mod - zcnt*calc()%mod;\n\tans %= mod;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 500;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nmodint t10[1000];\nmodint f[300];\nvoid init() {\n\tt10[0] = 1;\n\trep1(i, 900) {\n\t\tt10[i] = t10[i - 1] * (modint)10;\n\t}\n\tf[0] = 1;\n\trep1(i, 200) {\n\t\trep(j, i + 1) {\n\t\t\tf[i] += fact[j] * comb(i, j);\n\t\t}\n\t}\n}\n\nint r(int &x) {\n\tstring s = to_string(x); return (int)s.size();\n}\n\nmodint calc(vector<int> &a) {\n\tint n = a.size();\n\tmodint dp[205][805] = {};\n\tmodint cop[205][805] = {};\n\tdp[0][0] = 1;\n\trep(i, n) {\n\t\tint d = r(a[i]);\n\t\tper(j, i + 1) {\n\t\t\tper(k, 4 * i + 1) {\n\t\t\t\tdp[j + 1][k + d] += dp[j][k];\n\t\t\t}\n\t\t}\n\t}\n\tmodint ans = 0;\n\trep(i, n) {\n\t\trep(j, n + 1)rep(k, 4 * n + 1)cop[j][k] = 0;\n\t\tint d = r(a[i]);\n\t\tper(j, n) {\n\t\t\tper(k, 4*(n-1)+1) {\n\t\t\t\tcop[j][k] = dp[j + 1][k + d] - cop[j + 1][k + d];\n\t\t\t\tans += (modint)a[i]*cop[j][k] * f[n - 1 - j] * fact[j] * t10[k];\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nvoid solve() {\n\tint n; cin >> n;\n\tvector<int> a(n);\n\trep(i, n) {\n\t\tcin >> a[i];\n\t}\n\tmodint ans = calc(a);\n\tint cnt = 0;\n\trep(i, n)if (a[i] == 0)cnt++;\n\tif (cnt > 0) {\n\t\trep(i, n)if (a[i] == 0) {\n\t\t\ta.erase(a.begin() + i);\n\t\t\tbreak;\n\t\t}\n\t\tmodint sub = calc(a);\n\t\tsub = sub * (modint)cnt;\n\t\tans -= sub;\n\t}\n\tcout << ans << endl;\n\t\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(12);\n\tinit_f(); init();\n\t//int t; cin >> t; rep(i, t)solve();\n\t//while (cin >>n>>m>>s>>t, n)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n;\nll dp[201][1001];\nll P[1001];\nll P2[1001];\nll P3[1001];\n\nll solve(vector<string> &a, int t){\n\tmemset(dp, 0, sizeof(dp));\n\tint r = atoi(a[t].c_str());\n\tdp[0][0] = 1;\n\tREP(i, a.size()){\n\t\tif(i == t) continue;\n\t\tRREP(j, i+1)RREP(k, 800){\n\t\t\tdp[j+1][k+a[i].size()] += dp[j][k];\n\t\t\tif(dp[j+1][k+a[i].size()] > MOD) dp[j+1][k+a[i].size()]-=MOD;\n\t\t}\n\t}\n\tll sum=0;\n\tll tenp = 1;\n\tREP(j, 800){\n\t\tREP(i, a.size()){\n\t\t\tsum += (tenp*dp[i][j])%MOD * P3[i];\n\t\t\tif(sum > MOD) sum %= MOD;\n\t\t}\n\t\ttenp *= 10;\n\t\tif(tenp > MOD) tenp %= MOD;\n\t}\n\treturn (r*sum)%MOD;\n}\n\nll C[1010][1010];\nvoid make_C(){\n    memset(C, 0, (int)sizeof(C));    \n    REP(i, 1000){\n        C[i][0] = C[i][i] = 1;\n        for(int j = 1; j < i; j++) C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;\n    }\n    REP(i, 1000)for(int j = 0; j <= i; j++) P2[i] = (P2[i] + C[i][j]*P[i-j]) % MOD;\n}\n\nmain(){\n\tP[0] = 1;\n\tREP(i, 1000) P[i+1] = (P[i] * (i+1))%MOD;\n\tmake_C();\n\twhile(cin >> n){\n\t\tvector<string> a(n);\n\t\tREP(i, n) cin >> a[i];\n\t\tsort(RALL(a));\n\t\tll sum = 0;\n\t\tREP(i, a.size()) P3[i] = (P2[n-1-i] * P[i])%MOD;\n\t\tREP(i, n) sum += solve(a, i);\n\t\tif(a.back() == \"0\"){\n\t\t\ta.resize(a.size()-1);\n\t\t\tREP(i, a.size()) P3[i] = (P2[a.size()-1-i] * P[i])%MOD;\n\t\t\tREP(i, a.size()) sum -= solve(a, i);\n\t\t}\n\t\tcout << (sum%MOD+MOD)%MOD << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\n \nll add(ll a,ll b){ return (a+b)%mod; }\n \nvoid Add(int &a,ll b){\n  ll tmp=(a+b)%mod;\n  a=tmp;\n}\n \nll mul(ll a,ll b){ return (a*b)%mod; }\n \n \nll mpow(ll a,ll b){\n  ll res=1;\n  while(b){\n    if(b%2==1)res=mul(res,a);\n    a=mul(a,a);\n    b/=2;\n  }\n  return res;\n}\n \nll divi( ll a,ll b){\n  return mul(a, mpow(b,mod-2) );\n}\n \n \n \nint n;\nint a[200];\n \nll Z=0;\nll cnt[10];\nll cntinv[10];\n \nll sum[10];\n \n//ll dp[50][50][50][50][2];\n//ll DP[50][50][50][50][2];\nvector< vector< vector< vector< vector< int > > > >  > dp,DP;\n \nvoid update(int a,int b,int c,int d,int z){\n \n  int na=a%2;\n  int ma=1-na;\n   \n  /*  cout<<a<<' '<<b<<' '<<c<<' '<<d<<' '<<z<<endl;\n  cout<<dp[a][b][c][d][z]<<endl;\n  cout<<DP[a][b][c][d][z]<<endl;\n  cout<<endl;    */\n  if(a<cnt[1]){\n    int cc=cnt[1]-a;\n    ll pp=mul(dp[na][b][c][d][z], cc);\n    Add( dp[ma][b][c][d][z], pp );\n    Add( DP[ma][b][c][d][z], mul(DP[na][b][c][d][z], 10*cc )    );\n    Add( DP[ma][b][c][d][z], mul( mul(pp,cntinv[1]),sum[1]) );\n  }\n   \n  if(b<cnt[2]){\n    int cc=cnt[2]-b;\n    ll pp=mul(dp[na][b][c][d][z], cc);\n    Add( dp[na][b+1][c][d][z], pp );\n    Add( DP[na][b+1][c][d][z], mul(DP[na][b][c][d][z], 100*cc )    );\n    Add( DP[na][b+1][c][d][z], mul(mul(pp,cntinv[2]),sum[2]) );\n  }\n  if(c<cnt[3]){\n    int cc=cnt[3]-c;\n    ll pp=mul(dp[na][b][c][d][z], cc);\n    Add( dp[na][b][c+1][d][z], mul(dp[na][b][c][d][z], cc) );\n    Add( DP[na][b][c+1][d][z], mul(DP[na][b][c][d][z], 1000*cc )    );\n    Add( DP[na][b][c+1][d][z], mul(mul(pp,cntinv[3]),sum[3]) );\n  }\n  if(d<cnt[4]){\n    int cc=cnt[4]-d;\n    ll pp=mul(dp[na][b][c][d][z], cc);\n    Add( dp[na][b][c][d+1][z], mul(dp[na][b][c][d][z], cc) );\n    Add( DP[na][b][c][d+1][z], mul(DP[na][b][c][d][z], 10000*cc )    );\n    Add( DP[na][b][c][d+1][z], mul(mul(pp,cntinv[4]),sum[4]) );\n  }\n   \n  if(z<Z && a+b+c+d>0){\n    Add( dp[na][b][c][d][z+1], dp[na][b][c][d][z] );\n    Add( DP[na][b][c][d][z+1], mul(DP[na][b][c][d][z], 10 )    );\n  }\n}\n \nll solve(){\n  dp.resize(2);\n  for(int i=0;i<(int)dp.size();i++){\n    dp[i].resize(cnt[2]+1);\n    for(int j=0;j<(int)dp[i].size();j++){\n      dp[i][j].resize(cnt[3]+1);\n      for(int k=0;k<(int)dp[i][j].size();k++){\n        dp[i][j][k].resize(cnt[4]+1);\n        for(int l=0;l<(int)dp[i][j][k].size();l++){\n          dp[i][j][k][l].resize(2);\n        }\n      }\n    }\n  }\n  DP=dp;\n \n  dp[0][0][0][0][0]=1;\n \n  int ans=0;\n   \n  for(int a=0;a<=cnt[1];a++){\n    for(int b=0;b<=cnt[2];b++)\n      for(int c=0;c<=cnt[3];c++)\n        for(int d=0;d<=cnt[4];d++)\n          for(int z=0;z<=Z;z++){\n            update(a,b,c,d,z);\n            Add( ans, DP[a%2][b][c][d][z] );\n \n            dp[a%2][b][c][d][z]=0;\n            DP[a%2][b][c][d][z]=0;\n          }\n  }\n \n  return ans;\n}\n \nint countDisit(int x){\n  int res=0;\n  while(x){\n    res++;\n    x/=10;\n  }\n  return res;\n}\n \nint main(){\n  cin>>n;\n   \n  for(int i=0;i<n;i++){\n    cin>>a[i];\n    int D=countDisit(a[i]);\n    if(a[i]==0){\n      Z++;\n      continue;\n    }\n    cnt[D]++;\n    sum[D]+=a[i];\n  }\n \n  for(int i=1;i<=4;i++)\n    if(cnt[i]>0)\n      cntinv[i]=divi(1,cnt[i]);\n  cout<< solve() <<endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nint N;\nbool zero_FLG;\nll POW[1000];\nll num_count[5]; //1～4桁の数がいくつあるか\nll digit_sum[5]; //1～4桁の数の合計\nll nCm[200][200]; //抽出する場合の数\nll mult_num[200]; //n!の表\nll mult_sum[200]; //ΣnPk(k = 0～n)の表\nll dp[5][200][801]; //dp[桁数][右側の数字の使用個数][位置(右側の数字の合計桁数)] = 場合の数\n\nint get_digit(ll num){\n\tif(num == 0)return 1;\n\n\tint count = 0;\n\n\twhile(num > 0){\n\t\tcount++;\n\t\tnum /= 10;\n\t}\n\treturn count;\n}\n\nvoid make_dp(){\n\n\tfor(int digit = 1; digit <= 4; digit++){\n\t\tfor(int use_num = 0; use_num < 200; use_num++){\n\t\t\tfor(int loc = 0; loc < 801; loc++)dp[digit][use_num][loc] = 0;\n\t\t}\n\t}\n\n\tll sum_digit,sum_use,tmp;\n\tint work[5];\n\n\t//★★1～4桁の数が、ある場所に来る場合の数を求める[ある場所の右に来る数列を計算する]★★\n\tfor(int digit = 1; digit <= 4; digit++){ //計算したい桁の数\n\n\t\tfor(int num1 = 0; num1 <= num_count[1]; num1++){ //1桁の数の使用数\n\t\t\tif(digit == 1 && num1 == 0)continue; //1桁の数を計算したいなら、少なくとも1つ必要(自分の分)\n\n\t\t\tfor(int num2 = 0; num2 <= num_count[2]; num2++){\n\t\t\t\tif(digit == 2 && num2 == 0)continue;\n\n\t\t\t\tfor(int num3 = 0; num3 <= num_count[3]; num3++){\n\t\t\t\t\tif(digit == 3 && num3 == 0)continue;\n\n\t\t\t\t\tfor(int num4 = 0; num4 <= num_count[4]; num4++){\n\t\t\t\t\t\tif(digit == 4 && num4 == 0)continue;\n\n\t\t\t\t\t\twork[1] = num1;\n\t\t\t\t\t\twork[2] = num2;\n\t\t\t\t\t\twork[3] = num3;\n\t\t\t\t\t\twork[4] = num4;\n\n\t\t\t\t\t\twork[digit] -= 1; //自分を除く\n\n\t\t\t\t\t\tsum_use = 0;\n\t\t\t\t\t\tsum_digit = 0;\n\n\t\t\t\t\t\tfor(int i = 1; i <= 4; i++){\n\t\t\t\t\t\t\tsum_use += work[i];\n\t\t\t\t\t\t\tsum_digit += i*work[i];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//★★数字を抽出する場合の数を掛ける★★\n\t\t\t\t\t\ttmp = 1;\n\t\t\t\t\t\tfor(int i = 1; i <= 4; i++){\n\t\t\t\t\t\t\tif(digit != i){\n\t\t\t\t\t\t\t\ttmp *= nCm[num_count[i]][work[i]];\n\t\t\t\t\t\t\t}else{ //digit == i\n\t\t\t\t\t\t\t\ttmp *= nCm[num_count[i]-1][work[i]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttmp %= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp *= mult_num[sum_use]; //sum_use個の数字の並べ方はsum_use!通り\n\t\t\t\t\t\ttmp %= MOD;\n\n\t\t\t\t\t\tdp[digit][sum_use][sum_digit] += tmp;\n\t\t\t\t\t\tdp[digit][sum_use][sum_digit] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nll calc(){\n\n\tmake_dp();\n\n\tll ret = 0;\n\tll tmp;\n\tfor(int digit = 1; digit <= 4; digit++){\n\t\tfor(int use_num = 0; use_num < 200; use_num++){\n\t\t\tfor(int loc = 0; loc < 801; loc++){\n\n\t\t\t\ttmp = dp[digit][use_num][loc]*POW[loc];\n\t\t\t\ttmp %= MOD;\n\t\t\t\ttmp *= mult_sum[N-(use_num+1)]; //★左側に並べる数字の場合の数の総和★\n\t\t\t\ttmp %= MOD;\n\t\t\t\ttmp *= digit_sum[digit];\n\t\t\t\ttmp %= MOD;\n\t\t\t\tret += tmp;\n\t\t\t\tret %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\n\t//10の累乗を計算する\n\tPOW[0] = 1;\n\tfor(int i = 1; i < 801; i++){\n\t\tPOW[i] = POW[i-1]*10;\n\t\tPOW[i] %= MOD;\n\t}\n\n\t//ΣnPkおよびn!を求める\n\tll number,tmp_sum;\n\tfor(ll a = 199;a >= 0; a--){\n\t\ttmp_sum = a+1; //aP0 == 1,aP1 = a\n\t\tnumber = a;\n\t\tfor(ll k = 1; k <= a-1; k++){\n\t\t\tnumber *= (a-k);\n\t\t\tnumber %= MOD;\n\t\t\ttmp_sum += number;\n\t\t\ttmp_sum %= MOD;\n\t\t}\n\t\tmult_num[a] = number; //a!\n\t\tmult_sum[a] = tmp_sum; //ΣaPk\n\t}\n\n\t//コンビネーションを求める\n\tnCm[0][0] = 1;\n\tfor(int n = 1; n < 200; n++) {\n\t\tfor (int k = 0; k <= n; k++) {\n\t\t\tif(k > 0){\n\t\t\t\tnCm[n][k] = nCm[n-1][k]+nCm[n-1][k-1];\n\t\t\t}else{ //k == 0\n\t\t\t\tnCm[n][k] = 1;\n\t\t\t}\n\t\t\tnCm[n][k] %= MOD;\n\t\t}\n\t}\n\n\tmult_num[0] = 1; //0! = 1\n\n\tzero_FLG = false; //0が登場したかどうかのフラグ\n\tfor(int i = 1; i <= 4; i++){\n\t\tnum_count[i] = 0;\n\t\tdigit_sum[i] = 0;\n\t}\n\n\tscanf(\"%d\",&N);\n\n\tint tmp_digit;\n\tll tmp;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lld\",&tmp);\n\t\tif(tmp == 0){\n\t\t\tzero_FLG = true;\n\t\t}\n\t\ttmp_digit = get_digit(tmp);\n\t\tnum_count[tmp_digit]++; //tmp_digit桁の数の個数を計上\n\t\tdigit_sum[tmp_digit] += tmp; //tmp_digit桁の数の総和を求める\n\t}\n\n\tll ans = calc();\n\tif(zero_FLG){\n\t\tN--; //0は入力されても最大1つ(問題仕様)\n\t\tnum_count[1]--;\n\t\tans -= calc();\n\t\tif(ans < 0)ans += MOD;\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\nint n,a[210];\nint num[5];\n\nconst ll mod = 1000000007LL;\n\nll coef[5];\nll ans = 0LL;\n\nll dp[210][810];\nll ten[810];\nll P[210][210];\nll C[210][210];\n\nvoid init(){\n\trep(i,201)rep(j,i+1){\n\t\tif(j==0 or j==i)\n\t\t\tC[i][j]=1LL;\n\t\telse\n\t\t\tC[i][j] = (C[i-1][j] + C[i-1][j-1]) % mod;\n\t}\n\n\trep(i,201)rep(j,i+1){\n\t\tif(j==0)\n\t\t\tP[i][j]=1LL;\n\t\telse\n\t\t\tP[i][j] = (i+1-j) * P[i][j-1] %mod;\n\t}\n\n\tten[0] = 1LL;\n\trep(i,1,801) ten[i] = 10LL * ten[i-1] %mod;\n}\n\nvoid func(int tar){\n\tif(num[tar]==0) return;\n\tnum[tar]--;\n\n\trep(i,210)rep(j,810) dp[i][j]=0LL;\n\tdp[0][0] = 1LL;\n\n\trep(len,1,5){\n\t\trep(loop,num[len]){\n\t\t\trrep(j,n+1)rep(k,4*n+1){\n\t\t\t\tif(dp[j][k]==0) continue;\n\t\t\t\tdp[j+1][k+len] += 1LL * (j+1) * dp[j][k] % mod;\t\n\t\t\t\tdp[j+1][k+len] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\n\tcoef[tar] = 0LL;\n\n\tconst int m = n - 1 - num[0];\n\n\trep(rnzero,m+1)rep(len,4*m+1){\n\t\tif(dp[rnzero][len]==0) continue;\n\t\tconst int restnzero = m - rnzero;\n\n\t\trep(lnzero,m-rnzero+1){\n\t\t\trep(rzero,num[0]+1){\n\t\t\t\trep(lzero,num[0]-rzero+1){\n\n\t\t\t\t\tll cur = dp[rnzero][len];\n\t\t\t\t\tcur = 1LL * cur * ten[len + rzero] % mod;\n\n\t\t\t\t\tcur = 1LL * cur * P[restnzero][lnzero] % mod;\n\t\t\t\t\tcur = 1LL * cur * P[rnzero+rzero][rzero] % mod;\n\n\t\t\t\t\tif(lnzero == 0 and lzero == 0)\n\t\t\t\t\t\tcur = 1LL * cur;\t\n\t\t\t\t\telse if(lnzero == 0  and lzero > 0)\n\t\t\t\t\t\tcur = 0;\n\t\t\t\t\telse\n\t\t\t\t\t\tcur = 1LL * cur * P[lnzero-1+lzero][lzero] % mod;\n\n\t\t\t\t\t//cerr << lnzero << \" \" << rnzero << \" \" << len << \" \" << lzero << \" \" << rzero << \" \" << cur << endl;\n\n\t\t\t\t\tcoef[tar] = (coef[tar] + cur) % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tnum[tar]++;\n}\n\n\nint main(void){\n\tinit();\n\tcin >> n;\n\trep(i,n) cin >> a[i];\n\n\trep(i,n){\n\t\tstring tmp = to_string(a[i]);\n\t\tif(tmp == \"0\")\n\t\t\tnum[0]++;\n\t\telse\n\t\t\tnum[tmp.size()]++;\n\t}\n\n\trep(i,1,5) func(i);\n\n\t//cerr << coef[1] << \" \" << coef[2] << \" \" << coef[3] << \" \" << coef[4] << endl;\n\n\trep(i,n){\n\t\tstring tmp = to_string(a[i]);\n\t\tif(tmp == \"0\") continue;\n\t\tans += 1LL * coef[tmp.size()] * a[i] % mod;\n\t\tans %= mod;\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nclass range {\n    struct Iterator {\n        int val, inc;\n        int operator*() {return val;}\n        bool operator!=(Iterator& rhs) {return val < rhs.val;}\n        void operator++() {val += inc;}\n    };\n    Iterator i, n;\n    public:\n    range(int e) : i({0, 1}), n({e, 1}) {}\n    range(int b, int e) : i({b, 1}), n({e, 1}) {}\n    range(int b, int e, int inc) : i({b, inc}), n({e, inc}) {}\n    Iterator& begin() {return i;}\n    Iterator& end() {return n;}\n};\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\nconst int MOD = 1e9 + 7;\nvoid add(int& x, int y) {\n    x += y;\n    if(x >= MOD) x-= MOD;\n}\nint solve(vector<int> a) {\n    int n = a.size();\n    vector<int> d(n);\n    REP(i, n) d[i] = to_string(a[i]).size();\n\n    int ans = 0;\n\n    const int P = 4 * n + 1;\n    int ways[802][202] = {};\n    ways[0][0] = 1;\n    REP(i, n){\n        int nways[802][202] = {};\n        REP(l, P) REP(k, i+1) {\n            add(nways[l][k], ways[l][k]);\n            if(l + d[i] < P) add(nways[l+d[i]][k+1], ways[l][k]);\n        }\n        memcpy(ways, nways, sizeof(ways));\n    }\n    // REP(l, P) REP(k, n+1) if(ways[l][k] > 0) {\n    //     cout << \"length: \" << l << endl;\n    //     cout << \"count: \" << k << endl;\n    //     cout << \"ways: \" << ways[l][k] << endl;\n    // }\n    //\n    vector<int> fact(n+2, 1);\n    REP(i, n+1) fact[i+1] = (LL)fact[i] * (i+1) % MOD;\n\n    REP(i, n){\n        int base10 = 1;\n        const int P = 4*(n-1) + 1;\n\n        int dp[802][202] = {};\n        REP(l, P) REP(k, n) {\n            dp[l][k] = ways[l][k];\n            if(l-d[i]>=0 && k-1 >= 0) {\n                dp[l][k] -= dp[l-d[i]][k-1];\n                if(dp[l][k] < 0) dp[l][k] += MOD;\n            }\n            // if(dp[l][k] > 0) {\n            //     cout << \"not use: \" << i << endl;\n            //     cout << \"length: \" << l << endl;\n            //     cout << \"count: \" << k << endl;\n            //     cout << \"ways: \" << dp[l][k] << endl;\n            // }\n        }\n\n        REP(l, P) REP(k, n) {\n            dp[l][k] = fact[k] * dp[l][k] % MOD;\n        }\n\n\n        int dp2[802] = {};\n        REP(k, n) {\n            int rest = (n-1) - k;\n            LL K = 1;\n            REP(i, rest+1) {\n                REP(l, P) add(dp2[l], K * dp[l][k] % MOD);\n                K = K * (rest - i) % MOD;\n            }\n        }\n\n        REP(p, P) {\n            // if(dp2[p] > 0) {\n            //     cout << \"i: \" << i << endl;\n            //     cout << \"10^\" << p << endl;\n            //     cout << \"dp: \" << dp2[p] << endl;\n            // }\n\n            add(ans, (LL)dp2[p] * base10 % MOD * a[i] % MOD);\n            base10 = 10LL * base10 % MOD;\n        }\n    }\n    return ans;\n}\nint main(){\n    iostream_init();\n    int n;\n    while(cin >> n) {\n        vector<int> a(n);\n        REP(i, n) cin >> a[i];\n        sort(a.begin(), a.end());\n        int ans = solve(a);\n        if(a[0] == 0) {\n            vector<int> b;\n            REP(i, n-1) b.push_back(a[i+1]);\n            ans -= solve(b);\n            if(ans < 0) ans += MOD;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n/* vim:set foldmethod=marker: */"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst ll     MOD = 1000000007;\nconst double EPS = 1e-8;\n\nll memo[210][810];\nll calc(int i, int k, ll dp[210][810], ll len){\n    if(i == 0) return (k == 0 ? 1 : 0);\n    if(k <  0) return 0;\n    if(memo[i][k] != -1) return memo[i][k];\n    return memo[i][k] = dp[i][k] - calc(i - 1, k - len, dp, len);\n}\n\nll fact[210], ifact[210];\nll inv[210];\nll pow_10[210];\nvoid init(int N){\n    pow_10[0] = 1;\n    for(int i = 1; i <= N; i++){\n        pow_10[i] = pow_10[i - 1] * 10 % MOD;\n    }\n    inv[1] = 1;\n    for (int i = 2; i <= N; ++i){\n        inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n    }\n    fact[0] = 1, ifact[0] = 1;\n    for(int i = 1; i <= N; i++){\n        fact[i] = fact[i - 1] * i % MOD;\n        ifact[i] = ifact[i - 1] * inv[i] % MOD;\n    }\n}\nll C(int n, int r){\n    if(n < 0 || r < 0 || r > n) return 0;\n    if(r > n / 2) r = n - r;\n    return fact[n] * ifact[n - r] % MOD * ifact[r] % MOD;\n}\nll solve(vector<ll> a, vector<ll> len){\n    int n = a.size();\n    ll dp[210][810] = {};\n    dp[0][0] = 1;\n    for(int i = 0; i < n; i++){\n        for(int j = i; j >= 0; j--){\n            for(int k = 4 * i; k >= 0; k--){\n                dp[j + 1][k + len[i]] += dp[j][k];\n                dp[j + 1][k + len[i]] %= MOD;\n            }\n        }\n    }\n\n    ll ways_left[210] = {};\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j <= i; j++){\n            ways_left[i] += C(i, j) * fact[j] % MOD;\n        }\n    }\n    ll ans = 0;\n    REP(i, n){\n        REP(j, 210) REP(k, 810) memo[j][k] = -1;\n        for(int j = 0; j <= n - 1; j++){\n            for(int k = 0; k <= j * 4; k++){\n                //printf(\"(%d, %d, %d) = %lld\\n\", i, j, k, ways_left[n - 1 - j] * a[i] % MOD * pow_10[k] % MOD * calc(j, k, dp, len[i]) % MOD * fact[j] % MOD);\n                ans += ways_left[n - 1 - j] * a[i] % MOD * pow_10[k] % MOD * calc(j, k, dp, len[i]) % MOD * fact[j] % MOD;\n                ans %= MOD;\n            }\n        }\n    }\n    return ans;\n}\n\nint main(){\n    init(210);\n    int n;\n    while(cin >> n){\n        vector<ll> a(n);\n        vector<ll> len(n);\n        vector<ll> b;\n        vector<ll> len2;\n        REP(i, n){\n            string s;\n            cin >> s;\n            len[i] = s.size();\n            a[i] = atoi(s.c_str());\n            if(a[i] != 0){\n                b.push_back(a[i]);\n                len2.push_back(len[i]);\n            }\n        }\n        if(a.size() == b.size()){\n            cout << solve(a, len) << endl;\n        }else{\n            cout << (solve(a, len) - solve(b, len2) + MOD) % MOD << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n#define MOD 1000000007 // prime\nconst int SIZE = 100100;\nll inv[SIZE+10],fac[SIZE+10],facinv[SIZE+10];\nll Pow[1010],kai[210];\nll val[210];\nll nCr(int n,int r)\n{\n\tif(n<r)return -1;\n\tif(n<0||r<0)return -1;\n\treturn ((fac[n]*facinv[r]%MOD)*facinv[n-r])%MOD;\n}\nll func(int n)\n{\n\tll ret = 0ll;\n\tfor(int i=0;i<=n;i++)ret = (ret+(nCr(n,i)*kai[i])%MOD)%MOD;\n\treturn ret;\n}\nvoid init()\n{\n\tfac[0]=1ll;\n\tfor(int i=1;i<=SIZE;i++)fac[i]=(fac[i-1]*i)%MOD;\n\tinv[1]=1ll;\n\tfor(int i=2;i<=SIZE;i++)inv[i]=((-(MOD/i)*inv[MOD%i])%MOD+MOD)%MOD;\n\tfacinv[0]=1ll;\n\tfor(int i=1;i<=SIZE;i++)facinv[i]=(facinv[i-1]*inv[i])%MOD;\n\tPow[0]=1ll;\n\tfor(int i=0;i<1000;i++)Pow[i+1]=(Pow[i]*10ll)%MOD;\n\tkai[0]=1ll;\n\tfor(int i=1;i<=200;i++)kai[i]=(kai[i-1]*i)%MOD;\n\tfor(int i=0;i<=200;i++)val[i]=func(i);\n}\nint cnt_digit(ll x)\n{\n\tif(x==0ll)return 1;\n\tint ret = 0;\n\twhile(x){ret++;x/=10ll;}\n\treturn ret;\n}\nint dp[210][1010];\nint n;\nll a[210];\nint dig[210];\nint digit_sum[5];\nint del[5];\nint zero=-1;\nint N;\nvoid culc_dp(int unuse)\n{\n\tmemset(dp,0,sizeof(dp));\n\tdp[0][0]=1;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tif(i==unuse)continue;\n\t\tfor(int j=i;j>=0;j--)\n\t\t{\n\t\t\tfor(int k=0;k<=j*4;k++)\n\t\t\t{\n\t\t\t\tif(dp[j][k]==0)continue;\n\t\t\t\tdp[j+1][k+dig[i]]+=dp[j][k];\n\t\t\t}\n\t\t}\n\t}\n}\nll solve()\n{\n\tll ans = 0ll;\n\tfor(int d=1;d<=4;d++)\n\t{\n\t\tif(del[d]==-1)continue;\n\t\tculc_dp(del[d]);\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=4*N;j++)\n\t\t\t{\n\t\t\t\tif(dp[i][j]==0)continue;\n\t\t\t\tans += (((((((val[N-i-1]*kai[i])%MOD)*digit_sum[d])%MOD)*dp[i][j])%MOD)*Pow[j])%MOD;\n\t\t\t\tans %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tinit();\n\tmemset(del,-1,sizeof(del));\n\tscanf(\"%d\",&n);\n\tN=n;\n\tfor(int i=0;i<n;i++)scanf(\"%lld\",&a[i]);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tdig[i]=cnt_digit(a[i]);\n\t\tdigit_sum[dig[i]]+=a[i];\n\t\tdel[dig[i]]=i;\n\t\tif(a[i]==0)zero=i;\n\t}\n\tll ans = solve();\n\tif(zero!=-1)\n\t{\n\t\tswap(a[zero],a[n-1]);\n\t\tN--;\n\t\tmemset(del,-1,sizeof(del));\n\t\tmemset(digit_sum,0,sizeof(digit_sum));\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tdig[i]=cnt_digit(a[i]);\n\t\t\tdigit_sum[dig[i]]+=a[i];\n\t\t\tdel[dig[i]]=i;\n\t\t}\n\t\tans -= solve();\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nll M = 1000000007;\n\nint digit(int x){\n\tif(x == 0)return 0;\n\tif(x < 10)return 1;\n\treturn digit(x/10)+1;\n}\n\nll modpow(ll x,ll k){\n\tif(k == 0)return 1;\n\tll ret = modpow(x,k/2);\n\tret *= ret; ret %= M;\n\tif(k%2 == 1){ ret *= x; ret %= M; }\n\treturn ret;\n}\n\nll inv(ll x){\n\treturn modpow(x,M-2);\n}\n\nll C[202][202];\nvoid C_init(){\n\trep(i,202){\n\t\tC[i][0] = 1;\n\t\trep1(j,i){\n\t\t\tC[i][j] = C[i][j-1]*(i-j+1); C[i][j] %= M;\n\t\t\tC[i][j] *= inv(j); C[i][j] %= M;\n\t\t}\n\t}\n}\n\nll F[202],G[202];\nvoid FG_init(){\n\trep(x,202){\n\t\tF[x] = 0;\n\t\tG[x] = 0;\n\t\tll a = 1;\n\t\trep(i,x+1){\n\t\t\tF[x] += a;\n\t\t\tG[x] += a*(i+1);\n\t\t\tif(i < x){ a *= x-i; a %= M; }\n\t\t}\n\t\tF[x] %= M;\n\t\tG[x] %= M;\n\t}\n}\n\nll H[202];\nvoid H_init(){\n\tH[0] = 1;\n\trep1(i,201){\n\t\tH[i] = H[i-1]*i;\n\t\tH[i] %= M;\n\t}\n}\n\nint main(){\n\tC_init();\n\tFG_init();\n\tH_init();\n\tint n;\n\tint a[202];\n\tscanf(\"%d\",&n);\n\trep(i,n)scanf(\"%d\",&a[i]);\n\t\n\tint dig[202];\n\trep(i,n)dig[i] = digit(a[i]);\n\t\n\tint c[5] = {};\n\tint sum[5] = {};\n\trep(i,n){\n\t\tc[dig[i]] ++;\n\t\tsum[dig[i]] += a[i];\n\t}\n\t\n\tll ret = 0;\n\trep1(d,4){\n\t\tif(c[d] == 0)continue;\n\t\tc[d] --;\n\t\tint b[5];\n\t\tb[0] = 0;\n\t\tfor(;b[0]<=c[0];b[0]++){\n\t\t\tb[1] = 0;\n\t\t\tfor(;b[1]<=c[1];b[1]++){\n\t\t\t\tb[2] = 0;\n\t\t\t\tfor(;b[2]<=c[2];b[2]++){\n\t\t\t\t\tb[3] = 0;\n\t\t\t\t\tfor(;b[3]<=c[3];b[3]++){\n\t\t\t\t\t\tb[4] = 0;\n\t\t\t\t\t\tfor(;b[4]<=c[4];b[4]++){\n\t\t\t\t\t\t//\tprintf(\"%d;%d %d %d %d %d\\n\",d,b[0],b[1],b[2],b[3],b[4]);\n\t\t\t\t\t\t\tll ret_ = 1;\n\t\t\t\t\t\t\trep(i,5){ ret_ *= C[c[i]][b[i]]; ret_ %= M; }\n\t\t\t\t\t\t//\tcout << ret_ << endl;\n\t\t\t\t\t\t\tret_ *= H[b[0]+b[1]+b[2]+b[3]+b[4]]; ret_ %= M;\n\t\t\t\t\t\t//\tcout << ret_ << endl;\n\t\t\t\t\t\t\tret_ *= modpow(10,b[0]+b[1]+2*b[2]+3*b[3]+4*b[4]); ret_ %= M;\n\t\t\t\t\t\t//\tcout << ret_ << endl;\n\t\t\t\t\t\t\tif(c[0]-b[0] == 0){ ret_ *= F[c[0]+c[1]+c[2]+c[3]+c[4]-b[0]-b[1]-b[2]-b[3]-b[4]]; ret_ %= M; }\n\t\t\t\t\t\t\telse { ret_ *= G[c[1]+c[2]+c[3]+c[4]-b[1]-b[2]-b[3]-b[4]]; ret_ %= M; }\n\t\t\t\t\t\t//\tcout << ret_ << endl;\n\t\t\t\t\t\t\tret += ret_*sum[d];\n\t\t\t\t\t\t\tret %= M;\n\t\t\t\t\t\t//\tcout << ret << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tc[d] ++;\n\t}\n\t\n\tcout << ret << endl;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\ntypedef long long ll;\nint n,a[200],d[5]={};\nll MOD=1e9+7;\nll dp[5][2][201][1000],p10[1000],frac[201],p[201][201],sump[201];\nint dig(int x){\n\tif(x<10) return 0;\n\tif(x<100) return 1;\n\tif(x<1000) return 2;\n\tif(x<10000) return 3;\n\treturn 4;\n}\nll add(ll &x,ll y){\n\tx+=y;\n\tif(x>=MOD) x%=MOD;\n}\nll solve(){\n\trep(i,n){\n\t\td[dig(a[i])]++;\n\t}\n\trep(i,5){\n\t\tif(d[i]==0) continue;\n\t\tvector<int> vc;\n\t\trep(j,5) rep(k,d[j]){\n\t\t\tif(i==j&&k==0) continue;\n\t\t\tvc.pb(j+1);\n\t\t}\n\t\tdp[i][0][0][0]=1;\n\t\trep(ii,vc.size()){\n\t\t\trep(j,vc.size()+1) rep(k,1000) dp[i][1-ii%2][j][k]=0;\n\t\t\trep(j,vc.size()+1) rep(k,1000){\n\t\t\t\tadd(dp[i][1-ii%2][j][k],dp[i][ii%2][j][k]);\n//\t\t\t\tif(k<5) printf(\"dp[%d][%d][%d][%d]=%d\\n\",i,1+ii,j,k,dp[i][1-ii%2][j][k]);\n\t\t\t\tif(k+vc[j]<1000){\n\t\t\t\t\tadd(dp[i][1-ii%2][j+1][k+vc[j]],dp[i][ii%2][j][k]);\n//\t\t\t\t\tif(k<5) printf(\"dp[%d][%d][%d][%d]=%d\\n\",i,1+ii,j+1,k+vc[j],dp[i][1-ii%2][j+1][k+vc[j]]);\n\t\t\t\t}\n\t\t\t}\n//\t\t\trep(j,vc.size()+1) rep(k,5) printf(\"dp[%d][%d][%d][%d]=%d\\n\",i,1+ii,j,k,dp[i][1-ii%2][j][k]);\n\t\t}\n\t}\n\tll ans=0;\n\tll dsum[5]={};\n\trep(i,n) dsum[dig(a[i])]+=a[i];\n\trep(i,5){\n\t\trep(j,n){\n\t\t\trep(k,1000){\n\t\t\t\tadd(ans,dsum[i]*dp[i][1-n%2][j][k]%MOD*sump[n-j-1]%MOD*frac[j]%MOD*p10[k]%MOD);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\trep(i,201) p[i][0]=1;\n\trep(i,201){\n\t\trep(j,i) p[i][j+1]=p[i][j]*(i-j);\n\t}\n\trep(i,201) rep(j,i+1) add(sump[i],p[i][j]);\n\tp10[0]=1,frac[0]=1;\n\trep(i,999) p10[i+1]=p10[i]*10%MOD;\n\trep(i,200) frac[i+1]=frac[i]*(i+1)%MOD;\n\tcin>>n;\n\trep(i,n) scanf(\"%d\",a+i);\n\tsort(a,a+n);\n\tll ans=solve();\n\tif(a[0]==0){\n\t\tswap(a[0],a[n-1]);\n\t\tn--;\n\t\tsort(a,a+n);\n\t\trep(i,5) rep(ii,2) rep(j,201) rep(k,1000) dp[i][ii][j][k]=0;\n\t\trep(i,5) d[i]=0;\n\t\tll mn=solve();\n\t\tans-=mn;\n\t\tans=(ans%MOD+MOD)%MOD;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\nint n,a[200];\nll func[201],perm[201][201],sump[201],p10[801],dp[4][2][201][801];\nll mod=1e9+7;\nint dig(int x){\n\tif(x<10) return 0;\n\tif(x<100) return 1;\n\tif(x<1000) return 2;\n\treturn 3;\n}\nvoid add(ll &x,ll y){\n\tx+=y;\n\tif(x>=mod) x%=mod;\n}\nll solve(){\n\tint cntd[4]={},sumd[4]={};\n\trep(i,n) cntd[dig(a[i])]++;\n\trep(i,n) sumd[dig(a[i])]+=a[i];\n\trep(d,4){\n\t\tif(cntd[d]==0) continue;\n\t\tvector<int> vc;\n\t\trep(i,4) rep(j,cntd[i]){\n\t\t\tif(i==d&&j==0) continue;\n\t\t\tvc.push_back(i+1);\n\t\t}\n\t\tdp[d][0][0][0]=1;\n\t\trep(i,vc.size()){\n\t\t\trep(j,vc.size()+1) rep(k,801) dp[d][1-i%2][j][k]=0;\n\t\t\trep(j,vc.size()+1){\n\t\t\t\trep(k,801){\n\t\t\t\t\tif(dp[d][i%2][j][k]==0) continue;\n\t\t\t\t\tadd(dp[d][1-i%2][j][k],dp[d][i%2][j][k]);\n\t\t\t\t\tadd(dp[d][1-i%2][j+1][k+vc[i]],dp[d][i%2][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans=0;\n\trep(d,4){\n\t\tif(cntd[d]==0) continue;\n\t\trep(j,n) rep(k,801) add(ans,sumd[d]*dp[d][1-n%2][j][k]%mod*func[j]%mod*sump[n-1-j]%mod*p10[k]);\n\t}\n\treturn ans;\n}\nint main(){\n\tfunc[0]=1;\n\trep(i,200) func[i+1]=func[i]*(i+1)%mod;\n\trep(i,201) perm[i][0]=1;\n\trep(i,201) rep(j,i) perm[i][j+1]=perm[i][j]*(i-j)%mod;\n\trep(i,201) rep(j,i+1) add(sump[i],perm[i][j]);\n\tp10[0]=1;\n\trep(i,800) p10[i+1]=p10[i]*10%mod;\n\tcin>>n;\n\trep(i,n) cin>>a[i];\n\tll ans=solve();\n\tsort(a,a+n);\n\tif(a[0]==0){\n\t\tswap(a[n-1],a[0]);\n\t\tn--;\n\t\trep(i,4) rep(j,2) rep(k,201) rep(l,801) dp[i][j][k][l]=0;\n\t\tll mn=solve();\n\t\tans=(ans-mn+mod)%mod;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MD = 1e9+7;\nconst int MN = 210;\nconst int MM = 4;\nconst int MS = MN*MM;\n\nint n;\nstring s[MN];\nint si[MN];\nint sd[MN];\n\nll inv2;\nll pow10[MS];\nll facdp[MN];\n\nll dp1[MN][MS], dp2[MN][MS];\nll calc() {\n    inv2 = (MD+1)/2;\n    pow10[0] = 1;\n    for (int i = 1; i < MS; i++) {\n        pow10[i] = pow10[i-1] * 10;\n        pow10[i] %= MD;\n    }\n\n    for (int i = 0; i < MN; i++) {\n        facdp[i] = 0;\n        for (int j = 1; j <= i+1; j++) {\n            ll sm = 1;\n            for (int k = j; k <= i; k++) {\n                sm *= k;\n                sm %= MD;\n            }\n            facdp[i] += sm;\n            facdp[i] %= MD;\n        }\n    }\n\n    // for (int i = 0; i < 5; i++) {\n    //     cout << facdp[i] << \" \";\n    // } cout << endl;\n    for (int i = 0; i < n; i++) {\n        si[i] = stoi(s[i]);\n        sd[i] = (int)s[i].size();\n    }\n    memset(dp1, 0, sizeof(dp1));\n    dp1[0][0] = 1;\n    for (int fe = 0; fe < n; fe++) {\n        int nsd = sd[fe];\n        for (int i = 0; i < MN; i++) {\n            for (int j = 0; j < MS; j++) {\n                dp2[i][j] = dp1[i][j];\n                if (i >= 1 && j >= nsd) {\n                    dp2[i][j] += i*dp1[i-1][j-nsd];\n                    dp2[i][j] %= MD;\n                }\n            }\n        }\n        memcpy(dp1, dp2, sizeof(dp1));\n    }\n\n    // for (int i = 0; i <= n; i++) {\n    //     for (int j = 0; j < 10; j++) {\n    //         cout << dp1[i][j] << \" \";\n    //     } cout << endl;\n    // }\n    ll sm = 0;\n    for (int fe = 0; fe < n; fe++) {\n        int nsd = sd[fe];\n        for (int i = 0; i < MN; i++) {\n            for (int j = 0; j < MS; j++) {\n                dp2[i][j] = dp1[i][j];\n                if (i >= 1 && j >= nsd) {\n                    dp2[i][j] -= i*dp2[i-1][j-nsd];\n                    dp2[i][j] = (dp2[i][j]%MD+MD) % MD;\n                }\n                sm += pow10[j] * dp2[i][j] %MD * si[fe] %MD * facdp[n-i-1] %MD;\n                sm %= MD;\n            }\n        }\n    }\n    return sm;\n}\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> s[i];\n    }\n    sort(s, s+n, [&](const string &l, const string &r){\n        return stoi(l) < stoi(r);\n    });\n\n    ll u = calc();\n    if (s[0] == \"0\") {\n        reverse(s, s+n);\n        reverse(s, s+n-1);\n        n--;\n        u -= calc();\n        u = (u+MD) % MD;\n    }\n    cout << u << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst ll     MOD = 1000000007;\nconst double EPS = 1e-8;\n\nll memo[210][810];\nll calc(int i, int k, ll dp[210][810], ll len){\n    if(i == 0) return (k == 0 ? 1 : 0);\n    if(k <  0) return 0;\n    if(memo[i][k] != -1) return memo[i][k];\n    return memo[i][k] = (dp[i][k] - calc(i - 1, k - len, dp, len + MOD)) % MOD;\n}\n\nll fact[210], ifact[210];\nll inv[210];\nll pow_10[210];\nvoid init(int N){\n    pow_10[0] = 1;\n    for(int i = 1; i <= N; i++){\n        pow_10[i] = pow_10[i - 1] * 10 % MOD;\n    }\n    inv[1] = 1;\n    for (int i = 2; i <= N; ++i){\n        inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n    }\n    fact[0] = 1, ifact[0] = 1;\n    for(int i = 1; i <= N; i++){\n        fact[i] = fact[i - 1] * i % MOD;\n        ifact[i] = ifact[i - 1] * inv[i] % MOD;\n    }\n}\nll C(int n, int r){\n    if(n < 0 || r < 0 || r > n) return 0;\n    if(r > n / 2) r = n - r;\n    return fact[n] * ifact[n - r] % MOD * ifact[r] % MOD;\n}\nll solve(vector<ll> a, vector<ll> len){\n    int n = a.size();\n    ll dp[210][810] = {};\n    dp[0][0] = 1;\n    for(int i = 0; i < n; i++){\n        for(int j = i; j >= 0; j--){\n            for(int k = 4 * i; k >= 0; k--){\n                dp[j + 1][k + len[i]] += dp[j][k];\n                dp[j + 1][k + len[i]] %= MOD;\n            }\n        }\n    }\n\n    ll ways_left[210] = {};\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j <= i; j++){\n            ways_left[i] += C(i, j) * fact[j] % MOD;\n            ways_left[i] %= MOD;\n        }\n    }\n    ll ans = 0;\n    REP(i, n){\n        REP(j, 210) REP(k, 810) memo[j][k] = -1;\n        for(int j = 0; j <= n - 1; j++){\n            for(int k = 0; k <= j * 4; k++){\n                //printf(\"(%d, %d, %d) = %lld\\n\", i, j, k, ways_left[n - 1 - j] * a[i] % MOD * pow_10[k] % MOD * calc(j, k, dp, len[i]) % MOD * fact[j] % MOD);\n                ans += ways_left[n - 1 - j] * a[i] % MOD * pow_10[k] % MOD * calc(j, k, dp, len[i]) % MOD * fact[j] % MOD;\n                ans %= MOD;\n            }\n        }\n    }\n    return ans;\n}\n\nint main(){\n    init(210);\n    int n;\n    while(cin >> n){\n        vector<ll> a(n);\n        vector<ll> len(n);\n        vector<ll> b;\n        vector<ll> len2;\n        REP(i, n){\n            string s;\n            cin >> s;\n            len[i] = s.size();\n            a[i] = atoi(s.c_str());\n            if(a[i] != 0){\n                b.push_back(a[i]);\n                len2.push_back(len[i]);\n            }\n        }\n        if(a.size() == b.size()){\n            cout << solve(a, len) << endl;\n        }else{\n            cout << (solve(a, len) - solve(b, len2) + 2 * MOD) % MOD << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___CLASS_MODINT\n#define ___CLASS_MODINT\n\n#include <cstdint>\n\ntemplate<std::uint32_t mod>\nclass modint {\nprivate:\n\tstd::uint32_t n;\npublic:\n\tmodint() : n(0) {};\n\tmodint(std::uint64_t n_) : n(n_ % mod) {};\n\tbool operator==(const modint& m) const { return n == m.n; }\n\tbool operator!=(const modint& m) const { return n != m.n; }\n\tstd::uint32_t get() const { return n; }\n\tmodint& operator+=(const modint& m) { n += m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator-=(const modint& m) { n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator*=(const modint& m) { n = std::uint64_t(n) * m.n % mod; return *this; }\n\tmodint operator+(const modint& m) const { return modint(*this) += m; }\n\tmodint operator-(const modint& m) const { return modint(*this) -= m; }\n\tmodint operator*(const modint& m) const { return modint(*this) *= m; }\n\tmodint binpow(std::uint64_t b) const {\n\t\tmodint ans = 1, m = modint(*this);\n\t\twhile (b) {\n\t\t\tif (b & 1) ans *= m;\n\t\t\tm *= m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\tmodint inv() { return (*this).binpow(mod - 2); }\n};\n\n#endif // ___CLASS_MODINT\n\n#include <vector>\n#include <iostream>\nusing namespace std;\nusing modulo = modint<1000000007>;\nmodulo solve(vector<int> A) {\n\tint N = A.size();\n\tvector<int> D(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x = A[i];\n\t\twhile (x > 0) {\n\t\t\tx /= 10;\n\t\t\t++D[i];\n\t\t}\n\t\tif (A[i] == 0) D[i] = 1;\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < N; ++i) sum += D[i];\n\tvector<modulo> pw(sum + 1); pw[0] = 1;\n\tfor (int i = 1; i <= sum; ++i) pw[i] = pw[i - 1] * 10;\n\tvector<vector<modulo> > dp(N + 1);\n\tdp[0] = { modulo(1) };\n\tfor (int i = 0; i < N; ++i) {\n\t\tdp[i + 1].resize(i + 2);\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tdp[i + 1][j] += dp[i][j];\n\t\t\tdp[i + 1][j + 1] += dp[i][j] * pw[D[i]];\n\t\t}\n\t}\n\tvector<vector<modulo> > rdp(N + 1);\n\trdp[N] = { modulo(1) };\n\tfor (int i = N - 1; i >= 0; --i) {\n\t\trdp[i].resize(N - i + 1);\n\t\tfor (int j = 0; j <= N - i - 1; ++j) {\n\t\t\trdp[i][j] += rdp[i + 1][j];\n\t\t\trdp[i][j + 1] += rdp[i + 1][j] * pw[D[i]];\n\t\t}\n\t}\n\tvector<vector<modulo> > comb(N + 1);\n\tfor (int i = 0; i <= N; ++i) {\n\t\tcomb[i].resize(i + 1);\n\t\tcomb[i][0] = 1;\n\t\tfor (int j = 1; j <= i; ++j) {\n\t\t\tcomb[i][j] += comb[i - 1][j - 1];\n\t\t\tif (j != i) comb[i][j] += comb[i - 1][j];\n\t\t}\n\t}\n\tvector<modulo> fact(N + 1);\n\tvector<modulo> sumfact(N + 1);\n\tfact[0] = 1;\n\tsumfact[0] = 1;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfact[i] = fact[i - 1] * i;\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tsumfact[i] += fact[j] * comb[i][j];\n\t\t}\n\t}\n\tmodulo ans = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tfor (int k = 0; k <= N - i - 1; ++k) {\n\t\t\t\tmodulo sub = dp[i][j] * rdp[i + 1][k];\n\t\t\t\tans += sub * A[i] * fact[j + k] * sumfact[N - j - k - 1];\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\tint N;\n\tcin >> N;\n\tvector<int> A(N), ANZ;\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> A[i];\n\t\tif (A[i] != 0) ANZ.push_back(A[i]);\n\t}\n\tmodulo ans = solve(A);\n\tif (A != ANZ) ans -= solve(ANZ);\n\tcout << ans.get() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <numeric>\n\nconstexpr intmax_t mod = 1e9+7;\n\ntemplate <class Tp>\nTp gcd(Tp a, Tp b, Tp& x, Tp& y) {\n  x = Tp(0);\n  y = Tp(1);\n  for (Tp u=y, v=x; a;) {\n    Tp q = b/a;\n    std::swap(x-=q*u, u);\n    std::swap(y-=q*v, v);\n    std::swap(b-=q*a, a);\n  }\n  return b;\n}\n\ntemplate <class Tp>\nTp modinv(Tp a, Tp mod) {\n  Tp x, y;\n  gcd(a, mod, x, y);\n  x %= mod;\n  if (x < 0) x += mod;\n  return x;\n}\n\ntemplate <class Tp>\nTp modadd(Tp a, Tp b, Tp mod) {\n  a += b % mod;\n  if (a < 0) a += mod;\n  if (a >= mod) a -= mod;\n  return a;\n}\n\ntemplate <class Tp>\nTp modadd(const std::initializer_list<Tp>& adds, Tp mod) {\n  Tp res = 0;\n  for (const auto& add: adds) {\n    res += add % mod;\n    if (res < 0) res += mod;\n    if (res >= mod) res -= mod;\n  }\n  return res;\n}\n\ntemplate <class Tp>\nTp modsub(Tp a, Tp b, Tp mod) {\n  a -= b % mod;\n  if (a < 0) a += mod;\n  if (a >= mod) a -= mod;\n  return a;\n}\n\ntemplate <class Tp>\nTp modmul(const std::initializer_list<Tp>& muls, Tp mod) {\n  Tp res = 1;\n  for (const auto& mul: muls) (res *= mul) %= mod;\n  return res;\n}\n\ntemplate <class Tp>\nTp modpow(Tp base, intmax_t iexp, Tp mod) {\n  Tp res = 1;\n  for (Tp dbl = base; iexp; iexp >>= 1) {\n    if (iexp & 1) res = res * dbl % mod;\n    dbl = dbl * dbl % mod;\n  }\n  return res;\n}\n\nclass modfactorial {\n  std::vector<intmax_t> fact, fact_inv;\n  intmax_t mod;\n\npublic:\n  modfactorial(intmax_t N, intmax_t mod): mod(mod) {\n    fact.resize(N+1);\n    fact_inv.resize(N+1);\n    fact[0] = 1;\n    for (intmax_t i = 1; i <= N; ++i)\n      fact[i] = fact[i-1] * i % mod;\n\n    fact_inv[N] = modinv(fact[N], mod);\n    for (intmax_t i = N; i--;)\n      fact_inv[i] = fact_inv[i+1] * (i+1) % mod;\n  }\n\n  intmax_t operator ()(intmax_t k) const {\n    return fact[k];\n  }\n\n  intmax_t inverse(intmax_t k) const {\n    return fact_inv[k];\n  }\n};\n\ntemplate <class Tp>\nstd::vector<Tp> make_vector(size_t n, const Tp& x) {\n  return std::vector<Tp>(n, x);\n}\n\ntemplate <class... Ts>\nauto make_vector(size_t n, size_t m, const Ts&... x) {\n  return std::vector<decltype(make_vector(m, x...))>(n, make_vector(m, x...));\n}\n\nstd::vector<std::vector<intmax_t>> make_dp(std::vector<size_t> dig, size_t d) {\n  --dig[d];\n  size_t n = std::accumulate(dig.begin(), dig.end(), 0);\n  size_t m = 0;\n  for (size_t i = 1; i <= 4; ++i) m += i * dig[i];\n  auto dp = make_vector(n+1, n+1, m+1, intmax_t(0));\n  dp[0][0][0] = 1;\n\n  std::vector<size_t> ds;\n  ds.reserve(n);\n  for (size_t i = 1; i <= 4; ++i)\n    for (size_t j = 0; j < dig[i]; ++j)\n      ds.push_back(i);\n\n  for (size_t i = 0; i < n; ++i) {\n    for (size_t j = 0; j < n; ++j) {\n      for (size_t k = 0; k <= m; ++k) {\n        (dp[i+1][j][k] += dp[i][j][k]) %= mod;\n        if (k+ds[i] <= m) {\n          (dp[i+1][j+1][k+ds[i]] += (j+1) * dp[i][j][k]) %= mod;\n        }\n      }\n    }\n  }\n\n  return dp[n];\n}\n\nintmax_t solve(const std::vector<intmax_t>& a) {\n  size_t n = a.size();\n  std::vector<size_t> dig(5);\n  std::vector<intmax_t> sum(5);\n  for (auto ai: a) {\n    if (ai == 0) {\n      ++dig[1];\n      continue;\n    }\n    int d = 0;\n    for (int i = ai; i > 0; i /= 10) ++d;\n    ++dig[d];\n    (sum[d] += ai) %= mod;\n  }\n\n  modfactorial mf(n+1, mod);\n  auto coes = make_vector(n, n, intmax_t(0));\n  for (size_t j = 0; j < n; ++j)\n    for (size_t l = 0; l+j < n; ++l)\n      coes[j][l] = mf(n-1-j) * mf.inverse(n-1-j-l) % mod;\n\n  intmax_t res = 0;\n  for (int i = 1; i <= 4; ++i) {\n    if (!dig[i]) continue;\n    auto dp = make_dp(dig, i);\n\n    for (size_t j = 0; j < n; ++j) {\n      for (size_t l = 0; l+j < n; ++l) {\n        intmax_t cur = 0;\n        for (size_t k = 0; k < dp[j].size(); ++k) {\n          cur += modmul({sum[i], modpow(10L, k, mod), dp[j][k]}, mod);\n          if (cur >= mod) cur -= mod;\n        }\n        (res += cur * coes[j][l]) %= mod;\n      }\n    }\n  }\n  return res;\n}\n\nint main() {\n  size_t n;\n  scanf(\"%zu\", &n);\n\n  std::vector<intmax_t> a(n);\n  for (auto& ai: a) scanf(\"%jd\", &ai);\n\n  std::sort(a.rbegin(), a.rend());\n  intmax_t res = solve(a);\n  if (a[n-1] == 0) {\n    a.pop_back();\n    res -= solve(a);\n    if (res < 0) res += mod;\n  }\n\n  printf(\"%jd\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename Ostream,typename Container>\nOstream& operator<<(Ostream& os,const Container& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nll solve_naive(vi as)\n{\n\tint n=as.size();\n\tll sum=0,zero=0;\n\trepi(i,1,1<<n){\n\t\tvi is;\n\t\trep(j,n) if(i>>j&1) is.push_back(j);\n\t\tdo{\n\t\t\tstring s;\n\t\t\tfor(int i:is) s+=to_string(as[i]);\n\t\t\tll x=0;\n\t\t\tfor(char c:s) (x=x*10+c-'0')%=MOD;\n\t\t\t(sum+=x)%=MOD;\n\t\t\t//dump(x);\n\t\t\tif(s[0]=='0') (zero+=x)%=MOD;\n\t\t}while(next_permutation(all(is)));\n\t}\n\tdump(mp(sum,zero));\n\treturn (sum-zero+MOD)%MOD;\n}\n\nint ncr(int n,int r)\n{\n\tstatic int memo[300][300];\n\tif(memo[n][r]) return memo[n][r];\n\tif(r==0 || r==n) return 1;\n\treturn memo[n][r]=(ncr(n-1,r-1)+ncr(n-1,r))%MOD;\n}\n\nll solve(vi as)\n{\n\tvi tinvs(1000,1); // tinvs[i]=10^i mod m\n\trepi(i,1,tinvs.size()) tinvs[i]=(ll)tinvs[i-1]*10%MOD;\n\tvi finvs(200,1); // finvs[i]=i! mod m\n\trepi(i,1,finvs.size()) finvs[i]=(ll)finvs[i-1]*i%MOD;\n\t\n\tint n=as.size();\n\tvi ls(n);\n\trep(i,n){\n\t\tif(as[i]==0) ls[i]=1;\n\t\tfor(int x=as[i];x;x/=10) ls[i]++;\n\t}\n\t\n\tll res=0;\n\trep(i,n){\n\t\tvvl dp(n+1,vl(4*n+1)); // dp[下の桁に使った個数][下の桁の長さ]=下の桁に置く整数の選び方\n\t\tdp[0][0]=1;\n\t\trep(j,n) if(j!=i){\n\t\t\tvvl dp2=dp;\n\t\t\trep(lo,dp.size()) rep(len,dp[lo].size()) if(dp2[lo][len])\n\t\t\t\t(dp[lo+1][len+ls[j]]+=dp2[lo][len])%=MOD;\n\t\t}\n\t\t\n\t\tll tmp=0;\n\t\trep(lo,dp.size()) rep(len,dp[lo].size()) if(dp[lo][len]){\n\t\t\trep(hi,n-lo){\n\t\t\t\tll val=(ll)as[i]*tinvs[len]%MOD*dp[lo][len]%MOD;\n\t\t\t\tll locnt=finvs[lo];\n\t\t\t\tll hicnt=(ll)ncr(n-1-lo,hi)*finvs[hi]%MOD;\n\t\t\t\t(tmp+=val*locnt%MOD*hicnt%MOD)%=MOD;\n\t\t\t}\n\t\t}\n\t\t(res+=tmp)%=MOD;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvi as(n);\n\t\trep(i,n) cin>>as[i];\n\t\t\n\t\tll res=solve(as);\n\t\tif(count(all(as),0)){\n\t\t\tas.erase(find(all(as),0));\n\t\t\tll tmp=solve(as);\n\t\t\tres=(res-tmp+MOD)%MOD;\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst long long mod=1000000007;\n\nlong long pw[1000];\nlong long sum[300];\nlong long fact[300];\n\nvoid init(){\n\tpw[0]=1;\n\tfor(int i=1;i<1000;i++) pw[i]=(pw[i-1]*10)%mod;\n\tfact[0]=1;\n\tfor(int i=1;i<300;i++) fact[i]=(fact[i-1]*i)%mod;\n\tfor(int i=0;i<300;i++){\n\t\tif(i==0){\n\t\t\tsum[i]=1;\n\t\t\tcontinue;\n\t\t}\n\t\tlong long tmp=1;\n\t\tsum[i]=1;\n\t\tfor(int j=i;j>=0;j--){\n\t\t\ttmp=(tmp*j)%mod;\n\t\t\tsum[i]=(sum[i]+tmp)%mod;\n\t\t}\n\t}\n}\n\nint getDig(int n){\n\tif(n==0) return 1;\n\tint c=0;\n\twhile(n>0){\n\t\tn/=10;\n\t\tc++;\n\t}\n\treturn c;\n}\n\nvector<int> digs;\nlong long dp[2][201][801];\n\nlong long dp2[5][201][801];\nbool checked[5];\n\nlong long solve(vector<int> vec){\n\tlong long res=0;\n\tfor(int i=0;i<5;i++) checked[i]=false;\n\tint N=vec.size();\n\tfor(int i=0;i<N;i++){\n\t\tint k=getDig(vec[i]);\n\t\tint t=0;\n\t\tif(checked[k]) goto end_dp;\n\t\tchecked[k]=true;\n\t\tdigs.clear();\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(i==j) continue;\n\t\t\tdigs.push_back(getDig(vec[j]));\n\t\t}\n\t\tfor(int a=0;a<=200;a++) for(int b=0;b<=800;b++) dp[0][a][b]=0;\n\t\tdp[0][0][0]=1;\n\t\tt=0;\n\t\tfor(int j=0;j<N-1;j++){\n\t\t\tfor(int a=0;a<=200;a++) for(int b=0;b<=800;b++) dp[1-t][a][b]=0;\n\t\t\tfor(int a=0;a<=200;a++) for(int b=0;b<=800;b++){\n\t\t\t\tdp[1-t][a][b]+=dp[t][a][b];\n\t\t\t\tif(a+1<=200&&b+digs[j]<=800){\n\t\t\t\t\tdp[1-t][a+1][b+digs[j]]+=dp[t][a][b];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int a=0;a<=200;a++) for(int b=0;b<=800;b++){\n\t\t\t\tdp[1-t][a][b]%=mod;\n\t\t\t}\n\t\t\tt=1-t;\n\t\t}\n\t\tfor(int a=0;a<=200;a++) for(int b=0;b<=800;b++) dp2[k][a][b]=dp[t][a][b];\n\t\tend_dp:;\n\t\tfor(int a=0;a<=200;a++) for(int b=0;b<=800;b++){\n\t\t\tint c=N-1-a;\n\t\t\tlong long coe1=sum[c];\n\t\t\tlong long coe2=pw[b];\n\t\t\t//long long coe3=dp[t][a][b];\n\t\t\tlong long coe3=dp2[k][a][b];\n\t\t\tlong long tmp=(coe1*coe2)%mod;\n\t\t\ttmp*=coe3;\n\t\t\ttmp%=mod;\n\t\t\ttmp*=fact[a];\n\t\t\ttmp%=mod;\n\t\t\ttmp*=vec[i];\n\t\t\ttmp%=mod;\n\t\t\tres=(res+tmp)%mod;\n\t\t}\n\t}\n\treturn res;\n}\n\nint a[200];\n\nint main(){\n\tinit();\n\tint N;\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++) scanf(\"%d\",a+i);\n\tif(N==1){\n\t\tprintf(\"%d\\n\",a[0]);\n\t\treturn 0;\n\t}\n\tlong long ans=0;\n\tvector<int> tmp1,tmp2;\n\tfor(int i=0;i<N;i++){\n\t\ttmp1.push_back(a[i]);\n\t\tif(a[i]!=0) tmp2.push_back(a[i]);\n\t}\n\tans=solve(tmp1);\n\tif(tmp1.size()!=tmp2.size()) ans-=solve(tmp2);\n\tans%=mod;\n\tans+=mod;\n\tans%=mod;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n;\nll dp[5][201][1001];\nint calced[5];\nll P[1001];\nll P2[1001];\nll P3[1001];\n\nll solve(vector<string> &a, int t){\n\tint dig = a[t].size();\n\tint r = atoi(a[t].c_str());\n\tif(!calced[dig]){\n\t\tcalced[dig] = 1;\n\t\tdp[dig][0][0] = 1;\n\t\tREP(i, a.size()){\n\t\t\tif(i == t) continue;\n\t\t\tRREP(j, i+1)RREP(k, (i+1)*4){\n\t\t\t\tdp[dig][j+1][k+a[i].size()] += dp[dig][j][k];\n\t\t\t\tif(dp[dig][j+1][k+a[i].size()] > MOD) dp[dig][j+1][k+a[i].size()]-=MOD;\n\t\t\t}\n\t\t}\n\t}\n\tll sum=0;\n\tll tenp = 1;\n\tREP(j, 800){\n\t\tREP(i, a.size()){\n\t\t\tsum += (tenp*dp[dig][i][j])%MOD * P3[i];\n\t\t\tif(sum > MOD) sum %= MOD;\n\t\t}\n\t\ttenp *= 10;\n\t\tif(tenp > MOD) tenp %= MOD;\n\t}\n\treturn (r*sum)%MOD;\n}\n\nll C[1010][1010];\nvoid make_C(){\n    memset(C, 0, (int)sizeof(C));    \n    REP(i, 1000){\n        C[i][0] = C[i][i] = 1;\n        for(int j = 1; j < i; j++) C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;\n    }\n    REP(i, 1000)for(int j = 0; j <= i; j++) P2[i] = (P2[i] + C[i][j]*P[i-j]) % MOD;\n}\n\nmain(){\n\tP[0] = 1;\n\tREP(i, 1000) P[i+1] = (P[i] * (i+1))%MOD;\n\tmake_C();\n\twhile(cin >> n){\n\t\tmemset(calced, 0, sizeof(calced));\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tvector<string> a(n);\n\t\tREP(i, n) cin >> a[i];\n\t\tsort(RALL(a));\n\t\tll sum = 0;\n\t\tREP(i, a.size()) P3[i] = (P2[n-1-i] * P[i])%MOD;\n\t\tREP(i, n) sum += solve(a, i);\n\t\tif(a.back() == \"0\"){\n\t\t\tmemset(calced, 0, sizeof(calced));\n\t\t\tmemset(dp, 0, sizeof(dp));\n\t\t\ta.resize(a.size()-1);\n\t\t\tREP(i, a.size()) P3[i] = (P2[a.size()-1-i] * P[i])%MOD;\n\t\t\tREP(i, a.size()) sum -= solve(a, i);\n\t\t}\n\t\tcout << (sum%MOD+MOD)%MOD << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint M=1000000007;\n\nint f(vector<int> v,int s){\n  int dp[823][223]={};\n  dp[0][0]=1;\n  for(int i=0;i<4;i++){\n    for(int j=0;j<v[i];j++){\n      for(int k=800;k>=i+1;k--){\n\tfor(int l=200;l>0;l--){\n\t  dp[k][l]=(dp[k][l]+dp[k-(i+1)][l-1]*1LL*l)%M;\n\t}\n      }\n    }\n  }\n  int head[223]={1};\n  for(int i=1;i<=200;i++){\n    head[i]=(head[i-1]*1LL*i+1)%M;\n  }\n  int ans=0;\n  int n=v[0]+v[1]+v[2]+v[3];\n  int t=1;\n  for(int i=0;i<=800;i++,t=(t*10LL)%M){\n    for(int j=0;j<=n;j++){\n      ans=(ans+dp[i][j]*1LL*head[n-j]%M*s%M*t%M)%M;\n    }\n  }\n  return ans;\n}\n\nint solve(vector<int> a){\n  int nd[4]={};\n  int ds[4]={};\n  for(auto e:a){\n    int x=(e>=10)+(e>=100)+(e>=1000);\n    nd[x]++;\n    ds[x]=(ds[x]+e)%M;\n  }\n  int r=0;\n  r=(r+(nd[0]?f({nd[0]-1,nd[1],nd[2],nd[3]},ds[0]):0))%M;\n  r=(r+(nd[1]?f({nd[0],nd[1]-1,nd[2],nd[3]},ds[1]):0))%M;\n  r=(r+(nd[2]?f({nd[0],nd[1],nd[2]-1,nd[3]},ds[2]):0))%M;\n  r=(r+(nd[3]?f({nd[0],nd[1],nd[2],nd[3]-1},ds[3]):0))%M;\n  return r;\n}\n\nint main(){\n  int n;\n  cin>>n;\n  vector<int> a(n);\n  vector<int> nz;\n  for(int i=0;i<n;i++){\n    cin>>a[i];\n    if(a[i]){\n      nz.push_back(a[i]);\n    }\n  }\n  int ans=solve(a);\n  if(nz.size()<n){\n    ans=(ans-solve(nz)+M)%M;\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 201;\n\nll mod_pow(ll a,ll b)\n{\n    a %= MOD;\n    ll res = 1;\n    while(b){\n        if(b & 1){\n            res = res * a % MOD;\n        }\n        a = a * a % MOD;\n        b >>= 1;\n    }\n    return res;\n}\n\nll inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2;i<MAX_N;i++){\n\t\tinv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n\t\tfac[i] = fac[i-1] * (ll) i % MOD;\n\t\tfinv[i] = finv[i-1] * inv[i] % MOD;\n\t}\n}\n\nvoid extgcd(int a,int b, int& x,int& y)\n{\n\tif(b != 0){\n\t\textgcd(b,a%b,y,x);\n\t\ty -= (a/b)*x;\n\t}else{\n\t\tx = 1;\n\t\ty = 0;\n\t}\n}\n\nint mod_inverse(int a,int m)\n{\n\tint x,y;\n\textgcd(a,m,x,y);\n\treturn (m + x % m) % m;\n}\n\nll add(ll x,ll y)\n{\n    return (x + y)%MOD;\n}\n\nll sub(ll x,ll y)\n{\n    return (x+MOD-y)%MOD;\n}\n\nll mul(ll x,ll y)\n{\n    return x*y%MOD;\n}\n\nint dp[201][801];\nint dp2[201][801];\nint ten[801],smpow[201];\n\nint solve(vi& vec,vi&d,int n){\n    rep(j,n+1){\n        rep(k,801){\n            dp[j][k] = 0;\n        }\n    }\n    dp[0][0] = 1;\n    rep(i,n){\n        rrep(j,i+1){\n            rep(k,801){\n                if(dp[j][k]){\n                    dp[j+1][k+d[i]] = add(dp[j+1][k+d[i]],dp[j][k]);\n                }\n            }\n        }\n    }\n    ll ans = 0;\n    rep(i,n){\n        if(vec[i]){\n            rep(j,n+1){\n                rep(k,801){\n                    dp2[j][k] = dp[j][k];\n                }\n            }\n            rep(j,n){\n                srep(k,d[i],801){\n                    if(dp2[j][k-d[i]]){\n                        dp2[j+1][k] = sub(dp2[j+1][k],dp2[j][k-d[i]]);\n                    }\n                }\n            }\n            rep(j,n){\n                rep(k,801){\n                    if(dp2[j][k]){\n                        ans = add(ans,mul(mul(mul(dp2[j][k],smpow[n-j]),mul(ten[k],vec[i])),fac[j]));\n                    }\n                }\n            }\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    vi vec(n),d(n,0);\n    ten[0] = 1;\n    rep(i,801){\n        ten[i+1] = mul(ten[i],10);\n    }\n    make();\n    smpow[0] = 1;\n    rep(i,n){\n        rep(j,i+1){\n            smpow[i+1] = add(smpow[i+1],mul(fac[i],finv[j]));\n        }\n    }\n    bool flag = false;\n    rep(i,n){\n        cin >> vec[i];\n        if(vec[i] == 0){\n            flag = true;\n        }\n        int temp = vec[i];\n        if(temp){\n            while(temp){\n                ++d[i];\n                temp /= 10;\n            }\n        }else{\n            ++d[i];\n        }\n    }\n    int r1 = solve(vec,d,n),r2 = 0;\n    if(flag){\n        vi w,e;\n        rep(i,n){\n            if(vec[i]){\n                w.pb(vec[i]),e.pb(d[i]);\n            }\n        }\n        r2 = solve(w,e,n-1);\n    }\n    cout << sub(r1,r2) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nll M = 1000000007;\n\nint digit(int x){\n\tif(x == 0)return 0;\n\tif(x < 10)return 1;\n\treturn x/10+1;\n}\n\nll modpow(ll x,ll k){\n\tif(k == 0)return 1;\n\tll ret = modpow(x,k/2);\n\tret *= ret; ret %= M;\n\tif(k%2 == 1){ ret *= x; ret %= M; }\n\treturn ret;\n}\n\nll inv(ll x){\n\treturn modpow(x,M-2);\n}\n\nll C[202][202];\nvoid C_init(){\n\trep(i,202){\n\t\tC[i][0] = 1;\n\t\trep1(j,i){\n\t\t\tC[i][j] = C[i][j-1]*(i-j+1); C[i][j] %= M;\n\t\t\tC[i][j] *= inv(j); C[i][j] %= M;\n\t\t}\n\t}\n}\n\nll F[202],G[202];\nvoid FG_init(){\n\trep(x,202){\n\t\tF[x] = 0;\n\t\tG[x] = 0;\n\t\tll a = 1;\n\t\trep(i,x+1){\n\t\t\tF[x] += a;\n\t\t\tG[x] += a*(i+1);\n\t\t\tif(i < x){ a *= x-i; a %= M; }\n\t\t}\n\t\tF[x] %= M;\n\t\tG[x] %= M;\n\t}\n}\n\nll H[202];\nvoid H_init(){\n\tH[0] = 1;\n\trep1(i,201){\n\t\tH[i] = H[i-1]*i;\n\t\tH[i] %= M;\n\t}\n}\n\nint main(){\n\tC_init();\n\tFG_init();\n\tH_init();\n\tint n;\n\tint a[202];\n\tscanf(\"%d\",&n);\n\trep(i,n)scanf(\"%d\",&a[i]);\n\t\n\tint dig[202];\n\trep(i,n)dig[i] = digit(a[i]);\n\t\n\tint c[5] = {};\n\tint sum[5] = {};\n\trep(i,n){\n\t\tc[dig[i]] ++;\n\t\tsum[dig[i]] += a[i];\n\t}\n\t\n\tll ret = 0;\n\trep1(d,4){\n\t\tif(c[d] == 0)continue;\n\t\tc[d] --;\n\t\tint b[5];\n\t\tb[0] = 0;\n\t\tfor(;b[0]<=c[0];b[0]++){\n\t\t\tb[1] = 0;\n\t\t\tfor(;b[1]<=c[1];b[1]++){\n\t\t\t\tb[2] = 0;\n\t\t\t\tfor(;b[2]<=c[2];b[2]++){\n\t\t\t\t\tb[3] = 0;\n\t\t\t\t\tfor(;b[3]<=c[3];b[3]++){\n\t\t\t\t\t\tb[4] = 0;\n\t\t\t\t\t\tfor(;b[4]<=c[4];b[4]++){\n\t\t\t\t\t\t//\tprintf(\"%d;%d %d %d %d %d\\n\",d,b[0],b[1],b[2],b[3],b[4]);\n\t\t\t\t\t\t\tll ret_ = 1;\n\t\t\t\t\t\t\trep(i,5){ ret_ *= C[c[i]][b[i]]; ret_ %= M; }\n\t\t\t\t\t\t//\tcout << ret_ << endl;\n\t\t\t\t\t\t\tret_ *= H[b[0]+b[1]+b[2]+b[3]+b[4]]; ret_ %= M;\n\t\t\t\t\t\t//\tcout << ret_ << endl;\n\t\t\t\t\t\t\tret_ *= modpow(10,b[0]+b[1]+2*b[2]+3*b[3]+4*b[4]); ret_ %= M;\n\t\t\t\t\t\t//\tcout << ret_ << endl;\n\t\t\t\t\t\t\tif(c[0]-b[0] == 0){ ret_ *= F[c[0]+c[1]+c[2]+c[3]+c[4]-b[0]-b[1]-b[2]-b[3]-b[4]]; ret_ %= M; }\n\t\t\t\t\t\t\telse { ret_ *= G[c[1]+c[2]+c[3]+c[4]-b[1]-b[2]-b[3]-b[4]]; ret_ %= M; }\n\t\t\t\t\t\t//\tcout << ret_ << endl;\n\t\t\t\t\t\t\tret += ret_*sum[d];\n\t\t\t\t\t\t\tret %= M;\n\t\t\t\t\t\t//\tcout << ret << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tc[d] ++;\n\t}\n\t\n\tcout << ret << endl;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\ninline void add(int &x, int v) { x += v; if (x >= MOD) x -= MOD; }\ninline int mul(int x, int y) { return (1LL*x*y)%MOD; }\n\nint N;\nint fact[201];\nint A[200], C[200];\nint T[5][801][201];\nint nCr[201][201];\nint R[201];\nint num[5];\n\nvoid solve(int type) {\n  if (num[type] == 0) return;\n  auto &dp = T[type];\n  rep(i, 801) rep(j, 201) dp[i][j] = 0;\n  num[type]--;\n  dp[0][0] = 1;\n  for (int x=1; x<=4; x++) rep(_, num[x]) {\n    for (int j=800-x; j>=0; j--) {\n      for (int k=199; k>=0; k--) {\n        add(dp[j+x][k+1], dp[j][k]);\n      }\n    }\n  }\n  num[type]++;\n}\nint f() {\n  for (int i=1; i<=4; i++) solve(i);\n  int sum = 0;\n  rep(i, N) {\n    int p = A[i];\n    rep(s, 801) {\n      rep(k, N) {\n        if (T[C[i]][s][k] == 0) continue;\n        add(sum, mul(mul(mul(fact[k], T[C[i]][s][k]), p), R[N-1-k]));\n      }\n      p = (10LL*p)%MOD;\n    }\n  }\n  return sum;\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N) cin >> A[i];\n  sort(A, A+N, greater<int>());\n\n  fact[0] = 1;\n  for (int i=1; i<=200; i++) fact[i] = (1LL*i*fact[i-1]) % MOD;\n  nCr[0][0] = 1;\n  for (int i=1; i<=200; i++) {\n    nCr[i][0] = 1;\n    for (int j=1; j<=200; j++) nCr[i][j] = (nCr[i-1][j-1] + nCr[i-1][j]) % MOD;\n  }\n  rep(i, N+1) {\n    rep(j, i+1) add(R[i], mul(nCr[i][j], fact[j]));\n  }\n\n  bool has_zero = false;\n  rep(i, N) {\n    int x = A[i];\n    if (x == 0) {\n      C[i] = 1;\n      has_zero = true;\n    }\n    while (x) C[i]++, x/=10;\n    num[C[i]]++;\n  }\n  int sum = f();\n  if (has_zero) {\n    N--;\n    num[1]--;\n    add(sum, (MOD-f())%MOD);\n  }\n  cout << sum << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst ll     MOD = 1000000007;\nconst double EPS = 1e-8;\n\nll memo[210][810];\nll calc(int i, int k, ll dp[210][810], ll len){\n    if(i == 0) return (k == 0 ? 1 : 0);\n    if(k <  0) return 0;\n    if(memo[i][k] != -1) return memo[i][k];\n    return memo[i][k] = dp[i][k] - calc(i - 1, k - len, dp, len);\n}\n\nll fact[210], ifact[210];\nll inv[210];\nll pow_10[210];\nvoid init(int N){\n    pow_10[0] = 1;\n    for(int i = 1; i <= N; i++){\n        pow_10[i] = pow_10[i - 1] * 10 % MOD;\n    }\n    inv[1] = 1;\n    for (int i = 2; i <= N; ++i){\n        inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n    }\n    fact[0] = 1, ifact[0] = 1;\n    for(int i = 1; i <= N; i++){\n        fact[i] = fact[i - 1] * i % MOD;\n        ifact[i] = ifact[i - 1] * inv[i] % MOD;\n    }\n}\nll C(int n, int r){\n    if(n < 0 || r < 0 || r > n) return 0;\n    if(r > n / 2) r = n - r;\n    return fact[n] * ifact[n - r] % MOD * ifact[r] % MOD;\n}\nll solve(vector<ll> a, vector<ll> len){\n    int n = a.size();\n    ll dp[210][810] = {};\n    dp[0][0] = 1;\n    for(int i = 0; i < n; i++){\n        for(int j = i; j >= 0; j--){\n            for(int k = 4 * i; k >= 0; k--){\n                dp[j + 1][k + len[i]] += dp[j][k];\n                dp[j + 1][k + len[i]] %= MOD;\n            }\n        }\n    }\n\n    ll ways_left[210] = {};\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j <= i; j++){\n            ways_left[i] += C(i, j) * fact[j] % MOD;\n        }\n    }\n    ll ans = 0;\n    REP(i, n){\n        REP(j, 210) REP(k, 810) memo[j][k] = -1;\n        for(int j = 0; j <= n - 1; j++){\n            for(int k = 0; k <= j * 4; k++){\n                //printf(\"(%d, %d, %d) = %lld\\n\", i, j, k, ways_left[n - 1 - j] * a[i] % MOD * pow_10[k] % MOD * calc(j, k, dp, len[i]) % MOD * fact[j] % MOD);\n                ans += ways_left[n - 1 - j] * a[i] % MOD * pow_10[k] % MOD * calc(j, k, dp, len[i]) % MOD * fact[j] % MOD;\n                ans %= MOD;\n            }\n        }\n    }\n    return ans;\n}\n\nint main(){\n    init(210);\n    int n;\n    while(cin >> n){\n        vector<ll> a(n);\n        vector<ll> len(n);\n        vector<ll> b;\n        vector<ll> len2;\n        REP(i, n){\n            string s;\n            cin >> s;\n            len[i] = s.size();\n            a[i] = atoi(s.c_str());\n            if(a[i] != 0){\n                b.push_back(a[i]);\n                len2.push_back(len[i]);\n            }\n        }\n        if(a.size() == b.size()){\n            cout << solve(a, len) << endl;\n        }else{\n            clock_t start = clock();\n            while(clock() - start < CLOCKS_PER_SEC);\n            cout << (solve(a, len) - solve(b, len2) + MOD) % MOD << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n  \nusing namespace std;\n  \n\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n  \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void unique(vector<T>& c) { c.erase(unique(c.begin(), c.end()), c.end()); }\ntemplate <class T> void sort_unique(vector<T>& c) { sort(c); unique(c); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n  \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n \nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n  \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\n\nconst int M = 210 * 5;\nll fact[210];\nll combi[210][210];\nll ten_pow[M];\nvector<vector<ll> > digits_dp(const vector<int>& digits)\n{\n    int n = digits.size();\n\n    static ll dp[210][M + 30];\n    CL(dp, 0);\n    dp[0][0] = 1;\n    for (int i = 0; i < n; ++i)\n        for (int j = i; j >= 0; --j)\n            for (int k = 5 * i; k >= 0; --k)\n                (dp[j + 1][k + digits[i]] += dp[j][k]) %= mod;\n\n\n\n    vector<vector<ll> > res(n + 1, vector<ll>(M));\n    for (int i = 0; i <= n; ++i)\n        for (int j = 0; j < M; ++j)\n            res[i][j] = dp[i][j];\n    return res;\n}\nll gao(const vector<int>& a, const vector<int>& digits)\n{\n    int n = a.size();\n\n    ll res = 0;\n    for (int i = 0; i < n; ++i)\n    {\n        vector<int> d;\n        for (int j = 0; j < n; ++j)\n            if (i != j)\n                d.push_back(digits[j]);\n        vector<vector<ll> > d_pat = digits_dp(d);\n\n        for (int j = 0; j < n; ++j)\n        {\n            for (int k = 0; k < M; ++k)\n            {\n                ll pat = 0;\n                for (int u = 0; u <= (n - 1) - j; ++u)\n                    (pat += (combi[(n - 1) - j][u] * fact[u] % mod) * fact[j]) %= mod;\n                (pat *= d_pat[j][k]) %= mod;\n\n                (res += ((a[i] * ten_pow[k]) % mod) * pat) %= mod;\n            }\n        }\n    }\n\n    return res;\n}\nint main()\n{\n    fact[0] = 1;\n    for (int i = 1; i < 210; ++i)\n        fact[i] = (fact[i - 1] * i) % mod;\n\n    for (int i = 0; i < 210; ++i)\n    {\n        combi[i][0] = 1;\n        for (int j = 1; j <= i; ++j)\n            combi[i][j] = (combi[i - 1][j] + combi[i - 1][j - 1]) % mod;\n    }\n\n    ten_pow[0] = 1;\n    for (int i = 1; i < M; ++i)\n        ten_pow[i] = (ten_pow[i - 1] * 10) % mod;\n\n\n    int n;\n    vector<int> a, d;\n    cin >> n;\n    for (int i = 0; i < n; ++i)\n    {\n        string s;\n        cin >> s;\n        d.push_back(s.size());\n        a.push_back(to_T<int>(s));\n    }\n\n    ll res = gao(a, d);\n    if (find(all(a), 0) != a.end())\n    {\n        vector<int> _a, _d;\n        for (int i = 0; i < n; ++i)\n        {\n            if (a[i] != 0)\n            {\n                _a.push_back(a[i]);\n                _d.push_back(d[i]);\n            }\n        }\n\n        ll sub = gao(_a, _d);\n        res = (res - sub + mod) % mod;\n    }\n\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nlong long n, a[209], sz[209], ret, mod = 1000000007;\nlong long dp[209][209][209], power[5] = { 1,10,100,1000,10000 };\n\nlong long solve(vector<long long>E, long long num, bool iszero) {\n\tfor (int i = 0; i <= E.size(); i++) { for (int j = 0; j <= E.size() - i; j++) { for (int k = 0; k <= E.size() - i - j; k++) dp[i][j][k] = 0; } }\n\tdp[0][0][0] = 1;\n\tfor (int k = 0; k < E.size(); k++) {\n\t\tfor (int i = 0; i <= k; i++) {\n\t\t\tfor (int j = 0; j <= k - i; j++) {\n\t\t\t\tif (dp[k][i][j] == 0) continue;\n\t\t\t\tlong long X = i + 1, Y = j + 1;\n\t\t\t\tdp[k + 1][i + 1][j] += dp[k][i][j] * X; dp[k + 1][i + 1][j] %= mod;\n\t\t\t\tdp[k + 1][i][j + 1] += dp[k][i][j] * Y*power[sz[E[k]]]; dp[k + 1][i][j + 1] %= mod;\n\t\t\t\tdp[k + 1][i][j] += dp[k][i][j]; if (dp[k + 1][i][j] >= mod) dp[k + 1][i][j] -= mod;\n\t\t\t}\n\t\t}\n\t}\n\tlong long Z = 0;\n\tfor (int j = 0; j <= E.size(); j++) {\n\t\tfor (int k = 0; k <= E.size() - j; k++) {\n\t\t\tif (j == 0 && num == 0) continue;\n\t\t\tZ += dp[E.size()][j][k]; Z %= mod;\n\t\t\tif (iszero == true) {\n\t\t\t\tZ += dp[E.size()][j][k] * j; Z %= mod;\n\t\t\t\tZ += dp[E.size()][j][k] * (k + 1) * 10LL; Z %= mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn Z;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) { cin >> a[i]; sz[i] = to_string(a[i]).size(); }\n\tfor (int i = 1; i <= n; i++) {\n\t\tvector<long long>X; bool OK = false;\n\t\tfor (int j = 1; j <= n; j++) { if (i != j) { if (a[j] != 0)X.push_back(j); else OK = true; } }\n\t\tlong long G = solve(X, a[i], OK);\n\t\tret += a[i] * G; ret %= mod;\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nlong long n, a[209], sz[209], ret, mod = 1000000007;\nlong long dp[209][209][209], power[5] = { 1,10,100,1000,10000 };\n\nlong long solve(vector<long long>E, long long num, bool iszero) {\n\tfor (int i = 0; i <= E.size(); i++) { for (int j = 0; j <= E.size(); j++) { for (int k = 0; k <= E.size(); k++) dp[i][j][k] = 0; } }\n\tdp[0][0][0] = 1;\n\tfor (int k = 0; k < E.size(); k++) {\n\t\tfor (int i = 0; i <= k; i++) {\n\t\t\tfor (int j = 0; j <= k - i; j++) {\n\t\t\t\tif (dp[k][i][j] == 0) continue;\n\t\t\t\tlong long X = i + 1, Y = j + 1;\n\t\t\t\tdp[k + 1][i + 1][j] += dp[k][i][j] * X; dp[k + 1][i + 1][j] %= mod;\n\t\t\t\tdp[k + 1][i][j + 1] += dp[k][i][j] * Y*power[sz[E[k]]]; dp[k + 1][i][j + 1] %= mod;\n\t\t\t\tdp[k + 1][i][j] += dp[k][i][j]; if (dp[k + 1][i][j] >= mod) dp[k + 1][i][j] -= mod;\n\t\t\t}\n\t\t}\n\t}\n\tlong long Z = 0;\n\tfor (int j = 0; j <= E.size(); j++) {\n\t\tfor (int k = 0; k <= E.size(); k++) {\n\t\t\tif (j == 0 && num == 0) continue;\n\t\t\tZ += dp[E.size()][j][k]; Z %= mod;\n\t\t\tif (iszero == true) {\n\t\t\t\tZ += dp[E.size()][j][k] * j; Z %= mod;\n\t\t\t\tZ += dp[E.size()][j][k] * (k + 1) * 10LL; Z %= mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn Z;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) { cin >> a[i]; sz[i] = to_string(a[i]).size(); }\n\tfor (int i = 1; i <= n; i++) {\n\t\tvector<long long>X; bool OK = false;\n\t\tfor (int j = 1; j <= n; j++) { if (i != j) { if (a[j] != 0)X.push_back(j); else OK = true; } }\n\t\tlong long G = solve(X, a[i], OK);\n\t\tret += a[i] * G; ret %= mod;\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define F first\n#define S second\nconst long long MOD = 1e9+7;\ntypedef vector<int> vint;\ntypedef vector<vint> vvint;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n// Mod int\n// const int MOD = 1000000007;\nstruct mint{\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%MOD+MOD)%MOD){}\n  mint operator+=(const mint& a){ if((x+=a.x)>=MOD) x-=MOD; return *this;}\n  mint operator-=(const mint& a){ if((x+=MOD-a.x)>=MOD) x-=MOD; return *this;}\n  mint operator*=(const mint& a){ (x*=a.x)%=MOD; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nmint powmod(mint x,ll y){\n\tmint a(1);\n\twhile(y){\n\t\tif(y&1) a=a*x;\n\t\tx=x*x;\n\t\ty/=2;\n\t}\n\treturn a;\n}\nvector<vector<mint>> dp[5];\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<pii> v(n);\n\tbool zero=false;\n\trep(i,n) cin>>v[i].F;\n\trep(i,n){\n\t\tif(v[i].F==0){\n\t\t\tzero=true;\n\t\t\tv[i].S=1;\n\t\t}\n\t\telse{\n\t\t\tint cnt=0;\n\t\t\tint t=v[i].F;\n\t\t\twhile(t){\n\t\t\t\tt/=10;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tv[i].S=cnt;\n\t\t}\n\t}\n\tvint w(5,0);\n\trep(i,n){\n\t\tw[v[i].S]+=v[i].F;\n\t}\n\tint cc[5]={};\n\trep(i,n){\n\t\tcc[v[i].S]++;\n\t}\n\tmint ans[2];\n\trep(i,2) ans[i].x=0;\n\tvector<mint> fun(210,mint(0LL));\n\tvector<mint> fun_sum(210,mint(0LL));\n\tfun[0]+=mint(1);\n\treep(i,1,210){\n\t\tfun[i]=mint(i)*fun[i-1];\n\t}\n\tmint combi[210][210];\n\trep(i,210) rep(j,210) combi[i][j].x=0LL;\n\trep(i,210){\n\t\tcombi[i][0]=combi[i][i]=mint(1);\n\t\treep(j,1,i){\n\t\t\tcombi[i][j]=combi[i-1][j]+combi[i-1][j-1];\n\t\t}\n\t}\n\trep(i,210){\n\t\tif(i==0){\n\t\t\tfun_sum[0]=mint(1);\n\t\t\tcontinue;\n\t\t}\n\t\trep(j,i+1){\n\t\t\tfun_sum[i]+=combi[i][j]*fun[j];\n\t\t}\n\t}\n\trep(o,2){\n\t\tif(o){\n\t\t\tif(!zero) continue;\n\t\t\telse cc[1]--;\n\t\t}\n\t\trep(i,5) dp[i]=vector<vector<mint>>(1000,vector<mint>(210));\n\t\trep(i,5){\n\t\t\tdp[i][0][0].x=1;\n\t\t\tif(!cc[i]) continue;\n\t\t\tcc[i]--;\n\t\t\trep(j,5){\n\t\t\t\trep(k,cc[j]){\n\t\t\t\t\tvector<vector<mint>> tmp=dp[i];\n\t\t\t\t\tfor(int p=999;p>=0;p--){\n\t\t\t\t\t\tfor(int q=209;q>=0;q--){\n\t\t\t\t\t\t\tif(!tmp[p][q].x) continue;\n\t\t\t\t\t\t\tdp[i][p+j][q+1]+=tmp[p][q];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcc[i]++;\n\t\t}\n\t\trep(i,5){\n\t\t\trep(j,1000){\n\t\t\t\tll t=0;\n\t\t\t\trep(k,210){\n\t\t\t\t\tt+=(dp[i][j][k]*fun[k]*fun_sum[n-o-k-1]).x;\n\t\t\t\t}\n\t\t\t\tans[o]+=mint(w[i])*powmod(mint(10),j)*mint(t);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<(ans[0]-ans[1]).x<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nll dp[2][201][201][2];\nll ten[10001];\nll a[201];\n\nint calcdigit(int v){\n\tint ret=0;\n\tif(v==0)return 1;\n\twhile(v>0){\n\t\tv/=10;\n\t\tret++;\n\t}\n\treturn ret;\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%lld\",&a[i]);\n\t}\n\tten[0]=1;\n\tfor(int i=0;i<=10*n;i++){\n\t\tten[i+1]=ten[i]*10LL%MOD;\n\t}\n\tsort(a,a+n);\n\treverse(a,a+n);\n\tint now=1,prev=0;\n\tdp[0][0][0][0]=1;\n\tfor(int i=0;i<n;i++){\n\t\tint dig=calcdigit(a[i]);\n\t\tfor(ll j=0;j<=i;j++){\n\t\t\tfor(ll k=0;k<=i;k++){\n\t\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\t\tif(dp[prev][j][k][l]>0){\n\t\t\t\t\t\tif(l==0){\n\t\t\t\t\t\t\tdp[now][j][k][l]+=dp[prev][j][k][l]%MOD;\n\t\t\t\t\t\t\tdp[now][j][k][l]%=MOD;\n\n\t\t\t\t\t\t\tif(a[i]!=0){\n\t\t\t\t\t\t\t\tdp[now][j+1][k][l]+=dp[prev][j][k][l]*(j+1)%MOD;\n\t\t\t\t\t\t\t\tdp[now][j+1][k][l]%=MOD;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tdp[now][j+1][k][l]+=dp[prev][j][k][l]*j%MOD;\n\t\t\t\t\t\t\t\tdp[now][j+1][k][l]%=MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\tdp[now][j][k+1][l]+=dp[prev][j][k][l]*(k+1)*ten[dig]%MOD;\n\t\t\t\t\t\t\tdp[now][j][k+1][l]%=MOD;\n\n\t\t\t\t\t\t\tdp[now][j][k][1]+=dp[prev][j][k][l]*a[i]%MOD;\n\t\t\t\t\t\t\tdp[now][j][k][1]%=MOD;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tdp[now][j][k][l]+=dp[prev][j][k][l]%MOD;\n\t\t\t\t\t\t\tdp[now][j][k][l]%=MOD;\n\n\t\t\t\t\t\t\tif(a[i]!=0){\n\t\t\t\t\t\t\t\tdp[now][j+1][k][l]+=dp[prev][j][k][l]*(j+1)%MOD;\n\t\t\t\t\t\t\t\tdp[now][j+1][k][l]%=MOD;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tdp[now][j+1][k][l]+=dp[prev][j][k][l]*j%MOD;\n\t\t\t\t\t\t\t\tdp[now][j+1][k][l]%=MOD;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tdp[now][j][k+1][l]+=dp[prev][j][k][l]*(k+1)*ten[dig]%MOD;\n\t\t\t\t\t\t\tdp[now][j][k+1][l]%=MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(now,prev);\n\t\tmemset(dp[now],0,sizeof(dp[now]));\n\t}\n\tll ans=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tans=(ans+dp[prev][i][j][1])%MOD;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\nusing ll = long long;\n\nconstexpr ll M = 1e9 + 7;\n\nll ten_pow[1024];\nll fact[256];\nll comb[256][256];\n\nvoid init() {\n    ten_pow[0] = 1;\n    for(int i = 1; i < 1024; ++i) {\n        ten_pow[i] = (ten_pow[i - 1] * 10) % M;\n    }\n    fact[0] = 1;\n    for(int i = 1; i < 256; ++i) {\n        fact[i] = (fact[i - 1] * i) % M;\n    }\n    for(int i = 0; i < 256; ++i) {\n        for(int j = 0; j < 256; ++j) {\n            if(i == j || j == 0) {\n                comb[i][j] = 1;\n            } else {\n                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % M;\n            }\n        }\n    }\n}\n\nll solve(vector<int> const& a, vector<int> const& d) {\n    int const n = a.size();\n\n    vector<vector<vector<ll>>> dp(5, vector<vector<ll>>(n, vector<ll>(n * 4 + 1)));\n    ll res = 0;\n    vector<ll> sum(5);\n    for(int i = 0; i < n; ++i) {\n        sum[d[i]] = (sum[d[i]] + a[i]) % M;\n    }\n    for(int i = 0; i < n; ++i) {\n        if(dp[d[i]][0][0] == 0) {\n            dp[d[i]][0][0] = 1;\n            for(int j = 0; j < n; ++j) {\n                if(i == j) {\n                    continue;\n                }\n                for(int k = n - 1; k >= 0; --k) {\n                    for(int l = 0; l < n * 4 + 1; ++l) {\n                        if(dp[d[i]][k][l] == 0) {\n                            continue;\n                        }\n                        dp[d[i]][k + 1][l + d[j]] = (dp[d[i]][k + 1][l + d[j]] + dp[d[i]][k][l] * (k + 1)) % M;\n                    }\n                }\n            }\n        }\n    }\n    for(int i = 1; i < 5; ++i) {\n        for(int j = 0; j < n; ++j) {\n            for(int k = 0; k < 4 * n + 1; ++k) {\n                if(dp[i][j][k] == 0) {\n                    continue;\n                }\n                for(int l = 0; l <= n - 1 - j; ++l) {\n                    ll t = (sum[i] * dp[i][j][k]) % M;\n                    t = (t * ten_pow[k]) % M;\n                    t = (t * comb[n - 1 - j][l]) % M;\n                    t = (t * fact[l]) % M;\n                    res = (res + t) % M;\n                }\n            }\n        }\n    }\n\n    return res;\n}\n\nint main() {\n    init();\n\n    int n;\n    cin >> n;\n    int zero_cnt = 0;\n    vector<int> a(n);\n    vector<int> d(n);\n    for(int i = 0; i < n; ++i) {\n        cin >> a[i];\n        d[i] = to_string(a[i]).size();\n        zero_cnt += (a[i] == 0);\n    }\n\n    ll res = solve(a, d);\n    if(zero_cnt != 0) {\n        int idx = find(begin(a), end(a), 0) - begin(a);\n        a.erase(a.begin() + idx);\n        d.erase(d.begin() + idx);\n        ll leading_zero = (zero_cnt * solve(a, d)) % M;\n        res = (res - leading_zero + M) % M;\n    }\n\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VEC;\ntypedef vector<VEC> MAT;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define EPS 1e-8\n#define MOD 1000000007\n\nint a[222];\nLL s[4];\nLL cnt[4];\nLL fact[222];\nLL invfact[222];\nLL pow10[1000];\nLL f[222];\n\nLL extgcd(LL a, LL b, LL &x, LL &y){\n\tLL d = a;\n\tif(b){\n\t\td = extgcd(b, a % b, y, x);\n\t\ty -= a/b * x;\n\t}\n\telse x = 1, y = 0;\n\treturn d;\n}\n\nLL mod_inverse(LL a, LL m){\n\tLL x, y;\n\textgcd(a, m, x, y);\n\treturn (m + x%m) % m;\n}\n\ninline LL P(int n, int r){\n\tif(n<=0)return 0LL;\n\treturn (fact[n]*invfact[n-r])%MOD;\n}\n\ninline LL C(int n, int r){\n\tif(n<0)return 0LL;\n\treturn (P(n,r)*invfact[r])%MOD;\n}\nLL solve(int n){\n\tLL ret=0;\n\tint loop[4];\n\tfor(loop[0]=0; loop[0]<=cnt[0]; loop[0]++){\n\t\tfor(loop[1]=0; loop[1]<=cnt[1]; loop[1]++){\n\t\t\tfor(loop[2]=0; loop[2]<=cnt[2]; loop[2]++){\n\t\t\t\tfor(loop[3]=0; loop[3]<=cnt[3]; loop[3]++){\n\t\t\t\t\tint sum1 = loop[0]+loop[1]+loop[2]+loop[3];\n\t\t\t\t\tint sum2 = loop[0]+2*loop[1]+3*loop[2]+4*loop[3];\n\t\t\t\t\tLL tmp = 0;\n\t\t\t\t\tREP(i,4){\n\t\t\t\t\t\tLL tmp2=0;\n\t\t\t\t\t\tREP(j,4){\n\t\t\t\t\t\t\ttmp2 += C(cnt[j]-(i==j), loop[j]);\n\t\t\t\t\t\t\ttmp2 %= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp += tmp2*s[i];\n\t\t\t\t\t\ttmp %= MOD;\n\t\t\t\t\t}\n\t\t\t\t\tif(n-sum1-1<0)tmp=0;\n\t\t\t\t\telse tmp *= f[n-sum1-1];\n\t\t\t\t\ttmp %= MOD;\n\t\t\t\t\ttmp *= fact[sum1];\n\t\t\t\t\ttmp %= MOD;\n\t\t\t\t\ttmp *= pow10[sum2];\n\t\t\t\t\ttmp %= MOD;\n\t\t\t\t\tret = (ret+tmp)%MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tfact[0]=fact[1]=invfact[0]=invfact[1]=1;\n\tFOR(i,2,222)fact[i]=(fact[i-1]*i)%MOD;\n\tFOR(i,2,222)invfact[i]=mod_inverse(fact[i], MOD);\n\tpow10[0]=1;\n\tFOR(i,1,1000)pow10[i] = (pow10[i-1]*10)%MOD;\n\tf[0]=1;\n\tFOR(i,1,222){\n\t\tf[i]=1;\n\t\tFOR(j,1,i+1)f[i]=(f[i]+P(i,j))%MOD;\n\t}\n\tint n;\n\tcin>>n;\n\tREP(i,n)scanf(\"%d\", a+i);\n\tsort(a,a+n);\n\tint c=10;\n\tREP(i,n){\n\t\tREP(j,4){\n\t\t\tif(a[i]<c){\n\t\t\t\tcnt[j]++;\n\t\t\t\ts[j]+=a[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tc*=10;\n\t\t}\n\t}\n\tLL ret = solve(n);\n\tif(a[0]==0){\n\t\tcnt[0]--;\n\t\tret -= solve(n-1);\n\t}\n\twhile(ret<0)ret+=MOD;\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nlong long n, a[209], sz[209], ret, mod = 1000000007;\nlong long dp[209][209][209], power[5] = { 1,10,100,1000,10000 };\n\nlong long solve(vector<long long>E, long long num, bool iszero) {\n\tfor (int i = 0; i <= E.size(); i++) { for (int j = 0; j <= i; j++) { for (int k = 0; k <= i - j; k++) dp[i][j][k] = 0; } }\n\tdp[0][0][0] = 1;\n\tfor (int k = 0; k < E.size(); k++) {\n\t\tfor (int i = 0; i <= k; i++) {\n\t\t\tfor (int j = 0; j <= k - i; j++) {\n\t\t\t\tif (dp[k][i][j] == 0) continue;\n\t\t\t\tlong long X = i + 1, Y = j + 1;\n\t\t\t\tdp[k + 1][i + 1][j] += dp[k][i][j] * X;\n\t\t\t\tdp[k + 1][i][j + 1] += dp[k][i][j] * Y*power[sz[E[k]]];\n\t\t\t\tdp[k + 1][i][j] += dp[k][i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= k + 1; i++) {\n\t\t\tfor (int j = 0; j <= k + 1 - i; k++) dp[k + 1][i][j] %= mod;\n\t\t}\n\t}\n\tlong long Z = 0;\n\tfor (int j = 0; j <= E.size(); j++) {\n\t\tfor (int k = 0; k <= E.size() - j; k++) {\n\t\t\tif (j == 0 && num == 0) continue;\n\t\t\tZ += dp[E.size()][j][k]; Z %= mod;\n\t\t\tif (iszero == true) {\n\t\t\t\tZ += dp[E.size()][j][k] * j; Z %= mod;\n\t\t\t\tZ += dp[E.size()][j][k] * (k + 1) * 10LL; Z %= mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn Z;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) { cin >> a[i]; sz[i] = to_string(a[i]).size(); }\n\tfor (int i = 1; i <= n; i++) {\n\t\tvector<long long>X; bool OK = false;\n\t\tfor (int j = 1; j <= n; j++) { if (i != j) { if (a[j] != 0)X.push_back(j); else OK = true; } }\n\t\tlong long G = solve(X, a[i], OK);\n\t\tret += a[i] * G; ret %= mod;\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VEC;\ntypedef vector<VEC> MAT;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define EPS 1e-8\n#define MOD 1000000007\n\nint a[222];\nLL s[4];\nLL cnt[4];\nLL fact[222];\nLL invfact[222];\nLL powten[1000];\nLL f[222];\n\nLL extgcd(LL a, LL b, LL &x, LL &y){\n\tLL d = a;\n\tif(b){\n\t\td = extgcd(b, a % b, y, x);\n\t\ty -= a/b * x;\n\t}\n\telse x = 1, y = 0;\n\treturn d;\n}\n\nLL mod_inverse(LL a, LL m){\n\tLL x, y;\n\textgcd(a, m, x, y);\n\treturn (m + x%m) % m;\n}\n\ninline LL P(int n, int r){\n\tif(n<=0)return 0LL;\n\treturn (fact[n]*invfact[n-r])%MOD;\n}\n\ninline LL C(int n, int r){\n\tif(n<0)return 0LL;\n\treturn (P(n,r)*invfact[r])%MOD;\n}\nLL solve(int n){\n\tLL ret=0;\n\tint loop[4];\n\tfor(loop[0]=0; loop[0]<=cnt[0]; loop[0]++){\n\t\tfor(loop[1]=0; loop[1]<=cnt[1]; loop[1]++){\n\t\t\tfor(loop[2]=0; loop[2]<=cnt[2]; loop[2]++){\n\t\t\t\tfor(loop[3]=0; loop[3]<=cnt[3]; loop[3]++){\n\t\t\t\t\tint sum1 = loop[0]+loop[1]+loop[2]+loop[3];\n\t\t\t\t\tint sum2 = loop[0]+2*loop[1]+3*loop[2]+4*loop[3];\n\t\t\t\t\tLL tmp = 0;\n\t\t\t\t\tREP(i,4){\n\t\t\t\t\t\tif(loop[i]==cnt[i])continue;\n\t\t\t\t\t\tLL tmp2=0;\n\t\t\t\t\t\tREP(j,4){\n\t\t\t\t\t\t\ttmp2 += C(cnt[j]-(i==j), loop[j]);\n\t\t\t\t\t\t\ttmp2 %= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp += tmp2*s[i];\n\t\t\t\t\t\ttmp %= MOD;\n\t\t\t\t\t}\n\t\t\t\t\tif(n-sum1-1<0)tmp=0;\n\t\t\t\t\telse tmp *= f[n-sum1-1];\n\t\t\t\t\ttmp %= MOD;\n\t\t\t\t\ttmp *= fact[sum1];\n\t\t\t\t\ttmp %= MOD;\n\t\t\t\t\ttmp *= powten[sum2];\n\t\t\t\t\ttmp %= MOD;\n\t\t\t\t\tret = (ret+tmp)%MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tfact[0]=fact[1]=invfact[0]=invfact[1]=1;\n\tFOR(i,2,222)fact[i]=(fact[i-1]*i)%MOD;\n\tFOR(i,2,222)invfact[i]=mod_inverse(fact[i], MOD);\n\tpowten[0]=1;\n\tFOR(i,1,1000)powten[i] = (powten[i-1]*10)%MOD;\n\tf[0]=1;\n\tFOR(i,1,222){\n\t\tf[i]=1;\n\t\tFOR(j,1,i+1)f[i]=(f[i]+P(i,j))%MOD;\n\t}\n\tint n;\n\tcin>>n;\n\tREP(i,n)scanf(\"%d\", a+i);\n\tsort(a,a+n);\n\tint c=10;\n\tREP(i,n){\n\t\tREP(j,4){\n\t\t\tif(a[i]<c){\n\t\t\t\tcnt[j]++;\n\t\t\t\ts[j]+=a[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tc*=10;\n\t\t}\n\t}\n\tLL ret = solve(n);\n\tif(a[0]==0){\n\t\tcnt[0]--;\n\t\tret -= solve(n-1);\n\t}\n\twhile(ret<0)ret+=MOD;\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nclass range {\n    struct Iterator {\n        int val, inc;\n        int operator*() {return val;}\n        bool operator!=(Iterator& rhs) {return val < rhs.val;}\n        void operator++() {val += inc;}\n    };\n    Iterator i, n;\n    public:\n    range(int e) : i({0, 1}), n({e, 1}) {}\n    range(int b, int e) : i({b, 1}), n({e, 1}) {}\n    range(int b, int e, int inc) : i({b, inc}), n({e, inc}) {}\n    Iterator& begin() {return i;}\n    Iterator& end() {return n;}\n};\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\nconst int MOD = 1e9 + 7;\nvoid add(int& x, int y) {\n    x += y;\n    if(x >= MOD) x-= MOD;\n}\nint solve(vector<int> a) {\n    int n = a.size();\n    vector<int> d(n);\n    REP(i, n) d[i] = to_string(a[i]).size();\n\n    int ans = 0;\n\n    const int P = 4 * n + 1;\n    int ways[802][202] = {};\n    ways[0][0] = 1;\n    REP(i, n){\n        int nways[802][202] = {};\n        REP(l, P) REP(k, i+1) {\n            add(nways[l][k], ways[l][k]);\n            if(l + d[i] < P) add(nways[l+d[i]][k+1], ways[l][k]);\n        }\n        memcpy(ways, nways, sizeof(ways));\n    }\n    // REP(l, P) REP(k, n+1) if(ways[l][k] > 0) {\n    //     cout << \"length: \" << l << endl;\n    //     cout << \"count: \" << k << endl;\n    //     cout << \"ways: \" << ways[l][k] << endl;\n    // }\n    //\n    //\n    vector<int> fact(n+2, 1);\n    REP(i, n+1) fact[i+1] = (LL)fact[i] * (i+1) % MOD;\n\n    REP(i, n){\n        int base10 = 1;\n        const int P = 4*(n-1) + 1;\n\n        int dp[802][202] = {};\n        REP(l, P) REP(k, n) {\n            dp[l][k] = ways[l][k];\n            if(l-d[i]>=0 && k-1 >= 0) {\n                dp[l][k] -= dp[l-d[i]][k-1];\n                if(dp[l][k] < 0) dp[l][k] += MOD;\n            }\n            // if(dp[l][k] > 0) {\n            //     cout << \"not use: \" << i << endl;\n            //     cout << \"length: \" << l << endl;\n            //     cout << \"count: \" << k << endl;\n            //     cout << \"ways: \" << dp[l][k] << endl;\n            // }\n        }\n\n        REP(l, P) REP(k, n) {\n            dp[l][k] = (LL)fact[k] * dp[l][k] % MOD;\n        }\n\n\n        int dp2[802] = {};\n        REP(k, n) {\n            int rest = (n-1) - k;\n            LL K = 1;\n            REP(i, rest+1) {\n                REP(l, P) add(dp2[l], K * dp[l][k] % MOD);\n                K = K * (rest - i) % MOD;\n            }\n        }\n\n        REP(p, P) {\n            // if(dp2[p] > 0) {\n            //     cout << \"i: \" << i << endl;\n            //     cout << \"10^\" << p << endl;\n            //     cout << \"dp: \" << dp2[p] << endl;\n            // }\n\n            add(ans, (LL)dp2[p] * base10 % MOD * a[i] % MOD);\n            base10 = 10LL * base10 % MOD;\n        }\n    }\n    return ans;\n}\nint main(){\n    iostream_init();\n    int n;\n    while(cin >> n) {\n        vector<int> a(n);\n        REP(i, n) cin >> a[i];\n        sort(a.begin(), a.end());\n        int ans = solve(a);\n        if(a[0] == 0) {\n            vector<int> b;\n            REP(i, n-1) b.push_back(a[i+1]);\n            ans -= solve(b);\n            if(ans < 0) ans += MOD;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n/* vim:set foldmethod=marker: */"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nclass range {\n    struct Iterator {\n        int val, inc;\n        int operator*() {return val;}\n        bool operator!=(Iterator& rhs) {return val < rhs.val;}\n        void operator++() {val += inc;}\n    };\n    Iterator i, n;\n    public:\n    range(int e) : i({0, 1}), n({e, 1}) {}\n    range(int b, int e) : i({b, 1}), n({e, 1}) {}\n    range(int b, int e, int inc) : i({b, inc}), n({e, inc}) {}\n    Iterator& begin() {return i;}\n    Iterator& end() {return n;}\n};\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\nconst int MOD = 1e9 + 7;\nvoid add(int& x, int y) {\n    x += y;\n    if(x >= MOD) x-= MOD;\n}\nint solve(vector<int> a) {\n    int n = a.size();\n    vector<int> d(n);\n    REP(i, n) d[i] = to_string(a[i]).size();\n\n    int ans = 0;\n\n    const int P = 4 * n + 1;\n    int ways[802][202] = {};\n    ways[0][0] = 1;\n    REP(i, n){\n        int nways[802][202] = {};\n        REP(l, P) REP(k, i+1) {\n            add(nways[l][k], ways[l][k]);\n            if(l + d[i] < P) add(nways[l+d[i]][k+1], ways[l][k]);\n        }\n        memcpy(ways, nways, sizeof(ways));\n    }\n    // REP(l, P) REP(k, n+1) if(ways[l][k] > 0) {\n    //     cout << \"length: \" << l << endl;\n    //     cout << \"count: \" << k << endl;\n    //     cout << \"ways: \" << ways[l][k] << endl;\n    // }\n\n    REP(i, n){\n        int base10 = 1;\n        const int P = 4*(n-1) + 1;\n\n        int dp[802][202] = {};\n        REP(l, P) REP(k, n) {\n            dp[l][k] = ways[l][k];\n            if(l-d[i]>=0 && k-1 >= 0) {\n                dp[l][k] -= dp[l-d[i]][k-1];\n                if(dp[l][k] < 0) dp[l][k] += MOD;\n            }\n            // if(dp[l][k] > 0) {\n            //     cout << \"not use: \" << i << endl;\n            //     cout << \"length: \" << l << endl;\n            //     cout << \"count: \" << k << endl;\n            //     cout << \"ways: \" << dp[l][k] << endl;\n            // }\n        }\n\n        int dp2[802] = {};\n        REP(k, n) {\n            int rest = (n-1) - k;\n            LL K = 1;\n            REP(i, rest+1) {\n                REP(l, P) add(dp2[l], K * dp[l][k] % MOD);\n                K = K * (rest - i) % MOD;\n            }\n        }\n\n        REP(p, P) {\n            // if(dp2[p] > 0) {\n            //     cout << \"i: \" << i << endl;\n            //     cout << \"10^\" << p << endl;\n            //     cout << \"dp: \" << dp2[p] << endl;\n            // }\n            REP(k, p) dp2[p] = (LL)(k+1) * dp2[p] % MOD;\n\n            add(ans, (LL)dp2[p] * base10 % MOD * a[i] % MOD);\n            base10 = 10LL * base10 % MOD;\n        }\n    }\n    return ans;\n}\nint main(){\n    iostream_init();\n    int n;\n    while(cin >> n) {\n        vector<int> a(n);\n        REP(i, n) cin >> a[i];\n        sort(a.begin(), a.end());\n        int ans = solve(a);\n        if(a[0] == 0) {\n            vector<int> b;\n            REP(i, n-1) b.push_back(a[i+1]);\n            ans -= solve(b);\n            if(ans < 0) ans += MOD;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n/* vim:set foldmethod=marker: */"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nclass range {\n    struct Iterator {\n        int val, inc;\n        int operator*() {return val;}\n        bool operator!=(Iterator& rhs) {return val < rhs.val;}\n        void operator++() {val += inc;}\n    };\n    Iterator i, n;\n    public:\n    range(int e) : i({0, 1}), n({e, 1}) {}\n    range(int b, int e) : i({b, 1}), n({e, 1}) {}\n    range(int b, int e, int inc) : i({b, inc}), n({e, inc}) {}\n    Iterator& begin() {return i;}\n    Iterator& end() {return n;}\n};\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\nconst int MOD = 1e9 + 7;\nvoid add(int& x, int y) {\n    x += y;\n    if(x >= MOD) x-= MOD;\n}\nint solve(vector<int> a) {\n    int n = a.size();\n    vector<int> d(n);\n    REP(i, n) d[i] = to_string(a[i]).size();\n\n    int ans = 0;\n\n    const int P = 4 * n + 1;\n    int ways[802][202] = {};\n    ways[0][0] = 1;\n    REP(i, n){\n        int nways[802][202] = {};\n        REP(l, P) REP(k, i+1) {\n            add(nways[l][k], ways[l][k]);\n            if(l + d[i] < P) add(nways[l+d[i]][k+1], ways[l][k]);\n        }\n        memcpy(ways, nways, sizeof(ways));\n    }\n    // REP(l, P) REP(k, n+1) if(ways[l][k] > 0) {\n    //     cout << \"length: \" << l << endl;\n    //     cout << \"count: \" << k << endl;\n    //     cout << \"ways: \" << ways[l][k] << endl;\n    // }\n    //\n    //\n    vector<int> fact(n+2, 1);\n    REP(i, n+1) fact[i+1] = (LL)fact[i] * (i+1) % MOD;\n\n    REP(i, n){\n        int base10 = 1;\n        const int P = 4*(n-1) + 1;\n\n        int dp[802][202] = {};\n        REP(l, P) REP(k, n) {\n            dp[l][k] = ways[l][k];\n            if(l-d[i]>=0 && k-1 >= 0) {\n                dp[l][k] -= dp[l-d[i]][k-1];\n                if(dp[l][k] < 0) dp[l][k] += MOD;\n            }\n            // if(dp[l][k] > 0) {\n            //     cout << \"not use: \" << i << endl;\n            //     cout << \"length: \" << l << endl;\n            //     cout << \"count: \" << k << endl;\n            //     cout << \"ways: \" << dp[l][k] << endl;\n            // }\n        }\n\n        REP(l, P) REP(k, n) {\n            dp[l][k] = (LL)fact[k] * dp[l][k] % MOD;\n        }\n\n\n        int dp2[802] = {};\n        REP(k, n) {\n            int rest = (n-1) - k;\n            LL K = 1;\n            LL S = 0;\n            REP(i, rest+1) {\n                S += K;\n                S %= MOD;\n                K = K * (rest - i) % MOD;\n            }\n            REP(l, P){\n                add(dp2[l], S * dp[l][k] % MOD);\n            }\n        }\n\n        REP(p, P) {\n            // if(dp2[p] > 0) {\n            //     cout << \"i: \" << i << endl;\n            //     cout << \"10^\" << p << endl;\n            //     cout << \"dp: \" << dp2[p] << endl;\n            // }\n\n            add(ans, (LL)dp2[p] * base10 % MOD * a[i] % MOD);\n            base10 = 10LL * base10 % MOD;\n        }\n    }\n    return ans;\n}\nint main(){\n    iostream_init();\n    int n;\n    while(cin >> n) {\n        vector<int> a(n);\n        REP(i, n) cin >> a[i];\n        sort(a.begin(), a.end());\n        int ans = solve(a);\n        if(a[0] == 0) {\n            vector<int> b;\n            REP(i, n-1) b.push_back(a[i+1]);\n            ans -= solve(b);\n            if(ans < 0) ans += MOD;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n/* vim:set foldmethod=marker: */"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\n\nll add(ll a,ll b){ return (a+b)%mod; }\n\nvoid Add(ll &a,ll b){\n  a=(a+b)%mod;\n}\n\nll mul(ll a,ll b){ return (a*b)%mod; }\n\n\nll mpow(ll a,ll b){\n  ll res=1;\n  while(b){\n    if(b%2==1)res=mul(res,a);\n    a=mul(a,a);\n    b/=2;\n  }\n  return res;\n}\n\nll divi( ll a,ll b){\n  return mul(a, mpow(b,mod-2) );\n}\n\nll mem[1000][1000];\n\nll nCr(ll n,ll r){\n  if(r==0)return 1;\n  if(n==r)return 1;\n  if(n<r)return 0;\n  \n  if(mem[n][r])return mem[n][r];\n  mem[n][r]=add( nCr(n-1,r-1) , nCr(n-1,r) );\n  return mem[n][r];\n}\n\nint n;\nint a[200];\n\nll Z=0;\nll cnt[10];\nll sum[10];\n\n//ll dp[50][50][50][50][2];\n//ll DP[50][50][50][50][2];\nvector< vector< vector< vector< vector< ll > > > >  > dp,DP;\n\nvoid update(int a,int b,int c,int d,int z){\n  /*  cout<<a<<' '<<b<<' '<<c<<' '<<d<<' '<<z<<endl;\n  cout<<dp[a][b][c][d][z]<<endl;\n  cout<<DP[a][b][c][d][z]<<endl;\n  cout<<endl;    */\n  if(a<cnt[1]){\n    int cc=cnt[1]-a;\n    ll pp=mul(dp[a][b][c][d][z], cc);\n    Add( dp[a+1][b][c][d][z], pp );\n    Add( DP[a+1][b][c][d][z], mul(DP[a][b][c][d][z], 10*cc )    );\n    Add( DP[a+1][b][c][d][z], mul(divi(pp,cnt[1]),sum[1]) );\n  }\n  \n  if(b<cnt[2]){\n    int cc=cnt[2]-b;\n    ll pp=mul(dp[a][b][c][d][z], cc);\n    Add( dp[a][b+1][c][d][z], pp );\n    Add( DP[a][b+1][c][d][z], mul(DP[a][b][c][d][z], 100*cc )    );\n    Add( DP[a][b+1][c][d][z], mul(divi(pp,cnt[2]),sum[2]) );\n  }\n  if(c<cnt[3]){\n    int cc=cnt[3]-c;\n    ll pp=mul(dp[a][b][c][d][z], cc);\n    Add( dp[a][b][c+1][d][z], mul(dp[a][b][c][d][z], cc) );\n    Add( DP[a][b][c+1][d][z], mul(DP[a][b][c][d][z], 1000*cc )    );\n    Add( DP[a][b][c+1][d][z], mul(divi(pp,cnt[3]),sum[3]) );\n  }\n  if(d<cnt[4]){\n    int cc=cnt[4]-d;\n    ll pp=mul(dp[a][b][c][d][z], cc);\n    Add( dp[a][b][c][d+1][z], mul(dp[a][b][c][d][z], cc) );\n    Add( DP[a][b][c][d+1][z], mul(DP[a][b][c][d][z], 10000*cc )    );\n    Add( DP[a][b][c][d+1][z], mul(divi(pp,cnt[4]),sum[4]) );\n  }\n  \n  if(z<Z && a+b+c+d>0){\n    Add( dp[a][b][c][d][z+1], dp[a][b][c][d][z] );\n    Add( DP[a][b][c][d][z+1], mul(DP[a][b][c][d][z], 10 )    );\n  }\n}\n\nll solve(){\n  dp.resize(cnt[1]+1);\n  for(int i=0;i<(int)dp.size();i++){\n    dp[i].resize(cnt[2]+1);\n    for(int j=0;j<(int)dp[i].size();j++){\n      dp[i][j].resize(cnt[3]+1);\n      for(int k=0;k<(int)dp[i][j].size();k++){\n        dp[i][j][k].resize(cnt[4]+1);\n        for(int l=0;l<(int)dp[i][j][k].size();l++){\n          dp[i][j][k][l].resize(2);\n        }\n      }\n    }\n  }\n  DP=dp;\n\n  dp[0][0][0][0][0]=1;\n\n  ll ans=0;\n  \n  for(int a=0;a<=cnt[1];a++)\n    for(int b=0;b<=cnt[2];b++)\n      for(int c=0;c<=cnt[3];c++)\n        for(int d=0;d<=cnt[4];d++)\n          for(int z=0;z<=Z;z++){\n            update(a,b,c,d,z);\n            Add( ans, DP[a][b][c][d][z] );\n          }\n\n  return ans;\n}\n\nint countDisit(int x){\n  int res=0;\n  while(x){\n    res++;\n    x/=10;\n  }\n  return res;\n}\n\nint main(){\n  cin>>n;\n  \n  for(int i=0;i<n;i++){\n    cin>>a[i];\n    int D=countDisit(a[i]);\n    if(a[i]==0){\n      Z++;\n      continue;\n    }\n    cnt[D]++;\n    sum[D]+=a[i];\n  }\n  cout<< solve() <<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\ntypedef long long ll;\nint n,a[200],d[5]={};\nll MOD=1e9+7;\nll dp[5][2][201][1000],p10[1000],frac[201],p[201][201],sump[201];\nint dig(int x){\n\tif(x<10) return 0;\n\tif(x<100) return 1;\n\tif(x<1000) return 2;\n\tif(x<10000) return 3;\n\treturn 4;\n}\nll add(ll &x,ll y){\n\tx+=y;\n\tif(x>=MOD) x%=MOD;\n}\nll solve(){\n\trep(i,n){\n\t\td[dig(a[i])]++;\n\t}\n\trep(i,5){\n\t\tif(d[i]==0) continue;\n\t\tvector<int> vc;\n\t\trep(j,5) rep(k,d[j]){\n\t\t\tif(i==j&&k==0) continue;\n\t\t\tvc.pb(j+1);\n\t\t}\n\t\tdp[i][0][0][0]=1;\n\t\trep(ii,vc.size()){\n\t\t\trep(j,vc.size()+1) rep(k,1000) dp[i][1-ii%2][j][k]=0;\n\t\t\trep(j,vc.size()+1) rep(k,1000){\n\t\t\t\tadd(dp[i][1-ii%2][j][k],dp[i][ii%2][j][k]);\n//\t\t\t\tif(k<5) printf(\"dp[%d][%d][%d][%d]=%d\\n\",i,1+ii,j,k,dp[i][1-ii%2][j][k]);\n\t\t\t\tif(k+vc[ii]<1000){\n\t\t\t\t\tadd(dp[i][1-ii%2][j+1][k+vc[ii]],dp[i][ii%2][j][k]);\n//\t\t\t\t\tif(k<5) printf(\"dp[%d][%d][%d][%d]=%d\\n\",i,1+ii,j+1,k+vc[j],dp[i][1-ii%2][j+1][k+vc[j]]);\n\t\t\t\t}\n\t\t\t}\n//\t\t\trep(j,vc.size()+1) rep(k,5) printf(\"dp[%d][%d][%d][%d]=%d\\n\",i,1+ii,j,k,dp[i][1-ii%2][j][k]);\n\t\t}\n\t}\n\tll ans=0;\n\tll dsum[5]={};\n\trep(i,n) dsum[dig(a[i])]+=a[i];\n\trep(i,5){\n\t\trep(j,n){\n\t\t\trep(k,1000){\n\t\t\t\tadd(ans,dsum[i]*dp[i][1-n%2][j][k]%MOD*sump[n-j-1]%MOD*frac[j]%MOD*p10[k]%MOD);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\trep(i,201) p[i][0]=1;\n\trep(i,201){\n\t\trep(j,i) p[i][j+1]=p[i][j]*(i-j);\n\t}\n\trep(i,201) rep(j,i+1) add(sump[i],p[i][j]);\n\tp10[0]=1,frac[0]=1;\n\trep(i,999) p10[i+1]=p10[i]*10%MOD;\n\trep(i,200) frac[i+1]=frac[i]*(i+1)%MOD;\n\tcin>>n;\n\trep(i,n) scanf(\"%d\",a+i);\n\tsort(a,a+n);\n\tll ans=solve();\n\tif(a[0]==0){\n\t\tswap(a[0],a[n-1]);\n\t\tn--;\n\t\tsort(a,a+n);\n\t\trep(i,5) rep(ii,2) rep(j,201) rep(k,1000) dp[i][ii][j][k]=0;\n\t\trep(i,5) d[i]=0;\n\t\tll mn=solve();\n\t\tans-=mn;\n\t\tans=(ans%MOD+MOD)%MOD;\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <map>\n#include <string>\n#include <stack>\n#include <vector>\nusing namespace std;\n\n#define INF 1000000007LL\n#define ll long long\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define rep(i,n) rep2(i,0,n)\n#define sz size()\n\nll n,m[5],D,a[222],digitsum[5];\nll dp[6][222][888];\nll nPk[888][888],nPksum[888][889],nCk[888][888],fact[888]={1},p10[888]={1};\n\nll f(int dig, int card, int sum){\n\tif(card<0 || sum<0)return 0;\n\tll& res=dp[dig][card][sum];\n\tif(res>-1)return res;\n\tif(dig==5)return res=(card==0)&&(sum==0);\n\tres=0;\n\trep(i,m[dig]+1){\n\t\tres = (res + f(dig+1,card-i,sum-i*max(1,dig)) * nCk[m[dig]][i] ) % INF;\n\t}\n\t\n\t//cout<<dig<<\",\"<<card<<\",\"<<sum<<\" : \"<<res<<endl;\n\treturn res;\n}\n\nint main(){\n\trep2(i,1,888)p10[i]=p10[i-1]*10%INF;\n\trep2(i,1,888)fact[i]=fact[i-1]*i%INF;\n\trep(i,888)nCk[i][0]=nCk[i][i]=1;\n\trep2(i,1,888)rep2(j,1,i)nCk[i][j]=(nCk[i-1][j-1]+nCk[i-1][j])%INF;\n\trep(i,888){\n\t\tnPk[i][0]=1;\n\t\trep2(j,1,i+1)nPk[i][j]=(nPk[i][j-1]*(i+1-j))%INF;\n\t\tnPksum[i][0]=0;\n\t\trep2(j,1,i+2)nPksum[i][j]=(nPksum[i][j-1]+nPk[i][j-1])%INF;\n\t}\n\t//rep(i,6)cout<<nPksum[5][i]<<\" \";\n\trep2(i,1,6)p10[i]=p10[i-1]*10;\n\tcin>>n;\n\trep(i,n){\n\t\tcin>>a[i];\n\t\trep(j,6){\n\t\t\tif(a[i]<p10[j]){\n\t\t\t\tm[j]++;\n\t\t\t\tdigitsum[j]+=a[i];\n\t\t\t\tD+=max(j,1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tll ans=0;\n\t\n\trep2(i,1,5)if(m[i]>=1){\n\t\tm[i]--;\n\t\tD-=i;\n\t\t\n\t\tmemset(dp,-1,sizeof(dp));\n\t\t\n\t\t/*while(1){\n\t\t\tint card,dig;\n\t\t\tcin>>card>>dig;\n\t\t\tcout<<f(0,card,dig)<<endl;\n\t\t}*/\n\t\t\n\t\t//rep(j,5)cout<<m[j]<<\" \";cout<<endl;\n\t\t\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tll res=0;\n\t\t\n\t\trep(j,n)rep(k,D+1){\n\t\t\tres= ( res + (f(0,j,k) * fact[j] % INF *nPksum[n-1-j][n-j])%INF * p10[k] ) % INF;\n\t\t\t//cout<<i<<\" \"<<j<<\" \"<<k<<\" : \"<<f(0,j,k)<<\" * \"<<fact[j]<<\" * \"<<nPksum[n-1-j][n-j]<<\" * \"<<p10[k]<<endl;\n\t\t}\n\t\t\n\t\tans=(ans+res*digitsum[i])%INF;\n\t\t//cout<<i<<\" : \"<<digitsum[i]<<\" * \"<<res<<endl;\n\t\t\n\t\tm[i]++;\n\t\tD+=i;\n\t}\n\t\n\tif(m[0]==0){\n\t\tcout<<ans<<endl;\n\t\treturn 0;\n\t}\n\t\n\tm[0]--;\n\tD-=1;\n\tn--;\n\t\n\t//cout<<\"-----\\n\";\n\t\n\tll ans2=0;\n\t\n\trep2(i,1,5)if(m[i]>=1){\n\t\tm[i]--;\n\t\tD-=i;\n\t\t\n\t\tmemset(dp,-1,sizeof(dp));\n\t\t\n\t\t/*while(1){\n\t\t\tint card,dig;\n\t\t\tcin>>card>>dig;\n\t\t\tcout<<f(0,card,dig)<<endl;\n\t\t}*/\n\t\t\n\t\t//rep(j,5)cout<<m[j]<<\" \";cout<<endl;\n\t\t\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tll res=0;\n\t\t\n\t\trep(j,n)rep(k,D+1){\n\t\t\tres= ( res + (f(0,j,k) * fact[j] % INF *nPksum[n-1-j][n-j])%INF * p10[k] ) % INF;\n\t\t\t//cout<<i<<\" \"<<j<<\" \"<<k<<\" : \"<<f(0,j,k)<<\" * \"<<fact[j]<<\" * \"<<nPksum[n-1-j][n-j]<<\" * \"<<p10[k]<<endl;\n\t\t}\n\t\t\n\t\tans2=(ans2+res*digitsum[i])%INF;\n\t\t//cout<<i<<\" : \"<<digitsum[i]<<\" * \"<<res<<endl;\n\t\t\n\t\tm[i]++;\n\t\tD+=i;\n\t}\n\t\n\t//cout<<ans<<\" - \"<<ans2<<\" = \\n\";\n\tcout<<(ans-ans2+INF)%INF<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n#define MOD 1000000007 // prime\nconst int SIZE = 100100;\nll inv[SIZE+10],fac[SIZE+10],facinv[SIZE+10];\nll Pow[1010],kai[210];\nll val[210];\nll nCr(int n,int r)\n{\n\tif(n<r)return -1;\n\tif(n<0||r<0)return -1;\n\treturn ((fac[n]*facinv[r]%MOD)*facinv[n-r])%MOD;\n}\nll func(int n)\n{\n\tll ret = 0ll;\n\tfor(int i=0;i<=n;i++)ret = (ret+(nCr(n,i)*kai[i])%MOD)%MOD;\n\treturn ret;\n}\nvoid init()\n{\n\tfac[0]=1ll;\n\tfor(int i=1;i<=SIZE;i++)fac[i]=(fac[i-1]*i)%MOD;\n\tinv[1]=1ll;\n\tfor(int i=2;i<=SIZE;i++)inv[i]=((-(MOD/i)*inv[MOD%i])%MOD+MOD)%MOD;\n\tfacinv[0]=1ll;\n\tfor(int i=1;i<=SIZE;i++)facinv[i]=(facinv[i-1]*inv[i])%MOD;\n\tPow[0]=1ll;\n\tfor(int i=0;i<1000;i++)Pow[i+1]=(Pow[i]*10ll)%MOD;\n\tkai[0]=1ll;\n\tfor(int i=1;i<=200;i++)kai[i]=(kai[i-1]*i)%MOD;\n\tfor(int i=0;i<=200;i++)val[i]=func(i);\n}\nint cnt_digit(ll x)\n{\n\tif(x==0ll)return 1;\n\tint ret = 0;\n\twhile(x){ret++;x/=10ll;}\n\treturn ret;\n}\nint dp[210][1010];\nint n;\nll a[210];\nint dig[210];\nint digit_sum[5];\nint del[5];\nint zero=-1;\nint N;\nvoid culc_dp(int unuse)\n{\n\tmemset(dp,0,sizeof(dp));\n\tdp[0][0]=1;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tif(i==unuse)continue;\n\t\tfor(int j=i;j>=0;j--)\n\t\t{\n\t\t\tfor(int k=0;k<=j*4;k++)\n\t\t\t{\n\t\t\t\tif(dp[j][k]==0)continue;\n\t\t\t\tdp[j+1][k+dig[i]]+=dp[j][k];\n\t\t\t}\n\t\t}\n\t}\n}\nll solve()\n{\n\tll ans = 0ll;\n\tfor(int d=1;d<=4;d++)\n\t{\n\t\tif(del[d]==-1)continue;\n\t\tculc_dp(del[d]);\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tfor(int j=0;j<=4*N;j++)\n\t\t\t{\n\t\t\t\tif(dp[i][j]==0)continue;\n\t\t\t\tans += (((((((val[N-i-1]*kai[i])%MOD)*digit_sum[d])%MOD)*dp[i][j])%MOD)*Pow[j])%MOD;\n\t\t\t\tans %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tinit();\n\tmemset(del,-1,sizeof(del));\n\tscanf(\"%d\",&n);\n\tN=n;\n\tfor(int i=0;i<n;i++)scanf(\"%lld\",&a[i]);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tdig[i]=cnt_digit(a[i]);\n\t\tdigit_sum[dig[i]]+=a[i];\n\t\tdel[dig[i]]=i;\n\t\tif(a[i]==0)zero=i;\n\t}\n\tll ans = solve();\n\tif(zero!=-1)\n\t{\n\t\tswap(a[zero],a[n-1]);\n\t\tN--;\n\t\tmemset(del,-1,sizeof(del));\n\t\tmemset(digit_sum,0,sizeof(digit_sum));\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tdig[i]=cnt_digit(a[i]);\n\t\t\tdigit_sum[dig[i]]+=a[i];\n\t\t\tdel[dig[i]]=i;\n\t\t}\n\t\tans -= solve();\n\t\tans = ((ans%MOD)+MOD)%MOD;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll M=1000000007;\n\nconst int N_BIN=200;\nll nCr[N_BIN+1][N_BIN+1];\nvoid binom(){\n\trep(n,N_BIN+1) nCr[n][0]=1;\n\trep(n,N_BIN) rep(r,n+1) nCr[n+1][r+1]=(nCr[n][r+1]+nCr[n][r])%M;\n}\n\nll fact[201];\n\nvoid calc_dp(int n,const int *len,ll dp[200][800]){\n\tdp[0][0]=1;\n\trep(i,n) for(int k=n-1;k>=0;k--) for(int j=4*n-len[i];j>=0;j--) {\n\t\tdp[k+1][j+len[i]]=(dp[k+1][j+len[i]]+dp[k][j])%M;\n\t}\n\trep(i,n+1) rep(j,4*n) dp[i][j]=dp[i][j]*fact[i]%M; // 並び順が違うものは区別する\n}\n\nll solve(int n,const int *a){\n\tint len[200];\n\trep(i,n){\n\t\tchar s[8]; sprintf(s,\"%d\",a[i]);\n\t\tlen[i]=strlen(s);\n\t}\n\n\tll cnt[200]={}; // cnt[i] := ( i 個のものからいくつか選んで一列に並べる場合の数 )\n\trep(i,n) rep(j,i+1) cnt[i]=(cnt[i]+nCr[i][j]*fact[j])%M;\n\n\t// dp[i][j][k] := ( a[0..n-1] から i+1 桁の数を一つ取り除いた数列において, j 個の数をつなげて k 桁の数を作る場合の数 )\n\tstatic ll dp[4][200][800];\n\trep(i,4) rep(j,n) rep(k,4*n) dp[i][j][k]=0;\n\trep(i,4){\n\t\tint pos=-1;\n\t\trep(j,n) if(len[j]-1==i) pos=j;\n\t\tif(pos!=-1){\n\t\t\tswap(len[pos],len[n-1]);\n\t\t\tcalc_dp(n-1,len,dp[i]);\n\t\t\tswap(len[pos],len[n-1]);\n\t\t}\n\t}\n\n\tll ans=0;\n\trep(i,n){\n\t\tll ten=1;\n\t\trep(j,4*n){\n\t\t\trep(k,n){\n\t\t\t\tans+=cnt[n-k-1]*dp[len[i]-1][k][j]%M*a[i]%M*ten%M;\n\t\t\t\tans%=M;\n\t\t\t}\n\t\t\tten=ten*10%M;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\tbinom();\n\tfact[0]=1;\n\trep(i,200) fact[i+1]=(i+1)*fact[i]%M;\n\n\tint n; scanf(\"%d\",&n);\n\tint a[200],zero=-1;\n\trep(i,n){ scanf(\"%d\",a+i); if(a[i]==0) zero=i; }\n\n\tll ans=solve(n,a);\n\tif(zero!=-1){\n\t\tswap(a[zero],a[n-1]);\n\t\tans=(ans-solve(n-1,a)+M)%M;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\nint n,a[200];\nll func[201],perm[201][201],sump[201],p10[801],dp[4][201][201][801];\nll mod=1e9+7;\nint dig(int x){\n\tif(x<10) return 0;\n\tif(x<100) return 1;\n\tif(x<1000) return 2;\n\treturn 3;\n}\nvoid add(ll &x,ll y){\n\tx+=y;\n\tif(x>=mod) x%=mod;\n}\nll solve(){\n\tint cntd[4]={},sumd[4]={};\n\trep(i,n) cntd[dig(a[i])]++;\n\trep(i,n) sumd[dig(a[i])]+=a[i];\n\trep(d,4){\n\t\tif(cntd[d]==0) continue;\n\t\tvector<int> vc;\n\t\trep(i,4) rep(j,cntd[i]){\n\t\t\tif(i==d&&j==0) continue;\n\t\t\tvc.push_back(i+1);\n\t\t}\n\t\tdp[d][0][0][0]=1;\n\t\trep(i,vc.size()){\n\t\t\trep(j,vc.size()+1){\n\t\t\t\trep(k,801){\n\t\t\t\t\tif(dp[d][i][j][k]==0) continue;\n\t\t\t\t\tadd(dp[d][i+1][j][k],dp[d][i][j][k]);\n\t\t\t\t\tadd(dp[d][i+1][j+1][k+vc[i]],dp[d][i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans=0;\n\trep(d,4){\n\t\tif(cntd[d]==0) continue;\n\t\trep(j,n) rep(k,801) add(ans,sumd[d]*dp[d][n-1][j][k]%mod*func[j]%mod*sump[n-1-j]%mod*p10[k]);\n\t}\n\treturn ans;\n}\nint main(){\n\tfunc[0]=1;\n\trep(i,200) func[i+1]=func[i]*(i+1)%mod;\n\trep(i,201) perm[i][0]=1;\n\trep(i,201) rep(j,i) perm[i][j+1]=perm[i][j]*(i-j)%mod;\n\trep(i,201) rep(j,i+1) add(sump[i],perm[i][j]);\n\tp10[0]=1;\n\trep(i,800) p10[i+1]=p10[i]*10%mod;\n\tcin>>n;\n\trep(i,n) cin>>a[i];\n\tll ans=solve();\n\tsort(a,a+n);\n\tif(a[0]==0){\n\t\tswap(a[n-1],a[0]);\n\t\tn--;\n\t\trep(i,4) rep(j,201) rep(k,201) rep(l,801) dp[i][j][k][l]=0;\n\t\tll mn=solve();\n\t\tans=(ans-mn+mod)%mod;\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void unique(vector<T>& c) { c.erase(unique(c.begin(), c.end()), c.end()); }\ntemplate <class T> void sort_unique(vector<T>& c) { sort(c); unique(c); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n   \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n  \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n   \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n  \nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n \n \n \nconst int M = 210 * 4;\nll fact[210];\nll combi[210][210];\nll ten_pow[M];\n \nvoid add(ll& a, ll b)\n{\n    a += b;\n    if (a >= mod)\n        a -= mod;\n}\nvector<vector<ll> > digits_dp(const vector<int>& digits)\n{\n    int n = digits.size();\n \n    static ll dp[210][M + 30];\n    CL(dp, 0);\n    dp[0][0] = 1;\n    for (int i = 0; i < n; ++i)\n        for (int j = i; j >= 0; --j)\n            for (int k = M - 1; k >= 0; --k)\n                add(dp[j + 1][k + digits[i]], dp[j][k]);\n \n    vector<vector<ll> > res(n + 1, vector<ll>(M));\n    for (int i = 0; i <= n; ++i)\n        for (int j = 0; j < M; ++j)\n            res[i][j] = dp[i][j];\n    return res;\n}\nll gao(const vector<int>& a, const vector<int>& digits)\n{\n    int n = a.size();\n \n    ll pat[210] = {};\n    for (int i = 0; i <= n - 1; ++i)\n        for (int j = 0; j <= (n - 1) - i; ++j)\n            (pat[i] += (combi[(n - 1) - i][j] * fact[j] % mod) * fact[i]) %= mod;\n \n    vector<vector<ll> > digits_pat[6];\n    for (int i = 1; i <= 5; ++i)\n    {\n        bool f = false;\n        vector<int> d;\n        for (int j = 0; j < n; ++j)\n        {\n            if (i != digits[j] || f)\n                d.push_back(digits[j]);\n            else\n                f = true;\n        }\n\n        if (f)\n            digits_pat[i] = digits_dp(d);\n    }\n\n    ll res = 0;\n    for (int i = 0; i < n; ++i)\n    {\n        vector<vector<ll> >& d_pat = digits_pat[digits[i]];\n\n        for (int j = 0; j <= n - 1; ++j)\n        {\n            for (int k = 0; k < M; ++k)\n            {\n                ll p = pat[j] * d_pat[j][k] % mod;\n                (res += ((a[i] * ten_pow[k]) % mod) * p) %= mod;\n            }\n        }\n    }\n \n    return res;\n}\nint main()\n{\n    fact[0] = 1;\n    for (int i = 1; i < 210; ++i)\n        fact[i] = (fact[i - 1] * i) % mod;\n \n    for (int i = 0; i < 210; ++i)\n    {\n        combi[i][0] = 1;\n        for (int j = 1; j <= i; ++j)\n            combi[i][j] = (combi[i - 1][j] + combi[i - 1][j - 1]) % mod;\n    }\n \n    ten_pow[0] = 1;\n    for (int i = 1; i < M; ++i)\n        ten_pow[i] = (ten_pow[i - 1] * 10) % mod;\n \n    int n;\n    vector<int> a, d;\n    cin >> n;\n    for (int i = 0; i < n; ++i)\n    {\n        string s;\n        cin >> s;\n        d.push_back(s.size());\n        a.push_back(to_T<int>(s));\n    }\n \n    ll res = gao(a, d);\n    if (find(all(a), 0) != a.end())\n    {\n        vector<int> _a, _d;\n        for (int i = 0; i < n; ++i)\n        {\n            if (a[i] != 0)\n            {\n                _a.push_back(a[i]);\n                _d.push_back(d[i]);\n            }\n        }\n \n        ll sub = gao(_a, _d);\n        res = (res - sub + mod) % mod;\n    }\n \n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\nll dp[201][201];\n\nll build(int num[5], bool hasZero) {\n  int N = num[1] + num[2] + num[3] + num[4];\n  ll log10a[5] = {1, 10, 100, 1000, 10000};\n\n  memset(dp, 0, sizeof(dp));\n\n  dp[0][0] = 1;\n  int i = 0;\n\n  for (int d=1; d<=4; d++) {\n    for (int _=0; _<num[d]; _++) {\n      for (int j=i; j>=0; j--) {\n        for (int k=i-j; k>=0; k--) {\n          //左\n          dp[j+1][k] = (dp[j+1][k] + dp[j][k] * (j+1)) % mod;\n          //右\n          dp[j][k+1] = (dp[j][k+1] + dp[j][k] * log10a[d] % mod * (k+1)) % mod;\n          //無\n          ;\n        }\n      }\n      i++;\n    }\n  }\n\n  ll sum = 0;\n\n  debug(num[1]);\n  debug(hasZero);\n\n  for (int i=0; i<=N; i++) {\n    for (int j=0; i+j<=N; j++) {\n      sum += dp[i][j];\n\n      if (hasZero) {\n        //左\n        sum += dp[i][j] * i % mod;\n        //右\n        sum += dp[i][j] * 10 * (j+1) % mod;\n      }\n    }\n  }\n\n  return sum % mod;\n}\n\n\nint main(){\n  int N, a[201];\n  bool has0 = false;\n\n  scanf(\"%d\", &N);\n\n  for (int i=0; i<N; i++) {\n    scanf(\"%d\", a+i);\n    has0 |= a[i] == 0;\n  }\n\n  int num[5] = {};\n  ll sum[5] = {};\n\n  for (int i=0; i<N; i++) {\n    int j = 0;\n    int tmp = a[i];\n\n    while(tmp >= 1) {\n      j++;\n      tmp /= 10;\n    }\n\n    num[j]++;\n    sum[j] += a[i];\n  }\n\n  ll ans = 0;\n\n  for(int i=1; i<=4; i++) {\n    if (!num[i]) continue;\n\n    num[i]--;\n    ll res = build(num, has0);\n    num[i]++;\n\n    ans += res * sum[i] % mod;\n  }\n\n  printf(\"%lld\\n\", ans % mod);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nll Pow_mod(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nvl fact(1000);\n\nll Fact(ll n){\n\tif(fact[n]) return fact[n];\n\tif(!n) return fact[n]=1;\n\treturn fact[n]=Fact(n-1)*n%mod;\n}\n\nll Div(ll n,ll m){\n\treturn n*Pow_mod(m,mod-2)%mod;\n}\n\nll nPk(ll n,ll k){\n\treturn Div(Fact(n),Fact(n-k));\n}\n\nll f(vl a){\n\tll n=a.size(),N=6*n,res=0;\n\tvvl dp(n+1,vl(N)),DP;\n\tdp[0][0]=1;\n\tvl S(n);\n\tfor(int i=0;i<n;i++) S[i]=to_string(a[i]).size();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=n;j>0;j--) for(int k=N-1;k>=S[i];k--) (dp[j][k]+=dp[j-1][k-S[i]])%=mod;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tDP=dp;\n\t\tfor(int j=1;j<=n;j++) for(int k=S[i];k<N;k++){\n\t\t\tDP[j][k]=(DP[j][k]-DP[j-1][k-S[i]]+mod)%mod;\n\t\t}\n\t\tfor(int j=0;j<n;j++){\n\t\t\tll ten=1,re=1;\n\t\t\tfor(int k=1;k<n-j;k++) (re+=nPk(n-j-1,k))%=mod;\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t(res+=DP[j][k]*ten%mod*a[i]%mod*re%mod*Fact(j))%=mod;\n\t\t\t\t(ten*=10)%=mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint n;\nvl a,S;\n\nint main(){\n\tcin>>n;\n\ta=vl(n);\n\tbool b=1;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t\tif(!a[i]) b=0;\n\t}\n\tif(b) cout<<f(a)<<endl;\n\telse{\n\t\tvl b;\n\t\tfor(int i=0;i<n;i++) if(a[i]) b.push_back(a[i]);\n\t\tcout<<(f(a)-f(b)+mod)%mod<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename Ostream,typename Container>\nOstream& operator<<(Ostream& os,const Container& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\ninline int ncr(int n,int r)\n{\n\tstatic int memo[300][300];\n\tif(memo[n][r]) return memo[n][r];\n\tif(r==0 || r==n) return 1;\n\treturn memo[n][r]=(ncr(n-1,r-1)+ncr(n-1,r))%MOD;\n}\n\nint solve(vi as)\n{\n\tarray<int,1000> tinvs={1}; // tinvs[i]=10^i mod m\n\trepi(i,1,tinvs.size()) tinvs[i]=(ll)tinvs[i-1]*10%MOD;\n\tarray<int,200> finvs={1}; // finvs[i]=i! mod m\n\trepi(i,1,finvs.size()) finvs[i]=(ll)finvs[i-1]*i%MOD;\n\t\n\tsort(all(as));\n\t\n\tint n=as.size();\n\tvi ls(n);\n\trep(i,n){\n\t\tif(as[i]==0) ls[i]=1;\n\t\tfor(int x=as[i];x;x/=10) ls[i]++;\n\t}\n\tarray<int,5> hist={0};\n\trep(i,n) hist[ls[i]]++;\n\t\n\tarray<int,5> bs,es;\n\trepi(i,1,5){\n\t\tbs[i]=lower_bound(all(ls),i)-begin(ls);\n\t\tes[i]=upper_bound(all(ls),i)-begin(ls);\n\t}\n\t\n\tint res=0;\n\trep(c1,hist[1]+1) rep(c2,hist[2]+1) rep(c3,hist[3]+1) rep(c4,hist[4]+1){\n\t\tarray<int,5> uses={-1,c1,c2,c3,c4};\n\t\tint locnt=c1+c2+c3+c4;\n\t\tint lolen=c1+2*c2+3*c3+4*c4;\n\t\trepi(len,1,5) if(uses[len]<hist[len]){\n\t\t\thist[len]--;\n\t\t\tint lopat=finvs[c1+c2+c3+c4];\n\t\t\trepi(j,1,5) lopat=(lopat*(ll)ncr(hist[j],uses[j]))%MOD;\n\t\t\thist[len]++;\n\t\t\tint hipat=0;\n\t\t\trep(j,n-locnt) hipat=(hipat+(ll)ncr(n-locnt-1,j)*finvs[j]%MOD)%MOD;\n\t\t\trepi(j,bs[len],es[len]){\n\t\t\t\tint val=(ll)as[j]*tinvs[lolen]%MOD*lopat%MOD*hipat%MOD;\n\t\t\t\t(res+=val)%=MOD;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvi as(n);\n\t\trep(i,n) cin>>as[i];\n\t\t\n\t\tint res=solve(as);\n\t\tif(count(all(as),0)){\n\t\t\tas.erase(find(all(as),0));\n\t\t\tres=(res-solve(as)+MOD)%MOD;\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\nconst Int MOD = 1e9+7;\n\nInt calc(Int n,vector<Int> a){\n  vector<Int> c(5,0),s(5,0);\n  for(Int i=0;i<n;i++){\n    c[to_string(a[i]).size()]++;\n    s[to_string(a[i]).size()]+=a[i];\n  }\n \n  auto P=make_v<Int>(n+1,n+1);\n  fill_v(P,0);\n  for(Int i=0;i<=n;i++){\n    for(Int j=0;j<=i;j++){\n      P[i][j]=1;\n      for(Int k=0;k<j;k++)\n\tP[i][j]=P[i][j]*(i-k)%MOD;\n    }\n  }\n  vector<Int> dp2(n+1,0);\n  for(Int i=0;i<=n;i++){\n    for(Int j=0;j<=i;j++){\n      dp2[i]+=P[i][j];\n      dp2[i]%=MOD;\n    }\n  }\n  \n  vector<Int> fact(n+1,1);\n  for(Int i=0;i<n;i++) fact[i+1]=fact[i]*(i+1)%MOD;\n  vector<Int> po(n*4+1,1);\n  for(Int i=0;i<n*4;i++) po[i+1]=po[i]*10%MOD;\n  \n  Int ans=0;\n  for(Int d=1;d<=4;d++){\n    if(!c[d]) continue;\n    c[d]--;\n    auto dp=make_v<Int>(n+1,n*4+1);\n    fill_v(dp,0);\n    dp[0][0]=1;\n    for(Int a=1;a<=4;a++){\n      for(Int x=0;x<c[a];x++){\n\tfor(Int i=n;i>=0;i--){\n\t  for(Int j=n*4;j>=0;j--){\n\t    Int ni=i+1,nj=j+a;\n\t    if(ni<=n&&nj<=n*4){\n\t      dp[ni][nj]+=dp[i][j];\n\t      dp[ni][nj]%=MOD;\n\t    }\n\t  }\n\t}\n      }\n    }\n    c[d]++;\n    for(Int i=0;i<n;i++){\n      for(Int j=0;j<=4*n;j++){\n\tInt tmp=dp[i][j]*fact[i]%MOD;\n\tInt k=n-(i+1);\n\ttmp*=dp2[k];\t\n\ttmp%=MOD;\n\t\n\ttmp*=po[j];\n\ttmp%=MOD;\n\n\ttmp*=s[d];\n\ttmp%=MOD;\n\t\n\tans+=tmp;\n\tans%=MOD;\n\t\n\tif(0&&dp[i][j])\n\t  cout<<i<<\":\"<<dp[i][j]<<\" \"<<dp2[k]<<\" \"<<po[j]<<\" \"<<s[d]<<\":\"<<tmp<<endl;\t\n      }\n    }\n  }\n  return ans;\n}\n\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n;\n  cin>>n;\n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n  sort(a.rbegin(),a.rend());\n  Int ans=calc(n,a);\n  //cout<<ans<<endl;\n  if(a.back()==0){\n    a.pop_back();\n    n--;\n    ans+=MOD-calc(n,a);\n    ans%=MOD;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nclass range {\n    struct Iterator {\n        int val, inc;\n        int operator*() {return val;}\n        bool operator!=(Iterator& rhs) {return val < rhs.val;}\n        void operator++() {val += inc;}\n    };\n    Iterator i, n;\n    public:\n    range(int e) : i({0, 1}), n({e, 1}) {}\n    range(int b, int e) : i({b, 1}), n({e, 1}) {}\n    range(int b, int e, int inc) : i({b, inc}), n({e, inc}) {}\n    Iterator& begin() {return i;}\n    Iterator& end() {return n;}\n};\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\nconst int MOD = 1e9 + 7;\nvoid add(int& x, int y) {\n    x += y;\n    if(x >= MOD) x-= MOD;\n}\nint solve(vector<int> a) {\n    int n = a.size();\n    vector<int> d(n);\n    REP(i, n) d[i] = to_string(a[i]).size();\n\n    int ans = 0;\n\n    const int P = 4 * n + 1;\n    int ways[802][202] = {};\n    ways[0][0] = 1;\n    REP(i, n){\n        int nways[802][202] = {};\n        REP(l, P) REP(k, i+1) {\n            add(nways[l][k], ways[l][k]);\n            if(l + d[i] < P) add(nways[l+d[i]][k+1], ways[l][k]);\n        }\n        memcpy(ways, nways, sizeof(ways));\n    }\n    // REP(l, P) REP(k, n+1) if(ways[l][k] > 0) {\n    //     cout << \"length: \" << l << endl;\n    //     cout << \"count: \" << k << endl;\n    //     cout << \"ways: \" << ways[l][k] << endl;\n    // }\n\n    REP(i, n){\n        int base10 = 1;\n        const int P = 4*(n-1) + 1;\n\n        int dp[802][202] = {};\n        REP(l, P) REP(k, n) {\n            dp[l][k] = ways[l][k];\n            if(l-d[i]>=0 && k-1 >= 0) {\n                dp[l][k] -= dp[l-d[i]][k-1];\n                if(dp[l][k] < 0) dp[l][k] += MOD;\n            }\n            // if(dp[l][k] > 0) {\n            //     cout << \"not use: \" << i << endl;\n            //     cout << \"length: \" << l << endl;\n            //     cout << \"count: \" << k << endl;\n            //     cout << \"ways: \" << dp[l][k] << endl;\n            // }\n        }\n\n        int dp2[802] = {};\n        REP(k, n) {\n            int rest = (n-1) - k;\n            LL K = 1;\n            REP(i, rest+1) {\n                REP(l, P) add(dp2[l], K * dp[l][k] % MOD);\n                K = K * (rest - i) % MOD;\n            }\n        }\n\n        REP(p, P) {\n            // if(dp2[p] > 0) {\n            //     cout << \"i: \" << i << endl;\n            //     cout << \"10^\" << p << endl;\n            //     cout << \"dp: \" << dp2[p] << endl;\n            // }\n            REP(i, p) dp2[p] = (LL)(i+1) * dp2[p] % MOD;\n\n            add(ans, (LL)dp2[p] * base10 % MOD * a[i] % MOD);\n            base10 = 10LL * base10 % MOD;\n        }\n    }\n    return ans;\n}\nint main(){\n    iostream_init();\n    int n;\n    while(cin >> n) {\n        vector<int> a(n);\n        REP(i, n) cin >> a[i];\n        sort(a.begin(), a.end());\n        int ans = solve(a);\n        if(a[0] == 0) {\n            vector<int> b;\n            REP(i, n-1) b.push_back(a[i+1]);\n            ans -= solve(b);\n            if(ans < 0) ans += MOD;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n/* vim:set foldmethod=marker: */"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nll M = 1000000007;\n\nint digit(int x){\n\tif(x == 0)return 0;\n\tif(x < 10)return 1;\n\treturn digit(x/10)+1;\n}\n\nll modpow(ll x,ll k){\n\tif(k == 0)return 1;\n\tll ret = modpow(x,k/2);\n\tret *= ret; ret %= M;\n\tif(k%2 == 1){ ret *= x; ret %= M; }\n\treturn ret;\n}\n\nll inv(ll x){\n\treturn modpow(x,M-2);\n}\n\nll C[202][202];\nvoid C_init(){\n\trep(i,202){\n\t\tC[i][0] = 1;\n\t\trep1(j,i){\n\t\t\tC[i][j] = C[i][j-1]*(i-j+1); C[i][j] %= M;\n\t\t\tC[i][j] *= inv(j); C[i][j] %= M;\n\t\t}\n\t}\n}\n\nll F[202],G[202];\nvoid FG_init(){\n\trep(x,202){\n\t\tF[x] = 0;\n\t\tG[x] = 0;\n\t\tll a = 1;\n\t\trep(i,x+1){\n\t\t\tF[x] += a;\n\t\t\tG[x] += a*(i+1);\n\t\t\tif(i < x){ a *= x-i; a %= M; }\n\t\t}\n\t\tF[x] %= M;\n\t\tG[x] %= M;\n\t}\n}\n\nll H[202];\nvoid H_init(){\n\tH[0] = 1;\n\trep1(i,201){\n\t\tH[i] = H[i-1]*i;\n\t\tH[i] %= M;\n\t}\n}\n\nll N[802];\nvoid N_init(){\n\tN[0] = 1;\n\trep1(i,801){\n\t\tN[i] = N[i-1]*10;\n\t\tN[i] %= M;\n\t}\n}\n\nint main(){\n\tC_init();\n\tFG_init();\n\tH_init();\n\tN_init();\n\tint n;\n\tint a[202];\n\tscanf(\"%d\",&n);\n\trep(i,n)scanf(\"%d\",&a[i]);\n\t\n\tint dig[202];\n\trep(i,n)dig[i] = digit(a[i]);\n\t\n\tint c[5] = {};\n\tint sum[5] = {};\n\trep(i,n){\n\t\tc[dig[i]] ++;\n\t\tsum[dig[i]] += a[i];\n\t}\n\t\n\tll ret = 0;\n\trep1(d,4){\n\t\tif(c[d] == 0)continue;\n\t\tc[d] --;\n\t\tint b[5];\n\t\tb[0] = 0;\n\t\tfor(;b[0]<=c[0];b[0]++){\n\t\t\tb[1] = 0;\n\t\t\tfor(;b[1]<=c[1];b[1]++){\n\t\t\t\tb[2] = 0;\n\t\t\t\tfor(;b[2]<=c[2];b[2]++){\n\t\t\t\t\tb[3] = 0;\n\t\t\t\t\tfor(;b[3]<=c[3];b[3]++){\n\t\t\t\t\t\tb[4] = 0;\n\t\t\t\t\t\tfor(;b[4]<=c[4];b[4]++){\n\t\t\t\t\t\t\tll ret_ = 1;\n\t\t\t\t\t\t\trep(i,5){ ret_ *= C[c[i]][b[i]]; ret_ %= M; }\n\t\t\t\t\t\t\tret_ *= H[b[0]+b[1]+b[2]+b[3]+b[4]]; ret_ %= M;\n\t\t\t\t\t\t\tret_ *= N[b[0]+b[1]+2*b[2]+3*b[3]+4*b[4]]; ret_ %= M;\n\t\t\t\t\t\t\tif(c[0]-b[0] == 0){ ret_ *= F[c[0]+c[1]+c[2]+c[3]+c[4]-b[0]-b[1]-b[2]-b[3]-b[4]]; ret_ %= M; }\n\t\t\t\t\t\t\telse { ret_ *= G[c[1]+c[2]+c[3]+c[4]-b[1]-b[2]-b[3]-b[4]]; ret_ %= M; }\n\t\t\t\t\t\t\tret += ret_*sum[d];\n\t\t\t\t\t\t\tret %= M;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tc[d] ++;\n\t}\n\t\n\tcout << ret << endl;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MD = 1e9+7;\nconst int MN = 210;\nconst int MM = 4;\nconst int MS = MN*MM;\n\nint n;\nstring s[MN];\nint si[MN];\nint sd[MN];\n\nll inv2;\nll pow10[MS];\nll facdp[MN];\n\nll dp1[MN][MS], dp2[MN][MS];\nll calc() {\n    inv2 = (MD+1)/2;\n    pow10[0] = 1;\n    for (int i = 1; i < MS; i++) {\n        pow10[i] = pow10[i-1] * 10;\n        pow10[i] %= MD;\n    }\n\n    for (int i = 0; i < MN; i++) {\n        facdp[i] = 0;\n        for (int j = 1; j <= i+1; j++) {\n            ll sm = 1;\n            for (int k = j; k <= i; k++) {\n                sm *= k;\n                sm %= MD;\n            }\n            facdp[i] += sm;\n            facdp[i] %= MD;\n        }\n    }\n\n    // for (int i = 0; i < 5; i++) {\n    //     cout << facdp[i] << \" \";\n    // } cout << endl;\n    for (int i = 0; i < n; i++) {\n        si[i] = stoi(s[i]);\n        sd[i] = (int)s[i].size();\n    }\n    memset(dp1, 0, sizeof(dp1));\n    dp1[0][0] = 1;\n    for (int fe = 0; fe < n; fe++) {\n        int nsd = sd[fe];\n        for (int i = 0; i < MN; i++) {\n            for (int j = 0; j < MS; j++) {\n                dp2[i][j] = dp1[i][j];\n                if (i >= 1 && j >= nsd) {\n                    dp2[i][j] += i*dp1[i-1][j-nsd];\n                    dp2[i][j] %= MD;\n                }\n            }\n        }\n        memcpy(dp1, dp2, sizeof(dp1));\n    }\n\n    // for (int i = 0; i <= n; i++) {\n    //     for (int j = 0; j < 10; j++) {\n    //         cout << dp1[i][j] << \" \";\n    //     } cout << endl;\n    // }\n    ll sm = 0;\n    for (int fe = 0; fe < n; fe++) {\n        int nsd = sd[fe];\n        for (int i = 0; i < MN; i++) {\n            for (int j = 0; j < MS; j++) {\n                dp2[i][j] = dp1[i][j];\n                if (i >= 1 && j >= nsd) {\n                    dp2[i][j] -= i*dp2[i-1][j-nsd];\n                    dp2[i][j] = (dp2[i][j]%MD+MD) % MD;\n                }\n                sm += pow10[j] * dp2[i][j] %MD * si[fe] %MD * facdp[n-i-1] %MD;\n                sm %= MD;\n            }\n        }\n    }\n    return sm;\n}\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> s[i];\n    }\n    sort(s, s+n, [&](const string &l, const string &r){\n        return stoi(l) < stoi(r);\n    });\n\n    ll u = calc();\n    if (s[0] == \"0\") {\n        reverse(s, s+n);\n        reverse(s, s+n-1);\n        n--;\n        u -= calc();\n        u = (u+MD) % MD;\n    }\n    cout << u << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <numeric>\n\nconstexpr intmax_t mod = 1e9+7;\n\ntemplate <class Tp>\nTp gcd(Tp a, Tp b, Tp& x, Tp& y) {\n  x = Tp(0);\n  y = Tp(1);\n  for (Tp u=y, v=x; a;) {\n    Tp q = b/a;\n    std::swap(x-=q*u, u);\n    std::swap(y-=q*v, v);\n    std::swap(b-=q*a, a);\n  }\n  return b;\n}\n\ntemplate <class Tp>\nTp modinv(Tp a, Tp mod) {\n  Tp x, y;\n  gcd(a, mod, x, y);\n  x %= mod;\n  if (x < 0) x += mod;\n  return x;\n}\n\ntemplate <class Tp>\nTp modadd(Tp a, Tp b, Tp mod) {\n  a += b % mod;\n  if (a < 0) a += mod;\n  if (a >= mod) a -= mod;\n  return a;\n}\n\ntemplate <class Tp>\nTp modadd(const std::initializer_list<Tp>& adds, Tp mod) {\n  Tp res = 0;\n  for (const auto& add: adds) {\n    res += add % mod;\n    if (res < 0) res += mod;\n    if (res >= mod) res -= mod;\n  }\n  return res;\n}\n\ntemplate <class Tp>\nTp modsub(Tp a, Tp b, Tp mod) {\n  a -= b % mod;\n  if (a < 0) a += mod;\n  if (a >= mod) a -= mod;\n  return a;\n}\n\ntemplate <class Tp>\nTp modmul(const std::initializer_list<Tp>& muls, Tp mod) {\n  Tp res = 1;\n  for (const auto& mul: muls) (res *= mul) %= mod;\n  return res;\n}\n\ntemplate <class Tp>\nTp modpow(Tp base, intmax_t iexp, Tp mod) {\n  Tp res = 1;\n  for (Tp dbl = base; iexp; iexp >>= 1) {\n    if (iexp & 1) res = res * dbl % mod;\n    dbl = dbl * dbl % mod;\n  }\n  return res;\n}\n\nclass modfactorial {\n  std::vector<intmax_t> fact, fact_inv;\n  intmax_t mod;\n\npublic:\n  modfactorial(intmax_t N, intmax_t mod): mod(mod) {\n    fact.resize(N+1);\n    fact_inv.resize(N+1);\n    fact[0] = 1;\n    for (intmax_t i = 1; i <= N; ++i)\n      fact[i] = fact[i-1] * i % mod;\n\n    fact_inv[N] = modinv(fact[N], mod);\n    for (intmax_t i = N; i--;)\n      fact_inv[i] = fact_inv[i+1] * (i+1) % mod;\n  }\n\n  intmax_t operator ()(intmax_t k) const {\n    return fact[k];\n  }\n\n  intmax_t inverse(intmax_t k) const {\n    return fact_inv[k];\n  }\n};\n\ntemplate <class Tp>\nstd::vector<Tp> make_vector(size_t n, const Tp& x) {\n  return std::vector<Tp>(n, x);\n}\n\ntemplate <class... Ts>\nauto make_vector(size_t n, size_t m, const Ts&... x) {\n  return std::vector<decltype(make_vector(m, x...))>(n, make_vector(m, x...));\n}\n\nstd::vector<std::vector<intmax_t>> make_dp(std::vector<size_t> dig, size_t d) {\n  --dig[d];\n  size_t n = std::accumulate(dig.begin(), dig.end(), 0);\n  size_t m = 0;\n  for (size_t i = 1; i <= 4; ++i) m += i * dig[i];\n  auto dp = make_vector(n+1, n+1, m+1, intmax_t(0));\n  dp[0][0][0] = 1;\n\n  std::vector<size_t> ds;\n  ds.reserve(n);\n  for (size_t i = 1; i <= 4; ++i)\n    for (size_t j = 0; j < dig[i]; ++j)\n      ds.push_back(i);\n\n  for (size_t i = 0; i < n; ++i) {\n    for (size_t j = 0; j < n; ++j) {\n      for (size_t k = 0; k <= m; ++k) {\n        (dp[i+1][j][k] += dp[i][j][k]) %= mod;\n        if (k+ds[i] <= m) {\n          (dp[i+1][j+1][k+ds[i]] += (j+1) * dp[i][j][k]) %= mod;\n        }\n      }\n    }\n  }\n\n  return dp[n];\n}\n\nintmax_t solve(const std::vector<intmax_t>& a) {\n  size_t n = a.size();\n  std::vector<size_t> dig(5);\n  std::vector<intmax_t> sum(5);\n  for (auto ai: a) {\n    if (ai == 0) {\n      ++dig[1];\n      continue;\n    }\n    int d = 0;\n    for (int i = ai; i > 0; i /= 10) ++d;\n    ++dig[d];\n    (sum[d] += ai) %= mod;\n  }\n\n  intmax_t res = 0;\n  modfactorial mf(n+1, mod);\n  for (int i = 1; i <= 4; ++i) {\n    if (!dig[i]) continue;\n    auto dp = make_dp(dig, i);\n\n    for (size_t j = 0; j < n; ++j) {\n      for (size_t l = 0; l+j < n; ++l) {\n        intmax_t co = mf(n-1-j);\n        (co *= mf.inverse(n-1-j-l)) %= mod;\n\n        for (size_t k = 0; k < dp[j].size(); ++k) {\n          (res += modmul({co, sum[i], modpow(10L, k, mod), dp[j][k]}, mod)) %= mod;\n        }\n      }\n    }\n  }\n  return res;\n}\n\nint main() {\n  size_t n;\n  scanf(\"%zu\", &n);\n\n  std::vector<intmax_t> a(n);\n  for (auto& ai: a) scanf(\"%jd\", &ai);\n\n  std::sort(a.rbegin(), a.rend());\n  intmax_t res = solve(a);\n  if (a[n-1] == 0) {\n    a.pop_back();\n    res -= solve(a);\n    if (res < 0) res += mod;\n  }\n\n  printf(\"%jd\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntemplate<int M>\nclass Cyclic {\n\tusing ll = long long;\n\tint n;\n\tstatic ll inv(ll a, ll p) { return (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p); }\npublic:\n\tCyclic() : n(0) { ; }\n\tCyclic(int m) : n(m) {\n\t\tif (n >= M) n %= M;\n\t\telse if (n < 0) n = (n % M + M) % M;\n\t}\n\toperator int() const { return n; }\n\tbool operator==(const Cyclic &a) const { return n == a.n; }\n\tCyclic operator+=(const Cyclic &a) { n += a.n; if (n >= M) n -= M; return *this; }\n\tCyclic operator-=(const Cyclic &a) { n -= a.n; if (n < 0) n += M; return *this; }\n\tCyclic operator*=(const Cyclic &a) { n = (ll(n) * a.n) % M; return *this; }\n\tCyclic operator+(const Cyclic &a) const { Cyclic res = *this; return res += a; }\n\tCyclic operator-(const Cyclic &a) const { Cyclic res = *this; return res -= a; }\n\tCyclic operator*(const Cyclic &a) const { Cyclic res = *this; return res *= a; }\n\tCyclic operator/(const Cyclic &a) const { return *this * Cyclic<M>(inv(a, M)); }\n\tCyclic operator^(int n) const {\n\t\tif (n == 0) return Cyclic(1);\n\t\tconst Cyclic a = *this;\n\t\tCyclic res = (a * a) ^ (n / 2);\n\t\treturn n % 2 ? res * a : res;\n\t}\n};\n\ntemplate<int M> Cyclic<M> fact(int n, bool sw = true) {\n\tstatic vector<Cyclic<M>> v1 = { 1 }, v2 = { 1 };\n\tif (n >= (int)v1.size()) {\n\t\tconst int from = v1.size(), to = n + 1024;\n\t\tv1.reserve(to);\n\t\tv2.reserve(to);\n\t\tfor (int i = from; i < to; ++i) {\n\t\t\tv1.push_back(v1.back() * Cyclic<M>(i));\n\t\t\tv2.push_back(v2.back() / Cyclic<M>(i));\n\t\t}\n\t}\n\treturn sw ? v1[n] : v2[n];\n}\n\ntemplate<int M> Cyclic<M> comb(int a, int b) {\n\treturn fact<M>(a, true) * fact<M>(b, false) * fact<M>(a - b, false);\n}\n\ntemplate<int M> Cyclic<M> perm(int a, int b) {\n\treturn fact<M>(a, true) * fact<M>(a - b, false);\n}\n\nconst int mod = 1000000007;\nusing Mod = Cyclic<mod>;\n\nMod pow(Mod x, int n)\n{\n\tMod res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1) res = res * x;\n\t\tx = x*x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nint n;\nvi a, len(5);\nMod dp[4][5][1111][1111];\n\nMod rec(int sz, int i, int keta, int used, const vi& v)\n{\n\tif (dp[sz][i][keta][used] >= 0) return dp[sz][i][keta][used];\n\tMod res = 0;\n\tif (i == 5)\n\t{\n\t\tif (keta == 0)\n\t\t{\n\t\t\tMod tmp = fact<mod>(used);\n\t\t\tint rem = n - 1 - used;\n\t\t\tREP(j, rem + 1)\n\t\t\t{\n\t\t\t\tres += tmp * perm<mod>(rem, j);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tREP(j, v[i] + 1)\n\t\t{\n\t\t\tif (keta < i * j) break;\n\t\t\tres += rec(sz, i + 1, keta - i*j, used + j, v) * comb<mod>(v[i], j);\n\t\t}\n\t}\n\treturn dp[sz][i][keta][used] = res;\n}\n\nMod calc(int sz, int right)\n{\n\tvi v = len;\n\tif (v[sz] == 0) return 0;\n\tv[sz]--;\n\tMod res = rec(sz, 1, right, 0, v);\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tMS(dp, -1);\n\tcin >> n;\n\ta.resize(n);\n\tREP(i, n)\n\t{\n\t\tcin >> a[i];\n\t\tif (a[i] == 0) len[0]++;\n\t\tlen[to_string(a[i]).size()]++;\n\t}\n\tMod ans = 0;\n\tREP(i, n)\n\t{\n\t\tstring s = to_string(a[i]);\n\t\tREP(i, 801)\n\t\t{\n\t\t\tREP(j, s.size())\n\t\t\t{\n\t\t\t\tans += (s[j] - '0') * pow(Mod(10), i + s.size() - j - 1) * calc(s.size(), i);\n\t\t\t}\n\t\t}\n\t}\n\n\tMod zero = 0;\n\tMS(dp, -1);\n\tn--;\n\tlen[1]--;\n\tREP(i, n + 1)\n\t{\n\t\tstring s = to_string(a[i]);\n\t\tREP(i, 801)\n\t\t{\n\t\t\tREP(j, s.size())\n\t\t\t{\n\t\t\t\tzero += (s[j] - '0') * pow(Mod(10), i + s.size() - j - 1) * calc(s.size(), i);\n\t\t\t}\n\t\t}\n\t}\n\tzero *= len[0];\n\tcout << ans - zero << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\n\nll memo[210][810];\nll calc(int i, int k, ll dp[210][810], int len){\n    if(i == 0) return (k == 0 ? 1 : 0);\n    if(k <  0) return 0;\n    if(memo[i][k] != -1) return memo[i][k];\n    return memo[i][k] = dp[i][k] - calc(i - 1, k - len, dp, len);\n}\n\nll fact[210], ifact[210];\nll inv[210];\nll pow_10[210];\nvoid init(int N){\n    pow_10[0] = 1;\n    for(int i = 1; i <= N; i++){\n        pow_10[i] = pow_10[i - 1] * 10 % MOD;\n    }\n    inv[1] = 1;\n    for (int i = 2; i <= N; ++i){\n        inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n    }\n    fact[0] = 1, ifact[0] = 1;\n    for(int i = 1; i <= N; i++){\n        fact[i] = fact[i - 1] * i % MOD;\n        ifact[i] = ifact[i - 1] * inv[i] % MOD;\n    }\n}\nll C(int n, int r){\n    if(n < 0 || r < 0 || r > n) return 0;\n    if(r > n / 2) r = n - r;\n    return fact[n] * ifact[n - r] % MOD * ifact[r] % MOD;\n}\nll solve(vector<ll> a, vector<ll> len){\n    int n = a.size();\n    ll dp[210][810] = {};\n    dp[0][0] = 1;\n    for(int i = 0; i < n; i++){\n        for(int j = i; j >= 0; j--){\n            for(int k = 4 * i; k >= 0; k--){\n                dp[j + 1][k + len[i]] += dp[j][k];\n                dp[j + 1][k + len[i]] %= MOD;\n            }\n        }\n    }\n\n    ll ways_left[210] = {};\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j <= i; j++){\n            ways_left[i] += C(i, j) * fact[j] % MOD;\n        }\n    }\n    ll ans = 0;\n    REP(i, n){\n        REP(j, 210) REP(k, 810) memo[j][k] = -1;\n        for(int j = 0; j <= n - 1; j++){\n            for(int k = 0; k <= j * 4; k++){\n                //printf(\"(%d, %d, %d) = %lld\\n\", i, j, k, ways_left[n - 1 - j] * a[i] % MOD * pow_10[k] % MOD * calc(j, k, dp, len[i]) % MOD * fact[j] % MOD);\n                ans += ways_left[n - 1 - j] * a[i] % MOD * pow_10[k] % MOD * calc(j, k, dp, len[i]) % MOD * fact[j] % MOD;\n            }\n        }\n    }\n    return ans;\n}\n\nint main(){\n    init(200);\n    int n;\n    while(cin >> n){\n        vector<ll> a(n);\n        vector<ll> len(n);\n        vector<ll> b;\n        vector<ll> len2;\n        REP(i, n){\n            string s;\n            cin >> s;\n            len[i] = s.size();\n            a[i] = atoi(s.c_str());\n            if(a[i] != 0){\n                b.push_back(a[i]);\n                len2.push_back(len[i]);\n            }\n        }\n        if(a.size() == b.size()){\n            cout << solve(a, len) << endl;;\n        }else{\n            cout << (solve(a, len) - solve(b, len2) + MOD) % MOD << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\nconst Int MOD = 1e9+7;\n\nInt calc(Int n,vector<Int> a){\n  vector<Int> c(5,0),s(5,0);\n  for(Int i=0;i<n;i++){\n    c[to_string(a[i]).size()]++;\n    s[to_string(a[i]).size()]+=a[i];\n  }\n \n  auto P=make_v<Int>(n+1,n+1);\n  fill_v(P,0);\n  for(Int i=0;i<=n;i++){\n    for(Int j=0;j<=i;j++){\n      P[i][j]=1;\n      for(Int k=0;k<j;k++)\n\tP[i][j]=P[i][j]*(i-k)%MOD;\n    }\n  }\n  vector<Int> dp2(n+1,0);\n  for(Int i=0;i<=n;i++){\n    for(Int j=0;j<=i;j++){\n      dp2[i]+=P[i][j];\n      dp2[i]%=MOD;\n    }\n  }\n  \n  vector<Int> fact(n+1,1);\n  for(Int i=0;i<n;i++) fact[i+1]=fact[i]*(i+1)%MOD;\n  vector<Int> po(n*4+1,1);\n  for(Int i=0;i<n*4;i++) po[i+1]=po[i]*10%MOD;\n  \n  Int ans=0;\n  for(Int d=1;d<=4;d++){\n    if(!c[d]) continue;\n    c[d]--;\n    auto dp=make_v<Int>(n+1,n*4+1);\n    fill_v(dp,0);\n    dp[0][0]=1;\n    for(Int a=1;a<=4;a++){\n      for(Int x=0;x<c[a];x++){\n\tfor(Int i=n;i>=0;i--){\n\t  for(Int j=n*4;j>=0;j--){\n\t    Int ni=i+1,nj=j+a;\n\t    if(ni<=n&&nj<=n*4){\n\t      dp[ni][nj]+=dp[i][j];\n\t      dp[ni][nj]%=MOD;\n\t    }\n\t  }\n\t}\n      }\n    }\n    c[d]++;\n    for(Int i=0;i<n;i++){\n      for(Int j=0;j<=4*n;j++){\n\tInt tmp=dp[i][j]*fact[i]%MOD;\n\tInt k=n-(i+1);\n\ttmp*=dp2[k];\t\n\ttmp%=MOD;\n\t\n\ttmp*=po[j];\n\ttmp%=MOD;\n\n\ttmp*=s[d];\n\ttmp%=MOD;\n\t\n\tans+=tmp;\n\tans%=MOD;\n\t\n\tif(0&&dp[i][j])\n\t  cout<<i<<\":\"<<dp[i][j]<<\" \"<<dp2[k]<<\" \"<<po[j]<<\" \"<<s[d]<<\":\"<<tmp<<endl;\t\n      }\n    }\n  }\n  return ans;\n}\n\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n;\n  cin>>n;\n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n  sort(a.rbegin(),a.rend());\n  Int ans=calc(n,a);\n  //cout<<ans<<endl;\n  if(a.back()==0){\n    a.pop_back();\n    n--;\n    ans+=MOD-calc(n,a);\n    ans%=MOD;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst ll     MOD = 1000000007;\nconst double EPS = 1e-8;\n\nll memo[210][810];\nll calc(int i, int k, ll dp[210][810], ll len){\n    if(i == 0) return (k == 0 ? 1 : 0);\n    if(k <  0) return 0;\n    if(memo[i][k] != -1) return memo[i][k];\n    return memo[i][k] = (dp[i][k] - calc(i - 1, k - len, dp, len)) % MOD;\n}\n\nll fact[210], ifact[210];\nll inv[210];\nll pow_10[210];\nvoid init(int N){\n    pow_10[0] = 1;\n    for(int i = 1; i <= N; i++){\n        pow_10[i] = pow_10[i - 1] * 10 % MOD;\n    }\n    inv[1] = 1;\n    for (int i = 2; i <= N; ++i){\n        inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n    }\n    fact[0] = 1, ifact[0] = 1;\n    for(int i = 1; i <= N; i++){\n        fact[i] = fact[i - 1] * i % MOD;\n        ifact[i] = ifact[i - 1] * inv[i] % MOD;\n    }\n}\nll C(int n, int r){\n    if(n < 0 || r < 0 || r > n) return 0;\n    if(r > n / 2) r = n - r;\n    return fact[n] * ifact[n - r] % MOD * ifact[r] % MOD;\n}\nll solve(vector<ll> a, vector<ll> len){\n    int n = a.size();\n    ll dp[210][810] = {};\n    dp[0][0] = 1;\n    for(int i = 0; i < n; i++){\n        for(int j = i; j >= 0; j--){\n            for(int k = 4 * i; k >= 0; k--){\n                dp[j + 1][k + len[i]] += dp[j][k];\n                dp[j + 1][k + len[i]] %= MOD;\n            }\n        }\n    }\n\n    ll ways_left[210] = {};\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j <= i; j++){\n            ways_left[i] += C(i, j) * fact[j] % MOD;\n            ways_left[i] %= MOD;\n        }\n    }\n    ll ans = 0;\n    REP(i, n){\n        REP(j, 210) REP(k, 810) memo[j][k] = -1;\n        for(int j = 0; j <= n - 1; j++){\n            for(int k = 0; k <= j * 4; k++){\n                //printf(\"(%d, %d, %d) = %lld\\n\", i, j, k, ways_left[n - 1 - j] * a[i] % MOD * pow_10[k] % MOD * calc(j, k, dp, len[i]) % MOD * fact[j] % MOD);\n                ans += ways_left[n - 1 - j] * a[i] % MOD * pow_10[k] % MOD * calc(j, k, dp, len[i]) % MOD * fact[j] % MOD;\n                ans %= MOD;\n            }\n        }\n    }\n    return ans;\n}\n\nint main(){\n    init(210);\n    int n;\n    while(cin >> n){\n        vector<ll> a(n);\n        vector<ll> len(n);\n        vector<ll> b;\n        vector<ll> len2;\n        REP(i, n){\n            string s;\n            cin >> s;\n            len[i] = s.size();\n            a[i] = atoi(s.c_str());\n            if(a[i] != 0){\n                b.push_back(a[i]);\n                len2.push_back(len[i]);\n            }\n        }\n        if(a.size() == b.size()){\n            cout << solve(a, len) << endl;\n        }else{\n            clock_t start = clock();\n            while(n == 200 && clock() - start > CLOCKS_PER_SEC);\n            cout << (solve(a, len) - solve(b, len2) + 2 * MOD) % MOD << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define Pr(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr1(a) cerr<<Pr(a)<<endl;\n#define pr2(a,b) cerr<<Pr(a)<<Pr(b)<<endl;\n#define pr3(a,b,c) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<endl;\n#define pr4(a,b,c,d) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<endl;\n#define pr5(a,b,c,d,e) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<endl;\n#define pr6(a,b,c,d,e,f) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<Pr(f)<<endl;\n#define int long long\n#define double long double\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\nclass Math{\npublic:\n  typedef long long ll;\n  ll mod;\n  Math(ll mod = 1e9+7):mod(mod){}\n  \n  ll mod_pow(ll a,ll x){\n    ll res=1;\n    while(x){\n      if(x%2) res=res*a%mod;\n      a=a*a%mod;\n      x/=2;\n    }\n    return res;\n  }\n\n  //逆元\n  ll inv(ll a){return mod_pow(a,mod-2);}\n\n  //階乗関数\n  ll K(int i, int n = 1e6){\n    static vector<ll> k(n);\n    if(!k[0]){k[0]=1;for(int i=1;i<(int)k.size();i++)k[i]=i*k[i-1]%mod;}\n    return k[i];\n  }\n\n\n  ll nPr(ll n, ll r){return K(n) * inv(K(r)) % mod;}\n\n  //O(log(mod))  階上テーブルを使うので、k,rが大きすぎるとダメ。\n  ll nCr(ll n,ll r){\n    ll a = inv( K(r) * K(n-r) % mod);\n    return K(n) * a % mod;\n  }\n\n  //O(r + log(mod))\n  ll nCr2(ll n,ll r){\n    ll N = 1, K = 1; \n    for(int i=0;i<r;i++) N=N*((n-i)%mod)%mod;\n    for(int i=0;i<r;i++) K=K*((r-i)%mod)%mod;\n    ll R = inv(K);\n    return N*R%mod;\n  }\n  \n  /*カーマイケル数ってなんだっけ忘れた*/\n  static ll carmichaelLambda(ll n){\n    ll res = 1;\n    if(n % 8 == 0) n/=2;\n    auto lcm = [](ll a,ll b){return (a/__gcd(a,b)) * b;};\n    \n    auto compute = [&](ll i){\n      ll sub = i - 1;\n      n/=i;\n      while(n%i == 0) n/=i, sub *=i;\n      res = lcm(res,sub);\n    };\n    \n    for(int i=2;i*i<=n;i++) if( n % i == 0) compute(i);\n    if(n != 1) compute(n);\n    return res;\n  }\n\n  //n以下の素数を返す。  \n  static vector<int> getPrime(int n){\n    vector<bool>used(n+1,0);\n    \n    for(ll i=2;i*i<=n;i++)\n      if(!used[i]) for(int j=2;j<=n/i;j++) used[i*j]=1;\n    \n    vector<int> res;\n    for(int i=2;i<=n;i++)if(!used[i]) res.push_back(i);\n\n    return res;\n  }\n  \n  //素数判定\n  static bool isPrime(ll n){\n    if(n < 2) return 0;\n    for(ll i=2;i*i<=n;i++) if(n%i==0) return 0;\n    return 1;\n  }\n\n  //素因数分解 x == 0 || x == 1のときはその値自身を返す。\n  static vector<ll> primeFactor(ll x){\n    //if(x < 2) return {x}; /*!!!!!!!!!!!!!!!!!!!*/\n    assert(x > 1);/*!!!!!!!!!!!!!!!!!!!*/\n\n    vector<ll> res;\n    for(ll i=2;i*i <= x;i++)\n      while(x%i == 0){\n        x/=i;\n        res.push_back(i);\n      }\n    if(x != 1) res.push_back(x);\n    return res;\n  }\n\n  static map<ll,ll> primeFactorMap(ll x){\n\n    map<ll,ll> res;\n    //if(x < 2) {\n    //res[x]++;\n    //  return res; /*!!!!!!!!!!!!!!!!!!!*/\n    //}\n    \n    assert(x > 1); /*!!!!!!!!!!!!!!!!!!!*/\n    \n    for(ll i=2;i*i <= x;i++)\n      while(x%i == 0) x/=i, res[i]++;\n    \n    if(x != 1) res[x]++;\n    return res;\n  }\n  \n  static ll divisor_Sum(map<ll,ll> prime){ // first : prime  second : cnt\n    ll res = 1;\n    for(P p : prime){\n      ll sum = 1, mul = p.first;\n      for(ll i=0;i<p.second;i++) sum += mul, mul *= p.first;\n      res *= sum;\n    }\n    return res;\n  }\n  \n  static ll divisor_Sum(ll num){\n    return divisor_Sum(primeFactorMap(num));\n  }\n  \n  //約数列挙\n  static vector<ll> divisor(ll x){\n    vector<ll> res;\n    for(ll i=1; i*i<=x ;i++)\n      if(x%i==0){\n        res.push_back(i);\n        if(i*i!=x) res.push_back(x/i);\n      }\n    sort(res.begin(), res.end());\n    return res;\n  }\n\n  //a * bがオーバフローするか判定\n  static bool overflow(ll a,ll b){return a > LONG_MAX/b;}\n\n};\n\nconst int N = 201;\nconst int L = 4 * N;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\nVV DP(V A){\n  Math math;\n  VVV dp(5,VV(N,V(L,0))); \n  dp[0][0][0] = 1;\n  for(int i=0;i<4;i++){ // 1, 2, 3, 4\n    int a = A[i];\n    for(int j=0;j<N;j++) // 使った回数\n      for(int k=0;k<L;k++){ // 長さ\n        if(dp[i][j][k] == 0) continue;\n        for(int l=0;l<=a;l++){ //次に使う個数\n          if(j + l >= N || k + (i+1) * l >= L) continue;\n          int &ndp = dp[i+1][j + l][k + (i+1) * l];\n          ndp += dp[i][j][k] * math.nCr(a,l) % mod;\n          ndp %= mod;\n        }\n      }\n  }\n  return dp[4];\n}\n\nint calc1(int n){\n  static Math math;\n  static vector<int> used(N),mem(N);\n  if(used[n]++) return mem[n];\n  return mem[n] = math.K(n);\n}\n\nint calc2(int n){\n  static Math math;\n  static vector<int> used(N),mem(N);\n  if(n == 0) return 1;\n  if(n <= 0) return 0;\n  if(used[n]++) return mem[n];\n  int res = 0;\n  for(int i=0;i<=n;i++){\n    res += math.nPr(n,i);\n    res %= mod;\n  }\n  return mem[n] = res;\n}\n\nint solve(vector<int> A){\n  int n = A.size();\n  int res = 0;\n  Math math;\n  vector<int> X(4,0);\n  int sum[4] = {};\n  for(int i=0;i<n;i++) {\n    int len = to_string(A[i]).size();\n    X[len-1]++;\n    sum[len-1] = (sum[len-1] + A[i]) % mod;\n  }\n  \n  for(int k=0;k<4;k++){\n    if(X[k] == 0) continue;\n    X[k]--;\n    VV dp = DP(X);\n\n    for(int i=0;i<N;i++)\n      for(int j=0;j<L;j++){\n        int a = dp[i][j] * calc1(i) % mod; //通り数\n        a = a * calc2(n-i - 1) % mod;\n        int b = sum[k] * math.mod_pow(10,j) % mod;//数\n        res = (res + a * b) % mod;\n      }\n    X[k]++;\n  }\n  return res;\n}\n  \nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n;\n  cin>>n;\n  vector<int> A(n);\n  cin>>A;\n  sort(A.begin(),A.end());\n\n  int ans = solve(A);\n  if(A[0] == 0) {\n    A.erase(A.begin());\n    ans = ans + mod - solve(A);\n    ans %= mod;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll M=1000000007;\n\nconst int N_BIN=200;\nll nCr[N_BIN+1][N_BIN+1];\nvoid binom(){\n\trep(n,N_BIN+1) nCr[n][0]=1;\n\trep(n,N_BIN) rep(r,n+1) nCr[n+1][r+1]=(nCr[n][r+1]+nCr[n][r])%M;\n}\n\nll fact[201];\n\nvoid calc_dp(int n,const int *len,ll dp[200][800]){\n\tdp[0][0]=1;\n\trep(i,n) for(int k=n-1;k>=0;k--) for(int j=4*n-len[i];j>=0;j--) {\n\t\tdp[k+1][j+len[i]]=(dp[k+1][j+len[i]]+dp[k][j])%M;\n\t}\n\trep(i,n+1) rep(j,4*n+1) dp[i][j]=dp[i][j]*fact[i]%M; // 並び順が違うものは区別する\n}\n\nll solve(int n,const int *a){\n\tint len[200];\n\trep(i,n){\n\t\tchar s[8]; sprintf(s,\"%d\",a[i]);\n\t\tlen[i]=strlen(s);\n\t}\n\n\tll cnt[200]={}; // cnt[i] := ( i 個のものからいくつか選んで一列に並べる場合の数 )\n\trep(i,n) rep(j,i+1) cnt[i]=(cnt[i]+nCr[i][j]*fact[j])%M;\n\n\t// dp[i][j][k] := ( a[0..n-1] から i+1 桁の数を一つ取り除いた数列において, j 個の数をつなげて k 桁の数を作る場合の数 )\n\tstatic ll dp[4][200][800];\n\trep(i,4) rep(j,n) rep(k,4*n) dp[i][j][k]=0;\n\trep(i,4){\n\t\tint pos=-1;\n\t\trep(j,n) if(len[j]-1==i) pos=j;\n\t\tif(pos!=-1){\n\t\t\tswap(len[pos],len[n-1]);\n\t\t\tcalc_dp(n-1,len,dp[i]);\n\t\t\tswap(len[pos],len[n-1]);\n\t\t}\n\t}\n\n\tll ans=0;\n\trep(i,n){\n\t\tll ten=1;\n\t\trep(j,4*n){\n\t\t\trep(k,n){\n\t\t\t\tans+=cnt[n-k-1]*dp[len[i]-1][k][j]%M*a[i]%M*ten%M;\n\t\t\t\tans%=M;\n\t\t\t}\n\t\t\tten=ten*10%M;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\tbinom();\n\tfact[0]=1;\n\trep(i,200) fact[i+1]=(i+1)*fact[i]%M;\n\n\tint n; scanf(\"%d\",&n);\n\tint a[200],zero=-1;\n\trep(i,n){ scanf(\"%d\",a+i); if(a[i]==0) zero=i; }\n\n\tll ans=solve(n,a);\n\tif(zero!=-1){\n\t\tswap(a[zero],a[n-1]);\n\t\tans=(ans-solve(n-1,a)+M)%M;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename Ostream,typename Container>\nOstream& operator<<(Ostream& os,const Container& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\ninline int ncr(int n,int r)\n{\n\tstatic int memo[201][201];\n\tif(memo[n][r]) return memo[n][r];\n\tif(r==0 || r==n) return 1;\n\treturn memo[n][r]=(ncr(n-1,r-1)+ncr(n-1,r))%MOD;\n}\ninline int npr(int n,int r)\n{\n\tstatic int memo[201][201];\n\tif(memo[n][r]) return memo[n][r];\n\tif(r==0) return 1;\n\treturn memo[n][r]=n*(ll)npr(n-1,r-1)%MOD;\n}\n\nint solve(vi as)\n{\n\tarray<int,801> tinvs={1}; // tinvs[i]=10^i mod m\n\trepi(i,1,tinvs.size()) tinvs[i]=(ll)tinvs[i-1]*10%MOD;\n\tarray<int,201> finvs={1}; // finvs[i]=i! mod m\n\trepi(i,1,finvs.size()) finvs[i]=(ll)finvs[i-1]*i%MOD;\n\t\n\tsort(all(as));\n\t\n\tint n=as.size();\n\tvi ls(n);\n\trep(i,n){\n\t\tif(as[i]==0) ls[i]=1;\n\t\tfor(int x=as[i];x;x/=10) ls[i]++;\n\t}\n\tarray<int,5> hist={0};\n\trep(i,n) hist[ls[i]]++;\n\t\n\tarray<int,5> bs,es;\n\trepi(i,1,5){\n\t\tbs[i]=lower_bound(all(ls),i)-begin(ls);\n\t\tes[i]=upper_bound(all(ls),i)-begin(ls);\n\t}\n\t\n\tint res=0;\n\trep(c1,hist[1]+1) rep(c2,hist[2]+1) rep(c3,hist[3]+1) rep(c4,hist[4]+1){\n\t\tarray<int,5> uses={-1,c1,c2,c3,c4};\n\t\tint locnt=c1+c2+c3+c4;\n\t\tint lolen=c1+2*c2+3*c3+4*c4;\n\t\trepi(len,1,5) if(uses[len]<hist[len]){\n\t\t\thist[len]--;\n\t\t\tint lopat=finvs[locnt];\n\t\t\trepi(j,1,5) lopat=(lopat*(ll)ncr(hist[j],uses[j]))%MOD;\n\t\t\thist[len]++;\n\t\t\tint hipat=0;\n\t\t\t//rep(j,n-locnt) hipat=(hipat+(ll)ncr(n-locnt-1,j)*finvs[j]%MOD)%MOD;\n\t\t\trep(j,n-locnt) if((hipat+=npr(n-locnt-1,j))>=MOD) hipat-=MOD;\n\t\t\trepi(j,bs[len],es[len]){\n\t\t\t\tint val=(ll)as[j]*tinvs[lolen]%MOD*lopat%MOD*hipat%MOD;\n\t\t\t\t//(res+=val)%=MOD;\n\t\t\t\tif((res+=val)>=MOD) res-=MOD;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvi as(n);\n\t\trep(i,n) cin>>as[i];\n\t\t\n\t\tint res=solve(as);\n\t\tif(count(all(as),0)){\n\t\t\tas.erase(find(all(as),0));\n\t\t\tres=(res-solve(as)+MOD)%MOD;\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef unsigned long long ULL;\nconst int MOD = 1000000007;\nULL dp[4][256][800]; // dp[i][j][k] = 長さi+1のカードを1枚抜いて，j枚使って長さkの列を作る場合の数\nULL factorial[201];\nULL perm[201]; // perm[i] = iP1 + iP2 + ... + iPi\n\ninline int digit_len(int n) {\n    if(0 <= n && n <= 9) return 1;\n    else if(10 <= n && n <= 99) return 2;\n    else if(100 <= n && n <= 999) return 3;\n    else if(1000 <= n && n <= 9999) return 4;\n    throw \"Invalid\";\n}\n\nvoid calc(const vector<int> &nums, int idx) {\n    for(int j = 0; j <= 200; ++j) {\n        for(int k = 0; k <= 799; ++k) {\n            dp[idx][j][k] = 0;\n        }\n    }\n    dp[idx][0][0] = 1;\n    for(int len = 1; len <= 4; ++len) {\n        for(int i = 0; i < nums[len]; ++i) {\n            for(int j = 200; j >= 1; --j) {\n                for(int k = 799; k >= len; --k) {\n                    // 長さlenのものを1枚追加すると，dp[idx][j-1][k-len]の並べ方それぞれに対して\n                    // j箇所の挿入箇所がある．\n                    // したがってdp[idx][j][k]はdp[idx][j-1][k-len]*jだけ増える．\n                    dp[idx][j][k] += dp[idx][j-1][k-len] * j;\n                    dp[idx][j][k] %= MOD;\n                    //cout << idx << ' ' << j << ' ' << k << ' ' << dp[idx][j][k] << endl;\n                }\n            }\n        }\n    }\n}\n\nULL solve(vector<int> &nums, const vector<int> &sums) {\n    int N = 0;\n    int max_len = 0;\n    for(int len = 0; len <= 4; ++len) {\n        N += nums[len];\n        max_len += nums[len]*len;\n    }\n    for(int i = 1; i <= 4; ++i) {\n        if(nums[i] > 0) {\n            nums[i]--;\n            calc(nums, i-1);\n            nums[i]++;\n        }\n    }\n    ULL ans = 0;\n    for(int uselen = 1; uselen <= 4; ++uselen) {\n        if(nums[uselen] > 0) {\n            ULL ord = 1;\n            for(int pos = 0; pos <= max_len-uselen; ++pos) {\n                for(int right_cnt = 0; right_cnt <= N-1; ++right_cnt) {\n                    ULL right = dp[uselen-1][right_cnt][pos];\n                    ans += sums[uselen]*ord % MOD * right % MOD * perm[N-right_cnt-1] % MOD;\n                    ans %= MOD;\n                    //cout << ans << endl;\n                }\n                ord *= 10;\n                ord %= MOD;\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    factorial[0] = 1;\n    for(int i = 1; i <= 200; ++i) {\n        factorial[i] = factorial[i-1] * i;\n        factorial[i] %= MOD;\n    }\n    perm[0] = 1;\n    for(int i = 1; i <= 200; ++i) {\n        ULL fact = 1;\n        perm[i] = 1; // iP0\n        for(int j = i; j >= 1; --j) {\n            fact *= j;\n            fact %= MOD;\n            perm[i] += fact;\n            perm[i] %= MOD;\n        }\n        //cout << \"perm[\" << i << \"]=\" << perm[i] << endl;\n    }\n    vector<int> nums(5, 0);\n    vector<int> sums(5, 0);\n    bool have_zero = false;\n    int N;\n    cin >> N;\n    for(int i = 0; i < N; ++i) {\n        int a;\n        cin >> a;\n        if(a == 0) have_zero = true;\n        const int len = digit_len(a);\n        nums[len]++;\n        sums[len] += a;\n    }\n    ULL ans = solve(nums, sums);\n    if(have_zero) {\n        nums[1]--;\n        ULL leading_zero = solve(nums, sums);\n        ans = ans + MOD - leading_zero;\n        ans %= MOD;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint n;\nvector<ll> a,d;\nint dp[2][801][201];\nint dp2[801][201];\nll fac[202],p10[1000],fsum[202];\n\nll solve(){\n  int crt=0,nxt=1;\n  memset(dp,0,sizeof(dp));\n  dp[crt][0][0]=1;\n  n=a.size();\n  rep(i,n){\n    memset(dp[nxt],0,sizeof(dp[nxt]));\n    rep(j,801){\n      rep(k,201){\n        if(j+d[i]<=800&&k+1<=200)(dp[nxt][j+d[i]][k+1]+=dp[crt][j][k])%=mod;\n        (dp[nxt][j][k]+=dp[crt][j][k])%=mod;\n      }\n    }\n    swap(crt,nxt);\n  }\n\n  ll res=0;\n  rep(i,n){\n    memset(dp2,0,sizeof(dp2));\n    rep(j,801){\n      rep(k,201){\n        if(j-d[i]>=0&&k>=1) dp2[j][k]=(dp[crt][j][k]-dp2[j-d[i]][k-1]+mod)%mod;\n        else dp2[j][k]=dp[crt][j][k];\n        if(n-1-k>=0)(res+=((((a[i]*p10[j])%mod)*fac[k]%mod)*dp2[j][k]%mod)*fsum[n-1-k]%mod)%=mod;\n      }\n    }\n  }\n\n  return res;\n}\n\nint main(){\n  fac[0]=fac[1]=1;\n  repl(i,1,200)fac[i+1]=fac[i]*(i+1)%mod;\n  rep(i,201){\n    ll p=1;\n    rep(j,i+1){\n      (fsum[i]+=p)%=mod;\n      (p*=i-j)%=mod;\n    }\n  }\n  p10[0]=1;\n  rep(i,800)p10[i+1]=p10[i]*10%mod;\n\n  cin>>n;\n  rep(i,n){\n    ll aa;\n    cin>>aa;\n    a.push_back(aa);\n  }\n  sort(all(a)); reverse(all(a));\n  rep(i,n){\n    d.push_back(to_string(a[i]).size());\n  }\n  if(a[n-1]==0){\n    ll resa=solve();\n    a.pop_back(); d.pop_back();\n    ll resb=solve();\n    cout<<(resa-resb+mod)%mod<<endl;\n  }else{\n    cout<<solve()<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define Pr(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr1(a) cerr<<Pr(a)<<endl;\n#define pr2(a,b) cerr<<Pr(a)<<Pr(b)<<endl;\n#define pr3(a,b,c) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<endl;\n#define pr4(a,b,c,d) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<endl;\n#define pr5(a,b,c,d,e) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<endl;\n#define pr6(a,b,c,d,e,f) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<Pr(f)<<endl;\n#define int long long\n#define double long double\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\nclass Math{\npublic:\n  typedef long long ll;\n  ll mod;\n  Math(ll mod = 1e9+7):mod(mod){}\n  \n  ll mod_pow(ll a,ll x){\n    ll res=1;\n    while(x){\n      if(x%2) res=res*a%mod;\n      a=a*a%mod;\n      x/=2;\n    }\n    return res;\n  }\n\n  //逆元\n  ll inv(ll a){return mod_pow(a,mod-2);}\n\n  //階乗関数\n  ll K(int i, int n = 1e6){\n    static vector<ll> k(n);\n    if(!k[0]){k[0]=1;for(int i=1;i<(int)k.size();i++)k[i]=i*k[i-1]%mod;}\n    return k[i];\n  }\n\n\n  ll nPr(ll n, ll r){return K(n) * inv(K(r)) % mod;}\n\n  //O(log(mod))  階上テーブルを使うので、k,rが大きすぎるとダメ。\n  ll nCr(ll n,ll r){\n    ll a = inv( K(r) * K(n-r) % mod);\n    return K(n) * a % mod;\n  }\n\n  //O(r + log(mod))\n  ll nCr2(ll n,ll r){\n    ll N = 1, K = 1; \n    for(int i=0;i<r;i++) N=N*((n-i)%mod)%mod;\n    for(int i=0;i<r;i++) K=K*((r-i)%mod)%mod;\n    ll R = inv(K);\n    return N*R%mod;\n  }\n  \n  /*カーマイケル数ってなんだっけ忘れた*/\n  static ll carmichaelLambda(ll n){\n    ll res = 1;\n    if(n % 8 == 0) n/=2;\n    auto lcm = [](ll a,ll b){return (a/__gcd(a,b)) * b;};\n    \n    auto compute = [&](ll i){\n      ll sub = i - 1;\n      n/=i;\n      while(n%i == 0) n/=i, sub *=i;\n      res = lcm(res,sub);\n    };\n    \n    for(int i=2;i*i<=n;i++) if( n % i == 0) compute(i);\n    if(n != 1) compute(n);\n    return res;\n  }\n\n  //n以下の素数を返す。  \n  static vector<int> getPrime(int n){\n    vector<bool>used(n+1,0);\n    \n    for(ll i=2;i*i<=n;i++)\n      if(!used[i]) for(int j=2;j<=n/i;j++) used[i*j]=1;\n    \n    vector<int> res;\n    for(int i=2;i<=n;i++)if(!used[i]) res.push_back(i);\n\n    return res;\n  }\n  \n  //素数判定\n  static bool isPrime(ll n){\n    if(n < 2) return 0;\n    for(ll i=2;i*i<=n;i++) if(n%i==0) return 0;\n    return 1;\n  }\n\n  //素因数分解 x == 0 || x == 1のときはその値自身を返す。\n  static vector<ll> primeFactor(ll x){\n    //if(x < 2) return {x}; /*!!!!!!!!!!!!!!!!!!!*/\n    assert(x > 1);/*!!!!!!!!!!!!!!!!!!!*/\n\n    vector<ll> res;\n    for(ll i=2;i*i <= x;i++)\n      while(x%i == 0){\n        x/=i;\n        res.push_back(i);\n      }\n    if(x != 1) res.push_back(x);\n    return res;\n  }\n\n  static map<ll,ll> primeFactorMap(ll x){\n\n    map<ll,ll> res;\n    //if(x < 2) {\n    //res[x]++;\n    //  return res; /*!!!!!!!!!!!!!!!!!!!*/\n    //}\n    \n    assert(x > 1); /*!!!!!!!!!!!!!!!!!!!*/\n    \n    for(ll i=2;i*i <= x;i++)\n      while(x%i == 0) x/=i, res[i]++;\n    \n    if(x != 1) res[x]++;\n    return res;\n  }\n  \n  static ll divisor_Sum(map<ll,ll> prime){ // first : prime  second : cnt\n    ll res = 1;\n    for(P p : prime){\n      ll sum = 1, mul = p.first;\n      for(ll i=0;i<p.second;i++) sum += mul, mul *= p.first;\n      res *= sum;\n    }\n    return res;\n  }\n  \n  static ll divisor_Sum(ll num){\n    return divisor_Sum(primeFactorMap(num));\n  }\n  \n  //約数列挙\n  static vector<ll> divisor(ll x){\n    vector<ll> res;\n    for(ll i=1; i*i<=x ;i++)\n      if(x%i==0){\n        res.push_back(i);\n        if(i*i!=x) res.push_back(x/i);\n      }\n    sort(res.begin(), res.end());\n    return res;\n  }\n\n  //a * bがオーバフローするか判定\n  static bool overflow(ll a,ll b){return a > LONG_MAX/b;}\n\n};\n\nconst int N = 201;\nconst int L = 4 * N;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\nVV DP(V A){\n  Math math;\n  VVV dp(5,VV(N,V(L,0))); \n  dp[0][0][0] = 1;\n  for(int i=0;i<4;i++){ // 1, 2, 3, 4\n    int a = A[i];\n    for(int j=0;j<N;j++) // 使った回数\n      for(int k=0;k<L;k++){ // 長さ\n        if(dp[i][j][k] == 0) continue;\n        for(int l=0;l<=a;l++){ //次に使う個数\n          if(j + l >= N || k + (i+1) * l >= L) continue;\n          int &ndp = dp[i+1][j + l][k + (i+1) * l];\n          ndp += dp[i][j][k] * math.nCr(a,l) % mod;\n          ndp %= mod;\n        }\n      }\n  }\n  return dp[4];\n}\n\nint calc1(int n){\n  static Math math;\n  static vector<int> used(N),mem(N);\n  if(used[n]++) return mem[n];\n  return mem[n] = math.K(n);\n}\n\nint calc2(int n){\n  static Math math;\n  static vector<int> used(N),mem(N);\n  if(n == 0) return 1;\n  if(n <= 0) return 0;\n  if(used[n]++) return mem[n];\n  int res = 0;\n  for(int i=0;i<=n;i++){\n    res += math.nPr(n,i);\n    res %= mod;\n  }\n  return mem[n] = res;\n}\n\nint solve(vector<int> A){\n  int n = A.size();\n  int res = 0;\n  Math math;\n  vector<int> X(4,0);\n  int sum[4] = {};\n  for(int i=0;i<n;i++) {\n    int len = to_string(A[i]).size();\n    X[len-1]++;\n    sum[len-1] = (sum[len-1] + A[i]) % mod;\n  }\n  \n  for(int k=0;k<4;k++){\n    if(X[k] == 0) continue;\n    X[k]--;\n    VV dp = DP(X);\n\n    for(int i=0;i<N;i++)\n      for(int j=0;j<L;j++){\n        int a = dp[i][j] * calc1(i) % mod; //通り数\n        a = a * calc2(n-i - 1) % mod;\n        int b = sum[k] * math.mod_pow(10,j) % mod;//数\n        res = (res + a * b) % mod;\n      }\n    X[k]++;\n  }\n  return res;\n}\n  \nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n;\n  cin>>n;\n  vector<int> A(n);\n  cin>>A;\n  sort(A.begin(),A.end());\n\n  int ans = solve(A);\n  if(A[0] == 0) {\n    A.erase(A.begin());\n    ans = ans + mod - solve(A);\n    ans %= mod;\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VEC;\ntypedef vector<VEC> MAT;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define EPS 1e-8\n#define MOD 1000000007\n\nint a[222];\nLL s[4];\nLL cnt[4];\nLL fact[222];\nLL invfact[222];\nLL powten[1000];\nLL f[222];\n\nLL extgcd(LL a, LL b, LL &x, LL &y){\n\tLL d = a;\n\tif(b){\n\t\td = extgcd(b, a % b, y, x);\n\t\ty -= a/b * x;\n\t}\n\telse x = 1, y = 0;\n\treturn d;\n}\n\nLL mod_inverse(LL a, LL m){\n\tLL x, y;\n\textgcd(a, m, x, y);\n\treturn (m + x%m) % m;\n}\n\ninline LL P(int n, int r){\n\tif(n<0)return 0LL;\n\treturn (fact[n]*invfact[n-r])%MOD;\n}\n\ninline LL C(int n, int r){\n\tif(n<r)return 0LL;\n\treturn (P(n,r)*invfact[r])%MOD;\n}\nLL solve(int n){\n\tLL ret=0;\n\tint loop[4];\n\tfor(loop[0]=0; loop[0]<=cnt[0]; loop[0]++){\n\t\tfor(loop[1]=0; loop[1]<=cnt[1]; loop[1]++){\n\t\t\tfor(loop[2]=0; loop[2]<=cnt[2]; loop[2]++){\n\t\t\t\tfor(loop[3]=0; loop[3]<=cnt[3]; loop[3]++){\n\t\t\t\t\tint sum1 = loop[0]+loop[1]+loop[2]+loop[3];\n\t\t\t\t\tint sum2 = loop[0]+2*loop[1]+3*loop[2]+4*loop[3];\n\t\t\t\t\tLL tmp = 0;\n\t\t\t\t\tREP(i,4){\n\t\t\t\t\t\tLL tmp2 = 1LL;\n\t\t\t\t\t\tREP(j,4){\n\t\t\t\t\t\t\ttmp2 *= C(cnt[j]-(i==j), loop[j]);\n\t\t\t\t\t\t\ttmp2 %= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp2 *= s[i];\n\t\t\t\t\t\ttmp2 %= MOD;\n\t\t\t\t\t\ttmp += tmp2;\n\t\t\t\t\t\ttmp %= MOD;\n\t\t\t\t\t}\n\t\t\t\t\tif(n-sum1-1<0)tmp=0;\n\t\t\t\t\telse tmp *= f[n-sum1-1];\n\t\t\t\t\ttmp %= MOD;\n\t\t\t\t\ttmp *= fact[sum1];\n\t\t\t\t\ttmp %= MOD;\n\t\t\t\t\ttmp *= powten[sum2];\n\t\t\t\t\ttmp %= MOD;\n\t\t\t\t\tret = (ret+tmp)%MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tfact[0]=fact[1]=invfact[0]=invfact[1]=1;\n\tFOR(i,2,222)fact[i]=(fact[i-1]*i)%MOD;\n\tFOR(i,2,222)invfact[i]=mod_inverse(fact[i], MOD);\n\tpowten[0]=1;\n\tFOR(i,1,1000)powten[i] = (powten[i-1]*10)%MOD;\n\tf[0]=1;\n\tFOR(i,1,222){\n\t\tf[i]=1;\n\t\tFOR(j,1,i+1)f[i]=(f[i]+P(i,j))%MOD;\n\t}\n\tint n;\n\tcin>>n;\n\tREP(i,n)scanf(\"%d\", a+i);\n\tif(n==1){\n\t\tcout << a[0] << endl;\n\t\treturn 0;\n\t}\n\tsort(a,a+n);\n\tint c=10, k=0;\n\tREP(i,n){\n\t\tif(a[i] >= c){\n\t\t\tk++;\n\t\t\tc*=10;\n\t\t}\n\t\tcnt[k]++;\n\t\ts[k]+=a[i];\n\t}\n\tLL ret = solve(n);\n\tif(a[0]==0){\n\t\tcnt[0]--;\n\t\tret -= solve(n-1);\n\t}\n\twhile(ret<0)ret+=MOD;\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntemplate<int M>\nclass Cyclic {\n\tusing ll = long long;\n\tint n;\n\tstatic ll inv(ll a, ll p) { return (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p); }\npublic:\n\tCyclic() : n(0) { ; }\n\tCyclic(int m) : n(m) {\n\t\tif (n >= M) n %= M;\n\t\telse if (n < 0) n = (n % M + M) % M;\n\t}\n\toperator int() const { return n; }\n\tbool operator==(const Cyclic &a) const { return n == a.n; }\n\tCyclic operator+=(const Cyclic &a) { n += a.n; if (n >= M) n -= M; return *this; }\n\tCyclic operator-=(const Cyclic &a) { n -= a.n; if (n < 0) n += M; return *this; }\n\tCyclic operator*=(const Cyclic &a) { n = (ll(n) * a.n) % M; return *this; }\n\tCyclic operator+(const Cyclic &a) const { Cyclic res = *this; return res += a; }\n\tCyclic operator-(const Cyclic &a) const { Cyclic res = *this; return res -= a; }\n\tCyclic operator*(const Cyclic &a) const { Cyclic res = *this; return res *= a; }\n\tCyclic operator/(const Cyclic &a) const { return *this * Cyclic<M>(inv(a, M)); }\n\tCyclic operator^(int n) const {\n\t\tif (n == 0) return Cyclic(1);\n\t\tconst Cyclic a = *this;\n\t\tCyclic res = (a * a) ^ (n / 2);\n\t\treturn n % 2 ? res * a : res;\n\t}\n};\n\ntemplate<int M> Cyclic<M> fact(int n, bool sw = true) {\n\tstatic vector<Cyclic<M>> v1 = { 1 }, v2 = { 1 };\n\tif (n >= (int)v1.size()) {\n\t\tconst int from = v1.size(), to = n + 1024;\n\t\tv1.reserve(to);\n\t\tv2.reserve(to);\n\t\tfor (int i = from; i < to; ++i) {\n\t\t\tv1.push_back(v1.back() * Cyclic<M>(i));\n\t\t\tv2.push_back(v2.back() / Cyclic<M>(i));\n\t\t}\n\t}\n\treturn sw ? v1[n] : v2[n];\n}\n\ntemplate<int M> Cyclic<M> comb(int a, int b) {\n\treturn fact<M>(a, true) * fact<M>(b, false) * fact<M>(a - b, false);\n}\n\ntemplate<int M> Cyclic<M> perm(int a, int b) {\n\treturn fact<M>(a, true) * fact<M>(a - b, false);\n}\n\nconst int mod = 1000000007;\nusing Mod = Cyclic<mod>;\n\nMod pow(Mod x, int n)\n{\n\tMod res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1) res = res * x;\n\t\tx = x*x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nint n;\nvi a, len(6);\nMod dp[11][11][888][222];\n\nMod rec(int sz, int i, int keta, int used, const vi& v)\n{\n\tif (dp[sz][i][keta][used] >= 0) return dp[sz][i][keta][used];\n\tMod res = 0;\n\tif (i == 5)\n\t{\n\t\tif (keta == 0)\n\t\t{\n\t\t\tMod tmp = fact<mod>(used);\n\t\t\tint rem = n - 1 - used;\n\t\t\tREP(j, rem + 1)\n\t\t\t{\n\t\t\t\tres += tmp * perm<mod>(rem, j);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tREP(j, v[i] + 1)\n\t\t{\n\t\t\tif (keta < i * j) break;\n\t\t\tres += rec(sz, i + 1, keta - i*j, used + j, v) * comb<mod>(v[i], j);\n\t\t}\n\t}\n\treturn dp[sz][i][keta][used] = res;\n}\n\nMod calc(int sz, int right)\n{\n\tvi v = len;\n\tif (v[sz] == 0) return 0;\n\tv[sz]--;\n\tMod res = rec(sz, 1, right, 0, v);\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tMS(dp, -1);\n\tcin >> n;\n\ta.resize(n);\n\tREP(i, n)\n\t{\n\t\tcin >> a[i];\n\t\tif (a[i] == 0) len[0]++;\n\t\tlen[to_string(a[i]).size()]++;\n\t}\n\tMod ans = 0;\n\tREP(i, n)\n\t{\n\t\tstring s = to_string(a[i]);\n\t\tREP(j, 801)\n\t\t{\n\t\t\tMod cal = calc(s.size(), j);\n\t\t\tREP(k, s.size())\n\t\t\t{\n\t\t\t\tans += Mod(s[k] - '0') * pow(Mod(10), j + s.size() - k - 1) * cal;\n\t\t\t}\n\t\t}\n\t}\n\n\tMod zero = 0;\n\tMS(dp, -1);\n\tn--;\n\tlen[1]--;\n\tREP(i, n + 1)\n\t{\n\t\tstring s = to_string(a[i]);\n\t\tREP(j, 801)\n\t\t{\n\t\t\tMod cal = calc(s.size(), j);\n\t\t\tREP(k, s.size())\n\t\t\t{\n\t\t\t\tzero += Mod(s[k] - '0') * pow(Mod(10), j + s.size() - k - 1) * cal;\n\t\t\t}\n\t\t}\n\t}\n\tzero *= len[0];\n\tcout << ans - zero << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!===============================================================!//\n//!   88888888b            dP       .88888.   a88888b. 888888ba   !//\n//!   88                   88      d8'   '88 d8'   '88 88    '8b  !//\n//!  a88aaaa    dP.  .dP d8888P    88        88        88     88  !//\n//!   88         '8bd8'    88      88   YP88 88        88     88  !//\n//!   88         .d88b.    88      Y8.   .88 Y8.   .88 88    .8P  !//\n//!   88888888P dP'  'dP   dP       '88888'   Y88888P' 8888888P   !//\n//!===============================================================!//\ntemplate <typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto p = extgcd(b, a % b);\n    return {p.second, p.first - p.second * (a / b)};\n}\ntemplate <typename T>\nconstexpr T inverse(const T a, const T mod) { return (mod + extgcd((mod + a % mod) % mod, mod).first % mod) % mod; }\n//!========================================================!//\n//!  8888ba.88ba                 dP    dP            dP    !//\n//!  88  '8b  '8b                88    88            88    !//\n//!  88   88   88 .d8888b. .d888b88    88 88d888b. d8888P  !//\n//!  88   88   88 88'  '88 88'  '88    88 88'  '88   88    !//\n//!  88   88   88 88.  .88 88.  .88    88 88    88   88    !//\n//!  dP   dP   dP '88888P' '88888P8    dP dP    dP   dP    !//\n//!========================================================!//\ntemplate <uint mod>\nclass ModInt\n{\nprivate:\n    uint v;\n    static uint norm(const uint& x) { return x < mod ? x : x - mod; }\n    static ModInt make(const uint& x)\n    {\n        ModInt m;\n        return m.v = x, m;\n    }\n    static ModInt power(ModInt x, ll n)\n    {\n        ModInt ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static ModInt inv(const ModInt& x) { return ModInt{inverse((ll)x.v, (ll)mod)}; }\n\npublic:\n    ModInt() : v{0} {}\n    ModInt(const ll val) : v{norm(uint(val % (ll)mod + (ll)mod))} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    ModInt<mod>& operator=(const ModInt<mod>& n) { return v = n(), (*this); }\n    ModInt<mod>& operator=(const ll val) { return v = norm(uint(val % (ll)mod + (ll)mod)), (*this); }\n    ModInt<mod> operator+() const { return *this; }\n    ModInt<mod> operator-() const { return make(norm(mod - v)); }\n    ModInt<mod> operator+(const ModInt<mod>& val) const { return make(norm(v + val())); }\n    ModInt<mod> operator-(const ModInt<mod>& val) const { return make(norm(v + mod - val())); }\n    ModInt<mod> operator*(const ModInt<mod>& val) const { return make((uint)((ll)v * val() % (ll)mod)); }\n    ModInt<mod> operator/(const ModInt<mod>& val) const { return *this * inv(val()); }\n    ModInt<mod>& operator+=(const ModInt<mod>& val) { return *this = *this + val; }\n    ModInt<mod>& operator-=(const ModInt<mod>& val) { return *this = *this - val; }\n    ModInt<mod>& operator*=(const ModInt<mod>& val) { return *this = *this * val; }\n    ModInt<mod>& operator/=(const ModInt<mod>& val) { return *this = *this / val; }\n    ModInt<mod> operator+(const ll val) const { return ModInt{v + val}; }\n    ModInt<mod> operator-(const ll val) const { return ModInt{v - val}; }\n    ModInt<mod> operator*(const ll val) const { return ModInt{(ll)v * (val % mod)}; }\n    ModInt<mod> operator/(const ll val) const { return ModInt{(ll)v * inv(val)}; }\n    template <typename I>\n    ModInt<mod> operator^(const I n) const { return power(v, n); }\n    ModInt<mod>& operator+=(const ll val) { return *this = *this + val; }\n    ModInt<mod>& operator-=(const ll val) { return *this = *this - val; }\n    ModInt<mod>& operator*=(const ll val) { return *this = *this * val; }\n    ModInt<mod>& operator/=(const ll val) { return *this = *this / val; }\n    template <typename I>\n    ModInt<mod>& operator^=(const I n) { return (*this) = ((*this) ^ n); }\n    bool operator==(const ModInt<mod>& val) const { return v == val.v; }\n    bool operator!=(const ModInt<mod>& val) const { return not(*this == val); }\n    bool operator==(const ll val) const { return v == norm(uint((ll)mod + val % (ll)mod)); }\n    bool operator!=(const ll val) const { return not(*this == val); }\n    uint operator()() const { return v; }\n};\ntemplate <uint mod>\ninline ModInt<mod> operator+(const ll val, const ModInt<mod>& n) { return n + val; }\ntemplate <uint mod>\ninline ModInt<mod> operator-(const ll val, const ModInt<mod>& n) { return ModInt<mod>{val - (ll)n()}; }\ntemplate <uint mod>\ninline ModInt<mod> operator*(const ll val, const ModInt<mod>& n) { return n * val; }\ntemplate <uint mod>\ninline ModInt<mod> operator/(const ll val, const ModInt<mod>& n) { return ModInt<mod>(val) / n; }\ntemplate <uint mod>\ninline bool operator==(const ll val, const ModInt<mod>& n) { return n == val; }\ntemplate <uint mod>\ninline bool operator!=(const ll val, const ModInt<mod>& n) { return not(val == n); }\ntemplate <uint mod>\ninline std::istream& operator>>(std::istream& is, ModInt<mod>& n)\n{\n    uint v;\n    return is >> v, n = v, is;\n}\ntemplate <uint mod>\nstd::ostream& operator<<(std::ostream& os, const ModInt<mod>& n) { return (os << n()); }\n//!============================================================================!//\n//!  8888ba.88ba                 dP     a88888b.                     dP        !//\n//!  88  '8b  '8b                88    d8'   '88                     88        !//\n//!  88   88   88 .d8888b. .d888b88    88        .d8888b. 88d8b.d8b. 88d888b.  !//\n//!  88   88   88 88'  '88 88'  '88    88        88'  '88 88''88''88 88'  '88  !//\n//!  88   88   88 88.  .88 88.  .88    Y8.   .88 88.  .88 88  88  88 88.  .88  !//\n//!  dP   dP   dP '88888P' '88888P8     Y88888P' '88888P' dP  dP  dP 88Y8888'  !//\n//!============================================================================!//\ntemplate <uint mod>\nclass ModComb\n{\npublic:\n    ModComb(const std::size_t N) : f(N + 1, ModInt<mod>(1)), in(N + 1, ModInt<mod>(1)), invf(N + 1, ModInt<mod>(1))\n    {\n        for (uint i = 2; i <= N; i++) { f[i] = f[i - 1] * i, in[i] = (mod - (mod / i)) * in[mod % i], invf[i] = invf[i - 1] * in[i]; }\n    }\n    ModInt<mod> fact(const std::size_t N) const { return f[N]; }\n    ModInt<mod> inv(const std::size_t N) const { return in[N]; }\n    ModInt<mod> invFact(const std::size_t N) const { return invf[N]; }\n    ModInt<mod> perm(const std::size_t N, const std::size_t K) const { return N > f.size() or K > N ? ModInt<mod>(0) : f[N] * invf[N - K]; }\n    ModInt<mod> comb(const std::size_t N, const std::size_t K) const { return N > f.size() or K > N ? ModInt<mod>(0) : f[N] * invf[K] * invf[N - K]; }\n\nprivate:\n    std::vector<ModInt<mod>> f, in, invf;\n};\n//!=====================================!//\n//!  8888ba.88ba           oo           !//\n//!  88  '8b  '8b                       !//\n//!  88   88   88 .d8888b. dP 88d888b.  !//\n//!  88   88   88 88'  '88 88 88'  '88  !//\n//!  88   88   88 88.  .88 88 88    88  !//\n//!  dP   dP   dP '88888P8 dP dP    dP  !//\n//!=====================================!//\nint main()\n{\n    using mint = ModInt<MOD>;\n    const int N = read<int>();\n    ModComb<MOD> comb(2 * N);\n    std::vector<mint> P(N, 0);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j <= i; j++) { P[i] += comb.perm(i, j); }\n    }\n    auto A = readVec<int>(N);\n    int z = 0;\n    for (const int a : A) {\n        if (a == 0) { z++; }\n    }\n    std::sort(A.begin(), A.end(), std::greater<int>{});\n    auto solve = [&]() -> mint {\n        const int N = A.size();\n        std::vector<int> B(N, 10);\n        for (int i = 0; i < N; i++) {\n            for (; B[i] <= A[i]; B[i] *= 10) {}\n        }\n        std::vector<mint> dp(N + 1, 0);\n        dp[0] = 1;\n        for (int j = 0; j < N; j++) {\n            for (int k = N - 1; k >= 0; k--) { dp[k + 1] += dp[k] * B[j]; }\n        }\n        mint ans = 0;\n        for (int i = 0; i < N; i++) {\n            const mint b = B[i];\n            auto tmp = dp;\n            for (int k = 0; k < N; k++) { ans += tmp[k] * P[N - k - 1] * comb.fact(k) * A[i], tmp[k + 1] -= tmp[k] * b; }\n        }\n        return ans;\n    };\n    mint ans = solve();\n    if (z > 0) { A.pop_back(), ans -= solve() * z; }\n    std::cout << ans << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nlong long n, a[209], sz[209], ret, mod = 1000000007;\nlong long dp[209][209][209], power[5] = { 1,10,100,1000,10000 };\n\nlong long solve(vector<long long>E, long long num, bool iszero) {\n\tfor (int i = 0; i <= E.size(); i++) { for (int j = 0; j <= E.size(); j++) { for (int k = 0; k <= E.size(); k++) dp[i][j][k] = 0; } }\n\tdp[0][0][0] = 1;\n\tfor (int k = 0; k < E.size(); k++) {\n\t\tfor (int i = 0; i <= k; i++) {\n\t\t\tfor (int j = 0; j <= k - i; j++) {\n\t\t\t\tif (dp[k][i][j] == 0) continue;\n\t\t\t\tlong long X = i + 1, Y = j + 1;\n\t\t\t\tdp[k + 1][i + 1][j] += dp[k][i][j] * X; dp[k + 1][i + 1][j] %= mod;\n\t\t\t\tdp[k + 1][i][j + 1] += dp[k][i][j] * Y*power[sz[E[k]]]; dp[k + 1][i][j + 1] %= mod;\n\t\t\t\tdp[k + 1][i][j] += dp[k][i][j]; dp[k + 1][i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tlong long Z = 0;\n\tfor (int j = 0; j <= E.size(); j++) {\n\t\tfor (int k = 0; k <= E.size(); k++) {\n\t\t\tif (j == 0 && num == 0) continue;\n\t\t\tZ += dp[E.size()][j][k]; Z %= mod;\n\t\t\tif (iszero == true) {\n\t\t\t\tZ += dp[E.size()][j][k] * j; Z %= mod;\n\t\t\t\tZ += dp[E.size()][j][k] * (k + 1) * 10LL; Z %= mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn Z;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) { cin >> a[i]; sz[i] = to_string(a[i]).size(); }\n\tfor (int i = 1; i <= n; i++) {\n\t\tvector<long long>X; bool OK = false;\n\t\tfor (int j = 1; j <= n; j++) { if (i != j) { if (a[j] != 0)X.push_back(j); else OK = true; } }\n\t\tlong long G = solve(X, a[i], OK);\n\t\tret += a[i] * G; ret %= mod;\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename Ostream,typename Container>\nOstream& operator<<(Ostream& os,const Container& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nll solve_naive(vi as)\n{\n\tint n=as.size();\n\tll sum=0,zero=0;\n\trepi(i,1,1<<n){\n\t\tvi is;\n\t\trep(j,n) if(i>>j&1) is.push_back(j);\n\t\tdo{\n\t\t\tstring s;\n\t\t\tfor(int i:is) s+=to_string(as[i]);\n\t\t\tll x=0;\n\t\t\tfor(char c:s) (x=x*10+c-'0')%=MOD;\n\t\t\t(sum+=x)%=MOD;\n\t\t\tif(s[0]=='0') (zero+=x)%=MOD;\n\t\t}while(next_permutation(all(is)));\n\t}\n\tdump(mp(sum,zero));\n\treturn (sum-zero+MOD)%MOD;\n}\n\nint ncr(int n,int r)\n{\n\tstatic int memo[300][300];\n\tif(memo[n][r]) return memo[n][r];\n\tif(r==0 || r==n) return 1;\n\treturn memo[n][r]=(ncr(n-1,r-1)+ncr(n-1,r))%MOD;\n}\n\nint solve(vi as)\n{\n\tvi tinvs(1000,1); // tinvs[i]=10^i mod m\n\trepi(i,1,tinvs.size()) tinvs[i]=(ll)tinvs[i-1]*10%MOD;\n\tvi finvs(200,1); // finvs[i]=i! mod m\n\trepi(i,1,finvs.size()) finvs[i]=(ll)finvs[i-1]*i%MOD;\n\t\n\tint n=as.size();\n\tvi ls(n);\n\trep(i,n){\n\t\tif(as[i]==0) ls[i]=1;\n\t\tfor(int x=as[i];x;x/=10) ls[i]++;\n\t}\n\t\n\tll res=0;\n\trep(i,n){\n\t\tvvl dp(n+1,vl(4*n+1)); // dp[下の桁に使った個数][下の桁の長さ]=下の桁に置く整数の選び方\n\t\tdp[0][0]=1;\n\t\trep(j,n) if(j!=i){\n\t\t\tvvl dp2=dp;\n\t\t\trep(lo,dp.size()) rep(len,dp[lo].size()) if(dp[lo][len])\n\t\t\t\t(dp[lo+1][len+ls[j]]+=dp2[lo][len])%=MOD;\n\t\t}\n\t\t\n\t\tll tmp=0;\n\t\trep(lo,dp.size()) rep(len,dp[lo].size()) if(dp[lo][len]){\n\t\t\trep(hi,n-lo){\n\t\t\t\tll val=(ll)as[i]*tinvs[lo]%MOD*dp[lo][len]%MOD;\n\t\t\t\tll locnt=finvs[lo];\n\t\t\t\tll hicnt=(ll)ncr(n-1-lo,hi)*finvs[hi]%MOD;\n\t\t\t\t(tmp+=val*locnt%MOD*hicnt%MOD)%=MOD;\n\t\t\t}\n\t\t}\n\t\t(res+=tmp)%=MOD;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvi as(n);\n\t\trep(i,n) cin>>as[i];\n\t\t\n\t\tint res=solve(as);\n\t\tif(count(all(as),0)){\n\t\t\tas.erase(find(all(as),0));\n\t\t\tres=(res-solve(as)+MOD)%MOD;\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <numeric>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< (int)(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define iter(c) __typeof((c).begin())\n#define pb(e) push_back(e)\n#define foreach(c, i) for(iter(c) i = (c).begin(); i != c.end(); ++i)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst ll mod  = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nconst int maxn = 210;\nconst int sz = 1000;\nll p10[sz];\nll comb[maxn][maxn];\nll perm[maxn];\nll pattern[maxn];\nvector<ll> card_size;\nll memo[maxn * maxn * maxn];\n\nint digits(int n){\n  int res = 0;\n  do{ \n    res++;\n    n /= 10;\n  }while(n > 0);\n  return res;\n}\n\nll recur(vector<ll> num){\n  \n  \n  if(*max_element(num.begin(), num.end()) == 0) return 1;\n  \n  ll h = 0;\n  rep(i, num.size())   h = h * card_size[i] + num[i];\n  \n  if(memo[h] != -1) return memo[h];\n  \n  ll &res = memo[h] = 0;\n  rep(i, num.size()){\n    if(num[i] > 0){\n      num[i]--;\n      res = (res + recur(num) * (num[i] + 1)) % mod;\n      num[i]++;\n    }\n  }\n  return res;\n} \n\nll pattern_num(const vector<ll> &rest){\n  int n = accumulate(rest.begin(), rest.end(), 0);\n  return pattern[n];\n}\n\nll dfs(vector<ll> cnt, const vector<ll> &num, ll sum, int c){\n  ll res = 0;\n  if(c == (int)num.size()){\n    int len = 0;\n    vector<ll> rest(cnt.size(), 0);\n    rep(i, cnt.size()){\n      rest[i] = num[i] - cnt[i];\n      len += cnt[i] * (i + 1);\n    }\n    \n    ll p = recur(cnt) * pattern_num(rest) % mod;\n    rep(i, cnt.size()) p = (p * comb[num[i]][cnt[i]]) % mod;\n    p = (p * p10[len]) % mod;\n    return sum * p % mod;\n  }\n  \n  rep(i, num[c] + 1){\n    cnt[c] = i;\n    res = (res + dfs(cnt, num, sum, c + 1)) % mod;\n  }\n  return res;\n}\n\nll calc(vector<int> v){\n  vector<ll> sum(4, 0), cnt(4, 0), num(4, 0);\n  \n  rep(i, v.size()){\n    sum[digits(v[i])-1] += v[i];\n    num[digits(v[i])-1]++;\n  }\n  \n  memset(memo, -1, sizeof(memo));\n  \n  ll res = 0;\n  card_size = num;\n  rep(i, card_size.size()) card_size[i]++;\n  rep(i, num.size()){\n    num[i]--;\n    res = (res + dfs(cnt, num, sum[i], 0)) % mod;\n    num[i]++;\n  }\n  return res;\n}\n\nvoid init(){\n  p10[0] = 1;\n  rep(i, sz - 1) p10[i+1] = p10[i] * 10 % mod;\n  rep(n, maxn)rep(r, maxn){\n    if(n < r) comb[n][r] = 0;\n    else if(r == 0) comb[n][r] = 1;\n    else comb[n][r] = (comb[n-1][r] + comb[n-1][r-1]) % mod;\n  }\n  \n  perm[0] = 1;\n  rep(i, maxn - 1) perm[i+1] = perm[i] * (i + 1) % mod;\n  rep(i, maxn){\n    rep(j, i + 1){\n      pattern[i] = (pattern[i] + comb[i][j] * perm[j]) % mod;\n    }\n  }\n}\n\nint main(){\n  int n, a;\n  ll res = 0;\n  vector<int> v;\n  init();\n  cin >> n;\n  rep(i, n){\n    cin >> a;\n    v.push_back(a);\n  }\n  sort(v.begin(), v.end());\n  res = calc(v);\n  if(v[0] == 0) res = (res + mod - calc(vector<int>(v.begin() + 1, v.end()))) % mod;\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nlong long n, a[209], sz[209], ret, mod = 1000000007;\nlong long dp[209][209][209], power[5] = { 1,10,100,1000,10000 };\n\nlong long solve(vector<long long>E, long long num, bool iszero) {\n\tfor (int i = 0; i <= E.size(); i++) { for (int j = 0; j <= E.size(); j++) { for (int k = 0; k <= E.size(); k++) dp[i][j][k] = 0; } }\n\tdp[0][0][0] = 1;\n\tfor (int k = 0; k < E.size(); k++) {\n\t\tfor (int i = 0; i <= E.size(); i++) {\n\t\t\tfor (int j = 0; j <= E.size(); j++) {\n\t\t\t\tif (dp[k][i][j] == 0) continue;\n\t\t\t\tlong long X = i + 1, Y = j + 1;\n\t\t\t\tdp[k + 1][i + 1][j] += dp[k][i][j] * X; dp[k + 1][i + 1][j] %= mod;\n\t\t\t\tdp[k + 1][i][j + 1] += dp[k][i][j] * Y*power[sz[E[k]]]; dp[k + 1][i][j + 1] %= mod;\n\t\t\t\tdp[k + 1][i][j] += dp[k][i][j]; dp[k + 1][i][j] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tlong long Z = 0;\n\tfor (int j = 0; j <= E.size(); j++) {\n\t\tfor (int k = 0; k <= E.size(); k++) {\n\t\t\tif (j == 0 && num == 0) continue;\n\t\t\tZ += dp[E.size()][j][k]; Z %= mod;\n\t\t\tif (iszero == true) {\n\t\t\t\tZ += dp[E.size()][j][k] * j; Z %= mod;\n\t\t\t\tZ += dp[E.size()][j][k] * (k + 1) * 10LL; Z %= mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn Z;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) { cin >> a[i]; sz[i] = to_string(a[i]).size(); }\n\tfor (int i = 1; i <= n; i++) {\n\t\tvector<long long>X; bool OK = false;\n\t\tfor (int j = 1; j <= n; j++) { if (i != j) { if (a[j] != 0)X.push_back(j); else OK = true; } }\n\t\tlong long G = solve(X, a[i], OK);\n\t\tret += a[i] * G; ret %= mod;\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\nconst double EPS = 1e-9;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n\nint n;\nll L;\nll a[200];\nll l[200];\nll S[201];\nll A[5];\nll kai[201], p10[801];\nll conb[201][201];\nll dp[5][201][801];\n\nvoid init() {\n    kai[0] = 1;\n    for (ll i = 1; i <= 200; i++) kai[i] = kai[i-1]*i%mod;\n    p10[0] = 1;\n    for (ll i = 1; i <= 800; i++) p10[i] = p10[i-1]*10%mod;\n    conb[0][0] = 1;\n    for (int i = 1; i <= 200; i++) {\n        for (int j = 0; j <= i; j++) {\n            conb[i][j] = conb[i-1][j];\n            if (j > 0) conb[i][j] = (conb[i][j]+conb[i-1][j-1])%mod;\n        }\n    }\n    rep(i,201) {\n        S[i] = 0;\n        rep(j,i+1) {\n            S[i] = (S[i] + conb[i][j]*kai[j])%mod;\n        }\n    }\n}\n\nll solve1() {\n    rep(i,n) l[i] = to_string(a[i]).size();\n    L = 0;\n    rep(i,n) L += l[i];\n    memset(A, 0, sizeof(A));\n    rep(i,n) A[l[i]] += a[i];\n\n    memset(dp, 0, sizeof(dp));\n    for (int i = 1; i <= 4; i++) {\n        //if (A[i] == 0) continue;\n        dp[i][0][0] = 1;\n        bool skip = false;\n        rep(j,n) {\n            if (l[j] == i && !skip) {\n                skip = true;\n                continue;\n            }\n            for (int k = n; k >= 1; k--) {\n                for (int t = L; t >= l[j]; t--) {\n                    dp[i][k][t] = (dp[i][k][t]+dp[i][k-1][t-l[j]])%mod;\n                }\n            }\n        }\n        rep(k,n) rep(t,L) dp[i][k][t] %= mod;\n    }\n\n/*\n    rep(i,n) {\n        rep(j,L) {\n            cerr << dp[1][i][j] << \" \";\n        }\n        cerr << endl;\n    }\n*/\n\n    ll ret = 0;\n    for (int i = 1; i <= 4; i++) {\n        ll tmp = 0;\n        rep(j,n) {\n            rep(k,L) {\n                ll tmp2 = dp[i][j][k]*p10[k]%mod;\n                tmp2 = tmp2 * S[n-j-1] % mod;\n                tmp2 = tmp2 * kai[j] % mod;\n                tmp = (tmp + tmp2) % mod;\n            }\n        }\n        ret = (ret + A[i] * tmp) % mod;\n    }\n    return ret;\n}\n\nvoid solve() {\n    init();\n    cin >> n;\n    rep(i,n) cin >> a[i];\n    sort(a, a+n);\n    ll ans = solve1();\n    if (a[0] > 0) {\n        cout << ans << endl;\n        return;\n    }\n    a[0] = linf;\n    sort(a, a+n); n--;\n    ans = (ans - solve1() + mod) % mod;\n    cout << ans << endl;\n}\n\nint main() {\n#ifndef LOCAL\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n    cout.precision(20);\n    cerr << fixed;\n    cerr.precision(6);\n#ifdef LOCAL\n    //freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif  \n    solve();\n    //cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n  \nusing namespace std;\n  \n\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n  \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void unique(vector<T>& c) { c.erase(unique(c.begin(), c.end()), c.end()); }\ntemplate <class T> void sort_unique(vector<T>& c) { sort(c); unique(c); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n  \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n \nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n  \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\n\nconst int M = 210 * 5;\nll fact[210];\nll combi[210][210];\nll ten_pow[M];\n\nvoid add(ll& a, ll b)\n{\n    a += b;\n    if (a >= mod)\n        a -= mod;\n}\nvector<vector<ll> > digits_dp(const vector<int>& digits)\n{\n    int n = digits.size();\n\n    static ll dp[210][M + 30];\n    CL(dp, 0);\n    dp[0][0] = 1;\n    for (int i = 0; i < n; ++i)\n        for (int j = i; j >= 0; --j)\n            for (int k = 5 * i; k >= 0; --k)\n                add(dp[j + 1][k + digits[i]], dp[j][k]);\n\n    vector<vector<ll> > res(n + 1, vector<ll>(M));\n    for (int i = 0; i <= n; ++i)\n        for (int j = 0; j < M; ++j)\n            res[i][j] = dp[i][j];\n    return res;\n}\nll gao(const vector<int>& a, const vector<int>& digits)\n{\n    int n = a.size();\n\n    ll pat[210] = {};\n    for (int i = 0; i <= n - 1; ++i)\n        for (int j = 0; j <= (n - 1) - i; ++j)\n            (pat[i] += (combi[(n - 1) - i][j] * fact[j] % mod) * fact[i]) %= mod;\n\n    ll res = 0;\n    for (int i = 0; i < n; ++i)\n    {\n        vector<int> d;\n        for (int j = 0; j < n; ++j)\n            if (i != j)\n                d.push_back(digits[j]);\n        vector<vector<ll> > d_pat = digits_dp(d);\n\n        for (int j = 0; j <= n - 1; ++j)\n        {\n            for (int k = 0; k <= 5 * j ; ++k)\n            {\n                ll p = pat[j] * d_pat[j][k] % mod;\n                (res += ((a[i] * ten_pow[k]) % mod) * p) %= mod;\n            }\n        }\n    }\n\n    return res;\n}\nint main()\n{\n    fact[0] = 1;\n    for (int i = 1; i < 210; ++i)\n        fact[i] = (fact[i - 1] * i) % mod;\n\n    for (int i = 0; i < 210; ++i)\n    {\n        combi[i][0] = 1;\n        for (int j = 1; j <= i; ++j)\n            combi[i][j] = (combi[i - 1][j] + combi[i - 1][j - 1]) % mod;\n    }\n\n    ten_pow[0] = 1;\n    for (int i = 1; i < M; ++i)\n        ten_pow[i] = (ten_pow[i - 1] * 10) % mod;\n\n    int n;\n    vector<int> a, d;\n    cin >> n;\n    for (int i = 0; i < n; ++i)\n    {\n        string s;\n        cin >> s;\n        d.push_back(s.size());\n        a.push_back(to_T<int>(s));\n    }\n\n    ll res = gao(a, d);\n    if (find(all(a), 0) != a.end())\n    {\n        vector<int> _a, _d;\n        for (int i = 0; i < n; ++i)\n        {\n            if (a[i] != 0)\n            {\n                _a.push_back(a[i]);\n                _d.push_back(d[i]);\n            }\n        }\n\n        ll sub = gao(_a, _d);\n        res = (res - sub + mod) % mod;\n    }\n\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntemplate<int M>\nclass Cyclic {\n\tusing ll = long long;\n\tint n;\n\tstatic ll inv(ll a, ll p) { return (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p); }\npublic:\n\tCyclic() : n(0) { ; }\n\tCyclic(int m) : n(m) {\n\t\tif (n >= M) n %= M;\n\t\telse if (n < 0) n = (n % M + M) % M;\n\t}\n\toperator int() const { return n; }\n\tbool operator==(const Cyclic &a) const { return n == a.n; }\n\tCyclic operator+=(const Cyclic &a) { n += a.n; if (n >= M) n -= M; return *this; }\n\tCyclic operator-=(const Cyclic &a) { n -= a.n; if (n < 0) n += M; return *this; }\n\tCyclic operator*=(const Cyclic &a) { n = (ll(n) * a.n) % M; return *this; }\n\tCyclic operator+(const Cyclic &a) const { Cyclic res = *this; return res += a; }\n\tCyclic operator-(const Cyclic &a) const { Cyclic res = *this; return res -= a; }\n\tCyclic operator*(const Cyclic &a) const { Cyclic res = *this; return res *= a; }\n\tCyclic operator/(const Cyclic &a) const { return *this * Cyclic<M>(inv(a, M)); }\n\tCyclic operator^(int n) const {\n\t\tif (n == 0) return Cyclic(1);\n\t\tconst Cyclic a = *this;\n\t\tCyclic res = (a * a) ^ (n / 2);\n\t\treturn n % 2 ? res * a : res;\n\t}\n};\n\ntemplate<int M> Cyclic<M> fact(int n, bool sw = true) {\n\tstatic vector<Cyclic<M>> v1 = { 1 }, v2 = { 1 };\n\tif (n >= (int)v1.size()) {\n\t\tconst int from = v1.size(), to = n + 1024;\n\t\tv1.reserve(to);\n\t\tv2.reserve(to);\n\t\tfor (int i = from; i < to; ++i) {\n\t\t\tv1.push_back(v1.back() * Cyclic<M>(i));\n\t\t\tv2.push_back(v2.back() / Cyclic<M>(i));\n\t\t}\n\t}\n\treturn sw ? v1[n] : v2[n];\n}\n\ntemplate<int M> Cyclic<M> comb(int a, int b) {\n\treturn fact<M>(a, true) * fact<M>(b, false) * fact<M>(a - b, false);\n}\n\ntemplate<int M> Cyclic<M> perm(int a, int b) {\n\treturn fact<M>(a, true) * fact<M>(a - b, false);\n}\n\nconst int mod = 1000000007;\nusing Mod = Cyclic<mod>;\n\nMod pow(Mod x, int n)\n{\n\tMod res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1) res = res * x;\n\t\tx = x*x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nint n;\nvi a, len(6);\nMod dp[11][11][888][222];\n\nMod rec(int sz, int i, int keta, int used, const vi& v)\n{\n\tif (dp[sz][i][keta][used] >= 0) return dp[sz][i][keta][used];\n\tMod res = 0;\n\tif (i == 5)\n\t{\n\t\tif (keta == 0)\n\t\t{\n\t\t\tMod tmp = fact<mod>(used);\n\t\t\tint rem = n - 1 - used;\n\t\t\tREP(j, rem + 1)\n\t\t\t{\n\t\t\t\tres += tmp * perm<mod>(rem, j);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tREP(j, v[i] + 1)\n\t\t{\n\t\t\tif (keta < i * j) break;\n\t\t\tres += rec(sz, i + 1, keta - i*j, used + j, v) * comb<mod>(v[i], j);\n\t\t}\n\t}\n\treturn dp[sz][i][keta][used] = res;\n}\n\nMod calc(int sz, int right)\n{\n\tvi v = len;\n\tif (v[sz] == 0) return 0;\n\tv[sz]--;\n\tMod res = rec(sz, 1, right, 0, v);\n\treturn res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tMS(dp, -1);\n\tcin >> n;\n\ta.resize(n);\n\tREP(i, n)\n\t{\n\t\tcin >> a[i];\n\t\tif (a[i] == 0) len[0]++;\n\t\tlen[to_string(a[i]).size()]++;\n\t}\n\tMod ans = 0;\n\tREP(i, n)\n\t{\n\t\tstring s = to_string(a[i]);\n\t\tREP(j, 801)\n\t\t{\n\t\t\tMod cal = calc(s.size(), j);\n\t\t\tMod t = 0;\n\t\t\tREP(k, s.size())\n\t\t\t{\n\t\t\t\tMod tmp = Mod(s[k] - '0') * pow(Mod(10), j + s.size() - k - 1) * cal;\n\t\t\t\tans += tmp;\n\t\t\t\tt += tmp;\n\t\t\t}\n\t\t\t//cout << j <<\" \"<< cal <<\" * \" << a[i] * pow(Mod(10), j) << \" =\" <<t<<\" \"<<ans << endl;\n\t\t}\n\t}\n\n\tMod zero = 0;\n\tMS(dp, -1);\n\tn--;\n\tlen[1]--;\n\tREP(i, n + 1)\n\t{\n\t\tstring s = to_string(a[i]);\n\t\tREP(j, 801)\n\t\t{\n\t\t\tMod cal = calc(s.size(), j);\n\t\t\tREP(k, s.size())\n\t\t\t{\n\t\t\t\tzero += (s[k] - '0') * pow(Mod(10), j + s.size() - k - 1) * cal;\n\t\t\t}\n\t\t}\n\t}\n\tzero *= len[0];\n\tcout << ans - zero << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nlong long n, a[209], sz[209], ret, mod = 1000000007;\nlong long dp[209][209][209], power[5] = { 1,10,100,1000,10000 };\n\nlong long solve(vector<long long>E, long long num, bool iszero) {\n\tfor (int i = 0; i <= E.size(); i++) { for (int j = 0; j <= i; j++) { for (int k = 0; k <= i - j; k++) dp[i][j][k] = 0; } }\n\tdp[0][0][0] = 1;\n\tfor (int k = 0; k < E.size(); k++) {\n\t\tfor (int i = 0; i <= k; i++) {\n\t\t\tfor (int j = 0; j <= k - i; j++) {\n\t\t\t\tif (dp[k][i][j] == 0) continue;\n\t\t\t\tlong long X = i + 1, Y = j + 1;\n\t\t\t\tdp[k + 1][i + 1][j] += dp[k][i][j] * X;\n\t\t\t\tdp[k + 1][i][j + 1] += dp[k][i][j] * Y*power[sz[E[k]]];\n\t\t\t\tdp[k + 1][i][j] += dp[k][i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i <= k + 1; i++) {\n\t\t\tfor (int j = 0; j <= k + 1 - i; j++) dp[k + 1][i][j] %= mod;\n\t\t}\n\t}\n\tlong long Z = 0;\n\tfor (int j = 0; j <= E.size(); j++) {\n\t\tfor (int k = 0; k <= E.size() - j; k++) {\n\t\t\tif (j == 0 && num == 0) continue;\n\t\t\tZ += dp[E.size()][j][k]; Z %= mod;\n\t\t\tif (iszero == true) {\n\t\t\t\tZ += dp[E.size()][j][k] * j; Z %= mod;\n\t\t\t\tZ += dp[E.size()][j][k] * (k + 1) * 10LL; Z %= mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn Z;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) { cin >> a[i]; sz[i] = to_string(a[i]).size(); }\n\tfor (int i = 1; i <= n; i++) {\n\t\tvector<long long>X; bool OK = false;\n\t\tfor (int j = 1; j <= n; j++) { if (i != j) { if (a[j] != 0)X.push_back(j); else OK = true; } }\n\t\tlong long G = solve(X, a[i], OK);\n\t\tret += a[i] * G; ret %= mod;\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nll dp[201][805], tmp[201][805];\nll pw[805], tab[201], tab_zero[201];\n \nsigned main() {\n    int N; cin >> N;\n    pw[0] = 1;\n    for(int i=1; i<805; i++) {\n        pw[i] = (pw[i-1] * 10) % MOD;\n    }\n\n    // tab[i] = iP0 + iP1 + ... iPi\n    for(int i=0; i<=N; i++) {\n        tab[i] = 1;\n        ll P = 1;\n        for(int k=1; k<=i; k++) {\n            (P *= i - k + 1) %= MOD;\n            (tab[i] += P) %= MOD;\n            (tab_zero[i] += P * k % MOD) %= MOD;\n        }\n    }\n\n    bool exist_zero = false;\n    vector<int> A, digits;\n    for(int i=0; i<N; i++) {\n        int val; cin >> val;\n        if(val == 0) {\n            exist_zero = true;\n            continue;\n        }\n        else A.push_back(val);\n\n        int d = 0; while(val) d++, val /= 10;\n        digits.push_back(d);\n    }\n\n    int M = A.size(), sum = 0;\n    dp[0][0] = 1;\n    for(int i=0; i<M; i++) {\n        for(int j=i; j>=0; j--) {\n            for(int k=sum; k>=0; k--) {\n                (dp[j+1][k+digits[i]] += dp[j][k] * (j + 1)) %= MOD;\n            }\n        }\n        sum += digits[i];\n    }\n\n    // i 番目を使わない場合\n    ll ans = 0;\n    for(int i=0; i<M; i++) {\n        fill(tmp[0], tmp[M+1], 0);\n        for(int j=0; j<M; j++) {\n            for(int k=0; k<=sum; k++) {\n                tmp[j][k] = dp[j][k];\n                if(j - 1 >= 0 and k - digits[i] >= 0) {\n                    (tmp[j][k] += MOD - (tmp[j-1][k - digits[i]] * j % MOD)) %= MOD;\n                }\n\n                // j 個を使って合計 k 桁 (これを i 番目の下に置くイメージ)\n                // 残っているのは M-j-1 個\n                {\n                    // 0 を使わない場合\n                    ll comb = tab[M-j-1] * tmp[j][k] % MOD;\n                    ll val = A[i] * pw[k] % MOD;\n                    ll add = val * comb % MOD;\n                    (ans += add) %= MOD;\n                }\n\n                if(exist_zero) {\n                    // 0 を使う場合 (i 番目の下に置く)\n                    {\n                        ll comb = tab[M-j-1] * tmp[j][k] % MOD * (j+1) % MOD;\n                        ll val = A[i] * pw[k + 1] % MOD;\n                        ll add = val * comb % MOD;\n                        (ans += add) %= MOD;\n                    }\n\n                    // 0 を使う場合 (i 番目の上に置く)\n                    {\n                        ll comb = tab_zero[M-j-1] * tmp[j][k] % MOD;\n                        ll val = A[i] * pw[k] % MOD;\n                        ll add = val * comb % MOD;\n                        (ans += add) %= MOD;\n                    }\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VEC;\ntypedef vector<VEC> MAT;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define EPS 1e-8\n#define MOD 1000000007\n\nint a[222];\nLL s[4];\nLL cnt[4];\nLL fact[222];\nLL invfact[222];\nLL powten[1000];\nLL f[222];\n\nLL extgcd(LL a, LL b, LL &x, LL &y){\n\tLL d = a;\n\tif(b){\n\t\td = extgcd(b, a % b, y, x);\n\t\ty -= a/b * x;\n\t}\n\telse x = 1, y = 0;\n\treturn d;\n}\n\nLL mod_inverse(LL a, LL m){\n\tLL x, y;\n\textgcd(a, m, x, y);\n\treturn (m + x%m) % m;\n}\n\ninline LL P(int n, int r){\n\tif(n<=0)return 0LL;\n\treturn (fact[n]*invfact[n-r])%MOD;\n}\n\ninline LL C(int n, int r){\n\tif(n<0)return 0LL;\n\treturn (P(n,r)*invfact[r])%MOD;\n}\nLL solve(int n){\n\tLL ret=0;\n\tint loop[4];\n\tfor(loop[0]=0; loop[0]<=cnt[0]; loop[0]++){\n\t\tfor(loop[1]=0; loop[1]<=cnt[1]; loop[1]++){\n\t\t\tfor(loop[2]=0; loop[2]<=cnt[2]; loop[2]++){\n\t\t\t\tfor(loop[3]=0; loop[3]<=cnt[3]; loop[3]++){\n\t\t\t\t\tint sum1 = loop[0]+loop[1]+loop[2]+loop[3];\n\t\t\t\t\tint sum2 = loop[0]+2*loop[1]+3*loop[2]+4*loop[3];\n\t\t\t\t\tLL tmp = 0;\n\t\t\t\t\tREP(i,4){\n\t\t\t\t\t\tLL tmp2=0;\n\t\t\t\t\t\tREP(j,4){\n\t\t\t\t\t\t\ttmp2 += C(cnt[j]-(i==j), loop[j]);\n\t\t\t\t\t\t\ttmp2 %= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp += tmp2*s[i];\n\t\t\t\t\t\ttmp %= MOD;\n\t\t\t\t\t}\n\t\t\t\t\tif(n-sum1-1<0)tmp=0;\n\t\t\t\t\telse tmp *= f[n-sum1-1];\n\t\t\t\t\ttmp %= MOD;\n\t\t\t\t\ttmp *= fact[sum1];\n\t\t\t\t\ttmp %= MOD;\n\t\t\t\t\ttmp *= powten[sum2];\n\t\t\t\t\ttmp %= MOD;\n\t\t\t\t\tret = (ret+tmp)%MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tfact[0]=fact[1]=invfact[0]=invfact[1]=1;\n\tFOR(i,2,222)fact[i]=(fact[i-1]*i)%MOD;\n\tFOR(i,2,222)invfact[i]=mod_inverse(fact[i], MOD);\n\tpowten[0]=1;\n\tFOR(i,1,1000)powten[i] = (powten[i-1]*10)%MOD;\n\tf[0]=1;\n\tFOR(i,1,222){\n\t\tf[i]=1;\n\t\tFOR(j,1,i+1)f[i]=(f[i]+P(i,j))%MOD;\n\t}\n\tint n;\n\tcin>>n;\n\tREP(i,n)scanf(\"%d\", a+i);\n\tsort(a,a+n);\n\tint c=10;\n\tREP(i,n){\n\t\tREP(j,4){\n\t\t\tif(a[i]<c){\n\t\t\t\tcnt[j]++;\n\t\t\t\ts[j]+=a[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tc*=10;\n\t\t}\n\t}\n\tLL ret = solve(n);\n\tif(a[0]==0){\n\t\tcnt[0]--;\n\t\tret -= solve(n-1);\n\t}\n\twhile(ret<0)ret+=MOD;\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n  \nusing namespace std;\n  \n\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n  \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void unique(vector<T>& c) { c.erase(unique(c.begin(), c.end()), c.end()); }\ntemplate <class T> void sort_unique(vector<T>& c) { sort(c); unique(c); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n  \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n \nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n  \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\n\nconst int M = 210 * 5;\nll fact[210];\nll combi[210][210];\nll ten_pow[M];\nvector<vector<ll> > digits_dp(const vector<int>& digits)\n{\n    int n = digits.size();\n\n    static ll dp[210][M + 30];\n    CL(dp, 0);\n    dp[0][0] = 1;\n    for (int i = 0; i < n; ++i)\n        for (int j = i; j >= 0; --j)\n            for (int k = M - 1; k >= 0; --k)\n                (dp[j + 1][k + digits[i]] += dp[j][k]) %= mod;\n\n    vector<vector<ll> > res(n + 1, vector<ll>(M));\n    for (int i = 0; i <= n; ++i)\n        for (int j = 0; j < M; ++j)\n            res[i][j] = dp[i][j];\n    return res;\n}\nll gao(const vector<int>& a, const vector<int>& digits)\n{\n    int n = a.size();\n\n    ll res = 0;\n    for (int i = 0; i < n; ++i)\n    {\n        vector<int> d;\n        for (int j = 0; j < n; ++j)\n            if (i != j)\n                d.push_back(digits[j]);\n        vector<vector<ll> > d_pat = digits_dp(d);\n\n        for (int j = 0; j < n; ++j)\n        {\n            for (int k = 0; k < M; ++k)\n            {\n                ll pat = 0;\n                for (int u = 0; u <= (n - 1) - j; ++u)\n                    (pat += (combi[(n - 1) - j][u] * fact[u] % mod) * fact[j]) %= mod;\n                (pat *= d_pat[j][k]) %= mod;\n\n                (res += ((a[i] * ten_pow[k]) % mod) * pat) %= mod;\n            }\n        }\n    }\n\n    return res;\n}\nint main()\n{\n    fact[0] = 1;\n    for (int i = 1; i < 210; ++i)\n        fact[i] = (fact[i - 1] * i) % mod;\n\n    for (int i = 0; i < 210; ++i)\n    {\n        combi[i][0] = 1;\n        for (int j = 1; j <= i; ++j)\n            combi[i][j] = (combi[i - 1][j] + combi[i - 1][j - 1]) % mod;\n    }\n\n    ten_pow[0] = 1;\n    for (int i = 1; i < M; ++i)\n        ten_pow[i] = (ten_pow[i - 1] * 10) % mod;\n\n\n    int n;\n    vector<int> a, d;\n    cin >> n;\n    for (int i = 0; i < n; ++i)\n    {\n        string s;\n        cin >> s;\n        d.push_back(s.size());\n        a.push_back(to_T<int>(s));\n    }\n\n    ll res = gao(a, d);\n    if (find(all(a), 0) != a.end())\n    {\n        vector<int> _a, _d;\n        for (int i = 0; i < n; ++i)\n        {\n            if (a[i] != 0)\n            {\n                _a.push_back(a[i]);\n                _d.push_back(d[i]);\n            }\n        }\n\n        ll sub = gao(_a, _d);\n        res = (res - sub + mod) % mod;\n    }\n\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N],memo[400];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n\t\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nint main() {\n\tinit();\n\tfor (int i = 0; i < 300; ++i) {\n\t\tmemo[i] = 0;\n\t\tfor (int j = 0; j <= i; ++j) {\n\t\t\tmemo[i] +=comb(i,j)* fact[j];\n\t\t}\n\t}\n\tint N; cin >> N;\n\tvector<int>ketas(5);\n\tvector<int>sums(5);\n\tbool have_zero = false;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint a; cin >> a;\n\t\tif (!a) {\n\t\t\thave_zero = true;\n\t\t}\n\t\tconst int keta = to_string(a).size();\n\t\tketas[keta]++;\n\t\tsums[keta]+=a;\n\t}\n\tMod ans = 0;\n\tfor (int keta = 1; keta <= 4; ++keta) {\n\t\tketas[keta]--;\n\t\tvector<int>under_nums(5);\n\t\t\n\t\tfor (under_nums[1] = 0; under_nums[1] <= ketas[1]; ++under_nums[1]) {\n\t\t\tfor (under_nums[2] = 0; under_nums[2] <= ketas[2]; ++under_nums[2]) {\n\t\t\t\tfor (under_nums[3] = 0; under_nums[3] <= ketas[3]; ++under_nums[3]) {\n\t\t\t\t\tfor (under_nums[4] = 0; under_nums[4] <= ketas[4]; ++under_nums[4]) {\n\t\t\t\t\t\tMod under_choice = 1;\n\t\t\t\t\t\tint under_size = 0;\n\t\t\t\t\t\tfor (int i = 1; i <= 4; ++i) {\n\t\t\t\t\t\t\tunder_size += under_nums[i] * i;\n\t\t\t\t\t\t\tunder_choice *= comb(ketas[i], under_nums[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint under_count = accumulate(under_nums.begin(), under_nums.end(), 0);\n\t\t\t\t\t\tMod under_perm =fact[under_count];\n\t\t\t\t\t\t\n\t\t\t\t\t\tint above_sum = accumulate(ketas.begin(), ketas.end(), 0) - accumulate(under_nums.begin(), under_nums.end(), 0);\n\t\t\t\t\t\tMod above_choice = memo[above_sum];\n\t\t\t\t\t\tans += Mod(sums[keta]) * under_choice*under_perm*above_choice*mod_pow(Mod(10),under_size);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tketas[keta]++;\n\t}\n\tif (have_zero) {\n\t\tketas[1]--;\n\t\tfor (int keta = 1; keta <= 4; ++keta) {\n\t\t\tketas[keta]--;\n\t\t\tvector<int>under_nums(5);\n\n\t\t\tfor (under_nums[1] = 0; under_nums[1] <= ketas[1]; ++under_nums[1]) {\n\t\t\t\tfor (under_nums[2] = 0; under_nums[2] <= ketas[2]; ++under_nums[2]) {\n\t\t\t\t\tfor (under_nums[3] = 0; under_nums[3] <= ketas[3]; ++under_nums[3]) {\n\t\t\t\t\t\tfor (under_nums[4] = 0; under_nums[4] <= ketas[4]; ++under_nums[4]) {\n\t\t\t\t\t\t\tMod under_choice = 1;\n\t\t\t\t\t\t\tint under_size = 0;\n\t\t\t\t\t\t\tfor (int i = 1; i <= 4; ++i) {\n\t\t\t\t\t\t\t\tunder_size += under_nums[i] * i;\n\t\t\t\t\t\t\t\tunder_choice *= comb(ketas[i], under_nums[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tint under_count = accumulate(under_nums.begin(), under_nums.end(), 0);\n\t\t\t\t\t\t\tMod under_perm = fact[under_count];\n\t\t\t\t\t\t\tint above_sum = accumulate(ketas.begin(), ketas.end(), 0) - accumulate(under_nums.begin(), under_nums.end(), 0);\n\t\t\t\t\t\t\tMod above_choice = memo[above_sum];\n\t\t\t\t\t\t\tans -= Mod(sums[keta]) * under_choice*under_perm*above_choice*mod_pow(Mod(10), under_size);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tketas[keta]++;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\n\nll memo[210][810];\nll calc(int i, int k, ll dp[210][810], int len){\n    if(i == 0) return (k == 0 ? 1 : 0);\n    if(k <  0) return 0;\n    if(memo[i][k] != -1) return memo[i][k];\n    return memo[i][k] = dp[i][k] - calc(i - 1, k - len, dp, len);\n}\n\nll fact[210], ifact[210];\nll inv[210];\nll pow10[210];\nvoid init(int N){\n    pow10[0] = 1;\n    for(int i = 1; i <= N; i++){\n        pow10[i] = pow10[i - 1] * 10 % MOD;\n    }\n    inv[1] = 1;\n    for (int i = 2; i <= N; ++i){\n        inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n    }\n    fact[0] = 1, ifact[0] = 1;\n    for(int i = 1; i <= N; i++){\n        fact[i] = fact[i - 1] * i % MOD;\n        ifact[i] = ifact[i - 1] * inv[i] % MOD;\n    }\n}\nll C(int n, int r){\n    if(n < 0 || r < 0 || r > n) return 0;\n    if(r > n / 2) r = n - r;\n    return fact[n] * ifact[n - r] % MOD * ifact[r] % MOD;\n}\nll solve(vector<ll> a, vector<ll> len){\n    int n = a.size();\n    ll dp[210][810] = {};\n    dp[0][0] = 1;\n    for(int i = 0; i < n; i++){\n        for(int j = i; j >= 0; j--){\n            for(int k = 4 * i; k >= 0; k--){\n                dp[j + 1][k + len[i]] += dp[j][k];\n                dp[j + 1][k + len[i]] %= MOD;\n            }\n        }\n    }\n\n    ll ways_left[210] = {};\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j <= i; j++){\n            ways_left[i] += C(i, j) * fact[j] % MOD;\n        }\n    }\n    ll ans = 0;\n    REP(i, n){\n        REP(j, 210) REP(k, 810) memo[j][k] = -1;\n        for(int j = 0; j <= n - 1; j++){\n            for(int k = 0; k <= j * 4; k++){\n                //printf(\"(%d, %d, %d) = %lld\\n\", i, j, k, ways_left[n - 1 - j] * a[i] % MOD * pow10[k] % MOD * calc(j, k, dp, len[i]) % MOD * fact[j] % MOD);\n                ans += ways_left[n - 1 - j] * a[i] % MOD * pow10[k] % MOD * calc(j, k, dp, len[i]) % MOD * fact[j] % MOD;\n            }\n        }\n    }\n    return ans;\n}\n\nint main(){\n    init(200);\n    int n;\n    while(cin >> n){\n        vector<ll> a(n);\n        vector<ll> len(n);\n        vector<ll> b;\n        vector<ll> len2;\n        REP(i, n){\n            string s;\n            cin >> s;\n            len[i] = s.size();\n            a[i] = atoi(s.c_str());\n            if(a[i] != 0){\n                b.push_back(a[i]);\n                len2.push_back(len[i]);\n            }\n        }\n        if(a.size() == b.size()){\n            cout << solve(a, len) << endl;;\n        }else{\n            cout << (solve(a, len) - solve(b, len2) + MOD) % MOD << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nlong long n, a[209], sz[209], ret, mod = 1000000007;\nlong long dp[209][209][209], power[5] = { 1,10,100,1000,10000 };\n\nlong long solve(vector<long long>E, long long num, bool iszero) {\n\tfor (int i = 0; i <= E.size(); i++) { for (int j = 0; j <= i; j++) { for (int k = 0; k <= i - j; k++) dp[i][j][k] = 0; } }\n\tdp[0][0][0] = 1;\n\tfor (int k = 0; k < E.size(); k++) {\n\t\tfor (int i = 0; i <= k; i++) {\n\t\t\tfor (int j = 0; j <= k - i; j++) {\n\t\t\t\tif (dp[k][i][j] == 0) continue;\n\t\t\t\tlong long X = i + 1, Y = j + 1;\n\t\t\t\tdp[k + 1][i + 1][j] += dp[k][i][j] * X; dp[k + 1][i + 1][j] %= mod;\n\t\t\t\tdp[k + 1][i][j + 1] += dp[k][i][j] * Y*power[sz[E[k]]]; dp[k + 1][i][j + 1] %= mod;\n\t\t\t\tdp[k + 1][i][j] += dp[k][i][j]; if (dp[k + 1][i][j] >= mod) dp[k + 1][i][j] -= mod;\n\t\t\t}\n\t\t}\n\t}\n\tlong long Z = 0;\n\tfor (int j = 0; j <= E.size(); j++) {\n\t\tfor (int k = 0; k <= E.size() - j; k++) {\n\t\t\tif (j == 0 && num == 0) continue;\n\t\t\tZ += dp[E.size()][j][k]; Z %= mod;\n\t\t\tif (iszero == true) {\n\t\t\t\tZ += dp[E.size()][j][k] * j; Z %= mod;\n\t\t\t\tZ += dp[E.size()][j][k] * (k + 1) * 10LL; Z %= mod;\n\t\t\t}\n\t\t}\n\t}\n\treturn Z;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) { cin >> a[i]; sz[i] = to_string(a[i]).size(); }\n\tfor (int i = 1; i <= n; i++) {\n\t\tvector<long long>X; bool OK = false;\n\t\tfor (int j = 1; j <= n; j++) { if (i != j) { if (a[j] != 0)X.push_back(j); else OK = true; } }\n\t\tlong long G = solve(X, a[i], OK);\n\t\tret += a[i] * G; ret %= mod;\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\n\nll add(ll a,ll b){ return (a+b)%mod; }\n\nvoid Add(ll &a,ll b){\n  a=(a+b)%mod;\n}\n\nll mul(ll a,ll b){ return (a*b)%mod; }\n\n\nll mpow(ll a,ll b){\n  ll res=1;\n  while(b){\n    if(b%2==1)res=mul(res,a);\n    a=mul(a,a);\n    b/=2;\n  }\n  return res;\n}\n\nll divi( ll a,ll b){\n  return mul(a, mpow(b,mod-2) );\n}\n\nll mem[1000][1000];\n\nll nCr(ll n,ll r){\n  if(r==0)return 1;\n  if(n==r)return 1;\n  if(n<r)return 0;\n  \n  if(mem[n][r])return mem[n][r];\n  mem[n][r]=add( nCr(n-1,r-1) , nCr(n-1,r) );\n  return mem[n][r];\n}\n\nint n;\nint a[200];\n\nll Z=0;\nll cnt[10];\nll sum[10];\n\n//ll dp[50][50][50][50][2];\n//ll DP[50][50][50][50][2];\nvector< vector< vector< vector< vector< ll > > > >  > dp,DP;\n\nvoid update(int a,int b,int c,int d,int z){\n  /*  cout<<a<<' '<<b<<' '<<c<<' '<<d<<' '<<z<<endl;\n  cout<<dp[a][b][c][d][z]<<endl;\n  cout<<DP[a][b][c][d][z]<<endl;\n  cout<<endl;    */\n  if(a<cnt[1]){\n    int cc=cnt[1]-a;\n    ll pp=mul(dp[a][b][c][d][z], cc);\n    Add( dp[a+1][b][c][d][z], pp );\n    Add( DP[a+1][b][c][d][z], mul(DP[a][b][c][d][z], 10*cc )    );\n    Add( DP[a+1][b][c][d][z], divi(pp,cnt[1])*sum[1] );\n  }\n  \n  if(b<cnt[2]){\n    int cc=cnt[2]-b;\n    ll pp=mul(dp[a][b][c][d][z], cc);\n    Add( dp[a][b+1][c][d][z], pp );\n    Add( DP[a][b+1][c][d][z], mul(DP[a][b][c][d][z], 100*cc )    );\n    Add( DP[a][b+1][c][d][z], divi(pp,cnt[2])*sum[2] );\n  }\n  if(c<cnt[3]){\n    int cc=cnt[3]-b;\n    ll pp=mul(dp[a][b][c][d][z], cc);\n    Add( dp[a][b][c+1][d][z], mul(dp[a][b][c][d][z], cc) );\n    Add( DP[a][b][c+1][d][z], mul(DP[a][b][c][d][z], 1000*cc )    );\n    Add( DP[a][b][c+1][d][z], divi(pp,cnt[3])*sum[3] );\n  }\n  if(d<cnt[4]){\n    int cc=cnt[4]-d;\n    ll pp=mul(dp[a][b][c][d][z], cc);\n    Add( dp[a][b][c][d+1][z], mul(dp[a][b][c][d][z], cc) );\n    Add( DP[a][b][c][d+1][z], mul(DP[a][b][c][d][z], 10000*cc )    );\n    Add( DP[a][b][c][d+1][z], divi(pp,cnt[4])*sum[4] );\n  }\n  \n  if(z<Z && a+b+c+d>0){\n    Add( dp[a][b][c][d][z+1], dp[a][b][c][d][z] );\n    Add( DP[a][b][c][d][z+1], mul(DP[a][b][c][d][z], 10 )    );\n  }\n}\n\nll solve(){\n  dp.resize(cnt[1]+1);\n  for(int i=0;i<(int)dp.size();i++){\n    dp[i].resize(cnt[2]+1);\n    for(int j=0;j<(int)dp[i].size();j++){\n      dp[i][j].resize(cnt[3]+1);\n      for(int k=0;k<(int)dp[i][j].size();k++){\n        dp[i][j][k].resize(cnt[4]+1);\n        for(int l=0;l<(int)dp[i][j][k].size();l++){\n          dp[i][j][k][l].resize(2);\n        }\n      }\n    }\n  }\n  DP=dp;\n\n  dp[0][0][0][0][0]=1;\n\n  ll ans=0;\n  \n  for(int a=0;a<=cnt[1];a++)\n    for(int b=0;b<=cnt[2];b++)\n      for(int c=0;c<=cnt[3];c++)\n        for(int d=0;d<=cnt[4];d++)\n          for(int z=0;z<=Z;z++){\n            update(a,b,c,d,z);\n            Add( ans, DP[a][b][c][d][z] );\n          }\n\n  return ans;\n}\n\nint countDisit(int x){\n  int res=0;\n  while(x){\n    res++;\n    x/=10;\n  }\n  return res;\n}\n\nint main(){\n  cin>>n;\n  \n  for(int i=0;i<n;i++){\n    cin>>a[i];\n    int D=countDisit(a[i]);\n    if(a[i]==0){\n      Z++;\n      continue;\n    }\n    cnt[D]++;\n    sum[D]+=a[i];\n  }\n  cout<< solve() <<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nvoid combination(int n, vector<vector<long long> >& comb)\n{\n    comb.assign(n+1, vector<long long>(n+1, 0));\n    for(int i=0; i<=n; ++i){\n        comb[i][0] = 1;\n        for(int j=1; j<=i; ++j){\n            comb[i][j] = comb[i-1][j-1] + comb[i-1][j];\n            comb[i][j] %= MOD;\n        }\n    }\n}\n\nint main()\n{\n    vector<vector<long long> > comb; // 組み合わせ\n    combination(1000, comb);\n\n    vector<long long> factorial(1001, 1); // 階乗\n    for(int i=1; i<=1000; ++i)\n        factorial[i] = (factorial[i-1] * i) % MOD;\n\n    vector<long long> pow10(1001, 1); // 10のべき乗\n    for(int i=1; i<=1000; ++i)\n        pow10[i] = (pow10[i-1] * 10) % MOD;\n\n    vector<long long> select(1001, 1); // [i] : i個の要素からi個以下の要素を選び、並び替える場合の数\n    for(int i=1; i<=1000; ++i){\n        for(int j=1; j<=i; ++j){\n            select[i] *= j;\n            ++ select[i];\n            select[i] %= MOD;\n        }\n    }\n\n    //////////////////////////////////////////////////////////////////////\n\n    int n;\n    cin >> n;\n\n    vector<int> x(5);   // [i] : i桁の数字の個数\n    vector<int> sum(5); // [i] : i桁の数字の合計値\n    for(int i=0; i<n; ++i){\n        int a;\n        cin >> a;\n        \n        int b = a;\n        int len = 0;\n        while(b > 0){\n            ++ len;\n            b /= 10;\n        }\n        ++ x[len];\n        sum[len] += a;\n    }\n\n    int m = 1;\n    for(int i=0; i<5; ++i)\n        m *= x[i] + 1;\n\n    long long ret = 0;\n    for(int i=0; i<m-1; ++i){\n        int tmp = i;\n        vector<int> y(5);\n        int num = 0;\n        int len = 0;\n        for(int i=0; i<5; ++i){\n            y[i] = tmp % (x[i] + 1);\n            num += y[i];\n            len += y[i] * max(1, i);\n            tmp /= (x[i] + 1);\n        }\n\n        for(int j=1; j<5; ++j){\n            if(x[j] == 0)\n                continue;\n            if(y[j] + 1 > x[j])\n                continue;\n\n            long long ret2 = 1;\n            for(int k=0; k<5; ++k){\n                if(j == k)\n                    ret2 *= comb[x[k]-1][y[k]];\n                else\n                    ret2 *= comb[x[k]][y[k]];\n                ret2 %= MOD;\n            }\n\n            ret2 *= factorial[num];\n            ret2 %= MOD;\n\n            ret2 *= pow10[len];\n            ret2 %= MOD;\n\n            if(x[0] - y[0] > 0){\n                ret2 *= (select[n-num-1] - select[n-num-2] + MOD);\n                ret2 %= MOD;\n            }else{\n                ret2 *= select[n-num-1];\n                ret2 %= MOD;\n            }\n\n            ret += ret2 * sum[j];\n            ret %= MOD;\n        }\n    }\n\n    cout << ret << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\n\nint pow10[1000];\n\nint N;\nint sum[5],cnt[5];\n\nint table[205][1005];\nint table2[205][205];\nint C[500][500];\nint F[500];\n\nint calc(){\n    memset(table,0,sizeof(table));\n    rep(i1,cnt[1]+1){\n        rep(i2,cnt[2]+1){\n            rep(i3,cnt[3]+1){\n                rep(i4,cnt[4]+1){\n                    int t=C[cnt[1]][i1]*C[cnt[2]][i2]%mod*C[cnt[3]][i3]%mod*C[cnt[4]][i4]%mod;\n                    table[i1+i2+i3+i4][i1+i2*2+i3*3+i4*4]=(table[i1+i2+i3+i4][i1+i2*2+i3*3+i4*4]+t)%mod;\n                }\n            }\n        }\n    }\n\n    int ret=0;\n    for(int z=0;z<=cnt[0];z++){\n        for(int c=0;c<N-cnt[0];c++){\n            for(int s=0;s<N*4;s++){\n                int t=table[c][s]*C[cnt[0]][z]%mod;\n                t=t*F[c+z]%mod;\n                int lc=N-cnt[0]-1-c;\n                int lz=cnt[0]-z;\n                t=t*table2[lc][lz]%mod;\n                ret=(ret+t*pow10[s+z])%mod;\n            }\n        }\n    }\n\n    return ret;\n}\n\nsigned main(){\n    pow10[0]=1;\n    for(int i=1;i<1000;i++)pow10[i]=pow10[i-1]*10%mod;\n    C[0][0]=1;\n    for(int i=1;i<500;i++){\n        C[i][0]=C[i][i]=1;\n        for(int j=1;j<i;j++)C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n    }\n    F[0]=1;\n    for(int i=1;i<500;i++)F[i]=F[i-1]*i%mod;\n\n    for(int i=0;i<=200;i++){\n        for(int j=0;j<=200;j++){\n            table2[i][j]=1;\n            if(i){\n                int s=i+j-1;\n                for(int k=0;k<=s;k++){\n                    int t=C[s][k]*F[k]%mod;\n                    t=t*i%mod;\n                    table2[i][j]=(table2[i][j]+t)%mod;\n                }\n            }\n        }\n    }\n\n    cin>>N;\n    rep(i,N){\n        int a;\n        cin>>a;\n        if(a==0){\n            cnt[0]++;\n        }\n        else{\n            stringstream ss;\n            ss<<a;\n            int d=ss.str().size();\n            sum[d]+=a;\n            cnt[d]++;\n        }\n    }\n\n    int ans=0;\n    for(int i=1;i<5;i++){\n        if(cnt[i]==0)continue;\n        cnt[i]--;\n        int tmp=calc();\n        cnt[i]++;\n        ans=(ans+tmp*sum[i])%mod;\n    }\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nint N;\nbool zero_FLG;\nll POW[1000];\nll num_count[5]; //1～4桁の数がいくつあるか\nll digit_sum[5]; //1～4桁の数の合計\nll nCm[200][200]; //抽出する場合の数\nll mult_num[200]; //n!の表\nll mult_sum[200]; //ΣnPk(k = 0～n)の表\nll dp[5][200][1000]; //dp[桁数][右側の数字の使用個数][位置(右側の数字の合計桁数)] = 場合の数\n\nint get_digit(ll num){\n\tif(num == 0)return 1;\n\n\tint count = 0;\n\n\twhile(num > 0){\n\t\tcount++;\n\t\tnum /= 10;\n\t}\n\treturn count;\n}\n\nvoid make_dp(){\n\n\tfor(int digit = 1; digit <= 4; digit++){\n\t\tfor(int use_num = 0; use_num < 200; use_num++){\n\t\t\tfor(int loc = 0; loc < 1000; loc++)dp[digit][use_num][loc] = 0;\n\t\t}\n\t}\n\n\tll sum_digit,sum_use,tmp;\n\tint work[5];\n\n\t//★★1～4桁の数が、ある場所に来る場合の数を求める[ある場所の右に来る数列を計算する]★★\n\tfor(int digit = 1; digit <= 4; digit++){ //計算したい桁の数\n\n\t\tfor(int num1 = 0; num1 <= num_count[1]; num1++){ //1桁の数の使用数\n\t\t\tif(digit == 1 && num1 == 0)continue; //1桁の数を計算したいなら、少なくとも1つ必要(自分の分)\n\n\t\t\tfor(int num2 = 0; num2 <= num_count[2]; num2++){\n\t\t\t\tif(digit == 2 && num2 == 0)continue;\n\n\t\t\t\tfor(int num3 = 0; num3 <= num_count[3]; num3++){\n\t\t\t\t\tif(digit == 3 && num3 == 0)continue;\n\n\t\t\t\t\tfor(int num4 = 0; num4 <= num_count[4]; num4++){\n\t\t\t\t\t\tif(digit == 4 && num4 == 0)continue;\n\n\t\t\t\t\t\twork[1] = num1;\n\t\t\t\t\t\twork[2] = num2;\n\t\t\t\t\t\twork[3] = num3;\n\t\t\t\t\t\twork[4] = num4;\n\n\t\t\t\t\t\twork[digit] -= 1; //自分を除く\n\n\t\t\t\t\t\tsum_use = 0;\n\t\t\t\t\t\tsum_digit = 0;\n\n\t\t\t\t\t\tfor(int i = 1; i <= 4; i++){\n\t\t\t\t\t\t\tsum_use += work[i];\n\t\t\t\t\t\t\tsum_digit += i*work[i];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//★★数字を抽出する場合の数を掛ける★★\n\t\t\t\t\t\ttmp = 1;\n\t\t\t\t\t\tfor(int i = 1; i <= 4; i++){\n\t\t\t\t\t\t\tif(digit != i){\n\t\t\t\t\t\t\t\ttmp *= nCm[num_count[i]][work[i]];\n\t\t\t\t\t\t\t}else{ //digit == i\n\t\t\t\t\t\t\t\ttmp *= nCm[num_count[i]-1][work[i]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttmp %= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmp *= mult_num[sum_use]; //sum_use個の数字の並べ方はsum_use!通り\n\t\t\t\t\t\ttmp %= MOD;\n\n\t\t\t\t\t\tdp[digit][sum_use][sum_digit] += tmp;\n\t\t\t\t\t\tdp[digit][sum_use][sum_digit] %= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nll calc(){\n\n\tmake_dp();\n\n\tll ret = 0;\n\tll tmp;\n\tfor(int digit = 1; digit <= 4; digit++){\n\t\tfor(int use_num = 0; use_num < 200; use_num++){\n\t\t\tfor(int loc = 0; loc < 1000; loc++){\n\n\t\t\t\ttmp = dp[digit][use_num][loc]*POW[loc];\n\t\t\t\ttmp %= MOD;\n\t\t\t\ttmp *= mult_sum[N-(use_num+1)]; //★左側に並べる数字の場合の数の総和★\n\t\t\t\ttmp %= MOD;\n\t\t\t\ttmp *= digit_sum[digit];\n\t\t\t\ttmp %= MOD;\n\t\t\t\tret += tmp;\n\t\t\t\tret %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\n\t//10の累乗を計算する\n\tPOW[0] = 1;\n\tfor(int i = 1; i < 1000; i++){\n\t\tPOW[i] = POW[i-1]*10;\n\t\tPOW[i] %= MOD;\n\t}\n\n\t//ΣnPkおよびn!を求める\n\tll number,tmp_sum;\n\tfor(ll a = 199;a >= 0; a--){\n\t\ttmp_sum = a+1; //aP0 == 1,aP1 = a\n\t\tnumber = a;\n\t\tfor(ll k = 1; k <= a-1; k++){\n\t\t\tnumber *= (a-k);\n\t\t\tnumber %= MOD;\n\t\t\ttmp_sum += number;\n\t\t\ttmp_sum %= MOD;\n\t\t}\n\t\tmult_num[a] = number; //a!\n\t\tmult_sum[a] = tmp_sum; //ΣaPk\n\t}\n\n\t//コンビネーションを求める\n\tnCm[0][0] = 1;\n\tfor(int n = 1; n < 200; n++) {\n\t\tfor (int k = 0; k <= n; k++) {\n\t\t\tif(k > 0){\n\t\t\t\tnCm[n][k] = nCm[n-1][k]+nCm[n-1][k-1];\n\t\t\t}else{ //k == 0\n\t\t\t\tnCm[n][k] = 1;\n\t\t\t}\n\t\t\tnCm[n][k] %= MOD;\n\t\t}\n\t}\n\n\tmult_num[0] = 1; //0! = 1\n\n\tzero_FLG = false; //0が登場したかどうかのフラグ\n\tfor(int i = 1; i <= 4; i++){\n\t\tnum_count[i] = 0;\n\t\tdigit_sum[i] = 0;\n\t}\n\n\tscanf(\"%d\",&N);\n\n\tint tmp_digit;\n\tll tmp;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lld\",&tmp);\n\t\tif(tmp == 0){\n\t\t\tzero_FLG = true;\n\t\t}\n\t\ttmp_digit = get_digit(tmp);\n\t\tnum_count[tmp_digit]++; //tmp_digit桁の数の個数を計上\n\t\tdigit_sum[tmp_digit] += tmp; //tmp_digit桁の数の総和を求める\n\t}\n\n\tll ans = calc();\n\tif(zero_FLG){\n\t\tN--; //0は入力されても最大1つ(問題仕様)\n\t\tnum_count[1]--;\n\t\tans -= calc();\n\t\tif(ans < 0)ans += MOD;\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\n\nll add(ll a,ll b){ return (a+b)%mod; }\n\nvoid Add(ll &a,ll b){\n  a=(a+b)%mod;\n}\n\nll mul(ll a,ll b){ return (a*b)%mod; }\n\n\nll mpow(ll a,ll b){\n  ll res=1;\n  while(b){\n    if(b%2==1)res=mul(res,a);\n    a=mul(a,a);\n    b/=2;\n  }\n  return res;\n}\n\nll divi( ll a,ll b){\n  return mul(a, mpow(b,mod-2) );\n}\n\nll mem[1000][1000];\n\nll nCr(ll n,ll r){\n  if(r==0)return 1;\n  if(n==r)return 1;\n  if(n<r)return 0;\n  \n  if(mem[n][r])return mem[n][r];\n  mem[n][r]=add( nCr(n-1,r-1) , nCr(n-1,r) );\n  return mem[n][r];\n}\n\nint n;\nint a[200];\n\nll Z=0;\nll cnt[10];\nll sum[10];\n\n//ll dp[50][50][50][50][2];\n//ll DP[50][50][50][50][2];\nvector< vector< vector< vector< vector< ll > > > >  > dp,DP;\n\nvoid update(int a,int b,int c,int d,int z){\n  /*  cout<<a<<' '<<b<<' '<<c<<' '<<d<<' '<<z<<endl;\n  cout<<dp[a][b][c][d][z]<<endl;\n  cout<<DP[a][b][c][d][z]<<endl;\n  cout<<endl;    */\n  if(a<cnt[1]){\n    int cc=cnt[1]-a;\n    ll pp=mul(dp[a][b][c][d][z], cc);\n    Add( dp[a+1][b][c][d][z], pp );\n    Add( DP[a+1][b][c][d][z], mul(DP[a][b][c][d][z], 10*cc )    );\n    Add( DP[a+1][b][c][d][z], mul(divi(pp,cnt[1]),sum[1]) );\n  }\n  \n  if(b<cnt[2]){\n    int cc=cnt[2]-b;\n    ll pp=mul(dp[a][b][c][d][z], cc);\n    Add( dp[a][b+1][c][d][z], pp );\n    Add( DP[a][b+1][c][d][z], mul(DP[a][b][c][d][z], 100*cc )    );\n    Add( DP[a][b+1][c][d][z], mul(divi(pp,cnt[2]),sum[2]) );\n  }\n  if(c<cnt[3]){\n    int cc=cnt[3]-b;\n    ll pp=mul(dp[a][b][c][d][z], cc);\n    Add( dp[a][b][c+1][d][z], mul(dp[a][b][c][d][z], cc) );\n    Add( DP[a][b][c+1][d][z], mul(DP[a][b][c][d][z], 1000*cc )    );\n    Add( DP[a][b][c+1][d][z], mul(divi(pp,cnt[3]),sum[3]) );\n  }\n  if(d<cnt[4]){\n    int cc=cnt[4]-d;\n    ll pp=mul(dp[a][b][c][d][z], cc);\n    Add( dp[a][b][c][d+1][z], mul(dp[a][b][c][d][z], cc) );\n    Add( DP[a][b][c][d+1][z], mul(DP[a][b][c][d][z], 10000*cc )    );\n    Add( DP[a][b][c][d+1][z], mul(divi(pp,cnt[4]),sum[4]) );\n  }\n  \n  if(z<Z && a+b+c+d>0){\n    Add( dp[a][b][c][d][z+1], dp[a][b][c][d][z] );\n    Add( DP[a][b][c][d][z+1], mul(DP[a][b][c][d][z], 10 )    );\n  }\n}\n\nll solve(){\n  dp.resize(cnt[1]+1);\n  for(int i=0;i<(int)dp.size();i++){\n    dp[i].resize(cnt[2]+1);\n    for(int j=0;j<(int)dp[i].size();j++){\n      dp[i][j].resize(cnt[3]+1);\n      for(int k=0;k<(int)dp[i][j].size();k++){\n        dp[i][j][k].resize(cnt[4]+1);\n        for(int l=0;l<(int)dp[i][j][k].size();l++){\n          dp[i][j][k][l].resize(2);\n        }\n      }\n    }\n  }\n  DP=dp;\n\n  dp[0][0][0][0][0]=1;\n\n  ll ans=0;\n  \n  for(int a=0;a<=cnt[1];a++)\n    for(int b=0;b<=cnt[2];b++)\n      for(int c=0;c<=cnt[3];c++)\n        for(int d=0;d<=cnt[4];d++)\n          for(int z=0;z<=Z;z++){\n            update(a,b,c,d,z);\n            Add( ans, DP[a][b][c][d][z] );\n          }\n\n  return ans;\n}\n\nint countDisit(int x){\n  int res=0;\n  while(x){\n    res++;\n    x/=10;\n  }\n  return res;\n}\n\nint main(){\n  cin>>n;\n  \n  for(int i=0;i<n;i++){\n    cin>>a[i];\n    int D=countDisit(a[i]);\n    if(a[i]==0){\n      Z++;\n      continue;\n    }\n    cnt[D]++;\n    sum[D]+=a[i];\n  }\n  cout<< solve() <<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n  \nusing namespace std;\n  \n\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n  \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void unique(vector<T>& c) { c.erase(unique(c.begin(), c.end()), c.end()); }\ntemplate <class T> void sort_unique(vector<T>& c) { sort(c); unique(c); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n  \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n \nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n  \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\n\nconst int M = 210 * 5;\nll fact[210];\nll combi[210][210];\nll ten_pow[M];\n\nvoid add(ll& a, ll b)\n{\n    a += b;\n    if (a >= mod)\n        a -= mod;\n}\nvector<vector<ll> > digits_dp(const vector<int>& digits)\n{\n    int n = digits.size();\n\n    static ll dp[210][M + 30];\n    CL(dp, 0);\n    dp[0][0] = 1;\n    for (int i = 0; i < n; ++i)\n        for (int j = i; j >= 0; --j)\n            for (int k = 5 * i; k >= 0; --k)\n                add(dp[j + 1][k + digits[i]], dp[j][k]);\n\n    vector<vector<ll> > res(n + 1, vector<ll>(M));\n    for (int i = 0; i <= n; ++i)\n        for (int j = 0; j < M; ++j)\n            res[i][j] = dp[i][j];\n    return res;\n}\nll gao(const vector<int>& a, const vector<int>& digits)\n{\n    int n = a.size();\n\n    ll pat[210] = {};\n    for (int i = 0; i <= n - 1; ++i)\n        for (int j = 0; j <= (n - 1) - i; ++j)\n            (pat[i] += (combi[(n - 1) - i][j] * fact[j] % mod) * fact[i]) %= mod;\n\n    ll res = 0;\n    for (int i = 0; i < n; ++i)\n    {\n        vector<int> d;\n        for (int j = 0; j < n; ++j)\n            if (i != j)\n                d.push_back(digits[j]);\n        vector<vector<ll> > d_pat = digits_dp(d);\n\n        for (int j = 0; j < n; ++j)\n        {\n            for (int k = 0; k < M; ++k)\n            {\n                ll p = pat[j] * d_pat[j][k] % mod;\n                (res += ((a[i] * ten_pow[k]) % mod) * p) %= mod;\n            }\n        }\n    }\n\n    return res;\n}\nint main()\n{\n    fact[0] = 1;\n    for (int i = 1; i < 210; ++i)\n        fact[i] = (fact[i - 1] * i) % mod;\n\n    for (int i = 0; i < 210; ++i)\n    {\n        combi[i][0] = 1;\n        for (int j = 1; j <= i; ++j)\n            combi[i][j] = (combi[i - 1][j] + combi[i - 1][j - 1]) % mod;\n    }\n\n    ten_pow[0] = 1;\n    for (int i = 1; i < M; ++i)\n        ten_pow[i] = (ten_pow[i - 1] * 10) % mod;\n\n    int n;\n    vector<int> a, d;\n    cin >> n;\n    for (int i = 0; i < n; ++i)\n    {\n        string s;\n        cin >> s;\n        d.push_back(s.size());\n        a.push_back(to_T<int>(s));\n    }\n\n    ll res = gao(a, d);\n    if (find(all(a), 0) != a.end())\n    {\n        vector<int> _a, _d;\n        for (int i = 0; i < n; ++i)\n        {\n            if (a[i] != 0)\n            {\n                _a.push_back(a[i]);\n                _d.push_back(d[i]);\n            }\n        }\n\n        ll sub = gao(_a, _d);\n        res = (res - sub + mod) % mod;\n    }\n\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\n\nint power[1000];\n\nint N;\nint sum[5],cnt[5];\n\nint table[205][1005];\nint table2[205][205];\nint C[500][500];\nint F[500];\n\nint calc(){\n    memset(table,0,sizeof(table));\n    table[0][0]=1;\n    for(int i=1;i<5;i++){\n        for(int j=0;j<cnt[i];j++){\n            for(int k=N;k>=0;k--){\n                for(int l=0;l<N*4;l++){\n                    table[k+1][l+i]=(table[k+1][l+i]+table[k][l])%mod;\n                }\n            }\n        }\n    }\n\n    int ret=0;\n    for(int z=0;z<=cnt[0];z++){\n        for(int c=0;c<N-cnt[0];c++){\n            for(int s=0;s<N*4;s++){\n                int t=table[c][s]*C[cnt[0]][z]%mod;\n                t=t*F[c+z]%mod;\n                int lc=N-cnt[0]-1-c;\n                int lz=cnt[0]-z;\n                t=t*table2[lc][lz]%mod;\n                ret=(ret+t*power[s+z])%mod;\n            }\n        }\n    }\n\n    return ret;\n}\n\nsigned main(){\n    power[0]=1;\n    for(int i=1;i<1000;i++)power[i]=power[i-1]*10%mod;\n    C[0][0]=1;\n    for(int i=1;i<500;i++){\n        C[i][0]=C[i][i]=1;\n        for(int j=1;j<i;j++)C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;\n    }\n    F[0]=1;\n    for(int i=1;i<500;i++)F[i]=F[i-1]*i%mod;\n\n    for(int i=0;i<=200;i++){\n        for(int j=0;j<=200;j++){\n            table2[i][j]=1;\n            if(i){\n                int s=i+j-1;\n                for(int k=0;k<=s;k++){\n                    int t=C[s][k]*F[k]%mod;\n                    t=t*i%mod;\n                    table2[i][j]=(table2[i][j]+t)%mod;\n                }\n            }\n        }\n    }\n\n    cin>>N;\n    rep(i,N){\n        int a;\n        cin>>a;\n        if(a==0){\n            cnt[0]++;\n        }\n        else{\n            stringstream ss;\n            ss<<a;\n            int d=ss.str().size();\n            sum[d]+=a;\n            cnt[d]++;\n        }\n    }\n\n    int ans=0;\n    for(int i=1;i<5;i++){\n        if(cnt[i]==0)continue;\n        cnt[i]--;\n        int tmp=calc();\n        cnt[i]++;\n        ans=(ans+tmp*sum[i])%mod;\n    }\n\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\nint n,a[200];\nll func[201],perm[201][201],sump[201],p10[801],dp[4][2][201][801];\nll mod=1e9+7;\nint dig(int x){\n\tif(x<10) return 0;\n\tif(x<100) return 1;\n\tif(x<1000) return 2;\n\treturn 3;\n}\nvoid add(ll &x,ll y){\n\tx+=y;\n\tif(x>=mod) x%=mod;\n}\nll solve(){\n\tint cntd[4]={},sumd[4]={};\n\trep(i,n) cntd[dig(a[i])]++;\n\trep(i,n) sumd[dig(a[i])]+=a[i];\n\trep(d,4){\n\t\tif(cntd[d]==0) continue;\n\t\tvector<int> vc;\n\t\trep(i,4) rep(j,cntd[i]){\n\t\t\tif(i==d&&j==0) continue;\n\t\t\tvc.push_back(i+1);\n\t\t}\n\t\tdp[d][0][0][0]=1;\n\t\trep(i,vc.size()){\n\t\t\trep(j,vc.size()+1) rep(k,801) dp[d][1-i%2][j][k]=0;\n\t\t\trep(j,vc.size()+1){\n\t\t\t\trep(k,801){\n\t\t\t\t\tif(dp[d][i%2][j][k]==0) continue;\n\t\t\t\t\tadd(dp[d][1-i%2][j][k],dp[d][i%2][j][k]);\n\t\t\t\t\tadd(dp[d][1-i%2][j+1][k+vc[i]],dp[d][i%2][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans=0;\n\trep(d,4){\n\t\tif(cntd[d]==0) continue;\n\t\trep(j,n) rep(k,801) add(ans,sumd[d]*dp[d][1-n%2][j][k]%mod*func[j]%mod*sump[n-1-j]%mod*p10[k]);\n\t}\n\treturn ans;\n}\nint main(){\n\tfunc[0]=1;\n\trep(i,200) func[i+1]=func[i]*(i+1)%mod;\n\trep(i,201) perm[i][0]=1;\n\trep(i,201) rep(j,i) perm[i][j+1]=perm[i][j]*(i-j)%mod;\n\trep(i,201) rep(j,i+1) add(sump[i],perm[i][j]);\n\tp10[0]=1;\n\trep(i,800) p10[i+1]=p10[i]*10%mod;\n\tcin>>n;\n\trep(i,n) cin>>a[i];\n\tll ans=solve();\n\tsort(a,a+n);\n\tif(a[0]==0){\n\t\tswap(a[n-1],a[0]);\n\t\tn--;\n\t\trep(i,4) rep(j,2) rep(k,201) rep(l,801) dp[i][j][k][l]=0;\n\t\tll mn=solve();\n\t\tans=(ans-mn+mod)%mod;\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MD = 1e9+7;\nconst int MN = 210;\nconst int MM = 4;\nconst int MS = MN*MM;\n\nint n;\nstring s[MN];\nint si[MN];\nint sd[MN];\n\nll inv2;\nll po10[MS];\nll facdp[MN];\n\nll dp1[MN][MS], dp2[MN][MS];\nll calc() {\n    inv2 = (MD+1)/2;\n    po10[0] = 1;\n    for (int i = 1; i < MS; i++) {\n        po10[i] = po10[i-1] * 10;\n        po10[i] %= MD;\n    }\n\n    for (int i = 0; i < MN; i++) {\n        facdp[i] = 0;\n        for (int j = 1; j <= i+1; j++) {\n            ll sm = 1;\n            for (int k = j; k <= i; k++) {\n                sm *= k;\n                sm %= MD;\n            }\n            facdp[i] += sm;\n            facdp[i] %= MD;\n        }\n    }\n\n    // for (int i = 0; i < 5; i++) {\n    //     cout << facdp[i] << \" \";\n    // } cout << endl;\n    for (int i = 0; i < n; i++) {\n        si[i] = stoi(s[i]);\n        sd[i] = (int)s[i].size();\n    }\n    memset(dp1, 0, sizeof(dp1));\n    dp1[0][0] = 1;\n    for (int fe = 0; fe < n; fe++) {\n        int nsd = sd[fe];\n        for (int i = 0; i < MN; i++) {\n            for (int j = 0; j < MS; j++) {\n                dp2[i][j] = dp1[i][j];\n                if (i >= 1 && j >= nsd) {\n                    dp2[i][j] += i*dp1[i-1][j-nsd];\n                    dp2[i][j] %= MD;\n                }\n            }\n        }\n        memcpy(dp1, dp2, sizeof(dp1));\n    }\n\n    // for (int i = 0; i <= n; i++) {\n    //     for (int j = 0; j < 10; j++) {\n    //         cout << dp1[i][j] << \" \";\n    //     } cout << endl;\n    // }\n    ll sm = 0;\n    for (int fe = 0; fe < n; fe++) {\n        int nsd = sd[fe];\n        for (int i = 0; i < MN; i++) {\n            for (int j = 0; j < MS; j++) {\n                dp2[i][j] = dp1[i][j];\n                if (i >= 1 && j >= nsd) {\n                    dp2[i][j] -= i*dp2[i-1][j-nsd];\n                    dp2[i][j] = (dp2[i][j]%MD+MD) % MD;\n                }\n                sm += po10[j] * dp2[i][j] %MD * si[fe] %MD * facdp[n-i-1] %MD;\n                sm %= MD;\n            }\n        }\n    }\n    return sm;\n}\n\nint main() {\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> s[i];\n    }\n    sort(s, s+n, [&](const string &l, const string &r){\n        return stoi(l) < stoi(r);\n    });\n\n    ll u = calc();\n    if (s[0] == \"0\") {\n        reverse(s, s+n);\n        reverse(s, s+n-1);\n        n--;\n        u -= calc();\n        u = (u+MD) % MD;\n    }\n    cout << u << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\n\nll add(ll a,ll b){ return (a+b)%mod; }\n\nvoid Add(ll &a,ll b){\n  a=(a+b)%mod;\n}\n\nll mul(ll a,ll b){ return (a*b)%mod; }\n\n\nll mpow(ll a,ll b){\n  ll res=1;\n  while(b){\n    if(b%2==1)res=mul(res,a);\n    a=mul(a,a);\n    b/=2;\n  }\n  return res;\n}\n\nll divi( ll a,ll b){\n  return mul(a, mpow(b,mod-2) );\n}\n\nll mem[1000][1000];\n\nll nCr(ll n,ll r){\n  if(r==0)return 1;\n  if(n==r)return 1;\n  if(n<r)return 0;\n  \n  if(mem[n][r])return mem[n][r];\n  mem[n][r]=add( nCr(n-1,r-1) , nCr(n-1,r) );\n  return mem[n][r];\n}\n\nint n;\nint a[200];\n\nll Z=0;\nll cnt[10];\nll cntinv[10];\n\nll sum[10];\n\n//ll dp[50][50][50][50][2];\n//ll DP[50][50][50][50][2];\nvector< vector< vector< vector< vector< ll > > > >  > dp,DP;\n\nvoid update(int a,int b,int c,int d,int z){\n  /*  cout<<a<<' '<<b<<' '<<c<<' '<<d<<' '<<z<<endl;\n  cout<<dp[a][b][c][d][z]<<endl;\n  cout<<DP[a][b][c][d][z]<<endl;\n  cout<<endl;    */\n  if(a<cnt[1]){\n    int cc=cnt[1]-a;\n    ll pp=mul(dp[a][b][c][d][z], cc);\n    Add( dp[a+1][b][c][d][z], pp );\n    Add( DP[a+1][b][c][d][z], mul(DP[a][b][c][d][z], 10*cc )    );\n    Add( DP[a+1][b][c][d][z], mul( mul(pp,cntinv[1]),sum[1]) );\n  }\n  \n  if(b<cnt[2]){\n    int cc=cnt[2]-b;\n    ll pp=mul(dp[a][b][c][d][z], cc);\n    Add( dp[a][b+1][c][d][z], pp );\n    Add( DP[a][b+1][c][d][z], mul(DP[a][b][c][d][z], 100*cc )    );\n    Add( DP[a][b+1][c][d][z], mul(mul(pp,cntinv[2]),sum[2]) );\n  }\n  if(c<cnt[3]){\n    int cc=cnt[3]-c;\n    ll pp=mul(dp[a][b][c][d][z], cc);\n    Add( dp[a][b][c+1][d][z], mul(dp[a][b][c][d][z], cc) );\n    Add( DP[a][b][c+1][d][z], mul(DP[a][b][c][d][z], 1000*cc )    );\n    Add( DP[a][b][c+1][d][z], mul(mul(pp,cntinv[3]),sum[3]) );\n  }\n  if(d<cnt[4]){\n    int cc=cnt[4]-d;\n    ll pp=mul(dp[a][b][c][d][z], cc);\n    Add( dp[a][b][c][d+1][z], mul(dp[a][b][c][d][z], cc) );\n    Add( DP[a][b][c][d+1][z], mul(DP[a][b][c][d][z], 10000*cc )    );\n    Add( DP[a][b][c][d+1][z], mul(mul(pp,cntinv[4]),sum[4]) );\n  }\n  \n  if(z<Z && a+b+c+d>0){\n    Add( dp[a][b][c][d][z+1], dp[a][b][c][d][z] );\n    Add( DP[a][b][c][d][z+1], mul(DP[a][b][c][d][z], 10 )    );\n  }\n}\n\nll solve(){\n  dp.resize(cnt[1]+1);\n  for(int i=0;i<(int)dp.size();i++){\n    dp[i].resize(cnt[2]+1);\n    for(int j=0;j<(int)dp[i].size();j++){\n      dp[i][j].resize(cnt[3]+1);\n      for(int k=0;k<(int)dp[i][j].size();k++){\n        dp[i][j][k].resize(cnt[4]+1);\n        for(int l=0;l<(int)dp[i][j][k].size();l++){\n          dp[i][j][k][l].resize(2);\n        }\n      }\n    }\n  }\n  DP=dp;\n\n  dp[0][0][0][0][0]=1;\n\n  ll ans=0;\n  \n  for(int a=0;a<=cnt[1];a++)\n    for(int b=0;b<=cnt[2];b++)\n      for(int c=0;c<=cnt[3];c++)\n        for(int d=0;d<=cnt[4];d++)\n          for(int z=0;z<=Z;z++){\n            update(a,b,c,d,z);\n            Add( ans, DP[a][b][c][d][z] );\n          }\n\n  return ans;\n}\n\nint countDisit(int x){\n  int res=0;\n  while(x){\n    res++;\n    x/=10;\n  }\n  return res;\n}\n\nint main(){\n  cin>>n;\n  \n  for(int i=0;i<n;i++){\n    cin>>a[i];\n    int D=countDisit(a[i]);\n    if(a[i]==0){\n      Z++;\n      continue;\n    }\n    cnt[D]++;\n    sum[D]+=a[i];\n  }\n\n  for(int i=1;i<=4;i++)\n    if(cnt[i]>0)\n      cntinv[i]=divi(1,cnt[i]);\n  cout<< solve() <<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\n#define mod 1000000007\n\nusing namespace std;\n\n\n// ------ 0. Variables, Functions ------ //\n\nint n;\n\nvector<int> fact;\nvector<int> inv;\nvector<int> factinv;\nvector<int> power2;\nvector<int> power10;\n\nint digit(int n)\n{\n\tif (n < 10) return 1;\n\n\treturn digit(n / 10) + 1;\n}\n\nint solve(vector<int> a)\n{\n\tvector<vector<int> > d(5, vector<int>(2, 0));\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\td[digit(a[i])][0] += 1;\n\t\td[digit(a[i])][1] += a[i];\n\t}\n\n\tint ret = 0;\n\n\tfor (int i = 1; i <= 4; i++)\n\t{\n\t\tvector<vector<vector<int> > > dp(5, vector<vector<int> >(n, vector<int>(n * 4, 0)));\n\n\t\tdp[0][0][0] = 1;\n\n\t\tif (d[i][0] != 0)\n\t\t{\n\t\t\td[i][0]--;\n\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t{\n\t\t\t\t\tfor (int l = 0; l < n * 4; l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dp[j][k][l] != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int m = 0; m <= d[j + 1][0]; m++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdp[j + 1][k + m][l + (j + 1) * m] += dp[j][k][l];\n\t\t\t\t\t\t\t\tdp[j + 1][k + m][l + (j + 1) * m] %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\td[i][0]++;\n\n\t\t\tint res = 0;\n\n\t\t\tint mul = 0;\n\n\t\t\tfor (int j = n - 1; j >= 0; j--)\n\t\t\t{\n\t\t\t\tmul = (mul + 1LL * fact[n - j - 1] * fact[n - 1] % mod * factinv[n - j - 1] % mod * factinv[j] % mod) % mod;\n\n\t\t\t\tfor (int k = 0; k < n * 4; k++)\n\t\t\t\t{\n\t\t\t\t\tres = (res + 1LL * dp[4][j][k] * power10[k] % mod * mul % mod) % mod;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = (ret + 1LL * res * d[i][1]) % mod;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\t// ------ 1. init ------ //\n\n\tfact.push_back(1);\n\n\tfor (int i = 1; i <= 200; i++) fact.push_back(1LL * fact[i - 1] * i % mod);\n\n\tpower2.push_back(1);\n\n\tfor (int i = 1; i <= 200; i++) power2.push_back(1LL * power2[i - 1] * 2 % mod);\n\n\tpower10.push_back(1);\n\n\tfor (int i = 1; i <= 800; i++) power10.push_back(1LL * power10[i - 1] * 10 % mod);\n\n\tinv.push_back(0);\n\tinv.push_back(1);\n\n\tfor (int i = 2; i <= 200; i++) inv.push_back(1LL * inv[mod % i] * (mod - mod / i) % mod);\n\n\tfactinv.push_back(1);\n\n\tfor (int i = 1; i <= 200; i++) factinv.push_back(1LL * factinv[i - 1] * inv[i] % mod);\n\n\n\t// ------ 2. Input ------ //\n\n\tscanf(\"%d\", &n);\n\n\tvector<int> a(n);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tsort(a.begin(), a.end(), greater<int>());\n\n\tint res = solve(a);\n\n\tif (a[n - 1] == 0)\n\t{\n\t\ta.pop_back(); n--;\n\n\t\tres += (mod - solve(a));\n\t\tres %= mod;\n\t}\n\n\tprintf(\"%d\\n\", res);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst ll     MOD = 1000000007;\nconst double EPS = 1e-8;\n\nll memo[210][810];\nll calc(int i, int k, ll dp[210][810], ll len){\n    if(i == 0) return (k == 0 ? 1 : 0);\n    if(k <  0) return 0;\n    if(memo[i][k] != -1) return memo[i][k];\n    return memo[i][k] = dp[i][k] - calc(i - 1, k - len, dp, len);\n}\n\nll fact[210], ifact[210];\nll inv[210];\nll pow_10[210];\nvoid init(int N){\n    pow_10[0] = 1;\n    for(int i = 1; i <= N; i++){\n        pow_10[i] = pow_10[i - 1] * 10 % MOD;\n    }\n    inv[1] = 1;\n    for (int i = 2; i <= N; ++i){\n        inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n    }\n    fact[0] = 1, ifact[0] = 1;\n    for(int i = 1; i <= N; i++){\n        fact[i] = fact[i - 1] * i % MOD;\n        ifact[i] = ifact[i - 1] * inv[i] % MOD;\n    }\n}\nll C(int n, int r){\n    if(n < 0 || r < 0 || r > n) return 0;\n    if(r > n / 2) r = n - r;\n    return fact[n] * ifact[n - r] % MOD * ifact[r] % MOD;\n}\nll solve(vector<ll> a, vector<ll> len){\n    int n = a.size();\n    ll dp[210][810] = {};\n    dp[0][0] = 1;\n    for(int i = 0; i < n; i++){\n        for(int j = i; j >= 0; j--){\n            for(int k = 4 * i; k >= 0; k--){\n                dp[j + 1][k + len[i]] += dp[j][k];\n                dp[j + 1][k + len[i]] %= MOD;\n            }\n        }\n    }\n\n    ll ways_left[210] = {};\n    for(int i = 0; i <= n; i++){\n        for(int j = 0; j <= i; j++){\n            ways_left[i] += C(i, j) * fact[j] % MOD;\n            ways_left[i] %= MOD;\n        }\n    }\n    ll ans = 0;\n    REP(i, n){\n        REP(j, 210) REP(k, 810) memo[j][k] = -1;\n        for(int j = 0; j <= n - 1; j++){\n            for(int k = 0; k <= j * 4; k++){\n                //printf(\"(%d, %d, %d) = %lld\\n\", i, j, k, ways_left[n - 1 - j] * a[i] % MOD * pow_10[k] % MOD * calc(j, k, dp, len[i]) % MOD * fact[j] % MOD);\n                ans += ways_left[n - 1 - j] * a[i] % MOD * pow_10[k] % MOD * calc(j, k, dp, len[i]) % MOD * fact[j] % MOD;\n                ans %= MOD;\n            }\n        }\n    }\n    return ans;\n}\n\nint main(){\n    init(210);\n    int n;\n    while(cin >> n){\n        vector<ll> a(n);\n        vector<ll> len(n);\n        vector<ll> b;\n        vector<ll> len2;\n        REP(i, n){\n            string s;\n            cin >> s;\n            len[i] = s.size();\n            a[i] = atoi(s.c_str());\n            if(a[i] != 0){\n                b.push_back(a[i]);\n                len2.push_back(len[i]);\n            }\n        }\n        if(a.size() == b.size()){\n            cout << solve(a, len) << endl;\n        }else{\n            cout << (solve(a, len) - solve(b, len2) + 2 * MOD) % MOD << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=1000000007 ;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-10;\nconst long double epsA=1e-4;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nllint solve(array<llint,5>in){\n\tstatic llint dp[201][201];\n\tstatic llint ep[201][201];\n\tdp[0][0]=1;ep[0][0]=1;\n\tint h,i=0,j,k,aa=1;\n\tfor(h=1;h<=4;h++){\n\t\taa*=10;\n\t\tfor(k=1;k<=in[h];k++){\n\t\t\ti++;\n\t\t\tdp[i][0]=dp[i-1][0];\n\t\t\tep[i][0]=ep[i-1][0];\n\t\t\tdp[i-1][i]=0;ep[i-1][i]=0;\n\t\t\tfor(j=1;j<=i;j++){\n\t\t\t\tdp[i][j]=(dp[i-1][j]+dp[i-1][j-1]*j)%mod;\n\t\t\t\tep[i][j]=(ep[i-1][j]+ep[i-1][j-1]*j*aa)%mod;\n\t\t\t}\n\t\t}\n\t\t//cerr<<\"de\"<<__LINE__<<endl;\n\t}\n\tint n=in[1]+in[2]+in[3]+in[4];\n\t//cerr<<\"n=\"<<n<<endl;\n\tllint ue[201]={};\n\tllint st[201]={};\n\tfor(i=0;i<=n;i++){\n\t\t//cerr<<\"de\"<<__LINE__<<endl;\n\t\tfor(j=0;j<=i;j++){ue[i]+=dp[i][j];}\n\t\tue[i]%=mod;\n\t\t//cerr<<\"i=\"<<i<<\"ue=\"<<ue[i]<<\"st=\"<<st[i]<<endl;\n\t}\n\tllint ans=0;\n\tfor(i=0;i<=n;i++){ans+=ue[i]*ep[n][n-i];ans%=mod;}\n\t//cerr<<\"ans=\"<<ans<<endl;\n\treturn ans;\n\t\n}\n\nint main(void){\n\tcout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);\n\t\n\tllint n;cin>>n;\n\t//桁数、数字\n\t//何桁目に来ることがどのくらいあるか\n\t//桁数 1,2,3,4の4パターンしかない\n\t//自分より上 m枚まである->dpする\n\t//0はじめ対策 何とかする\n\tarray<llint,5>mai={},suu={};\n\tbool Oaru=false;\n\tint h,i,j;\n\tfor(i=0;i<n;i++){\n\t\tint a;cin>>a;\n\t\tif(a==0){mai[1]++;Oaru=true;}\n\t\tint k=1,kk=0;\n\t\twhile(k<=a){k*=10;kk++;}\n\t\tmai[kk]++;suu[kk]+=a;\n\t}\n\tllint ans=0;\n\tfor(h=1;h<=4;h++){\n\t\tif(mai[h]==0){continue;}\n\t\tmai[h]--;\n\t\tans+=solve(mai)*suu[h];\n\t\tif(Oaru&&mai[1]>0){\n\t\t\tmai[1]--;\n\t\t\tans-=solve(mai)*suu[h];\n\t\t\tmai[1]++;\n\t\t}\n\t\tans%=mod;\n\t\tmai[h]++;\n\t}\n\tans%=mod;ans+=mod;ans%=mod;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\n#define mod 1000000007\n\nusing namespace std;\n\n\n// ------ 0. Variables, Functions ------ //\n\nint n;\n\nvector<int> fact;\nvector<int> inv;\nvector<int> factinv;\nvector<int> power2;\nvector<int> power10;\n\nint digit(int n)\n{\n\tif (n < 10) return 1;\n\n\treturn digit(n / 10) + 1;\n}\n\nint solve(vector<int> a)\n{\n\tvector<vector<int> > d(5, vector<int>(2, 0));\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\td[digit(a[i])][0] += 1;\n\t\td[digit(a[i])][1] += a[i];\n\t}\n\n\tint ret = 0;\n\n\tfor (int i = 1; i <= 4; i++)\n\t{\n\t\tvector<vector<vector<int> > > dp(5, vector<vector<int> >(n, vector<int>(n * 4, 0)));\n\n\t\tdp[0][0][0] = 1;\n\n\t\tif (d[i][0] != 0)\n\t\t{\n\t\t\td[i][0]--;\n\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t{\n\t\t\t\t\tfor (int l = 0; l < n * 4; l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (dp[j][k][l] != 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int m = 0; m <= d[j + 1][0]; m++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdp[j + 1][k + m][l + (j + 1) * m] += dp[j][k][l];\n\t\t\t\t\t\t\t\tdp[j + 1][k + m][l + (j + 1) * m] %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\td[i][0]++;\n\n\t\t\tint res = 0;\n\n\t\t\tint mul = 0;\n\n\t\t\tfor (int j = n - 1; j >= 0; j--)\n\t\t\t{\n\t\t\t\tmul = (mul + 1LL * fact[j] * fact[n - 1] % mod * factinv[j] % mod * factinv[n - j - 1] % mod) % mod;\n\n\t\t\t\tfor (int k = 0; k < n * 4; k++)\n\t\t\t\t{\n\t\t\t\t\tres = (res + 1LL * dp[4][j][k] * power10[k] % mod * mul % mod) % mod;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret = (ret + 1LL * res * d[i][1]) % mod;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\t// ------ 1. init ------ //\n\n\tfact.push_back(1);\n\n\tfor (int i = 1; i <= 200; i++) fact.push_back(1LL * fact[i - 1] * i % mod);\n\n\tpower2.push_back(1);\n\n\tfor (int i = 1; i <= 200; i++) power2.push_back(1LL * power2[i - 1] * 2 % mod);\n\n\tpower10.push_back(1);\n\n\tfor (int i = 1; i <= 800; i++) power10.push_back(1LL * power10[i - 1] * 10 % mod);\n\n\tinv.push_back(0);\n\tinv.push_back(1);\n\n\tfor (int i = 2; i <= 200; i++) inv.push_back(1LL * inv[mod % i] * (mod - mod / i) % mod);\n\n\tfactinv.push_back(1);\n\n\tfor (int i = 1; i <= 200; i++) factinv.push_back(1LL * factinv[i - 1] * inv[i] % mod);\n\n\n\t// ------ 2. Input ------ //\n\n\tscanf(\"%d\", &n);\n\n\tvector<int> a(n);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\n\tsort(a.begin(), a.end(), greater<int>());\n\n\tint res = solve(a);\n\n\tif (a[n - 1] == 0)\n\t{\n\t\ta.pop_back(); n--;\n\n\t\tres += (mod - solve(a));\n\t\tres %= mod;\n\t}\n\n\tprintf(\"%d\\n\", res);\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n  \nusing namespace std;\n  \n\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n  \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void unique(vector<T>& c) { c.erase(unique(c.begin(), c.end()), c.end()); }\ntemplate <class T> void sort_unique(vector<T>& c) { sort(c); unique(c); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n  \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n \nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n  \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\n\nconst int M = 210 * 5;\nll fact[210];\nll combi[210][210];\nll ten_pow[M];\nvector<vector<ll> > digits_dp(const vector<int>& digits)\n{\n    int n = digits.size();\n\n    static ll dp[210][M + 30];\n    CL(dp, 0);\n    dp[0][0] = 1;\n    for (int i = 0; i < n; ++i)\n        for (int j = i; j >= 0; --j)\n            for (int k = M - 1; k >= 0; --k)\n                (dp[j + 1][k + digits[i]] += dp[j][k]) %= mod;\n\n    vector<vector<ll> > res(n + 1, vector<ll>(M));\n    for (int i = 0; i <= n; ++i)\n        for (int j = 0; j < M; ++j)\n            res[i][j] = dp[i][j];\n    return res;\n}\nll gao(const vector<int>& a, const vector<int>& digits)\n{\n    int n = a.size();\n\n    ll res = 0;\n    for (int i = 0; i < n; ++i)\n    {\n        vector<int> d;\n        for (int j = 0; j < n; ++j)\n            if (i != j)\n                d.push_back(digits[j]);\n        vector<vector<ll> > d_pat = digits_dp(d);\n\n        for (int j = 0; j < n; ++j)\n        {\n            for (int k = 0; k < M; ++k)\n            {\n                ll pat = 0;\n                for (int u = 0; u <= (n - 1) - j; ++u)\n                    (pat += (combi[(n - 1) - j][u] * fact[u] % mod) * fact[j]) %= mod;\n                (pat *= d_pat[j][k]) %= mod;\n\n                (res += ((a[i] * ten_pow[k]) % mod) * pat) %= mod;\n            }\n        }\n    }\n\n    return res;\n}\nint main()\n{\n    fact[0] = 1;\n    for (int i = 1; i < 210; ++i)\n        fact[i] = (fact[i - 1] * i) % mod;\n\n    for (int i = 0; i < 210; ++i)\n    {\n        combi[i][0] = 1;\n        for (int j = 1; j <= i; ++j)\n            combi[i][j] = (combi[i - 1][j] + combi[i - 1][j - 1]) % mod;\n    }\n\n    ten_pow[0] = 1;\n    for (int i = 1; i < M; ++i)\n        ten_pow[i] = (ten_pow[i - 1] * 10) % mod;\n\n\n    int n;\n    vector<int> a, d;\n    cin >> n;\n    for (int i = 0; i < n; ++i)\n    {\n        string s;\n        cin >> s;\n        d.push_back(s.size());\n        a.push_back(to_T<int>(s));\n    }\n\n    ll res = gao(a, d);\n    if (find(all(a), 0) != a.end())\n    {\n        vector<int> _a, _d;\n        for (int i = 0; i < n; ++i)\n        {\n            if (a[i] != 0)\n            {\n                _a.push_back(a[i]);\n                _d.push_back(d[i]);\n            }\n        }\n\n        ll sub = gao(_a, _d);\n        res = (res - sub + mod) % mod;\n    }\n\n    cout << res << endl;\n}"
  },
  {
    "language": "C",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n  \nusing namespace std;\n  \n\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n\n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n  \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void unique(vector<T>& c) { c.erase(unique(c.begin(), c.end()), c.end()); }\ntemplate <class T> void sort_unique(vector<T>& c) { sort(c); unique(c); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n  \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n \nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n  \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n  \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n \nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\n\nbool ok(const vector<int>& a)\n{\n    for (int i = 1; i < a.size(); ++i)\n        if (a[i - 1] >= a[i])\n            return false;\n    return true;\n}\nint main()\n{\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    input(a, n);\n\n    set<vector<int> > visit;\n    typedef pair<int, vector<int> > P;\n    queue<P> q;\n\n    int res = -1;\n\n    visit.insert(a);\n    q.push(P(0, a));\n    while (!q.empty())\n    {\n        int c = q.front().first;\n        vector<int> w = q.front().second;\n        q.pop();\n\n        if (ok(w))\n        {\n            res = c;\n            break;\n        }\n\n        int nc = c + 1;\n    }\n    cout << res << endl;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n    \npublic class Main {\n    public static void main(String[] args) throws IOException {\n        (new Main()).execute();\n    }\n    private long sum = 0;\n    private void execute() throws IOException {\n        Scanner sc = new Scanner(System.in);\n        summary(new StringBuilder(), getArray(sc), new HashSet<Integer>());\n        System.out.println(sum);\n        sc.close();\n    }\n    \n    private void summary(StringBuilder sb, String[] arr, Set<Integer> usedSet) {\n    \tif(usedSet.size() == arr.length) {return;}\n    \tInteger num;\n    \tfor(int i = 0 ; i < arr.length ; i++) {\n    \t\tif(usedSet.size() == 0 && \"0\".equals(arr[i])){continue;}\n\n    \t\tnum = Integer.valueOf(i);\n    \t\tif(!usedSet.contains(num)) {\n    \t\t\tusedSet.add(num);\n    \t\t\tsb.append(arr[i]);\n    \t\t\tsum += Long.parseLong(sb.toString());\n    \t\t\tsummary(sb, arr, usedSet);\n    \t\t\tsb.delete(sb.length() - arr[i].length(), sb.length());\n    \t\t\tusedSet.remove(num);\n    \t\t}\n    \t}\n    }\n\n    private String[] getArray(Scanner sc) {\n    \tString[] result = new String[sc.nextInt()];\n    \tfor(int i = 0 ; i < result.length ; i++) {\n    \t\tresult[i] = sc.next();\n    \t}\n    \treturn result;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tstatic long MOD = 1000_000_000 + 7;\n\n\tvoid run() {\n\t\tsolver();\n\t}\n\n\tlong calc(int[] len, int n) {\n\t\tlong[][][] dp = new long[4][800][200];\n\n\t\tfor (int idx = 0; idx < 4; idx++) {\n\t\t\tif (len[idx] > 0)\n\t\t\t\tlen[idx]--;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t\tdp[idx][0][0] = 1;\n\t\t\tfor (int length = 1; length <= 4; length++) {\n\t\t\t\tfor (int k = 0; k < len[length - 1]; k++) {\n\t\t\t\t\tfor (int i = 799; i >= length; i--) {\n\t\t\t\t\t\tfor (int j = 199; j >= 1; j--) {\n\t\t\t\t\t\t\tif (dp[idx][i - length][j - 1] > 0) {\n\t\t\t\t\t\t\t\tdp[idx][i][j] += dp[idx][i - length][j - 1] * j;\n\t\t\t\t\t\t\t\tdp[idx][i][j] %= MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlen[idx]++;\n\t\t}\n\t\tlong ans = 0;\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 800; j++) {\n\t\t\t\tfor (int k = 0; k < 200 && n - 1 - k >= 0; k++) {\n\t\t\t\t\tif (dp[i][j][k] > 0) {\n\t\t\t\t\t\tans = (ans + dp[i][j][k] * pow10[j] * sum[i] * perm[(n - 1) - k]) % MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tint[] len = new int[4];\n\t\tsum = new long[4];\n\t\tint zero_idx = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\tif (a[i] == 0)\n\t\t\t\tzero_idx = i;\n\t\t\tlen[(a[i] + \"\").length() - 1]++;\n\t\t\tsum[(a[i] + \"\").length() - 1] += a[i];\n\t\t}\n\n\t\tpow10[0] = 1;\n\t\tfor (int i = 1; i < pow10.length; i++) {\n\t\t\tpow10[i] = (pow10[i - 1] * 10) % MOD;\n\t\t}\n\t\tfor (int i = 0; i < 200; i++) {\n\t\t\tlong factorial = 1;\n\t\t\tperm[i] = 1;\n\t\t\tfor (int j = i; j >= 1; j--) {\n\t\t\t\tfactorial = (factorial * j) % MOD;\n\t\t\t\tperm[i] = (perm[i] + factorial) % MOD;\n\t\t\t}\n\t\t}\n\t\tlong ans = calc(len, n);\n\t\tif (zero_idx != -1) {\n\t\t\tlen[0]--;\n\t\t\tans = (ans - calc(len, n - 1) + MOD) % MOD;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tlong[] pow10 = new long[810];\n\tlong[] sum;\n\tlong[] perm = new long[200];\n//\tvoid tr(Object... o) {\n//\t\tSystem.out.println(Arrays.deepToString(o));\n//\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic final int MOD = 1000000007;\n\tstatic int N, total;\n\tstatic long[] pow10 = new long[801];\n\tstatic long[] fact = new long[201];\n\tstatic long[][] binom = new long[201][201];\n\n\tpublic static void main(String[] args) {\n\t\tpow10[0] = fact[0] = 1;\n\t\tfor (int i = 1; i < pow10.length; ++i) {\n\t\t\tpow10[i] = pow10[i - 1] * 10 % MOD;\n\t\t}\n\t\tfor (int i = 1; i < fact.length; ++i) {\n\t\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\t}\n\t\tfor (int i = 0; i <= 200; ++i) {\n\t\t\tbinom[i][i] = binom[i][0] = 1;\n\t\t}\n\t\tfor (int i = 0; i <= 200; ++i) {\n\t\t\tfor (int j = 1; j < i; ++j) {\n\t\t\t\tbinom[i][j] = (binom[i - 1][j] + binom[i - 1][j - 1]) % MOD;\n\t\t\t}\n\t\t}\n\t\tN = sc.nextInt();\n\t\tint[] A = new int[N];\n\t\tint zi = -1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tA[i] = sc.nextInt();\n\t\t\tif (A[i] == 0) zi = i;\n\t\t}\n\t\tint ans = solve(A);\n\t\tif (zi != -1) {\n\t\t\tint[] B = new int[N - 1];\n\t\t\tint idx = 0;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (i == zi) continue;\n\t\t\t\tB[idx++] = A[i];\n\t\t\t}\n\t\t\tans += MOD - solve(B);\n\t\t\tans %= MOD;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic int solve(int[] A) {\n\t\tint[] digits = new int[5];\n\t\tfor (int i = 0; i < A.length; ++i) {\n\t\t\tdigits[(A[i] + \"\").length()]++;\n\t\t}\n\t\ttotal = digits[1] + digits[2] * 2 + digits[3] * 3 + digits[4] * 4;\n\t\tint[][][] comb = new int[5][][];\n\t\tfor (int i = 1; i <= 4; ++i) {\n\t\t\tif (digits[i] > 0) {\n\t\t\t\tcomb[i] = calcComb(digits, i);\n\t\t\t}\n\t\t}\n\t\tlong ret = 0;\n\t\tfor (int i = 0; i < A.length; ++i) {\n\t\t\tint len = (A[i] + \"\").length();\n\t\t\tfor (int j = 0; j < A.length; ++j) {\n\t\t\t\tlong add = 0;\n\t\t\t\tfor (int k = 0; k <= A.length - 1 - j; ++k) {\n\t\t\t\t\tadd += binom[A.length - 1 - j][k] * fact[k];\n\t\t\t\t\tadd %= MOD;\n\t\t\t\t}\n\t\t\t\tadd *= A[i];\n\t\t\t\tadd %= MOD;\n\t\t\t\tadd *= fact[j];\n\t\t\t\tadd %= MOD;\n\t\t\t\tfor (int k = 0; k < total; ++k) {\n\t\t\t\t\tlong addElem = add * pow10[k] % MOD;\n\t\t\t\t\taddElem *= comb[len][j][k];\n\t\t\t\t\taddElem %= MOD;\n\t\t\t\t\tret += addElem;\n\t\t\t\t\tret %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (int) ret;\n\t}\n\n\tstatic int[][] calcComb(int[] digits, int cur) {\n\t\tdigits[cur]--;\n\t\tint[][] dp = new int[N][total + 1]; // dp[i][j] : j digits with i cards\n\t\tdp[0][0] = 1;\n\t\tfor (int i = 1; i <= 4; ++i) {\n\t\t\tfor (int j = 0; j < digits[i]; ++j) {\n\t\t\t\tfor (int k = N - 1; k > 0; --k) {\n\t\t\t\t\tfor (int l = total; l >= i; --l) {\n\t\t\t\t\t\tdp[k][l] += dp[k - 1][l - i];\n\t\t\t\t\t\tif (dp[k][l] >= MOD) dp[k][l] -= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdigits[cur]++;\n\t\treturn dp;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.math.BigInteger;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n    \npublic class Main {\n    public static void main(String[] args) throws IOException {\n        (new Main()).execute();\n    }\n    private long sum = 0;\n    private final BigInteger DIVIDER = new BigInteger(\"1000000007\");\n    private void execute() {\n        Scanner sc = new Scanner(System.in);\n        summary(new StringBuilder(), getArray(sc), new HashSet<String>());\n        System.out.println(sum % 1000000007);\n        sc.close();\n    }\n    \n    private void summary(StringBuilder sb, String[] arr, Set<String> usedSet) {\n    \tif(usedSet.size() == arr.length) {return;}\n    \tfor(int i = 0 ; i < arr.length ; i++) {\n    \t\tif(usedSet.isEmpty() && \"0\".equals(arr[i])){continue;}\n\n    \t\tif(!usedSet.contains(arr[i])) {\n    \t\t\tusedSet.add(arr[i]);\n    \t\t\tsb.append(arr[i]);\n    \t\t\tsum += new BigInteger(sb.toString()).divideAndRemainder(DIVIDER)[1].longValue();\n    \t\t\tsummary(sb, arr, usedSet);\n    \t\t\tsb.delete(sb.length() - arr[i].length(), sb.length());\n    \t\t\tusedSet.remove(arr[i]);\n    \t\t}\n    \t}\n    }\n\n    private String[] getArray(Scanner sc) {\n    \tString[] result = new String[sc.nextInt()];\n    \tfor(int i = 0 ; i < result.length ; i++) {\n    \t\tresult[i] = sc.next();\n    \t}\n    \treturn result;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n    \npublic class Main {\n    public static void main(String[] args) throws IOException {\n        (new Main()).execute();\n    }\n    private int sum = 0;\n    private void execute() throws IOException {\n        Scanner sc = new Scanner(System.in);\n        summary(new StringBuilder(), getArray(sc), new HashSet<Integer>());\n        System.out.println(sum);\n        sc.close();\n    }\n    \n    private void summary(StringBuilder sb, String[] arr, Set<Integer> usedSet) {\n    \tif(usedSet.size() == arr.length) {return;}\n    \tInteger num;\n    \tfor(int i = 0 ; i < arr.length ; i++) {\n    \t\tif(usedSet.size() == 0 && \"0\".equals(arr[i])){continue;}\n\n    \t\tnum = Integer.valueOf(i);\n    \t\tif(!usedSet.contains(num)) {\n    \t\t\tusedSet.add(num);\n    \t\t\tsb.append(arr[i]);\n    \t\t\tsum += Integer.parseInt(sb.toString());\n    \t\t\tsummary(sb, arr, usedSet);\n    \t\t\tsb.delete(sb.length() - arr[i].length(), sb.length());\n    \t\t\tusedSet.remove(num);\n    \t\t}\n    \t}\n    }\n\n    private String[] getArray(Scanner sc) {\n    \tString[] result = new String[sc.nextInt()];\n    \tfor(int i = 0 ; i < result.length ; i++) {\n    \t\tresult[i] = sc.next();\n    \t}\n    \treturn result;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic final int MOD = 1000000007;\n\tstatic int N, total;\n\tstatic long[] pow10 = new long[801];\n\tstatic long[] fact = new long[201];\n\tstatic long[][] binom = new long[201][201];\n\n\tpublic static void main(String[] args) {\n\t\tpow10[0] = fact[0] = 1;\n\t\tfor (int i = 1; i < pow10.length; ++i) {\n\t\t\tpow10[i] = pow10[i - 1] * 10 % MOD;\n\t\t}\n\t\tfor (int i = 1; i < fact.length; ++i) {\n\t\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\t}\n\t\tfor (int i = 0; i <= 200; ++i) {\n\t\t\tbinom[i][i] = binom[i][0] = 1;\n\t\t}\n\t\tfor (int i = 0; i <= 200; ++i) {\n\t\t\tfor (int j = 1; j < i; ++j) {\n\t\t\t\tbinom[i][j] = (binom[i - 1][j] + binom[i - 1][j - 1]) % MOD;\n\t\t\t}\n\t\t}\n\t\tN = sc.nextInt();\n\t\tint[] A = new int[N];\n\t\tint zi = -1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tA[i] = sc.nextInt();\n\t\t\tif (A[i] == 0) zi = i;\n\t\t}\n\t\tint ans = solve(A);\n\t\tif (zi != -1) {\n\t\t\tint[] B = new int[N - 1];\n\t\t\tint idx = 0;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (i == zi) continue;\n\t\t\t\tB[idx++] = A[i];\n\t\t\t}\n\t\t\tans += MOD - solve(B);\n\t\t\tans %= MOD;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic int solve(int[] A) {\n\t\tint[] digits = new int[5];\n\t\tfor (int i = 0; i < A.length; ++i) {\n\t\t\tdigits[(A[i] + \"\").length()]++;\n\t\t}\n\t\ttotal = digits[1] + digits[2] * 2 + digits[3] * 3 + digits[4] * 4;\n\t\tint[][][] comb = new int[5][][];\n\t\tfor (int i = 1; i <= 4; ++i) {\n\t\t\tif (digits[i] > 0) {\n\t\t\t\tcomb[i] = calcComb(digits, i);\n\t\t\t}\n\t\t}\n\t\tlong ret = 0;\n\t\tfor (int i = 0; i < A.length; ++i) {\n\t\t\tint len = (A[i] + \"\").length();\n\t\t\tfor (int j = 0; j < A.length; ++j) {\n\t\t\t\tlong add = 0;\n\t\t\t\tfor (int k = 0; k <= A.length - 1 - j; ++k) {\n\t\t\t\t\tadd += binom[A.length - 1 - j][k] * fact[k];\n\t\t\t\t\tadd %= MOD;\n\t\t\t\t}\n\t\t\t\tadd *= A[i];\n\t\t\t\tadd %= MOD;\n\t\t\t\tadd *= fact[j];\n\t\t\t\tadd %= MOD;\n\t\t\t\tfor (int k = 0; k < total && k <= j * 4; ++k) {\n\t\t\t\t\tlong addElem = add * pow10[k] % MOD;\n\t\t\t\t\taddElem *= comb[len][j][k];\n\t\t\t\t\taddElem %= MOD;\n\t\t\t\t\tret += addElem;\n\t\t\t\t}\n\t\t\t\tret %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn (int) ret;\n\t}\n\n\tstatic int[][] calcComb(int[] digits, int cur) {\n\t\tdigits[cur]--;\n\t\tint[][] dp = new int[N][total + 1]; // dp[i][j] : j digits with i cards\n\t\tdp[0][0] = 1;\n\t\tint sum = 0;\n\t\tint idx = 0;\n\t\tfor (int i = 1; i <= 4; ++i) {\n\t\t\tfor (int j = 0; j < digits[i]; ++j, ++idx) {\n\t\t\t\tsum += i;\n\t\t\t\tfor (int k = idx + 1; k > 0; --k) {\n\t\t\t\t\tfor (int l = sum; l >= i; --l) {\n\t\t\t\t\t\tdp[k][l] += dp[k - 1][l - i];\n\t\t\t\t\t\tif (dp[k][l] >= MOD) dp[k][l] -= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdigits[cur]++;\n\t\treturn dp;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n    \npublic class Main {\n    public static void main(String[] args) throws IOException {\n        (new Main()).execute();\n    }\n    private long sum = 0;\n    private void execute() {\n        Scanner sc = new Scanner(System.in);\n        summary(new StringBuilder(), getArray(sc), new HashSet<String>());\n        System.out.println(sum % 1000000007);\n        sc.close();\n    }\n    \n    private void summary(StringBuilder sb, String[] arr, Set<String> usedSet) {\n    \tif(usedSet.size() == arr.length) {return;}\n    \tfor(int i = 0 ; i < arr.length ; i++) {\n    \t\tif(usedSet.isEmpty() && \"0\".equals(arr[i])){continue;}\n\n    \t\tif(!usedSet.contains(arr[i])) {\n    \t\t\tusedSet.add(arr[i]);\n    \t\t\tsb.append(arr[i]);\n    \t\t\tsum += Long.parseLong(sb.toString());\n    \t\t\tsummary(sb, arr, usedSet);\n    \t\t\tsb.delete(sb.length() - arr[i].length(), sb.length());\n    \t\t\tusedSet.remove(arr[i]);\n    \t\t}\n    \t}\n    }\n\n    private String[] getArray(Scanner sc) {\n    \tString[] result = new String[sc.nextInt()];\n    \tfor(int i = 0 ; i < result.length ; i++) {\n    \t\tresult[i] = sc.next();\n    \t}\n    \treturn result;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tstatic long MOD = 1000_000_000 + 7;\n\n\tvoid run() {\n\t\tsolver();\n\t}\n\n\tlong calc(int[] len, int n) {\n\t\tlong[][][] dp = new long[4][800][200];\n\n\t\tfor (int idx = 0; idx < 4; idx++) {\n\t\t\tif (len[idx] > 0)\n\t\t\t\tlen[idx]--;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t\tdp[idx][0][0] = 1;\n\t\t\tfor (int length = 1; length <= 4; length++) {\n\t\t\t\tfor (int k = 0; k < len[length - 1]; k++) {\n\t\t\t\t\tfor (int i = 799; i >= length; i--) {\n\t\t\t\t\t\tfor (int j = 199; j >= 1; j--) {\n\t\t\t\t\t\t\tif (dp[idx][i - length][j - 1] > 0) {\n\t\t\t\t\t\t\t\tdp[idx][i][j] += dp[idx][i - length][j - 1] * j;\n\t\t\t\t\t\t\t\tdp[idx][i][j] %= MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlen[idx]++;\n\t\t}\n\t\tlong ans = 0;\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 800; j++) {\n\t\t\t\tfor (int k = 0; k < 200 && n - 1 - k >= 0; k++) {\n\t\t\t\t\tif (dp[i][j][k] > 0) {\n\t\t\t\t\t\tans = (ans + dp[i][j][k] * pow10[j] % MOD * sum[i] % MOD * perm[(n - 1) - k]) % MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tint[] len = new int[4];\n\t\tsum = new long[4];\n\t\tint zero_idx = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\tif (a[i] == 0)\n\t\t\t\tzero_idx = i;\n\t\t\tlen[(a[i] + \"\").length() - 1]++;\n\t\t\tsum[(a[i] + \"\").length() - 1] += a[i];\n\t\t}\n\n\t\tpow10[0] = 1;\n\t\tfor (int i = 1; i < pow10.length; i++) {\n\t\t\tpow10[i] = (pow10[i - 1] * 10) % MOD;\n\t\t}\n\t\tfor (int i = 0; i < 200; i++) {\n\t\t\tlong factorial = 1;\n\t\t\tperm[i] = 1;\n\t\t\tfor (int j = i; j >= 1; j--) {\n\t\t\t\tfactorial = (factorial * j) % MOD;\n\t\t\t\tperm[i] = (perm[i] + factorial) % MOD;\n\t\t\t}\n\t\t}\n\n\t\tlong ans = calc(len, n);\n\t\tif (zero_idx != -1) {\n\t\t\tlen[0]--;\n\t\t\tans = (ans - calc(len, n - 1) + MOD) % MOD;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tlong[] pow10 = new long[810];\n\tlong[] sum;\n\tlong[] perm = new long[200];\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.math.BigInteger;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n    \npublic class Main {\n    public static void main(String[] args) throws IOException {\n        (new Main()).execute();\n    }\n    private BigInteger sum = new BigInteger(\"0\");\n    private void execute() {\n        Scanner sc = new Scanner(System.in);\n        summary(new StringBuilder(), getArray(sc), new HashSet<String>());\n        System.out.println(sum.divideAndRemainder(new BigInteger(\"1000000007\"))[1]);\n        sc.close();\n    }\n    \n    private void summary(StringBuilder sb, String[] arr, Set<String> usedSet) {\n    \tif(usedSet.size() == arr.length) {return;}\n    \tfor(int i = 0 ; i < arr.length ; i++) {\n    \t\tif(usedSet.isEmpty() && \"0\".equals(arr[i])){continue;}\n\n    \t\tif(!usedSet.contains(arr[i])) {\n    \t\t\tusedSet.add(arr[i]);\n    \t\t\tsb.append(arr[i]);\n    \t\t\tsum = sum.add(new BigInteger(sb.toString()));\n    \t\t\tsummary(sb, arr, usedSet);\n    \t\t\tsb.delete(sb.length() - arr[i].length(), sb.length());\n    \t\t\tusedSet.remove(arr[i]);\n    \t\t}\n    \t}\n    }\n\n    private String[] getArray(Scanner sc) {\n    \tString[] result = new String[sc.nextInt()];\n    \tfor(int i = 0 ; i < result.length ; i++) {\n    \t\tresult[i] = sc.next();\n    \t}\n    \treturn result;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic final int MOD = 1000000007;\n\tstatic int N, total;\n\tstatic long[] pow10 = new long[801];\n\tstatic long[] fact = new long[201];\n\tstatic long[][] binom = new long[201][201];\n\n\tpublic static void main(String[] args) {\n\t\tpow10[0] = fact[0] = 1;\n\t\tfor (int i = 1; i < pow10.length; ++i) {\n\t\t\tpow10[i] = pow10[i - 1] * 10 % MOD;\n\t\t}\n\t\tfor (int i = 1; i < fact.length; ++i) {\n\t\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\t}\n\t\tfor (int i = 0; i <= 200; ++i) {\n\t\t\tbinom[i][i] = binom[i][0] = 1;\n\t\t}\n\t\tfor (int i = 0; i <= 200; ++i) {\n\t\t\tfor (int j = 1; j < i; ++j) {\n\t\t\t\tbinom[i][j] = (binom[i - 1][j] + binom[i - 1][j - 1]) % MOD;\n\t\t\t}\n\t\t}\n\t\tN = sc.nextInt();\n\t\tint[] A = new int[N];\n\t\tint zi = -1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tA[i] = sc.nextInt();\n\t\t\tif (A[i] == 0) zi = i;\n\t\t}\n\t\tint ans = solve(A);\n\t\tif (zi != -1) {\n\t\t\tint[] B = new int[N - 1];\n\t\t\tint idx = 0;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (i == zi) continue;\n\t\t\t\tB[idx++] = A[i];\n\t\t\t}\n\t\t\tans += MOD - solve(B);\n\t\t\tans %= MOD;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic int solve(int[] A) {\n\t\tint[] digits = new int[5];\n\t\tfor (int i = 0; i < A.length; ++i) {\n\t\t\tdigits[(A[i] + \"\").length()]++;\n\t\t}\n\t\ttotal = digits[1] + digits[2] * 2 + digits[3] * 3 + digits[4] * 4;\n\t\tint[][][] comb = new int[5][][];\n\t\tfor (int i = 1; i <= 4; ++i) {\n\t\t\tif (digits[i] > 0) {\n\t\t\t\tcomb[i] = calcComb(digits, i);\n\t\t\t}\n\t\t}\n\t\tlong ret = 0;\n\t\tfor (int i = 0; i < A.length; ++i) {\n\t\t\tint len = (A[i] + \"\").length();\n\t\t\tfor (int j = 0; j < A.length; ++j) {\n\t\t\t\tlong add = 0;\n\t\t\t\tfor (int k = 0; k <= A.length - 1 - j; ++k) {\n\t\t\t\t\tadd += binom[A.length - 1 - j][k] * fact[k];\n\t\t\t\t\tadd %= MOD;\n\t\t\t\t}\n\t\t\t\tadd *= A[i];\n\t\t\t\tadd %= MOD;\n\t\t\t\tadd *= fact[j];\n\t\t\t\tadd %= MOD;\n\t\t\t\tfor (int k = 0; k < total && k <= j * 4; ++k) {\n\t\t\t\t\tlong addElem = add * pow10[k] % MOD;\n\t\t\t\t\taddElem *= comb[len][j][k];\n\t\t\t\t\taddElem %= MOD;\n\t\t\t\t\tret += addElem;\n\t\t\t\t}\n\t\t\t\tret %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn (int) ret;\n\t}\n\n\tstatic int[][] calcComb(int[] digits, int cur) {\n\t\tdigits[cur]--;\n\t\tint[][] dp = new int[N][total + 1]; // dp[i][j] : j digits with i cards\n\t\tdp[0][0] = 1;\n\t\tfor (int i = 1; i <= 4; ++i) {\n\t\t\tfor (int j = 0; j < digits[i]; ++j) {\n\t\t\t\tfor (int k = N - 1; k > 0; --k) {\n\t\t\t\t\tfor (int l = total; l >= i; --l) {\n\t\t\t\t\t\tdp[k][l] += dp[k - 1][l - i];\n\t\t\t\t\t\tif (dp[k][l] >= MOD) dp[k][l] -= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdigits[cur]++;\n\t\treturn dp;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n    \n    int n;\n    String[] numbers;\n    int ans;\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    n = sc.nextInt();\n\t    numbers = new String[n];\n\t    for(int i=0; i<n; i++)\n\t\tnumbers[i] = sc.next();\n\t    ans = 0;\n\t    solve(0, \"\");\n\t    System.out.println(ans/2);\n\t}\n    }\n\n    void solve(int level, String sum){\n\tif(level==n){\n\t    if(sum.length()>0 && !sum.substring(0, 1).equals(\"0\")){\n\t\t//System.out.println(\"*\"+sum);\n\t\tans =  (ans+Integer.parseInt(sum))% 1000000007;\n\t    }\n\t    return;\n\t}\n\tsolve(level+1, sum);\n\n\tsolve(level+1, numbers[level]+sum);\n\tfor(int i=1; i<sum.length(); i++){\n\t    String s = sum.substring(0, i)+numbers[level]+sum.substring(i);\n\t    solve(level+1, s);\n\t}\n\tsolve(level+1, sum+numbers[level]);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic final int MOD = 1000000007;\n\tstatic int N, total;\n\tstatic long[] pow10 = new long[801];\n\tstatic long[] fact = new long[201];\n\tstatic long[][] binom = new long[201][201];\n\n\tpublic static void main(String[] args) {\n\t\tpow10[0] = fact[0] = 1;\n\t\tfor (int i = 1; i < pow10.length; ++i) {\n\t\t\tpow10[i] = pow10[i - 1] * 10 % MOD;\n\t\t}\n\t\tfor (int i = 1; i < fact.length; ++i) {\n\t\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\t}\n\t\tfor (int i = 0; i <= 200; ++i) {\n\t\t\tbinom[i][i] = binom[i][0] = 1;\n\t\t}\n\t\tfor (int i = 0; i <= 200; ++i) {\n\t\t\tfor (int j = 1; j < i; ++j) {\n\t\t\t\tbinom[i][j] = (binom[i - 1][j] + binom[i - 1][j - 1]) % MOD;\n\t\t\t}\n\t\t}\n\t\tN = sc.nextInt();\n\t\tint[] A = new int[N];\n\t\tint zi = -1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tA[i] = sc.nextInt();\n\t\t\tif (A[i] == 0) zi = i;\n\t\t}\n\t\tint ans = solve(A);\n\t\tif (zi != -1) {\n\t\t\tint[] B = new int[N - 1];\n\t\t\tint idx = 0;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (i == zi) continue;\n\t\t\t\tB[idx++] = A[i];\n\t\t\t}\n\t\t\tans += MOD - solve(B);\n\t\t\tans %= MOD;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic int solve(int[] A) {\n\t\tint[] digits = new int[5];\n\t\tfor (int i = 0; i < A.length; ++i) {\n\t\t\tdigits[(A[i] + \"\").length()]++;\n\t\t}\n\t\ttotal = digits[1] + digits[2] * 2 + digits[3] * 3 + digits[4] * 4;\n\t\tint[][][] comb = new int[5][][];\n\t\tfor (int i = 1; i <= 4; ++i) {\n\t\t\tif (digits[i] > 0) {\n\t\t\t\tcomb[i] = calcComb(digits, i);\n\t\t\t}\n\t\t}\n\t\tlong ret = 0;\n\t\tfor (int i = 0; i < A.length; ++i) {\n\t\t\tint len = (A[i] + \"\").length();\n\t\t\tfor (int j = 0; j < A.length; ++j) {\n\t\t\t\tlong add = 0;\n\t\t\t\tfor (int k = 0; k <= A.length - 1 - j; ++k) {\n\t\t\t\t\tadd += binom[A.length - 1 - j][k] * fact[k];\n\t\t\t\t\tadd %= MOD;\n\t\t\t\t}\n\t\t\t\tadd *= A[i];\n\t\t\t\tadd %= MOD;\n\t\t\t\tadd *= fact[j];\n\t\t\t\tadd %= MOD;\n\t\t\t\tfor (int k = 0; k < total && k <= j * 4; ++k) {\n\t\t\t\t\tif (comb[len][j][k] == 0) continue;\n\t\t\t\t\tlong addElem = add * pow10[k] % MOD;\n\t\t\t\t\taddElem *= comb[len][j][k];\n\t\t\t\t\taddElem %= MOD;\n\t\t\t\t\tret += addElem;\n\t\t\t\t}\n\t\t\t\tret %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn (int) ret;\n\t}\n\n\tstatic int[][] calcComb(int[] digits, int cur) {\n\t\tdigits[cur]--;\n\t\tint[][] dp = new int[N][total + 1]; // dp[i][j] : j digits with i cards\n\t\tdp[0][0] = 1;\n\t\tint sum = 0;\n\t\tint idx = 0;\n\t\tfor (int i = 1; i <= 4; ++i) {\n\t\t\tfor (int j = 0; j < digits[i]; ++j, ++idx) {\n\t\t\t\tsum += i;\n\t\t\t\tfor (int k = idx + 1; k > 0; --k) {\n\t\t\t\t\tfor (int l = sum; l >= i; --l) {\n\t\t\t\t\t\tdp[k][l] += dp[k - 1][l - i];\n\t\t\t\t\t\tif (dp[k][l] >= MOD) dp[k][l] -= MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdigits[cur]++;\n\t\treturn dp;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tstatic long MOD = 1000_000_000 + 7;\n\n\tvoid run() {\n\t\tsolver();\n\t}\n\n\tlong calc(int[] len, int n) {\n\t\tlong[][][] dp = new long[4][800][200];\n\n\t\tfor (int idx = 0; idx < 4; idx++) {\n\t\t\tif (len[idx] > 0)\n\t\t\t\tlen[idx]--;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t\tdp[idx][0][0] = 1;\n\t\t\tfor (int length = 1; length <= 4; length++) {\n\t\t\t\tfor (int k = 0; k < len[length - 1]; k++) {\n\t\t\t\t\tfor (int i = 799; i >= length; i--) {\n\t\t\t\t\t\tfor (int j = 199; j >= 1; j--) {\n\t\t\t\t\t\t\tif (dp[idx][i - length][j - 1] > 0) {\n\t\t\t\t\t\t\t\tdp[idx][i][j] += dp[idx][i - length][j - 1] * j;\n\t\t\t\t\t\t\t\tdp[idx][i][j] %= MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlen[idx]++;\n\t\t}\n\t\tlong ans = 0;\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 800; j++) {\n\t\t\t\tfor (int k = 0; k < 200 && n - 1 - k >= 0; k++) {\n\t\t\t\t\tif (dp[i][j][k] > 0) {\n\t\t\t\t\t\tans = (ans + dp[i][j][k] * pow10[j] % MOD * sum[i] % MOD * perm[(n - 1) - k]) % MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tint[] len = new int[4];\n\t\tsum = new long[4];\n\t\tint zero_idx = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\tif (a[i] == 0)\n\t\t\t\tzero_idx = i;\n\t\t\tlen[(a[i] + \"\").length() - 1]++;\n\t\t\tsum[(a[i] + \"\").length() - 1] += a[i];\n\t\t}\n\n\t\tpow10[0] = 1;\n\t\tfor (int i = 1; i < pow10.length; i++) {\n\t\t\tpow10[i] = (pow10[i - 1] * 10) % MOD;\n\t\t}\n\t\tfor (int i = 0; i < 200; i++) {\n\t\t\tlong factorial = 1;\n\t\t\tperm[i] = 1;\n\t\t\tfor (int j = i; j >= 1; j--) {\n\t\t\t\tfactorial = (factorial * j) % MOD;\n\t\t\t\tperm[i] = (perm[i] + factorial) % MOD;\n\t\t\t}\n\t\t}\n\n\t\tlong ans = calc(len, n);\n\t\tif (zero_idx != -1) {\n\t\t\tlen[0]--;\n\t\t\tans = (ans - calc(len, n - 1) + MOD) % MOD;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tlong[] pow10 = new long[810];\n\tlong[] sum;\n\tlong[] perm = new long[200];\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tstatic long MOD = 1000_000_000 + 7;\n\n\tvoid run() {\n\t\tsolver();\n\t}\n\n\tlong calc(int[] len) {\n\t\tlong[][][] dp = new long[4][800][200];\n\n\t\tfor (int idx = 0; idx < 4; idx++) {\n\t\t\tif (len[idx] > 0)\n\t\t\t\tlen[idx]--;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t\tdp[idx][0][0] = 1;\n\t\t\tfor (int length = 1; length <= 4; length++) {\n\t\t\t\tfor (int k = 0; k < len[length - 1]; k++) {\n\t\t\t\t\tfor (int i = 799; i >= length; i--) {\n\t\t\t\t\t\tfor (int j = 199; j >= 1; j--) {\n\t\t\t\t\t\t\tif (dp[idx][i - length][j - 1] > 0) {\n\t\t\t\t\t\t\t\tdp[idx][i][j] += dp[idx][i - length][j - 1] * j;\n\t\t\t\t\t\t\t\tdp[idx][i][j] %= MOD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlen[idx]++;\n\t\t}\n\t\tlong ans = 0;\n\n\t\t// dp[i][j][k] ??????i+1?????????????????????????????????k????????????????????£?????¨???????????????j?????????????????????????????°\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tfor (int j = 0; j < 800; j++) {\n\t\t\t\tfor (int k = 0; k < 200 && n - 1 - k >= 0; k++) {\n\t\t\t\t\tif (dp[i][j][k] > 0) {\n\t\t\t\t\t\ttr(i, j, k, dp[i][j][k], (n - 1 - k), perm[n - 1 - k]);\n\t\t\t\t\t\t// System.out.println(dp[i][j][k] * sum[i] * pow10[j]);\n\t\t\t\t\t\t// ans += dp[i][j][k] * sum[i] * pow10[j];\n\t\t\t\t\t\tans = (ans + dp[i][j][k] * pow10[j] * sum[i] * perm[(n - 1) - k]) % MOD;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tint n;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tint[] len = new int[4];\n\t\tsum = new long[4];\n\t\tint zero_idx = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = sc.nextInt();\n\t\t\tif (a[i] == 0)\n\t\t\t\tzero_idx = i;\n\t\t\tlen[(a[i] + \"\").length() - 1]++;\n\t\t\tsum[(a[i] + \"\").length() - 1] += a[i];\n\t\t}\n\n\t\tpow10[0] = 1;\n\t\tfor (int i = 1; i < pow10.length; i++) {\n\t\t\tpow10[i] = (pow10[i - 1] * 10) % MOD;\n\t\t}\n\t\tfor (int i = 0; i < 200; i++) {\n\t\t\tlong factorial = 1;\n\t\t\tperm[i] = 1;\n\t\t\tfor (int j = i; j >= 1; j--) {\n\t\t\t\tfactorial = (factorial * j) % MOD;\n\t\t\t\tperm[i] = (perm[i] + factorial) % MOD;\n\t\t\t}\n\t\t}\n\n\t\t// leading 0 ????????????\n\t\tlong ans = calc(len);\n\t\tif (zero_idx != -1) {\n\t\t\tlen[0]--;\n\t\t\tans = (ans - calc(len) + MOD) % MOD;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tlong[] pow10 = new long[810];\n\tlong[] sum;\n\tlong[] perm = new long[200];\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Threading;\nusing System.Text;\nusing System.Diagnostics;\nusing static util;\nusing P = pair<int, int>;\n\nclass Program {\n    static void Main(string[] args) {\n        var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n        var solver = new Solver(sw);\n        // var t = new Thread(solver.solve, 1 << 26); // 64 MB\n        // t.Start();\n        // t.Join();\n        solver.solve();\n        sw.Flush();\n    }\n}\n\nclass Solver {\n    StreamWriter sw;\n    Scan sc;\n    void Prt(string a) => sw.WriteLine(a);\n    void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    void Prt(params object[] a) => Prt(string.Join(\" \", a));\n    public Solver(StreamWriter sw) {\n        this.sw = sw;\n        this.sc = new Scan();\n    }\n    long solve(int n, int[] a) {\n        var b = new int[n];\n        var c = new long[n + 1];\n        var dp = new long[n + 1];\n        dp[0] = 1;\n        c[0] = 1;\n        for (int i = 0; i < n; i++)\n        {\n            b[i] = 10;\n            while (b[i] <= a[i]) b[i] *= 10;\n            for (int j = n - 1; j >= 0 ; j--)\n            {\n                dp[j + 1] = (dp[j + 1] + dp[j] * b[i] % M * (j + 1)) % M;\n            }\n            c[i + 1] = (c[i] * (i + 1) + 1) % M;\n        }\n        long ans = 0;\n        for (int i = 0; i < n; i++)\n        {\n            var d = dp.copy();\n            for (int j = 0; j < n; j++)\n            {\n                ans = (ans + a[i] * d[j] % M * c[n - j - 1]) % M;\n                d[j + 1] = (d[j + 1] + M - d[j] * b[i] % M * (j + 1) % M) % M;\n            }\n        }\n        return ans;\n    }\n\n    public void solve() {\n        int n = sc.Int;\n        var a = new int[n];\n        for (int i = 0; i < n; i++)\n        {\n            a[i] = sc.Int;\n        }\n        long ans = solve(n, a);\n        if (a.Any(x => x == 0)) {\n            Array.Sort(a);\n            Array.Reverse(a);\n            ans = (ans + M - solve(n - 1, a)) % M;\n        }\n        Prt(ans);\n    }\n}\n\nclass pair<T, U> : IComparable<pair<T, U>> {\n    public T v1;\n    public U v2;\n    public pair() : this(default(T), default(U)) {}\n    public pair(T v1, U v2) { this.v1 = v1; this.v2 = v2; }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) { a = v1; b = v2; }\n}\nstatic class util {\n    public static readonly int M = 1000000007;\n    // public static readonly int M = 998244353;\n    public static readonly long LM = 1L << 60;\n    public static readonly double eps = 1e-11;\n    public static void DBG(string a) => Console.Error.WriteLine(a);\n    public static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    public static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    public static void Assert(bool cond) { if (!cond) throw new Exception(); }\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static int CompareList<T>(IList<T> a, IList<T> b) where T : IComparable<T> {\n        for (int i = 0; i < a.Count && i < b.Count; i++)\n            if (a[i].CompareTo(b[i]) != 0) return a[i].CompareTo(b[i]);\n        return a.Count.CompareTo(b.Count);\n    }\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    static readonly int[] dd = { 0, 1, 0, -1 };\n    // static readonly string dstring = \"RDLU\";\n    public static P[] adjacents(int i, int j)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1])).ToArray();\n    public static P[] adjacents(int i, int j, int h, int w)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1]))\n                                         .Where(p => inside(p.v1, p.v2, h, w)).ToArray();\n    public static P[] adjacents(this P p) => adjacents(p.v1, p.v2);\n    public static P[] adjacents(this P p, int h, int w) => adjacents(p.v1, p.v2, h, w);\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static T[] inv<T>(this Dictionary<T, int> dic) {\n        var res = new T[dic.Count];\n        foreach (var item in dic) res[item.Value] = item.Key;\n        return res;\n    }\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\n\nclass Scan {\n    StreamReader sr;\n    public Scan() { sr = new StreamReader(Console.OpenStandardInput()); }\n    public Scan(string path) { sr = new StreamReader(path); }\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => sr.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P => Pair<int, int>();\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nMOD = 1_000_000_007\n\ndef fact(n)\n\treturn 1 if n == 0\n\tn * fact(n-1)\nend\n\ndef all_perm(n)\n\treturn 1 if n == 0\n\t1 + (0..n-1).map {|k| fact(n) / fact(k)}.inject(:+)\nend\n\nn = gets.to_i\ncards = (1..n).map { gets.to_i }.sort\nsum = 0\n\n(0..n-1).each do |i|\n\tsizes = cards.map {|x| x.to_s.size}\n\tsizes.delete_at(i)\n\th = { [0, 0] => 1 }\n\tsizes.each do |s|\n\t\tnew_h = Hash.new(0)\n\t\th.each do |(k, l), c|\n\t\t\tnew_h[[k, l]] += c\n\t\t\tnew_h[[k+1, l+s]] += c\n\t\tend\n\t\th = new_h\n\tend\n\n\tx = cards[i]\n\th.each do |(k, l), c|\n\t\tsum += (x * 10 ** l) * c * fact(k) * all_perm(n - 1 - k) % MOD\n\tend\nend\n\nif cards[0] > 0 || n == 1\n\tputs sum\n\texit\nend\n\ncards.shift\nn -= 1\n(0..n-1).each do |i|\n\tsizes = cards.map {|x| x.to_s.size}\n\tsizes.delete_at(i)\n\th = { [0, 0] => 1 }\n\tsizes.each do |s|\n\t\tnew_h = Hash.new(0)\n\t\th.each do |(k, l), c|\n\t\t\tnew_h[[k, l]] += c\n\t\t\tnew_h[[k+1, l+s]] += c\n\t\tend\n\t\th = new_h\n\tend\n\n\tx = cards[i]\n\th.each do |(k, l), c|\n\t\tsum -= (x * 10 ** l) * c * fact(k) * all_perm(n - 1 - k) % MOD\n\tend\nend\n\nputs sum % MOD"
  },
  {
    "language": "Ruby",
    "code": "module Memoizable\n\tdef memoize(name)\n\t\toriginal = \"__original_#{name}__\"\n\t\t([Class, Module].include?(self.class) ? self : self.class).class_eval {\n\t\t\talias_method(original, name)\n\t\t\tprivate(original)\n\t\t\tcache = {}\n\t\t\tdefine_method(name){|*args|\n\t\t\t\tcache[args] ||= send(original, *args)\n\t\t\t}\n\t\t}\n\tend \nend\ninclude Memoizable\n\nMOD = 1_000_000_007\n\ndef fact(n)\n\treturn 1 if n == 0\n\tn * fact(n-1)\nend\n\ndef all_perm(n)\n\treturn 1 if n == 0\n\t1 + (0..n-1).map {|k| fact(n) / fact(k)}.inject(:+)\nend\n\ndef f(sizes)\n\th = { [0, 0] => 1 }\n\tsizes.each do |s|\n\t\tnew_h = Hash.new(0)\n\t\th.each do |(k, l), c|\n\t\t\tnew_h[[k, l]] += c\n\t\t\tnew_h[[k+1, l+s]] += c\n\t\tend\n\t\th = new_h\n\tend\n\n\ts = 0\n\th.each do |(k, l), c|\n\t\ts += (10 ** l) * c * fact(k) * all_perm(sizes.size - k)\n\tend\n\ts\nend\n\nmemoize :fact\nmemoize :all_perm\nmemoize :f\n\nn = gets.to_i\ncards = (1..n).map { gets.to_i }.sort\nsum = 0\n\n(0..n-1).each do |i|\n\tsizes = cards.map {|x| x.to_s.size}\n\tsizes.delete_at(i)\n\tx = cards[i]\n\tsum += x * f(sizes)\nend\n\nif cards[0] > 0 || n == 1\n\tputs sum % MOD\n\texit\nend\n\ncards.shift\nn -= 1\n(0..n-1).each do |i|\n\tsizes = cards.map {|x| x.to_s.size}\n\tsizes.delete_at(i)\n\tx = cards[i]\n\tsum -= x * f(sizes)\nend\n\nputs sum % MOD"
  },
  {
    "language": "Ruby",
    "code": "module Memoizable\n\tdef memoize(name)\n\t\toriginal = \"__original_#{name}__\"\n\t\t([Class, Module].include?(self.class) ? self : self.class).class_eval {\n\t\t\talias_method(original, name)\n\t\t\tprivate(original)\n\t\t\tcache = {}\n\t\t\tdefine_method(name){|*args|\n\t\t\t\tcache[args] ||= send(original, *args)\n\t\t\t}\n\t\t}\n\tend \nend\ninclude Memoizable\n\nMOD = 1_000_000_007\n\ndef fact(n)\n\treturn 1 if n == 0\n\tn * fact(n-1)\nend\n\ndef all_perm(n)\n\treturn 1 if n == 0\n\t1 + (0..n-1).map {|k| fact(n) / fact(k)}.inject(:+)\nend\n\n$save = {}\ndef f(sizes, k)\n\th = { [0, 0] => 1 }\n\tsizes.reverse.each.with_index do |s, i|\n\t\tnew_h = Hash.new(0)\n\t\th.each do |(k, l), c|\n\t\t\tnew_h[[k, l]] += c\n\t\t\tnew_h[[k+1, l+s]] += c\n\t\tend\n\t\th = new_h\n\t\t$save[k] = Marshal.load(Marshal.dump(h)) if i == sizes.size - 2\n\tend\n\n\ts = 0\n\th.each do |(k, l), c|\n\t\ts += (10 ** l) * c * fact(k) * all_perm(sizes.size - k)\n\tend\n\ts\nend\n\nmemoize :fact\nmemoize :all_perm\nmemoize :f\n\nn = gets.to_i\ncards = (1..n).map { gets.to_i }.sort\nsum = 0\n\nsize_count = Hash.new(0)\nsum_per_size = Hash.new(0)\ncards.each do |x|\n\tk = x.to_s.size\n\tsize_count[k] += 1\n\tsum_per_size[k] += x\nend\n\n(1..4).each do |i|\n\tsizes = (1..4).map {|j| [j] * [size_count[j] - (j == i ? 1 : 0), 0].max}.flatten\n\tsum += sum_per_size[i] * f(sizes, i)\nend\n\nif cards[0] > 0 || n == 1\n\tputs sum % MOD\n\texit\nend\n\nn -= 1\n(1..4).each do |i|\n\tnext if size_count[i] == 0\n\t($save[i] || []).each do |(k, l), c|\n\t\tsum -= (sum_per_size[i] * 10 ** l) * c * fact(k) * all_perm(n - 1 - k)\n\tend\nend\n\nputs sum % MOD"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nMOD = 1_000_000_007\n\ndef fact(n)\n\treturn 1 if n == 0\n\tn * fact(n-1)\nend\n\ndef all_perm(n)\n\treturn 1 if n == 0\n\t1 + (0..n-1).map {|k| fact(n) / fact(k)}.inject(:+)\nend\n\nn = gets.to_i\ncards = (1..n).map { gets.to_i }.sort\nsum = 0\n\n(0..n-1).each do |i|\n\tsizes = cards.map {|x| x.to_s.size}\n\tsizes.delete_at(i)\n\th = { [0, 0] => 1 }\n\tsizes.each do |s|\n\t\tnew_h = Hash.new(0)\n\t\th.each do |(k, l), c|\n\t\t\tnew_h[[k, l]] += c\n\t\t\tnew_h[[k+1, l+s]] += c\n\t\tend\n\t\th = new_h\n\tend\n\n\tx = cards[i]\n\th.each do |(k, l), c|\n\t\tsum += (x * 10 ** l) * c * fact(k) * all_perm(n - 1 - k) % MOD\n\tend\nend\n\nif cards[0] > 0 || n == 1\n\tputs sum % MOD\n\texit\nend\n\ncards.shift\nn -= 1\n(0..n-1).each do |i|\n\tsizes = cards.map {|x| x.to_s.size}\n\tsizes.delete_at(i)\n\th = { [0, 0] => 1 }\n\tsizes.each do |s|\n\t\tnew_h = Hash.new(0)\n\t\th.each do |(k, l), c|\n\t\t\tnew_h[[k, l]] += c\n\t\t\tnew_h[[k+1, l+s]] += c\n\t\tend\n\t\th = new_h\n\tend\n\n\tx = cards[i]\n\th.each do |(k, l), c|\n\t\tsum -= (x * 10 ** l) * c * fact(k) * all_perm(n - 1 - k) % MOD\n\tend\nend\n\nputs sum % MOD"
  },
  {
    "language": "Ruby",
    "code": "module Memoizable\n\tdef memoize(name)\n\t\toriginal = \"__original_#{name}__\"\n\t\t([Class, Module].include?(self.class) ? self : self.class).class_eval {\n\t\t\talias_method(original, name)\n\t\t\tprivate(original)\n\t\t\tcache = {}\n\t\t\tdefine_method(name){|*args|\n\t\t\t\tcache[args] ||= send(original, *args)\n\t\t\t}\n\t\t}\n\tend \nend\ninclude Memoizable\n\nMOD = 1_000_000_007\n\ndef fact(n)\n\treturn 1 if n == 0\n\tn * fact(n-1)\nend\n\ndef all_perm(n)\n\treturn 1 if n == 0\n\t1 + (0..n-1).map {|k| fact(n) / fact(k)}.inject(:+)\nend\n\n$save = []\ndef f(sizes)\n\th = { [0, 0] => 1 }\n\tsizes.reverse.each.with_index do |s, i|\n\t\tnew_h = Hash.new(0)\n\t\th.each do |(k, l), c|\n\t\t\tnew_h[[k, l]] += c\n\t\t\tnew_h[[k+1, l+s]] += c\n\t\tend\n\t\th = new_h\n\t\t$save << h.dup if i == sizes.size - 2\n\tend\n\n\ts = 0\n\th.each do |(k, l), c|\n\t\ts += (10 ** l) * c * fact(k) * all_perm(sizes.size - k)\n\tend\n\ts\nend\n\nmemoize :fact\nmemoize :all_perm\nmemoize :f\n\nn = gets.to_i\ncards = (1..n).map { gets.to_i }.sort\nsum = 0\n\nsize_count = Hash.new(0)\nsum_per_size = Hash.new(0)\ncards.each do |x|\n\tk = x.to_s.size\n\tsize_count[k] += 1\n\tsum_per_size[k] += x\nend\n\n(1..4).each do |i|\n\tp i\n\tsizes = (1..4).map {|j| [j] * [size_count[j] - (j == i ? 1 : 0), 0].max}.flatten\n\tsum += sum_per_size[i] * f(sizes)\nend\n\nif cards[0] > 0 || n == 1\n\tputs sum % MOD\n\texit\nend\n\nsize_count[1] -= 1\n(1..4).each do |i|\n\tsizes = (1..4).map {|j| [j] * [size_count[j] - (j == i ? 1 : 0), 0].max}.flatten\n\ts = 0\n\t$save[i-1].each do |(k, l), c|\n\t\tsum -= (sum_per_size[i] * 10 ** l) * c * fact(k) * all_perm(sizes.size - k)\n\tend\nend\n\nputs sum % MOD"
  },
  {
    "language": "Ruby",
    "code": "module Memoizable\n\tdef memoize(name)\n\t\toriginal = \"__original_#{name}__\"\n\t\t([Class, Module].include?(self.class) ? self : self.class).class_eval {\n\t\t\talias_method(original, name)\n\t\t\tprivate(original)\n\t\t\tcache = {}\n\t\t\tdefine_method(name){|*args|\n\t\t\t\tcache[args] ||= send(original, *args)\n\t\t\t}\n\t\t}\n\tend \nend\ninclude Memoizable\n\nMOD = 1_000_000_007\n\ndef fact(n)\n\treturn 1 if n == 0\n\tn * fact(n-1)\nend\n\ndef all_perm(n)\n\treturn 1 if n == 0\n\t1 + (0..n-1).map {|k| fact(n) / fact(k)}.inject(:+)\nend\n\ndef f(sizes)\n\th = { [0, 0] => 1 }\n\tsizes.reverse.each do |s|\n\t\tnew_h = Hash.new(0)\n\t\th.each do |(k, l), c|\n\t\t\tnew_h[[k, l]] += c\n\t\t\tnew_h[[k+1, l+s]] += c\n\t\tend\n\t\th = new_h\n\tend\n\n\ts = 0\n\th.each do |(k, l), c|\n\t\ts += (10 ** l) * c * fact(k) * all_perm(sizes.size - k)\n\tend\n\ts\nend\n\nmemoize :fact\nmemoize :all_perm\nmemoize :f\n\nn = gets.to_i\ncards = (1..n).map { gets.to_i }.sort\nsum = 0\n\nsize_count = Hash.new(0)\nsum_per_size = Hash.new(0)\ncards.each do |x|\n\tk = x.to_s.size\n\tsize_count[k] += 1\n\tsum_per_size[k] += x\nend\n\n(1..4).each do |i|\n\tsizes = (1..4).map {|j| [j] * [size_count[j] - (j == i ? 1 : 0), 0].max}.flatten\n\tsum += sum_per_size[i] * f(sizes)\nend\n\nif cards[0] > 0 || n == 1\n\tputs sum % MOD\n\texit\nend\n\nsize_count[1] -= 1\n(1..4).each do |i|\n\tsizes = (1..4).map {|j| [j] * [size_count[j] - (j == i ? 1 : 0), 0].max}.flatten\n\tsum -= sum_per_size[i] * f(sizes)\nend\n\nputs sum % MOD"
  },
  {
    "language": "Ruby",
    "code": "module Memoizable\n\tdef memoize(name)\n\t\toriginal = \"__original_#{name}__\"\n\t\t([Class, Module].include?(self.class) ? self : self.class).class_eval {\n\t\t\talias_method(original, name)\n\t\t\tprivate(original)\n\t\t\tcache = {}\n\t\t\tdefine_method(name){|*args|\n\t\t\t\tcache[args] ||= send(original, *args)\n\t\t\t}\n\t\t}\n\tend \nend\ninclude Memoizable\n\nMOD = 1_000_000_007\n\ndef fact(n)\n\treturn 1 if n == 0\n\tn * fact(n-1)\nend\n\ndef all_perm(n)\n\treturn 1 if n == 0\n\t1 + (0..n-1).map {|k| fact(n) / fact(k)}.inject(:+)\nend\n\ndef f(sizes)\n\th = { [0, 0] => 1 }\n\tsizes.reverse.each do |s|\n\t\tnew_h = Hash.new(0)\n\t\th.each do |(k, l), c|\n\t\t\tnew_h[[k, l]] += c\n\t\t\tnew_h[[k+1, l+s]] += c\n\t\tend\n\t\th = new_h\n\tend\n\n\ts = 0\n\th.each do |(k, l), c|\n\t\ts += (10 ** l) * c * fact(k) * all_perm(sizes.size - k)\n\tend\n\ts\nend\n\nmemoize :fact\nmemoize :all_perm\nmemoize :f\n\nn = gets.to_i\ncards = (1..n).map { gets.to_i }.sort\nsum = 0\n\nsize_count = Hash.new(0)\nsum_per_size = Hash.new(0)\ncards.each do |x|\n\tk = x.to_s.size\n\tsize_count[k] += 1\n\tsum_per_size[k] += x\nend\n\n(1..4).each do |i|\n\tsizes = (1..4).map {|j| [j] * (size_count[j] - (j == i ? 1 : 0))}.flatten\n\tsum += sum_per_size[i] * f(sizes)\nend\n\nif cards[0] > 0 || n == 1\n\tputs sum % MOD\n\texit\nend\n\nsize_count[1] -= 1\n(1..4).each do |i|\n\tsizes = (1..4).map {|j| [j] * (size_count[j] - (j == i ? 1 : 0))}.flatten\n\tsum -= sum_per_size[i] * f(sizes)\nend\n\nputs sum % MOD"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.read\nwrite = sys.stdout.write\ndef solve():\n    MOD = 10**9 + 7\n    N, *A = map(int, read().split())\n\n    L = 10**5\n\n    fact = [1]*(L+1)\n    rfact = [1]*(L+1)\n    r = 1\n    for i in range(1, L+1):\n        fact[i] = r = r * i % MOD\n    rfact[L] = r = pow(fact[L], MOD-2, MOD)\n    for i in range(L, 0, -1):\n        rfact[i-1] = r = r * i % MOD\n\n    L0 = 1000\n    pw10 = [1]*(L0+1)\n    r = 1\n    for i in range(1, L0+1):\n        pw10[i] = r = r * 10 % MOD\n\n    C = [0]*5\n    V = [0]*5\n    z = 0\n    for a in A:\n        if a == 0:\n            z = 1\n        l = len(str(a))\n        C[l-1] += 1\n        V[l-1] += a\n\n    S = [0]*(N+1)\n    r = 0\n    for i in range(N+1):\n        r += rfact[i]\n        S[i] = fact[i] * r % MOD\n\n    F = [[0]*(i+1) for i in range(N+1)]\n    for i in range(N+1):\n        for j in range(i+1):\n            F[i][j] = fact[i] * rfact[i-j] % MOD\n\n    CM = [[0]*(i+1) for i in range(N+1)]\n    for i in range(N+1):\n        for j in range(i+1):\n            CM[i][j] = fact[i] * rfact[i-j] * rfact[j] % MOD\n\n    def calc(C):\n        c1, c2, c3, c4, c5 = C\n        l0 = sum(C)\n        res = 0\n        F1 = F[c1]; G1 = F[c1-1]\n        F2 = F[c2]\n        F3 = F[c3]\n        F4 = F[c4]\n        F5 = F[c5]\n        r1 = range(c1+1)\n        r2 = range(c2+1)\n        r3 = range(c3+1)\n        r4 = range(c4+1)\n        for d5 in range(c5+1):\n            v5 = F5[d5]\n            for d1 in r1:\n                v1 = v5 * CM[d1+d5][d1] % MOD\n                if z and d1 < c1:\n                    p1 = F1[d1]; p2 = G1[d1]\n                else:\n                    p1 = F1[d1]; p2 = 0\n                for d2 in r2:\n                    v2 = v1 * F2[d2] * CM[d2+d1+d5][d2] % MOD\n                    for d3 in r3:\n                        e = d1+d2*2+d3*3+d5*5\n                        f = d1+d2+d3+d5\n                        v3 = v2 * F3[d3] * CM[f][d3] % MOD\n                        for d4 in r4:\n                            l = f+d4\n                            v4 = v3 * F4[d4] * CM[l][d4] % MOD\n                            res += ((p1 * S[l0-l] - p2 * S[l0-1-l]) * pw10[e+d4*4] % MOD) * v4 % MOD\n        return res % MOD\n    c1, c2, c3, c4, c5 = C\n    ans = 0\n    ans += calc([c1-1, c2, c3, c4, c5]) * V[0]\n    ans += calc([c1, c2-1, c3, c4, c5]) * V[1]\n    ans += calc([c1, c2, c3-1, c4, c5]) * V[2]\n    ans += calc([c1, c2, c3, c4-1, c5]) * V[3]\n    ans += calc([c1, c2, c3, c4, c5-1]) * V[4]\n    ans %= MOD\n    write(\"%d\\n\" % ans)\nsolve()\n"
  }
]