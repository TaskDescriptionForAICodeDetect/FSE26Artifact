[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\ntypedef struct {\n    const char *name;\n    double factor;\n} Prefix;\n\nPrefix prefixes[] = {\n    {\"yocto\", 1e-24}, {\"zepto\", 1e-21}, {\"atto\", 1e-18}, {\"femto\", 1e-15},\n    {\"pico\", 1e-12}, {\"nano\", 1e-9}, {\"micro\", 1e-6}, {\"milli\", 1e-3},\n    {\"centi\", 1e-2}, {\"deci\", 1e-1}, {\"deca\", 1e1}, {\"hecto\", 1e2},\n    {\"kilo\", 1e3}, {\"mega\", 1e6}, {\"giga\", 1e9}, {\"tera\", 1e12},\n    {\"peta\", 1e15}, {\"exa\", 1e18}, {\"zetta\", 1e21}, {\"yotta\", 1e24}\n};\n\nint main() {\n    char input[100];\n    fgets(input, sizeof(input), stdin);\n    \n    char numberStr[50], prefixStr[50] = \"\", unit[50];\n    int matches = sscanf(input, \"%s %s %s\", numberStr, prefixStr, unit);\n    \n    if (matches == 2) {\n        strcpy(unit, prefixStr);\n        prefixStr[0] = '\\0';\n    }\n    \n    double number = atof(numberStr);\n    double factor = 1.0;\n    \n    if (prefixStr[0] != '\\0') {\n        int found = 0;\n        for (size_t i = 0; i < sizeof(prefixes) / sizeof(prefixes[0]); ++i) {\n            if (strcmp(prefixStr, prefixes[i].name) == 0) {\n                factor = prefixes[i].factor;\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            strcpy(unit, prefixStr);\n        }\n    }\n    \n    double value = number * factor;\n    if (value == 0) {\n        printf(\"0 * 10^0 %s\\n\", unit);\n        return 0;\n    }\n    \n    int exponent = (int)floor(log10(fabs(value)));\n    double mantissa = value / pow(10, exponent);\n    \n    printf(\"%g * 10^%d %s\\n\", mantissa, exponent, unit);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:13:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nmap<string, double> prefixToExponent = {\n    {\"yotta\", 24}, {\"zetta\", 21}, {\"exa\", 18}, {\"peta\", 15}, {\"tera\", 12},\n    {\"giga\", 9}, {\"mega\", 6}, {\"kilo\", 3}, {\"hecto\", 2}, {\"deca\", 1},\n    {\"deci\", -1}, {\"centi\", -2}, {\"milli\", -3}, {\"micro\", -6}, {\"nano\", -9},\n    {\"pico\", -12}, {\"femto\", -15}, {\"ato\", -18}, {\"zepto\", -21}, {\"yocto\", -24}\n};\n\npair<double, string> parseInput(const string& input) {\n    istringstream iss(input);\n    double num;\n    string prefix, unit;\n    \n    iss >> num;\n    if (iss >> prefix) {\n        if (prefixToExponent.find(prefix) != prefixToExponent.end()) {\n            if (iss >> unit) {\n                return {num * pow(10, prefixToExponent[prefix]), unit};\n            } else {\n                return {num * pow(10, prefixToExponent[prefix]), prefix};\n            }\n        } else {\n            return {num, prefix};\n        }\n    }\n    return {num, \"\"};\n}\n\npair<double, int> toScientific(double value) {\n    if (value == 0) return {0, 0};\n    int exponent = floor(log10(abs(value)));\n    double a = value / pow(10, exponent);\n    if (a >= 10.0) {\n        a /= 10.0;\n        exponent += 1;\n    } else if (a < 1.0) {\n        a *= 10.0;\n        exponent -= 1;\n    }\n    return {a, exponent};\n}\n\nstring formatScientific(double a, int b, const string& unit) {\n    ostringstream oss;\n    oss << fixed;\n    \n    string numStr = to_string(a);\n    size_t dotPos = numStr.find('.');\n    if (dotPos != string::npos) {\n        size_t lastNonZero = numStr.find_last_not_of('0');\n        if (lastNonZero != string::npos && lastNonZero > dotPos) {\n            numStr.erase(lastNonZero + 1);\n        } else {\n            numStr.erase(dotPos);\n        }\n    }\n    \n    oss << numStr << \" * 10^\" << b << \" \" << unit;\n    return oss.str();\n}\n\nint main() {\n    string input;\n    getline(cin, input);\n    \n    auto [value, unit] = parseInput(input);\n    auto [a, b] = toScientific(value);\n    \n    cout << formatScientific(a, b, unit) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:13:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class UnitConverter {\n    private static final Map<String, Integer> PREFIX_MAP = new HashMap<>();\n\n    static {\n        PREFIX_MAP.put(\"yocto\", -24);\n        PREFIX_MAP.put(\"zepto\", -21);\n        PREFIX_MAP.put(\"ato\", -18);\n        PREFIX_MAP.put(\"femto\", -15);\n        PREFIX_MAP.put(\"pico\", -12);\n        PREFIX_MAP.put(\"nano\", -9);\n        PREFIX_MAP.put(\"micro\", -6);\n        PREFIX_MAP.put(\"milli\", -3);\n        PREFIX_MAP.put(\"centi\", -2);\n        PREFIX_MAP.put(\"deci\", -1);\n        PREFIX_MAP.put(\"deca\", 1);\n        PREFIX_MAP.put(\"hecto\", 2);\n        PREFIX_MAP.put(\"kilo\", 3);\n        PREFIX_MAP.put(\"mega\", 6);\n        PREFIX_MAP.put(\"giga\", 9);\n        PREFIX_MAP.put(\"tera\", 12);\n        PREFIX_MAP.put(\"peta\", 15);\n        PREFIX_MAP.put(\"exa\", 18);\n        PREFIX_MAP.put(\"zetta\", 21);\n        PREFIX_MAP.put(\"yotta\", 24);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine().trim();\n        String[] parts = input.split(\"\\\\s+\");\n\n        double number;\n        String prefix = \"\";\n        String unit = \"\";\n\n        if (parts.length >= 2) {\n            number = Double.parseDouble(parts[0]);\n            if (PREFIX_MAP.containsKey(parts[1].toLowerCase())) {\n                prefix = parts[1].toLowerCase();\n                if (parts.length >= 3) {\n                    unit = parts[2];\n                }\n            } else {\n                unit = parts[1];\n            }\n        } else {\n            number = Double.parseDouble(parts[0]);\n        }\n\n        int exponent = PREFIX_MAP.getOrDefault(prefix, 0);\n        double value = number * Math.pow(10, exponent);\n\n        if (value == 0) {\n            System.out.println(\"0 [unit]\");\n            return;\n        }\n\n        int exp = (int) Math.floor(Math.log10(Math.abs(value)));\n        double a = value / Math.pow(10, exp);\n\n        String aStr = String.format(\"%.10f\", a).replaceAll(\"0*$\", \"\").replaceAll(\"\\\\.$\", \"\");\n        if (aStr.contains(\".\")) {\n            aStr = aStr.replaceAll(\"0+$\", \"\");\n        }\n\n        System.out.println(aStr + \" * 10^\" + exp + (unit.isEmpty() ? \"\" : \" [\" + unit + \"]\"));\n    }\n}",
    "timestamp": "2025-08-05 21:14:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class UnitConverter {\n    private static final Map<String, Integer> PREFIXES = new HashMap<>() {{\n        put(\"yotta\", 24);\n        put(\"zetta\", 21);\n        put(\"exa\", 18);\n        put(\"peta\", 15);\n        put(\"tera\", 12);\n        put(\"giga\", 9);\n        put(\"mega\", 6);\n        put(\"kilo\", 3);\n        put(\"hecto\", 2);\n        put(\"deca\", 1);\n        put(\"deci\", -1);\n        put(\"centi\", -2);\n        put(\"milli\", -3);\n        put(\"micro\", -6);\n        put(\"nano\", -9);\n        put(\"pico\", -12);\n        put(\"femto\", -15);\n        put(\"ato\", -18);\n        put(\"zepto\", -21);\n        put(\"yocto\", -24);\n    }};\n\n    public static String convert(String input) {\n        String[] parts = input.split(\"\\\\s+\");\n        double value = Double.parseDouble(parts[0]);\n        int prefixExponent = 0;\n        String unit = parts[parts.length - 1];\n\n        if (parts.length > 2 && PREFIXES.containsKey(parts[1])) {\n            prefixExponent = PREFIXES.get(parts[1]);\n        }\n\n        int exponent = (int) Math.floor(Math.log10(Math.abs(value)) + prefixExponent);\n        double mantissa = value / Math.pow(10, exponent);\n\n        // Adjust mantissa and exponent to ensure 1 <= a < 10\n        if (mantissa >= 10) {\n            mantissa /= 10;\n            exponent += 1;\n        } else if (mantissa < 1) {\n            mantissa *= 10;\n            exponent -= 1;\n        }\n\n        return String.format(\"%.6f * 10^%d %s\", mantissa, exponent, unit);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine();\n        System.out.println(convert(input));\n    }\n}",
    "timestamp": "2025-08-05 21:14:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\n// Prefix mapping to exponents\nconst char* prefixes[] = {\n    \"yotta\", \"zetta\", \"exa\", \"peta\", \"tera\", \"giga\", \"mega\", \"kilo\", \n    \"hecto\", \"deca\", \"deci\", \"centi\", \"milli\", \"micro\", \"nano\", \n    \"pico\", \"femto\", \"ato\", \"zepto\", \"yocto\"\n};\nconst int exponents[] = {\n    24, 21, 18, 15, 12, 9, 6, 3, \n    2, 1, -1, -2, -3, -6, -9, \n    -12, -15, -18, -21, -24\n};\n\nvoid convert_unit(char* input) {\n    char* num_str = strtok(input, \" \");\n    char* prefix_str = strtok(NULL, \" \");\n    char* unit_str = strtok(NULL, \" \");\n\n    // Parse number \n    double value = atof(num_str);\n    int prefix_exp = 0;\n\n    // Check for prefix\n    if (prefix_str) {\n        for (int i = 0; i < 20; i++) {\n            if (strcmp(prefix_str, prefixes[i]) == 0) {\n                prefix_exp = exponents[i];\n                break;\n            }\n        }\n    }\n\n    // Adjust value based on prefix\n    value *= pow(10, prefix_exp);\n\n    // Scientific notation conversion\n    int exp = floor(log10(fabs(value)));\n    double mantissa = value / pow(10, exp);\n\n    // Normalize to 1 <= mantissa < 10\n    if (mantissa >= 10) {\n        mantissa /= 10;\n        exp++;\n    } else if (mantissa < 1) {\n        mantissa *= 10;\n        exp--;\n    }\n\n    // Output result\n    printf(\"%.6g * 10^%d %s\\n\", mantissa, exp, unit_str ? unit_str : \"\");\n}\n\nint main() {\n    char input[256];\n    fgets(input, sizeof(input), stdin);\n    input[strcspn(input, \"\\n\")] = 0;  // Remove newline\n    convert_unit(input);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:14:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n#include <cmath>\n#include <map>\n#include <algorithm>\n\nstd::map<std::string, int> prefixes = {\n    {\"yotta\", 24}, {\"zetta\", 21}, {\"exa\", 18}, {\"peta\", 15}, {\"tera\", 12},\n    {\"giga\", 9}, {\"mega\", 6}, {\"kilo\", 3}, {\"hecto\", 2}, {\"deca\", 1},\n    {\"deci\", -1}, {\"centi\", -2}, {\"milli\", -3}, {\"micro\", -6}, {\"nano\", -9},\n    {\"pico\", -12}, {\"femto\", -15}, {\"ato\", -18}, {\"zepto\", -21}, {\"yocto\", -24}\n};\n\nint main() {\n    std::string input, prefix, unit, numberStr;\n    std::getline(std::cin, input);\n    \n    std::istringstream iss(input);\n    iss >> numberStr >> prefix >> unit;\n    \n    int prefixExp = 0;\n    if (prefixes.count(prefix)) {\n        prefixExp = prefixes[prefix];\n    } else {\n        prefix = \"\";\n        iss.clear();\n        iss.str(input);\n        iss >> numberStr >> unit;\n    }\n    \n    double number = std::stod(numberStr);\n    int exponent = static_cast<int>(std::floor(std::log10(std::abs(number)))) + prefixExp;\n    double mantissa = number / std::pow(10, exponent);\n    \n    std::cout << std::fixed << std::setprecision(1) << mantissa << \" * 10^\" << exponent << \" \" << unit << std::endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:14:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def to_scientific_notation(input_str):\n    prefix_to_power = {\n        'yocto': -24, 'zepto': -21, 'ato': -18, 'femto': -15, 'pico': -12,\n        'nano': -9, 'micro': -6, 'milli': -3, 'centi': -2, 'deci': -1,\n        'deka': 1, 'hecto': 2, 'kilo': 3, 'mega': 6, 'giga': 9, 'tera': 12,\n        'peta': 15, 'exa': 18, 'zetta': 21, 'yotta': 24\n    }\n\n    parts = input_str.split()\n    if len(parts) == 2:  # Only number and unit\n        number_str, unit = parts\n        prefix_power = 0\n    else:  # Number, prefix, and unit\n        number_str, prefix, unit = parts\n        prefix_power = prefix_to_power.get(prefix.lower(), 0)\n\n    # Convert number string to float and multiply by prefix power of 10\n    number = float(number_str) * (10 ** prefix_power)\n\n    # Determine scientific notation representation\n    exp = 0\n    while number >= 10 or number < 1:\n        if number >= 10:\n            number /= 10\n            exp += 1\n        elif number < 1:\n            number *= 10\n            exp -= 1\n\n    # Output the result\n    return f\"{number:.10g} * 10^{exp} [{unit}]\"\n\n# Example usage\nprint(to_scientific_notation(\"1500 kilo meters\"))  # Output: 1.5 * 10^6 [meters]",
    "timestamp": "2025-08-13 05:31:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class UnitConverter {\n    private static final Map<String, Double> PREFIX_MULTIPLIERS = new HashMap<>();\n\n    static {\n        PREFIX_MULTIPLIERS.put(\"yotta\", 1e24);\n        PREFIX_MULTIPLIERS.put(\"zetta\", 1e21);\n        PREFIX_MULTIPLIERS.put(\"exa\", 1e18);\n        PREFIX_MULTIPLIERS.put(\"peta\", 1e15);\n        PREFIX_MULTIPLIERS.put(\"tera\", 1e12);\n        PREFIX_MULTIPLIERS.put(\"giga\", 1e9);\n        PREFIX_MULTIPLIERS.put(\"mega\", 1e6);\n        PREFIX_MULTIPLIERS.put(\"kilo\", 1e3);\n        PREFIX_MULTIPLIERS.put(\"hecto\", 1e2);\n        PREFIX_MULTIPLIERS.put(\"deca\", 1e1);\n        PREFIX_MULTIPLIERS.put(\"deci\", 1e-1);\n        PREFIX_MULTIPLIERS.put(\"centi\", 1e-2);\n        PREFIX_MULTIPLIERS.put(\"milli\", 1e-3);\n        PREFIX_MULTIPLIERS.put(\"micro\", 1e-6);\n        PREFIX_MULTIPLIERS.put(\"nano\", 1e-9);\n        PREFIX_MULTIPLIERS.put(\"pico\", 1e-12);\n        PREFIX_MULTIPLIERS.put(\"femto\", 1e-15);\n        PREFIX_MULTIPLIERS.put(\"ato\", 1e-18);\n        PREFIX_MULTIPLIERS.put(\"zepto\", 1e-21);\n        PREFIX_MULTIPLIERS.put(\"yocto\", 1e-24);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine();\n        String[] parts = input.split(\" \");\n        \n        double number = Double.parseDouble(parts[0]);\n        String prefix = parts.length == 3 ? parts[1].toLowerCase() : \"\";\n        String unit = parts.length == 3 ? parts[2] : parts[1];\n\n        double multiplier = PREFIX_MULTIPLIERS.getOrDefault(prefix, 1.0);\n        number *= multiplier;\n        \n        int exponent = (int)Math.floor(Math.log10(Math.abs(number)));\n        double a = number / Math.pow(10, exponent);\n        \n        System.out.printf(\"%.5f * 10^%d %s%n\", a, exponent, unit);\n    }\n}",
    "timestamp": "2025-08-13 05:31:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\ndouble getPrefixMultiplier(const char* prefix) {\n    if (strcmp(prefix, \"yotta\") == 0) return 1e24;\n    if (strcmp(prefix, \"zetta\") == 0) return 1e21;\n    if (strcmp(prefix, \"exa\") == 0) return 1e18;\n    if (strcmp(prefix, \"peta\") == 0) return 1e15;\n    if (strcmp(prefix, \"tera\") == 0) return 1e12;\n    if (strcmp(prefix, \"giga\") == 0) return 1e9;\n    if (strcmp(prefix, \"mega\") == 0) return 1e6;\n    if (strcmp(prefix, \"kilo\") == 0) return 1e3;\n    if (strcmp(prefix, \"hecto\") == 0) return 1e2;\n    if (strcmp(prefix, \"deca\") == 0) return 1e1;\n    if (strcmp(prefix, \"deci\") == 0) return 1e-1;\n    if (strcmp(prefix, \"centi\") == 0) return 1e-2;\n    if (strcmp(prefix, \"milli\") == 0) return 1e-3;\n    if (strcmp(prefix, \"micro\") == 0) return 1e-6;\n    if (strcmp(prefix, \"nano\") == 0) return 1e-9;\n    if (strcmp(prefix, \"pico\") == 0) return 1e-12;\n    if (strcmp(prefix, \"femto\") == 0) return 1e-15;\n    if (strcmp(prefix, \"ato\") == 0) return 1e-18;\n    if (strcmp(prefix, \"zepto\") == 0) return 1e-21;\n    if (strcmp(prefix, \"yocto\") == 0) return 1e-24;\n    return 1.0; // Default, no prefix\n}\n\nint main() {\n    char input[100], prefix[20], unit[20];\n    double number;\n    fgets(input, sizeof(input), stdin);\n\n    int numFields = sscanf(input, \"%lf %s %s\", &number, prefix, unit);\n    double multiplier = 1.0;\n\n    if (numFields == 3) {\n        multiplier = getPrefixMultiplier(prefix);\n    } else if (numFields == 2) {\n        strcpy(unit, prefix);\n    }\n\n    double convertedValue = number * multiplier;\n    int exponent = (int) floor(log10(fabs(convertedValue)));\n    double mantissa = convertedValue / pow(10, exponent);\n\n    while (mantissa >= 10.0) {\n        mantissa /= 10.0;\n        exponent++;\n    }\n\n    printf(\"%.3f * 10^%d %s\\n\", mantissa, exponent, unit);\n    return 0;\n}",
    "timestamp": "2025-08-13 05:31:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def convert_to_scientific_notation(input_str):\n    prefixes = {\n        'yotta': 24, 'zetta': 21, 'exa': 18, 'peta': 15, 'tera': 12, 'giga': 9,\n        'mega': 6, 'kilo': 3, 'hecto': 2, 'deca': 1, 'deci': -1, 'centi': -2,\n        'milli': -3, 'micro': -6, 'nano': -9, 'pico': -12, 'femto': -15,\n        'ato': -18, 'zepto': -21, 'yocto': -24\n    }\n    \n    parts = input_str.split()\n    \n    if len(parts) < 2:\n        return None\n    \n    # Check if first part is a number\n    try:\n        num = float(parts[0])\n    except ValueError:\n        return None\n    \n    # Determine prefix exponent\n    prefix_exp = 0\n    unit = parts[-1]\n    \n    if len(parts) > 2 and parts[1] in prefixes:\n        prefix_exp = prefixes[parts[1]]\n        \n    # Normalize to scientific notation\n    if num == 0:\n        return f\"0 * 10^0 {unit}\"\n    \n    exp = 0\n    while abs(num) >= 10 or abs(num) < 1:\n        if abs(num) >= 10:\n            num /= 10\n            exp += 1\n        else:\n            num *= 10\n            exp -= 1\n    \n    total_exp = exp + prefix_exp\n    return f\"{num:.{len(str(input_str).split('.')[0])-1}f} * 10^{total_exp} {unit}\"",
    "timestamp": "2025-08-13 05:31:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import re\n\ndef unit_converter(input_str):\n    # Define prefix to multiplier mapping\n    prefix_map = {\n        'yotta': 1e24, 'Y': 1e24,\n        'zetta': 1e21, 'Z': 1e21,\n        'exa': 1e18, 'E': 1e18,\n        'peta': 1e15, 'P': 1e15,\n        'tera': 1e12, 'T': 1e12,\n        'giga': 1e9, 'G': 1e9,\n        'mega': 1e6, 'M': 1e6,\n        'kilo': 1e3, 'k': 1e3,\n        'hecto': 1e2, 'h': 1e2,\n        'deca': 1e1, 'da': 1e1,\n        'deci': 1e-1, 'd': 1e-1,\n        'centi': 1e-2, 'c': 1e-2,\n        'milli': 1e-3, 'm': 1e-3,\n        'micro': 1e-6, 'u': 1e-6,\n        'nano': 1e-9, 'n': 1e-9,\n        'pico': 1e-12, 'p': 1e-12,\n        'femto': 1e-15, 'f': 1e-15,\n        'ato': 1e-18, 'a': 1e-18,\n        'zepto': 1e-21, 'z': 1e-21,\n        'yocto': 1e-24, 'y': 1e-24\n    }\n    \n    # Parse the input\n    parts = input_str.split()\n    num_str = parts[0]\n    prefix = ''\n    unit = ''\n    \n    if len(parts) == 2:\n        # Only number and unit, no prefix\n        unit = parts[1]\n    elif len(parts) == 3:\n        # Number, prefix, unit\n        prefix = parts[1]\n        unit = parts[2]\n    \n    # Handle the number part\n    num = float(num_str)\n    \n    # Apply prefix multiplier if exists\n    if prefix:\n        multiplier = prefix_map.get(prefix.lower(), 1)\n        num *= multiplier\n    \n    # Handle zero case\n    if num == 0:\n        return f\"0 * 10^0 {unit}\"\n    \n    # Convert to scientific notation\n    exponent = 0\n    a = abs(num)\n    if a >= 10:\n        while a >= 10:\n            a /= 10\n            exponent += 1\n    elif a < 1:\n        while a < 1:\n            a *= 10\n            exponent -= 1\n    \n    # Determine the sign of 'a'\n    if num < 0:\n        a = -a\n    \n    # Count significant figures in the original number\n    if '.' in num_str:\n        # Count all digits except leading zeros after decimal\n        sig_figs = len(num_str.replace('.', '').lstrip('0'))\n    else:\n        # Count all digits except trailing zeros\n        sig_figs = len(num_str.rstrip('0'))\n    \n    # Format 'a' to have the same significant figures\n    a_str = f\"{a:.{sig_figs-1}f}\".rstrip('0').rstrip('.') if '.' in f\"{a:.{sig_figs-1}f}\" else f\"{a:.0f}\"\n    # Handle cases like 1.000 becoming 1\n    if '.' in a_str:\n        a_str = a_str.rstrip('0').rstrip('.') if '.' in a_str else a_str\n    \n    return f\"{a_str} * 10^{exponent} {unit}\"",
    "timestamp": "2025-08-13 05:32:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <sstream>\n#include <unordered_map>\n#include <string>\n#include <cmath>\n\nstd::unordered_map<std::string, int> prefixToPower = {\n    {\"yotta\", 24}, {\"zetta\", 21}, {\"exa\", 18}, {\"peta\", 15}, {\"tera\", 12}, {\"giga\", 9}, {\"mega\", 6}, \n    {\"kilo\", 3}, {\"hecto\", 2}, {\"deca\", 1}, {\"deci\", -1}, {\"centi\", -2}, {\"milli\", -3}, \n    {\"micro\", -6}, {\"nano\", -9}, {\"pico\", -12}, {\"femto\", -15}, {\"ato\", -18}, {\"zepto\", -21}, {\"yocto\", -24}\n};\n\nint main() {\n    std::string input;\n    getline(std::cin, input);\n    \n    std::istringstream iss(input);\n    double value;\n    std::string prefix, unit;\n    \n    iss >> value;\n    iss >> prefix;\n    iss >> unit;\n    \n    int power = 0;\n    if (prefixToPower.find(prefix) != prefixToPower.end()) {\n        power = prefixToPower[prefix];\n    } else {\n        unit = prefix;\n    }\n    \n    double convertedValue = value * pow(10, power);\n    int exponent = 0;\n    \n    while (convertedValue >= 10) {\n        convertedValue /= 10;\n        exponent++;\n    }\n    \n    while (convertedValue < 1) {\n        convertedValue *= 10;\n        exponent--;\n    }\n    \n    exponent += power;\n    \n    std::cout << convertedValue << \" * 10^\" << exponent << \" \" << unit << std::endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:25:42"
  }
]