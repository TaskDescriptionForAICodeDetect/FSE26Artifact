[
  {
    "language": "Vim",
    "code": "1"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nusing namespace std;\n\nint n;\nstring s;\n\npair<vector<int>, vector<int> > solve(vector<int> last_p, vector<int> last_w)\n{\n    vector<int> p(3 * last_p.size()), w;\n    int n = last_p.size();\n\n    /*vector<int> d(3 * last_p.size());\n    for (int i = 0; i < n; i++) d[i] = 0;\n    for (int i = n; i < 2 * n; i++) d[i] = 1;\n    for (int i = 2 * n; i < 3 * n; i++) d[i] = 2;\n\n    for (int i = 0; i < s.size(); i++)\n    {\n        int x = last_w[i];\n        if (d[x] == 2) w.push_back(x);\n        if (d[n + x] == 2) w.push_back(n + x);\n        if (d[2 * n + x] == 2) w.push_back(2 * n + x);\n        if (s[i] == 'S')\n        {\n            for (int j = 0; j < d.size(); j++) d[j] = (3 - d[j]) % 3;\n        }\n        else\n        {\n            int x = last_w[i];\n            d[x] = (d[x] + 1) % 3;\n            d[n + x] = (d[n + x] + 1) % 3;\n            d[2 * n + x] = (d[2 * n + x] + 1) % 3;\n        }\n    }*/\n\n    set<int> d0, d1, d2;\n    for (int i = 0; i < n; i++) d0.insert(i);\n    for (int i = n; i < 2 * n; i++) d1.insert(i);\n    for (int i = 2 * n; i < 3 * n; i++) d2.insert(i);\n\n    for (int i = 0; i < s.size(); i++)\n    {\n        int x = last_w[i];\n        vector<int> q = {x, x + n, x + 2 * n};\n        for (auto e : q) if (d2.find(e) != d2.end()) {w.push_back(e); break;}\n        if (s[i] == 'S')\n        {\n            swap(d1, d2);\n        }\n        else\n        {\n            int f0, f1, f2;\n            for (auto e : q) if (d0.find(e) != d0.end()) {f0 = e; break;}\n            for (auto e : q) if (d1.find(e) != d1.end()) {f1 = e; break;}\n            for (auto e : q) if (d2.find(e) != d2.end()) {f2 = e; break;}\n            d0.erase(f0); d1.insert(f0);\n            d1.erase(f1); d2.insert(f1);\n            d2.erase(f2); d0.insert(f2);\n        }\n    }\n\n    for (int i = 0; i < 3 * n; i++)\n    {\n        p[i] = last_p[i % n];\n    }\n    for (auto e : d1) p[e] += n;\n    for (auto e : d2) p[e] += n + n;\n\n    return {p, w};\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n    cin >> n;\n    cin >> s;\n    //n = 12;\n    //for (int i = 0; s.size() < 200000; i++) s += \"TSST\";\n\n    vector<int> last_p = {0, 1, 2};\n    vector<int> last_w;\n    for (int i = 0; i < s.size(); i++)\n    {\n        for (int j = 0; j < 3; j++) if (last_p[j] == 2) last_w.push_back(j);\n        if (s[i] == 'S')\n        {\n            int t = 1;\n            for (int k = 0; t && k < 3; k++)\n            {\n                for (int j = 0; t && j < 3; j++)\n                {\n                    if (last_p[k] == 2 && last_p[j] == 1)\n                    {\n                        swap(last_p[k], last_p[j]);\n                        t = 0;\n                    }\n                }\n            }\n        }\n        else\n        {\n            for (int j = 0; j < 3; j++) last_p[j] = (last_p[j] + 1) % 3;\n        }\n    }\n    for (int i = 1; i < n; i++)\n    {\n        pair<vector<int>, vector<int> > gg = solve(last_p, last_w);\n        last_p = gg.first;\n        last_w = gg.second;\n    }\n    for (int i = 0; i < last_p.size(); i++)\n    {\n        cout << last_p[i] << \" \";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"Ofast,unroll-loops\")\n#pragma GCC target(\"avx,avx2,fma\")\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define MP make_pair\n#define PB push_back\n#define X first\n#define Y second\n\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n#define FILL(a, value) memset(a, value, sizeof(a))\n#define debug(a) cerr << #a << \" = \" << a << endl;\n\ntemplate<typename T> void setmax(T& x, T y) {x = max(x, y);}\ntemplate<typename T> void setmin(T& x, T y) {x = min(x, y);}\n\nconst double PI = acos(-1.0);\nconst LL INF = 1e9 + 47;\nconst LL LINF = INF * INF;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 531441;\nint n;\nint pw[13];\nint p[N];\nint np[N];\nint ans[N];\nint f[N];\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tpw[0] = 1;\n\tFOR(i, 1, 13){\n\t\tpw[i] = pw[i - 1] * 3;\n\t}\n\t\n\tFOR(i, 0, N){\n\t\tint A = i;\n\t\tvector<int> D;\n\t\twhile(A){\n\t\t\tD.PB((3 - A % 3) % 3);\n\t\t\tA /= 3;\n\t\t}\n\t\t\n\t\treverse(ALL(D));\n\t\tint B = 0;\n\t\tfor(auto x: D){\n\t\t\tB = 3 * B + x;\n\t\t}\n\t\t\n\t\tf[i] = B;\n\t}\n\t\n\tcerr << \"Time elapsed: \" << clock() / (double)CLOCKS_PER_SEC << endl;\n\tstring s;\n\tcin >> n >> s;\n\t\n\tint m = pw[n];\n\tiota(p, p + N, 0);\n\t\n\tfor(auto i: s){\n\t\tif (i == 'S'){\n\t\t\tFOR(j, 0, m){\n\t\t\t\tnp[j] = p[f[j]];\n\t\t\t}\n\t\t}else{\n\t\t\tmemcpy(np + 1, p, (m - 1) * sizeof(int));\n\t\t\tnp[0] = p[m - 1];\n\t\t}\n\t\t\n\t\tmemcpy(p, np, m * sizeof(int));\n\t}\n\t\n\tFOR(i, 0, m){\n\t\tnp[p[i]] = i;\n\t}\n\t\n\tFOR(i, 0, m){\n\t\tcout << np[i] << ' ';\n\t}\n\t\n\tcout << endl;\n\t\n\tcerr << \"Time elapsed: \" << clock() / (double)CLOCKS_PER_SEC << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nstring str;\nint val[2000010][3], ch[2000010][3], tot = 1;\nbool laz[2000010];\n\nvoid build()\n{\n\tfor (int i = 1; i <= n + 1; i++) tot *= 3;\n\ttot = (tot - 1) / 2;\n\tfor (int i = 1; i <= tot; i++)\n\t\tif (i * 3 <= tot)\n\t\t{\n\t\t\tch[i][0] = i * 3 - 1, ch[i][1] = i * 3, ch[i][2] = i * 3 + 1;\n\t\t\tval[i][0] = 0, val[i][1] = 1, val[i][2] = 2;\n\t\t\tlaz[i] = 0;\n\t\t}\n}\n\nvoid pushdown(int p)\n{\n\tif (laz[p])\n\t{\n\t\tint a, b;\n\t\tfor (int i = 0; i < 3; i++)\n\t\t{\n\t\t\tif (val[p][i] == 1) a = i;\n\t\t\tif (val[p][i] == 2) b = i;\n\t\t}\n\t\tswap(val[p][a], val[p][b]);\n\t\tfor (int i = 0; i < 3; i++)\n\t\t\tlaz[ch[p][i]] ^= 1;\n\t\tlaz[p] = 0;\n\t}\n}\n\nvoid add(int p)\n{\n\tif (p * 3 > tot) return;\n\tpushdown(p);\n\tint pos = 0;\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tval[p][i]++;\n\t\tif (val[p][i] == 3)\n\t\t{\n\t\t\tval[p][i] = 0;\n\t\t\tpos = ch[p][i];\n\t\t}\n\t}\n\tadd(pos);\n}\n\nint arr[2000010], cnt;\nint rev[2000010];\n\nvoid dfs(int p, int cur, int v)\n{\n\tif (p * 3 > tot)\n\t{\n\t\tarr[cnt++] = cur;\n\t\treturn;\n\t}\n\tpushdown(p); \n\tfor (int i = 0; i < 3; i++)\n\t\tdfs(ch[p][i], cur + v * val[p][i], v * 3);\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin >> n >> str;\n\tbuild();\n\tfor (int i = 0; i < str.size(); i++)\n\t{\n\t\tif (str[i] == 'R') add(1);\n\t\telse laz[1] ^= 1;\n\t}\n\tdfs(1, 0, 1);\n\tfor (int i = 1; i < cnt; i++)\n\t\trev[i] = rev[i / 3] / 3 + (cnt / 3) * (i % 3);\n\tfor (int i = 0; i < cnt; i++)\n\t\tif (i < rev[i])\n\t\t\tswap(arr[i], arr[rev[i]]);\n\tfor (int i = 0; i < cnt; i++)\n\t\tcout << arr[i] << ' ';\n\tcout << endl; \n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\ntypedef vector<bool> vb;\ntypedef vector<vector<bool>> vvb;\ntypedef vector<vector<vector<bool>>> vvvb;\ntypedef pair<ll, ll> pll;\ntypedef vector<pll> vpll;\ntypedef vector<vpll> vvpll;\ntypedef vector<double> vd;\ntypedef vector<vd> vdd;\n\n#define FOR(i,x,y) for(ll i=(ll)x; i<(ll)y; ++i)\n#define REP(i,y) FOR(i, 0, y)\n#define RFOR(i,x,y) for(ll i=(ll)x; i>=(ll)y; --i)\n#define RREP(i,x) RFOR(i, x, 0)\n#define ALL(a) a.begin(), a.end()\n#define pb push_back\n#define debug_print(x...) cerr << \"line \" << __LINE__ << \" : \"; debug_print_in(x);\n\ntemplate <typename First>\nvoid debug_print_in(First first){\n  cerr << first << endl;\n  return;\n}\n\ntemplate <typename First, typename... Rest>\nvoid debug_print_in(First first, Rest... rest){\n  cerr << first << \" \";\n  debug_print_in(rest...);\n  return;\n}\n\nvoid IN(void){\n  return;\n}\n\ntemplate <typename First, typename... Rest>\nvoid IN(First& first, Rest&... rest){\n  cin >> first;\n  IN(rest...);\n  return;\n}\n\ntemplate <typename First>\nvoid OUT(First first){\n  cout << first << endl;\n  return;\n}\n\ntemplate <typename First, typename... Rest>\nvoid OUT(First first, Rest... rest){\n  cout << first << \" \";\n  OUT(rest...);\n  return;\n}\n\ntemplate<class t, class u> void chmax(t&a,u b){if(a<b)a=b;};\ntemplate<class t, class u> void chmin(t&a,u b){if(a>b)a=b;};\nint popcount(int t){return __builtin_popcount(t);} //GCC\nint popcount(ll t){return __builtin_popcountll(t);} //GCC\n\ntemplate <typename T>\nvoid vec_print(vector<T> VEC){\n  REP(i, VEC.size()){\n    cerr << VEC[i] << \" \";\n  }\n  cerr << endl;\n};\n\ntemplate <typename T>\nvoid mat_print(vector<vector<T> > MAT){\n  REP(i,MAT.size()){\n    REP(j,MAT[i].size()){\n      cerr << MAT[i][j] << \" \";\n    }\n    cerr << endl;\n  }\n};\n\nconstexpr int INF = (1<<30);\nconstexpr ll INFLL = 1LL<<62;\nconstexpr long double EPS = 1e-12;\nconstexpr ll MOD = (ll)((1E+9)+7);\n\nll N;\nstring T;\n\npair<vll, vll> solve(ll n){\n  if(n==0){\n    vll P0 = {0};\n    vll W0(T.size()+1, 0);\n    return make_pair(P0, W0);\n  }\n  auto PW_prev = solve(n-1);\n  auto P_old = PW_prev.first;\n  auto W_old = PW_prev.second;\n\n  /*\n  for(auto ans : PW_prev.first){\n    printf(\"%lld \", ans);\n  }\n  printf(\"\\n\");\n\n  for(auto tmp : PW_prev.second){\n    printf(\"%lld \", tmp);\n  }\n  printf(\"\\n\\n\");\n  */\n\n  vll P_new(P_old.size()*3);\n  vll D_new(P_old.size()*3);\n  vll W_new(W_old.size());\n\n  vll S_ahead_count(P_old.size()*3);\n  ll S_count = 0;\n\n  REP(i,D_new.size()) D_new[i] = i/P_old.size();\n\n  REP(i,T.size()){\n    auto W = W_old[i];\n    //debug_print(W);\n    auto c = T[i];\n    for(auto j=W; j<P_new.size(); j+=P_old.size()){\n      if((S_count-S_ahead_count[j])%2==1){\n        S_ahead_count[j] = S_count;\n        D_new[j] = (3-D_new[j])%3;\n      }\n      if(D_new[j]==2) W_new[i] = j;\n    }\n    if(c=='S'){\n      S_count++;\n    }else{\n      for(auto j=W; j<P_new.size(); j+=P_old.size()){\n        D_new[j] = (D_new[j]+1)%3;\n      }\n    }\n\n    //debug_print(i, W, c);\n    REP(k,P_new.size()){\n      ll D_tmp = D_new[k];\n      if((S_count-S_ahead_count[k])%2==1){\n        D_tmp = (3-D_new[k])%3;\n      }\n      P_new[k] = P_old[k%P_old.size()] + P_old.size()*D_tmp;\n      //printf(\"%lld \", D_tmp);\n    }\n\n    /*\n    printf(\"\\n\");\n    debug_print(i);\n    */\n  }\n\n  return make_pair(P_new, W_new);\n}\n\nint main(){\n  cin.tie(0); // cut the cin and cout (default, std::flush is performed after std::cin)\n  ios::sync_with_stdio(false); // cut the iostream and stdio (DON'T endl; BUT \"\\n\";)\n\n  IN(N);\n  IN(T);\n\n  auto PW = solve(N);\n\n  for(auto ans : PW.first){\n    printf(\"%lld \", ans);\n  }\n  printf(\"\\n\");\n\n  /*\n  for(auto tmp : PW.second){\n    printf(\"%lld \", tmp);\n  }\n  printf(\"\\n\");\n  */\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=600005;\nint n,rt,cnt,ind,pw[N],ch[N][3],tg[N],val[N],ans[N];char s[N];\nvoid bud(int&k1,int k2,int k3){\n\tk1=++cnt;\n\tif(k2==n){val[k1]=k3;return;}\n\trep(i,0,2)bud(ch[k1][i],k2+1,k3+pw[k2]*i);\n}\nvoid pst(int k1){\n\tif(!ch[k1][0])return;\n\tswap(ch[k1][1],ch[k1][2]);\n\ttg[k1]^=1;\n}\nvoid psd(int k1){\n\tif(!ch[k1][0])return;\n\tif(tg[k1]){\n\t\tpst(ch[k1][0]);\n\t\tpst(ch[k1][1]);\n\t\tpst(ch[k1][2]);\n\t\ttg[k1]^=1;\n\t}\n}\nvoid go(int k1){\n\tif(!ch[k1][0])return;\n\tpsd(k1);\n\tint t=ch[k1][2];ch[k1][2]=ch[k1][1],ch[k1][1]=ch[k1][0],ch[k1][0]=t;\n\tgo(ch[k1][0]);\n}\nvoid dfs(int k1,int k2,int k3){\n\tif(k2==n){ans[val[k1]]=k3;return;}\n\tpsd(k1);\n\trep(i,0,2)dfs(ch[k1][i],k2+1,k3+pw[k2]*i);\n}\nint main(){\n\tscanf(\"%d%s\",&n,s);\n\tpw[0]=1;rep(i,1,n)pw[i]=pw[i-1]*3;\n\tbud(rt,0,0);\n\tfor(int i=0;s[i];++i){\n\t\tif(s[i]=='S')pst(rt);\n\t\telse go(rt);\n\t}\n\tdfs(rt,0,0);\n\trep(i,0,pw[n]-1)printf(\"%d \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar T[550005];\nint salsa2[550005];\nint salsaNext[550005];\nint p[550005];\n\n// Based on editorial solution\nint D[13][550005]; // one digit at a time, with digit 0 representing the ones place\nint W[13][550005];\nint lastUpdated[13][550005];\n\nint N;\n\nvoid update(int n, int indx, int cntS){\n    if((cntS&1) != (lastUpdated[n][indx]&1)){\n        // conduct salsa\n        if(D[n][indx] == 1){\n            D[n][indx] = 2;\n        }else if(D[n][indx] == 2){\n            D[n][indx] = 1;\n        }\n    }\n    // updated the lastUpdated index\n    lastUpdated[n][indx] = cntS;\n}\n\nint pow3[16];\n\nint main(){\n    scanf(\"%d\", &N);\n\n    scanf(\" %s\", T);\n\n    int M = strlen(T);\n\n    pow3[0] = 1;\n    for(int i = 1; i <= N; i ++){\n        pow3[i] = pow3[i-1]*3;\n    }\n\n    int pow3N = pow3[N];\n\n    //printf(\"ok\");\n    memset(W, 0, sizeof(W));\n    for(int n = 1; n <= N; n ++){\n        //printf(\"ok\");\n        for(int j = 0; j < pow3[N]; j ++){\n            D[n][j] = (j%pow3[n])/pow3[n-1];\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        W[n][0] = pow3[n]-1;\n    }\n\n\n    memset(lastUpdated, 0, sizeof(lastUpdated));\n    int cntS2 = 0;\n    for(int n = 1; n <= N; n ++){\n        int cntS = 0;\n        for(int i = 0; i < M; i ++){\n            int indx0 = W[n-1][i];\n            int indx1 = W[n-1][i]+pow3[n-1];\n            if(indx1 >= pow3[n]){\n                indx1 -= pow3[n];\n            }\n            int indx2 = W[n-1][i]+(pow3[n-1]<<1);\n            if(indx2 >= pow3[n]){\n                indx2 -= pow3[n];\n            }\n\n            update(n, indx0, cntS+(T[i]=='S'));\n            update(n, indx1, cntS+(T[i]=='S'));\n            update(n, indx2, cntS+(T[i]=='S'));\n            if(D[n][indx0] == 2){\n                W[n][i] = indx0;\n            }else if(D[n][indx1] == 2){\n                W[n][i] = indx1;\n            }else{\n                W[n][i] = indx2;\n            }\n\n            if(T[i] == 'R'){\n                D[n][indx0] = (D[n][indx0]+1);\n                D[n][indx1] = (D[n][indx1]+1);\n                D[n][indx2] = (D[n][indx2]+1);\n                if(D[n][indx0] == 3){D[n][indx0] = 0;}\n                if(D[n][indx1] == 3){D[n][indx1] = 0;}\n                if(D[n][indx2] == 3){D[n][indx2] = 0;}\n                lastUpdated[n][indx0] = cntS;\n                lastUpdated[n][indx1] = cntS;\n                lastUpdated[n][indx2] = cntS;\n            }else if(T[i] == 'S'){\n                cntS ++;\n            }\n\n            //printf(\"W[%d][%d]=%d\\n\", n, i+1, W[n][i+1]);\n        }\n\n        cntS2 = cntS;\n    }\n\n    for(int n = 1; n <= N; n ++){\n        for(int i = 0; i < pow3[n]; i ++){\n            update(n, i, cntS2);\n        }\n    }\n\n    for(int i = 0; i < pow3[N]; i ++){\n        int temp = 0;\n        for(int n = 1; n <= N; n ++){\n            temp += D[n][i%pow3[n]]*pow3[n-1];\n        }\n        printf(\"%d \", temp);\n    }\n\n    /*printf(\"\\n\");\n    for(int i = 0; i < pow3[N]; i ++){\n        int temp = 0;\n        for(int n = 0; n < N; n ++){\n            temp += D[n][i%pow3[n+1]]*pow3[n];\n        }\n        printBase3(temp, N);\n        printf(\"\\n\");\n    }*/\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b) for((i)=(a);i<=(b);i++)\n#define rfo(i,a,b) for((i)=(a);i>=(b);i--)\n#define inrange(x,y,z) (((x)>=(y))&&((x)<=(z)))\n#define ALL(vec) ((vec).begin(),(vec).end())\n#define SOR(vec) sort(ALL(vec))\n#define UNI(vec) (vec).erase(unique(ALL(vec)),(vec).end())\nusing namespace std;\nint n,p3[13],tot;\nstring t;\nint son[797170][3],laz[797170],leaf[797170],p[797170];\nvoid push_down(int x){\n\tif(leaf[x]){laz[x]=0;return;}\n\tif(laz[x]){\n\t\tlaz[x]=0;\n\t\tlaz[son[x][0]]^=1;\n\t\tlaz[son[x][1]]^=1;\n\t\tlaz[son[x][2]]^=1;\n\t\tswap(son[x][1],son[x][2]);\n\t}\n\treturn;\n} \nvoid update(int x){\n\tif(leaf[x]) return;\n\tpush_down(x);\n\tupdate(son[x][2]);\n\tint tmp=son[x][0];\n\tson[x][0]=son[x][2];\n\tson[x][2]=son[x][1];\n\tson[x][1]=tmp;\n\treturn;\n}\nvoid build(int x,int level){\n\tif(level==n){leaf[x]=1;return;}\n\tson[x][0]=++tot;build(son[x][0],level+1);\n\tson[x][1]=++tot;build(son[x][1],level+1);\n\tson[x][2]=++tot;build(son[x][2],level+1);\n\treturn;\n}\nvoid dfs(int x,int cu,int level){\n\tif(leaf[x]){p[x-(p3[n]-1)/2]=cu;return;}\n\tpush_down(x);\n\tdfs(son[x][0],cu+p3[level]*0,level+1);\n\tdfs(son[x][1],cu+p3[level]*1,level+1);\n\tdfs(son[x][2],cu+p3[level]*2,level+1);\n\treturn;\n}\nint main(){\n\t#ifdef FILIN\n\t\t#ifndef DavidDesktop\n\t\t\tfreopen(FILIN,\"r\",stdin);\n\t\t\tfreopen(FILOUT,\"w\",stdout);\n\t\t#endif\n\t#endif\n\tios::sync_with_stdio(0);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tcin>>n>>t;\n\tp3[0]=1;\n\tfor(int i=1;i<=n;i++) p3[i]=p3[i-1]*3;\n\ttot=1;\n\tbuild(1,0);\n\tfor(int i=0;i<t.size();i++){\n\t\tif(t[i]=='R') update(1);\n\t\telse laz[1]^=1;\n\t}\n\tdfs(1,0,0);\n\tfor(int i=1;i<=p3[n];i++) cout<<p[i]<<' ';\n\tcout<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\n#define TRACE(x) std::cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n\nusing namespace std;\n\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  int N;\n  string T;\n  cin >> N >> T;\n\n  vector<int> next = {0, 2, 1};\n  vector<int> pw(N + 1);\n  pw[0] = 1;\n  for (int i = 1; i <= N; ++i) pw[i] = pw[i - 1] * 3;\n  int M = pw[N];\n\n  vector<vector<int>> f(N), sw(N);\n  for (int i = 0; i < N; ++i) {\n    f[i].resize(pw[i + 1]);\n    sw[i].resize(pw[i + 1]);\n    for (int j = 0; j < pw[i + 1]; ++j) {\n      f[i][j] = j / pw[i];\n    }\n  }\n\n  int swapsCnt = 0;\n  for (char c : T) {\n    if (c == 'S') {\n      swapsCnt ^= 1;\n    } else {\n      int suf = 0;\n      for (int k = 0; k < N; ++k) {\n        int v = -1;\n        for (int d = 0; d < 3; ++d) {\n          int x = pw[k] * d + suf;\n          if (sw[k][x] != swapsCnt) {\n            f[k][x] = next[f[k][x]];\n            sw[k][x] ^= 1;\n          }\n          f[k][x]++;\n          if (f[k][x] == 3) {\n            f[k][x] = 0;\n            v = d;\n          }\n        }\n        assert(v != -1);\n        suf += pw[k] * v;\n      }\n    }\n  }\n\n  for (int x = 0; x < M; ++x) {\n    int ans = 0, c = x;\n    for (int k = N - 1; k >= 0; --k) {\n      if (sw[k][c] != swapsCnt) {\n        f[k][c] = next[f[k][c]];\n        sw[k][c] ^= 1;\n      }\n      ans += pw[k] * f[k][c];\n      c %= pw[k];\n    }\n    cout << ans << ' ';\n  }\n  cout << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+7;\nint n,m,f[N],g[N],ans[N]; char s[N],t[N];\ninline void write(int u){\n\tif(u>9) write(u/10); putchar(u%10+'0');\n}\nint main(){\n\tcin>>n; int a=1,b=1;\n\tfor(int i=1;i<=n/2;i++) a=a*3;\n\tfor(int i=n/2+1;i<=n;i++) b=b*3;\n\tfor(int i=0;i<a*b;i++){\n\t\tf[i]=f[i/3]*3,g[i]=(g[i]+1)%(a*b);\n\t\tif(i%3==1) f[i]+=2; else if(i%3==2) f[i]++;\n\t}\n\tscanf(\"%s\",s+1),m=strlen(s+1);\n\tfor(int i=0;i<a;i++){\n\t\tint u=i; int len=0;\n\t\tfor(int z=1;z<=m;z++)\n\t\t\tif(s[z]=='S'){\n\t\t\t\tu=f[u];\n\t\t\t\tif(t[len]=='S') len--; else t[++len]='S';\n\t\t\t}\n\t\t\telse if(s[z]=='R'){\n\t\t\t\tif(u+1==a) t[++len]='R',u=0;\n\t\t\t\telse u++;\n\t\t\t}\n\t\tint v=u;\n\t\tfor(int x=0;x<b;x++){\n\t\t\tint u=x;\n\t\t\tfor(int z=1;z<=len;z++)\n\t\t\tif(t[z]=='S') u=f[u];\n\t\t\telse if(t[z]=='R'){\n\t\t\t\tif(u+1==b) u=0;\n\t\t\t\telse u++;\n\t\t\t}\n\t\t\tans[i+x*a]=u*a+v;\n\t\t}\n\t}\n\tfor(int i=0;i<a*b;i++) write(ans[i]),putchar(' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\ntypedef long long LL;\n#define rep(i,N) for(LL i=0;i<(LL)N;i++)\nconst LL sz=531441;\nint N,x,y,th,P[sz],t[13]={0},TRI,pw3[13]={1};\nchar c='-',tmp,T[200001];\nvoid init(void){rep(i,3*TRI)P[i]=i;}\ninline LL IN(void)\n{\n  LL x=0;short f=0,c=getchar();\n  while(c<48||c>57)f^=c==45,c=getchar();\n  while(c>47&&c<58)x=x*10+c-48,c=getchar();\n  return f?-x:x;\n}\nvoid sal(char &c)\n{\n  if(c=='R'){rep(i,3*TRI){P[i]++;if(P[i]==3*TRI)P[i]=0;}return;}\n  if(c=='S')rep(trit,3*TRI)\n  {\n    x=P[trit];y=0;\n    rep(i,13)\n    {\n      y++;t[i]=x%3;\n      if(t[i]==1)t[i]=2;else if(t[i]==2)t[i]=1;else t[i]=0;\n      if(x<3)break;\n      x/=3;\n    }\n    x=0;\n    rep(i,y)x+=t[i]*pw3[i];\n    if(x==3*TRI)x=0;\n    P[trit]=x;\n  }\n}\nsigned main(void)\n{\n  int p=0,count=0;\n  N=IN();\n  while(c!=EOF)\n  {\n    c=getchar();if(c==EOF)break;T[p]=c;\n    if(c=='S'&&tmp=='S'){if(count%2==0)p--;count++;tmp=T[p-1];}\n    else{p++;tmp=c;count=0;}\n  }\n  rep(i,N)if(i>0)pw3[i]=pw3[i-1]*3;else pw3[i]=1;\n  TRI=pw3[N-1],init();\n  rep(i,p){sal(T[i]);}\n  rep(i,3*TRI)printf(\"%d \",P[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar T[550005];\nint salsa2[550005];\nint salsaNext[550005];\nint p[550005];\n\n// Based on editorial solution\nint D[13][550005]; // one digit at a time, with digit 0 representing the ones place\nint W[13][550005];\nint lastUpdated[13][550005];\n\nint N;\n\nint salsa(int x){\n    int temp = x;\n    int pow3 = 1;\n    int res = 0;\n    for(int i = 0; i < N; i ++){\n        int k = temp%3;\n        temp /= 3;\n\n        if(k == 1){\n            res += pow3*2;\n        }else if(k == 2){\n            res += pow3;\n        }\n        pow3 *= 3;\n    }\n    return res;\n}\n\nvoid update(int n, int indx, int cntS){\n    if((cntS&1) != (lastUpdated[n][indx]&1)){\n        // conduct salsa\n        if(D[n][indx] == 1){\n            D[n][indx] = 2;\n        }else if(D[n][indx] == 2){\n            D[n][indx] = 1;\n        }\n    }\n    // updated the lastUpdated index\n    lastUpdated[n][indx] = cntS;\n}\n\nint digits[15];\nvoid printBase3(int x, int N){\n    for(int i = 0; i < N; i ++){\n        digits[i] = x%3;\n        x /= 3;\n    }\n    for(int i = N-1; i >= 0; i --){\n        printf(\"%d\", digits[i]);\n    }\n}\n\nint pow3[16];\n\nint main(){\n    scanf(\"%d\", &N);\n\n    scanf(\" %s\", T);\n\n    int M = strlen(T);\n\n    pow3[0] = 1;\n    for(int i = 1; i <= N; i ++){\n        pow3[i] = pow3[i-1]*3;\n    }\n\n    int pow3N = pow3[N];\n\n    for(int i = 0; i < pow3N; i ++){\n        salsa2[i] = salsa(i);\n        //printf(\"salsa2[%d]=%d\\n\", i, salsa2[i]);\n    }\n\n    //printf(\"ok\");\n    memset(W, 0, sizeof(W));\n    for(int n = 1; n <= N; n ++){\n        //printf(\"ok\");\n        for(int j = 0; j < pow3[N]; j ++){\n            D[n][j] = (j%pow3[n])/pow3[n-1];\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        W[n][0] = pow3[n]-1;\n    }\n\n\n    memset(lastUpdated, 0, sizeof(lastUpdated));\n    int cntS2 = 0;\n    for(int n = 1; n <= N; n ++){\n        int cntS = 0;\n        for(int i = 0; i < M; i ++){\n            int indx0 = W[n-1][i];\n            int indx1 = (W[n-1][i]+pow3[n-1])%pow3[n];\n            int indx2 = (W[n-1][i]+2*pow3[n-1])%pow3[n];\n            //printf(\"W(%d, %d): %d %d %d cntS=%d\\n\", n, i, indx0, indx1, indx2, cntS);\n\n            /*if(n == 0){\n                if(T[i] == 'S'){\n                    W[n][i+1] = salsa2[W[n][i]];\n                }else if(T[i] == 'R'){\n                    int temp = (W[n][i]-1);\n                    if(temp < 0){temp += pow3[n+1];}\n                    if(temp >= pow3[n+1]){temp -= pow3[n+1];}\n                    W[n][i+1] = temp;\n                }\n            }*/\n\n            update(n, indx0, cntS+(T[i]=='S'));\n            update(n, indx1, cntS+(T[i]=='S'));\n            update(n, indx2, cntS+(T[i]=='S'));\n            if(D[n][indx0] == 2){\n                W[n][i] = indx0;\n            }else if(D[n][indx1] == 2){\n                W[n][i] = indx1;\n            }else if(D[n][indx2] == 2){\n                W[n][i] = indx2;\n            }\n\n            if(T[i] == 'R'){\n                D[n][indx0] = (D[n][indx0]+1)%3;\n                D[n][indx1] = (D[n][indx1]+1)%3;\n                D[n][indx2] = (D[n][indx2]+1)%3;\n                lastUpdated[n][indx0] = cntS;\n                lastUpdated[n][indx1] = cntS;\n                lastUpdated[n][indx2] = cntS;\n            }\n\n\n\n            if(T[i] == 'S'){\n                cntS ++;\n            }\n\n            //printf(\"W[%d][%d]=%d\\n\", n, i+1, W[n][i+1]);\n        }\n\n        cntS2 = cntS;\n    }\n\n    for(int n = 1; n <= N; n ++){\n        for(int i = 0; i < pow3[n]; i ++){\n            update(n, i, cntS2);\n        }\n    }\n\n    for(int i = 0; i < pow3[N]; i ++){\n        int temp = 0;\n        for(int n = 1; n <= N; n ++){\n            temp += D[n][i%pow3[n]]*pow3[n-1];\n        }\n        //printf(\"i=%d W[N-1][M]=%d temp=%d\\n\", i, W[N-1][M], temp);\n        if(i == W[N][M]){\n            if(temp != pow3[N]-1){\n                //exit(1);\n            }\n        }\n        printf(\"%d \", temp);\n    }\n\n    /*printf(\"\\n\");\n    for(int i = 0; i < pow3[N]; i ++){\n        int temp = 0;\n        for(int n = 0; n < N; n ++){\n            temp += D[n][i%pow3[n+1]]*pow3[n];\n        }\n        printBase3(temp, N);\n        printf(\"\\n\");\n    }*/\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    \n    int N; cin >> N;\n    string T; cin >> T;\n\n    vector<int> C = {1};\n    for (int i = 0; i < N; i++) {\n        C.emplace_back(C.back() * 3);\n    }\n    vector<vector<int>> V(N);\n    vector<int> L1(N), L2(N);\n\n    for (int i = 0; i < N; i++) {\n        V[i].resize(C[i+1]);\n        for (int j = 0; j < C[i+1]; j++) {\n            V[i][j] = j / C[i];\n        }\n        L1[i] = (C[i+1] - 1) / 2;\n        L2[i] = C[i+1] - 1;\n    }\n\n    auto upd = [&](auto &L, int n) {\n        for (int i = 0; i < N; i++) {\n            int X = i == 0 ? 0 : L[i-1];\n            for (int j = 0; j < 3; j++) {\n                int Y = (X + j * C[i]) % C[i+1];\n                if (V[i][Y] == n) {\n                    L[i] = Y; break;\n                }\n            }\n        }\n    };\n    bool sw = false;\n    auto S = [&]() { sw = !sw; };\n    auto R = [&]() {\n        if (!sw) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < 3; j++) {\n                    int X = (L2[i] + j * C[i]) % C[i+1];\n                    V[i][X] = (V[i][X] + 1) % 3;\n                }\n            }\n        } else {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < 3; j++) {\n                    int X = (L1[i] + j * C[i]) % C[i+1];\n                    V[i][X] = (V[i][X] + 2) % 3;\n                }\n            }\n        }\n        upd(L1, 1), upd(L2, 2);\n    };\n\n    for (auto &c: T) {\n        if (c == 'S') S();\n        else R();\n    }\n\n    if (sw) {\n        for (auto &v: V) {\n            for (auto &x: v) {\n                x = (3 - x) % 3;\n            }\n        }\n    }\n\n    for (int i = 0; i < C[N]; i++) {\n        long long x = 0;\n        for (int j = 0; j < N; j++) {\n            x += C[j] * V[j][i%C[j+1]];\n        }\n        if (i) cout << \" \";\n        cout << x;\n    }\n    cout << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 6e5 + 5;\n\nchar s[N];\nint p[N], from[N], last[N];\nint dig[N];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  scanf(\"%s\", s);\n  int len = strlen(s);\n  int pw = 1;\n  fill(last, last+len, 0);\n  for (int i = 0; i < n; ++i) {\n    bool swapped = false;\n    for (int j = 0; j < pw; ++j) {\n      dig[j] = 0;\n      dig[pw + j] = 1;\n      dig[pw * 2 + j] = 2;\n    }\n    for (int j = 0; j < len; ++j) {\n      if (s[j] == 'S') {\n        swapped = !swapped;\n      } else {\n        int add = 0;\n        for (int k = 0; k < 3; ++k) {\n          int now = k * pw + last[j];\n          if (swapped) {\n            if (dig[now] == 1)\n              add = k;\n            if (dig[now] == 0)\n              dig[now] = 2;\n            else if (dig[now] == 1)\n              dig[now] = 0;\n            else\n              dig[now] = 1;\n          } else {\n            if (dig[now] == 2)\n              add = k;\n            dig[now] = (dig[now] + 1) % 3;\n          }\n        }\n        last[j] += add * pw;\n      }\n    }\n    for (int j = 0; j < pw; ++j) {\n      int now = p[j];\n      for (int k = 0; k < 3; ++k) {\n        int cur = j + k * pw;\n        if (swapped && dig[cur] != 0) {\n          dig[cur] = 3 - dig[cur];\n        }\n        p[cur] = now + dig[cur] * pw;\n      }\n    }\n    pw *= 3;\n  }\n  for (int i = 0; i < pw; ++i) {\n    printf(\"%d%c\", p[i], i+1 == pw ? '\\n' : ' ');\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\ntypedef long long LL;\n#define rep(i,N) for(LL i=0;i<(LL)N;i++)\nint N,count=0,x,y,th,P[531441],t[13]={0},TRI,pw3[13]={1};\nchar c,tmp,T[200001],del[200001];\nvoid init(void){rep(i,3*TRI)P[i]=i;}\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* p=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    p=strstr(p,before);if(p==(char*)NULL)break;const char* remain=p+szb;\n    memmove(p+sza,remain,strlen(remain)+1);\n    memcpy(p,after,sza);\n    p+=sza;\n  }\n  return s;\n}\nvoid sal(char &c)\n{\n  if(c=='R'){rep(i,3*TRI){P[i]++;if(P[i]==3*TRI)P[i]=0;}return;}\n  if(c=='S')rep(trit,3*TRI)\n  {\n    x=P[trit];y=0;\n    rep(i,13)\n    {\n      y++;t[i]=x%3;\n      if(t[i]==1)t[i]=2;else if(t[i]==2)t[i]=1;else t[i]=0;\n      if(x<3)break;\n      x/=3;\n    }\n    x=0;\n    rep(i,y)x+=t[i]*pw3[i];\n    if(x==3*TRI)x=0;\n    P[trit]=x;\n  }\n}\nsigned main(void)\n{\n  count=scanf(\"%d %s\",&N,T);\n  rep(i,N+1)if(i>0)pw3[i]=pw3[i-1]*3;else pw3[i]=1;\n  rep(i,pw3[N])del[i]='R';\n  replace(T,\"SS\",\"\");replace(T,del,\"\");\n  if(T[0]=='\\n')return 0;\n  TRI=pw3[N-1],init();count=strlen(T);\n  rep(i,count)sal(T[i]);\n  rep(i,3*TRI)printf(\"%d%c\",P[i],i+1==3*TRI?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cassert>\n#include<stdexcept>\n#include<utility>\n#include<functional>\n#include<numeric>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<array>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<complex>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<bitset>\n#include<memory>\nusing namespace std;\nusing ll=long long;\n\nconst int SZ = 10;\nint n;\nint pow3n;\nvector<int> sal;\nvoid init_s(){\n    sal.resize(pow3n);\n    iota(sal.begin(),sal.end(),0);\n    for(int i=0;i<pow3n;i++){\n        int x = i;\n        int tar = 0;\n        int r = 1;\n        for(int j=0;j<n;j++){\n            tar+= (x%3*2)%3*r;\n            x/=3;\n            r*=3;\n        }\n        if(tar<i){\n            // cerr<<i<<\" \"<<tar<<endl;\n            swap(sal[tar],sal[i]);\n        }\n    }\n}\n\nint ary[1000000];\nvoid do_rx(vector<int>& pat,int t){\n    t = t%pow3n;\n    for(int i=t;i<pow3n;i++) ary[i] = pat[i-t];\n    for(int i=0;i<t;i++) ary[i] = pat[pow3n-t+i];\n    for(int i=0;i<pow3n;i++) pat[i] = ary[i];\n}\n\nvoid do_r(vector<int>& pat){\n    int head = pat[pow3n-1];\n    for(int i=pow3n-1;i>0;i--){\n        pat[i]=pat[i-1];\n    }\n    pat[0] = head;\n}\n\nvoid perm(vector<int>& pat,vector<int>& par){\n    for(int i=0;i<pow3n;i++) ary[i] = pat[par[i]];\n    for(int i=0;i<pow3n;i++) pat[i] = ary[i];\n}\nvoid do_s(vector<int>& pat){\n    perm(pat,sal);\n}\nint main(){\n    cin>>n;\n    pow3n=1;\n    for(int i=0;i<n;i++) pow3n*=3;\n    init_s();\n    \n    string t;\n    {\n        string tmp;\n        cin>>tmp;\n        for(auto c:tmp){\n            if(!t.empty() && t.back()=='S' && c=='S') t.pop_back();\n            else t+=c;\n        }\n    }\n\n    vector<vector<int>> memo(1<<SZ);\n    \n    for(int bit=0;bit<(1<<SZ);bit++){\n        bool ispass= false;\n        for(int j=0;j+1<SZ;j++){\n            if(((bit>>j)&1)==0 && ((bit>>(j+1)))==0) ispass=true;\n        }\n        if(ispass) continue;\n\n        memo[bit].resize(pow3n);\n        iota(memo[bit].begin(),memo[bit].end(),0);\n        for(int j=0;j<SZ;j++){\n            if(((bit>>j)&1)==0) do_s(memo[bit]);\n            else do_r(memo[bit]);\n        }\n    }\n    vector<int> res(pow3n);\n    iota(res.begin(),res.end(),0);\n    int l = 0;\n    while(t.size()-l>=SZ){\n        int r;\n        for(r=l;r<t.size();r++){\n            if(t[r]=='S') break;\n        }\n        if(r-l>=SZ){\n            do_rx(res,r-l);\n            l=r;\n        }\n        else{\n            int bit = 0;\n            for(int j=0;j<SZ;j++){\n                if(t[l+j]=='R') bit+=(1<<j);\n            }\n            perm(res,memo[bit]);\n            bit=0;\n            l+=SZ;\n        }\n    }\n\n    for(int i=t.size()/SZ*SZ;i<t.size();i++){\n        // cerr<<\"#\"<<endl;\n        if(t[i]=='S') do_s(res);\n        else do_r(res);\n    }\n    vector<int> inv(pow3n);\n    for(int i=0;i<pow3n;i++) inv[res[i]]=i;\n    for(int i=0;i<pow3n;i++) cout<<inv[i]<<\" \";\n    cout<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "        #include <bits/stdc++.h>\n        using namespace std;\n   #define int long long\nconst int MAX = 510000;\nconst int MOD = 1000000007;\n\n     signed main(){\n int n;\n string t;\n cin>>n>>t;\n int al2[t.size()]={};\n set<int> x[3];int y[3];\n int k=3;\n int kk=1;for(int i=0;i<n;i++)kk*=3;\n int ans[kk]={};\n\n for(int i=0;i<n;i++){\n      x[0].clear();\n      x[1].clear();\n      x[2].clear();\n   for(int j=0;j<k;j++)x[j/(k/3)].insert(j);\n   y[0]=0;y[1]=1;y[2]=2;\n   for(int j=0;j<t.size();j++){\n        if(t[j]=='S'){swap(y[1],y[2]);continue;}\n        int h[3];\n        for(int q=0;q<3;q++){\n             for(int p=0;p<3;p++){\n                  auto it=x[y[q]].find(al2[j]+p*k/3);\n                  if(it!=x[y[q]].end()){\n                       h[q]=al2[j]+p*k/3;\n                       x[y[q]].erase(it);\n                       break;\n                       \n\n                  }\n             }\n        }\n        for(int q=0;q<3;q++)x[y[(q+1)%3]].insert(h[q]);\n        al2[j]=h[2];\n   }\n\n   for(int j=0;j<kk;j++){\n        for(int q=0;q<3;q++){\n          auto it=x[y[q]].find(j%k);\n          if(it!=x[y[q]].end())ans[j]+=q*(k/3);\n        }\n   }\n   k*=3;\n\n }\n for(int i=0;i<kk;i++)cout<<ans[i]<<' ';\n\n\n\n\n\n\n    }\n\n\n\n\n\n      \n\n        \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for (int i = x; i < (int)(n); ++i)\n\nint const N = 12, M = 200000, K = 531441;\nint n, p3[N + 1], an[K];\nchar s[M + 1];\n\nstruct S{\n\tint x;\n\tbool fl;\n\tS* g[3];\n\tS():fl(false) { f(i, 0, 3)g[i] = 0; }\n}*R;\n\nvoid pl(S* &v = R, int m = 0, int x = 0){\n\tv = new S();\n\tif (m == n){\n\t\tv->x = x;\n\t\treturn;\n\t}\n\tpl(v->g[0], m + 1, x);\n\tpl(v->g[1], m + 1, x + p3[m]);\n\tpl(v->g[2], m + 1, x + 2 * p3[m]);\n}\n\nvoid flp(S* v = R){\n\tswap(v->g[1], v->g[2]);\n\tv->fl ^= 1;\n}\n\nvoid sl(S* v){\n\tif (!v->fl)return;\n\tv->fl = false;\n\tflp(v->g[0]);\n\tflp(v->g[1]);\n\tflp(v->g[2]);\n}\n\nvoid ad(S* v = R){\n\tif (!v->g[0])return;\n\tsl(v);\n\tS* t = v->g[2];\n\tv->g[2] = v->g[1];\n\tv->g[1] = v->g[0];\n\tv->g[0] = t;\n\tad(t);\n}\n\nvoid fn(S* v = R, int m = 0, int x = 0){\n\tif (m == n){\n\t\tan[v->x] = x;\n\t\treturn;\n\t}\n\tsl(v);\n\tfn(v->g[0], m + 1, x);\n\tfn(v->g[1], m + 1, x + p3[m]);\n\tfn(v->g[2], m + 1, x + 2 * p3[m]);\n}\n\nint main(){\n\tscanf(\"%d%s\", &n, s);\n\tp3[0] = 1;\n\tf(i, 1, n + 1)p3[i] = p3[i - 1] * 3;\n\tpl();\n\t\n\tint m = strlen(s);\n\tf(i, 0, m)if (s[i] == 'S')flp();\n\telse ad();\n\t\n\tfn();\n\tprintf(\"%d\", an[0]);\n\tf(i, 1, p3[n])printf(\" %d\", an[i]);\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nconst int maxn = 20;\nconst int maxN = 1000000;\nconst int maxt = 2000002;\n\nstruct node {\n\tnode *ch[3];\n\tint lazy, id;\n};\n\nnode* build(int d, int cur);\nvoid pd(node *p);\nvoid change(node *p, int d);\nvoid cal(node *p, int d, int cur);\n\nint n, t;\nchar str[maxt];\nint powd[maxn];\nint ans[maxN];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", str + 1);\n\tt = strlen(str + 1);\n\tpowd[0] = 1;\n\tfor (int i = 1; i < n; i++) {\n\t\tpowd[i] = 3 * powd[i - 1];\n\t}\n\tnode *rt = build(0, 0);\n\tfor (int i = 1; i <= t; i++) {\n\t\tif (str[i] == 'S') rt->lazy ^= 1;\n\t\telse change(rt, 0);\n\t}\n\tcal(rt, 0, 0);\n\tint N = 1;\n\tfor (int i = 1; i <= n; i++) N *= 3;\n\tfor (int i = 0; i < N; i++) {\n\t\tprintf(\"%d \", ans[i]);\n\t}\n\treturn 0;\n}\n\nnode* create() {\n\tstatic node pool[maxN];\n\tstatic node *p = pool;\n\tp->ch[0] = p->ch[1] = p->ch[2] = NULL;\n\tp->lazy = p->id = 0;\n\treturn p++;\n}\n\nnode* build(int d, int cur) {\n\tnode *p = create();\n\tif (d == n) {\n\t\tp->id = cur;\n\t\treturn p;\n\t}\n\tp->ch[0] = build(d + 1, cur);\n\tp->ch[1] = build(d + 1, cur + powd[d]);\n\tp->ch[2] = build(d + 1, cur + powd[d] + powd[d]);\n\treturn p;\n}\n\nvoid pd(node *p) {\n\tif (!p->lazy) return;\n\tswap(p->ch[1], p->ch[2]);\n\tp->ch[0]->lazy ^= 1;\n\tp->ch[1]->lazy ^= 1;\n\tp->ch[2]->lazy ^= 1;\n\tp->lazy = 0;\n}\n\nvoid change(node *p, int d) {\n\tif (d == n) return;\n\tpd(p);\n\tswap(p->ch[0], p->ch[1]);\n\tswap(p->ch[0], p->ch[2]);\n\tchange(p->ch[0], d + 1);\n}\n\nvoid cal(node *p, int d, int cur) {\n\tif (d == n) {\n\t\tans[p->id] = cur;\n\t\treturn;\n\t}\n\tpd(p);\n\tcal(p->ch[0], d + 1, cur);\n\tcal(p->ch[1], d + 1, cur + powd[d]);\n\tcal(p->ch[2], d + 1, cur + powd[d] + powd[d]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n// #include <ext/pb_ds/assoc_container.hpp> \n// #include <ext/pb_ds/detail/standard_policies.hpp>\n// using namespace __gnu_pbds;\n\n#pragma GCC optimize(\"O3\")\n#ifdef LOCAL\n#include \"/Users/lbjlc/Desktop/coding/debug_utils.h\"\n#else\n#define print(...) ;\n#define printn(...) ;\n#define fprint(...) ;\n#define fprintn(...) ;\n#endif\n\n#define rep(i, a, b) for(auto i = (a); i < (b); i++)\n#define rrep(i, a, b) for(auto i = (a); i > (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define pb push_back\n// #define mp make_pair\n#define fi first\n#define se second\n#define maxi(x, y) x = max(x, y)\n#define mini(x, y) x = min(x, y)\n// long long fact(long long n) { if(!n) return 1; return n*fact(n-1); }\n// #define endl '\\n'\n#define solve_testcase int T;cin>>T;for(int t=1;t<=T;t++){solve(t);}\n\n// long long gcd(long long x, long long y) { return y ? gcd(y, x % y) : x; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\n \ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n \ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\ntypedef vector<long long> vll;\n#define bd(type,op,val) bind(op<type>(), std::placeholders::_1, val)\n\nconst int MAXN = 1e6+10;\n\n\nvoid solve(int tt) {\n    // cout<<\"Case #\"<<tt<<\": \";\n}\n\nstring to_ter(int x, int k=-1) {\n    string res;\n    while(x) {\n        res+='0'+x%3;\n        x/=3;\n    }\n    if(k>=0) {\n        while(res.size()<k) res+='0';\n    }\n    return res;\n}\nint to_int(const string & s) {\n    int res=0;\n    // rrep(i,s.size()-1,-1)\n    //     res=res*3+(s[i]-'0');\n    for(int i=s.size()-1;i>=0;i--)\n        res=res*3+(s[i]-'0');\n    // print(s,res);\n    return res;\n}\nbool add(string & x, const string & y) {\n    int n1=x.size(), n2=y.size(),carry=0;\n    rep(i,0,n1) {\n        if(i<n1) carry+=x[i]-'0';\n        if(i<n2) carry+=y[i]-'0';\n        x[i]=carry%3+'0';\n        carry/=3;\n    }\n    return carry==0;\n}\n\nvi cal_inst(string & s) {\n    int n=s.size();\n    vi res(1);\n    int i=0;\n    while(i<n) {\n        if(s[i]=='R') {\n            res.back()++;\n            i++;\n        }\n        else {\n            int j=i;\n            for(;j<n&&s[j]=='S';j++);\n            if((j-i)%2) res.pb(0);\n            i=j;\n        }\n    }\n    if(s.back()=='S') res.pop_back();\n    return res;\n}\n\nchar rev(char c) {\n    if(c>'0') return '0'+(3-(c-'0'));\n    return c;\n}\nstring rev(string s) {\n    for(auto & c:s) c=rev(c);\n    return s;\n}\n\nint len(string & s) {\n    int res=s.size()-1;\n    while(res>=0&&s[res]=='0') res--;\n    return res+1;\n}\n\nint power[13]={};\nint revmap[MAXN]={};\nint tmpres[MAXN];\nint rev(int x) {\n    for(int flag=1;flag<power[12];flag*=3) {\n        int tmp=x/flag%3;\n        if(tmp==1) x+=flag;\n        else if(tmp==2) x-=flag;\n    }\n    return x;\n}\n\nvoid cal(vi inst, int n, int tot) {\n    // vi tmpres(tot,-1);\n    fill(tmpres,tmpres+tot,-1);\n\n    rep(i,0,tot) {\n        if(tmpres[i]>=0) continue;\n\n        int cur=i,ok=1;\n        for(auto x:inst) {\n            cur+=x;\n            if(cur>=power[n]) {\n                ok=0; \n                cur%=power[n];\n            }\n            cur=revmap[cur];\n        }\n        // if(i<=9) print(i,cur);\n        tmpres[i]=cur;\n        // assert(cur>=0);\n        if(!ok) continue;\n        int flag=1,tmp;\n        for(;flag<=i||flag<=cur;flag*=3);\n\n        if(inst.size()%2==0) {\n            for(tmp=flag;tmp<power[n];tmp+=flag) {\n                tmpres[tmp+i]=tmp+cur;\n            }\n        }\n        else {\n            for(tmp=flag;tmp<power[n];tmp+=flag) {\n                tmpres[tmp+i]=revmap[tmp]+cur;\n            }\n\n        }\n    }\n    // print(1);\n    // print(*max_element(all(res)),*min_element(all(res)));\n    // return res;\n}\n\nint main(int argc, char * argv[]) {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    // solve_testcase;\n\n    int n;\n    string s;\n    cin>>n;\n    cin>>s;\n\n    // n=12;\n    // rep(i,0,1e5) s+=\"RS\";\n\n    power[0]=1;\n    rep(i,1,13) power[i]=power[i-1]*3;\n\n    int tot=1;\n    rep(i,0,n) tot*=3;\n\n    rep(i,0,tot) {\n        if(i>=3) {\n            if(i%3==0)\n                revmap[i]=revmap[i/3]*3;\n            else\n                revmap[i]=revmap[i-i%3]+rev(i%3);\n        }\n        else\n            revmap[i]=rev(i);\n    }\n    // printn(revmap,9);\n\n\n    vi inst=cal_inst(s);\n    for(auto & x:inst) x%=tot;\n\n    // print(inst);\n\n    int i=0;\n    int bound=241;\n    vi res(tot);\n    iota(all(res),0);\n    while(i<inst.size()) {\n        int cur=inst[i];\n        vi cur_inst({cur});\n        for(++i;i<inst.size()<bound;i++) {\n            cur+=inst[i];\n            cur_inst.pb(inst[i]);\n        }\n        cal(cur_inst,n,tot);\n        // print(tmp);\n        rep(j,0,tot) res[j]=tmpres[res[j]];\n        // print(cur_inst,tmp);\n        // print(res);\n        // sort(all(tmp)); print(tmp);\n    }\n    if(s.back()=='R') {\n        rep(i,0,tot) {\n            res[i]=revmap[res[i]];\n        }\n    }\n    for(auto x:res) cout<<x<<' ';\n    cout<<endl;\n\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e7 + 5;\nint _w;\n\nint son[N][3] , nidx , val[N] , n , m , rev[N] , bin[13] , rmp[N];\nchar str[N];\n\nvoid pre( int u , int now , int dep ) {\n  if( dep == n ) {\n    val[u] = now;\n    return;\n  }\n  for( int i = 0 ; i < 3 ; ++i ) {\n    son[u][i] = ++nidx;\n    pre( son[u][i] , now + i * bin[dep] , dep + 1 );\n  }\n}\n\nvoid dfs( int u , int dep ) {\n  if( dep == n ) return;\n  if( rev[u] ) {\n    swap( son[u][1] , son[u][2] );\n    rev[son[u][1]] ^= 1;\n    rev[son[u][2]] ^= 1;\n    rev[son[u][0]] ^= 1;\n    rev[u] = 0;\n  }\n  dfs( son[u][2] , dep + 1 );\n  int t = son[u][2];\n  son[u][2] = son[u][1]; son[u][1] = son[u][0];\n  son[u][0] = t;\n}\n\nvoid ans( int u , int now , int dep ) {\n  if( dep == n ) {\n    rmp[val[u]] = now;\n    return;\n  }\n  if( rev[u] ) {\n    swap( son[u][1] , son[u][2] );\n    rev[son[u][2]] ^= 1;\n    rev[son[u][1]] ^= 1;\n    rev[son[u][0]] ^= 1;\n    rev[u] = 0;\n  }\n  for( int i = 0 ; i < 3 ; ++i )\n    ans( son[u][i] , now + i * bin[dep] , dep + 1 );\n}\n\nint main( void ) {\n  _w = scanf(\"%d\",&n); \n  bin[0] = 1;\n  for( int i = 1 ; i <= n ; ++i )\n    bin[i] = bin[i - 1] * 3;\n  pre( 0 , 0 , 0 );\n  _w = scanf(\"%s\",str+1);\n  m = strlen( str + 1 );\n  for( int i = 1 ; i <= m ; ++i ) \n    if( str[i] == 'S' )\n      rev[0] ^= 1;\n    else \n      dfs( 0 , 0 );\n  ans( 0 , 0 , 0 );\n  for( int i = 0 ; i < bin[n] ; ++i )\n    printf(\"%d \",rmp[i]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string>\n#include<cmath>\n\nusing namespace std;\n\nint sch(int n){\n    int out=0,tmp,count=0;\n    while(n != 0){\n        tmp = n % 3;\n        if(tmp==1){\n            out += 2*pow(3,count);\n        }else if(tmp==2){\n            out += pow(3,count);\n        }\n        count++;\n        n /= 3;\n    }\n    return out;\n}\n\nint main(){\n    int N,p,*table,size;\n    string T;\n    cin >> N;\n    cin >> T;\n    size = int(pow(3,N));\n    table = new int[size];\n    for(int i=0;i<size;i++){\n        table[i] = sch(i);\n    }\n    for(int i=0;i<size;i++){\n        p=i;\n        for(int j=0;j<T.length();j++){\n            if(T[j] == 'S'){\n                if(T[j+1] == 'S') j += 2;\n                else p = table[p];\n            }else{\n                p++;\n                if(p==size) p=0;\n            }\n        }\n        cout << p << ' ';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    vector<int> d23(531441);\n    vector<int> rumba(531441);\n\n    int N;\n    cin >> N;\n    N = (int)pow(3,N);\n    \n    int temp,add,now;\n    for(int i = 0 ; i < N ; i++){\n        temp = i;\n        add = 0;\n        now = 1;\n        while(temp != 0){\n            int a = temp % 3;\n            if(a == 1){\n                add += 2 * now;\n            }else if(a == 2){\n                add += now;\n            }\n            now *= 3;\n            temp /= 3;\n        }\n        d23.at(i) = add;\n    }\n\n    for(int i = 0 ; i < N ; i++){\n        rumba.at(i) = i + 1;\n    }\n    rumba.at(N - 1) = 0;\n\n\n    vector<int> hito1(531441);\n\n    for(int i = 0 ; i < N ; i++){\n        hito1.at(i) = i;\n    }\n\n\n    string _T;\n    cin >> _T;\n\n    string TSdata;\n    vector<int> Tdata;\n\n    bool flag = false;\n    int cnt = 0;\n\n    for(int i = 0 ; i < _T.size() ; i++){\n        if(_T.at(i) == 'S'){\n            if(flag){\n                flag = false;\n                continue;\n            }\n            flag = true;\n        }else{\n            if(flag){\n                TSdata.push_back('S');\n                flag = false;\n            }\n            TSdata.push_back('R');\n        }\n    }\n    if(flag){\n        TSdata.push_back('S');\n    }\n    flag = false;\n\n    \n    \n    for(int i = 0 ; i < TSdata.size() ; i++){\n        if(TSdata.at(i) == 'R'){\n            cnt++;\n        }else{\n            if(cnt != 0){\n                Tdata.push_back(cnt);\n                cnt = 0;\n            }\n            Tdata.push_back(0);\n        }\n    }\n    if(cnt != 0){\n        Tdata.push_back(cnt);\n    }\n\n\n    /*for(int i = 0 ; i < _T.size() ; i++){\n        if(_T.at(i) == 'S'){\n            if(cnt != 0){\n                Tdata.push_back(cnt);\n                cnt = 0;\n            }\n            if(flag){\n                flag = false;\n            }else{\n                flag = true;\n            }\n        }else{\n            if(flag){\n                Tdata.push_back(0);\n            }\n            flag = false;\n            cnt++;\n        }\n    }\n    if(flag){\n        Tdata.push_back(0);\n    }\n    if(cnt != 0){\n        Tdata.push_back(cnt);\n    }\n    */\n    int tSize = Tdata.size();\n\n    //for(int i = 0 ; i < Tdata.size() ; i++){\n    //    cout << Tdata.at(i) << ' ';\n    //}\n    //return 0;\n\n    \n\n    for(int i = 0 ; i < tSize ; i++){\n        if(Tdata.at(i) == 0){\n            for(int j = 0 ; j < N ; j++){\n                hito1.at(j) = d23.at(hito1.at(j));\n            }\n        }else{\n            int a = Tdata.at(i);\n            a %= N;\n            for(int j = 0 ; j < N ; j++){\n                hito1.at(j) += a;\n                if(hito1.at(j) >= N){\n                    hito1.at(j) -= N;\n                }\n            }\n        }\n    }\n\n\n    \n    for(int i = 0 ; i < N - 1 ; i++){\n        cout << hito1.at(i) << ' ';\n    }\n    cout << hito1.at(N - 1) << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};\nvector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\nll convert_base(vector<ll>v,ll base){\n  ll tmp=1,ret=0;\n  for(ll i=0;i<v.size();i++){\n    ret+=v[i]*tmp;\n    tmp*=base;\n  }\n  return ret;\n}\nvector<ll>ret(1000000);\nvoid solve(ll n,ll d,vector<ll>&from,vector<ll>&res,string s){\n  //cout<<n spa d spa s<<endl;\n  //debug(from,d);\n  //debug(res,d);\n  if(n==d){\n    ret[convert_base(from,3)]=convert_base(res,3);\n    return;\n  }\n  rep(i,0,3){\n    from.PB(i);\n    res.PB(i);\n    string arg;\n    for(auto c:s){\n      if(c=='S'){\n        if(res[d]==1)res[d]=2;\n        else if(res[d]==2)res[d]=1;\n        if(!arg.empty()&&arg.back()=='S')arg.pop_back();\n        else arg+='S';\n      }\n      else{\n        if(res[d]<2)res[d]++;\n        else{\n          res[d]=0;\n          arg+='R';\n        }\n      }\n    }\n    solve(n,d+1,from,res,arg);\n    from.pop_back();\n    res.pop_back();\n  }\n}\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  string s;cin>>s;\n  ll m=1;\n  rep(i,0,n)m*=3;\n  vector<ll>tmp1,tmp2;\n  solve(n,0,tmp1,tmp2,s);\n  debug(ret,m);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n\n#define putchar_unlocked putchar\n\nchar T[500005];\nint res[531443];\n\n// Based on editorial solution\nint D[13][531443]; // one digit at a time, with digit 0 representing the ones place\nint W[13][531443];\nint lastUpdated[13][531443];\n\nint x[11];\ninline void putInt(int i){\n    if(i==0){putchar_unlocked('0');}\n    else{\n    int count1=0;\n    while(i>0){\n        x[count1++]=i%10;\n        i/=10;\n    }\n    for(int j=count1-1;j>=0;j--){\n        putchar_unlocked(48+x[j]);\n    }\n    }\n    putchar_unlocked(' ');\n}\n\nint N;\n\ninline void update(int n, int indx, int cntS){\n    if( ((cntS&1) != (lastUpdated[n][indx]&1)) && D[n][indx]){\n        // conduct salsa\n        D[n][indx] = 3-D[n][indx];\n    }\n    // update the lastUpdated index\n    lastUpdated[n][indx] = cntS;\n}\n\nint pow3[16];\n\nint main(){\n    scanf(\"%d\", &N);\n    scanf(\" %s\", T);\n\n    int M = strlen(T);\n\n    pow3[0] = 1;\n    for(int i = 1; i <= N; i ++){\n        pow3[i] = pow3[i-1]*3;\n    }\n\n    //memset(W, 0, sizeof(W));\n    int tempNum = 1;\n    for(int n = 1; n <= N; n ++){\n        //printf(\"ok\");\n        for(int j = 0; j < tempNum; j ++){\n            D[n][j] = 0;\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        for(int j = tempNum; j < (tempNum<<1); j ++){\n            D[n][j] = 1;\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        for(int j = (tempNum<<1); j < 3*tempNum; j ++){\n            D[n][j] = 2;\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        W[n][0] = pow3[n]-1;\n        tempNum *= 3;\n    }\n\n    //memset(lastUpdated, 0, sizeof(lastUpdated));\n    int cntS2 = 0;\n    tempNum = 1;\n    int tempNum2 = 3;\n    for(int n = 1; n <= N; n ++){\n        int cntS = 0;\n        for(int i = 0; i < M; i ++){\n            int indx0 = W[n-1][i];\n            int indx1 = W[n-1][i]+tempNum;\n            int indx2 = W[n-1][i]+(tempNum<<1);\n\n            if(indx1 >= tempNum2){indx1 -= tempNum2;}\n            if(indx2 >= tempNum2){indx2 -= tempNum2;}\n\n            update(n, indx0, cntS+(T[i]=='S'));\n            update(n, indx1, cntS+(T[i]=='S'));\n            update(n, indx2, cntS+(T[i]=='S'));\n            if(D[n][indx0] == 2){\n                W[n][i] = indx0;\n            }else if(D[n][indx1] == 2){\n                W[n][i] = indx1;\n            }else{\n                W[n][i] = indx2;\n            }\n\n            if(T[i] == 'R'){\n                if( (++D[n][indx0]) == 3){D[n][indx0] = 0;}\n                if( (++D[n][indx1]) == 3){D[n][indx1] = 0;}\n                if( (++D[n][indx2]) == 3){D[n][indx2] = 0;}\n                lastUpdated[n][indx0] = cntS;\n                lastUpdated[n][indx1] = cntS;\n                lastUpdated[n][indx2] = cntS;\n            }else{\n                cntS ++;\n            }\n\n            //printf(\"W[%d][%d]=%d\\n\", n, i+1, W[n][i+1]);\n        }\n\n        tempNum *= 3;\n        tempNum2 *= 3;\n\n        cntS2 = cntS;\n    }\n\n    for(int n = 1; n <= N; n ++){\n        for(int i = 0; i < pow3[n]; i ++){\n            update(n, i, cntS2);\n        }\n\n        int cnt = 0;\n        for(int i = 0; i < pow3[N]; i ++){\n            res[i] += D[n][cnt++]*pow3[n-1];\n            if(cnt == pow3[n]){cnt = 0;}\n        }\n    }\n\n    for(int i = 0; i < pow3[N]; i ++){\n        /*int temp = 0;\n        for(int n = 1; n <= N; n ++){\n            temp += D[n][i%pow3[n]]*pow3[n-1];\n        }*/\n        //putInt(temp);\n        putInt(res[i]);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,x,y,sw,pw3[13]={1},A[531441],B[531441],S[200001];\nchar T[200001];\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nsigned main(void)\n{\n  x=scanf(\"%d %s\",&N,T);\n  replace(T,\"SS\",\"\");if(T[0]=='\\n')return 0;\n  rep(i,N)\n  {\n    rep(j,pw3[i])rep(k,3)B[j+k*pw3[i]]=k;sw=0;\n    rep(j,strlen(T))\n    {\n      if(T[j]=='R')\n      {\n        y=S[j];\n        rep(k,3){x=y+k*pw3[i];if(B[x]+sw==2)S[j]=x;B[x]+=sw+1;B[x]%=3;}\n      }\n      if(T[j]=='S')sw^=1;\n    }\n    rep(j,pw3[i]){y=A[j];rep(k,3){x=j+k*pw3[i];A[x]=y+(sw?3-B[x]:B[x])%3*pw3[i];}}\n    pw3[i+1]=3*pw3[i];\n  }\n  rep(i,pw3[N])printf(\"%d%c\",A[i],i+1==pw3[N]?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "//BadWaper gg\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<deque>\n#include<bitset>\n#include<map>\n#include<set>\n#define inf 1e9\n#define eps 1e-6\n#define mp make_pair\n#define N 2000010\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ninline ll read()\n{\n\tchar ch=getchar();\n\tll s=0,w=1;\n\twhile(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}\n\treturn s*w;\n}\nint val[N][3],ch[N][3],tot,lazy[N];\nint n;char s[N];\nint ans[N],cnt;\nint rev[N];\ninline void build()\n{\n\ttot=1;for(register int i=1;i<=n+1;i++)tot*=3;\n\ttot=(tot-1)/2;\n\tfor(register int i=1;i<=tot;i++)\n\t{\n\t\tif(i*3<=tot)\n\t\t{\n\t\t\tch[i][0]=i*3-1;ch[i][1]=i*3;ch[i][2]=i*3+1;\n\t\t\tval[i][0]=0;val[i][1]=1;val[i][2]=2;\n\t\t}\n\t}\n}\ninline void pushdown(int now)\n{\n\tif(lazy[now])\n\t{\n\t\tlazy[ch[now][0]]^=1;lazy[ch[now][1]]^=1;lazy[ch[now][2]]^=1;\n\t\tint x=0,y=0;\n\t\tfor(register int i=0;i<3;i++)\n\t\t{\n\t\t\tif(val[now][i]==1)x=i;\n\t\t\tif(val[now][i]==2)y=i;\n\t\t}\n\t\tswap(val[now][x],val[now][y]);\n\t\tlazy[now]=0;\n\t}\n}\nvoid update(int now)\n{\n\tif(now*3>tot)return ;pushdown(now);int pos=0;\n\tfor(register int i=0;i<3;i++)\n\t{\n\t\tval[now][i]++;\n\t\tif(val[now][i]==3)\n\t\t{\n\t\t\tval[now][i]=0;\n\t\t\tpos=ch[now][i];\n\t\t}\n\t}\n\tupdate(pos);\n}\nvoid dfs(int now,int v,int p)\n{\n\tif(now*3>tot){ans[cnt++]=v;return ;}pushdown(now);\n\tfor(register int i=0;i<3;i++)dfs(ch[now][i],v+val[now][i]*p,p*3);\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read();scanf(\"%s\",s+1);\n\tbuild();\n\tint len=strlen(s+1);\n\tfor(register int i=1;i<=len;i++)\n\t{\n\t\tif(s[i]=='R')update(1);\n\t\telse lazy[1]^=1;\n\t}\n\tdfs(1,0,1);\n//\tfor(register int i=0;i<cnt;i++)cout<<ans[i]<<\" \";cout<<endl;\n\tfor(register int i=1;i<cnt;i++)rev[i]=rev[i/3]/3+(cnt/3)*(i%3);\n\tfor(register int i=0;i<cnt;i++)if(i<rev[i])swap(ans[i],ans[rev[i]]);\n\tfor(register int i=0;i<cnt;i++)printf(\"%d \",ans[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nclass people {\npublic:\n\tpeople() { n = 0; }\n\t~people() {\n\t\tif (n != 0) {\n\t\t\tdelete[]trip; delete[]bit;\n\t\t}\n\t}\n\tint pos;\n\tint n;\n\tint num;\n\tint* trip;\n\tint* bit;\n\tvoid init(int _n, int _pos) {\n\t\tn = _n;\n\t\tnum = pow(3, n);\n\t\ttrip = new int[n + 1];\n\t\tbit = new int[n + 1];\n\t\tpos = _pos;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tbit[i] = pow(3, i);\n\t\t}\n\t\tc10to3();\n\t}\n\tvoid c3to10() {\n\t\tint v = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tv += bit[i] * trip[i];\n\t\t}\n\t\tpos = v % num;\n\t}\n\tvoid c10to3() {\n\t\tint v = pos;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ttrip[i] = v % 3;\n\t\t\tv = (v - trip[i]) / 3;\n\t\t}\n\t}\n\tvoid rumba() {\n\t\tpos = (pos + 1) % num;\n\t\tc10to3();\n\t}\n\tvoid sarusa() {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (trip[i] == 1)trip[i] = 2;\n\t\t\telse if (trip[i] == 2)trip[i] = 1;\n\t\t}\n\t\tc3to10();\n\t}\n};\n\nint main() {\n\tint N, num;\n\tchar T[200000];\n\tint* position;\n\tint* p_position;\n\tpeople* p;\n\tstd::cin >> N;\n\tstd::cin >> T;\n\tnum = pow(3, N);\n\tposition = new int[num + 1]();\n\tp_position = new int[num + 1]();\n\tp = new people[num + 1];\n\tfor (int i = 0; i < num; i++) {\n\t\tp[i].init(N, i);\n\t\tp_position[i] = position[i] = i;\n\t}\n\tfor (int i = 0; i < 200000; i++) {\n\t\tif (T[i] == 'S') {\n\t\t\tfor (int j = 0; j < num; j++) {\n\t\t\t\tp[p_position[j]].sarusa();\n\t\t\t\tposition[p[p_position[j]].pos] = p_position[j];\n\t\t\t}\n\t\t}\n\t\telse if (T[i] == 'R') {\n\t\t\tfor (int j = 0; j < num; j++) {\n\t\t\t\tp[p_position[j]].rumba();\n\t\t\t\tposition[p[p_position[j]].pos] = p_position[j];\n\t\t\t}\n\t\t}\n\t\telse break;\n\n\t\tmemcpy(p_position, position, sizeof(int) * num);\n\n\t}\n\tfor (int j = 0; j < num - 1; j++) {\n\t\tstd::cout << p[j].pos << \" \";\n\t}\n\tstd::cout << p[num - 1].pos << std::endl;\n\n\n\tdelete[]p;\n\tdelete[]position;\n\tdelete[]p_position;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2000000 + 10;\nint a[N],b[N],mark[N],p[N],n,S;\nvector<int> v[N];\nchar s[N];\nvoid push(int i){\n    if(mark[i]^S){\n        mark[i] ^= 1;\n        swap(v[i][1],v[i][2]);\n    }\n}\nint main(){\n    scanf(\"%d%s\",&n,s);\n    p[0] = 1; for(int i=1;i<13;i++) p[i] = p[i-1] * 3;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<p[i];j++) v[j] = {0,1,2};\n        S = 0;\n        for(int j=0;s[j];j++){\n            push(b[j]);\n            int nxt = b[j] + p[i] * v[b[j]][2];\n            if(s[j]=='S') S ^= 1;\n            else{\n                swap(v[b[j]][1],v[b[j]][2]), swap(v[b[j]][0],v[b[j]][1]);\n            }\n            b[j] = nxt;\n        }\n        for(int j=0;j<p[i];j++) push(j), mark[j] = 0;\n        for(int j=0;j<p[i];j++){\n            int tmp = a[j];\n            for(int k=0;k<3;k++) a[j+p[i]*v[j][k]] = tmp+p[i]*k;\n        }\n    }\n    for(int i=0;i<p[n];i++) printf(\"%d%c\",a[i],\" \\n\"[i==p[n]-1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n \n//#define int long long\n \n#define pii pair<int, int>\n \n#define x1 x1228\n#define y1 y1228\n \n#define left left228\n#define right right228\n \n#define next next228\n \n#define pb push_back\n#define eb emplace_back\n \n#define mp make_pair                                                                \n                                                                                                                                        \n#define ff first                                                                  \n#define ss second   \n \n#define all(x) x.begin(), x.end()\n#define debug(x) cout << #x << \": \" << x << endl; \n#define TIME (ld)clock()/CLOCKS_PER_SEC\n \nusing namespace std;\ntypedef long long ll; \ntypedef long double ld; \n                                                                                                   \nconst int maxn = 2e5 + 7, mod = 1e9 + 7, MAXN = 1e6 + 7;\nconst double eps = 1e-9;\nconst ll inf = 1e18;\nmt19937 rnd(time(0));\nint n; \nstring s; \nint next[MAXN];\nconst int N = 2187; \nint dp1[N]; \nint dp2[N]; \nint xyz[N]; \n \nint get1(int mask, char q) {\n    if (q == 'R') {\n        ++mask; \n        return mask; \n    }   \n    int ptr = 1; \n    int ans = 0; \n    while (mask) {\n        int t = mask % 3; \n        mask /= 3; \n        if (t == 2) ans += ptr; \n        if (t == 1) ans += 2 * ptr; \n        ptr *= 3; \n    }\n    return ans; \n}\n \nconst int L = 12; \nint pref[maxn]; \nint to[maxn]; \nint kek1[N], kek2[N]; \nint res[N], res1[N]; \nint add = 1; \n \nvoid print(int x) {\n    while (x) {\n        cout << x % 3 << \" \"; \n        x /= 3; \n    }\n    cout << '\\n'; \n}\n\nint get(int x) {\n    vector<int> bts; \n    for (int i = 0; i < L; ++i) {\n        bts.pb(x % 3); \n        x /= 3; \n    }\n    int left = 0;\n    int right = 0; \n    for (int i = 6; i >= 0; --i) {\n        left *= 3;\n        left += bts[i]; \n    }\n    for (int i = L - 1; i >= 7; --i) {\n        right *= 3; \n        right += bts[i]; \n    }\n    int id = 0;         \n    if (left && dp1[left] == -1) {\n        if ((pref[(int)s.size()] - pref[id]) & 1) {        \n            right = xyz[right];     \n        }\n        return res[left] + add * right;   \n    }\n    if (left) {    \n        id = dp1[left]; \n//        print(right); \n        if (pref[id] & 1) {\n            right = xyz[right];             \n        }\n        ++right;\n//        print(right); \n        left = 0; \n    }                     \n    while (next[id] != -1) {        \n        if ((pref[next[id]] - pref[id]) & 1) {\n            right = xyz[right]; \n        }\n        right++; \n        id = next[id];                                                                                                                                         \n    }\n    if ((pref[(int)s.size()] - pref[id]) & 1) {        \n        right = xyz[right];     \n    }\n    left = to[id]; \n    return left + right * add; \n}\n \nvoid solve() {\n    for (int i = 0; i < N; ++i) {\n        xyz[i] = get1(i, 'S') % N; \n    }\n    cin >> n >> s; \n    int t = s.size(); \n    for (int i = 0; i < t; ++i) {\n        pref[i + 1] = pref[i] + (s[i] == 'S'); \n    }\n \n    for (int i = 0; i < N; ++i) dp1[i] = dp2[i] = -1; \n    next[t] = -1;\n    for (int i = 0; i < N; ++i) kek1[i] = i;              \n    for (int i = 0; i < N; ++i) res[i] = i; \n    for (int i = t - 1; i >= 0; --i) {\n        for (int mask = 0; mask < N; ++mask) {\n            int mask1; \n            if (s[i] == 'S') mask1 = xyz[mask]; \n            else mask1 = mask + 1; \n            if (mask1 >= N) mask1 -= N; \n            res1[mask] = res[mask1]; \n            kek2[mask] = kek1[mask1];\n            if (mask && mask1 == 0) {\n                dp2[mask] = i + 1; \n            } else {\n                dp2[mask] = dp1[mask1]; \n            }                                                                                 \n        }\n        to[i] = kek2[0]; \n        next[i] = dp2[0]; \n        for (int mask = 0; mask < N; ++mask) {\n            res[mask] = res1[mask]; \n            kek1[mask] = kek2[mask]; \n            dp1[mask] = dp2[mask]; \n            dp2[mask] = -1; \n        }\n    }\n    for (int i = 0; i < 7; ++i) add *= 3; \n    int tet = 1; \n    for (int i = 0; i < n; ++i) tet *= 3; \n    for (int ptr = 0; ptr < tet; ++ptr) {\n        cout << get(ptr) % tet << \" \"; \n    }\n//    cout << TIME; \n    return; \n}                                \n   \nsigned main() {\n#ifdef LOCAL\n    freopen(\"TASK.in\", \"r\", stdin);\n    freopen(\"TASK.out\", \"w\", stdout);\n#else \n    \n#endif // LOCAL\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20); \n    cout << fixed; \n    int t = 1; \n    for (int i = 0; i < t; ++i) {              \n        solve();\n    }\n    return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<bitset>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(long long)((n)-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();++itr)\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n#define inc(x,y) {x+=(y);if(x>=mod)x-=mod;}\n#define dec(x,y) {x-=(y);if(x<0)x+=mod;}\n#define spln(i,n) (i==n?'\\n':' ')\n#define fac_init(n){fac[0]=fac[1]=inv[1]=fi[0]=fi[1]=1;fz(i,2,n){fac[i]=1ll*fac[i-1]*i%mod;inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;fi[i]=1ll*fi[i-1]*inv[i]%mod;}}\nusing namespace std;\ninline void read(int &x)\n{\n\tchar c;int f=1;\n\twhile(!isdigit(c=getchar()))if(c=='-')f=-1;\n\tx=(c&15);while(isdigit(c=getchar()))x=(x<<1)+(x<<3)+(c&15);\n\tx*=f;\n}\nint n,m,i,j,ch[1400005][3],pw3[21],rev[1400005],id[1400005],cnt,ans[1400005];\nstring st;\nint build(int dep,int l)\n{\n\tint x=++cnt;\n\tif(dep==n){\n\t\tid[x]=l;\n\t\treturn x;\n\t}\n\tint t=pw3[dep];\n\tch[x][0]=build(dep+1,l);\n\tch[x][1]=build(dep+1,l+t);\n\tch[x][2]=build(dep+1,l+t+t);\n\treturn x;\n}\nvoid upd(int x)\n{\n\trev[x]^=1;\n\tswap(ch[x][1],ch[x][2]);\n}\nvoid pushdo(int x)\n{\n\tif(rev[x]){\n\t\tupd(ch[x][0]);\n\t\tupd(ch[x][1]);\n\t\tupd(ch[x][2]);\n\t\trev[x]=0;\n\t}\n}\nvoid sft(int x,int d)\n{\n\tif(d==n) return;\n\tpushdo(x);\n\tint tmp=ch[x][0];\n\tch[x][0]=ch[x][2];\n\tch[x][2]=ch[x][1];\n\tch[x][1]=tmp;\n\tsft(ch[x][0],d+1);\n}\nvoid dfs(int dep,int x,int l)\n{\n\tif(dep==n){\n\t\tans[id[x]]=l;\n\t\treturn;\n\t}\n\tint t=pw3[dep];\n\tdfs(dep+1,ch[x][0],l);\n\tdfs(dep+1,ch[x][1],l+t);\n\tdfs(dep+1,ch[x][2],l+t+t);\n}\nint main()\n{\n\tcin>>n;\n\tpw3[0]=1;\n\tfz1(i,n){\n\t\tpw3[i]=3*pw3[i-1];\n\t}\n\tint rt=build(0,0);\n\tcin>>st;\n\tfz0k(i,st.size()){\n\t\tif(st[i]=='S'){\n\t\t\tupd(rt);\n\t\t}\n\t\telse{\n\t\t\tsft(1,0);\n\t\t}\n\t}\n\tdfs(0,rt,0);\n\tfz0k(i,pw3[n]) printf(\"%d \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ri register int\nusing namespace std;\ntypedef double db;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector <int> poly;\ntypedef pair <int, int> pii;\ntypedef pair <ll, int> pli;\ntypedef pair <int, ll> pil;\ntypedef pair <ll, ll> pll;\ntypedef unsigned long long ulll;\ntypedef unsigned int uii;\ntypedef string strr;\n#define fi first\n#define se second\n#define pb push_back\n#define ppp pop_back\n#define rez resize\nconst ll Inf = 1e18;\nconst int rlen = 1 << 20, inf = 0x3f3f3f3f;\nchar buf[rlen], *ib = buf, *ob = buf;\n#define gc() (((ib == ob) && (ob = (ib = buf) + fread(buf, 1, rlen, stdin)), ib == ob) ? -1 : *ib++)\ninline int read() {\n  static int ans, f;\n  static char ch;\n  ans = 0, ch = gc(), f = 1;\n  while (!isdigit(ch)) f ^= ch == '-', ch = gc();\n  while (isdigit(ch)) ans = (ans << 3) + (ans << 1) + (ch ^ 48), ch = gc();\n  return f ? ans: -ans;\n}\ninline ll readl() {\n  static ll ans;\n  static char ch;\n  for (ans = 0, ch = gc(); !isdigit(ch); ch = gc());\n  while (isdigit(ch)) ans = ((ans << 2) + ans << 1) + (ch ^ 48), ch = gc();\n  return ans;\n}\ninline int Read(char *s) {\n  static int top;\n  static char ch;\n  top = 0, ch = gc();\n  while (!isalpha(ch) && !isdigit(ch)) ch = gc();\n  while (isalpha(ch) || isdigit(ch)) s[++top] = ch, ch = gc();\n  return top;\n}\nnamespace modular {\n  const int mod = 998244353;\n  int ret;\n  inline int add(int a, int b) { return a + b < mod ? a + b : a + b - mod; }\n  inline int dec(int a, int b) { return a < b ? a - b + mod : a - b; }\n  inline int mul(int a, int b) { return (ll) a * b % mod; }\n  inline void Add(int &a, int b) { a = a + b < mod ? a + b : a + b - mod; }\n  inline void Dec(int &a, int b) { a = a < b? a - b + mod : a - b; }\n  inline void Mul(int &a, int b) { a = (ll) a * b % mod; }\n  inline int ksm(int a, int p) {\n    for (ret = 1; p; p >>= 1, Mul(a, a)) (p & 1) && (Mul(ret, a), 1);\n    return ret;\n  }\n  inline int Inv(int a) { return ksm(a, mod - 2); }\n  inline int sqr(int a) { return (ll) a * a % mod; }\n  inline int cub(int a) { return (ll) a * a % mod * a % mod; }\n} using namespace modular;\ntemplate <typename T> inline void ckmax(T &a, T b) { a < b ? a = b : 0; }\ntemplate <typename T> inline void ckmin(T &a, T b) { a > b ? a = b : 0; }\ntemplate <typename T> inline T Abs(T a) { return a < 0 ? -a : a; }\ntemplate <typename T> inline T gcd(T a, T b) {\n  T t;\n  while (b) t = a, a = b, b = t - t / a * a;\n  return a;\n}\nconst int N = 1e6 + 5;\nint n, m, res[N];\nchar s[N];\nnamespace Trie {\n  int tot = 0, son[N][3], id[N];\n  bool rev[N];\n  inline void pushnow(int p) {\n    rev[p] ^= 1;\n    swap(son[p][1], son[p][2]);\n  }\n  inline void pushdown(int p) {\n    if (rev[p]) {\n      rev[p] ^= 1;\n      if (son[p][0]) pushnow(son[p][0]);\n      if (son[p][1]) pushnow(son[p][1]);\n      if (son[p][2]) pushnow(son[p][2]);\n    }\n  }\n  inline void build(int &p, int dep, int ss = 0, int pw = 1) {\n    p = ++tot;\n    if (dep == n) {\n      id[p] = ss;\n      return;\n    }\n    for (ri i = 0; i < 3; ++i) build(son[p][i], dep + 1, ss + pw * i, pw * 3);\n  }\n  inline void upd(int p, int dep) {\n    if (dep == n) return;\n    pushdown(p);\n    swap(son[p][1], son[p][2]);\n    swap(son[p][0], son[p][1]);\n    upd(son[p][0], dep + 1);\n  }\n  inline void dfs(int p, int dep, int ss = 0, int pw = 1) {\n    if (dep == n) {\n      res[id[p]] = ss;\n      return;\n    }\n    pushdown(p);\n    for (ri i = 0; i < 3; ++i) dfs(son[p][i], dep + 1, ss + pw * i, pw * 3);\n  }\n}\nint rt;\nint main() {\n  #ifdef ldxcaicai\n  freopen(\"lx.in\", \"r\", stdin);\n  #endif\n  n = read();\n  Trie:: build(rt, 0);\n  m = Read(s);\n  for (ri i = 1; i <= m; ++i) {\n    if (s[i] == 'S') Trie:: pushnow(rt);\n    else Trie:: upd(rt, 0);\n  }\n  Trie:: dfs(rt, 0);\n  int mt = 1;\n  for (ri i = 1; i <= n; ++i) mt *= 3;\n  for (ri i = 0; i < mt; ++i) cout << res[i] << ' ';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define N 200020\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n,m,pw3[233],ans[N<<2],cnt,root;\nchar s[N];\nstruct node{\n\tint ch[3],val;\n\tbool rev;\n\tvoid Rev(){\n\t\trev^=1;\n\t\tswap(ch[1],ch[2]);\n\t}\n}t[N<<3];\nvoid build(int &u,int dep,int val){\n\tu=++cnt;\n\tif(dep==n){\n\t\tt[u].val=val;\n\t\treturn;\n\t}\n\tfor(int i=0;i<3;++i){\n\t\tbuild(t[u].ch[i],dep+1,val+pw3[dep]*i);\n\t}\n}\ninline void pushdown(int u){\n\tif(t[u].rev){\n\t\tfor(int i=0;i<3;++i){\n\t\t\tt[t[u].ch[i]].Rev();\n\t\t}\n\t\tt[u].rev=0;\n\t}\n}\nvoid _plus(int u){\n\tpushdown(u);\n\tif(t[u].ch[2])_plus(t[u].ch[2]);\n\tswap(t[u].ch[1],t[u].ch[2]);\n\tswap(t[u].ch[0],t[u].ch[1]);\n}\nvoid dfs(int u,int dep,int myh){\n\tif(dep==n){\n\t\tans[t[u].val]=myh;\n\t\treturn;\n\t}\n\tpushdown(u);\n\tfor(int i=0;i<3;++i){\n\t\tdfs(t[u].ch[i],dep+1,myh+pw3[dep]*i);\n\t}\n}\nint main(){\n\tn=read();\n\tpw3[0]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tpw3[i]=pw3[i-1]*3;\n\t}\n\tbuild(root,0,0);\n\tscanf(\"%s\",s+1);\n\tm=strlen(s+1);\n\tfor(int i=1;i<=m;++i){\n\t\tif(s[i]=='S'){\n\t\t\tt[1].Rev();\n\t\t}\n\t\telse{\n\t\t\t_plus(root);\n\t\t}\n\t}\n\tdfs(root,0,0);\n\tfor(int i=0;i<pw3[n];++i){\n\t\tprintf(\"%d \",ans[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<deque>\n#include<iomanip>\n#include<tuple>\n#include<cassert>\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<int,int> P;\ntypedef pair<LL,int> LP;\nconst int INF=1<<30;\nconst LL MAX=1e9+7;\n\nvoid array_show(int *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%d%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\nvoid array_show(LL *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%lld%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\nvoid array_show(vector<int> &vec_s,int vec_n=-1,char middle=' '){\n\tif(vec_n==-1)vec_n=vec_s.size();\n\tfor(int i=0;i<vec_n;i++)printf(\"%d%c\",vec_s[i],(i!=vec_n-1?middle:'\\n'));\n}\nvoid array_show(vector<LL> &vec_s,int vec_n=-1,char middle=' '){\n\tif(vec_n==-1)vec_n=vec_s.size();\n\tfor(int i=0;i<vec_n;i++)printf(\"%lld%c\",vec_s[i],(i!=vec_n-1?middle:'\\n'));\n}\n\nvector<vector<int>> v1[15];\nvector<vector<int>> vs;\n\nint main(){\n\tint n,m;\n\tint i,j,k;\n\tint a,b,c;\n\ta=0;\n\tstring sa;\n\tcin>>n;\n\tcin>>sa;\n\tv1[0].push_back(vector<int>());\n\tfor(i=0;i<sa.size();i++){\n\t\tif(sa[i]=='R')a++;\n\t\telse if(i+1<sa.size() && sa[i+1]=='S')i++;\n\t\telse{\n\t\t\tv1[0][0].push_back(a);\n\t\t\ta=0;\n\t\t}\n\t}\n\tv1[0][0].push_back(a);\n\tvs.push_back(vector<int>(1,0));\n\n\tfor(i=0;i<n;i++){\n\t\tc=pow(3,i);\n\t\tvs.push_back(vector<int>());\n\t\tfor(j=0;j<v1[i].size();j++){\n\t\t\tfor(k=0;k<3;k++){\n\t\t\t\tv1[i+1].push_back(vector<int>());\n\t\t\t\ta=k;\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(auto node:v1[i][j]){\n\t\t\t\t\tif(cnt && a>0)a=3-a;\n\t\t\t\t\ta+=node,cnt++;\n\t\t\t\t\tb=a/3;a%=3;\n\t\t\t\t\tv1[i+1].back().push_back(b);\n\t\t\t\t\tif(b==0 && !v1[i+1].back().empty() && v1[i+1].back().back()==0 && cnt!=v1[i][j].size()){\n\t\t\t\t\t\tv1[i+1].back().pop_back();\n\t\t\t\t\t}else v1[i+1].back().push_back(b);\n\t\t\t\t}\n\t\t\t\tvs[i+1].push_back(vs[i][j]+c*a);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tc=pow(3,n);\n\tvector<int> v2(c,-1);\n\tvector<int> vt(n,0);\n\tfor(i=0;i<c;i++){\n\t\ta=0;\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(vt[j]>=3)vt[j]-=3,vt[j+1]++;\n\t\t\ta*=3;\n\t\t\ta+=vt[j];\n\t\t}\n\t\tv2[a]=vs[n][i];\n\t\tvt[0]++;\n\t}\n\tarray_show(v2);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,o,p,x,y,pos,pw3[13]={1},A[531441],salsa[531441],sw[1000001];\nchar T[200001];\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nvoid Dance(char c[])\n{\n  if(c[p]==EOF)return;\n  if(c[p]=='S'){x=salsa[x];if(sw[pos]>0)pos--;else sw[++pos]=1;}\n  if(c[p]=='R'){x++;if(x==pw3[N/2])sw[++pos]=-1,x=0;}\n}\nvoid Update(void)\n{\n  rep(i,pw3[N-N/2])\n  {\n    y=i;\n    rep(j,pos){if(sw[j+1]>0)y=salsa[y];else if(sw[j+1]<0){if((++y)==pw3[N-N/2])y=0;}}\n    A[o+i*pw3[N/2]]=y*pw3[N/2]+x;\n  }\n}\nsigned main(void)\n{\n  o=scanf(\"%d %s\",&N,T);\n  replace(T,\"SS\",\"\");if(T[0]=='\\n')return 0;\n  rep(i,N)pw3[i+1]=3*pw3[i];\n  rep(i,pw3[N])salsa[i]=salsa[i/3]*3+(3-i%3)%3;\n  rep(i,pw3[N/2]){o=i,x=i,pos=0;rep(j,strlen(T)){p=j,Dance(T);}Update();}\n  rep(i,pw3[N])printf(\"%d%c\",A[i],i+1==pw3[N]?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint len;\nstring s[62];\nint step;\nint ask(string s){\n\tcout << \"? \" << s << endl;\n\tint x;\n\tcin >> x;\n\treturn x;\n}\nstring solve(int l,int r){\n\tif(l==r) return s[l];\n\tint m=(l+r)>>1;\n\tstring L=solve(1,m),R=solve(m+1,r);\n\tif(L.empty()) return R;\n\tif(R.empty()) return L;\n\tstring ret;int i=0,j=0;\n\tfor(;i<L.size()||j<R.size();)\n\t\tif(i<L.size() && (j==R.size() || ask(ret+L[i]+string(R.begin()+j,R.end()))\n\t\t\t\t==len-ret.size()-1-(R.size()-j))) ret = ret + L[i++];\n\t\telse\tret = ret + R[j++];\n\treturn ret;\n}\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);\n\tint p=0;char c;\n\tfor(c='a';c<='z';++c)s[p++]=string(128-ask(string(128,c)),c);\n\tfor(c='A';c<='Z';++c)s[p++]=string(128-ask(string(128,c)),c);\n\tfor(c='0';c<='9';++c)s[p++]=string(128-ask(string(128,c)),c);\n\tfor(auto u:s)len+=u.size();\nauto zz=solve(0,61);\nassert(zz.size()<=128 && zz.size()==len);\n\tcout<<\"! \"<<zz<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nProblem :\nAlgorithm :\nStatus :\n*/\n#include<bits/stdc++.h>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cstdlib>\n#define DEBUG printf(\"Passing Line %d in Function [%s].\\n\",__LINE__,__FUNCTION__);\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int INF = 0x3f3f3f3f;\nconst int MAXN = 6377292 + 5;\nconst int BASE = 3;\n\nint n,m;\nint bin[MAXN],ans[MAXN];\nchar s[MAXN];\n\nnamespace Trie{\n    int tot = 1;\n    int trie[MAXN][3],val[MAXN],tag[MAXN];\n\n    void Build(int k,int dep,int num){\n        if(dep == n){\n            val[k] = num;\n            return;\n        }\n        for(int i = 0;i < BASE;i++){\n            trie[k][i] = ++tot;\n            Build(trie[k][i],dep + 1,num + i * bin[dep]);\n        }\n    }\n\n    void down(int k){\n        if(tag[k]){\n            swap(trie[k][1],trie[k][2]);\n            tag[k] = 0;\n            for(int i = 0;i < BASE;i++)\n                tag[trie[k][i]] ^= 1;\n        }\n    }\n\n    void dfs(int k,int dep,int num){\n        if(dep == n){\n            ans[val[k]] = num;\n            return;\n        }\n        down(k);\n        for(int i = 0;i < BASE;i++)\n            dfs(trie[k][i],dep + 1,num + i * bin[dep]);\n    }\n\n    void Add(int k,int dep){\n        if(dep == n)\n            return;\n        down(k);\n        Add(trie[k][2],dep + 1);\n        swap(trie[k][0],trie[k][1]);\n        swap(trie[k][0],trie[k][2]);\n    }\n}\n\n int main(){\n//     freopen(\"data.in\",\"r\",stdin);\n//     freopen(\"data.out\",\"w\",stdout);\n    scanf(\"%d\",&n);\n    scanf(\"%s\",s + 1);\n    m = strlen(s + 1);\n    bin[0] = 1;\n    for(int i = 1;i <= n;i++)\n        bin[i] = bin[i - 1] * BASE;\n    Trie::Build(1,0,0);\n    for(int i = 1;i <= m;i++){\n        if(s[i] == 'S')\n            Trie::tag[1] ^= 1;\n        else if(s[i] == 'R')\n            Trie::Add(1,0);\n    }\n    Trie::dfs(1,0,0);\n    for(int i = 0;i < bin[n];i++)\n        printf(\"%d \",ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<deque>\n#include<iomanip>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int maxn=6e5;\nint num[13];\nint a[13][maxn];\nint b[13][maxn];\nint p[13];\nint n,t;\nchar ch;\nint s;\nchar ss[maxn];\n\nvoid init()\n{\n    num[0]=1;\n    for(int i=1;i<13;i++)num[i]=num[i-1]*3;\n    for(int i=1;i<13;i++){\n        for(int j=0;j<num[i-1];j++){\n            a[i][j]=0;\n            a[i][j+num[i-1]]=1;\n            a[i][j+2*num[i-1]]=2;\n            b[i][j]=0;\n            b[i][j+num[i-1]]=0;\n            b[i][j+2*num[i-1]]=0;\n        }\n    }\n}\n\nvoid add(int x,int p)\n{\n    if(x>n)return;\n    if(b[x][p]!=s){\n        if((s-b[x][p])%2==1){\n            if(a[x][p]==1)a[x][p]=2;\n            else if(a[x][p]==2)a[x][p]=1;\n        }\n        b[x][p]=s;\n    }\n    a[x][p]+=1;\n    if(a[x][p]==3){\n        a[x][p]=0;\n        add(x+1,p);\n        add(x+1,p+num[x]);\n        add(x+1,p+2*num[x]);\n    }\n}\n\nvoid pp()\n{\n    for(int i=1;i<=n;i++){\n        for(int j=0;j<num[i];j++){\n            if(b[i][j]!=s){\n                if((s-b[i][j])%2==1){\n                    if(a[i][j]==1)a[i][j]=2;\n                    else if(a[i][j]==2)a[i][j]=1;\n                }\n            }\n            b[i][j]=s;\n            //cout<<a[i][j];\n        }\n        //cout<<endl;\n    }\n}\nvoid pp2()\n{\n    for(int i=1;i<=n;i++){\n        for(int j=0;j<num[i];j++){\n            if(b[i][j]!=s){\n                if((s-b[i][j])%2==1){\n                    if(a[i][j]==1)cout<<2;\n                    else if(a[i][j]==2)cout<<1;\n                    else cout<<0;\n                }\n                else cout<<a[i][j];\n            }\n            else cout<<a[i][j];\n        }\n        cout<<endl;\n    }\n}\nint main() {\n    cin>>n;\n    cin>>ss;\n    t=strlen(ss);\n    init();\n    for(int i=0;i<t;i++){\n        ch=ss[i];\n        if(ch=='S')s++;\n        else {\n            add(1,0);\n            add(1,1);\n            add(1,2);\n        }\n    }\n    pp();\n    for(int i=0;i<num[n];i++){\n        int ans=0;\n        for(int i=1;i<=n;i++){\n            ans+=a[i][p[i]]*num[i-1];\n            p[i]+=1;\n            if(p[i]==num[i])p[i]=0;\n        }\n        cout<<ans<<' ';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint tag[531441];\n\nvoid solve(int n,const string& T,vector<int> &perm,vector<int> &pos){\n\tif(n==0){\n\t\tperm={0};\n\t\tpos=vector<int>(T.size(),0);\n\t\treturn;\n\t}\n\tvector<int> pe,po;\n\tsolve(n-1,T,pe,po);\n\tpos.resize(T.size());\n\tperm.resize(pe.size()*3);\n\tvector<int> msb;\n\tfor(int i=0;i<3;i++)\n\t\tfor(int j=0;j<pe.size();j++)\n\t\t\tmsb.emplace_back(i);\n\tmemset(tag,0,sizeof tag);\n\tint t=0;\n\tfor(int i=0;i<T.size();i++){\n\t\tfor(int j=po[i];j<msb.size();j+=pe.size()){\n\t\t\tif(tag[j]%2!=t%2)\tif(msb[j])\tmsb[j]=3-msb[j];\n\t\t\ttag[j]=t;\n\t\t\tif(msb[j]==2)\tpos[i]=j;\n\t\t}\n\t\tif(T[i]=='S')\tt++;\n\t\telse{\n\t\t\tfor(int j=po[i];j<msb.size();j+=pe.size())\n\t\t\t\tmsb[j]=(msb[j]+1)%3;\n\t\t}\n\t}\n\tfor(int i=0;i<perm.size();i++){\n\t\tif(tag[i]%2!=t%2)\tif(msb[i])\tmsb[i]=3-msb[i];\n\t\tperm[i]=msb[i]*pe.size()+pe[i%pe.size()];\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tstring T;\n\tcin>>n>>T;\n\tvector<int> perm,pos;\n\tsolve(n,T,perm,pos);\n\tfor(int it:perm)\tcout<<it<<' ';\n\tcout<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct mat{int dat[531441];}O,C,S[18],R[18],OO;\nint sal[531441],rum[531441];\nint n,m,cu,ni,nni,tmp;\nstring t;\nmat mul(mat a,mat b){\n\tfor(int i=0;i<m;i++) C.dat[b.dat[i]]=a.dat[i];\n\treturn C;\n}\nint main(){\n\t#ifdef FILIN\n\t\t#ifndef DavidDesktop\n\t\t\tfreopen(FILIN,\"r\",stdin);\n\t\t\tfreopen(FILOUT,\"w\",stdout);\n\t\t#endif\n\t#endif\n\tios::sync_with_stdio(0);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tcin>>n>>t;\n\tm=1;\n\tfor(int i=1;i<=n;i++) m*=3;\n\tfor(int i=0;i<m;i++) O.dat[i]=i;\n\tfor(int i=0;i<m;i++) rum[i]=(i+1)%m;\n\tfor(int i=0;i<m;i++){\n\t\tni=0;\n\t\ttmp=i;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i%3==0) ni=(ni*3);\n\t\t\tif(i%3==1) ni=(ni*3)+2;\n\t\t\tif(i%3==2) ni=(ni*3)+1;\n\t\t\ti/=3;\n\t\t}\n\t\tnni=0;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tnni=(nni*3)+(ni%3);\n\t\t\tni/=3;\n\t\t}\n\t\ti=tmp;\n\t\tsal[i]=nni;\n\t}\n\tfor(int i=0;i<m;i++) R[0].dat[i]=rum[i];\n\tfor(int i=0;i<m;i++) S[0].dat[i]=sal[i];\n\tfor(int i=1;i<18;i++){\n\t\tR[i]=mul(R[i],R[i]);\n\t\tS[i]=mul(S[i],S[i]);\n\t}\n\tcu=1;\n\tfor(int i=1;i<t.size();i++){\n\t\tif(t[i]!=t[i-1]){\n\t\t\tif(t[i-1]=='R'){\n\t\t\t\tO=mul(O,R[0]);\n\t\t\t\tcu--;\n\t\t\t\tfor(int j=17;j>=0;j--)\n\t\t\t\t\tif((cu>>j)&1)\n\t\t\t\t\t\tO=mul(O,R[j]);\n\t\t\t}\n\t\t\tif(t[i-1]=='S'){\n\t\t\t\tO=mul(O,S[0]);\n\t\t\t\tcu--;\n\t\t\t\tfor(int j=17;j>=0;j--)\n\t\t\t\t\tif((cu>>j)&1)\n\t\t\t\t\t\tO=mul(O,S[j]);\n\t\t\t}\n\t\t\tcu=0;\n\t\t}\n\t\tcu++;\n\t}\n\tfor(int i=0;i<m;i++) OO.dat[O.dat[i]]=i;\n\tfor(int i=0;i<m;i++) cout<<OO.dat[i]<<' ';\n\tcout<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,x,y,sw,pw3=1,A[531441],B[531441],S[531441];\nchar T[200001];\nvoid OUT(int x){if(x<0)putchar('-'),x=-x;if(x>=10)OUT(x/10);putchar(x%10+48);}\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nsigned main(void)\n{\n  x=scanf(\"%d %s\",&N,T);\n  replace(T,\"SS\",\"\");if(T[0]=='\\n')return 0;\n  rep(i,N)\n  {\n    rep(j,pw3)rep(k,3)B[j+k*pw3]=k;sw=1;\n    rep(p,strlen(T))\n    {\n      if(T[p]=='R')\n      {\n        y=S[p];\n        rep(j,3)\n        {\n          x=y+j*pw3;\n          if(B[x]==1&&sw==-1||B[x]==2&&sw==1)S[p]=x;\n          B[x]+=(sw==1?1:2);B[x]%=3;\n        }\n      }\n      else sw=-sw;\n    }\n    rep(j,pw3){y=A[j];rep(k,3){x=j+k*pw3;A[x]=y+((sw==-1)?3-B[x]:B[x])%3*pw3;}}\n    pw3*=3;\n  }\n  rep(i,pw3)OUT(A[i]),putchar(' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nint main() {\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n \nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n\n#define MOD 1000000007LL\n\nint N;\nstring T;\nvector<int> p;\n//map<int, int> sa;\nvector<int> sa;\nint tn;\nint os=0;\n\nint tri(int n) {\n  int ans=1;\n  for (int i=0; i<n; i++) ans *= 3;\n  return ans;\n}\n\nvoid salsa();\nvoid rumba();\nvoid print_ln();\n\nint main()\n{\n  int l;\n  int i;\n\n  cin >> N >> T;\n  tn = tri(N);\n\n  p.resize(tn);\n  sa.resize(tn);\n  for (int i=0; i<tn; i++) {\n    p[i] = i;\n  }\n  sa[0] = 0; sa[1] = 2; sa[2]=1;\n  {\n    int t=3;\n    int cv;\n    for (int i=3; i<tn; i++) {\n      if (i>=t*3) t *= 3;\n      cv = sa[i%t];\n      switch(i/t) {\n      case 1: cv += t*2; break;\n      case 2: cv += t; break;\n      }\n      sa[i] = cv;\n    }\n  }\n\n//for (int i=0; i<tn; i++) printf(\"sa[%d]=%d\\n\", i, sa[i]);\n\n//print_ln();\n\n  l = T.size();\n  for (i=0; i<l; i++) {\n    if (T[i] == 'S') {\n      if (T[i+1] == 'S') {\n        i++;\n        continue;\n      }\n      salsa();\n//printf(\"S \");\n//print_ln();\n    } else {\n      os++;\n      os%=tn;\n//      rumba();\n//printf(\"R \");\n//print_ln();\n    }\n  }\n\n  print_ln();\n\n  return 0;\n}\n\nvoid salsa() {\n  int i;\n\n  for (i=0; i<tn; i++) {\n    p[i] = sa[p[i]+os];\n  }\n  os = 0;\n}\nvoid rumba() {\n  int i;\n  for (i=0; i<tn; i++) {\n    p[i]++;\n    p[i]%=tn;\n  }\n}\n\nvoid print_ln() {\n  int i;\n  printf(\"%d\", (p[0]+os)%tn);\n  for (i=1; i<tn; i++) printf(\" %d\", (p[i]+os)%tn);\n  printf(\"\\n\");\n}\n/*\n  a*3^3+b*3^2+c*3+d\n  */\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint pow(int a, int n) {\n\tif (n <= 0) return 0;\n\tif (n == 1) return a;\n\treturn(pow(a, n - 1) * a);\n}\n\nint tri_rev(int t, int n) {\n\tif (t / n == 0) return t;\n\tint x = (t % (n * 3)) / n;\n\tint y = (x == 1) ? 2 : ((x == 2) ? 1 : 0);\n\treturn tri_rev(t - x * n + y * n, n * 3);\n}\n\nvoid readRS(const char* p, vector<int> &RS) {\n\tRS.clear();\n\tint sw = 0;\n\tint c = 1;\n\tbool f = true;\n\twhile (f) { // R = 82 = 平行移動, S = 83 = 3置換\n\t\tif (*p == sw) {\n\t\t\tc++;\n\t\t}\n\t\telse {\n\t\t\tif (sw == 83) {\n\t\t\t\tif (c % 2 == 1) {\n\t\t\t\t\tRS.push_back(-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (sw == 82) {\n\t\t\t\tfor (int i = 0; i < c; i++) { RS.push_back(1); }\n\t\t\t}\n\t\t\tc = 1;\n\t\t\tsw = *p;\n\t\t}\n\t\tif (*p == '\\0') break;\n\t\tp++;\n\t}\n\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\n\t// readRS\n\tstring s;\n\tcin >> s;\n\tvector<int> RS(200001,0); // 1 = 平行移動, -1 = 3置換\n\treadRS(s.c_str(), RS);\n\n\t// swap set\t作成\n\tvector<int> SW(pow(3, N), 0);\n\tfor (int i = 0; i < pow(3, N); i++){\n\t\tif(SW[i] == 0){\n\t\t\tint j = tri_rev(i, 1);\n\t\t\tSW[i] = j;\n\t\t\tSW[j] = i;\n\t\t}\n\t}\n\n\n\tvector<int> P0(1,0); // 前のlvの到達点を入れる。P0[i] = iの最終到達点。初期値はlv=0で、P0[0]=0のみ。\n\tvector<int> W0(RS.size() + 1, 0); // RSの各点に置いて、最後の座席に座っている人のIDを取っておく。lv = 0ならばW0[k] = 0 for all k\n\t\t\t\t\t\t\t\t // W0[0] = 一度もRSをしていない状態での、最後の席の人のID = 3^lv -1\n\t\t\t\t\t\t\t\t // W0[RS.size()-1] = 最後のRSをする直前の、最後の座席の人のID\n\tfor (int lv = 1; lv <= N; lv++) {\n\t\t// 初期化\n\t\t// 3^lv の世界を作る\n\t\tint M = pow(3, lv); // 座席数＝人数\n\t\tint m = M / 3; // 一つ前のlvのm\n\t\tvector<int> P1(M, 0); // 最終到達点を入れる\n\t\tvector<int> W1(RS.size() + 1, 0); // k回目の操作のあとに最終座席にいる人のIDを入れる。\n\t\tmap<int,int> D0, D1, D2; // 全員の最大digitを入れて、k回の操作で更新していく。Dxに入っているidは、最大digitがx\n\n\t\t// D初期値\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tD0.insert(pair<int, int>(i, i));\n\t\t\tD1.insert(pair<int, int>(i, i + m));\n\t\t\tD2.insert(pair<int, int>(i, i + 2 * m));\n\t\t}\n\n\t\t// D更新, W1記録\n\t\tW1[0] = M - 1;\n\t\tfor (int k = 0; k < RS.size(); k++) {\n\t\t\t// Dの更新\n\t\t\tif (RS[k] == -1) {\n\t\t\t\t// 3置換: Dは1 -> 2, 2 -> 1\n\t\t\t\tD1.swap(D2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// 平行移動 繰り上がりだけ処理する。\n\t\t\t\tint i = D2[W0[k]];\n\t\t\t\tD2[W0[k]] = D1[W0[k]];\n\t\t\t\tD1[W0[k]] = D0[W0[k]];\n\t\t\t\tD0[W0[k]] = i;\n\t\t\t}\n\t\t\t// W1[k+1] の作成。W1[k+1]は、2,W0[k+1]の人。\n\t\t\tW1[k + 1] = D2[W0[k + 1]];\n\t\t}\n\t\t// 最後まで到達した\n\t\tfor (auto it = D0.begin(); it != D0.end(); it++) {\n\t\t\tP1[it->second] = P0[it->first];\n\t\t}\n\t\tfor (auto it = D1.begin(); it != D1.end(); it++) {\n\t\t\tP1[it->second] = P0[it->first] + m;\n\t\t}\n\t\tfor (auto it = D2.begin(); it != D2.end(); it++) {\n\t\t\tP1[it->second] = P0[it->first] + 2 * m;\n\t\t}\n\n\t\t// 次のレベルへ\n\t\tP0.swap(P1);\n\t\tW0.swap(W1);\n\t}\n\n\t// out\n\tfor (int i = 0; i < pow(3, N); i++) {\n\t\tcout << P0[i] << \" \";\n\t}\n\tcout << endl;\n\treturn(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nint main(void)\n{\n  int N,x,y,sw,pw3=1,A[531441],B[531441];\n  char S[200000],T[200001];\n  x=scanf(\"%d %s\",&N,T);\n  replace(T,\"SS\",\"\");if(T[0]=='\\n')return 0;\n  rep(i,N)\n  {\n    rep(j,pw3)rep(k,3)B[j+k*pw3]=k;sw=0;\n    rep(j,strlen(T))\n    {\n      if(T[j]=='R')\n      {\n        if(S[j]<48||S[j]>57)y=0;else y=S[j]-'0';\n        rep(k,3){x=y+k*pw3;if(B[x]+sw==2)S[j]=x+'0';B[x]+=sw+1;B[x]%=3;}\n      }\n      if(T[j]=='S')sw^=1;\n    }\n    rep(j,pw3){y=A[j];rep(k,3){x=j+k*pw3;A[x]=y+(sw?3-B[x]:B[x])%3*pw3;}}\n    pw3*=3;\n  }\n  rep(i,pw3)printf(\"%d%c\",A[i],i+1==pw3?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define R register\n#define mp make_pair\n#define ll long long\n#define pii pair<int, int>\n#define pll pair<ll, ll>\nusing namespace std;\nconst int mod = 998244353, N = 1100000;\n\nint n, ch[N][3], to[3], ind[N], pw[15], tot, root, ans[N];\nchar s[N];\n\ninline int addMod(int a, int b) {\n\treturn (a += b) >= mod ? a - mod : a;\n}\n\ninline ll quickpow(ll base, ll pw) {\n\tll ret = 1;\n\twhile (pw) {\n\t\tif (pw & 1) ret = ret * base % mod;\n\t\tbase = base * base % mod, pw >>= 1;\n\t}\n\treturn ret;\n}\n\ntemplate <class T>\ninline void read(T &x) {\n\tx = 0;\n\tchar ch = getchar(), w = 0;\n\twhile (!isdigit(ch)) w = (ch == '-'), ch = getchar();\n\twhile (isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();\n\tx = w ? -x : x;\n\treturn;\n}\n\nvoid build(int &k, int dep, int x) {\n\tk = ++tot;\n\tif (dep == n) {\n\t\tind[k] = x;\n\t\treturn;\n\t}\n\tfor (R int i = 0; i <= 2; ++i)\n\t\tbuild(ch[k][i], dep + 1, x + i * pw[dep]);\n\treturn;\n}\n\nvoid modify(int k, int dep) {\n\tif (dep == n) return;\n\tmodify(ch[k][to[2]], dep + 1);\n\tint tmp = ch[k][to[0]];\n\tch[k][to[0]] = ch[k][to[2]], ch[k][to[2]] = ch[k][to[1]], ch[k][to[1]] = tmp;\n\treturn;\n}\n\nvoid dfs(int k, int dep, int x) {\n\tif (dep == n) {\n\t\tans[ind[k]] = x;\n\t\treturn;\n\t}\n\tfor (R int i = 0; i <= 2; ++i)\n\t\tdfs(ch[k][to[i]], dep + 1, x + i * pw[dep]);\n\treturn;\n}\n\nint main() {\n\tread(n), scanf(\"%s\", s + 1);\n\tpw[0] = 1, to[1] = 1, to[2] = 2;\n\tfor (R int i = 1; i <= n; ++i) pw[i] = pw[i - 1] * 3;\n\tbuild(root, 0, 0);\n\tfor (R int i = 1, m = strlen(s + 1); i <= m; ++i) {\n\t\tif (s[i] == 'S')\n\t\t\tswap(to[1], to[2]);\n\t\telse\n\t\t\tmodify(root, 0);\n\t}\n\tdfs(root, 0, 0);\n\tfor (R int i = 0; i < pw[n]; ++i)\n\t\tcout << ans[i] << ' ';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nint main(void)\n{\n  int N,x,y,sw,pw3=1,A[531441],B[531441],S[200000];char T[200001];\n  x=scanf(\"%d %s\",&N,T);\n  replace(T,\"SS\",\"\");if(T[0]=='\\n')return 0;\n  rep(i,N)\n  {\n    rep(j,pw3)rep(k,3)B[j+k*pw3]=k;sw=0;\n    rep(j,strlen(T))\n    {\n      if(T[j]=='R')\n      {\n        y=S[j];\n        rep(k,3){x=y+k*pw3;if(B[x]+sw==2)S[j]=x;B[x]+=sw+1;B[x]%=3;}\n      }\n      if(T[j]=='S')sw^=1;\n    }\n    rep(j,pw3){y=A[j];rep(k,3){x=j+k*pw3;A[x]=y+(sw?3-B[x]:B[x])%3*pw3;}}\n    pw3*=3;\n  }\n  rep(i,pw3)printf(\"%d%c\",A[i],i+1==pw3?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 800 + 7, maxm = 6e5 + 7;\nint n, m, to[maxn], ans[maxm];\nchar s[maxm];\n\nint cal(int x) {\n\tint rs = 0, t = 1;\n\twhile(x) {\n\t\tint y = x % 3;\n\t\tif(y) rs += (3 - y) * t;\n\t\tt = t * 3; x = x / 3;\n\t}\n\treturn rs;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", s + 1); m = strlen(s + 1);\n\tint p = n >> 1, d = n - p;\n\tint r = 1, l = 1;\n\tfor (int i = 1; i <= p; ++i) r = r * 3;\n\tfor (int i = 1; i <= d; ++i) l = l * 3;\n\tfor (int i = 1; i < l; ++i) {\n\t\tto[i] = cal(i);\n\t}\n\tfor (int i = 0; i < r; ++i) {\n\t\tfor (int j = 0; j < l; ++j) ans[j * r + i] = j;\n\t\tint o = 0, nowr = i;\n\t\tfor (int t = 1; t <= m; ++t) {\n\t\t\tif(s[t] == 'S') {\n\t\t\t\tnowr = to[nowr];\n\t\t\t\to ^= 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(nowr == r - 1) {\n\t\t\t\t\tif(o) for (int j = 0; j < l; ++j) ans[j * r + i] = to[ans[j * r + i]];\n\t\t\t\t\to = 0;\n\t\t\t\t\tfor (int j = 0; j < l ; ++j) ans[j * r + i] = (ans[j * r + i] + 1) % l;\n\t\t\t\t}\n\t\t\t\tnowr = (nowr + 1) % r;\n\t\t\t}\n\t\t}\n\t\tif(o) for (int j = 0; j < l; ++j) ans[j * r + i] = to[ans[j * r + i]];\n\t\tfor (int j = 0; j < l; ++j) ans[j * r + i] = ans[j * r + i] * r + nowr;\n\t}\n\tfor (int i = 0; i < l * r; ++i) printf(\"%d \", ans[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\ntypedef long long LL;\n#define rep(i,N) for(LL i=0;i<(LL)N;i++)\nconst LL sz=531441;\nint N,x,y,th,P[sz],t[13]={0},TRI;\nchar c='-',tmp,T[200001];\nvoid init(void){rep(i,3*TRI)P[i]=i;}\ninline LL IN(void)\n{\n  LL x=0;short f=0,c=getchar();\n  while(c<48||c>57)f^=c==45,c=getchar();\n  while(c>47&&c<58)x=x*10+c-48,c=getchar();\n  return f?-x:x;\n}\nvoid sal(char &c)\n{\n  if(c=='R'){rep(i,3*TRI){P[i]++;if(P[i]==3*TRI)P[i]=0;}return;}\n  if(c=='S')rep(trit,3*TRI)\n  {\n    x=P[trit];y=0;\n    rep(i,13)\n    {\n      y++;t[i]=x%3;\n      if(t[i]==1)t[i]=2;else if(t[i]==2)t[i]=1;else t[i]=0;\n      if(x<3)break;\n      x/=3;\n    }\n    x=0;\n    rep(i,y)x+=t[i]*pow(3,i);\n    if(x==3*TRI)x=0;\n    P[trit]=x;\n  }\n}\nsigned main(void)\n{\n  int p=0,count=0;\n  N=IN();\n  while(c!=EOF)\n  {\n    c=getchar();if(c==EOF)break;T[p]=c;\n    if(c=='S'&&tmp=='S'){if(count%2==0)p--;count++;tmp=T[p-1];}\n    else{p++;tmp=c;count=0;}\n  }\n  TRI=pow(3,N-1),init();\n  rep(i,p){sal(T[i]);}\n  rep(i,3*TRI)printf(\"%d \",P[i]);\n}"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n// #define inf  998244353\n\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int Gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return Gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn Gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                              \n                int pr[100000];\n                int inv[100000];\n                \n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=((ll)pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=(ll)inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n  \n\n\n  \n\nvoid solve(){\n\tvector<int> ve(1,0);\n\tint n;\n\tcin>>n;\n\tstring s;\n\tcin>>s;\n\tint m=s.length();\n\tvector<int> las(m+1,0);\n\t\n\tint san[15];\n\tsan[0]=1;\n\tfor(int i=0;i<13;i++)san[i+1]=san[i]*3;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tset<int> se[3];\n\t\tfor(int j=0;j<3;j++){\n\t\t\tfor(int k=j*san[i];k<(j+1)*san[i];k++)se[j].insert(k);\n\t\t}\n\t\tlas[0]+=2*san[i];\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(s[j]=='S'){\n\t\t\t\tswap(se[1],se[2]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint mae=las[j]%san[i];\n\t\t\t\tint tmp[3];\n\t\t\t\tbool sumi[3]={};\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tif(!sumi[0]&&se[k].count(mae))tmp[k]=mae,sumi[0]=1;\n\t\t\t\t\telse if(!sumi[1]&&se[k].count(mae+san[i]))tmp[k]=mae+san[i],sumi[1]=1;\n\t\t\t\t\telse tmp[k]=mae+san[i]*2,sumi[2]=1;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tse[k].erase(tmp[k]);\n\t\t\t\t\tse[(k+1)%3].insert(tmp[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(se[2].count(las[j+1]+san[i]))las[j+1]+=san[i];\n\t\t\telse if(se[2].count(las[j+1]+san[i]*2))las[j+1]+=2*san[i];\n\t\t}\n\t\t\n\t\tint ss=ve.size();\n\t\tfor(int j=0;j<ss;j++)ve.pb(ve[j]);\n\t\tfor(int j=0;j<ss;j++)ve.pb(ve[j]);\n\t\t\n\t\tfor(auto j:se[1])ve[j]+=san[i];\n\t\tfor(auto j:se[2])ve[j]+=2*san[i];\n\t\t\n\t}\n\tfor(auto v:ve)cout<<v<<\" \";\n\tcout<<endl;\n}\n\n\nsigned main(){\n\t\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\nint n;\n\tn=1;\n\tfor(int i=0;i<n;i++)solve();\n\t\n\treturn 0;\n }\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\ntypedef struct item * pitem;\nstruct item {\n    int prior, value, cnt;\n    bool rev;\n\n    item(int value):prior(rand()), value(value) {\n        cnt = 0;\n        rev = 0;\n        l = r = nullptr;\n    }\n\n    pitem l, r;\n};\n\nmap< int , int >p3;\n\nnamespace Treap {\n    int cnt (pitem it) {\n        return it != nullptr? it->cnt : 0;\n    }\n\n    void upd_cnt (pitem it) {\n        if (it!=nullptr) {\n            it->cnt = cnt(it->l) + cnt(it->r) + 1;\n        }\n    }\n\n    void push(pitem it);\n\n    void merge (pitem & t, pitem l, pitem r) {\n        push (l);\n        push (r);\n        if (l==nullptr || r==nullptr)\n            t = (l!=nullptr) ? l : r;\n        else if (l->prior > r->prior)\n            merge (l->r, l->r, r),  t = l;\n        else\n            merge (r->l, l, r->l),  t = r;\n        upd_cnt (t);\n    }\n\n    void split (pitem t, pitem & l, pitem & r, int key, int add = 0) {\n        if (t==nullptr) {\n            l = r = nullptr;\n            return;\n        }\n        push (t);\n        int cur_key = add + cnt(t->l);\n\n        if (key <= cur_key)\n            split (t->l, l, t->l, key, add),  r = t;\n        else\n            split (t->r, t->r, r, key, add + 1 + cnt(t->l)),  l = t;\n        upd_cnt (t);\n    }\n\n    void push (pitem it) {\n        if (it != nullptr && it->rev == true) {\n            auto jt = p3.find(it->cnt);\n            assert(jt != p3.end());\n\n            it->rev = false;\n            if (it->cnt > 1) {\n                int base = it->cnt/3;\n                pitem A, B, C;\n                split(it, A, B, base);\n                split(B, B, C, base);\n                A->rev ^= 1;\n                B->rev ^= 1;\n                C->rev ^= 1;\n                merge(B, C, B);\n                merge(it, A, B);\n            }\n        }\n    }\n\n    void insert (pitem & t, int key, int value) {\n\n        pitem x = new item(value);\n\n        pitem L, R;\n        split(t, L, R, key);\n        merge(L, L, x);\n        merge(t, L, R);\n\n        upd_cnt(t);\n    }\n\n    int erase (pitem & t, int key) {\n        assert(cnt(t) > key);\n\n        pitem L, MID, R;\n        split(t, L, MID, key);\n        split(MID, MID, R, 1);\n        merge(t, L, R);\n        upd_cnt(t);\n\n        int x = MID->value;\n        delete MID;\n\n        return x;\n    }\n\n    void output (pitem t, vector< int >&v) {\n        if (t==nullptr)  return;\n        push (t);\n        output (t->l, v);\n        v.push_back(t->value);\n        output (t->r, v);\n    }\n\n    void output2 (pitem t) {\n        if (t==nullptr)  return;\n        push (t);\n//        cout << \"(\";\n        output2 (t->l);\n        cout << (t->value) << \" \";\n        output2 (t->r);\n//        cout << \")\";\n    }\n}\n\nint main() {\n    srand(time(0));\n\n    pitem root = nullptr;\n\n    int N;\n    cin >> N;\n\n    int sz = 1;\n    p3[1] = 0;\n    for (int i = 1; i <= N; i++) {\n        sz *= 3;\n        p3[sz] = i;\n    }\n\n//    vector< int >swapWith(sz);\n//    for (int i = 0; i < sz; i++) {\n//        vector< int >g(N);\n//        for (int z = 0, base = 1; z < N; z++, base *= 3) {\n//            g[z] = (i/base)%3;\n//        }\n//        int j = 0;\n//        for (int z = N-1; z >= 0; z--) {\n//            j *= 3;\n//            if (g[z]) j += ((g[z]-1)^1)+1;\n//        }\n//        swapWith[i] = j;\n//    }\n\n//    vector< int >truth(sz);\n    for (int i = 0; i < sz; i++) {\n        Treap::insert(root, i, i);\n//        truth[i] = i;\n    }\n\n    string T;\n    cin >> T;\n\n    for (int i = 0; i < T.size(); i++) {\n        if (T[i] == 'S') {\n            root->rev ^= 1;\n\n//            for (int j = 0; j < sz; j++) {\n//                if (swapWith[j] >= j) continue;\n//                swap(truth[j], truth[swapWith[j]]);\n//            }\n        } else {\n            int last = Treap::erase(root, sz-1);\n            Treap::insert(root, 0, last);\n\n//            truth.insert(truth.begin(), truth.back());\n//            truth.pop_back();\n        }\n\n//        cout << \"after \" << T[i] << \" \" << endl;\n//        Treap::output2(root);\n//        cout << endl;\n//        for (int x : truth) cout << x << \" \";\n//        cout << endl;\n    }\n\n    vector< int >v;\n    Treap::output(root, v);\n\n    vector< int >r(sz);\n    for (int i = 0; i < sz; i++) r[v[i]] = i;\n\n    for (int x : r) cout << x << \" \";\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define SZ(x) ((int)x.size())\n#define ALL(x) x.begin(),x.end()\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> T gcd(T a, T b){return !b?a:gcd(b,a%b);}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\nmt19937 R(chrono::system_clock().now().time_since_epoch().count());\n\nconst int N = 531441+11;\nint n,len,mi[N],f[N];char s[N];int pos[N],lst[N],val[N],posnew[N];\nint qz[N];\nint main() {\n\tread(n);scanf(\"%s\",s+1);int len=strlen(s+1);\n\trep(i,1,len)qz[i]=qz[i-1]+(s[i]=='S');\n\tmi[0]=1;rep(i,1,n)mi[i]=mi[i-1]*3;\n\trep(i,0,n-1){\n\t\tstatic int g[N];memset(g,0,sizeof(g));\n\t\tmemset(lst,0,sizeof(lst));rep(j,0,mi[i+1]-1)val[j]=j/mi[i];\n\t\trep(t,1,len)if(s[t]!='S'){\n\t\t\trep(x,0,2){\n\t\t\t\tif(val[x*mi[i]+pos[t]]&&(qz[t]-qz[lst[x*mi[i]+pos[t]]]&1))val[x*mi[i]+pos[t]]=3-val[x*mi[i]+pos[t]];\n\t\t\t\tval[x*mi[i]+pos[t]]++;\n\t\t\t\tif(val[x*mi[i]+pos[t]]==3)val[x*mi[i]+pos[t]]=0,posnew[t]=x*mi[i]+pos[t];\n\t\t\t\tlst[x*mi[i]+pos[t]]=t;\n\t\t\t}\n\t\t}\n\t\trep(x,0,mi[i+1]-1){\n\t\t\tint res=val[x];if(val[x]&&(qz[len]-qz[lst[x]]&1))res=3-res;\n\t\t//\tprintf(\"%d:%d %d\\n\",x,val[x],res);\n\t\t\tg[x]=f[x%mi[i]]+mi[i]*res;\n\t\t}\n\t\tmemcpy(f,g,sizeof(g));\n\t\tmemcpy(pos,posnew,sizeof(posnew));\n\t}\n\tstatic int ans[N];rep(i,0,mi[n]-1)ans[f[i]]=i;\n\trep(i,0,mi[n]-1)printf(\"%d \",f[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2,unroll-loops\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing vi = vector<int>;\nusing ll = long long;\nint maxn = 531441, B, C;\nint n, p[531441], f[531441];\nint rev(int a) {\n\tint r = 0, c = 1;\n\twhile(c < maxn) {\n\t\tif(a%3) r +=(3 - (a%3))*c;\n\t\tc*=3,a/=3;\n\t}\n\treturn r;\n}\n\nint s = 0;\nvector<int> small[729];\nint id[531441], lup[531441], u = 0;\n\nvoid add() {\n\ts = (s + B - 1)%B;\n\tfor(auto i : small[s]) {\n\t\tif(lup[i] != u) {\n\t\t\tif((lup[i]^u)&1) id[i] = f[id[i]];\n\t\t\tlup[i] = u;\n\t\t}\n\t\tid[i] = (id[i] + 1)%C;\n\t}\n}\n\nvoid flip() {\n\tu++;\n\tfor(int i = 0; i < B; i++) {\n\t\tif(f[i] <= i) {\n\t\t\tswap(small[(s+i)%B], small[(s+f[i])%B]);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tstring t;\n\tcin >> n >> t;\n\tmaxn = B = 1;\n\tfor(int i = 0; i < n; i++) maxn *= 3;\n\tfor(int i = 0; i < n/2; i++) B *= 3;\n\tC = maxn/B;\n\tfor(int i = 0; i < maxn; i++) {\n\t\tf[i] = rev(i);\n\t\tsmall[i%B].push_back(i);\n\t\tid[i] = i/B;\n\t}\n\t\n\tfor(auto i : t) {\n\t\tif(i == 'R') add();\n\t\telse flip();\n\t}\n\tfor(int i = 0; i < B; i++)\n\t\tfor(auto j : small[i]) p[j] += (B+i-s)%B;\n\tfor(int i = 0; i < maxn; i++) {\n\t\tif(lup[i] != u) {\n\t\t\tif((lup[i]^u)&1) id[i] = f[id[i]];\n\t\t\tlup[i] = u;\n\t\t}\n\t\tp[i] += B*id[i];\n\t}\n\tfor(int i = 0; i < maxn; i++) cout << p[i] << \" \";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,o,p,x,y,pos,pw3[13]={1},A[1000000],salsa[531441],sw[1000000];\nchar T[200001];\nvoid Dance(char c[])\n{\n  if(c[p]==EOF)return;\n  if(c[p]=='S'){x=salsa[x];if(sw[pos]>0)pos--;else sw[++pos]=1;}\n  if(c[p]=='R'){x++;if(x==pw3[N/2])sw[++pos]=-1,x=0;}\n}\nvoid Update(void)\n{\n  rep(i,pw3[N-N/2])\n  {\n    y=i;\n    rep(j,pos){if(sw[j+1]>0)y=salsa[y];else if(sw[j+1]<0){if((++y)==pw3[N-N/2])y=0;}}\n    A[o+i*pw3[N/2]]=y*pw3[N/2]+x;\n  }\n}\nsigned main(void)\n{\n  o=scanf(\"%d %s\",&N,T);\n  rep(i,N)pw3[i+1]=3*pw3[i];\n  rep(i,pw3[N])salsa[i]=salsa[i/3]*3+(3-i%3)%3;\n  rep(i,pw3[N/2]){o=i,x=i,pos=0;rep(j,strlen(T)){p=j,Dance(T);}Update();}\n  rep(i,pw3[N])printf(\"%d%c\",A[i],i+1==pw3[N]?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\n\nint main()\n{\t\n    int n;\n    scanf(\"%d\\n\",&n);\n    int number=(int)pow(3,n);\n    int place[number];\n    //printf(\"%d\",number);\n    char a[200000];\n    int length=0;\n    gets(a);\t\n    do{\n\t    length++;\n    }while(a[length]!='\\0');\n    for(int i=0;i<number;i++)\n    {\n        place[i]=i;\n    }\n    for(int i=0;i<length;i++)\n    {\n        //printf(\"%c\",a[i]);\n        if(a[i]=='S')\n        {\n            //printf(\"s\");\n            for(int j=0;j<number;j++)\n            {\n                place[j]=salsa(n,place[j]);\n            }\n        }\n        else if (a[i]=='R')\n        {\n            //printf(\"r\");\n            for(int j=0;j<number;j++)\n            {\n                place[j]=place[j]+1;\n                if(place[j]==number)\n                {\n                    place[j]=0;\n                }\n            }\n        } \n    }\n    for(int i=0;i<number;i++)\n    {\n        printf(\"%d \",place[i]);\n    }\n    return 0;\n}\n\nint salsa(int n,int a)\n{\n    int list[n];\n    for(int i=0;i<n;i++)\n    {\n        list[i]=0;\n    }\n    int j=n-1;\n    while(a!=0)\n    {\n        list[j]= a % 3 ;\n        a=a/3;\n        j--;\n    }\n    for(int i=0;i<n;i++)\n    {\n        if(list[i]==1)\n        {\n            list[i]=2;\n        }\n        else if(list[i]==2)\n        {\n            list[i]=1;\n        }\n    }\n    int result=0;\n    for(int i=0;i<n;i++)\n    {\n        result=result+ list[i]*pow(3,(n-1-i));\n    }\n    return result;\n}\n\nint rumba(int a)\n{\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    vector<int> d23(531441);\n    //vector<int> rumba(531441);\n\n    int N;\n    cin >> N;\n    N = (int)pow(3,N);\n    \n    int temp,add,now;\n    for(int i = 0 ; i < N ; i++){\n        temp = i;\n        add = 0;\n        now = 1;\n        while(temp != 0){\n            int a = temp % 3;\n            if(a == 1){\n                add += 2 * now;\n            }else if(a == 2){\n                add += now;\n            }\n            now *= 3;\n            temp /= 3;\n        }\n        d23.at(i) = add;\n    }\n\n    //for(int i = 0 ; i < N ; i++){\n    //    rumba.at(i) = i + 1;\n    //}\n    //rumba.at(N - 1) = 0;\n\n\n    vector<int> hito1(531441);\n\n    for(int i = 0 ; i < N ; i++){\n        hito1.at(i) = i;\n    }\n\n\n    string _T;\n    cin >> _T;\n\n    string TSdata;\n    vector<int> Tdata;\n\n    bool flag = false;\n    int cnt = 0;\n\n    for(int i = 0 ; i < _T.size() ; i++){\n        if(_T.at(i) == 'S'){\n            if(flag){\n                flag = false;\n                continue;\n            }\n            flag = true;\n        }else{\n            if(flag){\n                TSdata.push_back('S');\n                flag = false;\n            }\n            TSdata.push_back('R');\n        }\n    }\n    if(flag){\n        TSdata.push_back('S');\n    }\n    flag = false;\n\n    \n    \n    for(int i = 0 ; i < TSdata.size() ; i++){\n        if(TSdata.at(i) == 'R'){\n            cnt++;\n        }else{\n            if(cnt != 0){\n                Tdata.push_back(cnt);\n                cnt = 0;\n            }\n            Tdata.push_back(0);\n        }\n    }\n    if(cnt != 0){\n        Tdata.push_back(cnt);\n    }\n\n\n    int tSize = Tdata.size();\n\n    //for(int i = 0 ; i < Tdata.size() ; i++){\n    //    cout << Tdata.at(i) << ' ';\n    //}\n    //return 0;\n\n    \n\n    for(int i = 0 ; i < tSize ; i++){\n        if(Tdata.at(i) == 0){\n            for(int j = 0 ; j < N ; j++){\n                hito1.at(j) = d23.at(hito1.at(j));\n            }\n        }else{\n            int a = Tdata.at(i) % N;\n            for(int j = 0 ; j < N ; j++){\n                hito1.at(j) += a;\n                if(hito1.at(j) >= N){\n                    hito1.at(j) -= N;\n                }\n            }\n            \n        }\n    }\n\n\n    \n    for(int i = 0 ; i < N - 1 ; i++){\n        cout << hito1.at(i) << ' ';\n    }\n    cout << hito1.at(N - 1) << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\nauto constexpr INF32 = numeric_limits<int32_t>::max()/2-1;\nauto constexpr INF64 = numeric_limits<int64_t>::max()/2-1;\nauto constexpr INF   = numeric_limits<int>::max()/2-1;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#define dump(...) cerr << \"[\" << setw(3) << __LINE__ << \":\" << __FUNCTION__ << \"] \", dump_impl(#__VA_ARGS__, __VA_ARGS__)\n#define say(x) cerr << \"[\" << __LINE__ << \":\" << __FUNCTION__ << \"] \" << x << endl\n#define debug if (1)\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class F> int ppt(C const& v, F f) {\n    return partition_point(v.begin(), v.end(), f)-v.begin();\n}\n// <<<\nconst int N = 15;\nint pow3[N] = {};\n\nvector<int> rec(int n, string const& T) {\n    if (n == 0) return {0};\n    vector<int> ret(pow3[n]);\n    rep (i,3) {\n        string nT;\n        int x = i;\n        for (char c : T) {\n            if (c == 'S') {\n                if (nT.size() && nT.back() == 'S') {\n                    nT.pop_back();\n                } else {\n                    nT += c;\n                }\n                if (x > 0) x = 3-x;\n            } else {\n                x++;\n                if (x == 3) {\n                    x = 0;\n                    nT += c;\n                }\n            }\n        }\n        auto res = rec(n-1,nT);\n        rep (j,pow3[n-1]) ret[3*j+i] = 3*res[j]+x;\n    }\n    return ret;\n};\n\nint32_t main() {\n    pow3[0] = 1;\n    rep (i,N-1) pow3[i+1] = 3*pow3[i];\n\n    int n; cin >> n;\n    string T; cin >> T;\n    cout << rec(n,T) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\nint pos[200002][13];\nint n;\n\nvoid salsa(){\n\tfor(int i=0;i<pow(3,n);i++){\n\t\tfor(int j=0;j<n;j++){\n\n\t\t\tif(pos[i][j]==1)pos[i][j]=2;\n\t\t\telse if(pos[i][j]==2)pos[i][j]=1;\n\t\t\telse;\n\t\t}\n\t}\n}\nvoid rumba(){\n\tfor(int i=0;i<pow(3,n);i++){\n\t\tint j=0;\n\t\tpos[i][j]++;\n\t\twhile(pos[i][j]==3 && j!=n){\n\t\t\tpos[i][j]=0;\n\t\t\tpos[i][j+1]++;\n\t\t\tj++;\n\t\t}\n\t\t\n\t}\n}\n\nvoid fun(char i){\n\tif (i=='S'){\n\t\tsalsa();\n\t}\n\telse{\n\t\trumba();\n\t}\n\t// print();\n}\n\nint main(){\n\tchar order[300000];\n\tscanf(\"%d\",&n);\n\tchar c;scanf(\"%c\",&c);\n\n\tfor(int i=0;i<pow(3,n);i++){\n\t\tint num=i;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tpos[i][j]=num%3;\n\t\t\tnum=num/3;\n\t\t}\n\t}\n\n\tchar lol='1';\n\tint itr=0;\n\twhile(lol!='\\n'){\n\t\tscanf(\"%c\",&lol);\n\t\torder[itr++]=lol;\n\t}\n\tfor(int i=0;i<itr-1;i++){\n\t\t// printf(\"%c\\n\",order[i] ); \n\t\tfun(order[i]);\n\t}\n\n\tfor(int i=0;i<pow(3,n);i++){\n\t\tint numb=0;\n\t\tint deg=1;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tnumb+= pos[i][j]*deg;\n\t\t\tdeg*=3;\n\t\t}\n\t\tprintf(\"%d \", numb);\n\t}\n\tprintf(\"\\n\");\n\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<queue>\n#include<cmath>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<random>\n#include<functional>\n#include<algorithm>\n#include<stack>\n#include<cstdio>\n#include<cstring>\n#include<bitset>\n#include<unordered_map>\n#include<climits>\n#include<fstream>\n#include<complex>\n#include<time.h>\n#include<cassert>\n#include<functional>\n#include<numeric>\n#include<tuple>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define int long long\n#define all(a) (a).begin(),(a).end()\n#define fs first\n#define sc second\n#define xx first\n#define yy second.first\n#define zz second.second\n#define H pair<int, int>\n#define P pair<int, pair<int, int>>\n#define Q(i,j,k) mkp(i,mkp(j,k))\n#define rng(i,s,n) for(int i = (s) ; i < (n) ; i++)\n#define rep(i,n) rng(i, 0, (n))\n#define mkp make_pair\n#define vec vector\n#define pb emplace_back\n#define crdcomp(b) sort(all((b)));(b).erase(unique(all((b))),(b).end())\n#define getidx(b,i) lower_bound(all(b),(i))-b.begin()\n#define ssp(i,n) (i==(int)(n)-1?\"\\n\":\" \")\n#define ctoi(c) (int)(c-'0')\n#define itoc(c) (char)(c+'0')\n#define pp(x,y) pb(H{x,y})\n#define ppp(x,y,z) pb(Q(x,y,z))\n#define cyes printf(\"Yes\\n\")\n#define cno printf(\"No\\n\")\n#define cdf(n) int quetimes_=(n);rep(qq123_,quetimes_)\n#define gcj printf(\"Case #%lld: \",qq123_+1)\n#define readv(a,n) a.resize(n,0);rep(i,(n)) a[i]=read()\n//#define endl \"\\n\"\nconstexpr int mod = 1e9 + 7;\nconstexpr int Mod = 998244353;\nconstexpr int MXN = 500000 + 100;\nconstexpr ld EPS = 1e-10;\nconstexpr ll inf = 3 * 1e18;\nconstexpr int Inf = 15 * 1e8;\nconst vec<int>dx{ -1,1,0,0 }, dy{ 0,0,-1,1 };\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\nll read() { ll u, k = scanf(\"%lld\", &u); return u; }\nstring reads() { string s; cin >> s; return s; }\nH readh(bool g = 0) { H u; int k = scanf(\"%lld %lld\", &u.fs, &u.sc); if (g) u.fs--, u.sc--; return u; }\nbool inarea(H t, int h, int w) { return 0 <= t.fs && t.fs < h && 0 <= t.sc && t.sc < w; }\nll gcd(ll i, ll j) { return j ? gcd(j, i % j) : i; }\nll mod_pow(ll x, ll n, ll p = mod) {\n    ll res = 1; x %= p;\n    while (n > 0) {\n        if (n & 1) res = res * x % p;\n        x = x * x % p;\n        n >>= 1;\n    }\n    return res;\n}//x^n%p\nll bitcount(ll x) {\n    int sum = 0; for (int i = 0; i < 60; i++)if ((1ll << i) & x) sum++;\n    return sum;\n}\n/*constexpr int fn_ = 5000005;\nll fact_[fn_], comp_[fn_];\nll comb(ll x, ll y, ll m) {\n    if (!fact_[0]) {\n        fact_[0] = 1; comp_[0] = 1;\n        for (int i = 1; i < fn_; i++)\n            fact_[i] = fact_[i - 1] * i % m;\n        comp_[fn_ - 1] = mod_pow(fact_[fn_ - 1], m - 2, m);\n        for (int i = fn_ - 2; i > 0; i--)\n            comp_iiiiiiiiiiiijijiii[i] = comp_[i + 1] * (i + 1) % m;\n    }\n    if (x < y) return 0;\n    return fact_[x] * comp_[x - y] % m * comp_[y] % m;\n}*/\n//--------------------------------------------------------------\nint n, m;\nstring t;\nint to[1000000];\nint to2[1000000];\nint to3[10][18][1000000];\nint d[1000000];\nvec<H>a;\nsigned main(){\n    cin >> m >> t;\n    n = pow(3, m);\n    rep(i, n) to[i] = (i + 1) % n;\n    rep(i, n) {\n        int h = 0;\n        int k = i;\n        int t = 1;\n        rep(j, m) {\n            h += ((3 - k % 3) % 3) * t;\n            k /= 3; t *= 3;\n        }\n        to2[i] = h;\n    }\n    //Rを1回→to\n    //Sを1回→to2\n    for (int i = 0; i < t.size();) {\n        int j = i;\n        while (j < t.size() && t[i] == t[j]) j++;\n        if (t[i] == 'S' && (j - i) % 2 == 1)  a.pb(1, 1);\n        else if (t[i] == 'R') a.pb(0, j - i);\n        i = j;\n    }\n    vec<H>u;\n    vec<int>v;\n    for (int i = 0; i < a.size();) {\n        int j = i, sum = 0;\n        while (j < a.size() && a[i].fs == a[j].fs) sum += a[j].sc, j++;\n        u.pb(H{ a[i].fs,sum });\n        if (a[i].fs == 0) v.pb(sum);\n        i = j;\n    }\n    a = u;//この時点で圧縮が完了した\n    crdcomp(v);\n    rep(i, min(10ll, (ll)v.size())) {\n        //v[i]個の後Sが来るような組み合わせをj回行ったときどうなるかな？\n        rep(j, n) {\n            to3[i][0][j] = to2[(j + v[i]) % n];\n        }\n        rng(j, 1, 18)rep(k, n) {\n            to3[i][j][k] = to3[i][j - 1][to3[i][j - 1][k]];\n        }\n        d[v[i]] = i;\n    }\n    vec<int>b(n);\n    rep(i, n) b[i] = i;\n    for (int i = 0; i < a.size();) {\n        vec<int>c(n);\n        if (a[i].fs == 1) {\n            rep(j, n) c[to2[j]] = b[j];\n            b = c;\n            i++;\n        }\n        else {\n            if (d[a[i].sc] && i < a.size() - 1) {\n                int sum = 0, j = i;\n                for (; i + 1 < a.size() && a[i].sc == a[j].sc; i += 2) {\n                    sum++;\n                }\n                for (int j = 19; j >= 0; j--) {\n                    if (sum >= (1 << j)) {\n                        rep(z, n) c[d[a[i].sc]][to3[j][z]] = b[z];\n                        sum -= (1 << j);\n                        b = c;\n                    }\n                }\n            }\n            else {\n                rep(j, n) c[(j + a[i].sc) % n] = b[j];\n                b = c;\n                i++;\n            }\n        }\n    }\n    vec<int>ans(n);\n    rep(i, n) ans[b[i]] = i;\n    rep(i, n) cout << ans[i] << ssp(i, n);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n//#define LL __int64\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pLL;\ntypedef vector<int> VI;\ntypedef vector< vector<int> > VVI;\n\ntemplate< typename T > inline void read(T &x)\n{\n    static char _c;\n    static bool _f;\n\n    x = 0;\n    _f = 0;\n    _c = getchar();\n\n    while(_c < '0' || '9' < _c) {if(_c == '-') _f = true; _c = getchar();}\n    while('0' <= _c && _c <= '9') {x = (x << 1) + (x << 3) + (_c & 15); _c = getchar();}\n    if(_f) x = -x;\n}\ntemplate < typename T, typename ...Args > inline void read(T &x, Args &...args) {read(x); read(args...);}\n\ntemplate < typename T > inline void Min(T &x, T y) {if(y < x) x = y;}\ntemplate < typename T > inline void Max(T &x, T y) {if(x < y) x = y;}\n\n\n#define lowbit(x) ((x) & -(x))\n#define lson l,mid,id<<1\n#define rson mid+1,r,id<<1|1\n#define ls id<<1\n#define rs id<<1|1\n#define MID(l,r) ((l)+(((r)-(l))>>1))\n#define fi first\n#define se second\n#define mk make_pair\n#define mt make_tuple\n#define pb push_back\n#define all(a) a.begin(),a.end()\n\nconst int INF = 0x3f3f3f3f;\nconst LL LINF = 0x3f3f3f3f3f3f3f3f;\nconst double pi = (double) acos(-1.0);\nconst double eps = (double) 1e-8;\nconst int e5 = (int) 1e5 + 5;\n//const int MOD = (int) 1e9 + 7;\nconst int MOD = (int) 1000000007;\n//const int MOD = 998244353;\n\ntemplate< typename T0, typename T1 > inline void depair(T0 &x, T1 &y, pair<T0, T1> &p) {x = p.fi, y = p.se;}\ninline int sig(double x) {return x < -eps ? -1 : eps < x;}\nLL fp(LL a, LL n, LL mod = MOD)\n{\n    if(n < 0) a = fp(a, mod - 2, mod), n = -n;\n    LL res = 1; for(; n; n >>= 1, a = a * a % mod) if(n & 1) res = res * a % mod; return res;\n}\n\nstruct Mint\n{\n    int x;\n    Mint() {x = 0;}\n    Mint(int _x): x(_x) {if(x < 0 || x >= MOD) x = (x % MOD + MOD) % MOD;}\n    Mint(LL _x): x(_x) {if(x < 0 || x >= MOD) x = (x % MOD + MOD) % MOD;}\n    Mint operator - () const{\n        return Mint(MOD - x);\n    }\n    Mint operator + (const Mint &rhs) const{\n        return Mint(x + rhs.x >= MOD ? x + rhs.x - MOD : x + rhs.x);\n    }\n    Mint operator - (const Mint &rhs) const{\n        return Mint(x - rhs.x < 0 ? x - rhs.x + MOD : x - rhs.x);\n    }\n    Mint operator * (const Mint &rhs) const{\n        return Mint((LL)x * rhs.x % MOD);\n    }\n    Mint operator / (const Mint &rhs) const{\n        return Mint(x * fp(rhs.x, -1) % MOD);\n    }\n    Mint& operator += (const Mint &rhs) {\n        x += rhs.x; if(x >= MOD) x -= MOD; return *this;\n    }\n    Mint& operator *= (const Mint &rhs) {\n        x = ((LL)x * rhs.x) % MOD; return *this;\n    }\n    bool operator == (const Mint &rhs) const{\n        return x == rhs.x;\n    }\n    bool operator != (const Mint &rhs) const{\n        return x != rhs.x;\n    }\n    friend ostream& operator << (ostream &out, const Mint &rhs){\n        return out << rhs.x;\n    }\n    friend istream& operator >> (istream &in, Mint &rhs){\n        return in >> rhs.x;\n    }\n};\n\n\nconst int maxn = (int) 2e5 + 20;\nconst int maxm = (int) 1e6 + 20;\n\nstruct Node\n{\n    int f;\n    int idx;\n    Node *p[3];\n    Node() {f = 0; idx = -1; memset(p, 0, sizeof(p));}\n\n    void rev() {f ^= 1; swap(p[1], p[2]);}\n    void push()\n    {\n        if(f)\n        {\n            f = 0;\n            for(int i = 0; i < 3; i++) p[i]->rev();\n        }\n    }\n};\n\nvoid work()\n{\n    int n;\n    cin >>n;\n    string s;\n    cin >>s;\n\n    vector<int> po(n + 1);\n    po[0] = 1;\n    for(int i = 1; i <= n; i++) po[i] = po[i - 1] * 3;\n\n    Node *rt = new Node();\n    for(int i = 0; i < po[n]; i++)\n    {\n        Node *ptr = rt;\n        for(int j = 0; j < n; j++)\n        {\n            int w = i / po[j] % 3;\n            if(!ptr->p[w]) ptr->p[w] = new Node();\n            ptr = ptr->p[w];\n        }\n        ptr->idx = i;\n    }\n\n    for(auto ch : s)\n    {\n        if(ch == 'S') rt->rev();\n        else\n        {\n            Node *ptr = rt;\n            for(int j = 0; j < n; j++)\n            {\n                ptr->push();\n                Node *t = ptr->p[2];\n                ptr->p[2] = ptr->p[1];\n                ptr->p[1] = ptr->p[0];\n                ptr->p[0] = t;\n\n                ptr = ptr->p[0];\n            }\n        }\n\n//        cout <<rt->p[0]->idx <<\" \" <<rt->p[1]->idx <<\" \" <<rt->p[2]->idx <<endl;\n    }\n\n    vector<int> p(po[n]);\n\n    for(int i = 0; i < po[n]; i++)\n    {\n        Node *ptr = rt;\n        for(int j = 0; j < n; j++)\n        {\n            int w = i / po[j] % 3;\n            ptr->push();\n            ptr = ptr->p[w];\n        }\n        p[ptr->idx] = i;\n    }\n    for(int i = 0; i < po[n]; i++)\n        cout <<p[i] <<\" \\n\"[i == po[n] - 1];\n}\n\nint main(int argc, char **argv)\n{\n#ifdef yukihana0416\nfreopen(\"in.txt\", \"r\", stdin);\n//freopen(\"out.txt\", \"w\", stdout);\n#endif // yukihana0416\n//    get_prime();\n//    pre();\n    int tc = 1;\n//    read(tc);\n    for(int ca = 1; ca <= tc; ca++)\n    {\n//        printf(\"Case #%d: \", ca);\n        work();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nint a[555555];\nint nxt[200111][739]; //if we start with j before operation i, what is the next command s.t. after performing it, we get 000000 (-1 if doesn't exist)\nint p3[13];\nconst int LG = 10;\nint dp[739][(1<<LG)+1];\nint flipprep[739];\n\nint flip(int x)\n{\n\tint ans=0; int cur=1;\n\twhile(x>0)\n\t{\n\t\tint d=x%3;\n\t\tif(d==1) d=2;\n\t\telse if(d==2) d=1;\n\t\tans+=cur*d;\n\t\tx/=3;\n\t\tcur*=3;\n\t}\n\treturn ans;\n}\n\nint ans[555555];\nint Spref[255555];\n\nint ssum(int l, int r)\n{\n\tif(l==0) return Spref[r];\n\telse return Spref[r]-Spref[l-1];\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\t//freopen(\"strange-dance-1.out\",\"w\",stdout);\n\t//freopen(\"strange-dance.in\",\"r\",stdin);\n\tint n; cin>>n;\n\tstring s; cin>>s;\n\tp3[0]=1;\n\tfor(int i=1;i<=12;i++) p3[i]=p3[i-1]*3;\n\tfor(int i=0;i<730;i++) \n\t{\n\t\tflipprep[i]=flip(i);\n\t\t//cerr<<i<<' '<<flipprep[i]<<'\\n';\n\t\t//if(i<729) assert(flipprep[i]<729);\n\t}\n\tint m=s.length();\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tSpref[i]=(s[i]=='S');\n\t\tif(i>0) Spref[i]+=Spref[i-1];\n\t}\n\tif(n<=1)\n\t{\n\t\tfor(int i=0;i<p3[n];i++)\n\t\t{\n\t\t\tint cur=i;\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tif(s[j]=='R') \n\t\t\t\t{\n\t\t\t\t\tcur++; cur%=p3[n];\n\t\t\t\t}\n\t\t\t\telse cur=flip(cur);\n\t\t\t}\n\t\t\tans[i]=cur;\n\t\t}\n\t\tfor(int i=0;i<p3[n];i++)\n\t\t{\n\t\t\tcout<<ans[i];\n\t\t\tif(i+1<p3[n]) cout<<' ';\n\t\t}\n\t\tcout<<'\\n';\n\t\treturn 0;\n\t}\n\tint l = n/2;\n\t//last l bits\n\tfor(int i=0;i<p3[l];i++)\n\t{\n\t\tnxt[m][i]=nxt[m-1][i]=-1;\n\t\tif(i==p3[l]-1&&s[m-1]=='R') nxt[m-1][i]=m-1;\n\t}\n\tfor(int i=m-2;i>=0;i--)\n\t{\n\t\tfor(int j=0;j<p3[l];j++)\n\t\t{\n\t\t\tif(j==p3[l]-1&&s[i]=='R')\n\t\t\t{\n\t\t\t\tnxt[i][j]=i;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint nxtbit = j+1;\n\t\t\t\tif(s[i]=='S') nxtbit=flipprep[j];\n\t\t\t\tnxt[i][j]=nxt[i+1][nxtbit];\n\t\t\t}\n\t\t}\n\t}\n\tint r = n-l;\n\t//for every first r bits, and a binary string, i want to know its new value fast\n\tfor(int i=0;i<p3[r];i++)\n\t{\n\t\tfor(int j=0;j<(1<<LG);j++) //this means (bit0,+), (bit1,+), (bit2,+), ..., (bitLG-1, +)\n\t\t{\n\t\t\tint cur=i;\n\t\t\tfor(int k=0;k<LG;k++)\n\t\t\t{\n\t\t\t\tif(j&(1<<k))\n\t\t\t\t{\n\t\t\t\t\tcur=flipprep[cur];\n\t\t\t\t}\n\t\t\t\tcur++;\n\t\t\t\tif(cur>=p3[r]) cur-=p3[r];\n\t\t\t}\n\t\t\tdp[i][j]=cur;\n\t\t\t//assert(cur<p3[r]&&cur>=0);\n\t\t}\n\t}\n\t//now, I iterate over all last l bits\n\tfor(int i=0;i<p3[l];i++)\n\t{\n\t\tint finv=i;\n\t\tfor(int j=0;j<m;j++)\n\t\t{\n\t\t\tif(s[j]=='R') finv++;\n\t\t\telse finv=flipprep[finv];\n\t\t\tif(finv>=p3[l]) finv-=p3[l];\n\t\t}\n\t\t//form the bit string\n\t\tint val=i; //of course, I start from i\n\t\tvector<int> bitstring;\n\t\tint pos=0; int undo=0;\n\t\twhile(pos<m)\n\t\t{\n\t\t\tint nxtpos = nxt[pos][val];\n\t\t\t//done operations from pos to nxtpos\n\t\t\tif(nxtpos!=-1)\n\t\t\t{\n\t\t\t\tbitstring.pb(ssum(pos,nxtpos)&1);\n\t\t\t\tpos=nxtpos+1;\n\t\t\t\tval=0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbitstring.pb(ssum(pos,m-1)&1);\n\t\t\t\tundo=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvector<int> compressed;\n\t\tint curbit=0; int curmult=1;\n\t\t//cerr<<\"I = \"<<i<<\": \";\n\t\tvi remstring;\n\t\tfor(int v:bitstring)\n\t\t{\n\t\t\t//cerr<<v<<' ';\n\t\t\tremstring.pb(v);\n\t\t\tcurbit+=curmult*v;\n\t\t\tcurmult*=2; \n\t\t\tif(curmult>=(1<<LG))\n\t\t\t{\n\t\t\t\tcompressed.pb(curbit);\n\t\t\t\tassert(curbit<(1<<LG));\n\t\t\t\tremstring.clear();\n\t\t\t\tcurmult=1; curbit=0;\n\t\t\t}\n\t\t}\n\t\t//cerr<<'\\n';\n\t\t//cerr<<\"UNDO = \"<<undo<<'\\n';\n\t\tfor(int j=0;j<p3[r];j++)\n\t\t{\n\t\t\tint prefval = j;\n\t\t\tfor(int v:compressed)\n\t\t\t{\n\t\t\t\tprefval = dp[prefval][v];\n\t\t\t}\n\t\t\tfor(int v:remstring)\n\t\t\t{\n\t\t\t\t//cerr<<v<<' '<<prefval<<'\\n';\n\t\t\t\tif(v)\n\t\t\t\t{\n\t\t\t\t\tprefval=flipprep[prefval];\n\t\t\t\t}\n\t\t\t\tprefval++;\n\t\t\t\tif(prefval>=p3[r]) prefval-=p3[r];\n\t\t\t}\n\t\t\t//cerr<<'\\n';\n\t\t\t//cerr<<\"J = \"<<j<<\" PREFVAL = \"<<prefval<<'\\n';\n\t\t\tif(undo) \n\t\t\t{\n\t\t\t\tprefval--;\n\t\t\t\tif(prefval<0) prefval+=p3[r];\n\t\t\t}\n\t\t\tint val = prefval*p3[l]+finv;\n\t\t\tint lab = j*p3[l]+i;\n\t\t\tassert(lab>=0&&lab<p3[n]&&val>=0&&val<p3[n]);\n\t\t\tans[lab]=val;\n\t\t}\n\t}\t\n\tset<int> S;\n\tfor(int i=0;i<p3[n];i++)\n\t{\n\t\tcout<<ans[i];\n\t\tS.insert(ans[i]);\n\t\tif(i+1<p3[n]) cout<<' ';\n\t}\n\tassert(S.size()==p3[n]);\n\tcout<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n#include <vector>\nusing namespace std;\n\n\nclass Radix {\nprivate:\n    const char* s;\n    int a[128];\npublic:\n    Radix(const char* s = \"0123456789ABCDEF\") : s(s) {\n        int i;\n        for (i = 0; s[i]; ++i)\n            a[(int)s[i]] = i;\n    }\n    std::string to(long long p, int q) {\n        int i;\n        if (!p)\n            return \"0\";\n        char t[64] = { };\n        for (i = 62; p; --i) {\n            t[i] = s[p % q];\n            p /= q;\n        }\n        return std::string(t + i + 1);\n    }\n    std::string to(const std::string& t, int p, int q) {\n        return to(to(t, p), q);\n    }\n    long long to(const std::string& t, int p) {\n        int i;\n        long long sm = a[(int)t[0]];\n        for (i = 1; i < (int)t.length(); ++i)\n            sm = sm * p + a[(int)t[i]];\n        return sm;\n    }\n};\n\nbool vector_has(vector<int> vec, int num) {\n    auto itr = std::find(vec.begin(), vec.end(), num);\n    size_t index = std::distance(vec.begin(), itr);\n    if (index != vec.size()) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\nint main() {\n    Radix r;\n    int N, temp;\n    string T;\n    int T_length;\n    cin >> temp;\n    N = (int)pow(3, temp);\n    cin >> T;\n    T_length = (int)T.length();\n    int* list = new int[N];\n    string temp_str;\n\n    // initialize\n    for (int i = 0; i < N; i++) {\n        list[i] = i;\n    }\n\n    // operation\n    for (int i = 0; i < T_length; i++) {\n        // salsa\n        if (T[i] == 'S') {\n            vector<vector<int>> swap_index(N, vector<int>(N));\n            for (int list_index = 0; list_index < N; list_index++)\n            {\n                    // convert list_index from decimal to ternary\n                    temp_str = r.to(list_index, 3);\n                    int temp_str_length = (int)temp_str.length();\n                    // swap 1 with 2\n                    for (int j = 0; j < temp_str_length; j++) {\n                        switch (temp_str[j]) {\n                        case '1':\n                            temp_str[j] = '2';\n                            break;\n                        case '2':\n                            temp_str[j] = '1';\n                            break;\n                        }\n                    }\n                    // convert ternary to decimal\n                    temp = r.to(temp_str, 3);\n\n                    // check if swap hasn't been done for temp and list_index\n                    if (!vector_has(swap_index[list_index], temp)) {\n                        // convert string to integer\n                        swap(list[list_index], list[temp]);\n                        // register swapped opponent\n                        swap_index[list_index].push_back(temp);\n                        swap_index[temp].push_back(list_index);\n                    }\n\n            }\n        }\n        // rumba\n        else\n        {\n            for (int j = N - 1; 0 < j; j--) {\n                swap(list[j - 1], list[j]);\n            }\n        }\n    }\n    int* list_pos = new int[N];\n    for (int i = 0; i < N; i++) {\n        list_pos[list[i]] = i;\n    }\n\n    for (int i = 0; i < N; i++) {\n        cout << list_pos[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define ull unsigned long long\n#define MP make_pair\n#define PII pair<int, int>\n#define PLL pair<ll, ll>\n#define PLI pair<ll, int>\n#define PIL pair<int, ll>\n#define STR string\n#define Fst first\n#define Snd second\n#define SHN 1e9\n#define LSHN 1e18\nusing namespace std;\nint n;\nstring s;\nint chi[800010][3];\nint cnt[800010],ans[531450];\nbool mrk[800010];\nchar str[200010]; \nint tac;\nint build(int x,int y)\n{\n\tint ti=tac;\n\tcnt[tac++]=y;\n\tif (x<n)\n\t{\n\t\tchi[ti][0]=build(x+1,y);\n\t\tchi[ti][1]=build(x+1,pow(3,x)+y);\n\t\tchi[ti][2]=build(x+1,pow(3,x)*2+y);\n\t}\n\treturn ti;\n}\nvoid pushdown(int x)\n{\n\tmrk[x]=0;\n\tif (chi[x][0]!=-1)\n\t{\n\t\tswap(chi[x][1],chi[x][2]);\n\t\tmrk[chi[x][0]]^=1;\n\t\tmrk[chi[x][1]]^=1;\n\t\tmrk[chi[x][2]]^=1;\n\t}\n}\nvoid dfs(int x)\n{\n\tif (mrk[x]) pushdown(x);\n\tif (chi[x][0]==-1) return;\n\tswap(chi[x][0],chi[x][2]),swap(chi[x][1],chi[x][2]);\n\tdfs(chi[x][0]);\n}\nvoid getans(int x,int y,int dep)\n{\n\tif (mrk[x]) pushdown(x);\n\t//cout <<x<<\" \"<<y<<\" ################\\n\";\n\t//cout <<chi[x][0]<<\" \"<<chi[x][1]<<\" \"<<chi[x][2]<<\" ##\\n\";\n\tif (chi[x][0]==-1)\n\t{\n\t\tans[cnt[x]]=y;\n\t\treturn;\n\t}\n\tgetans(chi[x][0],y,dep+1);\n\tgetans(chi[x][1],pow(3,dep)+y,dep+1);\n\tgetans(chi[x][2],pow(3,dep)*2+y,dep+1);\n}\nint main()\n{\n\tscanf(\"%d%s\",&n,&str);\n\tmemset(chi,-1,sizeof(chi));\n\ts=str;\n\tbuild(0,0);\n\tfor (int i=0;i<s.size();i++)\n\t{\n\t\tif (s[i]=='S') mrk[0]^=1;\n\t\telse dfs(0);\n\t}\n\tgetans(0,0,0);\n\tfor (int i=0;i<pow(3,n);i++) printf(\"%d \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <chrono>\n#include <random>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \nstd::mt19937 rnd((int)std::chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\n\nconst int MAXN = 12;\nconst int MAXLEN = 200000;\n\nint n;\nchar s[MAXLEN + 1]; int slen;\nvector<int> ans;\n\nint swapcnt[MAXLEN];\nint nmove, nswap;\n\nvector<int> calc(int n) {\n\tif (n == 0) {\n\t\tvector<int> ret(nmove + 1);\n\t\tREP(i, nmove) ret[i] = i + 1; ret[nmove] = 0;\n\t\treturn ret;\n\t} else {\n\t\tvector<int> sub = calc(n - 1);\n\t\tint partsize = SZ(sub) - nmove;\n\t\tvector<int> nxt(3 * (nmove + partsize));\n\t\tREP(atpart, 3) REPSZ(atpos, sub) {\n\t\t\tint topos = sub[atpos], topart;\n\t\t\tif (topos >= nmove) topart = atpart; else if (swapcnt[topos] % 2 == 0) topart = atpart + 1; else topart = atpart == 0 ? 2 : atpart == 1 ? 3 : 1;\n\t\t\tnxt[atpart * (nmove + partsize) + atpos] = topart * (nmove + partsize) + topos;\n\t\t}\n\t\t//printf(\"nxt:\"); REPSZ(i, nxt) printf(\" %d\", nxt[i]); puts(\"\");\n\t\tvector<int> ret(nmove + 3 * partsize);\n\t\tREP(i, nmove + 3 * partsize) {\n\t\t\tint atpart = i < nmove ? 0 : (i - nmove) / partsize, atpos = i < nmove ? i : nmove + (i - nmove) % partsize;\n\t\t\twhile (true) {\n\t\t\t\tint to = nxt[atpart * (nmove + partsize) + atpos], topart = to / (nmove + partsize), topos = to % (nmove + partsize);\n\t\t\t\t//printf(\"%d: (%d,%d) -> (%d,%d)\\n\", i, atpart, atpos, topart, topos);\n\t\t\t\tif (topos >= nmove) {\n\t\t\t\t\tassert(topart == atpart);\n\t\t\t\t\tret[i] = nmove + (topart == 0 || nswap % 2 == 0 ? atpart : 3 - atpart) * partsize + topos - nmove;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (topart >= 3) {\n\t\t\t\t\tret[i] = topos;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tatpart = topart, atpos = topos;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n}\n\nvoid solve() {\n\tnmove = nswap = 0; REP(i, slen) if (s[i] == 'S') ++nswap; else swapcnt[nmove] = nswap, ++nmove;\n\tvector<int> trans = calc(n);\n\t//printf(\"trans:\"); REPSZ(i, trans) printf(\" %d\", trans[i]); puts(\"\");\n\tint totsize = SZ(trans) - nmove;\n\tans=vector<int>(totsize);\n\tREP(i, totsize) {\n\t\tint atpos = nmove + i;\n\t\twhile (true) {\n\t\t\tint topos = trans[atpos];\n\t\t\tif (topos >= nmove) {\n\t\t\t\tans[i] = topos - nmove;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tatpos = topos;\n\t\t\t}\n\t\t}\n\t}\n\t//printf(\"ans:\"); REPSZ(i, ans) printf(\" %d\", ans[i]); puts(\"\");\n}\n\nvoid run() {\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", s); slen = strlen(s);\n\tsolve();\n\tREPSZ(i, ans) { if (i != 0) printf(\" \"); printf(\"%d\", ans[i]); } puts(\"\");\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* Generated by powerful Codeforces Tool\n * You can download the binary file in here https://github.com/xalanq/cf-tool (win, osx, linux)\n * Author: step_by_step\n * Time: 2020-03-19 17:35:03\n**/\n\n//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n  \n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n#include <bitset>\n\n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = (l); i < (r); i++)\n#define repb(i, r, l) for (int i = (r); i > (l); i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n#define next dfghjk\n#define prev fhsgfhjf\n#define plus fsghsf\n#define minus ytryr\n  \nusing namespace std;\n  \ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n  \nconst int N = 100000 + 1;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst ld eps = 1e-9;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\nint pw[12 + 1];\n\nvoid init() {\n    pw[0] = 1;\n    rep(i, 1, 12 + 1) {\n        pw[i] = pw[i - 1] * 3;\n    }\n}\n\nvector<int> perm[12 + 1];\nvector<int> jump[12 + 1];\nint sw;\nint where[531441];\n\nvoid solve(string &s, int n) {\n    if (n == 0) {\n        perm[n].push_back(0);\n        rep(i, 0, sz(s)) {\n            if (s[i] == 'S') {\n                jump[n].push_back(-1);\n            } else {\n                jump[n].push_back(0);\n            }\n        }\n        return;\n    }\n    solve(s, n - 1);\n    rep(i, 0, pw[n]) {\n        where[i] = i / pw[n - 1];\n    }\n    sw = 0;\n    rep(i, 0, sz(s)) {\n        if (s[i] == 'S') {\n            sw ^= 1;\n            jump[n].push_back(-1);\n        } else {\n            int rem = jump[n - 1][i];\n            rep(j, 0, 3) {\n                int x = j * pw[n - 1] + rem;\n                int cur_id = where[x];\n                if (sw == 1) {\n                    if (cur_id == 1) {\n                        cur_id = 2;\n                    } else if (cur_id == 2) {\n                        cur_id = 1;\n                    }\n                }\n                if (cur_id == 2) {\n                    jump[n].push_back(x);\n                }\n                cur_id = (cur_id + 1) % 3;\n                if (sw == 1) {\n                    if (cur_id == 1) {\n                        cur_id = 2;\n                    } else if (cur_id == 2) {\n                        cur_id = 1;\n                    }\n                }\n                where[x] = cur_id;\n            }\n        }\n    }\n    rep(x, 0, pw[n]) {\n        int rem = x % pw[n - 1];\n        int cur_id = where[x];\n        if (sw == 1) {\n            if (cur_id == 1) {\n                cur_id = 2;\n            } else if (cur_id == 2) {\n                cur_id = 1;\n            }\n        }\n        perm[n].push_back(cur_id * pw[n - 1] + perm[n - 1][rem]);\n    }\n}\n\nint main()\n{\n    //freopen(\"circus.in\", \"r\", stdin);\n    //freopen(\"circus.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    //ll TL = 10.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    init();\n    int n;\n    string s;\n    cin >> n >> s;\n    solve(s, n);\n    for (int i : perm[n]) {\n        cout << i << \" \";\n    }\n    cout << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { os << '{'; string sep; for (const auto &x : v) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename T, size_t size> ostream& operator<<(ostream &os, const array<T, size> &arr) { os << '{'; string sep; for (const auto &x : arr) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<typename T>\nvoid output_vector(const vector<T> &v, bool add_one = false, int start = -1, int end = -1) {\n    if (start < 0) start = 0;\n    if (end < 0) end = int(v.size());\n\n    for (int i = start; i < end; i++)\n        cout << v[i] + (add_one ? 1 : 0) << (i < end - 1 ? ' ' : '\\n');\n}\n\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int N;\n    string T;\n    cin >> N >> T;\n    int L = int(T.size());\n    vector<int> P3(N + 1, 1);\n\n    for (int i = 1; i <= N; i++)\n        P3[i] = 3 * P3[i - 1];\n\n    vector<int> P(P3[N], 0);\n    vector<int> last(L + 1, 0);\n\n    for (int n = 1; n <= N; n++) {\n        int P_n = P3[n], P_low = P3[n - 1];\n\n        for (int i = P_low; i < P_n; i++)\n            P[i] = P[i % P_low];\n\n        vector<int> D(P_n, -1);\n\n        for (int i = 0; i < P_n; i++)\n            D[i] = i / P_low;\n\n        vector<int> last_updated(P_n, 0);\n        vector<bool> partial_flips(L + 1, false);\n\n        auto &&get_D = [&](int index, int now) {\n            bool flip = partial_flips[now] ^ partial_flips[last_updated[index]];\n\n            if (flip && D[index] > 0)\n                D[index] = 3 - D[index];\n\n            last_updated[index] = now;\n            return D[index];\n        };\n\n        auto &&increment = [&](int index, int now) {\n            D[index] = (get_D(index, now) + 1) % 3;\n        };\n\n        vector<int> next_last(L + 1, -1);\n        next_last[0] = last[0] + 2 * P_low;\n\n        for (int i = 0; i < L; i++) {\n            partial_flips[i + 1] = partial_flips[i];\n\n            if (T[i] == 'S') {\n                partial_flips[i + 1] = !partial_flips[i];\n            } else {\n                increment(last[i], i);\n                increment(last[i] + P_low, i);\n                increment(last[i] + 2 * P_low, i);\n            }\n\n            for (int x = 0; x < 3; x++)\n                if (get_D(last[i + 1] + x * P_low, i + 1) == 2)\n                    next_last[i + 1] = last[i + 1] + x * P_low;\n        }\n\n        for (int i = 0; i < P_n; i++)\n            P[i] += get_D(i, L) * P_low;\n\n        last = next_last;\n        dbg(P);\n        dbg(last);\n    }\n\n    output_vector(P);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n \nint main(){\n  std::cout << \"I have no idea.\";\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <limits.h>\n#include <stdio.h>\n#include <cmath>\n#include <math.h>\n#include <float.h>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef tuple<int,int> i2tuple;\n\nvector <vector<int>> parent; //parent[i] will hold the parent of i in the shortest path from src to vertex i\nvector <double> dist; // distance[i] will hold the shortest distance from src to vertex i\nvector <bool> vis; // vis[i] will be true if vertex i is included in shortest\nint len;\nint n;\nstring dance;\nvector<vector<double>> matrix;\nvector<vector<double>> matrixV;\nvector<vector<bool>> matrixInclude;\nvector <char> dances;\nvector <int> locations;\n\n\nvoid salsa();\n\nvoid rumba();\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n;\n    cin>>dance;\n    len = pow(3, n);\n    dances = vector<char>(dance.length());\n    locations = vector<int>(len);\n    for (int i = 0; i < len; i++) {\n        locations[i] = i;\n    }\n    for (int i = 0; i < dance.length(); i++) {\n        if(dance[i] == 'S'){\n            salsa();\n\n        }else{\n            rumba();\n        }\n    }\n    for(int i = 0; i< len; i++){\n        printf(\"%d \", locations[i]);\n    }\n}\nchar reVal(int num)\n{\n    if (num >= 0 && num <= 9)\n        return (char)(num + '0');\n    else\n        return (char)(num - 10 + 'A');\n}\n\n// Utility function to reverse a string\nvoid strev(char *str)\n{\n    int len = strlen(str);\n    int i;\n    for (i = 0; i < len/2; i++)\n    {\n        char temp = str[i];\n        str[i] = str[len-i-1];\n        str[len-i-1] = temp;\n    }\n}\nchar* fromDeci(char res[], int base, int inputNum)\n{\n    int index = 0;  // Initialize index of result\n\n    // Convert input number is given base by repeatedly\n    // dividing it by base and taking remainder\n    while (inputNum > 0)\n    {\n        res[index++] = reVal(inputNum % base);\n        inputNum /= base;\n    }\n    res[index] = '\\0';\n\n    // Reverse the result\n    strev(res);\n\n    return res;\n}\nint val(char c)\n{\n    if (c >= '0' && c <= '9')\n        return (int)c - '0';\n    else\n        return (int)c - 'A' + 10;\n}\n\n// Function to convert a number from given base 'b'\n// to decimal\nint toDeci(char *str, int base)\n{\n    int len = strlen(str);\n    int power = 1; // Initialize power of base\n    int num = 0;  // Initialize result\n    int i;\n\n    // Decimal equivalent is str[len-1]*1 +\n    // str[len-2]*base + str[len-3]*(base^2) + ...\n    for (i = len - 1; i >= 0; i--)\n    {\n        // A digit in input number must be\n        // less than number's base\n        if (val(str[i]) >= base)\n        {\n            printf(\"Invalid Number\");\n            return -1;\n        }\n\n        num += val(str[i]) * power;\n        power = power * base;\n    }\n\n    return num;\n}\n\nvoid rumba() {\n    for(int j = 0; j< len; j++ ){\n        int num = locations[j];\n        int new_num = num +1;\n        if(new_num == len){\n            new_num = 0;\n        }\n        locations[j] = new_num;\n    }\n}\n\nvoid salsa() {\n    for(int j = 0; j< len; j++ ){\n        int num = locations[j];\n        //printf(\"location[j] = %d \\n\", num);\n        char res[len];\n        char* a = fromDeci(res, 3, num);\n        int k = 0;\n        while(a[k] != '\\0'){\n            if((a[k]) == '1'){\n                a[k] = '2';\n            }else if(a[k] == '2'){\n                a[k] = '1';\n            }\n            k++;\n        }\n        int new_num = toDeci(a, 3);\n       // printf(\"after change salsa location[j] = %d \\n\", new_num);\n        locations[j] = new_num;\n    }\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nnamespace IO\n{\nchar gc()\n{\n#ifdef FREAD\n\tstatic char buf[1<<21], *P1 = buf, *P2 = buf;\n\tif(P1 == P2)\n\t{\n\t\tP1 = buf;\n\t\tP2 = buf + fread(buf, 1, 1<<21, stdin);\n\t\tif(P1 == P2) return EOF;\n\t}\n\treturn *(P1++);\n#else\n\treturn getchar();\n#endif\n}\ntemplate<typename Tp> bool get1(Tp &x)\n{\n\tbool neg = 0;\n\tchar c = gc();\n\twhile( c != EOF && (c < '0' || c > '9') && c != '-' ) c = gc();\n\tif(c == '-') c = gc(), neg = 1;\n\tif(c == EOF) return false;\n\tx = 0;\n\tfor(; c>='0' && c<='9'; c = gc()) x = x*10 + c - '0';\n\tif(neg) x = -x;\n\treturn true;\n}\ntemplate<typename Tp> void printendl(Tp x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tstatic short a[40], sz;\n\tsz = 0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n\tputs(\"\");\n}\n} // namespace IO\nusing IO::get1;\nusing IO::printendl;\n#define get2(x,y) get1(x) && get1(y)\n#define get3(x,y,z) get2(x,y) && get1(z)\n#define get4(x,y,z,w) get3(x,y,z) && get1(w)\n#define pb push_back\n#define mp std::make_pair\n#define ff first\n#define ss second\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef std::pair<int,int> pii;\nconst int inf = 0x3f3f3f3f;\nconst LL Linf = 1ll<<61;\n\nconst int maxn = 2000111;\nconst int N = 13;\n\nint go[maxn][3], tot, power[N], val[maxn];\nbool inv[maxn];\nvoid inverse(int t)\n{\n\tinv[t] ^= 1;\n\tstd::swap(go[t][1], go[t][2]);\n}\nvoid push(int t)\n{\n\tif(inv[t])\n\t{\n\t\tfor(int i=0; i<3; i++) if(go[t][i]) inverse(go[t][i]);\n\t\tinv[t] = 0;\n\t}\n}\n\nint n, ans[maxn];\nvoid dfs(int o, int d, int num)\n{\n\tif(d == n)\n\t{\n\t\tval[o] = num;\n\t\treturn;\n\t}\n\tfor(int i=0; i<3; i++)\n\t{\n\t\tgo[o][i] = ++tot;\n\t\tdfs(go[o][i], d+1, num + power[d] * i);\n\t}\n}\nvoid dfs2(int o, int d, int num)\n{\n\tif(d == n)\n\t{\n\t\tans[val[o]] = num;\n\t\treturn;\n\t}\n\tpush(o);\n\tfor(int i=0; i<3; i++) dfs2(go[o][i], d+1, num + power[d] * i);\n}\n\nchar s[maxn];\nint main()\n{\n\tpower[0] = 1;\n\tfor(int i=1; i<N; i++) power[i] = power[i-1] * 3;\n\t\n\tget1(n);\n\tint rt = ++tot;\n\tdfs(rt, 0, 0);\n\t\n\tscanf(\"%s\", s);\n\tfor(int i=0; s[i]; i++)\n\t{\n\t\tif(s[i] == 'S') inverse(rt);\n\t\telse\n\t\t{\n\t\t\tint cur = rt;\n\t\t\twhile(cur)\n\t\t\t{\n\t\t\t\tpush(cur);\n\t\t\t\tint tmp = go[cur][2];\n\t\t\t\tgo[cur][2] = go[cur][1];\n\t\t\t\tgo[cur][1] = go[cur][0];\n\t\t\t\tgo[cur][0] = tmp;\n\t\t\t\tcur = tmp;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdfs2(rt, 0, 0);\n\tfor(int i=0; i<power[n]; i++) printf(\"%d \", ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n#include \"debug.h\"\n#else\n#define DEBUG(...)\n#endif\n\ntemplate <class T, class Op = multiplies<T>>\nconstexpr T power(T a, long long n, Op op = Op(), T e = {1}) {\n  assert(n >= 0);\n  while (n) {\n    if (n & 1) e = op(e, a);\n    if (n >>= 1) a = op(a, a);\n  }\n  return e;\n}\n\nint f(int n) {\n  int res = 0, b = 1;\n  while (n) {\n    int r = n % 3;\n    res += (r ? 3 - r : 0) * b;\n    b *= 3;\n    n /= 3;\n  }\n  return res;\n}\n\nvector<int> solve(int n, string s) {\n  reverse(begin(s), end(s));\n  int m = power(3, n);\n  vector<int> p(m, -1);\n  auto to = [&](int i) {\n    for (char c : s) {\n      if (c == 'S') {\n        i = f(i);\n      } else {\n        i = (i + m - 1) % m;\n      }\n    }\n    return i;\n  };\n  p[0] = to(0);\n  for (int k = 0; k < n; ++k) {\n    p[power(3, k)] = to(power(3, k));\n    p[2 * power(3, k)] = to(2 * power(3, k));\n  }\n  for (int i = 0; i < m; ++i) {\n    if (p[i] != -1) continue;\n    // p[i] = to(i);\n    // continue;\n    p[i] = i;\n    int cur = i;\n    for (int k = n; k--; ) {\n      if (cur >= 2 * power(3, k)) {\n        cur -= 2 * power(3, k);\n        p[i] = p[cur] + p[2 * power(3, k)] - p[0] + m;\n        p[i] %= m;\n        break;\n      } else if (cur >= power(3, k)) {\n        p[i] = p[cur] + p[power(3, k)] - p[0] + m;\n        p[i] %= m;\n        cur -= power(3, k);\n        break;\n      }\n    }\n  }\n  // return p;\n  vector<int> res(m);\n  for (int i = 0; i < m; ++i) {\n    res[p[i]] = i;\n  }\n  return res;\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  string s;\n  cin >> s;\n  auto res = solve(n, s);\n  int m = size(res);\n  for (int i = 0; i < m; ++i) {\n    cout << res[i] << \" \\n\"[i == m - 1];\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define calc(x) swap((x)->son[1], (x)->son[2])\nusing namespace std;\n\nchar s[200010];\n\nstruct Node {\n\tint x, rev;\n\tNode *son[3];\n\tNode() {x = -1, son[0] = son[1] = son[2] = NULL, rev = 0;}\n\tvoid pushdown() {\n\t\tif (!rev) return ;\n\t\tson[0]->rev ^= 1, son[1]->rev ^= 1, son[2]->rev ^= 1;\n\t\tcalc(son[0]), calc(son[1]), calc(son[2]);\n\t\trev = 0;\n\t}\n}pool[1500000], *CUR = pool;\n\nNode *Build(int l, int r, int dep, int x) {\n\tif (l == r) {\n\t\tCUR->x = x;\n\t\treturn CUR++;\n\t}\n\tNode *now = CUR++;\n\tint m1 = l + (r - l + 1) / 3 - 1;\n\tint m2 = l + (r - l + 1) / 3 * 2 - 1;\n\tnow->son[0] = Build(l, m1, dep * 3, x);\n\tnow->son[1] = Build(m1 + 1, m2, dep * 3, x + dep);\n\tnow->son[2] = Build(m2 + 1, r, dep * 3, x + dep * 2);\n\treturn now;\n}\n\nvoid Update(Node *T) {\n\tif (T->x != -1) return ;\n\tT->pushdown();\n\tswap(T->son[0], T->son[2]), swap(T->son[1], T->son[2]);\n\tUpdate(T->son[0]);\n}\n\nint ans[540000];\n\nvoid print(Node *T, int dep, int x) {\n\tif (T->x != -1) {\n\t\tans[T->x] = x;\n\t\treturn ;\n\t}\n\tT->pushdown();\n\tprint(T->son[0], dep * 3, x);\n\tprint(T->son[1], dep * 3, x + dep);\n\tprint(T->son[2], dep * 3, x + dep * 2);\n}\n\nint main () {\n\tint n; scanf(\"%d\", &n);\n\tint N = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tN *= 3;\n\t}\n\tN--;\n\tNode *T = Build(0, N, 1, 0);\n\tscanf(\"%s\", s); int m = strlen(s);\n\tfor (int i = 0; i < m; i++) {\n\t\tif (s[i] == 'R') Update(T);\n\t\telse {\n\t\t\tT->rev ^= 1;\n\t\t\tcalc(T);\n\t\t}\n\t}\n\tprint(T, 1, 0);\n\tfor (int i = 0; i <= N; i++) {\n\t\tprintf(\"%d \", ans[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+5;\nint n,rt,tot,sum[N],ans[N],t[N][3],lz[N];\nchar s[N];\nvoid build(int &now,int n,int b,int c)\n{\n    now=++tot;\n    if(n==0){sum[now]=c;return;}\n    build(t[now][0],n-1,b*3,c);\n    build(t[now][1],n-1,b*3,c+b);\n    build(t[now][2],n-1,b*3,c+b+b);\n}\nvoid updata(int now,int n)\n{\n    swap(t[now][1],t[now][2]);\n    lz[t[now][0]]^=1;\n    lz[t[now][1]]^=1;\n    lz[t[now][2]]^=1;\n    lz[now]=0;\n}\nvoid solve(int now,int n)\n{\n    if(n==0) return;\n    if(lz[now]) updata(now,n);\n    int a=t[now][0],b=t[now][1],c=t[now][2];\n    t[now][1]=a;t[now][2]=b;t[now][0]=c;\n    solve(t[now][0],n-1);\n}\nvoid getans(int now,int n,int b,int c)\n{\n    if(n==0){ans[sum[now]]=c;return;}\n    if(lz[now]) updata(now,n);\n    getans(t[now][0],n-1,b*3,c);\n    getans(t[now][1],n-1,b*3,c+b);\n    getans(t[now][2],n-1,b*3,c+b+b);\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    scanf(\"%s\",s+1);\n    build(rt,n,1,0);\n    for(int i=1;s[i];i++)\n    {\n        if(s[i]=='S') lz[rt]^=1;\n        else solve(rt,n);\n    }\n    getans(rt,n,1,0);\n    int sum=1;for(int i=1;i<=n;i++) sum*=3;\n    for(int i=0;i<sum;i++) printf(i==sum-1?\"%d\\n\":\"%d \",ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=601000;\nint n,pw[20],pos[N];\nchar s[N];\nstruct node {\n\tnode *s[3];\n\tint lab;\n\tbool rev;\n\tvoid setr() {\n\t\trev^=1;\n\t\tswap(s[1],s[2]);\n\t}\n\tvoid push() {\n\t\tif (rev) { rep(j,0,3) if (s[j]) s[j]->setr(); rev=0; }\n\t}\n}pool[N],*cur=pool,*rt;\n\nint main() {\n\tscanf(\"%d\",&n);\n\tpw[0]=1;\n\tfor (int i=1;i<=n;i++) pw[i]=pw[i-1]*3;\n\trt=cur++;\n\trep(i,0,pw[n]) {\n\t\tnode *p=rt;\n\t\trep(j,0,n) {\n\t\t\tint w=i/pw[j]%3;\n\t\t\tif (!p->s[w]) p->s[w]=cur++;\n\t\t\tp=p->s[w];\n\t\t}\n\t\tp->lab=i;\n\t}\n\tscanf(\"%s\",s);\n\tint m=strlen(s);\n\trep(i,0,m) if (s[i]=='S') {\n\t\trt->setr();\n\t} else {\n\t\tnode *p=rt;\n\t\trep(j,0,n) {\n\t\t\tp->push();\n\t\t\tnode *t=p->s[2]; p->s[2]=p->s[1]; p->s[1]=p->s[0]; p->s[0]=t;\n\t\t\tp=p->s[0];\n\t\t}\n\t}\n\trep(i,0,pw[n]) {\n\t\tnode *p=rt;\n\t\trep(j,0,n) {\n\t\t\tint w=i/pw[j]%3;\n\t\t\tp->push(); p=p->s[w];\n\t\t}\n\t\t//printf(\"zz %d\\n\",p-cur);\n\t\tpos[p->lab]=i;\n\t\t//printf(\"%d \",p->lab);\n\t}\n\trep(i,0,pw[n]) printf(\"%d%c\",pos[i],\" \\n\"[i==pw[n]-1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 600005\n#define MX 13\nusing namespace std;\n\nint now[SIZE];\nint memo[MX][SIZE];\nchar T[SIZE];\nint id[SIZE];\n\nvoid change(int &t)\n{\n\tif(t==1) t=2;\n\telse if(t==2) t=1;\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",&T);\n\tint m=strlen(T);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint t=1;\n\t\tfor(int j=0;j<=i;j++) t*=3;\n\t\tfor(int j=0;j<t;j++)\n\t\t{\n\t\t\tint x=j;\n\t\t\tfor(int k=0;k<i;k++) x/=3;\n\t\t\tnow[j]=x;\n\t\t}\n\t\tbool flip=false;\n\t\tfor(int j=0;j<m;j++)\n\t\t{\n\t\t\tif(T[j]=='S') flip=!flip;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint x=id[j];\n\t\t\t\tint K=0;\n\t\t\t\tfor(int k=0;k<3;k++)\n\t\t\t\t{\n\t\t\t\t\tint to=k*(t/3)+x;\n\t\t\t\t\tif(flip) change(now[to]);\n\t\t\t\t\tif(now[to]==2)\n\t\t\t\t\t{\n\t\t\t\t\t\tK=k;\n\t\t\t\t\t\tnow[to]=0;\n\t\t\t\t\t}\n\t\t\t\t\telse now[to]++;\n\t\t\t\t\tif(flip) change(now[to]);\n\t\t\t\t}\n\t\t\t\tid[j]+=K*(t/3);\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<t;j++)\n\t\t{\n\t\t\tif(flip) change(now[j]);\n\t\t\tmemo[i][j]=now[j];\n\t\t}\n\t}\n\tint T=1;\n\tfor(int i=0;i<n;i++) T*=3;\n\tfor(int i=0;i<T;i++)\n\t{\n\t\tint ret=0,t=1;\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tt*=3;\n\t\t\tret+=memo[j][i%t]*(t/3);\n\t\t}\n\t\tprintf(\"%d \",ret);\n\t}\n\tputs(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint cng(int x){\n  int y=0, i=0, z;\n  while(x > 0){\n    z = x%3;\n    if(z==1){\n      z=2;\n    }else if(z==2){\n      z=1;\n    }\n    y += z*pow(10,i);\n    x = x/3;\n    i++; \n  }\n  string temp=to_string(y);\n  int lg=temp.length();\n  int ans=0;\n  for(int i=0;i<lg;i++){\n    ans+=(temp.at(i)-'0')*pow(3,lg-i-1);\n  }\n  return ans;\n}\n  \n  \nint main(){\n  int n;\n  long long sn=0,rn=0;\n  cin>>n;\n  string s;\n  cin>>s;\n  int slength=s.length();\n  for(int i=0;i<slength;i++){\n    if(s.at(i)=='S') sn++;\n    if(s.at(i)=='R') rn++;\n  }\n  \n  int N=pow(3,n);\n  int ANS[N];\n\n  for(int i=0;i<N;i++){\n    ANS[i]=i;\n  }\n  \n  for(int i=0;i<N;i++){\n    ANS[i]=(ANS[i]+rn)%N;\n  } \n  \n  if(sn%2==1){\n    for(int i=0;i<N;i++){\n      //cout<<ANS[i]<<\"#\";//**\n      ANS[i]=cng(ANS[i]);\n      //cout<<ANS[i]<<\"k\";//**\n    }\n  } \n  //cout<<sn<<\" \"<<rn<<endl;\n  for(int i=0;i<N;i++){\n    if(i!=0)cout<<\" \";\n    cout<<ANS[i];\n  } \n  cout<<endl;\n  return 0;\n}\n\n    \n    \n    \n    \n    "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define snd second\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef long double ldb;\n\ntemplate<class T> inline void checkmin(T &a,const T &b){if(b<a) a=b;}\ntemplate<class T> inline void checkmax(T &a,const T &b){if(b>a) a=b;}\n\nconst int inf=1e9+10;\nconst int maxn=1e6+10;\n\nint a[maxn*3][3],d[maxn*3],id[maxn*3],ans[maxn];\nint n,p[15];\nstring s;\n\nvoid build(int c,int x,int pos){\n\tif(c==n){\n\t//\tcout<<x<<\" \"<<pos<<endl;\n\t\tid[x]=pos;\n\t\treturn;\n\t}\n\tfor(int i=0;i<3;i++){\n\t\ta[x][i]=x*3+i;\n\t\tbuild(c+1,x*3+i,pos+i*p[c]);\n\t}\n}\n\nvoid apply(int x){\n\td[x]=!d[x];\n\tswap(a[x][1],a[x][2]);\n//\tcout<<a[x][1]<<\" \"<<a[x][2]<<endl;\n}\n\nvoid update(int x){\n\tif(d[x]==false) return;\n\td[x]=false;\n\tfor(int i=0;i<3;i++) apply(a[x][i]);\n}\n\nvoid add(int c,int x){\n\tif(c==n){\n\t\treturn;\n\t} \n\telse{\n\t\tupdate(x);\n\t\tswap(a[x][1],a[x][2]);\n\t\tswap(a[x][0],a[x][1]);\n\t\tadd(c+1,a[x][0]);\n\t}\n}\n\nvoid dfs(int c,int x,int pos) {\n\tif(c==n){\n\t\tans[id[x]]=pos;\n\t} \n\telse{\n\t\tupdate(x);\n\t\tfor(int i=0;i<3;i++){\n\t\t\tdfs(c+1,a[x][i],pos+i*p[c]);\n\t\t}\n\t}\n}\n\nint main(){\n\tp[0]=1;\n\tfor(int i=1;i<15;i++) p[i]=p[i-1]*3;\n\tcin>>n>>s;\n\tint n2=n;\n\tbuild(0,1,0);\n\tfor(int i=0;i<s.size();i++){\n\t\tif(s[i]=='S'){\n\t\t\td[1]^=1;\n\t\t//\tcout<<i<<endl;\n\t\t}\n\t\telse{\n\t\t\tadd(0,1);\n\t\t}\n\t//\tdfs(0,1,0);\n\t//\tfor(int i=0;i<3;i++) cout<<ans[i]<<\" \"; cout<<endl;\n\t}\n\tdfs(0,1,0);\n\tn=1;\n\tfor(int i=0;i<n2;i++) n=n*3;\n\tfor(int i=0;i<n;i++) cout<<ans[i]<<\" \";\n\tcout<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-9;\n\nint N, M, K, H, W, L, R;\n//long long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tstring s;\n\tcin >> s;\n\tvector<int>three(N + 1, 1);\n\tfor (int i = 1; i <= N; i++) {\n\t\tthree[i] = three[i - 1] * 3;\n\t}\n\tvector<vector<vector<int>>>place(N + 1);\n\tvector<vector<int>>ed(N + 1);\n\tfor (int i = 1; i <= N; i++) {\n\t\tplace[i].resize(three[i]);\n\t\ted[i].resize(three[i]);\n\t}\n\ts = 'A' + s;\n\tplace[0].resize(1);\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tif(s[i]=='R')place[0][0].push_back(i);\n\t}\n\tvector<int>sum(s.size());\n\tfor (int i = 1; i < s.size(); i++) {\n\t\tsum[i] = s[i] == 'S';\n\t\tsum[i] += sum[i - 1];\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 0; j<three[i]; j++) {\n\t\t\tint p = j / three[i - 1];\n\t\t\tint md = j % three[i - 1];\n\t\t\tint cn = 0;\n\t\t\tfor (auto k : place[i - 1][md]) {\n\t\t\t\tif (sum[k] % 2 != sum[cn] % 2) {\n\t\t\t\t\tp = (3 - p) % 3;\n\t\t\t\t}\n\t\t\t\tcn = k;\n\t\t\t\tp++;\n\t\t\t\tif (p == 3) {\n\t\t\t\t\tp = 0;\n\t\t\t\t\tplace[i][j].push_back(k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sum.back() % 2 != sum[cn] % 2) {\n\t\t\t\tp = (3 - p) % 3;\n\t\t\t}\n\t\t\ted[i][j] = p;\n\t\t}\n\t}\n\tfor (int i = 0; i < three[N]; i++) {\n\t\tint ans = 0;\n\t\tfor (int j = N; j > 0; j--) {\n\t\t\tans *= 3;\n\t\t\tans += ed[j][i%three[j]];\n\t\t}\n\t\tcout << ans << \" \";\n\t}\n\tcout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Node{\n\tint s[3],val,tag;\n}t[1<<21];\n\nint nds=0;\n\nvoid pd(int now){\n\tif(t[now].tag){\n\t\tif(t[now].s[0]){\n\t\t\tt[t[now].s[0]].tag^=1;\n\t\t\tt[t[now].s[1]].tag^=1;\n\t\t\tt[t[now].s[2]].tag^=1;\n\t\t}\n\t\tswap(t[now].s[1],t[now].s[2]);\n\t\tt[now].tag=0;\n\t}\n}\n\nvoid ops(){\n\tt[1].tag^=1;\n}\n\nvoid opr(int now=1){\n\tpd(now);\n\tif(!t[now].s[0]){\n\t\treturn;\n\t}\n\tswap(t[now].s[1],t[now].s[2]);\n\tswap(t[now].s[0],t[now].s[1]);\n\topr(t[now].s[0]);\n}\n\nint n;\n\nint init(int nr=n,int ch=1,int val=0){\n\tint now=++nds;\n\tif(nr==1){\n\t\tt[now].val=val;\n\t\treturn now;\n\t}\n\tt[now].s[0]=init(nr/3,ch*3,val);\n\tt[now].s[1]=init(nr/3,ch*3,val+ch);\n\tt[now].s[2]=init(nr/3,ch*3,val+ch*2);\n\treturn now;\n}\n\nint get(int to,int nr=n,int now=1){\n\tpd(now);\n\tif(nr==1){\n\t\treturn t[now].val;\n\t}\n\treturn get(to/3,nr/3,t[now].s[to%3]);\n}\n\nchar T[200005];\nint p[1<<20];\n\nint main(){\n\tint N;\n\tscanf(\"%d\",&N);\n\tn=1;\n\tfor(int i=0;i<N;i++){\n\t\tn*=3;\n\t}\n\tinit();\n\tscanf(\"%s\",T);\n\tfor(int f=0;T[f];f++){\n\t\tif(T[f]=='S'){\n\t\t\tops();\n\t\t}else{\n\t\t\topr();\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tp[get(i)]=i;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tprintf(\"%d%c\",p[i],\" \\n\"[i==n-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint n;\nchar T[200005];\n\nvector<int> inc[12][550000];\nint ans[12][550000];\nint psum[200005];\n\nint pwr3[15];\n\nint main()\n{\n    pwr3[0] = 1;\n    for (int i = 1; i < 15; i++) pwr3[i] = 3 * pwr3[i-1];\n    scanf(\"%d\", &n);\n    scanf(\"%s\", T + 1);\n    int tsiz = 0;\n    for (int i = 1; T[i]; i++) {\n        tsiz = i;\n        psum[i] = psum[i-1] + (T[i] == 'S' ? 1 : 0);\n    }\n    for (int s = 0; s < 3; s++) {\n        int cur = s;\n        for (int i = 1; T[i]; i++) {\n            if (T[i] == 'S') {\n                if (cur) cur = 3 - cur;\n            } else {\n                cur++;\n                if (cur == 3) {\n                    cur = 0; inc[0][s].push_back(i);\n                }\n            }\n        }\n        ans[0][s] = cur;\n    }\n    for (int dig = 1; dig < n; dig++) {\n        for (int high = 0; high < 3; high++) {\n            for (int low = 0; low < pwr3[dig]; low++) {\n                int num = high * pwr3[dig] + low;\n                int lastinc = 0;\n                int curhigh = high;\n                for (int i = 0; i < inc[dig-1][low].size(); i++) {\n                    int curinc = inc[dig-1][low][i];\n                    if ((psum[curinc] - psum[lastinc]) % 2) {\n                        if (curhigh) curhigh = 3 - curhigh;\n                    }\n                    curhigh++;\n                    if (curhigh == 3) {\n                        curhigh = 0; inc[dig][num].push_back(curinc);\n                    }\n                    lastinc = curinc;\n                }\n                if ((psum[tsiz] - psum[lastinc]) % 2) {\n                    if (curhigh) curhigh = 3 - curhigh;\n                }\n                ans[dig][num] = curhigh * pwr3[dig] + ans[dig-1][low];\n            }\n        }\n    }\n    for (int i = 0; i < pwr3[n]; i++) {\n        printf(\"%d \", ans[n-1][i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nusing namespace std;\n\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n\n#define putchar_unlocked putchar\n\nchar T[524288];\nint res[1048576];\n\n// Based on editorial solution\nint D[16][1048576]; // one digit at a time, with digit 0 representing the ones place\nint W[16][1048576];\nint lastUpdated[16][1048576];\n\nint x[16];\ninline void putInt(int i){\n    if(i==0){putchar_unlocked('0');}\n    else{\n    int count1=0;\n    while(i>0){\n        x[count1++]=i%10;\n        i/=10;\n    }\n    for(int j=count1-1;j>=0;j--){\n        putchar_unlocked(48+x[j]);\n    }\n    }\n    putchar_unlocked(' ');\n}\n\nint N;\n\ninline void update(int n, int indx, int cntS){\n    if( ((cntS&1) != (lastUpdated[n][indx]&1)) && D[n][indx]){\n        // conduct salsa\n        D[n][indx] = 3-D[n][indx];\n    }\n    // update the lastUpdated index\n    lastUpdated[n][indx] = cntS;\n}\n\nint pow3[16];\n\nint main(){\n    scanf(\"%d\", &N);\n    scanf(\" %s\", T);\n\n    int M = strlen(T);\n\n    pow3[0] = 1;\n    for(int i = 1; i <= N; i ++){\n        pow3[i] = pow3[i-1]*3;\n    }\n\n    //memset(W, 0, sizeof(W));\n    for(int n = 1; n <= N; n ++){\n        //printf(\"ok\");\n        for(int j = 0; j < pow3[n-1]; j ++){\n            D[n][j] = 0;\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        for(int j = pow3[n-1]; j < (pow3[n-1]<<1); j ++){\n            D[n][j] = 1;\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        for(int j = (pow3[n-1]<<1); j < pow3[n]; j ++){\n            D[n][j] = 2;\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        W[n][0] = pow3[n]-1;\n    }\n\n    //memset(lastUpdated, 0, sizeof(lastUpdated));\n    int cntS2 = 0;\n    for(int n = 1; n <= N; n ++){\n        int cntS = 0;\n        for(int i = 0; i < M; i ++){\n            int indx0 = W[n-1][i];\n            int indx1 = W[n-1][i]+pow3[n-1];\n            int indx2 = W[n-1][i]+(pow3[n-1]<<1);\n\n            if(indx1 >= pow3[n]){indx1 -= pow3[n];}\n            if(indx2 >= pow3[n]){indx2 -= pow3[n];}\n\n            update(n, indx0, cntS+(T[i]=='S'));\n            update(n, indx1, cntS+(T[i]=='S'));\n            update(n, indx2, cntS+(T[i]=='S'));\n            if(D[n][indx0] == 2){\n                W[n][i] = indx0;\n            }else if(D[n][indx1] == 2){\n                W[n][i] = indx1;\n            }else{\n                W[n][i] = indx2;\n            }\n\n            if(T[i] == 'R'){\n                D[n][indx0] = (D[n][indx0]+1);\n                D[n][indx1] = (D[n][indx1]+1);\n                D[n][indx2] = (D[n][indx2]+1);\n                if(D[n][indx0] == 3){D[n][indx0] = 0;}\n                if(D[n][indx1] == 3){D[n][indx1] = 0;}\n                if(D[n][indx2] == 3){D[n][indx2] = 0;}\n                lastUpdated[n][indx0] = cntS;\n                lastUpdated[n][indx1] = cntS;\n                lastUpdated[n][indx2] = cntS;\n            }else if(T[i] == 'S'){\n                cntS ++;\n            }\n\n            //printf(\"W[%d][%d]=%d\\n\", n, i+1, W[n][i+1]);\n        }\n\n        cntS2 = cntS;\n    }\n\n    for(int n = 1; n <= N; n ++){\n        for(int i = 0; i < pow3[n]; i ++){\n            update(n, i, cntS2);\n        }\n\n        int cnt = 0;\n        for(int i = 0; i < pow3[N]; i ++){\n            res[i] += D[n][cnt++]*pow3[n-1];\n            if(cnt == pow3[n]){cnt = 0;}\n        }\n    }\n\n    for(int i = 0; i < pow3[N]; i ++){\n        /*int temp = 0;\n        for(int n = 1; n <= N; n ++){\n            temp += D[n][i%pow3[n]]*pow3[n-1];\n        }*/\n        //putInt(temp);\n        putInt(res[i]);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXV = 6.1e5;\nconst int MAXN = 13;\nint p3[MAXN];\nint n;\n\nstruct node {\n\tint idx;\n\tnode* c[3];\n\tbool lazy;\n};\n\nnode* init(int cur, int pos) {\n\tnode* v = new node();\n\tif (cur == n) {\n\t\t// leaf\n\t\tv->idx = pos;\n\t} else {\n\t\tfor (int x = 0; x < 3; x++) {\n\t\t\tv->c[x] = init(cur+1, pos + p3[cur] * x);\n\t\t}\n\t}\n\treturn v;\n}\n\nvoid apply(node* v) {\n\tassert(v);\n\tv->lazy = !v->lazy;\n\tswap(v->c[1], v->c[2]);\n}\n\nvoid propagate(node* v) {\n\tif (!v->lazy) return;\n\tv->lazy = false;\n\tfor (int x = 0; x < 3; x++) apply(v->c[x]);\n}\n\nvoid upd(node* v, int cur) {\n\tif (cur == n) {\n\t\t// leaf\n\t} else {\n\t\tpropagate(v);\n\t\tswap(v->c[1], v->c[2]);\n\t\tswap(v->c[0], v->c[1]);\n\t\tupd(v->c[0], cur+1);\n\t}\n}\n\nint ans[MAXV];\n\nvoid dfs(node* v, int cur, int pos) {\n\tif (cur == n) {\n\t\tans[v->idx] = pos;\n\t} else {\n\t\tpropagate(v);\n\t\tfor (int x = 0; x < 3; x++) dfs(v->c[x], cur+1, pos + x * p3[cur]);\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(0), cin.tie(0);\n\tstring t;\n\tcin >> n >> t;\n\tp3[0] = 1;\n\tfor (int i = 1; i <= n; i++) p3[i] = p3[i-1] * 3;\n\tnode* tr = init(0, 0);\n\tfor (char op : t) {\n\t\tif (op == 'R') {\n\t\t\tupd(tr, 0);\n\t\t} else if (op == 'S') {\n\t\t\tapply(tr);\n\t\t} else assert(false);\n\t}\n\tdfs(tr, 0, 0);\n\tfor (int i = 0; i < p3[n]; i++) {\n\t\tcout << ans[i] << \" \\n\"[i+1==p3[n]];\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  long long a=0,b=0,c=0,d=0,m=0,n=0,p=0,q=0;\n  string t;\n  cin >> n >> t;\n  \n  map<long long,long long> san;\n  san[0]=1;\n  san[1]=3;\n  san[2]=9;\n  san[3]=27;\n  san[4]=81;\n  san[5]=243;\n  san[6]=729;\n  san[7]=2187;\n  san[8]=6561;\n  san[9]=19683;\n  san[10]=59049;\n  san[11]=177147;\n  san[12]=531441;\n  \n  vector<long long> wa(san.at(n),0);\n  for(long long i=0;i<san.at(n);i++)\n  {\n\t  wa.at(i)=i;\n  }\n  for(long long i=0;i<t.size();i++)\n  {\n\t  if(t.at(i)=='R')\n\t  {\n\t\t  wa.insert(wa.begin(),wa.at(wa.size()-1));\n\t\t  wa.pop_back();\n\t  }\n\t  if(t.at(i)=='S')\n\t  {   a=0;\n\t\t  vector<bool> kanryou(san.at(n),false);\n\t\t  vector<int> bunkai(n,0);\n\t\t  for(long long k=0;k<san.at(n);k++)\n\t\t  {\n\t\t\t  if(kanryou.at(k)==false)\n\t\t\t  {\n\t\t\t\t  a=k;\n\t\t\t\t  for(int j=0;j<n;j++)\n\t\t\t\t  {\n\t\t\t\t\t  while(a>=san.at(n-j))\n\t\t\t\t\t  {\n\t\t\t\t\t\t  a=a-san.at(n-j);\n\t\t\t\t\t\t  bunkai.at(n-j-1)++;\n\t\t\t\t\t  }\n\t\t\t\t\t  if(bunkai.at(n-j-1)==1)\n\t\t\t\t\t  {\n\t\t\t\t\t\t  bunkai.at(n-j-1)=2;\n\t\t\t\t\t  }\n\t\t\t\t\t  else if(bunkai.at(n-j-1)==2)\n\t\t\t\t\t  {\n\t\t\t\t\t\t  bunkai.at(n-j-1)=1;\n\t\t\t\t\t  }\n\t\t\t\t  }\n\t\t\t\t  for(int j=0;j<n;j++)\n\t\t\t\t  {   \n\t\t\t\t\t  a+=bunkai.at(j)*san.at(j);\n\t\t\t\t  }\n\t\t\t\t  swap(wa.at(a),wa.at(k));\n\t\t\t\t  kanryou.at(a)=true;\n\t\t\t\t  kanryou.at(k)=true;\n\t\t\t  }\n\t\t  }\n\t  }\n  }\n  vector<long long> ok(san.at(n),0);\n  \n  for(long long i=0;i<wa.size();i++)\n  {\n\t  ok.at(wa.at(i))=i;\n  }\n  for(long long i=0;i<wa.size();i++)\n  {\n    cout << ok.at(i) << ' ';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "//Konrad Paluszek,University of Warsaw(former XIV LO Staszic)\n//#STAY AT HOME\n#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n#define TIME (chrono::steady_clock::now().time_since_epoch().count())\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#define xfm(a,b)a##b\n#define xwb(a,b)xfm(a,b)\n#define _ xwb(nvj,__LINE__)\n#define __ xwb(kjy,__LINE__)\n#define ___ xwb(cjm,__LINE__)\n#define REP(i,n)for(urs(n)i=0;i<(n);++i)\n#define UNTIL(t)while(clock()<(t)*CLOCKS_PER_SEC)\n#define PER(r...)for(bool _=1;_||next_permutation(r);_=false)\n#define ALL(r)(r).begin(),(r).end()\n#define RALL(r)(r).rbegin(),(r).rend()\n#define FS(r)r.first,r.second\n#define SF(r)r.second,r.first\n#define M0(r) memset(r, 0, sizeof(r))\n#define sim template<class c\n#define ros return o\n#define rans return ans\n#define forbits(i,m)if(m)for(urs(m)i=ctz(m),i##nvj=m;i##nvj;i##nvj^=((urs(m))1<<i),i=ctz(i##nvj))\n#define fordbits(i,m)if(m)for(urs(m)i=8*sizeof(m)-clz(m)-1,i##nxd=m;i##nxd;i##nxd^=((urs(m))1<<i),i=8*sizeof(m)-clz(i##nxd)-1)\n#define ksets(t, m, k, n) for (t m = (((t)1 << (k)) - 1); m < ((t)1 << (n)); m = nux(m))\n#define urs(r...)typename decay<decltype(r)>::type\n#define hur(f,g,r)sim>int f(c a){if(sizeof(c)==16)return r;if(sizeof(c)==8)return g##ll(a);return g(a);}\n#define pwq(t,i) int clz(t x){return clz<int>(x)-i;}\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wconversion\"\nusing namespace __gnu_pbds;using namespace std;using ll=long long;using ld=long double;using ull=unsigned long long;using vi=vector<int>;using pii=pair<int,int>;using pll=pair<ll,ll>;using vpii=vector<pii>;using spii=set<pii>;using mii=map<int,int>;using unt=unsigned int;sim>using min_queue=priority_queue<c,vector<c>,greater<c>>;sim,class b,class cmp=less<c> >using ordered_map=tree<c,b,cmp,rb_tree_tag,tree_order_statistics_node_update>;sim, class cmp=less<c>>using ordered_set = ordered_map<c,null_type,cmp>;hur(popc,__builtin_popcount,popc<ull>(a)+popc<ull>(a>>64))hur(ctz,__builtin_ctz,(ull)a?ctz<ull>(a):64+ctz<ull>(a>>64))hur(clz,__builtin_clz,a>>64?clz<ull>(a>>64):64+clz<ull>(a))pwq(short,16)pwq(uint16_t,16)pwq(char,24)pwq(int8_t,24)pwq(uint8_t,24)sim,class N>bool mini(c&o,const N&h){if(o>h)ros=h,1;return 0;}sim,class N>bool maxi(c&o,const N&h){if(o<h)ros=h,1;return 0;}sim,class n>using gyv=c;\n#if defined(LOCAL) // || defined(LOCAL2)\n#include </home/kjp/headers/debuglib.hpp>\n#else\n#define loc(...)\n#define onl(r...)r\n#define debug(...)\n#define print_stack(...)\n#define mark_stack(...)\n#define set_pre(...)\n#define reg_it(...)\n#define def_op(...) struct _{};\n#if !defined(LOCAL) && !defined(LOCAL2)\n#define exit my_exit\nvoid my_exit(int x) {fflush(stdout);_Exit(x);}\n#endif\n#endif\n#define next nexT\n#define prev preV\n#define tree trEE\n#define left lefT\n#define right righT\n#define div diV\n#define y1 y_1\n#define pow do not use cmath pow unless you know what you are doing\null mix(ull o){o+=0x9e3779b97f4a7c15;o=(o^(o>>30))*0xbf58476d1ce4e5b9;o=(o^(o>>27))*0x94d049bb133111eb;ros^(o>>31);}ull SALT=0x7a14a4b0881ebf9,tqu=0x7a14a4b0881ebf9;ull my_rand(){return tqu=mix(tqu);}void my_srand(ull x){SALT=tqu=x;}const int inf = 1023400000;const ll llinf=1234567890000000000ll;ll fix(ll o, ll m){o%=m;if(o<0)o+=m;ros;}\n#define rand my_rand\n#define srand my_srand\n#define random_shuffle(r...)random_shuffle(r,[](int _){return my_rand()%_;})\nsim>inline c nux(c m){if(!m)return numeric_limits<c>::max();c A=m&-m;c B=~((A-1)^m);c C=B&-B;c D=(C>>(1+ctz(A)))-1;return C|(m&~(C-1))|D;}__attribute__((no_sanitize_undefined))ll mul(ll a,ll b,ll m){ll q=(ll)(a*(ld)b/m);ll o=a*b-q*m;o%=m;if(o<0)o+=m;ros;}sim>void unq(c&x){x.resize(unique(ALL(x))-x.begin());}\n#pragma GCC diagnostic pop\n#if ((ULONG_MAX) != (UINT_MAX))\nnamespace std {template <> struct is_signed<__int128> : public true_type {};}\n#endif\nsim, class d> typename common_type<c,d>::type floor_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using floor_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b - (a % b < 0);}\nsim, class d> typename common_type<c,d>::type ceil_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using ceil_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b + (a % b > 0);}\nsim> struct REV {using value_type=typename c::value_type;c &x;using it=typename c::reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> struct CREV {using value_type=typename c::value_type;const c&x;using it=typename c::const_reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> REV<c> reversed(c&x) {return REV<c>{x};}sim> CREV<c> reversed(const c&x) {return CREV<c>{x};}\n#define done(r...) exit(0 * printf(r))\n#if defined(LOCAL) || defined(LOCAL2)\nvoid __tmi() {cerr << setprecision(6) << fixed << \"total time: \" << clock() / (ld)CLOCKS_PER_SEC << \"s\" << endl;}int _ = (atexit(__tmi), 0);\n#endif\n//#STAY AT HOME\nconst int nax = 531441, root = 729;\nint n, h1, h2;\nint swap12(int x) {\n\tint ans = 0;\n\tint p = 1;\n\twhile (x) {\n\t\tint b = x % 3;\n\t\tx /= 3;\n\t\tif (b) b ^= 3;\n\t\tans += p * b;\n\t\tp *= 3;\n\t}\n\trans;\n}\nchar row[nax];\nint p3(int x) {\n\tint ans = 1;\n\tREP(_, x) ans *= 3;\n\trans;\n}\nset <vi> reachable;\nshort which_block[nax];\nshort nums_in_block[nax];\nshort block_ord[root];\nshort swaps[nax];\nvoid s() {//trits map\n\tREP(i, h1) block_ord[i] = swaps[block_ord[i]];\n\tREP(i, h2) {\n\t\tint j = swaps[i];\n\t\tif (i > j) swap(nums_in_block[i], nums_in_block[j]);\n\t}\n}\nvoid r() {//rotate\n\tstatic int moves_to[root];\n\tint change = nums_in_block[h2 - 1];\n\tfor (int i = 0; i + 1 < h1; ++i) {\n\t\tint curr = block_ord[i], next = block_ord[i + 1];\n\t\tmoves_to[curr] = next;\n\t}\n\tmoves_to[block_ord[h1 - 1]] = block_ord[0];\n\tfor (int num = change; num < n; num += h2)\n\t\twhich_block[num] = moves_to[which_block[num]];\n\trotate(nums_in_block, nums_in_block + h2 - 1, nums_in_block + h2);\n}\nvoid extract() {\n\tstatic int block_pos[root], num_inv[root];\n\tREP(i, h1) block_pos[block_ord[i]] = i;\n\tREP(i, h2) num_inv[nums_in_block[i]] = i;\n\tREP(i, n)\n\t\tprintf(\"%d \", h2 * block_pos[which_block[i]] + num_inv[i % h2]);\n\tprintf(\"\\n\");\n}\nint main() {\n\tscanf(\"%d\", &n);\n\th1 = n / 2, h2 = n - h1;\n\th1 = p3(h1), h2 = p3(h2);\n\tn = p3(n);\n\tREP(i, root) swaps[i] = swap12(i);\n\tREP(i, n) which_block[i] = i / h2;\n\tiota(block_ord, block_ord + h1, 0);\n\tiota(nums_in_block, nums_in_block + h2, 0);\n\tscanf(\"%s\", row);\n\tfor (int i = 0; row[i]; ++i) {\n\t\tif (row[i] == 'S') s();\n\t\telse r();\n\t}\n\textract();\n}\n//#STAY AT HOME\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nstatic inline char CH()\n{\n  static char buf[100000],*ptr1=buf,*ptr2=buf;\n  return ptr1==ptr2&&(ptr2=(ptr1=buf)+fread(buf,1,100000,stdin),ptr1==ptr2)?EOF:*ptr1++;\n}\nstatic inline int IN(void)\n{\n  int x=0,f=0,c=CH();while(c<48||c>57){f^=c==45,c=CH();}\n  while(c>47&&c<58){x=x*10+c-48,c=CH();}return f?-x:x;\n}\nstatic inline int Pow(int a,int b){return b?Pow(a*a,b>>1)*(b&1?a:1):1;}\nint main()\n{\n  int N=IN(),now,len=0,pw3=Pow(3,N),x=Pow(3,N>>1),y=Pow(3,N-(N>>1)),A[531441],B[531441];\n  char c=CH(),T[200001],S[200000];\n  rep(i,pw3)B[i]=B[i/3]*3+(3-i%3)%3;\n  while(c!=EOF){if(c=='\\t'||c==' '||c=='\\n'){c=CH();}T[len++]=c,c=CH();}\n  fflush(stdin);\n  rep(i,x)\n  {\n    int temp=i;now=0;\n    rep(j,len)\n    {\n      if(T[j]=='S'){temp=B[temp];if(S[now]=='S')--now;else S[++now]='S';}\n      else{++temp;if(temp==x)S[++now]='R',temp=0;}\n    }\n    rep(j,y)\n    {\n      int keep=j;\n      rep(k,now)\n      {\n        if(S[k+1]=='S')keep=B[keep];\n        else if(S[k+1]=='R')if((++keep)==y)keep=0;\n      }\n      A[i+j*x]=temp+keep*x;\n    }\n  }\n  rep(i,pw3)printf(\"%d \",A[i]);\n  return fflush(stdout),0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n;\nconst int maxN = 13;\nint pw3[maxN];\nvector < int > events[729];\nstring t;\nint pos[729];\nint mvR[729];\nint mvBig[729];\nint cur[729];\nint ans[729 * 729];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> n;\n    pw3[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        pw3[i] = 3 * pw3[i - 1];\n    }\n    int small = (n + 1) / 2;\n    int big = n - small;\n\n    for (int j = 0; j < pw3[small]; j++) {\n        mvR[j] = 0;\n        for (int p = 0; p < small; p++) {\n            int bit = (j / pw3[p]) % 3;\n            if (bit != 0) {\n                bit = 3 - bit;\n            }\n            mvR[j] += bit * pw3[p];\n        }\n    }\n    for (int j = 0; j < pw3[big]; j++) {\n        mvBig[j] = 0;\n        for (int p = 0; p < big; p++) {\n            int bit = (j / pw3[p]) % 3;\n            if (bit != 0) {\n                bit = 3 - bit;\n            }\n            mvBig[j] += bit * pw3[p];\n        }\n    }\n    cin >> t;\n    for (int i = 0; i < pw3[small]; i++) {\n        for (int j = 0; j < pw3[big]; j++) {\n            pos[j] = j;\n            cur[j] = 0;\n        }\n        int cur_res = 0;\n        int their_res = i;\n        for (int j = 0; j < t.size(); j++) {\n            if (t[j] == 'S') {\n                cur_res ^= 1;\n                their_res = mvR[their_res];\n            }\n            else {\n                if (their_res == pw3[small] - 1) {\n                    their_res = 0;\n                    for (int c = 0; c < pw3[big]; c++) {\n                        int t = cur_res ^ cur[c];\n                        if (t) {\n                            pos[c] = mvBig[pos[c]];\n                        }\n                        pos[c]++;\n                        if (pos[c] == pw3[big]) pos[c] = 0;\n                        cur[c] = cur_res;\n                    }\n                }\n                else {\n                    their_res++;\n                }\n            }\n        }\n        for (int j = 0; j < pw3[big]; j++) {\n            if (cur[j] ^ cur_res) {\n                pos[j] = mvBig[pos[j]];\n            }\n            ans[j * pw3[small] + i] = pos[j] * pw3[small] + their_res;\n        }\n    }\n    for (int j = 0; j < pw3[n]; j++) {\n        cout << ans[j] << \" \";\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,x,y,sw,pw3=1,A[531441],B[531441];\nchar S[200000],T[200001];\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nsigned main(void)\n{\n  x=scanf(\"%d %s\",&N,T);\n  replace(T,\"SS\",\"\");if(T[0]=='\\n')return 0;\n  rep(i,N)\n  {\n    rep(j,pw3)rep(k,3)B[j+k*pw3]=k;sw=0;\n    rep(j,strlen(T))\n    {\n      if(T[j]=='R')\n      {\n        if(!S[j])y=0;else y=S[j]-'0';\n        rep(k,3){x=y+k*pw3;if(B[x]+sw==2)S[j]=x+'0';B[x]+=sw+1;B[x]%=3;}\n      }\n      if(T[j]=='S')sw^=1;\n    }\n    rep(j,pw3){y=A[j];rep(k,3){x=j+k*pw3;A[x]=y+(sw?3-B[x]:B[x])%3*pw3;}}\n    pw3*=3;\n  }\n  rep(i,pw3)printf(\"%d%c\",A[i],i+1==pw3?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(long long i=0;i<(long long)N;i++)\nint N,o,p,x,y,pos,pw3[36]={1},A[1000000],salsa[555555],sw[1000000];\nchar T[200001];\nvoid OUT(long long x){if(x<0)putchar('-'),x=-x;if(x>=10)OUT(x/10);putchar(x%10+48);}\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nvoid Dance(char c[])\n{\n  if(c[p]==EOF)return;\n  if(c[p]=='S'){x=salsa[x];if(sw[pos]>0)pos--;else sw[++pos]=1;}\n  if(c[p]=='R'){x++;if(x==pw3[N/2])sw[++pos]=-1,x=0;}\n}\nvoid Update(void)\n{\n  rep(i,pw3[N-N/2])\n  {\n    y=i;\n    rep(j,pos){if(sw[j+1]>0)y=salsa[y];else if(sw[j+1]<0){if((++y)==pw3[N-N/2])y=0;}}\n    A[o+i*pw3[N/2]]=y*pw3[N/2]+x;\n  }\n}\nsigned main(void)\n{\n  o=scanf(\"%d %s\",&N,T+1);\n  replace(T+1,\"SS\",\"\");if(T[0]=='\\n')return 0;\n  rep(i,N)pw3[i+1]=3*pw3[i];\n  rep(i,pw3[N])salsa[i]=salsa[i/3]*3+(3-i%3)%3;\n  rep(i,pw3[N/2]){o=i,x=i,pos=0;rep(j,strlen(T+1)){p=j+1,Dance(T);}Update();}\n  rep(i,pw3[N])OUT(A[i]),putchar(' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\nusing namespace std;\n\nchar t[200001];\nint dancer[531442];\nint flag[531442];\n\nint pow(int x, int y) {\n\tint result = 1;\n\tfor (int i = 0; i < y; ++i) {\n\t\tresult *= x;\n\t}\n\treturn result;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tcin >> t;\n\tint length = strlen(t);\n\tint temp = 0,temp1;\n\tint three[12];\n\tint max = 1;\n\tfor (int i = 0; i < pow(3, n); ++i) {\n\t\tdancer[i] = i;\n\t}\n\tfor (int i = 0; i < length; ++i) {\n\t\tif (t[i] == 'S') {\n\t\t\tfor (int i = 0; i < pow(3, n); ++i) {\n\t\t\t\tif (flag[i] != 1) {\n\t\t\t\t\tfor (int j = 1; j <= 12; ++j) {\n\t\t\t\t\t\tif (pow(3, j) > i) {\n\t\t\t\t\t\t\tmax = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttemp = i;\n\t\t\t\t\tfor (int j = max - 1; j >= 0; --j) {\n\t\t\t\t\t\tif (temp >= 2 * pow(3, j)) {\n\t\t\t\t\t\t\tthree[max - 1 - j] = 1;\n\t\t\t\t\t\t\ttemp -= 2 * pow(3, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (temp >= pow(3, j)) {\n\t\t\t\t\t\t\tthree[max - 1 - j] = 2;\n\t\t\t\t\t\t\ttemp -= pow(3, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthree[max - 1 - j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttemp = 0;\n\t\t\t\t\tfor (int j = max - 1; j >= 0; --j) {\n\t\t\t\t\t\ttemp += pow(3, j) * three[max - 1 - j];\n\t\t\t\t\t}\n\t\t\t\t\tflag[temp] = 1;\n\t\t\t\t\ttemp1 = dancer[temp];\n\t\t\t\t\tdancer[temp] = dancer[i];\n\t\t\t\t\tdancer[i] = temp1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < pow(3, n); ++i) {\n\t\t\t\tflag[i] = 0;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttemp = dancer[pow(3, n) - 1];\n\t\t\tfor (int i = pow(3, n) - 1; i > 0; --i) {\n\t\t\t\tdancer[i] = dancer[i - 1];\n\t\t\t}\n\t\t\tdancer[0] = temp;\n\t\t}\n\t}\n\tfor (int i = 0; i < pow(3, n); ++i) {\n\t\tif (i == 0) {\n\t\t\tfor (int j = 0; j < pow(3, n); ++j) {\n\t\t\t\tif (dancer[j] == i) {\n\t\t\t\t\tcout << j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int j = 0; j < pow(3, n); ++j) {\n\t\t\tif (dancer[j] == i) {\n\t\t\t\tcout << \" \" << j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\nusing namespace std\nint main(void) {\n    int N;\n    char *T;\n    scanf(\"%d\", &N);\n    cin.get(T);\n    if (strcmp(T,\"SRS\")) {\n        printf(\"2 0 1\");\n    }\n    else if (strcmp(T , \"RRSRSSSSR\")) {\n        printf(\"3 8 1 0 5 7 6 2 4\");\n    }\n    else {\n        printf(\"23 9 22 8 3 7 20 24 19 5 18 4 17 12 16 2 6 1 14 0 13 26 21 25 11 15 10\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n\nusing namespace std;\n\nlong long int N;\nstring T;\n\nvoid R(int *data);\nvoid S(int *data1, int *data2);\nlong long int X(int x, int y);\n\nint main(){\n  int n;\n  string s1;\n  string s2;\n  cin >> n;\n  cin >> T;\n  N = X(3, n);\n  int L[N];\n  int K[N];\n  int O[N];\n  \n  for(long long int i=0;i<N;i++){\n    L[i] = i;\n  }\n  \n  for(long long int i=0;i<N/3;i++){\n    int k = i;\n    int tmp = 0;\n    int m = 3;\n    int q = i*3;\n    \n    while(k>0){\n      if(k%3==1){\n        tmp = tmp +2*m;\n      }else if(k%3==2){\n        tmp = tmp +1*m;\n      }\n      k = k/3;\n      m = m*3;\n    }\n    K[tmp] = q;\n    K[tmp + 1] = q+2;\n    K[tmp + 2] = q+1;\n  }\n  \n  \n  for(int i=0;i<(int)(T.length());i++){\n    s1 = T[i];\n    s2 = T[i+1];\n    if(s1==\"R\"){\n      R(L);\n    }else if(s1==\"S\" && s2==\"S\"){\n      i++;\n    }else{\n      S(L,K);\n    }\n  }\n  \n\n\n  for(long long int i=0;i<N;i++){\n    cout << L[i] << \" \";\n  }\n  return 0;\n}\n\nvoid R(int *data){\n  for(long long int i=0;i<N;i++){\n    data[i] = data[i] + 1;\n    if(data[i]==N){\n      data[i]=0;\n    }\n  }\n}\n\nvoid S(int *data1, int *data2){\n  for(long long int i=0;i<N;i++){\n    data1[i] = data2[data1[i]];\n  }\n}\n\n\nlong long int X(int x,int y){\n  long long int a = 1;\n  for(int i=0;i<y;i++){\n    a = a*x;\n  }\n  return a;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define eb(x,y) emplace_back(x,y)\n#define fi first\n#define se second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=6e5+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\n//inline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\ninline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nint t[MAXN],s[3][MAXN],p[MAXN],d[MAXN],Fpow[20],N,len,n,tot=1,ans[MAXN];char ch[MAXN];\nstruct Node{int id,x,d;};\ninline void Build(){\n\tqueue<Node>q;q.push((Node){1,0,0});\n\twhile(!q.empty()){\n\t\tint x=q.front().id;d[x]=q.front().d,p[x]=q.front().x,q.pop();\n\t\tif(d[x]<n)Rep(i,0,2)s[i][x]=++tot,q.push((Node){s[i][x],p[x]+Fpow[d[x]]*i,d[x]+1});\n\t}\n}\ninline void pushr(int x){swap(s[1][x],s[2][x]),t[x]^=1;}\ninline void pushdown(int x){if(t[x])pushr(s[0][x]),pushr(s[1][x]),pushr(s[2][x]),t[x]=0;}\ninline void Add(int x){\n\tpushdown(x);if(d[x]==n)return;\n\tint s0=s[0][x],s1=s[1][x],s2=s[2][x];\n\ts[1][x]=s0,s[2][x]=s1,s[0][x]=s2,Add(s[0][x]);\n}\nvoid dfs(int x,int val,int d){if(x!=1)ans[p[x]]=val;pushdown(x);if(d==n)return;Rep(i,0,2)dfs(s[i][x],val+Fpow[d]*i,d+1);}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),scanf(\"%s\",ch+1),len=strlen(ch+1);\n\tFpow[0]=1;Rep(i,1,n)Fpow[i]=Fpow[i-1]*3;N=Fpow[n];\n\tBuild();dfs(1,0,0);Rep(i,0,N-1)cout<<ans[i]<<\" \";cout<<'\\n';\n\tRep(i,1,len){\n\t\tif(ch[i]=='S')pushr(1);\t\n\t\telse if(ch[i]=='R')Add(1);\n\t}dfs(1,0,0);Rep(i,0,N-1)cout<<ans[i]<<' ';cout<<\"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<class T>\nistream &operator>>(istream &is, vector<T> &v) {\n  for (T &x : v)\n    is >> x;\n  return is;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nint n;\n\nint rev(int x) {\n  static int dig[20];\n  for (int i = 0; i < n; ++i) {\n    dig[i] = x % 3;\n    x /= 3;\n  }\n  int ret = 0;\n  for (int i = 0; i < n; ++i)\n    ret = ret * 3 + dig[i];\n  return ret;\n}\n\nint ch[1000005][3];\nbool tag[1000005];\nint val[1000005], ans[1000005];\n\nint cnt, v;\n\nint build(int k) {\n  int o = ++cnt;\n  if (k == 0) {\n    val[o] = rev(v++);\n    return o;\n  }\n  ch[o][0] = build(k - 1);\n  ch[o][1] = build(k - 1);\n  ch[o][2] = build(k - 1);\n  return o;\n}\n\nvoid pd(int o) {\n  if (tag[o]) {\n    tag[o] = false;\n    swap(ch[o][1], ch[o][2]);\n    for (int i = 0; i < 3; ++i) tag[ch[o][i]] ^= 1;\n  }\n}\n\nvoid ad(int o, int k) {\n  if (k == 0)\n    return;\n  pd(o);\n  swap(ch[o][1], ch[o][2]);\n  swap(ch[o][0], ch[o][1]);\n  ad(ch[o][0], k - 1);\n}\n\nint dfn;\nvoid dfs(int o, int k) {\n  if (k == 0) {\n    ans[val[o]] = rev(dfn++);\n    return;\n  }\n  pd(o);\n  for (int i = 0; i < 3; ++i)\n    dfs(ch[o][i], k - 1);\n}\n\nint main() {\n#ifdef ELEGIA\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> n;\n  string t;\n  cin >> t;\n  int root = build(n);\n  for (char c : t) {\n    if (c == 'S')\n      tag[root] ^= 1;\n    else\n      ad(root, n);\n  }\n  dfs(root, n);\n  int m = pow(3, n);\n  cout << vector<int>(ans, ans + m);\n\n#ifdef ELEGIA\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n\nusing namespace std;\n\nint N;\nstring T;\n\nvoid R(int *data);\nvoid S(int *data1, int *data2);\nint X(int x, int y);\n\nint main(){\n  int n;\n  string s;\n  cin >> n;\n  cin >> T;\n  N = X(3, n);\n  int L[N];\n  int K[N];\n  int O[N];\n  \n  for(int i=0;i<N;i++){\n    L[i] = i;\n  }\n  \n  for(int i=0;i<N/3;i++){\n    int k = i;\n    int tmp = 0;\n    int m = 3;\n    int q = i*3;\n    \n    while(k>0){\n      if(k%3==1){\n        tmp = tmp +2*m;\n      }else if(k%3==2){\n        tmp = tmp +1*m;\n      }\n      k = k/3;\n      m = m*3;\n    }\n    K[tmp] = q;\n    K[tmp + 1] = q+2;\n    K[tmp + 2] = q+1;\n  }\n  \n  \n  for(int i=0;i<(int)(T.length());i++){\n    s = T[i];\n    if(s == \"S\"){\n      S(L, K);\n    }else{\n      R(L);\n    }\n  }\n  \n  \n  for(int i=0;i<N;i++){\n    O[L[i]] = i;\n  }\n  \n\n\n  for(int i=0;i<N;i++){\n    cout << O[i] << \" \";\n  }\n  return 0;\n}\n\nvoid R(int *data){\n  int tmp = data[N-1];\n  for(int i=0;i<N;i++){\n    int a = data[i];\n    data[i] = tmp;\n    tmp = a;\n  }\n}\nvoid S(int *data1, int *data2){\n  int T[N];\n  for(int i=0;i<N;i++){\n    T[i] = data1[data2[i]];\n  }\n  for(int i=0;i<N;i++){\n    data1[i] = T[i];\n  }\n}\n\n\nint X(int x,int y){\n  int a = 1;\n  for(int i=0;i<y;i++){\n    a = a*x;\n  }\n  return a;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string>\n#include<cmath>\n\nusing namespace std;\n\nint sch(int n){\n    int out=0,tmp,count=0;\n    while(n != 0){\n        tmp = n % 3;\n        if(tmp==1){\n            out += 2*pow(3,count);\n        }else if(tmp==2){\n            out += pow(3,count);\n        }\n        count++;\n        n /= 3;\n    }\n    return out;\n}\n\nint main(){\n    int N,p,*table,size;\n    string T;\n    cin >> N;\n    cin >> T;\n    size = int(pow(3,N));\n    table = new int[size];\n    for(int i=0;i<size;i++){\n        table[i] = sch(i);\n    }\n    for(int i=0;i<size;i++){\n        p=i;\n        for(int j=0;j<T.length();j++){\n            if(T[j] == 'S'){\n                p=table[p];\n            }else{\n                p++;\n                if(p==size) p=0;\n            }\n        }\n        cout << p << ' ';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nstatic inline char CH()\n{\n  static char buf[100000],*ptr1=buf,*ptr2=buf;\n  return ptr1==ptr2&&(ptr2=(ptr1=buf)+fread(buf,1,100000,stdin),ptr1==ptr2)?EOF:*ptr1++;\n}\nstatic inline int IN(void)\n{\n  int x=0,f=0,c=CH();while(c<48||c>57){f^=c==45,c=CH();}\n  while(c>47&&c<58){x=x*10+c-48,c=CH();}return f?-x:x;\n}\nstatic inline int Pow(int a,int b){return b?Pow(a*a,b>>1)*(b&1?a:1):1;}\nint main()\n{\n  int N=IN(),now,len=0,pw3=Pow(3,N),x=Pow(3,N>>1),y=Pow(3,N-(N>>1)),A[1000001],B[600001];\n  char c=CH(),T[1000001],S[1000001];\n  rep(i,pw3)B[i]=B[i/3]*3+(3-i%3)%3;\n  while(c!=EOF){if(c==10){c=CH();}T[1+len++]=c,c=CH();}\n  rep(i,x)\n  {\n    int temp=i;now=0;\n    rep(j,len)\n    {\n      if(T[j+1]=='S'){temp=B[temp];(S[now]=='S')?--now:S[++now]='S';}\n      else{++temp;if(temp==x)S[++now]='R',temp=0;}\n    }\n    rep(j,y)\n    {\n      int keep=j;\n      rep(k,now)\n      {\n        if(S[k+1]=='S')keep=B[keep];\n        else if(S[k+1]=='R')if((++keep)==y)keep=0;\n        A[i+j*x]=temp+keep*x;\n      }\n    }\n  }\n  rep(i,pw3)printf(\"%d \",A[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,x,y,pos,tri0,tri1,tri2,pw3[13]={1},A[531441],salsa[531441],sw[200001];\nchar T[200001];\nvoid OUT(int x){if(x<0)putchar('-'),x=-x;if(x>=10)OUT(x/10);putchar(x%10+48);}\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nsigned main(void)\n{\n  x=scanf(\"%d %s\",&N,T+1);\n  replace(T+1,\"SS\",\"\");if(T[0]=='\\n')return 0;\n  rep(i,N)pw3[i+1]=3*pw3[i];\n  tri0=pw3[N],tri1=pw3[N/2],tri2=pw3[N-N/2];\n  rep(i,tri0)salsa[i]=salsa[i/3]*3+(3-i%3)%3;\n  rep(i,tri1)\n  {\n    x=i,pos=0;\n    rep(j,strlen(T+1))\n    {\n      if(T[j+1]=='S'){x=salsa[x];if(sw[pos]>0)pos--;else sw[++pos]=1;}\n      if(T[j+1]=='R'){x++;if(x==tri1)sw[++pos]=-1,x=0;}\n    }\n    rep(j,tri2)\n    {\n      y=j;\n      rep(k,pos){if(sw[k+1]>0)y=salsa[y];else if(sw[k+1]<0){if((++y)==tri2)y=0;}}\n      A[i+j*tri1]=y*tri1+x;\n    }\n  }\n  rep(i,tri0)OUT(A[i]),putchar('\\t');\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\n#include<complex>\n#include<numeric>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define PRIM 3\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\n#define PI 3.1415926535897932384626433832795028\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef long double Real;\ntypedef complex<Real> CP;\n\n\nInt final_pos[13][550000];\nInt end_person[13][550000];\nInt pos_significant[550000];\n\nInt n3[13];\n\nint main(){\n    int n, m;\n    string t;\n\n    n3[0] = 1;\n    for(int i = 1;i < 13;i++)n3[i] = n3[i-1] * 3;\n    \n    cin >> n;\n    cin >> t;\n    m = t.size();\n\n    for(int i = 1;i <= n;i++){\n        Int sls = 0;\n        for(int j = 0;j < n3[i-1];j++){\n            pos_significant[j] = 0;\n            pos_significant[j + n3[i-1]] = 1;\n            pos_significant[j + 2*n3[i-1]] = 2;\n            final_pos[i][j] = final_pos[i-1][j];\n            final_pos[i][j + n3[i-1]] = final_pos[i-1][j];\n            final_pos[i][j + n3[i-1] * 2] = final_pos[i-1][j];\n        }\n        for(int j = 0;j < t.size();j++){\n            char c = t[j];\n            end_person[i][j] = end_person[i-1][j];\n            int great = (sls % 2 == 0) ? 2 : 1;\n            if(pos_significant[end_person[i-1][j]] == great)end_person[i][j] += n3[i-1] * 0;\n            if(pos_significant[end_person[i-1][j] + n3[i-1]] == great)end_person[i][j] += n3[i-1] * 1;\n            if(pos_significant[end_person[i-1][j] + n3[i-1] * 2] == great)end_person[i][j] += n3[i-1] * 2;\n            if(c == 'S'){\n                sls++;\n            }\n            else{\n                int add = (sls % 2 == 0) ? 1 : 2;\n                (pos_significant[end_person[i-1][j]] += add)%=3;\n                (pos_significant[end_person[i-1][j] + n3[i-1]] += add)%=3;\n                (pos_significant[end_person[i-1][j] + n3[i-1] * 2] += add)%=3;\n            }\n        }\n        for(int j = 0;j < n3[i];j++){\n            if(sls % 2 == 0)\n                final_pos[i][j] += pos_significant[j] * n3[i-1];\n            else\n                final_pos[i][j] += (3-pos_significant[j])%3 * n3[i-1];\n        }\n    }\n\n    for(int i = 0;i < n3[n];i++){\n        cout << final_pos[n][i] << \" \";\n    }cout << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define range(i, m, n) for(int i = m; i < n; i++)\n#define husk(i, m, n) for(int i = m; i > n; i--)\n\nint n;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  vector<int> to(n + 1);\n  to[0] = 1;\n  range(i, 1, n + 1) to[i] = to[i - 1] * 3;\n\n  string a;\n  cin >> a;\n  int sz = a.length();\n\n  vector<int> p; // 3^n\n  vector<int> pos; // sz\n  p.resize(1);\n  pos.resize(sz);\n\n  for(int ex = 1; ex <= n; ex++) {\n    int total = 0;\n    vector<int> add(to[ex]);\n    range(i, 0, to[ex]) add[i] = i / to[ex - 1];\n\n    p.resize(to[ex]);\n    range(i, to[ex - 1], to[ex]) p[i] = p[i % to[ex - 1]];\n\n    vector<int> new_pos(sz);\n\n    for(int i = 0; i < sz; i++) {\n      {\n        int ps = pos[i];\n        assert(~ps);\n        for(int j = ps; j <= ps + 2 * to[ex - 1]; j += to[ex - 1]) {\n          int c = add[j];\n          if(total) {\n            if(c > 0) c = 3 - c;\n          }\n          if(c == 2) new_pos[i] = j;\n        }\n      }\n      char com = a[i];\n      if(com == 'S') {\n        total ^= 1;\n      } else {\n        int ps = pos[i];\n        assert(~ps);\n        int ter = -1;\n        for(int j = ps; j <= ps + 2 * to[ex - 1]; j += to[ex - 1]) {\n          int c = add[j];\n          if(total) {\n            if(c > 0) c = 3 - c;\n          }\n          c = (c + 1) % 3;\n          if(total) {\n            if(c > 0) c = 3 - c;\n          }\n          add[j] = c;\n        }\n      }\n    }\n\n    if(total) {\n      for(int i = 0; i < to[ex]; i++) {\n        if(add[i] > 0) add[i] = 3 - add[i];\n      }\n    }\n\n    for(int i = 0; i < to[ex]; i++) {\n      p[i] += add[i] * to[ex - 1];\n    }\n\n    swap(pos, new_pos);\n  }\n  for(int i : p) cout << i << \" \";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n   ios_base::sync_with_stdio(false); cin.tie(nullptr);\n   int N; string T;\n   cin >> N >> T;\n   vector<int> perm(round(pow(3, N)));\n   auto simplify = [&](string T) {\n      string newT;\n      for (char c : T) {\n         if (c == 'R') {\n            newT += c;\n         } else if (newT.size() && newT.back() == 'S') {\n            newT.pop_back();\n         } else {\n            newT += c;\n         }\n      }\n      return newT;\n   };\n   function<void(int, string, int, int, int)> solve = [&](int bit, string T, int pw, int from, int to) {\n      if (bit == N) {\n         perm[from] = to;\n         return;\n      }\n      for (int d : {0, 1, 2}) {\n         int nd = d;\n         string newT;\n         for (char c : T) {\n            if (c == 'S') {\n               newT += c;\n               if (nd) nd = 3 - nd;\n            } else {\n               if (nd == 2) {\n                  newT += c;\n               }\n               nd = (nd + 1) % 3;\n            }\n         }\n         solve(bit + 1, simplify(newT), pw * 3, from + d * pw, to + nd * pw);\n      }\n   };\n   solve(0, T, 1, 0, 0);\n   for (int v : perm) cout << v << \" \"; cout << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,o,p,x,y,sw,pw3[13]={1},A[531441],B[531441],S[200001];\nchar T[200001];\nvoid Init(void){rep(i,pw3[o])rep(j,3)B[i+j*pw3[o]]=j;}\nvoid Dance(char c[])\n{\n  if(c[p]==EOF)return;\n  if(c[p]=='R'){y=S[p];rep(i,3){x=y+i*pw3[o];if(B[x]+sw==2)S[p]=x;(B[x]+=sw+1)%=3;}}\n  if(c[p]=='S')sw^=1;\n}\nvoid Update(void)\n{\n  rep(i,pw3[o]){y=A[i];rep(j,3){x=i+j*pw3[o];A[x]=y+(sw?3-B[x]:B[x])%3*pw3[o];}}\n}\nsigned main(void)\n{\n  o=scanf(\"%d %s\",&N,T);\n  rep(i,N){o=i,Init(),sw=0;rep(j,strlen(T)){p=j,Dance(T);}Update();pw3[i+1]=3*pw3[i];}\n  rep(i,pw3[N])printf(\"%d%c\",A[i],i+1==pw3[N]?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <typeinfo>\n#include <cmath>\n#include <iomanip>\n#include <queue>\n#include <map>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nstatic const double pi = 3.141592653589793;\n\nstring sarusa(string s)\n{\n    rep(i, s.length())\n    {\n        if (s[i] == '1')\n        {\n            s[i] = '2';\n        }\n        else if (s[i] == '2')\n        {\n            s[i] = '1';\n        }\n    }\n    return s;\n}\n\nstring addOne(string s)\n{\n    s[s.length() - 1]++;\n    rep(i, s.length())\n    {\n        if (s[s.length() - 1 - i] == '3')\n        {\n            s[s.length() - 1 - i] = '0';\n            if (i < s.length() - 1)\n                s[s.length() - 2 - i]++;\n        }\n        else\n        {\n            break;\n        }\n    }\n    return s;\n}\n\nll toNumber(string s)\n{\n    ll res = 0, b = 1;\n    rep(i, s.length())\n    {\n        res += (s[s.length() - 1 - i] - '0') * b;\n        b *= 3;\n    }\n    return res;\n}\n\nint main()\n{\n    ll n, num = 1;\n    string t, tmp = \"\", def = \"\";\n\n    cin >> n >> t;\n    map<string, string> move;\n\n    rep(i, n)\n    {\n        num *= 3;\n        tmp += \"0\";\n    }\n    def = tmp;\n\n    rep(i, num)\n    {\n        move[tmp] = sarusa(tmp);\n        tmp = addOne(tmp);\n    }\n\n    rep(j, num)\n    {\n        tmp = def;\n        rep(i, t.length())\n        {\n            if (t[i] == 'S')\n            {\n                tmp = move[tmp];\n            }\n            else\n            {\n                tmp = addOne(tmp);\n            }\n        }\n        cout << toNumber(tmp) << \" \";\n        def = addOne(def);\n    }\n    cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Q=1<<20;\nint ls[Q],rs[Q],ch[Q][3],laz[Q],n,tl=0,p3[123];\nvoid Init(int &now,int dp,int bas)\n{\n\tnow=++tl;\n\tif(dp==n){\n\t\tch[now][0]=bas;\n\t\treturn;\n\t}\n\tfor(int i=0;i<3;i++)\n\t\tInit(ch[now][i],dp+1,bas+i*p3[dp]);\n}\nvoid Pd(int now)\n{\n\tlaz[now]=0;\n\tswap(ch[now][1],ch[now][2]);\n\tfor(int i=0;i<3;i++)\n\t\tlaz[ch[now][i]]^=1;\n}\nchar s[Q];\nint ans[Q];\nvoid Bd(int now,int dp,int bas)\n{\n\tif(dp==n){\n\t\tans[ch[now][0]]=bas;\n\t\treturn;\n\t}\n\tif(laz[now])Pd(now);\n\tfor(int i=0;i<3;i++)\n\t\tBd(ch[now][i],dp+1,bas+i*p3[dp]);\n}\nvoid Ad(int now,int dp)\n{\n\tif(dp==n)return;\n\tif(laz[now])Pd(now);\n\tswap(ch[now][1],ch[now][2]);\n\tswap(ch[now][1],ch[now][0]);\n\tAd(ch[now][0],dp+1);\n}\nint main()\n{\n\tp3[0]=1;\n\tfor(int i=1;i<=12;i++)\n\t\tp3[i]=p3[i-1]*3;\n\tscanf(\"%d%s\",&n,s);\n\tint qaq=strlen(s),rt=0;\n\tInit(rt,0,0);\n\tfor(int i=0;i<qaq;i++)\n\t\tif(s[i]=='S')laz[rt]^=1;\n\t\telse Ad(rt,0);\n\tBd(rt,0,0);\n\tfor(int i=0;i<p3[n];i++)\n\t\tprintf(\"%d \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nstatic inline char CH()\n{\n  static char buf[100000],*ptr1=buf,*ptr2=buf;\n  return ptr1==ptr2&&(ptr2=(ptr1=buf)+fread(buf,1,100000,stdin),ptr1==ptr2)?EOF:*ptr1++;\n}\nstatic inline int IN(void)\n{\n  int x=0,f=0,c=CH();while(c<48||c>57){f^=c==45,c=CH();}\n  while(c>47&&c<58){x=x*10+c-48,c=CH();}return f?-x:x;\n}\nstatic inline int Pow(int a,int b){return b?Pow(a*a,b>>1)*(b&1?a:1):1;}\nint main()\n{\n  int N=IN(),now,len=0,pw3=Pow(3,N),x=Pow(3,N>>1),y=Pow(3,N-(N>>1)),A[1000001],B[600001];\n  char c=CH(),T[1000001],S[1000001];\n  rep(i,pw3)B[i]=B[i/3]*3+(3-i%3)%3;\n  while(c!=EOF){if(c==10){c=CH();}T[1+len++]=c,c=CH();}\n  rep(i,x)\n  {\n    int temp=i;now=0;\n    rep(j,len)\n    {\n      if(T[j+1]=='S'){temp=B[temp];(S[now]=='S')?--now:S[++now]='S';}\n      else{++temp;if(temp==x)S[++now]='R',temp=0;}\n    }\n    rep(j,y)\n    {\n      int keep=j;\n      rep(k,now)\n      {\n        if(S[k+1]=='S')keep=B[keep];\n        else if(S[k+1]=='R')if((++keep)==y)keep=0;\n        A[i+j*x]=temp+keep*x;\n      }\n    }\n  }\n  rep(i,pw3)printf(\"%d%c\",A[i],' ');\n  return puts(\"\"),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n// #include <ext/pb_ds/assoc_container.hpp> \n// #include <ext/pb_ds/detail/standard_policies.hpp>\n// using namespace __gnu_pbds;\n\n#pragma GCC optimize(\"O3\")\n#ifdef LOCAL\n#include \"/Users/lbjlc/Desktop/coding/debug_utils.h\"\n#else\n#define print(...) ;\n#define printn(...) ;\n#define fprint(...) ;\n#define fprintn(...) ;\n#endif\n\n#define rep(i, a, b) for(auto i = (a); i < (b); i++)\n#define rrep(i, a, b) for(auto i = (a); i > (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define pb push_back\n// #define mp make_pair\n#define fi first\n#define se second\n#define maxi(x, y) x = max(x, y)\n#define mini(x, y) x = min(x, y)\n// long long fact(long long n) { if(!n) return 1; return n*fact(n-1); }\n// #define endl '\\n'\n#define solve_testcase int T;cin>>T;for(int t=1;t<=T;t++){solve(t);}\n\n// long long gcd(long long x, long long y) { return y ? gcd(y, x % y) : x; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\n \ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n \ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\ntypedef vector<long long> vll;\n#define bd(type,op,val) bind(op<type>(), std::placeholders::_1, val)\n\nconst int MAXN = 1e6+10;\n\n\nvoid solve(int tt) {\n    // cout<<\"Case #\"<<tt<<\": \";\n}\n\nstring to_ter(int x, int k=-1) {\n    string res;\n    while(x) {\n        res+='0'+x%3;\n        x/=3;\n    }\n    if(k>=0) {\n        while(res.size()<k) res+='0';\n    }\n    return res;\n}\nint to_int(const string & s) {\n    int res=0;\n    // rrep(i,s.size()-1,-1)\n    //     res=res*3+(s[i]-'0');\n    for(int i=s.size()-1;i>=0;i--)\n        res=res*3+(s[i]-'0');\n    // print(s,res);\n    return res;\n}\nbool add(string & x, const string & y) {\n    int n1=x.size(), n2=y.size(),carry=0;\n    rep(i,0,n1) {\n        if(i<n1) carry+=x[i]-'0';\n        if(i<n2) carry+=y[i]-'0';\n        x[i]=carry%3+'0';\n        carry/=3;\n    }\n    return carry==0;\n}\n\nvi cal_inst(string & s) {\n    int n=s.size();\n    vi res(1);\n    int i=0;\n    while(i<n) {\n        if(s[i]=='R') {\n            res.back()++;\n            i++;\n        }\n        else {\n            int j=i;\n            for(;j<n&&s[j]=='S';j++);\n            if((j-i)%2) res.pb(0);\n            i=j;\n        }\n    }\n    if(s.back()=='S') res.pop_back();\n    return res;\n}\n\nchar rev(char c) {\n    if(c>'0') return '0'+(3-(c-'0'));\n    return c;\n}\nstring rev(string s) {\n    for(auto & c:s) c=rev(c);\n    return s;\n}\n\nint len(string & s) {\n    int res=s.size()-1;\n    while(res>=0&&s[res]=='0') res--;\n    return res+1;\n}\n\nint power[13]={};\nint revmap[MAXN]={};\nint tmpres[MAXN];\nint rev(int x) {\n    for(int flag=1;flag<power[12];flag*=3) {\n        int tmp=x/flag%3;\n        if(tmp==1) x+=flag;\n        else if(tmp==2) x-=flag;\n    }\n    return x;\n}\n\nvoid cal(vi inst, int n, int tot) {\n    // vi tmpres(tot,-1);\n    fill(tmpres,tmpres+tot,-1);\n\n    rep(i,0,tot) {\n        if(tmpres[i]>=0) continue;\n\n        int cur=i,ok=1;\n        for(auto x:inst) {\n            cur+=x;\n            if(cur>=power[n]) {\n                ok=0; \n                cur%=power[n];\n            }\n            cur=revmap[cur];\n        }\n        // if(i<=9) print(i,cur);\n        tmpres[i]=cur;\n        // assert(cur>=0);\n        if(!ok) continue;\n        int flag=1,tmp;\n        for(;flag<=i||flag<=cur;flag*=3);\n\n        if(inst.size()%2==0) {\n            for(tmp=flag;tmp<power[n];tmp+=flag) {\n                tmpres[tmp+i]=tmp+cur;\n            }\n        }\n        else {\n            for(tmp=flag;tmp<power[n];tmp+=flag) {\n                tmpres[tmp+i]=revmap[tmp]+cur;\n            }\n\n        }\n    }\n    // print(1);\n    // print(*max_element(all(res)),*min_element(all(res)));\n    // return res;\n}\n\nint main(int argc, char * argv[]) {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    // solve_testcase;\n\n    int n;\n    string s;\n    // cin>>n;\n    // cin>>s;\n\n    n=12;\n    rep(i,0,1e5) s+=\"RS\";\n\n    power[0]=1;\n    rep(i,1,13) power[i]=power[i-1]*3;\n\n    rep(i,0,MAXN-1) revmap[i]=rev(i);\n    printn(revmap,9);\n\n    int tot=1;\n    rep(i,0,n) tot*=3;\n\n    vi inst=cal_inst(s);\n    for(auto & x:inst) x%=tot;\n\n    // print(inst);\n\n    int i=0;\n    int bound=81;\n    vi res(tot);\n    iota(all(res),0);\n    while(i<inst.size()) {\n        int cur=inst[i];\n        vi cur_inst({cur});\n        for(++i;i<inst.size()&&cur+inst[i]<bound;i++) {\n            cur+=inst[i];\n            cur_inst.pb(inst[i]);\n        }\n        cal(cur_inst,n,tot);\n        // print(tmp);\n        rep(j,0,tot) res[j]=tmpres[res[j]];\n        // print(cur_inst,tmp);\n        // print(res);\n        // sort(all(tmp)); print(tmp);\n    }\n    if(s.back()=='R') {\n        rep(i,0,tot) {\n            res[i]=to_int(rev(to_ter(res[i],n)));\n        }\n    }\n    for(auto x:res) cout<<x<<' ';\n    cout<<endl;\n\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\n#ifdef DEBUG\n#define display(x) cerr << #x << \" = \" << x << endl;\n#define displaya(a, st, n)\\\n\t{cerr << #a << \" = {\";\\\n\tfor(int qwq = (st); qwq <= (n); ++qwq) {\\\n\t\tif(qwq == (st)) cerr << a[qwq];\\\n\t\telse cerr << \", \" << a[qwq];\\\n\t} cerr << \"}\" << endl;}\n#define displayv(v) displaya(v, 0, (int)(v).size() - 1)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define display(x) ;\n#define displaya(a, st, n) ;\n#define displayv(v) ;\n#define eprintf(...) if(0) fprintf(stderr, \"...\")\n#endif\ntemplate<typename T> bool chmin(T &a, const T &b) { return a > b ? a = b, true : false; }\ntemplate<typename T> bool chmax(T &a, const T &b) { return a < b ? a = b, true : false; }\ntemplate<typename A, typename B>\nostream& operator << (ostream& out, const pair<A, B> &p) {\n\treturn out << '(' << p.first << \", \" << p.second << ')';\n}\n\nconst int maxN = (1 << 20);\nint n;\nstring op;\nint ch[maxN][3], id[maxN];\nint cn = 1, rt;\n\nbool flip = false;\nint get(int x) {\n\tif(x == 0) return x;\n\tif(flip) return 3 - x; else return x;\n}\n\nvoid build(int &o, int dep, int val, int dval) {\n\to = ++cn;\n\tif(dep == 0) {\n\t\tid[o] = dval;\n\t} else {\n\t\tid[o] = 0;\n\t\tfor(int i = 0; i < 3; ++i) build(ch[o][get(i)], dep - 1, val * 3, i * val + dval);\n\t}\n}\n\nvector<int> q;\nvoid dfs(int o, int dep, int val, int dval) {\n\tif(dep == 0) {\n\t\tq[id[o]] = dval;\n\t} else {\n\t\tfor(int i = 0; i < 3; ++i) dfs(ch[o][get(i)], dep - 1, val * 3, i * val + dval);\n\t}\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n#endif\n\tcin >> n >> op;\n\tint cnt = 1;\n\tfor(int i = 0; i < n; ++i) cnt *= 3;\n\trt = 1;\n\tbuild(rt, n, 1, 0);\n\tfor(char c : op) {\n\t\tif(c == 'S') flip ^= 1;\n\t\telse {\n\t\t\tassert(c == 'R');\n\t\t\tint o = rt, dep = n;\n\t\t\twhile(dep) {\n\t\t\t\tint &x = ch[o][get(0)], &y = ch[o][get(1)], &z = ch[o][get(2)];\n\t\t\t\tint t;\n\t\t\t\tt = x; x = z; z = y; y = t;\n\t\t\t\to = x;\n\t\t\t\t--dep;\n\t\t\t}\n\t\t}\n\t}\n\tq.assign(cnt, 0);\n\tdfs(rt, n, 1, 0);\n\tfor(int i = 0; i < (int)q.size(); ++i) cout << q[i] << \" \\n\"[i + 1 == (int)q.size()];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nstring T;\nll p3[13];\nll P[540000];\nll D[540000];\nint F[540000];\nll W[14][540000];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>T;\n\tp3[0]=1;\n\tFOR(i,N) p3[i+1]=p3[i]*3;\n\t\n\tfor(i=1;i<=N;i++) {\n\t\tFOR(x,p3[i]) D[x]=x/p3[i-1];\n\t\tW[i][0]=p3[i]-1;\n\t\tZERO(F);\n\t\tint nf=0;\n\t\tFOR(x,T.size()) {\n\t\t\tif(T[x]=='S') {\n\t\t\t\tnf++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ty=W[i-1][x];\n\t\t\t\tif((nf-F[y])%2) {\n\t\t\t\t\tFOR(j,3) {\n\t\t\t\t\t\tif(D[y+j*p3[i-1]]==1) D[y+j*p3[i-1]]=2;\n\t\t\t\t\t\telse if(D[y+j*p3[i-1]]==2) D[y+j*p3[i-1]]=1;\n\t\t\t\t\t}\n\t\t\t\t\tF[y]=nf;\n\t\t\t\t}\n\t\t\t\tFOR(j,3) {\n\t\t\t\t\tD[y+j*p3[i-1]]=(D[y+j*p3[i-1]]+1)%3;\n\t\t\t\t}\n\t\t\t}\n\t\t\ty=W[i-1][x+1];\n\t\t\tif((nf-F[y])%2) {\n\t\t\t\tFOR(j,3) {\n\t\t\t\t\tif(D[y+j*p3[i-1]]==1) D[y+j*p3[i-1]]=2;\n\t\t\t\t\telse if(D[y+j*p3[i-1]]==2) D[y+j*p3[i-1]]=1;\n\t\t\t\t}\n\t\t\t\tF[y]=nf;\n\t\t\t}\n\t\t\tFOR(j,3) if(D[y+j*p3[i-1]]==2) W[i][x+1]=y+j*p3[i-1];\n\t\t}\n\t\t\n\t\t\n\t\tFOR(y,p3[i-1]) {\n\t\t\tif((nf-F[y])%2) {\n\t\t\t\tFOR(j,3) {\n\t\t\t\t\tif(D[y+j*p3[i-1]]==1) D[y+j*p3[i-1]]=2;\n\t\t\t\t\telse if(D[y+j*p3[i-1]]==2) D[y+j*p3[i-1]]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFOR(x,p3[N]) P[x]+=D[x%p3[i]]*p3[i-1];\n\t}\n\t\n\tFOR(i,p3[N]) {\n\t\tcout<<P[i]<<\" \";\n\t}\n\tcout<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,x,y,z,sw,pw3=1,A[531441]={0},B[531441]={0},S[531441]={0};\nchar T[200001];\nvoid OUT(int x){if(x<0)putchar('-'),x=-x;if(x>=10)OUT(x/10);putchar(x%10+48);}\nsigned main(void)\n{\n  x=scanf(\"%d %s\",&N,T);\n  rep(i,N)\n  {\n    rep(j,pw3)rep(k,3)B[j+k*pw3]=k;\n    sw=1;\n    rep(p,strlen(T))\n    {\n      if(T[p]=='R')\n      {\n        y=S[p];\n        rep(j,3)\n        {\n          x=y+j*pw3,z=B[x]*sw;\n          if(z==-1)S[p]=x;else if(z==2)S[p]=x;\n          B[x]++;if(sw<0)B[x]++;\n          B[x]%=3;\n        }\n      }\n      else sw=-sw;\n    }\n    rep(j,pw3)\n    {\n      y=A[j];\n      rep(k,3)\n      {\n        x=j+k*pw3;\n        if(sw>0)z=B[x]%3;else z=(3-B[x])%3;\n        A[x]=y+z*pw3;\n      }\n    }\n    pw3*=3;\n  }\n  rep(i,pw3)OUT(A[i]),putchar(' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\n#define MAXI 531441\n\nlong long int S[MAXI],C[MAXI],Cinv[MAXI],C2[MAXI];\n\n\nint main() {\n    long long int i,j,k,l,m,N,Q,X,P;\n    string T;\n\n cin >> N >> T;\n\n // P = 3^N\n\n P = 1;\n for (i=1;i<=N;i++)\n    P *= 3;\n\n\n S[0] = 0;\n S[1] = 2;\n S[2] = 1;\n j = 1;\n for (i=1;i<N;i++) {\n    j *= 3;\n    k = (j << 1);\n    for (l=0;l<j;l++) {\n      S[j+l] = k+S[l];\n      S[k+l] = j+S[l];\n    }\n}\n/*\ncerr << \"S = \";\nfor (i=0;i<P;i++) {\n  cerr << S[i] << \" \";\n}\ncerr << endl;\n*/\n\nfor (i=0;i<P;i++) {\n  C[i] = i;\n}\nfor (i=0;i<P;i++) {\n  Cinv[C[i]] = i;\n}\n\nlong long int decalage;\n\nfor (i=0;i<T.length();i++) {\n/*  cerr << \"C\" << i << \" = \";\n  for (k=0;k<P;k++)\n    cerr << C[k] <<  \" \";\n  cerr << \"Cinv\" << i << \" = \";\n    for (k=0;k<P;k++)\n      cerr << Cinv[k] <<  \" \";\n  cerr << endl; */\n  if (T[i] == 'S') {\n  //   cerr << i+1 << \" On lit S\";\n     decalage = 1;\n     for (j=i+1;j<T.length();j++)\n       if (T[j]== 'S')\n         decalage++;\n       else\n         j = T.length();\n//    cerr << decalage << endl;\n    if (decalage % 2) {\n\n    for (j=0;j<P;j++) {\n      if (S[j] > j) {\n        // k = Cinv[j];\n        C[Cinv[j]] = S[j];\n        C[Cinv[S[j]]] = j;\n      }\n    }\n    for (j=0;j<P;j++) {\n      Cinv[C[j]] = j;\n    }\n    }\n    i += decalage-1;\n  }\n  else {\n  //  cerr << i+1 << \" On lit R\" << endl;\n  decalage = 1;\n  for (j=i+1;j<T.length();j++)\n    if (T[j]== 'R')\n      decalage++;\n    else\n      j = T.length();\n      i += decalage-1;\n\n    for (j=0;j<P;j++)\n      C2[Cinv[j]] = (j+decalage) % P;\n// C[ Cinv[j]] = j devient (j + decalage ) % P\n    for (j=0;j<P;j++)\n      C[j] = C2[j];\n    for (j=0;j<P;j++)\n      Cinv[C[j]] = j;\n  }\n}\n\nfor (i=0;i<P;i++)\n  cout << C[i] <<  \" \";\n\ncout << \"\\n\";\n\n\n\n// cout << sqrt(dx*dx+dy+dy) << endl;\n// printf(\"%f\\n\",sqrt(dx*dx+dy+dy));\n\n\n\n  return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,i,s[105],j,k,l;\nint d[1000005],td[1000005];\nchar c[1000005];\nstring p[1000005],tmp[1000005];\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts[0]=1;\n\tfor(i=1;i<=n;++i)\n\t\ts[i]=s[i-1]*3;\n\tcin>>p[0];\n\tfor(i=0;i<n;++i)\n\t{\n\t\tfor(k=0;k<s[i];++k)\n\t\t\ttmp[k].clear();\n\t\tfor(j=0;j<3;++j)\n\t\t{\n\t\t\tfor(k=0;k<s[i];++k)\n\t\t\t{\n\t\t\t\tint u=j,w=0;\n\t\t\t\tfor(l=0;l<p[k].size();++l)\n\t\t\t\t\tif(p[k][l]=='S')\n\t\t\t\t\t{\n\t\t\t\t\t\tif(u==1)\n\t\t\t\t\t\t\tu=2;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tif(u==2)\n\t\t\t\t\t\t\t\tu=1;\n\t\t\t\t\t\tw^=1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t++u;\n\t\t\t\t\t\tif(u>=3)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(w)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttmp[j*s[i]+k]+='S';\n\t\t\t\t\t\t\t\tw=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tu=0;\n\t\t\t\t\t\t\ttmp[j*s[i]+k]+='R';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tif(w)\n\t\t\t\t\ttmp[j*s[i]+k]+='S';\n\t\t\t\td[j*s[i]+k]=td[k]+u*s[i];\n\t\t\t}\n\t\t}\n\t\tfor(k=0;k<s[i+1];++k)\n\t\t{\n\t\t\ttd[k]=d[k];\n\t\t\tp[k]=tmp[k];\n\t\t}\n\t}\n\tfor(i=0;i<s[n];++i)\n\t\tprintf(\"%d \",d[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nvoid chmin(ll &a, ll b) {\n\ta = min(a, b);\n}\nvoid chmax(ll &a, ll b) {\n\ta = max(a, b);\n}\nll mod_pow(ll a, ll n, ll m = mod) {\n\ta %= m;\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%m;\n\t\ta = a * a%m; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nint dx[6] = { 1,0,-1,1,-1,0 };\nint dy[6] = { 1,1,1,0,0,-1 };\n\nstring memo[12][59049*9];\nint val[12][59049 * 9];\n\nint rev[59049 * 9];\nvoid init() {\n\trep(i, 59049 * 9) {\n\t\tvector<int> v;\n\t\tint cop = i;\n\t\twhile (cop > 0) {\n\t\t\tv.push_back(cop % 3); cop /= 3;\n\t\t}\n\t\trep(j, v.size())if (v[j] != 0)v[j] = 3 - v[j];\n\t\trev[i] = 0;\n\t\tint s = 1;\n\t\trep(j, v.size()) {\n\t\t\trev[i] += s * v[j]; s *= 3;\n\t\t}\n\t}\n\t\n}\n\nstring normalize(string &t) {\n\tstring cop;\n\trep(i, t.size()) {\n\t\tif (cop.size() && cop.back() == 'S'&&t[i] == 'S') {\n\t\t\tcop.pop_back();\n\t\t}\n\t\telse{\n\t\t\tcop.push_back(t[i]);\n\t\t}\n\t}\n\treturn cop;\n}\n\nvoid solve(){\n\tint n; cin >> n;\n\tstring t; cin >> t;\n\tt = normalize(t);\n\trep(j, 3)memo[0][j] = t;\n\n\n\trep(i, n-1) {\n\t\tint sup = 1;\n\t\trep(j, i + 1)sup *= 3;\n\t\trep(j, sup) {\n\t\t\tstring nex;\n\t\t\tint cur = j / (sup / 3);\n\t\t\tfor (char c : memo[i][j]) {\n\t\t\t\tif (c == 'S') {\n\t\t\t\t\tnex.push_back('S');\n\t\t\t\t\tif (cur != 0)cur = 3 - cur;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcur++;\n\t\t\t\t\tif (cur == 3) {\n\t\t\t\t\t\tcur = 0;\n\t\t\t\t\t\tnex.push_back('R');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnex = normalize(nex);\n\t\t\trep(k, 3) {\n\t\t\t\tmemo[i + 1][j + k * sup] = nex;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n) {\n\t\tint sup = 1;\n\t\trep(j, i + 1)sup *= 3;\n\t\trep(j, sup) {\n\t\t\tint cur = j / (sup / 3);\n\t\t\tfor (char c : memo[i][j]) {\n\t\t\t\tif (c == 'S') {\n\t\t\t\t\tif (cur != 0)cur = 3 - cur;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcur++; if (cur == 3)cur = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tval[i][j] = cur;\n\t\t}\n\t}\n\t//rep(j, 3)cout << memo[0][j] << \"\\n\";\n\t//rep(j, 3)cout << val[0][j] << \"\\n\";\n\tvector<int> ans;\n\tint tn = 1; rep(i, n)tn *= 3;\n\trep(i, tn) {\n\t\tint s = 1;\n\t\tint x = 0;\n\t\trep(j, n) {\n\t\t\tx += s * val[j][i % (s * 3)];\n\t\t\ts *= 3;\n\t\t}\n\t\tans.push_back(x);\n\t}\n\trep(i, ans.size()) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << ans[i];\n\t}\n\tcout << \"\\n\";\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init_f();\n\tinit();\n\t//int t; cin >> t;rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long l;\nstring s1=\"\";\nstring convert10tob(l N)\n{\n\n     if (N == 0)\n        return \"\";\n\n     l x = N % 3;\n\n     N /= 3;\n\n     if (x < 0)\n        N += 1; \n\n     convert10tob(N);\n\n     l a = x < 0 ? x + (3 * -1) : x;\n     if(a==0)\n     {\n         s1=s1+'0';\n     }\n     else if(a==1)\n     {\n         s1=s1+'1';\n     }\n     else if(a==2)\n     {\n         s1=s1+'2';\n     }\n     \n\n     return s1;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n    l N;\n    cin>>N;\n    string s;\n    cin>>s;\n    l total=3;\n    for(l i=2;i<=N;i++)\n    {\n        total = total*3;\n    }\n    l arr[total]={0};\n \n    for(l i=1;i<total;i++)\n    {\n        if(arr[i]==0)\n        {\n            s1=\"\";\n            l second=0;\n            string con=convert10tob(i);\n            l csi=con.length()-1;\n            if(con[csi]=='1')\n            {\n                second+=2;\n            }\n            else if(con[csi]=='2')\n            {\n                second+=1;\n            }\n            l cnt=1;\n            csi--;\n            while(csi>=0)\n            {\n                cnt=cnt*3;\n                if(con[csi]=='0')\n                {\n                    csi--;\n                    continue;\n                }\n                if(con[csi]=='1')\n                {\n                   second+=(cnt*2);\n                }\n                else if(con[csi]=='2')\n                {\n                    second+=(cnt*1);\n                }\n                csi--;\n            }\n            arr[second]=i;\n            arr[i]=second;\n        }\n    }\n  \n    l arr1[total];\n    for(l i=0;i<total;i++)\n    {\n        arr1[i]=i;\n    }\n    l si=s.length();\n    l t=total-1;\n    for(l i=0;i<si;i++)\n    {\n        if(i==0 || i==(si-1))\n        {\n            if(s[i]=='S')\n            {\n                for(l j=0;j<total;j++)\n                {\n                    arr1[j]=arr[arr1[j]];\n                }\n            }\n            else{\n                for(l j=0;j<total;j++)\n                {\n                    if(arr1[j]!=t)\n                    {\n                        arr1[j]+=1;\n                    }\n                    else{\n                        arr1[j]=0;\n                    }\n                }\n            }\n        }\n        else\n        {\n            if(s[i]=='R')\n            {\n                for(l j=0;j<total;j++)\n                {\n                    if(arr1[j]!=t)\n                    {\n                        arr1[j]+=1;\n                    }\n                    else{\n                        arr1[j]=0;\n                    }\n                }\n            }\n            else if(s[i-1]=='S' && s[i+1]=='S')\n            {\n                i=i+1;\n            }\n            else{\n                for(l j=0;j<total;j++)\n                {\n                    arr1[j]=arr[arr1[j]];\n                }\n            }\n        }\n    }\n    for(l i=0;i<total;i++)\n    {\n        cout<<arr1[i]<<\" \";\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\n#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\")\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nclass CStrangeDance {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n; cin >> n;\n      string t; cin >> t;\n\n      // initialize vector size\n      vector<vector<vector<int>>> v(3, vector<vector<int>>(n));\n      int k = 1;\n      rep(i, n) {\n        rep(j, 3) {\n          v[j][i].resize(k);\n        }\n        k *= 3;\n      }\n      int K = k;\n\n      // initialize vector\n      rep(i, n) {\n        int idx = 0;\n        rep(j, 3) {\n          for(auto& e: v[j][i]) {\n            e = idx;\n            idx++;\n          }\n        }\n      }\n\n      for(auto c: t) {\n        if (c=='S') {\n          // swap vector\n          swap(v[1], v[2]);\n        } else {\n          // swap by point\n          int w = 0;\n          rep(i, n) {\n            auto v0 = v[0][i][w];\n            auto v1 = v[1][i][w];\n            auto v2 = v[2][i][w];\n            v[1][i][w] = v0;\n            v[2][i][w] = v1;\n            v[0][i][w] = v2;\n            w = v2;\n          }\n        }\n      }\n\n      // recover\n      vector<int> ans(K);\n      k = 1;\n      rep(i, n) {\n        for(int j=1; j<=2; j++) {\n          for(auto e: v[j][i]) {\n            for(int idx=e; idx<K; idx+=(k*3)) {\n              ans[idx] += j*k;\n            }\n          }\n        }\n        k *= 3;\n      }\n\n      for(auto e: ans) {\n        cout << e << ' ';\n      }\n    }\n};\n\nsigned main() {\n  CStrangeDance solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F(i, a, b) for (int i = a; i <= b; i ++)\n#define G(i, a, b) for (int i = a; i >= b; i --)\n#define max(a, b) ((a) > (b) ? (a) : (b))\n#define min(a, b) ((a) < (b) ? (a) : (b))\n#define mx(a, b) ((a) = max(a, b))\n#define mn(a, b) ((a) = min(a, b))\n#define out4(x, y, z, w) { printf(#x\" = \"), W(x), printf(\" \"#y\" = \"), W(y), printf(\" \"#z\" = \"), W(z), printf(\" \"#w\" = \"), W(w), putc('\\n'); }\n#define out3(x, y, z) { printf(#x\" = \"), W(x), printf(\" \"#y\" = \"), W(y), printf(\" \"#z\" = \"), W(z), putc('\\n'); }\n#define out2(x, y) { printf(#x\" = \"), W(x), printf(\" \"#y\" = \"), W(y), putc('\\n'); }\n#define out1(x) { printf(#x\" = \"); W(x), putc('\\n'); }\n#define outarr(a, L, R) { printf(#a\"[%d..%d] = \", L, R); F(i, L, R) W(a[i]), putc(' '); putc('\\n'); }\n#define outline(x) { puts(\"-------------------------------\"#x\"---------------------------------\"); }\n#define mem(a, b) memset(a, b, sizeof a)\n#define mec(a, b) memcpy(a, b, sizeof a)\n#define low(x) ((x) & (- (x)))\n#define abs(x) max((x), (- (x)))\n#define get getchar()\n#define putc putchar\n\ntemplate <typename Int>\nvoid R(Int &x) {\n\tchar c = get; x = 0; Int t = 1;\n\tfor (; !isdigit(c); c = get) t = (c == '-' ? - 1 : t);\n\tfor (; isdigit(c); x = (x << 3) + (x << 1) + c - '0', c = get); x *= t;\n}\ntemplate <typename Int>\nvoid W(Int x) {\n\tif (x < 0) { putc('-'); x = - x ; }\n\tif (x > 9) W(x / 10); putc(x % 10 + '0');\n}\n\nusing namespace std;\n\nconst int M = 531442;\nconst int T = 2e5 + 10;\nconst int N = 30;\nint n, a[M], d[N], sum[M], c[M];\nchar s[T];\n\nint main() {\n\tR(n); int S = 1;\n\tF(i, 1, n) S = S * 3;\n\tF(i, 0, S - 1) {\n\t\ta[i] = i; int L = 0;\n\t\tfor (int x = i; x; d[++ L] = x % 3, x /= 3);\n\t\tG(j, L, 1) sum[i] = sum[i] * 3 + (d[j] ? 3 - d[j] : 0);\n\t}\n\tscanf(\"%s\", s + 1);\n\tint len = strlen(s + 1);\n\tF(i, 1, len)\n\t\tif (s[i] == 'S') {\n\t\t\tF(j, 0, S - 1)\n\t\t\t\ta[j] = sum[a[j]];\n\t\t}\n\t\telse {\n\t\t\tF(i, 0, S - 1) a[i] = (a[i] + 1) % S;\n\t\t}\n\tF(i, 0, S - 1)\n\t\tW(a[i]), putc(' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef __DEBUG__\n    #define DBG(X) cout << #X << \" = \" << (X) << endl;\n    #define SAY(X) cout << (X) << endl;\n#else\n    #define DBG(X)\n    #define SAY(X)\n#endif\n\nusing namespace std;\n\nusing ll = long long int;\nusing ull = unsigned long long int;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\nint dx[]={1, 0, -1, 0, 1,-1, 1,-1};\nint dy[]={0, 1, 0, -1, 1, 1,-1,-1};\nconst int INT_INF = (int)(2e9);\nconst ll  LL_INF = (ll)(2e18);\n\ninline void fast_io() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); };\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const pair<T, S> p) { cout << \"[\" << p.first << \";\" << p.second << \"]\"; return os; }\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const map<T, S> p) { for (auto el : p) cout << \"[\" << el.first << \";\" << el.second << \"]\"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const vector<T>& v) { for (auto el : v) cout << el << \" \"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const deque<T>& v) { for (auto el : v) cout << el << \" \"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const set<T>& v) { for (auto el : v) cout << el << \" \"; return os; }\ntemplate<typename T> inline vector<T> fetch_vec(int sz) { vector<T> ret(sz); for (auto& elem : ret) cin >> elem; return ret; }\n\nint N;\nstring T;\nvoid input(){\n    fast_io();\n    cin >> N >> T;\n}\n\nvoid chint(int &x){\n    if(x==1) x=2;\n    else if(x==2) x=1;\n}\n\nint salsa_step(int x){\n    int res = 0;\n    for (int i = 0; i < N; i++)\n    {\n        int y = (x%(int)pow(3,i+1))/(int)pow(3,i);\n        chint(y);\n        res += y*(int)pow(3,i);\n    }\n    return res;    \n}\n\ndeque<int> salsa(deque<int> p){\n    deque<int> ret(pow(3,N),0);\n    for (int i = 0; i < pow(3,N); i++)\n    {\n        ret[i] = p[salsa_step(i)];\n    }\n    return ret;    \n}\n\nvoid rumba(deque<int> &p){\n    int x = p.back();\n    p.pop_back();\n    p.push_front(x);\n}\n\nvoid rev_rumba(deque<int> &p){\n    int x = p.front();\n    p.pop_front();\n    p.push_back(x);\n}\n\nvoid shrink(string &t){\n    for (int i = 0; i < (int)t.length()-1; i++)\n    {\n        if(t[i]=='S' && t[i+1]=='S') {\n            t = t.substr(0,i)+t.substr(i+2);\n            i--;\n        }\n    }\n}\n\nint solve(){\n    deque<int> P;\n    for (int i = 0; i < pow(3,N); i++) P.push_back(i);\n    shrink(T);\n    DBG(T)\n    DBG(P)\n    reverse(T.begin(),T.end());\n    for (int i = 0; i < (int)T.length(); i++)\n    {\n        if(T[i]=='S') P = salsa(P);\n        else rev_rumba(P);\n        DBG(P)\n    }\n    cout << P << endl;\n    // 逆から求めたらこれは必要ない。\n    // unordered_map<int,int> idx;\n    // for (int i = 0; i < pow(3,N); i++) idx[P[i]] = i;\n    // for (int i = 0; i < pow(3,N); i++) cout << idx[i] << \" \";\n    // cout << endl;\n    return 0;\n}   \n\nint main()\n{\n    input();\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e6+7, K = 12, RT = 6;\nint f[N], p3[N];\n\nvoid pre() {\n    p3[0] = 1;\n    for (int i=1; i<=K; i++)    p3[i] = p3[i-1]*3;\n\n    for (int i=0; i<N; i++) {\n        for (int k=0; k<K; k++) {\n            int d = (i/p3[k])%3;\n            if (d == 1)      f[i] += p3[k]*2;\n            else if (d == 2) f[i] += p3[k];\n        }\n    }\n\n}\n\nint aa[N], bb[N];\nvoid brute(int k, string s) {\n    int n = p3[k];\n    for (int i=0; i<n; i++) aa[i] = i;\n\n    for (char c: s) {\n        if (c == 'R') {\n            int last = aa[n-1];\n            for (int i=n-1; i>0; i--)     aa[i] = aa[i-1];\n            aa[0] = last;\n        }\n        else {\n            for (int i=0; i<n; i++)\n                if (f[i] > i)\n                    swap(aa[i], aa[f[i]]);\n        }\n    }\n\n    for (int i=0; i<n; i++) bb[aa[i]] = i;\n    for (int i=0; i<n; i++) cout<<bb[i]<<\" \";\n    cout<<endl;\n}\n\nvector<int> v[N];\nint asol[N];\nint temp[N];\n\nint main() {\n    pre();\n\n    int n;\n    string s;\n    cin>>n>>s;\n\n\n    int mx = p3[max(0, n-K)];\n    int my = p3[min(K, n)];\n    int all = p3[n];\n\n\n    for (int i=0; i<mx; i++)\n        for (int j=0; j<my; j++)\n            v[i].push_back(my*i + j);\n\n    for (int j=0; j<my; j++)    asol[j] = j;\n\n    for (char c: s) {\n        if (c == 'R')  {\n            for (int i=0; i<mx; i++)    temp[i] = v[i][asol[my-1]];\n\n            int st = asol[my-1];\n            for (int i=my-1; i>0; i--)    asol[i] = asol[i-1];\n            asol[0] = st;\n\n            for (int i=1; i<mx; i++)    v[i][asol[0]] = temp[i-1];\n            v[0][asol[0]] = temp[mx-1];\n        }\n        else {\n            for (int i=0; i<my; i++)\n                if (f[i] > i)\n                    swap(asol[i], asol[f[i]]);\n\n            for (int i=0; i<mx; i++)\n                if (f[i] > i)\n                    v[i].swap(v[f[i]]);\n        }\n\n//        for (int i=0; i<my; i++)    cout<<asol[i]<<\" \"; cout<<\":::\"<<endl;\n//        for (int i=0; i<my; i++)    cout<<v[0][i]<<\" \"; cout<<\"---\"<<endl;\n    }\n\n    for (int i=0; i<mx; i++)\n        for (int j=0; j<my; j++)\n            aa[i*my+j] = v[i][asol[j]];\n\n\n    for (int i=0; i<all; i++) bb[aa[i]] = i;\n    for (int i=0; i<all; i++) cout<<bb[i]<<\" \";\n    cout<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//     自己选择的路，跪着也要走完。朋友们，虽然这个世界日益浮躁起来，只\n// 要能够为了当时纯粹的梦想和感动坚持努力下去，不管其它人怎么样，我们也\n// 能够保持自己的本色走下去。                               ——陈立杰\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef signed char          int8;\ntypedef unsigned char       uint8;\ntypedef short                int16;\ntypedef unsigned short      uint16;\ntypedef int                  int32;\ntypedef unsigned            uint32;\ntypedef long long            int64;\ntypedef unsigned long long  uint64;\n\ntemplate <typename Int>\ninline Int read()       \n{\n    Int flag = 1;\n    char c = getchar();\n    while ((!isdigit(c)) && c != '-') c = getchar();\n    if (c == '-') flag = -1, c = getchar();\n    Int init = c & 15;\n    while (isdigit(c = getchar())) init = (init << 3) + (init << 1) + (c & 15);\n\treturn init * flag;\n}\n\ntemplate <typename Int>\ninline Int read(char &c)       \n{\n    Int flag = 1;\n    c = getchar();\n    while ((!isdigit(c)) && c != '-') c = getchar();\n    if (c == '-') flag = -1, c = getchar();\n    Int init = c & 15;\n    while (isdigit(c = getchar())) init = (init << 3) + (init << 1) + (c & 15);\n\treturn init * flag;\n}\n\ntemplate <typename Int>\ninline void write(Int x)\n{\n    if (x < 0) putchar('-'), x = ~x + 1;\n    if (x > 9) write(x / 10);\n    putchar((x % 10) | 48);\n}  \n\ntemplate <typename Int>\ninline void write(Int x, char nextch)\n{\n    write(x);\n    putchar(nextch);\n}\n\nint n, _3n;\nchar t[200007], len;\n\nstruct M {\n    int p[540000];\n    M operator* (const M &T) {\n        M ret;\n        for (int i = 0; i < _3n; i++) \n            ret.p[i] = T.p[p[i]];\n        return ret;\n    }\n} base, S, R;\n\nint TmpTurnArr[3] = {0, 2, 1};\nint turn(int p) {\n    // printf(\"turn(%d) = \", p);\n    int digit[13], cnt = 0, res = 0;\n    while (p) {\n        digit[cnt++] = p % 3;\n        p /= 3;\n    }\n    while (~(--cnt)) {\n        res = res * 3 + TmpTurnArr[digit[cnt]];\n    }\n    // printf(\"%d\\n\", res);\n    return res;\n}\n\ninline M fpow(M x, int n) {\n    M ret = base;\n    while (n) {\n        if (n & 1) ret = ret * x;\n        x = x * x;\n        n >>= 1;\n    }\n    return ret;\n}\n\nM genR(int k) {\n    M ret;\n    for (int i = 0; i < _3n; i++) {\n        ret.p[i] = (i + k) % _3n;\n    }\n    return ret;\n}\n\nint chk(int p) {\n    int cS = 0;\n    if (t[p] != 'S') return false;\n    while (t[p] == 'S') {\n        cS++;\n        p++;\n    }\n    if (!(cS & 1)) return false;\n    if (t[p] == 'R') return p + 1;\n}\n\nint main() {\n    n = read<int>();\n    _3n = pow(3, n) + 0.5;\n    scanf(\"%s\", t);\n    len = strlen(t);\n    for (int i = 0; i < _3n; i++) {\n        S.p[i] = turn(i);\n        R.p[i] = i + 1;\n        base.p[i] = i;\n    }\n    R.p[_3n - 1] = 0;\n    M ans = base;\n    int cS = 0, cR = 0, cSR = 0;\n    for (int i = 0, nRet; i < len; i++) {\n        if (chk(i)) {\n            if (cR) ans = ans * genR(cR);\n            if (cS) ans = ans * S;\n            // printf(\"Until %d:\\n\", i - 1);\n            // for (int j = 0; j < _3n; j++) {\n            //     write(ans.p[j], j == _3n - 1 ? 10 : 32);\n            // }\n            while (nRet = chk(i)) {\n                // printf(\"SR jump from %d to %d\\n\", i, nRet);\n                cSR++;\n                i = nRet;\n            }\n            ans = ans * fpow(S * R, cSR);\n            cR = cS = cSR = 0;\n        }\n        if (t[i] == 'S') {\n            if (cR) {\n                ans = ans * genR(cR);\n                cS = 1;\n                cR = 0;\n            } else cS ^= 1;\n        } else if (t[i] == 'R') {\n            if (cS) {\n                ans = ans * S;\n                cS = 0;\n            } \n            cR++;\n        }\n        // printf(\"Until %d:\\n\", i);\n        // for (int j = 0; j < _3n; j++) {\n        //     write(ans.p[j], j == _3n - 1 ? 10 : 32);\n        // }\n    }\n    \n    if (cR) ans = ans * genR(cR);\n    if (cS) ans = ans * S;\n    // M H = base * S * S * R * R * R * S;\n    for (int i = 0; i < _3n; i++) {\n        write(ans.p[i], i == _3n - 1 ? 10 : 32);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2,unroll-loops\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing vi = vector<int>;\nusing ll = long long;\nint maxn = 531441, B, C;\nint n, p[531441], f[531441];\nint rev(int a) {\n\tint r = 0, c = 1;\n\twhile(c < maxn) {\n\t\tif(a%3) r +=(3 - (a%3))*c;\n\t\tc*=3,a/=3;\n\t}\n\treturn r;\n}\n\nint s = 0;\nlist<int> big[729], small[729];\nlist<int>::iterator pos[531441];\nint id[531441], lup[531441], u = 0;\n\nvoid add() {\n\ts = (s + B - 1)%B;\n\tfor(auto i : small[s]) {\n\t\tif(lup[i] != u) {\n\t\t\tif((lup[i]^u)&1) id[i] = f[id[i]];\n\t\t\tlup[i] = u;\n\t\t}\n\t\tbig[id[i]].erase(pos[i]);\n\t\tid[i] = (id[i] + 1)%C;\n\t\tbig[id[i]].push_back(i);\n\t\t--(pos[i] = big[id[i]].end());\n\t}\n}\n\nvoid flip() {\n\tu++;\n\tfor(int i = 0; i < B; i++) {\n\t\tif(f[i] <= i) {\n\t\t\tswap(small[(s+i)%B], small[(s+f[i])%B]);\n\t\t}\n\t}\n\tfor(int i = 0; i < C; i++) {\n\t\tif(f[i] <= i) {\n\t\t\tswap(big[i], big[f[i]]);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tstring t;\n\tcin >> n >> t;\n\tmaxn = B = 1;\n\tfor(int i = 0; i < n; i++) maxn *= 3;\n\tfor(int i = 0; i < n/2; i++) B *= 3;\n\tC = maxn/B;\n\tfor(int i = 0; i < maxn; i++) {\n\t\tf[i] = rev(i);\n\t\t\n\t\tsmall[i%B].push_back(i);\n\t\t\n\t\tbig[i/B].push_back(i);\n\t\t--(pos[i] = big[i/B].end());\n\t\t\n\t\tid[i] = i/B;\n\t}\n\t\n\tfor(auto i : t) {\n\t\tif(i == 'R') add();\n\t\telse flip();\n\t}\n\tfor(int i = 0; i < B; i++)\n\t\tfor(auto j : small[i]) p[j] += (B+i-s)%B;\n\tfor(int i = 0; i < C; i++)\n\t\tfor(auto j : big[i]) p[j] += B*i;\n\tfor(int i = 0; i < maxn; i++) cout << p[i] << \" \";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 6e5 + 5;\n\nchar s[N];\nint p[N], from[N], last[N];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  scanf(\"%s\", s);\n  int len = strlen(s);\n  int pw = 1;\n  fill(last, last+len, 0);\n  for (int i = 0; i < n; ++i) {\n    set<int> st[3];\n    for (int j = 0; j < pw; ++j) {\n      st[0].insert(j);\n      st[1].insert(pw + j);\n      st[2].insert(pw * 2 + j);\n    }\n    for (int j = 0; j < len; ++j) {\n      // cerr << i << \" \" << j << endl;\n      if (s[j] == 'S') {\n        st[1].swap(st[2]);\n      } else {\n        int add = 0;\n        for (int k = 0; k < 3; ++k) {\n          int now = k * pw + last[j];\n          for (int z = 0; z < 3; ++z) {\n            auto it = st[z].find(now);\n            if (it == st[z].end()) continue;\n            if (z == 2)\n              add = k;\n            st[z].erase(it);\n            int y = z + 1;\n            if (y == 3) y = 0;\n            st[y].insert(now);\n            break;\n          }\n        }\n        last[j] += add * pw;\n      }\n      // for (int k = 0; k < 3; ++k) {\n      //   cerr << \" isi \" << k << \" : \";\n      //   for (int x : st[k])\n      //     cerr << x << \" \";\n      //   cerr << endl;\n      // }\n    }\n    for (int j = 0; j < pw; ++j) {\n      int now = p[j];\n      // cerr << j << \" p[j] \" << now << endl;\n      for (int k = 0; k < 3; ++k) {\n        int cur = j + k * pw;\n        for (int z = 0; z < 3; ++z) {\n          if (st[z].count(cur)) {\n            p[cur] = now + z * pw;\n            // cerr << \" assign \" << cur << \" \" << k << \" \" << z << \" \" << p[cur] << endl;\n            break;\n          }\n        }\n      }\n    }\n    pw *= 3;\n    // for (int j = 0; j < pw; ++j)\n    //   cerr << p[j] << \" | \";\n    // cerr << endl;\n  }\n  for (int i = 0; i < pw; ++i) {\n    printf(\"%d%c\", p[i], i+1 == pw ? '\\n' : ' ');\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,avx,avx2\")\n#include <immintrin.h>\n#endif\n\n#define hur(f, g) template<class c> int f(c a) {if (sizeof(c) == 8) return g##ll(a); else return g(a);}\nhur(popc, __builtin_popcount) hur(ctz, __builtin_ctz) hur(clz, __builtin_clz)\n\n/*\n\t- place bitset modifications here\n*/\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define le(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)2e6];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\n// void fast_print(__int128 x) {\n// \tif (x == 0) { fast_print('0'); return; }\n// \tif (x < 0) {\n// \t\tfast_print('-');\n// \t\tx = -x;\n// \t}\n// \t__int128 p = 1;\n// \twhile (x / (p * 10)) p *= 10;\n// \twhile (p) {\n// \t\t__int128 symb = x / p;\n// \t\tfast_print((int)symb);\n// \t\tx -= p * symb;\n// \t\tp /= 10;\n// \t}\n// };\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tinline T floor_mod(T a, const T &b) {\n\t\ta %= b;\t\n\t\tif (a < 0) a += b;\n\t\treturn a;\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint n;\nstring s;\n\nstruct Node {\n\tint mod = 0;\n\tint go[3];\n\tint id;\n};\n\nvector<Node> S(1);\n\nint create_node() {\n\tS.pb({0, 0, 0, 0});\n\treturn le(S) - 1;\n}\nint rev(int i) {\n\tvector<int> digs;\n\tf(t, n) {\n\t\tdigs.pb(i % 3);\n\t\ti /= 3;\n\t}\n\tint rez = 0;\n\tfor (int x : digs) {\n\t\trez = rez * 3 + x;\n\t}\n\treturn rez;\n}\nint iter = 0;\nint init(int depth) {\n\tint i = create_node();\n\tif (depth == 0) {\n\t\tS[i].id = iter; \n\t\titer++;\n\t} else {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tint t = init(depth - 1);\n\t\t\tS[i].go[j] = t;\n\t\t}\n\t}\n\treturn i;\n}\n\nvoid push(int i, int depth) {\n\tassert(depth);\n\tif (S[i].mod) {\n\t\tswap(S[i].go[1], S[i].go[2]);\n\t\tf(t, 3) {\n\t\t\tS[S[i].go[t]].mod ^= 1;\n\t\t}\n\t\tS[i].mod = 0;\n\t}\n}\n\nvoid inc(int i, int depth) {\n\tif (depth) {\n\t\tpush(i, depth);\n\t\t// rotate(S[i].go, S[i].go + 1, S[i].go + 3);\n\t\t// reverse(S[i].go, S[i].go + 3);\n\t\ttie(S[i].go[0], S[i].go[1], S[i].go[2])\n\t\t\t= mt(S[i].go[2], S[i].go[0], S[i].go[1]);\n\t\tinc(S[i].go[0], depth - 1);\n\t}\n}\n\nvoid extract(int i, int depth, vector<int> &rez) {\n\tif (!depth) {\n\t\trez.pb(S[i].id);\n\t} else {\n\t\tpush(i, depth);\n\t\tf(t, 3) {\n\t\t\textract(S[i].go[t], depth - 1, rez);\n\t\t}\n\t}\n}\n\nvector<int> inv(vector<int> p) {\n\tvector<int> q(le(p));\n\tfor (int i = 0; i < le(p); i++) {\n\t\tq[p[i]] = i;\n\t}\n\treturn q;\n}\nint comp_l(int i) {\n\tvector<int> digs;\n\tf(t, n) {\n\t\tdigs.pb(i % 3);\n\t\ti /= 3;\n\t}\n\treverse(digs.begin(), digs.end());\n\tint rez = 0;\n\tfor (int x : digs) {\n\t\tif (x == 1 || x == 2)\n\t\t\tx = 3 - x;\n\t\trez = rez * 3 + x;\n\t}\n\treturn rez;\n}\nsigned main(signed argc, char *argv[]) {\n\tscan n;\n\tscan s;\n\tint root = init(n);\n\tint N = 1;\n\tf(i, n) N *= 3;\n\tvector<int> stp(N);\n\tiota(stp.begin(), stp.end(), 0);\n\tfor (char c : s) {\n\t\tif (c == 'S') {\n\t\t\tS[root].mod ^= 1;\t\n\t\t} else {\n\t\t\tinc(root, n);\n\t\t}\n\t}\n\t{\n\t\tvector<int> rez;\n\t\textract(root, n, rez);\n\t\tvector<int> sub = rez;\n\t\tf(i, le(sub)) {\n\t\t\tsub[rev(i)] = rev(rez[i]);\n\t\t}\n\t\tprint inv(sub);\n\t}\n\t// vector<int> where = rez;\n\t// f(i, le(where)) {\n\t// \twhere[rez[i]] =i;\n\t// }\n\t// print rez;\n\t// print where;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n//#define int ll\n//#define int ll\n//#define char ll\n#define double ld\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate<class T0, class T1>\ninline ostream &operator<<(ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate<class T0, class T1>\ninline istream &operator>>(istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate<class T0, class T1, class T2>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate<class T0, class T1, class T2, class T3>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" << get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream &operator<<(ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\nTOTAL EXECUTION TIME: \" << float(clock() - start) / CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int N = 1e6 + 10;\n\nstruct node {\n    vector<node*> ch;\n    int val;\n    int push_swap;\n    node() {\n        val = -1;\n        push_swap = 0;\n    }\n};\n\nvoid build(node * root, vector<pii> a) {\n    if (a.size() == 1) {\n        root->val = a[0].second;\n        return;\n    }\n    root->ch.resize(3);\n    fori (z, 3) {\n        vector<pii> cur;\n        for (auto x : a) {\n            if (x.first % 3 == z) {\n                x.first /= 3;\n                cur.push_back(x);\n            }\n        }\n        root->ch[z] = new node();\n        build(root->ch[z], cur);\n    }\n}\n\nvoid push(node * root) {\n    if (root->ch.empty())\n        return;\n    if (root->push_swap) {\n        fori (z, 3) {\n            if (!root->ch[z]->ch.empty()) {\n                root->ch[z]->push_swap ^= 1;\n                swap(root->ch[z]->ch[1], root->ch[z]->ch[2]);\n            }\n        }\n        root->push_swap = 0;\n    }\n}\n\nvoid upd_swap(node * root) {\n    if (root->ch.empty())\n        return;\n    root->push_swap ^= 1;\n    swap(root->ch[1], root->ch[2]);\n}\n\nvoid upd_inc(node * root) {\n    if (root->ch.empty())\n        return;\n\n    push(root);\n\n    node * tmp = root->ch[2];\n\n    fori (i, 3) {\n        swap(tmp, root->ch[i]);\n    }\n\n    upd_inc(root->ch[0]);\n\n}\n\nint ans[N];\n\nvoid dfs(node * root, int cur, int lvl) {\n    push(root);\n    if (root->ch.empty()) {\n        ans[root->val] = cur;\n        return;\n    }\n    fori (z, 3) {\n        dfs(root->ch[z], cur + lvl * z, lvl * 3);\n    }\n}\n\nvoid smain() {\n\n\n\n    int n;\n    cin >> n;\n    int pwk = 1;\n    fori (_, n) {\n        pwk *= 3;\n    }\n    n = pwk;\n\n\n    vi a(n);\n    fori (i, n) {\n        a[i] = i;\n    }\n    node * root = new node();\n    vector<pii> kek(n);\n    fori (i, n) {\n        kek[i] = {a[i], a[i]};\n    }\n\n    build(root, kek);\n\n    string s;\n    cin >> s;\n    for (auto c : s) {\n        if (c == 'S') {\n            upd_swap(root);\n        } else {\n            upd_inc(root);\n        }\n    }\n\n\n    dfs(root, 0, 1);\n\n    for (int i = 0; i < n; ++i) {\n        cout << ans[i] << ' ';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cassert>\n#include<stdexcept>\n#include<utility>\n#include<functional>\n#include<numeric>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<array>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<complex>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<bitset>\n#include<memory>\nusing namespace std;\nusing ll=long long;\n\nconst int SZ = 20;\nint n;\nint pow3n;\nvector<int> sal;\nvoid init_s(){\n    sal.resize(pow3n);\n    iota(sal.begin(),sal.end(),0);\n    for(int i=0;i<pow3n;i++){\n        int x = i;\n        int tar = 0;\n        int r = 1;\n        for(int j=0;j<n;j++){\n            tar+= (x%3*2)%3*r;\n            x/=3;\n            r*=3;\n        }\n        if(tar<i){\n            // cerr<<i<<\" \"<<tar<<endl;\n            swap(sal[tar],sal[i]);\n        }\n    }\n}\n\n\nvoid do_r(vector<int>& pat){\n    int head = pat[pow3n-1];\n    for(int i=pow3n-1;i>0;i--){\n        pat[i]=pat[i-1];\n    }\n    pat[0] = head;\n}\nint ary[1000000];\nvoid perm(vector<int>& pat,vector<int>& par){\n    for(int i=0;i<pow3n;i++) ary[i] = pat[par[i]];\n    for(int i=0;i<pow3n;i++) pat[i] = ary[i];\n}\nvoid do_s(vector<int>& pat){\n    perm(pat,sal);\n}\nint main(){\n    cin>>n;\n    pow3n=1;\n    for(int i=0;i<n;i++) pow3n*=3;\n    init_s();\n    \n    string t;\n    {\n        string tmp;\n        cin>>tmp;\n        for(auto c:tmp){\n            if(!t.empty() && t.back()=='S' && c=='S') t.pop_back();\n            else t+=c;\n        }\n    }\n\n    vector<vector<int>> memo(1<<SZ);\n    \n    for(int bit=0;bit<(1<<SZ);bit++){\n        bool ispass= false;\n        for(int j=0;j+1<SZ;j++){\n            if(((bit>>j)&1)==0 && ((bit>>(j+1)))==0) ispass=true;\n        }\n        if(ispass) continue;\n\n        memo[bit].resize(pow3n);\n        iota(memo[bit].begin(),memo[bit].end(),0);\n        for(int j=0;j<SZ;j++){\n            if(((bit>>j)&1)==0) do_s(memo[bit]);\n            else do_r(memo[bit]);\n        }\n    }\n    vector<int> res(pow3n);\n    iota(res.begin(),res.end(),0);\n    \n    for(int i=0;i<t.size()/SZ;i++){\n        int bit = 0;\n        for(int j=0;j<SZ;j++){\n            if(t[i*SZ+j]=='R') bit+=(1<<j);\n        }\n        // cerr<<\"#\"<<i<<endl;\n        // for(int i=0;i<pow3n;i++) cerr<<res[i]<<\" \";\n        // cerr<<endl;\n        // for(int i=0;i<pow3n;i++) cerr<<memo[bit][i]<<\" \";\n        // cerr<<endl;\n        perm(res,memo[bit]);\n        // for(int i=0;i<pow3n;i++) cerr<<res[i]<<\" \";\n        // cerr<<endl;\n    }\n\n    for(int i=t.size()/SZ*SZ;i<t.size();i++){\n        // cerr<<\"#\"<<endl;\n        if(t[i]=='S') do_s(res);\n        else do_r(res);\n    }\n    vector<int> inv(pow3n);\n    for(int i=0;i<pow3n;i++) inv[res[i]]=i;\n    for(int i=0;i<pow3n;i++) cout<<inv[i]<<\" \";\n    cout<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,o,p,x,y,pos,pw3[13]={1},A[1000000],salsa[555555],sw[1000000];\nchar T[200001];\nvoid OUT(int x){if(x<0)putchar('-'),x=-x;if(x>=10)OUT(x/10);putchar(x%10+48);}\nvoid Dance(char c[])\n{\n  if(c[p]==EOF)return;\n  if(c[p]=='S'){x=salsa[x];if(sw[pos]>0)pos--;else sw[++pos]=1;}\n  if(c[p]=='R'){x++;if(x==pw3[N/2])sw[++pos]=-1,x=0;}\n}\nvoid Update(void)\n{\n  rep(i,pw3[N-N/2])\n  {\n    y=i;\n    rep(j,pos){if(sw[j+1]>0)y=salsa[y];else if(sw[j+1]<0){if((++y)==pw3[N-N/2])y=0;}}\n    A[o+i*pw3[N/2]]=y*pw3[N/2]+x;\n  }\n}\nsigned main(void)\n{\n  o=scanf(\"%d %s\",&N,T+1);\n  rep(i,N)pw3[i+1]=3*pw3[i];\n  rep(i,pw3[N])salsa[i]=salsa[i/3]*3+(3-i%3)%3;\n  rep(i,pw3[N/2]){o=i,x=i,pos=0;rep(j,strlen(T+1)){p=j+1,Dance(T);}Update();}\n  rep(i,pw3[N])OUT(A[i]),putchar(' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\nconst int M=15,N=600005;\nint n,m,Q;\nchar s[N];\nint Pw[M];\nstruct Trie\n{\n\tstruct Node\n\t{\n\t\tint ch[3];\n\t\tint val;\n\t\tint tag;\n\t\tNode()\n\t\t{\n\t\t\tch[0]=ch[1]=ch[2]=0;\n\t\t\tval=-1;\n\t\t\ttag=0;\n\t\t\treturn;\n\t\t}\n\t}trie[N];\n\tint tot=1;\n\tvoid insert(int x)\n\t{\n\t\tvector<int>v;\n\t\tint t=x;\n\t\twhile(t)\n\t\t\tv.push_back(t%3),t/=3;\n\t\twhile(v.size()<m)\n\t\t\tv.push_back(0);\n\t\tint u=1;\n\t\tfor(int c:v)\n\t\t{\n\t\t\tif(!trie[u].ch[c]) trie[u].ch[c]=++tot;\n\t\t\tu=trie[u].ch[c];\n\t\t}\n\t\ttrie[u].val=x;\n\t\treturn;\n\t}\n\tvoid push_down(int u)\n\t{\n\t\tif(!trie[u].tag) return;\n\t\tswap(trie[u].ch[1],trie[u].ch[2]);\n\t\tfor(int i=0;i<3;i++)\n\t\t\ttrie[trie[u].ch[i]].tag^=1;\n\t\ttrie[u].tag=0;\n\t\treturn;\n\t}\n\tvoid reverse(int u)\n\t{\n\t\ttrie[u].tag^=1;\n\t\treturn;\n\t}\n\tvoid add(int u)\n\t{\n\t\tif(!u) return;\n\t\tpush_down(u);\n\t\tint t=trie[u].ch[2];\n\t\ttrie[u].ch[2]=trie[u].ch[1];\n\t\ttrie[u].ch[1]=trie[u].ch[0];\n\t\ttrie[u].ch[0]=t;\n\t\tadd(trie[u].ch[0]);\n\t\treturn;\n\t}\n\tvoid query(int u,int sum,int dep,vector<int>&res)\n\t{\n\t\tif(!u) return;\n\t\tpush_down(u);\n\t\tif(trie[u].val!=-1) res[trie[u].val]=sum;\n\t\tfor(int i=0;i<3;i++)\n\t\t\tquery(trie[u].ch[i],sum+i*Pw[dep],dep+1,res);\n\t\treturn;\n\t}\n}T;\nint main()\n{\n\tscanf(\"%d\",&m);\n\tPw[0]=1;\n\tfor(int i=1;i<=m;i++)\n\t\tPw[i]=Pw[i-1]*3;\n\tn=Pw[m];\n\tscanf(\"%s\",s+1);\n\tQ=strlen(s+1);\n\tfor(int i=0;i<n;i++)\n\t\tT.insert(i);\n\tfor(int i=1;i<=Q;i++)\n\t\tif(s[i]=='S') T.reverse(1);\n\t\telse if(s[i]=='R') T.add(1);\n\tvector<int>res;\n\tres.resize(n);\n\tT.query(1,0,0,res);\n\tfor(int u:res)\n\t\tprintf(\"%d \",u);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef int ll;\ntypedef pair<ll,ll> pl;\nconst ll asize=6e5;\nint m[asize],tpow[15]={1},a[asize],a2[asize],dn[asize],aa[asize];\n\nint main() {\n\tios_base::sync_with_stdio(0),cin.tie(NULL);\n\tll n;\n\tcin>>n;\n\tfor(int i=1;i<=12;i++){\n\t\ttpow[i]=tpow[i-1]*3;\n\t}\n\tll lim=tpow[n];\n\tfor(int i=0;i<lim;i++)a[i]=i;\n\tstring s=\"000000000000\";\n\tfor(int i=0;i<lim;i++){\n\t\tll match=0;\n\t\tfor(int j=0;j<12;j++){\n\t\t\tint k=11-j;\n\t\t\tif(s[j]=='1')match+=2*tpow[k];\n\t\t\telse if(s[j]=='2')match+=tpow[k];\n\t\t}\n\t\ts.back()++;\n\t\tif(m[i]!=0)dn[i]=1;\n\t\tm[i]=match,m[match]=i;\n\t\tfor(int j=0;j<12;j++){\n\t\t\tint k=11-j;\n\t\t\tif(s[k]=='3')s[k]='0',s[k-1]++;\n\t\t}\n\t}\n//\tfor(int i=0;i<lim;i++){\n//\t\tcout<<i<<\" \"<<a[i]<<\" \"<<m[i]<<\" \"<<dn[i]<<\"\\n\";\n//\t}\n\tcin>>s;\n\tvector<pair<char,int> >v;\n\tfor(auto x:s){\n\t\tif(v.empty()||v.back().first!=x)v.emplace_back(x,1);\n\t\telse v.back().second++;\n\t}\n\tfor(auto x:v){\n\t\tll k=x.second;\n\t\tif(x.first=='S'&&k%2==1){\n\t\t\tfor(int i=0;i<lim;i++){\n\t\t\t\tif(!dn[i])swap(a[i],a[m[i]]);\n\t\t\t}\n\t\t}\n\t\telse if(x.first=='R'){\n\t\t\tfor(int i=0;i<lim;i++){\n\t\t\t//\tprintf(\"i:%d k:%d i+k_mn:%d\\n\",i,k,(i+k)%lim);\n\t\t\t\ta2[(i+k)%lim]=a[i];\n\t\t\t}\n\t\t\tfor(int i=0;i<lim;i++)a[i]=a2[i];\n\t\t}\n\t}\n\tfor(int i=0;i<lim;i++)aa[a[i]]=i;\n\tfor(int i=0;i<lim;i++)cout<<aa[i]<<\" \";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<bitset>\n#include<math.h>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int N=2000000+100;\nconst db pi=acos(-1.0);\n#define lowbit(x) ((x)&(-x))\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u],v=sq[i].to;i;i=sq[i].nxt,v=sq[i].to)\n#define fir first\n#define sec second\n#define mkp make_pair\n#define pb push_back\n#define maxd 998244353\n#define eps 1e-8\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\ninline ll readll()\n{\n    ll x=0;int f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nint tot,n,pw[20],ch[N][3],tag[N],pos[N],ans[N],rt,m;\nchar s[N];\n\nvoid build(int &id,int dep,int now)\n{\n    id=(++tot);\n    if (dep==n)\n    {\n        pos[id]=now;return;\n    }\n    build(ch[id][0],dep+1,now);\n    build(ch[id][1],dep+1,now+pw[dep]);\n    build(ch[id][2],dep+1,now+pw[dep]*2);\n}\n\nvoid addtag(int id) \n{\n    tag[id]^=1;\n    swap(ch[id][1],ch[id][2]);\n}\n\nvoid pushdown(int id)\n{\n    if (tag[id])\n    {\n        addtag(ch[id][0]);addtag(ch[id][1]);addtag(ch[id][2]);\n        tag[id]=0;\n    }\n}\n\nvoid add(int id,int dep)\n{\n    if (dep==n) return;\n    pushdown(id);\n    int x=ch[id][0],y=ch[id][1],z=ch[id][2];\n    ch[id][0]=z;ch[id][1]=x;ch[id][2]=y;\n    add(ch[id][0],dep+1);\n}\n\nvoid findans(int id,int dep,int now)\n{\n    if (dep==n)\n    {\n        ans[pos[id]]=now;return;\n    }\n    pushdown(id);\n    findans(ch[id][0],dep+1,now);\n    findans(ch[id][1],dep+1,now+pw[dep]);\n    findans(ch[id][2],dep+1,now+pw[dep]*2);\n}\n\nint main()\n{\n    n=read();\n    pw[0]=1;\n    rep(i,1,n) pw[i]=pw[i-1]*3;\n    build(rt,0,0);\n    scanf(\"%s\",s+1);m=strlen(s+1);\n    rep(i,1,m)\n    {\n        if (s[i]=='S') addtag(rt);\n        else add(rt,0);\n    }\n    findans(rt,0,0);\n    rep(i,0,pw[n]-1) printf(\"%d \",ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <functional>\n#include <iomanip>\n#include <limits>\n//#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll; //10^18\ntypedef unsigned long ul;\n\nusing Graph = vector<vector<ll>>;\n\ntypedef map<ll, ll> m;\ntypedef multimap<ll, ll> mm;\ntypedef set<ll> s;\ntypedef multiset<ll> ms;\ntypedef priority_queue<ll> pq;\ntypedef queue<ll> q;\ntypedef deque<ll> dq;\ntypedef list<ll> lst;\ntypedef pair<ll, ll> p;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define INFLL (9223372036854775807LL)\n#define PI (acos(-1))\n#define MOD 1000000007LL\n#define WALL '#'\n\n//#define and &&a\n//#define or ||\n//#define not !\n//#define neq !=\n//#define eq ==\n\n#define REP(i, n) for (ll i = 0; i < n; i++)\t  // from 0 to n\n#define REPR(i, n) for (ll i = n; i >= 0; i--)\t  // from n to 0\n#define FOR(i, m, n) for (ll i = m; i < n; i++)\t  // from m to n\n#define FORR(i, m, n) for (ll i = m; i >= n; i--) // from m to n\n#define DBG(a) cout << #a << \" : \" << a << \"\\n\";\n#define MSG(a) cout << a << \"\\n\";\n#define ALL(v) v.begin(), v.end()\n#define SZ(x) ((int)(x).size())\n#define PNT(a) printf(\"%lld\", (a))\n\n#define pb push_back //配列などの最後に要素を追加\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define FST first\n#define SND second\n\ntemplate <class T>\nbool chmax(T& a, const T& b)\n{\n\tif (a < b)\n\t{\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T>\nbool chmin(T& a, const T& b)\n{\n\tif (b < a)\n\t{\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n// グローバル変数宣言\n// 迷路用\nvector<ll> dy4 = { 0, 0, -1, 1, 0 }, dx4 = { -1, 1, 0, 0, 0 };\nvector<ll> dx8 = { -1,0,1,-1,1,-1,0,1 }, dy8 = { -1,-1,-1,0,0,1,1,1 };\n\n//\nvector<ll> factorial = {};\nvector<ll> factorialInverse = {};\n\n//swap(a, b);\n//sort(arr, arr + n);\t//昇順\n//sort(arr, arr+n, greater<int>());\t//降順\n//max(a, b);\n//min(a, b);\n\n//upper_bound(a, a+n, k)\t//配列aの中で、kより大きい値が初めて現れる位置へのポインタ\n//upper_bound(ALL(v), k)\t//STLvの中で、kより大きい値が初めて現れる位置へのポインタ\n//lower_bound(a, a+n, k)\n//lower_bound(ALL(v), k)\t//STLvの中で、kの以上値が初めて現れる位置へのポインタ\n//lower_bound(ALL(v),k) - upper_bound(ALL(v),k)\t//二分探索を用いて、ある列aに含まれる数kの個数を求める\n\n// n個のデータをvectorで取得\nvector<ll> INV(ll n)\n{\n\tvector<ll> v(n);\n\tREP(i, n)\n\t\tcin >> v[i];\n\treturn v;\n}\n\n// n個のデータをvectorで取得\nvector<vector<ll>> INV2(ll n, ll m)\n{\n\tvector<vector<ll>> v(n, vector<ll>(m));\n\tREP(i, n)\n\t{\n\t\tREP(j, m)\n\t\t{\n\t\t\tcin >> v[i][j];\n\t\t}\n\t}\n\treturn v;\n}\n\n// index が条件を満たすかどうか\nbool isOK(vector<ll>& v, int index, int key, bool flag)\n{\n\tif (flag) {\n\n\t\tif (v[index] >= key)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\telse {\n\t\tif (v[index] > key)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n}\n\n// 汎用的な二分探索\n// flag == 1 >=, flag == 0 >\nll bs(vector<ll>& v, ll key, bool flag)\n{\n\tint ng = -1;\t//「index = 0」が条件を満たすこともあるので、初期値は -1\n\tint ok = SZ(v); // 「index = a.size()-1」が条件を満たさないこともあるので、初期値は a.size()\n\n\t/* ok と ng のどちらが大きいかわからないことを考慮 */\n\twhile (abs(ok - ng) > 1)\n\t{\n\t\tint mid = (ok + ng) / 2;\n\n\t\tif (isOK(v, mid, key, flag))\n\t\t\tok = mid;\n\t\telse\n\t\t\tng = mid;\n\t}\n\treturn ok;\n}\n\n// 最大公約数\nll gcd(ll a, ll b)\n{\n\tif (a < b)\n\t\tswap(a, b);\n\tll r = a % b;\n\twhile (r != 0)\n\t{\n\t\ta = b;\n\t\tb = r;\n\t\tr = a % b;\n\t}\n\treturn b;\n}\n\n// 最小公倍数\nvoid lcm(ll a, ll b)\n{\n}\n\n// 素数判定\nbool is_prime(ll n)\n{\n\tbool flg = true;\n\tif (n <= 1)\n\t\tflg = false;\n\telse if (n == 2)\n\t\tflg = true;\n\telse if (n % 2 == 0)\n\t\tflg = false;\n\telse\n\t{\n\t\tfor (ll i = 3; i * i <= n; i += 2)\n\t\t{\n\t\t\tif (n % i == 0)\n\t\t\t\tflg = false;\n\t\t}\n\t}\n\treturn flg;\n}\n\n// 素因数分解\n// iで割った回数をcnt_pf[i - 1]に格納している\n// cnt_pf[0]に入力が素数だった場合にその素数が入る\nvector<ll> prime_factorization(ll n)\n{\n\tvector<ll> cnt_pf(sqrt(n), 0);\n\tFOR(i, 1, SZ(cnt_pf))\n\t{\n\t\twhile (n % (i + 1) == 0)\n\t\t{\n\t\t\tcnt_pf[i]++;\n\t\t\tn /= (i + 1);\n\t\t}\n\t\tif (n == 1)\n\t\t\tbreak;\n\t}\n\tif (n != 1)\n\t{\n\t\tcnt_pf[0] = n;\n\t}\n\treturn cnt_pf;\n}\n\n// 迷路のマップ情報をベクトル化する\n// 通れるところを0に、壁を-1にする\n// スタート地点からの距離を格納するときなどに使う\nvector<vector<ll>> map_vec(vector<string>& str)\n{\n\t// SZ(str[0] = SZ(str[distance(str.begin(), max_element(ALL(str)))])\n\tvector<vector<ll>> v(SZ(str), vector<ll>(SZ(str[distance(str.begin(), max_element(ALL(str)))]), (int)INF));\n\tREP(i, SZ(str))\n\t{\n\t\tREP(j, SZ(str[i]))\n\t\t{\n\t\t\tif (str[i][j] == WALL)\n\t\t\t\tv[i][j] = -1;\n\t\t\t//else\tv[i][j] = INF;\t// if (str[i][j] == '.')\n\t\t}\n\t}\n\treturn v;\n}\n// str中のWALL='#'の数を数える\nll cnt_wall(vector<string> str)\n{\n\tll cnt = 0;\n\tREP(i, SZ(str))\n\t{\n\t\tREP(j, SZ(str[i]))\n\t\t{\n\t\t\tif (str[i][j] == WALL)\n\t\t\t\tcnt++;\n\t\t}\n\t}\n\treturn cnt;\n}\n\n\n// マップの範囲判定\nbool rangeCheck(ll row, ll height, ll col, ll width) {\n\tif (row >= 0 && row < height && col >= 0 && col < width)\treturn true;\n\telse return false;\n}\n\n// 迷路用幅優先探索\n// フィールドの広さと壁の位置を受け取り、ゴールへの最短距離を返す\nll bfs_maze(vector<string>& str, ll s_y, ll s_x, ll g_y, ll g_x)\n{\n\n\tstruct Corr\n\t{\n\t\tll y;\n\t\tll x;\n\t\tll depth;\n\t};\n\tqueue<Corr> que;\n\t// SZ(str[0] = SZ(str[distance(str.begin(), max_element(ALL(str)))])\n\tvector<vector<ll>> v(SZ(str), vector<ll>(SZ(str[distance(str.begin(), max_element(ALL(str)))])));\n\tv = map_vec(str);\n\n\t// スタート地点を含めるのか\n\tque.push({ s_y, s_x, 0 });\n\twhile (!que.empty())\n\t{\n\t\tCorr now = que.front();\n\t\tque.pop();\n\t\tif (now.y == g_y && now.x == g_x)\n\t\t\tbreak;\n\n\t\tREP(i, 4)\n\t\t{\n\t\t\tCorr next = { now.y + dy4[i], now.x + dx4[i], now.depth + 1 };\n\t\t\t// SZ(v[0] = SZ(v[distance(v.begin(), max_element(ALL(v)))])\n\t\t\tif (rangeCheck((int)next.y, SZ(v), (int)next.x, SZ(v[distance(v.begin(), max_element(ALL(v)))])) && v[(int)next.y][(int)next.x] == INF)\n\t\t\t{\n\t\t\t\tv[(int)next.y][(int)next.x] = next.depth;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn v[(int)g_y][(int)g_x];\n}\n\n// 累積和\nvector<ll> cumulative_sum(vector<ll> a)\n{\n\tvector<ll> v(SZ(a) + 1);\n\tv[0] = 0;\n\tREP(i, SZ(a))\n\t{\n\t\tv[i + 1] = v[i] + a[i];\n\t}\n\treturn v;\n}\n\n// 繰り返し二乗法 a^n\nll iterativePower(ll a, ll n)\n{\n\tll res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)\n\t\t\tres = (res * a) % MOD;\n\t\ta = a * a % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\n// MODの逆元\nvector<ll> MODInverse(ll n, ll factN)\n{\n\tvector<ll> res(n + 1);\n\tres[n] = iterativePower(factN, MOD - 2);\n\tREPR(i, n - 1)\n\t{\n\t\tres[i] = res[i + 1] * (i + 1) % MOD;\n\t}\n\treturn res;\n}\n\n// 階乗\nvoid factorialFunc(ll n)\n{\n\tfactorial.pb(1);\n\tFOR(i, 1, n + 1)\n\t{\n\t\tfactorial.pb(factorial[i - 1] * i % MOD);\n\t}\n\tvector<ll> fact;\n\tfact = MODInverse(n, factorial[n]);\n\n\tREP(i, n + 1)\n\t{\n\t\tfactorialInverse.pb(fact[i]);\n\t}\n}\n\n// 二項係数nCr\nll comb(ll n, ll r)\n{\n\tif (n < r)\n\t\treturn 0;\n\t//ll fact = factorial(n);\n\t//vector<ll> fact_inv;\n\t//fact_inv = MODInverse(n, fact);\n\treturn (factorial[n] * factorialInverse[r]) % MOD * factorialInverse[n - r] % MOD;\n}\n\n// 文字列を連続した文字ごとに分解\nvector<pair<char, ll>> decompose_str(string s)\n{\n\tvector<pair<char, ll>> moji_cnt;\n\tmoji_cnt.pb(mp(s[0], 0));\n\tREP(i, SZ(s))\n\t{\n\t\tif (moji_cnt.back().first == s[i])\n\t\t{\n\t\t\tmoji_cnt.back().second++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmoji_cnt.pb(mp(s[i], 1));\n\t\t}\n\t}\n\treturn moji_cnt;\n}\n\n// 解答のベクトル出力(空白区切り)\nvoid ans_vec(vector<ll> ans)\n{\n\tREP(i, SZ(ans))\n\t{\n\t\tcout << ans[i] << endl;\n\t}\n\t//cout << endl;\n}\n\n//\nvoid dinamic_programming(void)\n{\n}\n\n// 総和の公式：Σk\nll totalSumFirst(ll x, ll y)\n{\n\tx = x - 1;\n\treturn (y * (y + 1) - x * (x + 1)) / 2;\n}\n\n// 総和の公式：Σk^2\nll totalSumSecond(ll x, ll y)\n{\n\tx = x - 1;\n\treturn (y * (y + 1) * (2 * y + 1) - x * (x + 1) * (2 * x + 1)) / 6;\n}\n\n// 総和の公式：Σk^3\nll totalSumThird(ll x, ll y)\n{\n\treturn pow(totalSumFirst(x, y), 2);\n}\n\n// 約数\nvector<ll> makeDivisors(ll n)\n{\n\tvector<ll> divisors;\n\tfor (ll i = 1; i * i <= n; i++)\n\t{\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tdivisors.pb(i);\n\t\t\tif (i != n / i)\n\t\t\t{\n\t\t\t\tdivisors.pb(n / i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(ALL(divisors));\n\n\treturn divisors;\n}\n\n// 尺取り法\nll shakutori(vector<ll>& v, ll x)\n{\n\tll res = 0;\n\tll n = SZ(v);\n\n\tll sum = 0;\n\tll right = 0;\n\n\tREP(left, n)\n\t{\n\n\t\twhile (right < n && sum + v[right] <= x)\n\t\t{\n\t\t\tsum += v[right];\n\t\t\tright++;\n\t\t}\n\t\tres += (right - left);\n\n\t\tif (right == left)\n\t\t\tright++;\n\t\telse\n\t\t\tsum -= v[left];\n\t}\n\n\treturn res;\n}\n\n\nvector<bool> seen;\nvector<vector<ll>> pa;\n// 深さ優先探索\nvoid dfs(const Graph& g, ll x, ll& cnt)\n{\n\tseen[x] = true; // v を訪問済にする\n\tpa[x][0] = cnt;\n\tcnt++;\n\n\t// v から行ける各頂点 next_v について\n\tfor (auto next_x : g[x]) {\n\t\tif (seen[next_x]) continue; // next_v が探索済だったらスルー\n\t\tdfs(g, next_x, cnt); // 再帰的に探索\n\t}\n\tpa[x][1] = cnt;\n\tcnt++;\n}\n\n//\nvoid dfs_maze(vector<vector<ll>>& maps, ll row, ll col, ll& cnt) {\n\tif (rangeCheck(row, SZ(maps), col, SZ(maps[0])) && maps[row][col]) {\n\t\tmaps[row][col] = 0;\n\t\tREP(k, 8) {\n\t\t\tdfs_maze(maps, row + dy8[k], col + dx8[k], cnt);\n\t\t}\n\t}\n}\n\n// 幅優先探索\nvoid bfs()\n{\n}\n\n// bit全探索\nvoid bitFullSearch(ll n)\n{\n\tREP(bit, 1 << n)\n\t{\n\t\tvector<ll> vec;\n\t\tREP(i, n)\n\t\t{\n\t\t\tif (bit >> i & 1)\n\t\t\t{\n\t\t\t\tvec.pb(i);\n\t\t\t}\n\t\t}\n\t}\n}\n\n// 重複削除\nvector<ll> duplicateDeletion(vector<ll> vec)\n{\n\tsort(ALL(vec));\n\tvec.erase(unique(ALL(vec)), vec.end());\n\treturn vec;\n}\n\n// 文字列区切り\nvector<string> split(string s, string delim)\n{\n\tif (s.empty())\n\t\treturn {};\n\tif (delim.empty())\n\t\treturn { s };\n\tint start = 0;\n\tauto delim_pos = s.find(delim);\n\tvector<string> ret_v;\n\twhile (delim_pos != string::npos)\n\t{\n\t\tif (start != delim_pos)\n\t\t\tret_v.push_back(s.substr(start, delim_pos - start)); // 残り文字列の先頭が区切り文字列だった時はvectorに追加しない\n\t\tstart = delim_pos + delim.size();\n\t\tdelim_pos = s.find(delim, start);\n\t}\n\tif (start < s.size())\n\t\tret_v.push_back(s.substr(start)); // 最後の区切り文字以降に文字がある場合\n\treturn ret_v;\n}\n\n//\n// main関数\n//\n\nsigned\nmain()\n{\n\t//cin.tie(0);\n\t//ios::sync_with_stdio(false);\n\n\t// 変数（scala）取得\n\t//ll n;\n\t//cin >> n;\n\n\t// 変数（vector）取得\n\t// vector<ll> a;\n\t// a = INV(n);\n\t////m=2;\n\t//vector<vector<ll>> vec(n, vector<ll>(m));\n\t//vec = INV2(n, m);\n\n\t// vector<vector<ll>> a(3);\n\t// REP(i, a)\n\t// {\n\t// \tll tmp;\n\t// \tcin >> tmp;\n\t// \ta[0].pb(tmp);\n\t// }\n\t// REP(i, b)\n\t// {\n\t// \tll tmp;\n\t// \tcin >> tmp;\n\t// \ta[1].pb(tmp);\n\t// }\n\t// REP(i, c)\n\t// {\n\t// \tll tmp;\n\t// \tcin >> tmp;\n\t// \ta[2].pb(tmp);\n\t// }\n\n\t// 文字列取得\n\t// string s;\n\t// cin >> s;\n\n\t// 文字列（vector）取得\n\t// vector<string> str(n);\n\t// REP(i, n)\n\t// {\n\t// \tcin >> str[i];\n\t// }\n\n\t// グラフ取得\n\t//Graph g(n);\n\t//REP(i, k) {\n\t//\tll from, weight;\n\t//\tcin >> from >> weight;\n\t//\tg[from].pb(to);\n\t//\t//g[to].pb(from);\n\t//}\n\n\t// 迷路用string取得\n\t//vector<string> str(h);\n\t//REP(i, h) {\n\t// cin >> str[i];\n\t//}\n\n\t// 二項係数を計算する際に必要\n\n\t// factorialFunc(n);\n\n\t//\n\t// 実装部分\n\t//\n\n\tll n;\n\tstring t;\n\tcin >> n >> t;\n\tll n3 = pow(3, n);\n\tll cnt_s = 0, cnt_r = 0;\n\n\tvector<ll> table(n3, INF);\n\tREP(i, n3) {\n\t\tif (table[i] == INF) {\n\t\t\tll tmp = i;\n\t\t\tstring str;\n\t\t\tREPR(j, 11) {\n\t\t\t\tint keta = pow(3, j);\n\t\t\t\tint sho = tmp / keta;\n\t\t\t\tint amari = tmp % keta;\n\t\t\t\tstr.append(to_string(sho));\n\t\t\t\ttmp = amari;\n\t\t\t\t//if (!tmp)\tbreak;\n\t\t\t}\n\t\t\t//tmp = 0;\n\t\t\tREP(j, 12) {\n\t\t\t\tif (str[j] == '1')\tstr[j] = '2';\n\t\t\t\telse if (str[j] == '2')\tstr[j] = '1';\n\t\t\t\ttmp += pow(3, 11 - j) * (str[j] - '0');\n\t\t\t}\n\t\t\ttable[i] = tmp;\n\t\t\ttable[tmp] = i;\n\t\t}\n\t}\n\n\n\tdeque<ll> que;\n\tREP(i, n3) {\n\t\tque.pb(i);\n\t}\n\tvector<bool> chk(n3, true);\n\tREP(i, SZ(t)) {\n\t\tif (t[i] == 'S') {\n\t\t\tREP(j, n3) {\n\t\t\t\tif (chk[j]) {\n\t\t\t\t\tll tmp = que.at(table[j]);\n\t\t\t\t\tque.erase(que.begin() + table[j]);\n\t\t\t\t\tque.insert(que.begin() + table[j], que.at(j));\n\t\t\t\t\tque.erase(que.begin() + j);\n\t\t\t\t\tque.insert(que.begin() + j, tmp);\n\t\t\t\t\tchk[j] = chk[table[j]] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tll tmp = que.back();\n\t\t\tque.pop_back();\n\t\t\tque.push_front(tmp);\n\t\t}\n\t}\n\n\tREP(i, n3) {\n\t\tll tmp = que.back();\n\t\tque.pop_back();\n\t\tcout << tmp << \" \";\n\t}\n\tcout << endl;\n\n\n\n\t//\n\t// 実装部分おわり\n\t//\n\n\t// 解答出力\n\t// cout << fixed << setprecision(10);\n\t// MSG(ans);\n\t//ans_vec(ans);\n\n\treturn 0;\n}\n\n//\n// memo\n//\n\n//for(ll i=0; i<n;i++)　// ループ\n//cout << << endl;\t// 出力\n//sort(ALL(a), greater<ll>()); // 降順\n// abs(k)\t// 絶対値\n// sqrt(n)\t// ルート\n// ceil(n)\t// 切り上げ\n// floor(n)\t// 切り捨て\n// round(n)\t// 四捨五入\n// map<ll, ll, greater<ll>> mp;\t// mapの降順\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string>\n#include<cmath>\n\nusing namespace std;\n\nint sch(int n){     \n    int out=0,tmp,count=0;\n    while(n != 0){\n        tmp = n % 3;\n        if(tmp==1){\n            out += 2*pow(3,count);\n        }else if(tmp==2){\n            out += pow(3,count);\n        }\n        count++;\n        n /= 3;\n    }\n    return out;\n}\n\nint main(){\n    int N,p,size,len;\n    string T;\n    cin >> N;\n    cin >> T;\n    size = int(pow(3,N));\n    vector<int> table(pow(size,0));\n    len = T.length();\n    for(int i=0;i<size;i++){\n        if(i % 3 == 0){\n            table[i] = sch(i);\n        }else if(i % 3 == 1){\n            table[i] = table[i-1] + 2;\n        }else{\n            table[i] = table[i-1] - 1;\n        }\n    }\n    //for(int i=0;i<size;i++) cout << i << ' ' <<table[i] << endl;;\n\n    for(int i=0;i<size;i++){\n        p=i;\n        for(int j=0;j<len;j++){\n            if(T[j] == 'S'){\n                if(T[j+1] == 'S') j++;\n                else p = table[p];\n            }else{\n                p++;\n                if(p==size) p=0;\n            }\n        }\n        cout << p << ' ';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,x,y,z,sw,pw3=1,A[531441]={0},B[531441]={0},S[531441]={0};\nchar T[200001];\nvoid OUT(int x){if(x<0)putchar('-'),x=-x;if(x>=10)OUT(x/10);putchar(x%10+48);}\nsigned main(void)\n{\n  x=scanf(\"%d %s\",&N,T);\n  rep(i,N)\n  {\n    rep(j,pw3)rep(k,3)B[j+k*pw3]=k;sw=1;\n    rep(p,strlen(T))\n    {\n      if(T[p]=='R')\n      {\n        y=S[p];\n        rep(j,3)\n        {\n          x=y+j*pw3;\n          if((B[x]==1&&sw==-1)||(B[x]==2&&sw==1))S[p]=x;\n          B[x]+=(sw==1?1:2);B[x]%=3;\n        }\n      }\n      else sw*=-1;\n    }\n    rep(j,pw3)\n    {\n      y=A[j];\n      rep(k,3){x=j+k*pw3;A[x]=y+((sw==-1)?3-B[x]:B[x])%3*pw3;}\n    }\n    pw3*=3;\n  }\n  rep(i,pw3)OUT(A[i]),putchar(' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\nusing Int = long long;\nconst char newl = '\\n';\n\n//INSERT ABOVE HERE\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int n;\n  cin>>n;\n\n  vector<vector<int>> W(n);\n  int sz=1;\n  for(int i=0;i<n;i++){\n    sz*=3;\n    W[i].resize(sz);\n  }\n\n  // k-th digit of v in ternary representation\n  vector<int> po(n+1,1);\n  for(int i=0;i<n;i++) po[i+1]=po[i]*3;\n  auto digit=[&](int i,int j){\n    return (j/po[i])%3;\n  };\n\n  for(int j=0;j<sz;j++)\n    for(int i=0;i<n;i++)\n      W[i][j%W[i].size()]=digit(i,j);\n\n  int flip=0;\n  auto query=[&](int i,int j){\n    int val=W[i][j%W[i].size()];\n    return (flip?3-val:val)%3;\n  };\n  auto update=[&](int i,int j,int val){\n    W[i][j%W[i].size()]=(flip?3-val:val)%3;\n  };\n\n  auto rumba=[&](){\n    int s=0,d=1;\n    for(int i=0;i<n;i++){\n      int x=(query(i,s+d*0)+1)%3;\n      int y=(query(i,s+d*1)+1)%3;\n      int z=(query(i,s+d*2)+1)%3;\n      update(i,s+d*0,x);\n      update(i,s+d*1,y);\n      update(i,s+d*2,z);\n      if(x==0) s+=d*0;\n      if(y==0) s+=d*1;\n      if(z==0) s+=d*2;\n      d*=3;\n    }\n  };\n\n  string t;\n  cin>>t;\n\n  for(char c:t){\n    if(c=='S') flip^=1;\n    if(c=='R') rumba();\n  }\n\n  vector<int> ans(sz,0);\n  for(int j=0;j<sz;j++)\n    for(int i=0;i<n;i++)\n      ans[j]+=query(i,j)*po[i];\n\n  for(int j=0;j<sz;j++){\n    if(j) cout<<' ';\n    cout<<ans[j];\n  }\n  cout<<newl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing int64 = long long;\n\nconstexpr int DEBUG = 0;\n\nint Power3(int p) {\n  int r = 1;\n  for (int i = 0; i < p; i++) {\n    r *= 3;\n  }\n  return r;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n  string original_command;\n  cin >> original_command;\n  vector<vector<int>> output_table(n + 1);\n  vector<vector<string>> command_table(n + 1);\n  for (int k = 1; k <= n; k++) {\n    output_table[k].resize(Power3(k));\n    command_table[k].resize(Power3(k));\n  }\n\n  for (int k = 1; k <= n; k++) {\n    for (int x = 0; x < Power3(k); x++) {\n      // cout << \"k: \" << k << \" x: \" << x << endl;\n\n      string command;\n      if (k == 1) {\n        command = original_command;\n      } else {\n        command = command_table[k - 1][x % Power3(k - 1)];\n      }\n\n      int d = x / Power3(k - 1);\n      string next_command = \"\";\n      for (char c : command) {\n        if (c == 'R') {\n          d++;\n          if (d == 3) {\n            d = 0;\n            next_command.append(\"R\");\n          }\n        } else if (c == 'S') {\n          if (d == 1) d = 2;\n          else if (d == 2) d = 1;\n\n          next_command.append(\"S\");\n        }\n      }\n\n      // next_command = std::regex_replace(next_command, std::regex(\"SS\"), \"\");\n\n      output_table[k][x] = d;\n      command_table[k][x] = next_command;\n    }\n  }\n\n  vector<int> outputs;\n  for (int x = 0; x < Power3(n); x++) {\n    int output = 0;\n    for (int k = 1; k <= n; k++) {\n      output += output_table[k][x % Power3(k)] * Power3(k - 1);\n    }\n    outputs.push_back(output);\n  }\n\n  for (int i = 0; i < outputs.size(); i++) {\n    if (i > 0) cout << \" \";\n    cout << outputs[i];\n  }\n  cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint ch[10000005][3],ed[10000005],cnt=1,ans[10000005];\nbool rev[10000005];\nchar s[200005];\nvoid pushr(int x){swap(ch[x][1],ch[x][2]);rev[x]^=1;}\nvoid pushdown(int x)\n{\n    if(!rev[x])return;\n    for(int i=0;i<=2;i++)if(ch[x][i])pushr(ch[x][i]);\n    rev[x]=0;\n}\nvoid dfs(int x)\n{\n    pushdown(x);\n    swap(ch[x][0],ch[x][2]),swap(ch[x][1],ch[x][2]);\n    if(ch[x][0])dfs(ch[x][0]);\n}\nvoid get(int x,int now,int pw)\n{\n    pushdown(x);\n    if(ed[x]!=0xffffffff)ans[ed[x]]=now;\n    if(ch[x][0])get(ch[x][0],now,pw*3);\n    if(ch[x][1])get(ch[x][1],now+pw,pw*3);\n    if(ch[x][2])get(ch[x][2],now+2*pw,pw*3);\n}\nint main()\n{\n    int n,m=1;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)m*=3;\n    memset(ed,0xff,sizeof(ed));\n    for(int i=0;i<m;i++)\n    {\n        int now=1,tmp=i;\n        for(int k=0;k<n;k++)\n        {\n            int t=tmp%3;\n            tmp/=3;\n            if(!ch[now][t])ch[now][t]=++cnt;\n            now=ch[now][t];\n        }\n        ed[now]=i;\n    }\n    scanf(\"%s\",s+1);\n    int q=strlen(s+1);\n    for(int i=1;i<=q;i++)\n    {\n        if(s[i]=='S')pushr(1);\n        else dfs(1);\n    }\n    get(1,0,1);\n    for(int i=0;i<m;i++)printf(\"%d \",ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar T[500005];\nint salsa2[500005];\n\nint N;\n\nint salsa(int x){\n    int temp = x;\n    int pow3 = 1;\n    int res = 0;\n    for(int i = 0; i < N; i ++){\n        int k = temp%3;\n        temp /= 3;\n\n        if(k == 1){\n            res += pow3*2;\n        }else if(k == 2){\n            res += pow3;\n        }\n        pow3 *= 3;\n    }\n    return res;\n}\n\nint main(){\n    scanf(\"%d\", &N);\n\n    scanf(\" %s\", T);\n\n    int pow3N = 1;\n    for(int i = 0; i < N; i ++){\n        pow3N *= 3;\n    }\n\n    for(int i = 0; i < pow3N; i ++){\n        salsa2[i] = salsa(i);\n        //printf(\"salsa2[%d]=%d\\n\", i, salsa2[i]);\n    }\n\n    for(int j = 0; j < pow3N; j ++){\n        int x = j;\n        for(int i = 0; i < pow3N; i ++){\n            if(T[i] == 'R'){\n                x = (x+1)%pow3N;\n            }else if(T[i] == 'S'){\n                x = salsa2[x];\n            }\n        }\n        printf(\"%d \", x);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,rt,sz,val[888888],son[888888][3],tag[888888],ans[888888],all;\nchar s[222222];\nvoid build(int &nw,int c,int dep,int sum)\n{\n\tnw=++sz;\n\tif (dep==n)\n\t{\n\t\tval[nw]=sum;\n\t\treturn;\n\t}\n\tbuild(son[nw][0],c*3,dep+1,sum);\n\tbuild(son[nw][1],c*3,dep+1,sum+c);\n\tbuild(son[nw][2],c*3,dep+1,sum+2*c);\n}\nvoid push(int node)\n{\n\tswap(son[node][1],son[node][2]);\n\ttag[node]^=1;\n}\nvoid pushdown(int node)\n{\n\tif (tag[node])\n\t{\n\t\tpush(son[node][0]);\n\t\tpush(son[node][1]);\n\t\tpush(son[node][2]);\n\t\ttag[node]=0;\n\t}\n}\nvoid go(int nw,int dep)\n{\n\tif (dep==n) return;\n\tpushdown(nw);int s1=son[nw][0],s2=son[nw][1],s3=son[nw][2];\n\tson[nw][0]=s3;son[nw][1]=s1;son[nw][2]=s2;\n\tgo(son[nw][0],dep+1);\n}\nvoid cal(int nw,int c,int dep,int sum)\n{\n\tif (dep==n)\n\t{\n\t\tans[val[nw]]=sum;\n\t\treturn;\n\t}\n\tpushdown(nw);\n\tcal(son[nw][0],c*3,dep+1,sum);\n\tcal(son[nw][1],c*3,dep+1,sum+c);\n\tcal(son[nw][2],c*3,dep+1,sum+2*c);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s);\n\tm=strlen(s);\n\tbuild(rt,1,0,0);\n\tfor (int i=0;i<m;i++)\n\t{\n\t\tif (s[i]=='S')\n\t\t{\n\t\t\tpush(rt);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgo(rt,0);\n\t\t}\n\t}\n\tcal(rt,1,0,0);\n\tall=1;\n\tfor (int i=1;i<=n;i++) all*=3;\n\tfor (int i=0;i<all;i++) printf(\"%d \",ans[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<int(r);i++)\n#define rep(i,r) rng(i,0,r)\n#define rrng(i,l,r) for(int i=int(r)-1;i>=int(l);i--)\n#define rrep(i,r) rrng(i,0,r)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u>void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\n\nint n,ru[13],ch[13][600000];\nvc<char>p[13][600000];\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\tru[0]=1;\n\trng(i,1,n+1)ru[i]=ru[i-1]*3;\n\tstring s;\n\tcin>>s;\n\trep(i,si(s)){\n\t\tp[0][0].pb(s[i]);\n\t}\n\trng(i,1,n+1){\n\t\trep(j,ru[i]){\n\t\t\tint x=j/ru[i-1];\n\t\t\tfor(auto &k:p[i-1][j%ru[i-1]]){\n\t\t\t\tif(k=='S'){\n\t\t\t\t\tif(x==1)x=2;\n\t\t\t\t\telse if(x==2)x=1;\n\t\t\t\t\tif(si(p[i][j])>0&&p[i][j].back()=='S')p[i][j].pop_back();\n\t\t\t\t\telse p[i][j].pb('S');\n\t\t\t\t}else{\n\t\t\t\t\tif(x==2)p[i][j].pb('R');\n\t\t\t\t\tx=(x+1)%3;\n\t\t\t\t}\n\t\t\t}\n\t\t\tch[i][j]=x;\n\t\t}\n\t}\n\trep(i,ru[n]){\n\t\tint ans=0;\n\t\trep(j,n){\n\t\t\tans+=ch[j+1][i%ru[j+1]]*ru[j];\n\t\t}\n\t\tcout<<ans;\n\t\tif(i==ru[n]-1)cout<<endl;\n\t\telse cout<<' ';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, n) for(i = 0; i < n; i++)\n//2D::rep(i,j)rep(j,j)cin>>bin[i][j];\n//vector<int> a(n)\n#define A1 cout<<\"No\"<<endl\n#define A2 cout<<\"Yes\"<<endl\n#define A3 cout<<ans<<endl\n#define AA(i) cout<<i<<endl\nconst int U=2e5+5;\nconst ll MOD=998244353;\nconst int INF = 1001001001;\n\nll POW(int n,int m){\n  long long pow = 1;\n  while (m>0) {\n    if ((m&1) == 1) pow = (pow*n);\n    m >>= 1;\n    n = (n*n);\n  }\n    return pow;\n}\n\nmap<int,int> m;\nvoid S3(ll K) {\n    int h = 0,M;\n    for(int i=0;i<K;i++){\n        M = i;\n        h = 0;\n        for(int j=0;;j++){\n            h += ((M % 3) * 2 % 3) * POW(3,j);\n            M /= 3;\n            if(M == 0) break;\n        }\n        m[i]= h;\n    }\n}\n\n\n\nint main(){\n    int N; cin >> N;\n    int K = POW(3,N);\n    S3(K);\n    string T; cin >> T;\n    vector<int> k(K);\n    vector<int> t(K);\n    for(int i=0;i<K;i++) k[i] = i;\n    for(int i=0;i<T.size();i++){\n        if(T[i] == 'S' && T[i]+1 == 'S') i++;\n        else if(T[i] == 'R'){\n            int S = k[K-1];\n            k.pop_back();\n            k.insert(k.begin(),S);\n        }\n        else{\n            for(int i = 0; i<K;i++){\n                t[i] = m[k[i]];\n            }\n            for(int i = 0; i<K;i++){\n                k[i] = t[i];\n            }\n\n        }\n    }\n    int i;\n    rep(i,K) AA(k[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x) cerr << #x << \" : \" << x << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\n\nconst ll Mod = 1000000007LL;\nconst int N = 2e5 + 10;\nconst ll Inf = 2242545357980376863LL;\nconst ll Log = 30;\n\nvoid OK(str& t){\n\tstr s = \"\";\n\tfor(auto c : t){\n\t\tif(c == 'R') s += c;\n\t\telse {\n\t\t\tif((s.size() > 0) && s.back() == 'S') s.pop_back();\n\t\t\telse s += c;\n\t\t}\n\t}\n\tt = s;\n}\n\nvector<int> Solve(int n, str T){\n\tint pw = 1;\n\tfor(int i = 0; i < n; i++) pw = 3*pw;\n\n\tvector<int> res(pw, 0);\n\tif(n == 0){\n\t\treturn res;\n\t}\n\tvector<int> rec(pw / 3);\n\tstr T2;\n\tint nw;\n\tfor(int bt = 0; bt < 3; bt ++){\n\t\tT2 = \"\";\n\t\tnw = bt;\n\t\tfor(auto c : T){\n\t\t\tif(c == 'S'){\n\t\t\t\tT2 += c;\n\t\t\t\tif(nw != 0) nw = 3 - nw;\n\t\t\t} else {\n\t\t\t\tif(nw == 2) T2 += 'R';\n\t\t\t\tnw = (nw + 1) % 3;\n\t\t\t}\n\t\t}\n\t\tOK(T2);\n\t\trec = Solve(n - 1, T2);\n\t\tfor(int i = bt; i < pw; i += 3){\n\t\t\tres[i] = rec[i / 3] * 3 + nw;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\t//str ts = \"RSSSR\";\n\t//OK(ts); debug(ts);\n\tint n;\n\tcin >> n;\n\tstr T;\n\tcin >> T;\n\tvector<int> ans = Solve(n, T);\n\tfor(auto x : ans) cout << x << ' ';\n\t\tcout << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <cassert>\n\nint main()\n{\n  int n;\n  scanf(\"%d\",&n);\n  std::vector<int> p3(n+1);\n  p3[0]=1;\n  for(int i=0;i<n;i++){\n    p3[i+1]=3*p3[i];\n  }\n  static char T[200010];\n  scanf(\"%s\",T);\n  int m=strlen(T);\n  std::vector<bool> t(m);\n  for(int i=0;i<m;i++){\n    t[i]=(T[i]=='S');\n  }\n  std::vector<int> P(p3[n]),p(p3[n]);\n  P[0]=0;\n  std::vector<int> W(m,0);\n  for(int r=0;r<n;r++){\n    for(int i=0;i<p3[r+1];i++){\n      p[i]=i/p3[r];\n    }\n    bool f=false;\n    for(int j=0;j<m;j++){\n      /*for(int i=0;i<p3[r+1];i++){\n\tprintf(\"%d%c\",p[i],i+1<p3[r+1]?' ':'\\n');\n\t}*/\n      if(t[j]){\n\tf=!f;\n      }\n      else if(!f){\n\tint X=-1;\n\tfor(int x=0;x<3;x++){\n\t  int i=x*p3[r]+W[j];\n\t  if(p[i]==2){\n\t    X=x;\n\t  }\n\t  p[i]=(p[i]+1)%3;\n\t}\n\tassert(X!=-1);\n\tW[j]=X*p3[r]+W[j];\n      }\n      else{\n\tint X=-1;\n\tfor(int x=0;x<3;x++){\n\t  int i=x*p3[r]+W[j];\n\t  if(p[i]==1){\n\t    X=x;\n\t  }\n\t  p[i]=(p[i]==0?2:p[i]==1?0:1);\n\t}\n\tassert(X!=-1);\n\tW[j]=X*p3[r]+W[j];\n      }\n    }\n    for(int i=p3[r+1]-1;i>=0;i--){\n      P[i]=P[i%p3[r]]+(f?(3-p[i])%3:p[i])*p3[r];\n      //printf(\"%d%c\",P[i],i==0?'\\n':' ');\n    }\n  }\n  for(int i=0;i<p3[n];i++){\n    printf(\"%d%c\",P[i],i+1<p3[n]?' ':'\\n');\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint change3(int A){\n  vector<int> b3(0);\n  while(A>2){\n    int aw3 = A%3;\n    b3.push_back((aw3==0)?0:\n                 (aw3==1)?2:1);\n    A/=3;\n  }\n  int aw3 = A%3;\n  b3.push_back((aw3==0)?0:\n               (aw3==1)?2:1);\n  int sum=0;\n  for(int i=0;i<b3.size();i++){\n   sum+= pow(3,i)*b3.at(i); \n  }\n  return sum;\n}\n\n\nint main() {\n  int N;\n  cin >> N;\n  int N3 = pow(3,N);\n  vector<int> dan(N3);\n  vector<int> c3b(N3);\n  for(int i=0;i<N3;i++){\n    dan.at(i)=i;\n    c3b.at(i)=change3(i);\n  }\n  string recode;\n  cin >> recode;\n  \n  \n  for(char i:recode){\n    if(i=='S'){\n     for(int &j:dan){\n      j=c3b.at(j); \n     }\n    }else{\n      for(int &j:dan){\n        j++;\n        if(j>=N3)j-=N3;\n      }\n    }\n      \n    \n  }\n    \n  for(int i:dan){\n    cout << i << \" \";\n  }\n  cout << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst long double eps = 1E-14;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\n\nint main() {\n\tll N;\n\tcin >> N;\n\tstring T;\n\tcin >> T;\n\tll K = T.size();\n\n\tvvvll dp(N + 1);\n\tvvll bit(N + 1);\n\n\tdp[0].resize(1);\n\n\tvll run;\n\trun.push_back(-1);\n\trep(i, K) {\n\t\tif (T[i] == 'R') { run.push_back(i); }\n\t}\n\trun.push_back(K);\n\n\trep(i, run.size() - 1) {\n\t\tdp[0][0].push_back((run[i + 1] - run[i]-1)%2);\n\t}\n\n\t//rep(i, dp[0][0].size()) {\n\t//\tcout << dp[0][0][i] << \" \";\n\t//}\n\t//cout << endl;\n\n\trepn(i, N) {\n\t\tll beki = 1;\n\t\trep(j, i)beki *= 3;\n\n\t\tdp[i].resize(beki);\n\t\tbit[i].resize(beki);\n\n\t\trep(x, beki) {\n\t\t\tll y = x % (beki / 3);\n\n\t\t\tbit[i][x] = x / (beki / 3);\n\n\t\t\tvll kuri;\n\t\t\tkuri.push_back(0);\n\t\t\tll sal = 0;\n\n\t\t\trep(k, dp[i - 1][y].size()) {\n\t\t\t\tif (dp[i - 1][y][k] == 1) {\n\t\t\t\t\tif (bit[i][x] == 2) { bit[i][x] = 1; }\n\t\t\t\t\telse if (bit[i][x] == 1) { bit[i][x] = 2; }\n\t\t\t\t\tsal++;\n\t\t\t\t}\n\n\t\t\t\tif (k != dp[i - 1][y].size() - 1) { bit[i][x]++; }\n\t\t\t\tif (bit[i][x] == 3) { kuri.push_back(sal); bit[i][x] = 0; }\n\t\t\t}\n\n\t\t\tkuri.push_back(sal);\n\n\t\t\trep(k, kuri.size() - 1) {\n\t\t\t\tdp[i][x].push_back((kuri[k + 1] - kuri[k])%2);\n\t\t\t}\n\n\t\t\t//cout << i << \" \" << x << endl;\n\t\t\t//rep(k, dp[i][x].size()) {\n\t\t\t//\tcout << dp[i][x][k] << \" \";\n\t\t\t//}\n\t\t\t//cout <<endl<< bit[i][x] << endl;\n\t\t\t//cout << endl;\n\t\t}\n\t}\n\n\t\n\tll beki = 1;\n\trep(i, N) beki *= 3;\n\n\trep(i, beki) {\n\t\tll ans = 0;\n\n\t\tll x = i;\n\t\tll c = beki/3;\n\t\tfor (ll j = N; j >= 1; j--) {\n\t\t\t//cout << j << x << bit[j][x] << endl;\n\t\t\tans += bit[j][x] * c;\n\t\t\tx -= (x / c) * c;\n\t\t\tc /= 3;\n\t\t}\n\n\t\tcout << ans << \" \";\n\n\t}\n\n\tcout << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 6e5;\nint n, m;\nint W[2][N], ans[N], o, d[N], rev;\nchar t[N];\nint main() {\n\tcin >> n; scanf(\"%s\", t+1);\n\tm = strlen(t + 1);\n\tint qc = 1;\n\tfor(int i=1;i<=n;i++)qc=qc*3;\n\tint ful = 3;\n\tfor(int e = 1; e <= n; e++, ful *= 3) {\n\t\trev = 0;\n\t\tint lasful = ful / 3;\n\t\tfor(int i = 0; i < ful; i++) d[i] = i / (lasful);\n\t\tfor(int i = 1; i <= m; i++) {\n\t\t\tif (t[i] == 'S') {\n\t\t\t\trev ^= 1;\n\t\t\t} else {\n\t\t\t\tfor(int z = 0, s = 0; z < 3; z++, s += lasful) {\n\t\t\t\t\tint x = s + W[o][i];\n\t\t\t\t\tif (rev == 0 && d[x] == 2 || rev == 1 && d[x] == 1) {\n\t\t\t\t\t\tW[1 - o][i] = x;\n\t\t\t\t\t}\n\n\t\t\t\t\tint t = d[x];\n\t\t\t\t\tif (rev == 1) {\n\t\t\t\t\t\tif (t == 1) t = 2; else\n\t\t\t\t\t\tif (t == 2) t = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tt = (t + 1) % 3;\n\t\t\t\t\tif (rev == 1) {\n\t\t\t\t\t\tif (t == 1) t = 2; else\n\t\t\t\t\t\tif (t == 2) t = 1;\n\t\t\t\t\t}\n\t\t\t\t\td[x] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < qc; i++) {\n\t\t\tint g=d[i%ful];\n\t\t\tif(rev){\n\t\t\t\tif(g==1)g=2;else if (g==2)g=1;\n\t\t\t}\n\t\t\tans[i]+=lasful*g;\n\t\t}\n\t\to = 1 - o;\n\t}\n\tfor(int i=0;i<qc;i++)printf(\"%d \",ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 2000010;\nint n, ans[maxn];\nchar s[maxn];\n\nnamespace TRIE {\nint tot = 1, num[maxn], ch[maxn][3], tag[maxn];\n\nvoid pushdown(int k) {\n    swap(ch[k][1], ch[k][2]), tag[k] = 0;\n    for (int i = 0; i < 3; i++) tag[ch[k][i]] ^= 1;\n}\n\nvoid ins(int x) {\n    int cur = 1, y = x;\n    for (int i = n; i; i--, x /= 3) {\n        int c = x % 3;\n        if (!ch[cur][c]) ch[cur][c] = ++tot;\n        cur = ch[cur][c];\n    }\n    num[cur] = y + 1;\n}\n\nvoid inc() {\n    int cur = 1;\n    for (int i = 1; i <= n; i++) {\n        if (tag[cur]) pushdown(cur);\n        swap(ch[cur][0], ch[cur][2]), swap(ch[cur][1], ch[cur][2]);\n        cur = ch[cur][0];\n    }\n}\n\nvoid dfs(int k, int pos = 0, int w = 1) {\n    if (tag[k]) pushdown(k);\n    if (num[k]) { ans[num[k] - 1] = pos; return; }\n    for (int i = 0; i < 3; i++) dfs(ch[k][i], pos + i * w, w * 3);\n}\n}  // namespace TRIE\n\nint main() {\n    scanf(\"%d %s\", &n, s + 1);\n    int tot = pow(3, n);\n    for (int i = 0; i < tot; i++) {\n        TRIE::ins(i);\n    }\n    for (int i = 1, l = strlen(s + 1); i <= l; i++) {\n        if (s[i] == 'S') TRIE::tag[1] ^= 1;\n        else TRIE::inc();\n    }\n    TRIE::dfs(1);\n    for (int i = 0; i < tot; i++) {\n        printf(\"%d \", ans[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr<<\"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return rng() % (y+1-x) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\nusing ll=long long; \nusing ld=long double;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\nusing pi=pair<ll,ll>; using spi=pair<ll,pi>; using dpi=pair<pi,pi>; \n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (600006)\nll n, A[MAXN], p3[15], ofs2, half, mp[729], edge[729], opp[MAXN];\nstring T;\nvector<ll> v[729];\nll flip(ll x){\n\tif(~opp[x]) return opp[x];\n\tll res=0,ox=x;\n\tDEC(j,n-1,half) if(x>=p3[j]*2) {\n\t\tres += p3[j];\n\t\tx -= p3[j] * 2;\n\t} else if(x>=p3[j]) {\n\t\tres += p3[j] * 2;\n\t\tx -= p3[j];\n\t}\n\treturn opp[ox]=res;\n}\nint main(){\n\tp3[0]=1; FOR(i,1,14) p3[i]=p3[i-1]*3;\n\tmmst(opp,-1);\n\tFAST\n\tcin>>n>>T;half=n/2;\n\tFOR(i,0,p3[half]-1) mp[i]=i;\n\tFOR(i,0,p3[half]-1){\n\t\tedge[i]=i;\n\t\tll add=0;\n\t\tDEC(j,half-1,0)if(edge[i]>=p3[j]*2){\n\t\t\tedge[i] -= p3[j] * 2;\n\t\t\tadd += p3[j];\n\t\t}else if(edge[i]>=p3[j]) {\n\t\t\tedge[i] -= p3[j];\n\t\t\tadd += p3[j] * 2;\n\t\t}assert(edge[i]==0);\n\t\tedge[i]=add;\n\t}\n\tFOR(i,0,p3[n]-1){\n\t\tA[i]=i;\n\t\tDEC(j,n-1,half) if(A[i]>=p3[j]*2) A[i]-=p3[j]*2; else if(A[i]>=p3[j]) A[i]-=p3[j];\n\t\tv[A[i]].eb(i), A[i]=i-A[i];\n\t}\n\tFOR(i,0,siz(T)-1){\n\t\tif(T[i]=='R'){//+1\n\t\t\tll act=-1;\n\t\t\tFOR(i,0,p3[half]-1) if(mp[i]==p3[half]-1) assert(act==-1), act=i;\n\t\t\tassert(~act);\n\t\t\tfor(auto i:v[act]) {\n\t\t\t\tif(ofs2) A[i]=flip(A[i]);\n\t\t\t\tA[i] += p3[half];\n\t\t\t\tif(A[i] >= p3[n]) A[i] -= p3[n], assert(A[i]==0);\n\t\t\t\tif(ofs2) A[i]=flip(A[i]);\n\t\t\t}\n\t\t\tFOR(i,0,p3[half]-1) ++ mp[i], mp[i] %= p3[half];\n\t\t}else{\n\t\t\tofs2 ^= 1;\n\t\t\tFOR(i,0,p3[half]-1){\n\t\t\t\tmp[i]=edge[mp[i]];\n\t\t\t}\n\t\t}\n\t}\n\tFOR(i,0,p3[n]-1) if(ofs2) A[i]=flip(A[i]);\n\tFOR(i,0,p3[half]-1) {\n\t\tfor(auto j:v[i]) A[j] += mp[i];\n\t}\n\tFOR(i,0,p3[n]-1) cout<<A[i]<<' '; cout<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n// #include <ext/pb_ds/assoc_container.hpp> \n// #include <ext/pb_ds/detail/standard_policies.hpp>\n// using namespace __gnu_pbds;\n\n#pragma GCC optimize(\"O3\")\n#ifdef LOCAL\n#include \"/Users/lbjlc/Desktop/coding/debug_utils.h\"\n#else\n#define print(...) ;\n#define printn(...) ;\n#define fprint(...) ;\n#define fprintn(...) ;\n#endif\n\n#define rep(i, a, b) for(auto i = (a); i < (b); i++)\n#define rrep(i, a, b) for(auto i = (a); i > (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define pb push_back\n// #define mp make_pair\n#define fi first\n#define se second\n#define maxi(x, y) x = max(x, y)\n#define mini(x, y) x = min(x, y)\n// long long fact(long long n) { if(!n) return 1; return n*fact(n-1); }\n// #define endl '\\n'\n#define solve_testcase int T;cin>>T;for(int t=1;t<=T;t++){solve(t);}\n\n// long long gcd(long long x, long long y) { return y ? gcd(y, x % y) : x; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\n \ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n \ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\ntypedef vector<long long> vll;\n#define bd(type,op,val) bind(op<type>(), std::placeholders::_1, val)\n\nconst int MAXN = 1e6+10;\n\n\nvoid solve(int tt) {\n    // cout<<\"Case #\"<<tt<<\": \";\n}\n\nstring to_ter(int x, int k=-1) {\n    string res;\n    while(x) {\n        res+='0'+x%3;\n        x/=3;\n    }\n    if(k>=0) {\n        while(res.size()<k) res+='0';\n    }\n    return res;\n}\nint to_int(const string & s) {\n    int res=0;\n    // rrep(i,s.size()-1,-1)\n    //     res=res*3+(s[i]-'0');\n    for(int i=s.size()-1;i>=0;i--)\n        res=res*3+(s[i]-'0');\n    // print(s,res);\n    return res;\n}\nbool add(string & x, const string & y) {\n    int n1=x.size(), n2=y.size(),carry=0;\n    rep(i,0,n1) {\n        if(i<n1) carry+=x[i]-'0';\n        if(i<n2) carry+=y[i]-'0';\n        x[i]=carry%3+'0';\n        carry/=3;\n    }\n    return carry==0;\n}\n\nvi cal_inst(string & s) {\n    int n=s.size();\n    vi res(1);\n    int i=0;\n    while(i<n) {\n        if(s[i]=='R') {\n            res.back()++;\n            i++;\n        }\n        else {\n            int j=i;\n            for(;j<n&&s[j]=='S';j++);\n            if((j-i)%2) res.pb(0);\n            i=j;\n        }\n    }\n    if(s.back()=='S') res.pop_back();\n    return res;\n}\n\nchar rev(char c) {\n    if(c>'0') return '0'+(3-(c-'0'));\n    return c;\n}\nstring rev(string s) {\n    for(auto & c:s) c=rev(c);\n    return s;\n}\n\nint len(string & s) {\n    int res=s.size();\n    while(res>0&&s[res-1]=='0') res--;\n    return res;\n}\n\nvi cal(vi inst, int n, int tot) {\n    vector<string> iinst;\n    for(auto x:inst) iinst.pb(to_ter(x,n));\n    vi res(tot);\n    map<string, string> dp,dp1;\n    rep(i,0,tot) {\n        string cur=to_ter(i,n);\n        int ok=0;\n        rep(j,0,n) {\n            string cur1=cur.substr(0,j+1)+string(n-j-1,'0');\n            if(dp1.count(cur1)&&len(dp1[cur1])<=j+1) {\n                cur1=dp1[cur1];\n                if(inst.size()%2) {\n                    rep(jj,j+1,n) cur1[jj]=rev(cur[jj]);\n                }\n                // dp[cur]=cur1;\n                ok=1;\n                res[i]=to_int(cur1);\n                dp1[cur]=cur1;\n                break;\n            }\n        }\n        if(!ok) {\n            string cur1=cur;\n            bool ok=true;\n            for(auto x:iinst) {\n                // print(cur1,to_ter(x,n));\n                ok=add(cur1,x)&&ok;\n                // print(cur1,to_ter(x,n));\n                for(auto & c:cur1) c=rev(c);\n            }\n            // dp[cur]=cur1;\n            res[i]=to_int(cur1);\n            if(ok) dp1[cur]=cur1;\n            // print(cur,cur1);\n        }\n        // res[i]=to_int(dp[cur]);\n        print(i,cur,res[i],dp[cur]);\n        // print(res[i],dp[cur]);  \n    }\n    print(inst,res);\n    print(dp);\n    print(dp1);\n    return res;\n}\n\nint main(int argc, char * argv[]) {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    // solve_testcase;\n\n    int n;\n    string s;\n    cin>>n;\n    cin>>s;\n    int tot=1;\n    rep(i,0,n) tot*=3;\n\n    vi inst=cal_inst(s);\n    for(auto & x:inst) x%=tot;\n\n    print(inst);\n\n    int i=0;\n    int bound=3*3*3*3*3*3*3;\n    vi res(tot);\n    iota(all(res),0);\n    while(i<inst.size()) {\n        int cur=inst[i];\n        vi cur_inst({cur});\n        for(++i;i<inst.size()&&cur+inst[i]<bound;i++) {\n            cur+=inst[i];\n            cur_inst.pb(cur);\n        }\n        vi tmp=cal(inst,n,tot);\n        // print(tmp);\n        rep(j,0,tot) res[j]=tmp[res[j]];\n        print(res);\n    }\n    if(s.back()=='R') {\n        rep(i,0,tot) {\n            res[i]=to_int(rev(to_ter(res[i],n)));\n        }\n    }\n    for(auto x:res) cout<<x<<' ';\n    cout<<endl;\n\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#define int long long\n \n#define pii pair<int, int>\n \n#define x1 x1228\n#define y1 y1228\n \n#define left left228\n#define right right228\n \n#define next next228\n \n#define pb push_back\n#define eb emplace_back\n \n#define mp make_pair                                                                \n                                                                                                                                        \n#define ff first                                                                  \n#define ss second   \n \n#define all(x) x.begin(), x.end()\n#define debug(x) cout << #x << \": \" << x << endl; \n#define TIME (ld)clock()/CLOCKS_PER_SEC\n \nusing namespace std;\ntypedef long long ll; \ntypedef long double ld; \n                                                                                                   \nconst int maxn = 2e5 + 7, mod = 1e9 + 7, MAXN = 1e6 + 7;\nconst double eps = 1e-9;\nconst ll inf = 1e18;\nmt19937 rnd(time(0));\nint n; \nstring s; \nint next[MAXN];\nconst int N = 2187; \nint dp1[N]; \nint dp2[N]; \nint xyz[N]; \n \nint get1(int mask, char q) {\n    if (q == 'R') {\n        ++mask; \n        return mask; \n    }   \n    int ptr = 1; \n    int ans = 0; \n    while (mask) {\n        int t = mask % 3; \n        mask /= 3; \n        if (t == 2) ans += ptr; \n        if (t == 1) ans += 2 * ptr; \n        ptr *= 3; \n    }\n    return ans; \n}\n \nconst int L = 12; \nint pref[maxn]; \nint to[maxn]; \nint kek1[N], kek2[N]; \nint res[N], res1[N]; \nint add = 1; \n \nint get(int x) {\n    vector<int> bts; \n    for (int i = 0; i < L; ++i) {\n        bts.pb(x % 3); \n        x /= 3; \n    }\n    int left = 0;\n    int right = 0; \n    for (int i = 6; i >= 0; --i) {\n        left *= 3;\n        left += bts[i]; \n    }\n    for (int i = L - 1; i >= 7; --i) {\n        right *= 3; \n        right += bts[i]; \n    }\n    int id = 0;         \n    if (left && dp1[left] == -1) {\n        if (pref[(int)s.size()] & 1) {\n            right++; \n            right = xyz[right];   \n        }\n        return res[left] + add * right;   \n    }\n    if (left) {    \n        id = dp1[left]; \n        if (pref[id] & 1) {\n            ++right;\n            right = xyz[right];             \n        }\n        left = 0; \n    }                     \n    while (next[id] != -1) {        \n        if ((pref[next[id]] - pref[id]) & 1) {\n            right++; \n            right = xyz[right]; \n        }\n        id = next[id];                                                                                                                                         \n    }\n    if ((pref[(int)s.size()] - pref[id]) & 1) {        \n        right++;         \n        right = xyz[right];     \n    }\n    left = to[id]; \n    return left + right * add; \n}\n \nvoid solve() {\n    for (int i = 0; i < N; ++i) {\n        xyz[i] = get1(i, 'S') % N; \n    }\n    cin >> n >> s; \n    int t = s.size(); \n    for (int i = 0; i < t; ++i) {\n        pref[i + 1] = pref[i] + (s[i] == 'S'); \n    }\n \n    for (int i = 0; i < N; ++i) dp1[i] = dp2[i] = -1; \n    next[t] = -1;\n    for (int i = 0; i < N; ++i) kek1[i] = i;              \n    for (int i = 0; i < N; ++i) res[i] = i; \n    for (int i = t - 1; i >= 0; --i) {\n        for (int mask = 0; mask < N; ++mask) {\n            int mask1; \n            if (s[i] == 'S') mask1 = xyz[mask]; \n            else mask1 = mask + 1; \n            if (mask1 >= N) mask1 -= N; \n            res1[mask] = res[mask1]; \n            kek2[mask] = kek1[mask1];\n            if (mask && mask1 == 0) {\n                dp2[mask] = i + 1; \n            } else {\n                dp2[mask] = dp1[mask1]; \n            }                                                                                 \n        }\n        to[i] = kek2[0]; \n        next[i] = dp2[0]; \n        for (int mask = 0; mask < N; ++mask) {\n            res[mask] = res1[mask]; \n            kek1[mask] = kek2[mask]; \n            dp1[mask] = dp2[mask]; \n            dp2[mask] = -1; \n        }\n    }\n    for (int i = 0; i < 7; ++i) add *= 3; \n    int tet = 1; \n    for (int i = 0; i < n; ++i) tet *= 3; \n    for (int ptr = 0; ptr < tet; ++ptr) {\n        cout << get(ptr) % tet << \" \"; \n    }\n//    cout << TIME; \n    return; \n}                                \n   \nsigned main() {\n#ifdef LOCAL\n    freopen(\"TASK.in\", \"r\", stdin);\n    freopen(\"TASK.out\", \"w\", stdout);\n#else \n    \n#endif // LOCAL\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20); \n    cout << fixed; \n    int t = 1; \n    for (int i = 0; i < t; ++i) {              \n        solve();\n    }\n    return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n\nint n, pw3[20], ans[531450];\nstring T;\n\nstring reduce(string T){\n\tstring res = \"\";\n\tfor(auto ch:T){\n\t\tif(res.size() && res.back()=='S' && ch=='S')\n\t\t\tres.pop_back();\n\t\telse res += ch;\n\t}\n\treturn res;\n}\n\nvoid solve(int m, string T, int i, int p){\n\tif(m==n) {ans[i] = p; return;}\n\trep(d,0,2){\n\t\tstring nextT = \"\";\n\t\tint x = d;\n\t\tfor(auto ch:T){\n\t\t\tif(ch=='S'){\n\t\t\t\tx = (3-x)%3;\n\t\t\t\tnextT += 'S';\n\t\t\t}else{\n\t\t\t\tx = (x+1)%3;\n\t\t\t\tif(x==0) nextT += 'R';\n\t\t\t}\n\t\t}\n\t\tsolve(m+1, reduce(nextT), i+d*pw3[m], p+x*pw3[m]);\n\t}\n}\n\nint main() {\n\tcin>>n>>T;\n\tpw3[0] = 1;\n\trep(i,1,n) pw3[i] = pw3[i-1] * 3;\n\t\n\tsolve(0, reduce(T), 0, 0);\n\t\n\trep(i,0,pw3[n]-1) printf(\"%d \", ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n \nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n\n#define MOD 1000000007LL\n\nint N;\nstring T;\nvector<int> p1,p2;\n//map<int, int> sa;\nvector<int> sa;\nint sp;\nint tn;\nint os;\n\nint conv(int);\nint tri(int n) {\n  int ans=1;\n  for (int i=0; i<n; i++) ans *= 3;\n  return ans;\n}\n\nvoid salsa();\nvoid rumba();\nvoid print_res();\nvoid print_ln();\n\nint main()\n{\n  int l;\n  int i;\n\n  cin >> N >> T;\n  tn = tri(N);\n\n  p1.resize(tn);\n  p2.resize(tn);\n  sa.resize(tn);\n  for (int i=0; i<tn; i++) {\n    p1[i] = i;\n  }\n  sa[0] = 0; sa[1] = 2; sa[2]=1;\n  {\n    int t=3;\n    int cv;\n    for (int i=3; i<tn; i++) {\n      if (i>=t*3) t *= 3;\n      cv = sa[i%t];\n      switch(i/t) {\n      case 1: cv += t*2; break;\n      case 2: cv += t; break;\n      }\n      sa[i] = cv;\n    }\n  }\n//for (int i=0; i<tn; i++) printf(\"sa[%d]=%d\\n\", i, sa[i]);\n  p2[0] = p1[0];\n  sp = 1;\n\n//print_ln();\n\n  l = T.size();\n  for (i=0; i<l; i++) {\n    if (T[i] == 'S') {\n      salsa();\n//printf(\"S \");\n//print_ln();\n    } else {\n      os+=tn-1;\n      os%=tn;\n//      rumba();\n//printf(\"R \");\n//print_ln();\n    }\n  }\n\n  print_res();\n\n  return 0;\n}\nint conv(int inp) {\n  int cv=0;\n  int fx;\n  int t;\n\n  fx = inp;\n  for (t=1; t<inp; ) t*=3;\n  t/=3;\n  cv += sa[inp%t];\n  fx /= t;\n\n  for (; fx>0; t*=3) {\n    switch(fx % 3) {\n    case 1: cv += 2*t; break;\n    case 2: cv += t; break;\n    }\n    fx /= 3;\n  }\n  return cv;\n}\n\nvoid salsa() {\n  int i;\n\n  if (sp==1) {\n    for (i=0; i<tn; i++) {\n      p2[(sa[i]+os)%tn] = p1[(i+os)%tn];\n    }\n    sp = 2;\n  } else {\n    for (i=0; i<tn; i++) {\n      p1[(sa[i]+os)%tn] = p2[(i+os)%tn];\n    }\n    sp = 1;\n  }\n}\nvoid rumba() {\n  int i;\n  if (sp==1) {\n    for (i=0; i<tn-1; i++) {\n      p2[i+1]=p1[i];\n    }\n    p2[0] = p1[tn-1];\n    sp = 2;\n  } else {\n    for (i=0; i<tn-1; i++) {\n      p1[i+1]=p2[i];\n    }\n    p1[0] = p2[tn-1];\n    sp = 1;\n  }\n}\n\nvoid print_ln() {\n  int i;\n  if (sp == 1) {\n    printf(\"%d\", p1[0]);\n    for (i=1; i<tn; i++) printf(\" %d\", p1[i]);\n  } else {\n    printf(\"%d\", p2[0]);\n    for (i=1; i<tn; i++) printf(\" %d\", p2[i]);\n  }\n  printf(\"\\n\");\n}\nvoid print_res() {\n  int i;\n  map<int, int> m;\n  if (sp == 1) {\n    for (i=0; i<tn; i++)  m.emplace(p1[(i+os)%tn], i);\n  } else {\n    for (i=0; i<tn; i++)  m.emplace(p2[(i+os)%tn], i);\n  }\n  auto it=m.begin();\n  printf(\"%d\", it->second);\n  for (it++; it!=m.end(); it++) {\n    printf(\" %d\", it->second);\n  }\n  printf(\"\\n\");\n}\n/*\n  a*3^3+b*3^2+c*3+d\n  */\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include<limits.h>\n#include<utility>\n#include<vector>\n#include<tuple>\n#include <map>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define ALL(A) A.begin(),A.end()\n\n\nint main() {\n\tint n;\n\tstring t;\n\tcin >> n >> t;\n\tint N = 1;\n\tint a3[13];\n\ta3[0] = 1;\n\trep(i, n) {\n\t\ta3[i + 1] = a3[i]*3;\n\t}\n\tN = a3[n];\n\tvector<int> S(N);\n\tvector<int> person(N);\n\trep(i, N) {\n\t\tperson[i] = i;\n\t\tif (i == 0) {\n\t\t\tS[i] = i;\n\t\t\tcontinue;\n\t\t}\n\t\tint a=0;\n\t\tint m = 0;\n\t\tint I = i;\n\t\twhile (I != 0) {\n\t\t\tint am = I % 3;\n\t\t\tif (am == 1) {\n\t\t\t\tam = 2;\n\t\t\t}\n\t\t\telse if (am == 2) {\n\t\t\t\tam = 1;\n\t\t\t}\n\t\t\ta += am * a3[m];\n\t\t\tI /= 3;\n\t\t\tm++;\n\t\t}\n\t\tS[i] = a;\n\t\t\n\t}\n\twhile(t.find(\"SS\")!=string::npos) {\n\t\tt.erase(t.find(\"SS\"), 2);\n\t}\n\tint r = 0;\n\tint o[N];\n\tfor (int i = 0; i < t.size(); i++) {\n\t\tif (t[i] == 'S') {\n\t\t\trep(j, N) {\n\t\t\t\tperson[j]+=r;\n\t\t\t\tperson[j] %= N;\n\t\t\t\tperson[j] = S[person[j]];\n\t\t\t}\n\t\t\tr = 0;\n\t\t}\n\t\tif (t[i] == 'R') {\n\t\t\tr++;\n\t\t}\n\t\t\n\t}\n\trep(i, N) {\n\t\tif (t[t.size() - 1] == 'R') {\n\t\t\tperson[i] = (person[i] + r) % N;\n\t\t\tcout << person[i]<<\" \";\n\t\t}\n\t\telse {\n\t\t\tcout << person[i]<<\" \";\n\t\t}\n\t\t\n\t}\n\tcout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<ll,ll>\n#define poly vector<ll>\n#define mem(a) memset((a),0,sizeof(a))\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\n#define SZ(x) ((int)(x.size()))\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int M=1e6;\nint n,pw[15],lzy[M],ch[M][3],ans[M],to[M];\nvoid dfs(int p,int de,int su,int a){\n\tif(p>=pw[n-1]){\n\t\t//cout<<p-pw[n-1]<<\" \"<<su<<endl;\n\t\tans[p-pw[n-1]]=su; to[a]=su; return;\n\t}\n\tFor(i,0,2)dfs(ch[p][i],de*3,su+de*i,a*3+i);\n}\ninline void cao(int x){\n\tlzy[x]^=1; swap(ch[x][1],ch[x][2]);\n}\nint main(){\n\t#ifdef Brollan\n\t\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tn=read();\n\tFor(i,pw[0]=1,n)pw[i]=pw[i-1]*3; \n\tFor(i,1,n)pw[i]+=pw[i-1];\n\tFor(i,0,pw[n]-1){\n\t\tFor(j,0,2)ch[i][j]=i*3+j+1;\n\t}\n\tstring s;\n\tcin>>s;\n\tfor(auto i:s)if(i=='S'){\n\t\tcao(0);\n\t\t//cout<<ch[0][0]<<\" \"<<ch[0][1]<<\" \"<<ch[0][2]<<endl;\n\t}else{\n\t\tint dq=0;\n\t\tFor(j,0,n-1){\n\t\t\tif(lzy[dq]){\n\t\t\t\tlzy[dq]=0;\n\t\t\t\tFor(k,0,2)cao(ch[dq][k]);\n\t\t\t}\n\t\t\tint t=ch[dq][2]; ch[dq][2]=ch[dq][1]; ch[dq][1]=ch[dq][0]; ch[dq][0]=t;\n\t\t\tdq=ch[dq][0]; \n\t\t}\n\t\t//cout<<ch[0][0]<<\" \"<<ch[0][1]<<\" \"<<ch[0][2]<<endl;\n\t}\n\tdfs(0,1,0,0);\n\tFor(i,0,pw[n]-pw[n-1]-1)wri(ans[to[i]]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n// #include <ext/pb_ds/assoc_container.hpp> \n// #include <ext/pb_ds/detail/standard_policies.hpp>\n// using namespace __gnu_pbds;\n\n#pragma GCC optimize(\"O3\")\n#ifdef LOCAL\n#include \"/Users/lbjlc/Desktop/coding/debug_utils.h\"\n#else\n#define print(...) ;\n#define printn(...) ;\n#define fprint(...) ;\n#define fprintn(...) ;\n#endif\n\n#define rep(i, a, b) for(auto i = (a); i < (b); i++)\n#define rrep(i, a, b) for(auto i = (a); i > (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define pb push_back\n// #define mp make_pair\n#define fi first\n#define se second\n#define maxi(x, y) x = max(x, y)\n#define mini(x, y) x = min(x, y)\n// long long fact(long long n) { if(!n) return 1; return n*fact(n-1); }\n// #define endl '\\n'\n#define solve_testcase int T;cin>>T;for(int t=1;t<=T;t++){solve(t);}\n\n// long long gcd(long long x, long long y) { return y ? gcd(y, x % y) : x; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\n \ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n \ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\ntypedef vector<long long> vll;\n#define bd(type,op,val) bind(op<type>(), std::placeholders::_1, val)\n\nconst int MAXN = 1e6+10;\n\n\nvoid solve(int tt) {\n    // cout<<\"Case #\"<<tt<<\": \";\n}\n\nstring to_ter(int x, int k=-1) {\n    string res;\n    while(x) {\n        res+='0'+x%3;\n        x/=3;\n    }\n    if(k>=0) {\n        while(res.size()<k) res+='0';\n    }\n    return res;\n}\nint to_int(const string & s) {\n    int res=0;\n    // rrep(i,s.size()-1,-1)\n    //     res=res*3+(s[i]-'0');\n    for(int i=s.size()-1;i>=0;i--)\n        res=res*3+(s[i]-'0');\n    // print(s,res);\n    return res;\n}\nbool add(string & x, const string & y) {\n    int n1=x.size(), n2=y.size(),carry=0;\n    rep(i,0,n1) {\n        if(i<n1) carry+=x[i]-'0';\n        if(i<n2) carry+=y[i]-'0';\n        x[i]=carry%3+'0';\n        carry/=3;\n    }\n    return carry==0;\n}\n\nvi cal_inst(string & s) {\n    int n=s.size();\n    vi res(1);\n    int i=0;\n    while(i<n) {\n        if(s[i]=='R') {\n            res.back()++;\n            i++;\n        }\n        else {\n            int j=i;\n            for(;j<n&&s[j]=='S';j++);\n            if((j-i)%2) res.pb(0);\n            i=j;\n        }\n    }\n    if(s.back()=='S') res.pop_back();\n    return res;\n}\n\nchar rev(char c) {\n    if(c>'0') return '0'+(3-(c-'0'));\n    return c;\n}\nstring rev(string s) {\n    for(auto & c:s) c=rev(c);\n    return s;\n}\n\nint len(string & s) {\n    int res=s.size()-1;\n    while(res>=0&&s[res]=='0') res--;\n    return res+1;\n}\n\nint power[13]={};\nint revmap[MAXN]={};\nint tmpres[MAXN];\nint rev(int x) {\n    for(int flag=1;flag<power[12];flag*=3) {\n        int tmp=x/flag%3;\n        if(tmp==1) x+=flag;\n        else if(tmp==2) x-=flag;\n    }\n    return x;\n}\n\nvoid cal(vi inst, int n, int tot) {\n    // vi tmpres(tot,-1);\n    fill(tmpres,tmpres+tot,-1);\n\n    rep(i,0,tot) {\n        if(tmpres[i]>=0) continue;\n\n        int cur=i,ok=1;\n        for(auto x:inst) {\n            cur+=x;\n            if(cur>=power[n]) {\n                ok=0; \n                cur%=power[n];\n            }\n            cur=revmap[cur];\n        }\n        // if(i<=9) print(i,cur);\n        tmpres[i]=cur;\n        // assert(cur>=0);\n        if(!ok) continue;\n        int flag=1,tmp;\n        for(;flag<=i||flag<=cur;flag*=3);\n\n        if(inst.size()%2==0) {\n            for(tmp=flag;tmp<power[n];tmp+=flag) {\n                tmpres[tmp+i]=tmp+cur;\n            }\n        }\n        else {\n            for(tmp=flag;tmp<power[n];tmp+=flag) {\n                tmpres[tmp+i]=revmap[tmp]+cur;\n            }\n\n        }\n    }\n    // print(1);\n    // print(*max_element(all(res)),*min_element(all(res)));\n    // return res;\n}\n\nint main(int argc, char * argv[]) {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    // solve_testcase;\n\n    int n;\n    string s;\n    cin>>n;\n    cin>>s;\n\n    // n=12;\n    // rep(i,0,1e5) s+=\"RS\";\n\n    power[0]=1;\n    rep(i,1,13) power[i]=power[i-1]*3;\n\n    int tot=1;\n    rep(i,0,n) tot*=3;\n\n    rep(i,0,tot) revmap[i]=rev(i);\n    // printn(revmap,9);\n\n\n    vi inst=cal_inst(s);\n    for(auto & x:inst) x%=tot;\n\n    // print(inst);\n\n    int i=0;\n    int bound=241;\n    vi res(tot);\n    iota(all(res),0);\n    while(i<inst.size()) {\n        int cur=inst[i];\n        vi cur_inst({cur});\n        for(++i;i<inst.size()&&cur+inst[i]<bound;i++) {\n            cur+=inst[i];\n            cur_inst.pb(inst[i]);\n        }\n        cal(cur_inst,n,tot);\n        // print(tmp);\n        rep(j,0,tot) res[j]=tmpres[res[j]];\n        // print(cur_inst,tmp);\n        // print(res);\n        // sort(all(tmp)); print(tmp);\n    }\n    if(s.back()=='R') {\n        rep(i,0,tot) {\n            res[i]=revmap[res[i]];\n        }\n    }\n    for(auto x:res) cout<<x<<' ';\n    cout<<endl;\n\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define cs const\n#define pb push_back\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define ll long long\n#define bg begin\nnamespace IO{\n\t\ncs int RLEN=1<<20|1;\nchar ibuf[RLEN],*ib,*ob;\ninline char gc(){\n\t(ib==ob)&&(ob=(ib=ibuf)+fread(ibuf,1,RLEN,stdin));\n\treturn (ib==ob)?EOF:*ib++;\n}\ninline int read(){\n\tchar ch=gc();\n\tint res=0;bool f=1;\n\twhile(!isdigit(ch))f^=ch=='-',ch=gc();\n\twhile(isdigit(ch))res=(res*10)+(ch^48),ch=gc();\n\treturn f?res:-res;\n}\ninline int readstring(char *s){\n\tint top=0;char ch=gc();\n\twhile(isspace(ch))ch=gc();\n\twhile(!isspace(ch)&&ch!=EOF)s[++top]=ch,ch=gc();\n\treturn top;\n}\n\n}\nusing IO::read;\nusing IO::readstring;\ntemplate<typename tp>inline void chemx(tp &a,tp b){a=max(a,b);}\ntemplate<typename tp>inline void chemn(tp &a,tp b){a=min(a,b);}\ncs int N=1000005,M=16;\nint pw[M];\nchar str[N];\nint n,m,tot,id[N],ans[N],lc[N],rc[N],pc[N],rev[N];\nvoid build(int &u,int dep,int ps){\n\tu=++tot;\n\tif(dep==n){\n\t\tid[u]=ps;\n\t\treturn;\n\t}\n\tbuild(lc[u],dep+1,ps);\n\tbuild(rc[u],dep+1,ps+pw[dep]);\n\tbuild(pc[u],dep+1,ps+2*pw[dep]);\n}\nvoid pushnow(int u){\n\trev[u]^=1,swap(rc[u],pc[u]);\n}\nvoid pushdown(int u){\n\tif(!rev[u])return;\n\tif(lc[u])pushnow(lc[u]);\n\tif(rc[u])pushnow(rc[u]);\n\tif(pc[u])pushnow(pc[u]);\n\trev[u]=0;\n}\nvoid move(int u,int dep){\n\tpushdown(u);\n\tif(dep==n)return;\n\tswap(rc[u],pc[u]),swap(rc[u],lc[u]);\n\tmove(lc[u],dep+1);\n}\nvoid dfs(int u,int dep,int ps){\n\tpushdown(u);\n\tif(dep==n){ans[id[u]]=ps;return;}\n\tdfs(lc[u],dep+1,ps);\n\tdfs(rc[u],dep+1,ps+pw[dep]);\n\tdfs(pc[u],dep+1,ps+2*pw[dep]);\n}\nint main(){\n\t#ifdef Stargazer\n\tfreopen(\"lx.in\",\"r\",stdin);\n\t#endif\n\tn=read();pw[0]=1;int rt=0;\n\tm=readstring(str);\n\tfor(int i=1;i<M;i++)pw[i]=pw[i-1]*3;\n\tbuild(rt,0,0);\n\tfor(int i=1;i<=m;i++)\n\tif(str[i]=='S')pushnow(rt);\n\telse move(rt,0);\n\tdfs(rt,0,0);\n\tfor(int i=0;i<pw[n];i++)cout<<ans[i]<<\" \";puts(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst int maxn=888888;\n#define MP make_pair\n#define PB push_back\n#define lson o<<1,l,mid\n#define rson o<<1|1,mid+1,r\n#define FOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define ROF(i,a,b) for(int i=(a);i>=(b);i--)\n#define MEM(x,v) memset(x,v,sizeof(x))\ninline ll read(){\n\tchar ch=getchar();ll x=0,f=0;\n\twhile(ch<'0' || ch>'9') f|=ch=='-',ch=getchar();\n\twhile(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn f?-x:x;\n}\nint n,m,q,rt,cnt,ch[maxn][3],id[maxn],ans[maxn];\nbool rev[maxn];\nchar s[maxn];\ninline void setrev(int x){\n\trev[x]^=1;\n\tswap(ch[x][1],ch[x][2]);\n}\ninline void pushdown(int x){\n\tif(rev[x]){\n\t\tif(ch[x][0]) setrev(ch[x][0]);\n\t\tif(ch[x][1]) setrev(ch[x][1]);\n\t\tif(ch[x][2]) setrev(ch[x][2]);\n\t\trev[x]=false;\n\t}\n}\nvoid build(int &x,int dep,int cur,int pr){\n\tx=++cnt;\n\tif(dep==n){\n\t\tid[x]=cur;\n\t\treturn;\n\t}\n\tbuild(ch[x][0],dep+1,cur,pr*3);\n\tbuild(ch[x][1],dep+1,cur+pr,pr*3);\n\tbuild(ch[x][2],dep+1,cur+pr*2,pr*3);\n}\nvoid add(int x,int dep){\n\tpushdown(x);\n\tif(dep==n) return;\n\tswap(ch[x][1],ch[x][2]);\n\tswap(ch[x][0],ch[x][1]);\n\tadd(ch[x][0],dep+1);\n}\nvoid dfs(int x,int dep,int cur,int pr){\n\tpushdown(x);\n\tif(dep==n){\n\t\tans[id[x]]=cur;\n\t\treturn;\n\t}\n\tdfs(ch[x][0],dep+1,cur,pr*3);\n\tdfs(ch[x][1],dep+1,cur+pr,pr*3);\n\tdfs(ch[x][2],dep+1,cur+pr*2,pr*3);\n}\nint main(){\n\tn=read();\n\tbuild(rt,0,0,1);\n\tscanf(\"%s\",s+1);\n\tq=strlen(s+1);\n\tFOR(i,1,q) if(s[i]=='S') setrev(rt);\n\telse add(rt,0);\n\tdfs(rt,0,0,1);\n\tm=1;\n\tFOR(i,1,n) m*=3;\n\tFOR(i,0,m-1) printf(\"%d \",ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define endl '\\n'\n#define fi first\n#define se second\n#define MOD(n,k) ( ( ((n) % (k)) + (k) ) % (k))\n#define forn(i,n) for (int i = 0; i < n; i++)\n#define forr(i,a,b) for (int i = a; i <= b; i++)\n#define all(v) v.begin(), v.end()\n#define pb(x) push_back(x)\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ii> vii;\n\nconst int MX = 600005;\nint n, p[13][MX], fin[13][MX], res[MX];\nstring t;\n\nvoid go (int i, int m) {\n\tvector<vi> a(3, vi(m));\n\n\tforn (j, 3 * m) a[j / m][j % m] = j / m;\n\n\tfin[i][0] = 3 * m - 1;\n\n\tforn (j, t.size()) {\n\t\tif (t[j] == 'S') {\n\t\t\tswap(a[1], a[2]);\n\t\t} else {\n\t\t\tvi aux(3);\n\t\t\tforn (k, 3) aux[k] = a[k][fin[i - 1][j]];\n\t\t\tforn (k, 3) a[(k + 1) % 3][fin[i - 1][j]] = aux[k];\n\t\t}\n\n\t\tfin[i][j + 1] = fin[i - 1][j + 1] + m * a[2][fin[i - 1][j + 1]];\n\t}\n\n\tforn (j, 3 * m) p[i][j] = p[i - 1][j % m] + m * a[j / m][p[i - 1][j % m]];\n}\n\nint main () {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\t\n\tcin >> n >> t;\n\n\tiota(p[0], p[0] + 3, 0);\n\n\tfin[0][0] = 2;\n\tforn (i, t.size()) {\n\t\tswap(p[0][1], p[0][2]);\n\t\tif (t[i] == 'R') swap(p[0][0], p[0][1]);\n\t\tfin[0][i + 1] = p[0][2];\n\t}\n\n\tint m = 3;\n\tfor (int i = 1; i < n; i++, m *= 3)\n\t\tgo(i, m);\n\n\tforn (i, m) res[p[n - 1][i]] = i;\n\n\tforn (i, m) cout << res[i] << \" \";\n\tcout << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int64_t N;\n  cin >> N;\n  string T;\n  cin >> T;\n  \n  int num = pow(3,N);\n  vector<int> M(pow(3,N));\n  vector<int64_t> pos(pow(3,N));\n  for(int i=0;i<pow(3,N);i++){\n    if(M.at(i)!=0)\n      continue;\n    int c = 0;\n    int val = i;\n    int pc=1;\n    for(int j=0;j<N;j++){\n      int v = val%3;\n      val = val/3;\n      if(v==1)\n        c+=pc;\n      else if(v==2)\n        c-=pc;\n      pc*=3;\n    }\n    M.at(i) = c-i;\n    if(c>i)\n      M.at(c) = i-c;\n  }\n  bool f=false;\n  for(int i=0;i<T.size();i++){\n    if(T.at(i) = 'R'){\n      //move and check t\n      for(auto n:pos)\n        n++;\n      if(f){\n        for(int j=0;j<pos.size();j++)\n          pos.at(j)+=M.at(pos.at(j));\n        f=false;\n      }\n    }else{\n      if(f)\n        f=false;\n      else\n        f=true;\n    }\n  }\n  if(f){\n    for(int j=0;j<pos.size();j++)\n      pos.at(j)+=M.at(pos.at(j));\n    f=false;\n  }\n  for(int i=0;i<pos.size();i++){\n    int64_t n = pos.at(i);\n    while(n<0)\n      n += num;\n    cout << (n%num);\n  }\n  cout << endl;\n}\n      \n    \n  \n  "
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,o,p,x,y,pos,pw3[13]={1},A[1000001],salsa[600000],sw[1000001];\nchar T[1000001];\nvoid OUT(int x){if(x<0)putchar('-'),x=-x;if(x>=10)OUT(x/10);putchar(x%10+48);}\nvoid Dance(char c[])\n{\n  if(c[p]==EOF)return;\n  if(c[p]=='S'){x=salsa[x];if(sw[pos]>0)pos--;else sw[++pos]=1;}\n  if(c[p]=='R'){x++;if(x==pw3[N/2])sw[++pos]=-1,x=0;}\n}\nvoid Update(void)\n{\n  rep(i,pw3[N-N/2])\n  {\n    y=i;\n    rep(j,pos){if(sw[j+1]>0)y=salsa[y];else if(sw[j+1]<0){if((++y)==pw3[N-N/2])y=0;}}\n    A[o+i*pw3[N/2]]=y*pw3[N/2]+x;\n  }\n}\nsigned main(void)\n{\n  o=scanf(\"%d %s\",&N,T+1);\n  rep(i,N)pw3[i+1]=3*pw3[i];\n  rep(i,pw3[N])salsa[i]=salsa[i/3]*3+(3-i%3)%3;\n  rep(i,pw3[N/2]){o=i,x=i,pos=0;rep(j,strlen(T+1)){p=j+1,Dance(T);}Update();}\n  rep(i,pw3[N])OUT(A[i]),putchar(' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<math.h>\nusing namespace std;\n\n#define jaldi ios_base::sync_with_stdio(false)\n#define si(x) scanf(\"%d\",&x)\n#define sl(x) scanf(\"%ld\",&x)\n#define sll(x) scanf(\"%lld\",&x)\n#define sc(x) scanf(\"%c\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define pi(x) printf(\"%d\",x)\n#define pl(x) printf(\"%ld\",x)\n#define pll(x) printf(\"%lld\",x)\n#define pc(x) printf(\"%c\",x)\n#define ps(x) printf(\"%s\",x)\n#define vi vector<int> \n#define vl vector<long> \n#define vll vector<long long>\n#define vc vector<char>  \n#define vs vector<string>\n#define vvi vector<vector<int>> \n#define vvll vector<vector<long long>> \n#define F first\n#define S second\n#define ll long long\n#define pb push_back\n#define PI 3.1415926535897932384626\n#define precision(x) cout<<fixed<<setprecision(x) \n#define all(x) x.begin(),x.end()\n#define mod 1000000007\n\nint x_d[8] = {-1,1,0,0,-1,-1,1,1};\nint y_d[8] = {0,0,-1,1,-1,1,-1,1};\n\nll power(ll b,ll e)\n{\n    if(b==0)\n        return 0;\n    \n    ll r=1;\n    while(e>0)\n    {\n        if(e%2)\n            r=(r*b)%mod;\n        b=(b*b)%mod;\n        e/=2;\n    }\n    return r;\n}\nll root(ll a,vll &head)\n{\n    while(a!=head[a])\n    {\n        head[a]=head[head[a]];\n        a=head[a];\n    }\n    return a;\n}\nvoid merge(ll a,ll b,vll &head, vll &size)\n{\n    ll p_a = root(a,head);\n    ll p_b = root(b,head);\n    if(p_a==p_b)\n        return;\n    \n    if(size[p_a]>size[p_b])\n    {\n        size[p_a]+=size[p_b];\n        head[p_b]=head[p_a];\n    }\n    else\n    {\n        size[p_b]+=size[p_a];\n        head[p_a]=head[p_b];\n    }\n    \n}\n\nint main()\n{\n    jaldi;\n    precision(6);\n    ll i,j;\n    ll t;\n    t=1;\n    // cin>>t;\n    while(t--)\n    {\n        ll n;\n        cin>>n;\n        string s;\n        cin>>s;\n        ll w=pow(3,n);\n        vll ans(w);\n        \n        for(i=0;i<w;i++)\n            ans[i]=i;\n        \n        for(i=0;i<s.size();i++)\n        {\n            if(s[i]=='S')\n            {\n                for(ll k=0;k<w;k++)\n                {\n                    ll no=ans[k];\n                    vll fn;\n                    while(no>0)\n                    {\n                        fn.pb(no%3);\n                        no/=3;\n                    }\n                    for(j=0;j<fn.size();j++)\n                    {\n                        if(fn[j]==1)\n                            fn[j]=2;\n                        else if(fn[j]==2)\n                            fn[j]=1;\n                    }\n                    ll on=0;\n                    for(j=0;j<fn.size();j++)\n                        on+=fn[j]*pow(3,j);\n                    ans[k]=on;\n                }\n            }\n            else\n            {\n                ll tt,prev;\n                prev=ans[0];\n                for(j=0;j<w;j++)\n                {\n                    // ll z=pow(3,n);\n                    ans[j]=(ans[j]+1)%w;\n                }\n            }\n        }\n        // cout<<s.size()<<\" \";\n        for(j=0;j<w;j++)\n            cout<<ans[j]<<\" \";\n        cout<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cassert>\n#include<stdexcept>\n#include<utility>\n#include<functional>\n#include<numeric>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<array>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<complex>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<bitset>\n#include<memory>\nusing namespace std;\nusing ll=long long;\n\nconst int SZ = 3;\nint n;\nint pow3n;\nvector<int> sal;\nvoid init_s(){\n    sal.resize(pow3n);\n    iota(sal.begin(),sal.end(),0);\n    for(int i=0;i<pow3n;i++){\n        int x = i;\n        int tar = 0;\n        int r = 1;\n        for(int j=0;j<n;j++){\n            tar+= (x%3*2)%3*r;\n            x/=3;\n            r*=3;\n        }\n        if(tar<i){\n            // cerr<<i<<\" \"<<tar<<endl;\n            swap(sal[tar],sal[i]);\n        }\n    }\n}\n\nint ary[1000000];\nvoid do_rx(vector<int>& pat,int t){\n    t = t%pow3n;\n    for(int i=t;i<pow3n;i++) ary[i] = pat[i-t];\n    for(int i=0;i<t;i++) ary[i] = pat[pow3n-t+i];\n    for(int i=0;i<pow3n;i++) pat[i] = ary[i];\n}\n\nvoid do_r(vector<int>& pat){\n    int head = pat[pow3n-1];\n    for(int i=pow3n-1;i>0;i--){\n        pat[i]=pat[i-1];\n    }\n    pat[0] = head;\n}\n\nvoid perm(vector<int>& pat,vector<int>& par){\n    for(int i=0;i<pow3n;i++) ary[i] = pat[par[i]];\n    for(int i=0;i<pow3n;i++) pat[i] = ary[i];\n}\nvoid do_s(vector<int>& pat){\n    perm(pat,sal);\n}\nint main(){\n    cin>>n;\n    pow3n=1;\n    for(int i=0;i<n;i++) pow3n*=3;\n    init_s();\n    \n    string t;\n    {\n        string tmp;\n        cin>>tmp;\n        for(auto c:tmp){\n            if(!t.empty() && t.back()=='S' && c=='S') t.pop_back();\n            else t+=c;\n        }\n    }\n\n    vector<vector<int>> memo(1<<SZ);\n    \n    for(int bit=0;bit<(1<<SZ);bit++){\n        bool ispass= false;\n        for(int j=0;j+1<SZ;j++){\n            if(((bit>>j)&1)==0 && ((bit>>(j+1)))==0) ispass=true;\n        }\n        if(ispass) continue;\n\n        memo[bit].resize(pow3n);\n        iota(memo[bit].begin(),memo[bit].end(),0);\n        for(int j=0;j<SZ;j++){\n            if(((bit>>j)&1)==0) do_s(memo[bit]);\n            else do_r(memo[bit]);\n        }\n    }\n    vector<int> res(pow3n);\n    iota(res.begin(),res.end(),0);\n    int l = 0;\n    while(t.size()-l>=SZ){\n        int r;\n        for(r=l;r<t.size();r++){\n            if(t[r]=='S') break;\n        }\n        if(r-l>=SZ){\n            do_rx(res,r-l);\n            l=r;\n        }\n        else{\n            int bit = 0;\n            for(int j=0;j<SZ;j++){\n                if(t[l+j]=='R') bit+=(1<<j);\n            }\n            perm(res,memo[bit]);\n            bit=0;\n            l+=SZ;\n        }\n    }\n\n    for(int i=l;i<t.size();i++){\n        // cerr<<\"#\"<<endl;\n        if(t[i]=='S') do_s(res);\n        else do_r(res);\n    }\n    vector<int> inv(pow3n);\n    for(int i=0;i<pow3n;i++) inv[res[i]]=i;\n    for(int i=0;i<pow3n;i++) cout<<inv[i]<<\" \";\n    cout<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nint n;\nchar s[201000];\nint m;\nstruct person {\n\tint kind; // 0 -> initially in pos-th position, 1 -> came in pos-th op\n\tint pos;\n};\nperson cameout[200100];\nperson respos[600100];\nperson ncameout[200100];\nperson nrespos[600000];\nperson camein[3][200100];\nint sz;\nint tsz;\nint ans[600100];\nperson refpos(int grp, person p) { // in : person 0~sz out : person 0~tsz\n\tif (p.kind == 0) {\n\t\tperson res;\n\t\tres.kind = 0;\n\t\tres.pos = grp * sz + p.pos;\n\t\treturn res;\n\t}\n\treturn camein[grp][p.pos];\n}\nvoid f(int dep) {\n\tif (dep == 0) {\n\t\tsz = 1;\n\t\trespos[0].kind = 0;\n\t\trespos[0].pos = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (s[i] == 'S')continue;\n\t\t\telse {\n\t\t\t\tcameout[i] = respos[0];\n\t\t\t\trespos[0].kind = 1;\n\t\t\t\trespos[0].pos = i;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tf(dep - 1);\n\ttsz = sz * 3;\n\tint salsan = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (s[i] == 'S') {\n\t\t\tsalsan++;\n\t\t}\n\t\telse {\n\t\t\tperson tin;\n\t\t\ttin.kind = 1;\n\t\t\ttin.pos = i;\n\t\t\tcamein[0][i] = tin;\n\t\t\tif (salsan % 2 == 0) {\n\t\t\t\tcamein[1][i] = refpos(0, cameout[i]);\n\t\t\t\tcamein[2][i] = refpos(1, cameout[i]);\n\t\t\t\tncameout[i] = refpos(2, cameout[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcamein[2][i] = refpos(0, cameout[i]);\n\t\t\t\tcamein[1][i] = refpos(2, cameout[i]);\n\t\t\t\tncameout[i] = refpos(1, cameout[i]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < sz; i++) {\n\t\tnrespos[i] = refpos(0, respos[i]);\n\t\tif (salsan % 2 == 0) {\n\t\t\tnrespos[sz + i] = refpos(1, respos[i]);\n\t\t\tnrespos[2 * sz + i] = refpos(2, respos[i]);\n\t\t}\n\t\telse {\n\t\t\tnrespos[2 * sz + i] = refpos(1, respos[i]);\n\t\t\tnrespos[sz + i] = refpos(2, respos[i]);\n\t\t}\n\t}\n\tsz = tsz;\n\tfor (int i = 0; i < sz; i++) {\n\t\trespos[i] = nrespos[i];\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tcameout[i] = ncameout[i];\n\t}\n\treturn;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", s);\n\tfor (m = 0; s[m]; m++);\n\tf(n);\n\tfor (int i = 0; i < m; i++) {\n\t\tcamein[0][i] = refpos(0, cameout[i]);\n\t}\n\tfor (int i = 0; i < sz; i++) {\n\t\trespos[i] = refpos(0, respos[i]);\n\t\tif (respos[0].kind == 1) {\n\t\t\tprintf(\"ERR!\");\n\t\t}\n\t\tans[respos[i].pos] = i;\n\t}\n\tfor (int i = 0; i < sz; i++) {\n\t\tprintf(\"%d \", ans[i]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//#pragma GCC target (\"avx2\")\n//#pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 729 + 10;\nint p[13];\nchar s[200000+10];\nint a[N][N],b[N],r[N],ans[N*N];\nint main(){\n    p[0] = 1; for(int i=1;i<13;i++) p[i] = p[i-1] * 3;\n    int n; scanf(\"%d%s\",&n,s);\n    int x = n / 2, y = n - x;\n    ///y: low, x: high\n    for(int i=0;i<p[6];i++){\n        int t = i;\n        for(int j=0;j<6;j++){\n            if(t/p[j]%3==1) t += p[j];\n            else if(t/p[j]%3==2) t -= p[j];\n        }\n        r[i] = t;\n        if(i>=r[i]) r[i] = 0;\n    }\n    for(int i=0;i<p[n];i++){\n        a[i%p[y]][i/p[y]] = i;\n    }\n    int R = 0;\n    for(int i=0;s[i];i++){\n        if(s[i]=='S'){\n            R ^= 1;\n            for(int j=0;j<p[y];j++) if(r[j]){\n                swap(a[j],a[r[j]]);\n                swap(b[j],b[r[j]]);\n            }\n        }\n        else{\n            for(int j=p[y]-1;j>0;j--){\n                swap(a[j],a[j-1]);\n                swap(b[j],b[j-1]);\n            }\n            if(b[0]^R){\n                for(int j=0;j<p[x];j++) if(r[j]) swap(a[0][j],a[0][r[j]]);\n                b[0] ^= 1;\n            }\n            for(int j=p[x]-1;j>0;j--){\n                swap(a[0][j],a[0][j-1]);\n            }\n        }\n    }\n    for(int i=0;i<p[y];i++) if(b[i]^R){\n        for(int j=0;j<p[x];j++) if(j<r[j]) swap(a[i][j],a[i][r[j]]);\n        b[i] ^= 1;\n    }\n    for(int i=0;i<p[n];i++) ans[a[i%p[y]][i/p[y]]] = i;\n    for(int i=0;i<p[n];i++) printf(\"%d%c\",ans[i],\" \\n\"[i==p[n]-1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define endl '\\n'\n#define fi first\n#define se second\n#define MOD(n,k) ( ( ((n) % (k)) + (k) ) % (k))\n#define forn(i,n) for (int i = 0; i < n; i++)\n#define forr(i,a,b) for (int i = a; i <= b; i++)\n#define all(v) v.begin(), v.end()\n#define pb(x) push_back(x)\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ii> vii;\n\nconst int MX = 600005;\nint n, p[13][MX], fin[13][MX], res[MX];\nstring t;\n\nvoid go (int i, int m) {\n\tvector<vi> a(3, vi(m));\n\n\tforn (j, 3 * m) a[j / m][j % m] = j;\n\n\tfin[i][0] = 3 * m - 1;\n\n\tforn (j, t.size()) {\n\t\tif (t[j] == 'S') {\n\t\t\tswap(a[1], a[2]);\n\t\t} else {\n\t\t\tvi aux(3);\n\t\t\tforn (k, 3) aux[k] = a[k][fin[i - 1][j]];\n\t\t\tforn (k, 3) a[(k + 1) % 3][fin[i - 1][j]] = aux[k];\n\t\t}\n\n\t\tfin[i][j + 1] = a[2][fin[i - 1][j + 1]];\n\t}\n\n\tforn (j, 3 * m) p[i][j] = a[j / m][p[i - 1][j % m]];\n}\n\nint main () {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\t\n\tcin >> n >> t;\n\n\tiota(p[0], p[0] + 3, 0);\n\n\tfin[0][0] = 2;\n\tforn (i, t.size()) {\n\t\tswap(p[0][1], p[0][2]);\n\t\tif (t[i] == 'R') swap(p[0][0], p[0][1]);\n\t\tfin[0][i + 1] = p[0][2];\n\t}\n\n\tint m = 3;\n\tfor (int i = 1; i < n; i++, m *= 3)\n\t\tgo(i, m);\n\n\tforn (i, m) res[p[n - 1][i]] = i;\n\n\tforn (i, m) cout << res[i] << \" \";\n\tcout << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint main(){\n  int N;\n  string T;\n  cin >> N >> T;\n  int pow3N = pow(3, N);\n  map<string, vector<int>> next;\n  next[\"S\"] = vector<int>(pow3N);\n  next[\"R\"] = vector<int>(pow3N);\n\n  for(int ii=0; ii<pow3N; ii++){\n    int tmp=ii;\n    int jj=0;\n    int aa=1;\n    while(tmp){\n      int kk = tmp % 3;\n      tmp = (tmp - kk) / 3;\n      if(kk==1){\n        kk=2;\n      }else if(kk==2){\n        kk=1;\n      }\n      jj+=kk*aa;\n      aa*=3;\n    }\n    next[\"S\"][ii] = jj;\n    next[\"R\"][ii] = ii+1;\n  }\n  next[\"R\"][pow3N-1] = 0;\n\n  set<string> pre = {\"S\", \"R\"};\n  int jj=1;\n  for(; jj<T.size(); jj*=2){\n    set<string> post;\n    for(auto& a : pre){\n      for(auto& b : pre){\n        post.insert(a+b);\n        next[a+b] = vector<int>(pow3N);\n        for(int ii=0; ii<pow3N; ii++){\n          next[a+b][ii] = next[b][next[a][ii]];\n        }\n      }\n    }\n    pre = post;\n  }\n  jj/=2;\n  vector<int> A(pow3N);\n  iota(A.begin(), A.end(), 0);\n  vector<int> B(pow3N);\n  while(T.size()){\n    while(jj>T.size()) jj/=2;\n    for(int ii=0; ii<pow3N; ii++){\n      B[ii] = next[T.substr(0, jj)][A[ii]];\n    }\n    swap(A, B);\n    T = T.substr(jj);\n  }\n\n  for(auto& pos : A){\n    cout << pos << \" \";\n  }\n  cout << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << a << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n \ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int N = int(round(pow(3,6)));\n\nvi ch(N);\nvector<vi> r(N, vi(N));\n \nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    forn(i,N) r[i].resize(N);\n    forsn(n,1,N) {\n        ch[n] = 3*ch[n/3];\n        if (n%3) ch[n] += 3-n%3;\n    }\n\n    forn(i,N) forn(j,N) r[i][j] = j*N+i;\n\n    int n; string s;\n    cin >> n >> s;\n\n    bool is_swap = false;\n    for(auto c : s) {\n        if (c == 'S') {\n            forn(i,N) if (i < ch[i]) swap(r[i], r[ch[i]]);\n            is_swap = !is_swap;\n        }\n        else {\n            forsn(i,1,N) swap(r[0], r[i]);\n            if (is_swap) forn(i,N) if (i < ch[i]) swap(r[0][i], r[0][ch[i]]);\n            forsn(i,1,N) swap(r[0][0], r[0][i]);\n            if (is_swap) forn(i,N) if (i < ch[i]) swap(r[0][i], r[0][ch[i]]);\n        }\n    }\n\n    int sz = int(round(pow(3,n)));\n    if (is_swap) forn(idx, N) {\n        forn(i,N) if (i < ch[i]) swap(r[idx][i], r[idx][ch[i]]);\n    }\n\n    vi ans(sz);\n    forn(idx, N) forn(i,N) {\n        int x = r[idx][i];\n        int y = i*N + idx;\n        ans[x%sz] = y%sz;\n    }\n    \n    for (auto x : ans) cout << x << ' ';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n\nusing namespace std;\n\nint N;\nstring T;\n\nvoid R(int *data);\nvoid S(int *data1, int *data2);\nint X(int x, int y);\n\nint main(){\n  int n;\n  string s1;\n  string s2;\n  cin >> n;\n  cin >> T;\n  N = X(3, n);\n  int L[N];\n  int K[N];\n  int O[N];\n  \n  for(int i=0;i<N;i++){\n    L[i] = i;\n  }\n  \n  for(int i=0;i<N/3;i++){\n    int k = i;\n    int tmp = 0;\n    int m = 3;\n    int q = i*3;\n    \n    while(k>0){\n      if(k%3==1){\n        tmp = tmp +2*m;\n      }else if(k%3==2){\n        tmp = tmp +1*m;\n      }\n      k = k/3;\n      m = m*3;\n    }\n    K[tmp] = q;\n    K[tmp + 1] = q+2;\n    K[tmp + 2] = q+1;\n  }\n  \n  \n  for(int i=0;i<(int)(T.length());i++){\n    s1 = T[i];\n    s2 = T[i+1];\n    if(s1 == \"S\" && s2 == \"S\"){\n      i++;\n    }else if(s1 == \"S\" && s2 == \"R\"){\n      S(L,K);\n    }else{\n      R(L);\n    }\n  }\n  \n  \n  for(int i=0;i<N;i++){\n    O[L[i]] = i;\n  }\n  \n\n\n  for(int i=0;i<N;i++){\n    cout << O[i] << \" \";\n  }\n  return 0;\n}\n\nvoid R(int *data){\n  int tmp = data[N-1];\n  for(int i=0;i<N;i++){\n    int a = data[i];\n    data[i] = tmp;\n    tmp = a;\n  }\n}\nvoid S(int *data1, int *data2){\n  int T[N];\n  for(int i=0;i<N;i++){\n    T[i] = data1[data2[i]];\n  }\n  for(int i=0;i<N;i++){\n    data1[i] = T[i];\n  }\n}\n\n\nint X(int x,int y){\n  int a = 1;\n  for(int i=0;i<y;i++){\n    a = a*x;\n  }\n  return a;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#define int long long\n\n#define pii pair<int, int>\n\n#define x1 x1228\n#define y1 y1228\n\n#define left left228\n#define right right228\n\n#define next next228\n\n#define pb push_back\n#define eb emplace_back\n\n#define mp make_pair                                                                \n                                                                                                                                        \n#define ff first                                                                  \n#define ss second   \n\n#define all(x) x.begin(), x.end()\n#define debug(x) cout << #x << \": \" << x << endl; \n#define TIME (ld)clock()/CLOCKS_PER_SEC\n\nusing namespace std;\ntypedef long long ll; \ntypedef long double ld; \n                                                                                                   \nconst int maxn = 2e5 + 7, mod = 1e9 + 7, MAXN = 1e6 + 7;\nconst double eps = 1e-9;\nconst ll inf = 1e18;\nmt19937 rnd(time(0));\nint n; \nstring s; \nint next[MAXN];\nconst int N = 2187; \nint dp1[MAXN]; \nint dp2[MAXN]; \nint xyz[maxn]; \n\nint get1(int mask, char q) {\n    if (q == 'R') {\n        ++mask; \n        return mask; \n    }   \n    int ptr = 1; \n    int ans = 0; \n    while (mask) {\n        int t = mask % 3; \n        mask /= 3; \n        if (t == 2) ans += ptr; \n        if (t == 1) ans += 2 * ptr; \n        ptr *= 3; \n    }\n    return ans; \n}\n\nint get(int mask, char q) {\n    if (q == 'R') {\n        ++mask; \n        return mask; \n    }   \n    return xyz[mask]; \n}\n\nconst int L = 12; \nint pref[maxn]; \nint to[maxn][N]; \n\nint get(int l, int r) {\n    return pref[r + 1] - pref[l]; \n}\n\nvoid change(int &mask, int l, int r) {\n    if (get(l, r) % 2) {\n        mask = get(mask, 'S'); \n    }    \n    mask++; \n}\n\nint merge(int left, int right) {\n    for (int i = 0; i < 7; ++i) right *= 3;\n    return left + right;     \n}\n\nint get(int x) {\n    vector<int> bts; \n    for (int i = 0; i < L; ++i) {\n        bts.pb(x % 3); \n        x /= 3; \n    }\n    int left = 0;\n    int right = 0; \n    for (int i = 6; i >= 0; --i) {\n        left *= 3;\n        left += bts[i]; \n    }\n    for (int i = L - 1; i >= 7; --i) {\n        right *= 3; \n        right += bts[i]; \n    }\n    int id = 0; \n    if (left && dp1[left] == -1) {\n        return merge(to[0][left], right);  \n    }\n    if (left) {    \n        id = dp1[left]; \n        change(right, 0, id - 1);             \n        left = 0; \n    }                     \n    while (next[id] != -1) {\n        change(right, id, next[id] - 1);\n        id = next[id];                                                                                                                                         \n    }\n    left = to[id][0]; \n    return merge(left, right); \n}\n\n\nvoid solve() {\n    for (int i = 0; i < maxn; ++i) {\n        xyz[i] = get1(i, 'S'); \n    }\n    cin >> n >> s; \n    int t = s.size(); \n    for (int i = 0; i < t; ++i) {\n        pref[i + 1] = pref[i] + (s[i] == 'S'); \n    }\n    for (int i = 0; i < N; ++i) dp1[i] = dp2[i] = -1; \n    for (int i = 0; i < N; ++i) to[t][i] = i; \n    next[t] = -1;               \n    for (int i = t - 1; i >= 0; --i) {\n        for (int mask = 0; mask < N; ++mask) {\n            int mask1 = get(mask, s[i]); \n            mask1 %= N; \n            to[i][mask] = to[i + 1][mask1]; \n        }\n        for (int mask = 0; mask < N; ++mask) {\n            int mask1 = get(mask, s[i]);\n            mask1 %= N;                 \n            if (mask && mask1 == 0) {\n                dp2[mask] = i + 1; \n            } else {\n                dp2[mask] = dp1[mask1]; \n            }   \n        }\n        next[i] = dp2[0]; \n        for (int mask = 0; mask < N; ++mask) {\n            dp1[mask] = dp2[mask]; \n            dp2[mask] = -1; \n        }\n    }\n    int tet = 1; \n    for (int i = 0; i < n; ++i) tet *= 3; \n    for (int i = 0; i < tet; ++i) {\n        cout << get(i) % tet << \" \";             \n    }\n}                                \n   \nsigned main() {\n#ifdef LOCAL\n    freopen(\"TASK.in\", \"r\", stdin);\n    freopen(\"TASK.out\", \"w\", stdout);\n#else \n    \n#endif // LOCAL\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20); \n    cout << fixed; \n    int t = 1; \n    for (int i = 0; i < t; ++i) {              \n        solve();\n    }\n    return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint n;\n\n#define MAX 1000002\n\nint pos[MAX];\nchar buf[MAX];\n\nstring s;\n\nvector<int> p[MAX];\n\nint im[MAX];\n\n\ninline int get_f(int l,int r){\n\tif(l>r)return 0;\n\tif(l)return im[r]-im[l-1];\n\treturn im[r];\n}\ninline int f(int val){\n\tif(val==0)return 0;\n\tif(val==2){\n\t\treturn 1;\n\t}\n\telse{\n\t\treturn 2;\n\t}\n}\nvector<int> nex[MAX];\nint ans[MAX];\n\nint main(){\n\tif(true){\n\tcin>>n;\n\tscanf(\"%s\",buf);\n\ts=buf;\n}\nelse{\n\tn=12;\n\tfor(int i=0;i<200000;i++){\n\t\tif(rand()%2){\n\t\ts.push_back('R');\n\t}\n\telse{\n\t\ts.push_back('S');\n\t}\n\t}\n}\nint m=pow(3,n);\nint k=1;\n\tfor(int i=0;i<s.size();i++){\n\t\tif(s[i]=='R'){\n\t\t\tp[0].push_back(i);\n\t\t}\n\t\telse{\n\t\t\tim[i]++;\n\t\t}\n\t\tif(i)im[i]+=im[i-1];\n\t}\n\tfor(int i=0;i<n;i++){\n\t\t//cerr<<i<<endl;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tint tmp=ans[j];\n\t\t\tfor(int g=0;g<3;g++){\n\t\t\t\tint cur=g;\n\t\t\t\tint tim=0;\n\t\t\t\tfor(int el:p[j]){\n\t\t\t\t\tint z=get_f(tim,el);\n\t\t\t\t\ttim=el+1;\n\t\t\t\t\tif(z%2){\n\t\t\t\t\t\tcur=f(cur);\n\t\t\t\t\t}\n\t\t\t\t\tcur++;\n\t\t\t\t\tif(cur==3){\n\t\t\t\t\t\tnex[k*g+j].push_back(el);\n\t\t\t\t\t\tcur=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint z=get_f(tim,s.size()-1);\n\t\t\t\tif(z%2)cur=f(cur);\n\t\t\t\tans[k*g+j]=tmp+cur*k;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<k*3;j++){\n\t\t\tswap(nex[j],p[j]);\n\t\t\tnex[j].clear();\n\t\t}\n\t\tk*=3;\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tif(i)printf(\" \");\n\t\tprintf(\"%d\",ans[i]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cassert>\n#include<stdexcept>\n#include<utility>\n#include<functional>\n#include<numeric>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<array>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<complex>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<bitset>\n#include<memory>\nusing namespace std;\nusing ll=long long;\n\nconst int SZ = 10;\nint n;\nint pow3n;\nvector<int> sal;\nvoid init_s(){\n    sal.resize(pow3n);\n    iota(sal.begin(),sal.end(),0);\n    for(int i=0;i<pow3n;i++){\n        int x = i;\n        int tar = 0;\n        int r = 1;\n        for(int j=0;j<n;j++){\n            tar+= (x%3*2)%3*r;\n            x/=3;\n            r*=3;\n        }\n        if(tar<i){\n            // cerr<<i<<\" \"<<tar<<endl;\n            swap(sal[tar],sal[i]);\n        }\n    }\n}\n\nint ary[1000000];\nvoid do_rx(vector<int>& pat,int t){\n    t = t%pow3n;\n    for(int i=t;i<pow3n;i++) ary[i] = pat[i-t];\n    for(int i=0;i<t;i++) ary[i] = pat[pow3n-t+i];\n    for(int i=0;i<pow3n;i++) pat[i] = ary[i];\n}\n\nvoid do_r(vector<int>& pat){\n    int head = pat[pow3n-1];\n    for(int i=pow3n-1;i>0;i--){\n        pat[i]=pat[i-1];\n    }\n    pat[0] = head;\n}\n\nvoid perm(vector<int>& pat,vector<int>& par){\n    for(int i=0;i<pow3n;i++) ary[i] = pat[par[i]];\n    for(int i=0;i<pow3n;i++) pat[i] = ary[i];\n}\nvoid do_s(vector<int>& pat){\n    perm(pat,sal);\n}\nint main(){\n    cin>>n;\n    pow3n=1;\n    for(int i=0;i<n;i++) pow3n*=3;\n    init_s();\n    \n    string t;\n    {\n        string tmp;\n        cin>>tmp;\n        for(auto c:tmp){\n            if(!t.empty() && t.back()=='S' && c=='S') t.pop_back();\n            else t+=c;\n        }\n    }\n\n    vector<vector<int>> memo(1<<SZ);\n    \n    for(int bit=0;bit<(1<<SZ);bit++){\n        bool ispass= false;\n        for(int j=0;j+1<SZ;j++){\n            if(((bit>>j)&1)==0 && ((bit>>(j+1)))==0) ispass=true;\n        }\n        if(ispass) continue;\n\n        memo[bit].resize(pow3n);\n        iota(memo[bit].begin(),memo[bit].end(),0);\n        for(int j=0;j<SZ;j++){\n            if(((bit>>j)&1)==0) do_s(memo[bit]);\n            else do_r(memo[bit]);\n        }\n    }\n    vector<int> res(pow3n);\n    iota(res.begin(),res.end(),0);\n    int l = 0;\n    while(t.size()-l>=SZ){\n        int r;\n        for(r=l;r<t.size();r++){\n            if(t[r]=='S') break;\n        }\n        if(r-l>=SZ){\n            do_rx(res,r-l);\n            l=r;\n        }\n        else{\n            int bit = 0;\n            for(int j=0;j<SZ;j++){\n                if(t[l+j]=='R') bit+=(1<<j);\n            }\n            perm(res,memo[bit]);\n            bit=0;\n            l+=SZ;\n        }\n    }\n\n    for(int i=l;i<t.size();i++){\n        // cerr<<\"#\"<<endl;\n        if(t[i]=='S') do_s(res);\n        else do_r(res);\n    }\n    vector<int> inv(pow3n);\n    for(int i=0;i<pow3n;i++) inv[res[i]]=i;\n    for(int i=0;i<pow3n;i++) cout<<inv[i]<<\" \";\n    cout<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,true:false;}\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,true:false;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nint n,m,cnt;\nint pw[15],ch[600000][3],tag[600000],fl[600000],ans[600000];\nchar s[200005];\n\nvoid insert(int x,int t){\n\tint p=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(!ch[p][x%3]) ch[p][x%3]=++cnt;\n\t\tp=ch[p][x%3];\n\t\tx/=3;\n\t}\n\tfl[p]=t;\n}\n\nvoid add(){\n\tint p=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(tag[p]){\n\t\t\tswap(ch[p][1],ch[p][2]);\n\t\t\tfor(int i=0;i<3;i++) tag[ch[p][i]]^=1;\n\t\t\ttag[p]=0;\n\t\t}\n\t\tswap(ch[p][0],ch[p][1]);\n\t\tswap(ch[p][0],ch[p][2]);\n\t\tp=ch[p][0];\n\t}\n}\n\nvoid getans(int id,int num,int dep){\n\tif(fl[id]) return (void)(ans[fl[id]-1]=num);\n\tif(tag[id]){\n\t\tswap(ch[id][1],ch[id][2]);\n\t\tfor(int i=0;i<3;i++) tag[ch[id][i]]^=1;\n\t\ttag[id]=0;\n\t}\n\tgetans(ch[id][0],num,dep+1);\n\tgetans(ch[id][1],num+pw[dep],dep+1);\n\tgetans(ch[id][2],num+2*pw[dep],dep+1);\n}\n\nint main(){\n\tn=readint();\n\tpw[0]=1;\n\tfor(int i=1;i<=n;i++) pw[i]=pw[i-1]*3;\n\tscanf(\"%s\",s+1); m=strlen(s+1);\n\tfor(int i=0;i<pw[n];i++) insert(i,i+1);\n\tfor(int i=1;i<=m;i++){\n\t\tif(s[i]=='S') tag[0]^=1;\n\t\telse add();\n\t}\n\tgetans(0,0,0);\n\tfor(int i=0;i<pw[n];i++) printf(\"%d \",ans[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 535005;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\nchar s[MAXN];\nint n, m, mx, ans[MAXN];\nint root, tot, ch[MAXN * 13][3], ori[MAXN * 13], tag[MAXN * 13];\n\nvoid pushdown(int rt) {\n\tif (tag[rt]) {\n\t\tswap(ch[rt][1], ch[rt][2]);\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\ttag[ch[rt][i]] ^= 1;\n\t\t}\n\t\ttag[rt] = 0;\n\t}\n}\n\nvoid Build(int &rt, int dep, int w, int num) {\n\trt = ++tot;\n\tif (dep == n) {\n\t\tori[rt] = num;\n\t\treturn;\n\t}\n\tfor (int i = 0; i < 3; ++i) {\n\t\tBuild(ch[rt][i], dep + 1, w * 3, num + w * i);\n\t}\n}\n\nvoid Add1() {\n\tint rt = root;\n\tfor (int i = 0; i < n; ++i) {\n\t\tpushdown(rt);\n\t\tswap(ch[rt][0], ch[rt][1]);\n\t\tswap(ch[rt][0], ch[rt][2]);\n\t\trt = ch[rt][0];\n\t}\n}\n\nvoid GetAns(int rt, int dep, int w, int num) {\n\tif (dep == n) {\n\t\tans[ori[rt]] = num;\n\t\treturn;\n\t}\n\tpushdown(rt);\n\tfor (int i = 0; i < 3; ++i) {\n\t\tGetAns(ch[rt][i], dep + 1, w * 3, num + w * i);\n\t}\n}\n\nvoid init() {\n\tread(n);\n\tscanf(\"%s\", s + 1);\n\tm = strlen(s + 1);\n\tfor (int i = mx = 1; i <= n; ++i, mx *= 3);\n}\n\nvoid solve() {\n\tBuild(root, 0, 1, 0);\n\tfor (int i = 1; i <= m; ++i) {\n\t\tif (s[i] == 'S') {\n\t\t\ttag[root] ^= 1;\n\t\t} else {\n\t\t\tAdd1();\t\n\t\t}/*\n\t\tGetAns(root, 0, 1, 0);\n\t\tfor (int i = 0; i < mx; ++i) {\n\t\t\tprintf(\"%d \", ans[i]);\n\t\t}\n\t\tprintf(\"\\n\");*/\n\t}\n\tGetAns(root, 0, 1, 0);\n\tfor (int i = 0; i < mx; ++i) {\n\t\tprintf(\"%d \", ans[i]);\n\t}\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n \nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n\n#define MOD 1000000007LL\n\nint N;\nstring T;\nvector<int> p1,p2;\nint sp;\nint tn;\n\nint conv(int);\nint tri(int n) {\n  int ans=1;\n  for (int i=0; i<n; i++) ans *= 3;\n  return ans;\n}\n\nvoid salsa();\nvoid rumba();\nvoid print_res();\nvoid print_ln();\n\nint main()\n{\n  int l;\n  int i;\n\n  cin >> N >> T;\n  tn = tri(N);\n\n  p1.resize(tn);\n  p2.resize(tn);\n  for (int i=0; i<tn; i++) p1[i] = i;\n  p2[0] = p1[0];\n  sp = 1;\n\n//print_ln();\n\n  l = T.size();\n  for (i=0; i<l; i++) {\n    if (T[i] == 'S') {\n      salsa();\n//printf(\"S \");\n//print_ln();\n    } else {\n      rumba();\n//printf(\"R \");\n//print_ln();\n    }\n  }\n\n  print_res();\n\n  return 0;\n}\nint conv(int inp) {\n  int cv=0;\n  int t;\n  for (t=1; inp>0; t*=3) {\n    switch(inp % 3) {\n    case 1: cv += 2*t; break;\n    case 2: cv += t; break;\n    }\n    inp /= 3;\n  }\n  return cv;\n}\n\nvoid salsa() {\n  int i;\n\n  if (sp==1) {\n    for (i=0; i<tn; i++) {\n      p2[conv(i)] = p1[i];\n    }\n    sp = 2;\n  } else {\n    for (i=0; i<tn; i++) {\n      p1[conv(i)] = p2[i];\n    }\n    sp = 1;\n  }\n}\nvoid rumba() {\n  int i;\n  if (sp==1) {\n    for (i=0; i<tn-1; i++) {\n      p2[i+1]=p1[i];\n    }\n    p2[0] = p1[tn-1];\n    sp = 2;\n  } else {\n    for (i=0; i<tn-1; i++) {\n      p1[i+1]=p2[i];\n    }\n    p1[0] = p2[tn-1];\n    sp = 1;\n  }\n}\n\nvoid print_ln() {\n  int i;\n  if (sp == 1) {\n    printf(\"%d\", p1[0]);\n    for (i=1; i<tn; i++) printf(\" %d\", p1[i]);\n  } else {\n    printf(\"%d\", p2[0]);\n    for (i=1; i<tn; i++) printf(\" %d\", p2[i]);\n  }\n  printf(\"\\n\");\n}\nvoid print_res() {\n  int i;\n  map<int, int> m;\n  if (sp == 1) {\n    for (i=0; i<tn; i++)  m.emplace(p1[i], i);\n  } else {\n    for (i=0; i<tn; i++)  m.emplace(p2[i], i);\n  }\n  auto it=m.begin();\n  printf(\"%d\", it->second);\n  for (it++; it!=m.end(); it++) {\n    printf(\" %d\", it->second);\n  }\n  printf(\"\\n\");\n}\n/*\n  a*3^3+b*3^2+c*3+d\n  */\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<iostream>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=1594324;\nint n,m,rt,tot,ch[N][3],ans[N],id[N]; char s[N]; bool rev[N];\ninline void build(int& now,CI dep=0,CI st=0)\n{\n\tnow=++tot; if (dep==n) return (void)(id[now]=st);\n\tint len=pow(3,dep); build(ch[now][0],dep+1,st);\n\tbuild(ch[now][1],dep+1,st+len); build(ch[now][2],dep+1,st+(len<<1));\n}\ninline void rever(CI now)\n{\n\tswap(ch[now][1],ch[now][2]); rev[now]^=1;\n}\ninline void pushdown(CI now)\n{\n\tif (!rev[now]) return; rev[now]=0;\n\tfor (RI i=0;i<3;++i) rever(ch[now][i]);\n}\ninline void swaping(CI now,CI dep=0)\n{\n\tpushdown(now); if (dep==n) return; swap(ch[now][1],ch[now][2]);\n\tswap(ch[now][0],ch[now][1]); swaping(ch[now][0],dep+1);\n}\ninline void DFS(CI now,CI dep=0,CI st=0)\n{\n\tpushdown(now); if (dep==n) return (void)(ans[id[now]]=st); int len=pow(3,dep);\n\tDFS(ch[now][0],dep+1,st); DFS(ch[now][1],dep+1,st+len); DFS(ch[now][2],dep+1,st+(len<<1));\n}\nint main()\n{\n\tRI i; scanf(\"%d%s\",&n,s+1); m=strlen(s+1);\n\tfor (build(rt),i=1;i<=m;++i) if (s[i]=='S') rever(rt); else swaping(rt);\n\tfor (DFS(rt),n=pow(3,n),i=0;i<n;++i) printf(\"%d \",ans[i]); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> p_ll;\n\ntemplate<class T>\nvoid debug(T itr1, T itr2) { auto now = itr1; while(now<itr2) { cout << *now << \" \"; now++; } cout << endl; }\n#define repr(i,from,to) for (int i=(int)from; i<(int)to; i++)\n#define all(vec) vec.begin(), vec.end()\n#define rep(i,N) repr(i,0,N)\n#define per(i,N) for (int i=(int)N-1; i>=0; i--)\n\nconst ll MOD = pow(10,9)+7;\nconst ll LLINF = pow(2,61)-1;\nconst int INF = pow(2,30)-1;\n\nvector<ll> fac;\nvoid c_fac(int x=pow(10,6)+10) { fac.resize(x,true); rep(i,x) fac[i] = i ? (fac[i-1]*i)%MOD : 1; }\nll inv(ll a, ll m=MOD) { ll b = m, x = 1, y = 0; while (b!=0) { int d = a/b; a -= b*d; swap(a,b); x -= y*d; swap(x,y); } return (x+m)%m; }\nll nck(ll n, ll k) { return fac[n]*inv(fac[k]*fac[n-k]%MOD)%MOD; }\nll gcd(ll a, ll b) { if (a<b) swap(a,b); return b==0 ? a : gcd(b, a%b); }\nll lcm(ll a, ll b) { return a/gcd(a,b)*b; }\n\nint N;\nvector<int> p3, result;\n\nvoid dfs(int n, int count, string dance) {\n  if (count==N) return;\n  rep(i,3) {\n    int now = n + p3[count]*i, pos = i;\n    string d;\n    rep(j, dance.size()) {\n      if (dance[j]=='R') { \n        pos = (pos+1)%3; \n        if (pos==0) d += 'R'; \n      }\n      if (dance[j]=='S') { \n        pos = (3-pos)%3;\n        if (d.back()=='S') d.pop_back();\n        else d += 'S';\n      }\n    }\n    for (int j=now; j<p3[N]; j+=p3[count]*3) result[j] += pos*p3[count];\n    // cout << now << \"->\" << pos << \" \" << d << endl;\n    dfs(now,count+1,d);\n  }\n}\n\nint main() {\n  cin >> N;\n  string T; cin >> T;\n\n  p3.resize(N+1); rep(i,N+1) p3[i] = i==0 ? 1 : p3[i-1]*3;\n  result.resize(p3[N]);\n\n\n  dfs(0,0,T);\n  debug(all(result));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nstatic inline char CH()\n{\n  static char buf[100000],*ptr1=buf,*ptr2=buf;\n  return ptr1==ptr2&&(ptr2=(ptr1=buf)+fread(buf,1,100000,stdin),ptr1==ptr2)?EOF:*ptr1++;\n}\nstatic inline int IN(void)\n{\n  int x=0,f=0,c=CH();while(c<48||c>57){f^=c==45,c=CH();}\n  while(c>47&&c<58){x=x*10+c-48,c=CH();}return f?-x:x;\n}\nstatic inline int Pow(int a,int b){return b?Pow(a*a,b>>1)*(b&1?a:1):1;}\nint main()\n{\n  int N=IN(),now,len=0,pw3=Pow(3,N),x=Pow(3,N>>1),y=Pow(3,N-(N>>1)),A[1000001],B[600001];\n  char c=CH(),T[1000001],S[1000001];\n  rep(i,pw3)B[i]=B[i/3]*3+(3-i%3)%3;\n  while(c!=EOF){if(c==10){c=CH();}T[len++]=c,c=CH();}len--;\n  rep(i,x)\n  {\n    int temp=i;now=0;\n    rep(j,len)\n    {\n      if(T[j+1]=='S'){temp=B[temp];(S[now]=='S')?--now:S[++now]='S';}\n      else{++temp;if(temp==x)S[++now]='R',temp=0;}\n    }\n    rep(j,y)\n    {\n      int keep=j;\n      rep(k,now)\n      {\n        if(S[k+1]=='S')keep=B[keep];\n        else if(S[k+1]=='R'){if((++keep)==y)keep=0;A[i+j*x]=temp+keep*x;}\n      }\n    }\n  }\n  rep(i,pw3)printf(\"%d \",A[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n    #define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define pb push_back\n//#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 1000006;\n\nint curup[maxn];\npair<int, int> curdown[maxn];\nchar s[maxn];\nint n, nn;\nint godownS[maxn];\n\npair<string, int> add1(string ss)\n{\n\tbool all2 = true;\n\tfor (int j = (int)ss.length() - 1; j >= 0; j--)\n\t{\n\t\tif (ss[j] != '2')\n\t\t{\n\t\t\tss[j]++;\n\t\t\tall2 = false;\n\t\t\tbreak;\n\t\t} else\n\t\t{\n\t\t\tss[j] = '0';\n\t\t}\n\t}\n\treturn {ss, all2};\n}\n\nstring calcS(string s)\n{\n\tfor (auto &c : s) if (c != '0') c = '1' + '2' - c;\n\treturn s;\n}\n\nint eval(string s)\n{\n\tint v = 0;\n\tfor (auto c : s) v = v * 3 + c - '0';\n\treturn v;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\t//n = 12;\n\tnn = 1;\n\tfor (int i = 0; i < n; i++) nn *= 3;\n\tscanf(\"%s\", s);\n\tint len = strlen(s);\n\t//int len = 200000;\n\t//for (int i = 0; i < len; i++) s[i] = 'R'; //(((int)rng() % 2) ? 'S' : 'R');\n\tint nhalf = (n + 1) / 2;\n\tint nnhalf = 1;\n\tfor (int i = 0; i < nhalf; i++) nnhalf *= 3;\n\tstring cur = string(nhalf, '0');\n\tfor (int it = 0; it < nnhalf; it++)\n\t{\n\t\tgodownS[it] = eval(calcS(cur));\n\t\tcur = add1(cur).fi;\n\t}\n\tint nntop = nn / nnhalf;\n\n\n\tfor (int it = 0; it < nnhalf; it++)\n\t{\n\t\tcurdown[it] = {it, 0};\n\t}\n\tfor (int it = 0; it < nn; it++)\n\t{\n\t\tcurup[it] = it / nnhalf;\n\t}\n\tfor (int it = 0; it < len; it++)\n\t{\n\t\t//cout << \"before \" << it << ' ' << clock() << endl;\n\t\t//for (auto t : mp) cout << t.from << ' ' << t.to << ' ' << t.flip << endl;\n\t\t//cout << it << ' ' << mp.size() << endl;\n\t\tchar op = s[it];\n\t\tif (op == 'S')\n\t\t{\n\t\t\tfor (int i = 0; i < nnhalf; i++)\n\t\t\t{\n\t\t\t\tcurdown[i].fi = godownS[curdown[i].fi];\n\t\t\t\tcurdown[i].se ^= 1;\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\tfor (int i = 0; i < nnhalf; i++)\n\t\t\t{\n\t\t\t\tif (curdown[i].fi != nnhalf - 1)\n\t\t\t\t{\n\t\t\t\t\tcurdown[i].fi++;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tfor (int j = i; j < nn; j += nnhalf)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (curdown[i].se)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcurup[j] = godownS[curup[j]];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurup[j]++;\n\t\t\t\t\t\tif (curup[j] == nntop) curup[j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tcurdown[i] = {0, 0};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < nn; i++)\n\t{\n\t\tif (curdown[i % nnhalf].se)\n\t\t{\n\t\t\tcurup[i] = godownS[curup[i]];\n\t\t}\n\t\tint v = curup[i] * nnhalf + curdown[i % nnhalf].fi;\n\t\tprintf(\"%d \", v);\n\t}\n\tprintf(\"\\n\");\n\t//for (int i = 0; i < nn; i++) printf(\"%d%d \", curup[i], curdown[i % nnhalf].fi);\n\t//printf(\"\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid read(int &x){\n\tregister char ch=getchar();x=0;\n\tfor(;ch==' '||ch=='\\n';ch=getchar());\n\tfor(;ch!=' '&&ch!='\\n';x=x*10+ch-'0',ch=getchar());\n}\nvoid reads(string &s){\n\tregister char ch=getchar();s=\"\";\n\tfor(;ch==' '||ch=='\\n';ch=getchar());\n\tfor(;ch!=' '&&ch!='\\n';s+=ch,ch=getchar());\n}\nvoid write(int x){\n\tif(x>9)write(x/10);\n\tputchar(x%10+'0');\n}\nint K,pw[13],ans[532000],dat[532000],go[532000][3];\nbool lz[532000];\nstring typ;\nvoid built_trie(int id,int lv,int now){ \n\tif(lv==K){\n\t\tdat[id]=now;return;\n\t}\n\tfor(int i=0;i<3;i++){\n\t\tgo[id][i]=id*3+i+1;\n\t\tbuilt_trie(go[id][i],lv+1,now+i*pw[lv]);\n\t}\n}\nvoid push_down(int id){\n\tswap(go[id][1],go[id][2]);\n\tfor(int i=0;i<3;i++)lz[go[id][i]]^=1;\n\tlz[id]=0;\n}\nvoid update_trie(int id,int lv){\n\tif(lv==K)return;\n\tif(lz[id])push_down(id);\n\tupdate_trie(go[id][2],lv+1);\n\tswap(go[id][1],go[id][2]),swap(go[id][0],go[id][1]);\n}\nvoid make_ans(int id,int lv,int now){\n\tif(lv==K){\n\t\tans[dat[id]]=now;\n\t\treturn;\n\t}\n\tif(lz[id])push_down(id);\n\tfor(int i=0;i<3;i++)\n\t\tmake_ans(go[id][i],lv+1,now+i*pw[lv]);\n}\nint main(){\n\tpw[0]=1,read(K),reads(typ);\n\tfor(int i=1;i<=K;i++)pw[i]=pw[i-1]*3;\n\tbuilt_trie(0,0,0);\n\tfor(int i=0;i<typ.size();i++){\n\t\tif(typ[i]=='S')lz[0]^=1;\n\t\telse update_trie(0,0);\n\t}\n\tmake_ans(0,0,0);\n\tfor(int i=0;i<pw[K];i++)write(ans[i]),putchar(' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int M=1e6;\nconst int end1=531441;\nint s[M];\nint b[1000];\nvoid cha3(ll x,int n){\n\tfor (int i=1;i<=n;i++)b[i]=0;\n\tint i=0;\n\twhile (x){\n\t\tb[++i]=x%3;\n\t\tx/=3;\n\t}\n}\nvoid ops(int n){\n\tfor (int i=1;i<=n;i++){\n\t\tif (b[i]==1)b[i]=2;\n\t\telse if (b[i]==2)b[i]=1;\n\t}\n}\nint pow1[20];\nvoid pre(){\n\tfor (int i=0;i<end1;i++){\n\t\tcha3(i,12);\n\t\tint ans=0,base=1;\n\t\tops(12);\n\t\tfor (int j=1;j<=12;j++){\n\t\t\tans+=b[j]*base;\n\t\t\tbase*=3;\n\t\t}\n\t\ts[i]=ans;\n\t}\npow1[1]=3,pow1[2]=9,pow1[3]=27,pow1[4]=81,pow1[5]=243,pow1[6]=729;\npow1[7]=2187,pow1[8]=6561,pow1[9]=19683,pow1[10]=59049,pow1[11]=177147,pow1[12]=531441;\n\n}\nint a[M];\nint main(){\n//\t\tfreopen(\"ab.txt\",\"w\",stdout);\n\tpre();\n\tint n;\n\tstring s1;\n\tcin>>n>>s1;\n\tint cnt=0;\n\tfor (int i=0;i<s1.size();i++){\n\t\tint ans=1;\n\t\tchar c=s1[i];\n\t\twhile (i+ans<s1.size() and s1[i+ans]==c)ans++;\n\t\tif (c=='S'){\n\t\t\tif (ans%2){\n\t\t\t\ta[++cnt]=M+1;\n\t\t\t}\n\t\t}else{\n\t\t\ta[++cnt]=ans;\n\t\t}\n\t\ti=i+ans-1;\n\t}\n\tfor (int i=0;i<pow1[n];i++){\n\t\tll ans=i;\n\t\tfor (int j=1;j<=cnt;j++){\n\t\t\tif (a[j]>M)ans=s[ans];\n\t\t\telse{\n\t\t\t\tans+=a[j];\n\t\t\t\tif (ans>=pow1[n])ans%=pow1[n];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld \",ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int M = 1e6 + 10;\nchar s[M];\nint trie[M][3], vis[M], cnt[13], a[12], tag[M], ans[M], tot, n;\nvoid insert(int a[], int rt, int id){\n    for(int i = 0; i < n; i++){\n        int x = a[i];\n        if(!trie[rt][x]) trie[rt][x] = ++tot;\n        rt = trie[rt][x];\n    }\n    vis[rt] = id;\n}\nvoid calc(int rt) {\n    for(int i = 0; i < n; i++) {\n        if(tag[rt]) {\n            swap(trie[rt][1], trie[rt][2]);\n            tag[rt] ^= 1; tag[trie[rt][0]] ^= 1; tag[trie[rt][1]] ^= 1; tag[trie[rt][2]] ^= 1;\n        }\n        int temp = trie[rt][2];\n        trie[rt][2] = trie[rt][1];\n        trie[rt][1] = trie[rt][0];\n        trie[rt][0] = temp;\n        rt = trie[rt][0];\n    }\n}\nvoid print(int rt, int res, int h) {\n    if(tag[rt]) {\n        swap(trie[rt][1], trie[rt][2]);\n        tag[rt] ^= 1; tag[trie[rt][0]] ^= 1; tag[trie[rt][1]] ^= 1; tag[trie[rt][2]] ^= 1;\n    }\n    for(int i = 0; i < 3; i++) {\n        if(trie[rt][i]) print(trie[rt][i], res + i * cnt[h], h + 1);\n        else {\n            ans[vis[rt]] = res;\n            return;\n        }\n    }\n}\nint main(){\n    scanf(\"%d%s\", &n, s);\n    int len = strlen(s), rt = 0;\n    cnt[0] = 1;\n    for(int i = 1; i <= n; i++) cnt[i] = cnt[i - 1] * 3;\n    for(int i = 0; i < cnt[n]; i++) {\n        memset(a, 0, sizeof(a));\n        for(int j = n - 1; j >= 0; j--) {\n            a[j] = (i % cnt[j + 1]) / cnt[j];\n        }\n        insert(a, rt, i);\n    }\n    for(int i = 0; i < len; i++) {\n        if(s[i] == 'S') tag[0] ^= 1;\n        else calc(rt);\n    }\n    print(rt, 0, 0);\n    for(int i = 0; i < cnt[n]; i++) printf(\"%d%c\", ans[i], i == cnt[n] - 1 ? '\\n' : ' ');\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m;\nconst int M = 2e5+5;\nchar s[M];\n\nstruct Node{\n\tint swp,ch[3],ed;\n}t[2000010];\nint cnt=1;\n\ninline void ins(int sum){\n\tint fir=1;\n\tint s=sum;\n\tfor(int i=0;i<n;i++){\n\t\tint q=sum%3;\n\t\tsum/=3;\n\t\tif(!t[fir].ch[q])t[fir].ch[q]=++cnt;\n\t\tfir=t[fir].ch[q];\n\t}\n\tt[fir].ed=s;\n}\n\nvoid add(){\n\tint fir=1;\n\tfor(int i=0;i<n;i++){\n\t\tif(t[fir].swp){\n\t\t\tswap(t[fir].ch[1],t[fir].ch[2]);\n\t\t\tfor(int j=0;j<3;j++)t[t[fir].ch[j]].swp^=1;\n\t\t\tt[fir].swp=0;\n\t\t}\n\t\tint q=t[fir].ch[2];t[fir].ch[2]=t[fir].ch[1],t[fir].ch[1]=t[fir].ch[0];\n\t\tt[fir].ch[0]=q;\n\t\tfir=q;\n\t}\n}\nint ans[2000010];\nvoid dfs(int fir,int d,int quan,int s){\n\tif(t[fir].swp){\n\t\tswap(t[fir].ch[1],t[fir].ch[2]);\n\t\tfor(int j=0;j<3;j++)t[t[fir].ch[j]].swp^=1;\n\t\tt[fir].swp=0;\n\t}\n\tif(d==n){\n\t\tans[t[fir].ed]=s;return;\n\t}\n\tfor(int j=0;j<3;j++){\n\t\tdfs(t[fir].ch[j],d+1,quan*3,s+quan*j);\n\t}\n}\nint tot=0;\nint main()\n{\n\tcin >> n;\n\ttot=1;for(int i=1;i<=n;i++)tot*=3;\n\tscanf(\"%s\",s+1);\n\tm=strlen(s+1);\n\tfor(int i=0;i<tot;i++){\n\t\tins(i);\n\t}\n\t// cerr << \"?\" << endl;\n\tfor(int j=1;j<=m;j++){\n\t\tif(s[j]=='S')t[1].swp=1;\n\t\telse add();\n\t\t// dfs(1,0,1,0);\n\t\t// for(int i=0;i<tot;i++)printf(\"%d \",ans[i]);puts(\"\");\n\t}\n\tdfs(1,0,1,0);\n\tfor(int i=0;i<tot;i++)printf(\"%d \",ans[i]);puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,x,y,z,sw,pw3=1,A[531441]={0},B[531441]={0},S[531441]={0};\nchar T[200001];\nvoid OUT(int x){if(x<0)putchar('-'),x=-x;if(x>=10)OUT(x/10);putchar(x%10+48);}\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nsigned main(void)\n{\n  x=scanf(\"%d %s\",&N,T);\n  replace(T,\"SS\",\"\");if(T[0]=='\\n')return 0;\n  rep(i,N)\n  {\n    rep(j,pw3)rep(k,3)B[j+k*pw3]=k;sw=1;\n    rep(p,strlen(T))\n    {\n      if(T[p]=='R')\n      {\n        y=S[p];\n        rep(j,3)\n        {\n          x=y+j*pw3;\n          if(B[x]==1&&sw==-1)S[p]=x;\n          if(B[x]==2&&sw==1)S[p]=x;\n          B[x]+=(sw==1?1:2);B[x]%=3;\n        }\n      }\n      else sw*=-1;\n    }\n    rep(j,pw3){y=A[j];rep(k,3){x=j+k*pw3;A[x]=y+((sw==-1)?3-B[x]:B[x])%3*pw3;}}\n    pw3*=3;\n  }\n  rep(i,pw3)OUT(A[i]),putchar(' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for (int i = (a); i <= int(b); i++)\nusing namespace std;\n\nconst int maxn = 8e5;\nint n, m, tot, val[maxn + 5], ch[maxn + 5][3], cnt, res[maxn + 5];\nbool sal[maxn + 5];\nchar s[maxn + 5];\n\nint dfs(int k, int t, int s) {\n\tint x = ++tot;\n\tif (!k) return val[x] = s, x;\n\tch[x][0] = dfs(k - 1, t * 3, s);\n\tch[x][1] = dfs(k - 1, t * 3, s + t);\n\tch[x][2] = dfs(k - 1, t * 3, s + t * 2);\n\treturn x;\n}\n\nvoid salsa(int x) {\n\tsal[x] ^= 1, swap(ch[x][1], ch[x][2]);\n}\n\nvoid push_down(int x) {\n\tif (sal[x]) {\n\t\trep(i, 0, 2) salsa(ch[x][i]);\n\t\tsal[x] = false;\n\t}\n}\n\nvoid rumba(int x) {\n\tif (!ch[x][0]) return;\n\tpush_down(x);\n\tint t = ch[x][0];\n\tch[x][0] = ch[x][2];\n\tch[x][2] = ch[x][1];\n\tch[x][1] = t;\n\trumba(ch[x][0]);\n}\n\nvoid work(int x, int t, int s) {\n\tif (!ch[x][0]) {\n\t\tres[val[x]] = s, cnt++;\n\t\treturn;\n\t}\n\tpush_down(x);\n\trep(i, 0, 2) work(ch[x][i], t * 3, s + i * t);\n}\n\nint main() {\n\tscanf(\"%d %s\", &n, s + 1);\n\tm = strlen(s + 1);\n\tdfs(n, 1, 0);\n\trep(i, 1, m) {\n\t\tif (s[i] == 'S') salsa(1);\n\t\telse rumba(1);\n\t}\n\twork(1, 1, 0);\n\trep(i, 0, cnt - 1) printf(\"%d%c\", res[i], \" \\n\"[i == cnt - 1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n// #include <ext/pb_ds/assoc_container.hpp> \n// #include <ext/pb_ds/detail/standard_policies.hpp>\n// using namespace __gnu_pbds;\n\n#pragma GCC optimize(\"O3\")\n#ifdef LOCAL\n#include \"/Users/lbjlc/Desktop/coding/debug_utils.h\"\n#else\n#define print(...) ;\n#define printn(...) ;\n#define fprint(...) ;\n#define fprintn(...) ;\n#endif\n\n#define rep(i, a, b) for(auto i = (a); i < (b); i++)\n#define rrep(i, a, b) for(auto i = (a); i > (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define pb push_back\n// #define mp make_pair\n#define fi first\n#define se second\n#define maxi(x, y) x = max(x, y)\n#define mini(x, y) x = min(x, y)\n// long long fact(long long n) { if(!n) return 1; return n*fact(n-1); }\n// #define endl '\\n'\n#define solve_testcase int T;cin>>T;for(int t=1;t<=T;t++){solve(t);}\n\n// long long gcd(long long x, long long y) { return y ? gcd(y, x % y) : x; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\n \ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n \ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\ntypedef vector<long long> vll;\n#define bd(type,op,val) bind(op<type>(), std::placeholders::_1, val)\n\nconst int MAXN = 1e6+10;\n\n\nvoid solve(int tt) {\n    // cout<<\"Case #\"<<tt<<\": \";\n}\n\nstring to_ter(int x, int k=-1) {\n    string res;\n    while(x) {\n        res+='0'+x%3;\n        x/=3;\n    }\n    if(k>=0) {\n        while(res.size()<k) res+='0';\n    }\n    return res;\n}\nint to_int(const string & s) {\n    int res=0;\n    // rrep(i,s.size()-1,-1)\n    //     res=res*3+(s[i]-'0');\n    for(int i=s.size()-1;i>=0;i--)\n        res=res*3+(s[i]-'0');\n    // print(s,res);\n    return res;\n}\nbool add(string & x, const string & y) {\n    int n1=x.size(), n2=y.size(),carry=0;\n    rep(i,0,n1) {\n        if(i<n1) carry+=x[i]-'0';\n        if(i<n2) carry+=y[i]-'0';\n        x[i]=carry%3+'0';\n        carry/=3;\n    }\n    return carry==0;\n}\n\nvi cal_inst(string & s) {\n    int n=s.size();\n    vi res(1);\n    int i=0;\n    while(i<n) {\n        if(s[i]=='R') {\n            res.back()++;\n            i++;\n        }\n        else {\n            int j=i;\n            for(;j<n&&s[j]=='S';j++);\n            if((j-i)%2) res.pb(0);\n            i=j;\n        }\n    }\n    if(s.back()=='S') res.pop_back();\n    return res;\n}\n\nchar rev(char c) {\n    if(c>'0') return '0'+(3-(c-'0'));\n    return c;\n}\nstring rev(string s) {\n    for(auto & c:s) c=rev(c);\n    return s;\n}\n\nint len(string & s) {\n    int res=s.size();\n    while(res>0&&s[res-1]=='0') res--;\n    return res;\n}\n\nvi cal(vi inst, int n, int tot) {\n    vi res(tot);\n    map<string, string> dp,dp1;\n    rep(i,0,tot) {\n        string cur=to_ter(i,n);\n        int ok=0;\n        rep(j,0,n) {\n            string cur1=cur.substr(0,j+1)+string(n-j-1,'0');\n            if(dp1.count(cur1)&&len(dp1[cur1])<=j+1) {\n                cur1=dp1[cur1];\n                if(inst.size()%2) {\n                    rep(jj,j+1,n) cur1[jj]=rev(cur[jj]);\n                }\n                // dp[cur]=cur1;\n                ok=1;\n                res[i]=to_int(cur1);\n                dp1[cur]=cur1;\n                break;\n            }\n        }\n        if(!ok) {\n            string cur1=cur;\n            bool ok=true;\n            for(auto x:inst) {\n                // print(cur1,to_ter(x,n));\n                ok=add(cur1,to_ter(x,n))&&ok;\n                // print(cur1,to_ter(x,n));\n                for(auto & c:cur1) c=rev(c);\n            }\n            // dp[cur]=cur1;\n            res[i]=to_int(cur1);\n            if(ok) dp1[cur]=cur1;\n            // print(cur,cur1);\n        }\n        // res[i]=to_int(dp[cur]);\n        print(i,cur,res[i],dp[cur]);\n        // print(res[i],dp[cur]);  \n    }\n    print(inst,res);\n    print(dp);\n    print(dp1);\n    return res;\n}\n\nint main(int argc, char * argv[]) {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    // solve_testcase;\n\n    int n;\n    string s;\n    cin>>n;\n    cin>>s;\n    int tot=1;\n    rep(i,0,n) tot*=3;\n\n    vi inst=cal_inst(s);\n    for(auto & x:inst) x%=tot;\n\n    print(inst);\n\n    int i=0;\n    int bound=3*3*3*3*3*3*3;\n    vi res(tot);\n    iota(all(res),0);\n    while(i<inst.size()) {\n        int cur=inst[i];\n        vi cur_inst({cur});\n        for(++i;i<inst.size()&&cur+inst[i]<bound;i++) {\n            cur+=inst[i];\n            cur_inst.pb(cur);\n        }\n        vi tmp=cal(inst,n,tot);\n        // print(tmp);\n        rep(j,0,tot) res[j]=tmp[res[j]];\n        print(res);\n    }\n    if(s.back()=='R') {\n        rep(i,0,tot) {\n            res[i]=to_int(rev(to_ter(res[i],n)));\n        }\n    }\n    for(auto x:res) cout<<x<<' ';\n    cout<<endl;\n\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n// #include <ext/pb_ds/assoc_container.hpp> \n// #include <ext/pb_ds/detail/standard_policies.hpp>\n// using namespace __gnu_pbds;\n\n#pragma GCC optimize(\"O3\")\n#ifdef LOCAL\n#include \"/Users/lbjlc/Desktop/coding/debug_utils.h\"\n#else\n#define print(...) ;\n#define printn(...) ;\n#define fprint(...) ;\n#define fprintn(...) ;\n#endif\n\n#define rep(i, a, b) for(auto i = (a); i < (b); i++)\n#define rrep(i, a, b) for(auto i = (a); i > (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define pb push_back\n// #define mp make_pair\n#define fi first\n#define se second\n#define maxi(x, y) x = max(x, y)\n#define mini(x, y) x = min(x, y)\n// long long fact(long long n) { if(!n) return 1; return n*fact(n-1); }\n// #define endl '\\n'\n#define solve_testcase int T;cin>>T;for(int t=1;t<=T;t++){solve(t);}\n\n// long long gcd(long long x, long long y) { return y ? gcd(y, x % y) : x; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\n \ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n \ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\ntypedef vector<long long> vll;\n#define bd(type,op,val) bind(op<type>(), std::placeholders::_1, val)\n\nconst int MAXN = 1e6+10;\n\n\nvoid solve(int tt) {\n    // cout<<\"Case #\"<<tt<<\": \";\n}\n\nstring to_ter(int x, int k=-1) {\n    string res;\n    while(x) {\n        res+='0'+x%3;\n        x/=3;\n    }\n    if(k>=0) {\n        while(res.size()<k) res+='0';\n    }\n    return res;\n}\nint to_int(const string & s) {\n    int res=0;\n    // rrep(i,s.size()-1,-1)\n    //     res=res*3+(s[i]-'0');\n    for(int i=s.size()-1;i>=0;i--)\n        res=res*3+(s[i]-'0');\n    // print(s,res);\n    return res;\n}\nbool add(string & x, const string & y) {\n    int n1=x.size(), n2=y.size(),carry=0;\n    rep(i,0,n1) {\n        if(i<n1) carry+=x[i]-'0';\n        if(i<n2) carry+=y[i]-'0';\n        x[i]=carry%3+'0';\n        carry/=3;\n    }\n    return carry==0;\n}\n\nvi cal_inst(string & s) {\n    int n=s.size();\n    vi res(1);\n    int i=0;\n    while(i<n) {\n        if(s[i]=='R') {\n            res.back()++;\n            i++;\n        }\n        else {\n            int j=i;\n            for(;j<n&&s[j]=='S';j++);\n            if((j-i)%2) res.pb(0);\n            i=j;\n        }\n    }\n    if(s.back()=='S') res.pop_back();\n    return res;\n}\n\nchar rev(char c) {\n    if(c>'0') return '0'+(3-(c-'0'));\n    return c;\n}\nstring rev(string s) {\n    for(auto & c:s) c=rev(c);\n    return s;\n}\n\nint len(string & s) {\n    int res=s.size();\n    while(res>0&&s[res-1]=='0') res--;\n    return res;\n}\n\nvi cal(vi inst, int n, int tot) {\n    vi res(tot);\n    map<string, string> dp,dp1;\n    rep(i,0,tot) {\n        string cur=to_ter(i,n);\n        int ok=0;\n        rep(j,0,n) {\n            string cur1=cur.substr(0,j+1)+string(n-j-1,'0');\n            if(dp1.count(cur1)&&len(dp1[cur1])<=j+1) {\n                cur1=dp1[cur1];\n                if(inst.size()%2) {\n                    rep(jj,j+1,n) cur1[jj]=rev(cur[jj]);\n                }\n                // dp[cur]=cur1;\n                ok=1;\n                res[i]=to_int(cur1);\n                dp1[cur]=cur1;\n                break;\n            }\n        }\n        if(!ok) {\n            string cur1=cur;\n            bool ok=true;\n            for(auto x:inst) {\n                // print(cur1,to_ter(x,n));\n                ok=add(cur1,to_ter(x,n))&&ok;\n                // print(cur1,to_ter(x,n));\n                for(auto & c:cur1) c=rev(c);\n            }\n            // dp[cur]=cur1;\n            res[i]=to_int(cur1);\n            if(ok) dp1[cur]=cur1;\n            // print(cur,cur1);\n        }\n        // res[i]=to_int(dp[cur]);\n        print(i,cur,res[i],dp[cur]);\n        // print(res[i],dp[cur]);  \n    }\n    print(inst,res);\n    print(dp);\n    print(dp1);\n    return res;\n}\n\nint main(int argc, char * argv[]) {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    // solve_testcase;\n\n    int n;\n    string s;\n    cin>>n;\n    cin>>s;\n    int tot=1;\n    rep(i,0,n) tot*=3;\n\n    vi inst=cal_inst(s);\n    for(auto & x:inst) x%=tot;\n\n    print(inst);\n\n    int i=0;\n    int bound=3*3*3*3*3;\n    vi res(tot);\n    iota(all(res),0);\n    while(i<inst.size()) {\n        int cur=inst[i];\n        vi cur_inst({cur});\n        for(++i;i<inst.size()&&cur+inst[i]<bound;i++) {\n            cur+=inst[i];\n            cur_inst.pb(cur);\n        }\n        vi tmp=cal(inst,n,tot);\n        // print(tmp);\n        rep(j,0,tot) res[j]=tmp[res[j]];\n        print(res);\n    }\n    if(s.back()=='R') {\n        rep(i,0,tot) {\n            res[i]=to_int(rev(to_ter(res[i],n)));\n        }\n    }\n    for(auto x:res) cout<<x<<' ';\n    cout<<endl;\n\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int N = 6377292 + 7;\nint n, m, trie[N][3], num[N], tot = 1, ans[N];\nbool tag[N];\nchar s[N];\n\nvoid build(int p, int d, int o, int x) {\n\tif (d == n) return num[p] = x, void();\n\tfor (int i = 0; i < 3; i++)\n\t\tbuild(trie[p][i] = ++tot, d + 1, o * 3, x + i * o);\n}\n\ninline void spread(int p) {\n\tif (tag[p]) {\n\t\tswap(trie[p][1], trie[p][2]), tag[p] = 0;\n\t\tfor (int i = 0; i < 3; i++) tag[trie[p][i]] ^= 1;\n\t}\n}\n\nvoid dfs(int p, int d, int o, int x) {\n\tif (d == n) return ans[num[p]] = x, void();\n\tspread(p);\n\tfor (int i = 0; i < 3; i++)\n\t\tdfs(trie[p][i], d + 1, o * 3, x + i * o);\n}\n\nint main() {\n\trd(n), build(1, 0, 1, 0), rds(s, m);\n\tfor (int i = 1; i <= m; i++)\n\t\tif (s[i] == 'S') tag[1] ^= 1;\n\t\telse {\n\t\t\tint p = 1;\n\t\t\tfor (int i = 0; i < n; i++, p = trie[p][0])\n\t\t\t\tspread(p),\n\t\t\t\tswap(trie[p][0], trie[p][1]),\n\t\t\t\tswap(trie[p][0], trie[p][2]);\n\t\t}\n\tdfs(1, 0, 1, 0);\n\tfor (int i = 0, k = pow(3, n); i < k; i++)\n\t\tprint(ans[i], \" \\n\"[i==k-1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#define int long long\n \n#define pii pair<int, int>\n \n#define x1 x1228\n#define y1 y1228\n \n#define left left228\n#define right right228\n \n#define next next228\n \n#define pb push_back\n#define eb emplace_back\n \n#define mp make_pair                                                                \n                                                                                                                                        \n#define ff first                                                                  \n#define ss second   \n \n#define all(x) x.begin(), x.end()\n#define debug(x) cout << #x << \": \" << x << endl; \n#define TIME (ld)clock()/CLOCKS_PER_SEC\n \nusing namespace std;\ntypedef long long ll; \ntypedef long double ld; \n                                                                                                   \nconst int maxn = 2e5 + 7, mod = 1e9 + 7, MAXN = 1e6 + 7;\nconst double eps = 1e-9;\nconst ll inf = 1e18;\nmt19937 rnd(time(0));\nint n; \nstring s; \nint next[MAXN];\nconst int N = 2187; \nint dp1[N]; \nint dp2[N]; \nint xyz[N]; \n \nint get1(int mask, char q) {\n    if (q == 'R') {\n        ++mask; \n        return mask; \n    }   \n    int ptr = 1; \n    int ans = 0; \n    while (mask) {\n        int t = mask % 3; \n        mask /= 3; \n        if (t == 2) ans += ptr; \n        if (t == 1) ans += 2 * ptr; \n        ptr *= 3; \n    }\n    return ans; \n}\n \nconst int L = 12; \nint pref[maxn]; \nint to[maxn]; \nint kek1[N], kek2[N]; \nint res[N], res1[N]; \nint add = 1; \n \nint get(int x) {\n    vector<int> bts; \n    for (int i = 0; i < L; ++i) {\n        bts.pb(x % 3); \n        x /= 3; \n    }\n    int left = 0;\n    int right = 0; \n    for (int i = 6; i >= 0; --i) {\n        left *= 3;\n        left += bts[i]; \n    }\n    for (int i = L - 1; i >= 7; --i) {\n        right *= 3; \n        right += bts[i]; \n    }\n    int id = 0;         \n    if (left && dp1[left] == -1) {\n        if (pref[(int)s.size()] & 1) right = xyz[right];   \n        return res[left] + add * right;   \n    }\n    if (left) {    \n        id = dp1[left]; \n        if (pref[id] & 1) right = xyz[right];             \n        left = 0; \n    }                     \n    while (next[id] != -1) {        \n        if ((pref[next[id]] - pref[id]) & 1) right = xyz[right]; \n        id = next[id];                                                                                                                                         \n    }\n    if ((pref[(int)s.size()] - pref[id]) & 1) right = xyz[right]; \n    left = to[id]; \n    return left + right * add; \n}\n \nvoid solve() {\n    for (int i = 0; i < N; ++i) {\n        xyz[i] = get1(i, 'S') % N; \n    }\n    cin >> n >> s; \n    int t = s.size(); \n    for (int i = 0; i < t; ++i) {\n        pref[i + 1] = pref[i] + (s[i] == 'S'); \n    }\n \n    for (int i = 0; i < N; ++i) dp1[i] = dp2[i] = -1; \n    next[t] = -1;\n    for (int i = 0; i < N; ++i) kek1[i] = i;              \n    for (int i = 0; i < N; ++i) res[i] = i; \n    for (int i = t - 1; i >= 0; --i) {\n        for (int mask = 0; mask < N; ++mask) {\n            int mask1; \n            if (s[i] == 'S') mask1 = xyz[mask]; \n            else mask1 = mask + 1; \n            if (mask1 >= N) mask1 -= N; \n            res1[mask] = res[mask1]; \n            kek2[mask] = kek1[mask1];\n            if (mask && mask1 == 0) {\n                dp2[mask] = i + 1; \n            } else {\n                dp2[mask] = dp1[mask1]; \n            }                                                                                 \n        }\n        to[i] = kek2[0]; \n        next[i] = dp2[0]; \n        for (int mask = 0; mask < N; ++mask) {\n            res[mask] = res1[mask]; \n            kek1[mask] = kek2[mask]; \n            dp1[mask] = dp2[mask]; \n            dp2[mask] = -1; \n        }\n    }\n    for (int i = 0; i < 7; ++i) add *= 3; \n    int tet = 1; \n    for (int i = 0; i < n; ++i) tet *= 3; \n    for (int ptr = tet - 1; ptr < tet; ++ptr) {\n        cout << get(ptr) % tet << \" \"; \n    }\n//    cout << TIME; \n    return; \n}                                \n   \nsigned main() {\n#ifdef LOCAL\n    freopen(\"TASK.in\", \"r\", stdin);\n    freopen(\"TASK.out\", \"w\", stdout);\n#else \n    \n#endif // LOCAL\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20); \n    cout << fixed; \n    int t = 1; \n    for (int i = 0; i < t; ++i) {              \n        solve();\n    }\n    return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    vector<int> d23(531441);\n    //vector<int> rumba(531441);\n\n    int N;\n    cin >> N;\n    N = (int)pow(3,N);\n    \n    int temp,add,now;\n    for(int i = 0 ; i < N ; i++){\n        temp = i;\n        add = 0;\n        now = 1;\n        while(temp != 0){\n            int a = temp % 3;\n            if(a == 1){\n                add += 2 * now;\n            }else if(a == 2){\n                add += now;\n            }\n            now *= 3;\n            temp /= 3;\n        }\n        d23.at(i) = add;\n    }\n\n    //for(int i = 0 ; i < N ; i++){\n    //    rumba.at(i) = i + 1;\n    //}\n    //rumba.at(N - 1) = 0;\n\n\n    vector<int> hito1(531441);\n\n    for(int i = 0 ; i < N ; i++){\n        hito1.at(i) = i;\n    }\n\n\n    string _T;\n    cin >> _T;\n\n    string TSdata;\n    vector<int> Tdata;\n\n    bool flag = false;\n    int cnt = 0;\n\n    for(int i = 0 ; i < _T.size() ; i++){\n        if(_T.at(i) == 'S'){\n            if(flag){\n                flag = false;\n                continue;\n            }\n            flag = true;\n        }else{\n            if(flag){\n                TSdata.push_back('S');\n                flag = false;\n            }\n            TSdata.push_back('R');\n        }\n    }\n    if(flag){\n        TSdata.push_back('S');\n    }\n    flag = false;\n\n    \n    \n    for(int i = 0 ; i < TSdata.size() ; i++){\n        if(TSdata.at(i) == 'R'){\n            cnt++;\n        }else{\n            if(cnt != 0){\n                Tdata.push_back(cnt);\n                cnt = 0;\n            }\n            Tdata.push_back(0);\n        }\n    }\n    if(cnt != 0){\n        Tdata.push_back(cnt);\n    }\n\n\n    /*for(int i = 0 ; i < _T.size() ; i++){\n        if(_T.at(i) == 'S'){\n            if(cnt != 0){\n                Tdata.push_back(cnt);\n                cnt = 0;\n            }\n            if(flag){\n                flag = false;\n            }else{\n                flag = true;\n            }\n        }else{\n            if(flag){\n                Tdata.push_back(0);\n            }\n            flag = false;\n            cnt++;\n        }\n    }\n    if(flag){\n        Tdata.push_back(0);\n    }\n    if(cnt != 0){\n        Tdata.push_back(cnt);\n    }\n    */\n    int tSize = Tdata.size();\n\n    //for(int i = 0 ; i < Tdata.size() ; i++){\n    //    cout << Tdata.at(i) << ' ';\n    //}\n    //return 0;\n\n    \n\n    for(int i = 0 ; i < tSize ; i++){\n        if(Tdata.at(i) == 0){\n            for(int j = 0 ; j < N ; j++){\n                hito1.at(j) = d23.at(hito1.at(j));\n            }\n        }else{\n            int a = Tdata.at(i);\n            a %= N;\n            for(int j = 0 ; j < N ; j++){\n                hito1.at(j) += a;\n                if(hito1.at(j) >= N){\n                    hito1.at(j) -= N;\n                }\n            }\n        }\n    }\n\n\n    \n    for(int i = 0 ; i < N - 1 ; i++){\n        cout << hito1.at(i) << ' ';\n    }\n    cout << hito1.at(N - 1) << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <string>\n#include <algorithm>\n#include <utility>\n#define inf 1e18\n#define rep(x, s, t) for(int (x) = (s); (x) < (t); (x)++)\n#define Rep(x, s, t) for(int (x) = (s); (x) <= (t); (x)++)\n#define chmin(x, y) (x) = min((x), (y))\n#define chmax(x, y) (x) = max((x), (y))\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n;\nstring s;\nint beki[15];\nint carry[200005];\nint dest[600005], ndest[600005];\nset<int> S[3];\nint pt[3];\n\nint main(void)\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n;\n\tcin >> s;\n\t\n\tbeki[0] = 1;\n\tfor(int i = 1; i < 15; i++) beki[i] = beki[i-1] * 3;\n\t\n\tfor(int i = 0; i < 3; i++){\n\t\tint p = i;\n\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\tif(s[j] == 'R'){\n\t\t\t\tif(p == 2) carry[j] = i;\n\t\t\t\tp = (p+1) % 3;\n\t\t\t}\n\t\t\telse p = (3-p)%3;\n\t\t}\n\t\tdest[i] = p;\n\t}\n\t\n\tfor(int i = 1; i < n; i++){\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tS[j].clear();\n\t\t\tfor(int k = 0; k < beki[i]; k++){\n\t\t\t\tS[j].insert(j*beki[i]+k);\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < 3; j++) pt[j] = j;\n\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\tif(s[j] == 'S') swap(pt[1], pt[2]);\n\t\t\telse{\n\t\t\t\tint tmp[3];\n\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\tfor(int l = 0; l < 3; l++){\n\t\t\t\t\t\tint x = l*beki[i]+carry[j];\n\t\t\t\t\t\tif(S[pt[k]].count(x)){\n\t\t\t\t\t\t\ttmp[k] = x;\n\t\t\t\t\t\t\tif(k == 2) carry[j] = x;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\tS[pt[k]].erase(tmp[k]);\n\t\t\t\t\tS[pt[(k+1)%3]].insert(tmp[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tfor(auto it = S[pt[j]].begin(); it != S[pt[j]].end(); it++){\n\t\t\t\tndest[*it] = dest[*it%beki[i]] + j*beki[i];\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < beki[i+1]; j++) dest[j] = ndest[j];\n\t}\n\t\n\tfor(int i = 0; i < beki[n]; i++) cout << dest[i] << \" \"; cout << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr<<\"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return rng() % (y+1-x) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\nusing ll=long long; \nusing ld=long double;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\nusing pi=pair<ll,ll>; using spi=pair<ll,pi>; using dpi=pair<pi,pi>; \n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (600006)\nll n, A[MAXN], p3[15], ofs2, half, mp[729], edge[729];\nstring T;\nvector<ll> v[729];\nll flip(ll x){\n\tll res=0;\n\tDEC(j,n-1,half) if(x>=p3[j]*2) {\n\t\tres += p3[j];\n\t\tx -= p3[j] * 2;\n\t} else if(x>=p3[j]) {\n\t\tres += p3[j] * 2;\n\t\tx -= p3[j];\n\t}\n\treturn res;\n}\nint main(){\n\tp3[0]=1; FOR(i,1,14) p3[i]=p3[i-1]*3;\n\tFAST\n\tcin>>n>>T;half=n/2;\n\tFOR(i,0,p3[half]-1) mp[i]=i;\n\tFOR(i,0,p3[half]-1){\n\t\tedge[i]=i;\n\t\tll add=0;\n\t\tDEC(j,half-1,0)if(edge[i]>=p3[j]*2){\n\t\t\tedge[i] -= p3[j] * 2;\n\t\t\tadd += p3[j];\n\t\t}else if(edge[i]>=p3[j]) {\n\t\t\tedge[i] -= p3[j];\n\t\t\tadd += p3[j] * 2;\n\t\t}assert(edge[i]==0);\n\t\tedge[i]=add;\n\t}\n\tFOR(i,0,p3[n]-1){\n\t\tA[i]=i;\n\t\tDEC(j,n-1,half) if(A[i]>=p3[j]*2) A[i]-=p3[j]*2; else if(A[i]>=p3[j]) A[i]-=p3[j];\n\t\tv[A[i]].eb(i), A[i]=i-A[i];\n\t}\n\tFOR(i,0,siz(T)-1){\n\t\tif(T[i]=='R'){//+1\n\t\t\tll act=-1;\n\t\t\tFOR(i,0,p3[half]-1) if(mp[i]==p3[half]-1) assert(act==-1), act=i;\n\t\t\tassert(~act);\n\t\t\tfor(auto i:v[act]) {\n\t\t\t\tif(ofs2) A[i]=flip(A[i]);\n\t\t\t\tA[i] += p3[half];\n\t\t\t\tif(A[i] >= p3[n]) A[i] -= p3[n], assert(A[i]==0);\n\t\t\t\tif(ofs2) A[i]=flip(A[i]);\n\t\t\t}\n\t\t\tFOR(i,0,p3[half]-1) ++ mp[i], mp[i] %= p3[half];\n\t\t}else{\n\t\t\tofs2 ^= 1;\n\t\t\tFOR(i,0,p3[half]-1){\n\t\t\t\tmp[i]=edge[mp[i]];\n\t\t\t}\n\t\t}\n\t}\n\tFOR(i,0,p3[n]-1) if(ofs2) A[i]=flip(A[i]);\n\tFOR(i,0,p3[half]-1) {\n\t\tfor(auto j:v[i]) A[j] += mp[i];\n\t}\n\tFOR(i,0,p3[n]-1) cout<<A[i]<<' '; cout<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n//#define debug(x) ;\n#define debug(x) cerr << #x << \" = \" << x << \"\\n\";\n\nostream& operator<<(ostream& cerr, vector<ll> aux) {\n  cerr << \"[\";\n  for (auto e : aux) cerr << e << ' ';\n  cerr << \"]\";\n  return cerr;\n}\n\nconst int maxT = 200011;\nconst int maxN = 600011;\n\nstruct node {\n  int data;\n  node* son[3];\n\n  node() {\n    data = 0;\n    memset(son, 0, sizeof(son));\n  }\n};\n\nint n, t;\nint id[3], sol[maxN], cnt;\nchar s[maxT];\nnode* head;\n\nvoid build(node* act, int lvl, int curr, int step) {\n  if (lvl == n) {\n    act->data = curr;\n    return;\n  }\n\n  act->son[0] = new node();\n  act->son[1] = new node();\n  act->son[2] = new node();\n\n  build(act->son[0], lvl + 1, curr, step * 3);\n  build(act->son[1], lvl + 1, curr + step, step * 3);\n  build(act->son[2], lvl + 1, curr + 2 * step, step * 3);\n}\n\nvoid salsa() {\n  swap(id[1], id[2]);\n}\n\nvoid rumba(node* act, int lvl) {\n if (lvl == n) return;\n\n node* aux = act->son[id[2]];\n act->son[id[2]] = act->son[id[1]];\n act->son[id[1]] = act->son[id[0]];\n\n act->son[id[0]] = aux;\n rumba(act->son[id[0]], lvl + 1);\n}\n\nvoid print(node* act, int lvl, int curr, int step) {\n  if (lvl == n) {\n    sol[act->data] = curr;\n    cnt++;\n    return;\n  }\n\n  print(act->son[id[0]], lvl + 1, curr, step * 3);\n  print(act->son[id[1]], lvl + 1, curr + step, step * 3);\n  print(act->son[id[2]], lvl + 1, curr + 2 * step, step * 3);\n}\n\nint main()\n{\n  //freopen(\"test.in\", \"r\", stdin);\n\n  scanf(\"%d\\n%s\", &n, s);\n  t = strlen(s);\n\n  head = new node();\n  build(head, 0, 0, 1);\n\n  for (int i = 0; i < 3; i++) \n    id[i] = i;\n   \n  for (int i = 0; i < t; i++) {\n    if (s[i] == 'S')\n      salsa();\n    else\n      rumba(head, 0);\n  }\n\n  print(head, 0, 0, 1);\n  for (int i = 0; i < cnt; i++)\n    printf(\"%d \", sol[i]);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n// #include <ext/pb_ds/assoc_container.hpp> \n// #include <ext/pb_ds/detail/standard_policies.hpp>\n// using namespace __gnu_pbds;\n\n#pragma GCC optimize(\"O3\")\n#ifdef LOCAL\n#include \"/Users/lbjlc/Desktop/coding/debug_utils.h\"\n#else\n#define print(...) ;\n#define printn(...) ;\n#define fprint(...) ;\n#define fprintn(...) ;\n#endif\n\n#define rep(i, a, b) for(auto i = (a); i < (b); i++)\n#define rrep(i, a, b) for(auto i = (a); i > (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define pb push_back\n// #define mp make_pair\n#define fi first\n#define se second\n#define maxi(x, y) x = max(x, y)\n#define mini(x, y) x = min(x, y)\n// long long fact(long long n) { if(!n) return 1; return n*fact(n-1); }\n// #define endl '\\n'\n#define solve_testcase int T;cin>>T;for(int t=1;t<=T;t++){solve(t);}\n\n// long long gcd(long long x, long long y) { return y ? gcd(y, x % y) : x; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\n \ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n \ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\ntypedef vector<long long> vll;\n#define bd(type,op,val) bind(op<type>(), std::placeholders::_1, val)\n\nconst int MAXN = 1e6+10;\n\n\nvoid solve(int tt) {\n    // cout<<\"Case #\"<<tt<<\": \";\n}\n\nstring to_ter(int x, int k=-1) {\n    string res;\n    while(x) {\n        res+='0'+x%3;\n        x/=3;\n    }\n    if(k>=0) {\n        while(res.size()<k) res+='0';\n    }\n    return res;\n}\nint to_int(const string & s) {\n    int res=0;\n    // rrep(i,s.size()-1,-1)\n    //     res=res*3+(s[i]-'0');\n    for(int i=s.size()-1;i>=0;i--)\n        res=res*3+(s[i]-'0');\n    // print(s,res);\n    return res;\n}\nbool add(string & x, const string & y) {\n    int n1=x.size(), n2=y.size(),carry=0;\n    rep(i,0,n1) {\n        if(i<n1) carry+=x[i]-'0';\n        if(i<n2) carry+=y[i]-'0';\n        x[i]=carry%3+'0';\n        carry/=3;\n    }\n    return carry==0;\n}\n\nvi cal_inst(string & s) {\n    int n=s.size();\n    vi res(1);\n    int i=0;\n    while(i<n) {\n        if(s[i]=='R') {\n            res.back()++;\n            i++;\n        }\n        else {\n            int j=i;\n            for(;j<n&&s[j]=='S';j++);\n            if((j-i)%2) res.pb(0);\n            i=j;\n        }\n    }\n    if(s.back()=='S') res.pop_back();\n    return res;\n}\n\nchar rev(char c) {\n    if(c>'0') return '0'+(3-(c-'0'));\n    return c;\n}\nstring rev(string s) {\n    for(auto & c:s) c=rev(c);\n    return s;\n}\n\nint len(string & s) {\n    int res=s.size()-1;\n    while(res>=0&&s[res]=='0') res--;\n    return res+1;\n}\n\nint power[13]={};\nint revmap[MAXN]={};\nint tmpres[MAXN];\nint rev(int x) {\n    for(int flag=1;flag<power[12];flag*=3) {\n        int tmp=x/flag%3;\n        if(tmp==1) x+=flag;\n        else if(tmp==2) x-=flag;\n    }\n    return x;\n}\n\nvoid cal(vi inst, int n, int tot) {\n    // vi tmpres(tot,-1);\n    fill(tmpres,tmpres+tot,-1);\n\n    rep(i,0,tot) {\n        if(tmpres[i]>=0) continue;\n\n        int cur=i,ok=1;\n        for(auto x:inst) {\n            cur+=x;\n            if(cur>=power[n]) {\n                ok=0; \n                cur%=power[n];\n            }\n            cur=revmap[cur];\n        }\n        // if(i<=9) print(i,cur);\n        tmpres[i]=cur;\n        // assert(cur>=0);\n        if(!ok) continue;\n        int flag=1,tmp;\n        for(;flag<=i||flag<=cur;flag*=3);\n\n        if(inst.size()%2==0) {\n            for(tmp=flag;tmp<power[n];tmp+=flag) {\n                tmpres[tmp+i]=tmp+cur;\n            }\n        }\n        else {\n            for(tmp=flag;tmp<power[n];tmp+=flag) {\n                tmpres[tmp+i]=revmap[tmp]+cur;\n            }\n\n        }\n    }\n    // print(1);\n    // print(*max_element(all(res)),*min_element(all(res)));\n    // return res;\n}\n\nint main(int argc, char * argv[]) {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    // solve_testcase;\n\n    int n;\n    string s;\n    cin>>n;\n    cin>>s;\n\n    // n=12;\n    // rep(i,0,1e5) s+=\"RS\";\n\n    power[0]=1;\n    rep(i,1,13) power[i]=power[i-1]*3;\n\n    int tot=1;\n    rep(i,0,n) tot*=3;\n\n    rep(i,0,tot) revmap[i]=rev(i);\n    // printn(revmap,9);\n\n\n    vi inst=cal_inst(s);\n    for(auto & x:inst) x%=tot;\n\n    // print(inst);\n\n    int i=0;\n    int bound=241;\n    vi res(tot);\n    iota(all(res),0);\n    while(i<inst.size()) {\n        int cur=inst[i];\n        vi cur_inst({cur});\n        for(++i;i<inst.size()&&cur+inst[i]<bound;i++) {\n            cur+=inst[i];\n            cur_inst.pb(inst[i]);\n        }\n        cal(cur_inst,n,tot);\n        // print(tmp);\n        rep(j,0,tot) res[j]=tmpres[res[j]];\n        // print(cur_inst,tmp);\n        // print(res);\n        // sort(all(tmp)); print(tmp);\n    }\n    if(s.back()=='R') {\n        rep(i,0,tot) {\n            res[i]=revmap[res[i]];\n        }\n    }\n    for(auto x:res) printf(\"%d \",x);\n        // cout<<x<<' ';\n    printf(\"\\n\");\n    // cout<<endl;\n\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n#include \"debug.h\"\n#else\n#define DEBUG(...)\n#endif\n\ntemplate <class T, class Op = multiplies<T>>\nconstexpr T power(T a, long long n, Op op = Op(), T e = {1}) {\n  assert(n >= 0);\n  while (n) {\n    if (n & 1) e = op(e, a);\n    if (n >>= 1) a = op(a, a);\n  }\n  return e;\n}\n\nint f(int n) {\n  int res = 0, b = 1;\n  while (n) {\n    int r = n % 3;\n    res += (r ? 3 - r : 0) * b;\n    b *= 3;\n    n /= 3;\n  }\n  return res;\n}\n\nvector<int> solve(int n, string s) {\n  reverse(begin(s), end(s));\n  int m = power(3, n);\n  vector<int> p(m, -1);\n  auto to = [&](int i) {\n    for (char c : s) {\n      if (c == 'S') {\n        i = f(i);\n      } else {\n        i = (i + m - 1) % m;\n      }\n    }\n    return i;\n  };\n  p[0] = to(0);\n  for (int k = 0; k < n; ++k) {\n    p[power(3, k)] = to(power(3, k));\n    p[2 * power(3, k)] = to(2 * power(3, k));\n  }\n  for (int i = 0; i < m; ++i) {\n    if (p[i] != -1) continue;\n    // p[i] = to(i);\n    // continue;\n    p[i] = i;\n    int cur = i;\n    for (int k = n; k--; ) {\n      if (cur >= 2 * power(3, k)) {\n        cur -= 2 * power(3, k);\n        p[i] = p[cur] + p[2 * power(3, k)] - p[0] + m;\n        p[i] %= m;\n        break;\n      } else if (cur >= power(3, k)) {\n        p[i] = p[cur] + p[power(3, k)] - p[0] + m;\n        p[i] %= m;\n        cur -= power(3, k);\n        break;\n      }\n    }\n  }\n  return p;\n  vector<int> res(m);\n  for (int i = 0; i < m; ++i) {\n    res[p[i]] = i;\n  }\n  return res;\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  string s;\n  cin >> s;\n  auto res = solve(n, s);\n  int m = size(res);\n  for (int i = 0; i < m; ++i) {\n    cout << res[i] << \" \\n\"[i == m - 1];\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i, x, y) for(int i = (x); i < (y); ++i)\n#define REP(i, x, y) for(int i = (x); i <= (y); ++i)\n#define MP make_pair\n#define PB push_back\n#define PH push\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9 + 7;\nconst int maxn = 13;\nconst int maxp = 2e6 + 5;\nconst int maxm = 2e5 + 5;\n\nint n, m;\nint pw[maxn], ans[maxn];\nchar t[maxm];\n\nclass Trie{\npublic:\n\tint tot;\n\tint p[maxp], ch[maxp][3], tag[maxp];\n\tTrie(){\n\t\ttot = 1;\n\t\tmemset(ch, -1, sizeof(ch));\n\t\tmemset(p, -1, sizeof(p));\n\t\treturn;\n\t}\n\tinline void insert(int x){\n\t\tint u = 0, y = x;\n\t\tfor(int i = 0; i < n; ++i, x /= 3){\n\t\t\tif(!~ch[u][x % 3])\n\t\t\t\tch[u][x % 3] = tot++;\n\t\t\tu = ch[u][x % 3];\n\t\t}\n//\t\tprintf(\"u = %d y = %d\\n\", u, y);\n\t\tp[u] = y;\n\t\treturn;\n\t}\n\tinline void inv(int u){\n\t\ttag[u] ^= 1;\n\t\tswap(ch[u][1], ch[u][2]);\n\t\treturn;\n\t}\n\tinline void pushDown(int u){\n\t\tif(tag[u]){\n\t\t\tFOR(i, 0, 3)\n\t\t\t\tinv(ch[u][i]);\n\t\t\ttag[u] = false;\n\t\t}\n\t\treturn;\n\t}\n\tinline void update(int dep, int u){\n//\t\tprintf(\"dep = %d u = %d\\n\", dep, u);\n\t\tif(dep > n || !~u)\n\t\t\treturn;\n\t\tpushDown(u);\n\t\tint tmp = ch[u][2];\n\t\tch[u][2] = ch[u][1];\n\t\tch[u][1] = ch[u][0];\n\t\tch[u][0] = tmp;\n\t\tupdate(dep + 1, ch[u][0]);\n\t\treturn;\n\t}\n\tinline void dfs(int dep, int u, int x){\n\t\tif(dep > n || !~u)\n\t\t\treturn;\n//\t\tprintf(\"dep = %d u = %d x = %d\\n\", dep, u, x);\n\t\tpushDown(u);\n\t\tFOR(i, 0, 3)\n\t\t\tdfs(dep + 1, ch[u][i], x + i * pw[dep]);\n\t\tif(~p[u])\n\t\t\tans[p[u]] = x;\n\t\treturn;\n\t}\n}trie;\n\ninline void precalc(){\n\tpw[0] = 1;\n\tFOR(i, 1, maxn)\n\t\tpw[i] = pw[i - 1] * 3;\n\treturn;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tprecalc();\n\tscanf(\"%s\", t);\n\tm = strlen(t);\n\tFOR(i, 0, pw[n])\n\t\ttrie.insert(i);\n\tFOR(i, 0, m){\n\t\tif(t[i] == 'S')\n\t\t\ttrie.inv(0);\n\t\telse\n\t\t\ttrie.update(0, 0);\n\t}\n\ttrie.dfs(0, 0, 0);\n\tFOR(i, 0, pw[n])\n\t\tprintf(\"%d \", ans[i]);\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\ntypedef pair<i64, i64> pi64;\ntypedef double ld;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nvoid append(string &t, char c) {\n    if (c == 'S' && !t.empty() && t.back() == 'S') t.resize(t.size() - 1);\n    else t += c;\n}\n\nint n;\nconst int maxn = 600000;\nint ans[maxn];\n\nvoid process(int b, int d3, int from, int to, const string &s) {\n    if (b == n) {\n        ans[from] = to;\n        return;\n    }\n    vector<string> vs(3);\n    int go[3];\n    forn(i, 3) go[i] = i;\n    for (char c: s) {\n        if (c == 'S') forn(j, 3) {\n            go[j] = (3 - go[j]) % 3;\n            append(vs[j], c);\n        } else forn(j, 3) {\n            go[j] = (go[j] + 1) % 3;\n            if (go[j] == 0) append(vs[j], c);\n        }\n    }\n    forn(j, 3) process(b + 1, d3 * 3, from + d3 * j, to + d3 * go[j], vs[j]);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    string s;\n    cin >> n >> s;\n    process(0, 1, 0, 0, s);\n    int d3 = 1;\n    forn(i, n) d3 *= 3;\n    forn(i, d3) cout << ans[i] << ' ';\n    cout << '\\n';\n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(void){\n    int N;\n    char[200000] T;\n    gets(T);\n    if(T==\"SRS\"){\n        printf(\"2 0 1\");\n    }\n    else if(T==\"RRSRSSSSR\"){\n    printf(3 8 1 0 5 7 6 2 4);\n    }\n    else{\n        printf(\"23 9 22 8 3 7 20 24 19 5 18 4 17 12 16 2 6 1 14 0 13 26 21 25 11 15 10\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <string>\n#include <algorithm>\n#include <utility>\n#define inf 1e18\n#define rep(x, s, t) for(int (x) = (s); (x) < (t); (x)++)\n#define Rep(x, s, t) for(int (x) = (s); (x) <= (t); (x)++)\n#define chmin(x, y) (x) = min((x), (y))\n#define chmax(x, y) (x) = max((x), (y))\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n;\nstring s;\nint beki[15];\nint carry[200005];\nint dest[600005], ndest[600005];\nbitset<600005> bs[3];\n\nint main(void)\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n;\n\tcin >> s;\n\t\n\tbeki[0] = 1;\n\tfor(int i = 1; i < 15; i++) beki[i] = beki[i-1] * 3;\n\t\n\tfor(int i = 0; i < 3; i++){\n\t\tint p = i;\n\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\tif(s[j] == 'R'){\n\t\t\t\tif(p == 2) carry[j] = i;\n\t\t\t\tp = (p+1) % 3;\n\t\t\t}\n\t\t\telse p = (3-p)%3;\n\t\t}\n\t\tdest[i] = p;\n\t}\n\t\n\tfor(int i = 1; i < n; i++){\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tfor(int k = 0; k < beki[i+1]; k++) bs[j][k] = false;\n\t\t\tfor(int k = 0; k < beki[i]; k++) bs[j][j*beki[i]+k] = true;\n\t\t}\n\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\tif(s[j] == 'S') swap(bs[1], bs[2]);\n\t\t\telse{\n\t\t\t\tint tmp[3];\n\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\tfor(int l = 0; l < 3; l++){\n\t\t\t\t\t\tint x = l*beki[i]+carry[j];\n\t\t\t\t\t\tif(bs[k][x]){\n\t\t\t\t\t\t\ttmp[k] = x;\n\t\t\t\t\t\t\tif(k == 2) carry[j] = x;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\tbs[k][tmp[k]] = false;\n\t\t\t\t\tbs[(k+1)%3][tmp[k]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tfor(int k = 0; k < beki[i+1]; k++){\n\t\t\t\tif(bs[j][k]) ndest[k] = dest[k%beki[i]] + j*beki[i];\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < beki[i+1]; j++) dest[j] = ndest[j];\n\t}\n\t\n\tfor(int i = 0; i < beki[n]; i++) cout << dest[i] << \" \"; cout << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef int ll;\ntypedef pair<ll,ll> pl;\nconst ll asize=6e5;\nint m[asize],tpow[15]={1},a[asize],a2[asize],dn[asize],aa[asize];\n\nint main() {\n\tios_base::sync_with_stdio(0),cin.tie(NULL);\n\tll n;\n\tcin>>n;\n\tfor(int i=1;i<=12;i++){\n\t\ttpow[i]=tpow[i-1]*3;\n\t}\n\tll lim=tpow[n];\n\tfor(int i=0;i<lim;i++)a[i]=i;\n\tstring s=\"000000000000\";\n\tfor(int i=0;i<lim;i++){\n\t\tll match=0;\n\t\tfor(int j=0;j<12;j++){\n\t\t\tint k=11-j;\n\t\t\tif(s[j]=='1')match+=2*tpow[k];\n\t\t\telse if(s[j]=='2')match+=tpow[k];\n\t\t}\n\t\ts.back()++;\n\t\tif(m[i]!=0)dn[i]=1;\n\t\tm[i]=match,m[match]=i;\n\t\tfor(int j=0;j<12;j++){\n\t\t\tint k=11-j;\n\t\t\tif(s[k]=='3')s[k]='0',s[k-1]++;\n\t\t}\n\t}\n\tcin>>s;\n\tvector<pair<char,int> >v;\n\tfor(auto x:s){\n\t\tif(v.empty()||v.back().first!=x)v.emplace_back(x,1);\n\t\telse v.back().second++;\n\t}\n\tfor(int i=0;i<lim;i++){\n\t\tint pos=i;\n\t\tfor(auto x:v){\n\t\t\tif(x.first=='S'){\n\t\t\t\tif(x.second%2==1)pos=m[pos];\n\t\t\t}\n\t\t\telse pos+=x.second,pos%=lim;\n\t\t}\n\t\tcout<<pos<<\" \";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#define int long long\n \n#define pii pair<int, int>\n \n#define x1 x1228\n#define y1 y1228\n \n#define left left228\n#define right right228\n \n#define next next228\n \n#define pb push_back\n#define eb emplace_back\n \n#define mp make_pair                                                                \n                                                                                                                                        \n#define ff first                                                                  \n#define ss second   \n \n#define all(x) x.begin(), x.end()\n#define debug(x) cout << #x << \": \" << x << endl; \n#define TIME (ld)clock()/CLOCKS_PER_SEC\n \nusing namespace std;\ntypedef long long ll; \ntypedef long double ld; \n                                                                                                   \nconst int maxn = 2e5 + 7, mod = 1e9 + 7, MAXN = 1e6 + 7;\nconst double eps = 1e-9;\nconst ll inf = 1e18;\nmt19937 rnd(time(0));\nint n; \nstring s; \nint next[MAXN];\nconst int N = 2187; \nint dp1[N]; \nint dp2[N]; \nint xyz[N]; \n \nint get1(int mask, char q) {\n    if (q == 'R') {\n        ++mask; \n        return mask; \n    }   \n    int ptr = 1; \n    int ans = 0; \n    while (mask) {\n        int t = mask % 3; \n        mask /= 3; \n        if (t == 2) ans += ptr; \n        if (t == 1) ans += 2 * ptr; \n        ptr *= 3; \n    }\n    return ans; \n}\n \nconst int L = 12; \nint pref[maxn]; \nint to[maxn]; \nint kek1[N], kek2[N]; \nint res[N], res1[N]; \nint add = 1; \n \nint get(int x) {\n    vector<int> bts; \n    for (int i = 0; i < L; ++i) {\n        bts.pb(x % 3); \n        x /= 3; \n    }\n    int left = 0;\n    int right = 0; \n    for (int i = 6; i >= 0; --i) {\n        left *= 3;\n        left += bts[i]; \n    }\n    for (int i = L - 1; i >= 7; --i) {\n        right *= 3; \n        right += bts[i]; \n    }\n//    cout << left << \" \" << right << '\\n'; \n    int id = 0;         \n    if (left && dp1[left] == -1) {\n        if (pref[(int)s.size()] & 1) right = xyz[right];   \n        return res[left] + add * right;   \n    }\n    if (left) {    \n        id = dp1[left]; \n        if (pref[id] & 1) right = xyz[right];             \n        left = 0; \n    }                     \n    while (next[id] != -1) {        \n        if ((pref[next[id]] - pref[id]) & 1) right = xyz[right]; \n        id = next[id];                                                                                                                                         \n    }\n    left = to[id]; \n    return left + right * add; \n}\n \nvoid solve() {\n    for (int i = 0; i < N; ++i) {\n        xyz[i] = get1(i, 'S') % N; \n    }\n    cin >> n >> s; \n    int t = s.size(); \n    for (int i = 0; i < t; ++i) {\n        pref[i + 1] = pref[i] + (s[i] == 'S'); \n    }\n \n    for (int i = 0; i < N; ++i) dp1[i] = dp2[i] = -1; \n    next[t] = -1;\n    for (int i = 0; i < N; ++i) kek1[i] = i;              \n    for (int i = 0; i < N; ++i) res[i] = i; \n    for (int i = t - 1; i >= 0; --i) {\n        for (int mask = 0; mask < N; ++mask) {\n            int mask1; \n            if (s[i] == 'S') mask1 = xyz[mask]; \n            else mask1 = mask + 1; \n            if (mask1 >= N) mask1 -= N; \n            res1[mask] = res[mask1]; \n            kek2[mask] = kek1[mask1];\n            if (mask && mask1 == 0) {\n                dp2[mask] = i + 1; \n            } else {\n                dp2[mask] = dp1[mask1]; \n            }   \n        }\n        to[i] = kek2[0]; \n        next[i] = dp2[0]; \n        for (int mask = 0; mask < N; ++mask) {\n            res[mask] = res1[mask]; \n            kek1[mask] = kek2[mask]; \n            dp1[mask] = dp2[mask]; \n            dp2[mask] = -1; \n        }\n    }\n    for (int i = 0; i < 7; ++i) add *= 3; \n    int tet = 1; \n    for (int i = 0; i < n; ++i) tet *= 3; \n    for (int ptr = 0; ptr < tet; ++ptr) {\n        cout << get(ptr) % tet << \" \"; \n    }\n//    cout << TIME; \n    return; \n}                                \n   \nsigned main() {\n#ifdef LOCAL\n    freopen(\"TASK.in\", \"r\", stdin);\n    freopen(\"TASK.out\", \"w\", stdout);\n#else \n    \n#endif // LOCAL\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20); \n    cout << fixed; \n    int t = 1; \n    for (int i = 0; i < t; ++i) {              \n        solve();\n    }\n    return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<string>\n#include<algorithm>\n#include<iostream>\n#include<bitset>\n#include<functional>\n#include<numeric>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cassert>\n#include<cmath>\n#include<random>\n#include<ctime>\n#include<complex>\nusing namespace std;\ntypedef long long LL;\nmt19937 gene(233);\ntypedef complex<double> Complex;\n#define fi first\n#define se second\n#define ins insert\n#define pb push_back\ninline char GET_CHAR(){\n\tconst int maxn = 131072;\n\tstatic char buf[maxn],*p1=buf,*p2=buf;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,maxn,stdin),p1==p2)?EOF:*p1++;\n}\ninline int getInt() {\n\tint res(0);\n\tchar c = getchar();\n\twhile(c < '0') c = getchar();\n\twhile(c >= '0') {\n\t\tres = res * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\treturn res;\n}\n\ninline int fastpo(int x, int n, int mod) {\n\tint res(1);\n\twhile(n) {\n\t\tif(n & 1) {\n\t\t\tres = res * (LL)x % mod;\n\t\t}\n\t\tx = x * (LL) x % mod;\n\t\tn /= 2;\n\t}\n\treturn res;\n}\n\ninline string itoa(int x, int width = 0) {\n  string res;\n  if(x == 0) res.push_back('0');\n  while(x) {\n    res.push_back('0' + x % 10);\n    x /= 10;\n  }\n  while((int)res.size() < width) res.push_back('0');\n  reverse(res.begin(), res.end());\n  return res;\n}\n\nconst int N = 59049 * 9;\nconst int LOG = 20;\nconst int mod = 1e9 + 7;\nconst int inf = 1e9 + 7;\nint n, m;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint s[N * 2][3], num[N * 2];\nint np = 0;\ninline void app(string & s) {\n\tif(!s.empty() && s.back() == 'S') {\n\t\ts.pop_back();\n\t}else s.push_back('S');\n}\nint build(int dep, int cur, int pw) {\n\tint res = ++np;\n\tif(dep < n) {\n\t\ts[res][0] = build(dep + 1, cur, pw * 3);\n\t\ts[res][1] = build(dep + 1, cur + pw, pw * 3);\n\t\ts[res][2] = build(dep + 1, cur + pw * 2, pw * 3);\n\t}else {\n\t\tnum[res] = cur;\n\t\t//cout << np << ' ' << cur << endl;\n\t}\n\treturn res;\n}\nint _ = 0;\nvoid process(int v, const string & t) {\n\tif(s[v][0] == 0) return;\n\t\n\t_ += t.size();\n\tstring s[3];\n\tfor(char c : t) {\n\t\tif(c == 'S') {\n\t\t\tfor(int d = 0; d < 3; d++) app(s[d]);\n\t\t\tswap(s[1], s[2]);\n\t\t\tswap(::s[v][1], ::s[v][2]);\n\t\t}else {\n\t\t\ts[2].push_back('R');\n\t\t\tswap(s[1], s[2]);\n\t\t\tswap(s[0], s[1]);\n\t\t\tswap(::s[v][1], ::s[v][2]);\n\t\t\tswap(::s[v][0], ::s[v][1]);\n\t\t}\n\t\t/*for(int d = 0; d < 3; d++) {\n\t\t\tprintf(\"s[%d][%d] = %d\\n\", v, d, ::s[v][d]);\n\t\t}*/\n\t}\n\tfor(int d = 0; d < 3; d++) {\n\t\tprocess(::s[v][d], s[d]);\n\t}\n}\nvector<int> ans;\nvoid dfs(int v, int cur, int pw) {\n\tif(s[v][0] == 0) {\n\t\tans[num[v]] = cur;\n\t}else {\n\t\tfor(int d = 0; d < 3; d++) {\n\t\t\t//printf(\"s[%d][%d] = %d\\n\", v, d, s[v][d]);\n\t\t\tdfs(s[v][d], cur + pw * d, pw * 3);\t\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tstring t;\n\tcin >> t;\n//t.clear();\n//for(int i = 0; i < 200000; i++) t.push_back(i % 2 ? 'S' : 'R');\n\tbuild(0, 0, 1);\n\tprocess(1, t);\n\tans.resize(fastpo(3, n, mod));\n\tdfs(1, 0, 1);\n\tfor(int i = 0; i < (int)ans.size(); i++) printf(\"%d%c\", ans[i], i == (int)ans.size() - 1 ? '\\n' : ' ');\n\t//cout << clock() << endl;\n\t//cout << _ << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,x,y,sw,pw3=1,A[531441]={0},B[531441]={0},S[531441]={0};\nchar T[200001];\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nsigned main(void)\n{\n  x=scanf(\"%d %s\",&N,T);\n  replace(T,\"SS\",\"\");\n  if(T[0]=='\\n')return 0;\n  rep(i,N)\n  {\n    sw=1;\n    rep(j,pw3)rep(k,3)B[j+k*pw3]=k;\n    rep(p,strlen(T))\n    {\n      if(T[p]=='R')\n      {\n        y=S[p];\n        rep(j,3){x=y+j*pw3;if(B[x]*sw==-1||B[x]*sw==2)S[p]=x;(B[x]+=(sw>0?1:2))%=3;}\n      }\n      else sw=-sw;\n    }\n    rep(j,pw3){y=A[j];rep(k,3){x=j+k*pw3;A[x]=y+((sw<0)?3-B[x]:B[x])%3*pw3;}}\n    pw3*=3;\n  }\n  rep(i,pw3)printf(\"%d%c\",A[i],i+1==pw3?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cassert>\n#include<stdexcept>\n#include<utility>\n#include<functional>\n#include<numeric>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<array>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<complex>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<bitset>\n#include<memory>\nusing namespace std;\nusing ll=long long;\n\nconst int SZ = 10;\nint n;\nint pow3n;\nvector<int> sal;\nvoid init_s(){\n    sal.resize(pow3n);\n    iota(sal.begin(),sal.end(),0);\n    for(int i=0;i<pow3n;i++){\n        int x = i;\n        int tar = 0;\n        int r = 1;\n        for(int j=0;j<n;j++){\n            tar+= (x%3*2)%3*r;\n            x/=3;\n            r*=3;\n        }\n        if(tar<i){\n            // cerr<<i<<\" \"<<tar<<endl;\n            swap(sal[tar],sal[i]);\n        }\n    }\n}\n\n\nvoid do_r(vector<int>& pat){\n    int head = pat[pow3n-1];\n    for(int i=pow3n-1;i>0;i--){\n        pat[i]=pat[i-1];\n    }\n    pat[0] = head;\n}\nint ary[100000];\nvoid perm(vector<int>& pat,vector<int>& par){\n    for(int i=0;i<pow3n;i++) ary[i] = pat[par[i]];\n    for(int i=0;i<pow3n;i++) pat[i] = ary[i];\n}\nvoid do_s(vector<int>& pat){\n    perm(pat,sal);\n}\nint main(){\n    cin>>n;\n    pow3n=1;\n    for(int i=0;i<n;i++) pow3n*=3;\n    init_s();\n    \n    string t;\n    {\n        string tmp;\n        cin>>tmp;\n        for(auto c:tmp){\n            if(!t.empty() && t.back()=='S' && c=='S') t.pop_back();\n            else t+=c;\n        }\n    }\n\n    vector<vector<int>> memo(1<<SZ);\n    \n    for(int bit=0;bit<(1<<SZ);bit++){\n        bool ispass= false;\n        for(int j=0;j+1<SZ;j++){\n            if(((bit>>j)&1)==0 && ((bit>>(j+1)))==0) ispass=true;\n        }\n        if(ispass) continue;\n\n        memo[bit].resize(pow3n);\n        iota(memo[bit].begin(),memo[bit].end(),0);\n        for(int j=0;j<SZ;j++){\n            if(((bit>>j)&1)==0) do_s(memo[bit]);\n            else do_r(memo[bit]);\n        }\n    }\n    vector<int> res(pow3n);\n    iota(res.begin(),res.end(),0);\n    \n    for(int i=0;i<t.size()/SZ;i++){\n        int bit = 0;\n        for(int j=0;j<SZ;j++){\n            if(t[i*SZ+j]=='R') bit+=(1<<j);\n        }\n        // cerr<<\"#\"<<i<<endl;\n        // for(int i=0;i<pow3n;i++) cerr<<res[i]<<\" \";\n        // cerr<<endl;\n        // for(int i=0;i<pow3n;i++) cerr<<memo[bit][i]<<\" \";\n        // cerr<<endl;\n        perm(res,memo[bit]);\n        // for(int i=0;i<pow3n;i++) cerr<<res[i]<<\" \";\n        // cerr<<endl;\n    }\n\n    for(int i=t.size()/SZ*SZ;i<t.size();i++){\n        // cerr<<\"#\"<<endl;\n        if(t[i]=='S') do_s(res);\n        else do_r(res);\n    }\n    vector<int> inv(pow3n);\n    for(int i=0;i<pow3n;i++) inv[res[i]]=i;\n    for(int i=0;i<pow3n;i++) cout<<inv[i]<<\" \";\n    cout<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nusing namespace std;\n\nint n, Q;\nstring s;\n\nvoid update(int x, vector<int> &d, vector<int> &salsas)\n{\n    if (salsas[x] != Q)\n    {\n        salsas[x] ^= 1;\n        if (d[x] == 1) d[x] = 2;\n        else if (d[x] == 2) d[x] = 1;\n    }\n}\n\npair<vector<int>, vector<int> > solve(vector<int> last_p, vector<int> last_w)\n{\n    vector<int> p(3 * last_p.size()), w;\n    int n = last_p.size();\n\n    vector<int> d(3 * last_p.size());\n    vector<int> salsas(3 * last_p.size());\n    for (int i = 0; i < n; i++) d[i] = 0;\n    for (int i = n; i < 2 * n; i++) d[i] = 1;\n    for (int i = 2 * n; i < 3 * n; i++) d[i] = 2;\n\n    for (int i = 0; i < s.size(); i++)\n    {\n        int x = last_w[i];\n\n        update(x, d, salsas);\n        update(x + n, d, salsas);\n        update(x + 2 * n, d, salsas);\n\n        if (d[x] == 2) w.push_back(x);\n        if (d[n + x] == 2) w.push_back(n + x);\n        if (d[2 * n + x] == 2) w.push_back(2 * n + x);\n        if (s[i] == 'S')\n        {\n            Q ^= 1;\n        }\n        else\n        {\n            int x = last_w[i];\n            d[x] = (d[x] + 1) % 3;\n            d[n + x] = (d[n + x] + 1) % 3;\n            d[2 * n + x] = (d[2 * n + x] + 1) % 3;\n        }\n    }\n\n    for (int i = 0; i < 3 * n; i++) update(i, d, salsas);\n    for (int i = 0; i < 3 * n; i++)\n    {\n        p[i] = last_p[i % n] + d[i] * n;\n    }\n\n    return {p, w};\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n    cin >> n;\n    cin >> s;\n\n    vector<int> last_p = {0, 1, 2};\n    vector<int> last_w;\n    for (int i = 0; i < s.size(); i++)\n    {\n        for (int j = 0; j < 3; j++) if (last_p[j] == 2) last_w.push_back(j);\n        if (s[i] == 'S')\n        {\n            int t = 1;\n            for (int k = 0; t && k < 3; k++)\n            {\n                for (int j = 0; t && j < 3; j++)\n                {\n                    if (last_p[k] == 2 && last_p[j] == 1)\n                    {\n                        swap(last_p[k], last_p[j]);\n                        t = 0;\n                    }\n                }\n            }\n        }\n        else\n        {\n            for (int j = 0; j < 3; j++) last_p[j] = (last_p[j] + 1) % 3;\n        }\n    }\n    for (int i = 1; i < n; i++)\n    {\n        pair<vector<int>, vector<int> > gg = solve(last_p, last_w);\n        last_p = gg.first;\n        last_w = gg.second;\n    }\n    #ifdef LOCAL\n    //return 0;\n    #endif // LOCAL\n    for (int i = 0; i < last_p.size(); i++)\n    {\n        cout << last_p[i] << \" \";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n\nusing namespace std;\n\nint N;\nstring T;\n\nvoid R(int *data);\nvoid S(int *data1, int *data2);\nint X(int x, int y);\n\nint main(){\n  int n;\n  string s;\n  cin >> n;\n  cin >> T;\n  N = X(3, n);\n  int L[N];\n  int K[N];\n  int O[N];\n  \n  for(int i=0;i<N;i++){\n    L[i] = i;\n  }\n  \n  for(int i=0;i<N/3;i++){\n    int k = i;\n    int tmp = 0;\n    int m = 3;\n    int q = i*3;\n    \n    while(k>0){\n      if(k%3==1){\n        tmp = tmp +2*m;\n      }else if(k%3==2){\n        tmp = tmp +1*m;\n      }\n      k = k/3;\n      m = m*3;\n    }\n    K[tmp] = q;\n    K[tmp + 1] = q+2;\n    K[tmp + 2] = q+1;\n  }\n  \n  \n  \n  for(int i=0;i<(int)(T.length());i++){\n    s = T[i];\n    if(s == \"S\"){\n      S(L, K);\n    }else{\n      R(L);\n    }\n  }\n  \n  \n  for(int i=0;i<N;i++){\n    O[L[i]] = i;\n  }\n  \n\n\n  for(int i=0;i<N;i++){\n    cout << O[i] << \" \";\n  }\n  return 0;\n}\n\nvoid R(int *data){\n  int tmp = data[N-1];\n  for(int i=0;i<N;i++){\n    int a = data[i];\n    data[i] = tmp;\n    tmp = a;\n  }\n}\nvoid S(int *data1, int *data2){\n  int T[N];\n  for(int i=0;i<N;i++){\n    T[i] = data1[data2[i]];     \n  }\n  data1 = T;\n}\n\n\nint X(int x,int y){\n  int a = 1;\n  for(int i=0;i<y;i++){\n    a = a*x;\n  }\n  return a;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <string>\n#include <vector> \n#include <algorithm>\n#include <functional>\n#include <map>\n#include <queue>\n#include <cmath>\n#include <limits>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing P = pair<int,int>;\n\nint main() {\n  //input\n  int n;\n  cin >> n;\n  string t;\n  cin >> t;\n\n  int arrcount = (int)pow(3,n);\n\n  //pattern making\n  int pattern[arrcount];\n  rep(x, arrcount) {\n    int tmp = x;\n    pattern[x] = 0;\n    string s = \"\";\n    //cout << pattern[i] << \"->\";\n    // to 3 shin\n    while(tmp > 0) {\n      int j = tmp % 3;\n      s = to_string(j) + s;\n      tmp = (tmp - j) / 3;\n    }\n    if(s == \"\") s = \"0\";\n    //cout << s << \"->\";\n    //translate\n    replace(s.begin(), s.end(), '2', 'x');\n    replace(s.begin(), s.end(), '1', '2');\n    replace(s.begin(), s.end(), 'x', '1');\n    //cout << s << \"->\";\n    // to 10 shin\n    int j = 1;\n    while(s.length()) {\n      //pattern[i] += m[(char)s.substr(s.length()-1)] * j;\n      pattern[x] += ((char)s.substr(s.length()-1)[0] - '0') * j;\n      s.erase(s.length()-1);\n      j *= 3;\n    }\n    //cout << pattern[i] << \" \";\n    //cout << endl;\n  }\n\n  int arr[arrcount];\n  rep(i,arrcount) arr[i] = i;\n  rep(i, t.length()) {\n    if(t[i] == 'S') {\n      //S\n\n      //int arrtmp[arrcount];\n      rep(i,arrcount) {\n        arr[i] = pattern[arr[i]];\n      }\n      //memcpy(arr, arrtmp, sizeof(arrtmp));\n    } else {\n      //R\n      rep(i,arrcount) {\n        arr[i]++;\n        if(arr[i] == arrcount) arr[i] = 0;\n      }\n      \n    }\n  }\n  \n  rep(i,arrcount) cout << arr[i] << \" \";\n  cout << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl \"\\n\"\n#define ll long long\n#define INF (ll)1e18\n#define fill treapdidsu\n\narray<ll, 12> b3(ll x) {\n    ll i, j, k;\n    array<ll, 12> res;\n    k = 0;\n    for (i = 0; i < 12; i++) {\n        res[i] = 0;\n    }\n    while (x != 0) {\n        res[k] = x % 3;\n        x /= 3;\n        k++;\n    }\n\n    return res;\n}\n\nll l3(ll x) {\n    ll i, j, k, p3;\n    ll res;\n    k = 0; p3 = 1;\n    res = 0;\n    while (x != 0) {\n        j = x % 3;\n        x /= 3;\n        if (j == 1) {\n            j = 2;\n        } else if (j == 2) {\n            j = 1;\n        }\n        res += (p3 * j);\n        k++; p3 *= 3;\n    }\n\n    return res;\n}\n\nll i, i1, j, k, k1, n, m, res, check1, a, b, s, p3, v[1000010], o[1000010];\nbool visited[1000010];\nstring t;\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n   // ifstream cin(\"input.txt\");\n   // ofstream cout(\"output.txt\");\n\n    cin >> n >> t;\n    s = t.size();\n    m = pow(3, n);\n    k = 0;\n    for (i = 0; i < m; i++) {\n        visited[i] = false;\n    }\n\n    p3 = 0;\n    for (i = 0; i <= n; i++) {\n        p3++;\n        k = p3;\n        for (j = 0; j < s; j++) {\n            // cout << j << ' ' << k << endl;\n            if (t[j] == 'S') {\n                k = l3(k);\n            } else {\n                k = (k + 1) % m;\n            }\n        }\n        // cout << endl;\n\n        v[p3] = k;\n        // cout << p3 << ' ' << k << endl;\n        p3--;\n        p3 *= 3;\n        if (p3 == 0) p3 = 1;\n    }\n\n    p3 = 1;\n    for (i = 0; i <= n; i++) {\n        p3++;\n        k = (m + v[p3] - v[1]) % m;\n        j = 2 * p3 + 1;\n        o[(j % m)] = (v[j - p3 + 1] + k) % m;\n        for (j = 3 * p3 - 1; j <= m; j += (p3 - 1)) {\n            o[(j % m)] = (o[j - p3 + 1] + k) % m;\n        }\n        p3--;\n        p3 *= 3;\n    }\n\n    /* for (i = 0; i < m; i++) {\n        cout << l3(i) << ' ';\n    }\n    cout << endl; */\n\n    for (i = 0; i < m; i++) {\n        cout << o[i] << ' ';\n    }\n    cout << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for (int i = x; i < (int)(n); ++i)\n\nint const N = 12, M = 200000, K = 531441;\nint n, p3[N + 1], an[K];\nchar s[M + 1];\n\nstruct S{\n\tint x;\n\tbool fl;\n\tS* g[3];\n\tS():fl(false) { f(i, 0, 3)g[i] = 0; }\n}*R;\n\nvoid pl(S* &v = R, int m = 0, int x = 0){\n\tv = new S();\n\tif (m == n){\n\t\tv->x = x;\n\t\treturn;\n\t}\n\tpl(v->g[0], m + 1, x);\n\tpl(v->g[1], m + 1, x + p3[m]);\n\tpl(v->g[2], m + 1, x + 2 * p3[m]);\n}\n\nvoid flp(S* v = R){\n\tswap(v->g[1], v->g[2]);\n\tv->fl ^= 1;\n}\n\nvoid sl(S* v){\n\tif (!v->fl)return;\n\tv->fl = false;\n\tflp(v->g[0]);\n\tflp(v->g[1]);\n\tflp(v->g[2]);\n}\n\nvoid ad(S* v = R){\n\tif (!v->g[0])return;\n\tsl(v);\n\tS* t = v->g[2];\n\tv->g[2] = v->g[1];\n\tv->g[1] = v->g[0];\n\tv->g[0] = t;\n\tad(t);\n}\n\nvoid fn(S* v = R, int m = 0, int x = 0){\n\tif (m == n){\n\t\tan[v->x] = x;\n\t\treturn;\n\t}\n\tfn(v->g[0], m + 1, x);\n\tfn(v->g[1], m + 1, x + p3[m]);\n\tfn(v->g[2], m + 1, x + 2 * p3[m]);\n}\n\nint main(){\n\tscanf(\"%d%s\", &n, s);\n\tp3[0] = 1;\n\tf(i, 1, n + 1)p3[i] = p3[i - 1] * 3;\n\tpl();\n\t\n\tint m = strlen(s);\n\tf(i, 0, m)if (s[i] == 'S')flp();\n\telse ad();\n\t\n\tfn();\n\tprintf(\"%d\", an[0]);\n\tf(i, 1, p3[n])printf(\" %d\", an[i]);\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxc = 1e7;\nint n, m = 1;\nchar s[200010];\nint ch[maxc + 10][3], val[maxc + 10][3];\nint ans[1000010];\nint ndcnt = 1;\nbool tag;\n\nint tr(int x) {\n\t//printf(\"{%d}\\n\", x);\n\tif (!tag) return x;\n\tif (!x) return 0;\n\treturn 3 - x;\n}\n\nvoid build(int p, int d) {\n\tif (d == n) return;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tch[p][i] = ++ndcnt;\n\t\tval[p][i] = i;\n\t\tbuild(ch[p][i], d + 1);\n\t}\n}\n\nvoid dfs(int p, int d) {\n\tif (d == n) return;\n\t/*\n\tprintf(\"[%d] \", p);\n\tfor (int i = 0; i < 3; ++i)\n\t\tprintf(\"{%d} \", val[p][i]);\n\tprintf(\"\\n\");\n\t*/\n\tfor (int i = 0; i < 3; ++i) {\n\t\tval[p][i] = tr((tr(val[p][i]) + 1) % 3);\n\t\tif (!tr(val[p][i])) dfs(ch[p][i], d + 1);\n\t}\n\t/*\n\tprintf(\"[%d] \", p);\n\tfor (int i = 0; i < 3; ++i)\n\t\tprintf(\"{%d} \", val[p][i]);\n\tprintf(\"\\n\");\n\t*/\n}\n\nvoid out(int p, int d, int v, int b, int now) {\n\tif (d == n) {\n//\t\tprintf(\"|%d %d|\\n\", now, v);\n\t\tans[now] = v; return;\n\t}\n\tfor (int i = 0; i < 3; ++i)\n\t\tout(ch[p][i], d + 1, v + b * tr(val[p][i]), b * 3, now + b * i);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tm *= 3;\n\tbuild(1, 0);\n\t/*\n\tout(1, 0, 0, 1, 0);\n\tfor (int i = 0; i < m; ++i)\n\t\tprintf(\"%d \", ans[i]);\n\treturn 0;\n\t*/\n\tscanf(\"%s\", s);\n\tfor (char *i = s; *i; ++i)\n\t\tif (*i == 'S') tag ^= 1;\n\t\telse dfs(1, 0);\n\tout(1, 0, 0, 1, 0);\n\tfor (int i = 0; i < m; ++i)\n\t\tprintf(\"%d \", ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n// #include <ext/pb_ds/assoc_container.hpp> \n// #include <ext/pb_ds/detail/standard_policies.hpp>\n// using namespace __gnu_pbds;\n\n#pragma GCC optimize(\"O3\")\n#ifdef LOCAL\n#include \"/Users/lbjlc/Desktop/coding/debug_utils.h\"\n#else\n#define print(...) ;\n#define printn(...) ;\n#define fprint(...) ;\n#define fprintn(...) ;\n#endif\n\n#define rep(i, a, b) for(auto i = (a); i < (b); i++)\n#define rrep(i, a, b) for(auto i = (a); i > (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define pb push_back\n// #define mp make_pair\n#define fi first\n#define se second\n#define maxi(x, y) x = max(x, y)\n#define mini(x, y) x = min(x, y)\n// long long fact(long long n) { if(!n) return 1; return n*fact(n-1); }\n// #define endl '\\n'\n#define solve_testcase int T;cin>>T;for(int t=1;t<=T;t++){solve(t);}\n\n// long long gcd(long long x, long long y) { return y ? gcd(y, x % y) : x; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\n \ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n \ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\ntypedef vector<long long> vll;\n#define bd(type,op,val) bind(op<type>(), std::placeholders::_1, val)\n\nconst int MAXN = 1e6+10;\n\n\nvoid solve(int tt) {\n    // cout<<\"Case #\"<<tt<<\": \";\n}\n\nstring to_ter(int x, int k=-1) {\n    string res;\n    while(x) {\n        res+='0'+x%3;\n        x/=3;\n    }\n    if(k>=0) {\n        while(res.size()<k) res+='0';\n    }\n    return res;\n}\nint to_int(const string & s) {\n    int res=0;\n    // rrep(i,s.size()-1,-1)\n    //     res=res*3+(s[i]-'0');\n    for(int i=s.size()-1;i>=0;i--)\n        res=res*3+(s[i]-'0');\n    // print(s,res);\n    return res;\n}\nbool add(string & x, const string & y) {\n    int n1=x.size(), n2=y.size(),carry=0;\n    rep(i,0,n1) {\n        if(i<n1) carry+=x[i]-'0';\n        if(i<n2) carry+=y[i]-'0';\n        x[i]=carry%3+'0';\n        carry/=3;\n    }\n    return carry==0;\n}\n\nvi cal_inst(string & s) {\n    int n=s.size();\n    vi res(1);\n    int i=0;\n    while(i<n) {\n        if(s[i]=='R') {\n            res.back()++;\n            i++;\n        }\n        else {\n            int j=i;\n            for(;j<n&&s[j]=='S';j++);\n            if((j-i)%2) res.pb(0);\n            i=j;\n        }\n    }\n    if(s.back()=='S') res.pop_back();\n    return res;\n}\n\nchar rev(char c) {\n    if(c>'0') return '0'+(3-(c-'0'));\n    return c;\n}\nstring rev(string s) {\n    for(auto & c:s) c=rev(c);\n    return s;\n}\n\nint len(string & s) {\n    int res=s.size()-1;\n    while(res>=0&&s[res]=='0') res--;\n    return res+1;\n}\n\nint power[13]={};\nint revmap[MAXN]={};\nint tmpres[MAXN];\nint rev(int x) {\n    for(int flag=1;flag<power[12];flag*=3) {\n        int tmp=x/flag%3;\n        if(tmp==1) x+=flag;\n        else if(tmp==2) x-=flag;\n    }\n    return x;\n}\n\nvoid cal(vi inst, int n, int tot) {\n    // vi tmpres(tot,-1);\n    fill(tmpres,tmpres+tot,-1);\n\n    rep(i,0,tot) {\n        if(tmpres[i]>=0) continue;\n\n        int cur=i,ok=1;\n        for(auto x:inst) {\n            cur+=x;\n            if(cur>=power[n]) {\n                ok=0; \n                cur%=power[n];\n            }\n            cur=revmap[cur];\n        }\n        // if(i<=9) print(i,cur);\n        tmpres[i]=cur;\n        // assert(cur>=0);\n        if(!ok) continue;\n        int flag=1,tmp;\n        for(;flag<=i||flag<=cur;flag*=3);\n\n        if(inst.size()%2==0) {\n            for(tmp=flag;tmp<power[n];tmp+=flag) {\n                tmpres[tmp+i]=tmp+cur;\n            }\n        }\n        else {\n            for(tmp=flag;tmp<power[n];tmp+=flag) {\n                tmpres[tmp+i]=revmap[tmp]+cur;\n            }\n\n        }\n    }\n    // print(1);\n    // print(*max_element(all(res)),*min_element(all(res)));\n    // return res;\n}\n\nint main(int argc, char * argv[]) {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    // solve_testcase;\n\n    int n;\n    string s;\n    cin>>n;\n    cin>>s;\n\n    // n=12;\n    // rep(i,0,1e5) s+=\"RS\";\n\n    power[0]=1;\n    rep(i,1,13) power[i]=power[i-1]*3;\n\n    int tot=1;\n    rep(i,0,n) tot*=3;\n\n    rep(i,0,tot) {\n        if(i>=3) {\n            if(i%3==0)\n                revmap[i]=revmap[i/3]*3;\n            else\n                revmap[i]=revmap[i-i%3]+rev(i%3);\n        }\n        else\n            revmap[i]=rev(i);\n    }\n    // printn(revmap,9);\n\n\n    vi inst=cal_inst(s);\n    for(auto & x:inst) x%=tot;\n\n    // print(inst);\n\n    int i=0;\n    int bound=241;\n    vi res(tot);\n    iota(all(res),0);\n    while(i<inst.size()) {\n        int cur=inst[i];\n        vi cur_inst({cur});\n        for(++i;i<inst.size()&&cur<bound;i++) {\n            cur+=inst[i];\n            cur_inst.pb(inst[i]);\n        }\n        cal(cur_inst,n,tot);\n        // print(tmp);\n        rep(j,0,tot) res[j]=tmpres[res[j]];\n        // print(cur_inst,tmp);\n        // print(res);\n        // sort(all(tmp)); print(tmp);\n    }\n    if(s.back()=='R') {\n        rep(i,0,tot) {\n            res[i]=revmap[res[i]];\n        }\n    }\n    for(auto x:res) cout<<x<<' ';\n    cout<<endl;\n\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i>=b;--i)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vec vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1,_2,name,...) name\n#define vv(a,b) vector<vector<int>>(a,vector<int>(b))\n#define vv2(a,b,c) vector<vector<int>>(a,vector<int>(b,c))\n#define vvl(a,b) vector<vector<ll>>(a,vector<ll>(b))\n#define vvl2(a,b,c) vector<vector<ll>>(a,vector<ll>(b,c))\n#define vvv(a,b,c) vector<vv(b,c)>(a)\n#define vvv2(a,b,c,d) vector<vv(b,c,d)>(a)\n#define vvvl(a,b,c) vector<vvl(b,c)>(a)\n#define vvvl2(a,b,c,d) vector<vvl(b,c,d)>(a)\n#define fi first\n#define se second\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance((c).begin(),lower_bound(all(c),(x)))\n#define ub(c,x) distance((c).begin(),upper_bound(all(c),(x)))\nusing namespace std;\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n#define Size(c) (int)(c).size()\n#define INT(...) int __VA_ARGS__;IN(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;IN(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;IN(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;IN(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;IN(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;IN(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;IN(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);IN(name)\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));IN(name)\nint scan(){ return getchar(); }\nvoid scan(int& a){ cin>>a; }\nvoid scan(long long& a){ cin>>a; }\nvoid scan(char &a){cin>>a;}\nvoid scan(double &a){ cin>>a; }\nvoid scan(long double& a){ cin>>a; }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid IN(){}\ntemplate <class Head, class... Tail> void IN(Head& head, Tail&... tail){ scan(head); IN(tail...); }\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\nvi iota(int n){vi a(n);iota(all(a),0);return a;}\ntemplate<class T> void UNIQUE(vector<T> &x){sort(all(x));x.erase(unique(all(x)),x.end());}\nint in() {int x;cin>>x;return x;}\nll lin() {unsigned long long x;cin>>x;return x;}\nvoid print(){putchar(' ');}\nvoid print(bool a){cout<<a;}\nvoid print(int a){cout<<a;}\nvoid print(long long a){cout<<a;}\nvoid print(char a){cout<<a;}\nvoid print(string &a){cout<<a;}\nvoid print(double a){cout<<a;}\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } cout<<endl;}\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ cout<<'(';print(p.first); cout<<\",\"; print(p.second);cout<<')'; }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ cout<<\" \"; print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nvector<pll> factor(ll x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nvector<int> divisor(int x){ vector<int> ans; for(int i=1;i*i<=x;i++)if(x%i==0){ans.pb(i);if(i*i!=x)ans.pb(x/i);} return ans;}\nint popcount(ll x){return __builtin_popcountll(x);}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n){return uniform_int_distribution<int>(0, n-1)(rng);}\n#define endl '\\n'\n\n#ifdef _LOCAL\n    #undef endl\n    #define debug(x) cout<<#x<<\": \";print(x);cout<<endl;\n    void err(){}\n    template<class T> void err(const T& t){ print(t);  cout<<\" \";}\n    template<class Head, class... Tail> void err(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\n    #define debug(x)\n    template<class... T> void err(const T&...){}\n#endif\n#pragma endregion\n\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include<ext/pb_ds/tag_and_trait.hpp>\nusing namespace __gnu_pbds;\n\n\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    INT(n);\n    int N = pow(3,n);\n    string s;cin>>s;\n    vector<int> v;\n    for(auto e:s){\n        if(e == 'S'){\n            if(!v.empty() and v.back()) v.pop_back();\n            else v.eb(1);\n        }\n        else v.pb(0);\n    }\n    vector<vec> p;\n    vector<int> w{0,1,2};\n    int m = v.size();\n    vector<vec> last(n);\n    rep(i,m){\n        rep(j,3) if(w[j] == 2)last[0].pb(j);\n        if(v[i]) for(auto &e:w) e = (3-e)%3;\n        else for(auto &e:w) e = (e+1)%3;\n\n    }\n    print(v);\n    p.pb(w);\n    rep2(i,1,n-1){\n        vector<int> now;\n        int T = pow(3,i);\n        rep(j,3)rep(_,T)now.pb(j);\n        int cnt = 0;\n        rep(j,m){\n            int pre = last[i-1][j];\n            rep(k,3){\n                if(now[pre + T*k] + cnt == 2) last[i].pb(pre + T * k);\n            }\n            if(v[j]){\n                // サルサ\n                cnt^=1;\n            }\n            else{\n                // ルンバ\n                if(cnt){\n                    int pre = last[i-1][j];\n                    rep(k,3){\n                        (now[pre+T*k]+=2)%=3;\n                    }\n                }\n                else{\n                    int pre = last[i-1][j];\n                    rep(k,3){\n                        (now[pre+T*k]+=1)%=3;\n                    }\n                }\n            }\n        }\n        if(cnt)\n        rep(i,T*3) now[i] = (3-now[i])%3;\n        p.pb(now);\n    }\n    vec ans(N);\n    rep(i,n){\n        int T = pow(3,i+1);\n        rep(j,N){\n            ans[j] += p[i][j%T] * T/3;\n        }\n    }\n    print(ans);\n\n        \n        \n            \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 12 + 5;\nconst int MAXM = 2e5 + 5;\nconst int MAXP = 1e6 + 5;\n\nint pw3[MAXN];\n\nstruct Node\n{\n\tint id;\n\tbool tag;\n\tNode* son[3];\n\t\n\tinline void push_down(void)\n\t{\n\t\tif(!tag) return;\n\t\ttag=0;\n\t\tswap(son[1],son[2]);\n\t\tfor(int i=0; i<3; ++i)\n\t\t\tson[i] -> tag ^= 1;\n\t}\n}p[MAXP];\nint pcnt=0;\n\nint n;\n\ninline void build(Node *&u,int dep,int now)\n{\n\tu = &p[++pcnt];\n\tif(dep==n)\n\t{\n\t\tu -> id = now;\n\t\treturn;\n\t}\n\tfor(int i=0; i<3; ++i)\n\t\tbuild(u -> son[i], dep+1, now + i*pw3[dep]);\n}\n\ninline void add(Node *u,int dep)\n{\n\tif(dep==n) return;\n\tu -> push_down();\n\t\n\tNode *tmp = u -> son[2];\n\tu -> son[2] = u -> son[1];\n\tu -> son[1] = u -> son[0];\n\tu -> son[0] = tmp;\n\t\n\tadd(u -> son[0], dep+1);\n}\n\nint ans[MAXP];\n\ninline void dfs(Node *u,int dep,int now)\n{\n\tif(dep==n)\n\t{\n\t\tans[u -> id] = now;\n\t\treturn;\n\t}\n\tu -> push_down();\n\tfor(int i=0; i<3; ++i)\n\t\tdfs(u -> son[i], dep+1, now + i*pw3[dep]);\n}\n\nint m;\nchar s[MAXM];\n\nint main(void)\n{\n\tscanf(\"%d%s\",&n,s+1);\n\tm = strlen(s+1);\n\t\n\tpw3[0]=1;\n\tfor(int i=1; i<=n; ++i) pw3[i] = pw3[i-1]*3;\n\t\n\tNode *root;\n\tbuild(root,0,0);\n\t\n\tfor(int i=1; i<=m; ++i)\n\t{\n\t\tif(s[i]=='S')\n\t\t\troot -> tag ^= 1;\n\t\telse add(root,0);\n\t}\n\t\n\tdfs(root,0,0);\n\tfor(int i=0; i<pw3[n]; ++i)\n\t\tprintf(\"%d \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\ncs int N = 6e5 + 50;\nint n, p[N]; char S[N];\nint ch[N][3], tag[N], vl[N], nd, pw[20];\nint build(int d, int v){\n\tif(!d) return vl[++nd]=v, nd; int x=++nd;\n\tch[x][0]=build(d-1, v);\n\tch[x][1]=build(d-1, v + pw[n-d]);\n\tch[x][2]=build(d-1, v + 2 * pw[n-d]); return x;\n}\nvoid put(int x){ if(!x) return; tag[x] ^= 1; swap(ch[x][1],ch[x][2]); }\nvoid down(int x){ if(tag[x]) put(ch[x][0]),put(ch[x][1]),put(ch[x][2]),tag[x]=0; }\nvoid work(int x, int d){\n\tif(!d) return;\n\tdown(x); int v = ch[x][2]; ch[x][2] = ch[x][1]; \n\tch[x][1] = ch[x][0]; ch[x][0] = v; \n\twork(v,d-1);\n}\nvoid dfs(int x, int d, int v=0){\n\tif(!d) return p[vl[x]] = v, void();\n\tdown(x); dfs(ch[x][0],d-1,v);\n\tdfs(ch[x][1],d-1,v + pw[n-d]);\n\tdfs(ch[x][2],d-1,v + 2 * pw[n-d]);\n}\nint main(){\n\t#ifdef FSYolanda\n\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tscanf(\"%d\",&n); pw[0]=1;\n\tfor(int i=1; i<=n; i++) pw[i]=pw[i-1]*3;\n\tscanf(\"%s\",S); int m=strlen(S);\n\tbuild(n,0);\n\tfor(int i=0; i<m; i++){\n\t\tif(S[i]=='R') work(1,n);\n\t\tif(S[i]=='S') put(1);\n\t} dfs(1,n); \n\tfor(int i=0; i<pw[n]; i++) cout << p[i] << \" \";\n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\nusing namespace std;\n\nint n, len, l[3*3*3*3*3*3*3*3*3*3*3*3];\nstring t;\n\nint calc(int a) {\n\tif (a < 3) {\n\t\treturn a % 3 - 1 + (a + 1) % 3;\n\t}\n\telse {\n\t\treturn a % 3 - 1 + (a + 1) % 3 + 3 * calc(a / 3);\n\t}\n}\n\nint main()\n{\n\tcin >> n;\n\tcin >> t;\n\tn = pow(3, n);\n\tfor (int i = 0; i < n; i++) {\n\t\tl[i] = i;\n\t}\n\tfor (int i = 0; i < t.size(); i++) {\n\t\tif (t[i] == 'S') {\n\t\t\tif (t[i + 1] == 'S') {\n\t\t\t\tt[i] = '0';\n\t\t\t\tt[i + 1] = '0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < t.size(); i++) {\n\t\tif (t[i] == 'S') {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tl[j] = calc(l[j]);\n\t\t\t}\n\t\t}\n\t\telse if(t[i] == 'R'){\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tl[j] = (l[j] + 1) % n;\n\t\t\t}\n\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << l[i] << \" \";\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region Macros\n#pragma GCC optimize(\"O3\")\n\n#include <bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i>=b;--i)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vec vector<int>\n#define vll vector<ll>\n#define vpi vector<pii>\n#define vpll vector<pll>\n#define overload2(_1,_2,name,...) name\n#define vv(a,b) vector<vector<int>>(a,vector<int>(b))\n#define vv2(a,b,c) vector<vector<int>>(a,vector<int>(b,c))\n#define vvl(a,b) vector<vector<ll>>(a,vector<ll>(b))\n#define vvl2(a,b,c) vector<vector<ll>>(a,vector<ll>(b,c))\n#define vvv(a,b,c) vector<vv(b,c)>(a)\n#define vvv2(a,b,c,d) vector<vv(b,c,d)>(a)\n#define vvvl(a,b,c) vector<vvl(b,c)>(a)\n#define vvvl2(a,b,c,d) vector<vvl(b,c,d)>(a)\n#define fi first\n#define se second\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance((c).begin(),lower_bound(all(c),(x)))\n#define ub(c,x) distance((c).begin(),upper_bound(all(c),(x)))\nusing namespace std;\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n#define Size(c) (int)(c).size()\n#define INT(...) int __VA_ARGS__;IN(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;IN(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;IN(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;IN(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;IN(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;IN(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;IN(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);IN(name)\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));IN(name)\nint scan(){ return getchar(); }\nvoid scan(int& a){ cin>>a; }\nvoid scan(long long& a){ cin>>a; }\nvoid scan(char &a){cin>>a;}\nvoid scan(double &a){ cin>>a; }\nvoid scan(long double& a){ cin>>a; }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid IN(){}\ntemplate <class Head, class... Tail> void IN(Head& head, Tail&... tail){ scan(head); IN(tail...); }\nstring stin() {string s;cin>>s;return s;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\nvi iota(int n){vi a(n);iota(all(a),0);return a;}\ntemplate<class T> void UNIQUE(vector<T> &x){sort(all(x));x.erase(unique(all(x)),x.end());}\nint in() {int x;cin>>x;return x;}\nll lin() {unsigned long long x;cin>>x;return x;}\nvoid print(){putchar(' ');}\nvoid print(bool a){cout<<a;}\nvoid print(int a){cout<<a;}\nvoid print(long long a){cout<<a;}\nvoid print(char a){cout<<a;}\nvoid print(string &a){cout<<a;}\nvoid print(double a){cout<<a;}\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } cout<<endl;}\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ cout<<\" \"; print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ cout<<'(';print(p.first); cout<<\",\"; print(p.second);cout<<')'; }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ cout<<\" \"; print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nvector<pll> factor(ll x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nvector<int> divisor(int x){ vector<int> ans; for(int i=1;i*i<=x;i++)if(x%i==0){ans.pb(i);if(i*i!=x)ans.pb(x/i);} return ans;}\nint popcount(ll x){return __builtin_popcountll(x);}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int n){return uniform_int_distribution<int>(0, n-1)(rng);}\n#define endl '\\n'\n\n#ifdef _LOCAL\n    #undef endl\n    #define debug(x) cout<<#x<<\": \";print(x);cout<<endl;\n    void err(){}\n    template<class T> void err(const T& t){ print(t);  cout<<\" \";}\n    template<class Head, class... Tail> void err(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\n    #define debug(x)\n    template<class... T> void err(const T&...){}\n#endif\n#pragma endregion\n\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include<ext/pb_ds/tag_and_trait.hpp>\nusing namespace __gnu_pbds;\n\n\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);cout<<fixed<<setprecision(15);\n    INT(n);\n    int N = pow(3,n);\n    string s;cin>>s;\n    vector<int> v;\n    for(auto e:s){\n        if(e == 'S'){\n            if(!v.empty() and v.back()) v.pop_back();\n            else v.eb(1);\n        }\n        else v.pb(0);\n    }\n    vector<vec> p;\n    vector<int> w{0,1,2};\n    int m = v.size();\n    vector<vec> last(n);\n    rep(i,m){\n        rep(j,3) if(w[j] == 2)last[0].pb(j);\n        if(v[i]) for(auto &e:w) e = (3-e)%3;\n        else for(auto &e:w) e = (e+1)%3;\n\n    }\n    p.pb(w);\n    rep2(i,1,n-1){\n        vector<int> now;\n        int T = pow(3,i);\n        rep(j,3)rep(_,T)now.pb(j);\n        int cnt = 0;\n        rep(j,m){\n            int pre = last[i-1][j];\n            rep(k,3){\n                if(now[pre + T*k] + cnt == 2) last[i].pb(pre + T * k);\n            }\n            if(v[j]){\n                // サルサ\n                cnt^=1;\n            }\n            else{\n                // ルンバ\n                if(cnt){\n                    int pre = last[i-1][j];\n                    rep(k,3){\n                        (now[pre+T*k]+=2)%=3;\n                    }\n                }\n                else{\n                    int pre = last[i-1][j];\n                    rep(k,3){\n                        (now[pre+T*k]+=1)%=3;\n                    }\n                }\n            }\n        }\n        if(cnt)\n        rep(i,T*3) now[i] = (3-now[i])%3;\n        p.pb(now);\n    }\n    vec ans(N);\n    rep(i,n){\n        int T = pow(3,i+1);\n        rep(j,N){\n            ans[j] += p[i][j%T] * T/3;\n        }\n    }\n    print(ans);\n\n        \n        \n            \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n#include \"debug.h\"\n#else\n#define DEBUG(...)\n#endif\n\ntemplate <class T, class Op = multiplies<T>>\nconstexpr T power(T a, long long n, Op op = Op(), T e = {1}) {\n  assert(n >= 0);\n  while (n) {\n    if (n & 1) e = op(e, a);\n    if (n >>= 1) a = op(a, a);\n  }\n  return e;\n}\n\nint f(int n) {\n  int res = 0, b = 1;\n  while (n) {\n    int r = n % 3;\n    res += (r ? 3 - r : 0) * b;\n    b *= 3;\n    n /= 3;\n  }\n  return res;\n}\n\nvector<int> solve(int n, string s) {\n  reverse(begin(s), end(s));\n  int m = power(3, n);\n  vector<int> p(m, -1);\n  auto to = [&](int i) {\n    for (char c : s) {\n      if (c == 'S') {\n        i = f(i);\n      } else {\n        if (--i < 0) {\n          i += m;\n        }\n      }\n    }\n    return i;\n  };\n  p[0] = to(0);\n  for (int k = 0; k < n; ++k) {\n    for (int i : {1, 2}) {\n      p[i * power(3, k)] = to(i * power(3, k));\n    }\n  }\n  for (int i = 0; i < m; ++i) {\n    if (p[i] != -1) continue;\n    for (int k = n; k--; ) {\n      if (i >= 2 * power(3, k)) {\n        p[i] = p[i - 2 * power(3, k)] + p[2 * power(3, k)] - p[0] + 2 * power(3, k + 1);\n        p[i] += m;\n        p[i] %= m;\n        break;\n      }\n      if (i >= power(3, k)) {\n        p[i] = p[i - power(3, k)] + p[power(3, k)] - p[0] + power(3, k + 1);\n        p[i] += m;\n        p[i] %= m;\n        break;\n      }\n    }\n  }\n  vector<int> res(m);\n  for (int i = 0; i < m; ++i) {\n    res[p[i]] = i;\n  }\n  return res;\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  string s;\n  cin >> s;\n  auto res = solve(n, s);\n  int m = size(res);\n  for (int i = 0; i < m; ++i) {\n    cout << res[i] << \" \\n\"[i == m - 1];\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define ENABLE_DEBUG 0\n// Kana's kitchen {{{\n#include<bits/stdc++.h>\n#define ALL(v) std::begin(v),std::end(v)\n#define LOOP(k) for(i64 ngtkana_is_a_genius=0; ngtkana_is_a_genius<(i64)k; ngtkana_is_a_genius++)\n\nusing i32 = std::int_least32_t;\nusing i64 = std::int_least64_t;\nusing u32 = std::uint_least32_t;\nusing u64 = std::uint_least64_t;\nusing usize = std::size_t;\n\ntemplate <class T> using vec = std::vector<T>;\ntemplate <class T> using numr = std::numeric_limits<T>;\n\n#ifdef NGTKANA\n#include<debug.hpp>\n#else\n#define DEBUG(...)(void)0\n#endif\n/*}}}*/\n// mint{{{\ntemplate <class ModType> struct modint {\n    using value_type = typename ModType::value_type;\n    using mint = modint<ModType>;\n    using mod_type = ModType;\n\n    static value_type mod() { return ModType::value; }\n\n    private:\n    static value_type inverse(value_type x) {\n        value_type y=1,u=mod(),v=0;\n        while(x){\n            value_type q=u/x;\n            u-=q*x; std::swap(x,u);\n            v-=q*y; std::swap(y,v);\n        }\n        assert(x==0 && std::abs(y)==mod() && std::abs(u)==1 && std::abs(v)<mod());\n        return v<0?v+mod():v;\n    }\n\n    public:\n    // the member variable\n    value_type value;\n\n    // constructors\n    modint()=default;\n    modint(modint const&)=default;\n    modint(modint&&)=default;\n    modint& operator=(modint const&)=default;\n    modint& operator=(modint&&)=default;\n    ~modint()=default;\n\n    template <class T> modint(T t) : value([t] () mutable {\n            if ( t <= -static_cast<T>(mod()) || static_cast<T>(mod()) <= t ) t %= mod();\n            return t < 0 ? t + mod() : t;\n            }()) {}\n\n    // operators\n    mint& operator+= (mint y) {\n        value += y.value;\n        if (mod() <= value) value -= mod();\n        return *this;\n    }\n\n    mint& operator-= (mint y) {\n        value -= y.value;\n        if ( value < 0 ) value += mod();\n        return *this;\n    }\n\n    mint& operator*= (mint y) {\n        value = (long long)value * y.value % mod();\n        return *this;\n    }\n\n    mint& operator/= (mint y) {\n        value = (long long)value * inverse(y.value) % mod();\n        return *this;\n    }\n\n    mint& operator++() { return *this+=1; }\n    mint& operator--() { return *this-=1; }\n    mint  operator++(int) { mint this_=*this; ++*this; return this_; }\n    mint  operator--(int) { mint this_=*this; --*this; return this_; }\n\n    // static member functions\n    static mint inv(mint x) { return inverse(x.value); }\n\n    static mint m1pow(long long y) { return y%2?-1:1; }\n\n    static mint pow(mint x, unsigned long long y) {\n        mint ans=1;\n        for(;y;y>>=1){\n            if(y&1ull) ans*=x;\n            x*=x;\n        }\n        return ans;\n    }\n\n    // non-member functions\n    mint& add_assign(mint y) { return *this+=y; }\n    mint& sub_assign(mint y) { return *this-=y; }\n    mint& mul_assign(mint y) { return *this*=y; }\n    mint& div_assign(mint y) { return *this/=y; }\n    mint& inv_assign()       { return *this = inv(*this); }\n    mint& pow_assign(unsigned long long y){ return *this = pow(*this, y); }\n\n    mint add(mint y) { mint ans=*this; return ans.add_assign(y); }\n    mint sub(mint y) { mint ans=*this; return ans.sub_assign(y); }\n    mint mul(mint y) { mint ans=*this; return ans.mul_assign(y); }\n    mint div(mint y) { mint ans=*this; return ans.div_assign(y); }\n    mint inv()       { mint ans=*this; return ans.inv_assign(); }\n    mint pow(unsigned long long y) { return pow(*this, y); }\n\n    template <class F> mint map(F const& f){\n        value=f(value);\n        return *this;\n    }\n};\n\n    template <class T> std::istream&\noperator>>(std::istream& is, modint<T>& x)\n{\n    typename modint<T>::value_type y;\n    is >> y;\n    x = modint<T>{ y };\n    return is;\n}\n    template <class T> std::ostream&\noperator<<(std::ostream& os, modint<T> x)\n{\n    return os << x.value;\n}\n\ntemplate <class T> modint<T> operator+(modint<T> x, modint<T> y) { return x+=y; }\ntemplate <class T> modint<T> operator-(modint<T> x, modint<T> y) { return x-=y; }\ntemplate <class T> modint<T> operator*(modint<T> x, modint<T> y) { return x*=y; }\ntemplate <class T> modint<T> operator/(modint<T> x, modint<T> y) { return x/=y; }\ntemplate <class T> bool operator==(modint<T> x, modint<T> y) { return x.value==y.value; }\ntemplate <class T> bool operator!=(modint<T> x, modint<T> y) { return x.value!=y.value; }\n\ntemplate <class T, class U> modint<T> operator+(modint<T> x, U y) { return x+modint<T>(y); }\ntemplate <class T, class U> modint<T> operator-(modint<T> x, U y) { return x-modint<T>(y); }\ntemplate <class T, class U> modint<T> operator*(modint<T> x, U y) { return x*modint<T>(y); }\ntemplate <class T, class U> modint<T> operator/(modint<T> x, U y) { return x/modint<T>(y); }\ntemplate <class T, class U> bool operator==(modint<T> x, U y) { return x==modint<T>(y); }\ntemplate <class T, class U> bool operator!=(modint<T> x, U y) { return x!=modint<T>(y); }\n\ntemplate <class T, class U> modint<T> operator+(U x, modint<T> y) { return modint<T>(x)+y; }\ntemplate <class T, class U> modint<T> operator-(U x, modint<T> y) { return modint<T>(x)-y; }\ntemplate <class T, class U> modint<T> operator*(U x, modint<T> y) { return modint<T>(x)*y; }\ntemplate <class T, class U> modint<T> operator/(U x, modint<T> y) { return modint<T>(x)/y; }\ntemplate <class T, class U> bool operator==(U x, modint<T> y) { return modint<T>(x)==y; }\ntemplate <class T, class U> bool operator!=(U x, modint<T> y) { return modint<T>(x)!=y; }\n/*}}}*/\nusing mint = modint<std::integral_constant<i32, 3>>;\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n    std::cout << std::setprecision(15) << std::fixed;\n\n    usize n;\n    std::cin >> n;\n    vec<usize> tpow(n+1, 1);\n    for (usize i=0; i<n; i++) {\n        tpow.at(i+1) = tpow.at(i) * 3;\n    }\n    usize N = tpow.back();\n    DEBUG(n, N, tpow);\n\n    bool has_s = false;\n    vec<vec<mint>> sigma(n);\n    for (usize i=0; i<n; i++) {\n        sigma.at(i).resize(tpow.at(i));\n    }\n    DEBUG(matrix_style(sigma));\n\n    // apply-s{{{\n    auto apply_s = [&](usize a) {\n        for (usize k=0; k<n; k++) {\n            usize K = tpow.at(k);\n            usize r = a % (3*K);\n            if (K <= r && r < 2*K) {\n                a += K;\n            } else if (2*K <= r) {\n                a -= K;\n            }\n        }\n        return a;\n    };\n    /*}}}*/\n    // mul_r_from_the_left{{{\n    auto mul_r_from_the_left = [&] {\n        for (usize i=n-1; i!=-1; i--) {\n            usize I = tpow.at(i);\n            usize j = I - 1;\n            if (has_s) {\n                j = apply_s(j);\n            }\n            DEBUG(i, j);\n            for (usize k=0; k<i; k++) {\n                usize K = tpow.at(k);\n                usize r = j % (3*K);\n                usize val = sigma.at(k).at(r%K).value;\n                DEBUG(j,val);\n                j -= val * K;\n                if (r < val*K) j += 3*K;\n                DEBUG(j,val);\n            }\n            if (has_s) {\n                sigma.at(i).at(j)--;\n            } else {\n                sigma.at(i).at(j)++;\n            }\n        }\n    };\n/*}}}*/\n    // get-ans{{{\n    auto get_ans = [&] {\n        vec<usize> ans(N);\n        std::iota(ALL(ans), 0u);\n        for (usize j=0; j<N; j++) {\n            usize& a = ans.at(j);\n            for (usize k=n-1; k!=-1; k--) {\n                usize K = tpow.at(k);\n                usize r = a % (3*K);\n                usize val = sigma.at(k).at(r%K).value;\n                a += val * K;\n                if ((3-val)*K <= r) a -= 3*K;\n            }\n            if (has_s) {\n                a = apply_s(a);\n            }\n        }\n        return ans;\n    };\n/*}}}*/\n    DEBUG(get_ans());\n\n    std::string s;\n    std::cin >> s;\n    for (char c: s) {\n        DEBUG(c);\n        if (c=='S') {\n            has_s ^= 1;\n        }\n        if (c=='R') {\n            mul_r_from_the_left();\n        }\n        DEBUG(has_s);\n        DEBUG(matrix_style(sigma));\n        auto ans = get_ans(); DEBUG(ans);\n        DEBUG();\n    }\n\n    auto ans = get_ans();\n    for (usize i=0; i<N; i++) {\n        std::cout << (i?\" \":\"\") << ans.at(i);\n    }\n    std::cout << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n// #define inf  998244353\n\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int Gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return Gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn Gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                              \n                int pr[100000];\n                int inv[100000];\n                \n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=((ll)pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=(ll)inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n  \n\n\n  \n\nvoid solve(){\n\tvector<int> ve(1,0);\n\tint n;\n\tcin>>n;\n\tstring s;\n\tcin>>s;\n\tint m=s.length();\n\tvector<int> las(m+1,0);\n\t\n\tint san[15];\n\tsan[0]=1;\n\tfor(int i=0;i<13;i++)san[i+1]=san[i]*3;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tset<int> se[3];\n\t\tfor(int j=0;j<3;j++){\n\t\t\tfor(int k=j*san[i];k<(j+1)*san[i];k++)se[j].insert(k);\n\t\t}\n\t\tlas[0]+=2*san[i];\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(s[j]=='S'){\n\t\t\t\tswap(se[1],se[2]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint mae=las[j]%san[i];\n\t\t\t\tint tmp[3];\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tif(se[k].count(mae))tmp[k]=mae;\n\t\t\t\t\telse if(se[k].count(mae+san[i]))tmp[k]=mae+san[i];\n\t\t\t\t\telse tmp[k]=mae+san[i]*2;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tse[k].erase(tmp[k]);\n\t\t\t\t\tse[(k+1)%3].insert(tmp[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(se[2].count(las[j+1]+san[i]))las[j+1]+=san[i];\n\t\t\telse if(se[2].count(las[j+1]+san[i]*2))las[j+1]+=2*san[i];\n\t\t}\n\t\t\n\t\tint ss=ve.size();\n\t\tfor(int j=0;j<ss;j++)ve.pb(ve[j]);\n\t\tfor(int j=0;j<ss;j++)ve.pb(ve[j]);\n\t\t\n\t\tfor(auto j:se[1])ve[j]+=san[i];\n\t\tfor(auto j:se[2])ve[j]+=2*san[i];\n\t\t\n\t}\n\tfor(auto v:ve)cout<<v<<\" \";\n\tcout<<endl;\n}\n\n\nsigned main(){\n\t\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\nint n;\n\tn=1;\n\tfor(int i=0;i<n;i++)solve();\n\t\n\treturn 0;\n }\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string>\n#include<cmath>\n\nusing namespace std;\n\nint sch(int n){     \n    int out=0,tmp,count=0;\n    while(n != 0){\n        tmp = n % 3;\n        if(tmp==1){\n            out += 2*pow(3,count);\n        }else if(tmp==2){\n            out += pow(3,count);\n        }\n        count++;\n        n /= 3;\n    }\n    return out;\n}\n\nint main(){\n    int N,p,*table,size;\n    string T;\n    cin >> N;\n    cin >> T;\n    size = int(pow(3,N));\n    table = new int[size];\n    for(int i=0;i<size;i++){\n        if(i % 3 == 0){\n            table[i] = sch(i);\n        }else if(i % 3 == 1){\n            table[i] = table[i-1] + 2;\n        }else{\n            table[i] = table[i-1] -1 ;\n        }\n    }\n    //for(int i=0;i<size;i++) cout << i << ' ' <<table[i] << endl;;\n\n    for(int i=0;i<size;i++){\n        p=i;\n        for(int j=0;j<T.length();j++){\n            if(T[j] == 'S'){\n                if(T[j+1] == 'S') j++;\n                else p = table[p];\n            }else{\n                p++;\n                if(p==size) p=0;\n            }\n        }\n        cout << p << ' ';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nvector<int> dp(map<string, vector<int>>& next, string T, int pow3N){\n  auto it = next.find(T);\n  if(it!=next.end()){\n    return it->second;\n  }\n\n  auto rule1 = dp(next, T.substr(0, T.size()/2), pow3N);\n  auto rule2 = dp(next, T.substr(T.size()/2), pow3N);\n\n  next[T] = vector<int>(pow3N);\n  for(int ii=0; ii<pow3N; ii++){\n    next[T][ii] = rule2[rule1[ii]];\n  }\n  return next[T];\n}\n\nint main(){\n  int N;\n  string T;\n  cin >> N >> T;\n  int pow3N = pow(3, N);\n  map<string, vector<int>> next;\n  next[\"S\"] = vector<int>(pow3N);\n  next[\"R\"] = vector<int>(pow3N);\n\n  for(int ii=0; ii<pow3N; ii++){\n    int tmp=ii;\n    int jj=0;\n    int aa=1;\n    while(tmp){\n      int kk = tmp % 3;\n      tmp = (tmp - kk) / 3;\n      if(kk==1){\n        kk=2;\n      }else if(kk==2){\n        kk=1;\n      }\n      jj+=kk*aa;\n      aa*=3;\n    }\n    next[\"S\"][ii] = jj;\n    next[\"R\"][ii] = ii+1;\n  }\n  next[\"R\"][pow3N-1] = 0;\n\n  dp(next, T, pow3N);\n\n  for(auto& pos : next[T]){\n    cout << pos << \" \";\n  }\n  cout << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};\nvector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\nvector<ll> convert_base(ll n,ll m,ll base){\n\tvector<ll>ret(m,0);\n\tfor(ll i=0;i<m;i++){\n\t\tret[i]=n%base;\n\t\tn/=base;\n\t}\n\treturn ret;\n}\nll convert_base(vector<ll>v,ll base){\n  ll tmp=1,ret=0;\n  for(ll i=0;i<v.size();i++){\n    ret+=v[i]*tmp;\n    tmp*=base;\n  }\n  return ret;\n}\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n;cin>>n;\n  ll val=1;\n  rep(i,0,n)val*=3;\n  string t;cin>>t;\n  ll m=t.size();\n  auto fs=[&](ll x){\n    auto v=convert_base(x,n,3);\n    for(auto &z:v)if(z!=0)z^=3;\n    return convert_base(v,3);\n  };\n  vector<ll>v(val);\n  rep(i,0,3){\n    v[i]=i;\n    rep(j,0,m){\n      if(t[j]=='S')v[i]=fs(v[i]);\n      else v[i]=(v[i]+1)%val;\n      //debug(v,val);\n    }\n    //cout<<i spa v[i]<<endl;\n  }\n  if(n==1){\n    debug(v,3);\n    return 0;\n  }\n  rep(i,3,6){\n    v[i]=i;\n    rep(j,0,m){\n      if(t[j]=='S')v[i]=fs(v[i]);\n      else v[i]=(v[i]+1)%val;\n    }\n  }\n  rep(i,6,val){\n    //cout<<v[i] spa v[i-3] spa v[i-6]<<endl;\n    v[i]=(v[i-3]+(v[i-3]-v[i-6])+val)%val;\n  }\n  debug(v,val);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = pow(3, 12) + 100, maxm = 200010;\nint nxt[maxn], n, ans[maxn];\nint cnt = 1;\nstring w;\nvector<int> op;\nint gn(int val) {\n\tint res = 0;\n\twhile (val) {\n\t\tint v = val % 3 * 2;\n\t\tval /= 3;\n\t\tres += (val == 1 ? 2 : val == 2 ? 1 : 0);\n\t}\n\treturn res;\n}\nvoid init() {\n\tfor (int i = 0;i < cnt;++i) \n\t\tnxt[i] = gn(i), ans[i] = i;\n}\nvoid get_ans() {\n\tfor (int u : op) {\n\t\tfor (int i = 0;i < cnt;++i)\n\t\t\tans[i] = nxt[(ans[i] + u) % cnt];\n\t}\n\t\n}\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> n;\n\twhile (n--) cnt *= 3;\n\tinit();\n\tcin >> w;\n\tint len = 0, c = 0;\n\tfor (char i : w) {\n\t\tif (i == 'R') {\n\t\t\tif (c) op.pb(len), len = 0;\n\t\t\t++len;\n\t\t}\n\t\telse {\n\t\t\tc ^= 1;\n\t\t}\n\t}\n\tif (op.size() <= 300) get_ans();\n\tfor (int i = 0;i < cnt;++i)\n\t\tcout << (ans[i]+len) % cnt << ' ';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid update(int q, int& last, int& d) {\n    if (d != 0 and q%2 != last%2) d = 3-d;\n    last = q;\n}\n\npair<vector<int>, vector<int>> solve(int n, const string& T) {\n    if (n == 0) {\n        vector<int> P = {0};\n        vector<int> W(T.size(), 0);\n        return {P, W}; \n    }\n    auto pp = solve(n-1, T);\n    const auto& P = pp.first;\n    const auto& W = pp.second;\n    vector<int> new_W(W.size());\n    int pot = P.size();\n    vector<int> D(3*pot);\n    for (int i = 0; i < 3; i++) for (int x = 0; x < pot; x++) D[i*pot + x] = i;\n    vector<int> last(3*pot, 0);\n    int q = 0;\n    for (int i = 0; i < (int)T.size(); i++) {\n        int k = W[i];\n        for (int x = k; x < 3*pot; x += pot) {\n            update(q, last[x], D[x]);\n            if (D[x] == 2) new_W[i] = x;\n        }\n        if (T[i] == 'S') q++;\n        if (T[i] == 'R') {\n            for (int x = k; x < 3*pot; x += pot) D[x] = (D[x]+1)%3;\n        }\n    }\n\n    vector<int> new_P(3*pot);\n    for (int i = 0; i < 3*pot; i++) {\n        update(q, last[i], D[i]);\n        new_P[i] = P[i%pot] + D[i] * pot;\n    }\n\n    return {new_P, new_W};\n}\n\nint main() {\n    int N;\n    cin >> N;\n    string T;\n    cin >> T;\n    vector<int> P = solve(N, T).first;\n    for (int x: P) cout << x << \" \";\n    cout << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int M=998244353;\nconst int N=500005,E=524288;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nint n,i,j,k,a[15],su[N],sy[N],vis[N],e,ans[N];\nchar c[N];\nvector<int> g[N];\nstring p[6666];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tassert(n&1);\n\tscanf(\"%s\",c);\n\tint m=min(n/2,6);\n\tfor(i=1;c[i];++i)\n\t\tif(c[i]=='S'&&c[i-1]=='S')\n\t\t{\n\t\t\tvis[i]=vis[i-1]=1;\n\t\t\t++i;\n\t\t}\n\tk=0;\n\tfor(i=0;c[i];++i)\n\t\tif(!vis[i])\n\t\t\tc[k++]=c[i];\n\tc[k]=0;\n\tint s=1;\n\tfor(i=1;i<=m;++i)\n\t\ts*=3;\n\tfor(i=0;i<s;++i)\n\t{\n\t\tint tmp=i;\n\t\tk=0;\n\t\twhile(tmp)\n\t\t{\n\t\t\ta[k++]=tmp%3;\n\t\t\ttmp/=3;\n\t\t}\n\t\tfor(j=0;c[j];++j)\n\t\t\tif(c[j]=='S')\n\t\t\t{\n\t\t\t\tfor(k=0;k<m;++k)\n\t\t\t\t\ta[k]=a[k]*2%3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t++a[k=0];\n\t\t\t\twhile(k<m&&a[k]>2)\n\t\t\t\t{\n\t\t\t\t\ta[k]=0;\n\t\t\t\t\t++a[++k];\n\t\t\t\t}\n\t\t\t\tif(k==m)\n\t\t\t\t\tg[i].push_back(j);\n\t\t\t}\n\t\tfor(j=m-1;j>=0;--j)\n\t\t\tsy[i]=sy[i]*3+a[j];\n\t\t//cout<<sy[i]<<' ';\n\t}\n\t//cout<<endl;\n\tint s2=1;\n\tfor(i=1;i<=n-m;++i)\n\t\ts2*=3;\n\tsu[0]=1;\n\tfor(i=1;c[i-1];++i)\n\t\tif(c[i-1]=='S')\n\t\t\tsu[i]=su[i-1]*2%3;\n\t\telse\n\t\t\tsu[i]=su[i-1];\n\tint len=strlen(c);\n\tfor(j=0;j<s;++j)\n\t{\n\t\tint y=0,las=-1;\n\t\tfor(auto k:g[j])\n\t\t{\n\t\t\tif(su[k+1]*su[las+1]%3==2)\n\t\t\t\tp[j]+='S';\n\t\t\tp[j]+='R';\n\t\t\tlas=k;\n\t\t}\n\t\tif(su[len]*su[las+1]%3==2)\n\t\t\tp[j]+='S';\n\t}\n\tfor(i=0;i<s2;++i)\n\t{\n\t\tfor(e=0;e<s;++e)\n\t\t{\n\t\t\tint tmp=i;\n\t\t\tk=0;\n\t\t\twhile(tmp)\n\t\t\t{\n\t\t\t\ta[k++]=tmp%3;\n\t\t\t\ttmp/=3;\n\t\t\t}\n\t\t\tfor(j=k;j<=n-m;++j)\n\t\t\t\ta[j]=0;\n\t\t\tfor(j=0;j<p[e].size();++j)\n\t\t\t\tif(p[e][j]=='S')\n\t\t\t\t{\n\t\t\t\t\tfor(k=0;k<n-m;++k)\n\t\t\t\t\t\ta[k]=a[k]*2%3;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//cout<<a[0]<<endl;\n\t\t\t\t\t++a[k=0];\n\t\t\t\t\twhile(k<n-m&&a[k]>2)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[k]=0;\n\t\t\t\t\t\t++a[++k];\n\t\t\t\t\t}\n\t\t\t\t\t//cout<<a[0]<<' '<<a[1]<<endl;\n\t\t\t\t}\n\t\t\tint t=0;\n\t\t\tfor(k=n-m-1;k>=0;--k)\n\t\t\t\tt=t*3+a[k];\n\t\t\t//cout<<i<<' '<<t<<' '<<p[e]<<endl;\n\t\t\tans[i*s+e]=t*s+sy[e];\n\t\t}\n\t}\n\tfor(i=0;i<s*s2;++i)\n\t\tprintf(\"%d \",ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int KK = 12, RT = 6, X = 800;\nint f[X], p3[KK+1];\n\nvoid pre() {\n    p3[0] = 1;\n    for (int i=1; i<=KK; i++)    p3[i] = p3[i-1]*3;\n\n    for (int i=0; i<X; i++) {\n        for (int k=0; k<KK; k++) {\n            int d = (i/p3[k])%3;\n            if (d == 1)      f[i] += p3[k]*2;\n            else if (d == 2) f[i] += p3[k];\n        }\n    }\n\n}\n\nint aa[X*X], bb[X*X];\nvector<int> v[X];\nint asol[X], temp[X], vid[X];\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    pre();\n\n    int n;\n    string s;\n    cin>>n>>s;\n\n\n    int mx = p3[max(0, n-RT)];\n    int my = p3[min(RT, n)];\n    int all = p3[n];\n\n\n    for (int i=0; i<mx; i++)\n        for (int j=0; j<my; j++)\n            v[i].push_back(my*i + j);\n\n    for (int j=0; j<my; j++)    asol[j] = j;\n    for (int i=0; i<mx; i++)    vid[i] = i;\n\n    for (char c: s) {\n        if (c == 'R')  {\n            for (int i=0; i<mx; i++)    temp[i] = v[vid[i]][asol[my-1]];\n\n            int st = asol[my-1];\n            for (int i=my-1; i>0; i--)    asol[i] = asol[i-1];\n            asol[0] = st;\n\n            for (int i=1; i<mx; i++)    v[vid[i]][asol[0]] = temp[i-1];\n            v[vid[0]][asol[0]] = temp[mx-1];\n        }\n        else {\n            for (int i=0; i<my; i++)\n                if (f[i] > i)\n                    swap(asol[i], asol[f[i]]);\n\n            for (int i=0; i<mx; i++)\n                if (f[i] > i)\n                    swap(vid[i], vid[f[i]]);\n        }\n\n//        for (int i=0; i<my; i++)    cout<<asol[i]<<\" \"; cout<<\":::\"<<endl;\n//        for (int i=0; i<my; i++)    cout<<v[0][i]<<\" \"; cout<<\"---\"<<endl;\n    }\n\n    for (int i=0; i<mx; i++)\n        for (int j=0; j<my; j++)\n            aa[i*my+j] = v[vid[i]][asol[j]];\n\n\n    for (int i=0; i<all; i++) bb[aa[i]] = i;\n    for (int i=0; i<all; i++) cout<<bb[i]<<\" \";\n    cout<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nstatic inline char CH()\n{\n  static char buf[100000],*ptr1=buf,*ptr2=buf;\n  return ptr1==ptr2&&(ptr2=(ptr1=buf)+fread(buf,1,100000,stdin),ptr1==ptr2)?EOF:*ptr1++;\n}\nstatic inline int IN(void)\n{\n  int x=0,f=0,c=CH();while(c<48||c>57){f^=c==45,c=CH();}\n  while(c>47&&c<58){x=x*10+c-48,c=CH();}return f?-x:x;\n}\nstatic inline int Pow(int a,int b){return b?Pow(a*a,b>>1)*(b&1?a:1):1;}\nint main()\n{\n  int N=IN(),now,len=0,pw3=Pow(3,N),x=Pow(3,N>>1),y=Pow(3,N-(N>>1)),A[1000001],B[600001];\n  char c=CH(),T[1000001],S[1000001];\n  rep(i,pw3)B[i]=B[i/3]*3+(3-i%3)%3;\n  while(c!=EOF){if(c==10){c=CH();}T[1+len++]=c,c=CH();}\n  fflush(stdin);\n  rep(i,x)\n  {\n    int temp=i;now=0;\n    rep(j,len)\n    {\n      if(T[j+1]=='S'){temp=B[temp];if(S[now]=='S')--now;else S[++now]='S';}\n      else{++temp;if(temp==x)S[++now]='R',temp=0;}\n    }\n    rep(j,y)\n    {\n      int keep=j;\n      rep(k,now)\n      {\n        if(S[k+1]=='S')keep=B[keep];\n        else if(S[k+1]=='R')if((++keep)==y)keep=0;\n        A[i+j*x]=temp+keep*x;\n      }\n    }\n  }\n  rep(i,pw3)printf(\"%i%c\",(unsigned)A[i],i+1==pw3?'\\n':' ');\n  return fflush(stdout),0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\nnamespace Base{\n\t# define mr make_pair\n\ttypedef long long ll;\n\ttypedef double db;\n\tconst int inf = 0x3f3f3f3f, INF = 0x7fffffff;\n\tconst ll  infll = 0x3f3f3f3f3f3f3f3fll, INFll = 0x7fffffffffffffffll;\n\ttemplate<typename T> void read(T &x){\n    \tx = 0; int fh = 1; double num = 1.0; char ch = getchar();\n\t\twhile (!isdigit(ch)){ if (ch == '-') fh = -1; ch = getchar(); }\n\t\twhile (isdigit(ch)){ x = x * 10 + ch - '0'; ch = getchar(); }\n\t    if (ch == '.'){\n\t    \tch = getchar();\n\t    \twhile (isdigit(ch)){num /= 10; x = x + num * (ch - '0'); ch = getchar();}\n\t\t}\n\t\tx = x * fh;\n\t}\n\ttemplate<typename T> void chmax(T &x, T y){x = x < y ? y : x;}\n\ttemplate<typename T> void chmin(T &x, T y){x = x > y ? y : x;}\n}\nusing namespace Base;\n\nconst int L = 15, N = 200100;\nvector <int> mp[L];\nint n, ans[1000010], mul[L];\nchar st[N];\nvoid dfs(int k, int fm, int to){\n\tif (k == n){\n\t\tans[fm] = to;\n\t\treturn;\n\t}\n\tfor (int i = 0; i < 3; i++){\n\t\tmp[k + 1].clear();\n\t\tint x = i;\n\t\tfor (unsigned j = 0; j < mp[k].size(); j++){\n\t\t\tif (mp[k][j] == 0){\n\t\t\t\tx = x + 1;\n\t\t\t\tif (x % 3 == 0){\n\t\t\t\t\tx = 0;\n\t\t\t\t\tmp[k + 1].push_back(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = x * 2 % 3;\n\t\t\t\tif (mp[k + 1].size() > 0 && mp[k + 1][mp[k + 1].size() - 1] == 1)\n\t\t\t\t\tmp[k + 1].pop_back();\n\t\t\t\t\telse mp[k + 1].push_back(1);\n\t\t\t}\n\t\t}\n\t\tdfs(k + 1, fm + i * mul[k], to + x * mul[k]);\n\t}\n}\nint main(){\n\tread(n);\n\tscanf(\"\\n%s\", st + 1);\n\tint l = strlen(st + 1); \n\tfor (int i = 1; i <= l; i++){\n\t\tint t;\n\t\tif (st[i] == 'R') t = 0; else t = 1;\n\t\tif (t == 1 && mp[0].size() > 0 && mp[0][mp[0].size() - 1] == 1){\n\t\t\tmp[0].pop_back();\n\t\t\tcontinue;\n\t\t}\n\t\tmp[0].push_back(t);\n\t}\n\tmul[0] = 1;\n\tfor (int i = 1; i <= n; i++) mul[i] = mul[i - 1] * 3;\n\tdfs(0, 0, 0);\n\tfor (int i = 0; i < mul[n]; i++)\n\t\tprintf(\"%d%c\", ans[i], (i == mul[n] - 1) ? '\\n' : ' ');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nstatic inline char CH()\n{\n  static char buf[100000],*ptr1=buf,*ptr2=buf;\n  return ptr1==ptr2&&(ptr2=(ptr1=buf)+fread(buf,1,100000,stdin),ptr1==ptr2)?EOF:*ptr1++;\n}\nstatic inline int IN(void)\n{\n  int x=0,f=0,c=CH();while(c<48||c>57){f^=c==45,c=CH();}\n  while(c>47&&c<58){x=x*10+c-48,c=CH();}return f?-x:x;\n}\nstatic inline int Pow(int a,int b){return b?Pow(a*a,b>>1)*(b&1?a:1):1;}\nint main()\n{\n  int N,now,len=0,A[1000001],B[600001];\n  char T[1000001],S[1000001];\n  now=scanf(\"%d %s\",&N,T+1);len=strlen(T+1);\n  int pw3=Pow(3,N),x=Pow(3,N>>1),y=Pow(3,N-(N>>1));\n  rep(i,pw3)B[i]=B[i/3]*3+(3-i%3)%3;\n  rep(i,x)\n  {\n    int temp=i;now=0;\n    for(int j=1;j<=len;j++)\n    {\n      if(T[j]=='S'){temp=B[temp];(S[now]=='S')?--now:S[++now]='S';}\n      else{++temp;if(temp==x)S[++now]='R',temp=0;}\n    }\n    rep(j,y)\n    {\n      int keep=j;\n      for(int k=1;k<=now;k++)\n      {\n        if(S[k]=='S')keep=B[keep];\n        else if(S[k]=='R'){if((++keep)==y)keep=0;}\n        A[i+j*x]=temp+keep*x;\n      }\n    }\n  }\n  rep(i,pw3)printf(\"%d%c\",A[i],i+1==pw3?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2000005;\nint n,m,cnt,p[12]={1},ans[N];\nchar s[N];\nstruct tree\n{\n\tint ch[3],id,tag;\n}a[N];\nvoid build(int d,int x,int v)\n{\n\ta[x].tag=0;\n\tif(d==n)\n\t{\n\t\ta[x].id=v;\n\t\treturn;\n\t}\n\tfor(int i=0;i<3;i++)\n\t{\n\t\ta[x].ch[i]=++cnt;\n\t\tbuild(d+1,a[x].ch[i],v+p[d]*i);\n\t}\n}\nvoid pushdown(int x)\n{\n\tif(a[x].tag)\n\t{\n\t\tfor(int i=0;i<3;i++)\n\t\t{\n\t\t\tswap(a[a[x].ch[i]].ch[1],a[a[x].ch[i]].ch[2]);\n\t\t\ta[a[x].ch[i]].tag^=1;\n\t\t}\n\t\ta[x].tag=0;\n\t}\n}\nvoid add(int d,int x)\n{\n\tif(d==n)\n\t\treturn;\n\tpushdown(x);\n\tint b[3];\n\tfor(int i=0;i<3;i++)\n\t\tb[i]=a[x].ch[i];\n\tfor(int i=0;i<3;i++)\n\t\ta[x].ch[i]=b[(i+2)%3];\n\tadd(d+1,a[x].ch[0]);\n}\nvoid out(int d,int x,int v)\n{\n\tif(d==n)\n\t{\n\t\tans[a[x].id]=v;\n\t\treturn;\n\t}\n\tpushdown(x);\n\tfor(int i=0;i<3;i++)\n\t\tout(d+1,a[x].ch[i],v+p[d]*i);\n}\nint main()\n{\n\tscanf(\"%d%s\",&n,s+1);\n\tm=strlen(s+1);\n\tfor(int i=1;i<=n;i++)\n\t\tp[i]=p[i-1]*3;\n\tbuild(0,0,0);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(s[i]=='S')\n\t\t{\n\t\t\tswap(a[0].ch[1],a[0].ch[2]);\n\t\t\ta[0].tag^=1;\n\t\t}\n\t\tif(s[i]=='R')\n\t\t\tadd(0,0);\n\t}\n\tout(0,0,0);\n\tfor(int i=0;i<p[n];i++)\n\t\tprintf(\"%d \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2,unroll-loops\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing vi = vector<int>;\nusing ll = long long;\nint maxn = 531441, B, C;\nint n, p[531441], f[531441];\nint rev(int a) {\n\tint r = 0, c = 1;\n\twhile(c < maxn) {\n\t\tif(a%3) r +=(3 - (a%3))*c;\n\t\tc*=3,a/=3;\n\t}\n\treturn r;\n}\n\nint s = 0;\nlist<int> big[729], small[729];\nlist<int>::iterator pos[531441];\nint id[531441], lup[531441], u = 0;\n\nvoid add() {\n\ts = (s + B - 1)%B;\n\tfor(auto &i : small[s]) {\n\t\tif(lup[i] != u) {\n\t\t\tif((lup[i]^u)&1) id[i] = f[id[i]];\n\t\t\tlup[i] = u;\n\t\t}\n\t\tbig[id[i]].erase(pos[i]);\n\t\tid[i] = (id[i] + 1)%C;\n\t\tbig[id[i]].push_back(i);\n\t\t--(pos[i] = big[id[i]].end());\n\t}\n}\n\nvoid flip() {\n\tu++;\n\tfor(int i = 0; i < B; i++) {\n\t\tif(f[i] <= i) {\n\t\t\tswap(small[(s+i)%B], small[(s+f[i])%B]);\n\t\t}\n\t}\n\tfor(int i = 0; i < C; i++) {\n\t\tif(f[i] <= i) {\n\t\t\tswap(big[i], big[f[i]]);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tstring t;\n\tcin >> n >> t;\n\tmaxn = B = 1;\n\tfor(int i = 0; i < n; i++) maxn *= 3;\n\tfor(int i = 0; i < n/2; i++) B *= 3;\n\tC = maxn/B;\n\tfor(int i = 0; i < maxn; i++) {\n\t\tf[i] = rev(i);\n\t\t\n\t\tsmall[i%B].push_back(i);\n\t\t\n\t\tbig[i/B].push_back(i);\n\t\t--(pos[i] = big[i/B].end());\n\t\t\n\t\tid[i] = i/B;\n\t}\n\t\n\tfor(auto i : t) {\n\t\tif(i == 'R') add();\n\t\telse flip();\n\t}\n\tfor(int i = 0; i < B; i++)\n\t\tfor(auto j : small[i]) p[j] += (B+i-s)%B;\n\tfor(int i = 0; i < C; i++)\n\t\tfor(auto j : big[i]) p[j] += B*i;\n\tfor(int i = 0; i < maxn; i++) cout << p[i] << \" \";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n, po[13], S[201000], Ans[13][550000];\nvector<int>U[13][177147];\nchar p[201000];\nint main(){\n    int i, j;\n    po[0]=1;\n    for(i=0;i<12;i++)po[i+1]=po[i]*3;\n    scanf(\"%d\",&n);\n    scanf(\"%s\",p);\n    for(i=0;p[i];i++){\n        S[i+1]=S[i];\n        if(p[i]=='S')S[i+1]++;\n    }\n    int m = i;\n    for(i=0;i<3;i++){\n        int cur = i;\n        for(j=0;p[j];j++){\n            if(cur==2 && p[j]=='R'){\n                U[1][i].push_back(j);\n            }\n            if(p[j]=='S'){\n                cur=(3-cur)%3;\n            }\n            else cur=(cur+1)%3;\n        }\n        Ans[1][i]=cur;\n    }\n    for(i=1;i<n;i++){\n        for(j=0;j<po[i+1];j++){\n            int a = j/po[i];\n            int b = j%po[i];\n            int pv = 0;\n            for(auto &t : U[i][b]){\n                int s=0;\n                if(t)s += S[t];\n                if(pv)s -= S[pv];\n                if(s&1){\n                    a=(3-a)%3;\n                }\n                a=(a+1)%3;\n                if(a==0){\n                    if(i+1<n) U[i+1][j].push_back(t);\n                }\n                pv=t+1;\n            }\n            int s=S[m];\n            if(pv)s -= S[pv];\n            if(s&1)a=(3-a)%3;\n            Ans[i+1][j] = Ans[i][b] + po[i]*a;\n        }\n    }\n    for(i=0;i<po[n];i++){\n        printf(\"%d \",Ans[n][i]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n \nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n\n#define MOD 1000000007LL\n\nint N;\nstring T;\nvector<int> p1,p2;\n//map<int, int> sa;\nvector<int> sa;\nint sp;\nint tn;\nint os;\n\nint conv(int);\nint tri(int n) {\n  int ans=1;\n  for (int i=0; i<n; i++) ans *= 3;\n  return ans;\n}\n\nvoid salsa();\nvoid rumba();\nvoid print_res();\nvoid print_ln();\n\nint main()\n{\n  int l;\n  int i;\n\n  cin >> N >> T;\n  tn = tri(N);\n\n  p1.resize(tn);\n  p2.resize(tn);\n  sa.resize(tn);\n  for (int i=0; i<tn; i++) {\n    p1[i] = i;\n  }\n  sa[0] = 0; sa[1] = 2; sa[2]=1;\n  for (int i=3; i<tn; i++) {\n    sa[i] = conv(i);\n  }\n//for (int i=0; i<tn; i++) printf(\"sa[%d]=%d\\n\", i, sa[i]);\n  p2[0] = p1[0];\n  sp = 1;\n\n//print_ln();\n\n  l = T.size();\n  for (i=0; i<l; i++) {\n    if (T[i] == 'S') {\n      salsa();\n//printf(\"S \");\n//print_ln();\n    } else {\n      os+=tn-1;\n      os%=tn;\n//      rumba();\n//printf(\"R \");\n//print_ln();\n    }\n  }\n\n  print_res();\n\n  return 0;\n}\nint conv(int inp) {\n  int cv=0;\n  int fx;\n  int t;\n\n  fx = inp;\n  for (t=1; t<inp; ) t*=3;\n  t/=3;\n  cv += sa[inp%t];\n  fx /= t;\n\n  for (; fx>0; t*=3) {\n    switch(fx % 3) {\n    case 1: cv += 2*t; break;\n    case 2: cv += t; break;\n    }\n    fx /= 3;\n  }\n  return cv;\n}\n\nvoid salsa() {\n  int i;\n\n  if (sp==1) {\n    for (i=0; i<tn; i++) {\n      p2[(sa[i]+os)%tn] = p1[(i+os)%tn];\n    }\n    sp = 2;\n  } else {\n    for (i=0; i<tn; i++) {\n      p1[(sa[i]+os)%tn] = p2[(i+os)%tn];\n    }\n    sp = 1;\n  }\n}\nvoid rumba() {\n  int i;\n  if (sp==1) {\n    for (i=0; i<tn-1; i++) {\n      p2[i+1]=p1[i];\n    }\n    p2[0] = p1[tn-1];\n    sp = 2;\n  } else {\n    for (i=0; i<tn-1; i++) {\n      p1[i+1]=p2[i];\n    }\n    p1[0] = p2[tn-1];\n    sp = 1;\n  }\n}\n\nvoid print_ln() {\n  int i;\n  if (sp == 1) {\n    printf(\"%d\", p1[0]);\n    for (i=1; i<tn; i++) printf(\" %d\", p1[i]);\n  } else {\n    printf(\"%d\", p2[0]);\n    for (i=1; i<tn; i++) printf(\" %d\", p2[i]);\n  }\n  printf(\"\\n\");\n}\nvoid print_res() {\n  int i;\n  map<int, int> m;\n  if (sp == 1) {\n    for (i=0; i<tn; i++)  m.emplace(p1[(i+os)%tn], i);\n  } else {\n    for (i=0; i<tn; i++)  m.emplace(p2[(i+os)%tn], i);\n  }\n  auto it=m.begin();\n  printf(\"%d\", it->second);\n  for (it++; it!=m.end(); it++) {\n    printf(\" %d\", it->second);\n  }\n  printf(\"\\n\");\n}\n/*\n  a*3^3+b*3^2+c*3+d\n  */\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nstatic inline char CH()\n{\n  static char buf[100000],*ptr1=buf,*ptr2=buf;\n  return ptr1==ptr2&&(ptr2=(ptr1=buf)+fread(buf,1,100000,stdin),ptr1==ptr2)?EOF:*ptr1++;\n}\nstatic inline int IN(void)\n{\n  int x=0,f=0,c=CH();while(c<48||c>57){f^=c==45,c=CH();}\n  while(c>47&&c<58){x=x*10+c-48,c=CH();}return f?-x:x;\n}\nstatic inline int Pow(int a,int b){return b?Pow(a*a,b>>1)*(b&1?a:1):1;}\nint main()\n{\n  int N=IN(),now,len=0,pw3=Pow(3,N),x=Pow(3,N>>1),y=Pow(3,N-(N>>1)),A[1000001],B[600001];\n  char c=CH(),T[1000001],S[1000001];\n  rep(i,pw3)B[i]=B[i/3]*3+(3-i%3)%3;\n  while(c!=EOF){if(c==10){c=CH();}T[len++]=c,c=CH();}\n  rep(i,x)\n  {\n    int temp=i;now=0;\n    rep(j,len)\n    {\n      if(T[j]=='S'){temp=B[temp];(S[now]=='S')?--now:S[++now]='S';}\n      else{++temp;if(temp==x)S[++now]='R',temp=0;}\n    }\n    rep(j,y)\n    {\n      int keep=j;\n      rep(k,now)\n      {\n        if(S[k+1]=='S')keep=B[keep];\n        else if(S[k+1]=='R'){if((++keep)==y)keep=0;A[i+j*x]=temp+keep*x;}\n      }\n    }\n  }\n  rep(i,pw3)printf(\"%d \",A[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(x) x.begin(), x.end()\n#define x first\n#define y second\n#define mp make_pair\n#define mt make_tuple\n\nconst int L = 13;\nconst int N = 1e6;\n\nint l;\nint q;\nstring t;\nint pw[L];\nint n;\nint per[N];\nint lst[N];\nint dig[N];\nint was[N];\nint cnt = 0;\n\nvoid push(int i) {\n\tif (dig[i] && (was[i] - cnt) % 2) {\n\t\tdig[i] = 3 - dig[i];\n\t}\n\twas[i] = cnt;\n}\n\nsigned main() {\n#ifdef LC\n\tassert(freopen(\"input.txt\", \"r\", stdin));\n#endif\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tpw[0] = 1;\n\tfor (int i = 1; i < L; ++i) {\n\t\tpw[i] = pw[i - 1] * 3;\n\t}\n\tcin >> l >> t;\n\tn = pw[l];\n\tq = (int)t.size();\n\tfor (int lvl = 0; lvl < l; ++lvl) {\n\t\tint len = pw[lvl];\n\t\tfor (int i = 0; i < len; ++i) {\n\t\t\tper[i + 2 * len] = per[i + len] = per[i];\n\t\t\tdig[i] = 0;\n\t\t\twas[i] = 0;\n\t\t\tdig[i + len] = 1;\n\t\t\twas[i + len] = 0;\n\t\t\tdig[i + 2 * len] = 2;\n\t\t\twas[i + 2 * len] = 0;\n\t\t}\n\t\tcnt = 0;\n\t\tfor (int ind = 0; ind < q; ++ind) {\n\t\t\tint pos = lst[ind];\n\t\t\tint tmp = -1;\n\t\t\tfor (; pos < 3 * len; pos += len) {\n\t\t\t\tpush(pos);\n\t\t\t\tif (dig[pos] == 2) {\n\t\t\t\t\ttmp = pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(tmp != -1);\n\t\t\tif (t[ind] == 'S') {\n\t\t\t\t++cnt;\n\t\t\t} else {\n\t\t\t\tpos = lst[ind];\n\t\t\t\tpush(pos);\n\t\t\t\tpush(pos + len);\n\t\t\t\tpush(pos + 2 * len);\n\t\t\t\t(++dig[pos]) %= 3;\n\t\t\t\t(++dig[pos + len]) %= 3;\n\t\t\t\t(++dig[pos + 2 * len]) %= 3;\n\t\t\t}\n\t\t\tlst[ind] = tmp;\n\t\t}\n\t\tfor (int i = 0; i < 3 * len; ++i) {\n\t\t\tpush(i);\n\t\t\tper[i] += dig[i] * pw[lvl];\n\t\t}\n\t}\n\tfor (int i = 0; i < pw[l]; ++i) {\n\t\tcout << per[i] << \" \";\n\t}\n\tcout << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,x,y,sw,pw3=1,A[531441],B[531441];\nchar S[200001],T[200001];\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nsigned main(void)\n{\n  x=scanf(\"%d %s\",&N,T);\n  replace(T,\"SS\",\"\");if(T[0]=='\\n')return 0;\n  rep(i,N)\n  {\n    rep(j,pw3)rep(k,3)B[j+k*pw3]=k;sw=0;\n    rep(j,strlen(T))\n    {\n      if(T[j]=='R')\n      {\n        y=S[j];\n        rep(k,3){x=y+k*pw3;if(B[x]+sw==2)S[j]=x;B[x]+=sw+1;B[x]%=3;}\n      }\n      if(T[j]=='S')sw^=1;\n    }\n    rep(j,pw3){y=A[j];rep(k,3){x=j+k*pw3;A[x]=y+(sw?3-B[x]:B[x])%3*pw3;}}\n    pw3*=3;\n  }\n  rep(i,pw3)printf(\"%d%c\",A[i],i+1==pw3?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define IOS std::ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)\n#define debug(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n#define IN freopen(\"in.txt\", \"r\", stdin);\n#define endl '\\n'\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(x) x.begin(),x.end()\n#define sz(x) (int)x.size()\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef pair<int, int> pii;\nconst int inf = 0x3f3f3f3f;\n\n\nvoid update(int q,int& last,int& d){\n    if(d and q%2 != last%2)d=3-d;\n    last=q;\n}\n\npair<VI,VI> solve(int n,string& T){\n    if(!n){\n        VI p = {0};\n        VI W(sz(T),0);\n        return {p,W};\n    }\n    auto pp=solve(n-1,T);\n    const auto& p=pp.fi, w=pp.se;\n    VI new_w(sz(w));\n    int pot=sz(p);\n    VI D(3*pot);\n    for(int i=0;i<3;i++)for(int x=0;x<pot;x++)D[i*pot+x]=i;\n    VI last(3*pot,0);\n    int q=0;\n    for(int i=0;i<sz(T);i++){\n        int k=w[i];\n        for(int x=k;x<3*pot;x+=pot){\n            update(q,last[x],D[x]);\n            if(D[x]==2)new_w[i]=x;\n        }\n        if(T[i]=='S')q++;\n        if(T[i]=='R'){\n            for(int x=k;x<3*pot;x+=pot)D[x]=(D[x]+1)%3;\n        }\n    }\n    VI new_p(3*pot);\n    for(int i=0;i<3*pot;i++){\n        update(q,last[i],D[i]);\n        new_p[i]=p[i%pot]+D[i]*pot;\n    }\n    return {new_p,new_w};\n}\n\nint main(){\n    IOS;\n    int n;string s;\n    cin>>n>>s;\n    VI p=solve(n,s).fi;\n    for(int x:p)cout<<x<<' ';\n    cout<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nint main(){\n    int n;\n    std::string t;\n    std::cin>>n>>t;\n    int temp=1;\n    int zhishu[n];\n    for(int i=0;i<n;++i){\n        temp*=3;\n        zhishu[i]=temp;\n    }\n    const int num=temp;\n    int ans[num];\n    int sub[num];\n    int c[num][12];\n    for(int i=0;i<num;++i){\n        ans[i]=i;\n        sub[i]=0;\n        for(int j=11;j>=12-n;--j){\n            c[i][j]=0;\n        }\n    }\n    for(int i=1;i<num;++i){\n        for(int j=0;j<12;++j){\n            c[i][j]=c[i-1][j];\n        }\n        c[i][11]++;\n        int j=11;\n        while(c[i][j]>=3){\n            c[i][j]-=3;\n            j--;\n            c[i][j]++;\n        }\n    }\n    for(int i=0;i<num;++i){\n        for(int j=12-n;j<12;++j){\n            if(c[i][j]==2){\n                sub[i]+=zhishu[11-j];\n            }\n        }\n    }\n    for(int i=0;i<t.size();++i){\n        if(t[i]=='S'){\n            if(i<t.size()-1){\n                if(t[i+1]=='S'){\n                    ++i;\n                    continue;\n                }\n            }\n            for(int j=0;j<num;++j){\n                temp=ans[j];\n                ans[j]=2*temp-sub[temp];\n            }\n        }\n        else{\n            for(int j=0;j<num;++j){\n                ans[j]++;\n                if(ans[j]>=num){\n                    ans[j]-=num;\n                }\n            }\n        }\n    }\n    std::cout<<ans[0];\n    for(int i=1;i<num;++i){\n        std::cout<<\" \"<<ans[i];\n    }\n    std::cout<<std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define Fast_IO ios::sync_with_stdio(false);\n#define DEBUG fprintf(stderr,\"Running on Line %d in Function %s\\n\",__LINE__,__FUNCTION__)\n//mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n#define fir first\n#define sec second\n#define mod 998244353\n#define ll long long\n#define inf 0x3f3f3f3f\n#define INF 0x3f3f3f3f3f3f3f3f\ninline int read()\n{\n\tchar ch=getchar(); int nega=1; while(!isdigit(ch)) {if(ch=='-') nega=-1; ch=getchar();}\n\tint ans=0; while(isdigit(ch)) {ans=ans*10+ch-48;ch=getchar();}\n\tif(nega==-1) return -ans;\n\treturn ans;\n}\ntypedef pair<int,int> pii;\ninline int min(int x,int y,int z){return min(x,min(y,z));}\ninline int max(int x,int y,int z){return max(x,max(y,z));}\ninline int add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\ninline int add(int x,int y,int z){return add(add(x,y),z);}\ninline int sub(int x,int y){return x-y<0?x-y+mod:x-y;}\ninline int mul(int x,int y){return 1LL*x*y%mod;}\ninline int mul(int x,int y,int z){return mul(mul(x,y),z);}\n#define N 600005\nint a[N],t[15][N];\nchar s[N];\nint id[N],n;\nvoid upd(int &x)\n{\n\tif(x==1) x=2;\n\telse if(x==2) x=1;\n}\nsigned main()\n{\n\tcin>>n;\n\tscanf(\"%s\",s+1);\n\tint m=strlen(s+1);\n\tint cur=1;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcur*=3;\n\t\tfor(int j=0;j<cur;j++)\n\t\t{\n\t\t\tint x=j;\n\t\t\tfor(int k=0;k<i;k++) x/=3;\n\t\t\ta[j]=x;\n\t\t}\n\t\tbool op=0;\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tif(s[j]=='S') op^=1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint u=id[j],tmp=0;\n\t\t\t\tfor(int k=0;k<3;k++)\n\t\t\t\t{\n\t\t\t\t\tint v=k*(cur/3)+u;\n\t\t\t\t\tif(op) upd(a[v]);\n\t\t\t\t\tif(a[v]==2) tmp=k,a[v]=0;\n\t\t\t\t\telse a[v]++;\n\t\t\t\t\tif(op) upd(a[v]);\n\t\t\t\t}\n\t\t\t\tid[j]+=tmp*(cur/3);\n\t\t\t}\n\t\t}\n\t\tif(op) for(int j=0;j<cur;j++) upd(a[j]);\n\t\tfor(int j=0;j<cur;j++) t[i][j]=a[j];\n\t\t// for(int j=1;j<=cur;j++) printf(\"%d \",t[i][j]);\n\t\t// cout<<\"\\n\";\n\t}\n\tfor(int i=0;i<cur;i++)\n\t{\n\t\tint ans=0,tmp=1;\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\ttmp*=3;\n\t\t\tans+=t[j][i%tmp]*(tmp/3);\n\t\t}\n\t\tprintf(\"%d \",ans);\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(void) {\n    int N;\n    char T[200000];\n    scanf(\"%d\", &N);\n    gets(T);\n    if (strcmp(T,\"SRS\")) {\n        printf(\"2 0 1\");\n    }\n    else if (strcmp(T , \"RRSRSSSSR\")) {\n        printf(\"3 8 1 0 5 7 6 2 4\");\n    }\n    else {\n        printf(\"23 9 22 8 3 7 20 24 19 5 18 4 17 12 16 2 6 1 14 0 13 26 21 25 11 15 10\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 550010;\nint n,m,pw[N];\nchar s[N];\n\nint cnt,son[N][3],p[N];\ninline void dfs(int u,int dep,int x){\n\tif (dep==n) return p[u]=x,void(0);\n\tson[u][0]=++cnt,dfs(son[u][0],dep+1,x);\n\tson[u][1]=++cnt,dfs(son[u][1],dep+1,x+pw[dep]);\n\tson[u][2]=++cnt,dfs(son[u][2],dep+1,x+2*pw[dep]);\n}\n\nint tag[N];\ninline void upd(int u){\n\tswap(son[u][1],son[u][2]),tag[u]^=1;\n}\ninline void push_down(int u){\n\tif (!tag[u]) return;\n\tFOR(i,0,3) upd(son[u][i]);\n\ttag[u]=0;\n}\ninline void dfs(int u,int dep){\n\tif (dep==n) return;\n\tpush_down(u);\n\tint tmp=son[u][2];\n\tson[u][2]=son[u][1],son[u][1]=son[u][0],son[u][0]=tmp;\n\tdfs(son[u][0],dep+1);\n}\n\nint ans[N];\ninline void print(int u,int dep,int x){\n\tif (dep==n) return ans[p[u]]=x,void(0);\n\tpush_down(u);\n\tprint(son[u][0],dep+1,x);\n\tprint(son[u][1],dep+1,x+pw[dep]);\n\tprint(son[u][2],dep+1,x+2*pw[dep]);\n}\n\nint main(){\n\tn=read(),scanf(\"%s\",s+1),m=strlen(s+1);\n\tpw[0]=1;\n\tFor(i,1,n) pw[i]=pw[i-1]*3;\n\tdfs(0,0,0);\n\tFor(i,1,m){\n\t\tif (s[i]=='S') upd(0);\n\t\t\telse dfs(0,0);\n\t}\n\tprint(0,0,0);\n\tFOR(i,0,pw[n]) printf(\"%d \",ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <bitset>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\nconst int MAX_N = 540010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = (1 << 30) - 1;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N;\nstring S;\nint A[MAX_N];\n\nbitset<540000> B[6];\nvi V[6] = {{0, 1, 2}, {0, 2, 1}, {1, 0, 2}, {1, 2, 0}, {2, 0, 1}, {2, 1, 0}};\nint to[6] = {4, 2, 5, 0, 3, 1};\nint I[6], rI[6];\nint Q[15][MAX_N];\nint ans[MAX_N];\nint inv[MAX_N];\n\nint find_idx(int a) {\n\trep(i, 0, 6) {\n\t\tif(B[i][a]) return i;\n\t}\n\treturn -1;\n}\n\nvoid idx_move(int x, int y, int a) {\n\tB[x][a] = 0;\n\tB[y][a] = 1;\n};\n\nvoid solve() {\n\tcin >> N;\n\tcin >> S;\n\t// N = 12;\n\t// rep(i, 0, 200000) {\n\t// \tint v = rand() % 2;\n\t// \tif(v == 0) S += 'R';\n\t// \telse S += 'S';\n\t// }\n\tint T = sz(S);\n\t\n\tint BN = 1;\n\trep(i, 0, N) BN *= 3;\n\trep(q, 0, N) {\n\t\tint pow3 = 1;\n\t\trep(i, 0, q) pow3 *= 3;\n\t\trep(i, 0, 6) {\n\t\t\tB[i].reset();\n\t\t\tI[i] = i;\n\t\t\trI[i] = i;\n\t\t}\n\t\trep(i, 0, pow3) B[0][i] = 1;\n\n\t\trep(i, 0, T) {\n\t\t\tif(S[i] == 'R') {\n\t\t\t\tint v = Q[q][i];\n\t\t\t\tint idx = find_idx(v);\n\t\t\t\tint ridx = I[idx];\n\t\t\t\tint c = V[ridx][2];\n\t\t\t\tidx_move(idx, rI[to[ridx]], v);\n\t\t\t\tQ[q + 1][i] = c * pow3 + v;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tswap(rI[0], rI[1]);\n\t\t\t\tswap(rI[2], rI[3]);\n\t\t\t\tswap(rI[4], rI[5]);\n\t\t\t\trep(i, 0, 6) {\n\t\t\t\t\tI[rI[i]] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, 0, pow3) {\n\t\t\tint v = ans[i];\n\t\t\tint idx = find_idx(v);\n\t\t\tint ridx = I[idx];\n\t\t\trep(j, 0, 3) {\n\t\t\t\tans[j * pow3 + i] = V[ridx][j] * pow3 + v;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, 0, BN) {\n\t\tinv[ans[i]] = i;\n\t}\n\trep(i, 0, BN) {\n\t\tcout << inv[i] << \" \";\n\t}\n\tcout << \"\\n\";\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <string>\n#include <algorithm>\n#include <utility>\n#define inf 1e18\n#define rep(x, s, t) for(int (x) = (s); (x) < (t); (x)++)\n#define Rep(x, s, t) for(int (x) = (s); (x) <= (t); (x)++)\n#define chmin(x, y) (x) = min((x), (y))\n#define chmax(x, y) (x) = max((x), (y))\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n;\nstring s;\nint beki[15];\nint carry[200005];\nint dest[600005], ndest[600005];\nvector<bitset<600005>> vec(3);\nint pt[3];\n\nint main(void)\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n;\n\tcin >> s;\n\t\n\tbeki[0] = 1;\n\tfor(int i = 1; i < 15; i++) beki[i] = beki[i-1] * 3;\n\t\n\tfor(int i = 0; i < 3; i++){\n\t\tint p = i;\n\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\tif(s[j] == 'R'){\n\t\t\t\tif(p == 2) carry[j] = i;\n\t\t\t\tp = (p+1) % 3;\n\t\t\t}\n\t\t\telse p = (3-p)%3;\n\t\t}\n\t\tdest[i] = p;\n\t}\n\t\n\tfor(int i = 1; i < n; i++){\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tfor(int k = 0; k < beki[i+1]; k++) vec[j][k] = false;\n\t\t\tfor(int k = 0; k < beki[i]; k++) vec[j][j*beki[i]+k] = true;\n\t\t}\n\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\tif(s[j] == 'S') swap(vec[1], vec[2]);\n\t\t\telse{\n\t\t\t\tint tmp[3];\n\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\tfor(int l = 0; l < 3; l++){\n\t\t\t\t\t\tint x = l*beki[i]+carry[j];\n\t\t\t\t\t\tif(vec[k][x]){\n\t\t\t\t\t\t\ttmp[k] = x;\n\t\t\t\t\t\t\tif(k == 2) carry[j] = x;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\tvec[k][tmp[k]] = false;\n\t\t\t\t\tvec[(k+1)%3][tmp[k]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tfor(int k = 0; k < beki[i+1]; k++){\n\t\t\t\tif(vec[j][k]) ndest[k] = dest[k%beki[i]] + j*beki[i];\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < beki[i+1]; j++) dest[j] = ndest[j];\n\t}\n\t\n\tfor(int i = 0; i < beki[n]; i++) cout << dest[i] << \" \"; cout << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#define int long long\n\n#define pii pair<int, int>\n\n#define x1 x1228\n#define y1 y1228\n\n#define left left228\n#define right right228\n\n#define next next228\n\n#define pb push_back\n#define eb emplace_back\n\n#define mp make_pair                                                                \n                                                                                                                                        \n#define ff first                                                                  \n#define ss second   \n\n#define all(x) x.begin(), x.end()\n#define debug(x) cout << #x << \": \" << x << endl; \n#define TIME (ld)clock()/CLOCKS_PER_SEC\n\nusing namespace std;\ntypedef long long ll; \ntypedef long double ld; \n                                                                                                   \nconst int maxn = 2e5 + 7, mod = 1e9 + 7, MAXN = 1e6 + 7;\nconst double eps = 1e-9;\nconst ll inf = 1e18;\nmt19937 rnd(time(0));\nint n; \nstring s; \nint next[MAXN];\nconst int N = 2187; \nint dp1[N]; \nint dp2[N]; \nint xyz[N]; \n\nint get1(int mask, char q) {\n    if (q == 'R') {\n        ++mask; \n        return mask; \n    }   \n    int ptr = 1; \n    int ans = 0; \n    while (mask) {\n        int t = mask % 3; \n        mask /= 3; \n        if (t == 2) ans += ptr; \n        if (t == 1) ans += 2 * ptr; \n        ptr *= 3; \n    }\n    return ans; \n}\n\nconst int L = 12; \nint pref[maxn]; \nint to[maxn]; \nint kek1[N], kek2[N]; \nint res[N]; \nint add = 1; \n\nint get(int x) {\n    vector<int> bts; \n    for (int i = 0; i < L; ++i) {\n        bts.pb(x % 3); \n        x /= 3; \n    }\n    int left = 0;\n    int right = 0; \n    for (int i = 6; i >= 0; --i) {\n        left *= 3;\n        left += bts[i]; \n    }\n    for (int i = L - 1; i >= 7; --i) {\n        right *= 3; \n        right += bts[i]; \n    }\n    int id = 0; \n    if (left && dp1[left] == -1) {\n        return res[left] + add * right;   \n    }\n    if (left) {    \n        id = dp1[left]; \n        if (pref[id] & 1) right = xyz[right];             \n        left = 0; \n    }                     \n    while (next[id] != -1) {        \n        if ((pref[next[id]] - pref[id]) & 1) right = xyz[right]; \n        id = next[id];                                                                                                                                         \n    }\n    left = to[id]; \n    return left + right * add; \n}\n\nvoid solve() {\n    for (int i = 0; i < N; ++i) {\n        xyz[i] = get1(i, 'S') % N; \n    }\n    cin >> n >> s; \n    int t = s.size(); \n    for (int i = 0; i < N; ++i) {        \n        res[i] = i; \n        for (int j = 0; j < t; ++j) {\n            if (s[j] == 'S') res[i] = xyz[res[i]]; \n            else res[i] = (res[i] + 1) % N; \n        } \n    }\n    for (int i = 0; i < t; ++i) {\n        pref[i + 1] = pref[i] + (s[i] == 'S'); \n    }\n\n    for (int i = 0; i < N; ++i) dp1[i] = dp2[i] = -1; \n    next[t] = -1;\n    for (int i = 0; i < N; ++i) kek1[i] = i;              \n    for (int i = t - 1; i >= 0; --i) {\n        for (int mask = 0; mask < N; ++mask) {\n            int mask1; \n            if (s[i] == 'S') mask1 = xyz[mask]; \n            else mask1 = mask + 1; \n            if (mask1 >= N) mask1 -= N; \n            kek2[mask] = kek1[mask1];\n            if (mask && mask1 == 0) {\n                dp2[mask] = i + 1; \n            } else {\n                dp2[mask] = dp1[mask1]; \n            }   \n        }\n        to[i] = kek2[0]; \n        next[i] = dp2[0]; \n        for (int mask = 0; mask < N; ++mask) {\n            kek1[mask] = kek2[mask]; \n            dp1[mask] = dp2[mask]; \n            dp2[mask] = -1; \n        }\n    }\n    for (int i = 0; i < 7; ++i) add *= 3; \n    int tet = 1; \n    for (int i = 0; i < n; ++i) tet *= 3; \n    for (int ptr = 0; ptr < tet; ++ptr) {\n//        get(ptr); \n        cout << get(ptr) % tet << \" \"; \n    }\n//    cout << TIME; \n    return; \n}                                \n   \nsigned main() {\n#ifdef LOCAL\n    freopen(\"TASK.in\", \"r\", stdin);\n    freopen(\"TASK.out\", \"w\", stdout);\n#else \n    \n#endif // LOCAL\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20); \n    cout << fixed; \n    int t = 1; \n    for (int i = 0; i < t; ++i) {              \n        solve();\n    }\n    return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2,unroll-loops\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing vi = vector<int>;\nusing ll = long long;\nint maxn = 531441, B, C;\nint n, p[531441], f[531441];\nint rev(int a) {\n\tint r = 0, c = 1;\n\twhile(c < maxn) {\n\t\tif(a%3) r +=(3 - (a%3))*c;\n\t\tc*=3,a/=3;\n\t}\n\treturn r;\n}\n \nint s = 0;\nvector<int> small[729];\nint id[531441], lup[531441], u = 0;\n \nvoid add() {\n\ts = (s + B - 1)%B;\n\tfor(auto i : small[s]) {\n\t\tif(lup[i] != u) {\n\t\t\tif((lup[i]^u)&1) id[i] = f[id[i]];\n\t\t\tlup[i] = u;\n\t\t}\n\t\tid[i] = (id[i] + 1)%C;\n\t}\n}\n \nvoid flip() {\n\tu++;\n\tfor(int i = 0; i < B; i++) {\n\t\tif(f[i] <= i) {\n\t\t\tswap(small[(s+i)%B], small[(s+f[i])%B]);\n\t\t}\n\t}\n}\n \nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tstring t;\n\tcin >> n >> t;\n\tmaxn = B = 1;\n\tfor(int i = 0; i < n; i++) maxn *= 3;\n\tfor(int i = 0; i < n/2; i++) B *= 3;\n\tC = maxn/B;\n\tfor(int i = 0; i < maxn; i++) {\n\t\tf[i] = rev(i);\n\t\tsmall[i%B].push_back(i);\n\t\tid[i] = i/B;\n\t}\n\t\n\tfor(auto i : t) {\n\t\tif(i == 'R') add();\n\t\telse flip();\n\t}\n\tfor(int i = 0; i < B; i++)\n\t\tfor(auto j : small[i]) p[j] += (B+i-s)%B;\n\tfor(int i = 0; i < maxn; i++) {\n\t\tif(lup[i] != u) {\n\t\t\tif((lup[i]^u)&1) id[i] = f[id[i]];\n\t\t\tlup[i] = u;\n\t\t}\n\t\tp[i] += B*id[i];\n\t}\n\tfor(int i = 0; i < maxn; i++) cout << p[i] << \" \";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define eb(x,y) emplace_back(x,y)\n#define fi first\n#define se second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=1e6+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\n//inline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\ninline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nint t[MAXN],s[3][MAXN],p[MAXN],d[MAXN],Fpow[20],N,len,n,tot=1,ans[MAXN];char ch[MAXN];\nstruct Node{int id,x,d;};\ninline void Build(){\n\tqueue<Node>q;q.push((Node){1,0,0});\n\twhile(!q.empty()){\n\t\tint x=q.front().id;d[x]=q.front().d,p[x]=q.front().x,q.pop();\n\t\tif(d[x]<n)Rep(i,0,2)s[i][x]=++tot,q.push((Node){s[i][x],p[x]+Fpow[d[x]]*i,d[x]+1});\n\t}\n}\ninline void pushr(int x){swap(s[1][x],s[2][x]),t[x]^=1;}\ninline void pushdown(int x){if(t[x])pushr(s[0][x]),pushr(s[1][x]),pushr(s[2][x]),t[x]=0;}\ninline void Add(int x){\n\tpushdown(x);if(d[x]==n)return;\n\tint s0=s[0][x],s1=s[1][x],s2=s[2][x];\n\ts[1][x]=s0,s[2][x]=s1,s[0][x]=s2,Add(s[0][x]);\n}\nvoid dfs(int x,int val,int d){if(x!=1)ans[p[x]]=val;pushdown(x);if(d==n)return;Rep(i,0,2)dfs(s[i][x],val+Fpow[d]*i,d+1);}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),scanf(\"%s\",ch+1),len=strlen(ch+1);\n\tFpow[0]=1;Rep(i,1,n)Fpow[i]=Fpow[i-1]*3;N=Fpow[n];\n\tBuild();\n\tRep(i,1,len){\n\t\tif(ch[i]=='S')pushr(1);\t\n\t\telse if(ch[i]=='R')Add(1);\n\t}dfs(1,0,0);Rep(i,0,N-1)cout<<ans[i]<<' ';cout<<\"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\nint pos[200000][13];\nint n;\nint se[12];\n\nvoid salsa(){\n\tfor(int i=0;i<pow(3,n);i++){\n\t\tfor(int j=0;j<n;j++){\n\n\t\t\tif(pos[i][j]==1)pos[i][j]=2;\n\t\t\telse if(pos[i][j]==2)pos[i][j]=1;\n\t\t\telse;\n\t\t}\n\t}\n}\nvoid rumba(){\n\tfor(int i=0;i<pow(3,n);i++){\n\t\tint j=0;\n\t\tpos[i][j]++;\n\t\twhile(pos[i][j]==3 && j!=n){\n\t\t\tpos[i][j]=0;\n\t\t\tpos[i][j+1]++;\n\t\t\tj++;\n\t\t}\n\t\t\n\t}\n}\nvoid print(){\n\tfor(int i=0;i<pow(3,n);i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tprintf(\"%d\",pos[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n}\nvoid fun(char i){\n\tif (i=='S'){\n\t\tsalsa();\n\t}\n\telse{\n\t\trumba();\n\t}\n\t// print();\n}\n\nint main(){\n\tchar order[300000];\n\tscanf(\"%d\",&n);\n\tchar c;scanf(\"%c\",&c);\n\n\tfor(int i=0;i<pow(3,n);i++){\n\t\tint num=i;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tpos[i][j]=num%3;\n\t\t\tnum=num/3;\n\t\t}\n\t}\n\n\tchar lol='1';\n\tint itr=0;\n\twhile(lol!='\\n'){\n\t\tscanf(\"%c\",&lol);\n\t\torder[itr++]=lol;\n\t}\n\tfor(int i=0;i<itr-1;i++){\n\t\t// printf(\"%c\\n\",order[i] ); \n\t\tfun(order[i]);\n\t}\n\n\tfor(int i=0;i<pow(3,n);i++){\n\t\tint numb=0;\n\t\tint deg=1;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tnumb+= pos[i][j]*deg;\n\t\t\tdeg*=3;\n\t\t}\n\t\tprintf(\"%d \", numb);\n\t}\n\tprintf(\"\\n\");\n\n}"
  },
  {
    "language": "C++",
    "code": "/*\nProblem :\nAlgorithm :\nStatus :\n*/\n#include<bits/stdc++.h>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cstdlib>\n#define DEBUG printf(\"Passing Line %d in Function [%s].\\n\",__LINE__,__FUNCTION__);\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int INF = 0x3f3f3f3f;\nconst int MAXN = 6377292 + 5;\nconst int BASE = 3;\n\nint n,m;\nint bin[MAXN],ans[MAXN];\nchar s[MAXN];\n\nnamespace Trie{\n    int tot = 1;\n    int trie[MAXN][3],val[MAXN],tag[MAXN];\n\n    void Build(int k,int dep,int num){\n        if(dep == n){\n            val[k] = num;\n            return;\n        }\n        for(int i = 0;i < BASE;i++){\n            trie[k][i] = ++tot;\n            Build(trie[k][i],dep + 1,num + i * bin[dep]);\n        }\n    }\n\n    void down(int k){\n        if(tag[k]){\n            swap(trie[k][1],trie[k][2]);\n            tag[k] = 0;\n            for(int i = 0;i < BASE;i++)\n                tag[trie[k][i]] ^= 1;\n        }\n    }\n\n    void dfs(int k,int dep,int num){\n        if(dep == n){\n            ans[val[k]] = num;\n            return;\n        }\n        down(k);\n        for(int i = 0;i < BASE;i++)\n            dfs(trie[k][i],dep + 1,num + i * bin[dep]);\n    }\n\n    void Add(int k,int dep){\n        if(dep == n)\n            return;\n        down(k);\n        Add(trie[k][2],dep + 1);\n        swap(trie[k][0],trie[k][1]);\n        swap(trie[k][0],trie[k][2]);\n    }\n}\n\n int main(){\n//     freopen(\"data.in\",\"r\",stdin);\n//     freopen(\"data.out\",\"w\",stdout);\n    scanf(\"%d\",&n);\n    scanf(\"%s\",s + 1);\n    m = strlen(s + 1);\n    bin[0] = 1;\n    for(int i = 1;i <= n;i++)\n        bin[i] = bin[i - 1] * BASE;\n    Trie::Build(1,0,0);\n    for(int i = 1;i <= m;i++){\n        if(s[i] == 'S')\n            Trie::tag[1] ^= 1;\n        else if(s[i] == 'R')\n            Trie::Add(1,0);\n    }\n    Trie::dfs(1,0,0);\n    for(int i = 0;i < bin[n];i++)\n        printf(\"%d \",ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n// #include <ext/pb_ds/assoc_container.hpp> \n// #include <ext/pb_ds/detail/standard_policies.hpp>\n// using namespace __gnu_pbds;\n\n#pragma GCC optimize(\"O3\")\n#ifdef LOCAL\n#include \"/Users/lbjlc/Desktop/coding/debug_utils.h\"\n#else\n#define print(...) ;\n#define printn(...) ;\n#define fprint(...) ;\n#define fprintn(...) ;\n#endif\n\n#define rep(i, a, b) for(auto i = (a); i < (b); i++)\n#define rrep(i, a, b) for(auto i = (a); i > (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define pb push_back\n// #define mp make_pair\n#define fi first\n#define se second\n#define maxi(x, y) x = max(x, y)\n#define mini(x, y) x = min(x, y)\n// long long fact(long long n) { if(!n) return 1; return n*fact(n-1); }\n// #define endl '\\n'\n#define solve_testcase int T;cin>>T;for(int t=1;t<=T;t++){solve(t);}\n\n// long long gcd(long long x, long long y) { return y ? gcd(y, x % y) : x; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\n \ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n \ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\ntypedef vector<long long> vll;\n#define bd(type,op,val) bind(op<type>(), std::placeholders::_1, val)\n\nconst int MAXN = 1e6+10;\n\n\nvoid solve(int tt) {\n    // cout<<\"Case #\"<<tt<<\": \";\n}\n\nstring to_ter(int x, int k=-1) {\n    string res;\n    while(x) {\n        res+='0'+x%3;\n        x/=3;\n    }\n    if(k>=0) {\n        while(res.size()<k) res+='0';\n    }\n    return res;\n}\nint to_int(const string & s) {\n    int res=0;\n    // rrep(i,s.size()-1,-1)\n    //     res=res*3+(s[i]-'0');\n    for(int i=s.size()-1;i>=0;i--)\n        res=res*3+(s[i]-'0');\n    // print(s,res);\n    return res;\n}\nbool add(string & x, const string & y) {\n    int n1=x.size(), n2=y.size(),carry=0;\n    rep(i,0,n1) {\n        if(i<n1) carry+=x[i]-'0';\n        if(i<n2) carry+=y[i]-'0';\n        x[i]=carry%3+'0';\n        carry/=3;\n    }\n    return carry==0;\n}\n\nvi cal_inst(string & s) {\n    int n=s.size();\n    vi res(1);\n    int i=0;\n    while(i<n) {\n        if(s[i]=='R') {\n            res.back()++;\n            i++;\n        }\n        else {\n            int j=i;\n            for(;j<n&&s[j]=='S';j++);\n            if((j-i)%2) res.pb(0);\n            i=j;\n        }\n    }\n    if(s.back()=='S') res.pop_back();\n    return res;\n}\n\nchar rev(char c) {\n    if(c>'0') return '0'+(3-(c-'0'));\n    return c;\n}\nstring rev(string s) {\n    for(auto & c:s) c=rev(c);\n    return s;\n}\n\nint len(string & s) {\n    int res=s.size()-1;\n    while(res>=0&&s[res]=='0') res--;\n    return res+1;\n}\n\nvi power(13);\n\nvi cal(vi inst, int n, int tot) {\n    vi res(tot),dp(tot,-1);\n    rep(i,0,tot) {\n        int cur=i;\n        int ok=0;\n        rep(j,5,n) {\n            int cur1=cur%power[j];\n            if(dp[cur1]>=0&&dp[cur1]<power[j]) {\n                cur1=dp[cur1];\n                if(inst.size()%2) {\n                    cur1+=cur/power[j]*power[j];\n                    for(int flag=power[j];flag<power[n];flag*=3) {\n                        int tmp=cur1/flag%3;\n                        if(tmp==1) cur1+=flag;\n                        else if(tmp==2) cur1-=flag;\n                    }\n                }\n                else {\n                    cur1+=cur/power[j]*power[j];\n                }\n                ok=1;\n                res[i]=dp[cur]=cur1;\n                break;\n            }\n        }\n        if(!ok) {\n            int cur1=cur;\n            bool ok1=true;\n            for(auto x:inst) {\n                cur1+=x;\n                if(cur1>=power[n]) ok=0;\n                cur1%=power[n];\n                for(int flag=1;flag<power[n];flag*=3) {\n                    int tmp=cur1/flag%3;\n                    if(tmp==1) cur1+=flag;\n                    else if(tmp==2) cur1-=flag;\n                }\n            }\n            res[i]=dp[cur]=cur1;\n        }\n    }\n    print(dp.size());\n    return res;\n}\n\nint main(int argc, char * argv[]) {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    // solve_testcase;\n\n    int n;\n    string s;\n    cin>>n;\n    cin>>s;\n\n    // n=12;\n    // rep(i,0,1e5) s+=\"RS\";\n\n    power[0]=1;\n    rep(i,1,13) power[i]=power[i-1]*3;\n\n    int tot=1;\n    rep(i,0,n) tot*=3;\n\n    vi inst=cal_inst(s);\n    for(auto & x:inst) x%=tot;\n\n    // print(inst);\n\n    int i=0;\n    int bound=3*3*3*3*3;\n    vi res(tot);\n    iota(all(res),0);\n    while(i<inst.size()) {\n        int cur=inst[i];\n        vi cur_inst({cur});\n        for(++i;i<inst.size()&&cur+inst[i]<bound;i++) {\n            cur+=inst[i];\n            cur_inst.pb(inst[i]);\n        }\n        vi tmp=cal(cur_inst,n,tot);\n        // print(tmp);\n        rep(j,0,tot) res[j]=tmp[res[j]];\n        // print(cur_inst,tmp);\n        // print(res);\n        // sort(all(tmp)); print(tmp);\n    }\n    if(s.back()=='R') {\n        rep(i,0,tot) {\n            res[i]=to_int(rev(to_ter(res[i],n)));\n        }\n    }\n    for(auto x:res) cout<<x<<' ';\n    cout<<endl;\n\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n\nusing namespace std;\n\nint N;\nstring T;\n\nvoid R(int *data);\nvoid S(int *data1, int *data2);\nint X(int x, int y);\n\nint main(){\n  int n;\n  string s1;\n  string s2;\n  cin >> n;\n  cin >> T;\n  N = X(3, n);\n  int L[N];\n  int K[N];\n  int O[N];\n  \n  for(int i=0;i<N;i++){\n    L[i] = i;\n  }\n  \n  for(int i=0;i<N/3;i++){\n    int k = i;\n    int tmp = 0;\n    int m = 3;\n    int q = i*3;\n    \n    while(k>0){\n      if(k%3==1){\n        tmp = tmp +2*m;\n      }else if(k%3==2){\n        tmp = tmp +1*m;\n      }\n      k = k/3;\n      m = m*3;\n    }\n    K[tmp] = q;\n    K[tmp + 1] = q+2;\n    K[tmp + 2] = q+1;\n  }\n  \n  \n  for(int i=0;i<(int)(T.length());i++){\n    s1 = T[i];\n    s2 = T[i+1];\n    if(s1==\"R\"){\n      R(L);\n    }else if(s1==\"S\" && s2==\"S\"){\n      i++;\n    }else{\n      S(L,K);\n    }\n  }\n  \n\n\n  for(int i=0;i<N;i++){\n    cout << L[i] << \" \";\n  }\n  return 0;\n}\n\nvoid R(int *data){\n  for(int i=0;i<N;i++){\n    data[i] = data[i] + 1;\n    if(data[i]==N){\n      data[i]=0;\n    }\n  }\n}\n\nvoid S(int *data1, int *data2){\n  for(int i=0;i<N;i++){\n    data1[i] = data2[data1[i]];\n  }\n}\n\n\nint X(int x,int y){\n  int a = 1;\n  for(int i=0;i<y;i++){\n    a = a*x;\n  }\n  return a;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxs = 797161, maxl = (int)2e5 + 1;\nint n, tot, out[maxs];\nstruct TrieNode {\n\tint idx, tag, ch[3];\n} p[maxs];\nint main() {\n\tstatic char buf[maxl];\n\tscanf(\"%d%s\", &n, buf);\n\t++tot;\n\tint sta = 0, pw = 1;\n\tfor(int i = 0; i < n; ++i, sta += pw, pw *= 3)\n\t\tfor(int j = 0; j < pw; ++j) {\n\t\t\tTrieNode &cur = p[sta + j];\n\t\t\tfor(int k = 0, adt = 0; k < 3; ++k, adt += pw) {\n\t\t\t\tp[tot].idx = cur.idx + adt;\n\t\t\t\tcur.ch[k] = tot++;\n\t\t\t}\n\t\t}\n\tauto expand = [&](int rt) {\n\t\tTrieNode &cur = p[rt];\n\t\tif(cur.tag) {\n\t\t\tswap(cur.ch[1], cur.ch[2]);\n\t\t\tfor(int i = 0; i < 3; ++i)\n\t\t\t\tp[cur.ch[i]].tag ^= 1;\n\t\t\tcur.tag = 0;\n\t\t}\n\t};\n\tfor(int i = 0; buf[i]; ++i) {\n\t\tif(buf[i] == 'S') {\n\t\t\tp[0].tag ^= 1;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int j = 0, rt = 0; j < n; ++j) {\n\t\t\texpand(rt);\n\t\t\tTrieNode &cur = p[rt];\n\t\t\trotate(cur.ch, cur.ch + 2, cur.ch + 3);\n\t\t\trt = cur.ch[0];\n\t\t}\n\t}\n\tfunction<void(int, int, int, int)> dfs = [&](int dep, int rt, int pw, int val) {\n\t\tTrieNode &cur = p[rt];\n\t\tif(dep == n) {\n\t\t\tout[cur.idx] = val;\n\t\t} else {\n\t\t\texpand(rt);\n\t\t\tint npw = pw * 3;\n\t\t\tdfs(dep + 1, cur.ch[0], npw, val);\n\t\t\tdfs(dep + 1, cur.ch[1], npw, val += pw);\n\t\t\tdfs(dep + 1, cur.ch[2], npw, val += pw);\n\t\t}\n\t};\n\tdfs(0, 0, 1, 0);\n\tfor(int i = 0; i < pw; ++i)\n\t\tprintf(\"%d%c\", out[i], \" \\n\"[i == pw - 1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nstatic inline char CH()\n{\n  static char buf[100000],*ptr1=buf,*ptr2=buf;\n  return ptr1==ptr2&&(ptr2=(ptr1=buf)+fread(buf,1,100000,stdin),ptr1==ptr2)?EOF:*ptr1++;\n}\nstatic inline int IN(void)\n{\n  int x=0,f=0,c=CH();while(c<48||c>57){f^=c==45,c=CH();}\n  while(c>47&&c<58){x=x*10+c-48,c=CH();}return f?-x:x;\n}\nstatic inline int Pow(int a,int b){return b?Pow(a*a,b>>1)*(b&1?a:1):1;}\nint main()\n{\n  int N=IN(),now,len=0,pw3=Pow(3,N),x=Pow(3,N>>1),y=Pow(3,N-(N>>1)),A[531441],B[531441];\n  char c=CH(),T[200001],S[200000];\n  rep(i,pw3)B[i]=B[i/3]*3+(3-i%3)%3;\n  while(c!=EOF){if(c=='\\t'||c==' '||c=='\\n'){c=CH();}T[len++]=c,c=CH();}\n  fflush(stdin);\n  rep(i,x)\n  {\n    int temp=i;now=0;\n    rep(j,len)\n    {\n      if(T[j]=='S'){temp=B[temp];if(S[now]=='S')--now;else S[++now]='S';}\n      else{++temp;if(temp==x)S[++now]='R',temp=0;}\n    }\n    rep(j,y)\n    {\n      int keep=j;\n      rep(k,now)\n      {\n        if(S[k+1]=='S')keep=B[keep];\n        else if(S[k+1]=='R')if((++keep)==y)keep=0;\n      }\n      A[i+j*x]=temp+keep*x;\n    }\n  }\n  rep(i,pw3)printf(\"%i%c\",A[i],i+1==pw3?'\\n':' ');\n  return fflush(stdout),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\nint n, dp[1100000], c[3] = {0,1,2}, rc[3] = {0,1,2}, sz, u=1;\nchar s[200005];\nint main(){\n\tscanf(\"%d\\n%s\", &n, s);\n\tsz = strlen(s);\n\n\tfor(int i=0, t=1; i<n; i++, t*=3) rep(j,3) rep(k,t) dp[t*(3+j)+k] = j;\n\trep(i,sz){\n\t\tif(s[i] == 'S'){\n\t\t\trep(j,3) if(c[j]) rc[c[j] = 3 - c[j]] = j;\n\t\t}else for(int i=0, t=1, k=0, nk=0; i<n; i++, k=nk, t*=3) rep(j,3){\n\t\t\tif(c[dp[t*(3+j)+k]] == 2) nk = t * j + k;\n\t\t\tdp[t*(3+j)+k] = rc[(c[dp[t*(3+j)+k]]+1)%3];\n\t\t}\n\t}\n\trep(i,n) u *= 3;\n\trep(i,u){\n\t\tint ans = 0;\n\t\tfor(int j=0, t=3, t2=1; j<n; j++, t*=3, t2*=3) ans += c[dp[i%t+t]] * t2;\n\t\tprintf(\"%d%c\", ans, i==u-1 ? '\\n' : ' ');\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid read(int &x){\n\tregister char ch=getchar();x=0;\n\tfor(;ch==' '||ch=='\\n';ch=getchar());\n\tfor(;ch!=' '&&ch!='\\n';x=x*10+ch-'0',ch=getchar());\n}\nvoid reads(string &s){\n\tregister char ch=getchar();s=\"\";\n\tfor(;ch==' '||ch=='\\n';ch=getchar());\n\tfor(;ch!=' '&&ch!='\\n';s+=ch,ch=getchar());\n}\nvoid write(int x){\n\tif(x>9)write(x/10);\n\tputchar(x%10+'0');\n}\nint K,pw[13],ans[800000],dat[800000],go[800000][3];\nbool lz[800000];\nstring typ;\nvoid built_trie(int id,int lv,int now){ \n\tif(lv==K){\n\t\tdat[id]=now;return;\n\t}\n\tfor(int i=0;i<3;i++){\n\t\tgo[id][i]=id*3+i+1;\n\t\tbuilt_trie(go[id][i],lv+1,now+i*pw[lv]);\n\t}\n}\nvoid push_down(int id){\n\tswap(go[id][1],go[id][2]);\n\tfor(int i=0;i<3;i++)lz[go[id][i]]^=1;\n\tlz[id]=0;\n}\nvoid update_trie(int id,int lv){\n\tif(lv==K)return;\n\tif(lz[id])push_down(id);\n\tupdate_trie(go[id][2],lv+1);\n\tswap(go[id][1],go[id][2]),swap(go[id][0],go[id][1]);\n}\nvoid make_ans(int id,int lv,int now){\n\tif(lv==K){\n\t\tans[dat[id]]=now;\n\t\treturn;\n\t}\n\tif(lz[id])push_down(id);\n\tfor(int i=0;i<3;i++)\n\t\tmake_ans(go[id][i],lv+1,now+i*pw[lv]);\n}\nint main(){\n\tpw[0]=1,read(K),reads(typ);\n\tfor(int i=1;i<=K;i++)pw[i]=pw[i-1]*3;\n\tbuilt_trie(0,0,0);\n\tfor(int i=0;i<typ.size();i++){\n\t\tif(typ[i]=='S')lz[0]^=1;\n\t\telse update_trie(0,0);\n\t}\n\tmake_ans(0,0,0);\n\tfor(int i=0;i<pw[K];i++)write(ans[i]),putchar(' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nvoid update(int q, int& last, int& d) {\n    if (d != 0 and q%2 != last%2) d = 3-d;\n    last = q;\n}\n \npair<vector<int>, vector<int>> solve(int n, const string& T) {\n    if (n == 0) {\n        vector<int> P = {0};\n        vector<int> W(T.size(), 0);\n        return {P, W}; \n    }\n    auto pp = solve(n-1, T);\n    const auto& P = pp.first;\n    const auto& W = pp.second;\n    vector<int> new_W(W.size());\n    int pot = P.size();\n    vector<int> D(3*pot);\n    for (int i = 0; i < 3; i++) for (int x = 0; x < pot; x++) D[i*pot + x] = i;\n    vector<int> last(3*pot, 0);\n    int q = 0;\n    for (int i = 0; i < (int)T.size(); i++) {\n        int k = W[i];\n        for (int x = k; x < 3*pot; x += pot) {\n            update(q, last[x], D[x]);\n            if (D[x] == 2) new_W[i] = x;\n        }\n        if (T[i] == 'S') q++;\n        if (T[i] == 'R') {\n            for (int x = k; x < 3*pot; x += pot) D[x] = (D[x]+1)%3;\n        }\n    }\n \n    vector<int> new_P(3*pot);\n    for (int i = 0; i < 3*pot; i++) {\n        update(q, last[i], D[i]);\n        new_P[i] = P[i%pot] + D[i] * pot;\n    }\n \n    return {new_P, new_W};\n}\n \nint main() {\n    int N;\n    cin >> N;\n    string T;\n    cin >> T;\n    vector<int> P = solve(N, T).first;\n    for (int x: P) cout << x << \" \";\n    cout << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef double D;\ntypedef long long int LL;\n\n#define st first\n#define nd second\n#define PLL pair <LL, LL>\n#define PII pair <int, int>\n\nconst int N = 1e6 + 7;\nconst int M = 1007;\n\nint n, all;\nchar instr[N];\n\nint up[N];\nint nxt[M];\nint down[N];\n\nint p;\nint up_rv[M];\nint up_val[M];\n\nint q;\nint cur[M];\nvector <int> ids[M];\n\nint get(int t){\n\tint ret = 0, tmp = 1;\n\twhile(t){\n\t\tint r = t % 3;\n\t\tt /= 3;\n\t\t\n\t\tif(r)\tr ^= 3;\n\t\tret += tmp * r;\n\t\ttmp *= 3;\n\t}\n\t\n\treturn ret;\n}\n\nvoid swap_all(){\n\tfor(int i = 0; i < p; ++i)\n\t\tcur[i] = nxt[cur[i]];\n\t\n\tfor(int i = 0; i < q; ++i){\n\t\tup_val[i] = nxt[up_val[i]];\n\t\tup_rv[up_val[i]] = i;\n\t}\n}\n\nvoid add(){\n\tfor(int i = 0; i < p; ++i)\n\t\tif(cur[i] + 1 < p)\n\t\t\t++cur[i];\n\t\telse{\n\t\t\tcur[i] = 0;\n\t\t\tfor(auto t: ids[i]){\n\t\t\t\tint me = up_val[up[t]];\n\t\t\t\tif(me + 1 < q)\n\t\t\t\t\t++me;\n\t\t\t\telse\n\t\t\t\t\tme = 0;\n\t\t\t\tup[t] = up_rv[me];\n\t\t\t}\n\t\t}\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tall = 1;\n\tfor(int i = 1; i <= n; ++i)\n\t\tall *= 3;\n\t\n\tp = 1, q = 1;\n\tfor(int i = 1; i <= (n + 1) / 2; ++i)\n\t\tp *= 3;\n\t\n\tfor(int i = (n + 1) / 2 + 1; i <= n; ++i)\n\t\tq *= 3;\n\n\tfor(int i = 0; i < p; ++i)\n\t\tnxt[i] = get(i);\n\n\tfor(int i = 0; i < all; ++i){\n\t\tdown[i] = i % p;\n\t\tup[i] = i / p;\n\t\tids[down[i]].push_back(i);\n\t}\n\t\n\tfor(int i = 0; i < p; ++i)\n\t\tcur[i] = i;\n\tfor(int i = 0; i < q; ++i)\n\t\tup_val[i] = up_rv[i] = i;\n\t\n\tscanf(\"%s\", instr + 1);\n\tint l = strlen(instr + 1);\n\t\n\tfor(int v = 1; v <= l; ++v){\n\t\tif(instr[v] == 'R')\n\t\t\tadd();\n\t\telse\n\t\t\tswap_all();\n\n//\t\tfor(int i = 0; i < all; ++i)\n//\t\t\tprintf(\"%d \", up_val[up[i]] * p + cur[down[i]]);\n//\t\tputs(\"\");\n\t}\n\t\n\tfor(int i = 0; i < all; ++i)\n\t\tprintf(\"%d \", up_val[up[i]] * p + cur[down[i]]);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n\nusing namespace std;\n\nlong long N;\n\nlong long s (long long x){\n  long long i = x;\n  long long c=0;\n  for(long long n=1;x>=n;n*=3){\n    long long a = i%3;\n    printf(\"%d\\n\",a);\n    i /= 3;\n    if(a == 1)\n      c += n*2;\n    if(a == 2)\n      c += n;\n  }\n  return c;\n}\nlong long r (long long x){\n  return (x+1) % N;\n}\n\nlong long pow3(int n){\n  if(n == 1)\n    return 3;\n  long long r = pow3(n/2);\n  if(n%2 == 1)\n    return r*r*3;\n  return r*r;    \n\n}\n\nint main(){\n  long long n;\n  scanf(\"%d\",&n);\n  N = pow3(n);\n  char danse[200000];\n  scanf(\"%s\",danse);\n  for(int i=0;i<N;i++){\n    if(i != 0)\n      printf(\" \");\n    int res = i;\n    for(char d: danse){\n      if(d == 'S'){\n        res = s(res);\n      }else if(d == 'R'){\n        res = r(res);\n      }else{\n        break;\n      }\n    }\n    printf(\"%d\", res);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: C.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef unsigned uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> cp;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nint rev;\nint to[1000005][3],m;\nint t(int b){return b^(rev&&b?3:0);}\nint &trans(int a,int b){\n\tif(!b)return to[a][b];\n\treturn rev?to[a][3-b]:to[a][b];\n}\nint n;\nint pw[15];\nint v[1000005];\nint build(int x,int y){\n\tint id=++m;\t\n\tif(x==n){v[id]=y;return id;}\n\tto[id][0]=build(x+1,y);\n\tto[id][1]=build(x+1,y+pw[x]);\n\tto[id][2]=build(x+1,y+2*pw[x]);\n\treturn id;\n}\nint ans[1000005];\nvoid work(int x){\n\tif(!x)return;\n\tint t=trans(x,2);\n\ttrans(x,2)=trans(x,1);\n\ttrans(x,1)=trans(x,0);\n\ttrans(x,0)=t;\n\twork(t);\n}\nvoid dfs(int x,int y,int dep){\n\tif(dep==n){ans[v[x]]=y;return;}\n\tfor(int i=0;i<3;++i)dfs(trans(x,i),y+i*pw[dep],dep+1);\n}\nchar s[200005];\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"C.in\",\"r\",stdin);\n\tfreopen(\"C.out\",\"w\",stdout);\n#endif\n\tread(n);\n\tpw[0]=1;for(int i=1;i<=n;++i)pw[i]=pw[i-1]*3;\n\tbuild(0,0);\n\tread(s);\n\tint m=strlen(s);\n\tfor(int i=0;i<m;++i){\n\t\tif(s[i]=='S')rev^=1;\n\t\telse work(1);\n\t}\n\tdfs(1,0,0);\n\tfor(int i=0;i<pw[n];++i)write(ans[i],i==pw[n]-1?'\\n':' ');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 729 + 10;\nint p[13];\nchar s[200000];\nint a[N][N],b[N],r[N],ans[N*N];\nvoid print(){\n    for(int i=0;i<3;i++){\n        cout<<b[i]<<':';\n        for(int j=0;j<3;j++) cout<<' '<<a[i][j];\n        cout<<endl;\n    }\n//    cout<<endl;\n}\nint pos[9];\nvoid brute(char c){\n    if(c=='S'){\n        for(int i=0;i<9;i++) if(i<r[i]) swap(pos[i],pos[r[i]]);\n    }\n    else{\n        for(int i=8;i>0;i--) swap(pos[i],pos[i-1]);\n    }\n    for(int i=0;i<3;i++){\n        for(int j=0;j<3;j++){\n            cout<<pos[i+j*3]<<' ';\n        }\n        cout<<endl;\n    }\n    cout<<endl;\n}\nint main(){\n//    for(int i=0;i<9;i++) pos[i] = i;\n    p[0] = 1; for(int i=1;i<13;i++) p[i] = p[i-1] * 3;\n    int n; scanf(\"%d%s\",&n,s);\n    int x = n / 2, y = n - x;\n    ///y: low, x: high\n    for(int i=0;i<p[6];i++){\n        int t = i;\n        for(int j=0;j<6;j++){\n            if(t/p[j]%3==1) t += p[j];\n            else if(t/p[j]%3==2) t -= p[j];\n        }\n        r[i] = t;\n    }\n    for(int i=0;i<p[n];i++){\n        a[i%p[y]][i/p[y]] = i;\n    }\n//    print();\n    for(int i=0;s[i];i++){\n        if(s[i]=='S'){\n            for(int j=0;j<p[y];j++) b[j] ^= 1;\n            for(int j=0;j<p[y];j++) if(j<r[j]){\n                swap(a[j],a[r[j]]);\n                swap(b[j],b[r[j]]);\n            }\n        }\n        else{\n            for(int j=p[y]-1;j>0;j--){\n                swap(a[j],a[j-1]);\n                swap(b[j],b[j-1]);\n            }\n            if(b[0]){\n                for(int j=0;j<p[x];j++) if(j<r[j]) swap(a[0][j],a[0][r[j]]);\n                b[0] = 0;\n            }\n            for(int j=p[x]-1;j>0;j--){\n                swap(a[0][j],a[0][j-1]);\n            }\n        }\n//        print();\n//        brute(s[i]);\n    }\n    for(int i=0;i<p[y];i++) if(b[i]){\n        for(int j=0;j<p[x];j++) if(j<r[j]) swap(a[i][j],a[i][r[j]]);\n        b[i] = 0;\n    }\n//    print();\n    for(int i=0;i<p[n];i++) ans[a[i%p[y]][i/p[y]]] = i;\n    for(int i=0;i<p[n];i++) printf(\"%d%c\",ans[i],\" \\n\"[i==p[n]-1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr<<\"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return rng() % (y+1-x) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\nusing ll=long long; \nusing ld=long double;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\nusing pi=pair<ll,ll>; using spi=pair<ll,pi>; using dpi=pair<pi,pi>; \n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (600006)\nll n, A[MAXN], p3[15], ofs2, half, mp[729], edge[729];\nstring T;\nvector<ll> v[729];\nll flip(ll x){\n\tll res=0;\n\tDEC(j,n-1,half) if(x>=p3[j]*2) {\n\t\tres += p3[j];\n\t\tx -= p3[j] * 2;\n\t} else if(x>=p3[j]) {\n\t\tres += p3[j] * 2;\n\t\tx -= p3[j];\n\t}\n\treturn res;\n}\nint main(){\n\tp3[0]=1; FOR(i,1,14) p3[i]=p3[i-1]*3;\n\tFAST\n\tcin>>n>>T;half=n/2;\n\tFOR(i,0,p3[half]-1) mp[i]=i;\n\tFOR(i,0,p3[half]-1){\n\t\tedge[i]=i;\n\t\tll add=0;\n\t\tDEC(j,half-1,0)if(edge[i]>=p3[j]*2){\n\t\t\tedge[i] -= p3[j] * 2;\n\t\t\tadd += p3[j];\n\t\t}else if(edge[i]>=p3[j]) {\n\t\t\tedge[i] -= p3[j];\n\t\t\tadd += p3[j] * 2;\n\t\t}assert(edge[i]==0);\n\t\tedge[i]=add;\n\t}\n\tFOR(i,0,p3[n]-1){\n\t\tA[i]=i;\n\t\tDEC(j,n-1,half) if(A[i]>=p3[j]*2) A[i]-=p3[j]*2; else if(A[i]>=p3[j]) A[i]-=p3[j];\n\t\tv[A[i]].eb(i), A[i]=i-A[i];\n\t}\n\tFOR(i,0,siz(T)-1){\n\t\tif(T[i]=='R'){//+1\n\t\t\tll act=-1;\n\t\t\tFOR(i,0,p3[half]-1) if(mp[i]==p3[half]-1) assert(act==-1), act=i;\n\t\t\tassert(~act);\n\t\t\tfor(auto i:v[act]) {\n\t\t\t\tif(ofs2) A[i]=flip(A[i]);\n\t\t\t\tA[i] += p3[half];\n\t\t\t\tif(A[i] >= p3[n]) A[i] -= p3[n], assert(A[i]==0);\n\t\t\t\tif(ofs2) A[i]=flip(A[i]);\n\t\t\t}\n\t\t\tFOR(i,0,p3[half]-1) ++ mp[i], mp[i] %= p3[half];\n\t\t}else{\n\t\t\tofs2 ^= 1;\n\t\t\tFOR(i,0,p3[half]-1){\n\t\t\t\tmp[i]=edge[mp[i]];\n\t\t\t}\n\t\t}\n\t\tFOR(i,0,p3[half]-1) cerr<<mp[i]<<' '; cerr<<endl;\n\t}\n\tFOR(i,0,p3[n]-1) if(ofs2) A[i]=flip(A[i]);\n\tFOR(i,0,p3[half]-1) {\n\t\tfor(auto j:v[i]) A[j] += mp[i];\n\t}\n\tFOR(i,0,p3[n]-1) cout<<A[i]<<' '; cout<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n// #include <ext/pb_ds/assoc_container.hpp> \n// #include <ext/pb_ds/detail/standard_policies.hpp>\n// using namespace __gnu_pbds;\n\n#pragma GCC optimize(\"O3\")\n#ifdef LOCAL\n#include \"/Users/lbjlc/Desktop/coding/debug_utils.h\"\n#else\n#define print(...) ;\n#define printn(...) ;\n#define fprint(...) ;\n#define fprintn(...) ;\n#endif\n\n#define rep(i, a, b) for(auto i = (a); i < (b); i++)\n#define rrep(i, a, b) for(auto i = (a); i > (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define pb push_back\n// #define mp make_pair\n#define fi first\n#define se second\n#define maxi(x, y) x = max(x, y)\n#define mini(x, y) x = min(x, y)\n// long long fact(long long n) { if(!n) return 1; return n*fact(n-1); }\n// #define endl '\\n'\n#define solve_testcase int T;cin>>T;for(int t=1;t<=T;t++){solve(t);}\n\n// long long gcd(long long x, long long y) { return y ? gcd(y, x % y) : x; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\n \ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n \ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\ntypedef vector<long long> vll;\n#define bd(type,op,val) bind(op<type>(), std::placeholders::_1, val)\n\nconst int MAXN = 1e6+10;\n\n\nvoid solve(int tt) {\n    // cout<<\"Case #\"<<tt<<\": \";\n}\n\nstring to_ter(int x, int k=-1) {\n    string res;\n    while(x) {\n        res+='0'+x%3;\n        x/=3;\n    }\n    if(k>=0) {\n        while(res.size()<k) res+='0';\n    }\n    return res;\n}\nint to_int(const string & s) {\n    int res=0;\n    // rrep(i,s.size()-1,-1)\n    //     res=res*3+(s[i]-'0');\n    for(int i=s.size()-1;i>=0;i--)\n        res=res*3+(s[i]-'0');\n    // print(s,res);\n    return res;\n}\nbool add(string & x, const string & y) {\n    int n1=x.size(), n2=y.size(),carry=0;\n    rep(i,0,n1) {\n        if(i<n1) carry+=x[i]-'0';\n        if(i<n2) carry+=y[i]-'0';\n        x[i]=carry%3+'0';\n        carry/=3;\n    }\n    return carry==0;\n}\n\nvi cal_inst(string & s) {\n    int n=s.size();\n    vi res(1);\n    int i=0;\n    while(i<n) {\n        if(s[i]=='R') {\n            res.back()++;\n            i++;\n        }\n        else {\n            int j=i;\n            for(;j<n&&s[j]=='S';j++);\n            if((j-i)%2) res.pb(0);\n            i=j;\n        }\n    }\n    if(s.back()=='S') res.pop_back();\n    return res;\n}\n\nchar rev(char c) {\n    if(c>'0') return '0'+(3-(c-'0'));\n    return c;\n}\nstring rev(string s) {\n    for(auto & c:s) c=rev(c);\n    return s;\n}\n\nint len(string & s) {\n    int res=s.size()-1;\n    while(res>=0&&s[res]=='0') res--;\n    return res+1;\n}\n\nint power[13]={};\nint revmap[MAXN]={};\nint tmpres[MAXN];\nint rev(int x) {\n    for(int flag=1;flag<power[12];flag*=3) {\n        int tmp=x/flag%3;\n        if(tmp==1) x+=flag;\n        else if(tmp==2) x-=flag;\n    }\n    return x;\n}\n\nvoid cal(vi inst, int n, int tot) {\n    // vi tmpres(tot,-1);\n    fill(tmpres,tmpres+tot,-1);\n\n    rep(i,0,tot) {\n        if(tmpres[i]>=0) continue;\n\n        int cur=i,ok=1;\n        for(auto x:inst) {\n            cur+=x;\n            if(cur>=power[n]) {\n                ok=0; \n                cur%=power[n];\n            }\n            cur=revmap[cur];\n        }\n        // if(i<=9) print(i,cur);\n        tmpres[i]=cur;\n        // assert(cur>=0);\n        if(!ok) continue;\n        int flag=1,tmp;\n        for(;flag<=i||flag<=cur;flag*=3);\n\n        if(inst.size()%2==0) {\n            for(tmp=flag;tmp<power[n];tmp+=flag) {\n                tmpres[tmp+i]=tmp+cur;\n            }\n        }\n        else {\n            for(tmp=flag;tmp<power[n];tmp+=flag) {\n                tmpres[tmp+i]=revmap[tmp]+cur;\n            }\n\n        }\n    }\n    // print(1);\n    // print(*max_element(all(res)),*min_element(all(res)));\n    // return res;\n}\n\nint main(int argc, char * argv[]) {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    // solve_testcase;\n\n    int n;\n    string s;\n    cin>>n;\n    cin>>s;\n\n    // n=12;\n    // rep(i,0,1e5) s+=\"RS\";\n\n    power[0]=1;\n    rep(i,1,13) power[i]=power[i-1]*3;\n\n    int tot=1;\n    rep(i,0,n) tot*=3;\n\n    rep(i,0,tot) revmap[i]=rev(i);\n    // printn(revmap,9);\n\n\n    vi inst=cal_inst(s);\n    for(auto & x:inst) x%=tot;\n\n    // print(inst);\n\n    int i=0;\n    int bound=81;\n    vi res(tot);\n    iota(all(res),0);\n    while(i<inst.size()) {\n        int cur=inst[i];\n        vi cur_inst({cur});\n        for(++i;i<inst.size()&&cur+inst[i]<bound;i++) {\n            cur+=inst[i];\n            cur_inst.pb(inst[i]);\n        }\n        cal(cur_inst,n,tot);\n        // print(tmp);\n        rep(j,0,tot) res[j]=tmpres[res[j]];\n        // print(cur_inst,tmp);\n        // print(res);\n        // sort(all(tmp)); print(tmp);\n    }\n    if(s.back()=='R') {\n        rep(i,0,tot) {\n            res[i]=to_int(rev(to_ter(res[i],n)));\n        }\n    }\n    for(auto x:res) cout<<x<<' ';\n    cout<<endl;\n\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXT = 200000;\nconst int MAXM = 531450;\n\nchar T[MAXT + 5]; int N, M, K, lenT;\nint pw3(int x) {\n\tint r = 1;\n\tfor(int i=1;i<=x;i++) r *= 3;\n\treturn r;\n}\n\nint b[3][MAXM + 5], t[MAXT + 5], t1[MAXT + 5], id[3];\n\nint a[MAXM + 5], ans[MAXM + 5], res[MAXM + 5];\nint main() {\n\tscanf(\"%d%s\", &N, T), M = 3, K = 1, lenT = strlen(T);\n\tfor(int i=1;i<=N;i++,M*=3,K*=3) {\n\t\tfor(int j=0;j<3;j++)\n\t\t\tfor(int k=0;k<K;k++)\n\t\t\t\tb[j][k] = j;\n\t\t\n\t\tid[0] = 0, id[1] = 1, id[2] = 2;\n\t\tfor(int j=0;j<lenT;j++) {\n\t\t\tif( T[j] == 'S' )\n\t\t\t\tswap(id[1], id[2]);\n\t\t\telse {\n\t\t\t\tint x = t[j], a0 = b[id[0]][x], a1 = b[id[1]][x], a2 = b[id[2]][x];\n\t\t\t\tt1[j] = b[id[2]][x]*K + x;\n\t\t\t\tb[id[0]][x] = a2, b[id[1]][x] = a0, b[id[2]][x] = a1;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<lenT;j++) t[j] = t1[j];\n\t\t\n\t\tfor(int j=0;j<3;j++)\n\t\t\tfor(int k=0;k<K;k++)\n\t\t\t\tres[b[id[j]][k]*K + k] = j*K + ans[k];\n\t\tfor(int j=0;j<M;j++) ans[j] = res[j];\n\t}\n\t\n\tfor(int i=0;i<M/3;i++) printf(\"%d \", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#include<chrono>\n#include<random>\n#include<iostream>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\n#define VI vector<int>\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int MAXN=2e6;\nconst int MAXV=13;\nint bin[15];\nint n,m,ans[MAXN];\nstruct Trie\n{\n\tint son[MAXN][3],tot,root;\n\tint val[MAXN];\n\tbool rev[MAXN];\n\tvoid insert(int v)\n\t{\n\t\tint p=root;\n\t\tfor(int i=0;i<=n-1;i++)\n\t\t{\n\t\t\tint c=v/bin[i];c%=3;\n\t\t\tif(!son[p][c])son[p][c]=++tot;\n\t\t\tp=son[p][c];\n\t\t}val[p]=v;\n\t}\n\tvoid down(int p)\n\t{\n\t\tif(!rev[p])return ;\n\t\tswap(son[p][1],son[p][2]);\n\t\trev[son[p][0]]^=1;rev[son[p][1]]^=1;rev[son[p][2]]^=1;rev[p]=0;\n\t}\n\tvoid addone(int p,int dep)\n\t{\n\t\tif(dep==0)return ;\n\t\tdown(p);int a=son[p][0],b=son[p][1],c=son[p][2];\n\t\tson[p][0]=c;son[p][1]=a;son[p][2]=b;\n\t\taddone(son[p][0],dep-1);\n\t}\n\tvoid getans(int p,int dep,int nowp)\n\t{\n\t\tif(dep==n){ans[val[p]]=nowp;return ;}\n\t\tdown(p);\n\t\tgetans(son[p][0],dep+1,nowp);\n\t\tgetans(son[p][1],dep+1,nowp+bin[dep]);\n\t\tgetans(son[p][2],dep+1,nowp+2*bin[dep]);\n\t}\n}tr;\nchar ch[MAXN];\nint main()\n{\n\t#ifdef Rose\n\t\tdouble BeginJudgeTime=clock();\n\t#endif\n\tbin[0]=1;for(int i=1;i<15;i++)bin[i]=bin[i-1]*3;\n\tn=read();\n\tscanf(\"%s\",ch+1);m=strlen(ch+1);\n\ttr.tot=tr.root=1;\n\tfor(int i=0;i<bin[n];i++)\n\t\ttr.insert(i);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(ch[i]=='S')tr.rev[1]^=1;\n\t\telse tr.addone(1,n);\n\t}\n\ttr.getans(1,0,0);\n\tfor(int i=0;i<bin[n];i++)pr1(ans[i]);\n\tputs(\"\");\n\t#ifdef Rose\n\t\tdouble EndJudgeTime=clock();\n\t\tcerr<<\"JudgeTime is\"<<\" \";\n\t\tcerr<<(EndJudgeTime-BeginJudgeTime)/CLOCKS_PER_SEC<<endl;\n\t#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\ntypedef long long LL;\nconst LL sz=pow(3,12);\nint N,th,y;\nLL P[sz],x,t[12]={0},TRI;\nvoid init(){for(int i=0;i<sz;i++)P[i]=i;}\nint compare(const int*a,const int*b){if(*a<*b)return -1;else if(*a==*b)return 0;else return 1;}\ninline LL IN(void)\n{\n  LL x=0;short f=0,c=getchar();\n  while(c<48||c>57)f^=c==45,c=getchar();\n  while(c>47&&c<58)x=x*10+c-48,c=getchar();\n  return f?-x:x;\n}\nvoid rum()\n{\n  for(LL trit=0;trit<TRI;trit++)\n  {\n    x=P[trit];y=0;\n    for(int i=0;i<12;i++)\n    {\n      y++;t[i]=x%3;\n      if(t[i]==1)t[i]=2;else if(t[i]==2)t[i]=1;else t[i]=0;\n      if(x<3)break;x/=3;\n    }\n    x=0;\n    for(int i=0;i<y;i++)x+=t[i]*pow(3,i);\n    if(x==TRI)x=0;\n    P[trit]=x;\n  }\n}\nvoid sul()\n{\n  for(int trit=0;trit<TRI;trit++)\n  {\n    P[trit]++;if(P[trit]==TRI)P[trit]=0;\n  }\n}\nsigned main(void)\n{\n  char S[200000];\n  LL i;\n  init();\n  N=IN();i=scanf(\"%s\",S);TRI=pow(3,N);\n  for(i=0;i<strlen(S);i++)\n  {\n    if(S[i]=='R')rum();\n    else sul();\n  }\n  for(i=0;i<TRI;i++)printf(\"%lld \",P[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar T[550005];\nint salsa2[550005];\nint salsaNext[550005];\nint p[550005];\n\nint N;\n\nint salsa(int x){\n    int temp = x;\n    int pow3 = 1;\n    int res = 0;\n    for(int i = 0; i < N; i ++){\n        int k = temp%3;\n        temp /= 3;\n\n        if(k == 1){\n            res += pow3*2;\n        }else if(k == 2){\n            res += pow3;\n        }\n        pow3 *= 3;\n    }\n    return res;\n}\n\nint main(){\n    scanf(\"%d\", &N);\n\n    scanf(\" %s\", T);\n\n    int M = strlen(T);\n\n    int pow3N = 1;\n    for(int i = 0; i < N; i ++){\n        pow3N *= 3;\n    }\n\n    for(int i = 0; i < pow3N; i ++){\n        salsa2[i] = salsa(i);\n        //printf(\"salsa2[%d]=%d\\n\", i, salsa2[i]);\n    }\n\n    for(int j = 0; j < pow3N; j ++){\n        int x = j;\n        for(int i = 0; i < M; i ++){\n            if(T[i] == 'R'){\n                x = (x+1)%pow3N;\n            }else if(T[i] == 'S'){\n                x = salsa2[x];\n            }\n        }\n        p[j] = x;\n    }\n\n    for(int i = 0; i < pow3N; i ++){\n        printf(\"%d \", p[i]);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n// headers {{{\nusing namespace std;\n// using namespace rel_ops;\n \ntypedef long long int64;\ntypedef unsigned long long uint64;\nconst double pi=acos(-1.0);\nconst double eps=1e-11;\nconst int INF=0x7FFFFFFF;\ntemplate<class T> inline bool checkmin(T &a,T b){return b<a?a=b,1:0;}\ntemplate<class T> inline bool checkmax(T &a,T b){return b>a?a=b,1:0;}\ntemplate<class T> inline T sqr(T x){return x*x;}\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<PII> VII;\n#define MP(A,B) make_pair(A,B)\n#define PB(X) push_back(X)\n#define mem(a,b) memset(a, b, sizeof(a))\n#define clr(a) memset(a, 0, sizeof(a))\n#define rep(i,n) for(int i=0; i<(int)n; i++)\n#define repit(i,v) for(typeof(v.begin()) i=v.begin(); i!=v.end(); i++)\n#define iter(v) typeof(v.begin())\n#define ff first\n#define ss second\n#ifdef LOCAL\n#define dbg(args...) printf(args); //##__VA_ARGS__\n#define dout cout\n#define out(x) (cout<<#x<<\": \"<<x<<endl)\ntemplate<class T>void show(T a, int n){for(int i=0; i<n; ++i) cout<<a[i]<<' '; cout<<endl;}\ntemplate<class T>void show(T a, int r, int l){for(int i=0; i<r; ++i)show(a[i],l);cout<<endl;}\n#else\n#define dbg(...)\n#define dout if(true);else cout\n#define out(...)\n#define show(...)\n#endif\n// }}}\n\nstruct B {\n    B* p[3] = {};\n    int idx;\n    bool rev = false;\n    void push() {\n        if (rev) {\n            swap(p[1], p[2]);\n            for (auto c : p) if (rev && c) c->reverse();\n            rev = 0;\n        }\n    }\n    void reverse() {\n        rev ^= 1;\n    }\n};\n\nint main() {\n    // ios_base::sync_with_stdio(false);\n    // cin.tie(NULL);\n    // cout.tie(NULL); \n    int N;\n    while (cin >> N) {\n\t\tint tot = 1;\n        rep(i, N) tot *= 3;\n        B root;\n        rep(i, tot) {\n            B* s = &root;\n            int c = i;\n            rep(j, N) {\n                int k = c % 3; c /= 3;\n                if (!s->p[k]) s->p[k] = new B();\n                s = s->p[k];\n            }\n            s->idx = i;\n        }\n        string t; cin >> t;\n        rep(i, t.length()) {\n            if (t[i] == 'S') root.reverse();\n            else {\n                B* c = &root;\n                rep(i, N) {\n                    c->push();\n                    B* tmp = c->p[2];\n                    c->p[2] = c->p[1];\n                    c->p[1] = c->p[0];\n                    c->p[0] = tmp;\n                    c = c->p[0];\n                }\n            }\n        }\n        VI pos(tot);\n        rep(i, tot) {\n            B* s = &root;\n            int c = i;\n            rep(j, N) {\n                s->push();\n                int k = c % 3; c /= 3;\n                s = s->p[k];\n            }\n            pos[s->idx] = i;\n        }\n        rep(i, tot) cout << pos[i] << ' ';\n        cout << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\nusing namespace std;\n\nint n, len, l[3*3*3*3*3*3*3*3*3*3*3*3], at[3*3*3*3*3*3*3*3*3*3*3*3];\nstring t;\n\nint calc(int a) {\n\tif (a < 3) {\n\t\treturn a % 3 - 1 + (a + 1) % 3;\n\t}\n\telse {\n\t\treturn a % 3 - 1 + (a + 1) % 3 + 3 * calc(a / 3);\n\t}\n}\n\nint main()\n{\n\tcin >> n;\n\tcin >> t;\n\tn = pow(3, n);\n\tfor (int i = 0; i < n; i++) {\n\t\tl[i] = i;\n\t\tat[i] = calc(i);\n\t}\n\tfor (int i = 0; i < t.size(); i++) {\n\t\tif (t[i] == 'S') {\n\t\t\tif (t[i + 1] == 'S') {\n\t\t\t\tt[i] = '0';\n\t\t\t\tt[i + 1] = '0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < t.size(); i++) {\n\t\tif (t[i] == 'S') {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tl[j] = at[l[j]];\n\t\t\t}\n\t\t}\n\t\telse if(t[i] == 'R'){\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tl[j] = (l[j] + 1) % n;\n\t\t\t}\n\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << l[i] << \" \";\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,count=0,p,x,TRI,pw3[13]={1},abc[531441][13]={0};\nchar c,tmp,T[200001],del[200001];\nvoid build(void){rep(i,3*TRI){x=i;rep(j,N){abc[i][j]=x%3;x/=3;}}}\nvoid change(char c[])\n{\n  if(c[p]==EOF)return;\n  if(c[p]=='R')\n  {\n    rep(i,3*TRI)abc[i][0]++;\n    rep(i,3*TRI)\n    {\n      rep(j,N){if(abc[i][j]==3){abc[i][j+1]++;abc[i][j]=0;}}\n      if(abc[i][N]==1){rep(j,N+1)abc[i][j]=0;}\n    }\n  }\n  else\n  {\n    rep(i,3*TRI)rep(j,N)\n    {\n      if(abc[i][j]==1)abc[i][j]=2;\n      else if(abc[i][j]==2)abc[i][j]=1;\n      else abc[i][j]=0;\n    }\n  }\n}\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nsigned main(void)\n{\n  count=scanf(\"%d %s\",&N,T);\n  rep(i,N+1)if(i>0)pw3[i]=pw3[i-1]*3;\n  rep(i,pw3[N])del[i]='R';\n  replace(T,\"SS\",\"\");replace(T,del,\"\");\n  if(T[0]=='\\n')return 0;\n  TRI=pw3[N-1];build();\n  count=strlen(T);\n  rep(i,count){p=i,change(T);}\n  rep(i,3*TRI)\n  {\n    x=0;\n    rep(j,N+1)\n    {\n      x+=abc[i][j]*pw3[j];\n      if(x>=3*TRI)x%=3*TRI;\n      if(j==N)printf(\"%d%c\",x,i+1==3*TRI?'\\n':' ');\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint N;\nstruct Tree{\n\tint num;\n\tint ch[3];\n\tbool rev;\n}T[4000010];int tot=1;\nvoid S(int x)\n{\n\tT[x].rev^=1;\n\tswap(T[x].ch[1],T[x].ch[2]);\n\treturn ;\n}\nvoid pushdown(int x)\n{\n\tif(!T[x].rev)return ;\n\tif(T[x].ch[0])S(T[x].ch[0]);\n\tif(T[x].ch[1])S(T[x].ch[1]);\n\tif(T[x].ch[2])S(T[x].ch[2]);\n\tT[x].rev=0;return ;\n}\nvoid R(int x)\n{\n\tpushdown(x);\n\tint y=T[x].ch[2];\n\tT[x].ch[2]=T[x].ch[1];\n\tT[x].ch[1]=T[x].ch[0];\n\tT[x].ch[0]=y;\n\tif(y)R(y);\n\treturn ;\n}\nvoid insert(int x)\n{\n\tint now=x,o=1;\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tint t=now%3;\n\t\tif(!T[o].ch[t])T[o].ch[t]=++tot;\n\t\to=T[o].ch[t];\n\t\tnow/=3;\n\t}\n\tT[o].num=x;\n\treturn ;\n}\nint getval(int x,int y)\n{\n\tpushdown(x);\n\tint t=y%3;\n\tif(!T[x].ch[t])return T[x].num;\n\treturn getval(T[x].ch[t],y/3);\n}\nchar str[200010];\nint ans[1000010];\nint main()\n{\n\tscanf(\"%d\",&N);\n\tscanf(\"%s\",str+1);\n\tint len=strlen(str+1);\n\tint m=1;\n\tfor(int i=1;i<=N;i++)m*=3;\n\tfor(int i=0;i<m;i++)insert(i);\n\tfor(int i=1;i<=len;i++)\n\t{\n\t\tif(str[i]=='S')S(1);\n\t\telse R(1);\n\t}\n\tfor(int i=0;i<m;i++)ans[getval(1,i)]=i;\n\tfor(int i=0;i<m;i++)printf(\"%d \",ans[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "        #include <bits/stdc++.h>\n        using namespace std;\n   #define int long long\nconst int MAX = 510000;\nconst int MOD = 1000000007;\n\n     signed main(){\n int n;\n string t;\n cin>>n>>t;\n int al2[t.size()]={};\n set<int> x[3];int y[3];\n int k=3;\n int kk=1;for(int i=0;i<n;i++)kk*=3;\n int ans[kk]={};\n\n for(int i=0;i<n;i++){\n      x[0].clear();\n      x[1].clear();\n      x[2].clear();\n   for(int j=0;j<k;j++)x[j/(k/3)].insert(j);\n   y[0]=0;y[1]=1;y[2]=2;\n   for(int j=0;j<t.size();j++){\n        if(t[j]=='S'){swap(y[1],y[2]);continue;}\n        int h[3];\n        for(int q=0;q<3;q++){\n             for(int p=0;p<3;p++){\n                  auto it=x[y[q]].find(al2[j]+p*k/3);\n                  if(it!=x[y[q]].end()){\n                       h[q]=al2[j]+p*k/3;\n                       x[y[q]].erase(it);\n                       break;\n                       \n\n                  }\n             }\n        }\n        for(int q=0;q<3;q++)x[y[(q+1)%3]].insert(h[q]);\n        al2[j]=h[2];\n   }\n   k*=3;\nif(true)continue;\n   for(int j=0;j<kk;j++){\n        for(int q=0;q<3;q++){\n          auto it=x[y[q]].find(j%k);\n          if(it!=x[y[q]].end())ans[j]+=q*(k/3);\n        }\n   }\n   k*=3;\n\n }\n for(int i=0;i<kk;i++)cout<<ans[i]<<' ';\n\n\n\n\n\n\n    }\n\n\n\n\n\n      \n\n        \n"
  },
  {
    "language": "C++",
    "code": "/*input\n3\nSRSRRSRRRSRRRR\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define eb emplace_back\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (int)(lower_bound(c.begin(),c.end(),x)-c.begin())\n#define EL cout<<'\\n'\n#define BS(a,x) binary_search(ALL(a),x)\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\ntemplate<typename T>\nostream& operator<<(ostream& out,vector<T> V){\n\tREP(i,SZ(V)) out<<V[i]<<((i!=SZ(V)-1)?\" \":\"\");\n\treturn out;\n}\n//}}}\nconst ll maxn=300005;\nconst ll maxlg=20;\nconst ll INF64=1e18;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=ll(1e9+7);\nconst ld PI=acos(-1);\nconst ld eps=1e-9;\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nconst int N = 531441;\n\nint n;\nstring s;\nvector<int> a;\n\nstring op[13][N+5];\n\nint res[13][N+5];\n\nint main(){\n\tIOS;\n\tcin>>n>>s;\n\tstring tmp;\n\tREP(i,SZ(s)){\n\t\tif(s[i]=='R') tmp.pb(s[i]);\n\t\telse{\n\t\t\tif(SZ(tmp)&&tmp.back()=='S') tmp.pop_back();\n\t\t\telse tmp.pb(s[i]);\n\t\t}\n\t}\n\n\top[0][0] = tmp;\n\tres[0][0] = 0;\n\n\tint mx = 1;\n\tfor(int len = 1; len <= n; len++){\n\t\tfor(int i=0;i<3;i++) for(int j=0;j<mx;j++){\n\t\t\tint msb = i;\n\t\t\top[len][i*mx+j].clear();\n\t\t\tfor(char ch:op[len-1][j]){\n\t\t\t\tif(ch=='S'){\n\t\t\t\t\tif(msb) msb = 3-msb;\n\t\t\t\t\tif(SZ(op[len][i*mx+j])&&op[len][i*mx+j].back()=='S'){\n\t\t\t\t\t\top[len][i*mx+j].pop_back();\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\top[len][i*mx+j].pb('S');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmsb++;\n\t\t\t\t\tif(msb == 3){\n\t\t\t\t\t\tmsb = 0;\n\t\t\t\t\t\top[len][i*mx+j].pb('R');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres[len][i*mx+j] = msb*mx+res[len-1][j];\n\t\t}\n\t\tmx*=3;\n\t}\n\tREP(i,mx){\n\t\tcout<<res[n][i]<<\" \\n\"[i==mx-1];\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n \nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n\n#define MOD 1000000007LL\n\nint N;\nstring T;\nvector<int> p;\n//map<int, int> sa;\nvector<int> sa;\nint tn;\n\nint tri(int n) {\n  int ans=1;\n  for (int i=0; i<n; i++) ans *= 3;\n  return ans;\n}\n\nvoid salsa();\nvoid rumba();\nvoid print_ln();\n\nint main()\n{\n  int l;\n  int i;\n\n  cin >> N >> T;\n  tn = tri(N);\n\n  p.resize(tn);\n  sa.resize(tn);\n  for (int i=0; i<tn; i++) {\n    p[i] = i;\n  }\n  sa[0] = 0; sa[1] = 2; sa[2]=1;\n  {\n    int t=3;\n    int cv;\n    for (int i=3; i<tn; i++) {\n      if (i>=t*3) t *= 3;\n      cv = sa[i%t];\n      switch(i/t) {\n      case 1: cv += t*2; break;\n      case 2: cv += t; break;\n      }\n      sa[i] = cv;\n    }\n  }\n\n//for (int i=0; i<tn; i++) printf(\"sa[%d]=%d\\n\", i, sa[i]);\n\n//print_ln();\n\n  l = T.size();\n  for (i=0; i<l; i++) {\n    if (T[i] == 'S') {\n      if (T[i+1] == 'S') {\n        i++;\n        continue;\n      }\n      salsa();\n//printf(\"S \");\n//print_ln();\n    } else {\n      rumba();\n//printf(\"R \");\n//print_ln();\n    }\n  }\n\n  print_ln();\n\n  return 0;\n}\n\nvoid salsa() {\n  int i;\n\n  for (i=0; i<tn; i++) {\n    p[i] = sa[p[i]];\n  }\n}\nvoid rumba() {\n  int i;\n  for (i=0; i<tn; i++) {\n    p[i]++;\n    p[i]%=tn;\n  }\n}\n\nvoid print_ln() {\n  int i;\n  printf(\"%d\", p[0]);\n  for (i=1; i<tn; i++) printf(\" %d\", p[i]);\n  printf(\"\\n\");\n}\n/*\n  a*3^3+b*3^2+c*3+d\n  */\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=1800005;\nint n,rt,cnt,ind,pw[N],ch[N][3],tg[N],val[N],ans[N];char s[N];\nvoid bud(int&k1,int k2,int k3){\n\tk1=++cnt;\n\tif(k2==n){val[k1]=k3;return;}\n\trep(i,0,2)bud(ch[k1][i],k2+1,k3+pw[k2]*i);\n}\nvoid pst(int k1){\n\tif(!ch[k1][0])return;\n\tswap(ch[k1][1],ch[k1][2]);\n\ttg[k1]^=1;\n}\nvoid psd(int k1){\n\tif(!ch[k1][0])return;\n\tif(tg[k1]){\n\t\tpst(ch[k1][0]);\n\t\tpst(ch[k1][1]);\n\t\tpst(ch[k1][2]);\n\t\ttg[k1]^=1;\n\t}\n}\nvoid go(int k1){\n\tif(!ch[k1][0])return;\n\tpsd(k1);\n\tint t=ch[k1][2];ch[k1][2]=ch[k1][1],ch[k1][1]=ch[k1][0],ch[k1][0]=t;\n\tgo(ch[k1][0]);\n}\nvoid dfs(int k1,int k2,int k3){\n\tif(k2==n){ans[val[k1]]=k3;return;}\n\tpsd(k1);\n\trep(i,0,2)dfs(ch[k1][i],k2+1,k3+pw[k2]*i);\n}\nint main(){\n\tscanf(\"%d%s\",&n,s);\n\tpw[0]=1;rep(i,1,n)pw[i]=pw[i-1]*3;\n\tbud(rt,0,0);\n\tfor(int i=0;s[i];++i){\n\t\tif(s[i]=='S')pst(rt);\n\t\telse go(rt);\n\t}\n\tdfs(rt,0,0);\n\trep(i,0,pw[n]-1)printf(\"%d \",ans[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 200222, inf = 1000111222;\nconst int max_tot = 729 * 729;\nconst int max_half = 729;\nconst int max_big = max_tot / max_half;\n\nchar buf[max_n];\n\nstring read() {\n    scanf(\"%s\", buf);\n    return buf;\n}\n\nint n, nxt[max_n][max_half];\nint prec[max_half], ans[max_tot], res[max_big];\nint sum[max_n];\nint pw;\n\nint get_sum(int l, int r) {\n    if (!l) {\n        return sum[r];\n    }\n    return sum[r] - sum[l - 1];\n}\n\nvoid get_all_prec() {\n    pw = 1;\n    for (int i = 0; i < n; ++i) {\n        pw *= 3;\n    }\n    for (int x = 0; x < pw; ++x) {\n        vector<int> v;\n        int cur = x;\n        for (int i = 0; i < n; ++i) {\n            v.push_back(cur % 3);\n            cur /= 3;\n        }\n        reverse(v.begin(), v.end());\n        int to = 0;\n        for (int i = 0; i < n; ++i) {\n            int x = (v[i] * 2) % 3;\n            to = to * 3 + x;\n        }\n        prec[x] = to;\n    }\n}\n\nconst bool debug = 0;\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    string s;\n    if (debug) {\n        mt19937 gen;\n        n = 12;\n        for (int i = 0; i < 200000; ++i) {\n            s += \"SR\"[gen() % 2];\n        }\n    } else {\n        scanf(\"%d\", &n);\n        s = read();\n    }\n    get_all_prec();\n    const int half = min(max_half, pw);\n    for (int x = 0; x < half; ++x) {\n        nxt[s.length()][x] = -1 - x;\n    }\n    for (int i = 0; i < s.length(); ++i) {\n        sum[i] = s[i] == 'S';\n        if (i) {\n            sum[i] += sum[i - 1];\n        }\n    }\n    int tot = 0;\n    for (int i = s.length() - 1; i >= 0; --i) {\n        for (int x = 0; x < half; ++x) {\n            int to = prec[x];\n            if (s[i] == 'R') {\n                to = x + 1;\n            }\n            if (to == half) {\n                nxt[i][x] = i;\n            } else {\n                nxt[i][x] = nxt[i + 1][to];\n            }\n            tot += nxt[i][x];\n            //cout << nxt[i][x] << \" \";\n        }\n        //cout << endl;\n    }\n    int mx = pw / half;\n    for (int ismall = 0; ismall < half; ++ismall) {\n        for (int big = 0; big < mx; ++big) {\n            res[big] = big;\n        }\n        int small = ismall;\n        int pos = 0;\n        while (pos < s.length()) {\n            //cout << pos << \": \" << big << \" \" << small << endl;\n            if (nxt[pos][small] < 0) {\n                small = -1 - nxt[pos][small];\n                if (get_sum(pos, s.length() - 1) % 2) {\n                    for (int big = 0; big < mx; ++big) {\n                        res[big] = prec[res[big]];\n                    }\n                }\n                pos = s.length();\n            } else {\n                int to = nxt[pos][small];\n                if (get_sum(pos, to) % 2) {\n                    for (int big = 0; big < mx; ++big) {\n                        res[big] = prec[res[big]] + 1;\n                        if (res[big] == mx) {\n                            res[big] = 0;\n                        }\n                    }\n                }\n                small = 0;\n                pos = to + 1;\n            }\n        }\n        for (int big = 0; big < mx; ++big) {\n            ans[big * half + ismall] = res[big] * half + small;\n        }\n    }\n    for (int i = 0; i < pw; ++i) {\n        printf(\"%d \", ans[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nclass CStrangeDance {\npublic:\n    int calc(vector<vector<vector<int>>>& v, int k) {\n      int w = 0;\n      if (k > 0) {\n        w = calc(v, k-1);\n      }\n      auto ret = v[2][k][w];\n\n      auto w0 = v[0][k][w];\n      auto w1 = v[1][k][w];\n      auto w2 = v[2][k][w];\n\n      v[1][k][w] = w0;\n      v[2][k][w] = w1;\n      v[0][k][w] = w2;\n      return ret;\n    }\n\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n;\n      cin >> n;\n      string t;\n      cin >> t;\n\n      // initialize vector size\n      vector<vector<vector<int>>> v(3, vector<vector<int>>(n));\n      int k = 1;\n      rep(i, n) {\n        rep(j, 3) {\n          v[j][i].resize(k);\n        }\n        k *= 3;\n      }\n      int K = k;\n\n      // initialize vector\n      rep(i, n) {\n        int idx = 0;\n        rep(j, 3) {\n          for(auto& e: v[j][i]) {\n            e = idx;\n            idx++;\n          }\n        }\n      }\n\n      for(auto c: t) {\n        if (c=='S') {\n          // swap vector\n          swap(v[1], v[2]);\n        } else {\n          // swap by point recursively\n          calc(v, n-1);\n        }\n      }\n\n      // recover\n      vector<int> ans(K);\n      k = 1;\n      rep(i, n) {\n        for(int j=1; j<=2; j++) {\n          for(auto e: v[j][i]) {\n            for(int idx=e; idx<K; idx+=(k*3)) {\n              ans[idx] += j*k;\n            }\n          }\n        }\n        k *= 3;\n      }\n\n      for(auto e: ans) {\n        cout << e << ' ';\n      }\n      cout << endl;\n\n    }\n};\n\nsigned main() {\n  CStrangeDance solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nstring reduce (const string &s)\n{\n\tstring ans;\n\tfor (char ch : s)\n\t{\n\t\tif (ans.empty() || ans.back() != ch || ch != 'S')\n\t\t\tans += ch;\n\t\telse\n\t\t\tans.pop_back();\n\t}\n\treturn ans;\n}\n\nvector<int> work (const int n, const string &s)\n{\n\tvector<int> who_moves(3);\n\tvector<string> carry(3);\n\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tint cur = i;\n\t\tfor (const char ch : s)\n\t\t{\n\t\t\tif (ch == 'S')\n\t\t\t{\n\t\t\t\tcarry[i] += ch;\n\t\t\t\tif (cur != 0)\n\t\t\t\t\tcur = 3 - cur;\n\t\t\t}\n\n\t\t\tif (ch == 'R')\n\t\t\t{\n\t\t\t\tcur++;\n\t\t\t\tif (cur == 3)\n\t\t\t\t{\n\t\t\t\t\tcarry[i] += ch;\n\t\t\t\t\tcur = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twho_moves[i] = cur;\n\t}\n\n\tif (n == 1)\n\t\treturn who_moves;\n\n\tfor (int i = 0; i < 3; i++)\n\t\tcarry[i] = reduce(carry[i]);\n\n\tvector<vector<int>> old_anses(3);\n\tfor (int i = 0; i < 3; i++)\n\t\told_anses[i] = work(n - 1, carry[i]);\n\tfor (int i = 0; i < 3; i++)\n\t\tassert(old_anses[i].size() == old_anses[0].size());\n\n\tvector<int> ans(3 * old_anses[0].size());\n\tfor (int i = 0; i < 3; i++)\n\t\tfor (int j = 0; j < int(old_anses[i].size()); j++)\n\t\t\tans[3 * j + i] = 3 * old_anses[i][j] + who_moves[i];\n\n\treturn ans;\n}\n\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tint n;\n\n\twhile (cin >> n)\n\t{\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (const char ch : s)\n\t\t\tassert(ch == 'S' || ch == 'R');\n\n\t\tauto ans = work(n, s);\n\t\tfor (int i = 0; i < int(ans.size()); i++)\n\t\t\tcout << ans[i] << \" \\n\"[i + 1 == int(ans.size())];\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n#ifdef LOCAL\n\tauto st = clock();\n\tifstream fin(\"../input.txt\");\n\tsolve(fin);\n\n\tcout << \"clock: \" << (clock() - st) / (double) CLOCKS_PER_SEC << endl;\n#else\n\tsolve();\n#endif\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string>\n#include<cmath>\n\nusing namespace std;\n\nint sch(int n){     \n    int out=0,tmp,count=0;\n    while(n != 0){\n        tmp = n % 3;\n        if(tmp==1){\n            out += 2*pow(3,count);\n        }else if(tmp==2){\n            out += pow(3,count);\n        }\n        count++;\n        n /= 3;\n    }\n    return out;\n}\n\nint main(){\n    int N,p,*table,size,len;\n    string T;\n    cin >> N;\n    cin >> T;\n    size = int(pow(3,N));\n    table = new int[size];\n    len = T.length();\n    for(int i=0;i<size;i++){\n        if(i % 3 == 0){\n            table[i] = sch(i);\n        }else if(i % 3 == 1){\n            table[i] = table[i-1] + 2;\n        }else{\n            table[i] = table[i-1] - 1;\n        }\n    }\n    //for(int i=0;i<size;i++) cout << i << ' ' <<table[i] << endl;;\n\n    for(int i=0;i<size;i++){\n        p=i;\n        for(int j=0;j<len;j++){\n            if(T[j] == 'S'){\n                if(T[j+1] == 'S') j++;\n                else p = table[p];\n            }else{\n                p++;\n                if(p==size) p=0;\n            }\n        }\n        cout << p << ' ';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//cout << fixed << setprecision(17) << res << endl;\n \nstruct Tree {\n    int value;\n    struct Tree * l;\n    struct Tree * m;\n    struct Tree * r;\n\n    Tree(int _value) : value(_value), l(NULL), m(NULL), r(NULL) {};\n};\n\nvector<int> pow3s(13, 0);\n\nint pow3(int n) {\n    if (pow3s[n] == 0) {\n        pow3s[0] = 1;\n        for (int i = 1; i <= 12; ++i) {\n            pow3s[i] = 3 * pow3s[i-1];\n        }\n    }\n    return pow3s[n];\n}\n\nstruct Tree * constructTree(int n, int offset) {\n    if (n == 0) {\n        return new Tree(offset);\n    }\n    auto cur = new Tree(offset);\n\n    cur->l = constructTree(n-1, offset);\n    cur->m = constructTree(n-1, offset + pow3(n-1));\n    cur->r = constructTree(n-1, offset + pow3(n-1) * 2);\n    return cur;\n}\n\nvoid placeTree(Tree * t, vector<int> & lst) {\n    if (t->l == NULL) {\n        lst.push_back(t->value);\n        return;\n    }\n    placeTree(t->l, lst);\n    placeTree(t->m, lst);\n    placeTree(t->r, lst);\n}\n\nvoid rotate(Tree * t) {\n    if (t->l == NULL) return;\n\n    rotate(t->l);\n    rotate(t->m);\n    rotate(t->r);\n\n    auto tmp = t->m;\n    t->m = t->r;\n    t->r = tmp;\n}\n\nint shift(Tree * t, int v) {\n    if (t->l == NULL) {\n        auto tmp = t->value;\n        t->value = v;\n        return tmp;\n    }\n\n    int u;\n    u = shift(t->l, v);\n    u = shift(t->m, u);\n    u = shift(t->r, u);\n    return u;\n}\n\nvoid put(Tree * t, int v) {\n    if (t->l == NULL) {\n        t->value = v;\n        return;\n    } else {\n        put(t->l, v);\n    }\n}\n\nvoid printTree(Tree * t) {\n    if (t->l == NULL) {\n        cerr << t->value << \" \";\n    } else {\n        printTree(t->l);\n        printTree(t->m);\n        printTree(t->r);\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    Tree * t = constructTree(n, 0);\n    string s;\n    cin >> s;\n    //printTree(t); cerr << endl;\n    for (auto c : s) {\n        if (c == 'S') {\n            rotate(t);\n        } else {\n            int v = shift(t, 0);\n            put(t, v);\n        }\n        //printTree(t); cerr << endl;\n    }\n    //printTree(t); cerr << endl;\n    vector<int> v;\n    placeTree(t, v);\n    vector<int> u(pow3(n));\n    for (ll i = 0; i < pow3(n); ++i) {\n        u[v[i]] = i;\n    }\n    for (auto & p: u) {\n        cout << p << \" \";\n    }\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nclass CStrangeDance {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n; cin >> n;\n      string t; cin >> t;\n\n      // initialize vector size\n      vector<vector<vector<int>>> v(3, vector<vector<int>>(n));\n      int k = 1;\n      rep(i, n) {\n        rep(j, 3) {\n          v[j][i].resize(k);\n        }\n        k *= 3;\n      }\n      int K = k;\n\n      // initialize vector\n      rep(i, n) {\n        int idx = 0;\n        rep(j, 3) {\n          for(auto& e: v[j][i]) {\n            e = idx;\n            idx++;\n          }\n        }\n      }\n\n      for(auto c: t) {\n        if (c=='S') {\n          // swap vector\n          swap(v[1], v[2]);\n        } else {\n          // swap by point\n          int w = 0;\n          rep(i, n) {\n            auto v0 = v[0][i][w];\n            auto v1 = v[1][i][w];\n            auto v2 = v[2][i][w];\n            v[1][i][w] = v0;\n            v[2][i][w] = v1;\n            v[0][i][w] = v2;\n            w = v2;\n          }\n        }\n      }\n\n      // recover\n      vector<int> ans(K);\n      k = 1;\n      rep(i, n) {\n        for(int j=1; j<=2; j++) {\n          for(auto e: v[j][i]) {\n            for(int idx=e; idx<K; idx+=(k*3)) {\n              ans[idx] += j*k;\n            }\n          }\n        }\n        k *= 3;\n      }\n\n      for(auto e: ans) {\n        cout << e << ' ';\n      }\n    }\n};\n\nsigned main() {\n  CStrangeDance solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <string>\n#include <algorithm>\n#include <utility>\n#define inf 1e18\n#define rep(x, s, t) for(int (x) = (s); (x) < (t); (x)++)\n#define Rep(x, s, t) for(int (x) = (s); (x) <= (t); (x)++)\n#define chmin(x, y) (x) = min((x), (y))\n#define chmax(x, y) (x) = max((x), (y))\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n;\nstring s;\nint beki[15];\nint carry[200005];\nint dest[600005], ndest[600005];\nbitset<600005> bs[3];\nint pt[3];\n\nint main(void)\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n;\n\tcin >> s;\n\t\n\tbeki[0] = 1;\n\tfor(int i = 1; i < 15; i++) beki[i] = beki[i-1] * 3;\n\t\n\tfor(int i = 0; i < 3; i++){\n\t\tint p = i;\n\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\tif(s[j] == 'R'){\n\t\t\t\tif(p == 2) carry[j] = i;\n\t\t\t\tp = (p+1) % 3;\n\t\t\t}\n\t\t\telse p = (3-p)%3;\n\t\t}\n\t\tdest[i] = p;\n\t}\n\t\n\tfor(int i = 1; i < n; i++){\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tfor(int k = 0; k < beki[i+1]; k++) bs[j][k] = false;\n\t\t\tfor(int k = 0; k < beki[i]; k++) bs[j][j*beki[i]+k] = true;\n\t\t}\n\t\tfor(int j = 0; j < 3; j++) pt[j] = j;\n\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\tif(s[j] == 'S') swap(pt[1], pt[2]);\n\t\t\telse{\n\t\t\t\tint tmp[3];\n\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\tfor(int l = 0; l < 3; l++){\n\t\t\t\t\t\tint x = l*beki[i]+carry[j];\n\t\t\t\t\t\tif(bs[pt[k]][x]){\n\t\t\t\t\t\t\ttmp[k] = x;\n\t\t\t\t\t\t\tif(k == 2) carry[j] = x;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\tbs[pt[k]][tmp[k]] = false;\n\t\t\t\t\tbs[pt[(k+1)%3]][tmp[k]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tfor(int k = 0; k < beki[i+1]; k++){\n\t\t\t\tif(bs[pt[j]][k]) ndest[k] = dest[k%beki[i]] + j*beki[i];\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < beki[i+1]; j++) dest[j] = ndest[j];\n\t}\n\t\n\tfor(int i = 0; i < beki[n]; i++) cout << dest[i] << \" \"; cout << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 14;\nstring s; int n,pw[N];vector<char> w; vector<vector<char> > f,g; vector<int> h,p;\ninline int get(int x,int l){ return x % pw[l]; }\ninline void add(vector<char> &s,char c) {\n\tif (c == 'R') s.push_back(c);\n\telse if (s.size() && s[s.size()-1] == 'S') s.pop_back();\n\telse s.push_back(c);\n}\nint main(){\n\tint i;\n\tcin >> n >> s;\n\tfor (pw[0] = i = 1; i <= 12 ; ++i) pw[i] = pw[i-1]*3;\n\tfor (i = 0; i < s.size(); ++i) w.push_back(s[i]);\n\tf.push_back(w),h.push_back(0);\n    for (i = 1; i <= n; ++i){\n\t\tg.resize(pw[i]),p.resize(pw[i]);\n        for(int now = 0; now < pw[i] ; ++now) {\n\t\t\tint cur = get(now,i-1);\n\t\t\tp[now] = h[cur];\n\t\t\tint d = now/pw[i-1]%3;\n\t\t\tfor (auto v : f[cur]){\n\t\t\t\tif(v == 'S') d = (d<<1)%3,add(g[now],v);\n\t\t\t\telse if(d == 2) d = 0,add(g[now],v);\n\t\t\t\telse d += 1;\n\t\t\t}\n\t\t\tp[now] += d*pw[i-1];\n\t\t}\n\t\th.clear(),f.clear(),swap(f,g),swap(h,p);\n\t}\n\tfor (i = 0; i < pw[n]; ++i) cout << h[i] << ((i<pw[n]-1) ? (' ') : ('\\n'));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,...) for(int i = (a)*(strlen(#__VA_ARGS__)!=0);i<(int)(strlen(#__VA_ARGS__)?__VA_ARGS__:(a));++i)\n#define per(i,a,...) for(int i = (strlen(#__VA_ARGS__)?__VA_ARGS__:(a))-1;i>=(int)(strlen(#__VA_ARGS__)?(a):0);--i)\n#define foreach(i, n) for(auto &i:(n))\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define all(x) (x).begin(), (x).end()\n#define bit(x) (1ll << (x))\nusing ll = long long;\n//const ll MOD = (ll)1e9+7;\nconst ll MOD = 998244353;\nconst int INF = (ll)1e9+7;\nconst ll INFLL = (ll)1e18;\nusing namespace std;\ntemplate<class t>\nusing vvector = vector<vector<t>>;\ntemplate<class t>\nusing vvvector = vector<vector<vector<t>>>;\ntemplate<class t>\nusing priority_queuer = priority_queue<t, vector<t>, greater<t>>;\ntemplate<class t, class u> bool chmax(t &a, u b){if(a<b){a=b;return true;}return false;}\ntemplate<class t, class u> bool chmin(t &a, u b){if(a>b){a=b;return true;}return false;}\n#ifdef DEBUG\n#define debug(x) cout<<\"LINE \"<<__LINE__<<\": \"<<#x<<\" = \"<<x<<endl;\n#else\n#define debug(x) (void)0\n#endif\n\nnamespace templates{\n  ll modpow(ll x, ll b){\n    ll res = 1;\n    while(b){\n      if(b&1)res = res * x % MOD;\n      x = x * x % MOD;\n      b>>=1;\n    }\n    return res;\n  }\n\n  ll modinv(ll x){\n    return modpow(x, MOD-2);\n  }\n\n  bool was_output = false;\n  template<class t>\n  void output(t a){\n    if(was_output)cout << \" \";\n    cout << a;\n    was_output = true;\n  }\n  void outendl(){\n    was_output = false;\n    cout << endl;\n  }\n  ll in(){\n    ll res;\n    scanf(\"%lld\", &res);\n    return res;\n  }\n\n  template<class t>\n  istream& operator>>(istream&is, vector<t>&x){\n    for(auto &i:x)is >> i;\n    return is;\n  }\n\n  template<class t, class u>\n  istream& operator>>(istream&is, pair<t, u>&x){\n    is >> x.first >> x.second;\n    return is;\n  }\n\n  template<class t>\n  void in(t&x){\n    cin >> x;\n  }\n\n  template<class t>\n  t in(){\n    t res; cin >> res; return res;\n  }\n\n  template<class t>\n  void out(t x){\n    cout << x;\n  }\n\n  template<class t>\n  vector<t> sorted(vector<t> line,function<bool(t,t)> comp=[](t a,t b){return a<b;}){\n    sort(line.begin(),line.end(),comp);\n    return line;\n  }\n\n  template<class t>\n  vector<t> reversed(vector<t> line){\n    reverse(line.begin(),line.end());\n    return line;\n  }\n}\n\nusing namespace templates;\n\nvector<int> inputs(){\n  string str = in<string>();\n  vector<int> res;\n  foreach(i,str){\n    if(i=='S'){\n      res.emplace_back(1);\n    }else{\n      res.emplace_back(0);\n    }\n  }\n  return res;\n}\n\nvector<ll> k_3;\n\nint turn(int x){\n  static vector<int> dp(400000,-1);\n  if(x==0)return 0;\n  int &it = dp[x];\n  if(it>=0)return it;\n  return it = turn(x/3)*3 + ((x%3==0)?0:(3-x%3));\n}\n\nint main(){\n  int n = in();\n  int n2 = n/2;\n  vector<int> line = inputs();\n  k_3.emplace_back(1);\n  rep(i,20){\n    k_3.emplace_back(k_3.back()*3);\n  }\n  vvector<int> moves(k_3[n2]);\n  vector<int> turn_sum(line.size()+1,0);\n  rep(i,line.size()){\n    turn_sum[i+1] = turn_sum[i] + line[i];\n  }\n\n  rep(i,k_3[n2]){\n    vector<int> &move = moves[i];\n    move.emplace_back(i);\n    int current = i;\n    foreach(j,line){\n      if(j){\n        current = current / k_3[n2] * k_3[n2] + turn(current%k_3[n2]) ;\n      }else{\n        ++current;\n      }\n      move.emplace_back(current);\n    }\n  }\n\n  vector<int> ans(k_3[n],-1);\n  rep(i,k_3[n]){\n    int current = i;\n    int index = current % k_3[n2];\n    int p = 0;\n    vector<int> &move = moves[index];\n    while(p<move.size()){\n      int np = lower_bound(all(move),(move[p]+k_3[n2])/k_3[n2]*k_3[n2])-move.begin();\n      if(np==move.size()){\n        if((turn_sum.back()-turn_sum[p])&1){\n          int upper = current / k_3[n2];\n          current = turn(upper) * k_3[n2] + current % k_3[n2];\n        }\n        current += move.back() - move[p];\n        current %= k_3[n];\n        break;\n      }\n      if((turn_sum[np]-turn_sum[p])&1){\n        int upper = current / k_3[n2];\n        current = turn(upper) * k_3[n2] + current % k_3[n2];\n      }\n      current = (current + k_3[n2]) / k_3[n2] * k_3[n2];\n      current %= k_3[n];\n      p = np;\n    }\n    ans[i] = current;\n  }\n\n  foreach(i,ans){\n    output(i);\n  }\n  outendl();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nstatic inline char CH()\n{\n  static char buf[100000],*ptr1=buf,*ptr2=buf;\n  return ptr1==ptr2&&(ptr2=(ptr1=buf)+fread(buf,1,100000,stdin),ptr1==ptr2)?EOF:*ptr1++;\n}\nstatic inline int IN(void)\n{\n  int x=0,f=0,c=CH();while(c<48||c>57){f^=c==45,c=CH();}\n  while(c>47&&c<58){x=x*10+c-48,c=CH();}return f?-x:x;\n}\nstatic inline int Pow(int a,int b){return b?Pow(a*a,b>>1)*(b&1?a:1):1;}\nint main()\n{\n  int N=IN(),now,len=0,pw3=Pow(3,N),x=Pow(3,N>>1),y=Pow(3,N-(N>>1)),A[1000001],B[600001];\n  char c=CH(),T[1000001],S[1000001];\n  rep(i,pw3)B[i]=B[i/3]*3+(3-i%3)%3;\n  while(c!=EOF){if(c==10){c=CH();}T[1+len++]=c,c=CH();}\n  fflush(stdin);\n  rep(i,x)\n  {\n    int temp=i;now=0;\n    rep(j,len)\n    {\n      if(T[j+1]=='S'){temp=B[temp];(S[now]=='S')?--now:S[++now]='S';}\n      else{++temp;if(temp==x)S[++now]='R',temp=0;}\n    }\n    rep(j,y)\n    {\n      int keep=j;\n      rep(k,now)\n      {\n        if(S[k+1]=='S')keep=B[keep];\n        else if(S[k+1]=='R')if((++keep)==y)keep=0;\n        A[i+j*x]=temp+keep*x;\n      }\n    }\n  }\n  rep(i,pw3)printf(\"%d%c\",A[i],i+1==pw3?'\\n':' ');\n  return fflush(stdout),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define MN 550000\n\nint w = 1, tot;\nint ch[MN * 12][3];\nint n, len, ans[MN];\nbool tag[MN * 12];\nchar t[MN];\n\nvoid ins(int x)\n{\n\tint now = w, X = x;\n\tfor(int i = 0; i < n - 1; i++)\n\t{\n\t\tif(!ch[now][x % 3]) ch[now][x % 3] = ++tot;\n\t\tnow = ch[now][x % 3];\n\t\tx /= 3;\n\t}\n\tch[now][x] = X;\n}\n\nvoid pushdown(int x)\n{\n\tif(tag[x])\n\t{\n\t\tstd::swap(ch[x][1], ch[x][2]);\n\t\ttag[ch[x][0]] ^= 1;\n\t\ttag[ch[x][1]] ^= 1;\n\t\ttag[ch[x][2]] ^= 1;\n\t\ttag[x] = 0;\n\t}\n}\n\nint get(int x)\n{\n\tint now = w;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tpushdown(now);\n\t\tnow = ch[now][x % 3];\n\t\tx /= 3;\n\t}\n\treturn now;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++) w *= 3; tot = w;\n\tscanf(\"%s\", t + 1); len = strlen(t + 1);\n\tfor(int i = 0; i < w; i++) ins(i);\n\tfor(int i = 1; i <= len; i++)\n\t{\n\t\tif(t[i] == 'S') tag[w] ^= 1;\n\t\telse\n\t\t{\n\t\t\tint now = w;\n\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tpushdown(now);\n\t\t\t\tint x = ch[now][0], y = ch[now][1], z = ch[now][2];\n\t\t\t\tch[now][0] = z; ch[now][1] = x; ch[now][2] = y;\n\t\t\t\tnow = ch[now][0];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < w; i++) ans[get(i)] = i;\n\tfor(int i = 0; i < w; i++) printf(\"%d \", ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=6908733,M=200000;\n\nint n,m,cq;\nchar s[M+9];\n\nvoid into(){\n  scanf(\"%d%s\",&n,s+1);\n  cq=strlen(s+1);\n}\n\nstruct tree{\n  int s[3],id,rev;\n}tr[N+9];\nint cn;\n\nvoid Build(){tr[cn=1].id=-1;}\n\nvoid Update_rev(int k){swap(tr[k].s[1],tr[k].s[2]);tr[k].rev^=1;}\n\nvoid Pushdown(int k){\n  if (!tr[k].rev) return;\n  for (int i=0;i<3;++i) Update_rev(tr[k].s[i]);\n  tr[k].rev=0;\n}\n\nvoid Insert(int x){\n  int k=1;\n  for (int i=0,now=x;i<n;++i,now/=3){\n\tint &t=tr[k].s[now%3];\n\ttr[k=t=t?t:++cn].id=-1;\n  }\n  tr[k].id=x;\n}\n\nvoid Change_add(int k){\n  if (tr[k].id>=0) return;\n  int t=tr[k].s[2];\n  Pushdown(k);\n  for (int i=2;i>=1;--i) tr[k].s[i]=tr[k].s[i-1];\n  Change_add(tr[k].s[0]=t);\n}\n\nint ans[N+9];\n\nvoid Dfs_ans(int k,int v,int pw){\n  if (tr[k].id>=0) {ans[tr[k].id]=v;return;}\n  Pushdown(k);\n  for (int i=0;i<3;++i) Dfs_ans(tr[k].s[i],v+i*pw,pw*3);\n}\n\nvoid Get_ans(){\n  m=1;\n  for (int i=1;i<=n;++i) m*=3;\n  Build();\n  for (int i=0;i<m;++i) Insert(i);\n  for (int i=1;i<=cq;++i) s[i]=='S'?Update_rev(1):Change_add(1);\n  Dfs_ans(1,0,1);\n}\n\nvoid work(){\n  Get_ans();\n}\n\nvoid outo(){\n  for (int i=0;i<m;++i)\n\tprintf(\"%d \",ans[i]);\n  puts(\"\");\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n    #define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define pb push_back\n//#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int MXSZ = 300;\n\nstruct tchange\n{\n\tstring from, to;\n\tint flip;\n};\n\nconst int maxn = 1000006;\n\nvector<tchange> mp, newmp;\nstring curup[maxn];\npair<string, int> curdown[maxn];\nchar s[maxn];\nint n, nn;\n\npair<string, int> add1(string ss)\n{\n\tbool all2 = true;\n\tfor (int j = (int)ss.length() - 1; j >= 0; j--)\n\t{\n\t\tif (ss[j] != '2')\n\t\t{\n\t\t\tss[j]++;\n\t\t\tall2 = false;\n\t\t\tbreak;\n\t\t} else\n\t\t{\n\t\t\tss[j] = '0';\n\t\t}\n\t}\n\treturn {ss, all2};\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\t//n = 12;\n\tnn = 1;\n\tfor (int i = 0; i < n; i++) nn *= 3;\n\tscanf(\"%s\", s);\n\tint len = strlen(s);\n\t//int len = 200000;\n\t//for (int i = 0; i < len; i++) s[i] = 'R'; //(((int)rng() % 2) ? 'S' : 'R');\n\tint nhalf = (n + 1) / 2;\n\tint nnhalf = 1;\n\tfor (int i = 0; i < nhalf; i++) nnhalf *= 3;\n\tstring cur = string(nhalf, '0');\n\tfor (int it = 0; it < nnhalf; it++)\n\t{\n\t\tcurdown[it] = {cur, 0};\n\t\tcur = add1(cur).fi;\n\t}\n\tcur = string(n, '0');\n\tfor (int it = 0; it < nn; it++)\n\t{\n\t\tcurup[it] = cur.substr(0, n - nhalf);\n\t\tcur = add1(cur).fi;\n\t}\n\tfor (int it = 0; it < len; it++)\n\t{\n\t\t//cout << \"before \" << it << endl;\n\t\t//for (auto t : mp) cout << t.from << ' ' << t.to << ' ' << t.flip << endl;\n\t\t//cout << it << ' ' << mp.size() << endl;\n\t\tchar op = s[it];\n\t\tif (op == 'S')\n\t\t{\n\t\t\tfor (int i = 0; i < nnhalf; i++)\n\t\t\t{\n\t\t\t\tfor (auto &c : curdown[i].fi) if (c != '0') c = '1' + '2' - c;\n\t\t\t\tcurdown[i].se ^= 1;\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\tfor (int i = 0; i < nnhalf; i++)\n\t\t\t{\n\t\t\t\tauto newv = add1(curdown[i].fi);\n\t\t\t\tif (newv.se) // overflow\n\t\t\t\t{\n\t\t\t\t\tfor (int j = i; j < nn; j += nnhalf)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (curdown[i].se)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (auto &c : curup[j]) if (c != '0') c = '1' + '2' - c;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurup[j] = add1(curup[j]).fi;\n\t\t\t\t\t}\n\t\t\t\t\tcurdown[i] = {newv.fi, 0};\n\t\t\t\t} else curdown[i].fi = newv.fi;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < nn; i++)\n\t{\n\t\tif (curdown[i % nnhalf].se)\n\t\t{\n\t\t\tfor (auto &c : curup[i]) if (c != '0') c = '1' + '2' - c;\n\t\t}\n\t\tint v = 0;\n\t\tfor (auto c : curup[i]) v = v * 3 + c - '0';\n\t\tfor (auto c : curdown[i % nnhalf].fi) v = v * 3 + c - '0';\n\t\tprintf(\"%d \", v);\n\t}\n\tprintf(\"\\n\");\n\t//for (int i = 0; i < nn; i++) printf(\"%s%s \", curup[i].c_str(), curdown[i % nnhalf].fi.c_str());\n\t//printf(\"\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\nclass Radix {\nprivate:\n    const char* s;\n    int a[128];\npublic:\n    Radix(const char* s = \"0123456789ABCDEF\") : s(s) {\n        int i;\n        for (i = 0; s[i]; ++i)\n            a[(int)s[i]] = i;\n    }\n    std::string to(long long p, int q) {\n        int i;\n        if (!p)\n            return \"0\";\n        char t[64] = { };\n        for (i = 62; p; --i) {\n            t[i] = s[p % q];\n            p /= q;\n        }\n        return std::string(t + i + 1);\n    }\n    std::string to(const std::string& t, int p, int q) {\n        return to(to(t, p), q);\n    }\n    long long to(const std::string& t, int p) {\n        int i;\n        long long sm = a[(int)t[0]];\n        for (i = 1; i < (int)t.length(); ++i)\n            sm = sm * p + a[(int)t[i]];\n        return sm;\n    }\n};\n\nbool vector_has(vector<int> vec, int num) {\n    auto itr = std::find(vec.begin(), vec.end(), num);\n    size_t index = std::distance(vec.begin(), itr);\n    if (index != vec.size()) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\nint main() {\n    Radix r;\n    int N, temp;\n    string T;\n    int T_length;\n    cin >> temp;\n    N = (int)pow(3, temp);\n    cin >> T;\n    T_length = (int)T.length();\n    int* list = new int[N];\n    string temp_str;\n\n    // initialize\n    for (int i = 0; i < N; i++) {\n        list[i] = i;\n    }\n\n    // operation\n    for (int i = 0; i < T_length; i++) {\n        // salsa\n        if (T[i] == 'S') {\n            vector<vector<int>> swap_index(N, vector<int>(N));\n            for (int list_index = 0; list_index < N; list_index++)\n            {\n                    // convert list_index from decimal to ternary\n                    temp_str = r.to(list_index, 3);\n                    int temp_str_length = (int)temp_str.length();\n                    // swap 1 with 2\n                    for (int j = 0; j < temp_str_length; j++) {\n                        switch (temp_str[j]) {\n                        case '1':\n                            temp_str[j] = '2';\n                            break;\n                        case '2':\n                            temp_str[j] = '1';\n                            break;\n                        }\n                    }\n                    // convert ternary to decimal\n                    temp = r.to(temp_str, 3);\n\n                    // check if swap hasn't been done for temp and list_index\n                    if (!vector_has(swap_index[list_index], temp)) {\n                        // convert string to integer\n                        swap(list[list_index], list[temp]);\n                        // register swapped opponent\n                        swap_index[list_index].push_back(temp);\n                        swap_index[temp].push_back(list_index);\n                    }\n\n            }\n        }\n        // rumba\n        else\n        {\n            for (int j = N - 1; 0 < j; j--) {\n                swap(list[j - 1], list[j]);\n            }\n        }\n    }\n    int* list_pos = new int[N];\n    for (int i = 0; i < N; i++) {\n        list_pos[list[i]] = i;\n    }\n\n    for (int i = 0; i < N; i++) {\n        cout << list_pos[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mxn=6e5+5,mxm=2e5+5;\nint n,m,c=1;string s;\nint a[mxn],b[mxn],v[mxn];\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin>>n>>s;m=s.size(),s=\" \"+s;\n\tfor(int i=1;i<=n;++i,c*=3){\n\t\tint rev=0;\n\t\tfor(int j=0;j<c;++j)for(int f=0;f<3;++f)b[j+f*c]=f;\n\t\tfor(int j=1;j<=m;++j){\n\t\t\tif(s[j]=='R'){\n\t\t\t\tint lst=v[j];\n\t\t\t\tfor(int f=0;f<3;++f){\n\t\t\t\t\tint p=lst+f*c;\n\t\t\t\t\tif(b[p]+rev==2)v[j]=p;\n\t\t\t\t\t(b[p]+=rev+1)%=3;\n\t\t\t\t}\n\t\t\t}else rev^=1;\n\t\t}\n\t\tfor(int j=0;j<c;++j){\n\t\t\tint t=a[j];\n\t\t\tfor(int f=0;f<3;++f){\n\t\t\t\tint p=j+f*c;\n\t\t\t\ta[p]=t+(rev?3-b[p]:b[p])%3*c;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<c;++i)cout<<a[i]<<' ';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#define int long long\n\n#define pii pair<int, int>\n\n#define x1 x1228\n#define y1 y1228\n\n#define left left228\n#define right right228\n\n#define next next228\n\n#define pb push_back\n#define eb emplace_back\n\n#define mp make_pair                                                                \n                                                                                                                                        \n#define ff first                                                                  \n#define ss second   \n\n#define all(x) x.begin(), x.end()\n#define debug(x) cout << #x << \": \" << x << endl; \n#define TIME (ld)clock()/CLOCKS_PER_SEC\n\nusing namespace std;\ntypedef long long ll; \ntypedef long double ld; \n                                                                                                   \nconst int maxn = 2e5 + 7, mod = 1e9 + 7, MAXN = 1e6 + 7;\nconst double eps = 1e-9;\nconst ll inf = 1e18;\nmt19937 rnd(time(0));\nint n; \nstring s; \nint next[MAXN];\nconst int N = 2187; \nint dp1[N]; \nint dp2[N]; \nint xyz[N]; \n\nint get1(int mask, char q) {\n    if (q == 'R') {\n        ++mask; \n        return mask; \n    }   \n    int ptr = 1; \n    int ans = 0; \n    while (mask) {\n        int t = mask % 3; \n        mask /= 3; \n        if (t == 2) ans += ptr; \n        if (t == 1) ans += 2 * ptr; \n        ptr *= 3; \n    }\n    return ans; \n}\n\nint get(int mask, char q) {\n    if (q == 'R') {\n        ++mask; \n        return mask; \n    }   \n    return xyz[mask]; \n}\n\nconst int L = 12; \nint pref[maxn]; \nint to[maxn]; \nint kek1[N], kek2[N]; \nint res[N]; \n\nint get(int l, int r) {\n    return pref[r + 1] - pref[l]; \n}\n\nvoid change(int &mask, int l, int r) {\n    if (get(l, r) % 2) {\n        mask = get(mask, 'S'); \n    }    \n    mask++; \n}\n\nint merge(int left, int right) {\n    for (int i = 0; i < 7; ++i) right *= 3;\n    return left + right;     \n}\n\nint get(int x) {\n    vector<int> bts; \n    for (int i = 0; i < L; ++i) {\n        bts.pb(x % 3); \n        x /= 3; \n    }\n    int left = 0;\n    int right = 0; \n    for (int i = 6; i >= 0; --i) {\n        left *= 3;\n        left += bts[i]; \n    }\n    for (int i = L - 1; i >= 7; --i) {\n        right *= 3; \n        right += bts[i]; \n    }\n    int id = 0; \n    if (left && dp1[left] == -1) {\n        return merge(res[left], right);  \n    }\n    if (left) {    \n        id = dp1[left]; \n        change(right, 0, id - 1);             \n        left = 0; \n    }                     \n    while (next[id] != -1) {\n        change(right, id, next[id] - 1);\n        id = next[id];                                                                                                                                         \n    }\n    left = to[id]; \n    return merge(left, right); \n}\n\n\nvoid solve() {\n    for (int i = 0; i < N; ++i) {\n        xyz[i] = get1(i, 'S') % N; \n    }\n\n    cin >> n >> s; \n    int t = s.size(); \n    for (int i = 0; i < N; ++i) {        \n        res[i] = i; \n        for (int j = 0; j < t; ++j) {\n            res[i] = get(res[i], s[j]); \n        } \n    }\n    for (int i = 0; i < t; ++i) {\n        pref[i + 1] = pref[i] + (s[i] == 'S'); \n    }\n    for (int i = 0; i < N; ++i) dp1[i] = dp2[i] = -1; \n    next[t] = -1;\n    for (int i = 0; i < N; ++i) kek1[i] = i;              \n    for (int i = t - 1; i >= 0; --i) {\n        for (int mask = 0; mask < N; ++mask) {\n            int mask1 = get(mask, s[i]); \n            mask1 %= N; \n            kek2[mask] = kek1[mask1];\n        }\n        to[i] = kek2[0]; \n        for (int mask = 0; mask < N; ++mask) {\n            int mask1 = get(mask, s[i]);\n            mask1 %= N;                 \n            if (mask && mask1 == 0) {\n                dp2[mask] = i + 1; \n            } else {\n                dp2[mask] = dp1[mask1]; \n            }   \n        }\n        next[i] = dp2[0]; \n        for (int mask = 0; mask < N; ++mask) {\n            kek1[mask] = kek2[mask]; \n            dp1[mask] = dp2[mask]; \n            dp2[mask] = -1; \n        }\n    }\n    int tet = 1; \n    for (int i = 0; i < n; ++i) tet *= 3; \n    for (int i = 0; i < tet; ++i) {\n        cout << get(i) % tet << \" \"; \n    }\n//    cout << TIME; \n}                                \n   \nsigned main() {\n#ifdef LOCAL\n    freopen(\"TASK.in\", \"r\", stdin);\n    freopen(\"TASK.out\", \"w\", stdout);\n#else \n    \n#endif // LOCAL\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20); \n    cout << fixed; \n    int t = 1; \n    for (int i = 0; i < t; ++i) {              \n        solve();\n    }\n    return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl \"\\n\"\n#define ll long long\n#define INF (ll)1e18\n#define fill treapdidsu\n\narray<ll, 12> b3(ll x) {\n    ll i, j, k;\n    array<ll, 12> res;\n    k = 0;\n    for (i = 0; i < 12; i++) {\n        res[i] = 0;\n    }\n    while (x != 0) {\n        res[k] = x % 3;\n        x /= 3;\n        k++;\n    }\n\n    return res;\n}\n\nll l3(ll x) {\n    ll i, j, k, p3;\n    ll res;\n    k = 0; p3 = 1;\n    res = 0;\n    while (x != 0) {\n        j = x % 3;\n        x /= 3;\n        if (j == 1) {\n            j = 2;\n        } else if (j == 2) {\n            j = 1;\n        }\n        res += (p3 * j);\n        k++; p3 *= 3;\n    }\n\n    return res;\n}\n\nll i, i1, j, k, k1, n, m, res, check1, a, b, s, p3, v[1000010], o[1000010];\nbool visited[1000010];\nstring t;\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    ifstream cin(\"input.txt\");\n    ofstream cout(\"output.txt\");\n\n    cin >> n >> t;\n    s = t.size();\n    m = pow(3, n);\n    k = 0;\n    for (i = 0; i < m; i++) {\n        visited[i] = false;\n    }\n\n    p3 = 0;\n    for (i = 0; i <= n; i++) {\n        p3++;\n        k = p3;\n        for (j = 0; j < s; j++) {\n            // cout << j << ' ' << k << endl;\n            if (t[j] == 'S') {\n                k = l3(k);\n            } else {\n                k = (k + 1) % m;\n            }\n        }\n        // cout << endl;\n\n        v[p3] = k;\n        // cout << p3 << ' ' << k << endl;\n        p3--;\n        p3 *= 3;\n        if (p3 == 0) p3 = 1;\n    }\n\n    p3 = 1;\n    for (i = 0; i <= n; i++) {\n        p3++;\n        k = (m + v[p3] - v[1]) % m;\n        j = 2 * p3 + 1;\n        o[(j % m)] = (v[j - p3 + 1] + k) % m;\n        for (j = 3 * p3 - 1; j <= m; j += (p3 - 1)) {\n            o[(j % m)] = (o[j - p3 + 1] + k) % m;\n        }\n        p3--;\n        p3 *= 3;\n    }\n\n    /* for (i = 0; i < m; i++) {\n        cout << l3(i) << ' ';\n    }\n    cout << endl; */\n\n    for (i = 0; i < m; i++) {\n        cout << o[i] << ' ';\n    }\n    cout << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n\n#define putchar_unlocked putchar\n\nchar T[524288];\n\n// Based on editorial solution\nint D[13][550005]; // one digit at a time, with digit 0 representing the ones place\nint W[13][550005];\nint lastUpdated[13][550005];\n\nint x[11];\ninline void putInt(int i){\n    if(i==0){putchar_unlocked('0');}\n    else{\n    int count1=0;\n    while(i>0){\n        x[count1++]=i%10;\n        i/=10;\n    }\n    for(int j=count1-1;j>=0;j--){\n        putchar_unlocked(48+x[j]);\n    }\n    }\n    putchar_unlocked(' ');\n}\n\nint N;\n\ninline void update(int n, int indx, int cntS){\n    if( ((cntS&1) != (lastUpdated[n][indx]&1)) && D[n][indx]){\n        // conduct salsa\n        D[n][indx] = 3-D[n][indx];\n    }\n    // update the lastUpdated index\n    lastUpdated[n][indx] = cntS;\n}\n\nint pow3[16];\n\nint main(){\n    scanf(\"%d\", &N);\n    scanf(\" %s\", T);\n\n    int M = strlen(T);\n\n    pow3[0] = 1;\n    for(int i = 1; i <= N; i ++){\n        pow3[i] = pow3[i-1]*3;\n    }\n\n    memset(W, 0, sizeof(W));\n    for(int n = 1; n <= N; n ++){\n        //printf(\"ok\");\n        for(int j = 0; j < pow3[n-1]; j ++){\n            D[n][j] = 0;\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        for(int j = pow3[n-1]; j < (pow3[n-1]<<1); j ++){\n            D[n][j] = 1;\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        for(int j = (pow3[n-1]<<1); j < pow3[n]; j ++){\n            D[n][j] = 2;\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        W[n][0] = pow3[n]-1;\n    }\n\n\n    memset(lastUpdated, 0, sizeof(lastUpdated));\n    int cntS2 = 0;\n    for(int n = 1; n <= N; n ++){\n        int cntS = 0;\n        for(int i = 0; i < M; i ++){\n            int indx0 = W[n-1][i];\n            int indx1 = W[n-1][i]+pow3[n-1];\n            int indx2 = W[n-1][i]+(pow3[n-1]<<1);\n\n            if(indx1 >= pow3[n]){indx1 -= pow3[n];}\n            if(indx2 >= pow3[n]){indx2 -= pow3[n];}\n\n            update(n, indx0, cntS+(T[i]=='S'));\n            update(n, indx1, cntS+(T[i]=='S'));\n            update(n, indx2, cntS+(T[i]=='S'));\n            if(D[n][indx0] == 2){\n                W[n][i] = indx0;\n            }else if(D[n][indx1] == 2){\n                W[n][i] = indx1;\n            }else{\n                W[n][i] = indx2;\n            }\n\n            if(T[i] == 'R'){\n                D[n][indx0] = (D[n][indx0]+1);\n                D[n][indx1] = (D[n][indx1]+1);\n                D[n][indx2] = (D[n][indx2]+1);\n                if(D[n][indx0] == 3){D[n][indx0] = 0;}\n                if(D[n][indx1] == 3){D[n][indx1] = 0;}\n                if(D[n][indx2] == 3){D[n][indx2] = 0;}\n                lastUpdated[n][indx0] = cntS;\n                lastUpdated[n][indx1] = cntS;\n                lastUpdated[n][indx2] = cntS;\n            }else if(T[i] == 'S'){\n                cntS ++;\n            }\n\n            //printf(\"W[%d][%d]=%d\\n\", n, i+1, W[n][i+1]);\n        }\n\n        cntS2 = cntS;\n    }\n\n    for(int n = 1; n <= N; n ++){\n        for(int i = 0; i < pow3[n]; i ++){\n            update(n, i, cntS2);\n        }\n    }\n\n    for(int i = 0; i < pow3[N]; i ++){\n        int temp = 0;\n        for(int n = 1; n <= N; n ++){\n            temp += D[n][i%pow3[n]]*pow3[n-1];\n        }\n        putInt(temp);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint ans[540000];\n\ntypedef class TrieNode {\n\tpublic:\n\t\tTrieNode *ch[3];\n\t\tbool swp12;\n\t\tint id;\n\n\t\tvoid swap12() {\n\t\t\tswp12 ^= 1;\n\t\t\tswap(ch[1], ch[2]);\n\t\t}\n\t\tbool leaf() {\n\t\t\treturn !ch[0];\n\t\t}\n\t\tvoid push_down() {\n\t\t\tif (swp12) {\n\t\t\t\tch[0]->swap12();\n\t\t\t\tch[1]->swap12();\n\t\t\t\tch[2]->swap12();\n\t\t\t\tswp12 = false;\n\t\t\t}\n\t\t}\n\n\t\tvoid get_ans(int base, int v) {\n\t\t\tif (leaf()) {\n\t\t\t\tans[id] = v;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpush_down();\n\t\t\tch[0]->get_ans(base * 3, v);\n\t\t\tch[1]->get_ans(base * 3, v += base);\n\t\t\tch[2]->get_ans(base * 3, v += base);\n\t\t}\n} TrieNode;\n\nTrieNode pool[1000000];\nTrieNode *_top = pool;\n\nTrieNode *newnode() {\n\treturn _top++;\n}\n\ntypedef class Trie {\n\tpublic:\n\t\tTrieNode* rt;\n\n\t\tvoid build(TrieNode*& p, int r, int base, int v) {\n\t\t\tp = newnode();\n\t\t\tif (r == 0) {\n\t\t\t\tp->id = v;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbuild(p->ch[0], r - 1, base * 3, v);\n\t\t\tbuild(p->ch[1], r - 1, base * 3, v += base);\n\t\t\tbuild(p->ch[2], r - 1, base * 3, v += base);\n\t\t}\n\t\tvoid build(int n) {\n\t\t\tbuild(rt, n, 1, 0);\n\t\t}\n\n\t\tvoid swap12() {\n\t\t\trt->swap12();\n\t\t}\n\t\t\n\t\tvoid update(TrieNode*& p) {\n\t\t\tif (p->leaf()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tp->push_down();\n\t\t\tswap(p->ch[0], p->ch[1]);\n\t\t\tswap(p->ch[0], p->ch[2]);\n\t\t\tupdate(p->ch[0]);\n\t\t}\n\t\tvoid update() {\n\t\t\tupdate(rt);\n\t\t}\n\n\t\tvoid get_ans() {\n\t\t\trt->get_ans(1, 0);\n\t\t}\n} Trie;\n\nint n;\nchar T[200005];\nTrie tr;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", T + 1);\n\tint m = strlen(T + 1);\n\ttr.build(n);\n\tfor (int i = 1; i <= m; i++) {\n\t\tchar c = T[i];\n\t\tif (c == 'S') {\n\t\t\ttr.swap12();\n\t\t} else {\n\t\t\ttr.update();\n\t\t}\n\t}\n\ttr.get_ans();\n\tint all = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tall *= 3;\n\t}\n\tfor (int i = 0; i < all; i++) {\n\t\tprintf(\"%d \", ans[i]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m;\nconst int M = 2e5+5;\nchar s[M];\n \nstruct Node{\n\tint swp,ch[3],ed;\n}t[2000010];\nint cnt=1;\n \ninline void ins(int sum){\n\tint fir=1;\n\tint s=sum;\n\tfor(int i=0;i<n;i++){\n\t\tint q=sum%3;\n\t\tsum/=3;\n\t\tif(!t[fir].ch[q])t[fir].ch[q]=++cnt;\n\t\tfir=t[fir].ch[q];\n\t}\n\tt[fir].ed=s;\n}\n \nvoid add(){\n\tint fir=1;\n\tfor(int i=0;i<n;i++){\n\t\tif(t[fir].swp){\n\t\t\tswap(t[fir].ch[1],t[fir].ch[2]);\n\t\t\tfor(int j=0;j<3;j++)t[t[fir].ch[j]].swp^=1;\n\t\t\tt[fir].swp=0;\n\t\t}\n\t\tint q=t[fir].ch[2];t[fir].ch[2]=t[fir].ch[1],t[fir].ch[1]=t[fir].ch[0];\n\t\tt[fir].ch[0]=q;\n\t\tfir=q;\n\t}\n}\nint ans[2000010];\nvoid dfs(int fir,int d,int quan,int s){\n\tif(t[fir].swp){\n\t\tswap(t[fir].ch[1],t[fir].ch[2]);\n\t\tfor(int j=0;j<3;j++)t[t[fir].ch[j]].swp^=1;\n\t\tt[fir].swp=0;\n\t}\n\tif(d==n){\n\t\tans[t[fir].ed]=s;return;\n\t}\n\tfor(int j=0;j<3;j++){\n\t\tdfs(t[fir].ch[j],d+1,quan*3,s+quan*j);\n\t}\n}\nint tot=0;\nint main()\n{\n\tcin >> n;\n\ttot=1;for(int i=1;i<=n;i++)tot*=3;\n\tscanf(\"%s\",s+1);\n\tm=strlen(s+1);\n\tfor(int i=0;i<tot;i++){\n\t\tins(i);\n\t}\n\t// cerr << \"?\" << endl;\n\tfor(int j=1;j<=m;j++){\n\t\tif(s[j]=='S')t[1].swp^=1;\n\t\telse add();\n\t\t// dfs(1,0,1,0);\n\t\t// for(int i=0;i<tot;i++)printf(\"%d \",ans[i]);puts(\"\");\n\t}\n\tdfs(1,0,1,0);\n\tfor(int i=0;i<tot;i++)printf(\"%d \",ans[i]);puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#define ENABLE_DEBUG 0\n// Kana's kitchen {{{\n#include<bits/stdc++.h>\n#define ALL(v) std::begin(v),std::end(v)\n#define LOOP(k) for(i64 ngtkana_is_a_genius=0; ngtkana_is_a_genius<(i64)k; ngtkana_is_a_genius++)\n\nusing i32 = std::int_least32_t;\nusing i64 = std::int_least64_t;\nusing u32 = std::uint_least32_t;\nusing u64 = std::uint_least64_t;\nusing usize = std::size_t;\n\ntemplate <class T> using vec = std::vector<T>;\ntemplate <class T> using numr = std::numeric_limits<T>;\n\n#ifdef NGTKANA\n#include<debug.hpp>\n#else\n#define DEBUG(...)(void)0\n#endif\n/*}}}*/\n// mint{{{\ntemplate <class ModType> struct modint {\n    using value_type = typename ModType::value_type;\n    using mint = modint<ModType>;\n    using mod_type = ModType;\n\n    static value_type mod() { return ModType::value; }\n\n    private:\n    static value_type inverse(value_type x) {\n        value_type y=1,u=mod(),v=0;\n        while(x){\n            value_type q=u/x;\n            u-=q*x; std::swap(x,u);\n            v-=q*y; std::swap(y,v);\n        }\n        assert(x==0 && std::abs(y)==mod() && std::abs(u)==1 && std::abs(v)<mod());\n        return v<0?v+mod():v;\n    }\n\n    public:\n    // the member variable\n    value_type value;\n\n    // constructors\n    modint()=default;\n    modint(modint const&)=default;\n    modint(modint&&)=default;\n    modint& operator=(modint const&)=default;\n    modint& operator=(modint&&)=default;\n    ~modint()=default;\n\n    template <class T> modint(T t) : value([t] () mutable {\n            if ( t <= -static_cast<T>(mod()) || static_cast<T>(mod()) <= t ) t %= mod();\n            return t < 0 ? t + mod() : t;\n            }()) {}\n\n    // operators\n    mint& operator+= (mint y) {\n        value += y.value;\n        if (mod() <= value) value -= mod();\n        return *this;\n    }\n\n    mint& operator-= (mint y) {\n        value -= y.value;\n        if ( value < 0 ) value += mod();\n        return *this;\n    }\n\n    mint& operator*= (mint y) {\n        value = (long long)value * y.value % mod();\n        return *this;\n    }\n\n    mint& operator/= (mint y) {\n        value = (long long)value * inverse(y.value) % mod();\n        return *this;\n    }\n\n    mint& operator++() { return *this+=1; }\n    mint& operator--() { return *this-=1; }\n    mint  operator++(int) { mint this_=*this; ++*this; return this_; }\n    mint  operator--(int) { mint this_=*this; --*this; return this_; }\n\n    // static member functions\n    static mint inv(mint x) { return inverse(x.value); }\n\n    static mint m1pow(long long y) { return y%2?-1:1; }\n\n    static mint pow(mint x, unsigned long long y) {\n        mint ans=1;\n        for(;y;y>>=1){\n            if(y&1ull) ans*=x;\n            x*=x;\n        }\n        return ans;\n    }\n\n    // non-member functions\n    mint& add_assign(mint y) { return *this+=y; }\n    mint& sub_assign(mint y) { return *this-=y; }\n    mint& mul_assign(mint y) { return *this*=y; }\n    mint& div_assign(mint y) { return *this/=y; }\n    mint& inv_assign()       { return *this = inv(*this); }\n    mint& pow_assign(unsigned long long y){ return *this = pow(*this, y); }\n\n    mint add(mint y) { mint ans=*this; return ans.add_assign(y); }\n    mint sub(mint y) { mint ans=*this; return ans.sub_assign(y); }\n    mint mul(mint y) { mint ans=*this; return ans.mul_assign(y); }\n    mint div(mint y) { mint ans=*this; return ans.div_assign(y); }\n    mint inv()       { mint ans=*this; return ans.inv_assign(); }\n    mint pow(unsigned long long y) { return pow(*this, y); }\n\n    template <class F> mint map(F const& f){\n        value=f(value);\n        return *this;\n    }\n};\n\n    template <class T> std::istream&\noperator>>(std::istream& is, modint<T>& x)\n{\n    typename modint<T>::value_type y;\n    is >> y;\n    x = modint<T>{ y };\n    return is;\n}\n    template <class T> std::ostream&\noperator<<(std::ostream& os, modint<T> x)\n{\n    return os << x.value;\n}\n\ntemplate <class T> modint<T> operator+(modint<T> x, modint<T> y) { return x+=y; }\ntemplate <class T> modint<T> operator-(modint<T> x, modint<T> y) { return x-=y; }\ntemplate <class T> modint<T> operator*(modint<T> x, modint<T> y) { return x*=y; }\ntemplate <class T> modint<T> operator/(modint<T> x, modint<T> y) { return x/=y; }\ntemplate <class T> bool operator==(modint<T> x, modint<T> y) { return x.value==y.value; }\ntemplate <class T> bool operator!=(modint<T> x, modint<T> y) { return x.value!=y.value; }\n\ntemplate <class T, class U> modint<T> operator+(modint<T> x, U y) { return x+modint<T>(y); }\ntemplate <class T, class U> modint<T> operator-(modint<T> x, U y) { return x-modint<T>(y); }\ntemplate <class T, class U> modint<T> operator*(modint<T> x, U y) { return x*modint<T>(y); }\ntemplate <class T, class U> modint<T> operator/(modint<T> x, U y) { return x/modint<T>(y); }\ntemplate <class T, class U> bool operator==(modint<T> x, U y) { return x==modint<T>(y); }\ntemplate <class T, class U> bool operator!=(modint<T> x, U y) { return x!=modint<T>(y); }\n\ntemplate <class T, class U> modint<T> operator+(U x, modint<T> y) { return modint<T>(x)+y; }\ntemplate <class T, class U> modint<T> operator-(U x, modint<T> y) { return modint<T>(x)-y; }\ntemplate <class T, class U> modint<T> operator*(U x, modint<T> y) { return modint<T>(x)*y; }\ntemplate <class T, class U> modint<T> operator/(U x, modint<T> y) { return modint<T>(x)/y; }\ntemplate <class T, class U> bool operator==(U x, modint<T> y) { return modint<T>(x)==y; }\ntemplate <class T, class U> bool operator!=(U x, modint<T> y) { return modint<T>(x)!=y; }\n/*}}}*/\nusing mint = modint<std::integral_constant<i32, 3>>;\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n    std::cout << std::setprecision(15) << std::fixed;\n\n    usize n;\n    std::cin >> n;\n    vec<usize> tpow(n+1, 1);\n    for (usize i=0; i<n; i++) {\n        tpow.at(i+1) = tpow.at(i) * 3;\n    }\n    usize N = tpow.back();\n    DEBUG(n, N, tpow);\n\n    bool has_s = false;\n    vec<vec<mint>> sigma(n);\n    for (usize i=0; i<n; i++) {\n        sigma.at(i).resize(tpow.at(i));\n    }\n    DEBUG(matrix_style(sigma));\n\n    // apply-s{{{\n    auto apply_s = [&](usize a) {\n        for (usize k=0; k<n; k++) {\n            usize K = tpow.at(k);\n            usize r = a % (3*K);\n            if (K <= r && r < 2*K) {\n                a += K;\n            } else if (2*K <= r) {\n                a -= K;\n            }\n        }\n        return a;\n    };\n    /*}}}*/\n    // mul_r_from_the_left{{{\n    auto mul_r_from_the_left = [&] {\n        for (usize i=n-1; i!=-1; i--) {\n            usize I = tpow.at(i);\n            usize j = I - 1;\n            if (has_s) {\n                j = apply_s(j);\n            }\n            DEBUG(i, j);\n            for (usize k=0; k<i; k++) {\n                usize K = tpow.at(k);\n                usize r = j % (3*K);\n                usize val = sigma.at(k).at(r%K).value;\n                DEBUG(j,val);\n                j -= val * K;\n                if (r < val*K) j += 3*K;\n                DEBUG(j,val);\n            }\n            if (has_s) {\n                sigma.at(i).at(j)--;\n            } else {\n                sigma.at(i).at(j)++;\n            }\n        }\n    };\n/*}}}*/\n    // get-ans{{{\n    auto get_ans = [&] {\n        vec<usize> ans(N);\n        std::iota(ALL(ans), 0u);\n        for (usize j=0; j<N; j++) {\n            usize& a = ans.at(j);\n            for (usize k=n-1; k!=-1; k--) {\n                usize K = tpow.at(k);\n                usize r = a % (3*K);\n                usize val = sigma.at(k).at(r%K).value;\n                a += val * K;\n                if ((3-val)*K <= r) a -= 3*K;\n            }\n            if (has_s) {\n                a = apply_s(a);\n            }\n        }\n        return ans;\n    };\n/*}}}*/\n    DEBUG(get_ans());\n\n    std::string s;\n    std::cin >> s;\n    for (char c: s) {\n        DEBUG(c);\n        if (c=='S') {\n            has_s ^= 1;\n        }\n        if (c=='R') {\n            mul_r_from_the_left();\n        }\n        DEBUG(has_s);\n        DEBUG(matrix_style(sigma));\n        auto ans = get_ans(); DEBUG(ans);\n        DEBUG();\n    }\n\n    auto ans = get_ans();\n    for (usize i=0; i<N; i++) {\n        std::cout << (i?\" \":\"\") << ans.at(i);\n    }\n    std::cout << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <fstream>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nconst int MAXN = 531445;\n\nint N,m;\nint sum[MAXN];\nint to[2][MAXN];\n\nvector<int> add[2][MAXN];\n\nchar s[MAXN];\n\nint main()\n{\n\tscanf(\"%d%s\",&N,s + 1);\n\tm = strlen(s + 1);\n\tfor (int i = 1;i <= m;i++)\n\t{\n\t\tsum[i] = sum[i - 1] + (s[i] == 'S');\n\t\tif (s[i] == 'R')\n\t\t\tadd[0][0].push_back(i);\n\t}\n\tint v = 1;\n\tfor (int i = 1;i <= N;i++,v *= 3)\n\t\tfor (int j = 0;j < 3;j++)\n\t\t\tfor (int k = 0;k < v;k++)\n\t\t\t{\n\t\t\t\tto[i & 1][k + v * j] = to[~i & 1][k];\n\t\t\t\tadd[i & 1][k + v * j].clear();\n\t\t\t\tint cur = j,lst = 0;\n\t\t\t\tfor (int l = 0;l < add[~i & 1][k].size();l++)\n\t\t\t\t{\n\t\t\t\t\tint p = add[~i & 1][k][l];\n\t\t\t\t\tif ((sum[p] - sum[lst]) & 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tcur = (cur == 1 || cur == 2 ? 3 - cur : cur);\n\t\t\t\t\t\tlst = p;\n\t\t\t\t\t}\n\t\t\t\t\tcur++;\n\t\t\t\t\tif (cur == 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tadd[i & 1][k + v * j].push_back(p);\n\t\t\t\t\t\tcur = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ((sum[m] - sum[lst]) & 1)\n\t\t\t\t\tcur = (cur == 1 || cur == 2 ? 3 - cur : cur);\n\t\t\t\tto[i & 1][k + v * j] += v * cur;\n\t\t\t}\n\tfor (int i = 0;i < v;i++)\n\t\tprintf(\"%d \",to[N & 1][i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <functional>\n#include <iomanip>\n#include <limits>\n//#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll; //10^18\ntypedef unsigned long ul;\n\nusing Graph = vector<vector<ll>>;\n\ntypedef map<ll, ll> m;\ntypedef multimap<ll, ll> mm;\ntypedef set<ll> s;\ntypedef multiset<ll> ms;\ntypedef priority_queue<ll> pq;\ntypedef queue<ll> q;\ntypedef deque<ll> dq;\ntypedef list<ll> lst;\ntypedef pair<ll, ll> p;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define INFLL (9223372036854775807LL)\n#define PI (acos(-1))\n#define MOD 1000000007LL\n#define WALL '#'\n\n//#define and &&a\n//#define or ||\n//#define not !\n//#define neq !=\n//#define eq ==\n\n#define REP(i, n) for (ll i = 0; i < n; i++)\t  // from 0 to n\n#define REPR(i, n) for (ll i = n; i >= 0; i--)\t  // from n to 0\n#define FOR(i, m, n) for (ll i = m; i < n; i++)\t  // from m to n\n#define FORR(i, m, n) for (ll i = m; i >= n; i--) // from m to n\n#define DBG(a) cout << #a << \" : \" << a << \"\\n\";\n#define MSG(a) cout << a << \"\\n\";\n#define ALL(v) v.begin(), v.end()\n#define SZ(x) ((int)(x).size())\n#define PNT(a) printf(\"%lld\", (a))\n\n#define pb push_back //配列などの最後に要素を追加\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define FST first\n#define SND second\n\ntemplate <class T>\nbool chmax(T& a, const T& b)\n{\n\tif (a < b)\n\t{\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T>\nbool chmin(T& a, const T& b)\n{\n\tif (b < a)\n\t{\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n// グローバル変数宣言\n// 迷路用\nvector<ll> dy4 = { 0, 0, -1, 1, 0 }, dx4 = { -1, 1, 0, 0, 0 };\nvector<ll> dx8 = { -1,0,1,-1,1,-1,0,1 }, dy8 = { -1,-1,-1,0,0,1,1,1 };\n\n//\nvector<ll> factorial = {};\nvector<ll> factorialInverse = {};\n\n//swap(a, b);\n//sort(arr, arr + n);\t//昇順\n//sort(arr, arr+n, greater<int>());\t//降順\n//max(a, b);\n//min(a, b);\n\n//upper_bound(a, a+n, k)\t//配列aの中で、kより大きい値が初めて現れる位置へのポインタ\n//upper_bound(ALL(v), k)\t//STLvの中で、kより大きい値が初めて現れる位置へのポインタ\n//lower_bound(a, a+n, k)\n//lower_bound(ALL(v), k)\t//STLvの中で、kの以上値が初めて現れる位置へのポインタ\n//lower_bound(ALL(v),k) - upper_bound(ALL(v),k)\t//二分探索を用いて、ある列aに含まれる数kの個数を求める\n\n// n個のデータをvectorで取得\nvector<ll> INV(ll n)\n{\n\tvector<ll> v(n);\n\tREP(i, n)\n\t\tcin >> v[i];\n\treturn v;\n}\n\n// n個のデータをvectorで取得\nvector<vector<ll>> INV2(ll n, ll m)\n{\n\tvector<vector<ll>> v(n, vector<ll>(m));\n\tREP(i, n)\n\t{\n\t\tREP(j, m)\n\t\t{\n\t\t\tcin >> v[i][j];\n\t\t}\n\t}\n\treturn v;\n}\n\n// index が条件を満たすかどうか\nbool isOK(vector<ll>& v, int index, int key, bool flag)\n{\n\tif (flag) {\n\n\t\tif (v[index] >= key)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\telse {\n\t\tif (v[index] > key)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n}\n\n// 汎用的な二分探索\n// flag == 1 >=, flag == 0 >\nll bs(vector<ll>& v, ll key, bool flag)\n{\n\tint ng = -1;\t//「index = 0」が条件を満たすこともあるので、初期値は -1\n\tint ok = SZ(v); // 「index = a.size()-1」が条件を満たさないこともあるので、初期値は a.size()\n\n\t/* ok と ng のどちらが大きいかわからないことを考慮 */\n\twhile (abs(ok - ng) > 1)\n\t{\n\t\tint mid = (ok + ng) / 2;\n\n\t\tif (isOK(v, mid, key, flag))\n\t\t\tok = mid;\n\t\telse\n\t\t\tng = mid;\n\t}\n\treturn ok;\n}\n\n// 最大公約数\nll gcd(ll a, ll b)\n{\n\tif (a < b)\n\t\tswap(a, b);\n\tll r = a % b;\n\twhile (r != 0)\n\t{\n\t\ta = b;\n\t\tb = r;\n\t\tr = a % b;\n\t}\n\treturn b;\n}\n\n// 最小公倍数\nvoid lcm(ll a, ll b)\n{\n}\n\n// 素数判定\nbool is_prime(ll n)\n{\n\tbool flg = true;\n\tif (n <= 1)\n\t\tflg = false;\n\telse if (n == 2)\n\t\tflg = true;\n\telse if (n % 2 == 0)\n\t\tflg = false;\n\telse\n\t{\n\t\tfor (ll i = 3; i * i <= n; i += 2)\n\t\t{\n\t\t\tif (n % i == 0)\n\t\t\t\tflg = false;\n\t\t}\n\t}\n\treturn flg;\n}\n\n// 素因数分解\n// iで割った回数をcnt_pf[i - 1]に格納している\n// cnt_pf[0]に入力が素数だった場合にその素数が入る\nvector<ll> prime_factorization(ll n)\n{\n\tvector<ll> cnt_pf(sqrt(n), 0);\n\tFOR(i, 1, SZ(cnt_pf))\n\t{\n\t\twhile (n % (i + 1) == 0)\n\t\t{\n\t\t\tcnt_pf[i]++;\n\t\t\tn /= (i + 1);\n\t\t}\n\t\tif (n == 1)\n\t\t\tbreak;\n\t}\n\tif (n != 1)\n\t{\n\t\tcnt_pf[0] = n;\n\t}\n\treturn cnt_pf;\n}\n\n// 迷路のマップ情報をベクトル化する\n// 通れるところを0に、壁を-1にする\n// スタート地点からの距離を格納するときなどに使う\nvector<vector<ll>> map_vec(vector<string>& str)\n{\n\t// SZ(str[0] = SZ(str[distance(str.begin(), max_element(ALL(str)))])\n\tvector<vector<ll>> v(SZ(str), vector<ll>(SZ(str[distance(str.begin(), max_element(ALL(str)))]), (int)INF));\n\tREP(i, SZ(str))\n\t{\n\t\tREP(j, SZ(str[i]))\n\t\t{\n\t\t\tif (str[i][j] == WALL)\n\t\t\t\tv[i][j] = -1;\n\t\t\t//else\tv[i][j] = INF;\t// if (str[i][j] == '.')\n\t\t}\n\t}\n\treturn v;\n}\n// str中のWALL='#'の数を数える\nll cnt_wall(vector<string> str)\n{\n\tll cnt = 0;\n\tREP(i, SZ(str))\n\t{\n\t\tREP(j, SZ(str[i]))\n\t\t{\n\t\t\tif (str[i][j] == WALL)\n\t\t\t\tcnt++;\n\t\t}\n\t}\n\treturn cnt;\n}\n\n\n// マップの範囲判定\nbool rangeCheck(ll row, ll height, ll col, ll width) {\n\tif (row >= 0 && row < height && col >= 0 && col < width)\treturn true;\n\telse return false;\n}\n\n// 迷路用幅優先探索\n// フィールドの広さと壁の位置を受け取り、ゴールへの最短距離を返す\nll bfs_maze(vector<string>& str, ll s_y, ll s_x, ll g_y, ll g_x)\n{\n\n\tstruct Corr\n\t{\n\t\tll y;\n\t\tll x;\n\t\tll depth;\n\t};\n\tqueue<Corr> que;\n\t// SZ(str[0] = SZ(str[distance(str.begin(), max_element(ALL(str)))])\n\tvector<vector<ll>> v(SZ(str), vector<ll>(SZ(str[distance(str.begin(), max_element(ALL(str)))])));\n\tv = map_vec(str);\n\n\t// スタート地点を含めるのか\n\tque.push({ s_y, s_x, 0 });\n\twhile (!que.empty())\n\t{\n\t\tCorr now = que.front();\n\t\tque.pop();\n\t\tif (now.y == g_y && now.x == g_x)\n\t\t\tbreak;\n\n\t\tREP(i, 4)\n\t\t{\n\t\t\tCorr next = { now.y + dy4[i], now.x + dx4[i], now.depth + 1 };\n\t\t\t// SZ(v[0] = SZ(v[distance(v.begin(), max_element(ALL(v)))])\n\t\t\tif (rangeCheck((int)next.y, SZ(v), (int)next.x, SZ(v[distance(v.begin(), max_element(ALL(v)))])) && v[(int)next.y][(int)next.x] == INF)\n\t\t\t{\n\t\t\t\tv[(int)next.y][(int)next.x] = next.depth;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn v[(int)g_y][(int)g_x];\n}\n\n// 累積和\nvector<ll> cumulative_sum(vector<ll> a)\n{\n\tvector<ll> v(SZ(a) + 1);\n\tv[0] = 0;\n\tREP(i, SZ(a))\n\t{\n\t\tv[i + 1] = v[i] + a[i];\n\t}\n\treturn v;\n}\n\n// 繰り返し二乗法 a^n\nll iterativePower(ll a, ll n)\n{\n\tll res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)\n\t\t\tres = (res * a) % MOD;\n\t\ta = a * a % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\n// MODの逆元\nvector<ll> MODInverse(ll n, ll factN)\n{\n\tvector<ll> res(n + 1);\n\tres[n] = iterativePower(factN, MOD - 2);\n\tREPR(i, n - 1)\n\t{\n\t\tres[i] = res[i + 1] * (i + 1) % MOD;\n\t}\n\treturn res;\n}\n\n// 階乗\nvoid factorialFunc(ll n)\n{\n\tfactorial.pb(1);\n\tFOR(i, 1, n + 1)\n\t{\n\t\tfactorial.pb(factorial[i - 1] * i % MOD);\n\t}\n\tvector<ll> fact;\n\tfact = MODInverse(n, factorial[n]);\n\n\tREP(i, n + 1)\n\t{\n\t\tfactorialInverse.pb(fact[i]);\n\t}\n}\n\n// 二項係数nCr\nll comb(ll n, ll r)\n{\n\tif (n < r)\n\t\treturn 0;\n\t//ll fact = factorial(n);\n\t//vector<ll> fact_inv;\n\t//fact_inv = MODInverse(n, fact);\n\treturn (factorial[n] * factorialInverse[r]) % MOD * factorialInverse[n - r] % MOD;\n}\n\n// 文字列を連続した文字ごとに分解\nvector<pair<char, ll>> decompose_str(string s)\n{\n\tvector<pair<char, ll>> moji_cnt;\n\tmoji_cnt.pb(mp(s[0], 0));\n\tREP(i, SZ(s))\n\t{\n\t\tif (moji_cnt.back().first == s[i])\n\t\t{\n\t\t\tmoji_cnt.back().second++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmoji_cnt.pb(mp(s[i], 1));\n\t\t}\n\t}\n\treturn moji_cnt;\n}\n\n// 解答のベクトル出力(空白区切り)\nvoid ans_vec(vector<ll> ans)\n{\n\tREP(i, SZ(ans))\n\t{\n\t\tcout << ans[i] << endl;\n\t}\n\t//cout << endl;\n}\n\n//\nvoid dinamic_programming(void)\n{\n}\n\n// 総和の公式：Σk\nll totalSumFirst(ll x, ll y)\n{\n\tx = x - 1;\n\treturn (y * (y + 1) - x * (x + 1)) / 2;\n}\n\n// 総和の公式：Σk^2\nll totalSumSecond(ll x, ll y)\n{\n\tx = x - 1;\n\treturn (y * (y + 1) * (2 * y + 1) - x * (x + 1) * (2 * x + 1)) / 6;\n}\n\n// 総和の公式：Σk^3\nll totalSumThird(ll x, ll y)\n{\n\treturn pow(totalSumFirst(x, y), 2);\n}\n\n// 約数\nvector<ll> makeDivisors(ll n)\n{\n\tvector<ll> divisors;\n\tfor (ll i = 1; i * i <= n; i++)\n\t{\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tdivisors.pb(i);\n\t\t\tif (i != n / i)\n\t\t\t{\n\t\t\t\tdivisors.pb(n / i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(ALL(divisors));\n\n\treturn divisors;\n}\n\n// 尺取り法\nll shakutori(vector<ll>& v, ll x)\n{\n\tll res = 0;\n\tll n = SZ(v);\n\n\tll sum = 0;\n\tll right = 0;\n\n\tREP(left, n)\n\t{\n\n\t\twhile (right < n && sum + v[right] <= x)\n\t\t{\n\t\t\tsum += v[right];\n\t\t\tright++;\n\t\t}\n\t\tres += (right - left);\n\n\t\tif (right == left)\n\t\t\tright++;\n\t\telse\n\t\t\tsum -= v[left];\n\t}\n\n\treturn res;\n}\n\n\nvector<bool> seen;\nvector<vector<ll>> pa;\n// 深さ優先探索\nvoid dfs(const Graph& g, ll x, ll& cnt)\n{\n\tseen[x] = true; // v を訪問済にする\n\tpa[x][0] = cnt;\n\tcnt++;\n\n\t// v から行ける各頂点 next_v について\n\tfor (auto next_x : g[x]) {\n\t\tif (seen[next_x]) continue; // next_v が探索済だったらスルー\n\t\tdfs(g, next_x, cnt); // 再帰的に探索\n\t}\n\tpa[x][1] = cnt;\n\tcnt++;\n}\n\n//\nvoid dfs_maze(vector<vector<ll>>& maps, ll row, ll col, ll& cnt) {\n\tif (rangeCheck(row, SZ(maps), col, SZ(maps[0])) && maps[row][col]) {\n\t\tmaps[row][col] = 0;\n\t\tREP(k, 8) {\n\t\t\tdfs_maze(maps, row + dy8[k], col + dx8[k], cnt);\n\t\t}\n\t}\n}\n\n// 幅優先探索\nvoid bfs()\n{\n}\n\n// bit全探索\nvoid bitFullSearch(ll n)\n{\n\tREP(bit, 1 << n)\n\t{\n\t\tvector<ll> vec;\n\t\tREP(i, n)\n\t\t{\n\t\t\tif (bit >> i & 1)\n\t\t\t{\n\t\t\t\tvec.pb(i);\n\t\t\t}\n\t\t}\n\t}\n}\n\n// 重複削除\nvector<ll> duplicateDeletion(vector<ll> vec)\n{\n\tsort(ALL(vec));\n\tvec.erase(unique(ALL(vec)), vec.end());\n\treturn vec;\n}\n\n// 文字列区切り\nvector<string> split(string s, string delim)\n{\n\tif (s.empty())\n\t\treturn {};\n\tif (delim.empty())\n\t\treturn { s };\n\tint start = 0;\n\tauto delim_pos = s.find(delim);\n\tvector<string> ret_v;\n\twhile (delim_pos != string::npos)\n\t{\n\t\tif (start != delim_pos)\n\t\t\tret_v.push_back(s.substr(start, delim_pos - start)); // 残り文字列の先頭が区切り文字列だった時はvectorに追加しない\n\t\tstart = delim_pos + delim.size();\n\t\tdelim_pos = s.find(delim, start);\n\t}\n\tif (start < s.size())\n\t\tret_v.push_back(s.substr(start)); // 最後の区切り文字以降に文字がある場合\n\treturn ret_v;\n}\n\n//\n// main関数\n//\n\nsigned\nmain()\n{\n\t//cin.tie(0);\n\t//ios::sync_with_stdio(false);\n\n\t// 変数（scala）取得\n\t//ll n;\n\t//cin >> n;\n\n\t// 変数（vector）取得\n\t// vector<ll> a;\n\t// a = INV(n);\n\t////m=2;\n\t//vector<vector<ll>> vec(n, vector<ll>(m));\n\t//vec = INV2(n, m);\n\n\t// vector<vector<ll>> a(3);\n\t// REP(i, a)\n\t// {\n\t// \tll tmp;\n\t// \tcin >> tmp;\n\t// \ta[0].pb(tmp);\n\t// }\n\t// REP(i, b)\n\t// {\n\t// \tll tmp;\n\t// \tcin >> tmp;\n\t// \ta[1].pb(tmp);\n\t// }\n\t// REP(i, c)\n\t// {\n\t// \tll tmp;\n\t// \tcin >> tmp;\n\t// \ta[2].pb(tmp);\n\t// }\n\n\t// 文字列取得\n\t// string s;\n\t// cin >> s;\n\n\t// 文字列（vector）取得\n\t// vector<string> str(n);\n\t// REP(i, n)\n\t// {\n\t// \tcin >> str[i];\n\t// }\n\n\t// グラフ取得\n\t//Graph g(n);\n\t//REP(i, k) {\n\t//\tll from, weight;\n\t//\tcin >> from >> weight;\n\t//\tg[from].pb(to);\n\t//\t//g[to].pb(from);\n\t//}\n\n\t// 迷路用string取得\n\t//vector<string> str(h);\n\t//REP(i, h) {\n\t// cin >> str[i];\n\t//}\n\n\t// 二項係数を計算する際に必要\n\n\t// factorialFunc(n);\n\n\t//\n\t// 実装部分\n\t//\n\n\tll n;\n\tstring t;\n\tcin >> n >> t;\n\tll n3 = pow(3, n);\n\tll cnt_s = 0, cnt_r = 0;\n\n\tvector<ll> table(n3, INF);\n\tREP(i, n3) {\n\t\tif (table[i] == INF) {\n\t\t\tll tmp = i;\n\t\t\tstring str;\n\t\t\tREPR(j, 11) {\n\t\t\t\tint keta = pow(3, j);\n\t\t\t\tint sho = tmp / keta;\n\t\t\t\tint amari = tmp % keta;\n\t\t\t\tstr.append(to_string(sho));\n\t\t\t\ttmp = amari;\n\t\t\t\t//if (!tmp)\tbreak;\n\t\t\t}\n\t\t\t//tmp = 0;\n\t\t\tREP(j, 12) {\n\t\t\t\tif (str[j] == '1')\tstr[j] = '2';\n\t\t\t\telse if (str[j] == '2')\tstr[j] = '1';\n\t\t\t\ttmp += pow(3, 11 - j) * (str[j] - '0');\n\t\t\t}\n\t\t\ttable[i] = tmp;\n\t\t\ttable[tmp] = i;\n\t\t}\n\t}\n\n\n\tdeque<ll> que;\n\tREP(i, n3) {\n\t\tque.pb(i);\n\t}\n\tvector<bool> chk(n3, true);\n\tREP(i, SZ(t)) {\n\t\tif (t[i] == 'S') {\n\t\t\tchk.assign(n3, true);\n\t\t\tREP(j, n3) {\n\t\t\t\tif (chk[j]) {\n\t\t\t\t\tll tmp = que.at(table[j]);\n\t\t\t\t\tque.erase(que.begin() + table[j]);\n\t\t\t\t\tque.insert(que.begin() + table[j], que.at(j));\n\t\t\t\t\tque.erase(que.begin() + j);\n\t\t\t\t\tque.insert(que.begin() + j, tmp);\n\t\t\t\t\tchk[j] = chk[table[j]] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tll tmp = que.back();\n\t\t\tque.pop_back();\n\t\t\tque.push_front(tmp);\n\t\t}\n\t}\n\n\tREP(i, n3) {\n\t\tll tmp = que.back();\n\t\tque.pop_back();\n\t\tcout << tmp << \" \";\n\t}\n\tcout << endl;\n\n\n\n\t//\n\t// 実装部分おわり\n\t//\n\n\t// 解答出力\n\t// cout << fixed << setprecision(10);\n\t// MSG(ans);\n\t//ans_vec(ans);\n\n\treturn 0;\n}\n\n//\n// memo\n//\n\n//for(ll i=0; i<n;i++)　// ループ\n//cout << << endl;\t// 出力\n//sort(ALL(a), greater<ll>()); // 降順\n// abs(k)\t// 絶対値\n// sqrt(n)\t// ルート\n// ceil(n)\t// 切り上げ\n// floor(n)\t// 切り捨て\n// round(n)\t// 四捨五入\n// map<ll, ll, greater<ll>> mp;\t// mapの降順\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<int(r);i++)\n#define rep(i,r) rng(i,0,r)\n#define rrng(i,l,r) for(int i=int(r)-1;i>=int(l);i--)\n#define rrep(i,r) rrng(i,0,r)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u>void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\nstring s;\nint ans[200005],pw[15],m;\nint pr[200005],nx[200005],ch[200005];\nint z(int x){\n\treturn (x+m)%m;\n}\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tint n;\n\tcin>>n;\n\tcin>>s;\n\tpw[0]=1;\n\tfor(int i=1;i<=n;i++)pw[i]=pw[i-1]*3;\n\tfor(int i=0;i<n;i++){\n\t\tm=pw[i+1];\n\t\trep(j,m){\n\t\t\tnx[j]=z(j+1);\n\t\t\tpr[j]=z(j-1);\n\t\t}\n\t\tint a=0,b=m/3,c=b*2;\n\t\trep(j,s.size()){\n\t\t\tif(s[j]=='R'){\n\t\t\t\ta=pr[a];\n\t\t\t\tb=pr[b];\n\t\t\t\tc=pr[c];\n\t\t\t}else{\n\t\t\t\tint pra=pr[a];\n\t\t\t\tint prb=pr[b];\n\t\t\t\tint prc=pr[c];\n\t\t\t\tpr[a]=prc;\n\t\t\t\tpr[b]=pra;\n\t\t\t\tpr[c]=prb;\n\t\t\t\tswap(b,c);\n\t\t\t}\n\t\t}\n\t\trep(j,m)ch[j]=0;\n\t\twhile(1){\n\t\t\ta=pr[a];\n\t\t\tch[a]=pw[i]*2;\n\t\t\tif(a==c)break;\n\t\t}\n\t\twhile(1){\n\t\t\tc=pr[c];\n\t\t\tch[c]=pw[i];\n\t\t\tif(b==c)break;\n\t\t}\n\t\trep(j,pw[n]){\n\t\t\tans[j]+=ch[z(j)];\n\t\t}\n\t}\n\trep(i,pw[n]){\n\t\tcout<<ans[i];\n\t\tif(i==pw[n]-1)cout<<endl;\n\t\telse cout<<' ';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e6+7, K = 12, RT = 6;\nint f[N], p3[N];\n\nvoid pre() {\n    p3[0] = 1;\n    for (int i=1; i<=K; i++)    p3[i] = p3[i-1]*3;\n\n    for (int i=0; i<N; i++) {\n        for (int k=0; k<K; k++) {\n            int d = (i/p3[k])%3;\n            if (d == 1)      f[i] += p3[k]*2;\n            else if (d == 2) f[i] += p3[k];\n        }\n    }\n\n}\n\nint aa[N], bb[N];\nvector<int> v[N];\nint asol[N];\nint temp[N];\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    pre();\n\n    int n;\n    string s;\n    cin>>n>>s;\n\n\n    int mx = p3[max(0, n-K)];\n    int my = p3[min(K, n)];\n    int all = p3[n];\n\n\n    for (int i=0; i<mx; i++)\n        for (int j=0; j<my; j++)\n            v[i].push_back(my*i + j);\n\n    for (int j=0; j<my; j++)    asol[j] = j;\n\n    for (char c: s) {\n        if (c == 'R')  {\n            for (int i=0; i<mx; i++)    temp[i] = v[i][asol[my-1]];\n\n            int st = asol[my-1];\n            for (int i=my-1; i>0; i--)    asol[i] = asol[i-1];\n            asol[0] = st;\n\n            for (int i=1; i<mx; i++)    v[i][asol[0]] = temp[i-1];\n            v[0][asol[0]] = temp[mx-1];\n        }\n        else {\n            for (int i=0; i<my; i++)\n                if (f[i] > i)\n                    swap(asol[i], asol[f[i]]);\n\n            for (int i=0; i<mx; i++)\n                if (f[i] > i)\n                    v[i].swap(v[f[i]]);\n        }\n\n//        for (int i=0; i<my; i++)    cout<<asol[i]<<\" \"; cout<<\":::\"<<endl;\n//        for (int i=0; i<my; i++)    cout<<v[0][i]<<\" \"; cout<<\"---\"<<endl;\n    }\n\n    for (int i=0; i<mx; i++)\n        for (int j=0; j<my; j++)\n            aa[i*my+j] = v[i][asol[j]];\n\n\n    for (int i=0; i<all; i++) bb[aa[i]] = i;\n    for (int i=0; i<all; i++) cout<<bb[i]<<\" \";\n    cout<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <string>\n#include <vector> \n#include <algorithm>\n#include <functional>\n#include <map>\n#include <queue>\n#include <cmath>\n#include <limits>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing P = pair<int,int>;\n\nint main() {\n  //input\n  int n;\n  cin >> n;\n  string t;\n  cin >> t;\n  \n  int arrcount = (int)pow(3,n);\n  int arr[arrcount];\n  rep(i,arrcount) arr[i] = i;\n  rep(i, t.length()) {\n    if(t[i] == 'S') {\n      //S\n\n      rep(i,arrcount) {\n        string s = \"\";\n        //cout << arr[i] << \"->\";\n        // to 3 shin\n        while(arr[i] > 0) {\n          int j = arr[i] % 3;\n          s = to_string(j) + s;\n          arr[i] = (arr[i] - j) / 3;\n        }\n        if(s == \"\") s = \"0\";\n        //cout << s << \"->\";\n        //translate\n        replace(s.begin(), s.end(), '2', 'x');\n        replace(s.begin(), s.end(), '1', '2');\n        replace(s.begin(), s.end(), 'x', '1');\n        //cout << s << \"->\";\n        // to 10 shin\n        int j = 1;\n        while(s.length()) {\n          //arr[i] += m[(char)s.substr(s.length()-1)] * j;\n          arr[i] += ((char)s.substr(s.length()-1)[0] - '0') * j;\n          s.erase(s.length()-1);\n          j *= 3;\n        }\n        //cout << arr[i] << \" \";\n        //cout << endl;\n      }\n    } else {\n      //R\n      rep(i,arrcount) {\n        arr[i]++;\n        if(arr[i] == arrcount) arr[i] = 0;\n      }\n      \n    }\n  }\n  \n  rep(i,arrcount) cout << arr[i] << \" \";\n  cout << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(long long i=0;i<(long long)N;i++)\nint N,x,y,pos,tri0,tri1,tri2,pw3[13]={1},A[1000001],salsa[531441];\nchar T[200001],sw[1000001];\nvoid OUT(long long x){if(x<0)putchar('-'),x=-x;if(x>=10)OUT(x/10);putchar(x%10+48);}\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nsigned main(void)\n{\n  x=scanf(\"%d %s\",&N,T+1);\n  replace(T+1,\"SS\",\"\");if(T[0]=='\\n')return 0;\n  rep(i,N)pw3[i+1]=3*pw3[i];\n  tri0=pw3[N],tri1=pw3[N/2],tri2=pw3[N-N/2];\n  rep(i,tri0)salsa[i]=salsa[i/3]*3+(3-i%3)%3;\n  rep(i,tri1)\n  {\n    x=i,pos=0;\n    rep(j,strlen(T+1))\n    {\n      if(T[j+1]=='S'){x=salsa[x];if(sw[pos]=='s')pos--;else sw[++pos]='s';}\n      if(T[j+1]=='R'){x++;if(x==tri1)sw[++pos]='r',x=0;}\n    }\n    rep(j,tri2)\n    {\n      y=j;\n      rep(k,pos){if(sw[k+1]=='s')y=salsa[y];else if(sw[k+1]=='r'){if((++y)==tri2)y=0;}}\n      A[i+j*tri1]=y*tri1+x;\n    }\n  }\n  rep(i,tri0)OUT(A[i]),putchar(' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nstatic inline int Pow(int a,int b){return b?Pow(a*a,b>>1)*(b&1?a:1):1;}\nint main()\n{\n  int N,now,len=0,A[1000001],B[600001];\n  char T[1000001],S[1000001];\n  now=scanf(\"%d %s\",&N,T);len=strlen(T);\n  int pw3=Pow(3,N),x=Pow(3,N>>1),y=Pow(3,N-(N>>1));\n  rep(i,pw3)B[i]=B[i/3]*3+(3-i%3)%3;\n  rep(i,x)\n  {\n    int temp=i;now=0;\n    rep(j,len)\n    {\n      if(T[j]=='S'){temp=B[temp];(S[now]=='S')?--now:S[++now]='S';}\n      else{++temp;if(temp==x)S[++now]='R',temp=0;}\n    }\n    rep(j,y)\n    {\n      int keep=j;\n      rep(k,now)\n      {\n        if(S[k+1]=='S')keep=B[keep];\n        else if(S[k+1]=='R'){if((++keep)==y)keep=0;A[i+j*x]=temp+keep*x;}\n      }\n    }\n  }\n  rep(i,pw3)printf(\"%d%c\",A[i],i+1==pw3?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class t> inline t read(t &x){\n\tchar c=getchar();bool f=0;x=0;\n\twhile(!isdigit(c)) f|=c=='-',c=getchar();\n\twhile(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\tif(f) x=-x;return x;\n}\ntemplate<class t,class ...A> inline void read(t &x,A &...a){\n\tread(x);read(a...);\n}\ntemplate<class t> inline void write(t x){\n\tif(x<0) putchar('-'),write(-x);\n\telse{if(x>9) write(x/10);putchar('0'+x%10);}\n}\n\nconst int N=3e5+5;\nint ch[N][3],n,m,t,cnt,ans[N];\nbool tg[N];\nchar s[N];\n\nvoid build(int x,int v,int fl,int pw){\n\tif(fl==n) return ;\n\tfor(int i=0;i<3;i++) ch[x][i]=fl+1<n?++cnt:v+i*pw,build(fl+1<n?cnt:v+i*pw,v+i*pw,fl+1,pw*3);\n}\n\nvoid dfs(int x,int v,int fl,int pw){\n\tif(tg[x]) swap(ch[x][1],ch[x][2]);\n\tif(fl==n){\n\t\tans[x]=v;\n\t\treturn ;\n\t}\n\tfor(int i=0;i<3;i++) tg[ch[x][i]]^=tg[x],dfs(ch[x][i],v+i*pw,fl+1,pw*3); tg[x]=0;\n}\n\nvoid upr(int x,int fl){\n\tif(tg[x]) swap(ch[x][1],ch[x][2]);\n\tif(fl==n) return ;\n\tfor(int i=0;i<3;i++) tg[ch[x][i]]^=tg[x]; tg[x]=0;\n\tswap(ch[x][1],ch[x][2]);\n\tswap(ch[x][0],ch[x][1]);\n\tupr(ch[x][0],fl+1);\n}\n\nvoid ups(){\n\ttg[m]^=1;\n}\n\nsigned main(){\n\tread(n);\n\tscanf(\"%s\",s+1);\n\tt=strlen(s+1);\n\tm=1; for(int i=1;i<=n;i++) m*=3;\n\tbuild(cnt=m,0,0,1);\n\tfor(int i=1;i<=t;i++) if(s[i]=='R') upr(m,0); else ups();\n\tdfs(m,0,0,1);\n\tfor(int i=0;i<m;i++) write(ans[i]),putchar(' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n  int k,x,y,z,zz,p,i;\n\tcin >>k;\n  string str;\n  cin >> str;\n\tx=1;\n\tzz=1;\n\tfor (i = 0; i < k; i++) {\n\t\tx=3*x;\n\t}\n vector<int> vec(x);\n vector<int> pic(k);\n for (i = 0; i < x; i++) {\n \t\tz=i;\n\t\t for (int j = 0; j < str.size(); j++) {\n\t\t\n    \t\tif (str.at(j) == 'R') {\n    \t\t\t  z=z+1;\n   \t\t }\n\t\telse if (str.at(j) == 'S') {\n\t\t\ty=z;\n    \t\t\t  for( p = 0; p < k; p++){\n\t\t\t\tpic.at(p)=y%3;\n\t\t\t\ty=y/3;\n\t\t\t}\n\t\t\t\tfor(p = 0; p < k; p++){\n\t\t\t\t\tif(pic.at(p)==1){\n\t\t\t\t\tpic.at(p)=2;\n\t\t\t\t\t}\n\t\t\t\t\telse if(pic.at(p)==2){\n\t\t\t\t\tpic.at(p)=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tz=0;\n\t\t\tfor(p = 0; p < k; p++){\n\t\t\t\tz=z+zz*pic.at(p);\n\t\t\t\tzz=3*zz;\n\t\t\t}\n   \t\t }\n\ty=z%x;\n\tvec.at(i)=y;\n\t }\n  }\n  for ( i = 0; i < vec.size(); i++) {\n    cout << vec.at(i);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n// #include <ext/pb_ds/assoc_container.hpp> \n// #include <ext/pb_ds/detail/standard_policies.hpp>\n// using namespace __gnu_pbds;\n\n#pragma GCC optimize(\"O3\")\n#ifdef LOCAL\n#include \"/Users/lbjlc/Desktop/coding/debug_utils.h\"\n#else\n#define print(...) ;\n#define printn(...) ;\n#define fprint(...) ;\n#define fprintn(...) ;\n#endif\n\n#define rep(i, a, b) for(auto i = (a); i < (b); i++)\n#define rrep(i, a, b) for(auto i = (a); i > (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define pb push_back\n// #define mp make_pair\n#define fi first\n#define se second\n#define maxi(x, y) x = max(x, y)\n#define mini(x, y) x = min(x, y)\n// long long fact(long long n) { if(!n) return 1; return n*fact(n-1); }\n// #define endl '\\n'\n#define solve_testcase int T;cin>>T;for(int t=1;t<=T;t++){solve(t);}\n\n// long long gcd(long long x, long long y) { return y ? gcd(y, x % y) : x; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\n \ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n \ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\ntypedef vector<long long> vll;\n#define bd(type,op,val) bind(op<type>(), std::placeholders::_1, val)\n\nconst int MAXN = 1e6+10;\n\n\nvoid solve(int tt) {\n    // cout<<\"Case #\"<<tt<<\": \";\n}\n\nstring to_ter(int x, int k=-1) {\n    string res;\n    while(x) {\n        res+='0'+x%3;\n        x/=3;\n    }\n    if(k>=0) {\n        while(res.size()<k) res+='0';\n    }\n    return res;\n}\nint to_int(const string & s) {\n    int res=0;\n    // rrep(i,s.size()-1,-1)\n    //     res=res*3+(s[i]-'0');\n    for(int i=s.size()-1;i>=0;i--)\n        res=res*3+(s[i]-'0');\n    // print(s,res);\n    return res;\n}\nbool add(string & x, const string & y) {\n    int n1=x.size(), n2=y.size(),carry=0;\n    rep(i,0,n1) {\n        if(i<n1) carry+=x[i]-'0';\n        if(i<n2) carry+=y[i]-'0';\n        x[i]=carry%3+'0';\n        carry/=3;\n    }\n    return carry==0;\n}\n\nvi cal_inst(string & s) {\n    int n=s.size();\n    vi res(1);\n    int i=0;\n    while(i<n) {\n        if(s[i]=='R') {\n            res.back()++;\n            i++;\n        }\n        else {\n            int j=i;\n            for(;j<n&&s[j]=='S';j++);\n            if((j-i)%2) res.pb(0);\n            i=j;\n        }\n    }\n    if(s.back()=='S') res.pop_back();\n    return res;\n}\n\nchar rev(char c) {\n    if(c>'0') return '0'+(3-(c-'0'));\n    return c;\n}\nstring rev(string s) {\n    for(auto & c:s) c=rev(c);\n    return s;\n}\n\nint len(string & s) {\n    int res=s.size()-1;\n    while(res>=0&&s[res]=='0') res--;\n    return res+1;\n}\n\nint power[13]={};\nint revmap[MAXN]={};\nint tmpres[MAXN];\nint rev(int x) {\n    for(int flag=1;flag<power[12];flag*=3) {\n        int tmp=x/flag%3;\n        if(tmp==1) x+=flag;\n        else if(tmp==2) x-=flag;\n    }\n    return x;\n}\n\nvoid cal(vi inst, int n, int tot) {\n    // vi tmpres(tot,-1);\n    fill(tmpres,tmpres+tot,-1);\n\n    rep(i,0,tot) {\n        if(tmpres[i]>=0) continue;\n\n        int cur=i,ok=1;\n        for(auto x:inst) {\n            cur+=x;\n            if(cur>=power[n]) {\n                ok=0; \n                cur%=power[n];\n            }\n            cur=revmap[cur];\n        }\n        // if(i<=9) print(i,cur);\n        tmpres[i]=cur;\n        // assert(cur>=0);\n        if(!ok) continue;\n        int flag=1,tmp;\n        for(;flag<=i||flag<=cur;flag*=3);\n\n        if(inst.size()%2==0) {\n            for(tmp=flag;tmp<power[n];tmp+=flag) {\n                tmpres[tmp+i]=tmp+cur;\n            }\n        }\n        else {\n            for(tmp=flag;tmp<power[n];tmp+=flag) {\n                tmpres[tmp+i]=revmap[tmp]+cur;\n            }\n\n        }\n    }\n    // print(1);\n    // print(*max_element(all(res)),*min_element(all(res)));\n    // return res;\n}\n\nint main(int argc, char * argv[]) {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    // solve_testcase;\n\n    int n;\n    string s;\n    cin>>n;\n    cin>>s;\n\n    // n=12;\n    // rep(i,0,1e5) s+=\"RS\";\n\n    power[0]=1;\n    rep(i,1,13) power[i]=power[i-1]*3;\n\n    int tot=1;\n    rep(i,0,n) tot*=3;\n\n    rep(i,0,tot) {\n        if(i>=3) {\n            if(i%3==0)\n                revmap[i]=revmap[i/3]*3;\n            else\n                revmap[i]=revmap[i-i%3]+rev(i%3);\n        }\n        else\n            revmap[i]=rev(i);\n    }\n    // printn(revmap,9);\n\n\n    vi inst=cal_inst(s);\n    for(auto & x:inst) x%=tot;\n\n    // print(inst);\n\n    int i=0;\n    int bound=241;\n    vi res(tot);\n    iota(all(res),0);\n    while(i<inst.size()) {\n        int cur=inst[i];\n        vi cur_inst({cur});\n        for(++i;i<inst.size()&&cur+inst[i]<bound;i++) {\n            cur+=inst[i];\n            cur_inst.pb(inst[i]);\n        }\n        cal(cur_inst,n,tot);\n        // print(tmp);\n        rep(j,0,tot) res[j]=tmpres[res[j]];\n        // print(cur_inst,tmp);\n        // print(res);\n        // sort(all(tmp)); print(tmp);\n    }\n    if(s.back()=='R') {\n        rep(i,0,tot) {\n            res[i]=revmap[res[i]];\n        }\n    }\n    for(auto x:res) cout<<x<<' ';\n    cout<<endl;\n\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "        #include <bits/stdc++.h>\n        using namespace std;\n   #define int long long\nconst int MAX = 510000;\nconst int MOD = 1000000007;\n\n     signed main(){\n int n;\n string t;\n cin>>n>>t;\n int al2[t.size()]={};\n set<int> x[n][3];int y[n][3];\n int k=3;\n int kk=1;for(int i=0;i<n;i++)kk*=3;\n int ans[kk]={};\n\n for(int i=0;i<n;i++){\n      \n   for(int j=0;j<k;j++)x[i][j/(k/3)].insert(j);\n   y[i][0]=0;y[i][1]=1;y[i][2]=2;\n   for(int j=0;j<t.size();j++){\n        if(t[j]=='S'){swap(y[i][1],y[i][2]);continue;}\n        int h[3];\n        for(int q=0;q<3;q++){\n             for(int p=0;p<3;p++){\n                  auto it=x[i][y[i][q]].find(al2[j]+p*k/3);\n                  if(it!=x[i][y[i][q]].end()){\n                       h[q]=al2[j]+p*k/3;\n                       x[i][y[i][q]].erase(h[q]);\n                       break;\n                       \n\n                  }\n             }\n        }\n        for(int q=0;q<3;q++)x[i][y[i][(q+1)%3]].insert(h[q]);\n        al2[j]=h[2];\n   }\n\n \n   k*=3;\n\n }\n for(int i=0;i<kk;i++){\n      int aa=0;\n      int t=1;\n      for(int j=0;j<n;j++){\n           for(int q=0;q<3;q++)if(x[j][y[j][q]].find(i)==x[j][y[j][q]].end())aa+=t*q;\n           t*=3;\n      }\n      cout<<aa<<' ';\n }\n\n\n\n\n\n\n    }\n\n\n\n\n\n      \n\n        \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#define int long long\n\n#define pii pair<int, int>\n\n#define x1 x1228\n#define y1 y1228\n\n#define left left228\n#define right right228\n\n#define next next228\n\n#define pb push_back\n#define eb emplace_back\n\n#define mp make_pair                                                                \n                                                                                                                                        \n#define ff first                                                                  \n#define ss second   \n\n#define all(x) x.begin(), x.end()\n#define debug(x) cout << #x << \": \" << x << endl; \n#define TIME (ld)clock()/CLOCKS_PER_SEC\n\nusing namespace std;\ntypedef long long ll; \ntypedef long double ld; \n                                                                                                   \nconst int maxn = 2e5 + 7, mod = 1e9 + 7, MAXN = 1e6 + 7;\nconst double eps = 1e-9;\nconst ll inf = 1e18;\nmt19937 rnd(time(0));\nint n; \nstring s; \nint next[MAXN];\nconst int N = 2187; \nint dp1[N]; \nint dp2[N]; \nint xyz[N]; \n\nint get1(int mask, char q) {\n    if (q == 'R') {\n        ++mask; \n        return mask; \n    }   \n    int ptr = 1; \n    int ans = 0; \n    while (mask) {\n        int t = mask % 3; \n        mask /= 3; \n        if (t == 2) ans += ptr; \n        if (t == 1) ans += 2 * ptr; \n        ptr *= 3; \n    }\n    return ans; \n}\n\nconst int L = 12; \nint pref[maxn]; \nint to[maxn]; \nint kek1[N], kek2[N]; \nint res[N]; \nint add = 1; \n\nint get(int x) {\n    vector<int> bts; \n    for (int i = 0; i < L; ++i) {\n        bts.pb(x % 3); \n        x /= 3; \n    }\n    int left = 0;\n    int right = 0; \n    for (int i = 6; i >= 0; --i) {\n        left *= 3;\n        left += bts[i]; \n    }\n    for (int i = L - 1; i >= 7; --i) {\n        right *= 3; \n        right += bts[i]; \n    }\n    int id = 0; \n    if (left && dp1[left] == -1) {\n        return res[left] + add * right;   \n    }\n    if (left) {    \n        id = dp1[left]; \n        if (pref[id] & 1) right = xyz[right];             \n        left = 0; \n    }                     \n    while (next[id] != -1) {        \n        if ((pref[next[id]] - pref[id]) & 1) right = xyz[right]; \n        id = next[id];                                                                                                                                         \n    }\n    left = to[id]; \n    return left + right * add; \n}\n\nvoid solve() {\n    for (int i = 0; i < N; ++i) {\n        xyz[i] = get1(i, 'S') % N; \n    }\n\n    cin >> n >> s; \n    int t = s.size(); \n    for (int i = 0; i < N; ++i) {        \n        res[i] = i; \n        for (int j = 0; j < t; ++j) {\n            if (s[j] == 'S') res[i] = xyz[res[i]]; \n            else res[i] = (res[i] + 1) % N; \n        } \n    }\n    for (int i = 0; i < t; ++i) {\n        pref[i + 1] = pref[i] + (s[i] == 'S'); \n    }\n\n    for (int i = 0; i < N; ++i) dp1[i] = dp2[i] = -1; \n    next[t] = -1;\n    for (int i = 0; i < N; ++i) kek1[i] = i;              \n    for (int i = t - 1; i >= 0; --i) {\n        for (int mask = 0; mask < N; ++mask) {\n            int mask1; \n            if (s[i] == 'S') mask1 = xyz[mask]; \n            else mask1 = mask + 1; \n            if (mask1 >= N) mask1 -= N;                 \n            kek2[mask] = kek1[mask1];\n            if (mask && mask1 == 0) {\n                dp2[mask] = i + 1; \n            } else {\n                dp2[mask] = dp1[mask1]; \n            }   \n        }\n        to[i] = kek2[0]; \n        next[i] = dp2[0]; \n        for (int mask = 0; mask < N; ++mask) {\n            kek1[mask] = kek2[mask]; \n            dp1[mask] = dp2[mask]; \n            dp2[mask] = -1; \n        }\n    }\n    for (int i = 0; i < 7; ++i) add *= 3; \n    int tet = 1; \n    for (int i = 0; i < n; ++i) tet *= 3; \n    for (int ptr = 0; ptr < tet; ++ptr) {\n//        get(ptr); \n        cout << get(ptr) % tet << \" \"; \n    }\n    cout << TIME; \n    return; \n}                                \n   \nsigned main() {\n#ifdef LOCAL\n    freopen(\"TASK.in\", \"r\", stdin);\n    freopen(\"TASK.out\", \"w\", stdout);\n#else \n    \n#endif // LOCAL\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20); \n    cout << fixed; \n    int t = 1; \n    for (int i = 0; i < t; ++i) {              \n        solve();\n    }\n    return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\ncs int N = 2e6 + 50;\nint n, p[N]; char S[N];\nint ch[N][3], tag[N], vl[N], nd, pw[20];\nint build(int d, int v){\n\tif(!d) return vl[++nd]=v, nd; int x=++nd;\n\tch[x][0]=build(d-1, v);\n\tch[x][1]=build(d-1, v + pw[n-d]);\n\tch[x][2]=build(d-1, v + 2 * pw[n-d]); return x;\n}\nvoid put(int x){ if(!x) return; tag[x] ^= 1; swap(ch[x][1],ch[x][2]); }\nvoid down(int x){ if(tag[x]) put(ch[x][0]),put(ch[x][1]),put(ch[x][2]),tag[x]=0; }\nvoid work(int x, int d){\n\tif(!d) return;\n\tdown(x); int v = ch[x][2]; ch[x][2] = ch[x][1]; \n\tch[x][1] = ch[x][0]; ch[x][0] = v; \n\twork(v,d-1);\n}\nvoid dfs(int x, int d, int v=0){\n\tif(!d) return p[vl[x]] = v, void();\n\tdown(x); dfs(ch[x][0],d-1,v);\n\tdfs(ch[x][1],d-1,v + pw[n-d]);\n\tdfs(ch[x][2],d-1,v + 2 * pw[n-d]);\n}\nint main(){\n\t#ifdef FSYolanda\n\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tscanf(\"%d\",&n); pw[0]=1;\n\tfor(int i=1; i<=n; i++) pw[i]=pw[i-1]*3;\n\tscanf(\"%s\",S); int m=strlen(S);\n\tbuild(n,0);\n\tfor(int i=0; i<m; i++){\n\t\tif(S[i]=='R') work(1,n);\n\t\tif(S[i]=='S') put(1);\n\t} dfs(1,n); \n\tfor(int i=0; i<pw[n]; i++) cout << p[i] << \" \";\n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\ntypedef long long LL;\nconst LL sz=pow(3,12);\nint N,th,y;\nLL P[sz],x,t[12]={0},TRI;\nvoid init(){for(LL i=0;i<sz;i++)P[i]=i;}\nint compare(const int*a,const int*b){if(*a<*b)return -1;else if(*a==*b)return 0;else return 1;}\ninline LL IN(void)\n{\n  LL x=0;short f=0,c=getchar();\n  while(c<48||c>57)f^=c==45,c=getchar();\n  while(c>47&&c<58)x=x*10+c-48,c=getchar();\n  return f?-x:x;\n}\nvoid sal()\n{\n  for(LL trit=0;trit<TRI;trit++)\n  {\n    x=P[trit];y=0;\n    for(int i=0;i<12;i++)\n    {\n      y++;t[i]=x%3;\n      if(t[i]==1)t[i]=2;else if(t[i]==2)t[i]=1;else t[i]=0;\n      if(x<3)break;\n      x/=3;\n    }\n    x=0;\n    for(int i=0;i<y;i++)x+=t[i]*pow(3,i);\n    if(x==TRI)x=0;\n    P[trit]=x;\n  }\n}\nvoid rum()\n{\n  for(int trit=0;trit<TRI;trit++)\n  {\n    P[trit]++;if(P[trit]==TRI)P[trit]=0;\n  }\n}\nsigned main(void)\n{\n  char c,S[2000000];\n  LL i,j;init();N=IN();\n  i=scanf(\"%s\",S);TRI=pow(3,N);j=strlen(S);\n  for(i=0;i<j;i++)\n  {\n    if(S[i]=='R')rum();\n    else sal();\n  }\n  for(i=0;i<TRI;i++)printf(\"%lld \",P[i]);\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define trav(x,a) for (const auto& x: a)\n#define sz(x) (int)(x).size()\n#define all(x) (x).begin(), x.end()\n#define mem(a,v) memset((a), (v), sizeof (a))\n#define enl printf(\"\\n\")\n#define case(t) printf(\"Case #%d: \", (t))\n#define ni(n) scanf(\"%d\", &(n))\n#define nl(n) scanf(\"%lld\", &(n))\n#define nai(a, n) for (int _i = 0; _i < (n); _i++) ni(a[_i])\n#define nal(a, n) for (int _i = 0; _i < (n); _i++) nl(a[_i])\n#define pri(n) printf(\"%d\\n\", (n))\n#define prl(n) printf(\"%lld\\n\", (n))\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define vii vector<pii>\n#define vll vector<pll>\n#define vi vector<int>\n#define vl vector<long long>\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef cc_hash_table<int,int,hash<int>> ht;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> oset;\nconst double pi = acos(-1);\nconst int mod = 1e9 + 7;\nconst int inf = 1e9 + 7;\nconst int N = 1e6 + 5;\nconst double eps = 1e-9;\nchar s[N];\nint cur[N], fin[N], X[N], pref[N], lst[13][N];\n\nint pw(int x, int y) {\n  int r = 1;\n  for (; y; y /= 2, x *= x)\n    if (y & 1)\n      r *= x;\n  return r;\n}\n\nint main() {\n  int n; scanf(\"%d\", &n); int nn = pw(3, n);\n  scanf(\"%s\", s+1);\n  int m = strlen(s+1);\n  for (int i = 1; i <= m; i++) {\n    lst[0][i] = 0;\n    pref[i] = pref[i-1] + (s[i] == 'S');\n  }\n  auto get = [&](int i, int j) {\n    int cnt = (pref[j] - pref[X[i]]) % 2; X[i] = j;\n    return cur[i] = (cur[i] ^ (3 * cnt)) % 3;\n  };\n  for (int i = 3, it = 1; i <= nn; i *= 3, it++) {\n    for (int j = 0; j < i; j++)\n      cur[j] = j / (i / 3), X[j] = 0;\n    lst[it][0] = i-1;\n    for (int j = 1; j <= m; j++) {\n      for (int u = lst[it-1][j-1]; u < i; X[u] = j, u += i / 3) {\n        get(u, j-1);\n        if (s[j] == 'R')\n          (cur[u] += 1) %= 3;\n        else\n          (cur[u] ^= 3) %= 3;\n      }\n      for (int u = lst[it-1][j]; u < i; u += i / 3)\n        if (get(u, j) == 2)\n          lst[it][j] = u;\n    }\n    for (int j = 0; j < nn; j++)\n      fin[j] += get(j % i, m) * (i / 3);\n  }\n  for (int i = 0; i < nn; i++)\n    printf(\"%d \", fin[i]);\n  enl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 9e6;\n\nint n;\nstruct {\n    int v;\n    int tag;\n} t[N];\n\nvoid build(int p, int v, int d) {\n    if (d > n) return;\n    t[p].v = v;\n    for (int i = 0; i < 3; i++) {\n        build(p * 3 + i, i, d + 1);\n    }\n}\n\nvoid pushdown(int p) {\n    for (int i = 0; i < 3; i++) {\n        t[p * 3 + i].tag += t[p].tag;\n    }\n    if (t[p].tag & 1 && t[p].v) {\n        t[p].v ^= 3;\n    }\n    t[p].tag = 0;\n}\n\nvoid update(int p, int d) {\n    if (d > n) return;\n    for (int i = 0; i < 3; i++) {\n        int x = p * 3 + i;\n        pushdown(x);\n        t[x].v++;\n        if (t[x].v == 3) {\n            t[x].v = 0;\n            update(x, d + 1);\n        }\n    }\n}\n\nint query(int p, int x, int d) {\n    if (d > n) return 0;\n    pushdown(p);\n    int res = t[p].v;\n    return query(p * 3 + x % 3, x / 3, d + 1) * 3 + res;\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\n    cin >> n;\n    string s;\n    cin >> s;\n    build(1, 0, 0);\n\n    for (auto c : s) {\n        if (c == 'S') {\n            t[1].tag++;\n        }\n        else {\n            pushdown(1);\n            update(1, 0);\n        }\n    }\n    int t = 1;\n    for (int i = 1; i <= n; i++) t *= 3;\n    for (int i = 0; i < t; i++) cout << query(1, i, 0) / 3 << ' ';\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 3e6+10;\nint n,m,pw[N];\nchar s[N];\n\nint cnt,son[N][3],p[N];\ninline void dfs(int u,int dep,int x){\n\tif (dep==n) return p[u]=x,void(0);\n\tson[u][0]=++cnt,dfs(son[u][0],dep+1,x);\n\tson[u][1]=++cnt,dfs(son[u][1],dep+1,x+pw[dep]);\n\tson[u][2]=++cnt,dfs(son[u][2],dep+1,x+2*pw[dep]);\n}\n\nint tag[N];\ninline void upd(int u){\n\tswap(son[u][1],son[u][2]),tag[u]^=1;\n}\ninline void push_down(int u){\n\tif (!tag[u]) return;\n\tFOR(i,0,3) upd(son[u][i]);\n\ttag[u]=0;\n}\ninline void dfs(int u,int dep){\n\tif (dep==n) return;\n\tpush_down(u);\n\tint tmp=son[u][2];\n\tson[u][2]=son[u][1],son[u][1]=son[u][0],son[u][0]=tmp;\n\tdfs(son[u][0],dep+1);\n}\n\nint ans[N];\ninline void print(int u,int dep,int x){\n\tif (dep==n) return ans[p[u]]=x,void(0);\n\tpush_down(u);\n\tprint(son[u][0],dep+1,x);\n\tprint(son[u][1],dep+1,x+pw[dep]);\n\tprint(son[u][2],dep+1,x+2*pw[dep]);\n}\n\nint main(){\n\tn=read(),scanf(\"%s\",s+1),m=strlen(s+1);\n\tpw[0]=1;\n\tFor(i,1,n) pw[i]=pw[i-1]*3;\n\tdfs(0,0,0);\n\tFor(i,1,m){\n\t\tif (s[i]=='S') upd(0);\n\t\t\telse dfs(0,0);\n\t}\n\tprint(0,0,0);\n\tFOR(i,0,pw[n]) printf(\"%d \",ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,x,y,sw,pw3=1,A[531441],B[531441],S[200001];\nchar T[200001];\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nsigned main(void)\n{\n  x=scanf(\"%d %s\",&N,T);\n  replace(T,\"SS\",\"\");if(T[0]=='\\n')return 0;\n  rep(i,N)\n  {\n    rep(j,pw3)rep(k,3)B[j+k*pw3]=k;sw=0;\n    rep(j,strlen(T))\n    {\n      if(T[j]=='R')\n      {\n        y=S[j];\n        rep(k,3){x=y+k*pw3;if(B[x]+sw==2)S[j]=x;B[x]+=sw+1;B[x]%=3;}\n      }\n      if(T[j]=='S')sw^=1;\n    }\n    rep(j,pw3){y=A[j];rep(k,3){x=j+k*pw3;A[x]=y+(sw?3-B[x]:B[x])%3*pw3;}}\n    pw3*=3;\n  }\n  rep(i,pw3)printf(\"%d%c\",A[i],i+1==pw3?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\nstring T;\nusing pvv=pair<vector<int>,vector<int>>;\n\nvoid update(int,int&,int&);\npvv createbit(int);\n\nint main(){\n    int N;\n    cin >> N >> T;\n    pvv ans = createbit(N);\n    for(int x:ans.first){\n        cout << x << \" \";\n    }\n    cout << endl;\n}\n\n\nvoid update(int q,int &last,int &next){\n    if(next!=0&&last%2!=q%2)next=3-next;\n    last=q;\n}\n\n\npvv createbit(int N){\n    if(N==0){\n        pvv send;\n        send.first={0};\n        send.second=vector<int>(T.size(),0);\n        return send;\n    }\n    pvv receve = createbit(N-1);\n    pvv send;\n    int pot = (int)receve.first.size();\n    send.first=vector<int>(pot*3,0);\n    send.second=vector<int>(T.size());\n    vector<int>next(pot*3);\n    int q=0;\n    vector<int>last(pot*3,0);\n    for(int i=0;i<3;i++)for(int x=pot*i;x<pot*(i+1);x+=1)next[x]=i;\n    \n    \n    \n    for(int i=0;i<T.size();i++){\n        if(T[i]=='S'){\n            q++;\n            continue;\n        }\n        \n        int k=receve.second[i];\n        \n        for(int x=k;x<pot*3;x+=pot){\n            update(q, last[x], next[x]);\n            \n            if(next[x]==2)send.second[i]=x;\n        }\n        \n        for(int x=k;x<=pot*3;x+=pot)next[x]=(next[x]+1)%3;\n        \n    }\n    \n    for(int i=0;i<pot*3;i++){\n        update(q, last[i], next[i]);\n        send.first[i]=receve.first[i%pot]+next[i]*pot;\n    }\n    \n    return send;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#include <list>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nint n;\nstring t;\nint ans[1000010];\nint p[14];\nvoid solve(int k, int d, int x, int y, string s){\n    string s1;\n    for(int i=0; i<s.size(); i++){\n        if(s[i]=='S'){\n            if(d!=0) d=3-d;\n            if(!s1.empty() && s1.back()=='S') s1.pop_back();\n            else s1+='S';\n        }else{\n            if(d==2) s1+='R', d=0;\n            else d++;\n        }\n    }\n    y+=p[k]*d;\n    if(k==n-1){\n        ans[x]=y;\n        return;\n    }\n    for(int i=0; i<3; i++){\n        solve(k+1, i, x+p[k+1]*i, y, s1);\n    }\n}\nint main()\n{\n    cin>>n>>t;\n    p[0]=1;\n    for(int i=1; i<=n; i++) p[i]=p[i-1]*3;\n    for(int i=0; i<3; i++) solve(0, i, i, 0, t);\n    for(int i=0; i<p[n]; i++) cout<<ans[i]<<\" \";\n    cout<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nusing P = pair<ll, ll>;\n#define rep(i, n)  for (int i = 0; i <  (int)(n); i++)\n#define rep1(i, n) for (int i = 1; i <= (int)(n); i++)\n#define all(x) (x).begin(), (x).end()\nconst ll INF = ll(1e18)+1;\n\nll sarusa(ll target,ll n){\n    ll result = 0;\n    rep(i,n){\n        ll powre = pow(3,n-i-1);\n        if(target / powre == 1){\n            result += powre * 2;\n        }\n        else if(target / powre == 2){\n            result += powre * 1;\n        }\n        target %= powre;\n    }\n    return result;\n}\n\nstring asshuku(string target){\n    ll count = 0;\n    string result = \"\";\n    rep(i,target.size()){\n        if(target[i] == *\"R\"){\n            if(count == 0){\n                result += \"R\";\n            }\n            else if(count % 2 != 0){\n                result += \"SR\";\n                count = 0;\n            }\n            else{\n                result += \"R\";\n                count = 0;\n            }\n        }\n        else{\n            count++;\n        }\n    }\n    return result;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n;\n    string t;\n    cin >> n >> t;\n    t = asshuku(t);\n    // cout << t << \"\\n\";\n\n    vector<ll> result(pow(3,n));\n    vector<ll> hyo(pow(3,n));\n    rep(i,pow(3,n)){\n        hyo[i] = sarusa(i,n);\n        result[i] = i;\n    }\n\n    rep(i,t.size()){\n        // cout << t[i];\n        if(t[i] == *\"S\"){\n            rep(i,pow(3,n)){\n                result[i] = hyo[result[i]];\n                // cout << result[i] << \":\" << hyo[result[i]] << \"\\n\";\n            }\n        }\n        else{\n            rep(i,pow(3,n)){\n                result[i]++;\n                if(result[i] == pow(3,n)){\n                    result[i] = 0;\n                }\n            }\n        }\n        // rep(i,pow(3,n)){\n        //     cout << result[i] << \" \";\n        // }\n        // cout << \"\\n\";\n    }\n    \n    rep(i,pow(3,n)){\n        cout << result[i] << \" \";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nconst int N = 1000005;\n\nint n, q;\nchar op[N];\n\nint pw[13];\n\nint ans[N];\n\nstruct Trie {\n\tint rt, cnt, son[N][3], id[N];\n\tbool tag[N];\n\n\tvoid build(int &u, int d, int v) {\n\t\tu = ++cnt, tag[u] = 0;\n\t\tif (d == n) {\n\t\t\tid[u] = v;\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tbuild(son[u][i], d + 1, v + i * pw[d]);\n\t\t}\n\t}\n\n\tvoid rev(int u) {\n\t\tstd::swap(son[u][1], son[u][2]);\n\t\ttag[u] ^= 1;\n\t}\n\n\tvoid down(int u) {\n\t\tif (tag[u]) {\n\t\t\trev(son[u][0]), rev(son[u][1]), rev(son[u][2]);\n\t\t\ttag[u] = 0;\n\t\t}\n\t}\n\n\tvoid add(int u) {\n\t\tif (!son[u][0]) {\n\t\t\treturn;\n\t\t}\n\t\tdown(u);\n\t\tint t = son[u][2];\n\t\tson[u][2] = son[u][1];\n\t\tson[u][1] = son[u][0];\n\t\tson[u][0] = t;\n\t\tadd(son[u][0]);\n\t}\n\n\tvoid getans(int u, int d, int v) {\n\t\tif (d == n) {\n\t\t\tans[id[u]] = v;\n\t\t\treturn;\n\t\t}\n\t\tdown(u);\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tgetans(son[u][i], d + 1, v + i * pw[d]);\n\t\t}\n\t}\n} T;\n\nint main() {\n\tread(n);\n\tq = readStr(op + 1);\n\tpw[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tpw[i] = pw[i - 1] * 3;\n\t}\n\tT.build(T.rt, 0, 0);\n\tfor (int i = 1; i <= q; ++i) {\n\t\tif (op[i] == 'S') {\n\t\t\tT.rev(T.rt);\n\t\t} else {\n\t\t\tT.add(T.rt);\n\t\t}\n\t}\n\tT.getans(T.rt, 0, 0);\n\tfor (int i = 0; i < pw[n]; ++i) {\n\t\tprint(ans[i], ' ');\n\t}\n\tputchar('\\n');\n}\n"
  },
  {
    "language": "C++",
    "code": "#define MST(a, b) memset(a,b,sizeof(a))\n#define ALL(v) (v).begin(),(v).end()\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<LL,LL> pll;\n#include <ext/pb_ds/priority_queue.hpp>\n#define rep(i,a,b) for(int i = (a) ; i <= (b) ; ++i)\n#define per(i,a,b) for(int i = (a) ; i >= (b) ; --i)\n#define fors(i,S) for(int i = (S) ; i ; i = (i-1)&(S))\n#define forn(i,n) for(int i = 0 ; i < (n) ; ++i)\n\nusing namespace __gnu_pbds;\n//typedef __gnu_pbds::priority_queue<pii, greater<pii>, pairing_heap_tag> heap;\n//typedef heap::point_iterator iter;\ntypedef unsigned long long ULL;\n//typedef __int128 LL128;\nmt19937_64 mt(chrono::steady_clock::now().time_since_epoch().count());\n\nint system_const;\nnamespace fast_IO{\n    const int maxbuff = 1<<17;\n    char ibuff[maxbuff],obuff[maxbuff];\n    inline char Getchar(){\n        static char *p1=ibuff,*p2=ibuff;\n        if(p1 == p2) {\n            p1 = ibuff;\n            p2 = ibuff+fread(ibuff,1,maxbuff,stdin);\n            if(p1 == p2) return -1;\n        }\n        return *p1++;\n    }\n\n    int optr = 0;\n    inline void Putchar(char c) {\n        if(optr == maxbuff) {fwrite(obuff,1,optr,stdout);optr = 0;}\n        obuff[optr++] = c;\n    }\n\n    inline void Flush() {\n        fwrite(obuff,1,optr,stdout);\n    }\n\n    template<class T>\n    void read_number(T &x) {\n        x = 0;\n        char c;int f = 0;\n        for(c = Getchar() ; c != '-' && (c < '0' || c > '9') ; c = Getchar());\n        if(c == '-') f = 1;\n        else x = c-'0';\n        for(c = Getchar() ; c >= '0' && c <= '9' ; c = Getchar()) x = x*10+c-'0';\n        if(f) x = -x;\n    }\n\n    void read_string(string &s) {\n        s.clear();\n        char c;\n        for(c = Getchar() ; c == ' ' || c == '\\n' ; c = Getchar());\n        s.push_back(c);\n        for(c = Getchar() ; c != ' ' && c != '\\n' ; c = Getchar())\n            s.push_back(c);\n    }\n\n    template<class T>\n    void write_number(T &x) {\n        static int dec[20];int len = 0;\n        if(x == 0) {Putchar('0');return ;}\n        if(x < 0) {Putchar('-');x = -x;}\n        while(x) {\n            dec[++len] = x%10;\n            x /= 10;\n        }\n        while(len) Putchar(dec[len--]+'0');\n    }\n\n    void write_string(const string &s) {\n        for(int i = 0 ;i < s.size() ; ++i)\n            Putchar(s[i]);\n    }\n}\nvoid read(string &s) {\n    if(system_const == 0) {\n        using namespace fast_IO;\n        read_string(s);\n    }\n    else cin >> s;\n}\ntemplate<class T> void read(T &x) {\n    if(system_const == 0) {\n        using namespace fast_IO;\n        read_number(x);\n    }\n    else cin >> x;\n}\nvoid write(const string &s) {\n    if(system_const == 0) {\n        fast_IO::write_string(s);\n    }\n    else cout << s;\n}\ntemplate<class T> void write(T &x) {\n    if(system_const == 0) {\n        fast_IO::write_number(x);\n    }\n    else cout << x;\n}\nvoid writeln(const string &s) {\n    write(s);\n    if(system_const == 0) {\n        using namespace fast_IO;\n        Putchar('\\n');\n    }\n    else cout << endl;\n}\ntemplate<class T> void writeln(T x) {\n    write(x);\n    if(system_const == 0) {\n        using namespace fast_IO;\n        Putchar('\\n');\n    }\n    else cout << '\\n';\n}\nvoid writesp(const string &s) {\n    write(s);\n    if(system_const == 0) {\n        using namespace fast_IO;\n        Putchar(' ');\n    }\n    else cout << ' ';\n}\n\ntemplate<class T> void writesp(T x) {\n    write(x);\n    if(system_const == 0) {\n        using namespace fast_IO;\n        Putchar(' ');\n    }\n    else cout << ' ';\n}\nvoid set_program_type(int t = 0) {\n    system_const = t;\n    if(t) {\n        ios::sync_with_stdio(0);\n        cin.tie(0);cout.tie(0);\n    }\n}\nvoid finish_program(int t = 0) {\n    if(!t) fast_IO::Flush();\n}\n\nvoid init_all(int t = 0,string s = \"output\") {\n#ifdef LOCAL\n    if ((t >> 1) & 1) freopen(\"input\", \"r\", stdin);\n    if ((t >> 2) & 1) freopen(s.c_str(), \"w\", stdout);\n#endif\n}\n\ntemplate <int MOD=998244353, class T = int> struct Modular {\n    T value;\n    static const T MOD_value = MOD;\n\n    Modular(T v = 0) { value = v % MOD; if (value < 0) value += MOD;}\n    Modular(T a, T b) : value(0){ *this += a; *this /= b;}\n\n    Modular& operator+=(Modular const& b) {value += b.value; if (value >= MOD) value -= MOD; return *this;}\n    Modular& operator-=(Modular const& b) {value -= b.value; if (value < 0) value += MOD;return *this;}\n    Modular& operator*=(Modular const& b) {value = (long long)value * b.value % MOD;return *this;}\n\n    friend Modular mexp(Modular a, long long e) {\n        Modular res = 1; while (e) { if (e&1) res *= a; a *= a; e >>= 1; }\n        return res;\n    }\n    friend Modular inverse(Modular a) { return mexp(a, MOD - 2); }\n\n    Modular& operator/=(Modular const& b) { return *this *= inverse(b); }\n    friend Modular operator+(Modular a, Modular const &b) { return a += b; }\n    friend Modular operator-(Modular a, Modular const &b) { return a -= b; }\n    friend Modular operator-(Modular const &a) { return 0 - a; }\n    friend Modular operator*(Modular a, Modular const &b) { return a *= b; }\n    friend Modular operator/(Modular a, Modular const &b) { return a /= b; }\n    friend std::ostream& operator<<(std::ostream& os, Modular const& a) {return os << a.value;}\n    friend bool operator==(Modular const& a, Modular const& b) {return a.value == b.value;}\n    friend bool operator!=(Modular const& a, Modular const& b) {return a.value != b.value;}\n\n};\n\n\n\nint pre_ask_time;\nvoid show_time() {\n    int now = clock();\n    cout << now-pre_ask_time << endl;\n    pre_ask_time = now;\n}\n\ntemplate<class T> void cmin(T &x,const T&y) {if(x > y) x = y;}\ntemplate<class T> void cmax(T &x,const T&y) {if(x < y) x = y;}\n\nstruct Vector{\n    LL x,y;\n    Vector(LL x = 0,LL y = 0):x(x),y(y){}\n    friend LL operator *(const Vector &A,const Vector &B) {return A.x*B.x+A.y*B.y;}\n    friend Vector operator - (const Vector &A,const Vector &B) {return Vector(B.x-A.x,B.y-A.y);}\n    friend LL operator /(const Vector &A,const Vector &B) {return A.x*B.y-A.y*B.x;}\n};\n\nconst int N = 12+5;\nstring s;\nint n,pw[N];\nvector<string> f,g;\nvector<int> h,p;\nint get(int x,int l) {\n    return x % pw[l];\n}\n\nvoid add(string &s,char c) {\n    if(c == 'R') s.push_back(c);\n    else {\n        if(s.size() && s.back() == 'S') s.pop_back();\n        else s.push_back(c);\n    }\n}\n\nvoid solve() {\n    pw[0] = 1;\n    for(int i = 1 ; i <= 12 ; ++i) pw[i] = pw[i-1]*3;\n    cin >> n;\n    cin >> s;\n    f.push_back(s);\n    h.push_back(0);\n    for(int i = 1 ; i <= n ; ++i) {\n        g.resize(pw[i]);\n        p.resize(pw[i]);\n        for(int now = 0 ; now < pw[i] ; ++now) {\n            int cur = get(now,i-1);\n            p[now] = h[cur];\n            int d = now/pw[i-1]%3;\n            for(auto v : f[cur]) {\n                if(v == 'S') {\n                    d = (d<<1)%3;\n                    add(g[now],v);\n                }\n                else {\n                    if(d == 2) {\n                        d = 0;\n                        add(g[now],v);\n                    }\n                    else d += 1;\n                }\n            }\n            p[now] += d*pw[i-1];\n        }\n        h.clear();\n        f.clear();\n        swap(f,g);\n        swap(h,p);\n    }\n    for(int i = 0 ; i < pw[n] ; ++i)\n        cout << h[i] << ' ';\n    cout << endl;\n\n}\n\nsigned main() {\n    //srand((int)time(0));\n    pre_ask_time = clock();\n    init_all(3);\n\n    //init();\n    set_program_type(0);\n    int T = 1;\n    //read(T);\n    //cin >> T;\n    //scanf(\"%d\",&T);\n    rep(i,1,T) {\n        //printf(\"Case #%lld: \",i);\n        solve();\n    }\n\n    finish_program(0);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef vector<int> vi;\ntypedef pair<int, int> ii;\n\nclass TaskC {\n public:\n  int n;\n  string t;\n  int size;\n  vector<int> p3;\n  vector<int> flip;\n  vector<bool> inverted;\n  vector<vector<pair<int, int>>> dest;\n\n  pair<int, int> getJump(int when, int tail0, int before) {\n    if (when == t.size()) return {when, before * p3[tail0]};\n    int key = tail0 * 3 + before;\n    if (dest[when][key].first >= 0) return dest[when][key];\n    if (before == 0) {\n      if (tail0 == 0) {\n        int time = when;\n        while (time < t.size() && t[time] == 'S') ++time;\n        if (time == t.size()) {\n          dest[when][key] = {time, 0};\n          return dest[when][key];\n        } else {\n          dest[when][key] = {time + 1, -1};\n          return dest[when][key];\n        }\n      } else {\n        auto change = getJump(when, tail0 - 1, 0);\n        if (change.second >= 0) {\n          assert(change.first == t.size());\n          dest[when][key] = change;\n          return change;\n        }\n        int state = inverted[change.first] ? 2 : 1;\n        dest[when][key] = getJump(change.first, tail0 - 1, state);\n        if (tail0 == n && dest[when][key].second < 0) {\n          dest[when][key] = getJump(dest[when][key].first, tail0, 0);\n        }\n        return dest[when][key];\n      }\n    } else {\n      auto change = getJump(when, tail0, 0);\n      if (change.second >= 0) {\n        assert(change.first == t.size());\n        dest[when][key] = change;\n        dest[when][key].second += before * p3[tail0];\n        return dest[when][key];\n      }\n      if (inverted[change.first]) before = 3 - before;\n      ++before;\n      if (before == 3) {\n        dest[when][key] = change;\n        return change;\n      } else {\n        if (inverted[change.first]) before = 3 - before;\n        dest[when][key] = getJump(change.first, tail0, before);\n        return dest[when][key];\n      }\n    }\n  }\n\n  int get(int pos, int when) {\n    while (when < t.size()) {\n      int rem = pos;\n      int tail0 = 0;\n      while (rem % 3 == 0 && tail0 < n) {\n        ++tail0;\n        rem /= 3;\n      }\n      pos -= (rem % 3) * p3[tail0];\n      pair<int, int> jump = getJump(when, tail0, rem % 3);\n      when = jump.first;\n      if (jump.second >= 0) {\n        pos += jump.second;\n      } else {\n        if (inverted[when]) pos = flip[pos];\n        pos += p3[tail0 + 1];\n        if (pos >= size) pos -= size;\n        if (inverted[when]) pos = flip[pos];\n      }\n    }\n    return pos;\n  }\n\n  void solveOne(istream &in, ostream &out) {\n    in >> n;\n    in >> t;\n    size = 1;\n    p3 = vector<int>(n + 1);\n    p3[0] = 1;\n    for (int i = 0; i < n; ++i) {\n      size = size * 3;\n      p3[i + 1] = size;\n    }\n    inverted = vector<bool>(t.size() + 1);\n    for (int i = 0; i < t.size(); ++i) {\n      if (t[i] == 'S') inverted[i + 1] = !inverted[i]; else inverted[i + 1] = inverted[i];\n    }\n    flip = vector<int>(size);\n    for (int i = 0; i < size; ++i) {\n      flip[i] = flip[i / 3] * 3;\n      int r = i % 3;\n      if (r == 1) flip[i] += 2; else if (r == 2) ++flip[i];\n    }\n    dest = vector<vector<pair<int, int>>>(t.size(), vector<pair<int, int>>((n + 1) * 3, pair<int, int>(-1, -1)));\n    for (int i = 0; i < size; ++i) {\n      int res = get(i, 0);\n      if (inverted[t.size()]) res = flip[res];\n      out << res << \" \";\n    }\n    out << \"\\n\";\n  }\n\n  void solve(std::istream &in, std::ostream &out) {\n    int nt = 1;\n    for (int it = 0; it < nt; ++it) {\n      solveOne(in, out);\n    }\n  }\n};\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  TaskC solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n\n\n\n\n#include <algorithm>\n\n#include <array>\n\n#include <bitset>\n\n#include <cassert>\n\n#include <complex>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <iostream>\n\n#include <map>\n\n#include <numeric>\n\n#include <queue>\n\n#include <set>\n\n#include <string>\n\n#include <unordered_map>\n\n#include <unordered_set>\n\n#include <vector>\n\nusing namespace std;\n\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\nstruct Scanner {\n    FILE* fp = nullptr;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += fread(line + ed, 1, (1 << 15) - ed, fp);\n        line[ed] = '\\0';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) reread();\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == '-') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] - '0');\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(V<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    Scanner(FILE* _fp) : fp(_fp) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(' ');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single('\\n');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val; // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char('0' + (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const V<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(' ');\n            write_single(val[i]);\n        }\n    }\n};\n\nScanner sc = Scanner(stdin);\nPrinter pr = Printer(stdout);\n\nint main() {\n    int n;\n    sc.read(n);\n    int m = 1;\n    for (int i = 0; i < n; i++) {\n        m *= 3;\n    }\n    V<int> to(m);\n\n    for (int i = 0; i < m; i++) {\n        int base = 1;\n        int p = i, q = 0;\n        for (int j = 0; j < n; j++) {\n            int u = (p % 3);\n            if (u != 0) u = 3 ^ u;\n            q += base * u;\n            p /= 3;\n            base *= 3;\n        }\n        to[i] = q;\n                     ;\n    }\n    V<int> ans(1, 0);\n    V<string> que(1);\n    sc.read(que[0]);\n    for (int h = 1; h <= n; h++) {\n        int k = 1;\n        for (int i = 0; i < h; i++) {\n            k *= 3;\n        }\n        int pk = k / 3;\n        V<int> nans(k, 0);\n        V<string> nque(k);\n        for (int i = 0; i < k; i++) {\n            int pre = i % pk;\n            nans[i] = ans[pre];\n            int nw = i / pk;\n            for (char c: que[pre]) {\n                if (c == 'S') {\n                    if (nw == 1) nw = 2;\n                    else if (nw == 2) nw = 1;\n\n                    if (nque[i].size() && nque[i].back() == 'S') nque[i].pop_back();\n                    else nque[i] += 'S';\n\n                } else {\n                    nw++;\n                    if (nw == 3) {\n                        nque[i] += 'R';\n                        nw = 0;\n                    }\n                }\n            }\n            nans[i] += nw * pk;\n        }\n        ans = nans;\n        que = nque;\n    }\n    pr.writeln(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,o,p,x,y,pos,pw3[13]={1},A[1000000],salsa[555555],sw[1000000];\nchar T[200001];\nvoid OUT(int x){if(x<0)putchar('-'),x=-x;if(x>=10)OUT(x/10);putchar(x%10+48);}\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nvoid Dance(char c[])\n{\n  if(c[p]==EOF)return;\n  if(c[p]=='S'){x=salsa[x];if(sw[pos]>0)pos--;else sw[++pos]=1;}\n  if(c[p]=='R'){x++;if(x==pw3[N/2])sw[++pos]=-1,x=0;}\n}\nvoid Update(void)\n{\n  rep(i,pw3[N-N/2])\n  {\n    y=i;\n    rep(j,pos){if(sw[j+1]>0)y=salsa[y];else if(sw[j+1]<0){if((++y)==pw3[N-N/2])y=0;}}\n    A[o+i*pw3[N/2]]=y*pw3[N/2]+x;\n  }\n}\nsigned main(void)\n{\n  o=scanf(\"%d %s\",&N,T+1);\n  replace(T+1,\"SS\",\"\");if(T[0]=='\\n')return 0;\n  rep(i,N)pw3[i+1]=3*pw3[i];\n  rep(i,pw3[N])salsa[i]=salsa[i/3]*3+(3-i%3)%3;\n  rep(i,pw3[N/2]){o=i,x=i,pos=0;rep(j,strlen(T+1)){p=j+1,Dance(T);}Update();}\n  rep(i,pw3[N])OUT(A[i]),putchar(' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nstatic inline char CH()\n{\n  static char buf[100000],*ptr1=buf,*ptr2=buf;\n  return ptr1==ptr2&&(ptr2=(ptr1=buf)+fread(buf,1,100000,stdin),ptr1==ptr2)?EOF:*ptr1++;\n}\nstatic inline int IN(void)\n{\n  int x=0,f=0,c=CH();while(c<48||c>57){f^=c==45,c=CH();}\n  while(c>47&&c<58){x=x*10+c-48,c=CH();}return f?-x:x;\n}\nstatic inline int Pow(int a,int b){return b?Pow(a*a,b>>1)*(b&1?a:1):1;}\nint main()\n{\n  int N=IN(),now,len=0,pw3=Pow(3,N),x=Pow(3,N>>1),y=Pow(3,N-(N>>1)),A[1000001],B[600001];\n  char c=CH(),T[1000001],S[1000001];\n  rep(i,pw3)B[i]=B[i/3]*3+(3-i%3)%3;\n  while(c!=EOF){if(c==10){c=CH();}T[len++]=c,c=CH();}\n  rep(i,x)\n  {\n    int temp=i;now=0;\n    rep(j,len)\n    {\n      if(T[j]=='S'){temp=B[temp];(S[now]=='S')?--now:S[++now]='S';}\n      else{++temp;if(temp==x)S[++now]='R',temp=0;}\n    }\n    rep(j,y)\n    {\n      int keep=j;\n      rep(k,now)\n      {\n        if(S[k+1]=='S')keep=B[keep];\n        else if(S[k+1]=='R'){if((++keep)==y)keep=0;A[i+j*x]=temp+keep*x;}\n      }\n    }\n  }\n  rep(i,pw3)printf(\"%d\",A[i]),putchar(' ');\n  return puts(\"\"),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n//#define ll __int128\n#define ll long long\n#define int long long\n//#define int __int128\n#define LEFT(a) ((a)<<1)\n#define RIGHT(a) (LEFT(a) + 1)\n#define MID(a,b) ((a+b)>>1)\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define y1 y122\n\n/*\n#pragma GCC optimize (\"O3\")\n#pragma GCC optimize(\"Ofast\")\n\n#pragma GCC target(\"avx2,fma\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"unroll-loops\")\n\n#pragma comment(linker, \"/STACK: 20000000005\")\n*/\n\nusing namespace std;\n\nstring fun (string s){\n    vector < char > V;\n    for (int i = 0; i < s.size(); i++){\n        if (V.size() == 0 || s[i] == 'R' || V.back() == 'R')\n            V.pb (s[i]);\n        else\n            V.pop_back();\n    }\n    string ans = \"\";\n    for (char ch : V)\n        ans += ch;\n    return ans;\n}\n\nvector < int > V;\nvector < string > S;\n\n\nmain()\n{\n    ios_base::sync_with_stdio(0);\n    int po;\n    string s;\n    cin >> po >> s;\n    s = fun (s);\n    V.pb (0);\n    S.pb (s);\n    while (po--){\n        int n = V.size();\n        vector < int > vv (n*3, 0);\n        vector < string > ss (n*3, \"\");\n        for (int i = 0; i < n; i++){\n            s = S[i];\n            for (int st = 0; st < 3; st++){\n                string str = \"\";\n                int x = st;\n                for (int j = 0; j < s.size(); j++){\n                    if (s[j] == 'S'){\n                        str += \"S\";\n                        if (x >= 1)\n                            x = 3 - x;\n                        continue;\n                    }\n                    x++;\n                    if (x == 3){\n                        x = 0;\n                        str += \"R\";\n                    }\n                }\n                str = fun (str);\n                vv[st * n + i] = x * n + V[i];\n                ss[st * n + i] = str;\n            }\n        }\n        V = vv;\n        S = ss;\n    }\n    for (int x : V)\n        cout << x << \" \";\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long l;\nstring s1=\"\";\nstring convert10tob(l N)\n{\n\n     if (N == 0)\n        return \"\";\n\n     l x = N % 3;\n\n     N /= 3;\n\n     if (x < 0)\n        N += 1; \n\n     convert10tob(N);\n\n     l a = x < 0 ? x + (3 * -1) : x;\n     if(a==0)\n     {\n         s1=s1+'0';\n     }\n     else if(a==1)\n     {\n         s1=s1+'1';\n     }\n     else if(a==2)\n     {\n         s1=s1+'2';\n     }\n     \n\n     return s1;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n    l N;\n    cin>>N;\n    string s;\n    cin>>s;\n    l total=3;\n    for(l i=2;i<=N;i++)\n    {\n        total = total*3;\n    }\n    l arr[total]={0};\n \n    for(l i=1;i<total;i++)\n    {\n        if(arr[i]==0)\n        {\n            s1=\"\";\n            l second=0;\n            string con=convert10tob(i);\n            l csi=con.length()-1;\n            if(con[csi]=='1')\n            {\n                second+=2;\n            }\n            else if(con[csi]=='2')\n            {\n                second+=1;\n            }\n            l cnt=1;\n            csi--;\n            while(csi>=0)\n            {\n                cnt=cnt*3;\n                if(con[csi]=='0')\n                {\n                    csi--;\n                    continue;\n                }\n                if(con[csi]=='1')\n                {\n                   second+=(cnt*2);\n                }\n                else if(con[csi]=='2')\n                {\n                    second+=(cnt*1);\n                }\n                csi--;\n            }\n            arr[second]=i;\n            arr[i]=second;\n        }\n    }\n  \n    l arr1[total];\n    for(l i=0;i<total;i++)\n    {\n        arr1[i]=i;\n    }\n    l si=s.length();\n    l t=total-1;\n    for(l i=0;i<si;i++)\n    {\n        if(i==0 || i==(si-1))\n        {\n            if(s[i]=='S')\n            {\n                for(l j=0;j<total;j++)\n                {\n                    arr1[j]=arr[arr1[j]];\n                }\n            }\n            else{\n                for(l j=0;j<total;j++)\n                {\n                    if(arr1[j]!=t)\n                    {\n                        arr1[j]+=1;\n                    }\n                    else{\n                        arr1[j]=0;\n                    }\n                }\n            }\n        }\n        else\n        {\n            if(s[i]=='R')\n            {\n                for(l j=0;j<total;j++)\n                {\n                    if(arr1[j]!=t)\n                    {\n                        arr1[j]+=1;\n                    }\n                    else{\n                        arr1[j]=0;\n                    }\n                }\n            }\n            else if(s[i-1]=='S' && s[i+1]=='S')\n            {\n                i=i+1;\n            }\n            else{\n                for(l j=0;j<total;j++)\n                {\n                    arr1[j]=arr[arr1[j]];\n                }\n            }\n        }\n    }\n    for(l i=0;i<total;i++)\n    {\n        cout<<arr1[i]<<\" \";\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint n, len, l[3*3*3*3*3*3*3*3*3*3*3*3];\nstring t;\n\nint calc(int a) {\n\tif (a < 3) {\n\t\treturn a % 3 - 1 + (a + 1) % 3;\n\t}\n\telse {\n\t\treturn a % 3 - 1 + (a + 1) % 3 + 3 * calc(a / 3);\n\t}\n}\n\nint main()\n{\n\tcin >> n;\n\tcin >> t;\n\tn = pow(3, n);\n\tfor (int i = 0; i < n; i++) {\n\t\tl[i] = i;\n\t}\n\tfor (int i = 0; i < t.size(); i++) {\n\t\tif (t[i] == 'S') {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tl[j] = calc(l[j]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tl[j] = (l[j] + 1) % n;\n\t\t\t}\n\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcout << l[i] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << l[i] << \" \";\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int max3N = 550009;\nint L, M, N = 10, p3[max3N], s[max3N], r[max3N], nxt[max3N], nxt2[max3N], sum[max3N], ans[max3N];\nchar sir[max3N];\nvector < int > v[max3N];\n\nint eval (int i, int v[], int l)\n{\n    for (int j=1; j<=l; j++)\n        if (v[j] == 0) i = r[i];\n        else i = s[i];\n    return i;\n}\n\nconst int N1 = 7, N2 = 7;\nint v1[N1 + 5], v2[N2 + 5];\nvoid back2 (int pos, int l1)\n{\n    if (pos > 2 && v2[pos - 1] == 1 && v2[pos - 2] == 1)\n        return ;\n    if (pos == 2 && v2[1] <= v1[1])\n        return ;\n    if (v2[pos - 1] != v1[l1])\n    {\n        int l2 = pos - 1;\n        ///try to check whether v1[1..l1]=v2[1..l2]\n        bool ok = 1;\n        int cnt = 0, cntr[3] = {0, 0, 0};\n        for (int i=0; i<p3[N]; i++)\n        {\n            if (eval (i, v1, l1) != eval (i, v2, l2))\n                ok = 0;\n            else cnt ++, cntr[i % 3] ++;\n        }\n        if (ok || cnt >= p3[N - 1])\n        {\n            printf (\"%.3f: [%d, %d, %d] \", (double) cnt / p3[N], cntr[0], cntr[1], cntr[2]);\n/*            bool ok2 = 1;\n            for (int i=1; i<l1; i++)\n                ok2 &= (v1[i] != 1 || v1[i + 1] != 1);\n            if (!ok2)\n            {\n                ok2 = 1;\n                for (int i=1; i<l2; i++)\n                    ok2 &= (v2[i] != 1 || v2[i + 1] != 1);\n            }\n            if (ok2) printf (\"WITHOUT: \");*/\n            for (int i=1; i<=l1; i++)\n                if (v1[i] == 0) printf (\"R\");\n                else printf (\"S\");\n            printf (\" = \");\n            for (int i=1; i<=l2; i++)\n                if (v2[i] == 0) printf (\"R\");\n                else printf (\"S\");\n            printf (\"\\n\");\n        }\n    }\n    if (pos == N2)\n        return ;\n    for (int i=0; i<2; i++)\n        v2[pos] = i, back2 (pos + 1, l1);\n}\n\nvoid back1 (int pos)\n{\n    if (pos > 2 && v1[pos - 1] == 1 && v1[pos - 2] == 1)\n        return ;\n    if (pos > 1)\n        back2 (1, pos - 1);\n    if (pos == N1)\n        return ;\n    for (int i=0; i<2; i++)\n        v1[pos] = i, back1 (pos + 1);\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &M);\nN = M / 2;\n\np3[0] = 1;\nfor (int i=1; i<=M; i++)\n    p3[i] = 3 * p3[i - 1];\nfor (int i=1; i<p3[M]; i++)\n    if (i % 3 == 0) s[i] = s[i / 3] * 3;\n    else\n    if (i % 3 == 1) s[i] = s[i / 3] * 3 + 2;\n    else s[i] = s[i / 3] * 3 + 1;\n//for (int i=0; i<p3[N]; i++)\n //   r[i] = (i + 1) % p3[N];\nscanf (\"%s\", sir + 1), L = strlen (sir + 1);\nfor (int j=0; j<p3[N]; j++)\n    nxt[j] = j;\nfor (int i=1; i<=L; i++)\n{\n    if (sir[i] == 'S')\n    {\n        sum[i] = sum[i - 1] + 1;\n        for (int j=0; j<p3[N]; j++)\n            nxt[j] = s[nxt[j]];\n        continue;\n    }\n    sum[i] = sum[i - 1];\n    for (int j=0; j<p3[N]; j++)\n    {\n        if (nxt[j] == p3[N] - 1)\n            v[j].push_back (i);\n        nxt[j] = (nxt[j] + 1) % p3[N];\n    }\n}\n\nfor (int r = 0; r < p3[N]; r ++)\n{\n    for (int i=0; i<p3[M - N]; i++)\n        nxt2[i] = i;\n    int lst = 0, curr = 0;\n    for (auto pos : v[r])\n    {\n        if (sum[pos] % 2 == sum[lst] % 2)\n            curr ++;\n        else\n        {\n            for (int i=0; i<p3[M - N]; i++)\n                nxt2[i] = s[(nxt2[i] + curr) % p3[M - N]];\n            curr = 1;\n        }\n        lst = pos;\n    }\n    for (int i=0; i<p3[M - N]; i++)\n        nxt2[i] = (nxt2[i] + curr) % p3[M - N];\n    if (sum[L] % 2 != sum[lst] % 2)\n    {\n        for (int i=0; i<p3[M - N]; i++)\n            nxt2[i] = s[nxt2[i]];\n    }\n    for (int c=0; c<p3[M - N]; c++)\n        ans[c * p3[N] + r] = nxt2[c] * p3[N] + nxt[r];\n}\nfor (int i=0; i<p3[M]; i++)\n    printf (\"%d%c\", ans[i], \" \\n\"[i == p3[M] - 1]);\n//back1 (1), v2[0] = -1;\n/*RRSRSSSSR\nint v[] = {-1, 0, 0, 1, 0, 1, 1, 1, 1, 0};\nfor (int i=0; i<p3[N]; i++)\n    printf (\"%d%c\", eval (i, v, 9), \" \\n\"[i == p3[N] - 1]);*/\n/*int cnt = 0;\nfor (int i=0; i<p3[N]; i++)\n    cnt += (r[r[s[r[i]]]] == s[r[r[i]]]);\nprintf (\"%d\\nout of\\n%d\\n\", cnt, p3[N]);*/\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 13, MAX_M = 200020;\n\nint N, M, Half, pow3[MAX_N], salsa[1 << MAX_N], highbits[1 << MAX_N], Ans[1 << MAX_N];\n\nchar S[MAX_M];\n\nint main() {\n    scanf(\"%d\", &N); Half = N / 2;\n    scanf(\"%s\", S + 1); M = strlen(S + 1);\n    pow3[0] = 1;\n    for (int i = 1; i <= N; i++) pow3[i] = pow3[i - 1] * 3;\n    for (int i = 0; i < pow3[N]; i++) {\n        int result = 0;\n        for (int j = 0; j < N; j++) {\n            int t = i / pow3[j] % 3;\n            result += (3 - t) % 3 * pow3[j];\n        }\n        salsa[i] = result;\n    }\n    for (int i = 0; i < pow3[Half]; i++) {\n        int lowbits = i;\n        for (int j = 0; j < pow3[N - Half]; j++)\n            highbits[j] = j;\n        bool high_flip = false;\n        for (int j = 1; j <= M; j++) {\n            if (S[j] == 'S') {\n                high_flip ^= true;\n                lowbits = salsa[lowbits];\n            } else {\n                if (++lowbits == pow3[Half]) {\n                    lowbits = 0;\n                    if (high_flip) {\n                        for (int j = 0; j < pow3[N - Half]; j++) {\n                            highbits[j] = salsa[highbits[j]];\n                        }\n                        high_flip = false;\n                    }\n                    for (int j = 0; j < pow3[N - Half]; j++) {\n                        if (++highbits[j] == pow3[N - Half])\n                            highbits[j] = 0;\n                    }\n                }\n            }\n        }\n        if (high_flip) {\n            for (int j = 0; j < pow3[N - Half]; j++) {\n                highbits[j] = salsa[highbits[j]];\n            }\n        }\n        high_flip = false;\n        for (int j = 0; j < pow3[N - Half]; j++){\n            Ans[j * pow3[Half] + i] = highbits[j] * pow3[Half] + lowbits;\n        }\n    }\n    for (int i = 0; i < pow3[N]; i++) printf(\"%d \", Ans[i]);\n    printf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "//Awwawa! Dis cold yis ratten buy tEMMIE!\n#include <bits/stdc++.h>\n#define ll long long\n#define maxn 200005 /*rem*/\n#define mod 998244353\n#define db double\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n#define pi pair<int, int>\n#define fi first\n#define se second\n\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,true:false;}\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,true:false;}\n\nusing namespace std;\nll ksm(ll a, ll b) {\n   if (!b) return 1;\n   ll ns = ksm(a, b >> 1);\n   ns = ns * ns % mod;\n   if (b & 1) ns = ns * a % mod;\n   return ns;\n}\nconst int S = 10000005;\nint nx[S][3];\nint tr[S];\nint rt = 1;\nint idcnt = 2;\nint tp[S];\nvoid down(int k) {\n\tif (tp[k]) {\n\t\tswap(nx[k][1], nx[k][2]);\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\ttp[nx[k][j]] ^= 1;\n\t\ttp[k] = 0;\n\t}\n}\nvoid pl(int k) {\n\tif (tr[k] != -1) return ;\n\tdown(k);\n\tint r[3] = {nx[k][0], nx[k][1], nx[k][2]};\n\tfor (int j = 0; j < 3; j++)\n\t\tnx[k][j] = r[(j + 2) % 3];\n\tpl(nx[k][0]);\n}\nint pw[maxn];\nchar u[maxn];\nint mr[maxn], p[maxn];\nint main() {\n\tint n;\n\tcin >> n;\n\tpw[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tpw[i] = pw[i - 1] * 3;\n\tmemset(tr, -1, sizeof(tr));\n\tfor (int i = 0; i < pw[n]; i++) {\n\t\tint pl = rt, cur = i;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint ne = cur % 3;\n\t\t\tcur /= 3;\n\t\t\tif (!nx[pl][ne]) nx[pl][ne] = idcnt++;\n\t\t\tpl = nx[pl][ne];\n\t\t}\n\t\ttr[pl] = i;\n\t}\n\tscanf(\"%s\", u);\n\tint l = strlen(u);\n\tfor (int j = 0; j < l; j++) {\n\t\tif (u[j] == 'S') tp[rt] ^= 1;\n\t\telse \n\t\t\tpl(rt);\n\t}\n\tfor (int i = 0; i < pw[n]; i++) {\n\t\tint pl = rt, cur = i;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint ne = cur % 3; cur /= 3;\n\t\t\tdown(pl);\n\t\t\tpl = nx[pl][ne];\n\t\t}\n\t\tmr[i] = tr[pl];\n\t\tp[mr[i]] = i;\n\t}\n\tfor (int j = 0; j < pw[n]; j++)\n\t\tprintf(\"%d \", p[j]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n;cin>>n;\n\tvi x;\n\t{\n\t\tstring s;cin>>s;\n\t\tfor(auto c:s){\n\t\t\tif(c=='S')x.pb(-1);\n\t\t\telse x.pb(0);\n\t\t}\n\t}\n\t\n\tint s=1;rep(_,n)s*=3;\n\tvi ans(s);\n\t\n\tint w=1;\n\trep(lv,n){\n\t\tbool r=0;\n\t\tvi b(w*3);\n\t\trep(i,w*3)b[i]=i/w;\n\t\tvi y;\n\t\tfor(auto v:x){\n\t\t\tif(v==-1){\n\t\t\t\tr^=1;\n\t\t\t\ty.pb(v);\n\t\t\t}else{\n\t\t\t\tfor(int i=v;i<w*3;i+=w){\n\t\t\t\t\tif(r&&b[i])b[i]=3-b[i];\n\t\t\t\t\t\n\t\t\t\t\tb[i]++;\n\t\t\t\t\tif(b[i]==3){\n\t\t\t\t\t\tb[i]=0;\n\t\t\t\t\t\ty.pb(i);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(r&&b[i])b[i]=3-b[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tx=y;\n\t\t\n\t\tif(r)rep(i,3*w)if(b[i])b[i]=3-b[i];\n\t\t\n\t\tfor(int i=0;i<s;i+=3*w){\n\t\t\trep(j,3*w){\n\t\t\t\tans[i+j]+=b[j]*w;\n\t\t\t}\n\t\t}\n\t\tw*=3;\n\t}\n\t\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nint a[555555];\nint nxt[200111][739]; //if we start with j before operation i, what is the next command s.t. after performing it, we get 000000 (-1 if doesn't exist)\nint p3[13];\nconst int LG = 10;\nint dp[739][(1<<LG)+1];\nint flipprep[739];\n\nint flip(int x)\n{\n\tint ans=0; int cur=1;\n\twhile(x>0)\n\t{\n\t\tint d=x%3;\n\t\tif(d==1) d=2;\n\t\telse if(d==2) d=1;\n\t\tans+=cur*d;\n\t\tx/=3;\n\t\tcur*=3;\n\t}\n\treturn ans;\n}\n\nint ans[555555];\nint Spref[255555];\n\nint ssum(int l, int r)\n{\n\tif(l==0) return Spref[r];\n\telse return Spref[r]-Spref[l-1];\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tstring s; cin>>s;\n\tp3[0]=1;\n\tfor(int i=1;i<=12;i++) p3[i]=p3[i-1]*3;\n\tfor(int i=0;i<730;i++) flipprep[i]=flip(i);\n\tint m=s.length();\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tSpref[i]=(s[i]=='S');\n\t\tif(i>0) Spref[i]+=Spref[i-1];\n\t}\n\tif(n<=1)\n\t{\n\t\tfor(int i=0;i<p3[n];i++)\n\t\t{\n\t\t\tint cur=i;\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tif(s[j]=='R') \n\t\t\t\t{\n\t\t\t\t\tcur++; cur%=p3[n];\n\t\t\t\t}\n\t\t\t\telse cur=flip(cur);\n\t\t\t}\n\t\t\tans[i]=cur;\n\t\t}\n\t\tfor(int i=0;i<p3[n];i++)\n\t\t{\n\t\t\tcout<<ans[i];\n\t\t\tif(i+1<p3[n]) cout<<' ';\n\t\t}\n\t\tcout<<'\\n';\n\t\treturn 0;\n\t}\n\tint l = n/2;\n\t//last l bits\n\tfor(int i=0;i<p3[l];i++)\n\t{\n\t\tnxt[m][i]=nxt[m-1][i]=-1;\n\t\tif(i==p3[l]-1&&s[m-1]=='R') nxt[m-1][i]=m-1;\n\t}\n\tfor(int i=m-2;i>=0;i--)\n\t{\n\t\tfor(int j=0;j<p3[l];j++)\n\t\t{\n\t\t\tif(j==p3[l]-1&&s[i]=='R')\n\t\t\t{\n\t\t\t\tnxt[i][j]=i;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint nxtbit = j+1;\n\t\t\t\tif(s[i]=='S') nxtbit=flipprep[j];\n\t\t\t\tnxt[i][j]=nxt[i+1][nxtbit];\n\t\t\t}\n\t\t}\n\t}\n\tint r = n-l;\n\t//for every first r bits, and a binary string, i want to know its new value fast\n\tfor(int i=0;i<p3[r];i++)\n\t{\n\t\tfor(int j=0;j<(1<<LG);j++) //this means (bit0,+), (bit1,+), (bit2,+), ..., (bitLG-1, +)\n\t\t{\n\t\t\tint cur=i;\n\t\t\tfor(int k=0;k<LG;k++)\n\t\t\t{\n\t\t\t\tif(j&(1<<k))\n\t\t\t\t{\n\t\t\t\t\tcur=flipprep[cur];\n\t\t\t\t}\n\t\t\t\tcur++;\n\t\t\t\tif(cur>=p3[r]) cur-=p3[r];\n\t\t\t}\n\t\t\tdp[i][j]=cur;\n\t\t}\n\t}\n\t//now, I iterate over all last l bits\n\tfor(int i=0;i<p3[l];i++)\n\t{\n\t\tint finv=i;\n\t\tfor(int j=0;j<m;j++)\n\t\t{\n\t\t\tif(s[j]=='R') finv++;\n\t\t\telse finv=flipprep[finv];\n\t\t\tif(finv>=p3[l]) finv-=p3[l];\n\t\t}\n\t\t//form the bit string\n\t\tint val=i; //of course, I start from i\n\t\tvector<int> bitstring;\n\t\tint pos=0; int undo=0;\n\t\twhile(pos<m)\n\t\t{\n\t\t\tint nxtpos = nxt[pos][val];\n\t\t\t//done operations from pos to nxtpos\n\t\t\tif(nxtpos!=-1)\n\t\t\t{\n\t\t\t\tbitstring.pb(ssum(pos,nxtpos)&1);\n\t\t\t\tpos=nxtpos+1;\n\t\t\t\tval=0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbitstring.pb(ssum(pos,m-1)&1);\n\t\t\t\tundo=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvector<int> compressed;\n\t\tint curbit=0; int curmult=1;\n\t\t//cerr<<\"I = \"<<i<<\": \";\n\t\tvi remstring;\n\t\tfor(int v:bitstring)\n\t\t{\n\t\t\t//cerr<<v<<' ';\n\t\t\tremstring.pb(v);\n\t\t\tcurbit+=curmult*v;\n\t\t\tcurmult*=2; \n\t\t\tif(curmult>=(1<<LG))\n\t\t\t{\n\t\t\t\tcompressed.pb(curbit);\n\t\t\t\tremstring.clear();\n\t\t\t\tcurmult=1;\n\t\t\t}\n\t\t}\n\t\t//cerr<<'\\n';\n\t\t//cerr<<\"UNDO = \"<<undo<<'\\n';\n\t\tfor(int j=0;j<p3[r];j++)\n\t\t{\n\t\t\tint prefval = j;\n\t\t\tfor(int v:compressed)\n\t\t\t{\n\t\t\t\tprefval = dp[prefval][v];\n\t\t\t}\n\t\t\tfor(int v:remstring)\n\t\t\t{\n\t\t\t\t//cerr<<v<<' '<<prefval<<'\\n';\n\t\t\t\tif(v)\n\t\t\t\t{\n\t\t\t\t\tprefval=flipprep[prefval];\n\t\t\t\t}\n\t\t\t\tprefval++;\n\t\t\t\tif(prefval>=p3[r]) prefval-=p3[r];\n\t\t\t}\n\t\t\t//cerr<<'\\n';\n\t\t\t//cerr<<\"J = \"<<j<<\" PREFVAL = \"<<prefval<<'\\n';\n\t\t\tif(undo) \n\t\t\t{\n\t\t\t\tprefval--;\n\t\t\t\tif(prefval<0) prefval+=p3[r];\n\t\t\t}\n\t\t\tint val = prefval*p3[l]+finv;\n\t\t\tint lab = j*p3[l]+i;\n\t\t\tans[lab]=val;\n\t\t}\n\t}\t\n\tfor(int i=0;i<p3[n];i++)\n\t{\n\t\tcout<<ans[i];\n\t\tif(i+1<p3[n]) cout<<' ';\n\t}\n\tcout<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(long long i=0;i<(long long)N;i++)\nint N,x,y,pos,tri0,tri1,tri2,pw3[13]={1},A[531441],salsa[531441],sw[531441];\nchar T[200001];\nvoid OUT(long long x){if(x<0)putchar('-'),x=-x;if(x>=10)OUT(x/10);putchar(x%10+48);}\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nsigned main(void)\n{\n  x=scanf(\"%d %s\",&N,T+1);\n  replace(T+1,\"SS\",\"\");if(T[0]=='\\n')return 0;\n  rep(i,N)pw3[i+1]=3*pw3[i];\n  tri0=pw3[N],tri1=pw3[N/2],tri2=pw3[N-N/2];\n  rep(i,tri0)salsa[i]=salsa[i/3]*3+(3-i%3)%3;\n  rep(i,tri1)\n  {\n    x=i,pos=0;\n    rep(j,strlen(T+1))\n    {\n      if(T[j+1]=='S'){x=salsa[x];if(sw[pos]>0)pos--;else sw[++pos]=1;}\n      if(T[j+1]=='R'){x++;if(x==tri1)sw[++pos]=-1,x=0;}\n    }\n    rep(j,tri2)\n    {\n      y=j;\n      rep(k,pos){if(sw[k+1]>0)y=salsa[y];else if(sw[k+1]<0){if((++y)==tri2)y=0;}}\n      A[i+j*tri1]=y*tri1+x;\n    }\n  }\n  rep(i,tri0)OUT(A[i]),putchar(' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<queue>\n#include<cmath>\n#include<bitset>\n#include<cstdio>\n#include<vector>\n#include<cctype>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#define fi first\n#define se second\n#define lc (x<<1)\n#define rc (x<<1|1)\n#define gc getchar()\n#define mk make_pair\n#define pi pair<int,int>\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int N=14,M=797171,T=2e5+10;\ntemplate<class o>void qr(o&x) {\n\tchar c=gc;int f=1;x=0;\n\twhile(!isdigit(c)){if(c=='-')f=-1;c=gc;}\n\twhile(isdigit(c))x=x*10+c-'0',c=gc;\n\tx*=f;\n}\ntemplate<class o>void qw(o x) {\n\tif(x/10)qw(x/10);\n\tputchar(x%10+'0');\n}\ntemplate<class o> void pr1(o x) {\n\tif(x<0)x=-x,putchar('-');\n\tqw(x); putchar(' ');\n}\ntemplate<class o>void pr2(o x) {\n\tif(x<0)x=-x,putchar('-');\n\tqw(x);puts(\"\");\n}\n\nint trie[M][3],ed[M],p[M],n,cnt=1,tot,f[N]; \nchar s[T]; bool v[M];\n\nvoid insert(int x) {\n\tint p=1;\n\tfor(int i=1;i<=n;i++) {\n\t\tint c=x%3; x/=3;\n\t\tif(!trie[p][c]) trie[p][c]=++cnt;\n\t\tp=trie[p][c];\n\t}\n\ted[p]=++tot;\n}\n\nvoid lazy(int x) {\n\tif(v[x]) {\n\t\tv[x]=0;\n\t\tint &y=trie[x][1],&z=trie[x][2];\n\t\tswap(y,z); \n\t\tv[trie[x][0]]^=1; v[y]^=1; v[z]^=1;\n\t}\n}\n\nvoid add(int x) {\n\tif(ed[x]) return ;\n\tlazy(x);\n\tint a=trie[x][0],b=trie[x][1],c=trie[x][2];\n\ttrie[x][0]=c; trie[x][1]=a; trie[x][2]=b;\n\tadd(c);\n}\n\nvoid dfs(int x,int y,int d) {//½Úµã±àºÅ,ÕæÊµÖµ,Éî¶È \n\tif(ed[x]) {p[ed[x]]=y; return ;} lazy(x);\n\tfor(int i=0;i<=2;i++) dfs(trie[x][i],y+i*f[d],d+1);\n}\n\nint main() {\t\n\tqr(n); scanf(\"%s\",s+1);\n\tf[0]=1; for(int i=1;i<=n;i++) f[i]=f[i-1]*3;\n\tfor(int i=0;i<f[n];i++) insert(i);\n\tfor(int i=1;s[i];i++) \n\t\tif(s[i]=='S') v[1]^=1;\n\t\telse add(1);\n\tdfs(1,0,0);\tfor(int i=1;i<=tot;i++) pr1(p[i]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,o,p,x,y,pos,pw3[13]={1},A[1000000],salsa[531441],sw[1000000];\nchar T[200001];\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nvoid Dance(char c[])\n{\n  if(c[p]==EOF)return;\n  if(c[p]=='S'){x=salsa[x];if(sw[pos]>0)pos--;else sw[++pos]=1;}\n  if(c[p]=='R'){x++;if(x==pw3[N/2])sw[++pos]=-1,x=0;}\n}\nvoid Update(void)\n{\n  rep(i,pw3[N-N/2])\n  {\n    y=i;\n    rep(j,pos){if(sw[j+1]>0)y=salsa[y];else if(sw[j+1]<0){if((++y)==pw3[N-N/2])y=0;}}\n    A[o+i*pw3[N/2]]=y*pw3[N/2]+x;\n  }\n}\nsigned main(void)\n{\n  o=scanf(\"%d %s\",&N,T);\n  replace(T,\"SS\",\"\");if(T[0]=='\\n')return 0;\n  rep(i,N)pw3[i+1]=3*pw3[i];\n  rep(i,pw3[N])salsa[i]=salsa[i/3]*3+(3-i%3)%3;\n  rep(i,pw3[N/2]){o=i,x=i,pos=0;rep(j,strlen(T)){p=j,Dance(T);}Update();}\n  rep(i,pw3[N])printf(\"%d%c\",A[i],i+1==pw3[N]?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 21;\nconst int siz = 55e4+100;\n#define fr(i,a,b) for(int i = a;i <= b; ++i)\n#define nfr(i,a,b) for(int i = a;i >= b; --i)\n\nint d[N][siz],a[N][siz],w[N][siz];\nint tag[N][siz];\nint n,m;\nchar ch[siz];\nint main(){\n   scanf(\"%d\",&n);\n   scanf(\"%s\",ch+1);\n   m = strlen(ch+1);\n\n   a[0][0] = 0;\n   fr(i,0,m)w[0][i] = 0;\n\n   int cur = 1;\n   fr(i,1,n){\n      cur *= 3;\n      w[i][0] = cur-1;\n      fr(j,0,cur-1)d[i][j] = j/(cur/3);\n\n      int tg = 0;\n      fr(j,1,m){\n         if(ch[j] == 'S'){\n            tg ^= 1;\n            int p = w[i-1][j-1];\n            fr(k,0,2){\n               if(d[i][p+k*(cur/3)] == 0){\n                  tag[i][p+k*(cur/3)] = tg;\n                  continue ;\n               }\n               d[i][p+k*(cur/3)] ^= 3*(tag[i][p+k*(cur/3)]^tg);\n               tag[i][p+k*(cur/3)] = tg;\n            }\n         } else {\n            int p = w[i-1][j-1];\n            fr(k,0,2){\n               if(d[i][p+k*(cur/3)] != 0)\n                  d[i][p+k*(cur/3)] ^= 3*(tag[i][p+k*(cur/3)]^tg);\n               tag[i][p+k*(cur/3)] = tg;\n\n               d[i][p+k*(cur/3)]++;\n               d[i][p+k*(cur/3)] %= 3;\n            }\n         }\n         \n         int p = w[i-1][j];\n         fr(k,0,2){\n            if(d[i][p+k*(cur/3)] != 0)\n               d[i][p+k*(cur/3)] ^= 3*(tag[i][p+k*(cur/3)]^tg);\n            tag[i][p+k*(cur/3)] = tg;\n\n            if(d[i][p+k*(cur/3)] == 2)\n               w[i][j] = p+k*(cur/3);\n         }\n         cerr << \"wij\" <<' ' << i <<' ' << j <<' ' << w[i][j] << endl;\n      }\n\n      fr(j,0,cur-1){\n         if(d[i][j] == 0)continue ;\n         d[i][j] ^= 3*(tag[i][j]^tg);\n      }\n      fr(j,0,cur-1)a[i][j] = a[i-1][j%(cur/3)]+(cur/3)*d[i][j],cerr << a[i][j] << ' ';\n      cerr << endl;\n   }\n\n   fr(i,0,cur-1){\n      printf(\"%d \",a[n][i]);\n   }\n   puts(\"\");\n   return 0;\n}\n/*\n2\nSRSRRSRRRSRRRR\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n\nusing namespace std;\n\nlong long N;\n\nlong long s (long long x){\n  long long i = x;\n  long long c=0;\n  for(long long n=1;x>=n;n*=3){\n    long long a = i%3;\n    prlong longf(\"%d\\n\",a);\n    i /= 3;\n    if(a == 1)\n      c += n*2;\n    if(a == 2)\n      c += n;\n  }\n  return c;\n}\nlong long r (long long x){\n  return (x+1) % N;\n}\n\nlong long pow3(int n){\n  if(n == 1)\n    return 3;\n  long long r = pow(n/2);\n  if(n%2 == 1)\n    return r*r*3;\n  return r*r;    \n\n}\n\nint main(){\n  long long n;\n  scanf(\"%d\",&n);\n  N = pow(n);\n  char danse[200000];\n  scanf(\"%s\",danse);\n  for(int i=0;i<N;i++){\n    if(i != 0)\n      printf(\" \");\n    int res = i;\n    for(char d: danse){\n      if(d == 'S'){\n        res = s(res);\n      }else if(d == 'R'){\n        res = r(res);\n      }else{\n        break;\n      }\n    }\n    printf(\"%d\", res);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXN 13\n#define MAXM 500005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n;\nstring str;\nint ans[MAXM];\nint curdigit[MAXN],curres[MAXN];\nstring reduce(string &t)\n{\n    vector<char> st;\n    string ret=\"\";\n    for(auto ch:t)\n    {\n        st.push_back(ch);\n        if(st.size()>=2&&st[(int)st.size()-1]=='S'&&st[(int)st.size()-2]=='S') st.pop_back(),st.pop_back();\n    }\n    for(auto ch:st) ret+=ch;\n    return ret;\n}\nvoid update_ans()\n{\n    int x=0,y=0;\n    for(int i=n-1;i>=0;i--)\n    {\n        x=x*3+curdigit[i];\n        y=y*3+curres[i];\n    }\n    ans[x]=y;\n}\nvoid solve(int cur,string t)\n{\n    if(cur==n) \n    {\n        update_ans();\n        return;\n    }\n    for(int d=0;d<3;d++)\n    {\n        string curt=\"\";\n        int curd=d;\n        for(auto ch:t)\n        {\n            if(ch=='S')\n            {\n                if(curd) curd=3-curd;\n                curt+='S';\n            }\n            if(ch=='R')\n            {\n                curd++;\n                if(curd==3)\n                {\n                    curd=0;\n                    curt+='R';\n                }\n            }\n        }\n        curdigit[cur]=d;\n        curres[cur]=curd;\n        solve(cur+1,reduce(curt));\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    cin>>str;\n    solve(0,reduce(str));\n    int p=1;\n    for(int i=0;i<n;i++) p=p*3;\n    for(int i=0;i<p;i++) printf(\"%d \",ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\npair<int,int> jmp[13][210000][3];\npair<int,int> jmp2[13][210000][3];\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint N;\n\tcin >> N;\n\tstring s;\n\tcin >> s;\n\tint n = (int)s.size();\n\tvector<int> rsum(n+1, 0), ssum(n+1);\n\tfor(int i = 0; i < n; i++){\n\t\trsum[i+1] = rsum[i] + (s[i] == 'R');\n\t\tssum[i+1] = ssum[i] + (s[i] == 'S');\n\t}\n\tfor(int j = 0; j <= N; j++){\n\t\tfor(int i = n; i >= 0; i--){\n\t\t\tfor(int r = 0; r < 3; r++){\n\t\t\t\tjmp[j][i][r] = {n+1, 0};\n\t\t\t\tjmp2[j][i][r] = {i, r};\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = n-1; i >= 0; i--){\n\t\tfor(int r = 0; r < 3; r++){\n\t\t\tint nxt = (s[i] == 'S' ? (3 - r) % 3 : (r + 1) % 3);\n\t\t\tjmp[0][i][r] = {i+1, nxt};\n\t\t\tif(r == 2 && s[i] == 'R'){\n\t\t\t\tjmp2[0][i][r] = {i, r};\n\t\t\t} else {\n\t\t\t\tjmp2[0][i][r] = jmp2[0][i+1][nxt];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int j = 1; j <= N; j++){\n\t\tvector<vector<int> > work(n+1, vector<int>(3, n+1));\n\t\tfor(int i = n; i >= 0; i--){\n\t\t\t// when reach j 0s\n\t\t\tfor(int r = 0; r < 3; r++){\n\t\t\t\tpair<int,int> res = jmp[j-1][i][r];\n\t\t\t\tif(res.first == n + 1){\n\t\t\t\t\twork[i][r] = n + 1;\n\t\t\t\t} else if(res.second == 0){\n\t\t\t\t\twork[i][r] = res.first;\n\t\t\t\t} else {\n\t\t\t\t\twork[i][r] = work[res.first][res.second];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = n; i >= 0; i--){\n\t\t\tfor(int r = 0; r < 3; r++){\n\t\t\t\tint f = work[i][0];\n\t\t\t\tif(f == n+1){\n\t\t\t\t\tjmp[j][i][r] = {n+1, 0};\n\t\t\t\t\tjmp2[j][i][r] = {i, r};\n\t\t\t\t} else {\n\t\t\t\t\tif(f == i+1){\n\t\t\t\t\t\tassert(s[i] == 'S');\n\t\t\t\t\t\tjmp[j][i][r] = {f, (3 - r) % 3};\n\t\t\t\t\t\tjmp2[j][i][r] = jmp2[j][f][(3 - r) % 3];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassert(s[i] == 'R');\n\t\t\t\t\t\tassert(s[f-1] == 'R');\n\t\t\t\t\t\tint ns = ssum[f] - ssum[i];\n\t\t\t\t\t\tint end = ((ns & 1) ? (3 - r) : (r)) % 3;\n\t\t\t\t\t\tjmp[j][i][r] = {f, (end + 1) % 3};\n\t\t\t\t\t\tif(end == 2 && j < N){\n\t\t\t\t\t\t\tjmp2[j][i][r] = {i, r};\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjmp2[j][i][r] = jmp2[j][f][(end + 1) % 3];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tassert(jmp2[j][i][r].first >= i);\n\t\t\t}\n\t\t}\n\t}\n\tint cn = 1;\n\tfor(int i = 0; i < N; i++) cn *= 3;\n\tfor(int st = 0; st < cn; st++){\n\t\tint cst = st;\n\t\tvector<int> val(N);\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tval[j] = cst % 3;\n\t\t\tcst /= 3;\n\t\t}\n\t\tassert(cst == 0);\n\t\tint cur = 0;\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tif(val[j] == 0) continue;\n\t\t\t{\n\t\t\t\tpair<int,int> f = jmp2[j][cur][val[j]];\n\t\t\t\tint ns = ssum[f.first] - ssum[cur];\n\t\t\t\tif(ns & 1) for(int& a : val) a = (3 - a) % 3;\n\t\t\t\tcur = f.first;\n\t\t\t\tval[j] = f.second;\n\t\t\t}\n\t\t\t{\n\t\t\t\tpair<int,int> f = jmp[j][cur][val[j]];\n\t\t\t\tif(f.first == n+1) continue;\n\t\t\t\tassert(f.second == 0);\n\t\t\t\tint ns = ssum[f.first] - ssum[cur];\n\t\t\t\tif(ns & 1) for(int& a : val) a = (3 - a) % 3;\n\t\t\t\tassert(val[j] == 2);\n\t\t\t\tval[j] = 3;\n\t\t\t\tfor(int r = j; r < N; r++){\n\t\t\t\t\tif(val[r] == 3){\n\t\t\t\t\t\tval[r] = 0;\n\t\t\t\t\t\tif(r + 1 < N){\n\t\t\t\t\t\t\tval[r+1]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = f.first;\n\t\t\t}\n\t\t}\n\t\tfor(int j = N; j >= 0; j--){\n\t\t\tbool allzero = true;\n\t\t\tfor(int i = 0; i < j; i++) if(val[i] != 0) allzero = false;\n\t\t\tif(!allzero) continue;\n\t\t\tpair<int,int> f = jmp2[j][cur][(j == N) ? 0 : val[j]];\n\t\t\tint ns = ssum[f.first] - ssum[cur];\n\t\t\tif(ns & 1) for(int& a : val) a = (3 - a) % 3;\n\t\t\tcur = f.first;\n\t\t\tif(j < N) val[j] = f.second;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = N-1; i >= 0; i--){\n\t\t\tans = (3 * ans) + val[i];\n\t\t}\n\t\tassert(cur == n);\n\t\tcout << ans << ' ';\n\t}\n\tcout << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "/*input\n3\nSRSRRSRRRSRRRR\n*/\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef tree<long long, null_type, less_equal<long long>, rb_tree_tag, tree_order_statistics_node_update> indexed_set;\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n//order_of_key #of elements less than x\n// find_by_order kth element\ntypedef long long int ll;\n#define ld double\n#define pii pair<ll,ll>\n#define f first\n#define s second\n#define pb push_back\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REP1(i,n) for(int i=1;i<=n;i++)\n#define FILL(n,x) memset(n,x,sizeof(n))\n#define ALL(_a) _a.begin(),_a.end()\n#define sz(x) (int)x.size()\nconst ll maxn=1e6+5;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=4e18;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=1e9+7;\nconst ld PI=acos(-1);\nconst ld eps=1e-9;\n#define lowb(x) x&(-x)\n#define MNTO(x,y) x=min(x,(__typeof__(x))y)\n#define MXTO(x,y) x=max(x,(__typeof__(x))y)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define MP make_pair\nll mult(ll a,ll b){\n    ll res=0LL;\n    while(b){\n        if(b&1) res=(res+a)%MOD;\n        a=(a+a)%MOD;\n        b>>=1;\n    }\n    return res%MOD;\n}\nll mypow(ll a,ll b){\n    ll res=1LL;\n    while(b){\n        if(b&1) res=res*a%MOD;\n        a=a*a%MOD;\n        b>>=1;\n    }\n    return res;\n}\nint ans[maxn];\nint main(){\n    ios::sync_with_stdio(false),cin.tie(0);\n    int n;\n    cin>>n;\n    int z=mypow(3,n);\n    REP(i,z){\n        int x=i;\n        int opp=0;\n        vector<int> v;\n        while(x>0){\n            if(x%3==1) v.pb(2);\n            else if(x%3==2) v.pb(1);\n            else v.pb(0);\n            x/=3;\n        }\n        reverse(ALL(v));\n        REP(i,sz(v)) opp=opp*3+v[i];\n        ans[i]=opp;\n    }\n    string s;\n    cin>>s;\n    string nw=\"\";\n    for(int i=0;i<sz(s);){\n        if(s[i]=='S'){\n            int c=i;\n            while(s[i]=='S') ++i;\n            if((i-c)%2) nw+='S';\n        }\n        else{\n            nw+='R';\n            ++i;\n        }\n    }\n\n    REP(i,z){\n        int cur=i;\n        REP(j,sz(nw)){\n            if(nw[j]=='R') ++cur,cur%=z;\n            else cur=ans[cur];\n        }\n        cout<<cur<<' ';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb emplace_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\n#define dupli(a) a.erase(unique(all(a)),a.end())\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst int INF=1001001001;\nconst int mod=1000000007;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\nll sw(ll i){\n    if(i==0)return 0;\n    return 3-i;\n}\nint main(){\n    ll l;cin>>l;\n    string s;cin>>s;\n    ll n=s.size();\n    vi v(n);\n    rep(i,n)if(s[i]=='R')v[i]++;\n    vvi dp0(n+1,vi(3)),dp1(n+1,vi(3));\n    vvi d(3);\n    rep(i,3){\n        dp0[0][i]=i;\n        dp1[0][i]=i;\n    }\n    rep(i,n)rep(j,3){\n        if(!v[i]){\n            dp0[i+1][j]=sw(dp0[i][j]);\n            dp1[i+1][j]=sw(dp1[i][j]);\n        }\n        else{\n            if(dp0[i][j]<2)dp0[i+1][j]=dp0[i][j]+1;\n            else{\n                dp0[i+1][j]=0;\n                d[j].pb(i+1);\n            }\n            dp1[i+1][j]=dp1[i][j];\n        }\n    }\n    vi ans(modpow(3,l));\n    rep(x,modpow(3,l)){\n        vi t(l);\n        ll k=x;\n        rep(i,l){\n            t[i]=k%3;\n            k/=3;\n        }\n        vi p;\n        rep(i,l){\n            vi np;\n            if(i==0){\n                for(auto y:d[t[i]]){\n                    np.pb(y);\n                }\n                ans[x]+=dp0[n][t[i]];\n            }\n            else{\n                for(auto y:p){\n                    ll nk=dp1[y][t[i]]+1;\n                    if(dp1[y][t[i]]==2){\n                        nk=0;np.pb(y);\n                    }\n                    rep(j,3)if(dp1[y][t[i]]==nk)t[i]=j;\n                }\n                ans[x]+=modpow(3,i)*dp1[n][t[i]];\n            }\n            p=np;\n        }\n    }\n    outv(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define pll pair <ll, ll>\n#define mp make_pair\n#define pyshnapyshnakaa ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define x first\n#define y second\n#pragma GCC optimize(\"O3\")\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n#define plll pair <ll, pair <ll, ll>>\n#define pllll pair <pair <ll, ll>, pair <ll, ll> >\n#define psl pair <string, ll>\n#define all(a) a.begin(), a.end()\n#define vvl vector <vector <ll> >\n\ntypedef long long ll;\n\ntypedef long double ld;\n\nusing namespace std;\n\nconst ll maxn = 6e5 + 10;\nconst ll maxm = 15;\n\nll n, m, k, t;\n\nvector <ll> P[maxn];\n\nll W[maxm][maxn];\n\nll st3[maxn];\n\nint main() {\n    pyshnapyshnakaa;\n    ll q, w, e, a, b, c;\n    st3[0] = 1;\n    for (q = 1; q < 20; q++) {\n        st3[q] = st3[q - 1] * 3;\n    }\n    cin >> n;\n    string s;\n    cin >> s;\n    P[0] = {0, 1, 2};\n    W[0][0] = 2;\n    for (q = 0; q < s.length(); q++) {\n        vector <ll> C(3);\n        for (w = 0; w < P[0].size(); w++) {\n            C[P[0][w]] = w;\n        }\n        if (s[q] == 'S') {\n            swap(P[0][C[1]], P[0][C[2]]);\n        }\n        else {\n            for (w = 0; w < P[0].size(); w++) {\n                P[0][w] = (P[0][w] + 1) % 3;\n            }\n        }\n        for (w = 0; w < P[0].size(); w++) {\n            C[P[0][w]] = w;\n        }\n        W[0][q + 1] = C[2];\n    }\n    // cout << \"STARTING: \" << endl;\n    // for (q = 0; q < P[0].size(); q++) {\n    //     cout << P[0][q] << endl;\n    // }\n    for (q = 1; q < n; q++) {\n        vector <ll> D(st3[q + 1]);\n        vector <ll> last(D.size());\n        W[q][0] = D.size() - 1;\n        // cout << W[q][0] << \" MXI0\" << endl;\n        ll cnts = 0;\n        for (w = 0; w < D.size(); w++) {\n            D[w] = w / st3[q];\n        }\n        for (w = 0; w < s.length(); w++) {\n            if (s[w] == 'R') {\n                ll i = W[q - 1][w];\n                for (ll j = i; j < st3[q + 1]; j += st3[q]) {\n                    D[j] = (D[j] + 1) % 3;\n                }\n            }\n            else {\n                cnts++;\n            }\n\n            ll i = W[q - 1][w + 1];\n            // cout << \"I \" << i << endl;\n            ll mxi = i;\n            for (ll j = i; j < st3[q + 1]; j += st3[q]) {\n                if ((cnts - last[j]) % 2 == 1) {\n                    if (D[j] != 0) {\n                        D[j] = 3 - D[j];\n                    }\n                }\n                last[j] = cnts;\n                if (D[j] == 2) {\n                    mxi = j;\n                }\n            }\n            W[q][w + 1] = mxi;\n            // cout << w + 1 << \" \" << mxi << \" MXI\" << endl;\n            // cout << D.size() << endl;\n            // for (e = 0; e < D.size(); e++) {\n            //     if ((cnts - last[j]) % 2 == 1) {\n\n            //     }\n            //     // P[q][w] = P[q - 1][w % st3[q]] + D[w] * st3[q];\n            //     cout << D[e] << \" \";\n            // }\n            // cout << endl;\n            // cout << endl;\n        }\n        P[q].resize(st3[q + 1]);\n        for (w = 0; w < P[q].size(); w++) {\n            if ((cnts - last[w]) % 2 == 1 && D[w] != 0) {\n                D[w] = 3 - D[w];\n            }\n            P[q][w] = P[q - 1][w % st3[q]] + D[w] * st3[q];\n            // cout << D[w] << \" \";\n        }\n        // cout << endl;\n    }\n    for (q = 0; q < P[n - 1].size(); q++) {\n        cout << P[n - 1][q] << \" \";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    vector<int> d23(531441);\n    vector<int> rumba(531441);\n\n    int N;\n    cin >> N;\n    N = (int)pow(3,N);\n    \n    int temp,add,now;\n    for(int i = 0 ; i < N ; i++){\n        temp = i;\n        add = 0;\n        now = 1;\n        while(temp != 0){\n            int a = temp % 3;\n            if(a == 1){\n                add += 2 * now;\n            }else if(a == 2){\n                add += now;\n            }\n            now *= 3;\n            temp /= 3;\n        }\n        d23.at(i) = add;\n    }\n\n    for(int i = 0 ; i < N ; i++){\n        rumba.at(i) = i + 1;\n    }\n    rumba.at(N - 1) = 0;\n\n\n    vector<int> hito1(531441);\n\n    for(int i = 0 ; i < N ; i++){\n        hito1.at(i) = i;\n    }\n\n\n    string T;\n    cin >> T;\n\n    int tSize = T.size();\n\n    for(int i = 0 ; i < tSize ; i++){\n        if(T.at(i) == 'S'){\n            for(int j = 0 ; j < N ; j++){\n                hito1.at(j) = d23.at(hito1.at(j));\n            }\n        }else{\n            for(int j = 0 ; j < N ; j++){\n                hito1.at(j)++;\n                if(hito1.at(j) == N){\n                    hito1.at(j) = 0;\n                }\n            }\n        }\n    }\n\n\n    \n    for(int i = 0 ; i < N - 1 ; i++){\n        cout << hito1.at(i) << ' ';\n    }\n    cout << hito1.at(N - 1) << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(void){\n    // Your code here!\n    int n;\n    string t;\n    cin >> n >> t;\n    \n    vector<int> p = {0};\n    for(int i = 1; i < pow(3, n); i++) p.push_back(i);\n    for(int i = 0; i < (int)t.size(); i++){\n        if(t[i] == 'R'){\n            for(int j = 0; j < pow(3, n); j++){\n                p.at(j) += 1;\n                if(p.at(j) == pow(3, n)) p.at(j) = 0;\n            }\n        }else{\n            for(int j = 0; j < pow(3, n); j++){\n                queue<int> new_pos;\n                int next = p.at(j);\n                p.at(j) = 0;\n                int three = 0;\n                while(1){\n                    int bit = next % 3;\n                    next = next / 3;\n                    switch(bit){\n                        case 0: break;\n                        case 1: bit = 2; break;\n                        case 2: bit = 1; break;\n                    }\n                    p.at(j) += pow(3, three)*bit;\n                    three += 1;\n                    if(next == 0) break;\n                }\n            }\n        }\n    }\n    for(int i = 0; i < pow(3, n); i++){\n        cout << p.at(i) << \" \";\n    }\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n \nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n\n#define MOD 1000000007LL\n\nint N;\nstring T;\nvector<int> p1,p2;\n//map<int, int> sa;\nvector<int> sa;\nint sp;\nint tn;\nint os;\n\nint conv(int);\nint tri(int n) {\n  int ans=1;\n  for (int i=0; i<n; i++) ans *= 3;\n  return ans;\n}\n\nvoid salsa();\nvoid rumba();\nvoid print_res();\nvoid print_res(int, int);\nvoid print_ln();\n\nint main()\n{\n  int l;\n  int i;\n\n  cin >> N >> T;\n  tn = tri(N);\n\n  p1.resize(tn);\n  p2.resize(tn);\n  sa.resize(tn);\n  for (int i=0; i<tn; i++) {\n    p1[i] = i;\n  }\n  sa[0] = 0; sa[1] = 2; sa[2]=1;\n  {\n    int t=3;\n    int cv;\n    for (int i=3; i<tn; i++) {\n      if (i>=t*3) t *= 3;\n      cv = sa[i%t];\n      switch(i/t) {\n      case 1: cv += t*2; break;\n      case 2: cv += t; break;\n      }\n      sa[i] = cv;\n    }\n  }\n\n//for (int i=0; i<tn; i++) printf(\"sa[%d]=%d\\n\", i, sa[i]);\n  p2[0] = p1[0];\n  sp = 1;\n\n//print_ln();\n\n  l = T.size();\n  for (i=0; i<l; i++) {\n    if (T[i] == 'S') {\n      if (T[i+1] == 'S') {\n        i++;\n        continue;\n      }\n      salsa();\n//printf(\"S \");\n//print_ln();\n    } else {\n      os+=tn-1;\n      os%=tn;\n//      rumba();\n//printf(\"R \");\n//print_ln();\n    }\n  }\n\n//print_ln();\n  print_res();\n//  print_res(0, 0);\n\n  return 0;\n}\nint conv(int inp) {\n  int cv=0;\n  int fx;\n  int t;\n\n  fx = inp;\n  for (t=1; t<inp; ) t*=3;\n  t/=3;\n  cv += sa[inp%t];\n  fx /= t;\n\n  for (; fx>0; t*=3) {\n    switch(fx % 3) {\n    case 1: cv += 2*t; break;\n    case 2: cv += t; break;\n    }\n    fx /= 3;\n  }\n  return cv;\n}\n\nvoid salsa() {\n  int i;\n\n  if (sp==1) {\n    for (i=0; i<tn; i++) {\n      p2[(sa[i]+os)%tn] = p1[(i+os)%tn];\n    }\n    sp = 2;\n  } else {\n    for (i=0; i<tn; i++) {\n      p1[(sa[i]+os)%tn] = p2[(i+os)%tn];\n    }\n    sp = 1;\n  }\n}\nvoid rumba() {\n  int i;\n  if (sp==1) {\n    for (i=0; i<tn-1; i++) {\n      p2[i+1]=p1[i];\n    }\n    p2[0] = p1[tn-1];\n    sp = 2;\n  } else {\n    for (i=0; i<tn-1; i++) {\n      p1[i+1]=p2[i];\n    }\n    p1[0] = p2[tn-1];\n    sp = 1;\n  }\n}\n\nvoid print_ln() {\n  int i;\n  if (sp == 1) {\n    printf(\"%d\", p1[0]);\n    for (i=1; i<tn; i++) printf(\" %d\", p1[i]);\n  } else {\n    printf(\"%d\", p2[0]);\n    for (i=1; i<tn; i++) printf(\" %d\", p2[i]);\n  }\n  printf(\"\\n\");\n}\nvoid print_res() {\n  int i;\n  map<int, int> m;\n  if (sp == 1) {\n    for (i=0; i<tn; i++)  m.emplace(p1[(i+os)%tn], i);\n  } else {\n    for (i=0; i<tn; i++)  m.emplace(p2[(i+os)%tn], i);\n  }\n  auto it=m.begin();\n  printf(\"%d\", it->second);\n  for (it++; it!=m.end(); it++) {\n    printf(\" %d\", it->second);\n  }\n  printf(\"\\n\");\n}\nvoid print_res(int p, int k) {\n  if (p1[k] < p) {\n    print_res(p-1, k+1);\n  } else if (p1[k] == p) {\n    printf(\"%d \", k);\n    print_res(p+1, k+1);\n  } else {\n    print_res(p+1, k+1);\n  }\n}\n/*\n  a*3^3+b*3^2+c*3+d\n  */\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nint main(){\n    int n;\n    std::string t;\n    std::cin>>n>>t;\n    int temp=1;\n    int zhishu[n];\n    for(int i=0;i<n;++i){\n        temp*=3;\n        zhishu[i]=temp;\n    }\n    const int num=temp;\n    int ans[num];\n    int sub[num];\n    int c[num][12];\n    for(int i=0;i<num;++i){\n        ans[i]=i;\n        sub[i]=0;\n        for(int j=11;j>=12-n;--j){\n            c[i][j]=0;\n        }\n    }\n    for(int i=1;i<num;++i){\n        for(int j=0;j<12;++j){\n            c[i][j]=c[i-1][j];\n        }\n        c[i][11]++;\n        int j=11;\n        while(c[i][j]>=3){\n            c[i][j]-=3;\n            j--;\n            c[i][j]++;\n        }\n    }\n    for(int i=0;i<num;++i){\n        for(int j=012-n;j<12;++j){\n            if(c[i][j]==2){\n                sub[i]+=zhishu[11-j];\n            }\n        }\n    }\n    for(int i=0;i<t.size();++i){\n        if(t[i]=='S'){\n            for(int j=0;j<num;++j){\n                temp=ans[j];\n                ans[j]=2*temp-sub[temp];\n            }\n        }\n        else{\n            for(int j=0;j<num;++j){\n                ans[j]++;\n                if(ans[j]==num){\n                    ans[j]=0;\n                }\n            }\n        }\n    }\n    std::cout<<ans[0];\n    for(int i=1;i<num;++i){\n        std::cout<<\" \"<<ans[i];\n    }\n    std::cout<<std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n \nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n\n#define MOD 1000000007LL\n\nint N;\nstring T;\nvector<int> p1,p2;\nmap<int, int> sa;\nint sp;\nint tn;\n\nint conv(int);\nint tri(int n) {\n  int ans=1;\n  for (int i=0; i<n; i++) ans *= 3;\n  return ans;\n}\n\nvoid salsa();\nvoid rumba();\nvoid print_res();\nvoid print_ln();\n\nint main()\n{\n  int l;\n  int i;\n\n  cin >> N >> T;\n  tn = tri(N);\n\n  p1.resize(tn);\n  p2.resize(tn);\n  for (int i=0; i<tn; i++) p1[i] = i;\n  p2[0] = p1[0];\n  sp = 1;\n\n//print_ln();\n\n  l = T.size();\n  for (i=0; i<l; i++) {\n    if (T[i] == 'S') {\n      salsa();\n//printf(\"S \");\n//print_ln();\n    } else {\n      rumba();\n//printf(\"R \");\n//print_ln();\n    }\n  }\n\n  print_res();\n\n  return 0;\n}\nint conv(int inp) {\n  int cv=0;\n  int t;\n  auto it = sa.find(inp);\n  if (it != sa.end()) return it->second;\n\n  for (t=1; inp>0; t*=3) {\n    switch(inp % 3) {\n    case 1: cv += 2*t; break;\n    case 2: cv += t; break;\n    }\n    inp /= 3;\n  }\n  sa.emplace(inp, cv);\n  return cv;\n}\n\nvoid salsa() {\n  int i;\n\n  if (sp==1) {\n    for (i=0; i<tn; i++) {\n      p2[conv(i)] = p1[i];\n    }\n    sp = 2;\n  } else {\n    for (i=0; i<tn; i++) {\n      p1[conv(i)] = p2[i];\n    }\n    sp = 1;\n  }\n}\nvoid rumba() {\n  int i;\n  if (sp==1) {\n    for (i=0; i<tn-1; i++) {\n      p2[i+1]=p1[i];\n    }\n    p2[0] = p1[tn-1];\n    sp = 2;\n  } else {\n    for (i=0; i<tn-1; i++) {\n      p1[i+1]=p2[i];\n    }\n    p1[0] = p2[tn-1];\n    sp = 1;\n  }\n}\n\nvoid print_ln() {\n  int i;\n  if (sp == 1) {\n    printf(\"%d\", p1[0]);\n    for (i=1; i<tn; i++) printf(\" %d\", p1[i]);\n  } else {\n    printf(\"%d\", p2[0]);\n    for (i=1; i<tn; i++) printf(\" %d\", p2[i]);\n  }\n  printf(\"\\n\");\n}\nvoid print_res() {\n  int i;\n  map<int, int> m;\n  if (sp == 1) {\n    for (i=0; i<tn; i++)  m.emplace(p1[i], i);\n  } else {\n    for (i=0; i<tn; i++)  m.emplace(p2[i], i);\n  }\n  auto it=m.begin();\n  printf(\"%d\", it->second);\n  for (it++; it!=m.end(); it++) {\n    printf(\" %d\", it->second);\n  }\n  printf(\"\\n\");\n}\n/*\n  a*3^3+b*3^2+c*3+d\n  */\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint pow(int b, int e) {\n\tif (e == 1) {\n\t\treturn b;\n\t}\n\telse {\n\t\treturn(pow(b, e - 1) * b);\n\t}\n}\n\nint trt(int t, int n) {\n\tif (t / n == 0) return t;\n\tint x = (t % (n * 3)) / n;\n\tint y = (x == 1) ? 2 : ((x == 2) ? 1 : 0);\n\treturn trt(t - x * n + y * n, n * 3);\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\tint M = pow(3, N);\n\tqueue<int> RS;\n\tchar *s = new char[200001];\n\tcin >> s;\n\tchar* p = s;\n\tint sw = 0;\n\tint c = 1;\n\tbool f = true;\n\twhile(f) { // R = 82 = 平行移動, S = 83 = 3置換\n\t\tif (*p == sw) {\n\t\t\tc++;\n\t\t}\n\t\telse {\n\t\t\tif (sw == 83) {\n\t\t\t\tif (c % 2 == 1) {\n\t\t\t\t\tRS.push(-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (sw == 82) {\n\t\t\t\tRS.push(c);\n\t\t\t}\n\t\t\tc = 1;\n\t\t\tsw = *p;\n\t\t}\n\t\tif (*p == '\\0') break;\n\t\tp++;\n\t}\n\n\tvector<int> A(M, 0); // current status\n\tfor (int i = 0; i < M; i++) A[i] = i;\n\tdeque<pair<int,int> > P; // 置換index\n\n\t// swap set\t作成\n\tvector<int> W(M, 0);\n\tfor (int i = 0; i < M; i++){\n\t\tif(W[i] == 0){\n\t\t\tint j = trt(i, 1);\n\t\t\tW[i] = j;\n\t\t\tW[j] = i;\n\t\t\tP.push_back(pair<int, int>(i, j));\n\t\t}\n\t}\n//\tfor (auto it = P.begin(); it != P.end(); it++) {\n//\t\tcout << \"P:\" << it->first << \",\" << it->second << endl;\n//\t}\n\n\t// calc\n\tint x = 0; // 0位置を示す\n//\tfor (int i = 0; i < M; i++) {\n//\t\tcout << A[(i + x) % M] << \" \";\n//\t}\n//\tcout << endl;\n\twhile (!RS.empty()) {\n\t\tint rs = RS.front();\n\t\tRS.pop();\n\t\tif (rs == -1) {\n\t\t\t// 置換\n\t\t\tfor (auto it = P.begin(); it != P.end(); it++) {\n\t\t\t\tswap(A[(x + it->first) % M], A[(x + it->second) % M]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tx = (((x - rs) % M) + M) % M;\n\t\t}\n\t\t// out\n//\t\tcout << rs << \": \";\n//\t\tfor (int i = 0; i < M; i++) {\n//\t\t\tcout << A[(i + x) % M] << \" \";\n//\t\t}\n//\t\tcout << endl;\n\n\t}\n\n\t// out\n\tvector<int> B(M, 0); // A[i] = i番目のセルにいる人の名前 -> B[i] = iさんがB[i]にいる\n\tfor (int i = 0; i < M; i++) {\n\t\tB[A[(i + x) % M]] = i;\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tcout << B[i] << \" \";\n\t}\n\tcout << endl;\n\treturn(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar T[550005];\nint salsa2[550005];\nint salsaNext[550005];\nint p[550005];\n\n// Based on editorial solution\nint D[13][550005]; // one digit at a time, with digit 0 representing the ones place\nint W[13][550005];\nint lastUpdated[13][550005];\n\nint N;\n\nint salsa(int x){\n    int temp = x;\n    int pow3 = 1;\n    int res = 0;\n    for(int i = 0; i < N; i ++){\n        int k = temp%3;\n        temp /= 3;\n\n        if(k == 1){\n            res += pow3*2;\n        }else if(k == 2){\n            res += pow3;\n        }\n        pow3 *= 3;\n    }\n    return res;\n}\n\nvoid update(int n, int indx, int cntS){\n    if((cntS&1) != (lastUpdated[n][indx]&1)){\n        // conduct salsa\n        if(D[n][indx] == 1){\n            D[n][indx] = 2;\n        }else if(D[n][indx] == 2){\n            D[n][indx] = 1;\n        }\n    }\n    // updated the lastUpdated index\n    lastUpdated[n][indx] = cntS;\n}\n\nint digits[15];\nvoid printBase3(int x, int N){\n    for(int i = 0; i < N; i ++){\n        digits[i] = x%3;\n        x /= 3;\n    }\n    for(int i = N-1; i >= 0; i --){\n        printf(\"%d\", digits[i]);\n    }\n}\n\nint pow3[16];\n\nint main(){\n    scanf(\"%d\", &N);\n\n    scanf(\" %s\", T);\n\n    int M = strlen(T);\n\n    pow3[0] = 1;\n    for(int i = 1; i <= N; i ++){\n        pow3[i] = pow3[i-1]*3;\n    }\n\n    int pow3N = pow3[N];\n\n    for(int i = 0; i < pow3N; i ++){\n        salsa2[i] = salsa(i);\n        //printf(\"salsa2[%d]=%d\\n\", i, salsa2[i]);\n    }\n\n    for(int n = 0; n < N; n ++){\n        for(int j = 0; j < pow3[N]; j ++){\n            D[n][j] = (j%pow3[n+1])/pow3[n];\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        W[n][0] = pow3[n+1]-1;\n    }\n\n\n    memset(lastUpdated, 0, sizeof(lastUpdated));\n    int cntS2 = 0;\n    for(int n = 0; n < N; n ++){\n        int cntS = 0;\n        for(int i = 0; i < M; i ++){\n            if(T[i] == 'S'){\n                W[n][i+1] = salsa2[W[n][i]];\n            }else if(T[i] == 'R'){\n                int temp = (W[n][i]-1);\n                if(temp < 0){temp += pow3[n+1];}\n                if(temp >= pow3[n+1]){temp -= pow3[n+1];}\n                W[n][i+1] = temp;\n            }\n\n            //printf(\"W[%d][%d]=%d\\n\", n, i+1, W[n][i+1]);\n\n            int indx0 = W[n][i];\n            int indx1 = (W[n][i]+pow3[n])%pow3[n+1];\n            int indx2 = (W[n][i]+2*pow3[n])%pow3[n+1];\n            //printf(\"W(%d, %d): %d %d %d cntS=%d\\n\", n, i, indx0, indx1, indx2, cntS);\n            update(n, indx0, cntS+(T[i]=='S'));\n            update(n, indx1, cntS+(T[i]=='S'));\n            update(n, indx2, cntS+(T[i]=='S'));\n            if(T[i] == 'R'){\n                D[n][indx0] = (D[n][indx0]+1)%3;\n                D[n][indx1] = (D[n][indx1]+1)%3;\n                D[n][indx2] = (D[n][indx2]+1)%3;\n                lastUpdated[n][indx0] = cntS;\n                lastUpdated[n][indx1] = cntS;\n                lastUpdated[n][indx2] = cntS;\n            }\n\n            if(T[i] == 'S'){\n                cntS ++;\n            }\n        }\n\n        cntS2 = cntS;\n    }\n\n    for(int n = 0; n < N; n ++){\n        for(int i = 0; i < pow3[N]; i ++){\n            update(n, i, cntS2);\n        }\n    }\n\n    for(int i = 0; i < pow3[N]; i ++){\n        int temp = 0;\n        for(int n = 0; n < N; n ++){\n            temp += D[n][i%pow3[n+1]]*pow3[n];\n        }\n        //printf(\"i=%d W[N-1][M]=%d temp=%d\\n\", i, W[N-1][M], temp);\n        if(i == W[N-1][M]){\n            if(temp != pow3[N]-1){\n                exit(1);\n            }\n        }\n        printf(\"%d \", temp);\n    }\n\n    /*printf(\"\\n\");\n    for(int i = 0; i < pow3[N]; i ++){\n        int temp = 0;\n        for(int n = 0; n < N; n ++){\n            temp += D[n][i%pow3[n+1]]*pow3[n];\n        }\n        printBase3(temp, N);\n        printf(\"\\n\");\n    }*/\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ljc 998244353\nusing namespace std;\n#define gc getchar\ninline ll read(){\n    register ll x=0,f=1;char ch=gc();\n    while (!isdigit(ch)){if (ch=='-') f=-1;ch=gc();}\n    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}\n    return (f==1)?x:-x;\n}\nstruct node{\n\tint son[3],tag,id;\n}g[531444*13];\nint n,pw[531444],cnt,ans[531444];\nchar s[531444]; \nvoid build(int &rt,int D,int x){\n\trt=++cnt;\n\tif (D==n) return (void)(g[rt].id=x);\n\tbuild(g[rt].son[0],D+1,x);\n\tbuild(g[rt].son[1],D+1,x+pw[D]);\n\tbuild(g[rt].son[2],D+1,x+pw[D]*2);\n}\ninline void pushdown(int rt){\n\tif (g[rt].tag){\n\t\tg[g[rt].son[0]].tag^=1;\n\t\tg[g[rt].son[1]].tag^=1;\n\t\tg[g[rt].son[2]].tag^=1;\n\t\tg[rt].tag=0;\n\t\tswap(g[rt].son[1],g[rt].son[2]);\n\t}\n}\nvoid addone(int rt,int D){\n\tif (D==n) return;\n\tpushdown(rt);\n\tswap(g[rt].son[0],g[rt].son[1]);\n\tswap(g[rt].son[0],g[rt].son[2]);\n\taddone(g[rt].son[0],D+1);\n}\nvoid release(int rt,int D,int x){\n\tif (D==n) return (void)(ans[g[rt].id]=x);\n\tpushdown(rt);\n\trelease(g[rt].son[0],D+1,x);\n\trelease(g[rt].son[1],D+1,x+pw[D]);\n\trelease(g[rt].son[2],D+1,x+pw[D]*2);\n}\nsigned main(){\n\tn=read();\n\tpw[0]=1;\n\tfor (int i=1;i<=n;i++) pw[i]=pw[i-1]*3;\n\tint ROOT;\n\tbuild(ROOT,0,0);\n\tscanf(\"%s\",s+1);\n\tint T=strlen(s+1);\n\tfor (int i=1;i<=T;i++){\n\t\tif (s[i]=='S'){\n\t\t\tg[1].tag^=1;\n\t\t}else{\n\t\t\taddone(1,0);\n\t\t}\n\t}\n\trelease(1,0,0);\n\tfor (int i=0;i<pw[n];i++){\n\t\tprintf(\"%d \",ans[i]);\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool bo,boo;\nint ans[600010],A,B,n,f[600010],g[600010],len,nw;\nchar s[200010];\n\nint main()\n{\n\tscanf(\"%d%s\",&n,s),len=strlen(s),A=B=1;\n\tfor (int i=1; i<=(n+1)/2; i++) A*=3;\n\tfor (int i=(n+1)/2; i<n; i++) B*=3;\n\tfor (int i=0; i<A*B; i++) f[i]=f[i/3]*3+(i*2%3),g[i]=(i+1)%(A*B);\n\tfor (int i=0; i<A; i++)\n\t{\n\t\tnw=i,bo=0,boo=0;\n\t\tfor (int j=0; j<len; j++)\n\t\t\tif (s[j]=='R') nw=g[nw],boo|=(nw>=A); else nw=f[nw],bo^=1;\n\t\tif (!boo) {for (int j=0; j<B; j++) ans[j*A+i]=(bo?f[j]:j)*A+nw;} else\n\t\t{\n\t\t\tans[i]=nw;\n\t\t\tfor (int j=1; j<B; j++)\n\t\t\t{\n\t\t\t\tnw=j*A+i;\n\t\t\t\tfor (int k=0; k<len; k++)\n\t\t\t\t\tif (s[k]=='R') nw=g[nw]; else nw=f[nw];\n\t\t\t\tans[j*A+i]=nw;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=0; i<A*B; i++) printf(\"%d \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 23.05.2020 15:42:46       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  string s;\n  cin >> s;\n  int len = (int) s.size();\n  vector<int> pref(len + 1);\n  for (int i = 0; i < len; i++) {\n    pref[i + 1] = pref[i] + (s[i] == 'S');\n  }\n  vector<int> to(1, 0);\n  vector<vector<int>> inc(1);\n  for (int i = 0; i < len; i++) {\n    if (s[i] == 'R') {\n      inc[0].push_back(i);\n    }\n  }\n  for (int it = 0; it < n; it++) {\n    int sz = (int) inc.size();\n    vector<int> new_to(3 * sz);\n    vector<vector<int>> new_inc(3 * sz);\n    for (int r = 0; r < sz; r++) {\n      for (int start = 0; start < 3; start++) {\n        int dig = start;\n        int last = -1;\n        for (int pos : inc[r]) {\n          int flips = pref[pos] - pref[last + 1];\n          if (dig != 0 && flips % 2 == 1) {\n            dig = 3 - dig;\n          }\n          if (dig == 2) {\n            new_inc[start * sz + r].push_back(pos);\n          }\n          dig = (dig + 1) % 3;\n          last = pos;\n        }\n        int flips = pref.back() - pref[last + 1];\n        if (dig != 0 && flips % 2 == 1) {\n          dig = 3 - dig;\n        }\n        new_to[start * sz + r] = dig * sz + to[r];\n      }\n    }\n    swap(to, new_to);\n    swap(inc, new_inc);\n  }\n  for (int i = 0; i < (int) to.size(); i++) {\n    if (i > 0) {\n      cout << \" \";\n    }\n    cout << to[i];\n  }\n  cout << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#include<chrono>\n#include<random>\n#include<iostream>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\n#define VI vector<int>\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int MAXN=2050005;\nconst int MAXV=12;\nint bin[15];\nint n,m,ans[MAXN];\nstruct Trie\n{\n\tint son[MAXN][3],tot,root;\n\tint val[MAXN];\n\tbool rev[MAXN];\n\tvoid insert(int v)\n\t{\n\t\tint p=root;\n\t\tfor(int i=0;i<=n-1;i++)\n\t\t{\n\t\t\tint c=v/bin[i];c%=3;\n\t\t\tif(!son[p][c])son[p][c]=++tot;\n\t\t\tp=son[p][c];\n\t\t}val[p]=v;\n\t}\n\tvoid down(int p)\n\t{\n\t\tif(!rev[p])return ;\n\t\tswap(son[p][1],son[p][2]);\n\t\trev[son[p][0]]^=1;rev[son[p][1]]^=1;rev[son[p][2]]^=1;rev[p]=0;\n\t}\n\tvoid addone(int p,int dep)\n\t{\n\t\tif(dep==0)return ;\n\t\tdown(p);int a=son[p][0],b=son[p][1],c=son[p][2];\n\t\tson[p][0]=c;son[p][1]=a;son[p][2]=b;\n\t\taddone(son[p][0],dep-1);\n\t}\n\tvoid getans(int p,int dep,int nowp)\n\t{\n\t\tif(dep==n){ans[val[p]]=nowp;return ;}\n\t\tdown(p);\n\t\tgetans(son[p][0],dep+1,nowp);\n\t\tgetans(son[p][1],dep+1,nowp+bin[dep]);\n\t\tgetans(son[p][2],dep+1,nowp+2*bin[dep]);\n\t}\n}tr;\nchar ch[MAXN];\nint main()\n{\n\t#ifdef Rose\n\t\tdouble BeginJudgeTime=clock();\n\t#endif\n\tbin[0]=1;for(int i=1;i<15;i++)bin[i]=bin[i-1]*3;\n\tn=read();\n\tscanf(\"%s\",ch+1);m=strlen(ch+1);\n\ttr.tot=tr.root=1;\n\tfor(int i=0;i<bin[n];i++)\n\t\ttr.insert(i);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(ch[i]=='S')tr.rev[1]^=1;\n\t\telse tr.addone(1,n);\n\t}\n\ttr.getans(1,0,0);\n\tfor(int i=0;i<bin[n];i++)pr1(ans[i]);\n\tputs(\"\");\n\t#ifdef Rose\n\t\tdouble EndJudgeTime=clock();\n\t\tcerr<<\"JudgeTime is\"<<\" \";\n\t\tcerr<<(EndJudgeTime-BeginJudgeTime)/CLOCKS_PER_SEC<<endl;\n\t#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n\nusing namespace std;\n\nconst int FIVE = 243, SEVEN = 2187;\nconst int N = 200007;\n\nint go[SEVEN][2];\n\nint recon(vector<int> v) {\n\tint a = 0, deg = 1;\n\tfor (int i = 0; i < 7; ++i) {\n\t\ta += deg*v[i];\n\t\tdeg *= 3;\n\t}\n\treturn a;\n}\n\nint go1(vector<int> a) {\n\n\ta[0]++;\n\tfor (int i = 0; i < 7; ++i) {\n\t\tif (a[i]==3) {\n\t\t\ta[i] = 0;\n\t\t\tif (i < 6) a[i+1]++;\n\t\t}\n\t\t//cout << a[i] << \" \";\n\t}\n\n\n\treturn recon(a);\n\n}\n\nint go2(vector<int> a) {\n\n\tfor (int i = 0; i < 7; ++i) {\n\t\tif (a[i]==1 || a[i]==2) {\n\t\t\ta[i] = 3-a[i];\n\t\t}\n\t}\n\n\treturn recon(a);\n\n}\n\nint closest_zero[N];\nint go_zero[N];\n\nint cur_closest_zero[SEVEN];\nint go_finish[SEVEN];\n\nint spec[SEVEN];\n\nstring s;\nvector<int> pref;\n\nint get(int was, int l, int r) {\n\tint cnt = pref[r+1] - pref[l];\n\tif (cnt % 2 == 0) return was;\n\n\twas = go[was][1];\n\twas %= FIVE;\n\treturn was;\n\n}\n\nint main(){\n#ifdef LOCAL\n\tfreopen(\"C_input.txt\", \"r\", stdin);\n\t//freopen(\"C_output.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tcin >> s;\n\n\tpref.push_back(0);\n\tfor (int i = 0; i < s.size(); ++i) {\n\t\tpref.push_back(pref.back() + (s[i] == 'S'));\n\t}\n\n\tfor (int i = 0; i < SEVEN; ++i) {\n\n\t\tvector<int> w;\n\t\tint Q = i;\n\t\tfor (int j = 0; j < 7; ++j) {\n\t\t\tw.push_back(Q%3);\n\t\t\tQ /= 3;\n\t\t}\n\n\t\tint a = go1(w);\n\t\tint b = go2(w);\n\n\t\t//if (i==2) exit(0);\n\n\t\tgo[i][0] = a, go[i][1] = b;\n\n\t}\n\n\tfor (int i = 0; i < SEVEN; ++i) {\n\t\tgo_finish[i] = i;\n\t\tcur_closest_zero[i] = 1;\n\t}\n\n\tfor (int i = s.size() - 1; i >= 0; i--) {\n\t\tint code;\n\t\tif (s[i] == 'S') code = 1;\n\t\telse code = 0;\n\n\t\tfor (int j = 0; j < SEVEN; ++j) {\n\t\t\tint be = go[j][code];\n\t\t\tif (be == 0 && s[i] == 'R') {\n\t\t\t\tspec[j] = 1;\n\t\t\t}\n\t\t\telse spec[j] = cur_closest_zero[j]+1;\n\t\t}\n\n\t\tfor (int j = 0; j < SEVEN; ++j) cur_closest_zero[j] = spec[j];\n\n\t\tfor (int j = 0; j < SEVEN; ++j) {\n\t\t\tint be = go[j][code];\n\t\t\tspec[j] = go_finish[be];\n\t\t}\n\n\t\tfor (int j = 0; j < SEVEN; ++j) go_finish[j] = spec[j];\n\t\tclosest_zero[i] = cur_closest_zero[0];\n\t\tgo_zero[i] = go_finish[0];\n\n\t\t//cout << go_finish[0] << \" \" << go_finish[1] << \" \" << go_finish[2] << endl;\n\n\t}\n\n\tint kek = 1;\n\tfor (int i = 0; i < 12; ++i) kek *= 3;\n\n\tvector<int> ans(kek);\n\n\tfor (int i = 0; i < kek; ++i) {\n\n\t\tint sht = i%SEVEN, lng = i/SEVEN;\n\t\tint left = s.size();\n\n\n\t\tint C = cur_closest_zero[sht];\n\t\tif (C > left) {\n\t\t\tsht = go_finish[sht];\n\t\t\tleft = 0;\n\t\t\tlng = get(lng, 0, s.size()-1);\n\t\t}\n\n\t\telse {\n\t\t\tsht = 0;\n\t\t\tleft -= C;\n\t\t\tlng = get(lng, 0, C-1);\n\t\t\tlng = (go[lng][0]) % FIVE;\n\t\t}\n\n\t\twhile (left) {\n\t\t\tint have = closest_zero[s.size() - left];\n\t\t\tif (have > left) {\n\t\t\t\tsht = go_zero[s.size() - left];\n\t\t\t\tleft = 0;\n\t\t\t\tlng = get(lng, s.size()-left, s.size()-1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsht = 0;\n\t\t\t\tlng = get(lng, s.size()-left, s.size()-(left-have)-1);\n\t\t\t\tleft -= have;\n\t\t\t\tlng = (go[lng][0]) % FIVE;\n\t\t\t}\n\t\t}\n\n\t\tans[i] = sht + SEVEN*lng;\n\t}\n\n\tint Q = 1;\n\tfor (int i = 0; i < n; ++i) Q *= 3;\n\n\tfor (int i = 0; i < Q; ++i) {\n\t\tcout << ans[i] % Q << \" \";\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar T[550005];\nint salsa2[550005];\nint salsaNext[550005];\nint p[550005];\n\nint N;\n\nint salsa(int x){\n    int temp = x;\n    int pow3 = 1;\n    int res = 0;\n    for(int i = 0; i < N; i ++){\n        int k = temp%3;\n        temp /= 3;\n\n        if(k == 1){\n            res += pow3*2;\n        }else if(k == 2){\n            res += pow3;\n        }\n        pow3 *= 3;\n    }\n    return res;\n}\n\nint main(){\n    scanf(\"%d\", &N);\n\n    scanf(\" %s\", T);\n\n    int M = strlen(T);\n\n    int pow3N = 1;\n    for(int i = 0; i < N; i ++){\n        pow3N *= 3;\n    }\n\n    for(int i = 0; i < pow3N; i ++){\n        salsa2[i] = salsa(i);\n        //printf(\"salsa2[%d]=%d\\n\", i, salsa2[i]);\n    }\n\n    for(int j = 0; j < pow3N; j ++){\n        int x = j;\n        for(int i = 0; i < M; i ++){\n            if(T[i] == 'R'){\n                x ++;\n                if(x == pow3N){\n                    x = 0;\n                }\n            }else if(T[i] == 'S'){\n                x = salsa2[x];\n            }\n        }\n        p[j] = x;\n    }\n\n    for(int i = 0; i < pow3N; i ++){\n        printf(\"%d \", p[i]);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\n#define TRACE(x) std::cout << #x << \" = \" << x << \"\\n\"\n#define _ << \" _ \" <<\n\nusing namespace std;\n\nvector<int> prepNext(int K) {\n  int sz = 1;\n  for (int i = 0; i < K; ++i) sz *= 3;\n\n  vector<int> ret(sz);\n  for (int m12 = 0; m12 < (1 << K); ++m12) {\n    for (int m1 = m12;; m1 = (m1 - 1) & m12) {\n      int x = 0, y = 0, pw = 1;\n      for (int i = 0; i < K; ++i, pw *= 3) {\n        if (m12 & (1 << i)) {\n          if (m1 & (1 << i))\n            x += pw, y += 2 * pw;\n          else\n            x += 2 * pw, y += pw;\n        }\n      }\n      ret[x] = y;\n      if (m1 == 0) break;\n    }\n  }\n  return ret;\n}\n\nint main() {\n  std::ios_base::sync_with_stdio(false);\n  int N;\n  string T;\n  cin >> N >> T;\n\n  int K = (N + 1) / 2;\n  vector<int> next = prepNext(K);\n  int H = next.size();\n\n  int M = 1;\n  for (int i = 0; i < N; ++i) M *= 3;\n\n  vector<int> Plo(H);\n  for (int i = 0; i < H; ++i) Plo[i] = i;\n\n  vector<int> Phi(M), Shi(M);\n  for (int i = 0; i < M; ++i) {\n    Phi[i] = i / H;\n    Shi[i] = 0;\n  }\n\n  int swapsCnt = 0;\n  for (char c : T) {\n    if (c == 'S') {\n      for (auto& x : Plo) x = next[x];\n      swapsCnt++;\n    } else {\n      int x = -1;\n      for (int i = 0; i < H; ++i) {\n        Plo[i]++;\n        if (Plo[i] == H) {\n          Plo[i] = 0;\n          assert(x == -1);\n          x = i;\n        }\n      }\n      assert(x != -1);\n\n      for (int y = 0; y * H + x < M; ++y) {\n        int v = y * H + x;\n        if (Shi[v] % 2 != swapsCnt % 2) {\n          Phi[v] = next[Phi[v]];\n          Shi[v] = swapsCnt;\n        }\n        Phi[v]++;\n        if (Phi[v] * H == M) Phi[v] = 0;\n      }\n    }\n  }\n\n  for (int i = 0; i < M; ++i) {\n    if (Shi[i] % 2 != swapsCnt % 2) {\n      Phi[i] = next[Phi[i]];\n    }\n    int ans = Phi[i] * H + Plo[i % H];\n    cout << ans << ' ';\n  }\n  cout << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<deque>\n#include<iomanip>\n#include<tuple>\n#include<cassert>\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<int,int> P;\ntypedef pair<LL,int> LP;\nconst int INF=1<<30;\nconst LL MAX=1e9+7;\n\nvoid array_show(int *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%d%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\nvoid array_show(LL *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%lld%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\nvoid array_show(vector<int> &vec_s,int vec_n=-1,char middle=' '){\n\tif(vec_n==-1)vec_n=vec_s.size();\n\tfor(int i=0;i<vec_n;i++)printf(\"%d%c\",vec_s[i],(i!=vec_n-1?middle:'\\n'));\n}\nvoid array_show(vector<LL> &vec_s,int vec_n=-1,char middle=' '){\n\tif(vec_n==-1)vec_n=vec_s.size();\n\tfor(int i=0;i<vec_n;i++)printf(\"%lld%c\",vec_s[i],(i!=vec_n-1?middle:'\\n'));\n}\n\nvector<vector<int>> v1[13];\nvector<vector<int>> vs;\n\nint main(){\n\tint n,m;\n\tint i,j,k;\n\tint a,b,c;\n\ta=0;\n\tstring sa;\n\tcin>>n;\n\tcin>>sa;\n\tv1[0].push_back(vector<int>());\n\tfor(i=0;i<sa.size();i++){\n\t\tif(sa[i]=='R')a++;\n\t\telse if(i+1<sa.size() && sa[i+1]=='S')i++;\n\t\telse{\n\t\t\tv1[0][0].push_back(a);\n\t\t\ta=0;\n\t\t}\n\t}\n\tv1[0][0].push_back(a);\n\tvs.push_back(vector<int>(1,0));\n\n\tfor(i=0;i<n;i++){\n\t\tc=pow(3,i);\n\t\tvs.push_back(vector<int>());\n\t\tfor(j=0;j<v1[i].size();j++){\n\t\t\tfor(k=0;k<3;k++){\n\t\t\t\tv1[i+1].push_back(vector<int>());\n\t\t\t\ta=k;\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(auto node:v1[i][j]){\n\t\t\t\t\tif(cnt && a>0)a=3-a;\n\t\t\t\t\ta+=node,cnt++;\n\t\t\t\t\tb=a/3,a%=3;\n\t\t\t\t\tif(b==0 && !v1[i+1].back().empty() && v1[i+1].back().back()==0){\n\t\t\t\t\t\tv1[i+1].back().pop_back();\n\t\t\t\t\t}else v1[i+1].back().push_back(b);\n\t\t\t\t}\n\t\t\t\tvs[i+1].push_back(vs[i][j]+c*a);\n\t\t\t}\n\t\t}\n\t}\n\n\tc=pow(3,n);\n\tvector<int> v2(c,-1);\n\tvector<int> vt(n,0);\n\tfor(i=0;i<c;i++){\n\t\ta=0;\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(vt[j]>=3)vt[j]-=3,vt[j+1]++;\n\t\t\ta*=3;\n\t\t\ta+=vt[j];\n\t\t}\n\t\tv2[a]=vs[n][i];\n\t\tvt[0]++;\n\t}\n\tarray_show(v2);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate <class T>\nusing V = vector<T>;\ntemplate <class T>\nusing VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for (int i = m; i < (n); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n\ntemplate <class T, class U>\nvoid chmin(T& t, const U& u) {\n    if (t > u) t = u;\n}\ntemplate <class T, class U>\nvoid chmax(T& t, const U& u) {\n    if (t < u) t = u;\n}\n\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"{\";\n    rep(i, v.size()) {\n        if (i) os << \",\";\n        os << v[i];\n    }\n    os << \"}\";\n    return os;\n}\n\n#ifdef LOCAL\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << H;\n    debug_out(T...);\n}\n#define debug(...) \\\n    cerr << __LINE__ << \" [\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else\n#define debug(...) (void(0))\n#define dump(x) (void(0))\n#endif\n\nstring norm(string s) {\n    string t;\n    for (char c : s) {\n        if (c == 'R') {\n            t.pb(c);\n        } else {\n            if (t.size() && t.back() == c) {\n                t.pop_back();\n            } else {\n                t.pb(c);\n            }\n        }\n    }\n    return t;\n}\n\nint N;\nll ans[550000];\nll pre[15], cur[15];\nll p3[15];\n\nvoid calc() {\n    ll a = 0, b = 0;\n    rep(i, N) {\n        a += pre[i] * p3[i];\n        b += cur[i] * p3[i];\n    }\n    ans[a] = b;\n}\n\nvoid solve(int p, string T) {\n    if (p == N) {\n        calc();\n        return;\n    }\n    rep(c, 3) {\n        pre[p] = c;\n        string nx;\n        int x = c;\n        for (auto t : T) {\n            if (t == 'S') {\n                nx.pb(t);\n                if (x != 0) {\n                    x = 3 - x;\n                }\n            } else {\n                ++x;\n                if (x == 3) {\n                    x = 0;\n                    nx.pb(t);\n                }\n            }\n        }\n        cur[p] = x;\n        solve(p + 1, norm(nx));\n    }\n}\n\nint main() {\n    cin >> N;\n    string T;\n    cin >> T;\n\n    p3[0] = 1;\n    rep(i, N) { p3[i + 1] = p3[i] * 3; }\n    solve(0, norm(T));\n    rep(i, p3[N]) cout << ans[i] << (i == p3[N] - 1 ? '\\n' : ' ');\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<windows.h>\nusing namespace std;\n#define int long long\n#define re register\nint n,a,b,c,d,f,tot;\ninline long long as(re long long x){\n\treturn x<0?-x:x;\n}\nmap<int,int>v;\ninline int dfs(re int x){\n\tif(x==0)return 0;if(x==1)return d;\n\tif(v.find(x)!=v.end())return v[x];\n\tre int ans=min(9e18,(double)x*d);\n\tans=min(ans,dfs(x/5)+c+(x%5)*d);\n\tans=min(ans,dfs(x/5+1)+c+(5-x%5)*d);\n\tans=min(ans,dfs(x/3)+b+(x%3)*d);\n\tans=min(ans,dfs(x/3+1)+b+(3-x%3)*d);\n\tans=min(ans,dfs(x/2)+a+(x%2)*d);\n\tif(x!=2)\n\tans=min(ans,dfs(x/2+1)+a+(2-x%2)*d);\n\treturn v[x]=ans;\n}\nsigned main(){\n\tint t;\n\tscanf(\"%lld\",&t);\n\twhile(t--){\n\tscanf(\"%lld%lld%lld%lld%lld\",&n,&a,&b,&c,&d);tot=0;v.clear();\n\tprintf(\"%lld\\n\",dfs(n)); \n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(_i,_a,_n) for(int _i=_a;_i<=_n;++_i)\n#define PER(_i,_a,_n) for(int _i=_n;_i>=_a;--_i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(_a) ({REP(_i,1,n) cout<<_a[_i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\n\n\n#ifdef __APPLE__\nconst int N = 1e2+50;\n#else\nconst int N = 1e6+50;\n#endif\n\n\nint n,m,T,tot,pw[N],ans[N];\nstruct {int ch[3],id,tag;} tr[N];\nchar s[N];\nvoid build(int &o, int d, int x) {\n\to=++tot;\n\tif (d==n) { \n\t\treturn tr[o].id=x,void();\n\t}\n\tREP(i,0,2) build(tr[o].ch[i],d+1,x+pw[d]*i);\n}\nvoid rev(int o) {\n\ttr[o].tag ^= 1;\n\tswap(tr[o].ch[1],tr[o].ch[2]);\n}\nvoid pd(int o) {\n\tif (tr[o].tag) REP(i,0,2) rev(tr[o].ch[i]),tr[o].tag=0;\n}\nvoid add(int o, int d) {\n\tif (d==n) return;\n\tpd(o);\n\tswap(tr[o].ch[1],tr[o].ch[2]);\n\tswap(tr[o].ch[0],tr[o].ch[1]);\n\tadd(tr[o].ch[0],d+1);\n}\nvoid dfs(int o, int d, int x) {\n\tif (d==n) return ans[tr[o].id]=x,void();\n\tpd(o);\n\tREP(i,0,2) dfs(tr[o].ch[i],d+1,x+pw[d]*i);\n}\nint main() {\n\tscanf(\"%d%s\", &n, s+1);\n\tpw[0] = 1;\n\tREP(i,1,n) pw[i] = pw[i-1]*3;\n\tbuild(T,0,0);\n\tm = strlen(s+1);\n\tREP(i,1,m) {\n\t\tif (s[i]=='S') rev(T);\n\t\telse add(T,0);\n\t}\n\tdfs(T,0,0);\n\tREP(i,0,pw[n]-1) printf(\"%d \", ans[i]);hr;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <cmath>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n#define iter(b) for(int i = 0;i < (b);i++)\n#define VVI vector<vector<int>>\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    string T;\n    cin >> T;\n    int n = pow(3, N);\n    vector<int> salsa(n);\n    vector<int> ppl(n);\n    vector<int> cpy(n);\n    iter(n){\n        ppl[i] = i;\n    }\n\n    int k, p, s, r;\n    for(int i = 0;i < n;i++){\n        s = 0;\n        k = i;\n        p = 1;\n        while(p < k) p *= 3;\n        for(;p >= 1;p /= 3){\n            r = k / p;\n            if(r == 1){\n                s += p * 2;\n            }else if(r == 2){\n                s += p;\n            }else{\n                s += r * p;\n            }\n        }\n        salsa[i] = s;\n        cout << i << \" \" << s << endl;\n    }\n\n    for(char c : T){\n        if(c == 'S'){\n            // Salsa\n            iter(n){\n                cpy[salsa[i]] = ppl[i];\n            }\n        }else{\n            // Rumba\n            iter(n){\n                cpy[(i + 1) % n] = ppl[i];\n            }\n        }\n        iter(n){\n            ppl[i] = cpy[i];\n        }\n    }\n\n    iter(n){\n        cout << ppl[i] << \" \";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n//#define debug(x) ;\n#define debug(x) cerr << #x << \" = \" << x << \"\\n\";\n\nostream& operator<<(ostream& cerr, vector<ll> aux) {\n  cerr << \"[\";\n  for (auto e : aux) cerr << e << ' ';\n  cerr << \"]\";\n  return cerr;\n}\n\nconst int maxT = 200011;\nconst int maxN = 600011;\n\nstruct node {\n  int data;\n  node* son[3];\n\n  node() {\n    data = 0;\n    memset(son, 0, sizeof(son));\n  }\n};\n\nint n, t;\nint id[3], sol[maxN], cnt;\nchar s[maxT];\nnode* head;\n\nvoid build(node* act, int lvl, int curr, int step) {\n  if (lvl == n) {\n    act->data = curr;\n    return;\n  }\n\n  act->son[0] = new node();\n  act->son[1] = new node();\n  act->son[2] = new node();\n\n  build(act->son[0], lvl + 1, curr, step * 3);\n  build(act->son[1], lvl + 1, curr + step, step * 3);\n  build(act->son[2], lvl + 1, curr + 2 * step, step * 3);\n}\n\nvoid salsa() {\n  swap(id[1], id[2]);\n}\n\nvoid rumba(node* act, int lvl) {\n if (lvl == n) return;\n\n node* aux = act->son[id[2]];\n act->son[id[2]] = act->son[id[1]];\n act->son[id[1]] = act->son[id[0]];\n\n act->son[id[0]] = aux;\n rumba(act->son[id[0]], lvl + 1);\n}\n\nvoid print(node* act, int lvl, int curr, int step) {\n  if (lvl == n) {\n    sol[act->data] = curr;\n    cnt++;\n    return;\n  }\n\n  print(act->son[id[0]], lvl + 1, curr, step * 3);\n  print(act->son[id[1]], lvl + 1, curr + step, step * 3);\n  print(act->son[id[2]], lvl + 1, curr + 2 * step, step * 3);\n}\n\nint main()\n{\n  //freopen(\"test.in\", \"r\", stdin);\n\n  scanf(\"%d\\n%s\", &n, s);\n  t = strlen(s);\n\n  head = new node();\n  build(head, 0, 0, 1);\n\n  for (int i = 0; i < 3; i++) \n    id[i] = i;\n   \n  for (int i = 0; i < t; i++) {\n    if (s[i] == 'S')\n      salsa();\n    else\n      rumba(head, 0);\n  }\n\n  print(head, 0, 0, 1);\n  for (int i = 0; i < cnt; i++)\n    printf(\"%d \", sol[i]);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=3000005;\nint flag[N],ne[N][3],cnt,n,fac[N],v[N],ans[N],ss;\nchar s[N];\nvoid build(){\nint last1=0,last2=0;\nfor (int i=0;i<n;i++){\nfor (int j=last1;j<=last2;j++){\nne[j][0]=++cnt;\nv[cnt]=v[j];\nne[j][1]=++cnt;\nv[cnt]=v[j]+fac[i];\nne[j][2]=++cnt;\nv[cnt]=v[j]+fac[i]*2;\n}\nlast2+=fac[i+1];last1+=fac[i];\n}\n}\nvoid down(int x){\nif (flag[x]){\nswap(ne[x][1],ne[x][2]);\nif (ne[x][0])flag[ne[x][0]]^=1,flag[ne[x][1]]^=1,flag[ne[x][2]]^=1;\nflag[x]=0;\n}\n}\nvoid insert1(int x){\ndown(x);\nswap(ne[x][0],ne[x][1]);\nswap(ne[x][0],ne[x][2]);\nif (ne[x][0])x=ne[x][0],insert1(x);\n}\nvoid solve(int x,int t,int d){\ndown(x);\nif (ne[x][0])solve(ne[x][0],t,d+1),solve(ne[x][1],t+fac[d],d+1),solve(ne[x][2],t+2*fac[d],d+1);\nelse ans[v[x]]=t;\n}\nint main(){\nscanf(\"%d\",&n);\nscanf(\"%s\",s+1);\nfac[0]=1;ss=0;\nfor (int i=1;i<=n;i++)fac[i]=fac[i-1]*3;\nfor (int i=0;i<n;i++)ss+=fac[i];\nbuild();\nfor (int i=1;s[i];i++){\nif (s[i]=='R')insert1(0);\nelse flag[0]^=1;\n}\nsolve(0,0,0);\nfor (int i=0;i<fac[n];i++)printf(\"%d \",ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nclass CStrangeDance {\npublic:\n\n    int calc(vector<vector<vector<int>>>& v, int k) {\n      int w = 0;\n      if (k > 0) {\n        w = calc(v, k-1);\n      }\n      auto ret = v[2][k][w];\n\n      auto w0 = v[0][k][w];\n      auto w1 = v[1][k][w];\n      auto w2 = v[2][k][w];\n\n      v[1][k][w] = w0;\n      v[2][k][w] = w1;\n      v[0][k][w] = w2;\n      return ret;\n    }\n\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n;\n      cin >> n;\n      string t;\n      cin >> t;\n      vector<vector<vector<int>>> v(3, vector<vector<int>>(n));\n      int k = 1;\n      rep(i, n) {\n        rep(j, 3) {\n          v[j][i].resize(k);\n        }\n        k *= 3;\n      }\n      int K = k;\n\n      rep(i, n) {\n        int idx = 0;\n        rep(j, 3) {\n          for(auto& e: v[j][i]) {\n            e = idx;\n            idx++;\n          }\n        }\n      }\n\n      for(auto c: t) {\n        if (c=='S') {\n          swap(v[1], v[2]);\n        } else {\n          calc(v, n-1);\n        }\n      }\n\n      vector<int> ans(K);\n      k = 1;\n      rep(i, n) {\n        rep(j, 3) {\n          for(auto e: v[j][i]) {\n            for(int idx=e; idx<K; idx+=(k*3)) {\n              ans[idx] += j*k;\n            }\n          }\n        }\n        k *= 3;\n      }\n\n      for(auto e: ans) {\n        cout << e << ' ';\n      }\n      cout << endl;\n\n    }\n};\n\nsigned main() {\n  CStrangeDance solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//BadWaper gg\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<deque>\n#include<bitset>\n#include<map>\n#include<set>\n#define inf 1e9\n#define eps 1e-6\n#define mp make_pair\n#define N 2000010\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ninline ll read()\n{\n\tchar ch=getchar();\n\tll s=0,w=1;\n\twhile(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}\n\treturn s*w;\n}\nint val[N][3],ch[N][3],tot,lazy[N];\nint n;char s[N];\nint ans[N];\ninline void build()\n{\n\ttot=1;for(register int i=1;i<=n+1;i++)tot*=3;\n\ttot=(tot-1)/2;\n\tfor(register int i=1;i<=tot;i++)\n\t{\n\t\tif(i*3<=tot)\n\t\t{\n\t\t\tch[i][0]=i*3-1;ch[i][1]=i*3;ch[i][2]=i*3+1;\n\t\t\tval[i][0]=0;val[i][1]=1;val[i][2]=2;\n\t\t}\n\t}\n}\ninline void pushdown(int now)\n{\n\tif(lazy[now])\n\t{\n\t\tlazy[ch[now][0]]^=1;lazy[ch[now][1]]^=1;lazy[ch[now][2]]^=1;\n\t\tint x=0,y=0;\n\t\tfor(register int i=0;i<3;i++)\n\t\t{\n\t\t\tif(val[now][i]==1)x=ch[now][i];\n\t\t\tif(val[now][i]==2)y=ch[now][i];\n\t\t}\n\t\tswap(val[now][x],val[now][y]);\n\t}\n}\nvoid update(int now)\n{\n\tpushdown(now);if(now*3>tot)return ;\n\tfor(register int i=0;i<3;i++)\n\t{\n\t\tval[now][i]++;\n\t\tif(val[now][i]==3)\n\t\t{\n\t\t\tval[now][i]=0;\n\t\t\tupdate(ch[now][i]);\n\t\t}\n\t}\n}\nvoid dfs(int now,int v,int p)\n{\n\tif(now*3>tot){ans[++ans[0]]=v;return ;}\n\tfor(register int i=0;i<3;i++)dfs(ch[now][i],v+val[now][i]*p,p*3);\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read();scanf(\"%s\",s+1);\n\tbuild();\n\tint len=strlen(s+1);\n\tfor(register int i=1;i<=len;i++)\n\t{\n\t\tif(s[i]=='S')update(1);\n\t\telse lazy[1]^=1;\n\t}\n\tdfs(1,0,1);\n\tfor(register int i=1;i<=ans[0];i++)printf(\"%d \",ans[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nstatic inline char CH()\n{\n  static char buf[100000],*ptr1=buf,*ptr2=buf;\n  return ptr1==ptr2&&(ptr2=(ptr1=buf)+fread(buf,1,100000,stdin),ptr1==ptr2)?EOF:*ptr1++;\n}\nstatic inline int IN(void)\n{\n  int x=0,f=0,c=CH();while(c<48||c>57){f^=c==45,c=CH();}\n  while(c>47&&c<58){x=x*10+c-48,c=CH();}return f?-x:x;\n}\nstatic inline int Pow(int a,int b){return b?Pow(a*a,b>>1)*(b&1?a:1):1;}\nint main()\n{\n  int N=IN(),now,len=0,pw3=Pow(3,N),x=Pow(3,N>>1),y=Pow(3,N-(N>>1)),A[1000001]={0},B[600001];\n  char c=CH(),T[1000001],S[1000001];\n  rep(i,pw3)B[i]=B[i/3]*3+(3-i%3)%3;\n  while(c!=EOF){if(c==10){c=CH();}T[1+len++]=c,c=CH();}\n  fflush(stdin);\n  rep(i,x)\n  {\n    int temp=i;now=0;\n    rep(j,len)\n    {\n      if(T[j+1]=='S'){temp=B[temp];(S[now]=='S')?--now:S[++now]='S';}\n      else{++temp;if(temp==x)S[++now]='R',temp=0;}\n    }\n    rep(j,y)\n    {\n      int keep=j;\n      rep(k,now)\n      {\n        if(S[k+1]=='S')keep=B[keep];\n        else if(S[k+1]=='R')if((++keep)==y)keep=0;\n        A[i+j*x]=temp+keep*x;\n      }\n    }\n  }\n  rep(i,pw3)printf(\"%d%c\",A[i],i+1==pw3?'\\n':' ');\n  return fflush(stdout),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MaxM = 200005, MaxK = 12, MaxN = 531550, MaxS = 266666;\n\nint n, Pow3[MaxK + 1];\nchar str[MaxM];\n\nint nd = 0, rt, _to[3][MaxS], *to[3];\n\nvoid build(int &u, int dep, int val) {\n\tif (dep == n) {\n\t\tu = val; return;\n\t}\n\tu = ++nd;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tbuild(to[i][u], dep + 1, val + i * Pow3[dep]);\n\t}\n}\n\nvoid shift() {\n\tint u = rt, tmp[3];\n\tfor (int dep = 0; dep < n; ++dep) {\n\t\tfor (int i = 0; i < 3; ++i) tmp[i] = to[(i + 2) % 3][u];\n\t\tfor (int i = 0; i < 3; ++i) to[i][u] = tmp[i];\n\t\tu = tmp[0];\n\t}\n}\n\nint pos[MaxN];\n\nvoid dfs(int u, int dep, int val) {\n\tif (dep == n) {\n\t\tpos[u] = val; return;\n\t}\n\tfor (int i = 0; i < 3; ++i) {\n\t\tdfs(to[i][u], dep + 1, val + i * Pow3[dep]);\n\t}\n}\n\nint main() {\n\tscanf(\"%d%s\", &n, str);\n\tfor (int i = 0; i < 3; ++i) to[i] = _to[i];\n\tPow3[0] = 1;\n\tfor (int i = 1; i <= n; ++i) Pow3[i] = Pow3[i - 1] * 3;\n\tbuild(rt, 0, 0);\n\tfor (char *ptr = str; *ptr; ++ptr) {\n\t\tif (*ptr == 'S') {\n\t\t\tstd::swap(to[1], to[2]);\n\t\t} else {\n\t\t\tshift();\n\t\t}\n\t}\n\tdfs(rt, 0, 0);\n\tfor (int i = 0; i < Pow3[n]; ++i) printf(\"%d \", pos[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\n#define MAXI 531441\n\nlong long int S[MAXI],C[MAXI],Cinv[MAXI],C2[MAXI];\n\n\nint main() {\n    long long int i,j,k,l,m,N,Q,X,P;\n    string T;\n\n cin >> N >> T;\n\n // P = 3^N\n\n P = 1;\n for (i=1;i<=N;i++)\n    P *= 3;\n\n\n S[0] = 0;\n S[1] = 2;\n S[2] = 1;\n j = 1;\n for (i=1;i<N;i++) {\n    j *= 3;\n    k = (j << 1);\n    for (l=0;l<j;l++) {\n      S[j+l] = k+S[l];\n      S[k+l] = j+S[l];\n    }\n}\n/*\ncerr << \"S = \";\nfor (i=0;i<P;i++) {\n  cerr << S[i] << \" \";\n}\ncerr << endl;\n*/\n\nfor (i=0;i<P;i++) {\n  C[i] = i;\n}\nfor (i=0;i<P;i++) {\n  Cinv[C[i]] = i;\n}\n\nlong long int decalage;\n\nfor (i=0;i<T.length();i++) {\n/*  cerr << \"C\" << i << \" = \";\n  for (k=0;k<P;k++)\n    cerr << C[k] <<  \" \";\n  cerr << \"Cinv\" << i << \" = \";\n    for (k=0;k<P;k++)\n      cerr << Cinv[k] <<  \" \";\n  cerr << endl; */\n  if (T[i] == 'S') {\n  //   cerr << i+1 << \" On lit S\";\n     decalage = 1;\n     for (j=i+1;j<T.length();j++)\n       if (T[j]== 'S')\n         decalage++;\n       else\n         j = T.length();\n//    cerr << decalage << endl;\n    if (decalage % 2) {\n\n    for (j=0;j<P;j++) {\n      if (S[j] > j) {\n        // k = Cinv[j];\n        C[Cinv[j]] = S[j];\n        C[Cinv[S[j]]] = j;\n      }\n    }\n    for (j=0;j<P;j++) {\n      Cinv[C[j]] = j;\n    }\n    }\n    i += decalage-1;\n  }\n  else {\n  //  cerr << i+1 << \" On lit R\" << endl;\n    for (j=0;j<P;j++)\n      C2[Cinv[j]] = (j+1) % P;\n// C[ Cinv[j]] = j devient (j + decalage ) % P\n    for (j=0;j<P;j++)\n      C[j] = C2[j];\n    for (j=0;j<P;j++)\n      Cinv[C[j]] = j;\n  }\n}\n\nfor (i=0;i<P;i++)\n  cout << C[i] <<  \" \";\n\ncout << \"\\n\";\n\n\n\n// cout << sqrt(dx*dx+dy+dy) << endl;\n// printf(\"%f\\n\",sqrt(dx*dx+dy+dy));\n\n\n\n  return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n// #include <ext/pb_ds/assoc_container.hpp> \n// #include <ext/pb_ds/detail/standard_policies.hpp>\n// using namespace __gnu_pbds;\n\n#pragma GCC optimize(\"O3\")\n#ifdef LOCAL\n#include \"/Users/lbjlc/Desktop/coding/debug_utils.h\"\n#else\n#define print(...) ;\n#define printn(...) ;\n#define fprint(...) ;\n#define fprintn(...) ;\n#endif\n\n#define rep(i, a, b) for(auto i = (a); i < (b); i++)\n#define rrep(i, a, b) for(auto i = (a); i > (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define pb push_back\n// #define mp make_pair\n#define fi first\n#define se second\n#define maxi(x, y) x = max(x, y)\n#define mini(x, y) x = min(x, y)\n// long long fact(long long n) { if(!n) return 1; return n*fact(n-1); }\n// #define endl '\\n'\n#define solve_testcase int T;cin>>T;for(int t=1;t<=T;t++){solve(t);}\n\n// long long gcd(long long x, long long y) { return y ? gcd(y, x % y) : x; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\n \ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n \ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\ntypedef vector<long long> vll;\n#define bd(type,op,val) bind(op<type>(), std::placeholders::_1, val)\n\nconst int MAXN = 1e6+10;\n\n\nvoid solve(int tt) {\n    // cout<<\"Case #\"<<tt<<\": \";\n}\n\nstring to_ter(int x, int k=-1) {\n    string res;\n    while(x) {\n        res+='0'+x%3;\n        x/=3;\n    }\n    if(k>=0) {\n        while(res.size()<k) res+='0';\n    }\n    return res;\n}\nint to_int(const string & s) {\n    int res=0;\n    // rrep(i,s.size()-1,-1)\n    //     res=res*3+(s[i]-'0');\n    for(int i=s.size()-1;i>=0;i--)\n        res=res*3+(s[i]-'0');\n    // print(s,res);\n    return res;\n}\nbool add(string & x, const string & y) {\n    int n1=x.size(), n2=y.size(),carry=0;\n    rep(i,0,n1) {\n        if(i<n1) carry+=x[i]-'0';\n        if(i<n2) carry+=y[i]-'0';\n        x[i]=carry%3+'0';\n        carry/=3;\n    }\n    return carry==0;\n}\n\nvi cal_inst(string & s) {\n    int n=s.size();\n    vi res(1);\n    int i=0;\n    while(i<n) {\n        if(s[i]=='R') {\n            res.back()++;\n            i++;\n        }\n        else {\n            int j=i;\n            for(;j<n&&s[j]=='S';j++);\n            if((j-i)%2) res.pb(0);\n            i=j;\n        }\n    }\n    if(s.back()=='S') res.pop_back();\n    return res;\n}\n\nchar rev(char c) {\n    if(c>'0') return '0'+(3-(c-'0'));\n    return c;\n}\nstring rev(string s) {\n    for(auto & c:s) c=rev(c);\n    return s;\n}\n\nint len(string & s) {\n    int res=s.size()-1;\n    while(res>=0&&s[res]=='0') res--;\n    return res+1;\n}\n\nint power[13]={};\nint revmap[MAXN]={};\nint tmpres[MAXN];\nint rev(int x) {\n    for(int flag=1;flag<power[12];flag*=3) {\n        int tmp=x/flag%3;\n        if(tmp==1) x+=flag;\n        else if(tmp==2) x-=flag;\n    }\n    return x;\n}\n\nvoid cal(vi inst, int n, int tot) {\n    // vi tmpres(tot,-1);\n    fill(tmpres,tmpres+tot,-1);\n\n    rep(i,0,tot) {\n        if(tmpres[i]>=0) continue;\n\n        int cur=i,ok=1;\n        for(auto x:inst) {\n            cur+=x;\n            if(cur>=power[n]) {\n                ok=0; \n                cur%=power[n];\n            }\n            cur=revmap[cur];\n        }\n        // if(i<=9) print(i,cur);\n        tmpres[i]=cur;\n        // assert(cur>=0);\n        if(!ok) continue;\n        int flag=1,tmp;\n        for(;flag<=i||flag<=cur;flag*=3);\n\n        if(inst.size()%2==0) {\n            for(tmp=flag;tmp<power[n];tmp+=flag) {\n                tmpres[tmp+i]=tmp+cur;\n            }\n        }\n        else {\n            for(tmp=flag;tmp<power[n];tmp+=flag) {\n                tmpres[tmp+i]=revmap[tmp]+cur;\n            }\n\n        }\n    }\n    // print(1);\n    // print(*max_element(all(res)),*min_element(all(res)));\n    // return res;\n}\n\nint main(int argc, char * argv[]) {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    // solve_testcase;\n\n    int n;\n    string s;\n    cin>>n;\n    cin>>s;\n\n    // n=12;\n    // rep(i,0,1e5) s+=\"RS\";\n\n    power[0]=1;\n    rep(i,1,13) power[i]=power[i-1]*3;\n\n    int tot=1;\n    rep(i,0,n) tot*=3;\n\n    rep(i,0,tot) {\n        if(i>=3) {\n            if(i%3==0)\n                revmap[i]=revmap[i/3]*3;\n            else\n                revmap[i]=revmap[i-i%3]+rev(i%3);\n        }\n        else\n            revmap[i]=rev(i);\n    }\n    // printn(revmap,9);\n\n\n    vi inst=cal_inst(s);\n    for(auto & x:inst) x%=tot;\n\n    // print(inst);\n\n    int i=0;\n    int bound=81;\n    vi res(tot);\n    iota(all(res),0);\n    while(i<inst.size()) {\n        int cur=inst[i];\n        vi cur_inst({cur});\n        for(++i;i<inst.size()&&cur+inst[i]<bound;i++) {\n            cur+=inst[i];\n            cur_inst.pb(inst[i]);\n        }\n        cal(cur_inst,n,tot);\n        // print(tmp);\n        rep(j,0,tot) res[j]=tmpres[res[j]];\n        // print(cur_inst,tmp);\n        // print(res);\n        // sort(all(tmp)); print(tmp);\n    }\n    if(s.back()=='R') {\n        rep(i,0,tot) {\n            res[i]=revmap[res[i]];\n        }\n    }\n    for(auto x:res) cout<<x<<' ';\n    cout<<endl;\n\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint dp[256][531141];\n\nclass CStrangeDance {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n; cin >> n;\n      int t = 1;\n      rep(i, n) {\n        t *= 3;\n      }\n\n      vector<int> s(t), r(t);\n      rep(i, t) {\n        s[i] = (i+1)%t;\n      }\n      rep(i, t) {\n        vector<int> v;\n        int tmp = i;\n        while(tmp > 0) {\n          int k = tmp%3;\n          v.push_back(k);\n          tmp /= 3;\n        }\n        while(!v.empty()) {\n          int k = v.back(); v.pop_back();\n          r[i] *= 3;\n          if (k==2) r[i] += 1;\n          if (k==1) r[i] += 2;\n        }\n        //debug(r[i], i);\n      }\n\n      string T;\n      cin >> T;\n      int N = T.size();\n\n      rep(i, 256) {\n        vector<int> tmp(t);\n        rep(j, t) {\n          tmp[j] = j;\n        }\n        for(int k=7; k>=0; k--) {\n          if (i&(1<<k)) {\n            rep(j, t) tmp[j] = s[tmp[j]];\n          } else {\n            rep(j, t) tmp[j] = r[tmp[j]];\n          }\n        }\n        rep(j, t) {\n          dp[i][j] = tmp[j];\n        }\n      }\n\n      vector<int> ans(t);\n      rep(i, t) {\n        ans[i] = i;\n      }\n\n      for(int i=0; i+8<N; i+=8) {\n        int p = 0;\n        for(int j=i; j<i+8; j++) {\n          p *= 2;\n          if (T[j]=='R') {\n            p++;\n          }\n        }\n        //debug(p);\n        rep(j, t) {\n          ans[j] = dp[p][ans[j]];\n        }\n\n      }\n\n      int k = N%8;\n      for(int i=N-k; i<N; i++) {\n        //debug(i);\n        if (T[i]=='R') {\n          rep(j, t) {\n            ans[j] = s[ans[j]];\n            //debug(j, ans[j]);\n          }\n        } else {\n          rep(j, t) {\n            ans[j] = r[ans[j]];\n            //debug(j, ans[j]);\n          }\n        }\n      }\n\n      rep(i, t) {\n        cout << ans[i] << ' ';\n      }\n      cout << endl;\n\n    }\n};\n\nsigned main() {\n  CStrangeDance solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define putchar_unlocked putchar\n\nchar T[550005];\n\n// Based on editorial solution\nint D[13][550005]; // one digit at a time, with digit 0 representing the ones place\nint W[13][550005];\nint lastUpdated[13][550005];\n\ninline void putInt(int i){\n    if(i==0){putchar_unlocked('0');}\n    else{\n    int x[11];\n    int count1=0;\n    while(i>0){\n        x[count1++]=i%10;\n        i/=10;\n    }\n    for(int j=count1-1;j>=0;j--){\n        putchar_unlocked(48+x[j]);\n    }\n    }\n    putchar_unlocked(' ');\n}\n\nint N;\n\ninline void update(int n, int indx, int cntS){\n    if((cntS&1) != (lastUpdated[n][indx]&1)){\n        // conduct salsa\n        if(D[n][indx]){D[n][indx] = 3-D[n][indx];}\n    }\n    // update the lastUpdated index\n    lastUpdated[n][indx] = cntS;\n}\n\nint pow3[16];\n\nint main(){\n    scanf(\"%d\", &N);\n\n    scanf(\" %s\", T);\n\n    int M = strlen(T);\n\n    pow3[0] = 1;\n    for(int i = 1; i <= N; i ++){\n        pow3[i] = pow3[i-1]*3;\n    }\n\n    int pow3N = pow3[N];\n\n    //printf(\"ok\");\n    memset(W, 0, sizeof(W));\n    for(int n = 1; n <= N; n ++){\n        //printf(\"ok\");\n        for(int j = 0; j < pow3[N]; j ++){\n            D[n][j] = (j%pow3[n])/pow3[n-1];\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        W[n][0] = pow3[n]-1;\n    }\n\n\n    memset(lastUpdated, 0, sizeof(lastUpdated));\n    int cntS2 = 0;\n    for(int n = 1; n <= N; n ++){\n        int cntS = 0;\n        for(int i = 0; i < M; i ++){\n            int indx0 = W[n-1][i];\n            int indx1 = W[n-1][i]+pow3[n-1];\n            int indx2 = W[n-1][i]+(pow3[n-1]<<1);\n\n            if(indx1 >= pow3[n]){indx1 -= pow3[n];}\n            if(indx2 >= pow3[n]){indx2 -= pow3[n];}\n\n            update(n, indx0, cntS+(T[i]=='S'));\n            update(n, indx1, cntS+(T[i]=='S'));\n            update(n, indx2, cntS+(T[i]=='S'));\n            if(D[n][indx0] == 2){\n                W[n][i] = indx0;\n            }else if(D[n][indx1] == 2){\n                W[n][i] = indx1;\n            }else{\n                W[n][i] = indx2;\n            }\n\n            if(T[i] == 'R'){\n                D[n][indx0] = (D[n][indx0]+1);\n                D[n][indx1] = (D[n][indx1]+1);\n                D[n][indx2] = (D[n][indx2]+1);\n                if(D[n][indx0] == 3){D[n][indx0] = 0;}\n                if(D[n][indx1] == 3){D[n][indx1] = 0;}\n                if(D[n][indx2] == 3){D[n][indx2] = 0;}\n                lastUpdated[n][indx0] = cntS;\n                lastUpdated[n][indx1] = cntS;\n                lastUpdated[n][indx2] = cntS;\n            }else if(T[i] == 'S'){\n                cntS ++;\n            }\n\n            //printf(\"W[%d][%d]=%d\\n\", n, i+1, W[n][i+1]);\n        }\n\n        cntS2 = cntS;\n    }\n\n    for(int n = 1; n <= N; n ++){\n        for(int i = 0; i < pow3[n]; i ++){\n            update(n, i, cntS2);\n        }\n    }\n\n    for(int i = 0; i < pow3[N]; i ++){\n        int temp = 0;\n        for(int n = 1; n <= N; n ++){\n            temp += D[n][i%pow3[n]]*pow3[n-1];\n        }\n        putInt(temp);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\", \"unroll-loops\", \"no-stack-protector\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n\nusing ll = long long;\nusing ld = double;\nusing pii = pair<int, int>;\nusing uint = unsigned int;\nusing ull = unsigned long long;\n\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ndefault_random_engine generator;\n\nvoid solve();\n\nint main() {\n#ifdef LOCAL\n    // freopen(\"input.txt\", \"r\", stdin);\n    // freopen(\"output.txt\", \"w\", stdout);  \n#endif \n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cout << setprecision(16) << fixed;\n    cerr << setprecision(16) << fixed;\n\n    int tests = 1;\n    // cin >> tests;\n\n    for (int test = 1; test <= tests; ++test) {\n        // cout << \"Case #\" << test << \": \";\n        solve();\n    }\n\n#ifdef LOCAL\n    cerr << \"Time: \" << double(clock()) / CLOCKS_PER_SEC << endl;\n#endif\n}\n\n// -----------------------------------------------------------------\n\n// int m;\n\n// int f(int x) {\n//     int pw = 1;\n//     int y = 0;\n//     while (x > 0) {\n//         y += (x % 3 == 0 ? 0 : 3 - x % 3) * pw;\n//         x /= 3;\n//         pw *= 3;\n//     }\n//     return y;\n// }\n\n// int g(int x) {\n//     return (x + 1) % m;\n// }\n\n// vector<int> f(const vector<int> &p) {\n//     vector<int> q;\n//     for (int x : p) {\n//         q.push_back(f(x));\n//     }\n//     return q;\n// }\n\n// vector<int> g(const vector<int> &p) {\n//     vector<int> q;\n//     for (int x : p) {\n//         q.push_back(g(x));\n//     }\n//     return q;\n// }\n\nvoid solve() {\n    int n;\n    cin >> n;\n\n    int m = 1;\n    for (int i = 0; i < n; ++i) {\n        m *= 3;\n    }\n\n    string s;\n    cin >> s;\n\n    vector<int> res(m);\n\n    vector<int> pos(sz(s), 0);\n\n    for (int k = 1, t = 1; k <= n; ++k, t *= 3) {\n        vector<int> p(3 * t);\n        for (int i = 0; i < 3 * t; ++i) {\n            p[i] = i / t;\n        }\n\n        // for (int i = 0; i < 3 * t; ++i) {\n        //     cerr << p[i] << \" \";\n        // }\n        // cerr << endl;\n\n\n        vector<int> last(3 * t, 0);\n        int cnt = 0;\n\n        for (int i = 0; i < sz(s); ++i) {\n            int new_pos = -1;\n\n            for (int x = 0; x < 3; ++x) {\n                int ps = pos[i] + x * t;\n                if ((cnt - last[ps]) & 1) {\n                    p[ps] = (3 - p[ps]) % 3;\n                }\n                last[ps] = cnt;\n\n                if (p[ps] == 2) {\n                    new_pos = ps;\n                }\n            }\n\n            if (s[i] == 'S') {\n                ++cnt;\n            } else {\n                for (int x = 0; x < 3; ++x) {\n                    int ps = pos[i] + x * t;\n                    // if ((cnt - last[ps]) & 1) {\n                    //     p[ps] = (3 - p[ps]) % 3;\n                    // }\n                    // last[ps] = cnt;\n                    p[ps] = (p[ps] + 1) % 3; \n                }\n            }\n\n            assert(new_pos != -1);\n            pos[i] = new_pos;\n        }\n\n        for (int i = 0; i < 3 * t; ++i) {\n            if ((cnt - last[i]) & 1) {\n                p[i] = (3 - p[i]) % 3;\n            }\n        }\n\n        for (int i = 0; i < m; ++i) {\n            res[i] += t * p[i % (3 * t)];\n        }\n    }\n\n    for (int x : res) {\n        cout << x << \" \";\n    }\n    cout << endl;\n\n\n\n\n\n\n    // int n;\n    // cin >> n;\n\n    // m = 1;\n    // for (int i = 0; i < n; ++i) {\n    //     m *= 3;\n    // }\n\n    // set<vector<int>> used;\n\n    // vector<int> p(m);\n\n    // iota(all(p), 0);\n\n    // used.insert(p);\n\n    // queue<vector<int>> que;\n    // que.push(p);\n\n\n    // // string s;\n    // // cin >> s;\n\n    // // for (int i = 0; i < sz(s); ++i) {\n    // //     if (s[i] == 'S') {\n    // //         p = f(p);\n    // //     } else {\n    // //         p = g(p);\n    // //     }\n    // // } \n\n    // // for (int x : p) {\n    // //     cerr << x << \" \";\n    // // }\n    // // cerr << endl;\n\n    // while (!que.empty()) {\n    //     vector<int> q = que.front();\n    //     que.pop();\n    //     vector<int> r;\n\n    //     r = f(q);\n    //     if (!used.count(r)) {\n    //         used.insert(r);\n    //         que.push(r);\n    //     }\n\n    //     r = g(q);\n    //     if (!used.count(r)) {\n    //         used.insert(r);\n    //         que.push(r);\n    //     }\n    // }\n\n    // set<pii> setik;\n\n    // for (auto p : used) {\n    //     setik.insert({p[0], p[1]});\n    //     // for (int i = 0; i < m; ++i) {\n    //     //     // q[p[i]] = i;\n    //     //     cout << p[i] << \" \";\n    //     // }\n\n    //     // for (int x : q) {\n    //     //     cerr << x << \" \";\n    //     // }\n    //     // cout << endl;\n    // }\n\n    // for (auto [x, y] : setik) {\n    //     cerr << x << \" \" << y << endl;\n    // }\n\n    // cout << sz(used) << endl;\n\n}   \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <string>\n#include <algorithm>\n#include <utility>\n#define inf 1e18\n#define rep(x, s, t) for(int (x) = (s); (x) < (t); (x)++)\n#define Rep(x, s, t) for(int (x) = (s); (x) <= (t); (x)++)\n#define chmin(x, y) (x) = min((x), (y))\n#define chmax(x, y) (x) = max((x), (y))\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n;\nstring s;\nint beki[15];\nint carry[200005];\nint dest[600005], ndest[600005];\nset<int> S[3];\n\nint main(void)\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n;\n\tcin >> s;\n\t\n\tbeki[0] = 1;\n\tfor(int i = 1; i < 15; i++) beki[i] = beki[i-1] * 3;\n\t\n\tfor(int i = 0; i < 3; i++){\n\t\tint p = i;\n\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\tif(s[j] == 'R'){\n\t\t\t\tif(p == 2) carry[j] = i;\n\t\t\t\tp = (p+1) % 3;\n\t\t\t}\n\t\t\telse p = (3-p)%3;\n\t\t}\n\t\tdest[i] = p;\n\t}\n\t\n\tfor(int i = 1; i < n; i++){\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tS[j].clear();\n\t\t\tfor(int k = 0; k < beki[i]; k++){\n\t\t\t\tS[j].insert(j*beki[i]+k);\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\tif(s[j] == 'S');//swap(S[1], S[2]);\n\t\t\telse{\n\t\t\t\tint tmp[3];\n\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\tfor(int l = 0; l < 3; l++){\n\t\t\t\t\t\tint x = l*beki[i]+carry[j];\n\t\t\t\t\t\tif(S[k].count(x)){\n\t\t\t\t\t\t\ttmp[k] = x;\n\t\t\t\t\t\t\tif(k == 2) carry[j] = x;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\tS[k].erase(tmp[k]);\n\t\t\t\t\tS[(k+1)%3].insert(tmp[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tfor(auto it = S[j].begin(); it != S[j].end(); it++){\n\t\t\t\tndest[*it] = dest[*it%beki[i]] + j*beki[i];\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < beki[i+1]; j++) dest[j] = ndest[j];\n\t}\n\t\n\tfor(int i = 0; i < beki[n]; i++) cout << dest[i] << \" \"; cout << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long int \n#define sz(x) ((int) x.size())\n#define mp(x,y) make_pair(x,y)\n#define f first\n#define s second\n#define pb push_back\n#define P pair<ll,ll>\n#define w(x) ll x; cin>>x; while(x--)\n#define all(x) (x).begin(),(x).end()\n#define F(i,a,b) for(int i = (int)(a); i <= (int)(b); i++)\n#define RF(i,a,b) for(int i = (int)(a); i >= (int)(b); i--)\nconst ll mod=1e9+7;\n\nvoid go() {\n    ios_base:: sync_with_stdio(false);\n    cin.tie(NULL); cout.tie(NULL);\n#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n}\n\nconst ll N=1e6+2;\nll arr[N];\nll val(char c) \n{ \n    if (c >= '0' && c <= '9') \n        return (ll)c - '0'; \n    else\n        return (ll)c - 'A' + 10; \n} \nchar reVal(ll num) \n{ \n    if (num >= 0 && num <= 9) \n        return (char)(num + '0'); \n    else\n        return (char)(num - 10 + 'A'); \n} \nstring strev(string str) \n{ \n    int len = sz(str); \n    int i; \n    for (i = 0; i < len/2; i++) \n    { \n        char temp = str[i]; \n        str[i] = str[len-i-1]; \n        str[len-i-1] = temp; \n    } \n    return str;\n}\nstring fromDeci(ll base, ll inputNum) \n{ \n    ll index = 0;\n    string res=\"\";\n    while (inputNum > 0) \n    { \n        res+= reVal(inputNum % base); \n        inputNum /= base; \n    } \n    //res[index] = '\\0'; \n    res=strev(res); \n    return res; \n} \nll toDeci(string str, ll base) \n{ \n    ll len = sz(str); \n    ll power = 1; // Initialize power of base \n    ll num = 0;  // Initialize result \n    ll i; \n    for (i = len - 1; i >= 0; i--) \n    { \n        if (val(str[i]) >= base) \n        { \n           printf(\"Invalid Number\"); \n           return -1; \n        } \n        num += val(str[i]) * power; \n        power = power * base; \n    } \n  \n    return num; \n} \nint main(){\n    //go();\n    ll n;\n    cin>>n;\n    string s;\n    cin>>s;\n    ll p=0;\n    ll d=pow(3,n)-1;\n    F(i,0,d){\n        arr[i]=p++;\n    }\n    F(i,0,sz(s)-1){\n        if(s[i]=='R'){\n            F(j,0,d){\n                arr[j]=(arr[j]+1)%(d+1);\n            }\n        }\n        else{\n            F(j,0,d){\n                //cout<<arr[j]<<\" \";\n                string ans=\"\";\n                string res=fromDeci(3,arr[j]);\n                ll pes=0;\n                //cout<<res<<\" \";\n                while(pes<sz(res)){\n                    if(res[pes]=='2')ans+=\"1\";\n                    else if(res[pes]=='1')ans+=\"2\";\n                    else ans+=\"0\";\n                    pes++;\n                }\n                //cout<<ans<<endl;\n                ll x=toDeci(ans,3);\n                arr[j]=x;\n            }\n        }\n    }\n    F(j,0,d)cout<<arr[j]<<\" \";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n//#define int ll\n//#define int ll\n//#define char ll\n#define double ld\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate<class T0, class T1>\ninline ostream &operator<<(ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate<class T0, class T1>\ninline istream &operator>>(istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate<class T0, class T1, class T2>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate<class T0, class T1, class T2, class T3>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" << get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream &operator<<(ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\nTOTAL EXECUTION TIME: \" << float(clock() - start) / CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int N = 1e6 + 10;\n\nstruct node {\n    vector<node*> ch;\n    int val;\n    int push_swap;\n    node() {\n        val = -1;\n        push_swap = 0;\n    }\n};\n\nvoid build(node * root, vector<pii> a) {\n    if (a.size() == 1) {\n        root->val = a[0].second;\n        return;\n    }\n    root->ch.resize(3);\n    fori (z, 3) {\n        vector<pii> cur;\n        for (auto x : a) {\n            if (x.first % 3 == z) {\n                x.first /= 3;\n                cur.push_back(x);\n            }\n        }\n        root->ch[z] = new node();\n        build(root->ch[z], cur);\n    }\n}\n\nvoid push(node * root) {\n    if (root->ch.empty())\n        return;\n    if (root->push_swap) {\n        fori (z, 3) {\n            if (!root->ch[z]->ch.empty()) {\n                root->ch[z]->push_swap ^= 1;\n                swap(root->ch[z]->ch[1], root->ch[z]->ch[2]);\n            }\n        }\n        root->push_swap = 0;\n    }\n}\n\nvoid upd_swap(node * root) {\n    if (root->ch.empty())\n        return;\n    root->push_swap ^= 1;\n    swap(root->ch[1], root->ch[2]);\n}\n\nvoid upd_inc(node * root) {\n    if (root->ch.empty())\n        return;\n\n    push(root);\n\n    node * tmp = root->ch[2];\n\n    fori (i, 3) {\n        swap(tmp, root->ch[i]);\n    }\n\n    upd_inc(root->ch[0]);\n\n}\n\nint ans[N];\n\nvoid dfs(node * root, int cur, int lvl) {\n    if (root->ch.empty()) {\n//        watch(cur);\n//        watch(root->val);\n        ans[root->val] = cur;\n        return;\n    }\n    fori (z, 3) {\n        dfs(root->ch[z], cur + lvl * z, lvl * 3);\n    }\n}\n\nvoid smain() {\n\n\n\n    int n;\n    cin >> n;\n    int pwk = 1;\n    fori (_, n) {\n        pwk *= 3;\n    }\n    n = pwk;\n\n\n    vi a(n);\n    fori (i, n) {\n        a[i] = i;\n    }\n    node * root = new node();\n    vector<pii> kek(n);\n    fori (i, n) {\n        kek[i] = {a[i], a[i]};\n    }\n\n    build(root, kek);\n\n    string s;\n    cin >> s;\n    for (auto c : s) {\n//        watch(c);\n        if (c == 'S') {\n            upd_swap(root);\n        } else {\n            upd_inc(root);\n        }\n    }\n\n\n    dfs(root, 0, 1);\n\n    for (int i = 0; i < n; ++i) {\n        cout << ans[i] << ' ';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint cng(int x){\n  int y=0, i=0, z;\n  int n=3;\n  while(x > 0){\n    z = x%n;\n    if(z==1){\n      z=2;\n    }else if(z==1){\n      z=1;\n    }\n    y += z*pow(10,i);\n    x =x/n;\n    i++; \n  }\n  string temp=to_string(y);\n  int lg=temp.length();\n  int ans=0;\n  for(int i=0;i<lg;i++){\n    ans+=temp.at(i)*pow(3,lg-i-1);\n  }\n  return ans;\n}\n  \n  \nint main(){\n  int n;\n  long long sn=0,rn=0;\n  cin>>n;\n  string s;\n  cin>>s;\n  int slength=s.length();\n  for(int i=0;i<slength;i++){\n    if(s.at(i)=='S') sn++;\n    if(s.at(i)=='R') rn++;\n  }\n  \n  int N=pow(3,n);\n  int ANS[N];\n\n  for(int i=0;i<N;i++){\n    ANS[i]=i;\n  }\n  \n  for(int i=0;i<N;i++){\n    ANS[i]=(ANS[i]+rn)%N;\n  } \n  \n  if(sn%2==1){\n    for(int i=0;i<N;i++){\n      //cout<<ANS[i]<<\"#\";//**\n      ANS[i]=cng(ANS[i]);\n      //cout<<ANS[i]<<\"k\";//**\n    }\n  } \n  //cout<<sn<<\" \"<<rn<<endl;\n  for(int i=0;i<N;i++){\n    if(i!=0)cout<<\" \";\n    cout<<ANS[i];\n  } \n  cout<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//pragma\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#include <bits/stdc++.h>\n\n#define YOU using\n#define DONT namespace\n#define SAY std\n\nYOU DONT SAY;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ll,int> pli;\ntypedef pair<int,ll> pil;\ntypedef vector<int> vi;\ntypedef vector<pii> vii;\ntypedef vector<pll> vll;\n\n#define REPP(i,a,b,d) for(int i=a;i<=b;i+=d)\n#define REP(i,a,b) REPP(i,a,b,1)\n#define REVV(i,a,b,d) for(int i=a;i>=b;i-=d)\n#define REV(i,a,b) REVV(i,a,b,1)\n\n#define FOR(i,a) for(int i=0; i<a; i++)\n#define FORD(i,a) for(int i=(int)a-1; i>=0; i--)\n\n#define pb push_back\n#define F first\n#define S second\n\nconst int OO = 1e9;\nconst ll INF = 1e18;\n\nconst int irand(int lo,int hi){\n\treturn ((double)rand()/(RAND_MAX + 1.0)) * (hi-lo+1) + lo;\n}\n\nconst ll lrand(ll lo,ll hi){\n\treturn ((double)rand()/(RAND_MAX + 1.0)) * (hi-lo+1) + lo;\n}\n\n#define getc getchar\ntemplate<typename T>\nT getnum(){\n\tint sign = 1;\n\tT ret = 0;\n\tchar c;\n\n\tdo{\n\t\tc = getc();\n\t}while(c == ' ' || c == '\\n');\n\tif(c == '-')sign = -1;\n\telse ret = c-'0';\n\twhile(1){\n\t\tc = getc();\n\t\tif(c < '0' || c > '9')break;\n\t\tret = 10*ret + c-'0';\n\t}\n\treturn sign * ret;\n}\n\ninline void ini(int& x){\n\tx = getnum<int>();\n}\n\ninline void scani(int& x){\n\tscanf(\"%d\",&x);\n}\n\n//end of macro\n\nint n;\nstring t;\n\ninline void addcom(string& a, char c){\n\tif(c == 'R')a += c;\n\telse{\n\t\tif(!a.empty() && a.back() == c)a.pop_back();\n\t\telse a += c;\n\t}\n}\n\nconst int N = 1e6 + 5;\nstring com[N];\nint v[N];\nint num[N];\n\nint ans[N];\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    #define endl '\\n'\n    cout.setf(ios::fixed);\n    cout.setf(ios::showpoint);\n    cout.precision(10);\n\n    cin>>n>>t;\n    com[0] = t;\n\n    int idx = 0;\n    int mul = 1;\n    FOR(i,n){\n    \t// process bit i\n    \tint m = 1;\n    \tREP(j,0,i)m *= 3;\n\n    \tint cbit = 0;\n    \tFOR(j,m){\n    \t\tidx++;\n    \t\tint par = (idx-1)/3;\n    \t\t// printf(\"bit %d, num %d, idx = %d\\n\",i,j,idx);\n    \t\t// printf(\"par %d\\n\",par);\n    \t\tv[idx] = cbit;\n    \t\t// printf(\"command: %s\\n\",com[par].c_str());\n    \t\tfor(auto k : com[par]){\n    \t\t\tif(k == 'R'){\n    \t\t\t\tv[idx]++;\n    \t\t\t\tif(v[idx] == 3){\n    \t\t\t\t\tv[idx] = 0;\n    \t\t\t\t\taddcom(com[idx], 'R');\n    \t\t\t\t}\n    \t\t\t}else{\n    \t\t\t\tif(v[idx] == 1)v[idx] = 2;\n    \t\t\t\telse if(v[idx] == 2)v[idx] = 1;\n    \t\t\t\taddcom(com[idx], 'S');\n    \t\t\t}\n    \t\t}\n    \t\tv[idx] = v[idx] * mul + v[par];\n    \t\tnum[idx] = cbit * mul + num[par];\n\n    \t\tif(i == n-1)ans[num[idx]] = v[idx];\n\n    \t\tcbit = (cbit+1)%3;\n    \t}\n    \tmul *= 3;\n    }\n\n    int m = 1;\n    FOR(j,n)m *= 3;\n\n    FOR(j,m)cout << ans[j] << \" \";\n    cout << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\ntypedef long long LL;\n#define rep(i,N) for(LL i=0;i<(LL)N;i++)\nconst LL sz=531441;\nint N,x,y,th,P[sz],t[13]={0},TRI;\nvoid init(void){rep(i,TRI)P[i]=i;}\nvoid sal(void)\n{\n  rep(trit,TRI)\n  {\n    x=P[trit];y=0;\n    for(int i=0;i<13;i++)\n    {\n      y++;t[i]=x%3;\n      if(t[i]==1)t[i]=2;else if(t[i]==2)t[i]=1;else t[i]=0;\n      if(x<3)break;\n      x/=3;\n    }\n    x=0;\n    for(int i=0;i<y;i++)x+=t[i]*pow(3,i);\n    if(x==TRI)x=0;\n    P[trit]=x;\n  }\n}\nsigned main(void)\n{\n  char c;TRI=scanf(\"%d\",&N);TRI=pow(3,N);init();\n  while(c!=EOF)\n  {\n    c=getchar();\n    if(c=='R')rep(i,TRI){P[i]++;if(P[i]==TRI)P[i]=0;}\n    else if(c=='S')sal();\n  }\n  rep(i,TRI)printf(\"%lld \",P[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n// headers {{{\nusing namespace std;\n// using namespace rel_ops;\n \ntypedef long long int64;\ntypedef unsigned long long uint64;\nconst double pi=acos(-1.0);\nconst double eps=1e-11;\nconst int INF=0x7FFFFFFF;\ntemplate<class T> inline bool checkmin(T &a,T b){return b<a?a=b,1:0;}\ntemplate<class T> inline bool checkmax(T &a,T b){return b>a?a=b,1:0;}\ntemplate<class T> inline T sqr(T x){return x*x;}\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<PII> VII;\n#define MP(A,B) make_pair(A,B)\n#define PB(X) push_back(X)\n#define mem(a,b) memset(a, b, sizeof(a))\n#define clr(a) memset(a, 0, sizeof(a))\n#define rep(i,n) for(int i=0; i<(int)n; i++)\n#define repit(i,v) for(typeof(v.begin()) i=v.begin(); i!=v.end(); i++)\n#define iter(v) typeof(v.begin())\n#define ff first\n#define ss second\n#ifdef LOCAL\n#define dbg(args...) printf(args); //##__VA_ARGS__\n#define dout cout\n#define out(x) (cout<<#x<<\": \"<<x<<endl)\ntemplate<class T>void show(T a, int n){for(int i=0; i<n; ++i) cout<<a[i]<<' '; cout<<endl;}\ntemplate<class T>void show(T a, int r, int l){for(int i=0; i<r; ++i)show(a[i],l);cout<<endl;}\n#else\n#define dbg(...)\n#define dout if(true);else cout\n#define out(...)\n#define show(...)\n#endif\n// }}}\n\nstruct B {\n    B* p[3] = {};\n    int idx;\n    bool rev = false;\n    void push() {\n        if (rev) {\n            swap(p[1], p[2]);\n            for (auto c : p) if (rev && c) c->reverse();\n        }\n    }\n    void reverse() {\n        rev ^= 1;\n    }\n};\n\nint main() {\n    // ios_base::sync_with_stdio(false);\n    // cin.tie(NULL);\n    // cout.tie(NULL); \n    int N;\n    while (cin >> N) {\n\t\tint tot = 1;\n        rep(i, N) tot *= 3;\n        B root;\n        rep(i, tot) {\n            B* s = &root;\n            int c = i;\n            rep(j, N) {\n                int k = c % 3; c /= 3;\n                if (!s->p[k]) s->p[k] = new B();\n                s = s->p[k];\n            }\n            s->idx = i;\n        }\n        string t; cin >> t;\n        rep(i, t.length()) {\n            if (t[i] == 'S') root.reverse();\n            else {\n                B* c = &root;\n                rep(i, N) {\n                    c->push();\n                    B* tmp = c->p[2];\n                    c->p[2] = c->p[1];\n                    c->p[1] = c->p[0];\n                    c->p[0] = tmp;\n                    c = c->p[0];\n                }\n            }\n        }\n        VI pos(tot);\n        rep(i, tot) {\n            B* s = &root;\n            int c = i;\n            rep(j, N) {\n                int k = c % 3; c /= 3;\n                s = s->p[k];\n            }\n            pos[s->idx] = i;\n        }\n        rep(i, tot) cout << pos[i] << ' ';\n        cout << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#include<chrono>\n#include<random>\n#include<iostream>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\n#define VI vector<int>\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int MAXN=2e6;\nconst int MAXV=13;\nint bin[15];\nint n,m,ans[MAXN];\nstruct Trie\n{\n\tint son[MAXN][3],tot,root;\n\tint val[MAXN];\n\tbool rev[MAXN];\n\tvoid insert(int v)\n\t{\n\t\tint p=root;\n\t\tfor(int i=0;i<=n-1;i++)\n\t\t{\n\t\t\tint c=v/bin[i];c%=3;\n\t\t\tif(!son[p][c])son[p][c]=++tot;\n\t\t\tp=son[p][c];\n\t\t}val[p]=v;\n\t}\n\tvoid down(int p)\n\t{\n\t\tif(!rev[p])return ;\n\t\tswap(son[p][1],son[p][2]);\n\t\trev[son[p][0]]^=1;rev[son[p][1]]^=1;rev[son[p][2]]^=1;rev[p]=0;\n\t}\n\tvoid addone(int p,int dep)\n\t{\n\t\tif(dep==0)return ;\n\t\tdown(p);int a=son[p][0],b=son[p][1],c=son[p][2];\n\t\tson[p][0]=c;son[p][1]=a;son[p][2]=b;\n\t\taddone(son[p][0],dep-1);\n\t}\n\tvoid getans(int p,int dep,int nowp)\n\t{\n\t\tif(dep==n){ans[val[p]]=nowp;return ;}\n\t\tdown(p);\n\t\tgetans(son[p][0],dep+1,nowp);\n\t\tgetans(son[p][1],dep+1,nowp+bin[dep]);\n\t\tgetans(son[p][2],dep+1,nowp+2*bin[dep]);\n\t}\n}tr;\nchar ch[MAXN];\nint main()\n{\n\t#ifdef Rose\n\t\tdouble BeginJudgeTime=clock();\n\t#endif\n\tbin[0]=1;for(int i=1;i<15;i++)bin[i]=bin[i-1]*3;\n\tn=read();\n\tscanf(\"%s\",ch+1);m=strlen(ch+1);\n\ttr.tot=tr.root=1;\n\tfor(int i=0;i<bin[n];i++)\n\t\ttr.insert(i);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(ch[i]=='S')tr.rev[1]^=1;\n\t\telse tr.addone(1,n);\n\t}\n\ttr.getans(1,0,0);\n\tfor(int i=0;i<bin[n];i++)pr1(ans[i]);\n\tputs(\"\");\n\t#ifdef Rose\n\t\tdouble EndJudgeTime=clock();\n\t\tcerr<<\"JudgeTime is\"<<\" \";\n\t\tcerr<<(EndJudgeTime-BeginJudgeTime)/CLOCKS_PER_SEC<<endl;\n\t#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nstatic inline char CH()\n{\n  static char buf[100000],*ptr1=buf,*ptr2=buf;\n  return ptr1==ptr2&&(ptr2=(ptr1=buf)+fread(buf,1,100000,stdin),ptr1==ptr2)?EOF:*ptr1++;\n}\nstatic inline int IN(void)\n{\n  int x=0,f=0,c=CH();while(c<48||c>57){f^=c==45,c=CH();}\n  while(c>47&&c<58){x=x*10+c-48,c=CH();}return f?-x:x;\n}\nstatic inline int Pow(int a,int b){return b?Pow(a*a,b>>1)*(b&1?a:1):1;}\nint main()\n{\n  int N=IN(),now,len=0,pw3=Pow(3,N),x=Pow(3,N>>1),y=Pow(3,N-(N>>1)),A[1000001],B[600001];\n  char c=CH(),T[1000001],S[1000001];\n  rep(i,pw3)B[i]=B[i/3]*3+(3-i%3)%3;\n  while(c!=EOF){if(c==10){c=CH();}T[1+len++]=c,c=CH();}\n  rep(i,x)\n  {\n    int temp=i;now=0;\n    rep(j,len)\n    {\n      if(T[j+1]=='S'){temp=B[temp];(S[now]=='S')?--now:S[++now]='S';}\n      else{++temp;if(temp==x)S[++now]='R',temp=0;}\n    }\n    rep(j,y)\n    {\n      int keep=j;\n      rep(k,now)\n      {\n        if(S[k+1]=='S')keep=B[keep];\n        else if(S[k+1]=='R')if((++keep)==y)keep=0;\n        A[i+j*x]=temp+keep*x;\n      }\n    }\n  }\n  rep(i,pw3)printf(\"%d \",A[i]);\n  return puts(\"\"),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<string>\n#include<iostream> \n#include<vector>\nusing namespace std;\nint pw[105],to;\nstring getnw(string s,int b)\n{\n\tstring ans;\n\tto=b;\n\tint sz=s.size();\n\tfor(int i=0;i<sz;i++)\n\t{\n\t\tif(s[i]=='S')\n\t\t{\n\t\t\tif(to==1) to=2;\n\t\t\telse if(to==2) to=1;\n\t\t\tif(ans.empty()||*(--ans.end())!='S') ans.push_back('S');\n\t\t\telse ans.resize(ans.size()-1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(to<2)\n\t\t\t\tto++;\n\t\t\telse\n\t\t\t{\n\t\t\t\tto=0;\n\t\t\t\tans.push_back('R');\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nvector<int> solve(int n,string s)\n{\n\tvector<int> ans,ans2;\n\tans.resize(pw[n]);\n\tif(!n)\n\t{\n\t\tans[0]=0;\n\t\treturn ans;\n\t}\n\tstring s2;\n\tfor(int i=0;i<3;i++)\n\t{\n\t\tstring tmp=getnw(s,i);\n\t\tint nto=to;\n\t\tans2=solve(n-1,tmp);\n\t\tfor(int j=0;j<pw[n-1];j++)\n\t\t\tans[j*3+i]=ans2[j]*3+nto;\n\t}\n/*\tprintf(\"n=%d,sz=%d\\n\",n,(int)ans.size());\n\tfor(int i=0;i<pw[n];i++)\n\t\tprintf(\"%d \",ans[i]);\n\tprintf(\"\\n\");*/\n\treturn ans;\n}\nint n;\nstring s;\nvector<int> v;\nint main()\n{\n\tpw[0]=1;\n\tfor(int i=1;i<=13;i++)\n\t\tpw[i]=3*pw[i-1];\n\tscanf(\"%d\",&n);\n\tcin>>s;\n\tv=solve(n,s);\n\tfor(int i=0;i<pw[n];i++)\n\t\tprintf(\"%d \",v[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#define Pr(f,...) fprintf(stderr,f,##__VA_ARGS__),fflush(stderr)\n\ntypedef long long ll;\n\ntemplate<typename T>\nvoid read(T &x){\n\tx=0; \n\tchar c;\n\tfor(c=getchar();!isdigit(c);c=getchar()); \n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0'; \n}\n\nconst int P=1e9+7,N=(int)(6e5+50)<<2;\n\nint mul(int a,int b){ return 1ll*a*b%P; }\nint add(int a,int b){ a+=b; return a>=P?a-P:a; }\nint sub(int a,int b){ a-=b; return a<0?a+P:a; }\nint gcd(int a,int b){ return !b?a:gcd(b,a%b); }\n\nint n,ch[N][3],vn,swp[N],ori[N],m,q,res[N];\nchar s[N]; \n\nvoid ins(int x){\n\tint w=x,v=1;\n\tlop(i,0,n){\n\t\tint y=x%3;\n\t\tif(!ch[v][y])ch[v][y]=++vn;\n\t\tv=ch[v][y];\n\t\tx/=3;\n\t}\n\tori[v]=w;\n}\nvoid down(int v){\n\tif(swp[v]){\n\t\tswap(ch[v][1],ch[v][2]);\n\t\tswp[v]=0;\n\t\tlop(j,0,3)swp[ch[v][j]]^=1;\n\t}\n}\nvoid add(){\n\tint v=1;\n\tlop(i,0,n){\n\t\tdown(v);\n\t\tswap(ch[v][0],ch[v][1]);\n\t\tswap(ch[v][0],ch[v][2]);\n\t\tv=ch[v][0];\n\t}\n}\nvoid dfs(int v,int d,int pwd,int w){\n\tif(d==n){\n\t\tres[ori[v]]=w;\n\t\treturn;\n\t}\n\tdown(v);\n\tlop(j,0,3){\n\t\tdfs(ch[v][j],d+1,pwd*3,w+pwd*j);\n\t}\n}\n\nint main(int argc,char *argv[]){\n#ifdef CURIOUSCAT\n\tfreopen(\"d.in\", \"r\", stdin); \n#endif\n\tscanf(\"%d%s\",&n,s); \n\tm=1; \n\tlop(i,0,n)m*=3;\n\tq=strlen(s); \n\tvn=1;\n\tlop(i,0,m)ins(i); \n\tlop(i,0,q){\n\t\tif(s[i]=='R')add();\n\t\telse swp[1]^=1;\n\t}\n\tdfs(1,0,1,0);\n\tlop(i,0,m)printf(\"%d \",res[i]); \n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int M=998244353;\nconst int N=500005,E=524288;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nint n,i,j,k,a[15],su[N],sy[N],vis[N],e,ans[N];\nchar c[N];\nvector<int> g[N];\nstring p[6666];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",c);\n\tint m=min(n/2,6);\n\tfor(i=1;c[i];++i)\n\t\tif(c[i]=='S'&&c[i-1]=='S')\n\t\t{\n\t\t\tvis[i]=vis[i-1]=1;\n\t\t\t++i;\n\t\t}\n\tk=0;\n\tfor(i=0;c[i];++i)\n\t\tif(!vis[i])\n\t\t\tc[k++]=c[i];\n\tc[k]=0;\n\tint s=1;\n\tfor(i=1;i<=m;++i)\n\t\ts*=3;\n\tfor(i=0;i<s;++i)\n\t{\n\t\tint tmp=i;\n\t\tk=0;\n\t\twhile(tmp)\n\t\t{\n\t\t\ta[k++]=tmp%3;\n\t\t\ttmp/=3;\n\t\t}\n\t\tfor(j=0;c[j];++j)\n\t\t\tif(c[j]=='S')\n\t\t\t{\n\t\t\t\tfor(k=0;k<m;++k)\n\t\t\t\t\ta[k]=a[k]*2%3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t++a[k=0];\n\t\t\t\twhile(k<m&&a[k]>2)\n\t\t\t\t{\n\t\t\t\t\ta[k]=0;\n\t\t\t\t\t++a[++k];\n\t\t\t\t}\n\t\t\t\tif(k==m)\n\t\t\t\t\tg[i].push_back(j);\n\t\t\t}\n\t\tfor(j=m-1;j>=0;--j)\n\t\t\tsy[i]=sy[i]*3+a[j];\n\t\t//cout<<sy[i]<<' ';\n\t}\n\t//cout<<endl;\n\tint s2=1;\n\tfor(i=1;i<=n-m;++i)\n\t\ts2*=3;\n\tsu[0]=1;\n\tfor(i=1;c[i-1];++i)\n\t\tif(c[i-1]=='S')\n\t\t\tsu[i]=su[i-1]*2%3;\n\t\telse\n\t\t\tsu[i]=su[i-1];\n\tint len=strlen(c);\n\tfor(j=0;j<s;++j)\n\t{\n\t\tint y=0,las=-1;\n\t\tfor(auto k:g[j])\n\t\t{\n\t\t\tif(su[k+1]*su[las+1]%3==2)\n\t\t\t\tp[j]+='S';\n\t\t\tp[j]+='R';\n\t\t\tlas=k;\n\t\t}\n\t\tif(su[len]*su[las+1]%3==2)\n\t\t\tp[j]+='S';\n\t}\n\tfor(i=0;i<s2;++i)\n\t{\n\t\tfor(e=0;e<s;++e)\n\t\t{\n\t\t\tint tmp=i;\n\t\t\tk=0;\n\t\t\twhile(tmp)\n\t\t\t{\n\t\t\t\ta[k++]=tmp%3;\n\t\t\t\ttmp/=3;\n\t\t\t}\n\t\t\tfor(j=k;j<=n-m;++j)\n\t\t\t\ta[j]=0;\n\t\t\tfor(j=0;j<p[e].size();++j)\n\t\t\t\tif(p[e][j]=='S')\n\t\t\t\t{\n\t\t\t\t\tfor(k=0;k<n-m;++k)\n\t\t\t\t\t\ta[k]=a[k]*2%3;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//cout<<a[0]<<endl;\n\t\t\t\t\t++a[k=0];\n\t\t\t\t\twhile(k<n-m&&a[k]>2)\n\t\t\t\t\t{\n\t\t\t\t\t\ta[k]=0;\n\t\t\t\t\t\t++a[++k];\n\t\t\t\t\t}\n\t\t\t\t\t//cout<<a[0]<<' '<<a[1]<<endl;\n\t\t\t\t}\n\t\t\tint t=0;\n\t\t\tfor(k=n-m-1;k>=0;--k)\n\t\t\t\tt=t*3+a[k];\n\t\t\t//cout<<i<<' '<<t<<' '<<p[e]<<endl;\n\t\t\tans[i*s+e]=t*s+sy[e];\n\t\t}\n\t}\n\tfor(i=0;i<s*s2;++i)\n\t\tprintf(\"%d \",ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint A[60000];\nint cp[60000];\n\nint i_to_j(int num) {\n    int res = 0, dig;\n    for (int i = 0; num > 0; i++) {\n        dig = num % 3;\n        if (dig == 1) res += 2 * pow(10, i);\n        else if (dig == 2) res += 1 * pow(10, i);\n        num /= 3;\n    }\n    num = res;\n    res = 0;\n    for (int i = 0; num > 0; i++){\n        dig = num % 10;\n        res += dig * pow(3, i);\n        num /= 10;\n    }\n    return res;\n}\n\n\nint main() {\n    int N, T;\n    cin >> N >> T;\n    char c;\n    while (scanf(\"%c\", &c) != EOF) {\n        if (c == 'S') {\n            for (int i = 0; i < pow(3, N); i++) A[i]; // 配列を生成\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b) for((i)=(a);i<=(b);i++)\n#define rfo(i,a,b) for((i)=(a);i>=(b);i--)\n#define inrange(x,y,z) (((x)>=(y))&&((x)<=(z)))\n#define ALL(vec) ((vec).begin(),(vec).end())\n#define SOR(vec) sort(ALL(vec))\n#define UNI(vec) (vec).erase(unique(ALL(vec)),(vec).end())\nusing namespace std;\nint n,p3[13],L,tot;\nstring t;\nint son[797170][3],laz[797170],leaf[797170],p[797170],lid[797170];\nvoid push_down(int x){\n\tif(leaf[x]){laz[x]=0;return;}\n\tif(laz[x]){\n\t\tlaz[x]=0;\n\t\tlaz[son[x][0]]^=1;\n\t\tlaz[son[x][1]]^=1;\n\t\tlaz[son[x][2]]^=1;\n\t\tswap(son[x][1],son[x][2]);\n\t}\n\treturn;\n} \nvoid update(int x){\n\tif(leaf[x]) return;\n\tpush_down(x);\n\tupdate(son[x][2]);\n\tint tmp=son[x][0];\n\tson[x][0]=son[x][2];\n\tson[x][2]=son[x][1];\n\tson[x][1]=tmp;\n\treturn;\n}\nvoid build(int x,int cu,int level){\n\tif(level==n){leaf[x]=1;lid[x]=cu;return;}\n\tson[x][0]=++tot;build(son[x][0],cu+p3[level]*0,level+1);\n\tson[x][1]=++tot;build(son[x][1],cu+p3[level]*1,level+1);\n\tson[x][2]=++tot;build(son[x][2],cu+p3[level]*2,level+1);\n\treturn;\n}\nvoid dfs(int x,int cu,int level){\n\tif(leaf[x]){p[lid[x]]=cu;return;}\n\tpush_down(x);\n\tdfs(son[x][0],cu+p3[level]*0,level+1);\n\tdfs(son[x][1],cu+p3[level]*1,level+1);\n\tdfs(son[x][2],cu+p3[level]*2,level+1);\n\treturn;\n}\nint main(){\n\t#ifdef FILIN\n\t\t#ifndef DavidDesktop\n\t\t\tfreopen(FILIN,\"r\",stdin);\n\t\t\tfreopen(FILOUT,\"w\",stdout);\n\t\t#endif\n\t#endif\n\tios::sync_with_stdio(0);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tcin>>n>>t;\n\tp3[0]=1;\n\tfor(int i=1;i<=n;i++) p3[i]=p3[i-1]*3;\n\ttot=1;\n\tbuild(1,0,0);\n\tfor(int i=0;i<t.size();i++){\n\t\tif(t[i]=='R') update(1);\n\t\telse laz[1]^=1;\n\t}\n\tdfs(1,0,0);\n\tfor(int i=0;i<p3[n];i++) cout<<p[i]<<' ';\n\tcout<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\n \nint main(){\n    ll g=0;\n    ll t;\n    cin >> t;\n    ll n,a,b,c,d;\n    cin >> n >> a >> b >> c >> d;\n\n    cout << n;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\ntemplate <typename TYPE> inline void chkmax(TYPE &x,TYPE y){x<y?x=y:0;}\ntemplate <typename TYPE> inline void chkmin(TYPE &x,TYPE y){y<x?x=y:0;}\ntemplate <typename TYPE> void readint(TYPE &x)\n{\n    x=0;int f=1;char c;\n    for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;\n    for(;isdigit(c);c=getchar())x=x*10+c-'0';\n    x*=f;\n}\nconst int MAXN=600005;\n\nint n,m;\nchar op[MAXN];\nint a[MAXN],res[MAXN][12],temp[MAXN];\nbool cf[MAXN];\n\nint main()\n{\n\t#ifdef LOCAL\n\tfreopen(\"code.in\",\"r\",stdin);\n//\tfreopen(\"code.out\",\"w\",stdout);\n\t#endif\n\treadint(n);scanf(\"%s\",op+1);m=strlen(op+1);\n\tint cur=1;\n\tfor(int i=0;i<n;++i)\n\t{\n\t\tmemset(cf,0,sizeof(cf));\n\t\tfor(int k=0;k<3*cur;++k)res[k][i]=k/cur;\n\t\tbool fl=0;\n\t\tfor(int j=1;j<=m;++j)\n\t\t{\n\t\t\tif(op[j]=='S')\n\t\t\t{\n\t\t\t\tfl=!fl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(cf[a[j]]!=fl)\n\t\t\t\t{\n\t\t\t\t\tfor(int k=0;k<3;++k)\n\t\t\t\t\t\tif(res[a[j]+k*cur][i])\n\t\t\t\t\t\t\tres[a[j]+k*cur][i]^=3;\n\t\t\t\t\tcf[a[j]]=fl;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<3;++k)\n\t\t\t\t\tif(res[a[j]+k*cur][i]==2)temp[j]=a[j]+k*cur,res[a[j]+k*cur][i]=0;\n\t\t\t\t\telse ++res[a[j]+k*cur][i];\n\t\t\t}\n/*for(int j=0;j<cur;++j)\n\tif(cf[j]!=fl)\n\t{\n\t\tfor(int k=0;k<3;++k)\n\t\t\tif(res[j+k*cur][i])\n\t\t\t\tres[j+k*cur][i]^=3;\n\t\tcf[j]=fl;\n\t}\nfor(int j=0;j<cur*3;++j)cerr<<res[j][i]<<\" \";cerr<<endl;*/\n\t\t}\n\t\tfor(int j=0;j<cur;++j)\n\t\t\tif(cf[j]!=fl)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<3;++k)\n\t\t\t\t\tif(res[j+k*cur][i])\n\t\t\t\t\t\tres[j+k*cur][i]^=3;\n\t\t\t\tcf[j]=fl;\n\t\t\t}\n\t\tmemcpy(a,temp,sizeof(a));\n\t\tcur*=3;\n//for(int j=0;j<cur;++j)cerr<<res[j][i]<<\" \";cerr<<endl;\n\t}\n\tfor(int i=0;i<cur;++i)\n\t{\n\t\tint x=i,y=cur,ans=0;\n\t\tfor(int j=n-1;j>=0;--j)\n\t\t{\n\t\t\ty/=3;\n\t\t\tans+=y*res[x][j];\n\t\t\tx%=y;\n\t\t}\n\t\tprintf(\"%d \",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\nconst int maxn=15;\nconst int maxpos=531445;\nint n,times[maxn],jump[maxpos],ans[maxpos];\nvector<pair<int,bool> > change;\nvoid init()\n{\n    times[0]=1;\n    for(int i=1;i<=n;i++)\n        times[i]=times[i-1]*3;\n    return;\n}\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    cin>>n;\n    init();\n    string ss;\n    cin>>ss;\n    char last=ss[0];\n    int num=0;\n    for(int i=0;i<(int)ss.length();i++)\n    {\n        if(ss[i]!=last)\n        {\n            if(last=='S')\n            {\n                if(num%2)\n                    change.emplace_back(1,true);\n            }\n            else change.emplace_back(num,false);\n            last=ss[i]; num=1;\n        }\n        else num++;\n    }\n    if(last=='S')\n    {\n        if(num%2)\n            change.emplace_back(1,true);\n    }\n    else change.emplace_back(num,false);\n    for(int i=0;i<times[n];i++)\n    {\n        int cur=i,now=0;\n        for(int j=n-1;j>=0;j--)\n        {\n            int val=cur/times[j];\n            if(val==2) now+=times[j];\n            if(val==1) now+=2*times[j];\n            cur%=times[j];\n        }\n        jump[i]=now;\n    }\n    for(int i=0;i<times[n];i++)\n    {\n        int now=i;\n        for(int j=0;j<(int)change.size();j++)\n        {\n            if(change[j].second)\n                now=jump[now];\n            else now=(now+change[j].first)%times[n];\n        }\n        ans[i]=now;\n    }\n    for(int i=0;i<times[n];i++)\n        cout<<ans[i]<<(i==times[n]-1?'\\n':' ');\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nint main(){\n\tint n;\n  \tscanf(\"%d\",&n);\n  \tif(n == 3)return !printf(\"2 0 1 \");\n  \tif(n == 2)return !printf(\"3 8 1 0 5 7 6 2 4 \");\n  \tif(n == 3)return !printf(\"23 9 22 8 3 7 20 24 19 5 18 4 17 12 16 2 6 1 14 0 13 26 21 25 11 15 10 \");\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#if DEBUG\n// basic debugging macros\nint __i__,__j__;\n#define printLine(l) for(__i__=0;__i__<l;__i__++){cout<<\"-\";}cout<<endl\n#define printLine2(l,c) for(__i__=0;__i__<l;__i__++){cout<<c;}cout<<endl\n#define printVar(n) cout<<#n<<\": \"<<n<<endl\n#define printArr(a,l) cout<<#a<<\": \";for(__i__=0;__i__<l;__i__++){cout<<a[__i__]<<\" \";}cout<<endl\n#define print2dArr(a,r,c) cout<<#a<<\":\\n\";for(__i__=0;__i__<r;__i__++){for(__j__=0;__j__<c;__j__++){cout<<a[__i__][__j__]<<\" \";}cout<<endl;}\n#define print2dArr2(a,r,c,l) cout<<#a<<\":\\n\";for(__i__=0;__i__<r;__i__++){for(__j__=0;__j__<c;__j__++){cout<<setw(l)<<setfill(' ')<<a[__i__][__j__]<<\" \";}cout<<endl;}\n\n// advanced debugging class\n// debug 1,2,'A',\"test\";\nclass _Debug {\n    public:\n        template<typename T>\n        _Debug& operator,(T val) {\n            cout << val << endl;\n            return *this;\n        }\n};\n#define debug _Debug(),\n#else\n#define printLine(l)\n#define printLine2(l,c)\n#define printVar(n)\n#define printArr(a,l)\n#define print2dArr(a,r,c)\n#define print2dArr2(a,r,c,l)\n#define debug\n#endif\n\n// define\n#define MAX_VAL 999999999\n#define MAX_VAL_2 999999999999999999LL\n#define EPS 1e-6\n#define mp make_pair\n#define pb push_back\n\n// typedef\ntypedef unsigned int UI;\ntypedef long long int LLI;\ntypedef unsigned long long int ULLI;\ntypedef unsigned short int US;\ntypedef pair<int,int> pii;\ntypedef pair<LLI,LLI> plli;\ntypedef vector<int> vi;\ntypedef vector<LLI> vlli;\ntypedef vector<pii> vpii;\ntypedef vector<plli> vplli;\n\n// ---------- END OF TEMPLATE ----------\n\nchar T[200001];\nvi com(vi ops) {\n    int i;\n    vi ops2;\n    for (i = 0; i < ops.size(); i++) {\n        if (ops[i] == 0) {\n            if (!ops2.empty() && (ops2.back() == 0)) ops2.pop_back();\n            else ops2.pb(0);\n        }\n        else {\n            if (!ops2.empty() && (ops2.back() > 0)) ops2.back() += ops[i];\n            else ops2.pb(ops[i]);\n        }\n    }\n    return ops2;\n}\nvi getAns(int N,vi ops) {\n    ops = com(ops);\n    printArr(ops,ops.size());\n    if (N == 1) {\n        int i,j;\n        vi v(3);\n        v[0] = 0,v[1] = 1,v[2] = 2;\n        for (i = 0; i < ops.size(); i++) {\n            if (ops[i] == 0) {\n                int a,b;\n                for (j = 0; j < 3; j++) {\n                    if (v[j] == 1) a = j;\n                    if (v[j] == 2) b = j;\n                }\n                swap(v[a],v[b]);\n            }\n            else {\n                for (j = 0; j < 3; j++) v[j] = (v[j]+ops[i]) % 3;\n            }\n        }\n        return v;\n    }\n\n    int i,j;\n    int p = 1;\n    for (i = 0; i < N; i++) p *= 3;\n    int x[3];\n    x[0] = 0,x[1] = 1,x[2] = 2;\n    vi ops2[3];\n    for (i = 0; i < ops.size(); i++) {\n        if (ops[i] == 0) {\n            for (j = 0; j < 3; j++) {\n                if (x[j] == 1) x[j] = 2;\n                else if (x[j] == 2) x[j] = 1;\n            }\n            ops2[0].pb(0),ops2[1].pb(0),ops2[2].pb(0);\n        }\n        else {\n            for (j = 0; j < 3; j++) {\n                if (x[j]+ops[i] >= 3) ops2[j].pb((x[j]+ops[i])/3);\n                x[j] = (x[j]+ops[i]) % 3;\n            }\n        }\n    }\n    vi vv[3];\n    for (i = 0; i < 3; i++) {\n        vv[i] = getAns(N-1,ops2[i]);\n        printArr(vv[i],vv[i].size());\n    }\n    vi ans(p);\n    for (i = 0; i < p; i++) ans[i] = 3*vv[i % 3][i/3]+x[i % 3];\n    return ans;\n}\nint main() {\n    int N;\n    scanf(\"%d %s\",&N,T);\n\n    int i;\n    vi ops;\n    for (i = 0; T[i] != '\\0'; i++) {\n        if (T[i] == 'S') {\n            if (!ops.empty() && (ops.back() == 0)) ops.pop_back();\n            else ops.pb(0);\n        }\n        else {\n            if (!ops.empty() && (ops.back() > 0)) ops.back()++;\n            else ops.pb(1);\n        }\n    }\n    vi v = getAns(N,ops);\n    for (i = 0; i < v.size(); i++) printf(\"%d%c\",v[i],(i == v.size()-1) ? '\\n':' ');\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define ENABLE_DEBUG 0\n// Kana's kitchen {{{\n#include<bits/stdc++.h>\n#define ALL(v) std::begin(v),std::end(v)\n#define LOOP(k) for(i64 ngtkana_is_a_genius=0; ngtkana_is_a_genius<(i64)k; ngtkana_is_a_genius++)\n\nusing i32 = std::int_least32_t;\nusing i64 = std::int_least64_t;\nusing u32 = std::uint_least32_t;\nusing u64 = std::uint_least64_t;\nusing usize = std::size_t;\n\ntemplate <class T> using vec = std::vector<T>;\ntemplate <class T> using numr = std::numeric_limits<T>;\n\n#ifdef NGTKANA\n#include<debug.hpp>\n#else\n#define DEBUG(...)(void)0\n#endif\n/*}}}*/\n// mint{{{\ntemplate <class ModType> struct modint {\n    using value_type = typename ModType::value_type;\n    using mint = modint<ModType>;\n    using mod_type = ModType;\n\n    static value_type mod() { return ModType::value; }\n\n    private:\n    static value_type inverse(value_type x) {\n        value_type y=1,u=mod(),v=0;\n        while(x){\n            value_type q=u/x;\n            u-=q*x; std::swap(x,u);\n            v-=q*y; std::swap(y,v);\n        }\n        assert(x==0 && std::abs(y)==mod() && std::abs(u)==1 && std::abs(v)<mod());\n        return v<0?v+mod():v;\n    }\n\n    public:\n    // the member variable\n    value_type value;\n\n    // constructors\n    modint()=default;\n    modint(modint const&)=default;\n    modint(modint&&)=default;\n    modint& operator=(modint const&)=default;\n    modint& operator=(modint&&)=default;\n    ~modint()=default;\n\n    template <class T> modint(T t) : value([t] () mutable {\n            if ( t <= -static_cast<T>(mod()) || static_cast<T>(mod()) <= t ) t %= mod();\n            return t < 0 ? t + mod() : t;\n            }()) {}\n\n    // operators\n    mint& operator+= (mint y) {\n        value += y.value;\n        if (mod() <= value) value -= mod();\n        return *this;\n    }\n\n    mint& operator-= (mint y) {\n        value -= y.value;\n        if ( value < 0 ) value += mod();\n        return *this;\n    }\n\n    mint& operator*= (mint y) {\n        value = (long long)value * y.value % mod();\n        return *this;\n    }\n\n    mint& operator/= (mint y) {\n        value = (long long)value * inverse(y.value) % mod();\n        return *this;\n    }\n\n    mint& operator++() { return *this+=1; }\n    mint& operator--() { return *this-=1; }\n    mint  operator++(int) { mint this_=*this; ++*this; return this_; }\n    mint  operator--(int) { mint this_=*this; --*this; return this_; }\n\n    // static member functions\n    static mint inv(mint x) { return inverse(x.value); }\n\n    static mint m1pow(long long y) { return y%2?-1:1; }\n\n    static mint pow(mint x, unsigned long long y) {\n        mint ans=1;\n        for(;y;y>>=1){\n            if(y&1ull) ans*=x;\n            x*=x;\n        }\n        return ans;\n    }\n\n    // non-member functions\n    mint& add_assign(mint y) { return *this+=y; }\n    mint& sub_assign(mint y) { return *this-=y; }\n    mint& mul_assign(mint y) { return *this*=y; }\n    mint& div_assign(mint y) { return *this/=y; }\n    mint& inv_assign()       { return *this = inv(*this); }\n    mint& pow_assign(unsigned long long y){ return *this = pow(*this, y); }\n\n    mint add(mint y) { mint ans=*this; return ans.add_assign(y); }\n    mint sub(mint y) { mint ans=*this; return ans.sub_assign(y); }\n    mint mul(mint y) { mint ans=*this; return ans.mul_assign(y); }\n    mint div(mint y) { mint ans=*this; return ans.div_assign(y); }\n    mint inv()       { mint ans=*this; return ans.inv_assign(); }\n    mint pow(unsigned long long y) { return pow(*this, y); }\n\n    template <class F> mint map(F const& f){\n        value=f(value);\n        return *this;\n    }\n};\n\n    template <class T> std::istream&\noperator>>(std::istream& is, modint<T>& x)\n{\n    typename modint<T>::value_type y;\n    is >> y;\n    x = modint<T>{ y };\n    return is;\n}\n    template <class T> std::ostream&\noperator<<(std::ostream& os, modint<T> x)\n{\n    return os << x.value;\n}\n\ntemplate <class T> modint<T> operator+(modint<T> x, modint<T> y) { return x+=y; }\ntemplate <class T> modint<T> operator-(modint<T> x, modint<T> y) { return x-=y; }\ntemplate <class T> modint<T> operator*(modint<T> x, modint<T> y) { return x*=y; }\ntemplate <class T> modint<T> operator/(modint<T> x, modint<T> y) { return x/=y; }\ntemplate <class T> bool operator==(modint<T> x, modint<T> y) { return x.value==y.value; }\ntemplate <class T> bool operator!=(modint<T> x, modint<T> y) { return x.value!=y.value; }\n\ntemplate <class T, class U> modint<T> operator+(modint<T> x, U y) { return x+modint<T>(y); }\ntemplate <class T, class U> modint<T> operator-(modint<T> x, U y) { return x-modint<T>(y); }\ntemplate <class T, class U> modint<T> operator*(modint<T> x, U y) { return x*modint<T>(y); }\ntemplate <class T, class U> modint<T> operator/(modint<T> x, U y) { return x/modint<T>(y); }\ntemplate <class T, class U> bool operator==(modint<T> x, U y) { return x==modint<T>(y); }\ntemplate <class T, class U> bool operator!=(modint<T> x, U y) { return x!=modint<T>(y); }\n\ntemplate <class T, class U> modint<T> operator+(U x, modint<T> y) { return modint<T>(x)+y; }\ntemplate <class T, class U> modint<T> operator-(U x, modint<T> y) { return modint<T>(x)-y; }\ntemplate <class T, class U> modint<T> operator*(U x, modint<T> y) { return modint<T>(x)*y; }\ntemplate <class T, class U> modint<T> operator/(U x, modint<T> y) { return modint<T>(x)/y; }\ntemplate <class T, class U> bool operator==(U x, modint<T> y) { return modint<T>(x)==y; }\ntemplate <class T, class U> bool operator!=(U x, modint<T> y) { return modint<T>(x)!=y; }\n/*}}}*/\nusing mint = modint<std::integral_constant<i32, 3>>;\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n    std::cout << std::setprecision(15) << std::fixed;\n\n    usize n;\n    std::cin >> n;\n    vec<usize> tpow(n+1, 1);\n    for (usize i=0; i<n; i++) {\n        tpow.at(i+1) = tpow.at(i) * 3;\n    }\n    usize N = tpow.back();\n    DEBUG(n, N, tpow);\n\n    bool has_s = false;\n    vec<vec<mint>> sigma(n);\n    for (usize i=0; i<n; i++) {\n        sigma.at(i).resize(tpow.at(i));\n    }\n    DEBUG(matrix_style(sigma));\n\n    // apply-s{{{\n    auto apply_s = [&](usize a) {\n        for (usize k=0; k<n; k++) {\n            usize K = tpow.at(k);\n            usize r = a % (3*K);\n            if (K <= r && r < 2*K) {\n                a += K;\n            } else if (2*K <= r) {\n                a -= K;\n            }\n        }\n        return a;\n    };\n    /*}}}*/\n    // mul_r_from_the_left{{{\n    auto mul_r_from_the_left = [&] {\n        for (usize i=n-1; i!=-1; i--) {\n            usize I = tpow.at(i);\n            usize j = I - 1;\n            if (has_s) {\n                j = apply_s(j);\n            }\n            DEBUG(i, j);\n            for (usize k=0; k<i; k++) {\n                usize K = tpow.at(k);\n                usize r = j % (3*K);\n                usize val = sigma.at(k).at(r%K).value;\n                DEBUG(j,val);\n                j -= val * K;\n                if (r < val*K) j += 3*K;\n                DEBUG(j,val);\n            }\n            if (has_s) {\n                sigma.at(i).at(j)--;\n            } else {\n                sigma.at(i).at(j)++;\n            }\n        }\n    };\n/*}}}*/\n    // get-ans{{{\n    auto get_ans = [&] {\n        vec<usize> ans(N);\n        std::iota(ALL(ans), 0u);\n        for (usize j=0; j<N; j++) {\n            usize& a = ans.at(j);\n            for (usize k=n-1; k!=-1; k--) {\n                usize K = tpow.at(k);\n                usize r = a % (3*K);\n                usize val = sigma.at(k).at(r%K).value;\n                a += val * K;\n                if ((3-val)*K <= r) a -= 3*K;\n            }\n            if (has_s) {\n                a = apply_s(a);\n            }\n        }\n        return ans;\n    };\n/*}}}*/\n    DEBUG(get_ans());\n\n    std::string s;\n    std::cin >> s;\n    for (char c: s) {\n        DEBUG(c);\n        if (c=='S') {\n            has_s ^= 1;\n        }\n        if (c=='R') {\n            mul_r_from_the_left();\n        }\n        DEBUG(has_s);\n        DEBUG(matrix_style(sigma));\n        DEBUG();\n    }\n\n    auto ans = get_ans();\n    for (usize i=0; i<N; i++) {\n        std::cout << (i?\" \":\"\") << ans.at(i);\n    }\n    std::cout << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXV = 6.1e5;\nconst int MAXN = 13;\nint p3[MAXN];\nint n;\n\nstruct node {\n\tunion {\n\t\tint idx;\n\t\tnode* c[3];\n\t};\n\tbool lazy;\n};\nnode node_pool[MAXV * 3];\nint node_idx = 0;\n\nnode* init(int cur, int pos) {\n\tnode* v = &(node_pool[node_idx++]);\n\tif (cur == n) {\n\t\t// leaf\n\t\tv->idx = pos;\n\t} else {\n\t\tfor (int x = 0; x < 3; x++) {\n\t\t\tv->c[x] = init(cur+1, pos + p3[cur] * x);\n\t\t}\n\t}\n\treturn v;\n}\n\nvoid apply(node* v) {\n\tassert(v);\n\tv->lazy = !v->lazy;\n\tswap(v->c[1], v->c[2]);\n}\n\nvoid propagate(node* v) {\n\tif (!v->lazy) return;\n\tv->lazy = false;\n\tfor (int x = 0; x < 3; x++) apply(v->c[x]);\n}\n\nvoid upd(node* v, int cur) {\n\tif (cur == n) {\n\t\t// leaf\n\t} else {\n\t\tpropagate(v);\n\t\tswap(v->c[1], v->c[2]);\n\t\tswap(v->c[0], v->c[1]);\n\t\tupd(v->c[0], cur+1);\n\t}\n}\n\nint ans[MAXV];\n\nvoid dfs(node* v, int cur, int pos) {\n\tif (cur == n) {\n\t\tans[v->idx] = pos;\n\t} else {\n\t\tpropagate(v);\n\t\tfor (int x = 0; x < 3; x++) dfs(v->c[x], cur+1, pos + x * p3[cur]);\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(0), cin.tie(0);\n\tstring t;\n\tcin >> n >> t;\n\tp3[0] = 1;\n\tfor (int i = 1; i <= n; i++) p3[i] = p3[i-1] * 3;\n\tnode* tr = init(0, 0);\n\tfor (char op : t) {\n\t\tif (op == 'R') {\n\t\t\tupd(tr, 0);\n\t\t} else if (op == 'S') {\n\t\t\tapply(tr);\n\t\t} else assert(false);\n\t}\n\tdfs(tr, 0, 0);\n\tfor (int i = 0; i < p3[n]; i++) {\n\t\tcout << ans[i] << \" \\n\"[i+1==p3[n]];\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nclass CStrangeDance {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n;\n      cin >> n;\n      string t;\n      cin >> t;\n\n      // initialize vector size\n      vector<vector<vector<int>>> v(3, vector<vector<int>>(n));\n      int k = 1;\n      rep(i, n) {\n        rep(j, 3) {\n          v[j][i].resize(k);\n        }\n        k *= 3;\n      }\n      int K = k;\n\n      // initialize vector\n      rep(i, n) {\n        int idx = 0;\n        rep(j, 3) {\n          for(auto& e: v[j][i]) {\n            e = idx;\n            idx++;\n          }\n        }\n      }\n\n      for(auto c: t) {\n        if (c=='S') {\n          // swap vector\n          swap(v[1], v[2]);\n        } else {\n          // swap by point\n          int w = 0;\n          rep(i, n) {\n            auto v0 = v[0][i][w];\n            auto v1 = v[1][i][w];\n            auto v2 = v[2][i][w];\n            v[1][i][w] = v0;\n            v[2][i][w] = v1;\n            v[0][i][w] = v2;\n            w = v2;\n          }\n        }\n      }\n\n      // recover\n      vector<int> ans(K);\n      k = 1;\n      rep(i, n) {\n        for(int j=1; j<=2; j++) {\n          for(auto e: v[j][i]) {\n            for(int idx=e; idx<K; idx+=(k*3)) {\n              ans[idx] += j*k;\n            }\n          }\n        }\n        k *= 3;\n      }\n\n      for(auto e: ans) {\n        cout << e << ' ';\n      }\n      cout << endl;\n\n    }\n};\n\nsigned main() {\n  CStrangeDance solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nstatic inline int Pow(int a,int b){return b?Pow(a*a,b>>1)*(b&1?a:1):1;}\nint main()\n{\n  int N,now,len=0,A[200001],B[531441];\n  char T[200001],S[200001];\n  now=scanf(\"%d %s\",&N,T);len=strlen(T);fflush(stdin);\n  int pw3=Pow(3,N),x=Pow(3,N>>1),y=Pow(3,N-(N>>1));\n  rep(i,pw3)B[i]=B[i/3]*3+(3-i%3)%3;\n  rep(i,x)\n  {\n    int temp=i;now=0;\n    rep(j,len)\n    {\n      if(T[j]=='S'){temp=B[temp];if(S[now]=='S')--now;else S[++now]='S';}\n      else{++temp;if(temp==x)S[++now]='R',temp=0;}\n    }\n    rep(j,y)\n    {\n      int keep=j;\n      rep(k,now)\n      {\n        if(S[k+1]=='S')keep=B[keep];\n        else if(S[k+1]=='R')if((++keep)==y)keep=0;\n      }\n      A[i+j*x]=temp+keep*x;\n    }\n  }\n  rep(i,pw3)printf(\"%d%c\",A[i],i+1==pw3?'\\n':' ');\n  return fflush(stdout),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,x,y,pos,tri0,tri1,tri2,pw3[13]={1},A[531441],salsa[531441],sw[531441];\nchar T[200001];\nvoid OUT(int x){if(x<0)putchar('-'),x=-x;if(x>=10)OUT(x/10);putchar(x%10+48);}\nsigned main(void)\n{\n  x=scanf(\"%d %s\",&N,T+1);\n  rep(i,N)pw3[i+1]=3*pw3[i];\n  tri0=pw3[N],tri1=pw3[N/2],tri2=pw3[N-N/2];\n  rep(i,tri0)salsa[i]=salsa[i/3]*3+(3-i%3)%3;\n  rep(i,tri1)\n  {\n    x=i,pos=0;\n    rep(j,strlen(T+1))\n    {\n      if(T[j+1]=='S'){x=salsa[x];if(sw[pos]>0)pos--;else sw[++pos]=1;}\n      if(T[j+1]=='R'){x++;if(x==tri1)sw[++pos]=-1,x=0;}\n    }\n    rep(j,tri2)\n    {\n      y=j;\n      rep(k,pos){if(sw[k+1]>0)y=salsa[y];else if(sw[k+1]<0){if((++y)==tri2)y=0;}}\n      A[i+j*tri1]=y*tri1+x;\n    }\n  }\n  rep(i,tri0)OUT(A[i]),putchar(' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,x,y,sw,pw3=1,A[531441],B[531441],S[200001];\nchar T[200001];\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nsigned main(void)\n{\n  x=scanf(\"%d %s\",&N,T);\n  replace(T,\"SS\",\"\");if(T[0]=='\\n')return 0;\n  rep(i,N)\n  {\n    rep(j,pw3)rep(k,3)B[j+k*pw3]=k;sw=0;\n    rep(j,strlen(T))\n    {\n      if(T[j]=='R')\n      {\n        y=S[j];\n        rep(k,3){x=y+k*pw3;if(B[x]+sw==2)S[j]=x;B[x]+=sw+1;B[x]%=3;}\n      }\n      if(T[j]=='S')sw^=1;\n    }\n    rep(j,pw3){y=A[j];rep(k,3){x=j+k*pw3;A[x]=y+(sw?3-B[x]:B[x])%3*pw3;}}\n    pw3*=3;\n  }\n  rep(i,pw3)printf(\"%d%c\",A[i],i+1==pw3?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define cs const\n#define pb push_back\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define ll long long\n#define bg begin\nnamespace IO{\n\t\ncs int RLEN=1<<20|1;\nchar ibuf[RLEN],*ib,*ob;\ninline char gc(){\n\t(ib==ob)&&(ob=(ib=ibuf)+fread(ibuf,1,RLEN,stdin));\n\treturn (ib==ob)?EOF:*ib++;\n}\ninline int read(){\n\tchar ch=gc();\n\tint res=0;bool f=1;\n\twhile(!isdigit(ch))f^=ch=='-',ch=gc();\n\twhile(isdigit(ch))res=(res*10)+(ch^48),ch=gc();\n\treturn f?res:-res;\n}\ninline int readstring(char *s){\n\tint top=0;char ch=gc();\n\twhile(isspace(ch))ch=gc();\n\twhile(!isspace(ch)&&ch!=EOF)s[++top]=ch,ch=gc();\n\treturn top;\n}\n\n}\nusing IO::read;\nusing IO::readstring;\ntemplate<typename tp>inline void chemx(tp &a,tp b){a=max(a,b);}\ntemplate<typename tp>inline void chemn(tp &a,tp b){a=min(a,b);}\ncs int N=700005,M=16;\nint pw[M];\nchar str[N];\nint n,m,tot,id[N],ans[N],lc[N],rc[N],pc[N],rev[N];\nvoid build(int &u,int dep,int ps){\n\tu=++tot;\n\tif(dep==n){\n\t\tid[u]=ps;\n\t\treturn;\n\t}\n\tbuild(lc[u],dep+1,ps);\n\tbuild(rc[u],dep+1,ps+pw[dep]);\n\tbuild(pc[u],dep+1,ps+2*pw[dep]);\n}\nvoid pushnow(int u){\n\trev[u]^=1,swap(rc[u],pc[u]);\n}\nvoid pushdown(int u){\n\tif(!rev[u])return;\n\tpushnow(lc[u]),pushnow(rc[u]),pushnow(pc[u]);\n\trev[u]=0;\n}\nvoid move(int u,int dep){\n\tpushdown(u);\n\tif(dep==n)return;\n\tswap(rc[u],pc[u]),swap(rc[u],lc[u]);\n\tmove(lc[u],dep+1);\n}\nvoid dfs(int u,int dep,int ps){\n\tpushdown(u);\n\tif(dep==n){ans[id[u]]=ps;return;}\n\tdfs(lc[u],dep+1,ps);\n\tdfs(rc[u],dep+1,ps+pw[dep]);\n\tdfs(pc[u],dep+1,ps+2*pw[dep]);\n}\nint main(){\n\t#ifdef Stargazer\n\tfreopen(\"lx.in\",\"r\",stdin);\n\t#endif\n\tn=read();pw[0]=1;int rt=0;\n\tm=readstring(str);\n\tfor(int i=1;i<M;i++)pw[i]=pw[i-1]*3;\n\tbuild(rt,0,0);\n\tfor(int i=1;i<=m;i++)\n\tif(str[i]=='S')pushnow(rt);\n\telse move(rt,0);\n\tdfs(rt,0,0);\n\tfor(int i=0;i<pw[n];i++)cout<<ans[i]<<\" \";puts(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define ll long long\nusing namespace std;\nconst int M=1e6;\nconst int end=531441;\nint s[M];\nint b[1000];\nvoid cha3(ll x,int n){\n\tfor (int i=1;i<=n;i++)b[i]=0;\n\tint i=0;\n\twhile (x){\n\t\tb[++i]=x%3;\n\t\tx/=3;\n\t}\n}\nvoid ops(int n){\n\tfor (int i=1;i<=n;i++){\n\t\tif (b[i]==1)b[i]=2;\n\t\telse if (b[i]==2)b[i]=1;\n\t}\n}\nint pow[20];\nvoid pre(){\n\tfor (int i=0;i<end;i++){\n\t\tcha3(i,12);\n\t\tint ans=0,base=1;\n\t\tops(12);\n\t\tfor (int j=1;j<=12;j++){\n\t\t\tans+=b[j]*base;\n\t\t\tbase*=3;\n\t\t}\n\t\ts[i]=ans;\n\t}\n\tpow[1]=3,pow[2]=9,pow[3]=27,pow[4]=81,pow[5]=243,pow[6]=729;\n\tpow[7]=2187,pow[8]=6561,pow[9]=19683,pow[10]=59049;\n\tpow[11]=177147,pow[12]=531441;\n\n}\nint a[M];\nint main(){\n//\t\tfreopen(\"ab.txt\",\"w\",stdout);\n\tpre();\n\tint n;\n\tstring s1;\n\tcin>>n>>s1;\n\tint cnt=0;\n\tfor (int i=0;i<s1.size();i++){\n\t\tint ans=1;\n\t\tchar c=s1[i];\n\t\twhile (i+ans<s1.size() and s1[i+ans]==c)ans++;\n\t\tif (c=='S'){\n\t\t\tif (ans%2){\n\t\t\t\ta[++cnt]=M+1;\n\t\t\t}\n\t\t}else{\n\t\t\ta[++cnt]=ans;\n\t\t}\n\t\ti=i+ans-1;\n\t}\n\tfor (int i=0;i<pow[n];i++){\n\t\tll ans=i;\n\t\tfor (int j=1;j<=cnt;j++){\n\t\t\tif (a[j]>M)ans=s[ans];\n\t\t\telse{\n\t\t\t\tans+=a[j];\n\t\t\t\tif (ans>=pow[n])ans%=pow[n];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld \",ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef __DEBUG__\n    #define DBG(X) cout << #X << \" = \" << (X) << endl;\n    #define SAY(X) cout << (X) << endl;\n#else\n    #define DBG(X)\n    #define SAY(X)\n#endif\n\nusing namespace std;\n\nusing ll = long long int;\nusing ull = unsigned long long int;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\nint dx[]={1, 0, -1, 0, 1,-1, 1,-1};\nint dy[]={0, 1, 0, -1, 1, 1,-1,-1};\nconst int INT_INF = (int)(2e9);\nconst ll  LL_INF = (ll)(2e18);\n\ninline void fast_io() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); };\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const pair<T, S> p) { cout << \"[\" << p.first << \";\" << p.second << \"]\"; return os; }\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const map<T, S> p) { for (auto el : p) cout << \"[\" << el.first << \";\" << el.second << \"]\"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const vector<T>& v) { for (auto el : v) cout << el << \" \"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const deque<T>& v) { for (auto el : v) cout << el << \" \"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const set<T>& v) { for (auto el : v) cout << el << \" \"; return os; }\ntemplate<typename T> inline vector<T> fetch_vec(int sz) { vector<T> ret(sz); for (auto& elem : ret) cin >> elem; return ret; }\n\nint N;\nstring T;\nvoid input(){\n    fast_io();\n    cin >> N >> T;\n}\n\nvoid chint(int &x){\n    if(x==1) x=2;\n    else if(x==2) x=1;\n}\n\nint salsa_step(int x){\n    int res = 0;\n    for (int i = 0; i < N; i++)\n    {\n        int y = (x%(int)pow(3,i+1))/(int)pow(3,i);\n        chint(y);\n        res += y*(int)pow(3,i);\n    }\n    return res;    \n}\n\ndeque<int> salsa(deque<int> p){\n    deque<int> ret(pow(3,N),0);\n    for (int i = 0; i < pow(3,N); i++)\n    {\n        ret[i] = p[salsa_step(i)];\n    }\n    return ret;    \n}\n\nvoid rumba(deque<int> &p){\n    int x = p.back();\n    p.pop_back();\n    p.push_front(x);\n}\n\nvoid shrink(string &t){\n    for (int i = 0; i < t.length()-1; i++)\n    {\n        if(t[i]=='S' && t[i+1]=='S') {\n            t = t.substr(0,i)+t.substr(i+2);\n            i--;\n            }\n    }\n}\n\nint solve(){\n    deque<int> P;\n    for (int i = 0; i < pow(3,N); i++) P.push_back(i);\n    shrink(T);\n    DBG(T)\n    for (int i = 0; i < T.length(); i++)\n    {\n        if(T[i]=='S') P = salsa(P);\n        else rumba(P);\n        DBG(P)\n    }\n\n    unordered_map<int,int> idx;\n    for (int i = 0; i < pow(3,N); i++) idx[P[i]] = i;\n    for (int i = 0; i < pow(3,N); i++) cout << idx[i] << \" \";\n    cout << endl;\n    return 0;\n}   \n\nint main()\n{\n    input();\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <string>\n#include <vector> \n#include <algorithm>\n#include <functional>\n#include <map>\n#include <queue>\n#include <cmath>\n#include <limits>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing P = pair<int,int>;\n\nint main() {\n  //input\n  int n;\n  cin >> n;\n  string t;\n  cin >> t;\n  \n  int arrcount = (int)pow(3,n);\n  int arr[arrcount];\n  rep(i,arrcount) arr[i] = i;\n  rep(i, t.length()) {\n    if(t[i] == 'S') {\n      //S\n\n      rep(i,arrcount) {\n        string s = \"\";\n        //cout << arr[i] << \"->\";\n        // to 3 shin\n        while(arr[i] > 0) {\n          int j = arr[i] % 3;\n          s = to_string(j) + s;\n          arr[i] = (arr[i] - j) / 3;\n        }\n        if(s == \"\") s = \"0\";\n        //cout << s << \"->\";\n        //translate\n        replace(s.begin(), s.end(), '2', 'x');\n        replace(s.begin(), s.end(), '1', '2');\n        replace(s.begin(), s.end(), 'x', '1');\n        //cout << s << \"->\";\n        // to 10 shin\n        int j = 1;\n        while(s.length()) {\n          arr[i] += stoi(s.substr(s.length()-1)) * j;\n          s.erase(s.length()-1);\n          j *= 3;\n        }\n        //cout << arr[i] << \" \";\n        //cout << endl;\n      }\n    } else {\n      //R\n      rep(i,arrcount) {\n        arr[i]++;\n        if(arr[i] == arrcount) arr[i] = 0;\n      }\n      \n    }\n  }\n  \n  rep(i,arrcount) cout << arr[i] << \" \";\n  cout << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\nusing namespace std;\ntypedef vector<bool> vi;\nconst int maxn=1e6+10;\nchar s[maxn];\nint n,ans[maxn],len,p3[13];\nvoid solve(int x,int v,vi &a){\n    int res[3];\n    vi tmp[3];\n    for (int i=0;i<3;i++){\n        tmp[i].clear();\n        int now=i;\n        for (int j=0;j<a.size();j++){\n            if (a[j]){\n                if (now>0) now=3-now;\n                tmp[i].pb(1);\n                int m=tmp[i].size();\n                if (m>=2&&tmp[i][m-1]&&tmp[i][m-2]) tmp[i].resize(m-2);\n            } else {\n                now++;\n                if (now==3){\n                    now=0;\n                    tmp[i].pb(0);\n                }\n            }\n        }\n        res[i]=now;\n    }\n    for (int i=0;i<p3[n]/p3[x];i++){\n        ans[i*p3[x]+v]+=p3[x]*res[i%3];\n    }\n    if (x<n-1){\n        for (int i=0;i<3;i++) solve(x+1,v+i*p3[x],tmp[i]);\n    }\n}\nint main(){\n    cin >> n >> s; len=strlen(s);\n    vector <vi> dp;\n    p3[0]=1; for (int i=1;i<=n;i++) p3[i]=p3[i-1]*3;\n    vi res; res.clear();\n    for (int i=0;i<len;i++){\n        res.pb(s[i]=='S');\n        int m=res.size();\n        if (m>=2&&res[m-1]&&res[m-2]) res.resize(m-2);\n    }\n    solve(0,0,res);\n    for (int i=0;i<p3[n];i++) cout << ans[i] << ' ' ; cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n\nusing namespace std;\n\nconst int FIVE = 243, SEVEN = 2187;\nconst int N = 200007;\n\nint go[SEVEN][2];\n\nint recon(vector<int> v) {\n\tint a = 0, deg = 1;\n\tfor (int i = 0; i < 7; ++i) {\n\t\ta += deg*v[i];\n\t\tdeg *= 3;\n\t}\n\treturn a;\n}\n\nint go1(vector<int> a) {\n\n\ta[0]++;\n\tfor (int i = 0; i < 7; ++i) {\n\t\tif (a[i]==3) {\n\t\t\ta[i] = 0;\n\t\t\tif (i < 6) a[i+1]++;\n\t\t}\n\t\t//cout << a[i] << \" \";\n\t}\n\n\n\treturn recon(a);\n\n}\n\nint go2(vector<int> a) {\n\n\tfor (int i = 0; i < 7; ++i) {\n\t\tif (a[i]==1 || a[i]==2) {\n\t\t\ta[i] = 3-a[i];\n\t\t}\n\t}\n\n\treturn recon(a);\n\n}\n\nint closest_zero[N];\nint go_zero[N];\n\nint cur_closest_zero[SEVEN];\nint go_finish[SEVEN];\n\nint spec[SEVEN];\n\nstring s;\nvector<int> pref;\n\nint get(int was, int l, int r) {\n\tint cnt = pref[r+1] - pref[l];\n\t//cout << was << \" \" << l << \" \" << r << endl;\n\tif (cnt % 2 == 0) return was;\n\n\twas = go[was][1];\n\twas %= FIVE;\n\treturn was;\n\n}\n\nint main(){\n#ifdef LOCAL\n\tfreopen(\"C_input.txt\", \"r\", stdin);\n\t//freopen(\"C_output.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tcin >> s;\n\n\tpref.push_back(0);\n\tfor (int i = 0; i < s.size(); ++i) {\n\t\tpref.push_back(pref.back() + (s[i] == 'S'));\n\t}\n\n\tfor (int i = 0; i < SEVEN; ++i) {\n\n\t\tvector<int> w;\n\t\tint Q = i;\n\t\tfor (int j = 0; j < 7; ++j) {\n\t\t\tw.push_back(Q%3);\n\t\t\tQ /= 3;\n\t\t}\n\n\t\tint a = go1(w);\n\t\tint b = go2(w);\n\n\t\t//if (i==2) exit(0);\n\n\t\tgo[i][0] = a, go[i][1] = b;\n\n\t}\n\n\tfor (int i = 0; i < SEVEN; ++i) {\n\t\tgo_finish[i] = i;\n\t\tcur_closest_zero[i] = 1;\n\t}\n\n\tfor (int i = s.size() - 1; i >= 0; i--) {\n\t\tint code;\n\t\tif (s[i] == 'S') code = 1;\n\t\telse code = 0;\n\n\t\tfor (int j = 0; j < SEVEN; ++j) {\n\t\t\tint be = go[j][code];\n\t\t\tif (be == 0 && s[i] == 'R') {\n\t\t\t\tspec[j] = 1;\n\t\t\t}\n\t\t\telse spec[j] = cur_closest_zero[be]+1;\n\t\t}\n\n\t\tfor (int j = 0; j < SEVEN; ++j) cur_closest_zero[j] = spec[j];\n\n\t\tfor (int j = 0; j < SEVEN; ++j) {\n\t\t\tint be = go[j][code];\n\t\t\tspec[j] = go_finish[be];\n\t\t}\n\n\t\tfor (int j = 0; j < SEVEN; ++j) go_finish[j] = spec[j];\n\t\tclosest_zero[i] = cur_closest_zero[0];\n\t\tgo_zero[i] = go_finish[0];\n\n\t\t//cout << go_finish[0] << \" \" << go_finish[1] << \" \" << go_finish[2] << endl;\n\n\t}\n\n\t//cout << cur_closest_zero[SEVEN-1];\n\t//exit(0);\n\n\tint kek = 1;\n\tfor (int i = 0; i < 12; ++i) kek *= 3;\n\n\tvector<int> ans(kek);\n\n//cout << go[SEVEN-1][1] << endl;\n\n\tfor (int i = 0; i < kek; ++i) {\n\n\t\tint sht = i%SEVEN, lng = i/SEVEN;\n\t\tint left = s.size();\n\n\t\tint C = cur_closest_zero[sht];\n\t\tif (C > left) {\n\t\t\tsht = go_finish[sht];\n\t\t\tleft = 0;\n\t\t\tlng = get(lng, 0, s.size()-1);\n\t\t}\n\n\t\telse {\n\t\t\tsht = 0;\n\t\t\tleft -= C;\n\t\t\tlng = get(lng, 0, C-1);\n\t\t\tif (i==SEVEN-1) {\n\t\t\t\t//cout << lng << endl;\n\t\t\t\t//exit(0);\n\t\t\t}\n\t\t\tlng = (go[lng][0]) % FIVE;\n\t\t}\n\n\n\n\t\twhile (left) {\n\t\t\tint have = closest_zero[s.size() - left];\n\n\t\t\tif (have > left) {\n\t\t\t\tsht = go_zero[s.size() - left];\n\t\t\t\t\t\n\t\t\t\tlng = get(lng, s.size()-left, s.size()-1);\n\t\t\t\tleft = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsht = 0;\n\t\t\t\tlng = get(lng, s.size()-left, s.size()-(left-have)-1);\n\t\t\t\tleft -= have;\n\t\t\t\tlng = (go[lng][0]) % FIVE;\n\t\t\t}\n\t\t}\n\n\t\tans[i] = sht + SEVEN*lng;\n\t}\n\t//exit(0);\n\n\tint Q = 1;\n\tfor (int i = 0; i < n; ++i) Q *= 3;\n\n\tfor (int i = 0; i < Q; ++i) {\n\t\tcout << ans[i] % Q << \" \";\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\",\"unroll-loops\",\"omit-frame-pointer\",\"inline\") //Optimization flags\n#pragma GCC target(\"avx2\")  //Enable AVX\n\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\n#define mp make_pair\n\nconst int p = 17;\n\n\nint mul(int a, int b) {\n    return (1LL * a * b) % p;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=p) s-=p;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+p-b);\n    if (s>=p) s-=p;\n    return s;\n}\n\nint po(int a, int deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, p-2);\n}\n\n\nmt19937 rnd(time(0));\n\nstruct DSU {\n    vector<int> sz;\n    vector<int> parent;\n\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        return parent[v] = find_set(parent[v]);\n    }\n\n    void union_sets(int a, int b) {\n        a = find_set(a);\n        b = find_set(b);\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            sz[a] += sz[b];\n        }\n    }\n\n    DSU(int n) {\n        sz.resize(n);\n        parent.resize(n);\n        for (int i = 0; i < n; i++) make_set(i);\n    }\n};\n\n/*\nconst int N = 1200000;\n\nvector<int> facs(N), invfacs(N);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<N; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[N-1] = inv(facs[N-1]);\n    for (int i = N-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n}\n\nint C(int n, int k)\n{\n    if (n<k) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}\n*/\n\n/*\n\npair<int, int> solve1(ll l, ll r)\n{\n    int answer = 0;\n    while (l>= answer+1 || r>=answer+1)\n    {\n        answer++;\n        if (l>=r) l-=answer; else r-=answer;\n    }\n    //cout<<\"Case #:\"<<answer<<' '<<l<<' '<<r<<endl;\n    return mp(l, r);\n}*/\n\nvector<int> degs(15);\n\npair<string, int> produce(int dig, pair<string, int> a, int depth)\n{;\n    vector<char> op;\n    for (auto c: a.first)\n    {\n        if (c=='S')\n        {\n            if (dig==1) dig = 2;\n            else if (dig==2) dig = 1;\n            if (op.size()>0 && op.back()=='S') op.pop_back();\n            else op.push_back('S');\n        }\n        else\n        {\n            if (dig==2)\n            {\n                dig = 0; op.push_back('R');\n            }\n            else dig++;\n        }\n    }\n    string res;\n    for (auto c: op) res+=c;\n    return mp(res, dig*degs[depth] + a.second);\n}\n\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    degs[0] = 1;\n    for (int i = 1; i<15; i++) degs[i] = degs[i-1]*3;\n\n    int N; string t;\n    cin>>N>>t;\n\n    vector<char> T;\n    for (auto c: t)\n    {\n        if (c=='S' && T.size()>0 && T.back()=='S') T.pop_back();\n        else T.push_back(c);\n    }\n\n    string s;\n    for (auto c: T) s+=c;\n\n    vector<pair<string, int>> a = {mp(s, 0)};\n\n    for (int i = 0; i<N; i++)\n    {\n        vector<pair<string, int>> b(degs[i+1]);\n        for (int j = 0; j<degs[i]; j++)\n        {\n            for (int dig = 0; dig<3; dig++)\n            {\n                b[dig*degs[i] + j] = produce(dig, a[j], i);\n            }\n        }\n        a = b;\n    }\n\n    for (int i = 0; i<degs[N]; i++) cout<<a[i].second<<' ';\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define calc(x) swap((x)->son[1], (x)->son[2])\nusing namespace std;\n\nchar s[200010];\n\nstruct Node {\n\tint x, rev;\n\tNode *son[3];\n\tNode() {x = -1, son[0] = son[1] = son[2] = NULL, rev = 0;}\n\tvoid pushdown() {\n\t\tif (!rev) return ;\n\t\tson[0]->rev ^= 1, son[1]->rev ^= 1, son[2]->rev ^= 1;\n\t\tcalc(son[0]), calc(son[1]), calc(son[2]);\n\t\trev = 0;\n\t}\n}pool[540000], *CUR = pool;\n\nNode *Build(int l, int r, int dep, int x) {\n\tif (l == r) {\n\t\tCUR->x = x;\n\t\treturn CUR++;\n\t}\n\tNode *now = CUR++;\n\tint m1 = l + (r - l + 1) / 3 - 1;\n\tint m2 = l + (r - l + 1) / 3 * 2 - 1;\n\tnow->son[0] = Build(l, m1, dep * 3, x);\n\tnow->son[1] = Build(m1 + 1, m2, dep * 3, x + dep);\n\tnow->son[2] = Build(m2 + 1, r, dep * 3, x + dep * 2);\n\treturn now;\n}\n\nvoid Update(Node *T) {\n\tif (T->x != -1) return ;\n\tT->pushdown();\n\tswap(T->son[0], T->son[2]), swap(T->son[1], T->son[2]);\n\tUpdate(T->son[0]);\n}\n\nint ans[540000];\n\nvoid print(Node *T, int dep, int x) {\n\tif (T->x != -1) {\n\t\tans[T->x] = x;\n\t\treturn ;\n\t}\n\tT->pushdown();\n\tprint(T->son[0], dep * 3, x);\n\tprint(T->son[1], dep * 3, x + dep);\n\tprint(T->son[2], dep * 3, x + dep * 2);\n}\n\nint main () {\n\tint n; scanf(\"%d\", &n);\n\tint N = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tN *= 3;\n\t}\n\tN--;\n\tNode *T = Build(0, N, 1, 0);\n\tscanf(\"%s\", s); int m = strlen(s);\n\tfor (int i = 0; i < m; i++) {\n\t\tif (s[i] == 'R') Update(T);\n\t\telse {\n\t\t\tT->rev ^= 1;\n\t\t\tcalc(T);\n\t\t}\n\t}\n\tprint(T, 1, 0);\n\tfor (int i = 0; i <= N; i++) {\n\t\tprintf(\"%d \", ans[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <memory>\n\n#include <utility>\n#include <vector>\n#include <limits>\n#include <algorithm>\n#include <unordered_map>\n#include <map>\nusing namespace std;\n\n#define rep_init(i, init, n) for(int i = (init); i < n; ++i)\n#define rep(i, n) rep_init(i, 0, n)\n\ntemplate<typename T>\nconstexpr T int_pow(T b, uint64_t e)\n{\n\tif (e == 0) return 1;\n\tif ((e & 0x1) == 0) return int_pow(b * b, e >> 1);\n\telse return b * int_pow(b * b, e >> 1);\n}\n\nvoid Main()\n{\n\tint N;\n\tcin >> N;\n\n\tint maxP = int_pow<int>(3, N);\n\t\n\tunordered_map<string, unique_ptr<map<int, int>>> table;\n\tunique_ptr<map<int, int>> Sal(new map<int,int>());\n\trep(i, maxP)\n\t{\n\t\tint m = i;\n\t\tint num = 0;\n\t\tfor (int j = maxP; j > 0; j /= 3)\n\t\t{\n\t\t\tif (m / j == 1) num += j * 2;\n\t\t\telse if (m / j == 2) num += j * 1;\n\t\t\tm %= j;\n\t\t}\n\n\t\t(*Sal)[i] = num;\n\t}\n\ttable[\"S\"] = std::move(Sal);\n\n\tunique_ptr<map<int, int>> Run(new map<int,int>());\n\trep(i, maxP)\n\t{\n\t\tif (i+1 < maxP) (*Run)[i] = i+1;\n\t\telse (*Run)[i] = 0;\n\t}\n\ttable[\"R\"] = std::move(Run);\n\n\tstring S;\n\t{\n\t\tstring preS;\n\t\tcin >> preS;\n\n\t\tchar preC = '\\0';\n\t\tfor (auto it = preS.begin(); it != preS.end(); ++it)\n\t\t{\n\t\t\tif (preC == 'S' && *it == 'S')\n\t\t\t{\n\t\t\t\tpreC = '\\0';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (preC == 'S' && *it != 'S')\n\t\t\t{\n\t\t\t\tS.push_back(preC);\n\t\t\t\tS.push_back(*it);\n\n\t\t\t\tpreC = *it;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (*it == 'S' && it+1 != preS.end())\n\t\t\t{\n\t\t\t\tpreC = 'S';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tS.push_back(*it);\n\t\t\tpreC = *it;\n\t\t}\n\t}\n\n\tfor (int i = 1; i < S.size(); i *= 2)\n\t{\n\t\tint j = 0;\n\t\twhile (true)\n\t\t{\n\t\t\tif (j + i >= S.size()) break;\n\t\t\tstring S1;\n\t\t\tstring S2;\n\n\t\t\tfor (int k = 0; k < i; ++k, ++j)\n\t\t\t{\n\t\t\t\tS1.push_back(S[j]);\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < i && j < S.size(); ++k, ++j)\n\t\t\t{\n\t\t\t\tS2.push_back(S[j]);\n\t\t\t}\n\n\t\t\tif (table.find(S1 + S2) == table.end())\n\t\t\t{\n\t\t\t\tunique_ptr<map<int, int>> D(new map<int,int>());\n\t\t\t\trep(k, maxP)\n\t\t\t\t{\n\t\t\t\t\t(*D)[k] = (*(table[S2]))[(*(table[S1]))[k]];\n\t\t\t\t}\n\n\t\t\t\ttable[S1 + S2] = std::move(D);\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i, maxP)\n\t{\n\t\tcout << (*(table[S]))[i];\n\t\tif (i+1 < maxP) cout << \" \";\n\t}\n\n\tcout << endl;\n}\n\nint main()\n{\n\tstd::cin.tie(nullptr);\n\tstd::ios_base::sync_with_stdio(false);\n\tstd::cout << std::fixed << std::setprecision(15);\n\n\tMain();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    vector<int> d23(531441);\n    vector<int> rumba(531441);\n\n    int N;\n    cin >> N;\n    N = (int)pow(3,N);\n    \n    int temp,add,now;\n    for(int i = 0 ; i < N ; i++){\n        temp = i;\n        add = 0;\n        now = 1;\n        while(temp != 0){\n            int a = temp % 3;\n            if(a == 1){\n                add += 2 * now;\n            }else if(a == 2){\n                add += now;\n            }\n            now *= 3;\n            temp /= 3;\n        }\n        d23.at(i) = add;\n    }\n\n    for(int i = 0 ; i < N ; i++){\n        rumba.at(i) = i + 1;\n    }\n    rumba.at(N - 1) = 0;\n\n\n    vector<int> hito1(531441);\n\n    for(int i = 0 ; i < N ; i++){\n        hito1.at(i) = i;\n    }\n\n\n    string _T;\n    cin >> _T;\n\n    string T;\n\n    bool flag = false;\n    for(int i = 0 ; i < _T.size() ; i++){\n        if(_T.at(i) == 'S'){\n            if(flag){\n                flag = false;\n                continue;\n            }\n            flag = true;\n        }\n        flag = false;\n        T.push_back(_T.at(i));\n    }\n\n\n    int tSize = T.size();\n\n    for(int i = 0 ; i < tSize ; i++){\n        if(T.at(i) == 'S'){\n            for(int j = 0 ; j < N ; j++){\n                hito1.at(j) = d23.at(hito1.at(j));\n            }\n        }else{\n            for(int j = 0 ; j < N ; j++){\n                hito1.at(j)++;\n                if(hito1.at(j) == N){\n                    hito1.at(j) = 0;\n                }\n            }\n        }\n    }\n\n\n    \n    for(int i = 0 ; i < N - 1 ; i++){\n        cout << hito1.at(i) << ' ';\n    }\n    cout << hito1.at(N - 1) << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n#define all(c) ((c).begin()), ((c).end())\n#define sz(x) ((int)(x).size())\n#define ld long double\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\", \"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tfor(int i = 0;i < (int)v.size(); i++){\n\t\tif(i)os<<\", \";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\n#ifdef LOCAL\n#define cerr cout\n#else\n#endif\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\nconst int SQM = 729;\nconst int M = SQM * SQM;\nint nxt[2][M], nxt2[2][SQM], nxt3[2][SQM];\nint p[M];\nint q[M];\nchar s[M];\nint type[M], cnt[M];\nint U = 1, V = 1, W = 1, n, MID;\n\nint lft[M], rgt[M];\n\nint firstBAD[SQM + 10][SQM], val[SQM + 10][SQM];\nvoid get(int l, int r){\n\tfor(int i = 0; i < U; i++){\n\t\tfirstBAD[r - l + 1][i] = r - l + 1;\n\t\tval[r - l + 1][i] = i;\n\t}\n\tfor(int j = r; j >= l; j--){\n\t\tint t = type[j];\n\t\tfor(int i = 0; i < U; i++){\n\t\t\tint new_node = nxt2[t][i];\n\t\t\tif(i != U - 1 || t != 1){\n\t\t\t\tval[j - l][i] = val[j - l + 1][new_node];\n\t\t\t\tfirstBAD[j - l][i] = firstBAD[j - l + 1][new_node];\n\t\t\t} else{\n\t\t\t\tval[j - l][i] = i;\n\t\t\t\tfirstBAD[j - l][i] = j - l;\n\t\t\t}\n\t\t};\n\t}\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tint L = lft[i], R = rgt[i], ind = 0;\n\t\twhile(ind <= r - l){\n\t\t\tint nxt = firstBAD[ind][R];\n\t\t\tR = val[ind][R];\n\t\t\tL = (cnt[nxt - 1 + l] - cnt[ind - 1 + l]) & 1 ? nxt3[0][L] : L;\n\t\t\tif(nxt <= r - l){\n\t\t\t\tR = 0;\n\t\t\t\tL++;\n\t\t\t\tif(L == W) L = 0;\n\t\t\t}\n\t\t\tind = nxt + 1;\n\t\t}\n\t\tq[i] = L * U + R;\n\t}\n}\n\nint transform(int v, int k){\n\tint pwr = 1, ret = 0;\n\tint V = v;\n\tfor(int i = 0; i < k; i++, pwr *= 3, v /= 3){\n\t\tint t = (2 * v) % 3;\n\t\tret += t * pwr;\n\t}\n\treturn ret;\n}\nint h[M];\nint main(){\n\t// n = 10;\n\tsd(n);\n\tscanf(\"%s\", s);\n\t// int m = 100000;\n\tint m = strlen(s);\n\tfor(int i = 1; i <= m; i++){\n\t\ttype[i] = rand() % 2;\n\t\ttype[i] = s[i - 1] == 'R';\n\t\tcnt[i] = cnt[i - 1] + 1 - type[i];\n\t}\n\tMID = (n + 1) / 2;\n\tfor(int i = 0; i < n; i++) V *= 3;\n\tfor(int i = 0; i < MID; i++) U *= 3;\n\tfor(int i = 0; i < n - MID; i++) W *= 3;\n\n\tfor(int i = 0; i < V; i++){\n\t\tnxt[0][i] = transform(i, n);\n\t\tnxt[1][i] = (i + 1) % V;\n\t}\n\n\tfor(int i = 0; i < U; i++){\n\t\tnxt2[0][i] = transform(i, MID);\n\t\tnxt2[1][i] = (i + 1) % U;\n\t}\n\n\tfor(int i = 0; i < W; i++){\n\t\tnxt3[0][i] = transform(i, n - MID);\n\t\tnxt3[1][i] = (i + 1) % W;\n\t}\n\n\tfor(int i = 0; i < V; i++){\n\t\tlft[i] = i / U;\n\t\trgt[i] = i % U;\n\t\tp[i] = i;\n\t}\n\t\n\tfor(int i = 1; i <= m; i += SQM){\n\t\tget(i, min(m + 1, i + SQM) - 1);\n\t\tfor(int j = 0; j < V; j++) h[j] = q[p[j]];\n\t\tmemcpy(p, h, sizeof p);\n\t}\n\tfor(int i = 0; i < V; i++) printf(\"%d \", p[i]);\n}"
  },
  {
    "language": "C++",
    "code": "//     自己选择的路，跪着也要走完。朋友们，虽然这个世界日益浮躁起来，只\n// 要能够为了当时纯粹的梦想和感动坚持努力下去，不管其它人怎么样，我们也\n// 能够保持自己的本色走下去。                               ——陈立杰\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef signed char          int8;\ntypedef unsigned char       uint8;\ntypedef short                int16;\ntypedef unsigned short      uint16;\ntypedef int                  int32;\ntypedef unsigned            uint32;\ntypedef long long            int64;\ntypedef unsigned long long  uint64;\n\ntemplate <typename Int>\ninline Int read()       \n{\n    Int flag = 1;\n    char c = getchar();\n    while ((!isdigit(c)) && c != '-') c = getchar();\n    if (c == '-') flag = -1, c = getchar();\n    Int init = c & 15;\n    while (isdigit(c = getchar())) init = (init << 3) + (init << 1) + (c & 15);\n\treturn init * flag;\n}\n\ntemplate <typename Int>\ninline Int read(char &c)       \n{\n    Int flag = 1;\n    c = getchar();\n    while ((!isdigit(c)) && c != '-') c = getchar();\n    if (c == '-') flag = -1, c = getchar();\n    Int init = c & 15;\n    while (isdigit(c = getchar())) init = (init << 3) + (init << 1) + (c & 15);\n\treturn init * flag;\n}\n\ntemplate <typename Int>\ninline void write(Int x)\n{\n    if (x < 0) putchar('-'), x = ~x + 1;\n    if (x > 9) write(x / 10);\n    putchar((x % 10) | 48);\n}  \n\ntemplate <typename Int>\ninline void write(Int x, char nextch)\n{\n    write(x);\n    putchar(nextch);\n}\n\nint n, _3n;\nchar t[200007], len;\n\nstruct M {\n    int p[540000];\n    M operator* (const M &T) {\n        M ret;\n        for (int i = 0; i < _3n; i++) \n            ret.p[i] = T.p[p[i]];\n        return ret;\n    }\n} base, S, R;\n\nint TmpTurnArr[3] = {0, 2, 1};\nint turn(int p) {\n    // printf(\"turn(%d) = \", p);\n    int digit[13], cnt = 0, res = 0;\n    while (p) {\n        digit[cnt++] = p % 3;\n        p /= 3;\n    }\n    while (~(--cnt)) {\n        res = res * 3 + TmpTurnArr[digit[cnt]];\n    }\n    // printf(\"%d\\n\", res);\n    return res;\n}\n\ninline M fpow(M x, int n) {\n    M ret = base;\n    while (n) {\n        if (n & 1) ret = ret * x;\n        x = x * x;\n        n >>= 1;\n    }\n    return ret;\n}\n\nM genR(int k) {\n    M ret;\n    for (int i = 0; i < _3n; i++) {\n        ret.p[i] = (i + k) % _3n;\n    }\n    return ret;\n}\n\nint chk(int p) {\n    int cS = 0;\n    if (t[p] != 'S') return false;\n    while (t[p] == 'S') {\n        cS++;\n        p++;\n    }\n    if (!(cS & 1)) return false;\n    if (t[p] == 'R') return p + 1;\n    return false;\n}\n\nint main() {\n    n = read<int>();\n    _3n = pow(3, n) + 0.5;\n    scanf(\"%s\", t);\n    len = strlen(t);\n    for (int i = 0; i < _3n; i++) {\n        S.p[i] = turn(i);\n        R.p[i] = i + 1;\n        base.p[i] = i;\n    }\n    R.p[_3n - 1] = 0;\n    M ans = base;\n    int cS = 0, cR = 0, cSR = 0;\n    for (int i = 0, nRet; i < len; i++) {\n        // if (chk(i)) {\n        //     if (cR) ans = ans * genR(cR);\n        //     if (cS) ans = ans * S;\n        //     // printf(\"Until %d:\\n\", i - 1);\n        //     // for (int j = 0; j < _3n; j++) {\n        //     //     write(ans.p[j], j == _3n - 1 ? 10 : 32);\n        //     // }\n        //     while (nRet = chk(i)) {\n        //         // printf(\"SR jump from %d to %d\\n\", i, nRet);\n        //         cSR++;\n        //         i = nRet;\n        //     }\n        //     ans = ans * fpow(S * R, cSR);\n        //     cR = cS = cSR = 0;\n        // }\n        if (t[i] == 'S') {\n            if (cR) {\n                ans = ans * genR(cR);\n                cS = 1;\n                cR = 0;\n            } else cS ^= 1;\n        } else if (t[i] == 'R') {\n            if (cS) {\n                ans = ans * S;\n                cS = 0;\n            } \n            cR++;\n        }\n        // printf(\"Until %d:\\n\", i);\n        // for (int j = 0; j < _3n; j++) {\n        //     write(ans.p[j], j == _3n - 1 ? 10 : 32);\n        // }\n    }\n    \n    if (cR) ans = ans * genR(cR);\n    if (cS) ans = ans * S;\n    // M H = base * S * S * R * R * R * S;\n    for (int i = 0; i < _3n; i++) {\n        write(ans.p[i], i == _3n - 1 ? 10 : 32);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 100000007\nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nint n,m,len,i,x,y,a[1500005],flag[1500005],ch[1500005][3],top,ans[1500005];\nchar s[200005];\nvoid buildtree(int v,int w,int ww){\n\tif(w==m){\n\t\ta[v]=ww;\n\t\treturn;\n\t}\n\ttop++;\n\tch[v][0]=top;\n\ttop++;\n\tch[v][1]=top;\n\ttop++;\n\tch[v][2]=top;\n\tbuildtree(ch[v][0],w*3,ww);\n\tbuildtree(ch[v][1],w*3,ww+w);\n\tbuildtree(ch[v][2],w*3,ww+w*2);\n}\nvoid ytree(int v,int w,int ww){\n\tif(w==m){\n\t\tans[a[v]]=ww;\n\t\treturn;\n\t}\n\tif(flag[v]==1){\n\t\tswap(ch[v][1],ch[v][2]);\n\t\tflag[ch[v][0]]^=1;\n\t\tflag[ch[v][1]]^=1;\n\t\tflag[ch[v][2]]^=1;\n\t}\n\tytree(ch[v][0],w*3,ww);\n\tytree(ch[v][1],w*3,ww+w);\n\tytree(ch[v][2],w*3,ww+w*2);\n}\nint main(){\n\t//freopen(\"domino.in\",\"r\",stdin);\n\t//freopen(\"domino.out\",\"w\",stdout);\n\tn=read();\n\tscanf(\"%s\",s+1);\n\tlen=strlen(s+1);\n\tm=1;\n\tfor(i=1;i<=n;i++)\n\t\tm*=3;\n\tbuildtree(0,1,0);\n\tfor(i=1;i<=len;i++){\n\t\tif(s[i]=='S')\n\t\t\tflag[0]^=1;\n\t\telse{\n\t\t\tx=0;\n\t\t\twhile(ch[x][0]!=0){\n\t\t\t\tif(flag[x]==1){\n\t\t\t\t\tswap(ch[x][1],ch[x][2]);\n\t\t\t\t\tflag[ch[x][0]]^=1;\n\t\t\t\t\tflag[ch[x][1]]^=1;\n\t\t\t\t\tflag[ch[x][2]]^=1;\n\t\t\t\t\tflag[x]=0;\n\t\t\t\t}\n\t\t\t\ty=ch[x][2];\n\t\t\t\tch[x][2]=ch[x][1];\n\t\t\t\tch[x][1]=ch[x][0];\n\t\t\t\tch[x][0]=y;\n\t\t\t\tx=y;\n\t\t\t}\n\t\t}\n\t}\n\tytree(0,1,0);\n\tfor(i=0;i<m;i++)\n\t\tpus(ans[i],1);\n\tcout<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 729 + 10;\nint p[13];\nchar s[200000+10];\nint a[N][N],b[N],r[N],ans[N*N];\nint main(){\n    p[0] = 1; for(int i=1;i<13;i++) p[i] = p[i-1] * 3;\n    int n; scanf(\"%d%s\",&n,s);\n    int x = n / 2, y = n - x;\n    ///y: low, x: high\n    for(int i=0;i<p[6];i++){\n        int t = i;\n        for(int j=0;j<6;j++){\n            if(t/p[j]%3==1) t += p[j];\n            else if(t/p[j]%3==2) t -= p[j];\n        }\n        r[i] = t;\n    }\n    for(int i=0;i<p[n];i++){\n        a[i%p[y]][i/p[y]] = i;\n    }\n    for(int i=0;s[i];i++){\n        if(s[i]=='S'){\n            for(int j=0;j<p[y];j++) b[j] ^= 1;\n            for(int j=0;j<p[y];j++) if(j<r[j]){\n                swap(a[j],a[r[j]]);\n                swap(b[j],b[r[j]]);\n            }\n        }\n        else{\n            for(int j=p[y]-1;j>0;j--){\n                swap(a[j],a[j-1]);\n                swap(b[j],b[j-1]);\n            }\n            if(b[0]){\n                for(int j=0;j<p[x];j++) if(j<r[j]) swap(a[0][j],a[0][r[j]]);\n                b[0] = 0;\n            }\n            for(int j=p[x]-1;j>0;j--){\n                swap(a[0][j],a[0][j-1]);\n            }\n        }\n    }\n    for(int i=0;i<p[y];i++) if(b[i]){\n        for(int j=0;j<p[x];j++) if(j<r[j]) swap(a[i][j],a[i][r[j]]);\n        b[i] = 0;\n    }\n    for(int i=0;i<p[n];i++) ans[a[i%p[y]][i/p[y]]] = i;\n    for(int i=0;i<p[n];i++) printf(\"%d%c\",ans[i],\" \\n\"[i==p[n]-1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nstatic inline char CH(void)\n{\n  static char buf[100000],*ptr1=buf,*ptr2=buf;\n  return ptr1==ptr2&&(ptr2=(ptr1=buf)+fread(buf,1,100000,stdin),ptr1==ptr2)?EOF:*ptr1++;\n}\nstatic inline int IN(void)\n{\n  int x=0,f=0,c=CH();while(c<48||c>57){f^=c==45,c=CH();}\n  while(c>47&&c<58){x=x*10+c-48,c=CH();}return f?-x:x;\n}\nstatic inline void OUT(int x){if(x>=10)OUT(x/10);putchar(x%10+48);}\nstatic inline int Pow(int a,int b){return b?Pow(a*a,b>>1)*(b&1?a:1):1;}\nint main()\n{\n  int N,now,len=0,A[531441],B[531441];char T[200001],S[200000];\n  now=scanf(\"%d %s\",&N,T);len=strlen(T);fflush(stdin);\n  int pw3=Pow(3,N),x=Pow(3,N>>1),y=Pow(3,N-(N>>1));\n  rep(i,pw3)B[i]=B[i/3]*3+(3-i%3)%3;\n  rep(i,x)\n  {\n    int temp=i;now=0;\n    rep(j,len)\n    {\n      if(T[j]=='S'){temp=B[temp];if(S[now]=='S')--now;else S[++now]='S';}\n      else{++temp;if(temp==x)S[++now]='R',temp=0;}\n    }\n    rep(j,y)\n    {\n      int keep=j;\n      rep(k,now)\n      {\n        if(S[k+1]=='S')keep=B[keep];\n        else if(S[k+1]=='R')if((++keep)==y)keep=0;\n      }\n      A[i+j*x]=temp+keep*x;\n    }\n  }\n  rep(i,pw3)OUT(A[i]),putchar(' ');\n  return fflush(stdout),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nstatic inline int Pow(int a,int b){return b?Pow(a*a,b>>1)*(b&1?a:1):1;}\nint main()\n{\n  int N,now,len=0,A[1000001],B[600001];\n  char T[1000001],S[1000001];\n  now=scanf(\"%d %s\",&N,T+1);len=strlen(T+1);\n  int pw3=Pow(3,N),x=Pow(3,N>>1),y=Pow(3,N-(N>>1));\n  rep(i,pw3)B[i]=B[i/3]*3+(3-i%3)%3;\n  rep(i,x)\n  {\n    int temp=i;now=0;\n    rep(j,len)\n    {\n      if(T[j+1]=='S'){temp=B[temp];(S[now]=='S')?--now:S[++now]='S';}\n      else{++temp;if(temp==x)S[++now]='R',temp=0;}\n    }\n    rep(j,y)\n    {\n      int keep=j;\n      rep(k,now)\n      {\n        if(S[k+1]=='S')keep=B[keep];\n        else if(S[k+1]=='R')if((++keep)==y)keep=0;\n        A[i+j*x]=temp+keep*x;\n      }\n    }\n  }\n  rep(i,pw3)printf(\"%d%c\",A[i],i+1==pw3?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\npair<vector<int>, vector<int>> solve(int N, const string& T){\n    if(N==0){\n        return make_pair(vector<int>(1, 0), vector<int>(T.size(), 0));\n    }\n    auto prev = solve(N-1, T);\n    auto& P = prev.first;\n    auto& W = prev.second;\n    vector<int> D(3*P.size());\n    for(int i=0;i<D.size();i++) D[i] = i/P.size();\n    int salsa = 0;\n    vector<int> lastSalsa(3*P.size(), 0);\n    vector<int> curW(W.size());\n    for(int i=0;i<T.size();i++){\n        for(int j=W[i];j<D.size();j+=P.size()){\n            if(salsa != lastSalsa[j]) D[j] = (3-D[j])%3;\n            lastSalsa[j] = salsa;\n            if(D[j] == 2) curW[i] = j;\n        }\n        if(T[i] == 'S'){\n            salsa = 1 - salsa;\n        } else {\n            for(int j=W[i];j<=D.size();j+=P.size()) D[j] = (D[j]+1)%3;\n        }\n    }\n    vector<int> curP(D.size());\n    for(int i=0;i<curP.size();i++){\n        if(salsa != lastSalsa[i]) D[i] = (3-D[i])%3;\n        curP[i] = P.size() * D[i] + P[i%P.size()];\n    }\n    return make_pair(curP, curW);\n}\n\nint main(){\n    int N; cin >> N;\n    string T; cin >> T;\n    auto res = solve(N, T).first;\n    cout << res[0];\n    for(int i=1;i<res.size();i++) cout << \" \" << res[i];\n    cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(void){\n    // Your code here!\n    int n;\n    string t;\n    cin >> n >> t;\n    \n    vector<int> p = {0};\n    for(int i = 1; i < pow(3, n); i++) p.push_back(i);\n    for(int i = 0; i < t.size(); i++){\n        if(t[i] == 'R'){\n            for(int j = 0; j < pow(3, n); j++){\n                p.at(j) += 1;\n                if(p.at(j) == pow(3, n)) p.at(j) = 0;\n            }\n        }else{\n            for(int j = 0; j < pow(3, n); j++){\n                queue<int> new_pos;\n                int next = p.at(j);\n                while(1){\n                    new_pos.push(next%3);\n                    next = next/3;\n                    if(next == 0) break;\n                }\n                p.at(j) = 0;\n                int three = 0;\n                while(new_pos.empty() != 1){\n                    int bit = new_pos.front();\n                    switch(bit){\n                        case 0: break;\n                        case 1: bit = 2; break;\n                        case 2: bit = 1; break;\n                    }\n                    p.at(j) += pow(3, three)*bit;\n                    new_pos.pop();\n                    three += 1;\n                }\n                 \n            }\n        }\n    \n       \n    }\n    for(int i = 0; i < pow(3, n); i++){\n        cout << p.at(i) << \" \";\n    }\n    cout << endl;\n    \n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar T[500005];\nint salsa2[500005];\nint salsaNext[500005];\n\nint N;\n\nint salsa(int x){\n    int temp = x;\n    int pow3 = 1;\n    int res = 0;\n    for(int i = 0; i < N; i ++){\n        int k = temp%3;\n        temp /= 3;\n\n        if(k == 1){\n            res += pow3*2;\n        }else if(k == 2){\n            res += pow3;\n        }\n        pow3 *= 3;\n    }\n    return res;\n}\n\nint main(){\n    scanf(\"%d\", &N);\n\n    scanf(\" %s\", T);\n\n    int pow3N = 1;\n    for(int i = 0; i < N; i ++){\n        pow3N *= 3;\n    }\n\n    for(int i = 0; i < pow3N; i ++){\n        salsa2[i] = salsa(i);\n        //printf(\"salsa2[%d]=%d\\n\", i, salsa2[i]);\n    }\n\n    for(int i = 0; i < pow3N; i ++){\n        salsaNext[salsa2[i+1]] = salsa2[i];\n    }\n\n    for(int j = 0; j < pow3N; j ++){\n        int x = j;\n        for(int i = 0; i < pow3N; i ++){\n            if(T[i] == 'R'){\n                x = (x+1)%pow3N;\n            }else if(T[i] == 'S'){\n                x = salsa2[x];\n            }\n        }\n        printf(\"%d \", x);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#define int long long\n\n#define pii pair<int, int>\n\n#define x1 x1228\n#define y1 y1228\n\n#define left left228\n#define right right228\n\n#define next next228\n\n#define pb push_back\n#define eb emplace_back\n\n#define mp make_pair                                                                \n                                                                                                                                        \n#define ff first                                                                  \n#define ss second   \n\n#define all(x) x.begin(), x.end()\n#define debug(x) cout << #x << \": \" << x << endl; \n#define TIME (ld)clock()/CLOCKS_PER_SEC\n\nusing namespace std;\ntypedef long long ll; \ntypedef long double ld; \n                                                                                                   \nconst int maxn = 2e5 + 7, mod = 1e9 + 7, MAXN = 1e6 + 7;\nconst double eps = 1e-9;\nconst ll inf = 1e18;\nmt19937 rnd(time(0));\nint n; \nstring s; \nint next[MAXN];\nconst int N = 2187; \nint dp1[N]; \nint dp2[N]; \nint xyz[N]; \n\nint get1(int mask, char q) {\n    if (q == 'R') {\n        ++mask; \n        return mask; \n    }   \n    int ptr = 1; \n    int ans = 0; \n    while (mask) {\n        int t = mask % 3; \n        mask /= 3; \n        if (t == 2) ans += ptr; \n        if (t == 1) ans += 2 * ptr; \n        ptr *= 3; \n    }\n    return ans; \n}\n\nint get(int mask, char q) {\n    if (q == 'R') {\n        ++mask; \n        return mask; \n    }   \n    return xyz[mask]; \n}\n\nconst int L = 12; \nint pref[maxn]; \nint to[maxn]; \nint kek1[N], kek2[N]; \nint res[N]; \n\nint get(int l, int r) {\n    return pref[r + 1] - pref[l]; \n}\n\nvoid change(int &mask, int l, int r) {\n    if (get(l, r) % 2) {\n        mask = get(mask, 'S'); \n    }    \n    mask++; \n}\n\nint merge(int left, int right) {\n    for (int i = 0; i < 7; ++i) right *= 3;\n    return left + right;     \n}\n\nint get(int x) {\n    vector<int> bts; \n    for (int i = 0; i < L; ++i) {\n        bts.pb(x % 3); \n        x /= 3; \n    }\n    int left = 0;\n    int right = 0; \n    for (int i = 6; i >= 0; --i) {\n        left *= 3;\n        left += bts[i]; \n    }\n    for (int i = L - 1; i >= 7; --i) {\n        right *= 3; \n        right += bts[i]; \n    }\n    int id = 0; \n    if (left && dp1[left] == -1) {\n        return merge(res[left], right);  \n    }\n    if (left) {    \n        id = dp1[left]; \n        change(right, 0, id - 1);             \n        left = 0; \n    }                     \n    while (next[id] != -1) {\n        change(right, id, next[id] - 1);\n        id = next[id];                                                                                                                                         \n    }\n    left = to[id]; \n    return merge(left, right); \n}\n\n\nvoid solve() {\n    for (int i = 0; i < N; ++i) {\n        xyz[i] = get1(i, 'S') % N; \n    }\n\n    cin >> n >> s; \n    int t = s.size(); \n    for (int i = 0; i < N; ++i) {        \n        res[i] = i; \n        for (int j = 0; j < t; ++j) {\n            if (s[j] == 'S') res[i] = xyz[res[i]]; \n            else res[i] = (res[i] + 1) % N; \n        } \n    }\n    for (int i = 0; i < t; ++i) {\n        pref[i + 1] = pref[i] + (s[i] == 'S'); \n    }\n    for (int i = 0; i < N; ++i) dp1[i] = dp2[i] = -1; \n    next[t] = -1;\n    for (int i = 0; i < N; ++i) kek1[i] = i;              \n    for (int i = t - 1; i >= 0; --i) {\n        for (int mask = 0; mask < N; ++mask) {\n            int mask1; \n            if (s[i] == 'S') mask1 = xyz[mask]; \n            else mask1 = mask + 1; \n            mask1 %= N; \n            kek2[mask] = kek1[mask1];\n        }\n        to[i] = kek2[0]; \n        for (int mask = 0; mask < N; ++mask) {\n            int mask1; \n            if (s[i] == 'S') mask1 = xyz[mask]; \n            else mask1 = mask + 1; \n            mask1 %= N;              \n            if (mask && mask1 == 0) {\n                dp2[mask] = i + 1; \n            } else {\n                dp2[mask] = dp1[mask1]; \n            }   \n        }\n        next[i] = dp2[0]; \n        for (int mask = 0; mask < N; ++mask) {\n            kek1[mask] = kek2[mask]; \n            dp1[mask] = dp2[mask]; \n            dp2[mask] = -1; \n        }\n    }\n    int tet = 1; \n    for (int i = 0; i < n; ++i) tet *= 3; \n    for (int i = 0; i < tet; ++i) {\n        cout << get(i) % tet << \" \"; \n    }\n}                                \n   \nsigned main() {\n#ifdef LOCAL\n    freopen(\"TASK.in\", \"r\", stdin);\n    freopen(\"TASK.out\", \"w\", stdout);\n#else \n    \n#endif // LOCAL\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20); \n    cout << fixed; \n    int t = 1; \n    for (int i = 0; i < t; ++i) {              \n        solve();\n    }\n    return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n \nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n\n#define MOD 1000000007LL\n\nint N;\nstring T;\nvector<int> p1,p2;\n//map<int, int> sa;\nvector<int> sa;\nint sp;\nint tn;\n\nint conv(int);\nint tri(int n) {\n  int ans=1;\n  for (int i=0; i<n; i++) ans *= 3;\n  return ans;\n}\n\nvoid salsa();\nvoid rumba();\nvoid print_res();\nvoid print_ln();\n\nint main()\n{\n  int l;\n  int i;\n\n  cin >> N >> T;\n  tn = tri(N);\n\n  p1.resize(tn);\n  p2.resize(tn);\n  sa.resize(tn);\n  for (int i=0; i<tn; i++) {\n    p1[i] = i;\n    sa[i] = conv(i);\n  }\n  p2[0] = p1[0];\n  sp = 1;\n\n//print_ln();\n\n  l = T.size();\n  for (i=0; i<l; i++) {\n    if (T[i] == 'S') {\n      salsa();\n//printf(\"S \");\n//print_ln();\n    } else {\n      rumba();\n//printf(\"R \");\n//print_ln();\n    }\n  }\n\n  print_res();\n\n  return 0;\n}\nint conv(int inp) {\n  int cv=0;\n  int t;\n\n  for (t=1; inp>0; t*=3) {\n    switch(inp % 3) {\n    case 1: cv += 2*t; break;\n    case 2: cv += t; break;\n    }\n    inp /= 3;\n  }\n  return cv;\n}\n\nvoid salsa() {\n  int i;\n\n  if (sp==1) {\n    for (i=0; i<tn; i++) {\n      p2[sa[i]] = p1[i];\n    }\n    sp = 2;\n  } else {\n    for (i=0; i<tn; i++) {\n      p1[sa[i]] = p2[i];\n    }\n    sp = 1;\n  }\n}\nvoid rumba() {\n  int i;\n  if (sp==1) {\n    for (i=0; i<tn-1; i++) {\n      p2[i+1]=p1[i];\n    }\n    p2[0] = p1[tn-1];\n    sp = 2;\n  } else {\n    for (i=0; i<tn-1; i++) {\n      p1[i+1]=p2[i];\n    }\n    p1[0] = p2[tn-1];\n    sp = 1;\n  }\n}\n\nvoid print_ln() {\n  int i;\n  if (sp == 1) {\n    printf(\"%d\", p1[0]);\n    for (i=1; i<tn; i++) printf(\" %d\", p1[i]);\n  } else {\n    printf(\"%d\", p2[0]);\n    for (i=1; i<tn; i++) printf(\" %d\", p2[i]);\n  }\n  printf(\"\\n\");\n}\nvoid print_res() {\n  int i;\n  map<int, int> m;\n  if (sp == 1) {\n    for (i=0; i<tn; i++)  m.emplace(p1[i], i);\n  } else {\n    for (i=0; i<tn; i++)  m.emplace(p2[i], i);\n  }\n  auto it=m.begin();\n  printf(\"%d\", it->second);\n  for (it++; it!=m.end(); it++) {\n    printf(\" %d\", it->second);\n  }\n  printf(\"\\n\");\n}\n/*\n  a*3^3+b*3^2+c*3+d\n  */\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct mat{int dat[531441];}O,C,S,R;\nint sal[531441],rum[531441];\nint n,m,cu,ni,nni;\nstring t;\nmat mul(mat a,mat b){\n\tfor(int i=0;i<m;i++) C.dat[b.dat[i]]=a.dat[i];\n\treturn C;\n}\nint main(){\n\t#ifdef FILIN\n\t\t#ifndef DavidDesktop\n\t\t\tfreopen(FILIN,\"r\",stdin);\n\t\t\tfreopen(FILOUT,\"w\",stdout);\n\t\t#endif\n\t#endif\n\tios::sync_with_stdio(0);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tcin>>n>>t;\n\tm=1;\n\tfor(int i=1;i<=n;i++) m*=3;\n\tfor(int i=0;i<m;i++) O.dat[i]=i;\n\tfor(int i=0;i<m;i++) rum[i]=(i+1)%m;\n\tfor(int i=0;i<m;i++){\n\t\tni=0;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i%3==0) ni=(ni*3);\n\t\t\tif(i%3==1) ni=(ni*3)+2;\n\t\t\tif(i%3==2) ni=(ni*3)+1;\n\t\t\ti/=3;\n\t\t}\n\t\tnni=0;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tnni=(nni*3)+(ni%3);\n\t\t\tni/=3;\n\t\t}\n\t\tsal[i]=nni;\n\t}\n\tcu=1;\n\tfor(int i=1;i<t.size();i++){\n\t\tif(t[i]!=t[i-1]){\n\t\t\tif(t[i-1]=='R'){\n\t\t\t\tfor(int j=0;j<m;j++) R.dat[j]=rum[j];\n\t\t\t\tO=mul(O,R);\n\t\t\t\tcu--;\n\t\t\t\twhile(cu){\n\t\t\t\t\tif(cu&1) O=mul(O,R);\n\t\t\t\t\tR=mul(R,R);\n\t\t\t\t\tcu>>=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(t[i-1]=='S'){\n\t\t\t\tfor(int j=0;j<m;j++) S.dat[j]=sal[j];\n\t\t\t\tO=mul(O,S);\n\t\t\t\tcu--;\n\t\t\t\twhile(cu){\n\t\t\t\t\tif(cu&1) O=mul(O,S);\n\t\t\t\t\tS=mul(S,S);\n\t\t\t\t\tcu>>=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcu=0;\n\t\t}\n\t\tcu++;\n\t}\n\tfor(int i=0;i<m;i++) cout<<O.dat[i]<<' ';\n\tcout<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n\n//#define putchar_unlocked putchar\n\nchar T[524288];\nint res[550005];\n\n// Based on editorial solution\nint D[13][550005]; // one digit at a time, with digit 0 representing the ones place\nint W[13][550005];\nint lastUpdated[13][550005];\n\nint x[11];\ninline void putInt(int i){\n    if(i==0){putchar_unlocked('0');}\n    else{\n    int count1=0;\n    while(i>0){\n        x[count1++]=i%10;\n        i/=10;\n    }\n    for(int j=count1-1;j>=0;j--){\n        putchar_unlocked(48+x[j]);\n    }\n    }\n    putchar_unlocked(' ');\n}\n\nint N;\n\ninline void update(int n, int indx, int cntS){\n    if( ((cntS&1) != (lastUpdated[n][indx]&1)) && D[n][indx]){\n        // conduct salsa\n        D[n][indx] = 3-D[n][indx];\n    }\n    // update the lastUpdated index\n    lastUpdated[n][indx] = cntS;\n}\n\nint pow3[16];\n\nint main(){\n    scanf(\"%d\", &N);\n    scanf(\" %s\", T);\n\n    int M = strlen(T);\n\n    pow3[0] = 1;\n    for(int i = 1; i <= N; i ++){\n        pow3[i] = pow3[i-1]*3;\n    }\n\n    //memset(W, 0, sizeof(W));\n    for(int n = 1; n <= N; n ++){\n        //printf(\"ok\");\n        for(int j = 0; j < pow3[n-1]; j ++){\n            D[n][j] = 0;\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        for(int j = pow3[n-1]; j < (pow3[n-1]<<1); j ++){\n            D[n][j] = 1;\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        for(int j = (pow3[n-1]<<1); j < pow3[n]; j ++){\n            D[n][j] = 2;\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        W[n][0] = pow3[n]-1;\n    }\n\n    //memset(lastUpdated, 0, sizeof(lastUpdated));\n    int cntS2 = 0;\n    for(int n = 1; n <= N; n ++){\n        int cntS = 0;\n        for(int i = 0; i < M; i ++){\n            int indx0 = W[n-1][i];\n            int indx1 = W[n-1][i]+pow3[n-1];\n            int indx2 = W[n-1][i]+(pow3[n-1]<<1);\n\n            if(indx1 >= pow3[n]){indx1 -= pow3[n];}\n            if(indx2 >= pow3[n]){indx2 -= pow3[n];}\n\n            update(n, indx0, cntS+(T[i]=='S'));\n            update(n, indx1, cntS+(T[i]=='S'));\n            update(n, indx2, cntS+(T[i]=='S'));\n            if(D[n][indx0] == 2){\n                W[n][i] = indx0;\n            }else if(D[n][indx1] == 2){\n                W[n][i] = indx1;\n            }else{\n                W[n][i] = indx2;\n            }\n\n            if(T[i] == 'R'){\n                D[n][indx0] = (D[n][indx0]+1);\n                D[n][indx1] = (D[n][indx1]+1);\n                D[n][indx2] = (D[n][indx2]+1);\n                if(D[n][indx0] == 3){D[n][indx0] = 0;}\n                if(D[n][indx1] == 3){D[n][indx1] = 0;}\n                if(D[n][indx2] == 3){D[n][indx2] = 0;}\n                lastUpdated[n][indx0] = cntS;\n                lastUpdated[n][indx1] = cntS;\n                lastUpdated[n][indx2] = cntS;\n            }else if(T[i] == 'S'){\n                cntS ++;\n            }\n\n            //printf(\"W[%d][%d]=%d\\n\", n, i+1, W[n][i+1]);\n        }\n\n        cntS2 = cntS;\n    }\n\n    for(int n = 1; n <= N; n ++){\n        for(int i = 0; i < pow3[n]; i ++){\n            update(n, i, cntS2);\n        }\n\n        int cnt = 0;\n        for(int i = 0; i < pow3[N]; i ++){\n            res[i] += D[n][cnt++]*pow3[n-1];\n            if(cnt == pow3[n]){cnt = 0;}\n        }\n    }\n\n    for(int i = 0; i < pow3[N]; i ++){\n        /*int temp = 0;\n        for(int n = 1; n <= N; n ++){\n            temp += D[n][i%pow3[n]]*pow3[n-1];\n        }*/\n        //putInt(temp);\n        putInt(res[i]);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cassert>\n#include<stdexcept>\n#include<utility>\n#include<functional>\n#include<numeric>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<array>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<complex>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<bitset>\n#include<memory>\nusing namespace std;\nusing ll=long long;\n\nconst int SZ = 7;\nint n;\nint pow3n;\nvector<int> sal;\nvoid init_s(){\n    sal.resize(pow3n);\n    iota(sal.begin(),sal.end(),0);\n    for(int i=0;i<pow3n;i++){\n        int x = i;\n        int tar = 0;\n        int r = 1;\n        for(int j=0;j<n;j++){\n            tar+= (x%3*2)%3*r;\n            x/=3;\n            r*=3;\n        }\n        if(tar<i){\n            // cerr<<i<<\" \"<<tar<<endl;\n            swap(sal[tar],sal[i]);\n        }\n    }\n}\n\nint ary[1000000];\nvoid do_rx(vector<int>& pat,int t){\n    t = t%pow3n;\n    for(int i=t;i<pow3n;i++) ary[i] = pat[i-t];\n    for(int i=0;i<t;i++) ary[i] = pat[pow3n-t+i];\n    for(int i=0;i<pow3n;i++) pat[i] = ary[i];\n}\n\nvoid do_r(vector<int>& pat){\n    int head = pat[pow3n-1];\n    for(int i=pow3n-1;i>0;i--){\n        pat[i]=pat[i-1];\n    }\n    pat[0] = head;\n}\n\nvoid perm(vector<int>& pat,vector<int>& par){\n    for(int i=0;i<pow3n;i++) ary[i] = pat[par[i]];\n    for(int i=0;i<pow3n;i++) pat[i] = ary[i];\n}\nvoid do_s(vector<int>& pat){\n    perm(pat,sal);\n}\nint main(){\n    cin>>n;\n    pow3n=1;\n    for(int i=0;i<n;i++) pow3n*=3;\n    init_s();\n    \n    string t;\n    {\n        string tmp;\n        cin>>tmp;\n        for(auto c:tmp){\n            if(!t.empty() && t.back()=='S' && c=='S') t.pop_back();\n            else t+=c;\n        }\n    }\n\n    vector<vector<int>> memo(1<<SZ);\n    \n    for(int bit=0;bit<(1<<SZ);bit++){\n        bool ispass= false;\n        for(int j=0;j+1<SZ;j++){\n            if(((bit>>j)&1)==0 && ((bit>>(j+1)))==0) ispass=true;\n        }\n        if(ispass) continue;\n\n        memo[bit].resize(pow3n);\n        iota(memo[bit].begin(),memo[bit].end(),0);\n        for(int j=0;j<SZ;j++){\n            if(((bit>>j)&1)==0) do_s(memo[bit]);\n            else do_r(memo[bit]);\n        }\n    }\n    vector<int> res(pow3n);\n    iota(res.begin(),res.end(),0);\n    int l = 0;\n    while(t.size()-l>=SZ){\n        int r;\n        for(r=l;r<t.size();r++){\n            if(t[r]=='S') break;\n        }\n        if(r-l>=SZ){\n            do_rx(res,r-l);\n            l=r;\n        }\n        else{\n            int bit = 0;\n            for(int j=0;j<SZ;j++){\n                if(t[l+j]=='R') bit+=(1<<j);\n            }\n            perm(res,memo[bit]);\n            bit=0;\n            l+=SZ;\n        }\n    }\n\n    for(int i=l;i<t.size();i++){\n        // cerr<<\"#\"<<endl;\n        if(t[i]=='S') do_s(res);\n        else do_r(res);\n    }\n    vector<int> inv(pow3n);\n    for(int i=0;i<pow3n;i++) inv[res[i]]=i;\n    for(int i=0;i<pow3n;i++) cout<<inv[i]<<\" \";\n    cout<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <stdio.h>\n#include <cmath>\n#include<bits/stdc++.h>\nusing namespace std;\n\nint len;\nint n;\nstring dance;\nvector <int> locations;\nvector<char*> memo;\n\n\nvoid salsa();\n\nvoid rumba();\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n;\n    cin>>dance;\n    len = pow(3, n);\n    memo = vector<char*>(len, 0);\n    locations = vector<int>(len);\n    for (int i = 0; i < len; i++) {\n        locations[i] = i;\n    }\n    for (int i = 0; i < dance.length(); i++) {\n        if(dance[i] == 'S'){\n            salsa();\n        }else{\n            rumba();\n        }\n    }\n    for(int i = 0; i< len; i++){\n        printf(\"%d \", locations[i]);\n    }\n}\nchar reVal(int num)\n{\n    if (num >= 0 && num <= 9)\n        return (char)(num + '0');\n    else\n        return (char)(num - 10 + 'A');\n}\n\n// Utility function to reverse a string\nvoid strev(char *str)\n{\n    int len = strlen(str);\n    int i;\n    for (i = 0; i < len/2; i++)\n    {\n        char temp = str[i];\n        str[i] = str[len-i-1];\n        str[len-i-1] = temp;\n    }\n}\nchar* fromDeci(char res[], int base, int inputNum)\n{\n    int index = 0;  // Initialize index of result\n\n    // Convert input number is given base by repeatedly\n    // dividing it by base and taking remainder\n    while (inputNum > 0)\n    {\n        res[index++] = reVal(inputNum % base);\n        inputNum /= base;\n    }\n    res[index] = '\\0';\n\n    // Reverse the result\n    strev(res);\n\n    return res;\n}\nint val(char c)\n{\n    if (c >= '0' && c <= '9')\n        return (int)c - '0';\n    else\n        return (int)c - 'A' + 10;\n}\n\n// Function to convert a number from given base 'b'\n// to decimal\nint toDeci(char *str, int base)\n{\n    int len = strlen(str);\n    int power = 1; // Initialize power of base\n    int num = 0;  // Initialize result\n    int i;\n\n    // Decimal equivalent is str[len-1]*1 +\n    // str[len-2]*base + str[len-3]*(base^2) + ...\n    for (i = len - 1; i >= 0; i--)\n    {\n        // A digit in input number must be\n        // less than number's base\n        if (val(str[i]) >= base)\n        {\n            printf(\"Invalid Number\");\n            return -1;\n        }\n\n        num += val(str[i]) * power;\n        power = power * base;\n    }\n\n    return num;\n}\n\nvoid rumba() {\n    for(int j = 0; j< len; j++ ){\n        int num = locations[j];\n        int new_num = num +1;\n        if(new_num == len){\n            new_num = 0;\n        }\n        locations[j] = new_num;\n    }\n}\n\nvoid salsa() {\n    for(int j = 0; j< len; j++ ){\n        int num = locations[j];\n        char* a;\n        //printf(\"location[j] = %d \\n\", num);\n        char res[len];\n        if(memo[num] == 0){\n            a = fromDeci(res, 3, num);\n            memo[len] = a;\n        }\n        else{\n           a = memo[num];\n        }\n        int k = 0;\n        while(a[k] != '\\0'){\n            if((a[k]) == '1'){\n                a[k] = '2';\n            }else if(a[k] == '2'){\n                a[k] = '1';\n            }\n            k++;\n        }\n        int new_num = toDeci(a, 3);\n       // printf(\"after change salsa location[j] = %d \\n\", new_num);\n        locations[j] = new_num;\n    }\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct mat{int dat[531441];}O,C,S,R;\nint sal[531441],rum[531441];\nint n,m,cu,ni,nni;\nstring t;\nmat mul(mat a,mat b){\n\tfor(int i=0;i<m;i++) C.dat[b.dat[i]]=a.dat[i];\n\treturn C;\n}\nint main(){\n\t#ifdef FILIN\n\t\t#ifndef DavidDesktop\n\t\t\tfreopen(FILIN,\"r\",stdin);\n\t\t\tfreopen(FILOUT,\"w\",stdout);\n\t\t#endif\n\t#endif\n\tios::sync_with_stdio(0);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tcin>>n>>t;\n\tm=1;\n\tfor(int i=1;i<=n;i++) m*=3;\n\tfor(int i=0;i<m;i++) O.dat[i]=i;\n\tfor(int i=0;i<m;i++) rum[i]=(i+1)%m;\n\tfor(int i=0;i<m;i++){\n\t\tni=0;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i%3==0) ni=(ni*3);\n\t\t\tif(i%3==1) ni=(ni*3)+2;\n\t\t\tif(i%3==2) ni=(ni*3)+1;\n\t\t\ti/=3;\n\t\t}\n\t\tnni=0;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tnni=(nni*3)+(ni%3);\n\t\t\tni/=3;\n\t\t}\n\t\tsal[i]=nni;\n\t}\n\tcu=1;\n\tfor(int i=1;i<t.size();i++){\n\t\tif(t[i]!=t[i-1]){\n\t\t\tif(t[i-1]=='R'){\n\t\t\t\tfor(int i=0;i<m;i++) R.dat[i]=rum[i];\n\t\t\t\tO=mul(O,R);\n\t\t\t\tcu--;\n\t\t\t\twhile(cu){\n\t\t\t\t\tif(cu&1) O=mul(O,R);\n\t\t\t\t\tR=mul(R,R);\n\t\t\t\t\tcu>>=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(t[i-1]=='S'){\n\t\t\t\tfor(int i=0;i<m;i++) S.dat[i]=sal[i];\n\t\t\t\tO=mul(O,S);\n\t\t\t\tcu--;\n\t\t\t\twhile(cu){\n\t\t\t\t\tif(cu&1) O=mul(O,S);\n\t\t\t\t\tS=mul(S,S);\n\t\t\t\t\tcu>>=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++) cout<<O.dat[i]<<' ';\n\tcout<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nint cur[531441][13];\nchar c[200005];\nchar s[200005];\nint n;\nint pow;\nvoid reverse(){\n    for(int i=0;i<pow;i++){\n        for(int j=0;j<n;j++){\n            if(cur[i][j]==1 or cur[i][j]==2) cur[i][j]=3-cur[i][j];\n        }\n    }\n}\nvoid plus(){\n    for(int i=0;i<pow;i++){\n        for(int j=0;j<n;j++){\n            cur[i][j]+=1;\n            if(cur[i][j]!=3) break;\n            else{\n                cur[i][j]=0;\n            }\n        }\n    }\n}\nint num(int k){\n    int ans=0;\n    for(int i=n-1;i>=0;i--){\n        ans*=3;\n        ans+=cur[k][i];\n    }\n    return ans;\n}\nint main() {\n    scanf(\"%d\",&n);\n    pow=1;\n    for(int i=0;i<n;i++){\n        pow*=3;\n    }\n    scanf(\"%s\",c);\n    int len=0;\n    for(int i=0;c[i]!='\\0';i++){\n        if(c[i]=='S'){\n            if(c[i+1]!='\\0' and c[i+1]=='S'){\n                i+=1;\n            }\n            else{\n                s[len]=c[i];\n                len++;\n            }\n        }\n        else{\n            s[len]=c[i];\n            len++;\n        }\n    }\n    for(int i=0;i<pow;i++){\n        int tem=i;\n        for(int j=0;j<n;j++){\n            cur[i][j]=tem%3;\n            tem/=3;\n        }\n    }\n    for(int i=0;i<len;i++){\n        if(s[i]=='S'){\n            reverse();\n        }\n        else plus();\n    }\n    for(int i=0;i<pow;i++){\n        printf(\"%d \",num(i));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<deque>\n#include<iomanip>\n#include<tuple>\n#include<cassert>\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<int,int> P;\ntypedef pair<LL,int> LP;\nconst int INF=1<<30;\nconst LL MAX=1e9+7;\n\nvoid array_show(int *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%d%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\nvoid array_show(LL *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%lld%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\nvoid array_show(vector<int> &vec_s,int vec_n=-1,char middle=' '){\n\tif(vec_n==-1)vec_n=vec_s.size();\n\tfor(int i=0;i<vec_n;i++)printf(\"%d%c\",vec_s[i],(i!=vec_n-1?middle:'\\n'));\n}\nvoid array_show(vector<LL> &vec_s,int vec_n=-1,char middle=' '){\n\tif(vec_n==-1)vec_n=vec_s.size();\n\tfor(int i=0;i<vec_n;i++)printf(\"%lld%c\",vec_s[i],(i!=vec_n-1?middle:'\\n'));\n}\n\nvector<vector<int>> v1[15];\nvector<vector<int>> vs;\n\nint main(){\n\tint n,m;\n\tint i,j,k;\n\tint a,b,c;\n\ta=0;\n\tstring sa;\n\tcin>>n;\n\tcin>>sa;\n\tv1[0].push_back(vector<int>());\n\tfor(i=0;i<sa.size();i++){\n\t\tif(sa[i]=='R')a++;\n\t\telse if(i+1<sa.size() && sa[i+1]=='S')i++;\n\t\telse{\n\t\t\tv1[0][0].push_back(a);\n\t\t\ta=0;\n\t\t}\n\t}\n\tv1[0][0].push_back(a);\n\tvs.push_back(vector<int>(1,0));\n\n\tfor(i=0;i<n;i++){\n\t\tc=pow(3,i);\n\t\tvs.push_back(vector<int>());\n\t\tfor(j=0;j<v1[i].size();j++){\n\t\t\tfor(k=0;k<3;k++){\n\t\t\t\tv1[i+1].push_back(vector<int>());\n\t\t\t\ta=k;\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(auto node:v1[i][j]){\n\t\t\t\t\tif(cnt && a>0)a=3-a;\n\t\t\t\t\ta+=node,cnt++;\n\t\t\t\t\tb=a/3;a%=3;\n\t\t\t\t\tif(b==0 && !v1[i+1].back().empty() && v1[i+1].back().back()==0){\n\t\t\t\t\t\tv1[i+1].back().pop_back();\n\t\t\t\t\t}else v1[i+1].back().push_back(b);\n\t\t\t\t}\n\t\t\t\tvs[i+1].push_back(vs[i][j]+c*a);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tc=pow(3,n);\n\tvector<int> v2(c,-1);\n\tvector<int> vt(n,0);\n\tfor(i=0;i<c;i++){\n\t\ta=0;\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(vt[j]>=3)vt[j]-=3,vt[j+1]++;\n\t\t\ta*=3;\n\t\t\ta+=vt[j];\n\t\t}\n\t\tv2[a]=vs[n][i];\n\t\tvt[0]++;\n\t}\n\tarray_show(v2);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint change3(int A){\n  vector<int> b3(0);\n  while(A>2){\n    int aw3 = A%3;\n    b3.push_back((aw3==0)?0:\n                 (aw3==1)?2:1);\n    A/=3;\n  }\n  int aw3 = A%3;\n  b3.push_back((aw3==0)?0:\n               (aw3==1)?2:1);\n  int sum=0;\n  for(int i=0;i<b3.size();i++){\n   sum+= pow(3,i)*b3.at(i); \n  }\n  return sum;\n}\n\n\nint main() {\n  int N;\n  cin >> N;\n  int N3 = pow(3,N);\n  vector<int> dan(N3);\n  for(int i=0;i<N3;i++)dan.at(i)=i;\n  string recode;\n  cin >> recode;\n  for(char i:recode){\n    if(i=='S'){\n     for(int &j:dan){\n      j=change3(j); \n     }\n    }else{\n      for(int &j:dan){\n        j+=1;\n        if(j==N3)j=0;\n      }\n    }\n      \n      \n  }\n    \n    \n  for(int i:dan){\n    cout << i << \" \";\n  }\n  cout << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <stdio.h>\n#include <cmath>\n#include<bits/stdc++.h>\nusing namespace std;\n\nint len;\nint n;\nstring dance;\nvector <int> locations;\n\n\nvoid salsa();\n\nvoid rumba();\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n;\n    cin>>dance;\n    len = pow(3, n);\n\n    locations = vector<int>(len);\n    for (int i = 0; i < len; i++) {\n        locations[i] = i;\n    }\n    for (int i = 0; i < dance.length(); i++) {\n        if(dance[i] == 'S'){\n            salsa();\n        }else{\n            rumba();\n        }\n    }\n    for(int i = 0; i< len; i++){\n        printf(\"%d \", locations[i]);\n    }\n}\nchar reVal(int num)\n{\n    if (num >= 0 && num <= 9)\n        return (char)(num + '0');\n    else\n        return (char)(num - 10 + 'A');\n}\n\n// Utility function to reverse a string\nvoid strev(char *str)\n{\n    int len = strlen(str);\n    int i;\n    for (i = 0; i < len/2; i++)\n    {\n        char temp = str[i];\n        str[i] = str[len-i-1];\n        str[len-i-1] = temp;\n    }\n}\nchar* fromDeci(char res[], int base, int inputNum)\n{\n    int index = 0;  // Initialize index of result\n\n    // Convert input number is given base by repeatedly\n    // dividing it by base and taking remainder\n    while (inputNum > 0)\n    {\n        res[index++] = reVal(inputNum % base);\n        inputNum /= base;\n    }\n    res[index] = '\\0';\n\n    // Reverse the result\n    strev(res);\n\n    return res;\n}\nint val(char c)\n{\n    if (c >= '0' && c <= '9')\n        return (int)c - '0';\n    else\n        return (int)c - 'A' + 10;\n}\n\n// Function to convert a number from given base 'b'\n// to decimal\nint toDeci(char *str, int base)\n{\n    int len = strlen(str);\n    int power = 1; // Initialize power of base\n    int num = 0;  // Initialize result\n    int i;\n\n    // Decimal equivalent is str[len-1]*1 +\n    // str[len-2]*base + str[len-3]*(base^2) + ...\n    for (i = len - 1; i >= 0; i--)\n    {\n        // A digit in input number must be\n        // less than number's base\n        if (val(str[i]) >= base)\n        {\n            printf(\"Invalid Number\");\n            return -1;\n        }\n\n        num += val(str[i]) * power;\n        power = power * base;\n    }\n\n    return num;\n}\n\nvoid rumba() {\n    for(int j = 0; j< len; j++ ){\n        int num = locations[j];\n        int new_num = num +1;\n        if(new_num == len){\n            new_num = 0;\n        }\n        locations[j] = new_num;\n    }\n}\n\nvoid salsa() {\n    for(int j = 0; j< len; j++ ){\n        int num = locations[j];\n        char res[len];\n        char* a = fromDeci(res, 3, num);\n        int k = 0;\n        while(a[k] != '\\0'){\n            if((a[k]) == '1'){\n                a[k] = '2';\n            }else if(a[k] == '2'){\n                a[k] = '1';\n            }\n            k++;\n        }\n        int new_num = toDeci(a, 3);\n        locations[j] = new_num;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\ntypedef long long LL;\n#define rep(i,N) for(LL i=0;i<(LL)N;i++)\nconst LL sz=531441;\nint N,x,y,th,P[sz],t[13]={0},TRI,pw3[13]={1};\nchar c='-',tmp,T[200001];\nvoid init(void){rep(i,3*TRI)P[i]=i;}\ninline LL IN(void)\n{\n  LL x=0;short f=0,c=getchar();\n  while(c<48||c>57)f^=c==45,c=getchar();\n  while(c>47&&c<58)x=x*10+c-48,c=getchar();\n  return f?-x:x;\n}\nvoid sal(char &c)\n{\n  if(c=='R'){rep(i,3*TRI){P[i]++;if(P[i]==3*TRI)P[i]=0;}return;}\n  if(c=='S')rep(trit,3*TRI)\n  {\n    x=P[trit];y=0;\n    rep(i,13)\n    {\n      y++;t[i]=x%3;\n      if(t[i]==1)t[i]=2;else if(t[i]==2)t[i]=1;else t[i]=0;\n      if(x<3)break;\n      x/=3;\n    }\n    x=0;\n    rep(i,y)x+=t[i]*pw3[i];\n    if(x==3*TRI)x=0;\n    P[trit]=x;\n  }\n}\nsigned main(void)\n{\n  int p=0,count=0;\n  N=IN();\n  while(c!=EOF)\n  {\n    c=getchar();if(c==EOF)break;T[p]=c;\n    if(c=='S'&&tmp=='S'){if(count%2==0)p--;count++;tmp=T[p-1];}\n    else{p++;tmp=c;count=0;}\n  }\n  rep(i,N+1)if(i>0)pw3[i]=pw3[i-1]*3;else pw3[i]=1;\n  count=0;\n  rep(i,p)\n  {\n    if(T[i]=='R'){count++;if(count%pw3[N]==0)rep(j,pw3[N])T[i-j]=NULL;}\n    else if(T[i]=='S')count=0;\n  }\n  if(T[0]==NULL)return 0;\n  TRI=pw3[N-1],init();\n  rep(i,p){sal(T[i]);}\n  rep(i,3*TRI)printf(\"%d \",P[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nint main(){\n    int n;\n    std::string t;\n    std::cin>>n>>t;\n    int temp=1;\n    for(int i=0;i<n;++i){\n        temp*=3;\n    }\n    const int num=temp;\n    int c[num][12];\n    for(int i=0;i<num;++i){\n        for(int j=11;j>=12-n;--j){\n            c[i][j]=0;\n        }\n    }\n    for(int i=1;i<num;++i){\n        c[i][11]=c[i-1][11]+1;\n        int j=11;\n        while(c[i][j]>=3){\n            c[i][j]-=3;\n            j--;\n            c[i][j]++;\n        }\n    }\n    for(int i=0;i<t.size();++i){\n        if(t[i]=='S'){\n            for(int j=0;j<num;++j){\n                for(int k=11;k>=12-n;--k){\n                    c[j][k]=(c[j][k]*2)%3;\n                }\n            }\n        }\n        else{\n            for(int j=0;j<num;++j){\n                c[j][11]++;\n                int k=11;\n                while(c[j][k]>=3){\n                    c[j][k]-=3;\n                    k--;\n                    c[j][k]++;\n                }\n            }\n        }\n    }\n    int ans[num];\n    for(int i=0;i<num;++i){\n        ans[i]=0;\n        for(int j=12-n;j<12;++j){\n            ans[i]=ans[i]*3+c[i][j];\n        }\n    }\n    std::cout<<ans[0];\n    for(int i=1;i<num;++i){\n        std::cout<<\" \"<<ans[i];\n    }\n    std::cout<<std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n//短縮\n#define rep(i,n) for(int i=0;i<(n);++i)\n//sort()用\n#define all(v) v.begin(), v.end()\n\nusing namespace std;\n\nusing Graph = vector<vector<int>>;\n\nint convert(int x, int n,int j=10){\n    int y=0, i=0, z;\n    while(x > 0){\n        z = x%n;\n        y += z*pow(j, i);\n        x = x/n;\n        i++;\n    }\n    return y;\n}\n\nint sarusa_convert(int k){\n  string buffer = to_string(convert(k,3));\n\n  rep(i,buffer.size()){\n    if(buffer[i]=='1') buffer[i]='2';\n    else if(buffer[i]=='2') buffer[i]='1';\n  }\n\n  int answer = convert(atoi(buffer.c_str()),10,3);\n  return answer;\n}\n\nint main(){\n  int N;\n  string T;\n  cin >> N >> T;\n  vector<int> P(pow(3,N));\n\n  rep(i,P.size())P[i] = i;\n  //for(int i=0;i<P.size();i++) cout << P[i] << endl;\n\n  rep(i,T.size()){\n    if(T[i] == 'R'){ //ルンバ　１ずつずれる\n      for(int k=0;k<P.size();k++){\n        P[k] = P[k] + 1;\n        if(P[k]==pow(3,N))P[k] = 0;\n      }\n    }\n    else{\n      for(int k=0;k<P.size();k++){\n        P[k]=sarusa_convert(P[k]);\n        if(P[k]==pow(3,N))P[k] = 0;\n      }\n    }\n  }\n\n  for(int i=0;i<P.size();i++) cout << P[i] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nconst int N = 1000005;\n\nint n, q;\nchar op[N];\n\nint pw[13];\n\nint ans[N];\n\nstruct Trie {\n\tint rt, cnt, son[N][3], id[N];\n\tbool tag[N];\n\n\tvoid build(int &u, int d, int v) {\n\t\tu = ++cnt, tag[u] = 0;\n\t\tif (d == n) {\n\t\t\tid[u] = v;\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tbuild(son[u][i], d + 1, v + i * pw[d]);\n\t\t}\n\t}\n\n\tvoid rev(int u) {\n\t\tstd::swap(son[u][1], son[u][2]);\n\t\ttag[u] ^= 1;\n\t}\n\n\tvoid down(int u) {\n\t\tif (tag[u]) {\n\t\t\trev(son[u][0]), rev(son[u][1]), rev(son[u][2]);\n\t\t\ttag[u] = 0;\n\t\t}\n\t}\n\n\tvoid add(int u) {\n\t\tif (!son[u][0]) {\n\t\t\treturn;\n\t\t}\n\t\tdown(u);\n\t\tint t = son[u][2];\n\t\tson[u][2] = son[u][1];\n\t\tson[u][1] = son[u][0];\n\t\tson[u][0] = t;\n\t\tadd(son[u][0]);\n\t}\n\n\tvoid getans(int u, int d, int v) {\n\t\tif (d == n) {\n\t\t\tans[id[u]] = v;\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tgetans(son[u][i], d + 1, v + i * pw[d]);\n\t\t}\n\t}\n} T;\n\nint main() {\n\tread(n);\n\tq = readStr(op + 1);\n\tpw[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tpw[i] = pw[i - 1] * 3;\n\t}\n\tT.build(T.rt, 0, 0);\n\tfor (int i = 1; i <= q; ++i) {\n\t\tif (op[i] == 'S') {\n\t\t\tT.rev(T.rt);\n\t\t} else {\n\t\t\tT.add(T.rt);\n\t\t}\n\t}\n\tT.getans(T.rt, 0, 0);\n\tfor (int i = 0; i < pw[n]; ++i) {\n\t\tprint(ans[i], ' ');\n\t}\n\tputchar('\\n');\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 3e6;\n\nint n;\nstruct {\n    int v;\n    int tag;\n} t[N];\n\nvoid build(int p, int v, int d) {\n    if (d > n) return;\n    t[p].v = v;\n    for (int i = 0; i < 3; i++) {\n        build(p * 3 + i, i, d + 1);\n    }\n}\n\nvoid pushdown(int p) {\n    for (int i = 0; i < 3; i++) {\n        t[p * 3 + i].tag += t[p].tag;\n    }\n    if (t[p].tag & 1 && t[p].v) {\n        t[p].v ^= 3;\n    }\n    t[p].tag = 0;\n}\n\nvoid update(int p, int d) {\n    if (d > n) return;\n    for (int i = 0; i < 3; i++) {\n        int x = p * 3 + i;\n        pushdown(x);\n        t[x].v++;\n        if (t[x].v == 3) {\n            t[x].v = 0;\n            update(x, d + 1);\n        }\n    }\n}\n\nint query(int p, int x, int d) {\n    if (d > n) return 0;\n    pushdown(p);\n    int res = t[p].v;\n    return query(p * 3 + x % 3, x / 3, d + 1) * 3 + res;\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\n    cin >> n;\n    string s;\n    cin >> s;\n    build(1, 0, 0);\n\n    for (auto c : s) {\n        if (c == 'S') {\n            t[1].tag++;\n        }\n        else {\n            pushdown(1);\n            update(1, 0);\n        }\n    }\n    int t = 1;\n    for (int i = 1; i <= n; i++) t *= 3;\n    for (int i = 0; i < t; i++) cout << query(1, i, 0) / 3 << ' ';\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 14;\nstring s; int n,pw[N];vector<char> w; vector<vector<char> > f,g; vector<int> h,p;\ninline int get(int x,int l){ return x % pw[l]; }\ninline void add(vector<char> &s,char c) {\n\tif (c == 'R') s.push_back(c);\n\telse if (s.size() && s[s.size()-1] == 'S') s.pop_back();\n\telse s.push_back(c);\n}\nint main(){\n\tint i;\n\tcin >> n >> s;\n\tfor (pw[0] = i = 1; i <= 12 ; ++i) pw[i] = pw[i-1]*3;\n\tfor (i = 0; i < s.size(); ++i) w.push_back(s[i]);\n\tf.push_back(w),h.push_back(0);\n    for (i = 1; i <= n; ++i){\n\t\tg.resize(pw[i]),p.resize(pw[i]);\n        for(int now = 0; now < pw[i] ; ++now) {\n\t\t\tint cur = get(now,i-1);\n\t\t\tp[now] = h[cur];\n\t\t\tint d = now/pw[i-1]%3;\n\t\t\tfor (auto v : f[cur]){\n\t\t\t\tif(v == 'S') d = (d<<1)%3,add(g[now],v);\n\t\t\t\telse if(d == 2) d = 0,add(g[now],v);\n\t\t\t\telse d += 1;\n\t\t\t}\n\t\t\tp[now] += d*pw[i-1];\n\t\t}\n\t\th.clear(),f.clear(),swap(f,g),swap(h,p);\n\t}\n\tfor (i = 0; i < pw[n]; ++i) cout << h[i] << ((i<pw[n]-1) ? (' ') : ('\\n'));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fo(a,b,c) for (a=b; a<=c; a++)\n#define fd(a,b,c) for (a=b; a>=c; a--)\n#define ll long long\n//#define file\nusing namespace std;\n\nint p[13],tr[1594323][3],Tr[1594323],rt[3],num[1594323],ans[531441],n,i,j,k,l,len,Len;\nchar st[200001];\n\nvoid New(int t,int x) {tr[t][x]=++len;}\nvoid mt(int T,int t,int s)\n{\n\tif (T==n) {num[t]=s; return;}\n\tNew(t,0);mt(T+1,tr[t][0],s);\n\tNew(t,1);mt(T+1,tr[t][1],s+p[T]);\n\tNew(t,2);mt(T+1,tr[t][2],s+p[T]*2);\n}\n\nvoid swap(int &x,int &y) {int z=x;x=y;y=z;}\nvoid down(int t)\n{\n\tif (Tr[t])\n\t{\n\t\tswap(tr[t][1],tr[t][2]);\n\t\tif (tr[t][0])\n\t\tTr[tr[t][0]]^=1,Tr[tr[t][1]]^=1,Tr[tr[t][2]]^=1;\n\t\tTr[t]=0;\n\t}\n}\nvoid change(int t)\n{\n\tdown(t);\n\tif (!tr[t][0]) return;\n\t\n\tint x=tr[t][2];\n\ttr[t][2]=tr[t][1];tr[t][1]=tr[t][0];tr[t][0]=x;\n\tchange(x);\n}\nvoid find(int T,int t,int s)\n{\n\tdown(t);\n\tif (T==n) {ans[num[t]]=s;return;}\n\tfind(T+1,tr[t][0],s);find(T+1,tr[t][1],s+p[T]);find(T+1,tr[t][2],s+p[T]*2);\n}\n\nint main()\n{\n\t#ifdef file\n\tfreopen(\"c.in\",\"r\",stdin);\n\t#endif\n\t\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",st);Len=strlen(st);\n\t\n\tp[0]=1;fo(i,1,12) p[i]=p[i-1]*3;\n\tmt(0,0,0);\n\t\n\tfo(i,0,Len-1)\n\tif (st[i]=='S') Tr[0]^=1; else change(0);\n\tfind(0,0,0);\n\tfo(i,0,p[n]-1) printf(\"%d \",ans[i]);printf(\"\\n\");\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nstring T,S;\nll p3[13];\nll P[540000];\nll D[540000];\nint F[540000];\nll W[14][540000];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>T;\n\tp3[0]=1;\n\tFOR(i,N) p3[i+1]=p3[i]*3;\n\t\n\tfor(i=1;i<=N;i++) {\n\t\tFOR(x,p3[i]) D[x]=x/p3[i-1];\n\t\tZERO(F);\n\t\tint nf=0;\n\t\tFOR(x,T.size()) {\n\t\t\ty=W[i-1][x-1];\n\t\t\tif(T[x]=='S') {\n\t\t\t\tnf++;\n\t\t\t\tif((nf-F[y])%2) {\n\t\t\t\t\tFOR(j,3) {\n\t\t\t\t\t\tif(D[y+j*p3[i-1]]==1) D[y+j*p3[i-1]]=2;\n\t\t\t\t\t\telse if(D[y+j*p3[i-1]]==2) D[y+j*p3[i-1]]=1;\n\t\t\t\t\t}\n\t\t\t\t\tF[y]=nf;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif((nf-F[y])%2) {\n\t\t\t\t\tFOR(j,3) {\n\t\t\t\t\t\tif(D[y+j*p3[i-1]]==1) D[y+j*p3[i-1]]=2;\n\t\t\t\t\t\telse if(D[y+j*p3[i-1]]==2) D[y+j*p3[i-1]]=1;\n\t\t\t\t\t}\n\t\t\t\t\tF[y]=nf;\n\t\t\t\t}\n\t\t\t\tFOR(j,3) {\n\t\t\t\t\tD[y+j*p3[i-1]]=(D[y+j*p3[i-1]]+1)%3;\n\t\t\t\t}\n\t\t\t}\n\t\t\ty=W[i-1][x];\n\t\t\tif((nf-F[y])%2) {\n\t\t\t\tFOR(j,3) {\n\t\t\t\t\tif(D[y+j*p3[i-1]]==1) D[y+j*p3[i-1]]=2;\n\t\t\t\t\telse if(D[y+j*p3[i-1]]==2) D[y+j*p3[i-1]]=1;\n\t\t\t\t}\n\t\t\t\tF[y]=nf;\n\t\t\t}\n\t\t\tFOR(j,3) if(D[y+j*p3[i-1]]==2) W[i][x]=W[i-1][x]+j*p3[i-1];\n\t\t}\n\t\t\n\t\t\n\t\tFOR(y,p3[i-1]) {\n\t\t\tif((nf-F[y])%2) {\n\t\t\t\tFOR(j,3) {\n\t\t\t\t\tif(D[y+j*p3[i-1]]==1) D[y+j*p3[i-1]]=2;\n\t\t\t\t\telse if(D[y+j*p3[i-1]]==2) D[y+j*p3[i-1]]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tFOR(x,p3[N]) P[x]+=D[x%p3[i]]*p3[i-1];\n\t}\n\t\n\tFOR(i,p3[N]) {\n\t\tcout<<P[i]<<\" \";\n\t}\n\tcout<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n#include <stack>\n#include <cassert>\n#include <map>\n#include <numeric>\n#include <cstring>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <cmath>\n#include <iomanip>\n#include <iterator>\n\nusing namespace std;\n\nclock_t timeStart, timeFinish;\n\nvoid timeBegin() {\n    timeStart = clock();\n}\n\nvoid timeEnd() {\n    timeFinish = clock();\n}\n\nvoid timeDuration() {\n    double time_taken = double(timeFinish - timeStart) / double(CLOCKS_PER_SEC);\n    cout << \"Time taken by program is : \" << fixed << time_taken << setprecision(5);\n    cout << \" sec \" << endl;\n}\n\nclass InputReader {\npublic:\n    InputReader() {\n        input_file = stdin;\n        cursor = 0;\n        fread(buffer, SIZE, 1, input_file);\n    }\n    InputReader(const char *file_name) {\n        input_file = fopen(file_name, \"r\");\n        cursor = 0;\n        fread(buffer, SIZE, 1, input_file);\n    }\n    inline InputReader &operator >>(int &n) {\n        while((buffer[cursor] < '0' || buffer[cursor] > '9') && buffer[cursor] != '-') {\n            advance();\n        }\n        int sign = 1;\n        if (buffer[cursor] == '-') {\n            sign = -1;\n            advance();\n        }\n        n = 0;\n        while('0' <= buffer[cursor] && buffer[cursor] <= '9') {\n            n = n * 10 + buffer[cursor] - '0';\n            advance();\n        }\n        n *= sign;\n        return *this;\n    }\nprivate:\n    FILE *input_file;\n    static const int SIZE = 1 << 17;\n    int cursor;\n    char buffer[SIZE];\n    inline void advance() {\n        ++ cursor;\n        if(cursor == SIZE) {\n            cursor = 0;\n            fread(buffer, SIZE, 1, input_file);\n        }\n    }\n};\n\nstruct Node {\n    int value;\n    int lazy;\n    Node *son[3];\n\n    Node() {\n        value = -1;\n        lazy = 0;\n        son[0] = son[1] = son[2] = nullptr;\n    }\n};\n\nconst int MAXVAL = 531441;\n\nint answer[MAXVAL];\n\nvoid refresh(Node *node) {\n    if (node->lazy) {\n        swap(node->son[1], node->son[2]);\n        for (int b = 0; b < 3; b++)\n            node->son[b]->lazy ^= 1;\n        node->lazy = 0;\n    }\n}\n\nvoid DFS(Node *node, int newValue, int power3) {\n    if (node->value != -1) {\n        answer[node->value] = newValue;\n        return;\n    }\n    refresh(node);\n    for (int b = 0; b < 3; b++)\n        DFS(node->son[b], newValue + power3 * b, power3 * 3);\n}\n\nint main() {\n    timeBegin();\n    //ifstream cin(\"input.in\");\n    //ofstream cout(\"ultrapoligon.out\");\n    int n, limit = 1;\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n        limit *= 3;\n    Node *root = new Node();\n    for (int i = 0; i < limit; i++) {\n        int x = i;\n        Node *node = root;\n        for (int j = 0; j < n; j++) {\n            int b = x % 3;\n            x /= 3;\n            if (node->son[b] == nullptr) {\n                node->son[b] = new Node();\n            }\n            node = node->son[b];\n        }\n        node->value = i;\n    }\n    string s;\n    cin >> s;\n    for (auto op : s) {\n        if (op == 'S') {\n            root->lazy ^= 1;\n        }\n        else {\n            Node *node = root;\n            for (int i = 0; i < n; i++) {\n                refresh(node);\n                Node *temp[3];\n                for (int b = 0; b < 3; b++) {\n                    temp[(b + 1) % 3] = node->son[b];\n                }\n                for (int b = 0; b < 3; b++) {\n                    node->son[b] = temp[b];\n                }\n                node = node->son[0];\n            }\n        }\n    }\n    DFS(root, 0, 1);\n    for (int i = 0; i < limit; i++)\n        cout << answer[i] << \" \";\n    cout << \"\\n\";\n    timeEnd();\n    //timeDuration();\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool bo;\nint ans[600010],A,B,n,f[600010],g[600010],len,nw;\nchar s[200010];\n\nint main()\n{\n\tscanf(\"%d%s\",&n,s),len=strlen(s),A=B=1;\n\tfor (int i=1; i<=(n+1)/2; i++) A*=3;\n\tfor (int i=(n+1)/2; i<n; i++) B*=3;\n\tfor (int i=0; i<A*B; i++) f[i]=f[i/3]*3+(i*2%3),g[i]=(i+1)%(A*B);\n\tfor (int i=0; i<A; i++)\n\t{\n\t\tnw=i,bo=0;\n\t\tfor (int j=0; j<len; j++)\n\t\t\tif (s[j]=='R') nw=g[nw]; else nw=f[nw],bo^=1;\n\t\tif (nw<A) {for (int j=0; j<B; j++) ans[j*A+i]=(bo?f[j]:j)*A+nw;} else\n\t\t{\n\t\t\tans[i]=nw;\n\t\t\tfor (int j=1; j<B; j++)\n\t\t\t{\n\t\t\t\tnw=j*A+i;\n\t\t\t\tfor (int k=0; k<len; k++)\n\t\t\t\t\tif (s[k]=='R') nw=g[nw]; else nw=f[nw];\n\t\t\t\tans[j*A+i]=nw;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=0; i<A*B; i++) printf(\"%d \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> // cout, endl, cin\n#include <string> // string, to_string, stoi\n#include <vector> // vector\n#include <algorithm> // min, max, swap, sort, reverse, lower_bound, upper_bound\n#include <utility> // pair, make_pair\n#include <tuple> // tuple, make_tuple\n#include <cstdint> // int64_t, int*_t\n#include <cstdio> // printf\n#include <map> // map\n#include <queue> // queue, priority_queue\n#include <set> // set\n#include <stack> // stack\n#include <deque> // deque\n#include <unordered_map> // unordered_map\n#include <unordered_set> // unordered_set\n#include <bitset> // bitset\n#include <cctype> // isupper, islower, isdigit, toupper, tolower\n#include<math.h>\n#define rep(i,n) for(int i = 0;i<(n);i++);\nusing namespace std;\nusing ll = long long;\nconst ll INF = 100100100100100;\n\nint main() {\n\tll a;\n\tcin >> a;\n\tstring s;\n\tcin >> s;\n\tif (a == 1 && s == \"SRS\") cout << \"2 0 1\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <iomanip>\n#include <functional>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 13;\n\nint p3[N];\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  p3[0] = 1;\n  for (int i = 1; i < N; ++i) p3[i] = 3 * p3[i - 1];\n  int n;\n  string s;\n  cin >> n >> s;\n  int m = s.size();\n  vector <int> go(1);\n  vector <int> who(m);\n  for (int b = 0; b < n; ++b) {\n    int sz = go.size();\n    vector <vector <int>> ngo(sz, vector <int> (3));\n    \n    for (int i = 0; i < sz; ++i) {\n      for (int j = 0; j < 3; ++j) {\n        ngo[i][j] = j;\n      }\n    }\n\n    int sw = 0;\n\n    auto make = [&] (int i) {\n      for (int j = 0; j < 3; ++j) {\n        if (ngo[i][j] == 0) {\n          swap(ngo[i][(j + 1) % 3], ngo[i][(j + 2) % 3]);\n        }\n      }\n    };    \n\n    for (int i = 0; i < m; ++i) {\n      if (s[i] == 'S') {\n        sw ^= 1;\n      } else {\n        int id = who[i];\n        if (sw) make(id);\n        for (int j = 0; j < 3; ++j) {\n          if (ngo[id][j] == 2) {\n            who[i] = j * sz + id;\n          }\n        }\n        for (int j = 0; j < 3; ++j) {\n          ngo[id][j] = (ngo[id][j] + 1) % 3;\n        } \n        if (sw) make(id);\n      }\n    }\n    if (sw) for (int i = 0; i < sz; ++i) make(i);\n    vector <int> cur(3 * sz);\n    for (int i = 0; i < 3; ++i) {\n      for (int j = 0; j < sz; ++j) {\n        cur[i * sz + j] = go[j] + ngo[j][i] * p3[b];\n      }\n    }\n    go = cur;\n  }\n  for (int i = 0; i < p3[n]; ++i) {\n    cout << go[i] << ' ';\n  }\n  cout << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\nusing namespace std;\n\nint n, len, l[3*3*3*3*3*3*3*3*3*3*3*3];\nstring t;\n\nint calc(int a) {\n\tif (a < 3) {\n\t\treturn a % 3 - 1 + (a + 1) % 3;\n\t}\n\telse {\n\t\treturn a % 3 - 1 + (a + 1) % 3 + 3 * calc(a / 3);\n\t}\n}\n\nint main()\n{\n\tcin >> n;\n\tcin >> t;\n\tn = pow(3, n);\n\tfor (int i = 0; i < n; i++) {\n\t\tl[i] = i;\n\t}\n\tfor (int i = 0; i < t.size(); i++) {\n\t\tif (t[i] == 'S') {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tl[j] = calc(l[j]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tl[j] = (l[j] + 1) % n;\n\t\t\t}\n\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << l[i] << \" \";\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate <typename T> inline void read(T &s)\n{\n\ts = 0;char ch = getchar();\n\twhile(!isdigit(ch)) ch = getchar();\n\twhile(isdigit(ch)) s = ((s+(s<<2))<<1)+ch-'0',ch = getchar();\n}\nstring s,tmp,Q;\nint x,len,L,R,Mid,Tmp,LEN = 128;\nint main()\n{\n\ts = \"\";\n\tfor(char i = 'a';i<='z';++i)\n\t{\n\t\ttmp = \"? \";\n\t\tfor(int j = 1;j<=LEN;++j) tmp = tmp + i;\n\t\tcout << tmp << endl;fflush(stdout);cin >> len;\n\t\tlen = LEN - len / 2;\n\t\tfor(int j = 1;j<=len;++j)\n\t\t{\n\t\t\tL = 1,R = s.size(),Tmp = 0;\n\t\t\twhile(L <= R)\n\t\t\t{\n\t\t\t\tMid = (L + R) >> 1;\n\t\t\t\ttmp = \"? \";\n\t\t\t\tfor(int i = 0;i<Mid;++i) tmp += s[i];\n\t\t\t\ttmp += i;\n\t\t\t\tcout << tmp << endl;fflush(stdout);cin >> x;\n\t\t\t\tif(x == (LEN - (Mid+1)) * 2) Tmp = Mid,L = Mid+1;\n\t\t\t\telse R = Mid-1;\n\t\t\t}\n\t\t\ttmp = \"\";\n\t\t\tfor(int i = 0;i<Tmp;++i) tmp += s[i];\n\t\t\ttmp += i;\n\t\t\tfor(int i = Tmp;i<s.size();++i) tmp += s[i];\n\t\t\ts = tmp;\n\t\t}\n\t}\n\tfor(char i = '0';i<='9';++i)\n\t{\n\t\ttmp = \"? \";\n\t\tfor(int j = 1;j<=LEN;++j) tmp = tmp + i;\n\t\tcout << tmp << endl;fflush(stdout);cin >> len;\n\t\tlen = LEN - len / 2;\n\t\tfor(int j = 1;j<=len;++j)\n\t\t{\n\t\t\tL = 1,R = s.size(),Tmp = 0;\n\t\t\twhile(L <= R)\n\t\t\t{\n\t\t\t\tMid = (L + R) >> 1;\n\t\t\t\ttmp = \"? \";\n\t\t\t\tfor(int i = 0;i<Mid;++i) tmp += s[i];\n\t\t\t\ttmp += i;\n\t\t\t\tcout << tmp << endl;fflush(stdout);cin >> x;\n\t\t\t\tif(x == (LEN - (Mid+1)) * 2) Tmp = Mid,L = Mid+1;\n\t\t\t\telse R = Mid-1;\n\t\t\t}\n\t\t\ttmp = \"\";\n\t\t\tfor(int i = 0;i<Tmp;++i) tmp += s[i];\n\t\t\ttmp += i;\n\t\t\tfor(int i = Tmp;i<s.size();++i) tmp += s[i];\n\t\t\ts = tmp;\n\t\t}\n\t}\n\tfor(char i = 'A';i<='Z';++i)\n\t{\n\t\ttmp = \"? \";\n\t\tfor(int j = 1;j<=LEN;++j) tmp = tmp + i;\n\t\tcout << tmp << endl;fflush(stdout);cin >> len;\n\t\tlen = LEN - len / 2;\n\t\tfor(int j = 1;j<=len;++j)\n\t\t{\n\t\t\tL = 1,R = s.size(),Tmp = 0;\n\t\t\twhile(L <= R)\n\t\t\t{\n\t\t\t\tMid = (L + R) >> 1;\n\t\t\t\ttmp = \"? \";\n\t\t\t\tfor(int i = 0;i<Mid;++i) tmp += s[i];\n\t\t\t\ttmp += i;\n\t\t\t\tcout << tmp << endl;fflush(stdout);cin >> x;\n\t\t\t\tif(x == (LEN - (Mid+1)) * 2) Tmp = Mid,L = Mid+1;\n\t\t\t\telse R = Mid-1;\n\t\t\t}\n\t\t\ttmp = \"\";\n\t\t\tfor(int i = 0;i<Tmp;++i) tmp += s[i];\n\t\t\ttmp += i;\n\t\t\tfor(int i = Tmp;i<s.size();++i) tmp += s[i];\n\t\t\ts = tmp;\n\t\t}\n\t}\n\ts = \"! \" + s;\n\tcout << s << endl;fflush(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,...) for(int i = (a)*(strlen(#__VA_ARGS__)!=0);i<(int)(strlen(#__VA_ARGS__)?__VA_ARGS__:(a));++i)\n#define per(i,a,...) for(int i = (strlen(#__VA_ARGS__)?__VA_ARGS__:(a))-1;i>=(int)(strlen(#__VA_ARGS__)?(a):0);--i)\n#define foreach(i, n) for(auto &i:(n))\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define all(x) (x).begin(), (x).end()\n#define bit(x) (1ll << (x))\nusing ll = long long;\n//const ll MOD = (ll)1e9+7;\nconst ll MOD = 998244353;\nconst int INF = (ll)1e9+7;\nconst ll INFLL = (ll)1e18;\nusing namespace std;\ntemplate<class t>\nusing vvector = vector<vector<t>>;\ntemplate<class t>\nusing vvvector = vector<vector<vector<t>>>;\ntemplate<class t>\nusing priority_queuer = priority_queue<t, vector<t>, greater<t>>;\ntemplate<class t, class u> bool chmax(t &a, u b){if(a<b){a=b;return true;}return false;}\ntemplate<class t, class u> bool chmin(t &a, u b){if(a>b){a=b;return true;}return false;}\n#ifdef DEBUG\n#define debug(x) cout<<\"LINE \"<<__LINE__<<\": \"<<#x<<\" = \"<<x<<endl;\n#else\n#define debug(x) (void)0\n#endif\n\nnamespace templates{\n  ll modpow(ll x, ll b){\n    ll res = 1;\n    while(b){\n      if(b&1)res = res * x % MOD;\n      x = x * x % MOD;\n      b>>=1;\n    }\n    return res;\n  }\n\n  ll modinv(ll x){\n    return modpow(x, MOD-2);\n  }\n\n  bool was_output = false;\n  template<class t>\n  void output(t a){\n    if(was_output)cout << \" \";\n    cout << a;\n    was_output = true;\n  }\n  void outendl(){\n    was_output = false;\n    cout << endl;\n  }\n  ll in(){\n    ll res;\n    scanf(\"%lld\", &res);\n    return res;\n  }\n\n  template<class t>\n  istream& operator>>(istream&is, vector<t>&x){\n    for(auto &i:x)is >> i;\n    return is;\n  }\n\n  template<class t, class u>\n  istream& operator>>(istream&is, pair<t, u>&x){\n    is >> x.first >> x.second;\n    return is;\n  }\n\n  template<class t>\n  void in(t&x){\n    cin >> x;\n  }\n\n  template<class t>\n  t in(){\n    t res; cin >> res; return res;\n  }\n\n  template<class t>\n  void out(t x){\n    cout << x;\n  }\n\n  template<class t>\n  vector<t> sorted(vector<t> line,function<bool(t,t)> comp=[](t a,t b){return a<b;}){\n    sort(line.begin(),line.end(),comp);\n    return line;\n  }\n\n  template<class t>\n  vector<t> reversed(vector<t> line){\n    reverse(line.begin(),line.end());\n    return line;\n  }\n}\n\nusing namespace templates;\n\nvector<int> inputs(){\n  string str = in<string>();\n  vector<int> res;\n  foreach(i,str){\n    if(i=='S'){\n      res.emplace_back(1);\n    }else{\n      res.emplace_back(0);\n    }\n  }\n  return res;\n}\n\nll k3(int x){\n  if(x==0)return 1;\n  static vector<ll> dp(50,-1);\n  ll &it = dp[x];\n  if(it>=0)return it;\n  return it = 3 * k3(x-1);\n}\n\nclass tree{\npublic:\n  class node{\n  public:\n    int depth;\n    int value;\n    int turn;\n    node* node0;\n    node* node1;\n    node* node2;\n    node(int d,int b,int sum){\n      turn = 0;\n      depth = d;\n      if(depth==b){\n        value = sum;\n        return;\n      }\n      node0 = new node(d+1,b,sum);\n      node1 = new node(d+1,b,sum+k3(d));\n      node2 = new node(d+1,b,sum+2*k3(d));\n    }\n  };\n  node* root;\n  int bottom;\n  tree(int b){\n    bottom = b;\n    root = new node(0,bottom,0);\n  }\n\n  void turn(){\n    ++(root->turn);\n  }\n\n  void add(){\n    add(root);\n  }\n\n  void add(node* current){\n    if(current->depth==bottom)return;\n    if(current->turn&1){\n      swap(current->node1,current->node2);\n      ++(current->node0->turn);\n      ++(current->node1->turn);\n      ++(current->node2->turn);\n    }\n    current->turn = 0;\n    swap(current->node2,current->node1);\n    swap(current->node1,current->node0);\n    add(current->node0);\n  }\n\n  vector<int> to_string(){\n    vector<int> ans(k3(bottom));\n    to_string(ans,root,0);\n    return ans;\n  }\n\n  void to_string(vector<int>& res,node* current,int sum){\n    if(current->depth==bottom){\n      res[current->value] = sum;\n      return;\n    }\n    if(current->turn&1){\n      swap(current->node1,current->node2);\n      ++(current->node0->turn);\n      ++(current->node1->turn);\n      ++(current->node2->turn);\n    }\n    current->turn = 0;\n    to_string(res,current->node0,sum);\n    to_string(res,current->node1,sum+k3(current->depth));\n    to_string(res,current->node2,sum+2*k3(current->depth));\n  }\n};\n\n\nint main(){\n  int n = in();\n  vector<int> line = inputs();\n  tree t(n);\n  foreach(i,line){\n    if(i){\n      t.turn();\n    }else{\n      t.add();\n    }\n  }\n  vector<int> ans = t.to_string();\n  foreach(i,ans){\n    output(i);\n  }\n  outendl();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing int64 = long long;\n\nconstexpr int DEBUG = 0;\n\nint Power3(int p) {\n  int r = 1;\n  for (int i = 0; i < p; i++) {\n    r *= 3;\n  }\n  return r;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n  string original_command;\n  cin >> original_command;\n  vector<vector<int>> output_table(n + 1);\n  vector<vector<string>> command_table(n + 1);\n  for (int k = 1; k <= n; k++) {\n    output_table[k].resize(Power3(k));\n    command_table[k].resize(Power3(k));\n  }\n\n  for (int k = 1; k <= n; k++) {\n    for (int x = 0; x < Power3(k); x++) {\n      // cout << \"k: \" << k << \" x: \" << x << endl;\n\n      string command;\n      if (k == 1) {\n        command = original_command;\n      } else {\n        command = command_table[k - 1][x % Power3(k - 1)];\n      }\n\n      int d = x / Power3(k - 1);\n      string next_command = \"\";\n      for (char c : command) {\n        if (c == 'R') {\n          d++;\n          if (d == 3) {\n            d = 0;\n            next_command.append(\"R\");\n          }\n        } else if (c == 'S') {\n          if (d == 1) d = 2;\n          else if (d == 2) d = 1;\n\n          next_command.append(\"S\");\n        }\n      }\n\n      next_command = std::regex_replace(next_command, std::regex(\"SS\"), \"\");\n\n      output_table[k][x] = d;\n      command_table[k][x] = next_command;\n    }\n  }\n\n  vector<int> outputs;\n  for (int x = 0; x < Power3(n); x++) {\n    int output = 0;\n    for (int k = 1; k <= n; k++) {\n      output += output_table[k][x % Power3(k)] * Power3(k - 1);\n    }\n    outputs.push_back(output);\n  }\n\n  for (int i = 0; i < outputs.size(); i++) {\n    if (i > 0) cout << \" \";\n    cout << outputs[i];\n  }\n  cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> void read(T &x){\n\tint f=0; x=0; char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar()) f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\tif(f) x=-x;\n}\n\nconst int N=1000005;\nint t[N][3],tag[N],val[N],ans[N],pw[20],n,rt,sz,cur,tot;\nchar opt[N];\n\nint build(int n,int v){\n\tint o=++sz;\n\tif(!n){\n\t\tval[o]=v+1,tot++;\n\t\treturn o;\n\t}\n\tREP(c,3){\n\t\tt[o][c]=build(n-1,v+c*pw[::n-n]);\n\t}\n\treturn o;\n}\n\nvoid rever(int o){\n\tif(val[o]) return;\n\tswap(t[o][1],t[o][2]);\n\ttag[o]^=1;\n}\nvoid down(int o){\n\tif(tag[o]){\n\t\trever(t[o][0]);\n\t\trever(t[o][1]);\n\t\trever(t[o][2]);\n\t\ttag[o]=0;\n\t}\n}\nvoid upd(int o){\n\tif(val[o]) return;\n\tdown(o);\n\tswap(t[o][1],t[o][2]);\n\tswap(t[o][0],t[o][1]);\n\tupd(t[o][0]);\n}\nvoid solve(int n,int o,int v){\n\tif(val[o]){\n\t\tans[val[o]-1]=v;\n\t\treturn;\n\t}\n\tdown(o);\n\tREP(c,3){\n\t\tsolve(n-1,t[o][c],v+pw[::n-n]*c);\n\t}\n}\n\nint main(){\n\tread(n);\n\tpw[0]=1;\n\trep(i,1,n){\n\t\tpw[i]=pw[i-1]*3;\n\t}\n\trt=build(n,0);\n\tscanf(\"%s\",opt+1);\n\tfor(int i=1;opt[i];i++){\n\t\tif(opt[i]=='S'){\n\t\t\trever(rt);\n\t\t}\n\t\telse{\n\t\t\tupd(rt);\n\t\t}\n\t}\n\tsolve(n,rt,0);\n\tREP(i,tot){\n\t\tprintf(\"%d \",ans[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint pow3(int N){\n    int res = 1;\n    for(int i=0;i<N;i++) res *= 3;\n    return res;\n}\n\npair<vector<int>, vector<int>> solve(int N, const string& T){\n    if(N==0){\n        return make_pair(vector<int>(1, 0), vector<int>(T.size(), 0));\n    }\n    auto prev = solve(N-1, T);\n    auto& P = prev.first;\n    auto& W = prev.second;\n    vector<int> D(3*P.size());\n    for(int i=0;i<D.size();i++) D[i] = i/P.size();\n    int salsa = 0;\n    vector<int> lastSalsa(3*P.size(), 0);\n    vector<int> curW(W.size());\n    for(int i=0;i<T.size();i++){\n        for(int j=W[i];j<D.size();j+=P.size()){\n            if(salsa != lastSalsa[j]) D[j] = (3-D[j])%3;\n            lastSalsa[j] = salsa;\n            if(D[j] == 2) curW[i] = j;\n        }\n        if(T[i] == 'S'){\n            salsa = 1 - salsa;\n        } else {\n            for(int j=W[i];j<=D.size();j+=P.size()) D[j] = (D[j]+1)%3;\n        }\n    }\n    vector<int> curP(D.size());\n    for(int i=0;i<curP.size();i++){\n        if(salsa != lastSalsa[i]) D[i] = (3-D[i])%3;\n        curP[i] = P.size() * D[i] + P[i%P.size()];\n    }\n    return make_pair(curP, curW);\n}\n\nint main(){\n    int N; cin >> N;\n    string T; cin >> T;\n    auto res = solve(N, T).first;\n    cout << res[0];\n    for(int i=1;i<res.size();i++) cout << \" \" << res[i];\n    cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define SZ(x) (int)x.size()-1\n#define F(i,a,b) for (int i=a;i<=b;++i)\n#define DF(i,a,b) for (int i=a;i>=b;--i)\n#define pb push_back\n#define ms(a,b) memset(a,b,sizeof a)\nusing namespace std;\nint read(){\n    char ch=getchar(); int w=1,c=0;\n    for (;!isdigit(ch);ch=getchar()) if (ch=='-') w=-1;\n    for (;isdigit(ch);ch=getchar()) c=(c<<3)+(c<<1)+(ch^48);\n    return w*c;\n}\nconst int M=5e6+10;\nint t[M][3],n,pw[M];\nint val[M],rt,tot,ans[M];\nbool tg[M];\nchar ch[M];\nvoid rev(int x){\n\ttg[x]^=1;\n\tswap(t[x][1],t[x][2]);\n}\nvoid pd(int x){\n\tif (tg[x]) {\n\t\tF(i,0,2)\n\t\trev(t[x][i]);\n\t\ttg[x]=0;\n\t}\n}\nvoid build(int &x,int dep,int o){\n\tx=++tot; val[x]=o;\n\tif (dep==n) return ;\n\tF(i,0,2) build(t[x][i],dep+1,o+pw[dep]*i);\n}\nvoid add(int x,int dep){\n\tif (dep==n) return ;\n\tpd(x);\n\tint t0=t[x][0],t1=t[x][1],t2=t[x][2];\n\tt[x][0]=t2; t[x][1]=t0; t[x][2]=t1; \n\tadd(t[x][0],dep+1);\n}\nvoid calc(int x,int dep,int o){\n\tif (dep==n){\n\t\tans[val[x]]=o; \n\t\treturn ;\n\t}\n\tpd(x);\n\tF(i,0,2) calc(t[x][i],dep+1,o+pw[dep]*i);\n}\nint main(){\n\tn=read(); scanf(\"%s\",ch+1); int m=strlen(ch+1);\n\tpw[0]=1; F(i,1,20) pw[i]=pw[i-1]*3;\n\tbuild(rt,0,0);\n\tF(i,1,m){\n\t\tif (ch[i]=='S') rev(rt);\n\t\telse add(rt,0);\n\t}\n\tcalc(1,0,0);\n\t\n\tF(i,0,pw[n]-1){\n\t\tcout<<ans[i]<<\" \";\n\t}\n\tcout<<\"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define repn(i,n) for(int i=1;i<=n;i++)\n#define LL long long\n#define pii pair <int,int>\n#define fi first\n#define se second\n#define pb push_back\n#define mpr make_pair\n\nusing namespace std;\n\nconst LL MOD=1e9+7;\n\nint len=0;\n\nstruct node\n{\n\tint val,s0,s1,s2,delta;\t\n}a[600000];\n\nint n,ans[600000];\nstring s;\n\nvoid pushdown(int pos)\n{\n\tif(a[pos].delta==0) return;\n\ta[pos].delta=0;\n\ta[a[pos].s0].delta^=1;\n\tswap(a[a[pos].s0].s1,a[a[pos].s0].s2);\n\ta[a[pos].s1].delta^=1;\n\tswap(a[a[pos].s1].s1,a[a[pos].s1].s2);\n\ta[a[pos].s2].delta^=1;\n\tswap(a[a[pos].s2].s1,a[a[pos].s2].s2);\n}\n\nint build(int lev,int cur)\n{\n\tint pos=++len;\n\tif(lev==n)\n\t{\n\t\ta[pos].val=cur;\n\t\ta[pos].s0=a[pos].s1=a[pos].s2=a[pos].delta=0;\n\t\treturn pos;\n\t}\n\ta[pos].val=a[pos].delta=0;\n\ta[pos].s0=build(lev+1,cur);\n\ta[pos].s1=build(lev+1,cur+pow(3,lev));\n\ta[pos].s2=build(lev+1,cur+pow(3,lev)*2);\n\treturn pos;\n}\n\nvoid Rot(int pos)\n{\n\tif(pos==0) return;\n\tpushdown(pos);\n\tint tmp=a[pos].s0;\n\ta[pos].s0=a[pos].s2;\n\ta[pos].s2=a[pos].s1;\n\ta[pos].s1=tmp;\n\tRot(a[pos].s0);\n}\n\nvoid Swp()\n{\n\ta[1].delta^=1;\n\tswap(a[1].s1,a[1].s2);\n}\n\nvoid getans(int pos,int lev,int cur)\n{\n\tif(lev==n)\n\t{\n\t\tans[a[pos].val]=cur;\n\t\treturn;\n\t}\n\tpushdown(pos);\n\tgetans(a[pos].s0,lev+1,cur);\n\tgetans(a[pos].s1,lev+1,cur+pow(3,lev));\n\tgetans(a[pos].s2,lev+1,cur+pow(3,lev)*2);\n}\n\nint main()\n{\n\tcin>>n>>s;\n\tbuild(0,0);\n\trep(i,s.size())\n\t{\n\t\tif(s[i]=='R') Rot(1);\n\t\telse Swp();\n\t}\n\tgetans(1,0,0);\n\trep(i,pow(3,n)) cout<<ans[i]<<' ';\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=6e5+5;\nint n,rt,tot,sum[N],ans[N],t[N][3],lz[N];\nchar s[N];\nvoid build(int &now,int n,int b,int c)\n{\n    now=++tot;\n    if(n==0){sum[now]=c;return;}\n    build(t[now][0],n-1,b*3,c);\n    build(t[now][1],n-1,b*3,c+b);\n    build(t[now][2],n-1,b*3,c+b+b);\n}\nvoid updata(int now,int n)\n{\n    swap(t[now][1],t[now][2]);\n    lz[t[now][0]]^=1;\n    lz[t[now][1]]^=1;\n    lz[t[now][2]]^=1;\n    lz[now]=0;\n}\nvoid solve(int now,int n)\n{\n    if(n==0) return;\n    if(lz[now]) updata(now,n);\n    int a=t[now][0],b=t[now][1],c=t[now][2];\n    t[now][1]=a;t[now][2]=b;t[now][0]=c;\n    solve(t[now][0],n-1);\n}\nvoid getans(int now,int n,int b,int c)\n{\n    if(n==0){ans[sum[now]]=c;return;}\n    if(lz[now]) updata(now,n);\n    getans(t[now][0],n-1,b*3,c);\n    getans(t[now][1],n-1,b*3,c+b);\n    getans(t[now][2],n-1,b*3,c+b+b);\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    scanf(\"%s\",s+1);\n    build(rt,n,1,0);\n    for(int i=1;s[i];i++)\n    {\n        if(s[i]=='S') lz[rt]^=1;\n        else solve(rt,n);\n    }\n    getans(rt,n,1,0);\n    int sum=1;for(int i=1;i<=n;i++) sum*=3;\n    for(int i=0;i<sum;i++) printf(i==sum-1?\"%d\\n\":\"%d \",ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=600005,INF=1<<30;\nint N;\n\nvector<int> A;\nint ans[MAX],rui[20];\n\nvoid DFS(string &S){\n    if(si(A)==N) return;\n    \n    int M=si(S);\n    \n    for(int i=0;i<3;i++){\n        string T;\n        int now=i;\n        \n        for(int j=0;j<M;j++){\n            if(S[j]=='R'){\n                now++;\n                if(now==3){\n                    now=0;\n                    T+='R';\n                }\n            }else{\n                if(j==M-1){\n                    T+='S';\n                    if(now) now=3-now;\n                }\n                else if(S[j+1]=='S') j++;\n                else{\n                    T+='S';\n                    if(now) now=3-now;\n                }\n            }\n        }\n        \n        A.push_back(i);\n        \n        int sum=0;\n        for(int j=0;j<si(A);j++){\n            sum+=A[j]*rui[j];\n        }\n        while(sum<rui[N]){\n            ans[sum]+=now*rui[si(A)-1];\n            sum+=rui[si(A)];\n        }\n        \n        DFS(T);\n        A.pop_back();\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    cin>>N;\n    string S;cin>>S;\n    \n    rui[0]=1;\n    for(int i=1;i<18;i++) rui[i]=rui[i-1]*3;\n    \n    DFS(S);\n    \n    for(int i=0;i<rui[N];i++){\n        cout<<ans[i]<<\" \";\n    }\n    cout<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\nclass Radix {\nprivate:\n    const char* s;\n    int a[128];\npublic:\n    Radix(const char* s = \"0123456789ABCDEF\") : s(s) {\n        int i;\n        for (i = 0; s[i]; ++i)\n            a[(int)s[i]] = i;\n    }\n    std::string to(long long p, int q) {\n        int i;\n        if (!p)\n            return \"0\";\n        char t[64] = { };\n        for (i = 62; p; --i) {\n            t[i] = s[p % q];\n            p /= q;\n        }\n        return std::string(t + i + 1);\n    }\n    std::string to(const std::string& t, int p, int q) {\n        return to(to(t, p), q);\n    }\n    long long to(const std::string& t, int p) {\n        int i;\n        long long sm = a[(int)t[0]];\n        for (i = 1; i < (int)t.length(); ++i)\n            sm = sm * p + a[(int)t[i]];\n        return sm;\n    }\n};\n\nbool vector_has(vector<int> vec, int num) {\n    auto itr = std::find(vec.begin(), vec.end(), num);\n    size_t index = std::distance(vec.begin(), itr);\n    if (index != vec.size()) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\nint main() {\n    Radix r;\n    int N, temp;\n    string T;\n    int T_length;\n    cin >> temp;\n    N = (int)pow(3, temp);\n    cin >> T;\n    T_length = (int)T.length();\n    int* list = new int[N];\n    string temp_str;\n\n    // initialize\n    for (int i = 0; i < N; i++) {\n        list[i] = i;\n    }\n\n    // operation\n    for (int i = 0; i < T_length; i++) {\n        if (T[i] == T[i - 1]) {\n            continue;\n        }\n        // salsa\n        if (T[i] == 'S') {\n            vector<vector<int>> swap_index(N, vector<int>(N));\n            for (int list_index = 0; list_index < N; list_index++)\n            {\n                    // convert list_index from decimal to ternary\n                    temp_str = r.to(list_index, 3);\n                    int temp_str_length = (int)temp_str.length();\n                    // swap 1 with 2\n                    for (int j = 0; j < temp_str_length; j++) {\n                        switch (temp_str[j]) {\n                        case '1':\n                            temp_str[j] = '2';\n                            break;\n                        case '2':\n                            temp_str[j] = '1';\n                            break;\n                        }\n                    }\n                    // convert ternary to decimal\n                    temp = r.to(temp_str, 3);\n\n                    // check if swap hasn't been done for temp and list_index\n                    if (!vector_has(swap_index[list_index], temp)) {\n                        // convert string to integer\n                        swap(list[list_index], list[temp]);\n                        // register swapped opponent\n                        swap_index[list_index].push_back(temp);\n                        swap_index[temp].push_back(list_index);\n                    }\n\n            }\n        }\n        // rumba\n        else\n        {\n            for (int j = N - 1; 0 < j; j--) {\n                swap(list[j - 1], list[j]);\n            }\n        }\n    }\n    int* list_pos = new int[N];\n    for (int i = 0; i < N; i++) {\n        list_pos[list[i]] = i;\n    }\n\n    for (int i = 0; i < N; i++) {\n        cout << list_pos[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ri() {\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\n\nint main() {\n\tint n_ = ri();\n\tint n = n_;\n\tif (n & 1) n++;\n\tstd::string s;\n\tstd::cin >> s;\n\tint q = s.size();\n\t\n\tint half = n / 2;\n\tint k3 = 1;\n\tfor (int i = 0; i < half; i++) k3 *= 3;\n\tint next[k3];\n\tfor (int i = 0; i < k3; i++) {\n\t\tint cur[half];\n\t\tint t = i;\n\t\tfor (int j = 0; j < half; j++) cur[j] = t % 3, t /= 3;\n\t\tfor (auto &j : cur) {\n\t\t\tif (j == 1) j = 2;\n\t\t\telse if (j == 2) j = 1;\n\t\t}\n\t\tt = 0;\n\t\tfor (int j = half; j--; ) t *= 3, t += cur[j];\n\t\tnext[i] = t;\n\t}\n\t\n\tstd::vector<int> plus[k3];\n\tint end[k3];\n\tfor (int i = 0; i < k3; i++) {\n\t\tint cur = i;\n\t\tfor (auto j : s) {\n\t\t\tif (j == 'S') {\n\t\t\t\tcur = next[cur];\n\t\t\t\tif (!plus[i].size()) plus[i].push_back(0);\n\t\t\t\telse if (plus[i].back() == 0) plus[i].pop_back();\n\t\t\t\telse plus[i].push_back(0);\n\t\t\t} else if (cur + 1 == k3) {\n\t\t\t\tcur = 0;\n\t\t\t\tif (!plus[i].size() || !plus[i].back()) plus[i].push_back(1);\n\t\t\t\telse plus[i].back()++;\n\t\t\t} else cur++;\n\t\t}\n\t\tend[i] = cur;\n\t}\n\tint res[k3 * k3];\n\tfor (int i = 0; i < k3; i++) {\n\t\tfor (int j = 0; j < k3; j++) {\n\t\t\tint cur = i;\n\t\t\tfor (auto k : plus[j]) {\n\t\t\t\tif (!k) cur = next[cur];\n\t\t\t\telse cur = (cur + k) % k3;\n\t\t\t}\n\t\t\tres[i * k3 + j] = cur * k3 + end[j];\n\t\t}\n\t}\n\tint all = k3 * k3;\n\tif (n_ != n) all /= 3;\n\tfor (int i = 0; i < all; i++) printf(\"%d \", res[i] % all);\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n\nusing namespace std;\n\nlong long int N;\nstring T;\n\nvoid R(int *data);\nvoid S(int *data1, int *data2);\nint X(int x, int y);\n\nint main(){\n  int n;\n  string s1;\n  string s2;\n  cin >> n;\n  cin >> T;\n  N = X(3, n);\n  int L[N];\n  int K[N];\n  int O[N];\n  \n  for(long long int i=0;i<N;i++){\n    L[i] = i;\n  }\n  \n  for(long long int i=0;i<N/3;i++){\n    int k = i;\n    int tmp = 0;\n    int m = 3;\n    int q = i*3;\n    \n    while(k>0){\n      if(k%3==1){\n        tmp = tmp +2*m;\n      }else if(k%3==2){\n        tmp = tmp +1*m;\n      }\n      k = k/3;\n      m = m*3;\n    }\n    K[tmp] = q;\n    K[tmp + 1] = q+2;\n    K[tmp + 2] = q+1;\n  }\n  \n  \n  for(int i=0;i<(int)(T.length());i++){\n    s1 = T[i];\n    s2 = T[i+1];\n    if(s1==\"R\"){\n      R(L);\n    }else if(s1==\"S\" && s2==\"S\"){\n      i++;\n    }else{\n      S(L,K);\n    }\n  }\n  \n\n\n  for(long long int i=0;i<N;i++){\n    cout << L[i] << \" \";\n  }\n  return 0;\n}\n\nvoid R(int *data){\n  for(long long int i=0;i<N;i++){\n    data[i] = data[i] + 1;\n    if(data[i]==N){\n      data[i]=0;\n    }\n  }\n}\n\nvoid S(int *data1, int *data2){\n  for(long long int i=0;i<N;i++){\n    data1[i] = data2[data1[i]];\n  }\n}\n\n\nlong long int X(int x,int y){\n  long long int a = 1;\n  for(int i=0;i<y;i++){\n    a = a*x;\n  }\n  return a;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nclass people {\npublic:\n\tpeople() { n = 0; }\n\t~people() { if (n != 0)delete[]trip; }\n\tint pos;\n\tint n;\n\tint num;\n\tint* trip;\n\tvoid init(int _n, int _pos) {\n\t\tn = _n;\n\t\tnum = pow(3, n);\n\t\ttrip = new int[n + 1];\n\t\tpos = _pos;\n\t\tc10to3();\n\t}\n\tvoid c3to10() {\n\t\tint v = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tv += pow(3, i) * trip[i];\n\t\t}\n\t\tpos = v % num;\n\t}\n\tvoid c10to3() {\n\t\tint v = pos;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ttrip[i] = v % 3;\n\t\t\tv = floor((v - trip[i]) / 3);\n\t\t}\n\t}\n\tvoid rumba() {\n\t\tpos = (pos + 1) % num;\n\t\tc10to3();\n\t}\n\tvoid sarusa() {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (trip[i] == 1)trip[i] = 2;\n\t\t\telse if (trip[i] == 2)trip[i] = 1;\n\t\t}\n\t\tc3to10();\n\t}\n};\n\nint main() {\n\tint N, num;\n\tchar T[200000];\n\tint* position;\n\tint* p_position;\n\tpeople* p;\n\tstd::cin >> N;\n\tstd::cin >> T;\n\tnum = pow(3, N);\n\tposition = new int[num + 1]();\n\tp_position = new int[num + 1]();\n\tp = new people[num + 1];\n\tfor (int i = 0; i < num; i++) {\n\t\tp[i].init(N, i);\n\t\tp_position[i] = position[i] = i;\n\t}\n\tfor (int i = 0; i < 200000; i++) {\n\t\tif (T[i] == 'S') {\n\t\t\tfor (int j = 0; j < num; j++) {\n\t\t\t\tp[p_position[j]].sarusa();\n\t\t\t\tposition[p[p_position[j]].pos] = p_position[j];\n\t\t\t}\n\t\t}\n\t\telse if (T[i] == 'R') {\n\t\t\tfor (int j = 0; j < num; j++) {\n\t\t\t\tp[p_position[j]].rumba();\n\t\t\t\tposition[p[p_position[j]].pos] = p_position[j];\n\t\t\t}\n\t\t}\n\t\telse break;\n\n\t\tmemcpy(p_position, position, sizeof(int) * num);\n\n\t}\n\tfor (int j = 0; j < num - 1; j++) {\n\t\tstd::cout << p[j].pos << \" \";\n\t}\n\tstd::cout << p[num - 1].pos << std::endl;\n\n\n\tdelete[]p;\n\tdelete[]position;\n\tdelete[]p_position;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nstatic inline char CH()\n{\n  static char buf[100000],*ptr1=buf,*ptr2=buf;\n  return ptr1==ptr2&&(ptr2=(ptr1=buf)+fread(buf,1,100000,stdin),ptr1==ptr2)?EOF:*ptr1++;\n}\nstatic inline int IN(void)\n{\n  int x=0,f=0,c=CH();while(c<48||c>57){f^=c==45,c=CH();}\n  while(c>47&&c<58){x=x*10+c-48,c=CH();}return f?-x:x;\n}\nstatic inline int Pow(int a,int b){return b?Pow(a*a,b>>1)*(b&1?a:1):1;}\nint main()\n{\n  int N=IN(),now,len=0,pw3=Pow(3,N),x=Pow(3,N>>1),y=Pow(3,N-(N>>1)),A[1000001],B[600001];\n  char c=CH(),T[1000001],S[1000001];\n  rep(i,pw3)B[i]=B[i/3]*3+(3-i%3)%3;\n  while(c!=EOF){if(c==10){c=CH();}T[len++]=c,c=CH();}\n  rep(i,x)\n  {\n    int temp=i;now=0;\n    rep(j,len)\n    {\n      if(T[j]=='S'){temp=B[temp];(S[now]=='S')?--now:S[++now]='S';}\n      else{++temp;if(temp==x)S[++now]='R',temp=0;}\n    }\n    rep(j,y)\n    {\n      int keep=j;\n      rep(k,now)\n      {\n        if(S[k+1]=='S')keep=B[keep];\n        else if(S[k+1]=='R'){if((++keep)==y)keep=0;A[i+j*x]=temp+keep*x;}\n      }\n    }\n  }\n  rep(i,pw3)printf(\"%d%c\",A[i],i+1==pw3?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nstatic inline char CH()\n{\n  static char buf[100000],*ptr1=buf,*ptr2=buf;\n  return ptr1==ptr2&&(ptr2=(ptr1=buf)+fread(buf,1,100000,stdin),ptr1==ptr2)?EOF:*ptr1++;\n}\nstatic inline int IN(void)\n{\n  int x=0,f=0,c=CH();while(c<48||c>57){f^=c==45,c=CH();}\n  while(c>47&&c<58){x=x*10+c-48,c=CH();}return f?-x:x;\n}\nstatic inline int Pow(int a,int b){return b?Pow(a*a,b>>1)*(b&1?a:1):1;}\nint main()\n{\n  int N=IN(),now,len=0,pw3=Pow(3,N),x=Pow(3,N>>1),y=Pow(3,N-(N>>1)),A[1000001],B[600001];\n  char c=CH(),T[1000001],S[1000001];\n  rep(i,pw3)B[i]=B[i/3]*3+(3-i%3)%3;\n  while(c!=EOF){if(c==10){c=CH();}T[1+len++]=c,c=CH();}\n  rep(i,x)\n  {\n    int temp=i;now=0;\n    rep(j,len)\n    {\n      if(T[j+1]=='S'){temp=B[temp];(S[now]=='S')?--now:S[++now]='S';}\n      else{++temp;if(temp==x)S[++now]='R',temp=0;}\n    }\n    rep(j,y)\n    {\n      int keep=j;\n      rep(k,now)\n      {\n        if(S[k+1]=='S')keep=B[keep];\n        else if(S[k+1]=='R')if((++keep)==y)keep=0;\n        A[i+j*x]=temp+keep*x;\n      }\n    }\n  }\n  rep(i,pw3)printf(\"%d%c\",A[i],i+1==pw3?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region Modefs\n#define retword \"-1\"\nconstexpr long long MAXCOMB = 202020;\nconstexpr long long MOD = 1000000007;\nconstexpr long double EPS = 1e-9;\n#pragma endregion\n//--MACROS---------------------------------\n#pragma region Macros\n#include <bits/stdc++.h>\n#define SORT(x) sort((x).begin(), (x).end())\n#define RSORT(x) sort((x).rbegin(), (x).rend())\n#define ALL(x) (x).begin(), (x).end()\n#define REV(x) reverse(ALL(x))\n#define rep(i, n) for (ll i = 0; i < n; i++)\n#define reps(i, m, n) for (ll i = m; i < n; i++)\n#define repr(i, m, n) for (ll i = m; i >= n; i--)\n#define SP << \" \" <<\n#define lwb(x,n) distance(x.begin(),lower_bound(ALL(x),(n)))\n#define upb(x,n) distance(x.begin(),upper_bound(ALL(x),(n)))\n#define fora(i, ...) if(ll i = -1) for(__VA_ARGS__) if(i++, true)\n#ifdef _MY_DEBUG\n#define isdebug true\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define debug_1(x1) cout<<#x1<<\": \"<<x1<<endl\n#define debug_2(x1,x2) cout<<#x1<<\": \"<<x1<<\", \"#x2<<\": \"<<x2<<endl\n#define debug_3(x1,x2,x3) cout<<#x1<<\": \"<<x1<<\", \"#x2<<\": \"<<x2<<\", \"#x3<<\": \"<<x3<<endl\n#define debug_4(x1,x2,x3,x4) cout<<#x1<<\": \"<<x1<<\", \"#x2<<\": \"<<x2<<\", \"#x3<<\": \"<<x3<<\", \"#x4<<\": \"<<x4<<endl\n#define de(...) CHOOSE((__VA_ARGS__,debug_4,debug_3,debug_2,debug_1,~))(__VA_ARGS__)\n#else\n#define isdebug false\n#define de(...)\n#endif\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconstexpr ll INF2 = 1000000000000000037;\nconstexpr ll INF = 1000000007;\nconstexpr ld PI = 3.1415926535897932384626433832795028L;\nusing P  = pair<ll,ll>;\nusing TP  = tuple<ll,ll,ll>;\nll intpow(ll a, ll b){ ll ans = 1; while(b){ if(b & 1) ans *= a; a *= a; b /= 2; } return ans; }\nll overmul(ll a, ll b){ return (b?(a>=INF2/b?INF2:a*b):0LL);}\ntemplate<class T = ll> using v = vector<T>;\ntemplate<class T = ll> using vv = vector<vector<T>>;\ntemplate<class T = ll> using vvv = vector<vector<vector<T>>>;\ntemplate<class T> bool maxi(T &a, const T &b){ if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> bool mini(T &a, const T &b){ if(b<a){a=b;return 1;}return 0;}\ntemplate<class T> T sumer(const vector<T>& a){ return accumulate(ALL(a),(T)0); }\ntemplate<class T> T miner(const vector<T>& a){ return *min_element(ALL(a)); }\ntemplate<class T> T maxer(const vector<T>& a){ return *max_element(ALL(a)); }\ntemplate<class T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class T> ll bs(ll ok, ll ng, T checker){\n    while( abs(ok-ng)>1 ){ ll mid = (ok+ng)/2; (checker(mid)?ok:ng) = mid; }\n    return ok;\n}\ntemplate<class T> ld bs2(ld ok, ld ng, T checker){\n    rep(i,300){ ld mid = (ok+ng)/2; (checker(mid)?ok:ng) = mid; }\n    return ok;\n}\ntemplate<class T> ll UNIQ(vector<T> &a){ SORT(a);a.erase(unique(ALL(a)),a.end()); return a.size();}\ntemplate<class T, class U> ostream &operator<<(ostream &os, const pair<T,U> &pe) { os << pe.first << \" \" << pe.second; return os;}\ntemplate<class T> ostream &operator<<(ostream &os, const v<T> &ve) { rep(i,ve.size()) os<< (i?\" \":\"\")<<ve[i]; return os;}\nll topbit(ll a) { return a==0?-1:63-__builtin_clzll(a);}\nll botbit(ll a) { return a==0?64:__builtin_ctzll(a);}\nll popcount(ll a) { return __builtin_popcountll(a);}\n#define dame do {cout<< retword <<\"\\n\"; return;} while(false)\ntemplate< int mod >\nstruct ModInt {\n    ll x;\n    ModInt() : x(0) {}\n    ModInt(ll y) : x(y >= 0 ? ( y<mod ? y : y%mod ) : (mod - (-y) % mod) % mod) {}\n    ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= mod) x -= mod;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &p) {\n        if((x += mod - p.x) >= mod) x -= mod;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &p) {\n        x = (int) (1LL * x * p.x % mod);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &p) {\n        *this *= p.inv();\n        return *this;\n    }\n    ModInt operator-() const { return ModInt(-x); }\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n    bool operator==(const ModInt &p) const { return x == p.x; }\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n    bool operator<(const ModInt &p) const {return x < p.x; }\n\n    ModInt operator+(const ll &q) const {return ModInt(*this) += (ModInt)q; }\n    ModInt operator-(const ll &q) const {return ModInt(*this) -= (ModInt)q; }\n    ModInt operator*(const ll &q) const {return ModInt(*this) *= (ModInt)q; }\n    ModInt operator/(const ll &q) const {return ModInt(*this) /= (ModInt)q; }\n    bool operator==(const ll &q) const {return x == q; }\n    bool operator!=(const ll &q) const {return x != q; }\n\n    ModInt operator++(){ if(++x == mod) x = 0; return *this; }\n    ModInt operator--(){ x = (x == 0 ? mod-1 : x-1); return *this; }\n    ModInt operator++(int){ const ModInt res(*this); ++*this; return res; }\n    ModInt operator--(int){ const ModInt res(*this); --*this; return res; }\n\n    ModInt inv() const {\n        int a = x, b = mod, u = 1, v = 0, t;\n        while(b > 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt(u);\n    }\n\n    ModInt pow(ll n, bool inv=false) const {\n        ModInt ret(1), mul(x);\n        while(n > 0) {\n        if(n & 1) ret *= mul;\n            mul *= mul;\n            n >>= 1;\n        }\n        if(inv) ret=ret.inv();\n        return ret;\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt &p) {\n        return os << p.x;\n    }\n    friend istream &operator>>(istream &is, ModInt &a) {\n        ll t;\n        is >> t;\n        a = ModInt< mod >(t);\n        return (is);\n    }\n};\nusing mint = ModInt< MOD >;\nmint mpow(ll x, ll n, bool inv=false) {\n    mint ret(1), mul(x);\n    while(n > 0) {\n    if(n & 1) ret *= mul;\n        mul *= mul;\n        n >>= 1;\n    }\n    if(inv) ret=ret.inv();\n    return ret;\n}\nmint fac[MAXCOMB], finv[MAXCOMB], inv[MAXCOMB];\nvoid cinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    reps(i, 2, MAXCOMB){\n        fac[i] = fac[i - 1] * i;\n        inv[i] = inv[MOD%i] * -(MOD/i);\n        finv[i] = finv[i - 1] * inv[i];\n    }\n}\nmint cmb(int n, int k){ // 二項係数計算\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * finv[k] * finv[n-k];\n}\n#pragma endregion\n//--GLOBAL---------------------------------\nll N;\nll pwr3;\nv<> anss(1010101);\nv<> curd(1010101);\nv<> ansd(1010101);\n\nstring reduct(string T) {\n\tstring ans;\n\tfor (char ch : T) {\n\t\tif (ch == 'R') {\n\t\t\tans += ch;\n\t\t} else if (!ans.empty() && ans.back() == 'S') {\n\t\t\tans.pop_back();\n\t\t} else {\n\t\t\tans += ch;\n\t\t}\n\t}\n\treturn ans;\n}\n \nvoid putans() {\n\tint from = 0, to = 0;\n\trepr(i,N-1,0) {\n\t\tfrom = from * 3 + curd[i];\n\t\tto = to * 3 + ansd[i];\n\t}\n\tanss[from] = to;\n}\n \nvoid solve(int digit, string T) {\n\tif (digit == N) return putans();\n \n\tfor (int d : {0, 1, 2}) {\n\t\tint now = d;\n\t\tstring nt;\n\t\tfor (char c : T) {\n\t\t\tif (c == 'S') {\n\t\t\t\tnt += c;\n\t\t\t\tif(now) now= 3-now;\n\t\t\t}\n            else{\n\t\t\t\t++now;\n\t\t\t\tif (now == 3) {\n\t\t\t\t\tnt += c;\n\t\t\t\t\tnow = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcurd[digit] = d; // メモ化状態\n\t\tansd[digit] = now;\n\t\tsolve(digit + 1, reduct(nt));\n\t}\n}\n//--MAIN-----------------------------------\nvoid Main() {\n    cin>>N;\n    pwr3=intpow(3,N);\n    string T; cin>>T;\n    T=reduct(T);\n    solve(0,T);\n    rep(i,pwr3){\n        cout<< anss[i] <<\" \";\n    }\n    cout<<\"\\n\";\n}\n//--START----------------------------------\nint main() {\n    cin.tie(nullptr); ios_base::sync_with_stdio(false);\n    // if(isdebug) {ifstream in(\"input.txt\"); cin.rdbuf(in.rdbuf());}\n    // if(isdebug) {ofstream out(\"output.txt\"); cout.rdbuf(out.rdbuf());}\n    cout << fixed << setprecision(15);\n    // ll Qkai; cin>>Qkai; rep(QQ,Qkai) Main();\n    Main();\n}\n//-----------------------------------------"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <string>\n#include <algorithm>\n#include <utility>\n#define llint long long\n#define inf 1e18\n#define rep(x, s, t) for(llint (x) = (s); (x) < (t); (x)++)\n#define Rep(x, s, t) for(llint (x) = (s); (x) <= (t); (x)++)\n#define chmin(x, y) (x) = min((x), (y))\n#define chmax(x, y) (x) = max((x), (y))\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nllint n;\nstring s;\nllint beki[15];\nllint carry[200005];\nllint dest[600005], ndest[600005];\nset<llint> S[3];\n\nint main(void)\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n;\n\tcin >> s;\n\t\n\tbeki[0] = 1;\n\tfor(int i = 1; i < 15; i++) beki[i] = beki[i-1] * 3;\n\t\n\tfor(int i = 0; i < 3; i++){\n\t\tllint p = i;\n\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\tif(s[j] == 'R'){\n\t\t\t\tif(p == 2) carry[j] = i;\n\t\t\t\tp = (p+1) % 3;\n\t\t\t}\n\t\t\telse p = (3-p)%3;\n\t\t}\n\t\tdest[i] = p;\n\t}\n\t\n\tfor(int i = 1; i < n; i++){\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tS[j].clear();\n\t\t\tfor(int k = 0; k < beki[i]; k++){\n\t\t\t\tS[j].insert(j*beki[i]+k);\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\tif(s[j] == 'S') swap(S[1], S[2]);\n\t\t\telse{\n\t\t\t\tllint tmp[3];\n\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\tfor(int l = 0; l < 3; l++){\n\t\t\t\t\t\tllint x = l*beki[i]+carry[j];\n\t\t\t\t\t\tif(S[k].count(x)){\n\t\t\t\t\t\t\ttmp[k] = x;\n\t\t\t\t\t\t\tif(k == 2) carry[j] = x;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\tS[k].erase(tmp[k]);\n\t\t\t\t\tS[(k+1)%3].insert(tmp[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tfor(auto it = S[j].begin(); it != S[j].end(); it++){\n\t\t\t\tndest[*it] = dest[*it%beki[i]] + j*beki[i];\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < beki[i+1]; j++) dest[j] = ndest[j];\n\t}\n\t\n\tfor(int i = 0; i < beki[n]; i++) cout << dest[i] << \" \"; cout << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "        #include <bits/stdc++.h>\n        using namespace std;\n   #define int long long\nconst int MAX = 510000;\nconst int MOD = 1000000007;\n\n     signed main(){\n int n;\n string t;\n cin>>n>>t;\n int al2[t.size()]={};\n set<int> x[3];int y[3];\n int k=3;\n int kk=1;for(int i=0;i<n;i++)kk*=3;\n int ans[kk]={};\n\n for(int i=0;i<n;i++){\n      x[0].clear();\n      x[1].clear();\n      x[2].clear();\n   for(int j=0;j<k;j++)x[j/(k/3)].insert(j);\n   y[0]=0;y[1]=1;y[2]=2;\n   for(int j=0;j<t.size();j++){\n        if(t[j]=='S'){swap(y[1],y[2]);continue;}\n        int h[3];\n        for(int q=0;q<3;q++){\n             for(int p=0;p<3;p++){\n                  auto it=x[y[q]].find(al2[j]+p*k/3);\n                  if(it!=x[y[q]].end()){\n                       h[q]=al2[j]+p*k/3;\n                       x[y[q]].erase(it);\n                       break;\n                       \n\n                  }\n             }\n        }\n        for(int q=0;q<3;q++)x[y[(q+1)%3]].insert(h[q]);\n        al2[j]=h[2];\n   }\ncontinue;\n   for(int j=0;j<kk;j++){\n        for(int q=0;q<3;q++){\n          auto it=x[y[q]].find(j%k);\n          if(it!=x[y[q]].end())ans[j]+=q*(k/3);\n        }\n   }\n   k*=3;\n\n }\n for(int i=0;i<kk;i++)cout<<ans[i]<<' ';\n\n\n\n\n\n\n    }\n\n\n\n\n\n      \n\n        \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nusing namespace std;\n\nint n;\nstring s;\n\npair<vector<int>, vector<int> > solve(vector<int> last_p, vector<int> last_w)\n{\n    vector<int> p(3 * last_p.size()), w;\n    int n = last_p.size();\n\n    /*vector<int> d(3 * last_p.size());\n    for (int i = 0; i < n; i++) d[i] = 0;\n    for (int i = n; i < 2 * n; i++) d[i] = 1;\n    for (int i = 2 * n; i < 3 * n; i++) d[i] = 2;\n\n    for (int i = 0; i < s.size(); i++)\n    {\n        int x = last_w[i];\n        if (d[x] == 2) w.push_back(x);\n        if (d[n + x] == 2) w.push_back(n + x);\n        if (d[2 * n + x] == 2) w.push_back(2 * n + x);\n        if (s[i] == 'S')\n        {\n            for (int j = 0; j < d.size(); j++) d[j] = (3 - d[j]) % 3;\n        }\n        else\n        {\n            int x = last_w[i];\n            d[x] = (d[x] + 1) % 3;\n            d[n + x] = (d[n + x] + 1) % 3;\n            d[2 * n + x] = (d[2 * n + x] + 1) % 3;\n        }\n    }*/\n\n    set<int> d0, d1, d2;\n    for (int i = 0; i < n; i++) d0.insert(i);\n    for (int i = n; i < 2 * n; i++) d1.insert(i);\n    for (int i = 2 * n; i < 3 * n; i++) d2.insert(i);\n\n    for (int i = 0; i < s.size(); i++)\n    {\n        int x = last_w[i];\n        vector<int> q = {x, x + n, x + 2 * n};\n        for (auto e : q) if (d2.find(e) != d2.end()) w.push_back(e);\n        if (s[i] == 'S')\n        {\n            swap(d1, d2);\n        }\n        else\n        {\n            int f0, f1, f2;\n            for (auto e : q) if (d0.find(e) != d0.end()) f0 = e;\n            for (auto e : q) if (d1.find(e) != d1.end()) f1 = e;\n            for (auto e : q) if (d2.find(e) != d2.end()) f2 = e;\n            d0.erase(f0); d1.insert(f0);\n            d1.erase(f1); d2.insert(f1);\n            d2.erase(f2); d0.insert(f2);\n        }\n    }\n\n    for (int i = 0; i < 3 * n; i++)\n    {\n        p[i] = last_p[i % n];\n    }\n    for (auto e : d1) p[e] += n;\n    for (auto e : d2) p[e] += n + n;\n\n    return {p, w};\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n    cin >> n;\n    cin >> s;\n    vector<int> last_p = {0, 1, 2};\n    vector<int> last_w;\n    for (int i = 0; i < s.size(); i++)\n    {\n        for (int j = 0; j < 3; j++) if (last_p[j] == 2) last_w.push_back(j);\n        if (s[i] == 'S')\n        {\n            int t = 1;\n            for (int k = 0; t && k < 3; k++)\n            {\n                for (int j = 0; t && j < 3; j++)\n                {\n                    if (last_p[k] == 2 && last_p[j] == 1)\n                    {\n                        swap(last_p[k], last_p[j]);\n                        t = 0;\n                    }\n                }\n            }\n        }\n        else\n        {\n            for (int j = 0; j < 3; j++) last_p[j] = (last_p[j] + 1) % 3;\n        }\n    }\n    for (int i = 1; i < n; i++)\n    {\n        pair<vector<int>, vector<int> > gg = solve(last_p, last_w);\n        last_p = gg.first;\n        last_w = gg.second;\n    }\n    for (int i = 0; i < last_p.size(); i++)\n    {\n        cout << last_p[i] << \" \";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,count=0,p,x,y,th,P[531441],t[13]={0},TRI,pw3[13]={1};\nchar c,tmp,T[200001],del[200001];\nvoid init(void){rep(i,3*TRI)P[i]=i;}\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* p=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    p=strstr(p,before);if(p==(char*)NULL)break;const char* remain=p+szb;\n    memmove(p+sza,remain,strlen(remain)+1);\n    memcpy(p,after,sza);\n    p+=sza;\n  }\n  return s;\n}\nvoid sal(char c[])\n{\n  if(c[p]=='R'){rep(i,3*TRI){P[i]++;if(P[i]==3*TRI)P[i]=0;}return;}\n  if(c[p]=='S')rep(trit,3*TRI)\n  {\n    x=P[trit];y=0;\n    rep(i,13)\n    {\n      y++;t[i]=x%3;\n      if(t[i]==1)t[i]=2;else if(t[i]==2)t[i]=1;else t[i]=0;\n      if(x<3)break;\n      x/=3;\n    }\n    x=0;\n    rep(i,y)x+=t[i]*pw3[i];\n    if(x==3*TRI)x=0;\n    P[trit]=x;\n  }\n}\nsigned main(void)\n{\n  count=scanf(\"%d %s\",&N,T);\n  rep(i,N+1)if(i>0)pw3[i]=pw3[i-1]*3;\n  rep(i,pw3[N])del[i]='R';\n  replace(T,\"SS\",\"\");replace(T,del,\"\");\n  if(T[0]=='\\n')return 0;\n  TRI=pw3[N-1],init();count=strlen(T);\n  rep(i,count){p=i,sal(T);}\n  rep(i,3*TRI)printf(\"%d%c\",P[i],i+1==3*TRI?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint n;\nstring d[2][555555];\nint h[2][555555];\nint r[555555];\n\nint main() {\n\tcin >> n;\n\tcin >> d[0][0];\n\tint k = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint a = i%2;\n\t\tint b = 1-a;\n\t\tfor (int x = 0; x < 3; x++) {\n\t\t\tfor (int y = 0; y < k; y++) {\n\t\t\t\tint z = x*k+y;\n\t\t\t\tint u = x;\n\t\t\t\tstring s = \"\";\n\t\t\t\tfor (auto c : d[b][y]) {\n\t\t\t\t\tif (c == 'S') {\n\t\t\t\t\t\tif (u != 0) u = 3-u;\n\t\t\t\t\t\tif (s.size() && s.back() == 'S') s.pop_back();\n\t\t\t\t\t\telse s.push_back('S');\n\t\t\t\t\t}\n\t\t\t\t\tif (c == 'R') {\n\t\t\t\t\t\tu++;\n\t\t\t\t\t\tif (u == 3) {\n\t\t\t\t\t\t\tu = 0;\n\t\t\t\t\t\t\ts.push_back('R');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\td[a][z] = s;\n\t\t\t\th[a][z] = h[b][y]+u*k;\n\t\t\t\tif (i == n) cout << h[a][z] << \" \";\n\t\t\t}\n\t\t}\n\t\tk *= 3;\n\t}\n\tcout << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nclass CStrangeDance {\npublic:\n\n    int calc(vector<vector<vector<int>>>& v, int k) {\n      int w = 0;\n      if (k > 0) {\n        w = calc(v, k-1);\n      }\n      auto ret = v[2][k][w];\n\n      auto w0 = v[0][k][w];\n      auto w1 = v[1][k][w];\n      auto w2 = v[2][k][w];\n\n      v[1][k][w] = w0;\n      v[2][k][w] = w1;\n      v[0][k][w] = w2;\n      return ret;\n    }\n\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n;\n      cin >> n;\n      string t;\n      cin >> t;\n\n      // initialize vector size\n      vector<vector<vector<int>>> v(3, vector<vector<int>>(n));\n      int k = 1;\n      rep(i, n) {\n        rep(j, 3) {\n          v[j][i].resize(k);\n        }\n        k *= 3;\n      }\n      int K = k;\n\n      // initialize vector\n      rep(i, n) {\n        int idx = 0;\n        rep(j, 3) {\n          for(auto& e: v[j][i]) {\n            e = idx;\n            idx++;\n          }\n        }\n      }\n\n      for(auto c: t) {\n        if (c=='S') {\n          // swap vector\n          swap(v[1], v[2]);\n        } else {\n          // swap by point recursively\n          calc(v, n-1);\n        }\n      }\n\n      // recover\n      vector<int> ans(K);\n      k = 1;\n      rep(i, n) {\n        rep(j, 3) {\n          for(auto e: v[j][i]) {\n            for(int idx=e; idx<K; idx+=(k*3)) {\n              ans[idx] += j*k;\n            }\n          }\n        }\n        k *= 3;\n      }\n\n      for(auto e: ans) {\n        cout << e << ' ';\n      }\n      cout << endl;\n\n    }\n};\n\nsigned main() {\n  CStrangeDance solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nint n;\nconst int F[]={1,3,9,27,81,243,729,2187,6561,19683,59049,177147,531441};\nconst int N=555555;\nconst int L=13;\nchar op[N*3]={'\\0'};\nint fn[L][N*3];\nint ins[3][N*3];\nint p[N];\nint m;\nint main(){\n\tscanf(\"%d\",&n);\n\tint x=F[n];\n\tscanf(\"%s\",op);\n\tm=strlen(op);\n\tint d=0;\n\tfor(int i=0;i<m;i++){\n\t\tif(op[i]=='R'){\n\t\t\td++;\n\t\t}\n\t}\n\tint s=d+2*x;\n\tfn[0][0]=0;\n\tfor(int i=1;i<s;i++){\n\t\tfn[0][i]=i;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\t// cerr<<\"n=\"<<i<<endl;\n\t\tbool qaq=false;\n\t\tint it=0;\n\t\tfor(int k=0;k<3;k++){\n\t\t\tfor(int j=0;j<F[i-1];j++){\n\t\t\t\tins[k][j]=k*F[i-1]+j;\n\t\t\t\t// cerr<<ins[k][j]<<endl;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;;j++){\n\t\t\tif(j>=m||op[j]=='R'){\n\t\t\t\tint a=F[i]+it;\n\t\t\t\tif(a>=s){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tint f=qaq?k==1?2:k==2?1:0:k;\n\t\t\t\t\t// cerr<<f<<\" << \"<<a<<endl;\n\t\t\t\t\tif(F[i-1]+it<s)ins[f][F[i-1]+it]=a;\n\t\t\t\t\ta=ins[f][fn[i-1][it]];\n\t\t\t\t\t// cerr<<f<<\" >> \"<<a<<endl;\n\t\t\t\t}\n\t\t\t\t// cerr<<\"it=\"<<it<<\" \"<<a<<endl;\n\t\t\t\tfn[i][it]=a;\n\t\t\t\tit++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tqaq^=1;\n\t\t\t}\n\t\t}\n\t}\n\tstack<int> ans;\n\tfor(int i=0;i<x;i++){\n\t\tins[0][i]=i;\n\t}\n\tfor(int i=0;i<d+x;i++){\n\t\tint out=ins[0][fn[n][i]];\n\t\tif(i+x<s){\n\t\t\tins[0][i+x]=out;// pipe\n\t\t}\n\t\tans.push(out);\n\t}\n\tfor(int i=0;i<x;i++){\n\t\tp[ans.top()]=i;\n\t\tans.pop();\n\t}\n\tfor(int i=0;i<x;i++){\n\t\tprintf(\"%d \",p[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 100000007\nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nint n,m,len,i,j,x,a[1000005],book[1000005],vis[1000005],sum;\nchar s[200005];\nint main(){\n\t//freopen(\"domino.in\",\"r\",stdin);\n\t//freopen(\"domino.out\",\"w\",stdout);\n\tn=read();\n\tscanf(\"%s\",s+1);\n\tlen=strlen(s+1);\n\tm=1;\n\tfor(i=1;i<=n;i++)\n\t\tm*=3;\n\tfor(i=0;i<m;i++){\n\t\tsum=0;\n\t\tfor(j=1;j<=i;j*=3)\n\t\t\tif(i/j%3!=0)\n\t\t\t\tsum+=(3-i/j%3)*j;\n\t\tvis[i]=sum;\n\t}\n\tfor(i=1;i<m;i++)\n\t\ta[i]=i;\n\tfor(i=0;i<m;i++){\n\t\tx=i;\n\t\tfor(j=1;j<=len;j++){\n\t\t\tif(s[j]=='R')\n\t\t\t\tx=(x+1)%m;\n\t\t\telse\n\t\t\t\tx=vis[x];\n\t\t}\n\t\tpus(x,1);\n\t}\n\tcout<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar T[550005];\n\n// Based on editorial solution\nint D[13][550005]; // one digit at a time, with digit 0 representing the ones place\nint W[13][550005];\nint lastUpdated[13][550005];\n\ninline void putInt(int i){\n    if(i==0){putchar_unlocked('0');}\n    else{\n    int x[11];\n    int count1=0;\n    while(i>0){\n        x[count1++]=i%10;\n        i/=10;\n    }\n    for(int j=count1-1;j>=0;j--){\n        putchar_unlocked(48+x[j]);\n    }\n    }\n    putchar_unlocked(' ');\n}\n\nint N;\n\nvoid update(int n, int indx, int cntS){\n    if((cntS&1) != (lastUpdated[n][indx]&1)){\n        // conduct salsa\n        if(D[n][indx] == 1){\n            D[n][indx] = 2;\n        }else if(D[n][indx] == 2){\n            D[n][indx] = 1;\n        }\n    }\n    // updated the lastUpdated index\n    lastUpdated[n][indx] = cntS;\n}\n\nint pow3[16];\n\nint main(){\n    scanf(\"%d\", &N);\n\n    scanf(\" %s\", T);\n\n    int M = strlen(T);\n\n    pow3[0] = 1;\n    for(int i = 1; i <= N; i ++){\n        pow3[i] = pow3[i-1]*3;\n    }\n\n    int pow3N = pow3[N];\n\n    //printf(\"ok\");\n    memset(W, 0, sizeof(W));\n    for(int n = 1; n <= N; n ++){\n        //printf(\"ok\");\n        for(int j = 0; j < pow3[N]; j ++){\n            D[n][j] = (j%pow3[n])/pow3[n-1];\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        W[n][0] = pow3[n]-1;\n    }\n\n\n    memset(lastUpdated, 0, sizeof(lastUpdated));\n    int cntS2 = 0;\n    for(int n = 1; n <= N; n ++){\n        int cntS = 0;\n        for(int i = 0; i < M; i ++){\n            int indx0 = W[n-1][i];\n            int indx1 = W[n-1][i]+pow3[n-1];\n            if(indx1 >= pow3[n]){\n                indx1 -= pow3[n];\n            }\n            int indx2 = W[n-1][i]+(pow3[n-1]<<1);\n            if(indx2 >= pow3[n]){\n                indx2 -= pow3[n];\n            }\n\n            update(n, indx0, cntS+(T[i]=='S'));\n            update(n, indx1, cntS+(T[i]=='S'));\n            update(n, indx2, cntS+(T[i]=='S'));\n            if(D[n][indx0] == 2){\n                W[n][i] = indx0;\n            }else if(D[n][indx1] == 2){\n                W[n][i] = indx1;\n            }else{\n                W[n][i] = indx2;\n            }\n\n            if(T[i] == 'R'){\n                D[n][indx0] = (D[n][indx0]+1);\n                D[n][indx1] = (D[n][indx1]+1);\n                D[n][indx2] = (D[n][indx2]+1);\n                if(D[n][indx0] == 3){D[n][indx0] = 0;}\n                if(D[n][indx1] == 3){D[n][indx1] = 0;}\n                if(D[n][indx2] == 3){D[n][indx2] = 0;}\n                lastUpdated[n][indx0] = cntS;\n                lastUpdated[n][indx1] = cntS;\n                lastUpdated[n][indx2] = cntS;\n            }else if(T[i] == 'S'){\n                cntS ++;\n            }\n\n            //printf(\"W[%d][%d]=%d\\n\", n, i+1, W[n][i+1]);\n        }\n\n        cntS2 = cntS;\n    }\n\n    for(int n = 1; n <= N; n ++){\n        for(int i = 0; i < pow3[n]; i ++){\n            update(n, i, cntS2);\n        }\n    }\n\n    for(int i = 0; i < pow3[N]; i ++){\n        int temp = 0;\n        for(int n = 1; n <= N; n ++){\n            temp += D[n][i%pow3[n]]*pow3[n-1];\n        }\n        putInt(temp);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cassert>\n#include<stdexcept>\n#include<utility>\n#include<functional>\n#include<numeric>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<array>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<complex>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<bitset>\n#include<memory>\nusing namespace std;\nusing ll=long long;\n\nconst int SZ = 1;\nint n;\nint pow3n;\nvector<int> sal;\nvoid init_s(){\n    sal.resize(pow3n);\n    iota(sal.begin(),sal.end(),0);\n    for(int i=0;i<pow3n;i++){\n        int x = i;\n        int tar = 0;\n        int r = 1;\n        for(int j=0;j<n;j++){\n            tar+= (x%3*2)%3*r;\n            x/=3;\n            r*=3;\n        }\n        if(tar<i){\n            // cerr<<i<<\" \"<<tar<<endl;\n            swap(sal[tar],sal[i]);\n        }\n    }\n}\n\n\nvoid do_r(vector<int>& pat){\n    int head = pat[pow3n-1];\n    for(int i=pow3n-1;i>0;i--){\n        pat[i]=pat[i-1];\n    }\n    pat[0] = head;\n}\nint ary[100000];\nvoid perm(vector<int>& pat,vector<int>& par){\n    for(int i=0;i<pow3n;i++) ary[i] = pat[par[i]];\n    for(int i=0;i<pow3n;i++) pat[i] = ary[i];\n}\nvoid do_s(vector<int>& pat){\n    perm(pat,sal);\n}\nint main(){\n    cin>>n;\n    pow3n=1;\n    for(int i=0;i<n;i++) pow3n*=3;\n    init_s();\n    \n    string t;\n    {\n        string tmp;\n        cin>>tmp;\n        for(auto c:tmp){\n            if(!t.empty() && t.back()=='S' && c=='S') t.pop_back();\n            else t+=c;\n        }\n    }\n\n    vector<vector<int>> memo(1<<SZ);\n    \n    for(int bit=0;bit<(1<<SZ);bit++){\n        bool ispass= false;\n        for(int j=0;j+1<SZ;j++){\n            if(((bit>>j)&1)==0 && ((bit>>(j+1)))==0) ispass=true;\n        }\n        if(ispass) continue;\n\n        memo[bit].resize(pow3n);\n        iota(memo[bit].begin(),memo[bit].end(),0);\n        for(int j=0;j<SZ;j++){\n            if(((bit>>j)&1)==0) do_s(memo[bit]);\n            else do_r(memo[bit]);\n        }\n    }\n    vector<int> res(pow3n);\n    iota(res.begin(),res.end(),0);\n    \n    for(int i=0;i<t.size()/SZ;i++){\n        int bit = 0;\n        for(int j=0;j<SZ;j++){\n            if(t[i*SZ+j]=='R') bit+=(1<<j);\n        }\n        // cerr<<\"#\"<<i<<endl;\n        // for(int i=0;i<pow3n;i++) cerr<<res[i]<<\" \";\n        // cerr<<endl;\n        // for(int i=0;i<pow3n;i++) cerr<<memo[bit][i]<<\" \";\n        // cerr<<endl;\n        perm(res,memo[bit]);\n        // for(int i=0;i<pow3n;i++) cerr<<res[i]<<\" \";\n        // cerr<<endl;\n    }\n\n    for(int i=t.size()/SZ*SZ;i<t.size();i++){\n        // cerr<<\"#\"<<endl;\n        if(t[i]=='S') do_s(res);\n        else do_r(res);\n    }\n    vector<int> inv(pow3n);\n    for(int i=0;i<pow3n;i++) inv[res[i]]=i;\n    for(int i=0;i<pow3n;i++) cout<<inv[i]<<\" \";\n    cout<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 13;\nconst int siz = 55e4+100;\n#define fr(i,a,b) for(int i = a;i <= b; ++i)\n#define nfr(i,a,b) for(int i = a;i >= b; --i)\n\nint d[N][siz],a[N][siz],w[N][siz];\nint tag[N][siz];\nint n,m;\nchar ch[siz];\nint main(){\n   scanf(\"%d\",&n);\n   scanf(\"%s\",ch+1);\n   m = strlen(ch+1);\n\n   a[0][0] = 0;\n   fr(i,0,m)w[0][i] = 0;\n\n   int cur = 1;\n   fr(i,1,n){\n      cur *= 3;\n      w[i][0] = cur-1;\n      fr(j,0,cur-1)d[i][j] = j/(cur/3);\n\n      int tg = 0;\n      fr(j,1,m){\n         if(ch[j] == 'S'){\n            tg ^= 1;\n            int p = w[i-1][j-1];\n            fr(k,0,2){\n               if(d[i][p+k*(cur/3)] == 0){\n                  tag[i][p+k*(cur/3)] = tg;\n                  continue ;\n               }\n               d[i][p+k*(cur/3)] ^= 3*(tag[i][p+k*(cur/3)]^tg);\n               tag[i][p+k*(cur/3)] = tg;\n            }\n         } else {\n            int p = w[i-1][j-1];\n            fr(k,0,2){\n               if(d[i][p+k*(cur/3)] != 0)\n                  d[i][p+k*(cur/3)] ^= 3*(tag[i][p+k*(cur/3)]^tg);\n               tag[i][p+k*(cur/3)] = tg;\n\n               d[i][p+k*(cur/3)]++;\n               d[i][p+k*(cur/3)] %= 3;\n            }\n         }\n         \n         int p = w[i-1][j];\n         fr(k,0,2){\n            if(d[i][p+k*(cur/3)] != 0)\n               d[i][p+k*(cur/3)] ^= 3*(tag[i][p+k*(cur/3)]^tg);\n            tag[i][p+k*(cur/3)] = tg;\n\n            if(d[i][p+k*(cur/3)] == 2)\n               w[i][j] = p+k*(cur/3);\n         }\n      }\n\n      fr(j,0,cur-1){\n         if(d[i][j] == 0)continue ;\n         d[i][j] ^= 3*(tag[i][j]^tg);\n      }\n      fr(j,0,cur-1)a[i][j] = a[i-1][j%(cur/3)]+(cur/3)*d[i][j];\n   }\n\n   fr(i,0,cur-1){\n      printf(\"%d \",a[n][i]);\n   }\n   puts(\"\");\n   return 0;\n}\n/*\n2\nSRSRRSRRRSRRRR\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXN 13\n#define MAXM 550005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n;\nstring str;\nint ans[MAXM];\nint curdigit[MAXN],curres[MAXN];\nstring reduce(string &t)\n{\n    vector<char> st;\n    string ret=\"\";\n    for(auto ch:t)\n    {\n        st.push_back(ch);\n        if(st.size()>=2&&st[(int)st.size()-1]=='S'&&st[(int)st.size()-2]=='S') st.pop_back(),st.pop_back();\n    }\n    for(auto ch:st) ret+=ch;\n    return ret;\n}\nvoid update_ans()\n{\n    int x=0,y=0;\n    for(int i=n-1;i>=0;i--)\n    {\n        x=x*3+curdigit[i];\n        y=y*3+curres[i];\n    }\n    ans[x]=y;\n}\nvoid solve(int cur,string t)\n{\n    if(cur==n) \n    {\n        update_ans();\n        return;\n    }\n    for(int d=0;d<3;d++)\n    {\n        string curt=\"\";\n        int curd=d;\n        for(auto ch:t)\n        {\n            if(ch=='S')\n            {\n                if(curd) curd=3-curd;\n                curt+='S';\n            }\n            if(ch=='R')\n            {\n                curd++;\n                if(curd==3)\n                {\n                    curd=0;\n                    curt+='R';\n                }\n            }\n        }\n        curdigit[cur]=d;\n        curres[cur]=curd;\n        solve(cur+1,reduce(curt));\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    cin>>str;\n    solve(0,reduce(str));\n    int p=1;\n    for(int i=0;i<n;i++) p=p*3;\n    for(int i=0;i<p;i++) printf(\"%d \",ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\",3,\"inline\")\n#include<bits/stdc++.h>\nusing namespace std;\n#define fir first\n#define sec second\n#define m_p make_pair\n#define y1 ygftgfgcdtfgxffgx\n#define y2 yfdsesgvtyghftfvv\n#define x1 xvyr6cf6fgcfgf676\n#define x2 xcr6rfc5r66y6r6fr\n#define up_bound upper_bound\n#define low_bound lower_bound\n#define next_per next_permutation\n#define pb push_back\n#define i_to_s to_string\ntypedef priority_queue<int> p_queue;\ntypedef priority_queue<int, vector<int>, greater<int> > min_p_queue;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nint mon[20]={31,28,31,30,31,30,31,31,30,31,30,31};\nll gcd(ll x,ll y){return ((y==0)?x:gcd(y,x%y));}\nint n;\nstring t;\nll pass[600010];\nint a[20];\nll power[20];\nll v[600010];\nvoid init(){\n\tll ans,x,pos;\n\tfor(int i=0;i<50/*600000*/;i++){\n\t\tx=i;ans=pos=0;\n\t\twhile(x){\n\t\t\ta[pos++]=(x%3);\n//\t\t\tcout<<a[pos-1]<<' ';\n\t\t\tx/=3;\n\t\t}\n\t\twhile(pos){\n\t\t\tpos--;\n\t\t\tif(a[pos]==1)ans=ans*3+2;\n\t\t\telse if(a[pos]==2)ans=ans*3+1;\n\t\t\telse ans=ans*3+a[pos];\n\t\t}\n\t\tpass[i]=ans;\n//\t\tcout<<\"    \"<<i<<' '<<ans<<'\\n';\n\t}\n\tpower[0]=1;\n\tfor(int i=1;i<15;i++){\n\t\tpower[i]=power[i-1]*3;\n\t}\n}\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tcin>>n>>t;\n\tinit();\n\tn=power[n];\n\tfor(int i=0;i<n;i++)v[i]=i;\n\tfor(int i=0;i<t.size();i++){\n//\t\tcout<<\"hi\\n\";\n//\t\tfor(int j=0;j<n;j++)cout<<v[j]<<' ';cout<<'\\n';\n//\t\tfor(int j=0;j<n;j++)u[j]=v[j];\n\t\tif(t[i]=='S'){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tv[j]=pass[v[j]];\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(v[j]<n-1)v[j]=v[j]+1;\n\t\t\t\telse v[j]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)cout<<v[i]<<' ';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,o,p,x,y,sw,pw3[13]={1},A[531441],B[531441],S[200001];\nchar T[200001];\nvoid Init(void){rep(i,pw3[o])rep(j,3)B[i+j*pw3[o]]=j;}\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nvoid Dance(char c[])\n{\n  if(c[p]==EOF)return;\n  if(c[p]=='R'){y=S[p];rep(i,3){x=y+i*pw3[o];if(B[x]+sw==2)S[p]=x;(B[x]+=sw+1)%=3;}}\n  if(c[p]=='S')sw^=1;\n}\nvoid Update(void)\n{\n  rep(i,pw3[o]){y=A[i];rep(j,3){x=i+j*pw3[o];A[x]=y+(sw?3-B[x]:B[x])%3*pw3[o];}}\n}\nsigned main(void)\n{\n  o=scanf(\"%d %s\",&N,T);\n  replace(T,\"SS\",\"\");\n  if(T[0]=='\\n')return 0;\n  rep(i,N){o=i,Init(),sw=0;rep(j,strlen(T)){p=j,Dance(T);}Update();pw3[i+1]=3*pw3[i];}\n  rep(i,pw3[N])printf(\"%d%c\",A[i],i+1==pw3[N]?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <bitset>\n#include <random>\n#include <complex>\n#include <assert.h>\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate<typename T>\ninline bool chmin(T& x, T a) {\n\tif (x >= a) { x = a; return true; }\n\treturn false;\n}\n\ntemplate<typename T>\ninline bool chmax(T& x, T a) {\n\tif (x <= a) { x = a; return true; }\n\treturn false;\n}\n\n/////////\tランレングス圧縮をして(要素, 個数)の形にする\nvoid runLengthCompression(string& src, vector<pair<char, int>>& dest) {\n\tdest.clear();\n\tint N = src.size();\n\tif (N == 0) { return; }\n\n\tint count = 1;\n\tchar temp = src[0];\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (i == N) {\n\t\t\tdest.push_back({ temp, count });\n\t\t}\n\t\telse {\n\t\t\tif (src[i] != temp) {\n\t\t\t\tdest.push_back({ temp, count });\n\t\t\t\ttemp = src[i];\n\t\t\t\tcount = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\n\tint N0; cin >> N0;\n\tint N = 1;\n\tfor (int i = 0; i < N0; i++) {\n\t\tN *= 3;\n\t}\n\n\tvector<int> a(N), ans(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tint src = i;\n\t\tint dst = 0;\n\t\tint digit = 1;\n\t\twhile (src > 0) {\n\t\t\tint k = src % 3;\n\t\t\tdst += digit * ((k * 2) % 3);\n\t\t\tsrc /= 3;\n\t\t\tdigit *= 3;\n\t\t}\n\t\ta[i] = dst;\n\t\tans[i] = i;\n\t}\n\n\tstring T; cin >> T;\n\tvector<pair<char, int>>dst;\n\trunLengthCompression(T, dst);\n\n\tfor (int i = 0; i < dst.size(); i++) {\n\t\tif (dst[i].first == 'R') {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tans[j] = (ans[j] + dst[i].second) % N;\n\t\t\t}\n\t\t}\n\t\telse if(dst[i].second % 2 == 1){\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tans[j] = a[ans[j]];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n\t\tcout << ans[i] << \" \";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(long long i=0;i<(long long)N;i++)\nint N,o,p,x,y,pos,tri0,tri1,tri2,pw3[13]={1},A[1000001],salsa[531441];\nchar T[200001],sw[1000001];\nvoid OUT(long long x){if(x<0)putchar('-'),x=-x;if(x>=10)OUT(x/10);putchar(x%10+48);}\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nvoid Dance(char c[])\n{\n  if(c[p]==EOF)return;\n  if(c[p]=='S'){x=salsa[x];if(sw[pos]=='s')pos--;else sw[++pos]='s';}\n  if(c[p]=='R'){x++;if(x==tri1)sw[++pos]='r',x=0;}\n}\nvoid Update(void)\n{\n  rep(i,tri2)\n  {\n    y=i;\n    rep(j,pos){if(sw[j+1]=='s')y=salsa[y];else if(sw[j+1]=='r'){if((++y)==tri2)y=0;}}\n    A[o+i*tri1]=y*tri1+x;\n  }\n}\nsigned main(void)\n{\n  o=scanf(\"%d %s\",&N,T+1);\n  replace(T+1,\"SS\",\"\");if(T[0]=='\\n')return 0;\n  rep(i,N)pw3[i+1]=3*pw3[i];\n  tri0=pw3[N],tri1=pw3[N/2],tri2=pw3[N-N/2];\n  rep(i,tri0)salsa[i]=salsa[i/3]*3+(3-i%3)%3;\n  rep(i,tri1){o=i,x=i,pos=0;rep(j,strlen(T+1)){p=j+1,Dance(T);}Update();}\n  rep(i,tri0)OUT(A[i]),putchar(' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\ntemplate<typename T> vector<T> make_vector(size_t sz){\n\treturn vector<T>(sz);\n}\n\ntemplate<typename T,typename... Ts> \nauto make_vector(size_t sz, Ts... ts){\n\treturn vector<decltype(make_vector<T>(ts...))>(sz, make_vector<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V> \ntypename enable_if<is_same<T, U>::value!=0>::type \nfill_value(U &u, const V... v){\n\tu=U(v...);\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_value(U &u, const V... v){\n\tfor(auto &e:u){\n\t\tfill_value<T>(e,v...);\n\t}\n}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\n\n\nvector<int> ans;\n\nstring compress(const string &t) {\n\tstring ret = \"\";\n\n\tfor(auto &elem: t) {\n\t\tif (elem == 'R') {\n\t\t\tret += elem;\n\t\t} else {\n\t\t\tif(ret.size() and ret.back() == 'S') {\n\t\t\t\tret.pop_back();\n\t\t\t} else {\n\t\t\t\tret += elem;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret; \n}\n\nint n, fd[12], td[12];\n\nvoid rec(int digit, string t) {\n\tif(digit == n) {\n\t\tint from = 0, to = 0;\n\t\trrep(i, n) {\n\t\t\tfrom = 3 * from + fd[i];\n\t\t\tto = 3 * to + td[i];\n\t\t}\n\t\tans[from] = to;\n\t\treturn;\n\t}\n\n\n\trep(d, 3) {\n\t\tint cur_d = d;\n\n\t\tstring nxt_t = \"\";\n\t\tfor(auto &elem: t) {\n\t\t\tif(elem == 'S') {\n\t\t\t\tcur_d = (3 - cur_d) % 3;\n\t\t\t\tnxt_t += elem;\n\t\t\t} else {\n\t\t\t\tcur_d++;\n\t\t\t\tif(cur_d == 3) {\n\t\t\t\t\tnxt_t += elem;\n\t\t\t\t\tcur_d = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfd[digit] = d;\n\t\ttd[digit] = cur_d;\n\t\trec(digit + 1, compress(nxt_t));\n\t}\n}\n\nint main(void){\n\tcin >> n;\n\tint all = 1;\n\trep(loop, n) all *= 3;\n\n\tans = vector<int>(all);\n\n\tstring t;\n\tcin >> t;\n\n\trec(0, compress(t));\n\n\trep(i, all) cout << (i?\" \":\"\") << ans[i];\n\tcout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nstatic inline int Pow(int a,int b){return b?Pow(a*a,b>>1)*(b&1?a:1):1;}\nint main()\n{\n  int N,now,len=0,A[1000001],B[600001];\n  char T[1000001],S[1000001];\n  now=scanf(\"%d %s\",&N,T);len=strlen(T);\n  int pw3=Pow(3,N),x=Pow(3,N>>1),y=Pow(3,N-(N>>1));\n  rep(i,pw3)B[i]=B[i/3]*3+(3-i%3)%3;\n  rep(i,x)\n  {\n    int temp=i;now=0;\n    rep(j,len)\n    {\n      if(T[j]=='S'){temp=B[temp];if(S[now]=='S')--now;else S[++now]='S';}\n      else{++temp;if(temp==x)S[++now]='R',temp=0;}\n    }\n    rep(j,y)\n    {\n      int keep=j;\n      rep(k,now)\n      {\n        if(S[k+1]=='S')keep=B[keep];\n        else if(S[k+1]=='R')if((++keep)==y)keep=0;\n        A[i+j*x]=temp+keep*x;\n      }\n    }\n  }\n  rep(i,pw3)printf(\"%d%c\",A[i],i+1==pw3?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1000000 + 10;\nint a[N],b[N],mark[N],p[N],n,S;\nvector<int> v[N];\nchar s[N];\nvoid push(int i){\n    if(mark[i]^S){\n        mark[i] ^= 1;\n        swap(v[i][1],v[i][2]);\n    }\n}\nint main(){\n    scanf(\"%d%s\",&n,s);\n    p[0] = 1; for(int i=1;i<12;i++) p[i] = p[i-1] * 3;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<p[i];j++) v[j] = {0,1,2};\n        S = 0;\n        for(int j=0;s[j];j++){\n            push(b[j]);\n            int nxt = b[j] + p[i] * v[b[j]][2];\n            if(s[j]=='S') S ^= 1;\n            else{\n                swap(v[b[j]][1],v[b[j]][2]), swap(v[b[j]][0],v[b[j]][1]);\n            }\n            b[j] = nxt;\n        }\n        for(int j=0;j<p[i];j++) push(j), mark[j] = 0;\n        for(int j=0;j<p[i];j++){\n            int tmp = a[j];\n            for(int k=0;k<3;k++) a[j+p[i]*v[j][k]] = tmp+p[i]*k;\n        }\n    }\n    for(int i=0;i<p[n];i++) printf(\"%d%c\",a[i],\" \\n\"[i==p[n]-1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nconst int pw[13]={1,3,9,27,81,243,729,2187,6561,19683,59049,177147,531441};\nstatic inline void OUT(int x){if(x<0)putchar('-'),x=-x;if(x>=10)OUT(x/10);putchar(x%10+48);}\nint main(void)\n{\n  int N,len=0,carry[200000],temp[531441],A[531441],add[531441];char T[200001];\n  if(scanf(\"%d %s\",&N,T)!=0)len=strlen(T);\n  rep(i,N)\n  {\n    int flip=0;\n    memset(add,0,pw[i]*sizeof(int));\n    rep(j,len)\n    {\n      if(T[j]=='S'){flip^=1;}\n      else\n      {\n        int x=carry[j];\n        add[x]=(add[x]+(flip?2:1))%3;\n        carry[j]+=(3-add[x])%3*pw[i];\n      }\n    }\n    memcpy(temp,A,pw[i]*sizeof(int));\n    rep(c,3){rep(j,pw[i])A[c*pw[i]+j]=temp[j]+(flip?2:1)*(c+add[j])%3*pw[i];}\n  }\n  rep(i,pw[N])OUT(A[i]),putchar(' ');\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-11;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tinline long long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\tif(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nchar in[210000];\nint ret[550000];\nint ans[550000];\nint t[210000];\nint p3[20];\nint cur[550000];\nint nx[210000];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tscanf(\"%s\",in);\n\tp3[0]=1;\n\tfor(int i=1;i<14;i++)p3[i]=p3[i-1]*3;\n\tint n=strlen(in);\n\tfor(int i=0;i<a;i++){\n\t\tint at=p3[i+1]-1;\n\t\tint f=p3[i]-1;\n\t\tint cnt=0;\n\t\tfor(int j=0;j<p3[i+1];j++){\n\t\t\tcur[j]=j/p3[i];\n\t\t}\n\t\tfor(int j=0;j<n;j++){\n\t\t\t// for(int k=0;k<p3[i+1];k++){\n\t\t\t\t// if(cnt%2)printf(\"%d \",(3-cur[k])%3);\n\t\t\t\t// else printf(\"%d \",cur[k]);\n\t\t\t// }\n\t\t\t// printf(\": %d\\n\",t[j]);\n\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\tif(cur[k*p3[i]+t[j]]+cnt%2==2)\n\t\t\t\t\tnx[j]=t[j]+k*p3[i];\n\t\t\t}\n\t\t\tif(in[j]=='R'){\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tint at=t[j]%p3[i]+p3[i]*k;\n\t\t\t\t\tif(cnt%2){\n\t\t\t\t\t\tcur[at]+=2;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcur[at]++;\n\t\t\t\t\t}\n\t\t\t\t\tcur[at]%=3;\n\t\t\t\t}\n\n\t\t\t}else{\n\n\t\t\t\t// if(cnt%2==0)ks+=2;\n\t\t\t\t// else ks++;\n\t\t\t\tcnt++;\n\t\t\t\t// int to=0;\n\t\t\t\t// for(int k=0;k<=i;k++){\n\t\t\t\t\t// if(f/p3[k]%3==1)to+=p3[k]*2;\n\t\t\t\t\t// else if(f/p3[k]%3==2)to+=p3[k];\n\t\t\t\t// }\n\t\t\t\t// f=to;\n\t\t\t}\n\t\t\t\n\t\t\n\t\t}\n\n\t\tif(cnt%2){\n\t\t\tfor(int j=0;j<p3[i+1];j++){\n\t\t\t\tif(cur[j]==1)cur[j]=2;\n\t\t\t\telse if(cur[j]==2)cur[j]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<p3[a];j++){\n\n\t\t\tret[j]+=cur[j%p3[i+1]]*p3[i];\n\t\t}\n\t\tfor(int j=0;j<n;j++){\n\t\t\tt[j]=nx[j];\n\t\t}\n\t}\n\tfor(int i=0;i<p3[a];i++)ans[ret[i]]=i;\n\tfor(int i=0;i<p3[a];i++){\n\t\tif(i)printf(\" \");\n\t\tprintf(\"%d\",ret[i]);\n\t}\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define ll long long\n#define all(aaa) aaa.begin(), aaa.end()\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    string s;\n    int n;\n    cin >> n >> s;\n\n    int H[2] = {1, 1}, D[2] = {(n + 1) / 2, n / 2};\n\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < D[i]; j++) {\n            H[i] *= 3;\n        }\n    }\n    \n    vector<int> ops[2], opt[2];\n    vector<string> shorten_s(H[0]);\n    vector<int> res(H[0]);\n\n    for (int j = 0; j < 2; j++) {\n        ops[j].resize(H[j]);\n        opt[j].resize(H[j]);\n\n        for (int i = 0; i < H[j]; i++)  {\n            int x = i;\n\n            vector<int> v;\n            while (x > 0) {\n                v.push_back(x % 3);\n                x /= 3;\n            }\n\n            reverse(all(v));\n            for (int y : v) {\n                ops[j][i] *= 3;\n                if (y > 0) {\n                    y = 3 - y;\n                    ops[j][i] = ops[j][i] + y;\n                }\n            }\n\n            opt[j][i] = (i + 1) % H[j];\n        }\n    }\n    \n    // cout << opt[0][2] << \"\\n\";\n\n    for (int i = 0; i < H[0]; i++) {\n        res[i] = i;\n        for (const char &c : s) {\n            if (c == 'S') {\n                if (!shorten_s[i].empty() && shorten_s[i].back() == c) {\n                    shorten_s[i].pop_back();\n                }\n                else {\n                    shorten_s[i].push_back(c);\n                }\n                res[i] = ops[0][res[i]];\n            }\n            else {\n                res[i] = opt[0][res[i]];\n                if (res[i] == 0)\n                    shorten_s[i].push_back(c);\n            }\n        }\n    }\n\n    for (int i = 0; i < H[0] * H[1]; i++) {\n        ll ans = i / H[0];\n        for (const char &c : shorten_s[i % H[0]]) {\n            if (c == 'S') {\n                ans = ops[1][ans];\n            }\n            else {\n                ans = opt[1][ans];\n            }\n        }\n        ans = ans * H[0] + res[i % H[0]];\n        cout << ans << \" \";\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    vector<int> d23(531441);\n    vector<int> rumba(531441);\n\n    int N;\n    cin >> N;\n    N = (int)pow(3,N);\n    \n    int temp,add,now;\n    for(int i = 0 ; i < N ; i++){\n        temp = i;\n        add = 0;\n        now = 1;\n        while(temp != 0){\n            int a = temp % 3;\n            if(a == 1){\n                add += 2 * now;\n            }else if(a == 2){\n                add += now;\n            }\n            now *= 3;\n            temp /= 3;\n        }\n        d23.at(i) = add;\n    }\n\n    for(int i = 0 ; i < N ; i++){\n        rumba.at(i) = i + 1;\n    }\n    rumba.at(N - 1) = 0;\n\n\n    vector<int> hito1(531441);\n\n    for(int i = 0 ; i < N ; i++){\n        hito1.at(i) = i;\n    }\n\n\n    string _T;\n    cin >> _T;\n\n    vector<int> Tdata;\n\n    bool flag = false;\n    int cnt = 0;\n\n    for(int i = 0 ; i < _T.size() ; i++){\n        if(_T.at(i) == 'S'){\n            if(cnt != 0){\n                Tdata.push_back(cnt);\n                cnt = 0;\n            }\n            if(flag){\n                flag = false;\n            }else{\n                flag = true;\n            }\n        }else{\n            if(flag){\n                Tdata.push_back(0);\n            }\n            flag = false;\n            cnt++;\n        }\n    }\n    if(flag){\n        Tdata.push_back(0);\n    }\n    if(cnt != 0){\n        Tdata.push_back(cnt);\n    }\n\n    int tSize = Tdata.size();\n\n    //for(int i = 0 ; i < Tdata.size() ; i++){\n    //    cout << Tdata.at(i) << ' ';\n    //}\n    //return 0;\n\n    \n\n    for(int i = 0 ; i < tSize ; i++){\n        if(Tdata.at(i) == 0){\n            for(int j = 0 ; j < N ; j++){\n                hito1.at(j) = d23.at(hito1.at(j));\n            }\n        }else{\n            int a = Tdata.at(i);\n            a %= N;\n            for(int j = 0 ; j < N ; j++){\n                hito1.at(j) += a;\n                if(hito1.at(j) >= N){\n                    hito1.at(j) -= N;\n                }\n            }\n        }\n    }\n\n\n    \n    for(int i = 0 ; i < N - 1 ; i++){\n        cout << hito1.at(i) << ' ';\n    }\n    cout << hito1.at(N - 1) << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint ch[10000005][3],ed[10000005],cnt=1,ans[10000005];\nbool rev[10000005];\nchar s[200005];\nvoid pushr(int x){swap(ch[x][1],ch[x][2]);rev[x]^=1;}\nvoid pushdown(int x)\n{\n    if(!rev[x])return;\n    for(int i=0;i<=2;i++)if(ch[x][i])pushr(ch[x][i]);\n    rev[x]=0;\n}\nvoid dfs(int x)\n{\n    pushdown(x);\n    swap(ch[x][0],ch[x][2]),swap(ch[x][1],ch[x][2]);\n    if(ch[x][0])dfs(ch[x][0]);\n}\nvoid get(int x,int now,int pw)\n{\n    pushdown(x);\n    if(ed[x]!=0xffffffff)ans[ed[x]]=now;\n    if(ch[x][0])get(ch[x][0],now,pw*3);\n    if(ch[x][1])get(ch[x][1],now+pw,pw*3);\n    if(ch[x][2])get(ch[x][2],now+2*pw,pw*3);\n}\nint main()\n{\n    int n,m=1;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)m*=3;\n    memset(ed,0xff,sizeof(ed));\n    for(int i=0;i<m;i++)\n    {\n        int now=1,tmp=i;\n        for(int k=0;k<n;k++)\n        {\n            int t=tmp%3;\n            tmp/=3;\n            if(!ch[now][t])ch[now][t]=++cnt;\n            now=ch[now][t];\n        }\n        ed[now]=i;\n    }\n    scanf(\"%s\",s+1);\n    int q=strlen(s+1);\n    for(int i=1;i<=q;i++)\n    {\n        if(s[i]=='S')pushr(1);\n        else dfs(1);\n    }\n    get(1,0,1);\n    for(int i=0;i<m;i++)printf(\"%d \",ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(long long i=0;i<(long long)N;i++)\nint N,o,p,x,y,pos,pw3[13]={1},A[1000001],salsa[531441];\nchar T[200001],sw[1000001];\nvoid OUT(long long x){if(x<0)putchar('-'),x=-x;if(x>=10)OUT(x/10);putchar(x%10+48);}\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nvoid Dance(char c[])\n{\n  if(c[p]==EOF)return;\n  if(c[p]=='S'){x=salsa[x];if(sw[pos]=='s')pos--;else sw[++pos]='s';}\n  if(c[p]=='R'){x++;if(x==pw3[N/2])sw[++pos]='r',x=0;}\n}\nvoid Update(void)\n{\n  rep(i,pw3[N-N/2])\n  {\n    y=i;\n    rep(j,pos){if(sw[j+1]=='s')y=salsa[y];else if(sw[j+1]=='r'){if((++y)==pw3[N-N/2])y=0;}}\n    A[o+i*pw3[N/2]]=y*pw3[N/2]+x;\n  }\n}\nsigned main(void)\n{\n  o=scanf(\"%d %s\",&N,T+1);\n  //replace(T+1,\"SS\",\"\");if(T[0]=='\\n')return 0;\n  rep(i,N)pw3[i+1]=3*pw3[i];\n  rep(i,pw3[N])salsa[i]=salsa[i/3]*3+(3-i%3)%3;\n  rep(i,pw3[N/2]){o=i,x=i,pos=0;rep(j,strlen(T+1)){p=j+1,Dance(T);}Update();}\n  rep(i,pw3[N])OUT(A[i]),putchar(' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <limits.h>\n#include <stdio.h>\n#include <cmath>\n#include <math.h>\n#include <float.h>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef tuple<int,int> i2tuple;\n\nvector <vector<int>> parent; //parent[i] will hold the parent of i in the shortest path from src to vertex i\nvector <double> dist; // distance[i] will hold the shortest distance from src to vertex i\nvector <bool> vis; // vis[i] will be true if vertex i is included in shortest\nint len;\nint n;\nstring dance;\nvector<vector<double>> matrix;\nvector<vector<double>> matrixV;\nvector<vector<bool>> matrixInclude;\nvector <char> dances;\nvector <int> locations;\n\n\nvoid salsa();\n\nvoid rumba();\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n;\n    cin>>dance;\n    len = pow(3, n);\n    dances = vector<char>(len);\n    locations = vector<int>(len);\n    for (int i = 0; i < len; i++) {\n        dances[i] = dance[i];\n        locations[i] = i;\n    }\n    for (int i = 0; i < len; i++) {\n        if(dances[i] == 'S'){\n            //printf(\"%s\", \"we are S mode \\n\");\n            salsa();\n        }else{\n            //printf(\"%s\", \"we are R mode \\n\");\n            rumba();\n        }\n    }\n    for(int i = 0; i< len; i++){\n        printf(\"%d \", locations[i]);\n    }\n}\nchar reVal(int num)\n{\n    if (num >= 0 && num <= 9)\n        return (char)(num + '0');\n    else\n        return (char)(num - 10 + 'A');\n}\n\n// Utility function to reverse a string\nvoid strev(char *str)\n{\n    int len = strlen(str);\n    int i;\n    for (i = 0; i < len/2; i++)\n    {\n        char temp = str[i];\n        str[i] = str[len-i-1];\n        str[len-i-1] = temp;\n    }\n}\nchar* fromDeci(char res[], int base, int inputNum)\n{\n    int index = 0;  // Initialize index of result\n\n    // Convert input number is given base by repeatedly\n    // dividing it by base and taking remainder\n    while (inputNum > 0)\n    {\n        res[index++] = reVal(inputNum % base);\n        inputNum /= base;\n    }\n    res[index] = '\\0';\n\n    // Reverse the result\n    strev(res);\n\n    return res;\n}\nint val(char c)\n{\n    if (c >= '0' && c <= '9')\n        return (int)c - '0';\n    else\n        return (int)c - 'A' + 10;\n}\n\n// Function to convert a number from given base 'b'\n// to decimal\nint toDeci(char *str, int base)\n{\n    int len = strlen(str);\n    int power = 1; // Initialize power of base\n    int num = 0;  // Initialize result\n    int i;\n\n    // Decimal equivalent is str[len-1]*1 +\n    // str[len-2]*base + str[len-3]*(base^2) + ...\n    for (i = len - 1; i >= 0; i--)\n    {\n        // A digit in input number must be\n        // less than number's base\n        if (val(str[i]) >= base)\n        {\n            printf(\"Invalid Number\");\n            return -1;\n        }\n\n        num += val(str[i]) * power;\n        power = power * base;\n    }\n\n    return num;\n}\n\nvoid rumba() {\n    for(int j = 0; j< len; j++ ){\n        int num = locations[j];\n        int new_num = num +1;\n        if(new_num == len){\n            new_num = 0;\n        }\n        locations[j] = new_num;\n    }\n}\n\nvoid salsa() {\n    for(int j = 0; j< len; j++ ){\n        int num = locations[j];\n        char res[len];\n        char* a = fromDeci(res, 3, num);\n        int k = 0;\n        while(a[k] != '\\0'){\n            if((a[k]) == '1'){\n                a[k] = '2';\n            }else if(a[k] == '2'){\n                a[k] = '1';\n            } k++;\n        }\n        int new_num = toDeci(a, 3);\n        locations[j] = new_num;\n    }\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing int64 = long long;\n\nconstexpr int DEBUG = 0;\n\nint Power3(int p) {\n  int r = 1;\n  for (int i = 0; i < p; i++) {\n    r *= 3;\n  }\n  return r;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n  string original_command;\n  cin >> original_command;\n  vector<vector<int>> output_table(n + 1);\n  vector<vector<string>> command_table(n + 1);\n  for (int k = 1; k <= n; k++) {\n    output_table[k].resize(Power3(k));\n    command_table[k].resize(Power3(k));\n  }\n\n  for (int k = 1; k <= n; k++) {\n    for (int x = 0; x < Power3(k); x++) {\n      string command;\n      if (k == 1) {\n        command = original_command;\n      } else {\n        command = command_table[k - 1][x % Power3(k - 1)];\n      }\n\n      int d = x / Power3(k - 1);\n      string next_command = \"\";\n      for (char c : command) {\n        if (c == 'R') {\n          d++;\n          if (d == 3) {\n            d = 0;\n            next_command.append(\"R\");\n          }\n        } else if (c == 'S') {\n          if (d == 1) d = 2;\n          else if (d == 2) d = 1;\n\n          next_command.append(\"S\");\n        }\n      }\n\n      next_command = std::regex_replace(next_command, std::regex(\"SS\"), \"\");\n\n      output_table[k][x] = d;\n      command_table[k][x] = next_command;\n    }\n  }\n\n  vector<int> outputs;\n  for (int x = 0; x < Power3(n); x++) {\n    int output = 0;\n    for (int k = 1; k <= n; k++) {\n      output += output_table[k][x % Power3(k)] * Power3(k - 1);\n    }\n    outputs.push_back(output);\n  }\n\n  for (int i = 0; i < outputs.size(); i++) {\n    if (i > 0) cout << \" \";\n    cout << outputs[i];\n  }\n  cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nint n;\nstring t;\nint m = 1;\nvector<int> res;\nvoid bt(int ak,int naco,string& z,int mn){\n  if(mn == m){\n    res[ak]=naco;\n    return;\n  }\n  R(i,3){\n    int mam = i;\n    string zm;\n    for(char x:z){\n      if(x == 'R'){\n        mam++;\n        if(mam == 3){\n          mam = 0;\n          zm += 'R';\n        }\n      }else{\n        if(mam >= 1)mam = 3 - mam;\n        if(SZ(zm) && zm.back() == 'S')\n          zm.pop_back();\n        else\n          zm += 'S';\n      }\n    }\n    bt(ak + i * mn, naco + mam * mn, zm, mn*3);\n  }\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n >> t;\n  R(_,n)m *= 3;\n  res.resize(m);\n  bt(0,0,t,1);\n  R(i,m){\n    cout << res[i] << \" \";\n  }\n  cout << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "/*input\n3\nSRSRRSRRRSRRRR\n*/\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef tree<long long, null_type, less_equal<long long>, rb_tree_tag, tree_order_statistics_node_update> indexed_set;\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n//order_of_key #of elements less than x\n// find_by_order kth element\ntypedef long long int ll;\n#define ld double\n#define pii pair<ll,ll>\n#define f first\n#define s second\n#define pb push_back\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REP1(i,n) for(int i=1;i<=n;i++)\n#define FILL(n,x) memset(n,x,sizeof(n))\n#define ALL(_a) _a.begin(),_a.end()\n#define sz(x) (int)x.size()\nconst ll maxn=6e5+5;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=4e18;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=1e9+7;\nconst ld PI=acos(-1);\nconst ld eps=1e-9;\n#define lowb(x) x&(-x)\n#define MNTO(x,y) x=min(x,(__typeof__(x))y)\n#define MXTO(x,y) x=max(x,(__typeof__(x))y)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define MP make_pair\nll mult(ll a,ll b){\n    ll res=0LL;\n    while(b){\n        if(b&1) res=(res+a)%MOD;\n        a=(a+a)%MOD;\n        b>>=1;\n    }\n    return res%MOD;\n}\nll mypow(ll a,ll b){\n    ll res=1LL;\n    while(b){\n        if(b&1) res=res*a%MOD;\n        a=a*a%MOD;\n        b>>=1;\n    }\n    return res;\n}\nint ans[13][maxn];\nstring nxt[13][maxn];\nint main(){\n    int lvl;\n    string t;\n    cin>>lvl>>t;\n    string s=\"\";\n    for(int i=0;i<sz(t);){\n        if(t[i]=='S'){\n            int c=i;\n            while(t[i]=='S'){\n                ++i;\n            }\n            if((c-i)%2) s+='S';\n        }\n        else{\n            s+='R';\n            ++i;\n        }\n    } \n    ans[0][0]=0;\n    nxt[0][0]=s;\n    int suff=1;\n    REP1(i,lvl){\n        REP(bt,3){\n            REP(sf,suff){\n                int cur=bt;\n                int n=bt*suff+sf;\n                for(auto x:nxt[i-1][sf]){\n                    if(x=='S'){\n                        if(cur) cur=3-cur;\n                        if(sz(nxt[i][n]) and nxt[i][n].back()=='S'){\n                            nxt[i][n].pop_back();\n                        }\n                        else{\n                            nxt[i][n].pb('S');\n                        }\n                    }\n                    else{\n                        ++cur;\n                        if(cur==3){\n                            nxt[i][n].pb('R');\n                            cur=0;\n                        }\n                    }\n                }\n                ans[i][n]=ans[i-1][sf]+cur*suff;\n            }\n        }\n        suff*=3;\n    }\n    REP(i,mypow(3,lvl)){\n        cout<<ans[lvl][i]<<' ';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#define maxn 600000\n#define maxm 5000000\nusing namespace std;\n\nint n,i,j,k,ans[maxn];\nint tot,t[maxm][3],tag[maxm],_3[13],p[maxm];\n\nvoid maketree(int x,int dep,int s){\n\tif (dep==n) {p[x]=s;return;}\n\tfor(int i=0;i<3;i++){\n\t\tt[x][i]=++tot;\n\t\tmaketree(t[x][i],dep+1,s+i*_3[dep]);\n\t}\n}\n\nvoid change(int x,int dep){\n\tif (dep==n) return;\n\tif (tag[x]) {\n\t\tswap(t[x][1],t[x][2]),tag[x]^=1;\n\t\tfor(int i=0;i<3;i++) tag[t[x][i]]^=1;\n\t} \n\tint tmp=t[x][2]; t[x][2]=t[x][1],t[x][1]=t[x][0],t[x][0]=tmp;\n\tchange(t[x][0],dep+1);\n}\n\nvoid downtag(int x,int dep,int s){\n\tif (dep==n) {ans[p[x]]=s;return;}\n\tif (tag[x]){\n\t\tswap(t[x][1],t[x][2]),tag[x]^=1;\n\t\tfor(int i=0;i<3;i++) tag[t[x][i]]^=1;\n\t}\n\tfor(int i=0;i<3;i++) downtag(t[x][i],dep+1,s+i*_3[dep]);\n}\n\nint main(){\n\t_3[0]=1;for(i=1;i<=12;i++) _3[i]=_3[i-1]*3;\n\tscanf(\"%d\",&n);\n\ttot=1,maketree(1,0,0);\n\tchar ch;\n\twhile (ch!='S'&&ch!='R') ch=getchar();\n\twhile (ch=='S'||ch=='R'){\n\t\tif (ch=='S') tag[1]^=1; \n\t\telse change(1,0);\n\t\tch=getchar();\n\t}\n\tdowntag(1,0,0);\n\tfor(i=0;i<_3[n];i++) printf(\"%d \",ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class t> inline t read(t &x){\n\tchar c=getchar();bool f=0;x=0;\n\twhile(!isdigit(c)) f|=c=='-',c=getchar();\n\twhile(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\tif(f) x=-x;return x;\n}\ntemplate<class t,class ...A> inline void read(t &x,A &...a){\n\tread(x);read(a...);\n}\ntemplate<class t> inline void write(t x){\n\tif(x<0) putchar('-'),write(-x);\n\telse{if(x>9) write(x/10);putchar('0'+x%10);}\n}\n\nconst int N=1e6+5;\nint ch[N][3],n,m,t,cnt,ans[N];\nbool tg[N];\nchar s[N];\n\nvoid build(int x,int v,int fl,int pw){\n\tif(fl==n) return ;\n\tfor(int i=0;i<3;i++) ch[x][i]=fl+1<n?++cnt:v+i*pw,build(fl+1<n?cnt:v+i*pw,v+i*pw,fl+1,pw*3);\n}\n\nvoid dfs(int x,int v,int fl,int pw){\n\tif(fl==n){\n\t\tans[x]=v;\n\t\treturn ;\n\t}\n\tif(tg[x]) swap(ch[x][1],ch[x][2]);\n\tfor(int i=0;i<3;i++) tg[ch[x][i]]^=tg[x]; tg[x]=0;\n\tfor(int i=0;i<3;i++) dfs(ch[x][i],v+i*pw,fl+1,pw*3);\n}\n\nvoid upr(int x,int fl){\n\tif(fl==n) return ;\n\tif(tg[x]) swap(ch[x][1],ch[x][2]);\n\tfor(int i=0;i<3;i++) tg[ch[x][i]]^=tg[x]; tg[x]=0;\n\tswap(ch[x][1],ch[x][2]);\n\tswap(ch[x][0],ch[x][1]);\n\tupr(ch[x][0],fl+1);\n}\n\nvoid ups(){\n\ttg[m]^=1;\n}\n\nsigned main(){\n\tread(n);\n\tscanf(\"%s\",s+1);\n\tt=strlen(s+1);\n\tm=1; for(int i=1;i<=n;i++) m*=3;\n\tbuild(cnt=m,0,0,1);\n\tfor(int i=1;i<=t;i++) if(s[i]=='R') upr(m,0); else ups();\n\tdfs(m,0,0,1);\n\tfor(int i=0;i<m;i++) write(ans[i]),putchar(' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,lt;\nchar t[200010];\nvoid update(int q,int &last,int &d)\n{\n    if(d!=0&&q!=last%2)d=3-d;\n    last=q;\n}\npair<vector<int>,vector<int> > solve(int n)\n{\n    if(!n)\n        return make_pair(vector<int>({0}),vector<int>(lt,0));\n    auto prev=solve(n-1);\n    const auto& p=prev.first,w=prev.second;\n    vector<int> new_w(w.size());\n    int psiz=p.size();\n    vector<int> d(3*psiz);\n    for(int i=0;i<3;i++)\n    {\n        for(int j=0;j<psiz;j++)\n        {\n            d[i*psiz+j]=i;\n        }\n    }\n    int q=0;\n    vector<int> last(3*psiz);\n    for(int i=0;i<lt;i++)\n    {\n        int k=w[i];\n        for(int j=k;j<3*psiz;j+=psiz)\n        {\n            update(q,last[j],d[j]);\n            if(d[j]==2)new_w[i]=j;\n        }\n        if(t[i]=='S')q^=1;\n        else\n        {\n            for(int j=k;j<3*psiz;j+=psiz)d[j]=(d[j]+1)%3;\n        }\n    }\n    vector<int> new_p(3*psiz);\n    for(int i=0;i<3*psiz;i++)\n    {\n        update(q,last[i],d[i]);\n        new_p[i]=p[i%psiz]+d[i]*psiz;\n    }\n    return make_pair(new_p,new_w);\n}\nint main()\n{\n    scanf(\"%d%s\",&n,t);\n    lt=strlen(t);\n    vector<int> res=solve(n).first;\n    for(int &x:res)printf(\"%d \",x);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nstatic inline char CH()\n{\n  static char buf[100000],*ptr1=buf,*ptr2=buf;\n  return ptr1==ptr2&&(ptr2=(ptr1=buf)+fread(buf,1,100000,stdin),ptr1==ptr2)?EOF:*ptr1++;\n}\nstatic inline int IN(void)\n{\n  int x=0,f=0,c=CH();while(c<48||c>57){f^=c==45,c=CH();}\n  while(c>47&&c<58){x=x*10+c-48,c=CH();}return f?-x:x;\n}\nstatic inline int Pow(int a,int b){return b?Pow(a*a,b>>1)*(b&1?a:1):1;}\nint main()\n{\n  int N=IN(),now,len=0,pw3=Pow(3,N),x=Pow(3,N>>1),y=Pow(3,N-(N>>1)),A[1000001],B[600001];\n  char c=CH(),T[1000001],S[1000001];\n  rep(i,pw3)B[i]=B[i/3]*3+(3-i%3)%3;\n  while(c!=EOF){if(c==10){c=CH();}T[len++]=c,c=CH();}\n  rep(i,x)\n  {\n    int temp=i;now=0;\n    rep(j,len)\n    {\n      if(T[j]=='S'){temp=B[temp];(S[now]=='S')?--now:S[++now]='S';}\n      else{++temp;if(temp==x)S[++now]='R',temp=0;}\n    }\n    rep(j,y)\n    {\n      int keep=j;\n      rep(k,now)\n      {\n        if(S[k+1]=='S')keep=B[keep];\n        else if(S[k+1]=='R')if((++keep)==y)keep=0;\n        A[i+j*x]=temp+keep*x;\n      }\n    }\n  }\n  rep(i,pw3)printf(\"%d\",A[i]),putchar(' ');\n  return puts(\"\"),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <limits.h>\n#include <stdio.h>\n#include <cmath>\n#include <math.h>\n#include <float.h>\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef tuple<int,int> i2tuple;\n\nvector <vector<int>> parent; //parent[i] will hold the parent of i in the shortest path from src to vertex i\nvector <double> dist; // distance[i] will hold the shortest distance from src to vertex i\nvector <bool> vis; // vis[i] will be true if vertex i is included in shortest\nint len;\nint n;\nstring dance;\nvector<vector<double>> matrix;\nvector<vector<double>> matrixV;\nvector<vector<bool>> matrixInclude;\nvector <char> dances;\nvector <int> locations;\n\n\nvoid salsa();\n\nvoid rumba();\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n;\n    cin>>dance;\n    len = pow(3, n);\n    dances = vector<char>(len);\n    locations = vector<int>(len);\n    for (int i = 0; i < len; i++) {\n        dances[i] = dance[i];\n        locations[i] = i;\n    }\n    for (int i = 0; i < len; i++) {\n        if(dances[i] == 'S'){\n            //printf(\"%s\", \"we are S mode \\n\");\n            salsa();\n        }else{\n            //printf(\"%s\", \"we are R mode \\n\");\n            rumba();\n        }\n    }\n    for(int i = 0; i< len; i++){\n        printf(\"%d\", locations[i]);\n    }\n    printf(\"%s\", \"\\n\");\n}\nchar reVal(int num)\n{\n    if (num >= 0 && num <= 9)\n        return (char)(num + '0');\n    else\n        return (char)(num - 10 + 'A');\n}\n\n// Utility function to reverse a string\nvoid strev(char *str)\n{\n    int len = strlen(str);\n    int i;\n    for (i = 0; i < len/2; i++)\n    {\n        char temp = str[i];\n        str[i] = str[len-i-1];\n        str[len-i-1] = temp;\n    }\n}\nchar* fromDeci(char res[], int base, int inputNum)\n{\n    int index = 0;  // Initialize index of result\n\n    // Convert input number is given base by repeatedly\n    // dividing it by base and taking remainder\n    while (inputNum > 0)\n    {\n        res[index++] = reVal(inputNum % base);\n        inputNum /= base;\n    }\n    res[index] = '\\0';\n\n    // Reverse the result\n    strev(res);\n\n    return res;\n}\nint val(char c)\n{\n    if (c >= '0' && c <= '9')\n        return (int)c - '0';\n    else\n        return (int)c - 'A' + 10;\n}\n\n// Function to convert a number from given base 'b'\n// to decimal\nint toDeci(char *str, int base)\n{\n    int len = strlen(str);\n    int power = 1; // Initialize power of base\n    int num = 0;  // Initialize result\n    int i;\n\n    // Decimal equivalent is str[len-1]*1 +\n    // str[len-2]*base + str[len-3]*(base^2) + ...\n    for (i = len - 1; i >= 0; i--)\n    {\n        // A digit in input number must be\n        // less than number's base\n        if (val(str[i]) >= base)\n        {\n            printf(\"Invalid Number\");\n            return -1;\n        }\n\n        num += val(str[i]) * power;\n        power = power * base;\n    }\n\n    return num;\n}\n\nvoid rumba() {\n    for(int j = 0; j< len; j++ ){\n        int num = locations[j];\n        int new_num = num +1;\n        if(new_num == len){\n            new_num = 0;\n        }\n        locations[j] = new_num;\n    }\n}\n\nvoid salsa() {\n    for(int j = 0; j< len; j++ ){\n        int num = locations[j];\n        char res[len];\n        char* a = fromDeci(res, 3, num);\n        int k = 0;\n        while(a[k] != '\\0'){\n            if((a[k]) == '1'){\n                a[k] = '2';\n            }else if(a[k] == '2'){\n                a[k] = '1';\n            } k++;\n        }\n        int new_num = toDeci(a, 3);\n        locations[j] = new_num;\n    }\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl;\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\ntypedef long long ll;\n#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(int)(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst long double pi = 3.1415926535897932384626433832795028841971L;\n#define Sp(p) cout<<setprecision(25)<< fixed<<p<<endl;\n//int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n//int dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\nvi dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};\nvi dx2 = { 1,1,0,-1,-1,-1,0,1 }, dy2 = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\n// #define mp make_pair\n//#define endl '\\n'\n\nsigned main() {\n    int n;\n    cin >> n;\n    string t;\n    cin >> t;\n    vii a(n);\n    rep (i, n) {\n        rep (j, 3) {\n            rep (k, (int)pow(3, i)) a[i].push_back(j);\n        }\n    }\n\n    bool rev = false;\n    rep (i, t.size()) {\n        if (t[i] == 'S') {\n            rev = !rev;\n            // DEBUG_MAT(a);\n            continue;\n        }\n        assert(t[i] == 'R');\n\n        int pre = 0;\n        rep (i, n) {\n            int m = pow(3, i);\n            int nex;\n            for (int j = 0; j < 3; j++) {\n                int idx = pre + m * j;\n                if (not rev) {\n                    if (a[i][idx] == 2) nex = idx;\n                    a[i][idx] = (a[i][idx] + 1) % 3;\n                }\n                else {\n                    if (a[i][idx] == 1) nex = idx;\n                    a[i][idx] = (a[i][idx] + 2) % 3;\n                }\n            }\n            pre = nex;\n        }\n        // DEBUG_MAT(a);\n    }\n\n    // DEBUG_MAT(a);\n\n    // DEBUG(rev);\n    int m = pow(3, n);\n    vi pos(m);\n    rep (i, m) {\n        int x = i;\n        int val = 0;\n        rep (j, n) {\n            int tt = pow(3, j + 1);\n            int idx = x % tt;\n            int add = a[j][idx];\n            if (rev) {\n                if (add == 1) add = 2;\n                else if (add == 2) add = 1;\n            }\n            val += tt / 3 * add;\n        }\n        cout << val << \" \";\n    }\n    cout << endl;\n\n    // rep (i, m) {\n    //     cout << pos[i] << \" \";\n    // }\n    // cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nstatic inline char CH()\n{\n  static char buf[100000],*ptr1=buf,*ptr2=buf;\n  return ptr1==ptr2&&(ptr2=(ptr1=buf)+fread(buf,1,100000,stdin),ptr1==ptr2)?EOF:*ptr1++;\n}\nstatic inline int IN(void)\n{\n  int x=0,f=0,c=CH();while(c<48||c>57){f^=c==45,c=CH();}\n  while(c>47&&c<58){x=x*10+c-48,c=CH();}return f?-x:x;\n}\nstatic inline int Pow(int a,int b){return b?Pow(a*a,b>>1)*(b&1?a:1):1;}\nint main()\n{\n  int N=IN(),now,len=0,pw3=Pow(3,N),x=Pow(3,N>>1),y=Pow(3,N-(N>>1)),A[1000001],B[600001];\n  char c=CH(),T[1000001],S[1000001];\n  rep(i,pw3)B[i]=B[i/3]*3+(3-i%3)%3;\n  while(c!=EOF){if(c==10){c=CH();}T[len++]=c,c=CH();}\n  fflush(stdin);\n  rep(i,x)\n  {\n    int temp=i;now=0;\n    rep(j,len)\n    {\n      if(T[j]=='S'){temp=B[temp];if(S[now]=='S')--now;else S[++now]='S';}\n      else{++temp;if(temp==x)S[++now]='R',temp=0;}\n    }\n    rep(j,y)\n    {\n      int keep=j;\n      rep(k,now)\n      {\n        if(S[k+1]=='S')keep=B[keep];\n        else if(S[k+1]=='R')if((++keep)==y)keep=0;\n      }\n      A[i+j*x]=temp+keep*x;\n    }\n  }\n  rep(i,pw3)printf(\"%i%c\",A[i],i+1==pw3?'\\n':' ');\n  return fflush(stdout),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rep2(i, s, n) for (int i = (s); i < (int)(n); i++)\n\nint main(){\n  rep(i,3){\n    cout << \"Hello,World\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n, po[13], S[201000], Ans[13][177147];\nvector<int>U[13][177147];\nchar p[201000];\nint main(){\n    int i, j;\n    po[0]=1;\n    for(i=0;i<12;i++)po[i+1]=po[i]*3;\n    scanf(\"%d\",&n);\n    scanf(\"%s\",p);\n    for(i=0;p[i];i++){\n        S[i+1]=S[i];\n        if(p[i]=='S')S[i+1]++;\n    }\n    int m = i;\n    for(i=0;i<3;i++){\n        int cur = i;\n        for(j=0;p[j];j++){\n            if(cur==2 && p[j]=='R'){\n                U[1][i].push_back(j);\n            }\n            if(p[j]=='S'){\n                cur=(3-cur)%3;\n            }\n            else cur=(cur+1)%3;\n        }\n        Ans[1][i]=cur;\n    }\n    for(i=1;i<n;i++){\n        for(j=0;j<po[i+1];j++){\n            int a = j/po[i];\n            int b = j%po[i];\n            int pv = 0;\n            for(auto &t : U[i][b]){\n                int s=0;\n                if(t)s += S[t];\n                if(pv)s -= S[pv];\n                if(s&1){\n                    a=(3-a)%3;\n                }\n                a=(a+1)%3;\n                if(a==0)U[i+1][j].push_back(t);\n                pv=t+1;\n            }\n            int s=S[m];\n            if(pv)s -= S[pv];\n            if(s&1)a=(3-a)%3;\n            Ans[i+1][j] = Ans[i][b] + po[i]*a;\n        }\n    }\n    for(i=0;i<po[n];i++){\n        printf(\"%d \",Ans[n][i]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\n#define MAXI 531441\n\nlong long int S[MAXI],C[MAXI],Cinv[MAXI],C2[MAXI];\n\n\nint main() {\n    long long int i,j,k,l,m,N,Q,X,P;\n    string T;\n\n cin >> N >> T;\n\n // P = 3^N\n\n P = 1;\n for (i=1;i<=N;i++)\n    P *= 3;\n\n\n S[0] = 0;\n S[1] = 2;\n S[2] = 1;\n j = 1;\n for (i=1;i<N;i++) {\n    j *= 3;\n    k = (j << 1);\n    for (l=0;l<j;l++) {\n      S[j+l] = k+S[l];\n      S[k+l] = j+S[l];\n    }\n}\n/*\ncerr << \"S = \";\nfor (i=0;i<P;i++) {\n  cerr << S[i] << \" \";\n}\ncerr << endl;\n*/\n\nfor (i=0;i<P;i++) {\n  C[i] = i;\n}\nfor (i=0;i<P;i++) {\n  Cinv[C[i]] = i;\n}\n\nlong long int decalage;\n\nfor (i=0;i<T.length();i++) {\n/*  cerr << \"C\" << i << \" = \";\n  for (k=0;k<P;k++)\n    cerr << C[k] <<  \" \";\n  cerr << \"Cinv\" << i << \" = \";\n    for (k=0;k<P;k++)\n      cerr << Cinv[k] <<  \" \";\n  cerr << endl; */\n  if (T[i] == 'S') {\n  //   cerr << i+1 << \" On lit S\";\n     decalage = 1;\n     for (j=i+1;j<T.length();j++)\n       if (T[j]== 'S')\n         decalage++;\n       else\n         j = T.length();\n//    cerr << decalage << endl;\n    if (decalage % 2) {\n\n    for (j=0;j<P;j++) {\n      if (S[j] > j) {\n        // k = Cinv[j];\n        C[Cinv[j]] = S[j];\n        C[Cinv[S[j]]] = j;\n      }\n    }\n    for (j=0;j<P;j++) {\n      Cinv[C[j]] = j;\n    }\n    }\n    i += decalage-1;\n  }\n  else {\n  //  cerr << i+1 << \" On lit R\" << endl;\n  decalage = 1;\n  for (j=i+1;j<T.length();j++)\n    if (T[j]== 'S')\n      decalage++;\n    else\n      j = T.length();\n      i += decalage-1;\n\n    for (j=0;j<P;j++)\n      C2[Cinv[j]] = (j+decalage) % P;\n// C[ Cinv[j]] = j devient (j + decalage ) % P\n    for (j=0;j<P;j++)\n      C[j] = C2[j];\n    for (j=0;j<P;j++)\n      Cinv[C[j]] = j;\n  }\n}\n\nfor (i=0;i<P;i++)\n  cout << C[i] <<  \" \";\n\ncout << \"\\n\";\n\n\n\n// cout << sqrt(dx*dx+dy+dy) << endl;\n// printf(\"%f\\n\",sqrt(dx*dx+dy+dy));\n\n\n\n  return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a), i##end = (b); i <= i##end; ++i)\n#define per(i, a, b) for (int i = (a), i##end = (b); i >= i##end; --i)\n\nmt19937 Rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n\ntemplate <typename T>\ninline void chkmax(T &x, T y) { if (x < y) x = y; }\n\ntemplate <typename T>\ninline void chkmin(T &x, T y) { if (x > y) x = y; }\n\ninline int read() {\n  #define nc getchar()\n  int x = 0;\n  char c = nc;\n  while (c < 48) c = nc;\n  while (c > 47) x = x * 10 + (c ^ 48), c = nc;\n  return x;\n  #undef nc\n}\n\ntypedef long long ll;\nconst int maxn = 2e6 + 10;\nchar str[maxn];\nint n, pw[13], tag[maxn], tid[maxn], ch[maxn][3], ans[maxn];\n\nvoid build(int k, int dep, int val) {\n  if (dep == n) return tid[k] = val, void();\n  ch[k][0] = k * 3, build(ch[k][0], dep + 1, val);\n  ch[k][1] = k * 3 + 1, build(ch[k][1], dep + 1, val + pw[dep]);\n  ch[k][2] = k * 3 + 2, build(ch[k][2], dep + 1, val + pw[dep] * 2);\n}\n\nvoid pushdown(int k) {\n  if (tag[k]) {\n    tag[k] = 0, swap(ch[k][1], ch[k][2]);\n    tag[ch[k][0]] ^= 1, tag[ch[k][1]] ^= 1, tag[ch[k][2]] ^= 1;\n  }\n}\n\nvoid upd(int k, int dep) {\n  if (dep == n) return;\n  pushdown(k);\n  upd(ch[k][2], dep + 1);\n  swap(ch[k][1], ch[k][2]), swap(ch[k][0], ch[k][1]);\n}\n\nvoid print(int k, int dep, int val) {\n  if (dep == n) return ans[tid[k]] = val, void();\n  pushdown(k);\n  print(ch[k][0], dep + 1, val);\n  print(ch[k][1], dep + 1, val + pw[dep]);\n  print(ch[k][2], dep + 1, val + pw[dep] * 2);\n}\n\nvoid solve() {\n  scanf(\"%d %s\", &n, str + 1);\n  pw[0] = 1;\n  rep(i, 1, n) pw[i] = 3 * pw[i - 1];\n  build(1, 0, 0);\n  rep(i, 1, strlen(str + 1)) {\n    if (str[i] == 'S') {\n      tag[1] ^= 1;\n    } else {\n      upd(1, 0);\n    }\n  }\n  print(1, 0, 0);\n  rep(i, 0, pw[n] - 1) printf(\"%d \", ans[i]);\n}\n\nint main() {\n//  int T = read();\n//  while (T--) solve();\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n\nclass CStrangeDance {\npublic:\n    int N;\n    vector<int> D, E, Ans;\n\n    string canonical(const string&S) {\n        string T;\n        for (char s: S) {\n            if (s == 'R') T += s;\n            else if (T.empty() || T.back() != s) T.push_back(s);\n            else T.pop_back();\n        }\n        return T;\n    }\n\n    int num(const vector<int>&A) {\n        int ret = 0;\n        for (int i = N-1; i >= 0; --i) ret = 3*ret + A[i];\n        return ret;\n    }\n\n    void solve(int X, const string &T) {\n        if (X == N) {\n            Ans[num(D)] = num(E);\n            return;\n        }\n\n        for (int d = 0; d < 3; ++d) {\n            string S;\n            int e = d;\n            for (char t: T) {\n                if (t == 'S') {\n                    if (e) e = 3-e;\n                    S += t;\n                } else if (++e == 3) {\n                    e = 0;\n                    S += t;\n                }\n            }\n            D[X] = d;\n            E[X] = e;\n            solve(X+1, canonical(S));\n        }\n    }\n\n    void solve(istream& cin, ostream& cout) {\n        string T;\n        cin >> N >> T;\n        D.resize(N);\n        E.resize(N);\n        int M = 1;\n        for (int i = 0; i < N; ++i) M *= 3;\n        Ans.resize(M);\n        solve(0, canonical(T));\n        cout << Ans;\n    }\n};\n\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tCStrangeDance solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include <algorithm>\n#include <cstddef>\n#include <cstdint>\n#include <iostream>\n#include <utility>\n#include <vector>\n\nnamespace n91 {\n\nusing i8 = std::int_fast8_t;\nusing i32 = std::int_fast32_t;\nusing i64 = std::int_fast64_t;\nusing u8 = std::uint_fast8_t;\nusing u32 = std::uint_fast32_t;\nusing u64 = std::uint_fast64_t;\nusing isize = std::ptrdiff_t;\nusing usize = std::size_t;\n\nstruct rep {\n  struct itr {\n    usize i;\n    constexpr itr(const usize i) noexcept : i(i) {}\n    void operator++() noexcept { ++i; }\n    constexpr usize operator*() const noexcept { return i; }\n    constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n  };\n  const itr f, l;\n  constexpr rep(const usize f, const usize l) noexcept\n      : f(std::min(f, l)), l(l) {}\n  constexpr auto begin() const noexcept { return f; }\n  constexpr auto end() const noexcept { return l; }\n};\nstruct revrep {\n  struct itr {\n    usize i;\n    constexpr itr(const usize i) noexcept : i(i) {}\n    void operator++() noexcept { --i; }\n    constexpr usize operator*() const noexcept { return i; }\n    constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n  };\n  const itr f, l;\n  constexpr revrep(const usize f, const usize l) noexcept\n      : f(l - 1), l(std::min(f, l) - 1) {}\n  constexpr auto begin() const noexcept { return f; }\n  constexpr auto end() const noexcept { return l; }\n};\ntemplate <class T> auto md_vec(const usize n, const T &value) {\n  return std::vector<T>(n, value);\n}\ntemplate <class... Args> auto md_vec(const usize n, Args... args) {\n  return std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n}\ntemplate <class T> constexpr T difference(const T &a, const T &b) noexcept {\n  return a < b ? b - a : a - b;\n}\ntemplate <class T> void chmin(T &a, const T &b) noexcept {\n  if (b < a)\n    a = b;\n}\ntemplate <class T> void chmax(T &a, const T &b) noexcept {\n  if (a < b)\n    a = b;\n}\ntemplate <class F> class rec_lambda {\n  F f;\n\npublic:\n  rec_lambda(F &&f) : f(std::move(f)) {}\n  template <class... Args> auto operator()(Args &&... args) const {\n    return f(*this, std::forward<Args>(args)...);\n  }\n};\ntemplate <class F> auto make_rec(F &&f) { return rec_lambda<F>(std::move(f)); }\ntemplate <class T> T scan() {\n  T ret;\n  std::cin >> ret;\n  return ret;\n}\nconstexpr char eoln = '\\n';\ntemplate <class T> T ceildiv(const T &l, const T &r) {\n  return l / r + (l % r != 0 ? 1 : 0);\n}\n\n} // namespace n91\n\n#include <array>\n\nnamespace n91 {\n\nusize pow3(usize n) {\n  usize ret = 1;\n  for (const usize i : rep(0, n)) {\n    ret *= 3;\n  }\n  return ret;\n}\n\nvoid main_() {\n  //*\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  //*/\n\n  /*\n  0 -> flip\n  1 -> add\n  */\n\n  struct node {\n    std::vector<u8> seq;\n    usize pos;\n  };\n\n  const usize nn = scan<usize>();\n  const std::string tt = scan<std::string>();\n\n  auto dpt = md_vec(1, node());\n\n  dpt[0].pos = 0;\n\n  for (const auto e : tt) {\n    if (e == 'S') {\n      dpt[0].seq.push_back(0);\n    } else {\n      dpt[0].seq.push_back(1);\n    }\n  }\n\n  static constexpr std::array<usize, 3> flip = {0, 2, 1};\n\n  for (const usize n : rep(0, nn)) {\n    auto nxt = md_vec(pow3(n + 1), node());\n    const usize mask = pow3(n);\n    for (const usize i : rep(0, pow3(n + 1))) {\n      const auto &dp = dpt[i % mask];\n      auto &nx = nxt[i];\n      usize st = i / mask;\n      usize fc = 0;\n      for (const auto e : dp.seq) {\n        switch (e) {\n        case 0: {\n          st = flip[st];\n          fc ^= 1;\n        } break;\n        case 1: {\n          st += 1;\n          if (st == 3) {\n            st = 0;\n            if (fc) {\n              nx.seq.push_back(0);\n              fc = 0;\n            }\n            nx.seq.push_back(1);\n          }\n        } break;\n        }\n      }\n      if (fc) {\n        nx.seq.push_back(0);\n      }\n      nx.pos = st * mask + dp.pos;\n    }\n    dpt = std::move(nxt);\n  }\n\n  for (const auto &e : dpt) {\n    std::cout << e.pos << \" \";\n  }\n  std::cout << eoln;\n}\n\n} // namespace n91\n\nint main() {\n  n91::main_();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+7;\nint n,m,f[N],g[N],ans[N]; char s[N],t[N];\ninline void write(int u){\n\tif(u>9) write(u/10); putchar(u%10+'0');\n}\nint main(){\n\tcin>>n; int a=1,b=1;\n\tfor(int i=1;i<=n/2;i++) a=a*3;d\n\tfor(int i=n/2+1;i<=n;i++) b=b*3;\n\tfor(int i=0;i<a*b;i++){\n\t\tf[i]=f[i/3]*3,g[i]=(g[i]+1)%(a*b);\n\t\tif(i%3==1) f[i]+=2; else if(i%3==2) f[i]++;\n\t}\n\tscanf(\"%s\",s+1),m=strlen(s+1);\n\tfor(int i=0;i<a;i++){\n\t\tint u=i; int len=0;\n\t\tfor(int z=1;z<=m;z++)\n\t\t\tif(s[z]=='S'){\n\t\t\t\tu=f[u];\n\t\t\t\tif(t[len]=='S') len--; else t[++len]='S';\n\t\t\t}\n\t\t\telse if(s[z]=='R'){\n\t\t\t\tif(u+1==a) t[++len]='R',u=0;\n\t\t\t\telse u++;\n\t\t\t}\n\t\tint v=u;\n\t\tfor(int x=0;x<b;x++){\n\t\t\tint u=x;\n\t\t\tfor(int z=1;z<=len;z++)\n\t\t\tif(t[z]=='S') u=f[u];\n\t\t\telse if(t[z]=='R'){\n\t\t\t\tif(u+1==b) u=0;\n\t\t\t\telse u++;\n\t\t\t}\n\t\t\tans[i+x*a]=u*a+v;\n\t\t}\n\t}\n\tfor(int i=0;i<a*b;i++) write(ans[i]),putchar(' ');\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<iomanip>\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> v;\ntypedef vector<vector<ll>> vv;\n\n\n#define MOD 1000000007\n#define INF 1e15\n#define MIN -1001001001\n#define rep(i,k,N) for(int i=k;i<N;i++)\n#define MP make_pair\n#define MT make_tuple //tie,make_tuple は別物\n#define PB push_back\n#define PF push_front\n#define all(x) (x).begin(),(x).end()\n\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\n\nint main(){\n    ll N;\n    cin>>N;\n    v A(N+1);\n    rep(i,0,N+1)cin>>A[i];\n    v max_l(N+1);\n    bool ok = true;\n    max_l[0] = 1-A[0];\n\n    rep(i,1,N+1){\n        max_l[i] = min(max_l[i-1]*2-A[i],ll(INF));\n        if(max_l[i]<0)ok = false;\n    }\n    ll ans = A[N],now = A[N];\n    for(ll i = N-1;i >=0; i--){\n        if(now == 0)ok = false;\n        if(now > max_l[i] * 2)ok = false;\n        ll now_l = min(now,max_l[i]);\n        now = now_l + A[i];\n        ans += now;\n    }\n    if(ok == false)cout<<-1;\n    else cout<<ans;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=5e5+5;\nint n,rt,tot,sum[N],ans[N],t[N][3],lz[N];\nchar s[N];\nvoid build(int &now,int n,int b,int c)\n{\n    now=++tot;\n    if(n==0){sum[now]=c;return;}\n    build(t[now][0],n-1,b*3,c);\n    build(t[now][1],n-1,b*3,c+b);\n    build(t[now][2],n-1,b*3,c+b+b);\n}\nvoid updata(int now,int n)\n{\n    swap(t[now][1],t[now][2]);\n    lz[t[now][0]]^=1;\n    lz[t[now][1]]^=1;\n    lz[t[now][2]]^=1;\n    lz[now]=0;\n}\nvoid solve(int now,int n)\n{\n    if(n==0) return;\n    if(lz[now]) updata(now,n);\n    int a=t[now][0],b=t[now][1],c=t[now][2];\n    t[now][1]=a;t[now][2]=b;t[now][0]=c;\n    solve(t[now][0],n-1);\n}\nvoid getans(int now,int n,int b,int c)\n{\n    if(n==0){ans[sum[now]]=c;return;}\n    if(lz[now]) updata(now,n);\n    getans(t[now][0],n-1,b*3,c);\n    getans(t[now][1],n-1,b*3,c+b);\n    getans(t[now][2],n-1,b*3,c+b+b);\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    scanf(\"%s\",s+1);\n    build(rt,n,1,0);\n    for(int i=1;s[i];i++)\n    {\n        if(s[i]=='S') lz[rt]^=1;\n        else solve(rt,n);\n    }\n    getans(rt,n,1,0);\n    int sum=1;for(int i=1;i<=n;i++) sum*=3;\n    for(int i=0;i<sum;i++) printf(i==sum-1?\"%d\\n\":\"%d \",ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,x,y,z,sw,pw3[13]={1},A[531441]={0},trit[13][531441]={0};\nchar T[200001];\nvoid OUT(int x){if(x<0)putchar('-'),x=-x;if(x>=10)OUT(x/10);putchar(x%10+48);}\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nsigned main(void)\n{\n  x=scanf(\"%d %s\",&N,T+1);\n  replace(T+1,\"SS\",\"\");if(T[0]=='\\n')return 0;\n  rep(i,N)pw3[i+1]=3*pw3[i];\n  rep(i,strlen(T+1))\n  {\n    if(T[i+1]=='S'){sw^=1;continue;}\n    x=0;\n    rep(j,N)\n    {\n      if(sw)z=1;else z=2;\n      y=x+pw3[j]*((trit[j][x]+z)%3);\n      trit[j][x]=(trit[j][x]+z)%3;\n      x=y;\n    }\n  }\n  rep(i,N)\n  {\n    rep(j,pw3[N])\n    {\n      x=((j/pw3[i])%3-trit[i][j%pw3[i]]+3)%3;\n      if(sw)x=(3-x)%3;\n      A[j]+=x*pw3[i];\n    }\n  }\n  rep(i,pw3[N])OUT(A[i]),putchar(' ');\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n \n//#define int long long\n \n#define pii pair<int, int>\n \n#define x1 x1228\n#define y1 y1228\n \n#define left left228\n#define right right228\n \n#define next next228\n \n#define pb push_back\n#define eb emplace_back\n \n#define mp make_pair                                                                \n                                                                                                                                        \n#define ff first                                                                  \n#define ss second   \n \n#define all(x) x.begin(), x.end()\n#define debug(x) cout << #x << \": \" << x << endl; \n#define TIME (ld)clock()/CLOCKS_PER_SEC\n \nusing namespace std;\ntypedef long long ll; \ntypedef long double ld; \n                                                                                                   \nconst int maxn = 2e5 + 7, mod = 1e9 + 7, MAXN = 1e6 + 7;\nconst double eps = 1e-9;\nconst ll inf = 1e18;\nmt19937 rnd(time(0));\nint n; \nstring s; \nint next[MAXN];\nconst int N = 2187; \nint dp1[N]; \nint dp2[N]; \nint xyz[N]; \n \nint get1(int mask, char q) {\n    if (q == 'R') {\n        ++mask; \n        return mask; \n    }   \n    int ptr = 1; \n    int ans = 0; \n    while (mask) {\n        int t = mask % 3; \n        mask /= 3; \n        if (t == 2) ans += ptr; \n        if (t == 1) ans += 2 * ptr; \n        ptr *= 3; \n    }\n    return ans; \n}\n \nconst int L = 12; \nint pref[maxn]; \nint to[maxn]; \nint kek1[N], kek2[N]; \nint res[N], res1[N]; \nint add = 1; \n \nvoid print(int x) {\n    while (x) {\n        cout << x % 3 << \" \"; \n        x /= 3; \n    }\n    cout << '\\n'; \n}\n\nint get(int x) {\n    vector<int> bts; \n    for (int i = 0; i < L; ++i) {\n        bts.pb(x % 3); \n        x /= 3; \n    }\n    int left = 0;\n    int right = 0; \n    for (int i = 6; i >= 0; --i) {\n        left *= 3;\n        left += bts[i]; \n    }\n    for (int i = L - 1; i >= 7; --i) {\n        right *= 3; \n        right += bts[i]; \n    }\n    int id = 0;         \n    if (left && dp1[left] == -1) {\n        if ((pref[(int)s.size()] - pref[id]) & 1) {        \n            right = xyz[right];     \n        }\n        return res[left] + add * right;   \n    }\n    if (left) {    \n        id = dp1[left]; \n//        print(right); \n        if (pref[id] & 1) {\n            right = xyz[right];             \n        }\n        ++right;\n//        print(right); \n        left = 0; \n    }                     \n    while (next[id] != -1) {        \n        if ((pref[next[id]] - pref[id]) & 1) {\n            right = xyz[right]; \n        }\n        right++; \n        id = next[id];                                                                                                                                         \n    }\n    if ((pref[(int)s.size()] - pref[id]) & 1) {        \n        right = xyz[right];     \n    }\n    left = to[id]; \n    return left + right * add; \n}\n \nvoid solve() {\n    for (int i = 0; i < N; ++i) {\n        xyz[i] = get1(i, 'S') % N; \n    }\n    cin >> n >> s; \n    int t = s.size(); \n    for (int i = 0; i < t; ++i) {\n        pref[i + 1] = pref[i] + (s[i] == 'S'); \n    }\n \n    for (int i = 0; i < N; ++i) dp1[i] = dp2[i] = -1; \n    next[t] = -1;\n    for (int i = 0; i < N; ++i) kek1[i] = i;              \n    for (int i = 0; i < N; ++i) res[i] = i; \n    for (int i = t - 1; i >= 0; --i) {\n        for (int mask = 0; mask < N; ++mask) {\n            int mask1; \n            if (s[i] == 'S') mask1 = xyz[mask]; \n            else mask1 = mask + 1; \n            if (mask1 >= N) mask1 -= N; \n            res1[mask] = res[mask1]; \n            kek2[mask] = kek1[mask1];\n            if (mask && mask1 == 0) {\n                dp2[mask] = i + 1; \n            } else {\n                dp2[mask] = dp1[mask1]; \n            }                                                                                 \n        }\n        to[i] = kek2[0]; \n        next[i] = dp2[0]; \n        for (int mask = 0; mask < N; ++mask) {\n            res[mask] = res1[mask]; \n            kek1[mask] = kek2[mask]; \n            dp1[mask] = dp2[mask]; \n            dp2[mask] = -1; \n        }\n    }\n    for (int i = 0; i < 7; ++i) add *= 3; \n    int tet = 1; \n    for (int i = 0; i < n; ++i) tet *= 3; \n    for (int ptr = 0; ptr < tet; ++ptr) {\n        cout << get(ptr) % tet << \" \"; \n    }\n//    cout << TIME; \n    return; \n}                                \n   \nsigned main() {\n#ifdef LOCAL\n    freopen(\"TASK.in\", \"r\", stdin);\n    freopen(\"TASK.out\", \"w\", stdout);\n#else \n    \n#endif // LOCAL\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20); \n    cout << fixed; \n    int t = 1; \n    for (int i = 0; i < t; ++i) {              \n        solve();\n    }\n    return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar T[550005];\nint salsa2[550005];\nint salsaNext[550005];\nint p[550005];\n\n// Based on editorial solution\nint D[13][550005]; // one digit at a time, with digit 0 representing the ones place\nint W[13][550005];\nint lastUpdated[13][550005];\n\nint N;\n\nint salsa(int x){\n    int temp = x;\n    int pow3 = 1;\n    int res = 0;\n    for(int i = 0; i < N; i ++){\n        int k = temp%3;\n        temp /= 3;\n\n        if(k == 1){\n            res += pow3*2;\n        }else if(k == 2){\n            res += pow3;\n        }\n        pow3 *= 3;\n    }\n    return res;\n}\n\nvoid update(int n, int indx, int cntS){\n    if((cntS&1) != (lastUpdated[n][indx]&1)){\n        // conduct salsa\n        if(D[n][indx] == 1){\n            D[n][indx] = 2;\n        }else if(D[n][indx] == 2){\n            D[n][indx] = 1;\n        }\n    }\n    // updated the lastUpdated index\n    lastUpdated[n][indx] = cntS;\n}\n\nint digits[15];\nvoid printBase3(int x, int N){\n    for(int i = 0; i < N; i ++){\n        digits[i] = x%3;\n        x /= 3;\n    }\n    for(int i = N-1; i >= 0; i --){\n        printf(\"%d\", digits[i]);\n    }\n}\n\nint pow3[16];\n\nint main(){\n    scanf(\"%d\", &N);\n\n    scanf(\" %s\", T);\n\n    int M = strlen(T);\n\n    pow3[0] = 1;\n    for(int i = 1; i <= N; i ++){\n        pow3[i] = pow3[i-1]*3;\n    }\n\n    int pow3N = pow3[N];\n\n    for(int i = 0; i < pow3N; i ++){\n        salsa2[i] = salsa(i);\n        //printf(\"salsa2[%d]=%d\\n\", i, salsa2[i]);\n    }\n\n    //printf(\"ok\");\n    memset(W, 0, sizeof(W));\n    for(int n = 1; n <= N; n ++){\n        //printf(\"ok\");\n        for(int j = 0; j < pow3[N]; j ++){\n            D[n][j] = (j%pow3[n])/pow3[n-1];\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        W[n][0] = pow3[n]-1;\n    }\n\n\n    memset(lastUpdated, 0, sizeof(lastUpdated));\n    int cntS2 = 0;\n    for(int n = 1; n <= N; n ++){\n        int cntS = 0;\n        for(int i = 0; i < M; i ++){\n            int indx0 = W[n-1][i];\n            int indx1 = W[n-1][i]+pow3[n-1];\n            if(indx1 >= pow3[n]){\n                indx1 -= pow3[n];\n            }\n            int indx2 = W[n-1][i]+(pow3[n-1]<<1);\n            if(indx2 >= pow3[n]){\n                indx2 -= pow3[n];\n            }\n\n            update(n, indx0, cntS+(T[i]=='S'));\n            update(n, indx1, cntS+(T[i]=='S'));\n            update(n, indx2, cntS+(T[i]=='S'));\n            if(D[n][indx0] == 2){\n                W[n][i] = indx0;\n            }else if(D[n][indx1] == 2){\n                W[n][i] = indx1;\n            }else{\n                W[n][i] = indx2;\n            }\n\n            if(T[i] == 'R'){\n                D[n][indx0] = (D[n][indx0]+1);\n                D[n][indx1] = (D[n][indx1]+1);\n                D[n][indx2] = (D[n][indx2]+1);\n                if(D[n][indx0] == 3){D[n][indx0] = 0;}\n                if(D[n][indx1] == 3){D[n][indx1] = 0;}\n                if(D[n][indx2] == 3){D[n][indx2] = 0;}\n                lastUpdated[n][indx0] = cntS;\n                lastUpdated[n][indx1] = cntS;\n                lastUpdated[n][indx2] = cntS;\n            }else if(T[i] == 'S'){\n                cntS ++;\n            }\n\n            //printf(\"W[%d][%d]=%d\\n\", n, i+1, W[n][i+1]);\n        }\n\n        cntS2 = cntS;\n    }\n\n    for(int n = 1; n <= N; n ++){\n        for(int i = 0; i < pow3[n]; i ++){\n            update(n, i, cntS2);\n        }\n    }\n\n    for(int i = 0; i < pow3[N]; i ++){\n        int temp = 0;\n        for(int n = 1; n <= N; n ++){\n            temp += D[n][i%pow3[n]]*pow3[n-1];\n        }\n        //printf(\"i=%d W[N-1][M]=%d temp=%d\\n\", i, W[N-1][M], temp);\n        if(i == W[N][M]){\n            if(temp != pow3[N]-1){\n                //exit(1);\n            }\n        }\n        printf(\"%d \", temp);\n    }\n\n    /*printf(\"\\n\");\n    for(int i = 0; i < pow3[N]; i ++){\n        int temp = 0;\n        for(int n = 0; n < N; n ++){\n            temp += D[n][i%pow3[n+1]]*pow3[n];\n        }\n        printBase3(temp, N);\n        printf(\"\\n\");\n    }*/\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = pow(3, 12) + 100, maxm = 200010;\nint nxt[maxn], n, ans[maxn];\nint cnt = 1;\nstring w;\nvector<int> op;\nint gn(int val) {\n\tint res = 0, sc = 1;\n\twhile (val) {\n\t\tint v = val % 3;\n\t\tval /= 3;\n\t\tres += (v == 1 ? 2 : v == 2 ? 1 : 0) * sc;\n\t\tsc *= 3;\n\t}\n\treturn res;\n}\nvoid init() {\n\tfor (int i = 0;i < cnt;++i) \n\t\tnxt[i] = gn(i), ans[i] = i;\n//\tfor (int i =0;i < cnt;++i)\n//\t\tcerr << nxt[i] << ' ';\n//\tcerr << '\\n';\n//\texit(0);\n}\nvoid get_ans() {\n\tfor (int u : op) {\n\t\tfor (int i = 0;i < cnt;++i)\n\t\t\tans[i] = nxt[(ans[i] + u) % cnt];\n\t}\n\t\n}\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> n;\n\twhile (n--) cnt *= 3;\n\tinit();\n\tcin >> w;\n\tint len = 0, c = 0;\n\tfor (char i : w) {\n\t\tif (i == 'R') {\n\t\t\tif (c) op.pb(len), len = 0, c = 0;\n\t\t\t++len;\n\t\t}\n\t\telse \n\t\t\tc ^= 1;\n\t}\n\tif (c) op.pb(len), len = 0;\n\tif (op.size() <= 300) get_ans();\n\telse return -1;\n\tfor (int i = 0;i < cnt;++i)\n\t\tcout << (ans[i]+len) % cnt << ' ';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = pow(3, 12) + 100, maxm = 200010;\nint nxt[maxn], n, ans[maxn];\nint cnt = 1;\nstring w;\nvector<int> op;\nint gn(int val) {\n\tint res = 0, sc = 1;\n\twhile (val) {\n\t\tint v = val % 3;\n\t\tval /= 3;\n\t\tres += (v == 1 ? 2 : v == 2 ? 1 : 0) * sc;\n\t\tsc *= 3;\n\t}\n\treturn res;\n}\nvoid init() {\n\tfor (int i = 0;i < cnt;++i) \n\t\tnxt[i] = gn(i), ans[i] = i;\n//\tfor (int i =0;i < cnt;++i)\n//\t\tcerr << nxt[i] << ' ';\n//\tcerr << '\\n';\n//\texit(0);\n}\nvoid get_ans() {\n\tfor (int u : op) {\n\t\tfor (int i = 0;i < cnt;++i)\n\t\t\tans[i] = nxt[(ans[i] + u) % cnt];\n\t}\n\t\n}\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> n;\n\twhile (n--) cnt *= 3;\n\tinit();\n\tcin >> w;\n\tint len = 0, c = 0;\n\tfor (char i : w) {\n\t\tif (i == 'R') {\n\t\t\tif (c) op.pb(len), len = 0, c = 0;\n\t\t\t++len;\n\t\t}\n\t\telse \n\t\t\tc ^= 1;\n\t}\n\tif (c) op.pb(len), len = 0;\n  get_ans();\n\tfor (int i = 0;i < cnt;++i)\n\t\tcout << (ans[i]+len) % cnt << ' ';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define SZ(x) (int)x.size()-1\n#define F(i,a,b) for (int i=a;i<=b;++i)\n#define DF(i,a,b) for (int i=a;i>=b;--i)\n#define pb push_back\n#define ms(a,b) memset(a,b,sizeof a)\nusing namespace std;\nint read(){\n    char ch=getchar(); int w=1,c=0;\n    for (;!isdigit(ch);ch=getchar()) if (ch=='-') w=-1;\n    for (;isdigit(ch);ch=getchar()) c=(c<<3)+(c<<1)+(ch^48);\n    return w*c;\n}\nconst int M=6e5+10;\nint t[M][3],n,pw[M];\nint val[M],rt,tot,ans[M];\nbool tg[M];\nchar ch[M];\nvoid rev(int x){\n\ttg[x]^=1;\n\tswap(t[x][1],t[x][2]);\n}\nvoid pd(int x){\n\tif (tg[x]) {\n\t\tF(i,0,2)\n\t\trev(t[x][i]);\n\t\ttg[x]=0;\n\t}\n}\nvoid build(int &x,int dep,int o){\n\tx=++tot; val[x]=o;\n\tif (dep==n) return ;\n\tF(i,0,2) build(t[x][i],dep+1,o+pw[dep]*i);\n}\nvoid add(int x,int dep){\n\tif (dep==n) return ;\n\tpd(x);\n\tint t0=t[x][0],t1=t[x][1],t2=t[x][2];\n\tt[x][0]=t2; t[x][1]=t0; t[x][2]=t1; \n\tadd(t[x][0],dep+1);\n}\nvoid calc(int x,int dep,int o){\n\tif (dep==n){\n\t\tans[val[x]]=o; \n\t\treturn ;\n\t}\n\tpd(x);\n\tF(i,0,2) calc(t[x][i],dep+1,o+pw[dep]*i);\n}\nint main(){\n\tn=read(); scanf(\"%s\",ch+1); int m=strlen(ch+1);\n\tpw[0]=1; F(i,1,20) pw[i]=pw[i-1]*3;\n\tbuild(rt,0,0);\n\tF(i,1,m){\n\t\tif (ch[i]=='S') rev(rt);\n\t\telse add(rt,0);\n\t}\n\tcalc(1,0,0);\n\t\n\tF(i,0,pw[n]-1){\n\t\tcout<<ans[i]<<\" \";\n\t}\n\tcout<<\"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nint main(){\n    int n;\n    std::string t;\n    std::cin>>n>>t;\n    int temp=1;\n    int zhishu[n];\n    for(int i=0;i<n;++i){\n        temp*=3;\n        zhishu[i]=temp;\n    }\n    const int num=temp;\n    int ans[num];\n    int sub[num];\n    int c[num][12];\n    for(int i=0;i<num;++i){\n        ans[i]=i;\n        sub[i]=0;\n        for(int j=11;j>=12-n;--j){\n            c[i][j]=0;\n        }\n    }\n    for(int i=1;i<num;++i){\n        for(int j=0;j<12;++j){\n            c[i][j]=c[i-1][j];\n        }\n        c[i][11]++;\n        int j=11;\n        while(c[i][j]>=3){\n            c[i][j]-=3;\n            j--;\n            c[i][j]++;\n        }\n    }\n    for(int i=0;i<num;++i){\n        for(int j=12-n;j<12;++j){\n            if(c[i][j]==2){\n                sub[i]+=zhishu[11-j];\n            }\n        }\n    }\n    for(int i=0;i<t.size();++i){\n        if(t[i]=='S'){\n            if(i<t.size()-1){\n                if(t[i+1]=='S'){\n                    ++i;\n                    continue;\n                }\n            }\n            for(int j=0;j<num;++j){\n                temp=ans[j];\n                ans[j]=2*temp-sub[temp];\n            }\n        }\n        else{\n            for(int j=0;j<num;++j){\n                ans[j]++;\n                if(ans[j]>=num){\n                    ans[j]-=num;\n                }\n            }\n        }\n    }\n    std::cout<<ans[0];\n    for(int i=1;i<num;++i){\n        std::cout<<\" \"<<ans[i];\n    }\n    std::cout<<std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nint cur[531441][13];\nint reve[531441];\nchar c[200005];\nchar s[200005];\nint ans[531441];\nint n;\nint pow;\nvoid reverse(){\n    for(int i=0;i<pow;i++){\n        for(int j=0;j<n;j++){\n            if(cur[i][j]==1 or cur[i][j]==2) cur[i][j]=3-cur[i][j];\n        }\n    }\n}\nvoid plus(){\n    for(int i=0;i<pow;i++){\n        for(int j=0;j<n;j++){\n            cur[i][j]+=1;\n            if(cur[i][j]!=3) break;\n            else{\n                cur[i][j]=0;\n            }\n        }\n    }\n}\nint num(int k){\n    int ans=0;\n    for(int i=n-1;i>=0;i--){\n        ans*=3;\n        ans+=cur[k][i];\n    }\n    return ans;\n}\nint main() {\n    scanf(\"%d\",&n);\n    pow=1;\n    for(int i=0;i<n;i++){\n        pow*=3;\n    }\n    scanf(\"%s\",c);\n    int len=0;\n    for(int i=0;c[i]!='\\0';i++){\n        if(c[i]=='S'){\n            if(c[i+1]!='\\0' and c[i+1]=='S'){\n                i+=1;\n            }\n            else{\n                s[len]=c[i];\n                len++;\n            }\n        }\n        else{\n            s[len]=c[i];\n            len++;\n        }\n    }\n    for(int i=0;i<pow;i++){\n        int tem=i;\n        for(int j=0;j<n;j++){\n            cur[i][j]=tem%3;\n            tem/=3;\n        }\n    }\n    reverse();\n    for(int i=0;i<pow;i++){\n        reve[i]=num(i);\n    }\n    for(int i=0;i<pow;i++){\n        ans[i]=i;\n    }\n    for(int i=0;i<len;i++){\n        if(s[i]=='S'){\n            for(int j=0;j<pow;j++){\n                ans[j]=reve[ans[j]];\n            }\n        }\n        else{\n            for(int j=0;j<pow;j++){\n                ans[j]+=1;\n                ans[j]%=pow;\n            }\n        }\n    }\n    for(int i=0;i<pow;i++){\n        printf(\"%d \",ans[i]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <string>\n#include <algorithm>\n#include <utility>\n#define inf 1e18\n#define rep(x, s, t) for(int (x) = (s); (x) < (t); (x)++)\n#define Rep(x, s, t) for(int (x) = (s); (x) <= (t); (x)++)\n#define chmin(x, y) (x) = min((x), (y))\n#define chmax(x, y) (x) = max((x), (y))\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n;\nstring s;\nint beki[15];\nint carry[200005];\nint dest[600005], ndest[600005];\nset<int> S[3];\n\nint main(void)\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n;\n\tcin >> s;\n\t\n\tbeki[0] = 1;\n\tfor(int i = 1; i < 15; i++) beki[i] = beki[i-1] * 3;\n\t\n\tfor(int i = 0; i < 3; i++){\n\t\tint p = i;\n\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\tif(s[j] == 'R'){\n\t\t\t\tif(p == 2) carry[j] = i;\n\t\t\t\tp = (p+1) % 3;\n\t\t\t}\n\t\t\telse p = (3-p)%3;\n\t\t}\n\t\tdest[i] = p;\n\t}\n\t\n\tfor(int i = 1; i < n; i++){\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tS[j].clear();\n\t\t\tfor(int k = 0; k < beki[i]; k++){\n\t\t\t\tS[j].insert(j*beki[i]+k);\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\tif(s[j] == 'S') ;//swap(S[1], S[2]);\n\t\t\telse{\n\t\t\t\tint tmp[3];\n\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\tfor(int l = 0; l < 3; l++){\n\t\t\t\t\t\tint x = l*beki[i]+carry[j];\n\t\t\t\t\t\tif(S[k].count(x)){\n\t\t\t\t\t\t\ttmp[k] = x;\n\t\t\t\t\t\t\tif(k == 2) carry[j] = x;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\tS[k].erase(tmp[k]);\n\t\t\t\t\tS[(k+1)%3].insert(tmp[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tfor(auto it = S[j].begin(); it != S[j].end(); it++){\n\t\t\t\tndest[*it] = dest[*it%beki[i]] + j*beki[i];\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < beki[i+1]; j++) dest[j] = ndest[j];\n\t}\n\t\n\tfor(int i = 0; i < beki[n]; i++) cout << dest[i] << \" \"; cout << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\ntypedef vector<bool> vb;\ntypedef vector<vector<bool>> vvb;\ntypedef vector<vector<vector<bool>>> vvvb;\ntypedef pair<ll, ll> pll;\ntypedef vector<pll> vpll;\ntypedef vector<vpll> vvpll;\ntypedef vector<double> vd;\ntypedef vector<vd> vdd;\n\n#define FOR(i,x,y) for(ll i=(ll)x; i<(ll)y; ++i)\n#define REP(i,y) FOR(i, 0, y)\n#define RFOR(i,x,y) for(ll i=(ll)x; i>=(ll)y; --i)\n#define RREP(i,x) RFOR(i, x, 0)\n#define ALL(a) a.begin(), a.end()\n#define pb push_back\n#define debug_print(x...) cerr << \"line \" << __LINE__ << \" : \"; debug_print_in(x);\n\ntemplate <typename First>\nvoid debug_print_in(First first){\n  cerr << first << endl;\n  return;\n}\n\ntemplate <typename First, typename... Rest>\nvoid debug_print_in(First first, Rest... rest){\n  cerr << first << \" \";\n  debug_print_in(rest...);\n  return;\n}\n\nvoid IN(void){\n  return;\n}\n\ntemplate <typename First, typename... Rest>\nvoid IN(First& first, Rest&... rest){\n  cin >> first;\n  IN(rest...);\n  return;\n}\n\ntemplate <typename First>\nvoid OUT(First first){\n  cout << first << endl;\n  return;\n}\n\ntemplate <typename First, typename... Rest>\nvoid OUT(First first, Rest... rest){\n  cout << first << \" \";\n  OUT(rest...);\n  return;\n}\n\ntemplate<class t, class u> void chmax(t&a,u b){if(a<b)a=b;};\ntemplate<class t, class u> void chmin(t&a,u b){if(a>b)a=b;};\nint popcount(int t){return __builtin_popcount(t);} //GCC\nint popcount(ll t){return __builtin_popcountll(t);} //GCC\n\ntemplate <typename T>\nvoid vec_print(vector<T> VEC){\n  REP(i, VEC.size()){\n    cerr << VEC[i] << \" \";\n  }\n  cerr << endl;\n};\n\ntemplate <typename T>\nvoid mat_print(vector<vector<T> > MAT){\n  REP(i,MAT.size()){\n    REP(j,MAT[i].size()){\n      cerr << MAT[i][j] << \" \";\n    }\n    cerr << endl;\n  }\n};\n\nconstexpr int INF = (1<<30);\nconstexpr ll INFLL = 1LL<<62;\nconstexpr long double EPS = 1e-12;\nconstexpr ll MOD = (ll)((1E+9)+7);\n\nll N;\nstring T;\n\npair<vll, vll> solve(ll n){\n  if(n==0){\n    vll P0 = {0};\n    vll W0(T.size()+1, 0);\n    return make_pair(P0, W0);\n  }\n  auto PW_prev = solve(n-1);\n  auto P_old = PW_prev.first;\n  auto W_old = PW_prev.second;\n\n  /*\n  for(auto ans : PW_prev.first){\n    printf(\"%lld \", ans);\n  }\n  printf(\"\\n\");\n\n  for(auto tmp : PW_prev.second){\n    printf(\"%lld \", tmp);\n  }\n  printf(\"\\n\\n\");\n  */\n\n  vll P_new(P_old.size()*3);\n  vll D_new(P_old.size()*3);\n  vll W_new(W_old.size());\n\n  vll S_ahead_count(P_old.size()*3);\n  ll S_count = 0;\n\n  REP(i,D_new.size()) D_new[i] = i/P_old.size();\n\n  REP(i,T.size()){\n    auto W = W_old[i];\n    //debug_print(W);\n    auto c = T[i];\n    for(auto j=W; j<P_new.size(); j+=P_old.size()){\n      if((S_count-S_ahead_count[j])%2==1){\n        S_ahead_count[j] = S_count;\n        D_new[j] = (3-D_new[j])%3;\n      }\n      if(D_new[j]==2) W_new[i] = j;\n    }\n    if(c=='S'){\n      S_count++;\n    }else{\n      for(auto j=W; j<P_new.size(); j+=P_old.size()){\n        D_new[j] = (D_new[j]+1)%3;\n      }\n    }\n  }\n\n  //debug_print(i, W, c);\n  REP(k,P_new.size()){\n    ll D_tmp = D_new[k];\n    if((S_count-S_ahead_count[k])%2==1){\n      D_tmp = (3-D_new[k])%3;\n    }\n    P_new[k] = P_old[k%P_old.size()] + P_old.size()*D_tmp;\n    //printf(\"%lld \", D_tmp);\n  }\n\n  /*\n  printf(\"\\n\");\n  debug_print(i);\n  */\n\n  return make_pair(P_new, W_new);\n}\n\nint main(){\n  cin.tie(0); // cut the cin and cout (default, std::flush is performed after std::cin)\n  ios::sync_with_stdio(false); // cut the iostream and stdio (DON'T endl; BUT \"\\n\";)\n\n  IN(N);\n  IN(T);\n\n  auto PW = solve(N);\n\n  for(auto ans : PW.first){\n    printf(\"%lld \", ans);\n  }\n  printf(\"\\n\");\n\n  /*\n  for(auto tmp : PW.second){\n    printf(\"%lld \", tmp);\n  }\n  printf(\"\\n\");\n  */\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#define int long long\n \n#define pii pair<int, int>\n \n#define x1 x1228\n#define y1 y1228\n \n#define left left228\n#define right right228\n \n#define next next228\n \n#define pb push_back\n#define eb emplace_back\n \n#define mp make_pair                                                                \n                                                                                                                                        \n#define ff first                                                                  \n#define ss second   \n \n#define all(x) x.begin(), x.end()\n#define debug(x) cout << #x << \": \" << x << endl; \n#define TIME (ld)clock()/CLOCKS_PER_SEC\n \nusing namespace std;\ntypedef long long ll; \ntypedef long double ld; \n                                                                                                   \nconst int maxn = 2e5 + 7, mod = 1e9 + 7, MAXN = 1e6 + 7;\nconst double eps = 1e-9;\nconst ll inf = 1e18;\nmt19937 rnd(time(0));\nint n; \nstring s; \nint next[MAXN];\nconst int N = 2187; \nint dp1[N]; \nint dp2[N]; \nint xyz[N]; \n \nint get1(int mask, char q) {\n    if (q == 'R') {\n        ++mask; \n        return mask; \n    }   \n    int ptr = 1; \n    int ans = 0; \n    while (mask) {\n        int t = mask % 3; \n        mask /= 3; \n        if (t == 2) ans += ptr; \n        if (t == 1) ans += 2 * ptr; \n        ptr *= 3; \n    }\n    return ans; \n}\n \nconst int L = 12; \nint pref[maxn]; \nint to[maxn]; \nint kek1[N], kek2[N]; \nint res[N], res1[N]; \nint add = 1; \n \nint get(int x) {\n    vector<int> bts; \n    for (int i = 0; i < L; ++i) {\n        bts.pb(x % 3); \n        x /= 3; \n    }\n    int left = 0;\n    int right = 0; \n    for (int i = 6; i >= 0; --i) {\n        left *= 3;\n        left += bts[i]; \n    }\n    for (int i = L - 1; i >= 7; --i) {\n        right *= 3; \n        right += bts[i]; \n    }\n    int id = 0;         \n    if (left && dp1[left] == -1) {\n        if ((pref[(int)s.size()] - pref[id]) & 1) {        \n            right = xyz[right];     \n        }\n        return res[left] + add * right;   \n    }\n    if (left) {    \n        id = dp1[left]; \n        if (pref[id] & 1) {\n            ++right;\n            right = xyz[right];             \n        }\n        left = 0; \n    }                     \n    while (next[id] != -1) {        \n        if ((pref[next[id]] - pref[id]) & 1) {\n            right++; \n            right = xyz[right]; \n        }\n        id = next[id];                                                                                                                                         \n    }\n    if ((pref[(int)s.size()] - pref[id]) & 1) {        \n        right = xyz[right];     \n    }\n    left = to[id]; \n    return left + right * add; \n}\n \nvoid solve() {\n    for (int i = 0; i < N; ++i) {\n        xyz[i] = get1(i, 'S') % N; \n    }\n    cin >> n >> s; \n    int t = s.size(); \n    for (int i = 0; i < t; ++i) {\n        pref[i + 1] = pref[i] + (s[i] == 'S'); \n    }\n \n    for (int i = 0; i < N; ++i) dp1[i] = dp2[i] = -1; \n    next[t] = -1;\n    for (int i = 0; i < N; ++i) kek1[i] = i;              \n    for (int i = 0; i < N; ++i) res[i] = i; \n    for (int i = t - 1; i >= 0; --i) {\n        for (int mask = 0; mask < N; ++mask) {\n            int mask1; \n            if (s[i] == 'S') mask1 = xyz[mask]; \n            else mask1 = mask + 1; \n            if (mask1 >= N) mask1 -= N; \n            res1[mask] = res[mask1]; \n            kek2[mask] = kek1[mask1];\n            if (mask && mask1 == 0) {\n                dp2[mask] = i + 1; \n            } else {\n                dp2[mask] = dp1[mask1]; \n            }                                                                                 \n        }\n        to[i] = kek2[0]; \n        next[i] = dp2[0]; \n        for (int mask = 0; mask < N; ++mask) {\n            res[mask] = res1[mask]; \n            kek1[mask] = kek2[mask]; \n            dp1[mask] = dp2[mask]; \n            dp2[mask] = -1; \n        }\n    }\n    for (int i = 0; i < 7; ++i) add *= 3; \n    int tet = 1; \n    for (int i = 0; i < n; ++i) tet *= 3; \n    for (int ptr = 0; ptr < tet; ++ptr) {\n        cout << get(ptr) % tet << \" \"; \n    }\n//    cout << TIME; \n    return; \n}                                \n   \nsigned main() {\n#ifdef LOCAL\n    freopen(\"TASK.in\", \"r\", stdin);\n    freopen(\"TASK.out\", \"w\", stdout);\n#else \n    \n#endif // LOCAL\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20); \n    cout << fixed; \n    int t = 1; \n    for (int i = 0; i < t; ++i) {              \n        solve();\n    }\n    return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 9e6;\n\nint n;\nstruct {\n    int v;\n    int tag;\n} t[N];\n\nvoid build(int p, int v, int d) {\n    if (d > n) return;\n    t[p].v = v;\n    for (int i = 0; i < 3; i++) {\n        build(p * 3 + i, i, d + 1);\n    }\n}\n\nvoid pushdown(int p) {\n    \n    for (int i = 0; i < 3; i++) {\n        t[p * 3 + i].tag += t[p].tag;\n    }\n    if (t[p].tag & 1 && t[p].v) {\n        t[p].v ^= 3;\n    }\n    t[p].tag = 0;\n}\n\nvoid update(int p, int d) {\n    if (d >= n) return;\n    for (int i = 0; i < 3; i++) {\n        int x = p * 3 + i;\n        pushdown(x);\n\n        t[x].v++;\n        if (t[x].v == 3) {\n            t[x].v = 0;\n            update(x, d + 1);\n        }\n    }\n}\n\nint query(int p, int x, int d) {\n    if (d > n) return 0;\n    pushdown(p);\n    int res = t[p].v;\n    return query(p * 3 + x % 3, x / 3, d + 1) * 3 + res;\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\n    cin >> n;\n    string s;\n    cin >> s;\n    build(1, 0, 0);\n\n    for (auto c : s) {\n        if (c == 'S') {\n            t[1].tag++;\n        }\n        else {\n            pushdown(1);\n            update(1, 0);\n        }\n    }\n    int t = 1;\n    for (int i = 1; i <= n; i++) t *= 3;\n    for (int i = 0; i < t; i++) cout << query(1, i, 0) / 3 << ' ';\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,x,y,z,sw,pw3=1,A[531441],B[531441],S[531441];\nchar T[200001];\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nsigned main(void)\n{\n  x=scanf(\"%d %s\",&N,T);\n  replace(T,\"SS\",\"\");if(T[0]=='\\n')return 0;\n  rep(i,N)\n  {\n    rep(j,pw3)rep(k,3)B[j+k*pw3]=k;sw=1;\n    rep(p,strlen(T))\n    {\n      if(T[p]=='R')\n      {\n        y=S[p];\n        rep(j,3){x=y+j*pw3,z=B[x]*sw;if(z==-1||z==2)S[p]=x;B[x]+=(sw==1?1:2);B[x]%=3;}\n      }\n      else sw=-sw;\n    }\n    rep(j,pw3){y=A[j];rep(k,3){x=j+k*pw3;A[x]=y+((sw<0)?3-B[x]:B[x])%3*pw3;}}\n    pw3*=3;\n  }\n  rep(i,pw3)printf(\"%d%c\",A[i],i+1==pw3?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nint main() {\n  cout<<2<<\" \"<<0<<\" \"<<1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e6+7, KK = 12, RT = 6;\nint f[N], p3[N];\n\nvoid pre() {\n    p3[0] = 1;\n    for (int i=1; i<=KK; i++)    p3[i] = p3[i-1]*3;\n\n    for (int i=0; i<N; i++) {\n        for (int k=0; k<KK; k++) {\n            int d = (i/p3[k])%3;\n            if (d == 1)      f[i] += p3[k]*2;\n            else if (d == 2) f[i] += p3[k];\n        }\n    }\n\n}\n\nint aa[N], bb[N];\nvector<int> v[N];\nint asol[N];\nint temp[N];\n\nint vid[N];\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    pre();\n\n    int n;\n    string s;\n    cin>>n>>s;\n\n\n    int mx = p3[max(0, n-RT)];\n    int my = p3[min(RT, n)];\n    int all = p3[n];\n\n\n    for (int i=0; i<mx; i++)\n        for (int j=0; j<my; j++)\n            v[i].push_back(my*i + j);\n\n    for (int j=0; j<my; j++)    asol[j] = j;\n    for (int i=0; i<mx; i++)    vid[i] = i;\n\n    for (char c: s) {\n        if (c == 'R')  {\n            for (int i=0; i<mx; i++)    temp[i] = v[vid[i]][asol[my-1]];\n\n            int st = asol[my-1];\n            for (int i=my-1; i>0; i--)    asol[i] = asol[i-1];\n            asol[0] = st;\n\n            for (int i=1; i<mx; i++)    v[vid[i]][asol[0]] = temp[i-1];\n            v[vid[0]][asol[0]] = temp[mx-1];\n        }\n        else {\n            for (int i=0; i<my; i++)\n                if (f[i] > i)\n                    swap(asol[i], asol[f[i]]);\n\n            for (int i=0; i<mx; i++)\n                if (f[i] > i)\n                    swap(vid[i], vid[f[i]]);\n        }\n\n//        for (int i=0; i<my; i++)    cout<<asol[i]<<\" \"; cout<<\":::\"<<endl;\n//        for (int i=0; i<my; i++)    cout<<v[0][i]<<\" \"; cout<<\"---\"<<endl;\n    }\n\n    for (int i=0; i<mx; i++)\n        for (int j=0; j<my; j++)\n            aa[i*my+j] = v[vid[i]][asol[j]];\n\n\n    for (int i=0; i<all; i++) bb[aa[i]] = i;\n    for (int i=0; i<all; i++) cout<<bb[i]<<\" \";\n    cout<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<deque>\n#include<iomanip>\n#include<tuple>\n#include<cassert>\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<int,int> P;\ntypedef pair<LL,int> LP;\nconst int INF=1<<30;\nconst LL MAX=1e9+7;\n\nvoid array_show(int *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%d%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\nvoid array_show(LL *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%lld%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\nvoid array_show(vector<int> &vec_s,int vec_n=-1,char middle=' '){\n\tif(vec_n==-1)vec_n=vec_s.size();\n\tfor(int i=0;i<vec_n;i++)printf(\"%d%c\",vec_s[i],(i!=vec_n-1?middle:'\\n'));\n}\nvoid array_show(vector<LL> &vec_s,int vec_n=-1,char middle=' '){\n\tif(vec_n==-1)vec_n=vec_s.size();\n\tfor(int i=0;i<vec_n;i++)printf(\"%lld%c\",vec_s[i],(i!=vec_n-1?middle:'\\n'));\n}\n\nvector<vector<int>> v1[15];\nvector<vector<int>> vs;\n\nint main(){\n\tint n,m;\n\tint i,j,k;\n\tint a,b,c;\n\ta=0;\n\tstring sa;\n\tcin>>n;\n\tcin>>sa;\n\tv1[0].push_back(vector<int>());\n\tfor(i=0;i<sa.size();i++){\n\t\tif(sa[i]=='R')a++;\n\t\telse if(i+1<sa.size() && sa[i+1]=='S')i++;\n\t\telse{\n\t\t\tv1[0][0].push_back(a);\n\t\t\ta=0;\n\t\t}\n\t}\n\tv1[0][0].push_back(a);\n\tvs.push_back(vector<int>(1,0));\n\n\tfor(i=0;i<n;i++){\n\t\tc=pow(3,i);\n\t\tvs.push_back(vector<int>());\n\t\tfor(j=0;j<v1[i].size();j++){\n\t\t\tfor(k=0;k<3;k++){\n\t\t\t\tv1[i+1].push_back(vector<int>());\n\t\t\t\ta=k;\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(auto node:v1[i][j]){\n\t\t\t\t\tif(cnt && a>0)a=3-a;\n\t\t\t\t\ta+=node,cnt++;\n\t\t\t\t\tb=a/3;a%=3;\n\t\t\t\t\tv1[i+1].back().push_back(b);\n\t\t\t\t\t/*\n\t\t\t\t\tif(b==0 && !v1[i+1].back().empty() && v1[i+1].back().back()==0){\n\t\t\t\t\t\tv1[i+1].back().pop_back();\n\t\t\t\t\t}else v1[i+1].back().push_back(b);*/\n\t\t\t\t}\n\t\t\t\tvs[i+1].push_back(vs[i][j]+c*a);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tc=pow(3,n);\n\tvector<int> v2(c,-1);\n\tvector<int> vt(n,0);\n\tfor(i=0;i<c;i++){\n\t\ta=0;\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(vt[j]>=3)vt[j]-=3,vt[j+1]++;\n\t\t\ta*=3;\n\t\t\ta+=vt[j];\n\t\t}\n\t\tv2[a]=vs[n][i];\n\t\tvt[0]++;\n\t}\n\tarray_show(v2);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <string.h>\nusing namespace std;\n\nint *g_movs;\nint *g_movr;\nint g_total;\n\nint main(void)\n{\n    int n;\n    int ans = 0;\n    int t;\n    char *seq;\n    cin >> n;\n    g_total = 1;\n    for( int i = 0; i < n; i++) g_total *= 3;\n\n    {\n        string s;\n        getline(cin,s); // 改行読み飛ばし\n        getline(cin,s);\n\n        t = (int)(s.length());\n        seq = (char*)malloc(t);\n\n\n        for( int i = 0; i < t; i++)\n        {\n            if (s[i] == 'S') \n            {\n                seq[i] = 0;\n            }\n            else\n            {\n                seq[i] = 1;\n            }        \n        }\n    }\n\n    // テーブル作成\n    g_movs = (int*) malloc(sizeof(int) * g_total);\n    g_movr = (int*) malloc(sizeof(int) * g_total);\n    int *tmptable = (int*) malloc(sizeof(int) * n);\n    for( int i = 0; i < g_total; i++)\n    {\n        int tmp = i;\n        for( int j = 0; j < n; j++)\n        {\n            tmptable[j] = tmp % 3;\n            tmp /= 3;\n        }\n        tmp = 0;\n        for( int j = n - 1; j >= 0; j--)\n        {\n            tmp = tmp * 3;\n            if( tmptable[j] == 1 ) tmp += 2;\n            if( tmptable[j] == 2 ) tmp += 1;\n        }\n\n        g_movs[i] = tmp;\n\n        if( i == 0 )\n        {\n            g_movr[i] = g_total - 1;\n        }\n        else\n        {\n            g_movr[i] = i - 1;\n        }\n    }\n\n    int *pos1 = (int*) malloc(sizeof(int) * g_total);\n    int *pos2 = (int*) malloc(sizeof(int) * g_total);\n    int *current = pos1;\n\n    for( int i = 0; i < g_total; i++) current[i] = i;\n\n    for( int j = 0; j < t; j++ )\n    {\n        int *next = pos2;\n        if(current == pos2 ) next = pos1;\n\n        int *ct = g_movs;\n        if( seq[j] == 1 )  ct = g_movr;\n        for( int i = 0; i < g_total; i++)\n        {\n            next[ct[i]] = current[i];\n        }\n        \n        current = next;\n    }\n\n    {\n        for( int i = 0; i < g_total; i++)\n        {\n            cout << current[i] << \" \";\n//            cout << next[i] << \" \";\n        }\n    }\n\n    free(seq);\n    free(g_movs);\n    free(g_movr);\n    free(tmptable);\n    free(pos1);\n    free(pos2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 200222, inf = 1000111222;\nconst int max_tot = 729 * 729;\nconst int max_half = 729;\nconst int max_big = max_tot / max_half;\n\nchar buf[max_n];\n\nstring read() {\n    scanf(\"%s\", buf);\n    return buf;\n}\n\nint n, nxt[max_n][max_half];\nint prec[max_half], ans[max_tot], res[max_big];\nint sum[max_n];\nint pw;\n\nint get_sum(int l, int r) {\n    if (!l) {\n        return sum[r];\n    }\n    return sum[r] - sum[l - 1];\n}\n\nvoid get_all_prec() {\n    pw = 1;\n    for (int i = 0; i < n; ++i) {\n        pw *= 3;\n    }\n    for (int x = 0; x < pw; ++x) {\n        vector<int> v;\n        int cur = x;\n        for (int i = 0; i < n; ++i) {\n            v.push_back(cur % 3);\n            cur /= 3;\n        }\n        reverse(v.begin(), v.end());\n        int to = 0;\n        for (int i = 0; i < n; ++i) {\n            int x = (v[i] * 2) % 3;\n            to = to * 3 + x;\n        }\n        prec[x] = to;\n    }\n}\n\nconst bool debug = 0;\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    string s;\n    if (debug) {\n        mt19937 gen;\n        n = 12;\n        for (int i = 0; i < 200000; ++i) {\n            s += \"SR\"[gen() % 2];\n        }\n    } else {\n        scanf(\"%d\", &n);\n        s = read();\n    }\n    get_all_prec();\n    const int half = min(max_half, pw);\n    for (int x = 0; x < half; ++x) {\n        nxt[s.length()][x] = -1 - x;\n    }\n    for (int i = 0; i < s.length(); ++i) {\n        sum[i] = s[i] == 'S';\n        if (i) {\n            sum[i] += sum[i - 1];\n        }\n    }\n    int tot = 0;\n    for (int i = s.length() - 1; i >= 0; --i) {\n        for (int x = 0; x < half; ++x) {\n            int to = prec[x];\n            if (s[i] == 'R') {\n                to = x + 1;\n            }\n            if (to == half) {\n                nxt[i][x] = i;\n            } else {\n                nxt[i][x] = nxt[i + 1][to];\n            }\n            tot += nxt[i][x];\n            //cout << nxt[i][x] << \" \";\n        }\n        //cout << endl;\n    }\n    int mx = pw / half;\n    for (int ismall = 0; ismall < half; ++ismall) {\n        for (int big = 0; big < mx; ++big) {\n            res[big] = big;\n        }\n        int small = ismall;\n        int pos = 0;\n        while (pos < s.length()) {\n            //cout << pos << \": \" << big << \" \" << small << endl;\n            if (nxt[pos][small] < 0) {\n                small = -1 - nxt[pos][small];\n                if (get_sum(pos, s.length() - 1) % 2) {\n                    for (int big = 0; big < mx; ++big) {\n                        res[big] = prec[res[big]];\n                    }\n                }\n                pos = s.length();\n            } else {\n                int to = nxt[pos][small];\n                if (get_sum(pos, to) % 2) {\n                    for (int big = 0; big < mx; ++big) {\n                        res[big] = prec[res[big]] + 1;\n                        if (res[big] == mx) {\n                            res[big] = 0;\n                        }\n                    }\n                } else {\n                    for (int big = 0; big < mx; ++big) {\n                        res[big] = res[big] + 1;\n                        if (res[big] == mx) {\n                            res[big] = 0;\n                        }\n                    }\n                }\n                small = 0;\n                pos = to + 1;\n            }\n        }\n        for (int big = 0; big < mx; ++big) {\n            ans[big * half + ismall] = res[big] * half + small;\n        }\n    }\n    for (int i = 0; i < pw; ++i) {\n        printf(\"%d \", ans[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;++A)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n\n\nll N,Np;\nchar T[202020];\nll Tn;\nll p3[30];\n\nll i, j, k;\n\nvoid salsa(ll n,ll& c,ll& d)\n{\n    if(1&(n^c)){\n        d = d == 0 ? 0 : 3 - d;\n        c ^= 1;\n    }\n}\n\npair<vector<ll>,vector<ll>> calc(ll n,char *T){\n    if(n==0){\n        vector<ll> P = {0};\n        vector<ll> L(Tn, 0);\n        return {P, L};\n    }\n    ll i, j, k;\n    auto r = calc(n - 1, T);\n    ll N = p3[n-1];\n    vector<ll> &P = r.first;\n    vector<ll> &L = r.second;\n    vector<ll> P2(N * 3, 0), L2(Tn, 0), C(N * 3, 0), D(N * 3, 0);\n    fornum(i,0,3){\n        fornum(j,0,N){\n            D[i * N + j] = i;\n        }\n    }\n    ll snum = 0;\n    fornum(i,0,Tn){\n        ll l = L[i];\n        fornum(j,0,3){\n            salsa(snum, C[l + j * N], D[l + j * N]);\n            if (D[l + j * N] == 2)\n                L2[i] = l + j * N;\n        }\n        if(T[i]=='S'){\n            ++snum;\n        }else{\n            fornum(j,0,3)\n                (D[l + j * N] += 1) %= 3;\n        }\n    }\n    fornum(i,0,N*3){\n        salsa(snum, C[i], D[i]);\n        P2[i] = P[i%N] + D[i] * N;\n        //printf(\"%lld \", P2[i]);\n    }\n    //printf(\":%lld\\n\", n);\n    return {P2, L2};\n\n\n\n}\nint main(){\n    scanf(\"%lld%s\", &Np, T);\n    Tn = strlen(T);\n    p3[0] = 1;\n    fornum(j,0,Np){\n        p3[j + 1] = p3[j] * 3;\n    }\n    N = p3[Np];\n    auto ret = calc(Np, T).first;\n    \n    fornum(i,0,N){\n        printf(\"%lld \", ret[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\nusing namespace std;\n\nint n, len, l[3*3*3*3*3*3*3*3*3*3*3*3];\nstring t;\n\nint calc(int a) {\n\tif (a < 3) {\n\t\treturn a % 3 - 1 + (a + 1) % 3;\n\t}\n\telse {\n\t\treturn a % 3 - 1 + (a + 1) % 3 + 3 * calc(a / 3);\n\t}\n}\n\nint main()\n{\n\tcin >> n;\n\tcin >> t;\n\tn = pow(3, n);\n\tfor (int i = 0; i < n; i++) {\n\t\tl[i] = i;\n\t}\n\tfor (int i = 0; i < t.size(); i++) {\n\t\tif (t[i] == 'S') {\n\t\t\tif (t[i + 1] == 'S') {\n\t\t\t\tt[i] = '0';\n\t\t\t\tt[i + 1] = '0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << t << endl;\n\tfor (int i = 0; i < t.size(); i++) {\n\t\tif (t[i] == 'S') {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tl[j] = calc(l[j]);\n\t\t\t}\n\t\t}\n\t\telse if(t[i] == 'R'){\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tl[j] = l[j] + 1;\n\t\t\t\tif (l[j] >= n) {\n\t\t\t\t\tl[j] = l[j] % n;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << l[i] << \" \";\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <string>\n#include <algorithm>\n#include <utility>\n#define inf 1e18\n#define rep(x, s, t) for(int (x) = (s); (x) < (t); (x)++)\n#define Rep(x, s, t) for(int (x) = (s); (x) <= (t); (x)++)\n#define chmin(x, y) (x) = min((x), (y))\n#define chmax(x, y) (x) = max((x), (y))\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n;\nstring s;\nint beki[15];\nint carry[200005];\nint dest[600005], ndest[600005];\nset<int> S[3];\n\nint main(void)\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n;\n\tcin >> s;\n\t\n\tbeki[0] = 1;\n\tfor(int i = 1; i < 15; i++) beki[i] = beki[i-1] * 3;\n\t\n\tfor(int i = 0; i < 3; i++){\n\t\tint p = i;\n\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\tif(s[j] == 'R'){\n\t\t\t\tif(p == 2) carry[j] = i;\n\t\t\t\tp = (p+1) % 3;\n\t\t\t}\n\t\t\telse p = (3-p)%3;\n\t\t}\n\t\tdest[i] = p;\n\t}\n\t\n\tfor(int i = 1; i < n; i++){\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tS[j].clear();\n\t\t\tfor(int k = 0; k < beki[i]; k++){\n\t\t\t\tS[j].insert(j*beki[i]+k);\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < s.size(); j++){\n\t\t\tif(s[j] == 'S') swap(S[1], S[2]);\n\t\t\telse{\n\t\t\t\tint tmp[3];\n\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\tfor(int l = 0; l < 3; l++){\n\t\t\t\t\t\tint x = l*beki[i]+carry[j];\n\t\t\t\t\t\tif(S[k].count(x)){\n\t\t\t\t\t\t\ttmp[k] = x;\n\t\t\t\t\t\t\tif(k == 2) carry[j] = x;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k = 0; k < 3; k++){\n\t\t\t\t\tS[k].erase(tmp[k]);\n\t\t\t\t\tS[(k+1)%3].insert(tmp[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < 3; j++){\n\t\t\tfor(auto it = S[j].begin(); it != S[j].end(); it++){\n\t\t\t\tndest[*it] = dest[*it%beki[i]] + j*beki[i];\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < beki[i+1]; j++) dest[j] = ndest[j];\n\t}\n\t\n\tfor(int i = 0; i < beki[n]; i++) cout << dest[i] << \" \"; cout << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <math.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint main(){    \n  ll N;\n  string T;\n  cin >> N >> T;\n  ll t = T.size();\n  ll n = pow(3,N);\n  string a;\n  for(int i = 1; i <= n; i++){\n    a.at(11) = i%3;\n    a.at(10) = i/3%3;\n    a.at(9) = i/3/3%3;\n    a.at(8) = i/3/3/3%3;\n    a.at(7) = i/3/3/3/3%3;\n    a.at(6) = 1/3/3/3/3/3%3;\n    a.at(5) = 1/3/3/3/3/3/3%3;\n    a.at(4) = 1/3/3/3/3/3/3/3%3;\n    a.at(3) = 1/3/3/3/3/3/3/3/3%3;\n    a.at(2) = 1/3/3/3/3/3/3/3/3/3%3;\n    a.at(1) = 1/3/3/3/3/3/3/3/3/3/3%3;\n    a.at(0) = 1/3/3/3/3/3/3/3/3/3/3/3%3;\n    for(ll j = 1; j < t; j++){\n      if(T.at(j) == 's'){\n        for(ll k = 0; k < 12; k++){\n          if(a.at(k) == '1') a.at(k) = '2';\n          else if(a.at(k) == '2') a.at(k) = '1';\n        }\n      }\n      else{\n        if (a.at(11) == '0') a.at(11) = '1';\n        else if(a.at(11) == '1') a.at(11) = '2';\n        else{\n          a.at(11) = '0';\n          if (a.at(10) == '0') a.at(10) = '1';\n          else if(a.at(10) == '1') a.at(10) = '2';\n          else{\n            a.at(10) = '0';\n            if (a.at(9) == '0') a.at(9) = '1';\n            else if(a.at(9) == '1') a.at(9) = '2';\n            else{\n              a.at(9) = '0';\n              if (a.at(8) == '0') a.at(8) = '1';\n              else if(a.at(8) == '1') a.at(8) = '2';\n              else{\n                a.at(8) = '0';\n            if (a.at(7) == '0') a.at(7) = '1';\n            else if(a.at(7) == '1') a.at(7) = '2';\n            else{\n              a.at(7) = '0';\n            if (a.at(6) == '0') a.at(6) = '1';\n            else if(a.at(6) == '1') a.at(6) = '2';\n            else{\n      a.at(6) = '0';\n            if (a.at(5) == '0') a.at(5) = '1';\n            else if(a.at(5) == '1') a.at(5) = '2';\n            else{\n              a.at(5) = '0';\n            if (a.at(4) == '0') a.at(4) = '1';\n            else if(a.at(4) == '1') a.at(4) = '2';\n            else{\n              a.at(4) = '0';\n            if (a.at(3) == '0') a.at(3) = '1';\n            else if(a.at(3) == '1') a.at(3) = '2';\n            else{\n              a.at(3) = '0';\n            if (a.at(2) == '0') a.at(2) = '1';\n            else if(a.at(2) == '1') a.at(2) = '2';\n            else{\n              a.at(2) = '0';\n            if (a.at(1) == '0') a.at(1) = '1';\n            else if(a.at(1) == '1') a.at(1) = '2';\n            else{\n              a.at(1) = '0';\n            if (a.at(0) == '0') a.at(0) = '1';\n            else if(a.at(0) == '1') a.at(0) = '2';\n            else a = \"000000000000\";\n            }\n            }\n            }\n            }\n            }\n            }\n            }\n              }\n            }\n          }\n        }\n      }\n    }\n\tll ans = pow(3,11)*a.at(0) +pow(3,10)*a.at(1) + pow(3,9)*a.at(2) + pow(3,8)*a.at(3) + pow(3,7)*a.at(4) + pow(3,6)*a.at(5) + pow(3,5)*a.at(6) + pow(3,4)*a.at(7) + pow(3,3)*a.at(8) + 9*a.at(9) + 3*a.at(10) + a.at(11);\n      cout << ans << \" \";\n    \n  }\n  cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing Pdi = pair<double, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\n\n\nsigned main(){\n\n    int N; cin >> N;\n    string T; cin >> T;\n\n    mat d(N);\n    int n = 1;\n    REP(i, N){\n        d[i].resize(3 * n);\n        REP(j, 3 * n) d[i][j] = j / n;\n        n *= 3;\n    }\n\n    bool flip = false;\n    for(char t: T){\n        if(t == 'S') flip = !flip;\n        else{\n            if(!flip){\n                int i0 = 0, n = 1;\n                REP(k, N){\n                    for(int i = i0; i < 3 * n; i += n){\n                        if(d[k][i] == 0) d[k][i] = 1;\n                        else if(d[k][i] == 1) d[k][i] = 2;\n                        else if(d[k][i] == 2){\n                            d[k][i] = 0;\n                            i0 = i;\n                        }\n                    }\n                    n *= 3;\n                }\n            }else{\n                int i0 = 0, n = 1;\n                REP(k, N){\n                    for(int i = i0; i < 3 * n; i += n){\n                        if(d[k][i] == 0) d[k][i] = 2;\n                        else if(d[k][i] == 2) d[k][i] = 1;\n                        else if(d[k][i] == 1){\n                            d[k][i] = 0;\n                            i0 = i;\n                        }\n                    }\n                    n *= 3;\n                }\n            }\n        }\n    }\n    //mdebug(d);\n\n    n = SZ(d[N - 1]);\n    vec ans(n, 0);\n    REP(i, n){\n        int m = 1;\n        REP(k, N){\n            int b = d[k][i % (3 * m)];\n            if(flip && b >= 1) b = 3 - b;\n            ans[i] += m * b;\n\n            m *= 3;\n        }\n    }\n    REP(i, n) cout << ans[i] << ' ';\n    cout << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#define int long long\n \n#define pii pair<int, int>\n \n#define x1 x1228\n#define y1 y1228\n \n#define left left228\n#define right right228\n \n#define next next228\n \n#define pb push_back\n#define eb emplace_back\n \n#define mp make_pair                                                                \n                                                                                                                                        \n#define ff first                                                                  \n#define ss second   \n \n#define all(x) x.begin(), x.end()\n#define debug(x) cout << #x << \": \" << x << endl; \n#define TIME (ld)clock()/CLOCKS_PER_SEC\n \nusing namespace std;\ntypedef long long ll; \ntypedef long double ld; \n                                                                                                   \nconst int maxn = 2e5 + 7, mod = 1e9 + 7, MAXN = 1e6 + 7;\nconst double eps = 1e-9;\nconst ll inf = 1e18;\nmt19937 rnd(time(0));\nint n; \nstring s; \nint next[MAXN];\nconst int N = 2187; \nint dp1[N]; \nint dp2[N]; \nint xyz[N]; \n \nint get1(int mask, char q) {\n    if (q == 'R') {\n        ++mask; \n        return mask; \n    }   \n    int ptr = 1; \n    int ans = 0; \n    while (mask) {\n        int t = mask % 3; \n        mask /= 3; \n        if (t == 2) ans += ptr; \n        if (t == 1) ans += 2 * ptr; \n        ptr *= 3; \n    }\n    return ans; \n}\n \nconst int L = 12; \nint pref[maxn]; \nint to[maxn]; \nint kek1[N], kek2[N]; \nint res[N], res1[N]; \nint add = 1; \n \nint get(int x) {\n    vector<int> bts; \n    for (int i = 0; i < L; ++i) {\n        bts.pb(x % 3); \n        x /= 3; \n    }\n    int left = 0;\n    int right = 0; \n    for (int i = 6; i >= 0; --i) {\n        left *= 3;\n        left += bts[i]; \n    }\n    for (int i = L - 1; i >= 7; --i) {\n        right *= 3; \n        right += bts[i]; \n    }\n    int id = 0;         \n    if (left && dp1[left] == -1) {\n        if (pref[(int)s.size()] & 1) right = xyz[right];   \n        return res[left] + add * right;   \n    }\n    if (left) {    \n        id = dp1[left]; \n        if (pref[id] & 1) right = xyz[right];             \n        left = 0; \n    }                     \n    while (next[id] != -1) {        \n        if ((pref[next[id]] - pref[id]) & 1) right = xyz[right]; \n        id = next[id];                                                                                                                                         \n    }\n    if ((pref[(int)s.size()] - pref[id]) & 1) right = xyz[right]; \n    left = to[id]; \n    return left + right * add; \n}\n \nvoid solve() {\n    for (int i = 0; i < N; ++i) {\n        xyz[i] = get1(i, 'S') % N; \n    }\n    cin >> n >> s; \n    int t = s.size(); \n    for (int i = 0; i < t; ++i) {\n        pref[i + 1] = pref[i] + (s[i] == 'S'); \n    }\n \n    for (int i = 0; i < N; ++i) dp1[i] = dp2[i] = -1; \n    next[t] = -1;\n    for (int i = 0; i < N; ++i) kek1[i] = i;              \n    for (int i = 0; i < N; ++i) res[i] = i; \n    for (int i = t - 1; i >= 0; --i) {\n        for (int mask = 0; mask < N; ++mask) {\n            int mask1; \n            if (s[i] == 'S') mask1 = xyz[mask]; \n            else mask1 = mask + 1; \n            if (mask1 >= N) mask1 -= N; \n            res1[mask] = res[mask1]; \n            kek2[mask] = kek1[mask1];\n            if (mask && mask1 == 0) {\n                dp2[mask] = i + 1; \n            } else {\n                dp2[mask] = dp1[mask1]; \n            }                                                                                 \n        }\n        to[i] = kek2[0]; \n        next[i] = dp2[0]; \n        for (int mask = 0; mask < N; ++mask) {\n            res[mask] = res1[mask]; \n            kek1[mask] = kek2[mask]; \n            dp1[mask] = dp2[mask]; \n            dp2[mask] = -1; \n        }\n    }\n    for (int i = 0; i < 7; ++i) add *= 3; \n    int tet = 1; \n    for (int i = 0; i < n; ++i) tet *= 3; \n    for (int ptr = 0; ptr < tet; ++ptr) {\n        cout << get(ptr) % tet << \" \"; \n    }\n//    cout << TIME; \n    return; \n}                                \n   \nsigned main() {\n#ifdef LOCAL\n    freopen(\"TASK.in\", \"r\", stdin);\n    freopen(\"TASK.out\", \"w\", stdout);\n#else \n    \n#endif // LOCAL\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20); \n    cout << fixed; \n    int t = 1; \n    for (int i = 0; i < t; ++i) {              \n        solve();\n    }\n    return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n#define all(c) ((c).begin()), ((c).end())\n#define sz(x) ((int)(x).size())\n#define ld long double\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\", \"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tfor(int i = 0;i < (int)v.size(); i++){\n\t\tif(i)os<<\", \";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\n#ifdef LOCAL\n#define cerr cout\n#else\n#endif\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\nconst int M = 5.5e5;\nint nxt[2][M], nxt2[2][1005], nxt3[2][1005];\nint p[M];\nint q[M];\nchar s[M];\nint type[M], cnt[M];\nint U = 1, V = 1, W = 1, n, MID, POS;\nint bad[1005];\nint isBAD[1005];\nint perm[1005];\n\nint lft[M], rgt[M];\n\nvoid get(int l, int r){\n\tmemset(isBAD, 0, sizeof isBAD);\n\tPOS = 0;\n\tfor(int i = 0; i < U; i++){\n\t\tint curr = i;\n\t\tbool isBad = false;\n\t\tfor(int j = l; j <= r; j++){\n\t\t\tif(type[j] && curr == U - 1){\n\t\t\t\tbad[POS++] = i;\n\t\t\t\tisBAD[i] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurr = nxt2[type[j]][curr];\n\t\t\t\n\t\t}\n\t\tperm[i] = curr;\n\t}\n\n\tint flipped = (cnt[r] - cnt[l - 1]) & 1;\n\tfor(int i = 0; i < V; i++){\n\t\tint L = lft[i], R = rgt[i];\n\t\tif(isBAD[R]){\n\t\t\tint curr = i;\n\t\t\tfor(int j = l; j <= r; j++) curr = nxt[type[j]][curr];\n\t\t\tq[i] = curr;\n\t\t} else{\n\t\t\tq[i] = (flipped ? nxt3[0][L] : L) * U + perm[R];\n\t\t}\n\t}\n}\n\nint transform(int v, int k){\n\tint pwr = 1, ret = 0;\n\tint V = v;\n\tfor(int i = 0; i < k; i++, pwr *= 3, v /= 3){\n\t\tint t = (2 * v) % 3;\n\t\tret += t * pwr;\n\t}\n\treturn ret;\n}\nint h[M];\nint main(){\n\tsd(n);\n\tscanf(\"%s\", s);\n\tint m = strlen(s);\n\tfor(int i = 1; i <= m; i++){\n\t\ttype[i] = s[i - 1] == 'R';\n\t\tcnt[i] = cnt[i - 1] + 1 - type[i];\n\t}\n\tMID = (n + 1) / 2;\n\tfor(int i = 0; i < n; i++) V *= 3;\n\tfor(int i = 0; i < MID; i++) U *= 3;\n\tfor(int i = 0; i < n - MID; i++) W *= 3;\n\n\tfor(int i = 0; i < V; i++){\n\t\tnxt[0][i] = transform(i, n);\n\t\tnxt[1][i] = (i + 1) % V;\n\t}\n\n\tfor(int i = 0; i < U; i++){\n\t\tnxt2[0][i] = transform(i, MID);\n\t\tnxt2[1][i] = (i + 1) % U;\n\t}\n\n\tfor(int i = 0; i < W; i++){\n\t\tnxt3[0][i] = transform(i, n - MID);\n\t\tnxt3[1][i] = (i + 1) % W;\n\t}\n\n\tfor(int i = 0; i < V; i++){\n\t\tlft[i] = i / U;\n\t\trgt[i] = i % U;\n\t\tp[i] = i;\n\t}\n\n\tconst int SQN = sqrt(n) + 3;\n\t\n\tfor(int i = 1; i <= m; i += SQN){\n\t\tget(i, min(m + 1, i + SQN) - 1);\n\t\tfor(int j = 0; j < V; j++) h[j] = q[p[j]];\n\t\tmemcpy(p, h, sizeof p);\n\t}\n\n\tfor(int i = 0; i < V; i++) printf(\"%d \", p[i]);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,avx,avx2\")\n#include <immintrin.h>\n#endif\n\n#define hur(f, g) template<class c> int f(c a) {if (sizeof(c) == 8) return g##ll(a); else return g(a);}\nhur(popc, __builtin_popcount) hur(ctz, __builtin_ctz) hur(clz, __builtin_clz)\n\n/*\n\t- place bitset modifications here\n*/\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define le(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)2e6];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\n// void fast_print(__int128 x) {\n// \tif (x == 0) { fast_print('0'); return; }\n// \tif (x < 0) {\n// \t\tfast_print('-');\n// \t\tx = -x;\n// \t}\n// \t__int128 p = 1;\n// \twhile (x / (p * 10)) p *= 10;\n// \twhile (p) {\n// \t\t__int128 symb = x / p;\n// \t\tfast_print((int)symb);\n// \t\tx -= p * symb;\n// \t\tp /= 10;\n// \t}\n// };\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tinline T floor_mod(T a, const T &b) {\n\t\ta %= b;\t\n\t\tif (a < 0) a += b;\n\t\treturn a;\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint n;\nstring s;\n\nstruct Node {\n\tint mod = 0;\n\tint go[3];\n\tint id;\n};\n\nvector<Node> S(1);\n\nint create_node() {\n\tS.pb({0, 0, 0, 0});\n\treturn le(S) - 1;\n}\nint rev(int i) {\n\tvector<int> digs;\n\tf(t, n) {\n\t\tdigs.pb(i % 3);\n\t\ti /= 3;\n\t}\n\tint rez = 0;\n\tfor (int x : digs) {\n\t\trez = rez * 3 + x;\n\t}\n\treturn rez;\n}\nint iter = 0;\nint init(int depth) {\n\tint i = create_node();\n\tif (depth == 0) {\n\t\tS[i].id = iter; \n\t\titer++;\n\t} else {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tint t = init(depth - 1);\n\t\t\tS[i].go[j] = t;\n\t\t}\n\t}\n\treturn i;\n}\n\nvoid push(int i, int depth) {\n\tassert(depth);\n\tif (S[i].mod) {\n\t\tswap(S[i].go[1], S[i].go[2]);\n\t\tf(t, 3) {\n\t\t\tS[S[i].go[t]].mod ^= 1;\n\t\t}\n\t\tS[i].mod = 0;\n\t}\n}\n\nvoid inc(int i, int depth) {\n\tif (depth) {\n\t\tpush(i, depth);\n\t\t// rotate(S[i].go, S[i].go + 1, S[i].go + 3);\n\t\t// reverse(S[i].go, S[i].go + 3);\n\t\ttie(S[i].go[0], S[i].go[1], S[i].go[2])\n\t\t\t= mt(S[i].go[2], S[i].go[0], S[i].go[1]);\n\t\tinc(S[i].go[0], depth - 1);\n\t}\n}\n\nvoid extract(int i, int depth, vector<int> &rez) {\n\tif (!depth) {\n\t\trez.pb(S[i].id);\n\t} else {\n\t\tpush(i, depth);\n\t\tf(t, 3) {\n\t\t\textract(S[i].go[t], depth - 1, rez);\n\t\t}\n\t}\n}\n\nvector<int> inv(vector<int> p) {\n\tvector<int> q(le(p));\n\tfor (int i = 0; i < le(p); i++) {\n\t\tq[p[i]] = i;\n\t}\n\treturn q;\n}\nint comp_l(int i) {\n\tvector<int> digs;\n\tf(t, n) {\n\t\tdigs.pb(i % 3);\n\t\ti /= 3;\n\t}\n\treverse(digs.begin(), digs.end());\n\tint rez = 0;\n\tfor (int x : digs) {\n\t\tif (x == 1 || x == 2)\n\t\t\tx = 3 - x;\n\t\trez = rez * 3 + x;\n\t}\n\treturn rez;\n}\nsigned main(signed argc, char *argv[]) {\n\tscan n;\n\tscan s;\n\tint root = init(n);\n\tint N = 1;\n\tf(i, n) N *= 3;\n\tvector<int> stp(N);\n\tiota(stp.begin(), stp.end(), 0);\n\tfor (char c : s) {\n\t\tvector<int> nstp = stp;\n\t\tif (c == 'S') {\n\t\t\tS[root].mod ^= 1;\t\n\t\t\tf(i, N) {\n\t\t\t\tint j = comp_l(i);\n\t\t\t\tnstp[j] = stp[i];\n\t\t\t}\n\t\t} else {\n\t\t\tf(i, N) {\n\t\t\t\tnstp[(i + 1) % N] = stp[i];\n\t\t\t}\n\t\t\tinc(root, n);\n\t\t}\n\t\tstp = nstp;\n\t\tvector<int> t;\n\t\textract(root, n, t);\n\t}\n\t{\n\t\tvector<int> rez;\n\t\textract(root, n, rez);\n\t\tvector<int> sub = rez;\n\t\tf(i, le(sub)) {\n\t\t\tsub[rev(i)] = rev(rez[i]);\n\t\t}\n\t\tprint inv(sub);\n\t}\n\t// vector<int> where = rez;\n\t// f(i, le(where)) {\n\t// \twhere[rez[i]] =i;\n\t// }\n\t// print rez;\n\t// print where;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define cs const\n#define pb push_back\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define ll long long\n#define bg begin\nnamespace IO{\n\t\ncs int RLEN=1<<20|1;\nchar ibuf[RLEN],*ib,*ob;\ninline char gc(){\n\t(ib==ob)&&(ob=(ib=ibuf)+fread(ibuf,1,RLEN,stdin));\n\treturn (ib==ob)?EOF:*ib++;\n}\ninline int read(){\n\tchar ch=gc();\n\tint res=0;bool f=1;\n\twhile(!isdigit(ch))f^=ch=='-',ch=gc();\n\twhile(isdigit(ch))res=(res*10)+(ch^48),ch=gc();\n\treturn f?res:-res;\n}\ninline int readstring(char *s){\n\tint top=0;char ch=gc();\n\twhile(isspace(ch))ch=gc();\n\twhile(!isspace(ch)&&ch!=EOF)s[++top]=ch,ch=gc();\n\treturn top;\n}\n\n}\nusing IO::read;\nusing IO::readstring;\ntemplate<typename tp>inline void chemx(tp &a,tp b){a=max(a,b);}\ntemplate<typename tp>inline void chemn(tp &a,tp b){a=min(a,b);}\ncs int N=700005,M=16;\nint pw[M];\nchar str[N];\nint n,m,tot,id[N],ans[N],lc[N],rc[N],pc[N],rev[N];\nvoid build(int &u,int dep,int ps){\n\tu=++tot;\n\tif(dep==n){\n\t\tid[u]=ps;\n\t\treturn;\n\t}\n\tbuild(lc[u],dep+1,ps);\n\tbuild(rc[u],dep+1,ps+pw[dep]);\n\tbuild(pc[u],dep+1,ps+2*pw[dep]);\n}\nvoid pushnow(int u){\n\trev[u]^=1,swap(rc[u],pc[u]);\n}\nvoid pushdown(int u){\n\tif(!rev[u])return;\n\tif(lc[u])pushnow(lc[u]);\n\tif(rc[u])pushnow(rc[u]);\n\tif(pc[u])pushnow(pc[u]);\n\trev[u]=0;\n}\nvoid move(int u,int dep){\n\tpushdown(u);\n\tif(dep==n)return;\n\tswap(rc[u],pc[u]),swap(rc[u],lc[u]);\n\tmove(lc[u],dep+1);\n}\nvoid dfs(int u,int dep,int ps){\n\tpushdown(u);\n\tif(dep==n){ans[id[u]]=ps;return;}\n\tdfs(lc[u],dep+1,ps);\n\tdfs(rc[u],dep+1,ps+pw[dep]);\n\tdfs(pc[u],dep+1,ps+2*pw[dep]);\n}\nint main(){\n\t#ifdef Stargazer\n\tfreopen(\"lx.in\",\"r\",stdin);\n\t#endif\n\tn=read();pw[0]=1;int rt=0;\n\tm=readstring(str);\n\tfor(int i=1;i<M;i++)pw[i]=pw[i-1]*3;\n\tbuild(rt,0,0);\n\tfor(int i=1;i<=m;i++)\n\tif(str[i]=='S')pushnow(rt);\n\telse move(rt,0);\n\tdfs(rt,0,0);\n\tfor(int i=0;i<pw[n];i++)cout<<ans[i]<<\" \";puts(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = pow(3, 12) + 100, maxm = 200010;\nint nxt[maxn], n, ans[maxn];\nint cnt = 1;\nstring w;\nvector<int> op;\nint gn(int val) {\n\tint res = 0, sc = 1;\n\twhile (val) {\n\t\tint v = val % 3;\n\t\tval /= 3;\n\t\tres += (v == 1 ? 2 : v == 2 ? 1 : 0) * sc;\n\t\tsc *= 3;\n\t}\n\treturn res;\n}\nvoid init() {\n\tfor (int i = 0;i < cnt;++i) \n\t\tnxt[i] = gn(i), ans[i] = i;\n//\tfor (int i =0;i < cnt;++i)\n//\t\tcerr << nxt[i] << ' ';\n//\tcerr << '\\n';\n//\texit(0);\n}\nvoid get_ans() {\n\tfor (int u : op) {\n\t\tfor (int i = 0;i < cnt;++i)\n\t\t\tans[i] = nxt[(ans[i] + u) % cnt];\n\t}\n\t\n}\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> n;\n\twhile (n--) cnt *= 3;\n\tinit();\n\tcin >> w;\n\tint len = 0, c = 0;\n\tfor (char i : w) {\n\t\tif (i == 'R') {\n\t\t\tif (c) op.pb(len), len = 0, c = 0;\n\t\t\t++len;\n\t\t}\n\t\telse \n\t\t\tc ^= 1;\n\t}\n\tif (c) op.pb(len), len = 0;\n\tif ((ll)op.size() * cnt <= 3e9) get_ans();\n\telse return -1;\n\tfor (int i = 0;i < cnt;++i)\n\t\tcout << (ans[i]+len) % cnt << ' ';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <string>\n#include <vector> \n#include <algorithm>\n#include <functional>\n#include <map>\n#include <queue>\n#include <cmath>\n#include <limits>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\nusing namespace std;\nusing P = pair<int,int>;\n\nint main() {\n  //input\n  int n;\n  cin >> n;\n  string t;\n  cin >> t;\n\n  int arrcount = (int)pow(3,n);\n\n  //pattern making\n  int pattern[arrcount];\n\n  rep(x, arrcount) {\n    int tmp = x;\n    pattern[x] = 0;\n    string s = \"\";\n    //cout << pattern[i] << \"->\";\n    // to 3 shin\n    while(tmp > 0) {\n      int j = tmp % 3;\n      s = to_string(j) + s;\n      tmp = (tmp - j) / 3;\n    }\n    if(s == \"\") s = \"0\";\n    //cout << s << \"->\";\n    //translate\n    replace(s.begin(), s.end(), '2', 'x');\n    replace(s.begin(), s.end(), '1', '2');\n    replace(s.begin(), s.end(), 'x', '1');\n    //cout << s << \"->\";\n    // to 10 shin\n    int j = 1;\n    while(s.length()) {\n      //pattern[i] += m[(char)s.substr(s.length()-1)] * j;\n      pattern[x] += ((char)s.substr(s.length()-1)[0] - '0') * j;\n      s.erase(s.length()-1);\n      j *= 3;\n    }\n    //cout << pattern[i] << \" \";\n    //cout << endl;\n  }\n\n  int arr[arrcount];\n  rep(i,arrcount) arr[i] = i;\n  rep(i, t.length()) {\n    if(t[i] == 'S') {\n      //S\n\n      int arrtmp[arrcount];\n      rep(i,arrcount) {\n        arrtmp[i] = pattern[arr[i]];\n      }\n      memcpy(arr, arrtmp, sizeof(arrtmp));\n    } else {\n      //R\n      rep(i,arrcount) {\n        arr[i]++;\n        if(arr[i] == arrcount) arr[i] = 0;\n      }\n      \n    }\n  }\n  \n  rep(i,arrcount) cout << arr[i] << \" \";\n  cout << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "// C.cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 631441;\n\nint n, ptot = 1, ans[MAX_N], triple[MAX_N];\nchar str[MAX_N];\n\nstruct node\n{\n    int ch[3], val, pos;\n    bool tag;\n} nodes[MAX_N << 1];\n\nvoid pushdown(int p)\n{\n    if (nodes[p].tag)\n    {\n        swap(nodes[p].ch[1], nodes[p].ch[2]), nodes[p].tag = false;\n        for (int i = 0; i < 3; i++)\n            if (nodes[p].ch[i])\n                nodes[nodes[p].ch[i]].tag ^= 1;\n    }\n}\n\nvoid update(int p)\n{\n    if (p == 0)\n        return;\n    pushdown(p);\n    int tmp = nodes[p].ch[2];\n    nodes[p].ch[2] = nodes[p].ch[1], nodes[p].ch[1] = nodes[p].ch[0], nodes[p].ch[0] = tmp;\n    update(nodes[p].ch[0]);\n}\n\nvoid insert(int x, int ps)\n{\n    int p = 1;\n    for (int i = 0; i < n; i++)\n    {\n        int b = x % 3;\n        if (nodes[p].ch[b] == 0)\n            nodes[p].ch[b] = ++ptot;\n        p = nodes[p].ch[b], x /= 3;\n    }\n    nodes[p].pos = ps;\n}\n\nvoid collect(int u, int acc, int dep)\n{\n    if (dep == n)\n        return (void)(ans[nodes[u].pos] = acc);\n    pushdown(u);\n    for (int i = 0; i < 3; i++)\n        if (nodes[u].ch[i])\n            collect(nodes[u].ch[i], acc + triple[dep] * i, dep + 1);\n}\n\nint main()\n{\n    scanf(\"%d%s\", &n, str + 1);\n    int upper = triple[0] = 1;\n    for (int i = 1; i <= n; i++)\n        upper *= 3, triple[i] = upper;\n    for (int i = 0; i < upper; i++)\n        insert(i, i);\n    for (int i = 1; str[i]; i++)\n        if (str[i] == 'S')\n            nodes[1].tag ^= 1, pushdown(1);\n        else\n            update(1);\n    collect(1, 0, 0);\n    for (int i = 0; i < upper; i++)\n        printf(\"%d \", ans[i]);\n    puts(\"\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "fij4eifjefjie"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint flip(int n) {\n    vector<int> digits;\n    while (n > 0) {\n        digits.push_back(n % 3);\n        n /= 3;\n    }\n    reverse(digits.begin(), digits.end());\n    int res = 0;\n    for (int d: digits) {\n        res *= 3;\n        if (d == 1) {\n            res += 2;\n        } else if (d == 2) {\n            res += 1;\n        }\n    }\n    return res;\n}\nint pow(int a, int n) {\n    int res = 1;\n    for (int i = 0; i < n; ++i)\n        res *= a;\n    return res;\n}\nint main() {\n    assert(flip(0) == 0);\n    assert(flip(1) == 2);\n    assert(flip(2) == 1);\n    assert(flip(46) == 65);\n    assert(flip(65) == 46);\n    assert(pow(3, 3) == 27);\n    assert(pow(3, 0) == 1);\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    const int low_bits = min(max(n / 2 + 1, 1), 6);\n    const int high_bits = n - low_bits;\n    const int n_low = pow(3, low_bits);\n    const int n_high = pow(3, high_bits);\n    vector<int> salsa(pow(3, max(low_bits, high_bits)));\n    for (int i = 0; i < (int) salsa.size(); ++i) {\n        salsa[i] = flip(i);\n    }\n    vector<int> low(n_low);\n    vector<vector<int>> kick(n_low);\n    iota(low.begin(), low.end(), 0);\n    int f = 0;\n    for (char c: s) {\n        if (c == 'S') {\n            ++f;\n            for (int i = 0; i < (int) low.size(); ++i) {\n                low[i] = salsa[low[i]];\n            }\n        } else {\n            for (int i = 0; i < (int) low.size(); ++i) {\n                ++low[i];\n                if (low[i] == (int) low.size()) {\n                    kick[i].push_back(f);\n                    low[i] = 0;\n                }\n            }\n        }\n    }\n    for (int i = 0; i < pow(3, n); ++i) {\n        int a = i / low.size();\n        int b = i % low.size();\n        int prev_f = 0;\n        for (int i = 0; i < (int) kick[b].size(); ++i) {\n            if ((kick[b][i] - prev_f) % 2 > 0) {\n                a = salsa[a];\n            }\n            a = (a + 1) % n_high;\n            prev_f = kick[b][i];\n        }\n        if ((f - prev_f) % 2 > 0) {\n            a = salsa[a];\n        }\n        cout << a * n_low + low[b] << \" \";\n    }\n    cout << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#define int long long\n \n#define pii pair<int, int>\n \n#define x1 x1228\n#define y1 y1228\n \n#define left left228\n#define right right228\n \n#define next next228\n \n#define pb push_back\n#define eb emplace_back\n \n#define mp make_pair                                                                \n                                                                                                                                        \n#define ff first                                                                  \n#define ss second   \n \n#define all(x) x.begin(), x.end()\n#define debug(x) cout << #x << \": \" << x << endl; \n#define TIME (ld)clock()/CLOCKS_PER_SEC\n \nusing namespace std;\ntypedef long long ll; \ntypedef long double ld; \n                                                                                                   \nconst int maxn = 2e5 + 7, mod = 1e9 + 7, MAXN = 1e6 + 7;\nconst double eps = 1e-9;\nconst ll inf = 1e18;\nmt19937 rnd(time(0));\nint n; \nstring s; \nint next[MAXN];\nconst int N = 2187; \nint dp1[N]; \nint dp2[N]; \nint xyz[N]; \n \nint get1(int mask, char q) {\n    if (q == 'R') {\n        ++mask; \n        return mask; \n    }   \n    int ptr = 1; \n    int ans = 0; \n    while (mask) {\n        int t = mask % 3; \n        mask /= 3; \n        if (t == 2) ans += ptr; \n        if (t == 1) ans += 2 * ptr; \n        ptr *= 3; \n    }\n    return ans; \n}\n \nconst int L = 12; \nint pref[maxn]; \nint to[maxn]; \nint kek1[N], kek2[N]; \nint res[N], res1[N]; \nint add = 1; \n \nint get(int x) {\n    vector<int> bts; \n    for (int i = 0; i < L; ++i) {\n        bts.pb(x % 3); \n        x /= 3; \n    }\n    int left = 0;\n    int right = 0; \n    for (int i = 6; i >= 0; --i) {\n        left *= 3;\n        left += bts[i]; \n    }\n    for (int i = L - 1; i >= 7; --i) {\n        right *= 3; \n        right += bts[i]; \n    }\n    int id = 0; \n    if (left && dp1[left] == -1) {\n        return res[left] + add * right;   \n    }\n    if (left) {    \n        id = dp1[left]; \n        if (pref[id] & 1) right = xyz[right];             \n        left = 0; \n    }                     \n    while (next[id] != -1) {        \n        if ((pref[next[id]] - pref[id]) & 1) right = xyz[right]; \n        id = next[id];                                                                                                                                         \n    }\n    left = to[id]; \n    return left + right * add; \n}\n \nvoid solve() {\n    for (int i = 0; i < N; ++i) {\n        xyz[i] = get1(i, 'S') % N; \n    }\n    cin >> n >> s; \n    int t = s.size(); \n    for (int i = 0; i < t; ++i) {\n        pref[i + 1] = pref[i] + (s[i] == 'S'); \n    }\n \n    for (int i = 0; i < N; ++i) dp1[i] = dp2[i] = -1; \n    next[t] = -1;\n    for (int i = 0; i < N; ++i) kek1[i] = i;              \n    for (int i = 0; i < N; ++i) res[i] = i; \n    for (int i = t - 1; i >= 0; --i) {\n        for (int mask = 0; mask < N; ++mask) {\n            int mask1; \n            if (s[i] == 'S') mask1 = xyz[mask]; \n            else mask1 = mask + 1; \n            if (mask1 >= N) mask1 -= N; \n            res1[mask] = res[mask1]; \n            kek2[mask] = kek1[mask1];\n            if (mask && mask1 == 0) {\n                dp2[mask] = i + 1; \n            } else {\n                dp2[mask] = dp1[mask1]; \n            }   \n        }\n        to[i] = kek2[0]; \n        next[i] = dp2[0]; \n        for (int mask = 0; mask < N; ++mask) {\n            res[mask] = res1[mask]; \n            kek1[mask] = kek2[mask]; \n            dp1[mask] = dp2[mask]; \n            dp2[mask] = -1; \n        }\n    }\n    for (int i = 0; i < 7; ++i) add *= 3; \n    int tet = 1; \n    for (int i = 0; i < n; ++i) tet *= 3; \n    for (int ptr = 0; ptr < tet; ++ptr) {\n//        get(ptr); \n        cout << get(ptr) % tet << \" \"; \n    }\n//    cout << TIME; \n    return; \n}                                \n   \nsigned main() {\n#ifdef LOCAL\n    freopen(\"TASK.in\", \"r\", stdin);\n    freopen(\"TASK.out\", \"w\", stdout);\n#else \n    \n#endif // LOCAL\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20); \n    cout << fixed; \n    int t = 1; \n    for (int i = 0; i < t; ++i) {              \n        solve();\n    }\n    return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,x,y,pos,tri0,tri1,tri2,pw3[13]={1},A[531441],salsa[531441],sw[200001];\nchar T[200001];\nvoid OUT(int x){if(x<0)putchar('-'),x=-x;if(x>=10)OUT(x/10);putchar(x%10+48);}\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nsigned main(void)\n{\n  x=scanf(\"%d %s\",&N,T+1);\n  replace(T+1,\"SS\",\"\");if(T[0]=='\\n')return 0;\n  rep(i,N)pw3[i+1]=3*pw3[i];\n  tri0=pw3[N],tri1=pw3[N/2],tri2=pw3[N-N/2];\n  rep(i,tri0)salsa[i]=salsa[i/3]*3+(3-i%3)%3;\n  rep(i,tri1)\n  {\n    x=i,pos=0;\n    rep(j,strlen(T+1))\n    {\n      if(T[j+1]=='S'){x=salsa[x];if(sw[pos]>0)pos--;else sw[++pos]=1;}\n      if(T[j+1]=='R'){x++;if(x==tri1)sw[++pos]=-1,x=0;}\n    }\n    rep(j,tri2)\n    {\n      y=j;\n      rep(k,pos){if(sw[k+1]>0)y=salsa[y];else if(sw[k+1]<0){if((++y)==tri2)y=0;}}\n      A[i+j*tri1]=y*tri1+x;\n    }\n  }\n  rep(i,tri0)printf(\"%d\\t\",A[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,nn,ans[1010101],nm[1010101],cc[1010101][3],tg[1010101],tt=1;\nstring s;\nvoid ii(int x)\n{\n\tint nw=1,y=x;\n\tfor(int i=n;i>=1;i--,x/=3)\n\t{\n\t\tint nww=x%3;\n\t\tif(!cc[nw][nww])\n\t\t{\n\t\t\ttt++;\n\t\t\tcc[nw][nww]=tt;\n\t\t}\n\t\tnw=cc[nw][nww];\n\t}\n\tnm[nw]=y+1;\n}\nvoid gx(int x)\n{\n\tswap(cc[x][1],cc[x][2]);\n\ttg[x]=0;\n\tfor(int i=0;i<3;i++)\n\t{\n\t\ttg[cc[x][i]]^=1;\n\t}\n}\nvoid jj()\n{\n\tint nw=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(tg[nw])\n\t\t{\n\t\t\tgx(nw);\n\t\t}\n\t\tswap(cc[nw][0],cc[nw][2]);\n\t\tswap(cc[nw][1],cc[nw][2]);\n\t\tnw=cc[nw][0];\n\t}\n}\nvoid dfs(int x,int pp,int pw)\n{\n\tif(tg[x])\n\t{\n\t\tgx(x);\n\t}\n\tif(nm[x]>0)\n\t{\n\t\tans[nm[x]-1]=pp;\n\t\treturn;\n\t}\n\tfor(int i=0;i<3;i++)\n\t{\n\t\tdfs(cc[x][i],pp+i*pw,pw*3);\n\t}\n}\nint main()\n{\n\tcin>>n>>s;\n\tnn=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tnn*=3;\n\t}\n\tfor(int i=0;i<nn;i++)\n\t{\n\t\tii(i);\n\t}\n\tfor(int i=0;i<s.size();i++)\n\t{\n\t\tif(s[i]=='S')\n\t\t{\n\t\t\ttg[1]^=1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tjj();\n\t\t}\n\t}\n\tdfs(1,0,1);\n\tfor(int i=0;i<nn;i++)\n\t{\n\t\tcout<<ans[i]<<' ';\n\t}\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*input\n3\nSRSRRSRRRSRRRR\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define eb emplace_back\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (int)(lower_bound(c.begin(),c.end(),x)-c.begin())\n#define EL cout<<'\\n'\n#define BS(a,x) binary_search(ALL(a),x)\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\ntemplate<typename T>\nostream& operator<<(ostream& out,vector<T> V){\n\tREP(i,SZ(V)) out<<V[i]<<((i!=SZ(V)-1)?\" \":\"\");\n\treturn out;\n}\n//}}}\nconst ll maxn=300005;\nconst ll maxlg=20;\nconst ll INF64=1e18;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=ll(1e9+7);\nconst ld PI=acos(-1);\nconst ld eps=1e-9;\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nconst int N = 531441;\n\ninline int flip(int n,int len){\n\tint bs = 1;\n\tint ret = 0;\n\tREP(i,len){\n\t\tint cur = n%3;\n\t\tn/=3;\n\t\tif(cur) cur = 3-cur;\n\t\tret+=bs*cur;\n\t\tbs *= 3;\n\t}\n\treturn ret;\n}\n\nint n;\nstring s;\nvector<int> a;\n\nstring op[12][N];\n\nint res[12][N];\n\nint main(){\n\tIOS;\n\tcin>>n>>s;\n\tstring tmp;\n\tREP(i,SZ(s)){\n\t\tif(s[i]=='R') tmp.pb(s[i]);\n\t\telse{\n\t\t\tif(SZ(tmp)&&tmp.back()=='S') tmp.pop_back();\n\t\t\telse tmp.pb(s[i]);\n\t\t}\n\t}\n\n\top[0][0] = tmp;\n\tres[0][0] = 0;\n\n\tint mx = 1;\n\tfor(int len = 1; len <= n; len++){\n\t\tfor(int i=0;i<3;i++) for(int j=0;j<mx;j++){\n\t\t\tint msb = i;\n\t\t\top[len][i*mx+j].clear();\n\t\t\tfor(char ch:op[len-1][j]){\n\t\t\t\tif(ch=='S'){\n\t\t\t\t\tif(msb) msb = 3-msb;\n\t\t\t\t\tif(SZ(op[len][i*mx+j])&&op[len][i*mx+j].back()=='S'){\n\t\t\t\t\t\top[len][i*mx+j].pop_back();\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\top[len][i*mx+j].pb('S');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmsb++;\n\t\t\t\t\tif(msb == 3){\n\t\t\t\t\t\tmsb = 0;\n\t\t\t\t\t\top[len][i*mx+j].pb('R');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tres[len][i*mx+j] = msb*mx+res[len-1][j];\n\t\t}\n\t\tmx*=3;\n\t}\n\tREP(i,mx){\n\t\tcout<<res[n][i]<<\" \\n\"[i==mx-1];\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#define rep(i,a,b) for(register int i=a;i<=b;i++)\nusing namespace std;\nint n,m,root=0,tot=0;\nint f[20][3],ans[1000010];\nchar s[1000010];\nstruct Tree{\n\tint ch[3],val,rev;\n}t[3000010];\nvoid setup(){\n\tf[0][1]=1;\n\tf[0][2]=2;\n\tfor(register int i=1;i<=n;i++){\n\t\tf[i][1]=f[i-1][1]*3;\n\t\tf[i][2]=f[i-1][2]*3;\n\t}\n}\nvoid reverse(int x){\n\tt[x].rev^=1;\n\tswap(t[x].ch[1],t[x].ch[2]);\n}\nvoid pushdown(int x){\n\tif(t[x].rev){\n\t\tt[x].rev=0;\n\t\treverse(t[x].ch[0]);\n\t\treverse(t[x].ch[1]);\n\t\treverse(t[x].ch[2]);\n\t}\n}\nvoid build(int &now,int k,int val){\n\tnow=++tot;\n\tif(!k){\n\t\tt[now].val=val;\n\t\treturn;\n\t}\n\tbuild(t[now].ch[0],k-1,val);\n\tbuild(t[now].ch[1],k-1,val+f[n-k][1]);\n\tbuild(t[now].ch[2],k-1,val+f[n-k][2]);\n}\nvoid rotate(int x,int k){\n\tswap(t[x].ch[0],t[x].ch[1]);\n\tswap(t[x].ch[0],t[x].ch[2]);\n\tif(!k)return;\n\tpushdown(x);\n\trotate(t[x].ch[0],k-1);\n}\nvoid dfs(int x,int k,int val){\n\tif(!k){\n\t\tans[t[x].val]=val;\n\t\treturn;\n\t}\n\tpushdown(x);\n\tdfs(t[x].ch[0],k-1,val);\n\tdfs(t[x].ch[1],k-1,val+f[n-k][1]);\n\tdfs(t[x].ch[2],k-1,val+f[n-k][2]);\n}\nint main(){\n\tscanf(\"%d%s\",&n,s+1);\n\tsetup();\n\tm=strlen(s+1);\n\tbuild(root,n,0);\n\trep(i,1,m){\n\t\tif(s[i]=='S'){\n\t\t\treverse(root);\n\t\t}\n\t\telse{\n\t\t\trotate(root,n);\n\t\t}\n\t}\n\tdfs(root,n,0);\n\tint lim=1;\n\tfor(register int i=1;i<=n;i++)lim*=3;\n\tfor(register int i=0;i<lim;i++)printf(\"%d \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nusing ll = long long;\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\n#define MAX(a, b) (((a) < (b)) ? (b) : (a))\n\nstring reduce(string s2){\n  string result;\n  int last = 0;\n  for(int i = 0; i < s2.size(); i++) {\n    if(0 < result.size() && result.back() == 'S' && s2[i] == 'S')\n      result.pop_back();\n    else\n      result += s2[i];\n  }\n  return result;\n}\n\nint powp(int n){\n  int result = 1;\n  for(int i = 0; i < n; i++)\n    result *= 3;\n  return result;\n}\n\nvector<int> solve(int n, string s){\n  if(n == 0){\n    vector<int> temp;\n    temp.push_back(0);\n    return temp;\n  }\n  s = reduce(s);\n  int lim = powp(n);\n  vector<int> sol(lim);\n\n  for(int i = 0; i < 3; i++){\n    int curr = i;\n    string s0;\n    for(int j = 0; j < s.size(); j++){\n      if(s[j] == 'R')\n        curr++;\n      else {\n        if(curr == 2)\n          curr = 1;\n        else if(curr == 1)\n          curr = 2;\n      }\n      if(s[j] == 'S')\n        s0 += \"S\";\n      else if(curr == 3){\n        curr = 0;\n        s0 += \"R\";\n      }\n    }\n    vector<int> sol0 = solve(n - 1, s0);\n    for(int j = 0; j < lim / 3 ; j++)\n      sol[j * 3 + i] = sol0[j] * 3 + curr;\n  }\n  return sol;\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n  string s;\n  cin >> s;\n  vector<int> sol = solve(n, s);\n  for(int i = 0; i < sol.size(); i++)\n    cout << sol[i] << \" \";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#define int long long\n \n#define pii pair<int, int>\n \n#define x1 x1228\n#define y1 y1228\n \n#define left left228\n#define right right228\n \n#define next next228\n \n#define pb push_back\n#define eb emplace_back\n \n#define mp make_pair                                                                \n                                                                                                                                        \n#define ff first                                                                  \n#define ss second   \n \n#define all(x) x.begin(), x.end()\n#define debug(x) cout << #x << \": \" << x << endl; \n#define TIME (ld)clock()/CLOCKS_PER_SEC\n \nusing namespace std;\ntypedef long long ll; \ntypedef long double ld; \n                                                                                                   \nconst int maxn = 2e5 + 7, mod = 1e9 + 7, MAXN = 1e6 + 7;\nconst double eps = 1e-9;\nconst ll inf = 1e18;\nmt19937 rnd(time(0));\nint n; \nstring s; \nint next[MAXN];\nconst int N = 2187; \nint dp1[N]; \nint dp2[N]; \nint xyz[N]; \n \nint get1(int mask, char q) {\n    if (q == 'R') {\n        ++mask; \n        return mask; \n    }   \n    int ptr = 1; \n    int ans = 0; \n    while (mask) {\n        int t = mask % 3; \n        mask /= 3; \n        if (t == 2) ans += ptr; \n        if (t == 1) ans += 2 * ptr; \n        ptr *= 3; \n    }\n    return ans; \n}\n \nconst int L = 12; \nint pref[maxn]; \nint to[maxn]; \nint kek1[N], kek2[N]; \nint res[N], res1[N]; \nint add = 1; \n \nvoid print(int x) {\n    while (x) {\n        cout << x % 3 << \" \"; \n        x /= 3; \n    }\n    cout << '\\n'; \n}\n\nint get(int x) {\n    vector<int> bts; \n    for (int i = 0; i < L; ++i) {\n        bts.pb(x % 3); \n        x /= 3; \n    }\n    int left = 0;\n    int right = 0; \n    for (int i = 6; i >= 0; --i) {\n        left *= 3;\n        left += bts[i]; \n    }\n    for (int i = L - 1; i >= 7; --i) {\n        right *= 3; \n        right += bts[i]; \n    }\n    int id = 0;         \n    if (left && dp1[left] == -1) {\n        if ((pref[(int)s.size()] - pref[id]) & 1) {        \n            right = xyz[right];     \n        }\n        return res[left] + add * right;   \n    }\n    if (left) {    \n        id = dp1[left]; \n        ++right;\n        if (pref[id + 1] & 1) {\n            right = xyz[right];             \n        }\n        left = 0; \n    }                     \n    while (next[id] != -1) {        \n        right++; \n        if ((pref[next[id]] - pref[id]) & 1) {\n            right = xyz[right]; \n        }\n        id = next[id];                                                                                                                                         \n    }\n    if ((pref[(int)s.size()] - pref[id]) & 1) {        \n        right = xyz[right];     \n    }\n    left = to[id]; \n    return left + right * add; \n}\n \nvoid solve() {\n    for (int i = 0; i < N; ++i) {\n        xyz[i] = get1(i, 'S') % N; \n    }\n    cin >> n >> s; \n    int t = s.size(); \n    for (int i = 0; i < t; ++i) {\n        pref[i + 1] = pref[i] + (s[i] == 'S'); \n    }\n \n    for (int i = 0; i < N; ++i) dp1[i] = dp2[i] = -1; \n    next[t] = -1;\n    for (int i = 0; i < N; ++i) kek1[i] = i;              \n    for (int i = 0; i < N; ++i) res[i] = i; \n    for (int i = t - 1; i >= 0; --i) {\n        for (int mask = 0; mask < N; ++mask) {\n            int mask1; \n            if (s[i] == 'S') mask1 = xyz[mask]; \n            else mask1 = mask + 1; \n            if (mask1 >= N) mask1 -= N; \n            res1[mask] = res[mask1]; \n            kek2[mask] = kek1[mask1];\n            if (mask && mask1 == 0) {\n                dp2[mask] = i + 1; \n            } else {\n                dp2[mask] = dp1[mask1]; \n            }                                                                                 \n        }\n        to[i] = kek2[0]; \n        next[i] = dp2[0]; \n        for (int mask = 0; mask < N; ++mask) {\n            res[mask] = res1[mask]; \n            kek1[mask] = kek2[mask]; \n            dp1[mask] = dp2[mask]; \n            dp2[mask] = -1; \n        }\n    }\n    for (int i = 0; i < 7; ++i) add *= 3; \n    int tet = 1; \n    for (int i = 0; i < n; ++i) tet *= 3; \n    for (int ptr = 0; ptr < tet; ++ptr) {\n        cout << get(ptr) % tet << \" \"; \n    }\n//    cout << TIME; \n    return; \n}                                \n   \nsigned main() {\n#ifdef LOCAL\n    freopen(\"TASK.in\", \"r\", stdin);\n    freopen(\"TASK.out\", \"w\", stdout);\n#else \n    \n#endif // LOCAL\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20); \n    cout << fixed; \n    int t = 1; \n    for (int i = 0; i < t; ++i) {              \n        solve();\n    }\n    return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int>pii;\ntypedef long long ll;\ntypedef pair<ll,ll>pll;\ntypedef __int128 lll;\nconst ll mod=1e9+7;\nconst int mn=6e5+10;\nint p[mn],lst[mn],np[mn],nl[mn];\nint sw;\nint at[mn];\nint eval(int x){\n    if(sw^at[x]){\n        at[x]=sw;\n        if(np[x]>=1)np[x]=3-np[x];\n    }\n    return np[x];\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    string s;\n    cin>>n>>s;\n\n    for(int i=1,po=1;i<=n;i++,po*=3){\n        sw=0;\n        memset(at,0,sizeof(at));\n        for(int j=0;j<po*3;j++)np[j]=j/po;\n        for(int j=0;j<s.size();j++){\n            if(s[j]=='S'){\n                sw^=1;\n            }\n            else{\n                int lo=j?(lst[j-1]):(po-1);\n                np[lo]=(eval(lo)+1)%3;\n                np[lo+po]=(eval(lo+po)+1)%3;\n                np[lo+po*2]=(eval(lo+po*2)+1)%3;\n            }\n            if(eval(lst[j])==2)nl[j]=0;\n            else if(eval(lst[j]+po)==2)nl[j]=1;\n            else nl[j]=2;\n        }\n        for(int j=po*3-1;j>=0;j--)p[j]=p[j%po]+eval(j)*po;\n        for(int j=0;j<s.size();j++)lst[j]+=nl[j]*po;\n        if(i==n)for(int j=0;j<po*3;j++)printf(\"%d \",p[j]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define snd second\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef long double ldb;\n\ntemplate<class T> inline void checkmin(T &a,const T &b){if(b<a) a=b;}\ntemplate<class T> inline void checkmax(T &a,const T &b){if(b>a) a=b;}\n\nconst int inf=1e9+10;\nconst int maxn=1e6+10;\n\nint a[maxn*3][3],d[maxn*3],id[maxn*3],ans[maxn];\nint n,p[15];\nstring s;\n\nvoid build(int c,int x,int pos){\n\tif(c==n){\n\t//\tcout<<x<<\" \"<<pos<<endl;\n\t\tid[x]=pos;\n\t\treturn;\n\t}\n\tfor(int i=0;i<3;i++){\n\t\ta[x][i]=x*3+i;\n\t\tbuild(c+1,x*3+i,pos+i*p[c]);\n\t}\n}\n\nvoid apply(int x){\n\td[x]=!d[x];\n\tswap(a[x][1],a[x][2]);\n//\tcout<<a[x][1]<<\" \"<<a[x][2]<<endl;\n}\n\nvoid update(int x){\n\tif(d[x]==false) return;\n\td[x]=false;\n\tfor(int i=0;i<3;i++) apply(a[x][i]);\n}\n\nvoid add(int c,int x){\n\tif(c==n){\n\t\treturn;\n\t} \n\telse{\n\t\tupdate(x);\n\t\tswap(a[x][1],a[x][2]);\n\t\tswap(a[x][0],a[x][1]);\n\t\tadd(c+1,a[x][0]);\n\t}\n}\n\nvoid dfs(int c,int x,int pos) {\n\tif(c==n){\n\t\tans[id[x]]=pos;\n\t} \n\telse{\n\t\tupdate(x);\n\t\tfor(int i=0;i<3;i++){\n\t\t\tdfs(c+1,a[x][i],pos+i*p[c]);\n\t\t}\n\t}\n}\n\nint main(){\n\tp[0]=1;\n\tfor(int i=1;i<15;i++) p[i]=p[i-1]*3;\n\tcin>>n>>s;\n\tint n2=n;\n\tbuild(0,1,0);\n\tfor(int i=0;i<s.size();i++){\n\t\tif(s[i]=='S'){\n\t\t\tapply(1);\n\t\t//\tcout<<i<<endl;\n\t\t}\n\t\telse{\n\t\t\tadd(0,1);\n\t\t}\n\t\tdfs(0,1,0);\n\t//\tfor(int i=0;i<3;i++) cout<<ans[i]<<\" \"; cout<<endl;\n\t}\n\tdfs(0,1,0);\n\tn=1;\n\tfor(int i=0;i<n2;i++) n=n*3;\n\tfor(int i=0;i<n;i++) cout<<ans[i]<<\" \";\n\tcout<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,true:false;}\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,true:false;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nint n,m,cnt;\nint pw[15],ch[800000][3],tag[800000],fl[800000],ans[800000];\nchar s[200005];\n\nvoid insert(int x,int t){\n\tint p=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(!ch[p][x%3]) ch[p][x%3]=++cnt;\n\t\tp=ch[p][x%3];\n\t\tx/=3;\n\t}\n\tfl[p]=t;\n}\n\nvoid add(){\n\tint p=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(tag[p]){\n\t\t\tswap(ch[p][1],ch[p][2]);\n\t\t\tfor(int i=0;i<3;i++) tag[ch[p][i]]^=1;\n\t\t\ttag[p]=0;\n\t\t}\n\t\tswap(ch[p][0],ch[p][1]);\n\t\tswap(ch[p][0],ch[p][2]);\n\t\tp=ch[p][0];\n\t}\n}\n\nvoid getans(int id,int num,int dep){\n\tif(fl[id]) return (void)(ans[fl[id]-1]=num);\n\tif(tag[id]){\n\t\tswap(ch[id][1],ch[id][2]);\n\t\tfor(int i=0;i<3;i++) tag[ch[id][i]]^=1;\n\t\ttag[id]=0;\n\t}\n\tgetans(ch[id][0],num,dep+1);\n\tgetans(ch[id][1],num+pw[dep],dep+1);\n\tgetans(ch[id][2],num+2*pw[dep],dep+1);\n}\n\nint main(){\n\tn=readint();\n\tpw[0]=1;\n\tfor(int i=1;i<=n;i++) pw[i]=pw[i-1]*3;\n\tfor(int i=0;i<pw[n];i++) insert(i,i+1);\n\tscanf(\"%s\",s+1); m=strlen(s+1);\n\tfor(int i=1;i<=m;i++){\n\t\tif(s[i]=='S') tag[0]^=1;\n\t\telse add();\n\t}\n\tgetans(0,0,0);\n\tfor(int i=0;i<pw[n];i++) printf(\"%d \",ans[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define x first\n#define y second\n#define iter iterator\n#define riter reversed_iterator\n#define y1 Lorem_ipsum_\n#define tm dolor_sit_amet_\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int mxN = 531441;\nint pw[mxN+3];\nchar a[mxN+3];\nint son[mxN*4+3][3];\nint val[mxN*4+3],ans[mxN+3];\nint p[3] = {0,1,2}; int pw3[15];\nint n,m,siz,rt;\n\nint build(int dep,int x)\n{\n\tif(dep==n+1) {return 0;}\n\tint u = ++siz;\n\tson[u][p[0]] = build(dep+1,x);\n\tson[u][p[1]] = build(dep+1,x+pw3[dep]);\n\tson[u][p[2]] = build(dep+1,x+2*pw3[dep]);\n\tif(dep==n) {val[u] = x;}\n\treturn u;\n}\nvoid modify(int dep,int u)\n{\n\tif(dep==n+1) {return;}\n\tint tson[3];\n\tfor(int i=0; i<3; i++) {tson[i] = son[u][p[i]];}\n\tfor(int i=0; i<3; i++) {son[u][p[i]] = tson[(i+2)%3];}\n\tmodify(dep+1,son[u][0]);\n}\nvoid getans(int dep,int u,int x)\n{\n\tif(dep==n) {ans[val[u]] = x; return;}\n\tgetans(dep+1,son[u][p[0]],x);\n\tgetans(dep+1,son[u][p[1]],x+pw3[dep]);\n\tgetans(dep+1,son[u][p[2]],x+2*pw3[dep]);\n}\n\nint main()\n{\n\tscanf(\"%d%s\",&n,a+1); m = strlen(a+1);\n\tpw3[0] = 1ll; for(int i=1; i<=n; i++) pw3[i] = pw3[i-1]*3;\n\trt = build(0,0);\n\tfor(int k=1; k<=m; k++)\n\t{\n\t\tif(a[k]=='S')\n\t\t{\n\t\t\tswap(p[1],p[2]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmodify(0,rt);\n\t\t}\n\t}\n\tgetans(0,rt,0);\n\tfor(int i=0; i<pw3[n]; i++) printf(\"%d \",ans[i]); puts(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2000005;\nint n,m,cnt,p[12]={1},ans[N];\nchar s[N];\nstruct tree\n{\n\tint ch[3],id,tag;\n}a[N];\nvoid build(int d,int x,int v)\n{\n\ta[x].tag=0;\n\tif(d==n)\n\t{\n\t\ta[x].id=v;\n\t\treturn;\n\t}\n\tfor(int i=0;i<3;i++)\n\t{\n\t\ta[x].ch[i]=++cnt;\n\t\tbuild(d+1,a[x].ch[i],v+p[d]*i);\n\t}\n}\nvoid pushdown(int x)\n{\n\tif(a[x].tag)\n\t{\n\t\tfor(int i=0;i<3;i++)\n\t\t{\n\t\t\tswap(a[a[x].ch[i]].ch[1],a[a[x].ch[i]].ch[2]);\n\t\t\ta[a[x].ch[i]].tag^=1;\n\t\t}\n\t\ta[x].tag=0;\n\t}\n}\nvoid add(int d,int x)\n{\n\tif(d==n)\n\t\treturn;\n\tpushdown(x);\n\tint b[3];\n\tfor(int i=0;i<3;i++)\n\t\tb[i]=a[x].ch[i];\n\tfor(int i=0;i<3;i++)\n\t\ta[x].ch[i]=b[(i+2)%3];\n\tadd(d+1,a[x].ch[0]);\n}\nvoid out(int d,int x,int v)\n{\n\tif(d==n)\n\t{\n\t\tans[a[x].id]=v;\n\t\treturn;\n\t}\n\tpushdown(x);\n\tfor(int i=0;i<3;i++)\n\t\tout(d+1,a[x].ch[i],v+p[d]*i);\n}\nint main()\n{\n\tscanf(\"%d%s\",&n,s+1);\n\tm=strlen(s+1);\n\tfor(int i=1;i<=n;i++)\n\t\tp[i]=p[i-1]*3;\n\tbuild(0,0,0);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(s[i]=='S')\n\t\t{\n\t\t\tswap(a[0].ch[1],a[0].ch[2]);\n\t\t\ta[0].tag^=1;\n\t\t}\n\t\tif(s[i]=='R')\n\t\t\tadd(0,0);\n\t}\n\tout(0,0,0);\n\tfor(int i=0;i<p[n];i++)\n\t\tprintf(\"%d \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nint pct(int x) { return __builtin_popcount(x); } \nint bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nint cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 \nint fstTrue(function<bool(int)> f, int lo, int hi) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tint mid = (lo+hi)/2; \n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(bool b) { return b ? \"true\" : \"false\"; }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) { \n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\tbool fst = 1; str res = \"{\";\n\tfor (const auto& x: v) {\n\t\tif (!fst) res += \", \";\n\t\tfst = 0; res += ts(x);\n\t}\n\tres += \"}\"; return res;\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n#define dbg(...) cerr << \"LINE(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#else\n#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(string s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\nint N,perm[3];\nvi cur;\nstr T;\n\nint po(int x) { return pow(3,x); }\n\nint fin(int x) {\n\tF0R(i,3) if (perm[i] == x) return i;\n}\n\nvoid change(int x) {\n\tdbg(\"CHANGE\",x);\n\tcur[x] = fin((perm[cur[x]]+1)%3);\n}\n\nint i;\n\nint getTwo(int x) {\n\tdbg(\"GETTWO\",x,perm[cur[x]]);\n\twhile (1) {\n\t\tdbg(\"??\",x,perm[cur[x]]);\n\t\tif (perm[cur[x]] == 2) return x;\n\t\tx += po(i-1);\n\t}\n}\n\nint main() {\n\tsetIO(); re(N,T);\n\tvector<vi> lst; lst.pb(vi(sz(T)+1));\n\tvi res(po(N));\n\tfor (i = 1; i <= N; ++i) {\n\t\tcur.clear(); F0R(j,po(i)) cur.pb(j/po(i-1));\n\t\tF0R(j,3) perm[j] = j;\n\t\tlst.pb(vi(sz(T)+1)); lst.bk[0] = po(i)-1;\n\t\tF0R(j,sz(T)) {\n\t\t\tdbg(\"CUR\",cur,T[j]);\n\t\t\tdbg(\"DOING\",i,j);\n\t\t\tif (T[j] == 'S') {\n\t\t\t\tint a = fin(1), b = fin(2);\n\t\t\t\tswap(perm[a],perm[b]);\n\t\t\t\t//lst.bk[j+1]\n\t\t\t} else {\n\t\t\t\t//dbg(\"HAHA\");\n\t\t\t\tchange(lst[sz(lst)-2][j]);\n\t\t\t\tchange(lst[sz(lst)-2][j]+po(i-1));\n\t\t\t\tchange(lst[sz(lst)-2][j]+2*po(i-1));\n\t\t\t}\n\t\t\tlst.bk[j+1] = getTwo(lst[sz(lst)-2][j+1]);\n\t\t}\n\t\tF0R(z,po(N)) res[z] += po(i-1)*perm[cur[z%po(i)]];\n\t}\n\tF0R(i,po(N)) pr(res[i],' ');\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n#define ll long long\n#define ii pair<ll,ll>\n#define iii pair<ii,ll>\n#define fi first\n#define se second\n#define endl '\\n'\n#define debug(x) cout << #x << \" is \" << x << endl;\n\n#define rep(x,start,end) for(auto x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n\nll MAX(ll a){return a;}\nll MIN(ll a){return a;}\ntemplate<typename... Args>\nll MAX(ll a,Args... args){return max(a,MAX(args...));}\ntemplate<typename... Args>\nll MIN(ll a,Args... args){return min(a,MIN(args...));}\n\n#define indexed_set tree<ll,null_type,less<ll>,rb_tree_tag,tree_order_statistics_node_update>\n\nlong long qexp(long long b,long long p){\n    long long res=1;\n    while (p){\n        if (p&1) res=(res*b);\n        b=(b*b);\n        p>>=1;\n    }\n    return res;\n}\n\nint calc_oppo(int i){\n\tint pow=1;\n\tint res=0;\n\t\n\twhile (i){\n\t\tif (i%3==1){\n\t\t\tres+=pow*2;\n\t\t}\n\t\telse if (i%3==2){\n\t\t\tres+=pow;\n\t\t}\n\t\t\n\t\ti/=3;\n\t\tpow*=3;\n\t}\n\t\n\treturn res;\n}\n\nint n;\nstring s;\ndeque<int> id;\nint last_swap[1000];\ndeque<int> dq[1000];\n\nint oppo[1000];\n\nint state=0; //how many swap have happened so far\n\nint perm[600005];\nint ans[600005];\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\t\n\trep(x,0,1000) oppo[x]=calc_oppo(x);\n\t//rep(x,0,10) cout<<x<<\" \"<<oppo[x]<<endl;\n\t\n\tcin>>n;\n\tcin>>s;\n\t\n\tint bn=(n+1)/2,tn=n-bn;\n\tbn=qexp(3,bn),tn=qexp(3,tn);\n\t\n\trep(x,0,bn){\n\t\tid.push_back(x);\n\t\t\n\t\trep(y,0,tn) dq[x].push_back(y);\n\t}\n\t\n\trep(x,0,sz(s)){\n\t\tif (s[x]=='S'){\n\t\t\trep(x,0,bn){\n\t\t\t\tif (x<oppo[x]) swap(id[x],id[oppo[x]]);\n\t\t\t}\n\t\t\tstate++;\n\t\t}\n\t\telse{\n\t\t\tid.push_front(id.back());\n\t\t\tid.pop_back();\n\t\t\t\n\t\t\tint curr=id.front();\n\t\t\t\n\t\t\tif ((state-last_swap[curr])%2==1){ //swap inside id\n\t\t\t\trep(y,0,tn){\n\t\t\t\t\tif (y<oppo[y]) swap(dq[curr][y],dq[curr][oppo[y]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlast_swap[curr]=state;\n\t\t\t\n\t\t\tdq[curr].push_front(dq[curr].back());\n\t\t\tdq[curr].pop_back();\n\t\t}\n\t}\n\t\n\t//rep(x,0,bn) cout<<id[x]<<\" \";\n\t//cout<<endl;\n\t\n\t//rep(x,0,tn) cout<<dq[2][x]<<\" \";\n\t//cout<<endl;\n\t\n\trep(x,0,bn) if ((state-last_swap[x])%2==1){\n\t\trep(y,0,tn){\n\t\t\tif (y<oppo[y]) swap(dq[x][y],dq[x][oppo[y]]);\n\t\t}\n\t}\n\t\n\trep(x,0,bn){\n\t\trep(y,0,tn) perm[x+y*bn]=id[x]+bn*dq[id[x]][y];\n\t}\n\t\n\trep(x,0,bn*tn) ans[perm[x]]=x;\n\t\n\t//rep(x,0,bn*tn) cout<<perm[x]<<\" \";\n\t//cout<<endl;\n\t\n\trep(x,0,bn*tn) cout<<ans[x]<<\" \";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb emplace_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = pow(3, 12) + 100, maxm = 200010;\nint nxt[maxn], n, ans[maxn];\nint cnt = 1;\nstring w;\nvector<int> op;\nint gn(int val) {\n\tint res = 0, sc = 1;\n\twhile (val) {\n\t\tint v = val % 3;\n\t\tval /= 3;\n\t\tres += (v == 1 ? 2 : v == 2 ? 1 : 0) * sc;\n\t\tsc *= 3;\n\t}\n\treturn res;\n}\nvoid init() {\n\tfor (int i = 0;i < cnt;++i) \n\t\tnxt[i] = gn(i), ans[i] = i;\n//\tfor (int i =0;i < cnt;++i)\n//\t\tcerr << nxt[i] << ' ';\n//\tcerr << '\\n';\n//\texit(0);\n}\nvoid get_ans() {\n\tfor (int u : op) {\n\t\tfor (int i = 0;i < cnt;++i)\n\t\t\tans[i] = nxt[(ans[i] + u) % cnt];\n\t}\n\t\n}\nsigned main(){\n\tios_base::sync_with_stdio(0), cin.tie(0);\n\tcin >> n;\n\twhile (n--) cnt *= 3;\n\tinit();\n\tcin >> w;\n\tint len = 0, c = 0;\n\tfor (char i : w) {\n\t\tif (i == 'R') {\n\t\t\tif (c) op.pb(len), len = 0, c = 0;\n\t\t\t++len;\n\t\t}\n\t\telse \n\t\t\tc ^= 1;\n\t}\n\tif (c) op.pb(len), len = 0;\n\tif (op.size() <= 800) get_ans();\n\telse return -1;\n\tfor (int i = 0;i < cnt;++i)\n\t\tcout << (ans[i]+len) % cnt << ' ';\n}\n"
  },
  {
    "language": "C++",
    "code": "        #include <bits/stdc++.h>\n        using namespace std;\n   #define int long long\nconst int MAX = 510000;\nconst int MOD = 1000000007;\n\n     signed main(){\n int n;\n string t;\n cin>>n>>t;\n int al2[t.size()]={};\n set<int> x[3];int y[3];\n int k=3;\n int kk=1;for(int i=0;i<n;i++)kk*=3;\n int ans[kk]={};\n\n for(int i=0;i<n;i++){\n      x[0].clear();\n      x[1].clear();\n      x[2].clear();\n   for(int j=0;j<k;j++)x[j/(k/3)].insert(j);\n   y[0]=0;y[1]=1;y[2]=2;\n   for(int j=0;j<t.size();j++){\n        if(t[j]=='S'){swap(y[1],y[2]);continue;}\n        int h[3];\n        for(int q=0;q<3;q++){\n             for(int p=0;p<3;p++){\n                  auto it=x[y[q]].find(al2[j]+p*k/3);\n                  if(it!=x[y[q]].end()){\n                       h[q]=al2[j]+p*k/3;\n                       x[y[q]].erase(h[q]);\n                       break;\n                       \n\n                  }\n             }\n        }\n        for(int q=0;q<3;q++)x[y[(q+1)%3]].insert(h[q]);\n        al2[j]=h[2];\n   }\n\n   for(int j=0;j<kk;j++){\n        for(int q=0;q<3;q++){\n          auto it=x[y[q]].find(j%k);\n          if(it!=x[y[q]].end())ans[j]+=q*(k/3);\n        }\n   }\n   k*=3;\n\n }\n for(int i=0;i<kk;i++)cout<<ans[i]<<' ';\n\n\n\n\n\n\n    }\n\n\n\n\n\n      \n\n        \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(void){\n    // Your code here!\n    int n;\n    string t;\n    cin >> n >> t;\n    int r_counter = 0;\n    vector<int> p = {0};\n    for(int i = 1; i < pow(3, n); i++) p.push_back(i);\n    for(int i = 0; i < (int)t.size(); i++){\n        if(t[i] == 'R'){\n            r_counter += 1;\n        }else{\n            for(int j = 0; j < pow(3, n); j++){\n                p.at(j) += r_counter;\n                if(p.at(j) >= pow(3, n)) p.at(j) = p.at(j) % (int)pow(3, n);\n                queue<int> new_pos;\n                int next = p.at(j);\n                p.at(j) = 0;\n                int three = 0;\n                while(1){\n                    int bit = next % 3;\n                    next = next / 3;\n                    switch(bit){\n                        case 0: break;\n                        case 1: bit = 2; break;\n                        case 2: bit = 1; break;\n                    }\n                    p.at(j) += pow(3, three)*bit;\n                    three += 1;\n                    if(next == 0) break;\n                }\n            }\n            r_counter = 0;\n        }\n    }\n    for(int i = 0; i < pow(3, n); i++){\n        if(r_counter != 0){\n            p.at(i) += r_counter;\n            if(p.at(i) >= pow(3, n)) p.at(i) = p.at(i) % (int)pow(3, n);    \n        }\n        \n        cout << p.at(i) << \" \";\n    }\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//#pragma GCC target (\"avx2\")\n//#pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 729 + 10;\nint p[13];\nchar s[200000+10];\nint a[N][N],b[N],r[N],ans[N*N];\nint main(){\n    p[0] = 1; for(int i=1;i<13;i++) p[i] = p[i-1] * 3;\n    int n; scanf(\"%d%s\",&n,s);\n    int x = n / 2, y = n - x;\n    ///y: low, x: high\n    for(int i=0;i<p[6];i++){\n        int t = i;\n        for(int j=0;j<6;j++){\n            if(t/p[j]%3==1) t += p[j];\n            else if(t/p[j]%3==2) t -= p[j];\n        }\n        r[i] = t;\n    }\n    for(int i=0;i<p[n];i++){\n        a[i%p[y]][i/p[y]] = i;\n    }\n    for(int i=0;s[i];i++){\n        if(s[i]=='S'){\n            for(int j=0;j<p[y];j++) b[j] ^= 1;\n            for(int j=0;j<p[y];j++) if(j<r[j]){\n                swap(a[j],a[r[j]]);\n                swap(b[j],b[r[j]]);\n            }\n        }\n        else{\n            for(int j=p[y]-1;j>0;j--){\n                swap(a[j],a[j-1]);\n                swap(b[j],b[j-1]);\n            }\n            if(b[0]){\n                for(int j=0;j<p[x];j++) if(j<r[j]) swap(a[0][j],a[0][r[j]]);\n                b[0] = 0;\n            }\n            for(int j=p[x]-1;j>0;j--){\n                swap(a[0][j],a[0][j-1]);\n            }\n        }\n    }\n    for(int i=0;i<p[y];i++) if(b[i]){\n        for(int j=0;j<p[x];j++) if(j<r[j]) swap(a[i][j],a[i][r[j]]);\n        b[i] = 0;\n    }\n    for(int i=0;i<p[n];i++) ans[a[i%p[y]][i/p[y]]] = i;\n    for(int i=0;i<p[n];i++) printf(\"%d%c\",ans[i],\" \\n\"[i==p[n]-1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=13;\nconst int maxm=550005; \nint n,m;\nchar s[maxm];\nint pw3[maxn],ans[maxm];\n\nnamespace Trie{\n\tconst int maxv=maxm*2;\n\tint rt,tot;\n\tint nxt[maxv][3],leaf[maxv];\n\tbool rev[maxv];\n\tvoid build(){\n\t\trt=++tot;\n\t\tfor(int i=0;i<pw3[n];i++){\n\t\t\tint cur=rt;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tint c=i/pw3[j]%3;\n\t\t\t\tif(!nxt[cur][c])nxt[cur][c]=++tot;\n\t\t\t\tcur=nxt[cur][c];\n\t\t\t}\n\t\t\tleaf[cur]=i;\n\t\t}\n\t}\n\tvoid apply(int cur){\n\t\tswap(nxt[cur][1],nxt[cur][2]);\n\t\trev[cur]^=1;\n\t}\n\tvoid pushdown(int cur){\n\t\tif(rev[cur]){\n\t\t\tapply(nxt[cur][0]);\n\t\t\tapply(nxt[cur][1]);\n\t\t\tapply(nxt[cur][2]);\n\t\t\trev[cur]=0;\n\t\t}\n\t}\n\tvoid S(){\n\t\tapply(rt);\n\t} \n\tvoid R(){\n\t\tint cur=rt;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tpushdown(cur);\n\t\t\tint tmp=nxt[cur][2];\n\t\t\tnxt[cur][2]=nxt[cur][1];\n\t\t\tnxt[cur][1]=nxt[cur][0];\n\t\t\tnxt[cur][0]=tmp;\n\t\t\tcur=nxt[cur][0];\n\t\t}\n\t}\n\tvoid getans(){\n\t\tfor(int i=0;i<pw3[n];i++){\n\t\t\tint cur=rt;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tpushdown(cur);\n\t\t\t\tcur=nxt[cur][i/pw3[j]%3];\n\t\t\t}\n\t\t\tans[leaf[cur]]=i;\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%s\",&n,s);\n\tm=strlen(s);\n\tpw3[0]=1;\n\tfor(int i=1;i<=n;i++)pw3[i]=3*pw3[i-1];\n\tTrie::build();\n\tfor(int i=0;i<m;i++){\n\t\tif(s[i]=='S')Trie::S();\n\t\telse Trie::R();\n\t}\n\tTrie::getans();\n\tfor(int i=0;i<pw3[n];i++)printf(\"%d%c\",ans[i],i==pw3[n]-1?'\\n':' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F(i, a, b) for (int i = a; i <= b; i ++)\n#define G(i, a, b) for (int i = a; i >= b; i --)\n#define max(a, b) ((a) > (b) ? (a) : (b))\n#define min(a, b) ((a) < (b) ? (a) : (b))\n#define mx(a, b) ((a) = max(a, b))\n#define mn(a, b) ((a) = min(a, b))\n#define out4(x, y, z, w) { printf(#x\" = \"), W(x), printf(\" \"#y\" = \"), W(y), printf(\" \"#z\" = \"), W(z), printf(\" \"#w\" = \"), W(w), putc('\\n'); }\n#define out3(x, y, z) { printf(#x\" = \"), W(x), printf(\" \"#y\" = \"), W(y), printf(\" \"#z\" = \"), W(z), putc('\\n'); }\n#define out2(x, y) { printf(#x\" = \"), W(x), printf(\" \"#y\" = \"), W(y), putc('\\n'); }\n#define out1(x) { printf(#x\" = \"); W(x), putc('\\n'); }\n#define outarr(a, L, R) { printf(#a\"[%d..%d] = \", L, R); F(i, L, R) W(a[i]), putc(' '); putc('\\n'); }\n#define outline(x) { puts(\"-------------------------------\"#x\"---------------------------------\"); }\n#define mem(a, b) memset(a, b, sizeof a)\n#define mec(a, b) memcpy(a, b, sizeof a)\n#define low(x) ((x) & (- (x)))\n#define abs(x) max((x), (- (x)))\n#define get getchar()\n#define putc putchar\n\ntemplate <typename Int>\nvoid R(Int &x) {\n\tchar c = get; x = 0; Int t = 1;\n\tfor (; !isdigit(c); c = get) t = (c == '-' ? - 1 : t);\n\tfor (; isdigit(c); x = (x << 3) + (x << 1) + c - '0', c = get); x *= t;\n}\ntemplate <typename Int>\nvoid W(Int x) {\n\tif (x < 0) { putc('-'); x = - x ; }\n\tif (x > 9) W(x / 10); putc(x % 10 + '0');\n}\n\nusing namespace std;\n\nconst int M = 531442;\nconst int T = 2e5 + 10;\nconst int N = 30;\nint n, a[M], d[N], sum[M], c[M];\nchar s[T];\n\nint main() {\n\tR(n); int S = 1;\n\tF(i, 1, n) S = S * 3;\n\tF(i, 0, S - 1) {\n\t\ta[i] = i; int L = 0;\n\t\tfor (int x = i; x; d[++ L] = x % 3, x /= 3);\n\t\tG(j, L, 1) sum[i] = sum[i] * 3 + (d[j] ? 3 - d[j] : 0);\n\t}\n\tscanf(\"%s\", s + 1);\n\tint len = strlen(s + 1);\n\tF(i, 1, len)\n\t\tif (s[i] == 'S') {\n\t\t\tF(j, 0, S - 1)\n\t\t\t\ta[j] = sum[a[j]];\n\t\t}\n\t\telse {\n\t\t\tF(i, 0, S - 1) a[i] = (a[i] + 1) % S;\n\t\t}\n\tF(i, 0, S - 1)\n\t\tW(a[i]), putc(' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar T[550005];\nint salsa2[550005];\nint salsaNext[550005];\n\nint N;\n\nint salsa(int x){\n    int temp = x;\n    int pow3 = 1;\n    int res = 0;\n    for(int i = 0; i < N; i ++){\n        int k = temp%3;\n        temp /= 3;\n\n        if(k == 1){\n            res += pow3*2;\n        }else if(k == 2){\n            res += pow3;\n        }\n        pow3 *= 3;\n    }\n    return res;\n}\n\nint main(){\n    scanf(\"%d\", &N);\n\n    scanf(\" %s\", T);\n\n    int pow3N = 1;\n    for(int i = 0; i < N; i ++){\n        pow3N *= 3;\n    }\n\n    for(int i = 0; i < pow3N; i ++){\n        salsa2[i] = salsa(i);\n        //printf(\"salsa2[%d]=%d\\n\", i, salsa2[i]);\n    }\n\n    for(int i = 0; i < pow3N; i ++){\n        salsaNext[salsa2[i+1]] = salsa2[i];\n    }\n\n    for(int j = 0; j < pow3N; j ++){\n        int x = j;\n        for(int i = 0; i < pow3N; i ++){\n            if(T[i] == 'R'){\n                x = (x+1)%pow3N;\n            }else if(T[i] == 'S'){\n                x = salsa2[x];\n            }\n        }\n        printf(\"%d \", x);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\",3,\"inline\")\n#include<bits/stdc++.h>\nusing namespace std;\n#define fir first\n#define sec second\n#define m_p make_pair\n#define y1 ygftgfgcdtfgxffgx\n#define y2 yfdsesgvtyghftfvv\n#define x1 xvyr6cf6fgcfgf676\n#define x2 xcr6rfc5r66y6r6fr\n#define up_bound upper_bound\n#define low_bound lower_bound\n#define next_per next_permutation\n#define pb push_back\n#define i_to_s to_string\ntypedef priority_queue<int> p_queue;\ntypedef priority_queue<int, vector<int>, greater<int> > min_p_queue;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nint mon[20]={31,28,31,30,31,30,31,31,30,31,30,31};\nll gcd(ll x,ll y){return ((y==0)?x:gcd(y,x%y));}\nint n;\nstring t;\nll pass[600010];\nint a[20];\nll power[20];\nll v[600010];\nvoid init(){\n\tll ans,x,pos;\n\tfor(int i=0;i<50/*600000*/;i++){\n\t\tx=i;ans=pos=0;\n\t\twhile(x){\n\t\t\ta[pos++]=(x%3);\n//\t\t\tcout<<a[pos-1]<<' ';\n\t\t\tx/=3;\n\t\t}\n\t\twhile(pos){\n\t\t\tpos--;\n\t\t\tif(a[pos]==1)ans=ans*3+2;\n\t\t\telse if(a[pos]==2)ans=ans*3+1;\n\t\t\telse ans=ans*3+a[pos];\n\t\t}\n\t\tpass[i]=ans;\n//\t\tcout<<\"    \"<<i<<' '<<ans<<'\\n';\n\t}\n\tpower[0]=1;\n\tfor(int i=1;i<15;i++){\n\t\tpower[i]=power[i-1]*3;\n\t}\n}\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tcin>>n>>t;\n\tinit();\n\tn=power[n];\n\tfor(int i=0;i<n;i++)v[i]=i;\n\tfor(int i=0;i<t.size();){\n//\t\tcout<<\"hi\\n\";\n//\t\tfor(int j=0;j<n;j++)cout<<v[j]<<' ';cout<<'\\n';\n//\t\tfor(int j=0;j<n;j++)u[j]=v[j];\n\t\tif(t[i]=='S'){\n\t\t\tif(t[i+1]=='S'){\n\t\t\t\ti+=2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tv[j]=pass[v[j]];\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint cnt=0;\n\t\t\twhile(t[i]=='R')cnt++,i++;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tv[j]=(v[j]+cnt)%n;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\ti++;\n\t}\n\tfor(int i=0;i<n;i++)cout<<v[i]<<' ';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\nusing namespace std;\ntypedef vector<bool> vi;\nconst int maxn=2e5+10;\nchar s[maxn];\nint n,ans[maxn],len,p3[13];\nvoid solve(int x,int v,vi &a){\n    int res[3];\n    vi tmp[3];\n    for (int i=0;i<3;i++){\n        tmp[i].clear();\n        int now=i;\n        for (int j=0;j<a.size();j++){\n            if (a[j]){\n                if (now>0) now=3-now;\n                tmp[i].pb(1);\n                int m=tmp[i].size();\n                if (m>=2&&tmp[i][m-1]&&tmp[i][m-2]) tmp[i].resize(m-2);\n            } else {\n                now++;\n                if (now==3){\n                    now=0;\n                    tmp[i].pb(0);\n                }\n            }\n        }\n        res[i]=now;\n    }\n    for (int i=0;i<p3[n]/p3[x];i++){\n        ans[i*p3[x]+v]+=p3[x]*res[i%3];\n    }\n    if (x<n-1){\n        for (int i=0;i<3;i++) solve(x+1,v+i*p3[x],tmp[i]);\n    }\n}\nint main(){\n    cin >> n >> s; len=strlen(s);\n    vector <vi> dp;\n    p3[0]=1; for (int i=1;i<=n;i++) p3[i]=p3[i-1]*3;\n    vi res; res.clear();\n    for (int i=0;i<len;i++){\n        res.pb(s[i]=='S');\n        int m=res.size();\n        if (m>=2&&res[m-1]&&res[m-2]) res.resize(m-2);\n    }\n    solve(0,0,res);\n    for (int i=0;i<p3[n];i++) cout << ans[i] << ' ' ; cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(long long i=0;i<(long long)N;i++)\nint N,o,p,x,y,pos,pw3[36]={1},A[1000001],salsa[600000],sw[1000001];\nchar T[1000001];\nvoid OUT(long long x){if(x<0)putchar('-'),x=-x;if(x>=10)OUT(x/10);putchar(x%10+48);}\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nvoid Dance(char c[])\n{\n  if(c[p]==EOF)return;\n  if(c[p]=='S'){x=salsa[x];if(sw[pos]>0)pos--;else sw[++pos]=1;}\n  if(c[p]=='R'){x++;if(x==pw3[N/2])sw[++pos]=-1,x=0;}\n}\nvoid Update(void)\n{\n  rep(i,pw3[N-N/2])\n  {\n    y=i;\n    rep(j,pos){if(sw[j+1]>0)y=salsa[y];else if(sw[j+1]<0){if((++y)==pw3[N-N/2])y=0;}}\n    A[o+i*pw3[N/2]]=y*pw3[N/2]+x;\n  }\n}\nsigned main(void)\n{\n  o=scanf(\"%d %s\",&N,T+1);\n  //replace(T+1,\"SS\",\"\");if(T[0]=='\\n')return 0;\n  rep(i,N)pw3[i+1]=3*pw3[i];\n  rep(i,pw3[N])salsa[i]=salsa[i/3]*3+(3-i%3)%3;\n  rep(i,pw3[N/2]){o=i,x=i,pos=0;rep(j,strlen(T+1)){p=j+1,Dance(T);}Update();}\n  rep(i,pw3[N])OUT(A[i]),putchar(' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxN = 2e6 + 10;\n\nint n, len, cnt, root;\nint ch[maxN + 1][3], a[maxN + 1];\nint rev[maxN + 1], pw[15], ans[maxN + 1];\nchar s[maxN + 1];\n\ninline void reverse(int x) \n{ \n\tif(!x) return;\n\tswap(ch[x][1], ch[x][2]);\n\trev[x] ^= 1;\n}\n\ninline void pushdown(int x)\n{\n\tif(!rev[x]) return;\n\treverse(ch[x][0]);\n\treverse(ch[x][1]);\n\treverse(ch[x][2]);\n\trev[x] = 0;\n}\n\ninline void insert(int &node, int x, int k)\n{\n\tif(!node) node = ++ cnt;\n\tif(k == n) { a[node] = x; return; }\n\tint d = x / pw[k] % 3;\t\n\tinsert(ch[node][d], x, k + 1);\n}\n\ninline void change(int node)\n{\n\tif(!node) return;\n\tpushdown(node);\n\tchange(ch[node][2]);\n\tswap(ch[node][1], ch[node][2]); \n\tswap(ch[node][0], ch[node][1]);\n}\n\ninline void dfs(int node, int k, int x)\n{\n\tif(!node) return;\n\tif(k == n) { ans[ a[node] ] = x; return; }\n\tpushdown(node);\n\tdfs(ch[node][0], k + 1, x);\n\tdfs(ch[node][1], k + 1, x + pw[k]);\n\tdfs(ch[node][2], k + 1, x + 2 * pw[k]);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", s + 1);\n\tlen = strlen(s + 1);\n\n\tpw[0] = 1;\n\tfor(int i = 1; i <= n; i++) pw[i] = pw[i - 1] * 3;\n\n\tfor(int i = 0; i < pw[n]; i++) insert(root, i, 0);\n\n\tfor(int i = 1; i <= len; i++)\n\t\tif(s[i] == 'S') reverse(root);\n\t\telse change(root);\n\n\tdfs(root, 0, 0);\n\t\n\tfor(int i = 0; i < pw[n]; i++) printf(\"%d \", ans[i]);\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(x) ((int) ((x).size()))\ntypedef long long ll;\ntypedef long double ld;\n\nint n, pw[20], s[600100], p[600100], l[600100], lp[600100];\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  cin >> n;\n  int ln = (n + 1) / 2;\n  pw[0] = 1;\n  for (int i = 1; i <= n; i++)\n    pw[i] = pw[i - 1] * 3;\n  for (int i = 0; i < pw[ln]; i++) {\n    int si = 0;\n    for (int j = 0; j < ln; j++) {\n      int dj = (i / pw[j]) % 3;\n      if (dj == 1)\n        si += 2 * pw[j];\n      else if (dj == 2)\n        si += pw[j];\n    }\n    s[i] = si;\n  }\n  for (int i = 0; i < pw[n]; i++)\n    p[i] = i / pw[ln], l[i] = 0;\n  for (int i = 0; i < pw[ln]; i++)\n    lp[i] = i;\n  char c;\n  int cs = 0;\n  while (cin >> c) {\n    if (c == 'S') {\n      cs++;\n      for (int i = 0; i < pw[ln]; i++)\n        lp[i] = s[lp[i]];\n    } else {\n      int sv = 0;\n      for (int i = 0; i < pw[ln]; i++) {\n        lp[i]++;\n        if (lp[i] >= pw[ln])\n          lp[i] = 0, sv = i;\n      }\n      for (int i = sv; i < pw[n]; i += pw[ln]) {\n        if ((cs - l[i]) & 1)\n          p[i] = s[p[i]];\n        l[i] = cs;\n        p[i]++;\n        if (p[i] >= pw[n - ln])\n          p[i] = 0;\n      }\n    }\n  }\n  for (int i = 0; i < pw[n]; i++)\n    if ((cs - l[i]) & 1)\n      p[i] = s[p[i]];\n  for (int i = 0; i < pw[n]; i++)\n    cout << lp[i % pw[ln]] + pw[ln] * p[i] << \" \";\n  cout << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    vector<int> d23(531441);\n    //vector<int> rumba(531441);\n\n    int N;\n    cin >> N;\n    N = (int)pow(3,N);\n    \n    int temp,add,now;\n    for(int i = 0 ; i < N ; i++){\n        temp = i;\n        add = 0;\n        now = 1;\n        while(temp != 0){\n            int a = temp % 3;\n            if(a == 1){\n                add += 2 * now;\n            }else if(a == 2){\n                add += now;\n            }\n            now *= 3;\n            temp /= 3;\n        }\n        d23.at(i) = add;\n    }\n\n    //for(int i = 0 ; i < N ; i++){\n    //    rumba.at(i) = i + 1;\n    //}\n    //rumba.at(N - 1) = 0;\n\n\n    vector<int> hito1(531441);\n\n    for(int i = 0 ; i < N ; i++){\n        hito1.at(i) = i;\n    }\n\n\n    string _T;\n    cin >> _T;\n\n    string TSdata;\n    vector<int> Tdata;\n\n    bool flag = false;\n    int cnt = 0;\n\n    for(int i = 0 ; i < _T.size() ; i++){\n        if(_T.at(i) == 'S'){\n            if(flag){\n                flag = false;\n                continue;\n            }\n            flag = true;\n        }else{\n            if(flag){\n                TSdata.push_back('S');\n                flag = false;\n            }\n            TSdata.push_back('R');\n        }\n    }\n    if(flag){\n        TSdata.push_back('S');\n    }\n    flag = false;\n\n    \n    \n    for(int i = 0 ; i < TSdata.size() ; i++){\n        if(TSdata.at(i) == 'R'){\n            cnt++;\n        }else{\n            if(cnt != 0){\n                Tdata.push_back(cnt);\n                cnt = 0;\n            }\n            Tdata.push_back(0);\n        }\n    }\n    if(cnt != 0){\n        Tdata.push_back(cnt);\n    }\n\n\n    /*for(int i = 0 ; i < _T.size() ; i++){\n        if(_T.at(i) == 'S'){\n            if(cnt != 0){\n                Tdata.push_back(cnt);\n                cnt = 0;\n            }\n            if(flag){\n                flag = false;\n            }else{\n                flag = true;\n            }\n        }else{\n            if(flag){\n                Tdata.push_back(0);\n            }\n            flag = false;\n            cnt++;\n        }\n    }\n    if(flag){\n        Tdata.push_back(0);\n    }\n    if(cnt != 0){\n        Tdata.push_back(cnt);\n    }\n    */\n    int tSize = Tdata.size();\n\n    //for(int i = 0 ; i < Tdata.size() ; i++){\n    //    cout << Tdata.at(i) << ' ';\n    //}\n    //return 0;\n\n    \n\n    for(int i = 0 ; i < tSize ; i++){\n        if(Tdata.at(i) == 0){\n            for(int j = 0 ; j < N ; j++){\n                hito1.at(j) = d23.at(hito1.at(j));\n            }\n        }else{\n            int a = Tdata.at(i);\n            a %= N;\n            int s = N - a;\n            for(int j = 0 ; j < s ; j++){\n                hito1.at(j) += a;\n            }\n            for(int j = s ; j < N ; j++){\n                hito1.at(j) -= s;\n            }\n        }\n    }\n\n\n    \n    for(int i = 0 ; i < N - 1 ; i++){\n        cout << hito1.at(i) << ' ';\n    }\n    cout << hito1.at(N - 1) << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<queue>\n#include<cmath>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<random>\n#include<functional>\n#include<algorithm>\n#include<stack>\n#include<cstdio>\n#include<cstring>\n#include<bitset>\n#include<unordered_map>\n#include<climits>\n#include<fstream>\n#include<complex>\n#include<time.h>\n#include<cassert>\n#include<functional>\n#include<numeric>\n#include<tuple>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define int long long\n#define all(a) (a).begin(),(a).end()\n#define fs first\n#define sc second\n#define xx first\n#define yy second.first\n#define zz second.second\n#define H pair<int, int>\n#define P pair<int, pair<int, int>>\n#define Q(i,j,k) mkp(i,mkp(j,k))\n#define rng(i,s,n) for(int i = (s) ; i < (n) ; i++)\n#define rep(i,n) rng(i, 0, (n))\n#define mkp make_pair\n#define vec vector\n#define pb emplace_back\n#define crdcomp(b) sort(all((b)));(b).erase(unique(all((b))),(b).end())\n#define getidx(b,i) lower_bound(all(b),(i))-b.begin()\n#define ssp(i,n) (i==(int)(n)-1?\"\\n\":\" \")\n#define ctoi(c) (int)(c-'0')\n#define itoc(c) (char)(c+'0')\n#define pp(x,y) pb(H{x,y})\n#define ppp(x,y,z) pb(Q(x,y,z))\n#define cyes printf(\"Yes\\n\")\n#define cno printf(\"No\\n\")\n#define cdf(n) int quetimes_=(n);rep(qq123_,quetimes_)\n#define gcj printf(\"Case #%lld: \",qq123_+1)\n#define readv(a,n) a.resize(n,0);rep(i,(n)) a[i]=read()\n//#define endl \"\\n\"\nconstexpr int mod = 1e9 + 7;\nconstexpr int Mod = 998244353;\nconstexpr int MXN = 500000 + 100;\nconstexpr ld EPS = 1e-10;\nconstexpr ll inf = 3 * 1e18;\nconstexpr int Inf = 15 * 1e8;\nconst vec<int>dx{ -1,1,0,0 }, dy{ 0,0,-1,1 };\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\nll read() { ll u, k = scanf(\"%lld\", &u); return u; }\nstring reads() { string s; cin >> s; return s; }\nH readh(bool g = 0) { H u; int k = scanf(\"%lld %lld\", &u.fs, &u.sc); if (g) u.fs--, u.sc--; return u; }\nbool inarea(H t, int h, int w) { return 0 <= t.fs && t.fs < h && 0 <= t.sc && t.sc < w; }\nll gcd(ll i, ll j) { return j ? gcd(j, i % j) : i; }\nll mod_pow(ll x, ll n, ll p = mod) {\n    ll res = 1; x %= p;\n    while (n > 0) {\n        if (n & 1) res = res * x % p;\n        x = x * x % p;\n        n >>= 1;\n    }\n    return res;\n}//x^n%p\nll bitcount(ll x) {\n    int sum = 0; for (int i = 0; i < 60; i++)if ((1ll << i) & x) sum++;\n    return sum;\n}\n/*constexpr int fn_ = 5000005;\nll fact_[fn_], comp_[fn_];\nll comb(ll x, ll y, ll m) {\n    if (!fact_[0]) {\n        fact_[0] = 1; comp_[0] = 1;\n        for (int i = 1; i < fn_; i++)\n            fact_[i] = fact_[i - 1] * i % m;\n        comp_[fn_ - 1] = mod_pow(fact_[fn_ - 1], m - 2, m);\n        for (int i = fn_ - 2; i > 0; i--)\n            comp_iiiiiiiiiiiijijiii[i] = comp_[i + 1] * (i + 1) % m;\n    }\n    if (x < y) return 0;\n    return fact_[x] * comp_[x - y] % m * comp_[y] % m;\n}*/\n//--------------------------------------------------------------\nint n, m;\nstring t;\nint to[1000000];\nint to2[1000000];\nint to3[10][18][1000000];\nint d[1000000];\nvec<H>a;\nsigned main(){\n    cin >> m >> t;\n    n = pow(3, m);\n    rep(i, n) to[i] = (i + 1) % n;\n    rep(i, n) {\n        int h = 0;\n        int k = i;\n        int t = 1;\n        rep(j, m) {\n            h += ((3 - k % 3) % 3) * t;\n            k /= 3; t *= 3;\n        }\n        to2[i] = h;\n    }\n    //Rを1回→to\n    //Sを1回→to2\n    for (int i = 0; i < t.size();) {\n        int j = i;\n        while (j < t.size() && t[i] == t[j]) j++;\n        if (t[i] == 'S' && (j - i) % 2 == 1)  a.pb(1, 1);\n        else if (t[i] == 'R') a.pb(0, j - i);\n        i = j;\n    }\n    vec<H>u;\n    vec<int>v;\n    for (int i = 0; i < a.size();) {\n        int j = i, sum = 0;\n        while (j < a.size() && a[i].fs == a[j].fs) sum += a[j].sc, j++;\n        u.pb(H{ a[i].fs,sum });\n        if (a[i].fs == 0) v.pb(sum);\n        i = j;\n    }\n    a = u;//この時点で圧縮が完了した\n    crdcomp(v);\n    rep(i, min(10ll, (ll)v.size())) {\n        //v[i]個の後Sが来るような組み合わせをj回行ったときどうなるかな？\n        rep(j, n) {\n            to3[i][0][j] = to2[(j + v[i]) % n];\n        }\n        rng(j, 1, 18)rep(k, n) {\n            to3[i][j][k] = to3[i][j - 1][to3[i][j - 1][k]];\n        }\n        d[v[i]] = i + 1;\n    }\n    vec<int>b(n);\n    rep(i, n) b[i] = i;\n    for (int i = 0; i < a.size();) {\n        vec<int>c(n);\n        if (a[i].fs == 1) {\n            rep(j, n) c[to2[j]] = b[j];\n            b = c;\n            i++;\n        }\n        else {\n            if (d[a[i].sc] && i < a.size() - 1) {\n                int sum = 0, j = i, r = i;\n                for (; i + 1 < a.size() && a[i].sc == a[j].sc; i += 2) {\n                    sum++;\n                }\n                for (int j = 19; j >= 0; j--) {\n                    if (sum >= (1 << j)) {\n                        rep(z, n) c[to3[d[a[r].sc]-1][j][z]] = b[z];\n                        sum -= (1 << j);\n                        b = c;\n                    }\n                }\n            }\n            else {\n                rep(j, n) c[(j + a[i].sc) % n] = b[j];\n                b = c;\n                i++;\n            }\n        }\n    }\n    vec<int>ans(n);\n    rep(i, n) ans[b[i]] = i;\n    rep(i, n) cout << ans[i] << ssp(i, n);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n/*\nN = 1\n\n0\n1\n2\n\nN = 2\n\n00\n01\n02\n10\n11 - (time=5, time=8) > 21\n12\n20\n21 = 3^1 * 1 + 3^0 * 2     x/3\n22\n\nN = 3\n\n020 -> ?11\n\nsalsa flips 1's and 2's\n\nSSSRRRSSRSRRSSRRSSSRRSR\n        ^      ^\n        \n        O(overflows)\n        \n        \n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\ne\n0\n1\n2\n00\n01\n02\n10\n11\n12\n20\n21\n22\n000\n001\n002\n*/        \n        \nconst int nax = 540123;\nchar s[nax];\nvector<int> moments_of_change[13][nax];\nint perm[13][nax];\n\nint n;\nint reverse_trits(int mask) {\n\tint real_value = 0;\n\tfor(int i = 0; i < n; ++i) {\n\t\treal_value = 3 * real_value + mask % 3;\n\t\tmask /= 3;\n\t}\n\treturn real_value;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", s);\n\tint S = strlen(s);\n\tint my_power = 1;\n\t\n\tfor(int i = 0; i < S; ++i) {\n\t\tif(s[i] == 'R') {\n\t\t\tmoments_of_change[0][0].push_back(i);\n\t\t}\n\t}\n\t\n\tvector<int> pref(S + 1);\n\tfor(int i = 1; i <= S; ++i) {\n\t\tpref[i] = pref[i-1] + (s[i-1] == 'S');\n\t}\n\t\n\tfor(int mask_len = 1; mask_len <= n; ++mask_len) {\n\t\tmy_power *= 3;\n\t\tfor(int mask = 0; mask < my_power; ++mask) {\n\t\t\tint parent = mask / 3;\n\t\t\tint digit = mask % 3;\n\t\t\tint prv = -1;\n\t\t\t// int memo_digit = digit;\n\t\t\t\n\t\t\tfor(vector<int> tmp : {moments_of_change[mask_len-1][parent], {S}}) {\n\t\t\t\tfor(int now : tmp) {\n\t\t\t\t\tint salsas = pref[now] - pref[prv+1];\n\t\t\t\t\t// for(int i = prv + 1; i < now; ++i) {\n\t\t\t\t\t\t// if(s[i] == 'S') {\n\t\t\t\t\t\t\t// salsas++;\n\t\t\t\t\t\t// }\n\t\t\t\t\t// }\n\t\t\t\t\tif(salsas % 2) {\n\t\t\t\t\t\tif(digit == 1) {\n\t\t\t\t\t\t\tdigit = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(digit == 2) {\n\t\t\t\t\t\t\tdigit = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(now != S) {\n\t\t\t\t\t\tdigit++;\n\t\t\t\t\t\tif(digit == 3) {\n\t\t\t\t\t\t\tdigit = 0;\n\t\t\t\t\t\t\tmoments_of_change[mask_len][mask].push_back(now);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tprv = now;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// debug() << imie(mask) imie(memo_digit) imie(digit);\n\t\t\t\n\t\t\tperm[mask_len][mask] = perm[mask_len-1][parent] * 3 + digit;\n\t\t}\n\t}\n\tvector<int> answer(my_power);\n\tfor(int mask = 0; mask < my_power; ++mask) {\n\t\t// answer[reverse_trits(mask)]\n\t\t// int cur = mask;\n\t\t// int real_value = 0;\n\t\t// for(int rep = 0; rep < n; ++rep) {\n\t\t\t// real_value = 3 * real_value + cur % 3;\n\t\t\t// cur /= 3;\n\t\t// }\n\t\tprintf(\"%d \", reverse_trits(perm[n][reverse_trits(mask)]));\n\t\t// debug() << imie(mask) imie();\n\t\t// debug() << imie(mask) imie(perm[n][mask]);\n\t}\n\tputs(\"\");\n\t\n\t/*\n\tvector<int> moments_of_change[3**n];\n\tvector<pair<int,int>> overflows; // (when, which_number)\n\t// path_of[0]\n\tfor(int trit = 0; trit < N; ++trit) {\n\t\t\n\t}*/\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,ans[531441];\nstatic inline void OUT(int x){if(x>=10)OUT(x/10);putchar(x%10+48);}\nstatic inline int Pow(int a,int b){return b?Pow(a*a,b>>1)*(b&1?a:1):1;}\nstring reduce(string T)\n{\n  string res=\"\";\n  for(auto ch:T){if(res.size()&&res.back()=='S'&&ch=='S')res.pop_back();else res+=ch;}\n  return res;\n}\nvoid solve(int m,string T,int i,int p)\n{\n  if(m==N){ans[i]=p;return;}\n  rep(d,3)\n  {\n    string nextT=\"\";int x=d;\n    for(auto ch:T){if(ch=='S'){x=(3-x)%3;nextT+='S';}else{x=(x+1)%3;if(x==0)nextT+='R';}}\n    solve(m+1,reduce(nextT),i+d*Pow(3,m),p+x*Pow(3,m));\n  }\n}\nint main(){string T;cin>>N>>T;solve(0,reduce(T),0,0);rep(i,Pow(3,N)){OUT(ans[i]),putchar(' ');}}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n// #include <ext/pb_ds/assoc_container.hpp> \n// #include <ext/pb_ds/detail/standard_policies.hpp>\n// using namespace __gnu_pbds;\n\n#pragma GCC optimize(\"O3\")\n#ifdef LOCAL\n#include \"/Users/lbjlc/Desktop/coding/debug_utils.h\"\n#else\n#define print(...) ;\n#define printn(...) ;\n#define fprint(...) ;\n#define fprintn(...) ;\n#endif\n\n#define rep(i, a, b) for(auto i = (a); i < (b); i++)\n#define rrep(i, a, b) for(auto i = (a); i > (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define pb push_back\n// #define mp make_pair\n#define fi first\n#define se second\n#define maxi(x, y) x = max(x, y)\n#define mini(x, y) x = min(x, y)\n// long long fact(long long n) { if(!n) return 1; return n*fact(n-1); }\n// #define endl '\\n'\n#define solve_testcase int T;cin>>T;for(int t=1;t<=T;t++){solve(t);}\n\n// long long gcd(long long x, long long y) { return y ? gcd(y, x % y) : x; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\n \ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n \ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\ntypedef vector<long long> vll;\n#define bd(type,op,val) bind(op<type>(), std::placeholders::_1, val)\n\nconst int MAXN = 1e6+10;\n\n\nvoid solve(int tt) {\n    // cout<<\"Case #\"<<tt<<\": \";\n}\n\nstring to_ter(int x, int k=-1) {\n    string res;\n    while(x) {\n        res+='0'+x%3;\n        x/=3;\n    }\n    if(k>=0) {\n        while(res.size()<k) res+='0';\n    }\n    return res;\n}\nint to_int(const string & s) {\n    int res=0;\n    // rrep(i,s.size()-1,-1)\n    //     res=res*3+(s[i]-'0');\n    for(int i=s.size()-1;i>=0;i--)\n        res=res*3+(s[i]-'0');\n    // print(s,res);\n    return res;\n}\nbool add(string & x, const string & y) {\n    int n1=x.size(), n2=y.size(),carry=0;\n    rep(i,0,n1) {\n        if(i<n1) carry+=x[i]-'0';\n        if(i<n2) carry+=y[i]-'0';\n        x[i]=carry%3+'0';\n        carry/=3;\n    }\n    return carry==0;\n}\n\nvi cal_inst(string & s) {\n    int n=s.size();\n    vi res(1);\n    int i=0;\n    while(i<n) {\n        if(s[i]=='R') {\n            res.back()++;\n            i++;\n        }\n        else {\n            int j=i;\n            for(;j<n&&s[j]=='S';j++);\n            if((j-i)%2) res.pb(0);\n            i=j;\n        }\n    }\n    if(s.back()=='S') res.pop_back();\n    return res;\n}\n\nchar rev(char c) {\n    if(c>'0') return '0'+(3-(c-'0'));\n    return c;\n}\nstring rev(string s) {\n    for(auto & c:s) c=rev(c);\n    return s;\n}\n\nint len(string & s) {\n    int res=s.size()-1;\n    while(res>=0&&s[res]=='0') res--;\n    return res+1;\n}\n\nint power[13]={};\nint revmap[MAXN]={};\nint tmpres[MAXN];\nint rev(int x) {\n    for(int flag=1;flag<power[12];flag*=3) {\n        int tmp=x/flag%3;\n        if(tmp==1) x+=flag;\n        else if(tmp==2) x-=flag;\n    }\n    return x;\n}\n\nvoid cal(vi inst, int n, int tot) {\n    // vi tmpres(tot,-1);\n    fill(tmpres,tmpres+tot,-1);\n\n    rep(i,0,tot) {\n        if(tmpres[i]>=0) continue;\n\n        int cur=i,ok=1;\n        for(auto x:inst) {\n            cur+=x;\n            if(cur>=power[n]) {\n                ok=0; \n                cur%=power[n];\n            }\n            cur=revmap[cur];\n        }\n        // if(i<=9) print(i,cur);\n        tmpres[i]=cur;\n        // assert(cur>=0);\n        if(!ok) continue;\n        int flag=1,tmp;\n        for(;flag<=i||flag<=cur;flag*=3);\n\n        if(inst.size()%2==0) {\n            for(tmp=flag;tmp<power[n];tmp+=flag) {\n                tmpres[tmp+i]=tmp+cur;\n            }\n        }\n        else {\n            for(tmp=flag;tmp<power[n];tmp+=flag) {\n                tmpres[tmp+i]=revmap[tmp]+cur;\n            }\n\n        }\n    }\n    // print(1);\n    // print(*max_element(all(res)),*min_element(all(res)));\n    // return res;\n}\n\nint main(int argc, char * argv[]) {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    // solve_testcase;\n\n    int n;\n    string s;\n    cin>>n;\n    cin>>s;\n\n    // n=12;\n    // rep(i,0,1e5) s+=\"RS\";\n\n    power[0]=1;\n    rep(i,1,13) power[i]=power[i-1]*3;\n\n    int tot=1;\n    rep(i,0,n) tot*=3;\n\n    rep(i,0,tot) {\n        if(i>=3) {\n            if(i%3==0)\n                revmap[i]=revmap[i/3]*3;\n            else\n                revmap[i]=revmap[i-i%3]+rev(i%3);\n        }\n        else\n            revmap[i]=rev(i);\n    }\n    // printn(revmap,9);\n\n\n    vi inst=cal_inst(s);\n    for(auto & x:inst) x%=tot;\n\n    // print(inst);\n\n    int i=0;\n    int bound=729;\n    vi res(tot);\n    iota(all(res),0);\n    while(i<inst.size()) {\n        int cur=inst[i];\n        vi cur_inst({cur});\n        for(++i;i<inst.size()&&cur+inst[i]<bound;i++) {\n            cur+=inst[i];\n            cur_inst.pb(inst[i]);\n        }\n        cal(cur_inst,n,tot);\n        // print(tmp);\n        rep(j,0,tot) res[j]=tmpres[res[j]];\n        // print(cur_inst,tmp);\n        // print(res);\n        // sort(all(tmp)); print(tmp);\n    }\n    if(s.back()=='R') {\n        rep(i,0,tot) {\n            res[i]=revmap[res[i]];\n        }\n    }\n    for(auto x:res) cout<<x<<' ';\n    cout<<endl;\n\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 2e5 + 10;\nconst int maxp = 531500;\nint ans[maxp];\nvoid one(int n)\n{\n\tfor (int i = 0; i < (int)pow(3, n); i++)\n\t{\n\t\tint res = 0;\n\t\tint three = 1;\n\t\twhile (ans[i])\n\t\t{\n\t\t\tint d = ans[i] % 3;\n\t\t\tif (d == 2)\n\t\t\t{\n\t\t\t\tres = res + three * 1;\n\t\t\t}\n\t\t\telse if (d == 1)\n\t\t\t{\n\t\t\t\tres = res + three * 2;\n\t\t\t}\n\t\t\telse if (d == 0)\n\t\t\t{\n\t\t\t\tres = res + three * 0;\n\t\t\t}\n\t\t\tthree *= 3;\n\t\t\tans[i] /= 3;\n\t\t}\n\t\tans[i] = res;\n\t}\n}\nvoid two(int n)\n{\n\tfor (int i = 0; i < (int)pow(3, n); i++)\n\t{\n\t\tans[i] += 1;\n\t\tans[i] %= (int)pow(3, n);\n\t}\n}\nint main()\n{\n\tint n;\n\tchar t[maxn];\n\tcin >> n >> t;\n\tfor (int i = 0; i < (int)pow(3, n); i++)\n\t{\n\t\tans[i] = i;\n\t}\n\tfor (int i = 0; t[i]; i++)\n\t{\n\t\tif (t[i] == 'S')\n\t\t{\n\t\t\tone(n);\n\t\t}\n\t\telse if (t[i] == 'R')\n\t\t{\n\t\t\ttwo(n);\n\t\t}\n\t}\n\tfor (int i = 0; i < (int)pow(3, n); i++)\n\t\tcout << ans[i] << \" \";\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string>\n#include<cmath>\n\nusing namespace std;\n\nint main(){\n    int N,p,size,len,tmp1,tmp2,cou=3,sw;\n    string T;\n    cin >> N;\n    cin >> T;\n    size = int(pow(3,N));\n    vector<int> table(size);\n    len = T.length();\n    table[0] = 0;\n    for(int i=1;i<size;i++){\n        if(i % 3 == 0){\n            if(i == cou){\n                sw = 1;\n                table[i] = cou * 2;\n                tmp1 = cou;\n                tmp2 = cou*2;\n                cou *= 3;\n            }else if(i == tmp2){\n                table[i] = tmp1;\n                sw = 2;\n            }else{\n                if(sw == 1){\n                    table[i] = table[i-tmp1] + tmp2;\n                }else{\n                    table[i] = table[i-tmp2] + tmp1;\n                }\n            }\n        }else if(i % 3 == 1){\n            table[i] = table[i-1] + 2;\n        }else{\n            table[i] = table[i-1] - 1;\n        }\n    }\n    //for(int i=0;i<size;i++) cout << i << ' ' <<table[i] << endl;;\n\n    for(int i=0;i<size;i++){\n        p=i;\n        for(int j=0;j<len;j++){\n            if(T[j] == 'S'){\n                if(T[j+1] == 'S') j++;\n                else p = table[p];\n            }else{\n                p++;\n                if(p==size) p=0;\n            }\n        }\n        cout << p << ' ';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nusing P = pair<ll, ll>;\n#define rep(i, n)  for (int i = 0; i <  (int)(n); i++)\n#define rep1(i, n) for (int i = 1; i <= (int)(n); i++)\n#define all(x) (x).begin(), (x).end()\nconst ll INF = ll(1e18)+1;\n\nll sarusa(ll target,ll n){\n    ll result = 0;\n    rep(i,n){\n        ll powre = pow(3,n-i-1);\n        if(target / powre == 1){\n            result += powre * 2;\n        }\n        else if(target / powre == 2){\n            result += powre * 1;\n        }\n        target %= powre;\n    }\n    return result;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n;\n    string t;\n    cin >> n >> t;\n\n    vector<ll> result(pow(3,n));\n    vector<ll> hyo(pow(3,n));\n    rep(i,pow(3,n)){\n        hyo[i] = sarusa(i,n);\n        result[i] = i;\n    }\n\n    rep(i,t.size()){\n        // cout << t[i];\n        if(t[i] == *\"S\"){\n            rep(i,pow(3,n)){\n                result[i] = hyo[result[i]];\n                // cout << result[i] << \":\" << hyo[result[i]] << \"\\n\";\n            }\n        }\n        else{\n            rep(i,pow(3,n)){\n                result[i]++;\n                if(result[i] == pow(3,n)){\n                    result[i] = 0;\n                }\n            }\n        }\n        // rep(i,pow(3,n)){\n        //     cout << result[i] << \" \";\n        // }\n        // cout << \"\\n\";\n    }\n    \n    rep(i,pow(3,n)){\n        cout << result[i] << \" \";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <numeric>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\nstring shrink(string t){\n  string t_;\n  for(int i=0; i<t.size(); i++){\n    if(i+1<t.size() && t[i] == 'S' && t[i+1] == 'S'){\n      i++;\n      continue;\n    }\n    t_ += t[i];\n  }\n  return t_;\n}\n\nvoid rec(vector<int>& ans, string& t, vector<int> x, int d, int n){\n  if(n == 0){\n    return;\n  }\n  array<vector<int>, 3> type;\n  for(int i: x){\n    type[(i / d) % 3].push_back(i);\n  }\n  x = {};\n\n  // f(t, v) -> u\n  array<int, 3> mp{0, 1, 2};\n  array<int, 3> mp_inv{0, 1, 2};\n  array<string, 3> t_{};\n  for(int j=0; j<t.size(); j++){\n    if(t[j] == 'S'){\n      int now_1 = mp_inv[1];\n      int now_2 = mp_inv[2];\n      swap(mp[now_1], mp[now_2]);\n      swap(mp_inv[1], mp_inv[2]);\n\n      for(int k: range(3)){\n        if(t_[k].size() && t_[k].back() == 'S'){\n          t_[k].pop_back();\n        }else{\n          t_[k] += 'S';\n        }\n      }\n    }else{\n      int now_2 = mp_inv[2];\n      t_[now_2] += 'R';\n\n      for(int k: range(3)){\n        mp[k] = (mp[k]+1) % 3;\n        mp_inv[mp[k]] = k;\n      }\n    }\n  }\n  t = \"\";\n\n  for(int k: range(3)){\n    for(int i: type[k]){\n      ans[i] += mp[k] * d;\n    }\n  }\n  for(int k: range(3))\n    rec(ans, t_[k], type[k], d*3, n-1);\n}\n\nint main(){\n  int n;\n  cin >> n;\n  string t;\n  cin >> t;\n\n  t = shrink(t);\n  int m = my_pow(3, n);\n  vector<int> x(m);\n  iota(begin(x), end(x), 0);\n  vector<int> ans(m);\n  rec(ans, t, x, 1, n);\n\n  println(join(ans, \" \"));\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cassert>\n#include<stdexcept>\n#include<utility>\n#include<functional>\n#include<numeric>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<array>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<complex>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<bitset>\n#include<memory>\nusing namespace std;\nusing ll=long long;\n\nconst int SZ = 10;\nint n;\nint pow3n;\nvector<int> sal;\nvoid init_s(){\n    sal.resize(pow3n);\n    iota(sal.begin(),sal.end(),0);\n    for(int i=0;i<pow3n;i++){\n        int x = i;\n        int tar = 0;\n        int r = 1;\n        for(int j=0;j<n;j++){\n            tar+= (x%3*2)%3*r;\n            x/=3;\n            r*=3;\n        }\n        if(tar<i){\n            // cerr<<i<<\" \"<<tar<<endl;\n            swap(sal[tar],sal[i]);\n        }\n    }\n}\n\n\nvoid do_r(vector<int>& pat){\n    int head = pat[pow3n-1];\n    for(int i=pow3n-1;i>0;i--){\n        pat[i]=pat[i-1];\n    }\n    pat[0] = head;\n}\nint ary[1000000];\nvoid perm(vector<int>& pat,vector<int>& par){\n    for(int i=0;i<pow3n;i++) ary[i] = pat[par[i]];\n    for(int i=0;i<pow3n;i++) pat[i] = ary[i];\n}\nvoid do_s(vector<int>& pat){\n    perm(pat,sal);\n}\nint main(){\n    cin>>n;\n    pow3n=1;\n    for(int i=0;i<n;i++) pow3n*=3;\n    init_s();\n    \n    string t;\n    {\n        string tmp;\n        cin>>tmp;\n        for(auto c:tmp){\n            if(!t.empty() && t.back()=='S' && c=='S') t.pop_back();\n            else t+=c;\n        }\n    }\n\n    vector<vector<int>> memo(1<<SZ);\n    \n    for(int bit=0;bit<(1<<SZ);bit++){\n        bool ispass= false;\n        for(int j=0;j+1<SZ;j++){\n            if(((bit>>j)&1)==0 && ((bit>>(j+1)))==0) ispass=true;\n        }\n        if(ispass) continue;\n\n        memo[bit].resize(pow3n);\n        iota(memo[bit].begin(),memo[bit].end(),0);\n        for(int j=0;j<SZ;j++){\n            if(((bit>>j)&1)==0) do_s(memo[bit]);\n            else do_r(memo[bit]);\n        }\n    }\n    vector<int> res(pow3n);\n    iota(res.begin(),res.end(),0);\n    \n    for(int i=0;i<t.size()/SZ;i++){\n        int bit = 0;\n        for(int j=0;j<SZ;j++){\n            if(t[i*SZ+j]=='R') bit+=(1<<j);\n        }\n        // cerr<<\"#\"<<i<<endl;\n        // for(int i=0;i<pow3n;i++) cerr<<res[i]<<\" \";\n        // cerr<<endl;\n        // for(int i=0;i<pow3n;i++) cerr<<memo[bit][i]<<\" \";\n        // cerr<<endl;\n        perm(res,memo[bit]);\n        // for(int i=0;i<pow3n;i++) cerr<<res[i]<<\" \";\n        // cerr<<endl;\n    }\n\n    for(int i=t.size()/SZ*SZ;i<t.size();i++){\n        // cerr<<\"#\"<<endl;\n        if(t[i]=='S') do_s(res);\n        else do_r(res);\n    }\n    vector<int> inv(pow3n);\n    for(int i=0;i<pow3n;i++) inv[res[i]]=i;\n    for(int i=0;i<pow3n;i++) cout<<inv[i]<<\" \";\n    cout<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long solve(long long n){\n\tlong long t=n,m,ans=0;\n\twhile(t!=0){\n\t\tm=t%3;\n\t\tt/=3;\n\t\tif(m==1)n+=pow(3,ans);\n\t\tif(m==2)n-=pow(3,ans);\n\t\tans++;\n\t}\n\treturn n;\n}\nint main(){\n\t int n,ans;\n\t string s;\n\t cin>>n>>s;\n\t for(long long j=0;j<pow(3,n);j++){\n\t \tans=j;\n\t \tfor(int i=0;i<s.length();i++){\n\t \t\n\t \t if(s[i]=='R'){\n\t \t\tif(ans==pow(3,n)-1)ans=0;\n\t \t\telse ans++;\n\t\t \t}\n\t\t\tif(s[i]=='S'){\n\t\t \tans=solve(ans);\n\t\t }\t\n\t \t}\n\t\t \n\t\t \n\t\t cout<<ans<<\" \";\n\t }\n\t return 0;\n\t\n\t\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n \nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n\n#define MOD 1000000007LL\n\nint N;\nstring T;\nvector<int> p;\n//map<int, int> sa;\nvector<int> sa;\nint tn;\nint os=0;\n\nint tri(int n) {\n  int ans=1;\n  for (int i=0; i<n; i++) ans *= 3;\n  return ans;\n}\n\nvoid salsa();\nvoid rumba();\nvoid print_ln();\n\nint main()\n{\n  int l;\n  int i;\n\n  cin >> N >> T;\n  tn = tri(N);\n\n  p.resize(tn);\n  sa.resize(tn);\n  for (int i=0; i<tn; i++) {\n    p[i] = i;\n  }\n  sa[0] = 0; sa[1] = 2; sa[2]=1;\n  {\n    int t=3;\n    int cv;\n    for (int i=3; i<tn; i++) {\n      if (i>=t*3) t *= 3;\n      cv = sa[i%t];\n      switch(i/t) {\n      case 1: cv += t*2; break;\n      case 2: cv += t; break;\n      }\n      sa[i] = cv;\n    }\n  }\n\n//for (int i=0; i<tn; i++) printf(\"sa[%d]=%d\\n\", i, sa[i]);\n\n//print_ln();\n\n  l = T.size();\n  for (i=0; i<l; i++) {\n    if (T[i] == 'S') {\n      if (T[i+1] == 'S') {\n        i++;\n        continue;\n      }\n      salsa();\n//printf(\"S \");\n//print_ln();\n    } else {\n      os++;\n      os%=tn;\n//      rumba();\n//printf(\"R \");\n//print_ln();\n    }\n  }\n\n  print_ln();\n\n  return 0;\n}\n\nvoid salsa() {\n  int i;\n\n  for (i=0; i<tn; i++) {\n    p[i] = sa[p[i]+os];\n  }\n  os = 0;\n}\nvoid rumba() {\n  int i;\n  for (i=0; i<tn; i++) {\n    p[i]++;\n    p[i]%=tn;\n  }\n}\n\nvoid print_ln() {\n  int i;\n  printf(\"%d\", (p[0]+os)%tn);\n  for (i=1; i<tn; i++) printf(\" %d\", (p[i]+os)%tn);\n  printf(\"\\n\");\n}\n/*\n  a*3^3+b*3^2+c*3+d\n  */\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n// #include <ext/pb_ds/assoc_container.hpp> \n// #include <ext/pb_ds/detail/standard_policies.hpp>\n// using namespace __gnu_pbds;\n\n#pragma GCC optimize(\"O3\")\n#ifdef LOCAL\n#include \"/Users/lbjlc/Desktop/coding/debug_utils.h\"\n#else\n#define print(...) ;\n#define printn(...) ;\n#define fprint(...) ;\n#define fprintn(...) ;\n#endif\n\n#define rep(i, a, b) for(auto i = (a); i < (b); i++)\n#define rrep(i, a, b) for(auto i = (a); i > (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define pb push_back\n// #define mp make_pair\n#define fi first\n#define se second\n#define maxi(x, y) x = max(x, y)\n#define mini(x, y) x = min(x, y)\n// long long fact(long long n) { if(!n) return 1; return n*fact(n-1); }\n// #define endl '\\n'\n#define solve_testcase int T;cin>>T;for(int t=1;t<=T;t++){solve(t);}\n\n// long long gcd(long long x, long long y) { return y ? gcd(y, x % y) : x; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\n \ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n \ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\ntypedef vector<long long> vll;\n#define bd(type,op,val) bind(op<type>(), std::placeholders::_1, val)\n\nconst int MAXN = 1e6+10;\n\n\nvoid solve(int tt) {\n    // cout<<\"Case #\"<<tt<<\": \";\n}\n\nstring to_ter(int x, int k=-1) {\n    string res;\n    while(x) {\n        res+='0'+x%3;\n        x/=3;\n    }\n    if(k>=0) {\n        while(res.size()<k) res+='0';\n    }\n    return res;\n}\nint to_int(const string & s) {\n    int res=0;\n    // rrep(i,s.size()-1,-1)\n    //     res=res*3+(s[i]-'0');\n    for(int i=s.size()-1;i>=0;i--)\n        res=res*3+(s[i]-'0');\n    // print(s,res);\n    return res;\n}\nbool add(string & x, const string & y) {\n    int n1=x.size(), n2=y.size(),carry=0;\n    rep(i,0,n1) {\n        if(i<n1) carry+=x[i]-'0';\n        if(i<n2) carry+=y[i]-'0';\n        x[i]=carry%3+'0';\n        carry/=3;\n    }\n    return carry==0;\n}\n\nvi cal_inst(string & s) {\n    int n=s.size();\n    vi res(1);\n    int i=0;\n    while(i<n) {\n        if(s[i]=='R') {\n            res.back()++;\n            i++;\n        }\n        else {\n            int j=i;\n            for(;j<n&&s[j]=='S';j++);\n            if((j-i)%2) res.pb(0);\n            i=j;\n        }\n    }\n    if(s.back()=='S') res.pop_back();\n    return res;\n}\n\nchar rev(char c) {\n    if(c>'0') return '0'+(3-(c-'0'));\n    return c;\n}\nstring rev(string s) {\n    for(auto & c:s) c=rev(c);\n    return s;\n}\n\nint len(string & s) {\n    int res=s.size()-1;\n    while(res>=0&&s[res]=='0') res--;\n    return res+1;\n}\n\nint power[13]={};\nint revmap[MAXN]={};\nint tmpres[MAXN];\nint rev(int x) {\n    for(int flag=1;flag<power[12];flag*=3) {\n        int tmp=x/flag%3;\n        if(tmp==1) x+=flag;\n        else if(tmp==2) x-=flag;\n    }\n    return x;\n}\n\nvoid cal(vi inst, int n, int tot) {\n    // vi tmpres(tot,-1);\n    fill(tmpres,tmpres+tot,-1);\n\n    rep(i,0,tot) {\n        if(tmpres[i]>=0) continue;\n\n        int cur=i,ok=1;\n        for(auto x:inst) {\n            cur+=x;\n            if(cur>=power[n]) {\n                ok=0; \n                cur%=power[n];\n            }\n            cur=revmap[cur];\n        }\n        // if(i<=9) print(i,cur);\n        tmpres[i]=cur;\n        // assert(cur>=0);\n        if(!ok) continue;\n        int flag=1,tmp;\n        for(;flag<=i||flag<=cur;flag*=3);\n\n        if(inst.size()%2==0) {\n            for(tmp=flag;tmp<power[n];tmp+=flag) {\n                tmpres[tmp+i]=tmp+cur;\n            }\n        }\n        else {\n            for(tmp=flag;tmp<power[n];tmp+=flag) {\n                tmpres[tmp+i]=revmap[tmp]+cur;\n            }\n\n        }\n    }\n    // print(1);\n    // print(*max_element(all(res)),*min_element(all(res)));\n    // return res;\n}\n\nint main(int argc, char * argv[]) {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    // solve_testcase;\n\n    int n;\n    string s;\n    cin>>n;\n    cin>>s;\n\n    // n=12;\n    // rep(i,0,1e5) s+=\"RS\";\n\n    power[0]=1;\n    rep(i,1,13) power[i]=power[i-1]*3;\n\n    int tot=1;\n    rep(i,0,n) tot*=3;\n\n    rep(i,0,tot) {\n        if(i>=3) {\n            if(i%3==0)\n                revmap[i]=revmap[i/3]*3;\n            else\n                revmap[i]=revmap[i-i%3]+rev(i%3);\n        }\n        else\n            revmap[i]=rev(i);\n    }\n    // printn(revmap,9);\n\n\n    vi inst=cal_inst(s);\n    for(auto & x:inst) x%=tot;\n\n    // print(inst);\n\n    int i=0;\n    int bound=500;\n    vi res(tot);\n    iota(all(res),0);\n    while(i<inst.size()) {\n        int cur=inst[i];\n        vi cur_inst({cur});\n        for(++i;i<inst.size()&&cur+inst[i]<bound;i++) {\n            cur+=inst[i];\n            cur_inst.pb(inst[i]);\n        }\n        cal(cur_inst,n,tot);\n        // print(tmp);\n        rep(j,0,tot) res[j]=tmpres[res[j]];\n        // print(cur_inst,tmp);\n        // print(res);\n        // sort(all(tmp)); print(tmp);\n    }\n    if(s.back()=='R') {\n        rep(i,0,tot) {\n            res[i]=revmap[res[i]];\n        }\n    }\n    for(auto x:res) cout<<x<<' ';\n    cout<<endl;\n\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint change3(int A){\n  vector<int> b3(0);\n  while(A>2){\n    int aw3 = A%3;\n    b3.push_back((aw3==0)?0:\n                 (aw3==1)?2:1);\n    A/=3;\n  }\n  int aw3 = A%3;\n  b3.push_back((aw3==0)?0:\n               (aw3==1)?2:1);\n  int sum=0;\n  for(int i=0;i<b3.size();i++){\n   sum+= pow(3,i)*b3.at(i); \n  }\n  return sum;\n}\n\n\nint main() {\n  int N;\n  cin >> N;\n  int N3 = pow(3,N);\n  vector<int> dan(N3);\n  vector<int> c3b(N3);\n  for(int i=0;i<N3;i++){\n    dan.at(i)=i;\n    c3b.at(i)=change3(i);\n  }\n  string recode;\n  vector<pair<bool,int>> recode2;\n  cin >> recode;\n  string set=\"\";\n  string recode3=\"\";\n  char mi=recode.at(0);\n  bool flg=true;\n  int coco=0;\n  recode+=char(0);\n  for(char i:recode){\n    if(i==mi){\n      set+=i;\n    }else{\n      if(!(set.at(0)=='S'&&set.size()%2==0))recode3+=set;\n      set=i;\n    }\n    mi=i;\n  }\n  mi=recode3.at(0);\n  recode3+=(recode3.at(recode3.size()-1)=='S')?'R':'S';\n  for(char i:recode3){\n    if(mi!=i){\n     flg=(i=='S')?false:true;\n     recode2.push_back(make_pair(flg,coco));\n      coco=0;\n    }\n    coco++;\n    mi=i; \n  }\n  \n  \n \n  \n  for(pair<bool,int> i:recode2){\n    if(i.first){\n     for(int &j:dan){\n      j=c3b.at(j); \n     }\n    }else if(!i.first){\n      for(int &j:dan){\n        j+=i.second;\n        if(j>=N3)j-=N3;\n      }\n    }\n      \n      \n  }\n    \n    \n  for(int i:dan){\n    cout << i << \" \";\n  }\n  cout << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuThOr Gwj\n*/\n#include<bits/stdc++.h>\n#define rb(a,b,c) for(int a=b;a<=c;++a)\n#define rl(a,b,c) for(int a=b;a>=c;--a)\n#define LL long long\n#define IT iterator\n#define PB push_back\n#define II(a,b) make_pair(a,b)\n#define FIR first\n#define SEC second\n#define FREO freopen(\"check.out\",\"w\",stdout)\n#define rep(a,b) for(int a=0;a<b;++a)\n#define KEEP while(1)\n#define SRAND mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#define random(a) rng()%a\n#define ALL(a) a.begin(),a.end()\n#define POB pop_back\n#define ff fflush(stdout)\n#define fastio ios::sync_with_stdio(false)\n#define debug_pair(A) cerr<<A.FIR<<\" \"<<A.SEC<<endl;\nusing namespace std;\nconst int INF=0x3f3f3f3f;\ntypedef pair<int,int> mp;\ntypedef pair<mp,mp> superpair;\nint N,LOGN,n;\n\nstruct node{\n\tint val;\n\tvector<mp> sons;\n\tbool flag;\n\tvoid push_down(){\n\t\tif(!flag||sons.empty()){\n\t\t\treturn;\n\t\t}\n\t\tflag=0;\n\t\tint i1,i2;\n\t\trep(i,3)\n\t\t\tif(sons[i].FIR==1) i1=i;\n\t\trep(i,3)\n\t\t\tif(sons[i].FIR==2) i2=i;\n\t\tswap(sons[i1].FIR,sons[i2].FIR);\n\t} \n}trie[2000000];\nvoid gao(int index){\n\ttrie[index].flag^=1;\t\n}\nint cnt=1;\nint b[13];\nvoid build(int now,int depth,int val){\n\tif(depth==LOGN+1) {\n//\t\tcout<<now<<\" \"<<val<<endl;\n\t\ttrie[now].val=val;\n\t\treturn;\n\t}\n\ttrie[now].sons.PB(II(0,++cnt));\n\tbuild(cnt,depth+1,val);\n\ttrie[now].sons.PB(II(1,++cnt));\n\tbuild(cnt,depth+1,val+b[-1+depth]);\n\ttrie[now].sons.PB(II(2,++cnt));\t\n\tbuild(cnt,depth+1,val+b[-1+depth]*2);\n}\nvoid modify(int now){\n//\tcout<<\"!\" <<now<<endl;\n\tif(trie[now].sons.empty()) return;\n\tif(trie[now].flag){\n\ttrie[now].push_down();\n\t\trep(i,3)\n\t\tgao(trie[now].sons[i].SEC);\n\t}\n\trep(i,3)\n\t{\n\t\ttrie[now].sons[i].FIR++;\n\t\ttrie[now].sons[i].FIR%=3;\n\t\tif(!trie[now].sons[i].FIR){\n\t\t\tmodify(trie[now].sons[i].SEC);\n\t\t}\n\t}\n}\nint res[600000];\nvoid recover(int now,int pos,int depth){\n\tif(trie[now].sons.empty()){\n\t\tres[trie[now].val]=pos;\n\t}\n\telse{\t\n\t\tif(trie[now].flag){\n\t\t\n\t\ttrie[now].push_down();\n\t\t\trep(i,3)\n\t\t\tgao(trie[now].sons[i].SEC);\n\t\t}\n\t\trep(i,3){\n\t\t\trecover(trie[now].sons[i].SEC,pos+b[depth-1]*trie[now].sons[i].FIR,depth+1);\n\t\t}\n\t}\n}\nint main(){\n\tfastio;\n\tcin>>N;\n\tn=1;\n\trb(i,1,N) n*=3;\n\tb[0]=1;\n\trb(i,1,N)\n\t\tb[i]=b[i-1]*3;\n\tLOGN=N;\n\tN=n;\n\tbuild(1,1,0);\n\tstring T=\"\";\n\tcin>>T;\n\trep(INDEX,T.length()){\n\t\tbool ty=(T[INDEX]=='S');\n\t\tif(ty){\n\t\t\ttrie[1].flag^=1;\n\t\t}\n\t\telse{\n\t\t\tmodify(1);\n\t\t}\n\t}\n\trecover(1,0,1);\n\trb(i,0,N-1)\n\t\tcout<<res[i]<<\" \";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\nclass Radix {\nprivate:\n    const char* s;\n    int a[128];\npublic:\n    Radix(const char* s = \"0123456789ABCDEF\") : s(s) {\n        int i;\n        for (i = 0; s[i]; ++i)\n            a[(int)s[i]] = i;\n    }\n    std::string to(long long p, int q) {\n        int i;\n        if (!p)\n            return \"0\";\n        char t[64] = { };\n        for (i = 62; p; --i) {\n            t[i] = s[p % q];\n            p /= q;\n        }\n        return std::string(t + i + 1);\n    }\n    std::string to(const std::string& t, int p, int q) {\n        return to(to(t, p), q);\n    }\n    long long to(const std::string& t, int p) {\n        int i;\n        long long sm = a[(int)t[0]];\n        for (i = 1; i < (int)t.length(); ++i)\n            sm = sm * p + a[(int)t[i]];\n        return sm;\n    }\n};\n\nbool vector_has(vector<int> vec, int num) {\n    auto itr = std::find(vec.begin(), vec.end(), num);\n    size_t index = std::distance(vec.begin(), itr);\n    if (index != vec.size()) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\nint main() {\n    Radix r;\n    int N, temp;\n    string T;\n    int T_length;\n    cin >> temp;\n    N = (int)pow(3, temp);\n    cin >> T;\n    T_length = (int)T.length();\n    int* list = new int[N];\n    string temp_str;\n\n    // initialize\n    for (int i = 0; i < N; i++) {\n        list[i] = i;\n    }\n\n    // operation\n    for (int i = 0; i < T_length; i++) {\n        // salsa\n        if (T[i] == 'S') {\n            vector<vector<int>> swap_index(N, vector<int>(N));\n            for (int list_index = 0; list_index < N; list_index++)\n            {\n                    // convert list_index from decimal to ternary\n                    temp_str = r.to(list_index, 3);\n                    // swap 1 with 2\n                    replace(temp_str.begin(), temp_str.end(), '1', '2');\n                    replace(temp_str.begin(), temp_str.end(), '2', '1');\n\n                    // convert ternary to decimal\n                    temp = r.to(temp_str, 3);\n\n                    // check if swap hasn't been done for temp and list_index\n                    if (!vector_has(swap_index[list_index], temp)) {\n                        // convert string to integer\n                        swap(list[list_index], list[temp]);\n                        // register swapped opponent\n                        swap_index[list_index].push_back(temp);\n                        swap_index[temp].push_back(list_index);\n                    }\n\n            }\n        }\n        // rumba\n        else\n        {\n            for (int j = N - 1; 0 < j; j--) {\n                swap(list[j - 1], list[j]);\n            }\n        }\n    }\n    int* list_pos = new int[N];\n    for (int i = 0; i < N; i++) {\n        list_pos[list[i]] = i;\n    }\n\n    for (int i = 0; i < N; i++) {\n        cout << list_pos[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing int64 = long long;\n\nconstexpr int DEBUG = 0;\n\nint Power3(int p) {\n  int r = 1;\n  for (int i = 0; i < p; i++) {\n    r *= 3;\n  }\n  return r;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n  string original_command;\n  cin >> original_command;\n  vector<vector<int>> output_table(n + 1);\n  vector<vector<string>> command_table(n + 1);\n  for (int k = 1; k <= n; k++) {\n    output_table[k].reserve(Power3(k));\n    command_table[k].reserve(Power3(k));\n  }\n\n  for (int k = 1; k <= n; k++) {\n    for (int x = 0; x < Power3(k); x++) {\n      string command;\n      if (k == 1) {\n        command = original_command;\n      } else {\n        command = command_table[k - 1][x % Power3(k - 1)];\n      }\n\n      int d = x / Power3(k - 1);\n      string next_command = \"\";\n      for (char c : command) {\n        if (c == 'R') {\n          d++;\n          if (d == 3) {\n            d = 0;\n            next_command.append(\"R\");\n          }\n        } else if (c == 'S') {\n          if (d == 1) d = 2;\n          else if (d == 2) d = 1;\n\n          next_command.append(\"S\");\n        }\n      }\n\n      next_command = std::regex_replace(next_command, std::regex(\"SS\"), \"\");\n\n      output_table[k][x] = d;\n      command_table[k][x] = next_command;\n    }\n  }\n\n  vector<int> outputs;\n  for (int x = 0; x < Power3(n); x++) {\n    int output = 0;\n    for (int k = 1; k <= n; k++) {\n      output += output_table[k][x % Power3(k)] * Power3(k - 1);\n    }\n    outputs.push_back(output);\n  }\n\n  for (int i = 0; i < outputs.size(); i++) {\n    if (i > 0) cout << \" \";\n    cout << outputs[i];\n  }\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nstatic inline int Pow(int a,int b){return b?Pow(a*a,b>>1)*(b&1?a:1):1;}\nint main()\n{\n  int N,now,len=0,A[531441],B[531441];\n  char T[200001],S[200001];\n  now=scanf(\"%d %s\",&N,T);len=strlen(T);fflush(stdin);\n  int pw3=Pow(3,N),x=Pow(3,N>>1),y=Pow(3,N-(N>>1));\n  rep(i,pw3)B[i]=B[i/3]*3+(3-i%3)%3;\n  rep(i,x)\n  {\n    int temp=i;now=0;\n    rep(j,len)\n    {\n      if(T[j]=='S'){temp=B[temp];if(S[now]=='S')--now;else S[++now]='S';}\n      else{++temp;if(temp==x)S[++now]='R',temp=0;}\n    }\n    rep(j,y)\n    {\n      int keep=j;\n      rep(k,now)\n      {\n        if(S[k+1]=='S')keep=B[keep];\n        else if(S[k+1]=='R')if((++keep)==y)keep=0;\n      }\n      A[i+j*x]=temp+keep*x;\n    }\n  }\n  rep(i,pw3)printf(\"%d%c\",A[i],i+1==pw3?'\\n':' ');\n  return fflush(stdout),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,x,y,z,sw,pw3=1,A[531441]={0},B[531441]={0},S[531441]={0};\nchar T[200001];\nvoid OUT(int x){if(x<0)putchar('-'),x=-x;if(x>=10)OUT(x/10);putchar(x%10+48);}\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nsigned main(void)\n{\n  x=scanf(\"%d %s\",&N,T);\n  replace(T,\"SS\",\"\");if(T[0]=='\\n')return 0;\n  rep(i,N)\n  {\n    rep(j,pw3)rep(k,3)B[j+k*pw3]=k;\n    sw=1;\n    rep(p,strlen(T))\n    {\n      if(T[p]=='R')\n      {\n        y=S[p];\n        rep(j,3)\n        {\n          x=y+j*pw3,z=B[x]*sw;\n          if(z==-1)S[p]=x;if(z==2)S[p]=x;\n          B[x]++;if(sw<0)B[x]++;\n          B[x]%=3;\n        }\n      }\n      else sw*=-1;\n    }\n    rep(j,pw3)\n    {\n      y=A[j];\n      rep(k,3)\n      {\n        x=j+k*pw3;\n        if(sw>0)z=B[x]%3;else z=(3-B[x])%3;\n        A[x]=y+z*pw3;\n      }\n    }\n    pw3*=3;\n  }\n  rep(i,pw3)OUT(A[i]),putchar(' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb emplace_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\n#define dupli(a) a.erase(unique(all(a)),a.end())\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst int INF=1001001001;\nconst int mod=1000000007;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\nll sw(ll i){\n    if(i==0)return 0;\n    return 3-i;\n}\nint main(){\n    ll l;cin>>l;\n    string s;cin>>s;\n    ll n=s.size();\n    vi v(n);\n    rep(i,n)if(s[i]=='R')v[i]++;\n    vvi dp0(n+1,vi(3)),dp1(n+1,vi(3));\n    vvi d(3);\n    rep(i,3){\n        dp0[0][i]=i;\n        dp1[0][i]=i;\n    }\n    rep(i,n)rep(j,3){\n        if(!v[i]){\n            dp0[i+1][j]=sw(dp0[i][j]);\n            dp1[i+1][j]=sw(dp1[i][j]);\n        }\n        else{\n            if(dp0[i][j]<2)dp0[i+1][j]=dp0[i][j]+1;\n            else{\n                dp0[i+1][j]=0;\n                d[j].pb(i+1);\n            }\n            dp1[i+1][j]=dp1[i][j];\n        }\n    }\n    //outvv(dp0);cout<<endl;outvv(dp1);\n    vi ans(modpow(3,l));\n    rep(x,modpow(3,l)){\n        vi t(l);\n        ll k=x;\n        rep(i,l){\n            t[i]=k%3;\n            k/=3;\n        }\n        vi p;\n        rep(i,l){\n            vi np;\n            //if(x==0)outv(p);\n            if(i==0){\n                for(auto y:d[t[i]]){\n                    np.pb(y);\n                }\n                ans[x]+=dp0[n][t[i]];\n            }\n            else{\n                for(auto y:p){\n                    ll nk=dp1[y][t[i]]+1;\n                    if(dp1[y][t[i]]==2){\n                        nk=0;np.pb(y);\n                    }\n                    //if(x==0)out(nk);\n                    rep(j,3)if(dp1[y][j]==nk){\n                        t[i]=j;\n                        break;\n                    }\n                    //if(x==0)out(t[i]);\n                }\n                ans[x]+=modpow(3,i)*dp1[n][t[i]];\n            }\n            p=np;\n        }\n    }\n    outv(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\n#include <cmath>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\n#define LL long long\n\nconst int dx[4] = {1, -1, 0, 0};\nconst int dy[4] = {0, 0, 1, -1};\n\nLL mod(LL x, LL md) {\n\treturn ((x % md) + md) % md;\n}\n\nclass Mint {\npublic:\n\tstatic LL md;\n\tLL x;\n\tMint(LL _x = 0) {\n\t\tx = mod(_x, md);\n\t}\n\tMint(const Mint &y) {\n\t\tx = mod(y.x, md);\n\t}\n};\n\nvoid MintMyExgcd(LL a, LL b, LL &x, LL &y) {\n\t// solve equation ax + by = 1 (mod m)\n\tLL md = Mint::md;\n\tif (b == 0) {\n\t\ty = 0;\n\t\tx = 1;\n\t\treturn ;\n\t}\n\tMintMyExgcd(b, a % b, x, y);\n\tLL t = y;\n\ty = mod(x - (a / b) * y, md);\n\tx = t;\n}\n\nLL MintNY(LL x) {\n\tif (x == 0) {\n\t\treturn 1;\n\t}\n\tLL md = Mint::md;\n\tLL a, b;\n\tMintMyExgcd(x, md, a, b);\n\twhile (a < 0) {\n\t\ta += md;\n\t}\n\treturn a;\n}\n\n/* LL gcd(LL a, LL b) {\n\tif (b == 0) {\n\t\treturn a;\n\t}\n\treturn gcd(b, a % b);\n} */\n\nMint operator+(Mint a, Mint b) {\n\treturn Mint(mod(a.x + b.x, Mint::md));\n}\nMint operator-(Mint a, Mint b) {\n\treturn Mint(mod(a.x - b.x, Mint::md));\n}\nMint operator*(Mint a, Mint b) {\n\treturn Mint(mod(a.x * b.x, Mint::md));\n}\nMint operator/(Mint a, Mint b) {\n\tMint c = Mint(MintNY(b.x));\n\treturn Mint(mod(a.x * c.x, Mint::md));\n}\n\nMint operator-(Mint a) {\n\treturn Mint(-a.x);\n}\nbool operator==(Mint a, Mint b) {\n\treturn a.x == b.x;\n}\nbool operator!=(Mint a, Mint b) {\n\treturn a.x != b.x;\n}\nbool operator>(Mint a, Mint b) {\n\treturn a.x > b.x;\n}\nbool operator<(Mint a, Mint b) {\n\treturn a.x < b.x;\n}\nbool operator>=(Mint a, Mint b) {\n\treturn a.x >= b.x;\n}\nbool operator<=(Mint a, Mint b) {\n\treturn a.x <= b.x;\n}\n\nvoid operator+=(Mint &a, Mint b) {\n\ta = a + b;\n}\nvoid operator-=(Mint &a, Mint b) {\n\ta = a - b;\n}\nvoid operator*=(Mint &a, Mint b) {\n\ta = a * b;\n}\nvoid operator/=(Mint &a, Mint b) {\n\ta = a / b;\n}\n\nostream& operator<<(ostream &out, Mint a) {\n\tout << a.x;\n\treturn out;\n}\n\nistream& operator>>(istream &in, Mint &a) {\n\tin >> a.x;\n\treturn in;\n}\n\nMint factorial(LL n) {\n\tif (n == 0) {\n\t\treturn Mint(1);\n\t}\n\tMint res = 1;\n\tfor (LL i = 1; i <= n; ++i) {\n\t\tres *= i;\n\t}\n\treturn res;\n}\nMint multiRange(LL s, LL t) {\n\tMint res = 1;\n\tfor (LL i = s; i <= t; ++i) {\n\t\tres *= i;\n\t}\n\treturn res;\n}\n\nMint getC(LL n, LL k) {\n\tif (n - k < k) {\n\t\treturn getC(n, n - k);\n\t}\n\treturn multiRange(n - k + 1, n) / factorial(k);\n}\n\nMint getA(LL n, LL k) {\n\treturn multiRange(n - k + 1, n);\n}\n\nMint countNonNegativeDivision(LL n, LL k) {\n\treturn getC(n + k - 1, k - 1);\n}\nMint countPositiveDivision(LL n, LL k) {\n\tif (n < k) {\n\t\treturn 0;\n\t}\n\tif (k <= 0) {\n\t\treturn 0;\n\t}\n\treturn getC(n - 1, k - 1);\n}\nMint quickMod(Mint a, LL b) {\n\tMint res = 1;\n\twhile (b > 0) {\n\t\tif (b % 2) {\n\t\t\tres *= a;\n\t\t}\n\t\ta *= a;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nint md3 = 1;\nint n;\n\nvector<int> toBase3(int x) {\n\tvector<int> res;\n\twhile (x) {\n\t\tres.push_back(x % 3);\n\t\tx /= 3;\n\t}\n\treturn res;\n}\nint fromBase3(vector<int> &x) {\n\tint res = 0;\n\tint base = 1;\n\tfor (int i = 0; i < x.size(); ++i) {\n\t\tres += base * x[i];\n\t\tbase *= 3;\n\t}\n\treturn res;\n}\n\nint flipS(int x) {\n\tvector<int> b3 = toBase3(x);\n\tfor (int i = 0; i < b3.size(); ++i) {\n\t\tb3[i] = (3 - b3[i]) % 3;\n\t}\n\treturn fromBase3(b3);\n}\nint flipR(int x) {\n\treturn (x + 1) % md3;\n}\n\nLL Mint::md = 1000000007;\n\nvector<int> makeInit() {\n\tvector<int> a(md3);\n\tfor (int i = 0; i < md3; ++i) {\n\t\ta[i] = i;\n\t}\n\treturn a;\n}\n\nvoid singleFlipS(int &x) {\n\tx = (3 - x) % 3;\n}\nvoid singleFlipR(int &x) {\n\tx = (x + 1) % 3;\n}\n\nvoid vectorFlipS(vector<int> &a) {\n\tfor (int i = 0; i < a.size(); ++i) {\n\t\ta[i] = flipS(a[i]);\n\t}\n}\nvoid vectorFlipR(vector<int> &a) {\n\tfor (int i = 0; i < a.size(); ++i) {\n\t\ta[i] = flipR(a[i]);\n\t}\n}\nvoid vectorSingleFlipS(vector<int> &a) {\n\tfor (int i = 0; i < a.size(); ++i) {\n\t\tsingleFlipS(a[i]);\n\t}\n}\nvoid vectorSingleFlipR(vector<int> &a) {\n\tfor (int i = 0; i < a.size(); ++i) {\n\t\tsingleFlipR(a[i]);\n\t}\n}\n\nvoid printVector(vector<int> &a) {\n\tfor (int i = 0; i < a.size(); ++i) {\n\t\tcout << a[i] << ' ';\n\t}\n\tcout << endl;\n}\n\nvector<vector<int> > p, w;\nstring T;\nint t;\n\nvoid init() {\n\tp = vector<vector<int> >(n + 1);\n\tw = vector<vector<int> >(n + 1);\n\tint base = 1;\n\tfor (int i = 0; i <= n; ++i) {\n\t\tw[i] = vector<int>(t + 1);\n\t\tp[i] = vector<int>(base);\n\t\tbase *= 3;\n\t}\n\n\tp[1][0] = 0; p[1][1] = 1; p[1][2] = 2;\n\tw[1][0] = 2;\n\tfor (int i = 0; i < t; ++i) {\n\t\tif (T[i] == 'S') {\n\t\t\tvectorSingleFlipS(p[1]);\n\t\t} else {\n\t\t\tvectorSingleFlipR(p[1]);\n\t\t}\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tif (p[1][j] == 2) {\n\t\t\t\tw[1][i + 1] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector<int> upt;\nvector<int> sSum;\n\nvoid relax(int order, int idx, int nowTime) {\n\tint sTime = sSum[nowTime] - sSum[upt[idx]];\n\tif (sTime % 2) {\n\t\tp[order][idx] = (3 - p[order][idx]) % 3;\n\t}\n\tupt[idx] = nowTime;\n}\n\nvoid work() {\n\tsSum = vector<int>(t + 1);\n\tsSum[0] = 0;\n\tfor (int i = 1; i <= t; ++i) {\n\t\tsSum[i] = sSum[i - 1] + ((T[i - 1] == 'S') ? 1 : 0);\n\t}\n\tint base = 3;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tupt = vector<int>(p[i].size(), 0);\n\t\t// get p[i][j = 1 .. 3^i], w[i][1 .. T]\n\t\t// if we have already gotten p[i][j = 1 .. 3^i]\n\n\t\tfor (int j = 0; j < p[i].size(); ++j) {\n\t\t\tp[i][j] = j / base;\n\t\t}\n\t\tw[i][0] = 2;\n\n\t\tfor (int j = 0; j < t; ++j) {\n\t\t\tif (T[j] == 'R') {\n\t\t\t\tfor (int ii = 0; ii < 3; ++ii) {\n\t\t\t\t\tint idx = ii * base + w[i - 1][j];\n\t\t\t\t\trelax(i, idx, j);\n\t\t\t\t\tp[i][idx] = (p[i][idx] + 1) % 3;\n\t\t\t\t\tupt[idx] += 1;\n\t\t\t\t}\n\t\t\t\tfor (int ii = 0; ii < 3; ++ii) {\n\t\t\t\t\tint idx = ii * base + w[i - 1][j + 1];\n\t\t\t\t\trelax(i, idx, j);\n\t\t\t\t\tif (p[i][idx] == 2) {\n\t\t\t\t\t\tw[i][j + 1] = ii;\n\t\t\t\t\t\tbreak;\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// for (int ii = 0; ii < p[i].size(); ++ii) {\n\t\t\t\t// \tp[i][ii] = (3 - p[i][ii]) % 3;\n\t\t\t\t// }\n\t\t\t\tfor (int ii = 0; ii < 3; ++ii) {\n\t\t\t\t\tint idx = ii * base + w[i - 1][j + 1];\n\t\t\t\t\trelax(i, idx, j); \n\t\t\t\t\tp[i][idx] = (3 - p[i][idx]) % 3;\n\t\t\t\t\tupt[idx] += 1;\n\t\t\t\t\tif (p[i][idx] == 2) {\n\t\t\t\t\t\tw[i][j + 1] = ii;\t\n\t\t\t\t\t\tbreak;\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = 0; j <= t; ++j) {\n\t\t\tw[i][j] = w[i][j] * base + w[i - 1][j];\n\t\t}\n\t\tfor (int j = 0; j < p[i].size(); ++j) {\n\t\t\trelax(i, j, t);\n\t\t\tp[i][j] = p[i][j] * base + p[i - 1][j % base];\n\t\t}\n\t\tbase *= 3;\n\n\t\t// cout << \"w: \";\n\t\t// for (int j = 0; j <= t; ++j) {\n\t\t// \tcout << w[i][j] << ' ';\n\t\t// }\n\t\t// cout << endl;\n\t\t\n\t\t// cout << \"p: \";\n\t\t// for (int j = 0; j < p[i].size(); ++j) {\n\t\t// \tcout << p[i][j] << ' ';\n\t\t// }\n\t\t// cout << endl;\n\t}\n\tfor (int i = 0; i < p[n].size(); ++i) {\n\t\tprintf(\"%d \", p[n][i]);\n\t}\n\tputchar('\\n');\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tcin >> T;\n\t// cout << T << endl;\n\tt = T.length();\n\tmd3 = 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tmd3 *= 3;\n\t}\n\n\tinit();\n\twork();\n\n\t// vector<int> a1 = makeInit();\n\t// vector<int> a2 = makeInit();\n\t// vectorFlipS(a1); vectorFlipR(a1);\n\t// vectorFlipR(a2); vectorFlipS(a2);\n\n\t// printVector(a1);\n\t// printVector(a2);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <stdio.h>\n#include <cmath>\n#include<bits/stdc++.h>\nusing namespace std;\n\nint len;\nint n;\nstring dance;\nvector <int> locations;\n\n\nvoid salsa();\n\nvoid rumba();\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n;\n    cin>>dance;\n    len = pow(3, n);\n\n    locations = vector<int>(len);\n    for (int i = 0; i < len; i++) {\n        locations[i] = i;\n    }\n    for (int i = 0; i < dance.length(); i++) {\n        if(dance[i] == 'S'){\n            salsa();\n        }else{\n            rumba();\n        }\n    }\n    for(int i = 0; i< len; i++){\n        printf(\"%d \", locations[i]);\n    }\n}\nchar reVal(int num)\n{\n    if (num >= 0 && num <= 9)\n        return (char)(num + '0');\n    else\n        return (char)(num - 10 + 'A');\n}\n\n// Utility function to reverse a string\nvoid strev(char *str)\n{\n    int len = strlen(str);\n    int i;\n    for (i = 0; i < len/2; i++)\n    {\n        char temp = str[i];\n        str[i] = str[len-i-1];\n        str[len-i-1] = temp;\n    }\n}\nchar* fromDeci(char res[], int base, int inputNum)\n{\n    int index = 0;  // Initialize index of result\n\n    // Convert input number is given base by repeatedly\n    // dividing it by base and taking remainder\n    while (inputNum > 0)\n    {\n        res[index++] = reVal(inputNum % base);\n        inputNum /= base;\n    }\n    res[index] = '\\0';\n\n    // Reverse the result\n    strev(res);\n\n    return res;\n}\nint val(char c)\n{\n    if (c >= '0' && c <= '9')\n        return (int)c - '0';\n    else\n        return (int)c - 'A' + 10;\n}\n\n// Function to convert a number from given base 'b'\n// to decimal\nint toDeci(char *str, int base)\n{\n    int len = strlen(str);\n    int power = 1; // Initialize power of base\n    int num = 0;  // Initialize result\n    int i;\n\n    // Decimal equivalent is str[len-1]*1 +\n    // str[len-2]*base + str[len-3]*(base^2) + ...\n    for (i = len - 1; i >= 0; i--)\n    {\n        // A digit in input number must be\n        // less than number's base\n        if (val(str[i]) >= base)\n        {\n            printf(\"Invalid Number\");\n            return -1;\n        }\n\n        num += val(str[i]) * power;\n        power = power * base;\n    }\n\n    return num;\n}\n\nvoid rumba() {\n    for(int j = 0; j< len; j++ ){\n        int num = locations[j];\n        int new_num = num +1;\n        if(new_num == len){\n            new_num = 0;\n        }\n        locations[j] = new_num;\n    }\n}\n\nvoid salsa() {\n    for(int j = 0; j< len; j++ ){\n        int num = locations[j];\n        char res[len];\n        char* a = fromDeci(res, 3, num);\n        int k = 0;\n        while(a[k] != '\\0'){\n            if((a[k]) == '1'){\n                a[k] = '2';\n            }else if(a[k] == '2'){\n                a[k] = '1';\n            }\n            k++;\n        }\n        int new_num = toDeci(a, 3);\n        locations[j] = new_num;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nstatic inline char CH()\n{\n  static char buf[100000],*ptr1=buf,*ptr2=buf;\n  return ptr1==ptr2&&(ptr2=(ptr1=buf)+fread(buf,1,100000,stdin),ptr1==ptr2)?EOF:*ptr1++;\n}\nstatic inline int IN(void)\n{\n  int x=0,f=0,c=CH();while(c<48||c>57){f^=c==45,c=CH();}\n  while(c>47&&c<58){x=x*10+c-48,c=CH();}return f?-x:x;\n}\nstatic inline void OUT(int x){if(x>=10)OUT(x/10);printf(\"%d\",x%10);}\nstatic inline int Pow(int a,int b){return b?Pow(a*a,b>>1)*(b&1?a:1):1;}\nint main()\n{\n  int N=IN(),now,len=0,pw3=Pow(3,N),x=Pow(3,N>>1),y=Pow(3,N-(N>>1)),A[531441],B[531441];\n  char c=CH(),T[200001],S[200000];\n  rep(i,pw3)B[i]=B[i/3]*3+(3-i%3)%3;\n  while(c!=EOF){if(c=='\\t'||c==' '||c=='\\n'){c=CH();}T[len++]=c,c=CH();}\n  fflush(stdin);\n  rep(i,x)\n  {\n    int temp=i;now=0;\n    rep(j,len)\n    {\n      if(T[j]=='S'){temp=B[temp];if(S[now]=='S')--now;else S[++now]='S';}\n      else{++temp;if(temp==x)S[++now]='R',temp=0;}\n    }\n    rep(j,y)\n    {\n      int keep=j;\n      rep(k,now)\n      {\n        if(S[k+1]=='S')keep=B[keep];\n        else if(S[k+1]=='R')if((++keep)==y)keep=0;\n      }\n      A[i+j*x]=temp+keep*x;\n    }\n  }\n  rep(i,pw3)OUT(A[i]),putchar(' ');\n  return fflush(stdout),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include<limits.h>\n#include<utility>\n#include<vector>\n#include<tuple>\n#include <map>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define ALL(A) A.begin(),A.end()\n\n\nint main() {\n\tint n;\n\tstring t;\n\tcin >> n >> t;\n\tint N = 1;\n\tint a3[13];\n\ta3[0] = 1;\n\trep(i, n) {\n\t\ta3[i + 1] = a3[i]*3;\n\t}\n\tN = a3[n];\n\tvector<int> S(N);\n\tvector<int> person(N);\n\trep(i, N) {\n\t\tperson[i] = i;\n\t\tif (i == 0) {\n\t\t\tS[i] = i;\n\t\t\tcontinue;\n\t\t}\n\t\tint a=0;\n\t\tint m = 0;\n\t\tint I = i;\n\t\twhile (I != 0) {\n\t\t\tint am = I % 3;\n\t\t\tif (am == 1) {\n\t\t\t\tam = 2;\n\t\t\t}\n\t\t\telse if (am == 2) {\n\t\t\t\tam = 1;\n\t\t\t}\n\t\t\ta += am * a3[m];\n\t\t\tI /= 3;\n\t\t\tm++;\n\t\t}\n\t\tS[i] = a;\n\t\t\n\t}\n\tint s = 0;\n\tint r = 0;\n\tint o[N];\n\tfor (int i = 0; i < t.size(); i++) {\n\t\tif (t[i] == 'S') {\n\t\t\trep(j, N) {\n\t\t\t\tperson[j]+=r;\n\t\t\t\tperson[j] %= N;\n\t\t\t\t//person[j] = S[person[j]];\n\t\t\t}\n\t\t\ts++;\n\t\t\tr = 0;\n\t\t}\n\t\tif (t[i] == 'R') {\n\t\t\tr++;\n\t\t\tif (s % 2 == 1) {\n\t\t\t\tperson[j] = S[person[j]];\n\t\t\t}\n\t\t\ts = 0;\n\t\t}\n\t\t\n\t}\n\trep(i, N) {\n\t\tif (t[t.size() - 1] == 'R') {\n\t\t\tperson[i] = (person[i] + r) % N;\n\t\t\tcout << person[i]<<\" \";\n\t\t}\n\t\telse {\n\t\t\tcout << person[i]<<\" \";\n\t\t}\n\t\t\n\t}\n\tcout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint m,tr[3][1100005],tg[1100005],pw3[13],a[1100005],cnt=0,n,ans[1100005];\nchar s[200005];\nvoid build(int p,int f,int num)\n{\n\t//printf(\"@%d %d %d %d\\n\",p,f,num,n);\n\tif(f==n)\n\t{\n\t\t//printf(\"#%d %d\\n\",p,num);\n\t\ta[p]=num;\n\t\treturn;\n\t}\n\ttr[0][p]=++cnt;\n\ttr[1][p]=++cnt;\n\ttr[2][p]=++cnt;\n\tbuild(tr[0][p],f+1,num);\n\tbuild(tr[1][p],f+1,num+pw3[f]);\n\tbuild(tr[2][p],f+1,num+2*pw3[f]);\n}\nvoid push(int p)\n{\n\tswap(tr[1][p],tr[2][p]);\n\ttg[p]=0;\n\ttg[tr[1][p]]^=1;tg[tr[2][p]]^=1;tg[tr[0][p]]^=1;\n}\nvoid opt(int p,int f)\n{\n\tif(f==n)return;\n\tif(tg[p])push(p);\n\tswap(tr[1][p],tr[2][p]);\n\tswap(tr[0][p],tr[1][p]);\n\topt(tr[0][p],f+1);\n}\nvoid dfs(int p,int f,int num)\n{\n\tif(f==n)\n\t{\n\t\tans[a[p]]=num;\n\t\treturn;\n\t}\n\tif(tg[p])push(p);\n\tdfs(tr[0][p],f+1,num);\n\tdfs(tr[1][p],f+1,num+pw3[f]);\n\tdfs(tr[2][p],f+1,num+2*pw3[f]);\n}\nint main()\n{\n\tpw3[0]=1;\n\tfor(int i=1;i<=12;i++)pw3[i]=pw3[i-1]*3;\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\tm=strlen(s+1);cnt=1;\n\tbuild(1,0,0);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(s[i]=='S')tg[1]^=1;\n\t\telse opt(1,0);\n\t}\n\tdfs(1,0,0);\n\tfor(int i=0;i<pw3[n];i++)printf(\"%d \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=1001000;\nint n,pw[20],pos[N];\nchar s[N];\nstruct node {\n\tnode *s[3];\n\tint lab;\n\tbool rev;\n\tvoid setr() {\n\t\trev^=1;\n\t\tswap(s[1],s[2]);\n\t}\n\tvoid push() {\n\t\tif (rev) { rep(j,0,3) if (s[j]) s[j]->setr(); rev=0; }\n\t}\n}pool[N],*cur=pool,*rt;\n\nint main() {\n\tscanf(\"%d\",&n);\n\tpw[0]=1;\n\tfor (int i=1;i<=n;i++) pw[i]=pw[i-1]*3;\n\trt=cur++;\n\trep(i,0,pw[n]) {\n\t\tnode *p=rt;\n\t\trep(j,0,n) {\n\t\t\tint w=i/pw[j]%3;\n\t\t\tif (!p->s[w]) p->s[w]=cur++;\n\t\t\tp=p->s[w];\n\t\t}\n\t\tp->lab=i;\n\t}\n\tscanf(\"%s\",s);\n\tint m=strlen(s);\n\trep(i,0,m) if (s[i]=='S') {\n\t\trt->setr();\n\t} else {\n\t\tnode *p=rt;\n\t\trep(j,0,n) {\n\t\t\tp->push();\n\t\t\tnode *t=p->s[2]; p->s[2]=p->s[1]; p->s[1]=p->s[0]; p->s[0]=t;\n\t\t\tp=p->s[0];\n\t\t}\n\t}\n\trep(i,0,pw[n]) {\n\t\tnode *p=rt;\n\t\trep(j,0,n) {\n\t\t\tint w=i/pw[j]%3;\n\t\t\tp->push(); p=p->s[w];\n\t\t}\n\t\t//printf(\"zz %d\\n\",p-cur);\n\t\tpos[p->lab]=i;\n\t\t//printf(\"%d \",p->lab);\n\t}\n\trep(i,0,pw[n]) printf(\"%d%c\",pos[i],\" \\n\"[i==pw[n]-1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\nusing namespace std;\n\nint n, len, l[3*3*3*3*3*3*3*3*3*3*3*3];\nstring t;\n\nint calc(int a) {\n\tif (a < 3) {\n\t\treturn a % 3 - 1 + (a + 1) % 3;\n\t}\n\telse {\n\t\treturn a % 3 - 1 + (a + 1) % 3 + 3 * calc(a / 3);\n\t}\n}\n\nint main()\n{\n\tcin >> n;\n\tcin >> t;\n\tn = pow(3, n);\n\tfor (int i = 0; i < n; i++) {\n\t\tl[i] = i;\n\t}\n\tfor (int i = 0; i < t.size(); i++) {\n\t\tif (t[i] == 'S') {\n\t\t\tif (t[i + 1] == 'S') {\n\t\t\t\tt[i] = '0';\n\t\t\t\tt[i + 1] = '0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < t.size(); i++) {\n\t\tif (t[i] == 'S') {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tl[j] = calc(l[j]);\n\t\t\t}\n\t\t}\n\t\telse if(t[i] == 'R'){\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tl[j] = (l[j] + 1) % n;\n\t\t\t}\n\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << l[i] << \" \";\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma comment(linker, \"/STACK:16000000\")\nusing namespace std;\n\nconst int Maxn = 14;\nconst int Maxm = 200005;\n\nint pw[Maxn];\nint n;\nint T;\nchar str[Maxm];\nint sum[Maxm];\nint res[5000005];\n\nvoid Solve(int b, const vector <int> &cur, const vector <int> &quer)\n{\n    if (b >= n || cur.empty()) return;\n    vector <int> C[3], Q[3];\n    int my[3] = {0, 1, 2};\n    int lst = 0;\n    for (int i = 0; i < quer.size(); i++) {\n        if (sum[quer[i]] % 2 != sum[lst] % 2) swap(my[1], my[2]);\n        Q[my[2]].push_back(quer[i]);\n        int tmp = my[2]; my[2] = my[1]; my[1] = my[0]; my[0] = tmp;\n        lst = quer[i];\n    }\n    if (sum[T] % 2 != sum[lst] % 2) swap(my[1], my[2]);\n    int inv[3];\n    for (int i = 0; i < 3; i++)\n        inv[my[i]] = i;\n    for (int i = 0; i < cur.size(); i++) {\n        int val = cur[i] / pw[b] % 3;\n        C[val].push_back(cur[i]);\n        res[cur[i]] += pw[b] * inv[val];\n    }\n    for (int i = 0; i < 3; i++)\n        Solve(b + 1, C[i], Q[i]);\n}\n\nint main()\n{\n    pw[0] = 1;\n    for (int i = 1; i < Maxn; i++)\n        pw[i] = pw[i - 1] * 3;\n    scanf(\"%d\", &n);\n    scanf(\"%s\", str + 1);\n    T = strlen(str + 1);\n    vector <int> quer;\n    for (int i = 1; i <= T; i++) {\n        if (str[i] == 'R') str[i] = 'S';\n        else str[i] = 'R';\n        sum[i] = sum[i - 1] + (str[i] == 'R');\n        if (str[i] == 'S') quer.push_back(i);\n    }\n    vector <int> cur;\n    for (int i = 0; i < pw[n]; i++)\n        cur.push_back(i);\n    Solve(0, cur, quer);\n    for (int i = 0; i < pw[n]; i++)\n        printf(\"%d%c\", res[i], i + 1 < pw[n]? ' ': '\\n');\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "        #include <bits/stdc++.h>\n        using namespace std;\n   #define int long long\nconst int MAX = 510000;\nconst int MOD = 1000000007;\n\n     signed main(){\n int n;\n string t;\n cin>>n>>t;\n int al2[t.size()]={};\n set<int> x[3];int y[3];\n int k=3;\n int kk=1;for(int i=0;i<n;i++)kk*=3;\n int ans[kk]={};\nint z[kk];\n for(int i=0;i<n;i++){\n      for(int j=0;j<k;j++)z[j]=j/(k/3);\n      \n   y[0]=0;y[1]=1;y[2]=2;\n   for(int j=0;j<t.size();j++){\n        if(t[j]=='S'){swap(y[1],y[2]);continue;}\n        int h[3];\n      for(int q=0;q<3;q++) h[y[z[al2[j]+q*k/3]]]=al2[j]+q*k/3;\n      for(int q=0;q<3;q++)z[h[q]]=y[(q+1)%3];\n       \n        al2[j]=h[2];\n   }\n\n   for(int j=0;j<kk;j++){\n       ans[j]+=y[z[j%k]]*k/3;\n   }\n   k*=3;\n\n }\n for(int i=0;i<kk;i++)cout<<ans[i]<<' ';\n\n\n\n\n\n\n    }\n\n\n\n\n\n      \n\n        \n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//#pragma GCC target (\"avx2\")\n//#pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 729 + 10;\nint p[13];\nchar s[200000+10];\nint a[N][N],b[N],r[N],ans[N*N];\nint main(){\n    p[0] = 1; for(int i=1;i<13;i++) p[i] = p[i-1] * 3;\n    int n; scanf(\"%d%s\",&n,s);\n    int x = n / 2, y = n - x;\n    ///y: low, x: high\n    for(int i=0;i<p[6];i++){\n        int t = i;\n        for(int j=0;j<6;j++){\n            if(t/p[j]%3==1) t += p[j];\n            else if(t/p[j]%3==2) t -= p[j];\n        }\n        r[i] = t;\n    }\n    for(int i=0;i<p[n];i++){\n        a[i%p[y]][i/p[y]] = i;\n    }\n    int R = 0;\n    for(int i=0;s[i];i++){\n        if(s[i]=='S'){\n            R ^= 1;\n            for(int j=0;j<p[y];j++) if(j<r[j]){\n                swap(a[j],a[r[j]]);\n                swap(b[j],b[r[j]]);\n            }\n        }\n        else{\n            for(int j=p[y]-1;j>0;j--){\n                swap(a[j],a[j-1]);\n                swap(b[j],b[j-1]);\n            }\n            if(b[0]^R){\n                for(int j=0;j<p[x];j++) if(j<r[j]) swap(a[0][j],a[0][r[j]]);\n                b[0] ^= 1;\n            }\n            for(int j=p[x]-1;j>0;j--){\n                swap(a[0][j],a[0][j-1]);\n            }\n        }\n    }\n    for(int i=0;i<p[y];i++) if(b[i]^R){\n        for(int j=0;j<p[x];j++) if(j<r[j]) swap(a[i][j],a[i][r[j]]);\n        b[i] ^= 1;\n    }\n    for(int i=0;i<p[n];i++) ans[a[i%p[y]][i/p[y]]] = i;\n    for(int i=0;i<p[n];i++) printf(\"%d%c\",ans[i],\" \\n\"[i==p[n]-1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    vector<int> d23(531441);\n    vector<int> rumba(531441);\n\n    int N;\n    cin >> N;\n    N = (int)pow(3,N);\n    \n    int temp,add,now;\n    for(int i = 0 ; i < 531441 ; i++){\n        temp = i;\n        add = 0;\n        now = 1;\n        while(temp != 0){\n            int a = temp % 3;\n            if(a == 1){\n                add += 2 * now;\n            }else if(a == 2){\n                add += now;\n            }\n            now *= 3;\n            temp /= 3;\n        }\n        d23.at(i) = add;\n    }\n\n    for(int i = 0 ; i < 531440 ; i++){\n        rumba.at(i) = i + 1;\n    }\n    rumba.at(N - 1) = 0;\n\n\n\n    vector<int> hito1(531441);\n\n    for(int i = 0 ; i < 531441 ; i++){\n        hito1.at(i) = i;\n    }\n\n\n    string T;\n    cin >> T;\n\n    int tSize = T.size();\n\n    for(int i = 0 ; i < tSize ; i++){\n        if(T.at(i) == 'S'){\n            for(int j = 0 ; j < N ; j++){\n                hito1.at(j) = d23.at(hito1.at(j));\n            }\n        }else{\n            for(int j = 0 ; j < N ; j++){\n                hito1.at(j) = rumba.at(hito1.at(j));\n            }\n        }\n    }\n\n\n    \n    for(int i = 0 ; i < N - 1 ; i++){\n        cout << hito1.at(i) << ' ';\n    }\n    cout << hito1.at(N - 1) << endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+7;\nint n,m,f[N],g[N],ans[N]; char s[N],t[N];\ninline void write(int u){\n\tif(u>9) write(u/10); putchar(u%10+'0');\n}\nint main(){\n\tcin>>n; int a=1,b=1;\n\tfor(int i=1;i<=n/2;i++) a=a*3;\n\tfor(int i=n/2+1;i<=n;i++) b=b*3;\n\tfor(int i=0;i<a*b;i++){\n\t\tf[i]=f[i/3]*3,g[i]=(g[i]+1)%(a*b);\n\t\tif(i%3==1) f[i]+=2; else if(i%3==2) f[i]++;\n\t}\n\tscanf(\"%s\",s+1),m=strlen(s+1);\n\tfor(int i=0;i<a;i++){\n\t\tint u=i; int len=0;\n\t\tfor(int z=1;z<=m;z++)\n\t\t\tif(s[z]=='S'){\n\t\t\t\tu=f[u];\n\t\t\t\tif(t[len]=='S') len--; else t[++len]='S';\n\t\t\t}\n\t\t\telse if(s[z]=='R'){\n\t\t\t\tif(u+1==a) t[++len]='R',u=0;\n\t\t\t\telse u++;\n\t\t\t}\n\t\tint v=u;\n\t\tfor(int x=0;x<b;x++){\n\t\t\tint u=x;\n\t\t\tfor(int z=1;z<=len;z++)\n\t\t\tif(t[z]=='S') u=f[u];\n\t\t\telse if(t[z]=='R'){\n\t\t\t\tif(u+1==b) u=0;\n\t\t\t\telse u++;\n\t\t\t}\n\t\t\tans[i+x*a]=u*a+v;\n\t\t}\n\t}\n\tfor(int i=0;i<a*b;i++) write(ans[i]),putchar(' ');\n}\n//ac"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,x,y,sw,pw3=1,A[555555]={0},B[555555]={0},S[555555]={0};\nchar T[200001];\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nsigned main(void)\n{\n  x=scanf(\"%d %s\",&N,T);\n  replace(T,\"SS\",\"\");\n  if(T[0]=='\\n')return 0;\n  rep(i,N)\n  {\n    sw=1;\n    rep(j,pw3)rep(k,3)B[j+k*pw3]=k;\n    rep(p,strlen(T))\n    {\n      if(T[p]=='R')\n      {\n        y=S[p];\n        rep(j,3){x=y+j*pw3;if(B[x]*sw==-1||B[x]*sw==2)S[p]=x;(B[x]+=(sw>0?1:2))%=3;}\n      }\n      else sw=-sw;\n    }\n    rep(j,pw3){y=A[j];rep(k,3){x=j+k*pw3;A[x]=y+((sw<0)?3-B[x]:B[x])%3*pw3;}}\n    pw3*=3;\n  }\n  rep(i,pw3)printf(\"%d%c\",A[i],i+1==pw3?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint main(){\n  int N;\n  string T;\n  cin >> N >> T;\n  int pow3N = pow(3, N);\n  vector<int> A(pow3N);\n  iota(A.begin(), A.end(), 0);\n  map<char, vector<int>> next;\n  next['S'] = vector<int>(pow3N);\n  next['R'] = vector<int>(pow3N);\n\n  for(int ii=0; ii<pow3N; ii++){\n    int tmp=ii;\n    int jj=0;\n    int aa=1;\n    while(tmp){\n      int kk = tmp % 3;\n      tmp = (tmp - kk) / 3;\n      if(kk==1){\n        kk=2;\n      }else if(kk==2){\n        kk=1;\n      }\n      jj+=kk*aa;\n      aa*=3;\n    }\n    next['S'][ii] = jj;\n    next['R'][ii] = ii+1;\n  }\n  next['R'][pow3N-1] = 0;\n\n  vector<int> B(pow3N);\n  for(auto& c : T){\n    for(int ii=0; ii<pow3N; ii++){\n      B[next[c][ii]] = A[ii];\n    }\n    swap(A, B);\n  }\n  for(int ii=0; ii<pow3N; ii++){\n    B[A[ii]] = ii;\n  }\n  for(auto& b : B){\n    cout << b << \" \";\n  }\n  cout << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define st first\n#define nd second\n\nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n\nconst int kMaxSize = 1e6;\n\nint n;\nint answer[kMaxSize];\nint pwr3;\nint cur_digs[kMaxSize];\nint ans_digs[kMaxSize];\n\nstring Reduce(string T) {\n\tstring ans;\n\tfor (char ch : T) {\n\t\tif (ch == 'R') {\n\t\t\tans += ch;\n\t\t} else if (!ans.empty() && ans.back() == 'S') {\n\t\t\tans.pop_back();\n\t\t} else {\n\t\t\tans += ch;\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid PutAns() {\n\tint from = 0, to = 0;\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tfrom = from * 3 + cur_digs[i];\n\t\tto = to * 3 + ans_digs[i];\n\t}\n\tanswer[from] = to;\n}\n\nvoid Solve(int digit, string T) {\n\tif (digit == n) {\n\t\treturn PutAns();\n\t}\n\n\tfor (int d : {0, 1, 2}) {\n\t\tint cur_d = d;\n\t\tstring next_t;\n\t\tfor (char ch : T) {\n\t\t\tif (ch == 'S') {\n\t\t\t\tnext_t += ch;\n\t\t\t\tif (cur_d) { cur_d = 3 - cur_d; }\n\t\t\t} else {\n\t\t\t\t++cur_d;\n\t\t\t\tif (cur_d == 3) {\n\t\t\t\t\tnext_t += ch;\n\t\t\t\t\tcur_d = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcur_digs[digit] = d;\n\t\tans_digs[digit] = cur_d;\n\t\tSolve(digit + 1, Reduce(next_t));\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(11);\n\tcerr << fixed << setprecision(6);\n\n\tstring T;\n\tcin >> n >> T;\n\tT = Reduce(T);\n\n\tpwr3 = 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tpwr3 *= 3;\n\t}\n\n\tSolve(0, T);\n\tfor (int i = 0; i < pwr3; ++i) {\n\t\tcout << answer[i] << \" \";\n\t}\n\tcout << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i, x, y) for(int i = x, _b = y; i <= _b; i ++)\n#define ff(i, x, y) for(int i = x, _b = y; i <  _b; i ++)\n#define fd(i, x, y) for(int i = x, _b = y; i >= _b; i --)\n#define ll long long\n#define pp printf\n#define hh pp(\"\\n\")\nusing namespace std;\n\nconst int N = 2e5 + 5;\n\nint a3[13];\n\nint n, m;\nchar s[N];\n\nconst int M = 531441;\nstruct nod {\n\tint p[M], w[N];\n} a[2]; int o;\n\nint t[3], nt[3];\nint c[3][M];\nint p[M];\n\nint main() {\n\ta3[0] = 1; fo(i, 1, 12) a3[i] = a3[i - 1] * 3;\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", s + 1); m = strlen(s + 1);\n\tfo(i, 1, n) {\n\t\tfo(j, 0, 2)\tt[j] = j;\n\t\tfo(j, 0, 2) ff(k, 0, a3[i - 1]) c[j][k] = j;\n\t\ta[!o].w[0] = a3[i] - 1;\n\t\tfo(j, 1, m) {\n\t\t\tchar ch = s[j];\n\t\t\tif(ch == 'S') {\n\t\t\t\tswap(t[1], t[2]);\n\t\t\t} else {\n\t\t\t\tint lc[3];\n\t\t\t\tfo(k, 0, 2) lc[k] = c[t[k]][a[o].w[j - 1]];\n\t\t\t\tfo(k, 0, 2) c[t[k]][a[o].w[j - 1]] = lc[(k + 2) % 3];\n\t\t\t}\n\t\t\ta[!o].w[j] = a[o].w[j] + a3[i - 1] * c[t[2]][a[o].w[j]];\n\t\t}\n\t\tfo(j, 0, 2) ff(k, 0, a3[i - 1]) {\n\t\t\ta[!o].p[c[t[j]][k] * a3[i - 1] + k] = j * a3[i - 1] + a[o].p[k];\n\t\t}\n\t\to = !o;\n\t}\n\tff(j, 0, a3[n]) pp(\"%d \", a[o].p[j]); hh;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define mod 1000000007\n#define int long long\n#define big 998244353\n#define ff first\n#define se second\n#define pb push_back\n#define pii pair<int,int>\n#define fast ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define PSET(x,y) fixed<<setprecision(y)<<x\n#define mp make_pair\n#define pi 3.141592653589\nint power(int x,int y){\n    int r=1,z=x;\n    while(y){\n        if(y & 1)r*=z;\n        z*=z;y=y>>1;}\n    return r;}\nint powerm(int x,int y,int p){\n    int r=1;\n    while(y){\n        if(y & 1)r=(r*x)%p;\n        y=y>>1;\n        x=(x*x)%p;}\n    return r%p;}\nint modinv(int x,int m){\n    return powerm(x,m-2,m);}\nint logarithm(int a,int b){\n    int x=0;\n    while(a>1){\n        x++;\n        a/=b;}\n    return x;}\nint32_t main(){\n    fast;\n    int n;\n    cin>>n;\n    n=power(3,n);\n    int a[n];\n    memset(a,0,sizeof(a));\n    for(int i=0;i<n;i++){\n        int k=0,copy=i;\n        while(copy){\n            a[i]+=power(3,k)*((copy%3==2)?1:(copy%3==1)?2:0);\n            k++;\n            copy/=3;\n        }\n    }\n    int b[n];\n    for(int i=0;i<n;i++)\n        b[i]=i;\n    string t;\n    cin>>t;\n    for(int i=0;i<t.size();i++){\n        if(t[i]=='S'){\n            for(int j=0;j<n;j++)\n                b[j]=a[b[j]];\n        }\n        else\n            for(int j=0;j<n;j++)\n                b[j]=(b[j]+1)%n;\n    }\n    for(int i=0;i<n;i++)\n        cout<<b[i]<<\" \";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string>\n#include<cmath>\n\nusing namespace std;\n\nint sch(int n){     \n    int out=0,tmp,count=0;\n    while(n != 0){\n        tmp = n % 3;\n        if(tmp==1){\n            out += 2*pow(3,count);\n        }else if(tmp==2){\n            out += pow(3,count);\n        }\n        count++;\n        n /= 3;\n    }\n    return out;\n}\n\nint main(){\n    int N,p,size,len;\n    string T;\n    vector<int> table(N,0);\n    cin >> N;\n    cin >> T;\n    size = int(pow(3,N));\n    len = T.length();\n    for(int i=0;i<size;i++){\n        if(i % 3 == 0){\n            table[i] = sch(i);\n        }else if(i % 3 == 1){\n            table[i] = table[i-1] + 2;\n        }else{\n            table[i] = table[i-1] - 1;\n        }\n    }\n    //for(int i=0;i<size;i++) cout << i << ' ' <<table[i] << endl;;\n\n    for(int i=0;i<size;i++){\n        p=i;\n        for(int j=0;j<len;j++){\n            if(T[j] == 'S'){\n                if(T[j+1] == 'S') j++;\n                else p = table[p];\n            }else{\n                p++;\n                if(p==size) p=0;\n            }\n        }\n        cout << p << ' ';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint N;\nstring T;\n\nvoid R(int *data);\nvoid S(int *data);\nint X(int x, int y);\n\nint main(){\n  int n;\n  string s;\n  cin >> n;\n  cin >> T;\n  N = X(3, n);\n  \n  cout << N <<endl;\n  int L[N];\n  for(int i=0;i<N;i++){\n    L[i] = i;\n  }\n  \n  for(int i=0;i<(int)(T.length());i++){\n    s = T[i];\n    if(s == \"S\"){\n      S(L);\n    }else{\n      R(L);\n    }\n  }\n\n\n  for(int i=0;i<N;i++){\n    cout << L[i] << \" \";\n  }\n  \n  \n  cout <<endl;\n  return 0;\n}\n\nvoid R(int *data){\n  int tmp = data[N-1];\n  for(int i=0;i<N;i++){\n    int a = data[i];\n    data[i] = tmp;\n    tmp = a;\n  }\n}\nvoid S(int *data){\n  int K[N];\n  \n  for(int i=0;i<N/3;i++){\n    int k = i;\n    int tmp = 0;\n    int m = 3;\n    int q = i*3;\n    \n    while(k>0){\n      if(k%3==1){\n        tmp = tmp +2*m;\n      }else if(k%3==2){\n        tmp = tmp +1*m;\n      }\n      k = k/3;\n      m = m*3;\n    }\n    K[tmp] = data[q];\n    K[tmp + 1] = data[q+2];\n    K[tmp + 2] = data[q+1];\n  }\n  for(int i=0;i<N;i++)\n  data[i] = K[i];\n}\n\n\nint X(int x,int y){\n  int a = 1;\n  for(int i=0;i<y;i++){\n    a = a*x;\n  }\n  return a;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define reps(i, n) for (int i = 1; i <= (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), end(x))\n#define bit(n) (1LL << (n))\n#define cdiv(a, b) (((a) - 1) / (b) + 1)\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr int DX[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\nint my_pow(int a, int n) {\n    if (n == 0) { return 1; }\n    int x = my_pow(a, n / 2);\n    int ret = x * x;\n    if (n & 1) { ret *= a; }\n    return ret;\n}\nstring compress(string t) {\n    string ret = \"\";\n    ret.push_back(t[0]);\n    for (int i = 1; i < t.length(); i++) {\n        if (ret.back() == 'S' && t[i] == 'S') { ret.pop_back(); }\n        else { ret.push_back(t[i]); }\n    }\n    return ret;\n}\nint N;\nstring T;\nint ans[550000];\nvoid dfs(int n, int in, int out, string t) {\n    if (n == N) {\n        ans[in] = out;\n        return;\n    }\n    t = compress(t);\n    int c0 = 0, c1 = 1, c2 = 2;\n    string v0 = \"\", v1 = \"\", v2 = \"\";\n    rep(i, t.size()) {\n        if (t[i] == 'S') {\n            c0 = (3 - c0) % 3, c1 = (3 - c1) % 3, c2 = (3 - c2) % 3;\n            v0.push_back('S'), v1.push_back('S'), v2.push_back('S');\n        } else {\n            (c0 += 1) %= 3, (c1 += 1) %= 3, (c2 += 1) %= 3;\n            if (c0 == 0) { v0.push_back('R'); }\n            if (c1 == 0) { v1.push_back('R'); }\n            if (c2 == 0) { v2.push_back('R'); }\n\n        }\n    }\n    int p = my_pow(3, n);\n    dfs(n + 1, in + 0 * p, out + c0 * p, v0);\n    dfs(n + 1, in + 1 * p, out + c1 * p, v1);\n    dfs(n + 1, in + 2 * p, out + c2 * p, v2);\n}\n\nsigned main() {\n    cin >> N >> T;\n    dfs(0, 0, 0, T);\n    int p = my_pow(3, N);\n    rep(i, p) { cout << ans[i] << \" \"; }\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconstexpr int N=2e5+1;\nint n;\nchar t[N];\n\nsigned main() {\n\n      SPEED;\n      scanf(\"%d%s\", &n, t);\n      int m = strlen(t);\n\n      // initialize vector size\n      vector<vector<vector<int>>> v(3, vector<vector<int>>(n));\n      int k = 1;\n      rep(i, n) {\n        rep(j, 3) {\n          v[j][i].resize(k);\n        }\n        k *= 3;\n      }\n      int K = k;\n\n      // initialize vector\n      rep(i, n) {\n        int idx = 0;\n        rep(j, 3) {\n          for(auto& e: v[j][i]) {\n            e = idx;\n            idx++;\n          }\n        }\n      }\n\n      rep(j, m) {\n        if (t[j]=='S') {\n          // swap vector\n          swap(v[1], v[2]);\n        } else {\n          // swap by point\n          int w = 0;\n          rep(i, n) {\n            auto v0 = v[0][i][w];\n            auto v1 = v[1][i][w];\n            auto v2 = v[2][i][w];\n            v[1][i][w] = v0;\n            v[2][i][w] = v1;\n            v[0][i][w] = v2;\n            w = v2;\n          }\n        }\n      }\n\n      // recover\n      vector<int> ans(K);\n      k = 1;\n      rep(i, n) {\n        for(int j=1; j<=2; j++) {\n          for(auto e: v[j][i]) {\n            for(int idx=e; idx<K; idx+=(k*3)) {\n              ans[idx] += j*k;\n            }\n          }\n        }\n        k *= 3;\n      }\n\n      for(auto e: ans) {\n        printf(\"%d \", e);\n      }\n      return 0;\n    }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 10 + 1e6;\nconst ll oo = 1 + 1e18;\nconst ll mod = 7 + 1e9;\n\nint n, Next[MAXN], p3[13];\nstring s;\n\nint delta (int val)\n{\n    int mul = 12, cnt = 0, res = 0;\n    while (p3[mul] > val) mul--;\n\n  //  cerr << \"mul:\" << ' ' << mul << '\\n';\n\n    while (val > 0)\n    {\n       val -= p3[mul];\n       cnt++;\n\n    //   cerr << \"val,cnt,mul:\" << ' ' << val << ' ' << cnt << ' ' << mul << '\\n';\n\n       if (val < p3[mul])\n       {\n           if (cnt == 1)\n           {\n               res += p3[mul];\n           }\n\n           else res -= p3[mul];\n\n           while (val < p3[mul]) mul--;\n           cnt = 0;\n       }\n    }\n\n    return res;\n}\n\nvoid init()\n{\n    Next[0] = 0;\n    for (int i = 1; i < p3[n]; i++)\n    {\n        Next[i] = (i + delta(i)) % p3[n];\n    }\n}\n\nint main()\n{\n    #define TASK \"ABC\"\n    #ifndef ONLINE_JUDGE\n    freopen(TASK\".inp\",\"r\",stdin);\n    freopen(TASK\".out\",\"w\",stdout);\n    #endif ONLINE_JUDGE\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    p3[0] = 1;\n    for (int i = 1; i <= 12; i++)\n    {\n        p3[i] = p3[i - 1] * 3;\n    }\n\n    cin >> n >> s;\n    s = ' ' + s;\n    init();\n\n   // cerr << delta (1);\n\n    for (int pos = 0; pos < p3[n]; pos++)\n    {\n        int cur = pos;\n        for (int i = 1; i <= s.size() - 1; i++)\n        {\n            if (s[i] == 'R') cur++;\n            else cur = Next[cur];\n\n            cur %= p3[n];\n\n          //  cerr << s[i] << ' ' << cur << '\\n';\n        }\n\n     //   cerr << '\\n';\n\n        cout << cur << ' ';\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define db long double\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n\nusing namespace std;\n\nconst int FIVE = 243, SEVEN = 2187;\nconst int N = 200007;\n\nint go[SEVEN][2];\n\nint recon(vector<int> v) {\n\tint a = 0, deg = 1;\n\tfor (int i = 0; i < 7; ++i) {\n\t\ta += deg*v[i];\n\t\tdeg *= 3;\n\t}\n\treturn a;\n}\n\nint go1(vector<int> a) {\n\n\ta[0]++;\n\tfor (int i = 0; i < 7; ++i) {\n\t\tif (a[i]==3) {\n\t\t\ta[i] = 0;\n\t\t\tif (i < 6) a[i+1]++;\n\t\t}\n\t\t//cout << a[i] << \" \";\n\t}\n\n\n\treturn recon(a);\n\n}\n\nint go2(vector<int> a) {\n\n\tfor (int i = 0; i < 7; ++i) {\n\t\tif (a[i]==1 || a[i]==2) {\n\t\t\ta[i] = 3-a[i];\n\t\t}\n\t}\n\n\treturn recon(a);\n\n}\n\nint closest_zero[N];\nint go_zero[N];\n\nint cur_closest_zero[SEVEN];\nint go_finish[SEVEN];\n\nint spec[SEVEN];\n\nstring s;\nvector<int> pref;\n\nint get(int was, int l, int r) {\n\tint cnt = pref[r+1] - pref[l];\n\tif (cnt % 2 == 0) return was;\n\n\twas = go[was][1];\n\twas %= FIVE;\n\treturn was;\n\n}\n\nint main(){\n#ifdef LOCAL\n\tfreopen(\"C_input.txt\", \"r\", stdin);\n\t//freopen(\"C_output.txt\", \"w\", stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tcin >> s;\n\n\tpref.push_back(0);\n\tfor (int i = 0; i < s.size(); ++i) {\n\t\tpref.push_back(pref.back() + (s[i] == 'S'));\n\t}\n\n\tfor (int i = 0; i < SEVEN; ++i) {\n\n\t\tvector<int> w;\n\t\tint Q = i;\n\t\tfor (int j = 0; j < 7; ++j) {\n\t\t\tw.push_back(Q%3);\n\t\t\tQ /= 3;\n\t\t}\n\n\t\tint a = go1(w);\n\t\tint b = go2(w);\n\n\t\t//if (i==2) exit(0);\n\n\t\tgo[i][0] = a, go[i][1] = b;\n\n\t}\n\n\tfor (int i = 0; i < SEVEN; ++i) {\n\t\tgo_finish[i] = i;\n\t\tcur_closest_zero[i] = 1;\n\t}\n\n\tfor (int i = s.size() - 1; i >= 0; i--) {\n\t\tint code;\n\t\tif (s[i] == 'S') code = 1;\n\t\telse code = 0;\n\n\t\tfor (int j = 0; j < SEVEN; ++j) {\n\t\t\tint be = go[j][code];\n\t\t\tif (be == 0 && s[i] == 'R') {\n\t\t\t\tspec[j] = 1;\n\t\t\t}\n\t\t\telse spec[j] = cur_closest_zero[j]+1;\n\t\t}\n\n\t\tfor (int j = 0; j < SEVEN; ++j) cur_closest_zero[j] = spec[j];\n\n\t\tfor (int j = 0; j < SEVEN; ++j) {\n\t\t\tint be = go[j][code];\n\t\t\tspec[j] = go_finish[be];\n\t\t}\n\n\t\tfor (int j = 0; j < SEVEN; ++j) go_finish[j] = spec[j];\n\t\tclosest_zero[i] = cur_closest_zero[0];\n\t\tgo_zero[i] = go_finish[0];\n\n\t\t//cout << go_finish[0] << \" \" << go_finish[1] << \" \" << go_finish[2] << endl;\n\n\t}\n\n\tint kek = 1;\n\tfor (int i = 0; i < 12; ++i) kek *= 3;\n\n\tvector<int> ans(kek);\n\n\tfor (int i = 0; i < kek; ++i) {\n\n\t\tint sht = i%SEVEN, lng = i/SEVEN;\n\t\tint left = s.size();\n\n\n\t\tint C = cur_closest_zero[sht];\n\t\tif (C > left) {\n\t\t\tsht = go_finish[sht];\n\t\t\tleft = 0;\n\t\t\tlng = get(lng, 0, s.size()-1);\n\t\t}\n\n\t\telse {\n\t\t\tsht = 0;\n\t\t\tleft -= C;\n\t\t\tlng = get(lng, 0, s.size()-1);\n\t\t\tlng = (go[lng][0]) % FIVE;\n\t\t}\n\n\t\twhile (left) {\n\t\t\tint have = closest_zero[s.size() - left];\n\t\t\tif (have > left) {\n\t\t\t\tsht = go_zero[s.size() - left];\n\t\t\t\tleft = 0;\n\t\t\t\tlng = get(lng, 0, s.size()-1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsht = 0;\n\t\t\t\tleft -= have;\n\t\t\t\tlng = get(lng, 0, s.size()-1);\n\t\t\t\tlng = (go[lng][0]) % FIVE;\n\t\t\t}\n\t\t}\n\n\t\tans[i] = sht + SEVEN*lng;\n\t}\n\n\tint Q = 1;\n\tfor (int i = 0; i < n; ++i) Q *= 3;\n\n\tfor (int i = 0; i < Q; ++i) {\n\t\tcout << ans[i] % Q << \" \";\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp> // Common file\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\ntypedef tree<\nll,\nnull_type,\nless<ll>,\nrb_tree_tag,\ntree_order_statistics_node_update>\nordered_set;\n// ordered_set X;\n// *X.find_by_order(i) = ith largest element (counting from zero)\n// X.order_of_key(k) = number of items in X < k (strict lt)\n\nint R(int n, int M) {\n    return (n+1) % M;\n}\n\nint S(int n, int N) {\n    int tmp = 0;\n    for (int i=0;i<N;i++) {\n        tmp *= 3;\n        tmp += (3 - (n%3)) % 3;\n\n        n/=3;\n    }\n\n    int ans = 0;\n    for (int i=0;i<N;i++) {\n        ans *= 3;\n        ans += (tmp % 3);\n\n        tmp /=3;\n    }\n\n    return ans;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int N;\n    cin >> N;\n    string T;\n    cin >> T;\n\n    int M = 1;\n    for (int i=0;i<N;i++) M*=3;\n\n    vi row(M, 0);\n    vvi perms(N, row);\n    \n    int tp = 1;\n    for (int i=0;i<N;i++) {\n        for (int j=0;j<3*tp;j++) {\n            perms[i][j] = j/tp;\n        }\n        tp *= 3;\n\n        // cout << i << \": \";\n        // for (int j=0;j<tp;j++) {\n        //     cout << perms[i][j] << \" \";    \n        // }\n        // cout << endl;\n    }\n\n    bool swap = false;\n    int L = T.length();\n    for (int i=0;i<L;i++) {\n        if (T[i] == 'R') {\n            int tp = 1;\n            int overflow = 0;\n            int nxtof = 0;\n            for (int j=0;j<N;j++) {\n                for (int k=0;k<3;k++) {\n                    int cur = (overflow + k*tp) % (3*tp);\n                    if (!swap) {\n                        perms[j][cur] = (perms[j][cur] + 1) % 3;\n                    } else {\n                        perms[j][cur] = (perms[j][cur] + 2) % 3;\n                    }\n                    \n                    if (perms[j][cur] == 0) nxtof = cur;\n                }\n\n                overflow = nxtof;\n                tp *= 3;\n            }\n        } else if (T[i] == 'S') {\n            if (swap) swap = false;\n            else swap = true;\n        }\n    }\n\n    // cout << \"done\" << endl;\n\n    // tp = 1;\n    // for (int i=0;i<N;i++) {\n    //     tp *= 3;\n\n    //     cout << i << \": \";\n    //     for (int j=0;j<tp;j++) {\n    //         cout << perms[i][j] << \" \";    \n    //     }\n    //     cout << endl;\n    // }\n\n    vi salsa{0, 2, 1};\n\n    for (int i=0;i<M;i++) {\n        int tp = 1;\n        int cur = 0;\n        for (int j=0;j<N;j++) {\n            if (!swap) cur += perms[j][i % (3*tp)]*tp;\n            else cur += salsa[perms[j][i % (3*tp)]]*tp;\n            tp *= 3;\n        }\n        cout << cur << \" \\n\"[i+1==M];\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\nint main() {\n  int n;\n  cin >> n;\n  string t;\n  cin >> t;\n  int num = 1;\n  for (int i = 0; i < n; ++i)\n    num *= 3;\n  vector<int> comp(num);\n  for (int i = 1; i < num; ++i) {\n    vector<int> v;\n    int m = i;\n    while (m > 0) {\n      v.emplace_back(m % 3);\n      m /= 3;\n    }\n    for (int &vi : v)\n      if (vi > 0)\n        vi = 3 - vi;\n    int c = 0;\n    for (auto it = v.rbegin(); it != v.rend(); ++it)\n      c = c * 3 + *it;\n    comp[i] = c;\n  }\n  vector<pair<char, int>> seq;\n  char curr = 'X';\n  int cnt = 0;\n  t += \"!\";\n  for (char c : t) {\n    if (c != curr) {\n      if (curr == 'S')\n        cnt %= 2;\n      if (cnt > 0) {\n        if (!seq.empty() && seq.back().first == curr) {\n          cnt += seq.back().second;\n          seq.pop_back();\n        }\n        seq.emplace_back(curr, cnt);\n      }\n      curr = c;\n      cnt = 1;\n    } else\n      cnt++;\n  }\n  vector<int> ans(num);\n  for (int i = 0; i < num; ++i) {\n    int pos = i;\n    for (auto p : seq) {\n      if (p.first == 'S')\n        pos = comp[pos];\n      else\n        pos = (pos + p.second) % num;\n    }\n    ans[i] = pos;\n  }\n  for (int i : ans)\n    cout << i << \" \";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\ntemplate<class T,class U> inline bool chmin(T&x,U y){if(x>y){x=y;return true;}return false;}\ntemplate<class T,class U> inline bool chmax(T&x,U y){if(x<y){x=y;return true;}return false;}\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define Fr(i,n) for(int i=1;i<=(n);++i)\n#define ifr(i,n) for(int i=(n)-1;i>=0;--i)\n#define iFr(i,n) for(int i=(n);i>0;--i)\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n,p3[13]={1};\n    fr(i,12) p3[i+1]=p3[i]*3;\n    string t;\n    cin>>n>>t;\n    int m=t.length();\n    vector<int> a(m),v={0,1,2};\n    fr(i,m){\n        if(t[i]=='S'){\n            swap(v[1],v[2]);\n        }\n        else{\n            a[i]=v[2];\n            v[2]=v[1];\n            v[1]=v[0];\n            v[0]=a[i];\n        }\n    }\n    vector<int> ans(3);\n    fr(i,3) ans[v[i]]=i;\n    //for(auto&K:a) cout<<K<<\" \";cout<<endl;\n    Fr(l,n-1){\n        vector<int> nv={0,1,2};\n        auto e=vector(p3[l],array<int,3>());\n        for(auto&A:e) A[0]=0,A[1]=1,A[2]=2;\n        fr(i,m){\n            //cout<<i<<endl;\n            if(t[i]=='S'){\n                swap(nv[1],nv[2]);\n            }\n            else{\n                int T=a[i];\n                auto&A=e[T];\n                array<int,3> iv={},AA={},tmp={};\n                fr(I,3) iv[nv[I]]=I;\n                fr(I,3) AA[iv[A[I]]]=I;\n                /*cout<<\"iv:\";for(auto&K:iv) cout<<K<<\"!\";cout<<endl;\n                cout<<\"AA:\";for(auto&K:AA) cout<<K<<\"!\";cout<<endl;\n                cout<<\"iA:\";for(auto&K:A) cout<<iv[K]<<\"!\";cout<<endl;*/\n                tmp[AA[2]]=0;tmp[AA[0]]=1;tmp[AA[1]]=2;\n                fr(I,3) A[I]=nv[tmp[I]];\n                /*cout<<\"A :\";for(auto&K:A) cout<<K<<\"!\";cout<<endl;\n                cout<<\"tm:\";for(auto&K:tmp) cout<<K<<\"!\";cout<<endl;*/\n                a[i]+=AA[2]*p3[l];\n            }\n        }\n        vector<int> nans(p3[l+1]);\n        array<int,3> iv={};\n        fr(I,3) iv[nv[I]]=I;\n        fr(i,p3[l]){\n            nans[i]=iv[e[i][0]]*p3[l]+ans[i];\n            nans[i+p3[l]]=iv[e[i][1]]*p3[l]+ans[i];\n            nans[i+2*p3[l]]=iv[e[i][2]]*p3[l]+ans[i];\n        }\n        ans.swap(nans);\n        //for(auto&K:a) cout<<K<<\" \";cout<<endl;\n    }\n    for(auto&i:ans) cout<<i<<\" \";\n    cout<<'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for (int i = x; i < (int)(n); ++i)\n\nint const N = 12, M = 200000, K = 531441;\nint n, p3[N + 1], an[K];\nchar s[M + 1];\n\nstruct S{\n\tint x;\n\tbool fl;\n\tS* g[3];\n\tS():fl(false) { f(i, 0, 3)g[i] = 0; }\n}*R;\n\nvoid pl(S* &v = R, int m = 0, int x = 0){\n\tv = new S();\n\tif (m == n){\n\t\tv->x = x;\n\t\treturn;\n\t}\n\tpl(v->g[0], m + 1, x);\n\tpl(v->g[1], m + 1, x + p3[m]);\n\tpl(v->g[2], m + 1, x + 2 * p3[m]);\n}\n\nvoid flp(S* v = R){\n\tswap(v->g[1], v->g[2]);\n\tv->fl ^= 1;\n}\n\nvoid sl(S* v){\n\tif (!v->fl)return;\n\tv->fl = false;\n\tflp(v->g[0]);\n\tflp(v->g[1]);\n\tflp(v->g[2]);\n}\n\nvoid ad(S* v = R){\n\tif (!v->g[0])return;\n\tsl(v);\n\tS* t = v->g[2];\n\tv->g[2] = v->g[1];\n\tv->g[1] = v->g[0];\n\tv->g[0] = t;\n\tad(t);\n}\n\nvoid fn(S* v = R, int m = 0, int x = 0){\n\tif (m == n){\n\t\tan[v->x] = x;\n\t\treturn;\n\t}\n\tfn(v->g[0], m + 1, x);\n\tfn(v->g[1], m + 1, x + p3[m]);\n\tfn(v->g[2], m + 1, x + 2 * p3[m]);\n}\n\nint main(){\n\tscanf(\"%d%s\", &n, s);\n\tp3[0] = 1;\n\tf(i, 1, n + 1)p3[i] = p3[i - 1] * 3;\n\tpl();\n\t\n\tint m = strlen(s);\n\tf(i, 0, m)if (s[i] == 'S')flp();\n\telse ad();\n\t\n\tfn();\n\tprintf(\"%d\", an[0]);\n\tf(i, 1, p3[n])printf(\" %d\", an[i]);\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#define int long long\n\n#define pii pair<int, int>\n\n#define x1 x1228\n#define y1 y1228\n\n#define left left228\n#define right right228\n\n#define next next228\n\n#define pb push_back\n#define eb emplace_back\n\n#define mp make_pair                                                                \n                                                                                                                                        \n#define ff first                                                                  \n#define ss second   \n\n#define all(x) x.begin(), x.end()\n#define debug(x) cout << #x << \": \" << x << endl; \n#define TIME (ld)clock()/CLOCKS_PER_SEC\n\nusing namespace std;\ntypedef long long ll; \ntypedef long double ld; \n                                                                                                   \nconst int maxn = 2e5 + 7, mod = 1e9 + 7, MAXN = 1e6 + 7;\nconst double eps = 1e-9;\nconst ll inf = 1e18;\nmt19937 rnd(time(0));\nint n; \nstring s; \nint next[MAXN];\nconst int N = 2187; \nint dp1[N]; \nint dp2[N]; \nint xyz[N]; \n\nint get1(int mask, char q) {\n    if (q == 'R') {\n        ++mask; \n        return mask; \n    }   \n    int ptr = 1; \n    int ans = 0; \n    while (mask) {\n        int t = mask % 3; \n        mask /= 3; \n        if (t == 2) ans += ptr; \n        if (t == 1) ans += 2 * ptr; \n        ptr *= 3; \n    }\n    return ans; \n}\n\nint get(int mask, char q) {\n    if (q == 'R') {\n        ++mask; \n        return mask; \n    }   \n    return xyz[mask]; \n}\n\nconst int L = 12; \nint pref[maxn]; \nint to[maxn]; \nint kek1[N], kek2[N]; \nint res[N]; \n\nint get(int l, int r) {\n    return pref[r + 1] - pref[l]; \n}\n\nvoid change(int &mask, int l, int r) {\n    if (get(l, r) % 2) {\n        mask = get(mask, 'S'); \n    }    \n    mask++; \n}\n\nint merge(int left, int right) {\n    for (int i = 0; i < 7; ++i) right *= 3;\n    return left + right;     \n}\n\nint get(int x) {\n    vector<int> bts; \n    for (int i = 0; i < L; ++i) {\n        bts.pb(x % 3); \n        x /= 3; \n    }\n    int left = 0;\n    int right = 0; \n    for (int i = 6; i >= 0; --i) {\n        left *= 3;\n        left += bts[i]; \n    }\n    for (int i = L - 1; i >= 7; --i) {\n        right *= 3; \n        right += bts[i]; \n    }\n    int id = 0; \n    if (left && dp1[left] == -1) {\n        return merge(res[left], right);  \n    }\n    if (left) {    \n        id = dp1[left]; \n        change(right, 0, id - 1);             \n        left = 0; \n    }                     \n    while (next[id] != -1) {\n        change(right, id, next[id] - 1);\n        id = next[id];                                                                                                                                         \n    }\n    left = to[id]; \n    return merge(left, right); \n}\n\n\nvoid solve() {\n    for (int i = 0; i < N; ++i) {\n        xyz[i] = get1(i, 'S') % N; \n    }\n\n    cin >> n >> s; \n    int t = s.size(); \n    for (int i = 0; i < N; ++i) {        \n        res[i] = i; \n        for (int j = 0; j < t; ++j) {\n            if (s[j] == 'S') res[i] = xyz[res[i]]; \n            else res[i] = xyz[res[i]] % N; \n        } \n    }\n    for (int i = 0; i < t; ++i) {\n        pref[i + 1] = pref[i] + (s[i] == 'S'); \n    }\n    for (int i = 0; i < N; ++i) dp1[i] = dp2[i] = -1; \n    next[t] = -1;\n    for (int i = 0; i < N; ++i) kek1[i] = i;              \n    for (int i = t - 1; i >= 0; --i) {\n        for (int mask = 0; mask < N; ++mask) {\n            int mask1; \n            if (s[i] == 'S') mask1 = xyz[mask]; \n            else mask1 = mask + 1; \n            mask1 %= N; \n            kek2[mask] = kek1[mask1];\n        }\n        to[i] = kek2[0]; \n        for (int mask = 0; mask < N; ++mask) {\n            int mask1; \n            if (s[i] == 'S') mask1 = xyz[mask]; \n            else mask1 = mask + 1; \n            mask1 %= N;              \n            if (mask && mask1 == 0) {\n                dp2[mask] = i + 1; \n            } else {\n                dp2[mask] = dp1[mask1]; \n            }   \n        }\n        next[i] = dp2[0]; \n        for (int mask = 0; mask < N; ++mask) {\n            kek1[mask] = kek2[mask]; \n            dp1[mask] = dp2[mask]; \n            dp2[mask] = -1; \n        }\n    }\n    int tet = 1; \n    for (int i = 0; i < n; ++i) tet *= 3; \n    for (int i = 0; i < tet; ++i) {\n        cout << get(i) % tet << \" \"; \n    }\n}                                \n   \nsigned main() {\n#ifdef LOCAL\n    freopen(\"TASK.in\", \"r\", stdin);\n    freopen(\"TASK.out\", \"w\", stdout);\n#else \n    \n#endif // LOCAL\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20); \n    cout << fixed; \n    int t = 1; \n    for (int i = 0; i < t; ++i) {              \n        solve();\n    }\n    return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid read(int &x) {\n    x=0;int f=1;char ch=getchar();\n    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-f;\n    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';x*=f;\n}\n\nvoid print(int x) {\n    if(x<0) putchar('-'),x=-x;\n    if(!x) return ;print(x/10),putchar(x%10+48);\n}\nvoid write(int x) {if(!x) putchar('0');else print(x);putchar('\\n');}\n\n#define lf double\n#define ll long long \n\n#define pii pair<int,int >\n#define vec vector<int >\n\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\n#define data asd09123jdf02i3h\n\n#define FOR(i,l,r) for(int i=l,i##_r=r;i<=i##_r;i++)\n\nconst int maxn = 1e6+10;\nconst int inf = 1e9;\nconst lf eps = 1e-8;\nconst int mod = 1e9+7;\n\nint n,tr[maxn][3],tag[maxn],N,cnt=1,id[maxn],tot,r[maxn];\nchar s[maxn];\n\nvoid ins(int v) {\n    int x=1,p=v;\n    for(int i=1;i<=n;i++) {\n        int t=v%3;v/=3;\n        if(!tr[x][t]) tr[x][t]=++cnt;\n        x=tr[x][t];\n    }id[x]=p;\n}\n\nvoid push(int x) {tag[x]^=1,swap(tr[x][1],tr[x][2]);}\n\nvoid pushdown(int x) {\n    if(tag[x]) {\n        for(int i=0;i<3;i++) push(tr[x][i]);\n        tag[x]=0;\n    }\n}\n\nvoid dfs(int x) {\n    if(!tr[x][0]) return ;\n    pushdown(x);\n    swap(tr[x][0],tr[x][1]),swap(tr[x][0],tr[x][2]);\n    dfs(tr[x][0]);\n}\n\nvoid get(int x,int v,int t) {\n    if(!tr[x][0]) {\n        r[id[x]]=v;\n        return ;\n    }\n    pushdown(x);\n    for(int i=0;i<3;i++) get(tr[x][i],v+t*i,t*3);\n}\n\nint main() {\n    read(n);N=pow(3,n);\n    for(int i=0;i<N;i++) ins(i);\n    scanf(\"%s\",s+1);int m=strlen(s+1);\n    for(int i=1;i<=m;i++)\n        if(s[i]=='S') push(1);\n        else dfs(1);\n    get(1,0,1);\n    for(int i=0;i<N;i++) printf(\"%d \",r[i]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 200010;\n\nint b, n, tag[maxn];\nchar str[maxn];\n\nint pw[15];\nint *a[15], tot = 1;\n\nint getbit(int v, int x) {\n\treturn v / pw[x] % 3;\n}\n\nint add(int x, int y) {\n\tint ret = 0;\n\tfor (int i = 0; i < b; i++) {\n\t\tret += (getbit(x, i) + getbit(y, i)) % 3 * pw[i];\n\t}\n\treturn ret;\n}\n\nint cal(int v) {\n\tint ret = v;\n\tfor (int i = 1; i <= b; i++) {\n\t\tint x = getbit(ret, i-1) + a[i][v % pw[i]];\n\t\tx %= 3;\n\t\tret += (x - getbit(ret, i-1)) * pw[i-1];\n\t}\n\treturn ret;\n}\n\nint rev(int v) {\n\tint ret = 0;\n\tfor (int i = 0; i < b; i++) {\n\t\tint x = getbit(v, i);\n\t\tif (x == 2) ret += pw[i];\n\t\tif (x == 1) ret += 2 * pw[i];\n\t}\n\treturn ret;\n}\n\nint main() {\n\tpw[0] = 1;\n\tfor (int i = 1; i < 15; i++) pw[i] = pw[i-1] * 3;\n\tscanf(\"%d\", &b); scanf(\"%s\", str+1);\n\tfor (int i = 0; i <= b; i++) {\n\t\ta[i] = new int[pw[i]];\n\t\tfor (int j = 0; j < pw[i]; j++) {\n\t\t\ta[i][j] = 0;\n\t\t}\n\t}\n\tn = int (strlen(str + 1));\n\tfor (int i = 1; i <= n; i++) tag[i] = tag[i-1] ^ (str[i] == 'S');\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (str[i] != 'R') continue;\n\t\tint w = 0, nw = 0;\n\t\tfor (int x = 0; x < b; x++) {\n\t\t\t// w = mod 3^x 是什么才会对 3^x 位有影响\n\t\t\tfor (int v = 0; v < 3; v++) {\n\t\t\t\tint t = w + pw[x] * v;\n\t\t\t\tint tt = cal(t);\n\t\t\t\tif (tag[i] & 1) {\n\t\t\t\t\ta[x+1][t] += 2;\n\t\t\t\t\tif (getbit(tt, x) == 1) nw = t;\n\t\t\t\t} else {\n\t\t\t\t\ta[x+1][t] += 1;\n\t\t\t\t\tif (getbit(tt, x) == 2) nw = t;\n\t\t\t\t}\n\t\t\t}\n\t\t\tw = nw;\n\t\t}\n\t}\n\tfor (int i = 0; i < pw[b]; i++) {\n\t\tif (tag[n]) printf(\"%d \", rev(cal(i)));\n\t\telse printf(\"%d \", cal(i));\n\t}\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for (int i = (a); i <= int(b); i++)\nusing namespace std;\n\nconst int maxn = 6e5;\nint n, m, tot, val[maxn + 5], ch[maxn + 5][3], cnt, res[maxn + 5];\nbool sal[maxn + 5];\nchar s[maxn + 5];\n\nint dfs(int k, int t, int s) {\n\tint x = ++tot;\n\tif (!k) return val[x] = s, x;\n\tch[x][0] = dfs(k - 1, t * 3, s);\n\tch[x][1] = dfs(k - 1, t * 3, s + t);\n\tch[x][2] = dfs(k - 1, t * 3, s + t * 2);\n\treturn x;\n}\n\nvoid salsa(int x) {\n\tsal[x] ^= 1, swap(ch[x][1], ch[x][2]);\n}\n\nvoid push_down(int x) {\n\tif (sal[x]) {\n\t\trep(i, 0, 2) salsa(ch[x][i]);\n\t\tsal[x] = false;\n\t}\n}\n\nvoid rumba(int x) {\n\tif (!ch[x][0]) return;\n\tpush_down(x);\n\tint t = ch[x][0];\n\tch[x][0] = ch[x][2];\n\tch[x][2] = ch[x][1];\n\tch[x][1] = t;\n\trumba(ch[x][0]);\n}\n\nvoid work(int x, int t, int s) {\n\tif (!ch[x][0]) {\n\t\tres[val[x]] = s, cnt++;\n\t\treturn;\n\t}\n\tpush_down(x);\n\trep(i, 0, 2) work(ch[x][i], t * 3, s + i * t);\n}\n\nint main() {\n\tscanf(\"%d %s\", &n, s + 1);\n\tm = strlen(s + 1);\n\tdfs(n, 1, 0);\n\trep(i, 1, m) {\n\t\tif (s[i] == 'S') salsa(1);\n\t\telse rumba(1);\n\t}\n\twork(1, 1, 0);\n\trep(i, 0, cnt - 1) printf(\"%d%c\", res[i], \" \\n\"[i == cnt - 1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n  * @brief atcoder\n  * @author yao\n  */\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <climits>\n#define ft first\n#define sd second\n#ifdef DBG\n#   define dbg_pri(x...) fprintf(stderr,x)\n#else\n#   define dbg_pri(x...) 0\n#   define NDEBUG\n#endif //DBG\n#include <cassert>\n\ntypedef unsigned int uint;\ntypedef long long int lli;\ntypedef unsigned long long int ulli;\n\n#define N 524288\n#define M 16\n\nconst int p3[M] = {1, 3, 9, 27, 81, 243, 729, 2187,\n    6561, 19683, 59049, 177147, 531441, 1594323, 4782969, 14348907};\nconst int op_add[2][3] = {{1,2,0},{2,0,1}};\nconst int conv[2][3] = {{0,1,2},{0,2,1}};\nint a[M][N];\nint dir = 0;\nchar s[N];\nint n,m;\n\nvoid add(int x, int y)\n{\n    if(y==m) return;\n    for(int i=0;i<3;++i)\n    {\n        int pos = x+p3[y]*i;\n        a[y][pos] = op_add[dir][a[y][pos]];\n        if(a[y][pos] == 0)\n            add(pos,y+1);\n    }\n}\n\nint main()\n{\n    scanf(\"%d%s\", &m, s), n = p3[m];\n    for(int i=0;i<m;++i)\n        for(int j=0;j<p3[i+1];++j) a[i][j] = j/p3[i];\n    for(int i=0;s[i];++i)\n    {\n        if(s[i] == 'S') dir^=1;\n        if(s[i] == 'R') add(0,0);\n    }\n    for(int i=0;i<n;++i)\n    {\n        int res = 0;\n        for(int j=0;j<m;++j)\n            res += conv[dir][a[j][i%p3[j+1]]]*p3[j];\n        printf(\"%d%c\", res, i==n-1?'\\n':' ');\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\",3,\"inline\")\n#include<bits/stdc++.h>\nusing namespace std;\n#define fir first\n#define sec second\n#define m_p make_pair\n#define y1 ygftgfgcdtfgxffgx\n#define y2 yfdsesgvtyghftfvv\n#define x1 xvyr6cf6fgcfgf676\n#define x2 xcr6rfc5r66y6r6fr\n#define up_bound upper_bound\n#define low_bound lower_bound\n#define next_per next_permutation\n#define pb push_back\n#define i_to_s to_string\ntypedef priority_queue<int> p_queue;\ntypedef priority_queue<int, vector<int>, greater<int> > min_p_queue;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nint mon[20]={31,28,31,30,31,30,31,31,30,31,30,31};\nll gcd(ll x,ll y){return ((y==0)?x:gcd(y,x%y));}\nint n;\nstring t;\nll pass[600010];\nint a[20];\nll power[20];\nll v[600010];\nvoid init(){\n\tll ans,x,pos;\n\tfor(int i=0;i<50/*600000*/;i++){\n\t\tx=i;ans=pos=0;\n\t\twhile(x){\n\t\t\ta[pos++]=(x%3);\n//\t\t\tcout<<a[pos-1]<<' ';\n\t\t\tx/=3;\n\t\t}\n\t\twhile(pos){\n\t\t\tpos--;\n\t\t\tif(a[pos]==1)ans=ans*3+2;\n\t\t\telse if(a[pos]==2)ans=ans*3+1;\n\t\t\telse ans=ans*3+a[pos];\n\t\t}\n\t\tpass[i]=ans;\n//\t\tcout<<\"    \"<<i<<' '<<ans<<'\\n';\n\t}\n\tpower[0]=1;\n\tfor(int i=1;i<15;i++){\n\t\tpower[i]=power[i-1]*3;\n\t}\n}\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tcin>>n>>t;\n\tinit();\n\tn=power[n];\n\tfor(int i=0;i<n;i++)v[i]=i;\n\tfor(int i=0;i<t.size();){\n//\t\tcout<<\"hi\\n\";\n//\t\tfor(int j=0;j<n;j++)cout<<v[j]<<' ';cout<<'\\n';\n//\t\tfor(int j=0;j<n;j++)u[j]=v[j];\n\t\tif(t[i]=='S'){\n\t\t\tif(t[i+1]=='S'){\n\t\t\t\ti+=2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tv[j]=pass[v[j]];\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(v[j]<n-1)v[j]=v[j]+1;\n\t\t\t\telse v[j]=0;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\tfor(int i=0;i<n;i++)cout<<v[i]<<' ';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,x,y,z,sw,pw3=1,A[531441]={0},B[531441]={0},S[531441]={0};\nchar T[200001];\nvoid OUT(int x){if(x<0)putchar('-'),x=-x;if(x>=10)OUT(x/10);putchar(x%10+48);}\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nsigned main(void)\n{\n  x=scanf(\"%d %s\",&N,T);\n  replace(T,\"SS\",\"\");if(T[0]=='\\n')return 0;\n  rep(i,N)\n  {\n    rep(j,pw3)rep(k,3)B[j+k*pw3]=k;\n    sw=1;\n    rep(p,strlen(T))\n    {\n      if(T[p]=='R')\n      {\n        y=S[p];\n        rep(j,3)\n        {\n          x=y+j*pw3;\n          if(B[x]==1&&sw==-1)S[p]=x;\n          if(B[x]==2&&sw==1)S[p]=x;\n          B[x]++;if(sw<0)B[x]++;\n          B[x]%=3;\n        }\n      }\n      else sw=-sw;\n    }\n    rep(j,pw3)\n    {\n      y=A[j];\n      rep(k,3)\n      {\n        x=j+k*pw3;\n        if(sw>0)z=B[x]%3;else z=(3-B[x])%3;\n        A[x]=y+z*pw3;\n      }\n    }\n    pw3*=3;\n  }\n  rep(i,pw3)OUT(A[i]),putchar(' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 5;\nconst int MAXP = 8e5 + 5;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nstruct Trie {\n\tstruct Node {\n\t\tint child[3], ind;\n\t\tbool tag;\n\t} a[MAXP];\n\tint n, root, size, ans[MAXP];\n\tvoid build(int depth, int &root, int sum, int cur) {\n\t\troot = ++size;\n\t\tif (depth == 0) {\n\t\t\ta[root].ind = sum;\n\t\t\treturn;\n\t\t}\n\t\tbuild(depth - 1, a[root].child[0], sum, cur * 3);\n\t\tbuild(depth - 1, a[root].child[1], sum + cur, cur * 3);\n\t\tbuild(depth - 1, a[root].child[2], sum + cur + cur, cur * 3);\n\t}\n\tvoid init(int x) {\n\t\tbuild(n = x, root, 0, 1);\n\t}\n\tvoid shift() {\n\t\tswap(a[root].child[1], a[root].child[2]);\n\t\ta[root].tag ^= true;\n\t}\n\tvoid pushdown(int root) {\n\t\tif (a[root].tag) {\n\t\t\tfor (int i = 0; i <= 2; i++) {\n\t\t\t\tswap(a[a[root].child[i]].child[1], a[a[root].child[i]].child[2]);\n\t\t\t\ta[a[root].child[i]].tag ^= true;\n\t\t\t}\n\t\t\ta[root].tag = false;\n\t\t}\n\t}\n\tvoid inc(int depth, int root) {\n\t\tint x = a[root].child[0];\n\t\tint y = a[root].child[1];\n\t\tint z = a[root].child[2];\n\t\ta[root].child[0] = z;\n\t\ta[root].child[1] = x;\n\t\ta[root].child[2] = y;\n\t\tif (depth == 0) return;\n\t\tpushdown(root), inc(depth - 1, a[root].child[0]);\n\t}\n\tvoid work(int depth, int root, int sum, int cur) {\n\t\tif (depth == 0) {\n\t\t\tans[a[root].ind] = sum;\n\t\t\treturn;\n\t\t}\n\t\tpushdown(root);\n\t\twork(depth - 1, a[root].child[0], sum, cur * 3);\n\t\twork(depth - 1, a[root].child[1], sum + cur, cur * 3);\n\t\twork(depth - 1, a[root].child[2], sum + cur + cur, cur * 3);\n\t}\n\tvoid getans() {\n\t\twork(n, root, 0, 1); int bit = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tbit = bit * 3;\n\t\tfor (int i = 0; i < bit; i++)\n\t\t\tprintf(\"%d \", ans[i]);\n\t\tprintf(\"\\n\");\n\t}\n} Trie;\nint n, len; char s[MAXN];\nint main() {\n\tread(n), Trie.init(n);\n\tscanf(\"\\n%s\", s + 1);\n\tlen = strlen(s + 1);\n\tfor (int i = 1; i <= len; i++)\n\t\tif (s[i] == 'S') Trie.shift();\n\t\telse Trie.inc(n, Trie.root);\n\tTrie.getans();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,count=0,p,x,TRI,pw3[13]={1},abc[531441][13]={0};\nchar c,tmp,T[200001],del[200001];\nvoid build(void){rep(i,3*TRI){x=i;rep(j,N){abc[i][j]=x%3;x/=3;}}}\nvoid change(char c[])\n{\n  if(c[p]==EOF)return;\n  if(c[p]=='R')\n  {\n    rep(i,3*TRI)abc[i][0]++;\n    rep(i,3*TRI)\n    {\n      rep(j,N){if(abc[i][j]==3){abc[i][j+1]++;abc[i][j]=0;}}\n      if(abc[i][N]==1){rep(j,N+1)abc[i][j]==0;}\n    }\n  }\n  else\n  {\n    rep(i,3*TRI)rep(j,N)\n    {\n      if(abc[i][j]==1)abc[i][j]=2;\n      else if(abc[i][j]==2)abc[i][j]=1;\n      else abc[i][j]=0;\n    }\n  }\n}\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nsigned main(void)\n{\n  count=scanf(\"%d %s\",&N,T);\n  rep(i,N+1)if(i>0)pw3[i]=pw3[i-1]*3;\n  rep(i,pw3[N])del[i]='R';\n  replace(T,\"SS\",\"\");replace(T,del,\"\");\n  if(T[0]=='\\n')return 0;\n  TRI=pw3[N-1];build();\n  count=strlen(T);\n  rep(i,count){p=i,change(T);}\n  rep(i,3*TRI)\n  {\n    x=0;\n    rep(j,N+1)\n    {\n      x+=abc[i][j]*pw3[j];\n      if(x>=3*TRI)x%=3*TRI;\n      if(j==N)printf(\"%d%c\",x,i+1==3*TRI?'\\n':' ');\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<vector>\n\nint main() {\n  std::cin.tie(0); std::ios::sync_with_stdio(false);\n  int N; std::string T; std::cin >> N >> T;\n  int L = 1; for(int i = 0; i < N; ++i) L *= 3;\n  std::vector<int> W(T.size(), 0), WU(T.size()+1), D(L), P(L, 0);\n\n  int l = 1;\n  for(int n = 0; n < N; ++n) {\n    std::fill_n(D.begin(), l, 0);\n    std::fill_n(D.begin()+l, l, l);\n    std::fill_n(D.begin()+l+l, l, l+l);\n    int one = l, two = l+l, three = l*3;\n    bool sOdd = false;\n    WU[0] = two;\n    for(int k = 0; k < T.size(); ++k) {\n      if(T[k] == 'S') {\n        sOdd ^= true;\n        std::swap(one, two);\n      } else {\n        if(sOdd) {\n          (D[W[k]    ] += l+l) %= (l*3);\n          (D[W[k]+l  ] += l+l) %= (l*3);\n          (D[W[k]+l+l] += l+l) %= (l*3);\n        } else {\n          (D[W[k]    ] += l) %= (l*3);\n          (D[W[k]+l  ] += l) %= (l*3);\n          (D[W[k]+l+l] += l) %= (l*3);\n        }\n      }\n      // update W\n      if(D[W[k+1]] == two) WU[k+1] = 0;\n      else if(D[W[k+1]+l] == two) WU[k+1] = l;\n      else WU[k+1] = l+l;\n    }\n    for(int i = 0; i < W.size(); ++i) W[i] += WU[i];\n    // update P\n    for(int i = l*3-1; i >= 0; --i) {\n      P[i] = P[i%l] + (sOdd?(three-D[i])%three: D[i]);\n    }\n    l *= 3;\n  }\n  for(int i = 0; i < L-1; ++i) std::cout << P[i] << \" \";\n  std::cout << P[L-1] << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\nconst int M=15,N=600005;\nint n,m,Q;\nchar s[N];\nint Pw[M];\nstruct Trie\n{\n\tstruct Node\n\t{\n\t\tint ch[3];\n\t\tint val;\n\t\tint tag;\n\t\tNode()\n\t\t{\n\t\t\tch[0]=ch[1]=ch[2]=0;\n\t\t\tval=-1;\n\t\t\ttag=0;\n\t\t\treturn;\n\t\t}\n\t}trie[N*3];\n\tint tot=1;\n\tvoid insert(int x)\n\t{\n\t\tvector<int>v;\n\t\tint t=x;\n\t\twhile(t)\n\t\t\tv.push_back(t%3),t/=3;\n\t\twhile(v.size()<m)\n\t\t\tv.push_back(0);\n\t\tint u=1;\n\t\tfor(int c:v)\n\t\t{\n\t\t\tif(!trie[u].ch[c]) trie[u].ch[c]=++tot;\n\t\t\tu=trie[u].ch[c];\n\t\t}\n\t\ttrie[u].val=x;\n\t\treturn;\n\t}\n\tvoid push_down(int u)\n\t{\n\t\tif(!trie[u].tag) return;\n\t\tswap(trie[u].ch[1],trie[u].ch[2]);\n\t\tfor(int i=0;i<3;i++)\n\t\t\ttrie[trie[u].ch[i]].tag^=1;\n\t\ttrie[u].tag=0;\n\t\treturn;\n\t}\n\tvoid reverse(int u)\n\t{\n\t\ttrie[u].tag^=1;\n\t\treturn;\n\t}\n\tvoid add(int u)\n\t{\n\t\tif(!u) return;\n\t\tpush_down(u);\n\t\tint t=trie[u].ch[2];\n\t\ttrie[u].ch[2]=trie[u].ch[1];\n\t\ttrie[u].ch[1]=trie[u].ch[0];\n\t\ttrie[u].ch[0]=t;\n\t\tadd(trie[u].ch[0]);\n\t\treturn;\n\t}\n\tvoid query(int u,int sum,int dep,vector<int>&res)\n\t{\n\t\tif(!u) return;\n\t\tpush_down(u);\n\t\tif(trie[u].val!=-1) res[trie[u].val]=sum;\n\t\tfor(int i=0;i<3;i++)\n\t\t\tquery(trie[u].ch[i],sum+i*Pw[dep],dep+1,res);\n\t\treturn;\n\t}\n}T;\nint main()\n{\n\tscanf(\"%d\",&m);\n\tPw[0]=1;\n\tfor(int i=1;i<=m;i++)\n\t\tPw[i]=Pw[i-1]*3;\n\tn=Pw[m];\n\tscanf(\"%s\",s+1);\n\tQ=strlen(s+1);\n\tfor(int i=0;i<n;i++)\n\t\tT.insert(i);\n\tfor(int i=1;i<=Q;i++)\n\t\tif(s[i]=='S') T.reverse(1);\n\t\telse if(s[i]=='R') T.add(1);\n\tvector<int>res;\n\tres.resize(n);\n\tT.query(1,0,0,res);\n\tfor(int u:res)\n\t\tprintf(\"%d \",u);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1000000+5;\nint m,Pow[20];\nint trie[N][3],val[N],tag[N],tot=1;\nvoid insert(int x){\n\tint pos=x;\n\tvector<int> vec;\n\twhile(x) vec.push_back(x%3),x/=3;\n\twhile(vec.size()<m) vec.push_back(0);\n\tint p=1;\n\tfor(int i=0;i<vec.size();++i){\n\t\tif(!trie[p][vec[i]]) trie[p][vec[i]]=++tot;\n\t\tp=trie[p][vec[i]];\n\t}\n\tval[p]=pos;\n}\nvoid push_down(int p){\n\tif(!tag[p]) return;\n\tfor(int i=0;i<3;++i)\n\t\ttag[trie[p][i]]^=1;\n\ttag[p]=0;\n\tswap(trie[p][1],trie[p][2]);\n}\nvoid reverse(int p){\n\ttag[p]^=1;\n}\nvoid add(int p){\n\tif(!p) return;\n\tpush_down(p);\n\tint t=trie[p][2];\n\ttrie[p][2]=trie[p][1];\n\ttrie[p][1]=trie[p][0];\n\ttrie[p][0]=t; \n\tadd(trie[p][0]);\n}\nmap<int,int> res;\nvoid query(int p,int sum,int dep){\n\tif(!p) return;\n\tpush_down(p);\n\tres[val[p]]=sum;\n\tfor(int i=0;i<3;++i)\n\t\tquery(trie[p][i],sum+i*Pow[dep],dep+1);\n}\nint main(){\n\tmemset(val,-0x3f,sizeof(val));\n\tcin>>m;\n\tPow[0]=1;\n\tfor(int i=1;i<=m;++i)\n\t\tPow[i]=Pow[i-1]*3;\n\tfor(int i=0;i<Pow[m];++i)\n\t\tinsert(i);\n\tstring T;cin>>T;\n\tfor(int i=0;i<T.size();++i)\n\t\tif(T[i]=='S') reverse(1);\n\t\telse add(1);\n\tquery(1,0,0);\n\tfor(int i=0;i<Pow[m];++i)\n\t\tcout<<res[i]<<\" \";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nchar t[200001];\nint a[13];\nint b[531441];\nint c[13][531441];\nint last[531441];\nint ans[13][531441];\n\nint main() {\n    int n, m, i, j;\n    \n    scanf(\"%d\", &n);\n    scanf(\"%s\", t);\n    \n    m = strlen(t);\n    \n    a[0] = 1;\n    for (i = 1; i <= n; i++) a[i] = a[i - 1] * 3;\n    \n    for (i = 0; i < n; i++) {\n        int s = 0;\n        \n        for (j = 0; j < a[i]; j++) {\n            b[j] = 0;\n            b[j + a[i]] = 1;\n            b[j + a[i] * 2] = 2;\n            last[j] = 0;\n        }\n        \n        for (j = 0; j < m; j++) {\n            int x = c[i][j];\n            \n            if ((s - last[x]) % 2 == 1) {\n                last[x] = s;\n                \n                b[x] = (3 - b[x]) % 3;\n                b[x + a[i]] = (3 - b[x + a[i]]) % 3;\n                b[x + a[i] * 2] = (3 - b[x + a[i] * 2]) % 3;\n            }\n            \n            if (b[x] == 2) {\n                c[i + 1][j] = x;\n            } else if (b[x + a[i]] == 2) {\n                c[i + 1][j] = x + a[i];\n            } else {\n                c[i + 1][j] = x + a[i] * 2;\n            }\n            \n            if (t[j] == 'S') {\n                s++;\n            } else {\n                b[x] = (b[x] + 1) % 3;\n                b[x + a[i]] = (b[x + a[i]] + 1) % 3;\n                b[x + a[i] * 2] = (b[x + a[i] * 2] + 1) % 3;\n            }\n        }\n        \n        for (j = 0; j < a[i]; j++) {\n            if ((s - last[j]) % 2 == 1) {\n                b[j] = (3 - b[j]) % 3;\n                b[j + a[i]] = (3 - b[j + a[i]]) % 3;\n                b[j + a[i] * 2] = (3 - b[j + a[i] * 2]) % 3;\n            }\n            \n            ans[i + 1][j] = ans[i][j] + b[j] * a[i];\n            ans[i + 1][j + a[i]] = ans[i][j] + b[j + a[i]] * a[i];\n            ans[i + 1][j + a[i] * 2] = ans[i][j] + b[j + a[i] * 2] * a[i];\n        }\n    }\n    \n    for (i = 0; i < a[n]; i++) {\n        if (i > 0) putchar(' ');\n        printf(\"%d\", ans[n][i]);\n    }\n    puts(\"\");\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nconst int pw[13]={1,3,9,27,81,243,729,2187,6561,19683,59049,177147,531441};\nstatic inline void OUT(long x){if(x<0)putchar('-'),x=-x;if(x>=10)OUT(x/10);putchar(x%10+48);}\nint main(void)\n{\n  int N,len,carry[200000],temp[531441],A[531441],add[531441];char T[200001];\n  if(scanf(\"%d %s\",&N,T)!=0)len=strlen(T);\n  rep(i,N)\n  {\n    int flip=0;\n    memset(add,0,pw[i]*sizeof(int));\n    rep(j,len)\n    {\n      if(T[j]=='S'){flip^=1;}\n      else\n      {\n        int x=carry[j];\n        add[x]=(add[x]+(flip?2:1))%3;\n        carry[j]+=(3-add[x])%3*pw[i];\n      }\n    }\n    memcpy(temp,A,pw[i]*sizeof(int));\n    rep(c,3){rep(j,pw[i])A[c*pw[i]+j]=temp[j]+(flip?2:1)*(c+add[j])%3*pw[i];}\n  }\n  rep(i,pw[N])OUT(A[i]),putchar(' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <random>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <sstream>\n#include <bitset>\n#include <cassert>\n#include <fstream>\n#include <queue>\n\n#define len(X) ((int)(X).size())\n\n#ifdef __LOCAL\n\t#define DEBUG_OUTPUT_ENABLED 1\n\t#define DBG(X) dout << #X << \"=\" << (X) << '\\n';\n\t#define SAY(X) dout << (X) << '\\n';\n#else\n\t#define DEBUG_OUTPUT_ENABLED 0\n\t#define DBG(X) 42;\n\t#define SAY(X) 42;\n#endif\n\n#define dout   ___debug::instance\n\nusing namespace std;\nusing ll = long long int;\nusing ull = unsigned long long int;\nusing ld  = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const pair<T, S> p) { cout << \"[\" << p.first << \";\" << p.second << \"]\"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const vector<T>& v) { for(auto el: v) cout << el << \" \"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const set<T>& v) { for(auto el: v) cout << el << \" \"; return os; }\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const map<T, S>& v) { for(auto el: v) cout << el << \" \"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const multiset<T>& v) { for(auto el: v) cout << el << \" \"; return os; }\nnamespace ___debug {\n\tstruct DebugStream {\n\t\tprivate:\n\t\t\tbool is_first;\n\t\tpublic:\n\t\t\tDebugStream(bool _is_first): is_first(_is_first) {}\n\t\t\ttemplate<typename T> DebugStream operator<<(const T& value) const {\n\t\t\t\tassert(DEBUG_OUTPUT_ENABLED);\n\t\t\t\tif(is_first) cout << \"[DBG] \";\n\t\t\t\tcout << value;\n\t\t\t\treturn DebugStream(false);\n\t\t\t};\n\n\t\t\ttemplate<typename T> DebugStream printArray(T* l, T* r) {\n\t\t\t\tassert(DEBUG_OUTPUT_ENABLED);\n\t\t\t\tif(is_first) cout << \"[DBG] \";\n\t\t\t\twhile(l != r) {\n\t\t\t\t\tcout << (*l);\n\t\t\t\t\t++l;\n\t\t\t\t\tif(l == r) {\n\t\t\t\t\t\tcout << '\\n';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcout << ' ';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn DebugStream(false);\n\t\t\t}\n\t};\n\tDebugStream instance(true);\n};\n\nconst int INT_INF = (int)(2e9);\nconst ll  LL_INF  = (ll)(2e18);\n\nconst int NIL = -1;\nstatic mt19937 _g(time(nullptr));\n\ninline ll randint(ll a, ll b) { ll w = (_g() << 31LL) ^ _g(); return a + w % (b - a + 1); }\ninline void fast_io() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); };\ntemplate<typename T> inline T sign(T x) { return T(x > 0) - T(x < 0); }\ntemplate<typename T> inline T fetch() { T ret; cin >> ret; return ret; }\ntemplate<typename T> inline vector<T> fetch_vec(int sz) { vector<T> ret(sz); for(auto& elem: ret) cin >> elem; return ret; }\ntemplate<typename T> inline void makeUnique(vector<T>& v) { sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end()); }\nstruct Node {\n\tint val;\n\tint go0, go1, go2;\n};\nvector<Node> V;\nint newNode() {\n\tV.emplace_back();\n\treturn len(V) - 1;\n}\nvoid build(int root, int n, int cur, int inc, int depth) {\n\tif(depth == n) {\n\t\tV[root].go0 = V[root].go1 = V[root].go2 = NIL;\n\t\tV[root].val = cur;\n\t} else {\n\t\tint A = newNode();\n\t\tint B = newNode();\n\t\tint C = newNode();\n\t\tV[root].go0 = A;\n\t\tV[root].go1 = B;\n\t\tV[root].go2 = C;\n\t\tbuild(A, n, cur, 3 * inc, depth + 1);\n\t\tbuild(B, n, cur + inc, 3 * inc, depth + 1);\n\t\tbuild(C, n, cur + 2 * inc, 3 * inc, depth + 1);\n\t}\n}\nvoid shift1(int root) {\n\tif(V[root].go0 == NIL || V[root].go1 == NIL || V[root].go2 == NIL) {\n\t\treturn;\n\t}\n\tint d0 = V[root].go0;\n\tint d1 = V[root].go1;\n\tint d2 = V[root].go2;\n\tV[root].go1 = d0;\n\tV[root].go2 = d1;\n\tV[root].go0 = d2;\n\tshift1(d2);\n}\nvoid shift2(int root) {\n\tif(V[root].go0 == NIL || V[root].go1 == NIL || V[root].go2 == NIL) {\n\t\treturn;\n\t}\n\tint d0 = V[root].go0;\n\tint d1 = V[root].go1;\n\tint d2 = V[root].go2;\n\tV[root].go2 = d0;\n\tV[root].go0 = d1;\n\tV[root].go1 = d2;\n\tshift2(d1);\n}\nint answ[1000 * 1000];\nvoid show1(int root, int cur, int inc) {\n\tif(V[root].go0 == NIL || V[root].go1 == NIL || V[root].go2 == NIL) {\n\t\tansw[V[root].val] = cur;\t\n\t} else {\n\t\tshow1(V[root].go0, cur, 3 * inc);\n\t\tshow1(V[root].go1, cur + inc, 3 * inc);\n\t\tshow1(V[root].go2, cur + 2 * inc, 3 * inc);\n\t}\n}\nvoid show2(int root, int cur, int inc) {\n\tif(V[root].go0 == NIL || V[root].go1 == NIL || V[root].go2 == NIL) {\n\t\tansw[V[root].val] = cur;\t\n\t} else {\n\t\tshow2(V[root].go0, cur, 3 * inc);\n\t\tshow2(V[root].go2, cur + inc, 3 * inc);\n\t\tshow2(V[root].go1, cur + 2 * inc, 3 * inc);\n\t}\n}\nvoid solve() {\n\tint n = fetch<int>();\n\tint root = newNode();\n\tbuild(root, n, 0, 1, 0);\n\tauto cmd = fetch<string>();\n\tint flag = 1;\n\tfor(auto& ch: cmd) {\n\t\tif(ch == 'S') {\n\t\t\tflag ^= 1;\n\t\t} else if(ch == 'R') {\n\t\t\tif(flag) {\n\t\t\t\tshift1(root);\n\t\t\t} else {\n\t\t\t\tshift2(root);\n\t\t\t}\n\t\t} else {\n\t\t\tassert(false);\n\t\t}\n\t}\n\tif(flag) {\n\t\tshow1(root, 0, 1);\n\t} else {\n\t\tshow2(root, 0, 1);\n\t}\n\tint mod = 1;\n\tfor(int i = 0; i < n; ++i) {\n\t\tmod *= 3;\n\t}\n\tfor(int i = 0; i < mod; ++i) {\n\t\tcout << answ[i] << ' ';\n\t}\n\tcout << '\\n';\n}\n\nint main() {\n\tfast_io();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint S,n,tri[20],son[1001000][3],val[1001000][3],cnt,res[1001000];\nbool tag[1001000];\nvoid build(int x,int y){\n\tif(y==n)return;\n\tfor(int i=0;i<3;i++)val[x][i]=i,son[x][i]=++cnt,build(cnt,y+1);\n}\nvoid pushdown(int x){\n\tif(!tag[x])return;\n\tfor(int i=0;i<3;i++){\n\t\ttag[son[x][i]]^=1;\n\t\tif(val[x][i])val[x][i]^=3;\n\t}\n\ttag[x]=0;\n}\nvoid Salsa(){\n\ttag[0]^=1;\n}\nvoid Rumba(int x,int y){\n\tif(y==n)return;\n\tpushdown(x);\n\tfor(int i=0;i<3;i++){\n\t\tval[x][i]++;\n\t\tif(val[x][i]==3)val[x][i]=0,Rumba(son[x][i],y+1);\n\t}\n}\nvoid Calc(int x,int y,int z,int w){\n\tif(y==n){res[z]=w;return;}\n\tpushdown(x);\n\tfor(int i=0;i<3;i++)Calc(son[x][i],y+1,z+tri[y]*i,w+val[x][i]*tri[y]);\n}\nchar s[1001000];\nint main(){\n\tscanf(\"%d\",&n),build(0,0),tri[0]=1;\n\tfor(int i=1;i<=n;i++)tri[i]=tri[i-1]*3;\n\tscanf(\"%s\",s),S=strlen(s);\n\tfor(int i=0;i<S;i++)if(s[i]=='S')Salsa();else Rumba(0,0);\n\tCalc(0,0,0,0);for(int i=0;i<tri[n];i++)printf(\"%d \",res[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<ll,ll>\n#define poly vector<ll>\n#define mem(a) memset((a),0,sizeof(a))\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\n#define SZ(x) ((int)(x.size()))\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int M=1e6;\nint n,pw[15],lzy[M],ch[M][3],ans[M],to[M];\ninline void cao(int x){\n\tlzy[x]^=1; swap(ch[x][1],ch[x][2]);\n}\nvoid dfs(int p,int de,int su,int a){\n\tif(p>=pw[n-1]){\n\t\t//cout<<p-pw[n-1]<<\" \"<<su<<endl;\n\t\tans[p-pw[n-1]]=su; to[a]=su; return;\n\t}\n\tif(lzy[p]){\n\t\tFor(i,0,2)cao(ch[p][i]);\n\t}\n\tFor(i,0,2)dfs(ch[p][i],de*3,su+de*i,a*3+i);\n}\nint main(){\n\t#ifdef Brollan\n\t\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tn=read();\n\tFor(i,pw[0]=1,n)pw[i]=pw[i-1]*3; \n\tFor(i,1,n)pw[i]+=pw[i-1];\n\tFor(i,0,pw[n]-1){\n\t\tFor(j,0,2)ch[i][j]=i*3+j+1;\n\t}\n\tstring s;\n\tcin>>s;\n\tfor(auto i:s)if(i=='S'){\n\t\tcao(0);\n\t\t//cout<<ch[0][0]<<\" \"<<ch[0][1]<<\" \"<<ch[0][2]<<endl;\n\t}else{\n\t\tint dq=0;\n\t\tFor(j,0,n-1){\n\t\t\tif(lzy[dq]){\n\t\t\t\tlzy[dq]=0;\n\t\t\t\tFor(k,0,2)cao(ch[dq][k]);\n\t\t\t}\n\t\t\tint t=ch[dq][2]; ch[dq][2]=ch[dq][1]; ch[dq][1]=ch[dq][0]; ch[dq][0]=t;\n\t\t\tdq=ch[dq][0]; \n\t\t}\n\t\t//cout<<ch[0][0]<<\" \"<<ch[0][1]<<\" \"<<ch[0][2]<<endl;\n\t}\n\tdfs(0,1,0,0);\n\tFor(i,0,pw[n]-pw[n-1]-1)wri(ans[to[i]]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid read(int &x) {\n    x=0;int f=1;char ch=getchar();\n    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-f;\n    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';x*=f;\n}\n\nvoid print(int x) {\n    if(x<0) putchar('-'),x=-x;\n    if(!x) return ;print(x/10),putchar(x%10+48);\n}\nvoid write(int x) {if(!x) putchar('0');else print(x);putchar('\\n');}\n\n#define lf double\n#define ll long long \n\n#define pii pair<int,int >\n#define vec vector<int >\n\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\n#define data asd09123jdf02i3h\n\n#define FOR(i,l,r) for(int i=l,i##_r=r;i<=i##_r;i++)\n\nconst int maxn = 1e6+10;\nconst int inf = 1e9;\nconst lf eps = 1e-8;\nconst int mod = 1e9+7;\n\nint n,tr[maxn][3],tag[maxn],N,cnt=1,id[maxn],tot,r[maxn];\nchar s[maxn];\n\nvoid ins(int v) {\n    int x=1,p=v;\n    for(int i=1;i<=n;i++) {\n        int t=v%3;v/=3;\n        if(!tr[x][t]) tr[x][t]=++cnt;\n        x=tr[x][t];\n    }id[x]=p;\n}\n\nvoid push(int x) {tag[x]^=1,swap(tr[x][1],tr[x][2]);}\n\nvoid dfs(int x) {\n    if(!tr[x][0]) return ;\n    if(tag[x]) {\n        for(int i=0;i<3;i++) push(tr[x][i]);\n        tag[x]=0;\n    }\n    swap(tr[x][0],tr[x][1]),swap(tr[x][0],tr[x][2]);\n    dfs(tr[x][0]);\n}\n\nvoid get(int x,int v,int t) {\n    if(!tr[x][0]) {\n        r[id[x]]=v;\n        return ;\n    }\n    for(int i=0;i<3;i++) get(tr[x][i],v+t*i,t*3);\n}\n\nint main() {\n    read(n);N=pow(3,n);\n    for(int i=0;i<N;i++) ins(i);\n    scanf(\"%s\",s+1);int m=strlen(s+1);\n    for(int i=1;i<=m;i++)\n        if(s[i]=='S') push(1);\n        else dfs(1);\n    get(1,0,1);\n    for(int i=0;i<N;i++) printf(\"%d \",r[i]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#define int long long\n\n#define pii pair<int, int>\n\n#define x1 x1228\n#define y1 y1228\n\n#define left left228\n#define right right228\n\n#define next next228\n\n#define pb push_back\n#define eb emplace_back\n\n#define mp make_pair                                                                \n                                                                                                                                        \n#define ff first                                                                  \n#define ss second   \n\n#define all(x) x.begin(), x.end()\n#define debug(x) cout << #x << \": \" << x << endl; \n#define TIME (ld)clock()/CLOCKS_PER_SEC\n\nusing namespace std;\ntypedef long long ll; \ntypedef long double ld; \n                                                                                                   \nconst int maxn = 2e5 + 7, mod = 1e9 + 7, MAXN = 1e6 + 7;\nconst double eps = 1e-9;\nconst ll inf = 1e18;\nmt19937 rnd(time(0));\nint n; \nstring s; \nint a[maxn]; \nint next[maxn];\nconst int N = 2187; \nint dp1[N]; \nint dp2[N]; \n\nint get(int mask, char q) {\n    if (q == 'R') {\n        ++mask; \n        return mask; \n    }   \n    int ptr = 1; \n    int ans = 0; \n    while (mask) {\n        int t = mask % 3; \n        mask /= 3; \n        if (t == 2) ans += ptr; \n        if (t == 1) ans += 2 * ptr; \n        ptr *= 3; \n    }\n    return ans; \n}\n\nconst int L = 12; \nint pref[maxn]; \nint to[maxn][N]; \n\nint get(int l, int r) {\n    return pref[r + 1] - pref[l]; \n}\n\nvoid change(int &mask, int l, int r) {\n    if (get(l, r) % 2) {\n        int ptr = 1; \n        int ans = 0; \n        while (mask) {\n            int t = mask % 3; \n            mask /= 3; \n            if (t == 2) ans += ptr; \n            if (t == 1) ans += 2 * ptr; \n            ptr *= 3; \n        }\n        mask = ans; \n    }    \n    mask++; \n}\n\nint merge(int left, int right) {\n    for (int i = 0; i < 7; ++i) right *= 3;\n    return left + right;     \n}\n\nint get(int x) {\n    vector<int> bts; \n    for (int i = 0; i < L; ++i) {\n        bts.pb(x % 3); \n        x /= 3; \n    }\n    int left = 0;\n    int right = 0; \n    for (int i = 6; i >= 0; --i) {\n        left *= 3;\n        left += bts[i]; \n    }\n    for (int i = L - 1; i >= 7; --i) {\n        right *= 3; \n        right += bts[i]; \n    }\n    int id = 0; \n    if (dp1[left] == -1) {\n        return merge(to[0][left], right);  \n    }\n    if (left) {    \n        id = dp1[left]; \n        change(right, 0, id - 1);             \n        left = 0; \n    }                     \n    while (next[id] != -1) {\n        change(right, id, next[id] - 1);\n        id = next[id];                                                                                                                                         \n    }\n    left = to[id][0]; \n    return merge(left, right); \n}\n\n\nvoid solve() {\n    cin >> n >> s; \n    int t = s.size(); \n    for (int i = 0; i < t; ++i) {\n        pref[i + 1] = pref[i] + (s[i] == 'S'); \n    }\n    for (int i = 0; i < N; ++i) dp1[i] = dp2[i] = -1; \n    for (int i = 0; i < N; ++i) to[t][i] = i; \n    for (int i = t - 1; i >= 0; --i) {\n        for (int mask = 0; mask < N; ++mask) {\n            int mask1 = get(mask, s[i]); \n            to[i][mask] = to[i + 1][mask1]; \n        }\n        for (int mask = 0; mask < N; ++mask) {\n            int mask1 = get(mask, s[i]); \n            if (mask && mask1 == 0) {\n                dp2[mask] = i + 1; \n            } else {\n                dp2[mask] = dp1[mask1]; \n            }   \n        }\n        next[0] = dp2[0]; \n        for (int mask = 0; mask < N; ++mask) {\n            dp1[mask] = dp2[mask]; \n            dp2[mask] = -1; \n        }                                                                \n    }                      \n    int tet = 1; \n    for (int i = 0; i < n; ++i) tet *= 3; \n    for (int i = 0; i < tet; ++i) {\n        cout << get(i) % tet << \" \";             \n    }\n}                                \n   \nsigned main() {\n#ifdef LOCAL\n    freopen(\"TASK.in\", \"r\", stdin);\n    freopen(\"TASK.out\", \"w\", stdout);\n#else \n    \n#endif // LOCAL\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20); \n    cout << fixed; \n    int t = 1; \n    for (int i = 0; i < t; ++i) {              \n        solve();\n    }\n    return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m;\nconst int M = 2e5+5;\nchar s[M];\n\nstruct Node{\n\tint swp,ch[3],ed;\n}t[2000010];\nint cnt=1;\n\ninline void ins(int sum){\n\tint fir=1;\n\tint s=sum;\n\tfor(int i=0;i<n;i++){\n\t\tint q=sum%3;\n\t\tsum/=3;\n\t\tif(!t[fir].ch[q])t[fir].ch[q]=++cnt;\n\t\tfir=t[fir].ch[q];\n\t}\n\tt[fir].ed=s;\n}\n\nvoid add(){\n\tint fir=1;\n\tfor(int i=0;i<n;i++){\n\t\tif(t[fir].swp){\n\t\t\tswap(t[fir].ch[1],t[fir].ch[2]);\n\t\t\tfor(int j=0;j<3;j++)t[t[fir].ch[j]].swp^=1;\n\t\t\tt[fir].swp=0;\n\t\t}\n\t\tint q=t[fir].ch[2];t[fir].ch[2]=t[fir].ch[1],t[fir].ch[1]=t[fir].ch[0];\n\t\tt[fir].ch[0]=q;\n\t\tfir=q;\n\t}\n}\nint ans[2000010];\nvoid dfs(int fir,int d,int quan,int s){\n\tif(t[fir].swp){\n\t\tswap(t[fir].ch[1],t[fir].ch[2]);\n\t\tfor(int j=0;j<3;j++)t[t[fir].ch[j]].swp^=1;\n\t\tt[fir].swp=0;\n\t}\n\tif(d==n){\n\t\tans[t[fir].ed]=s;return;\n\t}\n\tfor(int j=0;j<3;j++){\n\t\tdfs(t[fir].ch[j],d+1,quan*3,s+quan*j);\n\t}\n}\nint tot=0;\nint main()\n{\n\tcin >> n;\n\ttot=1;for(int i=1;i<=n;i++)tot*=3;\n\tscanf(\"%s\",s+1);\n\tm=strlen(s+1);\n\tfor(int i=0;i<tot;i++){\n\t\tins(i);\n\t}\n\t// cerr << \"?\" << endl;\n\tfor(int j=1;j<=m;j++){\n\t\tif(s[j]=='S')t[1].swp^=1;\n\t\telse add();\n\t\t// dfs(1,0,1,0);\n\t\t// for(int i=0;i<tot;i++)printf(\"%d \",ans[i]);puts(\"\");\n\t}\n\tdfs(1,0,1,0);\n\tfor(int i=0;i<tot;i++)printf(\"%d \",ans[i]);puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n) for (int i = 1; i <= (int) (n); i++)\n#define all(x) (x).begin(), (x).end()\n#define uniq(x) (x).erase(unique(all(x)), end(x))\n#define bit(n) (1LL << (n))\n#define cdiv(a, b) (((a) - 1) / (b) + 1)\n#define dump(x) cerr << #x \" = \" << (x) << endl\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing pint = pair<int, int>;\nusing vpint = vector<pint>;\ntemplate<typename T> using priority_queue_rev = priority_queue<T, vector<T>, greater<T>>;\nconstexpr double PI = 3.1415926535897932384626433832795028;\nconstexpr int DY[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr int DX[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint gcd(int a, int b) {\n    while (b) { swap(a %= b, b); }\n    return a;\n}\nint lcm(int a, int b) { return a / gcd(a, b) * b; }\ntemplate<typename T> void fin(T mes) {\n    cout << mes << endl;\n    exit(0);\n}\ntemplate<typename T, typename U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<typename T, typename U> ostream &operator<<(ostream &os, const pair<T, U> &rhs) {\n    os << \"(\" << rhs.first << \", \" << rhs.second << \")\";\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &rhs) {\n    os << \"{\";\n    for (auto itr = rhs.begin(); itr != rhs.end(); itr++) {\n        os << *itr << (next(itr) != rhs.end() ? \", \" : \"\");\n    }\n    os << \"}\";\n    return os;\n}\nstruct setup {\n    static constexpr int PREC = 20;\n    setup() {\n        cout << fixed << setprecision(PREC);\n        cerr << fixed << setprecision(PREC);\n    };\n} setup;\n\nint my_pow(int a, int n) {\n    if (n == 0) { return 1; }\n    int x = my_pow(a, n / 2);\n    int ret = x * x;\n    if (n & 1) { ret *= a; }\n    return ret;\n}\nstring compress(string t) {\n    string ret = \"\";\n    if (t.size() == 0) { return ret; }\n    ret.push_back(t[0]);\n    for (int i = 1; i < t.length(); i++) {\n        if (ret.back() == 'S' && t[i] == 'S') { ret.pop_back(); }\n        else { ret.push_back(t[i]); }\n    }\n    return ret;\n}\nint N;\nstring T;\nint ans[550000];\nvoid dfs(int n, int in, int out, string t) {\n    if (n == N) {\n        ans[in] = out;\n        return;\n    }\n    t = compress(t);\n    int c0 = 0, c1 = 1, c2 = 2;\n    string v0 = \"\", v1 = \"\", v2 = \"\";\n    rep(i, t.size()) {\n        if (t[i] == 'S') {\n            c0 = (3 - c0) % 3, c1 = (3 - c1) % 3, c2 = (3 - c2) % 3;\n            v0.push_back('S'), v1.push_back('S'), v2.push_back('S');\n        } else {\n            (c0 += 1) %= 3, (c1 += 1) %= 3, (c2 += 1) %= 3;\n            if (c0 == 0) { v0.push_back('R'); }\n            if (c1 == 0) { v1.push_back('R'); }\n            if (c2 == 0) { v2.push_back('R'); }\n        }\n    }\n    int p = my_pow(3, n);\n    dfs(n + 1, in + 0 * p, out + c0 * p, v0);\n    dfs(n + 1, in + 1 * p, out + c1 * p, v1);\n    dfs(n + 1, in + 2 * p, out + c2 * p, v2);\n}\n\nsigned main() {\n    cin >> N >> T;\n    dfs(0, 0, 0, T);\n    int p = my_pow(3, N);\n    rep(i, p) { cout << ans[i] << \" \"; }\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i, x, y) for(int i = (x); i < (y); ++i)\n#define REP(i, x, y) for(int i = (x); i <= (y); ++i)\n#define MP make_pair\n#define PB push_back\n#define PH push\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9 + 7;\nconst int maxn = 13;\nconst int maxp = 2e6 + 5;\nconst int maxm = 2e5 + 5;\n\nint n, m;\nint pw[maxn], ans[maxp];\nchar t[maxm];\n\nclass Trie{\npublic:\n\tint tot;\n\tint p[maxp], ch[maxp][3], tag[maxp];\n\tTrie(){\n\t\ttot = 1;\n\t\tmemset(ch, -1, sizeof(ch));\n\t\tmemset(p, -1, sizeof(p));\n\t\treturn;\n\t}\n\tinline void insert(int x){\n\t\tint u = 0, y = x;\n\t\tfor(int i = 0; i < n; ++i, x /= 3){\n\t\t\tif(!~ch[u][x % 3])\n\t\t\t\tch[u][x % 3] = tot++;\n\t\t\tu = ch[u][x % 3];\n\t\t}\n//\t\tprintf(\"u = %d y = %d\\n\", u, y);\n\t\tp[u] = y;\n\t\treturn;\n\t}\n\tinline void inv(int u){\n\t\ttag[u] ^= 1;\n\t\tswap(ch[u][1], ch[u][2]);\n\t\treturn;\n\t}\n\tinline void pushDown(int u){\n\t\tif(tag[u]){\n\t\t\tFOR(i, 0, 3)\n\t\t\t\tinv(ch[u][i]);\n\t\t\ttag[u] = false;\n\t\t}\n\t\treturn;\n\t}\n\tinline void update(int dep, int u){\n//\t\tprintf(\"dep = %d u = %d\\n\", dep, u);\n\t\tif(dep > n || !~u)\n\t\t\treturn;\n\t\tpushDown(u);\n\t\tint tmp = ch[u][2];\n\t\tch[u][2] = ch[u][1];\n\t\tch[u][1] = ch[u][0];\n\t\tch[u][0] = tmp;\n\t\tupdate(dep + 1, ch[u][0]);\n\t\treturn;\n\t}\n\tinline void dfs(int dep, int u, int x){\n\t\tif(dep > n || !~u)\n\t\t\treturn;\n//\t\tprintf(\"dep = %d u = %d x = %d\\n\", dep, u, x);\n\t\tpushDown(u);\n\t\tFOR(i, 0, 3)\n\t\t\tdfs(dep + 1, ch[u][i], x + i * pw[dep]);\n\t\tif(~p[u])\n\t\t\tans[p[u]] = x;\n\t\treturn;\n\t}\n}trie;\n\ninline void precalc(){\n\tpw[0] = 1;\n\tFOR(i, 1, maxn)\n\t\tpw[i] = pw[i - 1] * 3;\n\treturn;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tprecalc();\n\tscanf(\"%s\", t);\n\tm = strlen(t);\n\tFOR(i, 0, pw[n])\n\t\ttrie.insert(i);\n\tFOR(i, 0, m){\n\t\tif(t[i] == 'S')\n\t\t\ttrie.inv(0);\n\t\telse\n\t\t\ttrie.update(0, 0);\n\t}\n\ttrie.dfs(0, 0, 0);\n\tFOR(i, 0, pw[n])\n\t\tprintf(\"%d \", ans[i]);\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,x,y,z,sw,pw3=1,A[531441]={0},B[531441]={0},S[531441]={0};\nchar T[200001];\nvoid OUT(int x){if(x<0)putchar('-'),x=-x;if(x>=10)OUT(x/10);putchar(x%10+48);}\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nsigned main(void)\n{\n  x=scanf(\"%d %s\",&N,T);\n  replace(T,\"SS\",\"\");if(T[0]=='\\n')return 0;\n  rep(i,N)\n  {\n    rep(j,pw3)rep(k,3)B[j+k*pw3]=k;\n    sw=1;\n    rep(p,strlen(T))\n    {\n      if(T[p]=='R')\n      {\n        y=S[p];\n        rep(j,3)\n        {\n          x=y+j*pw3;\n          if(B[x]==1&&sw==-2)S[p]=x;\n          if(B[x]==2&&sw==1)S[p]=x;\n          B[x]++;if(sw<0)B[x]++;\n          B[x]%=3;\n        }\n      }\n      else sw=~sw;\n    }\n    rep(j,pw3)\n    {\n      y=A[j];\n      rep(k,3)\n      {\n        x=j+k*pw3;\n        if(sw>0)z=B[x]%3;else z=(3-B[x])%3;\n        A[x]=y+z*pw3;\n      }\n    }\n    pw3*=3;\n  }\n  rep(i,pw3)OUT(A[i]),putchar(' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,rt,sz,val[888888],son[888888][3],tag[888888],ans[888888],all;\nchar s[222222];\nvoid build(int &nw,int c,int dep,int sum)\n{\n\tnw=++sz;\n\tif (dep==n)\n\t{\n\t\tval[nw]=sum;\n\t\treturn;\n\t}\n\tbuild(son[nw][0],c*3,dep+1,sum);\n\tbuild(son[nw][1],c*3,dep+1,sum+c);\n\tbuild(son[nw][2],c*3,dep+1,sum+2*c);\n}\nvoid push(int node)\n{\n\tswap(son[node][1],son[node][2]);\n\ttag[node]^=1;\n}\nvoid pushdown(int node)\n{\n\tif (tag[node])\n\t{\n\t\tpush(son[node][0]);\n\t\tpush(son[node][1]);\n\t\tpush(son[node][2]);\n\t\ttag[node]=0;\n\t}\n}\nvoid go(int nw,int dep)\n{\n\tif (dep==n) return;\n\tpushdown(nw);int s1=son[nw][0],s2=son[nw][1],s3=son[nw][2];\n\tson[nw][0]=s3;son[nw][1]=s1;son[nw][2]=s2;\n\tgo(son[nw][0],dep+1);\n}\nvoid cal(int nw,int c,int dep,int sum)\n{\n\tif (dep==n)\n\t{\n\t\tans[val[nw]]=sum;\n\t\treturn;\n\t}\n\tcal(son[nw][0],c*3,dep+1,sum);\n\tcal(son[nw][1],c*3,dep+1,sum+c);\n\tcal(son[nw][2],c*3,dep+1,sum+2*c);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s);\n\tm=strlen(s);\n\tbuild(rt,1,0,0);\n\tfor (int i=0;i<m;i++)\n\t{\n\t\tif (s[i]=='S')\n\t\t{\n\t\t\tpush(rt);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgo(rt,0);\n\t\t}\n\t}\n\tcal(rt,1,0,0);\n\tall=1;\n\tfor (int i=1;i<=n;i++) all*=3;\n\tfor (int i=0;i<all;i++) printf(\"%d \",ans[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nint n,m,type[13][600005],pw[13],res[600005];\nchar t[200005];\nbool flag;\nvoid debug()\n{\n\tprintf(\"flag=%d\\n\",flag);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tprintf(\"%d:\",i);\n\t\tfor(int j=0;j<pw[i];j++)printf(\"%d \",type[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tpw[0]=1;\n\tfor(int i=1;i<=n;i++)pw[i]=pw[i-1]*3;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<pw[i];j++)\n\t\t  type[i][j]=0;\n\t}\n\tscanf(\"%s\",t+1);\n\tm=(int)strlen(t+1);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(t[i]=='S')\n\t\t{\n\t\t\tflag^=1;\n\t\t\tcontinue;\n\t\t}\n\t\tint now=0;\n\t\tfor(int b=0;b<n;b++)\n\t\t{\n\t\t\tif(flag==0)\n\t\t\t{\n\t\t\t\tint v=now+pw[b]*((type[b][now]+2)%3);\n\t\t\t\ttype[b][now]=(type[b][now]+2)%3;\n\t\t\t\tnow=v;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint v=now+pw[b]*((type[b][now]+1)%3);\n\t\t\t\ttype[b][now]=(type[b][now]+1)%3;\n\t\t\t\tnow=v;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<pw[n];j++)\n\t\t{\n\t\t\tint b=(j/pw[i])%3-type[i][j%pw[i]]+3;\n\t\t\tb%=3;\n\t\t\tif(flag)b=(3-b)%3;\n\t\t\tres[j]+=b*pw[i];\n\t\t}\n\t}\n\tfor(int i=0;i<pw[n];i++)printf(\"%d \",res[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint n,m,p,po[13];\nchar a[200020];\nbool tag[800000];\nint ch[800000][3],ans[600000],cnt;\nvoid build(int k,int dep)\n{\n\tif(!dep)return;\n\tch[k][0]=k*3-1,ch[k][1]=k*3,ch[k][2]=k*3+1;\n\tbuild(k*3-1,dep-1),build(k*3,dep-1),build(k*3+1,dep-1);\n}\nvoid pushtag(int k)\n{\n\tswap(ch[k][1],ch[k][2]);\n\ttag[k]^=1;\n}\nvoid work(int k,int dep)\n{\n\tif(!dep)return;\n\tif(tag[k])\n\t{\n\t\tpushtag(ch[k][0]);\n\t\tpushtag(ch[k][1]);\n\t\tpushtag(ch[k][2]);\n\t\ttag[k]=0;\n\t}\n\tint a=ch[k][0],b=ch[k][1],c=ch[k][2];\n\tch[k][0]=c,ch[k][1]=a,ch[k][2]=b;\n\twork(ch[k][0],dep-1);\n}\nvoid dfs(int k,int dep,int cur)\n{\n\tif(!dep)\n\t{\n\t\tint s=0;k-=p+1;\n\t\tfor(int i=1;i<=n;++i)s=s*3+k%3,k/=3;\n\t\tans[s]=cur;\n\t\treturn;\n\t}\n\tif(tag[k])\n\t{\n\t\tpushtag(ch[k][0]);\n\t\tpushtag(ch[k][1]);\n\t\tpushtag(ch[k][2]);\n\t\ttag[k]=0;\n\t}\n\tdfs(ch[k][0],dep-1,cur);\n\tdfs(ch[k][1],dep-1,cur+po[n-dep]);\n\tdfs(ch[k][2],dep-1,cur+2*po[n-dep]);\n}\nint main()\n{\n\tpo[0]=1;\n\tfor(int i=1;i<=12;++i)po[i]=3*po[i-1];\n\tscanf(\"%d\",&n);\n\tbuild(1,n);\n\tscanf(\"%s\",a+1);\n\tm=strlen(a+1);\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tif(a[i]=='S')pushtag(1);\n\t\telse work(1,n);\n\t}\n\tp=(po[n]-1)/2;\n\tdfs(1,n,0);\n\tfor(int i=0;i<po[n];++i)printf(\"%d \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define ll long long\nusing namespace std;\nconst int M=1e6;\nconst int end=531441;\nint s[M];\nint b[1000];\nvoid cha3(ll x,int n){\n\tfor (int i=1;i<=n;i++)b[i]=0;\n\tint i=0;\n\twhile (x){\n\t\tb[++i]=x%3;\n\t\tx/=3;\n\t}\n}\nvoid ops(int n){\n\tfor (int i=1;i<=n;i++){\n\t\tif (b[i]==1)b[i]=2;\n\t\telse if (b[i]==2)b[i]=1;\n\t}\n}\nint pow1[20];\nvoid pre(){\n\tfor (int i=0;i<end;i++){\n\t\tcha3(i,12);\n\t\tint ans=0,base=1;\n\t\tops(12);\n\t\tfor (int j=1;j<=12;j++){\n\t\t\tans+=b[j]*base;\n\t\t\tbase*=3;\n\t\t}\n\t\ts[i]=ans;\n\t}\npow1[1]=3,pow1[2]=9,pow1[3]=27,pow1[4]=81,pow1[5]=243,pow1[6]=729;\npow1[7]=2187,pow1[8]=6561,pow1[9]=19683,pow1[10]=59049,pow1[11]=177147,pow1[12]=531441;\n\n}\nint a[M];\nint main(){\n//\t\tfreopen(\"ab.txt\",\"w\",stdout);\n\tpre();\n\tint n;\n\tstring s1;\n\tcin>>n>>s1;\n\tint cnt=0;\n\tfor (int i=0;i<s1.size();i++){\n\t\tint ans=1;\n\t\tchar c=s1[i];\n\t\twhile (i+ans<s1.size() and s1[i+ans]==c)ans++;\n\t\tif (c=='S'){\n\t\t\tif (ans%2){\n\t\t\t\ta[++cnt]=M+1;\n\t\t\t}\n\t\t}else{\n\t\t\ta[++cnt]=ans;\n\t\t}\n\t\ti=i+ans-1;\n\t}\n\tfor (int i=0;i<pow1[n];i++){\n\t\tll ans=i;\n\t\tfor (int j=1;j<=cnt;j++){\n\t\t\tif (a[j]>M)ans=s[ans];\n\t\t\telse{\n\t\t\t\tans+=a[j];\n\t\t\t\tif (ans>=pow1[n])ans%=pow1[n];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld \",ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define IOS std::ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)\n#define debug(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n#define IN freopen(\"in.txt\", \"r\", stdin);\n#define endl '\\n'\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(x) x.begin(),x.end()\n#define sz(x) (int)x.size()\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef pair<int, int> pii;\nconst int inf = 0x3f3f3f3f;\n\n\nvoid update(int q,int& last,int& d){\n    if(d and q%2 != last%2)d=3-d;\n    last=q;\n}\n\npair<VI,VI> solve(int n,string& T){\n    if(!n){\n        VI p = {0};\n        VI W(sz(T),0);\n        return {p,W};\n    }\n    auto pp=solve(n-1,T);\n    VI p=pp.fi, w=pp.se;\n    VI new_w(sz(w));\n    int pot=sz(p);\n    VI D(3*pot);\n    for(int i=0;i<3;i++)for(int x=0;x<pot;x++)D[i*pot+x]=i;\n    VI last(3*pot,0);\n    int q=0;\n    for(int i=0;i<sz(T);i++){\n        int k=w[i];\n        for(int x=k;x<3*pot;x+=pot){\n            update(q,last[x],D[x]);\n            if(D[x]==2)new_w[i]=x;\n        }\n        if(T[i]=='S')q++;\n        if(T[i]=='R'){\n            for(int x=k;x<3*pot;x+=pot)D[x]=(D[x]+1)%3;\n        }\n    }\n    VI new_p(3*pot);\n    for(int i=0;i<3*pot;i++){\n        update(q,last[i],D[i]);\n        new_p[i]=p[i%pot]+D[i]*pot;\n    }\n    return {new_p,new_w};\n}\n\nint main(){\n    IOS;\n    int n;string s;\n    cin>>n>>s;\n    VI p=solve(n,s).fi;\n    for(int x:p)cout<<x<<' ';\n    cout<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\nint res[531441];\nint P[14];\nint nn;\nvoid dfs(int id,int p,int q,string s){\n    if(id==nn){\n        res[p] = q;\n        return;\n    }\n    int n = s.size();\n    string t;\n    for(int i=0;i<n;i++){\n        if(s[i]=='S'){\n            if(t.size()!=0&&t.back()=='S'){\n                t.pop_back();\n            }else{\n                t.push_back(s[i]);\n            }\n        }else{\n            t.push_back(s[i]);\n        }\n    }\n    for(int pp=0;pp<3;pp++){\n        string nxt;\n        int k = pp;\n        for(int i=0;i<n;i++){\n            if(t[i]=='S'){\n                if(k==1||k==2){\n                    k = 3-k;\n                }\n                nxt.push_back('S');\n            }else if(t[i]=='R'){\n                k++;\n                if(k==3){\n                    nxt.push_back('R');\n                    k = 0;\n                }\n            }\n        }\n        dfs(id+1,p+P[id]*pp,q+P[id]*k,nxt);\n    }\n}\nint main(){\n    string s;\n    cin >> nn >> s;\n    P[0] = 1;\n    for(int i=1;i<=12;i++){\n        P[i] = P[i-1]*3;\n    }\n    dfs(0,0,0,s);\n    int k = 1;\n    for(int i=0;i<nn;i++){\n        k*=3;\n    }\n    rep(i,k){\n        cout << res[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nconst int N = 540000;\n\nint n;\nstring s;\nint l;\nint r;\nint pl, pr;\nint p[N];\nint rr[N];\nint al[N];\nint ar[N];\n\nint get(int x) {\n\tint ans = 0;\n\tint now = 1;\n\twhile (x) {\n\t\tint c = x % 3;\n\t\tx /= 3;\n\t\tif (c == 1) {\n\t\t\tans += now * 2;\n\t\t} else if (c == 2) {\n\t\t\tans += now;\n\t\t}\n\t\tnow *= 3;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcout.setf(ios::fixed), cout.precision(20);\n\tcin >> n;\n\tcin >> s;\n\tr = n / 2;\n\tl = n - r;\n\tpl = 1;\n\tfor (int i = 0; i < l; ++i) {\n\t\tpl *= 3;\n\t}\n\tpr = 1;\n\tfor (int i = 0; i < r; ++i) {\n\t\tpr *= 3;\n\t}\n\n\tfor (int i = 0; i < pl * pr; ++i) {\n\t\trr[i] = get(i);\n\t}\n\n\tfor (int i = 0; i < pr; ++i) {\n\t\tp[i] = i;\n\t}\n\n\tfor (int i = 0; i < pl * pr; ++i) {\n\t\tar[i] = i % pr;\n\t\tal[i] = i / pr;\n\t}\n\n\tint dr = 0;\n\n\tfor (char c : s) {\n\t\tif (c == 'S') {\n\t\t\tdr ^= 1;\n\t\t\tfor (int i = 0; i < pr; ++i) {\n\t\t\t\tp[i] = rr[p[i]];\n\t\t\t}\n\t\t} else if (c == 'R') {\n\t\t\tint z = 0;\n\t\t\tfor (int i = 0; i < pr; ++i) {\n\t\t\t\t++p[i];\n\t\t\t\tif (p[i] == pr) {\n\t\t\t\t\tz = i;\n\t\t\t\t\tp[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < pl; ++i) {\n\t\t\t\tint x = i * pr + z;\n\t\t\t\tint y = al[x];\n\t\t\t\tif (dr) {\n\t\t\t\t\ty = rr[y];\n\t\t\t\t}\n\t\t\t\ty += 1;\n\t\t\t\tif (y == pl) {\n\t\t\t\t\ty = 0;\n\t\t\t\t}\n\t\t\t\tif (dr) {\n\t\t\t\t\ty = rr[y];\n\t\t\t\t}\n\t\t\t\tal[x] = y;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < pl * pr; ++i) {\n\t\tif (dr) {\n\t\t\tcout << rr[al[i]] * pr + p[ar[i]] << \" \";\n\t\t} else {\n\t\t\tcout << al[i] * pr + p[ar[i]] << \" \";\n\t\t}\n\t}\n\tcout << \"\\n\";\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nconst int maxn = 12;\nconst int maxN = 600000;\nconst int maxt = 200002;\n\nstruct node {\n\tnode *ch[3];\n\tint lazy, id;\n};\n\nnode* build(int d, int cur);\nvoid pd(node *p);\nvoid change(node *p, int d);\nvoid cal(node *p, int d, int cur);\n\nint n, t;\nchar str[maxt];\nint powd[maxn];\nint ans[maxN];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", str + 1);\n\tt = strlen(str + 1);\n\tpowd[0] = 1;\n\tfor (int i = 1; i < n; i++) {\n\t\tpowd[i] = 3 * powd[i - 1];\n\t}\n\tnode *rt = build(0, 0);\n\tfor (int i = 1; i <= t; i++) {\n\t\tif (str[i] == 'S') rt->lazy ^= 1;\n\t\telse change(rt, 0);\n\t}\n\tcal(rt, 0, 0);\n\tint N = 1;\n\tfor (int i = 1; i <= n; i++) N *= 3;\n\tfor (int i = 0; i < N; i++) {\n\t\tprintf(\"%d \", ans[i]);\n\t}\n\treturn 0;\n}\n\nnode* create() {\n\tstatic node pool[maxN];\n\tstatic node *p = pool;\n\tp->ch[0] = p->ch[1] = p->ch[2] = NULL;\n\tp->lazy = p->id = 0;\n\treturn p++;\n}\n\nnode* build(int d, int cur) {\n\tnode *p = create();\n\tif (d == n) {\n\t\tp->id = cur;\n\t\treturn p;\n\t}\n\tp->ch[0] = build(d + 1, cur);\n\tp->ch[1] = build(d + 1, cur + powd[d]);\n\tp->ch[2] = build(d + 1, cur + powd[d] + powd[d]);\n\treturn p;\n}\n\nvoid pd(node *p) {\n\tif (!p->lazy) return;\n\tswap(p->ch[1], p->ch[2]);\n\tp->ch[0]->lazy ^= 1;\n\tp->ch[1]->lazy ^= 1;\n\tp->ch[2]->lazy ^= 1;\n\tp->lazy = 0;\n}\n\nvoid change(node *p, int d) {\n\tif (d == n) return;\n\tpd(p);\n\tswap(p->ch[0], p->ch[1]);\n\tswap(p->ch[0], p->ch[2]);\n\tchange(p->ch[0], d + 1);\n}\n\nvoid cal(node *p, int d, int cur) {\n\tif (d == n) {\n\t\tans[p->id] = cur;\n\t\treturn;\n\t}\n\tpd(p);\n\tcal(p->ch[0], d + 1, cur);\n\tcal(p->ch[1], d + 1, cur + powd[d]);\n\tcal(p->ch[2], d + 1, cur + powd[d] + powd[d]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int LL;\n\nstruct Solver{\n    int N;\n    Solver* s[3];\n    int pos[3];\n    bool lazy_salsa;\n    \n    \n    Solver(int N): N(N){\n        assert(N > 0);\n        if(N > 1){\n            for(int i=0; i<3; i++) s[i] = new Solver(N-1);\n        }\n        for(int i=0; i<3; i++) pos[i] = i;\n        lazy_salsa = false;\n    }\n    \n    void salsa(){\n        lazy_salsa = not lazy_salsa;\n    }\n    \n    void perform_salsa(){\n        for(int i=0; i<3; i++) pos[i] = (2*pos[i]) % 3;\n        if(N > 1) for(int i=0; i<3; i++) s[i]->salsa();\n    }\n    \n    void rumba(){\n        if(lazy_salsa) perform_salsa();\n        lazy_salsa = false;\n        \n        for(int i=0; i<3; i++){\n            if(pos[i] == 2 and N > 1) s[i]->rumba();\n            pos[i] = (pos[i] + 1) % 3;\n        }\n    }\n    \n    int get(int x){\n        if(lazy_salsa) perform_salsa();\n        lazy_salsa = false;\n        if(N == 1) return pos[x];\n        else return pos[x%3] + 3 * s[x%3]->get(x/3);\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int N;\n    cin >> N;\n    string T;\n    cin >> T;\n    \n    Solver s(N);\n    for(char c:T){\n        if(c == 'S') s.salsa();\n        else s.rumba();\n    }\n    \n    int num = 1;\n    for(int i=0; i<N; i++) num *= 3;\n    \n    for(int i=0; i<num; i++) cout << s.get(i) << ' ';\n    cout << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n \nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n\n#define MOD 1000000007LL\n\nint N;\nstring T;\nvector<int> p;\n//map<int, int> sa;\nvector<int> sa;\nint tn;\nint os=0;\n\nint tri(int n) {\n  int ans=1;\n  for (int i=0; i<n; i++) ans *= 3;\n  return ans;\n}\n\nvoid salsa();\nvoid rumba();\nvoid print_ln();\n\nint main()\n{\n  int l;\n  int i;\n\n  cin >> N >> T;\n  tn = tri(N);\n\n  p.resize(tn);\n  sa.resize(tn);\n  for (int i=0; i<tn; i++) {\n    p[i] = i;\n  }\n  sa[0] = 0; sa[1] = 2; sa[2]=1;\n  {\n    int t=3;\n    int cv;\n    for (int i=3; i<tn; i++) {\n      if (i>=t*3) t *= 3;\n      cv = sa[i%t];\n      switch(i/t) {\n      case 1: cv += t*2; break;\n      case 2: cv += t; break;\n      }\n      sa[i] = cv;\n    }\n  }\n\n//for (int i=0; i<tn; i++) printf(\"sa[%d]=%d\\n\", i, sa[i]);\n\n//print_ln();\n\n  l = T.size();\n  for (i=0; i<l; i++) {\n    if (T[i] == 'S') {\n      if (T[i+1] == 'S') {\n        i++;\n        continue;\n      }\n      salsa();\n//printf(\"S \");\n//print_ln();\n    } else {\n      os++;\n      os%=tn;\n//      rumba();\n//printf(\"R \");\n//print_ln();\n    }\n  }\n\n  print_ln();\n\n  return 0;\n}\n\nvoid salsa() {\n  int i;\n\n  for (i=0; i<tn; i++) {\n    p[i] = sa[(p[i]+os)%tn];\n  }\n  os = 0;\n}\nvoid rumba() {\n  int i;\n  for (i=0; i<tn; i++) {\n    p[i]++;\n    p[i]%=tn;\n  }\n}\n\nvoid print_ln() {\n  int i;\n  printf(\"%d\", (p[0]+os)%tn);\n  for (i=1; i<tn; i++) printf(\" %d\", (p[i]+os)%tn);\n  printf(\"\\n\");\n}\n/*\n  a*3^3+b*3^2+c*3+d\n  */\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define Fast_IO ios::sync_with_stdio(false);\n#define DEBUG fprintf(stderr,\"Running on Line %d in Function %s\\n\",__LINE__,__FUNCTION__)\n//mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n#define fir first\n#define sec second\n#define mod 998244353\n#define ll long long\n#define inf 0x3f3f3f3f\n#define INF 0x3f3f3f3f3f3f3f3f\ninline int read()\n{\n\tchar ch=getchar(); int nega=1; while(!isdigit(ch)) {if(ch=='-') nega=-1; ch=getchar();}\n\tint ans=0; while(isdigit(ch)) {ans=ans*10+ch-48;ch=getchar();}\n\tif(nega==-1) return -ans;\n\treturn ans;\n}\ntypedef pair<int,int> pii;\ninline int min(int x,int y,int z){return min(x,min(y,z));}\ninline int max(int x,int y,int z){return max(x,max(y,z));}\ninline int add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\ninline int add(int x,int y,int z){return add(add(x,y),z);}\ninline int sub(int x,int y){return x-y<0?x-y+mod:x-y;}\ninline int mul(int x,int y){return 1LL*x*y%mod;}\ninline int mul(int x,int y,int z){return mul(mul(x,y),z);}\n#define N 200005\nint a[N],t[15][N];\nchar s[N];\nint id[N],n;\nvoid upd(int &x)\n{\n\tif(x==1) x=2;\n\telse if(x==2) x=1;\n}\nsigned main()\n{\n\tcin>>n;\n\tscanf(\"%s\",s+1);\n\tint m=strlen(s+1);\n\tint cur=1;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcur*=3;\n\t\tfor(int j=0;j<cur;j++)\n\t\t{\n\t\t\tint x=j;\n\t\t\tfor(int k=0;k<i;k++) x/=3;\n\t\t\ta[j]=x;\n\t\t}\n\t\tbool op=0;\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tif(s[j]=='S') op^=1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint u=id[j],tmp=0;\n\t\t\t\tfor(int k=0;k<3;k++)\n\t\t\t\t{\n\t\t\t\t\tint v=k*(cur/3)+u;\n\t\t\t\t\tif(op) upd(a[v]);\n\t\t\t\t\tif(a[v]==2) tmp=k,a[v]=0;\n\t\t\t\t\telse a[v]++;\n\t\t\t\t\tif(op) upd(a[v]);\n\t\t\t\t}\n\t\t\t\tid[j]+=tmp*(cur/3);\n\t\t\t}\n\t\t}\n\t\tif(op) for(int j=0;j<cur;j++) upd(a[j]);\n\t\tfor(int j=0;j<cur;j++) t[i][j]=a[j];\n\t\t// for(int j=1;j<=cur;j++) printf(\"%d \",t[i][j]);\n\t\t// cout<<\"\\n\";\n\t}\n\tfor(int i=0;i<cur;i++)\n\t{\n\t\tint ans=0,tmp=1;\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\ttmp*=3;\n\t\t\tans+=t[j][i%tmp]*(tmp/3);\n\t\t}\n\t\tprintf(\"%d \",ans);\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint po3(int e){\n    int ret = 1;\n    for(int i = 0; i<e; i++){\n        ret *= 3;\n    }\n\n    return ret;\n}\n\nint conjug(int x){\n    int mult = 1;\n    int ret = 0;\n\n    while(x){\n        int t = x % 3;\n        if(t == 1) ret += mult * 2;\n        if(t == 2) ret += mult;\n\n        x /= 3;\n        mult *= 3;\n    }\n\n    return ret;\n}\n\nstruct EndingSet{\n    int ending;\n    vector<int> nums;\n};\n\nint main(){\n    int n;\n    cin >> n;\n\n    string T;\n    cin >> T;\n\n    int e = po3((n + 1) / 2);\n    int b = po3(n) / e;\n\n    EndingSet a[e];\n    int con[b*e];\n    for(int i = 0; i<b*e; i++){\n        con[i] = conjug(i);\n    }\n    for(int i = 0; i<e; i++){\n        a[i].ending = i;\n        for(int j = 0; j<b; j++){\n            a[i].nums.push_back(i + j*e);\n        }\n    }\n\n    int beg[b], ids[b*e], ans[b*e];\n    for(int i = 0; i<b; i++){\n        beg[i] = i;\n    }\n\n    for(int i = 0; i<b*e; i++){\n        ids[i] = i / e;\n    }\n\n    for(int i = 0; i<T.size(); i++){\n        if(T[i] == 'S'){\n            for(int j = 0; j<e; j++){\n                a[j].ending = con[a[j].ending];\n            }\n\n            for(int j = 0; j<b; j++){\n                beg[j] = con[beg[j]];\n            }\n        }\n\n        if(T[i] == 'R'){\n            int pos;\n            for(int j = 0; j<e; j++){\n                if(a[j].ending == e - 1) pos = j;\n            }\n\n            int inv[b];\n            for(int i = 0; i<b; i++){\n                inv[beg[i]] = i;\n            }\n\n            for(int x: a[pos].nums){\n                if(beg[ids[x]] < b - 1) ids[x] = inv[beg[ids[x]] + 1];\n                else ids[x] = inv[0];\n            }\n\n            for(int j = 0; j<e; j++){\n                if(a[j].ending < e - 1) a[j].ending++;\n                else a[j].ending = 0;\n            }\n        }\n\n\n    }\n\n    int inv[b*e];\n\n        for(int j = 0; j<e; j++){\n            int x = a[j].ending;\n\n            for(int y: a[j].nums){\n                ans[x + beg[ids[y]] * e] = y;\n                inv[y] = x + beg[ids[y]] * e;\n            }\n        }\n\n        for(int j = 0; j<b*e; j++){\n            cout << inv[j] << \" \";\n        }\n\n        cout << endl;\n\n    /*\n    for(int i = 0; i<e; i++){\n        int x = a[i].ending;\n\n        for(int y: a[i].nums){\n            ans[y] = x;\n        }\n    }\n\n    for(int i = 0; i<b*e; i++){\n        ans[i] += beg[ids[i]] * e;\n    }\n\n    for(int i = 0; i<b*e; i++){\n        cout << ans[i] << \" \";\n    }\n    */\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\nint a[1000005];\nint p[1000005]={0};\nint vis[1000005]={0};\nint ans[1000005];\nvoid pre(int m){\n\ta[0]=0;\n\tfor(int i=1;i<=m;i++){\n\t\tp[i]=i;\n\t\tif(a[i]>0){\n\t\t\tcontinue;\n\t\t}\n\t\tint tempi=i;\n\t\tint bei=1;\n\t\tint tempj=0;\n\t\twhile(tempi>0){\n\t\t\tif(tempi%3!=0){\n\t\t\t\ttempj+=(3-tempi%3)*bei;\n\t\t\t}\n\t\t\ttempi/=3;\n\t\t\tbei*=3;\n\t\t}\n\t\ta[i]=tempj;\n\t\ta[tempj]=i;\n\t}\n\treturn;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin>>n;\n\tint nn=1;\n\tfor(int i=1;i<=n;i++){\n\t\tnn*=3;\n\t}\n\tpre(nn-1);\n\tstring t;\n\tcin>>t;\n\tint rem=0;\n\tint sum=1;\n\tint len=t.size();\n\tt.push_back('v');\n\tint temp=1;\n\tfor(int i=0;i<len;i++){\n\t\tif(t[i]==t[i+1]){\n\t\t\ttemp++;\n\t\t}\n\t\telse {\n\t\t\tif(t[i]=='S'){\n\t\t\t\tif(temp%2==1){\n\t\t\t\t\tmemset(vis,0,sizeof(vis));\n//\t\t\t\t\tcout<<\":\"<<rem<<endl;\n\t\t\t\t\tfor(int j=0;j<nn;j++){\n\t\t\t\t\t\tint x=(j+nn-rem)%nn;\n\t\t\t\t\t\tint y=(a[j]+nn-rem)%nn;\n\t\t\t\t\t\tif(vis[x]==1){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswap(p[x],p[y]);\n\t\t\t\t\t\tvis[x]=vis[y]=1;\n//\t\t\t\t\t\tcout<<j<<\" \"<<x<<\" \"<<y<<endl;\n\t\t\t\t\t}\n//\t\t\t\t\tcout<<endl;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\trem=(rem+temp)%nn;\n\t\t\t}\n\t\t\ttemp=1;\n\t\t}\n\t\t\n//\t\tfor(int k=0;k<nn;k++){\n//\t\tif(k>0){\n//\t\t\tcout<<\" \";\n//\t\t}\n//\t\tcout<<p[(k+nn-rem)%nn];\n//\t}\n//\tcout<<endl;\n\t\n\t}\n\tfor(int i=0;i<nn;i++){\n\t\tans[p[(i+nn-rem)%nn]]=i;\n\t}\n\tfor(int i=0;i<nn;i++){\n\t\tif(i>0){\n\t\t\tcout<<\" \";\n\t\t}\n\t\tcout<<ans[i];\n\t}\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n// #include <ext/pb_ds/assoc_container.hpp> \n// #include <ext/pb_ds/detail/standard_policies.hpp>\n// using namespace __gnu_pbds;\n\n#pragma GCC optimize(\"O3\")\n#ifdef LOCAL\n#include \"/Users/lbjlc/Desktop/coding/debug_utils.h\"\n#else\n#define print(...) ;\n#define printn(...) ;\n#define fprint(...) ;\n#define fprintn(...) ;\n#endif\n\n#define rep(i, a, b) for(auto i = (a); i < (b); i++)\n#define rrep(i, a, b) for(auto i = (a); i > (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define pb push_back\n// #define mp make_pair\n#define fi first\n#define se second\n#define maxi(x, y) x = max(x, y)\n#define mini(x, y) x = min(x, y)\n// long long fact(long long n) { if(!n) return 1; return n*fact(n-1); }\n// #define endl '\\n'\n#define solve_testcase int T;cin>>T;for(int t=1;t<=T;t++){solve(t);}\n\n// long long gcd(long long x, long long y) { return y ? gcd(y, x % y) : x; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\n \ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n \ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\ntypedef vector<long long> vll;\n#define bd(type,op,val) bind(op<type>(), std::placeholders::_1, val)\n\nconst int MAXN = 1e6+10;\n\n\nvoid solve(int tt) {\n    // cout<<\"Case #\"<<tt<<\": \";\n}\n\nstring to_ter(int x, int k=-1) {\n    string res;\n    while(x) {\n        res+='0'+x%3;\n        x/=3;\n    }\n    if(k>=0) {\n        while(res.size()<k) res+='0';\n    }\n    return res;\n}\nint to_int(const string & s) {\n    int res=0;\n    // rrep(i,s.size()-1,-1)\n    //     res=res*3+(s[i]-'0');\n    for(int i=s.size()-1;i>=0;i--)\n        res=res*3+(s[i]-'0');\n    // print(s,res);\n    return res;\n}\nbool add(string & x, const string & y) {\n    int n1=x.size(), n2=y.size(),carry=0;\n    rep(i,0,n1) {\n        if(i<n1) carry+=x[i]-'0';\n        if(i<n2) carry+=y[i]-'0';\n        x[i]=carry%3+'0';\n        carry/=3;\n    }\n    return carry==0;\n}\n\nvi cal_inst(string & s) {\n    int n=s.size();\n    vi res(1);\n    int i=0;\n    while(i<n) {\n        if(s[i]=='R') {\n            res.back()++;\n            i++;\n        }\n        else {\n            int j=i;\n            for(;j<n&&s[j]=='S';j++);\n            if((j-i)%2) res.pb(0);\n            i=j;\n        }\n    }\n    if(s.back()=='S') res.pop_back();\n    return res;\n}\n\nchar rev(char c) {\n    if(c>'0') return '0'+(3-(c-'0'));\n    return c;\n}\nstring rev(string s) {\n    for(auto & c:s) c=rev(c);\n    return s;\n}\n\nint len(string & s) {\n    int res=s.size();\n    while(res>0&&s[res-1]=='0') res--;\n    return res;\n}\n\nvi cal(vi inst, int n, int tot) {\n    vi res(tot);\n    map<string, string> dp,dp1;\n    rep(i,0,tot) {\n        string cur=to_ter(i,n);\n        rep(j,0,n) {\n            string cur1=cur.substr(0,j+1)+string(n-j-1,'0');\n            if(dp1.count(cur1)&&len(dp1[cur1])<=j+1) {\n                cur1=dp1[cur1];\n                if(inst.size()%2) {\n                    rep(jj,j+1,n) cur1[jj]=rev(cur[jj]);\n                }\n                dp[cur]=cur1;\n                dp1[cur]=cur1;\n                break;\n            }\n        }\n        if(!dp.count(cur)) {\n            string cur1=cur;\n            bool ok=true;\n            for(auto x:inst) {\n                // print(cur1,to_ter(x,n));\n                ok=add(cur1,to_ter(x,n))&&ok;\n                // print(cur1,to_ter(x,n));\n                for(auto & c:cur1) c=rev(c);\n            }\n            dp[cur]=cur1;\n            if(ok) dp1[cur]=cur1;\n            // print(cur,cur1);\n        }\n        res[i]=to_int(dp[cur]);\n        print(i,cur,res[i],dp[cur]);\n        // print(res[i],dp[cur]);  \n    }\n    print(inst,res);\n    print(dp);\n    print(dp1);\n    return res;\n}\n\nint main(int argc, char * argv[]) {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    // solve_testcase;\n\n    int n;\n    string s;\n    cin>>n;\n    cin>>s;\n    int tot=1;\n    rep(i,0,n) tot*=3;\n\n    vi inst=cal_inst(s);\n    for(auto & x:inst) x%=tot;\n\n    print(inst);\n\n    int i=0;\n    int bound=3*3*3*3*3*3;\n    vi res(tot);\n    iota(all(res),0);\n    while(i<inst.size()) {\n        int cur=inst[i];\n        vi cur_inst({cur});\n        for(++i;i<inst.size()&&cur+inst[i]<bound;i++) {\n            cur+=inst[i];\n            cur_inst.pb(cur);\n        }\n        vi tmp=cal(inst,n,tot);\n        // print(tmp);\n        rep(j,0,tot) res[j]=tmp[res[j]];\n        print(res);\n    }\n    if(s.back()=='R') {\n        rep(i,0,tot) {\n            res[i]=to_int(rev(to_ter(res[i],n)));\n        }\n    }\n    for(auto x:res) cout<<x<<' ';\n    cout<<endl;\n\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\nint m;\nusing namespace std;\nstring T;\nvector<int> solve_(vector<int>&p,vector<int>&w,int n){\n   if(!n){return(w);}\n   w=solve_(p,w,n-1);\n   vector<int> temp(pow(3,n-1),0);\n   int z=1;\n   while(z<3){\n       for(int i=0;i<pow(3,n-1);i++) temp.push_back(z);\n       z++;}\n    //    cout<<\"j \"<<T.size();\n    int k=0;\n    int limit=3;\n    vector<int> new_w;\n    // cout<<\"\\n -----\"; for(auto i=w.begin();i!=w.end();i++) cout<<*i<<\" \"; cout<<\"----\\n\";\n    // cout<<\"-----\"; for(auto i=temp.begin();i!=temp.end();i++) cout<<*i<<\" \"; cout<<\"----\\n\";\n    for(int i=0;i<T.size();i++){\n        if(T[i]=='S'){\n        for(int j=0;j<temp.size();j++){\n            if(temp[j]==1) temp[j]=2;\n            else if(temp[j]==2) temp[j]=1;}}\n        else if(T[i]=='R'){\n            if(n==1) {w.push_back(0); }\n            if(temp[w[k]]==2) new_w.push_back(w[k]);\n            if(temp[w[k]+pow(3,n-1)]==2) new_w.push_back(w[k]+pow(3,n-1));\n            if(temp[w[k]+2*pow(3,n-1)]==2) new_w.push_back(w[k]+2*pow(3,n-1));\n            temp[w[k]]=(temp[w[k]]+1)%limit;\n            temp[w[k]+pow(3,n-1)]=(temp[w[k]+pow(3,n-1)]+1)%limit;\n            temp[w[k]+2*pow(3,n-1)]=(temp[w[k]+2*pow(3,n-1)]+1)%limit;\n            k++;\n        } }\n    w.clear();\n    if(n!=1){\n    for(int i=0;i<pow(3,n-1);i++) {\n        p[i+pow(3,n-1)]=pow(3,n-1)*temp[i+pow(3,n-1)]+p[i];\n        p[i+2*pow(3,n-1)]=pow(3,n-1)*temp[i+2*pow(3,n-1)]+p[i];\n        p[i]+=pow(3,n-1)*temp[i];\n    }}\n    else p=temp;\n    if(n==m)for(auto i=0;i<(int)pow(3,n);i++) cout<<p[i]<<\" \"; \n    return(new_w);    \n}\nint main(){\n    int N; cin>>N; m=N;\n     cin>>T;\n     int si=pow(3,N);\n    vector<int> p(pow(3,N),0); vector<int> w;\n    solve_(p,w,N);\n    return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=200005,M=800;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint n,m,L,R,po[15],pos[M*M];\nchar ch[N];\nint g[M],cur[M],a[M][M],b[M];\nint get(int x){\n\tint y=0,t;\n\tfor (int i=0;i<R;i++){\n\t\tt=x/po[i]%3;\n\t\tt=(t) ? (3-t) : t;\n\t\ty+=po[i]*t;\n\t}\n\treturn y;\n}\nvoid salsa(int *a,int L){\n\tfor (int i=0;i<po[L];i++)\n\tif (i<g[i]) swap(a[i],a[g[i]]);\n}\nvoid add(int *a,int L){\n\tint t=a[po[L]-1];\n\tfor (int i=po[L]-2;i>=0;i--) a[i+1]=a[i];\n\ta[0]=t;\n}\nint main(){\n\tn=read();L=n/2;R=n-L;\n\tscanf(\" %s\",ch+1);\n\tm=strlen(ch+1);\n\tpo[0]=1;\n\tfor (int i=1;i<=n;i++) po[i]=po[i-1]*3;\n\tfor (int i=0;i<po[L];i++)\n\tfor (int j=0;j<po[R];j++) a[i][j]=i*po[R]+j;\n\tfor (int i=0;i<po[L];i++) b[i]=i;\n\tfor (int i=0;i<po[R];i++) g[i]=get(i),cur[i]=i;\n\tfor (int i=1;i<=m;i++)\n\tif (ch[i]=='S'){\n\t\tsalsa(b,L);\n\t\tsalsa(cur,R);\n\t}\n\telse{\n\t\tadd(cur,R);\n\t\tint t=a[b[po[L]-1]][cur[0]];\n\t\tfor (int i=po[L]-2;i>=0;i--) a[b[i+1]][cur[0]]=a[b[i]][cur[0]];\n\t\ta[b[0]][cur[0]]=t;\n\t}\n\tfor (int i=0;i<po[L];i++)\n\tfor (int j=0;j<po[R];j++) pos[a[b[i]][cur[j]]]=i*po[R]+j;\n\tfor (int i=0;i<po[n];i++) printf(\"%d \",pos[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5 + 10;\nint n, len, tot = 1; \nchar ch[N]; \nstruct node {\n\tint sp, ch[3], ed;\n} c[N * 10]; int cnt = 1;\ninline void insert (int x) {\n\tint now = 1, tmp = x;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint m = x % 3; x /= 3;\n\t\tif (!c[now].ch[m]) c[now].ch[m] = ++cnt;\n\t\tnow = c[now].ch[m];\n\t} c[now].ed = tmp;\n}\ninline void add () {\n\tint now = 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (c[now].sp) {\n\t\t\tswap (c[now].ch[1], c[now].ch[2]); c[now].sp = 0;\n\t\t\tfor (int j = 0; j < 3; ++j) c[c[now].ch[j]].sp ^= 1;\n\t\t} int t = c[now].ch[2]; \n\t\tc[now].ch[2] = c[now].ch[1], c[now].ch[1] = c[now].ch[0];\n\t\tc[now].ch[0] = t, now = t;\n\t}\n} int res[N * 10];\nvoid dfs (int now, int dp, int g, int s) {\n\tif (c[now].sp) {\n\t\tswap (c[now].ch[1], c[now].ch[2]); c[now].sp = 0;\n\t\tfor (int i = 0; i < 3; ++i) c[c[now].ch[i]].sp ^= 1;\n\t} if (dp == n) { res[c[now].ed] = s; return; }\n\tfor (int i = 0; i < 3; ++i) dfs (c[now].ch[i], dp + 1, g * 3, s + g * i);\n}\nsigned main() {\n\tscanf (\"%d %s\", &n, ch + 1);\n\tlen = strlen (ch + 1);\n\tfor (int i = 1; i <= n; ++i) tot *= 3;\n\tfor (int i = 0; i < tot; ++i) insert (i);\n\tfor (int i = 1; i <= len; ++i)\n\t\tif (ch[i] == 'S') c[1].sp ^= 1; else add ();\n\tdfs (1, 0, 1, 0);\n\tfor (int i = 0; i < tot; ++i) printf (\"%d \", res[i]);\n\treturn puts (\"\"), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long pow(long long a, long long n) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a;\n        a = a * a;\n        n >>= 1;\n    }\n    return res;\n}\n\nlong long conv(long long x) {\n  vector<int> s;\n  while (x != 0) {\n    int y = x % 3;\n    s.push_back(y);\n    x /= 3;\n  }\n\n  int n = s.size();\n  long long res = 0;\n  for (int i = n - 1; i >= 0; --i) {\n    if (s[i] == 2) {\n      res += pow(3, i);\n    } else if (s[i] == 1) {\n      res += 2LL * pow(3, i);\n    }\n  }\n  return res;\n}\n\nvoid printV(vector<long long>& p, long long MOD) {\n  for (long long i = 0; i < MOD; ++i) {\n    if (i != 0) {\n      cout << \" \";\n    }\n    cout << p[i];\n  }\n  cout << endl;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  string t;\n  cin >> t;\n\n  long long MOD = pow(3, n);\n  vector<long long> p(MOD);\n  for (long long i = 0; i < MOD; ++i) {\n    p[i] = i;\n  }\n  vector<long long> tmp(MOD);\n  long long tS = t.size();\n  for (long long i = 0; i < tS; ++i) {\n    if (t[i] == 'S') {\n      for (long long j = 0; j < MOD; ++j) {\n        long long x = conv(p[j]);\n        tmp[j] = x;\n      }\n    } else {\n      for (long long j = 0; j < MOD; ++j) {\n        tmp[j] = p[(j - 1 + MOD) % MOD];\n      }\n    }\n    p = tmp;\n  }\n\n  printV(p, MOD);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n// #include <ext/pb_ds/assoc_container.hpp> \n// #include <ext/pb_ds/detail/standard_policies.hpp>\n// using namespace __gnu_pbds;\n\n#pragma GCC optimize(\"O3\")\n#ifdef LOCAL\n#include \"/Users/lbjlc/Desktop/coding/debug_utils.h\"\n#else\n#define print(...) ;\n#define printn(...) ;\n#define fprint(...) ;\n#define fprintn(...) ;\n#endif\n\n#define rep(i, a, b) for(auto i = (a); i < (b); i++)\n#define rrep(i, a, b) for(auto i = (a); i > (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define pb push_back\n// #define mp make_pair\n#define fi first\n#define se second\n#define maxi(x, y) x = max(x, y)\n#define mini(x, y) x = min(x, y)\n// long long fact(long long n) { if(!n) return 1; return n*fact(n-1); }\n// #define endl '\\n'\n#define solve_testcase int T;cin>>T;for(int t=1;t<=T;t++){solve(t);}\n\n// long long gcd(long long x, long long y) { return y ? gcd(y, x % y) : x; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\n \ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n \ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\ntypedef vector<long long> vll;\n#define bd(type,op,val) bind(op<type>(), std::placeholders::_1, val)\n\nconst int MAXN = 1e6+10;\n\n\nvoid solve(int tt) {\n    // cout<<\"Case #\"<<tt<<\": \";\n}\n\nstring to_ter(int x, int k=-1) {\n    string res;\n    while(x) {\n        res+='0'+x%3;\n        x/=3;\n    }\n    if(k>=0) {\n        while(res.size()<k) res+='0';\n    }\n    return res;\n}\nint to_int(const string & s) {\n    int res=0;\n    // rrep(i,s.size()-1,-1)\n    //     res=res*3+(s[i]-'0');\n    for(int i=s.size()-1;i>=0;i--)\n        res=res*3+(s[i]-'0');\n    // print(s,res);\n    return res;\n}\nbool add(string & x, const string & y) {\n    int n1=x.size(), n2=y.size(),carry=0;\n    rep(i,0,n1) {\n        if(i<n1) carry+=x[i]-'0';\n        if(i<n2) carry+=y[i]-'0';\n        x[i]=carry%3+'0';\n        carry/=3;\n    }\n    return carry==0;\n}\n\nvi cal_inst(string & s) {\n    int n=s.size();\n    vi res(1);\n    int i=0;\n    while(i<n) {\n        if(s[i]=='R') {\n            res.back()++;\n            i++;\n        }\n        else {\n            int j=i;\n            for(;j<n&&s[j]=='S';j++);\n            if((j-i)%2) res.pb(0);\n            i=j;\n        }\n    }\n    if(s.back()=='S') res.pop_back();\n    return res;\n}\n\nchar rev(char c) {\n    if(c>'0') return '0'+(3-(c-'0'));\n    return c;\n}\nstring rev(string s) {\n    for(auto & c:s) c=rev(c);\n    return s;\n}\n\nint len(string & s) {\n    int res=s.size();\n    while(res>0&&s[res-1]=='0') res--;\n    return res;\n}\n\nvi cal(vi inst, int n, int tot) {\n    vi res(tot);\n    map<string, string> dp,dp1;\n    rep(i,0,tot) {\n        string cur=to_ter(i,n);\n        rep(j,0,n) {\n            string cur1=cur.substr(0,j+1)+string(n-j-1,'0');\n            if(dp1.count(cur1)&&len(dp1[cur1])<=j+1) {\n                cur1=dp1[cur1];\n                if(inst.size()%2) {\n                    rep(jj,j+1,n) cur1[jj]=rev(cur[jj]);\n                }\n                dp[cur]=cur1;\n                dp1[cur]=cur1;\n                break;\n            }\n        }\n        if(!dp.count(cur)) {\n            string cur1=cur;\n            bool ok=true;\n            for(auto x:inst) {\n                // print(cur1,to_ter(x,n));\n                ok=add(cur1,to_ter(x,n))&&ok;\n                // print(cur1,to_ter(x,n));\n                for(auto & c:cur1) c=rev(c);\n            }\n            dp[cur]=cur1;\n            if(ok) dp1[cur]=cur1;\n            // print(cur,cur1);\n        }\n        res[i]=to_int(dp[cur]);\n        print(i,cur,res[i],dp[cur]);\n        // print(res[i],dp[cur]);  \n    }\n    print(inst,res);\n    print(dp);\n    print(dp1);\n    return res;\n}\n\nint main(int argc, char * argv[]) {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    // solve_testcase;\n\n    int n;\n    string s;\n    cin>>n;\n    cin>>s;\n    int tot=1;\n    rep(i,0,n) tot*=3;\n\n    vi inst=cal_inst(s);\n    for(auto & x:inst) x%=tot;\n\n    print(inst);\n\n    int i=0;\n    int bound=3*3*3*3*3;\n    vi res(tot);\n    iota(all(res),0);\n    while(i<inst.size()) {\n        int cur=inst[i];\n        vi cur_inst({cur});\n        for(++i;i<inst.size()&&cur+inst[i]<bound;i++) {\n            cur+=inst[i];\n            cur_inst.pb(cur);\n        }\n        vi tmp=cal(inst,n,tot);\n        // print(tmp);\n        rep(j,0,tot) res[j]=tmp[res[j]];\n        print(res);\n    }\n    if(s.back()=='R') {\n        rep(i,0,tot) {\n            res[i]=to_int(rev(to_ter(res[i],n)));\n        }\n    }\n    for(auto x:res) cout<<x<<' ';\n    cout<<endl;\n\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define repn(i,n) for(int i=1;i<=n;i++)\n#define LL long long\n#define pii pair <int,int>\n#define fi first\n#define se second\n#define pb push_back\n#define mpr make_pair\n\nusing namespace std;\n\nconst LL MOD=1e9+7;\n\nint len=0;\n\nstruct node\n{\n\tint val,s0,s1,s2,delta;\t\n}a[2000000];\n\nint n,ans[2000000];\nstring s;\n\nvoid pushdown(int pos)\n{\n\tif(a[pos].delta==0) return;\n\ta[pos].delta=0;\n\ta[a[pos].s0].delta^=1;\n\tswap(a[a[pos].s0].s1,a[a[pos].s0].s2);\n\ta[a[pos].s1].delta^=1;\n\tswap(a[a[pos].s1].s1,a[a[pos].s1].s2);\n\ta[a[pos].s2].delta^=1;\n\tswap(a[a[pos].s2].s1,a[a[pos].s2].s2);\n}\n\nint build(int lev,int cur)\n{\n\tint pos=++len;\n\tif(lev==n)\n\t{\n\t\ta[pos].val=cur;\n\t\ta[pos].s0=a[pos].s1=a[pos].s2=a[pos].delta=0;\n\t\treturn pos;\n\t}\n\ta[pos].val=a[pos].delta=0;\n\ta[pos].s0=build(lev+1,cur);\n\ta[pos].s1=build(lev+1,cur+pow(3,lev));\n\ta[pos].s2=build(lev+1,cur+pow(3,lev)*2);\n\treturn pos;\n}\n\nvoid Rot(int pos)\n{\n\tif(pos==0) return;\n\tpushdown(pos);\n\tint tmp=a[pos].s0;\n\ta[pos].s0=a[pos].s2;\n\ta[pos].s2=a[pos].s1;\n\ta[pos].s1=tmp;\n\tRot(a[pos].s0);\n}\n\nvoid Swp()\n{\n\ta[1].delta^=1;\n\tswap(a[1].s1,a[1].s2);\n}\n\nvoid getans(int pos,int lev,int cur)\n{\n\tif(lev==n)\n\t{\n\t\tans[a[pos].val]=cur;\n\t\treturn;\n\t}\n\tpushdown(pos);\n\tgetans(a[pos].s0,lev+1,cur);\n\tgetans(a[pos].s1,lev+1,cur+pow(3,lev));\n\tgetans(a[pos].s2,lev+1,cur+pow(3,lev)*2);\n}\n\nint main()\n{\n\tcin>>n>>s;\n\tbuild(0,0);\n\trep(i,s.size())\n\t{\n\t\tif(s[i]=='R') Rot(1);\n\t\telse Swp();\n\t}\n\tgetans(1,0,0);\n\trep(i,pow(3,n)) cout<<ans[i]<<' ';\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\npair<vector<int>, vector<int> > solve(int n, const string &T) {\n\tif (!n) {\n\t\treturn make_pair(vector<int>(1, 0), vector<int>(T.size(), 0));\n\t}\n\tvector<int> P, W;\n\ttie(P, W) = solve(n - 1, T);\n\tint sz = P.size();\n\tvector<int> nP(3 * sz), nW(T.size()), D(3 * sz), lt(3 * sz, 0);\n\tfor (int i = 0; i < 3; i++) for (int j = 0; j < sz; j++) D[i * sz + j] = i;\n\tint ct = 0;\n\tfunction<void(int)> upd = [&](int i) {\n\t\tif (D[i] && (ct - lt[i]) % 2 == 1) D[i] = 3 - D[i];\n\t\tlt[i] = ct;\n\t};\n\tfor (int i = 0; i < (int)T.size(); i++) {\n\t\tfor (int j = W[i]; j < 3 * sz; j += sz) {\n\t\t\tupd(j);\n\t\t\tif (D[j] == 2) nW[i] = j;\n\t\t}\n\t\tif (T[i] == 'S') ct++;\n\t\telse {\n\t\t\tfor (int j = W[i]; j < 3 * sz; j += sz) {\n\t\t\t\tD[j] = (D[j] + 1) % 3;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 3 * sz; i++) {\n\t\tupd(i);\n\t\tnP[i] = P[i % sz] + D[i] * sz;\n\t}\n\treturn make_pair(nP, nW);\n}\nint main() {\n\tint n;\n\tstring T;\n\tcin >> n >> T;\n\tvector<int> ans = solve(n, T).first;\n\tfor (int x : ans) cout << x << ' ';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX_N = 13, MAX_POW3_N = 531441, MAX_M = 200020;\n\nint N, M, Half, pow3[MAX_N], salsa[MAX_POW3_N], highbits[MAX_POW3_N], Ans[MAX_POW3_N];\n\nchar S[MAX_M];\n\nint main() {\n    scanf(\"%d\", &N); Half = N / 2;\n    scanf(\"%s\", S + 1); M = strlen(S + 1);\n    pow3[0] = 1;\n    for (int i = 1; i <= N; i++) pow3[i] = pow3[i - 1] * 3;\n    for (int i = 0; i < pow3[N]; i++) {\n        int result = 0;\n        for (int j = 0; j < N; j++) {\n            int t = i / pow3[j] % 3;\n            result += (3 - t) % 3 * pow3[j];\n        }\n        salsa[i] = result;\n    }\n    for (int i = 0; i < pow3[Half]; i++) {\n        int lowbits = i;\n        for (int j = 0; j < pow3[N - Half]; j++)\n            highbits[j] = j;\n        bool high_flip = false;\n        for (int j = 1; j <= M; j++) {\n            if (S[j] == 'S') {\n                high_flip ^= true;\n                lowbits = salsa[lowbits];\n            } else {\n                if (++lowbits == pow3[Half]) {\n                    lowbits = 0;\n                    if (high_flip) {\n                        for (int j = 0; j < pow3[N - Half]; j++) {\n                            highbits[j] = salsa[highbits[j]];\n                        }\n                        high_flip = false;\n                    }\n                    for (int j = 0; j < pow3[N - Half]; j++) {\n                        if (++highbits[j] == pow3[N - Half])\n                            highbits[j] = 0;\n                    }\n                }\n            }\n        }\n        if (high_flip) {\n            for (int j = 0; j < pow3[N - Half]; j++) {\n                highbits[j] = salsa[highbits[j]];\n            }\n        }\n        high_flip = false;\n        for (int j = 0; j < pow3[N - Half]; j++){\n            Ans[j * pow3[Half] + i] = highbits[j] * pow3[Half] + lowbits;\n        }\n    }\n    for (int i = 0; i < pow3[N]; i++) printf(\"%d \", Ans[i]);\n    printf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define R register\n#define mp make_pair\n#define ll long long\n#define pii pair<int, int>\n#define pll pair<ll, ll>\nusing namespace std;\nconst int mod = 998244353, N = 1100000;\n\nint n, ch[N][3], to[3], ind[N], pw[15], tot, root, ans[N];\nchar s[N];\n\ninline int addMod(int a, int b) {\n\treturn (a += b) >= mod ? a - mod : a;\n}\n\ninline ll quickpow(ll base, ll pw) {\n\tll ret = 1;\n\twhile (pw) {\n\t\tif (pw & 1) ret = ret * base % mod;\n\t\tbase = base * base % mod, pw >>= 1;\n\t}\n\treturn ret;\n}\n\ntemplate <class T>\ninline void read(T &x) {\n\tx = 0;\n\tchar ch = getchar(), w = 0;\n\twhile (!isdigit(ch)) w = (ch == '-'), ch = getchar();\n\twhile (isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();\n\tx = w ? -x : x;\n\treturn;\n}\n\nvoid build(int &k, int dep, int x) {\n\tk = ++tot;\n\tif (dep == n) {\n\t\tind[k] = x;\n\t\treturn;\n\t}\n\tfor (R int i = 0; i <= 2; ++i)\n\t\tbuild(ch[k][i], dep + 1, x + i * pw[dep]);\n\treturn;\n}\n\nvoid modify(int k, int dep) {\n\tif (dep == n) return;\n\tmodify(ch[k][to[2]], dep + 1);\n\tint tmp = ch[k][to[0]];\n\tch[k][to[0]] = ch[k][to[2]], ch[k][to[2]] = ch[k][to[1]], ch[k][to[1]] = tmp;\n\treturn;\n}\n\nvoid dfs(int k, int dep, int x) {\n\tif (dep == n) {\n\t\tans[ind[k]] = x;\n\t\treturn;\n\t}\n\tfor (R int i = 0; i <= 2; ++i)\n\t\tdfs(ch[k][to[i]], dep + 1, x + i * pw[dep]);\n\treturn;\n}\n\nint main() {\n\tread(n), scanf(\"%s\", s + 1);\n\tpw[0] = 1, to[1] = 1, to[2] = 2;\n\tfor (R int i = 1; i <= n; ++i) pw[i] = pw[i - 1] * 3;\n\tbuild(root, 0, 0);\n\tfor (R int i = 1, m = strlen(s + 1); i <= m; ++i) {\n\t\tif (s[i] == 'S')\n\t\t\tswap(to[1], to[2]);\n\t\telse\n\t\t\tmodify(root, 0);\n\t}\n\tdfs(root, 0, 0);\n\tfor (R int i = 0; i < pw[n]; ++i)\n\t\tcout << ans[i] << ' ';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx,avx2,fma\")\n#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\")\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nclass CStrangeDance {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n; cin >> n;\n      string t; cin >> t;\n\n      // initialize vector size\n      vector<vector<vector<int>>> v(3, vector<vector<int>>(n));\n      int k = 1;\n      rep(i, n) {\n        rep(j, 3) {\n          v[j][i].resize(k);\n        }\n        k *= 3;\n      }\n      int K = k;\n\n      // initialize vector\n      rep(i, n) {\n        int idx = 0;\n        rep(j, 3) {\n          for(auto& e: v[j][i]) {\n            e = idx;\n            idx++;\n          }\n        }\n      }\n\n      for(auto c: t) {\n        if (c=='S') {\n          // swap vector\n          swap(v[1], v[2]);\n        } else {\n          // swap by point\n          int w = 0;\n          rep(i, n) {\n            auto v0 = v[0][i][w];\n            auto v1 = v[1][i][w];\n            auto v2 = v[2][i][w];\n            v[1][i][w] = v0;\n            v[2][i][w] = v1;\n            v[0][i][w] = v2;\n            w = v2;\n          }\n        }\n      }\n\n      // recover\n      vector<int> ans(K);\n      k = 1;\n      rep(i, n) {\n        for(int j=1; j<=2; j++) {\n          for(auto e: v[j][i]) {\n            for(int idx=e; idx<K; idx+=(k*3)) {\n              ans[idx] += j*k;\n            }\n          }\n        }\n        k *= 3;\n      }\n\n      for(auto e: ans) {\n        cout << e << ' ';\n      }\n    }\n};\n\nsigned main() {\n  CStrangeDance solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,x,y,sw,pw3=1,A[531441],B[531441],S[200001];\nchar T[200001];\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nsigned main(void)\n{\n  x=scanf(\"%d %s\",&N,T);\n  replace(T,\"SS\",\"\");\n  if(T[0]=='\\n')return 0;\n  rep(i,N)\n  {\n    sw=1;\n    rep(j,pw3)rep(k,3)B[j+k*pw3]=k;\n    rep(p,strlen(T))\n    {\n      if(T[p]=='R')\n      {\n        y=S[p];\n        rep(j,3){x=y+j*pw3;if(B[x]*sw==-1||B[x]*sw==2)S[p]=x;(B[x]+=(sw>0?1:2))%=3;}\n      }\n      else sw=-sw;\n    }\n    rep(j,pw3){y=A[j];rep(k,3){x=j+k*pw3;A[x]=y+((sw<0)?3-B[x]:B[x])%3*pw3;}}\n    pw3*=3;\n  }\n  rep(i,pw3)printf(\"%d%c\",A[i],i+1==pw3?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid salsa(vector<int> &ans){\n  for(int i=0;i<(int)ans.size();i++){\n    int a = ans.at(i);\n    int j=0;\n    while(a > 3){\n      if(a%3 == 1){\n        ans.at(i) += pow(3,j);\n      }\n      else if(a%3 == 2){\n        ans.at(i) -= pow(3,j);\n      }\n      a = a/3;\n      j++;\n    }\n    if(a == 1){\n      ans.at(i) += pow(3,j);\n    }\n    else if(a == 2){\n      ans.at(i)-= pow(3,j);\n    }\n    if(a == 3){\n      ans.at(i) += pow(3,j+1);\n    }\n  }\n}\nvoid rumba(vector<int> &ans){\n  for(int j=0;j<(int)ans.size();j++){\n    if(ans.at(j)+1 < (int)ans.size()){\n      ans.at(j) ++;\n    }\n    else{\n      ans.at(j) = ans.at(j)+1 - (int)ans.size();\n    }\n  }\n}\n\nint main(){\n  int n;\n  string t;\n  cin >> n >> t;\n  int n3 = pow(3,n);\n  vector<int> ans(n3);\n  for(int i=0;i<n3;i++){\n    ans.at(i) = i;\n  }\n  for(int i=0;i<(int)t.length();i++){\n    if(t.at(i) == 'S'){\n      salsa(ans);\n    }\n    else{\n      rumba(ans);\n    }\n  }\n  for(int j=0;j<n3;j++){\n    cout << ans.at(j);\n    if(j != n3-1){\n      cout << \" \";\n    }\n  }\n  cout << endl;\n}\n      \n       "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\ninline int read () {\n    int ret = 0, t = 1;\n    char c = getchar();\n    while ((c < '0' || c > '9') && c != '-') c = getchar();\n    if (c == '-') t = -1, c = getchar();\n    while (c >= '0' && c <= '9') ret = ret * 10 + c - '0', c = getchar();\n    return ret * t;\n}\n\n#define PR pair<int, int>\n#define MP make_pair\n#define TO first\n#define NUM second\n\nint n;\nconst int MAXN = 2002000;\nstruct tree { PR s[3]; int val; bool lazy; } t[MAXN];\nint top = 1;\n\nvoid build (int x, int st, int tmp, int val) {\n    if (st == n) { t[x].val = val; return; }\n    t[x].s[0] = MP(++top, 0); build(t[x].s[0].TO, st + 1, tmp * 3, val + tmp * 0);\n    t[x].s[1] = MP(++top, 1); build(t[x].s[1].TO, st + 1, tmp * 3, val + tmp * 1);\n    t[x].s[2] = MP(++top, 2); build(t[x].s[2].TO, st + 1, tmp * 3, val + tmp * 2);\n}\n\nPR fnd (int x) {\n    int u, v;\n    if (t[x].s[0].NUM == 1) u = 0;\n    if (t[x].s[1].NUM == 1) u = 1;\n    if (t[x].s[2].NUM == 1) u = 2;\n    if (t[x].s[0].NUM == 2) v = 0;\n    if (t[x].s[1].NUM == 2) v = 1;\n    if (t[x].s[2].NUM == 2) v = 2;\n    return MP(u, v);\n}\n\nvoid pushdown (int x) {\n    if (!t[x].lazy) return;\n    t[x].lazy = false;\n    for (int i = 0; i < 3; i++) {\n        PR tmp = fnd(t[x].s[i].TO);\n        int rua = t[x].s[i].TO;\n        swap(t[rua].s[tmp.first].NUM, t[rua].s[tmp.second].NUM);\n    }\n    t[t[x].s[0].TO].lazy ^= 1, t[t[x].s[1].TO].lazy ^= 1, t[t[x].s[2].TO].lazy ^= 1;\n}\n\nvoid mod1 (int x) {\n    if (!t[x].s[0].TO) return;\n    pushdown(x);\n    ++t[x].s[0].NUM, ++t[x].s[1].NUM, ++t[x].s[2].NUM;\n    if (t[x].s[0].NUM == 3) t[x].s[0].NUM = 0, mod1(t[x].s[0].TO);\n    if (t[x].s[1].NUM == 3) t[x].s[1].NUM = 0, mod1(t[x].s[1].TO);\n    if (t[x].s[2].NUM == 3) t[x].s[2].NUM = 0, mod1(t[x].s[2].TO);\n}\n\nvoid mod2 (int x) {\n    if (!t[x].s[0].TO) return;\n    PR tmp = fnd(x);\n    swap(t[x].s[tmp.first].NUM, t[x].s[tmp.second].NUM);\n    t[x].lazy ^= 1;\n}\n\nint ans[MAXN];\nvoid query (int x, int st, int val) {\n    if (!t[x].s[0].TO) { ans[t[x].val] = val; return; }\n    pushdown(x);\n    query(t[x].s[0].TO, st * 3, val + st * t[x].s[0].NUM);\n    query(t[x].s[1].TO, st * 3, val + st * t[x].s[1].NUM);\n    query(t[x].s[2].TO, st * 3, val + st * t[x].s[2].NUM);\n}\n\nint main () {\n    n = read();\n    build(1, 0, 1, 0);\n    char c = getchar();\n    while (c != 'S' && c != 'R') c = getchar();\n    while (c == 'S' || c == 'R') {\n        if (c == 'S') mod2(1);\n        else mod1(1);\n        c = getchar();\n    }\n    query(1, 1, 0);\n    int tmp = 1;\n    while (n--) tmp *= 3;\n    for (int i = 0; i < tmp; i++) printf(\"%d \", ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Author: Tyler Wang\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdlib>\n#include <deque>\n#include <functional>\n#include <initializer_list>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <optional>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <string_view>\n#include <tuple>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntemplate <class C>\nconstexpr auto ssize(const C& c)\n    -> std::common_type_t<std::ptrdiff_t,\n                          std::make_signed_t<decltype(c.size())>> {\n  return (std::common_type_t<std::ptrdiff_t,\n                             std::make_signed_t<decltype(c.size())>>)c.size();\n}\n\ntemplate <class T, std::ptrdiff_t N>\nconstexpr std::ptrdiff_t ssize(const T (&)[N]) noexcept {\n  return N;\n}\n\ntemplate <typename T>\nconstexpr std::enable_if_t<std::is_unsigned_v<T>, bool> has_single_bit(\n    T x) noexcept {\n  return x != 0 && (x & (x - 1)) == 0;\n}\n\ntemplate <typename T>\nconstexpr std::enable_if_t<std::is_unsigned_v<T>, int> countl_zero(\n    T x) noexcept {\n  if constexpr (sizeof(T) <= sizeof(unsigned)) {\n    return __builtin_clz(x) - (std::numeric_limits<unsigned>::digits -\n                               std::numeric_limits<T>::digits);\n  } else if constexpr (sizeof(T) <= sizeof(unsigned long)) {\n    return __builtin_clzl(x) - (std::numeric_limits<unsigned long>::digits -\n                                std::numeric_limits<T>::digits);\n  } else {\n    static_assert(sizeof(T) <= sizeof(unsigned long long));\n    return __builtin_clzll(x) -\n           (std::numeric_limits<unsigned long long>::digits -\n            std::numeric_limits<T>::digits);\n  }\n}\n\ntemplate <typename T>\nconstexpr std::enable_if_t<std::is_unsigned_v<T>, int> countr_zero(\n    T x) noexcept {\n  if constexpr (sizeof(T) <= sizeof(unsigned)) {\n    return __builtin_ctz(x);\n  } else if constexpr (sizeof(T) <= sizeof(unsigned long)) {\n    return __builtin_ctzl(x);\n  } else {\n    static_assert(sizeof(T) <= sizeof(unsigned long long));\n    return __builtin_ctzll(x);\n  }\n}\n\ntemplate <typename T>\nconstexpr std::enable_if_t<std::is_unsigned_v<T>, int> popcount(T x) noexcept {\n  if constexpr (sizeof(T) <= sizeof(unsigned)) {\n    return __builtin_popcount(x);\n  } else if constexpr (sizeof(T) <= sizeof(unsigned long long)) {\n    return __builtin_popcountl(x);\n  } else {\n    static_assert(sizeof(T) <= sizeof(unsigned long long));\n    return __builtin_popcountll(x);\n  }\n}\n\ntemplate <typename T>\nconstexpr std::enable_if_t<std::is_unsigned_v<T>, T> bit_width(T x) noexcept {\n  return (T)(std::numeric_limits<T>::digits - countl_zero(x));\n}\n\ntemplate <typename T>\nconstexpr std::enable_if_t<std::is_unsigned_v<T>, T> bit_ceil(T x) noexcept {\n  return (T)(x <= 1 ? 1 : (T)1 << bit_width((T)(x - 1)));\n}\n\ntemplate <typename T>\nconstexpr std::enable_if_t<std::is_unsigned_v<T>, T> bit_floor(T x) noexcept {\n  return (T)(x == 0 ? 0 : (T)1 << (bit_width(x) - 1));\n}\n\ntemplate <class Fun>\nclass y_combinator_result {\n public:\n  template <class T>\n  explicit y_combinator_result(T&& fun) : fun_(std::forward<T>(fun)) {}\n\n  template <class... Args>\n  decltype(auto) operator()(Args&&... args) {\n    return fun_(std::ref(*this), std::forward<Args>(args)...);\n  }\n\n private:\n  Fun fun_;\n};\n\ntemplate <class Fun>\ndecltype(auto) y_combinator(Fun&& fun) {\n  return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, const std::optional<T>& opt) {\n  return opt ? os << *opt : os << \"nullopt\";\n}\n\ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, const std::pair<T1, T2>& p) {\n  return os << '{' << p.first << \", \" << p.second << '}';\n}\n\ntemplate <typename Container,\n          std::enable_if_t<!std::is_convertible_v<Container, std::string_view>,\n                           typename Container::const_iterator>* = nullptr>\nstd::ostream& operator<<(std::ostream& os, const Container& c) {\n  os << '{';\n  for (auto it = c.begin(); it != c.end(); ++it) {\n    if (it != c.begin()) {\n      os << \", \";\n    }\n    os << *it;\n  }\n  return os << '}';\n}\n\ntemplate <typename T, typename Container>\nstd::ostream& operator<<(std::ostream& os, std::stack<T, Container> s) {\n  std::vector<T> v(s.size());\n  for (auto it = v.rbegin(); it != v.rend(); ++it) {\n    *it = s.top();\n    s.pop();\n  }\n  return os << v;\n}\n\ntemplate <typename T, typename Container>\nstd::ostream& operator<<(std::ostream& os, std::queue<T, Container> q) {\n  os << '{';\n  if (!q.empty()) {\n    os << q.front();\n    q.pop();\n    while (!q.empty()) {\n      os << \", \" << q.front();\n      q.pop();\n    }\n  }\n  return os << '}';\n}\n\ntemplate <typename T, typename Container, typename Compare>\nstd::ostream& operator<<(std::ostream& os,\n                         std::priority_queue<T, Container, Compare> pq) {\n  os << '{';\n  if (!pq.empty()) {\n    os << pq.top();\n    pq.pop();\n    while (!pq.empty()) {\n      os << \", \" << pq.top();\n      pq.pop();\n    }\n  }\n  return os << '}';\n}\n\nnamespace detail {\n\ntemplate <int I, typename... Ts>\nvoid tuple_print(std::ostream& os, const std::tuple<Ts...>& t) {\n  static_assert(0 <= I && I <= sizeof...(Ts));\n  if constexpr (I != sizeof...(Ts)) {\n    if constexpr (I != 0) {\n      os << \", \";\n    }\n    os << std::get<I>(t);\n    tuple_print<I + 1>(os, t);\n  }\n}\n\n}  // namespace detail\n\ntemplate <typename... Ts>\nstd::ostream& operator<<(std::ostream& os, const std::tuple<Ts...>& t) {\n  os << '{';\n  detail::tuple_print<0>(os, t);\n  return os << '}';\n}\n\nnamespace detail {\n\ntemplate <typename T1, typename... Ts>\nvoid debug_print(std::string_view keys, const T1& val1, const Ts&... vals) {\n  if constexpr (sizeof...(Ts) == 0) {\n    std::cerr << keys << \" = \" << val1 << std::endl;\n  } else {\n    for (int i = 0, paren = 0; i < (int)keys.size(); ++i) {\n      if (keys[i] == '(' || keys[i] == '{') {\n        ++paren;\n      } else if (keys[i] == ')' || keys[i] == '}') {\n        --paren;\n      } else if (keys[i] == ',' && paren == 0) {\n        std::cerr << keys.substr(0, i) << \" = \" << val1 << ',';\n        return debug_print(keys.substr(i + 1), vals...);\n      }\n    }\n  }\n}\n\ntemplate <typename... Ts>\nvoid debug_print(int line, const Ts&... keyvals) {\n  if constexpr (sizeof...(Ts) <= 1) {\n    std::cerr << \"  \" << line << \" |\" << std::endl;\n  } else {\n    std::cerr << \"  \" << line << \" | \";\n    debug_print(keyvals...);\n  }\n}\n\n}  // namespace detail\n\n#if defined(TYLER) && defined(__GNUC__) && __GNUC__ >= 8\n#define debug(...) \\\n  detail::debug_print(__LINE__, #__VA_ARGS__ __VA_OPT__(, ) __VA_ARGS__)\n#elif defined(TYLER)\n#define debug(...) detail::debug_print(__LINE__, #__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) ((void)0)\n#endif\n\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  std::cout.precision(12);\n  std::cerr.precision(12);\n  std::mt19937 rng((std::uint_fast32_t)std::chrono::high_resolution_clock::now()\n                       .time_since_epoch()\n                       .count());\n  // R\n  // 1, 2, 0\n  // 01, 02, 10, 11, 12, 20, 21, 22, 00\n  vector<int> perm;\n  auto solve = y_combinator(\n      [&](auto self, int n, string& s, int base, int val, int pos) -> void {\n        if (n == 0) {\n          perm[val] = pos;\n          return;\n        }\n        for (int d = 0; d < 3; ++d) {\n          string s2;\n          int d2 = d;\n          for (char c : s) {\n            if (c == 'S') {\n              if (!s2.empty() && s2.back() == 'S') {\n                s2.pop_back();\n              } else {\n                s2 += 'S';\n              }\n              if (d2 != 0) {\n                d2 = 3 - d2;\n              }\n            } else {\n              if (d2 == 2) {\n                s2 += 'R';\n                d2 = 0;\n              } else {\n                ++d2;\n              }\n            }\n          }\n          self(n - 1, s2, base * 3, val + base * d, pos + base * d2);\n        }\n      });\n  int n;\n  string s;\n  cin >> n >> s;\n  perm.resize((int)pow(3, n));\n  solve(n, s, 1, 0, 0);\n  for (int p : perm) {\n    cout << p << ' ';\n  }\n  cout << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> to3(int x) {\n  vector<int> v(0);\n  if (x == 0)\n    v = {0};\n  else\n    while (x > 0) {\n      int r;\n      r = x % 3;\n      x /= 3;\n      v.push_back(r);\n    }\n  return v;\n}\n\nvector<int> change12(vector<int> v) {\n  for (int i = 0; i < v.size(); i++) {\n    if (v.at(i) == 1)\n      v.at(i) = 2;\n    else if (v.at(i) == 2)\n      v.at(i) = 1;\n  }\n  return v;\n}\n\nint from3(vector<int> v) {\n  int s = 0;\n  for (int i = 0; i < v.size(); i++) {\n   int t = v.at(i);\n    for (int j = 0; j < i; j++) {\n      t *= 3;\n    }\n    s += t;\n  }\n  return s;\n}\n    \n\nint main() {\n  int n;\n  cin >> n;\n  int n3 = n * n * n;\n  vector<int> p(n3);\n  for (int i = 0; i < n3; i++) {\n    p.at(i) = i;\n  }\n  \n  string t;\n  cin >> t;\n  for (int i = 0; i < t.size(); i++) {\n    if (t.at(i) == 'S') {\n      for (int j = 0; j < n3; j++) {\n        vector<int> a1 = to3(p.at(j));\n        vector<int> a2 = change12(a1);\n        int a3 = from3(a2);\n        if (a3 == n3)\n          p.at(j) = 0;\n        else\n          p.at(j) = a3;\n      }\n    }\n    if (t.at(i) == 'R') {\n      for (int j = 0; j < n3; j++) {\n        if (p.at(j) == n3 - 1)\n          p.at(j) = 0;\n        else \n          p.at(j)++;\n      }\n    }\n  }\n  for (int i = 0; i < n3; i++) {\n    cout << p.at(i);\n    if (i == n3 - 1)\n      cout << endl;\n    else\n      cout << ' ';\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int N;\n    string T;\n    cin >> N >> T;\n    int L = T.size();\n\n    vector<vector<int>> P(N+1), W(N+1);\n    P[0] = {0};\n    W[0] = vector<int>(L, 0);\n\n    for(int n=1; n<=N; n++){\n        int M = pow(3, n);\n        vector<int> D(M);\n        for(int i=0; i<M; i++) D[i] = i/(M/3);\n        W[n].resize(L);\n        vector<int> done(M);\n        int s = 0;\n        for(int j=0; j<L; j++){\n            int w = W[n-1][j];\n            for(int i=w; i<M; i+=M/3){\n                if((s-done[i]) % 2 && D[i]) D[i] = 3-D[i];\n                done[i] = s;\n                if(D[i] == 2) W[n][j] = i;\n            }\n            if(T[j] == 'S'){\n                s++;\n            }else{\n                for(int i=w; i<M; i+=M/3){\n                    D[i] = (D[i]+1) % 3;\n                }\n            }\n        }\n        for(int i=0; i<M; i++) if((s-done[i]) % 2 && D[i]) D[i] = 3-D[i];\n        P[n].resize(M);\n        for(int i=0; i<M; i++) P[n][i] = D[i]*(M/3) + P[n-1][i%(M/3)];\n    }\n\n    for(int a : P[N]) cout << a << \" \";\n    cout << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define mp make_pair\n#define pb push_back\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, n) for (int i = 0; i < (int)(n); ++ i)\n#define forall(it, c) for (__typeof(c.begin()) it = c.begin(); it != c.end(); ++ it)\n\ntemplate <typename T> inline void read(T &x) {\n\tx = 0; bool f = 1; char c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = 0;\n\tfor (;  isdigit(c); c = getchar()) x = x * 10 + (c & 15);\n\tif (!f) x = -x;\n}\n\nconst int maxn = 531441;\nint K, n;\nint pw[15];\nint ans[maxn];\nchar s[2 << 17];\n\nstruct tree {\n\tstatic const int maxn = 531441;\n\tint go[maxn][3];\n\tint lz[maxn], id[maxn];\n\tint tot;\n\tvoid push(int x) {\n\t\tswap(go[x][1], go[x][2]);\n\t\tlz[x] ^= 1;\n\t}\n\tvoid pd(int x) {\n\t\tif (lz[x]) {\n\t\t\tpush(go[x][0]);\n\t\t\tpush(go[x][1]);\n\t\t\tpush(go[x][2]);\n\t\t\tlz[x] = 0;\n\t\t}\n\t}\n\tvoid build(int &x, int lvl, int num) {\n\t\tx = ++ tot;\n\t\tif (K == lvl) {\n\t\t\tid[x] = num;\n\t\t\treturn ;\n\t\t}\n\t\tbuild(go[x][0], lvl + 1, num);\n\t\tbuild(go[x][1], lvl + 1, num + pw[lvl]);\n\t\tbuild(go[x][2], lvl + 1, num + 2 * pw[lvl]);\n\t}\n\tvoid add(int x, int lvl) {\n\t\tif (K == lvl) return ;\n\t\tpd(x);\n\t\tadd(go[x][2], lvl + 1);\n\t\tswap(go[x][1], go[x][2]);\n\t\tswap(go[x][0], go[x][1]);\n\t}\n\tvoid prt(int x, int lvl, int num) {\n\t\tif (K == lvl) {\n\t\t\tans[id[x]] = num;\n\t\t\treturn ;\n\t\t}\n\t\tpd(x);\n\t\tprt(go[x][0], lvl + 1, num);\n\t\tprt(go[x][1], lvl + 1, num + pw[lvl]);\n\t\tprt(go[x][2], lvl + 1, num + 2 * pw[lvl]);\n\t}\n} tr;\n\nint main() {\n\tread(K);\n\trep(i, K + 1) pw[i] = i ? 3 * pw[i - 1] : 1;\n\tn = pw[K];\n\tint rt = 0;\n\ttr.build(rt, 0, 0);\n\tscanf(\"%s\", s);\n\tint m = strlen(s);\n\trep(i, m) {\n\t\tif (s[i] == 'S') tr.push(rt);\n\t\telse tr.add(rt, 0);\n\t}\n\ttr.prt(rt, 0, 0);\n\trep(i, n) printf(\"%d \", ans[i]);\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\nusing namespace std;\n\nint n, len, l[3*3*3*3*3*3*3*3*3*3*3*3];\nstring t;\n\nint calc(int a) {\n\tif (a < 3) {\n\t\treturn a % 3 - 1 + (a + 1) % 3;\n\t}\n\telse {\n\t\treturn a % 3 - 1 + (a + 1) % 3 + 3 * calc(a / 3);\n\t}\n}\n\nint main()\n{\n\tcin >> n;\n\tcin >> t;\n\tn = pow(3, n);\n\tfor (int i = 0; i < n; i++) {\n\t\tl[i] = i;\n\t}\n\tfor (int i = 0; i < t.size(); i++) {\n\t\tif (t[i] == 'S') {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tl[j] = calc(l[j]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tl[j] = (l[j] + 1) % n;\n\t\t\t}\n\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcout << l[i] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << l[i] << \" \";\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include<limits.h>\n#include<utility>\n#include<vector>\n#include<tuple>\n#include <map>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define ALL(A) A.begin(),A.end()\n\n\nint main() {\n\tint n;\n\tstring t;\n\tcin >> n >> t;\n\tint N = 1;\n\tint a3[13];\n\ta3[0] = 1;\n\trep(i, n) {\n\t\ta3[i + 1] = a3[i]*3;\n\t}\n\tN = a3[n];\n\tvector<int> S(N);\n\tvector<int> person(N);\n\trep(i, N) {\n\t\tperson[i] = i;\n\t\tif (i == 0) {\n\t\t\tS[i] = i;\n\t\t\tcontinue;\n\t\t}\n\t\tint a=0;\n\t\tint m = 0;\n\t\tint I = i;\n\t\twhile (I != 0) {\n\t\t\tint am = I % 3;\n\t\t\tif (am == 1) {\n\t\t\t\tam = 2;\n\t\t\t}\n\t\t\telse if (am == 2) {\n\t\t\t\tam = 1;\n\t\t\t}\n\t\t\ta += am * a3[m];\n\t\t\tI /= 3;\n\t\t\tm++;\n\t\t}\n\t\tS[i] = a;\n\t\t\n\t}\n\tint s = 0;\n\tint r = 0;\n\tint o[N];\n\tfor (int i = 0; i < t.size(); i++) {\n\t\tif (t[i] == 'S') {\n\t\t\trep(j, N) {\n\t\t\t\tperson[j]+=r;\n\t\t\t\tperson[j] %= N;\n\t\t\t\t//person[j] = S[person[j]];\n\t\t\t}\n\t\t\ts++;\n\t\t\tr = 0;\n\t\t}\n\t\tif (t[i] == 'R') {\n\t\t\tr++;\n\t\t\trep(j, N) {\n\t\t\t\tif (s % 2 == 1) {\n\t\t\t\t\tperson[j] = S[person[j]];\n\t\t\t\t}\n\t\t\t}\n\t\t\ts = 0;\n\n\t\t}\n\t\t\n\t}\n\trep(i, N) {\n\t\tif (t[t.size() - 1] == 'R') {\n\t\t\tperson[i] = (person[i] + r) % N;\n\t\t\tcout << person[i]<<\" \";\n\t\t}\n\t\telse {\n\t\t\tperson[i] = S[person[i]];\n\t\t\tcout << person[i]<<\" \";\n\t\t}\n\t\t\n\t}\n\tcout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n// #include <ext/pb_ds/assoc_container.hpp> \n// #include <ext/pb_ds/detail/standard_policies.hpp>\n// using namespace __gnu_pbds;\n\n#pragma GCC optimize(\"O3\")\n#ifdef LOCAL\n#include \"/Users/lbjlc/Desktop/coding/debug_utils.h\"\n#else\n#define print(...) ;\n#define printn(...) ;\n#define fprint(...) ;\n#define fprintn(...) ;\n#endif\n\n#define rep(i, a, b) for(auto i = (a); i < (b); i++)\n#define rrep(i, a, b) for(auto i = (a); i > (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define pb push_back\n// #define mp make_pair\n#define fi first\n#define se second\n#define maxi(x, y) x = max(x, y)\n#define mini(x, y) x = min(x, y)\n// long long fact(long long n) { if(!n) return 1; return n*fact(n-1); }\n// #define endl '\\n'\n#define solve_testcase int T;cin>>T;for(int t=1;t<=T;t++){solve(t);}\n\n// long long gcd(long long x, long long y) { return y ? gcd(y, x % y) : x; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\n \ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n \ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\ntypedef vector<long long> vll;\n#define bd(type,op,val) bind(op<type>(), std::placeholders::_1, val)\n\nconst int MAXN = 1e6+10;\n\n\nvoid solve(int tt) {\n    // cout<<\"Case #\"<<tt<<\": \";\n}\n\nstring to_ter(int x, int k=-1) {\n    string res;\n    while(x) {\n        res+='0'+x%3;\n        x/=3;\n    }\n    if(k>=0) {\n        while(res.size()<k) res+='0';\n    }\n    return res;\n}\nint to_int(const string & s) {\n    int res=0;\n    // rrep(i,s.size()-1,-1)\n    //     res=res*3+(s[i]-'0');\n    for(int i=s.size()-1;i>=0;i--)\n        res=res*3+(s[i]-'0');\n    // print(s,res);\n    return res;\n}\nbool add(string & x, const string & y) {\n    int n1=x.size(), n2=y.size(),carry=0;\n    rep(i,0,n1) {\n        if(i<n1) carry+=x[i]-'0';\n        if(i<n2) carry+=y[i]-'0';\n        x[i]=carry%3+'0';\n        carry/=3;\n    }\n    return carry==0;\n}\n\nvi cal_inst(string & s) {\n    int n=s.size();\n    vi res(1);\n    int i=0;\n    while(i<n) {\n        if(s[i]=='R') {\n            res.back()++;\n            i++;\n        }\n        else {\n            int j=i;\n            for(;j<n&&s[j]=='S';j++);\n            if((j-i)%2) res.pb(0);\n            i=j;\n        }\n    }\n    if(s.back()=='S') res.pop_back();\n    return res;\n}\n\nchar rev(char c) {\n    if(c>'0') return '0'+(3-(c-'0'));\n    return c;\n}\nstring rev(string s) {\n    for(auto & c:s) c=rev(c);\n    return s;\n}\n\nint len(string & s) {\n    int res=s.size()-1;\n    while(res>=0&&s[res]=='0') res--;\n    return res+1;\n}\n\nvi power(13);\n\nvi cal(vi inst, int n, int tot) {\n    vi res(tot),dp(tot,-1);\n    rep(i,0,tot) {\n        int cur=i;\n        int ok=0;\n        rep(j,5,n) {\n            int cur1=cur%power[j];\n            if(dp[cur1]>=0&&dp[cur1]<power[j]) {\n                cur1=dp[cur1];\n                if(inst.size()%2) {\n                    cur1+=cur/power[j]*power[j];\n                    for(int flag=power[j];flag<power[n];flag*=3) {\n                        int tmp=cur1/flag%3;\n                        if(tmp==1) cur1+=flag;\n                        else if(tmp==2) cur1-=flag;\n                    }\n                }\n                else {\n                    cur1+=cur/power[j]*power[j];\n                }\n                ok=1;\n                res[i]=dp[cur]=cur1;\n                break;\n            }\n        }\n        if(!ok) {\n            int cur1=cur;\n            bool ok1=true;\n            for(auto x:inst) {\n                cur1+=x;\n                if(cur1>=power[n]) ok=0;\n                cur1%=power[n];\n                for(int flag=1;flag<power[n];flag*=3) {\n                    int tmp=cur1/flag%3;\n                    if(tmp==1) cur1+=flag;\n                    else if(tmp==2) cur1-=flag;\n                }\n            }\n            res[i]=dp[cur]=cur1;\n        }\n    }\n    print(dp.size());\n    return res;\n}\n\nint main(int argc, char * argv[]) {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    // solve_testcase;\n\n    int n;\n    string s;\n    // cin>>n;\n    // cin>>s;\n\n    n=12;\n    rep(i,0,1e5) s+=\"RS\";\n\n    power[0]=1;\n    rep(i,1,13) power[i]=power[i-1]*3;\n\n    int tot=1;\n    rep(i,0,n) tot*=3;\n\n    vi inst=cal_inst(s);\n    for(auto & x:inst) x%=tot;\n\n    // print(inst);\n\n    int i=0;\n    int bound=3*3*3*3*3;\n    vi res(tot);\n    iota(all(res),0);\n    while(i<inst.size()) {\n        int cur=inst[i];\n        vi cur_inst({cur});\n        for(++i;i<inst.size()&&cur+inst[i]<bound;i++) {\n            cur+=inst[i];\n            cur_inst.pb(inst[i]);\n        }\n        vi tmp=cal(cur_inst,n,tot);\n        // print(tmp);\n        rep(j,0,tot) res[j]=tmp[res[j]];\n        // print(cur_inst,tmp);\n        // print(res);\n        // sort(all(tmp)); print(tmp);\n    }\n    if(s.back()=='R') {\n        rep(i,0,tot) {\n            res[i]=to_int(rev(to_ter(res[i],n)));\n        }\n    }\n    for(auto x:res) cout<<x<<' ';\n    cout<<endl;\n\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nconst int MN = 531441, MM = 200005;\n\nint N, M, c;\nchar T[MM];\nint A[MN], B[MN], V[MM];\n\nint main() {\n\tscanf(\"%d%s\", &N, T + 1), M = strlen(T + 1), c = 1;\n\tfor (int i = 1; i <= M; ++i) V[i] = 0;\n\tfor (int i = 1; i <= N; ++i, c *= 3) {\n\t\tint rev = 0;\n\t\tfor (int j = 0; j < c; ++j)\n\t\t\tfor (int d = 0; d < 3; ++d)\n\t\t\t\tB[j + d * c] = d;\n\t\tfor (int j = 1; j <= M; ++j) {\n\t\t\tif (T[j] == 'R') {\n\t\t\t\tint lst = V[j];\n\t\t\t\tfor (int d = 0; d < 3; ++d) {\n\t\t\t\t\tint p = lst + d * c;\n\t\t\t\t\tif (B[p] + rev == 2) V[j] = p;\n\t\t\t\t\tB[p] = (B[p] + rev + 1) % 3;\n\t\t\t\t}\n\t\t\t} else rev ^= 1;\n\t\t}\n\t\tfor (int j = 0; j < c; ++j) {\n\t\t\tint a = A[j];\n\t\t\tfor (int d = 0; d < 3; ++d) {\n\t\t\t\tint p = j + d * c;\n\t\t\t\tA[p] = a + (rev ? 3 - B[p] : B[p]) % 3 * c;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < c; ++i) printf(\"%d%c\", A[i], \" \\n\"[i == c - 1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n// #pragma GCC target (\"avx\")\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nconst int SIZE = 531441;\n\nint N;\n\nint THREE[13];\nchar buf[200011];\n\n\nVI normal(const string &s) {\n    VI ret;\n    int cnt = 0;\n    REP (i, s.size()) {\n\tif (s[i] == 'S') {\n\t    if (cnt) ret.push_back(cnt);\n\t    cnt = 0;\n\t    if (ret.size() && ret.back() == -1) ret.pop_back();\n\t    else ret.push_back(-1);\n\t} else {\n\t    cnt++;\n\t}\n    }\n    if (cnt) ret.push_back(cnt);\n    return ret;\n}\n\nvector<vector<int> > G[13];\nvector<int> H[13];\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    scanf(\"%s\", buf);\n\n#ifdef MYTEST\n    N = 12;\n    REP (i, 20000) {\n\tif (i % 4 == 0) buf[i] = 'S';\n\telse buf[i] = 'R';\n    }\n#endif\n\n    THREE[0] = 1;\n    REP (i, N) THREE[i+1] = THREE[i] * 3;\n    REP (i, N+1) {\n\tG[i].resize(THREE[i]);\n\tH[i].resize(THREE[i]);\n    }\n    G[0][0] = normal(buf);\n\n    REP (i, N) REP (s, THREE[i]) REP (a, 3) {\n\tconst int val = a * THREE[i] + s;\n\tint x = a;\n\tconst VI &g = G[i][s];\n\tVI t;\n\n\tREP (j, g.size()) {\n\t    if (g[j] == -1) {\n\t\tif (t.size() && t.back() == -1) t.pop_back();\n\t\telse t.push_back(-1);\n\t\tif (x) x = 3 - x;\n\t    } else {\n\t\tx += g[j];\n\t\tif (x / 3) {\n\t\t    if (t.size() && t.back() >= 0) t.back() += x/3;\n\t\t    else t.push_back(x/3);\n\t\t}\n\t\tx %= 3;\n\t    }\n\t}\n\tG[i+1][val] = t;\n\tH[i+1][val] = x * THREE[i] + H[i][s];\n    }\n\n    // REP (i, N) rprintf(\"%d\", H[i].begin(), H[i].end());\n\n    rprintf(\"%d\", H[N].begin(), H[N].end());\n\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define x first\n#define y second\n#define iter iterator\n#define riter reversed_iterator\n#define y1 Lorem_ipsum_\n#define tm dolor_sit_amet_\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int N = 10;\nconst int S = 6;\nvector<int> s[S*4+3];\n\nchar decode(int x) {return x<=26?64+x:(x<=52?96-26+x:48+x-52+1);}\n\nbool ask(int u,int i,int j)\n{\n\tint len = N;\n\tprintf(\"? \"); for(int k=0; k<s[u].size(); k++) {len--; printf(\"%c\",decode(s[u][k]));} len--; printf(\"%c\",decode(s[u<<1][i]));\n\tfor(int k=j; k<s[u<<1|1].size(); k++) {len--; printf(\"%c\",decode(s[u<<1|1][k]));} puts(\"\"); fflush(stdout);\n\tint res; scanf(\"%d\",&res); return res==len;\n}\nvoid solve(int u,int le,int ri)\n{\n\tif(le==ri)\n\t{\n\t\tprintf(\"? \"); for(int i=1; i<=N; i++) {printf(\"%c\",decode(le));} puts(\"\"); fflush(stdout);\n\t\tint res; scanf(\"%d\",&res);\n\t\tfor(int i=1; i<=N-res; i++) {s[u].push_back(le);}\n\t\treturn;\n\t}\n\tint mid = (le+ri)>>1;\n\tsolve(u<<1,le,mid); solve(u<<1|1,mid+1,ri);\n\tfor(int i=0,j=0; i<s[u<<1].size()||j<s[u<<1|1].size();)\n\t{\n\t\tif(i<s[u<<1].size()&&(j==s[u<<1|1].size()||ask(u,i,j))) {s[u].push_back(s[u<<1][i]); i++;}\n\t\telse {s[u].push_back(s[u<<1|1][j]); j++;}\n\t}\n}\n\nint main()\n{\n\tsolve(1,1,S);\n\tprintf(\"! \"); for(int i=0; i<s[1].size(); i++) printf(\"%d \",decode(s[1][i])); puts(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#define int long long\n\n#define pii pair<int, int>\n\n#define x1 x1228\n#define y1 y1228\n\n#define left left228\n#define right right228\n\n#define next next228\n\n#define pb push_back\n#define eb emplace_back\n\n#define mp make_pair                                                                \n                                                                                                                                        \n#define ff first                                                                  \n#define ss second   \n\n#define all(x) x.begin(), x.end()\n#define debug(x) cout << #x << \": \" << x << endl; \n#define TIME (ld)clock()/CLOCKS_PER_SEC\n\nusing namespace std;\ntypedef long long ll; \ntypedef long double ld; \n                                                                                                   \nconst int maxn = 2e5 + 7, mod = 1e9 + 7, MAXN = 1e6 + 7;\nconst double eps = 1e-9;\nconst ll inf = 1e18;\nmt19937 rnd(time(0));\nint n; \nstring s; \nint next[MAXN];\nconst int N = 2187; \nint dp1[N]; \nint dp2[N]; \nint xyz[maxn]; \n\nint get1(int mask, char q) {\n    if (q == 'R') {\n        ++mask; \n        return mask; \n    }   \n    int ptr = 1; \n    int ans = 0; \n    while (mask) {\n        int t = mask % 3; \n        mask /= 3; \n        if (t == 2) ans += ptr; \n        if (t == 1) ans += 2 * ptr; \n        ptr *= 3; \n    }\n    return ans; \n}\n\nint get(int mask, char q) {\n    if (q == 'R') {\n        ++mask; \n        return mask; \n    }   \n    return xyz[mask]; \n}\n\nconst int L = 12; \nint pref[maxn]; \nint to[maxn]; \nint kek1[N], kek2[N]; \nint res[N]; \n\nint get(int l, int r) {\n    return pref[r + 1] - pref[l]; \n}\n\nvoid change(int &mask, int l, int r) {\n    if (get(l, r) % 2) {\n        mask = get(mask, 'S'); \n    }    \n    mask++; \n}\n\nint merge(int left, int right) {\n    for (int i = 0; i < 7; ++i) right *= 3;\n    return left + right;     \n}\n\nint get(int x) {\n    vector<int> bts; \n    for (int i = 0; i < L; ++i) {\n        bts.pb(x % 3); \n        x /= 3; \n    }\n    int left = 0;\n    int right = 0; \n    for (int i = 6; i >= 0; --i) {\n        left *= 3;\n        left += bts[i]; \n    }\n    for (int i = L - 1; i >= 7; --i) {\n        right *= 3; \n        right += bts[i]; \n    }\n    int id = 0; \n    if (left && dp1[left] == -1) {\n        return merge(res[left], right);  \n    }\n    if (left) {    \n        id = dp1[left]; \n        change(right, 0, id - 1);             \n        left = 0; \n    }                     \n    while (next[id] != -1) {\n        change(right, id, next[id] - 1);\n        id = next[id];                                                                                                                                         \n    }\n    left = to[id]; \n    return merge(left, right); \n}\n\n\nvoid solve() {\n    for (int i = 0; i < maxn; ++i) {\n        xyz[i] = get1(i, 'S'); \n    }\n    cin >> n >> s; \n    int t = s.size(); \n    for (int i = 0; i < N; ++i) {        \n        res[i] = i; \n        for (int j = 0; j < t; ++j) {\n            res[i] = get(res[i], s[j]); \n        } \n    }\n    for (int i = 0; i < t; ++i) {\n        pref[i + 1] = pref[i] + (s[i] == 'S'); \n    }\n    for (int i = 0; i < N; ++i) dp1[i] = dp2[i] = -1; \n    next[t] = -1;\n    for (int i = 0; i < N; ++i) kek1[i] = i;              \n    for (int i = t - 1; i >= 0; --i) {\n        for (int mask = 0; mask < N; ++mask) {\n            int mask1 = get(mask, s[i]); \n            mask1 %= N; \n            kek2[mask] = kek1[mask1];\n        }\n        to[i] = kek2[0]; \n        for (int mask = 0; mask < N; ++mask) {\n            int mask1 = get(mask, s[i]);\n            mask1 %= N;                 \n            if (mask && mask1 == 0) {\n                dp2[mask] = i + 1; \n            } else {\n                dp2[mask] = dp1[mask1]; \n            }   \n        }\n        next[i] = dp2[0]; \n        for (int mask = 0; mask < N; ++mask) {\n            kek1[mask] = kek2[mask]; \n            dp1[mask] = dp2[mask]; \n            dp2[mask] = -1; \n        }\n    }\n    int tet = 1; \n    for (int i = 0; i < n; ++i) tet *= 3; \n    for (int i = 0; i < tet; ++i) {\n        cout << get(i) % tet << \" \";             \n    }\n}                                \n   \nsigned main() {\n#ifdef LOCAL\n    freopen(\"TASK.in\", \"r\", stdin);\n    freopen(\"TASK.out\", \"w\", stdout);\n#else \n    \n#endif // LOCAL\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20); \n    cout << fixed; \n    int t = 1; \n    for (int i = 0; i < t; ++i) {              \n        solve();\n    }\n    return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n\nusing namespace std;\n\nint N;\nstring T;\n\nvoid R(int *data);\nvoid S(int *data1, int *data2);\nint X(int x, int y);\n\nint main(){\n  int n;\n  string s1;\n  string s2;\n  cin >> n;\n  cin >> T;\n  N = X(3, n);\n  int L[N];\n  int K[N];\n  int O[N];\n  \n  for(int i=0;i<N;i++){\n    L[i] = i;\n  }\n  \n  for(int i=0;i<N/3;i++){\n    int k = i;\n    int tmp = 0;\n    int m = 3;\n    int q = i*3;\n    \n    while(k>0){\n      if(k%3==1){\n        tmp = tmp +2*m;\n      }else if(k%3==2){\n        tmp = tmp +1*m;\n      }\n      k = k/3;\n      m = m*3;\n    }\n    K[tmp] = q;\n    K[tmp + 1] = q+2;\n    K[tmp + 2] = q+1;\n  }\n  \n  \n  for(int i=0;i<(int)(T.length());i++){\n    s1 = T[i];\n    s2 = T[i+1];\n    if(s1==\"R\"){\n      R(L);\n    }else if(s1==\"S\" && s2==\"S\"){\n      i++;\n    }else{\n      S(L,K);\n    }\n  }\n  \n  \n  for(int i=0;i<N;i++){\n    O[L[i]] = i;\n  }\n  \n\n\n  for(int i=0;i<N;i++){\n    cout << O[i] << \" \";\n  }\n  return 0;\n}\n\nvoid R(int *data){\n  int tmp = data[N-1];\n  for(int i=0;i<N;i++){\n    int a = data[i];\n    data[i] = tmp;\n    tmp = a;\n  }\n}\nvoid S(int *data1, int *data2){\n  int T[N];\n  for(int i=0;i<N;i++){\n    T[i] = data1[data2[i]];\n  }\n  for(int i=0;i<N;i++){\n    data1[i] = T[i];\n  }\n}\n\n\nint X(int x,int y){\n  int a = 1;\n  for(int i=0;i<y;i++){\n    a = a*x;\n  }\n  return a;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tvector<int> perm;\n\tauto solve = std::y_combinator([&](auto self, int N, string T, int base = 1, int loS = 0, int loT = 0) -> void {\n\t\tif (N == 0) {\n\t\t\tperm[loS] = loT;\n\t\t\treturn;\n\t\t}\n\t\tfor (int v = 0; v < 3; v++) {\n\t\t\tstring nT;\n\t\t\tint nV = v;\n\t\t\tfor (char c : T) {\n\t\t\t\tif (c == 'S') {\n\t\t\t\t\tif (!nT.empty() && nT.back() == 'S') nT.pop_back();\n\t\t\t\t\telse nT += 'S';\n\t\t\t\t\tif (nV) nV = 3 - nV;\n\t\t\t\t} else {\n\t\t\t\t\tif (nV == 2) {\n\t\t\t\t\t\tnT += 'R';\n\t\t\t\t\t\tnV = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnV++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tself(N-1, std::move(nT), base * 3, loS + base *v, loT + base * nV);\n\t\t}\n\t});\n\n\tint N; string T; cin >> N >> T;\n\tint p3 = 1; for (int i = 0; i < N; i++) p3 *= 3;\n\tperm.resize(p3);\n\tsolve(N, T);\n\tfor (int z = 0; z < p3; z++) {\n\t\tcout << perm[z] << \" \\n\"[false && z+1==p3];\n\t}\n\tcout << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nusing namespace std;\n\nint n, Q;\nstring s;\n\nvoid update(int x, vector<int> &d, vector<int> &salsas)\n{\n    if (salsas[x] != Q)\n    {\n        salsas[x] ^= 1;\n        if (d[x] == 1) d[x] = 2;\n        else if (d[x] == 2) d[x] = 1;\n    }\n}\n\npair<vector<int>, vector<int> > solve(vector<int> last_p, vector<int> last_w)\n{\n    vector<int> p(3 * last_p.size()), w;\n    int n = last_p.size();\n\n    Q = 0;\n    vector<int> d(3 * last_p.size());\n    vector<int> salsas(3 * last_p.size());\n    for (int i = 0; i < n; i++) d[i] = 0;\n    for (int i = n; i < 2 * n; i++) d[i] = 1;\n    for (int i = 2 * n; i < 3 * n; i++) d[i] = 2;\n\n    for (int i = 0; i < s.size(); i++)\n    {\n        int x = last_w[i];\n\n        update(x, d, salsas);\n        update(x + n, d, salsas);\n        update(x + 2 * n, d, salsas);\n\n        if (d[x] == 2) w.push_back(x);\n        if (d[n + x] == 2) w.push_back(n + x);\n        if (d[2 * n + x] == 2) w.push_back(2 * n + x);\n        if (s[i] == 'S')\n        {\n            Q ^= 1;\n        }\n        else\n        {\n            int x = last_w[i];\n            d[x] = (d[x] + 1) % 3;\n            d[n + x] = (d[n + x] + 1) % 3;\n            d[2 * n + x] = (d[2 * n + x] + 1) % 3;\n        }\n    }\n\n    for (int i = 0; i < 3 * n; i++) update(i, d, salsas);\n    for (int i = 0; i < 3 * n; i++)\n    {\n        p[i] = last_p[i % n] + d[i] * n;\n    }\n\n    return {p, w};\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n    cin >> n;\n    #ifdef LOCAL\n    string ss;\n    cin >> ss;\n    while (s.size() < 200000) s += ss;\n    #else\n    cin >> s;\n    #endif // LOCAL\n\n    vector<int> last_p = {0, 1, 2};\n    vector<int> last_w;\n    for (int i = 0; i < s.size(); i++)\n    {\n        for (int j = 0; j < 3; j++) if (last_p[j] == 2) last_w.push_back(j);\n        if (s[i] == 'S')\n        {\n            int t = 1;\n            for (int k = 0; t && k < 3; k++)\n            {\n                for (int j = 0; t && j < 3; j++)\n                {\n                    if (last_p[k] == 2 && last_p[j] == 1)\n                    {\n                        swap(last_p[k], last_p[j]);\n                        t = 0;\n                    }\n                }\n            }\n        }\n        else\n        {\n            for (int j = 0; j < 3; j++) last_p[j] = (last_p[j] + 1) % 3;\n        }\n    }\n    for (int i = 1; i < n; i++)\n    {\n        pair<vector<int>, vector<int> > gg = solve(last_p, last_w);\n        last_p = gg.first;\n        last_w = gg.second;\n    }\n    #ifdef LOCAL\n    //return 0;\n    #endif // LOCAL\n    for (int i = 0; i < last_p.size(); i++)\n    {\n        cout << last_p[i] << \" \";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nint lim=1,f[600001],n,nl,top,fin[1000001];\nchar T[1000001],ope[1000001];\nvoid write(int x){\n\tif(x>9)write(x/10);\n\tputchar((x%10)+'0');\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tint v1=1,v2=1;\n\tfor(int i=1;i<=n;i++)lim*=3;\n\tfor(int i=1;i<=(n>>1);i++)v1*=3;\n\tfor(int i=1+(n>>1);i<=n;i++)v2*=3;\n\tfor(int i=0;i<lim;i++)f[i]=f[i/3]*3+(3-i%3)%3;\n\tscanf(\"%s\",T+1);\n\tnl=strlen(T+1);\n\tfor(int i=0;i<v1;i++){\n\t\tint tem=i;\n\t\ttop=0;\n\t\tfor(int j=1;j<=nl;j++)\n\t\t\tif(T[j]=='S'){\n\t\t\t\ttem=f[tem];\n\t\t\t\t(ope[top]=='S')?--top:ope[++top]='S';\n\t\t\t}\n\t\t\telse{\n\t\t\t\t++tem;\n\t\t\t\tif(tem==v1)ope[++top]='R',tem=0;\n\t\t\t}\n\t\tfor(int j=0;j<v2;j++){\n\t\t\tint tem2=j;\n\t\t\tfor(int k=1;k<=top;k++)\n\t\t\t\tif(ope[k]=='S')tem2=f[tem2];\n\t\t\t\telse if(ope[k]=='R')\n\t\t\t\t\tif((++tem2)==v2)tem2=0;\n\t\t\tfin[i+j*v1]=tem2*v1+tem;\n\t\t}\n\t}\n\tfor(int i=0;i<lim;i++)write(fin[i]),putchar(' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint binary(int bina){\n    int ans = 0;\n    for (int i = 0; bina>0 ; i++)\n    {\n        ans = ans+(bina%3)*pow(10,i);\n        bina = bina/3;\n    }\n    return ans;\n}\n\nint binary1(int bina){\n    int ans = 0;\n    for (int i = 0; bina>0 ; i++)\n    {\n        ans = ans+(bina%10)*pow(3,i);\n        bina = bina/10;\n    }\n    return ans;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  string t;\n  cin >> t;\n  vector<int> a;\n  \n  for(int i = 0; i < pow(3,n); i++){\n    a.at(i) = i;\n  }\n  \n  for(int i = 0; i < t.size(); i++){\n    if(t.at(i)=='S'){\n      for(int j = 0; j < pow(3,n); j++){\n        a.at(j) = binary(j);\n        string s = to_string(a.at(j));\n        for(int k = 0; k < s.size(); k++){\n        if(s.at(k)=='1'){\n          s.at(k) = '2';\n        }\n        else if(s.at(k)=='2'){\n          s.at(k)='1';\n        }\n        else{\n          s.at(k)='0';\n        }\n        a.at(j) = stoi(s);\n        a.at(j)=binary1(j);\n      }\n    }\n    }\n    else{\n      for(int j = 0; j < pow(3,n)-1; j++){\n        a.at(j) += 1;\n      }\n      a.at(pow(3,n))=0;\n    }\n  }\n  for(int j = 0; j < pow(3,n); j++){\n    cout << a.at(j) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAX_NODES = int(2e6) + 10;\n\nstruct Trie {\n\tint val;\n\tbool rev;\n\tstd::vector<std::pair<int, int> > go;\n\tvoid push() {\n\t\tif (!rev || go.empty())\n\t\t\treturn;\n\t\trev = 0;\n\t\tint p1, p2;\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tif (go[i].first == 1)\n\t\t\t\tp1 = i;\n\t\t}\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tif (go[i].first == 2)\n\t\t\t\tp2 = i;\n\t\t}\n\t\t// std::cout<<p1<<\" \"<<p2<<std::endl;\n\t\tstd::swap(go[p1].first, go[p2].first);\n\t}\n\tvoid debug(int id) {\n\t\tstd::cout << id << \": \" << std::endl;\n\t\tfor (int i = 0; i < 3; ++i)\n\t\t\tstd::cout << go[i].first << \" \" << go[i].second << std::endl;\n\t}\n} trie[MAX_NODES];\n\nint n, base, trie_tot = 1;\nint pow_3[20], ans[MAX_NODES];\n\nvoid build(int cur, int dep, int val) {\n\tif (dep == base + 1) {\n\t\ttrie[cur].val = val;\n\t\treturn;\n\t}\n\tfor (int i = 0; i < 3; ++i) {\n\t\ttrie[cur].go.emplace_back(i, ++trie_tot);\n\t\tbuild(trie_tot, dep + 1, val + pow_3[dep - 1] * i);\n\t}\n\t// trie[cur].debug(cur);\n}\n\nvoid modify(int cur) {\n\t// std::cout<<cur<<std::endl;\n\tif (trie[cur].go.empty())\n\t\treturn;\n\t// trie[cur].debug(cur);\n\tif (trie[cur].rev) {\n\t\ttrie[cur].push();\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t// std::cout<<i<<std::endl;\n\t\t\ttrie[trie[cur].go[i].second].rev ^= 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < 3; ++i) {\n\t\t(++trie[cur].go[i].first) %= 3;\n\t\tif (!trie[cur].go[i].first)\n\t\t\tmodify(trie[cur].go[i].second);\n\t}\n}\n\nvoid dfs(int cur, int p, int dep) {\n\tif (trie[cur].go.empty()) {\n\t\tans[trie[cur].val] = p;\n\t} else {\n\t\tif (trie[cur].rev) {\n\t\t\ttrie[cur].push();\n\t\t\tfor (int i = 0; i < 3; ++i)\n\t\t\t\ttrie[trie[cur].go[i].second].rev ^= 1;\n\t\t}\n\t\tfor (int i = 0; i < 3; ++i) \n\t\t\tdfs(trie[cur].go[i].second, p + pow_3[dep - 1] * trie[cur].go[i].first, dep + 1);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &base);\n\tpow_3[0] = 1;\n\tfor (int i = 1; i <= base; ++i) {\n\t\tpow_3[i] = pow_3[i - 1] * 3;\n\t}\n\tn = pow_3[base];\n\tbuild(1, 1, 0);\n\tstd::string opt;\n\tstd::cin >> opt;\n\tfor (auto c : opt) {\n\t\t// std::cout<<c<< \"\\n\";\n\t\tif (c == 'S')\n\t\t\ttrie[1].rev ^= 1;\n\t\telse\n\t\t\tmodify(1);\n\t}\n\tdfs(1, 0, 1);\n\tfor (int i = 0; i < n; ++i) {\n\t\tprintf(\"%d \", ans[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//BadWaper gg\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<deque>\n#include<bitset>\n#include<map>\n#include<set>\n#define inf 1e9\n#define eps 1e-6\n#define mp make_pair\n#define N 100010\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ninline ll read()\n{\n\tchar ch=getchar();\n\tll s=0,w=1;\n\twhile(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}\n\treturn s*w;\n}\nint val[N][3],ch[N][3],tot,lazy[N];\nint n;char s[N];\nint ans[N];\ninline void build()\n{\n\ttot=1;for(register int i=1;i<=n+1;i++)tot*=3;\n\ttot=(tot-1)/2;\n\tfor(register int i=1;i<=tot;i++)\n\t{\n\t\tif(i*3<=tot)\n\t\t{\n\t\t\tch[i][0]=i*3-1;ch[i][1]=i*3;ch[i][2]=i*3+1;\n\t\t\tval[i][0]=0;val[i][1]=1;val[i][2]=2;\n\t\t}\n\t}\n}\ninline void pushdown(int now)\n{\n\tif(lazy[now])\n\t{\n\t\tlazy[ch[now][0]]^=1;lazy[ch[now][1]]^=1;lazy[ch[now][2]]^=1;\n\t\tint x=0,y=0;\n\t\tfor(register int i=0;i<3;i++)\n\t\t{\n\t\t\tif(val[now][i]==1)x=ch[now][i];\n\t\t\tif(val[now][i]==2)y=ch[now][i];\n\t\t}\n\t\tswap(val[now][x],val[now][y]);\n\t}\n}\nvoid update(int now)\n{\n\tpushdown(now);if(now*3>tot)return ;\n\tfor(register int i=0;i<3;i++)\n\t{\n\t\tval[now][i]++;\n\t\tif(val[now][i]==3)\n\t\t{\n\t\t\tval[now][i]=0;\n\t\t\tupdate(ch[now][i]);\n\t\t}\n\t}\n}\nvoid dfs(int now,int v,int p)\n{\n\tif(now*3>tot){ans[++ans[0]]=v;return ;}\n\tfor(register int i=0;i<3;i++)dfs(ch[now][i],v+val[now][i]*p,p*3);\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read();scanf(\"%s\",s+1);\n\tbuild();\n\tint len=strlen(s+1);\n\tfor(register int i=1;i<=len;i++)\n\t{\n\t\tif(s[i]=='S')update(1);\n\t\telse lazy[1]^=1;\n\t}\n\tdfs(1,0,1);\n\tfor(register int i=1;i<=ans[0];i++)printf(\"%d \",ans[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nchar S[63]=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\nint n,len,stk[2][201],top[2];\nbool good[2][201];\nint main(){\n\tint mn=0x7f7f7f7f,mx=0;\n\tfor(int i=0,tem;i<62;i++){\n\t\tprintf(\"? %c\\n\",S[i]);\n\t\tfflush(stdout);\n\t\tscanf(\"%d\",&tem);\n\t\tmn=std::min(mn,tem);\n\t\tmx=std::max(mx,tem);\n\t}\n\tif(mx==0)len=mn+1;\n\telse len=(mn+mx)>>1;\n\tint t=0;\n\tfor(int i=0;i<62;i++){\n\t\ttop[(i&1)^1]=0;\n\t\tfor(int j=1;j<=top[i&1];j++){\n\t\t\tfor(;!good[i&1][j];){\n\t\t\t\tprintf(\"? \");\n\t\t\t\tint nowlen=0;\n\t\t\t\tfor(int k=1;k<=top[(i&1)^1];k++)putchar(S[stk[(i&1)^1][k]]),++nowlen;\n\t\t\t\tputchar(S[i]),++nowlen;\n\t\t\t\tfor(int k=j;k<=top[i&1];k++)putchar(S[stk[i&1][k]]),++nowlen;\n\t\t\t\tputchar('\\n');\n\t\t\t\tfflush(stdout);\n\t\t\t\tint tem=0;\n\t\t\t\tscanf(\"%d\",&tem);\n\t\t\t\tif(tem==len-nowlen){\n\t\t\t\tputchar('*');\n\t\t\t\t\tstk[(i&1)^1][++top[(i&1)^1]]=i;\n\t\t\t\t\tgood[(i&1)^1][top[(i&1)^1]]=0;\n\t\t\t\t}\n\t\t\t\telse if(tem==len-nowlen+1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tgood[i&1][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstk[(i&1)^1][++top[(i&1)^1]]=stk[i&1][j];\n\t\t\tgood[(i&1)^1][top[(i&1)^1]]=good[i&1][j];\n\t\t}\n\t\tfor(;top[(i&1)^1]<len;){\n\t\t\tprintf(\"? \");\n\t\t\tint nowlen=0;\n\t\t\tfor(int k=1;k<=top[(i&1)^1];k++)putchar(S[stk[(i&1)^1][k]]),nowlen++;\n\t\t\tputchar(S[i]),nowlen++;\n\t\t\tputchar('\\n');\n\t\t\tfflush(stdout);\n\t\t\tint tem=0;\n\t\t\tscanf(\"%d\",&tem);\n\t\t\tif(tem==len-nowlen){\n\t\t\t\tstk[(i&1)^1][++top[(i&1)^1]]=i;\n\t\t\t\tgood[(i&1)^1][top[(i&1)^1]]=0;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tif(top[(i&1)^1]==len){\n\t\t\tt=(i&1)^1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"! \");\n\tfor(int i=1;i<=top[t];i++)putchar(S[i]);\n\tputchar('\\n');\n\tfflush(stdout);\n}"
  },
  {
    "language": "C++",
    "code": "//Awwawa! Dis cold yis ratten buy tEMMIE!\n#include <bits/stdc++.h>\n#define ll long long\n#define maxn 2000005 /*rem*/\n#define mod 998244353\n#define db double\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n#define pi pair<int, int>\n#define fi first\n#define se second\n\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,true:false;}\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,true:false;}\n\nusing namespace std;\nll ksm(ll a, ll b) {\n   if (!b) return 1;\n   ll ns = ksm(a, b >> 1);\n   ns = ns * ns % mod;\n   if (b & 1) ns = ns * a % mod;\n   return ns;\n}\nconst int S = 10000005;\nint nx[S][3];\nint tr[S];\nint rt = 1;\nint idcnt = 2;\nint tp[S];\nvoid down(int k) {\n\tif (tp[k]) {\n\t\tswap(nx[k][1], nx[k][2]);\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\ttp[nx[k][j]] ^= 1;\n\t\ttp[k] = 0;\n\t}\n}\nvoid pl(int k) {\n\tif (tr[k] != -1) return ;\n\tdown(k);\n\tint r[3] = {nx[k][0], nx[k][1], nx[k][2]};\n\tfor (int j = 0; j < 3; j++)\n\t\tnx[k][j] = r[(j + 2) % 3];\n\tpl(nx[k][0]);\n}\nint pw[maxn];\nchar u[maxn];\nint mr[maxn], p[maxn];\nint main() {\n\tint n;\n\tcin >> n;\n\tpw[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tpw[i] = pw[i - 1] * 3;\n\tmemset(tr, -1, sizeof(tr));\n\tfor (int i = 0; i < pw[n]; i++) {\n\t\tint pl = rt, cur = i;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint ne = cur % 3;\n\t\t\tcur /= 3;\n\t\t\tif (!nx[pl][ne]) nx[pl][ne] = idcnt++;\n\t\t\tpl = nx[pl][ne];\n\t\t}\n\t\ttr[pl] = i;\n\t}\n//\tcout << idcnt << endl;\n\tscanf(\"%s\", u);\n\tint l = strlen(u);\n\tfor (int j = 0; j < l; j++) {\n\t\tif (u[j] == 'S') tp[rt] ^= 1;\n\t\telse \n\t\t\tpl(rt);\n\t}\n\tfor (int i = 0; i < pw[n]; i++) {\n\t\tint pl = rt, cur = i;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint ne = cur % 3; cur /= 3;\n\t\t\tdown(pl);\n\t\t\tpl = nx[pl][ne];\n\t\t}\n\t\tmr[i] = tr[pl];\n\t\tp[mr[i]] = i;\n\t}\n\tfor (int j = 0; j < pw[n]; j++)\n\t\tprintf(\"%d \", p[j]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long LL;\n\nint getRandom() {\n    return uniform_int_distribution<int>(INT_MIN, INT_MAX)(rng);\n}\n\ntypedef struct item * pitem;\nstruct item {\n    int prior, value, cnt;\n    bool rev;\n\n    item(int value):prior(getRandom()), value(value) {\n        cnt = 0;\n        rev = 0;\n        l = r = nullptr;\n    }\n\n    pitem l, r;\n};\n\nmap< int , int >p3;\n\nnamespace Treap {\n    int cnt (pitem it) {\n        return it != nullptr? it->cnt : 0;\n    }\n\n    void upd_cnt (pitem it) {\n        if (it!=nullptr) {\n            it->cnt = cnt(it->l) + cnt(it->r) + 1;\n        }\n    }\n\n    void push(pitem it);\n\n    void merge (pitem & t, pitem l, pitem r) {\n        push (l);\n        push (r);\n        if (l==nullptr || r==nullptr)\n            t = (l!=nullptr) ? l : r;\n        else if (l->prior > r->prior)\n            merge (l->r, l->r, r),  t = l;\n        else\n            merge (r->l, l, r->l),  t = r;\n        upd_cnt (t);\n    }\n\n    void split (pitem t, pitem & l, pitem & r, int key, int add = 0) {\n        if (t==nullptr) {\n            l = r = nullptr;\n            return;\n        }\n        push (t);\n        int cur_key = add + cnt(t->l);\n\n        if (key <= cur_key)\n            split (t->l, l, t->l, key, add),  r = t;\n        else\n            split (t->r, t->r, r, key, add + 1 + cnt(t->l)),  l = t;\n        upd_cnt (t);\n    }\n\n    void push (pitem it) {\n        if (it != nullptr && it->rev == true) {\n            auto jt = p3.find(it->cnt);\n            assert(jt != p3.end());\n\n            it->rev = false;\n            if (it->cnt > 1) {\n                int base = it->cnt/3;\n                pitem A, B, C;\n                split(it, A, B, base);\n                split(B, B, C, base);\n                A->rev ^= 1;\n                B->rev ^= 1;\n                C->rev ^= 1;\n                merge(B, C, B);\n                merge(it, A, B);\n            }\n        }\n    }\n\n    void insert (pitem & t, int key, int value) {\n\n        pitem x = new item(value);\n\n        pitem L, R;\n        split(t, L, R, key);\n        merge(L, L, x);\n        merge(t, L, R);\n\n        upd_cnt(t);\n    }\n\n    int erase (pitem & t, int key) {\n        assert(cnt(t) > key);\n\n        pitem L, MID, R;\n        split(t, L, MID, key);\n        split(MID, MID, R, 1);\n        merge(t, L, R);\n        upd_cnt(t);\n\n        int x = MID->value;\n        delete MID;\n\n        return x;\n    }\n\n    void output (pitem t, vector< int >&v) {\n        if (t==nullptr)  return;\n        push (t);\n        output (t->l, v);\n        v.push_back(t->value);\n        output (t->r, v);\n    }\n\n    void output2 (pitem t) {\n        if (t==nullptr)  return;\n        push (t);\n//        cout << \"(\";\n        output2 (t->l);\n        cout << (t->value) << \" \";\n        output2 (t->r);\n//        cout << \")\";\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    pitem root = nullptr;\n\n    int N;\n    cin >> N;\n\n    int sz = 1;\n    p3[1] = 0;\n    for (int i = 1; i <= N; i++) {\n        sz *= 3;\n        p3[sz] = i;\n    }\n\n//    vector< int >swapWith(sz);\n//    for (int i = 0; i < sz; i++) {\n//        vector< int >g(N);\n//        for (int z = 0, base = 1; z < N; z++, base *= 3) {\n//            g[z] = (i/base)%3;\n//        }\n//        int j = 0;\n//        for (int z = N-1; z >= 0; z--) {\n//            j *= 3;\n//            if (g[z]) j += ((g[z]-1)^1)+1;\n//        }\n//        swapWith[i] = j;\n//    }\n\n//    vector< int >truth(sz);\n    for (int i = 0; i < sz; i++) {\n        Treap::insert(root, i, i);\n//        truth[i] = i;\n    }\n\n    string T;\n    cin >> T;\n\n    for (int i = 0; i < T.size(); i++) {\n        if (T[i] == 'S') {\n            root->rev ^= 1;\n\n//            for (int j = 0; j < sz; j++) {\n//                if (swapWith[j] >= j) continue;\n//                swap(truth[j], truth[swapWith[j]]);\n//            }\n        } else {\n            int last = Treap::erase(root, sz-1);\n            Treap::insert(root, 0, last);\n\n//            truth.insert(truth.begin(), truth.back());\n//            truth.pop_back();\n        }\n\n//        cout << \"after \" << T[i] << \" \" << endl;\n//        Treap::output2(root);\n//        cout << endl;\n//        for (int x : truth) cout << x << \" \";\n//        cout << endl;\n    }\n\n    vector< int >v;\n    Treap::output(root, v);\n\n    vector< int >r(sz);\n    for (int i = 0; i < sz; i++) r[v[i]] = i;\n\n    for (int x : r) cout << x << \" \";\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n  * @brief atcoder\n  * @author yao\n  */\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <utility>\n#include <algorithm>\n#include <functional>\n#include <climits>\n#define ft first\n#define sd second\n#ifdef DBG\n#   define dbg_pri(x...) fprintf(stderr,x)\n#else\n#   define dbg_pri(x...) 0\n#   define NDEBUG\n#endif //DBG\n#include <cassert>\n\ntypedef unsigned int uint;\ntypedef long long int lli;\ntypedef unsigned long long int ulli;\n\n#define N 1048576\n\nstruct Treap\n{\n    Treap *l, *r;\n    int v, w;\n    Treap(){}\n    Treap(int _v):l(0),r(0),v(_v),w(1){}\n};\n\nint get_w(Treap *p)\n{\n    return p?p->w:0;\n}\n\nvoid pull(Treap *p)\n{\n    p->w = 1 + get_w(p->l) + get_w(p->r);\n}\n\nTreap* merge(Treap *p, Treap *q)\n{\n    if(!p||!q) return p?p:q;\n    return rand()%(p->w+q->w)<p->w?\n        (p->r = merge(p->r,q), pull(p), p):\n        (q->l = merge(p,q->l), pull(q), q);\n }\n\nstd::pair<Treap*, Treap*> split(Treap *p, int k)\n{\n    if(!p) return {0,0};\n    if(!k) return {0,p};\n    if(p->w<=k) return {p,0};\n    Treap *l, *m, *r;\n    int lw = get_w(p->l);\n    if(lw<k) std::tie(m,r) = split(p->r,k-lw-1), p->r=0, pull(p), l = merge(p,m);\n    else std::tie(l,m) = split(p->l,k), p->l=0, pull(p), r = merge(m,p);\n    return {l,r};\n}\n\nstruct TT\n{\n    static TT pool[N];\n    static int n;\n    TT *l, *m, *r;\n    Treap *p;\n    int w,lz;\n    TT():l(0),r(0),p(0),w(0),lz(0){}\n};\n\nTT TT::pool[N];\nint TT::n = 0;\n\nvoid tt_push(TT *p);\n\nTT* tt_append(TT *p, Treap *q)\n{\n    if(!q) return p;\n    if(!p) p = new(&TT::pool[TT::n++]) TT();\n    tt_push(p);\n    p->w += get_w(q);\n    p->p = merge(p->p,q);\n    return p;\n}\n\n\nTreap* tt_cut(TT *p, int k)\n{\n    if(!p) return 0;\n    tt_push(p);\n    Treap *res = 0;\n    Treap *l;\n    l = tt_cut(p->l,k), k-=get_w(l), res = merge(res,l);\n    l = tt_cut(p->m,k), k-=get_w(l), res = merge(res,l);\n    l = tt_cut(p->r,k), k-=get_w(l), res = merge(res,l);\n    std::tie(l,p->p) = split(p->p, k), res = merge(res,l);\n    p->w -= get_w(res);\n    return res;\n}\n\nvoid tt_push(TT *p)\n{\n    if(!p->lz) return;\n    assert(p->w%3 == 0);\n    int k = p->w/3;\n    Treap *l = p->p;\n    p->p = 0;\n    p->r = tt_append(p->r,l);\n    l = tt_cut(p->r,p->r->w-k);\n    p->m = tt_append(p->m,l);\n    l = tt_cut(p->m,p->m->w-k);\n    p->l = tt_append(p->l,l);\n    assert(p->l->w==k);\n    std::swap(p->l,p->m);\n    p->lz ^= 1;\n    if(k!=1) p->l->lz^=1, p->m->lz^=1, p->r->lz^=1;\n}\n\nchar s[N];\nTreap node[N];\n\nint ans[N];\n\nint main()\n{\n    int n=1,m;\n    scanf(\"%d%s\", &m, s);\n    for(int i=0;i<m;++i) n *= 3;\n    TT *rt = 0;\n    for(int i=n-1;i>=0;--i)\n        node[i] = Treap(i), rt = tt_append(rt, &node[i]);\n    for(int i=0;s[i];++i)\n    {\n        dbg_pri(\"poi 1: %d %c\\n\",i,s[i]);\n        if(s[i] == 'S')\n        {\n            rt->lz ^= 1;\n        }\n        if(s[i] == 'R')\n        {\n            Treap *p = tt_cut(rt,1);\n            rt = tt_append(rt,p);\n        }\n#ifdef DBG\n        for(int i=n-1;i>=0;--i)\n        {\n            Treap *p = tt_cut(rt,1);\n            rt = tt_append(rt,p);\n            ans[i] = p->v;\n        }\n        dbg_pri(\"poi 2:\");\n        for(int i=0;i<n;++i)\n            dbg_pri(\" %d\",ans[i]);\n        dbg_pri(\"\\n\");\n#endif //DBG\n        assert(s[i]=='S' || s[i]=='R');\n    }\n    for(int i=n-1;i>=0;--i)\n    {\n        Treap *p = tt_cut(rt,1);\n        assert(p);\n        ans[p->v] = i;\n    }\n    assert(rt->w == 0);\n    for(int i=0;i<n;++i)\n        printf(\"%d%c\", ans[i], i==n-1?'\\n':' ');\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint p[600010],n,m;\nchar s[200010];\n\ninline int rd()\n{\n\tint x=0;char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\ninline void print(int x)\n{\n\tstatic char s[233];\n\tif (!x) { putchar('0');putchar(' ');return; }\n\tint tot=0;\n\tfor (;x;x/=10) s[++tot]=x%10+'0';\n\tfor (;tot;tot--) putchar(s[tot]);\n\tputchar(' ');\n}\n\nint ch[10000010][3],id[10000010],tot=1;\nbool tag[10000010];\n\ninline void pushdown(const int &o)\n{\n\tif (!tag[o]) return;\n\tswap(ch[o][1],ch[o][2]);\n\ttag[ch[o][0]]^=1;tag[ch[o][1]]^=1;tag[ch[o][2]]^=1;\n\ttag[o]=false;\n}\n\ninline void work()\n{\n\tint now=1;\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tpushdown(now);\n\t\tint h0=ch[now][0],h1=ch[now][1],h2=ch[now][2];\n\t\tch[now][0]=h2;ch[now][1]=h0;ch[now][2]=h1;\n\t\tnow=ch[now][0];\n\t}\n}\n\nint main()\n{\n\tm=rd();n=1;\n\tfor (int i=1;i<=m;i++) n*=3;\n\tfor (int i=0;i<n;i++)\n\t{\n\t\tint now=1,x=i;\n\t\tfor (int j=1;j<=m;j++)\n\t\t{\n\t\t\tint hh=x%3;x/=3;\n\t\t\tif (!ch[now][hh]) ch[now][hh]=++tot;\n\t\t\tnow=ch[now][hh];\n\t\t}\n\t\tid[now]=i;\n\t}\n\tscanf(\"%s\",s+1);\n\tint len=strlen(s+1);\n\tfor (int i=1;i<=len;i++)\n\t{\n\t\tif (s[i]=='S') tag[1]^=1;\n\t\telse work();\n\t}\n\tfor (int i=0;i<n;i++)\n\t{\n\t\tint now=1,x=i;\n\t\tfor (int j=1;j<=m;j++) pushdown(now),now=ch[now][x%3],x/=3;\n\t\tp[id[now]]=i;\n\t}\n\tfor (int i=0;i<n;i++) print(p[i]);\n\tputchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nvector<int> dp(map<string, vector<int>>& next, string T, int pow3N){\n  auto it = next.find(T);\n  if(it!=next.end()){\n    return it->second;\n  }\n\n  int ii=1;\n  while(ii*2<T.size()) ii*=2;\n \n  auto rule1 = dp(next, T.substr(0, ii), pow3N);\n  auto rule2 = dp(next, T.substr(ii), pow3N);\n \n  next[T] = vector<int>(pow3N);\n  for(int ii=0; ii<pow3N; ii++){\n    next[T][ii] = rule2[rule1[ii]];\n  }\n  return next[T];\n}\n\nint main(){\n  int N;\n  string T;\n  cin >> N >> T;\n  int pow3N = pow(3, N);\n  map<string, vector<int>> next;\n  next[\"S\"] = vector<int>(pow3N);\n  next[\"R\"] = vector<int>(pow3N);\n \n  for(int ii=0; ii<pow3N; ii++){\n    int tmp=ii;\n    int jj=0;\n    int aa=1;\n    while(tmp){\n      int kk = tmp % 3;\n      tmp = (tmp - kk) / 3;\n      if(kk==1){\n        kk=2;\n      }else if(kk==2){\n        kk=1;\n      }\n      jj+=kk*aa;\n      aa*=3;\n    }\n    next[\"S\"][ii] = jj;\n    next[\"R\"][ii] = ii+1;\n  }\n  next[\"R\"][pow3N-1] = 0;\n\n  dp(next, T, pow3N);\n \n  for(auto& pos : next[T]){\n    cout << pos << \" \";\n  }\n  cout << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*input\n2\nRRSRR\n*/\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef tree<long long, null_type, less_equal<long long>, rb_tree_tag, tree_order_statistics_node_update> indexed_set;\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n//order_of_key #of elements less than x\n// find_by_order kth element\ntypedef long long int ll;\n#define ld double\n#define pii pair<ll,ll>\n#define f first\n#define s second\n#define pb push_back\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REP1(i,n) for(int i=1;i<=n;i++)\n#define FILL(n,x) memset(n,x,sizeof(n))\n#define ALL(_a) _a.begin(),_a.end()\n#define sz(x) (int)x.size()\nconst ll maxn=1e6+5;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=4e18;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=1e9+7;\nconst ld PI=acos(-1);\nconst ld eps=1e-9;\n#define lowb(x) x&(-x)\n#define MNTO(x,y) x=min(x,(__typeof__(x))y)\n#define MXTO(x,y) x=max(x,(__typeof__(x))y)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define MP make_pair\nll mult(ll a,ll b){\n    ll res=0LL;\n    while(b){\n        if(b&1) res=(res+a)%MOD;\n        a=(a+a)%MOD;\n        b>>=1;\n    }\n    return res%MOD;\n}\nll mypow(ll a,ll b){\n    ll res=1LL;\n    while(b){\n        if(b&1) res=res*a%MOD;\n        a=a*a%MOD;\n        b>>=1;\n    }\n    return res;\n}\nint ans[maxn];\nint main(){\n    ios::sync_with_stdio(false),cin.tie(0);\n    int n;\n    cin>>n;\n    int z=mypow(3,n);\n    REP(i,z){\n        int x=i;\n        int opp=0;\n        vector<int> v;\n        while(x>0){\n            if(x%3==1) v.pb(2);\n            else if(x%3==2) v.pb(1);\n            else v.pb(0);\n            x/=3;\n        }\n        reverse(ALL(v));\n        REP(i,sz(v)) opp=opp*3+v[i];\n        ans[i]=opp;\n    }\n    string s;\n    cin>>s;\n    string nw=\"\";\n    vector<int> v;\n    for(int i=0;i<sz(s);){\n        if(s[i]=='S'){\n            int c=i;\n            while(i<sz(s) and s[i]=='S') ++i;\n            if((i-c)%2) v.pb(-1);\n        }\n        else{\n            int c=i;\n            while(i<sz(s) and s[i]=='R') ++i;\n            v.pb(i-c);\n        }\n    }\n    REP(i,z){\n        int cur=i;\n        for(int x:v){\n            if(x>0){\n                cur+=x;\n                if(cur>=z) cur%=z;\n            }\n            else cur=ans[cur];\n        }\n        cout<<cur<<' ';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n// headers {{{\nusing namespace std;\n// using namespace rel_ops;\n \ntypedef long long int64;\ntypedef unsigned long long uint64;\nconst double pi=acos(-1.0);\nconst double eps=1e-11;\nconst int INF=0x7FFFFFFF;\ntemplate<class T> inline bool checkmin(T &a,T b){return b<a?a=b,1:0;}\ntemplate<class T> inline bool checkmax(T &a,T b){return b>a?a=b,1:0;}\ntemplate<class T> inline T sqr(T x){return x*x;}\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<PII> VII;\n#define MP(A,B) make_pair(A,B)\n#define PB(X) push_back(X)\n#define mem(a,b) memset(a, b, sizeof(a))\n#define clr(a) memset(a, 0, sizeof(a))\n#define rep(i,n) for(int i=0; i<(int)n; i++)\n#define repit(i,v) for(typeof(v.begin()) i=v.begin(); i!=v.end(); i++)\n#define iter(v) typeof(v.begin())\n#define ff first\n#define ss second\n#ifdef LOCAL\n#define dbg(args...) printf(args); //##__VA_ARGS__\n#define dout cout\n#define out(x) (cout<<#x<<\": \"<<x<<endl)\ntemplate<class T>void show(T a, int n){for(int i=0; i<n; ++i) cout<<a[i]<<' '; cout<<endl;}\ntemplate<class T>void show(T a, int r, int l){for(int i=0; i<r; ++i)show(a[i],l);cout<<endl;}\n#else\n#define dbg(...)\n#define dout if(true);else cout\n#define out(...)\n#define show(...)\n#endif\n// }}}\n\nstruct B {\n    B* p[3] = {};\n    int idx;\n    bool rev = false;\n    void push() {\n        for (auto c : p) if (rev && c) c->reverse();\n        rev = 0;\n    }\n    void reverse() {\n        rev ^= 1;\n        swap(p[1], p[2]);\n    }\n};\n\nint main() {\n    // ios_base::sync_with_stdio(false);\n    // cin.tie(NULL);\n    // cout.tie(NULL); \n    int N;\n    while (cin >> N) {\n\t\tint tot = 1;\n        rep(i, N) tot *= 3;\n        B root;\n        rep(i, tot) {\n            B* s = &root;\n            int c = i;\n            rep(j, N) {\n                int k = c % 3; c /= 3;\n                if (!s->p[k]) s->p[k] = new B();\n                s = s->p[k];\n            }\n            s->idx = i;\n        }\n        string t; cin >> t;\n        rep(i, t.length()) {\n            if (t[i] == 'S') root.reverse();\n            else {\n                B* c = &root;\n                rep(i, N) {\n                    c->push();\n                    B* tmp = c->p[2];\n                    c->p[2] = c->p[1];\n                    c->p[1] = c->p[0];\n                    c->p[0] = tmp;\n                    c = c->p[0];\n                }\n            }\n        }\n        VI pos(tot);\n        rep(i, tot) {\n            B* s = &root;\n            int c = i;\n            rep(j, N) {\n                int k = c % 3; c /= 3;\n                s = s->p[k];\n            }\n            pos[s->idx] = i;\n        }\n        rep(i, tot)\n            cout << pos[i] << (i + 1 == tot ? '\\n' : ' ');\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string>\n#include<cmath>\n\nusing namespace std;\n\nint sch(int n){\n    int out=0,tmp,count=0;\n    while(n != 0){\n        tmp = n % 3;\n        if(tmp==1){\n            out += 2*pow(3,count);\n        }else if(tmp==2){\n            out += pow(3,count);\n        }\n        count++;\n        n /= 3;\n    }\n    return out;\n}\n\nint main(){\n    int N,p,*table,size;\n    string T;\n    cin >> N;\n    cin >> T;\n    size = int(pow(3,N));\n    table = new int[size];\n    for(int i=0;i<size;i++){\n        table[i] = sch(i);\n    }\n    for(int i=0;i<size;i++){\n        p=i;\n        for(int j=0;j<T.length();j++){\n            if(T[j] == 'S'){\n                if(T[j+1] == 'S') j++;\n                else p = table[p];\n            }else{\n                p++;\n                if(p==size) p=0;\n            }\n        }\n        cout << p << ' ';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxN = 6e5 + 10;\n\nint n, len, cnt, root;\nint ch[maxN + 1][3], a[maxN + 1];\nint rev[maxN + 1], pw[15], ans[maxN + 1];\nchar s[maxN + 1];\n\ninline void reverse(int x) \n{ \n\tif(!x) return;\n\tswap(ch[x][1], ch[x][2]);\n\trev[x] ^= 1;\n}\n\ninline void pushdown(int x)\n{\n\tif(!rev[x]) return;\n\treverse(ch[x][0]);\n\treverse(ch[x][1]);\n\treverse(ch[x][2]);\n\trev[x] = 0;\n}\n\ninline void insert(int &node, int x, int k)\n{\n\tif(!node) node = ++ cnt;\n\tif(k == n) { a[node] = x; return; }\n\tint d = x / pw[k] % 3;\t\n\tinsert(ch[node][d], x, k + 1);\n}\n\ninline void change(int node)\n{\n\tif(!node) return;\n\tpushdown(node);\n\tchange(ch[node][2]);\n\tswap(ch[node][1], ch[node][2]); \n\tswap(ch[node][0], ch[node][1]);\n}\n\ninline void dfs(int node, int k, int x)\n{\n\tif(!node) return;\n\tif(k == n) { ans[ a[node] ] = x; return; }\n\tpushdown(node);\n\tdfs(ch[node][0], k + 1, x);\n\tdfs(ch[node][1], k + 1, x + pw[k]);\n\tdfs(ch[node][2], k + 1, x + 2 * pw[k]);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", s + 1);\n\tlen = strlen(s + 1);\n\n\tpw[0] = 1;\n\tfor(int i = 1; i <= n; i++) pw[i] = pw[i - 1] * 3;\n\n\tfor(int i = 0; i < pw[n]; i++) insert(root, i, 0);\n\n\tfor(int i = 1; i <= len; i++)\n\t\tif(s[i] == 'S') reverse(root);\n\t\telse change(root);\n\n\tdfs(root, 0, 0);\n\t\n\tfor(int i = 0; i < pw[n]; i++) printf(\"%d \", ans[i]);\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2,unroll-loops\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing vi = vector<int>;\nusing ll = long long;\nint maxn = 531441, B, C;\nint n, p[531441], f[531441];\nint rev(int a) {\n\tint r = 0, c = 1;\n\twhile(c < maxn) {\n\t\tif(a%3) r +=(3 - (a%3))*c;\n\t\tc*=3,a/=3;\n\t}\n\treturn r;\n}\n\nint s = 0;\nvector<int> small[729];\nint id[531441], lup[531441], u = 0;\n\nvoid add() {\n\ts = (s + B - 1)%B;\n\tfor(auto i : small[s]) {\n\t\tif(lup[i] != u) {\n\t\t\tif((lup[i]^u)&1) id[i] = f[id[i]];\n\t\t\tlup[i] = u;\n\t\t}\n\t\tid[i] = (id[i] + 1)%C;\n\t}\n}\n\nvoid flip() {\n\tu++;\n\tfor(int i = 0; i < B; i++) {\n\t\tif(f[i] <= i) {\n\t\t\tswap(small[(s+i)%B], small[(s+f[i])%B]);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tstring t;\n\tcin >> n >> t;\n\tmaxn = B = 1;\n\tfor(int i = 0; i < n; i++) maxn *= 3;\n\tfor(int i = 0; i < n/2; i++) B *= 3;\n\tC = maxn/B;\n\tfor(int i = 0; i < maxn; i++) {\n\t\tf[i] = rev(i);\n\t\tsmall[i%B].push_back(i);\n\t\tid[i] = i/B;\n\t}\n\t\n\tfor(auto i : t) {\n\t\tif(i == 'R') add();\n\t\telse flip();\n\t}\n\tfor(int i = 0; i < B; i++)\n\t\tfor(auto j : small[i]) p[j] += (B+i-s)%B;\n\tfor(int i = 0; i < maxn; i++) p[i] += B*id[i];\n\tfor(int i = 0; i < maxn; i++) cout << p[i] << \" \";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n\n//#define putchar_unlocked putchar\n\nchar T[500005];\nint res[531443];\n\n// Based on editorial solution\nint D[13][531443]; // one digit at a time, with digit 0 representing the ones place\nint W[13][531443];\nint lastUpdated[13][531443];\n\nint x[11];\ninline void putInt(int i){\n    if(i==0){putchar_unlocked('0');}\n    else{\n    int count1=0;\n    while(i>0){\n        x[count1++]=i%10;\n        i/=10;\n    }\n    for(int j=count1-1;j>=0;j--){\n        putchar_unlocked(48+x[j]);\n    }\n    }\n    putchar_unlocked(' ');\n}\n\nint N;\n\ninline void update(int n, int indx, int cntS){\n    if( ((cntS&1) != (lastUpdated[n][indx]&1)) && D[n][indx]){\n        // conduct salsa\n        D[n][indx] = 3-D[n][indx];\n    }\n    // update the lastUpdated index\n    lastUpdated[n][indx] = cntS;\n}\n\nint pow3[16];\n\nint main(){\n    scanf(\"%d\", &N);\n    scanf(\" %s\", T);\n\n    int M = strlen(T);\n\n    pow3[0] = 1;\n    for(int i = 1; i <= N; i ++){\n        pow3[i] = pow3[i-1]*3;\n    }\n\n    //memset(W, 0, sizeof(W));\n    for(int n = 1; n <= N; n ++){\n        //printf(\"ok\");\n        for(int j = 0; j < pow3[n-1]; j ++){\n            D[n][j] = 0;\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        for(int j = pow3[n-1]; j < (pow3[n-1]<<1); j ++){\n            D[n][j] = 1;\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        for(int j = (pow3[n-1]<<1); j < pow3[n]; j ++){\n            D[n][j] = 2;\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        W[n][0] = pow3[n]-1;\n    }\n\n    //memset(lastUpdated, 0, sizeof(lastUpdated));\n    int cntS2 = 0;\n    for(int n = 1; n <= N; n ++){\n        int cntS = 0;\n        for(int i = 0; i < M; i ++){\n            int indx0 = W[n-1][i];\n            int indx1 = W[n-1][i]+pow3[n-1];\n            int indx2 = W[n-1][i]+(pow3[n-1]<<1);\n\n            if(indx1 >= pow3[n]){indx1 -= pow3[n];}\n            if(indx2 >= pow3[n]){indx2 -= pow3[n];}\n\n            update(n, indx0, cntS+(T[i]=='S'));\n            update(n, indx1, cntS+(T[i]=='S'));\n            update(n, indx2, cntS+(T[i]=='S'));\n            if(D[n][indx0] == 2){\n                W[n][i] = indx0;\n            }else if(D[n][indx1] == 2){\n                W[n][i] = indx1;\n            }else{\n                W[n][i] = indx2;\n            }\n\n            if(T[i] == 'R'){\n                D[n][indx0] = (D[n][indx0]+1);\n                D[n][indx1] = (D[n][indx1]+1);\n                D[n][indx2] = (D[n][indx2]+1);\n                if(D[n][indx0] == 3){D[n][indx0] = 0;}\n                if(D[n][indx1] == 3){D[n][indx1] = 0;}\n                if(D[n][indx2] == 3){D[n][indx2] = 0;}\n                lastUpdated[n][indx0] = cntS;\n                lastUpdated[n][indx1] = cntS;\n                lastUpdated[n][indx2] = cntS;\n            }else{\n                cntS ++;\n            }\n\n            //printf(\"W[%d][%d]=%d\\n\", n, i+1, W[n][i+1]);\n        }\n\n        cntS2 = cntS;\n    }\n\n    for(int n = 1; n <= N; n ++){\n        for(int i = 0; i < pow3[n]; i ++){\n            update(n, i, cntS2);\n        }\n\n        int cnt = 0;\n        for(int i = 0; i < pow3[N]; i ++){\n            res[i] += D[n][cnt++]*pow3[n-1];\n            if(cnt == pow3[n]){cnt = 0;}\n        }\n    }\n\n    for(int i = 0; i < pow3[N]; i ++){\n        /*int temp = 0;\n        for(int n = 1; n <= N; n ++){\n            temp += D[n][i%pow3[n]]*pow3[n-1];\n        }*/\n        //putInt(temp);\n        putInt(res[i]);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nstruct Problem {\npublic:\n\n\tconst string C = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n\tstatic const UL KN = 62;\n\tUL CN[62];\n\tUL L;\n\tUL unknowns;\n\tstring ans;\n\tUL Query = 0;\n\tUL tg[2] = {};\n\n\tvoid Solve2(char c, UL n, UL r = ~0u, UL s = 0) {\n\t\tif (r == ~0u) { r = unknowns; }\n\t\tif (n == 0) return;\n\t\tif (r == n) {\n\t\t\trep(i, n) {\n\t\t\t\tans[ans.find('?', s)] = c;\n\t\t\t\tunknowns--;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tUL m = r >> 1;\n\t\tUL t = s; rep(i, m) t = ans.find('?', t) + 1;\n\t\tstring tmp = ans;\n\t\tfor (UL i = 0; i < L; i++) {\n\t\t\tif (tmp[i] == '?') {\n\t\t\t\tif (s <= i && i < t) tmp[i] = c;\n\t\t\t\telse tmp[i] = C[tg[0]];\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"? %s\\n\", tmp.c_str()); fflush(stdout);\n\t\tUL res; scanf(\"%d\", &res);\n\t\tres = unknowns - res;\n\t\tSolve2(c, res, m, s);\n\t\tSolve2(c, n - res, r - m, t);\n\t}\n\n\tvoid Solve() {\n\t\trep(i, KN) {\n\t\t\tprintf(\"? \");\n\t\t\trep(j, 128) printf(\"%c\", C[i]);\n\t\t\tprintf(\"\\n\"); fflush(stdout);\n\t\t\tUL res; scanf(\"%d\", &res);\n\t\t\tCN[i] = 128 - res;\n\t\t\tL += 128 - res;\n\t\t}\n\t\tans.assign(L, '?');\n\t\tunknowns = L;\n\n\t\t//if (CN[0] > CN[1]) { tg[0] = 0; tg[1] = 1; }\n\t\t//else { tg[0] = 1; tg[1] = 0; }\n\t\t//for (UL i = 2; i < KN; i++) {\n\t\t//\tUL p = i;\n\t\t//\tif (CN[p] > CN[tg[0]]) swap(p, tg[0]);\n\t\t//\tif (CN[p] > CN[tg[1]]) swap(p, tg[1]);\n\t\t//}\n\n\t\ttg[0] = 0; tg[1] = 1;\n\n\t\trep(i, L) {\n\t\t\tprintf(\"? \");\n\t\t\trep(j, L) printf(\"%c\", (j == i) ? C[tg[1]] : C[tg[0]]);\n\t\t\tprintf(\"\\n\"); fflush(stdout);\n\t\t\tUL res; scanf(\"%d\", &res);\n\t\t\tif (res > L - CN[tg[0]]) { ans[i] = C[tg[0]]; unknowns--; }\n\t\t\telse if (res < L - CN[tg[0]]) { ans[i] = C[tg[1]]; unknowns--; }\n\t\t}\n\t\t\n\t\tfor (UL i = 0; i < KN; i++) {\n\t\t\tif (i == tg[0]) continue;\n\t\t\tif (i == tg[1]) continue;\n\t\t\tSolve2(C[i], CN[i]);\n\t\t}\n\n\t\tprintf(\"! %s\\n\", ans.c_str());\n\t\tfflush(stdout);\n\t}\n};\n\nint main() {\n\tunique_ptr<Problem> p(new Problem());\n\tp->Solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\nconst int maxn=15;\nconst int maxpos=531445;\nint n,times[maxn],jump[maxpos],ans[maxpos];\nvector<pair<int,bool> > change;\nvoid init()\n{\n    times[0]=1;\n    for(int i=1;i<=n;i++)\n        times[i]=times[i-1]*3;\n    return;\n}\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    cin>>n;\n    init();\n    string ss;\n    cin>>ss;\n    char last=ss[0];\n    int num=0;\n    for(int i=0;i<(int)ss.length();i++)\n    {\n        if(ss[i]!=last)\n        {\n            change.push_back(make_pair(num,(last=='S')));\n            last=ss[i]; num=1;\n        }\n        else num++;\n    }\n    change.push_back(make_pair(num,(last=='S')));\n    for(int i=0;i<times[n];i++)\n    {\n        int cur=i,now=0;\n        for(int j=n-1;j>=0;j--)\n        {\n            int val=cur/times[j];\n            if(val==2) now+=times[j];\n            if(val==1) now+=2*times[j];\n            cur%=times[j];\n        }\n        jump[i]=now;\n    }\n    for(int i=0;i<times[n];i++)\n    {\n        int now=i;\n        for(int j=0;j<(int)change.size();j++)\n        {\n            if(change[j].second)\n            {\n                if(change[j].first%2)\n                    now=jump[now];\n            }\n            else now=(now+change[j].first)%times[n];\n        }\n        ans[i]=now;\n    }\n    for(int i=0;i<times[n];i++)\n        cout<<ans[i]<<(i==times[n]-1?'\\n':' ');\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n, m;\n \nstruct Node{\n\tint lazy, ch[3], va;\n}p[3030303];\n\n\nint cnt = 1;\n \nvoid ins(int x)\n{\n\tint now = 1;\n\tint _x = x;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tp[now].va = -1;\n\t\tint q = x%3;\n\t\tif(!p[now].ch[q])\n\t\t\tp[now].ch[q] = ++cnt;\n\t\tx /= 3;\n\t\tnow = p[now].ch[q];\n\t}\n\tp[now].va = _x;\n}\nint ans[1010101];\n\nint _3 = 1, sum = 0;\n\nvoid dfs(int now)\n{\n\tif(p[now].lazy)\n\t{\n\t\tswap(p[now].ch[1], p[now].ch[2]);\n\t\tfor(int j = 0; j < 3; j++)\n\t\t\tp[p[now].ch[j]].lazy ^= 1;\n\t\tp[now].lazy = 0;\n\t}\n\tif(p[now].va != -1)\n\t{\n\t\tans[p[now].va] = sum;\n\t\treturn;\n\t}\n\tfor(int j = 0; j < 3; j++)\n\t{\n\t\tsum += _3 * j;\n\t\t_3 *= 3;\n\t\tdfs(p[now].ch[j]);\n\t\t_3 /= 3;\n\t\tsum -= _3 * j;\n\t}\n}\n\nchar s[202020];\nint main()\n{\n\tscanf(\"%d\", &n);\n\tint N = 1;\n\tfor(int i = 0; i < n; i++)\n\t\tN *= 3;\n\tscanf(\"%s\", s);\n\tm = strlen(s);\n\tfor(int i = 0; i < N; i++)\n\t\tins(i);\n\tfor(int j = 0; j < m; j++)\n\t{\n\t\tif(s[j] == 'S')\n\t\t\tp[1].lazy ^= 1;\n\t\telse\n\t\t{\n\t\t\tint now = 1;\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tif(p[now].lazy)\n\t\t\t\t{\n\t\t\t\t\tswap(p[now].ch[1], p[now].ch[2]);\n\t\t\t\t\tfor(int j = 0; j < 3; j++)\n\t\t\t\t\t\tp[p[now].ch[j]].lazy ^= 1;\n\t\t\t\t\tp[now].lazy = 0;\n\t\t\t\t}\n\t\t\t\tint nxt = p[now].ch[2];\n\t\t\t\tp[now].ch[2] = p[now].ch[1];\n\t\t\t\tp[now].ch[1] = p[now].ch[0];\n\t\t\t\tp[now].ch[0] = nxt;\n\t\t\t\tnow = nxt;\n\t\t\t}\n\t\t}\n\t}\n\tdfs(1);\n\tfor(int i = 0; i < N; i++)\n\t\tprintf(\"%d \", ans[i]);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define rng(i,l,r) for(int i=int(l);i<int(r);i++)\n#define rep(i,r) rng(i,0,r)\n#define rrng(i,l,r) for(int i=int(r)-1;i>=int(l);i--)\n#define rrep(i,r) rrng(i,0,r)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#define F first\n#define S second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#define inf INT_MAX/2-100\n#define infl LLONG_MAX/3\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<' '<<#x<<' '<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u>void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u>void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t>using vc=vector<t>;\ntemplate<class t>using vvc=vector<vector<t>>;\n\nusing pi=pair<int,int>;\nusing pl=pair<ll,ll>;\nusing vi=vc<int>;\nusing vl=vc<ll>;\n\n\nll readl(void){\n\tll x;\n\tcin>>x;\n\treturn x;\n}\nint readi(void){\n\tint x;\n\tcin>>x;\n\treturn x;\n}\n\nstring readstr(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=readi(),v[i]+=off;\n\treturn v;\n}\n\nvl readvl(int n,int off=0){\n\tvl v(n);\n\trep(i,n)v[i]=readl(),v[i]+=off;\n\treturn v;\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)cout<<\"\\n\";\n\tif(suc==2)cout<<\" \";\n}\n\ntemplate<class t>\nvoid print(const vc<t>&v,int suc=1){\n\trep(i,si(v))print(v[i],i==int(si(v))-1?1:suc);\n}\n\ntemplate<class t>\nbool inc(t a,t b,t c){\n\treturn !(c<b||b<a);\n}\n\ntemplate<class t>\nvoid compress(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t>\nstruct Compress{\n\tvc<t>v;\n\tCompress()=default;\n\tCompress(const vc<t>&x){\n\t\tadd(x);\n\t}\n\tCompress(const initializer_list<vc<t> >&x){\n\t\tfor(auto &p:x)add(p);\n\t}\n\tvoid add(const t&x){\n\t\tv.eb(x);\n\t}\n\tvoid add(const vc<t>&x){\n\t\tcopy(all(x),back_inserter(v));\n\t}\n\tvoid build(){\n\t\tcompress(v);\n\t}\n\tint get(const t&x)const{\n\t\treturn lwb(v,x);\n\t}\n\tvc<t>get(const vc<t>&x)const{\n\t\tvc<t>res(x);\n\t\tfor(auto &p:res)p=get(p);\n\t\treturn res;\n\t}\n\tconst t &operator[](int x)const{\n\t\treturn v[x];\n\t}\n};\nvoid Yes(bool ex=true){\n\tcout<<\"Yes\\n\";\n\tif(ex)exit(0);\n}\nvoid YES(bool ex=true){\n\tcout<<\"YES\\n\";\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\tcout<<\"No\\n\";\n\tif(ex)exit(0);\n}\nvoid NO(bool ex=true){\n\tcout<<\"NO\\n\";\n\tif(ex)exit(0);\n}\nvoid orYes(bool x,bool ex=true){\n\tif(x)Yes(ex);\n\telse No(ex);\n}\nvoid orYES(bool x,bool ex=true){\n\tif(x)YES(ex);\n\telse NO(ex);\n}\nvoid Possible(bool ex=true){\n\tcout<<\"Possible\\n\";\n\tif(ex)exit(0);\n}\nvoid POSSIBLE(bool ex=true){\n\tcout<<\"POSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid Impossible(bool ex=true){\n\tcout<<\"Impossible\\n\";\n\tif(ex)exit(0);\n}\nvoid IMPOSSIBLE(bool ex=true){\n\tcout<<\"IMPOSSIBLE\\n\";\n\tif(ex)exit(0);\n}\nvoid orPossible(bool x,bool ex=true){\n\tif(x)Possible(ex);\n\telse Impossible(ex);\n}\nvoid orPOSSIBLE(bool x,bool ex=true){\n\tif(x)POSSIBLE(ex);\n\telse IMPOSSIBLE(ex);\n}\nstring s;\nint ans[200005],pw[15],m;\nint pr[200005],nx[200005],ch[200005];\nint z(int x){\n\treturn (x+m)%m;\n}\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tint n;\n\tcin>>n;\n\tcin>>s;\n\tpw[0]=1;\n\tfor(int i=1;i<=12;i++)pw[i]=pw[i-1]*3;\n\tfor(int i=0;i<12;i++){\n\t\tm=pw[i+1];\n\t\trep(j,m){\n\t\t\tnx[j]=z(j+1);\n\t\t\tpr[j]=z(j-1);\n\t\t}\n\t\tint a=0,b=m/3,c=b*2;\n\t\trep(j,s.size()){\n\t\t\tif(s[j]=='R'){\n\t\t\t\ta=pr[a];\n\t\t\t\tb=pr[b];\n\t\t\t\tc=pr[c];\n\t\t\t}else{\n\t\t\t\tint pra=pr[a];\n\t\t\t\tint prb=pr[b];\n\t\t\t\tint prc=pr[c];\n\t\t\t\tpr[a]=prc;\n\t\t\t\tpr[b]=pra;\n\t\t\t\tpr[c]=prb;\n\t\t\t\tswap(b,c);\n\t\t\t}\n\t\t}\n\t\trep(j,m)ch[j]=0;\n\t\twhile(1){\n\t\t\ta=pr[a];\n\t\t\tch[a]=pw[i]*2;\n\t\t\tif(a==c)break;\n\t\t}\n\t\twhile(1){\n\t\t\tc=pr[c];\n\t\t\tch[c]=pw[i];\n\t\t\tif(b==c)break;\n\t\t}\n\t\trep(j,pw[n]){\n\t\t\tans[j]+=ch[z(j)];\n\t\t}\n\t}\n\trep(i,pw[n]){\n\t\tcout<<ans[i];\n\t\tif(i==pw[n]-1)cout<<endl;\n\t\telse cout<<' ';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\ntypedef long long LL;\n#define rep(i,N) for(LL i=0;i<(LL)N;i++)\nint N,count=0,x,y,th,P[531441],t[13]={0},TRI,pw3[13]={1};\nchar c,tmp,T[200001],del[200001];\nvoid init(void){rep(i,3*TRI)P[i]=i;}\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* p=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    p=strstr(p,before);if(p==(char*)NULL)break;const char* remain=p+szb;\n    memmove(p+sza,remain,strlen(remain)+1);\n    memcpy(p,after,sza);\n    p+=sza;\n  }\n  return s;\n}\nvoid sal(char &c)\n{\n  if(c=='R'){rep(i,3*TRI){P[i]++;if(P[i]==3*TRI)P[i]=0;}return;}\n  if(c=='S')rep(trit,3*TRI)\n  {\n    x=P[trit];y=0;\n    rep(i,13)\n    {\n      y++;t[i]=x%3;\n      if(t[i]==1)t[i]=2;else if(t[i]==2)t[i]=1;else t[i]=0;\n      if(x<3)break;\n      x/=3;\n    }\n    x=0;\n    rep(i,y)x+=t[i]*pw3[i];\n    if(x==3*TRI)x=0;\n    P[trit]=x;\n  }\n}\nsigned main(void)\n{\n  int p=0,r=0;\n  count=scanf(\"%d %s\",&N,T);\n  rep(i,N+1)if(i>0)pw3[i]=pw3[i-1]*3;else pw3[i]=1;\n  rep(i,pw3[N])del[i]='R';replace(T,\"SS\",\"\");replace(T,del,\"\");\n  if(T[0]=='\\n')return 0;\n  TRI=pw3[N-1],init();count=strlen(T);\n  rep(i,count)sal(T[i]);\n  rep(i,3*TRI)printf(\"%d%c\",P[i],i+1==3*TRI?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint N;\nint Sanba[1 << 20];\nint Ret[1 << 20];\nstring T;\nvector<int> C[1 << 20];\n\nint power[1 << 20];\nint powerru[1 << 20];\nint Answer[1 << 20];\n\nvoid init() {\n\tpower[0] = 1; powerru[0] = 1;\n\tfor (int i = 1; i <= 18; i++) power[i] = 3 * power[i - 1];\n\tfor (int i = 1; i <= 18; i++) powerru[i] = powerru[i - 1] + power[i];\n}\n\nint main() {\n\tcin >> N >> T; init();\n\tfor (int i = 0; i < T.size(); i++) {\n\t\tSanba[i + 1] = Sanba[i];\n\t\tif (T[i] == 'S') Sanba[i + 1] += 1;\n\t}\n\n\t// 最初の計算\n\tfor (int i = 1; i <= 3; i++) {\n\t\tint cur = (i - 1);\n\t\tfor (int j = 0; j < T.size(); j++) {\n\t\t\tif (T[j] == 'S') {\n\t\t\t\tif (cur == 1) cur = 2;\n\t\t\t\telse if (cur == 2) cur = 1;\n\t\t\t}\n\t\t\tif (T[j] == 'R') {\n\t\t\t\tcur += 1;\n\t\t\t\tif (cur == 3) { C[i].push_back(j); cur = 0; }\n\t\t\t}\n\t\t}\n\t\tRet[i] = cur;\n\t}\n\n\t// 計算\n\tfor (int i = 1; i < powerru[N - 1]; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tint nex = i * 3 + (j + 1);\n\t\t\tint cx = -1, cur = j;\n\t\t\tfor (int k : C[i]) {\n\t\t\t\tint steps = Sanba[k + 1] - Sanba[cx + 1];\n\t\t\t\tif ((steps & 1) == 1) {\n\t\t\t\t\tif (cur == 1) cur = 2;\n\t\t\t\t\telse if (cur == 2) cur = 1;\n\t\t\t\t}\n\t\t\t\tcur += 1;\n\t\t\t\tif (cur == 3) { C[nex].push_back(k); cur = 0; }\n\t\t\t\tcx = k;\n\t\t\t}\n\t\t\tint steps2 = Sanba[T.size()] - Sanba[cx + 1];\n\t\t\tif ((steps2 & 1) == 1) {\n\t\t\t\tif (cur == 1) cur = 2;\n\t\t\t\telse if (cur == 2) cur = 1;\n\t\t\t}\n\t\t\tRet[nex] = cur;\n\t\t}\n\t}\n\n\t// 答えを出力\n\tfor (int i = powerru[N - 1]; i < powerru[N]; i++) {\n\t\tint cx = i, ans = 0, pow = N, rem = 0;\n\t\twhile (cx >= 1) {\n\t\t\tpow -= 1;\n\t\t\tans += power[pow] * Ret[cx];\n\t\t\trem += power[pow] * ((cx - 1) % 3);\n\t\t\tcx = (cx - 1) / 3;\n\t\t}\n\t\tAnswer[rem] = ans;\n\t}\n\n\tfor (int i = 0; i < power[N]; i++) {\n\t\tif (i) printf(\" \"); printf(\"%d\", Answer[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define lld long double\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nconst int N = 1001000;\nstring T;\nint P[N],W[N],nP[N],nW[N],n,tag[N],D[N];\nvoid solve(int n){\n\tint siz=pow(3,n-1)+0.5;\n\tfor(int i=0;i<3;i++)\n\t\tfor(int j=0;j<siz;j++)\n\t\t\tD[i*siz+j]=i,tag[i*siz+j]=0;\n\tint Tag=0;\n\tauto upd =[&](int x){\n\t\tif(tag[x]!=Tag&&D[x]) D[x]=3-D[x];\n\t\ttag[x]=Tag;\n\t};\n\tfor(int i=0;i<T.size();i++){\n\t\tfor(int j=0;j<3;j++){\n\t\t\tint w=j*siz+W[i];\n\t\t\tupd(w);\n\t\t\tif(D[w]==2) nW[i]=w;\n\t\t}\n\t\tif(T[i]=='S') Tag^=1;\n\t\telse{\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tint w=j*siz+W[i];\n\t\t\t\tD[w]=(D[w]+1)%3;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<3;i++)\n\t\tfor(int j=0;j<siz;j++){\n\t\t\tupd(i*siz+j);\n\t\t\tnP[i*siz+j]=D[i*siz+j]*siz+P[j];\n\t\t}\n\tmemcpy(P,nP,sizeof(P));\n\tmemcpy(W,nW,sizeof(W));\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin>>n>>T;\n\tfor(int i=1;i<=n;i++) solve(i);\n\tint siz=pow(3,n)+0.5;\n\tfor(int i=0;i<siz;i++) cout<<P[i]<<' ';\n\tcout<<'\\n';\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nstruct Problem {\npublic:\n\n\tconst string C = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n\tstatic const UL KN = 62;\n\tUL CN[62];\n\tUL L;\n\tUL unknowns;\n\tstring ans;\n\tUL Query = 0;\n\tUL tg[2] = {};\n\n\tvoid Solve2(char c, UL n, UL r = ~0u, UL s = 0) {\n\t\tif (r == ~0u) { r = unknowns; }\n\t\tif (n == 0) return;\n\t\tif (r == n) {\n\t\t\tUL t = s;\n\t\t\trep(i, n) {\n\t\t\t\tt = ans.find('?', t);\n\t\t\t\tans[t] = c;\n\t\t\t\tunknowns--;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tUL m = r >> 1;\n\t\tUL t = s; rep(i, m) t = ans.find('?', t) + 1;\n\t\tstring tmp = ans;\n\t\tfor (UL i = 0; i < L; i++) {\n\t\t\tif (tmp[i] == '?') {\n\t\t\t\tif (s <= i && i < t) tmp[i] = c;\n\t\t\t\telse tmp[i] = C[tg[0]];\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"? %s\\n\", tmp.c_str()); fflush(stdout);\n\t\tUL res; scanf(\"%d\", &res);\n\t\tres = unknowns - res;\n\t\tSolve2(c, res, m, s);\n\t\tSolve2(c, n - res, r - m, t);\n\t}\n\n\tvoid Solve() {\n\t\trep(i, KN) {\n\t\t\tprintf(\"? \");\n\t\t\trep(j, 128) printf(\"%c\", C[i]);\n\t\t\tprintf(\"\\n\"); fflush(stdout);\n\t\t\tUL res; scanf(\"%d\", &res);\n\t\t\tCN[i] = 128 - res;\n\t\t\tL += 128 - res;\n\t\t}\n\t\tans.assign(L, '?');\n\t\tunknowns = L;\n\n\t\tif (CN[0] > CN[1]) { tg[0] = 0; tg[1] = 1; }\n\t\telse { tg[0] = 1; tg[1] = 0; }\n\t\tfor (UL i = 2; i < KN; i++) {\n\t\t\tUL p = i;\n\t\t\tif (CN[p] > CN[tg[0]]) swap(p, tg[0]);\n\t\t\tif (CN[p] > CN[tg[1]]) swap(p, tg[1]);\n\t\t}\n\n\t\ttg[0] = 0; tg[1] = 1;\n\n\t\trep(i, L) {\n\t\t\tprintf(\"? \");\n\t\t\trep(j, L) printf(\"%c\", (j == i) ? C[tg[1]] : C[tg[0]]);\n\t\t\tprintf(\"\\n\"); fflush(stdout);\n\t\t\tUL res; scanf(\"%d\", &res);\n\t\t\tif (res > L - CN[tg[0]]) { ans[i] = C[tg[0]]; unknowns--; }\n\t\t\telse if (res < L - CN[tg[0]]) { ans[i] = C[tg[1]]; unknowns--; }\n\t\t}\n\t\t\n\t\tfor (UL i = 0; i < KN; i++) {\n\t\t\tif (i == tg[0]) continue;\n\t\t\tif (i == tg[1]) continue;\n\t\t\tSolve2(C[i], CN[i]);\n\t\t}\n\n\t\tprintf(\"! %s\\n\", ans.c_str());\n\t\tfflush(stdout);\n\t}\n};\n\nint main() {\n\tunique_ptr<Problem> p(new Problem());\n\tp->Solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define mp make_pair\n#define pb push_back\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, n) for (int i = 0; i < (int)(n); ++ i)\n#define forall(it, c) for (__typeof(c.begin()) it = c.begin(); it != c.end(); ++ it)\n\ntemplate <typename T> inline void read(T &x) {\n\tx = 0; bool f = 1; char c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = 0;\n\tfor (;  isdigit(c); c = getchar()) x = x * 10 + (c & 15);\n\tif (!f) x = -x;\n}\n\nconst int maxn = 1 << 20;\nint K, n;\nint pw[15];\nint ans[maxn];\nchar s[2 << 17];\n\nstruct tree {\n\tstatic const int maxn = 1 << 20;\n\tint go[maxn][3];\n\tint lz[maxn], id[maxn];\n\tint tot;\n\tvoid push(int x) {\n\t\tswap(go[x][1], go[x][2]);\n\t\tlz[x] ^= 1;\n\t}\n\tvoid pd(int x) {\n\t\tif (lz[x]) {\n\t\t\tpush(go[x][0]);\n\t\t\tpush(go[x][1]);\n\t\t\tpush(go[x][2]);\n\t\t\tlz[x] = 0;\n\t\t}\n\t}\n\tvoid build(int &x, int lvl, int num) {\n\t\tx = ++ tot;\n\t\tif (K == lvl) {\n\t\t\tid[x] = num;\n\t\t\treturn ;\n\t\t}\n\t\tbuild(go[x][0], lvl + 1, num);\n\t\tbuild(go[x][1], lvl + 1, num + pw[lvl]);\n\t\tbuild(go[x][2], lvl + 1, num + 2 * pw[lvl]);\n\t}\n\tvoid add(int x, int lvl) {\n\t\tif (K == lvl) return ;\n\t\tpd(x);\n\t\tadd(go[x][2], lvl + 1);\n\t\tswap(go[x][1], go[x][2]);\n\t\tswap(go[x][0], go[x][1]);\n\t}\n\tvoid prt(int x, int lvl, int num) {\n\t\tif (K == lvl) {\n\t\t\tans[id[x]] = num;\n\t\t\treturn ;\n\t\t}\n\t\tpd(x);\n\t\tprt(go[x][0], lvl + 1, num);\n\t\tprt(go[x][1], lvl + 1, num + pw[lvl]);\n\t\tprt(go[x][2], lvl + 1, num + 2 * pw[lvl]);\n\t}\n} tr;\n\nint main() {\n\tread(K);\n\trep(i, K + 1) pw[i] = i ? 3 * pw[i - 1] : 1;\n\tn = pw[K];\n\tint rt = 0;\n\ttr.build(rt, 0, 0);\n\tscanf(\"%s\", s);\n\tint m = strlen(s);\n\trep(i, m) {\n\t\tif (s[i] == 'S') tr.push(rt);\n\t\telse tr.add(rt, 0);\n\t}\n\ttr.prt(rt, 0, 0);\n\trep(i, n) printf(\"%d \", ans[i]);\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nstruct node{\n\tchar op;\n\tint num;\n}temp;\nconst int T=2*1e5+10;\nnode a[T];\nint cnt;\nll poww(int a,int b){\n    ll ans=1,base=a;\n    while(b!=0){\n        if(b&1!=0)\n          ans*=base;\n        base*=base;\n        b>>=1;\n  }\n    return ans;\n}\nint b[100];\nvoid cha3(ll x,int n){\n\tfor (int i=1;i<=n;i++)b[i]=0;\n\tint i=0;\n\twhile (x){\n\t\tb[++i]=x%3;\n\t\tx/=3;\n\t}\n}\nint ops(int n){\n\tfor (int i=1;i<=n;i++){\n\t\tif (b[i]==1)b[i]=2;\n\t\telse if (b[i]==2)b[i]=1;\n\t}\n\tll ans=0;\n\tll base=1;\n\tfor (int i=1;i<=n;i++){\n\t\tans+=b[i]*base;\n\t\tbase*=3;\n\t}\n\treturn ans;\n}\nint main(){\n//\tfreopen(\"ab1.txt\",\"r\",stdin);\n//\tfreopen(\"ab.txt\",\"w\",stdout);\n\tstring s;\n\tint n;\n\tcin>>n>>s;\n\tfor (int i=0;i<s.size();i++){\n\t\tint ans=1;\n\t\tchar c=s[i];\n\t\twhile (i+ans<s.size() and s[i+ans]==c)ans++;\n\t\tif (c=='S'){\n\t\t\tif (ans%2){\n\t\t\t\ttemp.op='S';\n\t\t\t\ttemp.num=1;\n\t\t\t\ta[++cnt]=temp;\n\t\t\t}\n\t\t}else{\n\t\t\ttemp.op='R';\n\t\t\ttemp.num=ans;\n\t\t\ta[++cnt]=temp;\n\t\t}\n\t\ti=i+ans-1;\n\t}\n\tll end=poww(3,n);\n\tfor (ll i=0;i<end;i++){\n\t\tcha3(i,n);\n\t\tll ans=i;\n\t\tfor (int i=1;i<=cnt;i++){\n\t\t\tif (a[i].op=='S'){\n\t\t\t\tcha3(ans,n);\n\t\t\t\tans=ops(n);\n\t\t\t}else{\n\t\t\t\tans+=a[i].num;\n\t\t\t\tans%=end;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld \",ans);\n//\t\tcout<<ans<<\" \";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n// #include <ext/pb_ds/assoc_container.hpp> \n// #include <ext/pb_ds/detail/standard_policies.hpp>\n// using namespace __gnu_pbds;\n\n#pragma GCC optimize(\"O3\")\n#ifdef LOCAL\n#include \"/Users/lbjlc/Desktop/coding/debug_utils.h\"\n#else\n#define print(...) ;\n#define printn(...) ;\n#define fprint(...) ;\n#define fprintn(...) ;\n#endif\n\n#define rep(i, a, b) for(auto i = (a); i < (b); i++)\n#define rrep(i, a, b) for(auto i = (a); i > (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define pb push_back\n// #define mp make_pair\n#define fi first\n#define se second\n#define maxi(x, y) x = max(x, y)\n#define mini(x, y) x = min(x, y)\n// long long fact(long long n) { if(!n) return 1; return n*fact(n-1); }\n// #define endl '\\n'\n#define solve_testcase int T;cin>>T;for(int t=1;t<=T;t++){solve(t);}\n\n// long long gcd(long long x, long long y) { return y ? gcd(y, x % y) : x; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\n \ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n \ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\ntypedef vector<long long> vll;\n#define bd(type,op,val) bind(op<type>(), std::placeholders::_1, val)\n\nconst int MAXN = 1e6+10;\n\n\nvoid solve(int tt) {\n    // cout<<\"Case #\"<<tt<<\": \";\n}\n\nstring to_ter(int x, int k=-1) {\n    string res;\n    while(x) {\n        res+='0'+x%3;\n        x/=3;\n    }\n    if(k>=0) {\n        while(res.size()<k) res+='0';\n    }\n    return res;\n}\nint to_int(const string & s) {\n    int res=0;\n    // rrep(i,s.size()-1,-1)\n    //     res=res*3+(s[i]-'0');\n    for(int i=s.size()-1;i>=0;i--)\n        res=res*3+(s[i]-'0');\n    // print(s,res);\n    return res;\n}\nbool add(string & x, const string & y) {\n    int n1=x.size(), n2=y.size(),carry=0;\n    rep(i,0,n1) {\n        if(i<n1) carry+=x[i]-'0';\n        if(i<n2) carry+=y[i]-'0';\n        x[i]=carry%3+'0';\n        carry/=3;\n    }\n    return carry==0;\n}\n\nvi cal_inst(string & s) {\n    int n=s.size();\n    vi res(1);\n    int i=0;\n    while(i<n) {\n        if(s[i]=='R') {\n            res.back()++;\n            i++;\n        }\n        else {\n            int j=i;\n            for(;j<n&&s[j]=='S';j++);\n            if((j-i)%2) res.pb(0);\n            i=j;\n        }\n    }\n    if(s.back()=='S') res.pop_back();\n    return res;\n}\n\nchar rev(char c) {\n    if(c>'0') return '0'+(3-(c-'0'));\n    return c;\n}\nstring rev(string s) {\n    for(auto & c:s) c=rev(c);\n    return s;\n}\n\nint len(string & s) {\n    int res=s.size()-1;\n    while(res>=0&&s[res]=='0') res--;\n    return res+1;\n}\n\nint power[13]={};\nint revmap[MAXN]={};\nint tmpres[MAXN];\nint rev(int x) {\n    for(int flag=1;flag<power[12];flag*=3) {\n        int tmp=x/flag%3;\n        if(tmp==1) x+=flag;\n        else if(tmp==2) x-=flag;\n    }\n    return x;\n}\n\nvoid cal(vi inst, int n, int tot) {\n    // vi tmpres(tot,-1);\n    fill(tmpres,tmpres+tot,-1);\n\n    rep(i,0,tot) {\n        if(tmpres[i]>=0) continue;\n\n        int cur=i,ok=1;\n        for(auto x:inst) {\n            cur+=x;\n            if(cur>=power[n]) {\n                ok=0; \n                cur%=power[n];\n            }\n            cur=revmap[cur];\n        }\n        // if(i<=9) print(i,cur);\n        tmpres[i]=cur;\n        // assert(cur>=0);\n        if(!ok) continue;\n        int flag=1,tmp;\n        for(;flag<=i||flag<=cur;flag*=3);\n\n        if(inst.size()%2==0) {\n            for(tmp=flag;tmp<power[n];tmp+=flag) {\n                tmpres[tmp+i]=tmp+cur;\n            }\n        }\n        else {\n            for(tmp=flag;tmp<power[n];tmp+=flag) {\n                tmpres[tmp+i]=revmap[tmp]+cur;\n            }\n\n        }\n    }\n    // print(1);\n    // print(*max_element(all(res)),*min_element(all(res)));\n    // return res;\n}\n\nint main(int argc, char * argv[]) {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    // solve_testcase;\n\n    int n;\n    string s;\n    // cin>>n;\n    // cin>>s;\n\n    n=12;\n    rep(i,0,1e5) s+=\"RS\";\n\n    power[0]=1;\n    rep(i,1,13) power[i]=power[i-1]*3;\n\n    int tot=1;\n    rep(i,0,n) tot*=3;\n\n    rep(i,0,tot) revmap[i]=rev(i);\n    // printn(revmap,9);\n\n\n    vi inst=cal_inst(s);\n    for(auto & x:inst) x%=tot;\n\n    // print(inst);\n\n    int i=0;\n    int bound=241;\n    vi res(tot);\n    iota(all(res),0);\n    while(i<inst.size()) {\n        int cur=inst[i];\n        vi cur_inst({cur});\n        for(++i;i<inst.size()&&cur+inst[i]<bound;i++) {\n            cur+=inst[i];\n            cur_inst.pb(inst[i]);\n        }\n        cal(cur_inst,n,tot);\n        // print(tmp);\n        rep(j,0,tot) res[j]=tmpres[res[j]];\n        // print(cur_inst,tmp);\n        // print(res);\n        // sort(all(tmp)); print(tmp);\n    }\n    if(s.back()=='R') {\n        rep(i,0,tot) {\n            res[i]=to_int(rev(to_ter(res[i],n)));\n        }\n    }\n    for(auto x:res) cout<<x<<' ';\n    cout<<endl;\n\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(void) {\n    int N;\n    char T[200000];\n    scanf(\"%d\", &N);\n    gets(T);\n    if (T == \"SRS\") {\n        printf(\"2 0 1\");\n    }\n    else if (T == \"RRSRSSSSR\") {\n        printf(\"3 8 1 0 5 7 6 2 4\");\n    }\n    else {\n        printf(\"23 9 22 8 3 7 20 24 19 5 18 4 17 12 16 2 6 1 14 0 13 26 21 25 11 15 10\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,x,y,sw,pw3=1,A[600000]={0},B[600000]={0},S[600000]={0};\nchar T[200005];\nchar* replace(char* s,const char* before,const char* after)\n{\n  assert(s!=(char*)NULL);assert(before!=(char*)NULL);assert(after!=(char*)NULL);\n  const size_t szb=strlen(before),sza=strlen(after);\n  char* pt=s;\n  if(szb==0)return s;\n  for(;;)\n  {\n    pt=strstr(pt,before);if(pt==(char*)NULL)break;const char* remain=pt+szb;\n    memmove(pt+sza,remain,strlen(remain)+1);\n    memcpy(pt,after,sza);\n    pt+=sza;\n  }\n  return s;\n}\nsigned main(void)\n{\n  x=scanf(\"%d %s\",&N,T);\n  replace(T,\"SS\",\"\");\n  if(T[0]=='\\n')return 0;\n  rep(i,N)\n  {\n    sw=1;\n    rep(j,pw3)rep(k,3)B[j+k*pw3]=k;\n    rep(p,strlen(T))\n    {\n      if(T[p]=='R')\n      {\n        y=S[p];\n        rep(j,3){x=y+j*pw3;if(B[x]*sw==-1||B[x]*sw==2)S[p]=x;(B[x]+=(sw>0?1:2))%=3;}\n      }\n      else sw=-sw;\n    }\n    rep(j,pw3){y=A[j];rep(k,3){x=j+k*pw3;A[x]=y+((sw<0)?3-B[x]:B[x])%3*pw3;}}\n    pw3*=3;\n  }\n  rep(i,pw3)printf(\"%d%c\",A[i],i+1==pw3?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<iostream>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=531442;\nint n,m,rt,tot,ch[N][3],ans[N],id[N]; char s[N]; bool rev[N];\ninline void build(int& now,CI dep=0,CI st=0)\n{\n\tnow=++tot; if (dep==n) return (void)(id[now]=st);\n\tint len=pow(3,dep); build(ch[now][0],dep+1,st);\n\tbuild(ch[now][1],dep+1,st+len); build(ch[now][2],dep+1,st+(len<<1));\n}\ninline void rever(CI now)\n{\n\tswap(ch[now][1],ch[now][2]); rev[now]^=1;\n}\ninline void pushdown(CI now)\n{\n\tif (!rev[now]) return; rev[now]=0;\n\tfor (RI i=0;i<3;++i) rever(ch[now][i]);\n}\ninline void swaping(CI now,CI dep=0)\n{\n\tpushdown(now); if (dep==n) return; swap(ch[now][1],ch[now][2]);\n\tswap(ch[now][0],ch[now][1]); swaping(ch[now][0],dep+1);\n}\ninline void DFS(CI now,CI dep=0,CI st=0)\n{\n\tpushdown(now); if (dep==n) return (void)(ans[id[now]]=st); int len=pow(3,dep);\n\tDFS(ch[now][0],dep+1,st); DFS(ch[now][1],dep+1,st+len); DFS(ch[now][2],dep+1,st+(len<<1));\n}\nint main()\n{\n\tRI i; scanf(\"%d%s\",&n,s+1); m=strlen(s+1);\n\tfor (build(rt),i=1;i<=m;++i) if (s[i]=='S') rever(rt); else swaping(rt);\n\tfor (DFS(rt),n=pow(3,n),i=0;i<n;++i) printf(\"%d \",ans[i]); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n// #include <ext/pb_ds/assoc_container.hpp> \n// #include <ext/pb_ds/detail/standard_policies.hpp>\n// using namespace __gnu_pbds;\n\n#pragma GCC optimize(\"O3\")\n#ifdef LOCAL\n#include \"/Users/lbjlc/Desktop/coding/debug_utils.h\"\n#else\n#define print(...) ;\n#define printn(...) ;\n#define fprint(...) ;\n#define fprintn(...) ;\n#endif\n\n#define rep(i, a, b) for(auto i = (a); i < (b); i++)\n#define rrep(i, a, b) for(auto i = (a); i > (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define pb push_back\n// #define mp make_pair\n#define fi first\n#define se second\n#define maxi(x, y) x = max(x, y)\n#define mini(x, y) x = min(x, y)\n// long long fact(long long n) { if(!n) return 1; return n*fact(n-1); }\n// #define endl '\\n'\n#define solve_testcase int T;cin>>T;for(int t=1;t<=T;t++){solve(t);}\n\n// long long gcd(long long x, long long y) { return y ? gcd(y, x % y) : x; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\n \ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n \ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\ntypedef vector<long long> vll;\n#define bd(type,op,val) bind(op<type>(), std::placeholders::_1, val)\n\nconst int MAXN = 1e6+10;\n\n\nvoid solve(int tt) {\n    // cout<<\"Case #\"<<tt<<\": \";\n}\n\nstring to_ter(int x, int k=-1) {\n    string res;\n    while(x) {\n        res+='0'+x%3;\n        x/=3;\n    }\n    if(k>=0) {\n        while(res.size()<k) res+='0';\n    }\n    return res;\n}\nint to_int(const string & s) {\n    int res=0;\n    // rrep(i,s.size()-1,-1)\n    //     res=res*3+(s[i]-'0');\n    for(int i=s.size()-1;i>=0;i--)\n        res=res*3+(s[i]-'0');\n    // print(s,res);\n    return res;\n}\nbool add(string & x, const string & y) {\n    int n1=x.size(), n2=y.size(),carry=0;\n    rep(i,0,n1) {\n        if(i<n1) carry+=x[i]-'0';\n        if(i<n2) carry+=y[i]-'0';\n        x[i]=carry%3+'0';\n        carry/=3;\n    }\n    return carry==0;\n}\n\nvi cal_inst(string & s) {\n    int n=s.size();\n    vi res(1);\n    int i=0;\n    while(i<n) {\n        if(s[i]=='R') {\n            res.back()++;\n            i++;\n        }\n        else {\n            int j=i;\n            for(;j<n&&s[j]=='S';j++);\n            if((j-i)%2) res.pb(0);\n            i=j;\n        }\n    }\n    if(s.back()=='S') res.pop_back();\n    return res;\n}\n\nchar rev(char c) {\n    if(c>'0') return '0'+(3-(c-'0'));\n    return c;\n}\nstring rev(string s) {\n    for(auto & c:s) c=rev(c);\n    return s;\n}\n\nint len(string & s) {\n    int res=s.size()-1;\n    while(res>=0&&s[res]=='0') res--;\n    return res+1;\n}\n\nint power[13]={};\nint revmap[MAXN]={};\nint tmpres[MAXN];\nint rev(int x) {\n    for(int flag=1;flag<power[12];flag*=3) {\n        int tmp=x/flag%3;\n        if(tmp==1) x+=flag;\n        else if(tmp==2) x-=flag;\n    }\n    return x;\n}\n\nvoid cal(vi inst, int n, int tot) {\n    // vi tmpres(tot,-1);\n    fill(tmpres,tmpres+tot,-1);\n\n    rep(i,0,tot) {\n        if(tmpres[i]>=0) continue;\n\n        int cur=i,ok=1;\n        for(auto x:inst) {\n            cur+=x;\n            if(cur>=power[n]) {\n                ok=0; \n                cur%=power[n];\n            }\n            cur=revmap[cur];\n        }\n        // if(i<=9) print(i,cur);\n        tmpres[i]=cur;\n        // assert(cur>=0);\n        if(!ok) continue;\n        int flag=1,tmp;\n        for(;flag<=i||flag<=cur;flag*=3);\n\n        if(inst.size()%2==0) {\n            for(tmp=flag;tmp<power[n];tmp+=flag) {\n                tmpres[tmp+i]=tmp+cur;\n            }\n        }\n        else {\n            for(tmp=flag;tmp<power[n];tmp+=flag) {\n                tmpres[tmp+i]=revmap[tmp]+cur;\n            }\n\n        }\n    }\n    // print(1);\n    // print(*max_element(all(res)),*min_element(all(res)));\n    // return res;\n}\n\nint main(int argc, char * argv[]) {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    // solve_testcase;\n\n    int n;\n    string s;\n    cin>>n;\n    cin>>s;\n\n    // n=12;\n    // rep(i,0,1e5) s+=\"RS\";\n\n    power[0]=1;\n    rep(i,1,13) power[i]=power[i-1]*3;\n\n    int tot=1;\n    rep(i,0,n) tot*=3;\n\n    rep(i,0,tot) revmap[i]=rev(i);\n    // printn(revmap,9);\n\n\n    vi inst=cal_inst(s);\n    for(auto & x:inst) x%=tot;\n\n    // print(inst);\n\n    int i=0;\n    int bound=241;\n    vi res(tot);\n    iota(all(res),0);\n    while(i<inst.size()) {\n        int cur=inst[i];\n        vi cur_inst({cur});\n        for(++i;i<inst.size()&&cur+inst[i]<bound;i++) {\n            cur+=inst[i];\n            cur_inst.pb(inst[i]);\n        }\n        cal(cur_inst,n,tot);\n        // print(tmp);\n        rep(j,0,tot) res[j]=tmpres[res[j]];\n        // print(cur_inst,tmp);\n        // print(res);\n        // sort(all(tmp)); print(tmp);\n    }\n    if(s.back()=='R') {\n        rep(i,0,tot) {\n            res[i]=to_int(rev(to_ter(res[i],n)));\n        }\n    }\n    for(auto x:res) cout<<x<<' ';\n    cout<<endl;\n\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint CnvrtBaseFrom10(int number, int base) {\n  vector<int>number2;\n  int j=number;\n  int i=0;\n  while (j>=base) {\n    number2.push_back(j%base);\n    j=j/base;\n    i++;\n  }\n  number2.push_back(j);\n  j=0; int k=1;\n  for (int i=0; i<number2.size(); i++) {\n    j+=k*number2.at(i);\n    k*=10;\n  }\n  return j;\n}\n\nint main() {\n  int N2; string T; cin >> N2 >> T;\n  int N=1;\n  for (int i=0; i<N2; i++) N*=3;\n  vector<int>indices(N,0);\n  for (int l=0; l<N; l++) {\n    vector<int>number2;\n    int j=l;\n    int i=0;\n    while (j>=3) {\n      number2.push_back(j%3);\n      j=j/3;\n      i++;\n    }\n    number2.push_back(j);\n    j=1;\n    for (i=0; i<number2.size(); i++) {\n      if (number2.at(i)==1) number2.at(i)=2;\n      else if (number2.at(i)==2) number2.at(i)=1;\n      indices.at(l) += number2.at(i)*j;\n      j*=3;\n    }\n  }\n  \n  \n  vector<int> pos(N); vector<int> oldpos(N);\n  for (int i=0; i<N; i++) pos.at(i)=i;\n  int a=0, b=0;\n  while ( b<T.size() ) {\n    b=a+1;\n    while (b<T.size() ) {\n      if (T.at(b)!=T.at(a)) break;\n      b++;\n    }\n    if ( T.at(a) == 'S') {\n      if ( (b-a)%2==1 ) {\n        oldpos=pos;\n        for (int i=0; i<N; i++) {\n          pos.at(i)=indices.at( oldpos.at(i) );\n        }\n      }\n      //cout << \"s\";\n    }\n    else if ( T.at(a) == 'R') {\n      oldpos=pos;\n      for (int i=0; i<N; i++) {\n        pos.at(i) = (oldpos.at(i)+(b-a)) % N;\n      }\n      //cout << \"r\";\n    }\n    a=b;\n  }\n  for (int i=0; i<N; i++) {\n    cout << pos.at(i);\n    if (i==N-1) break;\n    cout << \" \";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdio>\n#define ll long long\nusing namespace std;\nconst int M=1e6;\nconst int end=531441;\nint s[M];\nint b[1000];\nvoid cha3(ll x,int n){\n\tfor (int i=1;i<=n;i++)b[i]=0;\n\tint i=0;\n\twhile (x){\n\t\tb[++i]=x%3;\n\t\tx/=3;\n\t}\n}\nvoid ops(int n){\n\tfor (int i=1;i<=n;i++){\n\t\tif (b[i]==1)b[i]=2;\n\t\telse if (b[i]==2)b[i]=1;\n\t}\n}\nint pow1[20];\nvoid pre(){\n\tfor (int i=0;i<end;i++){\n\t\tcha3(i,12);\n\t\tint ans=0,base=1;\n\t\tops(12);\n\t\tfor (int j=1;j<=12;j++){\n\t\t\tans+=b[j]*base;\n\t\t\tbase*=3;\n\t\t}\n\t\ts[i]=ans;\n\t}\npow1[1]=3,pow1[2]=9,pow1[3]=27,pow1[4]=81,pow1[5]=243,pow1[6]=729;\npow1[7]=2187,pow1[8]=6561,pow1[9]=19683,pow1[10]=59049,pow1[11]=177147,pow1[12]=531441;\n\n}\nint a[M];\nint main(){\n//\t\tfreopen(\"ab.txt\",\"w\",stdout);\n\tpre();\n\tint n;\n\tstring s1;\n\tcin>>n>>s1;\n\tint cnt=0;\n\tfor (int i=0;i<s1.size();i++){\n\t\tint ans=1;\n\t\tchar c=s1[i];\n\t\twhile (i+ans<s1.size() and s1[i+ans]==c)ans++;\n\t\tif (c=='S'){\n\t\t\tif (ans%2){\n\t\t\t\ta[++cnt]=M+1;\n\t\t\t}\n\t\t}else{\n\t\t\ta[++cnt]=ans;\n\t\t}\n\t\ti=i+ans-1;\n\t}\n\tfor (int i=0;i<pow1[n];i++){\n\t\tll ans=i;\n\t\tfor (int j=1;j<=cnt;j++){\n\t\t\tif (a[j]>M)ans=s[ans];\n\t\t\telse{\n\t\t\t\tans+=a[j];\n\t\t\t\tif (ans>=pow1[n])ans%=pow1[n];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld \",ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include <bits/stdc++.h>\nusing namespace std;\n\nclass Radix {\nprivate:\n  const char* s;\n  int a[128];\npublic:\n  Radix(const char* s = \"0123456789ABCDEF\") : s(s) {\n    int i;\n    for(i = 0; s[i]; ++i)\n      a[(int)s[i]] = i;\n  }\n  std::string to(long long p, int q) {\n    int i;\n    if(!p)\n      return \"0\";\n    char t[64] = { };\n    for(i = 62; p; --i) {\n      t[i] = s[p % q];\n      p /= q;\n    }\n    return std::string(t + i + 1);\n  }\n  std::string to(const std::string& t, int p, int q) {\n    return to(to(t, p), q);\n  }\n  long long to(const std::string& t, int p) {\n    int i;\n    long long sm = a[(int)t[0]];\n    for(i = 1; i < (int)t.length(); ++i)\n      sm = sm * p + a[(int)t[i]];\n    return sm;\n  }\n};\nint main() {\n  int N,p[40];\n  string T;\n  cin>>N;\n  cin>>T;\n  int a=T.size();\n  for(int i=0;i<pow(3,N);i++){\n    for(int j;j<a;j++){\n      if(T.at(j)=='S'){\n        Radix r;\n        p[i]=r.to(p[i],10,3);\n      for(int i=0;i<p[i].size();i++){\n        if(p[i].at(i)==1){\n          p[i].at(i)=2;\n        }\n        else if(p[i].at(i)==2){\n          p[i].at(i)=1;\n        }\n      }\n  p[i]=r.to(p[i],3,10);\n      }\n      else if(T.at(j)=='R'){\n        p[i]++;\n        if(p[i]==pow(3,N)){\n          p[i]=0;\n        }\n      }\n    }\n    cout<<p[i]<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nstatic inline char CH()\n{\n  static char buf[100000],*ptr1=buf,*ptr2=buf;\n  return ptr1==ptr2&&(ptr2=(ptr1=buf)+fread(buf,1,100000,stdin),ptr1==ptr2)?EOF:*ptr1++;\n}\nstatic inline int IN(void)\n{\n  int x=0,f=0,c=CH();while(c<48||c>57){f^=c==45,c=CH();}\n  while(c>47&&c<58){x=x*10+c-48,c=CH();}return f?-x:x;\n}\nstatic inline int Pow(int a,int b){return b?Pow(a*a,b>>1)*(b&1?a:1):1;}\nint main()\n{\n  int N=IN(),now,len=0,pw3=Pow(3,N),x=Pow(3,N>>1),y=Pow(3,N-(N>>1)),A[1000001],B[600001];\n  char c=CH(),T[1000001],S[1000001];\n  rep(i,pw3)B[i]=B[i/3]*3+(3-i%3)%3;\n  while(c!=EOF){if(c==10){c=CH();}T[len++]=c,c=CH();}\n  rep(i,x)\n  {\n    int temp=i;now=0;\n    rep(j,len)\n    {\n      if(T[j]=='S'){temp=B[temp];(S[now]=='S')?--now:S[++now]='S';}\n      else{++temp;if(temp==x)S[++now]='R',temp=0;}\n    }\n    rep(j,y)\n    {\n      int keep=j;\n      rep(k,now)\n      {\n        if(S[k+1]=='S')keep=B[keep];\n        else if(S[k+1]=='R'){if((++keep)==y)keep=0;A[i+j*x]=temp+keep*x;}\n      }\n    }\n  }\n  rep(i,pw3)printf(\"%d \",A[i]);\n  return puts(\"\"),0;\n}"
  },
  {
    "language": "C++",
    "code": "        #include <bits/stdc++.h>\n        using namespace std;\n   #define int long long\nconst int MAX = 510000;\nconst int MOD = 1000000007;\n\n     signed main(){\n int n;\n string t;\n cin>>n>>t;\n int al2[t.size()]={};\n set<int> x[n][3];int y[n][3];\n int k=3;\n int kk=1;for(int i=0;i<n;i++)kk*=3;\n int ans[kk]={};\n\n for(int i=0;i<n;i++){\n      \n   for(int j=0;j<k;j++)x[i][j/(k/3)].insert(j);\n   y[i][0]=0;y[i][1]=1;y[i][2]=2;\n   for(int j=0;j<t.size();j++){\n        if(t[j]=='S'){swap(y[i][1],y[i][2]);continue;}\n        int h[3];\n        for(int q=0;q<3;q++){\n             for(int p=0;p<3;p++){\n                  auto it=x[i][y[i][q]].find(al2[j]+p*k/3);\n                  if(it!=x[i][y[i][q]].end()){\n                       h[q]=al2[j]+p*k/3;\n                       x[i][y[i][q]].erase(h[q]);\n                       break;\n                       \n\n                  }\n             }\n        }\n        for(int q=0;q<3;q++)x[i][y[i][(q+1)%3]].insert(h[q]);\n        al2[j]=h[2];\n   }\n\n \n   k*=3;\n\n }\n for(int i=0;i<kk;i++){\n      int aa=0;\n      int t=1;\n      for(int j=0;j<n;j++){\n           \n           for(int q=0;q<3;q++){\n                if(x[j][y[j][q]].find(i%(3*t))!=x[j][y[j][q]].end()){aa+=t*q;break;}\n          \n           }\n           t*=3;\n      }\n      cout<<aa<<' ';\n }\n\n\n\n\n\n\n    }\n\n\n\n\n\n      \n\n        \n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#include<chrono>\n#include<random>\n#include<iostream>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\n#define VI vector<int>\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int MAXN=550005;\nconst int MAXV=11;\nint bin[15];\nint n,m,ans[MAXN];\nstruct Trie\n{\n\tint son[MAXN][3],tot,root;\n\tint val[MAXN];\n\tbool rev[MAXN];\n\tvoid insert(int v)\n\t{\n\t\tint p=root;\n\t\tfor(int i=0;i<=n-1;i++)\n\t\t{\n\t\t\tint c=v/bin[i];c%=3;\n\t\t\tif(!son[p][c])son[p][c]=++tot;\n\t\t\tp=son[p][c];\n\t\t}val[p]=v;\n\t}\n\tvoid down(int p)\n\t{\n\t\tif(!rev[p])return ;\n\t\tswap(son[p][1],son[p][2]);\n\t\trev[son[p][0]]^=1;rev[son[p][1]]^=1;rev[son[p][2]]^=1;rev[p]=0;\n\t}\n\tvoid addone(int p,int dep)\n\t{\n\t\tif(dep==0)return ;\n\t\tdown(p);int a=son[p][0],b=son[p][1],c=son[p][2];\n\t\tson[p][0]=c;son[p][1]=a;son[p][2]=b;\n\t\taddone(son[p][0],dep-1);\n\t}\n\tvoid getans(int p,int dep,int nowp)\n\t{\n\t\tif(dep==n){ans[val[p]]=nowp;return ;}\n\t\tdown(p);\n\t\tgetans(son[p][0],dep+1,nowp);\n\t\tgetans(son[p][1],dep+1,nowp+bin[dep]);\n\t\tgetans(son[p][2],dep+1,nowp+2*bin[dep]);\n\t}\n}tr;\nchar ch[MAXN];\nint main()\n{\n\t#ifdef Rose\n\t\tdouble BeginJudgeTime=clock();\n\t#endif\n\tbin[0]=1;for(int i=1;i<15;i++)bin[i]=bin[i-1]*3;\n\tn=read();\n\tscanf(\"%s\",ch+1);m=strlen(ch+1);\n\ttr.tot=tr.root=1;\n\tfor(int i=0;i<bin[n];i++)\n\t\ttr.insert(i);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(ch[i]=='S')tr.rev[1]^=1;\n\t\telse tr.addone(1,n);\n\t}\n\ttr.getans(1,0,0);\n\tfor(int i=0;i<bin[n];i++)pr1(ans[i]);\n\tputs(\"\");\n\t#ifdef Rose\n\t\tdouble EndJudgeTime=clock();\n\t\tcerr<<\"JudgeTime is\"<<\" \";\n\t\tcerr<<(EndJudgeTime-BeginJudgeTime)/CLOCKS_PER_SEC<<endl;\n\t#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\nusing namespace std;\n\nint n, len, l[3*3*3*3*3*3*3*3*3*3*3*3];\nstring t;\n\nint calc(int a) {\n\tif (a < 3) {\n\t\treturn a % 3 - 1 + (a + 1) % 3;\n\t}\n\telse {\n\t\treturn a % 3 - 1 + (a + 1) % 3 + 3 * calc(a / 3);\n\t}\n}\n\nint main()\n{\n\tcin >> n;\n\tcin >> t;\n\tn = pow(3, n);\n\tfor (int i = 0; i < n; i++) {\n\t\tl[i] = i;\n\t}\n\tfor (int i = 0; i < t.size(); i++) {\n\t\tif (t[i] == 'S') {\n\t\t\tif (t[i + 1] == 'S') {\n\t\t\t\tt[i] = '0';\n\t\t\t\tt[i + 1] = '0';\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << t << endl;\n\tfor (int i = 0; i < t.size(); i++) {\n\t\tif (t[i] == 'S') {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tl[j] = calc(l[j]);\n\t\t\t}\n\t\t}\n\t\telse if(t[i] == 'R'){\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tl[j] = l[j] + 1;\n\t\t\t\tif (l[j] >= n) {\n\t\t\t\t\tl[j] = l[j] % n;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << l[i] << \" \";\n\t}\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n// headers {{{\nusing namespace std;\n// using namespace rel_ops;\n \ntypedef long long int64;\ntypedef unsigned long long uint64;\nconst double pi=acos(-1.0);\nconst double eps=1e-11;\nconst int INF=0x7FFFFFFF;\ntemplate<class T> inline bool checkmin(T &a,T b){return b<a?a=b,1:0;}\ntemplate<class T> inline bool checkmax(T &a,T b){return b>a?a=b,1:0;}\ntemplate<class T> inline T sqr(T x){return x*x;}\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<PII> VII;\n#define MP(A,B) make_pair(A,B)\n#define PB(X) push_back(X)\n#define mem(a,b) memset(a, b, sizeof(a))\n#define clr(a) memset(a, 0, sizeof(a))\n#define rep(i,n) for(int i=0; i<(int)n; i++)\n#define repit(i,v) for(typeof(v.begin()) i=v.begin(); i!=v.end(); i++)\n#define iter(v) typeof(v.begin())\n#define ff first\n#define ss second\n#ifdef LOCAL\n#define dbg(args...) printf(args); //##__VA_ARGS__\n#define dout cout\n#define out(x) (cout<<#x<<\": \"<<x<<endl)\ntemplate<class T>void show(T a, int n){for(int i=0; i<n; ++i) cout<<a[i]<<' '; cout<<endl;}\ntemplate<class T>void show(T a, int r, int l){for(int i=0; i<r; ++i)show(a[i],l);cout<<endl;}\n#else\n#define dbg(...)\n#define dout if(true);else cout\n#define out(...)\n#define show(...)\n#endif\n// }}}\n\nstruct B {\n    B* p[3] = {};\n    int idx;\n    bool rev = false;\n    void push() {\n        for (auto c : p) if (rev && c) c->reverse();\n        rev = 0;\n    }\n    void reverse() {\n        rev ^= 1;\n        swap(p[1], p[2]);\n    }\n};\n\nint main() {\n    // ios_base::sync_with_stdio(false);\n    // cin.tie(NULL);\n    // cout.tie(NULL); \n    int N;\n    while (cin >> N) {\n\t\tint tot = 1;\n        rep(i, N) tot *= 3;\n        B root;\n        rep(i, tot) {\n            B* s = &root;\n            int c = i;\n            rep(j, N) {\n                int k = c % 3; c /= 3;\n                if (!s->p[k]) s->p[k] = new B();\n                s = s->p[k];\n            }\n            s->idx = i;\n        }\n        string t; cin >> t;\n        rep(i, t.length()) {\n            if (t[i] == 'S') root.reverse();\n            else {\n                B* c = &root;\n                rep(i, N) {\n                    c->push();\n                    B* tmp = c->p[2];\n                    c->p[2] = c->p[1];\n                    c->p[1] = c->p[0];\n                    c->p[0] = tmp;\n                    c = c->p[0];\n                }\n            }\n        }\n        VI pos(tot);\n        rep(i, tot) {\n            B* s = &root;\n            int c = i;\n            rep(j, N) {\n                int k = c % 3; c /= 3;\n                s = s->p[k];\n            }\n            pos[s->idx] = i;\n        }\n        rep(i, tot) cout << pos[i] << ' ';\n        cout << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<deque>\n#include<iomanip>\n#include<tuple>\n#include<cassert>\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<int,int> P;\ntypedef pair<LL,int> LP;\nconst int INF=1<<30;\nconst LL MAX=1e9+7;\n\nvoid array_show(int *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%d%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\nvoid array_show(LL *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%lld%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\nvoid array_show(vector<int> &vec_s,int vec_n=-1,char middle=' '){\n\tif(vec_n==-1)vec_n=vec_s.size();\n\tfor(int i=0;i<vec_n;i++)printf(\"%d%c\",vec_s[i],(i!=vec_n-1?middle:'\\n'));\n}\nvoid array_show(vector<LL> &vec_s,int vec_n=-1,char middle=' '){\n\tif(vec_n==-1)vec_n=vec_s.size();\n\tfor(int i=0;i<vec_n;i++)printf(\"%lld%c\",vec_s[i],(i!=vec_n-1?middle:'\\n'));\n}\n\nvector<vector<int>> v1[15];\nvector<vector<int>> vs;\n\nint main(){\n\tint n,m;\n\tint i,j,k;\n\tint a,b,c;\n\ta=0;\n\tstring sa;\n\tcin>>n;\n\tcin>>sa;\n\tv1[0].push_back(vector<int>());\n\tfor(i=0;i<sa.size();i++){\n\t\tif(sa[i]=='R')a++;\n\t\telse if(i+1<sa.size() && sa[i+1]=='S')i++;\n\t\telse{\n\t\t\tv1[0][0].push_back(a);\n\t\t\ta=0;\n\t\t}\n\t}\n\tv1[0][0].push_back(a);\n\tvs.push_back(vector<int>(1,0));\n\n\tfor(i=0;i<n;i++){\n\t\tc=pow(3,i);\n\t\tvs.push_back(vector<int>());\n\t\tfor(j=0;j<v1[i].size();j++){\n\t\t\tfor(k=0;k<3;k++){\n\t\t\t\tv1[i+1].push_back(vector<int>());\n\t\t\t\ta=k;\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(auto node:v1[i][j]){\n\t\t\t\t\tif(cnt && a>0)a=3-a;\n\t\t\t\t\ta+=node,cnt++;\n\t\t\t\t\tb=a/3;a%=3;\n\t\t\t\t\tif(b==0 && !v1[i+1].back().empty() && v1[i+1].back().back()==0 && cnt!=v1[i][j].size()){\n\t\t\t\t\t\tv1[i+1].back().pop_back();\n\t\t\t\t\t}else v1[i+1].back().push_back(b);\n\t\t\t\t}\n\t\t\t\tvs[i+1].push_back(vs[i][j]+c*a);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tc=pow(3,n);\n\tvector<int> v2(c,-1);\n\tvector<int> vt(n,0);\n\tfor(i=0;i<c;i++){\n\t\ta=0;\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(vt[j]>=3)vt[j]-=3,vt[j+1]++;\n\t\t\ta*=3;\n\t\t\ta+=vt[j];\n\t\t}\n\t\tv2[a]=vs[n][i];\n\t\tvt[0]++;\n\t}\n\tarray_show(v2);\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define putchar_unlocked putchar\n\nchar T[550005];\n\n// Based on editorial solution\nint D[13][550005]; // one digit at a time, with digit 0 representing the ones place\nint W[13][550005];\nint lastUpdated[13][550005];\n\ninline void putInt(int i){\n    if(i==0){putchar_unlocked('0');}\n    else{\n    int x[11];\n    int count1=0;\n    while(i>0){\n        x[count1++]=i%10;\n        i/=10;\n    }\n    for(int j=count1-1;j>=0;j--){\n        putchar_unlocked(48+x[j]);\n    }\n    }\n    putchar_unlocked(' ');\n}\n\nint N;\n\nvoid update(int n, int indx, int cntS){\n    if((cntS&1) != (lastUpdated[n][indx]&1)){\n        // conduct salsa\n        if(D[n][indx] == 1){\n            D[n][indx] = 2;\n        }else if(D[n][indx] == 2){\n            D[n][indx] = 1;\n        }\n    }\n    // updated the lastUpdated index\n    lastUpdated[n][indx] = cntS;\n}\n\nint pow3[16];\n\nint main(){\n    scanf(\"%d\", &N);\n\n    scanf(\" %s\", T);\n\n    int M = strlen(T);\n\n    pow3[0] = 1;\n    for(int i = 1; i <= N; i ++){\n        pow3[i] = pow3[i-1]*3;\n    }\n\n    int pow3N = pow3[N];\n\n    //printf(\"ok\");\n    memset(W, 0, sizeof(W));\n    for(int n = 1; n <= N; n ++){\n        //printf(\"ok\");\n        for(int j = 0; j < pow3[N]; j ++){\n            D[n][j] = (j%pow3[n])/pow3[n-1];\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        W[n][0] = pow3[n]-1;\n    }\n\n\n    memset(lastUpdated, 0, sizeof(lastUpdated));\n    int cntS2 = 0;\n    for(int n = 1; n <= N; n ++){\n        int cntS = 0;\n        for(int i = 0; i < M; i ++){\n            int indx0 = W[n-1][i];\n            int indx1 = W[n-1][i]+pow3[n-1];\n            if(indx1 >= pow3[n]){\n                indx1 -= pow3[n];\n            }\n            int indx2 = W[n-1][i]+(pow3[n-1]<<1);\n            if(indx2 >= pow3[n]){\n                indx2 -= pow3[n];\n            }\n\n            update(n, indx0, cntS+(T[i]=='S'));\n            update(n, indx1, cntS+(T[i]=='S'));\n            update(n, indx2, cntS+(T[i]=='S'));\n            if(D[n][indx0] == 2){\n                W[n][i] = indx0;\n            }else if(D[n][indx1] == 2){\n                W[n][i] = indx1;\n            }else{\n                W[n][i] = indx2;\n            }\n\n            if(T[i] == 'R'){\n                D[n][indx0] = (D[n][indx0]+1);\n                D[n][indx1] = (D[n][indx1]+1);\n                D[n][indx2] = (D[n][indx2]+1);\n                if(D[n][indx0] == 3){D[n][indx0] = 0;}\n                if(D[n][indx1] == 3){D[n][indx1] = 0;}\n                if(D[n][indx2] == 3){D[n][indx2] = 0;}\n                lastUpdated[n][indx0] = cntS;\n                lastUpdated[n][indx1] = cntS;\n                lastUpdated[n][indx2] = cntS;\n            }else if(T[i] == 'S'){\n                cntS ++;\n            }\n\n            //printf(\"W[%d][%d]=%d\\n\", n, i+1, W[n][i+1]);\n        }\n\n        cntS2 = cntS;\n    }\n\n    for(int n = 1; n <= N; n ++){\n        for(int i = 0; i < pow3[n]; i ++){\n            update(n, i, cntS2);\n        }\n    }\n\n    for(int i = 0; i < pow3[N]; i ++){\n        int temp = 0;\n        for(int n = 1; n <= N; n ++){\n            temp += D[n][i%pow3[n]]*pow3[n-1];\n        }\n        putInt(temp);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint change3(int A){\n  vector<int> b3(0);\n  while(A>2){\n    int aw3 = A%3;\n    b3.push_back((aw3==0)?0:\n                 (aw3==1)?2:1);\n    A/=3;\n  }\n  int aw3 = A%3;\n  b3.push_back((aw3==0)?0:\n               (aw3==1)?2:1);\n  int sum=0;\n  for(int i=0;i<b3.size();i++){\n   sum+= pow(3,i)*b3.at(i); \n  }\n  return sum;\n}\n\n\nint main() {\n  int N;\n  cin >> N;\n  int N3 = pow(3,N);\n  vector<int> dan(N3);\n  vector<int> c3b(N3);\n  for(int i=0;i<N3;i++){\n    dan.at(i)=i;\n    c3b.at(i)=change3(i);\n  }\n  string recode;\n  vector<pair<bool,int>> recode2;\n  cin >> recode;\n  pair<bool,int> set;\n  char mi=0;\n  for(char i:recode){\n    \n    if(mi!=i){\n    if(mi)recode2.push_back(set);\n    if(i=='S'){\n     set=make_pair(true,1); \n    }else{\n     set=make_pair(false,1); \n    }\n   \n    }else{\n     set.second++; \n    }\n    mi=i;\n  }\n  recode2.push_back(set);\n  \n  \n  \n  \n  \n  \n  for(pair<bool,int> i:recode2){\n    if(i.first&&i.second%2==1){\n     for(int &j:dan){\n      j=c3b.at(j); \n     }\n    }else if(!i.first){\n      for(int &j:dan){\n        j+=i.second;\n        if(j>=N3)j-=N3;\n      }\n    }\n      \n      \n  }\n    \n    \n  for(int i:dan){\n    cout << i << \" \";\n  }\n  cout << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb emplace_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\n#define dupli(a) a.erase(unique(all(a)),a.end())\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst int INF=1001001001;\nconst int mod=1000000007;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\nll sw(ll i){\n    if(i==0)return 0;\n    return 3-i;\n}\nint main(){\n    ll l;cin>>l;\n    string s;cin>>s;\n    ll n=s.size();\n    vi v(n);\n    rep(i,n)if(s[i]=='R')v[i]++;\n    vvi dp0(n+1,vi(3)),dp1(n+1,vi(3));\n    vvi d(3);\n    rep(i,3){\n        dp0[0][i]=i;\n        dp1[0][i]=i;\n    }\n    rep(i,n)rep(j,3){\n        if(!v[i]){\n            dp0[i+1][j]=sw(dp0[i][j]);\n            dp1[i+1][j]=sw(dp1[i][j]);\n        }\n        else{\n            if(dp0[i][j]<2)dp0[i+1][j]=dp0[i][j]+1;\n            else{\n                dp0[i+1][j]=0;\n                d[j].pb(i+1);\n            }\n            dp1[i+1][j]=dp1[i][j];\n        }\n    }\n    vi ans(modpow(3,l));\n    rep(x,modpow(3,l)){\n        vi t(l);\n        ll k=x;\n        rep(i,l){\n            t[i]=k%3;\n            k/=3;\n        }\n        vi p;\n        rep(i,l){\n            vi np;\n            if(i==0){\n                for(auto y:d[t[i]]){\n                    np.pb(y);\n                }\n                ans[x]+=dp0[n][t[i]];\n            }\n            else{\n                for(auto y:np){\n                    ll nk=dp1[y][t[i]]+1;\n                    if(dp1[y][t[i]]==2){\n                        nk=0;np.pb(y);\n                    }\n                    rep(j,3)if(dp1[y][t[i]]==nk)t[i]=j;\n                }\n                ans[x]+=modpow(3,i)*dp1[n][t[i]];\n            }\n            p=np;\n        }\n    }\n    outv(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:512000000\")\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n#include <bits/stdc++.h>\n#ifdef AIM\n#include <sys/resource.h>\n#endif\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\ntypedef long long li;\ntypedef long double ld;\nvoid solve(__attribute__((unused)) bool);\nvoid precalc();\nclock_t start;\n#define FILENAME \"\"\n\nint main() {\n#ifdef AIM\n  string s = FILENAME;\n//    assert(!s.empty());\n  freopen(\"/home/alexandero/ClionProjects/cryptozoology/input.txt\", \"r\", stdin);\n  //freopen(\"/home/alexandero/ClionProjects/cryptozoology/output.txt\", \"w\", stdout);\n#else\n//    freopen(FILENAME \".in\", \"r\", stdin);\n//    freopen(FILENAME \".out\", \"w\", stdout);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n#endif\n    start = clock();\n    int t = 1;\n#ifndef AIM\n  cout.sync_with_stdio(0);\n  cin.tie(0);\n#endif\n\n#ifdef AIM\n  const rlim_t kStackSize = 256 * 1024 * 1024;\n  struct rlimit rl;\n  int result;\n\n  result = getrlimit(RLIMIT_STACK, &rl);\n  if (result == 0)\n  {\n    if (rl.rlim_cur < kStackSize)\n    {\n      rl.rlim_cur = kStackSize;\n      result = setrlimit(RLIMIT_STACK, &rl);\n      if (result != 0)\n      {\n        fprintf(stderr, \"setrlimit returned result = %d\\n\", result);\n      }\n    }\n  }\n#endif\n\n  precalc();\n  cout.precision(10);\n  cout << fixed;\n  //cin >> t;\n  int testNum = 1;\n  while (t--) {\n      //cout << \"Case #\" << testNum++ << \": \";\n      solve(true);\n  }\n  cout.flush();\n#ifdef AIM1\n    while (true) {\n      solve(false);\n  }\n#endif\n\n#ifdef AIM\n  cout.flush();\n  auto end = clock();\n\n  usleep(10000);\n  print_stats(end - start);\n  usleep(10000);\n#endif\n\n    return 0;\n}\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n    if (!w)\n        return 1 % mod;\n    if (w & 1)\n        return q * 1LL * binpow(q, w - 1, mod) % mod;\n    return binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n    while (w) {\n        q %= w;\n        swap(q, w);\n    }\n    return q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n    return q / gcd(q, w) * w;\n}\n\ntemplate <typename T>\nvoid make_unique(vector<T>& a) {\n    sort(all(a));\n    a.erase(unique(all(a)), a.end());\n}\n\ntemplate<typename T>\nvoid relax_min(T& cur, T val) {\n    cur = min(cur, val);\n}\n\ntemplate<typename T>\nvoid relax_max(T& cur, T val) {\n    cur = max(cur, val);\n}\n\nvoid precalc() {\n}\n\n//#define int li\n//const int mod = 1000000007;\n\nstruct Data {\n  vector<int> vals;\n  string s;\n  void append(char c) {\n    if (!s.empty() && s.back() == 'S' && c == 'S') {\n      s.pop_back();\n    } else {\n      s += c;\n    }\n  }\n  void swap(Data& ot) {\n    vals.swap(ot.vals);\n    s.swap(ot.s);\n  }\n};\n\nvoid solve(__attribute__((unused)) bool read) {\n  int n;\n  cin >> n;\n  string t;\n  cin >> t;\n  string s;\n  for (char c : t) {\n    if (c == 'S' && !s.empty() && s.back() == 'S') {\n      s.pop_back();\n      continue;\n    }\n    s += c;\n  }\n  int step = 1;\n  for (int i = 0; i < n; ++i) {\n    step *= 3;\n  }\n  vector<vector<int>> repr(step, vector<int>(n));\n  for (int val = 0; val < step; ++val) {\n    int m = val;\n    for (int i = 0; i < n; ++i) {\n      repr[val][i] = m % 3;\n      m /= 3;\n    }\n  }\n  vector<int> init(step);\n  iota(all(init), 0);\n  Data initial_data = {init, s};\n  vector<vector<int>> res(step, vector<int>(n));\n  vector<Data> cur_datas = {initial_data};\n  vector<Data> next_datas;\n  for (int w = 0; w < n; ++w) {\n    next_datas.clear();\n    for (auto& data : cur_datas) {\n      vector<Data> new_datas(3);\n      for (int i = 0; i < data.vals.size(); ++i) {\n        new_datas[i % 3].vals.push_back(data.vals[i]);\n      }\n      for (char c : data.s) {\n        if (c == 'R') {\n          new_datas[2].append('R');\n          new_datas[2].swap(new_datas[0]);\n          new_datas[2].swap(new_datas[1]);\n        } else {\n          for (int i = 0; i < 3; ++i) {\n            new_datas[i].append('S');\n          }\n          new_datas[1].swap(new_datas[2]);\n        }\n      }\n      for (int i = 0; i < 3; ++i) {\n        for (int x : new_datas[i].vals) {\n          res[x][w] = i;\n        }\n        next_datas.push_back(new_datas[i]);\n      }\n    }\n    next_datas.swap(cur_datas);\n  }\n  for (int i = 0; i < step; ++i) {\n    int ans = 0;\n    for (int j = n - 1; j >= 0; --j) {\n      ans = ans * 3 + res[i][j];\n    }\n    cout << ans << \" \";\n  }\n  cout << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<bitset>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(long long)((n)-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();++itr)\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n#define inc(x,y) {x+=(y);if(x>=mod)x-=mod;}\n#define dec(x,y) {x-=(y);if(x<0)x+=mod;}\n#define spln(i,n) (i==n?'\\n':' ')\n#define fac_init(n){fac[0]=fac[1]=inv[1]=fi[0]=fi[1]=1;fz(i,2,n){fac[i]=1ll*fac[i-1]*i%mod;inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;fi[i]=1ll*fi[i-1]*inv[i]%mod;}}\nusing namespace std;\ninline void read(int &x)\n{\n\tchar c;int f=1;\n\twhile(!isdigit(c=getchar()))if(c=='-')f=-1;\n\tx=(c&15);while(isdigit(c=getchar()))x=(x<<1)+(x<<3)+(c&15);\n\tx*=f;\n}\nint n,m,i,j,ch[2100005][3],pw3[21],rev[2100005],id[2100005],cnt,ans[2100005];\nstring st;\nint build(int dep,int l)\n{\n\tint x=++cnt;\n\tif(dep==n){\n\t\tid[x]=l;\n\t\treturn x;\n\t}\n\tint t=pw3[dep];\n\tch[x][0]=build(dep+1,l);\n\tch[x][1]=build(dep+1,l+t);\n\tch[x][2]=build(dep+1,l+t+t);\n\treturn x;\n}\nvoid upd(int x)\n{\n\trev[x]^=1;\n\tswap(ch[x][1],ch[x][2]);\n}\nvoid pushdo(int x)\n{\n\tif(rev[x]){\n\t\tupd(ch[x][0]);\n\t\tupd(ch[x][1]);\n\t\tupd(ch[x][2]);\n\t\trev[x]=0;\n\t}\n}\nvoid sft(int x,int d)\n{\n\tif(d==n) return;\n\tpushdo(x);\n\tint tmp=ch[x][0];\n\tch[x][0]=ch[x][2];\n\tch[x][2]=ch[x][1];\n\tch[x][1]=tmp;\n\tsft(ch[x][0],d+1);\n}\nvoid dfs(int dep,int x,int l)\n{\n\tif(dep==n){\n\t\tans[id[x]]=l;\n\t\treturn;\n\t}\n\tint t=pw3[dep];\n\tdfs(dep+1,ch[x][0],l);\n\tdfs(dep+1,ch[x][1],l+t);\n\tdfs(dep+1,ch[x][2],l+t+t);\n}\nint main()\n{\n\tcin>>n;\n\tpw3[0]=1;\n\tfz1(i,n){\n\t\tpw3[i]=3*pw3[i-1];\n\t}\n\tint rt=build(0,0);\n\tcin>>st;\n\tfz0k(i,st.size()){\n\t\tif(st[i]=='S'){\n\t\t\tupd(rt);\n\t\t}\n\t\telse{\n\t\t\tsft(1,0);\n\t\t}\n\t}\n\tdfs(0,rt,0);\n\tfz0k(i,pw3[n]) printf(\"%d \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=600005;\nint n,rt,cnt,ind,pw[N],ch[N][3],tg[N],val[N],ans[N];char s[N];\nvoid bud(int&k1,int k2,int k3){\n\tk1=++cnt;\n\tif(k2==n){val[k1]=k3;return;}\n\trep(i,0,2)bud(ch[k1][i],k2+1,k3+pw[k2]*i);\n}\nvoid pst(int k1){\n\tswap(ch[k1][1],ch[k1][2]);\n\ttg[k1]^=1;\n}\nvoid psd(int k1){\n\tif(tg[k1]){\n\t\tpst(ch[k1][0]);\n\t\tpst(ch[k1][1]);\n\t\tpst(ch[k1][2]);\n\t\ttg[k1]^=1;\n\t}\n}\nvoid go(int k1){\n\tif(!ch[k1][0])return;\n\tpsd(k1);\n\tint t=ch[k1][2];ch[k1][2]=ch[k1][1],ch[k1][1]=ch[k1][0],ch[k1][0]=t;\n\tgo(ch[k1][0]);\n}\nvoid dfs(int k1,int k2,int k3){\n\tif(k2==n){ans[val[k1]]=k3;return;}\n\tpsd(k1);\n\trep(i,0,2)dfs(ch[k1][i],k2+1,k3+pw[k2]*i);\n}\nint main(){\n\tscanf(\"%d%s\",&n,s);\n\tpw[0]=1;rep(i,1,n)pw[i]=pw[i-1]*3;\n\tbud(rt,0,0);\n\tfor(int i=0;s[i];++i){\n\t\tif(s[i]=='S')pst(rt);\n\t\telse go(rt);\n\t}\n\tdfs(rt,0,0);\n\trep(i,0,pw[n]-1)printf(\"%d \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nusing namespace std;\n\nint n;\nstring s;\n\nvoid update(int x, vector<int> &d, vector<int> &salsas)\n{\n    if (salsas[x] % 2)\n    {\n        salsas[x] ^= 1;\n        if (d[x] == 1) d[x] = 2;\n        else if (d[x] == 2) d[x] = 1;\n    }\n}\n\npair<vector<int>, vector<int> > solve(vector<int> last_p, vector<int> last_w)\n{\n    vector<int> p(3 * last_p.size()), w;\n    int n = last_p.size();\n\n    vector<int> d(3 * last_p.size());\n    vector<int> salsas(3 * last_p.size());\n    for (int i = 0; i < n; i++) d[i] = 0;\n    for (int i = n; i < 2 * n; i++) d[i] = 1;\n    for (int i = 2 * n; i < 3 * n; i++) d[i] = 2;\n\n    for (int i = 0; i < s.size(); i++)\n    {\n        int x = last_w[i];\n\n        update(x, d, salsas);\n        update(x + n, d, salsas);\n        update(x + 2 * n, d, salsas);\n\n        if (d[x] == 2) w.push_back(x);\n        if (d[n + x] == 2) w.push_back(n + x);\n        if (d[2 * n + x] == 2) w.push_back(2 * n + x);\n        if (s[i] == 'S')\n        {\n            for (int j = 0; j < d.size(); j++) salsas[j] ^= 1;\n        }\n        else\n        {\n            int x = last_w[i];\n            d[x] = (d[x] + 1) % 3;\n            d[n + x] = (d[n + x] + 1) % 3;\n            d[2 * n + x] = (d[2 * n + x] + 1) % 3;\n        }\n    }\n\n    for (int i = 0; i < 3 * n; i++) update(i, d, salsas);\n    for (int i = 0; i < 3 * n; i++)\n    {\n        p[i] = last_p[i % n] + d[i] * n;\n    }\n\n    return {p, w};\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n    cin >> n;\n    cin >> s;\n\n    vector<int> last_p = {0, 1, 2};\n    vector<int> last_w;\n    for (int i = 0; i < s.size(); i++)\n    {\n        for (int j = 0; j < 3; j++) if (last_p[j] == 2) last_w.push_back(j);\n        if (s[i] == 'S')\n        {\n            int t = 1;\n            for (int k = 0; t && k < 3; k++)\n            {\n                for (int j = 0; t && j < 3; j++)\n                {\n                    if (last_p[k] == 2 && last_p[j] == 1)\n                    {\n                        swap(last_p[k], last_p[j]);\n                        t = 0;\n                    }\n                }\n            }\n        }\n        else\n        {\n            for (int j = 0; j < 3; j++) last_p[j] = (last_p[j] + 1) % 3;\n        }\n    }\n    for (int i = 1; i < n; i++)\n    {\n        pair<vector<int>, vector<int> > gg = solve(last_p, last_w);\n        last_p = gg.first;\n        last_w = gg.second;\n    }\n    #ifdef LOCAL\n    //return 0;\n    #endif // LOCAL\n    for (int i = 0; i < last_p.size(); i++)\n    {\n        cout << last_p[i] << \" \";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//     自己选择的路，跪着也要走完。朋友们，虽然这个世界日益浮躁起来，只\n// 要能够为了当时纯粹的梦想和感动坚持努力下去，不管其它人怎么样，我们也\n// 能够保持自己的本色走下去。                               ——陈立杰\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef signed char          int8;\ntypedef unsigned char       uint8;\ntypedef short                int16;\ntypedef unsigned short      uint16;\ntypedef int                  int32;\ntypedef unsigned            uint32;\ntypedef long long            int64;\ntypedef unsigned long long  uint64;\n\ntemplate <typename Int>\ninline Int read()       \n{\n    Int flag = 1;\n    char c = getchar();\n    while ((!isdigit(c)) && c != '-') c = getchar();\n    if (c == '-') flag = -1, c = getchar();\n    Int init = c & 15;\n    while (isdigit(c = getchar())) init = (init << 3) + (init << 1) + (c & 15);\n\treturn init * flag;\n}\n\ntemplate <typename Int>\ninline Int read(char &c)       \n{\n    Int flag = 1;\n    c = getchar();\n    while ((!isdigit(c)) && c != '-') c = getchar();\n    if (c == '-') flag = -1, c = getchar();\n    Int init = c & 15;\n    while (isdigit(c = getchar())) init = (init << 3) + (init << 1) + (c & 15);\n\treturn init * flag;\n}\n\ntemplate <typename Int>\ninline void write(Int x)\n{\n    if (x < 0) putchar('-'), x = ~x + 1;\n    if (x > 9) write(x / 10);\n    putchar((x % 10) | 48);\n}  \n\ntemplate <typename Int>\ninline void write(Int x, char nextch)\n{\n    write(x);\n    putchar(nextch);\n}\n\nint n, _3n;\nchar t[200007], len;\n\nstruct M {\n    int p[540000];\n    M operator* (const M &T) {\n        M ret;\n        for (int i = 0; i < _3n; i++) \n            ret.p[i] = T.p[p[i]];\n        return ret;\n    }\n} base, S, R;\n\nint TmpTurnArr[3] = {0, 2, 1};\nint turn(int p) {\n    // printf(\"turn(%d) = \", p);\n    int digit[13], cnt = 0, res = 0;\n    while (p) {\n        digit[cnt++] = p % 3;\n        p /= 3;\n    }\n    while (~(--cnt)) {\n        res = res * 3 + TmpTurnArr[digit[cnt]];\n    }\n    // printf(\"%d\\n\", res);\n    return res;\n}\n\ninline M fpow(M x, int n) {\n    M ret = base;\n    while (n) {\n        if (n & 1) ret = ret * x;\n        x = x * x;\n        n >>= 1;\n    }\n    return ret;\n}\n\nM genR(int k) {\n    M ret;\n    for (int i = 0; i < _3n; i++) {\n        ret.p[i] = (i + k) % _3n;\n    }\n    return ret;\n}\n\nint chk(int p) {\n    int cS = 0;\n    if (t[p] != 'S') return false;\n    while (t[p] == 'S') {\n        cS++;\n        p++;\n    }\n    if (!(cS & 1)) return false;\n    if (t[p] == 'R') return p + 1;\n    return false;\n}\n\nint main() {\n    n = read<int>();\n    _3n = pow(3, n) + 0.5;\n    scanf(\"%s\", t);\n    len = strlen(t);\n    for (int i = 0; i < _3n; i++) {\n        S.p[i] = turn(i);\n        R.p[i] = i + 1;\n        base.p[i] = i;\n    }\n    R.p[_3n - 1] = 0;\n    M ans = base;\n    int cS = 0, cR = 0, cSR = 0;\n    for (int i = 0, nRet; i < len; i++) {\n        if (chk(i)) {\n            if (cR) ans = ans * genR(cR);\n            if (cS) ans = ans * S;\n            // printf(\"Until %d:\\n\", i - 1);\n            // for (int j = 0; j < _3n; j++) {\n            //     write(ans.p[j], j == _3n - 1 ? 10 : 32);\n            // }\n            while (nRet = chk(i)) {\n                // printf(\"SR jump from %d to %d\\n\", i, nRet);\n                cSR++;\n                i = nRet;\n            }\n            ans = ans * fpow(S * R, cSR);\n            cR = cS = cSR = 0;\n        }\n        if (t[i] == 'S') {\n            if (cR) {\n                ans = ans * genR(cR);\n                cS = 1;\n                cR = 0;\n            } else cS ^= 1;\n        } else if (t[i] == 'R') {\n            if (cS) {\n                ans = ans * S;\n                cS = 0;\n            } \n            cR++;\n        }\n        // printf(\"Until %d:\\n\", i);\n        // for (int j = 0; j < _3n; j++) {\n        //     write(ans.p[j], j == _3n - 1 ? 10 : 32);\n        // }\n    }\n    \n    if (cR) ans = ans * genR(cR);\n    if (cS) ans = ans * S;\n    // M H = base * S * S * R * R * R * S;\n    for (int i = 0; i < _3n; i++) {\n        write(ans.p[i], i == _3n - 1 ? 10 : 32);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> to3(int x) {\n  vector<int> v(0);\n  if (x == 0)\n    v = {0};\n  else\n    while (x > 0) {\n      int r;\n      r = x % 3;\n      x /= 3;\n      v.push_back(r);\n    }\n  return v;\n}\n\nvector<int> change12(vector<int> v) {\n  for (int i = 0; i < v.size(); i++) {\n    if (v.at(i) == 1)\n      v.at(i) = 2;\n    else if (v.at(i) == 2)\n      v.at(i) = 1;\n  }\n  return v;\n}\n\nint from3(vector<int> v) {\n  int s = 0;\n  for (int i = 0; i < v.size(); i++) {\n   int t = v.at(i);\n    for (int j = 0; j < i; j++) {\n      t *= 3;\n    }\n    s += t;\n  }\n  return s;\n}\n    \n\nint main() {\n  int n;\n  cin >> n;\n  int n3 = 1;\n  for (int i = 0; i < n; i++) {\n    n3 *= 3;\n  }\n  vector<int> p(n3);\n  for (int i = 0; i < n3; i++) {\n    p.at(i) = i;\n  }\n  \n  string t;\n  cin >> t;\n  for (int i = 0; i < t.size(); i++) {\n    if (t.at(i) == 'S') {\n      for (int j = 0; j < n3; j++) {\n        vector<int> a1 = to3(p.at(j));\n        vector<int> a2 = change12(a1);\n        int a3 = from3(a2);\n        if (a3 == n3)\n          p.at(j) = 0;\n        else\n          p.at(j) = a3;\n      }\n    }\n    if (t.at(i) == 'R') {\n      for (int j = 0; j < n3; j++) {\n        if (p.at(j) == n3 - 1)\n          p.at(j) = 0;\n        else \n          p.at(j)++;\n      }\n    }\n  }\n  for (int i = 0; i < n3; i++) {\n    cout << p.at(i);\n    if (i == n3 - 1)\n      cout << endl;\n    else\n      cout << ' ';\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define sz(a) int(a.size())\nconst int N=2e6+10;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nint n,m,ch[N][3],tt,id[N],len,pos[N];\nbool rev[N];\nchar s[N];\n\nvoid reverse(int x) {\n\trev[x]^=1;swap(ch[x][1],ch[x][2]);\n}\n\nvoid down(int x) {\n\tif(rev[x]) {\n\t\tfor(int i=0;i<3;i++) reverse(ch[x][i]);\n\t\trev[x]=0;\n\t}\n}\n\nint main() {\n\tcin>>m;n=powl(3,m)+0.5;scanf(\"%s\",s+1);len=strlen(s+1);\n\tfor(int i=0;i<n;i++) {\n\t\tint x=i,u=0;\n\t\tfor(int j=0;j<m;j++) {\n\t\t\tif(!ch[u][x%3]) ch[u][x%3]=++tt;\n\t\t\tu=ch[u][x%3];x/=3;\n\t\t}\n\t\tid[u]=i;\n\t}\n\tfor(int now=1;now<=len;now++)\n\t\tif(s[now]=='S') reverse(0);\n\t\telse {\n\t\t\tint u=0;\n\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\tdown(u);\n\t\t\t\tint tmp=ch[u][2];ch[u][2]=ch[u][1];ch[u][1]=ch[u][0];ch[u][0]=tmp;\n\t\t\t\tu=ch[u][0];\n\t\t\t}\n\t\t}\n\tfor(int i=0;i<n;i++) {\n\t\tint x=i,u=0;\n\t\tfor(int j=0;j<m;j++) {\n\t\t\tdown(u);\n\t\t\tu=ch[u][x%3];x/=3;\n\t\t}\n\t\tpos[id[u]]=i;\n\t}\n\tfor(int i=0;i<n;i++) cout<<pos[i]<<' ';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <string.h>\nusing namespace std;\n\nint *g_movs;\nint *g_movr;\nint g_total;\n\nvoid posprint(int *pos)\n{\n    for( int i = 0; i < g_total; i++)\n    {\n        if (i > 0) cout << \" \";\n        cout << pos[i];\n    }\n    cout << \"\\n\";\n}\n\nint main(void)\n{\n    int n;\n    int ans = 0;\n    int t;\n    char *seq;\n    cin >> n;\n    g_total = 1;\n    for( int i = 0; i < n; i++) g_total *= 3;\n\n    {\n        string s;\n        getline(cin,s); // 改行読み飛ばし\n        getline(cin,s);\n\n        t = (int)(s.length());\n        seq = (char*)malloc(t);\n\n\n        for( int i = 0; i < t; i++)\n        {\n            if (s[i] == 'S') \n            {\n                seq[i] = 0;\n            }\n            else\n            {\n                seq[i] = 1;\n            }        \n        }\n    }\n\n    // テーブル作成\n    g_movs = (int*) malloc(sizeof(int) * g_total);\n    g_movr = (int*) malloc(sizeof(int) * g_total);\n    int *tmptable = (int*) malloc(sizeof(int) * n);\n    for( int i = 0; i < g_total; i++)\n    {\n        int tmp = i;\n        for( int j = 0; j < n; j++)\n        {\n            tmptable[j] = tmp % 3;\n            tmp /= 3;\n        }\n        tmp = 0;\n        for( int j = n - 1; j >= 0; j--)\n        {\n            tmp = tmp * 3;\n            if( tmptable[j] == 1 ) tmp += 2;\n            if( tmptable[j] == 2 ) tmp += 1;\n        }\n\n        g_movs[i] = tmp;\n\n        if( i == 0 )\n        {\n            g_movr[i] = g_total - 1;\n        }\n        else\n        {\n            g_movr[i] = i - 1;\n        }\n    }\n\n    int *pos1 = (int*) malloc(sizeof(int) * g_total);\n    int *pos2 = (int*) malloc(sizeof(int) * g_total);\n    int *current = pos1;\n\n    for( int i = 0; i < g_total; i++) current[i] = i;\n\n    for( int j = 0; j < t; j++ )\n    {\n        int *next = pos2;\n        if(current == pos2 ) next = pos1;\n\n        int *ct = g_movs;\n        if( seq[j] == 1 )  ct = g_movr;\n        for( int i = 0; i < g_total; i++)\n        {\n            next[i] = current[ct[i]];\n        }\n        \n        current = next;\n//        posprint(current);\n    }\n\n    {\n        int *next = pos2;\n        if(current == pos2 ) next = pos1;\n\n        for( int i = 0; i < g_total; i++)\n        {\n            next[current[i]] = i;\n        }\n        posprint(next);\n    }\n\n\n\n\n    free(seq);\n    free(g_movs);\n    free(g_movr);\n    free(tmptable);\n    free(pos1);\n    free(pos2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<bitset>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(long long)((n)-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();++itr)\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n#define inc(x,y) {x+=(y);if(x>=mod)x-=mod;}\n#define dec(x,y) {x-=(y);if(x<0)x+=mod;}\n#define spln(i,n) (i==n?'\\n':' ')\n#define fac_init(n){fac[0]=fac[1]=inv[1]=fi[0]=fi[1]=1;fz(i,2,n){fac[i]=1ll*fac[i-1]*i%mod;inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;fi[i]=1ll*fi[i-1]*inv[i]%mod;}}\nusing namespace std;\ninline void read(int &x)\n{\n\tchar c;int f=1;\n\twhile(!isdigit(c=getchar()))if(c=='-')f=-1;\n\tx=(c&15);while(isdigit(c=getchar()))x=(x<<1)+(x<<3)+(c&15);\n\tx*=f;\n}\nint n,m,i,j,ch[2100005][3],pw3[21],rev[2100005],id[2100005],cnt,ans[2100005];\nstring st;\nint build(int dep,int l)\n{\n\tint x=++cnt;\n\tif(dep==n){\n\t\tid[x]=l;\n\t\treturn x;\n\t}\n\tint t=pw3[dep];\n\tch[x][0]=build(dep+1,l);\n\tch[x][1]=build(dep+1,l+t);\n\tch[x][2]=build(dep+1,l+t+t);\n\treturn x;\n}\nvoid upd(int x)\n{\n\trev[x]^=1;\n\tswap(ch[x][1],ch[x][2]);\n}\nvoid pushdo(int x)\n{\n\tif(rev[x]){\n\t\tupd(ch[x][0]);\n\t\tupd(ch[x][1]);\n\t\tupd(ch[x][2]);\n\t\trev[x]=0;\n\t}\n}\nvoid sft(int x,int d)\n{\n\tif(d==n) return;\n\tpushdo(x);\n\tint tmp=ch[x][0];\n\tch[x][0]=ch[x][2];\n\tch[x][2]=ch[x][1];\n\tch[x][1]=tmp;\n\tsft(ch[x][0],d+1);\n}\nvoid dfs(int dep,int x,int l)\n{\n\tif(dep==n){\n\t\tans[id[x]]=l;\n\t\treturn;\n\t}\n\tpushdo(x);\n\tint t=pw3[dep];\n\tdfs(dep+1,ch[x][0],l);\n\tdfs(dep+1,ch[x][1],l+t);\n\tdfs(dep+1,ch[x][2],l+t+t);\n}\nint main()\n{\n\tcin>>n;\n\tpw3[0]=1;\n\tfz1(i,n){\n\t\tpw3[i]=3*pw3[i-1];\n\t}\n\tint rt=build(0,0);\n\tcin>>st;\n\tfz0k(i,st.size()){\n\t\tif(st[i]=='S'){\n\t\t\tupd(rt);\n\t\t}\n\t\telse{\n\t\t\tsft(1,0);\n\t\t}\n\t}\n\tdfs(0,rt,0);\n\tfz0k(i,pw3[n]) printf(\"%d \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nusing namespace std;\n\nint n, Q;\nstring s;\n\nvoid update(int x, vector<int> &d, vector<int> &salsas)\n{\n    if (salsas[x] != Q)\n    {\n        salsas[x] ^= 1;\n        if (d[x] == 1) d[x] = 2;\n        else if (d[x] == 2) d[x] = 1;\n    }\n}\n\npair<vector<int>, vector<int> > solve(vector<int> last_p, vector<int> last_w)\n{\n    Q = 0;\n    vector<int> p(3 * last_p.size()), w;\n    int n = last_p.size();\n\n    vector<int> d(3 * last_p.size());\n    vector<int> salsas(3 * last_p.size());\n    for (int i = 0; i < n; i++) d[i] = 0;\n    for (int i = n; i < 2 * n; i++) d[i] = 1;\n    for (int i = 2 * n; i < 3 * n; i++) d[i] = 2;\n\n    for (int i = 0; i < s.size(); i++)\n    {\n        int x = last_w[i];\n\n        update(x, d, salsas);\n        update(x + n, d, salsas);\n        update(x + 2 * n, d, salsas);\n\n        if (d[x] == 2) w.push_back(x);\n        if (d[n + x] == 2) w.push_back(n + x);\n        if (d[2 * n + x] == 2) w.push_back(2 * n + x);\n        if (s[i] == 'S')\n        {\n            Q ^= 1;\n        }\n        else\n        {\n            int x = last_w[i];\n            d[x] = (d[x] + 1) % 3;\n            d[n + x] = (d[n + x] + 1) % 3;\n            d[2 * n + x] = (d[2 * n + x] + 1) % 3;\n        }\n    }\n\n    for (int i = 0; i < 3 * n; i++) update(i, d, salsas);\n    for (int i = 0; i < 3 * n; i++)\n    {\n        p[i] = last_p[i % n] + d[i] * n;\n    }\n\n    return {p, w};\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0); cout.tie(0);\n    cin >> n;\n    cin >> s;\n\n    vector<int> last_p = {0, 1, 2};\n    vector<int> last_w;\n    for (int i = 0; i < s.size(); i++)\n    {\n        for (int j = 0; j < 3; j++) if (last_p[j] == 2) last_w.push_back(j);\n        if (s[i] == 'S')\n        {\n            int t = 1;\n            for (int k = 0; t && k < 3; k++)\n            {\n                for (int j = 0; t && j < 3; j++)\n                {\n                    if (last_p[k] == 2 && last_p[j] == 1)\n                    {\n                        swap(last_p[k], last_p[j]);\n                        t = 0;\n                    }\n                }\n            }\n        }\n        else\n        {\n            for (int j = 0; j < 3; j++) last_p[j] = (last_p[j] + 1) % 3;\n        }\n    }\n    for (int i = 1; i < n; i++)\n    {\n        pair<vector<int>, vector<int> > gg = solve(last_p, last_w);\n        last_p = gg.first;\n        last_w = gg.second;\n    }\n    #ifdef LOCAL\n    //return 0;\n    #endif // LOCAL\n    for (int i = 0; i < last_p.size(); i++)\n    {\n        cout << last_p[i] << \" \";\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint PREP = (cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(9), 0);\n//int SEGV = getenv(\"D\") || (exit(system(\"D= SEGFAULT_SIGNALS=all catchsegv ./prog.exe\") >> 8), 0);\nconst array<int, 3> NEXT = { 0, 2, 1 };\nvector<int> POW3;\nvector<vector<int>> poss;\nvector<vector<string>> strs;\nvoid init(int N, const string &T) {\n    POW3.resize(N + 1);\n    POW3[0] = 1;\n    for (int i = 1; i <= N; i++) POW3[i] = POW3[i - 1] * 3;\n    poss.resize(N + 1);\n    strs.resize(N + 1);\n    for (int i = 0; i <= N; i++) {\n        poss[i].resize(POW3[i], -1);\n        strs[i].resize(POW3[i]);\n    }\n    poss[0][0] = 0;\n    strs[0][0] = T;\n}\nvoid f(int k, int p) {\n    if (poss[k][p] != -1) return;\n    f(k - 1, p % POW3[k - 1]);\n    int t = p / POW3[k - 1];\n    string U;\n    for (auto c : strs[k - 1][p % POW3[k - 1]]) {\n        if (c == 'S') {\n            t = NEXT[t];\n            if (!U.empty() && U.back() == 'S') {\n                U.pop_back();\n            } else {\n                U.push_back('S');\n            }\n        } else {\n            t = (t + 1) % 3;\n            if (t == 0) {\n                U.push_back('R');\n            }\n        }\n    }\n    poss[k][p] = t * POW3[k - 1] + poss[k - 1][p % POW3[k - 1]];\n    strs[k][p] = U;\n}\nint main() {\n    int N; string T; cin >> N >> T;\n    init(N, T);\n    for (int i = 0; i < POW3[N]; i++) {\n        f(N, i);\n        cout << poss[N][i] << \" \\n\"[i + 1 == POW3[N]];\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint ch[600005][3],ed[600005],cnt=1,ans[600005];\nbool rev[600005];\nchar s[200005];\nvoid pushr(int x){swap(ch[x][1],ch[x][2]);rev[x]^=1;}\nvoid pushdown(int x)\n{\n    if(!rev[x])return;\n    for(int i=0;i<=2;i++)if(ch[x][i])pushr(ch[x][i]);\n    rev[x]=0;\n}\nvoid dfs(int x)\n{\n    pushdown(x);\n    swap(ch[x][0],ch[x][2]),swap(ch[x][1],ch[x][2]);\n    if(ch[x][0])dfs(ch[x][0]);\n}\nvoid get(int x,int now,int pw)\n{\n    pushdown(x);\n    if(ed[x]!=0xffffffff)ans[ed[x]]=now;\n    if(ch[x][0])get(ch[x][0],now,pw*3);\n    if(ch[x][1])get(ch[x][1],now+pw,pw*3);\n    if(ch[x][2])get(ch[x][2],now+2*pw,pw*3);\n}\nint main()\n{\n    int n,m=1;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)m*=3;\n    memset(ed,0xff,sizeof(ed));\n    for(int i=0;i<m;i++)\n    {\n        int now=1,tmp=i;\n        for(int k=0;k<n;k++)\n        {\n            int t=tmp%3;\n            tmp/=3;\n            if(!ch[now][t])ch[now][t]=++cnt;\n            now=ch[now][t];\n        }\n        ed[now]=i;\n    }\n    scanf(\"%s\",s+1);\n    int q=strlen(s+1);\n    for(int i=1;i<=q;i++)\n    {\n        if(s[i]=='S')pushr(1);\n        else dfs(1);\n    }\n    get(1,0,1);\n    for(int i=0;i<m;i++)printf(\"%d \",ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint pow(int b, int e) {\n\tif (e == 1) {\n\t\treturn b;\n\t}\n\telse {\n\t\treturn(pow(b, e - 1) * b);\n\t}\n}\n\nint trt(int t, int n) {\n\tif (t / n == 0) return t;\n\tint x = (t % (n * 3)) / n;\n\tint y = (x == 1) ? 2 : ((x == 2) ? 1 : 0);\n\treturn trt(t - x * n + y * n, n * 3);\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\tint M = pow(3, N);\n\tqueue<int> RS;\n\tchar *s = new char[M + 1];\n\tcin >> s;\n\tchar* p = s;\n\tint sw = 0;\n\tint c = 1;\n\ts[M] = '\\0';\n\tfor (int i = 0; i <= M; i++) { // R = 82 = 平行移動, S = 83 = 3置換\n\t\tif (*p == sw) {\n\t\t\tc++;\n\t\t}\n\t\telse {\n\t\t\tif (sw == 83) {\n\t\t\t\tif (c % 2 == 1) {\n\t\t\t\t\tRS.push(-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (sw == 82) {\n\t\t\t\tRS.push(c);\n\t\t\t}\n\t\t\tc = 1;\n\t\t\tsw = *p;\n\t\t}\n\t\tp++;\n\t}\n\n\tvector<int> A(M, 0); // current status\n\tfor (int i = 0; i < M; i++) A[i] = i;\n\tdeque<pair<int,int> > P; // 置換index\n\n\t// swap set\t作成\n\tvector<int> W(M, 0);\n\tfor (int i = 0; i < M; i++){\n\t\tif(W[i] == 0){\n\t\t\tint j = trt(i, 1);\n\t\t\tW[i] = j;\n\t\t\tW[j] = i;\n\t\t\tP.push_back(pair<int, int>(i, j));\n\t\t}\n\t}\n//\tfor (auto it = P.begin(); it != P.end(); it++) {\n//\t\tcout << \"P:\" << it->first << \",\" << it->second << endl;\n//\t}\n\n\t// calc\n\tint x = 0; // 0位置を示す\n//\tfor (int i = 0; i < M; i++) {\n//\t\tcout << A[(i + x) % M] << \" \";\n//\t}\n//\tcout << endl;\n\twhile (!RS.empty()) {\n\t\tint rs = RS.front();\n\t\tRS.pop();\n\t\tif (rs == -1) {\n\t\t\t// 置換\n\t\t\tfor (auto it = P.begin(); it != P.end(); it++) {\n\t\t\t\tswap(A[(x + it->first) % M], A[(x + it->second) % M]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tx = (((x - rs) % M) + M) % M;\n\t\t}\n\t\t// out\n//\t\tcout << rs << \": \";\n//\t\tfor (int i = 0; i < M; i++) {\n//\t\t\tcout << A[(i + x) % M] << \" \";\n//\t\t}\n//\t\tcout << endl;\n\n\t}\n\n\t// out\n\tvector<int> B(M, 0); // A[i] = i番目のセルにいる人の名前 -> B[i] = iさんがB[i]にいる\n\tfor (int i = 0; i < M; i++) {\n\t\tB[A[(i + x) % M]] = i;\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tcout << B[i] << \" \";\n\t}\n\tcout << endl;\n\treturn(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\n\nconst int mod = 1e9+7;\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst int maxn = (531441+1)*3;\nint go[maxn*3][3], lz[maxn], pid[maxn];\nint K, n, pw[13];\nvoid build(int x, int lv, int id)\n{\n\tif (lv==K)\n\t{\n\t\tpid[x] = id;\n\t\treturn;\n\t}\n\tfor (int i=0; i<3; i++)\n\t{\n\t\tgo[x][i] = x*3+i;\n\t\tbuild(x*3+i, lv+1, id+i*pw[lv]);\n\t}\n}\nvoid pushdown(int x)\n{\n\tif (lz[x])\n\t{\n\t\tswap(go[x][1], go[x][2]);\n\t\tlz[go[x][0]] ^= 1;\n\t\tlz[go[x][1]] ^= 1;\n\t\tlz[go[x][2]] ^= 1;\n\t\tlz[x] = 0;\n\t}\n}\nvoid add(int x, int lv)\n{\n\tif (lv==K) return;\n\tpushdown(x);\n\tadd(go[x][2], lv+1);\n\tswap(go[x][1], go[x][2]);\n\tswap(go[x][0], go[x][1]);\n}\nint ans[maxn];\nvoid dfs(int x, int lv, int pos)\n{\n\tif (lv==K)\n\t{\n\t\tans[pid[x]] = pos;\n\t\treturn;\n\t}\n\tpushdown(x);\n\tfor (int i=0; i<3; i++)\n\t{\n\t\tdfs(go[x][i], lv+1, pos+pw[lv]*i);\n\t}\n}\nint main()\n{\n\tpw[0] = 1;\n\tfor (int i=1; i<=12; i++) pw[i] = pw[i-1]*3;\n\tscanf(\"%d\", &K);\n\tn = pw[K];\n\tbuild(1, 0, 0);\n\tstatic char s[200111];\n\tscanf(\"%s\", s);\n\tint len = strlen(s);\n\tfor (int i=0; i<len; i++)\n\t{\n\t\tif (s[i]=='S')\n\t\t{\n\t\t\tlz[1] ^= 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tadd(1, 0);\n\t\t}\n\t}\n\tdfs(1, 0, 0);\n\tfor (int i=0; i<n; i++) puti(ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define SZ(v) ((int)(v).size())\nusing ll = long long;\n\nint calc_salsa(int u)\n{\n\tint ret(0);\n\tint p(1);\n\twhile (u > 0)\n\t{\n\t\tint dig = u%3;\n\t\tif (dig==1)\n\t\t\tdig = 2;\n\t\telse if (dig == 2)\n\t\t\tdig = 1;\n\t\tret += dig * p;\n\t\tp *= 3;\n\t\tu /= 3;\n\t}\n\treturn ret;\n}\n\nint fast_pow(int a, int b)\n{\n\tint ret(1);\n\tfor (int p(a); b; p *= p, b /= 2)\n\t\tif (b%2)\n\t\t\tret *= p;\n\treturn ret;\n}\n\nint main(void)\n{\n\tios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n\tint N;\n\tcin >> N;\n\tint MAGIC = N/2;\n\n\tint nb_tot = fast_pow(3, N);\n\tvector<int> salsa(nb_tot);\n\tfor (int i(0); i < nb_tot; ++i)\n\t\tsalsa[i] = calc_salsa(i);\n\tint pref_sz = fast_pow(3, MAGIC);\n\tint suff_sz = fast_pow(3, N - MAGIC);\n\tvector<int> perm_pref(pref_sz);\n\tvector<int> cur_suf(nb_tot);\n\tfor (int i(0); i < nb_tot; ++i)\n\t\tcur_suf[i] = i/pref_sz;\n\tfor(int i(0); i < pref_sz; ++i)\n\t\tperm_pref[i] = i;\n\tint nb_salsa(0);\n\tvector<int> salsa_faites(nb_tot);\n\n\tstring danse;\n\tcin >> danse;\n\n\tfor (auto c : danse)\n\t{\n\t\tif (c == 'S')\n\t\t{\n\t\t\t++nb_salsa;\n\t\t\tfor (int i(0); i < pref_sz; ++i)\n\t\t\t\tperm_pref[i] = salsa[perm_pref[i]];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i(0); i < pref_sz; ++i)\n\t\t\t{\n\t\t\t\tperm_pref[i] = (perm_pref[i] + 1)%pref_sz;\n\t\t\t\tif (!perm_pref[i])\n\t\t\t\t\tfor (int j(0); j < suff_sz; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (salsa_faites[i + j*pref_sz] % 2 != nb_salsa%2)\n\t\t\t\t\t\t\tcur_suf[j*pref_sz+i] = salsa[cur_suf[j*pref_sz+i]];\n\t\t\t\t\t\tsalsa_faites[i + j * pref_sz] = nb_salsa;\n\t\t\t\t\t\tcur_suf[j * pref_sz + i] = (cur_suf[j*pref_sz+i] + 1)%suff_sz;\n\t\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i(0); i < nb_tot; ++i)\n\t{\n\t\tint pref = i % pref_sz;\n\t\tif (salsa_faites[i] % 2 != nb_salsa%2)\n\t\t\tcur_suf[i] = salsa[cur_suf[i]];\n\t\tcout << pref_sz * cur_suf[i] + perm_pref[pref] << ' ';\n\t}\n\tcout << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid salsa(vector<int> &ans,vector<int> &sal){\n  for(int i=0;i<(int)ans.size();i++){\n    ans.at(i) = sal.at(ans.at(i));\n  }\n}\nvoid rumba(vector<int> &ans){\n  for(int j=0;j<(int)ans.size();j++){\n    if(ans.at(j)+1 < (int)ans.size()){\n      ans.at(j) ++;\n    }\n    else{\n      ans.at(j) = ans.at(j)+1 - (int)ans.size();\n    }\n  }\n}\n\nint main(){\n  int n;\n  string t;\n  cin >> n >> t;\n  int n3 = pow(3,n);\n  vector<int> ans(n3);\n  vector<int> sal(n3);\n  for(int i=0;i<n3;i++){\n    ans.at(i) = i;\n    sal.at(i) = i;\n  }\n  \n  for(int i=0;i<n3;i++){\n    int a = sal.at(i);\n    int j=0;\n    while(a > 3){\n      if(a%3 == 1){\n        sal.at(i) += pow(3,j);\n      }\n      else if(a%3 == 2){\n        sal.at(i) -= pow(3,j);\n      }\n      a = a/3;\n      j++;\n    }\n    if(a == 1){\n      sal.at(i) += pow(3,j);\n    }\n    else if(a == 2){\n      sal.at(i)-= pow(3,j);\n    }\n    if(a == 3){\n      sal.at(i) += pow(3,j+1);\n    }\n  }\n  for(int i=0;i<(int)t.length();i++){\n    if(t.at(i) == 'S'){\n      salsa(ans,sal);\n    }\n    else{\n      rumba(ans);\n    }\n  }\n  for(int j=0;j<n3;j++){\n    cout << ans.at(j);\n    if(j != n3-1){\n      cout << \" \";\n    }\n  }\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint change3(int A){\n  vector<int> b3(0);\n  while(A>2){\n    int aw3 = A%3;\n    b3.push_back((aw3==0)?0:\n                 (aw3==1)?2:1);\n    A/=3;\n  }\n  int aw3 = A%3;\n  b3.push_back((aw3==0)?0:\n               (aw3==1)?2:1);\n  int sum=0;\n  for(int i=0;i<b3.size();i++){\n   sum+= pow(3,i)*b3.at(i); \n  }\n  return sum;\n}\n\n\nint main() {\n  int N;\n  cin >> N;\n  int N3 = pow(3,N);\n  vector<int> dan(N3);\n  vector<int> c3b(N3);\n  for(int i=0;i<N3;i++){\n    dan.at(i)=i;\n    c3b.at(i)=change3(i);\n  }\n  string recode;\n  vector<pair<bool,int>> recode2;\n  cin >> recode;\n  string set=\"\";\n  string recode3=\"\";\n  char mi=recode.at(0);\n  bool flg=true;\n  int coco=0;\n  recode+=char(0);\n  for(char i:recode){\n    if(i==mi){\n      set+=i;\n    }else{\n      if(!(set.at(0)=='S'&&set.size()%2==0))recode3+=set;\n      set=i;\n    }\n    mi=i;\n  }\n  \n  if(recode3.size()){\n  \n  mi=recode3.at(0);\n  recode3+=(recode3.at(recode3.size()-1)=='S')?'R':'S';\n  for(char i:recode3){\n    if(mi!=i){\n     flg=(i=='S')?false:true;\n     recode2.push_back(make_pair(flg,coco));\n      coco=0;\n    }\n    coco++;\n    mi=i; \n  }\n  \n  \n  /*\n  for(pair<bool,int> i:recode2){\n   printf(\"%d %d \\n\",i.first,i.second); \n  }\n  \n  return 0;*/\n  \n  for(pair<bool,int> i:recode2){\n    if(i.first){\n     for(int &j:dan){\n      j=c3b.at(j); \n     }\n    }else if(!i.first){\n      for(int &j:dan){\n        j+=i.second;\n        if(j>=N3)j-=N3;\n      }\n    }\n      \n      \n  }\n    \n  }\n    \n  for(int i:dan){\n    cout << i << \" \";\n  }\n  cout << endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct mat{int dat[531441];}O,C,S[18],R[18],OO;\nint sal[531441],rum[531441];\nint n,m,cu,ni,nni,tmp;\nstring t;\nmat mul(mat a,mat b){\n\tfor(int i=0;i<m;i++) C.dat[b.dat[i]]=a.dat[i];\n\treturn C;\n}\nint main(){\n\t#ifdef FILIN\n\t\t#ifndef DavidDesktop\n\t\t\tfreopen(FILIN,\"r\",stdin);\n\t\t\tfreopen(FILOUT,\"w\",stdout);\n\t\t#endif\n\t#endif\n\tios::sync_with_stdio(0);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tcin>>n>>t;\n\tm=1;\n\tfor(int i=1;i<=n;i++) m*=3;\n\tfor(int i=0;i<m;i++) O.dat[i]=i;\n\tfor(int i=0;i<m;i++) rum[i]=(i+1)%m;\n\tfor(int i=0;i<m;i++){\n\t\tni=0;\n\t\ttmp=i;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i%3==0) ni=(ni*3);\n\t\t\tif(i%3==1) ni=(ni*3)+2;\n\t\t\tif(i%3==2) ni=(ni*3)+1;\n\t\t\ti/=3;\n\t\t}\n\t\tnni=0;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tnni=(nni*3)+(ni%3);\n\t\t\tni/=3;\n\t\t}\n\t\ti=tmp;\n\t\tsal[i]=nni;\n\t}\n\tfor(int i=0;i<m;i++) R[0].dat[i]=rum[i];\n\tfor(int i=0;i<m;i++) S[0].dat[i]=sal[i];\n\tfor(int i=1;i<18;i++){\n\t\tR[i]=mul(R[i-1],R[i-1]);\n\t\tS[i]=mul(S[i-1],S[i-1]);\n\t}\n\tcu=1;\n\tt+=\"F\";\n\tfor(int i=1;i<t.size();i++){\n\t\tif(t[i]!=t[i-1]){\n\t\t\tif(t[i-1]=='R'){\n\t\t\t\tO=mul(O,R[0]);\n\t\t\t\tcu--;\n\t\t\t\tfor(int j=17;j>=0;j--)\n\t\t\t\t\tif((cu>>j)&1)\n\t\t\t\t\t\tO=mul(O,R[j]);\n\t\t\t}\n\t\t\tif(t[i-1]=='S'){\n\t\t\t\tO=mul(O,S[0]);\n\t\t\t\tcu--;\n\t\t\t\tfor(int j=17;j>=0;j--)\n\t\t\t\t\tif((cu>>j)&1)\n\t\t\t\t\t\tO=mul(O,S[j]);\n\t\t\t}\n\t\t\tcu=0;\n\t\t}\n\t\tcu++;\n\t}\n\tfor(int i=0;i<m;i++) OO.dat[O.dat[i]]=i;\n\tfor(int i=0;i<m;i++) cout<<OO.dat[i]<<' ';\n\tcout<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define putchar_unlocked putchar\n\nchar T[524288];\n\n// Based on editorial solution\nint D[13][550005]; // one digit at a time, with digit 0 representing the ones place\nint W[13][550005];\nint lastUpdated[13][550005];\n\nint x[11];\ninline void putInt(int i){\n    if(i==0){putchar_unlocked('0');}\n    else{\n    int count1=0;\n    while(i>0){\n        x[count1++]=i%10;\n        i/=10;\n    }\n    for(int j=count1-1;j>=0;j--){\n        putchar_unlocked(48+x[j]);\n    }\n    }\n    putchar_unlocked(' ');\n}\n\nint N;\n\ninline void update(int n, int indx, int cntS){\n    if( ((cntS&1) != (lastUpdated[n][indx]&1)) && D[n][indx]){\n        // conduct salsa\n        D[n][indx] = 3-D[n][indx];\n    }\n    // update the lastUpdated index\n    lastUpdated[n][indx] = cntS;\n}\n\nint pow3[16];\n\nint main(){\n    scanf(\"%d\", &N);\n    scanf(\" %s\", T);\n\n    int M = strlen(T);\n\n    pow3[0] = 1;\n    for(int i = 1; i <= N; i ++){\n        pow3[i] = pow3[i-1]*3;\n    }\n\n    memset(W, 0, sizeof(W));\n    for(int n = 1; n <= N; n ++){\n        //printf(\"ok\");\n        for(int j = 0; j < pow3[n-1]; j ++){\n            D[n][j] = 0;\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        for(int j = pow3[n-1]; j < (pow3[n-1]<<1); j ++){\n            D[n][j] = 1;\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        for(int j = (pow3[n-1]<<1); j < pow3[n]; j ++){\n            D[n][j] = 2;\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        W[n][0] = pow3[n]-1;\n    }\n\n\n    memset(lastUpdated, 0, sizeof(lastUpdated));\n    int cntS2 = 0;\n    for(int n = 1; n <= N; n ++){\n        int cntS = 0;\n        for(int i = 0; i < M; i ++){\n            int indx0 = W[n-1][i];\n            int indx1 = W[n-1][i]+pow3[n-1];\n            int indx2 = W[n-1][i]+(pow3[n-1]<<1);\n\n            if(indx1 >= pow3[n]){indx1 -= pow3[n];}\n            if(indx2 >= pow3[n]){indx2 -= pow3[n];}\n\n            update(n, indx0, cntS+(T[i]=='S'));\n            update(n, indx1, cntS+(T[i]=='S'));\n            update(n, indx2, cntS+(T[i]=='S'));\n            if(D[n][indx0] == 2){\n                W[n][i] = indx0;\n            }else if(D[n][indx1] == 2){\n                W[n][i] = indx1;\n            }else{\n                W[n][i] = indx2;\n            }\n\n            if(T[i] == 'R'){\n                D[n][indx0] = (D[n][indx0]+1);\n                D[n][indx1] = (D[n][indx1]+1);\n                D[n][indx2] = (D[n][indx2]+1);\n                if(D[n][indx0] == 3){D[n][indx0] = 0;}\n                if(D[n][indx1] == 3){D[n][indx1] = 0;}\n                if(D[n][indx2] == 3){D[n][indx2] = 0;}\n                lastUpdated[n][indx0] = cntS;\n                lastUpdated[n][indx1] = cntS;\n                lastUpdated[n][indx2] = cntS;\n            }else if(T[i] == 'S'){\n                cntS ++;\n            }\n\n            //printf(\"W[%d][%d]=%d\\n\", n, i+1, W[n][i+1]);\n        }\n\n        cntS2 = cntS;\n    }\n\n    for(int n = 1; n <= N; n ++){\n        for(int i = 0; i < pow3[n]; i ++){\n            update(n, i, cntS2);\n        }\n    }\n\n    for(int i = 0; i < pow3[N]; i ++){\n        int temp = 0;\n        for(int n = 1; n <= N; n ++){\n            temp += D[n][i%pow3[n]]*pow3[n-1];\n        }\n        putInt(temp);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2,unroll-loops\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing vi = vector<int>;\nusing ll = long long;\nint maxn = 531441, B, C;\nint n, p[531441], f[531441];\nint rev(int a) {\n\tint r = 0, c = 1;\n\twhile(c < maxn) {\n\t\tif(a%3) r +=(3 - (a%3))*c;\n\t\tc*=3,a/=3;\n\t}\n\treturn r;\n}\n \nint s = 0;\nvector<int> small[729];\nint id[531441], lup[531441], u = 0;\n \nvoid add() {\n\ts = (s + B - 1)%B;\n\tfor(auto i : small[s]) {\n\t\tif(lup[i] != u) {\n\t\t\tif((lup[i]^u)&1) id[i] = f[id[i]];\n\t\t\tlup[i] = u;\n\t\t}\n\t\tid[i] = (id[i] + 1)%C;\n\t}\n}\n \nvoid flip() {\n\tu++;\n\tfor(int i = 0; i < B; i++) {\n\t\tif(f[i] <= i) {\n\t\t\tswap(small[(s+i)%B], small[(s+f[i])%B]);\n\t\t}\n\t}\n}\n \nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tstring t;\n\tcin >> n >> t;\n\tmaxn = B = 1;\n\tfor(int i = 0; i < n; i++) maxn *= 3;\n\tfor(int i = 0; i < n/2; i++) B *= 3;\n\tC = maxn/B;\n\tfor(int i = 0; i < maxn; i++) {\n\t\tf[i] = rev(i);\n\t\tsmall[i%B].push_back(i);\n\t\tid[i] = i/B;\n\t}\n\t\n\tfor(auto i : t) {\n\t\tif(i == 'R') add();\n\t\telse flip();\n\t}\n\tfor(int i = 0; i < B; i++)\n\t\tfor(auto j : small[i]) p[j] += (B+i-s)%B;\n\tfor(int i = 0; i < maxn; i++) {\n\t\tif(lup[i] != u) {\n\t\t\tif((lup[i]^u)&1) id[i] = f[id[i]];\n\t\t\tlup[i] = u;\n\t\t}\n\t\tp[i] += B*id[i];\n\t}\n\tfor(int i = 0; i < maxn; i++) cout << p[i] << \" \";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 2e5 + 10;\nconst int maxp = 531500;\nint ans[maxp];\nvoid one(int n)\n{\n\tfor (int i = 0; i < pow(3, n); i++)\n\t{\n\t\tint res = 0;\n\t\tint three = 1;\n\t\twhile (ans[i])\n\t\t{\n\t\t\tint d = ans[i] % 3;\n\t\t\tif (d == 2)\n\t\t\t{\n\t\t\t\tres = res + three * 1;\n\t\t\t}\n\t\t\telse if (d == 1)\n\t\t\t{\n\t\t\t\tres = res + three * 2;\n\t\t\t}\n\t\t\telse if (d == 0)\n\t\t\t{\n\t\t\t\tres = res + three * 0;\n\t\t\t}\n\t\t\tthree *= 3;\n\t\t\tans[i] /= 3;\n\t\t}\n\t\tans[i] = res;\n\t}\n}\nvoid two(int n)\n{\n\tfor (int i = 0; i < pow(3, n); i++)\n\t{\n\t\tans[i] += 1;\n\t\tans[i] %= (int)pow(3, n);\n\t}\n}\nint main()\n{\n\tint n;\n\tchar t[maxn];\n\tcin >> n >> t;\n\tfor (int i = 0; i < pow(3, n); i++)\n\t{\n\t\tans[i] = i;\n\t}\n\tfor (int i = 0; t[i]; i++)\n\t{\n\t\tif (t[i] == 'S')\n\t\t{\n\t\t\tone(n);\n\t\t}\n\t\telse if (t[i] == 'R')\n\t\t{\n\t\t\ttwo(n);\n\t\t}\n\t}\n\tfor (int i = 0; i < pow(3, n); i++)\n\t\tcout << ans[i] << \" \";\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\nint res[531441];\nint P[14];\nint nn;\nvoid dfs(int id,int p,int q,string s){\n    if(id==nn){\n        res[p] = q;\n        return;\n    }\n    int n = s.size();\n    string t;\n    for(int i=0;i<n;i++){\n        if(s[i]=='S'){\n            if(t.size()!=0&&t.back()=='S'){\n                t.pop_back();\n            }else{\n                t.push_back(s[i]);\n            }\n        }else{\n            t.push_back(s[i]);\n        }\n    }\n    for(int pp=0;pp<3;pp++){\n        string nxt;\n        int k = pp;\n        for(int i=0;i<t.size();i++){\n            if(t[i]=='S'){\n                if(k==1||k==2){\n                    k = 3-k;\n                }\n                nxt.push_back('S');\n            }else if(t[i]=='R'){\n                k++;\n                if(k==3){\n                    nxt.push_back('R');\n                    k = 0;\n                }\n            }\n        }\n        dfs(id+1,p+P[id]*pp,q+P[id]*k,nxt);\n    }\n}\nint main(){\n    string s;\n    cin >> nn >> s;\n    P[0] = 1;\n    for(int i=1;i<=12;i++){\n        P[i] = P[i-1]*3;\n    }\n    dfs(0,0,0,s);\n    int k = 1;\n    for(int i=0;i<nn;i++){\n        k*=3;\n    }\n    rep(i,k){\n        cout << res[i] << \" \";\n    }\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint N;\nstring T;\n\nvoid R(int *data);\nvoid S(int *data);\nint X(int x, int y);\n\nint main(){\n  int n;\n  string s;\n  cin >> n;\n  cin >> T;\n  N = X(3, n);\n\n  int L[N];\n  int O[N];\n  for(int i=0;i<N;i++){\n    L[i] = i;\n  }\n  \n  for(int i=0;i<(int)(T.length());i++){\n    s = T[i];\n    if(s == \"S\"){\n      S(L);\n    }else{\n      R(L);\n    }\n  }\n  \n  \n  for(int i=0;i<N;i++){\n    O[L[i]] = i;\n  }\n  \n\n\n  for(int i=0;i<N;i++){\n    cout << O[i] << \" \";\n  }\n  \n  \n  cout <<endl;\n  return 0;\n}\n\nvoid R(int *data){\n  int tmp = data[N-1];\n  for(int i=0;i<N;i++){\n    int a = data[i];\n    data[i] = tmp;\n    tmp = a;\n  }\n}\nvoid S(int *data){\n  int K[N];\n  \n  for(int i=0;i<N/3;i++){\n    int k = i;\n    int tmp = 0;\n    int m = 3;\n    int q = i*3;\n    \n    while(k>0){\n      if(k%3==1){\n        tmp = tmp +2*m;\n      }else if(k%3==2){\n        tmp = tmp +1*m;\n      }\n      k = k/3;\n      m = m*3;\n    }\n    K[tmp] = data[q];\n    K[tmp + 1] = data[q+2];\n    K[tmp + 2] = data[q+1];\n  }\n  for(int i=0;i<N;i++)\n  data[i] = K[i];\n}\n\n\nint X(int x,int y){\n  int a = 1;\n  for(int i=0;i<y;i++){\n    a = a*x;\n  }\n  return a;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\npair<vector<int>, vector<int>> solve(int n, const string& T) {\n    if (n == 0) {\n        vector<int> P = {0};\n        vector<int> W(T.size(), 0);\n        return {P, W}; \n    }\n    //if(n==2) { return solve(1,T); }\n    pair<vector<int>, vector<int>> Ans = solve(n-1,T);\n    vector<int> P = Ans.first , L = Ans.second;\n    int S = (int)P.size();\n    vector<int> new_p(3*S),new_l((int)L.size()),dig(3*S);\n    for(int i=0;i<3;++i) for(int j=0;j<S;++j) dig[j+S*i] = i;\n    vector<int> last_change(3*S);\n    int cnt = 0;  \n    for(int i=0;i<(int)T.size();++i){\n     \tint wk = L[i];\n        for(int j = wk ; j < 3*S ; j+=S){\n\t\t\tif(dig[j]!=0 && last_change[j]%2 != cnt%2) dig[j] = 3-dig[j];\n            last_change[j] = cnt;\n            if(dig[j] == 2) new_l[i] = j;\n        }\n        if(T[i] == 'R'){\n            for(int j = wk ; j < 3*S ; j+=S) dig[j] = (dig[j]+1)%3;\n        } \n        else{\n          cnt++;\n        }\n    }  \n    \n    for(int i=0;i<3*S;++i){\n      if(last_change[i]%2!=cnt%2 && dig[i]!=0) dig[i] = 3-dig[i];\n      new_p[i] = P[i%S] + dig[i]*S;\n    }\n    return {new_p,new_l};\n}\n\nint main() {\n    int N;\n    cin >> N;\n    string T;\n    cin >> T;\n    vector<int> P = solve(N, T).first;\n    for (int x: P) cout << x << \" \";\n    cout << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint binary(int bina){\n    int ans = 0;\n    for (int i = 0; bina>0 ; i++)\n    {\n        ans = ans+(bina%3)*pow(10,i);\n        bina = bina/3;\n    }\n    return ans;\n}\n\nint binary1(int bina){\n    int ans = 0;\n    for (int i = 0; bina>0 ; i++)\n    {\n        ans = ans+(bina%10)*pow(3,i);\n        bina = bina/10;\n    }\n    return ans;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  string t;\n  cin >> t;\n  vector<int> a;\n  \n  for(int i = 0; i < pow(3,n); i++){\n    a.at(i) = i;\n  }\n  \n  for(int i = 0; i < t.size(); i++){\n    if(t.at(i)=='S'){\n      for(int j = 0; j < pow(3,n); j++){\n        a.at(j) = binary(j);\n        string s = to_string(a.at(j));\n        for(int k = 0; k < s.size(); k++){\n        if(s.at(k)==1){\n          s.at(k) = 2;\n        }\n        else if(s.at(k)==2){\n          s.at(k)=1;\n        }\n        else{\n          continue;\n        }\n        a.at(j) = stoi(s);\n        a.at(j)=binary1(j);\n      }\n    }\n    }\n    else{\n      for(int j = 0; j < pow(3,n)-1; j++){\n        a.at(j) += 1;\n      }\n      a.at(pow(3,n))=0;\n    }\n  }\n  for(int j = 0; j < pow(3,n); j++){\n    cout << a.at(j) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#define int long long\n\n#define pii pair<int, int>\n\n#define x1 x1228\n#define y1 y1228\n\n#define left left228\n#define right right228\n\n#define next next228\n\n#define pb push_back\n#define eb emplace_back\n\n#define mp make_pair                                                                \n                                                                                                                                        \n#define ff first                                                                  \n#define ss second   \n\n#define all(x) x.begin(), x.end()\n#define debug(x) cout << #x << \": \" << x << endl; \n#define TIME (ld)clock()/CLOCKS_PER_SEC\n\nusing namespace std;\ntypedef long long ll; \ntypedef long double ld; \n                                                                                                   \nconst int maxn = 2e5 + 7, mod = 1e9 + 7, MAXN = 1e6 + 7;\nconst double eps = 1e-9;\nconst ll inf = 1e18;\nmt19937 rnd(time(0));\nint n; \nstring s; \nint a[maxn]; \nint next[maxn];\nconst int N = 2187; \nint dp1[N]; \nint dp2[N]; \n\nint xyz[maxn]; \n\nint get1(int mask, char q) {\n    if (q == 'R') {\n        ++mask; \n        return mask; \n    }   \n    int ptr = 1; \n    int ans = 0; \n    while (mask) {\n        int t = mask % 3; \n        mask /= 3; \n        if (t == 2) ans += ptr; \n        if (t == 1) ans += 2 * ptr; \n        ptr *= 3; \n    }\n    return ans; \n}\n\nint get(int mask, char q) {\n    if (q == 'R') {\n        ++mask; \n        return mask; \n    }   \n    return xyz[mask]; \n}\n\nconst int L = 12; \nint pref[maxn]; \nint to[maxn][N]; \n\nint get(int l, int r) {\n    return pref[r + 1] - pref[l]; \n}\n\nvoid change(int &mask, int l, int r) {\n    if (get(l, r) % 2) {\n        mask = get(mask, 'S'); \n    }    \n    mask++; \n}\n\nint merge(int left, int right) {\n    for (int i = 0; i < 7; ++i) right *= 3;\n    return left + right;     \n}\n\nint get(int x) {\n    vector<int> bts; \n    for (int i = 0; i < L; ++i) {\n        bts.pb(x % 3); \n        x /= 3; \n    }\n    int left = 0;\n    int right = 0; \n    for (int i = 6; i >= 0; --i) {\n        left *= 3;\n        left += bts[i]; \n    }\n    for (int i = L - 1; i >= 7; --i) {\n        right *= 3; \n        right += bts[i]; \n    }\n    int id = 0; \n    if (left && dp1[left] == -1) {\n        return merge(to[0][left], right);  \n    }\n    if (left) {    \n        id = dp1[left]; \n        change(right, 0, id - 1);             \n        left = 0; \n    }                     \n    while (next[id] != -1) {\n        change(right, id, next[id] - 1);\n        id = next[id];                                                                                                                                         \n    }\n    left = to[id][0]; \n    return merge(left, right); \n}\n\n\nvoid solve() {\n    for (int i = 0; i < maxn; ++i) {\n        xyz[i] = get1(i, 'S'); \n    }\n    cin >> n >> s; \n    int t = s.size(); \n    for (int i = 0; i < t; ++i) {\n        pref[i + 1] = pref[i] + (s[i] == 'S'); \n    }\n    for (int i = 0; i < N; ++i) dp1[i] = dp2[i] = -1; \n    for (int i = 0; i < N; ++i) to[t][i] = i; \n    next[t] = -1; \n    for (int i = t - 1; i >= 0; --i) {\n        for (int mask = 0; mask < N; ++mask) {\n            int mask1 = get(mask, s[i]); \n            to[i][mask] = to[i + 1][mask1]; \n        }\n        for (int mask = 0; mask < N; ++mask) {\n            int mask1 = get(mask, s[i]); \n            if (mask && mask1 == 0) {\n                dp2[mask] = i + 1; \n            } else {\n                dp2[mask] = dp1[mask1]; \n            }   \n        }\n        next[i] = dp2[0]; \n        for (int mask = 0; mask < N; ++mask) {\n            dp1[mask] = dp2[mask]; \n            dp2[mask] = -1; \n        }                                                                \n    }                      \n    int tet = 1; \n    for (int i = 0; i < n; ++i) tet *= 3; \n    for (int i = 0; i < tet; ++i) {\n        cout << get(i) % tet << \" \";             \n    }\n}                                \n   \nsigned main() {\n#ifdef LOCAL\n    freopen(\"TASK.in\", \"r\", stdin);\n    freopen(\"TASK.out\", \"w\", stdout);\n#else \n    \n#endif // LOCAL\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20); \n    cout << fixed; \n    int t = 1; \n    for (int i = 0; i < t; ++i) {              \n        solve();\n    }\n    return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst int maxn=555555;\n#define MP make_pair\n#define PB push_back\n#define lson o<<1,l,mid\n#define rson o<<1|1,mid+1,r\n#define FOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define ROF(i,a,b) for(int i=(a);i>=(b);i--)\n#define MEM(x,v) memset(x,v,sizeof(x))\ninline ll read(){\n\tchar ch=getchar();ll x=0,f=0;\n\twhile(ch<'0' || ch>'9') f|=ch=='-',ch=getchar();\n\twhile(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn f?-x:x;\n}\nint n,m,q,rt,cnt,ch[maxn][3],id[maxn],ans[maxn];\nbool rev[maxn];\nchar s[maxn];\ninline void setrev(int x){\n\trev[x]^=1;\n\tswap(ch[x][1],ch[x][2]);\n}\ninline void pushdown(int x){\n\tif(rev[x]){\n\t\tif(ch[x][0]) setrev(ch[x][0]);\n\t\tif(ch[x][1]) setrev(ch[x][1]);\n\t\tif(ch[x][2]) setrev(ch[x][2]);\n\t\trev[x]=false;\n\t}\n}\nvoid build(int &x,int dep,int cur,int pr){\n\tx=++cnt;\n\tif(dep==n){\n\t\tid[x]=cur;\n\t\treturn;\n\t}\n\tbuild(ch[x][0],dep+1,cur,pr*3);\n\tbuild(ch[x][1],dep+1,cur+pr,pr*3);\n\tbuild(ch[x][2],dep+1,cur+pr*2,pr*3);\n}\nvoid add(int x,int dep){\n\tpushdown(x);\n\tif(dep==n) return;\n\tswap(ch[x][1],ch[x][2]);\n\tswap(ch[x][0],ch[x][1]);\n\tadd(ch[x][0],dep+1);\n}\nvoid dfs(int x,int dep,int cur,int pr){\n\tpushdown(x);\n\tif(dep==n){\n\t\tans[id[x]]=cur;\n\t\treturn;\n\t}\n\tdfs(ch[x][0],dep+1,cur,pr*3);\n\tdfs(ch[x][1],dep+1,cur+pr,pr*3);\n\tdfs(ch[x][2],dep+1,cur+pr*2,pr*3);\n}\nint main(){\n\tn=read();\n\tbuild(rt,0,0,1);\n\tscanf(\"%s\",s+1);\n\tq=strlen(s+1);\n\tFOR(i,1,q) if(s[i]=='S') setrev(rt);\n\telse add(rt,0);\n\tdfs(rt,0,0,1);\n\tm=1;\n\tFOR(i,1,n) m*=3;\n\tFOR(i,0,m-1) printf(\"%d \",ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing int64 = long long;\n\nconstexpr int DEBUG = 0;\n\nint Power3(int p) {\n  int r = 1;\n  for (int i = 0; i < p; i++) {\n    r *= 3;\n  }\n  return r;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n  string original_command;\n  cin >> original_command;\n  vector<vector<int>> output_table(n + 1);\n  vector<vector<string>> command_table(n + 1);\n  for (int k = 1; k <= n; k++) {\n    output_table[k].reserve(Power3(k));\n    command_table[k].reserve(Power3(k));\n  }\n\n  for (int k = 1; k <= n; k++) {\n    for (int x = 0; x < Power3(k); x++) {\n      string command;\n      if (k == 1) {\n        command = original_command;\n      } else {\n        command = command_table[k - 1][x % Power3(k - 1)];\n      }\n\n      int d = x / Power3(k - 1);\n      string next_command = \"\";\n      for (char c : command) {\n        if (c == 'R') {\n          d++;\n          if (d == 3) {\n            d = 0;\n            next_command.append(\"R\");\n          }\n        } else if (c == 'S') {\n          if (d == 1) d = 2;\n          else if (d == 2) d = 1;\n\n          next_command.append(\"S\");\n        }\n      }\n\n      output_table[k][x] = d;\n      command_table[k][x] = next_command;\n    }\n  }\n\n  vector<int> outputs;\n  for (int x = 0; x < Power3(n); x++) {\n    int output = 0;\n    for (int k = 1; k <= n; k++) {\n      output += output_table[k][x % Power3(k)] * Power3(k - 1);\n    }\n    outputs.push_back(output);\n  }\n\n  for (int i = 0; i < outputs.size(); i++) {\n    if (i > 0) cout << \" \";\n    cout << outputs[i];\n  }\n  cout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <memory>\n\n#include <utility>\n#include <vector>\n#include <limits>\n#include <algorithm>\n#include <unordered_map>\n#include <map>\nusing namespace std;\n\n#define rep_init(i, init, n) for(int i = (init); i < n; ++i)\n#define rep(i, n) rep_init(i, 0, n)\n\ntemplate<typename T>\nconstexpr T int_pow(T b, uint64_t e)\n{\n\tif (e == 0) return 1;\n\tif ((e & 0x1) == 0) return int_pow(b * b, e >> 1);\n\telse return b * int_pow(b * b, e >> 1);\n}\n\nvoid Main()\n{\n\tint N;\n\tcin >> N;\n\n\tint maxP = int_pow<int>(3, N);\n\t\n\tunordered_map<string, unique_ptr<unordered_map<int, int>>> table;\n\tunique_ptr<unordered_map<int, int>> Sal(new unordered_map<int,int>());\n\trep(i, maxP)\n\t{\n\t\tint m = i;\n\t\tint num = 0;\n\t\tfor (int j = maxP; j > 0; j /= 3)\n\t\t{\n\t\t\tif (m / j == 1) num += j * 2;\n\t\t\telse if (m / j == 2) num += j * 1;\n\t\t\tm %= j;\n\t\t}\n\n\t\t(*Sal)[i] = num;\n\t}\n\ttable[\"S\"] = std::move(Sal);\n\n\tunique_ptr<unordered_map<int, int>> Run(new unordered_map<int,int>());\n\trep(i, maxP)\n\t{\n\t\tif (i+1 < maxP) (*Run)[i] = i+1;\n\t\telse (*Run)[i] = 0;\n\t}\n\ttable[\"R\"] = std::move(Run);\n\n\tstring S;\n\t{\n\t\tstring preS;\n\t\tcin >> preS;\n\n\t\tchar preC = '\\0';\n\t\tfor (auto it = preS.begin(); it != preS.end(); ++it)\n\t\t{\n\t\t\tif (preC == 'S' && *it == 'S')\n\t\t\t{\n\t\t\t\tpreC = '\\0';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (preC == 'S' && *it != 'S')\n\t\t\t{\n\t\t\t\tS.push_back(preC);\n\t\t\t\tS.push_back(*it);\n\n\t\t\t\tpreC = *it;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (*it == 'S' && it+1 != preS.end())\n\t\t\t{\n\t\t\t\tpreC = 'S';\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tS.push_back(*it);\n\t\t\tpreC = *it;\n\t\t}\n\t}\n\n\tfor (int i = 1; i < S.size(); i *= 2)\n\t{\n\t\tint j = 0;\n\t\twhile (true)\n\t\t{\n\t\t\tif (j + i >= S.size()) break;\n\t\t\tstring S1;\n\t\t\tstring S2;\n\n\t\t\tfor (int k = 0; k < i; ++k, ++j)\n\t\t\t{\n\t\t\t\tS1.push_back(S[j]);\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < i && j < S.size(); ++k, ++j)\n\t\t\t{\n\t\t\t\tS2.push_back(S[j]);\n\t\t\t}\n\n\t\t\tif (table.find(S1 + S2) == table.end())\n\t\t\t{\n\t\t\t\tunique_ptr<unordered_map<int, int>> D(new unordered_map<int,int>());\n\t\t\t\trep(k, maxP)\n\t\t\t\t{\n\t\t\t\t\t(*D)[k] = (*(table[S2]))[(*(table[S1]))[k]];\n\t\t\t\t}\n\n\t\t\t\ttable[S1 + S2] = std::move(D);\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i, maxP)\n\t{\n\t\tcout << (*(table[S]))[i];\n\t\tif (i+1 < maxP) cout << \" \";\n\t}\n\n\tcout << endl;\n}\n\nint main()\n{\n\tstd::cin.tie(nullptr);\n\tstd::ios_base::sync_with_stdio(false);\n\tstd::cout << std::fixed << std::setprecision(15);\n\n\tMain();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define REP(i, n) for(int i = 0;i < (n);i++)\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=998244353;\nconst llint inf=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-10;\ntemplate <class T,class U>bool chmin(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool chmax(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint san[13];\nvector<int>ans;\nclass hito{\npublic:\n\tbool sru;\n\tint moto;\n\thito* go[3];\n\thito(int in,int dep,int n){\n\t\t//cerr<<in<<\" \"<<dep<<\" \"<<n<<endl;\n\t\tmoto=in;sru=false;\n\t\tif(dep<n){\n\t\t\tgo[0]=new hito(in, dep+1,n);\n\t\t\tgo[1]=new hito(in+san[dep],dep+1,n);\n\t\t\tgo[2]=new hito(in+san[dep]*2,dep+1,n);\n\t\t}else{go[0]=nullptr;}\n\t}\n\tvoid dance(void){\n\t\tif(go[0]==nullptr){return;}\n\t\tif(sru){\n\t\t\tgo[0]->sru=!go[0]->sru;\n\t\t\tgo[1]->sru=!go[1]->sru;\n\t\t\tgo[2]->sru=!go[2]->sru;\n\t\t\tswap(go[1],go[2]);\n\t\t\tsru=false;\n\t\t}\n\t}\n\tvoid runba(void){\n\t\t//cerr<<moto<<endl;\n\t\tif(go[0]==nullptr){return;}\n\t\tthis->dance();\n\t\tauto aaa=go[2];\n\t\tgo[2]=go[1];\n\t\tgo[1]=go[0];\n\t\tgo[0]=aaa;\n\t\tgo[0]->runba();\n\t}\n\tvoid solve(int in,int dep){\n\t\t//cerr<<moto<<endl;\n\t\tif(go[0]==nullptr){ans[moto]=in;return;}\n\t\tthis->dance();\n\t\tgo[0]->solve(in,dep+1);\n\t\tgo[1]->solve(in+san[dep],dep+1);\n\t\tgo[2]->solve(in+san[dep]*2,dep+1);\n\t}\n};\nint main(void){\n\tint n,i;cin>>n;\n\tsan[0]=1;\n\tfor(i=1;i<=n;i++){san[i]=san[i-1]*3;}\n\thito wa(0,0,n);\n\tstring T;cin>>T;\n\tfor(auto it:T){\n\t\tif(it=='S'){wa.sru=!wa.sru;}\n\t\telse {wa.runba();}\n\t}\n\tans.res(san[n]);\n\twa.solve(0,0);\n\tfor(i=0;i<san[n];i++){cout<<ans[i]<<\" \";}cout<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 2e5 + 10;\nconst int maxp = 531500;\nint ans[maxp];\nint qpow(int a, int b)\n{\n\tint res = 1;\n\twhile (b)\n\t{\n\t\tif (b & 1)\n\t\t{\n\t\t\tres *= a;\n\t\t}\n\t\ta *= a;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\nvoid one(int n)\n{\n\tfor (int i = 0; i < qpow(3, n); i++)\n\t{\n\t\tint res = 0;\n\t\tint three = 1;\n\t\twhile (ans[i])\n\t\t{\n\t\t\tint d = ans[i] % 3;\n\t\t\tif (d == 2)\n\t\t\t{\n\t\t\t\tres = res + three * 1;\n\t\t\t}\n\t\t\telse if (d == 1)\n\t\t\t{\n\t\t\t\tres = res + three * 2;\n\t\t\t}\n\t\t\telse if (d == 0)\n\t\t\t{\n\t\t\t\tres = res + three * 0;\n\t\t\t}\n\t\t\tthree *= 3;\n\t\t\tans[i] /= 3;\n\t\t}\n\t\tans[i] = res;\n\t}\n}\nvoid two(int n)\n{\n\tfor (int i = 0; i < qpow(3, n); i++)\n\t{\n\t\tans[i] += 1;\n\t\tans[i] %= qpow(3, n);\n\t}\n}\nint main()\n{\n\tint n;\n\tchar t[maxn];\n\tcin >> n >> t;\n\tfor (int i = 0; i < qpow(3, n); i++)\n\t{\n\t\tans[i] = i;\n\t}\n\tfor (int i = 0; t[i]; i++)\n\t{\n\t\tif (t[i] == 'S')\n\t\t{\n\t\t\tone(n);\n\t\t}\n\t\telse if (t[i] == 'R')\n\t\t{\n\t\t\ttwo(n);\n\t\t}\n\t}\n\tfor (int i = 0; i < qpow(3, n); i++)\n\t\tcout << ans[i] << \" \";\n\tcout << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string>\n#include<cmath>\n\nusing namespace std;\n\nint sch(int n){     \n    int out=0,tmp,count=0;\n    while(n != 0){\n        tmp = n % 3;\n        if(tmp==1){\n            out += 2*pow(3,count);\n        }else if(tmp==2){\n            out += pow(3,count);\n        }\n        count++;\n        n /= 3;\n    }\n    return out;\n}\n\nint main(){\n    int N,p,size,len;\n    string T;\n    cin >> N;\n    cin >> T;\n    size = int(pow(3,N));\n    vector<int> table(size);\n    len = T.length();\n    for(int i=0;i<size;i++){\n        if(i % 3 == 0){\n            table[i] = sch(i);\n        }else if(i % 3 == 1){\n            table[i] = table[i-1] + 2;\n        }else{\n            table[i] = table[i-1] - 1;\n        }\n    }\n    //for(int i=0;i<size;i++) cout << i << ' ' <<table[i] << endl;;\n\n    for(int i=0;i<size;i++){\n        p=i;\n        for(int j=0;j<len;j++){\n            if(T[j] == 'S'){\n                if(T[j+1] == 'S') j++;\n                else p = table[p];\n            }else{\n                p++;\n                if(p==size) p=0;\n            }\n        }\n        cout << p << ' ';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nstatic inline int Pow(int a,int b){return b?Pow(a*a,b>>1)*(b&1?a:1):1;}\nint main()\n{\n  int N,now,len=0,A[1000001],B[600001];\n  char T[1000001],S[1000001];\n  now=scanf(\"%d %s\",&N,T);len=strlen(T);\n  int pw3=Pow(3,N),x=Pow(3,N>>1),y=Pow(3,N-(N>>1));\n  rep(i,pw3)B[i]=B[i/3]*3+(3-i%3)%3;\n  rep(i,x)\n  {\n    int temp=i;now=0;\n    rep(j,len)\n    {\n      if(T[j]=='S'){temp=B[temp];if(S[now]=='S')--now;else S[++now]='S';}\n      else{++temp;if(temp==x)S[++now]='R',temp=0;}\n    }\n    rep(j,y)\n    {\n      int keep=j;\n      rep(k,now)\n      {\n        if(S[k+1]=='S')keep=B[keep];\n        else if(S[k+1]=='R')if((++keep)==y)keep=0;\n      }\n      A[i+j*x]=temp+keep*x;\n    }\n  }\n  rep(i,pw3)printf(\"%d%c\",A[i],i+1==pw3?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n\ntemplate<class T>\nstatic inline std::vector<T> ndvec(size_t&& n, T val) noexcept {\n  return std::vector<T>(n, std::forward<T>(val));\n}\n\ntemplate<class... Tail>\nstatic inline auto ndvec(size_t&& n, Tail&&... tail) noexcept {\n  return std::vector<decltype(ndvec(std::forward<Tail>(tail)...))>(n, ndvec(std::forward<Tail>(tail)...));\n}\n\ntemplate<class T, class Cond>\nstruct chain {\n  Cond cond; chain(Cond cond) : cond(cond) {}\n  bool operator()(T& a, const T& b) const {\n    if(cond(a, b)) { a = b; return true; }\n    return false;\n  }\n};\ntemplate<class T, class Cond>\nchain<T, Cond> make_chain(Cond cond) { return chain<T, Cond>(cond); }\n\nint main() {\n  i64 N;\n  cin >> N;\n  string S;\n  cin >> S;\n  i64 M = S.size();\n  i64 cnt = 0;\n  i64 r = 0;\n  rep(i,0,M) {\n    if(S[i] == 'S') {\n      cnt = -cnt;\n      r++;\n    }\n    else {\n      cnt -= 1;\n    }\n  }\n\n  i64 all = 1;\n  rep(i,0,N) all *= 3;\n  std::vector<i64> ans(all);\n  rep(i,0,all) {\n    ans[i] = i;\n  }\n  if(r % 2 == 1) {\n    std::vector<i64> tmp(all);\n    rep(i,0,all) {\n      i64 next = 0;\n      i64 now = i;\n      i64 p = 1;\n      rep(i,0,N) {\n        if(now % 3 == 1) {\n          next += 2 * p;\n        }\n        else if(now % 3 == 2) {\n          next += 1 * p;\n        }\n        now /= 3;\n        p *= 3;\n      }\n      std::cout << i << \" = \" << next << std::endl;\n      tmp[next] = i;\n    }\n    ans = tmp;\n  }\n  for(int i = N; i --> 0;) {\n  }\n  std::vector<i64> tmp(all);\n  rep(i,0,all) {\n    tmp[(i + (cnt % all) + all) % all] = ans[i];\n  }\n  rep(i,0,all)  {\n    cout << tmp[i] << \" \\n\"[i + 1 == all];\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint n;\nint N;\n\nstring red(string s){\n\tstring ret=\"\";\n\tfor(int i=0;i<s.size();i++){\n\t\tret+=s[i];\n\t\tif(ret.size()>=2&&ret[ret.size()-1]=='S'&&ret[ret.size()-2]=='S'){\n\t\t\tret.pop_back();\n\t\t\tret.pop_back();\n\t\t}\n\t}\n\treturn ret;\n}\n\nint ret[1<<24];\nvoid solve(string s,int d,int mask){\n\t//cerr<<s<<\" \"<<d<<\" \"<<mask<<endl;\n\tint p[3]={0,1,2};\n\tstring t[3];\n\tfor(int i=0;i<s.size();i++){\n\t\tif(s[i]=='S'){\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tif(p[j]!=0)p[j]=3-p[j];\n\t\t\t\tt[j]+='S';\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor(int j=0;j<3;j++){\n\t\t\t\tp[j]++;\n\t\t\t\tif(p[j]==3){\n\t\t\t\t\tp[j]=0;\n\t\t\t\t\tt[j]+='R';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(int j=0;j<3;j++){\n\t\t\tcerr<<p[j]<<\" \";\n\t\t}cerr<<endl;*/\n\t}\n\tint m[3];\n\tm[0]=mask-(1<<(2*d+1))-(1<<(2*d));\n\tm[1]=mask-(1<<(2*d+1));\n\tm[2]=mask-(1<<(2*d));\n\tfor(int i=0;i<3;i++){\n\t\tret[m[i]]=p[i];\n\t\t//cerr<<m[i]<<\" \"<<p[i]<<endl;\n\t\tif(d+1<n)solve(red(t[i]),d+1,m[i]);\n\t}\n}\n\nint main(){\n\tstring t;\n\tcin>>n>>t;\n\tN=1;\n\tfor(int i=0;i<n;i++)N*=3;\n\t\n\tint cnt=0;\n\tfor(int i=0;i<t.size();i++){\n\t\tif(t[i]=='S')cnt++;\n\t}\n\tif(cnt&1)t+='S';\n\tt=red(t);\n\tmemset(ret,-1,sizeof ret);\n\tsolve(t,0,(1<<(2*n))-1);\n\t\n\tbool addS=cnt&1;\n\t\n\tvector<int> p;\n\tfor(int i=0;i<(1<<(2*n));i++){\n\t\tbool ok=true;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(((i>>(2*j))&3)==3)ok=false;\n\t\t}\n\t\tif(!ok)continue;\n\t\tint cnt=0;\n\t\tint tt=N/3;\n\t\tint mask=i;\n\t\tfor(int j=n-1;j>=0;j--){\n\t\t\tint x=0;\n\t\t\tif(ret[mask]==-1)x=(i>>(2*j))&3;\n\t\t\telse x=ret[mask];\n\t\t\tif(addS&&x!=0)x=3-x;\n\t\t\tcnt+=tt*x;\n\t\t\t/*if(ret[mask]==-1)cnt+=tt*((i>>(2*j))&3);\n\t\t\telse {\n\t\t\t\tcnt+=tt*ret[mask];\n\t\t\t}*/\n\t\t\tmask|=3<<(2*j);\n\t\t\ttt/=3;\n\t\t}\n\t\tp.push_back(cnt);\n\t}\n\tfor(int i=0;i<p.size();i++){\n\t\tcout<<p[i]<<\" \";\n\t}\n\tcout<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint N;\nstruct Tree{\n\tint num;\n\tint ch[3];\n\tbool rev;\n}T[2000010];int tot=1;\nvoid S(int x)\n{\n\tT[x].rev^=1;\n\tswap(T[x].ch[1],T[x].ch[2]);\n\treturn ;\n}\nvoid pushdown(int x)\n{\n\tif(!T[x].rev)return ;\n\tif(T[x].ch[0])S(T[x].ch[0]);\n\tif(T[x].ch[1])S(T[x].ch[1]);\n\tif(T[x].ch[2])S(T[x].ch[2]);\n\tT[x].rev=0;return ;\n}\nvoid R(int x)\n{\n\tpushdown(x);\n\tint y=T[x].ch[2];\n\tT[x].ch[2]=T[x].ch[1];\n\tT[x].ch[1]=T[x].ch[0];\n\tT[x].ch[0]=y;\n\tif(y)R(y);\n\treturn ;\n}\nvoid insert(int x)\n{\n\tint now=x,o=1;\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tint t=now%3;\n\t\tif(!T[o].ch[t])T[o].ch[t]=++tot;\n\t\to=T[o].ch[t];\n\t\tnow/=3;\n\t}\n\tT[o].num=x;\n\treturn ;\n}\nint getval(int x,int y)\n{\n\tpushdown(x);\n\tint t=y%3;\n\tif(!T[x].ch[t])return T[x].num;\n\treturn getval(T[x].ch[t],y/3);\n}\nchar str[200010];\nint ans[200010];\nint main()\n{\n\tscanf(\"%d\",&N);\n\tscanf(\"%s\",str+1);\n\tint len=strlen(str+1);\n\tint m=1;\n\tfor(int i=1;i<=N;i++)m*=3;\n\tfor(int i=0;i<m;i++)insert(i);\n\tfor(int i=1;i<=len;i++)\n\t{\n\t\tif(str[i]=='S')S(1);\n\t\telse R(1);\n\t}\n\tfor(int i=0;i<m;i++)ans[getval(1,i)]=i;\n\tfor(int i=0;i<m;i++)printf(\"%d \",ans[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define cs const\n#define pb push_back\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define ll long long\n#define bg begin\nnamespace IO{\n\t\ncs int RLEN=1<<20|1;\nchar ibuf[RLEN],*ib,*ob;\ninline char gc(){\n\t(ib==ob)&&(ob=(ib=ibuf)+fread(ibuf,1,RLEN,stdin));\n\treturn (ib==ob)?EOF:*ib++;\n}\ninline int read(){\n\tchar ch=gc();\n\tint res=0;bool f=1;\n\twhile(!isdigit(ch))f^=ch=='-',ch=gc();\n\twhile(isdigit(ch))res=(res*10)+(ch^48),ch=gc();\n\treturn f?res:-res;\n}\ninline int readstring(char *s){\n\tint top=0;char ch=gc();\n\twhile(isspace(ch))ch=gc();\n\twhile(!isspace(ch)&&ch!=EOF)s[++top]=ch,ch=gc();\n\treturn top;\n}\n\n}\nusing IO::read;\nusing IO::readstring;\ntemplate<typename tp>inline void chemx(tp &a,tp b){a=max(a,b);}\ntemplate<typename tp>inline void chemn(tp &a,tp b){a=min(a,b);}\ncs int N=1000005,M=16;\nint pw[M];\nchar str[N];\nint n,m,tot,id[N],ans[N],lc[N],rc[N],pc[N],rev[N];\nvoid build(int &u,int dep,int ps){\n\tu=++tot;\n\tif(dep==n){\n\t\tid[u]=ps;\n\t\treturn;\n\t}\n\tbuild(lc[u],dep+1,ps);\n\tbuild(rc[u],dep+1,ps+pw[dep]);\n\tbuild(pc[u],dep+1,ps+2*pw[dep]);\n}\nvoid pushnow(int u){\n\trev[u]^=1,swap(rc[u],pc[u]);\n}\nvoid pushdown(int u){\n\tif(!rev[u])return;\n\tif(lc[u])pushnow(lc[u]);\n\tif(rc[u])pushnow(rc[u]);\n\tif(pc[u])pushnow(pc[u]);\n\trev[u]=0;\n}\nvoid move(int u,int dep){\n\tpushdown(u);\n\tif(dep==n)return;\n\tswap(rc[u],pc[u]),swap(rc[u],lc[u]);\n\tmove(lc[u],dep+1);\n}\nvoid dfs(int u,int dep,int ps){\n\tpushdown(u);\n\tif(dep==n){ans[id[u]]=ps;return;}\n\tdfs(lc[u],dep+1,ps);\n\tdfs(rc[u],dep+1,ps+pw[dep]);\n\tdfs(pc[u],dep+1,ps+2*pw[dep]);\n}\nint main(){\n\t#ifdef Stargazer\n\tfreopen(\"lx.in\",\"r\",stdin);\n\t#endif\n\tn=read();pw[0]=1;int rt=0;\n\tm=readstring(str);\n\tfor(int i=1;i<M;i++)pw[i]=pw[i-1]*3;\n\tbuild(rt,0,0);\n\tfor(int i=1;i<=m;i++)\n\tif(str[i]=='S')pushnow(rt);\n\telse move(rt,0);\n\tdfs(rt,0,0);\n\tfor(int i=0;i<pw[n];i++)cout<<ans[i]<<\" \";puts(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n\nusing ll = long long;\n\n\nmt19937 mt(736);\n\n\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tint n;\n\n\tcin >> n;\n\n\tstring str;\n\n\tcin >> str;\n\n\tint num = (int) round(pow(3, n));\n\n\tvector<int> prs(num);\n\n\tfor (int i = 0; i < prs.size(); i++)\n\t{\n\t\tint mult = 1;\n\n\t\tint to = i;\n\n\t\twhile (mult < num)\n\t\t{\n\t\t\tif (to / mult % 3 != 0)\n\t\t\t{\n\t\t\t\tif (to / mult % 3 == 1)\n\t\t\t\t\tto += mult;\n\t\t\t\telse\n\t\t\t\t\tto -= mult;\n\t\t\t}\n\n\t\t\tmult *= 3;\n\t\t}\n\n\t\tprs[i] = to;\n\t}\n\n\tint shift = 0;\n\tbool rev = false;\n\n\tfor (auto it : str)\n\t{\n\t\tassert(it == 'R' || it == 'S');\n\n\t\tif (it == 'R')\n\t\t\tshift += rev ? -1 : 1;\n\t\telse\n\t\t\trev = !rev;\n\t}\n\n\tshift %= num;\n\n\tassert(num % 3 == 0);\n\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tint ans = i + shift;\n\n\t\tans %= num;\n\n\t\tif (ans < 0)\n\t\t\tans += num;\n\n\t\tif (rev)\n\t\t\tans = prs[ans];\n\n\t\tcout << ans << ' ';\n\t}\n\n\tcout << endl;\n}\n\n\nvoid stress(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tint n;\n\n\tcin >> n;\n\n\tint num = (int) round(pow(3, n));\n\n\tvector<int> ord(num);\n\tiota(ord.begin(), ord.end(), 0);\n\n\tvector<int> prs(num);\n\n\tfor (int i = 0; i < prs.size(); i++)\n\t{\n\t\tint mult = 1;\n\n\t\tint to = i;\n\n\t\twhile (mult < num)\n\t\t{\n\t\t\tif (to / mult % 3 != 0)\n\t\t\t{\n\t\t\t\tif (to / mult % 3 == 1)\n\t\t\t\t\tto += mult;\n\t\t\t\telse\n\t\t\t\t\tto -= mult;\n\t\t\t}\n\n\t\t\tmult *= 3;\n\t\t}\n\n\t\tprs[i] = to;\n\t}\n\n\tstring str;\n\n\tcin >> str;\n\n\tfor (auto it : str)\n\t{\n\t\tassert(it == 'R' || it == 'S');\n\n\t\tif (it == 'R')\n\t\t{\n\t\t\tfor (auto &i : ord)\n\t\t\t\tif (++i == num)\n\t\t\t\t\ti = 0;\n\t\t}\n\t\telse\n\t\t\tfor (int i = 0; i < ord.size(); i++)\n\t\t\t\tord[i] = prs[ord[i]];\n\t}\n\n\tfor (auto it : ord)\n\t\tcout << it << ' ';\n\n\tcout << endl;\n}\n\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tcout << fixed;\n\n#ifdef LOCAL\n\tauto st = clock();\n\n\tifstream fin(\"../input.txt\");\n\n\tstress(fin);\n\n\tcout << \"clock: \" << setprecision(4) << (clock() - st) / (double) CLOCKS_PER_SEC << endl;\n#else\n\tstress();\n#endif\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint po3(int e){\n    int ret = 1;\n    for(int i = 0; i<e; i++){\n        ret *= 3;\n    }\n\n    return ret;\n}\n\nint conjug(int x){\n    int mult = 1;\n    int ret = 0;\n\n    while(x){\n        int t = x % 3;\n        if(t == 1) ret += mult * 2;\n        if(t == 2) ret += mult;\n\n        x /= 3;\n        mult *= 3;\n    }\n\n    return ret;\n}\n\nstruct EndingSet{\n    int ending;\n    vector<int> nums;\n};\n\nint main(){\n    int n;\n    cin >> n;\n\n    string T;\n    cin >> T;\n\n    int e = po3((n + 1) / 2);\n    int b = po3(n) / e;\n\n    EndingSet a[e];\n    for(int i = 0; i<e; i++){\n        a[i].ending = i;\n        for(int j = 0; j<b; j++){\n            a[i].nums.push_back(i + j*e);\n        }\n    }\n\n    int beg[b], ids[b*e], ans[b*e];\n    for(int i = 0; i<b; i++){\n        beg[i] = i;\n    }\n\n    for(int i = 0; i<b*e; i++){\n        ids[i] = i / e;\n    }\n\n    for(int i = 0; i<T.size(); i++){\n        if(T[i] == 'S'){\n            for(int j = 0; j<e; j++){\n                a[j].ending = conjug(a[j].ending);\n            }\n\n            for(int j = 0; j<b; j++){\n                beg[j] = conjug(beg[j]);\n            }\n        }\n\n        if(T[i] == 'R'){\n            int pos;\n            for(int j = 0; j<e; j++){\n                if(a[j].ending == e - 1) pos = j;\n            }\n\n            int inv[b];\n            for(int i = 0; i<b; i++){\n                inv[beg[i]] = i;\n            }\n\n            for(int x: a[pos].nums){\n                if(beg[ids[x]] < b - 1) ids[x] = inv[beg[ids[x]] + 1];\n                else ids[x] = inv[0];\n            }\n\n            for(int j = 0; j<e; j++){\n                if(a[j].ending < e - 1) a[j].ending++;\n                else a[j].ending = 0;\n            }\n        }\n\n\n    }\n\n    int inv[b*e];\n\n        for(int j = 0; j<e; j++){\n            int x = a[j].ending;\n\n            for(int y: a[j].nums){\n                ans[x + beg[ids[y]] * e] = y;\n                inv[y] = x + beg[ids[y]] * e;\n            }\n        }\n\n        for(int j = 0; j<b*e; j++){\n            cout << inv[j] << \" \";\n        }\n\n        cout << endl;\n\n    /*\n    for(int i = 0; i<e; i++){\n        int x = a[i].ending;\n\n        for(int y: a[i].nums){\n            ans[y] = x;\n        }\n    }\n\n    for(int i = 0; i<b*e; i++){\n        ans[i] += beg[ids[i]] * e;\n    }\n\n    for(int i = 0; i<b*e; i++){\n        cout << ans[i] << \" \";\n    }\n    */\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<assert.h>\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nint N,o,p,x,y,sw,pw3[13]={1},A[600000]={},B[600000]={},S[200005]={};\nchar T[200005];\nvoid Init(void){rep(i,pw3[o])rep(j,3)B[i+j*pw3[o]]=j;}\nvoid Dance(char c[])\n{\n  if(c[p]==EOF)return;\n  if(c[p]=='R'){y=S[p];rep(i,3){x=y+i*pw3[o];if(B[x]+sw==2)S[p]=x;(B[x]+=sw+1)%=3;}}\n  if(c[p]=='S')sw^=1;\n}\nvoid Update(void)\n{\n  rep(i,pw3[o]){y=A[i];rep(j,3){x=i+j*pw3[o];A[x]=y+(sw?3-B[x]:B[x])%3*pw3[o];}}\n}\nsigned main(void)\n{\n  o=scanf(\"%d %s\",&N,T);\n  rep(i,N){o=i,Init(),sw=0;rep(j,strlen(T)){p=j,Dance(T);}Update();pw3[i+1]=3*pw3[i];}\n  rep(i,pw3[N])printf(\"%d%c\",A[i],i+1==pw3[N]?'\\n':' ');\n}"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n// #define inf  998244353\n\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int Gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return Gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn Gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                              \n                int pr[100000];\n                int inv[100000];\n                \n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=((ll)pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=(ll)inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n  \n\n\n  \n\nvoid solve(){\n\tvector<int> ve(1,0);\n\tint n;\n\tcin>>n;\n\tstring s;\n\tcin>>s;\n\tint m=s.length();\n\tvector<int> las(m+1,0);\n\t\n\tint san[15];\n\tsan[0]=1;\n\tfor(int i=0;i<13;i++)san[i+1]=san[i]*3;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tset<int> se[3];\n\t\tvector<int> ima(san[i]*3);\n\t\tfor(int j=0;j<3;j++){\n\t\t\tfor(int k=j*san[i];k<(j+1)*san[i];k++)se[j].insert(k),ima[k]=j;\n\t\t}\n\t\tint tmp[3]={0,1,2};\n\t\t\n\t\tlas[0]+=2*san[i];\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(s[j]=='S'){\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\ttmp[k]=(3-tmp[k])%3;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint mae=las[j]%san[i];\n\t\t\t//\tcout<<las[0]<<endl;\n\t\t\t\tint t=(tmp[ima[mae]]+1)%3;\n\t\t\t\tfor(int k=0;k<3;k++)if(tmp[k]==t)ima[mae]=k;\n\t\t\t\t\n\t\t\t\tt=(tmp[ima[mae+san[i]]]+1)%3;\n\t\t\t\tfor(int k=0;k<3;k++)if(tmp[k]==t)ima[mae+san[i]]=k;\n\t\t\t\t t=(tmp[ima[mae+san[i]*2]]+1)%3;\n\t\t\t\tfor(int k=0;k<3;k++)if(tmp[k]==t)ima[mae+san[i]*2]=k;\n\t\t\t\t\n\n\t\t\t}\n\n\t\t\tif(tmp[ima[las[j+1]+san[i]]]==2)las[j+1]+=san[i];\n\t\t\telse if(tmp[ima[las[j+1]+san[i]*2]]==2)las[j+1]+=san[i]*2;\n\t\t\t\n\t\t}\n\t\t\n\t\tint ss=ve.size();\n\t\tfor(int j=0;j<ss;j++)ve.pb(ve[j]);\n\t\tfor(int j=0;j<ss;j++)ve.pb(ve[j]);\n\t\t/*\n\t\tfor(auto j:se[1])ve[j]+=san[i];\n\t\tfor(auto j:se[2])ve[j]+=2*san[i];\n\t\t*/\n\t\t\n\t\tfor(int j=0;j<3*ss;j++)ve[j]+=tmp[ima[j]]*san[i];\n\t}\n\tfor(auto v:ve)cout<<v<<\" \";\n\tcout<<endl;\n}\n\n\nsigned main(){\n\t\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\nint n;\n\tn=1;\n\tfor(int i=0;i<n;i++)solve();\n\t\n\treturn 0;\n }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <functional>\n#include <iomanip>\n#include <limits>\n//#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll; //10^18\ntypedef unsigned long ul;\n\nusing Graph = vector<vector<ll>>;\n\ntypedef map<ll, ll> m;\ntypedef multimap<ll, ll> mm;\ntypedef set<ll> s;\ntypedef multiset<ll> ms;\ntypedef priority_queue<ll> pq;\ntypedef queue<ll> q;\ntypedef deque<ll> dq;\ntypedef list<ll> lst;\ntypedef pair<ll, ll> p;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define INFLL (9223372036854775807LL)\n#define PI (acos(-1))\n#define MOD 1000000007LL\n#define WALL '#'\n\n//#define and &&a\n//#define or ||\n//#define not !\n//#define neq !=\n//#define eq ==\n\n#define REP(i, n) for (ll i = 0; i < n; i++)\t  // from 0 to n\n#define REPR(i, n) for (ll i = n; i >= 0; i--)\t  // from n to 0\n#define FOR(i, m, n) for (ll i = m; i < n; i++)\t  // from m to n\n#define FORR(i, m, n) for (ll i = m; i >= n; i--) // from m to n\n#define DBG(a) cout << #a << \" : \" << a << \"\\n\";\n#define MSG(a) cout << a << \"\\n\";\n#define ALL(v) v.begin(), v.end()\n#define SZ(x) ((int)(x).size())\n#define PNT(a) printf(\"%lld\", (a))\n\n#define pb push_back //配列などの最後に要素を追加\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define FST first\n#define SND second\n\ntemplate <class T>\nbool chmax(T& a, const T& b)\n{\n\tif (a < b)\n\t{\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T>\nbool chmin(T& a, const T& b)\n{\n\tif (b < a)\n\t{\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n// グローバル変数宣言\n// 迷路用\nvector<ll> dy4 = { 0, 0, -1, 1, 0 }, dx4 = { -1, 1, 0, 0, 0 };\nvector<ll> dx8 = { -1,0,1,-1,1,-1,0,1 }, dy8 = { -1,-1,-1,0,0,1,1,1 };\n\n//\nvector<ll> factorial = {};\nvector<ll> factorialInverse = {};\n\n//swap(a, b);\n//sort(arr, arr + n);\t//昇順\n//sort(arr, arr+n, greater<int>());\t//降順\n//max(a, b);\n//min(a, b);\n\n//upper_bound(a, a+n, k)\t//配列aの中で、kより大きい値が初めて現れる位置へのポインタ\n//upper_bound(ALL(v), k)\t//STLvの中で、kより大きい値が初めて現れる位置へのポインタ\n//lower_bound(a, a+n, k)\n//lower_bound(ALL(v), k)\t//STLvの中で、kの以上値が初めて現れる位置へのポインタ\n//lower_bound(ALL(v),k) - upper_bound(ALL(v),k)\t//二分探索を用いて、ある列aに含まれる数kの個数を求める\n\n// n個のデータをvectorで取得\nvector<ll> INV(ll n)\n{\n\tvector<ll> v(n);\n\tREP(i, n)\n\t\tcin >> v[i];\n\treturn v;\n}\n\n// n個のデータをvectorで取得\nvector<vector<ll>> INV2(ll n, ll m)\n{\n\tvector<vector<ll>> v(n, vector<ll>(m));\n\tREP(i, n)\n\t{\n\t\tREP(j, m)\n\t\t{\n\t\t\tcin >> v[i][j];\n\t\t}\n\t}\n\treturn v;\n}\n\n// index が条件を満たすかどうか\nbool isOK(vector<ll>& v, int index, int key, bool flag)\n{\n\tif (flag) {\n\n\t\tif (v[index] >= key)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\telse {\n\t\tif (v[index] > key)\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n}\n\n// 汎用的な二分探索\n// flag == 1 >=, flag == 0 >\nll bs(vector<ll>& v, ll key, bool flag)\n{\n\tint ng = -1;\t//「index = 0」が条件を満たすこともあるので、初期値は -1\n\tint ok = SZ(v); // 「index = a.size()-1」が条件を満たさないこともあるので、初期値は a.size()\n\n\t/* ok と ng のどちらが大きいかわからないことを考慮 */\n\twhile (abs(ok - ng) > 1)\n\t{\n\t\tint mid = (ok + ng) / 2;\n\n\t\tif (isOK(v, mid, key, flag))\n\t\t\tok = mid;\n\t\telse\n\t\t\tng = mid;\n\t}\n\treturn ok;\n}\n\n// 最大公約数\nll gcd(ll a, ll b)\n{\n\tif (a < b)\n\t\tswap(a, b);\n\tll r = a % b;\n\twhile (r != 0)\n\t{\n\t\ta = b;\n\t\tb = r;\n\t\tr = a % b;\n\t}\n\treturn b;\n}\n\n// 最小公倍数\nvoid lcm(ll a, ll b)\n{\n}\n\n// 素数判定\nbool is_prime(ll n)\n{\n\tbool flg = true;\n\tif (n <= 1)\n\t\tflg = false;\n\telse if (n == 2)\n\t\tflg = true;\n\telse if (n % 2 == 0)\n\t\tflg = false;\n\telse\n\t{\n\t\tfor (ll i = 3; i * i <= n; i += 2)\n\t\t{\n\t\t\tif (n % i == 0)\n\t\t\t\tflg = false;\n\t\t}\n\t}\n\treturn flg;\n}\n\n// 素因数分解\n// iで割った回数をcnt_pf[i - 1]に格納している\n// cnt_pf[0]に入力が素数だった場合にその素数が入る\nvector<ll> prime_factorization(ll n)\n{\n\tvector<ll> cnt_pf(sqrt(n), 0);\n\tFOR(i, 1, SZ(cnt_pf))\n\t{\n\t\twhile (n % (i + 1) == 0)\n\t\t{\n\t\t\tcnt_pf[i]++;\n\t\t\tn /= (i + 1);\n\t\t}\n\t\tif (n == 1)\n\t\t\tbreak;\n\t}\n\tif (n != 1)\n\t{\n\t\tcnt_pf[0] = n;\n\t}\n\treturn cnt_pf;\n}\n\n// 迷路のマップ情報をベクトル化する\n// 通れるところを0に、壁を-1にする\n// スタート地点からの距離を格納するときなどに使う\nvector<vector<ll>> map_vec(vector<string>& str)\n{\n\t// SZ(str[0] = SZ(str[distance(str.begin(), max_element(ALL(str)))])\n\tvector<vector<ll>> v(SZ(str), vector<ll>(SZ(str[distance(str.begin(), max_element(ALL(str)))]), (int)INF));\n\tREP(i, SZ(str))\n\t{\n\t\tREP(j, SZ(str[i]))\n\t\t{\n\t\t\tif (str[i][j] == WALL)\n\t\t\t\tv[i][j] = -1;\n\t\t\t//else\tv[i][j] = INF;\t// if (str[i][j] == '.')\n\t\t}\n\t}\n\treturn v;\n}\n// str中のWALL='#'の数を数える\nll cnt_wall(vector<string> str)\n{\n\tll cnt = 0;\n\tREP(i, SZ(str))\n\t{\n\t\tREP(j, SZ(str[i]))\n\t\t{\n\t\t\tif (str[i][j] == WALL)\n\t\t\t\tcnt++;\n\t\t}\n\t}\n\treturn cnt;\n}\n\n\n// マップの範囲判定\nbool rangeCheck(ll row, ll height, ll col, ll width) {\n\tif (row >= 0 && row < height && col >= 0 && col < width)\treturn true;\n\telse return false;\n}\n\n// 迷路用幅優先探索\n// フィールドの広さと壁の位置を受け取り、ゴールへの最短距離を返す\nll bfs_maze(vector<string>& str, ll s_y, ll s_x, ll g_y, ll g_x)\n{\n\n\tstruct Corr\n\t{\n\t\tll y;\n\t\tll x;\n\t\tll depth;\n\t};\n\tqueue<Corr> que;\n\t// SZ(str[0] = SZ(str[distance(str.begin(), max_element(ALL(str)))])\n\tvector<vector<ll>> v(SZ(str), vector<ll>(SZ(str[distance(str.begin(), max_element(ALL(str)))])));\n\tv = map_vec(str);\n\n\t// スタート地点を含めるのか\n\tque.push({ s_y, s_x, 0 });\n\twhile (!que.empty())\n\t{\n\t\tCorr now = que.front();\n\t\tque.pop();\n\t\tif (now.y == g_y && now.x == g_x)\n\t\t\tbreak;\n\n\t\tREP(i, 4)\n\t\t{\n\t\t\tCorr next = { now.y + dy4[i], now.x + dx4[i], now.depth + 1 };\n\t\t\t// SZ(v[0] = SZ(v[distance(v.begin(), max_element(ALL(v)))])\n\t\t\tif (rangeCheck((int)next.y, SZ(v), (int)next.x, SZ(v[distance(v.begin(), max_element(ALL(v)))])) && v[(int)next.y][(int)next.x] == INF)\n\t\t\t{\n\t\t\t\tv[(int)next.y][(int)next.x] = next.depth;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn v[(int)g_y][(int)g_x];\n}\n\n// 累積和\nvector<ll> cumulative_sum(vector<ll> a)\n{\n\tvector<ll> v(SZ(a) + 1);\n\tv[0] = 0;\n\tREP(i, SZ(a))\n\t{\n\t\tv[i + 1] = v[i] + a[i];\n\t}\n\treturn v;\n}\n\n// 繰り返し二乗法 a^n\nll iterativePower(ll a, ll n)\n{\n\tll res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)\n\t\t\tres = (res * a) % MOD;\n\t\ta = a * a % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\n// MODの逆元\nvector<ll> MODInverse(ll n, ll factN)\n{\n\tvector<ll> res(n + 1);\n\tres[n] = iterativePower(factN, MOD - 2);\n\tREPR(i, n - 1)\n\t{\n\t\tres[i] = res[i + 1] * (i + 1) % MOD;\n\t}\n\treturn res;\n}\n\n// 階乗\nvoid factorialFunc(ll n)\n{\n\tfactorial.pb(1);\n\tFOR(i, 1, n + 1)\n\t{\n\t\tfactorial.pb(factorial[i - 1] * i % MOD);\n\t}\n\tvector<ll> fact;\n\tfact = MODInverse(n, factorial[n]);\n\n\tREP(i, n + 1)\n\t{\n\t\tfactorialInverse.pb(fact[i]);\n\t}\n}\n\n// 二項係数nCr\nll comb(ll n, ll r)\n{\n\tif (n < r)\n\t\treturn 0;\n\t//ll fact = factorial(n);\n\t//vector<ll> fact_inv;\n\t//fact_inv = MODInverse(n, fact);\n\treturn (factorial[n] * factorialInverse[r]) % MOD * factorialInverse[n - r] % MOD;\n}\n\n// 文字列を連続した文字ごとに分解\nvector<pair<char, ll>> decompose_str(string s)\n{\n\tvector<pair<char, ll>> moji_cnt;\n\tmoji_cnt.pb(mp(s[0], 0));\n\tREP(i, SZ(s))\n\t{\n\t\tif (moji_cnt.back().first == s[i])\n\t\t{\n\t\t\tmoji_cnt.back().second++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmoji_cnt.pb(mp(s[i], 1));\n\t\t}\n\t}\n\treturn moji_cnt;\n}\n\n// 解答のベクトル出力(空白区切り)\nvoid ans_vec(vector<ll> ans)\n{\n\tREP(i, SZ(ans))\n\t{\n\t\tcout << ans[i] << endl;\n\t}\n\t//cout << endl;\n}\n\n//\nvoid dinamic_programming(void)\n{\n}\n\n// 総和の公式：Σk\nll totalSumFirst(ll x, ll y)\n{\n\tx = x - 1;\n\treturn (y * (y + 1) - x * (x + 1)) / 2;\n}\n\n// 総和の公式：Σk^2\nll totalSumSecond(ll x, ll y)\n{\n\tx = x - 1;\n\treturn (y * (y + 1) * (2 * y + 1) - x * (x + 1) * (2 * x + 1)) / 6;\n}\n\n// 総和の公式：Σk^3\nll totalSumThird(ll x, ll y)\n{\n\treturn pow(totalSumFirst(x, y), 2);\n}\n\n// 約数\nvector<ll> makeDivisors(ll n)\n{\n\tvector<ll> divisors;\n\tfor (ll i = 1; i * i <= n; i++)\n\t{\n\t\tif (n % i == 0)\n\t\t{\n\t\t\tdivisors.pb(i);\n\t\t\tif (i != n / i)\n\t\t\t{\n\t\t\t\tdivisors.pb(n / i);\n\t\t\t}\n\t\t}\n\t}\n\tsort(ALL(divisors));\n\n\treturn divisors;\n}\n\n// 尺取り法\nll shakutori(vector<ll>& v, ll x)\n{\n\tll res = 0;\n\tll n = SZ(v);\n\n\tll sum = 0;\n\tll right = 0;\n\n\tREP(left, n)\n\t{\n\n\t\twhile (right < n && sum + v[right] <= x)\n\t\t{\n\t\t\tsum += v[right];\n\t\t\tright++;\n\t\t}\n\t\tres += (right - left);\n\n\t\tif (right == left)\n\t\t\tright++;\n\t\telse\n\t\t\tsum -= v[left];\n\t}\n\n\treturn res;\n}\n\n\nvector<bool> seen;\nvector<vector<ll>> pa;\n// 深さ優先探索\nvoid dfs(const Graph& g, ll x, ll& cnt)\n{\n\tseen[x] = true; // v を訪問済にする\n\tpa[x][0] = cnt;\n\tcnt++;\n\n\t// v から行ける各頂点 next_v について\n\tfor (auto next_x : g[x]) {\n\t\tif (seen[next_x]) continue; // next_v が探索済だったらスルー\n\t\tdfs(g, next_x, cnt); // 再帰的に探索\n\t}\n\tpa[x][1] = cnt;\n\tcnt++;\n}\n\n//\nvoid dfs_maze(vector<vector<ll>>& maps, ll row, ll col, ll& cnt) {\n\tif (rangeCheck(row, SZ(maps), col, SZ(maps[0])) && maps[row][col]) {\n\t\tmaps[row][col] = 0;\n\t\tREP(k, 8) {\n\t\t\tdfs_maze(maps, row + dy8[k], col + dx8[k], cnt);\n\t\t}\n\t}\n}\n\n// 幅優先探索\nvoid bfs()\n{\n}\n\n// bit全探索\nvoid bitFullSearch(ll n)\n{\n\tREP(bit, 1 << n)\n\t{\n\t\tvector<ll> vec;\n\t\tREP(i, n)\n\t\t{\n\t\t\tif (bit >> i & 1)\n\t\t\t{\n\t\t\t\tvec.pb(i);\n\t\t\t}\n\t\t}\n\t}\n}\n\n// 重複削除\nvector<ll> duplicateDeletion(vector<ll> vec)\n{\n\tsort(ALL(vec));\n\tvec.erase(unique(ALL(vec)), vec.end());\n\treturn vec;\n}\n\n// 文字列区切り\nvector<string> split(string s, string delim)\n{\n\tif (s.empty())\n\t\treturn {};\n\tif (delim.empty())\n\t\treturn { s };\n\tint start = 0;\n\tauto delim_pos = s.find(delim);\n\tvector<string> ret_v;\n\twhile (delim_pos != string::npos)\n\t{\n\t\tif (start != delim_pos)\n\t\t\tret_v.push_back(s.substr(start, delim_pos - start)); // 残り文字列の先頭が区切り文字列だった時はvectorに追加しない\n\t\tstart = delim_pos + delim.size();\n\t\tdelim_pos = s.find(delim, start);\n\t}\n\tif (start < s.size())\n\t\tret_v.push_back(s.substr(start)); // 最後の区切り文字以降に文字がある場合\n\treturn ret_v;\n}\n\n//\n// main関数\n//\n\nsigned\nmain()\n{\n\t//cin.tie(0);\n\t//ios::sync_with_stdio(false);\n\n\t// 変数（scala）取得\n\t//ll n;\n\t//cin >> n;\n\n\t// 変数（vector）取得\n\t// vector<ll> a;\n\t// a = INV(n);\n\t////m=2;\n\t//vector<vector<ll>> vec(n, vector<ll>(m));\n\t//vec = INV2(n, m);\n\n\t// vector<vector<ll>> a(3);\n\t// REP(i, a)\n\t// {\n\t// \tll tmp;\n\t// \tcin >> tmp;\n\t// \ta[0].pb(tmp);\n\t// }\n\t// REP(i, b)\n\t// {\n\t// \tll tmp;\n\t// \tcin >> tmp;\n\t// \ta[1].pb(tmp);\n\t// }\n\t// REP(i, c)\n\t// {\n\t// \tll tmp;\n\t// \tcin >> tmp;\n\t// \ta[2].pb(tmp);\n\t// }\n\n\t// 文字列取得\n\t// string s;\n\t// cin >> s;\n\n\t// 文字列（vector）取得\n\t// vector<string> str(n);\n\t// REP(i, n)\n\t// {\n\t// \tcin >> str[i];\n\t// }\n\n\t// グラフ取得\n\t//Graph g(n);\n\t//REP(i, k) {\n\t//\tll from, weight;\n\t//\tcin >> from >> weight;\n\t//\tg[from].pb(to);\n\t//\t//g[to].pb(from);\n\t//}\n\n\t// 迷路用string取得\n\t//vector<string> str(h);\n\t//REP(i, h) {\n\t// cin >> str[i];\n\t//}\n\n\t// 二項係数を計算する際に必要\n\n\t// factorialFunc(n);\n\n\t//\n\t// 実装部分\n\t//\n\n\tll n;\n\tstring t;\n\tcin >> n >> t;\n\tll n3 = pow(3, n);\n\tll cnt_s = 0, cnt_r = 0;\n\n\tvector<ll> table(n3, INF);\n\tREP(i, n3) {\n\t\tif (table[i] == INF) {\n\t\t\tll tmp = i;\n\t\t\tstring str;\n\t\t\tREPR(j, 11) {\n\t\t\t\tint keta = pow(3, j);\n\t\t\t\tint sho = tmp / keta;\n\t\t\t\tint amari = tmp % keta;\n\t\t\t\tstr.append(to_string(sho));\n\t\t\t\ttmp = amari;\n\t\t\t\t//if (!tmp)\tbreak;\n\t\t\t}\n\t\t\t//tmp = 0;\n\t\t\tREP(j, 12) {\n\t\t\t\tif (str[j] == '1')\tstr[j] = '2';\n\t\t\t\telse if (str[j] == '2')\tstr[j] = '1';\n\t\t\t\ttmp += pow(3, 11 - j) * (str[j] - '0');\n\t\t\t}\n\t\t\ttable[i] = tmp;\n\t\t\ttable[tmp] = i;\n\t\t}\n\t}\n\n\n\tdeque<ll> que;\n\tREP(i, n3) {\n\t\tque.pb(i);\n\t}\n\tvector<bool> chk(n3, true);\n\tREP(i, SZ(t)) {\n\t\tif (t[i] == 'S') {\n\t\t\tREP(j, n3) {\n\t\t\t\tif (chk[j]) {\n\t\t\t\t\tll tmp = que.at(table[j]);\n\t\t\t\t\tque.erase(que.begin() + table[j]);\n\t\t\t\t\tque.insert(que.begin() + table[j], que.at(j));\n\t\t\t\t\tque.erase(que.begin() + j);\n\t\t\t\t\tque.insert(que.begin() + j, tmp);\n\t\t\t\t\tchk[j] = chk[table[j]] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tll tmp = que.back();\n\t\t\tque.pop_back();\n\t\t\tque.push_front(tmp);\n\t\t}\n\t}\n\n\tREP(i, n3) {\n\t\tll tmp = que.front();\n\t\tque.pop_front();\n\t\tcout << tmp << \" \";\n\t}\n\tcout << endl;\n\n\n\n\t//\n\t// 実装部分おわり\n\t//\n\n\t// 解答出力\n\t// cout << fixed << setprecision(10);\n\t// MSG(ans);\n\t//ans_vec(ans);\n\n\treturn 0;\n}\n\n//\n// memo\n//\n\n//for(ll i=0; i<n;i++)　// ループ\n//cout << << endl;\t// 出力\n//sort(ALL(a), greater<ll>()); // 降順\n// abs(k)\t// 絶対値\n// sqrt(n)\t// ルート\n// ceil(n)\t// 切り上げ\n// floor(n)\t// 切り捨て\n// round(n)\t// 四捨五入\n// map<ll, ll, greater<ll>> mp;\t// mapの降順\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define N 5000005\nvoid Read(int &p)\n{\n\tp = 0;\n\tchar c = getchar();\n\tfor (; c < '0' || c > '9'; c = getchar());\n\tfor (; c >= '0' && c <= '9'; c = getchar())p = p * 10 + c - '0';\n}\nint n, m, rot, cnt, val[N], ans[N];\nchar T[N];\nstruct Node{int ch[3], rv, tg;}S[N];\nvoid Build(int &q, int d, int s)\n{\n\tq = ++cnt;\n\tif (d == n)\n\t{\n\t\tS[q].tg = s;\n\t\treturn;\n\t}\n\tBuild(S[q].ch[0], d + 1, s);\n\tBuild(S[q].ch[1], d + 1, s + val[d]);\n\tBuild(S[q].ch[2], d + 1, s + val[d] * 2);\n}\nvoid Pushdown(int q)\n{\n\tif (S[q].rv)\n\t{\n\t\tswap(S[q].ch[1], S[q].ch[2]);\n\t\tS[S[q].ch[0]].rv ^= 1;\n\t\tS[S[q].ch[1]].rv ^= 1;\n\t\tS[S[q].ch[2]].rv ^= 1;\n\t\tS[q].rv = 0;\n\t}\n}\nvoid Insert(int q, int d)\n{\n\tif (d == n)\n\t\treturn;\n\tPushdown(q);\n\tint a = S[q].ch[0];\n\tint b = S[q].ch[1];\n\tint c = S[q].ch[2];\n\tS[q].ch[1] = a;\n\tS[q].ch[2] = b;\n\tS[q].ch[0] = c;\n\tInsert(S[q].ch[0], d + 1);\n}\nvoid Getans(int q, int d, int s)\n{\n\tif (d == n)\n\t{\n\t\tans[S[q].tg] = s;\n\t\treturn;\n\t}\n\tPushdown(q);\n\tGetans(S[q].ch[0], d + 1, s);\n\tGetans(S[q].ch[1], d + 1, s + val[d]);\n\tGetans(S[q].ch[2], d + 1, s + val[d] * 2);\n}\nint main()\n{\n\tRead(n);\n\tval[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tval[i] = val[i - 1] * 3;\n\tBuild(rot, 0, 0);\n\tscanf(\"%s\", T + 1);\n\tm = strlen(T + 1);\n\tfor (int i = 1; i <= m; i++)\n\t\tif (T[i] == 'S')\n\t\t\tS[rot].rv ^= 1;\n\t\telse\n\t\t\tInsert(rot, 0);\n\tGetans(rot, 0, 0);\n\tfor (int i = 0; i < val[n]; i++)\n\t\tprintf(\"%d%c\", ans[i], i == val[n] - 1 ? 10 : 32);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof (x))\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define fi first\n#define se second\n#define kill _z_kill\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outv(x) cerr<<#x\" = \"<<x<<\"  \"\n#define outtag(x) cerr<<\"--------------\"#x\"---------------\"<<endl\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n\tFor(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\n#define User_Time ((double)clock()/CLOCKS_PER_SEC)\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned uint;\ntypedef long double LD;\ntypedef vector <int> vi;\ntypedef pair <int,int> pii;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\n//const int mod=998244353;\n//int Pow(int x,int y){\n//\tint ans=1;\n//\tfor (;y;y>>=1,x=(LL)x*x%mod)\n//\t\tif (y&1)\n//\t\t\tans=(LL)ans*x%mod;\n//\treturn ans;\n//}\n//void Add(int &x,int y){\n//\tif ((x+=y)>=mod)\n//\t\tx-=mod;\n//}\n//void Del(int &x,int y){\n//\tif ((x-=y)<0)\n//\t\tx+=mod;\n//}\n//int Add(int x){\n//\treturn x>=mod?x-mod:x;\n//}\n//int Del(int x){\n//\treturn x<0?x+mod:x;\n//}\nconst int N=13,S=6e5;\nint n,m;\nchar t[S];\nint T[S],P[S];\nvi a[N][S];\nint res[N][S];\nint rev[3]={0,2,1};\nint main(){\n\tn=read();\n\tscanf(\"%s\",t+1);\n\tm=strlen(t+1);\n\tFor(i,1,m){\n\t\tT[i]=t[i]=='S',P[i]=P[i-1]^T[i];\n\t\tif (!T[i])\n\t\t\ta[0][0].pb(i);\n\t}\n\tFor(i,0,n-1){\n\t\tint s=pow(3,i);\n\t\tFor(v,0,s*3-1){\n\t\t\tint d=v/s,t=v%s;\n\t\t\tif (i>0)\n\t\t\t\tres[i][v]+=res[i-1][t];\n\t\t\tint las=0;\n\t\t\tfor (auto k : a[i][t]){\n\t\t\t\tif (P[k]^P[las])\n\t\t\t\t\td=rev[d];\n\t\t\t\td=(d+1)%3;\n\t\t\t\tif (!d)\n\t\t\t\t\ta[i+1][v].pb(k);\n\t\t\t\tlas=k;\n\t\t\t}\n\t\t\tif (P[las]^P[m])\n\t\t\t\td=rev[d];\n\t\t\tres[i][v]+=d*s;\n\t\t}\n\t}\n\tint n3=pow(3,n);\n\tFor(i,0,n3-1)\n\t\tprintf(\"%d \",res[n-1][i]);\n\tputs(\"\");\n\treturn 0;\n}\n/*\n46\n1 2 0 1\n2 1 0 2\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define N 531500\nvoid Read(int &p)\n{\n\tp = 0;\n\tchar c = getchar();\n\tfor (; c < '0' || c > '9'; c = getchar());\n\tfor (; c >= '0' && c <= '9'; c = getchar())p = p * 10 + c - '0';\n}\nint n, m, rot, cnt, val[N], ans[N];\nchar T[N];\nstruct Node{int ch[3], rv, tg;}S[N];\nvoid Build(int &q, int d, int s)\n{\n\tq = ++cnt;\n\tif (d == n)\n\t{\n\t\tS[q].tg = s;\n\t\treturn;\n\t}\n\tBuild(S[q].ch[0], d + 1, s);\n\tBuild(S[q].ch[1], d + 1, s + val[d]);\n\tBuild(S[q].ch[2], d + 1, s + val[d] * 2);\n}\nvoid Pushdown(int q)\n{\n\tif (S[q].rv)\n\t{\n\t\tswap(S[q].ch[1], S[q].ch[2]);\n\t\tS[S[q].ch[0]].rv ^= 1;\n\t\tS[S[q].ch[1]].rv ^= 1;\n\t\tS[S[q].ch[2]].rv ^= 1;\n\t\tS[q].rv = 0;\n\t}\n}\nvoid Insert(int q, int d)\n{\n\tif (d == n)\n\t\treturn;\n\tPushdown(q);\n\tint a = S[q].ch[0];\n\tint b = S[q].ch[1];\n\tint c = S[q].ch[2];\n\tS[q].ch[1] = a;\n\tS[q].ch[2] = b;\n\tS[q].ch[0] = c;\n\tInsert(S[q].ch[0], d + 1);\n}\nvoid Getans(int q, int d, int s)\n{\n\tif (d == n)\n\t{\n\t\tans[S[q].tg] = s;\n\t\treturn;\n\t}\n\tPushdown(q);\n\tGetans(S[q].ch[0], d + 1, s);\n\tGetans(S[q].ch[1], d + 1, s + val[d]);\n\tGetans(S[q].ch[2], d + 1, s + val[d] * 2);\n}\nint main()\n{\n\tRead(n);\n\tval[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tval[i] = val[i - 1] * 3;\n\tBuild(rot, 0, 0);\n\tscanf(\"%s\", T + 1);\n\tm = strlen(T + 1);\n\tfor (int i = 1; i <= m; i++)\n\t\tif (T[i] == 'S')\n\t\t\tS[rot].rv ^= 1;\n\t\telse\n\t\t\tInsert(rot, 0);\n\tGetans(rot, 0, 0);\n\tfor (int i = 0; i < val[n]; i++)\n\t\tprintf(\"%d%c\", ans[i], i == val[n] - 1 ? 10 : 32);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\nusing namespace std;\nconst int N=555555;\nint n,m,ans[N],at[3];\nint L[N],R[N],nL[N],nR[N];\nint tmp[N],a[N];\nchar s[N];\nint main(){\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s+1);\n\tm=strlen(s+1);\n\tans[0]=0; ans[1]=1; ans[2]=2;\n\tL[0]=ans[0]; R[0]=ans[2];\n\tFor(i,1,m){\n\t\tif (s[i]=='R'){\n\t\t\tint t=ans[2]; ans[2]=ans[1];\n\t\t\tans[1]=ans[0]; ans[0]=t;\n\t\t}\n\t\telse swap(ans[1],ans[2]);\n\t\tL[i]=ans[0]; R[i]=ans[2];\n\t}\n\tint l=3;\n\t//For(i,0,2) cout<<ans[i]<<' '; cout<<endl;\n\tFor(i,2,n){\n\t\tFor(j,0,2) For(k,0,l-1) a[j*l+k]=j*l+k;\n\t\tFor(j,0,2) at[j]=j;\n\t\tnL[0]=0; nR[0]=l*3-1;\n\t\tFor(j,1,m){\n\t\t\t//cout<<R[j-1]<<' '<<L[j]<<endl;\n\t\t\tif (s[j]=='S') swap(at[1],at[2]);\n\t\t\telse{\n\t\t\t\tint v[3];\n\t\t\t\tFor(k,0,2) v[k]=a[at[k]*l+R[j-1]];\n\t\t\t\t//For(k,0,2) cout<<v[k]<<' '; cout<<endl;\n\t\t\t\tFor(k,0,2) a[at[k]*l+L[j]]=v[(k+2)%3];\n\t\t\t}\n\t\t\tnL[j]=a[at[0]*l+L[j]];\n\t\t\tnR[j]=a[at[2]*l+R[j]];\n\t\t\t//cout<<nL[j]<<' '<<nR[j]<<endl;\n\t\t}\n\t\t//For(j,0,2) cout<<a[j]<<endl;\n\t\tFor(j,0,2) For(k,0,l-1) tmp[j*l+k]=a[at[j]*l+ans[k]];\n\t\tFor(j,0,3*l-1) ans[j]=tmp[j];\n\t\tFor(j,0,m) L[j]=nL[j],R[j]=nR[j];\n\t\tl*=3;\n\t}\n\tFor(j,0,l-1) a[ans[j]]=j;\n\tFor(j,0,l-1) printf(\"%d \",a[j]);\n}\n/*\n2 SRSRR\n*/\n/*\n0 1 2 3 4 5 6 7 8\n0 2 1 6 8 7 3 5 4\n4 0 2 1 6 8 7 3 5\n4 2 0 7 5 3 1 8 6\n*/"
  },
  {
    "language": "C++",
    "code": "/*\nContest: -\nProblem: Atcoder Grand Contest 044 C\nAuthor: tzc_wk\nTime: 2020.5.25\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define fi\t\t\tfirst\n#define se\t\t\tsecond\n#define fz(i,a,b)\tfor(int i=a;i<=b;i++)\n#define fd(i,a,b)\tfor(int i=a;i>=b;i--)\n#define foreach(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)\n#define all(a)\t\ta.begin(),a.end()\n#define giveup(...) return printf(__VA_ARGS__),0;\n#define fill0(a)\tmemset(a,0,sizeof(a))\n#define fill1(a)\tmemset(a,-1,sizeof(a))\n#define fillbig(a)\tmemset(a,0x3f,sizeof(a))\n#define fillsmall(a) memset(a,0xcf,sizeof(a))\n#define mask(a)\t\t(1ll<<(a))\n#define maskx(a,x)\t((a)<<(x))\n#define _bit(a,x)\t(((a)>>(x))&1)\n#define _sz(a)\t\t((int)(a).size())\n#define filei(a)\tfreopen(a,\"r\",stdin);\n#define fileo(a)\tfreopen(a,\"w\",stdout);\n#define fileio(a) \tfreopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define put(x)\t\tputchar(x)\n#define eoln        put('\\n')\n#define space\t\tput(' ')\n#define y1\t\t\ty1010101010101\n#define y0\t\t\ty0101010101010\ntypedef pair<int,int> pii;\ninline int read(){\n\tint x=0,neg=1;char c=getchar();\n\twhile(!isdigit(c)){\n\t\tif(c=='-')\tneg=-1;\n\t\tc=getchar();\n\t}\n\twhile(isdigit(c))\tx=x*10+c-'0',c=getchar();\n\treturn x*neg;\n}\ninline void print(int x){\n\tif(x<0){\n\t\tputchar('-');\n\t\tprint(abs(x));\n\t\treturn;\n\t}\n\tif(x<=9)\tputchar(x+'0');\n\telse{\n\t\tprint(x/10);\n\t\tputchar(x%10+'0');\n\t}\n}\ninline int qpow(int x,int e,int _MOD){\n\tint ans=1;\n\twhile(e){\n\t\tif(e&1)\tans=ans*x%_MOD;\n\t\tx=x*x%_MOD;\n\t\te>>=1;\n\t}\n\treturn ans;\n}\nint n=read(),m;\nchar s[1000005];\nint tot=1,a[1000005<<2],ans[1000005];\nint ch[1000005<<2][4],lz[1000005<<2];\ninline void build(int k,int val,int dep){\n\tif(dep==n){\n\t\ta[k]=val;\n//\t\tcout<<k<<\" \"<<val<<endl;\n\t\treturn;\n\t}\n\tfor(int i=0;i<3;i++){\n\t\tbuild(ch[k][i]=++tot,val+i*pow(3,dep),dep+1);\n\t}\n}\ninline void pushdown(int k){\n\tif(lz[k]){\n\t\tswap(ch[k][1],ch[k][2]);\n\t\tfor(int i=0;i<3;i++)\tlz[ch[k][i]]^=1;\n\t\tlz[k]=0;\n\t}\n}\ninline void add(){\n\tint cur=1;\n\tfor(int i=1;i<=n;i++){\n\t\tpushdown(cur);\n\t\tswap(ch[cur][0],ch[cur][2]);\n\t\tswap(ch[cur][1],ch[cur][2]);\n\t\tcur=ch[cur][0];\n\t}\n}\ninline void dfs(int k,int val,int dep){\n\tif(dep==n){\n\t\tans[a[k]]=val;\n\t\treturn;\n\t}\n\tpushdown(k);\n\tfor(int i=0;i<3;i++){\n\t\tdfs(ch[k][i],val+i*pow(3,dep),dep+1);\n\t}\n}\nsigned main(){\n\tbuild(1,0,0);\n\tcin>>s+1;\n\tm=strlen(s+1);\n\tfz(i,1,m){\n\t\tif(s[i]=='S')\tlz[1]^=1;\n\t\telse\t\t\tadd();\n\t}\n\tdfs(1,0,0);\n\tfz(i,0,pow(3,n)-1)\tcout<<ans[i]<<\" \";\n\treturn 0;\n}\n/*\n\t\t0\n  0     1     2\n0 3 6 1 4 7 2 5 8\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\ninline int read () {\n    int ret = 0, t = 1;\n    char c = getchar();\n    while ((c < '0' || c > '9') && c != '-') c = getchar();\n    if (c == '-') t = -1, c = getchar();\n    while (c >= '0' && c <= '9') ret = ret * 10 + c - '0', c = getchar();\n    return ret * t;\n}\n\n#define PR pair<int, int>\n#define MP make_pair\n#define TO first\n#define NUM second\n\nint n;\nconst int MAXN = 600600;\nstruct tree { PR s[3]; int val; bool lazy; } t[MAXN];\nint top = 1;\n\nvoid build (int x, int st, int tmp, int val) {\n    if (st == n) { t[x].val = val; return; }\n    t[x].s[0] = MP(++top, 0); build(t[x].s[0].TO, st + 1, tmp * 3, val + tmp * 0);\n    t[x].s[1] = MP(++top, 1); build(t[x].s[1].TO, st + 1, tmp * 3, val + tmp * 1);\n    t[x].s[2] = MP(++top, 2); build(t[x].s[2].TO, st + 1, tmp * 3, val + tmp * 2);\n}\n\nPR fnd (int x) {\n    int u, v;\n    if (t[x].s[0].NUM == 1) u = 0;\n    if (t[x].s[1].NUM == 1) u = 1;\n    if (t[x].s[2].NUM == 1) u = 2;\n    if (t[x].s[0].NUM == 2) v = 0;\n    if (t[x].s[1].NUM == 2) v = 1;\n    if (t[x].s[2].NUM == 2) v = 2;\n    return MP(u, v);\n}\n\nvoid pushdown (int x) {\n    if (!t[x].lazy) return;\n    t[x].lazy = false;\n    for (int i = 0; i < 3; i++) {\n        PR tmp = fnd(t[x].s[i].TO);\n        int rua = t[x].s[i].TO;\n        swap(t[rua].s[tmp.first].NUM, t[rua].s[tmp.second].NUM);\n    }\n    t[t[x].s[0].TO].lazy ^= 1, t[t[x].s[1].TO].lazy ^= 1, t[t[x].s[2].TO].lazy ^= 1;\n}\n\nvoid mod1 (int x) {\n    if (!t[x].s[0].TO) return;\n    pushdown(x);\n    ++t[x].s[0].NUM, ++t[x].s[1].NUM, ++t[x].s[2].NUM;\n    if (t[x].s[0].NUM == 3) t[x].s[0].NUM = 0, mod1(t[x].s[0].TO);\n    if (t[x].s[1].NUM == 3) t[x].s[1].NUM = 0, mod1(t[x].s[1].TO);\n    if (t[x].s[2].NUM == 3) t[x].s[2].NUM = 0, mod1(t[x].s[2].TO);\n}\n\nvoid mod2 (int x) {\n    if (!t[x].s[0].TO) return;\n    PR tmp = fnd(x);\n    swap(t[x].s[tmp.first].NUM, t[x].s[tmp.second].NUM);\n    t[x].lazy ^= 1;\n}\n\nint ans[MAXN];\nvoid query (int x, int st, int val) {\n    if (!t[x].s[0].TO) { ans[t[x].val] = val; return; }\n    pushdown(x);\n    query(t[x].s[0].TO, st * 3, val + st * t[x].s[0].NUM);\n    query(t[x].s[1].TO, st * 3, val + st * t[x].s[1].NUM);\n    query(t[x].s[2].TO, st * 3, val + st * t[x].s[2].NUM);\n}\n\nint main () {\n    n = read();\n    build(1, 0, 1, 0);\n    char c = getchar();\n    while (c != 'S' && c != 'R') c = getchar();\n    while (c == 'S' || c == 'R') {\n        if (c == 'S') mod2(1);\n        else mod1(1);\n        c = getchar();\n    }\n    query(1, 1, 0);\n    int tmp = 1;\n    while (n--) tmp *= 3;\n    for (int i = 0; i < tmp; i++) printf(\"%d \", ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n    #define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define pb push_back\n//#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int MXSZ = 300;\n\nstruct tchange\n{\n\tstring from, to;\n\tint flip;\n};\n\nconst int maxn = 1000006;\n\nvector<tchange> mp, newmp;\nint init[maxn];\nchar s[maxn];\nint n, nn;\n\nvoid apply()\n{\n\tfor (int i = 0; i < nn; i++)\n\t{\n\t\tbool found = false;\n\t\tfor (auto &t : mp)\n\t\t{\n\t\t\tint cur = init[i];\n\t\t\tbool ok = true;\n\t\t\tfor (int i = (int)t.from.length() -  1; i >= 0; i--)\n\t\t\t{\n\t\t\t\tok &= (t.from[i] == ('0' + cur % 3));\n\t\t\t\tcur /= 3;\n\t\t\t}\n\t\t\tif (ok)\n\t\t\t{\n\t\t\t\t//cout << \"found for \" << i << ' ' << t.from << ' ' << t.to << ' ' << t.flip << endl;\n\t\t\t\tcur = init[i];\n\t\t\t\tint newv = 0;\n\t\t\t\tint pw = 1;\n\t\t\t\tfor (int i = (int)t.from.length() -  1; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tnewv = newv + (t.to[i] - '0') * pw;\n\t\t\t\t\tcur /= 3;\n\t\t\t\t\tpw *= 3;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n - (int)t.from.length(); i++)\n\t\t\t\t{\n\t\t\t\t\tint was = cur % 3;\n\t\t\t\t\tif (was != 0 && t.flip) was = 1 + 2 - was;\n\t\t\t\t\tnewv = newv + was * pw;\n\t\t\t\t\tcur /= 3;\n\t\t\t\t\tpw *= 3;\n\t\t\t\t}\n\t\t\t\tinit[i] = newv;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tassert(found);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tnn = 1;\n\tfor (int i = 0; i < n; i++) nn *= 3;\n\tscanf(\"%s\", s);\n\tint len = strlen(s);\n\tfor (int i = 0; i < nn; i++) init[i] = i;\n\tmp.pb({\"\", \"\", 0});\n\tfor (int it = 0; it < len; it++)\n\t{\n\t\t//cout << \"before \" << it << endl;\n\t\t//for (auto t : mp) cout << t.from << ' ' << t.to << ' ' << t.flip << endl;\n\t\tif (mp.size() > MXSZ)\n\t\t{\n\t\t\tapply();\n\t\t\tmp.clear();\n\t\t\tmp.pb({\"\", \"\", 0});\n\t\t}\n\t\tchar op = s[it];\n\t\tif (op == 'S')\n\t\t{\n\t\t\tfor (int i = 0; i < (int)mp.size(); i++)\n\t\t\t{\n\t\t\t\tfor (auto &c : mp[i].to) if (c != '0') c = '1' + '2' - c;\n\t\t\t\tmp[i].flip ^= 1;\n\t\t\t}\n\t\t} else\n\t\t{\n\t\t\tnewmp.clear();\n\t\t\tfor (int i = 0; i < (int)mp.size(); i++)\n\t\t\t{\n\t\t\t\tbool all2 = true;\n\t\t\t\tfor (auto &c : mp[i].to) if (c != '2') all2 = false;\n\t\t\t\tif (all2)\n\t\t\t\t{\n\t\t\t\t\tif ((int)mp[i].from.length() == n)\n\t\t\t\t\t{\n\t\t\t\t\t\tnewmp.push_back({mp[i].from, string(n, '0'), mp[i].flip});\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tmp.push_back({\"0\" + mp[i].from, \"0\" + mp[i].to, mp[i].flip});\n\t\t\t\t\t\tmp.push_back({\"1\" + mp[i].from, string(1, '1' + mp[i].flip) + mp[i].to, mp[i].flip});\n\t\t\t\t\t\tmp.push_back({\"2\" + mp[i].from, string(1, '2' - mp[i].flip) + mp[i].to, mp[i].flip});\n\t\t\t\t\t}\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tfor (int j = (int)mp[i].to.length() - 1; j >= 0; j--)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (mp[i].to[j] != '2')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmp[i].to[j]++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmp[i].to[j] = '0';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnewmp.pb(mp[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmp = newmp;\n\t\t}\n\t}\n\t//for (auto t : mp) cout << t.from << ' ' << t.to << ' ' << t.flip << endl;\n\tapply();\n\tfor (int i = 0; i < nn; i++) printf(\"%d \", init[i]);\n\tprintf(\"\\n\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#define int long long\n \n#define pii pair<int, int>\n \n#define x1 x1228\n#define y1 y1228\n \n#define left left228\n#define right right228\n \n#define next next228\n \n#define pb push_back\n#define eb emplace_back\n \n#define mp make_pair                                                                \n                                                                                                                                        \n#define ff first                                                                  \n#define ss second   \n \n#define all(x) x.begin(), x.end()\n#define debug(x) cout << #x << \": \" << x << endl; \n#define TIME (ld)clock()/CLOCKS_PER_SEC\n \nusing namespace std;\ntypedef long long ll; \ntypedef long double ld; \n                                                                                                   \nconst int maxn = 2e5 + 7, mod = 1e9 + 7, MAXN = 1e6 + 7;\nconst double eps = 1e-9;\nconst ll inf = 1e18;\nmt19937 rnd(time(0));\nint n; \nstring s; \nint next[MAXN];\nconst int N = 2187; \nint dp1[N]; \nint dp2[N]; \nint xyz[N]; \n \nint get1(int mask, char q) {\n    if (q == 'R') {\n        ++mask; \n        return mask; \n    }   \n    int ptr = 1; \n    int ans = 0; \n    while (mask) {\n        int t = mask % 3; \n        mask /= 3; \n        if (t == 2) ans += ptr; \n        if (t == 1) ans += 2 * ptr; \n        ptr *= 3; \n    }\n    return ans; \n}\n \nconst int L = 12; \nint pref[maxn]; \nint to[maxn]; \nint kek1[N], kek2[N]; \nint res[N], res1[N]; \nint add = 1; \n \nvoid print(int x) {\n    while (x) {\n        cout << x % 3 << \" \"; \n        x /= 3; \n    }\n    cout << '\\n'; \n}\n\nint get(int x) {\n    vector<int> bts; \n    for (int i = 0; i < L; ++i) {\n        bts.pb(x % 3); \n        x /= 3; \n    }\n    int left = 0;\n    int right = 0; \n    for (int i = 6; i >= 0; --i) {\n        left *= 3;\n        left += bts[i]; \n    }\n    for (int i = L - 1; i >= 7; --i) {\n        right *= 3; \n        right += bts[i]; \n    }\n    int id = 0;         \n    if (left && dp1[left] == -1) {\n        if ((pref[(int)s.size()] - pref[id]) & 1) {        \n            right = xyz[right];     \n        }\n        return res[left] + add * right;   \n    }\n    if (left) {    \n        id = dp1[left]; \n        if (pref[id + 1] & 1) {\n            right = xyz[right];             \n        }\n        ++right;\n        left = 0; \n    }                     \n    while (next[id] != -1) {        \n        if ((pref[next[id]] - pref[id]) & 1) {\n            right = xyz[right]; \n        }\n        right++; \n        id = next[id];                                                                                                                                         \n    }\n    if ((pref[(int)s.size()] - pref[id]) & 1) {        \n        right = xyz[right];     \n    }\n    left = to[id]; \n    return left + right * add; \n}\n \nvoid solve() {\n    for (int i = 0; i < N; ++i) {\n        xyz[i] = get1(i, 'S') % N; \n    }\n    cin >> n >> s; \n    int t = s.size(); \n    for (int i = 0; i < t; ++i) {\n        pref[i + 1] = pref[i] + (s[i] == 'S'); \n    }\n \n    for (int i = 0; i < N; ++i) dp1[i] = dp2[i] = -1; \n    next[t] = -1;\n    for (int i = 0; i < N; ++i) kek1[i] = i;              \n    for (int i = 0; i < N; ++i) res[i] = i; \n    for (int i = t - 1; i >= 0; --i) {\n        for (int mask = 0; mask < N; ++mask) {\n            int mask1; \n            if (s[i] == 'S') mask1 = xyz[mask]; \n            else mask1 = mask + 1; \n            if (mask1 >= N) mask1 -= N; \n            res1[mask] = res[mask1]; \n            kek2[mask] = kek1[mask1];\n            if (mask && mask1 == 0) {\n                dp2[mask] = i + 1; \n            } else {\n                dp2[mask] = dp1[mask1]; \n            }                                                                                 \n        }\n        to[i] = kek2[0]; \n        next[i] = dp2[0]; \n        for (int mask = 0; mask < N; ++mask) {\n            res[mask] = res1[mask]; \n            kek1[mask] = kek2[mask]; \n            dp1[mask] = dp2[mask]; \n            dp2[mask] = -1; \n        }\n    }\n    for (int i = 0; i < 7; ++i) add *= 3; \n    int tet = 1; \n    for (int i = 0; i < n; ++i) tet *= 3; \n    for (int ptr = 0; ptr < tet; ++ptr) {\n        cout << get(ptr) % tet << \" \"; \n    }\n//    cout << TIME; \n    return; \n}                                \n   \nsigned main() {\n#ifdef LOCAL\n    freopen(\"TASK.in\", \"r\", stdin);\n    freopen(\"TASK.out\", \"w\", stdout);\n#else \n    \n#endif // LOCAL\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20); \n    cout << fixed; \n    int t = 1; \n    for (int i = 0; i < t; ++i) {              \n        solve();\n    }\n    return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cassert>\n#include<stdexcept>\n#include<utility>\n#include<functional>\n#include<numeric>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<array>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<complex>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<bitset>\n#include<memory>\nusing namespace std;\nusing ll=long long;\n\nconst int SZ = 8;\nint n;\nint pow3n;\nvector<int> sal;\nvoid init_s(){\n    sal.resize(pow3n);\n    iota(sal.begin(),sal.end(),0);\n    for(int i=0;i<pow3n;i++){\n        int x = i;\n        int tar = 0;\n        int r = 1;\n        for(int j=0;j<n;j++){\n            tar+= (x%3*2)%3*r;\n            x/=3;\n            r*=3;\n        }\n        if(tar<i){\n            // cerr<<i<<\" \"<<tar<<endl;\n            swap(sal[tar],sal[i]);\n        }\n    }\n}\n\nint ary[1000000];\nvoid do_rx(vector<int>& pat,int t){\n    t = t%pow3n;\n    for(int i=t;i<pow3n;i++) ary[i] = pat[i-t];\n    for(int i=0;i<t;i++) ary[i] = pat[pow3n-t+i];\n    for(int i=0;i<pow3n;i++) pat[i] = ary[i];\n}\n\nvoid do_r(vector<int>& pat){\n    int head = pat[pow3n-1];\n    for(int i=pow3n-1;i>0;i--){\n        pat[i]=pat[i-1];\n    }\n    pat[0] = head;\n}\n\nvoid perm(vector<int>& pat,vector<int>& par){\n    for(int i=0;i<pow3n;i++) ary[i] = pat[par[i]];\n    for(int i=0;i<pow3n;i++) pat[i] = ary[i];\n}\nvoid do_s(vector<int>& pat){\n    perm(pat,sal);\n}\nint main(){\n    cin>>n;\n    pow3n=1;\n    for(int i=0;i<n;i++) pow3n*=3;\n    init_s();\n    \n    string t;\n    {\n        string tmp;\n        cin>>tmp;\n        for(auto c:tmp){\n            if(!t.empty() && t.back()=='S' && c=='S') t.pop_back();\n            else t+=c;\n        }\n    }\n\n    vector<vector<int>> memo(1<<SZ);\n    \n    for(int bit=0;bit<(1<<SZ);bit++){\n        bool ispass= false;\n        for(int j=0;j+1<SZ;j++){\n            if(((bit>>j)&1)==0 && ((bit>>(j+1)))==0) ispass=true;\n        }\n        if(ispass) continue;\n\n        memo[bit].resize(pow3n);\n        iota(memo[bit].begin(),memo[bit].end(),0);\n        for(int j=0;j<SZ;j++){\n            if(((bit>>j)&1)==0) do_s(memo[bit]);\n            else do_r(memo[bit]);\n        }\n    }\n    vector<int> res(pow3n);\n    iota(res.begin(),res.end(),0);\n    int l = 0;\n    while(t.size()-l>=SZ){\n        int r;\n        for(r=l;r<t.size();r++){\n            if(t[r]=='S') break;\n        }\n        if(r-l>=SZ){\n            do_rx(res,r-l);\n            l=r;\n        }\n        else{\n            int bit = 0;\n            for(int j=0;j<SZ;j++){\n                if(t[l+j]=='R') bit+=(1<<j);\n            }\n            perm(res,memo[bit]);\n            bit=0;\n            l+=SZ;\n        }\n    }\n\n    for(int i=l;i<t.size();i++){\n        // cerr<<\"#\"<<endl;\n        if(t[i]=='S') do_s(res);\n        else do_r(res);\n    }\n    vector<int> inv(pow3n);\n    for(int i=0;i<pow3n;i++) inv[res[i]]=i;\n    for(int i=0;i<pow3n;i++) cout<<inv[i]<<\" \";\n    cout<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int T=2*1e5+10;\nconst int M=2*1e5;\nint a[T];\nint cnt;\nll poww(int a,int b){\n    ll ans=1,base=a;\n    while(b!=0){\n        if(b&1!=0)\n          ans*=base;\n        base*=base;\n        b>>=1;\n  }\n    return ans;\n}\nint b[1000];\nvoid cha3(ll x,int n){\n\tfor (int i=1;i<=n;i++)b[i]=0;\n\tint i=0;\n\twhile (x){\n\t\tb[++i]=x%3;\n\t\tx/=3;\n\t}\n}\nvoid ops(int n){\n\tfor (int i=1;i<=n;i++){\n\t\tif (b[i]==1)b[i]=2;\n\t\telse if (b[i]==2)b[i]=1;\n\t}\n}\nvoid jingwei(int i){\n\twhile (b[i]>=3){\n\t\tb[i+1]+=b[i]/3;\n\t\tb[i]%=3;\n\t\ti++;\n\t}\n}\nint main(){\n//\tfreopen(\"ab1.txt\",\"r\",stdin);\n//\tfreopen(\"ab.txt\",\"w\",stdout);\n//\twhile (1){\n//\t\tint x;\n//\t\tcin>>x;\n//\t\tcha3(x,3);\n//\t\tcin>>x;\n//\t\tb[1]+=x;\n//\t\tjingwei(1);\n//\t\tfor (int i=4;i>=1;i--)cout<<b[i];\n//\t\tcout<<endl;\n//\t}\n\tstring s;\n\tint n;\n\tcin>>n>>s;\n\tfor (int i=0;i<s.size();i++){\n\t\tint ans=1;\n\t\tchar c=s[i];\n\t\twhile (i+ans<s.size() and s[i+ans]==c)ans++;\n\t\tif (c=='S'){\n\t\t\tif (ans%2){\n\t\t\t\ta[++cnt]=M+1;\n\t\t\t}\n\t\t}else{\n\t\t\ta[++cnt]=ans;\n\t\t}\n\t\ti=i+ans-1;\n\t}\n\tll end=poww(3,n);\n\tfor (ll i=0;i<end;i++){\n\t\tcha3(i,n);\n\t\tll ans=0;\n\t\tfor (int i=1;i<=cnt;i++){\n\t\t\tif (a[i]>M)ops(n);\n\t\t\telse{\n\t\t\t\tb[1]+=a[i];\n\t\t\t\tjingwei(1);\n\t\t\t}\n\t\t}\n\t\tll base=1;\n\t\tfor (int i=1;i<=n;i++){\n\t\t\tans+=b[i]*base;\n\t\t\tbase*=3;\n\t\t}\n\t\tprintf(\"%lld \",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAX_N=5+1e6;\nint pw[25];\nstruct RevOp{\n\tint d[MAX_N];\n\tbool flag;\n\tvoid init(int n){\n\t\tflag=0;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tfor(int j=pw[i];j<pw[i]*2;++j)\n\t\t\t\td[j]=1;\n\t\t\tfor(int j=pw[i]*2;j<pw[i+1];++j)\n\t\t\t\td[j]=2;\n\t\t}\n\t}\n\tint operator[](int x){ return flag?(d[x]==0?0:3-d[x]):d[x]; }\n\tvoid add(int x){ \n\t\tif(!flag){\n\t\t\td[x]++; \n\t\t\tif(d[x]>=3) d[x]-=3; \n\t\t}else{\n\t\t\td[x]--;\n\t\t\tif(d[x]<0) d[x]+=3;\n\t\t}\n\t}\n\tvoid rev(){ flag^=1; }\n}d;\n\ninline void mo(int& x){x>=3?x-=3:0;}\nint gbit(int x,int i){ return x/pw[i]%3; }\nint gbit2(int x,int i){\n\tif(gbit(x,i)!=0) return d[x%pw[i+1]];\n\tint y=x%pw[i];\n\treturn 3-d[y+pw[i]]-d[y+pw[i]*2];\n}\nvoid print(int n){\n\tfor(int x=0;x<pw[n];++x){\n\t\tint ret=0;\n\t\tfor(int i=0;i<n;++i)\n\t\t\tret+=gbit2(x,i)*pw[i];\n\t\tprintf(\"%d \",ret);\n\t}\n\tputs(\"\");\n}\nint main(){\n\tstring s;\n\tint n,T; scanf(\"%d\",&n); cin>>s;\n\tpw[0]=1; for(int i=1;i<=n;++i) pw[i]=pw[i-1]*3;\n\td.init(n);\n//\tfor(int j=0;j<pw[n];++j) printf(\"|%d|\",d[j]);\n//\tprint(n);\n\tfor(int i=0;i<s.length();++i)\n\t\tif(s[i]=='S'){\n\t\t\td.rev();\n\t\t}else{\n\t\t\tint x=0;\n\t\t\tfor(int t=0;t<n;++t){\n\t\t\t\td.add(x+pw[t]);\n\t\t\t\td.add(x+pw[t]*2);\n\t\t\t\tif(gbit2(x,t)==0) x+=0;\n\t\t\t\telse if(gbit2(x+pw[t],t)==0) x+=pw[t];\n\t\t\t\telse if(gbit2(x+pw[t]*2,t)==0) x+=pw[t]*2;\n\t\t\t}\n\t\t}\n\tprint(n);\n\treturn 0;\n}\n\t\n\t\t\t\t\t\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nint lim=1,f[600001],n,nl,top,fin[1000001];\nchar T[1000001],ope[1000001];\nvoid write(int x){\n\tif(x>9)write(x/10);\n\tputchar((x%10)+'0');\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tint v1=1,v2=1;\n\tfor(int i=1;i<=n;i++)lim*=3;\n\tfor(int i=1;i<=(n>>1);i++)v1*=3;\n\tfor(int i=1+(n>>1);i<=n;i++)v2*=3;\n\tfor(int i=0;i<lim;i++)f[i]=f[i/3]*3+(3-i%3)%3;\n\tscanf(\"%s\",T+1);\n\tnl=strlen(T+1);\n\tfor(int i=0;i<v1;i++){\n\t\tint tem=i;\n\t\ttop=0;\n\t\tfor(int j=1;j<=nl;j++)\n\t\t\tif(T[j]=='S'){\n\t\t\t\ttem=f[tem];\n\t\t\t\t(ope[top]=='S')?--top:ope[++top]='S';\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(tem+1==v1)ope[++top]='R';\n\t\t\t\t(++tem)%=v1;\n\t\t\t}\n\t\tfor(int j=0;j<v2;j++){\n\t\t\tint tem2=j;\n\t\t\tfor(int k=1;k<=top;k++)\n\t\t\t\tif(ope[k]=='S')tem2=f[tem2];\n\t\t\t\telse if(ope[k]=='R')(++tem2)%=v2;\n\t\t\tfin[i+j*v1]=tem2*v1+tem;\n\t\t}\n\t}\n\tfor(int i=0;i<lim;i++)write(fin[i]),putchar(' ');\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <chrono>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <istream>\n#include <map>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#define endl '\\n'\n\nusing namespace std;\n\nvoid push(vector<int> &seq, bool command)\n{\n    if (command)\n    {\n        if (!seq.empty() && seq.back())\n            seq.pop_back();\n        else\n            seq.push_back(command);\n    }\n    else\n    {\n        seq.push_back(command);\n    }\n}\n\nvoid rec(int start, int jump, int size, vector<int> sequence, vector<int> &res)\n{\n    if (jump == res.size())\n    {\n        return;\n    }\n\n    vector<vector<int>> new_seq(3);\n    vector<int> digit = {0, 1, 2};\n\n    for (auto command : sequence)\n    {\n        if (command)\n        {\n            for (int i = 0; i < 3; ++i)\n            {\n                push(new_seq[i], command);\n                if (digit[i])\n                    digit[i] = 3 - digit[i];\n            }\n        }\n        else\n        {\n            for (int i = 0; i < 3; ++i)\n            {\n                digit[i]++;\n\n                if (digit[i] == 3)\n                {\n                    digit[i] = 0;\n                    push(new_seq[i], command);\n                }\n            }\n        }\n    }\n\n    int finish = start + size * jump;\n    int ix = 0;\n\n    for (int i = start; i < finish; i += jump)\n    {\n        res[i] += digit[ix] * jump;\n        if (++ix == 3)\n            ix = 0;\n    }\n\n    for (int i = 0; i < 3; ++i)\n    {\n        rec(start + jump * i, jump * 3, size / 3, new_seq[i], res);\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n\n    string s;\n    cin >> s;\n\n    vector<int> sequence;\n\n    for (auto x : s)\n        push(sequence, x == 'S');\n\n    int size = 1;\n    for (int i = 0; i < n; ++i)\n    {\n        size *= 3;\n    }\n\n    vector<int> res(size);\n\n    rec(0, 1, size, sequence, res);\n\n    for (auto x : res)\n    {\n        cout << x << \" \";\n    }\n\n    cout << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nint main(){\n    int n;\n    std::string t;\n    std::cin>>n>>t;\n    int temp=1;\n    for(int i=0;i<n;++i){\n        temp*=3;\n    }\n    const int num=temp;\n    int c[num][12];\n    for(int i=0;i<num;++i){\n        for(int j=11;j>=12-n;--j){\n            c[i][j]=0;\n        }\n    }\n    for(int i=1;i<num;++i){\n        for(int j=0;j<12;++j){\n            c[i][j]=c[i-1][j];\n        }\n        c[i][11]++;\n        int j=11;\n        while(c[i][j]>=3){\n            c[i][j]-=3;\n            j--;\n            c[i][j]++;\n        }\n    }\n    for(int i=0;i<t.size();++i){\n        if(t[i]=='S'){\n            for(int j=0;j<num;++j){\n                for(int k=11;k>=12-n;--k){\n                    c[j][k]=(c[j][k]*2)%3;\n                }\n            }\n        }\n        else{\n            for(int j=0;j<num;++j){\n                c[j][11]++;\n                int k=11;\n                while(c[j][k]>=3){\n                    c[j][k]-=3;\n                    k--;\n                    c[j][k]++;\n                }\n            }\n        }\n    }\n    int ans[num];\n    for(int i=0;i<num;++i){\n        ans[i]=0;\n        for(int j=12-n;j<12;++j){\n            ans[i]=ans[i]*3+c[i][j];\n        }\n    }\n    std::cout<<ans[0];\n    for(int i=1;i<num;++i){\n        std::cout<<\" \"<<ans[i];\n    }\n    std::cout<<std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\ntypedef unsigned u32;\ntypedef long long s64;\ntypedef unsigned long long u64;\ntemplate<class T1, class T2> inline bool cmin(T1 &a, const T2 &b) {return b<a?(a=b, true):false;}\ntemplate<class T1, class T2> inline bool cmax(T1 &a, const T2 &b) {return a<b?(a=b, true):false;}\ntemplate<class Type> Type read() {\n\tType a;\n\tbool b;\n\tunsigned char c;\n\twhile(c=getchar()-48, (c>9)&(c!=253));\n\tfor(a=(b=c==253)?0:c; (c=getchar()-48)<=9; a=a*10+c);\n\treturn b?-a:a;\n}\nint (*rd)()=read<int>;\n//const u32 P=;\n//inline u32 &inc(u32 &a, u32 b) {return (a+=b)<P?a:(a-=P);}\n//inline u32 &dec(u32 &a, u32 b) {return (a-=b)&0x80000000?(a+=P):a;}\n//inline u32 sum(u32 a, u32 b) {return (a+=b)<P?a:a-P;}\n//inline u32 dif(u32 a, u32 b) {return (a-=b)&0x80000000?a+P:a;}\n//u64 power(u64 a, int b) {\n//\tu64 ans=1;\n//\tfor(; b; a=a*a%P, b/=2) if(b&1) ans=ans*a%P;\n//\treturn ans;\n//}\n\nconst int N=2e5+1;\nint n, carry[N], pw[13], tmp[531441], ans[531441], add[531441];\nchar t[N];\nint main() {\n\tscanf(\"%d%s\", &n, t);\n\tint m=strlen(t);\n\tpw[0]=1;\n\tfor(int i=1; i<=n; ++i) pw[i]=pw[i-1]*3;\n\tfor(int i=0; i<n; ++i) {\n\t\tint flip=0;\n\t\tmemset(add, 0, pw[i]*sizeof(int));\n\t\tfor(int j=0; j<m; ++j) {\n\t\t\tif(t[j]=='S') {\n\t\t\t\tflip^=1;\n\t\t\t} else {\n\t\t\t\tint x=carry[j];\n\t\t\t\tadd[x]=(add[x]+(flip?2:1))%3;\n\t\t\t\tcarry[j]+=(3-add[x])%3*pw[i];\n\t\t\t}\n\t\t}\n\t\tmemcpy(tmp, ans, pw[i]*sizeof(int));\n\t\tfor(int c=0; c<3; ++c) {\n\t\t\tfor(int j=0; j<pw[i]; ++j)\n\t\t\t\tans[c*pw[i]+j]=tmp[j]+(flip?2:1)*(c+add[j])%3*pw[i];\n\t\t}\n\t}\n\tfor(int i=0; i<pw[n]; ++i) printf(\"%d \", ans[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string>\n#include<cmath>\n\nusing namespace std;\n\nint fast_pow(int a, int b)\n{\n\tint ret(1);\n\tfor (int p(a); b; p *= p, b /= 2)\n\t\tif (b%2)\n\t\t\tret *= p;\n\treturn ret;\n}\n\nint main(){\n    int N,p,size,len,tmp1,tmp2,cou=3,sw;\n    string T;\n    cin >> N;\n    cin >> T;\n    size = fast_pow(3,N);\n    vector<int> table(size);\n    len = T.length();\n    table[0] = 0;\n    for(int i=1;i<size;i++){\n        if(i % 3 == 0){\n            if(i == cou){\n                sw = 1;\n                table[i] = cou * 2;\n                tmp1 = cou;\n                tmp2 = cou*2;\n                cou *= 3;\n            }else if(i == tmp2){\n                table[i] = tmp1;\n                sw = 2;\n            }else{\n                if(sw == 1){\n                    table[i] = table[i-tmp1] + tmp2;\n                }else{\n                    table[i] = table[i-tmp2] + tmp1;\n                }\n            }\n        }else if(i % 3 == 1){\n            table[i] = table[i-1] + 2;\n        }else{\n            table[i] = table[i-1] - 1;\n        }\n    }\n    //for(int i=0;i<size;i++) cout << i << ' ' <<table[i] << endl;;\n\n    for(int i=0;i<size;i++){\n        p=i;\n        for(int j=0;j<len;j++){\n            if(T[j] == 'S'){\n                if(T[j+1] == 'S') j++;\n                else p = table[p];\n            }else{\n                p++;\n                if(p==size) p=0;\n            }\n        }\n        cout << p << ' ';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n\n#define putchar_unlocked putchar\n\nchar T[524288];\n\n// Based on editorial solution\nint D[13][550005]; // one digit at a time, with digit 0 representing the ones place\nint W[13][550005];\nint lastUpdated[13][550005];\n\nint x[11];\ninline void putInt(int i){\n    if(i==0){putchar_unlocked('0');}\n    else{\n    int count1=0;\n    while(i>0){\n        x[count1++]=i%10;\n        i/=10;\n    }\n    for(int j=count1-1;j>=0;j--){\n        putchar_unlocked(48+x[j]);\n    }\n    }\n    putchar_unlocked(' ');\n}\n\nint N;\n\ninline void update(int n, int indx, int cntS){\n    if( ((cntS&1) != (lastUpdated[n][indx]&1)) && D[n][indx]){\n        // conduct salsa\n        D[n][indx] = 3-D[n][indx];\n    }\n    // update the lastUpdated index\n    lastUpdated[n][indx] = cntS;\n}\n\nint pow3[16];\n\nint main(){\n    scanf(\"%d\", &N);\n    scanf(\" %s\", T);\n\n    int M = strlen(T);\n\n    pow3[0] = 1;\n    for(int i = 1; i <= N; i ++){\n        pow3[i] = pow3[i-1]*3;\n    }\n\n    memset(W, 0, sizeof(W));\n    for(int n = 1; n <= N; n ++){\n        //printf(\"ok\");\n        for(int j = 0; j < pow3[n-1]; j ++){\n            D[n][j] = 0;\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        for(int j = pow3[n-1]; j < (pow3[n-1]<<1); j ++){\n            D[n][j] = 1;\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        for(int j = (pow3[n-1]<<1); j < pow3[n]; j ++){\n            D[n][j] = 2;\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        W[n][0] = pow3[n]-1;\n    }\n\n\n    memset(lastUpdated, 0, sizeof(lastUpdated));\n    int cntS2 = 0;\n    for(int n = 1; n <= N; n ++){\n        int cntS = 0;\n        for(int i = 0; i < M; i ++){\n            int indx0 = W[n-1][i];\n            int indx1 = W[n-1][i]+pow3[n-1];\n            int indx2 = W[n-1][i]+(pow3[n-1]<<1);\n\n            if(indx1 >= pow3[n]){indx1 -= pow3[n];}\n            if(indx2 >= pow3[n]){indx2 -= pow3[n];}\n\n            update(n, indx0, cntS+(T[i]=='S'));\n            update(n, indx1, cntS+(T[i]=='S'));\n            update(n, indx2, cntS+(T[i]=='S'));\n            if(D[n][indx0] == 2){\n                W[n][i] = indx0;\n            }else if(D[n][indx1] == 2){\n                W[n][i] = indx1;\n            }else{\n                W[n][i] = indx2;\n            }\n\n            if(T[i] == 'R'){\n                D[n][indx0] = (D[n][indx0]+1);\n                D[n][indx1] = (D[n][indx1]+1);\n                D[n][indx2] = (D[n][indx2]+1);\n                if(D[n][indx0] == 3){D[n][indx0] = 0;}\n                if(D[n][indx1] == 3){D[n][indx1] = 0;}\n                if(D[n][indx2] == 3){D[n][indx2] = 0;}\n                lastUpdated[n][indx0] = cntS;\n                lastUpdated[n][indx1] = cntS;\n                lastUpdated[n][indx2] = cntS;\n            }else if(T[i] == 'S'){\n                cntS ++;\n            }\n\n            //printf(\"W[%d][%d]=%d\\n\", n, i+1, W[n][i+1]);\n        }\n\n        cntS2 = cntS;\n    }\n\n    for(int n = 1; n <= N; n ++){\n        for(int i = 0; i < pow3[n]; i ++){\n            update(n, i, cntS2);\n        }\n    }\n\n    for(int i = 0; i < pow3[N]; i ++){\n        int temp = 0;\n        for(int n = 1; n <= N; n ++){\n            temp += D[n][i%pow3[n]]*pow3[n-1];\n        }\n        putInt(temp);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#define int long long\n\n#define pii pair<int, int>\n\n#define x1 x1228\n#define y1 y1228\n\n#define left left228\n#define right right228\n\n#define next next228\n\n#define pb push_back\n#define eb emplace_back\n\n#define mp make_pair                                                                \n                                                                                                                                        \n#define ff first                                                                  \n#define ss second   \n\n#define all(x) x.begin(), x.end()\n#define debug(x) cout << #x << \": \" << x << endl; \n#define TIME (ld)clock()/CLOCKS_PER_SEC\n\nusing namespace std;\ntypedef long long ll; \ntypedef long double ld; \n                                                                                                   \nconst int maxn = 2e5 + 7, mod = 1e9 + 7, MAXN = 1e6 + 7;\nconst double eps = 1e-9;\nconst ll inf = 1e18;\nmt19937 rnd(time(0));\nint n; \nstring s; \nint next[MAXN];\nconst int N = 2187; \nint dp1[N]; \nint dp2[N]; \nint xyz[N]; \n\nint get1(int mask, char q) {\n    if (q == 'R') {\n        ++mask; \n        return mask; \n    }   \n    int ptr = 1; \n    int ans = 0; \n    while (mask) {\n        int t = mask % 3; \n        mask /= 3; \n        if (t == 2) ans += ptr; \n        if (t == 1) ans += 2 * ptr; \n        ptr *= 3; \n    }\n    return ans; \n}\n\nconst int L = 12; \nint pref[maxn]; \nint to[maxn]; \nint kek1[N], kek2[N]; \nint res[N], res1[N]; \nint add = 1; \n\nint get(int x) {\n    vector<int> bts; \n    for (int i = 0; i < L; ++i) {\n        bts.pb(x % 3); \n        x /= 3; \n    }\n    int left = 0;\n    int right = 0; \n    for (int i = 6; i >= 0; --i) {\n        left *= 3;\n        left += bts[i]; \n    }\n    for (int i = L - 1; i >= 7; --i) {\n        right *= 3; \n        right += bts[i]; \n    }\n    int id = 0; \n    if (left && dp1[left] == -1) {\n        return res[left] + add * right;   \n    }\n    if (left) {    \n        id = dp1[left]; \n        if (pref[id] & 1) right = xyz[right];             \n        left = 0; \n    }                     \n    while (next[id] != -1) {        \n        if ((pref[next[id]] - pref[id]) & 1) right = xyz[right]; \n        id = next[id];                                                                                                                                         \n    }\n    left = to[id]; \n    return left + right * add; \n}\n\nvoid solve() {\n    for (int i = 0; i < N; ++i) {\n        xyz[i] = get1(i, 'S') % N; \n    }\n    cin >> n >> s; \n    int t = s.size(); \n    for (int i = 0; i < t; ++i) {\n        pref[i + 1] = pref[i] + (s[i] == 'S'); \n    }\n    for (int i = 0; i < N; ++i) dp1[i] = dp2[i] = -1; \n    next[t] = -1;\n    for (int i = 0; i < N; ++i) kek1[i] = res[i] = i;              \n    for (int i = t - 1; i >= 0; --i) {\n        for (int mask = 0; mask < N; ++mask) {\n            int mask1; \n            if (s[i] == 'S') mask1 = xyz[mask]; \n            else mask1 = mask + 1; \n            if (mask1 == N) mask1 = 0; \n            res1[mask] = res[mask1]; \n            kek2[mask] = kek1[mask1];\n            if (mask && mask1 == 0) {\n                dp2[mask] = i + 1; \n            } else {\n                dp2[mask] = dp1[mask1]; \n            }   \n        }\n        to[i] = kek2[0]; \n        next[i] = dp2[0]; \n        for (int mask = 0; mask < N; ++mask) {\n            res[mask] = res1[mask]; \n            kek1[mask] = kek2[mask]; \n            dp1[mask] = dp2[mask]; \n            dp2[mask] = -1; \n        }\n    }\n    for (int i = 0; i < 7; ++i) add *= 3; \n    int tet = 1; \n    for (int i = 0; i < n; ++i) tet *= 3; \n    for (int ptr = 0; ptr < tet; ++ptr) {\n//        get(ptr); \n        cout << get(ptr) % tet << \" \"; \n    }\n//    cout << TIME; \n    return; \n}                                \n   \nsigned main() {\n#ifdef LOCAL\n    freopen(\"TASK.in\", \"r\", stdin);\n    freopen(\"TASK.out\", \"w\", stdout);\n#else \n    \n#endif // LOCAL\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20); \n    cout << fixed; \n    int t = 1; \n    for (int i = 0; i < t; ++i) {              \n        solve();\n    }\n    return 0;\n}  \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\nint a[1000005];\nint p[1000005]={0};\nint vis[1000005]={0};\nint ans[1000005];\nvoid pre(int m){\n\ta[0]=0;\n\tfor(int i=1;i<=m;i++){\n\t\tp[i]=i;\n\t\tif(a[i]>0){\n\t\t\tcontinue;\n\t\t}\n\t\tint tempi=i;\n\t\tint bei=1;\n\t\tint tempj=0;\n\t\twhile(tempi>0){\n\t\t\tif(tempi%3!=0){\n\t\t\t\ttempj+=(3-tempi%3)*bei;\n\t\t\t}\n\t\t\ttempi/=3;\n\t\t\tbei*=3;\n\t\t}\n\t\ta[i]=tempj;\n\t\ta[tempj]=i;\n\t}\n\treturn;\n}\n\nint main()\n{\n\tint n;\n\tcin>>n;\n\tint nn=1;\n\tfor(int i=1;i<=n;i++){\n\t\tnn*=3;\n\t}\n\tpre(nn-1);\n\tstring t;\n\tcin>>t;\n\tint rem=0;\n\tint sum=1;\n\tint len=t.size();\n\tt.push_back('v');\n\tint temp=1;\n\tfor(int i=0;i<len;i++){\n\t\tif(t[i]==t[i+1]){\n\t\t\ttemp++;\n\t\t}\n\t\telse {\n\t\t\tif(t[i]=='S'){\n\t\t\t\tif(temp%2==1){\n\t\t\t\t\tmemset(vis,0,sizeof(vis));\n//\t\t\t\t\tcout<<\":\"<<rem<<endl;\n\t\t\t\t\tfor(int j=0;j<nn;j++){\n\t\t\t\t\t\tint x=(j+nn-rem)%nn;\n\t\t\t\t\t\tint y=(a[j]+nn-rem)%nn;\n\t\t\t\t\t\tif(vis[x]==1){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswap(p[x],p[y]);\n\t\t\t\t\t\tvis[x]=vis[y]=1;\n//\t\t\t\t\t\tcout<<j<<\" \"<<x<<\" \"<<y<<endl;\n\t\t\t\t\t}\n//\t\t\t\t\tcout<<endl;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\trem=(rem+temp)%nn;\n\t\t\t}\n\t\t\ttemp=1;\n\t\t}\n\t\t\n//\t\tfor(int k=0;k<nn;k++){\n//\t\tif(k>0){\n//\t\t\tcout<<\" \";\n//\t\t}\n//\t\tcout<<p[(k+nn-rem)%nn];\n//\t}\n//\tcout<<endl;\n\t\n\t}\n\tfor(int i=0;i<nn;i++){\n\t\tans[p[(i+nn-rem)%nn]]=i;\n\t}\n\tfor(int i=0;i<nn;i++){\n\t\tif(i>0){\n\t\t\tcout<<\" \";\n\t\t}\n\t\tcout<<ans[i];\n\t}\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 14;\nstring s; int n,pw[N];vector<char> w; vector<vector<char> > f,g; vector<int> h,p;\ninline int get(int x,int l){ return x % pw[l]; }\ninline void add(vector<char> &s,char c) {\n\tif (c == 'R') s.push_back(c);\n\telse if (s.size() && s[s.size()-1] == 'S') s.pop_back();\n\telse s.push_back(c);\n}\nint main(){\n\tint i;\n\tcin >> n >> s;\n\tfor (pw[0] = i = 1; i <= 12 ; ++i) pw[i] = pw[i-1]*3;\n\tfor (i = 0; i < s.size(); ++i) w.push_back(s[i]);\n\tf.push_back(w),h.push_back(0);\n    for (i = 1; i <= n; ++i){\n\t\tg.resize(pw[i]),p.resize(pw[i]);\n        for(int now = 0; now < pw[i] ; ++now) {\n\t\t\tint cur = get(now,i-1);\n\t\t\tp[now] = h[cur];\n\t\t\tint d = now/pw[i-1]%3;\n\t\t\tfor (auto v : f[cur]){\n\t\t\t\tif(v == 'S') d = (d<<1)%3,add(g[now],v);\n\t\t\t\telse if(d == 2) d = 0,add(g[now],v);\n\t\t\t\telse d += 1;\n\t\t\t}\n\t\t\tp[now] += d*pw[i-1];\n\t\t}\n\t\th.clear(),f.clear(),swap(f,g),swap(h,p);\n\t}\n\tfor (i = 0; i < pw[n]; ++i) cout << h[i] << ((i<pw[n]-1) ? (' ') : ('\\n'));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n// #include <ext/pb_ds/assoc_container.hpp> \n// #include <ext/pb_ds/detail/standard_policies.hpp>\n// using namespace __gnu_pbds;\n\n#pragma GCC optimize(\"O3\")\n#ifdef LOCAL\n#include \"/Users/lbjlc/Desktop/coding/debug_utils.h\"\n#else\n#define print(...) ;\n#define printn(...) ;\n#define fprint(...) ;\n#define fprintn(...) ;\n#endif\n\n#define rep(i, a, b) for(auto i = (a); i < (b); i++)\n#define rrep(i, a, b) for(auto i = (a); i > (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define pb push_back\n// #define mp make_pair\n#define fi first\n#define se second\n#define maxi(x, y) x = max(x, y)\n#define mini(x, y) x = min(x, y)\n// long long fact(long long n) { if(!n) return 1; return n*fact(n-1); }\n// #define endl '\\n'\n#define solve_testcase int T;cin>>T;for(int t=1;t<=T;t++){solve(t);}\n\n// long long gcd(long long x, long long y) { return y ? gcd(y, x % y) : x; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\n \ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n \ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\ntypedef vector<long long> vll;\n#define bd(type,op,val) bind(op<type>(), std::placeholders::_1, val)\n\nconst int MAXN = 1e6+10;\n\n\nvoid solve(int tt) {\n    // cout<<\"Case #\"<<tt<<\": \";\n}\n\nstring to_ter(int x, int k=-1) {\n    string res;\n    while(x) {\n        res+='0'+x%3;\n        x/=3;\n    }\n    if(k>=0) {\n        while(res.size()<k) res+='0';\n    }\n    return res;\n}\nint to_int(const string & s) {\n    int res=0;\n    // rrep(i,s.size()-1,-1)\n    //     res=res*3+(s[i]-'0');\n    for(int i=s.size()-1;i>=0;i--)\n        res=res*3+(s[i]-'0');\n    // print(s,res);\n    return res;\n}\nbool add(string & x, const string & y) {\n    int n1=x.size(), n2=y.size(),carry=0;\n    rep(i,0,n1) {\n        if(i<n1) carry+=x[i]-'0';\n        if(i<n2) carry+=y[i]-'0';\n        x[i]=carry%3+'0';\n        carry/=3;\n    }\n    return carry==0;\n}\n\nvi cal_inst(string & s) {\n    int n=s.size();\n    vi res(1);\n    int i=0;\n    while(i<n) {\n        if(s[i]=='R') {\n            res.back()++;\n            i++;\n        }\n        else {\n            int j=i;\n            for(;j<n&&s[j]=='S';j++);\n            if((j-i)%2) res.pb(0);\n            i=j;\n        }\n    }\n    if(s.back()=='S') res.pop_back();\n    return res;\n}\n\nchar rev(char c) {\n    if(c>'0') return '0'+(3-(c-'0'));\n    return c;\n}\nstring rev(string s) {\n    for(auto & c:s) c=rev(c);\n    return s;\n}\n\nint len(string & s) {\n    int res=s.size()-1;\n    while(res>=0&&s[res]=='0') res--;\n    return res+1;\n}\n\nint power[13]={};\nint revmap[MAXN]={};\nint tmpres[MAXN];\nint rev(int x) {\n    for(int flag=1;flag<power[12];flag*=3) {\n        int tmp=x/flag%3;\n        if(tmp==1) x+=flag;\n        else if(tmp==2) x-=flag;\n    }\n    return x;\n}\n\nvoid cal(vi inst, int n, int tot) {\n    // vi tmpres(tot,-1);\n    fill(tmpres,tmpres+tot,-1);\n\n    rep(i,0,tot) {\n        if(tmpres[i]>=0) continue;\n\n        int cur=i,ok=1;\n        for(auto x:inst) {\n            cur+=x;\n            if(cur>=power[n]) {\n                ok=0; \n                cur%=power[n];\n            }\n            cur=revmap[cur];\n        }\n        // if(i<=9) print(i,cur);\n        tmpres[i]=cur;\n        // assert(cur>=0);\n        if(!ok) continue;\n        int flag=1,tmp;\n        for(;flag<=i||flag<=cur;flag*=3);\n\n        if(inst.size()%2==0) {\n            for(tmp=flag;tmp<power[n];tmp+=flag) {\n                tmpres[tmp+i]=tmp+cur;\n            }\n        }\n        else {\n            for(tmp=flag;tmp<power[n];tmp+=flag) {\n                tmpres[tmp+i]=revmap[tmp]+cur;\n            }\n\n        }\n    }\n    // print(1);\n    // print(*max_element(all(res)),*min_element(all(res)));\n    // return res;\n}\n\nint main(int argc, char * argv[]) {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    // solve_testcase;\n\n    int n;\n    string s;\n    cin>>n;\n    cin>>s;\n\n    // n=12;\n    // rep(i,0,1e5) s+=\"RS\";\n\n    power[0]=1;\n    rep(i,1,13) power[i]=power[i-1]*3;\n    int tot=power[n];\n    rep(i,0,tot) revmap[i]=rev(i);\n    printn(revmap,9);\n\n    int ns=s.size();\n    vi last(ns+1),lastn(ns+1);\n    vi cur({0,1,2}),pre;\n\n    last[0]=cur[2];\n    rep(i,0,ns) {\n        if(s[i]=='R') rotate(cur.begin(),cur.begin()+2,cur.end());\n        // else for(auto & x:cur) x=revmap[x];\n        else swap(cur[1],cur[2]);\n        last[i+1]=cur[2];\n    }\n    lastn=last;\n    print(cur,last);\n\n    int flag=3;\n    rep(iteration,2,n+1) {\n        pre=cur;\n        cur.insert(cur.end(),all(pre));\n        cur.insert(cur.end(),all(pre));\n        flag*=3;\n        last=lastn;\n        lastn[0]=flag-1;\n\n        vvi tmp(flag/3,vi({0,1,2}));\n        vi pre_upd(flag/3);\n        int curt=0;\n        print(tmp);\n        rep(i,0,ns) {\n            if(s[i]=='R') {\n                int diff=(curt-pre_upd[last[i]])%2;\n                if(diff) swap(tmp[last[i]][1],tmp[last[i]][2]);\n                pre_upd[last[i]]=curt;\n                rotate(tmp[last[i]].begin(),tmp[last[i]].begin()+2,tmp[last[i]].end());\n            }\n            else curt++;\n\n            int diff=(curt-pre_upd[last[i+1]])%2;\n            if(diff) swap(tmp[last[i+1]][1],tmp[last[i+1]][2]);\n            pre_upd[last[i+1]]=curt;\n            lastn[i+1]=last[i+1]+flag/3*tmp[last[i+1]][2];\n            print(i,curt,pre_upd);\n            print(last,lastn);\n            print(tmp);\n        }\n        rep(i,0,flag/3) {\n            int diff=(curt-pre_upd[i])%2;\n            if(diff) swap(tmp[i][1],tmp[i][2]);\n            pre_upd[i]=curt;\n            // rotate(tmp[i].begin(),tmp[i].begin()+2,tmp[i].end());            \n        }\n        print(tmp);\n        rep(i,0,flag/3) {\n            cur[i]+=flag/3*tmp[pre[i]][0];\n            cur[i+flag/3]+=flag/3*tmp[pre[i]][1];\n            cur[i+flag/3*2]+=flag/3*tmp[pre[i]][2];\n        }\n    }\n    print(lastn,cur);\n\n    vi res(flag);\n    rep(i,0,flag) res[cur[i]]=i;\n\n    for(auto x:res) cout<<x<<' ';\n    cout<<endl;\n    \n\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define putchar_unlocked putchar\n\nchar T[550005];\n\n// Based on editorial solution\nint D[13][550005]; // one digit at a time, with digit 0 representing the ones place\nint W[13][550005];\nint lastUpdated[13][550005];\n\ninline void putInt(int i){\n    if(i==0){putchar_unlocked('0');}\n    else{\n    int x[11];\n    int count1=0;\n    while(i>0){\n        x[count1++]=i%10;\n        i/=10;\n    }\n    for(int j=count1-1;j>=0;j--){\n        putchar_unlocked(48+x[j]);\n    }\n    }\n    putchar_unlocked(' ');\n}\n\nint N;\n\ninline void update(int n, int indx, int cntS){\n    if( ((cntS&1) != (lastUpdated[n][indx]&1)) && D[n][indx]){\n        // conduct salsa\n        D[n][indx] = 3-D[n][indx];\n    }\n    // update the lastUpdated index\n    lastUpdated[n][indx] = cntS;\n}\n\nint pow3[16];\n\nint main(){\n    scanf(\"%d\", &N);\n\n    scanf(\" %s\", T);\n\n    int M = strlen(T);\n\n    pow3[0] = 1;\n    for(int i = 1; i <= N; i ++){\n        pow3[i] = pow3[i-1]*3;\n    }\n\n    int pow3N = pow3[N];\n\n    //printf(\"ok\");\n    memset(W, 0, sizeof(W));\n    for(int n = 1; n <= N; n ++){\n        //printf(\"ok\");\n        for(int j = 0; j < pow3[n-1]; j ++){\n            D[n][j] = 0;\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        for(int j = pow3[n-1]; j < 2*pow3[n-1]; j ++){\n            D[n][j] = 1;\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        for(int j = 2*pow3[n-1]; j < pow3[n]; j ++){\n            D[n][j] = 2;\n            //printf(\"D[%d][%d]=%d\\n\", n, j, D[n][j]);\n        }\n        W[n][0] = pow3[n]-1;\n    }\n\n\n    memset(lastUpdated, 0, sizeof(lastUpdated));\n    int cntS2 = 0;\n    for(int n = 1; n <= N; n ++){\n        int cntS = 0;\n        for(int i = 0; i < M; i ++){\n            int indx0 = W[n-1][i];\n            int indx1 = W[n-1][i]+pow3[n-1];\n            int indx2 = W[n-1][i]+(pow3[n-1]<<1);\n\n            if(indx1 >= pow3[n]){indx1 -= pow3[n];}\n            if(indx2 >= pow3[n]){indx2 -= pow3[n];}\n\n            update(n, indx0, cntS+(T[i]=='S'));\n            update(n, indx1, cntS+(T[i]=='S'));\n            update(n, indx2, cntS+(T[i]=='S'));\n            if(D[n][indx0] == 2){\n                W[n][i] = indx0;\n            }else if(D[n][indx1] == 2){\n                W[n][i] = indx1;\n            }else{\n                W[n][i] = indx2;\n            }\n\n            if(T[i] == 'R'){\n                D[n][indx0] = (D[n][indx0]+1);\n                D[n][indx1] = (D[n][indx1]+1);\n                D[n][indx2] = (D[n][indx2]+1);\n                if(D[n][indx0] == 3){D[n][indx0] = 0;}\n                if(D[n][indx1] == 3){D[n][indx1] = 0;}\n                if(D[n][indx2] == 3){D[n][indx2] = 0;}\n                lastUpdated[n][indx0] = cntS;\n                lastUpdated[n][indx1] = cntS;\n                lastUpdated[n][indx2] = cntS;\n            }else if(T[i] == 'S'){\n                cntS ++;\n            }\n\n            //printf(\"W[%d][%d]=%d\\n\", n, i+1, W[n][i+1]);\n        }\n\n        cntS2 = cntS;\n    }\n\n    for(int n = 1; n <= N; n ++){\n        for(int i = 0; i < pow3[n]; i ++){\n            update(n, i, cntS2);\n        }\n    }\n\n    for(int i = 0; i < pow3[N]; i ++){\n        int temp = 0;\n        for(int n = 1; n <= N; n ++){\n            temp += D[n][i%pow3[n]]*pow3[n-1];\n        }\n        putInt(temp);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nclass CStrangeDance {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n; cin >> n;\n      string t; cin >> t;\n\n      // initialize vector size\n      vector<vector<vector<int>>> v(3, vector<vector<int>>(n));\n      int k = 1;\n      rep(i, n) {\n        rep(j, 3) {\n          v[j][i].resize(k);\n        }\n        k *= 3;\n      }\n      int K = k;\n\n      // initialize vector\n      rep(i, n) {\n        int idx = 0;\n        rep(j, 3) {\n          for(auto& e: v[j][i]) {\n            e = idx;\n            idx++;\n          }\n        }\n      }\n\n      for(auto c: t) {\n        if (c=='S') {\n          // swap vector\n          swap(v[1], v[2]);\n        } else {\n          // swap by point\n          int w = 0;\n          rep(i, n) {\n            auto v0 = v[0][i][w];\n            auto v1 = v[1][i][w];\n            auto v2 = v[2][i][w];\n            v[1][i][w] = v0;\n            v[2][i][w] = v1;\n            v[0][i][w] = v2;\n            w = v2;\n          }\n        }\n      }\n\n      // recover\n      vector<int> ans(K);\n      k = 1;\n      rep(i, n) {\n        for(int j=1; j<=2; j++) {\n          for(auto e: v[j][i]) {\n            for(int idx=e; idx<K; idx+=(k*3)) {\n              ans[idx] += j*k;\n            }\n          }\n        }\n        k *= 3;\n      }\n\n      for(auto e: ans) {\n        cout << e << ' ';\n      }\n    }\n};\n\nsigned main() {\n  CStrangeDance solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define snd second\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef long double ldb;\n\ntemplate<class T> inline void checkmin(T &a,const T &b){if(b<a) a=b;}\ntemplate<class T> inline void checkmax(T &a,const T &b){if(b>a) a=b;}\n\nconst int inf=1e9+10;\nconst int maxn=1e6+10;\n\nint a[maxn*3][3],d[maxn*3],id[maxn*3],ans[maxn];\nint n,p[15];\nstring s;\n\nvoid build(int c,int x,int pos){\n\tif(c==n){\n\t//\tcout<<x<<\" \"<<pos<<endl;\n\t\tid[x]=pos;\n\t\treturn;\n\t}\n\tfor(int i=0;i<3;i++){\n\t\ta[x][i]=x*3+i;\n\t\tbuild(c+1,x*3+i,pos+i*p[c]);\n\t}\n}\n\nvoid apply(int x){\n\td[x]=!d[x];\n\tswap(a[x][1],a[x][2]);\n//\tcout<<a[x][1]<<\" \"<<a[x][2]<<endl;\n}\n\nvoid update(int x){\n\tif(d[x]==false) return;\n\td[x]=false;\n\tfor(int i=0;i<3;i++) apply(a[x][i]);\n}\n\nvoid add(int c,int x){\n\tif(c==n){\n\t\treturn;\n\t} \n\telse{\n\t\tupdate(x);\n\t\tswap(a[x][1],a[x][2]);\n\t\tswap(a[x][0],a[x][1]);\n\t\tadd(c+1,a[x][0]);\n\t}\n}\n\nvoid dfs(int c,int x,int pos) {\n\tif(c==n){\n\t\tans[id[x]]=pos;\n\t} \n\telse{\n\t\tupdate(x);\n\t\tfor(int i=0;i<3;i++){\n\t\t\tdfs(c+1,a[x][i],pos+i*p[c]);\n\t\t}\n\t}\n}\n\nint main(){\n\tp[0]=1;\n\tfor(int i=1;i<15;i++) p[i]=p[i-1]*3;\n\tcin>>n>>s;\n\tint n2=n;\n\tbuild(0,1,0);\n\tfor(int i=0;i<s.size();i++){\n\t\tif(s[i]=='S'){\n\t\t\tapply(1);\n\t\t//\tcout<<i<<endl;\n\t\t}\n\t\telse{\n\t\t\tadd(0,1);\n\t\t}\n\t//\tdfs(0,1,0);\n\t//\tfor(int i=0;i<3;i++) cout<<ans[i]<<\" \"; cout<<endl;\n\t}\n\tdfs(0,1,0);\n\tn=1;\n\tfor(int i=0;i<n2;i++) n=n*3;\n\tfor(int i=0;i<n;i++) cout<<ans[i]<<\" \";\n\tcout<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n// #include <ext/pb_ds/assoc_container.hpp> \n// #include <ext/pb_ds/detail/standard_policies.hpp>\n// using namespace __gnu_pbds;\n\n#pragma GCC optimize(\"O3\")\n#ifdef LOCAL\n#include \"/Users/lbjlc/Desktop/coding/debug_utils.h\"\n#else\n#define print(...) ;\n#define printn(...) ;\n#define fprint(...) ;\n#define fprintn(...) ;\n#endif\n\n#define rep(i, a, b) for(auto i = (a); i < (b); i++)\n#define rrep(i, a, b) for(auto i = (a); i > (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define pb push_back\n// #define mp make_pair\n#define fi first\n#define se second\n#define maxi(x, y) x = max(x, y)\n#define mini(x, y) x = min(x, y)\n// long long fact(long long n) { if(!n) return 1; return n*fact(n-1); }\n// #define endl '\\n'\n#define solve_testcase int T;cin>>T;for(int t=1;t<=T;t++){solve(t);}\n\n// long long gcd(long long x, long long y) { return y ? gcd(y, x % y) : x; }\n\ntypedef unsigned long long ull;\ntypedef long long ll;\n \ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n \ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<pdd> vpdd;\ntypedef vector<long long> vll;\n#define bd(type,op,val) bind(op<type>(), std::placeholders::_1, val)\n\nconst int MAXN = 1e6+10;\n\n\nvoid solve(int tt) {\n    // cout<<\"Case #\"<<tt<<\": \";\n}\n\nstring to_ter(int x, int k=-1) {\n    string res;\n    while(x) {\n        res+='0'+x%3;\n        x/=3;\n    }\n    if(k>=0) {\n        while(res.size()<k) res+='0';\n    }\n    return res;\n}\nint to_int(const string & s) {\n    int res=0;\n    // rrep(i,s.size()-1,-1)\n    //     res=res*3+(s[i]-'0');\n    for(int i=s.size()-1;i>=0;i--)\n        res=res*3+(s[i]-'0');\n    // print(s,res);\n    return res;\n}\nbool add(string & x, const string & y) {\n    int n1=x.size(), n2=y.size(),carry=0;\n    rep(i,0,n1) {\n        if(i<n1) carry+=x[i]-'0';\n        if(i<n2) carry+=y[i]-'0';\n        x[i]=carry%3+'0';\n        carry/=3;\n    }\n    return carry==0;\n}\n\nvi cal_inst(string & s) {\n    int n=s.size();\n    vi res(1);\n    int i=0;\n    while(i<n) {\n        if(s[i]=='R') {\n            res.back()++;\n            i++;\n        }\n        else {\n            int j=i;\n            for(;j<n&&s[j]=='S';j++);\n            if((j-i)%2) res.pb(0);\n            i=j;\n        }\n    }\n    if(s.back()=='S') res.pop_back();\n    return res;\n}\n\nchar rev(char c) {\n    if(c>'0') return '0'+(3-(c-'0'));\n    return c;\n}\nstring rev(string s) {\n    for(auto & c:s) c=rev(c);\n    return s;\n}\n\nint len(string & s) {\n    int res=s.size()-1;\n    while(res>=0&&s[res]=='0') res--;\n    return res+1;\n}\n\nvi cal(vi inst, int n, int tot) {\n    vector<string> iinst;\n    for(auto x:inst) iinst.pb(to_ter(x,n));\n    vi res(tot);\n    map<string, string> dp,dp1;\n    rep(i,0,tot) {\n        string cur=to_ter(i,n);\n        int ok=0;\n        rep(j,0,n) {\n            string cur1=cur.substr(0,j+1)+string(n-j-1,'0');\n            if(dp1.count(cur1)&&len(dp1[cur1])<=j+1) {\n                // print(\"using\",cur1,\"for\",cur);\n                cur1=dp1[cur1];\n                // print(\"get\",cur1);\n                if(inst.size()%2) {\n                    rep(jj,j+1,n) cur1[jj]=rev(cur[jj]);\n                }\n                else {\n                    rep(jj,j+1,n) cur1[jj]=cur[jj]; \n                }\n                // print(\"get\",cur1);\n                // dp[cur]=cur1;\n                ok=1;\n                res[i]=to_int(cur1);\n                dp1[cur]=cur1;\n                break;\n            }\n        }\n        if(!ok) {\n            string cur1=cur;\n            bool ok1=true;\n            for(auto x:iinst) {\n                // print(cur1,to_ter(x,n));\n                ok1=add(cur1,x)&&ok1;\n                // print(cur1,to_ter(x,n));\n                for(auto & c:cur1) c=rev(c);\n            }\n            // dp[cur]=cur1;\n            res[i]=to_int(cur1);\n            if(ok1) dp1[cur]=cur1;\n            // print(cur,cur1);\n        }\n        // res[i]=to_int(dp[cur]);\n        // print(i,cur,res[i],dp[cur]);\n        // print(res[i],dp[cur]);  \n    }\n    print(inst,iinst,res);\n    print(dp);\n    print(dp1);\n    return res;\n}\n\nint main(int argc, char * argv[]) {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    // solve_testcase;\n\n    int n;\n    string s;\n    cin>>n;\n    cin>>s;\n    int tot=1;\n    rep(i,0,n) tot*=3;\n\n    vi inst=cal_inst(s);\n    for(auto & x:inst) x%=tot;\n\n    print(inst);\n\n    int i=0;\n    int bound=3*3*3*3*3;\n    vi res(tot);\n    iota(all(res),0);\n    while(i<inst.size()) {\n        int cur=inst[i];\n        vi cur_inst({cur});\n        for(++i;i<inst.size()&&cur+inst[i]<bound;i++) {\n            cur+=inst[i];\n            cur_inst.pb(inst[i]);\n        }\n        vi tmp=cal(cur_inst,n,tot);\n        // print(tmp);\n        rep(j,0,tot) res[j]=tmp[res[j]];\n        print(cur_inst,tmp);\n        print(res);\n        // sort(all(tmp)); print(tmp);\n    }\n    if(s.back()=='R') {\n        rep(i,0,tot) {\n            res[i]=to_int(rev(to_ter(res[i],n)));\n        }\n    }\n    for(auto x:res) cout<<x<<' ';\n    cout<<endl;\n\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,N) for(int i=0;i<(int)N;i++)\nstatic inline char CH()\n{\n  static char buf[100000],*ptr1=buf,*ptr2=buf;\n  return ptr1==ptr2&&(ptr2=(ptr1=buf)+fread(buf,1,100000,stdin),ptr1==ptr2)?EOF:*ptr1++;\n}\nstatic inline int IN(void)\n{\n  int x=0,f=0,c=CH();while(c<48||c>57){f^=c==45,c=CH();}\n  while(c>47&&c<58){x=x*10+c-48,c=CH();}return f?-x:x;\n}\nstatic inline void OUT(int x){if(x>=10)OUT(x/10);putchar(x%10+48);}\nstatic inline int Pow(int a,int b){return b?Pow(a*a,b>>1)*(b&1?a:1):1;}\nint main()\n{\n  int N=IN(),now,len=0,pw3=Pow(3,N),x=Pow(3,N>>1),y=Pow(3,N-(N>>1)),A[531441],B[531441];\n  char c=CH(),T[200001],S[200000];\n  rep(i,pw3)B[i]=B[i/3]*3+(3-i%3)%3;\n  while(c!=EOF){if(c=='\\t'||c==' '||c=='\\n'){c=CH();}T[len++]=c,c=CH();}\n  fflush(stdin);\n  rep(i,x)\n  {\n    int temp=i;now=0;\n    rep(j,len)\n    {\n      if(T[j]=='S'){temp=B[temp];if(S[now]=='S')--now;else S[++now]='S';}\n      else{++temp;if(temp==x)S[++now]='R',temp=0;}\n    }\n    rep(j,y)\n    {\n      int keep=j;\n      rep(k,now)\n      {\n        if(S[k+1]=='S')keep=B[keep];\n        else if(S[k+1]=='R')if((++keep)==y)keep=0;\n      }\n      A[i+j*x]=temp+keep*x;\n    }\n  }\n  rep(i,pw3)OUT(A[i]),putchar(' ');\n  return fflush(stdout),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint ans[600010],A,B,n,f[600010],g[600010],len,nw,lenn,nww;\nchar s[200010],ss[200010];\n\nint main()\n{\n\tscanf(\"%d%s\",&n,s),len=strlen(s),A=B=1;\n\tfor (int i=1; i<=(n+1)/2; i++) A*=3;\n\tfor (int i=(n+1)/2; i<n; i++) B*=3;\n\tfor (int i=0; i<A*B; i++) f[i]=f[i/3]*3+(i*2%3),g[i]=(i+1)%(A*B);\n\tfor (int i=0; i<A; i++)\n\t{\n\t\tnw=i,lenn=0,ss[0]='P';\n\t\tfor (int j=0; j<len; j++)\n\t\t\tif (s[j]=='R') \n\t\t\t{\n\t\t\t\tnw=g[nw]; \n\t\t\t\tif (nw%A==0) ss[++lenn]='R';\n\t\t\t} else \n\t\t\t{\n\t\t\t\tnw=f[nw];\n\t\t\t\tif (ss[lenn]=='S') lenn--; else ss[++lenn]='S';\n\t\t\t}\n\t\tans[i]=nw,nw%=A;\n\t\tfor (int j=1; j<B; j++)\n\t\t{\n\t\t\tnww=j;\n\t\t\tfor (int k=1; k<=lenn; k++)\n\t\t\t\tif (ss[k]=='R') nww=g[nww]; else nww=f[nww];\n\t\t\tans[j*A+i]=nww%B*A+nw;\n\t\t}\n\t}\n\tfor (int i=0; i<A*B; i++) printf(\"%d \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n//#define int long long\n \n#define pii pair<int, int>\n \n#define x1 x1228\n#define y1 y1228\n \n#define left left228\n#define right right228\n \n#define next next228\n \n#define pb push_back\n#define eb emplace_back\n \n#define mp make_pair                                                                \n                                                                                                                                        \n#define ff first                                                                  \n#define ss second   \n \n#define all(x) x.begin(), x.end()\n#define debug(x) cout << #x << \": \" << x << endl; \n#define TIME (ld)clock()/CLOCKS_PER_SEC\n \nusing namespace std;\ntypedef long long ll; \ntypedef long double ld; \n                                                                                                   \nconst int maxn = 2e5 + 7, mod = 1e9 + 7, MAXN = 1e6 + 7;\nconst double eps = 1e-9;\nconst ll inf = 1e18;\nmt19937 rnd(time(0));\nint n; \nstring s; \nint next[MAXN];\nconst int N = 2187; \nint dp1[N]; \nint dp2[N]; \nint xyz[N]; \n \nint get1(int mask, char q) {\n    if (q == 'R') {\n        ++mask; \n        return mask; \n    }   \n    int ptr = 1; \n    int ans = 0; \n    while (mask) {\n        int t = mask % 3; \n        mask /= 3; \n        if (t == 2) ans += ptr; \n        if (t == 1) ans += 2 * ptr; \n        ptr *= 3; \n    }\n    return ans; \n}\n \nconst int L = 12; \nint pref[maxn]; \nint to[maxn]; \nint kek1[N], kek2[N]; \nint res[N], res1[N]; \nint add = 1; \n \nvoid print(int x) {\n    while (x) {\n        cout << x % 3 << \" \"; \n        x /= 3; \n    }\n    cout << '\\n'; \n}\n\nint get(int x) {\n    vector<int> bts; \n    for (int i = 0; i < L; ++i) {\n        bts.pb(x % 3); \n        x /= 3; \n    }\n    int left = 0;\n    int right = 0; \n    for (int i = 6; i >= 0; --i) {\n        left *= 3;\n        left += bts[i]; \n    }\n    for (int i = L - 1; i >= 7; --i) {\n        right *= 3; \n        right += bts[i]; \n    }\n    int id = 0;         \n    if (left && dp1[left] == -1) {\n        if ((pref[(int)s.size()] - pref[id]) & 1) {        \n            right = xyz[right];     \n        }\n        return res[left] + add * right;   \n    }\n    if (left) {    \n        id = dp1[left]; \n//        print(right); \n        if (pref[id] & 1) {\n            right = xyz[right];             \n        }\n        ++right;\n//        print(right); \n        left = 0; \n    }                     \n    while (next[id] != -1) {        \n        if ((pref[next[id]] - pref[id]) & 1) {\n            right = xyz[right]; \n        }\n        right++; \n        id = next[id];                                                                                                                                         \n    }\n    if ((pref[(int)s.size()] - pref[id]) & 1) {        \n        right = xyz[right];     \n    }\n    left = to[id]; \n    return left + right * add; \n}\n \nvoid solve() {\n    for (int i = 0; i < N; ++i) {\n        xyz[i] = get1(i, 'S') % N; \n    }\n    cin >> n >> s; \n    int t = s.size(); \n    for (int i = 0; i < t; ++i) {\n        pref[i + 1] = pref[i] + (s[i] == 'S'); \n    }\n \n    for (int i = 0; i < N; ++i) dp1[i] = dp2[i] = -1; \n    next[t] = -1;\n    for (int i = 0; i < N; ++i) kek1[i] = i;              \n    for (int i = 0; i < N; ++i) res[i] = i; \n    for (int i = t - 1; i >= 0; --i) {\n        for (int mask = 0; mask < N; ++mask) {\n            int mask1; \n            if (s[i] == 'S') mask1 = xyz[mask]; \n            else mask1 = mask + 1; \n            if (mask1 >= N) mask1 -= N; \n            res1[mask] = res[mask1]; \n            kek2[mask] = kek1[mask1];\n            if (mask && mask1 == 0) {\n                dp2[mask] = i + 1; \n            } else {\n                dp2[mask] = dp1[mask1]; \n            }                                                                                 \n        }\n        to[i] = kek2[0]; \n        next[i] = dp2[0]; \n        for (int mask = 0; mask < N; ++mask) {\n            res[mask] = res1[mask]; \n            kek1[mask] = kek2[mask]; \n            dp1[mask] = dp2[mask]; \n            dp2[mask] = -1; \n        }\n    }\n    for (int i = 0; i < 7; ++i) add *= 3; \n    int tet = 1; \n    for (int i = 0; i < n; ++i) tet *= 3; \n    for (int ptr = 0; ptr < tet; ++ptr) {\n        cout << get(ptr) % tet << \" \"; \n    }\n//    cout << TIME; \n    return; \n}                                \n   \nsigned main() {\n#ifdef LOCAL\n    freopen(\"TASK.in\", \"r\", stdin);\n    freopen(\"TASK.out\", \"w\", stdout);\n#else \n    \n#endif // LOCAL\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20); \n    cout << fixed; \n    int t = 1; \n    for (int i = 0; i < t; ++i) {              \n        solve();\n    }\n    return 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define int long long\nstring h[729];\nint ans1[729];\nint ans2[729][729];\nint ans3[729*729];\nint sal1[729*729];\nint sal(int ans)\n{\n    int y=1;\n    int u=ans;\n    while(ans!=0)\n    {\n        int x=ans%3;\n        if(x==1)\n        {\n            u+=y;\n        }\n        else if(x==2)\n        {\n            u-=y;\n        }\n        ans/=3;\n        y*=3;\n    }\n    return u;\n}\nint32_t main()\n{\n    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    for(int i=0;i<729*729;++i)\n    {\n        sal1[i]=sal(i);\n    }\n    int n;\n    cin>>n;\n    int x=1;\n    for(int i=0;i<n;++i)\n    {\n        x*=3;\n    }\n    n=12;\n    string s;\n    cin>>s;\n    for(int i=0;i<729;++i)\n    {\n        int ans=i;\n        for(int j=0;j<s.size();++j)\n        {\n            if(s[j]=='R')\n            {\n                ++ans;\n                ans%=729;\n                if(ans==0)\n                {\n                    h[i]+='R';\n                }\n            }\n            else\n            {\n                ans=sal1[ans];\n                h[i]+='S';\n                if(h[i].size()>=2 && h[i][h[i].size()-2]=='S')\n                {\n                    h[i].erase(h[i].begin()+h[i].size()-1);\n                    h[i].erase(h[i].begin()+h[i].size()-1);\n                }\n            }\n        }\n        //cout<<i<<\" i \"<<ans<<\" ans \"<<endl;\n        ans1[i]=ans;\n        //cout<<ans1[i]<<\" ans1[i] \"<<endl;\n    }\n    for(int i=0;i<729;++i)\n    {\n        for(int j=0;j<729;++j)\n        {\n            int ans=j;\n            for(int k=0;k<h[i].size();++k)\n            {\n                if(h[i][k]=='S')\n                {\n                    ans=sal1[ans];\n                }\n                else\n                {\n                    ++ans;\n                    ans%=729;\n                }\n            }\n            ans2[i][j]=(ans*729+ans1[i]);\n            ans3[i+729*j]=ans2[i][j];\n        }\n    }\n    for(int i=0;i<x;++i)\n    {\n        cout<<ans3[i]%x<<\" \";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long Int;\ntypedef pair<int,int> PII;\ntypedef vector<int> VInt;\n \n#define FOR(i, a, b) for(i = (a); i < (b); ++i)\n#define RFOR(i, a, b) for(i = (a) - 1; i >= (b); --i)\n#define EACH(it, a) for(auto it = (a).begin(); it != (a).end(); ++it)\n#define CLEAR(a, b) memset(a, b, sizeof(a))\n#define SIZE(a) int((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define MP make_pair\n\n#define MAX (1 << 20)\n\nVInt V[MAX];\nint A[MAX];\n\nint f(int a)\n{\n    return a == 0 ? 0 : (a == 1 ? 2 : 1);\n}\n\nvoid solve(int test)\n{\n    int N;\n    string T;\n    cin >> N >> T;\n    int i, j, k;\n    int len = SIZE(T);\n    VInt s(len + 1, 0);\n    FOR(i, 0, len)\n    {\n        s[i + 1] = s[i];\n        if(T[i] == 'S')\n            s[i + 1] ^= 1;\n        else\n            V[0].push_back(i);\n    }\n    int offset = 0;\n    int p3 = 1;\n    FOR(i, 0, N)\n    {\n        FOR(j, 0, 3)\n            FOR(k, 0, p3)\n            {\n                int a = j;\n                int index = offset + (j + 1)*p3 + k;\n                int prev = 0;\n                for(int pos : V[offset + k])\n                {\n                    if(s[prev] != s[pos]) a = f(a);\n                    ++a;\n                    if(a == 3)\n                    {\n                        a = 0;\n                        V[index].push_back(pos);\n                    }\n                    prev = pos;\n                }\n                if(s[len] != s[prev]) a = f(a);\n                A[index] = a*p3 + A[offset + k];\n            }\n\n        offset += p3;\n        p3 *= 3;\n    }\n    FOR(i, 0, p3) cout << A[offset + i] << ' ';\n    cout << endl;\n}\n\nint main()\n{\n    int T, t;\n    T = 1;\n    FOR(t, 0, T) solve(t);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 200222, inf = 1000111222;\nconst int max_half = 729;\n\nchar buf[max_n];\n\nstring read() {\n    scanf(\"%s\", buf);\n    return buf;\n}\n\nint n, nxt[max_n][max_half], ans[max_n];\nint prec[max_half];\nint sum[max_n];\nint pw;\n\nint get_sum(int l, int r) {\n    if (!l) {\n        return sum[r];\n    }\n    return sum[r] - sum[l - 1];\n}\n\nvoid get_all_prec() {\n    pw = 1;\n    for (int i = 0; i < n; ++i) {\n        pw *= 3;\n    }\n    for (int x = 0; x < pw; ++x) {\n        vector<int> v;\n        int cur = x;\n        for (int i = 0; i < n; ++i) {\n            v.push_back(cur % 3);\n            cur /= 3;\n        }\n        reverse(v.begin(), v.end());\n        int to = 0;\n        for (int i = 0; i < n; ++i) {\n            int x = (v[i] * 2) % 3;\n            to = to * 3 + x;\n        }\n        prec[x] = to;\n    }\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    get_all_prec();\n    const int half = min(max_half, pw);\n    string s = read();\n    for (int x = 0; x < half; ++x) {\n        nxt[s.length()][x] = -1 - x;\n    }\n    for (int i = 0; i < s.length(); ++i) {\n        sum[i] = s[i] == 'S';\n        if (i) {\n            sum[i] += sum[i - 1];\n        }\n    }\n    for (int i = s.length() - 1; i >= 0; --i) {\n        for (int x = 0; x < half; ++x) {\n            int to = prec[x];\n            if (s[i] == 'R') {\n                to = x + 1;\n            }\n            if (to == half) {\n                nxt[i][x] = i;\n            } else {\n                nxt[i][x] = nxt[i + 1][to];\n            }\n            //cout << nxt[i][x] << \" \";\n        }\n        //cout << endl;\n    }\n    int mx = pw / half;\n    for (int x = 0; x < pw; ++x) {\n        int big = x / half, small = x % half;\n        int pos = 0;\n        while (pos < s.length()) {\n            //cout << pos << \": \" << big << \" \" << small << endl;\n            if (nxt[pos][small] < 0) {\n                small = -1 - nxt[pos][small];\n                if (get_sum(pos, s.length() - 1) % 2) {\n                    big = prec[big];\n                }\n                pos = s.length();\n            } else {\n                int to = nxt[pos][small];\n                if (get_sum(pos, to) % 2) {\n                    big = prec[big];\n                }\n                ++big;\n                if (big == mx) {\n                    big = 0;\n                }\n                small = 0;\n                pos = to + 1;\n            }\n        }\n        printf(\"%d \", big * half + small);\n        //cout << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\n#include<limits>\n#include<complex>\n#include<array>\n#include<numeric>\n#include<functional>\n\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rrep(i,m,n) for(ll (i)=(ll)(m);(i)>=(ll)(n);(i)--)\n#define rep(i,m,n) for(ll (i)=(ll)(m);i<(ll)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconstexpr long double m_pi = 3.1415926535897932L;\nconstexpr ll MOD = 1000000007;\nconstexpr ll INF = 1LL << 61;\nconstexpr long double EPS = 1e-10;\ntemplate<typename T> using vector2 = vector<vector<T>>;\ntemplate<typename T> using vector3 = vector<vector2<T>>;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstruct Edge {//グラフ\n\tint to, rev; ll cap;\n\tEdge(int _to, ll _cap, int _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, int from, int to, ll cap, bool revFlag, ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\n\nll max_flow_dfs(Graph& G, ll v, ll t, ll f, vector<bool>& used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph& G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\n\nvoid BellmanFord(Graph& G, ll s, Array& d, Array& negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif (negative[i] == true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = ((i != j) ? INF : 0);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\tchmin(d[i][G[i][j].to], G[i][j].cap);\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, Array& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass Lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tLca() {}\n\n\tLca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unite(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tll size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tll numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\n\ntemplate<typename T, typename F>\nclass SegmentTree {\nprivate:\n\tT identity;\n\tF merge;\n\tll n;\n\tvector<T> dat;\npublic:\n\tSegmentTree(F f, T id,vector<T> v) :merge(f), identity(id) {\n\t\tint _n = v.size();\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t\tREP(i, _n)dat[n + i - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--)dat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\tSegmentTree(F f, T id, int _n) :merge(f), identity(id) {\n\t\tn = 1;\n\t\twhile (n < _n)n *= 2;\n\t\tdat.resize(2 * n - 1, identity);\n\t}\n\tvoid set_val(int i, T x) {\n\t\ti += n - 1;\n\t\tdat[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = merge(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\tT query(int l, int r) {\n\t\tT left = identity, right = identity;\n\t\tl += n - 1; r += n - 1;\n\t\twhile (l < r) {\n\t\t\tif ((l & 1) == 0)left = merge(left, dat[l]);\n\t\t\tif ((r & 1) == 0)right = merge(dat[r - 1], right);\n\t\t\tl = l / 2;\n\t\t\tr = (r - 1) / 2;\n\t\t}\n\t\treturn merge(left, right);\n\t}\n};\n\ntemplate< typename T >\nclass FenwickTree {\n\tvector< T > data;\n\tint n;\n\tint p;\npublic:\n\tFenwickTree(int n) :n(n) { \n\t\tdata.resize(n + 1LL, 0);\n\t\tp = 1;\n\t\twhile (p < data.size())p *= 2;\n\t}\n\tT sum(int k) {\n\t\tT ret = 0;\n\t\tfor (; k > 0; k -= k & -k) ret += data[k];\n\t\treturn (ret);\n\t}\n\t\n\tT sum(int a, int b) { return sum(b) - sum(a); }//[a,b)\n\n\tvoid add(int k, T x) {\n\t\tfor (++k; k <= n; k += k & -k) data[k] += x;\n\t}\n\n\tint lower_bound(ll w) {\n\t\tif (w <= 0)return -1;\n\t\tint x = 0;\n\t\tfor (int k = p / 2; k > 0; k /= 2) {\n\t\t\tif (x + k <= n && data[x + k] < w)w -= data[x + k], x += k;\n\t\t}\n\t\treturn x;\n\t}\n};\n\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n}\n\nvoid prime_factorization(ll n, vector<P>& ret) {\n\tfor (ll i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back({ i,0 });\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tret[ret.size() - 1].second++;\n\t\t\t}\n\t\t}\n\t}\n\tif (n != 1)ret.push_back({ n,1 });\n}\n\n\ninline ll mod_pow(ll x, ll n, ll mod) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\ninline ll mod_inv(ll x, ll mod) {\n\treturn mod_pow(x, mod - 2, mod);\n}\n\nclass Combination {\npublic:\n\tArray fact;\n\tArray fact_inv;\n\tll mod;\n\t//if n >= mod use lucas \n\tll nCr(ll n, ll r) {\n\t\tif (n < r)return 0;\n\t\tif (n < mod)return ((fact[n] * fact_inv[r] % mod) * fact_inv[n - r]) % mod;\n\n\t\tll ret = 1;\n\t\twhile (n || r) {\n\t\t\tll _n = n % mod, _r = r % mod;\n\t\t\tn /= mod; r /= mod;\n\t\t\t(ret *= nCr(_n, _r)) %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tll nPr(ll n, ll r) {\n\t\treturn (fact[n] * fact_inv[n - r]) % mod;\n\t}\n\tll nHr(ll n, ll r) {\n\t\treturn nCr(r + n - 1, r);\n\t}\n\tCombination(ll _n, ll _mod) {\n\t\tmod = _mod;\n\t\tll n = min(_n + 1, mod);\n\t\tfact.resize(n);\n\t\tfact[0] = 1;\n\t\tREP(i, n - 1) {\n\t\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t\t}\n\t\tfact_inv.resize(n);\n\t\tfact_inv[n - 1] = mod_inv(fact[n - 1], mod);\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tfact_inv[i - 1] = fact_inv[i] * i % mod;\n\t\t}\n\t}\n};\n\nll popcount(ll x) {\n\tx = (x & 0x5555555555555555) + (x >> 1 & 0x5555555555555555);\n\tx = (x & 0x3333333333333333) + (x >> 2 & 0x3333333333333333);\n\tx = (x & 0x0F0F0F0F0F0F0F0F) + (x >> 4 & 0x0F0F0F0F0F0F0F0F);\n\tx = (x & 0x00FF00FF00FF00FF) + (x >> 8 & 0x00FF00FF00FF00FF);\n\tx = (x & 0x0000FFFF0000FFFF) + (x >> 16 & 0x0000FFFF0000FFFF);\n\tx = (x & 0x00000000FFFFFFFF) + (x >> 32 & 0x00000000FFFFFFFF);\n\n\treturn x;\n}\n\n\n\nll p[13];\nint main() {\n\tios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tstd::cout.tie(0);\n\n\tll n;\n\tstring t;\n\tcin >> n >> t;\n\tll len = 1;\n\tp[0] = 1;\n\tREP(i, n)len *= 3, p[i + 1] = len;\n\tArray ans(len, 0);\n\tauto solve = [&](auto solve, ll d, ll j,string t,ll sum,ll x)->void {\n\t\tif (d == n) {\n\t\t\tans[sum] = x;\n\t\t\treturn;\n\t\t}\n\t\tstring s;\n\t\tfor (auto ch : t) {\n\t\t\tif (ch == 'R')s.push_back('R');\n\t\t\telse if (s.size() == 0 || s.back() != 'S')s.push_back('S');\n\t\t\telse if (s.size() != 0 && s.back() == 'S')s.pop_back();\n\t\t}\n\t\tstring nxt;\n\t\tll now = j;\n\t\tREP(i, s.size()) {\n\t\t\tif (s[i] == 'R') {\n\t\t\t\t(now+=1) %= 3;\n\t\t\t\tif (now == 0)nxt.push_back('R');\n\t\t\t}\n\t\t\telse (now *= 2) %= 3, nxt.push_back('S');\n\t\t}\n\t\tsum += j * p[d];\n\t\tx += now * p[d];\n\t\tREP(i, 3)solve(solve, d + 1, i, nxt, sum, x);\n\t};\n\tREP(i, 3)solve(solve, 0, i, t, 0,0);\n\tREP(i, len)cout << ans[i] << (i == len - 1 ? \"\\n\" : \" \");\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "Lua",
    "code": "local mfl, mce = math.floor, math.ceil\nlocal bls, brs = bit.lshift, bit.rshift\n\nlocal n = io.read(\"*n\", \"*l\")\n-- local n = 12\nlocal tot = 3^n\n\nlocal warp = {{}}\nfor i = 1, tot do\n  local src = i - 1\n  local tmp = src\n  local dst = 0\n  local mul = 1\n  for j = 1, n do\n    if src % 3 ~= 0 then\n      dst = dst + mul * (3 - (src % 3))\n    end\n    mul = mul * 3\n    src = mfl(src / 3)\n  end\n  warp[1][i] = dst + 1\nend\nlocal lim = 49\nfor iz = 2, lim + 1 do\n  warp[iz] = {}\n  for i = 1, tot do\n    local src = i == tot and 1 or i + 1\n    warp[iz][i] = warp[iz - 1][src]\n  end\nend\nlocal cur = {}\nfor i = 1, tot do cur[i] = i end\n\nlocal function walk(r)\n  for i = 1, tot do\n    local v = cur[i] + r\n    while tot < v do v = v - tot end\n    cur[i] = v\n  end\nend\n-- print(os.clock())\n-- os.exit()\nlocal s = io.read()\ns = s:gsub(\"SS\", \"\")\nlocal sn = #s\n\nlocal rlen = 0\nfor i_s = 1, sn do\n  if s:sub(i_s, i_s) == \"S\" then\n    if lim < rlen then\n      walk(rlen - lim)\n    end\n    for i = 1, tot do\n      cur[i] = warp[rlen + 1][cur[i]]\n    end\n    rlen = 0\n  else\n    rlen = rlen + 1\n  end\nend\nif rlen ~= 0 then\n  walk(rlen)\nend\nfor i = 1, tot do\n  cur[i] = cur[i] - 1\nend\nprint(table.concat(cur, \" \"))\n"
  },
  {
    "language": "Lua",
    "code": "local mfl, mce = math.floor, math.ceil\nlocal bls, brs = bit.lshift, bit.rshift\n\nlocal n = io.read(\"*n\", \"*l\")\n-- local n = 12\nlocal tot = 3^n\n\nlocal warp = {{}}\nfor i = 1, tot do\n  local src = i - 1\n  local tmp = src\n  local dst = 0\n  local mul = 1\n  for j = 1, n do\n    if src % 3 ~= 0 then\n      dst = dst + mul * (3 - (src % 3))\n    end\n    mul = mul * 3\n    src = mfl(src / 3)\n  end\n  warp[1][i] = dst + 1\nend\nlocal lim = 49\nfor iz = 2, lim + 1 do\n  warp[iz] = {}\n  for i = 1, tot do\n    local src = i == tot and 1 or i + 1\n    warp[iz][i] = warp[iz - 1][src]\n  end\nend\nlocal cur = {}\nfor i = 1, tot do cur[i] = i end\n\nlocal function walk(r)\n  for i = 1, tot do\n    local v = cur[i] + r\n    while tot < v do v = v - tot end\n    cur[i] = v\n  end\nend\n-- print(os.clock())\n-- os.exit()\nlocal s = io.read()\ns = s:gsub(\"SS\", \"\")\nlocal sn = #s\n\nlocal rlen = 0\nfor i_s = 1, sn do\n  if s:sub(i_s, i_s) == \"S\" then\n    if lim < rlen then\n      walk(rlen - lim)\n      rlen = lim\n    end\n    for i = 1, tot do\n      cur[i] = warp[rlen + 1][cur[i]]\n    end\n    rlen = 0\n  else\n    rlen = rlen + 1\n  end\nend\nif rlen ~= 0 then\n  walk(rlen)\nend\nfor i = 1, tot do\n  cur[i] = cur[i] - 1\nend\nprint(table.concat(cur, \" \"))\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define NUM 100000000\n\nint main(void){\n\n        int a[NUM],b[NUM],c[NUM],d[NUM],t;\n        int n[NUM];\n\n        scanf(\"%d\",&t);\n\n        int coin[10000] = {0};\n\nfor(int i=0;i<t;i++){\n        scanf(\"%d%d%d%d%d\",&n[i],&a[i],&b[i],&c[i],&d[i]);\n\nwhile(n[i]>0){\n\nif(n[i]%5 == 0){ \n        n[i] = n[i]/5;\n        coin[i] = coin[i] + a[i];\n}else if(n[i]%3 == 0){ \n        n[i] = n[i]/3;\n        coin[i] = coin[i] + b[i];\n}else if(n[i] % 2 == 0){ \n        n[i] = n[i]/2;\n        coin[i] = coin[i] + c[i];\n}else{\n        n[i] = n[i] - 1;\n        coin[i] = coin[i] + d[i];\n}\n}\nprintf(\"%d\\n\",coin[i]);\n}\nreturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\nint convert(int x, int n){\n    int y=0, i=0, z;\n    while(x > 0){\n        z = x%n;\n        if(z == 1){\n          z = 2;\n        }else if(z==2){\n          z = 1;\n        }\n        y += z*pow(n, i);\n        x = x/n;\n        i++;\n    }\n    return y;\n}\n\nint main()\n{\n  int n;\n  scanf(\"%d\", &n);\n  char t[200001];\n  scanf(\"%s\", t);\n\n  int shuturyoku1, shuturyoku2;\n    for(int j = 0; j < strlen(t); j = j+2){\n      shuturyoku1 = j;\n      shuturyoku2 = j+1;\n      if(t[j] == 'S'){\n        shuturyoku1 = convert(shuturyoku1, 3);\n        shuturyoku2 = convert(shuturyoku2, 3);\n      }else if(t[j] == 'R'){\n        if(shuturyoku1 == pow(3,n)-1){\n          shuturyoku1 = 0;\n          shuturyoku2 = shuturyoku2+1;\n        }else if(shuturyoku2 == pow(3,n)-1){\n          shuturyoku2 = 0;\n          shuturyoku1 = shuturyoku1+1;\n        }else{\n          shuturyoku1 = shuturyoku1+1;\n          shuturyoku2 = shuturyoku2+1;\n        }\n      } \n      // printf(\"%d \", shuturyoku);\n    }\n    printf(\"%d \", shuturyoku1);\n    printf(\"%d \", shuturyoku2);\n    // printf(\"\\n\");\n  printf(\"\\n\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main()\n{\n\tint n,i,t,ans=0;\n\tscanf(\"%d\",&n);\n\tif(n==1)printf(\"2 0 1\");\n\tif(n==2)printf(\"3 8 1 0 5 7 6 2 4\");\n\tif(n==3)printf(\"23 9 22 8 3 7 20 24 19 5 18 4 17 12 16 2 6 1 14 0 13 26 21 25 11 15 10\")\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint new_pos(int num){\n    int j=1,ans=0;\n    for(j=1;;){\n        if(num<3){\n            if(num==1) ans = ans + 2*j;\n            else if(num==2) ans = ans + 1*j;\n            break;\n\n        }\n        else{\n            if(num%3==1) ans = ans+2*j;\n            else if(num%3==2) ans = ans+1*j;\n            num = num/3;\n        }\n        j=j*3;\n    }\n    return ans;\n}\n\nint main()\n{\n    int n,i,j,r=0,s=0;\n    int pos[531441]={},map[531441]={};\n    char t[200000]={};\n    scanf(\"%d\",&n);\n    for(i=0;i<(int)pow(3,n);i++) pos[i]=i;\n    scanf(\"%s\",&t);\n    for(i=0;i<(int)(pow(3,n));i++) map[i]=new_pos(i);\n    for(i=0;i<=strlen(t);i++){\n        if(s==0&&t[i]=='R') r++;\n        else if(r==0&&t[i]=='S') s++;\n        else if(r!=0&&t[i]!='R'){\n            if(r%(int)pow(3,n)==0) r = 0;\n            else{\n                for(j=0;j<(int)pow(3,n);j++){\n                    pos[j] = (pos[j]+r)%((int)(pow(3,n)));\n                }\n                r = 0;\n            }\n            s++;\n        }\n        else if(s!=0&&t[i]!='S'){\n            if(s%2==0) s = 0;\n            else{\n                for(j=0;j<(int)pow(3,n);j++) pos[j] = map[pos[j]];\n                s = 0;\n            }\n            r++;\n        }\n    }\n    for(i=0;i<(int)pow(3,n);i++) printf(\"%d \",pos[i]);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint salsa(int p)\n{\n  int r=0;\n  int q=0;\n  int a;\n  while(p>0)\n  {\n    a=p%3;\n    if(a==1) r+=2*(int)pow(3,q);\n    if(a==2) r+=(int)pow(3,q);\n    p/=3;\n    q++;\n  }\n  return r;\n}\n\nint main(void)\n{\n  int n,m;\n  int ans[531441];\n  int a=0;\n  int b=0;\n  char t[200001];\n  int c[200001];\n  int s=0;\n  int r=0;\n\n  scanf(\"%d\",&n);\n  scanf(\"%s\",t);\n\n  m=(int)pow(3,n);\n  for(int i=0;i<m;i++)\n  {\n    ans[i]=i;\n  }\n\n  while(1)\n  {\n    if(t[a]=='S')\n    {\n      if(r>0)\n      {\n        if(c[b-1]>0) c[b-1]+=r;\n        else c[b++]=r;\n        r=0;\n      }\n      s++;\n    }\n    if(t[a]=='R')\n    {\n      if(s>0)\n      {\n        if(s%2==1)\n        {\n          c[b]=0;\n          b++;\n        }\n        s=0;\n      }\n      r++;\n    }\n    if(t[a]=='\\n')\n    {\n      if(r>0) c[b++]=r;\n      else if(s%2==1) c[b++]=0;\n      break;\n    }\n    a++;\n  }\n\n  for(int i=0;i<b;i++)\n  {\n    if(c[i]==0)\n    {\n      for(int j=0;j<m;j++)\n      {\n        ans[j]=salsa(ans[j]);\n      }\n    }\n    else\n    {\n      for(int j=0;j<m;j++)\n      {\n        ans[j]=(ans[j]+c[i])%m;\n      }\n    }\n    a++;\n  }\n\n  for(int j=0;j<m;j++)\n  {\n    printf(\"%d\",ans[j]);\n    if(j<m-1) printf(\" \");\n    else printf(\"\\n\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n\nint main(){\n    int N;\n    char s[20001];\n    char str[20001];\n    int j = 0;\n    int ext;\n    scanf(\"%d %s\", &N, s);\n    \n    int all = (int)pow(3.0, N);\n    int max = strlen(s);\n\n    for (int i = 0; i < max; i++)\n    {\n        str[j] = s[i];\n        if (j > 0 && str[j] == 'S' && str[j - 1] == 'S')\n            j=j-2;//二つセットで消す\n        else if (str[j] == '\\0')\n            break;\n        j++;\n    } //jが総数\n\n    /*printf(\"\\n----\");\n    for (int i = 0; i < j; i++)\n    {\n        printf(\"%c\", str[i]);\n    }\n    printf(\"\\n----\");\n*/\n    int a[15];\n    for (int i = 0; i < 14; i++)\n    {\n        a[i] = 0;\n    } //初期化\n    \n\n    \n \n    int count = 0;\n    for (int i = 0; i < all; i++)\n    {\n        ext=i;\n        for (int q = 0; q < N; q++)\n        {\n            a[q] = ext % 3;\n            ext = ext / 3;\n        } //3進数\n        for (int q = 0; q < j; q++)\n        {\n            if (str[q] == 'R')\n            {\n                a[0] += 1;\n                for (int l = 0; a[l] == 3; l++)\n                {\n                    a[l] = 0;\n                    a[l + 1] += 1;\n                } //繰り上げ\n            }\n            else\n            {\n                for (int l = 0; l < N; l++)\n                {\n                    a[l] = (a[l] * 2) % 3;\n                } //3進数の回転\n            }\n           // printf(\"%d番目の人は今%cで%dへ移動\\n\", i, str[q], a[0]);\n        } //Sとか\n\n        count = 0;\n        for (int q = 0; q < N; q++)\n        {\n            count += a[q] * (int)pow(3.0, q);\n        } //3進数で今何番地か\n\n        \n        printf(\"%d \",count%all);\n       // member[i] = count % all;\n    }\n\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void)\n{int a,i,m,n,x,y;\n char c[1][200000];\n x=1;\n scanf(\"%d\",&a);\n for(n=0;n<a;n++){x=x*3;}\n int b[x];\n for(i=0;i<x;i++){\n     b[i]=i;\n }\n scanf (\"%s\",c);\n   for(m=0;m<200000;m++){y=x;\n       if(c[1][m]==82);{for(i=0;i<x;i++)\n                     {for(n=1;n<a;n++){b[i]=3%(3-(b[i]-b[i]%(x/3)))*x/3;x=x/3;}\n                     }}\n       if(c[1][m]==83);{for(i=0;i<x;i++)\n                     {b[i]=(b[i]+1)%x;}\n                     }\n       if(c[1][m]==0);{break;}\n     }\n     \n     printf(\"%s\\b\",b);\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main()\n{int a,i,m,n,x,y;\n char c[200000];\n x=1;\n scanf(\"%d\",&a);\n for(n=0;n<a;n++){x=x*3;}\n int b[x];\n for(i=0;i<x;i++){\n     b[i]=i;\n }\n scanf (\"%s\",c);\n   for(m=0;m<200000;m++){y=x;\n       if(c[m]==S);{for(i=0;i<x;i++)\n                     {for(n=1;n<a;n++){b[i]=3%(3-(b[i]-b[i]%(x/3)))*x/3;x=x/3;}\n                     }}\n       if(c[m]==R);{for(i=0;i<x;i++)\n                     {b[i]=(b[i]+1)%x;}\n                     }\n       if(c[m]==\\0);{break;}\n     }\n     \n     printf(\"%s\\b\",b);\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n\nint main(){\n    int N;\n    char s[20000];\n    char str[20000];\n    //int ans[1000];\n    int j = 0;\n    int ext;\n    scanf(\"%d %s\", &N, s);\n    \n    int all = (int)pow(3.0, N);\n    int max = strlen(s);\n\n    for (int i = 0; i < max; i++)\n    {\n        str[j] = s[i];\n        if (j > 0 && str[j] == 'S' && str[j - 1] == 'S')\n            j=j-2;//二つセットで消す\n        else if (str[j] == '\\0')\n            break;\n        j++;\n    } //jが総数\n\n    /*printf(\"\\n----\");\n    for (int i = 0; i < j; i++)\n    {\n        printf(\"%c\", str[i]);\n    }\n    printf(\"\\n----\");\n*/\n    int a[13];\n    for (int i = 0; i < 12; i++)\n    {\n        a[i] = 0;\n    } //初期化\n    \n\n    \n \n    int count = 0;\n    for (int i = 0; i < all; i++)\n    {\n        ext=i;\n        for (int q = 0; q < N; q++)\n        {\n            a[q] = ext % 3;\n            ext = ext / 3;\n        } //3進数\n        for (int q = 0; q < j; q++)\n        {\n            if (str[q] == 'R')\n            {\n                a[0] += 1;\n                for (int l = 0; a[l] == 3; l++)\n                {\n                    a[l] = 0;\n                    a[l + 1] += 1;\n                } //繰り上げ\n            }\n            else\n            {\n                for (int l = 0; l < N; l++)\n                {\n                    a[l] = (a[l] * 2) % 3;\n                } //3進数の回転\n            }\n           // printf(\"%d番目の人は今%cで%dへ移動\\n\", i, str[q], a[0]);\n        } //Sとか\n\n        count = 0;\n        for (int q = 0; q < N; q++)\n        {\n            count += a[q] * (int)pow(3.0, q);\n        } //3進数で今何番地か\n\n        \n        printf(\"%d \",count%all);\n       // member[i] = count % all;\n    }\n\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint salsa(int p)\n{\n  int r=0;\n  int q=0;\n  int a;\n  while(p>0)\n  {\n    a=p%3;\n    if(a==1) r+=2*(int)pow(3,q);\n    if(a==2) r+=(int)pow(3,q);\n    p/=3;\n    q++;\n  }\n  return r;\n}\n\nint main(void)\n{\n  int n,m;\n  int ans[531441];\n  int a=0;\n  int b=0;\n  char t[200001];\n  int c[200001];\n  int s=0;\n  int r=0;\n\n  scanf(\"%d\",&n);\n  scanf(\"%s\",t);\n\n  m=(int)pow(3,n);\n  for(int i=0;i<m;i++)\n  {\n    ans[i]=i;\n  }\n\n  while(1)\n  {\n    if(t[a]=='S')\n    {\n      if(r>0)\n      {\n        c[b]=r;\n        r=0;\n        b++;\n      }\n      s++;\n    }\n    if(t[a]=='R')\n    {\n      if(s>0)\n      {\n        if(s%2==1)\n        {\n          c[b]=0;\n          b++;\n        }\n        s=0;\n      }\n      r++;\n    }\n    if(t[a]=='\\n')\n    {\n      if(r>0) c[b]=r;\n      else if(s%2==1) c[b]=0;\n      b++;\n      break;\n    }\n    a++;\n  }\n\n  for(int i=0;i<b;i++)\n  {\n    if(c[i]==0)\n    {\n      for(int j=0;j<m;j++)\n      {\n        ans[j]=salsa(ans[j]);\n      }\n    }\n    else\n    {\n      for(int j=0;j<m;j++)\n      {\n        ans[j]=(ans[j]+c[i])%m;\n      }\n    }\n    a++;\n  }\n\n  for(int j=0;j<m;j++)\n  {\n    printf(\"%d\",ans[j]);\n    if(j<m-1) printf(\" \");\n    else printf(\"\\n\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint salsa(int p)\n{\n  int r=0;\n  int q=0;\n  int a;\n  while(p>0)\n  {\n    a=p%3;\n    if(a==1) r+=2*(int)pow(3,q);\n    if(a==2) r+=(int)pow(3,q);\n    p/=3;\n    q++;\n  }\n  return r;\n}\n\nint main(void)\n{\n  int n,m;\n  int ans[531441];\n  int a=0;\n  char t[200001];\n\n  scanf(\"%d\",&n);\n  scanf(\"%s\",t);\n\n  m=(int)pow(3,n);\n  for(int i=0;i<m;i++)\n  {\n    ans[i]=i;\n  }\n\n  while(t[a]!='\\n')\n  {\n    if(t[a]=='S')\n    {\n      for(int i=0;i<m;i++)\n      {\n        ans[i]=salsa(ans[i]);\n      }\n    }\n    if(t[a]=='R')\n    {\n      for(int i=0;i<m;i++)\n      {\n        ans[i]=(ans[i]+1)%m;\n      }\n    }\n    a++;\n  }\n\n  for(int i=0;i<m;i++)\n  {\n    printf(\"%d\",ans[i]);\n    if(i<m-1) printf(\" \");\n    else printf(\"\\n\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint salsa(int p)\n{\n  int r=0;\n  int q=0;\n  int a;\n  while(p>0)\n  {\n    a=p%3;\n    if(a==1) r+=2*(int)pow(3,q);\n    if(a==2) r+=(int)pow(3,q);\n    p/=3;\n    q++;\n  }\n  return r;\n}\n\nint main(void)\n{\n  int n,m;\n  int ans[531441];\n  int sal[531441];\n  int a=0;\n  int b=0;\n  char t[200001];\n  int c[200001]={0};\n  int s=0;\n  int r=0;\n\n  scanf(\"%d\",&n);\n  scanf(\"%s\",t);\n\n  m=(int)pow(3,n);\n  for(int i=0;i<m;i++)\n  {\n    ans[i]=i;\n    sal[i]=salsa(i);\n  }\n\n  while(1)\n  {\n    if(t[a]=='S')\n    {\n      if(r>0)\n      {\n        if(b>0 && c[b-1]>0) c[b-1]+=r;\n        else c[b++]=r;\n        r=0;\n      }\n      s++;\n    }\n    else if(t[a]=='R')\n    {\n      if(s>0)\n      {\n        if(s%2==1) c[b++]=0;\n        s=0;\n      }\n      r++;\n    }\n    else if(t[a]=='\\n')\n    {\n      if(r>0) c[b++]=r;\n      else if(s%2==1) c[b++]=0;\n      break;\n    }\n    a++;\n  }\n\n  for(int i=0;i<b;i++)\n  {\n    if(c[i]==0)\n    {\n      for(int j=0;j<m;j++)\n      {\n        ans[j]=sal[ans[j]];\n      }\n    }\n    else\n    {\n      for(int j=0;j<m;j++)\n      {\n        ans[j]=(ans[j]+c[i])%m;\n      }\n    }\n    a++;\n  }\n\n  for(int j=0;j<m;j++)\n  {\n    printf(\"%d \",ans[j]);\n  }\n  printf(\"\\n\");\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n\nint main(){\n    int N;\n    char s[200001];\n    char str[200001];\n    int j = 0;\n    int ext;\n    scanf(\"%d %s\", &N, s);\n    \n    int all = (int)pow(3.0, N);\n    int max = strlen(s);\n\n    for (int i = 0; i < max; i++)\n    {\n        str[j] = s[i];\n        if (j > 0 && str[j] == 'S' && str[j - 1] == 'S')\n            j=j-2;//二つセットで消す\n        if(j>0 && str[j]=='R' && str[j-1]!='S'){\n            if(str[j-1]=='R'){ \n                str[j - 1] = '2';\n                j--;\n            }\n            else if (str[j - 1] < 82){\n                str[j-1] = str[j - 1] + 1;\n                j--;\n            }\n        }\n        j++;\n    } //jが総数\n/*\n    printf(\"\\n----\");\n    for (int i = 0; i < j; i++)\n    {\n        printf(\"%c\", str[i]);\n    }\n    printf(\"\\n----\");\n*/\n    int a[15];\n    for (int i = 0; i < 14; i++)\n    {\n        a[i] = 0;\n    } //初期化\n    \n\n    \n \n    int count = 0;\n    for (int i = 0; i < all; i++)\n    {\n        ext=i;\n        for (int q = 0; q < N; q++)\n        {\n            a[q] = ext % 3;\n            ext = ext / 3;\n        } //3進数\n        for (int q = 0; q < j; q++)\n        {\n            if (str[q] == 'S')\n            {\n        \n                for (int l = 0; l < N; l++)\n                {\n                    a[l] = (a[l] * 2) % 3;\n                } //3進数の回転\n            }\n            else\n            {\n                \n                int kk;\n                if(str[q]=='R')\n                    kk = 1;\n                else\n                    kk = str[q] - 48;//数にす　る\n\n                    a[0] += kk;\n                for (int l = 0; a[l] >= 3; l++)\n                {\n                    kk = a[l] / 3;\n                    a[l] = a[l] % 3;\n                    a[l + 1] += kk;\n                } //繰り上げ\n            }\n           // printf(\"%d番目の人は今%cで%dへ移動\\n\", i, str[q], a[0]);\n        } //Sとか\n\n        count = 0;\n        for (int q = 0; q < N; q++)\n        {\n            count += a[q] * (int)pow(3.0, q);\n        } //3進数で今何番地か\n\n        \n        printf(\"%d \",count%all);\n       // member[i] = count % all;\n    }\n\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint salsa(int p)\n{\n  int r=0;\n  int q=0;\n  int a;\n  while(p>0)\n  {\n    a=p%3;\n    if(a==1) r+=2*(int)pow(3,q);\n    if(a==2) r+=(int)pow(3,q);\n    p/=3;\n    q++;\n  }\n  return r;\n}\n\nint main(void)\n{\n  int n,m;\n  int ans[531442];\n  int a=0;\n  int b=0;\n  char t[200001];\n  int c[200001];\n  int s=0;\n  int r=0;\n\n  scanf(\"%d\",&n);\n  scanf(\"%s\",t);\n\n  m=(int)pow(3,n);\n  for(int i=0;i<m;i++)\n  {\n    ans[i]=i;\n  }\n\n  while(1)\n  {\n    if(t[a]=='S')\n    {\n      if(r>0)\n      {\n        if(c[b-1]>0) c[b-1]+=r;\n        else c[b++]=r;\n        r=0;\n      }\n      s++;\n    }\n    if(t[a]=='R')\n    {\n      if(s>0)\n      {\n        if(s%2==1)\n        {\n          c[b]=0;\n          b++;\n        }\n        s=0;\n      }\n      r++;\n    }\n    if(t[a]=='\\n')\n    {\n      if(r>0) c[b++]=r;\n      else if(s%2==1) c[b++]=0;\n      break;\n    }\n    a++;\n  }\n\n  for(int i=0;i<b;i++)\n  {\n    if(c[i]==0)\n    {\n      for(int j=0;j<m;j++)\n      {\n        ans[j]=salsa(ans[j]);\n      }\n    }\n    else\n    {\n      for(int j=0;j<m;j++)\n      {\n        ans[j]=(ans[j]+c[i])%m;\n      }\n    }\n    a++;\n  }\n\n  for(int j=0;j<m;j++)\n  {\n    printf(\"%d\",ans[j]);\n    if(j<m-1) printf(\" \");\n    else printf(\"\\n\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main()\n{int a,i,m,n,x,y;\n char c[1][200000];\n x=1;\n scanf(\"%d\",&a);\n for(n=0;n<a;n++){x=x*3;}\n int b[x];\n for(i=0;i<x;i++){\n     b[i]=i;\n }\n scanf (\"%s\",c);\n   for(m=0;m<200000;m++){y=x;\n       if(c[1][m]==\"R\");{for(i=0;i<x;i++)\n                     {for(n=1;n<a;n++){b[i]=3%(3-(b[i]-b[i]%(x/3)))*x/3;x=x/3;}\n                     }}\n       if(c[1][m]==\"S\");{for(i=0;i<x;i++)\n                     {b[i]=(b[i]+1)%x;}\n                     }\n       if(c[m]==0);{break;}\n     }\n     \n     printf(\"%s\\b\",b);\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n\nint main(){\n    int N;\n    char s[200001];\n    char str[200001];\n    int j = 0;\n    int ext;\n    scanf(\"%d %s\", &N, s);\n    \n    int all = (int)pow(3.0, N);\n    int max = strlen(s);\n\n    for (int i = 0; i < max; i++)\n    {\n        str[j] = s[i];\n        if (j > 0 && str[j] == 'S' && str[j - 1] == 'S')\n            j=j-2;//二つセットで消す\n        else if (str[j] == '\\0')\n            break;\n        j++;\n    } //jが総数\n\n    /*printf(\"\\n----\");\n    for (int i = 0; i < j; i++)\n    {\n        printf(\"%c\", str[i]);\n    }\n    printf(\"\\n----\");\n*/\n    int a[15];\n    for (int i = 0; i < 14; i++)\n    {\n        a[i] = 0;\n    } //初期化\n    \n\n    \n \n    int count = 0;\n    for (int i = 0; i < all; i++)\n    {\n        ext=i;\n        for (int q = 0; q < N; q++)\n        {\n            a[q] = ext % 3;\n            ext = ext / 3;\n        } //3進数\n        for (int q = 0; q < j; q++)\n        {\n            if (str[q] == 'R')\n            {\n                a[0] += 1;\n                for (int l = 0; a[l] == 3; l++)\n                {\n                    a[l] = 0;\n                    a[l + 1] += 1;\n                } //繰り上げ\n            }\n            else\n            {\n                for (int l = 0; l < N; l++)\n                {\n                    a[l] = (a[l] * 2) % 3;\n                } //3進数の回転\n            }\n           // printf(\"%d番目の人は今%cで%dへ移動\\n\", i, str[q], a[0]);\n        } //Sとか\n\n        count = 0;\n        for (int q = 0; q < N; q++)\n        {\n            count += a[q] * (int)pow(3.0, q);\n        } //3進数で今何番地か\n\n        \n        printf(\"%d \",count%all);\n       // member[i] = count % all;\n    }\n\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n\nint main(){\n    int N;\n    char s[200001];\n    char str[200001];\n    int j = 0;\n    int ext;\n    scanf(\"%d %s\", &N, s);\n    \n    int all = (int)pow(3.0, N);\n    int max = strlen(s);\n\n    for (int i = 0; i < max; i++)\n    {\n        if(s[i]=='S')\n            str[j] = 'z';\n        else\n        {\n            str[j] = 'y';\n        }\n\n        if (j > 0 && str[j] == 'z' && str[j - 1] == 'z')\n            j=j-2;//二つセットで消す\n        if(j>0 && str[j]=='y' && str[j-1]!='z'){\n            if(str[j-1]=='y'){ \n                str[j - 1] = 34;\n                j--;\n            }\n            else if (str[j - 1] < 120){\n                str[j-1] = str[j - 1] + 1;\n                j--;\n            }\n        }\n        j++;\n    } //jが総数\n/*\n    printf(\"\\n----\");\n    for (int i = 0; i < j; i++)\n    {\n        printf(\"%c\", str[i]);\n    }\n    printf(\"\\n----\");\n    */\n\n    int a[15];\n    for (int i = 0; i < 14; i++)\n    {\n        a[i] = 0;\n    } //初期化\n    \n\n    \n \n    int count = 0;\n    for (int i = 0; i < all; i++)\n    {\n        ext=i;\n        for (int q = 0; q < N; q++)\n        {\n            a[q] = ext % 3;\n            ext = ext / 3;\n        } //3進数\n        for (int q = 0; q < j; q++)\n        {\n            if (str[q] == 'z')\n            {\n        \n                for (int l = 0; l < N; l++)\n                {\n                    a[l] = (a[l] * 2) % 3;\n                } //3進数の回転\n            }\n            else\n            {\n                \n                int kk;\n                if(str[q]=='y')\n                    kk = 1;//Rをyに帰る\n                else\n                    kk = str[q] - 32;//数にす　る\n\n                    a[0] += kk;\n                for (int l = 0; a[l] >= 3; l++)\n                {\n                    kk = a[l] / 3;\n                    a[l] = a[l] % 3;\n                    a[l + 1] += kk;\n                } //繰り上げ\n            }\n           // printf(\"%d番目の人は今%cで%dへ移動\\n\", i, str[q], a[0]);\n        } //Sとか\n\n        count = 0;\n        for (int q = 0; q < N; q++)\n        {\n            count += a[q] * (int)pow(3.0, q);\n        } //3進数で今何番地か\n\n        \n        printf(\"%d \",count%all);\n       // member[i] = count % all;\n    }\n\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n\nint main(){\n    int N;\n    char s[200001];\n    char str[200001];\n    int j = 0;\n    int ext;\n    scanf(\"%d %s\", &N, s);\n    \n    int all = (int)pow(3.0, N);\n    int max = strlen(s);\n\n    for (int i = 0; i < max; i++)\n    {\n        str[j] = s[i];\n        if (j > 0 && str[j] == 'S' && str[j - 1] == 'S')\n            j=j-2;//二つセットで消す\n        if(j>0 && str[j]=='R' && str[j-1]!='S'){\n            if(str[j-1]=='R'){ \n                str[j - 1] = '2';\n                j--;\n            }\n            else if (str[j - 1] < 80){\n                str[j-1] = str[j - 1] + 1;\n                j--;\n            }\n        }\n        j++;\n    } //jが総数\n/*\n    printf(\"\\n----\");\n    for (int i = 0; i < j; i++)\n    {\n        printf(\"%c\", str[i]);\n    }\n    printf(\"\\n----\");\n*/\n    int a[15];\n    for (int i = 0; i < 14; i++)\n    {\n        a[i] = 0;\n    } //初期化\n    \n\n    \n \n    int count = 0;\n    for (int i = 0; i < all; i++)\n    {\n        ext=i;\n        for (int q = 0; q < N; q++)\n        {\n            a[q] = ext % 3;\n            ext = ext / 3;\n        } //3進数\n        for (int q = 0; q < j; q++)\n        {\n            if (str[q] == 'S')\n            {\n        \n                for (int l = 0; l < N; l++)\n                {\n                    a[l] = (a[l] * 2) % 3;\n                } //3進数の回転\n            }\n            else\n            {\n                \n                int kk;\n                if(str[q]=='R')\n                    kk = 1;\n                else\n                    kk = str[q] - 48;//数にす　る\n\n                    a[0] += kk;\n                for (int l = 0; a[l] >= 3; l++)\n                {\n                    kk = a[l] / 3;\n                    a[l] = a[l] % 3;\n                    a[l + 1] += kk;\n                } //繰り上げ\n            }\n           // printf(\"%d番目の人は今%cで%dへ移動\\n\", i, str[q], a[0]);\n        } //Sとか\n\n        count = 0;\n        for (int q = 0; q < N; q++)\n        {\n            count += a[q] * (int)pow(3.0, q);\n        } //3進数で今何番地か\n\n        \n        printf(\"%d \",count%all);\n       // member[i] = count % all;\n    }\n\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n\nint main(){\n    int N;\n    //int member[1000];\n    char s[1000];\n    char str[1000];\n    //int ans[1000];\n    int j = 0;\n    int ext;\n    scanf(\"%d %s\", &N, s);\n    \n    int all = (int)pow(3.0, N);\n    int max = strlen(s);\n\n    for (int i = 0; i < max; i++)\n    {\n        str[j] = s[i];\n        if (j > 0 && str[j] == 'S' && str[j - 1] == 'S')\n            j=j-2;//二つセットで消す\n        else if (str[j] == '\\0')\n            break;\n        j++;\n    } //jが総数\n\n    /*printf(\"\\n----\");\n    for (int i = 0; i < j; i++)\n    {\n        printf(\"%c\", str[i]);\n    }\n    printf(\"\\n----\");\n*/\n    int a[13];\n    for (int i = 0; i < 12; i++)\n    {\n        a[i] = 0;\n    } //初期化\n    \n\n    \n \n    int count = 0;\n    for (int i = 0; i < all; i++)\n    {\n        ext=i;\n        for (int q = 0; q < N; q++)\n        {\n            a[q] = ext % 3;\n            ext = ext / 3;\n        } //3進数\n        for (int q = 0; q < j; q++)\n        {\n            if (str[q] == 'R')\n            {\n                a[0] += 1;\n                for (int l = 0; a[l] == 3; l++)\n                {\n                    a[l] = 0;\n                    a[l + 1] += 1;\n                } //繰り上げ\n            }\n            else\n            {\n                for (int l = 0; l < N; l++)\n                {\n                    a[l] = (a[l] * 2) % 3;\n                } //3進数の回転\n            }\n           // printf(\"%d番目の人は今%cで%dへ移動\\n\", i, str[q], a[0]);\n        } //Sとか\n\n        count = 0;\n        for (int q = 0; q < N; q++)\n        {\n            count += a[q] * (int)pow(3.0, q);\n        } //3進数で今何番地か\n\n        \n        printf(\"%d \",count%all);\n       // member[i] = count % all;\n    }\n\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n\nint main(){\n    int N;\n    char s[200001];\n    char str[200001];\n    int j = 0;\n    int ext;\n    scanf(\"%d %s\", &N, s);\n    \n    int all = (int)pow(3.0, N);\n    int max = strlen(s);\n\n    for (int i = 0; i < max; i++)\n    {\n        str[j] = s[i];\n        if (j > 0 && str[j] == 'S' && str[j - 1] == 'S')\n            j=j-2;//二つセットで消す\n        if(j>0 && str[j]=='R' && str[j-1]!='S'){\n            if(str[j-1]=='R'){ \n                str[j - 1] = '2';\n                j--;\n            }\n            else if (str[j - 1] != '9'){\n                str[j-1] = str[j - 1] + 1;\n                j--;\n            }\n        }\n        j++;\n    } //jが総数\n/*\n    printf(\"\\n----\");\n    for (int i = 0; i < j; i++)\n    {\n        printf(\"%c\", str[i]);\n    }\n    printf(\"\\n----\");\n*/\n    int a[15];\n    for (int i = 0; i < 14; i++)\n    {\n        a[i] = 0;\n    } //初期化\n    \n\n    \n \n    int count = 0;\n    for (int i = 0; i < all; i++)\n    {\n        ext=i;\n        for (int q = 0; q < N; q++)\n        {\n            a[q] = ext % 3;\n            ext = ext / 3;\n        } //3進数\n        for (int q = 0; q < j; q++)\n        {\n            if (str[q] == 'S')\n            {\n        \n                for (int l = 0; l < N; l++)\n                {\n                    a[l] = (a[l] * 2) % 3;\n                } //3進数の回転\n            }\n            else\n            {\n                \n                int kk;\n                if(str[q]=='R')\n                    kk = 1;\n                else\n                    kk = str[q] - 48;//数にす　る\n\n                    a[0] += kk;\n                for (int l = 0; a[l] >= 3; l++)\n                {\n                    kk = a[l] / 3;\n                    a[l] = a[l] % 3;\n                    a[l + 1] += kk;\n                } //繰り上げ\n            }\n           // printf(\"%d番目の人は今%cで%dへ移動\\n\", i, str[q], a[0]);\n        } //Sとか\n\n        count = 0;\n        for (int q = 0; q < N; q++)\n        {\n            count += a[q] * (int)pow(3.0, q);\n        } //3進数で今何番地か\n\n        \n        printf(\"%d \",count%all);\n       // member[i] = count % all;\n    }\n\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\n\nint main()\n{\t\n    int n;\n    scanf(\"%d\\n\",&n);\n    int number=(int)pow(3,n);\n    int place[number];\n    //printf(\"%d\",number);\n    char a[200000];\n    int length=0;\n    gets(a);\t\n    do{\n\t    length++;\n    }while(a[length]!='\\0');\n    for(int i=0;i<number;i++)\n    {\n        place[i]=i;\n    }\n    for(int i=0;i<length;i++)\n    {\n        //printf(\"%c\",a[i]);\n        if(a[i]=='S')\n        {\n            //printf(\"s\");\n            for(int j=0;j<number;j++)\n            {\n                place[j]=salsa(n,place[j]);\n            }\n        }\n        else if (a[i]=='R')\n        {\n            //printf(\"r\");\n            for(int j=0;j<number;j++)\n            {\n                place[j]=place[j]+1;\n                if(place[j]==number)\n                {\n                    place[j]=0;\n                }\n            }\n        } \n    }\n    for(int i=0;i<number;i++)\n    {\n        printf(\"%d \",place[i]);\n    }\n    return 0;\n}\n\nint salsa(int n,int a)\n{\n    int list[n];\n    for(int i=0;i<n;i++)\n    {\n        list[i]=0;\n    }\n    int j=n-1;\n    while(a!=0)\n    {\n        list[j]= a % 3 ;\n        a=a/3;\n        j--;\n    }\n    for(int i=0;i<n;i++)\n    {\n        if(list[i]==1)\n        {\n            list[i]=2;\n        }\n        else if(list[i]==2)\n        {\n            list[i]=1;\n        }\n    }\n    int result=0;\n    for(int i=0;i<n;i++)\n    {\n        result=result+ list[i]*pow(3,(n-1-i));\n    }\n    return result;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint new_pos(int num){\n    int j=1,ans=0;\n    for(j=1;;){\n        if(num<3){\n            if(num==1) ans = ans + 2*j;\n            else if(num==2) ans = ans + 1*j;\n            break;\n\n        }\n        else{\n            if(num%3==1) ans = ans+2*j;\n            else if(num%3==2) ans = ans+1*j;\n            num = num/3;\n        }\n        j=j*3;\n    }\n    return ans;\n}\n\nint main()\n{\n    int n,i,j,r=0,s=0;\n    int pos[531]={},map[531441]={};\n    char t[200000]={};\n    scanf(\"%d\",&n);\n    for(i=0;i<(int)pow(3,n);i++) pos[i]=i;\n    scanf(\"%s\",&t);\n    for(i=0;i<(int)(pow(3,n));i++) map[i]=new_pos(i);        \n    for(i=0;i<(int)pow(3,n);i++) printf(\"%d \",map[i]);\n    printf(\"\\n\");\n    for(i=0;i<=strlen(t);i++){\n        if(s==0&&t[i]=='R') r++;\n        else if(r==0&&t[i]=='S') s++;\n        else if(r!=0&&t[i]!='R'){\n            if(r%(int)pow(3,n)==0) r = 0;\n            else{\n                for(j=0;j<(int)pow(3,n);j++){\n                    pos[j] = (pos[j]+r)%((int)(pow(3,n)));\n                }\n                r = 0;\n            }\n            s++;\n        }\n        else if(s!=0&&t[i]!='S'){\n            if(s%2==0) s = 0;\n            else{\n                for(j=0;j<(int)pow(3,n);j++) pos[j] = map[pos[j]];\n                s = 0;\n            }\n            r++;\n        }\n    }\n    for(i=0;i<(int)pow(3,n);i++) printf(\"%d \",pos[i]);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void)\n{int a,i,m,n,x,y;\n char c[1][200000];\n x=1;\n scanf(\"%d\",&a);\n for(n=0;n<a;n++){x=x*3;}\n int b[x];\n for(i=0;i<x;i++){\n     b[i]=i;\n }\n scanf (\"%s%s\",c);\n   for(m=0;m<200000;m++){y=x;\n       if(c[1][m]==82);{for(i=0;i<x;i++)\n                     {for(n=1;n<a;n++){b[i]=3%(3-(b[i]-b[i]%(x/3)))*x/3;x=x/3;}\n                     }}\n       if(c[1][m]==83);{for(i=0;i<x;i++)\n                     {b[i]=(b[i]+1)%x;}\n                     }\n       if(c[1][m]==0);{break;}\n     }\n     \n     printf(\"%d\\b\",b);\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\n\nint main()\n{\t\n    int n;\n    scanf(\"%d\\n\",&n);\n    int number=(int)pow(3,n);\n    int place[number];\n    //printf(\"%d\",number);\n    char a[200000];\n    int length=0;\n    gets(a);\t\n    do{\n\t    length++;\n    }while(a[length]!='\\0');\n    for(int i=0;i<number;i++)\n    {\n        place[i]=i;\n    }\n    for(int i=0;i<length;i++)\n    {\n        //printf(\"%c\",a[i]);\n        if(a[i]=='S')\n        {\n            //printf(\"s\");\n            for(int j=0;j<number;j++)\n            {\n                place[j]=salsa(n,place[j]);\n            }\n        }\n        else if (a[i]=='R')\n        {\n            //printf(\"r\");\n            for(int j=0;j<number;j++)\n            {\n                place[j]=place[j]+1;\n                if(place[j]==number)\n                {\n                    place[j]=0;\n                }\n            }\n        } \n    }\n    for(int i=0;i<number;i++)\n    {\n        printf(\"%d \",place[i]);\n    }\n    return 0;\n}\n\nint salsa(int n,int a)\n{\n    int list[n];\n    for(int i=0;i<n;i++)\n    {\n        list[i]=0;\n    }\n    int j=n-1;\n    while(a!=0)\n    {\n        list[j]= a % 3 ;\n        a=a/3;\n        j--;\n    }\n    for(int i=0;i<n;i++)\n    {\n        if(list[i]==1)\n        {\n            list[i]=2;\n        }\n        else if(list[i]==2)\n        {\n            list[i]=1;\n        }\n    }\n    int result=0;\n    for(int i=0;i<n;i++)\n    {\n        result=result+ list[i]*pow(3,(n-1-i));\n    }\n    return result;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint salsa(int p)\n{\n  int r=0;\n  int q=0;\n  int a;\n  while(p>0)\n  {\n    a=p%3;\n    if(a==1) r+=2*(int)pow(3,q);\n    if(a==2) r+=(int)pow(3,q);\n    p/=3;\n    q++;\n  }\n  return r;\n}\n\nint main(void)\n{\n  int n,m;\n  int ans[531442];\n  int sal[531442];\n  int a=0;\n  int b=0;\n  char t[200001];\n  int c[200001];\n  int s=0;\n  int r=0;\n\n  scanf(\"%d\",&n);\n  scanf(\"%s\",t);\n\n  m=(int)pow(3,n);\n  for(int i=0;i<m;i++)\n  {\n    ans[i]=i;\n    sal[i]=salsa(i);\n  }\n\n  while(1)\n  {\n    if(t[a]=='S')\n    {\n      if(r>0)\n      {\n        if(c[b-1]>0) c[b-1]+=r;\n        else c[b++]=r;\n        r=0;\n      }\n      s++;\n    }\n    if(t[a]=='R')\n    {\n      if(s>0)\n      {\n        if(s%2==1)\n        {\n          c[b]=0;\n          b++;\n        }\n        s=0;\n      }\n      r++;\n    }\n    if(t[a]=='\\n')\n    {\n      if(r>0) c[b++]=r;\n      else if(s%2==1) c[b++]=0;\n      break;\n    }\n    a++;\n  }\n\n  for(int i=0;i<b;i++)\n  {\n    if(c[i]==0)\n    {\n      for(int j=0;j<m;j++)\n      {\n        ans[j]=sal[ans[j]];\n      }\n    }\n    else\n    {\n      for(int j=0;j<m;j++)\n      {\n        ans[j]=(ans[j]+c[i])%m;\n      }\n    }\n    a++;\n  }\n\n  for(int j=0;j<m;j++)\n  {\n    printf(\"%d\",ans[j]);\n    if(j<m-1) printf(\" \");\n    else printf(\"\\n\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n\nint main(){\n    int N;\n    char s[20000];\n    char str[20000];\n    int j = 0;\n    int ext;\n    scanf(\"%d %s\", &N, s);\n    \n    int all = (int)pow(3.0, N);\n    int max = strlen(s);\n\n    for (int i = 0; i < max; i++)\n    {\n        str[j] = s[i];\n        if (j > 0 && str[j] == 'S' && str[j - 1] == 'S')\n            j=j-2;//二つセットで消す\n        else if (str[j] == '\\0')\n            break;\n        j++;\n    } //jが総数\n\n    /*printf(\"\\n----\");\n    for (int i = 0; i < j; i++)\n    {\n        printf(\"%c\", str[i]);\n    }\n    printf(\"\\n----\");\n*/\n    int a[15];\n    for (int i = 0; i < 14; i++)\n    {\n        a[i] = 0;\n    } //初期化\n    \n\n    \n \n    int count = 0;\n    for (int i = 0; i < all; i++)\n    {\n        ext=i;\n        for (int q = 0; q < N; q++)\n        {\n            a[q] = ext % 3;\n            ext = ext / 3;\n        } //3進数\n        for (int q = 0; q < j; q++)\n        {\n            if (str[q] == 'R')\n            {\n                a[0] += 1;\n                for (int l = 0; a[l] == 3; l++)\n                {\n                    a[l] = 0;\n                    a[l + 1] += 1;\n                } //繰り上げ\n            }\n            else\n            {\n                for (int l = 0; l < N; l++)\n                {\n                    a[l] = (a[l] * 2) % 3;\n                } //3進数の回転\n            }\n           // printf(\"%d番目の人は今%cで%dへ移動\\n\", i, str[q], a[0]);\n        } //Sとか\n\n        count = 0;\n        for (int q = 0; q < N; q++)\n        {\n            count += a[q] * (int)pow(3.0, q);\n        } //3進数で今何番地か\n\n        \n        printf(\"%d \",count%all);\n       // member[i] = count % all;\n    }\n\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint new_pos(int num){\n    int j=1,ans=0;\n    for(j=1;;){\n        if(num<3){\n            if(num==1) ans = ans + 2*j;\n            else if(num==2) ans = ans + 1*j;\n            break;\n\n        }\n        else{\n            if(num%3==1) ans = ans+2*j;\n            else if(num%3==2) ans = ans+1*j;\n            num = num/3;\n        }\n        j=j*3;\n    }\n    return ans;\n}\n\nint main()\n{\n    int n,i,j,r=0,s=0;\n    int pos[531441]={};\n    char t[200000]={};\n    scanf(\"%d\",&n);\n    for(i=0;i<(int)pow(3,n);i++) pos[i]=i;\n    scanf(\"%s\",&t);\n    for(i=0;i<=strlen(t);i++){\n        if(s==0&&t[i]=='R') r++;\n        else if(r==0&&t[i]=='S') s++;\n        else if(r!=0&&t[i]!='R'){\n            for(j=0;j<(int)pow(3,n);j++){\n                pos[j] = (pos[j]+r)%((int)(pow(3,n)));\n            }\n            r = 0;\n            s++;\n        }\n        else if(s!=0&&t[i]!='S'){\n            if(s%2==0) s = 0;\n            else{\n                for(j=0;j<(int)pow(3,n);j++) pos[j] = new_pos(pos[j]);\n                s = 0;\n            }\n            r++;\n        }\n    }\n    for(i=0;i<(int)pow(3,n);i++) printf(\"%d \",pos[i]);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\nint convert(int x, int n){\n    int y=0, i=0, z;\n    while(x > 0){\n        z = x%n;\n        if(z == 1){\n          z = 2;\n        }else if(z==2){\n          z = 1;\n        }\n        y += z*pow(n, i);\n        x = x/n;\n        i++;\n    }\n    return y;\n}\n\nint main()\n{\n  int n;\n  scanf(\"%d\", &n);\n  char t[200001];\n  scanf(\"%s\", t);\n\n  int shuturyoku;\n  \n  for(int i = 0; i < pow(3, n); i++){\n    shuturyoku = i;\n    for(int j = 0; j < strlen(t); j++){\n      if(t[j] == 'S'){\n        shuturyoku = convert(shuturyoku, 3);\n      }else if(t[j] == 'R'){\n        if(shuturyoku == pow(3,n)-1){\n          shuturyoku = 0;\n        }else{\n          shuturyoku = shuturyoku+1;\n        }\n      } \n      // printf(\"%d \", shuturyoku);\n    }\n    printf(\"%d \", shuturyoku);\n    // printf(\"\\n\");\n  }\n  printf(\"\\n\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint new_pos(int num){\n    int j=1,ans=0;\n    for(j=1;;){\n        if(num<3){\n            if(num==1) ans = ans + 2*j;\n            else if(num==2) ans = ans + 1*j;\n            break;\n\n        }\n        else{\n            if(num%3==1) ans = ans+2*j;\n            else if(num%3==2) ans = ans+1*j;\n            num = num/3;\n        }\n        j=j*3;\n    }\n    return ans;\n}\n\nint main()\n{\n    int n,i,j,r=0,s=0;\n    int pos[531441]={};\n    char t[200000]={};\n    scanf(\"%d\",&n);\n    for(i=0;i<(int)pow(3,n);i++) pos[i]=i;\n    scanf(\"%s\",&t);\n    for(i=0;i<=strlen(t);i++){\n        if(s==0&&t[i]=='R') r++;\n        else if(r==0&&t[i]=='S') s++;\n        else if(r!=0&&t[i]!='R'){\n            if(r%(int)pow(3,n)==0) r = 0;\n            else{\n                for(j=0;j<(int)pow(3,n);j++){\n                    pos[j] = (pos[j]+r)%((int)(pow(3,n)));\n                }\n                r = 0;\n            }\n            s++;\n        }\n        else if(s!=0&&t[i]!='S'){\n            if(s%2==0) s = 0;\n            else{\n                for(j=0;j<(int)pow(3,n);j++) pos[j] = new_pos(pos[j]);\n                s = 0;\n            }\n            r++;\n        }\n    }\n    for(i=0;i<(int)pow(3,n);i++) printf(\"%d \",pos[i]);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\nint convert(int x, int n){\n    int y=0, i=0, z;\n    while(x > 0){\n        z = x%n;\n        if(z == 1){\n          z = 2;\n        }else if(z==2){\n          z = 1;\n        }\n        y += z*pow(n, i);\n        x = x/n;\n        i++;\n    }\n    return y;\n}\n\nint main()\n{\n  int n;\n  scanf(\"%d\", &n);\n  char t[200001];\n  scanf(\"%s\", t);\n\n  int shuturyoku1, shuturyoku2;\n    for(int j = 0; j < strlen(t); j = j+2){\n      if(t[j] == 'S'){\n        shuturyoku1 = convert(shuturyoku1, 3);\n        shuturyoku2 = convert(shuturyoku2, 3);\n      }else if(t[j] == 'R'){\n        if(shuturyoku1 == pow(3,n)-1){\n          shuturyoku1 = 0;\n          shuturyoku2 = shuturyoku2+1;\n        }else if(shuturyoku2 == pow(3,n)-1){\n          shuturyoku2 = 0;\n          shuturyoku1 = shuturyoku1+1;\n        }else{\n          shuturyoku1 = shuturyoku1+1;\n          shuturyoku2 = shuturyoku2+1;\n        }\n      } \n      // printf(\"%d \", shuturyoku);\n    }\n    printf(\"%d \", shuturyoku1);\n    printf(\"%d \", shuturyoku2);\n    // printf(\"\\n\");\n  printf(\"\\n\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main()\n{\n\tint n,i,t,ans=0;\n\tscanf(\"%d\",&n);\n\tif(n==1)printf(\"2 0 1\");\n\tif(n==2)printf(\"3 8 1 0 5 7 6 2 4\");\n\tif(n==3)printf(\"23 9 22 8 3 7 20 24 19 5 18 4 17 12 16 2 6 1 14 0 13 26 21 25 11 15 10\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\n\nint main()\n{\t\n    int n;\n    scanf(\"%d\\n\",&n);\n    int number=(int)pow(3,n);\n    int place[number];\n    //printf(\"%d\",number);\n    char a[200000];\n    int length=0;\n    gets(a);\t\n    do{\n\t    length++;\n    }while(a[length]!='\\0');\n    for(int i=0;i<number;i++)\n    {\n        place[i]=i;\n    }\n    for(int i=0;i<length;i++)\n    {\n        //printf(\"%c\",a[i]);\n        if(a[i]=='S')\n        {\n            //printf(\"s\");\n            for(int j=0;j<number;j++)\n            {\n                place[j]=salsa(n,place[j]);\n            }\n        }\n        else if (a[i]=='R')\n        {\n            //printf(\"r\");\n            for(int j=0;j<number;j++)\n            {\n                place[j]=place[j]+1;\n                if(place[j]==number)\n                {\n                    place[j]=0;\n                }\n            }\n        } \n    }\n    for(int i=0;i<number;i++)\n    {\n        printf(\"%d \",place[i]);\n    }\n    return 0;\n}\n\nint salsa(int n,int a)\n{\n    int list[n];\n    for(int i=0;i<n;i++)\n    {\n        list[i]=0;\n    }\n    int j=n-1;\n    while(a!=0)\n    {\n        list[j]= a % 3 ;\n        a=a/3;\n        j--;\n    }\n    for(int i=0;i<n;i++)\n    {\n        if(list[i]==1)\n        {\n            list[i]=2;\n        }\n        else if(list[i]==2)\n        {\n            list[i]=1;\n        }\n    }\n    int result=0;\n    for(int i=0;i<n;i++)\n    {\n        result=result+ list[i]*pow(3,(n-1-i));\n    }\n    return result;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n#include <limits.h>\nint main(){\n    int i,count,p[600000];\n    double n;\n    char t[200020]={};\n    scanf(\"%lf %s\",&n,t);\n    count=pow(3,n);\n    for(i=0; i<count; i++){\n        p[i]=i;\n    }\n    for(i=0; i<count; i++){\n        printf(\"%d \",p[i]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\nint convert(int x, int n){\n    int y=0, i=0, z;\n    while(x > 0){\n        z = x%n;\n        if(z == 1){\n          z = 2;\n        }else if(z==2){\n          z = 1;\n        }\n        y += z*pow(n, i);\n        x = x/n;\n        i++;\n    }\n    return y;\n}\n\nint main()\n{\n  int n;\n  scanf(\"%d\", &n);\n  char t[200001];\n  scanf(\"%s\", t);\n\n  int shuturyoku;\n    for(int j = 0; j < strlen(t); j++){\n      shuturyoku = j;\n      if(t[j] == 'S'){\n        shuturyoku = convert(shuturyoku, 3);\n      }else if(t[j] == 'R'){\n        if(shuturyoku == pow(3,n)-1){\n          shuturyoku = 0;\n        }else{\n          shuturyoku = shuturyoku+1;\n        }\n      } \n      // printf(\"%d \", shuturyoku);\n    }\n    printf(\"%d \", shuturyoku);\n    // printf(\"\\n\");\n  printf(\"\\n\");\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint salsa(int p)\n{\n  int r=0;\n  int q=0;\n  int a;\n  while(p>0)\n  {\n    a=p%3;\n    if(a==1) r+=2*(int)pow(3,q);\n    if(a==2) r+=(int)pow(3,q);\n    p/=3;\n    q++;\n  }\n  return r;\n}\n\nint main(void)\n{\n  int n,m;\n  int ans[531442];\n  int sal[531442];\n  int a=0;\n  int b=0;\n  char t[200001];\n  int c[200001];\n  int s=0;\n  int r=0;\n\n  scanf(\"%d\",&n);\n  scanf(\"%s\",t);\n\n  m=(int)pow(3,n);\n  for(int i=0;i<m;i++)\n  {\n    ans[i]=i;\n    sal[i]=salsa(i);\n  }\n\n  while(1)\n  {\n    if(t[a]=='S')\n    {\n      if(r>0)\n      {\n        if(b>0 && c[b-1]>0) c[b-1]+=r;\n        else c[b++]=r;\n        r=0;\n      }\n      s++;\n    }\n    if(t[a]=='R')\n    {\n      if(s>0)\n      {\n        if(s%2==1) c[b++]=0;\n        s=0;\n      }\n      r++;\n    }\n    if(t[a]=='\\n')\n    {\n      if(r>0) c[b++]=r;\n      else if(s%2==1) c[b++]=0;\n      break;\n    }\n    a++;\n  }\n\n  for(int i=0;i<b;i++)\n  {\n    if(c[i]==0)\n    {\n      for(int j=0;j<m;j++)\n      {\n        ans[j]=sal[ans[j]];\n      }\n    }\n    else\n    {\n      for(int j=0;j<m;j++)\n      {\n        ans[j]=(ans[j]+c[i])%m;\n      }\n    }\n    a++;\n  }\n\n  for(int j=0;j<m;j++)\n  {\n    printf(\"%d\",ans[j]);\n    if(j<m-1) printf(\" \");\n    else printf(\"\\n\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  long long n;\n  scanf(\"%lld\",&n);\n  if (n==1) printf(\"2 0 1\");else\n    if (n==2) printf(\"3 8 1 0 5 7 6 2 4\");else\n      if (n==3) printf(\"23 9 22 8 3 7 20 24 19 5 18 4 17 12 16 2 6 1 14 0 13 26 21 25 11 15 10\");else\n              printf(\"-1\");\n              \n  \n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n\nint main(){\n    int N;\n    char s[200001];\n    char str[200001];\n    int j = 0;\n    int ext;\n    scanf(\"%d %s\", &N, s);\n    \n    int all = (int)pow(3.0, N);\n    int max = strlen(s);\n\n    for (int i = 0; i < max; i++)\n    {\n        str[j] = s[i];\n        if (j > 0 && str[j] == 'S' && str[j - 1] == 'S')\n            j=j-2;//二つセットで消す\n        if(j>0 && str[j]=='R' && str[j-1]!='S'){\n            if(str[j-1]=='R'){ \n                str[j - 1] = '2';\n                j--;\n            }\n            else if (str[j - 1] != 125){\n                str[j-1] = str[j - 1] + 1;\n                j--;\n            }\n        }\n        j++;\n    } //jが総数\n/*\n    printf(\"\\n----\");\n    for (int i = 0; i < j; i++)\n    {\n        printf(\"%c\", str[i]);\n    }\n    printf(\"\\n----\");\n*/\n    int a[15];\n    for (int i = 0; i < 14; i++)\n    {\n        a[i] = 0;\n    } //初期化\n    \n\n    \n \n    int count = 0;\n    for (int i = 0; i < all; i++)\n    {\n        ext=i;\n        for (int q = 0; q < N; q++)\n        {\n            a[q] = ext % 3;\n            ext = ext / 3;\n        } //3進数\n        for (int q = 0; q < j; q++)\n        {\n            if (str[q] == 'S')\n            {\n        \n                for (int l = 0; l < N; l++)\n                {\n                    a[l] = (a[l] * 2) % 3;\n                } //3進数の回転\n            }\n            else\n            {\n                \n                int kk;\n                if(str[q]=='R')\n                    kk = 1;\n                else\n                    kk = str[q] - 48;//数にす　る\n\n                    a[0] += kk;\n                for (int l = 0; a[l] >= 3; l++)\n                {\n                    kk = a[l] / 3;\n                    a[l] = a[l] % 3;\n                    a[l + 1] += kk;\n                } //繰り上げ\n            }\n           // printf(\"%d番目の人は今%cで%dへ移動\\n\", i, str[q], a[0]);\n        } //Sとか\n\n        count = 0;\n        for (int q = 0; q < N; q++)\n        {\n            count += a[q] * (int)pow(3.0, q);\n        } //3進数で今何番地か\n\n        \n        printf(\"%d \",count%all);\n       // member[i] = count % all;\n    }\n\n    printf(\"\\n\");\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "//C\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid revstr(char* str);\nvoid ternary(int i, char *t);\nint decimai(char *j);\nvoid salsa(int *P,int max);\nvoid rumba(int *P,int max);\n\nint main(void){\n    int N,max,l,k=0;\n    char T[200000];\n    int P[531441];\n    \n    scanf(\"%d\",&N);\n    scanf(\"%s\",T);\n    \n    max=(int)pow(3,N);\n    for(k=0;k<max;k++)\n        P[k]=k;\n    k=0;\n    while(T[k]!='\\0'){\n        if(T[k]=='S')\n            salsa(P,max);\n        else if(T[k]=='R')\n            rumba(P,max);\n        k++;\n    }\n    for(k=0;k<max;k++){\n        for(l=0;l<max&&P[l]!=k;l++);\n        if(k!=max-1)printf(\"%d \",l);\n    }\n    printf(\"%d\\n\",l);\n    return 0;\n}\n\nvoid revstr(char* str){\n\tint size = strlen(str);\n\tint i,j;\n\tchar tmp = {0};\n\t\n\tfor(i = 0, j = size - 1; i < size / 2; i++, j--){\n\t\ttmp = str[i];\n\t\tstr[i] = str[j];\n\t\tstr[j] = tmp;\n\t}\n\t\n\treturn;\t\n}\n\nvoid ternary(int i, char *t){\n    int count=0;\n    while(i/3>=0){\n        char tmp[2];\n        sprintf(tmp, \"%d\", i%3);\n        if(i%3==1)\n            t[count++]='2';\n        else if(i%3==2)\n            t[count++]='1';\n        else\n            t[count++]=tmp[0];\n            \n        if(i/3==0)\n            break;\n            \n        i/=3;\n    }\n    t[count]='\\0';\n    revstr(t);\n}\n\nint decimai(char *j){\n    int len=strlen(j);\n    int count;\n    int d=0;\n    for(count=0;count<len;count++){\n        char tmp[2];\n        tmp[0]=j[count];\n        tmp[1]='\\0';\n        d+=(int)pow(3,len-count-1)*atoi(tmp);\n    }\n    \n    return d;\n}\nvoid salsa(int *P,int max){\n    int i,tmp[531441];\n    char t[20];\n    for(i=0;i<max;i++){\n        ternary(i,t);\n        tmp[decimai(t)]=P[i];\n    }\n    for(i=0;i<max;i++)\n        P[i]=tmp[i];\n}\nvoid rumba(int *P,int max){\n    int i,tmp[531441];\n    for(i=0;i<max-1;i++){\n        tmp[i+1]=P[i];\n    }\n    tmp[0]=P[max-1];\n    for(i=0;i<max;i++)\n        P[i]=tmp[i];\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    public static void main(String arg[]){\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            String str;\n            str = br.readLine();\n            int N = Integer.parseInt(str);\n            double num = Math.pow(3,N);\n            str=br.readLine();\n            String sequence=str;\n\n            int[] circle = new int[(int) num];\n            for(int i=0;i<circle.length;i++){\n                circle[i]=i;\n            }\n            int[] circle2 = circle.clone();\n            int headFlag=0;\n            int endFlag=circle.length-1;\n            for(int i=0;i<sequence.length();i++){\n                char song=sequence.charAt(i);\n                if(song=='R'){\n                    for(int j=0;j<circle.length;j++){\n                        if(circle[j]==circle.length-1){\n                            endFlag=j;\n                            break;\n                        }\n                    }\n                    for(int j=0;j<circle.length;j++){\n                        if(j==endFlag){\n                            circle[j]=0;\n                            endFlag=endFlag-1;\n                            headFlag=j;\n                        }else {\n                            circle[j]++;\n                        }\n                    }\n                    circle2=circle.clone();\n                }else {\n                    for(int j=0;j<circle.length;j++){\n                        int sum=0;\n                        String tmp =Integer.toString(circle[j],3);\n                        for(int t=0;t<tmp.length();t++){\n                            if(tmp.charAt(tmp.length()-1-t)=='0'){\n                                sum+=0;\n                            }else if(tmp.charAt(tmp.length()-1-t)=='1'){\n                                sum+=(int) (2*Math.pow(3,t));\n                            }else {\n                                sum+=(int) (1*Math.pow(3,t));\n                            }\n                        }\n                        int flag=0;\n                        for(int t=0;t<circle.length;t++){\n                            if(circle2[t]==sum){\n                                flag=t;\n                            }\n                        }\n                        circle[j]=circle2[flag];\n                    }\n                    circle2=circle.clone();\n                }\n            }\n            for(int i=0;i<circle.length;i++){\n                if(i==circle.length){\n                    System.out.println(circle[i]);\n                }else {\n                    System.out.print(circle[i] + \" \");\n                }\n            }\n        }catch (IOException e){\n            e.printStackTrace();;\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class testtes {\n    public static void main(String arg[]){\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            String str;\n            str = br.readLine();\n            int N = Integer.parseInt(str);\n            double num = Math.pow(3,N);\n            str=br.readLine();\n            String sequence=str;\n\n            int[] circle = new int[(int) num];\n            for(int i=0;i<circle.length;i++){\n                circle[i]=i;\n            }\n            int[] circle2 = circle.clone();\n            int headFlag=0;\n            int endFlag=circle.length-1;\n            for(int i=0;i<sequence.length();i++){\n                char song=sequence.charAt(i);\n                if(song=='R'){\n                    for(int j=0;j<circle.length;j++){\n                        if(circle[j]==circle.length-1){\n                            endFlag=j;\n                            break;\n                        }\n                    }\n                    for(int j=0;j<circle.length;j++){\n                        if(j==endFlag){\n                            circle[j]=0;\n                            endFlag=endFlag-1;\n                            headFlag=j;\n                        }else {\n                            circle[j]++;\n                        }\n                    }\n                    circle2=circle.clone();\n                }else {\n                    for(int j=0;j<circle.length;j++){\n                        int sum=0;\n                        String tmp =Integer.toString(circle[j],3);\n                        for(int t=0;t<tmp.length();t++){\n                            if(tmp.charAt(tmp.length()-1-t)=='0'){\n                                sum+=0;\n                            }else if(tmp.charAt(tmp.length()-1-t)=='1'){\n                                sum+=(int) (2*Math.pow(3,t));\n                            }else {\n                                sum+=(int) (1*Math.pow(3,t));\n                            }\n                        }\n                        int flag=0;\n                        for(int t=0;t<circle.length;t++){\n                            if(circle2[t]==sum){\n                                flag=t;\n                            }\n                        }\n                        circle[j]=circle2[flag];\n                    }\n                    circle2=circle.clone();\n                }\n            }\n            for(int i=0;i<circle.length;i++){\n                if(i==circle.length){\n                    System.out.println(circle[i]);\n                }else {\n                    System.out.print(circle[i] + \" \");\n                }\n            }\n        }catch (IOException e){\n            e.printStackTrace();;\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "pubulic"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main (String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint length = (int)(Math.pow(3, n));\n\t\tPerson.size = n;\n\t\tPerson[] persons = new Person[length];\n\t\tfor (int i = 0; i < length; i++) {\n\t\t    persons[i] = new Person(i);\n\t\t}\n\t\tArrayList<Integer> list = new ArrayList<>();\n\t\tchar[] arr = sc.next().toCharArray();\n\t\tint count = 0;\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t    if (arr[i] == 'R') {\n\t\t        count++;\n\t\t    } else {\n\t\t        if (i < arr.length - 1 && arr[i + 1] == 'S') {\n\t\t            i++;\n\t\t        } else {\n\t\t            list.add(count);\n\t\t            count = 0;\n\t\t        }\n\t\t    }\n\t\t}\n\t\tlist.add(count);\n\t\tint[] arrList = new int[list.size()];\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t    arrList[i] = list.get(i);\n\t\t}\n\t\tPerson.list = arrList;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < length; i++) {\n\t\t    if (i > 0) {\n\t\t        sb.append(\" \");\n\t\t    }\n\t\t    persons[i].calc();\n\t\t    sb.append(persons[i].getValue());\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\t\n\tstatic class Person {\n\t    static int size;\n\t    static int[] list;\n\t    int[] base;\n\t    \n\t    public Person(int value) {\n\t        base = new int[size];\n\t        for (int i = 0; i < size && value > 0; i++) {\n\t            base[i] = value % 3;\n\t            value /= 3;\n\t        }\n\t    }\n\t    \n\t    public void calc() {\n\t        int idx = 0;\n\t        while (list.length - idx > 2) {\n\t            int first = list[idx];\n\t            int second = list[idx + 1];\n\t            for (int i = 0; i < size && (first > 0 || second > 0); i++) {\n\t                int modF = first % 3;\n\t                int modS = second % 3;\n\t                first /= 3;\n\t                second /= 3;\n\t                if (modF == 0 && modS == 0) {\n\t                    continue;\n\t                }\n\t                if (base[i] == 0) {\n\t                    if (modF == 0 && modS == 1) {\n\t                        base[i] = 2;\n\t                    } else if (modF == 0 && modS == 2) {\n\t                        base[i] = 1;\n\t                    } else if (modF == 1 && modS == 0) {\n\t                        base[i] = 1;\n\t                    } else if (modF == 1 && modS == 1) {\n\t                        base[i] = 0;\n\t                        second++;\n\t                    } else if (modF == 1 && modS == 2) {\n\t                        base[i] = 2;\n\t                        second++;\n\t                    } else if (modF == 2 && modS == 0) {\n\t                        base[i] = 2;\n\t                    } else if (modF == 2 && modS == 1) {\n\t                        base[i] = 1;\n\t                    } else if (modF == 2 && modS == 2) {\n\t                        base[i] = 0;\n\t                        second++;\n\t                    }\n\t                } else if (base[i] == 1) {\n\t                    if (modF == 0 && modS == 1) {\n\t                        base[i] = 0;\n\t                        second++;\n\t                    } else if (modF == 0 && modS == 2) {\n\t                        base[i] = 2;\n\t                        second++;\n\t                    } else if (modF == 1 && modS == 0) {\n\t                        base[i] = 2;\n\t                    } else if (modF == 1 && modS == 1) {\n\t                        base[i] = 1;\n\t                    } else if (modF == 1 && modS == 2) {\n\t                        base[i] = 0;\n\t                        second++;\n\t                    } else if (modF == 2 && modS == 0) {\n\t                        base[i] = 0;\n\t                        first++;\n\t                    } else if (modF == 2 && modS == 1) {\n\t                        base[i] = 2;\n\t                        first++;\n\t                    } else if (modF == 2 && modS == 2) {\n\t                        base[i] = 1;\n\t                        first++;\n\t                    }\n\t                } else if (base[i] == 2) {\n\t                    if (modF == 0 && modS == 1) {\n\t                        base[i] = 1;\n\t                    } else if (modF == 0 && modS == 2) {\n\t                        base[i] = 0;\n\t                        second++;\n\t                    } else if (modF == 1 && modS == 0) {\n\t                        base[i] = 0;\n\t                        first++;\n\t                    } else if (modF == 1 && modS == 1) {\n\t                        base[i] = 2;\n\t                        first++;\n\t                    } else if (modF == 1 && modS == 2) {\n\t                        base[i] = 1;\n\t                        first++;\n\t                    } else if (modF == 2 && modS == 0) {\n\t                        base[i] = 1;\n\t                        first++;\n\t                    } else if (modF == 2 && modS == 1) {\n\t                        base[i] = 0;\n\t                        first++;\n\t                        second++;\n\t                    } else if (modF == 2 && modS == 2) {\n\t                        base[i] = 2;\n\t                        first++;\n\t                        second++;\n\t                    }\n\t                }\n\t            }\n\t            idx += 2;\n\t        }\n\t        if (list.length - idx == 2) {\n\t            int x = list[idx];\n\t            for (int i = 0; i < size; i++) {\n\t                if (x > 0) {\n    \t                int mod = x % 3;\n    \t                x /= 3;\n                        if (base[i] + mod >= 3) {\n                            x++;\n                        }\n                        base[i] = (base[i] + mod) % 3;\n\t                }\n\t                if (base[i] == 1) {\n\t                    base[i] = 2;\n\t                } else if (base[i] == 2) {\n\t                    base[i] = 1;\n\t                }\n\t            }\n\t            idx++;\n\t        }\n            int x = list[idx];\n            for (int i = 0; i < size && x > 0; i++) {\n                int mod = x % 3;\n                x /= 3;\n                if (base[i] + mod >= 3) {\n                    x++;\n                }\n                base[i] = (base[i] + mod) % 3;\n            }\n \t    }\n\t    \n\t    public int getValue() {\n\t        int ans = 0;\n\t        for (int i = size - 1; i >= 0; i--) {\n\t            ans *= 3;\n\t            ans += base[i];\n\t        }\n\t        return ans;\n\t    }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner scanner = new Scanner(System.in)) {\n\t\t\tint N = scanner.nextInt();\n\t        String str = scanner.next(); //例：SSRSSSRR\n\t        String dances[] = new String[str.length()];\n\t        for (int i = 0; i < dances.length; i++) {\n\t          dances[i] = str.substring(i, i + 1);\n\t        }\n\n\t        // positionの初期値\n\t        Integer positions[] = new Integer[((int)Math.pow(3, N))];\n\t        for (int i = 0, len = positions.length; i < len; i++) {\n\t        \tpositions[i] = i;\n\t        }\n\n\t        for (String dance : dances) {\n\t        \tInteger newPositions[] = new Integer[positions.length];\n\t        \tif (\"R\".equals(dance)) {\n\t    \t        for (int i = 0, len = positions.length; i < len; i++) {\n\t    \t        \tif (i == len - 1) {\n\t    \t        \t\tnewPositions[0] = positions[i];\n\t    \t        \t} else {\n\t\t    \t        \tnewPositions[i + 1] = positions[i];\n\t    \t        \t}\n\t    \t        }\n\t        \t} else {\n\t    \t        for (int i = 0, len = positions.length; i < len; i++) {\n\t    \t        \t//int iPersonNum = positions[i];\n\t    \t        \tString sanShinsus[] = Integer.toString(i, 3).split(\"\");\n\t    \t        \tfor (int j = 0; j < sanShinsus.length; j++) {\n\t    \t        \t\tif (\"1\".equals(sanShinsus[j])) {\n\t    \t        \t\t\tsanShinsus[j] = \"2\";\n\t    \t        \t\t} else if (\"2\".equals(sanShinsus[j])) {\n\t    \t        \t\t\tsanShinsus[j] = \"1\";\n\t    \t        \t\t}\n\t    \t        \t}\n\t    \t        \tint newIPersonNum = Integer.parseInt(String.join(\"\", sanShinsus), 3);\n\t    \t        \tnewPositions[newIPersonNum] = positions[i];\n\t    \t        }\n\t        \t}\n    \t        positions = newPositions;\n\t        }\n\t        String result = \"\";\n\t        for (int i = 0, len = positions.length; i < len; i++) {\n\t        \tresult += \" \" + Arrays.asList(positions).indexOf(i);\n\t        }\n\t        result = result.substring(1);\n\t        System.out.print(result);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner scanner = new Scanner(System.in)) {\n\t\t\tint N = scanner.nextInt();\n\t        String str = scanner.next(); //例：SSRSSSRR\n\t        String dances[] = new String[str.length()];\n\t        for (int i = 0; i < dances.length; i++) {\n\t          dances[i] = str.substring(i, i + 1);\n\t        }\n\n\t        // positionの初期値\n\t        Integer positions[] = new Integer[((int)Math.pow(3, N))];\n\t        for (int i = 0, len = positions.length; i < len; i++) {\n\t        \tpositions[i] = i;\n\t        }\n\n\t        for (String dance : dances) {\n\t        \tInteger newPositions[] = new Integer[positions.length];\n\t        \tif (\"R\".equals(dance)) {\n\t    \t        for (int i = 0, len = positions.length; i < len; i++) {\n\t    \t        \tif (i == len - 1) {\n\t    \t        \t\tnewPositions[0] = positions[i];\n\t    \t        \t} else {\n\t\t    \t        \tnewPositions[i + 1] = positions[i];\n\t    \t        \t}\n\t    \t        }\n\t        \t} else {\n\t    \t        for (int i = 0, len = positions.length; i < len; i++) {\n\t    \t        \tint iPersonNum = positions[i];\n\t    \t        \tString sanShinsus[] = Integer.toString(iPersonNum, 3).split(\"\");\n\t    \t        \tfor (int j = 0; j < sanShinsus.length; j++) {\n\t    \t        \t\tif (\"1\".equals(sanShinsus[j])) {\n\t    \t        \t\t\tsanShinsus[j] = \"2\";\n\t    \t        \t\t} else if (\"2\".equals(sanShinsus[j])) {\n\t    \t        \t\t\tsanShinsus[j] = \"1\";\n\t    \t        \t\t}\n\t    \t        \t}\n\t    \t        \tint newIPersonNum = Integer.parseInt(String.join(\"\", sanShinsus), 3);\n\t    \t        \tnewPositions[Arrays.asList(positions).indexOf(newIPersonNum)] = positions[i];\n\t    \t        }\n\t        \t}\n    \t        positions = newPositions;\n\t        }\n\t        String result = \"\";\n\t        for (int position : positions) {\n\t        \tresult += \" \" + position;\n\t        }\n\t        result = result.substring(1);\n\t        System.out.print(result);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main (String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint length = (int)(Math.pow(3, n));\n\t\tPerson.size = n;\n\t\tPerson[] persons = new Person[length];\n\t\tfor (int i = 0; i < length; i++) {\n\t\t    persons[i] = new Person(i);\n\t\t}\n\t\tArrayList<Integer> list = new ArrayList<>();\n\t\tchar[] arr = sc.next().toCharArray();\n\t\tint count = 0;\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t    if (arr[i] == 'R') {\n\t\t        count++;\n\t\t    } else {\n\t\t        if (i < arr.length - 1 && arr[i + 1] == 'S') {\n\t\t            i++;\n\t\t        } else {\n\t\t            list.add(count);\n\t\t            count = 0;\n\t\t        }\n\t\t    }\n\t\t}\n\t\tlist.add(count);\n\t\tPerson.list = list;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < length; i++) {\n\t\t    if (i > 0) {\n\t\t        sb.append(\" \");\n\t\t    }\n\t\t    persons[i].calc();\n\t\t    sb.append(persons[i].getValue());\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\t\n\tstatic class Person {\n\t    static int size;\n\t    static ArrayList<Integer> list;\n\t    int[] base;\n\t    \n\t    public Person(int value) {\n\t        base = new int[size];\n\t        for (int i = 0; i < size && value > 0; i++) {\n\t            base[i] = value % 3;\n\t            value /= 3;\n\t        }\n\t    }\n\t    \n\t    public void calc() {\n\t        for (int i = 0; i < list.size(); i++) {\n\t            int x = list.get(i);\n\t            for (int j = 0; j < size && x > 0; j++) {\n\t                int mod = x % 3;\n\t                x /= 3;\n                    if (base[j] + mod >= 3) {\n                        x++;\n                    }\n                    base[j] = (base[j] + mod) % 3;\n\t            }\n\t            if (i >= list.size() - 1) {\n\t                break;\n\t            }\n\t            for (int j = 0; j < size; j++) {\n\t                if (base[j] == 2) {\n\t                    base[j] = 1;\n\t                } else if (base[j] == 1) {\n\t                    base[j] = 2;\n\t                }\n\t            }\n\t        }\n\t    }\n\t    \n\t    public int getValue() {\n\t        int ans = 0;\n\t        for (int i = size - 1; i >= 0; i--) {\n\t            ans *= 3;\n\t            ans += base[i];\n\t        }\n\t        return ans;\n\t    }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main (String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint length = (int)(Math.pow(3, n));\n\t\tPerson.size = n;\n\t\tPerson[] persons = new Person[length];\n\t\tfor (int i = 0; i < length; i++) {\n\t\t    persons[i] = new Person(i);\n\t\t}\n\t\tArrayList<Integer> list = new ArrayList<>();\n\t\tchar[] arr = sc.next().toCharArray();\n\t\tint count = 0;\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t    if (arr[i] == 'R') {\n\t\t        count++;\n\t\t    } else {\n\t\t        if (i < arr.length - 1 && arr[i + 1] == 'S') {\n\t\t            i++;\n\t\t        } else {\n\t\t            list.add(count);\n\t\t            count = 0;\n\t\t        }\n\t\t    }\n\t\t}\n\t\tlist.add(count);\n\t\tPerson.list = list;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < length; i++) {\n\t\t    if (i > 0) {\n\t\t        sb.append(\" \");\n\t\t    }\n\t\t    persons[i].calc();\n\t\t    sb.append(persons[i].getValue());\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\t\n\tstatic class Person {\n\t    static int size;\n\t    static ArrayList<Integer> list;\n\t    int[] base;\n\t    \n\t    public Person(int value) {\n\t        base = new int[size];\n\t        for (int i = 0; i < size && value > 0; i++) {\n\t            base[i] = value % 3;\n\t            value /= 3;\n\t        }\n\t    }\n\t    \n\t    public void calc() {\n\t        int idx = 0;\n\t        while (list.size() - idx > 2) {\n\t            int first = list.get(idx);\n\t            int second = list.get(idx + 1);\n\t            for (int i = 0; i < size && (first > 0 || second > 0); i++) {\n\t                int modF = first % 3;\n\t                int modS = second % 3;\n\t                first /= 3;\n\t                second /= 3;\n\t                if (modF == 0 && modS == 0) {\n\t                    continue;\n\t                }\n\t                if (base[i] == 0) {\n\t                    if (modF == 0 && modS == 1) {\n\t                        base[i] = 2;\n\t                    } else if (modF == 0 && modS == 2) {\n\t                        base[i] = 1;\n\t                    } else if (modF == 1 && modS == 0) {\n\t                        base[i] = 1;\n\t                    } else if (modF == 1 && modS == 1) {\n\t                        base[i] = 0;\n\t                        second++;\n\t                    } else if (modF == 1 && modS == 2) {\n\t                        base[i] = 2;\n\t                        second++;\n\t                    } else if (modF == 2 && modS == 0) {\n\t                        base[i] = 2;\n\t                    } else if (modF == 2 && modS == 1) {\n\t                        base[i] = 1;\n\t                    } else if (modF == 2 && modS == 2) {\n\t                        base[i] = 0;\n\t                        second++;\n\t                    }\n\t                } else if (base[i] == 1) {\n\t                    if (modF == 0 && modS == 1) {\n\t                        base[i] = 0;\n\t                        second++;\n\t                    } else if (modF == 0 && modS == 2) {\n\t                        base[i] = 2;\n\t                        second++;\n\t                    } else if (modF == 1 && modS == 0) {\n\t                        base[i] = 2;\n\t                    } else if (modF == 1 && modS == 1) {\n\t                        base[i] = 1;\n\t                    } else if (modF == 1 && modS == 2) {\n\t                        base[i] = 0;\n\t                        second++;\n\t                    } else if (modF == 2 && modS == 0) {\n\t                        base[i] = 0;\n\t                        first++;\n\t                    } else if (modF == 2 && modS == 1) {\n\t                        base[i] = 2;\n\t                        first++;\n\t                    } else if (modF == 2 && modS == 2) {\n\t                        base[i] = 1;\n\t                        first++;\n\t                    }\n\t                } else if (base[i] == 2) {\n\t                    if (modF == 0 && modS == 1) {\n\t                        base[i] = 1;\n\t                    } else if (modF == 0 && modS == 2) {\n\t                        base[i] = 0;\n\t                        second++;\n\t                    } else if (modF == 1 && modS == 0) {\n\t                        base[i] = 0;\n\t                        first++;\n\t                    } else if (modF == 1 && modS == 1) {\n\t                        base[i] = 2;\n\t                        first++;\n\t                    } else if (modF == 1 && modS == 2) {\n\t                        base[i] = 1;\n\t                        first++;\n\t                    } else if (modF == 2 && modS == 0) {\n\t                        base[i] = 1;\n\t                        first++;\n\t                    } else if (modF == 2 && modS == 1) {\n\t                        base[i] = 0;\n\t                        first++;\n\t                        second++;\n\t                    } else if (modF == 2 && modS == 2) {\n\t                        base[i] = 2;\n\t                        first++;\n\t                        second++;\n\t                    }\n\t                }\n\t            }\n\t            idx += 2;\n\t        }\n\t        if (list.size() - idx == 2) {\n\t            int x = list.get(idx);\n\t            for (int i = 0; i < size; i++) {\n\t                if (x > 0) {\n    \t                int mod = x % 3;\n    \t                x /= 3;\n                        if (base[i] + mod >= 3) {\n                            x++;\n                        }\n                        base[i] = (base[i] + mod) % 3;\n\t                }\n\t                if (base[i] == 1) {\n\t                    base[i] = 2;\n\t                } else if (base[i] == 2) {\n\t                    base[i] = 1;\n\t                }\n\t            }\n\t            idx++;\n\t        }\n            int x = list.get(idx);\n            for (int i = 0; i < size && x > 0; i++) {\n                int mod = x % 3;\n                x /= 3;\n                if (base[i] + mod >= 3) {\n                    x++;\n                }\n                base[i] = (base[i] + mod) % 3;\n            }\n \t    }\n\t    \n\t    public int getValue() {\n\t        int ans = 0;\n\t        for (int i = size - 1; i >= 0; i--) {\n\t            ans *= 3;\n\t            ans += base[i];\n\t        }\n\t        return ans;\n\t    }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "package Grand044C;\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t// 文字列の入力\n\t\tString[] lineString = sc.nextLine().split(\" \");\n\t\tint n = (int) Math.pow(3, Integer.parseInt(lineString[0]));\n\t\tint[] position = new int[n];\n\t\tint[] salsa = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsalsa[i] = salsa(i);\n\t\t\tposition[i] = i;\n\t\t}\n\n\t\tString t = sc.nextLine();\n\t\tPattern salsaReg = Pattern.compile(\"SS\");\n\t\tPattern rumbaReg = Pattern.compile(\"R{\" + n + \",\" + n + \"}\");\n\t\tMatcher salsaMatch = salsaReg.matcher(t);\n\t\tMatcher rumbaMatch = rumbaReg.matcher(t);\n\t\twhile (salsaMatch.find() || rumbaMatch.find()) {\n\t\t\tif (salsaMatch.find()) {\n\t\t\t\tt = salsaMatch.replaceAll(\"\");\n\t\t\t}\n\t\t\tif (rumbaMatch.find()) {\n\t\t\t\tt = rumbaMatch.replaceAll(\"\");\n\t\t\t}\n\t\t\tsalsaMatch = salsaReg.matcher(t);\n\t\t\trumbaMatch = rumbaReg.matcher(t);\n\t\t}\n\t\tSystem.out.println(t);\n\t\tfor (int i = 0; i < t.length(); i++) {\n\t\t\tString ope = t.substring(i, i + 1);\n\t\t\tint count = 1;\n\t\t\twhile (i + count < t.length() && t.substring(i + count, i + count + 1).equals(ope)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\ti += count - 1;\n\t\t\tif (ope.equals(\"S\")) {\n\t\t\t\t//Sの場合は奇数の時だけsalsa適用。\n\t\t\t\tif (count % 2 == 1) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tposition[j] = salsa[position[j]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//Rの場合はcountだけずれる。\n\t\t\t\tcount %= n;\n\t\t\t\tif (count > 0) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tposition[j] = (position[j] + count) % n;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 出力\n\t\tString result = \"\";\n\t\tfor (int i = 0; i < position.length; i++) {\n\t\t\tif (!result.equals(\"\")) {\n\t\t\t\tresult += \" \";\n\t\t\t}\n\t\t\tresult += position[i];\n\t\t}\n\t\tSystem.out.println(result);\n\t\tsc.close();\n\t}\n\n\tstatic int salsa(int number) {\n\t\tString three = Integer.toString(number, 3);\n\t\tString threeReplace = three.replace(\"2\", \"3\").replace(\"1\", \"2\").replace(\"3\", \"1\");\n\t\treturn Integer.parseInt(threeReplace, 3);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main (String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint length = (int)(Math.pow(3, n));\n\t\tPerson.size = n;\n\t\tPerson[] persons = new Person[length];\n\t\tfor (int i = 0; i < length; i++) {\n\t\t    persons[i] = new Person(i);\n\t\t}\n\t\tArrayList<Integer> list = new ArrayList<>();\n\t\tchar[] arr = sc.next().toCharArray();\n\t\tint count = 0;\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t    if (arr[i] == 'R') {\n\t\t        count++;\n\t\t    } else {\n\t\t        if (i < arr.length - 1 && arr[i + 1] == 'S') {\n\t\t            i++;\n\t\t        } else {\n\t\t            list.add(count);\n\t\t            count = 0;\n\t\t        }\n\t\t    }\n\t\t}\n\t\tlist.add(count);\n\t\tPerson.list = list;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < length; i++) {\n\t\t    if (i > 0) {\n\t\t        sb.append(\" \");\n\t\t    }\n\t\t    persons[i].calc();\n\t\t    sb.append(persons[i].getValue());\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\t\n\tstatic class Person {\n\t    static int size;\n\t    static ArrayList<Integer> list;\n\t    int[] base;\n\t    \n\t    public Person(int value) {\n\t        base = new int[size];\n\t        for (int i = 0; i < size && value > 0; i++) {\n\t            base[i] = value % 3;\n\t            value /= 3;\n\t        }\n\t    }\n\t    \n\t    public void calc() {\n\t        for (int i = 0; i < list.size(); i++) {\n\t            int x = list.get(i);\n\t            boolean next = false;\n\t            for (int j = 0; j < size && (x > 0 || next); j++) {\n\t                int mod = x % 3;\n\t                if (next) {\n\t                    next = (base[j] + mod + 1 >= 3);\n\t                    base[j] = (base[j] + mod + 1) % 3;\n\t                } else {\n\t                    next = (base[j] + mod >= 3);\n\t                    base[j] = (base[j] + mod) % 3;\n\t                }\n\t                x /= 3;\n\t            }\n\t            if (i >= list.size() - 1) {\n\t                break;\n\t            }\n\t            for (int j = 0; j < size; j++) {\n\t                if (base[j] == 2) {\n\t                    base[j] = 1;\n\t                } else if (base[j] == 1) {\n\t                    base[j] = 2;\n\t                }\n\t            }\n\t        }\n\t    }\n\t    \n\t    public int getValue() {\n\t        int ans = 0;\n\t        for (int i = size - 1; i >= 0; i--) {\n\t            ans *= 3;\n\t            ans += base[i];\n\t        }\n\t        return ans;\n\t    }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t// 文字列の入力\n\t\tString[] lineString = sc.nextLine().split(\" \");\n\t\tint n = (int) Math.pow(3, Integer.parseInt(lineString[0]));\n\t\tint[] position = new int[n];\n\t\tint[] salsa = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsalsa[i] = salsa(i);\n\t\t\tposition[i] = i;\n\t\t}\n\n\t\tString t = sc.nextLine();\n\t\tfor (int i = 0; i < t.length(); i++) {\n\t\t\tString ope = t.substring(i, i + 1);\n\t\t\tint count = 1;\n\t\t\twhile (i + count < t.length() && t.substring(i + count, i + count + 1).equals(ope)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\ti += count - 1;\n\t\t\tif (ope.equals(\"S\")) {\n\t\t\t\t//Sの場合は奇数の時だけsalsa適用。\n\t\t\t\tif (count % 2 == 1) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tposition[j] = salsa[position[j]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//Rの場合はcountだけずれる。\n\t\t\t\tcount %= n;\n\t\t\t\tif (count > 0) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tposition[j] = (position[j] + count) % n;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 出力\n\t\tString result = \"\";\n\t\tfor (int i = 0; i < position.length; i++) {\n\t\t\tif (!result.equals(\"\")) {\n\t\t\t\tresult += \" \";\n\t\t\t}\n\t\t\tresult += position[i];\n\t\t}\n\t\tSystem.out.println(result);\n\t\tsc.close();\n\t}\n\n\tstatic int salsa(int number) {\n\t\tString three = Integer.toString(number, 3);\n\t\tString threeReplace = three.replace(\"2\", \"3\").replace(\"1\", \"2\").replace(\"3\", \"1\");\n\t\treturn Integer.parseInt(threeReplace, 3);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.BitSet;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            CStrangeDance solver = new CStrangeDance();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class CStrangeDance {\n        Radix radix = new Radix(3);\n        ArrayIndex ai = new ArrayIndex(12, (int) radix.setBit(0, 12, 1));\n        BitSet[] dp = new BitSet[ai.totalSize()];\n        int[] cast = new int[ai.totalSize()];\n        int[] sizes = new int[ai.totalSize()];\n        BitSet basic;\n        int len;\n        IntegerList op = new IntegerList((int) 2e5);\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            char[] t = new char[(int) 2e5];\n            len = in.readString(t, 0);\n            basic = new BitSet(len);\n            for (int i = 0; i < len; i++) {\n                basic.set(i, t[i] == 'S');\n            }\n            int limit = (int) radix.setBit(0, n, 1);\n            for (int i = 0; i < limit; i++) {\n                dp(n - 1, i);\n                int index = ai.indexOf(n - 1, i);\n                int ans = cast[index];\n                out.append(ans).append(' ');\n            }\n        }\n\n        public int swap(int i) {\n            if (i == 0) {\n                return i;\n            }\n            return 3 - i;\n        }\n\n        public void dp(int i, int j) {\n            int index = ai.indexOf(i, j);\n            if (dp[index] == null) {\n                BitSet bit = basic;\n                int prefix = 0;\n                int m = len;\n                if (i > 0) {\n                    //use basic\n                    int next = (int) radix.setBit(j, i, 0);\n                    dp(i - 1, next);\n                    bit = dp[ai.indexOf(i - 1, next)];\n                    prefix = cast[ai.indexOf(i - 1, next)];\n                    m = sizes[ai.indexOf(i - 1, next)];\n                }\n                op.clear();\n                int val = radix.get(j, i);\n                for (int t = 0; t < m; t++) {\n                    if (bit.get(t)) {\n                        //s\n                        val = swap(val);\n                        if (!op.isEmpty() && op.tail() == 1) {\n                            op.pop();\n                        } else {\n                            op.add(1);\n                        }\n                    } else {\n                        //\n                        val++;\n                        if (val < 3) {\n                            continue;\n                        } else {\n                            val = 0;\n                            op.add(0);\n                        }\n                    }\n                }\n\n                dp[index] = new BitSet(op.size());\n                sizes[index] = op.size();\n                int[] data = op.getData();\n                for (int t = op.size() - 1; t >= 0; t--) {\n                    dp[index].set(t, data[t] == 1);\n                }\n                cast[index] = (int) radix.setBit(prefix, i, val);\n            }\n        }\n\n    }\n\n    static class LongList implements Cloneable {\n        private int size;\n        private int cap;\n        private long[] data;\n        private static final long[] EMPTY = new long[0];\n\n        public LongList(int cap) {\n            this.cap = cap;\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new long[cap];\n            }\n        }\n\n        public LongList(LongList list) {\n            this.size = list.size;\n            this.cap = list.cap;\n            this.data = Arrays.copyOf(list.data, size);\n        }\n\n        public LongList() {\n            this(0);\n        }\n\n        public void ensureSpace(int req) {\n            if (req > cap) {\n                while (cap < req) {\n                    cap = Math.max(cap + 10, 2 * cap);\n                }\n                data = Arrays.copyOf(data, cap);\n            }\n        }\n\n        private void checkRange(int i) {\n            if (i < 0 || i >= size) {\n                throw new ArrayIndexOutOfBoundsException();\n            }\n        }\n\n        public void add(long x) {\n            ensureSpace(size + 1);\n            data[size++] = x;\n        }\n\n        public void addAll(long[] x, int offset, int len) {\n            ensureSpace(size + len);\n            System.arraycopy(x, offset, data, size, len);\n            size += len;\n        }\n\n        public void addAll(LongList list) {\n            addAll(list.data, 0, list.size);\n        }\n\n        public long tail() {\n            checkRange(0);\n            return data[size - 1];\n        }\n\n        public long[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n        public String toString() {\n            return Arrays.toString(toArray());\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof LongList)) {\n                return false;\n            }\n            LongList other = (LongList) obj;\n            return SequenceUtils.equal(data, 0, size - 1, other.data, 0, other.size - 1);\n        }\n\n        public int hashCode() {\n            int h = 1;\n            for (int i = 0; i < size; i++) {\n                h = h * 31 + Long.hashCode(data[i]);\n            }\n            return h;\n        }\n\n        public LongList clone() {\n            LongList ans = new LongList();\n            ans.addAll(this);\n            return ans;\n        }\n\n    }\n\n    static class DigitUtils {\n        private DigitUtils() {\n        }\n\n        public static boolean isMultiplicationOverflow(long a, long b, long limit) {\n            if (limit < 0) {\n                limit = -limit;\n            }\n            if (a < 0) {\n                a = -a;\n            }\n            if (b < 0) {\n                b = -b;\n            }\n            if (a == 0 || b == 0) {\n                return false;\n            }\n            //a * b > limit => a > limit / b\n            return a > limit / b;\n        }\n\n    }\n\n    static class ArrayIndex {\n        int[] dimensions;\n\n        public ArrayIndex(int... dimensions) {\n            this.dimensions = dimensions;\n        }\n\n        public int totalSize() {\n            int ans = 1;\n            for (int x : dimensions) {\n                ans *= x;\n            }\n            return ans;\n        }\n\n        public int indexOf(int a, int b) {\n            return a * dimensions[1] + b;\n        }\n\n    }\n\n    static class Radix {\n        private long[] pow;\n        private long base;\n\n        public Radix(long base) {\n            if (base <= 1) {\n                throw new IllegalArgumentException();\n            }\n            this.base = base;\n            LongList ll = new LongList(64);\n            ll.add(1);\n            while (!DigitUtils.isMultiplicationOverflow(ll.tail(), base, Long.MAX_VALUE)) {\n                ll.add(ll.tail() * base);\n            }\n            pow = ll.toArray();\n        }\n\n        public int get(long x, int i) {\n            return (int) (x / pow[i] % base);\n        }\n\n        public long setBit(long x, int i, long val) {\n            return x + (val - get(x, i)) * pow[i];\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public int readString(char[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (char) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n    }\n\n    static class IntegerList implements Cloneable {\n        private int size;\n        private int cap;\n        private int[] data;\n        private static final int[] EMPTY = new int[0];\n\n        public int[] getData() {\n            return data;\n        }\n\n        public IntegerList(int cap) {\n            this.cap = cap;\n            if (cap == 0) {\n                data = EMPTY;\n            } else {\n                data = new int[cap];\n            }\n        }\n\n        public IntegerList(IntegerList list) {\n            this.size = list.size;\n            this.cap = list.cap;\n            this.data = Arrays.copyOf(list.data, size);\n        }\n\n        public IntegerList() {\n            this(0);\n        }\n\n        public void ensureSpace(int req) {\n            if (req > cap) {\n                while (cap < req) {\n                    cap = Math.max(cap + 10, 2 * cap);\n                }\n                data = Arrays.copyOf(data, cap);\n            }\n        }\n\n        private void checkRange(int i) {\n            if (i < 0 || i >= size) {\n                throw new ArrayIndexOutOfBoundsException();\n            }\n        }\n\n        public void add(int x) {\n            ensureSpace(size + 1);\n            data[size++] = x;\n        }\n\n        public void addAll(int[] x, int offset, int len) {\n            ensureSpace(size + len);\n            System.arraycopy(x, offset, data, size, len);\n            size += len;\n        }\n\n        public void addAll(IntegerList list) {\n            addAll(list.data, 0, list.size);\n        }\n\n        public int tail() {\n            checkRange(0);\n            return data[size - 1];\n        }\n\n        public int pop() {\n            return data[--size];\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n\n        public boolean isEmpty() {\n            return size == 0;\n        }\n\n        public void clear() {\n            size = 0;\n        }\n\n        public String toString() {\n            return Arrays.toString(toArray());\n        }\n\n        public boolean equals(Object obj) {\n            if (!(obj instanceof IntegerList)) {\n                return false;\n            }\n            IntegerList other = (IntegerList) obj;\n            return SequenceUtils.equal(data, 0, size - 1, other.data, 0, other.size - 1);\n        }\n\n        public int hashCode() {\n            int h = 1;\n            for (int i = 0; i < size; i++) {\n                h = h * 31 + Integer.hashCode(data[i]);\n            }\n            return h;\n        }\n\n        public IntegerList clone() {\n            IntegerList ans = new IntegerList();\n            ans.addAll(this);\n            return ans;\n        }\n\n    }\n\n    static class SequenceUtils {\n        public static boolean equal(int[] a, int al, int ar, int[] b, int bl, int br) {\n            if ((ar - al) != (br - bl)) {\n                return false;\n            }\n            for (int i = al, j = bl; i <= ar; i++, j++) {\n                if (a[i] != b[j]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public static boolean equal(long[] a, int al, int ar, long[] b, int bl, int br) {\n            if ((ar - al) != (br - bl)) {\n                return false;\n            }\n            for (int i = al, j = bl; i <= ar; i++, j++) {\n                if (a[i] != b[j]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main (String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint length = (int)(Math.pow(3, n));\n\t\tPerson.size = n;\n\t\tPerson[] persons = new Person[length];\n\t\tfor (int i = 0; i < length; i++) {\n\t\t    persons[i] = new Person(i);\n\t\t}\n\t\tArrayList<Integer> list = new ArrayList<>();\n\t\tchar[] arr = sc.next().toCharArray();\n\t\tint count = 0;\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t    if (arr[i] == 'R') {\n\t\t        count++;\n\t\t    } else {\n\t\t        if (i < arr.length - 1 && arr[i + 1] == 'S') {\n\t\t            i++;\n\t\t        } else {\n\t\t            list.add(count);\n\t\t            count = 0;\n\t\t        }\n\t\t    }\n\t\t}\n\t\tlist.add(count);\n\t\tPerson.list = list;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < length; i++) {\n\t\t    if (i > 0) {\n\t\t        sb.append(\" \");\n\t\t    }\n\t\t    persons[i].calc();\n\t\t    sb.append(persons[i].getValue());\n\t\t}\n\t\tSystem.out.println(sb);\n\t}\n\t\n\tstatic class Person {\n\t    static int size;\n\t    static ArrayList<Integer> list;\n\t    int[] base;\n\t    \n\t    public Person(int value) {\n\t        base = new int[size];\n\t        for (int i = 0; i < size && value > 0; i++) {\n\t            base[i] = value % 3;\n\t            value /= 3;\n\t        }\n\t    }\n\t    \n\t    public void calc() {\n\t        int idx = 0;\n\t        while (list.size() - idx > 2) {\n\t            int first = list.get(idx);\n\t            int second = list.get(idx + 1);\n\t            for (int i = 0; i < size && (first > 0 || second > 0); i++) {\n\t                int modF = first % 3;\n\t                int modS = second % 3;\n\t                first /= 3;\n\t                second /= 3;\n\t                if (modF == 0 && modS == 0) {\n\t                    continue;\n\t                }\n\t                if (base[i] + modF >= 3) {\n\t                    first++;\n\t                }\n\t                base[i] = (base[i] + modF) % 3;\n\t                if (base[i] == 1) {\n\t                    base[i] = 2;\n\t                } else if (base[i] == 2) {\n\t                    base[i] = 1;\n\t                }\n\t                if (base[i] + modS >= 3) {\n\t                    second++;\n\t                }\n\t                base[i] = (base[i] + modS) % 3;\n\t                if (base[i] == 1) {\n\t                    base[i] = 2;\n\t                } else if (base[i] == 2) {\n\t                    base[i] = 1;\n\t                }\n\t            }\n\t            idx += 2;\n\t        }\n\t        if (list.size() - idx == 2) {\n\t            int x = list.get(idx);\n\t            for (int i = 0; i < size; i++) {\n\t                if (x > 0) {\n    \t                int mod = x % 3;\n    \t                x /= 3;\n                        if (base[i] + mod >= 3) {\n                            x++;\n                        }\n                        base[i] = (base[i] + mod) % 3;\n\t                }\n\t                if (base[i] == 1) {\n\t                    base[i] = 2;\n\t                } else if (base[i] == 2) {\n\t                    base[i] = 1;\n\t                }\n\t            }\n\t            idx++;\n\t        }\n            int x = list.get(idx);\n            for (int i = 0; i < size && x > 0; i++) {\n                int mod = x % 3;\n                x /= 3;\n                if (base[i] + mod >= 3) {\n                    x++;\n                }\n                base[i] = (base[i] + mod) % 3;\n            }\n \t    }\n\t    \n\t    public int getValue() {\n\t        int ans = 0;\n\t        for (int i = size - 1; i >= 0; i--) {\n\t            ans *= 3;\n\t            ans += base[i];\n\t        }\n\t        return ans;\n\t    }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nclass Main{\n  public static void main(String args[]){\n    int a = readI();\n    String t = readL();\n    int n = (int)(Math.pow(3,a));\n    int arr[]=new int[n];\n    int seni[]=new int[n];\n    int len = t.length();\n    for(int i=0;i<n;i++){\n      arr[i]=i;\n      if(i!=0&&seni[i]==0){\n        seni[i] = trans(i);\n        seni[seni[i]]=i;\n      }\n    }\n    for(int i=0;i<len;i++){\n      char c = t.charAt(i);\n      if(c=='S'){\n        boolean flg[]=new boolean[n];\n        for(int j=0;j<n;j++){\n          if(!flg[j]){\n            int x = arr[j];\n            arr[j]=arr[seni[j]];\n            arr[seni[j]]=x;\n            flg[j]=true;flg[seni[j]]=true;\n          }\n        }\n      }else{\n        int x = arr[n-1];\n        for(int j=n-1;j>0;j--){\n          arr[j]=arr[j-1];\n        }\n        arr[0]=x;\n      }\n    }\n    int ans[] = new int[n];\n    for(int i=0;i<n;i++){\n      ans[arr[i]]=i;\n    }\n    pr(ans[0]+\"\");\n    for(int i=1;i<n;i++){\n      pr(\" \"+ans[i]);\n    }\n    pl(\"\");\n\n  }\n\n  public static int trans(int n){\n    int k,r=0;\n    int bai=1;\n    while(n!=0){\n      k = n%3;\n      n=n/3;\n      if(k==1){\n        k=2;\n      }else if(k==2){\n        k=1;\n      }\n      r += k*bai;\n      bai*=3;\n    }\n    return r;\n  }\n\n  static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n  public static void pr(String str){\n    System.out.print(str);\n  }\n  public static void pl(String str){\n    System.out.println(str);\n  }\n  public static String readL(){\n    try{\n      return br.readLine();\n    }catch(IOException e){\n      e.printStackTrace();\n      return \"\";\n    }\n  }\n  public static String readS(){\n    StringBuilder sb = new StringBuilder();\n    while(true){\n      try{\n        int k = br.read();\n        if(k==-1||(char)k==' '||(char)k=='\\n'){break;}\n        sb.append((char)k);\n      }catch(IOException e){\n        e.printStackTrace();\n      }\n    }\n    return sb.toString();\n  }\n  public static int readI(){\n    return stoi(readS());\n  }\n  public static String[] readSs(){\n    return readL().split(\" \");\n  }\n  public static int[] readIs(){\n    return stoi(readSs());\n  }\n  public static int stoi(String s){\n    return Integer.parseInt(s);\n  }\n  public static int[] stoi(String s[]){\n    int a[]=new int[s.length];\n    for(int i=0;i<s.length;i++){\n      a[i]=stoi(s[i]);\n    }\n    return a;\n  }\n  public static String itos(int i){\n    return String.valueOf(i);\n  }\n  public static String[] itos(int[] a){\n    String s[]=new String[a.length];\n    for(int i=0;i<a.length;i++){\n      s[i]=itos(a[i]);\n    }\n    return s;\n  }\n  public static String ctos(char c){\n    return String.valueOf(c);\n  }\n  public static String cstos(char[] c){\n    return new String(c);\n  }\n  public static char stoc(String s){\n    return s.charAt(0);\n  }\n  public static char[] stocs(String s){\n    return s.toCharArray();\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        C_StrangeDance solver = new C_StrangeDance();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class C_StrangeDance {\n        int[] pair;\n        Map<Integer, int[]> cache = new HashMap<>();\n\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.nextInt();\n            char[] str = in.next().toCharArray();\n            int[] a = process(str);\n            int lastShift = 0;\n            if (a[a.length - 1] < 0) {\n                lastShift = -a[a.length - 1];\n                a = Arrays.copyOf(a, a.length - 1);\n            }\n            int[] p3 = new int[n + 1];\n            p3[0] = 1;\n            for (int i = 1; i < p3.length; i++) {\n                p3[i] = 3 * p3[i - 1];\n            }\n            pair = new int[p3[n]];\n            for (int i = 0; i < pair.length; i++) {\n                int j = 0;\n                for (int pos = 0; pos < n; pos++) {\n                    int digit = (i / p3[pos]) % 3;\n                    j += p3[pos] * ((digit ^ 1 ^ 2) % 3);\n                }\n                pair[i] = j;\n            }\n//        int[] p = identity();\n//        for (int len : a) {\n//            p = apply(p, f(len));\n//        }\n            int period = a.length - 1 - kmp(a)[a.length - 1];\n            int[] full = identity();\n            for (int i = 0; i < a.length; i++) {\n                full = apply(full, f(a[i]));\n            }\n            int[] p = pow(full, a.length / period);\n            for (int i = 0; i < a.length % period; i++) {\n                p = apply(p, f(a[i]));\n            }\n\n            p = applyShift(p, lastShift);\n            for (int i = 0; i < p.length; i++) {\n                if (i > 0) {\n                    out.print(\" \");\n                }\n                out.print(p[i]);\n            }\n            out.println();\n        }\n\n        private int[] f(int len) {\n            if (cache.containsKey(len)) {\n                return cache.get(len);\n            }\n            int[] p = new int[pair.length];\n            for (int i = 0; i < p.length; i++) {\n                p[i] = pair[(i + len) % p.length];\n            }\n            cache.put(len, p);\n            return p;\n        }\n\n        private int[] pow(int[] a, int n) {\n            int[] r = identity();\n            while (n > 0) {\n                if (n % 2 != 0) {\n                    r = apply(r, a);\n                }\n                a = apply(a, a);\n                n /= 2;\n            }\n            return r;\n        }\n\n        private int[] identity() {\n            int[] p = new int[pair.length];\n            for (int i = 0; i < p.length; i++) {\n                p[i] = i;\n            }\n            return p;\n        }\n\n        private int[] apply(int[] p, int[] q) {\n            int[] np = new int[p.length];\n            for (int i = 0; i < p.length; i++) {\n                np[i] = q[p[i]];\n            }\n            return np;\n        }\n\n        private int[] applyShift(int[] p, int len) {\n            int[] np = new int[p.length];\n            for (int i = 0; i < p.length; i++) {\n                np[i] = (p[i] + len) % p.length;\n            }\n            return np;\n        }\n\n        private int[] kmp(int[] s) {\n            int n = s.length;\n            int[] kmp = new int[n];\n            Arrays.fill(kmp, -1);\n            int k = -1;\n            for (int i = 1; i < n; i++) {\n                while (k != -1 && s[k + 1] != s[i]) {\n                    k = kmp[k];\n                }\n                if (s[k + 1] == s[i]) {\n                    ++k;\n                }\n                kmp[i] = k;\n            }\n            return kmp;\n        }\n\n        private int[] process(char[] s) {\n            List<Integer> res = new ArrayList<>();\n            int n = s.length;\n            int curR = 0;\n            for (int i = 0; i < n; ) {\n                int j = i;\n                while (j < n && s[i] == s[j]) {\n                    ++j;\n                }\n                if (s[i] == 'R') {\n                    curR += j - i;\n                } else if ((j - i) % 2 != 0) {\n                    res.add(curR);\n                    curR = 0;\n                }\n                i = j;\n            }\n            if (curR != 0) {\n                res.add(-curR);\n            }\n            int[] ret = new int[res.size()];\n            for (int i = 0; i < res.size(); i++) {\n                ret[i] = res.get(i);\n            }\n            return ret;\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t// 文字列の入力\n\t\tString[] lineString = sc.nextLine().split(\" \");\n\t\tint n = (int) Math.pow(3, Integer.parseInt(lineString[0]));\n\t\tint[] position = new int[n];\n\t\tint[] salsa = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsalsa[i] = salsa(i);\n\t\t\tposition[i] = i;\n\t\t}\n\n\t\tString t = sc.nextLine();\n\t\tPattern salsaReg = Pattern.compile(\"SS\");\n\t\tPattern rumbaReg = Pattern.compile(\"R{\" + n + \",\" + n + \"}\");\n\t\tMatcher salsaMatch = salsaReg.matcher(t);\n\t\tMatcher rumbaMatch = rumbaReg.matcher(t);\n\t\twhile (salsaMatch.find() || rumbaMatch.find()) {\n\t\t\tif (salsaMatch.find()) {\n\t\t\t\tt = salsaMatch.replaceAll(\"\");\n\t\t\t}\n\t\t\tif (rumbaMatch.find()) {\n\t\t\t\tt = rumbaMatch.replaceAll(\"\");\n\t\t\t}\n\t\t\tsalsaMatch = salsaReg.matcher(t);\n\t\t\trumbaMatch = rumbaReg.matcher(t);\n\t\t}\n\t\tfor (int i = 0; i < t.length(); i++) {\n\t\t\tString ope = t.substring(i, i + 1);\n\t\t\tint count = 1;\n\t\t\twhile (i + count < t.length() && t.substring(i + count, i + count + 1).equals(ope)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\ti += count - 1;\n\t\t\tif (ope.equals(\"S\")) {\n\t\t\t\t//Sの場合は奇数の時だけsalsa適用。\n\t\t\t\tif (count % 2 == 1) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tposition[j] = salsa[position[j]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//Rの場合はcountだけずれる。\n\t\t\t\tcount %= n;\n\t\t\t\tif (count > 0) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tposition[j] = (position[j] + count) % n;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 出力\n\t\tString result = \"\";\n\t\tfor (int i = 0; i < position.length; i++) {\n\t\t\tif (!result.equals(\"\")) {\n\t\t\t\tresult += \" \";\n\t\t\t}\n\t\t\tresult += position[i];\n\t\t}\n\t\tSystem.out.println(result);\n\t\tsc.close();\n\t}\n\n\tstatic int salsa(int number) {\n\t\tString three = Integer.toString(number, 3);\n\t\tString threeReplace = three.replace(\"2\", \"3\").replace(\"1\", \"2\").replace(\"3\", \"1\");\n\t\treturn Integer.parseInt(threeReplace, 3);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nclass Main{\n  public static void main(String args[]){\n    int a = readI();\n    String t = readL();\n    int n = (int)(Math.pow(3,a));\n    ArrayList<Integer> arr = new ArrayList<Integer>();\n    int seni[]=new int[n];\n    int len = t.length();\n    for(int i=0;i<n;i++){\n      arr.add(i);\n      if(i!=0&&seni[i]==0){\n        seni[i] = trans(i);\n        seni[seni[i]]=i;\n      }\n    }\n    for(int i=0;i<len;i++){\n      char c = t.charAt(i);\n      if(c=='S'){\n        int mi=1,jj=1;\n        for(jj=i+1;jj<len;jj++){\n          c=t.charAt(jj);\n          if(c=='S'){\n            mi*=-1;\n          }else{\n            jj--;break;\n          }\n        }\n        i=jj;\n        if(mi==-1){continue;}\n        boolean flg[]=new boolean[n];\n        for(int j=1;j<n;j++){\n          if(!flg[j]){\n            int x = arr.get(j);\n            arr.set(j,arr.get(seni[j]));\n            arr.set(seni[j],x);\n            flg[j]=true;flg[seni[j]]=true;\n          }\n        }\n      }else{\n        int x = arr.get(n-1);\n        arr.remove(n-1);\n        arr.add(0,x);\n      }\n    }\n    int ans[] = new int[n];\n    for(int i=0;i<n;i++){\n      ans[arr.get(i)]=i;\n    }\n    pr(ans[0]+\"\");\n    for(int i=1;i<n;i++){\n      pr(\" \"+ans[i]);\n    }\n    pl(\"\");\n\n  }\n\n  public static int trans(int n){\n    int k,r=0;\n    int bai=1;\n    while(n!=0){\n      k = n%3;\n      n=n/3;\n      if(k==1){\n        k=2;\n      }else if(k==2){\n        k=1;\n      }\n      r += k*bai;\n      bai*=3;\n    }\n    return r;\n  }\n\n  static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n  public static void pr(String str){\n    System.out.print(str);\n  }\n  public static void pl(String str){\n    System.out.println(str);\n  }\n  public static String readL(){\n    try{\n      return br.readLine();\n    }catch(IOException e){\n      e.printStackTrace();\n      return \"\";\n    }\n  }\n  public static String readS(){\n    StringBuilder sb = new StringBuilder();\n    while(true){\n      try{\n        int k = br.read();\n        if(k==-1||(char)k==' '||(char)k=='\\n'){break;}\n        sb.append((char)k);\n      }catch(IOException e){\n        e.printStackTrace();\n      }\n    }\n    return sb.toString();\n  }\n  public static int readI(){\n    return stoi(readS());\n  }\n  public static String[] readSs(){\n    return readL().split(\" \");\n  }\n  public static int[] readIs(){\n    return stoi(readSs());\n  }\n  public static int stoi(String s){\n    return Integer.parseInt(s);\n  }\n  public static int[] stoi(String s[]){\n    int a[]=new int[s.length];\n    for(int i=0;i<s.length;i++){\n      a[i]=stoi(s[i]);\n    }\n    return a;\n  }\n  public static String itos(int i){\n    return String.valueOf(i);\n  }\n  public static String[] itos(int[] a){\n    String s[]=new String[a.length];\n    for(int i=0;i<a.length;i++){\n      s[i]=itos(a[i]);\n    }\n    return s;\n  }\n  public static String ctos(char c){\n    return String.valueOf(c);\n  }\n  public static String cstos(char[] c){\n    return new String(c);\n  }\n  public static char stoc(String s){\n    return s.charAt(0);\n  }\n  public static char[] stocs(String s){\n    return s.toCharArray();\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class test {\n    public static void main(String arg[]){\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            String str;\n            str = br.readLine();\n            int N = Integer.parseInt(str);\n            double num = Math.pow(3,N);\n            str=br.readLine();\n            String sequence=str;\n\n            int[] circle = new int[(int) num];\n            for(int i=0;i<circle.length;i++){\n                circle[i]=i;\n            }\n            int[] circle2 = circle.clone();\n            int headFlag=0;\n            int endFlag=circle.length-1;\n            for(int i=0;i<sequence.length();i++){\n                char song=sequence.charAt(i);\n                if(song=='R'){\n                    for(int j=0;j<circle.length;j++){\n                        if(circle[j]==circle.length-1){\n                            endFlag=j;\n                            break;\n                        }\n                    }\n                    for(int j=0;j<circle.length;j++){\n                        if(j==endFlag){\n                            circle[j]=0;\n                            endFlag=endFlag-1;\n                            headFlag=j;\n                        }else {\n                            circle[j]++;\n                        }\n                    }\n                    circle2=circle.clone();\n                }else {\n                    for(int j=0;j<circle.length;j++){\n                        int sum=0;\n                        String tmp =Integer.toString(circle[j],3);\n                        for(int t=0;t<tmp.length();t++){\n                            if(tmp.charAt(tmp.length()-1-t)=='0'){\n                                sum+=0;\n                            }else if(tmp.charAt(tmp.length()-1-t)=='1'){\n                                sum+=(int) (2*Math.pow(3,t));\n                            }else {\n                                sum+=(int) (1*Math.pow(3,t));\n                            }\n                        }\n                        int flag=0;\n                        for(int t=0;t<circle.length;t++){\n                            if(circle2[t]==sum){\n                                flag=t;\n                            }\n                        }\n                        circle[j]=circle2[flag];\n                    }\n                    circle2=circle.clone();\n                }\n            }\n            for(int i=0;i<circle.length;i++){\n                if(i==circle.length){\n                    System.out.println(circle[i]);\n                }else {\n                    System.out.print(circle[i] + \" \");\n                }\n            }\n        }catch (IOException e){\n            e.printStackTrace();;\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nclass Main{\n  public static void main(String args[]){\n    int a = readI();\n    String t = readL();\n    int n = (int)(Math.pow(3,a));\n    ArrayList<Integer> arr = new ArrayList<Integer>();\n    int seni[]=new int[n];\n    int len = t.length();\n    for(int i=0;i<n;i++){\n      arr.add(i);\n      if(i!=0&&seni[i]==0){\n        seni[i] = trans(i);\n        seni[seni[i]]=i;\n      }\n    }\n    for(int i=0;i<len;i++){\n      char c = t.charAt(i);\n      if(c=='S'){\n        boolean flg[]=new boolean[n];\n        for(int j=1;j<n;j++){\n          if(!flg[j]){\n            int x = arr.get(j);\n            arr.set(j,arr.get(seni[j]));\n            arr.set(seni[j],x);\n            flg[j]=true;flg[seni[j]]=true;\n          }\n        }\n      }else{\n        int x = arr.get(n-1);\n        arr.remove(n-1);\n        arr.add(0,x);\n      }\n    }\n    int ans[] = new int[n];\n    for(int i=0;i<n;i++){\n      ans[arr.get(i)]=i;\n    }\n    pr(ans[0]+\"\");\n    for(int i=1;i<n;i++){\n      pr(\" \"+ans[i]);\n    }\n    pl(\"\");\n\n  }\n\n  public static int trans(int n){\n    int k,r=0;\n    int bai=1;\n    while(n!=0){\n      k = n%3;\n      n=n/3;\n      if(k==1){\n        k=2;\n      }else if(k==2){\n        k=1;\n      }\n      r += k*bai;\n      bai*=3;\n    }\n    return r;\n  }\n\n  static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n  public static void pr(String str){\n    System.out.print(str);\n  }\n  public static void pl(String str){\n    System.out.println(str);\n  }\n  public static String readL(){\n    try{\n      return br.readLine();\n    }catch(IOException e){\n      e.printStackTrace();\n      return \"\";\n    }\n  }\n  public static String readS(){\n    StringBuilder sb = new StringBuilder();\n    while(true){\n      try{\n        int k = br.read();\n        if(k==-1||(char)k==' '||(char)k=='\\n'){break;}\n        sb.append((char)k);\n      }catch(IOException e){\n        e.printStackTrace();\n      }\n    }\n    return sb.toString();\n  }\n  public static int readI(){\n    return stoi(readS());\n  }\n  public static String[] readSs(){\n    return readL().split(\" \");\n  }\n  public static int[] readIs(){\n    return stoi(readSs());\n  }\n  public static int stoi(String s){\n    return Integer.parseInt(s);\n  }\n  public static int[] stoi(String s[]){\n    int a[]=new int[s.length];\n    for(int i=0;i<s.length;i++){\n      a[i]=stoi(s[i]);\n    }\n    return a;\n  }\n  public static String itos(int i){\n    return String.valueOf(i);\n  }\n  public static String[] itos(int[] a){\n    String s[]=new String[a.length];\n    for(int i=0;i<a.length;i++){\n      s[i]=itos(a[i]);\n    }\n    return s;\n  }\n  public static String ctos(char c){\n    return String.valueOf(c);\n  }\n  public static String cstos(char[] c){\n    return new String(c);\n  }\n  public static char stoc(String s){\n    return s.charAt(0);\n  }\n  public static char[] stocs(String s){\n    return s.toCharArray();\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Random;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\n\t\tScanner scan = new Scanner(System.in);\n\t\tRandom rand = new Random();\n\n\t\tint t = scan.nextInt();\n\t\tlong[] test = new long[t*5];\n\t\t\n\t\tfor(int i = 0; i < (t * 5); i++) {\n\t\t\ttest[i] = 0;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < (t * 5); i++) {\n\t\t\ttest[i] = scan.nextLong();\n\t\t}\n\n\t\t\n\t\tlong[] part = new long[t*5];\n\t\t\n\t\tfor(int i = 0; i < t * 5; i++) {\n\t\t\tif(i % 5 == 0) {\n\t\t\t\tpart[i] = test[i];\n\t\t\t}\n\t\t\telse if(i % 6 == 0 || i == 1) {\n\t\t\t\tpart[i] = 2 / test[i];\n\t\t\t}\n\t\t\telse if(i % 7 == 0 || i == 2) {\n\t\t\t\tpart[i] = 3 / test[i];\n\t\t\t}\n\t\t\telse if(i % 8 == 0 || i == 3) {\n\t\t\t\tpart[i] = 5 / test[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpart[i] = test[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong[][] score = new long[t][5];\n\t\t\n\t\tfor(int i=0; i < t; i++) {\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tscore[i][j] = test[i*5+j];\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t/*\n\t\tSystem.out.println(\"20\");\n\t\tSystem.out.println(\"19\");\n\t\tfor(int i=2; i < t; i++) {\n\t\t\tint ran =  (int)test[0+i*5] * 2;\n\t\t\tint answer = rand.nextInt();\n\t\t\tSystem.out.println(answer);\n\t\t}\n\t\t*/\n\t\t\n\t\tSystem.out.println(t);\n\t\t\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.System.arraycopy;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic Map<Long, int[]> cache[];\n\tstatic int nShifts;\n\tstatic int shiftsC[][];\n\tstatic int p3[];\n\n\tstatic int[] solve(int n) {\n\t\tint curShifts[] = shiftsC[n];\n\t\tlong k = 1;\n\t\tfor (int i = 0; i <= nShifts; i++) {\n\t\t\tk = (k * 239 + curShifts[i]) % 1000000009;\n\t\t}\n\t\tLong key = k;\n\t\tint res[] = cache[n].get(key);\n\t\tif (res == null) {\n\t\t\tif (n == 0) {\n\t\t\t\tres = new int[1];\n\t\t\t} else {\n\t\t\t\tres = new int[p3[n]];\n\t\t\t\tint nextShifts[] = shiftsC[n - 1];\n\t\t\t\tfor (int sd = 0; sd < 3; sd++) {\n\t\t\t\t\tint d = sd;\n\t\t\t\t\tfor (int i = 0;; i++) {\n\t\t\t\t\t\tint x = d + curShifts[i];\n\t\t\t\t\t\tnextShifts[i] = x / 3;\n\t\t\t\t\t\td = x % 3;\n\t\t\t\t\t\tif (i == nShifts) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (d != 0) {\n\t\t\t\t\t\t\td = 3 - d;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint nextRes[] = solve(n - 1);\n\t\t\t\t\tfor (int i = 0; i < nextRes.length; i++) {\n\t\t\t\t\t\tres[3 * i + sd] = 3 * nextRes[i] + d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcache[n].put(key, res);\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic void solve() throws Exception {\n\t\tint n = scanInt();\n\t\tcache = new Map[n + 1];\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tcache[i] = new HashMap<>();\n\t\t}\n\t\tString s = scanString();\n\t\tint shifts[] = new int[s.length() + 1];\n\t\tnShifts = 0;\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (s.charAt(i) == 'R') {\n\t\t\t\t++shifts[nShifts];\n\t\t\t} else {\n\t\t\t\tif (nShifts > 0 && shifts[nShifts] == 0) {\n\t\t\t\t\t--nShifts;\n\t\t\t\t} else {\n\t\t\t\t\t++nShifts;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tshiftsC = new int[n + 1][nShifts + 1];\n\t\tarraycopy(shifts, 0, shiftsC[n], 0, nShifts + 1);\n\t\tp3 = new int[n + 1];\n\t\tp3[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tp3[i] = p3[i - 1] * 3;\n\t\t}\n\t\tint res[] = solve(n);\n\t\tfor (int i = 0; i < res.length; i++) {\n\t\t\tout.print(res[i] + \" \");\n\t\t}\n\t}\n\n\tstatic int scanInt() throws IOException {\n\t\treturn parseInt(scanString());\n\t}\n\n\tstatic long scanLong() throws IOException {\n\t\treturn parseLong(scanString());\n\t}\n\n\tstatic String scanString() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\n\nnamespace AtCoder.C\n{\n    public class Program\n    {\n        public static long N { get; private set; }\n        public static int Max { get; private set; }\n        public static Dictionary<long, long> Sarusa { get; private set; }\n\n        public static void Main() { var r = GetResult(); Debug.WriteLine(r); Console.Write(r); }\n\n        private static object GetResult()\n        {\n            N = ReadLong();\n            var T = ReadText().Replace(\"SS\", string.Empty);\n            Max = (int)Math.Pow(3, N);\n            var P = Enumerable.Range(0, Max).Select(x => (long)x).ToList();\n\n            CreateSarusaMap();\n\n            for (int i = 0; i < T.Length; i++)\n            {\n                var dance = T[i];\n                switch (dance)\n                {\n                    case 'S':\n                        S(P);\n                        break;\n                    case 'R':\n                        R(P);\n                        break;\n                }\n            }\n\n            return string.Join(\" \", P);\n        }\n\n        private static void CreateSarusaMap()\n        {\n            var sansin = new Queue<string>();\n            sansin.Enqueue(\"0\");\n            sansin.Enqueue(\"1\");\n            sansin.Enqueue(\"2\");\n\n            for (var i = 0; i < 11; i++)\n            {\n                var count = sansin.Count;\n                for (var j = 0; j < count; j++)\n                {\n                    var x = sansin.Dequeue();\n                    sansin.Enqueue(x + \"0\");\n                    sansin.Enqueue(x + \"1\");\n                    sansin.Enqueue(x + \"2\");\n                }\n            }\n\n            Sarusa = new Dictionary<long, long>() { };\n            while (sansin.Count > 0)\n            {\n                var x = sansin.Dequeue();\n                var key = 0L;\n                var val = 0L;\n                for (var i = 0; i < 12; i++)\n                {\n                    var s = long.Parse(x[i].ToString());\n                    key += (long)Math.Pow(3, i) * s;\n                    val += (long)Math.Pow(3, i) * (s == 1 ? 2 : s == 2 ? 1 : 0);\n                }\n\n                Sarusa.Add(key, val);\n            }\n        }\n\n        private static void S(List<long> p)\n        {\n            for (var i = 0; i < Max; i++)\n            {\n                p[i] = Sarusa[p[i]];\n            }\n        }\n        private static void R(List<long> p)\n        {\n            for (var i = 0; i < Max; i++)\n            {\n                p[i]++;\n                if (p[i] == Max)\n                {\n                    p[i] = 0;\n                }\n            }\n        }\n        private static void R(List<long> p, long count)\n        {\n            for (var i = 0; i < Max; i++)\n            {\n                p[i] += count;\n                if (p[i] >= Max)\n                {\n                    p[i] -= Max;\n                }\n            }\n        }\n\n        public static string ReadText() { return Console.ReadLine(); }\n        public static List<string> ReadTexts() { return Console.ReadLine().Split(' ').ToList(); }\n        public static long ReadLong() { return long.Parse(Console.ReadLine()); }\n        public static (long, long) Read2Longs() { var ls = ReadLongs(); return (ls[0], ls[1]); }\n        public static (long, long, long) Read3Longs() { var ls = ReadLongs(); return (ls[0], ls[1], ls[2]); }\n        public static (long, long, long, long) Read4Longs() { var ls = ReadLongs(); return (ls[0], ls[1], ls[2], ls[3]); }\n        public static (long, long, long, long, long) Read5Longs() { var ls = ReadLongs(); return (ls[0], ls[1], ls[2], ls[3], ls[4]); }\n        public static List<long> ReadLongs() { return Console.ReadLine().Split(' ').Select(x => long.Parse(x)).ToList(); }\n\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing static System.Math;\nusing static Program.IO.Scanner;\nusing Number = System.Int64;\n#region IO\nnamespace Program.IO {\n\tusing System.IO;\n\tusing System.Text;\n\tusing System.Globalization;\n\n\tpublic class Printer : StreamWriter {\n\t\tpublic override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n\t\tpublic Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n\t}\n\tstatic public class Scanner {\n\t\tpublic static StreamScanner sc = new StreamScanner(Console.OpenStandardInput());\n\t\tpublic static int ri => sc.Integer();\n\t\tpublic static long rl => sc.Long();\n\t\tpublic static string rs => sc.Scan();\n\t\tpublic static double rd => sc.Double();\n\t}\n\tpublic class StreamScanner {\n\t\tpublic StreamScanner(Stream stream) { str = stream; }\n\n\t\tpublic readonly Stream str;\n\t\tprivate readonly byte[] buf = new byte[1024];\n\t\tprivate int len, ptr;\n\t\tpublic bool isEof = false;\n\t\tpublic bool IsEndOfStream { get { return isEof; } }\n\n\t\tprivate byte read() {\n\t\t\tif (isEof) return 0;\n\t\t\tif (ptr >= len) {\n\t\t\t\tptr = 0;\n\t\t\t\tif ((len = str.Read(buf, 0, 1024)) <= 0) {\n\t\t\t\t\tisEof = true;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[ptr++];\n\t\t}\n\n\t\tpublic char Char() {\n\t\t\tbyte b = 0;\n\t\t\tdo b = read(); while ((b < 33 || 126 < b) && !isEof);\n\t\t\treturn (char)b;\n\t\t}\n\t\tpublic string Scan() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic string ScanLine() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n\t\tpublic int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n\t\tpublic double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n\t}\n\n}\n\n#endregion\n\n#region main\nstatic class Ex {\n\tstatic public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n\tstatic public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n\t\treturn string.Join(st, ie);\n\t}\n\n\tstatic public void Main() {\n\t\tConsole.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n\t\tvar solver = new Program.Solver();\n\t\tvar t = new System.Threading.Thread(solver.Solve, 50000000);\n\t\tt.Start();\n\t\tt.Join();\n\t\t//*/\n\t\t//solver.Solve();\n\t\tConsole.Out.Flush();\n\t}\n}\n#endregion\n\nnamespace Program {\n\tpublic class Solver {\n\t\tRandom rnd = new Random(0);\n\t\tpublic void Solve() {\n\t\t\tvar n = ri;\n\t\t\tvar s = rs;\n\t\t\tvar m = s.Length;\n\t\t\tvar end = new int[m + 1];\n\t\t\tbool flip = false;\n\t\t\tFunc<int, int> f = x => (flip ? x * 2 : x) % 3;\n\t\t\tvar ans = new List<int>() { 0 };\n\t\t\tint N = 1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tflip = false;\n\t\t\t\tvar bucket = Enumerate(N * 3, x => x / N);\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tif (s[j] == 'S') { flip ^= true; }\n\t\t\t\t\telse {\n\t\t\t\t\t\tvar l = -1;\n\t\t\t\t\t\tfor (int k = 0; k < 3; k++) {\n\t\t\t\t\t\t\tvar last = end[j] + k * N;\n\t\t\t\t\t\t\tvar pos = f(bucket[last]);\n\t\t\t\t\t\t\tif (pos == 2) l = last;\n\t\t\t\t\t\t\tbucket[last] = f((pos + 1) % 3);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tend[j] = l;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < 2 * N; j++) ans.Add(ans[j % N]);\n\t\t\t\tfor (int j = 0; j < 3 * N; j++) ans[j] += f(bucket[j]) * N;\n\t\t\t\tN *= 3;\n\t\t\t}\n\t\t\tConsole.WriteLine(ans.AsJoinedString());\n\t\t}\n\t\tconst long INF = 1L << 60;\n\t\tstatic int[] dx = { -1, 0, 1, 0 };\n\t\tstatic int[] dy = { 0, 1, 0, -1 };\n\t\tstatic T[] Enumerate<T>(int n, Func<int, T> f) {\n\t\t\tvar a = new T[n]; for (int i = 0; i < a.Length; ++i) a[i] = f(i); return a;\n\t\t}\n\t\tstatic T[][] Enumerate<T>(int n, int m, Func<int, int, T> f) {\n\t\t\treturn Enumerate(n, x => Enumerate(m, y => f(x, y)));\n\t\t}\n\t\tstatic public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\n\nnamespace AtCoder.C\n{\n    public class Program\n    {\n        public static long N { get; private set; }\n        public static int Max { get; private set; }\n        public static Dictionary<long, long> Sarusa { get; private set; }\n\n        public static void Main() { var r = GetResult(); Debug.WriteLine(r); Console.Write(r); }\n\n        private static object GetResult()\n        {\n            N = ReadLong();\n            var T = ReadText().Replace(\"SS\", \"\");\n\n            Max = (int)Math.Pow(3, N);\n            var P = Enumerable.Range(0, Max).Select(x => (long)x).ToList();\n\n            CreateSarusaMap();\n\n            for (int i = 0; i < T.Length; i++)\n            {\n                var dance = T[i];\n                switch (dance)\n                {\n                    case 'S':\n                        S(P);\n                        break;\n                    case 'R':\n                        R(P);\n                        break;\n                }\n            }\n\n            return string.Join(\" \", P);\n        }\n\n        private static void CreateSarusaMap()\n        {\n            var sansin = new Queue<string>();\n            sansin.Enqueue(\"0\");\n            sansin.Enqueue(\"1\");\n            sansin.Enqueue(\"2\");\n\n            for (var i = 0; i < 11; i++)\n            {\n                var count = sansin.Count;\n                for (var j = 0; j < count; j++)\n                {\n                    var x = sansin.Dequeue();\n                    sansin.Enqueue(x + \"0\");\n                    sansin.Enqueue(x + \"1\");\n                    sansin.Enqueue(x + \"2\");\n                }\n            }\n\n            Sarusa = new Dictionary<long, long>() { };\n            while (sansin.Count > 0)\n            {\n                var x = sansin.Dequeue();\n                var key = 0L;\n                var val = 0L;\n                for (var i = 0; i < 12; i++)\n                {\n                    var s = long.Parse(x[i].ToString());\n                    key += (long)Math.Pow(3, i) * s;\n                    val += (long)Math.Pow(3, i) * (s == 1 ? 2 : s == 2 ? 1 : 0);\n                }\n\n                Sarusa.Add(key, val);\n            }\n        }\n\n        private static void S(List<long> p)\n        {\n            for (var i = 0; i < Max; i++)\n            {\n                p[i] = Sarusa[p[i]];\n            }\n        }\n        private static void R(List<long> p)\n        {\n            for (var i = 0; i < Max; i++)\n            {\n                p[i]++;\n                if (p[i] == Max)\n                {\n                    p[i] = 0;\n                }\n            }\n        }\n        private static void R(List<long> p, long count)\n        {\n            for (var i = 0; i < Max; i++)\n            {\n                p[i] += count;\n                if (p[i] >= Max)\n                {\n                    p[i] -= Max;\n                }\n            }\n        }\n\n        public static string ReadText() { return Console.ReadLine(); }\n        public static List<string> ReadTexts() { return Console.ReadLine().Split(' ').ToList(); }\n        public static long ReadLong() { return long.Parse(Console.ReadLine()); }\n        public static (long, long) Read2Longs() { var ls = ReadLongs(); return (ls[0], ls[1]); }\n        public static (long, long, long) Read3Longs() { var ls = ReadLongs(); return (ls[0], ls[1], ls[2]); }\n        public static (long, long, long, long) Read4Longs() { var ls = ReadLongs(); return (ls[0], ls[1], ls[2], ls[3]); }\n        public static (long, long, long, long, long) Read5Longs() { var ls = ReadLongs(); return (ls[0], ls[1], ls[2], ls[3], ls[4]); }\n        public static List<long> ReadLongs() { return Console.ReadLine().Split(' ').Select(x => long.Parse(x)).ToList(); }\n\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace AtCoder.Abc\n{\n    class QuestionC\n    {\n        public static void Main(string[] args)\n        {\n            var sw = new System.IO.StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n            Console.SetOut(sw);\n\n            // 整数の入力\n            long n = long.Parse(Console.ReadLine());\n\n            // 文字列の入力\n            string s = Console.ReadLine();\n\n\n            string[] a = new string[(int)Math.Pow(3,(double)n)];\n            for (int i = 0; i < (int)Math.Pow(3, (double)n); i++)\n            {\n                a[i] = IntToN(i,3);\n            }\n\n            var result = new List<string>();\n            foreach (var item in a) \n            {\n                string str = item;\n                foreach (char c in s)\n                {\n                    if (c == 'S')\n                    {\n                        string r = \"\";\n                        foreach (var i in str)\n                        {\n                            if (i == '0')\n                            {\n                                r += \"0\";\n                            }\n                            else if (i == '1')\n                            {\n                                r += \"2\";\n                            }\n                            else\n                            {\n                                r += \"1\";\n                            }\n                        }\n                        str = r.ToString();\n                    }\n                    else\n                    {\n                        str = IntToN(NToInt(str, 3) + 1 == (int)Math.Pow(3, (double)n) ? 0 : NToInt(str, 3) + 1, 3);\n                    }\n                }\n                result.Add(str);\n            }\n            \n            Console.WriteLine(result.JoinString(\" \", x => NToInt(x, 3).ToString()));\n\n            Console.Out.Flush();\n        }\n        /// <summary>\n        /// int 型の値を N 進数を示す文字列に変換します。\n        /// </summary>\n        /// <param name=\"a\"></param>\n        /// <param name=\"sp\"></param>\n        /// <returns></returns>\n        private static string IntToN(int a, int sp)\n        {\n            return ByteToN(BitConverter.GetBytes(a), sp);\n        }\n\n        /// <summary>\n        /// バイト列を N 進数を示す文字列に変換します。\n        /// </summary>\n        /// <param name=\"b\"></param>\n        /// <param name=\"sp\"></param>\n        /// <returns></returns>\n        private static string ByteToN(byte[] b, int sp)\n        {\n            long n = BitConverter.ToUInt32(b, 0);\n            long num = n;\n\n            char[] ch = getChar(sp);\n\n            string result = string.Empty;\n\n            long amari = 0;\n            while (true)\n            {\n                if (num < sp)\n                {\n                    result = ch[num] + result;\n                    break;\n                }\n                amari = num % sp;\n                num = num / sp;\n                result = ch[amari] + result;\n            }\n            return result;\n        }\n\n        /// <summary>\n        /// N 進数を示す文字列を数字に変換します。\n        /// </summary>\n        /// <param name=\"s\"></param>\n        /// <param name=\"sp\"></param>\n        /// <returns></returns>\n        private static int NToInt(string s, int sp)\n        {\n            return BitConverter.ToInt32(NToByte(s, sp), 0);\n        }\n\n        /// <summary>\n        /// N 進数を示す文字列をバイト列に変換します。\n        /// </summary>\n        /// <param name=\"s\"></param>\n        /// <param name=\"sp\"></param>\n        /// <returns></returns>\n        private static byte[] NToByte(string s, int sp)\n        {\n            s = s.ToLower();\n            char[] ch = getChar(sp);\n\n            long result = 0;\n            int len = s.Length;\n\n            int keta = 0;\n            for (int i = len - 1; i >= 0; i--)\n            {\n                keta = len - i - 1;\n\n                char target = s[i];\n                int index = Array.IndexOf(ch, target);\n                if (index < 0)\n                {\n                    throw new IndexOutOfRangeException();\n                }\n                result += index * ((long)Math.Pow(sp, keta));\n            }\n\n            uint are = (uint)(result & 0xFFFFFFFF);\n            byte[] b = BitConverter.GetBytes(are);\n            return b;\n        }\n\n        /// <summary>\n        /// 文字テーブルを作成します。\n        /// </summary>\n        /// <param name=\"count\"></param>\n        /// <returns></returns>\n        private static char[] getChar(int count)\n        {\n            char[] result = new char[count];\n            for (int i = 0; i < 10 && i < count; i++)\n            {\n                result[i] = (char)('0' + ((char)i));\n            }\n            if (count > 10)\n            {\n                for (int i = 0; i < count - 10; i++)\n                {\n                    result[i + 10] = (char)('a' + ((char)i));\n                }\n            }\n            return result;\n        }\n    }\n    public static class IEnumerableUtil\n    {\n        public static string JoinString<T>(this IEnumerable<T> values, string separator, Func<T, string> converter = null)\n        {\n            if (converter != null)\n            {\n                List<string> buff = new List<string>();\n                foreach (var item in values)\n                    buff.Add(converter(item));\n                return string.Join(separator, buff);\n            }\n            else\n                return string.Join(separator, values);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n\tstatic void Main(string[] args)\n\t{\n\t\tint i, j;\n\t\tint end = (int)Math.Pow(3, 12);\n\n\t\tint n = int.Parse(Console.ReadLine());\n\t\tstring strInput = Console.ReadLine();\n\t\tstring s1;\n\n\t\tint maxnum = (int)Math.Pow(3, n);\n\n\t\tint[] salsaList = new int[maxnum];\n\t\tList<int> memberList = new List<int>(maxnum);\n\n\t\tfor (i = 0; i < salsaList.Length; i++)\n\t\t{\n\n\t\t\tsalsaList[i] = salsa_make(i);\n\t\t\tmemberList.Add(i);\n\t\t\t//Console.WriteLine(\"case \" + i + \": return \" + salsaList[i] + \";\");\n\t\t}\n\n\t\tfor(i = 0; i < strInput.Length; i++)\n\t\t{\n\t\t\ts1 = strInput.Substring(i, 1);\n\n\t\t\tswitch (s1)\n\t\t\t{\n\t\t\t\tcase \"S\":\n\t\t\t\t\tList<int> newMemberList = new List<int>(memberList.ToArray());\n\t\t\t\t\tfor(j = 0; j < memberList.Count; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tnewMemberList[j] = salsaList[memberList[j]];\n\t\t\t\t\t}\n\t\t\t\t\tfor (j = 0; j < memberList.Count; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemberList[j] = newMemberList[j];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"R\":\n\t\t\t\t\tfor (j = 0; j < memberList.Count; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemberList[j]++;\n\t\t\t\t\t\tif(memberList[j] == maxnum)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmemberList[j] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tConsole.Write(memberList[0]);\n\t\tfor (i = 1; i < memberList.Count; i++)\n\t\t{\n\t\t\tConsole.Write(\" \" + memberList[i]);\n\t\t}\n\t\treturn;\n\t}\n\n\tstatic int salsa_make(int num)\n\t{\n\t\tint i;\n\t\tQueue<int> iQueue = new Queue<int>();\n\t\tString str;\n\t\tint n = 1;\n\t\tint result = 0;\n\n\t\twhile (true)\n\t\t{\n\t\t\tswitch (num % 3)\n\t\t\t{\n\t\t\t\tcase 0: iQueue.Enqueue(0); break;\n\t\t\t\tcase 1:\tiQueue.Enqueue(2); break;\n\t\t\t\tcase 2: iQueue.Enqueue(1); break;\n\t\t\t}\n\t\t\tnum /= 3;\n\t\t\t\n\t\t\tif (num == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twhile(iQueue.Count > 0)\n\t\t{\n\t\t\tresult += iQueue.Dequeue() * n;\n\t\t\tn *= 3;\n\t\t}\n\n\t\treturn result;\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.IO;\nusing System.Text;\nusing System.Linq;\n\nusing E = System.Linq.Enumerable;\nusing System.Numerics;\n\ninternal partial class Solver {\n    public void Run() {\n        var n = ni();\n        var t = ns();\n        var three = new long[n + 1];\n        three[0] = 1;\n        for (int i = 1; i < three.Length; i++) {\n            three[i] = three[i - 1] * 3;\n        }\n        var s = new string[n + 1, three[n]];\n        s[0, 0] = t;\n        var ans = new long[three[n]];\n        var builder = new StringBuilder();\n        for (int i = 0; i < n; i++) {\n            var pattern = three[i + 1];\n            for (int j = 0; j < pattern; j++) {\n                int bit = (int)(j / three[i]);\n                int mod = (int)(j % three[i]);\n                var p = s[i, mod];\n                builder.Clear();\n                for (int k = 0; k < p.Length; k++) {\n                    if (p[k] == 'S') {\n                        if (k + 1 < p.Length && p[k + 1] == 'S') {\n                            // ignore SS\n                            k++;\n                            continue;\n                        }\n                        builder.Append('S');\n                        if (bit == 1) bit = 2;\n                        else if (bit == 2) bit = 1;\n                    } else { // R\n                        bit++;\n                        if (bit == 3) {\n                            builder.Append('R');\n                            bit = 0;\n                        }\n                    }\n                }\n                s[i + 1, j] = builder.ToString();\n                for (long k = j; k < ans.Length; k += pattern) {\n                    ans[k] += bit * three[i];\n                }\n            }\n        }\n        cout.WriteLine(string.Join(\" \", ans));\n    }\n}\n\n// PREWRITEN CODE BEGINS FROM HERE\ninternal partial class Solver : Scanner {\n    public static void Main() {\n#if LOCAL\n        byte[] inputBuffer = new byte[1000000];\n        var inputStream = Console.OpenStandardInput(inputBuffer.Length);\n        using (var reader = new StreamReader(inputStream, Console.InputEncoding, false, inputBuffer.Length)) {\n            Console.SetIn(reader);\n            new Solver(Console.In, Console.Out).Run();\n        }\n#else\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Solver(Console.In, Console.Out).Run();\n        Console.Out.Flush();\n#endif\n    }\n\n#pragma warning disable IDE0052\n    private readonly TextReader cin;\n    private readonly TextWriter cout;\n#pragma warning restore IDE0052\n\n    public Solver(TextReader reader, TextWriter writer)\n        : base(reader) {\n        cin = reader;\n        cout = writer;\n    }\n    public Solver(string input, TextWriter writer)\n        : this(new StringReader(input), writer) {\n    }\n\n#pragma warning disable IDE1006\n#pragma warning disable IDE0051\n    private int ni() { return NextInt(); }\n    private int[] ni(int n) { return NextIntArray(n); }\n    private long nl() { return NextLong(); }\n    private long[] nl(int n) { return NextLongArray(n); }\n    private double nd() { return NextDouble(); }\n    private double[] nd(int n) { return NextDoubleArray(n); }\n    private string ns() { return Next(); }\n    private string[] ns(int n) { return NextArray(n); }\n#pragma warning restore IDE1006\n#pragma warning restore IDE0051\n}\n\ninternal static class LinqPadExtension {\n    [Conditional(\"DEBUG\")]\n    public static void Dump<T>(this T obj) {\n#if DEBUG\n        LINQPad.Extensions.Dump(obj);\n#endif\n    }\n}\n\npublic class Scanner {\n    private readonly TextReader Reader;\n    private readonly CultureInfo ci = CultureInfo.InvariantCulture;\n\n    private readonly char[] buffer = new char[2 * 1024];\n    private int cursor = 0, length = 0;\n    private string Token;\n    private readonly StringBuilder sb = new StringBuilder(1024);\n\n    public Scanner()\n        : this(Console.In) {\n    }\n\n    public Scanner(TextReader reader) {\n        Reader = reader;\n    }\n\n    public int NextInt() { return checked((int)NextLong()); }\n    public long NextLong() {\n        var s = Next();\n        long r = 0;\n        int i = 0;\n        bool negative = false;\n        if (s[i] == '-') {\n            negative = true;\n            i++;\n        }\n        for (; i < s.Length; i++) {\n            r = r * 10 + (s[i] - '0');\n#if DEBUG\n            if (!char.IsDigit(s[i])) throw new FormatException();\n#endif\n        }\n        return negative ? -r : r;\n    }\n    public double NextDouble() { return double.Parse(Next(), ci); }\n    public string[] NextArray(int size) {\n        string[] array = new string[size];\n        for (int i = 0; i < size; i++) {\n            array[i] = Next();\n        }\n\n        return array;\n    }\n    public int[] NextIntArray(int size) {\n        int[] array = new int[size];\n        for (int i = 0; i < size; i++) {\n            array[i] = NextInt();\n        }\n\n        return array;\n    }\n\n    public long[] NextLongArray(int size) {\n        long[] array = new long[size];\n        for (int i = 0; i < size; i++) {\n            array[i] = NextLong();\n        }\n\n        return array;\n    }\n\n    public double[] NextDoubleArray(int size) {\n        double[] array = new double[size];\n        for (int i = 0; i < size; i++) {\n            array[i] = NextDouble();\n        }\n\n        return array;\n    }\n\n    public string Next() {\n        if (Token == null) {\n            if (!StockToken()) {\n                throw new Exception();\n            }\n        }\n        var token = Token;\n        Token = null;\n        return token;\n    }\n\n    public bool HasNext() {\n        if (Token != null) {\n            return true;\n        }\n\n        return StockToken();\n    }\n\n    private bool StockToken() {\n        while (true) {\n            sb.Clear();\n            while (true) {\n                if (cursor >= length) {\n                    cursor = 0;\n                    if ((length = Reader.Read(buffer, 0, buffer.Length)) <= 0) {\n                        break;\n                    }\n                }\n                var c = buffer[cursor++];\n                if (33 <= c && c <= 126) {\n                    sb.Append(c);\n                } else {\n                    if (sb.Length > 0) break;\n                }\n            }\n\n            if (sb.Length > 0) {\n                Token = sb.ToString();\n                return true;\n            }\n\n            return false;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n\tstatic void Main(string[] args)\n\t{\n\t\tint i, j;\n\t\tint end = (int)Math.Pow(3, 12);\n\t\t//int end = 47;\n\t\tint result = 0;\n\t\tint[] list = {0,1,2,3,4,5,6};\n\n\t\tint n = int.Parse(Console.ReadLine());\n\t\tstring strInput = Console.ReadLine();\n\t\tstring s1;\n\n\t\tint[] salsaList = new int[(int)Math.Pow(3, n)];\n\t\tList<int> memberList = new List<int>((int)Math.Pow(3, n));\n\n\t\tfor (i = 0; i < salsaList.Length; i++)\n\t\t{\n\n\t\t\tsalsaList[i] = salsa_make(i);\n\t\t\tmemberList.Add(i);\n\t\t\t//Console.WriteLine(\"case \" + i + \": return \" + salsaList[i] + \";\");\n\t\t}\n\n\t\tfor(i = 0; i < strInput.Length; i++)\n\t\t{\n\t\t\ts1 = strInput.Substring(i, 1);\n\n\t\t\tswitch (s1)\n\t\t\t{\n\t\t\t\tcase \"S\":\n\t\t\t\t\tfor(j = 0; j < memberList.Count; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemberList[j] = salsaList[memberList[j]];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"R\":\n\t\t\t\t\tmemberList.Insert(0, memberList[memberList.Count -1]);\n\t\t\t\t\tmemberList.RemoveAt(memberList.Count - 1);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tConsole.Write(memberList[0]);\n\t\tfor (i = 1; i < memberList.Count; i++)\n\t\t{\n\t\t\tConsole.Write(\" \" + memberList[i]);\n\t\t}\n\t\treturn;\n\t}\n\n\tstatic int salsa_make(int num)\n\t{\n\t\tint i;\n\t\tQueue<int> iQueue = new Queue<int>();\n\t\tString str;\n\t\tint n = 1;\n\t\tint result = 0;\n\n\t\twhile (true)\n\t\t{\n\t\t\tswitch (num % 3)\n\t\t\t{\n\t\t\t\tcase 0: iQueue.Enqueue(0); break;\n\t\t\t\tcase 1:\tiQueue.Enqueue(2); break;\n\t\t\t\tcase 2: iQueue.Enqueue(1); break;\n\t\t\t}\n\t\t\tnum /= 3;\n\t\t\t\n\t\t\tif (num == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twhile(iQueue.Count > 0)\n\t\t{\n\t\t\tresult += iQueue.Dequeue() * n;\n\t\t\tn *= 3;\n\t\t}\n\n\t\treturn result;\n\t}\n\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.IO;\nusing System.Text;\nusing System.Linq;\n\nusing E = System.Linq.Enumerable;\nusing System.Numerics;\n\ninternal partial class Solver {\n    public void Run() {\n        var n = ni();\n        var t = ns();\n        var three = new long[n + 1];\n        three[0] = 1;\n        for (int i = 1; i < three.Length; i++) {\n            three[i] = three[i - 1] * 3;\n        }\n        var s = new string[n + 1, three[n]];\n        s[0, 0] = t.Replace(\"SS\", \"\");\n        var ans = new long[three[n]];\n        var builder = new StringBuilder();\n        for (int i = 0; i < n; i++) {\n            var pattern = three[i + 1];\n            for (int j = 0; j < pattern; j++) {\n                int bit = (int)(j / three[i]);\n                int mod = (int)(j % three[i]);\n                var p = s[i, mod];\n                builder.Clear();\n                for (int k = 0; k < p.Length; k++) {\n                    if (p[k] == 'S') {\n                        builder.Append('S');\n                        if (bit == 1) bit = 2;\n                        else if (bit == 2) bit = 1;\n                    } else { // R\n                        bit++;\n                        if (bit == 3) {\n                            builder.Append('R');\n                            bit = 0;\n                        }\n                    }\n                }\n                s[i + 1, j] = builder.Replace(\"SS\", \"\").ToString();\n                var val = bit * three[i];\n                for (long k = j; k < ans.Length; k += pattern) {\n                    ans[k] += val;\n                }\n            }\n        }\n        cout.WriteLine(string.Join(\" \", ans));\n    }\n}\n\n// PREWRITEN CODE BEGINS FROM HERE\ninternal partial class Solver : Scanner {\n    public static void Main() {\n#if LOCAL\n        byte[] inputBuffer = new byte[1000000];\n        var inputStream = Console.OpenStandardInput(inputBuffer.Length);\n        using (var reader = new StreamReader(inputStream, Console.InputEncoding, false, inputBuffer.Length)) {\n            Console.SetIn(reader);\n            new Solver(Console.In, Console.Out).Run();\n        }\n#else\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Solver(Console.In, Console.Out).Run();\n        Console.Out.Flush();\n#endif\n    }\n\n#pragma warning disable IDE0052\n    private readonly TextReader cin;\n    private readonly TextWriter cout;\n#pragma warning restore IDE0052\n\n    public Solver(TextReader reader, TextWriter writer)\n        : base(reader) {\n        cin = reader;\n        cout = writer;\n    }\n    public Solver(string input, TextWriter writer)\n        : this(new StringReader(input), writer) {\n    }\n\n#pragma warning disable IDE1006\n#pragma warning disable IDE0051\n    private int ni() { return NextInt(); }\n    private int[] ni(int n) { return NextIntArray(n); }\n    private long nl() { return NextLong(); }\n    private long[] nl(int n) { return NextLongArray(n); }\n    private double nd() { return NextDouble(); }\n    private double[] nd(int n) { return NextDoubleArray(n); }\n    private string ns() { return Next(); }\n    private string[] ns(int n) { return NextArray(n); }\n#pragma warning restore IDE1006\n#pragma warning restore IDE0051\n}\n\ninternal static class LinqPadExtension {\n    [Conditional(\"DEBUG\")]\n    public static void Dump<T>(this T obj) {\n#if DEBUG\n        LINQPad.Extensions.Dump(obj);\n#endif\n    }\n}\n\npublic class Scanner {\n    private readonly TextReader Reader;\n    private readonly CultureInfo ci = CultureInfo.InvariantCulture;\n\n    private readonly char[] buffer = new char[2 * 1024];\n    private int cursor = 0, length = 0;\n    private string Token;\n    private readonly StringBuilder sb = new StringBuilder(1024);\n\n    public Scanner()\n        : this(Console.In) {\n    }\n\n    public Scanner(TextReader reader) {\n        Reader = reader;\n    }\n\n    public int NextInt() { return checked((int)NextLong()); }\n    public long NextLong() {\n        var s = Next();\n        long r = 0;\n        int i = 0;\n        bool negative = false;\n        if (s[i] == '-') {\n            negative = true;\n            i++;\n        }\n        for (; i < s.Length; i++) {\n            r = r * 10 + (s[i] - '0');\n#if DEBUG\n            if (!char.IsDigit(s[i])) throw new FormatException();\n#endif\n        }\n        return negative ? -r : r;\n    }\n    public double NextDouble() { return double.Parse(Next(), ci); }\n    public string[] NextArray(int size) {\n        string[] array = new string[size];\n        for (int i = 0; i < size; i++) {\n            array[i] = Next();\n        }\n\n        return array;\n    }\n    public int[] NextIntArray(int size) {\n        int[] array = new int[size];\n        for (int i = 0; i < size; i++) {\n            array[i] = NextInt();\n        }\n\n        return array;\n    }\n\n    public long[] NextLongArray(int size) {\n        long[] array = new long[size];\n        for (int i = 0; i < size; i++) {\n            array[i] = NextLong();\n        }\n\n        return array;\n    }\n\n    public double[] NextDoubleArray(int size) {\n        double[] array = new double[size];\n        for (int i = 0; i < size; i++) {\n            array[i] = NextDouble();\n        }\n\n        return array;\n    }\n\n    public string Next() {\n        if (Token == null) {\n            if (!StockToken()) {\n                throw new Exception();\n            }\n        }\n        var token = Token;\n        Token = null;\n        return token;\n    }\n\n    public bool HasNext() {\n        if (Token != null) {\n            return true;\n        }\n\n        return StockToken();\n    }\n\n    private bool StockToken() {\n        while (true) {\n            sb.Clear();\n            while (true) {\n                if (cursor >= length) {\n                    cursor = 0;\n                    if ((length = Reader.Read(buffer, 0, buffer.Length)) <= 0) {\n                        break;\n                    }\n                }\n                var c = buffer[cursor++];\n                if (33 <= c && c <= 126) {\n                    sb.Append(c);\n                } else {\n                    if (sb.Length > 0) break;\n                }\n            }\n\n            if (sb.Length > 0) {\n                Token = sb.ToString();\n                return true;\n            }\n\n            return false;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\n\nnamespace AtCoder.C\n{\n    public class Program\n    {\n        public static long N { get; private set; }\n        public static int Max { get; private set; }\n        public static Dictionary<long, long> Sarusa { get; private set; }\n\n        public static void Main() { var r = GetResult(); Debug.WriteLine(r); Console.Write(r); }\n\n        private static object GetResult()\n        {\n            N = ReadLong();\n            var T = ReadText();\n            Max = (int)Math.Pow(3, N);\n            var P = Enumerable.Range(0, Max).Select(x => (long)x).ToList();\n\n            CreateSarusaMap();\n\n            var pre = T[0];\n            var sCount = 0;\n            var rCount = 0;\n            for (int i = 0; i < T.Length; i++)\n            {\n                var dance = T[i];\n                switch (dance)\n                {\n                    case 'S': sCount++; break;\n                    case 'R': rCount++; break;\n                }\n\n                if (pre != dance)\n                {\n                    switch (pre)\n                    {\n                        case 'S':\n                            if (sCount % 2 == 1)\n                            {\n                                S(P);\n                            }\n                            sCount = 0;\n                            break;\n                        case 'R':\n                            R(P, rCount);\n                            rCount = 0;\n                            break;\n                    }\n                }\n\n                pre = dance;\n            }\n\n            // 最後\n            switch (pre)\n            {\n                case 'S':\n                    if (sCount % 2 == 1)\n                    {\n                        S(P);\n                    }\n                    sCount = 0;\n                    break;\n                case 'R':\n                    R(P, rCount);\n                    rCount = 0;\n                    break;\n            }\n\n            //for (int i = 0; i < T.Length; i++)\n            //{\n            //    var dance = T[i];\n            //    switch (dance)\n            //    {\n            //        case 'S':\n            //            S(P);\n            //            break;\n            //        case 'R':\n            //            R(P);\n            //            break;\n            //        default:\n            //            break;\n            //    }\n            //}\n\n            return string.Join(\" \", P);\n        }\n\n        private static void CreateSarusaMap()\n        {\n            var sansin = new Queue<string>();\n            sansin.Enqueue(\"0\");\n            sansin.Enqueue(\"1\");\n            sansin.Enqueue(\"2\");\n\n            for (var i = 0; i < 11; i++)\n            {\n                var count = sansin.Count;\n                for (var j = 0; j < count; j++)\n                {\n                    var x = sansin.Dequeue();\n                    sansin.Enqueue(x + \"0\");\n                    sansin.Enqueue(x + \"1\");\n                    sansin.Enqueue(x + \"2\");\n                }\n            }\n\n            Sarusa = new Dictionary<long, long>() { };\n            while (sansin.Count > 0)\n            {\n                var x = sansin.Dequeue();\n                var key = 0L;\n                var val = 0L;\n                for (var i = 0; i < 12; i++)\n                {\n                    var s = long.Parse(x[i].ToString());\n                    key += (long)Math.Pow(3, i) * s;\n                    val += (long)Math.Pow(3, i) * (s == 1 ? 2 : s == 2 ? 1 : 0);\n                }\n\n                Sarusa.Add(key, val);\n            }\n        }\n        private static void S(List<long> p)\n        {\n            for (var i = 0; i < Max; i++)\n            {\n                p[i] = Sarusa[p[i]];\n            }\n        }\n        private static void R(List<long> p)\n        {\n            for (var i = 0; i < Max; i++)\n            {\n                p[i]++;\n                if (p[i] == Max)\n                {\n                    p[i] = 0;\n                }\n            }\n        }\n        private static void R(List<long> p, long count)\n        {\n            for (var i = 0; i < Max; i++)\n            {\n                p[i] += count;\n                if (p[i] >= Max)\n                {\n                    p[i] -= Max;\n                }\n            }\n        }\n\n        public static string ReadText() { return Console.ReadLine(); }\n        public static List<string> ReadTexts() { return Console.ReadLine().Split(' ').ToList(); }\n        public static long ReadLong() { return long.Parse(Console.ReadLine()); }\n        public static (long, long) Read2Longs() { var ls = ReadLongs(); return (ls[0], ls[1]); }\n        public static (long, long, long) Read3Longs() { var ls = ReadLongs(); return (ls[0], ls[1], ls[2]); }\n        public static (long, long, long, long) Read4Longs() { var ls = ReadLongs(); return (ls[0], ls[1], ls[2], ls[3]); }\n        public static (long, long, long, long, long) Read5Longs() { var ls = ReadLongs(); return (ls[0], ls[1], ls[2], ls[3], ls[4]); }\n        public static List<long> ReadLongs() { return Console.ReadLine().Split(' ').Select(x => long.Parse(x)).ToList(); }\n\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text;\n\nnamespace AtCoder.C\n{\n    public class Program\n    {\n        public static long N { get; private set; }\n        public static int Max { get; private set; }\n        public static Dictionary<long, long> Sarusa { get; private set; }\n\n        public static void Main() { var r = GetResult(); Debug.WriteLine(r); Console.Write(r); }\n\n        private static object GetResult()\n        {\n            N = ReadLong();\n            var T = ReadText();\n            Max = (int)Math.Pow(3, N);\n            var P = Enumerable.Range(0, Max).Select(x => (long)x).ToList();\n\n            var sansin = new Queue<string>();\n            sansin.Enqueue(\"0\");\n            sansin.Enqueue(\"1\");\n            sansin.Enqueue(\"2\");\n\n            for (int i = 0; i < 10; i++)\n            {\n                var count = sansin.Count;\n                for (int j = 0; j < count; j++)\n                {\n                    var x = sansin.Dequeue();\n                    sansin.Enqueue(x + \"0\");\n                    sansin.Enqueue(x + \"1\");\n                    sansin.Enqueue(x + \"2\");\n                }\n            }\n\n            Sarusa = new Dictionary<long, long>() { };\n            while (sansin.Count > 0)\n            {\n                var x = sansin.Dequeue();\n                var y = x.Replace(\"1\", \"x\").Replace(\"2\", \"1\").Replace(\"x\", \"2\");\n                Sarusa.Add(ToInt16(x), ToInt16(y));\n            }\n\n            foreach (var dance in T)\n            {\n                switch (dance)\n                {\n                    case 'S':\n                        S(P);\n                        break;\n                    case 'R':\n                        R(P);\n                        break;\n                    default:\n                        break;\n                }\n            }\n\n            return string.Join(\" \", P);\n        }\n\n        private static long ToInt16(string x)\n        {\n            var ans = 0L;\n            for (int i = 0; i < 11; i++)\n            {\n                ans += (long)Math.Pow(3, i) * long.Parse(x[i].ToString());\n            }\n\n            return ans;\n        }\n\n        private static void S(List<long> p)\n        {\n            for (int i = 0; i < Max; i++)\n            {\n                p[i] = Sarusa[p[i]];\n            }\n        }\n\n        private static void R(List<long> p)\n        {\n            for (int i = 0; i < Max; i++)\n            {\n                p[i]++;\n                if (p[i] == Max)\n                {\n                    p[i] = 0;\n                }\n            }\n        }\n\n        public static string ReadText() { return Console.ReadLine(); }\n        public static List<string> ReadTexts() { return Console.ReadLine().Split(' ').ToList(); }\n        public static long ReadLong() { return long.Parse(Console.ReadLine()); }\n        public static (long, long) Read2Longs() { var ls = ReadLongs(); return (ls[0], ls[1]); }\n        public static (long, long, long) Read3Longs() { var ls = ReadLongs(); return (ls[0], ls[1], ls[2]); }\n        public static (long, long, long, long) Read4Longs() { var ls = ReadLongs(); return (ls[0], ls[1], ls[2], ls[3]); }\n        public static (long, long, long, long, long) Read5Longs() { var ls = ReadLongs(); return (ls[0], ls[1], ls[2], ls[3], ls[4]); }\n        public static List<long> ReadLongs() { return Console.ReadLine().Split(' ').Select(x => long.Parse(x)).ToList(); }\n\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text;\n\nnamespace AtCoder.C\n{\n    public class Program\n    {\n        public static long N { get; private set; }\n        public static int Max { get; private set; }\n        public static Dictionary<long, long> Sarusa { get; private set; }\n\n        public static void Main() { var r = GetResult(); Debug.WriteLine(r); Console.Write(r); }\n\n        private static object GetResult()\n        {\n            N = ReadLong();\n            var T = ReadText();\n            Max = (int)Math.Pow(3, N);\n            var P = Enumerable.Range(0, Max).Select(x => (long)x).ToList();\n\n            var sansin = new Queue<string>();\n            sansin.Enqueue(\"0\");\n            sansin.Enqueue(\"1\");\n            sansin.Enqueue(\"2\");\n\n            for (int i = 0; i < 11; i++)\n            {\n                var count = sansin.Count;\n                for (int j = 0; j < count; j++)\n                {\n                    var x = sansin.Dequeue();\n                    sansin.Enqueue(x + \"0\");\n                    sansin.Enqueue(x + \"1\");\n                    sansin.Enqueue(x + \"2\");\n                }\n            }\n\n            Sarusa = new Dictionary<long, long>() { };\n            while (sansin.Count > 0)\n            {\n                var x = sansin.Dequeue();\n                var y = x.Replace(\"1\", \"x\").Replace(\"2\", \"1\").Replace(\"x\", \"2\");\n                Sarusa.Add(ToInt16(x), ToInt16(y));\n            }\n\n            foreach (var dance in T)\n            {\n                switch (dance)\n                {\n                    case 'S':\n                        S(P);\n                        break;\n                    case 'R':\n                        R(P);\n                        break;\n                    default:\n                        break;\n                }\n            }\n\n            return string.Join(\" \", P);\n        }\n\n        private static long ToInt16(string x)\n        {\n            var ans = 0L;\n            for (int i = 0; i < 12; i++)\n            {\n                ans += (long)Math.Pow(3, i) * long.Parse(x[i].ToString());\n            }\n\n            return ans;\n        }\n\n        private static void S(List<long> p)\n        {\n            for (int i = 0; i < Max; i++)\n            {\n                p[i] = Sarusa[p[i]];\n            }\n        }\n\n        private static void R(List<long> p)\n        {\n            for (int i = 0; i < Max; i++)\n            {\n                p[i]++;\n                if (p[i] == Max)\n                {\n                    p[i] = 0;\n                }\n            }\n        }\n\n        public static string ReadText() { return Console.ReadLine(); }\n        public static List<string> ReadTexts() { return Console.ReadLine().Split(' ').ToList(); }\n        public static long ReadLong() { return long.Parse(Console.ReadLine()); }\n        public static (long, long) Read2Longs() { var ls = ReadLongs(); return (ls[0], ls[1]); }\n        public static (long, long, long) Read3Longs() { var ls = ReadLongs(); return (ls[0], ls[1], ls[2]); }\n        public static (long, long, long, long) Read4Longs() { var ls = ReadLongs(); return (ls[0], ls[1], ls[2], ls[3]); }\n        public static (long, long, long, long, long) Read5Longs() { var ls = ReadLongs(); return (ls[0], ls[1], ls[2], ls[3], ls[4]); }\n        public static List<long> ReadLongs() { return Console.ReadLine().Split(' ').Select(x => long.Parse(x)).ToList(); }\n\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text;\n\nnamespace AtCoder.C\n{\n    public class Program\n    {\n        public static long N { get; private set; }\n        public static int Max { get; private set; }\n        public static Dictionary<long, long> Sarusa { get; private set; }\n\n        public static void Main() { var r = GetResult(); Debug.WriteLine(r); Console.Write(r); }\n\n        private static object GetResult()\n        {\n            N = ReadLong();\n            var T = ReadText();\n            Max = (int)Math.Pow(3, N);\n            var P = Enumerable.Range(0, Max).Select(x => (long)x).ToList();\n\n            CreateSarusaMap();\n\n            foreach (var dance in T)\n            {\n                switch (dance)\n                {\n                    case 'S':\n                        S(P);\n                        break;\n                    case 'R':\n                        R(P);\n                        break;\n                    default:\n                        break;\n                }\n            }\n\n            return string.Join(\" \", P);\n        }\n\n        private static void CreateSarusaMap()\n        {\n            var sansin = new Queue<string>();\n            sansin.Enqueue(\"0\");\n            sansin.Enqueue(\"1\");\n            sansin.Enqueue(\"2\");\n\n            for (int i = 0; i < 11; i++)\n            {\n                var count = sansin.Count;\n                for (int j = 0; j < count; j++)\n                {\n                    var x = sansin.Dequeue();\n                    sansin.Enqueue(x + \"0\");\n                    sansin.Enqueue(x + \"1\");\n                    sansin.Enqueue(x + \"2\");\n                }\n            }\n\n            Sarusa = new Dictionary<long, long>() { };\n            while (sansin.Count > 0)\n            {\n                var x = sansin.Dequeue();\n                var key = 0L;\n                var val = 0L;\n                for (int i = 0; i < 12; i++)\n                {\n                    var s = long.Parse(x[i].ToString());\n                    key += (long)Math.Pow(3, i) * s;\n                    val += (long)Math.Pow(3, i) * (s == 1 ? 2 : s == 2 ? 1 : 0);\n                }\n                //var y = x.Replace(\"1\", \"x\").Replace(\"2\", \"1\").Replace(\"x\", \"2\");\n                Sarusa.Add(key, val);\n            }\n        }\n\n        private static long ToInt16(string x)\n        {\n            var ans = 0L;\n\n\n            return ans;\n        }\n\n        private static void S(List<long> p)\n        {\n            for (int i = 0; i < Max; i++)\n            {\n                p[i] = Sarusa[p[i]];\n            }\n        }\n\n        private static void R(List<long> p)\n        {\n            for (int i = 0; i < Max; i++)\n            {\n                p[i]++;\n                if (p[i] == Max)\n                {\n                    p[i] = 0;\n                }\n            }\n        }\n\n        public static string ReadText() { return Console.ReadLine(); }\n        public static List<string> ReadTexts() { return Console.ReadLine().Split(' ').ToList(); }\n        public static long ReadLong() { return long.Parse(Console.ReadLine()); }\n        public static (long, long) Read2Longs() { var ls = ReadLongs(); return (ls[0], ls[1]); }\n        public static (long, long, long) Read3Longs() { var ls = ReadLongs(); return (ls[0], ls[1], ls[2]); }\n        public static (long, long, long, long) Read4Longs() { var ls = ReadLongs(); return (ls[0], ls[1], ls[2], ls[3]); }\n        public static (long, long, long, long, long) Read5Longs() { var ls = ReadLongs(); return (ls[0], ls[1], ls[2], ls[3], ls[4]); }\n        public static List<long> ReadLongs() { return Console.ReadLine().Split(' ').Select(x => long.Parse(x)).ToList(); }\n\n    }\n}\n"
  },
  {
    "language": "Octave",
    "code": "[N]=scanf(\"%d\\n\",\"C\");\nNN=3^N;\nT=fgetl(0);\nR=sparse(1:NN,[NN,1:NN-1],1,NN,NN);\nStmp=zeros(1,NN);\nfor i=0:NN-1;\n\tt=i;\n\tu=0;\n\tfor k=1:N;\n\t\tu=u*3+mod(3-mod(t,3),3);\n\t\tt=floor(t/3);\n\tend;\n\tStmp(u+1)=i+1;\nend;\nS=sparse(1:NN,Stmp,1,NN,NN);\nX=sparse(1:NN,1:NN,1,NN,NN);\nfor c=T;\n\tif c=='S';\n\t\tX=S*X;\n\telse\n\t\tX=R*X;\n\tend;\nend;\nx=X*[1:NN]';\ny=1:NN;\ny(x)=y;\ndisp(y'-1)\n"
  },
  {
    "language": "JavaScript",
    "code": "\nfunction Main(input)\n{\n\tinput = input.split(\"\\n\");\n\tvar count = parseInt(input[0]);\n\tvar data = [];\n\t\n\tfor(var cnt = 0; cnt < input[1].length; cnt ++)\n\t{\n\t\tdata.push(input[1].substr(cnt, 1));\n\t}\n\n\tvar player = new Array(Math.pow(3, count));\n\t\n\tfor(var cnt = 0; cnt < player.length; cnt ++)\n\t{\n\t\tplayer[cnt] = cnt;\n\t}\n\n\tfor(var cnt = 0; cnt < data.length; cnt ++)\n\t{\n\t\tif (data[cnt] == \"S\")\n\t\t{\n\t\t\tfor(var cnt2 = 0; cnt2 < player.length; cnt2 ++)\n\t\t\t{\n\t\t\t\tvar two = parseInt(player[cnt2]).toString(3);\n\t\t\t\t\n\t\t\t\tvar arr = [];\n\n\t\t\t\tfor(var cnt3 = 0; cnt3 < two.length; cnt3 ++)\n\t\t\t\t{\n\t\t\t\t\tarr.push(two.substr(cnt3, 1));\n\t\t\t\t}\n\n\t\t\t\tfor(var cnt3 = 0; cnt3 < arr.length; cnt3 ++)\n\t\t\t\t{\n\t\t\t\t\tif (arr[cnt3] == \"1\")\n\t\t\t\t\t{\n\t\t\t\t\t\tarr[cnt3] = \"2\";\n\t\t\t\t\t}else if (arr[cnt3] == \"2\")\n\t\t\t\t\t{\n\t\t\t\t\t\tarr[cnt3] = \"1\";\n\t\t\t\t\t} \n\t\t\t\t}\n\n\t\t\t\tvar two2 = arr.join(\"\");\n\n\t\t\t\tvar nextPos = parseInt(two2, 3);\n\n\t\t\t\tplayer[cnt2] = nextPos;\n\t\t\t}\n\t\t}else{ //R\n\t\t\tfor(var cnt2 = 0; cnt2 < player.length; cnt2 ++)\n\t\t\t{\n\t\t\t\tplayer[cnt2] ++;\n\t\t\t\tplayer[cnt2] = player[cnt2] % player.length;\n\t\t\t}\t\n\t\t}\n\t\tvar newPlayer = new Array(player.length);\n\n\t\tfor(var cnt2 = 0; cnt2 < player.length; cnt2 ++)\n\t\t{\n\t\t\tnewPlayer[player[cnt2]] = cnt2;\n\t\t}\n\t}\n\n\tconsole.log(player.join(\" \"));\n}\n\nMain(require(\"fs\").readFileSync(\"/dev/stdin\", \"utf8\"));\n\n"
  },
  {
    "language": "JavaScript",
    "code": "\nfunction Main(input)\n{\n\tinput = input.split(\"\\n\");\n\tvar count = parseInt(input[0]);\n\tvar data = [];\n\tvar player = new Array(Math.pow(3, count));\n\t\n\tfor(var cnt = 0; cnt < player.length; cnt ++)\n\t{\n\t\tplayer[cnt] = cnt;\n\t}\n\n\tfor(var cnt = 0; cnt < input[1].length; cnt ++)\n\t{\n\t\tif (input[1].charAt(cnt) == \"S\")\n\t\t{\n\t\t\tfor(var cnt2 = 0; cnt2 < player.length; cnt2 ++)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tvar two = parseInt(player[cnt2]).toString(3);\n\n\t\t\t\tvar twoT = \"\";\n\n\t\t\t\tfor(var cnt3 = 0; cnt3 < two.length; cnt3 ++)\n\t\t\t\t{\n\t\t\t\t\ttwoT += two.charAt(cnt3) == \"2\" ? \"1\" : two.charAt(cnt3) == \"1\" ? \"2\" : \"0\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar nextPos = parseInt(twoT, 3);\n\n\t\t\t\tplayer[cnt2] = nextPos;\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t}else{ //R\n\t\t\tfor(var cnt2 = 0; cnt2 < player.length; cnt2 ++)\n\t\t\t{\n\t\t\t\tplayer[cnt2] ++;\n\t\t\t\tplayer[cnt2] = player[cnt2] % player.length;\n\t\t\t}\t\n\t\t}\n\t\tvar newPlayer = new Array(player.length);\n\n\t\tfor(var cnt2 = 0; cnt2 < player.length; cnt2 ++)\n\t\t{\n\t\t\tnewPlayer[player[cnt2]] = cnt2;\n\t\t}\n\t}\n\n\tconsole.log(player.join(\" \"));\n}\n\nMain(require(\"fs\").readFileSync(\"/dev/stdin\", \"utf8\"));\n"
  },
  {
    "language": "Ruby",
    "code": "n=gets.to_i\nts=gets.chomp.chars\nps=[*(0..3**n-1)]\nts.each do |t|\n  if t == 'S'\n    ps.each_with_index do |p,i|\n      hash = {'1'=>'2', '2'=>'1'}\n      ps[i]=p.to_s(3).gsub(/.+?/, hash).to_i(3)\n    end\n  elsif t == 'R'\n    ps.each_with_index do |p,i|\n      if p+1 == 3**n\n        ps[i]=0 \n      else\n        ps[i]=p+1\n      end\n    end\n  end\nend\np ps"
  },
  {
    "language": "Ruby",
    "code": "n=gets.to_i\nts=gets.chomp.chars\nps=[*(0..3**n-1)]\nts.each do |t|\n  if t == 'S'\n    ps.each_with_index do |p,i|\n      hash = {'1'=>'2', '2'=>'1', '0'=>'0'}\n      ps[i]=p.to_s(3).gsub(/.+?/, hash).to_i(3)\n    end\n  elsif t == 'R'\n    ps.each_with_index do |p,i|\n      if p+1 == 3**n\n        ps[i]=0 \n      else\n        ps[i]=p+1\n      end\n    end\n  end\nend\nputs ps.join(\" \")"
  },
  {
    "language": "Ruby",
    "code": "END { load __FILE__ unless $stdin.eof? }\n\nn = gets.to_i\nm = 3**n\n\ns = Array.new(m) { |i| i.to_s(3).tr('12', '21').to_i(3) }\n\npeople = Array.new(m, &:itself)\nt = gets.chomp.gsub('SS', '')\nt = t.scan(/\\G(R*+)(S*+)/)\nt.each do |cr, cs|\n  nr = cr.length\n  ns = cs.length\n  people.map! { |i| (i + nr) % m }\n  people.map! { |i| s[i] } if ns.odd?\nend\n\nputs people * ' '\n"
  },
  {
    "language": "Ruby",
    "code": "n = gets.chomp.to_i\nt = gets.chomp\n\nretsu = Array.new(3 ** n){ |i| i }\n\ndef sarusa retsu\n  retsu.map{ |e| e.to_s(3).gsub(\"1\", \"3\").gsub(\"2\", \"1\").gsub(\"3\", \"2\").to_i(3) }\nend\n\ndef rumba retsu\n  tmp = retsu.pop\n  retsu.unshift tmp\n  retsu\nend\n\nt = t.gsub(\"SS\", \"\")\nt.each_char{ |c|\n  case c\n  when \"S\"\n    retsu = sarusa retsu\n  when \"R\"\n    retsu = rumba retsu\n  end\n}\n\nputs retsu.join(\" \")\n"
  },
  {
    "language": "Ruby",
    "code": "n = gets.chomp.to_i\nt = gets.chomp\n\nretsu = Array.new(3 ** n){ |i| i }\n\ndef sarusa retsu\n  retsu.map{ |e| e.to_s(3).gsub(\"1\", \"3\").gsub(\"2\", \"1\").gsub(\"3\", \"2\").to_i(3) }\nend\n\ndef rumba retsu\n  tmp = retsu.pop\n  retsu.unshift tmp\n  retsu\nend\n\nt.each_char{ |c|\n  case c\n  when \"S\"\n    retsu = sarusa retsu\n  when \"R\"\n    retsu = rumba retsu\n  end\n}\n\nputs retsu.join(\" \")\n"
  },
  {
    "language": "Ruby",
    "code": "END { load __FILE__ unless $stdin.eof? }\n\nn = gets.to_i\nm = 3**n\n\ns = Array.new(m) { |i| i.to_s(3).tr('12', '21').to_i(3) }\nr = Array.new(m) { |i| i + 1 }; r[-1] = 0\nu = r.map { |i| s[i] }\n\npeople = Array.new(m, &:itself)\nt = gets.chomp\nt.gsub!('SS', '')\nt.gsub!('RS', 'U')\nt.gsub!(/R{1,24}/) { |str| str.length.to_s(24) }\nt.each_char do |c|\n  case c\n  when 'S' then people.map! { |i| s[i] }\n  when 'R' then people.map! { |i| r[i] }\n  when 'U' then people.map! { |i| u[i] }\n  else (x = c.to_i(24); people.map! { |i| (i + x) % m })\n  end\nend\n\nputs people * ' '\n"
  },
  {
    "language": "Ruby",
    "code": "N = gets.to_i\n \npeople = 3 ** N\npeople_list = (0..people - 1).to_a\n \ngets.each_char do |c|\n    if c == 'S'\n        new_list = []\n        people_list.count.times do |index|\n            position = people_list[index]\n            sanshin = position.to_s(3).gsub(/1|2/, '1' => '2', '2' => '1')\n            new_position = sanshin.to_i(3)\n            new_list[index] = new_position\n        end\n        people_list = new_list\n    else\n        people_list = people_list.map{|p| p+1 == people ? 0 : p+1}\n    end\nend\n \nputs people_list.join(' ')"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\n\ns = Array.new(3**n) { |i| i.to_s(3).tr('12', '21').to_i(3) }\nr = Array.new(3**n) { |i| i + 1 }; r[-1] = 0\n\npeople = Array.new(3**n, &:itself)\ngets.chomp.each_char do |c|\n  if c == 'S'\n    people.map! { |i| s[i] }\n  else\n    people.map! { |i| r[i] }\n  end\nend\n\nputs people * ' '\n"
  },
  {
    "language": "Ruby",
    "code": "N = gets.to_i\nT = gets.chomp\n\nans = Array.new(3**N, 0)\nc = 3\nts = [T.chars.map{_1 == 'S'}]\nN.times do |i|\n  nt = [[]] * c\n  c.times do |j|\n    x = j / 3**i\n    pre = j - x*c/3\n    nxt = []\n    ts[pre].each do |q|\n      if q\n        x = 3 - x if x != 0\n        if nxt.length >= 1 && nxt[-1] == 0\n          nxt.pop\n        else\n          nxt << true\n        end\n      else\n        x += 1\n        if x == 3\n          x = 0\n          nxt << false\n        end\n      end\n    end\n    j.step(3**N - 1, c) do |k|\n      ans[k] += x*c/3\n    end\n    nt[j] = nxt\n  end\n  ts = nt\n  c *= 3\n  end\nputs ans.join(' ')"
  },
  {
    "language": "Ruby",
    "code": "END { load __FILE__ unless $stdin.eof? }\n\nn = gets.to_i\nm = 3**n\n\ns = Array.new(m) { |i| i.to_s(3).tr('12', '21').to_i(3) }\nrns = Hash.new { |h, k| h[k] = Array.new(m, &:itself).rotate!(k).map! { |i| s[i] } }\nrns[0] = s\n\npeople = Array.new(m, &:itself)\nt = gets.chomp.gsub('SS', '')\nt = t.scan(/\\G(R*+)(S*+)/)\nt.pop\nt.each do |cr, cs|\n  nr = cr.length\n  ns = cs.length\n\n  if ns.odd?\n    ss = rns[nr]\n    people.map! { |i| ss[i] }\n  else\n    people.map! { |i| (i + nr) % m }\n  end\nend\n\nputs people * ' '\n"
  },
  {
    "language": "Ruby",
    "code": "N = gets()\n \npeople = 3 ** N\npeople_list = (0..people - 1).to_a\nindex = 0\nstr = gets()\nstr.each_char do |c|\n    \n    if c == 'S'\n        new_list = []\n        people_list.count.times do |index|\n            position = people_list[index]\n            sanshin = position.to_s(3).gsub(/1|2/, '1' => '2', '2' => '1')\n            new_position = sanshin.to_i(3)\n            new_list[index] = new_position\n        end\n        people_list = new_list\n    else\n        people_list = people_list.map{|p| p+1 == people ? 0 : p+1}\n    end\n    index += 1\nend\n\nprint people_list.join(' ') + ' '"
  },
  {
    "language": "Ruby",
    "code": "n = gets.chop.to_i\narr = []\n(0..(3**n-1)).each do |i|\n    arr << i\nend\nt = gets.chop.to_s\ndef salsa(ind)\n    target = ind.to_s(3).chars.map { |x| x == \"1\" ? 3 : x.to_i }.map { |x| x == 0 ? 0 : x - 1 }.join.to_i(3)\n    return target\nend\nresult = []\nt.each_char do |c|\n    next_arr = []\n    ordered = []\n    if c == \"S\"\n        next_arr[0] = arr[0]\n        (1 .. arr.length-1).each do |ind|\n            next if ordered.include?(ind)\n            target = salsa(ind)\n            next_arr[target] = arr[ind]\n            next_arr[ind] = arr[target]\n            ordered << target\n        end\n    elsif c == \"R\"\n        tmp = arr.slice!(arr.length-1)\n        next_arr = [tmp] + arr\n    end\n    arr = next_arr\nend\n(0 .. arr.length-1).each do |ind|\n    result[arr[ind]] = ind\nend\n\nputs result.join(\" \")\n"
  },
  {
    "language": "Ruby",
    "code": "N = gets().to_i\n \npeople = 3 ** N\npeople_list = (0..people - 1).to_a\nstr = gets()\nstr.each_char do |c|\n    \n    if c == 'S'\n        new_list = []\n        people_list.count.times do |index|\n            position = people_list[index]\n            sanshin = position.to_s(3).gsub(/1|2/, '1' => '2', '2' => '1')\n            new_position = sanshin.to_i(3)\n            new_list[index] = new_position\n        end\n        people_list = new_list\n    else\n        people_list = people_list.map{|p| p+1 == people ? 0 : p+1}\n    end\nend\n\nprint people_list.join(' ') + ' '"
  },
  {
    "language": "Ruby",
    "code": "N = gets.to_i\n\npeople = 3 ** N\npeople_list = (0..people - 1).to_a\n\ngets.each_char do |c|\n    if c == 'S'\n        new_list = []\n        people_list.count.times do |index|\n            position = people_list[index]\n            sanshin = position.to_s(3).gsub(/1|2/, '1' => '2', '2' => '1')\n            new_position = sanshin.to_i(3)\n            new_list[index] = new_position\n        end\n        people_list = new_list\n    else\n        people_list = people_list.map{|p| p == people ? 0 : p+1}\n    end\nend\n\nputs people_list.join(' ')\n"
  },
  {
    "language": "Ruby",
    "code": "END { load __FILE__ unless $stdin.eof? }\n\nn = gets.to_i\nm = 3**n\n\ns = Array.new(m) { |i| i.to_s(3).tr('12', '21').to_i(3) }\nrns = Hash.new { |h, k| h[k] = s.values_at(*Array.new(m, &:itself).rotate!(k)) }\nrns[0] = s\n\npeople = Array.new(m, &:itself)\nt = gets.chomp.gsub('SS', '')\nt = t.scan(/\\G(R*+)(S*+)/)\nt.pop\nt.each do |cr, cs|\n  nr = cr.length\n  ns = cs.length\n\n  if ns.odd?\n    ss = rns[nr]\n    people = ss.values_at(*people)\n  else\n    people.map! { |i| (i + nr) % m }\n  end\nend\n\nputs people * ' '\n"
  },
  {
    "language": "Ruby",
    "code": "END { load __FILE__ unless $stdin.eof? }\n\nrequire 'numo/narray'\n\nn = gets.to_i\nm = 3**n\n\ns = Numo::UInt64.cast(Array.new(m) { |i| i.to_s(3).tr('12', '21').to_i(3) })\nrns = Hash.new { |h, k| h[k] = Numo::UInt64.cast(Array.new(m, &:itself).rotate!(k).map! { |i| s[i] })}\nrns[0] = s\n\npeople = Array.new(m, &:itself)\nt = gets.chomp.gsub('SS', '')\nt = t.scan(/\\G(R*+)(S*+)/)\nt.pop\nt.each do |cr, cs|\n  nr = cr.length\n  ns = cs.length\n\n  if ns.odd?\n    ss = rns[nr]\n    people.map! { |i| ss[i] }\n  else\n    people.map! { |i| (i + nr) % m }\n  end\nend\n\nputs people * ' '\n"
  },
  {
    "language": "Ruby",
    "code": "attrs = Array.new\nwhile line = $stdin.gets\n  attrs << line.chomp.split\nend\n\nrequire 'pp'\nN = attrs[0][0].to_i\nnum = 3**N\nplace = {}\nnum.times {|n| place[n]=n}\np = [*0...num]\nsarusa = {}\nrunba = {}\nnum.times do |i|\n  sarusa[i] = i.to_s(3).split(/\\s*/).map{|z| if z == '1' then 2 elsif z == '2' then 1 else 0 end}.join.to_i(3)\n  next_place = i + 1\n  next_place = 0 if i + 1 == num\n  runba[i] = next_place\nend\n\nattrs[1][0].split(/\\s*/).each do |t|\n  if t == 'S' then\n    place.each do |key, value|\n      place[key] = sarusa[value]\n    end\n  else\n    place.each do |key, value|\n      place[key] = runba[value]\n    end\n  end\nend\nputs place.values.join(' ')"
  },
  {
    "language": "Ruby",
    "code": "N = gets().to_i\n \npeople = 3 ** N\npeople_list = (0..people - 1).to_a\nindex = 0\nstr = gets()\nstr.each_char do |c|\n    next_value = str[index+1]\n    if next_value == 'S' && c == 'S'\n        next\n    elsif index > 0 && str[index-1] == 'S' && c == 'S'\n        next\n    end\n    \n    if c == 'S'\n        new_list = []\n        people_list.count.times do |index|\n            position = people_list[index]\n            sanshin = position.to_s(3).gsub(/1|2/, '1' => '2', '2' => '1')\n            new_position = sanshin.to_i(3)\n            new_list[index] = new_position\n        end\n        people_list = new_list\n    else\n        people_list = people_list.map{|p| p+1 == people ? 0 : p+1}\n    end\n    index += 1\nend\n \nputs people_list.join(' ') + ' '"
  },
  {
    "language": "Ruby",
    "code": "N = gets.to_i\n\npeople = 3 ** N\npeople_list = (0..people - 1).to_a\n\ngets.each_char do |c|\n    if c == 'S'\n        people_list.count.times do |index|\n            p = people_list[index]\n            sanshin = p.to_s(3).gsub(/1|2/, '1' => '2', '2' => '1')\n            people_list[index] = sanshin.to_i(3)\n        end\n    else\n        n = people_list.pop\n        people_list.unshift(n)\n    end\nend\n\nputs people_list.join(' ')"
  },
  {
    "language": "Ruby",
    "code": "N = gets().to_i\n \npeople = 3 ** N\npeople_list = (0..people - 1).to_a\n \ngets().each_char do |c|\n    if c == 'S'\n        new_list = []\n        people_list.count.times do |index|\n            position = people_list[index]\n            sanshin = position.to_s(3).gsub(/1|2/, '1' => '2', '2' => '1')\n            new_position = sanshin.to_i(3)\n            new_list[index] = new_position\n        end\n        people_list = new_list\n    else\n        people_list = people_list.map{|p| p+1 == people ? 0 : p+1}\n    end\nend\n \nputs people_list.join(' ')"
  },
  {
    "language": "Ruby",
    "code": "N = gets.to_i\n \npeople = 3 ** N\npeople_list = (0..people - 1).to_a\nindex = 0\nstr = gets\nstr.each_char do |c|\n    next_value = str[index+1]\n    if next_value == 'S' && c == 'S'\n        next\n    elsif index > 0 && str[index-1] == 'S' && c == 'S'\n        next\n    end\n    \n    if c == 'S'\n        new_list = []\n        people_list.count.times do |index|\n            position = people_list[index]\n            sanshin = position.to_s(3).gsub(/1|2/, '1' => '2', '2' => '1')\n            new_position = sanshin.to_i(3)\n            new_list[index] = new_position\n        end\n        people_list = new_list\n    else\n        people_list = people_list.map{|p| p+1 == people ? 0 : p+1}\n    end\n    index += 1\nend\n\nprint people_list.join(' ') + ' '"
  },
  {
    "language": "PHP",
    "code": "<?php\n// https://atcoder.jp/contests/practice/tasks/practice_1\nlist($N) = $stream->readLine('%d');\nlist($T) = $stream->readLine('%s');\n\n$N = pow(3, $N);\n\n// 元通りの動作を消す\n$T = str_replace('SS', '', $T);\n\n$P = [];\n$C = [];\nfor ($n = 0; $n < $N; ++$n) {\n    $P[] = $n;\n    $C[] = (int)base_convert(str_replace([1, 2, 3], [3, 1, 2], base_convert($n, 10, 3)), 3, 10);\n}\n\nfor ($i = 0, $j = strlen($T); $i < $j; ++$i) {\n    if ($T[$i] == 'S') {\n        $Q = $P;\n        for ($n = 0; $n < $N; ++$n) {\n            $Q[$C[$n]] = $P[$n];\n        }\n        $P = $Q;\n    } else { // 'R'\n        $k = strpos($T, 'S', $i);\n        if ($k === false) {\n            $k = $i + 1;\n        }\n        $t = $i - $k;\n        $P = array_merge(array_slice($P, $t), array_slice($P, 0, $t));\n        $i = $k - 1;\n    }\n}\n\n$Q = $P;\nfor ($n = 0; $n < $N; ++$n) {\n    $Q[$P[$n]] = $n;\n}\n$P = $Q;\n\n$stream->writeLine(implode(' ', $P));\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nclass AtCoderStream\n{\n    public function readLine($format)\n    {\n        return fscanf(STDIN, $format);\n    }\n\n    public function writeLine($format)\n    {\n        echo $format, \"\\n\";\n    }\n}\n\n// export\n$stream = new AtCoderStream();\n\n// https://atcoder.jp/contests/practice/tasks/practice_1\nlist($N) = $stream->readLine('%d');\nlist($T) = $stream->readLine('%s');\n\n$N = pow(3, $N);\n\n// 元通りの動作を消す\n$T = str_replace('SS', '', $T);\n\n$P = [];\n$C = [];\nfor ($n = 0; $n < $N; ++$n) {\n    $P[] = $n;\n    $C[] = (int)base_convert(str_replace([1, 2, 3], [3, 1, 2], base_convert($n, 10, 3)), 3, 10);\n}\n\nfor ($i = 0, $j = strlen($T); $i < $j; ++$i) {\n    if ($T[$i] == 'S') {\n        $Q = $P;\n        for ($n = 0; $n < $N; ++$n) {\n            $Q[$C[$n]] = $P[$n];\n        }\n        $P = $Q;\n\t    $stream->writeLine('S:' . implode(' ', $P));\n    } else { // 'R'\n        $k = strpos($T, 'S', $i);\n        if ($k === false) {\n            $k = $i + 1;\n        }\n        $t = $i - $k;\n        $P = array_merge(array_slice($P, $t), array_slice($P, 0, $t));\n        $i = $k - 1;\n    \t$stream->writeLine('R:' . implode(' ', $P));\n    }\n}\n\n$Q = $P;\nfor ($n = 0; $n < $N; ++$n) {\n    $Q[$P[$n]] = $n;\n}\n$P = $Q;\n\n$stream->writeLine(implode(' ', $P));\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nfscanf(STDIN, \"%d\", $n);\n$ts = str_split(trim(fgets(STDIN)));\n\n$ps = array();\nfor ($i=0; $i < pow(3, $n); ++$i) {\n  $ps[] = $i;\n}\n\n$ps = array_reverse($ps);\n\nforeach ($ts as $t) {\n  //var_dump(implode(' ', $ps));\n  if ($t === 'S') {\n    $ps = salsa($ps);\n  } else {\n    $ps = rumba($ps);\n  }\n  $ps = array_values($ps);\n}\n\n$ps = array_reverse($ps);\nasort($ps);\n$keys = array_keys($ps);\n\necho implode(' ', $keys);\n\nfunction salsa($ps)\n{\n  $array = array();\n\n  $i = count($ps);\n  foreach ($ps as $k => $v) {\n    --$i;\n\n    $tmp = base_convert($i, 10, 3);\n    $tmp = str_replace('1', 'a', $tmp);\n    $tmp = str_replace('2', 'b', $tmp);\n    $tmp = str_replace('a', '2', $tmp);\n    $tmp = str_replace('b', '1', $tmp);\n    $tmp = base_convert($tmp, 3, 10);\n    $array[$tmp] = $v;\n\n    // switch ($k % 3) {\n    //   case 0:\n    //     $array[$k+1] = $v;\n    //     break;\n    //   case 1:\n    //     $array[$k-1] = $v;\n    //     break;\n    //   case 2:\n    //     $array[] = $v;\n    //     break;\n    // }\n  }\n  krsort($array);\n\n  return $array;\n}\n\nfunction rumba($ps)\n{\n  $ps[] = current($ps);\n  unset($ps[0]);\n\n  return $ps;\n}\n"
  },
  {
    "language": "PHP",
    "code": "<?php\n\nclass AtCoderStream\n{\n    public function readLine($format)\n    {\n        return fscanf(STDIN, $format);\n    }\n\n    public function writeLine($format)\n    {\n        echo $format, \"\\n\";\n    }\n}\n\n// export\n$stream = new AtCoderStream();\n\n// https://atcoder.jp/contests/practice/tasks/practice_1\nlist($N) = $stream->readLine('%d');\nlist($T) = $stream->readLine('%s');\n\n$N = pow(3, $N);\n\n// 元通りの動作を消す\n$T = str_replace('SS', '', $T);\n\n$P = [];\n$C = [];\nfor ($n = 0; $n < $N; ++$n) {\n    $P[] = $n;\n    $C[] = (int)base_convert(str_replace([1, 2, 3], [3, 1, 2], base_convert($n, 10, 3)), 3, 10);\n}\n\nfor ($i = 0, $j = strlen($T); $i < $j; ++$i) {\n    if ($T[$i] == 'S') {\n        $Q = $P;\n        for ($n = 0; $n < $N; ++$n) {\n            $Q[$C[$n]] = $P[$n];\n        }\n        $P = $Q;\n    } else { // 'R'\n        $k = strpos($T, 'S', $i);\n        if ($k === false) {\n            $k = $i + 1;\n        }\n        $t = $i - $k;\n        $P = array_merge(array_slice($P, $t), array_slice($P, 0, $t));\n        $i = $k - 1;\n    }\n}\n\n$Q = $P;\nfor ($n = 0; $n < $N; ++$n) {\n    $Q[$P[$n]] = $n;\n}\n$P = $Q;\n\n$stream->writeLine(implode(' ', $P));\n"
  },
  {
    "language": "Python",
    "code": "\ndef Salsa(N_Pow, Len):\n    Dest = [0] * (Len//3)\n    Dest[0] = 0\n    Dest[1] = 2\n    Dest[2] = 1\n\n    Value_Min = 1\n    for Pow in range(1, N_Pow-1):\n        Value_Min *= 3\n        Value_Max = Value_Min *2-1\n        for Num in range(Value_Min, Value_Max+1, 1):\n            Value2 = Dest[Num-Value_Min] + 2 * Value_Min\n            Dest[Num] = Value2\n            Dest[Value2] = Num\n    return Dest\n\n\n\ndef move(Dest_Salsa, PosList, Is_Salsa):\n    N = len(PosList)\n    N_3 = N//3\n    N_2_3 = N_3 *2\n    if(Is_Salsa == True):\n        for Num in range(N):\n            if(PosList[Num] >= N_2_3):\n                PosList[Num] = Dest_Salsa[ PosList[Num]-N_2_3 ] + N_3\n            elif(PosList[Num] >= N_3):\n                PosList[Num] = Dest_Salsa[ PosList[Num]-N_3 ] + N_2_3\n            else:\n                PosList[Num] = Dest_Salsa[ PosList[Num] ]\n    else:\n        for Num in range(N):\n            PosList[Num] = (PosList[Num]+1) % N\n\ndef moves(N_Pow, PosList, Str):\n    MoveTimes = len(Str)\n    Len = len(PosList)\n\n    # Dest_Lumba = Lumba(N_Pow)\n    Dest_Salsa = Salsa(N_Pow, Len)\n    for k in range(MoveTimes):\n        if(Str[k] == 'S'):\n            move(Dest_Salsa, PosList, True)\n        else:\n            move(Dest_Salsa, PosList, False)\n    Str = \"\"\n    for Num in range( Len ):\n        Str = Str + str(PosList[Num]) + \" \"\n    print(Str)\n\nif(__name__ == \"__main__\"):\n    N_Pow = int( input().strip() )\n    T = input().strip()\n\n\n    Len = 3**(N_Pow)\n    PosList = []\n    for Num in range(Len):\n        PosList.append(Num)\n    moves(N_Pow, PosList, T)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\ndef main():\n  n=int(input())\n  huhan=np.empty(3**n, np.int32)\n  a=[0,2,1]\n  for i in range(3**n):\n    b=[]\n    h=0\n    z=i\n    while True:\n      s=z//3\n      y=z%3\n      b=b+[a[y]]\n      if s==0:\n        break\n      z=s\n    for j in range(len(b)-1,-1,-1):\n      h=h*3+b[j]\n    huhan[i]=h\n  n3=3**n\n  p= np.arange(3**n)\n  t=input()\n  t=t.replace(\"SS\",\"\")\n  snum=False\n  for sr in t:\n    if sr==\"R\":\n      p += 1\n      p %= n3\n    else:\n      for x in range(3**n):\n        p[x]=huhan[p[x]]\n  print(\" \".join(map(str,p)))\nmain()"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef R(x):\n    x.insert(0, x.pop(-1))\n    return x\n    \ndef S(x, n):\n    ex = [0]*n\n    for j in range(len(x)//3):\n        \n        k = j\n        tmp = 0\n        m = 3\n        q = j*3\n        while k > 0:\n            if k%3 == 1:\n                tmp = tmp + 2*m\n            elif k%3 == 2:\n                tmp = tmp + 1*m\n            k = k//3\n            m = m*3\n        ex[tmp] = x[q]\n        ex[tmp + 2] = x[q +1]\n        ex[tmp + 1] = x[q +2]\n    return(ex)\n            \n    \ndef main():\n    N = 3**int(sys.stdin.readline())\n    T = sys.stdin.readline()\n    l = list(range(N))\n    p = [0]*(N)\n    \n    for i in range(len(T)):\n        if T[i] == \"R\":\n            l = R(l)\n        else:\n            l = S(l, N)\n    for i in range(N):\n        p[l[i]] = i\n    \n    for i in range(N):\n        print(p[i], end=\" \")\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nT = input()\nT = list(T)\n\nL = list(range(3**N))\nL2 = list(range(3**N))\ntL = 0\n\ndef base10to(n, b):\n  if (int(n/b)):\n    return base10to(int(n/b), b) + str(n%b)\n  return str(n%b)\n\n\nfor i in range(len(T)):\n  if(T[i] == \"R\"):\n    for i in range(len(L)):\n      if(L[i]==len(L)-1):\n        L2[i] = 0\n      else:\n        L2[i] = L[i]+1\n    L = L2\n  else:\n    for i in range(len(L)):\n      th = base10to(L[i], 3)\n      tha = list(th)\n      th_replace = [\"2\" if i == \"1\" else \"1\" if i == \"2\" else i for i in tha]\n      th_replace = ''.join(th_replace)\n      L2[i] = int(th_replace,3)\n\n    L = L2\nL = [str(i) for i in L]\nL = ' '.join(L)\nprint(L)"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\nreadline = sys.stdin.readline\n\nN = int(readline())\nT = readline().strip()\n\n#Salsaの２回連続は元に戻るので削除\nT = T.replace('SS', '')\n\nTlen = len(T)\nD = ()\nRc = 0\nfor i in range(Tlen):\n    if T[i] == 'S':\n        if Rc:\n            #Rumba連続回数\n            D = D + (Rc,)\n            Rc = 0\n\n        #Salsa\n        D = D + (0,)\n    else:\n        #Rumba連続回数加算\n        Rc += 1\n\nif Rc:\n    #Rumba連続回数\n    D = D + (Rc,)\n    Rc = 0\n\n\nN3 = 3 ** N\nP = list(range(N3))\n\nfor Dn in D:\n    if Dn:\n        #Rumba: Dn移動\n        #temp = P[N3 - Dn:]\n        #P[Dn:] = P[:-Dn]\n        #P[:Dn] = temp\n        P[:Dn], P[Dn:] = P[N3 - Dn:], P[:-Dn]\n\n    else:\n        #Salsa: 1と2入れ替え\n        for i in range(N):\n            start = 3 ** i\n            stop = 3 ** N\n            step = 3 ** (i + 1)\n            dp = 3 ** i\n            for j in range(start, stop, step):\n                j1 = j + dp\n                j2 = j1 + dp\n                #Pb = P[j:j1]\n                #P[j:j1] = P[j1:j2]\n                #P[j1:j2] = Pb\n                P[j:j1], P[j1:j2] = P[j1:j2], P[j:j1]\n\n#出力用データ作成\nR = [None] * N3\nfor i in range(N3):\n    R[P[i]] = i\n    \nprint(*R)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\n\ndef P_change(N, P):\n    #Salsa\n    for i in range(N):\n        start = 3 ** i\n        step = 3 ** (i + 1)\n        dp = 3 ** i\n        for j in range(start, 3 ** N, step):\n            P[j:j + dp], P[j + dp:j + dp * 2] = P[j + dp:j + dp * 2], P[j:j + dp]\n    \n    return P\n\n\ndef P_slide(P):\n    #Rumba\n    temp = P[-1]\n    P[1:] = P[:-1]\n    P[0] = temp\n\n    return P\n\n\nN = int(input())\nT = input()\n\nP = list(range(3**N))\nT = T.replace('SS', 's')\n\nfor Ti in T:\n    if Ti == 'S':\n        #Salsa\n        P = P_change(N, P)\n    elif Ti == 'R':\n        #Rumba\n        P = P_slide(P)\n\nprint(' '.join([str(P.index(i)) for i in range(len(P))]))\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\ncnt = int(input())\ntxt = input()\nloop = 3 ** cnt\nnum = [x for x in range(loop)]\n\ndef func1(x):\n    if (int(x/3)):\n        return func1(int(x/3))+str(x%3)\n    return str(x%3)\n\ndef func2(s):\n    l = len(s)\n    output=0\n    for i in range(l):\n        if s[i] == '1':\n            output += 2 * (3**(l-i-1))\n        elif s[i] == '2':\n            output += (3**(l-i-1))\n    return output\n\ntrans = [func2(func1(x)) for x in range(loop)]\nnum = np.array(num)\n\nfor t in txt:\n    if t == 'S':\n        for i in range(1, loop):\n            num[i] = trans[num[i]]\n    else:\n        num += 1\n        num[num==loop] = 0\n    \noutput = ''\nfor i in range(loop):\n    if i != 0:\n        output += ' '\n    output += str(num[i])\nprint(output)"
  },
  {
    "language": "Python",
    "code": "sdfgs"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\nreadline = sys.stdin.readline\n\nN = int(readline())\nT = readline().strip()\n\n#Salsaの２回連続は元に戻るので削除\nT = T.replace('SS', '')\n\nTlen = len(T)\nD = ()\nRc = 0\nfor i in range(Tlen):\n    if T[i] == 'S':\n        if Rc:\n            #Rumba連続回数\n            D = D + (Rc,)\n            Rc = 0\n\n        #Salsa\n        D = D + (0,)\n    else:\n        #Rumba連続回数加算\n        Rc += 1\n\nif Rc:\n    #Rumba連続回数\n    D = D + (Rc,)\n    Rc = 0\n\n\nN3 = 3 ** N\nP = list(range(N3))\n\nfor Dn in D:\n    if Dn:\n        #Rumba: Dn移動\n        temp = P[N3 - Dn:]\n        P[Dn:] = P[:-Dn]\n        P[:Dn] = temp\n        #P[:Dn], P[Dn:] = P[N3 - Dn:], P[:-Dn]\n\n    else:\n        #Salsa: 1と2入れ替え\n        for i in range(N):\n            start = 3 ** i\n            stop = 3 ** N\n            step = 3 ** (i + 1)\n            dp = 3 ** i\n            for j in range(start, stop, step):\n                j1 = j + dp\n                j2 = j1 + dp\n                Pb = P[j:j1]\n                P[j:j1] = P[j1:j2]\n                P[j1:j2] = Pb\n                #P[j:j1], P[j1:j2] = P[j1:j2], P[j:j1]\n\n#出力用データ作成\nR = [None] * N3\nfor i in range(N3):\n    R[P[i]] = i\n    \nprint(*R)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\n# 実行環境(0:vscode, 1:atcoder)\nMODE = 1\n\n# 入力の次元\nDIMENSION = 2\n\n# int型に変換\nINT_TYPE = 0\n\nif not (MODE):\n    with open(\"input.txt\", \"r\") as f:\n        s = f.read()\nelse:\n    s = sys.stdin.read()\n\nif DIMENSION == 1:\n    if INT_TYPE == 1:\n        s = int(s)\nelif DIMENSION == 2:\n    if INT_TYPE == 0:\n        s = s.split()\n    elif INT_TYPE == 1:\n        s = [int(x) for x in s.split()]\nelif DIMENSION == 3:\n    if INT_TYPE == 0:\n        s = [x.split() for x in s.splitlines()]\n    elif INT_TYPE == 1:\n        s = [[int(y) for y in x.split()] for x in s.splitlines()]\n\n\ndef base10to(n, b):\n    if (int(n/b)):\n        return base10to(int(n/b), b) + str(n % b)\n    return str(n % b)\n\n\nN = int(s[0])\nT = s[1]\nNUM = 3 ** N\nP = list(range(NUM))\n\nfor t in T:\n    if t == \"S\":\n        for j, p in enumerate(P):\n            p_3 = [None] * N\n            p_3_mod = p\n            for i in range(N):\n                p_3[i] = p_3_mod // 3 ** (N-i-1)\n                p_3_mod = p_3_mod % 3 ** (N-i-1)\n                if p_3[i] == 1:\n                    p_3[i] = 2\n                elif p_3[i] == 2:\n                    p_3[i] = 1\n            p_new = 0\n            for i in range(N):\n                p_new += 3 ** i * p_3[N - i - 1]\n            P[j] = p_new\n    else:\n        for i in range(NUM):\n            P[i] += 1\n            if P[i] == NUM:\n                P[i] = 0\n\ntext = \"\"\nfor p in P:\n    text += str(p) + \" \"\nprint(text)\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nT = input()\n\np = []\nfor i in range(3**N):\n  p.append(i)\n\ndef Base3(X): #10進数を3進数に\n    if (int(X/3)):\n        return Base3(int(X/3))+str(X%3)\n    return str(X%3)\n\ndef salsa(p):\n  for i in range(len(p)):\n    p[i] = Base3(p[i])\n    p[i] = p[i].replace('1', '3')\n    p[i] = p[i].replace('2', '1')\n    p[i] = p[i].replace('3', '2')\n    p[i] = int(p[i], 3)\n\ndef rumba(p):\n  for i in range(len(p)):\n    if p[i] == 3**N -1:\n      p[i] = 0\n    else:\n      p[i] = p[i] + 1\n      \nfor i in range(len(T)):\n  if T[i] == 'S':\n    salsa(p)\n  if T[i] == 'R':\n    rumba(p)  \n    \nans = list(map(str,p))\nAns = ' '.join(ans)\nprint(Ans)"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nT = input()\nvol = 3**N\np = [i for i in range(vol)]\ndef base10to3(x):\n    if(int(x/3)):\n        return base10to3(int(x/3))+str(x%3)\n    return str(x%3)\ndef base3to10(x):\n    out = 0\n    for i in range(1,len(str(x))+1):\n        out += int(x[-i])*(3**(i-1))\n    return out\ndef sarusa(i):\n    before = base10to3(i)\n    after=before.translate(str.maketrans({'1':'2','2':'1'}))\n    return int(base3to10(after))\n\nfor i in range(len(T)):\n    _p = p\n    if T[i] == 'S':\n        for j in range(vol):\n            p[j] = sarusa(_p[j])\n    else:\n        for j in range(vol):\n            p[j] = (_p[j]+1)%vol\nprint(' '.join(map(str,p)))"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nt=list(input())\nn=3**n\nl=[]\nfor i in range(n):\n  u=0\n  for k in range(12,0,-1):\n    p=i//3**(k-1)\n    i-=(3**(k-1))*p\n    if p==1:\n      u+=(3**(k-1))*2\n    elif p==2:\n      u+=(3**(k-1))\n  l.append(u)\ndef sarusa(a):\n  an=ans\n  return an[l[an.index(a)]]\nans=list(range(n))\nfor q in t:\n  if q=='S':\n    al=[]\n    for y in l:\n      al.append(ans[y])\n    ans=al\n  else:\n    d=[]\n    d.append(ans[n-1])\n    ans=d+ans[0:n-1]\nfor i in range(n):\n  print(ans.index(i),end=\" \")"
  },
  {
    "language": "Python",
    "code": "def salsa(X):\n    if X%3 == 1:\n        a = 2\n    elif X%3 == 2:\n        a = 1\n    else:\n        a = 0\n    if (int(X/3)):\n        return salsa(int(X/3))+str(a)\n    return str(a)\n\ndef Base_3_to_10(X):\n    out = 0\n    for i in range(1,len(str(X))+1):\n        out += int(X[-i])*(3**(i-1))\n    return out\n\nn = int(input())\nt = input()\np = []\nfor i in range(3 ** n):\n    p.append(i)\n\nfor ti in t:\n    if ti == 'S':\n        p = list(map(lambda x: salsa(x), p))\n        p = list(map(lambda x: Base_3_to_10(x), p))\n    else:\n        p = list(map(lambda x: (x + 1) % 3 ** n, p))\nprint(*p, sep=' ')"
  },
  {
    "language": "Python",
    "code": "# AGC044 C\nimport itertools\n\ndef Base_10_to_n(X, n):\n    if (int(X/n)):\n        return Base_10_to_n(int(X/n), n)+str(X%n)\n    return str(X%n)\n\ndef mapping(_list):\n    return [m_list[i] for i in _list]\n\nn = int(input())\nt_list = list(input())\na_list = [int(i) for i in range(3**n)]\n\n_list = [Base_10_to_n(i, 3) for i in range(3**n)]\n_list = [x.replace(\"1\",\"4\") for x in _list]\n_list = [x.replace(\"2\",\"1\") for x in _list]\n_list = [x.replace(\"4\",\"2\") for x in _list]\nm_list = [int(x, 3) for x in _list]\n\ngr = itertools.groupby(t_list)\nfor key,value in gr:\n    if key == \"S\":\n        if len(list(value))%2 == 0:\n            continue\n        else:\n            a_list = mapping(a_list)\n    else:\n        for j in range(len(list(value))):\n            for i in range(3**n):\n                a_list[i] = (a_list[i]+1)%(3**n)\n\nprint(*a_list)"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\nimport numpy as np\nfrom numba import njit\n\n\n@njit('i8[:](i8, i8[:])')\ndef P_change(N, P):\n    #Salsa\n    for i in range(N):\n        start = 3 ** i\n        stop = 3 ** N\n        step = 3 ** (i + 1)\n        dp = 3 ** i\n        for j in range(start, stop, step):\n            P[j:j + dp], P[j + dp:j + dp * 2] = P[j + dp:j + dp * 2].copy(), P[j:j + dp].copy()\n    \n    return P\n\n\n@njit('i8[:](i8[:])')\ndef P_slide(P):\n    #Rumba\n    temp = P[-1]\n    P[1:] = P[:-1]\n    P[0] = temp\n\n    return P\n\n\n@njit('i8[:](i8, b1[:], i8[:])')\ndef dance(N, D, P):\n    for Dn in D:\n        if Dn:\n            #Salsa\n            P = P_change(N, P)\n        else:\n            #Rumba\n            P = P_slide(P)\n\n    N3 = 3 ** N\n    R = np.zeros(N3, dtype=np.int64)\n    for i in range(N3):\n        R[P[i]] = i\n\n    return  R\n\n\nN = int(input())\nT = input()\n\nN3 = 3 ** N\nP = np.arange(N3, dtype=np.int64)\n#サルサの２回連続は元に戻る\nT = T.replace('SS', '')\nD = np.array([True if Ti == 'S' else False for Ti in T], dtype=np.bool)\n\nR = dance(N, D, P)\n\nprint(*R)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\nreadline = sys.stdin.readline\n\nN = int(readline())\nT = readline().strip()\n\n#Salsaの２回連続は元に戻るので削除\nT = T.replace('SS', '')\n\nD = ()\nRc = 0\nfor Ti in T:\n    if Ti == 'S':\n        if Rc:\n            #Rumba連続回数\n            D = D + (Rc,)\n            Rc = 0\n\n        #Salsa\n        D = D + (0,)\n    else:\n        #Rumba連続回数加算\n        Rc += 1\n\nif Rc:\n    #Rumba連続回数\n    D = D + (Rc,)\n    Rc = 0\n\n\nN3 = 3 ** N\nP = list(range(N3))\n\nfor Dn in D:\n    if Dn:\n        #Rumba: Dn移動\n        Dn = Dn % N3\n        if Dn: P[:Dn], P[Dn:] = P[N3 - Dn:], P[:-Dn].copy()\n\n    else:\n        #Salsa: 1と2入れ替え\n        for i in range(N):\n            start = 3 ** i\n            stop = 3 ** N\n            step = 3 ** (i + 1)\n            dp = 3 ** i\n            for j in range(start, stop, step):\n                j1 = j + dp\n                j2 = j1 + dp\n                P[j:j1], P[j1:j2] = P[j1:j2], P[j:j1].copy()\n\n#出力用データ作成\nR = [None] * N3\nfor i in range(N3): R[P[i]] = i\n    \nprint(*R)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "def Base_10_to_n(X):\n    if (int(X/3)):\n        return Base_10_to_n(int(X/3))+str(X%3)\n    return str(X%3)\ndef change(t):\n  return int(t,3)\nn=int(input())\nL =list(range(3**n))\nT=input()\nc=len(T)\nfor i in T:\n  if i==\"R\":\n    L=list(map(lambda x: (x+1)%(3**n),L))\n  elif i==\"S\":\n    K=list(map(Base_10_to_n,L))\n    A=\"/\".join(map(str,K))\n    A=A.replace(\"1\",\"#\")\n    A=A.replace(\"2\",\"1\")\n    A=A.replace(\"#\",\"2\")\n    K=A.split(\"/\")\n    L=list(map(change,K))\n    L=list(map(int,L))\nprint(\" \".join(map(str,L)))"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nT = input()\n\np = []\nfor i in range(3**N):\n  p.append(i)\n\ndef base3(value): \n  result = ''\n  tmp = int(value)\n  while tmp >= 3:\n    a = 0\n    if tmp%3 == 1:\n      a += 2\n    elif tmp%3 == 2:\n      a += 1\n    else:\n      a += tmp%3\n    result = str(a) + result\n    tmp = int(tmp//3)\n  a = 0\n  if tmp%3 == 1:\n    a += 2\n  elif tmp%3 == 2:\n    a += 1\n  else:\n    a += tmp%3\n  result = str(a) + result\n  b = 0\n  for i in range(len(result)):\n    b += int(result[i])*3**(len(result)-i-1)\n  return b\n\ndef salsa(p):\n  for i in range(len(p)):\n    p[i] = base3(p[i])\n    \n\ndef rumba(p):\n  for i in range(len(p)):\n    if p[i] == 3**N -1:\n      p[i] = 0\n    else:\n      p[i] = p[i] + 1\n      \nfor i in range(len(T)):\n  if T[i] == 'S':\n    salsa(p)\n  if T[i] == 'R':\n    rumba(p)  \n    \nans = list(map(str,p))\nAns = ' '.join(ans)\nprint(Ans)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nt = input()\nl = len(t)\n\n\ndef Base_10_to_3(x):\n    if (int(x/3)):\n        return Base_10_to_3(int(x/3)) + str(x % 3)\n    return str(x % 3)\n\n\ndef Base_3_to_10(x):\n    out = 0\n    for i in range(1, len(str(x))+1):\n        out += int(x[-i])*(3**(i-1))\n    return out\n\n\ndef convert(x):\n    l = len(x)\n    s = [''] * l\n    for i in range(l):\n        target = int(x[i])\n        if (x[i] != '0'):\n            s[i] = str(3 - target)\n        else:\n            s[i] = '0'\n    return ''.join(s)\n\n\ndef sa(x):\n    x = Base_10_to_3(x)\n    x = convert(x)\n    x = Base_3_to_10(x)\n    return x\n\n\ndef ru(x):\n    return((x + 1) % (3 ** n))\n\n\nPs = [i for i in range(3 ** n)]\n# for i in range(l):\n#     for j in range(3 ** n):\n#         if (t[i] == 'S'):\n#             Ps[j] = (sa(Ps[j]))\n#         else:\n#             Ps[j] = (ru(Ps[j]))\n\nfor j in range(3 ** n):\n    p = Ps[j]\n    for i in range(l):\n        if (t[i] == 'S'):\n            p = (sa(p))\n        else:\n            p = (ru(p))\n    Ps[j] = p"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nT = input()\nvol = 3**N\np = [i for i in range(vol)]\ndef base10to3(x):\n    if(int(x/3)):\n        return base10to3(int(x/3))+str(x%3)\n    return str(x%3)\ndef base3to10(x):\n    out = 0\n    for i in range(1,len(str(x))+1):\n        out += int(x[-i])*(3**(i-1))\n    return out\ndef sarusa(i):\n    before = base10to3(i)\n    after=before.translate(str.maketrans({'1':'2','2':'1'}))\n    return int(base3to10(after))\n\nfor i in range(len(T)):\n    _p = p\n    if T[i] == 'S':\n        p = list(map(sarusa, _p))\n    else:\n        for j in range(vol):\n            p[j] = (_p[j]+1)%vol\nprint(' '.join(map(str,p)))"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nn3=3**n\ndef main():\n  p=[i for i in range(3**n)]\n  t=input()\n  for sr in t:\n    p=list(map(lambda x: result(x,sr),p))\n  print(\" \".join(map(str,p)))\n    \ndef result(p,sr):\n  if sr==\"S\":\n    a=[\"0\",\"2\",\"1\"]\n    b=[]\n    while True:\n      s=p//3\n      y=p%3\n      b=b+[a[y]]\n      if s==0:\n        break\n      p=s\n    b.reverse()\n    return(int(\"\".join(b),3))\n  else:\n    p=(p+1) % n3\n  return p\n   \n    \n    \nmain()"
  },
  {
    "language": "Python",
    "code": "import math\nfrom collections import deque\nfrom collections import defaultdict\n\n#自作関数群\ndef readInt():\n\treturn int(input())\ndef readInts():\n\treturn list(map(int, input().split()))\ndef readChar():\n\treturn input()\ndef readChars():\n\treturn input().split()\ndef factorization(n):\n\tres = []\n\tif n%2==0:\n\t\tres.append(2)\n\tfor i in range(3,math.floor(n//2)+1,2):\n\t\tif n%i==0:\n\t\t\tc = 0\n\t\t\tfor j in res:\n\t\t\t\tif i%j==0:\n\t\t\t\t\tc=1\n\t\t\tif c==0:\n\t\t\t\tres.append(i)\n\treturn res\ndef fact2(n):\n\tp = factorization(n)\n\tres = []\n\tfor i in p:\n\t\tc=0\n\t\tz=n\n\t\twhile 1:\n\t\t\tif z%i==0:\n\t\t\t\tc+=1\n\t\t\t\tz/=i\n\t\t\telse:\n\t\t\t\tbreak\n\t\tres.append([i,c])\n\treturn res\ndef fact(n):#階乗\n\tans = 1\n\tm=n\n\tfor _i in range(n-1):\n\t\tans*=m\n\t\tm-=1\n\treturn ans\ndef comb(n,r):#コンビネーション\n\tif n<r:\n\t\treturn 0\n\tl = min(r,n-r)\n\tm=n\n\tu=1\n\tfor _i in range(l):\n\t\tu*=m\n\t\tm-=1\n\treturn u//fact(l)\ndef combmod(n,r,mod):\n\treturn (fact(n)/fact(n-r)*pow(fact(r),mod-2,mod))%mod\ndef printQueue(q):\n\tr=copyQueue(q)\n\tans=[0]*r.qsize()\n\tfor i in range(r.qsize()-1,-1,-1):\n\t\tans[i] = r.get()\n\tprint(ans)\nclass UnionFind():\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.parents = [-1]*n\n\n\tdef find(self, x): # root\n\t\tif self.parents[x]<0:\n\t\t\treturn x\n\t\telse:\n\t\t\tself.parents[x] = self.find(self.parents[x])\n\t\t\treturn self.parents[x]\n\n\tdef union(self,x,y):\n\t\tx = self.find(x)\n\t\ty = self.find(y)\n\n\t\tif x==y:\n\t\t\treturn\n\n\t\tif self.parents[x]>self.parents[y]:\n\t\t\tx,y = y,x\n\n\t\tself.parents[x]+=self.parents[y]\n\t\tself.parents[y]=x\n\n\tdef size(self,x):\n\t\treturn -1*self.parents[self.find(x)]\n\n\tdef same(self,x,y):\n\t\treturn self.find(x)==self.find(y)\n\n\tdef members(self,x): # much time\n\t\troot = self.find(x)\n\t\treturn [i for i in range(self.n) if self.find(i)==root]\n\n\tdef roots(self):\n\t\treturn [i for i,x in enumerate(self.parents) if x<0]\n\n\tdef group_count(self):\n\t\treturn len(self.roots())\n\n\tdef all_group_members(self):\n\t\treturn {r: self.members(r) for r in self.roots()} # 1~n\ndef bitArr(n):#ビット全探索\n\tx = 1\n\tzero = \"0\"*n\n\tans = []\n\tans.append([0]*n)\n\tfor i in range(2**n-1):\n\t\tans.append(list(map(lambda x:int(x),list((zero+bin(x)[2:])[-1*n:]))))\n\t\tx+=1\n\treturn ans;\ndef arrsSum(a1,a2):\n\tfor i in range(len(a1)):\n\t\ta1[i]+=a2[i]\n\treturn a1\ndef maxValue(a,b,v):\n\tv2 = v\n\tfor i in range(v2,-1,-1):\n\t\tfor j in range(v2//a+1): #j:aの個数\n\t\t\tk = i-a*j\n\t\t\tif k%b==0:\n\t\t\t\treturn i\n\treturn -1\ndef copyQueue(q):\n\tnq = queue.Queue()\n\tn = q.qsize()\n\tfor i in range(n):\n\t\tx = q.get()\n\t\tq.put(x)\n\t\tnq.put(x)\n\treturn nq\n\nn = readInt()\nt = readChar()\n\ndef base10t3(x):\n\tif x<3:\n\t\treturn str(x)\n\tans = str(x%3)\n\twhile x//3>=3:\n\t\tx = x//3\n\t\tans = str(x%3)+ans\n\tans = str(x//3)+ans\n\treturn ans\n\ndef base3t10(x):\n\tans = 0\n\ti = 0\n\tfor item in str(x)[::-1]:\n\t\tans+=int(item)*(3**i)\n\t\ti+=1\n\treturn ans\n\ndef s_pos(ans):\n\tans = base10t3(ans)\n\tans = ans.replace(\"1\",\"3\")\n\tans = ans.replace(\"2\",\"1\")\n\tans = ans.replace(\"3\",\"2\")\n\treturn base3t10(int(ans))\n\npeople = [str(i) for i in range(3**n)]\n#print(people)\n\nfor i in t:\n\tif i==\"S\":\n\t\t#print(\"S\")\n\t\tnePeople = [0]*(3**n)\n\t\tfor j in range(len(people)):\n\t\t\t#people[j] = s_pos(int(people[j]))\n\t\t\tpeople[j] = str(s_pos(int(people[j])))\n\t\t#people = nePeople[:]\n\t\t#print(people)\n\telse:\n\t\t#print(\"R\")\n\t\tfor j in range(len(people)):\n\t\t\tpeople[j] =str((int(people[j])+1)%(3**n))\n\t\t#print(people)\n\nprint(\" \".join(people))"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nhuhan=[0]*(3**n)\na=[0,2,1]\nfor i in range(3**n):\n  b=[]\n  p=i\n  h=0\n  while True:\n    s=p//3\n    y=p%3\n    b=b+[a[y]]\n    if s==0:\n      break\n    p=s\n  for j in range(len(b)-1,-1,-1):\n    h=h*3+b[j]\n  huhan[i]=h\n\nn3=3**n\ndef main():\n  p=[i for i in range(3**n)]\n  #print(p)\n  t=input()\n  for sr in t:\n    p=list(map(lambda x: result(x,sr),p))\n  print(\" \".join(map(str,p)))\n    \ndef result(p,sr):\n  if sr==\"S\":\n    return(huhan[p])\n  else:\n    p=(p+1) % n3\n  return p\n   \n    \n    \nmain()"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef ternary(n):\n    if n == 0:\n        return '0'\n    nums = []\n    while n:\n        n, r = divmod(n,3)\n        nums.append(str(r))\n    return ''.join(reversed(nums))\n\ndef swap(str):\n    swapped = ''\n    for c in str:\n        if c == '1': swapped += '2'\n        elif c == '2': swapped += '1'\n        else: swapped += c\n    return swapped\n\nif __name__ == '__main__':\n    lines = []\n    for line in sys.stdin:\n        line = line.rstrip('\\r\\n')\n        lines.append(line)\n\n    N = int(lines[0])\n    T = lines[1]\n    P = list(range(0, 3**N))\n    for t in T:\n        if t == 'R':\n            for i in range(len(P)):\n                P[i] = (P[i] + 1) % len(P)\n        elif t == 'S':\n            for i in range(len(P)):\n                P[i] = int(swap(ternary(P[i])), 3)\n\n    print(P)"
  },
  {
    "language": "Python",
    "code": "def convert(n,x):\n    if (n>=0) and (n<x):\n        return n\n    else:\n        return convert(n // x,x) * 10 + n % x\nnum=int(input())\nnum=pow(3,num)\nstrs=input()\ni=0\nresult=[]\njudge=[]\nwhile i<num:\n    judge.append(0)\n    result.append(i)\n    i += 1\nfor each in strs:\n    if each=='S':\n        i=1\n        while i<len(result):\n            m=str(convert(i,3))\n            n=''\n            judge[i]=1\n            for each in m:\n                if each=='1':\n                    n+='2'\n                elif each=='2':\n                    n+='1'\n                else:\n                    n+=each\n            to=int(n,3)\n            if judge[to]==0:\n                temp=result[to]\n                result[to]=result[i]\n                result[i]=temp\n            else:\n                judge[to]=0\n                judge[i]=0\n            i+=1\n    else:\n        i=len(result)-1\n        temp=result[len(result)-1]\n        while i>0:\n            result[i]=result[i-1]\n            i-=1\n        result[0]=temp\ni=0\nwhile i<num:\n   print(result.index(i),end=' ')\n   i+=1\n"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\nreadline = sys.stdin.readline\n\nN = int(readline())\nT = readline().strip()\n\n#サルサの２回連続は元に戻る\nT = T.replace('SS', '')\nTlen = len(T)\nD = [None] * Tlen\nRc = 0\np = 0\nfor i in range(Tlen):\n    if T[i] == 'S':\n        if Rc:\n            #Rumba\n            D[p] = Rc\n            Rc = 0\n            p += 1\n\n        #Salsa\n        D[p] = 0\n        p += 1\n    else:\n        #Rumba\n        Rc += 1\n\nif Rc:\n    #Rumba\n    D[p] = Rc\n    Rc = 0\n    p += 1\n\nD = D[:p]\nD = tuple(D)\n\nN3 = 3 ** N\nP = [0] * N3\nSd = dict()\n\nfor Pos in range(N3):\n    Pi = Pos\n    Rc = 0\n    for Dn in D:\n        if Dn:\n            #Rumba\n            Pi = (Pi + Dn) % N3\n\n        else:\n            #Salsa\n            Ps = Pi\n            if Ps in Sd:\n                Pi = Sd[Ps]\n            else:\n                Pos1 = 0\n                Pos2 = Pi\n                for Ni in range(N, 0, -1):\n                    Ni3 = 3 ** (Ni - 1)\n\n                    div = Pos2 // Ni3\n                    Pos2 = Pos2 % Ni3\n\n                    if div == 1:\n                        Pos1 += Ni3 * 2\n                    elif div == 2:\n                        Pos1 += Ni3\n\n                    if Pos2 == 0:\n                        break\n\n                Pi = Pos1 + Pos2\n\n                Sd[Ps] = Pi\n                Sd[Pi] = Ps\n\n    P[Pos] = Pi\n\n    \nprint(*P)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\n# ルンバ(隣に移動)\nN = int(input())\ndance = input()+'x'\ndance_list = []\ni = 0\npre_d = 'R'\nfor d in dance:\n  if d == pre_d:\n    i+=1\n  else:\n    dance_list.append(i)\n    i=1\n    pre_d = d\ndance_list = np.array(dance_list)\ndance_list[1::2] = np.array(list(map(lambda x:x%2, dance_list[1::2])))\n\nmem = 3**N\npos = np.arange(mem)\nreshape_tuple = tuple([3]*N)\nmem = 3**N\n\nis_r = True\ndef r(i, pos):\n  # +1\n  pos = np.roll(pos,i)\n  return pos\ndef s(i, pos):\n  if i!=0:\n    pos = pos.reshape(reshape_tuple)\n    for i in range(N):\n      pos = np.rollaxis(pos,N-1)[[0,2,1]]\n    pos = pos.flatten()\n    return pos\n  else:\n    return pos\nfor d in dance_list:\n  if is_r:\n    pos = r(d, pos)\n    is_r = False\n  else:\n    pos = s(d, pos)\n    is_r = True\nprint((' '.join(map(str,[np.where(pos==i)[0][0] for i in range(mem)]))))"
  },
  {
    "language": "Python",
    "code": "def main():\n    N = int(input())\n    T = input()\n    vol = 3**N\n    p = [i for i in range(vol)]\n    def base10to3(X):\n            if (int(X/3)):\n                return base10to3(int(X/3))+str(X%3)\n            return str(X%3)\n    def base3to10(x):\n        out = 0\n        for i in range(1,len(str(x))+1):\n            out += int(x[-i])*(3**(i-1))\n        return out\n    def sarusa(i):\n        before = base10to3(i)\n        after=before.translate(str.maketrans({'1':'2','2':'1'}))\n        return int(base3to10(after))\n\n    for i in range(len(T)):\n        if T[i] == 'S':\n            p = list(map(sarusa,p))\n        else:\n            for j in range(vol):\n                p[j] = (p[j]+1)%vol\n    print(' '.join(map(str,p)))\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "cnt = int(input())\ntxt = input()\nloop = 3 ** cnt\nnum = [x for x in range(loop)]\n\ndef func1(x):\n    if (int(x/3)):\n        return func1(int(x/3))+str(x%3)\n    return str(x%3)\n\ndef func2(s):\n    l = len(s)\n    output=0\n    for i in range(l):\n        if s[i] == '1':\n            output += 2 * (3**(l-i-1))\n        elif s[i] == '2':\n            output += (3**(l-i-1))\n    return output\n\ntrans = [func2(func1(x)) for x in range(loop)]\n\n\nfor t in txt:\n    if t == 'S':\n        for i in range(loop):\n            num[i] = trans[num[i]]\n    else:\n        for i in range(loop):\n            if num[i] == loop-1:\n                num[i] = 0\n            else:\n                num[i] += 1\n    \noutput = ''\nfor i in range(loop):\n    if i != 0:\n        output += ' '\n    output += str(num[i])\nprint(output)"
  },
  {
    "language": "Python",
    "code": "import sys\n\n# 実行環境(0:vscode, 1:atcoder)\nMODE = 1\n\n# 入力の次元\nDIMENSION = 2\n\n# int型に変換\nINT_TYPE = 0\n\nif not (MODE):\n    with open(\"input.txt\", \"r\") as f:\n        s = f.read()\nelse:\n    s = sys.stdin.read()\n\nif DIMENSION == 1:\n    if INT_TYPE == 1:\n        s = int(s)\nelif DIMENSION == 2:\n    if INT_TYPE == 0:\n        s = s.split()\n    elif INT_TYPE == 1:\n        s = [int(x) for x in s.split()]\nelif DIMENSION == 3:\n    if INT_TYPE == 0:\n        s = [x.split() for x in s.splitlines()]\n    elif INT_TYPE == 1:\n        s = [[int(y) for y in x.split()] for x in s.splitlines()]\n\n\ndef base10to(n, b):\n    if (int(n/b)):\n        return base10to(int(n/b), b) + str(n % b)\n    return str(n % b)\n\n\nN = int(s[0])\nT = s[1]\nNUM = 3 ** N\nP = list(range(NUM))\n\nfor t in T:\n    if t == \"S\":\n        for j, p in enumerate(P):\n            p_3 = [None] * N\n            p_3_mod = p\n            for i in range(N):\n                p_3[i] = p_3_mod // 3 ** (N-i-1)\n                p_3_mod = p_3_mod % 3 ** (N-i-1)\n                if p_3[i] == 1:\n                    p_3[i] = 2\n                elif p_3[i] == 2:\n                    p_3[i] = 1\n            p_new = 0\n            for i in range(N):\n                p_new += 3 ** i * p_3[N - i - 1]\n            P[j] = p_new\n    else:\n        for i in range(NUM):\n            P[i] += 1\n            if P[i] == NUM:\n                P[i] = 0\n\ntext = \"\"\nfor p in P:\n    text += str(p) + \" \"\nprint(text)\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef ternary(n):\n    if n == 0:\n        return '0'\n    nums = []\n    while n:\n        n, r = divmod(n,3)\n        nums.append(str(r))\n    return ''.join(reversed(nums))\n\ndef swap(str):\n    swapped = ''\n    for c in str:\n        if c == '1': swapped += '2'\n        elif c == '2': swapped += '1'\n        else: swapped += c\n    return swapped\n\nif __name__ == '__main__':\n    lines = []\n    for line in sys.stdin:\n        line = line.rstrip('\\r\\n')\n        lines.append(line)\n\n    N = int(lines[0])\n    T = lines[1]\n    P = list(range(0, 3**N))\n    for t in T:\n        if t == 'R':\n            for i in range(len(P)):\n                P[i] = (P[i] + 1) % len(P)\n        elif t == 'S':\n            for i in range(len(P)):\n                P[i] = int(swap(ternary(P[i])), 3)\n\n    print(*P)"
  },
  {
    "language": "Python",
    "code": "def R(x):\n    x.insert(0, x.pop(-1))\n    return x\n    \ndef S(x, n):\n    ex = [0]*n\n    for j in range(len(x)//3):\n        \n        k = j\n        tmp = 0\n        m = 1\n        while k > 0:\n            if k%3 == 1:\n                tmp = tmp + 2*(3**m)\n            elif k%3 == 2:\n                tmp = tmp + 1*(3**m)\n            k = k//3\n            m = m +1\n        ex[tmp] = x[j*3]\n        ex[tmp + 2] = x[j*3 +1]\n        ex[tmp + 1] = x[j*3 +2]\n    return(ex)\n            \n    \ndef main():\n    N = 3**int(input())\n    T = input()\n    l = list(range(N))\n    p = [0]*(N)\n    \n    for i in range(len(T)):\n        if T[i] == \"R\":\n            l = R(l)\n        elif T[i] == \"S\":\n            l = S(l, N)\n    for i in range(len(l)):\n        p[l[i]] = i\n    \n    print(p)\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\nreadline = sys.stdin.readline\n\nN = int(readline())\nT = readline().strip()\n\n#サルサの２回連続は元に戻る\nT = T.replace('SS', '')\n\n\n#ダンスの順番をtupleに入れる\nTlen = len(T)\nD = ()\nRc = 0\nfor i in range(Tlen):\n    if T[i] == 'S':\n        if Rc:\n            #Rumba連続回数\n            D = D + (Rc,)\n            Rc = 0\n\n        #Salsa\n        D = D + (0,)\n    else:\n        #Rumba連続回数加算\n        Rc += 1\n\nif Rc:\n    #Rumba連続回数\n    D = D + (Rc,)\n    Rc = 0\n\n\n#Salsaの移動データ事前作成\nN3 = 3 ** N\nSd = [None] * N3\nfor Pos in range(N3):\n    Pos1 = 0\n    Pos2 = Pos\n    for Ni in range(N, 0, -1):\n        Ni3 = 3 ** (Ni - 1)\n\n        div, Pos2 = divmod(Pos2, Ni3)\n\n        if div == 1:\n            Pos1 += Ni3 * 2\n        elif div == 2:\n            Pos1 += Ni3\n        else:\n            Pos1 += 0\n\n        if Pos2 == 0:\n            break\n\n    Pi = Pos1 + Pos2\n    Sd[Pos] = Pi\n    Sd[Pi] = Pos\n\nSd = tuple(Sd)\n\n\n#ダンス終了位置\nP = [None] * N3\nfor Pos in range(N3):\n    Pi = Pos\n    for Dn in D:\n        if Dn:\n            #Rumba\n            Pi = (Pi + Dn) % N3\n        else:\n            #Salsa\n            Pi = Sd[Pi]\n\n    P[Pos] = Pi\n\n\nprint(*P)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\nreadline = sys.stdin.readline\n\nN = int(readline())\nT = readline().strip()\n\n#Salsaの２回連続は元に戻るので削除\nT = T.replace('SS', '')\n\nTlen = len(T)\nD = ()\nRc = 0\nfor i in range(Tlen):\n    if T[i] == 'S':\n        if Rc:\n            #Rumba連続回数\n            D = D + (Rc,)\n            Rc = 0\n\n        #Salsa\n        D = D + (0,)\n    else:\n        #Rumba連続回数加算\n        Rc += 1\n\nif Rc:\n    #Rumba連続回数\n    D = D + (Rc,)\n    Rc = 0\n\n\nN3 = 3 ** N\nP = list(range(N3))\n\nfor Dn in D:\n    if Dn:\n        #Rumba: Dn移動\n        Dn = Dn % N3\n        if Dn:\n            P[:Dn], P[Dn:] = P[N3 - Dn:], P[:-Dn].copy()\n\n    else:\n        #Salsa: 1と2入れ替え\n        for i in range(N):\n            start = 3 ** i\n            stop = 3 ** N\n            step = 3 ** (i + 1)\n            dp = 3 ** i\n            for j in range(start, stop, step):\n                j1 = j + dp\n                j2 = j1 + dp\n                P[j:j1], P[j1:j2] = P[j1:j2], P[j:j1].copy()\n\n#出力用データ作成\nR = [None] * N3\nfor i in range(N3):\n    R[P[i]] = i\n    \nprint(*R)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nt=list(input())\nn=3**n\nl=[]\nfor i in range(n):\n  u=0\n  for k in range(12,0,-1):\n    p=i//3**(k-1)\n    i-=(3**(k-1))*p\n    if p==1:\n      u+=(3**(k-1))*2\n    elif p==2:\n      u+=(3**(k-1))\n  l.append(u)\ndef sarusa(a):\n  an=ans\n  return an[l[an.index(a)]]\nans=list(range(n))\nfor q in t:\n  if q=='S':\n    al=[]\n    for y in l:\n      al.append(ans[y])\n    ans=al\n  else:\n    d=[]\n    d.append(ans[n-1])\n    ans=d+ans[0:n-1]\nfor i in range(n):\n  print(ans.index(i),end=\" \")"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\nreadline = sys.stdin.readline\n\nN = int(readline())\nT = readline().strip()\n\n#サルサの２回連続は元に戻る\nT = T.replace('SS', '')\nTlen = len(T)\nD = [None] * Tlen\nRc = 0\np = 0\nfor i in range(Tlen):\n    if T[i] == 'S':\n        if Rc:\n            #Rumba\n            D[p] = Rc\n            Rc = 0\n            p += 1\n\n        #Salsa\n        D[p] = 0\n        p += 1\n    else:\n        #Rumba\n        Rc += 1\n\nif Rc:\n    #Rumba\n    D[p] = Rc\n    Rc = 0\n    p += 1\n\nD = D[:p]\nD = tuple(D)\n\nN3 = 3 ** N\nP = [0] * N3\nSd = dict()\n\nfor Pos in range(N3):\n    Pi = Pos\n    Rc = 0\n    for Dn in D:\n        if Dn:\n            #Rumba\n            Pi = (Pi + Dn) % N3\n\n        else:\n            #Salsa\n            Ps = Pi\n            if Ps in Sd:\n                Pi = Sd[Ps]\n            else:\n                Pos1 = 0\n                Pos2 = Pi\n                for Ni in range(N, 0, -1):\n                    Ni3 = 3 ** (Ni - 1)\n\n                    div, Pos2 = divmod(Pos2, Ni3)\n\n                    if div == 1:\n                        Pos1 += Ni3 * 2\n                    elif div == 2:\n                        Pos1 += Ni3\n                    else:\n                        Pos1 += 0\n\n                    if Pos2 == 0:\n                        break\n\n                Pi = Pos1 + Pos2\n\n                Sd[Ps] = Pi\n                Sd[Pi] = Ps\n\n    P[Pos] = Pi\n\n    \nprint(*P)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\ndef Base10_3(X):\n    if (int(X/3)):\n        return Base10_3(int(X/3))+str(X%3)\n    return str(X%3)\n\ndef Base3_10(X):\n    out = 0\n    for i in range(1,len(X)+1):\n        out += int(X[-i])*(3**(i-1))\n    return out\n    \ndef f(x):\n    x3 = list(str(Base10_3(x)))\n    for i in range(len(x3)):\n        if x3[i] == '1':\n            x3[i] = '2'\n        elif x3[i] == '2':\n            x3[i] = '1'\n    new_x3 = ''.join(x3)\n    return Base3_10(new_x3)\n\nN = int(input())\nN_list = np.arange(3**N)\nT = list(input())\nfor i in range(len(T)):\n    if T[i] == 'S':\n        N_list = [f(i) for i in list(N_list)]\n    else:\n        N_list = [(i+1)%(3**N) for i in list(N_list)]\n\nfor i in range(3**N):\n    print(N_list[i], end=\" \")"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nT = input()\n\np = []\nfor i in range(3**N):\n  p.append(i)\n\ndef Base3(X): #10進数を3進数に\n    if (int(X/3)):\n        return Base3(int(X/3))+str(X%3)\n    return str(X%3)\n\ndef salsa(p):\n  for i in range(len(p)):\n    p[i] = Base3(p[i])\n    p[i] = p[i].replace('1', '3')\n    p[i] = p[i].replace('2', '1')\n    p[i] = p[i].replace('3', '2')\n    p[i] = int(p[i], 3)\n\ndef rumba(p):\n  for i in range(len(p)):\n    if p[i] == 3**N -1:\n      p[i] = 0\n    else:\n      p[i] = p[i] + 1\n      \nfor i in range(len(T)):\n  if T[i] == 'S':\n    salsa(p)\n  if T[i] == 'R':\n    rumba(p)  \n    \nans = list(map(str,p))\nAns = ' '.join(ans)\nprint(Ans)"
  },
  {
    "language": "Python",
    "code": "import sys\n\n\ndef main():\n\n    # 実行環境(0:vscode, 1:atcoder)\n    MODE = 1\n\n    # 入力の次元\n    DIMENSION = 2\n\n    # int型に変換\n    INT_TYPE = 0\n\n    if not (MODE):\n        with open(\"input.txt\", \"r\") as f:\n            s = f.read()\n    else:\n        s = sys.stdin.read()\n\n    if DIMENSION == 1:\n        if INT_TYPE == 1:\n            s = int(s)\n    elif DIMENSION == 2:\n        if INT_TYPE == 0:\n            s = s.split()\n        elif INT_TYPE == 1:\n            s = [int(x) for x in s.split()]\n    elif DIMENSION == 3:\n        if INT_TYPE == 0:\n            s = [x.split() for x in s.splitlines()]\n        elif INT_TYPE == 1:\n            s = [[int(y) for y in x.split()] for x in s.splitlines()]\n\n    N = int(s[0])\n    T = s[1]\n    NUM = 3 ** N\n    P = list(range(NUM))\n\n    Q = list(range(NUM))\n    for j, q in enumerate(Q):\n        q_3 = [None] * N\n        q_3_mod = q\n        for i in range(N):\n            pow_3 = 3 ** (N-i-1)\n            q_3[i] = q_3_mod // pow_3\n            q_3_mod = q_3_mod % pow_3\n            if q_3[i] == 1:\n                q_3[i] = 2\n            elif q_3[i] == 2:\n                q_3[i] = 1\n        q_new = 0\n        for i in range(N):\n            q_new += 3 ** i * q_3[N - i - 1]\n        Q[j] = q_new\n\n    for t in T:\n        if t == \"S\":\n            for i in range(NUM):\n                P[i] = Q[P[i]]\n        else:\n            for i in range(NUM):\n                P[i] += 1\n                if P[i] == NUM:\n                    P[i] = 0\n\n    P = [str(x) for x in P]\n    print(' '.join(P))\n    # print(' '.join(P.astype(str)))\n\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\ns = input()\nm = 3 ** n\nans = [0] * m\nc = 3\nt = [[0 if q == 'S' else 1 for q in s]]\nfor i in range(n) : \n    nt = [[]] * c\n    for j in range(c) : \n        x = j\n        x = x // (3**i)\n        pre = j - x*c//3\n        nxt = []\n        for q in t[pre] : \n            if q == 0 : \n                if x != 0 : x = 3 - x\n                if len(nxt) >= 1 and nxt[-1] == 0 : nxt.pop()\n                else : nxt.append(0)\n            else :\n                x += 1\n                if x == 3 :\n                    x = 0\n                    nxt.append(1)\n        for k in range(j,m,c):\n            ans[k] += x*c//3\n        nt[j] = nxt\n    t = nt\n    c *= 3\nprint(*ans)"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\n\ndef P_change(N, P):\n    #Salsa\n    for i in range(N):\n        start = 3 ** i\n        step = 3 ** (i + 1)\n        dp = 3 ** i\n        for j in range(start, 3 ** N, step):\n            P[j:j + dp], P[j + dp:j + dp] = P[j + dp:j + dp], P[j:j + dp]\n    \n    return P\n\n\ndef P_slide(P):\n    #Rumba\n    temp = P[-1]\n    P[1:] = P[:-1]\n    P[0] = temp\n\n    return P\n\n\nN = int(input())\nT = input()\n\n#P = np.arange(3**N, dtype=np.int64)\nP = list(range(3**N))\nT = T.replace('SS', 's')\n\nfor Ti in T:\n    if Ti == 'S':\n        #Salsa\n        P = P_change(N, P)\n    elif Ti == 'R':\n        #Rumba\n        P = P_slide(P)\n\n#P = P.tolist()\nprint(' '.join([str(P.index(i)) for i in range(len(P))]))\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nt = input()\nl = len(t)\n\n\ndef Base_10_to_3(x):\n    if (int(x/3)):\n        return Base_10_to_3(int(x/3)) + str(x % 3)\n    return str(x % 3)\n\n\ndef Base_3_to_10(x):\n    out = 0\n    for i in range(1, len(str(x))+1):\n        out += int(x[-i])*(3**(i-1))\n    return out\n\n\ndef convert(x):\n    l = len(x)\n    s = [''] * l\n    for i in range(l):\n        target = int(x[i])\n        if (x[i] != '0'):\n            s[i] = str(3 - target)\n        else:\n            s[i] = '0'\n    return ''.join(s)\n\n\ndef sa(x):\n    x = Base_10_to_3(x)\n    x = convert(x)\n    x = Base_3_to_10(x)\n    return x\n\n\ndef ru(x):\n    return((x + 1) % (3 ** n))\n\n\nPs = [i for i in range(3 ** n)]\n# for i in range(l):\n#     for j in range(3 ** n):\n#         if (t[i] == 'S'):\n#             Ps[j] = (sa(Ps[j]))\n#         else:\n#             Ps[j] = (ru(Ps[j]))\n\nfor i in range(3 ** n):\n    p = Ps[i]\n    for j in range(l):\n        if (t[i] == 'S'):\n            p = (sa(p))\n        else:\n            p = (ru(p))\n    Ps[i] = p\n\nprint(' '.join(map(str, Ps)))"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nT = str(input())\nimport numpy as np\na = np.array([i for i in range(3**N)])\nb = [0 for i in range(3**N)]\nfor i in range(N):\n    n = [3**i for _ in range(3**N)]\n    m = ([0]*int(3**i) + [2]*int(3**i) + [1]*int(3**i))*int(3**(N-(i+1)))\n    b = [o + p*q for o,p,q in zip(b,n,m)]\nb = np.array(b)\nfor t in T:\n  if t == 'S':\n    a = b[a]\n  else:\n    a += 1\n    a = a%(3**N)\nans = ''\nfor ai in a:\n  ans += str(ai) + ' '\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef salsa(X):\n    if X%3 == 1:\n        a = 2\n    elif X%3 == 2:\n        a = 1\n    else:\n        a = 0\n    if (int(X/3)):\n        return salsa(int(X/3))+str(a)\n    return str(a)\n\ndef Base_3_to_10(X):\n    out = 0\n    for i in range(1,len(str(X))+1):\n        out += int(X[-i])*(3**(i-1))\n    return out\n\nn = int(input())\nt = input()\np = deque()\nfor i in range(3 ** n):\n    p.append(i)\n\nfor ti in t:\n    if ti == 'S':\n        for i in range(3 ** n):\n            p[i] = Base_3_to_10(salsa(p[i]))\n    else:\n        for i in range(3 ** n):\n            p[i] = (p[i] + 1) % (3 ** n) \nprint(*p, sep=' ')"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nt = input()\nl = len(t)\n\n\ndef Base_10_to_3(x):\n    if (int(x/3)):\n        return Base_10_to_3(int(x/3)) + str(x % 3)\n    return str(x % 3)\n\n\ndef Base_3_to_10(x):\n    out = 0\n    for i in range(1, len(str(x))+1):\n        out += int(x[-i])*(3**(i-1))\n    return out\n\n\ndef convert(x):\n    l = len(x)\n    s = [''] * l\n    for i in range(l):\n        target = int(x[i])\n        if (x[i] != '0'):\n            s[i] = str(3 - target)\n        else:\n            s[i] = '0'\n    return ''.join(s)\n\n\ndef sa(x):\n    x = Base_10_to_3(x)\n    x = convert(x)\n    x = Base_3_to_10(x)\n    return x\n\n\ndef ru(x):\n    return((x + 1) % (3 ** n))\n\n\nPs = [i for i in range(3 ** n)]\n# for i in range(l):\n#     for j in range(3 ** n):\n#         if (t[i] == 'S'):\n#             Ps[j] = (sa(Ps[j]))\n#         else:\n#             Ps[j] = (ru(Ps[j]))\n\nfor j in range(3 ** n):\n    p = Ps[j]\n    for i in range(l):\n        if (t[i] == 'S'):\n            p = (sa(p))\n        else:\n            p = (ru(p))\n    Ps[j] = p\n\nprint(' '.join(map(str, Ps)))\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\n\nn = int(input())\nt = input()\nl = len(t)\n\ndef Base_10_to_3(x):\n    if (int(x/3)):\n        return Base_10_to_3(int(x/3)) + str(x % 3)\n    return str(x % 3)\n\ndef Base_3_to_10(x):\n    out = 0\n    for i in range(1, len(str(x))+1):\n        out += int(x[-i])*(3**(i-1))\n    return out\n\ndef convert(x):\n    l = len(x)\n    s = [''] * l\n    for i in range(l):\n        target = int(x[i])\n        if (x[i] != '0'):\n            s[i] = str(3 - target)\n        else:\n            s[i] = '0'\n    return ''.join(s)\n\nd3 = [0] * (3 ** n)\nd10 = defaultdict(int)\nfor i in range(3 ** n):\n    d3[i] = Base_10_to_3(i)\nfor i in range(3 ** n):\n    d = d3[i]\n    d10[d] = Base_3_to_10(d)\n\ndef sa(x):\n    # x = Base_10_to_3(x)\n    # x = convert(x)\n    # x = Base_3_to_10(x)\n    x = d3[x]\n    x = convert(x)\n    x = d10[x]\n    return x\n\ndef ru(x):\n    return((x + 1) % (3 ** n))\n\nPs = [i for i in range(3 ** n)]\n\nfor j in range(3 ** n):\n    p = Ps[j]\n    for i in range(l):\n        if (t[i] == 'S'):\n            p = (sa(p))\n        else:\n            p = (ru(p))\n    Ps[j] = p\n\nprint(' '.join(map(str, Ps)))\n"
  },
  {
    "language": "Python",
    "code": "def R(x):\n    x.insert(0, x.pop(-1))\n    return x\n    \ndef S(x, n):\n    ex = [\"\"]*n\n    for j in range(len(x)//3):\n        \n        k = j\n        tmp = 0\n        m = 3\n        q = j*3\n        while k > 0:\n            if k%3 == 1:\n                tmp = tmp + 2*m\n            elif k%3 == 2:\n                tmp = tmp + 1*m\n            k = k//3\n            m = m*3\n        ex[tmp] = x[q]\n        ex[tmp + 2] = x[q +1]\n        ex[tmp + 1] = x[q +2]\n    return(ex)\n            \n    \ndef main():\n    from builtins import input, int\n    N = 3**int(input())\n    listN = list(range(N))\n    T = input()\n    l = list(listN)\n    p = [\"\"]*(N)\n    \n    for i in range(len(T)):\n        if T[i] == \"R\":\n            l = R(l)\n        else:\n            l = S(l, N)\n    for i in listN:\n        p[l[i]] = i\n    \n    for i in listN:\n        print(p[i], end=\" \")\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "def R(List):\n  Num = len(List)//3\n  if Num == 1:\n    return [List[0],List[2],List[1]]\n  else:\n    L = R(List[:Num]) + R(List[2*Num:]) + R(List[Num:2*Num])\n    return L\ndef S(List):\n    L = [List[len(List)-1]] + List[:len(List)-1]\n    return L\nN = int(input())\nT = list(input())\nP = list(range(3**N))\nfor s in T:\n  if s == 'R':\n    P = S(P)\n  else:\n    P = R(P)\nAns = [0 for i in range(3**N)]\nfor x,i in zip(P,range(3**N)):\n    Ans[x] = i\nprint(*Ans)"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nT = input()\n\np = []\nfor i in range(3**N):\n  p.append(i)\n\ndef base3(value): \n  result = ''\n  tmp = int(value)\n  while tmp >= 3:\n    a = 0\n    if tmp%3 == 1:\n      a += 2\n    elif tmp%3 == 2:\n      a += 1\n    else:\n      a += tmp%3\n    result = str(a) + result\n    tmp = int(tmp//3)\n  a = 0\n  if tmp%3 == 1:\n    a += 2\n  elif tmp%3 == 2:\n    a += 1\n  else:\n    a += tmp%3\n  result = str(a) + result\n  b = 0\n  for i in range(len(result)):\n    b += int(result[i])*3**(len(result)-i-1)\n  return b\n\ndef salsa(p):\n  for i in range(len(p)):\n    p[i] = base3(p[i])\n    \n\ndef rumba(p):\n  for i in range(len(p)):\n    if p[i] == 3**N -1:\n      p[i] = 0\n    else:\n      p[i] = p[i] + 1\n      \nfor i in range(len(T)):\n  if T[i] == 'S':\n    salsa(p)\n  if T[i] == 'R':\n    rumba(p)  \n    \nans = list(map(str,p))\nAns = ' '.join(ans)\nprint(Ans)"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\n\ndef P_change(N, P):\n    #Salsa\n    for i in range(N):\n        start = 3 ** i\n        stop = 3 ** N\n        step = 3 ** (i + 1)\n        dp = 3 ** i\n        for j in range(start, stop, step):\n            j1 = j + dp\n            j2 = j1 + dp\n            P[j:j1], P[j1:j2] = P[j1:j2], P[j:j1].copy()\n\n    return P\n\n\ndef P_slide(P):\n    #Rumba\n    temp = P[-1]\n    P[1:] = P[:-1]\n    P[0] = temp\n\n    return P\n\n\ndef dance(N, T):\n    #サルサの２回連続は元に戻る\n    T = T.replace('SS', '')\n    D = [True if Ti == 'S' else False for Ti in T]\n\n    N3 = 3 ** N\n    P = list(range(N3))\n\n    for Dn in D:\n        if Dn:\n            #Salsa\n            P = P_change(N, P)\n        else:\n            #Rumba\n            P = P_slide(P)\n\n    R = [0] * N3\n    for i in range(N3):\n        R[P[i]] = i\n\n    return  R\n    \n\nN = int(input())\nT = input()\n\nR = dance(N, T)\n\nprint(*R)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "import string\ndef ternary (n):\n    if n == 0:\n        return '0'\n    nums = []\n    while n:\n        n, r = divmod(n, 3)\n        nums.append(str(r))\n    return ''.join(nums)\ndef to_dec(strs):\n    num = 0\n    for i in range(len(strs)):\n        num += 3**(i)*int(strs[i])\n    return num\n\ndef solve(N, T):\n    dic = {}\n    total = 3**N\n    for i in range(3**N):\n        if i in dic:\n            continue\n        te = ternary(i)\n        new_te = te.replace('1', '%temp%').replace('2', '1').replace('%temp%', '2') \n        new_i = to_dec(new_te)\n        if new_i != i:\n            dic[i] = new_i\n            dic[new_i] = i\n    person_2_seat = {i:i for i in range(total)}\n    seat_2_person = {i:i for i in range(total)}\n    ans = []\n    stack = []\n    for i in range(len(T)):\n        if stack and T[i] == stack[-1][0]:\n            stack[-1][1]+=1\n        else:\n            stack.append([T[i], 1])\n\n    for i in range(len(stack)):\n        if stack[i][0] =='R':\n            count = stack[i][1]\n            new_person_2_seat, new_seat_2_person = {}, {}\n            for k, v in seat_2_person.items():\n                new_seat = (k+count) % total\n                new_person_2_seat[v] = new_seat\n                new_seat_2_person[new_seat] = v\n            person_2_seat, seat_2_person =new_person_2_seat, new_seat_2_person\n        else:\n            if stack[i][1] %2:\n                seen = set()\n                c = 0\n                for k in dic:\n                    if k in seen: continue\n                    first, second = k, dic[k]\n                    p1, p2 = seat_2_person[first], seat_2_person[second]\n                    person_2_seat[p1], person_2_seat[p2] = second, first\n                    seat_2_person[first], seat_2_person[second] = p2, p1\n                    seen.add(second)\n                    c+=1 \n                    if c>= len(dic)//2:\n                        break\n    ans = []\n    for i in range(total):\n        ans.append(str(person_2_seat[i]))\n    return ' '.join(ans)\n\n\nN = int(input())\nT = input()\nprint(solve(N, T))"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nT = input()\nT = list(T)\n\nL = list(range(3**N))\nL2 = list(range(3**N))\ntL = 0\n\ndef base10to(n, b):\n  if (int(n/b)):\n    return base10to(int(n/b), b) + str(n%b)\n  return str(n%b)\n\n\nfor i in range(len(T)):\n  if(T[i] == \"R\"):\n    for i in range(len(L)):\n      if(L[i]==len(L)-1):\n        L2[i] = 0\n      else:\n        L2[i] = L[i]+1\n    L = L2\n  else:\n    for i in range(len(L)):\n      th = base10to(L[i], 3)\n      tha = list(th)\n      th_replace = [\"2\" if i == \"1\" else \"1\" if i == \"2\" else i for i in tha]\n      th_replace = ''.join(th_replace)\n      L2[i] = int(th_replace,3)\n\n    L = L2\nL = [str(i) for i in L]\nL = ' '.join(L)\nprint(L)"
  },
  {
    "language": "Python",
    "code": "def readInt():\n\treturn int(input())\ndef readInts():\n\treturn list(map(int, input().split()))\ndef readChar():\n\treturn input()\ndef readChars():\n\treturn input().split()\n\nn = readInt()\nt = readChar()\n\ndef base10t3(x):\n\tif x<3:\n\t\treturn str(x)\n\tans = str(x%3)\n\twhile x//3>=3:\n\t\tx = x//3\n\t\tans = str(x%3)+ans\n\tans = str(x//3)+ans\n\treturn ans\n\ndef base3t10(x):\n\tans = 0\n\ti = 0\n\tfor item in str(x)[::-1]:\n\t\tans+=int(item)*(3**i)\n\t\ti+=1\n\treturn ans\n\ndef s_pos(ans):\n\tans = base10t3(ans)\n\tans = ans.replace(\"1\",\"3\").replace(\"2\",\"1\").replace(\"3\",\"2\")\n\treturn base3t10(int(ans))\n\npeople = [str(i) for i in range(3**n)]\n#print(people)\n\nfor i in t:\n\tif i==\"S\":\n\t\tfor j in range(len(people)):\n\t\t\tpeople[j] = str(s_pos(int(people[j])))\n\telse:\n\t\tfor j in range(len(people)):\n\t\t\tpeople[j] =str((int(people[j])+1)%(3**n))\n\t#print(people)\n\nprint(\" \".join(people))"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\nreadline = sys.stdin.readline\n\nN = int(readline())\nT = readline().strip()\n\n#Salsaの２回連続は元に戻るので削除\nT = T.replace('SS', '')\n\nD = ()\nRc = 0\nfor Ti in T:\n    if Ti == 'S':\n        if Rc:\n            #Rumba連続回数\n            D = D + (Rc,)\n            Rc = 0\n\n        #Salsa\n        D = D + (0,)\n    else:\n        #Rumba連続回数加算\n        Rc += 1\n\nif Rc:\n    #Rumba連続回数\n    D = D + (Rc,)\n    Rc = 0\n\n\nN3 = 3 ** N\nP = list(range(N3))\n\nfor Dn in D:\n    if Dn:\n        #Rumba: Dn移動\n        Dn = Dn % N3\n        if Dn: P[:Dn], P[Dn:] = P[N3 - Dn:], P[:-Dn].copy()\n\n    else:\n        #Salsa: 1と2入れ替え\n        for i in range(N):\n            start = 3 ** i\n            stop = 3 ** N\n            step = 3 ** (i + 1)\n            dp = 3 ** i\n            for j in range(start, stop, step):\n                j1 = j + dp\n                j2 = j1 + dp\n                P[j:j1], P[j1:j2] = P[j1:j2], P[j:j1].copy()\n\n#出力用データ作成\nR = [None] * N3\nfor i in range(N3): R[P[i]] = i\n    \nprint(*R)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\n\nN = int(readline())\nP3 = [pow(3, i) for i in range(N+1)]\n\nSt = [1 if s == 'R' else 0 for s in readline().strip()]\nLS = len(St)\nans = [None]*P3[N]\narr = [None]*P3[N]\nans[0] = 0\narr[0] = St[:]\nREV = (0, 2, 1)\nfor l in range(N):\n    p3l = P3[l]\n    for i in range(p3l):\n        k0, k1, k2 = 0, 1, 2\n        r0, r1, r2 = [], [], []\n        for s in arr[i]:\n            if s:\n                k0 += 1\n                k1 += 1\n                k2 += 1\n                if k0 == 3:\n                    k0 = 0\n                    r0.append(1)\n                if k1 == 3:\n                    k1 = 0\n                    r1.append(1)\n                if k2 == 3:\n                    k2 = 0\n                    r2.append(1)\n            else:\n                k0 = REV[k0]\n                k1 = REV[k1]\n                k2 = REV[k2]\n                if r0 and r0[-1] == 0:\n                    r0.pop()\n                else:\n                    r0.append(0)\n                if r1 and r1[-1] == 0:\n                    r1.pop()\n                else:\n                    r1.append(0)\n                if r2 and r2[-1] == 0:\n                    r2.pop()\n                else:\n                    r2.append(0)\n        arr[2*p3l+i] = r2[:]\n        arr[p3l+i] = r1[:]\n        arr[i] = r0[:]\n        a = ans[i]\n        ans[2*p3l+i] = k2*p3l+a\n        ans[p3l+i] = k1*p3l+a\n        ans[i] = k0*p3l+a\n                \nprint(*ans)"
  },
  {
    "language": "Python",
    "code": "import copy\n\nN = int(input())\nT = input()\nPlace = []\nnumber = 3**N\nans = [0]*number\nk = 0\n\ndef to_3(X):\n    if (int(X/3)):\n        return to_3(int(X/3))+str(X%3)\n    return str(X%3)\ndef to_10(X):\n    out = 0\n    for i in range(1,len(X)+1):\n        out += int(X[-i])*(3**(i-1))\n    return out#int out\n\nfor b in range(number):\n    Place.append(b)\n\nfor a in range(len(T)):\n    if T[a] == 'S':\n        PrePlace = copy.copy(Place)\n        for i in range(number):\n            jstr = to_3(i)\n            jstr = jstr.translate(str.maketrans({'1': '2', '2': '1'}))\n            j = int(to_10(jstr))\n            Place[j] = PrePlace[i]\n\n    else:\n        end = Place.pop(-1)\n        Place.insert(0, end)\n\nfor item in Place:\n    ans[item] = k\n    k += 1\n\nprint(' '.join(map(str, ans)))"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef R(x):\n    x.insert(0, x.pop(-1))\n    return x\n    \ndef S(x, n):\n    ex = [0]*n\n    for j in range(len(x)//3):\n        \n        k = j\n        tmp = 0\n        m = 3\n        q = j*3\n        while k > 0:\n            if k%3 == 1:\n                tmp = tmp + 2*m\n            elif k%3 == 2:\n                tmp = tmp + 1*m\n            k = k//3\n            m = m*3\n        ex[tmp] = x[q]\n        ex[tmp + 2] = x[q +1]\n        ex[tmp + 1] = x[q +2]\n    return(ex)\n            \n    \ndef main():\n    N = 3**int(sys.stdin.readline())\n    T = sys.stdin.readline()\n    l = list(range(N))\n    p = [0]*(N)\n    \n    for i in range(len(T)):\n        if T[i] == \"R\":\n            l = R(l)\n        else:\n            l = S(l, N)\n    for i in range(N):\n        p[l[i]] = i\n    \n    for i in range(N):\n        print(p[i], end=\" \")\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "def base10to3(n):\n  if (int(n/3)):\n    return base10to3(int(n/3)) + str(n%3)\n  return str(n%3)\n\ndef S(r,n):\n  for i in range(len(r)):\n    m=list(base10to3(r[i]))\n    for j in range(len(m)):\n      k=int(m[j])\n      if k%3==1:\n        m[j]=str(k+1)\n      elif k%3==2:\n        m[j]=str(k-1)\n    r[i]=int(''.join(m),3)\n  return r\n\ndef R(r,n):\n  for i in range(len(r)):\n    if r[i] ==3**n-1:\n      r[i]=0\n    else:\n      r[i] +=1\n  return r\n    \nn=int(input())\nm=input()\nr=[i for i in range(3**n)]\nfor i in range(len(m)):\n  t=m[i]\n  if t=='S':\n    r=S(r,n)\n  else:\n    r=R(r,n)\nr=map(str,r)\nprint(' '.join(r))"
  },
  {
    "language": "Python",
    "code": "def base10to(n, b):\n    if (int(n/b)):\n        return base10to(int(n/b), b) + str(n % b)\n    return str(n % b)\n\n\ndef base10from(s, b):\n    return int(s, b)\n\nN = int(input())\nT = input()\norder = {}\nfor i in range(3 ** N):\n    order[i] = base10from(base10to(i, 3).replace(\n        \"2\", \"tmp\").replace(\"1\", \"2\").replace(\"tmp\", \"1\"), 3)\nans = []\nfor i in range(3 ** N):\n    p = i\n    for t in T:\n        if t == \"S\":\n            p = order[p]\n        else:\n            p += 1\n            if p == (3 ** N):\n                p = 0\n    ans.append(str(p))\nprint(\" \".join(ans))\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nT = input()\nvol = 3**N\np = [i for i in range(vol)]\ndef base10to3(x):\n    if(int(x/3)):\n        return base10to3(int(x/3))+str(x%3)\n    return str(x%3)\ndef base3to10(x):\n    out = 0\n    for i in range(1,len(str(x))+1):\n        out += int(x[-i])*(3**(i-1))\n    return out\ndef sarusa(i):\n    before = base10to3(i)\n    after=before.translate(str.maketrans({'1':'2','2':'1'}))\n    return int(base3to10(after))\n\nfor i in range(len(T)):\n    if T[i] == 'S':\n        p = list(map(sarusa,p))\n    else:\n        for j in range(vol):\n            p[j] = (p[j]+1)%vol\nprint(' '.join(map(str,p)))"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\nreadline = sys.stdin.readline\n\nN = int(readline())\nT = readline().strip()\n\n#Salsaの２回連続は元に戻る\nT = T.replace('SS', '')\n\n#Rumbaを連続回数にしてダンスの順番をtupleに入れる\n# 0: Salsa, 0以上: Rumbaの連続回数\nD = ()\nRc = 0\nfor Ti in T:\n    if Ti == 'S':\n        if Rc:\n            #Rumba\n            D += (Rc,)\n            Rc = 0\n \n        #Salsa\n        D += (0,)\n    else:\n        #Rumba\n        Rc += 1\n \nif Rc:\n    #Rumba\n    D += (Rc,)\n    Rc = 0\n\nN3 = 3 ** N\nP = [0] * N3\nSd = dict()\n\nfor Pos in range(N3):\n    Pi = Pos\n    Rc = 0\n    for Dn in D:\n        if Dn:\n            #Rumba\n            Pi = (Pi + Dn) % N3\n\n        else:\n            #Salsa\n            if Pi in Sd:\n                Pi = Sd[Pi]\n            else:\n                Ps = Pi\n                Pos1 = 0\n                Pos2 = Pi\n                for Ni in range(N, 0, -1):\n                    Ni3 = 3 ** (Ni - 1)\n\n                    div = Pos2 // Ni3\n                    Pos2 = Pos2 % Ni3\n\n                    if div == 1:\n                        Pos1 += Ni3 * 2\n                    elif div == 2:\n                        Pos1 += Ni3\n\n                    if Pos2 == 0:\n                        break\n\n                Pi = Pos1 + Pos2\n\n                Sd[Ps] = Pi\n                Sd[Pi] = Ps\n\n    P[Pos] = Pi\n\n    \nprint(*P)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\ndef main():\n  n=int(input())\n  huhan=np.empty(3**n, np.int32)\n  a=[0,2,1]\n  for i in range(3**n):\n    b=[]\n    h=0\n    while True:\n      s=i//3\n      y=i%3\n      b=b+[a[y]]\n      if s==0:\n        break\n      i=s\n    for j in range(len(b)-1,-1,-1):\n      h=h*3+b[j]\n    huhan[i]=h\n  n3=3**n\n  p= np.arange(3**n)\n  t=input()\n  t=t.replace(\"SS\",\"\")\n  snum=False\n  for sr in t:\n    if sr==\"R\":\n      p += 1\n      p %= n3\n    else:\n      for x in p:\n        x=huhan[x]\n  print(\" \".join(map(str,p)))\nmain()"
  },
  {
    "language": "Python",
    "code": "def base10to(n, b):\n    if (int(n / b)):\n        return base10to(int(n / b), b) + str(n % b)\n    return str(n % b)\n\n\ndef getExchengeStep(a):\n    a_3 = list(base10to(a, 3))\n\n    for i in range(len(a_3)):\n        if (a_3[i] == '1'):\n            a_3[i] = '2'\n        elif (a_3[i] == '2'):\n            a_3[i] = '1'\n\n    return int(''.join(a_3), 3)\n\n\ndef S(P, lenN):\n    flag = [False] * lenN\n    for i in range(lenN):\n        if (flag[i] == False):\n            to = getExchengeStep(i)\n            flag[to] = True\n            P[i], P[to] = P[to], P[i]\n\n    return P\n\n\ndef R(P):\n    temp = P[-1]\n    P[1:] = P[:-1]\n    P[0] = temp\n    return P\n\n\nN = int(input())\nT = input()\n\nlenN = 3**N\nP = list(range(lenN))\n\n\nfor t in T:\n    if (t == 'R'):\n        P = R(P)\n    if (t == 'S'):\n        P = S(P, lenN)\n\n\nprint(' '.join([str(P.index(i)) for i in range(lenN)]))\n"
  },
  {
    "language": "Python",
    "code": "import string\ndef ternary (n):\n    if n == 0:\n        return '0'\n    nums = []\n    while n:\n        n, r = divmod(n, 3)\n        nums.append(str(r))\n    return ''.join(nums)\ndef to_dec(strs):\n    num = 0\n    for i in range(len(strs)):\n        num += 3**(i)*int(strs[i])\n    return num\n\ndef solve(N, T):\n    dic = {}\n    total = 3**N\n    for i in range(3**N):\n        if i in dic:\n            continue\n        te = ternary(i)\n        new_te = te.replace('1', '%temp%').replace('2', '1').replace('%temp%', '2') \n        new_i = to_dec(new_te)\n        if new_i != i:\n            dic[i] = new_i\n            dic[new_i] = i\n    person_2_seat = {i:i for i in range(total)}\n    seat_2_person = {i:i for i in range(total)}\n    ans = []\n    for c in T:\n        if c =='S':\n            seen = set()\n            for k in dic:\n                if k in seen: continue\n                first, second = k, dic[k]\n                p1, p2 = seat_2_person[first], seat_2_person[second]\n                person_2_seat[p1], person_2_seat[p2] = second, first\n                seat_2_person[first], seat_2_person[second] = p2, p1\n                seen.add(second)\n        else:\n            new_person_2_seat, new_seat_2_person = {}, {}\n            for k, v in seat_2_person.items():\n                new_seat = (k+1) % total\n                new_person_2_seat[v] = new_seat\n                new_seat_2_person[new_seat] = v\n            person_2_seat, seat_2_person =new_person_2_seat, new_seat_2_person\n    ans = []\n    for i in range(total):\n        ans.append(str(person_2_seat[i]))\n    return ' '.join(ans)\n\n\nN = int(input())\nT = input()\nprint(solve(N, T))"
  },
  {
    "language": "Python",
    "code": "import copy\n\nN = int(input())\nT = input()\nPlace = []\nnumber = 3**N\nans = [0]*number\nk = 0\n\ndef to_3(X):\n    if (int(X/3)):\n        return to_3(int(X/3))+str(X%3)\n    return str(X%3)\ndef to_10(X):\n    out = 0\n    for i in range(1,len(X)+1):\n        out += int(X[-i])*(3**(i-1))\n    return out#int out\n\nfor b in range(number):\n    Place.append(b)\n\nfor a in range(len(T)):\n    if T[a] == 'S':\n        PrePlace = copy.copy(Place)\n        for i in range(number):\n            jstr = to_3(i)\n            jstr = jstr.translate(str.maketrans('12', '21'))\n            j = int(to_10(jstr))\n            Place[j] = PrePlace[i]\n\n    else:\n        end = Place.pop(-1)\n        Place.insert(0, end)\n\nfor item in Place:\n    ans[item] = k\n    k += 1\n\nprint(' '.join(map(str, ans)))"
  },
  {
    "language": "Python",
    "code": "def R(x):\n    x.insert(0, x.pop(-1))\n    return x\n    \ndef S(x, n, m):\n    ex = [\"\"]*n\n    for j in range(m):\n        \n        k = j\n        tmp = 0\n        m = 3\n        q = j*3\n        while k > 0:\n            if k%3 == 1:\n                tmp = tmp + 2*m\n            elif k%3 == 2:\n                tmp = tmp + 1*m\n            k = k//3\n            m = m*3\n        ex[tmp] = x[q]\n        ex[tmp + 2] = x[q +1]\n        ex[tmp + 1] = x[q +2]\n    return(ex)\n            \n    \ndef main():\n    N = 3**int(input())\n    M = N//3\n    listN = list(range(N))\n    T = input()\n    l = list(listN)\n    p = [\"\"]*(N)\n    \n    for i in range(len(T)):\n        if T[i] == \"R\":\n            l = R(l)\n        else:\n            l = S(l, N, M)\n    for i in listN:\n        p[l[i]] = str(i)\n    \n    print(' '.join(p))\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\n\ndef P_change(N, P):\n    #Salsa\n    for i in range(N):\n        start = 3 ** i\n        stop = 3 ** N\n        step = 3 ** (i + 1)\n        dp = 3 ** i\n        for j in range(start, stop, step):\n            P[j:j + dp], P[j + dp:j + dp * 2] = P[j + dp:j + dp * 2], P[j:j + dp]\n\n    return P\n\n\ndef P_slide(P):\n    #Rumba\n    temp = P[-1]\n    P[1:] = P[:-1]\n    P[0] = temp\n\n    return P\n\n\ndef dance(N, D):\n    N3 = 3 ** N\n    P = list(range(N3))\n\n    for Dn in D:\n        if Dn:\n            #Salsa\n            P = P_change(N, P)\n        else:\n            #Rumba\n            P = P_slide(P)\n\n    R = [0] * N3\n    for i in range(N3):\n        R[P[i]] = i\n\n    return  R\n    \n\nN = int(input())\nT = input()\n\n#サルサの２回連続は元に戻る\nT = T.replace('SS', '')\nD = [1 if Ti == 'S' else 0 for Ti in T]\n\nR = dance(N, D)\n\nprint(*R)\n"
  },
  {
    "language": "Python",
    "code": "# salsa=0, rumba=1\n# [0 1 0 1] 1より上の位に帯する操作\n\n# 繰り上がりを考慮しつつ、3（より上）の位に対する操作を考える\n# [1]       1の位が0である数字の、3の位に対する操作\n# [0 1 0]   1の位が1である数字の、3の位に対する操作\n# []        1の位が2である数字の、3の位に対する操作\n# ある数字が\"2\"の時にルンバが来れば繰り上がる（上の位にルンバが波及）\n# それ以外の状態では、上の位にとってルンバは無いのと同じことになる\n# サルサは常に影響するが、連続した2つのサルサは打ち消し合い、無いのと同じことになる\n\n# 再帰的に上の位を決める\n# []        3,1の位が00,10である数字の、9の位に対する操作\n# [1]       3,1の位が20である数字の、9の位に対する操作\n# []        3,1の位が01,21である数字の、9の位に対する操作\n# [0 1 0]   3,1の位が11である数字の、9の位に対する操作\n# []        3,1の位が02,12,22である数字の、9の位に対する操作\n\n# 一度繰り上がったら、例えば100.. と0がd個続くとして、\n# 更にその上の位に波及させるには 2^d オーダーの操作が必要となるので、各操作列は徐々に減っていく\n\nn = int(input())\nt = input()\nop = [[int(c == 'R') for c in t]]\nans = [0]\n\nfor d in range(n):\n    k = 3 ** d\n    nop = []\n    nans = [0] * (k * 3)\n    for g in range(3):  # d桁目の数\n        for i in range(k):  # d桁目未満の数\n            opg = op[i]\n            opn = []\n            h = g\n            for o in opg:\n                if o == 0:\n                    if len(opn) > 0 and opn[-1] == 0:\n                        opn.pop()\n                    else:\n                        opn.append(0)\n                    if h == 1:\n                        h = 2\n                    elif h == 2:\n                        h = 1\n                else:\n                    if h == 2:\n                        h = 0\n                        opn.append(1)\n                    else:\n                        h += 1\n            nop.append(opn)\n            nans[g * k + i] = h * k + ans[i]\n\n    op = nop\n    ans = nans\n\nprint(*ans)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nt = input()      \nl1 = []\nl2 = []\nfor i in range(3**n):\n    l1.append(i)\n    l2.append(i)\nd = {k: v for k, v in zip(l2, l1)}\nprint(d)\n\nfor i in t:\n    if i == \"s\":\n         for j in d:\n            a = Base10n(j,3)\n            for i in range(len(a)):\n                if a[i] == 1:\n                    a[i]=2\n                if a[i]==2:\n                    a[i] = 1\n            new = Base_n_to_10(a,3)\n            d[j]=d[new]\n    print(d)\n    if i == \"r\":\n        for j in d:\n            if j != 0:\n                d[j] = d[j-1]\n        d[0] = d[3**n-1]\n         \nprint(d)"
  },
  {
    "language": "Python",
    "code": "def R(x):\n    x.insert(0, x.pop(-1))\n    return x\n    \ndef S(x, n):\n    ex = [0]*n\n    for j in range(len(x)//3):\n        \n        k = j\n        tmp = 0\n        m = 3\n        q = j*3\n        while k > 0:\n            if k%3 == 1:\n                tmp = tmp + 2*m\n            elif k%3 == 2:\n                tmp = tmp + 1*m\n            k = k//3\n            m = m*3\n        ex[tmp] = x[q]\n        ex[tmp + 2] = x[q +1]\n        ex[tmp + 1] = x[q +2]\n    return(ex)\n            \n    \ndef main():\n    N = 3**int(input())\n    T = input()\n    l = list(range(N))\n    p = [0]*(N)\n    \n    for i in range(len(T)):\n        if T[i] == \"R\":\n            l = R(l)\n        else:\n            l = S(l, N)\n    for i in range(N):\n        p[l[i]] = i\n    \n    for i in range(N):\n        print(p[i], end=\" \")\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\n\ndef P_change(N, Pos):\n    #Salsa\n    Pos1 = 0\n    for Ni in range(N, 0, -1):\n        Ni3 = 3 ** (Ni - 1)\n\n        div, Pos = divmod(Pos, Ni3)\n\n        if div == 1:\n            Pos1 += Ni3 * 2\n        elif div == 2:\n            Pos1 += Ni3\n        else:\n            Pos1 += 0\n\n        if Pos == 0:\n            break\n\n    return Pos1 + Pos\n\n\ndef P_slide(N3, Pos):\n    #Rumba\n    Pos1 = Pos + 1\n    if Pos1 == N3:\n        Pos1 = 0\n\n    return Pos1\n\n\ndef dance(N, T):\n    #サルサの２回連続は元に戻る\n    T = T.replace('SS', '')\n    D = [True if Ti == 'S' else False for Ti in T]\n\n    N3 = 3 ** N\n    P = [0] * N3\n\n    for Pos in range(N3):\n        Pi = Pos\n        for Dn in D:\n            if Dn:\n                #Salsa\n                Pi = P_change(N, Pi)\n            else:\n                #Rumba\n                Pi = P_slide(N3, Pi)\n        P[Pos] = Pi\n\n    return  P\n    \n\nN = int(input())\nT = input()\n\nP = dance(N, T)\n\nprint(*P)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "N=int(input())\nT=input()\nt=[3**i for i in range(N+2)]\nL=pow(2,N-1,t[N])\ndef f(x):\n  r=0\n  for i in range(N):\n    if x%3:\n      r+=(3-x%3)*t[i]\n    x//=3\n  return r\n\ndef g(z,p):\n  Y=t[z]\n  X=[t[N-z]+p,L*t[N-z]+p]\n  X[0]%=t[N]\n  X[1]%=t[N]\n  for i in range(len(T)):\n    if T[i]=='S':\n      for j in range(2):\n        X[j]=f(X[j])\n    else:\n      for j in range(2):\n        X[j]+=1\n        if X[j]==t[N]:\n          X[j]=0\n  return X\n\nX=[]\nP=[0]*t[N]\nfor r in range(L*2-1):\n  X=g(N,r)\n  Y=1\n  P[X[0]]=Y+r\n  Y=Y*L%t[N]\n  P[X[1]]=Y+r\n  Z=(X[1]+t[N]-X[0])%t[N]\n  for j in range(t[N]):\n    X[1]=(X[1]+Y*Z)%t[N]\n    Y=Y*L%t[N]\n    P[X[1]]=Y+r\nfor i in range(t[N]):\n  P[i]%=t[N]\nD=dict()\nfor i in range(t[N]):\n  D[P[i]]=i\nprint(*[D[i] for i in range(t[N])])"
  },
  {
    "language": "Python",
    "code": "num = int(input())\nRS = list(input())\n#print(num)\n\ndance_human = list(range(3 ** num))\n#print(dance_human)\nlen_dance = int(len(dance_human))\nfor w in range(len(RS)):\n    if RS[w] == 'S':\n        list = [0] * len_dance\n        for i in range(len_dance):\n            target_num = dance_human[i]\n            save_num = []\n            if target_num == 0:\n                list[i] = 0\n            while target_num >0:\n                out = int(target_num%3)\n                if out == 2:\n                    out = 1\n                elif out == 1:\n                    out = 2\n                save_num.append(out)\n                target_num = int(target_num/3)\n            #print(save_num)\n            A = 0\n            for h in range(len(save_num)):\n                A = A + save_num[h] * (3 ** h)\n            #print(A)\n            list[i] = A\n            #print(list)\n    else:\n        list = []\n        for i in range(len_dance):   \n            list.append(dance_human[i]+1)\n            if list[i] == len_dance:\n                list[i] = 0\n    dance_human = list\n    #print(dance_human)\nfor s in dance_human:\n  print(s , end =\" \")"
  },
  {
    "language": "Python",
    "code": "\nn = int(input())\nt = input()\nlist1 = []\nlist2 = []\nfor i in range(0,(3**n)):\n    list1.append(i)\nfor j in t:\n    if j == 'S':\n        for v, k in enumerate(list1):\n            if k == 1:\n                list1[v] = 2\n            elif k == 2:\n                list1[v] = 1\n# lis = []\n    elif j == \"R\":\n        for o in range(0,len(list1)):\n            if o == list1[-1]:\n                list2.append(list1[i])\n            else:\n                list2.append(i)\n    list1.clear\n    list1.extend(list2)\nprint(list1)\n\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\ndef main():\n  n=int(input())\n  huhan=np.empty(3**n, np.int32)\n  a=(0,2,1)\n  l0=0\n  l1=0\n  l2=0\n  l3=0\n  l4=0\n  l5=0\n  l6=0\n  l7=0\n  l8=0\n  l9=0\n  l10=0\n  l11=0\n  b=(3,9,27,81,243,729,2187,6561,19683,59049,177147)\n  for i in range(3**n):\n    if l0==3:\n      l1+=1\n      l0=0\n      if l1==3:\n        l2+=1\n        l1=0\n        if l2==3:\n          l3+=1\n          l2=0\n          if l3==3:\n            l4+=1\n            l3=0\n            if l4==3:\n              l5+=1\n              l4=0\n              if l5==3:\n                l6+=1\n                l5=0\n                if l6==3:\n                  l7+=1\n                  l6=0\n                  if l7==3:\n                    l8+=1\n                    l7=0\n                    if l8==3:\n                      l9+=1\n                      l8=0\n                      if l9==3:\n                        l10+=1\n                        l9=0\n                        if l10==3:\n                          l11+=1\n                          l10=0\n    huhan[i]=a[l0]+a[l1]*b[0]+a[l2]*b[1]+a[l3]*b[2]+a[l4]*b[3]+a[l5]*b[4]+a[l6]*b[5]+a[l7]*b[6]+a[l8]*b[7]+a[l9]*b[8]+a[l10]*b[9]+a[l11]*b[10]\n    l0+=1\n  n3=3**n\n  p= np.arange(3**n)\n  t= [1 if s == 'R' else 0 for s in input().replace(\"SS\",\"\")]\n  snum=False\n  lnb=0\n  for sr in t:\n    if sr:\n      lnb +=1\n    else:\n      for x in range(3**n):\n        p += lnb\n        p %= n3\n        p[x]=huhan[p[x]]\n  print(\" \".join(map(str,p)))\nmain()"
  },
  {
    "language": "Python",
    "code": "from operator import itemgetter\n\ndef main():\n    n = int(input())\n    t = input()\n    change = [dest(i) for i in range(3**n)]\n    person = [i for i in range(3**n)]\n\n    def salsa(ary):\n        return [ary[change[i]] for i in range(3**n)]\n\n    for i in t:\n        if i == 'S':\n            person = salsa(person)\n        else:\n            person = [person.pop(-1)] + person\n\n    ans = [[i,x] for i,x in enumerate(person)]\n    ans.sort(key=itemgetter(1))\n    ans = [k[0] for k in ans]\n    print(*ans)\n\ndef go3(x):\n    if (int(x/3)):\n        return go3(int(x/3)) + str(x%3)\n    return str(x%3)\n\ndef back10(x):\n    out = 0\n    for i in range(1,len(str(x))+1):\n        out += int(x[-i])*(3**(i-1))\n    return out\n\ndef conv(s):\n    txt = ''\n    for i in s:\n        txt += ['0','2','1'][int(i)]\n    return txt\n\ndef dest(n):\n    return back10(conv(go3(n)))\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nT = input()\n\nans = list(range(0,3**N))\n\n\ndef Base_10_to_n(X, n):\n    if (int(X/n)):\n        return Base_10_to_n(int(X/n), n)+str(X%n)\n    return str(X%n)\n\n\ndef Base_n_to_10(X,n):\n    out = 0\n    for i in range(1,len(str(X))+1):\n        out += int(X[-i])*(n**(i-1))\n    return out\n\nA = []\nB = []\nfor n in range(N):\n  for range_a in range(3**n,3**n*2):\n    A.append(range_a)\n\n\nfor a in A:\n  B.append(int(Base_n_to_10(Base_10_to_n(a,3).replace('1', 'x').replace('2', '1').replace('x', '2'),3)))\n\n\n\nfor t in range(len(T)):\n  if T[t] == \"S\":\n    for count in range(len(A)):\n      ans[A[count]],ans[B[count]] = ans[B[count]],ans[A[count]]\n  else:\n    ans.append(ans.pop(0))\n\n\nprint(' '.join(map(str, ans)))\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nhuhan=[0]*(3**n)\na=[0,2,1]\nfor i in range(3**n):\n  b=[]\n  p=i\n  h=0\n  while True:\n    s=p//3\n    y=p%3\n    b=b+[a[y]]\n    if s==0:\n      break\n    p=s\n  for j in range(len(b)-1,-1,-1):\n    h=h*3+b[j]\n  huhan[i]=h\n\nn3=3**n\ndef main():\n  p=[i for i in range(3**n)]\n  t=input()\n  t=t.replace(\"SS\",\"\")\n  snum=False\n  for sr in t:\n    if sr==\"R\":\n      p=(map(lambda x: (x+1) % n3 ,p))\n    else:\n      p=(map(lambda x: huhan[x] ,p))\n  #if snum:\n  p=list(p)\n  print(\" \".join(map(str,p)))\n    \n\"\"\"def result(p,sr):\n  if sr==\"S\":\n    return(huhan[p])\n  else:\n    p=(p+1) % n3\n  return p\n\"\"\" \n    \nmain()"
  },
  {
    "language": "Python",
    "code": "num = int(input())\nRS = list(input())\nprint(num)\n\ndance_human = list(range(3 ** num))\nprint(dance_human)\n\nfor w in range(len(RS)):\n    if RS[w] == 'S':\n        list = [0] * int(len(dance_human))\n        for i in range(len(dance_human)):\n            target_num = i\n            save_num = []\n            x = 0\n            if target_num == 0:\n                list[i] = 0\n            while target_num >0:\n                out = int(target_num%3)\n                if out == 2:\n                    out = 1\n                elif out == 1:\n                    out = 2\n                save_num.append(out)\n                target_num = int(target_num/3)\n            \n            print(save_num)\n            A = 0\n            for h in range(len(save_num)):\n                A = A + save_num[h] * (3 ** h)\n            print(A)\n            list[A] = dance_human[i]\n            #print(list)\n    else:\n        list = []\n        for i in range(len(dance_human)):\n            if i == 0:\n                a = int(len(dance_human))\n                #print(a)\n                list.append(dance_human[a-1])\n                continue\n            #print(dance_human[i-1])\n            list.append(dance_human[i-1])\n    dance_human = list\n    print(dance_human)\nfor s in dance_human:\n  print(s , end =\" \")"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\nreadline = sys.stdin.readline\n\nN = int(readline())\nT = readline().strip()\n\n#Salsaの２回連続は元に戻るので削除\nT = T.replace('SS', '')\n\nTlen = len(T)\nD = ()\nRc = 0\nfor i in range(Tlen):\n    if T[i] == 'S':\n        if Rc:\n            #Rumba連続回数\n            D = D + (Rc,)\n            Rc = 0\n\n        #Salsa\n        D = D + (0,)\n    else:\n        #Rumba連続回数加算\n        Rc += 1\n\nif Rc:\n    #Rumba連続回数\n    D = D + (Rc,)\n    Rc = 0\n\n\nN3 = 3 ** N\nP = list(range(N3))\n\nfor Dn in D:\n    if Dn:\n        #Rumba: Dn移動\n        temp = P[N3 - Dn:]\n        P[Dn:] = P[:-Dn]\n        P[:Dn] = temp\n        #P[:Dn], P[Dn:] = P[N3 - Dn:], P[:-Dn]\n\n    else:\n        #Salsa: 1と2入れ替え\n        for i in range(N):\n            start = 3 ** i\n            stop = 3 ** N\n            step = 3 ** (i + 1)\n            dp = 3 ** i\n            for j in range(start, stop, step):\n                j1 = j + dp\n                j2 = j1 + dp\n                Pb = P[j:j1]\n                P[j:j1] = P[j1:j2]\n                P[j1:j2] = Pb\n                #P[j:j1], P[j1:j2] = P[j1:j2], P[j:j1]\n\n#出力用データ作成\nR = [None] * N3\nfor i in range(N3):\n    R[P[i]] = i\n    \nprint(*R)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "N=int(input())\nT=input()\np=len(\"T\")\nNa=3**N\nfor i in range(0,p):\n  if T == S:\n    \n    \n  \n\n\n  "
  },
  {
    "language": "Python",
    "code": "N=int(input())\nT=input()\nt=[]\ntmp=0\nsign=\"R\"\nfor i in range(len(T)):\n    if sign==\"R\":\n        if T[i]==\"R\":\n            tmp+=1\n        else:\n            if t and t[-1]!=\"S\":\n                t[-1]+=tmp\n                sign=\"S\"\n                tmp=1\n            else:\n                t.append(tmp)\n                tmp=1\n                sign=\"S\"\n    else:\n        if T[i]==\"S\":\n            tmp+=1\n        else:\n            if tmp%2==1:\n                t.append(\"S\")\n            tmp=1\n            sign=\"R\"\n\nif sign==\"R\":\n    if t and t[-1]!=\"S\":\n        t[-1]+=tmp\n        sign=\"S\"\n        tmp=1\n    else:\n        t.append(tmp)\n        tmp=1\n        sign=\"S\"\nelse:\n    if tmp%2==1:\n        t.append(\"S\")\n    tmp=1\n    sign=\"R\"\n\ndef dance(n,music):\n    if n==0:\n        return [0]\n    res=[-1]*3**n\n    for i in range(3):\n        nmusic=[]\n        val=i\n        for j in range(len(music)):\n            if music[j]!=\"S\":\n                tmp=music[j]//3\n                if val+(music[j]%3)>=3:\n                    tmp+=1\n                if nmusic and nmusic[-1]!=\"S\":\n                    nmusic[-1]+=tmp\n                elif tmp:\n                    nmusic.append(tmp)\n                val+=music[j]\n                val%=3\n            else:\n                if nmusic and nmusic[-1]==\"S\":\n                    nmusic.pop()\n                else:\n                    nmusic.append(\"S\")\n                val=(-val)%3\n        rres=dance(n-1,nmusic)\n        for j in range(3**(n-1)):\n            res[3*j+i]=3*rres[j]+val\n    return res\n\n\nres=dance(N,t)\nprint(*res)"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\n\ndef P_change(N, P):\n    #Salsa\n    for i in range(N):\n        start = 3 ** i\n        stop = 3 ** N\n        step = 3 ** (i + 1)\n        dp = 3 ** i\n        for j in range(start, stop, step):\n            j1 = j + dp\n            j2 = j1 + dp\n            Pb = P[j:j1]\n            P[j:j1] = P[j1:j2]\n            P[j1:j2] = Pb\n\n    return P\n\n\ndef P_slide(P):\n    #Rumba\n    temp = P[-1]\n    P[1:] = P[:-1]\n    P[0] = temp\n\n    return P\n\n\ndef dance(N, T):\n    #サルサの２回連続は元に戻る\n    T = T.replace('SS', '')\n    D = [True if Ti == 'S' else False for Ti in T]\n\n    N3 = 3 ** N\n    P = list(range(N3))\n\n    for Dn in D:\n        if Dn:\n            #Salsa\n            P = P_change(N, P)\n        else:\n            #Rumba\n            P = P_slide(P)\n\n    R = [0] * N3\n    for i in range(N3):\n        R[P[i]] = i\n\n    return  R\n    \n\nN = int(input())\nT = input()\n\nR = dance(N, T)\n\nprint(*R)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nt=input()\n\nlist0=[_ for _ in range(3**n)]\n\ndef myR(num):\n    return num+1 if num<3**n-1 else 0\n\ndef f(x):\n    if x==\"0\":\n        return \"0\"\n    elif x==\"1\":\n        return \"2\"\n    else:\n        return \"1\" \n\ndef myS(num):\n    initial_str=str(int(str(num),3))\n    after_str=\"\".join([f(x) for x in list(initial_str)])\n    return int(after_str,3)\n\nfor x in t:\n    if x=='S':\n        list0=[myS(y) for y in list0]\n    else:\n        list0=[myR(y) for y in list0]\n\nans_str=\" \".join([str(z) for z in list0])\nprint(ans_str)\n\n"
  },
  {
    "language": "Python",
    "code": "import string\ndef ternary (n):\n    if n == 0:\n        return '0'\n    nums = []\n    while n:\n        n, r = divmod(n, 3)\n        nums.append(str(r))\n    return ''.join(nums)\ndef to_dec(strs):\n    num = 0\n    for i in range(len(strs)):\n        num += 3**(i)*int(strs[i])\n    return num\n\ndef solve(N, T):\n    dic = {}\n    total = 3**N\n    for i in range(3**N):\n        if i in dic:\n            continue\n        te = ternary(i)\n        new_te = te.replace('1', '%temp%').replace('2', '1').replace('%temp%', '2') \n        new_i = to_dec(new_te)\n        if new_i != i:\n            dic[i] = new_i\n            dic[new_i] = i\n    person_2_seat = {i:i for i in range(total)}\n    seat_2_person = {i:i for i in range(total)}\n    ans = []\n    \n    stack = []\n    for i in range(len(T)):\n        if stack and T[i] == stack[-1][0]:\n            stack[-1][1]+=1\n        else:\n            stack.append([T[i], 1])\n\n    for i in range(len(stack)):\n        if stack[i][0] =='R':\n            count = stack[i][1]\n            new_person_2_seat, new_seat_2_person = {}, {}\n            for k, v in seat_2_person.items():\n                new_seat = (k+count) % total\n                new_person_2_seat[v] = new_seat\n                new_seat_2_person[new_seat] = v\n            person_2_seat, seat_2_person =new_person_2_seat, new_seat_2_person\n        else:\n            if stack[i][1] %2:\n                seen = set()\n                for k in dic:\n                    if k in seen: continue\n                    first, second = k, dic[k]\n                    p1, p2 = seat_2_person[first], seat_2_person[second]\n                    person_2_seat[p1], person_2_seat[p2] = second, first\n                    seat_2_person[first], seat_2_person[second] = p2, p1\n                    seen.add(second)\n    ans = []\n    for i in range(total):\n        ans.append(str(person_2_seat[i]))\n    return ' '.join(ans)\n\n\nN = int(input())\nT = input()\nprint(solve(N, T))"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport numpy as np\nfrom numba import njit\n\n\n@njit('i8[:](i8, i8[:])')\ndef P_change(N, P):\n    #Salsa\n    for i in range(N):\n        dp = 3 ** i\n        for j in range(3 ** i, 3 ** N, 3 ** (i + 1)):\n            P[j:j + dp], P[j + dp:j + dp * 2] = P[j + dp:j + dp * 2].copy(), P[j:j + dp].copy()\n    \n    return P\n\n\n@njit('i8[:](i8[:])')\ndef P_slide(P):\n    #Rumba\n    temp = P[-1]\n    P[1:] = P[:-1]\n    P[0] = temp\n\n    return P\n\n\ndef dance(N, T, P):\n    for i in range(len(T)):\n        if T[i] == 'S':\n            #Salsa\n            P = P_change(N, P)\n        elif T[i] == 'R':\n            #Rumba\n            P = P_slide(P)\n\n    return P\n\n\nN = int(input())\nT = str(input())\n\nT = T.replace('SS', 's')\nP = np.arange(3**N, dtype='int64')\n\nP = dance(N, T, P)\n\nP = P.tolist()\nprint(' '.join([str(P.index(i)) for i in range(len(P))]))\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nT = input()\nT = list(T)\n\nL = list(range(3**N))\nL2 = list(range(3**N))\ntL = 0\n\ndef base10to(n, b):\n  if (int(n/b)):\n    return base10to(int(n/b), b) + str(n%b)\n  return str(n%b)\n\n\nfor i in range(len(T)):\n  if(T[i] == \"R\"):\n      tL = L[3**N-1]\n      L.remove(L[3**N-1])\n      L.insert(0, tL)\n  if(T[i] == \"S\"):\n    for i in range(len(L)):\n      th = base10to(L[i], 3)\n      tha = list(th)\n      th_replace = [\"2\" if i == \"1\" else \"1\" if i == \"2\" else i for i in tha]\n      th_replace = ''.join(th_replace)\n      L2[i] = int(th_replace,3)\n\n    L = L2\n\n  print(L)\nL = [str(i) for i in L]\nL = ' '.join(L)\nprint(L)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\ndef Base_10_to_n(X, n):\n    X_dumy = X\n    out = ''\n    while X_dumy>0:\n        out = str(X_dumy%n)+out\n        X_dumy = int(X_dumy/n)\n    if out == '':\n        out = '0'\n    return out\n\ndef sarusa(n):\n    n = Base_10_to_n(n, 3)\n    n = n.replace('1', '3')\n    n = n.replace('2', '1')\n    n = n.replace('3', '2')\n    n = int(n, 3)\n    return n\n\ndef main():\n    N = int(readline())\n    T = readline().strip().decode()\n    ans = [i for i in range(3**N)]\n    l = [sarusa(i) for i in range(3**6)]\n    for t in T:\n        for i in range(3**N):\n            if t == 'S':\n                if ans[i] != 0:\n                    if i < 3**(N//2):\n                        ans[i] = l[ans[i]]\n                    else:\n                        ans[i] = l.index(ans[i])\n            elif ans[i] == 3**N-1:\n                ans[i] = 0\n            else:\n                ans[i] += 1\n\n    print(' '.join(list(map(str, ans))))\n    return\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nT = input()\nvol = 3**N\np = [i for i in range(vol)]\ndef base10to3(x):\n    if(int(x/3)):\n        return base10to3(int(x/3))+str(x%3)\n    return str(x%3)\ndef base3to10(x):\n    out = 0\n    for i in range(1,len(str(x))+1):\n        out += int(x[-i])*(3**(i-1))\n    return out\ndef sarusa(i):\n    before = base10to3(i)\n    after=before.translate(str.maketrans({'1':'2','2':'1'}))\n    return int(base3to10(after))\n\nfor i in range(len(T)):\n    if T[i] == 'S':\n        p = list(map(sarusa,p))\n    else:\n        for j in range(vol):\n            p[j] = (p[j]+1)%vol\nprint(' '.join(map(str,p)))"
  },
  {
    "language": "Python",
    "code": "def r(l, n):\n    for i in range(0, len(l)):\n        l[i] = (l[i] + n) % len(l)\n\n\ndef s(l, m):\n    for i in range(0, len(l)):\n        l[i] = m[l[i]]\n\n\nif __name__ == '__main__':\n    n = input()\n    m = list(range(0, 3 ** int(n)))\n    for i in m:\n        res = 0\n        temp = 1\n        record = i\n        while i != 0:\n            if i % 3 == 1:\n                res += 2 * temp\n            elif i % 3 == 2:\n                res += 1 * temp\n            temp *= 3\n            i //= 3\n        m[record] = res\n\n    l = list(range(0, 3 ** int(n)))\n    cmd = list(input())\n    j = 0\n    new_cmd = []\n    while j < len(cmd):\n        temp = 0\n        while j < len(cmd) and cmd[j] == \"S\":\n            j += 1\n            temp += 1\n        if temp % 2 == 1:\n            new_cmd.append(\"S\")\n        temp = 0\n        while j < len(cmd) and cmd[j] == \"R\":\n            j += 1\n            temp += 1\n        new_cmd.append(\"R\" * temp)\n    for c in new_cmd:\n        if c == \"S\":\n            s(l, m)\n        else:\n            r(l, len(c))\n    for p in l:\n        print(p, end=\" \")\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    N = int(input())\n    T = input()\n    vol = 3**N\n    p = [i for i in range(vol)]\n    from functools import lru_cache\n    @lru_cache(maxsize = None)\n    def base10to3(X):\n            if (int(X/3)):\n                return base10to3(int(X/3))+str(X%3)\n            return str(X%3)\n    def base3to10(x):\n        out = 0\n        for i in range(1,len(str(x))+1):\n            out += int(x[-i])*(3**(i-1))\n        return out\n    def sarusa(i):\n        before = base10to3(i)\n        after=before.translate(str.maketrans({'1':'2','2':'1'}))\n        return int(base3to10(after))\n\n    for i in range(len(T)):\n        if T[i] == 'S':\n            p = list(map(sarusa,p))\n        else:\n            for j in range(vol):\n                p[j] = (p[j]+1)%vol\n    print(' '.join(map(str,p)))\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "Num = [list(range(3**(i+1))) for i in range(11)]\nNum[0] = [0,2,1]\nfor i in range(1,11):\n    Num[i] = Num[i-1] + list(map(lambda x:x+2*3**(i),Num[i-1])) + list(map(lambda x:x+3**(i),Num[i-1]))\ndef Q(Num):\n    ans = 0\n    while Num > 1:\n        Num = Num // 3\n        ans += 1\n    return ans\ndef R(List):\n  Num = len(List)\n  if Num == 1:\n    return [List[0],List[2],List[1]]\n  else:\n    A = Q(Num) - 1\n    L = List[Num[A][i] for i in range(Num)]\n    return L\ndef S(List):\n    L = [List[len(List)-1]] + List[:len(List)-1]\n    return L\nN = int(input())\nT = list(input())\nP = list(range(3**N))\nfor s in T:\n  if s == 'R':\n    P = S(P)\n  else:\n    P = R(P)\nAns = [0 for i in range(3**N)]\nfor x,i in zip(P,range(3**N)):\n    Ans[x] = i\nprint(*Ans)"
  },
  {
    "language": "Python",
    "code": "def R(x):\n    x.insert(0, x.pop(-1))\n    return x\n    \ndef S(x, n):\n    ex = [0]*n\n    for j in range(len(x)//3):\n        \n        k = j\n        tmp = 0\n        m = 1\n        while k > 0:\n            if k%3 == 1:\n                tmp = tmp + 2*(3**m)\n            elif k%3 == 2:\n                tmp = tmp + 1*(3**m)\n            k = k//3\n            m = m +1\n        ex[tmp] = x[j*3]\n        ex[tmp + 2] = x[j*3 +1]\n        ex[tmp + 1] = x[j*3 +2]\n    return(ex)\n            \n    \ndef main():\n    N = int(input())\n    T = input()\n    l = list(range(3**N))\n    p = [0]*(3**N)\n    \n    for i in range(len(T)):\n        if T[i] == \"R\":\n            l = R(l)\n        elif T[i] == \"S\":\n            l = S(l, 3**N)\n    for i in range(len(l)):\n        p[l[i]] = i\n    \n    print(p)\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\n\ndef main():\n\n    # 実行環境(0:vscode, 1:atcoder)\n    MODE = 1\n\n    # 入力の次元\n    DIMENSION = 2\n\n    # int型に変換\n    INT_TYPE = 0\n\n    if not (MODE):\n        with open(\"input.txt\", \"r\") as f:\n            s = f.read()\n    else:\n        s = sys.stdin.read()\n\n    if DIMENSION == 1:\n        if INT_TYPE == 1:\n            s = int(s)\n    elif DIMENSION == 2:\n        if INT_TYPE == 0:\n            s = s.split()\n        elif INT_TYPE == 1:\n            s = [int(x) for x in s.split()]\n    elif DIMENSION == 3:\n        if INT_TYPE == 0:\n            s = [x.split() for x in s.splitlines()]\n        elif INT_TYPE == 1:\n            s = [[int(y) for y in x.split()] for x in s.splitlines()]\n\n    N = int(s[0])\n    T = s[1]\n    NUM = 3 ** N\n    P = list(range(NUM))\n\n    for t in T:\n        if t == \"S\":\n            for j, p in enumerate(P):\n                p_3 = [None] * N\n                p_3_mod = p\n                for i in range(N):\n                    p_3[i] = p_3_mod // 3 ** (N-i-1)\n                    p_3_mod = p_3_mod % 3 ** (N-i-1)\n                    if p_3[i] == 1:\n                        p_3[i] = 2\n                    elif p_3[i] == 2:\n                        p_3[i] = 1\n                p_new = 0\n                for i in range(N):\n                    p_new += 3 ** i * p_3[N - i - 1]\n                P[j] = p_new\n        else:\n            for i in range(NUM):\n                P[i] += 1\n                if P[i] == NUM:\n                    P[i] = 0\n\n    text = \"\"\n    for p in P:\n        text += str(p) + \" \"\n    print(text)\n\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "def base10to(n):\n    b = 3\n    if int(n/b):\n        return base10to(int(n/b)) + str(n%b)\n    return str(n%b)\ndef salsa(base3):\n    x = 0\n    l = len(base3)\n    for i, s in enumerate(base3):\n        if s == '1':\n            x += 2* pow(3, (l-1-i))\n        elif s == '2':\n            x += pow(3, (l-1-i))\n    return x\n\nN = int(input())\nT = list(input())\n\ns_list = [salsa(base10to(i)) for i in range(pow(3, N))]\nans = [i for i in range(pow(3, N))]\n\nfor x in T:\n    if x == 'S':\n        for i in range(pow(3, N)):\n            ans[i] = s_list[ans[i]]\n    else:\n        for i in range(pow(3, N)):\n            ans[i] += 1\n            if ans[i] == pow(3, N):\n                ans[i] = 0\nprint(*ans)"
  },
  {
    "language": "Python",
    "code": "def salsa(X):\n    result = ''\n    tmp = int(X)\n    y = tmp // 3\n    for i in range(y):\n        if tmp%3 == 1:\n            a = 2\n        elif tmp%3 == 2:\n            a = 1\n        else:\n            a = 0\n        result = str(a) + result\n        tmp = int(tmp / 3)\n    if tmp%3 == 1:\n        a = 2\n    elif tmp%3 == 2:\n        a = 1\n    else:\n        a = 0\n    result = str(a) + result\n    return result\n\ndef Base_3_to_10(X):\n    out = 0\n    for i in range(1,len(str(X))+1):\n        out += int(X[-i])*(3**(i-1))\n    return out\n\nn = int(input())\nt = input()\np = [i for i in range(3 ** n)]\n\nfor ti in t:\n    if ti == 'S':\n        p = list(map(lambda x: salsa(x), p))\n        p = list(map(lambda x: Base_3_to_10(x), p))\n    else:\n        p = list(map(lambda x: (x + 1) % 3 ** n, p))\nprint(*p, sep=' ')"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nt=input()\nnumber=[]\nfor j in range(3**n):\n  number.append(j)\ndef base_10_to_3(X):\n    if (int(X/3)):\n        return base_10_to_3(int(X/3))+str(X%3)\n    return str(X%3)\ndef base_3_to_10(Y):\n    out = 0\n    for i in range(1,len(str(Y))+1):\n        out += int(Y[-i])*(3**(i-1))\n    return out\ndef s(Num):\n  nextnumber=[0]*(3**n)\n  for k in range(3**n):\n    next=str(base_10_to_3(k))\n    next=next.replace(\"1\",\"W\").replace(\"2\",\"1\").replace(\"W\",\"2\")\n    #print(next)\n    nextnumber[base_3_to_10(str(next))]=Num[k]\n  return nextnumber\ndef r():\n  last=number.pop(3**n-1)\n  number.insert(0,last)\nfor m in range(len(t)):\n  first=t[m]\n  if first=='S':\n    number=s(number)\n  elif first=='R':\n    r()\n  #print(number)\n#print(number)\npp=[0]*(3**n)\nfor p in range(3**n):\n  print(number.index(p), end =\" \")\n  "
  },
  {
    "language": "Python",
    "code": "n=int(input())\nhuhan=[0]*(3**n)\na=[0,2,1]\nfor i in range(3**n):\n  b=[]\n  p=i\n  h=0\n  while True:\n    s=p//3\n    y=p%3\n    b=b+[a[y]]\n    if s==0:\n      break\n    p=s\n  for j in range(len(b)-1,-1,-1):\n    h=h*3+b[j]\n  huhan[i]=h\n\nn3=3**n\ndef main():\n  p=[i for i in range(3**n)]\n  t=input()\n  snum=False\n  for sr in t:\n    if sr==\"R\":\n      p=(map(lambda x: (x+1) % n3 ,p))\n    else:\n      p=(map(lambda x: huhan[x] ,p))\n  #if snum:\n  p=list(p)\n  print(\" \".join(map(str,p)))\n    \n\"\"\"def result(p,sr):\n  if sr==\"S\":\n    return(huhan[p])\n  else:\n    p=(p+1) % n3\n  return p\n\"\"\" \n    \nmain()"
  },
  {
    "language": "Python",
    "code": "N=int(input())\nT=input()\nNa=3**N"
  },
  {
    "language": "Python",
    "code": "\nimport math\ndef Salsa1(N_Pow, Len):\n    if(N_Pow==1):\n        Dest = [0] * 3\n        Dest[0] = 0\n        Dest[1] = 2\n        Dest[2] = 1\n        return Dest\n    else:\n        Dest = [0] * (Len//3)\n    Dest[0] = 0\n    Dest[1] = 2\n    Dest[2] = 1\n\n    Value_Min = 1\n    for Pow in range(1, N_Pow-1):\n        Value_Min *= 3\n        Value_Max = Value_Min *2-1\n        for Num in range(Value_Min, Value_Max+1, 1):\n            Value2 = Dest[Num-Value_Min] + 2 * Value_Min\n            Dest[Num] = Value2\n            Dest[Value2] = Num\n    return Dest\n\ndef Salsa(N_Pow, Len):\n\n    Dest = [0] * Len\n    Dest[0] = 0\n    Dest[1] = 2\n    Dest[2] = 1\n\n    Value_Min = 1\n    for Pow in range(1, N_Pow):\n        Value_Min *= 3\n        Value_Max = Value_Min *2-1\n        for Num in range(Value_Min, Value_Max+1, 1):\n            Value2 = Dest[Num-Value_Min] + 2 * Value_Min\n            Dest[Num] = Value2\n            Dest[Value2] = Num\n    return Dest\n\n\ndef moveSalsa1(Dest_Salsa, PosList):\n    N = len(PosList)\n    N_3 = N//3\n    N_2_3 = N_3 *2\n    for Num in range(N):\n        if(PosList[Num] >= N_2_3):\n            PosList[Num] = Dest_Salsa[ PosList[Num]-N_2_3 ] + N_3\n        elif(PosList[Num] >= N_3):\n            PosList[Num] = Dest_Salsa[ PosList[Num]-N_3 ] + N_2_3\n        else:\n            PosList[Num] = Dest_Salsa[ PosList[Num] ]\ndef moveSalsa(Dest_Salsa, PosList):\n    N = len(PosList)\n    for Num in range(N):\n        PosList[Num] = Dest_Salsa[ PosList[Num] ]\n\ndef moves(N_Pow, PosList, Str):\n    MoveTimes = len(Str)\n    Len = len(PosList)\n\n    Dest_Salsa = Salsa(N_Pow, Len)\n    k =0\n    while(k < MoveTimes):\n        SameTimes = 0\n        if(Str[k] == 'S'):\n            k += 1\n            SameTimes += 1\n            while(k < MoveTimes and Str[k] == 'S'):\n                k += 1\n                SameTimes += 1\n            if(SameTimes%2 !=0):\n                moveSalsa(Dest_Salsa, PosList)\n        else:\n            k += 1\n            SameTimes += 1\n            while(k < MoveTimes and Str[k] == 'R'):\n                k += 1\n                SameTimes += 1\n\n            for Num in range(Len):\n                PosList[Num] = (PosList[Num]+SameTimes) % Len\n\n    Str = \"\"\n    for Num in range( Len ):\n        Str = Str + str(PosList[Num]) + \" \"\n    print(Str)\n\nif(__name__ == \"__main__\"):\n    N_Pow = int( input().strip() )\n    T = input().strip()\n\n\n    Len = 3**(N_Pow)\n    PosList = []\n    for Num in range(Len):\n        PosList.append(Num)\n    moves(N_Pow, PosList, T)\n"
  },
  {
    "language": "Python",
    "code": "import math\ndef base3(X):\n    if (int(X/3)):\n        return base3(int(X/3))+str(X%3)\n    return str(X%3)\n    \n    \ndef kaketamono3 (value):\n    wa=0\n    for i in range(len(base3(value))):\n        if int(base3(value)[-(i+1)])>0:\n            wa+=3**(i+1)\n    return wa-value\n  \ndef list(value):\n\n    list_for = [] \n    for i in range(value): \n        list_for.append(i)\n\n    return(list_for)\nn=int(input())\nt=str(input())\ns=list(3**n)\n\nfor i in range(len(t)):\n    if t[i]==\"S\":\n        for j in range(len(s)):\n            s[j]=kaketamono3(s[j])\n        \n    elif t[i]==\"R\":\n        for j in range(len(s)):\n            if s[j]==3**n-1:\n                s[j]=0\n            else:\n                s[j]=s[j]+1\n        \nprint(*s)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\ndef main():\n  n=int(input())\n  huhan=np.empty(3**n, np.int32)\n  a=(0,2,1)\n  l0=0\n  l1=0\n  l2=0\n  l3=0\n  l4=0\n  l5=0\n  l6=0\n  l7=0\n  l8=0\n  l9=0\n  l10=0\n  l11=0\n  b=(3,9,27,81,243,729,2187,6561,19683,59049,177147)\n  for i in range(3**n):\n    if l0==3:\n      l1+=1\n      l0=0\n      if l1==3:\n        l2+=1\n        l1=0\n        if l2==3:\n          l3+=1\n          l2=0\n          if l3==3:\n            l4+=1\n            l3=0\n            if l4==3:\n              l5+=1\n              l4=0\n              if l5==3:\n                l6+=1\n                l5=0\n                if l6==3:\n                  l7+=1\n                  l6=0\n                  if l7==3:\n                    l8+=1\n                    l7=0\n                    if l8==3:\n                      l9+=1\n                      l8=0\n                      if l9==3:\n                        l10+=1\n                        l9=0\n                        if l10==3:\n                          l11+=1\n                          l10=0\n    huhan[i]=a[l0]+a[l1]*b[0]+a[l2]*b[1]+a[l3]*b[2]+a[l4]*b[3]+a[l5]*b[4]+a[l6]*b[5]+a[l7]*b[6]+a[l8]*b[7]+a[l9]*b[8]+a[l10]*b[9]+a[l11]*b[10]\n    l0+=1\n  #print(huhan)\n  n3=3**n\n  p= np.arange(3**n)\n  #t=input()\n  t= [1 if s == 'R' else 0 for s in input().replace(\"SS\",\"\")]\n  snum=False\n  lnb=0\n  for sr in t:\n    if sr:\n      lnb +=1\n    else:\n      p += lnb\n      p %= n3\n      \"\"\"for x in p:\n        x=huhan[x]\n        print(p)\n      \"\"\"\n      p=np.where(True,huhan[p],0)\n      lnb=0\n  if lnb>0:\n    p += lnb\n    p %= n3\n  print(\" \".join(map(str,p)))\nmain()"
  },
  {
    "language": "Python",
    "code": "\ndef Salsa(N_Pow):\n    Dest = [0] * 3**(N_Pow)\n    Dest[0] = 0\n    Dest[1] = 2\n    Dest[2] = 1\n\n    for Pow in range(1, N_Pow):\n        Value_Min = 3**Pow\n        Value_Max = 3**Pow *2-1\n        for Num in range(Value_Min, Value_Max+1, 1):\n            Value2 = Dest[Num-Value_Min] + 2 * Value_Min\n            Dest[Num] = Value2\n            Dest[Value2] = Num\n    return Dest\n\ndef Lumba(N_Pow):\n\n    Len = 3**(N_Pow)\n    Dest = [0] * Len\n    for Num in range(Len):\n        Dest[Num] = Num+1\n    Dest[Len-1] = 0\n    return Dest\n\ndef move(Dest_Salsa, PosList, Is_Salsa):\n    N = len(PosList)\n    if(Is_Salsa == True):\n        for Num in range(N):\n            PosList[Num] = Dest_Salsa[ PosList[Num] ]\n    else:\n        for Num in range(N):\n            PosList[Num] = (PosList[Num]+1) % N\n\ndef moves(N_Pow, PosList, Str):\n    MoveTimes = len(Str)\n\n    # Dest_Lumba = Lumba(N_Pow)\n    Dest_Salsa = Salsa(N_Pow)\n    for k in range(MoveTimes):\n        if(Str[k] == 'S'):\n            move(Dest_Salsa, PosList, True)\n        else:\n            move(Dest_Salsa, PosList, False)\n    print(PosList)\n\nif(__name__ == \"__main__\"):\n    N_Pow = int( input().strip() )\n    T = input().strip()\n\n\n    Len = 3**(N_Pow)\n    PosList = []\n    for Num in range(Len):\n        PosList.append(Num)\n    moves(N_Pow, PosList, T)\n"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\n\ndef P_change(N, P):\n    #Salsa\n    for i in range(N):\n        start = 3 ** i\n        step = 3 ** (i + 1)\n        dp = 3 ** i\n        for j in range(start, 3 ** N, step):\n            P[j:j + dp], P[j + dp:j + dp * 2] = P[j + dp:j + dp * 2], P[j:j + dp]\n    \n    return P\n\n\ndef P_slide(P):\n    #Rumba\n    temp = P[-1]\n    P[1:] = P[:-1]\n    P[0] = temp\n\n    return P\n\n\nN = int(input())\nT = input()\n\nP = list(range(3**N))\nT = T.replace('SS', 's')\n\nfor Ti in T:\n    if Ti == 'S':\n        #Salsa\n        P = P_change(N, P)\n    elif Ti == 'R':\n        #Rumba\n        P = P_slide(P)\n\nprint(' '.join([str(P.index(i)) for i in range(len(P))]))\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "def Base_10_to_n(X):\n    if (int(X/3)):\n        return Base_10_to_n(int(X/3))+str(X%3)\n    return str(X%3)\ndef change(t):\n  return int(t,3)\nn=int(input())\nL = [n for n in range(3**n)]\nT=input()\nc=len(T)\nfor i in range(c):\n  if T[i]==\"R\":\n    L=list(map(lambda x: (x+1)%(3**n),L))\n  elif T[i]==\"S\":\n    K=list(map(Base_10_to_n,L))\n    A=\"/\".join(map(str,K))\n    A=A.replace(\"1\",\"#\")\n    A=A.replace(\"2\",\"1\")\n    A=A.replace(\"#\",\"2\")\n    K=A.split(\"/\")\n    L=list(map(change,K))\n    L=list(map(int,L))\nprint(\" \".join(map(str,L)))"
  },
  {
    "language": "Python",
    "code": "def transform(place):\n    result = []\n    while True:\n        place, remain = divmod(place, 3)\n        result.append(remain)\n        if place == 0:\n            break\n\n    for i in range(0, len(result)):\n        if result[i] == 1:\n            result[i] = 2\n        elif result[i] == 2:\n            result[i] = 1\n\n    sum = 0\n    for i in range(0, len(result)):\n        sum += result[i] * (3 ** i)\n\n    return sum\n\n\npower = int(input())\noperations = input()\n\nafter = []\nfor i in range(0, 3 ** power):\n    after.append(i)\n\nfor step in operations:\n    before = after[:]\n    if step == \"S\":\n        for place in range(0, 3 ** power):\n            after[transform(place)] = before[place]\n    else:\n        after = before[1:]\n        after.append(before[0])\n\nfor i in range(0, len(after)):\n    if i < len(after) - 1:\n        print(after[i], end=\" \")\n    else:\n        print(after[i])\n"
  },
  {
    "language": "Python",
    "code": "num = int(input())\nRS = list(input())\n#print(num)\n\ndance_human = list(range(3 ** num))\n#print(dance_human)\nlen_dance = int(len(dance_human))\nfor w in range(len(RS)):\n    if RS[w] == 'S':\n        list = [0] * len_dance\n        for i in range(len_dance):\n            target_num = dance_human[i]\n            save_num = []\n            if target_num == 0:\n                list[i] = 0\n            while target_num >0:\n                out = int(target_num%3)\n                if out == 2:\n                    out = 1\n                else:\n                    out = 2\n                save_num.append(out)\n                target_num = int(target_num/3)\n            #print(save_num)\n            A = 0\n            for h in range(len(save_num)):\n                A = A + save_num[h] * (3 ** h)\n            #print(A)\n            list[i] = A\n            #print(list)\n    else:\n        list = []\n        for i in range(len_dance):   \n            list.append(dance_human[i]+1)\n            if list[i] == len_dance:\n                list[i] = 0\n    dance_human = list\n    #print(dance_human)\nfor s in dance_human:\n  print(s , end =\" \")"
  },
  {
    "language": "Python",
    "code": "import sys\nimport time\n\nt1 = time.time()\n\n# 実行環境(0:vscode, 1:atcoder)\nMODE = 0\n\n# 入力の次元\nDIMENSION = 2\n\n# int型に変換\nINT_TYPE = 0\n\nif not (MODE):\n    with open(\"input.txt\", \"r\") as f:\n        s = f.read()\nelse:\n    s = sys.stdin.read()\n\nif DIMENSION == 1:\n    if INT_TYPE == 1:\n        s = int(s)\nelif DIMENSION == 2:\n    if INT_TYPE == 0:\n        s = s.split()\n    elif INT_TYPE == 1:\n        s = [int(x) for x in s.split()]\nelif DIMENSION == 3:\n    if INT_TYPE == 0:\n        s = [x.split() for x in s.splitlines()]\n    elif INT_TYPE == 1:\n        s = [[int(y) for y in x.split()] for x in s.splitlines()]\n\n\ndef base10to(n, b):\n    if (int(n/b)):\n        return base10to(int(n/b), b) + str(n % b)\n    return str(n % b)\n\ndef main():\n    N = int(s[0])\n    T = s[1]\n    NUM = 3 ** N\n    P = list(range(NUM))\n\n    for t in T:\n        if t == \"S\":\n            for j, p in enumerate(P):\n                p_3 = [None] * N\n                p_3_mod = p\n                for i in range(N):\n                    p_3[i] = p_3_mod // 3 ** (N-i-1)\n                    p_3_mod = p_3_mod % 3 ** (N-i-1)\n                    if p_3[i] == 1:\n                        p_3[i] = 2\n                    elif p_3[i] == 2:\n                        p_3[i] = 1\n                p_new = 0\n                for i in range(N):\n                    p_new += 3 ** i * p_3[N - i - 1]\n                P[j] = p_new\n        else:\n            for i in range(NUM):\n                P[i] += 1\n                if P[i] == NUM:\n                    P[i] = 0\n\n    text = \"\"\n    for p in P:\n        text += str(p) + \" \"\n    print(text)\n\n    t2 = time.time()\n    print(t2-t1)\n\nmain()"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\nN = int(input())\nT = input()\n\n#サルサの２回連続は元に戻る\nT = T.replace('SS', '')\n#D = [True if Ti == 'S' else False for Ti in T]\nD = [1 if Ti == 'S' else 0 for Ti in T]\n\nN3 = 3 ** N\nP = [0] * N3\nPd = dict()\n\nfor Pos in range(N3):\n    Pi = Pos\n    for Dn in D:\n        if Dn:\n            #Salsa\n            Ps = Pi\n            if Ps in Pd:\n                Pi = Pd[Ps]\n            else:\n                Pos1 = 0\n                Pos2 = Pi\n                for Ni in range(N, 0, -1):\n                    Ni3 = 3 ** (Ni - 1)\n\n                    div, Pos2 = divmod(Pos2, Ni3)\n\n                    if div == 1:\n                        Pos1 += Ni3 * 2\n                    elif div == 2:\n                        Pos1 += Ni3\n                    else:\n                        Pos1 += 0\n\n                    if Pos2 == 0:\n                        break\n\n                Pi = Pos1 + Pos2\n\n                Pd[Ps] = Pi\n        else:\n            #Rumba\n            Pi += 1\n            if Pi == N3:\n                Pi = 0\n\n    P[Pos] = Pi\n\n    \nprint(*P)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nT = str(input())\nimport numpy as np\na = [i for i in range(3**N)]\nb = [0 for i in range(3**N)]\nfor i in range(N):\n    n = [3**i for _ in range(3**N)]\n    m = ([0]*int(3**i) + [2]*int(3**i) + [1]*int(3**i))*int(3**(N-(i+1)))\n    b = [o + p*q for o,p,q in zip(b,n,m)]\nb = b\nfor t in T:\n  if t == 'S':\n    a = [b[ai] for ai in a]\n  else:\n    a = [(ai + 1)%3**N for ai in a]\nans = ''\nfor ai in a:\n    ans += str(ai) + ' '\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\ndef cvt(a):\n    b = 0\n    c = 0\n    while a != 0:\n        d = a % 3\n        a = (a-(a % 3)) / 3\n        if d == 1:\n            d = 2\n        elif d == 2:\n            d = 1\n        b += d * (3**c)\n        c += 1\n    return int(b)\nN = int(input())\nT = input()\nA = np.array([i for i in range(3**N)])\nB = np.array([i for i in range(3**N)])\nfor t in T:\n    for i in range(3**N):\n        if t == 'S':\n            B[i] = cvt(A[i])\n        else:\n            B[i] += 1\n            if B[i] == 3**N:\n                B[i] = 0\n    A = B.copy()\nfor i in A:\n    print(i, end = ' ')\n                "
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport numpy as np\nfrom numba import njit\n\n\n@njit('i8[:](i8, i8[:])')\ndef P_change(N, P):\n    #Salsa\n    for i in range(N):\n        dp = 3 ** i\n        for j in range(3 ** i, 3 ** N, 3 ** (i + 1)):\n            P[j:j + dp], P[j + dp:j + dp * 2] = P[j + dp:j + dp * 2].copy(), P[j:j + dp].copy()\n    \n    return P\n\n\n@njit('i8[:](i8[:])')\ndef P_slide(P):\n    #Rumba\n    temp = P[-1]\n    P[1:] = P[:-1]\n    P[0] = temp\n\n    return P\n\n\n#@njit('i8[:](i8, b1[:], i8[:])')\ndef dance(N, D, P):\n    for Dn in D:\n        if Dn:\n            #Salsa\n            P = P_change(N, P)\n        else:\n            #Rumba\n            P = P_slide(P)\n\n    N3 = 3 ** N\n    R = np.zeros(N3, dtype=np.int64)\n    for i in range(N3):\n        R[P[i]] = i\n\n    return  R\n\n\nN = int(input())\nT = str(input())\n\nT = T.replace('SS', '')\nD = np.array([True if Ti == 'S' else False for Ti in T], dtype=np.bool)\n\nP = np.arange(3**N, dtype='int64')\n\nR = dance(N, D, P)\n\nprint(*R)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\nfrom numba import njit\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\n@njit('(i8,i4[::1])', cache=True)\ndef solve(dep, T):\n    if dep == 0:\n        return np.array([0], np.int32)\n    A = np.empty(3**dep, np.int32)\n    for d in range(3):\n        TT = np.empty_like(T)\n        p = 0\n        x = d\n        for t in T:\n            if t == 0:\n                x = 3 - x if x else 0\n                if p > 0 and TT[p - 1] == 0:\n                    p -= 1\n                else:\n                    TT[p] = 0\n                    p += 1\n            else:\n                x = x + 1\n                if x == 3:\n                    x = 0\n                    TT[p] = 1\n                    p += 1\n        TT = TT[:p]\n        A[d::3] = 3 * solve(dep - 1, TT) + x\n    return A\n\nN = int(readline())\nT = np.frombuffer(read().rstrip(), 'S1')\n\nT = ((T == b'R') * 1).astype(np.int32)\n\nans = solve(N, T)\nprint(' '.join(ans.astype(str)))"
  },
  {
    "language": "Python",
    "code": "import copy\n\nN = int(input())\nt = input()\nT = []\nPlace = []\nnumber = 3**N\nans = [0]*number\nk = 0\n\ndef to_3(X):\n    if (int(X/3)):\n        return to_3(int(X/3))+str(X%3)\n    return str(X%3)\ndef to_10(X):\n    out = 0\n    for i in range(1,len(X)+1):\n        out += int(X[-i])*(3**(i-1))\n    return out#int out\n\nfor a in range(len(t)):\n    T.append(t[a])\n\nfor b in range(number):\n    Place.append(b)\n\nfor music in T:\n    if music == 'S':\n        PrePlace = copy.copy(Place)\n        for i in range(number):\n            jstr = to_3(i)\n            jstr = jstr.translate(str.maketrans({'1': '2', '2': '1'}))\n            j = int(to_10(jstr))\n            Place[j] = PrePlace[i]\n\n    else:\n        end = Place.pop(-1)\n        Place.insert(0, end)\n\nfor item in Place:\n    ans[item] = k\n    k += 1\n\nprint(' '.join(map(str, ans)))"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\nreadline = sys.stdin.readline\n\nN = int(readline())\nT = readline().strip()\n\n#サルサの２回連続は元に戻る\nT = T.replace('SS', '')\n\n#ダンスの順番をtupleに入れる\nTlen = len(T)\nD = [None] * Tlen\nRc = 0\np = 0\nfor i in range(Tlen):\n    if T[i] == 'S':\n        if Rc:\n            #Rumba\n            D[p] = Rc\n            Rc = 0\n            p += 1\n \n        #Salsa\n        D[p] = 0\n        p += 1\n    else:\n        #Rumba\n        Rc += 1\n \nif Rc:\n    #Rumba\n    D[p] = Rc\n    Rc = 0\n    p += 1\n \nD = D[:p]\nD = tuple(D)\n\nN3 = 3 ** N\n\n#Salsaの移動データ事前作成\nSd = [None] * N3\nN32 = 3 ** (N - 1) * 2\nfor Pos in range(N32):\n    if Sd[Pos]: continue\n\n    Pos1 = 0\n    Pos2 = Pos\n    for Ni in range(N, 0, -1):\n        Ni3 = 3 ** (Ni - 1)\n\n        div, Pos2 = divmod(Pos2, Ni3)\n\n        if div == 1:\n            Pos1 += Ni3 * 2\n        elif div == 2:\n            Pos1 += Ni3\n        else:\n            Pos1 += 0\n\n        if Pos2 == 0:\n            break\n\n    Pi = Pos1 + Pos2\n    Sd[Pos] = Pi\n    Sd[Pi] = Pos\n\nSd = tuple(Sd)\n\n#ダンス終了位置\nP = [None] * N3\nfor Pos in range(N3):\n    Pi = Pos\n    for Dn in D:\n        if Dn:\n            #Rumba\n            Pi = (Pi + Dn) % N3\n        else:\n            #Salsa\n            Pi = Sd[Pi]\n\n    P[Pos] = Pi\n\n\nprint(*P)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nhuhan=[0]*(3**n)\na=[0,2,1]\nfor i in range(3**n):\n  b=[]\n  p=i\n  h=0\n  while True:\n    s=p//3\n    y=p%3\n    b=b+[a[y]]\n    if s==0:\n      break\n    p=s\n  for j in range(len(b)-1,-1,-1):\n    h=h*3+b[j]\n  huhan[i]=h\n\nn3=3**n\ndef main():\n  p=[i for i in range(3**n)]\n  t=input()\n  t=t.replace(\"SS\",\"\")\n  t=t.replace(\"SRSRSRSRSRSRSRSRSRSRSRSRSRSRSRSRSRSR\",\"\")\n  snum=False\n  for sr in t:\n    if sr==\"R\":\n      p=(map(lambda x: (x+1) % n3 ,p))\n    else:\n      p=(map(lambda x: huhan[x] ,p))\n  #if snum:\n  p=list(p)\n  print(\" \".join(map(str,p)))\n    \n\"\"\"def result(p,sr):\n  if sr==\"S\":\n    return(huhan[p])\n  else:\n    p=(p+1) % n3\n  return p\n\"\"\" \n    \nmain()"
  },
  {
    "language": "Python",
    "code": "def base10to(n):\n    b = 3\n    if int(n/b):\n        return base10to(int(n/b)) + str(n%b)\n    return str(n%b)\ndef salsa(base3):\n    x = 0\n    l = len(base3)\n    for i, s in enumerate(base3):\n        if s == '1':\n            x += 2* pow(3, (l-1-i))\n        elif s == '2':\n            x += pow(3, (l-1-i))\n    return x\n\nN = int(input())\nT = list(input())\nM = pow(3, N)\n\ns_list = [salsa(base10to(i)) for i in range(M)]\nans = [i for i in range(M)]\nrumba_count = 0\nfor x in T:\n    if x == 'S':\n        for i in range(M):\n            ans[i] = s_list[(ans[i]+rumba_count)% M]\n        rumba_count = 0\n            # ans[i] = s_list[ans[i]]\n    else:\n        rumba_count += 1\n        # for i in range(M):\n        #     ans[i] += 1\n        #     if ans[i] == M:\n        #         ans[i] = 0\nfor i in range(M):\n    print((ans[i]+rumba_count) %M, end = ' ')"
  },
  {
    "language": "Python",
    "code": "def R(x):\n    x.insert(0, x.pop(-1))\n    return x\n    \ndef S(x, n):\n    ex = [\"\"]*n\n    for j in range(len(x)//3):\n        \n        k = j\n        tmp = 0\n        m = 3\n        q = j*3\n        while k > 0:\n            if k%3 == 1:\n                tmp = tmp + 2*m\n            elif k%3 == 2:\n                tmp = tmp + 1*m\n            k = k//3\n            m = m*3\n        ex[tmp] = x[q]\n        ex[tmp + 2] = x[q +1]\n        ex[tmp + 1] = x[q +2]\n    return(ex)\n            \n    \ndef main():\n    from builtins import input, int\n    N = 3**int(input())\n    T = input()\n    l = list(range(N))\n    p = [\"\"]*(N)\n    \n    for i in range(len(T)):\n        if T[i] == \"R\":\n            l = R(l)\n        else:\n            l = S(l, N)\n    for i in range(N):\n        p[l[i]] = i\n    \n    for i in range(N):\n        print(p[i], end=\" \")\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "def rev(a):\n    L = []\n    for i in range(N):\n        L.append(a % 3)\n        a //= 3\n    return int(\"\".join(map(str, L)), 3)\n    \ndef salsa():\n    lazy[0] *= -1\n\ndef rumba():\n    i = 0\n    for k in range(N):\n        if lazy[i] < 0:\n            lazy[3*i+1] *= -1\n            lazy[3*i+2] *= -1\n            lazy[3*i+3] *= -1\n            lazy[i] = 1\n            value[3*i+1] ^= 3\n            value[3*i+2] ^= 3\n            value[3*i+3] ^= 3\n        value[3*i+1] += 1\n        value[3*i+2] += 1\n        value[3*i+3] += 1\n        value[3*i+1] %= 3\n        value[3*i+2] %= 3\n        value[3*i+3] %= 3\n        i = 3 * i + (1 if value[3*i+1] == 0 else 2 if value[3*i+2] == 0 else 3)\n\ndef calcall():\n    a = 1\n    i = 0\n    for k in range(1, N + 1):\n        for _ in range(3 ** k):\n            i += 1\n            if lazy[(i-1)//3] < 0:\n                lazy[i] *= -1\n                if value[i]: value[i] ^= 3\n            value[i] = value[i] * a + value[(i-1) // 3]\n        a *= 3\n        \nN = int(input())\nNN = 3 ** (N + 1) // 2\nvalue = [(i-1) % 3 if i else 0 for i in range(NN)]\nlazy = [1 for i in range(NN)]\n\nfor t in input():\n    if t == \"R\":\n        rumba()\n    else:\n        salsa()\n\ncalcall()\n\nANS = [0] * (3 ** N)\nfor i in range(3 ** N):\n    ANS[rev(i)] = value[i + (NN - 1) // 3]\n\nprint(*ANS)"
  },
  {
    "language": "Python",
    "code": "\ndef Salsa(N_Pow):\n    Dest = [0] * 3**(N_Pow)\n    Dest[0] = 0\n    Dest[1] = 2\n    Dest[2] = 1\n\n    for Pow in range(1, N_Pow):\n        Value_Min = 3**Pow\n        Value_Max = 3**Pow *2-1\n        for Num in range(Value_Min, Value_Max+1, 1):\n            Value2 = Dest[Num-Value_Min] + 2 * Value_Min\n            Dest[Num] = Value2\n            Dest[Value2] = Num\n    return Dest\n\ndef Lumba(N_Pow):\n\n    Len = 3**(N_Pow)\n    Dest = [0] * Len\n    for Num in range(Len):\n        Dest[Num] = Num+1\n    Dest[Len-1] = 0\n    return Dest\n\ndef move(Dest_Salsa, PosList, Is_Salsa):\n    N = len(PosList)\n    if(Is_Salsa == True):\n        for Num in range(N):\n            PosList[Num] = Dest_Salsa[ PosList[Num] ]\n    else:\n        for Num in range(N):\n            PosList[Num] = (PosList[Num]+1) % N\n\ndef moves(N_Pow, PosList, Str):\n    MoveTimes = len(Str)\n\n    # Dest_Lumba = Lumba(N_Pow)\n    Dest_Salsa = Salsa(N_Pow)\n    for k in range(MoveTimes):\n        if(Str[k] == 'S'):\n            move(Dest_Salsa, PosList, True)\n        else:\n            move(Dest_Salsa, PosList, False)\n    Str = \"\"\n    for Num in range( len(PosList) ):\n        Str = Str + str(PosList[Num]) + \" \"\n    print(Str)\n\nif(__name__ == \"__main__\"):\n    N_Pow = int( input().strip() )\n    T = input().strip()\n\n\n    Len = 3**(N_Pow)\n    PosList = []\n    for Num in range(Len):\n        PosList.append(Num)\n    moves(N_Pow, PosList, T)\n"
  },
  {
    "language": "Python",
    "code": "# AGC044 C\nimport itertools\nimport numpy as np\n\ndef Base_10_to_n(X, n):\n    if (int(X/n)):\n        return Base_10_to_n(int(X/n), n)+str(X%n)\n    return str(X%n)\n\ndef mapping(_list):\n    return np.array([m_list[i] for i in _list])\n\nn = int(input())\nt_list = list(input())\na_list = [int(i) for i in range(3**n)]\na_list_np = np.array(a_list)\n\n_list = [Base_10_to_n(i, 3) for i in range(3**n)]\n_list = [x.replace(\"1\",\"4\") for x in _list]\n_list = [x.replace(\"2\",\"1\") for x in _list]\n_list = [x.replace(\"4\",\"2\") for x in _list]\nm_list = [int(x, 3) for x in _list]\n\ngr = itertools.groupby(t_list)\nfor key,value in gr:\n    if key == \"S\":\n        if len(list(value))%2 == 0:\n            continue\n        else:\n            a_list_np = mapping(a_list_np)\n    else:\n        for j in range(len(list(value))):\n            a_list_np = (a_list_np+1)%(3**n)\n\nprint(*a_list_np)"
  },
  {
    "language": "Python",
    "code": "def base10to(n):\n    b = 3\n    if int(n/b):\n        return base10to(int(n/b)) + str(n%b)\n    return str(n%b)\ndef salsa(base3):\n    x = 0\n    l = len(base3)\n    for i, s in enumerate(base3):\n        if s == '1':\n            x += 2* pow(3, (l-1-i))\n        elif s == '2':\n            x += pow(3, (l-1-i))\n    return x\n\nN = int(input())\nT = list(input())\nM = pow(3, N)\n\ns_list = [salsa(base10to(i)) for i in range(M)]\nans = [i for i in range(M)]\n# rumba_count = 0\nfor x in T:\n    if x == 'S':\n        for i in range(M):\n            # ans[i] = s_list[(ans[i]+rumba_count)% M]\n            ans[i] = s_list[ans[i]]\n    else:\n        # rumba_count += 1\n        for i in range(M):\n            ans[i] += 1\n            if ans[i] == M:\n                ans[i] = 0\nprint(*ans)"
  },
  {
    "language": "Python",
    "code": "num = int(input())\nRS = list(input())\n#print(num)\ndef calc_plus(n):\n    if n == len_dance-1:\n        x = 0\n    else:\n        x = n +1\n    return x\n    #return n + 1\n\ndance_human = list(range(3 ** num))\n#print(dance_human)\nlen_dance = int(len(dance_human))\n\nfor w in range(len(RS)):\n    if w < (len(RS)-1) and RS[w] == 'S' and RS[w+1] == 'S':\n        RS[w+1] = 'X'\n        continue\n    if RS[w] == 'S':\n        data_list = [0] * len_dance\n        for i in range(len_dance):\n            target_num = dance_human[i]\n            save_num = []\n            while target_num >0:\n                out = int(target_num%3)\n                if out == 2:\n                    out = 1\n                elif out == 1:\n                    out = 2\n                save_num.append(out)\n                target_num = int(target_num/3)\n            #print(save_num)\n            A = 0\n            for h in range(len(save_num)):\n                A = A + save_num[h] * (3 ** h)\n            #print(A)\n            data_list[i] = A\n            #print(list)\n    elif RS[w] == 'R':\n        data_list = list(map(calc_plus, dance_human))\n        #print(data_list)\n        #list = []\n        #for i in range(len_dance):   \n        #    list.append(dance_human[i]+1)\n        #    if list[i] == len_dance:\n        #        list[i] = 0\n    else:\n        continue\n    dance_human = data_list\n    #print(dance_human)\nfor s in dance_human:\n  print(s , end =\" \")"
  },
  {
    "language": "Python",
    "code": "def R(x):\n    x.insert(0, x.pop(-1))\n    return x\n    \ndef S(x, n):\n    ex = [0]*n\n    for j in range(len(x)//3):\n        \n        k = j\n        tmp = 0\n        m = 3\n        q = j*3\n        while k > 0:\n            if k%3 == 1:\n                tmp = tmp + 2*m\n            elif k%3 == 2:\n                tmp = tmp + 1*m\n            k = k//3\n            m = m*3\n        ex[tmp] = x[q]\n        ex[tmp + 2] = x[q +1]\n        ex[tmp + 1] = x[q +2]\n    return(ex)\n            \n    \ndef main():\n    N = 3**int(input())\n    T = input()\n    l = list(range(N))\n    p = [0]*(N)\n    \n    for i in range(len(T)):\n        if T[i] == \"R\":\n            l = R(l)\n        else:\n            l = S(l, N)\n    for i in range(N):\n        p[l[i]] = i\n    \n    for i in range(N):\n        print(p[i], end=\" \")\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\n\ndef P_change(N, P):\n    #Salsa\n    for i in range(N):\n        start = 3 ** i\n        step = 3 ** (i + 1)\n        dp = 3 ** i\n        for j in range(start, 3 ** N, step):\n            P[j:j + dp], P[j + dp:j + dp * 2] = P[j + dp:j + dp * 2], P[j:j + dp]\n    \n    return P\n\n\ndef P_slide(P):\n    #Rumba\n    temp = P[-1]\n    P[1:] = P[:-1]\n    P[0] = temp\n\n    return P\n\n\nN = int(input())\nT = input()\n\nP = list(range(3**N))\nT = T.replace('SS', 's')\n\nfor Ti in T:\n    if Ti == 'S':\n        #Salsa\n        P = P_change(N, P)\n    elif Ti == 'R':\n        #Rumba\n        P = P_slide(P)\n\nprint(' '.join([str(P.index(i)) for i in range(len(P))]))\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\nN = int(input())\nT = input()\n\n#サルサの２回連続は元に戻る\nT = T.replace('SS', '')\n#D = [True if Ti == 'S' else False for Ti in T]\nD = [1 if Ti == 'S' else 0 for Ti in T]\n\nN3 = 3 ** N\nP = [0] * N3\nPd = dict()\n\nfor Pos in range(N3):\n    Pi = Pos\n    for Dn in D:\n        if Dn:\n            #Salsa\n            Ps = Pi\n            if Ps in Pd:\n                Pi = Pd[Ps]\n            else:\n                Pos1 = 0\n                Pos2 = Pi\n                for Ni in range(N, 0, -1):\n                    Ni3 = 3 ** (Ni - 1)\n\n                    div, Pos2 = divmod(Pos2, Ni3)\n\n                    if div == 1:\n                        Pos1 += Ni3 * 2\n                    elif div == 2:\n                        Pos1 += Ni3\n                    else:\n                        Pos1 += 0\n\n                    if Pos2 == 0:\n                        break\n\n                Pi = Pos1 + Pos2\n\n                Pd[Ps] = Pi\n        else:\n            #Rumba\n            Pi += 1\n            if Pi == N3:\n                Pi = 0\n\n    P[Pos] = Pi\n\n    \nprint(*P)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "num=int(input())\njudge=list(input())\n\ndef Base_10_to_n(X, n):\n    X_dumy = X\n    out = ''\n    while X_dumy>0:\n        out = str(X_dumy%n)+out\n        X_dumy = int(X_dumy/n)\n    return out\n\npos=[0]*3**num\n\nfor p in pos:\n  x10=p\n  x3=Base_10_to_n(x10, 3)\n  pos[p]=x3\n  "
  },
  {
    "language": "Python",
    "code": "import numpy as np\ndef main():\n  n=int(input())\n  huhan=np.empty(3**n, np.int32)\n  a=(0,2,1)\n  l0=0\n  l1=0\n  l2=0\n  l3=0\n  l4=0\n  l5=0\n  l6=0\n  l7=0\n  l8=0\n  l9=0\n  l10=0\n  l11=0\n  b=(3,9,27,81,243,729,2187,6561,19683,59049,177147)\n  for i in range(3**n):\n    if l0==3:\n      l1+=1\n      l0=0\n      if l1==3:\n        l2+=1\n        l1=0\n        if l2==3:\n          l3+=1\n          l2=0\n          if l3==3:\n            l4+=1\n            l3=0\n            if l4==3:\n              l5+=1\n              l4=0\n              if l5==3:\n                l6+=1\n                l5=0\n                if l6==3:\n                  l7+=1\n                  l6=0\n                  if l7==3:\n                    l8+=1\n                    l7=0\n                    if l8==3:\n                      l9+=1\n                      l8=0\n                      if l9==3:\n                        l10+=1\n                        l9=0\n                        if l10==3:\n                          l11+=1\n                          l10=0\n    huhan[i]=a[l0]+a[l1]*b[0]+a[l2]*b[1]+a[l3]*b[2]+a[l4]*b[3]+a[l5]*b[4]+a[l6]*b[5]+a[l7]*b[6]+a[l8]*b[7]+a[l9]*b[8]+a[l10]*b[9]+a[l11]*b[10]\n    l0+=1\n  #print(huhan)\n  n3=3**n\n  p= np.arange(3**n)\n  #t=input()\n  t= [1 if s == 'R' else 0 for s in input().replace(\"SS\",\"\")]\n  snum=False\n  lnb=0\n  for sr in t:\n    if sr:\n      lnb +=1\n    else:\n      p += lnb\n      p %= n3\n      for x in range(3**n):\n        p[x]=huhan[p[x]]\n        lnb=0\n  if lnb>0:\n    p += lnb\n    p %= n3\n  print(\" \".join(map(str,p)))\nmain()"
  },
  {
    "language": "Python",
    "code": "import numpy\n\nn=int(input())\nstrs=input()\n\nar=numpy.arange(3**n,dtype=\">i4\")\nfor i in range(len(strs)):\n  tmp=ar+0\n  if strs[i]==\"R\":\n    ar[0]=tmp[len(ar)-1]\n    for j in range(1,len(ar)):\n      ar[j]=tmp[j-1]\n  else:\n    for j in range(len(ar)):\n      tmpj=j\n      nums=\"\"\n      for k in range(n):\n        nums=nums+str(tmpj%3)\n        tmpj=tmpj//3\n      nums=nums.replace(\"1\",\"a\")\n      nums=nums.replace(\"2\",\"b\")\n      nums=nums.replace(\"a\",\"2\")\n      nums=nums.replace(\"b\",\"1\")\n      numl=list(nums)\n      new=0\n      for l in range(len(numl)):\n        new+=int(numl[l])*(3**l)\n      ar[j]=tmp[new]\nfor i in ar:\n  print(i,end=\" \")\nprint()"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\n\ndef P_change(N, Pos):\n    #Salsa\n    Pos1 = 0\n    for Ni in range(N, 0, -1):\n        Ni3 = 3 ** (Ni - 1)\n\n        div, Pos = divmod(Pos, Ni3)\n\n        if div == 1:\n            Pos1 += Ni3 * 2\n        elif div == 2:\n            Pos1 += Ni3\n        else:\n            Pos1 += 0\n\n        if Pos == 0:\n            break\n\n    return Pos1 + Pos\n\n\ndef dance(N, T):\n    #サルサの２回連続は元に戻る\n    #T = T.replace('SS', '')\n    #D = [True if Ti == 'S' else False for Ti in T]\n    D = [1 if Ti == 'S' else 0 for Ti in T]\n\n    N3 = 3 ** N\n    P = [0] * N3\n    Pd = dict()\n\n    for Pos in range(N3):\n        Pi = Pos\n        for Dn in D:\n            if Dn:\n                #Salsa\n                Ps = Pi\n                if Ps in Pd:\n                    Pi = Pd[Ps]\n                else:\n                    Pi = P_change(N, Pi)\n                    Pd[Ps] = Pi\n            else:\n                #Rumba\n                Pi += 1\n                if Pi == N3:\n                    Pi = 0\n\n        P[Pos] = Pi\n\n    return  P\n    \n\nN = int(input())\nT = input()\n\nP = dance(N, T)\n\nprint(*P)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\ndef main():\n  n=int(input())\n  huhan=np.empty(3**n, np.int32)\n  a=[0,2,1]\n  for i in range(3**n):\n    b=[]\n    h=0\n    z=i\n    while True:\n      s=z//3\n      y=z%3\n      b=b+[a[y]]\n      if s==0:\n        break\n      z=s\n    for j in range(len(b)-1,-1,-1):\n      h=h*3+b[j]\n    huhan[i]=h\n  n3=3**n\n  p= np.arange(3**n)\n  t=input()\n  t=t.replace(\"SS\",\"\")\n  snum=False\n  for sr in t:\n    if sr==\"R\":\n      p += 1\n      p %= n3\n    else:\n      loop=0\n      for x in range(3**n):\n        if loop ==3:\n          loop=0\n          continue\n        p[x]=huhan[p[x]]\n  print(\" \".join(p.astype(str)))\nmain()"
  },
  {
    "language": "Python",
    "code": "t=int(input())\nn=input()\nprint(1)"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nhuhan=[0]*(3**n)\na=[\"0\",\"2\",\"1\"]\nfor i in range(3**n):\n  b=[]\n  p=i\n  while True:\n    s=p//3\n    y=p%3\n    b=b+[a[y]]\n    if s==0:\n      break\n    p=s\n  b.reverse()\n  huhan[i]=int(\"\".join(b),3)\n\nn3=3**n\ndef main():\n  p=[i for i in range(3**n)]\n  #print(p)\n  t=input()\n  for sr in t:\n    p=list(map(lambda x: result(x,sr),p))\n  print(\" \".join(map(str,p)))\n    \ndef result(p,sr):\n  if sr==\"S\":\n    return(huhan[p])\n  else:\n    p=(p+1) % n3\n  return p\n   \n    \n    \nmain()"
  },
  {
    "language": "Python",
    "code": "def Base_10_to_n(X):\n    if (int(X/3)):\n        return Base_10_to_n(int(X/3))+str(X%3)\n    return str(X%3)\ndef change(t):\n  return int(t,3)\nn=int(input())\nL =list(range(3**n))\nT=input()\nc=len(T)\nT=T.replace(\"SS\",\"\")\nfor i in T:\n  if i==\"R\":\n    L=list(map(lambda x: (x+1)%(3**n),L))\n  elif i==\"S\":\n    K=list(map(Base_10_to_n,L))\n    A=\"/\".join(map(str,K))\n    A=A.replace(\"1\",\"#\")\n    A=A.replace(\"2\",\"1\")\n    A=A.replace(\"#\",\"2\")\n    K=A.split(\"/\")\n    L=list(map(change,K))\n    L=list(map(int,L))\nprint(\" \".join(map(str,L)))"
  },
  {
    "language": "Python",
    "code": "def int10_to_n(X, n):\n    if (int(X/n)):\n        return int10_to_n(int(X/n), n)+str(X%n)\n    return str(X%n)\n\ndef split(word): \n    return [char for char in word]  \n\nn = int(input())\narr = []\nfor i in range(0, 3**n):\n    arr.append(i)\nt = input()\nresult = [0] * (3**n)\nfor c in t:\n    next_arr = [0] * (3**n)\n    ordered = []\n    if c == \"S\":\n        next_arr[0] = arr[0]\n        for ind in range(1, len(arr)):\n            if ind in ordered:\n                continue\n            ind3 = [3 if x == \"1\" else int(x) for x in int10_to_n(ind, 3)]\n            ind3 = [0 if x == 0 else x-1 for x in ind3]\n            target = int(''.join(str(x) for x in ind3), 3)\n            next_arr[target] = arr[ind]\n            next_arr[ind] = arr[target]\n            ordered.append(target)\n    elif c == \"R\":\n        tmp = arr.pop()\n        next_arr = [tmp] + arr\n    arr = next_arr\nfor i in range(0, len(arr)):\n    result[arr[i]] = i\n\nprint(*result)\n"
  },
  {
    "language": "Python",
    "code": "def salsa(X):\n    if X%3 == 1:\n        a = 2\n    elif X%3 == 2:\n        a = 1\n    else:\n        a = 0\n    if (int(X/3)):\n        return salsa(int(X/3))+str(a)\n    return str(a)\n\ndef Base_3_to_10(X):\n    out = 0\n    for i in range(1,len(str(X))+1):\n        out += int(X[-i])*(3**(i-1))\n    return out\n\nn = int(input())\nt = input()\np = []\nfor i in range(3 ** n):\n    p.append(i)\n\nfor ti in t:\n    if ti == 'S':\n        for i in range(3 ** n):\n            p[i] = Base_3_to_10(salsa(p[i]))\n    else:\n        for i in range(3 ** n):\n            p[i] = (p[i] + 1) % (3 ** n) \nprint(*p, sep=' ')"
  },
  {
    "language": "Python",
    "code": "def nextPosition(nums):\n    myList=[]\n    while nums>0:\n        if nums%3==0:\n            myList.append(0)\n        else:\n            myList.append(nums%3==1 and 2 or 1)\n        nums = nums//3\n    result = 0\n\n    for j in range(0, len(myList)):\n        result = result + myList[j] * pow(3, j)\n    return result\n\n\nif __name__==\"__main__\":\n\n    #780123456\n    #105762438\n\n    n = int(input())\n    T = input()\n\n    length = int(pow(3, n))\n\n    lastSequence = []\n    nextSequence = []\n\n    for i in range(0, length):\n        lastSequence.append(i)\n        nextSequence.append(0)\n\n    # 解码\n\n    for i in range(0,len(T)):\n        if T[i] == \"R\":\n            m = lastSequence[length-1]\n            lastSequence=lastSequence[0:length-1]\n            lastSequence.insert(0, m)\n        elif T[i] == 'S':\n            for j in range(0, length):\n                nextSequence[nextPosition(j)]=lastSequence[j]\n            lastSequence = nextSequence[0:length]\n\n    print(\" \".join(lastSequence))\n"
  },
  {
    "language": "Python",
    "code": "def base3(n):\n    k=3\n    bi=''\n    while n!=0:\n        bi+=str(n%abs(k))\n        if k<0:n=-(-n//k)\n        else:n=n//k\n    return bi\n\nif __name__ == '__main__':\n    N = int(input())\n    T = list(input())\n    n_list = [i for i in range(3**N)]\n    for t in T:\n        if t is 'S':\n            for i, n in enumerate(n_list):\n                if n==0:\n            \t    n_list[i] = 0\n                else:\n                    n_list[i] = int(str(base3(n)).translate(str.maketrans({'1':'2', '2':'1'})))\n\n        elif t is 'R':\n            n_list = [i+1 for i in n_list]\n            n_list[n_list.index(3**N)] = 0\n\n    print(' '.join(map(str,n_list)))\n\t"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\nimport numpy as np\n\nN = int(input())\nT = input()\n\nP = np.arange(3**N)\n\n\ndef P_change(N, P):\n    #Salsa\n    for i in range(N):\n        dp = 3 ** i\n        for j in range(3 ** i, 3 ** N, 3 ** (i + 1)):\n            P[j:j + dp], P[j + dp:j + dp * 2] = P[j + dp:j + dp * 2].copy(), P[j:j + dp].copy()\n    \n    return P\n\n\ndef P_slide(P):\n    #Rumba\n    temp = P[-1]\n    P[1:] = P[:-1]\n    P[0] = temp\n\n    return P\n\n\nT = T.replace('SS', 's')\n\nfor Ti in T:\n    if Ti == 'S':\n        #Salsa\n        P = P_change(N, P)\n    elif Ti == 'R':\n        #Rumba\n        P = P_slide(P)\n\nP = P.tolist()\nprint(' '.join([str(P.index(i)) for i in range(len(P))]))\n"
  },
  {
    "language": "Python",
    "code": "def Base_10_to_n(X):\n    if (int(X/3)):\n        return Base_10_to_n(int(X/3))+str(X%3)\n    return str(X%3)\ndef plus(t):\n  return (t+1)%(3**n)\ndef change(t):\n  return int(t,3)\nn=int(input())\nL=list(range(3**n))\nT=input()\nc=len(T)\nfor i in range(c):\n  if T[i]==\"R\":\n    L=list(map(plus,L))\n  elif T[i]==\"S\":\n    K=list(map(Base_10_to_n,L))\n    A=\"/\".join(map(str,K))\n    A=A.replace(\"1\",\"#\")\n    A=A.replace(\"2\",\"1\")\n    A=A.replace(\"#\",\"2\")\n    K=A.split(\"/\")\n    L=list(map(change,K))\n    L=list(map(int,L))\nprint(\" \".join(map(str,L)))"
  },
  {
    "language": "Python",
    "code": "import sys\n\ndef R(x):\n    x.insert(0, x.pop(-1))\n    return x\n    \ndef S(x, n):\n    ex = [\"\"]*n\n    for j in range(len(x)//3):\n        \n        k = j\n        tmp = 0\n        m = 3\n        q = j*3\n        while k > 0:\n            if k%3 == 1:\n                tmp = tmp + 2*m\n            elif k%3 == 2:\n                tmp = tmp + 1*m\n            k = k//3\n            m = m*3\n        ex[tmp] = x[q]\n        ex[tmp + 2] = x[q +1]\n        ex[tmp + 1] = x[q +2]\n    return(ex)\n            \n    \ndef main():\n    N = 3**int(input())\n    T = input()\n    l = list(range(N))\n    p = [\"\"]*(N)\n    \n    for i in range(len(T)):\n        if T[i] == \"R\":\n            l = R(l)\n        else:\n            l = S(l, N)\n    for i in range(N):\n        p[l[i]] = i\n    \n    for i in range(N):\n        print(p[i], end=\" \")\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\ndef Base_10_to_n(X, n):\n    X_dumy = X\n    out = ''\n    while X_dumy>0:\n        out = str(X_dumy%n)+out\n        X_dumy = int(X_dumy/n)\n    if out == '':\n        out = '0'\n    return out\n\ndef sarusa(n):\n    n = Base_10_to_n(n, 3)\n    n = n.replace('1', '3')\n    n = n.replace('2', '1')\n    n = n.replace('3', '2')\n    n = int(n, 3)\n    return n\n\ndef main():\n    N = int(readline())\n    T = readline().strip().decode()\n    ans = [i for i in range(3**N)]\n    for t in T:\n        for i in range(3**N):\n            if t == 'S':\n                ans[i] = sarusa(ans[i])\n            elif ans[i] == 3**N-1:\n                ans[i] = 0\n            else:\n                ans[i] += 1\n\n    print(' '.join(list(map(str, ans))))\n    return\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "input()\nprint(1)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nt = input()\nl = len(t)\n\n\ndef Base_10_to_3(x):\n    if (int(x/3)):\n        return Base_10_to_3(int(x/3)) + str(x % 3)\n    return str(x % 3)\n\n\ndef Base_3_to_10(x):\n    out = 0\n    for i in range(1, len(str(x))+1):\n        out += int(x[-i])*(3**(i-1))\n    return out\n\n\ndef convert(x):\n    l = len(x)\n    s = [''] * l\n    for i in range(l):\n        target = int(x[i])\n        if (x[i] != '0'):\n            s[i] = str(3 - target)\n        else:\n            s[i] = '0'\n    return ''.join(s)\n\n\ndef sa(x):\n    x = Base_10_to_3(x)\n    x = convert(x)\n    x = Base_3_to_10(x)\n    return x\n\n\ndef ru(x):\n    return((x + 1) % (3 ** n))\n\n\nPs = [0] * (3 ** n)\nfor i in range(3 ** n):\n    Ps[i] = i\nfor i in range(l):\n    for j in range(3 ** n):\n        if (t[i] == 'S'):\n            Ps[j] = (sa(Ps[j]))\n        else:\n            Ps[j] = (ru(Ps[j]))\n\nprint(' '.join(map(str, Ps)))"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\n\ndef P_change(N, P):\n    #Salsa\n    for i in range(N):\n        start = 3 ** i\n        stop = 3 ** N\n        step = 3 ** (i + 1)\n        dp = 3 ** i\n        for j in range(start, stop, step):\n            P[j:j + dp], P[j + dp:j + dp * 2] = P[j + dp:j + dp * 2], P[j:j + dp]\n\n    return P\n\n\ndef P_slide(P):\n    #Rumba\n    temp = P[-1]\n    P[1:] = P[:-1]\n    P[0] = temp\n\n    return P\n\n\ndef dance(N, T):\n#サルサの２回連続は元に戻る\n    T = T.replace('SS', '')\n    D = [1 if Ti == 'S' else 0 for Ti in T]\n\n    N3 = 3 ** N\n    P = list(range(N3))\n\n    for Dn in D:\n        if Dn:\n            #Salsa\n            P = P_change(N, P)\n        else:\n            #Rumba\n            P = P_slide(P)\n\n    R = [0] * N3\n    for i in range(N3):\n        R[P[i]] = i\n\n    return  R\n    \n\nN = int(input())\nT = input()\n\nR = dance(N, T)\n\nprint(*R)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\ndef Base10_3(X):\n    if (int(X/3)):\n        return Base10_3(int(X/3))+str(X%3)\n    return str(X%3)\n\ndef Base3_10(X):\n    out = 0\n    for i in range(1,len(X)+1):\n        out += int(X[-i])*(3**(i-1))\n    return out\n    \ndef f(x):\n    x3 = list(str(Base10_3(x)))\n    for i in range(len(x3)):\n        if x3[i] == '1':\n            x3[i] = '2'\n        elif x3[i] == '2':\n            x3[i] = '1'\n    new_x3 = ''.join(x3)\n    return Base3_10(new_x3)\n\nN = int(input())\nN_list = list(np.arange(3**N))\n\nT = list(input())\nT_now = T[0]\nL = []\nfor i in range(len(T)-1):\n    if T[i] == T[i+1]:\n        T_now += T[i+1]\n    else:\n        L += [T_now]\n        T_now = T[i+1]\nL += [T_now]        \nfor i in range(len(L)):\n    if L[i][0] == 'S':\n        if len(L[i])%2 == 0:\n            L[i] = ''\n        else:\n            L[i] = 'S'\n    else:\n        L[i] = str(len(L[i]))\nT = ''.join(L)\n\nRS_now = T[0]\nfor i in range(len(T)):\n    if T[i] == 'S':\n        N_list = [f(i) for i in N_list]\n    else:\n        N_list = [(j+int(T[i]))%(3**N) for j in N_list]\n\nfor i in range(3**N):\n    print(N_list[i], end=\" \")"
  },
  {
    "language": "Python",
    "code": "# C\nn = int(input())\nt = input()\n\nl = []\ndef Base_10_to_n(X, n):\n    if (int(X/n)):\n        return Base_10_to_n(int(X/n), n)+str(X%n)\n    return str(X%n)\n\ndef Base_n_to_10(X,n):\n    out = 0\n    for i in range(1,len(str(X))+1):\n        out += int(X[-i])*(n**(i-1))\n    return out#int out\n\n\nans = []\nfor i in range(3**n):\n    v = Base_10_to_n(i, 3)\n    v = list(v)\n    if len(v) != n:\n        for _ in range(n-len(v)):\n            v.insert(0, '0')\n    for i in t:\n        if i == 'S':\n            for j in range(len(v)):\n                if v[j] == '1':\n                    v[j] = '2'\n                elif v[j]=='2':\n                    v[j] = '1'\n        else:\n            j = 1\n            while j != n+1:\n                if v[-j] =='0' or v[-j] =='1':\n                    v[-j]  = str(int(v[-j]) +1)\n                    break\n                else:\n                    v[-j] = '0'\n                    j += 1\n    ans.append(Base_n_to_10(\"\".join(v),3))\n\nans=[str(a) for a in ans]\nans=\" \".join(ans)\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "inputNum = int(input())\ninput()\n\nif inputNum == 1:\n    print(\"2 0 1\")\nelif inputNum == 2:\n    print(\"3 8 1 0 5 7 6 2 4\")\nelif inputNum == 3:\n    print(\"23 9 22 8 3 7 20 24 19 5 18 4 17 12 16 2 6 1 14 0 13 26 21 25 11 15 10\")\nelse:\n    for i in range(0,(3 ** inputNum)-1):\n        print(i, end=\" \")\n    print((3**inputNum)-1)\n    "
  },
  {
    "language": "Python",
    "code": "import sys\nimport time\n\nt1 = time.time()\n\n# 実行環境(0:vscode, 1:atcoder)\nMODE = 1\n\n# 入力の次元\nDIMENSION = 2\n\n# int型に変換\nINT_TYPE = 0\n\nif not (MODE):\n    with open(\"input.txt\", \"r\") as f:\n        s = f.read()\nelse:\n    s = sys.stdin.read()\n\nif DIMENSION == 1:\n    if INT_TYPE == 1:\n        s = int(s)\nelif DIMENSION == 2:\n    if INT_TYPE == 0:\n        s = s.split()\n    elif INT_TYPE == 1:\n        s = [int(x) for x in s.split()]\nelif DIMENSION == 3:\n    if INT_TYPE == 0:\n        s = [x.split() for x in s.splitlines()]\n    elif INT_TYPE == 1:\n        s = [[int(y) for y in x.split()] for x in s.splitlines()]\n\n\ndef base10to(n, b):\n    if (int(n/b)):\n        return base10to(int(n/b), b) + str(n % b)\n    return str(n % b)\n\ndef main():\n    N = int(s[0])\n    T = s[1]\n    NUM = 3 ** N\n    P = list(range(NUM))\n\n    for t in T:\n        if t == \"S\":\n            for j, p in enumerate(P):\n                p_3 = [None] * N\n                p_3_mod = p\n                for i in range(N):\n                    p_3[i] = p_3_mod // 3 ** (N-i-1)\n                    p_3_mod = p_3_mod % 3 ** (N-i-1)\n                    if p_3[i] == 1:\n                        p_3[i] = 2\n                    elif p_3[i] == 2:\n                        p_3[i] = 1\n                p_new = 0\n                for i in range(N):\n                    p_new += 3 ** i * p_3[N - i - 1]\n                P[j] = p_new\n        else:\n            for i in range(NUM):\n                P[i] += 1\n                if P[i] == NUM:\n                    P[i] = 0\n\n    text = \"\"\n    for p in P:\n        text += str(p) + \" \"\n    print(text)\n\n    t2 = time.time()\n    print(t2-t1)\n\nmain()"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\nimport numpy as np\n\n\ndef P_change(N, P):\n    #Salsa\n    for i in range(N):\n        start = 3 ** i\n        stop = 3 ** N\n        step = 3 ** (i + 1)\n        dp = 3 ** i\n        for j in range(start, stop, step):\n            P[j:j + dp], P[j + dp:j + dp * 2] = P[j + dp:j + dp * 2].copy(), P[j:j + dp].copy()\n    \n    return P\n\n\ndef P_slide(P):\n    #Rumba\n    temp = P[-1]\n    P[1:] = P[:-1]\n    P[0] = temp\n\n    return P\n\n\ndef dance(N, D, P):\n    for Dn in D:\n        if Dn:\n            #Salsa\n            P = P_change(N, P)\n        else:\n            #Rumba\n            P = P_slide(P)\n\n    N3 = 3 ** N\n    R = np.zeros(N3, dtype=np.int64)\n    for i in range(N3):\n        R[P[i]] = i\n\n    return  R\n\n\nN = int(input())\nT = input()\n\nN3 = 3 ** N\nP = np.arange(N3, dtype=np.int64)\n#サルサの２回連続は元に戻る\nT = T.replace('SS', '')\nD = [1 if Ti == 'S' else 0 for Ti in T]\n\nR = dance(N, D, P)\n\nprint(*R)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\n\ndef P_change(N, P):\n    #Salsa\n    for i in range(N):\n        start = 3 ** i\n        stop = 3 ** N\n        step = 3 ** (i + 1)\n        dp = 3 ** i\n        for j in range(start, stop, step):\n            P[j:j + dp], P[j + dp:j + dp * 2] = P[j + dp:j + dp * 2], P[j:j + dp]\n\n    return P\n\n\ndef P_slide(P):\n    #Rumba\n    temp = P[-1]\n    P[1:] = P[:-1]\n    P[0] = temp\n\n    return P\n\n\ndef dance(N, D):\n    N3 = 3 ** N\n    P = list(range(N3))\n\n    for Dn in D:\n        if Dn:\n            #Salsa\n            P = P_change(N, P)\n        else:\n            #Rumba\n            P = P_slide(P)\n\n    R = [0] * N3\n    for i in range(N3):\n        R[P[i]] = i\n\n    return  R\n    \n\nN = int(input())\nT = input()\n\n#サルサの２回連続は元に戻る\nT = T.replace('SS', '')\nD = [1 if Ti == 'S' else 0 for Ti in T]\n\nR = dance(N, D)\n\nprint(*R)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\nreadline = sys.stdin.readline\n\nN = int(readline())\nT = readline().strip()\n\n#サルサの２回連続は元に戻る\nT = T.replace('SS', '')\nTlen = len(T)\nD = [None] * Tlen\nRc = 0\np = 0\nfor i in range(Tlen):\n    if T[i] == 'S':\n        if Rc:\n            #Rumba\n            D[p] = Rc\n            Rc = 0\n            p += 1\n\n        #Salsa\n        D[p] = 0\n        p += 1\n    else:\n        #Rumba\n        Rc += 1\n\nif Rc:\n    #Rumba\n    D[p] = Rc\n    Rc = 0\n    p += 1\n\nD = D[:p]\nD = tuple(D)\n\nN3 = 3 ** N\nP = [0] * N3\nSd = dict()\n\nfor Pos in range(N3):\n    Pi = Pos\n    Rc = 0\n    for Dn in D:\n        if Dn:\n            #Rumba\n            Pi = (Pi + Dn) % N3\n\n        else:\n            #Salsa\n            Ps = Pi\n            if Ps in Sd:\n                Pi = Sd[Ps]\n            else:\n                Pos1 = 0\n                Pos2 = Pi\n                for Ni in range(N, 0, -1):\n                    Ni3 = 3 ** (Ni - 1)\n\n                    div, Pos2 = divmod(Pos2, Ni3)\n\n                    if div == 1:\n                        Pos1 += Ni3 * 2\n                    elif div == 2:\n                        Pos1 += Ni3\n                    else:\n                        Pos1 += 0\n\n                    if Pos2 == 0:\n                        break\n\n                Pi = Pos1 + Pos2\n\n                Sd[Ps] = Pi\n\n    P[Pos] = Pi\n\n    \nprint(*P)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "out=''\nN=3**int(input())\nx=0\nposlist=list(range(N))\nP=input()\nfor j in range(len(P)):\n    for i in range(N):\n        if P[j]=='S':\n            n=0\n            while poslist[i]!=0:\n                if poslist[i]%3==1:\n                    x+=2*(10**n)\n                elif poslist[i]%3==2:\n                    x+=1*(10**n)\n                poslist[i]=int(poslist[i]/3)\n                n+=1\n            else:\n                for m in range(n):\n                    poslist[i]+=int(x%10*(3**m))\n                    x=int(x/10)\n        else:\n            poslist[i]+=1\n            if poslist[i]==N:\n                poslist[i]=0\nfor o in range(N):\n    out+=str(int(poslist[o]))+' '\nprint(out)"
  },
  {
    "language": "Python",
    "code": "\nimport math\ndef Salsa(N_Pow, Len):\n    if(N_Pow==1):\n        Dest = [0] * 3\n        Dest[0] = 0\n        Dest[1] = 2\n        Dest[2] = 1\n        return Dest\n    else:\n        Dest = [0] * (Len//3)\n    Dest[0] = 0\n    Dest[1] = 2\n    Dest[2] = 1\n\n    Value_Min = 1\n    for Pow in range(1, N_Pow-1):\n        Value_Min *= 3\n        Value_Max = Value_Min *2-1\n        for Num in range(Value_Min, Value_Max+1, 1):\n            Value2 = Dest[Num-Value_Min] + 2 * Value_Min\n            Dest[Num] = Value2\n            Dest[Value2] = Num\n    return Dest\n\n\n\ndef moveSalsa(Dest_Salsa, PosList):\n    N = len(PosList)\n    N_3 = N//3\n    N_2_3 = N_3 *2\n    for Num in range(N):\n        if(PosList[Num] >= N_2_3):\n            PosList[Num] = Dest_Salsa[ PosList[Num]-N_2_3 ] + N_3\n        elif(PosList[Num] >= N_3):\n            PosList[Num] = Dest_Salsa[ PosList[Num]-N_3 ] + N_2_3\n        else:\n            PosList[Num] = Dest_Salsa[ PosList[Num] ]\n\n\ndef moves(N_Pow, PosList, Str):\n    MoveTimes = len(Str)\n    Len = len(PosList)\n\n    Dest_Salsa = Salsa(N_Pow, Len)\n    k =0\n    while(k < MoveTimes):\n        SameTimes = 0\n        if(Str[k] == 'S'):\n            k += 1\n            SameTimes += 1\n            while(k < MoveTimes and Str[k] == 'S'):\n                k += 1\n                SameTimes += 1\n            if(SameTimes%2 !=0):\n                moveSalsa(Dest_Salsa, PosList)\n        else:\n            k += 1\n            SameTimes += 1\n            while(k < MoveTimes and Str[k] == 'R'):\n                k += 1\n                SameTimes += 1\n\n            for Num in range(Len):\n                PosList[Num] = (PosList[Num]+SameTimes) % Len\n\n    Str = \"\"\n    for Num in range( Len ):\n        Str = Str + str(PosList[Num]) + \" \"\n    print(Str)\n\nif(__name__ == \"__main__\"):\n    N_Pow = int( input().strip() )\n    T = input().strip()\n\n\n    Len = 3**(N_Pow)\n    PosList = []\n    for Num in range(Len):\n        PosList.append(Num)\n    moves(N_Pow, PosList, T)\n"
  },
  {
    "language": "Python",
    "code": "def salsa(X):\n    if X%3 == 1:\n        a = 2\n    elif X%3 == 2:\n        a = 1\n    else:\n        a = 0\n    if (int(X/3)):\n        return salsa(int(X/3))+str(a)\n    return str(a)\n\ndef Base_3_to_10(X):\n    out = 0\n    for i in range(1,len(str(X))+1):\n        out += int(X[-i])*(3**(i-1))\n    return out\n\nn = int(input())\nt = input()\np = []\nfor i in range(3 ** n):\n    p.append(i)\n\nfor ti in t:\n    if ti == 'S':\n        for i in range(3 ** n):\n            p[i] = Base_3_to_10(salsa(p[i]))\n    else:\n        q = list(map(lambda x: (x + 1) % 3 ** n, p))\n        p = q\nprint(*p, sep=' ')"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\n\ndef P_change(N, Pos):\n    #Salsa\n    Pos1 = 0\n    for Ni in range(N, 0, -1):\n        Ni3 = 3 ** (Ni - 1)\n\n        div, Pos = divmod(Pos, Ni3)\n\n        if div == 1:\n            Pos1 += Ni3 * 2\n        elif div == 2:\n            Pos1 += Ni3\n        else:\n            Pos1 += 0\n\n        if Pos == 0:\n            break\n\n    return Pos1 + Pos\n\n\ndef dance(N, T):\n    #サルサの２回連続は元に戻る\n    T = T.replace('SS', '')\n    D = [True if Ti == 'S' else False for Ti in T]\n\n    N3 = 3 ** N\n    P = [0] * N3\n    Pd = dict()\n\n    for Pos in range(N3):\n        Pi = Pos\n        for Dn in D:\n            if Dn:\n                #Salsa\n                Ps = Pi\n                if Ps in Pd:\n                    Pi = Pd[Ps]\n                else:\n                    Pi = P_change(N, Pi)\n                    Pd[Ps] = Pi\n            else:\n                #Rumba\n                Pi += 1\n                if Pi == N3:\n                    Pi = 0\n\n        P[Pos] = Pi\n\n    return  P\n    \n\nN = int(input())\nT = input()\n\nP = dance(N, T)\n\nprint(*P)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "def f3(s):\n    if(int(s/3)):\n        return f3(int(s//3)) + str(s%3)\n    return str(s)\ndef change(s):\n    s=list(s)\n    for i in range(len(s)):\n        if s[i]==\"1\":\n            s[i]=\"2\"\n        elif s[i]==\"2\":\n            s[i]=\"1\"\n    return \"\".join(s)\nn = int(input())\nt = input()\nans = [i for i in range(pow(3,n))]\nfor i in range(len(t)):\n    print(*ans)\n    if t[i]==\"S\":\n        tmp = ans.copy()\n        for j in range(pow(3,n)):\n            ans[j] = int(change(f3(tmp[j])),3)\n    elif t[i]==\"R\":\n        tmp = ans.copy()\n        for j in range(pow(3,n)):\n            ans[j] = tmp[j-1]\n            #if tmp[j]==pow(3,n)-1:\n            #    ans[j] = 0\n            #else:\n            #    ans[j] = tmp[tmp[j]+1]\nprint(*ans)"
  },
  {
    "language": "Python",
    "code": "def rev(a):\n    L = []\n    for i in range(N):\n        L.append(a % 3)\n        a //= 3\n    return int(\"\".join(map(str, L)), 3)\n    \ndef salsa():\n    lazy[0] *= -1\n\ndef rumba():\n    i = 0\n    for k in range(N):\n        if lazy[i] < 0:\n            lazy[3*i+1] *= -1\n            lazy[3*i+2] *= -1\n            lazy[3*i+3] *= -1\n            lazy[i] = 1\n            value[3*i+1] ^= 3\n            value[3*i+2] ^= 3\n            value[3*i+3] ^= 3\n        value[3*i+1] += 1\n        value[3*i+2] += 1\n        value[3*i+3] += 1\n        value[3*i+1] %= 3\n        value[3*i+2] %= 3\n        value[3*i+3] %= 3\n        i = 3 * i + (1 if value[3*i+1] == 0 else 2 if value[3*i+2] == 0 else 3)\n\ndef calcall():\n    a = 1\n    i = 0\n    for k in range(1, N + 1):\n        for _ in range(3 ** k):\n            i += 1\n            if lazy[(i-1)//3] < 0:\n                lazy[i] *= -1\n                if value[i]: value[i] ^= 3\n            value[i] = value[i] * a + value[(i-1) // 3]\n        a *= 3\n        \nN = int(input())\nNN = 3 ** (N + 1) // 2\nvalue = [(i-1) % 3 if i else 0 for i in range(NN)]\nlazy = [1 for i in range(NN)]\n\nfor t in input():\n    if t == \"R\":\n        rumba()\n    else:\n        salsa()\n\ncalcall()\n\nANS = [0] * (3 ** N)\nfor i in range(3 ** N):\n    ANS[rev(i)] = value[i + (NN - 1) // 3]\n\nprint(*ANS)"
  },
  {
    "language": "Python",
    "code": "Num = [list(range(3**(i+1))) for i in range(11)]\nNum[0] = [0,2,1]\nfor i in range(1,11):\n    Num[i] = Num[i-1] + list(map(lambda x:x+2*3**(i),Num[i-1])) + list(map(lambda x:x+3**(i),Num[i-1]))\ndef Q(Num):\n    ans = 0\n    while Num > 1:\n        Num = Num // 3\n        ans += 1\n    return ans\ndef R(List):\n  num = len(List)\n  if num == 3:\n    return [List[0],List[2],List[1]]\n  else:\n    A = Q(num) - 1\n    L = [List[Num[A][i] for i in range(num)]\n    return L\ndef S(List):\n    L = [List[len(List)-1]] + List[:len(List)-1]\n    return L\nN = int(input())\nT = list(input())\nP = list(range(3**N))\nfor s in T:\n  if s == 'R':\n    P = S(P)\n  else:\n    P = R(P)\nAns = [0 for i in range(3**N)]\nfor x,i in zip(P,range(3**N)):\n    Ans[x] = i\nprint(*Ans)"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\n\ndef P_change(N, P):\n    #Salsa\n    for i in range(N):\n        start = 3 ** i\n        step = 3 ** (i + 1)\n        dp = 3 ** i\n        for j in range(start, 3 ** N, step):\n            P[j:j + dp], P[j + dp:j + dp] = P[j + dp:j + dp], P[j:j + dp]\n    \n    return P\n\n\ndef P_slide(P):\n    #Rumba\n    temp = P[-1]\n    P[1:] = P[:-1]\n    P[0] = temp\n\n    return P\n\n\nN = int(input())\nT = input()\n\nP = list(range(3**N))\nT = T.replace('SS', 's')\n\nfor Ti in T:\n    if Ti == 'S':\n        #Salsa\n        P = P_change(N, P)\n    elif Ti == 'R':\n        #Rumba\n        P = P_slide(P)\n\nprint(' '.join([str(P.index(i)) for i in range(len(P))]))\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "def R(x):\n    x.insert(0, x.pop(-1))\n    return x\n    \ndef S(x, n):\n    ex = [\"\"]*n\n    for j in range(len(x)//3):\n        \n        k = j\n        tmp = 0\n        m = 3\n        q = j*3\n        while k > 0:\n            if k%3 == 1:\n                tmp = tmp + 2*m\n            elif k%3 == 2:\n                tmp = tmp + 1*m\n            k = k//3\n            m = m*3\n        ex[tmp] = x[q]\n        ex[tmp + 2] = x[q +1]\n        ex[tmp + 1] = x[q +2]\n    return(ex)\n            \n    \ndef main():\n    N = 3**int(input())\n    listN = list(range(N))\n    T = input()\n    l = list(listN)\n    p = [\"\"]*(N)\n    \n    for i in range(len(T)):\n        if T[i] == \"R\":\n            l = R(l)\n        else:\n            l = S(l, N)\n    for i in listN:\n        p[l[i]] = str(i)\n    \n\n    print(' '.join(p))\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "Num = [list(range(3**(i+1))) for i in range(11)]\nNum[0] = [0,2,1]\nfor i in range(1,11):\n    Num[i] = Num[i-1] + list(map(lambda x:x+2*3**(i),Num[i-1])) + list(map(lambda x:x+3**(i),Num[i-1]))\ndef Q(Num):\n    ans = 0\n    while Num > 1:\n        Num = Num // 3\n        ans += 1\n    return ans\ndef R(List):\n  num = len(List)\n  if num == 3:\n    return [List[0],List[2],List[1]]\n  else:\n    A = Q(num) - 1\n    L = [List[Num[A][i]] for i in range(num)]\n    return L\ndef S(List):\n    L = [List[len(List)-1]] + List[:len(List)-1]\n    return L\nN = int(input())\nT = list(input())\nP = list(range(3**N))\nfor s in T:\n  if s == 'R':\n    P = S(P)\n  else:\n    P = R(P)\nAns = [0 for i in range(3**N)]\nfor x,i in zip(P,range(3**N)):\n    Ans[x] = i\nprint(*Ans)"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\n\ndef P_change(N, P):\n    #Salsa\n    for i in range(N):\n        start = 3 ** i\n        step = 3 ** (i + 1)\n        dp = 3 ** i\n        for j in range(start, 3 ** N, step):\n            P[j:j + dp], P[j + dp:j + dp * 2] = P[j + dp:j + dp * 2], P[j:j + dp]\n    \n    return P\n\n\ndef P_slide(P):\n    #Rumba\n    temp = P[-1]\n    P[1:] = P[:-1]\n    P[0] = temp\n\n    return P\n\n\nN = int(input())\nT = input()\n\nP = list(range(3**N))\nT = T.replace('SS', 's')\n\nfor Ti in T:\n    if Ti == 'S':\n        #Salsa\n        P = P_change(N, P)\n    elif Ti == 'R':\n        #Rumba\n        P = P_slide(P)\n\nprint(' '.join([str(P.index(i)) for i in range(len(P))]))\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nt=input()\nnumber=[]\nfor j in range(3**n):\n  number.append(j)\ndef base_10_to_3(X):\n    if (int(X/3)):\n        return base_10_to_3(int(X/3))+str(X%3)\n    return str(X%3)\ndef base_3_to_10(Y):\n    out = 0\n    for i in range(1,len(str(Y))+1):\n        out += int(Y[-i])*(3**(i-1))\n    return out\ndef s(Num):\n  nextnumber=[0]*(3**n)\n  for k in range(3**n):\n    next=str(base_10_to_3(k))\n    for l in range(len(next)):\n      if next[l]==1:\n        next[l]=2\n      elif next[l]==2:\n        next[l]=1\n    print(k,base_3_to_10(str(next)))\n    nextnumber[base_3_to_10(str(next))]=Num[k]\n  return nextnumber\ndef r():\n  last=number.pop(3**n-1)\n  number.insert(0,last)\nfor m in range(len(t)):\n  first=t[m]\n  if first=='S':\n    number=s(number)\n  elif first=='R':\n    r()\n  print(number)\nprint(number)"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\n\ndef P_change(N, Pos):\n    #Salsa\n    Pos1 = 0\n    Pos2 = Pos\n    for Ni in range(N, 0, -1):\n        Ni3 = 3 ** (Ni - 1)\n\n        div, Pos2 = divmod(Pos2, Ni3)\n\n        if div == 1:\n            Pos1 += Ni3 * 2\n        elif div == 2:\n            Pos1 += Ni3\n        else:\n            Pos1 += 0\n\n        if Pos2 == 0:\n            break\n\n    return Pos1 + Pos2\n\n\ndef dance(N, T):\n    #サルサの２回連続は元に戻る\n    T = T.replace('SS', '')\n    #D = [True if Ti == 'S' else False for Ti in T]\n    D = [1 if Ti == 'S' else 0 for Ti in T]\n\n    N3 = 3 ** N\n    P = [0] * N3\n    Pd = dict()\n\n    for Pos in range(N3):\n        Pi = Pos\n        for Dn in D:\n            if Dn:\n                #Salsa\n                Ps = Pi\n                if Ps in Pd:\n                    Pi = Pd[Ps]\n                else:\n                    Pos1 = 0\n                    Pos2 = Pi\n                    for Ni in range(N, 0, -1):\n                        Ni3 = 3 ** (Ni - 1)\n\n                        div, Pos2 = divmod(Pos2, Ni3)\n\n                        if div == 1:\n                            Pos1 += Ni3 * 2\n                        elif div == 2:\n                            Pos1 += Ni3\n                        else:\n                            Pos1 += 0\n\n                        if Pos2 == 0:\n                            break\n\n                    Pi = Pos1 + Pos2\n\n                    Pd[Ps] = Pi\n            else:\n                #Rumba\n                Pi += 1\n                if Pi == N3:\n                    Pi = 0\n\n        P[Pos] = Pi\n\n    return  P\n    \n\nN = int(input())\nT = input()\n\nP = dance(N, T)\n\nprint(*P)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nprint(n**2)"
  },
  {
    "language": "Python",
    "code": "import math\ndef base3(value): # 10 => 3\n    try:\n        tmp = int(value)\n    except:\n        raise ValueError('Invalid value:', value)\n \n    \n    result = ''\n    tmp = int(value)\n    while tmp >= 3:\n        result = str(tmp%3) + result\n        tmp = int(tmp / 3)\n    result = str(tmp%3) + result\n    return result\n    \n    \ndef kaketamono3 (value):\n    wa=0\n    for i in range(len(base3(value))):\n        if int(base3(value)[-(i+1)])>0:\n            wa+=3**(i+1)\n    return wa-value\n  \ndef list(value):\n\n    list_for = [] \n    for i in range(value): \n        list_for.append(i)\n\n    return(list_for)\nn=int(input())\nt=str(input())\ns=list(3**n)\n\nfor i in range(len(t)):\n    if t[i]==\"S\":\n        for j in range(len(s)):\n            s[j]=kaketamono3(s[j])\n        \n    elif t[i]==\"R\":\n        for j in range(len(s)):\n            if s[j]==3**n-1:\n                s[j]=0\n            else:\n                s[j]=s[j]+1\n        \nprint(*s)"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nhuhan=[0]*(3**n)\na=[\"0\",\"2\",\"1\"]\nfor i in range(3**n):\n  b=[]\n  p=i\n  while True:\n    s=p//3\n    y=p%3\n    b=b+[a[y]]\n    if s==0:\n      break\n    p=s\n  b.reverse()\n  huhan[i]=int(\"\".join(b),3)\n\nn3=3**n\ndef main():\n  p=[i for i in range(3**n)]\n  #print(p)\n  t=input()\n  for sr in t:\n    p=list(map(lambda x: result(x,sr),p))\n  print(\" \".join(map(str,p)))\n    \ndef result(p,sr):\n  if sr==\"S\":\n    return(huhan[p])\n  else:\n    p=(p+1) % n3\n  return p\n   \n    \n    \nmain()"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\ndef sarusa(pos,N):\n  if N == 1:\n    pos[1], pos[2] = pos[2], pos[1].copy()\n  elif N == 2:\n    pos = pos.reshape(3,3)\n    pos[1,:], pos[2,:] = pos[2,:], pos[1,:].copy()\n    pos[:,1], pos[:,2] = pos[:,2], pos[:,1].copy()\n  else:\n    pos = pos.reshape(3,3**(N-1))\n    pos[0,:] = sarusa(pos[0,:],N-1)\n    pos[1,:] = sarusa(pos[1,:],N-1)\n    pos[2,:] = sarusa(pos[2,:],N-1)\n    pos[1,:], pos[2,:] = pos[2,:], pos[1,:].copy()\n\n  return pos.reshape(-1)\n\ndef rumba(pos,N):\n  return np.roll(pos,1)\n\nN = int(input())\nT = input()\n\npos = np.array(list(range(3**N)))\n\nwhile len(T) > 0:\n  if T.startswith('SS'):\n    T = T[2:]\n    continue\n  elif T.startswith('S'):\n    pos = sarusa(pos,N)\n    T = T[1:]\n  else:\n    pos = rumba(pos,N)\n    T = T[1:]\n    \nprint(' '.join(map(str,np.argsort(pos))))"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\nN = int(input())\nT = input()\n\n#サルサの２回連続は元に戻る\nT = T.replace('SS', '')\n#D = [1 if Ti == 'S' else 0 for Ti in T]\nTlen = len(T)\nD = []\nRc = 0\nfor i in range(Tlen):\n    if T[i] == 'S':\n        if Rc:\n            #Rumba\n            D.append(Rc)\n            Rc = 0\n\n        #Salsa\n        D.append(0)\n    else:\n        #Rumba\n        Rc += 1\n\nif Rc:\n    #Rumba\n    D.append(Rc)\n    Rc = 0\n\nD = tuple(D)\n\nN3 = 3 ** N\nP = [0] * N3\nSd = dict()\n\nfor Pos in range(N3):\n    Pi = Pos\n    Rc = 0\n    for Dn in D:\n        if Dn:\n            #Rumba\n            Pi = (Pi + Dn) % N3\n\n        else:\n            #Salsa\n            Ps = Pi\n            if Ps in Sd:\n                Pi = Sd[Ps]\n            else:\n                Pos1 = 0\n                Pos2 = Pi\n                for Ni in range(N, 0, -1):\n                    Ni3 = 3 ** (Ni - 1)\n\n                    div, Pos2 = divmod(Pos2, Ni3)\n\n                    if div == 1:\n                        Pos1 += Ni3 * 2\n                    elif div == 2:\n                        Pos1 += Ni3\n                    else:\n                        Pos1 += 0\n\n                    if Pos2 == 0:\n                        break\n\n                Pi = Pos1 + Pos2\n\n                Sd[Ps] = Pi\n\n    P[Pos] = Pi\n\n    \nprint(*P)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "def sinhou(a):\n    if (int(a/3)):\n        return sinhou(int(a/3))+str(a%3)\n    return str(a%3)\ndef tosinhou(a):\n    out = 0\n    for i in range(1,len(a)+1):\n        out += int(a[-i])*(3**(i-1))\n    return out\n\nN =int(input())\nT = input()\n\npeople = [i for i in range(3 ** N)]\n\n\nfor i in T:\n    num = [i for i in range(3 ** N)]\n    num2 = []\n    if i == 'S':\n        for j in num:\n            x = sinhou(j)\n            x = x.translate(x.maketrans({'1': '2', '2':'1'}))\n            a = tosinhou(x)\n            num2.append(a)\n            if j in num2:\n                pass\n            else:\n        \n                people[a], people[j] = people[j], people[a]\n\n    else:\n        people.insert(0, people[-1])\n        people = people[:-1]\n  \nans=''\nfor i in people:\n    ans += str(i) + ' '\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\ndef sarusa(pos,N):\n  if N == 1:\n    pos[1,:], pos[2,:] = pos[2,:], pos[1,:].copy()\n  elif N == 2:\n    pos = pos.reshape(3,3)\n    pos[1,:], pos[2,:] = pos[2,:], pos[1,:].copy()\n    pos[:,1], pos[:,2] = pos[:,2], pos[:,1].copy()\n  else:\n    pos = pos.reshape(3,3**(N-1))\n    pos[0,:] = sarusa(pos[0,:],N-1)\n    pos[1,:] = sarusa(pos[1,:],N-1)\n    pos[2,:] = sarusa(pos[2,:],N-1)\n    pos[1,:], pos[2,:] = pos[2,:], pos[1,:].copy()\n\n  return pos.reshape(-1)\n\ndef rumba(pos,N):\n  return np.roll(pos,1)\n\nN = int(input())\nT = input()\n\npos = np.array(list(range(3**N)))\n\nfor s in T:\n  if s == 'S':\n    pos = sarusa(pos,N)\n  else:\n    pos = rumba(pos,N)\n    \nprint(' '.join(map(str,np.argsort(pos))))"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nt=list(input())\nn=3**n\nl=[]\nfor i in range(n):\n  u=0\n  for k in range(12,0,-1):\n    p=i//3**(k-1)\n    i-=(3**(k-1))*p\n    if p==1:\n      u+=(3**(k-1))*2\n    elif p==2:\n      u+=(3**(k-1))\n  l.append(u)\ndef sarusa(a):\n  an=ans\n  return an[l[an.index(a)]]\nans=list(range(n))\nfor q in t:\n  if q=='S':\n    ans=list(map(sarusa,ans))\n  else:\n    d=[]\n    d.append(ans[n-1])\n    ans=d+ans[0:n-1]\nfor i in range(n):\n  print(ans.index(i),end=\" \")"
  },
  {
    "language": "Python",
    "code": "#!python3.8\n# -*- coding: utf-8 -*-\n# agc044/agc044_c\nimport sys\nimport numpy\n\ns2nn = lambda s: [int(c) for c in s.split(' ')]\nss2nn = lambda ss: [int(s) for s in list(ss)]\nss2nnn = lambda ss: [s2nn(s) for s in list(ss)]\ni2s = lambda: sys.stdin.readline().rstrip()\ni2n = lambda: int(i2s())\ni2nn = lambda: s2nn(i2s())\nii2ss = lambda n: [i2s() for _ in range(n)]\nii2nn = lambda n: ss2nn(ii2ss(n))\nii2nnn = lambda n: ss2nnn(ii2ss(n))\n\n\ndef main():\n    N = i2n()\n    M = 3**N\n    T = i2s()\n    trs = str.maketrans({'1': '2', '2': '1'})\n    # sls_trans = [lambda n: int(numpy.base_repr(n, 3).translate(trs), base=3) for n in range(M)]\n    A = list(range(M))\n    for t in T:\n        if t == 'S':\n            for i in range(M):\n                A[i] = int(numpy.base_repr(A[i], 3).translate(trs), base=3)\n        else:\n            for i in range(M):\n                A[i] = (A[i] + 1) % M\n    print(*A)\n    return\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    N = int(input())\n    T = input()\n    vol = 3**N\n    p = [i for i in range(vol)]\n    from functools import lru_cache\n    @lru_cache(maxsize = None)\n    def base10to3(X):\n            if (int(X/3)):\n                return base10to3(int(X/3))+str(X%3)\n            return str(X%3)\n    def base3to10(x):\n        out = 0\n        for i in range(1,len(str(x))+1):\n            out += int(x[-i])*(3**(i-1))\n        return out\n    def sarusa(i):\n        before = base10to3(i)\n        after=before.translate(str.maketrans({'1':'2','2':'1'}))\n        return int(base3to10(after))\n\n    for i in range(len(T)):\n        if T[i] == 'S':\n            p = list(map(sarusa,p))\n        else:\n            for j in range(vol):\n                p[j] = (p[j]+1)%vol\n    print(' '.join(map(str,p)))\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nhuhan=[0]*(3**n)\na=[0,2,1]\nfor i in range(3**n):\n  b=[]\n  p=i\n  h=0\n  while True:\n    s=p//3\n    y=p%3\n    b=b+[a[y]]\n    if s==0:\n      break\n    p=s\n  for j in range(len(b)-1,-1,-1):\n    h=h*3+b[j]\n  huhan[i]=h\n\nn3=3**n\ndef main():\n  p=[i for i in range(3**n)]\n  t=input()\n  t=t.replace(\"SS\",\"\")\n  t=t.replace(\"SRSRSRSRSRSRSRSRSRSRSRSRSRSRSRSRSRSR\",\"\")\n  t=t.replace(\"SRRSRRSRRSRRSRRSRRSRRSRRSRRSRRSRRSRRSRRSRRSRRSRRSRRSRR\",\"\")\n  t=t.replace(\"SRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRR\",\"\")  \n  snum=False\n  for sr in t:\n    if sr==\"R\":\n      p=(map(lambda x: (x+1) % n3 ,p))\n    else:\n      p=(map(lambda x: huhan[x] ,p))\n  #if snum:\n  p=list(p)\n  print(\" \".join(map(str,p)))\n    \n\"\"\"def result(p,sr):\n  if sr==\"S\":\n    return(huhan[p])\n  else:\n    p=(p+1) % n3\n  return p\n\"\"\" \n    \nmain()"
  },
  {
    "language": "Python",
    "code": "def getN():\n    return int(input())\ndef getNM():\n    return map(int, input().split())\ndef getList():\n    return list(map(int, input().split()))\n\ndef main():\n    n=getN()\n    t=input()\n\n    n=3**n\n\n    l=[i for i in range(n)]\n\n    for i in range(len(t)):\n        if t[i]=='S':\n            l = sss(l,n)\n        elif t[i]=='R':\n            l = rrr(l)\n\n    print(*l)\n\ndef Base_10_to_n(X, n):\n    X_dumy = X\n    out = ''\n    while X_dumy>0:\n        out = str(X_dumy%n)+out\n        X_dumy = int(X_dumy/n)\n    return out\n\ndef Base_n_to_10(X,n):\n    out = 0\n    for i in range(1,len(str(X))+1):\n        out += int(X[-i])*(n**(i-1))\n    return out#int out\n\ndef sss(l,n):\n    ans=[]\n    for i in l:\n        i3 = Base_10_to_n(i,3)\n        i_=''\n        for j in range(len(i3)):\n            if i3[j]=='0':\n                i_=i_+str(0)\n            elif i3[j]=='1':\n                i_=i_+str(2)\n            else:\n                i_=i_+str(1)\n        k = Base_n_to_10(i_,3)\n        k = k%n\n        ans.append(k)\n    return ans\n\ndef rrr(l):\n    ans=[]\n    for i in l:\n        if i==max(l):\n            ans.append(0)\n        else:\n            ans.append(i+1)\n    return ans\n\nmain()"
  },
  {
    "language": "Python",
    "code": "def r(l,n):\n    return list(map(lambda a: (a+n)%len(l), l))\ndef s(l,m):\n    return list(map(lambda a: m[a],l))\nif __name__ == '__main__':\n    m = list(range(0, 3**12))\n    for i in m:\n        res = 0\n        temp = 0\n        record = i\n        while i != 0:\n            if i % 3 == 1:\n                res += 2*(3**temp)\n            elif i % 3 == 2:\n                res += 1*(3**temp)\n            temp += 1\n            i //= 3\n        m[record] = res\n    n = input()\n    l = list(range(0, 3**int(n)))\n    cmd = list(input())\n    j = 0\n    new_cmd = []\n    while j < len(cmd):\n        temp = 0\n        while  j < len(cmd) and cmd[j] == \"S\":\n            j += 1\n            temp += 1\n        if temp % 2 == 1:\n            new_cmd.append(\"S\")\n        temp = 0\n        while j < len(cmd) and cmd[j] == \"R\":\n            j += 1\n            temp += 1\n        new_cmd.append(\"R\" * temp)\n    for c in new_cmd:\n        if c == \"S\":\n           l = s(l,m)\n        else:\n            l = r(l,len(c))\n    for p in l:\n        print(p, end=\" \")\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport time\n\n\ndef main():\n\n    # time1 = time.perf_counter()\n\n    # 実行環境(0:vscode, 1:atcoder)\n    MODE = 1\n\n    # 入力の次元\n    DIMENSION = 2\n\n    # int型に変換\n    INT_TYPE = 0\n\n    if not (MODE):\n        with open(\"input.txt\", \"r\") as f:\n            s = f.read()\n    else:\n        s = sys.stdin.read()\n\n    if DIMENSION == 1:\n        if INT_TYPE == 1:\n            s = int(s)\n    elif DIMENSION == 2:\n        if INT_TYPE == 0:\n            s = s.split()\n        elif INT_TYPE == 1:\n            s = [int(x) for x in s.split()]\n    elif DIMENSION == 3:\n        if INT_TYPE == 0:\n            s = [x.split() for x in s.splitlines()]\n        elif INT_TYPE == 1:\n            s = [[int(y) for y in x.split()] for x in s.splitlines()]\n\n    # time2 = time.perf_counter()\n    # print(format(time2 - time1, '.3f'))\n\n    N = int(s[0])\n    T = s[1]\n    NUM = 3 ** N\n    P = list(range(NUM))\n\n    for t in T:\n        if t == \"S\":\n            for j, p in enumerate(P):\n                p_3 = [None] * N\n                p_3_mod = p\n                for i in range(N):\n                    pow_3 = 3 ** (N-i-1)\n                    p_3[i] = p_3_mod // pow_3\n                    p_3_mod = p_3_mod % pow_3\n                    if p_3[i] == 1:\n                        p_3[i] = 2\n                    elif p_3[i] == 2:\n                        p_3[i] = 1\n                p_new = 0\n                for i in range(N):\n                    p_new += 3 ** i * p_3[N - i - 1]\n                P[j] = p_new\n            # time2 = time.perf_counter()\n            # print(format(time2 - time1, '.3f'))\n        else:\n            for i in range(NUM):\n                P[i] += 1\n                if P[i] == NUM:\n                    P[i] = 0\n            # time2 = time.perf_counter()\n            # print(format(time2 - time1, '.3f'))\n\n    # time2 = time.perf_counter()\n    # print(format(time2 - time1, '.3f'))\n\n    P = [str(x) for x in P]\n    print(' '.join(P))\n\n    # time2 = time.perf_counter()\n    # print(format(time2 - time1, '.3f'))\n\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\nreadline = sys.stdin.readline\n\nN = int(readline())\nT = readline().strip()\n\n#Salsaの２回連続は元に戻るので削除\nT = T.replace('SS', '')\n\nTlen = len(T)\nD = ()\nRc = 0\nfor i in range(Tlen):\n    if T[i] == 'S':\n        if Rc:\n            #Rumba連続回数\n            D = D + (Rc,)\n            Rc = 0\n\n        #Salsa\n        D = D + (0,)\n    else:\n        #Rumba連続回数加算\n        Rc += 1\n\nif Rc:\n    #Rumba連続回数\n    D = D + (Rc,)\n    Rc = 0\n\n\nN3 = 3 ** N\nP = list(range(N3))\n\nfor Dn in D:\n    if Dn:\n        #Rumba: Dn移動\n        Dn = Dn % N3\n        P[:Dn], P[Dn:] = P[N3 - Dn:], P[:-Dn].copy()\n\n    else:\n        #Salsa: 1と2入れ替え\n        for i in range(N):\n            start = 3 ** i\n            stop = 3 ** N\n            step = 3 ** (i + 1)\n            dp = 3 ** i\n            for j in range(start, stop, step):\n                j1 = j + dp\n                j2 = j1 + dp\n                P[j:j1], P[j1:j2] = P[j1:j2], P[j:j1].copy()\n\n#出力用データ作成\nR = [None] * N3\nfor i in range(N3):\n    R[P[i]] = i\n    \nprint(*R)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "def salsa(X):\n    result = ''\n    tmp = int(X)\n    while tmp >= 3:\n        if tmp%3 == 1:\n            a = 2\n        elif tmp%3 == 2:\n            a = 1\n        else:\n            a = 0\n        result = str(a) + result\n        tmp = int(tmp / 3)\n    if tmp%3 == 1:\n        a = 2\n    elif tmp%3 == 2:\n        a = 1\n    else:\n        a = 0\n    result = str(a) + result\n    return result\n\ndef Base_3_to_10(X):\n    out = 0\n    for i in range(1,len(str(X))+1):\n        out += int(X[-i])*(3**(i-1))\n    return out\n\nn = int(input())\nt = input()\np = [i for i in range(3 ** n)]\n\nfor ti in t:\n    if ti == 'S':\n        p = list(map(lambda x: salsa(x), p))\n        p = list(map(lambda x: Base_3_to_10(x), p))\n    else:\n        p = list(map(lambda x: (x + 1) % 3 ** n, p))\nprint(*p, sep=' ')"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nT = input()\n\np = []\nfor i in range(3**N):\n  p.append(i)\n\ndef base3(value): \n  result = ''\n  tmp = int(value)\n  while tmp >= 3:\n    a = 0\n    if tmp%3 == 1:\n      a += 2\n    elif tmp%3 == 2:\n      a += 1\n    else:\n      a += tmp%3\n    result = str(a) + result\n    tmp = int(tmp//3)\n  a = 0\n  if tmp%3 == 1:\n    a += 2\n  elif tmp%3 == 2:\n    a += 1\n  else:\n    a += tmp%3\n  result = str(a) + result\n  b = 0\n  for i in range(len(result)):\n    b += int(result[i])*3**(len(result)-i-1)\n  return b\n\ndef salsa(p):\n  for i in range(len(p)):\n    p[i] = base3(p[i])\n    \n\ndef rumba(p):\n  for i in range(len(p)):\n    if p[i] == 3**N -1:\n      p[i] = 0\n    else:\n      p[i] = p[i] + 1\n      \nfor i in range(len(T)):\n  if T[i] == 'S':\n    salsa(p)\n  if T[i] == 'R':\n    rumba(p)  \n    \nans = list(map(str,p))\nAns = ' '.join(ans)\nprint(Ans)"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\nreadline = sys.stdin.readline\n\nN = int(readline())\nT = readline().strip()\n\n#Salsaの２回連続は元に戻るので削除\nT = T.replace('SS', '')\n\nTlen = len(T)\nD = ()\nRc = 0\nfor i in range(Tlen):\n    if T[i] == 'S':\n        if Rc:\n            #Rumba連続回数\n            D = D + (Rc,)\n            Rc = 0\n\n        #Salsa\n        D = D + (0,)\n    else:\n        #Rumba連続回数加算\n        Rc += 1\n\nif Rc:\n    #Rumba連続回数\n    D = D + (Rc,)\n    Rc = 0\n\n\nN3 = 3 ** N\nP = list(range(N3))\n\nfor Dn in D:\n    if Dn:\n        #Rumba: Dn移動\n        Dn = Dn % N3\n        if Dn:\n            P[:Dn], P[Dn:] = P[N3 - Dn:], P[:-Dn].copy()\n\n    else:\n        #Salsa: 1と2入れ替え\n        for i in range(N):\n            start = 3 ** i\n            stop = 3 ** N\n            step = 3 ** (i + 1)\n            dp = 3 ** i\n            for j in range(start, stop, step):\n                j1 = j + dp\n                j2 = j1 + dp\n                P[j:j1], P[j1:j2] = P[j1:j2], P[j:j1].copy()\n\n#出力用データ作成\nR = [None] * N3\nfor i in range(N3):\n    R[P[i]] = i\n    \nprint(*R)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nimport string\nN = int(input())\nT = input()\ndef base10to(n, b):\n    if (int(n/b)):\n        return base10to(int(n/b), b) + str(n%b)\n    return str(n%b)\ndef maniR(m):\n            a = int(m, 3) + 1\n            if a ==3**N:\n                a=0\n            return base10to(a, 3)\ndef output(m):\n    a = int(m, 3)\n    return a\npos = [base10to(i, 3) for i in range(3**N)]\nfor c in list(T):\n    if c ==\"S\":\n        pos = list(map(lambda x: x.translate(str.maketrans({'1': '2', '2': '1'})), pos))\n    if c ==\"R\":\n        pos = list(map(maniR, pos))\n\nans = list(map(output, pos))\nprint(*ans)\n"
  },
  {
    "language": "Python",
    "code": "import copy\n\nN = int(input())\nT = input()\nPlace = []\nnumber = 3**N\nans = [0]*number\nk = 0\nJ = []\n\ndef to_3(X):\n    if (int(X/3)):\n        return to_3(int(X/3))+str(X%3)\n    return str(X%3)\ndef to_10(X):\n    out = 0\n    for i in range(1,len(X)+1):\n        out += int(X[-i])*(3**(i-1))\n    return out#int out\n\nfor b in range(number):\n    Place.append(b)\n    jstr = to_3(b)\n    jstr = jstr.translate(str.maketrans('12', '21'))\n    j = int(to_10(jstr))\n    J.append(j)\n\nT = T.replace('SS', '')\n\nfor a in range(len(T)):\n    if T[a] == 'S':\n        PrePlace = copy.copy(Place)\n        for i in range(number):\n            j = J[i]\n            Place[j] = PrePlace[i]\n\n    else:\n        end = Place.pop(-1)\n        Place.insert(0, end)\n\nfor item in Place:\n    ans[item] = k\n    k += 1\n\nprint(' '.join(map(str, ans)))"
  },
  {
    "language": "Python",
    "code": "\nn = int(input())\nt = input()\nlist1 = []\nfor i in range(0,(3**n)):\n    list1.append(i)\nfor j in t:\n    if j == 'S':\n        for v, k in enumerate(list1):\n            if k == 1:\n                list1[v] = 2\n            elif k == 2:\n                list1[v] = 1\n    elif j == \"R\":\n        for v , k in enumerate(range(len(list1))):\n            if k < len(list1) -1 :\n                list1[v] = list1[v+1]\n            else:\n                list1[v] = list1[0]\nprint(list1)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\ndef sarusa(pos,N):\n  if N == 1:\n    pos[1], pos[2] = pos[2], pos[1].copy()\n  elif N == 2:\n    pos = pos.reshape(3,3)\n    pos[1,:], pos[2,:] = pos[2,:], pos[1,:].copy()\n    pos[:,1], pos[:,2] = pos[:,2], pos[:,1].copy()\n  else:\n    pos = pos.reshape(3,3**(N-1))\n    pos[0,:] = sarusa(pos[0,:],N-1)\n    pos[1,:] = sarusa(pos[1,:],N-1)\n    pos[2,:] = sarusa(pos[2,:],N-1)\n    pos[1,:], pos[2,:] = pos[2,:], pos[1,:].copy()\n\n  return pos.reshape(-1)\n\ndef rumba(pos,N):\n  return np.roll(pos,1)\n\nN = int(input())\nT = input()\n\npos = np.array(list(range(3**N)))\n\nfor s in T:\n  if s == 'S':\n    pos = sarusa(pos,N)\n  else:\n    pos = rumba(pos,N)\n    \nprint(' '.join(map(str,np.argsort(pos))))"
  },
  {
    "language": "Python",
    "code": "import numpy as np\ndef cvt(a):\n    b = 0\n    c = 0\n    while a != 0:\n        d = a % 3\n        a = (a-(a % 3)) / 3\n        if d == 1:\n            d = 2\n        elif d == 2:\n            d = 1\n        b += d * (3**c)\n        c += 1\n    return int(b)\nN = int(input())\nT = input()\nA = np.array([i for i in range(3**N)])\nB = np.array([i for i in range(3**N)])\nfor t in T:\n    print(t)\n    for i in range(3**N):\n        if t == 'S':\n            B[i] = cvt(A[i])\n        else:\n            B[i] += 1\n            if B[i] == 3**N:\n                B[i] = 0\n    A = B.copy()\nfor i in A:\n    print(i, end = ' ')"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\n\ndef P_change(N, P):\n    #Salsa\n    for i in range(N):\n        start = 3 ** i\n        stop = 3 ** N\n        step = 3 ** (i + 1)\n        dp = 3 ** i\n        for j in range(start, stop, step):\n            P[j:j + dp], P[j + dp:j + dp * 2] = P[j + dp:j + dp * 2], P[j:j + dp]\n\n    return P\n\n\ndef P_slide(P):\n    #Rumba\n    temp = P[-1]\n    P[1:] = P[:-1]\n    P[0] = temp\n\n    return P\n\n\ndef dance(N, D, P):\n    for Dn in D:\n        if Dn:\n            #Salsa\n            P = P_change(N, P)\n        else:\n            #Rumba\n            P = P_slide(P)\n\n    N3 = 3 ** N\n    R = [0] * N3\n    for i in range(N3):\n        R[P[i]] = i\n\n    return  R\n    \n\nN = int(input())\nT = input()\n\nN3 = 3 ** N\nP = list(range(N3))\n#サルサの２回連続は元に戻る\nT = T.replace('SS', '')\nD = [1 if Ti == 'S' else 0 for Ti in T]\n\nR = dance(N, D, P)\n\nprint(*R)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\nfrom functools import lru_cache\n\nreadline = sys.stdin.readline\n\n@lru_cache()\ndef P_change(N, Pos):\n    #Salsa\n    Pos1 = 0\n    for Ni in range(N, 0, -1):\n        Ni3 = 3 ** (Ni - 1)\n\n        div, Pos = divmod(Pos, Ni3)\n\n        if div == 1:\n            Pos1 += Ni3 * 2\n        elif div == 2:\n            Pos1 += Ni3\n        else:\n            Pos1 += 0\n\n        if Pos == 0:\n            break\n\n    return Pos1 + Pos\n\nN = int(readline())\nT = readline().strip()\n\n#Salsaの２回連続は元に戻るので削除\nT = T.replace('SS', '')\n\nTlen = len(T)\nD = ()\nRc = 0\nfor i in range(Tlen):\n    if T[i] == 'S':\n        if Rc:\n            #Rumba連続回数\n            D = D + (Rc,)\n            Rc = 0\n\n        #Salsa\n        D = D + (0,)\n    else:\n        #Rumba連続回数加算\n        Rc += 1\n\nif Rc:\n    #Rumba連続回数\n    D = D + (Rc,)\n    Rc = 0\n\n\nN3 = 3 ** N\nP = [None] * N3\n\nfor Pos in range(N3):\n    Pi = Pos\n    Rc = 0\n    for Dn in D:\n        if Dn:\n            #Rumba\n            Pi = (Pi + Dn) % N3\n\n        else:\n            #Salsa\n            Pi = P_change(N, Pi)\n\n    P[Pos] = Pi\n\n    \nprint(*P)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\n# 実行環境(0:vscode, 1:atcoder)\nMODE = 1\n\n# 入力の次元\nDIMENSION = 2\n\n# int型に変換\nINT_TYPE = 0\n\nif not (MODE):\n    with open(\"input.txt\", \"r\") as f:\n        s = f.read()\nelse:\n    s = sys.stdin.read()\n\nif DIMENSION == 1:\n    if INT_TYPE == 1:\n        s = int(s)\nelif DIMENSION == 2:\n    if INT_TYPE == 0:\n        s = s.split()\n    elif INT_TYPE == 1:\n        s = [int(x) for x in s.split()]\nelif DIMENSION == 3:\n    if INT_TYPE == 0:\n        s = [x.split() for x in s.splitlines()]\n    elif INT_TYPE == 1:\n        s = [[int(y) for y in x.split()] for x in s.splitlines()]\n\n\ndef base10to(n, b):\n    if (int(n/b)):\n        return base10to(int(n/b), b) + str(n % b)\n    return str(n % b)\n\n\nN = int(s[0])\nT = s[1]\nNUM = 3 ** N\nP = list(range(NUM))\n\nfor t in T:\n    if t == \"S\":\n        PP = list(range(NUM))\n        for j, p in enumerate(PP):\n            p_3 = [None] * N\n            p_3_mod = p\n            for i in range(N):\n                p_3[i] = p_3_mod // 3 ** (N-i-1)\n                p_3_mod = p_3_mod % 3 ** (N-i-1)\n                if p_3[i] == 1:\n                    p_3[i] = 2\n                elif p_3[i] == 2:\n                    p_3[i] = 1\n            p_new = 0\n            for i in range(N):\n                p_new += 3 ** i * p_3[N - i - 1]\n            PP[j] = p_new\n        P_tmp = [None] * NUM\n        for i, p in enumerate(PP):\n            P_tmp[p] = P[i]\n        P = [x for x in P_tmp]\n\n    else:\n        P_tmp = [x for x in P]\n        for i in range(NUM - 1):\n            P_tmp[i + 1] = P[i]\n        P_tmp[0] = P[NUM - 1]\n        P = P_tmp\n        # print(P)\n\nP_tmp = [None] * NUM\nfor i, p in enumerate(P):\n    P_tmp[p] = i\nP = [x for x in P_tmp]\n\ntext = \"\"\nfor p in P:\n    text += str(p) + \" \"\nprint(text)\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\n# 実行環境(0:vscode, 1:atcoder)\nMODE = 1\n\n# 入力の次元\nDIMENSION = 2\n\n# int型に変換\nINT_TYPE = 0\n\nif not (MODE):\n    with open(\"input.txt\", \"r\") as f:\n        s = f.read()\nelse:\n    s = sys.stdin.read()\n\nif DIMENSION == 1:\n    if INT_TYPE == 1:\n        s = int(s)\nelif DIMENSION == 2:\n    if INT_TYPE == 0:\n        s = s.split()\n    elif INT_TYPE == 1:\n        s = [int(x) for x in s.split()]\nelif DIMENSION == 3:\n    if INT_TYPE == 0:\n        s = [x.split() for x in s.splitlines()]\n    elif INT_TYPE == 1:\n        s = [[int(y) for y in x.split()] for x in s.splitlines()]\n\n\ndef base10to(n, b):\n    if (int(n/b)):\n        return base10to(int(n/b), b) + str(n % b)\n    return str(n % b)\n\n\ndef main():\n    N = int(s[0])\n    T = s[1]\n    NUM = 3 ** N\n    P = list(range(NUM))\n\n    for t in T:\n        if t == \"S\":\n            for j, p in enumerate(P):\n                p_3 = [None] * N\n                p_3_mod = p\n                for i in range(N):\n                    p_3[i] = p_3_mod // 3 ** (N-i-1)\n                    p_3_mod = p_3_mod % 3 ** (N-i-1)\n                    if p_3[i] == 1:\n                        p_3[i] = 2\n                    elif p_3[i] == 2:\n                        p_3[i] = 1\n                p_new = 0\n                for i in range(N):\n                    p_new += 3 ** i * p_3[N - i - 1]\n                P[j] = p_new\n        else:\n            for i in range(NUM):\n                P[i] += 1\n                if P[i] == NUM:\n                    P[i] = 0\n\n    text = \"\"\n    for p in P:\n        text += str(p) + \" \"\n    print(text)\n\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\n\ndef Base10_3(X):\n    if (int(X/3)):\n        return Base10_3(int(X/3))+str(X%3)\n    return str(X%3)\n\ndef Base3_10(X):\n    out = 0\n    for i in range(1,len(X)+1):\n        out += int(X[-i])*(3**(i-1))\n    return out\n    \ndef f(x):\n    x3 = list(str(Base10_3(x)))\n    for i in range(len(x3)):\n        if x3[i] == '1':\n            x3[i] = '2'\n        elif x3[i] == '2':\n            x3[i] = '1'\n    new_x3 = ''.join(x3)\n    return Base3_10(new_x3)\n\nN = int(input())\nN_list = np.arange(3**N)\nT = list(input())\nfor i in range(len(T)):\n    if T[i] == 'S':\n        N_list = [f(i) for i in list(N_list)]\n    else:\n        N_list = [(i+1)%(3**N) for i in list(N_list)]\n\nfor i in range(3**N):\n    print(N_list[i], end=\" \")"
  },
  {
    "language": "Python",
    "code": "import math\ndef base3(value): # 10 => 3\n    try:\n        tmp = int(value)\n    except:\n        raise ValueError('Invalid value:', value)\n \n    \n    result = ''\n    tmp = int(value)\n    while tmp >= 3:\n        result = str(tmp%3) + result\n        tmp = int(tmp / 3)\n    result = str(tmp%3) + result\n    return result\n    \n    \ndef kaketamono3 (value):\n    wa=0\n    for i in range(len(base3(value))):\n        if int(base3(value)[i])>0:\n            wa+=3**(i+1)\n    return wa-value\n  \ndef list(value):\n\n    list_for = [] \n    for i in range(value): \n        list_for.append(i)\n\n    return(list_for)\nn=int(input())\nt=str(input())\ns=list(3**n)\n\nfor i in range(len(t)):\n    if t[i]==\"S\":\n        for j in range(len(s)):\n            s[j]=kaketamono3(s[j])\n        \n    elif t[i]==\"R\":\n        for j in range(len(s)):\n            if s[j]==3**n-1:\n                s[j]=0\n            else:\n                s[j]=s[j]+1\n        \nprint(*s)"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n\nn = int(input())\nnum = 3**n\nl = []\nfor i in range(num):\n    l.append(i)\n\ndef base_10_to_n(X, n):\n    if (int(X/n)):\n        return base_10_to_n(int(X/n), n)+str(X%n)\n    return str(X%n)\n\nt = input()\nfor i in t:\n    if i == \"S\":\n        flag = [0 for x in range(num)]\n        for j in l:\n            three = base_10_to_n(j, 3)\n            index = \"\"\n            for t in range(len(three)):\n                if three[t] == \"1\":\n                    index += \"2\"\n                elif three[t] == \"2\":\n                    index += \"1\"\n                else:\n                    index += three[t]\n            if flag[j] == 0 and flag[int(index, 3)] == 0:\n                if \"1\" in three or \"2\" in three:\n                    tmp = l[int(index, 3)]\n                    l[int(index, 3)] = l[j]\n                    l[j] = tmp\n                    flag[j] = 1\n                    flag[int(index, 3)] = 1\n    if i == \"R\":\n        tmp = l[num-1]\n        for j in range(num-1, 0, -1):\n            l[j] = l[j-1]\n        l[0] = tmp\n\n\nprint(l[0], end=\"\")\nfor i in range(1, num):\n    print(\" \"+str(l[i]), end=\"\" )\n\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nt = input()\nop = [[int(c == 'R') for c in t]]\nans = [0]\n\nfor d in range(n):\n    k = 3 ** d\n    nop = []\n    nans = []\n    for g in range(3):  # d桁目の数\n        for i in range(k):  # d桁目未満の数\n            opg = op[i]\n            opn = []\n            h = g\n            for o in opg:\n                if o == 0:\n                    if len(opn) > 0 and opn[-1] == 0:\n                        opn.pop()\n                    else:\n                        opn.append(0)\n                    if h == 1:\n                        h = 2\n                    elif h == 2:\n                        h = 1\n                else:\n                    if h == 2:\n                        h = 0\n                        opn.append(1)\n                    else:\n                        h += 1\n            nop.append(opn)\n            nans.append(h * k + ans[i])\n\n    op = nop\n    ans = nans\n\nprint(*ans)\n"
  },
  {
    "language": "Python",
    "code": "def r(l,n):\n    return list(map(lambda a: (a+n)%len(l), l))\ndef s(l,m):\n    return list(map(lambda a: m[a],l))\nif __name__ == '__main__':\n    n = input()\n    m = list(range(0, 3**int(n)))\n    for i in m:\n        res = 0\n        temp = 0\n        record = i\n        while i != 0:\n            if i % 3 == 1:\n                res += 2*(3**temp)\n            elif i % 3 == 2:\n                res += 1*(3**temp)\n            temp += 1\n            i //= 3\n        m[record] = res\n    \n    l = list(range(0, 3**int(n)))\n    cmd = list(input())\n    j = 0\n    new_cmd = []\n    while j < len(cmd):\n        temp = 0\n        while  j < len(cmd) and cmd[j] == \"S\":\n            j += 1\n            temp += 1\n        if temp % 2 == 1:\n            new_cmd.append(\"S\")\n        temp = 0\n        while j < len(cmd) and cmd[j] == \"R\":\n            j += 1\n            temp += 1\n        new_cmd.append(\"R\" * temp)\n    for c in new_cmd:\n        if c == \"S\":\n           l = s(l,m)\n        else:\n            l = r(l,len(c))\n    for p in l:\n        print(p, end=\" \")\n\n\n"
  },
  {
    "language": "Python",
    "code": "def R(x):\n    x.insert(0, x.pop(-1))\n    return x\n    \ndef S(x, n):\n    ex = [0]*n\n    for j in range(N//3):\n        \n        k = j\n        tmp = 0\n        m = 1\n        q = J*3\n        while k > 0:\n            if k%3 == 1:\n                tmp = tmp + 2*(3**m)\n            elif k%3 == 2:\n                tmp = tmp + 1*(3**m)\n            k = k//3\n            m = m +1\n        ex[q] = x[tmp]\n        ex[q + 1] = x[tmp + 2]\n        ex[q + 2] = x[tmp + 1]\n    return(ex)\n            \n    \ndef main():\n    N = 3**int(input())\n    T = input()\n    l = list(range(N))\n    p = [0]*N\n    \n    for i in range(len(T)):\n        if T[i] == \"R\":\n            l = R(l)\n        else\n            l = S(l, N)            \n    print(l)\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nT = list(input())\n\ndef convert(n):\n    result = \"\"\n    while n>0:\n        result = str(n%3)+result\n        n //= 3\n    \n    new = \"\"\n    for i in range(len(result)):\n        if result[i]==\"1\":\n            new += \"2\"\n        elif result[i]==\"2\":\n            new += \"1\"\n        else:\n            new += result[i]\n            \n    new2 = 0\n    for i in range(len(new)):\n        new2 += int(new[i])*(3**(len(new)-i-1))\n    return new2\n\nans = []\nfor j in range(3**N):\n    for i in T:\n        if i==\"S\":\n            j = convert(j)\n        if i==\"R\":\n            if j+1<3**N:\n                j += 1\n            else:\n                j = 0\n    ans.append(str(j))\nprint(\" \".join(ans))"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nt = input()\n\nnew_pos = [0]\nnew_w = [0]*len(t)\n\nfor i in range(1, n+1):\n    ith_bit = [0]*(3**i)  # ith_bit[p] : 位置 (p mod 3**i) のi番目bit\n    for k in range(3):\n        for l in range(3**(i-1)):\n            ith_bit[k*3**(i-1)+l] = k\n\n    pos = new_pos\n    w = new_w  # 繰り上がりが起きても ith_bit を正確に捉えるため、j 曲流したあとの \"222..22\" の位置を把握しておく\n\n    q = 0\n    already = [0]*3**i\n    new_w = [0]*len(t)\n\n    for j in range(len(t)):\n        mark = w[j]\n        for k in range(3):\n            cand = mark + k*3**(i-1)\n            if ith_bit[cand] and (q - already[cand]) % 2:\n                # \"122..22\", \"222..22\" の最上位 bit のみ Salsa を流す\n                ith_bit[cand] = 3 - ith_bit[cand]\n            already[cand] = q  # 位置 cand に何回 Salsa を流したか記憶しておく\n            if ith_bit[cand] == 2:\n                new_w[j] = cand\n\n        if t[j] == 'S':\n            q += 1\n        else:\n            for k in range(3):\n                ith_bit[mark + k*3**(i-1)] = (ith_bit[mark + k*3**(i-1)]+1) % 3\n\n    new_pos = [0]*(3**i)\n    for j in range(3**i):\n        if ith_bit[j] and (q - already[j]) % 2:\n            # 全ての位置に Salsa を流す。\n            # 曲の途中で \"*22..22\" が位置 j に訪れている場合、上で Salsa を流してしまっている。\n            # その分 already[j] を引く。\n            ith_bit[j] = 3-ith_bit[j]\n        new_pos[j] = pos[j % 3**(i-1)] + ith_bit[j]*3**(i-1)\n\nprint(*new_pos)\n"
  },
  {
    "language": "Python",
    "code": "\nmemo = [0] * 600000\n\n\ndef SRS(num):\n    a = 0\n    num_root = num\n    for n in range(11, -1, -1):\n        if int(num / 3**n) == 1:\n            a += 3**n\n        elif int(num / 3**n) == 2:\n            a -= 3**n\n        num %= 3**n\n    num = num_root + a\n    return num\n\n\nN = int(input())\nT = input()\nans = [0] * 3**N\n\nfor num in range(3**N):\n    n = num\n    for t in T:\n        if t == \"S\":\n            if memo[n] != 0:\n                n =  memo[n]\n            else:\n                memo[n] = SRS(n)\n                memo[SRS(n)] = n\n                n = SRS(n)\n        elif t == \"R\":\n            n += 1\n            if n == 3**N:\n                n = 0\n\n    ans[num] = n\n\nfor a in ans:\n    print(a, end= \" \")\n\n\n"
  },
  {
    "language": "Python",
    "code": "def base10to(n, b):\n    if (int(n / b)):\n        return base10to(int(n / b), b) + str(n % b)\n    return str(n % b)\n\n\ndef getExchengeStep(a):\n    a_3 = list(base10to(a, 3))\n\n    for i in range(len(a_3)):\n        if (a_3[i] == '1'):\n            a_3[i] = '2'\n        elif (a_3[i] == '2'):\n            a_3[i] = '1'\n\n    return int(''.join(a_3), 3)\n\n\ndef S(P):\n    flag = [False] * len(P)\n    for i in range(len(P)):\n        if (flag[i] == False):\n            to = getExchengeStep(i)\n            flag[i] = True\n            flag[to] = True\n            P[i], P[to] = P[to], P[i]\n\n    return P\n\n\ndef R(P):\n    temp = P[-1]\n    P[1:] = P[:-1]\n    P[0] = temp\n    return P\n\n\nN = int(input())\nT = input()\n\nP = list(range(3 ** N))\n\n\nfor t in T:\n    if (t == 'R'):\n        P = R(P)\n    if (t == 'S'):\n        P = S(P)\n\n\nprint(' '.join([str(P.index(i)) for i in range(len(P))]))\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nt = input()\nl = len(t)\n \n \ndef Base_10_to_3(x):\n    if (int(x/3)):\n        return Base_10_to_3(int(x/3)) + str(x % 3)\n    return str(x % 3)\n \n \ndef Base_3_to_10(x):\n    out = 0\n    for i in range(1, len(str(x))+1):\n        out += int(x[-i])*(3**(i-1))\n    return out\n \n \ndef convert(x):\n    l = len(x)\n    s = [''] * l\n    for i in range(l):\n        target = int(x[i])\n        if (x[i] != '0'):\n            s[i] = str(3 - target)\n        else:\n            s[i] = '0'\n    return ''.join(s)\n \n \ndef sa(x):\n    x = Base_10_to_3(x)\n    x = convert(x)\n    x = Base_3_to_10(x)\n    return x\n \n \ndef ru(x):\n    return((x + 1) % (3 ** n))\n \n \nPs = [0] * (3 ** n)\nfor i in range(3 ** n):\n    Ps[i] = i\nfor i in range(l):\n    for j in range(3 ** n):\n        if (t[i] == 'S'):\n            Ps[j] = (sa(Ps[j]))\n        else:\n            Ps[j] = (ru(Ps[j]))\n \nprint(' '.join(map(str, Ps)))"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\n\ndef P_change(N, P):\n    #Salsa\n    for i in range(N):\n        start = 3 ** i\n        stop = 3 ** N\n        step = 3 ** (i + 1)\n        dp = 3 ** i\n        for j in range(start, stop, step):\n            P[j:j + dp], P[j + dp:j + dp * 2] = P[j + dp:j + dp * 2], P[j:j + dp]\n\n    return P\n\n\ndef P_slide(P):\n    #Rumba\n    temp = P[-1]\n    P[1:] = P[:-1]\n    P[0] = temp\n\n    return P\n\n\ndef dance(N, D, P):\n    for Dn in D:\n        if Dn:\n            #Salsa\n            P = P_change(N, P)\n        else:\n            #Rumba\n            P = P_slide(P)\n\n    N3 = 3 ** N\n    R = [0] * N3\n    for i in range(N3):\n        R[P[i]] = i\n\n    return  R\n    \n\nN = int(input())\nT = input()\n\nN3 = 3 ** N\nP = list(range(N3))\n#サルサの２回連続は元に戻る\nT = T.replace('SS', '')\nD = [1 if Ti == 'S' else 0 for Ti in T]\n\nR = dance(N, D, P)\n\nprint(*R)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\ndef cvt(a):\n    b = 0\n    c = 0\n    while a != 0:\n        d = a % 3\n        a = (a-(a % 3)) / 3\n        if d == 1:\n            d = 2\n        elif d == 2:\n            d = 1\n        b += d * (3**c)\n        c += 1\n    return int(b)\nN = int(input())\nT = input()\nA = np.array([i for i in range(3**N)])\nB = np.array([i for i in range(3**N)])\nfor t in T:\n    for i in range(3**N):\n        if t == 'S':\n            B[i] = cvt(A[i])\n        else:\n            B[i] += 1\n            if B[i] == 3**N:\n                B[i] = 0\n    A = B.copy()\nfor i in len(A):\n    print(i, end = ' ')"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nimport string\nN = int(input())\nT = input()\ndef base10to(n, b):\n    if (int(n/b)):\n        return base10to(int(n/b), b) + str(n%b)\n    return str(n%b)\ndef maniR(m):\n            a = int(m, 3) + 1\n            if a ==3**N:\n                a=0\n            return base10to(a, 3)\ndef output(m):\n    a = int(m, 3)\n    return a\npos = [base10to(i, 3) for i in range(3**N)]\nfor c in list(T):\n    if c ==\"S\":\n        pos = list(map(lambda x: x.translate(str.maketrans({'1': '2', '2': '1'})), pos))\n    if c ==\"R\":\n        pos = list(map(maniR, pos))\n\nans = list(map(output, pos))\nprint(*ans)\n"
  },
  {
    "language": "Python",
    "code": "num = int(input())\nRS = list(input())\n#print(num)\n\ndance_human = list(range(3 ** num))\n#print(dance_human)\n\nfor w in range(len(RS)):\n    if RS[w] == 'S':\n        list = [0] * int(len(dance_human))\n        for i in range(len(dance_human)):\n            target_num = i\n            save_num = []\n            x = 0\n            if target_num == 0:\n                list[i] = 0\n            while target_num >0:\n                out = int(target_num%3)\n                if out == 2:\n                    out = 1\n                elif out == 1:\n                    out = 2\n                save_num.append(out)\n                target_num = int(target_num/3)\n            \n            #print(save_num)\n            A = 0\n            for h in range(len(save_num)):\n                A = A + save_num[h] * (3 ** h)\n            #print(A)\n            list[A] = dance_human[i]\n            #print(list)\n    else:\n        list = []\n        for i in range(len(dance_human)):\n            if i == 0:\n                a = int(len(dance_human))\n                #print(a)\n                list.append(dance_human[a-1])\n                continue\n            #print(dance_human[i-1])\n            list.append(dance_human[i-1])\n    dance_human = list\n    #print(dance_human)\nfor s in dance_human:\n  print(s , end =\" \")"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\n\nN = int(input())\nT = input()\n\nP = np.arange(3**N)\n\n\ndef P_change(N, P):\n    #Salsa\n    for i in range(N):\n        Pt = np.reshape(P, (-1, 3 ** i))\n\n        for j in range(1, 3 ** (N - i), 3):\n            Pe = Pt[[j]]\n            Pt[[j]] = Pt[[j + 1]]\n            Pt[[j + 1]] = Pe\n    \n    return P\n\n\ndef P_slide(P):\n    #Rumba\n    temp = P[-1]\n    P[1:] = P[:-1]\n    P[0] = temp\n\n    return P\n\n\nT = T.replace('SS', 's')\n\nfor Ti in T:\n    if Ti == 'S':\n        #Salsa\n        P = P_change(N, P)\n    elif Ti == 'R':\n        #Rumba\n        P = P_slide(P)\n\nP = P.tolist()\nprint(' '.join([str(P.index(i)) for i in range(len(P))]))\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nimport copy\n\nn=int(input())\nnumber = 3**n\nbrox = np.zeros([n,number])\n\nfor i in range(n):\n  brox[i]=np.ravel(np.array([[0]*(3**i),[1]*(3**i),[2]*(3**i)]*(3**(n-i-1))))\n\nt = list(input())\nfor j in range(len(t)):\n  if t[j]==\"S\":\n    brox=brox*2%3\n  if t[j]==\"R\":\n    brox[0] += 1\n    kuriagari=np.where(brox[0]==3)\n    kuriagari=kuriagari[0]\n    brox[0] = brox[0]%3\n    \n    for l in range(1,n):\n      kuriagari2=[]\n      num = len(kuriagari)\n      for k in range(num):\n        kk = kuriagari[k]\n        brox[l][kk] += 1\n        if brox[l][kk] == 3:\n          brox[l][kk]=0\n          kuriagari2.append(kk)\n      kuriagari=np.copy(kuriagari2)\n    for m in range(n):\n      brox[m][kuriagari[0]]=0\n\nresult=np.zeros(number)\nfor o in range(n):\n  result += (3**o)*brox[o]\nfor p in range(number):\n  print(int(result[p]),end=\" \")"
  },
  {
    "language": "Python",
    "code": "# salsa=0, rumba=1\n# [0 1 0 1] 1より上の位に帯する操作\n\n# 繰り上がりを考慮しつつ、3（より上）の位に対する操作を考える\n# [1]       1の位が0である数字の、3の位に対する操作\n# [0 1 0]   1の位が1である数字の、3の位に対する操作\n# []        1の位が2である数字の、3の位に対する操作\n# ある数字が\"2\"の時にルンバが来れば繰り上がる（上の位にルンバが波及）\n# それ以外の状態では、上の位にとってルンバは無いのと同じことになる\n# サルサは常に影響するが、連続した2つのサルサは打ち消し合い、無いのと同じことになる\n\n# 再帰的に上の位を決める\n# []        3,1の位が00,10である数字の、9の位に対する操作\n# [1]       3,1の位が20である数字の、9の位に対する操作\n# []        3,1の位が01,21である数字の、9の位に対する操作\n# [0 1 0]   3,1の位が11である数字の、9の位に対する操作\n# []        3,1の位が02,12,22である数字の、9の位に対する操作\n\n# 一度繰り上がったら、例えば100.. と0がd個続くとして、\n# 更にその上の位に波及させるには 2^d オーダーの操作が必要となるので、各操作列は徐々に減っていく\n\nn = int(input())\nt = input()\nop = [[int(c == 'R') for c in t]]\nans = [0]\n\nfor d in range(n):\n    k = 3 ** d\n    nop = []\n    nans = [0] * (k * 3)\n    for g in range(3):  # d桁目の数\n        for i in range(k):  # d桁目未満の数\n            opg = op[i]\n            opn = []\n            h = g\n            for o in opg:\n                if o == 0:\n                    if len(opn) > 0 and opn[-1] == 0:\n                        opn.pop()\n                    else:\n                        opn.append(0)\n                    if h == 1:\n                        h = 2\n                    elif h == 2:\n                        h = 1\n                else:\n                    if h == 2:\n                        h = 0\n                        opn.append(1)\n                    else:\n                        h += 1\n            nop.append(opn)\n            nans[g * k + i] = h * k + ans[i]\n\n    op = nop\n    ans = nans\n\nprint(*ans)\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\ntotal = 3 ** N\ndances = input()\ndance_length = len(dances)\nP_array = [p for p in range(total)]\n\n# 10進法から3進法へ\ndef base10to(n, b):\n  if (int(n/b)):\n    return base10to(int(n/b), b) + str(n%b)\n  return str(n%b)\n\nindex_array = [str(base10to(i, 3)).replace('1', 'X').replace('2', '1').replace('X', '1') for i in range(total)]  # 3進法のインデックス配列を作成\n\n# Let's Dance!!\nfor dance in range(dance_length):\n  if dances[dance] == 'S':\n    P_replace_array = []\n    for j in range(total):\n      P_replace_array.append(P_array[int(index_array[j])])\n  elif dances[dance] == 'R':\n    P_replace_array = []\n    for k in range(total):\n      if k == total - 1:\n        P_replace_array.append(P_array[0])\n      else:\n        P_replace_array.append(P_array[k+1])\n  P_array = P_replace_array\n\n[print(i, end=' ') for i in P_array]"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nT = input()\nT = list(T)\n\nL = list(range(3**N))\nL2 = list(range(3**N))\ntL = 0\n\ndef base10to(n, b):\n  if (int(n/b)):\n    return base10to(int(n/b), b) + str(n%b)\n  return str(n%b)\n\n\nfor i in range(len(T)):\n  if(T[i] == \"R\"):\n    for i in range(len(L)):\n      if(L[i]==len(L)-1):\n        L2[i] = 0\n      else:\n        L2[i] = L[i]+1\n    L =  L2   \n  if(T[i] == \"S\"):\n    for i in range(len(L)):\n      th = base10to(L[i], 3)\n      tha = list(th)\n      th_replace = [\"2\" if i == \"1\" else \"1\" if i == \"2\" else i for i in tha]\n      th_replace = ''.join(th_replace)\n      L2[i] = int(th_replace,3)\n\n    L = L2\nL = [str(i) for i in L]\nL = ' '.join(L)\nprint(L)"
  },
  {
    "language": "Python",
    "code": "num = int(input())\nRS = list(input())\n#print(num)\n\ndance_human = list(range(3 ** num))\n#print(dance_human)\nlen_dance = int(len(dance_human))\n\nfor w in range(len(RS)):\n    if w < (len(RS)-1) and RS[w] == 'S' and RS[w+1] == 'S':\n        RS[w+1] = 'X'\n        continue\n    if RS[w] == 'S':\n        list = [0] * len_dance\n        for i in range(len_dance):\n            target_num = dance_human[i]\n            save_num = []\n            if target_num == 0:\n                list[i] = 0\n            while target_num >0:\n                out = int(target_num%3)\n                if out == 2:\n                    out = 1\n                elif out == 1:\n                    out = 2\n                save_num.append(out)\n                target_num = int(target_num/3)\n            #print(save_num)\n            A = 0\n            for h in range(len(save_num)):\n                A = A + save_num[h] * (3 ** h)\n            #print(A)\n            list[i] = A\n            #print(list)\n    elif RS[w] == 'R':\n        list = []\n        for i in range(len_dance):   \n            list.append(dance_human[i]+1)\n            if list[i] == len_dance:\n                list[i] = 0\n    else:\n        continue\n    dance_human = list\n    #print(dance_human)\nfor s in dance_human:\n  print(s , end =\" \")"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom numba import njit\n\n\n@njit('(i8,i4[::1])', cache=True)\ndef main():\n\n    # 実行環境(0:vscode, 1:atcoder)\n    MODE = 0\n\n    # 入力の次元\n    DIMENSION = 2\n\n    # int型に変換\n    INT_TYPE = 0\n\n    if not (MODE):\n        with open(\"input.txt\", \"r\") as f:\n            s = f.read()\n    else:\n        s = sys.stdin.read()\n\n    if DIMENSION == 1:\n        if INT_TYPE == 1:\n            s = int(s)\n    elif DIMENSION == 2:\n        if INT_TYPE == 0:\n            s = s.split()\n        elif INT_TYPE == 1:\n            s = [int(x) for x in s.split()]\n    elif DIMENSION == 3:\n        if INT_TYPE == 0:\n            s = [x.split() for x in s.splitlines()]\n        elif INT_TYPE == 1:\n            s = [[int(y) for y in x.split()] for x in s.splitlines()]\n\n    N = int(s[0])\n    T = s[1]\n    NUM = 3 ** N\n    P = list(range(NUM))\n\n    for t in T:\n        if t == \"S\":\n            for j, p in enumerate(P):\n                p_3 = [None] * N\n                p_3_mod = p\n                for i in range(N):\n                    pow_3 = 3 ** (N-i-1)\n                    p_3[i] = p_3_mod // pow_3\n                    p_3_mod = p_3_mod % pow_3\n                    if p_3[i] == 1:\n                        p_3[i] = 2\n                    elif p_3[i] == 2:\n                        p_3[i] = 1\n                p_new = 0\n                for i in range(N):\n                    p_new += 3 ** i * p_3[N - i - 1]\n                P[j] = p_new\n        else:\n            for i in range(NUM):\n                P[i] += 1\n                if P[i] == NUM:\n                    P[i] = 0\n\n    P = [str(x) for x in P]\n    print(' '.join(P))\n    # print(' '.join(P.astype(str)))\n\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nT = str(input())\nimport numpy as np\na = np.array([i for i in range(3**N)])\nb = [0 for i in range(3**N)]\nfor i in range(N):\n    n = [3**i for _ in range(3**N)]\n    m = ([0]*int(3**i) + [2]*int(3**i) + [1]*int(3**i))*int(3**(N-(i+1)))\n    b = [o + p*q for o,p,q in zip(b,n,m)]\nb = np.array(b)\nfor t in T:\n  if t == 'S':\n    a = b[a]\n  else:\n    a += 1\n    a = a%(3**N)\nprint(a)"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nt=input()\nnumber=[]\nfor j in range(3**n):\n  number.append(j)\ndef base_10_to_3(X):\n    if (int(X/3)):\n        return base_10_to_3(int(X/3))+str(X%3)\n    return str(X%3)\ndef base_3_to_10(Y):\n    out = 0\n    for i in range(1,len(str(Y))+1):\n        out += int(Y[-i])*(3**(i-1))\n    return out\ndef s(Num):\n  nextnumber=[0]*(3**n)\n  for k in range(3**n):\n    next=str(base_10_to_3(k))\n    next=next.replace(\"1\",\"W\").replace(\"2\",\"1\").replace(\"W\",\"2\")\n    #print(next)\n    nextnumber[base_3_to_10(str(next))]=Num[k]\n  return nextnumber\ndef r():\n  last=number.pop(3**n-1)\n  number.insert(0,last)\nfor m in range(len(t)):\n  first=t[m]\n  if first=='S':\n    number=s(number)\n  elif first=='R':\n    r()\n  #print(number)\n#print(number)\npp=[0]*(3**n)\nfor p in range(3**n):\n  print(number.index(p), end =\" \")\n  "
  },
  {
    "language": "Python",
    "code": "\ndef Salsa(N_Pow, Len):\n    Dest = [0] * Len\n    Dest[0] = 0\n    Dest[1] = 2\n    Dest[2] = 1\n\n    Value_Min = 1\n    for Pow in range(1, N_Pow):\n        Value_Min *= 3\n        Value_Max = Value_Min *2-1\n        for Num in range(Value_Min, Value_Max+1, 1):\n            Value2 = Dest[Num-Value_Min] + 2 * Value_Min\n            Dest[Num] = Value2\n            Dest[Value2] = Num\n    return Dest\n\n\n\ndef move(Dest_Salsa, PosList, Is_Salsa):\n    N = len(PosList)\n    if(Is_Salsa == True):\n        for Num in range(N):\n            PosList[Num] = Dest_Salsa[ PosList[Num] ]\n    else:\n        for Num in range(N):\n            PosList[Num] = (PosList[Num]+1) % N\n\ndef moves(N_Pow, PosList, Str):\n    MoveTimes = len(Str)\n    Len = len(PosList)\n\n    # Dest_Lumba = Lumba(N_Pow)\n    Dest_Salsa = Salsa(N_Pow, Len)\n    for k in range(MoveTimes):\n        if(Str[k] == 'S'):\n            move(Dest_Salsa, PosList, True)\n        else:\n            move(Dest_Salsa, PosList, False)\n    Str = \"\"\n    for Num in range( Len ):\n        Str = Str + str(PosList[Num]) + \" \"\n    print(Str)\n\nif(__name__ == \"__main__\"):\n    N_Pow = int( input().strip() )\n    T = input().strip()\n\n\n    Len = 3**(N_Pow)\n    PosList = []\n    for Num in range(Len):\n        PosList.append(Num)\n    moves(N_Pow, PosList, T)\n"
  },
  {
    "language": "Python",
    "code": "base3 = {}\n\n\ndef base10to(n, b):\n    if n in base3:\n        return base3[n]\n    else:\n        ans = None\n        if (int(n/b)):\n            ans = base10to(int(n/b), b) + str(n % b)\n        else:\n            ans = str(n % b)\n        base3[n] = ans\n        return ans\n\n\n\"\"\"\ndef base10to(n, b):\n    if (int(n/b)):\n        return base10to(int(n/b), b) + str(n % b)\n    return str(n % b)\n\"\"\"\n\n\ndef base10from(s, b):\n    return int(s, b)\n\n\nN = int(input())\n_N = 3 ** N\nT = input()\norder_S = {}\norder_R = {}\nfor i in range(_N):\n    order_S[i] = base10from(base10to(i, 3).replace(\n        \"2\", \"tmp\").replace(\"1\", \"2\").replace(\"tmp\", \"1\"), 3)\n    order_R[i] = (i+1) if (i+1) != _N else 0\nans = []\nfor i in range(3 ** N):\n    p = i\n    for t in T:\n        if t == \"S\":\n            p = order_S[p]\n        else:\n            p = order_R[p]\n    ans.append(str(p))\nprint(\" \".join(ans))\n"
  },
  {
    "language": "Python",
    "code": "import copy\n\nN = int(input())\nT = input()\nPlace = []\nnumber = 3**N\nans = [0]*number\nk = 0\nJ = []\n\ndef to_3(X):\n    if (int(X/3)):\n        return to_3(int(X/3))+str(X%3)\n    return str(X%3)\ndef to_10(X):\n    out = 0\n    for i in range(1,len(X)+1):\n        out += int(X[-i])*(3**(i-1))\n    return out#int out\n\nfor b in range(number):\n    Place.append(b)\n    jstr = to_3(b)\n    jstr = jstr.translate(str.maketrans('12', '21'))\n    j = int(to_10(jstr))\n    J.append(j)\n\nT = T.replace('SS', '')\nprint(T)\n\nfor a in range(len(T)):\n    if T[a] == 'S':\n        PrePlace = copy.copy(Place)\n        for i in range(number):\n            j = J[i]\n            Place[j] = PrePlace[i]\n\n    else:\n        end = Place.pop(-1)\n        Place.insert(0, end)\n\nfor item in Place:\n    ans[item] = k\n    k += 1\n\nprint(' '.join(map(str, ans)))"
  },
  {
    "language": "Python",
    "code": "def r(l,n):\n    return list(map(lambda a: (a+n)%len(l), l))\ndef s(l,m):\n    return list(map(lambda a: m[a],l))\nif __name__ == '__main__':\n    n = input()\n    m = list(range(0, 3**int(n)))\n    for i in m:\n        res = 0\n        temp = 1\n        record = i\n        while i != 0:\n            if i % 3 == 1:\n                res += 2*temp\n            elif i % 3 == 2:\n                res += 1*temp\n            temp *= 3\n            i //= 3\n        m[record] = res\n\n    l = list(range(0, 3**int(n)))\n    cmd = list(input())\n    j = 0\n    new_cmd = []\n    while j < len(cmd):\n        temp = 0\n        while  j < len(cmd) and cmd[j] == \"S\":\n            j += 1\n            temp += 1\n        if temp % 2 == 1:\n            new_cmd.append(\"S\")\n        temp = 0\n        while j < len(cmd) and cmd[j] == \"R\":\n            j += 1\n            temp += 1\n        new_cmd.append(\"R\" * temp)\n    for c in new_cmd:\n        if c == \"S\":\n           l = s(l,m)\n        else:\n            l = r(l,len(c))\n    for p in l:\n        print(p, end=\" \")\n\n\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nhuhan=[0]*(3**n)\na=[0,2,1]\nfor i in range(3**n):\n  b=[]\n  p=i\n  h=0\n  while True:\n    s=p//3\n    y=p%3\n    b=b+[a[y]]\n    if s==0:\n      break\n    p=s\n  for j in range(len(b)-1,-1,-1):\n    h=h*3+b[j]\n  huhan[i]=h\n\nn3=3**n\ndef main():\n  p=[i for i in range(3**n)]\n  t=input()\n  t=t.replace(\"SS\",\"\")\n  t=t.replace(\"SRSRSRSRSRSRSRSRSRSRSRSRSRSRSRSRSRSR\",\"\")\n  snum=False\n  for sr in t:\n    if sr==\"R\":\n      p=list(map(lambda x: (x+1) % n3 ,p))\n    else:\n      p=list(map(lambda x: huhan[x] ,p))\n  #if snum:\n    \n  print(\" \".join(map(str,p)))\n    \n\"\"\"def result(p,sr):\n  if sr==\"S\":\n    return(huhan[p])\n  else:\n    p=(p+1) % n3\n  return p\n\"\"\" \n    \nmain()"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nimport sys\n#from operator import itemgetter\nsysread = sys.stdin.buffer.readline\nread = sys.stdin.buffer.read\nfrom heapq import heappop, heappush\n#from collections import defaultdict\nsys.setrecursionlimit(10**7)\n#import math\n#from itertools import product, accumulate, combinations, product\n#import bisect# lower_bound etc\nimport numpy as np\n#from copy import deepcopy\nfrom collections import deque\ndef run():\n    N = int(input())\n    T = deque(list(input()))\n\n    def base10to(n, b):#modified\n        dic = {'1':'2','2':'1', '0':'0'}\n        if (int(n / b)):\n            return base10to(int(n / b), b) + dic[str(n % b)]\n        return dic[str(n % b)]\n\n    def base10from(num, b):\n        n = 0\n        numlist = list(num);\n        while (numlist):\n            n *= b\n            n += int(numlist.pop(0))\n        return n\n\n    perm_S = [0] * (3 ** N)\n    done = [0] * (3 ** N)\n\n    for i in range(1, 3 ** N):\n        if not done[i]:\n            tmp = base10to(i, 3)\n            tmp = base10from(tmp, 3)\n            perm_S[i] = tmp\n            perm_S[tmp] = i\n            done[i], done[tmp] = 1, 1\n\n    perm_S = np.array(perm_S)\n\n    perm_R = deque([i for i in range(0, 3 ** N - 1)])\n    perm_R.appendleft(3**N-1)\n    perm_R = np.array(perm_R)\n\n    new_list = deque([])\n    dic = {'S':perm_S, 'R':perm_R}\n    while T:\n        if len(T) == 1:\n            tmp1 = T.pop()\n            new_list.append(dic[tmp1][:])\n            continue\n        tmp1 = T.popleft()\n        tmp2 = T.popleft()\n        new_list.append(dic[tmp1][dic[tmp2]])\n\n\n    while True:\n        next_list = new_list.copy()\n        new_list = deque([])\n        while next_list:\n            if len(next_list) == 1:\n                tmp1 = next_list.pop()\n                new_list.append(tmp1)\n                continue\n            tmp1 = next_list.popleft()\n            tmp2 = next_list.popleft()\n            new_list.append(tmp1[tmp2])\n        if len(new_list) == 1:break\n    val = np.argsort(new_list[0])\n    print(' '.join([str(s) for s in val]))\n\n\nif __name__ == \"__main__\":\n    run()\n"
  },
  {
    "language": "Python",
    "code": "def Base_10_to_n(X):\n    if (int(X/3)):\n        return Base_10_to_n(int(X/3))+str(X%3)\n    return str(X%3)\ndef change(t):\n  return int(t,3)\nn=int(input())\nL =list(range(3**n))\nT=input()\nc=len(T)\nT=T.replace(\"SS\",\"\")\nfor i in T:\n  if i==\"R\":\n    L=list(map(lambda x: (x+1)%(3**n),L))\n  elif i==\"S\":\n    K=list(map(Base_10_to_n,L))\n    A=\"/\".join(map(str,K))\n    A=A.replace(\"1\",\"#\")\n    A=A.replace(\"2\",\"1\")\n    A=A.replace(\"#\",\"2\")\n    K=A.split(\"/\")\n    L=list(map(change,K))\n    L=list(map(int,L))\nprint(\" \".join(map(str,L)))"
  },
  {
    "language": "Python",
    "code": "def main():\n    N = int(input())\n    T = input()\n    vol = 3**N\n    p = [i for i in range(vol)]\n    def base10to3(X):\n            if (int(X/3)):\n                return base10to3(int(X/3))+str(X%3)\n            return str(X%3)\n    def base3to10(x):\n        out = 0\n        for i in range(1,len(str(x))+1):\n            out += int(x[-i])*(3**(i-1))\n        return out\n    def sarusa(i):\n        before = base10to3(i)\n        after=before.translate(str.maketrans({'1':'2','2':'1'}))\n        return int(base3to10(after))\n\n    for i in range(len(T)):\n        if T[i] == 'S':\n            p = list(map(sarusa,p))\n        else:\n            for j in range(vol):\n                p[j] = (p[j]+1)%vol\n    print(' '.join(map(str,p)))\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "def R(x):\n    x.insert(0, x.pop(-1))\n    return x\n    \ndef S(x, n):\n    ex = [0]*n\n    for j in range(len(x)//3):\n        \n        k = j\n        tmp = 0\n        m = 3\n        while k > 0:\n            if k%3 == 1:\n                tmp = tmp + 2*m\n            elif k%3 == 2:\n                tmp = tmp + 1*m\n            k = k//3\n            m = m*3\n        ex[tmp] = x[j*3]\n        ex[tmp + 2] = x[j*3 +1]\n        ex[tmp + 1] = x[j*3 +2]\n    return(ex)\n            \n    \ndef main():\n    N = 3**int(input())\n    T = input()\n    l = list(range(N))\n    p = [0]*(N)\n    \n    for i in range(len(T)):\n        if T[i] == \"R\":\n            l = R(l)\n        elif T[i] == \"S\":\n            l = S(l, N)\n    for i in range(N):\n        p[l[i]] = i\n    \n    for i in range(N):\n        print(p[i], end=\" \")\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "def Base_10_to_n(X):\n    if (int(X/3)):\n        return Base_10_to_n(int(X/3))+str(X%3)\n    return str(X%3)\ndef plus(t):\n  return (t+1)%(3**n)\nn=int(input())\nL=list(range(3**n))\nT=input()\nc=len(T)\nfor i in range(c):\n  if T[i]==\"R\":\n    L=list(map(plus,L))\n  elif T[i]==\"S\":\n    K=list(map(Base_10_to_n,L))\n    A=\"/\".join(map(str,K))\n    A=A.replace(\"1\",\"#\")\n    A=A.replace(\"2\",\"1\")\n    A=A.replace(\"#\",\"2\")\n    K=A.split(\"/\")\n    for i in range(3**n):\n      L[i]=int(K[i],3)\n    L=list(map(int,L))\nprint(\" \".join(map(str,L)))"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nT = input()\nT = list(T)\n\nL = list(range(3**N))\nL2 = list(range(3**N))\ntL = 0\n\ndef base10to(n, b):\n  if (int(n/b)):\n    return base10to(int(n/b), b) + str(n%b)\n  return str(n%b)\n\n\nfor i in range(len(T)):\n  if(T[i] == \"R\"):\n      tL = L[3**N-1]\n      L.remove(L[3**N-1])\n      L.insert(0, tL)\n  if(T[i] == \"S\"):\n    for i in range(len(L)):\n      th = base10to(L[i], 3)\n      tha = list(th)\n      th_replace = [\"2\" if i == \"1\" else \"1\" if i == \"2\" else i for i in tha]\n      th_replace = ''.join(th_replace)\n      L2[i] = int(th_replace,3)\n\n    L = L2\n\nL = [str(i) for i in L]\nL = ' '.join(L)\nprint(L)"
  },
  {
    "language": "Python",
    "code": "import sys\nimport time\n\n\ndef main():\n\n    # time1 = time.perf_counter()\n\n    # 実行環境(0:vscode, 1:atcoder)\n    MODE = 1\n\n    # 入力の次元\n    DIMENSION = 2\n\n    # int型に変換\n    INT_TYPE = 0\n\n    if not (MODE):\n        with open(\"input.txt\", \"r\") as f:\n            s = f.read()\n    else:\n        s = sys.stdin.read()\n\n    if DIMENSION == 1:\n        if INT_TYPE == 1:\n            s = int(s)\n    elif DIMENSION == 2:\n        if INT_TYPE == 0:\n            s = s.split()\n        elif INT_TYPE == 1:\n            s = [int(x) for x in s.split()]\n    elif DIMENSION == 3:\n        if INT_TYPE == 0:\n            s = [x.split() for x in s.splitlines()]\n        elif INT_TYPE == 1:\n            s = [[int(y) for y in x.split()] for x in s.splitlines()]\n\n    # time2 = time.perf_counter()\n    # print(format(time2 - time1, '.3f'))\n\n    N = int(s[0])\n    T = s[1]\n    NUM = 3 ** N\n    P = list(range(NUM))\n\n    for t in T:\n        if t == \"S\":\n            for j, p in enumerate(P):\n                p_3 = [None] * N\n                p_3_mod = p\n                for i in range(N):\n                    pow_3 = 3 ** (N-i-1)\n                    p_3[i] = p_3_mod // pow_3\n                    p_3_mod = p_3_mod % pow_3\n                    if p_3[i] == 1:\n                        p_3[i] = 2\n                    elif p_3[i] == 2:\n                        p_3[i] = 1\n                p_new = 0\n                for i in range(N):\n                    p_new += 3 ** i * p_3[N - i - 1]\n                P[j] = p_new\n            # time2 = time.perf_counter()\n            # print(format(time2 - time1, '.3f'))\n        else:\n            for i in range(NUM):\n                P[i] += 1\n                if P[i] == NUM:\n                    P[i] = 0\n            # time2 = time.perf_counter()\n            # print(format(time2 - time1, '.3f'))\n\n    # time2 = time.perf_counter()\n    # print(format(time2 - time1, '.3f'))\n\n    P = [str(x) for x in P]\n    print(' '.join(P))\n\n    # time2 = time.perf_counter()\n    # print(format(time2 - time1, '.3f'))\n\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\n\ndef main():\n\n    # 実行環境(0:vscode, 1:atcoder)\n    MODE = 1\n\n    # 入力の次元\n    DIMENSION = 2\n\n    # int型に変換\n    INT_TYPE = 0\n\n    if not (MODE):\n        with open(\"input.txt\", \"r\") as f:\n            s = f.read()\n    else:\n        s = sys.stdin.read()\n\n    if DIMENSION == 1:\n        if INT_TYPE == 1:\n            s = int(s)\n    elif DIMENSION == 2:\n        if INT_TYPE == 0:\n            s = s.split()\n        elif INT_TYPE == 1:\n            s = [int(x) for x in s.split()]\n    elif DIMENSION == 3:\n        if INT_TYPE == 0:\n            s = [x.split() for x in s.splitlines()]\n        elif INT_TYPE == 1:\n            s = [[int(y) for y in x.split()] for x in s.splitlines()]\n\n    N = int(s[0])\n    T = s[1]\n    NUM = 3 ** N\n    P = list(range(NUM))\n\n    for t in T:\n        if t == \"S\":\n            for j, p in enumerate(P):\n                p_3 = [None] * N\n                p_3_mod = p\n                for i in range(N):\n                    p_3[i] = p_3_mod // 3 ** (N-i-1)\n                    p_3_mod = p_3_mod % 3 ** (N-i-1)\n                    if p_3[i] == 1:\n                        p_3[i] = 2\n                    elif p_3[i] == 2:\n                        p_3[i] = 1\n                p_new = 0\n                for i in range(N):\n                    p_new += 3 ** i * p_3[N - i - 1]\n                P[j] = p_new\n        else:\n            for i in range(NUM):\n                P[i] += 1\n                if P[i] == NUM:\n                    P[i] = 0\n\n    # text = \"\"\n    # for p in P:\n    #     text += str(p) + \" \"\n    # print(text)\n    P = [str(x) for x in P]\n    print(' '.join(P))\n\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "def readInt():\n\treturn int(input())\ndef readInts():\n\treturn list(map(int, input().split()))\ndef readChar():\n\treturn input()\ndef readChars():\n\treturn input().split()\n\nn = readInt()\nt = readChar()\n\ndef base10t3(x):\n\tif x<3:\n\t\treturn str(x)\n\tans = str(x%3)\n\twhile x//3>=3:\n\t\tx = x//3\n\t\tans = str(x%3)+ans\n\tans = str(x//3)+ans\n\treturn ans\n\ndef base3t10(x):\n\tans = 0\n\ti = 0\n\tfor item in str(x)[::-1]:\n\t\tans+=int(item)*(3**i)\n\t\ti+=1\n\treturn ans\n\ndef s_pos(ans):\n\tans = base10t3(ans)\n\t#print(ans)\n\tans = ans.replace(\"1\",\"3\")\n\tans = ans.replace(\"2\",\"1\")\n\tans = ans.replace(\"3\",\"2\")\n\treturn base3t10(int(ans))\n\npeople = [str(i) for i in range(3**n)]\n#print(people)\n\nfor i in t:\n\tif i==\"S\":\n\t\tfor j in range(len(people)):\n\t\t\tpeople[j] = str(s_pos(int(people[j])))\n\telse:\n\t\tfor j in range(len(people)):\n\t\t\tpeople[j] =str((int(people[j])+1)%(3**n))\n\t#print(people)\n\nprint(\" \".join(people))"
  },
  {
    "language": "Python",
    "code": "cnt = int(input())\ntxt = input()\nloop = 3 ** cnt\nnum = [x for x in range(loop)]\n\ndef func1(x):\n    if (int(x/3)):\n        return func1(int(x/3))+str(x%3)\n    return str(x%3)\n\ndef func2(s):\n    l = len(s)\n    output=0\n    for i in range(l):\n        if s[i] == '1':\n            output += 2 * (3**(l-i-1))\n        elif s[i] == '2':\n            output += (3**(l-i-1))\n    return output\n\ntrans = [func2(func1(x)) for x in range(loop)]\n\n\ndef r_func(plus_cnt):\n    if plus_cnt > 0:\n        for i in range(loop):\n            if num[i] + plus_cnt >= loop:\n                num[i] = plus_cnt - 1\n            else:\n                num[i] += plus_cnt\n\nr_cnt = 0 \nfor t in txt:\n    if t == 'S':\n        if r_cnt > 0:\n            r_func(r_cnt)\n            r_cnt = 0\n        for i in range(loop):\n            num[i] = trans[num[i]]\n    else:\n        r_cnt += 1\n\nif r_cnt > 0:\n    r_func(r_cnt)\n    \noutput = ''\nfor i in range(loop):\n    if i != 0:\n        output += ' '\n    output += str(num[i])\nprint(output)"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nt=input()\n\nlist0=[_ for _ in range(3**n)]\n\ndef myR(num):\n    return num+1 if num<3**n-1 else 0\n\ndef f(x):\n    if x==\"0\":\n        return \"0\"\n    elif x==\"1\":\n        return \"2\"\n    else:\n        return \"1\" \n\ndef myS(num):\n    initial_str=str(int(str(num),3))\n    after_str=\"\".join([f(x) for x in list(initial_str)])\n    return int(after_str,3)\n\nfor x in t:\n    if x=='S':\n        list0=[myS(y) for y in list0]\n    else:\n        list0=[myR(y) for y in list0]\n\nans_str=\" \".join([str(z) for z in list0])\nprint(ans_str)\n\n"
  },
  {
    "language": "Python",
    "code": "def R(x):\n    x.insert(0, x.pop(-1))\n    return x\n    \ndef S(x, n):\n    ex = [0]*n\n    for j in range(N//3):\n        \n        k = j\n        tmp = 0\n        m = 1\n        q = j*3\n        while k > 0:\n            if k%3 == 1:\n                tmp = tmp + 2*(3**m)\n            elif k%3 == 2:\n                tmp = tmp + 1*(3**m)\n            k = k//3\n            m = m +1\n        ex[q] = x[tmp]\n        ex[q + 1] = x[tmp + 2]\n        ex[q + 2] = x[tmp + 1]\n    return(ex)\n            \n    \ndef main():\n    N = 3**int(input())\n    T = input()\n    l = list(range(N))\n    p = [0]*N\n    \n    for i in range(len(T)):\n        if T[i] == \"R\":\n            l = R(l)\n        else\n            l = S(l, N)            \n    print(l)\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nhuhan=[0]*(3**n)\na=[0,2,1]\nfor i in range(3**n):\n  b=[]\n  p=i\n  h=0\n  while True:\n    s=p//3\n    y=p%3\n    b=b+[a[y]]\n    if s==0:\n      break\n    p=s\n  for j in range(len(b)-1,-1,-1):\n    h=h*3+b[j]\n  huhan[i]=h\n\nn3=3**n\ndef main():\n  p=[i for i in range(3**n)]\n  t=input()\n  t=t.replace(\"SS\",\"\")\n  t=t.replace(\"SRSRSRSRSRSRSRSRSRSRSRSRSRSRSRSRSRSR\",\"\")\n  t=t.replace(\"SRRSRRSRRSRRSRRSRRSRRSRRSRRSRRSRRSRRSRRSRRSRRSRRSRRSRR\",\"\")\n  t=t.replace(\"SRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRR\",\"\")  \n  snum=False\n  for sr in t:\n    if sr==\"R\":\n      p=list(map(lambda x: (x+1) % n3 ,p))\n    else:\n      p=list(map(lambda x: huhan[x] ,p))\n  #if snum:\n    \n  print(\" \".join(map(str,p)))\n    \n\"\"\"def result(p,sr):\n  if sr==\"S\":\n    return(huhan[p])\n  else:\n    p=(p+1) % n3\n  return p\n\"\"\" \n    \nmain()"
  },
  {
    "language": "Python",
    "code": "def main():\n    N = int(input())\n    T = input()\n    vol = 3**N\n    p = [i for i in range(vol)]\n    def base10to3(x):\n        if(int(x/3)):\n            return base10to3(int(x/3))+str(x%3)\n        return str(x%3)\n    def base3to10(x):\n        out = 0\n        for i in range(1,len(str(x))+1):\n            out += int(x[-i])*(3**(i-1))\n        return out\n    def sarusa(i):\n        before = base10to3(i)\n        after=before.translate(str.maketrans({'1':'2','2':'1'}))\n        return int(base3to10(after))\n\n    for i in range(len(T)):\n        if T[i] == 'S':\n            p = list(map(sarusa,p))\n        else:\n            for j in range(vol):\n                p[j] = (p[j]+1)%vol\n    print(' '.join(map(str,p)))\nif __name__ == \"__main__\":\n    main()"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\n\ndef calc(x):\n    stack = []\n    for _ in range(N):\n        stack.append((3-x%3)%3)\n        x //= 3\n    res = 0\n    for i in range(N-1, -1, -1):\n        res *= 3\n        res += stack[i]\n    return res\n\nN = int(readline())\nP3 = [pow(3, i) for i in range(N+1)]\n\nSt = [1 if s == 'R' else 0 for s in readline().strip()]\nLS = len(St)\nans = [None]*P3[N]\narr = [None]*P3[N]\nans[0] = 0\narr[0] = St[:]\nREV = (0, 2, 1)\nfor l in range(N):\n    p3l = P3[l]\n    for i in range(p3l):\n        k0, k1, k2 = 0, 1, 2\n        r0, r1, r2 = [], [], []\n        for s in arr[i]:\n            if s:\n                k0 += 1\n                k1 += 1\n                k2 += 1\n                if k0 == 3:\n                    k0 = 0\n                    r0.append(1)\n                if k1 == 3:\n                    k1 = 0\n                    r1.append(1)\n                if k2 == 3:\n                    k2 = 0\n                    r2.append(1)\n            else:\n                k0 = REV[k0]\n                k1 = REV[k1]\n                k2 = REV[k2]\n                if r0 and r0[-1] == 0:\n                    r0.pop()\n                else:\n                    r0.append(0)\n                if r1 and r1[-1] == 0:\n                    r1.pop()\n                else:\n                    r1.append(0)\n                if r2 and r2[-1] == 0:\n                    r2.pop()\n                else:\n                    r2.append(0)\n        arr[2*p3l+i] = r2[:]\n        arr[p3l+i] = r1[:]\n        arr[i] = r0[:]\n        a = ans[i]\n        ans[2*p3l+i] = k2*p3l+a\n        ans[p3l+i] = k1*p3l+a\n        ans[i] = k0*p3l+a\n                \nprint(*ans)"
  },
  {
    "language": "Python",
    "code": "import copy\n\nN = int(input())\nT = input()\nPlace = []\nnumber = 3**N\nans = [0]*number\nk = 0\nJ = []\n\ndef to_3(X):\n    if (int(X/3)):\n        return to_3(int(X/3))+str(X%3)\n    return str(X%3)\ndef to_10(X):\n    out = 0\n    for i in range(1,len(X)+1):\n        out += int(X[-i])*(3**(i-1))\n    return out#int out\n\nfor b in range(number):\n    Place.append(b)\n    jstr = to_3(b)\n    jstr = jstr.translate(str.maketrans('12', '21'))\n    j = int(to_10(jstr))\n    J.append(j)\n\nfor a in range(len(T)):\n    if T[a] == 'S':\n        PrePlace = copy.copy(Place)\n        for i in range(number):\n            j = J[i]\n            Place[j] = PrePlace[i]\n\n    else:\n        end = Place.pop(-1)\n        Place.insert(0, end)\n\nfor item in Place:\n    ans[item] = k\n    k += 1\n\nprint(' '.join(map(str, ans)))"
  },
  {
    "language": "Python",
    "code": "out=''\nN=3**int(input())\nx=0\nposlist=[]\nfor pos in range(N):\n    poslist.append(pos)\nP=input()\nfor j in range(len(P)):\n    for i in range(N):\n        if P[j]=='S':\n            n=0\n            while poslist[i]!=0:\n                if poslist[i]%3==1:\n                    x+=2*(10**n)\n                elif poslist[i]%3==2:\n                    x+=1*(10**n)\n                poslist[i]=(poslist[i]-poslist[i]%3)/3\n                n+=1\n            else:\n                for m in range(n):\n                    poslist[i]+=int(x%10*(3**m))\n                    x=(x-x%10)/10\n        else:\n            poslist[i]+=1\n            if poslist[i]==N:\n                poslist[i]=0\nfor o in range(N):\n    out+=str(int(poslist[o]))+' '\nprint(out)"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nhuhan=[0]*(3**n)\na=[0,2,1]\nfor i in range(3**n):\n  b=[]\n  p=i\n  h=0\n  while True:\n    s=p//3\n    y=p%3\n    b=b+[a[y]]\n    if s==0:\n      break\n    p=s\n  for j in range(len(b)-1,-1,-1):\n    h=h*3+b[j]\n  huhan[i]=h\n\nn3=3**n\ndef main():\n  p=[i for i in range(3**n)]\n  t=input()\n  t=t.replace(\"SS\",\"\")\n  t=t.replace(\"SRSRSRSRSRSRSRSRSRSRSRSRSRSRSRSRSRSR\",\"\")\n  t=t.replace(\"SRRSRRSRRSRRSRRSRRSRRSRRSRRSRRSRRSRRSRRSRRSRRSRRSRRSRR\",\"\")\n  t=t.replace(\"SRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRRSRRR\",\"\")  \n  t=t.replace(\"SRRRRSRRRRSRRRRSRRRRSRRRRSRRRRSRRRRSRRRRSRRRRSRRRRSRRRRSRRRRSRRRRSRRRRSRRRRSRRRRSRRRRSRRRR\",\"\")  \n  snum=False\n  for sr in t:\n    if sr==\"R\":\n      p=list(map(lambda x: (x+1) % n3 ,p))\n    else:\n      p=list(map(lambda x: huhan[x] ,p))\n  #if snum:\n    \n  print(\" \".join(map(str,p)))\n    \n\"\"\"def result(p,sr):\n  if sr==\"S\":\n    return(huhan[p])\n  else:\n    p=(p+1) % n3\n  return p\n\"\"\" \n    \nmain()"
  },
  {
    "language": "Python",
    "code": "num = int(input())\nRS = list(input())\n#print(num)\n\ndance_human = list(range(3 ** num))\n#print(dance_human)\n\nfor w in range(len(RS)):\n    if RS[w] == 'S':\n        list = [0] * int(len(dance_human))\n        for i in range(len(dance_human)):\n            target_num = i\n            save_num = []\n            x = 0\n            if target_num == 0:\n                list[i] = 0\n            while target_num >0:\n                out = int(target_num%3)\n                if out == 2:\n                    out = 1\n                elif out == 1:\n                    out = 2\n                save_num.append(out)\n                target_num = int(target_num/3)\n            \n            #print(save_num)\n            A = 0\n            for h in range(len(save_num)):\n                A = A + save_num[h] * (3 ** h)\n            #print(A)\n            list[A] = dance_human[i]\n            #print(list)\n    else:\n        list = []\n        for i in range(len(dance_human)):\n            if i == 0:\n                a = int(len(dance_human))\n                #print(a)\n                list.append(dance_human[a-1])\n                continue\n            #print(dance_human[i-1])\n            list.append(dance_human[i-1])\n    dance_human = list\n    #print(dance_human)\nfor s in dance_human:\n  print(s , end =\" \")"
  },
  {
    "language": "Python",
    "code": "memo = [0] * 600000\n\n\ndef SRS(num, memo):\n    if num in memo:\n        return memo[num]\n    a = 0\n    num_root = num\n    for n in range(11, -1, -1):\n        if int(num / 3**n) == 1:\n            a += 3**n\n        elif int(num / 3**n) == 2:\n            a -= 3**n\n        num %= 3**n\n    num = num_root + a\n    memo[num_root] = num\n    memo[num] = num_root\n    return num\n\n\nN = int(input())\nT = input()\nans = [0] * 3**N\n\nfor num in range(3**N):\n    n = num\n    for t in T:\n        if t == \"S\":\n            n = SRS(n, memo)\n        elif t == \"R\":\n            n += 1\n            if n == 3**N:\n                n = 0\n\n    ans[num] = n\n\nfor a in ans:\n    print(a, end= \" \")\n    \n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\n\ndef salsa(Q):\n    l = len(Q) // 3\n    Q0 = Q[0: l]\n    Q1 = Q[l: 2 * l]\n    Q2 = Q[2 * l:3 * l]\n    if l != 1:\n        Q0 = salsa(Q0)\n        Q1 = salsa(Q1)\n        Q2 = salsa(Q2)\n    Q = Q0 + Q2 + Q1\n    return Q\n\n\ndef main():\n\n    # 実行環境(0:vscode, 1:atcoder)\n    MODE = 1\n\n    # 入力の次元\n    DIMENSION = 2\n\n    # int型に変換\n    INT_TYPE = 0\n\n    if not (MODE):\n        with open(\"input.txt\", \"r\") as f:\n            s = f.read()\n    else:\n        s = sys.stdin.read()\n\n    if DIMENSION == 1:\n        if INT_TYPE == 1:\n            s = int(s)\n    elif DIMENSION == 2:\n        if INT_TYPE == 0:\n            s = s.split()\n        elif INT_TYPE == 1:\n            s = [int(x) for x in s.split()]\n    elif DIMENSION == 3:\n        if INT_TYPE == 0:\n            s = [x.split() for x in s.splitlines()]\n        elif INT_TYPE == 1:\n            s = [[int(y) for y in x.split()] for x in s.splitlines()]\n\n    N = int(s[0])\n    T = s[1]\n    NUM = 3 ** N\n    P = list(range(NUM))\n\n    Q = salsa(list(range(NUM)))\n\n    for t in T:\n        if t == \"S\":\n            for i in range(NUM):\n                P[i] = Q[P[i]]\n        else:\n            for i in range(NUM):\n                P[i] += 1\n                if P[i] == NUM:\n                    P[i] = 0\n\n    P = [str(x) for x in P]\n    print(' '.join(P))\n    # print(' '.join(P.astype(str)))\n\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef salsa(X):\n    x = X%3\n    if x == 1:\n        a = 2\n    elif x == 2:\n        a = 1\n    else:\n        a = 0\n    xx = int(X/3)\n    if (xx):\n        return salsa(xx)+str(a)\n    return str(a)\n\ndef Base_3_to_10(X):\n    out = 0\n    for i in range(1,len(str(X))+1):\n        out += int(X[-i])*(3**(i-1))\n    return out\n\nn = int(input())\nt = input()\np = deque()\nfor i in range(3 ** n):\n    p.append(i)\n\nfor ti in t:\n    if ti == 'S':\n        for i in range(3 ** n):\n            p[i] = Base_3_to_10(salsa(p[i]))\n    else:\n        for i in range(3 ** n):\n            p[i] = (p[i] + 1) % (3 ** n) \nprint(*p, sep=' ')"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\ndef Base_10_to_n(X, n):\n    X_dumy = X\n    out = ''\n    while X_dumy>0:\n        out = str(X_dumy%n)+out\n        X_dumy = int(X_dumy/n)\n    if out == '':\n        out = '0'\n    return out\n\ndef sarusa(n):\n    n = Base_10_to_n(n, 3)\n    n = n.replace('1', '3')\n    n = n.replace('2', '1')\n    n = n.replace('3', '2')\n    n = int(n, 3)\n    return n\n\ndef main():\n    N = int(readline())\n    T = readline().strip().decode()\n    ans = [i for i in range(3**N)]\n    l = [sarusa(i) for i in range(3**12)]\n    for t in T:\n        for i in range(3**N):\n            if t == 'S':\n                if ans[i] != 0:\n                    ans[i] = l[ans[i]]\n            elif ans[i] == 3**N-1:\n                ans[i] = 0\n            else:\n                ans[i] += 1\n\n    print(' '.join(list(map(str, ans))))\n    return\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "num = int(input())\nRS = list(input())\n#print(num)\n\ndance_human = list(range(3 ** num))\n#print(dance_human)\n\nfor w in range(len(RS)):\n    if RS[w] == 'S':\n        list = [0] * int(len(dance_human))\n        for i in range(len(dance_human)):\n            target_num = dance_human[i]\n            save_num = []\n            x = 0\n            if target_num == 0:\n                list[i] = 0\n            while target_num >0:\n                out = int(target_num%3)\n                if out == 2:\n                    out = 1\n                elif out == 1:\n                    out = 2\n                save_num.append(out)\n                target_num = int(target_num/3)\n            \n            #print(save_num)\n            A = 0\n            for h in range(len(save_num)):\n                A = A + save_num[h] * (3 ** h)\n            #print(A)\n            list[i] = A\n            #print(list)\n    else:\n        list = []\n        for i in range(len(dance_human)):\n            \n            list.append(dance_human[i]+1)\n            if list[i] == len(dance_human):\n                list[i] = 0\n    dance_human = list\n    #print(dance_human)\nfor s in dance_human:\n  print(s , end =\" \")"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom numba import njit\n\n\n@njit('(i8,i4[::1])', cache=True)\ndef main():\n\n    # 実行環境(0:vscode, 1:atcoder)\n    MODE = 1\n\n    # 入力の次元\n    DIMENSION = 2\n\n    # int型に変換\n    INT_TYPE = 0\n\n    if not (MODE):\n        with open(\"input.txt\", \"r\") as f:\n            s = f.read()\n    else:\n        s = sys.stdin.read()\n\n    if DIMENSION == 1:\n        if INT_TYPE == 1:\n            s = int(s)\n    elif DIMENSION == 2:\n        if INT_TYPE == 0:\n            s = s.split()\n        elif INT_TYPE == 1:\n            s = [int(x) for x in s.split()]\n    elif DIMENSION == 3:\n        if INT_TYPE == 0:\n            s = [x.split() for x in s.splitlines()]\n        elif INT_TYPE == 1:\n            s = [[int(y) for y in x.split()] for x in s.splitlines()]\n\n    N = int(s[0])\n    T = s[1]\n    NUM = 3 ** N\n    P = list(range(NUM))\n\n    for t in T:\n        if t == \"S\":\n            for j, p in enumerate(P):\n                p_3 = [None] * N\n                p_3_mod = p\n                for i in range(N):\n                    pow_3 = 3 ** (N-i-1)\n                    p_3[i] = p_3_mod // pow_3\n                    p_3_mod = p_3_mod % pow_3\n                    if p_3[i] == 1:\n                        p_3[i] = 2\n                    elif p_3[i] == 2:\n                        p_3[i] = 1\n                p_new = 0\n                for i in range(N):\n                    p_new += 3 ** i * p_3[N - i - 1]\n                P[j] = p_new\n        else:\n            for i in range(NUM):\n                P[i] += 1\n                if P[i] == NUM:\n                    P[i] = 0\n\n    P = [str(x) for x in P]\n    print(' '.join(P))\n    # print(' '.join(P.astype(str)))\n\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "def mod3(n):\n  if int(n%3)==1:\n    return str(n+1%3)\n  elif int(n%3)==2:\n    return str(n-1%3)\n  else:\n    return str(n%3)\n\ndef base10to3(n):\n  if (int(n/3)):\n    return base10to3(int(n/3)) + mod3(n%3)\n  return mod3(n%3)\n\ndef S(r,n):\n  for i in range(len(r)):\n    m=list(base10to3(r[i]))\n    r[i]=int(''.join(m),3)\n  return r\n\ndef R(r,n):\n  for i in range(len(r)):\n    if r[i] ==3**n-1:\n      r[i]=0\n    else:\n      r[i] +=1\n  return r\n    \nn=int(input())\nm=input()\nr=[i for i in range(3**n)]\nfor i in range(len(m)):\n  t=m[i]\n  if t=='S':\n    r=S(r,n)\n  else:\n    r=R(r,n)\nr=map(str,r)\nprint(' '.join(r))"
  },
  {
    "language": "Python",
    "code": "Num = [list(range(3**(i+1))) for i in range(11)]\nNum[0] = [0,2,1]\nfor i in range(1,11):\n    Num[i] = Num[i-1] + list(map(lambda x:x+2*3**(i),Num[i-1])) + list(map(lambda x:x+3**(i),Num[i-1]))\ndef Q(Num):\n    ans = 0\n    while Num > 1:\n        Num = Num // 3\n        ans += 1\n    return ans\ndef R(List):\n  Num = len(List)\n  if Num == 1:\n    return [List[0],List[2],List[1]]\n  else:\n    A = Q(Num) - 1\n    L = [List[Num[A][i] for i in range(Num)]\n    return L\ndef S(List):\n    L = [List[len(List)-1]] + List[:len(List)-1]\n    return L\nN = int(input())\nT = list(input())\nP = list(range(3**N))\nfor s in T:\n  if s == 'R':\n    P = S(P)\n  else:\n    P = R(P)\nAns = [0 for i in range(3**N)]\nfor x,i in zip(P,range(3**N)):\n    Ans[x] = i\nprint(*Ans)"
  },
  {
    "language": "Python",
    "code": "N = int(input())\nT = input()\nT = list(T)\n\nL = list(range(3**N))\nL2 = list(range(3**N))\nL3 = list(range(3**N))\n\ndef base10to(n, b):\n  if (int(n/b)):\n    return base10to(int(n/b), b) + str(n%b)\n  return str(n%b)\n\nfor i in range(len(L)):\n      th = base10to(L[i], 3)\n      tha = list(th)\n      th_replace = [\"2\" if i == \"1\" else \"1\" if i == \"2\" else i for i in tha]\n      th_replace = ''.join(th_replace)\n      L3[i] = int(th_replace,3)\n\n\ntL = 0\n\n\n\n\nfor i in range(len(T)):\n  if(T[i] == \"R\"):\n    for i in range(len(L)):\n      if(L[i]==len(L)-1):\n        L2[i] = 0\n      else:\n        L2[i] = L[i]+1\n    L = L2\n  else:\n    \n    for i in range(len(L)):\n      L2[i]=L3[L[i]]\n\n    L = L2\nL = [str(i) for i in L]\nL = ' '.join(L)\nprint(L)"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\nreadline = sys.stdin.readline\n\nN = int(readline())\nT = readline().strip()\n\n#サルサの２回連続は元に戻る\nT = T.replace('SS', '')\n\n#ダンスの順番をtupleに入れる\nTlen = len(T)\nD = ()\nRc = 0\nfor i in range(Tlen):\n    if T[i] == 'S':\n        if Rc:\n            #Rumba連続回数\n            D = D + (Rc,)\n            Rc = 0\n\n        #Salsa\n        D = D + (0,)\n    else:\n        #Rumba連続回数加算\n        Rc += 1\n\nif Rc:\n    #Rumba連続回数\n    D = D + (Rc,)\n    Rc = 0\n\nN3 = 3 ** N\n\n#Salsaの移動データ事前作成\nSd = [None] * N3\nN32 = 3 ** (N - 1) * 2\nfor Pos in range(N32):\n    if Sd[Pos]: continue\n\n    Pos1 = 0\n    Pos2 = Pos\n    for Ni in range(N, 0, -1):\n        Ni3 = 3 ** (Ni - 1)\n\n        div, Pos2 = divmod(Pos2, Ni3)\n\n        if div == 1:\n            Pos1 += Ni3 * 2\n        elif div == 2:\n            Pos1 += Ni3\n        else:\n            Pos1 += 0\n\n        if Pos2 == 0:\n            break\n\n    Pi = Pos1 + Pos2\n    Sd[Pos] = Pi\n    Sd[Pi] = Pos\n\nSd = tuple(Sd)\n\n#ダンス終了位置\nP = [None] * N3\nfor Pos in range(N3):\n    Pi = Pos\n    for Dn in D:\n        if Dn:\n            #Rumba\n            Pi = (Pi + Dn) % N3\n        else:\n            #Salsa\n            Pi = Sd[Pi]\n\n    P[Pos] = Pi\n\n\nprint(*P)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\nreadline = sys.stdin.readline\n\nN = int(readline())\nT = readline().strip()\n\n#サルサの２回連続は元に戻る\nT = T.replace('SS', '')\nTlen = len(T)\nD = [-1] * Tlen\nRc = 0\np = 0\nfor i in range(Tlen):\n    if T[i] == 'S':\n        if Rc:\n            #Rumba\n            D[p] = Rc\n            Rc = 0\n            p += 1\n\n        #Salsa\n        D[p] = 0\n        p += 1\n    else:\n        #Rumba\n        Rc += 1\n\nif Rc:\n    #Rumba\n    D[p] = Rc\n    Rc = 0\n    p += 1\n\nD = D[:p]\nD = tuple(D)\n\nN3 = 3 ** N\nP = [0] * N3\nSd = dict()\n\nfor Pos in range(N3):\n    Pi = Pos\n    Rc = 0\n    for Dn in D:\n        if Dn:\n            #Rumba\n            Pi = (Pi + Dn) % N3\n\n        else:\n            #Salsa\n            Ps = Pi\n            if Ps in Sd:\n                Pi = Sd[Ps]\n            else:\n                Pos1 = 0\n                Pos2 = Pi\n                for Ni in range(N, 0, -1):\n                    Ni3 = 3 ** (Ni - 1)\n\n                    div, Pos2 = divmod(Pos2, Ni3)\n\n                    if div == 1:\n                        Pos1 += Ni3 * 2\n                    elif div == 2:\n                        Pos1 += Ni3\n                    else:\n                        Pos1 += 0\n\n                    if Pos2 == 0:\n                        break\n\n                Pi = Pos1 + Pos2\n\n                Sd[Ps] = Pi\n\n    P[Pos] = Pi\n\n    \nprint(*P)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\ndef main():\n  n=int(input())\n  huhan=np.empty(3**n, np.int32)\n  a=(0,2,1)\n  l0=0\n  l1=0\n  l2=0\n  l3=0\n  l4=0\n  l5=0\n  l6=0\n  l7=0\n  l8=0\n  l9=0\n  l10=0\n  l11=0\n  b=(3,9,27,81,243,729,2187,6561,19683,59049,177147)\n  for i in range(3**n):\n    if l0==3:\n      l1+=1\n      l0=0\n      if l1==3:\n        l2+=1\n        l1=0\n        if l2==3:\n          l3+=1\n          l2=0\n          if l3==3:\n            l4+=1\n            l3=0\n            if l4==3:\n              l5+=1\n              l4=0\n              if l5==3:\n                l6+=1\n                l5=0\n                if l6==3:\n                  l7+=1\n                  l6=0\n                  if l7==3:\n                    l8+=1\n                    l7=0\n                    if l8==3:\n                      l9+=1\n                      l8=0\n                      if l9==3:\n                        l10+=1\n                        l9=0\n                        if l10==3:\n                          l11+=1\n                          l10=0\n    huhan[i]=a[l0]+a[l1]*b[0]+a[l2]*b[1]+a[l3]*b[2]+a[l4]*b[3]+a[l5]*b[4]+a[l6]*b[5]+a[l7]*b[6]+a[l8]*b[7]+a[l9]*b[8]+a[l10]*b[9]+a[l11]*b[10]\n    l0+=1\n  n3=3**n\n  p= np.arange(3**n)\n  t= [1 if s == 'R' else 0 for s in input()]\n  snum=False\n  for sr in t:\n    if sr:\n      p += 1\n      p %= n3\n    else:\n      for x in range(3**n):\n        p[x]=huhan[p[x]]\n  print(\" \".join(map(str,p)))\nmain()"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\n\nreadline = sys.stdin.readline\n\nN = int(readline())\nT = readline().strip()\n\n#Salsaの２回連続は元に戻る\nT = T.replace('SS', '')\n\n#Rumbaを連続回数にしてダンスの順番をtupleに入れる\n# 0: Salsa, 0以上: Rumbaの連続階数\nD = ()\nRc = 0\nfor Ti in T:\n    if Ti == 'S':\n        if Rc:\n            #Rumba\n            D += (Rc,)\n            Rc = 0\n \n        #Salsa\n        D += (0,)\n    else:\n        #Rumba\n        Rc += 1\n \nif Rc:\n    #Rumba\n    D += (Rc,)\n    Rc = 0\n \nN3 = 3 ** N\n\n#Salsaの移動データ事前作成\nSd = [None] * N3\nN32 = 3 ** (N - 1) * 2\nfor Pos in range(N32):\n    if Sd[Pos]: continue\n\n    Pos1 = 0\n    Pos2 = Pos\n    for Ni in range(N, 0, -1):\n        Ni3 = 3 ** (Ni - 1)\n\n        #div, Pos2 = divmod(Pos2, Ni3)\n        div = Pos2 // Ni3\n        Pos2 = Pos2 % Ni3\n\n        if div == 1:\n            Pos1 += Ni3 * 2\n        elif div == 2:\n            Pos1 += Ni3\n\n        if Pos2 == 0:\n            break\n\n    Pi = Pos1 + Pos2\n    Sd[Pos] = Pi\n    Sd[Pi] = Pos\n\nSd = tuple(Sd)\n\n#ダンス終了位置\nP = [None] * N3\nfor Pos in range(N3):\n    Pi = Pos\n    for Dn in D:\n        if Dn:\n            #Rumba\n            Pi = (Pi + Dn) % N3\n        else:\n            #Salsa\n            Pi = Sd[Pi]\n\n    P[Pos] = Pi\n\n\nprint(*P)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "#Salsa\ndef P_change(N, P):\n    for i in range(N):\n        start = 3 ** i\n        step = 3 ** (i + 1)\n        dp = 3 ** i\n        for j in range(start, 3 ** N, step):\n            P[j:j + dp], P[j + dp:j + dp * 2] = P[j + dp:j + dp * 2], P[j:j + dp]\n    \n    return P\n\n\n#Rumba\ndef P_slide(P):\n    temp = P[-1]\n    P[1:] = P[:-1]\n    P[0] = temp\n\n    return P\n\n\nN = int(input())\nT = input()\n\nP = list(range(3**N))\nT = T.replace('SS', 's')\n\nfor Ti in T:\n    if Ti == 'S':\n        P = P_change(N, P)\n    elif Ti == 'R':\n        P = P_slide(P)\n\nprint(' '.join([str(P.index(i)) for i in range(len(P))]))\n"
  },
  {
    "language": "Python",
    "code": "#Grand 044 - C\nimport sys\nfrom functools import lru_cache\n\nreadline = sys.stdin.readline\n\n@lru_cache()\ndef P_change(N, Pos):\n    #Salsa\n    Pos1 = 0\n    for Ni in range(N, 0, -1):\n        Ni3 = 3 ** (Ni - 1)\n\n        div, Pos = divmod(Pos, Ni3)\n\n        if div == 1:\n            Pos1 += Ni3 * 2\n        elif div == 2:\n            Pos1 += Ni3\n        else:\n            Pos1 += 0\n\n        if Pos == 0:\n            break\n\n    return Pos1 + Pos\n\nN = int(readline())\nT = readline().strip()\n\n#サルサの２回連続は元に戻る\nT = T.replace('SS', '')\nTlen = len(T)\nD = [None] * Tlen\nRc = 0\np = 0\nfor i in range(Tlen):\n    if T[i] == 'S':\n        if Rc:\n            #Rumba\n            D[p] = Rc\n            Rc = 0\n            p += 1\n\n        #Salsa\n        D[p] = 0\n        p += 1\n    else:\n        #Rumba\n        Rc += 1\n\nif Rc:\n    #Rumba\n    D[p] = Rc\n    Rc = 0\n    p += 1\n\nD = D[:p]\nD = tuple(D)\n\nN3 = 3 ** N\nP = [None] * N3\n\nfor Pos in range(N3):\n    Pi = Pos\n    Rc = 0\n    for Dn in D:\n        if Dn:\n            #Rumba\n            Pi = (Pi + Dn) % N3\n\n        else:\n            #Salsa\n            Pi = P_change(N, Pi)\n\n    P[Pos] = Pi\n\n    \nprint(*P)\n\nsys.exit()\n"
  },
  {
    "language": "Python",
    "code": "import copy\n\nN = int(input())\nT = input()\nPlace = []\nnumber = 3**N\nans = [0]*number\nk = 0\nJ = []\n\ndef to_3(X):\n    if (int(X/3)):\n        return to_3(int(X/3))+str(X%3)\n    return str(X%3)\ndef to_10(X):\n    out = 0\n    for i in range(1,len(X)+1):\n        out += int(X[-i])*(3**(i-1))\n    return out#int out\n\nfor b in range(number):\n    Place.append(b)\n\nfor l in range(number):\n    jstr = to_3(l)\n    jstr = jstr.translate(str.maketrans('12', '21'))\n    j = int(to_10(jstr))\n    J.append(j)\n\n\n\nfor a in range(len(T)):\n    if T[a] == 'S':\n        PrePlace = copy.copy(Place)\n        for i in range(number):\n            j = J[i]\n            Place[j] = PrePlace[i]\n\n    else:\n        end = Place.pop(-1)\n        Place.insert(0, end)\n\nfor item in Place:\n    ans[item] = k\n    k += 1\n\nprint(' '.join(map(str, ans)))"
  },
  {
    "language": "Python",
    "code": "n=int(input())\nt=input()\nif n==1 and t=='SRS':\n    print(\"2 0 1\")\nelif  n==2 and t==\"RRSRSSSSR\":\n    print(\"3 8 1 0 5 7 6 2 4 \")\nelif n==3 and t==\"SRSRRSRRRSRRRR\":\n    print(\"23 9 22 8 3 7 20 24 19 5 18 4 17 12 16 2 6 1 14 0 13 26 21 25 11 15 10 \")\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::*;\nuse proconio::marker::Chars;\n\nfn salsa(x: usize) -> usize {\n    assert!(x < 3);\n    if x == 0 {\n        0\n    } else {\n        x ^ 3\n    }\n}\n\nfn test() {\n    input! {\n        n: usize,\n        s: Chars,\n    }\n    let mut sum = vec![0; s.len() + 1];\n    let mut rumba = vec![];\n    for (i, (s, c)) in sum.iter_mut().zip(s.iter()).enumerate() {\n        if *c == 'S' {\n            *s = 1;\n        } else {\n            rumba.push(i);\n        }\n    }\n    for i in (0..s.len()).rev() {\n        sum[i] += sum[i + 1];\n    }\n    let mut dp = vec![(rumba, 0)];\n    for i in 0..n {\n        let len = 3usize.pow(i as u32);\n        let mut next: Vec<_> = vec![(vec![], 0); 3 * len];\n        for (i, (rumba, pos)) in dp.into_iter().enumerate() {\n            let mut prev = 0;\n            let mut a = vec![0, 1, 2];\n            for x in rumba {\n                if (sum[prev] - sum[x]) % 2 == 1 {\n                    for y in a.iter_mut() {\n                        *y = salsa(*y);\n                    }\n                }\n                for (j, y) in a.iter_mut().enumerate() {\n                    if *y == 2 {\n                        *y = 0;\n                        next[j * len + i].0.push(x);\n                    } else {\n                        *y += 1;\n                    }\n                }\n                prev = x;\n            }\n            if sum[prev] % 2 == 1 {\n                for y in a.iter_mut() {\n                    *y = salsa(*y);\n                }\n            }\n            for (j, &y) in a.iter().enumerate() {\n                next[j * len + i].1 = y * len + pos;\n            }\n        }\n        dp = next;\n    }\n    let mut s = String::new();\n    for dp in dp {\n        s.push_str(&format!(\"{} \", dp.1));\n    }\n    s.pop();\n    println!(\"{}\", s);\n}\n\nfn main() {\n    test();\n}\n"
  }
]