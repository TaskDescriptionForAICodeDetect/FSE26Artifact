[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid write(int **matrix, int x, int y, int v) {\n    matrix[x][y] = v;\n}\n\nvoid copy(int **matrix, int x1, int y1, int x2, int y2) {\n    matrix[x2][y2] = matrix[x1][y1];\n}\n\nvoid swap_rows(int **matrix, int r1, int r2, int N) {\n    for (int i = 0; i < N; i++) {\n        int temp = matrix[r1][i];\n        matrix[r1][i] = matrix[r2][i];\n        matrix[r2][i] = temp;\n    }\n}\n\nvoid swap_cols(int **matrix, int c1, int c2, int N) {\n    for (int i = 0; i < N; i++) {\n        int temp = matrix[i][c1];\n        matrix[i][c1] = matrix[i][c2];\n        matrix[i][c2] = temp;\n    }\n}\n\nvoid rotate(int **matrix, int N) {\n    int **temp = (int **)malloc(N * sizeof(int *));\n    for (int i = 0; i < N; i++) {\n        temp[i] = (int *)malloc(N * sizeof(int));\n    }\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            temp[j][N - 1 - i] = matrix[i][j];\n        }\n    }\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            matrix[i][j] = temp[i][j];\n        }\n    }\n    \n    for (int i = 0; i < N; i++) {\n        free(temp[i]);\n    }\n    free(temp);\n}\n\nvoid reflect_horizontal(int **matrix, int N) {\n    for (int i = 0; i < N / 2; i++) {\n        swap_rows(matrix, i, N - 1 - i, N);\n    }\n}\n\nvoid reflect_vertical(int **matrix, int N) {\n    for (int i = 0; i < N / 2; i++) {\n        swap_cols(matrix, i, N - 1 - i, N);\n    }\n}\n\nint main() {\n    int N, Q;\n    scanf(\"%d %d\", &N, &Q);\n    \n    int **matrix = (int **)malloc(N * sizeof(int *));\n    for (int i = 0; i < N; i++) {\n        matrix[i] = (int *)malloc(N * sizeof(int));\n        for (int j = 0; j < N; j++) {\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n    \n    char command[20];\n    int x1, y1, x2, y2, v;\n    \n    for (int q = 0; q < Q; q++) {\n        scanf(\"%s\", command);\n        if (strcmp(command, \"WRITE\") == 0) {\n            scanf(\"%d %d %d\", &x1, &y1, &v);\n            write(matrix, x1, y1, v);\n        } else if (strcmp(command, \"CPY\") == 0) {\n            scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n            copy(matrix, x1, y1, x2, y2);\n        } else if (strcmp(command, \"SWAP_ROW\") == 0) {\n            scanf(\"%d %d\", &x1, &x2);\n            swap_rows(matrix, x1, x2, N);\n        } else if (strcmp(command, \"SWAP_COL\") == 0) {\n            scanf(\"%d %d\", &y1, &y2);\n            swap_cols(matrix, y1, y2, N);\n        } else if (strcmp(command, \"ROTATE\") == 0) {\n            rotate(matrix, N);\n        } else if (strcmp(command, \"REFLECT_H\") == 0) {\n            reflect_horizontal(matrix, N);\n        } else if (strcmp(command, \"REFLECT_V\") == 0) {\n            reflect_vertical(matrix, N);\n        }\n    }\n    \n    int K;\n    scanf(\"%d\", &K);\n    int *a = (int *)malloc(K * sizeof(int));\n    int *b = (int *)malloc(K * sizeof(int));\n    int *c = (int *)malloc(K * sizeof(int));\n    \n    for (int i = 0; i < K; i++) {\n        scanf(\"%d %d %d\", &a[i], &b[i], &c[i]);\n    }\n    \n    long long hash = 0;\n    for (int i = 0; i < K; i++) {\n        hash += matrix[a[i]][b[i]] * c[i];\n    }\n    \n    printf(\"%lld\\n\", hash);\n    \n    for (int i = 0; i < N; i++) {\n        free(matrix[i]);\n    }\n    free(matrix);\n    free(a);\n    free(b);\n    free(c);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:27:33"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvoid processCommands(int N, int Q, vector<vector<int>>& matrix) {\n    while (Q--) {\n        string cmd;\n        cin >> cmd;\n        if (cmd == \"WRITE\") {\n            int r, c, v;\n            cin >> r >> c >> v;\n            matrix[r][c] = v;\n        } else if (cmd == \"CPY\") {\n            int r1, c1, r2, c2;\n            cin >> r1 >> c1 >> r2 >> c2;\n            matrix[r2][c2] = matrix[r1][c1];\n        } else if (cmd == \"SWAP_ROW\") {\n            int r1, r2;\n            cin >> r1 >> r2;\n            swap(matrix[r1], matrix[r2]);\n        } else if (cmd == \"SWAP_COL\") {\n            int c1, c2;\n            cin >> c1 >> c2;\n            for (int i = 0; i < N; ++i) {\n                swap(matrix[i][c1], matrix[i][c2]);\n            }\n        } else if (cmd == \"ROT\") {\n            vector<vector<int>> temp(N, vector<int>(N));\n            for (int i = 0; i < N; ++i) {\n                for (int j = 0; j < N; ++j) {\n                    temp[j][N - 1 - i] = matrix[i][j];\n                }\n            }\n            matrix = temp;\n        } else if (cmd == \"HFLIP\") {\n            for (int i = 0; i < N; ++i) {\n                reverse(matrix[i].begin(), matrix[i].end());\n            }\n        } else if (cmd == \"VFLIP\") {\n            reverse(matrix.begin(), matrix.end());\n        }\n    }\n}\n\nint computeHash(int N, const vector<vector<int>>& matrix, const vector<int>& coeffs) {\n    int hash = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            hash += matrix[i][j] * coeffs[i * N + j];\n        }\n    }\n    return hash;\n}\n\nint main() {\n    int N, Q, K;\n    cin >> N >> Q >> K;\n    vector<vector<int>> matrix(N, vector<int>(N, 0));\n    processCommands(N, Q, matrix);\n    vector<int> coeffs(K);\n    for (int i = 0; i < K; ++i) {\n        cin >> coeffs[i];\n    }\n    cout << computeHash(N, matrix, coeffs) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:27:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class MatrixOperations {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[][] matrix = new int[N][N];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                matrix[i][j] = scanner.nextInt();\n            }\n        }\n        \n        int Q = scanner.nextInt();\n        for (int q = 0; q < Q; q++) {\n            String command = scanner.next();\n            switch (command) {\n                case \"WRITE\":\n                    int x = scanner.nextInt();\n                    int y = scanner.nextInt();\n                    int value = scanner.nextInt();\n                    matrix[x][y] = value;\n                    break;\n                case \"COPY\":\n                    int x1 = scanner.nextInt();\n                    int y1 = scanner.nextInt();\n                    int x2 = scanner.nextInt();\n                    int y2 = scanner.nextInt();\n                    matrix[x2][y2] = matrix[x1][y1];\n                    break;\n                case \"SWAP_ROW\":\n                    int a = scanner.nextInt();\n                    int b = scanner.nextInt();\n                    int[] tempRow = matrix[a];\n                    matrix[a] = matrix[b];\n                    matrix[b] = tempRow;\n                    break;\n                case \"SWAP_COL\":\n                    int c = scanner.nextInt();\n                    int d = scanner.nextInt();\n                    for (int i = 0; i < N; i++) {\n                        int temp = matrix[i][c];\n                        matrix[i][c] = matrix[i][d];\n                        matrix[i][d] = temp;\n                    }\n                    break;\n                case \"ROTATE\":\n                    int[][] rotated = new int[N][N];\n                    for (int i = 0; i < N; i++) {\n                        for (int j = 0; j < N; j++) {\n                            rotated[j][N - 1 - i] = matrix[i][j];\n                        }\n                    }\n                    matrix = rotated;\n                    break;\n                case \"REFLECT_H\":\n                    for (int i = 0; i < N / 2; i++) {\n                        int[] temp = matrix[i];\n                        matrix[i] = matrix[N - 1 - i];\n                        matrix[N - 1 - i] = temp;\n                    }\n                    break;\n                case \"REFLECT_V\":\n                    for (int i = 0; i < N; i++) {\n                        for (int j = 0; j < N / 2; j++) {\n                            int temp = matrix[i][j];\n                            matrix[i][j] = matrix[i][N - 1 - j];\n                            matrix[i][N - 1 - j] = temp;\n                        }\n                    }\n                    break;\n            }\n        }\n        \n        int K = scanner.nextInt();\n        long hash = 0;\n        for (int k = 0; k < K; k++) {\n            int i = scanner.nextInt();\n            int j = scanner.nextInt();\n            int c = scanner.nextInt();\n            hash += (long) matrix[i][j] * c;\n        }\n        System.out.println(hash);\n    }\n}",
    "timestamp": "2025-08-05 21:28:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MatrixOperations {\n    private int[][] matrix;\n    private int N;\n\n    public MatrixOperations(int N) {\n        this.N = N;\n        matrix = new int[N][N];\n    }\n\n    public void write(int row, int col, int value) {\n        matrix[row][col] = value;\n    }\n\n    public void copy(int srcRow, int srcCol, int destRow, int destCol) {\n        matrix[destRow][destCol] = matrix[srcRow][srcCol];\n    }\n\n    public void swapRows(int row1, int row2) {\n        int[] temp = matrix[row1];\n        matrix[row1] = matrix[row2];\n        matrix[row2] = temp;\n    }\n\n    public void swapColumns(int col1, int col2) {\n        for (int i = 0; i < N; i++) {\n            int temp = matrix[i][col1];\n            matrix[i][col1] = matrix[i][col2];\n            matrix[i][col2] = temp;\n        }\n    }\n\n    public void rotateClockwise() {\n        int[][] rotated = new int[N][N];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                rotated[j][N-1-i] = matrix[i][j];\n            }\n        }\n        matrix = rotated;\n    }\n\n    public void reflectHorizontal() {\n        for (int i = 0; i < N / 2; i++) {\n            swapRows(i, N - 1 - i);\n        }\n    }\n\n    public void reflectVertical() {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N / 2; j++) {\n                int temp = matrix[i][j];\n                matrix[i][j] = matrix[i][N-1-j];\n                matrix[i][N-1-j] = temp;\n            }\n        }\n    }\n\n    public long computeHash(int[] rows, int[] cols, int[] coeffs) {\n        long hash = 0;\n        for (int i = 0; i < rows.length; i++) {\n            hash += (long)matrix[rows[i]][cols[i]] * coeffs[i];\n        }\n        return hash;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        MatrixOperations mo = new MatrixOperations(N);\n\n        int Q = scanner.nextInt();\n        for (int q = 0; q < Q; q++) {\n            String command = scanner.next();\n            switch (command) {\n                case \"WRITE\":\n                    int row = scanner.nextInt();\n                    int col = scanner.nextInt();\n                    int value = scanner.nextInt();\n                    mo.write(row, col, value);\n                    break;\n                case \"COPY\":\n                    int srcRow = scanner.nextInt();\n                    int srcCol = scanner.nextInt();\n                    int destRow = scanner.nextInt();\n                    int destCol = scanner.nextInt();\n                    mo.copy(srcRow, srcCol, destRow, destCol);\n                    break;\n                case \"SWAP_ROWS\":\n                    int r1 = scanner.nextInt();\n                    int r2 = scanner.nextInt();\n                    mo.swapRows(r1, r2);\n                    break;\n                case \"SWAP_COLS\":\n                    int c1 = scanner.nextInt();\n                    int c2 = scanner.nextInt();\n                    mo.swapColumns(c1, c2);\n                    break;\n                case \"ROTATE\":\n                    mo.rotateClockwise();\n                    break;\n                case \"REFLECT_H\":\n                    mo.reflectHorizontal();\n                    break;\n                case \"REFLECT_V\":\n                    mo.reflectVertical();\n                    break;\n                case \"HASH\":\n                    int K = scanner.nextInt();\n                    int[] rows = new int[K];\n                    int[] cols = new int[K];\n                    int[] coeffs = new int[K];\n                    for (int i = 0; i < K; i++) {\n                        rows[i] = scanner.nextInt();\n                        cols[i] = scanner.nextInt();\n                        coeffs[i] = scanner.nextInt();\n                    }\n                    System.out.println(mo.computeHash(rows, cols, coeffs));\n                    break;\n            }\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:28:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 1000\n#define MAX_COMMAND_LENGTH 20\n\ntypedef struct {\n    int matrix[MAX_N][MAX_N];\n    int size;\n} Matrix;\n\nvoid initMatrix(Matrix* mat, int n) {\n    mat->size = n;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            mat->matrix[i][j] = 0;\n        }\n    }\n}\n\nvoid writeValue(Matrix* mat, int row, int col, int value) {\n    if (row >= 0 && row < mat->size && col >= 0 && col < mat->size) {\n        mat->matrix[row][col] = value;\n    }\n}\n\nvoid copyValue(Matrix* mat, int srcRow, int srcCol, int destRow, int destCol) {\n    if (srcRow >= 0 && srcRow < mat->size && \n        srcCol >= 0 && srcCol < mat->size &&\n        destRow >= 0 && destRow < mat->size && \n        destCol >= 0 && destCol < mat->size) {\n        mat->matrix[destRow][destCol] = mat->matrix[srcRow][srcCol];\n    }\n}\n\nvoid swapRows(Matrix* mat, int row1, int row2) {\n    if (row1 >= 0 && row1 < mat->size && row2 >= 0 && row2 < mat->size) {\n        for (int j = 0; j < mat->size; j++) {\n            int temp = mat->matrix[row1][j];\n            mat->matrix[row1][j] = mat->matrix[row2][j];\n            mat->matrix[row2][j] = temp;\n        }\n    }\n}\n\nvoid swapColumns(Matrix* mat, int col1, int col2) {\n    if (col1 >= 0 && col1 < mat->size && col2 >= 0 && col2 < mat->size) {\n        for (int i = 0; i < mat->size; i++) {\n            int temp = mat->matrix[i][col1];\n            mat->matrix[i][col1] = mat->matrix[i][col2];\n            mat->matrix[i][col2] = temp;\n        }\n    }\n}\n\nvoid rotateMatrix(Matrix* mat) {\n    int n = mat->size;\n    for (int layer = 0; layer < n / 2; layer++) {\n        int first = layer;\n        int last = n - 1 - layer;\n        for (int i = first; i < last; i++) {\n            int offset = i - first;\n            int top = mat->matrix[first][i];\n            \n            // left -> top\n            mat->matrix[first][i] = mat->matrix[last - offset][first];\n            \n            // bottom -> left\n            mat->matrix[last - offset][first] = mat->matrix[last][last - offset];\n            \n            // right -> bottom\n            mat->matrix[last][last - offset] = mat->matrix[i][last];\n            \n            // top -> right\n            mat->matrix[i][last] = top;\n        }\n    }\n}\n\nvoid reflectHorizontal(Matrix* mat) {\n    for (int i = 0; i < mat->size / 2; i++) {\n        swapRows(mat, i, mat->size - 1 - i);\n    }\n}\n\nvoid reflectVertical(Matrix* mat) {\n    for (int j = 0; j < mat->size / 2; j++) {\n        swapColumns(mat, j, mat->size - 1 - j);\n    }\n}\n\nlong long computeHash(Matrix* mat, int* coefficients, int* cells, int numCells) {\n    long long hash = 0;\n    for (int i = 0; i < numCells; i++) {\n        int row = cells[2*i];\n        int col = cells[2*i + 1];\n        hash += (long long)mat->matrix[row][col] * coefficients[i];\n    }\n    return hash;\n}\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    Matrix mat;\n    initMatrix(&mat, n);\n\n    for (int i = 0; i < q; i++) {\n        char command[MAX_COMMAND_LENGTH];\n        scanf(\"%s\", command);\n\n        if (strcmp(command, \"write\") == 0) {\n            int row, col, val;\n            scanf(\"%d %d %d\", &row, &col, &val);\n            writeValue(&mat, row, col, val);\n        }\n        else if (strcmp(command, \"copy\") == 0) {\n            int srcRow, srcCol, destRow, destCol;\n            scanf(\"%d %d %d %d\", &srcRow, &srcCol, &destRow, &destCol);\n            copyValue(&mat, srcRow, srcCol, destRow, destCol);\n        }\n        else if (strcmp(command, \"swap_rows\") == 0) {\n            int row1, row2;\n            scanf(\"%d %d\", &row1, &row2);\n            swapRows(&mat, row1, row2);\n        }\n        else if (strcmp(command, \"swap_cols\") == 0) {\n            int col1, col2;\n            scanf(\"%d %d\", &col1, &col2);\n            swapColumns(&mat, col1, col2);\n        }\n        else if (strcmp(command, \"rotate\") == 0) {\n            rotateMatrix(&mat);\n        }\n        else if (strcmp(command, \"reflect_h\") == 0) {\n            reflectHorizontal(&mat);\n        }\n        else if (strcmp(command, \"reflect_v\") == 0) {\n            reflectVertical(&mat);\n        }\n        else if (strcmp(command, \"compute_hash\") == 0) {\n            int numCells;\n            scanf(\"%d\", &numCells);\n            int* cells = malloc(2 * numCells * sizeof(int));\n            int* coeff = malloc(numCells * sizeof(int));\n\n            for (int j = 0; j < numCells; j++) {\n                scanf(\"%d %d\", &cells[2*j], &cells[2*j + 1]);\n            }\n            for (int j = 0; j < numCells; j++) {\n                scanf(\"%d\", &coeff[j]);\n            }\n\n            long long hash = computeHash(&mat, coeff, cells, numCells);\n            printf(\"%lld\\n\", hash);\n\n            free(cells);\n            free(coeff);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:28:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nclass MatrixOperations {\nprivate:\n    std::vector<std::vector<int>> matrix;\n    int N;\n\npublic:\n    MatrixOperations(int size) : N(size) {\n        matrix.resize(N, std::vector<int>(N, 0));\n    }\n\n    void write(int row, int col, int value) {\n        matrix[row][col] = value;\n    }\n\n    void copy(int srcRow, int srcCol, int destRow, int destCol) {\n        matrix[destRow][destCol] = matrix[srcRow][srcCol];\n    }\n\n    void swapRows(int row1, int row2) {\n        std::swap(matrix[row1], matrix[row2]);\n    }\n\n    void swapColumns(int col1, int col2) {\n        for (int i = 0; i < N; ++i) {\n            std::swap(matrix[i][col1], matrix[i][col2]);\n        }\n    }\n\n    void rotateClockwise() {\n        std::vector<std::vector<int>> temp(N, std::vector<int>(N));\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                temp[j][N - 1 - i] = matrix[i][j];\n            }\n        }\n        matrix = temp;\n    }\n\n    void reflectHorizontal() {\n        for (int i = 0; i < N / 2; ++i) {\n            std::swap(matrix[i], matrix[N - 1 - i]);\n        }\n    }\n\n    void reflectVertical() {\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N / 2; ++j) {\n                std::swap(matrix[i][j], matrix[i][N - 1 - j]);\n            }\n        }\n    }\n\n    int computeHash(const std::vector<std::pair<int, int>>& cells, const std::vector<int>& coefficients) {\n        long long hash = 0;\n        for (size_t i = 0; i < cells.size(); ++i) {\n            int row = cells[i].first;\n            int col = cells[i].second;\n            hash += (long long)matrix[row][col] * coefficients[i];\n        }\n        return hash % 1000000007;\n    }\n};\n\nint main() {\n    int N, Q;\n    std::cin >> N >> Q;\n\n    MatrixOperations matOps(N);\n\n    while (Q--) {\n        int op;\n        std::cin >> op;\n\n        switch (op) {\n            case 1: {  // Write\n                int row, col, value;\n                std::cin >> row >> col >> value;\n                matOps.write(row, col, value);\n                break;\n            }\n            case 2: {  // Copy\n                int srcRow, srcCol, destRow, destCol;\n                std::cin >> srcRow >> srcCol >> destRow >> destCol;\n                matOps.copy(srcRow, srcCol, destRow, destCol);\n                break;\n            }\n            case 3: {  // Swap rows\n                int row1, row2;\n                std::cin >> row1 >> row2;\n                matOps.swapRows(row1, row2);\n                break;\n            }\n            case 4: {  // Swap columns\n                int col1, col2;\n                std::cin >> col1 >> col2;\n                matOps.swapColumns(col1, col2);\n                break;\n            }\n            case 5: {  // Rotate clockwise\n                matOps.rotateClockwise();\n                break;\n            }\n            case 6: {  // Reflect horizontal\n                matOps.reflectHorizontal();\n                break;\n            }\n            case 7: {  // Reflect vertical\n                matOps.reflectVertical();\n                break;\n            }\n            case 8: {  // Compute hash\n                int K;\n                std::cin >> K;\n                std::vector<std::pair<int, int>> cells(K);\n                std::vector<int> coefficients(K);\n                \n                for (int i = 0; i < K; ++i) {\n                    std::cin >> cells[i].first >> cells[i].second;\n                }\n                for (int i = 0; i < K; ++i) {\n                    std::cin >> coefficients[i];\n                }\n                \n                std::cout << matOps.computeHash(cells, coefficients) << std::endl;\n                break;\n            }\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:29:11"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def matrix_operations(n, commands):\n    matrix = [[0] * n for _ in range(n)]\n\n    def write_value(x, y, value):\n        matrix[x][y] = value\n\n    def copy_value(x1, y1, x2, y2):\n        matrix[x2][y2] = matrix[x1][y1]\n\n    def swap_rows(r1, r2):\n        matrix[r1], matrix[r2] = matrix[r2], matrix[r1]\n\n    def swap_cols(c1, c2):\n        for row in matrix:\n            row[c1], row[c2] = row[c2], row[c1]\n\n    def rotate_matrix():\n        nonlocal matrix\n        matrix = [list(row) for row in zip(*matrix[::-1])]\n\n    def reflect_horizontally():\n        nonlocal matrix\n        matrix = matrix[::-1]\n\n    def reflect_vertically():\n        nonlocal matrix\n        matrix = [row[::-1] for row in matrix]\n\n    for command in commands:\n        cmd = command.split()\n        if cmd[0] == 'WRITE':\n            _, x, y, value = cmd\n            write_value(int(x), int(y), int(value))\n        elif cmd[0] == 'COPY':\n            _, x1, y1, x2, y2 = cmd\n            copy_value(int(x1), int(y1), int(x2), int(y2))\n        elif cmd[0] == 'SWAP_ROWS':\n            _, r1, r2 = cmd\n            swap_rows(int(r1), int(r2))\n        elif cmd[0] == 'SWAP_COLS':\n            _, c1, c2 = cmd\n            swap_cols(int(c1), int(c2))\n        elif cmd[0] == 'ROTATE':\n            rotate_matrix()\n        elif cmd[0] == 'REFLECT_H':\n            reflect_horizontally()\n        elif cmd[0] == 'REFLECT_V':\n            reflect_vertically()\n\n    def compute_hash(selected_cells, coefficients):\n        hash_value = 0\n        for (i, j), coeff in zip(selected_cells, coefficients):\n            hash_value += matrix[i][j] * coeff\n        return hash_value\n\n    return compute_hash\n\n# Example usage:\nn = 4\ncommands = [\n    \"WRITE 1 1 5\",\n    \"WRITE 2 2 10\",\n    \"COPY 1 1 3 3\",\n    \"SWAP_ROWS 1 2\",\n    \"ROTATE\",\n    \"REFLECT_H\"\n]\n\n# Operate on 4x4 matrix\ncompute_hash = matrix_operations(n, commands)\n\n# Example to compute hash with selected_cells and coefficients\nselected_cells = [(0, 0), (1, 1), (2, 2)]\ncoefficients = [3, 4, 5]\n\nprint(compute_hash(selected_cells, coefficients))  # Example usage of hash computation",
    "timestamp": "2025-08-13 06:34:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class MatrixOperations {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int Q = scanner.nextInt();\n        int[][] matrix = new int[N][N];\n\n        for (int i = 0; i < Q; i++) {\n            String command = scanner.next();\n            switch (command) {\n                case \"WRITE\":\n                    int r1 = scanner.nextInt();\n                    int c1 = scanner.nextInt();\n                    int val = scanner.nextInt();\n                    matrix[r1][c1] = val;\n                    break;\n                case \"COPY\":\n                    r1 = scanner.nextInt();\n                    c1 = scanner.nextInt();\n                    int r2 = scanner.nextInt();\n                    int c2 = scanner.nextInt();\n                    matrix[r2][c2] = matrix[r1][c1];\n                    break;\n                case \"SWAP_ROW\":\n                    r1 = scanner.nextInt();\n                    r2 = scanner.nextInt();\n                    for (int j = 0; j < N; j++) {\n                        int temp = matrix[r1][j];\n                        matrix[r1][j] = matrix[r2][j];\n                        matrix[r2][j] = temp;\n                    }\n                    break;\n                case \"SWAP_COL\":\n                    c1 = scanner.nextInt();\n                    c2 = scanner.nextInt();\n                    for (int j = 0; j < N; j++) {\n                        int temp = matrix[j][c1];\n                        matrix[j][c1] = matrix[j][c2];\n                        matrix[j][c2] = temp;\n                    }\n                    break;\n                case \"ROTATE\":\n                    int[][] tempMatrix = new int[N][N];\n                    for (int x = 0; x < N; x++) {\n                        for (int y = 0; y < N; y++) {\n                            tempMatrix[y][N - 1 - x] = matrix[x][y];\n                        }\n                    }\n                    matrix = tempMatrix;\n                    break;\n                case \"REFLECT_H\":\n                    for (int x = 0; x < N / 2; x++) {\n                        for (int y = 0; y < N; y++) {\n                            int temp = matrix[x][y];\n                            matrix[x][y] = matrix[N - 1 - x][y];\n                            matrix[N - 1 - x][y] = temp;\n                        }\n                    }\n                    break;\n                case \"REFLECT_V\":\n                    for (int y = 0; y < N / 2; y++) {\n                        for (int x = 0; x < N; x++) {\n                            int temp = matrix[x][y];\n                            matrix[x][y] = matrix[x][N - 1 - y];\n                            matrix[x][N - 1 - y] = temp;\n                        }\n                    }\n                    break;\n            }\n        }\n\n        int K = scanner.nextInt();\n        long hashValue = 0;\n        long mod = 1000000007;\n        for (int i = 0; i < K; i++) {\n            int r = scanner.nextInt();\n            int c = scanner.nextInt();\n            int coeff = scanner.nextInt();\n            hashValue = (hashValue + (long)coeff * matrix[r][c]) % mod;\n        }\n\n        System.out.println(hashValue);\n    }\n}",
    "timestamp": "2025-08-13 06:34:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_N 100\n\nint matrix[MAX_N][MAX_N];\nint n;\n\nvoid writeValue(int row, int col, int value) {\n    matrix[row][col] = value;\n}\n\nvoid copyValue(int srcRow, int srcCol, int destRow, int destCol) {\n    matrix[destRow][destCol] = matrix[srcRow][srcCol];\n}\n\nvoid swapRows(int row1, int row2) {\n    for (int i = 0; i < n; i++) {\n        int temp = matrix[row1][i];\n        matrix[row1][i] = matrix[row2][i];\n        matrix[row2][i] = temp;\n    }\n}\n\nvoid swapColumns(int col1, int col2) {\n    for (int i = 0; i < n; i++) {\n        int temp = matrix[i][col1];\n        matrix[i][col1] = matrix[i][col2];\n        matrix[i][col2] = temp;\n    }\n}\n\nvoid rotate() {\n    int temp[MAX_N][MAX_N];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            temp[j][n - i - 1] = matrix[i][j];\n        }\n    }\n    memcpy(matrix, temp, sizeof(temp));\n}\n\nvoid reflectHorizontally() {\n    for (int i = 0; i < n / 2; i++) {\n        swapRows(i, n - i - 1);\n    }\n}\n\nvoid reflectVertically() {\n    for (int i = 0; i < n / 2; i++) {\n        swapColumns(i, n - i - 1);\n    }\n}\n\nint calculateHash(int *rows, int *cols, int *coeffs, int numCells) {\n    int hash = 0;\n    for (int i = 0; i < numCells; i++) {\n        hash += matrix[rows[i]][cols[i]] * coeffs[i];\n    }\n    return hash;\n}\n\nint main() {\n    int numCommands;\n    scanf(\"%d %d\", &n, &numCommands);\n\n    // Initialize matrix values to 0\n    memset(matrix, 0, sizeof(matrix));\n\n    for (int i = 0; i < numCommands; i++) {\n        char command[20];\n        scanf(\"%s\", command);\n\n        if (strcmp(command, \"WRITE\") == 0) {\n            int row, col, value;\n            scanf(\"%d %d %d\", &row, &col, &value);\n            writeValue(row, col, value);\n        } else if (strcmp(command, \"COPY\") == 0) {\n            int srcRow, srcCol, destRow, destCol;\n            scanf(\"%d %d %d %d\", &srcRow, &srcCol, &destRow, &destCol);\n            copyValue(srcRow, srcCol, destRow, destCol);\n        } else if (strcmp(command, \"SWAP_ROWS\") == 0) {\n            int row1, row2;\n            scanf(\"%d %d\", &row1, &row2);\n            swapRows(row1, row2);\n        } else if (strcmp(command, \"SWAP_COLUMNS\") == 0) {\n            int col1, col2;\n            scanf(\"%d %d\", &col1, &col2);\n            swapColumns(col1, col2);\n        } else if (strcmp(command, \"ROTATE\") == 0) {\n            rotate();\n        } else if (strcmp(command, \"REFLECT_HORIZONTALLY\") == 0) {\n            reflectHorizontally();\n        } else if (strcmp(command, \"REFLECT_VERTICALLY\") == 0) {\n            reflectVertically();\n        }\n    }\n\n    int numCells;\n    scanf(\"%d\", &numCells);\n    int rows[numCells], cols[numCells], coeffs[numCells];\n    for (int i = 0; i < numCells; i++) {\n        scanf(\"%d %d %d\", &rows[i], &cols[i], &coeffs[i]);\n    }\n\n    int hash = calculateHash(rows, cols, coeffs, numCells);\n    printf(\"%d\\n\", hash);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 06:34:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class MatrixOperations:\n    def __init__(self, N):\n        self.N = N\n        self.matrix = [[0] * N for _ in range(N)]\n\n    def write(self, x, y, val):\n        if 0 <= x < self.N and 0 <= y < self.N:\n            self.matrix[x][y] = val\n\n    def copy(self, src_x, src_y, dest_x, dest_y):\n        if (0 <= src_x < self.N and 0 <= src_y < self.N and\n            0 <= dest_x < self.N and 0 <= dest_y < self.N):\n            self.matrix[dest_x][dest_y] = self.matrix[src_x][src_y]\n\n    def swap_rows(self, row1, row2):\n        if 0 <= row1 < self.N and 0 <= row2 < self.N:\n            self.matrix[row1], self.matrix[row2] = self.matrix[row2], self.matrix[row1]\n\n    def swap_columns(self, col1, col2):\n        if 0 <= col1 < self.N and 0 <= col2 < self.N:\n            for i in range(self.N):\n                self.matrix[i][col1], self.matrix[i][col2] = self.matrix[i][col2], self.matrix[i][col1]\n\n    def rotate(self):\n        self.matrix = [list(row) for row in zip(*self.matrix[::-1])]\n\n    def reflect_horizontal(self):\n        self.matrix = self.matrix[::-1]\n\n    def reflect_vertical(self):\n        for row in self.matrix:\n            row.reverse()\n\n    def compute_hash(self, cells, coefficients):\n        hash_val = 0\n        for (x, y), coef in zip(cells, coefficients):\n            if 0 <= x < self.N and 0 <= y < self.N:\n                hash_val += self.matrix[x][y] * coef\n        return hash_val\n\ndef main():\n    N = int(input())\n    matrix_ops = MatrixOperations(N)\n\n    Q = int(input())\n    for _ in range(Q):\n        command = input().split()\n        \n        if command[0] == 'write':\n            matrix_ops.write(int(command[1]), int(command[2]), int(command[3]))\n        \n        elif command[0] == 'copy':\n            matrix_ops.copy(int(command[1]), int(command[2]), int(command[3]), int(command[4]))\n        \n        elif command[0] == 'swap_rows':\n            matrix_ops.swap_rows(int(command[1]), int(command[2]))\n        \n        elif command[0] == 'swap_columns':\n            matrix_ops.swap_columns(int(command[1]), int(command[2]))\n        \n        elif command[0] == 'rotate':\n            matrix_ops.rotate()\n        \n        elif command[0] == 'reflect_horizontal':\n            matrix_ops.reflect_horizontal()\n        \n        elif command[0] == 'reflect_vertical':\n            matrix_ops.reflect_vertical()\n    \n    hash_cells = [(int(x), int(y)) for x, y in zip(input().split(), input().split())]\n    hash_coefficients = [int(coef) for coef in input().split()]\n    \n    print(matrix_ops.compute_hash(hash_cells, hash_coefficients))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 06:34:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    Q = int(input[ptr])\n    ptr += 1\n    \n    matrix = [[0] * N for _ in range(N)]\n    \n    for _ in range(Q):\n        cmd = input[ptr]\n        ptr += 1\n        if cmd == \"WRITE\":\n            r = int(input[ptr])\n            ptr += 1\n            c = int(input[ptr])\n            ptr += 1\n            val = int(input[ptr])\n            ptr += 1\n            matrix[r][c] = val\n        elif cmd == \"CPY\":\n            r1 = int(input[ptr])\n            ptr += 1\n            c1 = int(input[ptr])\n            ptr += 1\n            r2 = int(input[ptr])\n            ptr += 1\n            c2 = int(input[ptr])\n            ptr += 1\n            matrix[r2][c2] = matrix[r1][c1]\n        elif cmd == \"SWAP_ROW\":\n            r1 = int(input[ptr])\n            ptr += 1\n            r2 = int(input[ptr])\n            ptr += 1\n            matrix[r1], matrix[r2] = matrix[r2], matrix[r1]\n        elif cmd == \"SWAP_COL\":\n            c1 = int(input[ptr])\n            ptr += 1\n            c2 = int(input[ptr])\n            ptr += 1\n            for i in range(N):\n                matrix[i][c1], matrix[i][c2] = matrix[i][c2], matrix[i][c1]\n        elif cmd == \"ROT\":\n            new_matrix = [[0] * N for _ in range(N)]\n            for i in range(N):\n                for j in range(N):\n                    new_matrix[j][N - 1 - i] = matrix[i][j]\n            matrix = new_matrix\n        elif cmd == \"SYM\":\n            new_matrix = [[0] * N for _ in range(N)]\n            for i in range(N):\n                for j in range(N):\n                    new_matrix[i][j] = matrix[i][N - 1 - j]\n            matrix = new_matrix\n        elif cmd == \"REV\":\n            new_matrix = [[0] * N for _ in range(N)]\n            for i in range(N):\n                for j in range(N):\n                    new_matrix[i][j] = matrix[N - 1 - i][j]\n            matrix = new_matrix\n    \n    K = int(input[ptr])\n    ptr += 1\n    hash_val = 0\n    for _ in range(K):\n        r = int(input[ptr])\n        ptr += 1\n        c = int(input[ptr])\n        ptr += 1\n        a = int(input[ptr])\n        ptr += 1\n        hash_val += matrix[r][c] * a\n    \n    print(hash_val % (10**9 + 7))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 06:35:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n\n    vector<vector<int>> matrix(N, vector<int>(N, 0));\n\n    while (Q--) {\n        string command;\n        cin >> command;\n\n        if (command == \"WRITE\") {\n            int x, y, v;\n            cin >> x >> y >> v;\n            matrix[x][y] = v;\n        } else if (command == \"COPY\") {\n            int x1, y1, x2, y2;\n            cin >> x1 >> y1 >> x2 >> y2;\n            matrix[x2][y2] = matrix[x1][y1];\n        } else if (command == \"SWAP_ROWS\") {\n            int r1, r2;\n            cin >> r1 >> r2;\n            swap(matrix[r1], matrix[r2]);\n        } else if (command == \"SWAP_COLS\") {\n            int c1, c2;\n            cin >> c1 >> c2;\n            for (int i = 0; i < N; i++) {\n                swap(matrix[i][c1], matrix[i][c2]);\n            }\n        } else if (command == \"ROTATE\") {\n            vector<vector<int>> rotated(N, vector<int>(N));\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    rotated[j][N - 1 - i] = matrix[i][j];\n                }\n            }\n            matrix = rotated;\n        } else if (command == \"REFLECT_HORIZONTALLY\") {\n            for (int i = 0; i < N / 2; i++) {\n                swap(matrix[i], matrix[N - 1 - i]);\n            }\n        } else if (command == \"REFLECT_VERTICALLY\") {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N / 2; j++) {\n                    swap(matrix[i][j], matrix[i][N - 1 - j]);\n                }\n            }\n        }\n    }\n\n    int M;\n    cin >> M;\n\n    vector<pair<int, int>> targetCells(M);\n    vector<int> coefficients(M);\n    for (int i = 0; i < M; i++) {\n        cin >> targetCells[i].first >> targetCells[i].second >> coefficients[i];\n    }\n\n    int hashValue = 0;\n    for (int i = 0; i < M; i++) {\n        int x = targetCells[i].first;\n        int y = targetCells[i].second;\n        hashValue += matrix[x][y] * coefficients[i];\n    }\n\n    cout << hashValue << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:32:51"
  }
]