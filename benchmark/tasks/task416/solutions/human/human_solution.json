[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const deque<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Indices{\n\tvi data;\n\tbool reversed;\n\tIndices(int n):data(n),reversed(false){\n\t\tiota(all(data),0);\n\t}\n\tint& operator[](int i){\n\t\treturn reversed?data[data.size()-1-i]:data[i];\n\t}\n};\n\nstruct Matrix{\n\tconst int n,A,B,C,D,E,F,G;\n\tint dir; // 反時計回りに回した回数 mod 4\n\tIndices fr,fc;\n\tmap<tuple<int,int>,int> val;\n\tMatrix(int n,int A,int B,int C,int D,int E,int F,int G)\n\t\t:n(n),A(A),B(B),C(C),D(D),E(E),F(F),G(G),dir(0),fr(n),fc(n){\n\t}\n\tvoid Set(int i,int j,int x){ // WR\n\t\tif(dir==0) tie(i,j)=mt(fr[i],fc[j]);\n\t\tif(dir==1) tie(i,j)=mt(fr[j],fc[n-1-i]);\n\t\tif(dir==2) tie(i,j)=mt(fr[n-1-i],fc[n-1-j]);\n\t\tif(dir==3) tie(i,j)=mt(fr[n-1-j],fc[i]);\n\t\tval[mt(i,j)]=x;\n\t}\n\tvoid SwapRow(int i1,int i2){ // SR\n\t\tif(dir==0) swap(fr[i1],fr[i2]);\n\t\tif(dir==1) swap(fc[n-1-i1],fr[n-1-i2]);\n\t\tif(dir==2) swap(fr[n-1-i1],fr[n-1-i2]);\n\t\tif(dir==3) swap(fc[i1],fr[i2]);\n\t}\n\tvoid SwapColumn(int j1,int j2){ // SC\n\t\tif(dir==0) swap(fc[j1],fc[j2]);\n\t\tif(dir==1) swap(fr[j1],fr[j2]);\n\t\tif(dir==2) swap(fc[n-1-j1],fc[n-1-j2]);\n\t\tif(dir==3) swap(fr[n-1-j1],fr[n-1-j2]);\n\t}\n\tvoid RotateLeft(){ // RL\n\t\tdir=(dir+1)%4;\n\t}\n\tvoid RotateRight(){ // RR\n\t\tdir=(dir+3)%4;\n\t}\n\tvoid ReverseRow(){ // RH\n\t\tif(dir==0 || dir==2) fr.reversed^=1;\n\t\tif(dir==1 || dir==3) fc.reversed^=1;\n\t}\n\tvoid ReverseColumn(){ // RV\n\t\tif(dir==0 || dir==2) fc.reversed^=1;;\n\t\tif(dir==1 || dir==3) fr.reversed^=1;;\n\t}\n\tint Get(int i,int j){\n\t\tif(dir==0) tie(i,j)=mt(fr[i],fc[j]);\n\t\tif(dir==1) tie(i,j)=mt(fr[j],fc[n-1-i]);\n\t\tif(dir==2) tie(i,j)=mt(fr[n-1-i],fc[n-1-j]);\n\t\tif(dir==3) tie(i,j)=mt(fr[n-1-j],fc[i]);\n\t\tif(val.count(mt(i,j)))\n\t\t\treturn val[mt(i,j)];\n\t\telse\n\t\t\treturn (ll(i+1)*A+ll(j+1)*B)%C;\n\t};\n\tint Hash(){\n\t\tint h=314159265;\n\t\trepi(i,D-1,E) repi(j,F-1,G){\n\t\t\t//dump(vi({fr[i],fc[j],Get(i,j)}));\n\t\t\th=(31ll*h+Get(i,j))%MOD;\n\t\t}\n\t\treturn h;\n\t}\n\tvoid Print(){\n\t\trep(i,n){\n\t\t\trep(j,n) cout<<Get(i,j)<<' ';\n\t\t\tcout<<endl;\n\t\t}\n\t}\n};\n\nint main()\n{\n\tfor(int n,q;cin>>n>>q && n|q;){\n\t\tint A,B,C,D,E,F,G; cin>>A>>B>>C>>D>>E>>F>>G;\n\t\tMatrix mat(n,A,B,C,D,E,F,G);\n\t\trep(_,q){\n\t\t\tstring op; cin>>op;\n\t\t\tif(op==\"WR\"){\n\t\t\t\tint r,c,v; cin>>r>>c>>v; r--,c--;\n\t\t\t\tmat.Set(r,c,v);\n\t\t\t}\n\t\t\tif(op==\"CP\"){\n\t\t\t\tint r1,c1,r2,c2; cin>>r1>>c1>>r2>>c2; r1--,c1--,r2--,c2--;\n\t\t\t\tmat.Set(r2,c2,mat.Get(r1,c1));\n\t\t\t}\n\t\t\tif(op==\"SR\"){\n\t\t\t\tint r1,r2; cin>>r1>>r2; r1--,r2--;\n\t\t\t\tmat.SwapRow(r1,r2);\n\t\t\t}\n\t\t\tif(op==\"SC\"){\n\t\t\t\tint c1,c2; cin>>c1>>c2; c1--,c2--;\n\t\t\t\tmat.SwapColumn(c1,c2);\n\t\t\t}\n\t\t\tif(op==\"RL\") mat.RotateLeft();\n\t\t\tif(op==\"RR\") mat.RotateRight();\n\t\t\tif(op==\"RH\") mat.ReverseRow();\n\t\t\tif(op==\"RV\") mat.ReverseColumn();\n\t\t}\n\t\tcout<<mat.Hash()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <map>\n#include <string>\nusing namespace std;\n\ntypedef long long ll;\nconst int MOD = 1000000007;\nconst int N = 44444;\nconst string st = \"VHRL\";\nmap<pair<int, int>, int> M;\nint r[N], c[N];\nll A, B;\nint C, D, E, F, G;\nint n, m, state;\nint trans[4][8] = {{6, 5, 4, 7, 2, 1, 0, 3},\n                   {4, 7, 6, 5, 0, 3, 2, 1},\n                   {1, 2, 3, 0, 5, 6, 7, 4},\n                   {3, 0, 1, 2, 7, 4, 5, 6}};\nchar com[11];\n\nvoid GetPos(int &x, int &y) {\n    int tx = x, ty = y;\n    for (int i=0; i<state&3; ++i){\n        ty = x;\n        tx = n - y + 1;\n        x = tx; y = ty;\n    }\n    if (state & 4) tx = n - tx + 1;\n    x = r[tx]; y = c[ty];\n}\n\nvoid SwapLine(int p1, int p2, int q1, int q2) {\n    GetPos(p1, p2); GetPos(q1, q2);\n    if (p1 == q1) swap(c[p2], c[q2]);\n    else swap(r[p1], r[q1]);\n}\n\nint GetValue(int x, int y) {\n    GetPos(x, y);\n    int value = (A * x + B * y) % C;\n    if (M.count(make_pair(x, y))) value = M[make_pair(x, y)];\n    return value;\n}\n\nint main(){\n    while (scanf(\"%d %d %lld %lld %d %d %d %d %d\", &n, &m, &A, &B, &C, &D ,&E, &F, &G) == 9){\n        for (int i=0; i<=n; ++i) r[i] = c[i] = i;\n        M.clear();\n        int p1, p2, q1, q2, v;\n        state = 0;\n        while (m--){\n            scanf(\"%s\", com);\n            if (com[0] == 'W'){\n                scanf(\"%d %d %d\", &p1, &p2, &v);\n                GetPos(p1, p2);\n                M[make_pair(p1, p2)] = v;\n            } else if (com[0] == 'C'){\n                scanf(\"%d %d %d %d\", &p1, &p2, &q1, &q2);\n                GetPos(q1, q2);\n                M[make_pair(q1, q2)] = GetValue(p1, p2);\n            } else if (com[0] == 'S' && com[1] == 'R') {\n                scanf(\"%d %d\", &p1, &p2);\n                SwapLine(p1, 0, p2, 0);\n            } else if (com[0] == 'S' && com[1] == 'C') {\n                scanf(\"%d %d\", &p1, &p2);\n                SwapLine(0, p1, 0, p2);\n            } else state = trans[st.find(com[1])][state];\n        }\n        ll ans = 314159265;\n        for (int i=D; i<=E; ++i)\n            for (int j=F; j<=G; ++j)\n                ans = (ans * 31 + GetValue(i, j)) % MOD;\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int MN = 40400;\nconst ll MD = 1e9+7;\n\nint N;\nint A, B, C;\nint rowmp[MN]; //y = rowmp[y]\nint colmp[MN];\nint dir, rev;\n\nint xc(int x, int y) {\n    switch (rev*4+dir) {\n    case 0:\n    case 6:\n        return x;\n    case 1:\n    case 5:\n        return y;\n    case 2:\n    case 4:\n        return N-1-x;\n    case 3:\n    case 7: \n        return N-1-y;\n    }\n    assert(false);\n}\n\nint yc(int x, int y) {\n    switch(rev*4+dir) {\n    case 0:\n    case 4:\n        return y;\n    case 3:\n    case 5:\n        return x;\n    case 2:\n    case 6:\n        return N-1-y;\n    case 1:\n    case 7:\n        return N-1-x;\n    }\n    assert(false);\n}\n\n\nmap<P, int> mp;\n\nint get(int x, int y) {\n    int xx = xc(x, y);\n    int yy = yc(x, y);\n    xx = colmp[xx];\n    yy = rowmp[yy];\n    if (mp.count(P(xx, yy))) {\n        return mp[P(xx, yy)];\n    }\n    return ((ll)A*(yy+1)+(ll)B*(xx+1)) % C;\n}\n\nvoid set(int x, int y, int d) {\n    int xx = xc(x, y);\n    int yy = yc(x, y);\n    xx = colmp[xx];\n    yy = rowmp[yy];\n    mp[P(xx, yy)] = d;\n}\n\nint main() {\n    int Q, D, E, F, G;\n    cin >> N >> Q >> A >> B >> C >> D >> E >> F >> G;\n    D--; F--;\n    for (int i = 0; i < N; i++) {\n        rowmp[i] = colmp[i] = i;\n    }\n    // for (int i = 0; i < N; i++) {\n    //     for (int j = 0; j < N; j++) {\n    //         printf(\"%d \", get(j, i));\n    //     } printf(\"\\n\");\n    // }\n    for (int i = 0; i < Q; i++) {\n        string s;\n        cin >> s;\n        if (s == \"WR\") {\n            int y, x, d;\n            cin >> y >> x >> d; y--; x--;\n            set(x, y, d);\n        } else if (s == \"CP\") {\n            int y1, x1, y2, x2;\n            cin >> y1 >> x1 >> y2 >> x2;\n            y1--; x1--; y2--; x2--;\n            int a = get(x1, y1);\n            int b = get(x2, y2);\n            set(x1, y1, a);\n            set(x2, y2, b);\n        } else if (s == \"SR\") {\n            int y1, y2;\n            cin >> y1 >> y2; y1--; y2--;\n            if (dir % 2 == 0) {\n                y1 = yc(-1, y1);\n                y2 = yc(-1, y2);\n                swap(rowmp[y1], rowmp[y2]);\n            } else {\n                y1 = xc(-1, y1);\n                y2 = xc(-1, y2);\n                swap(colmp[y1], colmp[y2]);\n            }\n        } else if (s == \"SC\") {\n            int x1, x2;\n            cin >> x1 >> x2; x1--; x2--;\n            if (dir % 2 == 0) {\n                x1 = xc(x1, -1);\n                x2 = xc(x2, -1);\n                swap(colmp[x1], colmp[x2]);\n            } else {\n                x1 = yc(x1, -1);\n                x2 = yc(x2, -1);\n                swap(rowmp[x1], rowmp[x2]);\n            }\n        } else if (s == \"RL\") {\n            if (!rev) {\n                dir = (dir+3) % 4;\n            } else {\n                dir = (dir+1) % 4;\n            }\n        } else if (s == \"RR\") {\n            if (!rev) {\n                dir = (dir+1) % 4;\n            } else {\n                dir = (dir+3) % 4;\n            }\n        } else if (s == \"RH\") {\n            rev = 1-rev;\n            dir += 2;\n            dir %= 4;\n        } else if (s == \"RV\") {\n            rev = 1-rev;\n        }\n//        printf(\"dir %d rev %d\\n\", dir, rev);\n        // for (int i = 0; i < N; i++) {\n        //     for (int j = 0; j < N; j++) {\n        //         printf(\"%d \", get(j, i));\n        //     } printf(\"\\n\");\n        // }\n    }\n    ll h = 314159265;\n    for (int i = D; i < E; i++) {\n        for (int j = F; j < G; j++) {\n            h = (31 * h + get(j, i)) % MD;\n        }\n    }\n    cout << h << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nint ROW[40000];\nint COL[40000];\nint N,Q,A,B,C,D,E,F,G;\n\n/*\n  state\n  \n  AB\n  CD\n\n  BD\n  AC\n\n  DC\n  BA\n\n  CA\n  DB\n\n  BA\n  DC\n\n  AC\n  BD\n\n  CD\n  AB\n\n  DB\n  CA\n */\npii func(int state, int r, int c) {\n  pii res;\n  if (state == 0) res = pii(r,c);\n  else if (state == 1) res = pii(N-1-c,r);\n  else if (state == 2) res = pii(N-1-r,N-1-c);\n  else if (state == 3) res = pii(c, N-1-r);\n  else if (state == 4) res = pii(r,N-1-c);\n  else if (state == 5) res = pii(c, r);\n  else if (state == 6) res = pii(N-1-r,c);\n  else res = pii(N-1-c,N-1-r);\n  return pii(ROW[res.first], COL[res.second]);\n}\nmap<pii, int> mp;\n\nint get(int state, int r, int c) {\n  pii p = func(state, r, c);\n  //cout << r << \" \" << c << \" : \" << p.first << \",\" << p.second << \" \" << mp.count(pii(p)) << endl;\n  if (mp.count(pii(p))) return mp[pii(p)];\n  else return ((p.first+1LL)*A + (p.second+1LL)*B) % C;\n}\n\nint main() {\n  int rh[8] = {6,5,4,7,2,1,0,3};\n  int rv[8] = {4,7,6,5,0,3,2,1};\n  while(cin>>N>>Q>>A>>B>>C>>D>>E>>F>>G) {\n    mp.clear();\n    REP(i,N) ROW[i] = COL[i] = i;\n    int state = 0;\n    // if (N > 4) continue;\n    // REP(i, N) {\n    //   REP(j,N) cout << get(0,i,j) << \" \";\n    //   cout << endl;\n    // }\n    REP(i,Q) {\n      string op;\n      cin >> op;\n      if (op == \"WR\") {\n        int r,c,v;cin>>r>>c>>v;r--;c--;\n        //cout << func(state, r, c).first << \" \"<<func(state, r,c).second << endl;\n        mp[func(state, r, c)] = v;\n      } else if (op == \"CP\") {\n        int r1,c1,r2,c2;cin>>r1>>c1>>r2>>c2;r1--;c1--;r2--;c2--;\n        pii p2 = func(state, r2, c2);\n        mp[p2] = get(state, r1, c1);\n      } else if (op == \"SR\") {\n        int r1, r2; cin >> r1 >> r2; r1--;r2--;\n        pii p1 = func(state, r1, 0), p2 = func(state, r2, 0);\n        if (state % 2)\n          swap(COL[p1.second], COL[p2.second]);\n        else\n          swap(ROW[p1.first], ROW[p2.first]);\n      } else if (op == \"SC\") {\n        int c1, c2; cin >> c1 >> c2; c1--; c2--;\n        pii p1 = func(state, 0, c1), p2 = func(state, 0, c2);\n        if (state % 2)\n          swap(ROW[p1.first], ROW[p2.first]);\n        else\n          swap(COL[p1.second], COL[p2.second]);\n      } else if (op == \"RL\") {\n        state = (state + 3) % 4 + state/4*4;\n      } else if (op == \"RR\") {\n        state = (state + 1) % 4 + state/4*4;\n      } else if (op == \"RH\") {\n        state = rh[state];\n      } else {\n        state = rv[state];\n      }\n    }\n    ll h = 314159265;\n    for (int i=D-1; i<E; ++i) {\n      for (int j=F-1; j<G; ++j) {\n        int b = get(state, i, j);\n        //if (b < 0) cout << b << endl;\n        h = (31*h+b) % 1000000007;\n        //cout << h << endl;\n        // cout << b << \" \";\n      }\n      //cout << endl;\n    }\n    cout << h << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define repa(i,a,n) for(int i=a;i<a+n;++i)\n#define repb(i,a,n) for(int i=a;i>a-n;--i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\ntypedef long long ll;\ntypedef pair<int,int> P;\nmap<P,ll> mp;\nll N,Q,A,B,C,D,E,F,G;\nll mod=1e9+7;\nint row[40001],col[40001];\nll initial(int r,int c){\n\treturn (A*r+B*c)%C;\n}\nll value(int r,int c){\n\tif(mp.find(P(r,c))==mp.end()){\n\t\treturn initial(r,c);\n\t}else{\n\t\treturn mp[P(r,c)];\n\t}\n}\nint ro,inv;\nvoid change(int &r,int &c){\n\tint nr,nc;\n\tif(inv==0){\n\t\tif(ro==0) nr=r,nc=c;\n\t\tif(ro==1) nr=c,nc=N+1-r;\n\t\tif(ro==2) nr=N+1-r,nc=N+1-c;\n\t\tif(ro==3) nr=N+1-c,nc=r;\n\t}else{\n\t\tif(ro==0) nr=N+1-r,nc=c;\n\t\tif(ro==1) nr=N+1-c,nc=N+1-r;\n\t\tif(ro==2) nr=r,nc=N+1-c;\n\t\tif(ro==3) nr=c,nc=r;\n\t}\n\tr=row[nr],c=col[nc];\n}\nvoid change2(int &r,int &c){\n\tint nr,nc;\n\tif(inv==0){\n\t\tif(ro==0) nr=r,nc=c;\n\t\tif(ro==1) nr=c,nc=N+1-r;\n\t\tif(ro==2) nr=N+1-r,nc=N+1-c;\n\t\tif(ro==3) nr=N+1-c,nc=r;\n\t}else{\n\t\tif(ro==0) nr=N+1-r,nc=c;\n\t\tif(ro==1) nr=N+1-c,nc=N+1-r;\n\t\tif(ro==2) nr=r,nc=N+1-c;\n\t\tif(ro==3) nr=c,nc=r;\n\t}\n\tr=nr,c=nc;\n}\nvoid showmat(){\n\tshow(ro);\n\tshow(inv);\n\tfor(int r=D;r<=E;r++){\n\t\tfor(int c=F;c<=G;c++){\n\t\t\tint tmpr=r,tmpc=c;\n\t\t\tchange(tmpr,tmpc);\n\t\t\tcout<<value(tmpr,tmpc)<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\tcout<<endl;\n}\nint main(){\n\tcin>>N>>Q>>A>>B>>C>>D>>E>>F>>G;\n\trep1(i,N) row[i]=i,col[i]=i;\n\tint X=E-D+1,Y=G-F+1;\n\tro=0,inv=0;\n\trep(i,Q){\n\t\tstring type;\n\t\tcin>>type;\n\t\tif(type==\"WR\"){\n\t\t\tint r,c,v;\n\t\t\tcin>>r>>c>>v;\n\t\t\tchange(r,c);\n\t\t\tmp[P(r,c)]=v;\n\t\t}\n\t\tif(type==\"CP\"){\n\t\t\tint r1,c1,r2,c2;\n\t\t\tcin>>r1>>c1>>r2>>c2;\n\t\t\tchange(r1,c1);\n\t\t\tchange(r2,c2);\n\t\t\tmp[P(r2,c2)]=value(r1,c1);\n\t\t}\n\t\tif(type==\"SR\"){\n\t\t\tint r1,r2,c1=0,c2=0;\n\t\t\tcin>>r1>>r2;\n\t\t\tchange2(r1,c1);\n\t\t\tchange2(r2,c2);\n\t\t\t// show(r1);\n\t\t\t// show(r2);\n\t\t\t// show(c1);\n\t\t\t// show(c2);\n\t\t\tif(c1==c2) swap(row[r1],row[r2]);\n\t\t\tif(r1==r2) swap(col[c1],col[c2]);\n\t\t}\n\t\tif(type==\"SC\"){\n\t\t\tint r1=0,r2=0,c1,c2;\n\t\t\tcin>>c1>>c2;\n\t\t\tchange2(r1,c1);\n\t\t\tchange2(r2,c2);\n\t\t\tif(c1==c2) swap(row[r1],row[r2]);\n\t\t\tif(r1==r2) swap(col[c1],col[c2]);\n\t\t}\n\t\tif(type==\"RL\"){\n\t\t\tro=(ro+1)%4;\n\t\t}\n\t\tif(type==\"RR\"){\n\t\t\tro=(ro+3)%4;\n\t\t}\n\t\tif(type==\"RH\"){\n\t\t\tif(ro%2==0){\n\t\t\t\tinv=1-inv;\n\t\t\t}else{\n\t\t\t\tinv=1-inv;\n\t\t\t\tro=(ro+2)%4;\n\t\t\t}\n\t\t}\n\t\tif(type==\"RV\"){\n\t\t\tif(ro%2==0){\n\t\t\t\tinv=1-inv;\n\t\t\t\tro=(ro+2)%4;\n\t\t\t}else{\n\t\t\t\tinv=1-inv;\n\t\t\t}\n\t\t}\n//\t\tshowmat();\n\t}\n\tll h=314159265;\n\tfor(int r=D;r<=E;r++) for(int c=F;c<=G;c++){\n\t\tint tmpr=r,tmpc=c;\n\t\tchange(tmpr,tmpc);\n\t\th=h*31+value(tmpr,tmpc);\n\t\th%=mod;\n\t}\n\tcout<<h<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n,q,a,b,c,d,e,f,g;\n  cin>>n>>q>>a>>b>>c>>d>>e>>f>>g;\n  using P = pair<Int, Int>;\n  map<P, Int> mp;\n  auto val=[&](Int y,Int x){\n    if(x>y) swap(x,y);\n    return ((y-n)*a+x*b)%c;\n  };\n  auto calc=[&](Int y,Int x){\n    //cout<<y<<\":\"<<x<<endl;\n    if(mp.count(minmax(y,x))) return mp[minmax(y,x)];\n    else return val(y,x);\n  };\n\n  vector<Int> vx(n),vy(n);\n  iota(vx.begin(),vx.end(),1);\n  iota(vy.begin(),vy.end(),n+1);\n  //for(Int i=0;i<n;i++) cout<<\"vx:\"<<i<<vx[i]<<endl;\n  //for(Int i=0;i<n;i++) cout<<\"vy:\"<<i<<vy[i]<<endl;\n\n  using It = vector<Int>::iterator;\n  It px=vx.begin();\n  It qx=--vx.end();\n  It py=vy.begin();\n  It qy=--vy.end();\n\n  auto conv=[&](It it,Int x){\n    if(it==--vx.end()||it==--vy.end()) return it-x;\n    return it+x;\n  }; \n  \n  for(Int i=0;i<q;i++){\n    string s;\n    cin>>s;\n    if(s==\"WR\"){\n      Int r,c,v;\n      cin>>r>>c>>v;\n      r--;c--;\n      mp[minmax(*conv(py,r),*conv(px,c))]=v;\n    }\n    if(s==\"CP\"){\n      Int r1,c1,r2,c2;\n      cin>>r1>>c1>>r2>>c2;\n      r1--;c1--;r2--;c2--;\n      mp[minmax(*conv(py,r2),*conv(px,c2))]=calc(*conv(py,r1),*conv(px,c1));\n    }\n    if(s==\"SR\"){\n      Int r1,r2;\n      cin>>r1>>r2;r1--;r2--;\n      auto sy=(py<qy?py:qy);\n      if(sy==vx.begin())\n\tswap(vx[conv(py,r1)-sy],vx[conv(py,r2)-sy]);\n      else\n\tswap(vy[conv(py,r1)-sy],vy[conv(py,r2)-sy]);\n    }\n    if(s==\"SC\"){\n      Int c1,c2;\n      cin>>c1>>c2;c1--;c2--;\n      auto sx=(px<qx?px:qx);\n      if(sx==vx.begin())\n\tswap(vx[conv(px,c1)-sx],vx[conv(px,c2)-sx]);\n      else\n\tswap(vy[conv(px,c1)-sx],vy[conv(px,c2)-sx]);\n    }\n    if(s==\"RL\"){\n      It bpx=px,bqx=qx,bpy=py,bqy=qy;\n      px=bpy;\n      qx=bqy;\n      py=bqx;\n      qy=bpx;\n    }\n    if(s==\"RR\"){\n      It bpx=px,bqx=qx,bpy=py,bqy=qy;\n      px=bqy;\n      qx=bpy;\n      py=bpx;\n      qy=bqx;\n    }\n    if(s==\"RH\"){\n      swap(py,qy);\n    }    \n    if(s==\"RV\"){\n      swap(px,qx);\n    }\n  }\n\n  const Int MOD = 1e9+7;\n  d--;f--;\n  Int ans=314159265;\n  for(Int i=d;i<e;i++)\n    for(Int j=f;j<g;j++)\n      ans=(ans*31+calc(*conv(py,i),*conv(px,j)))%MOD;\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<numeric>\n\nusing namespace std;\n\nmap<unsigned,int> m;\n\nlong long N,Q,A,B,C,D,E,F,G;\nvector<int> rx,cx;\nbool cr=false,rr=false;\nbool t=false;\n\nint &org(int y,int x){\n  int oy=rx[y];\n  if(rr){\n    oy=N+1-oy;\n  }\n  int ox=cx[x];\n  if(cr){\n    ox=N+1-ox;\n  }\n  if(t){\n    swap(oy,ox);\n  }\n  unsigned mx=(oy*1u<<16)+ox;\n  if(!m.count(mx)){\n    m[mx]=(oy*A+ox*B)%C;\n  }\n  return m[mx];\n}\n\nint main(){\n  cin>>N>>Q>>A>>B>>C>>D>>E>>F>>G;\n  rx.resize(N+1);\n  cx.resize(N+1);\n  iota(begin(rx),end(rx),0);\n  iota(begin(cx),end(cx),0);\n  while(Q--){\n    char op[9];\n    cin>>op;\n    if(op[0]=='W'){\n      int r,c,v;\n      cin>>r>>c>>v;\n      org(r,c)=v;\n    }else if(op[0]=='C'){\n      int r1,c1,r2,c2;\n      cin>>r1>>c1>>r2>>c2;\n      org(r2,c2)=org(r1,c2);\n    }else if(op[0]=='S'){\n      int rc1,rc2;\n      cin>>rc1>>rc2;\n      if(op[1]=='R'){\n\tswap(rx[rc1],rx[rc2]);\n      }else{\n\tswap(cx[rc1],cx[rc2]);\n      }\n    }else{\n      if(op[1]=='R'){\n\tswap(rx,cx);\n\tswap(rr,cr);\n\tcr^=true;\n\tt^=true;\n      }else if(op[1]=='L'){\n\tswap(rx,cx);\n\tswap(rr,cr);\n\trr^=true;\n\tt^=true;\n      }else if(op[1]=='H'){\n\trr^=true;\n      }else{\n\tcr^=true;\n      }\n    }\n  }\n  long long h=314159265;\n  for(int i=D;i<=E;i++){\n    for(int j=F;j<=G;j++){\n      h=(31*h+org(i,j))%1000000007;\n    }\n  }\n  cout<<h<<endl;\n}\n\n    \n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int MN = 40400;\nconst ll MD = 1e9+7;\n\nint N;\nint A, B, C;\nint rowmp[MN]; //y = rowmp[y]\nint colmp[MN];\nint dir, rev;\n\nint xc(int x, int y) {\n    switch (rev*4+dir) {\n    case 0:\n    case 6:\n        return x;\n    case 1:\n    case 5:\n        return y;\n    case 2:\n    case 4:\n        return N-1-x;\n    case 3:\n    case 7: \n        return N-1-y;\n    }\n    assert(false);\n}\n\nint yc(int x, int y) {\n    switch(rev*4+dir) {\n    case 0:\n    case 4:\n        return y;\n    case 3:\n    case 5:\n        return x;\n    case 2:\n    case 6:\n        return N-1-y;\n    case 1:\n    case 7:\n        return N-1-x;\n    }\n    assert(false);\n}\n\n\nmap<P, int> mp;\n\nint get(int x, int y) {\n    int xx = xc(x, y);\n    int yy = yc(x, y);\n    xx = colmp[xx];\n    yy = rowmp[yy];\n    if (mp.count(P(xx, yy))) {\n        return mp[P(xx, yy)];\n    }\n    return ((ll)A*(yy+1)+(ll)B*(xx+1)) % C;\n}\n\nvoid set(int x, int y, int d) {\n    int xx = xc(x, y);\n    int yy = yc(x, y);\n    xx = colmp[xx];\n    yy = rowmp[yy];\n    mp[P(xx, yy)] = d;\n}\n\nint main() {\n    int Q, D, E, F, G;\n    cin >> N >> Q >> A >> B >> C >> D >> E >> F >> G;\n    D--; F--;\n    for (int i = 0; i < N; i++) {\n        rowmp[i] = colmp[i] = i;\n    }\n    // for (int i = 0; i < N; i++) {\n    //     for (int j = 0; j < N; j++) {\n    //         printf(\"%d \", get(j, i));\n    //     } printf(\"\\n\");\n    // }\n    for (int i = 0; i < Q; i++) {\n        string s;\n        cin >> s;\n        if (s == \"WR\") {\n            int y, x, d;\n            cin >> y >> x >> d; y--; x--;\n            set(x, y, d);\n        } else if (s == \"CP\") {\n            int y1, x1, y2, x2;\n            cin >> y1 >> x1 >> y2 >> x2;\n            y1--; x1--; y2--; x2--;\n            set(x2, y2, get(x1, y1));\n        } else if (s == \"SR\") {\n            int y1, y2;\n            cin >> y1 >> y2; y1--; y2--;\n            if (dir % 2 == 0) {\n                y1 = yc(-1, y1);\n                y2 = yc(-1, y2);\n                swap(rowmp[y1], rowmp[y2]);\n            } else {\n                y1 = xc(-1, y1);\n                y2 = xc(-1, y2);\n                swap(colmp[y1], colmp[y2]);\n            }\n        } else if (s == \"SC\") {\n            int x1, x2;\n            cin >> x1 >> x2; x1--; x2--;\n            if (dir % 2 == 0) {\n                x1 = xc(x1, -1);\n                x2 = xc(x2, -1);\n                swap(colmp[x1], colmp[x2]);\n            } else {\n                x1 = yc(x1, -1);\n                x2 = yc(x2, -1);\n                swap(rowmp[x1], rowmp[x2]);\n            }\n        } else if (s == \"RL\") {\n            if (!rev) {\n                dir = (dir+3) % 4;\n            } else {\n                dir = (dir+1) % 4;\n            }\n        } else if (s == \"RR\") {\n            if (!rev) {\n                dir = (dir+1) % 4;\n            } else {\n                dir = (dir+3) % 4;\n            }\n        } else if (s == \"RH\") {\n            rev = 1-rev;\n            dir += 2;\n            dir %= 4;\n        } else if (s == \"RV\") {\n            rev = 1-rev;\n        }\n//        printf(\"dir %d rev %d\\n\", dir, rev);\n        // for (int i = 0; i < N; i++) {\n        //     for (int j = 0; j < N; j++) {\n        //         printf(\"%d \", get(j, i));\n        //     } printf(\"\\n\");\n        // }\n    }\n    ll h = 314159265;\n    for (int i = D; i < E; i++) {\n        for (int j = F; j < G; j++) {\n            h = (31 * h + get(j, i)) % MD;\n        }\n    }\n    cout << h << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<map>\nusing namespace std;\nint row[41000];\nint col[41000];\nmap<pair<int,int>,int> m;\nchar str[10];\nint dir;\nint n;\npair<int,int> conv(int a,int b){\n\tint ret1=0;\n\tint ret2=0;\n\tswitch(dir&3){\n\t\tcase 0:\n\t\t\tret1=a;\n\t\t\tret2=b;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tret1=b;\n\t\t\tret2=n-a+1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret1=n-a+1;\n\t\t\tret2=n-b+1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tret1=n-b+1;\n\t\t\tret2=a;\n\t\t\tbreak;\n\t}\n\tif(dir&4)swap(ret1,ret2);\n\treturn make_pair(row[ret1],col[ret2]);\n}\nint main(){\n\tint a,b,c,d,e,f,g;\n\tint q;\n\tscanf(\"%d%d%d%d%d%d%d%d%d\",&n,&q,&a,&b,&c,&d,&e,&f,&g);\n\tlong long h=314159265;\n\tlong long mod=1000000007;\n\tfor(int i=1;i<=n;i++)row[i]=i;\n\tfor(int i=1;i<=n;i++)col[i]=i;\n\twhile(q--){\n\t\tscanf(\"%s\",str);\n\t\tif(str[0]=='W'){\n\t\t\tint R,C,V;\n\t\t\tscanf(\"%d%d%d\",&R,&C,&V);\n\t\t\tpair<int,int> at=conv(R,C);\n\t\t\tm[at]=V;\n\t\t}\n\t\tif(str[0]=='C'){\n\t\t\tint r1,c1,r2,c2;\n\t\t\tscanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n\t\t\tpair<int,int> at1=conv(r1,c1);\n\t\t\tpair<int,int> at2=conv(r2,c2);\n\t\t\tif(m.count(at1))m[at2]=m[at1];\n\t\t\telse m[at2]=((long long)at1.first*a+(long long)at1.second*b)%c;\n\t\t}\n\t\tif(str[0]=='S'){\n\t\t\tint r1,r2;\n\t\t\tscanf(\"%d%d\",&r1,&r2);\n\t\t\tif((dir/4+(str[1]=='R')+dir%4)&1){\n\t\t\t\tif((dir+1+(str[1]!='R')*2)%4<2)swap(row[r1],row[r2]);\n\t\t\t\telse swap(row[n-r1+1],row[n-r2+1]);\n\t\t\t}else{\n\t\t\t\tif((dir+(str[1]=='R')*2)%4<2)swap(col[r1],col[r2]);\n\t\t\t\telse swap(col[n-r1+1],col[n-r2+1]);\n\t\t\t}\n\t\t}\n\t\tif(str[0]=='R'){\n\t\t\tif(str[1]=='L'){\n\t\t\t\tdir=(dir&4)+((dir%4+1)&3);\n\t\t\t}\n\t\t\tif(str[1]=='R'){\n\t\t\t\tdir=(dir&4)+((dir%4+3)&3);\n\t\t\t}\n\t\t\tif(str[1]=='H'){\n\t\t\t\tdir=((dir&4)?0:4)+(dir%4)^1;\n\t\t\t}\n\t\t\tif(str[1]=='V'){\n\t\t\t\tdir=((dir&4)?0:4)+(dir%4)^3;\n\t\t\t}\n\t\t}\n\t}\n\t/*for(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tpair<int,int> at=conv(i,j);\n\t\t\tint ans;\n\t\t\tif(m.count(at))ans=m[at];\n\t\t\telse ans=((long long)at.first*a+(long long)at.second*b)%c;\n\t\t\tprintf(\"%d \",ans);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\tfor(int i=d;i<=e;i++){\n\t\tfor(int j=f;j<=g;j++){\n\t\t\tpair<int,int> at=conv(i,j);\n\t\t\tif(m.count(at))h=(h*31+m[at])%mod;\n\t\t\telse h=(h*31+((long long)at.first*a+(long long)at.second*b)%c)%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",h);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<numeric>\n\nusing namespace std;\n\nmap<unsigned,int> m;\n\nlong long N,Q,A,B,C,D,E,F,G;\nvector<int> rx,cx;\nbool cr=false,rr=false;\nbool t=false;\n\nint ay(int y){\n  if(rr){\n    y=N+1-y;\n  }\n  return y;\n}\n\nint ax(int x){\n  if(cr){\n    x=N+1-x;\n  }\n  return x;\n}\n\nint &org(int y,int x){\n  int oy=rx[ay(y)];\n  int ox=cx[ax(x)];\n  if(t){\n    swap(oy,ox);\n  }\n  unsigned mx=(oy*1u<<16)+ox;\n  if(!m.count(mx)){\n    m[mx]=(oy*A+ox*B)%C;\n  }\n  return m[mx];\n}\n\nint main(){\n  cin>>N>>Q>>A>>B>>C>>D>>E>>F>>G;\n  rx.resize(N+1);\n  cx.resize(N+1);\n  iota(begin(rx),end(rx),0);\n  iota(begin(cx),end(cx),0);\n  while(Q--){\n    char op[9];\n    cin>>op;\n    if(op[0]=='W'){\n      int r,c,v;\n      cin>>r>>c>>v;\n      org(r,c)=v;\n    }else if(op[0]=='C'){\n      int r1,c1,r2,c2;\n      cin>>r1>>c1>>r2>>c2;\n      org(r2,c2)=org(r1,c1);\n    }else if(op[0]=='S'){\n      int rc1,rc2;\n      cin>>rc1>>rc2;\n      if(op[1]=='R'){\n\tswap(rx[ay(rc1)],rx[ay(rc2)]);\n      }else{\n\tswap(cx[ax(rc1)],cx[ax(rc2)]);\n      }\n    }else{\n      if(op[1]=='R'){\n\tswap(rx,cx);\n\tswap(rr,cr);\n\tcr^=true;\n\tt^=true;\n      }else if(op[1]=='L'){\n\tswap(rx,cx);\n\tswap(rr,cr);\n\trr^=true;\n\tt^=true;\n      }else if(op[1]=='H'){\n\trr^=true;\n      }else{\n\tcr^=true;\n      }\n    }\n  }\n  long long h=314159265;\n  for(int i=D;i<=E;i++){\n    for(int j=F;j<=G;j++){\n      h=(31*h+org(i,j))%1000000007;\n    }\n  }\n  cout<<h<<endl;\n}\n\n    \n    "
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<map>\nusing namespace std;\nint row[41000];\nint col[41000];\nmap<pair<int,int>,int> m;\nchar str[10];\nint dir;\nint n;\npair<int,int> conv(int a,int b){\n\tint ret1;\n\tint ret2;\n\tswitch(dir&3){\n\t\tcase 0:\n\t\t\tret1=a;\n\t\t\tret2=b;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tret1=b;\n\t\t\tret2=n-a+1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret1=n-a+1;\n\t\t\tret2=n-b+1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tret1=n-b+1;\n\t\t\tret2=a;\n\t\t\tbreak;\n\t}\n\tif(dir&4)swap(ret1,ret2);\n\treturn make_pair(row[ret1],col[ret2]);\n}\nint main(){\n\tint a,b,c,d,e,f,g;\n\tint q;\n\tscanf(\"%d%d%d%d%d%d%d%d%d\",&n,&q,&a,&b,&c,&d,&e,&f,&g);\n\tlong long h=314159265;\n\tlong long mod=1000000007;\n\tfor(int i=1;i<=n;i++)row[i]=i;\n\tfor(int i=1;i<=n;i++)col[i]=i;\n\twhile(q--){\n\t\tscanf(\"%s\",str);\n\t\tif(str[0]=='W'){\n\t\t\tint R,C,V;\n\t\t\tscanf(\"%d%d%d\",&R,&C,&V);\n\t\t\tpair<int,int> at=conv(R,C);\n\t\t\tm[at]=V;\n\t\t}\n\t\tif(str[0]=='C'){\n\t\t\tint r1,c1,r2,c2;\n\t\t\tscanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n\t\t\tpair<int,int> at1=conv(r1,c1);\n\t\t\tpair<int,int> at2=conv(r2,c2);\n\t\t\tif(m.count(at1))m[at2]=m[at1];\n\t\t\telse m[at2]=((long long)at1.first*a+(long long)at1.second*b)%c;\n\t\t}\n\t\tif(str[0]=='S'){\n\t\t\tint r1,r2;\n\t\t\tscanf(\"%d%d\",&r1,&r2);\n\t\t\tif((dir/4+(str[1]=='R')+dir%4)&1){\n\t\t\t\tif((dir+1)%4<2)swap(row[r1],row[r2]);\n\t\t\t\telse swap(row[n-r1+1],row[n-r2+1]);\n\t\t\t}else{\n\t\t\t\tif(dir%4<2)swap(col[r1],col[r2]);\n\t\t\t\telse swap(col[n-r1+1],col[n-r2+1]);\n\t\t\t}\n\t\t}\n\t\tif(str[0]=='R'){\n\t\t\tif(str[1]=='L'){\n\t\t\t\tdir=(dir&4)+((dir%4+1)&3);\n\t\t\t}\n\t\t\tif(str[1]=='R'){\n\t\t\t\tdir=(dir&4)+((dir%4+3)&3);\n\t\t\t}\n\t\t\tif(str[1]=='H'){\n\t\t\t\tdir=((dir&4)?0:4)+(dir%4)^1;\n\t\t\t}\n\t\t\tif(str[1]=='V'){\n\t\t\t\tdir=((dir&4)?0:4)+(dir%4)^3;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=d;i<=e;i++){\n\t\tfor(int j=f;j<=g;j++){\n\t\t\tpair<int,int> at=conv(i,j);\n\t\t\tif(m.count(at))h=(h*31+m[at])%mod;\n\t\t\telse h=(h*31+((long long)at.first*a+(long long)at.second*b)%c)%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",h);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const long long  int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init(const int amax = MAX_MOD_N) {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < amax - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nlong long int N, Q, A, B, C, D, E, F, G;\n\nvector<int>xs;\nvector<int>revxs;\nvector<int>ys;\nvector<int>revys;\nbool ud_swap = false;\nbool lr_swap = false;\nint r_num = 0;\nmap<pair<int, int>, long long int>mp;\n\n//?????????\npair<int, int>rot(pair<int, int>p, const int num) {\n\tif (num == 0) {\n\t\treturn p;\n\t}\n\telse {\n\t\tp = rot(make_pair(p.second, N - 1 - p.first), num - 1);\n\t\treturn p;\n\t}\n}\npair<int, int>udsw(pair<int, int>p) {\n\treturn make_pair(p.first, N - 1 - p.second);\n}\npair<int, int>lrsw(pair<int, int>p) {\n\treturn make_pair(N - 1 - p.first, p.second);\n}\npair<int, int>getplace(pair<int, int>p) {\n\tp = rot(p, 4 - r_num);\n\tif (lr_swap)p = lrsw(p);\n\tif (ud_swap)p = udsw(p);\n\tp = make_pair(revxs[p.first], revys[p.second]);\n\treturn p;\n}\nlong long int  getnum(const pair<int, int>p, const bool flag = false) {\n\tconst pair<int, int>place = getplace(p);\n\tlong long int ans;\n\n\tif (mp.find(place) == mp.end()) {\n\t\tans = ((1 + place.second)*A + (1 + place.first)*B) % C;\n\t}\n\telse {\n\t\tans = mp[place];\n\t}\n\tif (flag) {\n\t\tcout << \"x:\" << place.first << \"   y:\" << place.second << \"   ans:\" << ans << endl;\n\t}\n\treturn ans;\n}\nvoid setnum(pair<int, int>p, long long int  num) {\n\tconst pair<int, int>place = getplace(p);\n\tmp[place] = num;\n}\nint main() {\n\t{\n\t\tcin >> N >> Q >> A >> B >> C >> D >> E >> F >> G;\n\t\txs.resize(N);\n\t\tiota(xs.begin(), xs.end(), 0);\n\t\tys = xs;\n\t\trevxs = xs;\n\t\trevys = xs;\n\t}\n\twhile (Q--) {\n\t\tstring st; cin >> st;\n\t\tif (st == \"WR\") {\n\t\t\tint y, x; cin >> y >> x;\n\t\t\ty--; x--;\n\t\t\tint r; cin >> r;\n\t\t\tsetnum(make_pair(x, y), r);\n\t\t}\n\t\telse if (st == \"CP\") {\n\t\t\tint y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n\t\t\ty1--; x1--; y2--; x2--;\n\t\t\tlong long int r = getnum(make_pair(x1, y1));\n\t\t\tsetnum(make_pair(x2, y2), r);\n\t\t}\n\t\telse if (st == \"SR\") {\n\t\t\tint y1, y2; cin >> y1 >> y2; y1--; y2--;\n\t\t\tint x1 = 0, x2 = 0;\n\n\t\t\tif (r_num == 0) {\n\n\t\t\t}\n\t\t\telse if (r_num == 2) {\n\t\t\t\tswap(y1, y2);\n\t\t\t\tswap(x1, x2);\n\t\t\t}\n\t\t\telse if (r_num == 1) {\n\t\t\t\tx1 = N - 1 - y1;\n\t\t\t\tx2 = N - 1 - y2;\n\t\t\t\ty1 = 0;\n\t\t\t\ty2 = 0;\n\t\t\t}\n\t\t\telse if (r_num == 3) {\n\t\t\t\tx1 = y1;\n\t\t\t\tx2 = y2;\n\t\t\t\ty1 = 0;\n\t\t\t\ty2 = 0;\n\t\t\t}\n\t\t\tif (ud_swap) {\n\t\t\t\ty1 = N - 1 - y1;\n\t\t\t\ty2 = N - 1 - y2;\n\t\t\t}\n\t\t\tif (lr_swap) {\n\t\t\t\tx1 = N - 1 - x1;\n\t\t\t\tx2 = N - 1 - x2;\n\t\t\t}\n\t\t\t{\n\t\t\t\tswap(ys[y1], ys[y2]);\n\t\t\t\trevys[ys[y1]] = y1;\n\t\t\t\trevys[ys[y2]] = y2;\n\t\t\t\tswap(xs[x1], xs[x2]);\n\t\t\t\trevxs[xs[x1]] = x1;\n\t\t\t\trevxs[xs[x2]] = x2;\n\t\t\t}\n\t\t}\n\t\telse if (st == \"SC\") {\n\t\t\tint x1, x2; cin >> x1 >> x2; x1--; x2--;\n\t\t\tint y1 = 0, y2 = 0;\n\n\t\t\tif (r_num == 0) {\n\n\t\t\t}\n\t\t\telse if (r_num == 2) {\n\t\t\t\tswap(y1, y2);\n\t\t\t\tswap(x1, x2);\n\t\t\t}\n\t\t\telse if (r_num == 1) {\n\t\t\t\ty1 =  x1;\n\t\t\t\ty2 =  x2;\n\t\t\t\tx1 = 0;\n\t\t\t\tx2 = 0;\n\t\t\t}\n\t\t\telse if (r_num == 3) {\n\t\t\t\ty1 = N - 1 - x1;\n\t\t\t\ty2 = N - 1 - x2;\n\t\t\t\tx1 = 0;\n\t\t\t\tx2 = 0;\n\t\t\t}\n\t\t\tif (ud_swap) {\n\t\t\t\ty1 = N - 1 - y1;\n\t\t\t\ty2 = N - 1 - y2;\n\t\t\t}\n\t\t\tif (lr_swap) {\n\t\t\t\tx1 = N - 1 - x1;\n\t\t\t\tx2 = N - 1 - x2;\n\t\t\t}\n\t\t\t{\n\t\t\t\tswap(ys[y1], ys[y2]);\n\t\t\t\trevys[ys[y1]] = y1;\n\t\t\t\trevys[ys[y2]] = y2;\n\t\t\t\tswap(xs[x1], xs[x2]);\n\t\t\t\trevxs[xs[x1]] = x1;\n\t\t\t\trevxs[xs[x2]] = x2;\n\t\t\t}\n\t\t}\n\t\telse if (st == \"RL\") {\n\t\t\t\n\t\t\tr_num = (r_num + 1) % 4;\n\t\t}\n\t\telse if (st == \"RR\") {\n\t\t\tr_num = (r_num + 3) % 4;\n\t\t}\n\t\telse if (st == \"RH\") {\n\t\t\tif (r_num % 2) {\n\t\t\t\tlr_swap = !lr_swap;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tud_swap = !ud_swap;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (r_num % 2) {\n\t\t\t\tud_swap = !ud_swap;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlr_swap = !lr_swap;\n\t\t\t}\n\t\t}\n\t}\n\tMod ans = 314159265;\n\tfor (int y = D - 1; y <= E - 1; ++y) {\n\t\tfor (int x = F - 1; x <= G - 1; ++x) {\n\t\t\tans = Mod(31) * ans + getnum(make_pair(x, y));\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <map>\n\nusing namespace std;\n\nconst int maxn=4e4+5;\n\nbool RH,RV,R;\nint row[maxn],colum[maxn];\nint A,B,C,D,E,F,G,n,q;\n\nstruct HashMap\n{\n    int mod;\n    int begin[100007],next[maxn],val[maxn],key[maxn];\n    int s,i,num;\n    void ini()\n    {\n        mod=100007;\n        memset(begin,-1,sizeof(begin));\n        num=0;\n    }\n    int back(int x,int y)\n    {\n        s=x*n+y;\n        for(i=begin[s%mod];i!=-1;i=next[i])\n            if(key[i]==s)return val[i];\n        return (A*(long long)x+B*(long long)y)%C;\n    }\n    void change(int x,int y,int k)\n    {\n        s=x*n+y;\n        for(i=begin[s%mod];i!=-1;i=next[i])\n            if(key[i]==s)\n            {\n                val[i]=k;\n                return;\n            }\n        key[num]=s;\n        val[num]=k;\n        s=s%mod;\n        next[num]=begin[s];\n        begin[s]=num++;\n    }\n}S;\n\nvoid change(int &r,int &c)\n{\n    if(R)swap(r,c);\n    if(RH)r=row[n+1-r];\n    else r=row[r];\n    if(RV)c=colum[n+1-c];\n    else c=colum[c];\n}\n\nconst int mod=1e9+7;\n\nint r1,r2,c1,c2,r,c,v;\nchar s[10];\n\nint main()\n{\n    scanf(\"%d%d\",&n,&q);\n    scanf(\"%d%d%d%d%d%d%d\",&A,&B,&C,&D,&E,&F,&G);\n    S.ini();\n    for(int i=1;i<=n;i++)\n        row[i]=colum[i]=i;\n    RH=RV=R=false;\n    for(int i=0;i<q;i++)\n    {\n        scanf(\"%s\",s);\n        if(s[0]=='W')\n        {\n            scanf(\"%d%d%d\",&r,&c,&v);\n            change(r,c);\n            S.change(r,c,v);\n        }\n        else if(s[0]=='C')\n        {\n            scanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n            change(r1,c1);\n            change(r2,c2);\n            S.change(r2,c2,S.back(r1,c1));\n        }\n        else if(s[0]=='S')\n        {\n            if(s[1]=='R')\n            {\n                scanf(\"%d%d\",&r1,&r2);\n                c1=c2=0;\n                if(R)\n                {\n                    swap(r1,c1);\n                    swap(r2,c2);\n                }\n                if(r1&&RH)r1=n+1-r1,r2=n+1-r2;\n                if(c1&&RV)c1=n+1-c1,c2=n+1-c2;\n                if(r1)swap(row[r1],row[r2]);\n                if(c1)swap(colum[c1],colum[c2]);\n            }\n            else if(s[1]=='C')\n            {\n                scanf(\"%d%d\",&c1,&c2);\n                r1=r2=0;\n                if(R)\n                {\n                    swap(r1,c1);\n                    swap(r2,c2);\n                }\n                if(r1&&RH)r1=n+1-r1,r2=n+1-r2;\n                if(c1&&RV)c1=n+1-c1,c2=n+1-c2;\n                if(r1)swap(row[r1],row[r2]);\n                if(c1)swap(colum[c1],colum[c2]);\n            }\n        }\n        else if(s[0]=='R')\n        {\n            if(s[1]=='L')\n            {\n                if(R)RH=!RH;\n                else RV=!RV;\n                R=!R;\n            }\n            else if(s[1]=='R')\n            {\n                if(R)RV=!RV;\n                else RH=!RH;\n                R=!R;\n            }\n            else if(s[1]=='H')\n            {\n                if(!R)RH=!RH;\n                else RV=!RV;\n            }\n            else if(s[1]=='V')\n            {\n                if(!R)RV=!RV;\n                else RH=!RH;\n            }\n        }\n    }\n    long long ans=314159265LL;\n    for(int i=D;i<=E;i++)\n        for(int j=F;j<=G;j++)\n        {\n            r=i,c=j;\n            change(r,c);\n            ans=(ans*31+S.back(r,c))%mod;\n        }\n    printf(\"%d\\n\",(int)ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef pair<int, int> P;\nint N, Q;\nint A, B, C;\nint D, E, F, G;\nint rot;\nint revy;\nint revx;\nint row[40404];\nint col[40404];\nvoid get(int& x, int& y) {\n    x--; y--;\n    if(revy) y = N - 1 - y;\n    if(revx) x = N - 1 - x;\n    if(rot) swap(y, x);\n\n    y = row[y];\n    x = col[x];\n}\n\nint init(int x, int y) {\n    return ((long long)(y + 1) * A + (long long)(x + 1) * B) % C;\n}\n\nvoid rotate() {\n    rot ^= 1;\n    bool nry = revx ^ 1;\n    bool nrx = revy;\n    revy = nry;\n    revx = nrx;\n}\n\nint main(){\n    while(cin >> N >> Q >> A >> B >> C >> D >> E >> F >> G) {\n\n        rot = revx = revy = false;\n        REP(i, N) row[i] = i;\n        REP(i, N) col[i] = i;\n\n        map<P, int> mat;\n\n        auto get_value = [&](int x, int y, bool insert=true) {\n            if(!mat.count(P(x, y))) {\n                if(insert) {\n                    mat[P(x, y)] = init(x, y);\n                } else {\n                    return init(x, y);\n                }\n            }\n            return mat[P(x, y)];\n        };\n\n        REP(_, Q) {\n            string s;\n            cin >> s;\n            //cout << s << \"!\" << endl;\n            if(s == \"WR\") {\n                int y, x, val;\n                cin >> y >> x >> val;\n                get(x, y);\n                mat[P(x, y)] = val;\n            } else if(s == \"CP\") {\n                int y1, x1, y2, x2;\n                cin >> y1 >> x1 >> y2 >> x2;\n                get(x1, y1);\n                get(x2, y2);\n                mat[P(x2, y2)] = get_value(x1, y1);\n            } else if(s == \"SR\") {\n                int y1, y2;\n                cin >> y1 >> y2;\n                y1--; y2--;\n                if(!rot) {\n                    if(revy) y1 = N - 1 - y1;\n                    if(revy) y2 = N - 1 - y2;\n                    swap(row[y1], row[y2]);\n                } else {\n                    int x1 = y1, x2 = y2;\n                    if(revy) x1 = N - 1 - x1;\n                    if(revy) x2 = N - 1 - x2;\n                    swap(col[x1], col[x2]);\n                }\n            } else if(s == \"SC\") {\n                int x1, x2;\n                cin >> x1 >> x2;\n                x1--; x2--;\n                if(rot) {\n                    int y1 = x1, y2 = x2;\n                    if(revx) y1 = N - 1 - y1;\n                    if(revx) y2 = N - 1 - y2;\n                    swap(row[y1], row[y2]);\n                } else {\n                    if(revx) x1 = N - 1 - x1;\n                    if(revx) x2 = N - 1 - x2;\n                    swap(col[x1], col[x2]);\n                }\n            } else if(s == \"RL\") {\n                rotate();\n            } else if(s == \"RR\") {\n                REP(i, 3) rotate();\n            } else if(s == \"RH\") {\n                revy ^= 1;\n            } else if(s == \"RV\") {\n                revx ^= 1;\n            } \n            // cerr << \"rot: \" << rot << endl;;\n            // cerr << \"revx: \" << revx << endl;;\n            // cerr << \"revy: \" << revy << endl;;\n        }\n\n        long long h = 314159265;\n        const int MOD = 1000000007;\n        // if(N < 10) {\n        //     for(int y = 0; y < N; y++) {\n        //         for(int x = 0; x < N; x++) {\n        //             int tx = x, ty = y;\n        //             get(tx, ty);\n        //             //cout << get_value(x, y) << \"(\" << init(x, y) << \") \";\n        //         }\n        //         //cout << endl;\n        //     }\n        // }\n        for(int y = D; y <= E; y++) {\n            for(int x = F; x <= G; x++) {\n                int tx = x, ty = y;\n                get(tx, ty);\n                //if(N < 10) printf(\"(%d, %d) -> (%d, %d)\\n\", x, y, tx, ty);\n                h = (h * 31 + get_value(tx, ty, false)) % MOD;\n            }\n        }\n        cout << h << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const deque<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Indices{\n\tvl data;\n\tbool reversed;\n\tIndices(int n):data(n),reversed(false){\n\t\tiota(all(data),0);\n\t}\n\tll& operator[](int i){\n\t\treturn reversed?data[data.size()-1-i]:data[i];\n\t}\n};\n\nstruct Matrix{\n\tconst int n,A,B,C,D,E,F,G;\n\tint dir; // 反時計回りに回した回数 mod 4\n\tIndices fr,fc;\n\tmap<tuple<int,int>,int> val;\n\tMatrix(int n,int A,int B,int C,int D,int E,int F,int G)\n\t\t:n(n),A(A),B(B),C(C),D(D),E(E),F(F),G(G),dir(0),fr(n),fc(n){\n\t}\n\tvoid Set(int i,int j,int x){ // WR\n\t\tif(dir==0) tie(i,j)=mt(fr[i],fc[j]);\n\t\tif(dir==1) tie(i,j)=mt(fr[j],fc[n-1-i]);\n\t\tif(dir==2) tie(i,j)=mt(fr[n-1-i],fc[n-1-j]);\n\t\tif(dir==3) tie(i,j)=mt(fr[n-1-j],fc[i]);\n\t\tval[mt(i,j)]=x;\n\t}\n\tvoid SwapRow(int i1,int i2){ // SR\n\t\tif(dir==0) swap(fr[i1],fr[i2]);\n\t\tif(dir==1) swap(fc[n-1-i1],fc[n-1-i2]);\n\t\tif(dir==2) swap(fr[n-1-i1],fr[n-1-i2]);\n\t\tif(dir==3) swap(fc[i1],fc[i2]);\n\t}\n\tvoid SwapColumn(int j1,int j2){ // SC\n\t\tif(dir==0) swap(fc[j1],fc[j2]);\n\t\tif(dir==1) swap(fr[j1],fr[j2]);\n\t\tif(dir==2) swap(fc[n-1-j1],fc[n-1-j2]);\n\t\tif(dir==3) swap(fr[n-1-j1],fr[n-1-j2]);\n\t}\n\tvoid RotateLeft(){ // RL\n\t\tdir=(dir+1)%4;\n\t}\n\tvoid RotateRight(){ // RR\n\t\tdir=(dir+3)%4;\n\t}\n\tvoid ReverseRow(){ // RH\n\t\tif(dir==0 || dir==2) fr.reversed^=1;\n\t\tif(dir==1 || dir==3) fc.reversed^=1;\n\t}\n\tvoid ReverseColumn(){ // RV\n\t\tif(dir==0 || dir==2) fc.reversed^=1;;\n\t\tif(dir==1 || dir==3) fr.reversed^=1;;\n\t}\n\tint Get(int i,int j){\n\t\tif(dir==0) tie(i,j)=mt(fr[i],fc[j]);\n\t\tif(dir==1) tie(i,j)=mt(fr[j],fc[n-1-i]);\n\t\tif(dir==2) tie(i,j)=mt(fr[n-1-i],fc[n-1-j]);\n\t\tif(dir==3) tie(i,j)=mt(fr[n-1-j],fc[i]);\n\t\tif(val.count(mt(i,j)))\n\t\t\treturn val[mt(i,j)];\n\t\telse\n\t\t\treturn (ll(i+1)*A+ll(j+1)*B)%C;\n\t};\n\tint Hash(){\n\t\tint h=314159265;\n\t\trepi(i,D-1,E) repi(j,F-1,G){\n\t\t\t//dump(vi({fr[i],fc[j],Get(i,j)}));\n\t\t\th=(31ll*h+Get(i,j))%MOD;\n\t\t}\n\t\treturn h;\n\t}\n\tvoid Print(){\n\t\trep(i,n){\n\t\t\trep(j,n) cout<<Get(i,j)<<' ';\n\t\t\tcout<<endl;\n\t\t}\n\t}\n};\n\nint main()\n{\n\tfor(int n,q;cin>>n>>q && n|q;){\n\t\tint A,B,C,D,E,F,G; cin>>A>>B>>C>>D>>E>>F>>G;\n\t\tMatrix mat(n,A,B,C,D,E,F,G);\n\t\trep(_,q){\n\t\t\tstring op; cin>>op;\n\t\t\tif(op==\"WR\"){\n\t\t\t\tint r,c,v; cin>>r>>c>>v; r--,c--;\n\t\t\t\tmat.Set(r,c,v);\n\t\t\t}\n\t\t\tif(op==\"CP\"){\n\t\t\t\tint r1,c1,r2,c2; cin>>r1>>c1>>r2>>c2; r1--,c1--,r2--,c2--;\n\t\t\t\tmat.Set(r2,c2,mat.Get(r1,c1));\n\t\t\t}\n\t\t\tif(op==\"SR\"){\n\t\t\t\tint r1,r2; cin>>r1>>r2; r1--,r2--;\n\t\t\t\tmat.SwapRow(r1,r2);\n\t\t\t}\n\t\t\tif(op==\"SC\"){\n\t\t\t\tint c1,c2; cin>>c1>>c2; c1--,c2--;\n\t\t\t\tmat.SwapColumn(c1,c2);\n\t\t\t}\n\t\t\tif(op==\"RL\") mat.RotateLeft();\n\t\t\tif(op==\"RR\") mat.RotateRight();\n\t\t\tif(op==\"RH\") mat.ReverseRow();\n\t\t\tif(op==\"RV\") mat.ReverseColumn();\n\t\t}\n\t\tcout<<mat.Hash()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 40005\n\nstruct Info{\n\tInfo(){\n\t\trow = col = 0;\n\t}\n\n\tInfo(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\tif(row != arg.row){\n\t\t\treturn row < arg.row;\n\t\t}else{\n\t\t\treturn col < arg.col;\n\t\t}\n\t}\n\tint row,col;\n};\n\nll N,num_query,A,B,C,D,E,F,G;\nint clock_table[8] = {1,2,3,0,7,4,5,6};\nint rev_clock_table[8] = {3,0,1,2,5,6,7,4};\nint LR[8] = {4,5,6,7,0,1,2,3};\nint UD[8] = {6,7,4,5,2,3,0,1};\nmap<Info,ll> MAP;\n\nint STATE;\nint row_table[NUM],col_table[NUM];\n\nll get_value(ll row,ll col){\n\n\tauto at = MAP.find(Info(row,col));\n\n\tif(at == MAP.end()){\n\t\tMAP[Info(row,col)] = (row*A+col*B)%C;\n\t}\n\treturn MAP[Info(row,col)];\n}\n\nInfo get_pos(ll row,ll col){\n\n\tInfo ret;\n\n\tswitch(STATE){\n\tcase 0:\n\t\tret.row = row;\n\t\tret.col = col;\n\t\tbreak;\n\tcase 1:\n\t\tret.row = N+1-col;\n\t\tret.col = row;\n\t\tbreak;\n\tcase 2:\n\t\tret.row = N+1-row;\n\t\tret.col = N+1-col;\n\t\tbreak;\n\tcase 3:\n\t\tret.row = col;\n\t\tret.col = N+1-row;\n\t\tbreak;\n\tcase 4:\n\t\tret.row = row;\n\t\tret.col = N+1-col;\n\t\tbreak;\n\tcase 5:\n\t\tret.row = col;\n\t\tret.col = row;\n\t\tbreak;\n\tcase 6:\n\t\tret.row = N+1-row;\n\t\tret.col = col;\n\t\tbreak;\n\tcase 7:\n\t\tret.row = N+1-col;\n\t\tret.col = N+1-row;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nInfo get_loc(ll row,ll col){\n\n\tInfo ret = get_pos(row,col);\n\n\tret.row = row_table[ret.row];\n\tret.col = col_table[ret.col];\n\n\treturn ret;\n}\n\nInfo get_loc2(ll row,ll col){\n\n\treturn get_pos(row,col);\n}\n\n\nint main(){\n\n\tscanf(\"%lld %lld %lld %lld %lld %lld %lld %lld %lld\",&N,&num_query,&A,&B,&C,&D,&E,&F,&G);\n\n\tSTATE = 0;\n\n\tfor(int i = 1; i <= N; i++){\n\t\trow_table[i] = i;\n\t\tcol_table[i] = i;\n\t}\n\n\tchar buf[3];\n\n\tll tmp_row1,tmp_col1,tmp_row2,tmp_col2,tmp_value;\n\tInfo info,info2;\n\n\tfor(int loop = 0; loop < num_query; loop++){\n\n\t\tscanf(\"%s\",buf);\n\n\t\tswitch(buf[0]){\n\t\tcase 'W': //書き込み命令\n\n\t\t\tscanf(\"%lld %lld %lld\",&tmp_row1,&tmp_col1,&tmp_value);\n\t\t\tinfo = get_loc(tmp_row1,tmp_col1);\n\t\t\tMAP[Info(info.row,info.col)] = tmp_value;\n\n\t\t\tbreak;\n\n\t\tcase 'C': //コピー命令\n\n\t\t\tscanf(\"%lld %lld %lld %lld\",&tmp_row1,&tmp_col1,&tmp_row2,&tmp_col2);\n\t\t\tinfo = get_loc(tmp_row1,tmp_col1);\n\t\t\tinfo2 = get_loc(tmp_row2,tmp_col2);\n\t\t\tMAP[Info(info2.row,info2.col)] = get_value(info.row,info.col);\n\n\t\t\tbreak;\n\t\tcase 'S':\n\n\t\t\tif(buf[1] == 'R'){ //行スワップ\n\n\t\t\t\tscanf(\"%lld %lld\",&tmp_row1,&tmp_row2);\n\t\t\t\tinfo = get_loc2(tmp_row1,0);\n\t\t\t\tinfo2 = get_loc2(tmp_row2,0);\n\n\t\t\t\tif(STATE%2){\n\t\t\t\t\tswap(col_table[info.col],col_table[info2.col]);\n\t\t\t\t}else{\n\t\t\t\t\tswap(row_table[info.row],row_table[info2.row]);\n\t\t\t\t}\n\n\t\t\t}else{ //列スワップ\n\n\t\t\t\tscanf(\"%lld %lld\",&tmp_col1,&tmp_col2);\n\t\t\t\tinfo = get_loc2(0,tmp_col1);\n\t\t\t\tinfo2 = get_loc2(0,tmp_col2);\n\n\t\t\t\tif(STATE%2){\n\t\t\t\t\tswap(row_table[info.row],row_table[info2.row]);\n\t\t\t\t}else{\n\t\t\t\t\tswap(col_table[info.col],col_table[info2.col]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 'R':\n\n\t\t\tswitch(buf[1]){\n\t\t\tcase 'L': //反時計90\n\n\t\t\t\tSTATE = rev_clock_table[STATE];\n\n\t\t\t\tbreak;\n\t\t\tcase 'R': //時計90\n\n\t\t\t\tSTATE = clock_table[STATE];\n\n\t\t\t\tbreak;\n\t\t\tcase 'H': //上下反転\n\n\t\t\t\tSTATE = UD[STATE];\n\n\t\t\t\tbreak;\n\t\t\tcase 'V': //左右反転\n\n\t\t\t\tSTATE = LR[STATE];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\tll ans = 314159265;\n\n\tfor(int row = D; row <= E;row++){\n\t\tfor(int col = F; col <=G; col++){\n\n\t\t\tinfo = get_loc(row,col);\n\n\t\t\tans = ans*31 + get_value(info.row,info.col);\n\t\t\tans %=MOD;\n\t    }\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const long long  int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init(const int amax = MAX_MOD_N) {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < amax - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nlong long int N, Q, A, B, C, D, E, F, G;\n\nvector<int>xs;\nvector<int>revxs;\nvector<int>ys;\nvector<int>revys;\nbool ud_swap = false;\nbool lr_swap = false;\nint r_num = 0;\nmap<pair<int, int>, long long int>mp;\n\n//?????????\npair<int, int>rot(pair<int, int>p, const int num) {\n\tif (num == 0) {\n\t\treturn p;\n\t}\n\telse {\n\t\tp = rot(make_pair(p.second, N - 1 - p.first), num - 1);\n\t\treturn p;\n\t}\n}\npair<int, int>udsw(pair<int, int>p) {\n\treturn make_pair(p.first, N - 1 - p.second);\n}\npair<int, int>lrsw(pair<int, int>p) {\n\treturn make_pair(N - 1 - p.first, p.second);\n}\npair<int, int>getplace(pair<int, int>p) {\n\tp = rot(p, 4 - r_num);\n\tif (lr_swap)p = lrsw(p);\n\tif (ud_swap)p = udsw(p);\n\tp = make_pair(xs[p.first], ys[p.second]);\n\treturn p;\n}\nlong long int  getnum(const pair<int, int>p, const bool flag = false) {\n\tconst pair<int, int>place = getplace(p);\n\tlong long int ans;\n\n\tif (mp.find(place) == mp.end()) {\n\t\tans = ((1 + place.second)*A + (1 + place.first)*B) % C;\n\t}\n\telse {\n\t\tans = mp[place];\n\t}\n\tif (flag) {\n\t\tcout << \"x:\" << place.first << \"   y:\" << place.second << \"   ans:\" << ans << endl;\n\t}\n\treturn ans;\n}\nvoid setnum(pair<int, int>p, long long int  num) {\n\tconst pair<int, int>place = getplace(p);\n\tmp[place] = num;\n}\nint main() {\n\t{\n\t\tcin >> N >> Q >> A >> B >> C >> D >> E >> F >> G;\n\t\txs.resize(N);\n\t\tiota(xs.begin(), xs.end(), 0);\n\t\tys = xs;\n\t\trevxs = xs;\n\t\trevys = xs;\n\t}\n\twhile (Q--) {\n\t\tstring st; cin >> st;\n\t\tif (st == \"WR\") {\n\t\t\tint y, x; cin >> y >> x;\n\t\t\ty--; x--;\n\t\t\tint r; cin >> r;\n\t\t\tsetnum(make_pair(x, y), r);\n\t\t}\n\t\telse if (st == \"CP\") {\n\t\t\tint y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n\t\t\ty1--; x1--; y2--; x2--;\n\t\t\tlong long int r = getnum(make_pair(x1, y1));\n\t\t\tsetnum(make_pair(x2, y2), r);\n\t\t}\n\t\telse if (st == \"SR\") {\n\t\t\tint y1, y2; cin >> y1 >> y2; y1--; y2--;\n\t\t\tint x1 = 0, x2 = 0;\n\n\t\t\tif (r_num == 0) {\n\n\t\t\t}\n\t\t\telse if (r_num == 2) {\n\t\t\t\ty1 = N - 1 - y1;\n\t\t\t\ty2 = N - 1 - y2;\n\t\t\t\tx1 = N - 1 - x1;\n\t\t\t\tx2 = N - 1 - x2;\n\t\t\t}\n\t\t\telse if (r_num == 1) {\n\t\t\t\tx1 = N - 1 - y1;\n\t\t\t\tx2 = N - 1 - y2;\n\t\t\t\ty1 = 0;\n\t\t\t\ty2 = 0;\n\t\t\t}\n\t\t\telse if (r_num == 3) {\n\t\t\t\tx1 = y1;\n\t\t\t\tx2 = y2;\n\t\t\t\ty1 = 0;\n\t\t\t\ty2 = 0;\n\t\t\t}\n\t\t\tif (ud_swap) {\n\t\t\t\ty1 = N - 1 - y1;\n\t\t\t\ty2 = N - 1 - y2;\n\t\t\t}\n\t\t\tif (lr_swap) {\n\t\t\t\tx1 = N - 1 - x1;\n\t\t\t\tx2 = N - 1 - x2;\n\t\t\t}\n\t\t\t{\n\t\t\t\tswap(ys[y1], ys[y2]);\n\t\t\t\trevys[ys[y1]] = y1;\n\t\t\t\trevys[ys[y2]] = y2;\n\t\t\t\tswap(xs[x1], xs[x2]);\n\t\t\t\trevxs[xs[x1]] = x1;\n\t\t\t\trevxs[xs[x2]] = x2;\n\t\t\t}\n\t\t}\n\t\telse if (st == \"SC\") {\n\t\t\tint x1, x2; cin >> x1 >> x2; x1--; x2--;\n\t\t\tint y1 = 0, y2 = 0;\n\n\t\t\tif (r_num == 0) {\n\n\t\t\t}\n\t\t\telse if (r_num == 2) {\n\t\t\t\ty1 = N - 1 - y1;\n\t\t\t\ty2 = N - 1 - y2;\n\t\t\t\tx1 = N - 1 - x1;\n\t\t\t\tx2 = N - 1 - x2;\n\t\t\t}\n\t\t\telse if (r_num == 1) {\n\t\t\t\ty1 =  x1;\n\t\t\t\ty2 =  x2;\n\t\t\t\tx1 = 0;\n\t\t\t\tx2 = 0;\n\t\t\t}\n\t\t\telse if (r_num == 3) {\n\t\t\t\ty1 = N - 1 - x1;\n\t\t\t\ty2 = N - 1 - x2;\n\t\t\t\tx1 = 0;\n\t\t\t\tx2 = 0;\n\t\t\t}\n\t\t\tif (ud_swap) {\n\t\t\t\ty1 = N - 1 - y1;\n\t\t\t\ty2 = N - 1 - y2;\n\t\t\t}\n\t\t\tif (lr_swap) {\n\t\t\t\tx1 = N - 1 - x1;\n\t\t\t\tx2 = N - 1 - x2;\n\t\t\t}\n\t\t\t{\n\t\t\t\tswap(ys[y1], ys[y2]);\n\t\t\t\trevys[ys[y1]] = y1;\n\t\t\t\trevys[ys[y2]] = y2;\n\t\t\t\tswap(xs[x1], xs[x2]);\n\t\t\t\trevxs[xs[x1]] = x1;\n\t\t\t\trevxs[xs[x2]] = x2;\n\t\t\t}\n\t\t}\n\t\telse if (st == \"RL\") {\n\t\t\t\n\t\t\tr_num = (r_num + 1) % 4;\n\t\t}\n\t\telse if (st == \"RR\") {\n\t\t\tr_num = (r_num + 3) % 4;\n\t\t}\n\t\telse if (st == \"RH\") {\n\t\t\tif (r_num % 2) {\n\t\t\t\tlr_swap = !lr_swap;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tud_swap = !ud_swap;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (r_num % 2) {\n\t\t\t\tud_swap = !ud_swap;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlr_swap = !lr_swap;\n\t\t\t}\n\t\t}\n\t}\n\tMod ans = 314159265;\n\tfor (int y = D - 1; y <= E - 1; ++y) {\n\t\tfor (int x = F - 1; x <= G - 1; ++x) {\n\t\t\tans = Mod(31) * ans + getnum(make_pair(x, y),true);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nint ROW[40001];\nint COL[40001];\nint N,Q,A,B,C,D,E,F,G;\n\n/*\n  state\n  \n  AB\n  CD\n\n  BD\n  AC\n\n  DC\n  BA\n\n  CA\n  DB\n\n  BA\n  DC\n\n  AC\n  BD\n\n  CD\n  AB\n\n  DB\n  CA\n */\npii func(int state, int r, int c) {\n  pii res;\n  if (state == 0) res = pii(r,c);\n  else if (state == 3) res = pii(N-1-c,r);\n  else if (state == 2) res = pii(N-1-r,N-1-c);\n  else if (state == 1) res = pii(c, N-1-r);\n  else if (state == 4) res = pii(r,N-1-c);\n  else if (state == 5) res = pii(c, r);\n  else if (state == 6) res = pii(N-1-r,c);\n  else if (state == 7) res = pii(N-1-c,N-1-r);\n  return pii(ROW[res.first], COL[res.second]);\n}\npii func2(int state, int r, int c) {\n  pii res;\n  if (state == 0) res = pii(r,c);\n  else if (state == 3) res = pii(N-1-c,r);\n  else if (state == 2) res = pii(N-1-r,N-1-c);\n  else if (state == 1) res = pii(c, N-1-r);\n  else if (state == 4) res = pii(r,N-1-c);\n  else if (state == 5) res = pii(c, r);\n  else if (state == 6) res = pii(N-1-r,c);\n  else if (state == 7) res = pii(N-1-c,N-1-r);\n  return pii(res.first, res.second);\n}\nmap<pii, int> mp;\n\nint get(int state, int r, int c) {\n  pii p = func(state, r, c);\n  //cout << r << \" \" << c << \" : \" << p.first << \",\" << p.second << \" \" << mp.count(pii(p)) << endl;\n  if (mp.count(pii(p))) return mp[pii(p)];\n  else return ((p.first+1LL)*A + (p.second+1LL)*B) % C;\n}\n\nint main() {\n  int rh[8] = {6,5,4,7,2,1,0,3};\n  int rv[8] = {4,7,6,5,0,3,2,1};\n  int NUM = 0;\n  while(cin>>N>>Q>>A>>B>>C>>D>>E>>F>>G) {\n    if (NUM++) return 0;\n    mp.clear();\n    REP(i,N) ROW[i] = COL[i] = i;\n    int state = 0;\n    \n    REP(i,Q+1) {\n      // cout << state << endl;\n      // REP(j, N) {\n      //   REP(k,N) cout << get(state,j,k) << \" \";\n      //   cout << endl;\n      // }cout << endl;\n      if (i==Q) break;\n      string op;\n      cin >> op;\n      // cout << op << endl;\n      if (op == \"WR\") {\n        int r,c,v;cin>>r>>c>>v;r--;c--;\n        //cout << func(state, r, c).first << \" \"<<func(state, r,c).second << endl;\n        mp[func(state, r, c)] = v;\n      } else if (op == \"CP\") {\n        int r1,c1,r2,c2;cin>>r1>>c1>>r2>>c2;r1--;c1--;r2--;c2--;\n        pii p2 = func(state, r2, c2);\n        mp[p2] = get(state, r1, c1);\n      } else if (op == \"SR\") {\n        int r1, r2; cin >> r1 >> r2; r1--;r2--;\n        pii p1 = func2(state, r1, 0), p2 = func2(state, r2, 0);\n        if (state % 2)\n          swap(COL[p1.second], COL[p2.second]);\n        else\n          swap(ROW[p1.first], ROW[p2.first]);\n      } else if (op == \"SC\") {\n        int c1, c2; cin >> c1 >> c2; c1--; c2--;\n        pii p1 = func2(state, 0, c1), p2 = func2(state, 0, c2);\n        if (state % 2)\n          swap(ROW[p1.first], ROW[p2.first]);\n        else\n          swap(COL[p1.second], COL[p2.second]);\n      } else if (op == \"RL\") {\n        state = (state + 1) % 4 + state/4*4;\n      } else if (op == \"RR\") {\n        state = (state + 3) % 4 + state/4*4;\n      } else if (op == \"RH\") {\n        state = rh[state];\n      } else {\n        state = rv[state];\n      }\n    }\n    ll h = 314159265;\n    for (int i=D-1; i<E; ++i) {\n      for (int j=F-1; j<G; ++j) {\n        int b = get(state, i, j);\n        //if (b < 0) cout << b << endl;\n        h = (31*h+b) % 1000000007;\n        //cout << h << endl;\n      }\n    }\n    cout << h << endl; \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <list>\n#include <stack>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <set>\nusing namespace std;\n\nconst long long mod = 1e9+7;\n\nmap<pair<int,int>, int> mp;\nmap<pair<int,int>, int>::iterator it;\n\nint pos_r[40010],pos_c[40010],row[40010],col[40010],Row,flag_R,flag_C,n;\n\nint get_x(int x,int y)\n{\n    int r;\n    if(Row==0)\n    {\n        if(flag_R==0)\n            r=pos_r[x];\n        else\n            r=pos_r[n+1-x];\n    }\n    else\n    {\n        if(flag_R==0)\n            r=pos_r[y];\n        else\n            r=pos_r[n+1-y];\n    }\n    return r;\n}\n\nint get_y(int x,int y)\n{\n    int c;\n    if(Row==0)\n    {\n        if(flag_C==0)\n            c=pos_c[y];\n        else\n            c=pos_c[n+1-y];\n    }\n    else\n    {\n        if(flag_C==0)\n            c=pos_c[x];\n        else\n            c=pos_c[n+1-x];\n    }\n}\n\nvoid swap_r(int x,int y)\n{\n    int a,b;\n    if(Row==0)\n    {\n        if(flag_R==0)\n        {\n            a=pos_r[x];\n            b=pos_r[y];\n            pos_r[y]=a;\n            pos_r[x]=b;\n        }\n        else\n        {\n            a=pos_r[n+1-x];\n            b=pos_r[n+1-y];\n            pos_r[n+1-x]=b;\n            pos_r[n+1-y]=a;\n        }\n    }\n    else\n    {\n        if(flag_C==0)\n        {\n            a=pos_c[x];\n            b=pos_c[y];\n            pos_c[y]=a;\n            pos_c[x]=b;\n        }\n        else\n        {\n            a=pos_c[n+1-x];\n            b=pos_c[n+1-y];\n            pos_c[n+1-x]=b;\n            pos_c[n+1-y]=a;\n        }\n    }\n}\n\nvoid swap_c(int x,int y)\n{\n    int a,b;\n    if(Row==1)\n    {\n        if(flag_R==0)\n        {\n            a=pos_r[x];\n            b=pos_r[y];\n            pos_r[y]=a;\n            pos_r[x]=b;\n        }\n        else\n        {\n            a=pos_r[n+1-x];\n            b=pos_r[n+1-y];\n            pos_r[n+1-x]=b;\n            pos_r[n+1-y]=a;\n        }\n    }\n    else\n    {\n        if(flag_C==0)\n        {\n            a=pos_c[x];\n            b=pos_c[y];\n            pos_c[y]=a;\n            pos_c[x]=b;\n        }\n        else\n        {\n            a=pos_c[n+1-x];\n            b=pos_c[n+1-y];\n            pos_c[n+1-x]=b;\n            pos_c[n+1-y]=a;\n        }\n    }\n}\n\nvoid RR()\n{\n    if(Row==0)\n    {\n        flag_R=1-flag_R;\n        Row=1-Row;\n    }\n    else\n    {\n        flag_C=1-flag_C;\n        Row=1-Row;\n    }\n}\n\nvoid RL()\n{\n    if(Row==0)\n    {\n        flag_C=1-flag_C;\n        Row=1-Row;\n    }\n    else\n    {\n        flag_R=1-flag_R;\n        Row=1-Row;\n    }\n}\n\nvoid RH()\n{\n    if(Row==0)\n        flag_R=1-flag_R;\n    else\n        flag_C=1-flag_C;\n}\n\nvoid RV()\n{\n    if(Row==0)\n        flag_C=1-flag_C;\n    else\n        flag_R=1-flag_R;\n}\n\nchar str[10];\n\nint main()\n{\n    int q,i,x,y,v,r1,r2,c1,c2,r,c,j;\n    int A,B,C,D,E,F,G;\n    scanf(\"%d%d\",&n,&q);\n    for(i=1;i<=n;i++)\n    {\n        row[i]=i;\n        col[i]=i;\n        pos_r[i]=i;\n        pos_c[i]=i;\n    }\n    Row=0;\n    flag_C=0;\n    flag_R=0;\n    scanf(\"%d%d%d%d%d%d%d\",&A,&B,&C,&D,&E,&F,&G);\n    mp.clear();\n    while(q--)\n    {\n        scanf(\"%s\",str);\n        if(str[0]=='W'&&str[1]=='R')\n        {\n            scanf(\"%d%d%d\",&x,&y,&v);\n            r=get_x(x,y);\n            c=get_y(x,y);\n            mp[make_pair(r,c)]=v;\n        }\n        else if(str[0]=='C'&&str[1]=='P')\n        {\n            scanf(\"%d%d%d\",&r1,&c1,&r2,&c2);\n            r=get_x(r1,c1);\n            c=get_y(r1,c1);\n            v=mp[make_pair(r,c)];\n            r=get_x(r2,c2);\n            c=get_y(r2,c2);\n            mp[make_pair(r,c)]=v;\n        }\n        else if(str[0]=='S'&&str[1]=='R')\n        {\n            scanf(\"%d%d\",&x,&y);\n            swap_r(x,y);\n        }\n        else if(str[0]=='S'&&str[1]=='C')\n        {\n            scanf(\"%d%d\",&x,&y);\n            swap_c(x,y);\n        }\n        else if(str[0]=='R'&&str[1]=='L')\n            RL();\n        else if(str[0]=='R'&&str[1]=='R')\n            RR();\n        else if(str[0]=='R'&&str[1]=='H')\n            RH();\n        else if(str[0]=='R'&&str[1]=='V')\n            RV();\n    }\n    long long h=314159265LL,w;\n    for(i=D;i<=E;i++)\n        for(j=F;j<=G;j++)\n        {\n            x=get_x(i,j);\n            y=get_y(i,j);\n            if(mp.find(make_pair(x,y))==mp.end())\n                w=(1LL*A*x+1LL*B*y)%C;\n            else\n                w=(long long)mp[make_pair(x,y)];\n       //     printf(\"%d %d %lld\\n\",i,j,w);\n            h=(h*31+w)%mod;\n        }\n    printf(\"%lld\\n\",h);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// * template\n\n#include <bits/stdc++.h>\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\ntemplate<class T, class U> inline void fill_array(T &e, const U &v) { e = v; }\ntemplate<class T, class U, size_t s> inline void fill_array(T (&a)[s], const U &v) {for(auto&e:a)fill_array(e,v);}\ntemplate<class T, class U, size_t s> inline void fill_array(array<T, s> &a, const U &v) {for(auto&e:a)fill_array(e,v);}\ntemplate<class T, class U> inline void fill_array(vector<T> &a, const U &v) {for(auto&e:a)fill_array(e,v);}\n\nstruct range {\n\ttypedef int Int;\n\tstruct iter {\n\t\tInt i;\n\t\tconst Int s;\n\t\titer(const Int &i_, const Int &s_):i(i_), s(s_) {}\n\t\tbool operator!=(const iter &r) const { return s > 0 ? i < r.i : i > r.i; }\n\t\tconst Int &operator*() const { return i; }\n\t\titer &operator++() { i += s; return *this; }\n\t};\n\tconst Int f, l, s;\n\trange(const Int &f_, const Int &l_, const Int &s_):f(f_), l(l_), s(s_) {}\n\trange(const Int &f_, const Int &l_):f(f_), l(l_), s(1) {}\n\trange(const Int &num):f(0), l(num), s(1) {}\n\titer begin() const { return iter(f, s); }\n\titer end() const { return iter(l, s); }\n};\n\n// * solve\n\nstruct matrix {\n\ttypedef pair<int, int> point;\n\tint N;\n\tlong long A, B, C;\n\tbool is_rotate;\n\tvector<int> row, column;\n\tmap<point, int> value;\n\n\tmatrix(int N_, int A_, int B_, int C_):N(N_), A(A_), B(B_), C(C_), is_rotate(false), row(N), column(N) {\n\t\tiota(begin(row), end(row), 0);\n\t\tiota(begin(column), end(column), 0);\n\t}\n\n\tpoint get_initial_index(const int r, const int c) const {\n\t\tint x = column[c];\n\t\tint y = row[r];\n\t\tif(is_rotate) swap(x, y);\n\t\treturn point(x, y);\n\t}\n\n\tint get_initial_value(const int r, const int c) const {\n\t\treturn ((r + 1) * A + (c + 1) * B) % C;\n\t}\n\n\tint get_value(const int r, const int c) const {\n\t    const point p = get_initial_index(r, c);\n\t\treturn value.count(p) ? value.at(p) : get_initial_value(p.second, p.first);\n\t}\n\n\tlong long get_hash(const int D, const int E, const int F, const int G) const {\n\t\tconstexpr long long mod = 1e9 + 7;\n\t\tlong long h = 314159265;\n\t\tfor(int r = D; r <= E; ++r) {\n\t\t\tfor(int c = F; c <= G; ++c) {\n\t\t\t\th = (31 * h + get_value(r, c)) % mod;\n\t\t\t}\n\t\t}\n\t\treturn h;\n\t}\n\n\tvoid write(const int r, const int c, const int v) {\n\t\tvalue[get_initial_index(r, c)] = v;\n\t}\n\n\tvoid copy(const int r1, const int c1, const int r2, const int c2) {\n\t\twrite(r1, c1, get_value(r2, c2));\n\t}\n\n\tvoid swap_row(const int r1, const int r2) {\n\t\tswap(row[r1], row[r2]);\n\t}\n\n\tvoid swap_column(const int c1, const int c2) {\n\t\tswap(column[c1], column[c2]);\n\t}\n\n\tvoid rotate_left() {\n\t\tswap(row, column);\n\t\tfor(auto &e : row) e = N - e - 1;\n\t\tis_rotate = !is_rotate;\n\t}\n\n\tvoid rotate_right() {\n\t\tswap(row, column);\n\t\tfor(auto &e : column) e = N - e - 1;\n\t\tis_rotate = !is_rotate;\n\t}\n\n\tvoid reflect_horizontal() {\n\t\treverse(begin(row), end(row));\n\t}\n\n\tvoid reflect_vertical() {\n\t\treverse(begin(column), end(column));\n\t}\n};\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint N, Q, A, B, C, D, E, F, G;\n\tcin >> N >> Q >> A >> B >> C >> D >> E >> F >> G;\n\n\tmatrix mat(N, A, B, C);\n\twhile(Q--) {\n\t\tstring command;\n\t\tcin >> command;\n\n\t\tif(command == \"WR\") {\n\t\t\tint r, c, v;\n\t\t\tcin >> r >> c >> v;\n\t\t\tmat.write(r - 1, c - 1, v);\n\t\t}\n\t\telse if(command == \"CP\") {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tmat.copy(r1 - 1, c1 - 1, r2 - 1, c2 - 1);\n\t\t}\n\t\telse if(command == \"SR\") {\n\t\t\tint r1, r2;\n\t\t\tcin >> r1 >> r2;\n\t\t\tmat.swap_row(r1 - 1, r2 - 1);\n\t\t}\n\t\telse if(command == \"SC\") {\n\t\t\tint c1, c2;\n\t\t\tcin >> c1 >> c2;\n\t\t\tmat.swap_column(c1 - 1, c2 - 1);\n\t\t}\n\t\telse if(command == \"RL\") {\n\t\t\tmat.rotate_left();\n\t\t}\n\t\telse if(command == \"RR\") {\n\t\t\tmat.rotate_right();\n\t\t}\n\t\telse if(command == \"RH\") {\n\t\t\tmat.reflect_horizontal();\n\t\t}\n\t\telse if(command == \"RV\") {\n\t\t\tmat.reflect_vertical();\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\tcout << mat.get_hash(D - 1, E - 1, F - 1, G - 1) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <map>\nusing namespace std;\nint n;\nint A, B, C;\nstruct Coordinates\n{\n    int map[40000];\n    bool rever;\n    Coordinates()\n    {\n        for (int i = 0; i < 40000; ++ i)\n            map[i] = i;\n        rever = false;\n    }\n    void reverse()\n    {\n        rever = !rever;\n    } \n    int &operator [] (int a)\n    {\n        if (rever == true)\n            return map[n - 1 - a];\n        else\n            return map[a];\n    }\n}X, Y;\nCoordinates &x = X, &y = Y;\nmap <pair <int, int>, int > num;\nbool flag = false;\npair <int, int> getCoorddinates(int a, int b)\n{\n    if (flag == false)\n        return make_pair(x[a], y[b]);\n    else\n        return make_pair(y[b], x[a]);\n}\nint calc(pair <int, int> a)\n{\n    return ((long long) a.first * A + A + (long long) a.second * B + B) % C;\n}\nint &getNum(pair <int, int> a)\n{\n    if (num.find(a) != num.end())\n        return num[a];\n    else\n        return num[a] = calc(a);\n}\nint getNum2(pair <int, int> a)\n{\n    if (num.find(a) != num.end())\n        return num[a];\n    else\n        return calc(a);\n}\nvoid reflectHorizontal()\n{\n    x.reverse();\n}\nvoid reflectVertical()\n{\n    y.reverse();\n}\nvoid rotateLeft()\n{\n    flag = !flag;\n    swap(x, y);\n    x.reverse();\n}\nvoid rotateRight()\n{\n    flag = !flag;\n    swap(x, y);\n    y.reverse();\n}\nvoid swapColumn(int a, int b)\n{\n    swap(y[a], y[b]);\n}\nvoid swapRow(int a, int b)\n{\n    swap(x[a], x[b]);\n}\nchar s[3];\nint main()\n{\n    int q;\n    scanf(\"%d%d\", &n, &q);\n    scanf(\"%d%d%d\", &A, &B, &C);\n    int D, E, F, G;\n    scanf(\"%d%d%d%d\", &D, &E, &F, &G);\n    while (q --)\n    {\n        scanf(\"%s\", s);\n        if (strcmp(s, \"WR\") == 0)\n        {\n            int r, c, v;\n            scanf(\"%d%d%d\", &r, &c, &v);\n            -- r;\n            -- c;\n            getNum(getCoorddinates(r, c)) = v;\n        }\n        else if (strcmp(s, \"CP\") == 0)\n        {\n            int r1, c1, r2, c2;\n            scanf(\"%d%d%d%d\", &r1, &c1, &r2, &c2);\n            -- r1;\n            -- c1;\n            -- r2;\n            -- c2;\n            getNum(getCoorddinates(r2, c2)) = getNum(getCoorddinates(r1, c1));\n        }\n        else if (strcmp(s, \"SR\") == 0)\n        {\n            int r1, r2;\n            scanf(\"%d%d\", &r1, &r2);\n            -- r1;\n            -- r2;\n            swapRow(r1, r2);\n        }\n        else if (strcmp(s, \"SC\") == 0)\n        {\n            int c1, c2;\n            scanf(\"%d%d\", &c1, &c2);\n            -- c1;\n            -- c2;\n            swapColumn(c1, c2);\n        }\n        else if (strcmp(s, \"RL\") == 0)\n            rotateLeft();\n        else if (strcmp(s, \"RR\") == 0)\n            rotateRight();\n        else if (strcmp(s, \"RH\") == 0)\n            reflectHorizontal();\n        else \n            reflectVertical();\n//        for (int r = 0; r < n; ++ r, puts(\"\"))\n//            for (int c = 0; c < n; ++ c)\n//                printf(\"%d \", getNum2(getCoorddinates(r, c)));\n    } \n    int h = 314159265;\n    for (int r = D - 1; r < E; ++ r)\n        for (int c = F - 1; c < G; ++ c)\n            h = ((long long) h * 31 + getNum2(getCoorddinates(r, c))) % 1000000007;\n    printf(\"%d\\n\", h);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const long long  int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init(const int amax = MAX_MOD_N) {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < amax - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nlong long int N, Q, A, B, C, D, E, F, G;\n\nvector<int>xs;\nvector<int>revxs;\nvector<int>ys;\nvector<int>revys;\nbool ud_swap = false;\nbool lr_swap = false;\nint r_num = 0;\nmap<pair<int, int>, long long int>mp;\n\n//?????????\npair<int, int>rot(pair<int, int>p, const int num) {\n\tif (num == 0) {\n\t\treturn p;\n\t}\n\telse {\n\t\tp = rot(make_pair(p.second, N - 1 - p.first), num - 1);\n\t\treturn p;\n\t}\n}\npair<int, int>udsw(pair<int, int>p) {\n\treturn make_pair(p.first, N - 1 - p.second);\n}\npair<int, int>lrsw(pair<int, int>p) {\n\treturn make_pair(N - 1 - p.first, p.second);\n}\npair<int, int>getplace(pair<int, int>p) {\n\tp = rot(p, 4 - r_num);\n\tif (lr_swap)p = lrsw(p);\n\tif (ud_swap)p = udsw(p);\n\tp = make_pair(xs[p.first], ys[p.second]);\n\treturn p;\n}\nlong long int  getnum(const pair<int, int>p, const bool flag = false) {\n\tconst pair<int, int>place = getplace(p);\n\tlong long int ans;\n\n\tif (mp.find(place) == mp.end()) {\n\t\tans = ((1 + place.second)*A + (1 + place.first)*B) % C;\n\t}\n\telse {\n\t\tans = mp[place];\n\t}\n\tif (flag) {\n\t\tcout << \"x:\" << place.first << \"   y:\" << place.second << \"   ans:\" << ans << endl;\n\t}\n\treturn ans;\n}\nvoid setnum(pair<int, int>p, long long int  num) {\n\tconst pair<int, int>place = getplace(p);\n\tmp[place] = num;\n}\nint main() {\n\t{\n\t\tcin >> N >> Q >> A >> B >> C >> D >> E >> F >> G;\n\t\txs.resize(N);\n\t\tiota(xs.begin(), xs.end(), 0);\n\t\tys = xs;\n\t\trevxs = xs;\n\t\trevys = xs;\n\t}\n\twhile (Q--) {\n\t\tstring st; cin >> st;\n\t\tif (st == \"WR\") {\n\t\t\tint y, x; cin >> y >> x;\n\t\t\ty--; x--;\n\t\t\tint r; cin >> r;\n\t\t\tsetnum(make_pair(x, y), r);\n\t\t}\n\t\telse if (st == \"CP\") {\n\t\t\tint y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n\t\t\ty1--; x1--; y2--; x2--;\n\t\t\tlong long int r = getnum(make_pair(x1, y1));\n\t\t\tsetnum(make_pair(x2, y2), r);\n\t\t}\n\t\telse if (st == \"SR\") {\n\t\t\tint y1, y2; cin >> y1 >> y2; y1--; y2--;\n\t\t\tint x1 = 0, x2 = 0;\n\n\t\t\tif (r_num == 0) {\n\n\t\t\t}\n\t\t\telse if (r_num == 2) {\n\t\t\t\ty1 = N - 1 - y1;\n\t\t\t\ty2 = N - 1 - y2;\n\t\t\t\tx1 = N - 1 - x1;\n\t\t\t\tx2 = N - 1 - x2;\n\t\t\t}\n\t\t\telse if (r_num == 1) {\n\t\t\t\tx1 = N - 1 - y1;\n\t\t\t\tx2 = N - 1 - y2;\n\t\t\t\ty1 = 0;\n\t\t\t\ty2 = 0;\n\t\t\t}\n\t\t\telse if (r_num == 3) {\n\t\t\t\tx1 = y1;\n\t\t\t\tx2 = y2;\n\t\t\t\ty1 = 0;\n\t\t\t\ty2 = 0;\n\t\t\t}\n\t\t\tif (ud_swap) {\n\t\t\t\ty1 = N - 1 - y1;\n\t\t\t\ty2 = N - 1 - y2;\n\t\t\t}\n\t\t\tif (lr_swap) {\n\t\t\t\tx1 = N - 1 - x1;\n\t\t\t\tx2 = N - 1 - x2;\n\t\t\t}\n\t\t\t{\n\t\t\t\tswap(ys[y1], ys[y2]);\n\t\t\t\trevys[ys[y1]] = y1;\n\t\t\t\trevys[ys[y2]] = y2;\n\t\t\t\tswap(xs[x1], xs[x2]);\n\t\t\t\trevxs[xs[x1]] = x1;\n\t\t\t\trevxs[xs[x2]] = x2;\n\t\t\t}\n\t\t}\n\t\telse if (st == \"SC\") {\n\t\t\tint x1, x2; cin >> x1 >> x2; x1--; x2--;\n\t\t\tint y1 = 0, y2 = 0;\n\n\t\t\tif (r_num == 0) {\n\n\t\t\t}\n\t\t\telse if (r_num == 2) {\n\t\t\t\ty1 = N - 1 - y1;\n\t\t\t\ty2 = N - 1 - y2;\n\t\t\t\tx1 = N - 1 - x1;\n\t\t\t\tx2 = N - 1 - x2;\n\t\t\t}\n\t\t\telse if (r_num == 1) {\n\t\t\t\ty1 =  x1;\n\t\t\t\ty2 =  x2;\n\t\t\t\tx1 = 0;\n\t\t\t\tx2 = 0;\n\t\t\t}\n\t\t\telse if (r_num == 3) {\n\t\t\t\ty1 = N - 1 - x1;\n\t\t\t\ty2 = N - 1 - x2;\n\t\t\t\tx1 = 0;\n\t\t\t\tx2 = 0;\n\t\t\t}\n\t\t\tif (ud_swap) {\n\t\t\t\ty1 = N - 1 - y1;\n\t\t\t\ty2 = N - 1 - y2;\n\t\t\t}\n\t\t\tif (lr_swap) {\n\t\t\t\tx1 = N - 1 - x1;\n\t\t\t\tx2 = N - 1 - x2;\n\t\t\t}\n\t\t\t{\n\t\t\t\tswap(ys[y1], ys[y2]);\n\t\t\t\trevys[ys[y1]] = y1;\n\t\t\t\trevys[ys[y2]] = y2;\n\t\t\t\tswap(xs[x1], xs[x2]);\n\t\t\t\trevxs[xs[x1]] = x1;\n\t\t\t\trevxs[xs[x2]] = x2;\n\t\t\t}\n\t\t}\n\t\telse if (st == \"RL\") {\n\t\t\t\n\t\t\tr_num = (r_num + 1) % 4;\n\t\t}\n\t\telse if (st == \"RR\") {\n\t\t\tr_num = (r_num + 3) % 4;\n\t\t}\n\t\telse if (st == \"RH\") {\n\t\t\tif (r_num % 2) {\n\t\t\t\tlr_swap = !lr_swap;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tud_swap = !ud_swap;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (r_num % 2) {\n\t\t\t\tud_swap = !ud_swap;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlr_swap = !lr_swap;\n\t\t\t}\n\t\t}\n\t}\n\tMod ans = 314159265;\n\tfor (int y = D - 1; y <= E - 1; ++y) {\n\t\tfor (int x = F - 1; x <= G - 1; ++x) {\n\t\t\tans = Mod(31) * ans + getnum(make_pair(x, y));\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const long long  int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init(const int amax = MAX_MOD_N) {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < amax - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n long long int N, Q, A, B, C, D, E, F, G;\n\nvector<int>xs;\nvector<int>revxs;\nvector<int>ys;\nvector<int>revys;\nbool ud_swap = false;\nbool lr_swap = false;\nint r_num = 0;\nmap<pair<int, int>,long long int>mp;\n\n//?????????\npair<int, int>rot(pair<int,int>p, const int num) {\n\tif (num== 0) {\n\t\treturn p;\n\t}\n\telse {\n\t\tp = rot(make_pair(p.second,N-1-p.first), num- 1);\n\t\treturn p;\n\t}\n}\npair<int, int>udsw(pair<int, int>p) {\n\treturn make_pair(p.first, N - 1 - p.second);\n}\npair<int, int>lrsw(pair<int, int>p) {\n\treturn make_pair(N-1-p.first, p.second);\n}\npair<int, int>getplace(pair<int, int>p ) {\n\tp = rot(p, 4 - r_num);\n\tif (lr_swap)p = lrsw(p);\n\tif (ud_swap)p = udsw(p);\n\tp = make_pair(revxs[p.first], revys[p.second]);\n\treturn p;\n}\nlong long int  getnum(const pair<int, int>p,const bool flag = false) {\n\tconst pair<int, int>place = getplace(p);\n\tlong long int ans;\n\t\n\tif (mp.find(place) == mp.end()) {\n\t\tans= ((1 + place.second)*A + (1 + place.first)*B) % C;\n\t}\n\telse {\n\t\tans = mp[place];\n\t}\n\tif (flag) {\n\t\tcout << \"x:\" << place.first << \"   y:\" << place.second <<  \"   ans:\"<<ans<<endl;\n\t}\n\treturn ans;\n}\nvoid setnum(pair<int, int>p,long long int  num) {\n\tconst pair<int, int>place = getplace(p);\n\tmp[place] = num;\n}\nint main() {\n\t{\n\t\tcin >> N >> Q >> A >> B >> C >> D >> E >> F >> G;\n\t\txs.resize(N);\n\t\tiota(xs.begin(), xs.end(), 0);\n\t\tys = xs;\n\t\trevxs = xs;\n\t\trevys = xs;\n\t}\n\twhile (Q--) {\n\t\tstring st; cin >> st;\n\t\tif (st == \"WR\") {\n\t\t\tint y, x; cin >> y >> x;\n\t\t\ty--; x--;\n\t\t\tint r; cin >> r;\n\t\t\tsetnum(make_pair(x, y), r);\n\t\t}\n\t\telse if (st == \"CP\") {\n\t\t\tint y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n\t\t\ty1--; x1--; y2--; x2--;\n\t\t\tlong long int r = getnum(make_pair(x1, y1));\n\t\t\tsetnum(make_pair(x2, y2), r);\n\t\t}\n\t\telse if (st == \"SR\") {\n\t\t\tint y1, y2; cin >> y1 >> y2; y1--; y2--;\n\t\t\tint x1 = 0, x2 = 0;\n\t\t\t\n\t\t\tif (r_num == 0) {\n\n\t\t\t}\n\t\t\telse if (r_num == 2) {\n\t\t\t\tswap(y1, y2);\n\t\t\t\tswap(x1, x2);\n\t\t\t}\n\t\t\telse if (r_num == 1) {\n\t\t\t\tx1 = N - 1 - y1;\n\t\t\t\tx2 = N - 1 - y2;\n\t\t\t\ty1 = 0;\n\t\t\t\ty2 = 0;\n\t\t\t}\n\t\t\telse if (r_num == 3) {\n\t\t\t\tx1 = y1;\n\t\t\t\tx2 = y2;\n\t\t\t\ty1 = 0;\n\t\t\t\ty2 = 0;\n\t\t\t}\n\t\t\tif (ud_swap) {\n\t\t\t\ty1 = N - 1 - y1;\n\t\t\t\ty2 = N - 1 - y2;\n\t\t\t}\n\t\t\tif (lr_swap) {\n\t\t\t\tx1 = N - 1 - x1;\n\t\t\t\tx2 = N - 1 - x2;\n\t\t\t}\n\t\t\t{\n\t\t\t\tswap(ys[y1], ys[y2]);\n\t\t\t\trevys[ys[y1]] = y1;\n\t\t\t\trevys[ys[y2]] = y2;\n\t\t\t\tswap(xs[x1], xs[x2]);\n\t\t\t\trevxs[xs[x1]] = x1;\n\t\t\t\trevxs[xs[x2]] = x2;\n\t\t\t}\n\t\t}\n\t\telse if (st == \"SC\") {\n\t\t\tint x1, x2; cin >> x1 >> x2; x1--; x2--;\n\t\t\tint y1 = 0, y2 = 0;\n\n\t\t\tif (r_num == 0) {\n\n\t\t\t}\n\t\t\telse if (r_num == 2) {\n\t\t\t\tswap(y1, y2);\n\t\t\t\tswap(x1, x2);\n\t\t\t}\n\t\t\telse if (r_num == 1) {\n\t\t\t\tx1 = N - 1 - y1;\n\t\t\t\tx2 = N - 1 - y2;\n\t\t\t\ty1 = 0;\n\t\t\t\ty2 = 0;\n\t\t\t}\n\t\t\telse if (r_num == 3) {\n\t\t\t\tx1 = y1;\n\t\t\t\tx2 = y2;\n\t\t\t\ty1 = 0;\n\t\t\t\ty2 = 0;\n\t\t\t}\n\t\t\tif (ud_swap) {\n\t\t\t\ty1 = N - 1 - y1;\n\t\t\t\ty2 = N - 1 - y2;\n\t\t\t}\n\t\t\tif (lr_swap) {\n\t\t\t\tx1 = N - 1 - x1;\n\t\t\t\tx2 = N - 1 - x2;\n\t\t\t}\n\t\t\t{\n\t\t\t\tswap(ys[y1], ys[y2]);\n\t\t\t\trevys[ys[y1]] = y1;\n\t\t\t\trevys[ys[y2]] = y2;\n\t\t\t\tswap(xs[x1], xs[x2]);\n\t\t\t\trevxs[xs[x1]] = x1;\n\t\t\t\trevxs[xs[x2]] = x2;\n\t\t\t}\n\t\t}\n\t\telse if (st == \"RL\") {\n\t\t\tr_num = (r_num + 1) % 4;\n\t\t}\n\t\telse if (st == \"RR\") {\n\t\t\tr_num = (r_num + 3) % 4;\n\t\t}\n\t\telse if (st == \"RH\") {\n\t\t\tif (r_num % 2) {\n\t\t\t\tlr_swap = !lr_swap;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tud_swap = !ud_swap;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (r_num % 2) {\n\t\t\t\tud_swap = !ud_swap;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlr_swap = !lr_swap;\n\t\t\t}\n\t\t}\n\t}\n\tMod ans = 314159265;\n\tfor (int y = D-1; y <= E-1; ++y) {\n\t\tfor (int x = F-1; x <= G-1; ++x) {\n\t\t\tans = Mod(31) * ans+ getnum(make_pair(x, y));\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\n#define locate(r,c) {(dr[0]*(r)+dc[0]*(c)+n+1)%(n+1),(dr[1]*(r)+dc[1]*(c)+n+1)%(n+1)}\n#define origin(x)   (((x).first*1ll*A+(x).second*1ll*B)%C)\n\ntypedef pair<int,int> PII;\nint row[40005],col[40005];\nmap<PII,int> w;\n\nint main(){\n    char s[200];\n    int n,m,A,B,C,D,E,F,G,r1,r2,c1,c2,at;\n    int dr[2]={1,0},dc[2]={0,1};\n    scanf(\"%d%d%d%d%d%d%d%d%d\",&n,&m,&A,&B,&C,&D,&E,&F,&G);\n    for(int i=1;i<=n;i++) row[i]=col[i]=i;\n    for(int i=1;i<=m;i++){\n        scanf(\"%s\",s);\n        if(!strcmp(s,\"WR\")){\n            scanf(\"%d%d%d\",&r1,&c1,&at);\n            int u[2]=locate(r1,c1);\n            w[PII(row[u[0]],col[u[1]])]=at;\n        }else if(!strcmp(s,\"CP\")){\n            scanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n            int u[2]=locate(r1,c1);\n            int v[2]=locate(r2,c2);\n            PII up(row[u[0]],col[u[1]]);\n            PII vp(row[v[0]],col[v[1]]);\n            if(w.count(up)) w[vp]=w[up];\n            else w[vp]=origin(up);\n        }else if(!strcmp(s,\"SR\")){\n            scanf(\"%d%d\",&r1,&r2);\n            int u[2]=locate(r1,0);\n            int v[2]=locate(r2,0);\n            swap(row[u[0]],row[v[0]]);\n            swap(col[u[1]],col[v[1]]);\n        }else if(!strcmp(s,\"SC\")){\n            scanf(\"%d%d\",&c1,&c2);\n            int u[2]=locate(0,c1);\n            int v[2]=locate(0,c2);\n            swap(row[u[0]],row[v[0]]);\n            swap(col[u[1]],col[v[1]]);\n        }else if(!strcmp(s,\"RL\")){\n            swap(dr[0]*=-1,dr[1]);\n            swap(dc[0]*=-1,dc[1]);\n        }else if(!strcmp(s,\"RR\")){\n            swap(dr[0],dr[1]*=-1);\n            swap(dc[0],dc[1]*=-1);\n        }else if(!strcmp(s,\"RH\")){\n            dr[0]*=-1,dc[0]*=-1;\n        }else if(!strcmp(s,\"RV\")){\n            dr[1]*=-1,dc[1]*=-1;\n        }\n    }\n    int H=314159265;\n    for(int r=D;r<=E;r++)\n    for(int c=F;c<=G;c++){\n        int u[2]=locate(r,c);\n        PII up(row[u[0]],col[u[1]]);\n        H=(31*1ll*H+(w.count(up)?w[up]:origin(up)))%1000000007;\n    }\n    printf(\"%d\\n\",H);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const long long  int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init(const int amax = MAX_MOD_N) {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < amax - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nlong long int N, Q, A, B, C, D, E, F, G;\n\nvector<int>xs;\nvector<int>revxs;\nvector<int>ys;\nvector<int>revys;\nbool ud_swap = false;\nbool lr_swap = false;\nint r_num = 0;\nmap<pair<int, int>, long long int>mp;\n\n//?????????\npair<int, int>rot(pair<int, int>p, const int num) {\n\tif (num == 0) {\n\t\treturn p;\n\t}\n\telse {\n\t\tp = rot(make_pair(p.second, N - 1 - p.first), num - 1);\n\t\treturn p;\n\t}\n}\npair<int, int>udsw(pair<int, int>p) {\n\treturn make_pair(p.first, N - 1 - p.second);\n}\npair<int, int>lrsw(pair<int, int>p) {\n\treturn make_pair(N - 1 - p.first, p.second);\n}\npair<int, int>getplace(pair<int, int>p) {\n\tp = rot(p, 4 - r_num);\n\tif (lr_swap)p = lrsw(p);\n\tif (ud_swap)p = udsw(p);\n\tp = make_pair(xs[p.first], ys[p.second]);\n\treturn p;\n}\nlong long int  getnum(const pair<int, int>p, const bool flag = false) {\n\tconst pair<int, int>place = getplace(p);\n\tlong long int ans;\n\n\tif (mp.find(place) == mp.end()) {\n\t\tans = ((1 + place.second)*A + (1 + place.first)*B) % C;\n\t}\n\telse {\n\t\tans = mp[place];\n\t}\n\tif (flag) {\n\t\tcout << \"x:\" << place.first << \"   y:\" << place.second << \"   ans:\" << ans << endl;\n\t}\n\treturn ans;\n}\nvoid setnum(pair<int, int>p, long long int  num) {\n\tconst pair<int, int>place = getplace(p);\n\tmp[place] = num;\n}\nint main() {\n\t{\n\t\tcin >> N >> Q >> A >> B >> C >> D >> E >> F >> G;\n\t\txs.resize(N);\n\t\tiota(xs.begin(), xs.end(), 0);\n\t\tys = xs;\n\t\trevxs = xs;\n\t\trevys = xs;\n\t}\n\twhile (Q--) {\n\t\tstring st; cin >> st;\n\t\tif (st == \"WR\") {\n\t\t\tint y, x; cin >> y >> x;\n\t\t\ty--; x--;\n\t\t\tint r; cin >> r;\n\t\t\tsetnum(make_pair(x, y), r);\n\t\t}\n\t\telse if (st == \"CP\") {\n\t\t\tint y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n\t\t\ty1--; x1--; y2--; x2--;\n\t\t\tlong long int r = getnum(make_pair(x1, y1));\n\t\t\tsetnum(make_pair(x2, y2), r);\n\t\t}\n\t\telse if (st == \"SR\") {\n\t\t\tint y1, y2; cin >> y1 >> y2; y1--; y2--;\n\t\t\tint x1 = 0, x2 = 0;\n\n\t\t\tif (r_num == 0) {\n\n\t\t\t}\n\t\t\telse if (r_num == 2) {\n\t\t\t\tswap(y1, y2);\n\t\t\t\tswap(x1, x2);\n\t\t\t}\n\t\t\telse if (r_num == 1) {\n\t\t\t\tx1 = N - 1 - y1;\n\t\t\t\tx2 = N - 1 - y2;\n\t\t\t\ty1 = 0;\n\t\t\t\ty2 = 0;\n\t\t\t}\n\t\t\telse if (r_num == 3) {\n\t\t\t\tx1 = y1;\n\t\t\t\tx2 = y2;\n\t\t\t\ty1 = 0;\n\t\t\t\ty2 = 0;\n\t\t\t}\n\t\t\tif (ud_swap) {\n\t\t\t\ty1 = N - 1 - y1;\n\t\t\t\ty2 = N - 1 - y2;\n\t\t\t}\n\t\t\tif (lr_swap) {\n\t\t\t\tx1 = N - 1 - x1;\n\t\t\t\tx2 = N - 1 - x2;\n\t\t\t}\n\t\t\t{\n\t\t\t\tswap(ys[y1], ys[y2]);\n\t\t\t\trevys[ys[y1]] = y1;\n\t\t\t\trevys[ys[y2]] = y2;\n\t\t\t\tswap(xs[x1], xs[x2]);\n\t\t\t\trevxs[xs[x1]] = x1;\n\t\t\t\trevxs[xs[x2]] = x2;\n\t\t\t}\n\t\t}\n\t\telse if (st == \"SC\") {\n\t\t\tint x1, x2; cin >> x1 >> x2; x1--; x2--;\n\t\t\tint y1 = 0, y2 = 0;\n\n\t\t\tif (r_num == 0) {\n\n\t\t\t}\n\t\t\telse if (r_num == 2) {\n\t\t\t\tswap(y1, y2);\n\t\t\t\tswap(x1, x2);\n\t\t\t}\n\t\t\telse if (r_num == 1) {\n\t\t\t\ty1 =  x1;\n\t\t\t\ty2 =  x2;\n\t\t\t\tx1 = 0;\n\t\t\t\tx2 = 0;\n\t\t\t}\n\t\t\telse if (r_num == 3) {\n\t\t\t\ty1 = N - 1 - x1;\n\t\t\t\ty2 = N - 1 - x2;\n\t\t\t\tx1 = 0;\n\t\t\t\tx2 = 0;\n\t\t\t}\n\t\t\tif (ud_swap) {\n\t\t\t\ty1 = N - 1 - y1;\n\t\t\t\ty2 = N - 1 - y2;\n\t\t\t}\n\t\t\tif (lr_swap) {\n\t\t\t\tx1 = N - 1 - x1;\n\t\t\t\tx2 = N - 1 - x2;\n\t\t\t}\n\t\t\t{\n\t\t\t\tswap(ys[y1], ys[y2]);\n\t\t\t\trevys[ys[y1]] = y1;\n\t\t\t\trevys[ys[y2]] = y2;\n\t\t\t\tswap(xs[x1], xs[x2]);\n\t\t\t\trevxs[xs[x1]] = x1;\n\t\t\t\trevxs[xs[x2]] = x2;\n\t\t\t}\n\t\t}\n\t\telse if (st == \"RL\") {\n\t\t\t\n\t\t\tr_num = (r_num + 1) % 4;\n\t\t}\n\t\telse if (st == \"RR\") {\n\t\t\tr_num = (r_num + 3) % 4;\n\t\t}\n\t\telse if (st == \"RH\") {\n\t\t\tif (r_num % 2) {\n\t\t\t\tlr_swap = !lr_swap;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tud_swap = !ud_swap;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (r_num % 2) {\n\t\t\t\tud_swap = !ud_swap;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlr_swap = !lr_swap;\n\t\t\t}\n\t\t}\n\t}\n\tMod ans = 314159265;\n\tfor (int y = D - 1; y <= E - 1; ++y) {\n\t\tfor (int x = F - 1; x <= G - 1; ++x) {\n\t\t\tans = Mod(31) * ans + getnum(make_pair(x, y));\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// * template\n\n#include <bits/stdc++.h>\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\ntemplate<class T, class U> inline void fill_array(T &e, const U &v) { e = v; }\ntemplate<class T, class U, size_t s> inline void fill_array(T (&a)[s], const U &v) {for(auto&e:a)fill_array(e,v);}\ntemplate<class T, class U, size_t s> inline void fill_array(array<T, s> &a, const U &v) {for(auto&e:a)fill_array(e,v);}\ntemplate<class T, class U> inline void fill_array(vector<T> &a, const U &v) {for(auto&e:a)fill_array(e,v);}\n\nstruct range {\n\ttypedef int Int;\n\tstruct iter {\n\t\tInt i;\n\t\tconst Int s;\n\t\titer(const Int &i_, const Int &s_):i(i_), s(s_) {}\n\t\tbool operator!=(const iter &r) const { return s > 0 ? i < r.i : i > r.i; }\n\t\tconst Int &operator*() const { return i; }\n\t\titer &operator++() { i += s; return *this; }\n\t};\n\tconst Int f, l, s;\n\trange(const Int &f_, const Int &l_, const Int &s_):f(f_), l(l_), s(s_) {}\n\trange(const Int &f_, const Int &l_):f(f_), l(l_), s(1) {}\n\trange(const Int &num):f(0), l(num), s(1) {}\n\titer begin() const { return iter(f, s); }\n\titer end() const { return iter(l, s); }\n};\n\n// * solve\n\nstruct matrix {\n\ttypedef pair<int, int> point;\n\tint N;\n\tlong long A, B, C;\n\tbool is_rotate;\n\tvector<int> row, column;\n\tmap<point, int> value;\n\n\tmatrix(int N_, int A_, int B_, int C_):N(N_), A(A_), B(B_), C(C_), is_rotate(false), row(N), column(N) {\n\t\tiota(begin(row), end(row), 0);\n\t\tiota(begin(column), end(column), 0);\n\t}\n\n\tpoint get_initial_index(const int r, const int c) const {\n\t\tint x = column[c];\n\t\tint y = row[r];\n\t\tif(is_rotate) swap(x, y);\n\t\treturn point(x, y);\n\t}\n\n\tint get_initial_value(const int r, const int c) const {\n\t\treturn ((r + 1) * A + (c + 1) * B) % C;\n\t}\n\n\tint get_value(const int r, const int c) const {\n\t    const point p = get_initial_index(r, c);\n\t\treturn value.count(p) ? value.at(p) : get_initial_value(p.second, p.first);\n\t}\n\n\tlong long get_hash(const int D, const int E, const int F, const int G) const {\n\t\tconstexpr long long mod = 1e9 + 7;\n\t\tlong long h = 314159265;\n\t\tfor(int r = D; r <= E; ++r) {\n\t\t\tfor(int c = F; c <= G; ++c) {\n\t\t\t\th = (31 * h + get_value(r, c)) % mod;\n\t\t\t}\n\t\t}\n\t\treturn h;\n\t}\n\n\tvoid write(const int r, const int c, const int v) {\n\t\tvalue[get_initial_index(r, c)] = v;\n\t}\n\n\tvoid copy(const int r1, const int c1, const int r2, const int c2) {\n\t\twrite(r2, c2, get_value(r1, c1));\n\t}\n\n\tvoid swap_row(const int r1, const int r2) {\n\t\tswap(row[r1], row[r2]);\n\t}\n\n\tvoid swap_column(const int c1, const int c2) {\n\t\tswap(column[c1], column[c2]);\n\t}\n\n\tvoid rotate_left() {\n\t\tswap(row, column);\n\t\tfor(auto &e : row) e = N - e - 1;\n\t\tis_rotate = !is_rotate;\n\t}\n\n\tvoid rotate_right() {\n\t\tswap(row, column);\n\t\tfor(auto &e : column) e = N - e - 1;\n\t\tis_rotate = !is_rotate;\n\t}\n\n\tvoid reflect_horizontal() {\n\t\treverse(begin(row), end(row));\n\t}\n\n\tvoid reflect_vertical() {\n\t\treverse(begin(column), end(column));\n\t}\n};\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint N, Q, A, B, C, D, E, F, G;\n\tcin >> N >> Q >> A >> B >> C >> D >> E >> F >> G;\n\n\tmatrix mat(N, A, B, C);\n\twhile(Q--) {\n\t\tstring command;\n\t\tcin >> command;\n\n\t\tif(command == \"WR\") {\n\t\t\tint r, c, v;\n\t\t\tcin >> r >> c >> v;\n\t\t\tmat.write(r - 1, c - 1, v);\n\t\t}\n\t\telse if(command == \"CP\") {\n\t\t\tint r1, c1, r2, c2;\n\t\t\tcin >> r1 >> c1 >> r2 >> c2;\n\t\t\tmat.copy(r1 - 1, c1 - 1, r2 - 1, c2 - 1);\n\t\t}\n\t\telse if(command == \"SR\") {\n\t\t\tint r1, r2;\n\t\t\tcin >> r1 >> r2;\n\t\t\tmat.swap_row(r1 - 1, r2 - 1);\n\t\t}\n\t\telse if(command == \"SC\") {\n\t\t\tint c1, c2;\n\t\t\tcin >> c1 >> c2;\n\t\t\tmat.swap_column(c1 - 1, c2 - 1);\n\t\t}\n\t\telse if(command == \"RL\") {\n\t\t\tmat.rotate_left();\n\t\t}\n\t\telse if(command == \"RR\") {\n\t\t\tmat.rotate_right();\n\t\t}\n\t\telse if(command == \"RH\") {\n\t\t\tmat.reflect_horizontal();\n\t\t}\n\t\telse if(command == \"RV\") {\n\t\t\tmat.reflect_vertical();\n\t\t}\n\t\telse {\n\t\t\tassert(false);\n\t\t}\n\t}\n\tcout << mat.get_hash(D - 1, E - 1, F - 1, G - 1) << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\ntemplate <class T>\nvector<vector<T> > matrixProduct(const vector<vector<T> >& x, const vector<vector<T> >& y)\n{\n    vector<vector<T> > z(2, vector<T>(2, 0));\n    for(int i=0; i<2; ++i){\n        for(int j=0; j<2; ++j){\n            for(int k=0; k<2; ++k){\n                z[i][j] += x[i][k] * y[k][j];\n            }\n        }\n    }\n    return z;\n}\n\nint n;\n\ntemplate <class T>\nvector<T> transform(const vector<vector<T> >& x, const vector<T>& y)\n{\n    vector<T> z(2);\n    z[0] = x[0][0] * y[0] + x[0][1] * y[1];\n    z[1] = x[1][0] * y[0] + x[1][1] * y[1];\n    if(z[0] < 0)\n        z[0] = n + 1 + z[0];\n    if(z[1] < 0)\n        z[1] = n + 1 + z[1];\n    return z;\n}\n\nint main()\n{\n    int q;\n    long long a, b, c;\n    int d, e, f, g;\n    cin >> n >> q >> a >> b >> c >> d >> e >> f >> g;\n\n    map<vector<int>, int> change;\n    vector<vector<int> > p(2, vector<int>(2, 0));\n    p[0][0] = p[1][1] = 1;\n    vector<int> toY(n+1), toX(n+1);\n    for(int i=1; i<=n; ++i)\n        toY[i] = toX[i] = i;\n\n    while(--q >= 0){\n        string s;\n        cin >> s;\n\n        if(s == \"WR\"){\n            vector<int> q(2);\n            int v;\n            cin >> q[0] >> q[1] >> v;\n            q = transform(p, q);\n            q[0] = toY[q[0]];\n            q[1] = toX[q[1]];\n            change[q] = v;\n        }else if(s == \"CP\"){\n            vector<int> q(2), r(2);\n            cin >> q[0] >> q[1] >> r[0] >> r[1];\n            q = transform(p, q);\n            r = transform(p, r);\n            q[0] = toY[q[0]];\n            q[1] = toX[q[1]];\n            r[0] = toY[r[0]];\n            r[1] = toX[r[1]];\n            if(change.find(q) == change.end())\n                change[r] = (q[0] * a + q[1] * b) % c;\n            else\n                change[r] = change[q];\n        }else if(s == \"SR\"){\n            vector<int> q(2), r(2);\n            cin >> q[0] >> r[0];\n            q = transform(p, q);\n            r = transform(p, r);\n            swap(toY[q[0]], toY[r[0]]);\n            swap(toX[q[1]], toX[r[1]]);\n        }else if(s == \"SC\"){\n            vector<int> q(2), r(2);\n            cin >> q[1] >> r[1];\n            q = transform(p, q);\n            r = transform(p, r);\n            swap(toY[q[0]], toY[r[0]]);\n            swap(toX[q[1]], toX[r[1]]);\n        }else if(s == \"RL\"){\n            vector<vector<int> > q(2, vector<int>(2, 0));\n            q[0][1] = 1;\n            q[1][0] = -1;\n            p = matrixProduct(p, q);\n        }else if(s == \"RR\"){\n            vector<vector<int> > q(2, vector<int>(2, 0));\n            q[0][1] = -1;\n            q[1][0] = 1;\n            p = matrixProduct(p, q);\n        }else if(s == \"RH\"){\n            vector<vector<int> > q(2, vector<int>(2, 0));\n            q[0][0] = -1;\n            q[1][1] = 1;\n            p = matrixProduct(p, q);\n        }else if(s == \"RV\"){\n            vector<vector<int> > q(2, vector<int>(2, 0));\n            q[0][0] = 1;\n            q[1][1] = -1;\n            p = matrixProduct(p, q);\n\n        }\n    }\n\n    long long h = 314159265;\n    for(int y=d; y<=e; ++y){\n        for(int x=f; x<=g; ++x){\n            vector<int> q(2);\n            q[0] = y;\n            q[1] = x;\n            q = transform(p, q);\n            q[0] = toY[q[0]];\n            q[1] = toX[q[1]];\n            if(change.find(q) == change.end())\n                h = (31 * h + ((q[0] * a + q[1] * b) % c)) % 1000000007;\n            else\n                h = (31 * h + change[q]) % 1000000007;\n        }\n    }\n    cout << h << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\n\nconstexpr int mod = 1e9 + 7;\n\nconstexpr int rev_tbl[2][4][2] = { // [mir][rot][row/col]\n    {{0, 0}, {1, 0}, {1, 1}, {0, 1}},\n    {{0, 1}, {1, 1}, {1, 0}, {0, 0}}\n};\n\nint main() {\n    ll n, q, A, B, C, D, E, F, G;\n    cin >> n >> q >> A >> B >> C >> D >> E >> F >> G;\n\n    vector<string> op(q);\n    vector<int> w(q), x(q), y(q), z(q);\n    for(int i = 0; i < q; ++i) {\n        cin >> op[i];\n        if(op[i] == \"WR\") cin >> w[i] >> x[i] >> y[i];\n        else if(op[i] == \"CP\") cin >> w[i] >> x[i] >> y[i] >> z[i];\n        else if(op[i] == \"SR\") cin >> w[i] >> x[i];\n        else if(op[i] == \"SC\") cin >> w[i] >> x[i];\n    }\n\n    int mir = 0, rot = 0;\n    vector<int> ridx(n), cidx(n);\n    iota(begin(ridx), end(ridx), 1);\n    iota(begin(cidx), end(cidx), 1);\n    auto get_r_idx = [&] (int r) -> int& {\n        const int i = (rev_tbl[mir][rot][0] ? n - r : r - 1);\n        return rot & 1 ? cidx[i] : ridx[i];\n    };\n    auto get_c_idx = [&] (int c) -> int& {\n        const int i = (rev_tbl[mir][rot][1] ? n - c : c - 1);\n        return rot & 1 ? ridx[i] : cidx[i];\n    };\n    auto get_orig_pos = [&] (int r, int c) {\n        if(rot & 1) return make_pair(get_c_idx(c), get_r_idx(r));\n        else        return make_pair(get_r_idx(r), get_c_idx(c));\n    };\n    map<pii, int> v;\n    for(int i = 0; i < q; ++i) {\n        if(op[i] == \"WR\") {\n            int r, c; tie(r, c) = get_orig_pos(w[i], x[i]);\n            v[{r, c}] = y[i];\n        } else if(op[i] == \"CP\") {\n            int r1, c1, r2, c2;\n            tie(r1, c1) = get_orig_pos(w[i], x[i]);\n            tie(r2, c2) = get_orig_pos(y[i], z[i]);\n            if(v.count({r1, c1})) {\n                v[{r2, c2}] = v[{r1, c1}];\n            } else {\n                v[{r2, c2}] = (r1 * A + c1 * B) % C;\n            }\n        } else if(op[i] == \"SR\") {\n            swap(get_r_idx(w[i]), get_r_idx(x[i]));\n        } else if(op[i] == \"SC\") {\n            swap(get_c_idx(w[i]), get_c_idx(x[i]));\n        } else if(op[i] == \"RL\") {\n            if(mir) rot = (rot + 3) % 4;\n            else    rot = (rot + 1) % 4;\n        } else if(op[i] == \"RR\") {\n            if(mir) rot = (rot + 1) % 4;\n            else    rot = (rot + 3) % 4;\n        } else if(op[i] == \"RH\") {\n            mir = !mir;\n            rot = (rot + 2) % 4;\n        } else if(op[i] == \"RV\") {\n            mir = !mir;\n        }\n    }\n\n    ll h = 314159265;\n    for(int r = D; r <= E; ++r) {\n        for(int c = F; c <= G; ++c) {\n            int rr, cc; tie(rr, cc) = get_orig_pos(r, c);\n            const ll val = v.count({rr, cc}) ? v[{rr, cc}] : (rr * A + cc * B) % C;\n            h = (h * 31 + val) % mod;\n        }\n    }\n    cout << h << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<numeric>\n\nusing namespace std;\n\nmap<unsigned,int> m;\n\nlong long N,Q,A,B,C,D,E,F,G;\nvector<int> rx,cx;\nbool cr=false,rr=false;\nbool t=false;\n\nint &org(int y,int x){\n  int oy=rx[y];\n  if(rr){\n    oy=N+1-oy;\n  }\n  int ox=cx[x];\n  if(cr){\n    ox=N+1-ox;\n  }\n  if(t){\n    swap(oy,ox);\n  }\n  unsigned mx=(oy*1u<<16)+ox;\n  if(!m.count(mx)){\n    m[mx]=(oy*A+ox*B)%C;\n  }\n  return m[mx];\n}\n\nint main(){\n  cin>>N>>Q>>A>>B>>C>>D>>E>>F>>G;\n  rx.resize(N+1);\n  cx.resize(N+1);\n  iota(begin(rx),end(rx),0);\n  iota(begin(cx),end(cx),0);\n  while(Q--){\n    char op[9];\n    cin>>op;\n    if(op[0]=='W'){\n      int r,c,v;\n      cin>>r>>c>>v;\n      org(r,c)=v;\n    }else if(op[0]=='C'){\n      int r1,c1,r2,c2;\n      cin>>r1>>c1>>r2>>c2;\n      org(r2,c2)=org(r1,c1);\n    }else if(op[0]=='S'){\n      int rc1,rc2;\n      cin>>rc1>>rc2;\n      if(op[1]=='R'){\n\tswap(rx[rc1],rx[rc2]);\n      }else{\n\tswap(cx[rc1],cx[rc2]);\n      }\n    }else{\n      if(op[1]=='R'){\n\tswap(rx,cx);\n\tswap(rr,cr);\n\tcr^=true;\n\tt^=true;\n      }else if(op[1]=='L'){\n\tswap(rx,cx);\n\tswap(rr,cr);\n\trr^=true;\n\tt^=true;\n      }else if(op[1]=='H'){\n\trr^=true;\n      }else{\n\tcr^=true;\n      }\n    }\n  }\n  long long h=314159265;\n  for(int i=D;i<=E;i++){\n    for(int j=F;j<=G;j++){\n      h=(31*h+org(i,j))%1000000007;\n    }\n  }\n  cout<<h<<endl;\n}\n\n    \n    "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<numeric>\n\nusing namespace std;\n\nmap<unsigned,int> m;\n\nlong long N,Q,A,B,C,D,E,F,G;\nvector<int> rx,cx;\nbool cr=false,rr=false;\nbool t=false;\n\nint &org(int y,int x){\n  if(rr){\n    y=N+1-y;\n  }\n  int oy=rx[y];\n  if(cr){\n    x=N+1-x;\n  }\n  int ox=cx[x];\n  if(t){\n    swap(oy,ox);\n  }\n  unsigned mx=(oy*1u<<16)+ox;\n  if(!m.count(mx)){\n    m[mx]=(oy*A+ox*B)%C;\n  }\n  return m[mx];\n}\n\nint main(){\n  cin>>N>>Q>>A>>B>>C>>D>>E>>F>>G;\n  rx.resize(N+1);\n  cx.resize(N+1);\n  iota(begin(rx),end(rx),0);\n  iota(begin(cx),end(cx),0);\n  while(Q--){\n    char op[9];\n    cin>>op;\n    if(op[0]=='W'){\n      int r,c,v;\n      cin>>r>>c>>v;\n      org(r,c)=v;\n    }else if(op[0]=='C'){\n      int r1,c1,r2,c2;\n      cin>>r1>>c1>>r2>>c2;\n      org(r2,c2)=org(r1,c1);\n    }else if(op[0]=='S'){\n      int rc1,rc2;\n      cin>>rc1>>rc2;\n      if(op[1]=='R'){\n\tswap(rx[rc1],rx[rc2]);\n      }else{\n\tswap(cx[rc1],cx[rc2]);\n      }\n    }else{\n      if(op[1]=='R'){\n\tswap(rx,cx);\n\tswap(rr,cr);\n\tcr^=true;\n\tt^=true;\n      }else if(op[1]=='L'){\n\tswap(rx,cx);\n\tswap(rr,cr);\n\trr^=true;\n\tt^=true;\n      }else if(op[1]=='H'){\n\trr^=true;\n      }else{\n\tcr^=true;\n      }\n    }\n  }\n  long long h=314159265;\n  for(int i=D;i<=E;i++){\n    for(int j=F;j<=G;j++){\n      h=(31*h+org(i,j))%1000000007;\n    }\n  }\n  cout<<h<<endl;\n}\n\n    \n    "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nconst ll MOD = 1e9 + 7;\nint state;\nint n, q;\nint row[40010];\nint column[40010];\nint A, B, C, D, E, F, G;\nchar str[100];\nmap<pair<int, int>, int> vs;\n\nvoid GetPos(int &x, int &y) {\n  int rotate = state & 3;\n  REP(i, rotate) {\n    int py = y;\n    y = n - x - 1;\n    x = py;\n  }\n  if (state & 4) {\n    y = n - y - 1;\n  }\n}\nvoid GetTruePos(int &x, int &y) {\n  GetPos(x, y);\n  x = column[x]; y = row[y];\n}\nvoid SwapPos(int c1, int r1, int c2, int r2) {\n  GetPos(c1, r1); GetPos(c2, r2);\n  if (c1 == c2) {\n    swap(row[r1], row[r2]);\n  } else {\n    assert(r1 == r2);\n    swap(column[c1], column[c2]);\n  }\n}\nll GetValue(int x, int y) {\n  GetTruePos(x, y);\n  ll v = ((ll)(y + 1) * A + (ll)(x + 1) * B) % C;\n  if (vs.count(make_pair(x, y))) { v = vs[make_pair(x, y)]; }\n  return v;\n}\n\nvoid PrintMatrix() {\n  REP(y, n) {\n    REP(x, n) {\n      printf(\"%lld \", GetValue(x, y));\n    }\n    puts(\"\");\n  }\n  puts(\"\");\n}\n\nint main() {\n  while (scanf(\"%d %d  %d %d %d  %d %d %d %d\", &n, &q, &A, &B, &C, &D, &E, &F, &G) > 0) {\n    D--; E--; F--; G--;\n    MEMSET(row, 0x0f); MEMSET(column, 0x0f);\n    REP(i, n) { row[i] = i; column[i] = i; }\n    state = 0;\n    vs.clear();\n    //PrintMatrix();\n    REP(i, q) {\n      scanf(\"%s\", str);\n      if (str[0] == 'W') {\n        int r, c, v;\n        scanf(\"%d %d %d\", &r, &c, &v);\n        r--; c--;\n        GetTruePos(c, r);\n        vs[make_pair(c, r)] = v;\n      } else if (str[0] == 'C') {\n        int r1, c1, r2, c2;\n        scanf(\"%d %d %d %d\", &r1, &c1, &r2, &c2);\n        r1--; c1--; r2--; c2--;\n        GetTruePos(c2, r2);\n        vs[make_pair(c2, r2)] = GetValue(c1, r1);\n      } else if (str[0] == 'S' && str[1] == 'R') {\n        int r1, r2;\n        scanf(\"%d %d\", &r1, &r2);\n        r1--; r2--;\n        SwapPos(0, r1, 0, r2);\n      } else if (str[0] == 'S' && str[1] == 'C') {\n        int c1, c2;\n        scanf(\"%d %d\", &c1, &c2);\n        c1--; c2--;\n        SwapPos(c1, 0, c2, 0);\n      } else if (str[1] == 'L') {\n        int conv[8] = { 3, 0, 1, 2, 7, 4, 5, 6 };\n        state = conv[state];\n      } else if (str[1] == 'R') {\n        int conv[8] = { 1, 2, 3, 0, 5, 6, 7, 4 };\n        state = conv[state];\n      } else if (str[1] == 'H') {\n        int conv[8] = { 4, 7, 6, 5, 0, 3, 2, 1 };\n        state = conv[state];\n      } else if (str[1] == 'V') {\n        int conv[8] = { 6, 5, 4, 7, 2, 1, 0, 3 };\n        state = conv[state];\n      }\n      //PrintMatrix();\n    }\n    ll ans = 314159265;\n    FOREQ(y, D, E) {\n      FOREQ(x, F, G) {\n        ans = (ans * 31 + GetValue(x, y)) % MOD;\n      }\n    }\n    printf(\"%lld\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <map>\nusing namespace std;\n#define SE second\n#define FI first\n#define MP(x,y) make_pair(x,y)\nconst int MAXN = 40010;\nconst int MAXM = 1010;\nconst int MOD = 1000000007;\nchar str[MAXN][3];\nint co[MAXN][4],cto[MAXN],rto[MAXN];\nbool rh,rv,vi[MAXM][MAXM];\nint dir,n,q,c,d,e,f,g;\nlong long a,b;\nmap<pair<int,int>,int> ma;\nvoid cha(int &x,int &y)\n{\n    if(rh)  x=n-x+1;\n    if(rv)  y=n-y+1;\n    if(dir==1)    y=n-y+1,swap(x,y);\n    if(dir==2)    x=n-x+1,y=n-y+1;\n    if(dir==3)    x=n-x+1,swap(x,y);\n    x=rto[x],y=cto[y];\n}\ninline int mget(int x,int y)\n{\n    if(ma.find(MP(x,y))!=ma.end())    return ma[MP(x,y)];\n    cha(x,y);\n    return (x*a+y*b)%c;\n}\nvoid re(int l,int r,int ste)\n{\n    for(int i=1;i<=n;++i)   cto[i]=i,rto[i]=i;\n    rv=rh=0;\n    dir=0;\n    for(int i=l;i!=r;i+=ste)\n    {\n        if(strcmp(str[i],\"RH\")==0)\n        {\n            if(dir%2==0)\n                rh=!rh;\n            else    rv=!rv;\n        }\n        else    if(strcmp(str[i],\"RV\")==0)\n        {\n            if(dir%2==1)\n                rh=!rh;\n            else    rv=!rv;\n        }\n        else    if(strcmp(str[i],\"RL\")==0)  dir=(dir+3)%4;\n        else    if(strcmp(str[i],\"RR\")==0)  dir=(dir+1)%4;\n        else    if(strcmp(str[i],\"WR\")==0)\n            cha(co[i][0],co[i][1]);\n        else    if(strcmp(str[i],\"CP\")==0)\n            cha(co[i][0],co[i][1]),cha(co[i][2],co[i][3]);\n        else    if(strcmp(str[i],\"SR\")==0)\n        {\n            int tmp=0;\n            cha(co[i][0],tmp);\n            if(dir%2==1)\n            {\n                str[i][1]='C';\n                swap(co[i][0],tmp);\n            }\n            cha(co[i][1],tmp);\n            if(dir%2==1)\n            {\n                str[i][1]='C';\n                swap(co[i][1],tmp);\n            }\n        }\n        else    if(strcmp(str[i],\"SC\")==0)\n        {\n            int tmp=0;\n            cha(co[i][0],tmp);\n            if(dir%2==1)\n            {\n                str[i][1]='R';\n                swap(co[i][0],tmp);\n            }\n            cha(co[i][1],tmp);\n            if(dir%2==1)\n            {\n                str[i][1]='R';\n                swap(co[i][1],tmp);\n            }\n        }\n        if(strcmp(str[i],\"SR\")==0)\n            swap(rto[co[i][0]],rto[co[i][1]]);\n        else    if(strcmp(str[i],\"SC\")==0)\n            swap(cto[co[i][0]],cto[co[i][1]]);\n    }\n}\nint main()\n{\n    //freopen(\"/home/moor/Code/input\",\"r\",stdin);\n    while(scanf(\"%d%d%lld%lld%d%d%d%d%d\",&n,&q,&a,&b,&c,&d,&e,&f,&g)==9)\n    {\n        memset(vi,0,sizeof(vi));\n        dir=rh=rv=0;\n        ma.clear();\n        for(int i=0;i<q;++i)\n        {\n            scanf(\"%s\",str[i]);\n            if(strcmp(str[i],\"WR\")==0)\n                for(int j=0;j<3;++j)    scanf(\"%d\",&co[i][j]);\n            else    if(strcmp(str[i],\"CP\")==0)\n                for(int j=0;j<4;++j)    scanf(\"%d\",&co[i][j]);\n            else    if(strcmp(str[i],\"SR\")==0)\n                for(int j=0;j<2;++j)    scanf(\"%d\",&co[i][j]);\n            else    if(strcmp(str[i],\"SC\")==0)\n                for(int j=0;j<2;++j)    scanf(\"%d\",&co[i][j]);\n        }\n        re(q-1,-1,-1);\n        for(int i=0;i<q;++i)\n        {\n            if(strcmp(str[i],\"WR\")==0)  ma[MP(co[i][0],co[i][1])]=co[i][2];\n            else    if(strcmp(str[i],\"CP\")==0)\n                ma[MP(co[i][2],co[i][3])]=mget(co[i][0],co[i][1]);\n        }\n\n        re(0,q,1);\n        //long long h=0;\n        long long h=314159265;\n        e-=d,g-=f;\n        for(int i=0;i<=e;++i)\n            for(int j=0;j<=g;++j)\n                h=(h*31+mget(i+d,j+f))%MOD;\n                //h=(h+mget(i+d,j+f))%MOD;\n        cout<<h<<'\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef pair<int, int> P;\nint N, Q;\nint A, B, C;\nint D, E, F, G;\nbool rot;\nbool revy;\nbool revx;\nint row[40404];\nint col[40404];\nvoid get(int& x, int& y) {\n    x--; y--;\n    if(rot) swap(y, x);\n    if(revy) y = N - 1 - y;\n    if(revx) x = N - 1 - x;\n\n    y = row[y];\n    x = col[x];\n}\n\nint init(int x, int y) {\n    return ((long long)(y + 1) * A + (long long)(x + 1) * B) % C;\n}\n\nvoid rotate() {\n    rot ^= 1;\n    bool nry = revx ^ 1;\n    bool nrx = revy;\n    revy = nry;\n    revx = nrx;\n}\n\nint main(){\n    while(cin >> N >> Q >> A >> B >> C >> D >> E >> F >> G) {\n\n        rot = revx = revy = false;\n        REP(i, N) row[i] = i;\n        REP(i, N) col[i] = i;\n\n        map<P, int> mat;\n\n        auto get_value = [&](int x, int y, bool insert=true) {\n            if(!mat.count(P(x, y))) {\n                if(insert) {\n                    mat[P(x, y)] = init(x, y);\n                } else {\n                    return init(x, y);\n                }\n            }\n            return mat[P(x, y)];\n        };\n\n        REP(_, Q) {\n            string s;\n            cin >> s;\n            //cout << s << \"!\" << endl;\n            if(s == \"WR\") {\n                int y, x, val;\n                cin >> y >> x >> val;\n                get(x, y);\n                mat[P(x, y)] = val;\n            } else if(s == \"CP\") {\n                int y1, x1, y2, x2;\n                cin >> y1 >> x1 >> y2 >> x2;\n                get(x1, y1);\n                get(x2, y2);\n                mat[P(x2, y2)] = get_value(x1, y1);\n            } else if(s == \"SR\") {\n                int y1, y2;\n                cin >> y1 >> y2;\n                y1--; y2--;\n                if(!rot) {\n                    if(revy) y1 = N - 1 - y1;\n                    if(revy) y2 = N - 1 - y2;\n                    swap(row[y1], row[y2]);\n                } else {\n                    int x1 = y1, x2 = y2;\n                    if(revx) x1 = N - 1 - x1;\n                    if(revx) x2 = N - 1 - x2;\n                    swap(col[x1], col[x2]);\n                }\n            } else if(s == \"SC\") {\n                int x1, x2;\n                cin >> x1 >> x2;\n                x1--; x2--;\n                if(rot) {\n                    int y1 = x1, y2 = x2;\n                    if(revy) y1 = N - 1 - y1;\n                    if(revy) y2 = N - 1 - y2;\n                    swap(row[y1], row[y2]);\n                } else {\n                    if(revx) x1 = N - 1 - x1;\n                    if(revx) x2 = N - 1 - x2;\n                    swap(col[x1], col[x2]);\n                }\n            } else if(s == \"RL\") {\n                REP(i, 3) rotate();\n            } else if(s == \"RR\") {\n                rotate();\n            } else if(s == \"RH\") {\n                revy ^= 1;\n            } else if(s == \"RV\") {\n                revx ^= 1;\n            } \n        }\n\n        long long h = 314159265;\n        const int MOD = 1000000007;\n        if(N < 10) {\n            for(int y = 0; y < N; y++) {\n                for(int x = 0; x < N; x++) {\n                    int tx = x, ty = y;\n                    get(tx, ty);\n                    //cout << get_value(x, y) << \"(\" << init(x, y) << \") \";\n                }\n                //cout << endl;\n            }\n        }\n        for(int y = D; y <= E; y++) {\n            for(int x = F; x <= G; x++) {\n                int tx = x, ty = y;\n                get(tx, ty);\n                //if(N < 10) printf(\"(%d, %d) -> (%d, %d)\\n\", x, y, tx, ty);\n                h = (h * 31 + get_value(tx, ty, false)) % MOD;\n            }\n        }\n        cout << h << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <map>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define repa(i,a,n) for(int i=a;i<a+n;++i)\n#define repb(i,a,n) for(int i=a;i>a-n;--i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\ntypedef long long ll;\ntypedef pair<int,int> P;\nmap<P,ll> mp;\nll N,Q,A,B,C,D,E,F,G;\nll mod=1e9+7;\nint row[40001],col[40001];\nll initial(int r,int c){\n\treturn (A*r+B*c)%C;\n}\nll value(int r,int c){\n\tif(mp.find(P(r,c))==mp.end()){\n\t\treturn initial(r,c);\n\t}else{\n\t\treturn mp[P(r,c)];\n\t}\n}\nint ro,inv;\nvoid change(int &r,int &c){\n\tint nr,nc;\n\tif(inv==0){\n\t\tif(ro==0) nr=r,nc=c;\n\t\tif(ro==1) nr=c,nc=N+1-r;\n\t\tif(ro==2) nr=N+1-r,nc=N+1-c;\n\t\tif(ro==3) nr=N+1-c,nc=r;\n\t}else{\n\t\tif(ro==0) nr=N+1-r,nc=c;\n\t\tif(ro==1) nr=N+1-c,nc=N+1-r;\n\t\tif(ro==2) nr=r,nc=N+1-c;\n\t\tif(ro==3) nr=c,nc=r;\n\t}\n\tr=row[nr],c=col[nc];\n}\nint main(){\n\tcin>>N>>Q>>A>>B>>C>>D>>E>>F>>G;\n\trep1(i,N) row[i]=i,col[i]=i;\n\tint X=E-D+1,Y=G-F+1;\n\tro=0,inv=0;\n\trep(i,Q){\n\t\tstring type;\n\t\tcin>>type;\n\t\tif(type==\"WR\"){\n\t\t\tint r,c,v;\n\t\t\tcin>>r>>c>>v;\n\t\t\tchange(r,c);\n\t\t\tmp[P(r,c)]=v;\n\t\t}\n\t\tif(type==\"CP\"){\n\t\t\tint r1,c1,r2,c2;\n\t\t\tcin>>r1>>c1>>r2>>c2;\n\t\t\tchange(r1,c1);\n\t\t\tchange(r2,c2);\n\t\t\tmp[P(r2,c2)]=value(r1,c1);\n\t\t}\n\t\tif(type==\"SR\"){\n\t\t\tint r1,r2,c1=0,c2=0;\n\t\t\tcin>>r1>>r2;\n\t\t\tchange(r1,c1);\n\t\t\tchange(r2,c2);\n\t\t\tif(c1==c2) swap(row[r1],row[r2]);\n\t\t\tif(r1==r2) swap(col[c1],col[c2]);\n\t\t}\n\t\tif(type==\"SC\"){\n\t\t\tint r1=0,r2=0,c1,c2;\n\t\t\tcin>>c1>>c2;\n\t\t\tchange(r1,c1);\n\t\t\tchange(r2,c2);\n\t\t\tif(c1==c2) swap(row[r1],row[r2]);\n\t\t\tif(r1==r2) swap(col[c1],col[c2]);\n\t\t}\n\t\tif(type==\"RL\"){\n\t\t\tif(inv==0) ro=(ro+1)%4;\n\t\t\telse ro=(ro+3)%4;\n\t\t}\n\t\tif(type==\"RR\"){\n\t\t\tif(inv==0) ro=(ro+3)%4;\n\t\t\telse ro=(ro+1)%4;\n\t\t}\n\t\tif(type==\"RH\"){\n\t\t\tif(ro%2==0){\n\t\t\t\tinv=1-inv;\n\t\t\t}else{\n\t\t\t\tinv=1-inv;\n\t\t\t\tro=(ro+2)%2;\n\t\t\t}\n\t\t}\n\t\tif(type==\"RV\"){\n\t\t\tif(ro%2==0){\n\t\t\t\tinv=1-inv;\n\t\t\t\tro=(ro+2)%2;\n\t\t\t}else{\n\t\t\t\tinv=1-inv;\n\t\t\t}\n\t\t}\n\t}\n\tll h=314159265;\n\tfor(int r=D;r<=E;r++) for(int c=F;c<=G;c++){\n\t\tint tmpr=r,tmpc=c;\n\t\tchange(tmpr,tmpc);\n\t\th=h*31+value(tmpr,tmpc);\n\t\th%=mod;\n\t}\n\tcout<<h<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<map>\nusing namespace std;\nint row[41000];\nint col[41000];\nmap<pair<int,int>,int> m;\nchar str[10];\nint dir;\nint n;\npair<int,int> conv(int a,int b){\n\tint ret1=0;\n\tint ret2=0;\n\tswitch(dir&3){\n\t\tcase 0:\n\t\t\tret1=a;\n\t\t\tret2=b;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tret1=b;\n\t\t\tret2=n-a+1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret1=n-a+1;\n\t\t\tret2=n-b+1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tret1=n-b+1;\n\t\t\tret2=a;\n\t\t\tbreak;\n\t}\n\tif(dir&4)swap(ret1,ret2);\n\treturn make_pair(row[ret1],col[ret2]);\n}\nint main(){\n\tint a,b,c,d,e,f,g;\n\tint q;\n\tscanf(\"%d%d%d%d%d%d%d%d%d\",&n,&q,&a,&b,&c,&d,&e,&f,&g);\n\tlong long h=314159265;\n\tlong long mod=1000000007;\n\tfor(int i=1;i<=n;i++)row[i]=i;\n\tfor(int i=1;i<=n;i++)col[i]=i;\n\twhile(q--){\n\t\tscanf(\"%s\",str);\n\t\tif(str[0]=='W'){\n\t\t\tint R,C,V;\n\t\t\tscanf(\"%d%d%d\",&R,&C,&V);\n\t\t\tpair<int,int> at=conv(R,C);\n\t\t\tm[at]=V;\n\t\t}\n\t\tif(str[0]=='C'){\n\t\t\tint r1,c1,r2,c2;\n\t\t\tscanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n\t\t\tpair<int,int> at1=conv(r1,c1);\n\t\t\tpair<int,int> at2=conv(r2,c2);\n\t\t\tif(m.count(at1))m[at2]=m[at1];\n\t\t\telse m[at2]=((long long)at1.first*a+(long long)at1.second*b)%c;\n\t\t}\n\t\tif(str[0]=='S'){\n\t\t\tint r1,r2;\n\t\t\tscanf(\"%d%d\",&r1,&r2);\n\t\t\tif((dir/4+(str[1]=='R')+dir%4)&1){\n\t\t\t\tif((dir+1+dir/4*1+(str[1]!='R')*2)%4<2)swap(row[r1],row[r2]);\n\t\t\t\telse swap(row[n-r1+1],row[n-r2+1]);\n\t\t\t}else{\n\t\t\t\tif((dir+dir/4*3+(str[1]=='R')*2)%4<2)swap(col[r1],col[r2]);\n\t\t\t\telse swap(col[n-r1+1],col[n-r2+1]);\n\t\t\t}\n\t\t}\n\t\tif(str[0]=='R'){\n\t\t\tif(str[1]=='L'){\n\t\t\t\tdir=(dir&4)+((dir%4+1)&3);\n\t\t\t}\n\t\t\tif(str[1]=='R'){\n\t\t\t\tdir=(dir&4)+((dir%4+3)&3);\n\t\t\t}\n\t\t\tif(str[1]=='H'){\n\t\t\t\tdir=((dir&4)?0:4)+(dir%4)^1;\n\t\t\t}\n\t\t\tif(str[1]=='V'){\n\t\t\t\tdir=((dir&4)?0:4)+(dir%4)^3;\n\t\t\t}\n\t\t}\n\t}/*\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tpair<int,int> at=conv(i,j);\n\t\t\tint ans;\n\t\t\tif(m.count(at))ans=m[at];\n\t\t\telse ans=((long long)at.first*a+(long long)at.second*b)%c;\n\t\t\tprintf(\"%d \",ans);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}*/\n\tfor(int i=d;i<=e;i++){\n\t\tfor(int j=f;j<=g;j++){\n\t\t\tpair<int,int> at=conv(i,j);\n\t\t\tif(m.count(at))h=(h*31+m[at])%mod;\n\t\t\telse h=(h*31+((long long)at.first*a+(long long)at.second*b)%c)%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",h);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\ntemplate <class T>\nvector<vector<T> > matrixProduct(const vector<vector<T> >& x, const vector<vector<T> >& y)\n{\n    vector<vector<T> > z(2, vector<T>(2, 0));\n    for(int i=0; i<2; ++i){\n        for(int j=0; j<2; ++j){\n            for(int k=0; k<2; ++k){\n                z[i][j] += x[i][k] * y[k][j];\n            }\n        }\n    }\n    return z;\n}\n\nint n;\nvector<int> toY, toX;\n\ntemplate <class T>\nvector<T> transform(const vector<vector<T> >& x, const vector<T>& y)\n{\n    vector<T> z(2);\n    z[0] = x[0][0] * y[0] + x[0][1] * y[1];\n    z[1] = x[1][0] * y[0] + x[1][1] * y[1];\n    if(z[0] < 0)\n        z[0] = n + 1 + z[0];\n    if(z[1] < 0)\n        z[1] = n + 1 + z[1];\n    z[0] = toY[z[0]];\n    z[1] = toX[z[1]];\n    return z;\n}\n\nint main()\n{\n    int q;\n    long long a, b, c;\n    int d, e, f, g;\n    cin >> n >> q >> a >> b >> c >> d >> e >> f >> g;\n\n    map<vector<int>, int> change;\n    vector<vector<int> > p(2, vector<int>(2, 0));\n    p[0][0] = p[1][1] = 1;\n    toY.resize(n+1);\n    toX.resize(n+1);\n    for(int i=1; i<=n; ++i)\n        toY[i] = toX[i] = i;\n\n    while(--q >= 0){\n        string s;\n        cin >> s;\n\n        if(s == \"WR\"){\n            vector<int> q(2);\n            int v;\n            cin >> q[0] >> q[1] >> v;\n            q = transform(p, q);\n            change[q] = v;\n        }else if(s == \"CP\"){\n            vector<int> q(2), r(2);\n            cin >> q[0] >> q[1] >> r[0] >> r[1];\n            q = transform(p, q);\n            r = transform(p, r);\n            if(change.find(q) == change.end())\n                change[r] = (q[0] * a + q[1] * b) % c;\n            else\n                change[r] = change[q];\n        }else if(s == \"SR\"){\n            vector<int> q(2), r(2);\n            cin >> q[0] >> r[0];\n            q = transform(p, q);\n            r = transform(p, r);\n            swap(toY[q[0]], toY[r[0]]);\n            swap(toX[q[1]], toX[r[1]]);\n        }else if(s == \"SC\"){\n            vector<int> q(2), r(2);\n            cin >> q[1] >> r[1];\n            q = transform(p, q);\n            r = transform(p, r);\n            swap(toY[q[0]], toY[r[0]]);\n            swap(toX[q[1]], toX[r[1]]);\n        }else if(s == \"RL\"){\n            vector<vector<int> > q(2, vector<int>(2, 0));\n            q[0][1] = 1;\n            q[1][0] = -1;\n            p = matrixProduct(p, q);\n        }else if(s == \"RR\"){\n            vector<vector<int> > q(2, vector<int>(2, 0));\n            q[0][1] = -1;\n            q[1][0] = 1;\n            p = matrixProduct(p, q);\n        }else if(s == \"RH\"){\n            vector<vector<int> > q(2, vector<int>(2, 0));\n            q[0][0] = -1;\n            q[1][1] = 1;\n            p = matrixProduct(p, q);\n        }else if(s == \"RV\"){\n            vector<vector<int> > q(2, vector<int>(2, 0));\n            q[0][0] = 1;\n            q[1][1] = -1;\n            p = matrixProduct(p, q);\n\n        }\n    }\n\n    long long h = 314159265;\n    for(int y=d; y<=e; ++y){\n        for(int x=f; x<=g; ++x){\n            vector<int> q(2);\n            q[0] = y;\n            q[1] = x;\n            q = transform(p, q);\n            if(change.find(q) == change.end())\n                h = (31 * h + ((q[0] * a + q[1] * b) % c)) % 1000000007;\n            else\n                h = (31 * h + change[q]) % 1000000007;\n        }\n    }\n    cout << h << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef pair<int, int> P;\nint N, Q;\nint A, B, C;\nint D, E, F, G;\nbool rot;\nbool revy;\nbool revx;\nint row[40404];\nint col[40404];\nvoid get(int& x, int& y) {\n    x--; y--;\n    if(rot) swap(y, x);\n    if(revy) y = N - 1 - y;\n    if(revx) x = N - 1 - x;\n\n    y = row[y];\n    x = col[x];\n}\n\nint init(int x, int y) {\n    return ((long long)(y + 1) * A + (long long)(x + 1) * B) % C;\n}\n\nvoid rotate() {\n    rot ^= 1;\n    bool nry = revx ^ 1;\n    bool nrx = revy;\n    revy = nry;\n    revx = nrx;\n}\n\nint main(){\n    while(cin >> N >> Q >> A >> B >> C >> D >> E >> F >> G) {\n\n        rot = revx = revy = false;\n        REP(i, N) row[i] = i;\n        REP(i, N) col[i] = i;\n\n        map<P, int> mat;\n\n        auto get_value = [&](int x, int y, bool insert=true) {\n            if(!mat.count(P(x, y))) {\n                if(insert) {\n                    mat[P(x, y)] = init(x, y);\n                } else {\n                    return init(x, y);\n                }\n            }\n            return mat[P(x, y)];\n        };\n\n        REP(_, Q) {\n            string s;\n            cin >> s;\n            //cout << s << \"!\" << endl;\n            if(s == \"WR\") {\n                int y, x, val;\n                cin >> y >> x >> val;\n                get(x, y);\n                mat[P(x, y)] = val;\n            } else if(s == \"CP\") {\n                int y1, x1, y2, x2;\n                cin >> y1 >> x1 >> y2 >> x2;\n                x1 = x2; // ?????\n                get(x1, y1);\n                get(x2, y2);\n                mat[P(x2, y2)] = get_value(x1, y1);\n            } else if(s == \"SR\") {\n                int y1, y2;\n                cin >> y1 >> y2;\n                y1--; y2--;\n                if(!rot) {\n                    if(revy) y1 = N - 1 - y1;\n                    if(revy) y2 = N - 1 - y2;\n                    swap(row[y1], row[y2]);\n                } else {\n                    int x1 = y1, x2 = y2;\n                    if(revx) x1 = N - 1 - x1;\n                    if(revx) x2 = N - 1 - x2;\n                    swap(col[x1], col[x2]);\n                }\n            } else if(s == \"SC\") {\n                int x1, x2;\n                cin >> x1 >> x2;\n                x1--; x2--;\n                if(rot) {\n                    int y1 = x1, y2 = x2;\n                    if(revy) y1 = N - 1 - y1;\n                    if(revy) y2 = N - 1 - y2;\n                    swap(row[y1], row[y2]);\n                } else {\n                    if(revx) x1 = N - 1 - x1;\n                    if(revx) x2 = N - 1 - x2;\n                    swap(col[x1], col[x2]);\n                }\n            } else if(s == \"RL\") {\n                REP(i, 3) rotate();\n            } else if(s == \"RR\") {\n                rotate();\n            } else if(s == \"RH\") {\n                revy ^= 1;\n            } else if(s == \"RV\") {\n                revx ^= 1;\n            } \n        }\n\n        long long h = 314159265;\n        const int MOD = 1000000007;\n        if(N < 10) {\n            for(int y = 0; y < N; y++) {\n                for(int x = 0; x < N; x++) {\n                    int tx = x, ty = y;\n                    get(tx, ty);\n                    //cout << get_value(x, y) << \"(\" << init(x, y) << \") \";\n                }\n                //cout << endl;\n            }\n        }\n        for(int y = D; y <= E; y++) {\n            for(int x = F; x <= G; x++) {\n                int tx = x, ty = y;\n                get(tx, ty);\n                //if(N < 10) printf(\"(%d, %d) -> (%d, %d)\\n\", x, y, tx, ty);\n                h = (h * 31 + get_value(tx, ty, false)) % MOD;\n            }\n        }\n        cout << h << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nint ROW[40000];\nint COL[40000];\nint N,Q,A,B,C,D,E,F,G;\n\n/*\n  state\n  \n  AB\n  CD\n\n  BD\n  AC\n\n  DC\n  BA\n\n  CA\n  DB\n\n  BA\n  DC\n\n  AC\n  BD\n\n  CD\n  AB\n\n  DB\n  CA\n */\npii func(int state, int r, int c) {\n  pii res;\n  if (state == 0) res = pii(r,c);\n  else if (state == 3) res = pii(N-1-c,r);\n  else if (state == 2) res = pii(N-1-r,N-1-c);\n  else if (state == 1) res = pii(c, N-1-r);\n  else if (state == 4) res = pii(r,N-1-c);\n  else if (state == 5) res = pii(c, r);\n  else if (state == 6) res = pii(N-1-r,c);\n  else if (state == 7) res = pii(N-1-c,N-1-r);\n  return pii(ROW[res.first], COL[res.second]);\n}\nmap<pii, int> mp;\n\nint get(int state, int r, int c) {\n  pii p = func(state, r, c);\n  //cout << r << \" \" << c << \" : \" << p.first << \",\" << p.second << \" \" << mp.count(pii(p)) << endl;\n  if (mp.count(pii(p))) return mp[pii(p)];\n  else return ((p.first+1LL)*A + (p.second+1LL)*B) % C;\n}\n\nint main() {\n  int rh[8] = {6,5,4,7,2,1,0,3};\n  int rv[8] = {4,7,6,5,0,3,2,1};\n  while(cin>>N>>Q>>A>>B>>C>>D>>E>>F>>G) {\n    mp.clear();\n    REP(i,N) ROW[i] = COL[i] = i;\n    int state = 0;\n    //if (N > 4) continue;\n    \n    REP(i,Q+1) {\n      // cout << state << endl;\n      // REP(j, N) {\n      //   REP(k,N) cout << get(state,j,k) << \" \";\n      //   cout << endl;\n      // }cout << endl;\n      if (i==Q) break;\n      string op;\n      cin >> op;\n      if (op == \"WR\") {\n        int r,c,v;cin>>r>>c>>v;r--;c--;\n        //cout << func(state, r, c).first << \" \"<<func(state, r,c).second << endl;\n        mp[func(state, r, c)] = v;\n      } else if (op == \"CP\") {\n        int r1,c1,r2,c2;cin>>r1>>c1>>r2>>c2;r1--;c1--;r2--;c2--;\n        pii p2 = func(state, r2, c2);\n        mp[p2] = get(state, r1, c1);\n      } else if (op == \"SR\") {\n        int r1, r2; cin >> r1 >> r2; r1--;r2--;\n        pii p1 = func(state, r1, 0), p2 = func(state, r2, 0);\n        if (state % 2)\n          swap(COL[p1.second], COL[p2.second]);\n        else\n          swap(ROW[p1.first], ROW[p2.first]);\n      } else if (op == \"SC\") {\n        int c1, c2; cin >> c1 >> c2; c1--; c2--;\n        pii p1 = func(state, 0, c1), p2 = func(state, 0, c2);\n        if (state % 2)\n          swap(ROW[p1.first], ROW[p2.first]);\n        else\n          swap(COL[p1.second], COL[p2.second]);\n      } else if (op == \"RL\") {\n        state = (state + 1) % 4 + state/4*4;\n      } else if (op == \"RR\") {\n        state = (state + 3) % 4 + state/4*4;\n      } else if (op == \"RH\") {\n        state = rh[state];\n      } else {\n        state = rv[state];\n      }\n    }\n    ll h = 314159265;\n    for (int i=D-1; i<E; ++i) {\n      for (int j=F-1; j<G; ++j) {\n        int b = get(state, i, j);\n        //if (b < 0) cout << b << endl;\n        h = (31*h+b) % 1000000007;\n        //cout << h << endl;\n      }\n    }\n    cout << h << endl;\n\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef pair<int, int> P;\nint N, Q;\nint A, B, C;\nint D, E, F, G;\nbool rot;\nbool revy;\nbool revx;\nint row[40404];\nint col[40404];\nvoid get(int& x, int& y) {\n    x--; y--;\n    if(rot) swap(y, x);\n    if(revy) y = N - 1 - y;\n    if(revx) x = N - 1 - x;\n\n    y = row[y];\n    x = col[x];\n}\n\nint init(int x, int y) {\n    return ((long long)(y + 1) * A + (long long)(x + 1) * B) % C;\n}\n\nvoid rotate() {\n    rot ^= 1;\n    bool nry = revx ^ 1;\n    bool nrx = revy;\n    revy = nry;\n    revx = nrx;\n}\n\nint main(){\n    while(cin >> N >> Q >> A >> B >> C >> D >> E >> F >> G) {\n\n        rot = revx = revy = false;\n        REP(i, N) row[i] = i;\n        REP(i, N) col[i] = i;\n\n        map<P, int> mat;\n\n        auto get_value = [&](int x, int y, bool insert=true) {\n            if(!mat.count(P(x, y))) {\n                if(insert) {\n                    mat[P(x, y)] = init(x, y);\n                } else {\n                    return init(x, y);\n                }\n            }\n            return mat[P(x, y)];\n        };\n\n        REP(_, Q) {\n            string s;\n            cin >> s;\n            //cout << s << \"!\" << endl;\n            if(s == \"WR\") {\n                int y, x, val;\n                cin >> y >> x >> val;\n                get(x, y);\n                mat[P(x, y)] = val;\n            } else if(s == \"CP\") {\n                int y1, x1, y2, x2;\n                cin >> y1 >> x1 >> y2 >> x2;\n                x1 = x2; // ?????\n                get(x1, y1);\n                get(x2, y2);\n                mat[P(x2, y2)] = get_value(x1, y1);\n            } else if(s == \"SR\") {\n                int y1, y2;\n                cin >> y1 >> y2;\n                y1--; y2--;\n                if(!rot) {\n                    if(revy) y1 = N - 1 - y1;\n                    if(revy) y2 = N - 1 - y2;\n                    swap(row[y1], row[y2]);\n                } else {\n                    int x1 = y1, x2 = y2;\n                    if(revx) x1 = N - 1 - x1;\n                    if(revx) x2 = N - 1 - x2;\n                    swap(col[x1], col[x2]);\n                }\n            } else if(s == \"SC\") {\n                int x1, x2;\n                cin >> x1 >> x2;\n                x1--; x2--;\n                if(rot) {\n                    int y1 = x1, y2 = x2;\n                    if(revy) y1 = N - 1 - y1;\n                    if(revy) y2 = N - 1 - y2;\n                    swap(row[y1], row[y2]);\n                } else {\n                    if(revx) x1 = N - 1 - x1;\n                    if(revx) x2 = N - 1 - x2;\n                    swap(col[x1], col[x2]);\n                }\n            } else if(s == \"RL\") {\n                REP(i, 3) rotate();\n            } else if(s == \"RR\") {\n                rotate();\n            } else if(s == \"RH\") {\n                revy ^= 1;\n            } else if(s == \"RV\") {\n                revx ^= 1;\n            } \n        }\n\n        long long h = 314159265;\n        const int MOD = 1000000007;\n        if(N < 10) {\n            for(int y = 0; y < N; y++) {\n                for(int x = 0; x < N; x++) {\n                    int tx = x, ty = y;\n                    get(tx, ty);\n                    //cout << get_value(x, y) << \"(\" << init(x, y) << \") \";\n                }\n                //cout << endl;\n            }\n        }\n        for(int y = D; y <= E; y++) {\n            for(int x = F; x <= G; x++) {\n                int tx = x, ty = y;\n                get(tx, ty);\n                //if(N < 10) printf(\"(%d, %d) -> (%d, %d)\\n\", x, y, tx, ty);\n                h = (h * 31 + get_value(tx, ty, false)) % MOD;\n            }\n        }\n        cout << h << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing vec  = vector<ll>;\nusing matrix = vector<vector<ll> >;\n\nvector<ll> toY, toX;\nll n, Q, a, b, c, d, e, f, g;\nll r1, c1, r2, c2, v;\n\ninline matrix operator*(const matrix &a, const matrix &b) {\n    matrix ret = matrix{{0, 0},\n                        {0, 0}};\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++) {\n            for (int k = 0; k < 2; k++) {\n                ret[i][j] += a[i][k] * b[k][j];\n            }\n        }\n    }\n    return ret;\n}\n\ninline vec operator*(const matrix &a, const vec &b) {\n    vec ret{0, 0};\n    for (int i = 0; i < 2; i++) {\n        for (int k = 0; k < 2; k++) {\n            ret[i] += a[i][k] * b[k];\n        }\n    }\n    if (ret[0] < 0) ret[0] += n + 1;\n    if (ret[1] < 0) ret[1] += n + 1;\n    return ret;\n}\n\n\ninline vec origin(vec q) {\n    q[0] = toY[q[0]];\n    q[1] = toX[q[1]];\n    return q;\n}\n\n\nint main() {\n\n\n    cin >> n >> Q >> a >> b >> c >> d >> e >> f >> g;\n    map<vec, ll> change;\n    matrix p{{1, 0},\n             {0, 1}};\n    toX.resize(n + 1);\n    toY.resize(n + 1);\n    for (ll i = 0; i <= n; ++i)\n        toY[i] = toX[i] = i;\n\n    while (Q--) {\n        string s;\n        cin >> s;\n        if (s == \"WR\") {\n            cin >> r1 >> c1 >> v;\n            vec q{r1, c1};\n            q = origin(p * q);\n            change[q] = v;\n        } else if (s == \"CP\") {\n            cin >> r1 >> c1 >> r2 >> c2;\n            vec q{r1, c1};\n            vec r{r2, c2};\n            q = origin(p * q);\n            r = origin(p * r);\n            if (change.find(q) == change.end())\n                change[r] = (q[0] * a + q[1] * b) % c;\n            else\n                change[r] = change[q];\n        } else if (s == \"SR\") {\n            cin >> r1 >> r2;\n            vec q{r1, 0};\n            vec r{r2, 0};\n            q = p * q;\n            r = p * r;\n            swap(toY[q[0]], toY[r[0]]);\n            swap(toX[q[1]], toX[r[1]]);\n        } else if (s == \"SC\") {\n            cin >> c1 >> c2;\n            vec q{0, c1};\n            vec r{0, c2};\n            q = p * q;\n            r = p * r;\n            swap(toY[q[0]], toY[r[0]]);\n            swap(toX[q[1]], toX[r[1]]);\n        } else if (s == \"RL\") {\n            matrix q{{0,  1},\n                     {-1, 0}};\n            p = p * q;\n        } else if (s == \"RR\") {\n            matrix q{{0, -1},\n                     {1, 0}};\n            p = p * q;\n        } else if (s == \"RH\") {\n            matrix q{{-1, 0},\n                     {0,  1}};\n            p = p * q;\n        } else if (s == \"RV\") {\n            matrix q{{1, 0},\n                     {0, -1}};\n            p = p * q;\n\n        }\n    }\n\n    ll h = 314159265;\n    for (ll y = d; y <= e; ++y) {\n        for (ll x = f; x <= g; ++x) {\n            vec q{y, x};\n            q = origin(p * q);\n            if (change.find(q) == change.end())\n                h = (31 * h + ((q[0] * a + q[1] * b) % c)) % 1000000007;\n            else\n                h = (31 * h + change[q]) % 1000000007;\n        }\n    }\n    cout << h << endl;\n\n    return 0;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\n\n\nconst int mod = 1000000007;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const long long  int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init(const int amax = MAX_MOD_N) {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < amax - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n long long int N, Q, A, B, C, D, E, F, G;\n\nvector<int>xs;\nvector<int>revxs;\nvector<int>ys;\nvector<int>revys;\nbool ud_swap = false;\nbool lr_swap = false;\nint r_num = 0;\nmap<pair<int, int>,long long int>mp;\n\n//?????????\npair<int, int>rot(pair<int,int>p, const int num) {\n\tif (num== 0) {\n\t\treturn p;\n\t}\n\telse {\n\t\tp = rot(make_pair(p.second,N-1-p.first), num- 1);\n\t\treturn p;\n\t}\n}\npair<int, int>udsw(pair<int, int>p) {\n\treturn make_pair(p.first, N - 1 - p.second);\n}\npair<int, int>lrsw(pair<int, int>p) {\n\treturn make_pair(N-1-p.first, p.second);\n}\npair<int, int>getplace(pair<int, int>p ) {\n\tp = rot(p, 4 - r_num);\n\tif (lr_swap)p = lrsw(p);\n\tif (ud_swap)p = udsw(p);\n\tp = make_pair(revxs[p.first], revys[p.second]);\n\treturn p;\n}\nlong long int  getnum(const pair<int, int>p,const bool flag = false) {\n\tconst pair<int, int>place = getplace(p);\n\tif (flag) {\n\t\tcout << \"x:\" << place.first << \"   y:\"<<place.second << endl;\n\t}\n\tif (mp.find(place) == mp.end()) {\n\t\treturn ((1+place.second)*A + (1+place.first)*B) % C;\n\t}\n\telse {\n\t\treturn mp[place];\n\t}\n}\nvoid setnum(pair<int, int>p,long long int  num) {\n\tconst pair<int, int>place = getplace(p);\n\tmp[place] = num;\n}\nint main() {\n\t{\n\t\tcin >> N >> Q >> A >> B >> C >> D >> E >> F >> G;\n\t\txs.resize(N);\n\t\tiota(xs.begin(), xs.end(), 0);\n\t\tys = xs;\n\t\trevxs = xs;\n\t\trevys = xs;\n\t}\n\twhile (Q--) {\n\t\tstring st; cin >> st;\n\t\tif (st == \"WR\") {\n\t\t\tint y, x; cin >> y >> x;\n\t\t\ty--; x--;\n\t\t\tint r; cin >> r;\n\t\t\tsetnum(make_pair(x, y), r);\n\t\t}\n\t\telse if (st == \"CP\") {\n\t\t\tint y1, x1, y2, x2; cin >> y1 >> x1 >> y2 >> x2;\n\t\t\ty1--; x1--; y2--; x2--;\n\t\t\tlong long int r = getnum(make_pair(x1, y1));\n\t\t\tsetnum(make_pair(x2, y2), r);\n\t\t}\n\t\telse if (st == \"SR\") {\n\t\t\tint y1, y2; cin >> y1 >> y2; y1--; y2--;\n\t\t\tint x1 = 0, x2 = 0;\n\t\t\t\n\t\t\tif (r_num == 0) {\n\n\t\t\t}\n\t\t\telse if (r_num == 2) {\n\t\t\t\tswap(y1, y2);\n\t\t\t\tswap(x1, x2);\n\t\t\t}\n\t\t\telse if (r_num == 1) {\n\t\t\t\tx1 = N - 1 - y1;\n\t\t\t\tx2 = N - 1 - y2;\n\t\t\t\ty1 = 0;\n\t\t\t\ty2 = 0;\n\t\t\t}\n\t\t\telse if (r_num == 3) {\n\t\t\t\tx1 = y1;\n\t\t\t\tx2 = y2;\n\t\t\t\ty1 = 0;\n\t\t\t\ty2 = 0;\n\t\t\t}\n\t\t\tif (ud_swap) {\n\t\t\t\ty1 = N - 1 - y1;\n\t\t\t\ty2 = N - 1 - y2;\n\t\t\t}\n\t\t\tif (lr_swap) {\n\t\t\t\tx1 = N - 1 - x1;\n\t\t\t\tx2 = N - 1 - x2;\n\t\t\t}\n\t\t\t{\n\t\t\t\tswap(ys[y1], ys[y2]);\n\t\t\t\trevys[ys[y1]] = y1;\n\t\t\t\trevys[ys[y2]] = y2;\n\t\t\t\tswap(xs[x1], xs[x2]);\n\t\t\t\trevxs[xs[x1]] = x1;\n\t\t\t\trevxs[xs[x2]] = x2;\n\t\t\t}\n\t\t}\n\t\telse if (st == \"SC\") {\n\t\t\tint x1, x2; cin >> x1 >> x2; x1--; x2--;\n\t\t\tint y1 = 0, y2 = 0;\n\n\t\t\tif (r_num == 0) {\n\n\t\t\t}\n\t\t\telse if (r_num == 2) {\n\t\t\t\tswap(y1, y2);\n\t\t\t\tswap(x1, x2);\n\t\t\t}\n\t\t\telse if (r_num == 1) {\n\t\t\t\tx1 = N - 1 - y1;\n\t\t\t\tx2 = N - 1 - y2;\n\t\t\t\ty1 = 0;\n\t\t\t\ty2 = 0;\n\t\t\t}\n\t\t\telse if (r_num == 3) {\n\t\t\t\tx1 = y1;\n\t\t\t\tx2 = y2;\n\t\t\t\ty1 = 0;\n\t\t\t\ty2 = 0;\n\t\t\t}\n\t\t\tif (ud_swap) {\n\t\t\t\ty1 = N - 1 - y1;\n\t\t\t\ty2 = N - 1 - y2;\n\t\t\t}\n\t\t\tif (lr_swap) {\n\t\t\t\tx1 = N - 1 - x1;\n\t\t\t\tx2 = N - 1 - x2;\n\t\t\t}\n\t\t\t{\n\t\t\t\tswap(ys[y1], ys[y2]);\n\t\t\t\trevys[ys[y1]] = y1;\n\t\t\t\trevys[ys[y2]] = y2;\n\t\t\t\tswap(xs[x1], xs[x2]);\n\t\t\t\trevxs[xs[x1]] = x1;\n\t\t\t\trevxs[xs[x2]] = x2;\n\t\t\t}\n\t\t}\n\t\telse if (st == \"RL\") {\n\t\t\tr_num = (r_num + 1) % 4;\n\t\t}\n\t\telse if (st == \"RR\") {\n\t\t\tr_num = (r_num + 3) % 4;\n\t\t}\n\t\telse if (st == \"RH\") {\n\t\t\tif (r_num % 2) {\n\t\t\t\tlr_swap = !lr_swap;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tud_swap = !ud_swap;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (r_num % 2) {\n\t\t\t\tud_swap = !ud_swap;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlr_swap = !lr_swap;\n\t\t\t}\n\t\t}\n\t}\n\tMod ans = 314159265;\n\tfor (int y = D-1; y <= E-1; ++y) {\n\t\tfor (int x = F-1; x <= G-1; ++x) {\n\t\t\tans = Mod(31) * ans+ getnum(make_pair(x, y),false);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n \nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n,q,a,b,c,d,e,f,g;\n  cin>>n>>q>>a>>b>>c>>d>>e>>f>>g;\n  using P = pair<Int, Int>;\n  map<P, Int> mp;\n  auto val=[&](Int y,Int x){\n    if(x>y) swap(x,y);\n    return ((y-n)*a+x*b)%c;\n  };\n  auto calc=[&](Int y,Int x){\n    //cout<<y<<\":\"<<x<<endl;\n    if(mp.count(minmax(y,x))) return mp[minmax(y,x)];\n    else return val(y,x);\n  };\n \n  vector<Int> vx(n),vy(n);\n  iota(vx.begin(),vx.end(),1);\n  iota(vy.begin(),vy.end(),n+1);\n  //for(Int i=0;i<n;i++) cout<<\"vx:\"<<i<<vx[i]<<endl;\n  //for(Int i=0;i<n;i++) cout<<\"vy:\"<<i<<vy[i]<<endl;\n \n  using It = vector<Int>::iterator;\n  It px=vx.begin();\n  It qx=--vx.end();\n  It py=vy.begin();\n  It qy=--vy.end();\n \n  auto conv=[&](It it,Int x){\n    if(it==--vx.end()||it==--vy.end()) return it-x;\n    return it+x;\n  }; \n   \n  for(Int i=0;i<q;i++){\n    string s;\n    cin>>s;\n    if(s==\"WR\"){\n      Int r,c,v;\n      cin>>r>>c>>v;\n      r--;c--;\n      mp[minmax(*conv(py,r),*conv(px,c))]=v;\n    }\n    if(s==\"CP\"){\n      Int r1,c1,r2,c2;\n      cin>>r1>>c1>>r2>>c2;\n      r1--;c1--;r2--;c2--;\n      mp[minmax(*conv(py,r2),*conv(px,c2))]=calc(*conv(py,r1),*conv(px,c1));\n    }\n    if(s==\"SR\"){\n      Int r1,r2;\n      cin>>r1>>r2;r1--;r2--;\n      auto sy=(py<qy?py:qy);\n      if(sy==vx.begin())\n\tswap(vx[conv(py,r1)-sy],vx[conv(py,r2)-sy]);\n      else\n\tswap(vy[conv(py,r1)-sy],vy[conv(py,r2)-sy]);\n    }\n    if(s==\"SC\"){\n      Int c1,c2;\n      cin>>c1>>c2;c1--;c2--;\n      auto sx=(px<qx?px:qx);\n      if(sx==vx.begin())\n\tswap(vx[conv(px,c1)-sx],vx[conv(px,c2)-sx]);\n      else\n\tswap(vy[conv(px,c1)-sx],vy[conv(px,c2)-sx]);\n    }\n    if(s==\"RL\"){\n      It bpx=px,bqx=qx,bpy=py,bqy=qy;\n      px=bpy;\n      qx=bqy;\n      py=bqx;\n      qy=bpx;\n    }\n    if(s==\"RR\"){\n      It bpx=px,bqx=qx,bpy=py,bqy=qy;\n      px=bqy;\n      qx=bpy;\n      py=bpx;\n      qy=bqx;\n    }\n    if(s==\"RH\"){\n      swap(py,qy);\n    }    \n    if(s==\"RV\"){\n      swap(px,qx);\n    }\n  }\n \n  const Int MOD = 1e9+7;\n  d--;f--;\n  Int ans=314159265;\n  for(Int i=d;i<e;i++)\n    for(Int j=f;j<g;j++)\n      ans=(ans*31+calc(*conv(py,i),*conv(px,j)))%MOD;\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<map>\n#include<utility>\n#include<string>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst long long mod=1000000007;\nconst int MN=40000;\n\nmap<P,long long> changedVals;\nint N;\nint A,B,C;\nint D,E,F,G;\nint Q;\n\nchar ch[2];\nint initIds[MN][2];//[cur pos]=init id\nint curPos[MN][2]; //[init id]=cur pos\nbool reversed[2];\n/*\nP getInitPos(P p){\n\tint i=p.first,j=p.second;\n\tP res;\n\tif(ch[0]=='R'){\n\t\tif(topNum[0]==0) res.first=i;\n\t\telse res.first=N-1-i;\n\t}else{\n\t\tif(topNum[0]==0) res.second=i;\n\t\telse res.second=N-1-i;\n\t}\n\t\n\tif(ch[1]=='C'){\n\t\tif(topNum[1]==0) res.second=j;\n\t\telse res.second=N-1-j;\n\t}else{\n\t\tif(topNum[1]==0) res.first=j;\n\t\telse res.first=N-1-j;\n\t}\n\t\n\treturn res;\n}*/\n\nP getInitPos(P p){\n\tint i=p.first,j=p.second;\n\tP res;\n\tif(ch[0]=='R'){\n\t\tif(reversed[0]){\n\t\t\ti=N-1-i;\n\t\t}\n\t\tres.first=initIds[i][0];\n\t}else{\n\t\tif(reversed[0]){\n\t\t\ti=N-1-i;\n\t\t}\n\t\tres.second=initIds[i][1];\n\t}\n\t\n\tif(ch[1]=='C'){\n\t\tif(reversed[1]){\n\t\t\tj=N-1-j;\n\t\t}\n\t\tres.second=initIds[j][1];\n\t}else{\n\t\tif(reversed[1]){\n\t\t\tj=N-i-j;\n\t\t}\n\t\tres.first=initIds[j][0];\n\t}\n\treturn res;\n}\n\nlong long getInitVal(P p){\n\tint i=p.first,j=p.second;\n\ti++;j++;\n\tlong long res=(long long)A*i+(long long)B*j;\n\tres%=C;\n\treturn res;\n}\n\nlong long getCurVal(P p){\n\tP init=getInitPos(p);\n\tlong long res;\n\tif(changedVals.count(init)==0){\n\t\tres=getInitVal(init);\n\t}else{\n\t\tres=changedVals[init];\n\t}\n\treturn res;\n}\n\nvoid WR(P p,int val){\n\tP init=getInitPos(p);\n\tchangedVals[init]=val;\n}\n\nvoid CP(P p1,P p2){\n\tP init=getInitPos(p1);\n\tint val;\n\tif(changedVals.count(init)==0){\n\t\tval=getInitVal(init);\n\t}else{\n\t\tval=changedVals[init];\n\t}\n\tWR(p2,val);\n}\n\nvoid SR(int i1,int i2){\n\tif(ch[0]=='R'){\n\t\tif(reversed[0]){\n\t\t\ti1=N-1-i1;\n\t\t\ti2=N-1-i2;\n\t\t}\n\t\tint x=initIds[i1][0];\n\t\tint y=initIds[i2][0];\n\t\tswap(initIds[i1][0],initIds[i2][0]);\n\t\tswap(curPos[x][0],curPos[y][0]);\n\t}else{\n\t\tif(reversed[0]){\n\t\t\ti1=N-1-i1;\n\t\t\ti2=N-1-i2;\n\t\t}\n\t\tint x=initIds[i1][1];\n\t\tint y=initIds[i2][1];\n\t\tswap(initIds[i1][1],initIds[i2][1]);\n\t\tswap(curPos[x][1],curPos[y][1]);\n\t}\n}\n\nvoid SC(int j1,int j2){\n\tif(ch[1]=='C'){\n\t\tif(reversed[1]){\n\t\t\tj1=N-1-j1;\n\t\t\tj2=N-1-j2;\n\t\t}\n\t\tint x=initIds[j1][1];\n\t\tint y=initIds[j2][1];\n\t\tswap(initIds[j1][1],initIds[j2][1]);\n\t\tswap(curPos[x][1],curPos[y][1]);\n\t}else{\n\t\tif(reversed[1]){\n\t\t\tj1=N-1-j1;\n\t\t\tj2=N-1-j2;\n\t\t}\n\t\tint x=initIds[j1][0];\n\t\tint y=initIds[j2][0];\n\t\tswap(initIds[j1][0],initIds[j2][0]);\n\t\tswap(curPos[x][0],curPos[y][0]);\n\t}\n}\n\nvoid RL(){\n\tbool tmp[2];\n\ttmp[0]=reversed[0],tmp[1]=reversed[1];\n\treversed[0]=!tmp[1];\n\treversed[1]=tmp[0];\n\tswap(ch[0],ch[1]);\n}\n\nvoid RR(){\n\tbool tmp[2];\n\ttmp[0]=reversed[0],tmp[1]=reversed[1];\n\treversed[0]=tmp[1];\n\treversed[1]=!tmp[0];\n\tswap(ch[0],ch[1]);\n}\n\nvoid RH(){\n\treversed[0]=!reversed[0];\n}\n\nvoid RV(){\n\treversed[1]=!reversed[1];\n}\n\nlong long getHash(int D,int E,int F,int G){\n\tlong long res=314159265;\n\tfor(int i=D;i<=E;i++) for(int j=F;j<=G;j++){\n\t\tres*=31;\n\t\tlong long val=getCurVal(P(i,j));\n\t\tres+=val;\n\t\tres%=mod;\n\t}\n\tres+=mod;\n\tres%=mod;\n\treturn res;\n}\n\nvoid init(){\n\tscanf(\"%d%d\",&N,&Q);\n\tscanf(\"%d%d%d\",&A,&B,&C);\n\tscanf(\"%d%d%d%d\",&D,&E,&F,&G);\n\tD--;E--;F--;G--;\n\tch[0]='R';\n\tch[1]='C';\n\tfor(int i=0;i<N;i++){\n\t\tinitIds[i][0]=i;\n\t\tinitIds[i][1]=i;\n\t\tcurPos[i][0]=i;\n\t\tcurPos[i][1]=i;\n\t}\n\treversed[0]=false;\n\treversed[1]=false;\n}\n\nvoid query(){\n\tstring str;\n\tcin>>str;\n\tif(str==\"WR\"){\n\t\tint r,c,v;\n\t\tscanf(\"%d%d%d\",&r,&c,&v);\n\t\tr--;c--;\n\t\tWR(P(r,c),v);\n\t}else if(str==\"CP\"){\n\t\tint r1,c1,r2,c2;\n\t\tscanf(\"%d%d%d%d\",&r1,&c1,&r2,&c2);\n\t\tr1--;c1--;\n\t\tr2--;c2--;\n\t\tCP(P(r1,c1),P(r2,c2));\n\t}else if(str==\"SR\"){\n\t\tint r1,r2;\n\t\tscanf(\"%d%d\",&r1,&r2);\n\t\tr1--;r2--;\n\t\tSR(r1,r2);\n\t}else if(str==\"SC\"){\n\t\tint c1,c2;\n\t\tscanf(\"%d%d\",&c1,&c2);\n\t\tc1--;c2--;\n\t\tSC(c1,c2);\n\t}else if(str==\"RL\"){\n\t\tRL();\n\t}else if(str==\"RR\"){\n\t\tRR();\n\t}else if(str==\"RH\"){\n\t\tRH();\n\t}else if(str==\"RV\"){\n\t\tRV();\n\t}\n}\n\nvoid output(){\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<N;j++){\n\t\t\tprintf(\"%lld \",getCurVal(P(i,j)));\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\nlong long mat[100][100];\n\nvoid init_brute(int A,int B,int C){\n\tfor(int i=0;i<N;i++) for(int j=0;j<N;j++){\n\t\tmat[i][j]=(long long)(i+1)*A+(long long)(j+1)*B;\n\t\tmat[i][j]%=C;\n\t}\n}\n\nvoid SR_brute(int i1,int i2){\n\tfor(int j=0;j<N;j++){\n\t\tswap(mat[i1][j],mat[i2][j]);\n\t}\n}\n\nvoid RL_brute(){\n\tlong long tmp[100][100];\n\tfor(int i=0;i<N;i++) for(int j=0;j<N;j++){\n\t\ttmp[i][j]=mat[i][j];\n\t}\n\tfor(int i=0;i<N;i++) for(int j=0;j<N;j++){\n\t\tmat[N-1-j][i]=tmp[i][j];\n\t}\n}\n\nlong long getHash_brute(int D,int E,int F,int G){\n\tlong long res=314159265;\n\tfor(int i=0;i<N;i++) for(int j=0;j<N;j++){\n\t\tres*=31;\n\t\tres+=mat[i][j];\n\t\tres%=mod;\n\t}\n\treturn res;\n}\n\nvoid output_brute(){\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<N;j++) printf(\"%lld \",mat[i][j]);\n\t\tprintf(\"\\n\");\n\t}\n}\n\nbool TEST;\n\nint main(){\n\tTEST=false;\n\tif(TEST){\n\t\tinit();\n\t\tinit_brute(A,B,C);\n\t\tprintf(\"a\\n\");\n\t//\toutput_brute();\n\t\tfor(int q=0;q<Q;q++){\n\t\t\tstring str;\n\t\t\tcin>>str;\n\t\t\tif(str==\"SR\"){\n\t\t\t\tint a,b;\n\t\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\t\ta--;b--;\n\t\t\t\tSR_brute(a,b);\n\t\t\t}else if(str==\"RL\"){\n\t\t\t\tRL_brute();\n\t\t\t}\n\t\t}\n\t\tlong long ans=getHash_brute(D,E,F,G);\n\t\tprintf(\"%lld\\n\",ans);\n\t//\toutput_brute();\n\t\treturn 0;\n\t}\n\tinit();\n//\toutput();\n\tfor(int q=0;q<Q;q++){\n\t\tquery();\n\t}\n\tlong long ans=getHash(D,E,F,G);\n//\toutput();\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#if 0\n#define DEBUG_MODE\n#endif\n\n#define TREE_MAX 40000\n\ntypedef struct {\n\tint key_r;\n\tint key_c;\n\tint data;\n\tint isred;\n\tint parent;\n\tint left;\n\tint right;\n} rbt_node_t;\n\nint rbt_node_used;\nrbt_node_t rbt_node[TREE_MAX+1];\n\nvoid rbt_init(void) {\n\trbt_node_used=1;\n\tmemset(rbt_node,0,sizeof(rbt_node));\n\trbt_node[0].key_r=-0x7fffffff;\n\trbt_node[0].key_c=-0x7fffffff;\n}\n\nint rbt_search(int key_r,int key_c) {\n\tint pos=rbt_node[0].right;\n\twhile(pos>0) {\n\t\tif(rbt_node[pos].key_r==key_r && rbt_node[pos].key_c==key_c) {\n\t\t\treturn rbt_node[pos].data;\n\t\t} else if(rbt_node[pos].key_r<key_r ||\n\t\t\t\t(rbt_node[pos].key_r==key_r && rbt_node[pos].key_c<key_c)) {\n\t\t\tpos=rbt_node[pos].right;\n\t\t} else {\n\t\t\tpos=rbt_node[pos].left;\n\t\t}\n\t}\n\treturn -1;\n}\n\nint rbt_insert(int key_r,int key_c,int data) {\n\tint pos=0;\n\tint parent,p_parent,p_left,p_right;\n\tint pp_parent,pp_left,pp_right;\n\twhile(1) {\n\t\tif(rbt_node[pos].key_r==key_r && rbt_node[pos].key_c==key_c) {\n\t\t\trbt_node[pos].data=data;\n\t\t\treturn 1;\n\t\t} else if(rbt_node[pos].key_r<key_r ||\n\t\t\t\t(rbt_node[pos].key_r==key_r && rbt_node[pos].key_c<key_c)) {\n\t\t\tif(rbt_node[pos].right==0)break;\n\t\t\tpos=rbt_node[pos].right;\n\t\t} else {\n\t\t\tif(rbt_node[pos].left==0)break;\n\t\t\tpos=rbt_node[pos].left;\n\t\t}\n\t}\n\tif(rbt_node_used>TREE_MAX)return 0;\n\trbt_node[rbt_node_used].key_r=key_r;\n\trbt_node[rbt_node_used].key_c=key_c;\n\trbt_node[rbt_node_used].data=data;\n\trbt_node[rbt_node_used].isred=1;\n\trbt_node[rbt_node_used].parent=pos;\n\trbt_node[rbt_node_used].left=0;\n\trbt_node[rbt_node_used].right=0;\n\tif(rbt_node[pos].key_r<key_r ||\n\t\t\t(rbt_node[pos].key_r==key_r && rbt_node[pos].key_c<key_c)) {\n\t\trbt_node[pos].right=rbt_node_used;\n\t} else {\n\t\trbt_node[pos].left=rbt_node_used;\n\t}\n\tpos=rbt_node_used;\n\trbt_node_used++;\n\n\twhile(pos>0) {\n\t\tif(rbt_node[pos].parent==0) {\n\t\t\trbt_node[pos].isred=0;\n\t\t\tbreak;\n\t\t}\n\t\tparent=rbt_node[pos].parent;\n\t\tp_parent=rbt_node[parent].parent;\n\t\tp_left=rbt_node[parent].left;\n\t\tp_right=rbt_node[parent].right;\n\t\tif(!rbt_node[parent].isred) {\n\t\t\tbreak;\n\t\t}\n\t\tpp_parent=rbt_node[p_parent].parent;\n\t\tpp_left=rbt_node[p_parent].left;\n\t\tpp_right=rbt_node[p_parent].right;\n\t\tif(rbt_node[pp_left].isred && rbt_node[pp_right].isred) {\n\t\t\trbt_node[pp_left].isred=0;\n\t\t\trbt_node[pp_right].isred=0;\n\t\t\trbt_node[p_parent].isred=1;\n\t\t\tpos=p_parent;\n\t\t} else {\n\t\t\tif(pos==p_right && parent==pp_left) {\n\t\t\t\tif(rbt_node[pos].left>0) {\n\t\t\t\t\trbt_node[rbt_node[pos].left].parent=parent;\n\t\t\t\t}\n\t\t\t\trbt_node[parent].right=rbt_node[pos].left;\n\t\t\t\trbt_node[parent].parent=pos;\n\t\t\t\trbt_node[pos].left=parent;\n\t\t\t\trbt_node[pos].parent=p_parent;\n\t\t\t\trbt_node[p_parent].left=pos;\n\t\t\t\tpos=parent;\n\t\t\t} else if(pos==p_left && parent==pp_right) {\n\t\t\t\tif(rbt_node[pos].right>0) {\n\t\t\t\t\trbt_node[rbt_node[pos].right].parent=parent;\n\t\t\t\t}\n\t\t\t\trbt_node[parent].left=rbt_node[pos].right;\n\t\t\t\trbt_node[parent].parent=pos;\n\t\t\t\trbt_node[pos].right=parent;\n\t\t\t\trbt_node[pos].parent=p_parent;\n\t\t\t\trbt_node[p_parent].right=pos;\n\t\t\t\tpos=parent;\n\t\t\t} else if(pos==p_left && parent==pp_left) {\n\t\t\t\tif(rbt_node[pp_parent].left==p_parent) {\n\t\t\t\t\trbt_node[pp_parent].left=parent;\n\t\t\t\t} else if(rbt_node[pp_parent].right==p_parent) {\n\t\t\t\t\trbt_node[pp_parent].right=parent;\n\t\t\t\t} else {\n\t\t\t\t\t/* error!bug! */\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(rbt_node[parent].right>0) {\n\t\t\t\t\trbt_node[rbt_node[parent].right].parent=p_parent;\n\t\t\t\t}\n\t\t\t\trbt_node[p_parent].left=rbt_node[parent].right;\n\t\t\t\trbt_node[p_parent].parent=parent;\n\t\t\t\trbt_node[parent].right=p_parent;\n\t\t\t\trbt_node[parent].parent=pp_parent;\n\t\t\t\trbt_node[p_parent].isred=1;\n\t\t\t\trbt_node[parent].isred=0;\n\t\t\t\tbreak;\n\t\t\t} else if(pos==p_right && parent==pp_right) {\n\t\t\t\tif(rbt_node[pp_parent].left==p_parent) {\n\t\t\t\t\trbt_node[pp_parent].left=parent;\n\t\t\t\t} else if(rbt_node[pp_parent].right==p_parent) {\n\t\t\t\t\trbt_node[pp_parent].right=parent;\n\t\t\t\t} else {\n\t\t\t\t\t/* error!bug! */\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(rbt_node[parent].left>0) {\n\t\t\t\t\trbt_node[rbt_node[parent].left].parent=p_parent;\n\t\t\t\t}\n\t\t\t\trbt_node[p_parent].right=rbt_node[parent].left;\n\t\t\t\trbt_node[p_parent].parent=parent;\n\t\t\t\trbt_node[parent].left=p_parent;\n\t\t\t\trbt_node[parent].parent=pp_parent;\n\t\t\t\trbt_node[p_parent].isred=1;\n\t\t\t\trbt_node[parent].isred=0;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t/* error!bug! */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\trbt_node[0].parent=0;\n\trbt_node[0].left=0;\n\trbt_node[0].isred=0;\n\treturn 1;\n}\n\nint N,Q,A,B,C,D,E,F,G;\n\nint rc_flip,row_flip,col_flip;\nint row_table[40001];\nint col_table[40001];\n\nint get_value(int r,int c) {\n\tint kari_value;\n\tint hr,hc,temp;\n\thr=r;hc=c;\n\tif(rc_flip){temp=hr;hr=hc;hc=temp;}\n\thr=row_flip?row_table[N-hr+1]:row_table[hr];\n\thc=col_flip?col_table[N-hc+1]:col_table[hc];\n#ifdef DEBUG_MODE\n\tprintf(\"[%d,%d]\",hr,hc);\n#endif\n\tkari_value=rbt_search(hr,hc);\n\tif(kari_value<0)return (int)(((long long)hr*A+(long long)hc*B)%C);\n\treturn kari_value;\n}\n\nvoid set_value(int r,int c,int v) {\n\tint hr,hc,temp;\n\thr=r;hc=c;\n\tif(rc_flip){temp=hr;hr=hc;hc=temp;}\n\thr=row_flip?row_table[N-hr+1]:row_table[hr];\n\thc=col_flip?col_table[N-hc+1]:col_table[hc];\n\trbt_insert(hr,hc,v);\n}\n\nint main(void) {\n\tint i;\n\tchar order[4];\n\tint h1,h2,h3,h4;\n\tint temp;\n\tint r,c;\n\tlong long hash;\n\tscanf(\"%d%d%d%d%d%d%d%d%d\",&N,&Q,&A,&B,&C,&D,&E,&F,&G);\n\trbt_init();\n\trc_flip=row_flip=col_flip=0;\n\tfor(i=1;i<=N;i++) {\n\t\trow_table[i]=col_table[i]=i;\n\t}\n\tfor(i=0;i<Q;i++) {\n#ifdef DEBUG_MODE\n\t\tfor(r=D;r<=E;r++) {\n\t\t\tfor(c=F;c<=G;c++) {\n\t\t\t\tprintf(\"%3d\",get_value(r,c));\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n#endif\n\t\tscanf(\"%s\",order);\n\t\tif(strcmp(order,\"WR\")==0) {\n\t\t\tscanf(\"%d%d%d\",&h1,&h2,&h3);\n\t\t\tset_value(h1,h2,h3);\n\t\t} else if(strcmp(order,\"CP\")==0) {\n\t\t\tscanf(\"%d%d%d%d\",&h1,&h2,&h3,&h4);\n\t\t\tset_value(h3,h4,get_value(h1,h2));\n\t\t} else if(strcmp(order,\"SR\")==0) {\n\t\t\tscanf(\"%d%d\",&h1,&h2);\n\t\t\tif(rc_flip) {\n\t\t\t\tif(col_flip){h1=N-h1+1;h2=N-h2+1;}\n\t\t\t\ttemp=col_table[h1];\n\t\t\t\tcol_table[h1]=col_table[h2];\n\t\t\t\tcol_table[h2]=temp;\n\t\t\t} else {\n\t\t\t\tif(row_flip){h1=N-h1+1;h2=N-h2+1;}\n\t\t\t\ttemp=row_table[h1];\n\t\t\t\trow_table[h1]=row_table[h2];\n\t\t\t\trow_table[h2]=temp;\n\t\t\t}\n\t\t} else if(strcmp(order,\"SC\")==0) {\n\t\t\tscanf(\"%d%d\",&h1,&h2);\n\t\t\tif(rc_flip) {\n\t\t\t\tif(row_flip){h1=N-h1+1;h2=N-h2+1;}\n\t\t\t\ttemp=row_table[h1];\n\t\t\t\trow_table[h1]=row_table[h2];\n\t\t\t\trow_table[h2]=temp;\n\t\t\t} else {\n\t\t\t\tif(col_flip){h1=N-h1+1;h2=N-h2+1;}\n\t\t\t\ttemp=col_table[h1];\n\t\t\t\tcol_table[h1]=col_table[h2];\n\t\t\t\tcol_table[h2]=temp;\n\t\t\t}\n\t\t} else if(strcmp(order,\"RL\")==0) {\n\t\t\trc_flip=!rc_flip;\n\t\t\tif(rc_flip) {\n\t\t\t\tcol_flip=!col_flip;\n\t\t\t} else {\n\t\t\t\trow_flip=!row_flip;\n\t\t\t}\n\t\t} else if(strcmp(order,\"RR\")==0) {\n\t\t\trc_flip=!rc_flip;\n\t\t\tif(rc_flip) {\n\t\t\t\trow_flip=!row_flip;\n\t\t\t} else {\n\t\t\t\tcol_flip=!col_flip;\n\t\t\t}\n\t\t} else if(strcmp(order,\"RH\")==0) {\n\t\t\tif(rc_flip) {\n\t\t\t\tcol_flip=!col_flip;\n\t\t\t} else {\n\t\t\t\trow_flip=!row_flip;\n\t\t\t}\n\t\t} else if(strcmp(order,\"RV\")==0) {\n\t\t\tif(rc_flip) {\n\t\t\t\trow_flip=!row_flip;\n\t\t\t} else {\n\t\t\t\tcol_flip=!col_flip;\n\t\t\t}\n\t\t} else return 1;\n\t}\n#ifdef DEBUG_MODE\n\tfor(r=D;r<=E;r++) {\n\t\tfor(c=F;c<=G;c++) {\n\t\t\tprintf(\"%3d\",get_value(r,c));\n\t\t}\n\t\tputs(\"\");\n\t}\n#endif\n\thash=314159265;\n\tfor(r=D;r<=E;r++) {\n\t\tfor(c=F;c<=G;c++) {\n\t\t\thash=(31*hash+get_value(r,c))%1000000007;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",hash);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#if 0\n#define DEBUG_MODE\n#endif\n\n#define TREE_MAX 40000\n\ntypedef struct {\n\tint key_r;\n\tint key_c;\n\tint data;\n\tint isred;\n\tint parent;\n\tint left;\n\tint right;\n} rbt_node_t;\n\nint rbt_node_used;\nrbt_node_t rbt_node[TREE_MAX+1];\n\nvoid rbt_init(void) {\n\trbt_node_used=1;\n\tmemset(rbt_node,0,sizeof(rbt_node));\n\trbt_node[0].key_r=-0x7fffffff;\n\trbt_node[0].key_c=-0x7fffffff;\n}\n\nint rbt_search(int key_r,int key_c) {\n\tint pos=rbt_node[0].right;\n\twhile(pos>0) {\n\t\tif(rbt_node[pos].key_r==key_r && rbt_node[pos].key_c==key_c) {\n\t\t\treturn rbt_node[pos].data;\n\t\t} else if(rbt_node[pos].key_r<key_r ||\n\t\t\t\t(rbt_node[pos].key_r==key_r && rbt_node[pos].key_c<key_c)) {\n\t\t\tpos=rbt_node[pos].right;\n\t\t} else {\n\t\t\tpos=rbt_node[pos].left;\n\t\t}\n\t}\n\treturn -1;\n}\n\nint rbt_insert(int key_r,int key_c,int data) {\n\tint pos=0;\n\tint parent,p_parent,p_left,p_right;\n\tint pp_parent,pp_left,pp_right;\n\twhile(1) {\n\t\tif(rbt_node[pos].key_r==key_r && rbt_node[pos].key_c==key_c) {\n\t\t\trbt_node[pos].data=data;\n\t\t\treturn 1;\n\t\t} else if(rbt_node[pos].key_r<key_r ||\n\t\t\t\t(rbt_node[pos].key_r==key_r && rbt_node[pos].key_c<key_c)) {\n\t\t\tif(rbt_node[pos].right==0)break;\n\t\t\tpos=rbt_node[pos].right;\n\t\t} else {\n\t\t\tif(rbt_node[pos].left==0)break;\n\t\t\tpos=rbt_node[pos].left;\n\t\t}\n\t}\n\tif(rbt_node_used>TREE_MAX)return 0;\n\trbt_node[rbt_node_used].key_r=key_r;\n\trbt_node[rbt_node_used].key_c=key_c;\n\trbt_node[rbt_node_used].data=data;\n\trbt_node[rbt_node_used].isred=1;\n\trbt_node[rbt_node_used].parent=pos;\n\trbt_node[rbt_node_used].left=0;\n\trbt_node[rbt_node_used].right=0;\n\tif(rbt_node[pos].key_r<key_r ||\n\t\t\t(rbt_node[pos].key_r==key_r && rbt_node[pos].key_c<key_c)) {\n\t\trbt_node[pos].right=rbt_node_used;\n\t} else {\n\t\trbt_node[pos].left=rbt_node_used;\n\t}\n\tpos=rbt_node_used;\n\trbt_node_used++;\n\n\twhile(pos>0) {\n\t\tif(rbt_node[pos].parent==0) {\n\t\t\trbt_node[pos].isred=0;\n\t\t\tbreak;\n\t\t}\n\t\tparent=rbt_node[pos].parent;\n\t\tp_parent=rbt_node[parent].parent;\n\t\tp_left=rbt_node[parent].left;\n\t\tp_right=rbt_node[parent].right;\n\t\tif(!rbt_node[parent].isred) {\n\t\t\tbreak;\n\t\t}\n\t\tpp_parent=rbt_node[p_parent].parent;\n\t\tpp_left=rbt_node[p_parent].left;\n\t\tpp_right=rbt_node[p_parent].right;\n\t\tif(rbt_node[pp_left].isred && rbt_node[pp_right].isred) {\n\t\t\trbt_node[pp_left].isred=0;\n\t\t\trbt_node[pp_right].isred=0;\n\t\t\trbt_node[p_parent].isred=1;\n\t\t\tpos=p_parent;\n\t\t} else {\n\t\t\tif(pos==p_right && parent==pp_left) {\n\t\t\t\tif(rbt_node[pos].left>0) {\n\t\t\t\t\trbt_node[rbt_node[pos].left].parent=parent;\n\t\t\t\t}\n\t\t\t\trbt_node[parent].right=rbt_node[pos].left;\n\t\t\t\trbt_node[parent].parent=pos;\n\t\t\t\trbt_node[pos].left=parent;\n\t\t\t\trbt_node[pos].parent=p_parent;\n\t\t\t\trbt_node[p_parent].left=pos;\n\t\t\t\tpos=parent;\n\t\t\t} else if(pos==p_left && parent==pp_right) {\n\t\t\t\tif(rbt_node[pos].right>0) {\n\t\t\t\t\trbt_node[rbt_node[pos].right].parent=parent;\n\t\t\t\t}\n\t\t\t\trbt_node[parent].left=rbt_node[pos].right;\n\t\t\t\trbt_node[parent].parent=pos;\n\t\t\t\trbt_node[pos].right=parent;\n\t\t\t\trbt_node[pos].parent=p_parent;\n\t\t\t\trbt_node[p_parent].right=pos;\n\t\t\t\tpos=parent;\n\t\t\t} else if(pos==p_left && parent==pp_left) {\n\t\t\t\tif(rbt_node[pp_parent].left==p_parent) {\n\t\t\t\t\trbt_node[pp_parent].left=parent;\n\t\t\t\t} else if(rbt_node[pp_parent].right==p_parent) {\n\t\t\t\t\trbt_node[pp_parent].right=parent;\n\t\t\t\t} else {\n\t\t\t\t\t/* error!bug! */\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(rbt_node[parent].right>0) {\n\t\t\t\t\trbt_node[rbt_node[parent].right].parent=p_parent;\n\t\t\t\t}\n\t\t\t\trbt_node[p_parent].left=rbt_node[parent].right;\n\t\t\t\trbt_node[p_parent].parent=parent;\n\t\t\t\trbt_node[parent].right=p_parent;\n\t\t\t\trbt_node[parent].parent=pp_parent;\n\t\t\t\trbt_node[p_parent].isred=1;\n\t\t\t\trbt_node[parent].isred=0;\n\t\t\t\tbreak;\n\t\t\t} else if(pos==p_right && parent==pp_right) {\n\t\t\t\tif(rbt_node[pp_parent].left==p_parent) {\n\t\t\t\t\trbt_node[pp_parent].left=parent;\n\t\t\t\t} else if(rbt_node[pp_parent].right==p_parent) {\n\t\t\t\t\trbt_node[pp_parent].right=parent;\n\t\t\t\t} else {\n\t\t\t\t\t/* error!bug! */\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(rbt_node[parent].left>0) {\n\t\t\t\t\trbt_node[rbt_node[parent].left].parent=p_parent;\n\t\t\t\t}\n\t\t\t\trbt_node[p_parent].right=rbt_node[parent].left;\n\t\t\t\trbt_node[p_parent].parent=parent;\n\t\t\t\trbt_node[parent].left=p_parent;\n\t\t\t\trbt_node[parent].parent=pp_parent;\n\t\t\t\trbt_node[p_parent].isred=1;\n\t\t\t\trbt_node[parent].isred=0;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t/* error!bug! */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\trbt_node[0].parent=0;\n\trbt_node[0].left=0;\n\trbt_node[0].isred=0;\n\treturn 1;\n}\n\nint N,Q,A,B,C,D,E,F,G;\n\nint rc_flip,row_flip,col_flip;\nint row_table[40001];\nint col_table[40001];\n\nint get_value(int r,int c) {\n\tint kari_value;\n\tint hr,hc,temp;\n\thr=r;hc=c;\n\tif(rc_flip){temp=hr;hr=hc;hc=temp;}\n\thr=row_flip?row_table[N-hr+1]:row_table[hr];\n\thc=col_flip?col_table[N-hc+1]:col_table[hc];\n#ifdef DEBUG_MODE\n\tprintf(\"[%d,%d]\",hr,hc);\n#endif\n\tkari_value=rbt_search(hr,hc);\n\tif(kari_value<0)return (int)(((long long)hr*A+(long long)hc*B)%C);\n\treturn kari_value;\n}\n\nvoid set_value(int r,int c,int v) {\n\tint hr,hc,temp;\n\thr=r;hc=c;\n\tif(rc_flip){temp=hr;hr=hc;hc=temp;}\n\thr=row_flip?row_table[N-hr+1]:row_table[hr];\n\thc=col_flip?col_table[N-hc+1]:col_table[hc];\n\trbt_insert(hr,hc,v);\n}\n\nint main(void) {\n\tint i;\n\tchar order[4];\n\tint h1,h2,h3,h4;\n\tint temp;\n\tint r,c;\n\tlong long hash;\n\tscanf(\"%d%d%d%d%d%d%d%d%d\",&N,&Q,&A,&B,&C,&D,&E,&F,&G);\n\trbt_init();\n\trc_flip=row_flip=col_flip=0;\n\tfor(i=1;i<=N;i++) {\n\t\trow_table[i]=col_table[i]=i;\n\t}\n\tfor(i=0;i<Q;i++) {\n#ifdef DEBUG_MODE\n\t\tfor(r=D;r<=E;r++) {\n\t\t\tfor(c=F;c<=G;c++) {\n\t\t\t\tprintf(\"%3d\",get_value(r,c));\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n#endif\n\t\tscanf(\"%s\",order);\n\t\tif(strcmp(order,\"WR\")==0) {\n\t\t\tscanf(\"%d%d%d\",&h1,&h2,&h3);\n\t\t\tset_value(h1,h2,h3);\n\t\t} else if(strcmp(order,\"CP\")==0) {\n\t\t\tscanf(\"%d%d%d%d\",&h1,&h2,&h3,&h4);\n\t\t\tset_value(h3,h4,get_value(h1,h2));\n\t\t} else if(strcmp(order,\"SR\")==0) {\n\t\t\tscanf(\"%d%d\",&h1,&h2);\n\t\t\tif(rc_flip) {\n\t\t\t\tif(col_flip){h1=N-h1+1;h2=N-h2+1;}\n\t\t\t\ttemp=col_table[h1];\n\t\t\t\tcol_table[h1]=col_table[h2];\n\t\t\t\tcol_table[h2]=temp;\n\t\t\t} else {\n\t\t\t\tif(row_flip){h1=N-h1+1;h2=N-h2+1;}\n\t\t\t\ttemp=row_table[h1];\n\t\t\t\trow_table[h1]=row_table[h2];\n\t\t\t\trow_table[h2]=temp;\n\t\t\t}\n\t\t} else if(strcmp(order,\"SC\")==0) {\n\t\t\tscanf(\"%d%d\",&h1,&h2);\n\t\t\tif(rc_flip) {\n\t\t\t\tif(row_flip){h1=N-h1+1;h2=N-h2+1;}\n\t\t\t\ttemp=row_table[h1];\n\t\t\t\trow_table[h1]=row_table[h2];\n\t\t\t\trow_table[h2]=temp;\n\t\t\t} else {\n\t\t\t\tif(col_flip){h1=N-h1+1;h2=N-h2+1;}\n\t\t\t\ttemp=col_table[h1];\n\t\t\t\tcol_table[h1]=col_table[h2];\n\t\t\t\tcol_table[h2]=temp;\n\t\t\t}\n\t\t} else if(strcmp(order,\"RL\")==0) {\n\t\t\trc_flip=!rc_flip;\n\t\t\tif(rc_flip) {\n\t\t\t\tcol_flip=!col_flip;\n\t\t\t} else {\n\t\t\t\trow_flip=!row_flip;\n\t\t\t}\n\t\t} else if(strcmp(order,\"RR\")==0) {\n\t\t\trc_flip=!rc_flip;\n\t\t\tif(rc_flip) {\n\t\t\t\trow_flip=!row_flip;\n\t\t\t} else {\n\t\t\t\tcol_flip=!col_flip;\n\t\t\t}\n\t\t} else if(strcmp(order,\"RH\")==0) {\n\t\t\tif(rc_flip) {\n\t\t\t\tcol_flip=!col_flip;\n\t\t\t} else {\n\t\t\t\trow_flip=!row_flip;\n\t\t\t}\n\t\t} else if(strcmp(order,\"RV\")==0) {\n\t\t\tif(rc_flip) {\n\t\t\t\trow_flip=!row_flip;\n\t\t\t} else {\n\t\t\t\tcol_flip=!col_flip;\n\t\t\t}\n\t\t} else return 1;\n\t}\n#ifdef DEBUG_MODE\n\tfor(r=D;r<=E;r++) {\n\t\tfor(c=F;c<=G;c++) {\n\t\t\tprintf(\"%3d\",get_value(r,c));\n\t\t}\n\t\tputs(\"\");\n\t}\n#endif\n\thash=314159265;\n\tfor(r=D;r<=E;r++) {\n\t\tfor(c=F;c<=G;c++) {\n\t\t\thash=(31*hash+get_value(r,c))%100000007;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(int)hash);\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tsolver();\n\t}\n\n\tint N;\n\tint Q;\n\tlong A, B, C;\n\tint[] row;\n\tint[] column;\n\tint[][] go = new int[][] { { 1, 0 }, { 0, 1 } };\n\tint[][] back = new int[][] { { 1, 0 }, { 0, 1 } };\n\tfinal int[][] RL = new int[][] { { 0, -1 }, { 1, 0 } };\n\tfinal int[][] RR = new int[][] { { 0, 1 }, { -1, 0 } };\n\tfinal int[][] RH = new int[][] { { 1, 0 }, { 0, -1 } };\n\tfinal int[][] RV = new int[][] { { -1, 0 }, { 0, 1 } };\n\tHashMap<List<Integer>, Long> map = new HashMap<>();\n\tfinal long MODULO = 1_000_000_000 + 7;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tN = sc.nextInt();\n\t\tQ = sc.nextInt();\n\t\tA = sc.nextLong();\n\t\tB = sc.nextLong();\n\t\tC = sc.nextLong();\n\t\trow = new int[N + 1];\n\t\tcolumn = new int[N + 1];\n\t\tfor (int i = 0; i <= N; ++i) {\n\t\t\trow[i] = i;\n\t\t\tcolumn[i] = i;\n\t\t}\n\t\tint D = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tint F = sc.nextInt();\n\t\tint G = sc.nextInt();\n\t\tfor (int q = 0; q < Q; ++q) {\n\t\t\tString s = sc.next();\n\t\t\tif (s.equals(\"WR\")) {\n\t\t\t\tint r = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tlong v = sc.nextLong();\n\t\t\t\tint[][] pos = get(r, c, true);\n\t\t\t\tc = pos[0][0];\n\t\t\t\tr = pos[1][0];\n\t\t\t\tmap.put(Arrays.asList(row[r], column[c]), v);\n\t\t\t} else if (s.equals(\"CP\")) {\n\t\t\t\tint r1 = sc.nextInt();\n\t\t\t\tint c1 = sc.nextInt();\n\t\t\t\tint r2 = sc.nextInt();\n\t\t\t\tint c2 = sc.nextInt();\n\t\t\t\tlong v = getValue(r1, c1);\n\t\t\t\tint[][] pos = get(r2, c2, true);\n\t\t\t\tint r = pos[1][0];\n\t\t\t\tint c = pos[0][0];\n\t\t\t\tmap.put(Arrays.asList(row[r], column[c]), v);\n\t\t\t} else if (s.equals(\"RL\")) {\n\t\t\t\tgo = mul(RL, go);\n\t\t\t\tback = mul(back, RR);\n\t\t\t} else if (s.equals(\"RR\")) {\n\t\t\t\tgo = mul(RR, go);\n\t\t\t\tback = mul(back, RL);\n\t\t\t} else if (s.equals(\"RH\")) {\n\t\t\t\tgo = mul(RH, go);\n\t\t\t\tback = mul(back, RH);\n\t\t\t} else if (s.equals(\"RV\")) {\n\t\t\t\tgo = mul(RV, go);\n\t\t\t\tback = mul(back, RV);\n\t\t\t} else if (s.equals(\"SR\")) {\n\t\t\t\tint r1 = sc.nextInt();\n\t\t\t\tint r2 = sc.nextInt();\n\t\t\t\tint[][] v1 = get(r1, 0, false);\n\t\t\t\tint[][] v2 = get(r2, 0, false);\n\t\t\t\tswap(v1, v2);\n\t\t\t} else if (s.equals(\"SC\")) {\n\t\t\t\tint c1 = sc.nextInt();\n\t\t\t\tint c2 = sc.nextInt();\n\t\t\t\tint[][] v1 = get(0, c1, false);\n\t\t\t\tint[][] v2 = get(0, c2, false);\n\t\t\t\tswap(v1, v2);\n\t\t\t}\n\t\t}\n\n\t\tlong h = 314159265;\n\t\tfor (int r = D; r <= E; ++r) {\n\t\t\tfor (int c = F; c <= G; ++c) {\n\t\t\t\th = (31 * h + getValue(r, c)) % MODULO;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(h);\n\t\tsc.close();\n\t}\n\n\tlong getValue(int r, int c) {\n\t\tint[][] pos = get(r, c, true);\n\t\tint rp = pos[1][0];\n\t\tint cp = pos[0][0];\n\t\tif (map.containsKey(Arrays.asList(row[rp], column[cp]))) {\n\t\t\treturn map.get(Arrays.asList(row[rp], column[cp])) % MODULO;\n\t\t} else {\n\t\t\treturn init(row[rp], column[cp]);\n\t\t}\n\t}\n\n\tint[][] get(int r, int c, boolean forward) {\n\t\tint[][] v = new int[][] { { c }, { r } };\n\t\tv = mul(forward ? go : back, v);\n\t\tif (v[0][0] < 0)\n\t\t\tv[0][0] += N + 1;\n\t\tif (v[1][0] < 0)\n\t\t\tv[1][0] += N + 1;\n\t\treturn v;\n\t}\n\n\tlong init(long r, long c) {\n\t\treturn (r * A + c * B) % C;\n\t}\n\n\tvoid swap(int[][] v1, int[][] v2) {\n\t\tint c1 = v1[0][0];\n\t\tint c2 = v2[0][0];\n\t\tint r1 = v1[1][0];\n\t\tint r2 = v2[1][0];\n\t\tint d = row[r1];\n\t\trow[r1] = row[r2];\n\t\trow[r2] = d;\n\t\td = column[c1];\n\t\tcolumn[c1] = column[c2];\n\t\tcolumn[c2] = d;\n\t}\n\n\tint[][] mul(int[][] a, int[][] b) {\n\t\tassert a[0].length == b.length;\n\t\tint n = a[0].length;\n\t\tint[][] ret = new int[a.length][b[0].length];\n\t\tfor (int i = 0; i < a.length; ++i) {\n\t\t\tfor (int j = 0; j < b[0].length; ++j) {\n\t\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\t\tret[i][j] += a[i][k] * b[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tsolver();\n\t}\n\n\tint N;\n\tint Q;\n\tlong A, B, C;\n\tint[] row;\n\tint[] column;\n\tint[][] back = new int[][] { { 1, 0 }, { 0, 1 } };\n\tfinal int[][] RR = new int[][] { { 0, -1 }, { 1, 0 } };\n\tfinal int[][] RL = new int[][] { { 0, 1 }, { -1, 0 } };\n\tfinal int[][] RH = new int[][] { { 1, 0 }, { 0, -1 } };\n\tfinal int[][] RV = new int[][] { { -1, 0 }, { 0, 1 } };\n\tHashMap<List<Integer>, Long> map = new HashMap<>();\n\tfinal long MODULO = 1_000_000_000 + 7;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tN = sc.nextInt();\n\t\tQ = sc.nextInt();\n\t\tA = sc.nextLong();\n\t\tB = sc.nextLong();\n\t\tC = sc.nextLong();\n\t\trow = new int[N + 1];\n\t\tcolumn = new int[N + 1];\n\t\tfor (int i = 0; i <= N; ++i) {\n\t\t\trow[i] = i;\n\t\t\tcolumn[i] = i;\n\t\t}\n\t\tint D = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tint F = sc.nextInt();\n\t\tint G = sc.nextInt();\n\t\tfor (int q = 0; q < Q; ++q) {\n\t\t\tString s = sc.next();\n\t\t\tif (s.equals(\"WR\")) {\n\t\t\t\tint r = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tlong v = sc.nextLong();\n\t\t\t\tint[][] pos = get(r, c);\n\t\t\t\tc = pos[0][0];\n\t\t\t\tr = pos[1][0];\n\t\t\t\tmap.put(Arrays.asList(row[r], column[c]), v);\n\t\t\t} else if (s.equals(\"CP\")) {\n\t\t\t\tint r1 = sc.nextInt();\n\t\t\t\tint c1 = sc.nextInt();\n\t\t\t\tint r2 = sc.nextInt();\n\t\t\t\tint c2 = sc.nextInt();\n\t\t\t\tlong v = getValue(r1, c1);\n\t\t\t\tint[][] pos = get(r2, c2);\n\t\t\t\tint r = pos[1][0];\n\t\t\t\tint c = pos[0][0];\n\t\t\t\tmap.put(Arrays.asList(row[r], column[c]), v);\n\t\t\t} else if (s.equals(\"RL\")) {\n\t\t\t\tback = mul(back, RR);\n\t\t\t} else if (s.equals(\"RR\")) {\n\t\t\t\tback = mul(back, RL);\n\t\t\t} else if (s.equals(\"RH\")) {\n\t\t\t\tback = mul(back, RH);\n\t\t\t} else if (s.equals(\"RV\")) {\n\t\t\t\tback = mul(back, RV);\n\t\t\t} else if (s.equals(\"SR\")) {\n\t\t\t\tint r1 = sc.nextInt();\n\t\t\t\tint r2 = sc.nextInt();\n\t\t\t\tint[][] v1 = get(r1, 0);\n\t\t\t\tint[][] v2 = get(r2, 0);\n\t\t\t\tswap(v1, v2);\n\t\t\t} else if (s.equals(\"SC\")) {\n\t\t\t\tint c1 = sc.nextInt();\n\t\t\t\tint c2 = sc.nextInt();\n\t\t\t\tint[][] v1 = get(0, c1);\n\t\t\t\tint[][] v2 = get(0, c2);\n\t\t\t\tswap(v1, v2);\n\t\t\t}\n\t\t}\n\n\t\tlong h = 314159265;\n\t\tfor (int r = D; r <= E; ++r) {\n\t\t\tfor (int c = F; c <= G; ++c) {\n\t\t\t\th = (31 * h + getValue(r, c)) % MODULO;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(h);\n\t\tsc.close();\n\t}\n\n\tlong getValue(int r, int c) {\n\t\tint[][] pos = get(r, c);\n\t\tint rp = pos[1][0];\n\t\tint cp = pos[0][0];\n\t\tif (map.containsKey(Arrays.asList(row[rp], column[cp]))) {\n\t\t\treturn map.get(Arrays.asList(row[rp], column[cp])) % MODULO;\n\t\t} else {\n\t\t\treturn init(row[rp], column[cp]);\n\t\t}\n\t}\n\n\tint[][] get(int r, int c) {\n\t\tint[][] v = new int[][] { { c }, { r } };\n\t\tv = mul(back, v);\n\t\tif (v[0][0] < 0)\n\t\t\tv[0][0] += N + 1;\n\t\tif (v[1][0] < 0)\n\t\t\tv[1][0] += N + 1;\n\t\treturn v;\n\t}\n\n\tlong init(long r, long c) {\n\t\treturn (r * A + c * B) % C;\n\t}\n\n\tvoid swap(int[][] v1, int[][] v2) {\n\t\tint c1 = v1[0][0];\n\t\tint c2 = v2[0][0];\n\t\tint r1 = v1[1][0];\n\t\tint r2 = v2[1][0];\n\t\tint d = row[r1];\n\t\trow[r1] = row[r2];\n\t\trow[r2] = d;\n\t\td = column[c1];\n\t\tcolumn[c1] = column[c2];\n\t\tcolumn[c2] = d;\n\t}\n\n\tint[][] mul(int[][] a, int[][] b) {\n\t\tassert a[0].length == b.length;\n\t\tint n = a[0].length;\n\t\tint[][] ret = new int[a.length][b[0].length];\n\t\tfor (int i = 0; i < a.length; ++i) {\n\t\t\tfor (int j = 0; j < b[0].length; ++j) {\n\t\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\t\tret[i][j] += a[i][k] * b[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "N, Q, A, B, C, D, E, F, G = gets.split.map(&:to_i)\n\nrow = (D..E).to_a\ncol = (F..G).to_a\n\nop = []\nQ.times do\n    c, i, j, x, y = gets.chomp.split\n    op << [c, i.to_i, j.to_i, x.to_i, y.to_i]\nend\n\nupdate = []\nflag = true\nop.reverse.each do |c, i, j, x, y|\n    case c\n    when 'WR'\n        update.unshift [c, i, j, x, nil]\n    when 'CP'\n        update.unshift [c, i, j, x, y]\n    when 'RV'\n        col.map! {|c| N + 1 - c}\n        update.each do |u|\n            u[2] = N + 1 - u[2]\n            u[4] = N + 1 - u[4] if u[0] == 'CP'\n        end\n    when 'RH'\n        row.map! {|r| N + 1 - r}\n        update.each do |u|\n            u[1] = N + 1 - u[1]\n            u[3] = N + 1 - u[3] if u[0] == 'CP'\n        end\n    when 'RL'\n        flag = !flag\n        row, col = col, row.map {|r| N + 1 - r}\n        update.each do |u|\n            u[1], u[2] = u[2], N + 1 - u[1]\n            u[3], u[4] = u[4], N + 1 - u[3] if u[0] == 'CP'\n        end\n    when 'RR'\n        flag = !flag\n        row, col = col.map {|c| N + 1 - c}, row\n        update.each do |u|\n            u[1], u[2] = N + 1 - u[2], u[1]\n            u[3], u[4] = N + 1 - u[4], u[3] if u[0] == 'CP'\n        end\n    when 'SR'\n        h = {i => j, j => i}\n        row.map! {|r| h[r] || r}\n        update.each do |u|\n            u[1] = h[u[1]] || u[1]\n            u[3] = h[u[3]] || u[3] if u[0] == 'CP'\n        end\n    when 'SC'\n        h = {i => j, j => i}\n        col.map! {|c| h[c] || c}\n        update.each do |u|\n            u[2] = h[u[2]] || u[2]\n            u[4] = h[u[4]] || u[4] if u[0] == 'CP'\n        end\n    end\nend\n\ntarget = []\nhash = {}\nif flag\n    row.each do |r|\n        col.each do |c|\n            k = [r, c]\n            v = (A * r + B * c) % C\n            target << k\n            hash[k] = v\n        end\n    end\nelse\n    col.each do |c|\n        row.each do |r|\n            k = [r, c]\n            v = (A * r + B * c) % C\n            target << k\n            hash[k] = v\n        end\n    end\nend\n\nupdate.each do |c, i, j, x, y|\n    if c == 'WR'\n        hash[[i, j]] = x\n    else\n        hash[[x, y]] = (hash[[i, j]] ||= (A * i + B * j) % C)\n    end\nend\n\nh = 314159265\ntarget.each do |k|\n    h = (h * 31 + hash[k]) % 1_000_000_007\nend\np h"
  },
  {
    "language": "Ruby",
    "code": "n, q, A, B, C, D, E, F, G = gets.split.map(&:to_i)\n\nqueries = (1..q).map do\n    c, i, j, x, y = gets.chomp.split\n    [c, i.to_i, j.to_i, x.to_i, y.to_i]\nend\n\n#contract rotation, reflection\n\ncontracted = []\nmirror = false\nrot = 0\n\ndef trans(mirror, rot, n, r, c)\n    rot.times { r, c = n + 1 - c, r }\n    c = n + 1 - c if mirror\n    return [r, c]\nend\n\nqueries.each do |query|\n    case query[0]\n    when 'WR'\n        _, r, c, v = query\n        r, c = trans(mirror, rot, n, r, c)\n        contracted << ['WR', r, c, v]\n    when 'CP'\n        _, r1, c1, r2, c2 = query\n        r1, c1 = trans(mirror, rot, n, r1, c1)\n        r2, c2 = trans(mirror, rot, n, r2, c2)\n        contracted << ['CP', r1, c1, r2, c2]\n    when 'SR'\n        _, r1, r2 = query\n        if rot.even?\n            r1, _ = trans(mirror, rot, n, r1, 0)\n            r2, _ = trans(mirror, rot, n, r2, 0)\n            contracted << ['SR', r1, r2]\n        else\n            _, c1 = trans(mirror, rot, n, r1, 0)\n            _, c2 = trans(mirror, rot, n, r2, 0)\n            contracted << ['SC', c1, c2]\n        end\n    when 'SC'\n        _, c1, c2 = query\n        if rot.odd?\n            r1, _ = trans(mirror, rot, n, 0, c1)\n            r2, _ = trans(mirror, rot, n, 0, c2)\n            contracted << ['SR', r1, r2]\n        else\n            _, c1 = trans(mirror, rot, n, 0, c1)\n            _, c2 = trans(mirror, rot, n, 0, c2)\n            contracted << ['SC', c1, c2]\n        end\n    when 'RL'\n        rot = (rot - 1) % 4\n    when 'RR'\n        rot = (rot + 1) % 4\n    when 'RH'\n        mirror = ! mirror\n        rot = (rot + 2) % 4 if rot.even?\n    when 'RV'\n        mirror = ! mirror\n        rot = (4 - rot) % 4\n    end\nend\n\nqueries = contracted\ncontracted = []\n\n#contract swap\n\nrow_perm = (0..n).to_a\ncol_perm = (0..n).to_a\nrow_perm_inv = (0..n).to_a\ncol_perm_inv = (0..n).to_a\n\nqueries.each do |query|\n    case query[0]\n    when 'WR'\n        _, r, c, v = query\n        r = row_perm_inv[r]\n        c = col_perm_inv[c]\n        contracted << ['WR', r, c, v]\n    when 'CP'\n        _, r1, c1, r2, c2 = query\n        r1 = row_perm_inv[r1]\n        c1 = col_perm_inv[c1]\n        r2 = row_perm_inv[r2]\n        c2 = col_perm_inv[c2]\n        contracted << ['CP', r1, c1, r2, c2]\n    when 'SR'\n        _, r1, r2 = query\n        row_perm[r1], row_perm[r2] = row_perm[r2], row_perm[r1]\n        row_perm_inv[row_perm[r1]] = r1\n        row_perm_inv[row_perm[r2]] = r2\n    when 'SC'\n        _, c1, c2 = query\n        col_perm[c1], col_perm[c2] = col_perm[c2], col_perm[c1]\n        col_perm_inv[col_perm[c1]] = c1\n        col_perm_inv[col_perm[c2]] = c2\n   end\nend\n\nrow = (D..E).to_a\ncol = (F..G).to_a\nrot.times do\n    row, col = col.map {|c| n + 1 - c}, row\nend\ncol.map! {|c| n + 1 - c} if mirror\nrow.map! {|r| row_perm_inv[r]}\ncol.map! {|c| col_perm_inv[c]}\n\nhash = {}\nrow.each do |r|\n    col.each do |c|\n        hash[[r, c]] = (r * A + c * B) % C\n    end\nend\n\ncontracted.each do |query|\n    case query[0]\n    when 'WR'\n        _, r, c, v = query\n        hash[[r, c]] = v\n    when 'CP'\n        _, r1, c1, r2, c2 = query\n        hash[[r2, c2]] = (hash[[r1, c1]] ||= (r1 * A + c1 * B) % C)\n    end\nend\n\nh = 314159265\nif rot.even?\n    row.each do |r|\n        col.each do |c|\n            h = (h * 31 + hash[[r, c]]) % 1_000_000_007\n        end\n    end\nelse\n    col.each do |c|\n        row.each do |r|\n            h = (h * 31 + hash[[r, c]]) % 1_000_000_007\n        end\n    end\nend\np h"
  },
  {
    "language": "Ruby",
    "code": "N, Q, A, B, C, D, E, F, G = gets.split.map(&:to_i)\n\nrow = (D..E).to_a\ncol = (F..G).to_a\n\nop = []\nQ.times do\n    c, i, j, x, y = gets.chomp.split\n    op << [c, i.to_i, j.to_i, x.to_i, y.to_i]\nend\n\nupdate = []\nop.reverse.each do |c, i, j, x, y|\n    case c\n    when 'WR'\n        update.unshift [c, i, j, x, nil]\n    when 'CP'\n        update.unshift [c, i, j, x, y]\n    when 'RV'\n        col.map! {|c| N + 1 - c}\n        update.each do |u|\n            u[2] = N + 1 - u[2]\n            u[4] = N + 1 - u[4] if u[0] == 'CP'\n        end\n    when 'RH'\n        row.map! {|r| N + 1 - r}\n        update.each do |u|\n            u[1] = N + 1 - u[1]\n            u[3] = N + 1 - u[3] if u[0] == 'CP'\n        end\n    when 'RL'\n        row, col = col.map {|c| N + 1 - c}, row\n        update.each do |u|\n            u[1], u[2] = N + 1 - u[2], u[1]\n            u[3], u[4] = N + 1 - u[4], u[3] if u[0] == 'CP'\n        end\n    when 'RR'\n        row, col = col, row.map {|r| N + 1 - r}\n        update.each do |u|\n            u[1], u[2] = u[2], N + 1 - u[1]\n            u[3], u[4] = u[4], N + 1 - u[3] if u[0] == 'CP'\n        end\n    when 'SR'\n        h = {i => j, j => i}\n        row.map! {|r| h[r] || r}\n        update.each do |u|\n            u[1] = h[u[1]] || u[1]\n            u[3] = h[u[3]] || u[3] if u[0] == 'CP'\n        end\n    when 'SC'\n        h = {i => j, j => i}\n        col.map! {|c| h[c] || c}\n        update.each do |u|\n            u[2] = h[u[2]] || u[2]\n            u[4] = h[u[4]] || u[4] if u[0] == 'CP'\n        end\n    end\nend\n\n\ntarget = []\nhash = {}\nrow.each do |r|\n    col.each do |c|\n        k = [r, c]\n        v = (A * r + B * c) % C\n        target << k\n        hash[k] = v\n    end\nend\n\nupdate.each do |c, i, j, x, y|\n    if c == 'WR'\n        hash[[i, j]] = x\n    else\n        hash[[x, y]] = (hash[[i, j]] ||= (A * i + B * j) % C)\n    end\nend\n\nh = 314159265\ntarget.each do |k|\n    h = (h * 31 + hash[k]) % 1_000_000_007\nend\np h"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    N, Q, A, B, C, D, E, F, G = map(int, readline().split())\n    d = 0; rx = 0; ry = 0\n    *X, = range(N)\n    *Y, = range(N)\n    def fc(d, x, y):\n        if d == 0:\n            return x, y\n        if d == 1:\n            return y, N-1-x\n        if d == 2:\n            return N-1-x, N-1-y\n        return N-1-y, x\n    mp = {}\n    for i in range(Q):\n        c, *g = readline().strip().split()\n        c0, c1 = c\n        if c0 == \"R\":\n            if c1 == \"L\":\n                d = (d - 1) % 4\n            elif c1 == \"R\":\n                d = (d + 1) % 4\n            elif c1 == \"H\":\n                if d & 1:\n                    rx ^= 1\n                else:\n                    ry ^= 1\n            else: #c1 == \"V\":\n                if d & 1:\n                    ry ^= 1\n                else:\n                    rx ^= 1\n        elif c0 == \"S\":\n            a, b = map(int, g); a -= 1; b -= 1\n            if c1 == \"R\":\n                if d & 1:\n                    if rx != ((d & 2) > 0):\n                        a = N-1-a; b = N-1-b\n                    X[a], X[b] = X[b], X[a]\n                else:\n                    if ry != ((d & 2) > 0):\n                        a = N-1-a; b = N-1-b\n                    Y[a], Y[b] = Y[b], Y[a]\n            else: #c1 == \"C\":\n                if d & 1:\n                    if ((d & 2) == 0) != ry:\n                        a = N-1-a; b = N-1-b\n                    Y[a], Y[b] = Y[b], Y[a]\n                else:\n                    if ((d & 2) > 0) != rx:\n                        a = N-1-a; b = N-1-b\n                    X[a], X[b] = X[b], X[a]\n        elif c0 == \"C\": #c == \"CP\":\n            y1, x1, y2, x2 = map(int, g); x1 -= 1; y1 -= 1; x2 -= 1; y2 -= 1\n            x1, y1 = fc(d, x1, y1)\n            x2, y2 = fc(d, x2, y2)\n            if rx:\n                x1 = N-1-x1; x2 = N-1-x2\n            if ry:\n                y1 = N-1-y1; y2 = N-1-y2\n            key1 = (X[x1], Y[y1]); key2 = (X[x2], Y[y2])\n            if key1 not in mp:\n                xa, ya = key1\n                mp[key2] = (ya*A + xa*B + A + B) % C\n            else:\n                mp[key2] = mp[key1]\n        else: #c == \"WR\":\n            y, x, v = map(int, g); x -= 1; y -= 1\n            x, y = fc(d, x, y)\n            if rx:\n                x = N-1-x\n            if ry:\n                y = N-1-y\n            key = (X[x], Y[y])\n            mp[key] = v\n    MOD = 10**9 + 7\n    h = 314159265\n    for y in range(D-1, E):\n        for x in range(F-1, G):\n            x0, y0 = fc(d, x, y)\n            if rx:\n                x0 = N-1-x0\n            if ry:\n                y0 = N-1-y0\n            x0 = X[x0]; y0 = Y[y0]\n            key = (x0, y0)\n            if key in mp:\n                v = mp[key]\n            else:\n                v = ((y0+1)*A + (x0+1)*B) % C\n            h = (31 * h + v) % MOD\n    write(\"%d\\n\" % h)\nsolve()\n"
  }
]