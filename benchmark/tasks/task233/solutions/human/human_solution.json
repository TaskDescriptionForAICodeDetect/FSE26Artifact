[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int MAX = 2000;\nconst int MAX2 = 1000000;\nint n,m,G[MAX][MAX];\nbool isPrime[MAX2+1];\nP pos[MAX2+1];\n\nvoid makeP(){\n  fill(isPrime, isPrime+MAX2+1, true);\n  isPrime[0] = isPrime[1] = false;\n  for(int i=2;i<=MAX2;i++){\n    if(isPrime[i]){\n      for(int j=i*2;j<=MAX2;j+=i) isPrime[j] = false;\n    }\n  }\n}\n\nvoid makeG(){\n  int y = MAX / 2, x = MAX / 2, step = 0;\n  fill(G[0],G[MAX],0);\n  for(int i=1;i<=MAX2;){\n    for(int j=0;j<4;j++){\n      if(j % 2 == 0) step++;\n      for(int k=0;k<step;k++){\n        pos[i] = P(x,y);\n        G[y][x] = i++;\n        if(j == 0) x++;\n        if(j == 1) y--;\n        if(j == 2) x--;\n        if(j == 3) y++;\n      }\n    }\n  }\n}\n\nbool check(int y, int x){\n  if(y < 0 || y >= MAX) return false;\n  if(x < 0 || x >= MAX) return false;\n  if(G[y][x] > m) return false;\n  return true;\n}\n\nint dp[MAX][MAX], dp2[MAX][MAX];\n\nvoid solve(){\n  int ans=0, ans2=0;\n  fill(dp[0],dp[MAX],-1);\n  fill(dp2[0],dp2[MAX],0);\n  dp[pos[n].second][pos[n].first] = isPrime[n];\n  if(isPrime[n]) dp2[pos[n].second][pos[n].first] = n;\n\n  for(int i=pos[n].second;i<MAX;i++){\n    for(int j=0;j<MAX;j++){\n      if(dp[i][j] == -1) continue;\n      if(i == MAX - 1){\n        if(ans < dp[i][j]){\n          ans = dp[i][j];\n          ans2 = dp2[i][j];\n        } else if(ans == dp[i][j]) ans2 = max(ans2, dp2[i][j]);\n        continue;\n      }\n\n      for(int k=-1;k<=1;k++){\n        int ny = i + 1;\n        int nx = j + k;\n        if(check(ny,nx)){\n          if(dp[ny][nx] < dp[i][j] + isPrime[G[ny][nx]]){\n            dp[ny][nx] = dp[i][j] + isPrime[G[ny][nx]];\n            if(isPrime[G[ny][nx]]) dp2[ny][nx] = G[ny][nx];\n            else dp2[ny][nx] = dp2[i][j];\n          } else if(dp[ny][nx] == dp[i][j] + isPrime[G[ny][nx]]){\n            if(isPrime[G[ny][nx]]) dp2[ny][nx] = max(dp2[ny][nx], G[ny][nx]);\n            else dp2[ny][nx] = max(dp2[ny][nx], dp2[i][j]);\n          }\n        } else {\n          if(ans < dp[i][j]){\n            ans = dp[i][j];\n            ans2 = dp2[i][j];\n          } else if(ans == dp[i][j]) ans2 = max(ans2, dp2[i][j]);\n        }\n      }\n    }\n  }\n\n  cout << ans << ' ' << ans2 << endl;\n}\n\nint main(){\n  makeP();\n  makeG();\n  while(cin >> m >> n && (n|m)) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> P;\n#define F first\n#define S second\nint fie[1111][1111];\nint N,M;\nint sosu[1000001];\nP mie[1000001];\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\n\nP dp[1111][1111];\nint ndx[]={1,0,-1};\nP solve(int x,int y,int ss){\n  if(dp[x][y].F!=-1 && dp[x][y].S!=-1) return dp[x][y];\n  if(fie[x][y]>N ||  fie[x][y] == -1 ){\n    return P(0,ss);\n  }\n  if(!sosu[fie[x][y]]) ss = fie[x][y];\n  P ret = P(0,0);\n  for(int i=0;i<3;i++){\n    int nx = x+ndx[i];\n    int ny = y+1;\n    P state = solve(nx,ny,ss);\n    ret = max(ret,state);\n  }\n  if(!sosu[fie[x][y]]) ret.F++;\n  // printf(\"%d dp[%d][%d] =  %d, %d fie=%d\\n\",ss,x,y,ret.F,ret.S,fie[x][y]);\n  return dp[x][y] = ret;\n}\n\nint main(){\n  sosu[1]=1;\n  for(int i=2;i<=1000000;i++){\n    if(!sosu[i]){\n      for(int j=i+i;j<=1000000;j+=i){\n\tsosu[j]=1;\n      }\n    }\n  }\n  for(int i=0;i<1111;i++)\n    for(int j=0;j<1111;j++)\n      dp[i][j]=P(-1,-1);\n  memset(fie,-1,sizeof(fie));\n\n\n  int x = 1111/2,y = 1111/2;\n  int id = 1, ic = 0;\n  //printf(\"%d %d\\n\",x,y);\n  fie[x][y]=1;\n  x += dx[ic]; y += dy[ic];\n\n \n  while( id < 1000000 ){\n    id++;\n    fie[x][y]=id;\n    mie[id] = P(x,y);\n    //if(id==1000000) printf(\"%d %d %d\\n\",id,x,y);\n    //    if(!sosu[fie[x][y]]) if(id<1000) printf(\"sosu::%d %d %d\\n\",id,x,y);\n    int nc = (ic+1)%4;\n    int nx = x+dx[nc], ny = y+dy[nc];\n    if( fie[nx][ny] == -1 ){\n      x = nx; y=ny;\n      ic=nc;\n    } else {\n      x = x + dx[ic]; y = y + dy[ic];\n    }\n  }\n\n\n  /*  for(int i=550;i<560;i++){\n    for(int j=550;j<560;j++){\n      printf(\"%3d \",fie[j][i]);\n    }\n    puts(\"\");\n  }\n  */\n\n  while(1){\n    for(int i=0;i<1111;i++)\n      for(int j=0;j<1111;j++)\n\tdp[i][j]=P(-1,-1);\n    \n    cin >> N >> M;\n    if(!N && !M) break;\n    //    printf(\"%d %d\\n\",mie[N].F,mie[N].S);\n    P res = solve(mie[M].F,mie[M].S,-1);\n    /*    if(sosu[fie[mie[M]][Mie[M]]]){\n      res.F ++;\n      }*/\n    if(res.S == -1)\n      printf(\"%d %d\\n\",0,0);\n    /*  } else {\n\tif( !sosu[fie[mie[M].F][mie[M].S]] ){\n\tif( res.F==0 ){\n\t  printf(\"%d %d\\n\",1,fie[mie[M].F][mie[M].S]);\n\t  } else \n\t  printf(\"%d %d\\n\",res.F+1,res.S);\n\t  }*/\n    else\n      printf(\"%d %d\\n\",res.F,res.S);\n    \n  }\n  \n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst i64 MOD = 1e9+7;\n\nconst i64 INF = i64(1e18)+MOD;\n\ntemplate <typename T = i64>\nstruct Range{\n    struct iterator{\n        T value;\n        const T step, last;\n        const T& operator*(){return value;}\n        iterator(T value, T step, T last) :\n            value(step < static_cast<T>(0) ? max(last, value) : min(last, value)),\n            step(step),\n            last(last)\n        {\n        }\n        iterator operator++(){value = step < static_cast<T>(0) ? max(value + step, last) : min(value + step, last); return *this;}\n        bool operator!=(const iterator& x){return value != x.value;}\n    };\n    const T start, last, step;\n\n    Range(const T start, const T last, const T step = static_cast<T>(1)) :\n        start(start),\n        last(last),\n        step(step)\n    {\n    }\n\n    Range(const T last) :\n        start(0),\n        last(last),\n        step(1)\n    {\n    }\n\n    iterator begin(){return iterator(start, step, last);}\n    iterator end(){return iterator(last, step, last);}\n};\n\ntemplate <typename F>\nstruct FixPoint{\n    const F _f;\n    FixPoint(F&& f) : _f(forward<F>(f)){}\n\n    template<typename... Types>\n    decltype(auto) operator()(Types&&... args) const{\n        return _f(*this, forward<Types>(args)...);\n    }\n};\n\ntemplate <typename F>\nstatic decltype(auto) makeRec(F&& f){\n    return FixPoint<F>(forward<F>(f));\n}\n\ntemplate <typename T, T Value = T()>\nvector<T> makeVector(size_t x){\n    return vector<T>(x, T(Value));\n}\n\ntemplate <typename T, T Value = T(), typename... Types>\nauto makeVector(size_t x, Types... args){\n    return vector<decltype(makeVector<T, Value>(args...))>(x, makeVector<T, Value>(args...));\n}\n\ntemplate <typename T = i64>\nbool chmax(T& a, T b){\n    if(a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T = i64>\nbool chmin(T& a, T b){\n    if(a > b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define dump(x) fprintf(stderr, \"line =%4d, name =%7s , \", __LINE__, #x); clog << \"value = \" << x << endl;\n\n#define vecdump(x) fprintf(stderr, \"line =%4d, name =%7s\\n\", __LINE__, #x); _dump_macro(x);\n\nvoid _dump(int, string& x){\n    clog << x << endl;\n}\n\ntemplate <typename T>\nvoid _dump(bool, T& x){\n    clog << x << \" \";\n}\n\ntemplate <typename T, typename U = typename T::iterator>\nvoid _dump(int, T& x){\n\n    for(auto& elm : x)\n        _dump(0, elm);\n\n    clog << endl;\n}\n\ntemplate <typename T>\nvoid _dump_macro(T& x){\n    _dump(0, x);\n}\n\nvoid _input(int, string& x){\n    cin >> x;\n}\n\ntemplate <typename T>\nvoid _input(bool, T& x){\n    cin >> x;\n}\n\ntemplate <typename T, typename U = typename T::iterator>\nvoid _input(int, T& x){\n\n    for(auto& elm : x)\n        _input(0, elm);\n}\n\ntemplate <typename T>\nvoid input_single(T& x){\n    _input(0, x);\n}\n\nauto input(){}\n\ntemplate <typename T, typename... Types>\nvoid input(T& value, Types&&... args){\n    input_single(value);\n    input(forward<Types>(args)...);\n};\n\nvoid _pararell_input(size_t){}\n\ntemplate <typename T, typename... Types>\nvoid _pararell_input(size_t index, T& value, Types&&... args){\n    input(value[index]);\n    _pararell_input(index, forward<Types>(args)...);\n}\n\ntemplate <typename... Types>\nvoid pararell_input(size_t count, Types&&... args){\n    for(const auto& i : Range<>(count))\n        _pararell_input(i, forward<Types>(args)...);\n}\n\n\nbool solve(){\n\n    int n, m;\n    input(m, n);\n    if(!m)\n        return false;\n\n    auto eratosthenes = []{\n        constexpr int N = 1e6+5;\n        bitset<N> not_prime(3);\n        for(int i = 2; i < N; ++i)\n            if(!not_prime[i])\n                for(int j = 2 * i; j < N; j += i)\n                    not_prime.set(j);\n        return not_prime;\n    };\n\n    static auto prime(eratosthenes().flip());\n\n    vector<pair<pair<int,int>, int>> s;\n    int x = 0, y = 0, d = 0;\n    int sx = 0, ex = 0, sy = 0, ey = 0;\n    vector<int> dx{1, 0, -1, 0};\n    vector<int> dy{0, -1, 0, 1};\n    int p = 1000;\n    int q = p / 2;\n    int h = p, w = p;\n    vector<vector<int>> v(h, vector<int>(w, 0));\n    int tx, ty;\n    for(int i = 1; i <= m; ++i){\n        if(i != 1){\n            x += dx[d];\n            y += dy[d];\n        }\n        if(prime[i])\n            v[y + q][x + q] = i;\n        if(i == n){\n            tx = y + q;\n            ty = x + q;\n        }\n        if(ex < x)\n            ++ex, ++d;\n        else if(x < sx)\n            --sx, ++d;\n        else if(ey < y)\n            ++ey, d = 0;\n        else if(y < sy)\n            --sy, ++d;\n    }\n\n    vector<vector<int>> dp(h, vector<int>(w, -MOD));\n    dp[tx][ty] = bool(v[tx][ty]);\n    pair<int, int> ans{0, 0};\n    for(int i = 0; i < h; ++i){\n        for(int j = 0; j < w; ++j){\n            if(dp[i][j] == -MOD)\n                continue;\n            if(v[i][j])\n                chmax(ans, make_pair(dp[i][j], v[i][j]));\n            if(i == h - 1)\n                continue;\n            if(j != w - 1)\n                chmax(dp[i + 1][j + 1], dp[i][j] + bool(v[i + 1][j + 1]));\n            if(j)\n                chmax(dp[i + 1][j - 1], dp[i][j] + bool(v[i + 1][j - 1]));\n            chmax(dp[i + 1][j], dp[i][j] + bool(v[i + 1][j]));\n        }\n    }\n\n    cout << ans.first << \" \" << ans.second << endl;\n\n    return true;\n}\n\nsigned main(){\n\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    while(solve());\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define SIZE 1000\n\nbool C(int dp1, int pr1, int dp2, int pr2) {\n\tif (dp2 == 0)return false;\n\tif (dp1 < dp2 || (dp1 == dp2&&pr1 < pr2))return true;\n\treturn false;\n}\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool complete;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1;i <= SIZE&&a<=SIZE*SIZE;i++) {\n\t\tfor (int j = 0;j < i&&a<=SIZE*SIZE;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\tif (i % 2 == 0)x--;\n\t\t\telse x++;\n\t\t\ta++;\n\t\t}\n\t\tfor (int j = 0;j < i&&a<=SIZE*SIZE;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t\ta++;\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\tcomplete = false;\n\t\twhile (!complete) {\n\t\t\twhile (x >= 0 && !complete) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x - 1], pr[y + 1][x - 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x], pr[y + 1][x])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x + 1], pr[y + 1][x + 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (table[y][x] == n)complete = true;\n\t\t\t\telse x--;\n\t\t\t}\n\t\t\tif (!complete) {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define SIZE 1000\n\nbool C(int dp1, int pr1, int dp2, int pr2) {\n\tif (dp2 == 0)return false;\n\tif (dp1 < dp2 || (dp1 == dp2&&pr1 < pr2))return true;\n\treturn false;\n}\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i <= SIZE&&a <= SIZE*SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x - 1], pr[y + 1][x - 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x], pr[y + 1][x])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x + 1], pr[y + 1][x + 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\n\t\toutput = false;\n\t\tfor (int i = 0;i < SIZE&&!output;i++) {\n\t\t\tfor (int j = 0;j < SIZE&&!output;j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tprintf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define reps(i,j,k) for(int i=(j);i<(k);i++)\n#define rep(i,j) reps(i,0,j)\n#define fs first\n#define sc second\n#define pb push_back\n#define mk make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntemplate<class S,class T>\nostream &operator<<(ostream &out, const pair<S,T> &p){\n\treturn out << \"(\" << p.fs << \", \" << p.sc << \")\";\n}\ntemplate<class T>\nostream &operator<<(ostream &out, const vector<T> &v){\n\tout << \"{\";\n\trep(i,v.size()) out << v[i] << \", \";\n\treturn out << endl;\n}\n#define M 2001\n#define P 3000001\nbool prime[P];\npii sp[M][M]; //isprime, num\nint dx[] = {1,0,-1,0}, dy[] = {0,-1,0,1};\npii board[M][M]; //score, maxprime\n\npii bfs(int m, int x, int y, pii r){\n\tif(sp[x][y].sc > m) return r;\n\tr = pii(r.fs + sp[x][y].fs, max(r.sc, sp[x][y].sc));\n\trep(i,3){\n\t\tint cx = x+i-1, cy = y+1;\n//\t\tboard[cx][cy] = pii(board[x][y].fs + sp[])\n\t}\n}\n\npii add(pii x, pii y){\n\n\treturn pii(x.fs + y.fs, y.sc);\n}\n\nint main(){\n\tint m,n;\n\tprime[0]=prime[1]=1;\n\treps(i,2,P){\n\t\tif(!prime[i])\n\t\t\tfor(int j=2*i;j<P;j+=i) prime[j] = 1;\n\t}\n\n\tvector<pii> pos(P);\n\tint cx = M/2, cy = M/2;\n\tint dist = 1, cnt = 0, way = 0;\n\tfill(sp[0],sp[M],pii(0,999999999));\n\treps(i,1,P){\n\t\tpos[i] = pii(cx,cy);\n\t\tsp[pos[i].fs][pos[i].sc] = pii(!prime[i],i);\n\t\tif(cnt == dist){\n\t\t\tif(way % 2 == 1) dist++;\n\t\t\tcnt = 0;\n\t\t\tway = (way + 1) & 3;\n\t\t}\n\t\tcnt++;\n\t\tcx+=dx[way];\n\t\tcy+=dy[way];\n\t}\n\n//\treps(i,1,26) cout << mk(i,pos[i]) << endl;\n//\tcout << pos[1000000] << endl;\n\t\n\twhile(cin >> m >> n, m){\n\t\tfill(board[0], board[M], pii(0,0));\n\t\tint sq = 1;\n\t\twhile(sq * sq <= m) sq++;\n\t\tint y = pos[n].sc, x = pos[n].fs;\n//\t\tcout << pii(x,y) << endl;\n//\t\tcout << sp[x][y] << endl;\n\t\tpii ans = board[x][y] = prime[n]?pii(0,0):pii(1,n);\n\t\trep(i,sq){\n\t\t\tif(i+y>M)break;\n\t\t\treps(j,x-i,x+i+1){\n\t\t\t\tif(j >= M || j < 0 || sp[j][i+y].sc > m)continue;\n//\t\t\t\tcout << mk(pii(j,i+y),sp[j][i+y]);\n\t\t\t\trep(k,3){\n\t\t\t\t\tint nx = j+k-1;\n\t\t\t\t\tint ny = i+y+1;\n\t\t\t\t\tif(sp[nx][ny].sc > m)continue;\n\t\t\t\t\tif(sp[nx][ny].fs)\n\t\t\t\t\t\tboard[nx][ny] = max(board[nx][ny], add(board[j][ny-1], sp[nx][ny]));\n\t\t\t\t\telse\n\t\t\t\t\t\tboard[nx][ny] = max(board[nx][ny], board[j][ny-1]);\n\n\t\t\t\t\tans = max(board[nx][ny], ans);\n\t\t\t\t}\n//\t\t\t\tcout << mk(sp[j][i+y].sc, board[j][i+y]);\n\t\t\t}\n//\t\t\tcout << endl;\n\t\t}\n\n\t\tcout << ans.fs << \" \" << ans.sc << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nstatic const int N = 1010;\n\nvector<pair<int, int>> guruguru(vector<vector<int>>& field, int n_inputs, const unordered_map<int, int>& pos2id)\n{\n    static int dy[] = { 0, -1, 0, 1 };\n    static int dx[] = { 1, 0, -1, 0 };\n    int h = field.size();\n    int w = field[0].size();\n    int y = h / 2;\n    int x = w / 2;\n    int dir = 0;\n    int i = 1;\n    int a = 0;          // 譛蠕後↓譖イ縺後▲縺ヲ縺九ｉ縺ョ豁ゥ謨ー\n    int b = 1;          // 谺。縺ォ譖イ縺後ｋ縺セ縺ァ縺ョ豁ゥ謨ー\n    int c = 0;          // 譛蠕後↓ b 縺悟「励∴縺ヲ縺九ｉ縺ョ譖イ縺後▲縺溷屓謨ー\n    vector<pair<int, int>> starts(n_inputs);\n\n    while (0 <= y && y < h && 0 <= x && x < w) {\n        field[y][x] = i;\n        auto it = pos2id.find(i);\n        if (it != pos2id.end()) {\n            starts[it->second] = make_pair(y, x);\n        }\n\n        ++i;\n        y += dy[dir];\n        x += dx[dir];\n        ++a;\n        if (a == b) {\n            dir = (dir + 1) % 4;\n            a = 0;\n            ++c;\n            if (c == 2) {\n                ++b;\n                c = 0;\n            }\n        }\n    }\n\n    return move(starts);\n}\n\nvector<bool> sieve(int n)\n{\n    vector<bool> prime(n + 1, true);\n    prime[0] = prime[1] = false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (prime[i]) {\n            for (int j = i * i; j <= n; j += i)\n                prime[j] = false;\n        }\n    }\n    return move(prime);\n}\n\nint main()\n{\n    vector<pair<int, int>> inputs;\n    unordered_map<int, int> pos2id;\n    int m, n;\n    for (int i = 0; cin >> m >> n, m | n; ++i) {\n        inputs.emplace_back(m, n);\n        pos2id[n] = i;\n    }\n\n    vector<vector<int>> field(N, vector<int>(N));\n    const auto starts = guruguru(field, inputs.size(), pos2id);\n    const auto prime = sieve(N * N);\n\n    for (int t = 0; t < (int)inputs.size(); ++t) {\n        pair<int, int> ans;\n        vector<vector<pair<int, int>>> dp(N, vector<pair<int, int>>(N, make_pair(-10000, 0)));\n        int sy = starts[t].first;\n        int sx = starts[t].second;\n        ans = dp[sy][sx] = make_pair(prime[field[sy][sx]], (prime[field[sy][sx]] ? field[sy][sx] : 0));\n        for (int y = sy + 1; y < N; ++y) {\n            for (int x = 1; x < N - 1; ++x) {\n                if (field[y][x] > inputs[t].first)\n                    continue;\n                auto prev = max(dp[y-1][x-1], max(dp[y-1][x], dp[y-1][x+1]));\n                if (prime[field[y][x]]) {\n                    dp[y][x] = make_pair(prev.first + 1, field[y][x]);\n                } else {\n                    dp[y][x] = prev;\n                }\n                ans = max(ans, dp[y][x]);\n            }\n        }\n\n        cout << ans.first << ' ' << ans.second << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1000011\nusing namespace std;\nint mp[2000][2000];\nint dx[]={1,0,-1,0},dy[]={0,-1,0,1};//>, ^,<,v\nbool prime[N];\n\nvoid mk_mp(){\n  mp[1000][1000]=1;  \n  int x=1001,y=1000,dir=0,num=2;\n  while(num<N+N){\n    mp[y][x]=num;\n    int ndir=(dir+1)%4,nx=x+dx[ndir],ny=y+dy[ndir];\n    if(mp[ny][nx]==0) dir=ndir;\n    else x+=dx[dir],y+=dy[dir],num++;\n  }\n}\n\ntypedef pair<int,int> P;\nint n,m;\nP mem[2000][2000];\nint used[2000][2000];\nP dfs(int y,int x){\n  if(mp[y][x]>m)return P(0,0);\n  if(used[y][x]++) return mem[y][x];\n  P res=max(dfs(y+1,x-1),max(dfs(y+1,x),dfs(y+1,x+1)));\n  if(!prime[mp[y][x]]){\n    res.first++;\n    if(res.second==0)res.second=mp[y][x];\n  }\n  return mem[y][x]=res;\n}\n\n\nint main(){\n  prime[0]=prime[1]=1;\n  for(int i=2;i*i<N;i++)\n    if(!prime[i])\n      for(int j=2;j<=N/i;j++) prime[i*j]=1;\n  mk_mp();\n  while(1){\n    cin>>m>>n;\n    if(!n&&!m)return 0;\n    memset(used,0,sizeof(used));\n    int x=-1,y=-1;\n    for(int i=0;i<2000&&x==-1;i++)\n      for(int j=0;j<2000&&x==-1;j++)if(mp[i][j]==n)x=j,y=i ;\n    P ans=dfs(y,x);\n    cout <<ans.first<<\" \"<<ans.second<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nusing namespace std;\n  \n#define MP make_pair\n#define PB push_back\n#define MAX_N 1001000\n#define SIZE 2010\n#define X first\n#define Y second\n  \nconst int STX = 1000, STY = 1000;\n  \nint id[SIZE][SIZE];\nbool is_prime[MAX_N+1];\nvector<pair<int, int> > coord;\n\nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++) {\n    if(is_prime[i]) {\n      for(int j=i*i; j<=MAX_N; j+=i) {\n\tis_prime[j] = false;\n      }\n    }\n  }\n}\n\nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  \n  coord.PB(MP(0, 0)); // no use\n  cnt ++;\n  coord.PB(MP(x, y)); // cnt = 1\n  \n  fill(id[0], id[0]+SIZE*SIZE+1, -1);\n  \n  const int dx[] = {0,-1,0,1};\n  const int dy[] = {-1,0,1,0};\n  \n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt <= MAX_N) {\n    a += 2;\n    for(int turn=0; turn<4; turn++) {\n      for(int i=0; i<a; i++) {\n\tx += dx[turn], y += dy[turn];\n\tcoord.PB(MP(x, y));\n\tid[y][x] = ++ cnt;\n      }\n    }\n    x++, y++;\n  }\n}\n\nint dp[MAX_N+1];\n\nint main() {\n  \n  Sieve();\n  MakeMap();\n  \n  int m, n;\n    \n  while(cin >> m >> n && (m|n)) {\n    \n    bool ok = false;\n    \n    fill(dp, dp+MAX_N+1, -1);\n    dp[n] = is_prime[n];\n    \n    queue<pair<int, int> > que;\n    que.push(coord[n]);\n    \n    while(!que.empty()) {\n      pair<int, int> now = que.front(); que.pop();\n      int noid = id[now.Y][now.X];\n      \n      for(int i=-1; i<=1; i++) {\n\tpair<int, int> nex = MP(now.X+i, now.Y+1);\n\tif(nex.X < 0 || SIZE <= nex.X || nex.Y < 0 || SIZE <= nex.Y) continue;\n\tint neid = id[nex.Y][nex.X];\n\tif(neid <= m) {\n\t  if(dp[neid] < dp[noid] + is_prime[neid]) {\n\t    dp[neid] = dp[noid] + is_prime[neid];\n\t    if(is_prime[neid]) ok = true;\n\t    que.push(nex);\n\t  }\n\t}\n      }\n    }\n    \n    int res = dp[n], lastid = -1;\n    if(is_prime[n]) lastid = n;\n    \n    for(int i=1; i<=m; i++) {\n      if(res <= dp[i] && is_prime[i]) {\n\tres = dp[i];\n\tlastid = max(lastid, i);\n      }\n    }\n    \n    if(!ok) cout << \"0 0\" << endl;\n    else cout << res << \" \" << lastid << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint s[1000][1000];\nint dp[1000][1000];\nint p[1000][1000];\n\npair<int, int> get_pos(int n) {\n        if (n == 1) return make_pair(500, 499);\n        int top_left = 1;\n        int k = 1;\n        while (n > top_left) {\n                top_left = (2 * k) * (2 * k);\n                k ++;\n        }\n        k --;\n        int top_right = top_left - 2 * k + 1;\n        int bottom_right = top_right - 2 * k + 1;\n        int bottom_left = bottom_right - 2 * k + 1;\n        int y, x;\n        if (n <= bottom_left) {\n                y = 499 - k + 1 + (2 * k - 1 - (bottom_left - n));\n                x = 499 - k + 1;\n        } else if (n <= bottom_right) {\n                y = 499 + k;\n                x = 499 - k + 1 + (n - bottom_left);\n        } else if (n <= top_right) {\n                y = 499 - k + 1 + (top_right - n);\n                x = 499 + k;\n        } else { \n                y = 499 - k + 1;\n                x = 499 - k + 1 + (top_left - n);\n        }\n        p[y][x] = n;\n        return make_pair(y, x);\n}\n\n//N??\\???????´???°?????????O(N log log N)\nint N = 1000000;\nvector<int> primes;\nvector<bool> is_prime(N + 1, true);\nvoid init() {\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 2; i <= N; i ++) {\n                if (is_prime[i]) {\n                        primes.push_back(i);\n                        for (int j = i + i; j <= N; j += i) is_prime[j] = false;\n                }\n        }\n}\n\nint main() {\n        init();\n        int m, n;\n        while (scanf(\"%d%d\", &m, &n) && n) {\n                for (int i = 0; i < 1000; i ++) for (int j = 0; j < 1000; j ++) s[i][j] = 0;\n                for (auto p : primes) {\n                        if (p > m) break;\n                        int y, x;\n                        tie(y, x) = get_pos(p);\n                        s[y][x] = 1;\n                }\n                int dp[1000][1000] = { 0 };\n                int sy, sx;\n                tie(sy, sx) = get_pos(n);\n                dp[sy][sx] = s[sy][sx];\n                for (int dy = 0; sy + dy + 1 < 1000; dy ++) {\n                        for (int dx = -dy; dx <= dy && sx + dx < 1000; dx ++) {\n                                dp[sy + dy + 1][sx + dx - 1] = max(dp[sy + dy + 1][sx + dx - 1], s[sy + dy + 1][sx + dx - 1] + dp[sy + dy][sx + dx]);\n                                dp[sy + dy + 1][sx + dx]     = max(dp[sy + dy + 1][sx + dx]    , s[sy + dy + 1][sx + dx]     + dp[sy + dy][sx + dx]);\n                                dp[sy + dy + 1][sx + dx + 1] = max(dp[sy + dy + 1][sx + dx + 1], s[sy + dy + 1][sx + dx + 1] + dp[sy + dy][sx + dx]);\n                        }\n                }\n                int ans = 0;\n                for (int i = 0; i < 1000; i ++) {\n                        for (int j = 0; j < 1000; j ++) {\n                                ans = max(ans, dp[i][j]);\n                        }\n                }\n                if (ans == 0) { \n                        cout << 0 << ' ' << 0 << endl;\n                        continue;\n                }\n                int res = -1;\n                for (int i = 0; i < 1000; i ++) {\n                        for (int j = 0; j < 1000; j ++) {\n                                if (dp[i][j] == ans && s[i][j]) {\n                                        res = max(res, p[i][j]);\n                                }\n                        }\n                }\n                cout << ans << ' ' << res << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int CAVEL = 1003;\nconst int NMAX = (int)1e6;\n\nint cave[CAVEL][CAVEL];\nbool prime[NMAX];\n\nvoid mkCave(){\n    int x, y;\n    x = y = CAVEL / 2;\n    int n = 1;\n    FOR(i, 1, NMAX+1){\n        REP(j, n) {\n            cave[y][x] = i++;\n            x++;\n        }\n        REP(j, n) {\n            cave[y][x] = i++;\n            y--;\n        }\n        n++;\n        REP(j, n) {\n            cave[y][x] = i++;\n            x--;\n        }\n        REP(j, n) {\n            cave[y][x] = i++;\n            y++;\n        }\n        n++;\n        i--;\n    }\n}\n\npii find_pos(const int n){\n    REP(y, CAVEL)\n        REP(x, CAVEL)\n            if(cave[y][x] == n)\n                return {x, y};\n}\n\nint main() {\n    fill_n((bool *)prime, NMAX, true);\n    prime[0] = prime[1] = false;\n    FOR(i, 2, NMAX)\n        if(prime[i])\n            for (int j = i * 2; j < NMAX; j += i)\n                prime[j] = false;\n\n    mkCave();\n\n    int table[CAVEL];\n    int table_bak[CAVEL];\n\n    int cavelim, into;\n    while(cin >> cavelim >> into, cavelim|into){\n        fill_n((int *)table, CAVEL, -1);\n        fill_n((int *)table_bak, CAVEL, -1);\n\n        pii p = find_pos(into);\n        int X = p.first, Y = p.second;\n\n        table[X] = 0;\n\n        pii res = {0, 0};\n        bool endflg = false;\n        FOR(y, Y, CAVEL) {\n            if (endflg) break;\n            endflg = true;\n            REP(x, CAVEL) {\n                if (cave[y][x] > cavelim) {\n                    continue;\n                }\n                endflg = false;\n\n                if (table[x] != -1) {\n//                    LOG(\"%d %d = %d %d\\n\",x,y,cave[y][x],prime[cave[y][x]]);\n                    if (prime[cave[y][x]]) table[x]++;\n                    FOR(d, -1, 1 + 1) {\n                        if (x + d >= 0 && cave[y][x + d]) {\n                            if(prime[cave[y][x]])\n                                res = max(res, (pii) {table[x], cave[y][x]});\n                            table_bak[x + d] = max(table[x], table_bak[x + d]);\n                        }\n                    }\n                }\n            }\n\n            REP(x, CAVEL)\n                table[x] = table_bak[x];\n        }\n\n        if(res.first == 0)\n            cout << \"0 0\" << endl;\n        else\n            cout <<res.first << \" \" << res.second << endl;\n    }\n\n    //print prime\n    /*\n    REP(i, NMAX){\n        cout << i<<\" \" << prime[i] << endl;\n    }\n     */\n\n     //print cave\n    /*\n    FOR(y, CAVEL-5, CAVEL) {\n        FOR(x, CAVEL - 5, CAVEL) {\n            LOG(\"%d\", cave[y][x]);\n        }\n        cout << endl;\n    }\n     */\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<list>\n#include<queue>\n#include<cmath>\n#include<map>\n#include<functional>\n#include<algorithm>\nusing namespace std;\n\n\n#define MAX_N 1000000\nbool is_prime[MAX_N+1];\nvoid sieve(int n){\n\tmemset(is_prime,true,sizeof(is_prime));\n\tis_prime[0]=is_prime[1]=false;\n\tfor(int i=2;i<=n;i++){\n\t\tif(is_prime[i]){\n\t\t\tfor(int j=2*i;j<=n;j+=i)is_prime[j]=false;\n\t\t}\n\t}\n}\n\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\n\nmap<pair<int,int>,int> num;\n\npair<int,int> create(int m,int n){\n\tpair<int,int> res;\n\tint p=1,x=0,y=0;\n\tnum.clear();\n\tfor(int i=0;p<=m;i++){\n\t\tfor(int j=0;j<i/2+1&&p<=m;j++){\n\t\t\tif(p==n)res=make_pair(x,y);\n\t\t\tnum[make_pair(x,y)]=p++;\n\t\t\tx+=dx[i%4];\n\t\t\ty+=dy[i%4];\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tsieve(MAX_N);\n\tint m,n;\n\twhile(cin>>m>>n,m||n){\n\t\tmap<pair<int,int>,pair<int,int> > cur,next;\n\t\tmap<pair<int,int>,pair<int,int> >::iterator it;\n\t\tpair<int,int> s=create(m,n);\n\t\tpair<int,int> ans;\n\t\tif(is_prime[n])cur[s]=make_pair(1,n);\n\t\telse cur[s]=make_pair(0,0);\n\t\tans=cur[s];\n\t\twhile(!cur.empty()){\n\t\t\tfor(it=cur.begin();it!=cur.end();++it){\n\t\t\t\ts=it->first;\n\t\t\t\tfor(int i=-1;i<=1;i++){\n\t\t\t\t\tpair<int,int> t=make_pair(s.first+i,s.second+1);\n\t\t\t\t\tif(num.find(t)==num.end())continue;\n\t\t\t\t\tpair<int,int> val=it->second;\n\t\t\t\t\tif(is_prime[num[t]]){\n\t\t\t\t\t\tval.first++;\n\t\t\t\t\t\tval.second=num[t];\n\t\t\t\t\t}\n\t\t\t\t\tnext[t]=max(next[t],val);\n\t\t\t\t\tans=max(ans,val);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.swap(next);\n\t\t\tnext.clear();\n\t\t}\n\t\tcout<<ans.first<<' '<<ans.second<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\n#define MP make_pair\n#define PB push_back\n#define MAX_N 1000001\n#define SIZE 1001\n#define X first\n#define Y second\n\nconst int STX = 500, STY = 500;\n\nint id[SIZE][SIZE];\nbool is_prime[MAX_N+1];\nvector<pair<int, int> > coord;\n\nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++) {\n    if(is_prime[i]) {\n      for(int j=i*i; j<=MAX_N; j+=i) {\n\tis_prime[j] = false;\n      }\n    }\n  }\n}\n\nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  /*\n  const int dx[] = {1,0,-1,0};\n  const int dy[] = {0,-1,0,1};\n  */\n  coord.PB(MP(0, 0)); // no use\n  coord.PB(MP(x, y)); // cnt = 1\n  cnt ++;\n\n  fill(id[0], id[0]+SIZE*SIZE+1, -1);\n  \n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt < SIZE*SIZE) {\n    a += 2;\n    for(int i=0; i<a; i++) {\n      y --;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      x --;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      y ++;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      x ++;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    x++, y++;\n  }\n}\n\nint dp[MAX_N+1];\n\nint main() {\n  \n  Sieve();\n  MakeMap();\n  \n  int m, n;\n  \n  while(cin >> m >> n && (m|n)) {\n    fill(dp, dp+m+1, -1);\n    dp[n] = is_prime[n];\n    \n    queue<pair<int, int> > que;\n    que.push(coord[n]);\n    \n    while(!que.empty()) {\n      pair<int, int> now = que.front(); que.pop();\n      int noid = id[now.Y][now.X];\n      \n      for(int i=-1; i<=1; i++) {\n\tpair<int, int> nex = MP(now.X+i, now.Y+1);\n\tif(nex.X < 0 || SIZE-1 <= nex.X || nex.Y < 0 || SIZE-1 <= nex.Y) continue;\n\tint neid = id[nex.Y][nex.X];\n\tif(neid <= m) {\n\t  if(dp[neid] < dp[noid] + is_prime[neid]) {\n\t    dp[neid] = dp[noid] + is_prime[neid];\n\t    que.push(nex);\n\t  }\n\t}\n      }\n    }\n    \n    int res = dp[n], lastid = -1;\n    if(is_prime[n]) lastid = n;\n    \n    for(int i=1; i<=m; i++) {\n      if(res <= dp[i] && is_prime[i]) {\n\tres = dp[i];\n\tlastid = max(lastid, i);\n      }\n    }\n    \n    if(lastid == -1) cout << \"0 0\" << endl;\n    else cout << res << \" \" << lastid << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <complex>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<int(b); i++)\n#define rep(i,n) loop(i,0,n)\n#define all(c) (c).begin(), (c).end()\ntypedef complex<int> P;\n\nconst int MAX_M = 1.5e6+10;\nconst int SIZE = 2000;\nint ps[MAX_M/2];\nbool isp[MAX_M];\nint grid[SIZE][SIZE]={};\nP itop[MAX_M];\npair<int,int> dp[SIZE][SIZE];\n\nint cnt_p = 0;\n\nvoid make_es(){\n    fill(isp,isp+MAX_M,true);\n    isp[0]=isp[1]=false;\n    rep(i,MAX_M){\n        if(!isp[i]) continue;\n        ps[cnt_p++] = i;\n        for(int j=i<<1; j<MAX_M; j+=i){\n            isp[j] = false;\n        }\n    }\n}\n\nP const ii(0,1);\n\nint n,m;\n\npair<int,int> rec(int y, int x){\n    if(dp[y][x].first!=-1) return dp[y][x];\n\n    pair<int,int> res(0,0);\n    if(isp[grid[y][x]]){\n        res.first = 1;\n        res.second = grid[y][x];\n    }\n    pair<int,int> best(0,0);\n    loop(i,-1,2){\n        if(grid[y+1][x+i]<=m){\n            auto t = rec(y+1,x+i);\n            best = max(t,best);\n        }\n    }\n\n    if(best.first != 0){\n        res.first += best.first;\n        res.second = best.second;\n    }\n\n    dp[y][x] = res;\n    return res;\n}\n\nint main(){\n    make_es();\n\n    P p(SIZE/2,SIZE/2);\n    P dir(0,1);\n    for(int i=1; i<MAX_M; i++){\n        grid[p.real()][p.imag()] = i;\n        itop[i]=p;\n        p+=dir;\n        P q = p+dir*ii;\n        if(grid[q.real()][q.imag()] == 0){\n            dir*=ii;\n        }\n    }\n\n    while(cin>>m>>n, n+m){\n        auto t = make_pair(-1,-1);\n        rep(i,SIZE)rep(j,SIZE) dp[i][j] = t;\n\n        auto u = itop[n];\n        auto ans = rec(u.real(), u.imag());\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define pb push_back\ntypedef pair<int,int> pi;\n#define MAX 1000000\nint isprime[1145141];\nint table[2000][2000];\npi S[1145141];\nint D[2000][2000];\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,-1,0,1};\nvoid eratos(int n)\n{\n  rep(i,n+1)isprime[i]=true;\n  isprime[0]=isprime[1]=false;\n  for(int i=2;i*i<=n;i++)\n    {\n      if(isprime[i])\n\t{\n\t  int j = i + i;\n\t  while(j <= n)\n\t    {\n\t      isprime[j] = false;\n\t      j = j + i;\n\t    }\n\t}\n      \n    }\n  \n}\nint main(){\n  eratos(MAX);\n  //table turkuru\n  memset(table,0,sizeof(table));\n  int now = 2;\n  int dist = 1;\n  int cnt = 0;\n  int dir = 0;\n  int y = 1000;\n  int x = 1000;\n  table[y][x]=1;\n  S[1] = pi(y,x);\n  while(now <= MAX)\n    {\n      if(cnt < dist)\n\t{\n\t  y += dy[dir];\n\t  x += dx[dir];\n\t  table[y][x] = now;\n\t  S[now] = pi(y,x);\n\t  cnt++;\n\t  now++;\n\t}\n      else\n\t{\n\t  dir = (dir+1)%4;\n\t  if(dir == 2 || dir == 0)dist++;\n\t  y += dy[dir];\n\t  x += dx[dir];\n\t  table[y][x] = now;\n\t  S[now] = pi(y,x);\n\t  cnt = 1;\n\t  now++;\n\t}\n    }\n  /*rep(i,2000)\n    {\n      rep(j,2000)\n\t{\n\t  printf(\"%d \", table[i][j]);\n\t}\n\t    printf(\"\\n\");    \n\t    }*/\n  //cout << table[1000][1000]<< endl;\n  //cout << table[1001][1001] << endl;\n  int M, N;\n  int ans;\n  int pp;\n  int ey[3] = {1,1,1};\n  int ex[3] = {-1,0,1};\n  //printf(\"%d\", isprime[table[S[947].first][S[947].second]]);\n  while(true){\n    cin >> M >> N;\n    if(M==0&&N==0)break;\n    memset(D,-1,sizeof(D));\n    queue<pi> Q;\n    queue<int> R;\n    ans = 0;\n    pp = 0;\n    Q.push(pi(S[N].first,S[N].second));\n    //printf(\"%d %d\\n\", S[N].first,S[N].second);\n    R.push(0);\n    while(!R.empty())\n      {\n\tint ty = Q.front().first;\n\tint tx = Q.front().second;\n       \n\t\n\tint point = R.front();\n\tQ.pop();R.pop();\n\n\n\t\n\tif(isprime[table[ty][tx]])\n\t  {\n\t    point++;\n\t  }\n\tif(ans <= point)\n\t  {\n\t    if(ans < point && isprime[table[ty][tx]])pp = table[ty][tx];\n\t    else if(ans == point && isprime[table[ty][tx]])pp = max(table[ty][tx],pp);\n\t    ans = point;\n\t    \n\t  }\n\n\t//printf(\"ty=%d, tx=%d, point=%d\\n\",ty,tx,point);\n\t\n\tif(point <= D[ty][tx])continue;\n\tD[ty][tx] = point;\n\t//ans = max(ans,point);\n\trep(r,3)\n\t  {\n\t    int y = ty + ey[r];\n\t    int x = tx + ex[r];\n\t    \n\t    if(table[y][x]==0)continue;\n\t    if(table[y][x]>M)continue;\n\t    Q.push(pi(y,x));\n\t    R.push(point);\n\t  }\n\t\n      }\n    printf(\"%d %d\\n\", ans, pp);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nvector<ll> prime;\nbool isprime[1100000];\n\nvoid sieve(){\n\tfor(ll i=0; i<1100000; i++){\n\t\tisprime[i]=1;\n\t}\n\tisprime[0]=0, isprime[1]=0;\n\tfor(ll i=2; i<1100000; i++){\n\t\tif(isprime[i]){\n\t\t\tprime.push_back(i);\n\t\t\tfor(ll j=2*i; j<1100000; j+=i){\n\t\t\t\tisprime[j]=0;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main()\n{\n\tsieve();\n\tint a[1001][1001];\n\tint x=500, y=500, t=1;\n\ta[x][y]=t;\n\tfor(int i=3; i<=1001; i+=2){\n\t\ty++; t++;\n\t\ta[x][y]=t;\n\t\tfor(int j=1; j<i-1; j++){\n\t\t\tx--; t++;\n\t\t\ta[x][y]=t;\n\t\t}\n\t\tfor(int j=0; j<i-1; j++){\n\t\t\ty--; t++;\n\t\t\ta[x][y]=t;\n\t\t}\n\t\tfor(int j=0; j<i-1; j++){\n\t\t\tx++; t++;\n\t\t\ta[x][y]=t;\n\t\t}\n\t\tfor(int j=0; j<i-1; j++){\n\t\t\ty++; t++;\n\t\t\ta[x][y]=t;\n\t\t}\n\t}\n\tP p[1100000];\n\tfor(int i=0; i<1001; i++){\n\t\tfor(int j=0; j<1001; j++){\n\t\t\tp[a[i][j]]=P(i, j);\n\t\t}\n\t}\n\twhile(1){\n\t\tint n, m;\n\t\tcin>>m>>n;\n\t\tif(m==0 && n==0) return 0;\n\t\tint d[1000001];\n\t\tfill(d, d+m+1, -1);\n\t\tif(isprime[n]) d[n]=1;\n\t\telse d[n]=0;\n\t\tint x0=p[n].first, y0=p[n].second;\n\t\tfor(int i=x0; i<=1000; i++){\n\t\t\tbool end=1;\n\t\t\tfor(int j=max(0, y0-i+x0); j<=min(1000, y0+i-x0); j++){\n\t\t\t\tif(a[i][j]>m) continue;\n\t\t\t\tif(i+1<=1000 && j-1>=0 && a[i+1][j-1]<=m){\n\t\t\t\t\tend=0;\n\t\t\t\t\tif(isprime[a[i+1][j-1]]){\n\t\t\t\t\t\td[a[i+1][j-1]]=max(d[a[i+1][j-1]], d[a[i][j]]+1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\td[a[i+1][j-1]]=max(d[a[i+1][j-1]], d[a[i][j]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i+1<=1000 && a[i+1][j]<=m){\n\t\t\t\t\tend=0;\n\t\t\t\t\tif(isprime[a[i+1][j]]){\n\t\t\t\t\t\td[a[i+1][j]]=max(d[a[i+1][j]], d[a[i][j]]+1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\td[a[i+1][j]]=max(d[a[i+1][j]], d[a[i][j]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(i+1<=1000 && j+1<=1000 && a[i+1][j+1]<=m){\n\t\t\t\t\tend=0;\n\t\t\t\t\tif(isprime[a[i+1][j+1]]){\n\t\t\t\t\t\td[a[i+1][j+1]]=max(d[a[i+1][j+1]], d[a[i][j]]+1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\td[a[i+1][j+1]]=max(d[a[i+1][j+1]], d[a[i][j]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(end) break;\n\t\t}\n\t\tint ans=0, ans2=0;\n\t\tfor(int i=1; i<=m; i++){\n\t\t\tif(ans<d[i]) ans=d[i];\n\t\t}\n\t\tif(ans==0){\n\t\t\tcout<<0<<\" \"<<0<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=1; i<=m; i++){\n\t\t\tif(isprime[i] && ans==d[i]) ans2=i;\n\t\t}\n\t\tcout<<ans<<\" \"<<ans2<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\nusing namespace std;\n#define N 1010\n#define N2 N*N\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nbool prime[N2+1];\nint cave[N][N]={};\npair<int,int> dp[N][N];\nint m,n;\n\npair<int,int> rec(int x,int y){\n    if(dp[x][y].first)return dp[x][y];\n    if(y<0 || x<0 || x==N) return pair<int,int>(0,0);\n    if(cave[x][y]>m) return pair<int,int>(0,0);\n\n    //printf(\"now %d call %d %d\\n\", cave[x][y],x,y);\n\n    pair<int,int> child[3];\n    child[0]=rec(x-1,y-1);\n    child[1]=rec(x,y-1);\n    child[2]=rec(x+1,y-1);\n    sort(child,child+3);\n    if(child[2].first==0 && prime[cave[x][y]])\n    {\n        pair<int,int> tmp(1,cave[x][y]);\n        //printf( \"%d %d ret %d,%d\\n\",x,y,tmp.first,tmp.second);\n        return dp[x][y]=pair<int,int>(1,cave[x][y]);\n    }\n    if(prime[cave[x][y]])child[2].first++;\n\n    //printf( \"%d %d ret %d,%d\\n\",x,y,child[2].first,child[2].second);\n    return dp[x][y]=child[2];\n}\n\nint main(void){\n    cout<<\"test\"<<endl;\n    fill(prime,prime+N2+1,true);\n    prime[0]=prime[1]=false;\n    for(int i=2;i<=N2;i++){\n        if(!prime[i])continue;\n        for(int k=2;i*k<=N2;k++)prime[i*k]=false;\n    }\n\n    int x=0,y=N-1,d=0;\n    pair<int,int> locate[N2+1];\n    for(int i=N2;i>0;i--){\n        cave[x][y]=i;\n        locate[i] = pair<int,int>(x,y);\n        int nextX=x+dx[d],nextY=y+dy[d];\n        if(nextX==-1 || nextX==N || nextY==-1 || nextY==N || cave[nextX][nextY])d=(d+1)%4;\n        x+=dx[d];\n        y+=dy[d];\n    }\n\n\n    while(cin>>m>>n, m|n){\n        rep(i,N)rep(j,N)dp[i][j].first=dp[i][j].second=0;\n        pair<int,int> tmp=rec(locate[n].first,locate[n].second);\n        printf(\"start %d, %d\\n\", locate[n].first,locate[n].second);\n        cout<<tmp.first<<\" \"<<tmp.second<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n//#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n//#define EXIST(s, e) ((s).find(e)!=(s).end())\n//#define SORT(c) sort(begin(c),end(c))\n//#define pb emplace_back\n//#define MP make_pair\n//#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n//ここから編集する\nclass Dijkstra {\npublic:\n    struct edge {\n        ll to, cost;\n    };\n    typedef pair<ll, ll> P; //firstは最短距離、secondは頂点の番号\n\n    int V;                  //超点数\n    vector<vector<edge>> G; //グラフ,G[i]はiから出る辺の集合,G[i][j]はiから出る辺のj番目の辺\n    vector<ll> d;           //最短距離\n    vector<int> last;\n\n    //0origin\n    Dijkstra(int N) {\n        V = N;\n        G = vector<vector<edge >>(N);\n        d = vector<ll>(N);\n        last = vector<int>(N);\n    };\n\n    void dijkstra(int s) {\n        priority_queue<P, vector<P>, greater<P>> que;\n        fill(d.begin(), d.end(), INFl);\n        d[s] = 0;\n        que.push(P(0, s));\n\n        while (!que.empty()) {\n            P p = que.top();\n            que.pop();\n            ll v = p.second;\n            if (d[v] < p.first)\n                continue;\n            for (int i = 0; i < G[v].size(); i++) {\n                edge e = G[v][i];\n                if (d[e.to] > d[v] + e.cost && !(d[e.to] == INFl && d[v] == INFl)) {\n                    d[e.to] = d[v] + e.cost;\n                    que.push(P(d[e.to], e.to));\n                }\n            }\n        }\n    }\n\n    /* 頂点fromに頂点toに達するコストcostの辺を貼る */\n    void addEdge(int from, int to, int cost) {\n        edge e;\n        e.to = to;\n        e.cost = cost;\n        G[from].push_back(e);\n    }\n};\n\n\nvector<bool> prime(1000005, true);\n\nvoid setEra() {\n    prime[0] = prime[1] = false;\n    int lim = 1000005;\n    rep(i, 2, lim) {\n        if (prime[i]) {\n            for (int j = i * 2; j < lim; j += i) {\n                prime[j] = false;\n            }\n        }\n    }\n}\n\nvector<vector<int> > makeDou(int n) {\n    vector<vector<int> > tmp(2000, vector<int>(2000));\n    int h = 1000;\n    int w = 1000;\n    int val = 1;\n    int dh[] = {0, -1, 0, 1};\n    int dw[] = {1, 0, -1, 0};\n    int seq = 0;\n    int lim = 1;\n    int turn = 0;\n\n    while (val <= n) {\n        tmp[h][w] = val;\n        val++;\n        seq++;\n        h += dh[turn % 4];\n        w += dw[turn % 4];\n\n        if (seq == lim) {\n            turn++;\n            seq = 0;\n            lim = turn / 2 + 1;\n        }\n    }\n\n    int sw = 2000, tw = 0, sh = 2000, th = 0;\n    rep(i, 0, 2000) {\n        rep(j, 0, 2000) {\n            if (tmp[i][j] > 0) {\n                sh = min(sh, i);\n                sw = min(sw, j);\n\n                th = max(th, i + 1);\n                tw = max(tw, j + 1);\n            }\n        }\n    }\n    vector<vector<int>> ret(th - sh + 1, vector<int>(tw - sw + 1));\n    for (int i = sh; i < th; i++) {\n        for (int j = sw; j < tw; j++) {\n            ret[i - sh][j - sw] = tmp[i][j];\n        }\n    }\n\n    return ret;\n}\n\nbool solve() {\n    int m, n;\n    cin >> m >> n;\n    if (n == 0 && m == 0) return false;\n\n    auto field = makeDou(m);\n    vector<vector<int> > dp(field.size(), vector<int>(field[0].size(), -1));\n    int sh, sw;\n    int H = field.size();\n    int W = field[0].size();\n    rep(i, 0, H) {\n        rep(j, 0, W) {\n            if (field[i][j] == n) {\n                sh = i;\n                sw = j;\n            }\n        }\n    }\n    dp[sh][sw] = prime[n];\n\n\n    rep(i, 0, H - 1) {\n        rep(j, 0, W) {\n            if (dp[i][j] != -1) {\n                for (int nj = j - 1; nj <= j + 1; nj++) {\n                    if (nj >= 0 && nj < W) {\n                        int tmp = (prime[field[i + 1][nj]]) ? dp[i][j] + 1 : dp[i][j];\n                        dp[i + 1][nj] = max(dp[i + 1][nj], tmp);\n                    }\n                }\n            }\n        }\n    }\n\n    int max_v = 0;\n    int max_p = 0;\n\n    rep(i, 0, H) {\n        rep(j, 0, W) {\n            if (dp[i][j] > max_v) {\n                max_v = dp[i][j];\n            }\n        }\n    }\n    if (max_v == 0) {\n        cout << 0 << \" \" << 0 << endl;\n        return true;\n    }\n\n    rep(i, 0, H) {\n        rep(j, 0, W) {\n            if (dp[i][j] == max_v && prime[field[i][j]]) {\n                max_p = max(field[i][j],max_p);\n            }\n        }\n    }\n\n    cout << max_v << \" \" << max_p << endl;\n\n\n    return true;\n\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    if (false) {\n        auto hya = makeDou(1097);\n        rep(i, 0, hya.size()) {\n            rep(j, 0, hya[i].size()) {\n//                cout << hya[i][j] << \" \";\n                printf(\"%4d \", hya[i][j]);\n            }\n            cout << endl;\n        }\n        return 0;\n    }\n\n    setEra();\n    while (solve()) {\n\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <utility>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <set>\nusing namespace std;\n\nusing P = pair<int, int>;\nusing dp1P = P;\n\nconst int MAX_M = 1000010;\n\nbool prime_table[MAX_M];\nmap<P, int> cave;\nP num2pos[MAX_M];\nbool used[MAX_M];\n\nint dp1[MAX_M],\n    dp2[MAX_M];\n\nint dy[4] = {0, 1, 0, -1},\n    dx[4] = {1, 0, -1, 0};\n\nvoid sieve() {\n    for (int i = 2; i < MAX_M; i++) {\n        prime_table[i] = true;\n    }\n    for (int m = 2; m * m <= MAX_M; m++) {\n        if (prime_table[m]) {\n            for (int i = 2; i * m < MAX_M; i++) {\n                prime_table[i * m] = false;\n            }\n        }\n    }\n}\n\nint main() {\n    // テヲツエツ榲ァツェツ淌」ツ?ョテヲツァツ凝ァツッツ?\n    int num = 1, x = 0, y = 0, dir = 3;\n    cave[P(x, y)] = num;\n    num2pos[num] = P(x, y);\n    num++;\n\n    for (int i = 0; i < MAX_M - 5; i++) {\n        int ndir = (dir + 1) % 4,\n            nx = x + dx[ndir],\n            ny = y + dy[ndir];\n        // テ・ツ?・テ」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝」ツ?凝・ツ青ヲテ」ツ??\n        if (cave.count(P(nx, ny)) == 0) {\n            x = nx;\n            y = ny;\n            dir = ndir;\n        } else {\n            x = x + dx[dir],\n            y = y + dy[dir];\n        }\n        cave[P(x, y)] = num;\n        num2pos[num] = P(x, y);\n        num++;\n    }\n\n    sieve();\n\n    int m, n;\n    while (cin >> m >> n, m | n) {\n        memset(dp1, -1, sizeof(dp1));\n        memset(dp2, 0, sizeof(dp2));\n        memset(used, false, sizeof(used));\n\n        queue<int> que;\n        que.push(n);\n\n        dp1[n] = prime_table[n];\n        dp2[n] = prime_table[n] ? n : 0;\n\n        used[n] = true;\n        while (!que.empty()) {\n            auto num = que.front(); que.pop();\n            // if (dp1[qp.first] > qp.second) continue;\n\n            P pos = num2pos[num];\n            for (int ddx = -1; ddx <= 1; ddx++) {\n                int nx = pos.first + ddx,\n                    ny = pos.second - 1;\n                if (cave.count(P(nx, ny)) == 0 || cave[P(nx, ny)] > m) continue;\n                int nnum = cave[P(nx, ny)],\n                    prime_num = dp1[num] + (prime_table[nnum]);\n\n                if (dp1[nnum] < prime_num) {\n                    dp1[nnum] = prime_num;\n                    dp2[nnum] = dp1[num];\n\n                    if (prime_table[nnum]) dp2[nnum] = nnum;\n\n                    if (!used[nnum]) {\n                        que.push(nnum);\n                        used[nnum] = true;\n                    }\n                } else if (dp1[nnum] == prime_num && dp2[nnum] < dp2[num]) {\n                    dp2[nnum] = dp2[num];\n\n                    if (prime_table[nnum]) dp2[nnum] = nnum;\n                }\n            }\n        }\n        int prime_num = 0, last_prime = 0;\n        for (int i = 1; i <= m; i++) {\n            if (prime_num < dp1[i]) {\n                prime_num = dp1[i];\n                last_prime = dp2[i];\n            } else if (prime_num == dp1[i] && last_prime < dp2[i]) {\n                prime_num = dp1[i];\n                last_prime = dp2[i];\n            }\n        }\n        cout << prime_num << \" \" << last_prime << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\n#define MP make_pair\n#define PB push_back\n#define MAX_N 1000000\n#define X first\n#define Y second\n\nconst int STX = 505, STY = 505;\n\nint id[1010][1010];\nbool is_prime[MAX_N+1];\nvector<pair<int, int> > coord;\n\nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++) {\n    if(is_prime[i]) {\n      for(int j=i*i; j<=MAX_N; j+=i) {\n\tis_prime[j] = false;\n      }\n    }\n  }\n}\n\nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  /*\n  const int dx[] = {1,0,-1,0};\n  const int dy[] = {0,-1,0,1};\n  */\n  coord.PB(MP(0, 0)); // no use\n  coord.PB(MP(x, y)); // cnt = 1\n  cnt ++;\n\n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt <= MAX_N) {\n    a += 2;\n    for(int i=0; i<a; i++) {\n      y --;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      x --;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      y ++;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      x ++;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    x++, y++;\n  }\n  /*\n  for(int i=1; ; i++) {\n    if(i%4 == 0) x--;\n    \n    // marking\n    for(int j=0; j<(i/4+1)*2; j++) {\n      x += dx[i%4], y += dy[i%4];\n      cout << x << \",\" << y;// << endl;\n      id[y][x] = ++ cnt; cout << \" \" << cnt << endl;\n      coord.PB(MP(x, y));\n      if(cnt == 50) return;\n    }\n  }\n  */\n}\n\nint dp[MAX_N+1];\n\nint main() {\n  \n  Sieve();\n  MakeMap();\n  \n  int m, n;\n  \n  while(cin >> m >> n && (m|n)) {\n    fill(dp, dp+MAX_N+1, -1);\n    dp[n] = is_prime[n];\n    \n    queue<pair<int, int> > que;\n    que.push(coord[n]);\n    \n    while(!que.empty()) {\n      pair<int, int> now = que.front(); que.pop();\n      int noid = id[now.Y][now.X];\n      \n      for(int i=-1; i<=1; i++) {\n\tpair<int, int> nex = MP(now.X+i, now.Y+1);\n\tint neid = id[nex.Y][nex.X];\n\n\tif(neid <= m) {\n\t  if(dp[neid] < dp[noid] + is_prime[neid]) {\n\t    dp[neid] = dp[noid] + is_prime[neid];\n\t    que.push(nex);\n\t    /*\n\t    if(res <= dp[neid] ) {\n\t      if(res == dp[neid]) {\n\t\tlastid = max(lastid, neid);\n\t      } else {\n\t\tlastid = neid;\n\t\tres = dp[neid];\n\t      }\n\t    }\n\t    */\n\t  }\n\t}\n\t\n      }\n    }\n    \n    int res = dp[n], lastid;\n    if(is_prime[n]) lastid = n;\n    else lastid = 0;\n    \n    for(int i=1; i<=m; i++) {\n      if(res <= dp[i] && is_prime[i]) {\n\tres = dp[i];\n\tlastid = max(lastid, i);\n      }\n    }\n    \n    if(res == 0) cout << \"0 0\" << endl;\n    else cout << res << \" \" << lastid << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define SIZE 1000\n\nbool C(int dp1, int pr1, int dp2, int pr2) {\n\tif (dp2 == 0)return false;\n\tif (dp1 < dp2 || (dp1 == dp2&&pr1 < pr2))return true;\n\treturn false;\n}\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool complete;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;\n\tfor (int i = 1;i <= SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\tif (i % 2 == 0)x--;\n\t\t\telse x++;\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t}\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\tcomplete = false;\n\t\twhile (!complete) {\n\t\t\twhile (x >= 0 && !complete) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x - 1], pr[y + 1][x - 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x], pr[y + 1][x])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x + 1], pr[y + 1][x + 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (table[y][x] == n)complete = true;\n\t\t\t\telse x--;\n\t\t\t}\n\t\t\tif (!complete) {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define MAX_N 1000000\n#define L 1000\nusing namespace std;\nstruct cave{\n\tint num;\n\tint pnum;\t//探索した素数洞穴の総数\n\tint lastp;\t//最後に通った素数の値\n};\n\nstruct cave hole[L+1][L+1];\nbool prime[MAX_N+1];\n\nint main(){\n\tfor(int i = 0; i < MAX_N+1; i++){\n\t\tprime[i] = true;\n\t}\n\tprime[0] = prime[1] = false;\t//prime[1]:1\n\n\tfor(int i = 2; i <= MAX_N; i++){\n\t\tif(prime[i] == true){\n\t\t\tfor(int j = 2*i; j < MAX_N; j += i){\n\t\t\t\tprime[j] = false;\n\t\t\t}\n\t\t}\n\t}\t//ふるい\n\n//\tfor(int i = 0; i < L*L; i++){\n//\t\tcout << i << \" \" << prime[i] << endl;\n//\t}\n\n\tint m,n;\n\twhile(cin >> m >> n,m){\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tfor(int j = 0; j < L; j++){\n\t\t\t\thole[i][j].num = 0;\n\t\t\t\thole[i][j].pnum = 0;\n\t\t\t\thole[i][j].lastp = 0;\n\t\t\t}\n\t\t}\t//hole初期化\n\n\t\tint sy = 0,sx = 0;\n\t\tfor(int i = 0; i < L/2; i++){\n\t\t\tfor(int j = 0; j < 2*i+1; j++){\n\t\t\t\thole[-i-1+L/2][-i+j+L/2-1].num = (2*i+2)*(2*i+2)-j;\n\t\t\t\tif(n == (2*i+2)*(2*i+2)-j){\n\t\t\t\t\tsy = -i-1+L/2;\n\t\t\t\t\tsx = -i+j+L/2-1;\n\t\t\t\t}\n\t\t\t\thole[-i-1+j+L/2][i+1+L/2-1].num = (2*i+1)*(2*i+2)+1-j;\n\t\t\t\tif(n == (2*i+1)*(2*i+2)+1-j){\n\t\t\t\t\tsy = -i-1+j+L/2;\n\t\t\t\t\tsx = i+1+L/2-1;\n\t\t\t\t}\n\t\t\t\thole[i+L/2][i+1-j+L/2-1].num = (2*i+1)*(2*i+1)+1-j;\n\t\t\t\tif(n == (2*i+1)*(2*i+1)+1-j){\n\t\t\t\t\tsy = i+L/2;\n\t\t\t\t\tsx = i+1-j+L/2-1;\n\t\t\t\t}\n\t\t\t\thole[i-j+L/2][-i+L/2-1].num = 2*i*(2*i+1)+1-j;\n\t\t\t\tif(n == 2*i*(2*i+1)+1-j){\n\t\t\t\t\tsy = i-j+L/2;\n\t\t\t\t\tsx = -i+L/2-1;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\t//mapping\n\t\tif(prime[hole[sy][sx].num] == true){\n\t\t\thole[sy][sx].pnum = 1;\n\t\t\thole[sy][sx].lastp = hole[sy][sx].num;\n\t\t}\n\t\tfor(int i = sy+1; i < L; i++){\t//syのあった段から下に見ていく\n\t\t\tfor(int j = max(0,sx-(i-sy)); j <= min(sx+(i-sy),L-1); j++){\n\t\t\t\tif(hole[i][j].num <= m){\t//洞穴の個数以上の場所は見ない\n\t\t\t\t\tint tmp = 0,maxtmp = 0;\n\t\t\t\t\tfor(int k = -1; k <= 1; k++){\n\t\t\t\t\t\tif(max(0,sx-(i-sy)) <= j+k && j+k <= min(sx+(i-sy),L-1) && maxtmp < hole[i-1][j+k].pnum){\n\t\t\t\t\t\t\tmaxtmp = hole[i-1][j+k].pnum;\n\t\t\t\t\t\t\ttmp = hole[i-1][j+k].lastp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\thole[i][j].pnum = maxtmp;\n\t\t\t\t\thole[i][j].lastp = tmp;\n\t\t\t\t\tif(prime[hole[i][j].num] == true){\n\t\t\t\t\t\thole[i][j].pnum ++;\n\t\t\t\t\t\thole[i][j].lastp = hole[i][j].num;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint maxtmp = -1;\n\t\tint last = 0;\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tfor(int j = 0; j < L; j++){\n\t\t\t\tif(hole[i][j].num <= m){\n\t\t\t\t\tif(hole[i][j].pnum == maxtmp && hole[i][j].lastp > last){\n\t\t\t\t\t\tlast = hole[i][j].lastp;\n\t\t\t\t\t}else if(hole[i][j].pnum > maxtmp){\n\t\t\t\t\t\tmaxtmp = hole[i][j].pnum;\n\t\t\t\t\t\tlast = hole[i][j].lastp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tfor(int j = 0; j < L; j++){\n\t\t\t\tcout << hole[i][j].num << \" \" ;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\t//debug\n\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tfor(int j = 0; j < L; j++){\n\t\t\t\tcout << hole[i][j].pnum << \" \" ;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\t//debug\n*/\n\t\tcout << maxtmp << \" \" << last << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\n#define mp make_pair\ntypedef pair<int,int> pii;\n\nconst int M_MAX = 1000010;\nconst int N = 4000;\n\n// 4000*4000*4 = 16000000*4 = 16MB*4=64MB\n// 1MB\npii fill(vector<vector<int>> &maze, int x, int y, int dir, int k, int s) {\n  for (int i = 0; i < k; i++) {\n    maze[y + i * dy[dir]][x + i * dx[dir]] = s++;\n  }\n  return mp(x + k * dx[dir], y + k * dy[dir]);\n}\n\nvoid make(vector<vector<int>> &maze) {\n  pii now = mp(N / 2, N / 2);\n  int k = 1;\n  int num = 1;\n  while(num <= M_MAX) {\n    now = fill(maze, now.first, now.second, 0, k, num); num += k;\n    now = fill(maze, now.first, now.second, 1, k, num); num += k;\n    k++;\n    now = fill(maze, now.first, now.second, 2, k, num); num += k;\n    now = fill(maze, now.first, now.second, 3, k, num); num += k;\n    k++;\n  }\n}\n\nchar isprime[M_MAX];\n\nvoid era() {\n  for (int i = 0; i < M_MAX; i++) {\n    isprime[i] = 1;\n  }\n  isprime[0] = isprime[1] = 0;\n  for (int i = 2; i < M_MAX; i++) {\n    if (isprime[i]) {\n      for (int j = i + i; j < M_MAX; j += i) {\n        isprime[j] = 0;\n      }\n    }\n  }\n}\n\nvoid solve(vector<vector<int>> &maze, int m, int n) {\n  int sx, sy;\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      if (maze[i][j] == n) {\n        sx = j, sy = i;\n      }\n    }\n  }\n  vector<vector<int16_t>> dp(N, vector<int16_t>(N, -1));\n  dp[sy][sx] = isprime[maze[sy][sx]];\n  for (int i = 0; i < N - 1; i++) {\n    for (int j = 0; j < N; j++) {\n      if (maze[i][j] > m) continue;\n      if (dp[i][j] == -1) continue;\n      if (j >= 1) dp[i + 1][j - 1] = max(dp[i + 1][j - 1], (int16_t)(dp[i][j] + isprime[maze[i + 1][j - 1]]));\n      dp[i + 1][j] = max(dp[i + 1][j], (int16_t)(dp[i][j] + isprime[maze[i + 1][j]]));\n      if (j < N - 1) dp[i + 1][j + 1] = max(dp[i + 1][j + 1], (int16_t)(dp[i][j] + isprime[maze[i + 1][j + 1]]));\n    }\n  }\n  int ma = 0;\n  int ma_ind = 0;\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      if (maze[i][j] > m) continue;\n      if (ma <= dp[i][j] && isprime[maze[i][j]]) {\n        if (ma < dp[i][j]) {\n          ma = dp[i][j];\n          ma_ind = maze[i][j];\n        } else {\n          if (ma_ind < maze[i][j]) ma_ind = maze[i][j];\n        }\n      }\n    }\n  }\n  if (ma == 0) {\n    cout << \"0 0\" << endl;\n  } else {\n    cout << ma << \" \" << ma_ind << endl;\n  }\n}\n\nint main() {\n  vector<vector<int>> maze(N, vector<int>(N, 0));\n  make(maze);\n  era();\n\n  int n, m;\n  while(cin >> m >> n, m != 0) {\n    solve(maze, m, n);\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nusing namespace std;\n  \n#define MP make_pair\n#define PB push_back\n#define MAX_N 1010000\n#define SIZE 3000\n#define X first\n#define Y second\n  \nconst int STX = 1500, STY = 1500;\n\ntypedef pair<int, int> Pii;\ntypedef pair<int, Pii> P;\n  \nint id[SIZE][SIZE];\nbool is_prime[MAX_N+1];\nvector<Pii> coord;\n\nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++)\n    if(is_prime[i])\n      for(int j=i*i; j<=MAX_N; j+=i)\n\tis_prime[j] = false;\n}\n\nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  \n  coord.PB(MP(0, 0)); // no use\n  cnt ++;\n  coord.PB(MP(x, y)); // cnt = 1\n  \n  fill(id[0], id[0]+SIZE*SIZE+1, -1);\n  \n  const int dx[] = {0,-1,0,1};\n  const int dy[] = {-1,0,1,0};\n  \n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt <= MAX_N) {\n    a += 2;\n    for(int turn=0; turn<4; turn++) {\n      for(int i=0; i<a; i++) {\n\tx += dx[turn], y += dy[turn];\n\tcoord.PB(MP(x, y));\n\tid[y][x] = ++ cnt;\n      }\n    }\n    x++, y++;\n  }\n}\n\nint dp[MAX_N+1];\n\nint main() {\n  \n  Sieve();\n  MakeMap();\n  \n  int m, n;\n\n  while(cin >> m >> n && (m|n)) {\n    \n    fill(dp, dp+MAX_N+1, -1);\n    dp[n] = is_prime[n];\n    Pii ans(dp[n], n);\n    \n    queue<P> que;\n    que.push(P(dp[n], coord[n]));\n    while(!que.empty()) {\n      P now = que.front(); que.pop();\n      int tmpid = id[now.second.Y][now.second.X];\n      if(now.first < dp[tmpid]) continue;\n      \n      int noid = id[now.second.Y][now.second.X];\n      \n      for(int i=-1; i<=1; i++) {\n\tPii nex = MP(now.second.X+i, now.second.Y+1);\n\tif(nex.X < 0 || SIZE <= nex.X || nex.Y < 0 || SIZE <= nex.Y) continue;\n\tint neid = id[nex.Y][nex.X];\n\tif(neid <= m) {\n\t  if(dp[neid] < dp[noid] + is_prime[neid]) {\n\t    dp[neid] = dp[noid] + is_prime[neid];\n\t    if(is_prime[neid]) ans = max(ans, MP(dp[neid], neid));\n\t    que.push(P(dp[neid], nex));\n\t  }\n\t}\n      }\n\n    }\n    \n    if(ans.first == 0) cout << \"0 0\" << endl;\n    else cout << ans.first << ' ' << ans.second << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<utility>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint cave_num[1000][1000];\nbool is_prime[1000001];\nP trans[1000001];\nP dp[1000001];\nint m;\n\nvoid prime() {\n\tint p = 0;\n\tfor (int i = 0; i <= 1000000; i++)is_prime[i] = true;\n\tis_prime[0] = is_prime[1] = false;\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tif (is_prime[i]) {\n\t\t\tfor (int j = 2 * i; j <= 1000000; j += i)is_prime[j] = false;\n\t\t}\n\t}\n}\n\nP dfs(int n) {\n\tif (dp[n].first != -1)return dp[n];\n\tint res1 = 0, res2 = 0;\n\tP now = trans[n];\n\tfor (int i = -1; i <= 1; i++) {\n\t\tif (now.second + 1 > 999)break;\n\t\tif (now.first + i < 0 || now.first + i>999)continue;\n\t\tif (cave_num[now.first + i][now.second + 1] > m)continue;\n\t\tP next = dfs(cave_num[now.first + i][now.second + 1]);\n\t\tif (res1 <= next.first) {\n\t\t\tif (res1 == next.first) {\n\t\t\t\tres2 = max(res2, next.second);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres2 = next.second;\n\t\t\t}\n\t\t\tres1 = next.first;\n\t\t}\n\t}\n\tif (is_prime[n]) {\n\t\tif (res2 == 0)res2 = n;\n\t\tres1++;\n\t}\n\treturn dp[n] = P(res1, res2);\n}\n\nvoid num() {\n\tint sx = 499, sy = 500;\n\tint x = 1; cave_num[sx][sy] = x; trans[x] = P(sx, sy);\n\tfor (int i = 1; i <= 999; i++) {\n\t\tif (i % 2) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tcave_num[++sx][sy] = ++x;\n\t\t\t\ttrans[x] = P(sx, sy);\n\t\t\t}\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tcave_num[sx][--sy] = ++x;\n\t\t\t\ttrans[x] = P(sx, sy);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tcave_num[--sx][sy] = ++x;\n\t\t\t\ttrans[x] = P(sx, sy);\n\t\t\t}\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tcave_num[sx][++sy] = ++x;\n\t\t\t\ttrans[x] = P(sx, sy);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 999; i++) {\n\t\tcave_num[--sx][sy] = ++x;\n\t\ttrans[x] = P(sx, sy);\n\t}\n}\n\nint main() {\n\tint n;\n\tprime();\n\tnum();\n\twhile (scanf(\"%d %d\", &m, &n), m) {\n\t\tfor (int i = 0; i <= m; i++)dp[i] = P(-1, -1);\n\t\tP p = dfs(n);\n\t\tprintf(\"%d %d\\n\", p.first, p.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstring>\n#include <tuple>\n#include <utility>\n#define MAX_N 1010\n#define LIMIT 1000010\n#define CENTER 501\nusing namespace std;\nconst int dy[] = {0, -1, 0, 1};\nconst int dx[] = {1, 0, -1, 0};\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\ntypedef struct res\n{\n\tint id, num, last;\n} table_t;\ntable_t table[MAX_N][MAX_N];\nbool isPrime[LIMIT];\n//int table[MAX_N][MAX_N];\n//bool visit[MAX_N][MAX_N];\n//P dp[MAX_N][MAX_N];\nint sy, sx, n, m;\nvoid make_prime()\n{\n\tfill(isPrime, isPrime + LIMIT, true);\n\tisPrime[0] = isPrime[1] = false;\n\tfor (int i = 2; i * i < LIMIT; i++)\n\t{\n\t\tif (!isPrime[i])\n\t\t\tcontinue;\n\t\tfor (int j = i * 2; j < LIMIT; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\nvoid init_table()\n{\n\tfor(int i = 0; i < MAX_N; i++)\n\t{\n\t\tfor(int j = 0; j < MAX_N; j++)\n\t\t{\n\t\t\ttable[i][j].id = table[i][j].last = 0;\n\t\t\ttable[i][j].num = -1;\n\t\t}\n\t}\n}\nvoid make_cave()\n{\n\tint dir = 0, ok = 1, cnt = 0, flag = 0;\n\tint y, x;\n\ty = x = MAX_N / 2;\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tif (i == n)\n\t\t{\n\t\t\tsy = y;\n\t\t\tsx = x;\n\t\t}\n\t\ttable[y][x].id = i;\n\t\t//dp[y][x].second = i;\n\t\ty += dy[dir];\n\t\tx += dx[dir];\n\t\tcnt++;\n\t\tif (cnt == ok)\n\t\t{\n\t\t\tdir = (dir + 1) % 4;\n\t\t\tflag++;\n\t\t\tcnt = 0;\n\t\t\tif (flag == 2)\n\t\t\t{\n\t\t\t\tflag = 0;\n\t\t\t\tok++;\n\t\t\t}\n\t\t}\n\t}\n}\n//残骸\n/*P dfs(int y, int x)\n{\n\tif(dp[y][x].second == -1)\n\t\treturn {0, -2};\n\tif(dp[y][x].second > 0)\n\t\treturn dp[y][x];\n\tP ret = max({dfs(y + 1, x - 1), dfs(y + 1, x), dfs(y + 1, x + 1)});\n\tif(ret.second == -2)\n\t{\n\t\tret.second = dp[y][x].second;\n\t}\n\tif(isPrime[dp[y][x].second] && isPrime[ret.second])\n\t{\n\t\tret.second = max(dp[y][x].second, ret.second);\n\t\tret.first++;\n\t}\n\tvisit[y][x] = true;\n\tdp[y][x] = ret;\t\n\tfor(int i = MAX_N / 2 - 20; i < MAX_N / 2 + 20; i++)\n\t{\n\t\tfor(int j = MAX_N / 2 - 20; j < MAX_N / 2 + 20; j++)\n\t\t{\n\t\t\tif(i == y && j == x)\n\t\t\t\tprintf(\"%5d\", dp[i][j].first);\n\t\t\telse\n\t\t\t\tprintf(\"%5d\", dp[i][j].second);\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n\n\treturn ret;\n}\n*/\ntable_t dfs(int y, int x)\n{\n\ttable_t ret;\n\tint id, num, last;\n\tif(table[y][x].id == 0)\n\t{\n\t\tret.id = ret.num = ret.last = 0;\n\t}\n\telse if(table[y][x].num >= 0)\n\t\tret = table[y][x];\n\telse\n\t{\n\t\tnum = last = 0;\n\t\tid = table[y][x].id;\n\t\tfor(int i = -1; i <= 1; i++)\n\t\t{\n\t\t\tret = dfs(y + 1, x + i);\n\t\t\tif(ret.num > num)\n\t\t\t{\n\t\t\t\tnum = ret.num;\n\t\t\t\tlast = ret.last;\n\t\t\t}\n\t\t\telse if(ret.num == num)\n\t\t\t{\n\t\t\t\tlast = max(ret.last, last);\n\t\t\t}\n\t\t}\n\t\tif(isPrime[id])\n\t\t{\n\t\t\tif(num == 0)\n\t\t\t\tlast = id;\n\t\t\tnum++;\n\t\t}\n\t\tret.id = id;\n\t\tret.num = num;\n\t\tret.last = last;\n\t\ttable[y][x] = ret;\n\t}\n\treturn ret;\n}\nint main()\n{\n\tmake_prime();\n\twhile (cin >> m >> n, n | m)\n\t{\n\t\t//memset(dp, -1, sizeof(dp));\n\t\tinit_table();\n\t\t//memset(visit, false, sizeof(visit));\n\t\tmake_cave();\n\t\ttable_t ans = dfs(sy, sx);\n\t\t/*\n\t\tfor(int i = MAX_N / 2 - 20; i < MAX_N / 2 + 20; i++)\n\t\t{\n\t\t\tfor(int j = MAX_N / 2 - 20; j < MAX_N / 2 + 20; j++)\n\t\t\t\tprintf(\"%5d\", table[i][j].last);\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tcout << ans.num << \" \" << ans.last << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nint num[1101][1101];\nbool saw[2000000], fact[2000000];\nint m, n;\n\nvoid init(){\n\trep(i,1101) rep(j,1101) num[i][j] = -1;\n\tnum[550][550] = 1; num[550][551] = 2;\n\tint y = 550, x = 551;\n\tfor(int i = 3; i <= 1010*1010; i++){\n\t\tif(num[y][x-1] != -1 && num[y-1][x] == -1) y--;\n\t\telse if(num[y+1][x] != -1 && num[y][x-1] == -1) x--;\n\t\telse if(num[y][x+1] != -1 && num[y+1][x] == -1) y++;\n\t\telse if(num[y-1][x] != -1 && num[y][x+1] == -1) x++;\n\t\tnum[y][x] = i;\n\t}\n\trep(i,2000000) fact[i] = false;\n\trep(i,2000000) saw[i] = false;\n\tfor(int i = 2; i <= 2000000; i++){\n\t\tif(saw[i] == false) fact[i] = true;\n\t\tfor(int j = i*2; j <= 2000000; j += i) saw[j] = true; \n\t}\n}\n\nP cnt[1101][1101];\n\nvoid solve(){\n\trep(i,1101) rep(j,1101) cnt[i][j] = P(-1,0);\n\tint y, x;\n\trep(i,1101) rep(j,1101){\n\t\tif(num[i][j] == n){\n\t\t\ty = i;\n\t\t\tx = j;\n\t\t\tcnt[i][j] = P(0,0);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(fact[n]){\n\t\tcnt[y][x] = P(1,n);\n\t}\n\t\n\trep(yy,1101) rep(xx,1101){\n\t\tif(cnt[yy][xx].first == -1) continue;\n\t\tfor(int i = -1; i <= 1; i++){\n\t\t\tif(num[yy+1][xx+i] == -1 || num[yy+1][xx+i] > m) continue;\n\t\t\tP tmp = cnt[yy][xx];\n\t\t\tif(fact[num[yy+1][xx+i]]){\n\t\t\t\ttmp.first++;\n\t\t\t\ttmp.second = num[yy+1][xx+i];\n\t\t\t}\n\t\t\tif(cnt[yy+1][xx+i] > tmp) continue;\n\t\t\tcnt[yy+1][xx+i] = tmp;\n\t\t}\n\t}\n\tP ans = P(-1,-1);\n\trep(i,1101) rep(j,1101) ans=max(ans,cnt[i][j]);\n\tcout << ans.first << \" \" << ans.second << endl;\n}\n\nint main(){\n\tinit();\n\twhile(true){\n\t\tcin >> m >> n;\n\t\tif(m == 0 && n == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <fstream>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint dp[1003][1003];\nint visit[1003][1003];\nint cave[1003][1003] = { 0 };\nconst int dx[4] = { 1, 0, -1,  0 };\nconst int dy[4] = { 0, -1,  0, 1 };\n\nint main() {\n\tifstream fin(\"input.txt\");\n\tofstream fout(\"output.txt\");\n\n\t//1~1000000の内素数ならtrue素数でないならfalse\n\tstatic int isPrime[1000001];\n\tfor (int i = 0; i < 1000001; i++) {\n\t\tisPrime[i] = 1;\n\t}\n\tisPrime[0] = 0;\n\tisPrime[1] = 0;\n\tfor (int i = 2; i <= 1000; i++) {\n\t\tif (isPrime[i]) {\n\t\t\tfor (int j = 2; i * j < 1000001; j++) {\n\t\t\t\tisPrime[i * j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tint c = 1, d = 0;\n\tint x = 500, y = 500;\n\tbool end = false;\n\twhile (true) {\n\t\tfor (int dir = 0; dir < 4; dir++) {\n\t\t\tif (dir % 2 == 0) d++;\n\t\t\tfor (int cnt = 1; cnt <= d; cnt++) {\n\t\t\t\tcave[x][y] = c;\n\t\t\t\tif (c == 1000000) {\n\t\t\t\t\tend = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tc++;\n\t\t\t\tx = x + dx[dir];\n\t\t\t\ty = y + dy[dir];\n\t\t\t}\n\t\t\tif (end) break;\n\t\t}\n\t\tif (end) break;\n\t}\n\n\twhile (true) {\n\t\tint all, num = 0, first, last = 0, f_x, f_y, l_x, l_y;\n\t\tcin >> all >> first;\n\t\tif (all == 0 && first == 0) break;\n\n\t\tfor (int j = 0; j < 1003; j++) {\n\t\t\tfor (int i = 0; i < 1003; i++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tvisit[i][j] = 0;\n\t\t\t\tif (cave[i][j] == first) {\n\t\t\t\t\tf_x = i;\n\t\t\t\t\tf_y = j;\n\t\t\t\t\tvisit[i][j] = 1;\n\t\t\t\t\tif (isPrime[first] == 1) dp[i][j] = 1;\n\t\t\t\t}\n\t\t\t\tif (cave[i][j] == all) {\n\t\t\t\t\tl_x = i;\n\t\t\t\t\tl_y = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int y = f_y + 1; y <= 1002; y++) {\n\t\t\tfor (int x = 1; x <= 1002; x++) {\n\t\t\t\tif (cave[x][y] <= all && cave[x][y] != 0) {\n\t\t\t\t\tif (!(visit[x - 1][y - 1] == 0 && visit[x][y - 1] == 0 && visit[x + 1][y - 1] == 0)) {\n\t\t\t\t\t\tdp[x][y] = max(visit[x - 1][y - 1] * dp[x - 1][y - 1], max(visit[x][y - 1] * dp[x][y - 1], visit[x + 1][y - 1] * dp[x + 1][y - 1]))\n\t\t\t\t\t\t\t+ isPrime[cave[x][y]];\n\t\t\t\t\t\tvisit[x][y] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int y = f_y; y <= 1002; y++) {\n\t\t\tfor (int x = 1; x <= 1002; x++) {\n\t\t\t\tnum = max(num, dp[x][y]);\n\t\t\t}\n\t\t}\n\n\t\tif (num != 0) {\n\t\t\tfor (int y = f_y; y <= 1002; y++) {\n\t\t\t\tfor (int x = 1; x <= 1002; x++) {\n\t\t\t\t\tif (dp[x][y] == num && isPrime[cave[x][y]] == 1) {\n\t\t\t\t\t\tlast = max(last, cave[x][y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << endl;\n\t\t//for (int y = 0; y <= 10; y++) {\n\t\t//\tfor (int x = 0; x <= 10; x++) {\n\t\t//\t\tcout << dp[x][y] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\t//cout << endl;\n\t\t//for (int y = 0; y <= 10; y++) {\n\t\t//\tfor (int x = 0; x <= 10; x++) {\n\t\t//\t\tcout << visit[x][y] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\n\t\tcout << num << \" \" << last << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\n#include <list>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str(); }\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX / 10;\n\nconst int MAX_N = 1000000;\nconst int MAX_F = 1000;\nint num[1001][1001];\nint dp[1001][1001], last[1001][1001];\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nbool isProperXY(int x, int y, int m) {\n\treturn 0 <= x && x <= MAX_F && 0 <= y && y <= MAX_F && 0 < num[y][x] && num[y][x] <= m;\n}\n\nint main() {\n\tvi isPrime(MAX_N + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, 1000) {\n\t\tfor (int j = i*i; j <= MAX_N; j += i) {\n\t\t\tisPrime[j] = false;\n\t\t}\n\t}\n\n\tmemset(num, INF, sizeof(num));\n\tint x = 500, y = 500, cur = 1, step = 1;\n\twhile (cur <= MAX_N) {\n\t\tREP(i, (step + 1) / 2) {\n\t\t\tnum[y][x] = cur;\n\t\t\tcur++;\n\t\t\tx += dx[step % 4];\n\t\t\ty += dy[step % 4];\n\t\t}\n\t\tstep++;\n\t}\n\n\tint m, n;\n\twhile (cin >> m >> n, m) {\n\t\tint stx, sty;\n\t\tFOR(i, 0, MAX_F) {\n\t\t\tFOR(j, 0, MAX_F) {\n\t\t\t\tif (num[i][j] == n) {\n\t\t\t\t\tsty = i, stx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tcout << sty << \" \" << stx << endl;\n\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tmemset(last, 0, sizeof(last));\n\t\tif (isPrime[num[sty][stx]]) {\n\t\t\tdp[sty][stx] = 1;\n\t\t\tlast[sty][stx] = num[sty][stx];\n\t\t}\n\t\tint ans = dp[sty][stx], lastp = last[sty][stx], minx = stx, maxx = stx;\n\t\tbool cont = true;\n\t\ty = sty;\n\t\twhile (cont) {\n\t\t\tcont = false;\n\t\t\tint nminx = INF, nmaxx = -INF;\n\t\t\tFOR(x, minx, maxx) {\n\t\t\t\tFOR(d, 1, 3) {\n\t\t\t\t\tint nx = x + dx[d], ny = y + 1;\n\t\t\t\t\tif (isProperXY(nx, ny, m)) {\n\t\t\t\t\t\tcont = true;\n\t\t\t\t\t\tnminx = min(nminx, nx);\n\t\t\t\t\t\tnmaxx = max(nmaxx, nx);\n\t\t\t\t\t\tif (isPrime[num[ny][nx]]) {\n\t\t\t\t\t\t\tlast[ny][nx] = num[ny][nx];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlast[ny][nx] = last[y][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint ndp = dp[y][x] + (isPrime[num[ny][nx]] ? 1 : 0);\n\t\t\t\t\t\tif (ans == ndp && lastp < last[ny][nx]) {\n\t\t\t\t\t\t\tlastp = last[ny][nx];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ans < ndp) {\n\t\t\t\t\t\t\tans = ndp;\n\t\t\t\t\t\t\tlastp = last[ny][nx];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[ny][nx] = max(dp[ny][nx], ndp);\n//\t\t\t\t\t\tcout << num[y][x] << \" \" << num[ny][nx] << \" \" << dp[ny][nx] << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tminx = nminx, maxx = nmaxx;\n\t\t\ty++;\n\t\t}\n\n\t\tcout << ans << \" \" << lastp << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int N = 1010, MAX = 1000001;\nint a[N][N], isprime[MAX];\n\nint main() {\n    int i = 505, j = 505, x = 1;\n    int di[] = {0,-1,0,1}, dj[] = {1,0,-1,0};\n    a[i][j] = 1;\n    for (int p = 0; x < 1000000; p++){\n        REP(c,p/2+1){\n            x++;\n            i += di[p%4];\n            j += dj[p%4];\n            a[i][j] = x;\n        }\n    }\n\n    FOR(i,2,MAX) isprime[i] = 1;\n    FOR(i,2,MAX){\n        if (!isprime[i]) continue;\n        for (int x = 2*i; x <= MAX; x += i) isprime[x] = 0; \n    }\n\n    int m, n;\n    while (cin >> m >> n && m){\n        VVI dp(N,VI(N,-1)), dpm(N,VI(N));\n        REP(i,N) REP(j,N) if (a[i][j] == n) dp[i][j] = isprime[n], dpm[i][j] = n;\n        REP(i,N) REP(j,N){\n            if (dp[i][j] == -1 || a[i][j] == 0) continue;\n            FOR(k,j-1,j+1){\n                int p = a[i+1][k];\n                if (p > m) continue;\n                if (isprime[p]){\n                    dp[i+1][k] = max(dp[i+1][k], dp[i][j] + 1);\n                    dpm[i+1][k] = p;\n                }else{\n                    if (dp[i+1][k] < dp[i][j] || (dp[i+1][k] == dp[i][j] && dpm[i+1][k] < dpm[i][j])){\n                        dp[i+1][k] = dp[i][j];\n                        dpm[i+1][k] = dpm[i][j];\n                    }\n                }\n            }\n        }\n        int x = 0, y = 0;\n        REP(i,N) REP(j,N){\n            if (x < dp[i][j] || (x == dp[i][j] && y < dpm[i][j])){\n                x = dp[i][j];\n                y = dpm[i][j];\n            }\n        }\n        if (x == 0) y = 0;\n        printf(\"%d %d\\n\", x, y);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\nconst int MAX_HW = 1010;\n\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\n\nint main()\n{\n\n\t\tvi p(1000000+1, 1);\n\t\tp[0] = p[1] = 0;\n\t\tFOR(i, 2, 1000+1) {\n\t\t\tif(p[i]) {\n\t\t\t\tfor(int j = i*i; j <= 1000000; j += i) {\n\t\t\t\t\tp[j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\tint m,n;\n\twhile(cin>>m>>n,m){\n\t\tpii start;\n\n\t\tint sty, stx;\n\t\tint top=INT_MAX, bottom=INT_MIN, left=INT_MAX, right=INT_MIN;\n\t\tvvi exist(MAX_HW, vi(MAX_HW));\n\t\tvvi canuse(MAX_HW, vi(MAX_HW));\n\n\t\tint y=MAX_HW/2;\n\t\tint x=MAX_HW/2;\n\t\tint move=1,d=0;\n\t\tint num=1;\n\t\tint cnt=1;\n\t\twhile(1){\n\t\t\tREP(_,move){\n\t\t\t\tif(num == n) {\n\t\t\t\t\tsty = y;\n\t\t\t\t\tstx = x;\n\t\t\t\t}\n\t\t\t\tif(p[num]){\n\t\t\t\t\texist[y][x]=1;\n\t\t\t\t}\n\t\t\t\tcanuse[y][x]=num;\n\t\t\t\ty+=dy[d];\n\t\t\t\tx+=dx[d];\n\t\t\t\tif(num==m){\n\t\t\t\t\tgoto made;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tassert(y<MAX_HW&&y>=0&&x<MAX_HW&&x>=0);\n\t\t\t}\n\t\t\td=(d+1)%4;\n\t\t\tif(cnt%2==0){\n\t\t\t\tmove++;\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\nmade:;\n\n\t\tREP(i,MAX_HW){\n\t\t\tREP(j,MAX_HW){\n\t\t\t\tif(canuse[i][j]){\n\t\t\t\t\tleft=min(left,j);\n\t\t\t\t\tright=max(right,j);\n\t\t\t\t\ttop=min(top,i);\n\t\t\t\t\tbottom=max(bottom,i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvvi dp(MAX_HW, vi(MAX_HW));\n\t\tdp[sty][stx]=exist[sty][stx]+1;\n\t\tvvi last(MAX_HW, vi(MAX_HW));\n\t\tif(exist[sty][stx]){\n\t\t\tlast[sty][stx]=canuse[sty][stx];\n\t\t}else{\n\t\t\tlast[sty][stx]=-1;\n\t\t}\n\n\t\tFOR(i, sty+1, bottom+1) {\n\t\t\tFOR(j, left, right+1) {\n\t\t\t\tif(!canuse[i][j]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint saiyou=INT_MIN;\n\t\t\t\tint best=0;\n\t\t\t\tfor(int k=-1;k<2;k++){\n\t\t\t\t\tif(dp[i-1][j+k]>best||(saiyou!=INT_MIN&&dp[i-1][j+k]==best&&last[i-1][saiyou]<last[i-1][j+k])){\n\t\t\t\t\t\tassert(j+k>=left&&j+k<=right);\n\t\t\t\t\t\tbest=dp[i-1][j+k];\n\t\t\t\t\t\tsaiyou=j+k;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(saiyou!=INT_MIN){\n\t\t\t\t\tif(exist[i][j]){\n\t\t\t\t\t\tdp[i][j]=best+1;\n\t\t\t\t\t\tlast[i][j]=canuse[i][j];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i][j]=best;\n\t\t\t\t\t\tlast[i][j]=last[i-1][saiyou];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//if(dp[i-1][j-1]>=1||dp[i-1][j]>=1||dp[i-1][j+1]>=1){\n\t\t\t\t//\tdp[i][j] = max(dp[i-1][j-1], max(dp[i-1][j], dp[i-1][j+1])) + exist[i][j];\n\t\t\t\t//}\n\t\t\t\t//if(exist[i][j]){\n\t\t\t\t//\tlast[i][j]=canuse[i][j];\n\t\t\t\t//}else{\n\t\t\t\t//\tlast[i][j]=max(last[i-1][j-1], max(last[i-1][j], last[i-1][j+1]));\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\n\t\tint ans = -1, ansx, ansy;\n\t\tFOR(j, left, right+1) {\n\t\t\tif(canuse[bottom][j]) {\n\t\t\t\tif(ans < dp[bottom][j]) {\n\t\t\t\t\tans = dp[bottom][j];\n\t\t\t\t\tansx = j;\n\t\t\t\t\tansy = bottom;\n\t\t\t\t} else if(ans == dp[bottom][j] && last[bottom][j] > last[ansy][ansx]){\n\t\t\t\t\tansx = j;\n\t\t\t\t\tansy = bottom;\n\t\t\t\t}\n\t\t\t} else if(canuse[bottom-1][j]) {\n\t\t\t\tif(ans < dp[bottom-1][j]) {\n\t\t\t\t\tans = dp[bottom-1][j];\n\t\t\t\t\tansx = j;\n\t\t\t\t\tansy = bottom-1;\n\t\t\t\t} else if(ans == dp[bottom-1][j] && last[bottom-1][j] > last[ansy][ansx]){\n\t\t\t\t\tansx = j;\n\t\t\t\t\tansy = bottom-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//REP(i,MAX_HW){\n\t\t//\tREP(j,MAX_HW){\n\t\t//\t\tcerr<<dp[i][j];\n\t\t//\t}\n\t\t//\tcerr<<endl;\n\t\t//}\n\n\t\tif(ans-1==0){\n\t\t\tcout<<\"0 0\"<<endl;\n\t\t}else{\n\t\t\tcout<<ans-1<<\" \"<<last[ansy][ansx]<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\n#define SIZE 1000\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (x >= 0 && y >= 0 && table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}/*\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}*/\n\n\t\toutput = false;\n\t\tfor (int i = 0;i < SIZE&&!output;i++) {\n\t\t\tfor (int j = 0;j < SIZE&&!output;j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tprintf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#define X first\n#define Y second\n#define MAX 1333\nusing namespace std;\n\nstruct state{\n\tstate():num(0), max(-1), mindex(0){}\n\tint num;\n\tint max;\n\tint mindex;\n};\n\nstate dp[MAX][MAX];\nbool sosuu[1000001];\nmap<int, pair<int, int> > pos;\nint dx[] = {0, -1, 0, 1};\nint dy[] = {-1, 0, 1, 0};\nint ddx[] = {-1, 0, 1};\n\nvoid era(){\n\tfill(sosuu, sosuu+1000001, true);\n\tfor(int i = 2; i <= 1000000; i++){\n\t\tif(sosuu[i]){\n\t\t\tfor(int j = 2*i; j <= 1000000; j+=i) sosuu[j] = false;\n\t\t}\n\t}\n}\n\nvoid fillNum(){\n\tint rect = 3, index = 0, count = 1;\n\tint x = MAX/2, y = MAX/2;\n\tpos[count] = pair<int, int>(x, y);\n\tdp[y][x].num = count++;\n\twhile(count <= MAX*MAX-1){\n\t\tpos[count] = pair<int, int>(++x, y);\n\t\tdp[y][x].num = count++;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tfor(int j = (i==0)?1:0; j < rect-1; j++){\n\t\t\t\tx += dx[i];\n\t\t\t\ty += dy[i];\n\t\t\t\tpos[count] = pair<int, int>(x, y);\n\t\t\t\tdp[y][x].num = count++;\n\t\t\t}\n\t\t}\n\t\trect+=2;\n\t}\n}\n\nvoid Init(int n){\n\tfor(int i = 0; i < MAX; i++){\n\t\tfor(int j = 0; j < MAX; j++){\n\t\t\tif(n>=dp[i][j].num){\n\t\t\t\tdp[i][j].max = -1;\n\t\t\t\tdp[i][j].mindex = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n  \nint dfs(int x, int y, int n){\n\tif(dp[y][x].max>=0) return dp[y][x].max;\n\tint add = 0;\n\tfor(int i = 0; i < 3; i++){\n\t\tif(dp[y+1][x+ddx[i]].num>n) continue;\n\t\tint tmp = dfs(x+ddx[i], y+1, n);\n\t\tif(add<tmp){\n\t\t\tadd = tmp;\n\t\t\tdp[y][x].mindex = dp[y+1][x+ddx[i]].mindex;\n\t\t}\n\t\telse if(add == tmp){ \n\t\t\tdp[y][x].mindex = dp[y][x].mindex<dp[y+1][x+ddx[i]].mindex?dp[y+1][x+ddx[i]].mindex:dp[y][x].mindex;\n\t\t}\n\t}\n\tdp[y][x].max = sosuu[dp[y][x].num]?add + 1:add;\n\tif(!dp[y][x].mindex&&sosuu[dp[y][x].num]) dp[y][x].mindex = dp[y][x].num;\n\treturn dp[y][x].max;\n}\n\nint main(){\n\tera();\n\tfillNum();\n\tint n, m;\n\twhile(cin >> n >> m && (n!=0||m!=0)){\n\t\tInit(n);\n\t\tint x = pos[m].X, y = pos[m].Y;\n\t\tdfs(x, y, n);\n\t\tif(dp[y][x].max==0) cout << 0 << \" \" << 0 << endl;\n\t\telse cout << dp[y][x].max << \" \" << dp[y][x].mindex << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int INF = 1e9;\n\nbool is_prime[1000100];\n\nint sieve()\n{\n    int p = 0;\n    for (int i = 0; i < 1000100; i++)\n        is_prime[i] = true;\n    is_prime[0] = is_prime[1] = false;\n    for (int i = 2; i < 1000100; i++)\n    {\n        if (is_prime[i])\n        {\n            for (int j = i * 2; j < 1000100; j += i)\n                is_prime[j] = false;\n        }\n    }\n}\n\nint rec(int num, vector<int> &dp, vector<int> &dplast, vector<vector<int>> &G)\n{\n    if (dp[num] != -1)\n        return dp[num];\n    int ret = 0;\n    for (auto x : G[num])\n    {\n        ret = max(ret, rec(x, dp, dplast, G));\n    }\n    for (auto x : G[num])\n    {\n        if (dp[x] == ret)\n            dplast[num] = max(dplast[num], dplast[x]);\n    }\n    if (dplast[num] == 0 && is_prime[num])\n        dplast[num] = num;\n    return dp[num] = ret + is_prime[num];\n}\n\nint main()\n{\n    vector<vector<int>> caves(1001, vector<int>(1001));\n    int n, m;\n    sieve();\n    while (cin >> m >> n, n | m)\n    {\n        vector<int> dp(m + 1, -1);\n        vector<int> dplast(m + 1, 0);\n        vector<vector<int>> G(m + 1, vector<int>());\n\n        for (int i = 0; i < 1001; i++)\n        {\n            for (int j = 0; j < 1001; j++)\n            {\n                caves[i][j] = INF;\n            }\n        }\n        int step = 1, code = 1, x = 500, y = 500, num = 1;\n        caves[y][x] = num++;\n        while (1)\n        {\n            for (int i = 0; i < step; i++)\n            {\n                x += code;\n                caves[y][x] = num++;\n                if (num > m)\n                    break;\n            }\n            if (num > m)\n                break;\n            for (int i = 0; i < step; i++)\n            {\n                y += code;\n                caves[y][x] = num++;\n                if (num > m)\n                    break;\n            }\n            if (num > m)\n                break;\n            step++;\n            code *= -1;\n        }\n\n        step = 1, code = 1, x = 500, y = 500;\n        if (y - 1 > 0 && caves[y - 1][x] != INF)\n            G[caves[y][x]]\n                .push_back(caves[y - 1][x]);\n        if (y - 1 > 0 && x - 1 > 0 && caves[y - 1][x - 1] != INF)\n            G[caves[y][x]].push_back(caves[y - 1][x - 1]);\n        if (y - 1 > 0 && x + 1 < 1000 && caves[y - 1][x + 1] != INF)\n            G[caves[y][x]].push_back(caves[y - 1][x + 1]);\n        while (1)\n        {\n            for (int i = 0; i < step; i++)\n            {\n                x += code;\n                if (caves[y][x] == INF)\n                    break;\n                if (y - 1 > 0 && caves[y - 1][x] != INF)\n                    G[caves[y][x]].push_back(caves[y - 1][x]);\n                if (y - 1 > 0 && x - 1 > 0 && caves[y - 1][x - 1] != INF)\n                    G[caves[y][x]].push_back(caves[y - 1][x - 1]);\n                if (y - 1 > 0 && x + 1 < 1000 && caves[y - 1][x + 1] != INF)\n                    G[caves[y][x]].push_back(caves[y - 1][x + 1]);\n            }\n            if (caves[y][x] == INF)\n                break;\n            for (int i = 0; i < step; i++)\n            {\n                y += code;\n                if (caves[y][x] == INF)\n                    break;\n                if (y - 1 > 0 && caves[y - 1][x] != INF)\n                    G[caves[y][x]].push_back(caves[y - 1][x]);\n                if (y - 1 > 0 && x - 1 > 0 && caves[y - 1][x - 1] != INF)\n                    G[caves[y][x]].push_back(caves[y - 1][x - 1]);\n                if (y - 1 > 0 && x + 1 < 1000 && caves[y - 1][x + 1] != INF)\n                    G[caves[y][x]].push_back(caves[y - 1][x + 1]);\n            }\n            if (caves[y][x] == INF)\n                break;\n            step++;\n            code *= -1;\n        }\n\n        rec(n, dp, dplast, G);\n\n        int now = n;\n        int last = 0;\n        while (1)\n        {\n            int tmp = -1;\n            int next = 0;\n            if (is_prime[now])\n                last = now;\n            if (G[now].size() == 0)\n                break;\n            for (auto x : G[now])\n            {\n                if (dp[x] > tmp)\n                {\n                    tmp = dp[x];\n                    next = x;\n                }\n            }\n            now = next;\n        }\n        cout << dp[n] << \" \" << dplast[n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\nbool prime[1100000];\nint mazen[1100][1100];\nint dp[1100][1100];\nint n, m;\nint num;\nint hen;\nbool flag;\nint jx, iy;\nint si, sj;\n\nvoid makemaze(int x, int y){\n    REP(i, hen) {\n        num++;\n        if (num > n) {\n            flag = false; break;\n        }\n\n        iy += y;\n        jx += x;\n        mazen[iy][jx] = num;\n        if (num == m) {si = iy; sj = jx;}\n    }\n}\n\nint main() {\n    REP(i, 1100000) prime[i] = true;\n    prime[0] = false; prime[1] = false;\n    for(int i=2; i<1100000; i++) {\n        if (prime[i]) {\n            for(int j=2; j<1100000/i; j++) {\n                prime[i*j] = false;\n            }\n        }\n    }\n\n    while(true) {\n        cin >> n >> m;\n        if (n==0) break;\n\n        int sq;\n        REP(i, 1100) {\n            if ((2*i+1)*(2*i+1) >= n) {\n                sq = 2*i+1; break;\n            }\n        }\n\n        // initial index\n        jx = (sq+1)/2 - 1;\n        iy = jx;\n\n        REP(i, sq+3) {\n            REP(j, sq+3) {\n                dp[i][j] = -1;\n                mazen[i][j] = -1;\n            }\n        }\n\n        mazen[iy][jx] = 1;\n        if (m==1) {\n            si = iy; sj = jx;\n        }\n\n        hen = 1;\n        num = 1;\n        flag = true;\n        int x1, y1, x2, y2;\n        while(flag) {\n            if (hen % 2 == 1) {\n                x1=1; y1=0;\n                x2=0; y2=-1;\n            } else {\n                x1=-1; y1=0;\n                x2=0; y2=1;\n            }\n            \n            makemaze(x1, y1);\n            makemaze(x2, y2);\n            hen++;\n        }\n\n        dp[si][sj] = 0;\n        int output = 0;\n        int last;\n        if (prime[mazen[si][sj]]) {\n            dp[si][sj]++;\n            output = 1;\n            last = mazen[si][sj];\n        }\n        \n        for(int i=si; i<sq; i++) {\n            REP(j, sq) {\n                if (dp[i][j]<0 || mazen[i][j]<0) continue;\n                REP(k, 3) {\n                    int mv = k-1;\n                    if (j+mv < 0 || mazen[i+1][j+mv]<0) continue;\n\n                    dp[i+1][j+mv] = max(dp[i+1][j+mv], dp[i][j]);\n                }\n            }\n\n            REP(j, sq) {\n                if (dp[i+1][j] >= 0 && prime[mazen[i+1][j]]) {\n                    dp[i+1][j]++;\n\n                    // output\n                    if (dp[i+1][j] > output) {\n                        last = mazen[i+1][j];\n                        output = dp[i+1][j];\n                    }\n                    if (dp[i+1][j] == output) {\n                        last = max(last, mazen[i+1][j]);\n                    }\n                }\n            }\n        }\n\n        if (output == 0) {\n             cout << \"0 0\" << endl;\n        } else {\n             cout << output << \" \" << last << endl;\n        }\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n\nusing namespace std;\nint holes[1005][1005],table[1005][1005];\nbool prime[1000008];\n\n\nint main(){\nint m,n,g,x,y,sx,sy,i,j;\nint dx[]={1,0,-1,0},dy[]={0,-1,0,1},d;\n\nmemset(prime,1,sizeof(prime));\nprime[0]=prime[1]=0;\nfor(i=2;i<=1000003;i++){\nif(prime[i])for(j=i*2;j<=1000003;j+=i){\nprime[j]=0;\n}\n}\n\nwhile(1){\nscanf(\"%d %d\",&m,&n);\nif(m==0&&n==0)break;\n\nmemset(holes,0,sizeof(holes));\nmemset(table,-1,sizeof(table));\ng=(int)ceil(sqrt(m));\ny=x=g/2+1;\t//縁を0でうめる\nd=3;\nholes[y][x]=1;\nfor(i=2;i<=m;i++){\nif(holes[y+dy[(d+1)%4]][x+dx[(d+1)%4]]==0){\nd=(d+1)%4;\n}\nx+=dx[d];\ny+=dy[d];\n\nholes[y][x]=i;\nif(i==n){\nsx=x;\nsy=y;\n}\n}\n\n/* for(i=0;i<=g+1;i++){\nfor(j=0;j<=g+1;j++)\nprintf(\"%3d \",holes[i][j]);\nprintf(\"\\n\");\n}\n*/\nint maxNum=0,maxCnt=0;\ntable[sy][sx]=0;\nfor(y=sy;y<=g;y++){\nfor(x=1;x<=g;x++){\nif(table[y][x]==-1)continue;\nif(prime[holes[y][x]])table[y][x]++;\nif(maxCnt<table[y][x] && holes[y][x]>0){\nmaxCnt=table[y][x];\nmaxNum=holes[y][x];\n}else if(maxCnt==table[y][x]){\nif(maxNum<holes[y][x])\nif(prime[holes[y][x]])\nmaxNum=holes[y][x];\n}\n\nfor(i=-1;i<=1;i++){\nif(table[y+1][x+i]<table[y][x]){\ntable[y+1][x+i]=table[y][x];\n}\n}\n}\n}\n\n/*cout<<endl;\nfor(i=0;i<=g+1;i++){\nfor(j=0;j<=g+1;j++)\nprintf(\"%3d \",table[i][j],holes[i][j]);\nprintf(\"\\n\");\n}*/\n\nprintf(\"%d %d\\n\",maxCnt,maxNum);\n\n\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <stdlib.h>\n#include <math.h>\n#include <list>\n#include <algorithm>\n\nusing namespace std;\n\n//平方数かどうか調べる\nint isSq(int n) {\n\tif(n <= 0) return 0;\n\n\tfor(int i = 1; i <= (int)sqrt( (double)n ) + 1; i++) {\n\t\tif( n % i == 0 && n / i == i ) return i;\n\t}\n\t\n\treturn 0;\n}\n//素数かどうか調べる\nint isPrime(int n) {\n\tif(n <= 1) return 0;\n\tint flg = 1;\n\tfor(int i = 2; i <= (int)sqrt((double)n) + 1; i++) {\n\t\tif( n % i == 0) {\n\t\t\tflg = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn flg;\n}\n\nstruct memo{\n\tint last;\n\tint pts;\n};\nstruct cave{\n\tint x;\n\tint y;\n\tint flg;\n\tint num;\n};\n\n//動的計画法で探査\n//番号が決まれば得点がきまるはず\nvoid search_cave(int n, int xpos, int ypos, vector<memo>*m, vector<vector<int>> *cv, vector<cave> *cl, int h, int w){\n\n\tif( m -> at(n).last != -1 ) {\n\t\t//探索済みの場合\n\t\treturn;\n\t} else {\n\t\t//未探索の場合\n\t\t//直下の三洞窟を探索する\n\t\t//直下三通りはすでに探索済みとする\n\n\t\tif( ypos == h - 1 || cv->at(xpos).at( ypos + 1) == 0 ) {\n\t\t\t//一番下ならば？\n\t\t\tm->at(n).pts = cl->at(n).flg;\n\t\t\tm->at(n).last = 0;\n\t\t\tif(cl->at(n).flg == 1) m->at(n).last = n;\n\t\t} else {\n\t\t\t//降りられる洞穴がある場合\n\t\t\tint indx;\n\t\t\tint point[3] = {-1,-1,-1};\n\t\t\tint last[3] = {-1,-1,-1};\n\t\t\t//左右移動できるか確認する\n\t\t\tif(( (xpos > 0) && ( ( cv->at( xpos - 1 ).at( ypos + 1 ) ) > 0  ) ) )\t{\t//左下\n\t\t\t\tint tmp = cv->at( xpos - 1 ).at( ypos + 1 );\n\t\t\t\tpoint[0] = m->at( tmp ).pts;\n\t\t\t\tlast[0] = m->at(tmp).last;\n\t\t\t}\n\t\t\tif( xpos < w - 1 && cv->at( xpos + 1 ).at( ypos + 1 )  > 0) { //右下\n\t\t\t\tint tmp = cv->at( xpos + 1 ).at( ypos + 1 );\n\t\t\t\tpoint[1] = m->at( tmp ).pts;\n\t\t\t\tlast[1] = m->at( tmp ).last;\n\t\t\t}\n\t\t\tif( cv->at( xpos  ).at( ypos + 1)  > 0 ) {\t\t\t//真下\n\t\t\t\tint tmp = cv -> at( xpos ).at( ypos + 1 );\n\t\t\t\tpoint[2] = m -> at( tmp ).pts;\n\t\t\t\tlast[2] = m -> at( tmp ).last;\n\t\t\t}\n\n\t\t\t//大小比較する\n\t\t\tif( point[0] < point[1] ) {\n\t\t\t\tindx = 1;\n\t\t\t} else if( point[0] > point[1] ) {\n\t\t\t\tindx = 0;\n\t\t\t} else {\n\t\t\t\tif(last[0] < last[1]) indx = 1;\n\t\t\t\telse indx = 0;\n\t\t\t}\n\n\t\t\tif( point[indx] < point[2] ) {\n\t\t\t\tindx = 2;\n\t\t\t} else if( point[indx] > point[2] ) {\n\t\t\t\tindx = indx;\n\t\t\t} else {\n\t\t\t\tif(last[indx] < last[2]) indx = 2;\n\t\t\t\telse indx = indx;\n\t\t\t}\n\n\t\t\tm -> at(n).pts = point[indx] + cl -> at(n).flg ;\n\t\t\tm -> at(n).last = last[indx]  ;\n\t\t\tif(last[indx] <= 0 && cl -> at(n).flg > 0) m -> at(n).last = n;\n\n\t\t}\n\t}\n}\n\nint main(void){\n\t//FILE* fp_in = freopen(\"data.txt\", \"r\", stdin);\n\n\t\n\n\twhile(1){\n\t\tint m, n;\n\t\tvector<cave> clist;\n\n\t\tcin >> m >> n;\n\t\tif( m == 0 && n == 0 ) break;\n\t\t\n\t\tcave c;\n\t\tc.x = -1;\n\t\tc.y = 0;\n\t\tc.flg = 0;\n\t\tc.num = 0;\n\t\tclist.push_back(c);\n\n\t\t//洞窟の大きさを調べる\n\t\tint dir = 0, sq = 1;\n\t\tfor(int i = 1; i <= m; i ++) {\n\t\t\tif( isSq(i) != 0 ) \n\t\t\t\tsq = isSq(i);\n\t\t\t//進む\n\t\t\tswitch(dir) {\n\t\t\t\tcase 0:\n\t\t\t\t\tc.x ++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tc.y --;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tc.x --;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tc.y ++;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//方向転換\n\t\t\tif( ( isSq( i - 1 ) != 0 ) || ( i == sq*sq + sq + 1 ) ) { \n\t\t\t\tdir ++;\n\t\t\t\tif( dir > 3 ) dir = 0;\n\t\t\t}\n\t\t\tc.flg = isPrime(i);\n\t\t\tc.num = i;\n\t\t\tclist.push_back(c);\n\t\t}\n\n\t\t//洞窟の大きさを取得する\n\t\tint x_max = 0, x_min = 0, y_max = 0, y_min = 0;\n\t\tfor(int i = 1; i < clist.size(); i++) {\n\t\t\tif( clist.at(i).x < x_min ) x_min = clist.at(i).x;\n\t\t\tif( clist.at(i).x > x_max ) x_max = clist.at(i).x;\n\t\t\tif( clist.at(i).y < y_min ) y_min = clist.at(i).y;\n\t\t\tif( clist.at(i).y > y_max ) y_max = clist.at(i).y;\n\t\t}\n\n\t\t//上端のy座標を0にセット\n\t\tfor(int i = 1; i < clist.size(); i++) {\n\t\t\tclist.at(i).y -= y_min;\n\t\t\tclist.at(i).x -= x_min;\n\t\t}\n\t\t\n\t\t//洞穴を意味するvector\n\t\tvector<vector<int>> caves;\n\t\tfor(int i = 0; i <= x_max - x_min; i++) {\n\t\t\tvector<int> newcave;\n\t\t\tfor(int j = 0; j <= y_max - y_min; j++)\n\t\t\t\tnewcave.push_back(0);\n\t\t\tcaves.push_back(newcave);\n\t\t}\n\n\t\t//番号をセットする\n\t\tfor(int i = 1; i < clist.size(); i++) \n\t\t\tcaves.at( clist.at(i).x ).at( clist.at(i).y ) = clist.at(i).num;\n\n\t\t//メモ用vector\n\t\tvector<memo> memory;\n\t\tfor(int i = 0; i < clist.size() + 2; i++) {\n\t\t\tmemo newmemo;\n\t\t\tnewmemo.last = -1;\n\t\t\tnewmemo.pts = 0;\n\t\t\tmemory.push_back(newmemo);\n\t\t}\n\n\t\tint height = caves.at(0).size();\n\t\tint width = caves.size();\n\t\tint ans[2];\n\t\tint flg;\n\t\n\n\t\t//一番下から調べる\n\t\tfor(int i = height - 1; i >= 0; i--) {\n\t\t\tfor(int j = 0; j < width; j++) {\n\t\t\t\tint num = caves.at(j).at(i);\n\t\t\t\tsearch_cave(num, j, i, &memory, &caves, &clist, height, width);\n\t\t\t\tif( num == n ) {\n\t\t\t\t\tflg = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg) break;\n\t\t}\n\t\t\n\n\t\tans[0] = memory.at(n).pts;\n\t\tans[1] = memory.at(n).last;\n\t\tif( ans[0] == 0 ) ans[1] = 0;\n\n\t\tcout << ans[0] << \" \" << ans[1] << endl;\n\t}\n\n\t//while(1){}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nint caves[2000][2000];\n\nbool sieve[1000001];\nint SX, SY;\n\ntypedef pair<int, int> PII;\n\nPII dp[2000][2000];\nbool vis[2000][2000];\n\nint main()\n{\n\tint nx, ny;\n\tfill(sieve, sieve + 1000001, true);\n\tsieve[0] = sieve[1] = false;\n\tfor(int i = 2; i * i <= 1000000; ++i) {\n\t\tif(sieve[i]) {\n\t\t\tfor(int j = i * i; j <= 1000000; j += i) {\n\t\t\t\tsieve[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint M, N;\n\twhile (cin>>M>>N, M||N) {\n\t\tmemset(caves, -1, sizeof(caves));\n\t\t\n\t\tfor (int j=0; j<2000; j++) {\n\t\t\tfor (int i=0; i<2000; i++) {\n\t\t\t\tdp[i][j] = PII(0, -1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tnx = ny = 2000/2;\n\t\tint len=1, num=2;\n\t\tint d = 0;\n\t\t\n\t\tcaves[nx][ny] = 1;\n\t\t\n\t\twhile (num <= M) {\n\t\t\tfor (int j=0; j<len; j++) {\n\t\t\t\tnx += dx[d];\n\t\t\t\tny += dy[d];\n\t\t\t\tcaves[nx][ny] = num++;\n\t\t\t\tif (num > M) break;\n\t\t\t}\n\t\t\td++; d %= 4;\n\t\t\tif (num > M) break;\n\t\t\t\n\t\t\tfor (int j=0; j<len; j++) {\n\t\t\t\tnx += dx[d];\n\t\t\t\tny += dy[d];\n\t\t\t\tcaves[nx][ny] = num++;\n\t\t\t\tif (num > M) break;\n\t\t\t}\n\t\t\t\n\t\t\td++;\n\t\t\td %= 4;\n\t\t\tlen++;\n\t\t}\n\t\t\n\t\tfor (int i=0; i<2000; i++) {\n\t\t\tfor (int j=0; j<2000; j++) {\n\t\t\t\tif (caves[j][i] == N) {\n\t\t\t\t\tSX = j, SY = i;\n\t\t\t\t\tif(sieve[N]) {\n\t\t\t\t\t\tdp[i][j] = PII(1, N);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j] = PII(0, -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t#if 1\n\t\tfor (int i=1000-10; i<1000+10; i++) {\n\t\t\tfor (int j=1000-10; j<1000+10; j++) {\n\t\t\t\tprintf(\"%3d\", caves[j][i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t#endif\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tvis[SY][SX] = true;\n\t\tfor(int i = 0; i < 2000 - 1; ++i) {\n\t\t\tfor(int j = 0; j < 2000; ++j) {\n\t\t\t\tif(vis[i][j] == false) continue;\n\t\t\t\tfor(int k = -1; k <= 1; ++k) {\n\t\t\t\t\tint nx = j + k;\n\t\t\t\t\tif(nx < 0 || nx >= 2000) continue;\n\t\t\t\t\tint add = dp[i][j].first;\n\t\t\t\t\tint maxP = dp[i][j].second;\n\t\t\t\t\tif(caves[nx][i + 1] > 0 && sieve[caves[nx][i + 1]]) {\n\t\t\t\t\t\tadd++;\n\t\t\t\t\t\tmaxP = caves[nx][i + 1];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i + 1][nx] = max(dp[i + 1][nx], PII(add, maxP));\n\t\t\t\t\tvis[i + 1][nx] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tPII ans(-1, -1);\n\t\tfor(int j = 0; j < 2000; ++j) {\n\t\t\tans = max(ans, dp[2000 - 1][j]);\n\t\t}\n\t\tcout << ans.first << ' ' << max(0, ans.second) << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iomanip>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define pii pair<int,int>\n\n#define MAXM 1000001\n#define MAXSQM 1002\nint diff[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nint map[MAXSQM][MAXSQM] = {};\nbool furui[MAXM] = {};\npii dpmap[MAXSQM][MAXSQM] = {};\n\nvoid init_map(int m){\n    fill_n(*map,MAXSQM*MAXSQM,0);\n    fill_n(*dpmap,MAXSQM*MAXSQM,pii(-1,-1));\n    int idx=MAXSQM/2,idy=MAXSQM/2;\n    int dir=0;\n    int c=1;\n    for(int i=1;c<=m;i++){\n        for(int j=0;j<i&&c<=m;j++){\n            map[idx][idy]=c++;\n            idx+=diff[dir][0];\n            idy+=diff[dir][1];\n        }\n        dir=(dir+1)%4;\n        for(int j=0;j<i&&c<=m;j++){\n            map[idx][idy]=c++;\n            idx+=diff[dir][0];\n            idy+=diff[dir][1];\n        }\n        dir=(dir+1)%4;\n    }\n}\n\npii dp(int n){\n    int nx,ny;\n    for(nx=0;nx<MAXSQM;nx++){\n        for(ny=0;ny<MAXSQM;ny++){\n            if(n==map[nx][ny]) break;\n        }\n        if(n==map[nx][ny]) break;\n    }\n\n    pii ans=pii(0,0);\n\n    if(!furui[map[nx][ny]]){\n        dpmap[nx][ny]=pii(1,map[nx][ny]);\n        ans=dpmap[nx][ny];\n    }\n    else\n    {\n        dpmap[nx][ny]=pii(0,0);\n    }\n\n    for(int j=ny;j>=1;j--){\n        for(int i=0;i<MAXSQM;i++){\n            if(map[i][j]==0 || dpmap[i][j].first==-1) continue;\n            for(int k=-1;k<=1;k++){\n                if(map[i+k][j-1]==0) continue;\n                if(!furui[map[i+k][j-1]]){\n                    dpmap[i+k][j-1]=max(pii(dpmap[i][j].first+1,map[i+k][j-1]), dpmap[i+k][j-1]);\n                }\n                else\n                {\n                    dpmap[i+k][j-1]=max(dpmap[i][j], dpmap[i+k][j-1]);\n                }\n                ans=max(ans,dpmap[i+k][j-1]);\n            }\n        }\n    }\n    return ans;\n}\n\nint main(){\n    while(1){\n        int m,n;\n        cin>>m>>n;\n        if(m==0) break;\n\n        furui[0]==furui[1]==true;\n        for(int i=2;i<MAXSQM;i++){\n            for(int j=2;i*j<MAXM;j++){\n                if(!furui[i]){\n                    furui[i*j]=true;\n                }\n            }\n        }\n        init_map(m);\n        pii p=dp(n);\n\n        /*int b=503,a=487;\n        for(int i=a-5;i<a+5;i++){\n            for(int j=b-5;j<b+5;j++){\n                cout<<std::setw(4)<<map[j][i];\n            }\n            cout<<endl;\n        }\n        for(int i=a-5;i<a+5;i++){\n            for(int j=b-5;j<b+5;j++){\n                cout<<setw(4)<<dpmap[j][i].first;\n            }\n            cout<<endl;\n        }*/\n        cout<<p.first<<\" \"<<p.second<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define rrep(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); --i)\n#define sz(c) ((int)c.size())\n#define all(c) c.begin(), c.end()\n\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\nconst int INF = 1e9;\ntemplate <class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T> using heap = priority_queue<T, vector<T>, greater<T>>;\n\nint DY[4] = {-1, 0, 1, 0};\nint DX[4] = {0, 1, 0, -1};\n\nbool inrange(int x, int l, int r) {\n    return l <= x and x < r;\n}\n\nint table[1010][1010];\npii num2pos[1000006];\nbool is_prime[1000006];\n\nvoid solve(int M, int N) {\n    pii p = num2pos[N];\n    vvi dp(1010, vi(1010, 0));\n    queue<pii> q;\n    q.push(p);\n    dp[p.first][p.second] = is_prime[N];\n    vvi valid(1010, vi(1010, 0));\n    valid[p.first][p.second] = 1;\n    rep(i, p.first, 1010) {\n        rep(j, 0, 1010) {\n            if (!valid[i][j]) continue;\n            rep(d, -1, 2) {\n                int ii = i + 1;\n                int jj = j + d;\n                if (inrange(jj, 0, 1010) && inrange(ii, 0, 1010) && table[ii][jj] <= M) {\n                    valid[ii][jj] = 1;\n                    if (chmax(dp[ii][jj], dp[i][j] + is_prime[table[ii][jj]])) {\n                        q.push({ii, jj});\n                    }\n                }\n            }\n        }\n    }\n\n    int mx = 0;\n    int last = 0;\n    rrep(i, 0, 1010) {\n        rrep(j, 0, 1010) {\n            if (valid[i][j] && is_prime[table[i][j]]) {\n                if (mx < dp[i][j]) {\n                    mx = dp[i][j];\n                    last = table[i][j];\n                } else if (mx == dp[i][j]) {\n                    if (last < table[i][j]) {\n                        last = table[i][j];\n                    }\n                }\n            }\n        }\n    }\n    cout << mx << \" \" << last << endl;\n}\n\nsigned main() {\n    memset(is_prime, true, sizeof(is_prime));\n    rep(i, 0, 1010) rep(j, 0, 1010) table[i][j] = INF;\n    is_prime[0] = is_prime[1] = false;\n    rep(i, 2, 1000006) {\n        if (!is_prime[i]) continue;\n        rep(j, 2, 1000006) {\n            if (i * j > 1000006) break;\n            is_prime[i * j] = false;\n        }\n    }\n\n    int y = 505;\n    int x = 505;\n    int dir = 1;\n    int next_turn = 1;\n    queue<int> seq;\n    seq.push(1);\n    rep(i, 2, 1000006) {\n        seq.push(i);\n        seq.push(i);\n    }\n    rep(i, 1, 1000003) {\n        table[y][x] = i;\n        num2pos[i] = {y, x};\n        y += DY[dir];\n        x += DX[dir];\n        if (i == next_turn) {\n            dir = (dir + 3) % 4;\n            next_turn += seq.front(); seq.pop();\n        }\n    }\n\n    while (1) {\n        int M, N;\n        cin >> M >> N;\n        if (M == 0 && N == 0) break;\n        solve(M, N);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\n\nconst Int N = 1123456;\nbool is_prime[N];\nconst Int inf = 1LL << 50;\n\nint main() {\n   for(Int i = 0; i < N; ++i) {\n      is_prime[i] = true;\n   }\n   is_prime[0] = is_prime[1] = false;\n   for(Int i = 2; i * i < N; ++i) {\n      if( is_prime[i] ) {\n         for(Int k = 2*i; k < N; k+=i) {\n            is_prime[k] = false;\n         }\n      }\n   }\n   for(;;) {\n      Int n, m;\n      std::cin >> m >> n;\n      if( n == 0 and m == 0 ) break;\n      auto field = std::vector<std::vector<Int>>(1024, std::vector<Int>(1024, -1));\n      Int y = 512;\n      Int x = 512;\n      Int dx[] = {1, 0,-1, 0};\n      Int dy[] = {0,-1, 0, 1};\n      Int k = 3;\n      Int i = 1;\n      while( i <= m ) {\n         field[y][x] = i;\n         i += 1;\n         {\n            Int nx = x + dx[(k+1)%4], ny = y + dy[(k+1)%4];\n            if( field[ny][nx] == -1 ) {\n               k = (k+1) % 4;\n            }\n         }\n         Int nx = x + dx[k], ny = y + dy[k];\n         x = nx;\n         y = ny;\n      }\n      /*\n      for(Int y = 512-3; y < 512+3; ++y) {\n         for(Int x = 512-3; x < 512+3; ++x) {\n            std::cout << field[y][x] << ' ';\n         }\n         std::cout << std::endl;\n      }\n      */\n      auto dp = std::vector<std::vector<std::pair<Int,Int>>>(1024, std::vector<std::pair<Int,Int>>(1024, std::make_pair(-inf,-1)));\n      for(Int y = 0; y < 1024; ++y) {\n         for(Int x = 0; x < 1024; ++x) {\n            if( field[y][x] == n ) {\n               dp[y][x] = std::make_pair(0, field[y][x]);\n               //dp[y][x] = is_prime[field[y][x]] ? 1 : 0;\n            }\n         }\n      }\n      for(Int y = 1; y < 1024; ++y) {\n         for(Int x = 0; x < 1024; ++x) {\n            if( x-1 >= 0 ) {\n               if( dp[y][x].first < dp[y-1][x-1].first ) {\n                  dp[y][x] = dp[y-1][x-1];\n               }\n               //dp[y][x] = std::max(dp[y][x], dp[y-1][x-1]);\n            }\n            if( dp[y][x].first < dp[y-1][x].first ) {\n               dp[y][x] = dp[y-1][x];\n            }\n            //dp[y][x] = std::max(dp[y][x], dp[y-1][x]);\n            if( x+1 < 1024 ) {\n               if( dp[y][x].first < dp[y-1][x+1].first ) {\n                  dp[y][x] = dp[y-1][x+1];\n               }\n               //dp[y][x] = std::max(dp[y][x], dp[y-1][x+1]);\n            }\n            if( is_prime[field[y][x]] ) {\n               dp[y][x].first += 1;\n               dp[y][x].second = field[y][x];\n               //dp[y][x] += 1;\n            }\n         }\n      }\n      // for(Int y = 512-3; y < 512+3; ++y) {\n      //    for(Int x = 512-3; x < 512+3; ++x) {\n      //       std::cout << dp[y][x] << ' ';\n      //    }\n      //    std::cout << std::endl;\n      // }\n      std::pair<Int,Int> res(-inf,-1);\n      //Int res = -inf, res_i = -1;\n      for(Int y = 0; y < 1024; ++y) {\n         for(Int x = 0; x < 1024; ++x) {\n            if( res < dp[y][x] ) {\n               res = dp[y][x];\n            }\n         }\n      }\n      if( res.first == 0 ) {\n         res.second = 0;\n      }\n      std::cout << res.first << ' ' << res.second << std::endl;\n   }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1000000;\nconst int WIDTH = 1005;\nconst int S = 500;\nconst int INF = 100000000;\n\nint prime[N];\nint ma[WIDTH][WIDTH];\nint dis[WIDTH][WIDTH];\nint did[WIDTH][WIDTH];\nconst int dirx[4] = {1, 0, -1, 0};\nconst int diry[4] = {0, -1, 0, 1};\ntypedef pair<int, int> P;\n\nint sx, sy;\nint ans, fin;\n\nvoid BFS_prime();\nvoid BFS_ans(int n);\n\nvoid Eratos(){\n\tfor(int i=0; i<N; i++){\n\t\tprime[i] = 1;\n\t}\n\n\tprime[0] = prime[1] = 0;\n\tfor(int i=2; i*i <= N; i++){\n\t\tfor(int j=i*2; j<N; j += i){\n\t\t\tprime[j] = 0;\n\t\t}\n\t}\n\n}\n\nvoid create(int m, int n){\n\tmemset(ma, 0, sizeof(ma));\n\tint cnt = 1;\n\tint dx = 0;\n\tint dy = 0;\n\tint ndir = 0;\n\tint lim = 1;\n\tbool f = false;\n\twhile(1){\n\t\tfor(int i=0; i<lim; i++){\n\n\t\t\tma[S + dy][S + dx] = cnt;\n\t\t\tif(cnt == n){\n\t\t\t\tsx = S + dx;\n\t\t\t\tsy = S + dy;\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tif(cnt == m+1){\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdx += dirx[ndir % 4];\n\t\t\tdy += diry[ndir % 4];\n\t\t}\n\t\tif(f) break;\n\t\tndir++;\n\t\tfor(int i=0; i<lim; i++){\n\n\t\t\tma[S + dy][S + dx] = cnt;\n\t\t\tif(cnt == n){\n\t\t\t\tsx = S + dx;\n\t\t\t\tsy = S + dy;\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tif(cnt == m+1){\n\t\t\t\tf = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdx += dirx[ndir % 4];\n\t\t\tdy += diry[ndir % 4];\n\t\t}\n\t\tndir++;\n\t\tlim++;\n\t\tif(f) break;\n\t}\n}\n\nint main(void){\n\tEratos();\n\n\twhile(1){\n\t\tans = 0;\n\t\tfin = 0;\n\t\tint m, n;\n\t\tcin >> m >> n;\n\t\tif(m == 0 && n == 0) break;\n\t\tcreate(m, n);\n\n\t\t/*\n\t\tfor(int i=S-30; i<S+30; i++){\n\t\t\tfor(int j=S-30; j<S+30; j++){\n\t\t\t\tprintf(\"%3d \", ma[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\t*/\n\n\t\tBFS_prime();\n\t\t/*\n\t\tfor(int i=S-30; i<S+30; i++){\n\t\t\tfor(int j=S-30; j<S+30; j++){\n\t\t\t\tif(dis[i][j] == INF){\n\t\t\t\t if(i == sy && j == sx) printf(\"S \");\n\t\t\t\t else printf(\"* \");\n\n\t\t\t\t}else printf(\"%1d \", dis[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\t*/\n\t\tBFS_ans(m);\n\t\t/*\n\t\tfor(int i=S-30; i<S+30; i++){\n\t\t\tfor(int j=S-30; j<S+30; j++){\n\t\t\t\tif(dis[i][j] == INF) printf(\"* \");\n\t\t\t\telse printf(\"%1d \", dis[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\t*/\n\t\tprintf(\"%d %d\\n\", ans, fin);\n\n\t}\n\n\treturn 0;\n}\n\nvoid BFS_prime(){\n\tqueue<P> que;\n\tfor(int i=0; i<WIDTH; i++){\n\t\tfor(int j=0; j<WIDTH; j++){\n\t\t\tdis[i][j] = INF;\n\t\t}\n\t}\n\n\t//printf(\"%d %d\\n\", sy, sx);\n\tque.push(P(sy, sx));\n\tif(prime[ma[sy][sx]] == 1) dis[sy][sx] = 1;\n\n\twhile(que.size()){\n\t\tP p = que.front(); que.pop();\n\n\t\t//printf(\"%d %d\\n\", p.first, p.second);\n\t\tif(ma[p.first][p.second] == 0) continue;\n\n\t\tfor(int i=-1; i <= 1; i++){\n\t\t\tint nx = p.second + i;\n\t\t\tint ny = p.first + 1;\n\n\t\t\tif(dis[ny][nx] == INF){\n\t\t\t\t//printf(\"nynx:%d %d\\n\", ny, nx);\n\n\t\t\t\tque.push(P(ny, nx));\n\t\t\t\tif(prime[ma[ny][nx]] == 1) dis[ny][nx] = 1;\n\t\t\t\telse dis[ny][nx] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid BFS_ans(int n){\n\tqueue<P> que;\n\tfor(int i=0; i<WIDTH; i++){\n\t\tfor(int j=0; j<WIDTH; j++){\n\t\t\tif(dis[i][j] == INF) dis[i][j] = 0;\n\t\t}\n\t}\n\tfor(int i=0; i<WIDTH; i++){\n\t\tfor(int j=0; j<WIDTH; j++){\n\t\t\tdid[i][j] = 0;\n\t\t}\n\t}\n\n\tque.push(P(sy, sx));\n\tif(prime[ma[sy][sx]] == 1){\n\t\tdis[sy][sx] = 1;\n\t\tif(ans < dis[sy][sx]){\n\t\t\tans = dis[sy][sx];\n\t\t\tfin = ma[sy][sx];\n\t\t}\n\t}\n\n\twhile(que.size()){\n\t\tP p = que.front(); que.pop();\n\n\t\tif(ma[p.first][p.second] == 0) continue;\n\n\t\tfor(int i=-1; i <= 1; i++){\n\t\t\tint nx = p.second + i;\n\t\t\tint ny = p.first + 1;\n\n\t\t\tif(did[ny][nx] == 0){\n\t\t\t\tdid[ny][nx] = 1;\n\t\t\t\tque.push(P(ny, nx));\n\t\t\t\tif(dis[ny][nx] == 1) {\n\t\t\t\t\tdis[ny][nx] = 1 + max(dis[ny-1][nx-1], max(dis[ny-1][nx], dis[ny-1][nx+1]));\n\t\t\t\t}else{\n\t\t\t\t\tdis[ny][nx] = max(dis[ny-1][nx-1], max(dis[ny-1][nx], dis[ny-1][nx+1]));\n\t\t\t\t}\n\t\t\t\tif(ma[ny][nx] <= n && ma[ny][nx] != 0){\n\t\t\t\t\t//printf(\"%d %d %d\\n\", dis[ny][nx], ma[ny][nx], n);\n\t\t\t\t\tif(ans < dis[ny][nx]){\n\t\t\t\t\t\tans = dis[ny][nx];\n\t\t\t\t\t\tfin = ma[ny][nx];\n\t\t\t\t\t}else if(ans == dis[ny][nx] && fin < ma[ny][nx] && prime[ma[ny][nx]] == 1){\n\t\t\t\t\t\tfin = ma[ny][nx];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS; typedef istringstream ISS;\ntypedef long long LL;\ntypedef pair<int, int> PII;  typedef pair<LL, LL> PLL;\ntypedef vector<int>    VI;   typedef vector<VI>   VVI;   typedef vector<VVI>   VVVI;\ntypedef vector<LL>     VLL;  typedef vector<VLL>  VVLL;  typedef vector<VVLL>  VVVLL;\ntypedef vector<double> VD;   typedef vector<VD>   VVD;   typedef vector<VVD>   VVVD;\ntypedef vector<string> VS;   typedef vector<VS>   VVS;   typedef vector<VVS>   VVVS;\ntypedef vector<bool>   VB;   typedef vector<VB>   VVB;   typedef vector<VVB>   VVVB;\ntypedef vector<PII>    VPII; typedef vector<VPII> VVPII; typedef vector<VVPII> VVVPII;\ntypedef vector<PLL>    VPLL; typedef vector<VPLL> VVPLL; typedef vector<VVPLL> VVVPLL;\n\ntypedef unsigned int  UI;\ntypedef vector<UI>    VUI;\ntypedef vector<VUI>   VVUI;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x)  (x).begin(),(x).end()\n#define RALL(x) (x).rbegin(),(x).rend()\n#define RANGEBOX(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define RANGE(x, l, r) ((l) <= (x) && (x) <= (r))\n#define rep(i, N)  for (int i = 0; i < (int)(N); i++)\n#define rrep(i, N) for (int i = N - 1; i >= 0; i--)\n#define REP(i, init, N)  for (int i = (init); i < (int)(N); i++)\n#define RREP(i, N, last) for (int i = (init - 1); i >= last; i--)\n#define MAXUD(orig, target) orig = max(orig, target)\n#define MINUD(orig, target) orig = min(orig, target)\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a)   { OSS oss; oss << a; return oss.str(); };\n\ntemplate<typename T=int> inline void dump(vector<T> vs, bool ent=false) { rep(i, vs.size()) cout << vs[i] << (i+1==vs.size() ? '\\n' : ' '); if (ent) cout << endl; }\ntemplate<typename T = int> inline void dump(vector<vector<T>> vs, bool ent = false) { rep(i, vs.size()) dump<T>(vs[i]); if (ent) cout << endl; }\n\nconst int    INF  = 0x3f3f3f3f;\nconst LL     INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int    DX[] = {1,  0, -1, 0};\nconst int    DY[] = {0, -1,  0, 1};\nconst double EPS  = 1e-12;\n// const double PI   = acos(-1.0);\n// lambda: [](T1 x)->T2{return y;}\n// simple lambda: [](T x){return x;}\n\nVB prime;\n// O(sqrt(n) * n)\nvoid initprime(LL num) {\n\tprime = VB(num + 1, true);\n\tprime[1] = prime[0] = false;\n\tfor (LL i = 2; i * i <= num; i++) {\n\t\tif (prime[i]) {\n\t\t\tfor (LL j = i + i; j <= num; j += i) {\n\t\t\t\tprime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst int MAX_M = 1000010;\nconst int HW = 1010;\nconst int OFFSET = 505;\nVVI ts = VVI(HW, VI(HW));\nVPII toIdx(MAX_M);\nint M, N;\n\nvoid gen_ts() {\n    int dir = 0;\n    int x = OFFSET, y = OFFSET;\n    int idx = 1;\n    int cnt = 1;\n    ts[y][x] = 1;\n    while (true) {\n        rep(i, 2) {\n            rep(j, cnt) {\n                ++idx;\n                if (idx > MAX_M){ return; }\n                x += DX[dir];\n                y += DY[dir];\n                ts[y][x] = idx;\n                toIdx[idx] = MP(y, x);\n            }\n            dir = (dir + 1) % 4;\n\n        }\n        ++cnt;\n    }\n}\n\nVVPII memo(HW, VPII(HW));\n\nPII dfs(PII p) {\n    int x = p.snd;\n    int y = p.fst;\n    if (memo[y][x].fst) return memo[y][x];\n\n    int num = ts[y][x];\n    bool is_b = prime[num];\n\n    PII res = is_b ? MP(1, num) : MP(0, 0);\n\n    rep(i, 3) {\n        int nx = x + (i - 1);\n        int ny = y + 1;\n        int nnum = ts[ny][nx];\n        if (nnum != 0 && nnum <= M) {\n            PII tmp = dfs(MP(ny, nx));\n            tmp.fst += is_b;\n            res = max(res, tmp);\n        }\n    }\n\n    return memo[y][x] = res;\n}\n\n// price, num\nPII solve() {\n    memo = VVPII(HW, VPII(HW));\n    PII start = toIdx[N];\n    PII res = dfs(start);\n    return res;\n}\n\nint main(void) {\n    initprime(1000010);\n    gen_ts();\n\n    while (cin >> M >> N, M) {\n        PII x = solve();\n        cout << x.fst << \" \" << x.snd << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\n#define MP make_pair\n#define PB push_back\n#define MAX_N 1020000\n#define X first\n#define Y second\n\nconst int STX = 505, STY = 505;\n\nint id[2010][2010];\nbool is_prime[MAX_N+1];\nvector<pair<int, int> > coord;\n\nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++) {\n    if(is_prime[i]) {\n      for(int j=i*i; j<=MAX_N; j+=i) {\n\tis_prime[j] = false;\n      }\n    }\n  }\n}\n\nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  /*\n  const int dx[] = {1,0,-1,0};\n  const int dy[] = {0,-1,0,1};\n  */\n  coord.PB(MP(0, 0)); // no use\n  coord.PB(MP(x, y)); // cnt = 1\n  cnt ++;\n\n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt <= MAX_N) {\n    a += 2;\n    for(int i=0; i<a; i++) {\n      y --;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      x --;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      y ++;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      x ++;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    x++, y++;\n  }\n  /*\n  for(int i=1; ; i++) {\n    if(i%4 == 0) x--;\n    \n    // marking\n    for(int j=0; j<(i/4+1)*2; j++) {\n      x += dx[i%4], y += dy[i%4];\n      cout << x << \",\" << y;// << endl;\n      id[y][x] = ++ cnt; cout << \" \" << cnt << endl;\n      coord.PB(MP(x, y));\n      if(cnt == 50) return;\n    }\n  }\n  */\n}\n\nint dp[MAX_N+1];\n\nint main() {\n  \n  Sieve();\n  MakeMap();\n  \n  int m, n;\n  \n  while(cin >> m >> n && (m|n)) {\n    fill(dp, dp+MAX_N+1, -1);\n    dp[n] = is_prime[n];\n    \n    queue<pair<int, int> > que;\n    que.push(coord[n]);\n    \n    while(!que.empty()) {\n      pair<int, int> now = que.front(); que.pop();\n      int noid = id[now.Y][now.X];\n      \n      for(int i=-1; i<=1; i++) {\n\tpair<int, int> nex = MP(now.X+i, now.Y+1);\n\t\n\tint neid = id[nex.Y][nex.X];\n\tif(neid <= m) {\n\t  if(dp[neid] < dp[noid] + is_prime[neid]) {\n\t    dp[neid] = dp[noid] + is_prime[neid];\n\t    que.push(nex);\n\t  }\n\t}\n      }\n    }\n    \n    int res = dp[n], lastid;\n    if(is_prime[n]) lastid = n;\n    else lastid = -1;\n    \n    for(int i=1; i<=m; i++) {\n      if(res <= dp[i] && is_prime[i]) {\n\tres = dp[i];\n\tlastid = max(lastid, i);\n      }\n    }\n    \n    if(res == 0) cout << \"0 0\" << endl;\n    else cout << res << \" \" << lastid << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\n#define mp make_pair\ntypedef pair<int,int> pii;\n\npii fill(vector<vector<int>> &maze, int x, int y, int dir, int k, int s) {\n  for (int i = 0; i < k; i++) {\n    maze[y + i * dy[dir]][x + i * dx[dir]] = s++;\n  }\n  return mp(x + k * dx[dir], y + k * dy[dir]);\n}\n\nvoid make(vector<vector<int>> &maze) {\n  pii now = mp(2000, 2000);\n  int k = 1;\n  int num = 1;\n  while(num <= 1000000) {\n    now = fill(maze, now.first, now.second, 0, k, num); num += k;\n    now = fill(maze, now.first, now.second, 1, k, num); num += k;\n    k++;\n    now = fill(maze, now.first, now.second, 2, k, num); num += k;\n    now = fill(maze, now.first, now.second, 3, k, num); num += k;\n    k++;\n  }\n  \n}\n\nint isprime[1000010];\n\nvoid era() {\n  for (int i = 0; i < 1000010; i++) {\n    isprime[i] = 1;\n  }\n  isprime[0] = isprime[1] = 0;\n  for (int i = 2; i < 1000010; i++) {\n    if (isprime[i]) {\n      for (int j = i + i; j < 1000010; j += i) {\n        isprime[j] = 0;\n      }\n    }\n  }\n}\n\nvoid solve(vector<vector<int>> &maze, int m, int n) {\n  int sx, sy;\n  for (int i = 0; i < 4000; i++) {\n    for (int j = 0; j < 4000; j++) {\n      if (maze[i][j] == n) {\n        sx = j, sy = i;\n      }\n    }\n  }\n  vector<vector<int>> dp(4000, vector<int>(4000, -1));\n  dp[sy][sx] = isprime[maze[sy][sx]];\n  for (int i = 0; i < 3999; i++) {\n    for (int j = 0; j < 4000; j++) {\n      if (maze[i][j] > m) continue;\n      if (dp[i][j] == -1) continue;\n      if (j >= 1) dp[i + 1][j - 1] = max(dp[i + 1][j - 1], dp[i][j] + isprime[maze[i + 1][j - 1]]);\n      dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + isprime[maze[i + 1][j]]);\n      if (j < 3999) dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + isprime[maze[i + 1][j + 1]]);\n    }\n  }\n\n\n  int ma = 0;\n  int ma_ind = 0;\n  for (int i = 0; i < 4000; i++) {\n    for (int j = 0; j < 4000; j++) {\n      if (maze[i][j] > m) continue;\n      if (ma <= dp[i][j] && isprime[maze[i][j]]) {\n        if (ma < dp[i][j]) {\n          ma = dp[i][j];\n          ma_ind = maze[i][j];\n        } else {\n          if (ma_ind < maze[i][j]) ma_ind = maze[i][j];\n        }\n      }\n    }\n  }\n  if (ma == 0) {\n    cout << \"0 0\" << endl;\n  } else {\n    cout << ma << \" \" << ma_ind << endl;\n  }\n}\n\nint main() {\n  vector<vector<int>> maze(4000, vector<int>(4000, 0));\n  make(maze);\n  era();\n\n  int n, m;\n  while(cin >> m >> n, m != 0) {\n    solve(maze, m, n);\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            /*\n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n \nbool ona(vector<pa2> v1,vector<pa2> v2){\n\tif(v1.size()!=v2.size()) return false;\n\tint l=v1.size();\n\tfor(int i=0;i<l;i++)if(v1[i]!=v2[i])return false;\n\treturn true;\n\n}\nint suuji[2000][2000]={0};\nint a[2000][2000];\npa2 dp[2000][2000];\nint is[1000020]={0};\nvector<int>sosuu; \n   signed main(){\n   \t\n   \tsosuu.pb(2);\n   \tsosuu.pb(3);\n   \tsosuu.pb(5);\n   \tsosuu.pb(7);\n   \tfor(int i=11;i<=1000000;i+=2){\n   \t\tif(i%3==0) continue;\n   \t\tif(i%5==0) continue;\n   \t\tbool bo=true;\n   \t\tfor(auto v:sosuu){\n   \t\t\tif(i%v==0){\n   \t\t\t\tbo=false;\n   \t\t\t\tbreak;\n   \t\t\t}\n   \t\t\tif(v*v>i){\n   \t\t\t\tbreak;\n   \t\t\t}\n   \t\t}\n   \t\tif(bo)\t\tsosuu.pb(i);\n   \t}\n   \tfor(auto v:sosuu)is[v]=1;\n   \tint x=1000,y=1000;\n   \tint cnt=1,muki=0,jou=1,imajou=0,mukik=0;\n   \twhile(cnt<=1000010){\n   \tsuuji[x][y]=cnt;\n   \t\t//if(cnt<43)cout<<x-1000<<\" \"<<y-1000<<\" \"<<cnt<<endl;\n   \t\tcnt++;\n   \t\t\n   \t\tif(imajou==jou){\n   \t\t\tif(mukik%2==1)jou++;\n   \t\t\timajou=0;\n   \t\t\tmukik++;\n   \t\t\tmuki++;\n   \t\t\tmuki%=4;\n   \t\t}\n   \t\timajou++;\n   \t\tx+=dx[muki];\n   \t\ty+=dy[muki];\n   \t}\n\n   \twhile(1){\n   \t//\treturn 0;\n   \t\tint m, n;\n   \tcin>>m>>n;\n   \t\tif(m==0) return 0;\n   \t\tif(n==0) return 0;\n   \t\tfor(int i=0;i<2000;i++)for(int j=0;j<2000;j++)dp[i][j]={0,0};\n   \t\t\n   \t\tfor(int i=1980;i>=0;i--)for(int j=3;j<=1998;j++){\n   \t\t\tif(suuji[i][j]>0 && suuji[i][j]<=m && is[suuji[i][j]]==1){\n   \t\t\t\tdp[i][j].x =1;\n   \t\t\t\tdp[i][j].y =suuji[i][j];\n   \t\t\t//\tcout<<suuji[i][j]<<endl;\n   \t\t\t}\n   \t\t\tpa2 er={-10,-10};\n   \t\t\tif(er.x<dp[i+1][j-1].x || (er.x==dp[i+1][j-1].x && er.y<dp[i+1][j-1].y) ) er=dp[i+1][j-1];\n   \t\t\tif(er.x<dp[i+1][j].x || (er.x==dp[i+1][j].x && er.y<dp[i+1][j].y) ) er=dp[i+1][j];\n   \t\t\tif(er.x<dp[i+1][j+1].x || (er.x==dp[i+1][j+1].x && er.y<dp[i+1][j+1].y) ) er=dp[i+1][j+1];\n   \t\t\t\t\n   \t\t\tdp[i][j].x += er.x;\n   \t\t\tif(er.y!=0)dp[i][j].y=er.y;\n   \t\t\t\n   \t\t\tif(suuji[i][j]==n){\n   \t\t\tcout<<dp[i][j].x<<\" \"<<dp[i][j].y<<endl;\n   \t\t\t\tbreak;\n   \t\t\t}\n   \t\t}\n   \t\t\n   \t}\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n, m;\nint cave[1001][1001];\nP dp[1000005];\nbool prime[1000005];\n\nP search(int x, int y, int val)\n{\n\tint nx, ny;\n\tP ret = make_pair(0, -1);\n\t\n\tif(dp[val].first != -1) return dp[val];\n\t\n\tfor(int v = -1; v <= 1; v++){\n\t\tnx = x + v, ny = y + 1;\n\t\tif(nx < 0 || nx >= 1001 || ny < 0 || ny >= 1001) continue;\n\t\tif(cave[nx][ny] > n) continue;\n\t\tret = max(ret, search(nx, ny, cave[nx][ny]));\n\t}\n\tif(!prime[val]){\n\t\tret.first++;\n\t\tif(ret.second == -1) ret.second = val;\n\t}\n\t\n\treturn dp[val] = ret;\n}\n\nint main(void)\n{\n\tint px = 500, py = 500, dir = 0, dir2;\n\tconst int vx[] = {1, 0, -1, 0}, vy[] = {0, -1, 0, 1};\n\t\n\tint nx, ny;\n\tfor(int i = 1; i <= 1001 * 1001; i++){\n\t\tcave[px][py] = i;\n\t\tpx += vx[dir], py += vy[dir];\n\t\tdir2 = (dir+1)%4;\n\t\tif(cave[px + vx[dir2]][py + vy[dir2]] == 0) dir = dir2;\n\t}\n\t\n\tprime[1] = true;\n\tfor(int i = 2; i < 1100; i++){\n\t\tif(!prime[i]){\n\t\t\tfor(int j = 2 * i; j < 1000005; j += i) prime[j] = true;\n\t\t}\n\t}\n\t\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0) break;\n\t\t\n\t\tfor(int i = 1; i <= n; i++) dp[i] = make_pair(-1, -1);\n\t\t\n\t\tint x, y;\n\t\tfor(x = 0; x < 1001; x++){\n\t\t\tfor(y = 0; y < 1001; y++){\n\t\t\t\tif(cave[x][y] == m) goto end;\n\t\t\t}\n\t\t}\n\t\tend:;\n\t\t\n\t\tP ans = search(x, y, m);\n\t\tif(ans.first == 0) ans.second = 0;\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\nusing namespace std;\n#define N 1000\n#define N2 N*N\nbool prime[N2+1];\nint cave[N+2][N+2]={};\npair<int,int> locate[N2+1];\nint last[N+2][N+2];\nint dp[N+2][N+2];\nint m,n;\n\nbool wall(int x,int y){ return x==0 || y==0 || x==N+1 || y==N+1; }\n\nint rec(int x,int y){\n    int value = cave[x][y];\n    if(wall(x,y) || value>m)return 0;\n    if(dp[x][y])return dp[x][y];\n    pair<int,int> child[3];\n    rep(i,3)child[i]=pair<int,int>(rec(x+i-1,y-1),last[x+i-1][y-1]);\n    sort(child,child+3);\n    dp[x][y]=child[2].first;\n    if(prime[value])dp[x][y]++;\n    last[x][y]=child[2].second;\n    if(last[x][y]==0 && prime[value]) last[x][y]=value;\n    return dp[x][y];\n}\n\nint main(void){\n    rep1(i,N2)prime[i]=true;\n    prime[0]=prime[1]=false;\n    for(int i=2;i<=N2;i++){\n        if(prime[i]) for(int k=2;i*k<=N2;k++) prime[i*k]=false;\n    }\n\n    int x=1,y=N,d=0;\n    int dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n    for(int i=N2;i>0;i--){\n        cave[x][y]=i;\n        locate[i] = pair<int,int>(x,y);\n        if(wall(x+dx[d],y+dy[d]) || cave[x+dx[d]][y+dy[d]]) d=(d+1)%4;\n        x+=dx[d];\n        y+=dy[d];\n    }\n\n    while(cin>>m>>n, m|n){\n        rep1(x,N)rep1(y,N) dp[x][y]=last[x][y]=0;\n        int x=locate[n].first,y=locate[n].second;\n        int cnt = rec(x,y);\n        cout<<cnt<<\" \"<<last[x][y]<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nmap<int,pair<int,int> > dp;\nint field[2048][2048];\nmap<int,pair<int,int> >itop;\nvector<bool> p(1048576,true);\nint m;\npair<int,int> solve(int n)\n{\n  if(m<n) return make_pair(0,0);\n  if(dp.count(n)) return dp[n];\n  int x,y;\n  tie(x,y)=itop[n];\n  pair<int,int> after=make_pair(0,0);\n  FOR(i,-1,2) after=max(after,solve(field[x+i][y+1]));\n  dp[n]=after;\n  if(p[n])\n    if(after==make_pair(0,0)) dp[n]=make_pair(1,n);\n    else ++dp[n].first;\n  return dp[n];\n}\nint main(void)\n{\n  p[0]=false;\n  p[1]=false;\n  REP(i,1024){\n    if(!p[i]) continue;\n    for(int j=i*i;j<1048576;j+=i) p[j]=false;\n  }\n  int tmp=1,x=1024,y=1024;\n  field[x][y]=tmp;\n  itop[tmp]=make_pair(x,y);\n  for(int i=1;;++i){\n    REP(j,i){\n      if(i%2) ++x;\n      else --x;\n      ++tmp;\n      field[x][y]=tmp;\n      itop[tmp]=make_pair(x,y);\n    }\n    REP(j,i){\n      if(i%2) --y;\n      else ++y;\n      ++tmp;\n      field[x][y]=tmp;\n      itop[tmp]=make_pair(x,y);\n    }\n    if(tmp>1048576) break;\n  }\n  for(;;){\n    int n;\n    cin >> m >> n;\n    if(!n) return 0;\n    dp.clear();\n    pair<int,int> answer=solve(n);\n    cout << answer.first << ' ' << answer.second << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\n#define SIZE 1000\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\t\t/*\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}*/\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (x >= 0 && y >= 0 && table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}/*\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}*/\n\n\t\toutput = false;\n\t\tfor (int i = 0;i < SIZE&&!output;i++) {\n\t\t\tfor (int j = 0;j < SIZE&&!output;j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tprintf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,bg,ed) for(int i=bg;i<ed;i++)\n#define REP(i,n) FOR(i,0,n)\nconstexpr int MAX_N = 2*1123456;\nnamespace prime{\n bool is[MAX_N];\n struct latte{\n   latte(){\n    REP(i,MAX_N)is[i]=true;\n    is[0]=is[1]=false;\n    REP(i,MAX_N)if(is[i]){\n     \tfor(int j=i+i;j<MAX_N;j+=i)is[j]=false; \n    }\n   }\n }malta;\n}\nnamespace maze{\nint r[MAX_N];\nint c[MAX_N];\nconstexpr int dr[]={0,-1,0,1};\nconstexpr int dc[]={1,0,-1,0};\nint maze[2123][2123];\nstruct latte{\n  latte(){\n    REP(i,2123)REP(j,2123)maze[i][j]=MAX_N;\n    r[1]=c[1]=0;\n    int rm = 0;\n    int cm = 0;\n    int d = 0;\n    int v = 2;\n    FOR(i,1,1200){\n      REP(j,i){\n        r[v] = r[v-1]+dr[d];rm = min(rm,r[v]);\n        c[v] = c[v-1]+dc[d];cm = min(cm,c[v]);\n        v++;\n      }\n      d++;\n      REP(j,i){\n        r[v] = r[v-1]+dr[d];rm = min(rm,r[v]);\n        c[v] = c[v-1]+dc[d];cm = min(cm,c[v]);\n        v++;\n      }      \n      d++;\n      d%=4;\n    }\n  \n  \tFOR(i,1,v){\n      r[i]-=rm - 5,c[i]-=cm - 5;\n      maze[r[i]][c[i]] = i;\n    }\n  }\n}malta;\n}\ntypedef pair<int,int> P;\nP dp[2123][2123];\nconstexpr int INF = 1e8;\nint main(){\n  int n,m;\n  while(cin>>m>>n,n+m){\n    int r = maze::r[n];\n    int c = maze::c[n];\n    REP(i,2123)REP(j,2123)dp[i][j]={-INF,-1};\n    dp[r][c] = {0,0};\n    if(prime::is[n])dp[r][c]={1,n};\n    P ret = dp[r][c];\n    REP(i,2123)REP(j,2123){\n      const int v = maze::maze[i][j];\n      if(v>m)continue;\n      P mx = max({dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1]});\n      if(prime::is[maze::maze[i][j]]){\n      \tdp[i][j]=max(dp[i][j],{mx.first+1,v});\n      }\n      else{\n        dp[i][j]=max(dp[i][j],mx);\n      }\n      ret = max(ret,dp[i][j]);\n    }\n    cout<<ret.first<<\" \"<<ret.second<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3f\n#define EPS (1e-10)\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nbool is_prime[1000001];\nint t[1500][1500], dp[1500][1500];\nint dx[]{ 1,0,-1,0 }, dy[]{ 0,1,0,-1 };\n\nint main() {\n\tmemset(is_prime, 1, sizeof(is_prime));\n\tis_prime[0] = is_prime[1] = false;\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tif (is_prime[i]) {\n\t\t\tfor (int j = i * 2; j <= 1000000; j += i)is_prime[j] = false;\n\t\t}\n\t}\n\tint m, n;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tmemset(t, 0, sizeof(t));\n\t\tint sx, sy, x = 750, y = 750, id = 0;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tt[x][y] = i;\n\t\t\tif (i == n)sx = x, sy = y;\n\t\t\tint nx = x + dx[(id + 1) % 4], ny = y + dy[(id + 1) % 4];\n\t\t\tif (!t[nx][ny]) {\n\t\t\t\t(id += 1) %= 4; x = nx; y = ny;\n\t\t\t}\n\t\t\telse x += dx[id], y += dy[id];\n\t\t}\n\t\tint Max = 0; id = 0;\n\t\tif (is_prime[n])dp[sx][sy] = 1;\n\t\tfor (int i = sx; i < 1400; i++) {\n\t\t\tfor (int j = sy - (i - sx); j <= sy + (i - sx); j++) {\n\t\t\t\tif (Max < dp[i][j] && is_prime[t[i][j]]) {\n\t\t\t\t\tMax = dp[i][j]; id = t[i][j];\n\t\t\t\t}\n\t\t\t\telse if (Max == dp[i][j] && is_prime[t[i][j]]) {\n\t\t\t\t\tid = max(id, t[i][j]);\n\t\t\t\t}\n\t\t\t\tfor (int k = j - 1; k <= j + 1; k++) {\n\t\t\t\t\tif (is_prime[t[i + 1][k]])dp[i + 1][k] = max(dp[i + 1][k], dp[i][j] + 1);\n\t\t\t\t\telse dp[i + 1][k] = max(dp[i + 1][k], dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (Max == 0)puts(\"0 0\");\n\t\telse printf(\"%d %d\\n\", Max, id);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define f first\n#define s second\ntypedef pair<int,int> P;\nint a[2000][2000],ans[2000][2000],d=0,y=999,x=1001,n,m;\nbool b[1000001],used[2000][2000];\nint dx[]={-1,0,1,0},tx[]={-1,0,1};\nint dy[]={0,1,0,-1},ty[]={1,1,1};\nint main(){\n  b[0]=b[1]=1;\n  for(int i=2;i<1000001;i++)\n    for(int j=i+i;j<1000001;j+=i)b[j]=1;\n  a[1000][1000]=1;\n  a[1000][1001]=2;\n  a[999][1001]=3;\n  for(int i=4;i<1000001;i++){\n    int yy=y+dy[d],xx=x+dx[d];\n    int ya=yy+dy[(d+1)%4],xa=xx+dx[(d+1)%4];\n    if(!a[ya][xa])d=(d+1)%4;\n    a[yy][xx]=i;\n    y=yy,x=xx;\n  }\n  while(cin>>n>>m,n){\n    memset(ans,0,sizeof(ans));\n    memset(used,0,sizeof(used));\n    r(i,2000)r(j,2000)if(a[i][j]==m){\n      used[i][j]=1;y=i;\n      break;\n    }\n    for(int i=y;i<2000;i++)r(j,2000)if(a[i][j]&&used[i][j]){\n      if(!b[a[i][j]])ans[i][j]++;\n      r(k,3){\n        y=i+ty[k],x=j+tx[k];\n        if(!a[y][x]||a[y][x]>=n)continue;\n        ans[y][x]=max(ans[y][x],ans[i][j]);\n        used[y][x]=1;\n      }\n    }\n    int a1=0,a2;\n    r(i,2000)r(j,2000)if(a[i][j]<=n)if(a1<ans[i][j]){\n      a1=ans[i][j],a2=a[i][j];\n    }\n    if(!a1)cout<<\"0 0\"<<endl;\n    else cout<<a1<<' '<<a2<<endl;\n  }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (y>=0&&x>=0&&table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t\n\t\tfor (int h = 0;h < SIZE;h++) {\n\t\t\tfor (int w = 0;w < SIZE;w++) {\n\t\t\t\tif (table[h][w] == n) {\n\t\t\t\t\t//cout << dp[h][w] << \" \";\n\t\t\t\t\tcout << pr[h][w] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[(SIZE + 1)*(SIZE + 1) + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tint res1, res2;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= (SIZE + 1)*(SIZE + 1);i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= (SIZE + 1)*(SIZE + 1);j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d %d\", &m, &n);\n\t\tif (m == 0 || n == 0)return 0;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = SIZE - 1;i >= 0;i--){\n\t\t\tfor(int j = SIZE - 1;j >= 0;j--){\n\t\t\t\tif (table[i][j] <= m) {\n\t\t\t\t\tif (i + 1 < SIZE) {\n\t\t\t\t\t\tif (j > 0 && table[i + 1][j - 1] <= m && (dp[i][j] < dp[i + 1][j - 1] || (dp[i][j] == dp[i + 1][j - 1] && pr[i][j] < pr[i + 1][j - 1]))) {\n\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j - 1];\n\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j - 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (table[i + 1][j] <= m && (dp[i][j] < dp[i + 1][j] || (dp[i][j] == dp[i + 1][j] && pr[i][j] < pr[i + 1][j]))) {\n\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j];\n\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j + 1 < SIZE && table[i + 1][j + 1] <= m && (dp[i][j] < dp[i + 1][j + 1] || (dp[i][j] == dp[i + 1][j + 1] && pr[i][j] < pr[i + 1][j + 1]))) {\n\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j + 1];\n\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!prime[table[i][j]]) {\n\t\t\t\t\t\tdp[i][j]++;\n\t\t\t\t\t\tif (pr[i][j] == 0) {\n\t\t\t\t\t\t\tpr[i][j] = table[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tres1 = dp[i][j];\n\t\t\t\t\tres2 = pr[i][j];\n\t\t\t\t\t//printf(\"%d\\n\", dp[y][x]);\n\t\t\t\t\t//cout << dp[y][x] << \" \";\n\t\t\t\t\t//cout << pr[y][x] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", res1, res2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (y>=0&&x>=0&&table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t\n\t\tfor (int h = 0;h < SIZE;h++) {\n\t\t\tfor (int w = 0;w < SIZE;w++) {\n\t\t\t\tif (table[h][w] == n) {\n\t\t\t\t\tcout << dp[h][w] << \" \";\n\t\t\t\t\t//cout << pr[h][w] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[(SIZE + 1)*(SIZE + 1)];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= (SIZE + 1)*(SIZE + 1);i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= (SIZE + 1)*(SIZE + 1);j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(y=SIZE-1;y>=0;y--){\n\t\t\tfor(x=SIZE-1;x>=0;x--){\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&\n\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x - 1]||(dp[y][x] == dp[y + 1][x - 1] && pr[y][x] < pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && \n\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x] || (dp[y][x] == dp[y + 1][x] && pr[y][x] < pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && \n\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x + 1] || (dp[y][x] == dp[y + 1][x + 1] && pr[y][x] < pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (y = 0;y < SIZE;y++) {\n\t\t\tfor (x = 0;x < SIZE;x++) {\n\t\t\t\tif (table[y][x] == n) {\n\t\t\t\t\tcout << dp[y][x] << \" \" << pr[y][x] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\nusing namespace std;\nusing llong = long long;\n\nllong n, m;\n\nllong num[1024][1024];\npair<llong, llong> dp[1024][1024];\nbool is_prime[1000005];\n\nvoid sieve(llong n) {\n    for (int i = 0; i <= n; i++) is_prime[i] = true;\n    is_prime[0] = is_prime[1] = false;\n\n    for (int i = 2; i <= n; i++) {\n        if (is_prime[i]) {\n            for (int j = 2 * i; j <= n; j += i) is_prime[j] = false;\n        }\n    }\n    return;\n}\n\npair<llong, llong> rec(int i, int j) {\n    if (i >= 1024 || j < 0 || j >= 1024) return {0, 0};\n    if (num[i][j] > m) return {0, 0};\n\n    if (dp[i][j] != make_pair(-1ll, -1ll)) return dp[i][j];\n\n    pair<llong, llong> ret = max({rec(i + 1, j - 1),\n                                  rec(i + 1, j),\n                                  rec(i + 1, j + 1)});\n\n    if (ret == make_pair(0ll, 0ll) && is_prime[num[i][j]]) {\n        ret.first = 1;\n        ret.second = num[i][j];\n    }\n    else if (is_prime[num[i][j]]){\n        ret.first++;\n    }\n    \n    return dp[i][j] = ret;\n}\n\nint main() {\n    {\n        sieve(1000000);\n        llong x, y;\n        llong c = 3;\n        llong w = 3;\n        num[512][512] = 1;\n        num[512][513] = 2;\n        x = 513;\n        y = 512;\n\n        while (c <= 1000000) {\n            for (int i = 0; i < w - 2; i++) {\n                y--;\n                num[y][x] = c;\n                c++;\n            }\n\n            for (int i = 0; i < w - 1; i++) {\n                x--;\n                num[y][x] = c;\n                c++;\n            }\n\n            for (int i = 0; i < w - 1; i++) {\n                y++;\n                num[y][x] = c;\n                c++;\n            }\n\n            for (int i = 0; i < w; i++) {\n                x++;\n                num[y][x] = c;\n                c++;\n            }\n            w += 2;\n        }\n    }\n    \n    while (1) {\n        cin >> m >> n;\n        if (n == 0) break;\n\n        llong x, y;\n        for (int i = 0; i < 1024; i++) {\n            for (int j = 0; j < 1024; j++) {\n                if (num[i][j] == n) {\n                    y = i;\n                    x = j;\n                }\n                dp[i][j] = make_pair(-1ll, -1ll);\n            }\n        }\n\n        auto p = rec(y, x);\n\n        cout << p.first << ' ' << p.second << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define SIZE 1000\n\nbool C(int dp1, int pr1, int dp2, int pr2) {\n\tif (dp2 == 0)return false;\n\tif (dp1 < dp2 || (dp1 == dp2&&pr1 < pr2))return true;\n\treturn false;\n}\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\t/*\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x - 1], pr[y + 1][x - 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x], pr[y + 1][x])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x + 1], pr[y + 1][x + 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}*/\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\n\t\toutput = false;\n\t\tfor (int i = 0;i < SIZE&&!output;i++) {\n\t\t\tfor (int j = 0;j < SIZE&&!output;j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tprintf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\n#define SIZE 1000\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\t\t/*\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}*/\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}/*\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}*/\n\t\t\n\t\toutput = false;\n\t\tfor (int i = 0;i < SIZE&&(!output);i++) {\n\t\t\tfor (int j = 0;j < SIZE&&(!output);j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tprintf(\"%d\\n\", dp[i][j]);\n\t\t\t\t\t//printf(\"%d %d\\n\", dp[i][j], pr[i][j]);\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> P;\n#define F first\n#define S second\nint fie[1111][1111];\nint N,M;\nint sosu[1000001];\nP mie[1000001];\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\n\nP dp[1111][1111];\nint ndx[]={1,0,-1};\nP solve(int x,int y,int ss){\n  if(dp[x][y].F!=-1 && dp[x][y].S!=-1) return dp[x][y];\n  //   printf(\"%d %d %d fie=%d\\n\",x,y,ss,fie[x][y]);\n  if(fie[x][y]>N ||  fie[x][y] == -1 ){\n    return P(0,ss);\n  }\n  if(!sosu[fie[x][y]]) ss = fie[x][y];\n  P ret = P(0,0);\n  for(int i=0;i<3;i++){\n    int nx = x+ndx[i];\n    int ny = y+1;\n    P state = solve(nx,ny,ss);\n    ret = max(ret,state);\n  }\n  if(!sosu[fie[x][y]]) ret.F++;\n  //printf(\"%d dp[%d][%d] =  %d, %d fie=%d\\n\",ss,x,y,ret.F,ret.S,fie[x][y]);\n   return dp[x][y] = ret;\n}\n\nint main(){\n  sosu[1]=1;\n  sosu[0]=1;\n  for(int i=2;i<=1000000;i++){\n    if(!sosu[i]){\n      for(int j=i+i;j<=1000000;j+=i){\n\tsosu[j]=1;\n      }\n    }\n  }\n  for(int i=0;i<1111;i++)\n    for(int j=0;j<1111;j++)\n      dp[i][j]=P(-1,-1);\n  memset(fie,-1,sizeof(fie));\n\n\n  int x = 1111/2,y = 1111/2;\n  int id = 1, ic = 0;\n  //printf(\"%d %d\\n\",x,y);\n  fie[x][y]=1;\n  x += dx[ic]; y += dy[ic];\n  mie[1]=P(x,y);\n \n  while( id < 1000000 ){\n    id++;\n    fie[x][y]=id;\n    mie[id] = P(x,y);\n    //if(id==1000000) printf(\"%d %d %d\\n\",id,x,y);\n    //    if(!sosu[fie[x][y]]) if(id<1000) printf(\"sosu::%d %d %d\\n\",id,x,y);\n    int nc = (ic+1)%4;\n    int nx = x+dx[nc], ny = y+dy[nc];\n    if( fie[nx][ny] == -1 ){\n      x = nx; y=ny;\n      ic=nc;\n    } else {\n      x = x + dx[ic]; y = y + dy[ic];\n    }\n  }\n\n\n  /*    for(int i=110;i<1111;i++){\n    for(int j=1100;j<1111;j++){\n      printf(\"%3d \",fie[j][i]);\n    }\n    puts(\"\");\n  }\n  */\n\n  while(1){\n    for(int i=0;i<1111;i++)\n      for(int j=0;j<1111;j++)\n\tdp[i][j]=P(-1,-1);\n    \n    cin >> N >> M;\n    if(!N && !M) break;\n    //    printf(\"%d %d\\n\",mie[N].F,mie[N].S);\n    P res = solve(mie[M].F,mie[M].S,-1);\n    /*    if(sosu[fie[mie[M]][Mie[M]]]){\n      res.F ++;\n      }*/\n    if(res.S == -1)\n      printf(\"%d %d\\n\",0,0);\n    else\n      printf(\"%d %d\\n\",res.F,res.S);\n    \n  }\n  \n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nusing namespace std;\n  \n#define MP make_pair\n#define PB push_back\n#define MAX_N 1001000\n#define SIZE 2010\n#define X first\n#define Y second\n  \nconst int STX = 1000, STY = 1000;\n  \nint id[SIZE][SIZE];\nbool is_prime[MAX_N+1];\nvector<pair<int, int> > coord;\n\nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++) {\n    if(is_prime[i]) {\n      for(int j=i*i; j<=MAX_N; j+=i) {\n\tis_prime[j] = false;\n      }\n    }\n  }\n}\n\nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  \n  coord.PB(MP(0, 0)); // no use\n  cnt ++;\n  coord.PB(MP(x, y)); // cnt = 1\n  \n  fill(id[0], id[0]+SIZE*SIZE+1, -1);\n  \n  const int dx[] = {0,-1,0,1};\n  const int dy[] = {-1,0,1,0};\n  \n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt <= MAX_N) {\n    a += 2;\n    for(int turn=0; turn<4; turn++) {\n      for(int i=0; i<a; i++) {\n\tx += dx[turn], y += dy[turn];\n\tcoord.PB(MP(x, y));\n\tid[y][x] = ++ cnt;\n      }\n    }\n    x++, y++;\n  }\n}\n\nint dp[MAX_N+1];\n\nint main() {\n  \n  Sieve();\n  MakeMap();\n  \n  int m, n;\n    \n  while(cin >> m >> n && (m|n)) {\n    \n    bool ok = false;\n    \n    fill(dp, dp+MAX_N+1, -1);\n    dp[n] = is_prime[n];\n    \n    queue<pair<int, int> > que;\n    que.push(coord[n]);\n    \n    while(!que.empty()) {\n      pair<int, int> now = que.front(); que.pop();\n      int noid = id[now.Y][now.X];\n      \n      for(int i=-1; i<=1; i++) {\n\tpair<int, int> nex = MP(now.X+i, now.Y+1);\n\tif(nex.X < 0 || SIZE <= nex.X || nex.Y < 0 || SIZE <= nex.Y) continue;\n\tint neid = id[nex.Y][nex.X];\n\tif(neid <= m) {\n\t  if(dp[neid] < dp[noid] + is_prime[neid]) {\n\t    dp[neid] = dp[noid] + is_prime[neid];\n\t    if(is_prime[neid]) ok = true;\n\t    que.push(nex);\n\t  }\n\t}\n      }\n    }\n    \n    int res = dp[n], lastid = -1;\n    if(is_prime[n]) lastid = n;\n    \n    for(int i=1; i<=m; i++) {\n      if(res <= dp[i] && is_prime[i]) {\n\tres = dp[i];\n\tlastid = max(lastid, i);\n      }\n    }\n    \n    if(!ok && lastid == -1) cout << \"0 0\" << endl;\n    else cout << res << \" \" << lastid << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n\n#define MAX_M 1000000\n\nusing namespace std;\n\ntypedef struct\n{\n\tint num, prime, last;\n}HOLE;\n\nint M, N;\nHOLE h[1000+2][1000+2];\n\nbool prime_judge(int x){\n\tif(x == 0 || x == 1) return false;\n\tfor (int i = 2; i*i <= x; i++)\n\t{\n\t\tif(x % i == 0) return false;\n\t}\n\treturn true;\n}\n\nvoid solve(){\n\tint flag = 0, d = 1;//?????????????????????, ???????????¢\n\tint x = 500, y = 500, ox = 500, oy = 500;\n\tint ansx, ansy;\n\tfor (int i = 0; i < 1002; i++)\n\t{\n\t\tfor (int j = 0; j < 1002; j++)\n\t\t{\n\t\t\th[i][j].num = 0;\n\t\t\th[i][j].last = 0;\n\t\t\th[i][j].prime = 0;\n\t\t}\n\t}\n\tfor (int i = 1; i <= M; i++)\n\t{\n\t\th[x][y].num = i;\n\t\tif(i == N){\n\t\t\tansx = x;\n\t\t\tansy = y;\n\t\t}\n\t\tif(flag == 0){\n\t\t\tx++;\n\t\t\tif(x - ox == d){\n\t\t\t\tox = x;\n\t\t\t\tflag = 1;\n\t\t\t}\n\t\t}else if(flag == 1){\n\t\t\ty--;\n\t\t\tif(oy - y == d){\n\t\t\t\toy = y;\n\t\t\t\td++;\n\t\t\t\tflag = 2;\n\t\t\t}\n\t\t}else if(flag == 2){\n\t\t\tx--;\n\t\t\tif(ox - x == d){\n\t\t\t\tox = x;\n\t\t\t\tflag = 3;\n\t\t\t}\n\t\t}else if(flag == 3){\n\t\t\ty++;\n\t\t\tif(y - oy == d){\n\t\t\t\toy = y;\n\t\t\t\td++;\n\t\t\t\tflag = 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1001; i >= 0; i--)\n\t{\n\t\tfor (int j = 0; j < 1002; j++)\n\t\t{\n\t\t\tif(h[j][i].num != 0){\n\t\t\t\th[j][i].prime = max(max(h[j-1][i+1].prime, h[j][i+1].prime), h[j+1][i+1].prime);\n\t\t\t\tif(h[j-1][i+1].last == 0 && h[j][i+1].last == 0 && h[j+1][i+1].last == 0)\n\t\t\t\t{\n\t\t\t\t\tif(prime_judge(h[j][i].num)) h[j][i].last = h[j][i].num;\n\t\t\t\t}else{\n\t\t\t\t\tint k;\n\t\t\t\t\tfor (k = -1; k <= 1; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(h[j+k][i+1].prime == h[j][i].prime){\n\t\t\t\t\t\t\th[j][i].last = h[j+k][i+1].last;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int l = -1; l <= 1; l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(h[j+k][i+1].prime == h[j+l][i+1].prime){\n\t\t\t\t\t\t\th[j][i].last = max(h[j][i].last, h[j+l][i+1].last);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(prime_judge(h[j][i].num)) h[j][i].prime++;\n\t\t\t}\n\t\t}\n\t}\n\tif(h[ansx][ansy].prime == 0) cout << \"0 0\" << endl;\n\telse cout << h[ansx][ansy].prime << \" \" << h[ansx][ansy].last << endl;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> M >> N;\n\t\tif(M == 0 && N == 0) break;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[(SIZE + 1)*(SIZE + 1) + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tint res1, res2;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= (SIZE + 1)*(SIZE + 1);i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= (SIZE + 1)*(SIZE + 1);j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 || n == 0)return 0;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(y=SIZE-1;y>=0;y--){\n\t\t\tfor(x=SIZE-1;x>=0;x--){\n\t\t\t\tif (table[y][x] <= m) {\n\t\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m &&\n\t\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x - 1] || (dp[y][x] == dp[y + 1][x - 1] && pr[y][x] < pr[y + 1][x - 1]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (table[y + 1][x] <= m &&\n\t\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x] || (dp[y][x] == dp[y + 1][x] && pr[y][x] < pr[y + 1][x]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m &&\n\t\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x + 1] || (dp[y][x] == dp[y + 1][x + 1] && pr[y][x] < pr[y + 1][x + 1]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (y = 0;y < SIZE;y++) {\n\t\t\tfor (x = 0;x < SIZE;x++) {\n\t\t\t\tif (table[y][x] == n) {\n\t\t\t\t\tres1 = dp[y][x];\n\t\t\t\t\tres2 = pr[y][x];\n\t\t\t\t\t//printf(\"%d\\n\", dp[y][x]);\n\t\t\t\t\t//cout << dp[y][x] << \" \";\n\t\t\t\t\t//cout << pr[y][x] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", res1, res2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int lim = 1500;\nconst int offset = 600;\nconst int MAX_LIM = 1000100;\n\nint cave[lim][lim];\nint dp[lim][lim];\nbool prime[MAX_LIM];\nmap<int, P> mp;\n\nint dy[4] = {0, -1, 0, 1};\nint dx[4] = {1, 0, -1, 0};\n\n\nvoid make_cave(){\n    int d = 0;\n    //原点をずらす\n    int y = offset;\n    int x = offset;\n\n    //辻褄合わせのため仕方なく入れた\n//    mp[1] = {y, x};\n\n    //範囲を指定\n    int L = 0;\n\n    int num = 1;\n    while(num <= MAX_LIM){\n        int Min = offset - L;\n        int Max = offset + L;\n\n        cave[y][x] = num;\n        mp[num] = {y, x};\n\n        int ny = y + dy[d];\n        int nx = x + dx[d];\n        \n        if(nx > Max){\n            d = (d + 1) % 4;\n            L++;\n        }\n        else if(ny < Min || ny > Max){\n            d = (d + 1) % 4;\n            ny = y + dy[d];\n            nx = x + dx[d];\n        }\n        else if(nx < Min){\n            d = (d + 1) % 4;\n            ny = y + dy[d];\n            nx = x + dx[d];\n        }\n\n        y = ny;\n        x = nx;\n\n        num++;\n        //足してから入れるとかいうのでバグらせた\n        //mp[num] = {y, x};\n    }\n    return;\n}\n\n\nvoid make_prime(){\n    fill(prime,prime+MAX_LIM,true);\n    prime[0] = prime[1] = false;\n    for(int i = 2 ; i*i <= MAX_LIM; i++){\n        if(prime[i]){\n            for(int j = i*2 ; j <= MAX_LIM; j+=i){\n                prime[j] = false;\n            }\n        }\n    }\n    return;\n}\n\n\nvoid solve(int y, int x, int m){\n    dp[y][x] = prime[cave[y][x]];\n    \n    for(int h=0; h<lim-1; h++){\n        for(int w=1; w<lim-1; w++){\n            if(dp[h][w] >= 0 && cave[h][w] <= m){\n                if(cave[h+1][w-1] <= m) dp[h+1][w-1] = max(dp[h+1][w-1], dp[h][w] + prime[cave[h+1][w-1]]);\n                if(cave[h+1][w] <= m) dp[h+1][w] = max(dp[h+1][w], dp[h][w] + prime[cave[h+1][w]]);\n                if(cave[h+1][w+1] <= m) dp[h+1][w+1] = max(dp[h+1][w+1], dp[h][w] + prime[cave[h+1][w+1]]);\n            }\n        }\n    }\n    \n    int res = 0;\n    int num = 0;\n    for(int i=0; i<lim; i++){\n        for(int j=0; j<lim; j++){\n            res = max(res, dp[i][j]);\n            \n        }\n    }\n\n    //これをやらなかったのがバグの原因だった\n    for(int i=0; i<lim; i++){\n        for(int j=0; j<lim; j++){\n            if(prime[cave[i][j]] && res == dp[i][j]){\n                num = max(num, cave[i][j]);\n            }\n        }\n    }\n\n    cout << res << \" \" << num << endl;\n    \n    return;\n}\n\n\nint main(){\n    \n    make_prime();\n    make_cave();\n    \n    int m, s;\n    while(true){\n        cin >> m >> s;\n        if(m == 0 && s == 0) return 0;\n        memset(dp, -1, sizeof(dp));\n        auto point = mp[s];\n        solve(point.first, point.second, m);\n    }\n    return 0;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (y>=0&&x>=0&&table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&\n\t\t\t\t\t\t(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]==dp[y + 1][x - 1]&&pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && \n\t\t\t\t\t\t(dp[y][x]<dp[y + 1][x] || (dp[y][x] == dp[y + 1][x] && pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && \n\t\t\t\t\t\t(dp[y][x]<dp[y + 1][x + 1] || (dp[y][x] == dp[y + 1][x + 1] && pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t\n\t\tfor (int h = 0;h < SIZE;h++) {\n\t\t\tfor (int w = 0;w < SIZE;w++) {\n\t\t\t\tif (table[h][w] == n) {\n\t\t\t\t\tcout << \" \";\n\t\t\t\t\t//cout << pr[h][w] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n\n#define  X  first\n#define  Y  second\n\nusing namespace std;\n\ntypedef pair<int, int>  P;\n\nconst int MAX_N = 1050;\nconst int MAX_PRIME = 1000010;\n\nbool is_prime[MAX_PRIME + 1];\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nvoid SieveOfEratosthenes();\nvoid Solve(int m, int n);\nvoid SearchPrimeCaves(const vector<vector<int>> &board, P p);\n\nint main()\n{\n    int m, n;\n\n    SieveOfEratosthenes();\n\n    while (cin >> m >> n, m || n)\n        Solve(m, n);\n\n    return 0;\n}\n\nvoid Solve(int m, int n)\n{\n    P p;\n    vector<vector<int>> board(MAX_N, vector<int>(MAX_N, 0));\n\n    // make board\n    pair<int, int> now(MAX_N / 2, MAX_N / 2);\n    int d = 3, cnt = 1, nd, nx, ny;\n\n    while (cnt <= m) {\n        if (cnt == n) {\n            p.X = now.X;\n            p.Y = now.Y;\n        }\n\n        board[now.Y][now.X] = cnt;\n\n        nd = (d + 1) % 4;\n        nx = now.X + dx[nd];\n        ny = now.Y + dy[nd];\n\n        ++cnt;\n        if (board[ny][nx] == 0) {\n            d = nd;\n            now.X = nx;\n            now.Y = ny;\n        }\n        else {\n            now.X += dx[d];\n            now.Y += dy[d];\n        }\n    }\n\n    SearchPrimeCaves(board, p);\n}\n\nvoid SearchPrimeCaves(const vector<vector<int>> &board, P p)\n{\n    vector<vector<P>> dp(MAX_N, vector<P>(MAX_N, P(0, 0)));\n    vector<vector<bool>> visit(MAX_N, vector<bool>(MAX_N, false));\n\n    visit[p.Y][p.X] = true;\n    if (is_prime[board[p.Y][p.X]]) {\n        dp[p.Y][p.X].first = 1;\n        dp[p.Y][p.X].second = board[p.Y][p.X];\n    }\n\n    P res = dp[p.Y][p.X];\n\n    for (int i = 1; i < MAX_N - 1; ++i) {\n        for (int j = 1; j < MAX_N - 1; ++j) {\n            if (board[i][j] == 0 || !visit[i][j])\n                continue;\n\n            for (int k = -1; k <= 1; ++k) {\n                if (board[i + 1][j + k] == 0)\n                    continue;\n                visit[i + 1][j + k] = true;\n                P tmp = dp[i][j];\n\n                if (is_prime[board[i + 1][j + k]]) {\n                    ++tmp.first;\n                    tmp.second = board[i + 1][j + k];\n                }\n\n                dp[i + 1][j + k] = max(dp[i + 1][j + k], tmp);\n                res = max(res, dp[i + 1][j + k]);\n            }\n        }\n    }\n\n    cout << res.first << ' ' << res.second << '\\n';\n}\n\n// 素数表を作る\nvoid SieveOfEratosthenes()\n{\n    for (int i = 0; i < MAX_PRIME; ++i)\n        is_prime[i] = true;\n    is_prime[0] = is_prime[1] = false;\n\n    for (int i = 2; i <= MAX_PRIME; ++i)\n        if (is_prime[i]) {\n            for (int j = 2 * i; j < MAX_PRIME; j += i)\n                is_prime[j] = false;\n        }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define SIZE 1000\n\nbool C(int dp1, int pr1, int dp2, int pr2) {\n\tif (dp2 == 0)return false;\n\tif (dp1 < dp2 || (dp1 == dp2&&pr1 < pr2))return true;\n\treturn false;\n}\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool complete;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1;i <= SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\tif (i % 2 == 0)x--;\n\t\t\telse x++;\n\t\t\ta++;\n\t\t}\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t\ta++;\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\tcomplete = false;\n\t\twhile (!complete) {\n\t\t\twhile (x >= 0 && !complete) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x - 1], pr[y + 1][x - 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x], pr[y + 1][x])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x + 1], pr[y + 1][x + 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (table[y][x] == n)complete = true;\n\t\t\t\telse x--;\n\t\t\t}\n\t\t\tif (!complete) {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nvector<bool> sieve_of_eratosthenes(int n) {\n  vector<bool> primes(n);\n  for (int i = 2; i < n; ++i)\n    primes[i] = true;\n  for (int i = 2; i*i < n; ++i)\n    if (primes[i])\n      for (int j = i*i; j < n; j+=i)\n        primes[j] = false;\n  return primes;\n}\n\nint main(void){\n\tint n,m;\n\twhile(cin >> n >> m,n+m != 0){\n\tvector<vector<bool>> grid(1100,vector<bool>(1100,false));\n\tvector<bool> primes = sieve_of_eratosthenes(n+1);\n\tvector<vector<int>> nums(1100,vector<int>(1100,-1));\n\tint mx,my;\n\t//??????????????????\n\tint x=505,y=505;\n\tint cnt = 1,d = 1,dir = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tnums[y][x] = i;\n\t\tif(primes[i])grid[y][x] = true;\n\n\t\tif(i == m){mx = x;my = y;}\n\t\tif(dir == 0){\n\t\t\tx++;\n\t\t\td--;\n\t\t\tif(d == 0){d = cnt;dir++;}\n\t\t}else if(dir == 1){\n\t\t\ty--;\n\t\t\td--;\n\t\t\tif(d == 0){cnt++;d = cnt;dir++;}\n\t\t}else if(dir == 2){\n\t\t\tx--;\n\t\t\td--;\n\t\t\tif(d == 0){d = cnt;dir++;}\n\t\t}else{\n\t\t\ty++;\n\t\t\td--;\n\t\t\tif(d == 0){cnt++;d = cnt;dir=0;}\n\t\t}\n\n\t}\n\tvector<vector<int>> dp(1100,vector<int>(1100,0));\n\tvector<vector<bool>> visited(1100,vector<bool>(1100,false));\n\tqueue<int> qx,qy;\n\tqx.push(mx);\n\tqy.push(my);\n\tint dx[] = {-1,0,1};\n\tint ret = 0,rnum = 0;\n\twhile(!qx.empty()){\n\t\tint xx = qx.front();qx.pop();\n\t\tint yy = qy.front();qy.pop();\n\t\t// cout << xx << \" \" << yy << endl;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint nx = xx + dx[i],ny = yy + 1;\n\t\t\tif(nx < 0 || nx > 1004 || ny > 1004)continue;\n\t\t\t//if(nums[ny][nx] == -1)continue;\n\t\t\tif(grid[yy][xx]){\n\t\t\t\tif(ret < dp[yy][xx] + 1){\n\t\t\t\t\tret = dp[yy][xx] + 1;\n\t\t\t\t\trnum = nums[yy][xx];\n\t\t\t\t}else if(ret == dp[yy][xx] + 1){\n\t\t\t\t\trnum = nums[yy][xx];\n\t\t\t\t}\n\t\t\t\tdp[ny][nx] = max(dp[ny][nx],dp[yy][xx]+1);\n\t\t\t}else{\n\t\t\t\tdp[ny][nx] = max(dp[ny][nx],dp[yy][xx]);\n\t\t\t}\n\n\t\t\tif(visited[ny][nx] == false){\n\t\t\t\tqx.push(nx);\n\t\t\t\tqy.push(ny);\n\t\t\t\tvisited[ny][nx] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// for(int y=500;y<510;y++){\n\t// \tfor(int x=500;x<510;x++){\n\t// \t\tprintf(\"%2d \",nums[y][x]);\n\t// \t}cout << endl;\n\t// }\n\t// for(int y=500;y<510;y++){\n\t// \tfor(int x=500;x<510;x++){\n\t// \t\tprintf(\"%2d \",dp[y][x]);\n\t// \t}cout << endl;\n\t// }\n\tcout << ret << \" \" << rnum << endl;\n}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n#define t_max 10000001\nchar M[1001][1001];\nchar S[1001][1001];\nchar P[1001][1001];\nchar table[t_max];\nvector<pair<short,short> >m(t_max);\nmap<pair<short,short>,int>m_rev;\npair<int,int> dfs(int x,int y){\n\tif(y==1001)return make_pair(0,0);\n\tif(S[x][y]>=0)return make_pair(S[x][y],P[x][y]);\n\tint m=0,m_place=0,i=-1;\n\tfor(;i<2;i++){\n\t\tif(x+i<0||1000<x+i)continue;\n\t\tpair<int,int> p=dfs(x+i,y+1);\n\t\tif(m<p.first||(m==p.first&&m_place<p.second))m=p.first,m_place=p.second;\n\t}\n\tif(m==0){\n\t\tif(M[x][y])return make_pair(S[x][y]=1,P[x][y]=m_rev[make_pair(x,y)]);\n\t\treturn make_pair(S[x][y]=0,P[x][y]=0);\n\t}else{\n\t\treturn make_pair(S[x][y]=m+M[x][y],P[x][y]=m_place);\n\t}\n}\nmain(){\n\tint k=1,z,x,y,i,n,s;\n\tm[k]=make_pair(x=500,y=500),m_rev[make_pair(x,y)]=k,k++;\n\tfor(z=2;z<=1000;z+=2){\n\t\tx++,y++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(x,--y),m_rev[make_pair(x,y)]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(--x,y),m_rev[make_pair(x,y)]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(x,++y),m_rev[make_pair(x,y)]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(++x,y),m_rev[make_pair(x,y)]=k,k++;\n\t}\n\ttable[0]=table[1]=1;\n\tfor(x=2;x<t_max;x++)if(!table[x])for(y=x*2;y<t_max;y+=x)table[y]=1;\n\tfor(;scanf(\"%d%d\",&n,&s),n;){\n\t\tmemset(M,0,sizeof(M));\n\t\tmemset(S,0xff,sizeof(S));\n\t\tmemset(P,0,sizeof(P));\n\t\tfor(i=1;i<=n;i++)if(!table[i])M[m[i].first][m[i].second]=1;\n\t\tpair<int,int> p=dfs(m[s].first,m[s].second);\n\t\tprintf(\"%d %d\\n\",p.first,p.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\n#define SIZE 1000\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\t\t/*\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}*/\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}/*\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}*/\n\t\t/*\n\t\toutput = false;\n\t\tfor (int i = 0;i < SIZE&&!output;i++) {\n\t\t\tfor (int j = 0;j < SIZE&&!output;j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tprintf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main(){\n  vector<vector<int> > cave(2000,vector<int>(2000,1e6+1));\n  vector<int> xp(1e6+1);\n  vector<int> yp(1e6+1);\n  int l=1;\n  int x=1000;\n  int y=1000;\n  xp[1]=x;\n  yp[1]=y;\n  cave[x][y]=1;\n\n  for(int i=2;i<1e6+1;i++){\n    for(int j=0;j<l;j++){\n      x++;\n      cave[x][y]=i;\n      xp[i]=x;\n      yp[i]=y;\n      i++;\n      if(i>1e6+1)break;\n    }\n    if(i>1e6+1)break;\n    for(int j=0;j<l;j++){\n      y--;\n      cave[x][y]=i;\n      xp[i]=x;\n      yp[i]=y;\n      i++;\n      if(i>1e6+1)break;\n    }\n    if(i>1e6+1)break;\n    l++;\n    for(int j=0;j<l;j++){\n      x--;\n      cave[x][y]=i;\n      xp[i]=x;\n      yp[i]=y;\n      i++;\n      if(i>1e6+1)break;\n    }\n    if(i>1e6+1)break;\n    for(int j=0;j<l;j++){\n      y++;\n      cave[x][y]=i;\n      xp[i]=x;\n      yp[i]=y;\n      if(j!=l-1)i++;\n      if(i>1e6+1)break;\n    }\n    if(i>1e6+1)break;\n    l++;\n  }\n\n  /*\n  for(int i=1490;i<1510;i++){\n    for(int j=1490;j<1510;j++){\n      cout<<cave[j][i]<<\" \";\n    }\n    cout<<endl;\n  }\n  */\n\n  vector<int> prime(1e6+2,1);\n  prime[1e6+1]=0;\n  prime[1]=0;\n  for(int i=2;i<prime.size();i++){\n    if(prime[i]){\n      for(int j=i+i;j<prime.size();j+=i)prime[j]=0;\n    }\n  }\n\n  //for(int i=0;i<1e6;i++)if(prime[i])cout<<i<<\" \";\n\n\n  while(1){\n    int m,n;\n    cin>>m>>n;\n    if(m==0&&n==0)break;\n    vector<vector<int> > bfs(2000,vector<int>(2000,0));\n    vector<int> used(1e6+1,1);\n    queue<int> q;\n    q.push(n);\n    while(!q.empty()){\n      int np=q.front();\n      //cout<<np<<endl;\n      q.pop();\n      if(used[cave[xp[np]-1][yp[np]+1]]&&cave[xp[np]-1][yp[np]+1]<=m){\n        q.push(cave[xp[np]-1][yp[np]+1]);\n        used[cave[xp[np]-1][yp[np]+1]]=0;\n      }\n      if(used[cave[xp[np]][yp[np]+1]]&&cave[xp[np]][yp[np]+1]<=m){\n        q.push(cave[xp[np]][yp[np]+1]);\n        used[cave[xp[np]][yp[np]+1]]=0;\n      }\n      if(used[cave[xp[np]+1][yp[np]+1]]&&cave[xp[np]+1][yp[np]+1]<=m){\n        q.push(cave[xp[np]+1][yp[np]+1]);\n        used[cave[xp[np]+1][yp[np]+1]]=0;\n      }\n      bfs[xp[np]][yp[np]]=max(bfs[xp[np]-1][yp[np]-1],max(bfs[xp[np]][yp[np]-1],bfs[xp[np]+1][yp[np]-1]))+prime[np];\n      //if(prime[np])bfs[xp[np]][yp[np]]++;\n    }\n\n    /*\n    for(int i=995;i<1005;i++){\n      for(int j=995;j<1005;j++){\n        cout<<bfs[j][i]<<\" \";\n      }\n      cout<<endl;\n    }\n    */\n\n    int ans=0;\n    int id=0;\n    for(int i=0;i<=m;i++){\n      //cout<<i<<\" \"<<bfs[xp[i]][yp[i]]<<endl;\n      if(ans<bfs[xp[i]][yp[i]]&&prime[i]){\n        ans=bfs[xp[i]][yp[i]];\n        id=cave[xp[i]][yp[i]];\n      }\n      if(ans!=0&&ans==bfs[xp[i]][yp[i]]&&prime[i]){\n        ans=bfs[xp[i]][yp[i]];\n        id=max(id,cave[xp[i]][yp[i]]);\n      }\n    }\n    cout<<ans<<\" \"<<id<<endl;\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n\nusing namespace std;\n\n#define mod 1000000007\n\nvector<pair<int, int> > numtoplace(1000001);\nvector<pair<int, int> > result;\nmap<pair<int, int>, int> placetonum;\n\nvoid getplace()\n{\n\tnumtoplace[1] = make_pair(0, 0);\n\tplacetonum[make_pair(0, 0)] = 1;\n\tfor(int i = 1; i <= 500; i++){\n\t\tint tmp = 2 * i - 1;\n\t\tint x = numtoplace[tmp * tmp].first;\n\t\tint y = numtoplace[tmp * tmp].second;\n\t\tint nx = x;\n\t\tint ny = y;\n\t\tint dx[4] = {-1, 0, 1, 0};\n\t\tint dy[4] = {0, -1, 0, 1};\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tfor(int k = 1; k <= 2 * i; k++){\n\t\t\t\tif(tmp * tmp + 2 * i * j + k > 1000001){\n\t\t\t\t\tj = 5;\n\t\t\t\t\ti = 501;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(j == 0 && k == 1){\n\t\t\t\t\tny++;\n\t\t\t\t} else {\n\t\t\t\t\tnx += dx[j];\n\t\t\t\t\tny += dy[j];\n\t\t\t\t}\n\t\t\t\t// cout << tmp * tmp + 2 * i * j + k << \" \" << nx << \" \" << ny << endl;\n\t\t\t\tnumtoplace[tmp * tmp + 2 * i * j + k] = make_pair(nx, ny);\n\t\t\t\tplacetonum[make_pair(nx, ny)] = tmp * tmp + 2 * i * j + k;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool isprime(int n)\n{\n\tif(n == 2) return true;\n\tfor(int i = 2; i * i <= n; i++){\n\t\tif(n % i == 0) return false;\n\t}\n\treturn true;\n}\n\npair<int, int> getresult(int n, int m)\n{\n\tif(n > m) return make_pair(0, 0);\n\tif(result[n] != make_pair(-1, -1)) return result[n];\n\tint dokutsunum = 0;\n\tint lastprime = 0;\n\tint x = numtoplace[n].first;\n\tint y = numtoplace[n].second;\n\tfor(int i = -1; i < 2; i++){\n\t\t\tif(placetonum.find(make_pair(x + 1, y + i)) == placetonum.end()) continue;\n\t\t\tpair<int, int> tmp = getresult(placetonum[make_pair(x + 1, y + i)], m);\n\t\t\tif(tmp.first > dokutsunum){\n\t\t\t\tdokutsunum = tmp.first;\n\t\t\t\tlastprime = tmp.second;\n\t\t\t} else if(tmp.first == dokutsunum){\n\t\t\t\tlastprime = max(lastprime, tmp.second);\n\t\t\t}\n\t}\n\tif(isprime(n)){\n\t\tdokutsunum++;\n\t\tif(lastprime == 0) lastprime = n;\n\t}\n\tresult[n] = make_pair(dokutsunum, lastprime);\n\treturn result[n];\n}\n\nint main()\n{\n\tgetplace();\n\tint n, m;\n\twhile(1){\n\t\tcin >> m >> n;\n\t\tif(n == 0 && m == 0) break;\n\t\tresult = vector<pair<int, int> >(m + 1, make_pair(-1, -1));\n\t\tpair<int, int> tmp = getresult(n, m);\n\t\tcout << tmp.first << \" \" << tmp.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n, m;\nint cave[1001][1001];\nP dp[1000005];\nbool prime[1000005];\n\nP search(int x, int y, int val)\n{\n\tint nx, ny;\n\tP ret = make_pair(0, -1);\n\t\n\tif(dp[val].first != -1) return dp[val];\n\t\n\tfor(int v = -1; v <= 1; v++){\n\t\tnx = x + v, ny = y + 1;\n\t\tif(nx < 0 || nx >= 1001 || ny < 0 || ny >= 1001) continue;\n\t\tif(cave[nx][ny] > n) continue;\n\t\tret = max(ret, search(nx, ny, cave[nx][ny]));\n\t}\n\tif(!prime[val]){\n\t\tret.first++;\n\t\tif(ret.second == -1) ret.second = val;\n\t}\n\t\n\treturn dp[val] = ret;\n}\n\nint main(void)\n{\n\tint px = 500, py = 500, dir = 0, dir2;\n\tconst int vx[4] = {1, 0, -1, 0}, vy[4] = {0, -1, 0, 1};\n\t\n\tint nx, ny;\n\tfor(int i = 1; i <= 1001 * 1001 - 1; i++){\n\t\tcave[px][py] = i;\n\t\tpx += vx[dir], py += vy[dir];\n\t\tdir2 = (dir+1)%4;\n\t\tif(cave[px + vx[dir2]][py + vy[dir2]] == 0) dir = dir2;\n\t}\n\t\n\tprime[1] = true;\n\tfor(int i = 2; i < 1100; i++){\n\t\tif(!prime[i]){\n\t\t\tfor(int j = 2 * i; j < 1000005; j += i) prime[j] = true;\n\t\t}\n\t}\n\t\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0) break;\n\t\t\n\t\tfor(int i = 1; i <= n; i++) dp[i] = make_pair(-1, -1);\n\t\t\n\t\tint x, y;\n\t\tfor(x = 0; x < 1001; x++){\n\t\t\tfor(y = 0; y < 1001; y++){\n\t\t\t\tif(cave[x][y] == m) goto end;\n\t\t\t}\n\t\t}\n\t\tend:;\n\t\t\n\t\tP ans = search(x, y, m);\n\t\tif(ans.first == 0) ans.second = 0;\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing P = pair<int, int>;\nconst int MAX = 1e6;\n\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, 1, 0, -1 };\n\nint main()\n{\n\tvector<bool> prime(MAX + 1, true); prime[0] = prime[1] = false;\n\tfor (int i = 2; i * i <= MAX; i++) {\n\t\tif (prime[i]) {\n\t\t\tfor (int j = i * 2; j <= MAX; j += i) {\n\t\t\t\tprime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\tint m, n;\n\twhile (cin >> m >> n, m | n) {\n\t\tvector<P> pos(m + 1);\n\t\tmap<P, int> mp;\n\t\tP tmp(0, 0);\n\t\tfor (int i = 1, j = 1, d = 0, k = 1, c = 0; i <= m; i++) {\n\t\t\tpos[i] = tmp;\n\t\t\tmp[tmp] = i;\n\t\t\ttmp.first += dx[d];\n\t\t\ttmp.second += dy[d];\n\t\t\tif (k == j) {\n\t\t\t\tk = 1;\n\t\t\t\tj = c ? j + 1 : j;\n\t\t\t\tc = 1 - c;\n\t\t\t\td = d == 3 ? 0 : d + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\tmap<P, int> val; val[pos[n]] = prime[n];\n\t\tset<P> q; q.insert(pos[n]);\n\t\tfor (; !q.empty(); ) {\n\t\t\tauto t = q; q.clear();\n\t\t\tfor (auto v : t) {\n\t\t\t\tfor (int x = -1; x <= 1; x++) {\n\t\t\t\t\tP to(v.first + x, v.second - 1);\n\t\t\t\t\tint num = mp[to];\n\t\t\t\t\tif (num) {\n\t\t\t\t\t\tq.insert(to);\n\t\t\t\t\t\tval[to] = max(val[to], val[v] + (prime[num] ? 1 : 0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ma = 0, id = 0;\n\t\tfor (auto p : val) {\n\t\t\tif (!prime[mp[p.first]]) continue;\n\t\t\tif (p.second > ma) {\n\t\t\t\tma = p.second;\n\t\t\t\tid = mp[p.first];\n\t\t\t}\n\t\t\telse if (p.second == ma && mp[p.first] > id) {\n\t\t\t\tid = mp[p.first];\n\t\t\t}\n\t\t}\n\t\tcout << ma << ' ' << (ma ? id : 0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nvector<bool> sieve_of_eratosthenes(int n) {\n  vector<bool> primes(n);\n  for (int i = 2; i < n; ++i)\n    primes[i] = true;\n  for (int i = 2; i*i < n; ++i)\n    if (primes[i])\n      for (int j = i*i; j < n; j+=i)\n        primes[j] = false;\n  return primes;\n}\n\nint main(void){\n\tint n,m;\n\twhile(cin >> n >> m,n+m != 0){\n\tvector<vector<bool>> grid(1100,vector<bool>(1100,false));\n\tvector<bool> primes = sieve_of_eratosthenes(n+1);\n\tvector<vector<int>> nums(1100,vector<int>(1100,-1));\n\tint mx,my;\n\t//??????????????????\n\tint x=505,y=505;\n\tint cnt = 1,d = 1,dir = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tnums[y][x] = i;\n\t\tif(primes[i])grid[y][x] = true;\n\n\t\tif(i == m){mx = x;my = y;}\n\t\tif(dir == 0){\n\t\t\tx++;\n\t\t\td--;\n\t\t\tif(d == 0){d = cnt;dir++;}\n\t\t}else if(dir == 1){\n\t\t\ty--;\n\t\t\td--;\n\t\t\tif(d == 0){cnt++;d = cnt;dir++;}\n\t\t}else if(dir == 2){\n\t\t\tx--;\n\t\t\td--;\n\t\t\tif(d == 0){d = cnt;dir++;}\n\t\t}else{\n\t\t\ty++;\n\t\t\td--;\n\t\t\tif(d == 0){cnt++;d = cnt;dir=0;}\n\t\t}\n\n\t}\n\tvector<vector<int>> dp(1100,vector<int>(1100,0));\n\tvector<vector<bool>> visited(1100,vector<bool>(1100,false));\n\tqueue<int> qx,qy;\n\tqx.push(mx);\n\tqy.push(my);\n\tint dx[] = {-1,0,1};\n\tint ret = 0,rnum = 0;\n\twhile(!qx.empty()){\n\t\tint xx = qx.front();qx.pop();\n\t\tint yy = qy.front();qy.pop();\n\t\t// cout << xx << \" \" << yy << endl;\n\t\tfor(int i=0;i<3;i++){\n\t\t\tint nx = xx + dx[i],ny = yy + 1;\n\t\t\tif(nx < 0 || nx > 1080 || ny > 1080)continue;\n\t\t\t//if(nums[ny][nx] == -1)continue;\n\t\t\tif(grid[yy][xx]){\n\t\t\t\tif(ret < dp[yy][xx] + 1){\n\t\t\t\t\tret = dp[yy][xx] + 1;\n\t\t\t\t\trnum = nums[yy][xx];\n\t\t\t\t}else if(ret == dp[yy][xx] + 1 && rnum < nums[yy][xx]){\n\t\t\t\t\trnum = nums[yy][xx];\n\t\t\t\t}\n\t\t\t\tdp[ny][nx] = max(dp[ny][nx],dp[yy][xx]+1);\n\t\t\t}else{\n\t\t\t\tdp[ny][nx] = max(dp[ny][nx],dp[yy][xx]);\n\t\t\t}\n\n\t\t\tif(visited[ny][nx] == false){\n\t\t\t\tqx.push(nx);\n\t\t\t\tqy.push(ny);\n\t\t\t\tvisited[ny][nx] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// for(int y=500;y<510;y++){\n\t// \tfor(int x=500;x<510;x++){\n\t// \t\tprintf(\"%2d \",nums[y][x]);\n\t// \t}cout << endl;\n\t// }\n\t// for(int y=500;y<510;y++){\n\t// \tfor(int x=500;x<510;x++){\n\t// \t\tprintf(\"%2d \",dp[y][x]);\n\t// \t}cout << endl;\n\t// }\n\tcout << ret << \" \" << rnum << endl;\n}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint map[1001][1000], dp[1001][1000], dp2[1001][1000], sosu[1000001];\nint y[] = { 0, -1, 0, 1 }, x[] = { 1, 0, -1, 0 }, maxh, maxw, minh, minw, ansH, ansW;\nint m, n;\n\nvoid hantei(int h, int w) {\n\tmaxh = max(maxh, h);\n\tmaxw = max(maxw, w);\n\tminh = min(minh, h);\n\tminw = min(minw, w);\n}\n\nvoid setMap() {\n\tint h = 500, w = 500, muki = 0;\n\tmap[h][w] = 1;\n\tfor (int i = 2; i <= m; i++) {\n\t\tif (map[h + y[muki]][w+x[muki]] <= 0) {\n\t\t\thantei(h+y[muki], w+x[muki]);\n\t\t\tmap[h + y[muki]][w+x[muki]] = i;//????????£????????????\n\t\t\th += y[muki];\n\t\t\tw += x[muki];\n\t\t\tif (map[h][w] == n) {\n\t\t\t\tansH = h;\n\t\t\t\tansW = w;\n\t\t\t}\n\t\t\tmuki = (muki + 1) % 4;\n\t\t}\n\t\telse {\n\t\t\tif (muki - 1 >= 0) {\n\t\t\t\tmap[h + y[muki-1]][w + x[muki-1]] = i;//\n\t\t\t\th += y[muki - 1];\n\t\t\t\tw += x[muki - 1];\n\t\t\t\tif (map[h][w] == n) {\n\t\t\t\t\tansH = h;\n\t\t\t\t\tansW = w;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmap[h + y[3]][w + x[3]] = i;//\n\t\t\t\th += y[3];\n\t\t\t\tw += x[3];\n\t\t\t\tif (map[h][w] == n) {\n\t\t\t\t\tansH = h;\n\t\t\t\t\tansW = w;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid eratosthenes() {\n\tsosu[0] = 1;\n\tsosu[1] = 1;\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tif (sosu[i] == 0) {\n\t\t\tfor (int j = 2; j*i <= 1000000; j++) {\n\t\t\t\tsosu[j*i]++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid DP() {\n\tfor (int i = maxh; i >= minh; i--) {\n\t\tfor (int j = maxw; j >= minw; j--) {\n\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\tif (minw <= j + k && maxw >= j + k) {\n\t\t\t\t\tif (dp[i][j] < dp[i + 1][j + k]) {\n\t\t\t\t\t\tdp[i][j] = dp[i + 1][j + k];\n\t\t\t\t\t\tdp2[i][j] = dp2[i + 1][j + k];\n\t\t\t\t\t\t//printf(\"a1\\t\");\n\t\t\t\t\t}\n\t\t\t\t\telse if (dp[i][j] == dp[i + 1][j + k] && dp2[i][j] < dp2[i + 1][j + k]) {\n\t\t\t\t\t\tdp2[i][j] = dp2[i + 1][j + k];\n\t\t\t\t\t\t//printf(\"a2\\t\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sosu[map[i][j]] == 0) {//???????¶??????????????????¨?????????????????£????????????????????????\n\t\t\t\t//printf(\"a3\\t\");\n\t\t\t\tdp[i][j]++;\n\t\t\t\tif (dp[i][j] == 1) {\n\t\t\t\t\tdp2[i][j] = map[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << endl;\n\t}\n}\n\nint main() {\n\tvector<int>v,v2;\n\teratosthenes();\n\n\twhile (cin >> m >> n, m || n) {\n\t\tmaxh = 0, maxw = 0, minh = 9999999, minw = 9999999;\n\t\tfor (int i = 0; i < 1001;i++) {\n\t\t\tfor (int j = 0; j < 1000;j++) {\n\t\t\t\tmap[i][j] = 0;\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tdp2[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tsetMap();\n\t\tDP();\n\t\t/*int ans = 0, a = 0;\n\t\tfor (int i = minw; i <= maxw; i++) {//????????????????????????????????£??\\????????????\n\t\t\tif (dp[minh][i] > ans) {\n\t\t\t\tans = dp[minh][i];\n\t\t\t\ta = dp2[minh][i];\n\t\t\t}\n\t\t\telse if (dp[minh][i] == ans && a < dp2[minh][i]) {\n\t\t\t\ta = dp2[minh][i];\n\t\t\t}\n\t\t}*/\n\t\tv.push_back(dp[ansH][ansW]);\n\t\tv2.push_back(dp2[ansH][ansW]);\n\t\t/*for (int i = minh; i <= maxh; i++) {\n\t\t\tfor (int j = minw; j <= maxh; j++) {\n\t\t\t\tprintf(\"%4d \", dp[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tcout << endl;\n\t\tfor (int i = minh; i <= maxh; i++) {\n\t\t\tfor (int j = minw; j <= maxh; j++) {\n\t\t\t\tprintf(\"%4d \", dp2[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tcout << endl;\n\t\tfor (int i = minh; i <= maxh; i++) {\n\t\t\tfor (int j = minw; j <= maxh; j++) {\n\t\t\t\tprintf(\"%4d \", map[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t}\n\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tcout << v.at(i) << \" \" << v2.at(i) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n\nusing namespace std;\n\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef pair<int, int> PII;\n\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n **/\n\nconst int MAP_SIZE = 2000;\n\ninline int SQR(int n) {\n    return n * n;\n}\n\nvector<bool> ERATOSTHENES(int n) {\n    vector<bool> arr(n, true);\n    for (int i = 2; SQR(i) < n; i++) {\n        if (arr[i]) {\n            for (int j = 0; i * (j + 2) < n; j++) {\n                arr[i * (j + 2)] = false;\n            }\n        }\n    }\n    return arr;\n}\n\nvoid makeMap(VVI &map, VVB &used, VB &primes, PII start, int m) {\n    int count = 1;\n    int right = 1;\n    int up = 1;\n    int left = 2;\n    int down = 2;\n    PII point = start;\n\n    while (true) {\n        for (int i = 0; i < right; i++) {\n            if (count < m) {\n                count++;\n                point.second += 1;\n                map[point.first][point.second] = count;\n                if (primes[count]) {\n                    used[point.first][point.second] = true;\n                }\n            }\n        }\n        for (int i = 0; i < up; i++) {\n            if (count < m) {\n                count++;\n                point.first -= 1;\n                map[point.first][point.second] = count;\n                if (primes[count]) {\n                    used[point.first][point.second] = true;\n                }\n            }\n        }\n        for (int i = 0; i < left; i++) {\n            if (count < m) {\n                count++;\n                point.second -= 1;\n                map[point.first][point.second] = count;\n                if (primes[count]) {\n                    used[point.first][point.second] = true;\n                }\n            }\n        }\n        for (int i = 0; i < down; i++) {\n            if (count < m) {\n                count++;\n                point.first += 1;\n                map[point.first][point.second] = count;\n                if (primes[count]) {\n                    used[point.first][point.second] = true;\n                }\n            }\n        }\n\n        if (count < m) {\n            right += 2;\n            up += 2;\n            left += 2;\n            down += 2;\n        } else {\n            break;\n        }\n\n    }\n}\n\nint main() {\n\n    vector<bool> primes = ERATOSTHENES(2000000);\n\n    while (true) {\n        int m, n;\n        cin >> m >> n;\n\n        if (m == 0 && n == 0) break;\n\n        VVI map(MAP_SIZE, VI(MAP_SIZE, 0));\n        VVB used(MAP_SIZE, VB(MAP_SIZE, false));\n        //first = y   second = x\n        PII start(MAP_SIZE / 2, MAP_SIZE / 2);\n        map[start.first][start.second] = 1;\n\n        makeMap(map, used, primes, start, m);\n\n        for (int i = 0; i < map.size(); i++) {\n            for (int j = 0; j < map[i].size(); j++) {\n                if (map[i][j] == n) start = make_pair(i, j);\n            }\n        }\n\n        VVI dp(MAP_SIZE, VI(MAP_SIZE, -1));\n        if (used[start.first][start.second]) {\n            dp[start.first][start.second] = 1;\n        } else {\n            dp[start.first][start.second] = 0;\n        }\n//        for (int j = 2; j <= MAP_SIZE - 2; j++) {\n//            if (used[start.first][j])dp[start.first][j] = 1;\n//        }\n\n        for (int i = start.first + 1; i < MAP_SIZE - 2; i++) {\n            for (int j = 2; j < MAP_SIZE - 2; j++) {\n                if (map[i][j] == 0)continue;\n                int maxV = -1;\n                maxV = max(maxV, dp[i - 1][j - 1]);\n                maxV = max(maxV, dp[i - 1][j]);\n                maxV = max(maxV, dp[i - 1][j + 1]);\n                if (maxV == -1) continue;\n                if (used[i][j]) maxV++;\n                dp[i][j] = maxV;\n            }\n        }\n\n//        for(int i=0;i<dp.size();i++){\n//            for(int j=0;j<dp[i].size();j++){\n//                cout << dp[i][j] << \" \";\n//            }\n//            cout << endl;\n//        }\n//\n//        cout << start.first << \" \"  << start.second;\n\n        int maxV = 0;\n        int number = 0;\n        PII last(0, 0);\n\n        for (int i = 0; i < dp.size(); i++) {\n            for (int j = 0; j < dp[i].size(); j++) {\n                if (used[i][j] && dp[i][j] != 0 && dp[i][j] >= maxV) {\n                    number = map[i][j];\n                    maxV = dp[i][j];\n                    last.first = i;\n                    last.second = j;\n                }\n                maxV = max(maxV, dp[i][j]);\n            }\n        }\n\n        cout << maxV << \" \" << number << endl;\n\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\n#define MAX 1000000\n\nint m,n;\nint cave[1000][1000];\nint dp[1000][1000];\nbool prime[MAX+1];\n\nvoid sieve(){\n  prime[0] = prime[1] = false;\n  for(int i=2;i<MAX+1;i++)\n    prime[i] = true;\n  for(int i=2;i<MAX+1;i++)\n    if(prime[i])\n      for(int j=i*2;j<MAX+1;j+=i)\n\tprime[j]=false;\n}\n\nbool isPrime(int n){\n  return prime[n];\n}\n\nvoid makecave(){\n  int dc[5]={1,0,-1,0,1};\n  int r=0,x=1,num=1;\n  int cx=499,cy=500;\n  while(num<MAX){\n    rep(i,2){\n      rep(k,x){\n\tif(isPrime(num))\n\t  cave[cx][cy]=num;\n\telse\n\t  cave[cx][cy]=num*-1;\n\tnum++;\n\tcx += dc[r%4];\n\tcy += dc[r%4+1];\n      }\n      r++;\n    }\n    x++;\n  }\n}\n\nint max3(int a,int b,int c){\n  int max = a;\n  if (b > max) max = b;\n  if (c > max) max = c;\n  return max;\n}\n\nvoid solve(){\n  rep(i,1000)\n    rep(j,1000)\n      dp[j][i]=0;\n\n  if(!isPrime(n))\n    n*=-1;\n\n  int sx,sy;\n  bool f = false;\n  rep(i,1000){\n    rep(j,1000){\n      if(cave[j][i]==n){\n\tsx = j;\n\tsy = i;\n\tf=true;\n\tbreak;\n      }\n    }\n    if(f)\n      break;\n  }\n  //printf(\"start = (%d,%d)\\n\",sx,sy);\n\n  dp[sx][sy] = (0<cave[sx][sy] && cave[sx][sy]<=m)?1:0;\n  int cx=sx,cy=sy;\n\n  int nmax=0;\n  for(int i=1; i<sqrt(m)+1 && i<1000; i++){\n    for(int j=-i;j<=i;j++){\n      dp[sx+j][sy+i]=\n\t((0<cave[sx+j][sy+i] && cave[sx+j][sy+i]<=m)?1:0)\n\t+max3(dp[sx+j-1][sy+i-1],dp[sx+j][sy+i-1],dp[sx+j+1][sy+i-1]);\n      if(dp[sx+j][sy+i]>nmax)\n\tnmax=dp[sx+j][sy+i];\n    }\n }\n\n  /*\n  for(int i=500-sqrt(m)/2+1;i<500+sqrt(m)/2;i++){\n    for(int j=500-sqrt(m)/2;j<500+sqrt(m)/2-1;j++)\n      printf(\"%3d \",dp[j][i]);\n    putchar('\\n');\n  }\n  */\n  \n  int pmax=0;\n  for(int i=0; i<sqrt(m)+1 && i<1000; i++){\n    for(int j=-i;j<=i;j++){\n      if(dp[sx+j][sy+i]==nmax && pmax<cave[sx+j][sy+i] && cave[sx+j][sy+i]<=m)\n\tpmax = cave[sx+j][sy+i];\n    }\n  }\n  \n  printf(\"%d %d\\n\",nmax,pmax);\n}\n\nint main(){\n  sieve();\n  makecave();\n  for(;;){\n    cin >> m >> n;\n    if(!(m+n)) break;\n\n    /*\n    for(int i=500-sqrt(m)/2+1;i<500+sqrt(m)/2;i++){\n      for(int j=500-sqrt(m)/2;j<500+sqrt(m)/2-1;j++)\n\tprintf(\"%3d \",cave[j][i]);\n      putchar('\\n');\n    } \n    */\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int MAX_M = 1000001;\nconst int C = 1000;\nconst int INF = 1e9;\n#define y first\n#define x second\n\nmap<int, P> itop;\nmap<P, int> ptoi;\nbool isp[MAX_M];\n\nvoid make_prime(){\n  REP(i, MAX_M) isp[i] = true;\n  isp[0] = isp[1] = false;\n  FOR(i, 2, sqrt(MAX_M) + 1){\n    if(!isp[i]) continue;\n    for(int j = i + i; j < MAX_M; j += i) isp[j] = false;\n  }\n}\n\nvoid init(){\n  P now = P(C / 2, C / 2);\n  int c[C][C], pls = 1, l = 1, step = 0, d = 0;\n  memset(c, 0, sizeof(c));\n  FOR(i, 1, MAX_M){\n    itop[i] = now;\n    ptoi[now] = i;\n    if(d == 0) now.x += 1;\n    else if(d == 1) now.y -= 1;\n    else if(d == 2) now.x -= 1;\n    else if(d == 3) now.y += 1;\n    ++step;\n    if(step >= l){\n      d = (d + 1) % 4;\n      step = 0;\n    }\n    if(i != 1 && (d == 0 || d == 2) && step == 0) ++l;\n  }\n}\n\nint main() {\n  make_prime();\n  init();\n  int M, N;\n  while(cin >>M >>N && (N && M)){\n    cout <<\"0 0\" <<endl;\n    //P dp[C][C];\n    //REP(i, C) REP(j, C) dp[i][j] = P(-1, -1);\n    //P now = itop[N], ans = P(-1, -1);\n    //dp[now.y][now.x] = (isp[N] ? P(1, N) : P(0, -1));\n    //REP(y, C){\n    //  REP(x, C){\n    //    if(dp[y][x].first == -1 || ptoi.find(P(y, x)) == ptoi.end()) continue;\n    //    ans = max(ans, dp[y][x]);\n    //    for(int mx = -1; mx <= 1; ++mx){\n    //      int ny = y + 1, nx = x + mx;\n    //      if(ny < 0 || nx < 0 || ny >= C || nx >= C || ptoi.find(P(ny, nx)) == ptoi.end()) continue;\n    //      int cnt = dp[y][x].first + (isp[ptoi[P(ny, nx)]] ? 1 : 0), num = (isp[ptoi[P(ny, nx)]] ? ptoi[P(ny, nx)] : dp[y][x].second);\n    //      if(num > M) continue;\n    //      if(cnt > dp[ny][nx].first || (cnt == dp[ny][nx].first && num > dp[ny][nx].second)) dp[ny][nx] = P(cnt, num);\n    //    }\n    //  }\n    //}\n    //if(ans.first == 0) cout <<\"0 0\" <<endl;\n    //else cout <<ans.first <<\" \" <<ans.second <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint map[2000][2000],dp[2000][2000];\nint isprime[200];\nbool prime[1000001];\nbool square;\nvoid issquare(int n){\n\tsquare=false;\n\tfor(int i=2;i*i<=n;i++)if(n==i*i)square=true;\n\treturn;\n}\nint main(){\n\tfor(int i=0;i<=1000000;i++)prime[i]=true;\n\tprime[1]=false;\n\tint pcnt=0;\n\tfor(int i=2;i<1000;i++){\n\t\tbool ok=true;\n\t\tfor(int j=0;j<pcnt;j++)if(i%isprime[j]==0)ok=false;\n\t\tif(ok){\n\t\t\tfor(int j=i*i;j<=1000000;j+=i)prime[j]=false;\n\t\t\tisprime[pcnt]=i,pcnt++;\n\t\t}\n\t}\n\tfor(int i=0;i<2000;i++)for(int j=0;j<2000;j++){map[i][j]=-1,dp[i][j]=-10000;}\n\tint dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\tint x=1000,y=1000,s=0,t=1,r=1;\n\tmap[999][999]=1;\n\tfor(int k=1;k<=1000000;k++){\n\t\tmap[y][x]=k;\n\t\ty+=dy[r],x+=dx[r];\n\t\tissquare(k+1);\n\t\tif(square)t++;\n\t\tif(s==t){r=(r+1)%4;s=0;}\n\t\ts++;\n\t}//prepara\n\tint n,m;\n\twhile(true){\n\t\tcin>>m>>n;\n\t\tif(n==0&&m==0)break;\n\t\tfor(int i=0;i<2000;i++)for(int j=0;j<2000;j++)dp[i][j]=-10000;\n\t\tint x=0,y=0;\n\t\tbool end=false;\n\t\twhile(true){\n\t\t\twhile(true){\n\t\t\t\tif(map[y][x]==n){end=true;break;}\n\t\t\t\tx++;if(x==2000)break;\n\t\t\t}if(end)break;y++;\n\t\t}\n\t\tint ans=0,set=0;\n\t\tdp[y][x]=0;\n\t\tfor(int i=1;i<2000;i++){\n\t\t\tfor(int j=1;j<1999;j++){\n\t\t\t\tif(map[i][j]>0&&map[i][j]<=m){\n\t\t\t\t\tfor(int k=j-1;k<=j+1;k++)if(map[i-1][k]<=m)dp[i][j]=max(dp[i][j],dp[i-1][k]);\n\t\t\t\t\tdp[i][j]+=prime[map[i][j]];\n\t\t\t\t\tif(ans<dp[i][j])ans=dp[i][j],set=map[i][j];\n\t\t\t\t\tif(ans==dp[i][j]&&prime[map[i][j]]==true&&set<map[i][j])set=map[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<\" \"<<set<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#define rep(i,n) for(lint (i) = 0;(i) < (n);(i)++)\n#define INF (1000000+5)\n#define SZ 1010\n#define BS 505\n#define MAX(a,b) (a)<(b)?(b):(a)\nusing namespace std;\ntypedef long long int lint;\nint go[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nint dw[3][2]={{1,-1},{1,0},{1,1}};\n\nint site[1000000+5][2];\nint prime[1000000+5];\nlint mp[SZ][SZ]={0};\n\nint main(){\n    int m,n;\n    rep(i,1000000+5){\n        prime[i]=-1;\n    }\n    prime[0]=0;\n    prime[1]=0;\n    int now = 2;\n    while(now<1000000+5){\n        if(prime[now]==0){\n            now++;\n            continue;\n        }\n        prime[now]=1;\n        lint temp = now*2;\n        while(temp<1000000+5){\n            prime[temp]=0;\n            temp+=now;\n        }\n        now++;\n    }\n    rep(i,SZ){\n        rep(j,SZ){\n            mp[i][j]=INF;\n        }\n    }\n    int at[2]={BS,BS};\n    int dir=0;\n    for(int i = 1;i <= 1000000+6;i++){\n        mp[at[0]][at[1]]=i;\n        site[i][0]=at[0],site[i][1]=at[1];\n        int ndir = (dir + 1)%4;\n        if(mp[at[0]+go[ndir][0]][at[1]+go[ndir][1]]==INF){\n            at[0]+=go[ndir][0];\n            at[1]+=go[ndir][1];\n            dir = ndir;\n        }else{\n            at[0]+=go[dir][0];\n            at[1]+=go[dir][1];\n        }\n    }\n    while(cin>>m>>n&&m){\n        int dp[SZ][SZ];\n        rep(i,SZ){\n            rep(j,SZ){\n                dp[i][j]=-1;\n            }\n        }\n\n        dp[site[n][0]][site[n][1]]=prime[n];\n        for(int i=0;i<SZ-1;i++){\n            for(int j=1;j<SZ-1;j++){\n                rep(k,3){\n                    int hoge[2] = {i+dw[k][0],j+dw[k][1]};\n                    if(mp[i][j]<=m&&mp[hoge[0]][hoge[1]]<=m&&dp[i][j]!=-1){\n                        dp[hoge[0]][hoge[1]]=MAX(dp[hoge[0]][hoge[1]],dp[i][j]+prime[mp[hoge[0]][hoge[1]]]);\n                    }\n                }\n            }\n        }/*\n        for(int x = -10;x < 10;x++){\n            for(int y = -10;y < 10;y++){\n                printf(\"%5d\", dp[BS+x][BS+y]);\n            }\n            cout << endl;\n        }\n        for(int x = -10;x < 10;x++){\n            for(int y = -10;y < 10;y++){\n                printf(\"%5d\", prime[mp[BS+x][BS+y]]);\n            }\n            cout << endl;\n        }\n        for(int x = -10;x < 10;x++){\n            for(int y = -10;y < 10;y++){\n                printf(\"%ll\", mp[BS+x][BS+y]);\n            }\n            cout << endl;\n        }*/\n\n        lint retp = 0;\n        lint ret = 0;\n        for(int i = SZ-1;i >= 0;i--){\n\n            rep(j,SZ){\n                if(ret<dp[i][j]){\n                    ret = dp[i][j];\n                }\n            }\n            if(ret != 0){\n                break;\n            }\n        }\n        cout << ret <<  \" \" << retp << endl;\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; ++i)\nusing namespace std;\nusing ll = long long;\n\nconst int limit = 1000000;\nint posr[limit+10],posc[limit+10];\nint number[1010][1010];\n\nbool prime[limit+10];\n\nconst int dr[4]={0,-1,0,1};\nconst int dc[4]={1,0,-1,0};\n\nvoid init(){\n\trep(i,limit+1) prime[i] = true;\n\tprime[0] = prime[1] = false;\n\n\tfor(ll i = 2; i <= limit; ++i){\n\t\tif(prime[i]){\n\t\t\tfor(ll j = i*i; j <= limit; j+=i){\n\t\t\t\tprime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tint r = 500, c = 499, cnt = 1, step = 0;\n\n\twhile(cnt < limit){\n\t\trep(dir,4){\n\t\t\tif(dir % 2 ==0) step++;\n\t\t\trep(loop,step){\n\t\t\t\tif(cnt > limit) break;\n\t\t\t\tnumber[r][c] = cnt;\n\t\t\t\tposr[cnt]=r,posc[cnt]=c;\n\t\t\t\tcnt++;\n\t\t\t\tr += dr[dir];\n\t\t\t\tc += dc[dir];\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nusing pii = pair<int,int>;\nconst pii ban = pii(-1,-1);\npii dp[1010][1010];\n\ninline pii chmax(pii a,pii b){\n\tpii ret = a;\n\tif(a.first < b.first) ret = b;\n\tif(a.first == b.first and a.second < b.second) ret = b;\n\treturn ret;\n}\n\n\nint main(void){\n\tinit();\n\n\tint m,n;\n\twhile(cin >> m >> n,m){\n\t\trep(i,1010)rep(j,1010) dp[i][j]=ban;\n\n\t\tconst int sr = posr[n],sc = posc[n];\n\t\t\n\t\tif(prime[n]){\n\t\t\tdp[sr][sc] = pii(1,n);\n\t\t}else{\n\t\t\tdp[sr][sc] = pii(0,0);\n\t\t}\n\n\t\tpii ans = ban;\n\n\t\tfor(int r = sr; r < 1000; ++r){\n\t\t\trep(c,1000){\n\t\t\t\tconst int cur = number[r][c];\n\t\t\t\tif(cur > m) continue;\n\t\t\t\tif(dp[r][c] == ban) continue;\n\n\t\t\t\tfor(auto &col:{c-1,c,c+1}){\n\t\t\t\t\tif(col < 0 or 1000 <= col) continue;\n\t\t\t\t\tconst int tar = number[r+1][col];\n\t\t\t\t\tif(tar > m) continue;\n\t\t\t\t\tpii cur = dp[r][c];\n\t\t\t\t\tif(prime[tar]) cur.first++,cur.second = tar;\n\t\t\t\t\tdp[r+1][col] = chmax(dp[r+1][col],cur);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trep(r,1000)rep(c,1000){\n\t\t\tif(number[r][c] > m) continue;\n\t\t\tans = chmax(ans,dp[r][c]);\n\t\t}\n\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\nint main ()\n{\n    const int INF = 1 << 28;\n    const int MAX = 1000000;\n    const int dx[] = { 1, 0,-1, 0};\n    const int dy[] = { 0,-1, 0, 1};\n    const int dm[] = {-1, 0, 1};\n    int n, m;\n    map<P, int> M;\n    vector<P> d(MAX+1, P(INF,INF));\n\n    M[P(0,0)] = 1;\n    d[1] = P(0,0);\n    int x = 1, y = 0;\n    int c = 1;\n    for (int i = 2; i <= MAX; i++) {\n        c %= 4;\n        int cdir = 4 + c - 1;\n        cdir %= 4;\n        int sy = y - dy[cdir], sx = x - dx[cdir];\n        M[P(y,x)] = i;\n        d[i] = P(y,x);\n         if (M.find(P(sy,sx)) != M.end()) {\n            x += dx[c];\n            y += dy[c];\n         } else {\n             x = sx;\n             y = sy;\n             c++;\n         }\n    }\n\n    vector<bool> prim(MAX+1, true);\n    prim[0] = prim[1] = false;\n    for (int i = 2; i <= MAX / 2; i++) {\n        for (int j = 2; prim[i] && j * i <= MAX; j++) {\n            prim[i * j] = false;\n        }\n    }\n\n    while (cin >> n >> m , n + m) {\n        int res = 0;\n        int res_n = 0;\n        queue<pair<int,P> > q;\n\n        vector<int> count(MAX+1, 0);\n        if (prim[m]) {\n            count[m] = 1;\n            q.push(pair<int,P>(1, d[m]));\n            res = 1;\n            res_n = m;\n        } else {\n            count[m] = 0;\n            q.push(pair<int,P>(0, d[m]));\n        }\n\n        vector<bool> used(MAX + 1, false);\n\n        while (q.size()) {\n            pair<int,P> pp = q.front(); q.pop();\n            P p = pp.second;\n            int num = M[p];\n            int ret = pp.first;\n\n            if (count[num] > ret) continue;\n            used[num] = true;\n            y = p.first, x = p.second;\n            for (int i = 0; i < 3; i++) {\n                int ny = y + 1, nx = x + dm[i];\n                if (M.find(P(ny, nx)) != M.end() && M[P(ny,nx)] <= n) {\n                    int t_n = M[P(ny,nx)];\n                    if (count[t_n] == 0 || count[t_n] < count[num] + (prim[t_n] ? 1 : 0)) {\n\n                        if (!used[t_n] || count[t_n] < count[num] + (prim[t_n] ? 1 : 0)) {\n                            count[t_n] = count[num] + (prim[t_n] ? 1 : 0);\n                            q.push(pair<int,P>(count[t_n], P(ny,nx)));\n                            used[t_n] = true;\n                        }\n                        if (res <= count[t_n] && prim[t_n]) {\n                            if (res < count[t_n]) {\n                                res = count[t_n];\n                                res_n =  t_n;\n                            } else {\n                                res_n = max(t_n, res_n);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (res == 0)\n            cout << 0 << \" \" << 0 << endl;\n        else\n            cout << res << \" \" << res_n << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nbool is_prime[1100001];\nint cav[4000][4000];\nP mem[4000][4000];\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\n\nP dfs(int i,int j,int maxp){\n  if(cav[i][j]>maxp)return P(0,0);\n  if(mem[i][j]!=P(-1,-1))return mem[i][j];\n  P res=P(0,0);\n  if(i+1<4000){\n    res=max(res,dfs(i+1,j,maxp));\n    if(j-1>=0)res=max(res,dfs(i+1,j-1,maxp));\n    if(j+1<4000)res=max(res,dfs(i+1,j+1,maxp));\n  }\n  if(is_prime[cav[i][j]]){\n    if(res.first==0)res.second=cav[i][j];\n    res.first++;\n  }\n  return mem[i][j]=res;\n}\n\nint main(void) {\n  is_prime[0]=is_prime[1]=false;\n  for(int i=2;i<=1100000;i++)is_prime[i]=true;\n  for(int i=2;i<=1100000;i++){\n    if(is_prime[i]){\n      for(int j=i*2;j<=1100000;j+=i)is_prime[j]=false;\n    }\n  }\n  rep(i,4000)rep(j,4000)cav[i][j]=INF;\n  int si=2000,sj=2000,len=1,num=1,dir=0;\n  while(num<=1000000){\n    rep(i,len){\n      cav[si][sj]=num++;\n      si+=dy[dir];\n      sj+=dx[dir];\n    }\n    dir=(dir+1)%4;\n    if(dir==0||dir==2)len++;\n  }\n  while(1) {\n    int n,s;\n    cin>>n>>s;\n    if(n==0&&s==0)break;\n    rep(i,4000)rep(j,4000)mem[i][j]=P(-1,-1);\n    P res=P(0,0);\n    rep(i,4000)rep(j,4000){\n      if(cav[i][j]==s){\n        res=dfs(i,j,n);\n        break;\n      }\n    }\n    printf(\"%d %d\\n\", res.first,res.second);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n/*\n100 099 098 097 096 095 094 093 092 091\n065 064 063 062 061 060 059 058 057 090\n066 037 036 035 034 033 032 031 056 089\n067 038 017 016 015 014 013 030 055 088\n068 039 018 005 004 003 012 029 054 087\n069 040 019 006 001 002 011 028 053 086\n070 041 020 007 008 009 010 027 052 085\n071 042 021 022 023 024 025 026 051 084\n072 043 044 045 046 047 048 049 050 083\n073 074 075 076 077 078 079 080 081 082\n*/\n\nconst int MAX_N = 1000;\nconst int MAX_N2 = MAX_N * MAX_N;\n\nint caves[MAX_N][MAX_N]; // ここに置かないとSegmentation falutになる\npair<short, int> dp[MAX_N][MAX_N]; // 素数洞穴の数、最後に通った素数洞穴の番号\nbool is_prime[MAX_N2 + 1];\n\n// 入力\nint n, m;\n\nvoid sieve() {\n\tfor (int i = 0; i <= MAX_N2; i++) {\n\t\tis_prime[i] = true;\n\t}\n\tis_prime[0] = is_prime[1] = false;\n\tfor (int i = 2; i <= MAX_N2; i++) {\n\t\tif (is_prime[i]) {\n\t\t\tfor (int j = 2 * i; j <= MAX_N2; j += i) {\n\t\t\t\tis_prime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn;\n}\n\n// 初期化 素数表と洞穴を作成\nvoid init() {\n\tsieve();\n\tint dx[4] = {1, 0, -1, 0};\n\tint dy[4] = {0, 1, 0, -1};\n\t\n\tint num = MAX_N2;\n\tint array = 0;\n\tint x = 0;\n\tint y = 0;\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tcaves[i][j] = 0;\n\t\t}\n\t}\n\t\n\tfor (int i = num; i > 0; i--) {\n\t\tcaves[y][x] = i;\n\t\tint tx = x + dx[array];\n\t\tint ty = y + dy[array];\n\t\tif (tx < 0 || tx >= MAX_N || ty < 0 || ty >= MAX_N || caves[ty][tx] != 0) {\n\t\t\tarray = (array + 1) % 4;\n\t\t}\n\t\tx += dx[array];\n\t\ty += dy[array];\n\t}\n\t/*\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tif (j > 0) {\n\t\t\t\tcout << \" \";\n\t\t\t}\n\t\t\tprintf(\"%7d\", caves[i][j]);\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n\treturn;\n}\n\nvoid search(int sx, int sy) {\n\tfor (int i = MAX_N - 1; i >= 0; i--) {\n\t\tfor (int j = MAX_N - 1; j >= 0; j--) {\n\t\t\tif (caves[i][j] > m) {\n\t\t\t\tdp[i][j].first = 0;\n\t\t\t\tdp[i][j].second = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == MAX_N - 1) {\n\t\t\t\tif (is_prime[caves[i][j]]) {\n\t\t\t\t\tdp[i][j].first = 1;\n\t\t\t\t\tdp[i][j].second = caves[i][j];\n\t\t\t\t} else {\n\t\t\t\t\tdp[i][j].first = 0;\n\t\t\t\t\tdp[i][j].second = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpair<short, int> tmp[3];\n\t\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\t\tif (j + k < 0 || j + k >= MAX_N) {\n\t\t\t\t\t\ttmp[k+1].first = 0;\n\t\t\t\t\t\ttmp[k+1].second = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttmp[k+1].first = dp[i+1][j+k].first;\n\t\t\t\t\t\ttmp[k+1].second = dp[i+1][j+k].second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsort(tmp, tmp + 3, greater<pair<short, int> >());\n\t\t\t\tdp[i][j].first = tmp[0].first;\n\t\t\t\tdp[i][j].second = tmp[0].second;\n\t\t\t\tif (is_prime[caves[i][j]]) {\n\t\t\t\t\tdp[i][j].first++;\n\t\t\t\t\tif (dp[i][j].second == 0) {\n\t\t\t\t\t\tdp[i][j].second = caves[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nvoid solve(int sx, int sy) {\n\tsearch(sx, sy);\n\tcout << dp[sy][sx].first << \" \" << dp[sy][sx].second << endl;\n}\n\nint main() {\n\tinit();\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tint sx, sy;\n\t\tfor (int i = 0; i < MAX_N; i++) {\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tdp[i][j].first = 0;\n\t\t\t\tdp[i][j].second = 0;\n\t\t\t\tif (caves[i][j] == n) {\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve(sx, sy);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int MAX_M = 1000001;\nconst int C = 1000;\nconst int INF = 1e9;\n#define y first\n#define x second\n\nmap<int, P> itop;\nmap<P, int> ptoi;\nbool isp[MAX_M];\n\nvoid make_prime(){\n  REP(i, MAX_M) isp[i] = true;\n  isp[0] = isp[1] = false;\n  FOR(i, 2, sqrt(MAX_M) + 1){\n    if(!isp[i]) continue;\n    for(int j = i + i; j < MAX_M; j += i) isp[j] = false;\n  }\n}\n\nvoid init(){\n  P now = P(C / 2, C / 2);\n  int pls = 1, l = 1, step = 0, d = 0;\n  FOR(i, 1, MAX_M){\n    itop[i] = now;\n    ptoi[now] = i;\n    if(d == 0) now.x += 1;\n    else if(d == 1) now.y -= 1;\n    else if(d == 2) now.x -= 1;\n    else if(d == 3) now.y += 1;\n    ++step;\n    if(step >= l){\n      d = (d + 1) % 4;\n      step = 0;\n    }\n    if(i != 1 && (d == 0 || d == 2) && step == 0) ++l;\n  }\n}\n\nint main() {\n  make_prime();\n  init();\n  int M, N;\n  while(cin >>M >>N && (N && M)){\n    P dp[C][C];\n    REP(i, C) REP(j, C) dp[i][j] = P(-1, -1);\n    P now = itop[N], ans = P(-1, -1);\n    dp[now.y][now.x] = (isp[N] ? P(1, N) : P(0, -1));\n    REP(y, C){\n      REP(x, C){\n        if(dp[y][x].first == -1 || ptoi.find(P(y, x)) == ptoi.end()) continue;\n        ans = max(ans, dp[y][x]);\n        for(int mx = -1; mx <= 1; ++mx){\n          int ny = y + 1, nx = x + mx;\n          if(ny < 0 || nx < 0 || ny >= C || nx >= C || ptoi.find(P(ny, nx)) == ptoi.end()) continue;\n          int cnt = dp[y][x].first + (isp[ptoi[P(ny, nx)]] ? 1 : 0), num = (isp[ptoi[P(ny, nx)]] ? ptoi[P(ny, nx)] : dp[y][x].second);\n          if(num > M) continue;\n          if(cnt > dp[ny][nx].first || (cnt == dp[ny][nx].first && num > dp[ny][nx].second)) dp[ny][nx] = P(cnt, num);\n        }\n      }\n    }\n    if(ans.first == 0) cout <<\"0 0\" <<endl;\n    else cout <<ans.first <<\" \" <<ans.second <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<cassert>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<numeric>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\n\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n\n//??¨????????????????????????\n//n??\\????????£??´??°????´???°???????????°???????????????is_prime[]???????´?\nvoid eratos(int n, bool is_prime[]) {\n\tfill(is_prime, is_prime + n + 1, true);\n\tis_prime[0] = is_prime[1] = false;\n\tfor (int i = 2; i*i <= n; i++) {\n\t\tif (is_prime[i]) {\n\t\t\tint j = i + i;\n\t\t\twhile (j <= n) {\n\t\t\t\tis_prime[j] = false;\n\t\t\t\tj = j + i;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic signed char c[1050][1050]; //?´???° or ????????° or ?´???´?????????\nstatic pii dp[1050][1050]; //?´???°?´???´????????° ??????????????????????´???°?´???´????????§??????\nstatic bool a[1050][1050]; //?´???´?????¢?´¢??????????????????\nstatic int num[1050][1050]; //xy??§?¨??????????????????´??°\npii dfs(int x, int y) {\n\tif (c[x][y] == -1)return pii(0, 0);\n\tif (a[x][y])return dp[x][y];\n\ta[x][y] = true;\n\n\n\tpii l = dfs(x - 1, y + 1);\n\tpii b = dfs(x, y + 1);\n\tpii r = dfs(x + 1, y + 1);\n\n\t//cout << x << \" \" << y << endl;\n\t//cout << l << \" \" << d << \" \" << r << endl;\n\n\tpii ret = max(b, max(l, r));\n\tint second = (ret.second == 0) ? ((c[x][y] == 1) ? num[x][y] : 0) : ret.second;\n\treturn dp[x][y] = pii(\n\t\tret.first + c[x][y],\n\t\tsecond\n\t);\n}\n\n#define MAX 1000001\n\nint main() {\n\tstatic bool is_prime[MAX];\n\teratos(MAX, is_prime);\n\tint O = 505;\n\tfor (int m, n; cin >> m >> n&&m;) {\n\t\tmemset(c, -1, sizeof(c));\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tmemset(a, false, sizeof(a));\n\t\tint sx, sy;\n\t\tint x = O, y = O;\n\t\tint p = 1;\n\t\tfor (int i = 1; p <= m;) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tnum[x][y] = p;\n\t\t\t\tif (p == n)sx = x, sy = y;\n\t\t\t\tc[x++][y] = (p <= m) ? is_prime[p] : -1;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tnum[x][y] = p;\n\t\t\t\tif (p == n)sx = x, sy = y;\n\t\t\t\tc[x][y--] = (p <= m) ? is_prime[p] : -1;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\ti++;\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tnum[x][y] = p;\n\t\t\t\tif (p == n)sx = x, sy = y;\n\t\t\t\tc[x--][y] = (p <= m) ? is_prime[p] : -1;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tnum[x][y] = p;\n\t\t\t\tif (p == n)sx = x, sy = y;\n\t\t\t\tc[x][y++] = (p <= m) ? is_prime[p] : -1;\n\t\t\t\tp++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\t//for (int y = 490; y < 520; y++) {\n\t\t//\tfor (int x = 490; x < 520; x++) {\n\t\t//\t\tcout << b[x][y];\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\tpii ans = dfs(sx, sy);\n\t\tcout << ans.first << \" \" << ans.second << endl;;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\nclass Task{\npublic:\n\tint y,x;\n\tint c,M;\n\tTask(int y,int x,int c,int M):y(y),x(x),c(c),M(M){}\n\tbool operator < (const Task& r) const{\n\t\tif(c!=r.c)return c<r.c;\n\t\treturn M<r.M;\n\t}\n};\nint INF=1<<28;\n\nclass Main{\npublic:\n\t\n\tint m,n;\n\tbool input(){\n\t\tcin >> m >> n;if(m==0 && n==0)return false;\n\t\treturn true;\n\t}\n\n\tvector<bool> sieve(const int M){\n\t\tvector<bool> isPrime(M);\n\t\tfor(int i=2;i<M;i++) isPrime[i] = true;\n\t\tfor(int i=2;i*i < M;i++){\n\t\t\tif(! isPrime[i]) continue;\n\t\t\tfor(int j=i*i;j<M;j+=i)isPrime[j] = false;\n\t\t}\n\t\treturn isPrime;\n\t}\n\n\tbool comp(int c1,int M1,int c2,int M2){\n\t\tif(c1!=c2)return c1<c2;\n\t\treturn M1<M2;\n\t}\n\n\n\tint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\n\tvoid run(){\n\t\t//prime\n\t\tvector<bool> ps=sieve(4000050);\n\n\t\tvector<vector<int>> board(2100,vector<int>(2100));\n\t\tvector<int> xs(4000050),ys(4000050);\n\n\t\tint y=1050,x=1050,v=1;\n\t\tboard[y][x]=v;xs[v]=x;ys[v]=y;v++;\n\t\tint d=1,dir=0;\n\t\twhile(v<3000050){\n\n\t\t\tREP(_d,d){\n\t\t\t\ty+=dy[dir];x+=dx[dir];\n\t\t\t\tboard[y][x]=v;xs[v]=x;ys[v]=y;v++;\n\t\t\t}\n\t\t\tdir=(dir-1+4)%4;\n\t\t\tif(dir%2==0)d++;\n\t\t}\n\n\t\twhile(input()){\n\t\t\tvector<vector<pair<int,int>>> dp(2100,vector<pair<int,int>>(2100,make_pair(-INF,-INF)));\n\n\n\t\t\tpair<int,int> res=make_pair(0,0);\n\n\t\t\tint pc=0,pM=0;\n\t\t\tif(ps[n])pc++,pM=n;\n\t\t\tdp[ys[n]][xs[n]]=make_pair(pc,pM);\n\t\t\tfor(int y=ys[n];y<2100;y++){\n\t\t\t\tREP(x,2100){\n\t\t\t\t\tfor(int dx=-1;dx<=1;dx++){//move\n\t\t\t\t\t\tint nx=x+dx,ny=y+1;if(!IN(0,ny,2100)|| !IN(0,nx,2100))continue;\n\t\t\t\t\t\tint nv=board[ny][nx];if(!(nv<=m))continue;\n\t\t\t\t\t\tint nc=dp[y][x].first,nM=dp[y][x].second;\n\t\t\t\t\t\tif(ps[nv])nc++,nM=nv;\n\t\t\t\t\t\tif(comp(dp[ny][nx].first,dp[ny][nx].second,nc,nM)){\n\t\t\t\t\t\t\tdp[ny][nx]=make_pair(nc, nM);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t//end\n\t\t\t\t\tbool end=true;\n\t\t\t\t\tfor(int dx=-1;dx<=1;dx++){\n\t\t\t\t\t\tint nx=x+dx,ny=y+1;if(!IN(0,ny,2100)|| !IN(0,nx,2100))continue;\n\t\t\t\t\t\tint nv=board[ny][nx];if(!(nv<=m))continue;\n\t\t\t\t\t\tend=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(end)res=max(dp[y][x],res);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout <<res.first <<\" \"<<res.second<<endl;\n\t\t}\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int MAX = 1500;\nconst int MAX2 = 1000000;\nconst int dy[4] = {0,-1,0,1};\nconst int dx[4] = {1,0,-1,0};\n\nint n,m,G[MAX][MAX];\nbool isPrime[MAX2+1];\nP pos[MAX2+1];\n\nbool check(int y, int x){\n  if(y < 0 || y >= MAX) return false;\n  if(x < 0 || x >= MAX) return false;\n  if(G[y][x] > m || G[y][x] == 0) return false;\n  return true;\n}\n\nvoid makeP(){\n  fill(isPrime, isPrime+MAX2+1, true);\n  isPrime[0] = isPrime[1] = false;\n  for(int i=2;i<=MAX2;i++){\n    if(isPrime[i]){\n      for(int j=i*2;j<=MAX2;j+=i) isPrime[j] = false;\n    }\n  }\n}\n\nvoid makeG(){\n  int y = MAX / 2, x = MAX / 2, step = 0;\n  fill(G[0],G[MAX],0);\n  for(int i=1;i<=MAX2;){\n    for(int j=0;j<4;j++){\n      if(j % 2 == 0) step++;\n      for(int k=0;k<step;k++){\n        pos[i] = P(x,y);\n        G[y][x] = i++;\n        y += dy[j];\n        x += dx[j];\n      }\n    }\n  }\n}\n\nint dp[MAX][MAX],dp2[MAX][MAX];\n\nvoid solve(){\n  int ans=0, ans2=0;\n  fill(dp[0],dp[MAX],-1);\n  fill(dp2[0],dp2[MAX],0);\n  dp[pos[n].second][pos[n].first] = isPrime[n];\n  if(isPrime[n]) dp2[pos[n].second][pos[n].first] = n;\n\n  for(int i=pos[n].second;i<MAX;i++){\n    for(int j=0;j<MAX;j++){\n      if(dp[i][j] == -1) continue;\n\n      if(ans < dp[i][j]){\n        ans = dp[i][j];\n        ans2 = dp2[i][j];\n      } else if(ans == dp[i][j]) ans2 = max(ans2, dp2[i][j]);\n\n      for(int k=-1;k<=1;k++){\n        int ny = i + 1;\n        int nx = j + k;\n        if(check(ny,nx)){\n          if(dp[ny][nx] < dp[i][j] + isPrime[G[ny][nx]]){\n            dp[ny][nx] = dp[i][j] + isPrime[G[ny][nx]];\n            if(isPrime[G[ny][nx]]) dp2[ny][nx] = G[ny][nx];\n            else dp2[ny][nx] = dp2[i][j];\n          } else if(dp[ny][nx] == dp[i][j] + isPrime[G[ny][nx]]){\n            if(isPrime[G[ny][nx]]) dp2[ny][nx] = max(dp2[ny][nx], G[ny][nx]);\n            else dp2[ny][nx] = max(dp2[ny][nx], dp2[i][j]);\n          }\n        }\n      }\n    }\n  }\n  cout << ans << ' ' << ans2 << endl;\n}\n\nint main(){\n  makeP();\n  makeG();\n  while(cin >> m >> n && (n|m)) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 100;\n\tint m, n;\n\tbool prime[SIZE * SIZE + 1];\n\tint table[SIZE][SIZE];\n\tint dp[SIZE][SIZE];\n\tint pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tint res1, res2;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d %d\", &m, &n);\n\t\tif (m == 0 || n == 0)return 0;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = SIZE - 1;i >= 0;i--){\n\t\t\tfor(int j = SIZE - 1;j >= 0;j--){\n\t\t\t\tif (table[i][j] <= m) {\n\t\t\t\t\tif (i + 1 < SIZE) {\n\t\t\t\t\t\tif (j > 0 && table[i + 1][j - 1] <= m && (dp[i][j] < dp[i + 1][j - 1] || (dp[i][j] == dp[i + 1][j - 1] && pr[i][j] < pr[i + 1][j - 1]))) {\n\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j - 1];\n\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j - 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (table[i + 1][j] <= m && (dp[i][j] < dp[i + 1][j] || (dp[i][j] == dp[i + 1][j] && pr[i][j] < pr[i + 1][j]))) {\n\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j];\n\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j + 1 < SIZE && table[i + 1][j + 1] <= m && (dp[i][j] < dp[i + 1][j + 1] || (dp[i][j] == dp[i + 1][j + 1] && pr[i][j] < pr[i + 1][j + 1]))) {\n\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j + 1];\n\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!prime[table[i][j]]) {\n\t\t\t\t\t\tdp[i][j]++;\n\t\t\t\t\t\tif (pr[i][j] == 0) {\n\t\t\t\t\t\t\tpr[i][j] = table[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tprintf(\"%d %d\\n\", dp[i][j], pr[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n//#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n//#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#include <array>\n//#include <atomic>\n#include <chrono>\n//#include <condition_variable>\n#include <forward_list>\n//#include <future>\n#include <initializer_list>\n//#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n//#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\n\nint main ()\n{\n\tint M , N;\n\tint ii[1000];\n\tfor( size_t i = 0; i < 1000; i++ )\n\t{\n\t\tii[i] = i*i;\n\t}\n\n\tint dx[] = { 1 , 0 , -1 , 0 };\n\tint dy[] = { 0 , -1 , 0 , 1 };\n\tvector<vector<int>>data ( 1e3 + 5 , vector<int> ( 1e3 + 5 , INT_MAX ) );\n\t{\n\t\tint nowx = ( 1e3 / 2 + 1 ) , nowy = ( 1e3 / 2 ) + 1;\n\t\tint nowz = 3;\n\t\tfor( size_t i = 1; i < 1e6 + 10; i++ )\n\t\t{\n\t\t\tif( data[nowx + dx[( nowz + 1 ) % 4]][nowy + dy[( nowz + 1 ) % 4]] == INT_MAX )\n\t\t\t{\n\t\t\t\tnowz = ( nowz + 1 ) % 4;\n\t\t\t}\n\t\t\tdata[nowx + dx[nowz]][nowy + dy[nowz]] = i;\n\n\t\t\tnowx = nowx + dx[nowz];\n\t\t\tnowy = nowy + dy[nowz];\n\t\t}\n\t}\n\tbool pri[(int) ( 1e6 + 3 )];\n\tpri[0] = 1;\n\tpri[1] = 1;\n\tfor( size_t i = 2; i < 1e6 + 3; i++ )\n\t{\n\t\tif( pri[i] == 0 )\n\t\t{\n\t\t\tfor( size_t j = 2; j*i < 1e6 + 3; j++ )\n\t\t\t{\n\t\t\t\tpri[i*j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\twhile( cin >> M >> N , M || N )\n\t{\n\t\tpair<int , int>S;\n\t\tint ans1 = 0 , ans2 = 0;\n\t\t//vector<vector<int>>data2 ( 1e3 + 5 , vector<int> ( 1e3 + 5 , 0 ) );\n\t\tmap < int , map < int , int >>data2;\n\t\tfor( size_t i = 0; i < 1e3 + 5; i++ )\n\t\t{\n\t\t\tfor( size_t j = 0; j < 1e3 + 5; j++ )\n\t\t\t{\n\t\t\t\tif( data[i][j] == N )\n\t\t\t\t{\n\t\t\t\t\tS.first = i;\n\t\t\t\t\tS.second = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( S.first )\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tqueue<pair<int , int>>que;\n\t\tque.push ( S );\n\t\tif( !pri[data[S.first][S.second]] )\n\t\t{\n\t\t\tans1 = data[S.first][S.second];\n\t\t\tans2 = 1;\n\t\t\tdata2[S.first][S.second] = 1;\n\t\t}\n\t\twhile( que.size () )\n\t\t{\n\t\t\tpair<int , int>now = que.front (); que.pop ();\n\t\t\tint nowx = now.first;\n\t\t\tint nowy = now.second;\n\t\t\t//cout << data[nowx][nowy] << endl;\n\t\t\tfor( int i = 1; i >= -1; i-- )\n\t\t\t{\n\t\t\t\tif( !( nowx + 1 < 1e3 + 5 && nowy + i < 1e3 + 5 && nowy + i >= 0 ) )continue;\n\t\t\t\tif( data[nowx][nowy] != 2 && nowx + 1 + nowy + i % 2 == 0 )continue;\n\t\t\t\tif( data[nowx + 1][nowy + i] <= M )\n\t\t\t\t{\n\t\t\t\t\tif( !data2[nowx + 1][nowy + i] )que.push ( pair<int , int> ( nowx + 1 , nowy + i ) );\n\t\t\t\t\tif( !pri[data[nowx + 1][nowy + i]] )\n\t\t\t\t\t{\n\t\t\t\t\t\tif( data2[nowx + 1][nowy + i] < data2[nowx][nowy] + 1 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdata2[nowx + 1][nowy + i] = data2[nowx][nowy] + 1;\n\t\t\t\t\t\t\tif( ans2 <= data2[nowx + 1][nowy + i] )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif( ans2 == data2[nowx + 1][nowy + i] )\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tans1 = max ( data[nowx + 1][nowy + i] , ans1 );\n\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tans1 = data[nowx + 1][nowy + i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tans2 = data2[nowx + 1][nowy + i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tif( data2[nowx + 1][nowy + i] < data2[nowx][nowy] )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdata2[nowx + 1][nowy + i] = data2[nowx][nowy];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans2 << \" \" << ans1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint n, m;\nint a[2000][2000];\nint b[2000][2000];\nint c[2000][2000];\nint e[2000][2000];\nint sx[1000005];\nint sy[1000005];\nint p[1000005];\nvoid prime()\n{\n\tint i, j;\n\tp[1] = 1;\n\tfor(i=2;i<=1000000;i++)\n\t{\n\t\tif(p[i] == 0)\n\t\t{\n\t\t\tfor(j=2*i;j<=1000000;j+=i)\n\t\t\t{\n\t\t\t\tp[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid inil()\n{\n\tint i, j;\n\tprime();\n\tint x,y,d;\n\tint dx[4]={1,0,-1,0};\n\tint dy[4]={0,1,0,-1};\n\td = 0;\n\tx = y = 1000;\n\tint k=1;\n\tint td;\n\twhile(k<=1000000)\n\t{\n\t\ta[x][y] = k;\n\t\tsx[k] = x;\n\t\tsy[k] = y;\n\t\tif(p[k] == 0)\n\t\t\tb[x][y] = 1;\n\t\ttd = (d+1)%4;\n\t\tif(a[dx[td] + x][dy[td] + y] == 0)\n\t\t\td = td;\n\t\tx = x+dx[d];\n\t\ty = y+dy[d];\n\t\tk++;\n\t}\n}\nvoid process()\n{\n\tint i, j, k;\n\tint x,y;\n\tx = sx[m];\n\ty = sy[m];\n\tfor(i=0;i<2000;i++)\n\t\tfor(j=0;j<2000;j++)\n\t\t\tc[i][j] = e[i][j]=0;\n\tif(p[a[x][y]]==0)\n\t{\n\t\tc[x][y]=1;\n\t\te[x][y] = a[x][y];\n\t}\n\tfor(i=x+1;i<1888;i++)\n\t{\n\t\tfor(j=y-i+x;j<=y+i-x;j++)\n\t\t{\n\t\t\tif(j<0)continue;\n\t\t\tif(j>1888)continue;\n\t\t\tif(a[i][j] == 0 || a[i][j] > n) continue;\n\t\t\t//printf(\"%d %d  %d %d\\n\",x,y,i,j);\n\t\t\tk = (p[a[i][j]]==0);\n\t\t\tif(c[i][j] < c[i-1][j-1] + k)\n\t\t\t{\n\t\t\t\tc[i][j] = c[i-1][j-1]+k;\n\t\t\t\te[i][j] = e[i-1][j-1];\n\t\t\tif(k)e[i][j] = a[i][j];\n\t\t\t}\n\t\t\telse if(c[i][j] == c[i-1][j-1]+k)\n\t\t\t{\n\t\t\t\te[i][j] = e[i-1][j-1];\n\t\t\tif(k)e[i][j] = a[i][j];\n\t\t\t}\n\t\t\tif(c[i][j] < c[i-1][j] + k)\n\t\t\t{\n\t\t\t\tc[i][j] = c[i-1][j]+k;\n\t\t\t\te[i][j] = e[i-1][j];\n\t\t\tif(k)e[i][j] = a[i][j];\n\t\t\t}\n\t\t\telse if(c[i][j] == c[i-1][j]+k)\n\t\t\t{\n\t\t\t\te[i][j] = e[i-1][j];\n\t\t\tif(k)e[i][j] = a[i][j];\n\t\t\t}\n\t\t\tif(c[i][j] < c[i-1][j+1] + k)\n\t\t\t{\n\t\t\t\tc[i][j] = c[i-1][j+1]+k;\n\t\t\t\te[i][j] = e[i-1][j+1];\n\t\t\tif(k)e[i][j] = a[i][j];\n\t\t\t}\n\t\t\telse if(c[i][j] == c[i-1][j+1]+k)\n\t\t\t{\n\t\t\t\te[i][j] = e[i-1][j+1];\n\t\t\tif(k)e[i][j] = a[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tint max=0;\n\tint mi = 0;\n\tfor(i=n;i>0;i--)\n\t{\n\t\tif(max < c[sx[i]][sy[i]])\n\t\t{\n\t\t\tmax = c[sx[i]][sy[i]];\n\t\t\tmi = e[sx[i]][sy[i]];\n\t\t}\n\t\telse if(max == c[sx[i]][sy[i]])\n\t\t{\n\t\t\tif(mi < e[sx[i]][sy[i]])\n\t\t\t\tmi = e[sx[i]][sy[i]];\n\t\t}\n\t}\n\tif(max==0)mi=0;\n\tprintf(\"%d %d\\n\",max,mi);\n}\nint main()\n{\n\tinil();\n\twhile(1)\n\t{\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n+m==0)break;\n\t\tprocess();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstdio>\n \nusing namespace std;\n \n#define out(x,l) (x<0||l<=x)\n \nconst int N = 1000000+10;\n \nbool isprime[N];\npair<int, int> loc[N];\nint cave[1010][1010];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, -1, 0, 1};\npair<int, int> dp[1010][1010];\n \nint main(){\n    for (int i = 0; i < N; i++) { isprime[i] = 1; } \n    isprime[0] = isprime[1] = 0;\n    for (int i = 2; i*i <= N; i++) {\n        if (!isprime[i]) continue;\n        for (int j = 2*i; j <= N; j += i) {\n            isprime[j] = 0;\n        }\n    }\n\n\tfor (int i = 0; i < 1010; i++)\n\t\tfor (int j = 0; j < 1010; j++)\n\t\t\tcave[i][j] = 0;\n \n    int x = 1010/2, y = 1010/2+5;\n    int cnt = 1;\n    int dir = 0;\n    int edge = 1;\n    while (1) {\n        if (out(x,1010)||out(y,1010)) break;\n        dir %= 4;\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < edge; j++) {\n                cave[y][x] = cnt;\n                loc[cnt].first = y;\n                loc[cnt].second = x;\n                x += dx[dir];\n                y += dy[dir];\n                cnt++;\n            }\n            dir++;\n        }\n        edge++;\n    }\n \n//  for (int i = 1; i < 100; i++) {\n//      cout << i << \" \" << loc[i].first << \" \" << loc[i].second << endl;\n//  }\n \n    int n, m;\n    while (cin >> m >> n, m&&n) {\n        for (int i = 0; i < 1010; i++)\n            for (int j = 0; j < 1010; j++) {\n                dp[i][j].first = -1;\n                dp[i][j].second = 0;\n            }\n        dp[loc[n].first][loc[n].second].first = isprime[n];\n        if (isprime[n]) dp[loc[n].first][loc[n].second].second = n;\n \n        for (int i = 0; i < 1010; i++) {\n            for (int j = 0; j < 1010; j++) {\n                if (cave[i][j] > m) continue;\n                pair<int, int> next; // first:the number of caves passed    second:last cave\n                next.first = -1;\n                next.second = 0;\n                bool update = 0;\n                if (!out(i-1,1010)&&!out(j-1,1010)&&dp[i-1][j-1].first!=-1) {\n                    if (dp[i-1][j-1].first > next.first) {\n                        next = dp[i-1][j-1];\n                        update = 1;\n                    } else if (dp[i-1][j-1].first == next.first && dp[i-1][j-1].second > next.second) {\n                        next = dp[i-1][j-1];\n                        update = 1;\n                    }\n                }\n                if (!out(i-1,1010)&&!out(j+1,1010)&&dp[i-1][j+1].first!=-1) {\n                    if (dp[i-1][j+1].first > next.first) {\n                        next = dp[i-1][j+1];\n                        update = 1;\n                    } else if (dp[i-1][j+1].first == next.first && dp[i-1][j+1].second > next.second) {\n                        next = dp[i-1][j+1];\n                        update = 1;\n                    }\n                }\n                if (!out(i-1,1010)&&!out(j,1010)&&dp[i-1][j].first!=-1) {\n                    if (dp[i-1][j].first > next.first) {\n                        next = dp[i-1][j];\n                        update = 1;\n                    } else if (dp[i-1][j].first == next.first && dp[i-1][j].second > next.second) {\n                        next = dp[i-1][j];\n                        update = 1;\n                    }\n                }\n                if (!update) continue;\n                if (isprime[cave[i][j]]) {\n                    next.first++;\n                    next.second = cave[i][j];\n                }\n                dp[i][j] = next;\n            }\n        }\n\n        pair<int, int> res;\n        for (int i = 0; i < 1010; i++)\n            for (int j = 0; j < 1010; j++)\n                if (res.first < dp[i][j].first) {\n                    res = dp[i][j];\n                } else if (res.first == dp[i][j].first&&res.second < dp[i][j].second) {\n                    res = dp[i][j];\n                }\n        cout << res.first << \" \" << res.second << endl;\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 1000010\nint prime[MAX_N];//i番目の素数\nbool is_prime[MAX_N+1];\n\n//n以下の素数の数を返す\nint sieve(int n){\n  int p=0;\n  for(int i=0;i<=n;i++)is_prime[i]=true;\n  is_prime[0]=is_prime[1]=false;\n  for(int i=2;i<=n;i++){\n    if(is_prime[i]){\n      prime[p++]=i;\n      for(int j=2*i;j<=n;j+=i)is_prime[j]=false;\n    }\n  }\n  return p;\n}\n\nint ma[1501][1501];\nint h[1000001][2];\nint dp[1501][1501];\nint main(){\n\tsieve(1000010);\n\tint x=750,y=750,k=0;\n\tint dy[4]={1,0,-1,0};\n\tint dx[4]={0,-1,0,1};\n\tint N=1;\n\tfor(int i=1;N<=1000000;i++){\n\t\tfor(int j=0;j<2;j++,k++){\n\t\t\tfor(int l=0;l<i;l++){\n\t\t\t\tma[x][y]=N;\n\t\t\t\th[N][0]=x;\n\t\t\t\th[N++][1]=y;\n\t\t\t\tx+=dx[k%4];\n\t\t\t\ty+=dy[k%4];\n\t\t\t\tif(N==1000001)break;\n\t\t\t}\n\t\t\tif(N==1000001)break;\n\t\t}\n\t\tif(N==1000001)break;\n\t}\n\t//\tcout<<h[1000000][0]<<\" \"<<h[1000000][1]<<endl;\n\tint m,n;\n\twhile(cin>>m>>n,n){\n\t\tmemset(dp,0,sizeof(dp));\n\t\tint x=h[n][0];\n\t\tint y=h[n][1];\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\tint ans=0,man=0;\n\t\tfor(int i=1;;i+=2){\n\t\t\tint f=1;\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tif(x<=0||x>=1500||y+j<=0||y+j>=1500)continue;\n\t\t\t\tif(ma[x][y+j]>=m)continue;\n\t\t\t\tf=0;\n\t\t\t\tint t=ma[x][y+j];\n\t\t\t\t//\tcout<<t<<\" \";\n\t\t\t\tint ty=y+j;\n\t\t\t\tif(is_prime[t]){\n\t\t\t\t\tdp[x][ty]++;\n\t\t\t\t\tif(dp[x][ty]==ans&&t>man)man=t;\n\t\t\t\t\tif(dp[x][ty]>ans){\n\t\t\t\t\t\tans=dp[x][ty];\n\t\t\t\t\t\tman=t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[x+1][ty]=max(dp[x+1][ty],dp[x][ty]);\n\t\t\t\tdp[x+1][ty+1]=max(dp[x+1][ty+1],dp[x][ty]);\n\t\t\t\tdp[x+1][ty-1]=max(dp[x+1][ty-1],dp[x][ty]);\n\t\t\t}\n\t\t\t//\tcout<<endl;\n\t\t\tif(f)break;\n\t\t\tx++;\n\t\t\ty--;\n\t\t}\n\t\tif(ans==0)man=0;\n\t\tcout<<ans<<\" \"<<man<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <fstream>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppi;\n\n\nconst int dy[]={0,-1,0,1};\nconst int dx[]={1,0,-1,0};\n\n\nbool isPrime[1000100];\nint prime[1000100];\n\nint p;\nvoid erats(){\n  for(int i=0;i<1000100;i++)\n    isPrime[i]=true;\n  p=0;\n  isPrime[0]=isPrime[1]=false;\n  for(int i=2;i<1000100;i++){\n    if(isPrime[i]){\n      prime[p++]=i;\n      for(int j=2*i;j<1000100;j+=i)\n        isPrime[j]=false;\n    }\n  }\n}\n\n\nint N,M;\nmap<pair<short,short>,int> m;\npair<short,short> idToPii[1000200];\npii dp[1000100];\n\npii dfs(int pos){\n  if(dp[pos].first>=0)return dp[pos];\n  pii res=pii(isPrime[pos],isPrime[pos]?pos:0);\n  for(int i=-1;i<=1;i++){\n    pii nxt=idToPii[pos];\n    nxt.first++;\n    nxt.second+=i;\n    if(m.count(nxt)&&m[nxt]<=M){\n      pii p=dfs(m[nxt]);\n      if(isPrime[pos])p.first++;\n      if(res.first<p.first)res=p;\n      else if(res.first==p.first){\n        if(res.second<p.second)\n          res=p;\n      }\n    }\n  }\n  return dp[pos]=res;\n}\n\nint main(){\n  erats();\n  \n  int sum=1;\n  int pos=0;\n  pii now=pii(0,0);\n  m[now]=1;\n  idToPii[sum]=now;\n  sum++;\n  for(int i=1;;i++){\n    for(int j=0;j<2;j++){\n      // posの方向へiだけ進む\n      for(int k=0;k<i;k++){\n        now.first+=dy[pos];\n        now.second+=dx[pos];\n        m[now]=sum;\n        idToPii[sum]=now;\n        sum++;\n      }\n      pos=(pos+1)%4;\n    }\n    if(sum>=1000100)break;\n  }\n  while(cin>>M>>N&&(N|M)){\n    for(int i=0;i<=M;i++)\n      dp[i].first=dp[i].second=-1;\n    pii p=dfs(N);\n    cout<<p.first<<\" \"<<p.second<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int int64_t\n#define REP(i, s, n) for (signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define all(c) begin(c), end(c)\n\n#define maxup(ans, x) (ans = (ans < x ? x : ans))\n#define minup(ans, x) (ans = (ans > x ? x : ans))\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\nsigned main() {\n\tVV data(1000, V(1000));\n\tvector<P> nums(1000001);\n\tP center = P(500, 499);\n\tP now = center;\n\tdata[center.first][center.second] = 1;\n\tnums[1] = now;\n\n\tint length = 1;\n\tint x = 1;\n\twhile (x < 1000000) {\n\t\tif (length & 1) {\n\t\t\trep(j, length) {\n\t\t\t\tdata[now.first][++now.second] = ++x;\n\t\t\t\tnums[x] = now;\n\t\t\t}\n\t\t\trep(j, length) {\n\t\t\t\tdata[--now.first][now.second] = ++x;\n\t\t\t\tnums[x] = now;\n\t\t\t}\n\t\t} else {\n\t\t\trep(j, length) {\n\t\t\t\tdata[now.first][--now.second] = ++x;\n\t\t\t\tnums[x] = now;\n\t\t\t\tif (x == 1000000) {\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, length) {\n\t\t\t\tdata[++now.first][now.second] = ++x;\n\t\t\t\tnums[x] = now;\n\t\t\t}\n\t\t}\n\t\tlength++;\n\t}\nout:\n\tvector<bool> isprime(1000001, true);\n\tisprime[0] = isprime[1] = false;\n\tfor (int i = 2; i*i <= 1000000; i++) if (isprime[i]) {\n\t\tfor (int j = 2; i * j <= 1000000; j++) {\n\t\t\tisprime[i * j] = false;\n\t\t}\n\t}\n\n\tint m, n;\n\twhile (cin >> m >> n && m) {\n\t\tmap<P, P> memo;\n\t\tfunction<P(int, int)> dp = [&](int r, int c) {\n\t\t\tif (r < 0 || r >= data.size() || c < 0 || c >= data[0].size()\n\t\t\t\t|| data[r][c] > m) return P(0, 0);\n\t\t\tif (memo.count(P(r, c))) return memo[P(r, c)];\n\t\t\tP ret;\n\t\t\tmaxup(ret, dp(r + 1, c - 1));\n\t\t\tmaxup(ret, dp(r + 1, c));\n\t\t\tmaxup(ret, dp(r + 1, c + 1));\n\t\t\tif (isprime[data[r][c]]) {\n\t\t\t\tret.first++;\n\t\t\t\tif (ret.second == 0) ret.second = data[r][c];\n\t\t\t}\n\t\t\treturn memo[P(r, c)] = ret;\n\t\t};\n\t\tP ans = dp(nums[n].first, nums[n].second);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[(SIZE + 1)*(SIZE + 1) + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= (SIZE + 1)*(SIZE + 1);i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= (SIZE + 1)*(SIZE + 1);j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(y=SIZE-1;y>=0;y--){\n\t\t\tfor(x=SIZE-1;x>=0;x--){\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&\n\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x - 1]||(dp[y][x] == dp[y + 1][x - 1] && pr[y][x] < pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && \n\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x] || (dp[y][x] == dp[y + 1][x] && pr[y][x] < pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && \n\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x + 1] || (dp[y][x] == dp[y + 1][x + 1] && pr[y][x] < pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (y = 0;y < SIZE;y++) {\n\t\t\tfor (x = 0;x < SIZE;x++) {\n\t\t\t\tif (table[y][x] == n) {\n\t\t\t\t\tcout << dp[y][x] << \" \" << pr[y][x] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include<iomanip>\n\nusing namespace std;\n\n#define ALLNUM 1005\n#define fin cin\n\nint all, start;\nint map[ALLNUM][ALLNUM] = {};\n\nbool isPrime(int n){\n    if(n <= 1)return false;\n    if(n == 2)return true;\n    if(n % 2 == 0)return false;\n    \n    for(int i = 3; i * i <= n; i+=2){\n        if(n % i == 0)return false;\n    }\n    return true;\n}\n\nclass Pair{\n    \npublic:\n    int num;\n    int count;\n    \n    Pair(){\n        this->num = 0;\n        this->count = 0;\n    };\n    Pair(int _num){\n        if(isPrime(_num)){\n            this->num = _num;\n            this->count = 1;\n        }\n        else {this->num = this->count = 0;}\n    }\n    \n    Pair operator + (const Pair &p){\n        this->count += p.count;\n        if(p.num != 0)this->num = p.num;\n        return *this;\n    }\n    \n    void print(){\n        cout << this->count << \" \" << this->num;\n    }\n};\n\nbool come[ALLNUM][ALLNUM];\nPair pMap[ALLNUM][ALLNUM];\n\nvoid init(){\n    \n    for(int i = 0; i < ALLNUM; i++){\n        for(int j = 0; j < ALLNUM; j++){\n            pMap[i][j] = Pair(0);\n            come[i][j] = false;\n        }\n    }\n}\n\nPair calc(int y, int x){\n    \n    if(map[y][x] > all)return Pair(-10);\n    if(come[y][x])return pMap[y][x];\n    \n    Pair p(map[y][x]);\n    Pair ans;\n    \n    Pair tmp1 = calc(y + 1, x);\n    Pair tmp2 = calc(y + 1, x + 1);\n    \n    if (tmp1.count == tmp1.count) {\n        if (tmp1.num < tmp2.num)tmp1.count--;\n    }\n    \n    if (tmp1.count < tmp2.count)ans =  tmp2;\n    else ans = tmp1;\n    \n    tmp1 = calc(y + 1, x - 1);\n    \n    if(tmp1.count == ans.count)if(tmp1.num < ans.num)tmp1.count--;\n    \n    if (tmp1.count < ans.count);\n    else ans = tmp1;\n    \n    /*\n     if (tmp1.count == tmp2.count) {\n     if(tmp1.num == tmp2.num)ans = tmp1;\n     else if(tmp1.num < tmp2.num)ans = tmp2;\n     else ans = tmp1;\n     }\n     else if(tmp1.count < tmp2.count)ans = tmp2;\n     else ans = tmp1;\n     \n     tmp2 = calc(y + 1, x - 1);\n     if (ans.count == tmp2.count) {\n     if(ans.num == tmp2.num);\n     else if(ans.num < tmp2.num)ans = tmp2;\n     else ;\n     }\n     else if(ans.count < tmp2.count)ans = tmp2;\n     else ;\n     */\n    \n    come[y][x] = true;\n    return pMap[y][x] = p + ans;\n}\n\nint main() {\n//    ifstream fin(\"in.txt\");\n    \n    int x, y;\n    x = y = ALLNUM / 2;\n    \n    map[y][x] = 1;\n    \n    int gumi = 1;\n    int num = 1;\n    \n    while(num < (ALLNUM - 1) * (ALLNUM - 1)){\n        for(int i = 0; i < gumi; i++){\n            map[y][++x] = ++num;\n        }\n        if(num >= ALLNUM * ALLNUM)break;\n        \n        for(int i = 0; i < gumi; i++){\n            map[--y][x] = ++num;\n        }\n        if(num >= ALLNUM * ALLNUM)break;\n        \n        gumi++;\n        for(int i = 0; i < gumi; i++){\n            map[y][--x] = ++num;\n        }\n        if(num >= ALLNUM * ALLNUM)break;\n        \n        for(int i = 0; i < gumi; i++){\n            map[++y][x] = ++num;\n        }\n        if(num >= ALLNUM * ALLNUM)break;\n        gumi++;\n    }\n    \n    while(true){\n        fin >> all >> start;\n        if((all | start) == 0)break;\n        \n        init();\n        x = y = 0;\n        \n        for(int i = 0; i < ALLNUM; i++){\n            for(int j = 0; j < ALLNUM; j++){\n                if(map[j][i] == start){\n                    x = i;\n                    y = j;\n                    i = j = ALLNUM;//?????????break;\n                    break;\n                }\n            }\n        }\n        calc(y, x).print();\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "13 947\n13 947\n13 947\n13 947\n13 947\n1 1069\n4 1091\n4 839\n1 941\n1 941\n16 829\n1 929\n24 947\n0 0\n17 947\n25 947\n23 947\n22 829\n26 947\n23 947\n1 823\n1 953\n1 1063\n1 953\n1 839\n0 0\n0 0\n0 0\n0 0\n0 0\n19 947\n20 947\n20 947\n19 947\n20 947\n13 947\n17 947\n22 947\n0 0\n14 829\n19 947\n11 947\n11 947\n5 941\n20 947\n18 829\n9 821\n574 993541"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n\nusing namespace std;\nint holes[1005][1005],table[1005][1005];\nbool prime[1000008];\n\n\nint main(){\nint m,n,g,x,y,sx,sy,i,j;\nint dx[]={1,0,-1,0},dy[]={0,-1,0,1},d;\n\nmemset(prime,1,sizeof(prime));\nprime[0]=prime[1]=0;\nfor(i=2;i<=1000003;i++){\nif(prime[i])for(j=i*2;j<=1000003;j+=i){\nprime[j]=0;\n}\n}\n\nwhile(1){\nscanf(\"%d %d\",&m,&n);\nif(m==0&&n==0)break;\n\nmemset(holes,0,sizeof(holes));\nmemset(table,-1,sizeof(table));\ng=(int)ceil(sqrt(m));\ny=x=g/2+1;\t//縁を0でうめる\nd=3;\nholes[y][x]=1;\nfor(i=2;i<=m;i++){\nif(holes[y+dy[(d+1)%4]][x+dx[(d+1)%4]]==0){\nd=(d+1)%4;\n}\nx+=dx[d];\ny+=dy[d];\n\nholes[y][x]=i;\nif(i==n){\nsx=x;\nsy=y;\n}\n}\n\n/* for(i=0;i<=g+1;i++){\nfor(j=0;j<=g+1;j++)\nprintf(\"%3d \",holes[i][j]);\nprintf(\"\\n\");\n}\n*/\nint maxNum=0,maxCnt=0;\ntable[sy][sx]=0;\nfor(y=sy;y<=g;y++){\nfor(x=1;x<=g;x++){\nif(table[y][x]==-1)continue;\nif(prime[holes[y][x]])table[y][x]++;\nif(maxCnt<table[y][x] && holes[y][x]>0){\nmaxCnt=table[y][x];\nmaxNum=holes[y][x];\n}else if(maxCnt==table[y][x]){\nif(maxNum<holes[y][x])\nif(prime[holes[y][x]])\nmaxNum=holes[y][x];\n}\n\nfor(i=-1;i<=1;i++){\nif(table[y+1][x+i]<table[y][x]){\ntable[y+1][x+i]=table[y][x];\n}\n}\n}\n}\n\n/*cout<<endl;\nfor(i=0;i<=g+1;i++){\nfor(j=0;j<=g+1;j++)\nprintf(\"%3d \",table[i][j],holes[i][j]);\nprintf(\"\\n\");\n}*/\n\nparintf(\"%d %d\\n\",maxCnt,maxNum);\n\n\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nusing P = pair<int, int>;\n\nP solve(int x, int y, vector<P>& dp, vector<vector<int>>& num, vector<P>& pos, vector<bool>& is_prime, int m) {\n    int n = num[x][y];\n    P& r = dp[n];\n    if(r.first != -1) {\n        return r;\n    }\n    r = make_pair(0, 0);\n    for(int dx=-1; dx<=1; ++dx) {\n        int nx = x+dx, ny = y+1;\n        if(0 <= nx && nx < 1100 && ny < 1100 && num[nx][ny] != -1 && num[nx][ny] <= m) {\n            P p = solve(nx, ny, dp, num, pos, is_prime, m);\n            if(r.first < p.first) {\n                r = p;\n            } else if(r.first == p.first && r.second < p.second) {\n                r = p;\n            }\n        }\n    }\n    if(is_prime[n]) {\n        r.first += 1;\n        if(r.second == 0) {\n            r.second = n;\n        }\n    }\n    return r;\n}\n\nint main() {\n    int m, n;\n    vector<vector<int>> number(1100, vector<int>(1100, -1));\n    vector<P> pos(1000001);\n    int dx[4] = {1, 0, -1, 0},\n        dy[4] = {0, -1, 0, 1};\n    int dir = 0;\n    int x = 500, y = 500;\n    for(int i=1; i<=1000000; ++i) {\n        pos[i] = make_pair(x, y);\n        number[x][y] = i;\n        x += dx[dir], y += dy[dir];\n        if(number[x+dx[(dir+1)%4]][y+dy[(dir+1)%4]] == -1) {\n            dir = (dir+1)%4;\n        }\n    }\n    vector<bool> is_prime(1000001, true);\n    is_prime[0] = is_prime[1] = false;\n    for(int i=2; i<is_prime.size(); ++i) {\n        if(is_prime[i]) {\n            for(int j=i+i; j<is_prime.size(); j+=i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    while(cin >> m >> n, m) {\n        vector<P> dp(1000001, P{-1, -1});\n        P res = solve(pos[n].first, pos[n].second, dp, number, pos, is_prime, m);\n        cout << res.first << \" \" << res.second << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define N 1000\n\nusing namespace std;\n\nint num[N][N], dp[N][N];\nbool prime[N][N], is_reach[N][N];\n\nbool is_prime(int& n, vector<int>* p){\n  if(n==1) return false;\n  for(vector<int>::iterator it=p->begin();\n      it!=p->end() && (*it)*(*it)<=n; ++it){\n    if(!(n%(*it))) return false;\n  }\n  p->push_back(n);\n  return true;\n}\nvoid init(){\n  for(int i=0; i<N; ++i){\n    for(int j=0; j<N; ++j){\n      num[i][j]=0, prime[i][j]=false;\n    }\n  }\n  vector<int> p;\n  for(int i=N/2, j=N/2-1, k=1, is=1; k<=N*N; ++k){\n    num[i][j] = k;\n    prime[i][j] = is_prime(k, &p);\n    if(is==1){\n      ++j;\n      if(!num[i-1][j]) ++is;\n    }else if(is==2){\n      --i;\n      if(!num[i][j-1]) ++is;\n    } else if(is==3){\n      --j;\n      if(!num[i+1][j]) ++is;\n    }else if(is==4){\n      ++i;\n      if(!num[i][j+1]) is=1;\n    }\n  }\n}\n\nbool is_over(int& i, int& j, int& m){\n  return (i==-1 || i==N || j==-1 || j==N || num[i][j]>m);\n}\nvoid set(int i, int j, int& m){\n  if(!is_over(i,j,m)) is_reach[i][j]=true;\n}\nint get(int i, int j, int& m){\n  return (is_over(i,j,m) ? 0 : dp[i][j]);\n}\nbool is_max(int& i, int& j, int& max_, int& num_){\n  if(!prime[i][j]) return false;\n  if(dp[i][j] > max_) return true;\n  if(dp[i][j]==max_ && num[i][j]>num_) return true;\n  return false;\n}\n\nvoid solve(int& m, int& n){\n  for(int i=0; i<N; ++i){\n    for(int j=0; j<N; ++j){\n      dp[i][j]=0, is_reach[i][j]=false;\n    }\n  }\n  int max_=0, num_=0;\n  bool is=false;\n  for(int i=0; i<N; ++i){\n    for(int j=0; j<N; ++j){\n      if(num[i][j]==n){\n\tis=true;\n\tdp[i][j]=prime[i][j];\n\tset(i,j,m), set(i+1,j-1,m), set(i+1,j,m), set(i+1,j+1,m);\n\tif(prime[i][j]) max_=1, num_=num[i][j];\n\tbreak;\n      }\n      if(num[i][j]>m || !is || !is_reach[i][j]) continue;\n      dp[i][j] = prime[i][j] +\n\tmax(get(i-1,j-1,m), max(get(i-1,j,m), get(i-1,j+1,m)));\n      set(i+1,j-1,m), set(i+1,j,m), set(i+1,j+1,m);\n      if(is_max(i,j,max_,num_)) max_=dp[i][j], num_=num[i][j];\n    }\n  }\n  cout << max_ << \" \" << num_ << endl;\n}\n\nint main(){\n  init();\n  int m, n;\n  while(1){\n    cin >> m >> n;\n    if(!m && !n) break;\n    solve(m, n);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t\n\t\tfor (int h = 0;h < SIZE;h++) {\n\t\t\tfor (int w = 0;w < SIZE;w++) {\n\t\t\t\tcout << dp[h][w] << \" \" << pr[h][w] << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\nusing namespace std;\n#define N 1010\n#define N2 N*N\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nbool prime[N2+1];\nint cave[N][N]={};\npair<int,int> dp[N][N];\nint m,n;\n\npair<int,int> rec(int x,int y){\n    if(dp[x][y].first)return dp[x][y];\n    if(y<0 || x<0 || x==N) return pair<int,int>(0,0);\n    if(cave[x][y]>m) return pair<int,int>(0,0);\n\n    //printf(\"now %d call %d %d\\n\", cave[x][y],x,y);\n\n    pair<int,int> child[3];\n    child[0]=rec(x-1,y-1);\n    child[1]=rec(x,y-1);\n    child[2]=rec(x+1,y-1);\n    sort(child,child+3);\n    if(child[2].first==0 && prime[cave[x][y]])\n    {\n        pair<int,int> tmp(1,cave[x][y]);\n        //printf( \"%d %d ret %d,%d\\n\",x,y,tmp.first,tmp.second);\n        return dp[x][y]=pair<int,int>(1,cave[x][y]);\n    }\n    if(prime[cave[x][y]])child[2].first++;\n\n    //printf( \"%d %d ret %d,%d\\n\",x,y,child[2].first,child[2].second);\n    return dp[x][y]=child[2];\n}\n\nint main(void){\n    cout<<\"test\"<<endl;\n    fill(prime,prime+N2+1,true);\n    prime[0]=prime[1]=false;\n    for(int i=2;i<=N2;i++){\n        if(!prime[i])continue;\n        for(int k=2;i*k<=N2;k++)prime[i*k]=false;\n    }\n\n    int x=0,y=N-1,d=0;\n    pair<int,int> locate[N2+1];\n    for(int i=N2;i>0;i--){\n        cave[x][y]=i;\n        locate[i] = pair<int,int>(x,y);\n        int nextX=x+dx[d],nextY=y+dy[d];\n        if(nextX==-1 || nextX==N || nextY==-1 || nextY==N || cave[nextX][nextY])d=(d+1)%4;\n        x+=dx[d];\n        y+=dy[d];\n    }\n\n\n    while(cin>>m>>n, m|n){\n        rep(i,N)rep(j,N)dp[i][j].first=dp[i][j].second=0;\n        pair<int,int> tmp=rec(locate[n].first,locate[n].second);\n        printf(\"start %d, %d\\n\", locate[n].first,locate[n].second);\n        cout<<tmp.first<<\" \"<<tmp.second<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <fstream>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppi;\n\n\nconst int dy[]={0,-1,0,1};\nconst int dx[]={1,0,-1,0};\n\n\nbool isPrime[1000100];\nint prime[1000100];\n\nint p;\nvoid erats(){\n  for(int i=0;i<1000100;i++)\n    isPrime[i]=true;\n  p=0;\n  isPrime[0]=isPrime[1]=false;\n  for(int i=2;i<1000100;i++){\n    if(isPrime[i]){\n      prime[p++]=i;\n      for(int j=2*i;j<1000100;j+=i)\n        isPrime[j]=false;\n    }\n  }\n}\n\n\nint N,M;\nmap<pair<short,short>,int> m;\npair<short,short> idToPii[1000200];\n//map<int,pair<short,short> > idToPii;\npii dp[1000100];\n\npii dfs(int pos){\n  if(dp[pos].first>=0)return dp[pos];\n  pii res=pii(isPrime[pos],isPrime[pos]?pos:0);\n  for(int i=-1;i<=1;i++){\n    pii nxt=idToPii[pos];\n    nxt.first++;\n    nxt.second+=i;\n    if(m.count(nxt)&&m[nxt]<=M){\n      pii p=dfs(m[nxt]);\n      if(isPrime[pos])p.first++;\n      \n      if(res.first<p.first)res=p;\n      else if(res.first==p.first){\n        if(res.second<p.second)\n          res=p;\n      }\n    }\n  }\n  return dp[pos]=res;\n}\n\nint main(){\n  erats();\n  \n  int sum=1;\n  int pos=0;\n  pii now=pii(0,0);\n  m[now]=1;\n  idToPii[sum]=now;\n  sum++;\n  for(int i=1;;i++){\n    for(int j=0;j<2;j++){\n      // posの方向へiだけ進む\n      for(int k=0;k<i;k++){\n        now.first+=dy[pos];\n        now.second+=dx[pos];\n        m[now]=sum;\n        idToPii[sum]=now;\n        sum++;\n      }\n      pos=(pos+1)%4;\n    }\n    if(sum>=1000100)break;\n  }\n  while(cin>>M>>N&&(N|M)){\n    for(int i=0;i<=M;i++)\n      dp[i].first=dp[i].second=-1;\n    pii p=dfs(N);\n    cout<<p.first<<\" \"<<p.second<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <complex>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<int(b); i++)\n#define rep(i,n) loop(i,0,n)\n#define all(c) (c).begin(), (c).end()\ntypedef complex<int> P;\n\nconst int MAX_M = 1.5e6+10;\nconst int SIZE = 2000;\nint ps[MAX_M/2];\nbool isp[MAX_M];\nint grid[SIZE][SIZE]={};\nP itop[MAX_M];\npair<int,int> dp[SIZE][SIZE];\n\nint cnt_p = 0;\n\nvoid make_es(){\n    fill(isp,isp+MAX_M,true);\n    isp[0]=isp[1]=false;\n    rep(i,MAX_M){\n        if(!isp[i]) continue;\n        ps[cnt_p++] = i;\n        for(int j=i<<1; j<MAX_M; j+=i){\n            isp[j] = false;\n        }\n    }\n}\n\nP const ii(0,1);\n\nint n,m;\n\npair<int,int> rec(int y, int x){\n    // cout << x << \" \" << y << endl;\n    if(dp[y][x].first!=-1) return dp[y][x];\n\n    pair<int,int> res(0,0);\n    if(isp[grid[y][x]]){\n        res.first = 1;\n        res.second = grid[y][x];\n    }\n\n    pair<int,int> best(0,0);\n    loop(i,-1,2){\n        if(grid[y+1][x+i]<=m){\n            auto t = rec(y+1,x+i);\n            best = max(t,best);\n        }\n    }\n\n    if(best.first != 0){\n        res.first += best.first;\n        res.second = best.second;\n    }\n\n    dp[y][x] = res;\n    return res;\n\n    // if(grid[y][x] > m) return 0;\n    // int res = isp[grid[y][x]];\n    // int k = 0;\n    // loop(i,-1,2){\n    //     k = max(k, rec(y+1,x+i));\n    // }\n    // res += k;\n    // dp[y][x] = res;\n    // return res;\n}\n\npair<int,int> solve(int k){\n    P p = itop[k];\n    return rec(p.real(), p.imag());\n}\n\nint main(){\n    make_es();\n\n    P p(SIZE/2,SIZE/2);\n    P dir(0,1);\n    for(int i=1; i<MAX_M; i++){\n        grid[p.real()][p.imag()] = i;\n        itop[i]=p;\n        p+=dir;\n        P q = p+dir*ii;\n        if(grid[q.real()][q.imag()] == 0){\n            dir*=ii;\n        }\n    }\n\n    while(cin>>m>>n, n+m){\n        auto t = make_pair(-1,-1);\n        rep(i,SIZE)rep(j,SIZE) dp[i][j] = t;\n        auto ans = solve(n);\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <set>\n#include <map>\n#include <stack>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n \nusing namespace std;\n \n#define ll long long\n#define pi pair<int,int>\n#define pll pair<ll,ll>\n#define pii pair<int,pi>\n#define X first\n#define Y second\n#define pb push_back\n#define ab(x) ((x)<0?(-(x)):(x))\n#define xx(x) ((x)*(x))\n#define mp make_pair\n#define vi vector<int>\n#define vll vector<ll>\n#define vs vector<string>\n#define vpi vector<pi>\n#define vpll vector<pll>\n#define ALL(x) (x).begin(),(x).end()\n#define Max (1<<30)\n#define LLMax (1ll<<60)\ntemplate<class T>string ToString(T t){stringstream s;s<<t;return s.str();}\ntemplate<class T>void ToOther(T&t,string a){stringstream s(a);s>>t;}\n \n\n \nint a[3333][3333];\n\nint xx[]={1,0,-1,0};\nint yy[]={0,-1,0,1};\n\nint wh1[1000005];\nint wh2[1000005];\nint d[3333][3333];\nint ck[3333][3333];\n\nbool pr[1000005];\n\nint main(){\n//\tfreopen(\"output.txt\",\"w\",stdout);\n\n\tpr[1]=1;\n\tfor(int i=2;i<=1000000;i++)if(pr[i]==0){\n\t\tpr[i]=0;\n\t\tfor(int j=i+i;j<=1000000;j+=i)pr[j]=1;\n\t}\n\n\tint x=1500;\n\tint y=1500;\n\tint di=0,now=1;\n\n\ta[y][x]=now;\n\twh1[now]=y;\n\twh2[now]=x;\n\n\tfor(int L=1;;L++){\n\t\t\n\t\tfor(int i=0;i<2;i++){\n\t\t\tfor(int c=0;c<L;c++){\n\t\t\t\tnow++;\n\t\t\t\tif(now>1000000)goto END;\n\t\t\t\tx+=xx[di];\n\t\t\t\ty+=yy[di];\n\n\t\t\t\ta[y][x]=now;\n\t\t\t\twh1[now]=y;\n\t\t\t\twh2[now]=x;\n\n\t\t\t}\n\t\t\tdi=(di+1)%4;\n\t\t}\n\t} \n\tEND:;\n\n\tint n,st;\n\tint CC=0;\n\twhile(cin>>n>>st,n){\n\t\tCC++;\n\t\tint mx=Max;\n\t\tint MX=-Max;\n\t\tint my=Max;\n\t\tint MY=-Max;\n\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tmx=min(mx,wh2[i]);\n\t\t\tMX=max(MX,wh2[i]);\n\n\t\t\tmy=min(my,wh1[i]);\n\t\t\tMY=max(MY,wh1[i]);\n\t\t}\n\n\t\tint x=wh2[st];\n\t\tint y=wh1[st];\n\n\t\tck[y][x]=CC;\n\t\td[y][x]=!pr[st];\n\n\t\tint r1=0;\n\t\tint r2=0;\n\n\t\tif(!pr[st])r1=1,r2=st;\n\n\t\tfor(int i=y+1;i<=MY;i++){\n\t\t\tfor(int j=mx;j<=MX;j++)if(a[i][j]>=1 && a[i][j]<=n){\n\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\tint nx=j+k;\n\n\t\t\t\t\tif(ck[i-1][nx]!=CC)continue;\n\t\t\t\t\tif(a[i-1][nx]<=0 || a[i-1][nx]>n)continue;\n\n\t\t\t\t\tif(ck[i][j]==CC){\n\t\t\t\t\t\td[i][j]=max(d[i][j],d[i-1][nx]+ !pr[ a[i][j] ]);\n\t\t\t\t\t}else d[i][j]=d[i-1][nx]+ !pr[ a[i][j] ];\n\t\t\t\t\tck[i][j]=CC;\n\n\t\t\t\t\tif(!pr[ a[i][j] ]){\n\t\t\t\t\t\tif(r1<d[i][j]){\n\t\t\t\t\t\t\tr1=d[i][j];\n\t\t\t\t\t\t\tr2=a[i][j];\n\t\t\t\t\t\t}else if(r1==d[i][j])r2=max(r2,a[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout<<r1<<\" \"<<r2<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define f first\n#define s second\ntypedef pair<int,int> P;\nint a[2000][2000],ans[2000][2000],d=0,y=999,x=1001,n,m;\nbool b[1000001],used[2000][2000];\nint dx[]={-1,0,1,0},tx[]={-1,0,1};\nint dy[]={0,1,0,-1},ty[]={1,1,1};\nint main(){\n  b[0]=b[1]=1;\n  for(int i=2;i<1000001;i++)\n    for(int j=i+i;j<1000001;j+=i)b[j]=1;\n  a[1000][1000]=1;\n  a[1000][1001]=2;\n  a[999][1001]=3;\n  for(int i=4;i<1000001;i++){\n    int yy=y+dy[d],xx=x+dx[d];\n    int ya=yy+dy[(d+1)%4],xa=xx+dx[(d+1)%4];\n    if(!a[ya][xa])d=(d+1)%4;\n    a[yy][xx]=i;\n    y=yy,x=xx;\n  }\n  while(cin>>n>>m,n){\n    memset(ans,0,sizeof(ans));\n    memset(used,0,sizeof(used));\n    r(i,2000)r(j,2000)if(a[i][j]==m){\n      used[i][j]=1;y=i;\n      break;\n    }\n    for(int i=y;i<2000;i++)r(j,2000)if(a[i][j]&&used[i][j]){\n      if(!b[a[i][j]])ans[i][j]++;\n      r(k,3){\n        y=i+ty[k],x=j+tx[k];\n        if(!a[y][x]||a[y][x]>n)continue;\n        ans[y][x]=max(ans[y][x],ans[i][j]);\n        used[y][x]=1;\n      }\n    }\n    int a1=0,a2;\n    r(i,2000)r(j,2000)if(a[i][j]<=n)if(a1<=ans[i][j]&&a2<a[i][j]){\n      a1=ans[i][j],a2=a[i][j];\n    }\n    if(!a1)cout<<\"0 0\"<<endl;\n    else cout<<a1<<' '<<a2<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#define X first\n#define Y second\n#define MAX 1233\nusing namespace std;\n\nstruct state{\n\tstate():num(0), max(-1), mindex(0){}\n\tint num;\n\tint max;\n\tint mindex;\n};\n\nstate dp[MAX][MAX];\nbool sosuu[1000001];\nmap<int, pair<int, int> > pos;\nint dx[] = {0, -1, 0, 1};\nint dy[] = {-1, 0, 1, 0};\nint ddx[] = {-1, 0, 1};\n\nvoid era(){\n\tfill(sosuu, sosuu+1000001, true);\n\tfor(int i = 2; i <= 1000000; i++){\n\t\tif(sosuu[i]){\n\t\t\tfor(int j = 2*i; j <= 1000000; j+=i) sosuu[j] = false;\n\t\t}\n\t}\n}\n\nvoid fillNum(){\n\tint rect = 3, index = 0, count = 1;\n\tint x = MAX/2, y = MAX/2;\n\tpos[count] = pair<int, int>(x, y);\n\tdp[y][x].num = count++;\n\twhile(count <= MAX*MAX-1){\n\t\tpos[count] = pair<int, int>(++x, y);\n\t\tdp[y][x].num = count++;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tfor(int j = (i==0)?1:0; j < rect-1; j++){\n\t\t\t\tx += dx[i];\n\t\t\t\ty += dy[i];\n\t\t\t\tpos[count] = pair<int, int>(x, y);\n\t\t\t\tdp[y][x].num = count++;\n\t\t\t}\n\t\t}\n\t\trect+=2;\n\t}\n}\n\nvoid Init(int n){\n\tfor(int i = 0; i < MAX; i++){\n\t\tfor(int j = 0; j < MAX; j++){\n\t\t\tif(n>=dp[i][j].num){\n\t\t\t\tdp[i][j].max = -1;\n\t\t\t\tdp[i][j].mindex = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n  \nint dfs(int x, int y, int n){\n\tif(dp[y][x].max>=0) return dp[y][x].max;\n\tint add = 0;\n\tfor(int i = 0; i < 3; i++){\n\t\tif(dp[y+1][x+ddx[i]].num>n) continue;\n\t\tint tmp = dfs(x+ddx[i], y+1, n);\n\t\tif(add<tmp){\n\t\t\tadd = tmp;\n\t\t\tdp[y][x].mindex = dp[y+1][x+ddx[i]].mindex;\n\t\t}\n\t\telse if(add == tmp){ \n\t\t\tdp[y][x].mindex = dp[y][x].mindex<dp[y+1][x+ddx[i]].mindex?dp[y+1][x+ddx[i]].mindex:dp[y][x].mindex;\n\t\t}\n\t}\n\tdp[y][x].max = sosuu[dp[y][x].num]?add + 1:add;\n\tif(!dp[y][x].mindex&&sosuu[dp[y][x].num]) dp[y][x].mindex = dp[y][x].num;\n\treturn dp[y][x].max;\n}\n\nint main(){\n\tera();\n\tfillNum();\n\tint n, m;\n\twhile(cin >> n >> m && (n!=0||m!=0)){\n\t\tInit(n);\n\t\tint x = pos[m].X, y = pos[m].Y;\n\t\tdfs(x, y, n);\n\t\tif(dp[y][x].max==0) cout << 0 << \" \" << 0 << endl;\n\t\telse cout << dp[y][x].max << \" \" << dp[y][x].mindex << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define foreach(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint main()\n{\n\tconst int h=1010,w=1010;\n\tvvi grid(h,vi(w));\n\tfor(int n=1,m=1,i=505,j=505;n<=1000000;m+=2){\n\t\tfor(int k=0;k<m;k++)  grid[i][j]=n++,j++;\n\t\tfor(int k=0;k<m;k++)  grid[i][j]=n++,i--;\n\t\tfor(int k=0;k<=m;k++) grid[i][j]=n++,j--;\n\t\tfor(int k=0;k<=m;k++) grid[i][j]=n++,i++;\n\t}\n\t\n\tvi isp(1100000,1); isp[0]=isp[1]=0;\n\tfor(int i=2;i*i<isp.size();i++)\n\t\tif(isp[i])\n\t\t\tfor(int j=i*i;j<isp.size();j+=i)\n\t\t\t\tisp[j]=0;\n\t\n\tfor(int m,n;cin>>m>>n,m|n;){\n\t\tint i0=-1,j0=-1;\n\t\trep(i,h) rep(j,w) if(grid[i][j]==n)\n\t\t\ti0=i,j0=j;\n\t\t\n\t\tint btm=0;\n\t\trep(i,h) rep(j,w) if(grid[i][j]>0 && grid[i][j]<=m)\n\t\t\tbtm=max(btm,i);\n\t\t\n\t\tvvi dp(h,vi(w)),prev(h,vi(w,-1));\n\t\tprev[i0][j0]=0;\n\t\t\n\t\trepi(i,i0,h) rep(j,w){\n\t\t\tif(prev[i][j]==-1) continue;\n\t\t\tif(grid[i][j]<=m && isp[grid[i][j]])\n\t\t\t\tdp[i][j]++,prev[i][j]=grid[i][j];\n\t\t\trep(k,3){\n\t\t\t\tint nj=j+\"\\xff\\0\\x1\"[k];\n\t\t\t\tif(i<h-1 && 0<=nj && nj<w && (dp[i+1][nj]!=dp[i][j]?dp[i+1][nj]<dp[i][j]:prev[i+1][nj]<prev[i][j]))\n\t\t\t\t\tdp[i+1][nj]=dp[i][j],prev[i+1][nj]=prev[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res=*max_element(all(dp[h-1])),last=0;\n\t\trep(i,w) if(dp[h-1][i]==res) last=max(last,prev[h-1][i]);\n\t\tcout<<res<<' '<<last<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nbool isNotPrime[1000200] = {1,1};\nint prime(){\n\tfor(int i = 2;i*i < 1000200;i++){\n\t\tfor(int j = 2*i;j < 1000200;j+=i){\n\t\t\tisNotPrime[j] = 1;\n\t\t}\n\t}\n}\nint sc[1050][1050] = {};\nint dp[1050][1050][2];\n#define T_MAX  1000000\nint main(){\n\tprime();\n\tint c = 502,t = 1;\n\tint x = c,y = c;\n\tint w = -1,h = -1,_w = 1000000,_h = 1000000;\n\tfor(int i = 1;;i+=2){\n\t\t//cout<<t<<endl;\n\t\tfor(int j = 1;j <= i;j++){\n\t\t\tsc[y][x] = t++;\n\t\t\tw = max(x,w);\n\t\t\th = max(y,h);\n\t\t\t_w = min(x,_w);\n\t\t\t_h = min(y,_h);\n\t\t\tx++;\n\t\t\tif(t > T_MAX)goto next;\n\t\t}\n\t\tfor(int j = 1;j <= i;j++){\n\t\t\tsc[y][x] = t++;\n\t\t\tw = max(x,w);\n\t\t\th = max(y,h);\n\t\t\t_w = min(x,_w);\n\t\t\t_h = min(y,_h);\n\t\t\ty--;\n\t\t\t//if(x < 0 || y < 0)cout<<\"!\"<<endl;\n\t\t\tif(t > T_MAX)goto next;\n\t\t}\n\t\tfor(int j = 1;j <= i+1;j++){\n\t\t\tsc[y][x] = t++;\n\t\t\tw = max(x,w);\n\t\t\th = max(y,h);\n\t\t\t_w = min(x,_w);\n\t\t\t_h = min(y,_h);\n\t\t\tx--;\n\t\t\t//if(x < 0 || y < 0)cout<<\"!\"<<endl;\n\t\t\tif(t > T_MAX)goto next;\n\t\t}\n\t\tfor(int j = 1;j <= i+1;j++){\n\t\t\tsc[y][x] = t++;\n\t\t\tw = max(x,w);\n\t\t\th = max(y,h);\n\t\t\t_w = min(x,_w);\n\t\t\t_h = min(y,_h);\n\t\t\ty++;\n\t\t\t//if(x < 0 || y < 0)cout<<\"!\"<<endl;\n\t\t\tif(t > T_MAX)goto next;\n\t\t}\n\t}\n\tnext:;\n\tint m,n;\n\twhile(cin>>m>>n,m){\n\t\tint sx,sy;\n\t\tfor(int i = 0;i < 1050;i++){\n\t\t\tfor(int j = 0;j < 1050;j++){\n\t\t\t\tif(sc[i][j] == n)sy = i,sx = j;\n\t\t\t\tdp[i][j][0] = dp[i][j][1] = -1;\n\t\t\t}\n\t\t}\n\t\tdp[sy][sx][0] = dp[sy][sx][1] = 0;\n\t\tif(!isNotPrime[sc[sy][sx]])dp[sy][sx][0]++,dp[sy][sx][1] = sc[sy][sx];\n\t\tint aval = dp[sy][sx][0],aidx = dp[sy][sx][1];\n\t\tfor(int i = sy;i <= h+1;i++){\n\t\t\tfor(int j = 0;j <= w+1;j++){\n\t\t\t\tif(dp[i][j][0] == -1)continue;\n\t\t\t\tif(sc[i+1][j] != 0 && sc[i+1][j] <= m){\n\t\t\t\t\tint n0 = dp[i][j][0] + !isNotPrime[sc[i+1][j]];\n\t\t\t\t\tint n1 = (!isNotPrime[sc[i+1][j]]) ? sc[i+1][j] : dp[i][j][1];\n\t\t\t\t\tif(dp[i+1][j][0] == n0 ? dp[i+1][j][1] < n1 : dp[i+1][j][0] < n0){\n\t\t\t\t\t\tdp[i+1][j][0] = n0;\n\t\t\t\t\t\tdp[i+1][j][1] = n1;\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[i+1][j][0] == aval ? dp[i+1][j][1] > aidx : dp[i+1][j][0] > aval){\n\t\t\t\t\t\taval = dp[i+1][j][0];\n\t\t\t\t\t\taidx = dp[i+1][j][1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(sc[i+1][j-1] != 0 && sc[i+1][j-1] <= m){\n\t\t\t\t\tint n0 = dp[i][j][0] + !isNotPrime[sc[i+1][j-1]];\n\t\t\t\t\tint n1 = (!isNotPrime[sc[i+1][j-1]]) ? sc[i+1][j-1] : dp[i][j][1];\n\t\t\t\t\tif(dp[i+1][j-1][0] == n0 ? dp[i+1][j-1][1] < n1 : dp[i+1][j-1][0] < n0){\n\t\t\t\t\t\tdp[i+1][j-1][0] = n0;\n\t\t\t\t\t\tdp[i+1][j-1][1] = n1;\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[i+1][j-1][0] == aval ? dp[i+1][j-1][1] > aidx : dp[i+1][j-1][0] > aval){\n\t\t\t\t\t\taval = dp[i+1][j-1][0];\n\t\t\t\t\t\taidx = dp[i+1][j-1][1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(sc[i+1][j+1] != 0 && sc[i+1][j+1] <= m){\n\t\t\t\t\tint n0 = dp[i][j][0] + !isNotPrime[sc[i+1][j+1]];\n\t\t\t\t\tint n1 = (!isNotPrime[sc[i+1][j+1]]) ? sc[i+1][j+1] : dp[i][j][1];\n\t\t\t\t\tif(dp[i+1][j+1][0] == n0 ? dp[i+1][j+1][1] < n1 : dp[i+1][j+1][0] < n0){\n\t\t\t\t\t\tdp[i+1][j+1][0] = n0;\n\t\t\t\t\t\tdp[i+1][j+1][1] = n1;\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[i+1][j+1][0] == aval ? dp[i+1][j+1][1] > aidx : dp[i+1][j+1][0] > aval){\n\t\t\t\t\t\taval = dp[i+1][j+1][0];\n\t\t\t\t\t\taidx = dp[i+1][j+1][1];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//cout<<i<<\" \"<<j<<\" \"<<dp[i][j][0]<<\" \"<<dp[i][j][1]<<endl;\n\t\t\t}\n\t\t}\n\t\tcout<<aval<<\" \"<<aidx<<endl;\n\t}\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\nconst int MAXN = 1000001;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\nbool isPrime[MAXN];\nint I[MAXN], J[MAXN];\n\nconst int H = 1111;\nconst int W = 1111;\nint G[H][W];\nint m, n;\npair<int, int> dp[H][W];\n\nint main() {\n  fill(isPrime, isPrime+MAXN, true);\n  isPrime[0] = isPrime[1] = false;\n  for(int i = 2; i < MAXN; ++i) {\n    if(!isPrime[i]) continue;\n    for(int j = i*2; j < MAXN; j += i) {\n      isPrime[j] = false;\n    }\n  }\n\n  {\n    fill(G[0], G[H], INF);\n    int pi = 500, pj = 500, d = 2;\n    G[pi][pj] = 1;\n    I[1] = pi, J[1] = pj;\n    for(int num = 2; num < MAXN; ++num) {\n      for(int k = 0; k < 4; ++k) {\n        int nd = (d + k + 2) % 4;\n        int ni = pi + di[nd];\n        int nj = pj + dj[nd];\n        if(G[ni][nj] != INF) continue;\n        G[ni][nj] = num;\n        pi = ni, pj = nj, d = nd;\n        I[num] = pi, J[num] = pj;\n        break;\n      }\n    }\n  }\n\n  while(cin >> m >> n && (m|n)) {\n    int si = I[n], sj= J[n];\n    fill(dp[0], dp[H], make_pair(-1, -1));\n    dp[si][sj] = make_pair(isPrime[G[si][sj]], \n                           isPrime[G[si][sj]] * G[si][sj]);\n    pair<int, int> res = dp[si][sj];\n    for(int i = si; i+1 < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        if(dp[i][j].first == -1) continue;\n        for(int d = -1; d <= 1; ++d) {\n          int ni = i + 1;\n          int nj = j + d;\n          if(nj < 0 || nj >= W) continue;\n          if(G[ni][nj] > m) continue;\n          dp[ni][nj]\n            = max(dp[ni][nj],\n                  make_pair(dp[i][j].first + isPrime[G[ni][nj]],\n                            max(dp[i][j].first, isPrime[G[ni][nj]]*G[ni][nj])));\n          res = max(res, dp[ni][nj]);\n        }\n      }\n    }\n    cout << res.first << \" \" << res.second << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint si = 0, sj = 0;\n\npair<int, int> toij(int p) {\n    int u = 1;\n    while (u * u < p)\n        ++u;\n\n    if (u % 2 == 0) {\n        int ui = si - u / 2;\n        int uj = sj - u / 2 + 1;\n        if (u * (u - 1) < p) {\n            return make_pair(ui, uj + (u * u - p));\n        }\n        else {\n            return make_pair(ui + (u * (u - 1) - p) + 1, uj + u - 1);\n        }\n    }\n    else {\n        int ui = si + u / 2;\n        int uj = sj + u / 2;\n        if (u * (u - 1) < p) {\n            return make_pair(ui, uj - (u * u - p));\n        }\n        else {\n            return make_pair(ui - (u * (u - 1) - p) - 1, uj - u + 1);\n        }\n    }\n}\nint tov(int pi, int pj) {\n    int dma = max(abs(pi - si), abs(pj - sj));\n    int u = dma * 2;\n    if (pi == si + dma) {\n        return (u + 1) * (u + 1) - (sj + dma - pj);\n    }\n    if (pj == sj - dma) {\n        return u * u + (pi - (si - dma) + 1);\n    }\n    if (pi == si - dma) {\n        return u * u - (pj - (sj - dma + 1));\n    }\n    if (pj == sj + dma) {\n        return u * (u - 1) + ((si - dma + 1) - pi);\n    }\n\n}\nvector<int> sieve(int n) {\n    vector<int> v(n, 1);\n    for (int i = 2; i < n; ++i)\n    {\n        if (!v[i]) continue;\n\n        for (int j = i * i; j < n; j += i)\n        {\n            v[j] = 1;\n        }\n    }\n    return v;\n}\nvector<int> isp;\nvector<int> memo;\nint dfs(int v, int lim) {\n    if (v > lim) return 0;\n    if (memo[v] >= 0) return memo[v];\n    auto p = toij(v);\n    int pi = p.first, pj = p.second;\n\n    return memo[v] = isp[v] + max({dfs(tov(pi + 1, pj - 1), lim), dfs(tov(pi + 1, pj), lim), dfs(tov(pi + 1, pj + 1), lim)});\n}\n\nint main()\n{\n    isp = sieve(1000010);\n\n\n    while (true)\n    {\n        int m, n;\n        cin >> m >> n;\n        if (!m) return 0;\n        memo.resize(m + 1, -1);\n        cout << dfs(n, m) << \"\\n\";\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint si = 0, sj = 0;\nvector<int> isp;\n\npair<int, int> toij(int p) {\n    int u = 1;\n    while (u * u < p)\n        ++u;\n\n    if (u % 2 == 0) {\n        int ui = si - u / 2;\n        int uj = sj - u / 2 + 1;\n        if (u * (u - 1) < p) {\n            return make_pair(ui, uj + (u * u - p));\n        }\n        else {\n            return make_pair(ui + (u * (u - 1) - p) + 1, uj + u - 1);\n        }\n    }\n    else {\n        int ui = si + u / 2;\n        int uj = sj + u / 2;\n        if (u * (u - 1) < p) {\n            return make_pair(ui, uj - (u * u - p));\n        }\n        else {\n            return make_pair(ui - (u * (u - 1) - p) - 1, uj - u + 1);\n        }\n    }\n}\nint tov(int pi, int pj) {\n    int dma = max(abs(pi - si), abs(pj - sj));\n    int u = dma * 2;\n    if (pi == si + dma) {\n        return (u + 1) * (u + 1) - (sj + dma - pj);\n    }\n    if (pj == sj - dma) {\n        return u * u + (pi - (si - dma) + 1);\n    }\n    if (pi == si - dma) {\n        return u * u - (pj - (sj - dma + 1));\n    }\n    if (pj == sj + dma) {\n        return u * (u - 1) + ((si - dma + 1) - pi);\n    }\n\n}\nvoid sieve(int n) {\n    isp.resize(n, 1);\n    isp[1] = 0;\n    for (int i = 2; i * i < n; ++i)\n    {\n        if (!isp[i]) continue;\n\n        for (int j = i * i; j < n; j += i)\n        {\n            isp[j] = 0;\n        }\n    }\n}\n\nint main()\n{\n    sieve(1000010);\n    while (true)\n    {\n        int m, n;\n        cin >> m >> n;\n        if (!m) return 0;\n\n        vector<int> ma(m + 1, -1);\n        vector<int> lp(m + 1);\n        queue<int> q;\n        q.push(n);\n        ma[n] = isp[n];\n        lp[n] = isp[n] ? n : 0;\n        int ansi = 0, ansj = 0;\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            auto p = toij(v);\n            int pi = p.first, pj = p.second;\n            int next = 0;\n            for (int j = pj - 1; j <= pj + 1; ++j) {\n                int nv = tov(pi + 1, j);\n                if (nv > m) continue;\n\n                next = 1;\n                if (ma[nv] < 0)\n                    q.push(nv);\n\n                if (ma[nv] < ma[v] + isp[nv]) {\n                    ma[nv] = ma[v] + isp[nv];\n                    lp[nv] = isp[nv] ? nv : lp[v];\n                }\n                else if (ma[nv] == ma[v] + isp[nv]) {\n                    lp[nv] = max(lp[nv], isp[nv] ? nv : lp[v]);\n                }\n            }\n            if (!next) {\n                if (ansi < ma[v]) {\n                    ansi = ma[v];\n                    ansj = lp[v];\n                }\n                else if (ansi == ma[v] && ansj < lp[v]) {\n                    ansj = lp[v];\n                }\n            }\n        }\n        cout << ansi << \" \" << ansj << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define SIZE 1000\n\nbool C(int dp1, int pr1, int dp2, int pr2) {\n\tif (dp2 == 0)return false;\n\tif (dp1 < dp2 || (dp1 == dp2&&pr1 < pr2))return true;\n\treturn false;\n}\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x - 1], pr[y + 1][x - 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x], pr[y + 1][x])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x + 1], pr[y + 1][x + 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\n\t\toutput = false;\n\t\tfor (int i = 0;i < SIZE&&!output;i++) {\n\t\t\tfor (int j = 0;j < SIZE&&!output;j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tprintf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int MAX_M = 1000001;\nconst int C = 1000;\nconst int INF = 1e9;\n#define y first\n#define x second\n\nmap<int, P> itop;\nmap<P, int> ptoi;\nbool isp[MAX_M];\n\nvoid make_prime(){\n  REP(i, MAX_M) isp[i] = true;\n  isp[0] = isp[1] = false;\n  FOR(i, 2, sqrt(MAX_M) + 1){\n    if(!isp[i]) continue;\n    for(int j = i + i; j < MAX_M; j += i) isp[j] = false;\n  }\n}\n\nvoid init(){\n  P now = P(C / 2, C / 2);\n  int pls = 1, l = 1, step = 0, d = 0;\n  FOR(i, 1, MAX_M){\n    itop[i] = now;\n    ptoi[now] = i;\n    if(d == 0) now.x += 1;\n    else if(d == 1) now.y -= 1;\n    else if(d == 2) now.x -= 1;\n    else if(d == 3) now.y += 1;\n    ++step;\n    if(step >= l){\n      d = (d + 1) % 4;\n      step = 0;\n    }\n    if(i != 1 && (d == 0 || d == 2) && step == 0) ++l;\n  }\n}\n\nint main() {\n  make_prime();\n  init();\n  int M, N;\n  while(cin >>M >>N && (N && M)){\n    cout <<\"0 0\" <<endl;\n    //P dp[C][C];\n    //REP(i, C) REP(j, C) dp[i][j] = P(-1, -1);\n    //P now = itop[N], ans = P(-1, -1);\n    //dp[now.y][now.x] = (isp[N] ? P(1, N) : P(0, -1));\n    //REP(y, C){\n    //  REP(x, C){\n    //    if(dp[y][x].first == -1 || ptoi.find(P(y, x)) == ptoi.end()) continue;\n    //    ans = max(ans, dp[y][x]);\n    //    for(int mx = -1; mx <= 1; ++mx){\n    //      int ny = y + 1, nx = x + mx;\n    //      if(ny < 0 || nx < 0 || ny >= C || nx >= C || ptoi.find(P(ny, nx)) == ptoi.end()) continue;\n    //      int cnt = dp[y][x].first + (isp[ptoi[P(ny, nx)]] ? 1 : 0), num = (isp[ptoi[P(ny, nx)]] ? ptoi[P(ny, nx)] : dp[y][x].second);\n    //      if(num > M) continue;\n    //      if(cnt > dp[ny][nx].first || (cnt == dp[ny][nx].first && num > dp[ny][nx].second)) dp[ny][nx] = P(cnt, num);\n    //    }\n    //  }\n    //}\n    //if(ans.first == 0) cout <<\"0 0\" <<endl;\n    //else cout <<ans.first <<\" \" <<ans.second <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define SIZE 1000\n\nbool C(int dp1, int pr1, int dp2, int pr2) {\n\tif (dp2 == 0)return false;\n\tif (dp1 < dp2 || (dp1 == dp2&&pr1 < pr2))return true;\n\treturn false;\n}\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool complete;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i <= SIZE&&a <= SIZE*SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i+1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x--;\n\t\t\telse x++;\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (y>=0&&x>=0&&table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\tcomplete = false;\n\t\twhile (!complete) {\n\t\t\twhile (x >= 0 && !complete) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x - 1], pr[y + 1][x - 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x], pr[y + 1][x])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x + 1], pr[y + 1][x + 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (table[y][x] == n)complete = true;\n\t\t\t\telse x--;\n\t\t\t}\n\t\t\tif (!complete) {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\n#define mp make_pair\ntypedef pair<int,int> pii;\n\nconst int M_MAX = 1000010;\nconst int N = 4000;\n\npii fill(vector<vector<int>> &maze, int x, int y, int dir, int k, int s) {\n  for (int i = 0; i < k; i++) {\n    maze[y + i * dy[dir]][x + i * dx[dir]] = s++;\n  }\n  return mp(x + k * dx[dir], y + k * dy[dir]);\n}\n\nvoid make(vector<vector<int>> &maze) {\n  pii now = mp(N / 2, N / 2);\n  int k = 1;\n  int num = 1;\n  while(num <= M_MAX) {\n    now = fill(maze, now.first, now.second, 0, k, num); num += k;\n    now = fill(maze, now.first, now.second, 1, k, num); num += k;\n    k++;\n    now = fill(maze, now.first, now.second, 2, k, num); num += k;\n    now = fill(maze, now.first, now.second, 3, k, num); num += k;\n    k++;\n  }\n}\n\nchar isprime[M_MAX];\n\nvoid era() {\n  for (int i = 0; i < M_MAX; i++) {\n    isprime[i] = 1;\n  }\n  isprime[0] = isprime[1] = 0;\n  for (int i = 2; i < M_MAX; i++) {\n    if (isprime[i]) {\n      for (int j = i + i; j < M_MAX; j += i) {\n        isprime[j] = 0;\n      }\n    }\n  }\n}\n\nvoid solve(vector<vector<int>> &maze, int m, int n) {\n  int sx, sy;\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      if (maze[i][j] == n) {\n        sx = j, sy = i;\n      }\n    }\n  }\n  vector<vector<int>> dp(N, vector<int>(N, -1));\n  dp[sy][sx] = isprime[maze[sy][sx]];\n  for (int i = 0; i < N - 1; i++) {\n    for (int j = 0; j < N; j++) {\n      if (maze[i][j] > m) continue;\n      if (dp[i][j] == -1) continue;\n      if (j >= 1) dp[i + 1][j - 1] = max(dp[i + 1][j - 1], dp[i][j] + isprime[maze[i + 1][j - 1]]);\n      dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + isprime[maze[i + 1][j]]);\n      if (j < N - 1) dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + isprime[maze[i + 1][j + 1]]);\n    }\n  }\n  int ma = 0;\n  int ma_ind = 0;\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      if (maze[i][j] > m) continue;\n      if (ma <= dp[i][j] && isprime[maze[i][j]]) {\n        if (ma < dp[i][j]) {\n          ma = dp[i][j];\n          ma_ind = maze[i][j];\n        } else {\n          if (ma_ind < maze[i][j]) ma_ind = maze[i][j];\n        }\n      }\n    }\n  }\n  if (ma == 0) {\n    cout << \"0 0\" << endl;\n  } else {\n    cout << ma << \" \" << ma_ind << endl;\n  }\n}\n\nint main() {\n  vector<vector<int>> maze(N, vector<int>(N, 0));\n  make(maze);\n  era();\n\n  int n, m;\n  while(cin >> m >> n, m != 0) {\n    solve(maze, m, n);\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nint n;\nP pos;\nvector<bool> prime;\nint dr[4] = {0, -1, 0, 1};\nint dc[4] = {1, 0, -1, 0};\nvoid search(vvi &b, vector<vector<bool>> &p, int r, int c, int now, int ed, int cnt, int nowma, int prevma, int dir) {\n  if(now == 1097) {\n  }\n  if(now == ed+1) return;\n  if(cnt == nowma && nowma == prevma) {\n    search(b, p, r, c, now, ed, 0, nowma+1, nowma, (dir + 1) % 4);\n  } else if(cnt == nowma) {\n    search(b, p, r, c, now, ed, 0, nowma, nowma, (dir + 1) % 4);\n  } else {\n    int nr = r + dr[dir], nc = c + dc[dir];\n    b[nr][nc] = now;\n    if(prime[now]) p[nr][nc] = true;\n    if(now == n) pos = {nr, nc};\n    search(b, p, nr, nc, now+1, ed, cnt+1, nowma, prevma, dir);\n  }\n  return;\n}\nint main() {\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  prime.resize(1000001, true);\n  prime[0] = false;\n  prime[1] = false;\n  for(int i=2;i*i<=1000000;++i) {\n    if(prime[i]) {\n      int now = 2*i;\n      while(now <= 1000000) {\n        prime[now] = false;\n        now += i;\n      }\n    }\n  }\n  while(1) {\n    int m; cin >> m >> n;\n    if(m == 0) break;\n    vvi b(1001, vi(1001, 0));\n    b[500][500] = 1;\n    pos = {500, 500};\n    vector<vector<bool>> p(1001, vector<bool>(1001, false));\n    search(b, p, 500, 500, 2, m, 0, 1, 0, 0);\n    vector<vector<P>> dp(1001, vector<P>(1001, {0, 0}));\n    int sr = pos.first, sc = pos.second;\n    dp[sr][sc] = {p[sr][sc], (p[sr][sc] ? b[sr][sc] : 0)};\n    for(int i=sr;i<1000;++i) {\n      for(int j=-(i-sr)+sc;j<=i-sr+sc;++j) {\n        if(!(0 <= j && j < 1001)) continue;\n        for(int k=-1;k<=1;++k) {\n          if(!(0 <= j+k && j+k < 1001)) continue;\n          if(dp[i+1][j+k].first < dp[i][j].first + p[i+1][j+k]) {\n            dp[i+1][j+k] = {dp[i][j].first + p[i+1][j+k], (p[i+1][j+k] ? b[i+1][j+k] : dp[i][j].second)};\n          } else if(dp[i+1][j+k].first == dp[i][j].first + p[i+1][j+k]) {\n            dp[i+1][j+k].second = (p[i+1][j+k] ? b[i+1][j+k] : max(dp[i+1][j+k].second, dp[i][j].second));\n          }\n        }\n      }\n    }\n    int ma = 0;\n    int argma = 0;\n    for(int i=0;i<1001;++i) {\n      if(ma < dp[1000][i].first) {\n        ma = dp[1000][i].first;\n        argma = dp[1000][i].second;\n      } else if(ma == dp[1000][i].first) {\n        argma = max(argma, dp[1000][i].second);\n      }\n    }\n    cout << ma << \" \" << argma << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <complex>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<int(b); i++)\n#define rep(i,n) loop(i,0,n)\n#define all(c) (c).begin(), (c).end()\ntypedef complex<int> P;\n\nconst int MAX_M = 1e7+10;\nint ps[MAX_M/2];\nbool isp[MAX_M];\nint cnt_p = 0;\n\nint grid[5000][5000]={};\nP itop[MAX_M];\n\nvoid make_es(){\n    fill(isp,isp+MAX_M,true);\n    isp[0]=isp[1]=false;\n    rep(i,MAX_M){\n        if(!isp[i]) continue;\n        ps[cnt_p++] = i;\n        for(int j=i<<1; j<MAX_M; j+=i){\n            isp[j] = false;\n        }\n    }\n}\n\nP const ii(0,1);\n\nint n,m;\n\npair<int,int> dp[5000][5000];\n\npair<int,int> rec(int y, int x){\n    // cout << x << \" \" << y << endl;\n    if(dp[y][x].first!=-1) return dp[y][x];\n\n    pair<int,int> res(0,0);\n    if(isp[grid[y][x]]){\n        res.first = 1;\n        res.second = grid[y][x];\n    }\n\n    pair<int,int> best(0,0);\n    loop(i,-1,2){\n        if(grid[y+1][x+i]<=m){\n            auto t = rec(y+1,x+i);\n            best = max(t,best);\n        }\n    }\n\n    if(best.first != 0){\n        res.first += best.first;\n        res.second = best.second;\n    }\n\n    dp[y][x] = res;\n    return res;\n\n    // if(grid[y][x] > m) return 0;\n    // int res = isp[grid[y][x]];\n    // int k = 0;\n    // loop(i,-1,2){\n    //     k = max(k, rec(y+1,x+i));\n    // }\n    // res += k;\n    // dp[y][x] = res;\n    // return res;\n}\n\npair<int,int> solve(int k){\n    P p = itop[k];\n    return rec(p.real(), p.imag());\n}\n\nint main(){\n    make_es();\n\n    P p(2500,2500);\n    P dir(0,1);\n    for(int i=1; i<MAX_M; i++){\n        grid[p.real()][p.imag()] = i;\n        itop[i]=p;\n        p+=dir;\n        P q = p+dir*ii;\n        if(grid[q.real()][q.imag()] == 0){\n            dir*=ii;\n        }\n    }\n\n    while(cin>>m>>n, n+m){\n        auto t = make_pair(-1,-1);\n        rep(i,5000)rep(j,5000) dp[i][j] = t;\n        auto ans = solve(n);\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//マップをつくる\n//ふるって素数マップ作る\n//dp[深さ][左端からの距離]で素数洞窟に入った回数をDP、素数かどうかはO(1)で判定\n#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\n\nclass Solver{\npublic:\n\tint isprime[1100000];\t//素数なら1、そうでないなら0を入れる\n\tint data[2001][2001];\t//マップデータ。\n\tint dp[1201][1201];\n\tint dp2[1201][1201];\n\t\n\tvoid SetPrime( int m ){\n\t\tint i,j;\n\t\tfor( i = 0; i <= m; i++ ) isprime[i] = 1;\n\t\tisprime[0] = 0; isprime[1] = 0;\n\t\tfor( i = 2; i <= m; i++ ){\n\t\t\tif( isprime[i] ) {\n\t\t\t\t//cout << i << endl;\n\t\t\t\tfor( j = i*2; j <= m; j += i )\n\t\t\t\t\tisprime[j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid uzumaki( int m ){\n\t\tint i,j;\n\t\tint ci=600,cj=600;\n\t\tint cnt=1;\n\t\tfor( i = 1; cnt <= m; i++ ){\n\t\t\t//→\n\t\t\tfor( j = 0; j <= i; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[i+ci][j+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//↑\n\t\t\tfor( j = 1; j <= 2*i-1; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[i-j+ci][i+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//←\n\t\t\tfor( j = 1; j <= 2*i; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[-i+1+ci][i-j+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//↓\n\t\t\tfor( j = 1; j <= 2*i; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[-i+1+j+ci][-i+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//→\n\t\t\tfor( j = 1; j < i; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[i+1+ci][-i+j+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\t//デバッグ\n\t\t/*for( i = -10; i <= 10; i++ ){\n\t\t\tfor( j = -10; j <= 10; j++ ){\n\t\t\t\tprintf(\"%4d\",data[i+ci][j+cj]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t}\n\t\n\tpair<int, int> search_ij(int m, int n) {\n\t\tint i,j;\n\t\tint ci=600,cj=600;\t//uzumakiと同じにしておくこと！\n\t\tint cnt=1;\n\t\tfor( i = 1; cnt <= m; i++ ){\n\t\t\tif ( data[i+1+ci][cj] < n ) {\n\t\t\t\tcnt = data[i+1+ci][cj];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//→\n\t\t\tfor( j = 0; j <= i; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(i+ci, j+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//↑\n\t\t\tfor( j = 1; j <= 2*i-1; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(i-j+ci, i+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//←\n\t\t\tfor( j = 1; j <= 2*i; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(-i+1+ci, i-j+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//↓\n\t\t\tfor( j = 1; j <= 2*i; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(-i+1+j+ci, -i+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//→\n\t\t\tfor( j = 1; j < i; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(i+1+ci, -i+j+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\treturn pair<int, int>(-1, -1);\n\t}\n\t\n\tvoid DP( int m, int n ){\n\t\tint i,j;\n\t\tpair<int, int> ij = search_ij(m, n);\n\t\ti = ij.first; if ( i == -1 ) return;\n\t\tfor( ; i < 1200; i++ ) {\n\t\t\tfor( j = 0; j < 1200; j++ ) {\n\t\t\t\tdp[i][j] = -114514;\n\t\t\t\tdp2[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\ti = ij.first;\n\t\tj = ij.second;\n\t\tdp[i][j] = 0;\n\t\t\n\t\tfor( ; i < 1200; i++ ){\n\t\t\tfor( j = 0; j < 1200; j++ ){\n\t\t\t\t//今いる場所がゴールなら何もしない\n\t\t\t\tif ( data[i][j] > m || dp[i][j] < 0 )\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\t//今いる場所が素数か\n\t\t\t\tint c = isprime[ data[i][j] ];\n\t\t\t\tdp[i+1][j-1] = max( dp[i][j]+c, dp[i+1][j-1] );\n\t\t\t\tdp[i+1][j] = max( dp[i][j]+c, dp[i+1][j] );\n\t\t\t\tdp[i+1][j+1] = max( dp[i][j]+c, dp[i+1][j+1] );\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor( i = ij.first; i < 1200; i++ ){\n\t\t\tfor( j = 0; j < 1200; j++ ) {\n\t\t\t\tans = max(ans, dp[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//経路復元とついでにans2の更新。\n\t\t//ちなみに、ゴールからたどっていけば、たどった場所すべてがスタートからありつけるようにできるので、\n\t\t//ans2を直接更新することができる。(経路の候補が消える！ということがない)→嘘解法らしい。\n\t\t//したがって、ans2はdp2を全部埋めてから求めることにしよう。\n\t\tint ans2 = 0;\n\t\tif ( ans > 0 ) {\n\t\t\t//\n\t\t\tfor( i = 1199; i > ij.first; i-- ) {\n\t\t\t\tfor( j = 0; j < 1200; j++ ) {\n\t\t\t\t\tif ( dp[i][j] != ans && dp2[i][j] == 0 )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif ( dp2[i][j] == 0 ) {\n\t\t\t\t\t\tdp2[i][j] = 1;\n\t\t\t\t\t\tif ( isprime[data[i][j]] && data[i][j] <= m )\n\t\t\t\t\t\t\tdp2[i][j] = data[i][j];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ( data[i-1][j-1] <= m && dp[i-1][j-1] + isprime[data[i-1][j-1]] == dp[i][j]) {\n\t\t\t\t\t\tdp2[i-1][j-1] = max(dp2[i-1][j-1], dp2[i][j]);\n\t\t\t\t\t\tif ( isprime[data[i-1][j-1]] ) {\n\t\t\t\t\t\t\tdp2[i-1][j-1] = max(dp2[i-1][j-1], data[i-1][j-1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( data[i-1][j] <= m && dp[i-1][j] + isprime[data[i-1][j]] == dp[i][j] ) {\n\t\t\t\t\t\tdp2[i-1][j] = max(dp2[i-1][j], dp2[i][j]);\n\t\t\t\t\t\tif ( isprime[data[i-1][j]] )\n\t\t\t\t\t\t\tdp2[i-1][j] = max(dp2[i-1][j], data[i-1][j]);\n\t\t\t\t\t}\n\t\t\t\t\tif ( data[i-1][j+1] <= m && dp[i-1][j+1] + isprime[data[i-1][j+1]] == dp[i][j] ) {\n\t\t\t\t\t\tdp2[i-1][j+1] = max(dp2[i-1][j+1], dp2[i][j]);\n\t\t\t\t\t\tif ( isprime[data[i-1][j+1]] )\n\t\t\t\t\t\t\tdp2[i-1][j+1] = max(dp2[i-1][j+1], data[i-1][j+1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//\n\t\t\tans2 = dp2[ij.first][ij.second];\n\t\t}\n\t\tcout << ans << \" \" << ans2 << endl;\n\t}\n};\n\nSolver test;\n\nint main(){\n\tint m,n;\n\t\n\ttest.SetPrime(1090000);\n\ttest.uzumaki(1090000);\n\twhile( cin >> m >> n ){\n\t\tif(!m)return 0;\n\t\ttest.DP(m, n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int MAX_M = 1000001;\nconst int C = 1000;\nconst int INF = 1e9;\n#define y first\n#define x second\n\nmap<int, P> itop;\nmap<P, int> ptoi;\nbool isp[MAX_M];\n\nvoid make_prime(){\n  REP(i, MAX_M) isp[i] = true;\n  isp[0] = isp[1] = false;\n  FOR(i, 2, sqrt(MAX_M) + 1){\n    if(!isp[i]) continue;\n    for(int j = i + i; j < MAX_M; j += i) isp[j] = false;\n  }\n}\n\nvoid init(){\n  P now = P(C / 2, C / 2);\n  int c[C][C], pls = 1, l = 1, step = 0, d = 0;\n  memset(c, 0, sizeof(c));\n  FOR(i, 1, MAX_M){\n    itop[i] = now;\n    ptoi[now] = i;\n    if(d == 0) now.x += 1;\n    else if(d == 1) now.y -= 1;\n    else if(d == 2) now.x -= 1;\n    else if(d == 3) now.y += 1;\n    ++step;\n    if(step >= l){\n      d = (d + 1) % 4;\n      step = 0;\n    }\n    if(i != 1 && (d == 0 || d == 2) && step == 0) ++l;\n  }\n}\n\nint main() {\n  make_prime();\n  init();\n  int M, N;\n  while(cin >>M >>N && N){\n    P dp[C][C];\n    REP(i, C) REP(j, C) dp[i][j] = P(-1, -1);\n    P now = itop[N], ans = P(-1, -1);\n    dp[now.y][now.x] = (isp[N] ? P(1, N) : P(0, -1));\n    REP(y, C - 1){\n      REP(x, C){\n        if(dp[y][x].first == -1) continue;\n        //cout <<y <<\", \" <<x <<\" (\" <<ptoi[P(y, x)] <<\") = \" <<dp[y][x].first <<\", \" <<dp[y][x].second <<endl;\n        ans = max(ans, dp[y][x]);\n        for(int mx = -1; mx <= 1; ++mx){\n          int ny = y + 1, nx = x + mx, cnt = dp[y][x].first + (isp[ptoi[P(ny, nx)]] ? 1 : 0), num = (isp[ptoi[P(ny, nx)]] ? ptoi[P(ny, nx)] : dp[y][x].second);\n          if(num > M) continue;\n          if(cnt > dp[ny][nx].first || (cnt == dp[ny][nx].first && num > dp[ny][nx].second)) dp[ny][nx] = P(cnt, num);\n        }\n      }\n    }\n    if(ans.first == 0) cout <<\"0 0\" <<endl;\n    else cout <<ans.first <<\" \" <<ans.second <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t\n\t\toutput = false;\n\t\tfor (int h = 0;h < SIZE && (!output);h++) {\n\t\t\tfor (int w = 0;w < SIZE && (!output);w++) {\n\t\t\t\tif (table[h][w] == n) {\n\t\t\t\t\t//printf(\"%d %d\\n\", dp[i][j], pr[i][j]);\n\t\t\t\t\tcout << dp[h][w] << \" \" << pr[h][w] << endl;\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 2000\n#define LIMIT 1001000\ntypedef pair<int,int> pii;\n\nint M,N;\nint caves[MAX][MAX];\nint dp[MAX][MAX];\nmap<int,pii> mp;\nbool prime[LIMIT];\n\nconst int dx[4] = {1,0,-1,0};\nconst int dy[4] = {0,-1,0,1};\n\nvoid makePrime(){\n  fill(prime,prime+LIMIT,true);\n  prime[0] = prime[1] = false;\n  for(int i = 2 ; i*i < LIMIT ; i++){\n    if(prime[i]){\n      for(int j = i*2 ; j < LIMIT ; j+=i){\n        prime[j] = false;\n      }\n    }\n  }\n}\n\nvoid makeCaves(){\n  int x = 1000,y = 1000,dir = 0;\n  int num = 1,cnt = 1;\n  while(true){\n    if(cnt == LIMIT) break;\n    for(int i = 0 ; i < 2 ; i++){\n      for(int j = 0 ; j < num ; j++){\n        mp[cnt] = pii(y,x);\n        caves[y][x] = cnt++;\n        if(cnt == LIMIT){\n          return;\n        }\n        x += dx[dir];\n        y += dy[dir];\n      }\n      dir = (dir+1)%4;   \n    }\n    num++;\n  }\n}\n\nvoid solve(int sx,int sy){\n  dp[sy][sx] = prime[caves[sy][sx]];\n  for(int i = 0 ; i < MAX-1 ; i++){\n    for(int j = 1 ; j < MAX-1 ; j++){\n      if(dp[i][j] >= 0 && caves[i][j] <= M){\n        if(caves[i+1][j-1] <= M){\n          dp[i+1][j-1] = max(dp[i+1][j-1],dp[i][j]+prime[caves[i+1][j-1]]); \n        }\n        if(caves[i+1][j] <= M){\n          dp[i+1][j] = max(dp[i+1][j],dp[i][j]+prime[caves[i+1][j]]); \n        }\n        if(caves[i+1][j+1] <= M){\n          dp[i+1][j+1] = max(dp[i+1][j+1],dp[i][j]+prime[caves[i+1][j+1]]); \n        }\n      }\n    }\n  }\n  int res = 0, num = 0;\n  for(int i = 0 ; i < MAX ; i++){\n    for(int j = 0 ; j < MAX ; j++){\n      if(caves[i][j] <= M && prime[caves[i][j]]){\n        if(res < dp[i][j]){\n          res = dp[i][j];\n          num = caves[i][j];\n        }else if(res == dp[i][j]){\n          if(num < caves[i][j]){\n            num = caves[i][j];\n          }\n        }\n      }\n    }\n  }\n  cout << res << \" \" << num << endl;\n}\n\nint main(){\n  makeCaves();\n  makePrime();\n  while(cin >> M >> N, M){\n    pii src = mp[N];\n    memset(dp,-1,sizeof(dp));\n    solve(src.second,src.first);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE * SIZE + 1];\n\tint table[SIZE][SIZE];\n\tint dp[SIZE][SIZE];\n\tint pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d %d\", &m, &n);\n\t\tif (m == 0 || n == 0)return 0;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = SIZE - 1;i >= 0;i--){\n\t\t\tfor(int j = SIZE - 1;j >= 0;j--){\n\t\t\t\tif (table[i][j] <= m) {\n\t\t\t\t\tif (i + 1 < SIZE) {\n\t\t\t\t\t\tif (j > 0 && table[i + 1][j - 1] <= m){\n\t\t\t\t\t\t\tif (dp[i][j] < dp[i + 1][j - 1] || (dp[i][j] == dp[i + 1][j - 1] && pr[i][j] < pr[i + 1][j - 1])) {\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j - 1];\n\t\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j - 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (table[i + 1][j] <= m){\n\t\t\t\t\t\t\tif (dp[i][j] < dp[i + 1][j] || (dp[i][j] == dp[i + 1][j] && pr[i][j] < pr[i + 1][j])) {\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j];\n\t\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j + 1 < SIZE && table[i + 1][j + 1] <= m){\n\t\t\t\t\t\t\tif (dp[i][j] < dp[i + 1][j + 1] || (dp[i][j] == dp[i + 1][j + 1] && pr[i][j] < pr[i + 1][j + 1])) {\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j + 1];\n\t\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j + 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!prime[table[i][j]]) {\n\t\t\t\t\t\tdp[i][j]++;\n\t\t\t\t\t\tif (pr[i][j] == 0) {\n\t\t\t\t\t\t\tpr[i][j] = table[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tprintf(\"%d %d\\n\", dp[i][j], pr[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int N = 1000;\n\n#define F first\n#define S second\n\nvi dx = { 1, 0,-1, 0};\nvi dy = { 0,-1, 0, 1};\n\nint main(void){\n    vvi cave(N + 1, vi(N + 1)); \n\n    pii pos = mp(N / 2, N / 2);\n    cave[N / 2][N / 2] = 1;\n\n    int limit = 1, cnt = 0, dir = 0, inc = false;\n    range(i, 2, N * N + 1){\n        if(cnt++ == limit){\n            (++dir) %= dx.size();\n\n            if(inc) limit++;\n            cnt = 0;\n\n            inc = !inc;\n\n            i--;\n            continue;\n        }\n\n        pos.F += dy[dir];\n        pos.S += dx[dir];\n\n        cave[pos.F][pos.S] = i;\n    }\n\n\tconst int MAX_N = (int)1e6 + 1;\n\tvector<bool> isP(MAX_N, true);\n    isP[0] = isP[1] = false;\n\tfor(int i = 2; i * i < MAX_N; i++) if(isP[i]) for(int j = i; i * j < MAX_N; j++) isP[i * j] = false;\n\n    for(int m, n; cin >> m >> n, m; ){\n        \n        //(集めた個数, 最後に通った素数)\n        vector<vector<pii>> dp(N + 1, vector<pii>(N + 1, mp(-1, -1)));\n\n        rep(y, N + 1) rep(x, N + 1) if(cave[y][x] == n) dp[y][x] = isP[cave[y][x]] ? mp(1, cave[y][x]):mp(0, 0);\n\n        pii res = mp(-1, -1);\n        rep(y, N + 1){\n            rep(x, N + 1){\n                if(cave[y][x] > m || dp[y][x].F == -1) continue;\n\n                res = max(res, dp[y][x]);\n\n                rep(i, 3){\n                    int xx = x + dx[i];\n                    int yy = y + 1;\n\n                    if(xx < 0 || N < xx ||\n                       yy < 0 || N < yy) continue;\n\n                    dp[yy][xx] = max(dp[yy][xx], mp(dp[y][x].F + (isP[cave[yy][xx]] ? 1:0), isP[cave[yy][xx]] ? cave[yy][xx]:dp[y][x].S));\n                }\n            }\n        }\n\n        cout << res.F << \" \" << res.S << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1500\n#define LIMIT 1201000\ntypedef pair<int,int> pii;\n\nint M,N;\nint caves[MAX][MAX];\nint dp[MAX][MAX];\nmap<int,pii> mp;\nbool prime[LIMIT];\n\nconst int dx[4] = {1,0,-1,0};\nconst int dy[4] = {0,-1,0,1};\n\nvoid makePrime(){\n  fill(prime,prime+LIMIT,true);\n  prime[0] = prime[1] = false;\n  for(int i = 2 ; i*i < LIMIT ; i++){\n    if(prime[i]){\n      for(int j = i*2 ; j < LIMIT ; j+=i){\n        prime[j] = false;\n      }\n    }\n  }\n}\n\nvoid makeCaves(){\n  int x = 750,y = 750,dir = 0;\n  int num = 1,cnt = 1;\n  while(true){\n    if(cnt == LIMIT) break;\n    for(int i = 0 ; i < 2 ; i++){\n      for(int j = 0 ; j < num ; j++){\n        mp[cnt] = pii(y,x);\n        caves[y][x] = cnt++;\n        if(cnt == LIMIT){\n          return;\n        }\n        x += dx[dir];\n        y += dy[dir];\n      }\n      dir = (dir+1)%4;   \n    }\n    num++;\n  }\n}\n\nvoid solve(int sx,int sy){\n  dp[sy][sx] = prime[caves[sy][sx]];\n  for(int i = 0 ; i < MAX-1 ; i++){\n    for(int j = 0 ; j < MAX ; j++){\n      if(dp[i][j] >= 0 && caves[i][j] <= M){\n        if(caves[i+1][j-1] <= M){\n          dp[i+1][j-1] = max(dp[i+1][j-1],dp[i][j]+prime[caves[i+1][j-1]]); \n        }\n        if(caves[i+1][j] <= M){\n          dp[i+1][j] = max(dp[i+1][j],dp[i][j]+prime[caves[i+1][j]]); \n        }\n        if(caves[i+1][j+1] <= M){\n          dp[i+1][j+1] = max(dp[i+1][j+1],dp[i][j]+prime[caves[i+1][j+1]]); \n        }\n      }\n    }\n  }\n  int res = 0, num = 0;\n  for(int i = 0 ; i < MAX ; i++){\n    for(int j = 0 ; j < MAX ; j++){\n      if(caves[i][j] <= M && prime[caves[i][j]]){\n        if(res <= dp[i][j]){\n          res = dp[i][j];\n          num = caves[i][j];\n        }\n      }\n    }\n  }\n  cout << res << \" \" << num << endl;\n}\n\nint main(){\n  makeCaves();\n  makePrime();\n  while(cin >> M >> N, M){\n    pii src = mp[N];\n    memset(dp,-1,sizeof(dp));\n    solve(src.second,src.first);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst int N = 1111111;\nbool prime[N];\nvector<int> primes;\n\nvoid hurui()\n{\n\tmemset(prime, true, sizeof(prime));\n\tprime[0] = prime[1] = false;\n\tfor (int i = 2; i*i < N; i++)\n\t{\n\t\tfor (int j = 2; i*j < N; j++)\n\t\t{\n\t\t\tprime[i*j] = false;\n\t\t}\n\t}\n\tREP(i, N + 1)\n\t{\n\t\tif (prime[i]) primes.push_back(i);\n\t}\n}\n\nint m, n;\nbool fld[1200][1200];\npii id[1111111];\nint hs[1200][1200];\n\nvoid init()\n{\n\tint tx = 600, ty = 600, t = 1;\n\tFOR(i, 1, INF)\n\t{\n\t\tif (t > 1000000) break;\n\t\tif (i % 2)\n\t\t{\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tid[t] = pii(tx, ty);\n\t\t\t\ths[tx][ty] = t;\n\t\t\t\tt++;\n\t\t\t\tty++;\n\t\t\t}\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tid[t] = pii(tx, ty);\n\t\t\t\ths[tx][ty] = t;\n\t\t\t\tt++;\n\t\t\t\ttx--;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tid[t] = pii(tx, ty);\n\t\t\t\ths[tx][ty] = t;\n\t\t\t\tt++;\n\t\t\t\tty--;\n\t\t\t}\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tid[t] = pii(tx, ty);\n\t\t\t\ths[tx][ty] = t;\n\t\t\t\tt++;\n\t\t\t\ttx++;\n\t\t\t}\n\t\t}\n\t}\n}\n\npii dp[1200][1200];\n\npii solve(int x, int y)\n{\n\tif (x == 1199) return pii(0, 0);\n\tif (dp[x][y].first >= 0) return dp[x][y];\n\tpii res(0, 0);\n\tif (fld[x + 1][y - 1])\n\t{\n\t\tpii tmp = solve(x + 1, y - 1);\n\t\tchmax(res, pii(tmp.first + 1, (tmp.second==0?hs[x + 1][y - 1]:tmp.second)));\n\t}\n\telse\n\t{\n\t\tchmax(res, pii(solve(x + 1, y - 1).first, solve(x + 1, y - 1).second));\n\t}\n\n\tif (fld[x + 1][y])\n\t{\n\t\tpii tmp = solve(x + 1, y);\n\t\tchmax(res, pii(tmp.first + 1, (tmp.second == 0 ? hs[x + 1][y] : tmp.second)));\n\t}\n\telse\n\t{\n\t\tchmax(res, pii(solve(x + 1, y).first, solve(x + 1, y).second));\n\t}\n\n\tif (fld[x + 1][y + 1])\n\t{\n\t\tpii tmp = solve(x + 1, y + 1);\n\t\tchmax(res, pii(tmp.first + 1, (tmp.second == 0 ? hs[x + 1][y + 1] : tmp.second)));\n\t}\n\telse\n\t{\n\t\tchmax(res, pii(solve(x + 1, y + 1).first, solve(x + 1, y + 1).second));\n\t}\n\treturn dp[x][y] = res;\n}\n\nint main()\n{\n\thurui();\n\tinit();\n\twhile (cin >> n >> m, n)\n\t{\n\t\tMS(fld, false);\n\t\tREP(i, 1200)REP(j, 1200) dp[i][j] = pii(-1, -1);\n\t\tREP(i, primes.size())\n\t\t{\n\t\t\tif (primes[i] > n) break;\n\t\t\tint x = id[primes[i]].first, y = id[primes[i]].second;\n\t\t\tfld[x][y] = true;\n\t\t}\n\t\tpii ans = solve(id[m].first, id[m].second);\n\t\tif (find(ALL(primes), m) != primes.end())\n\t\t{\n\t\t\tif(ans.second==0) cout << ans.first + 1 << \" \" << m << endl;\n\t\t\telse cout << ans.first + 1 << \" \" << ans.second << endl;\n\t\t}\n\t\telse cout << ans.first << \" \" << ans.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//=====================================================\n// \n// (setq backup-inhibited t)\n// (setq auto-save-default nil)\n// \n// (column-number-mode t)\n// (setq-default tab-width 2 indent-tabs-mode nil)\n// \n// (global-set-key \"\\C-h\" 'delete-backward-char)\n// \n// (setq indent-line-function 'indent-relative-maybe)\n// (global-set-key \"\\C-m\" 'newline-and-indent)\n// \n//=====================================================\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint main() {\n  vector<int> p(1000001,1);\n  p[0] = p[1] = 0;\n  for(int i = 2; i<=1000; ++i) {\n    if(p[i]==1){\n      for(int j = i*i;j<=1000000;j+=i){\n        p[j]=0;\n      }\n    }\n  }\n  while(1){\n    int m,n;\n    cin>>m>>n;\n    if(!n)break;\n    vector<vector<int>> cv(1000,vector<int>(1000));\n    int k=1000000;\n    int i=0;\n    int j=0;\n    int di[]={0,-1,0,1};\n    int dj[]={-1,0,1,0};\n    int r=2;\n    while(k>0){\n      cv[i][j] = k;\n      int ni = i+di[r];\n      int nj = j+dj[r];\n      if(ni<0||ni>=1000||nj<0||nj>=1000){\n        ++r;\n        r%=4;\n        ni = i+di[r];\n        nj = j+dj[r];\n      }\n      if(cv[ni][nj] != 0){\n        ++r;\n        r%=4;\n        ni = i+di[r];\n        nj = j+dj[r];\n      }\n      i=ni;j=nj;\n      --k;\n    }\n    int si=0,sj=0;\n    REP(i,1000){\n      REP(j,1000){\n        if(cv[i][j]==n){\n          si=i;\n          sj=j;\n        }\n      }\n    }\n    REP(i,1000){\n      REP(j,1000){\n        if(p[cv[i][j]]==0||cv[i][j]>m||(i+j)<(si+sj)||(i-j)<(si-sj))\n          cv[i][j]=0;\n      }\n    }\n    vector<vector<pair<int,int>>> dp(1000,vector<pair<int,int>>(1000));\n    REP(i,999){\n      REP(j,1000){\n        if(cv[i][j]!=0){\n          ++dp[i][j].first;\n          dp[i][j].second=cv[i][j];\n        }\n        if(j>0){\n          dp[i+1][j-1] = max(dp[i+1][j-1],dp[i][j]);\n        }\n        dp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n        if(j<999){\n          dp[i+1][j+1] = max(dp[i+1][j+1],dp[i][j]);\n        }\n      }\n    }\n    REP(j,1000){\n      if(cv[999][j]!=0){\n        ++dp[999][j].first;\n        dp[999][j].second=cv[999][j];\n      }\n    }\n    pair<int,int> mx(0,0);\n    REP(i,1000)\n      REP(j,1000)\n        mx=max(mx,dp[i][j]);\n    cout << mx.first << ' ' << mx.second << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint map[2000][2000],dp[2000][2000];\nint isprime[200];\nbool prime[1000001];\nbool square;\nvoid issquare(int n){\n\tsquare=false;\n\tfor(int i=2;i*i<=n;i++)if(n==i*i)square=true;\n\treturn;\n}\nint main(){\n\tfor(int i=0;i<=1000000;i++)prime[i]=true;\n\tprime[1]=false;\n\tint pcnt=0;\n\tfor(int i=2;i<1000;i++){\n\t\tbool ok=true;\n\t\tfor(int j=0;j<pcnt;j++)if(i%isprime[j]==0)ok=false;\n\t\tif(ok){\n\t\t\tfor(int j=i*i;j<=1000000;j+=i)prime[j]=false;\n\t\t\tisprime[pcnt]=i,pcnt++;\n\t\t}\n\t}\n\tfor(int i=0;i<2000;i++)for(int j=0;j<2000;j++){map[i][j]=-1,dp[i][j]=-10000;}\n\tint dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\tint x=1000,y=1000,s=0,t=1,r=1;\n\tmap[999][999]=1;\n\tfor(int k=1;k<=1000000;k++){\n\t\tmap[y][x]=k;\n\t\ty+=dy[r],x+=dx[r];\n\t\tissquare(k+1);\n\t\tif(square)t++;\n\t\tif(s==t){r=(r+1)%4;s=0;}\n\t\ts++;\n\t}//prepara\n\tint n,m;\n\twhile(true){\n\t\tcin>>m>>n;\n\t\tif(n==0&&m==0)break;\n\t\tfor(int i=0;i<2000;i++)for(int j=0;j<2000;j++)dp[i][j]=-10000;\n\t\tint x=0,y=0;\n\t\tbool end=false;\n\t\twhile(true){\n\t\t\twhile(true){\n\t\t\t\tif(map[y][x]==n){end=true;break;}\n\t\t\t\tx++;if(x==2000)break;\n\t\t\t}if(end)break;y++;\n\t\t}\n\t\tint ans=0,set=0;\n\t\tdp[y][x]=0;\n\t\tfor(int i=1;i<2000;i++){\n\t\t\tfor(int j=1;j<1999;j++){\n\t\t\t\tif(map[i][j]>0&&map[i][j]<=m){\n\t\t\t\t\tfor(int k=j-1;k<=j+1;k++)if(map[i-1][k]<=m)dp[i][j]=max(dp[i][j],dp[i-1][k]);\n\t\t\t\t\tdp[i][j]+=prime[map[i][j]];\n\t\t\t\t\tif(ans<dp[i][j])ans=dp[i][j],set=map[i][j];\n\t\t\t\t\tif(ans==dp[i][j]&&prime[map[i][j]]==true)set=map[i][j];\n\t\t\t\t}\n\t\t\t\t//cout<<dp[i][j]<<\" \";\n\t\t\t}\n\t\t\t//cout<<endl;\n\t\t}\n\t\tcout<<ans<<\" \"<<set<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> is_prime;\n\nvoid sieve(int n) {\n\tis_prime=vector<int>(n);\n\tfor (int i = 2; i < n; ++i)\n\t\tis_prime[i] = i;\n\tfor (int i = 2; i*i < n; ++i)\n\t\tif (is_prime[i])\n\t\t\tfor (int j = i*i; j < n; j+=i)\n\t\t\t\tis_prime[j] = 0;\n}\n\n\n//int map[1002][1002];//IDをいれる\nvector<vector<int> > map;\nint id_to_x[1000002];\nint id_to_y[1000002];\nconst int dx[4]={0,-1,0,1};\nconst int dy[4]={-1,0,1,0};\n\nconst int next_dx[3]={-1,0,1};\n\npair<int,int> dp[1002][1002];\n\nint m,n;\n\npair<int,int> calc(int x,int y){\n\tif(map[y][x]<0) return pair<int,int>(0,0);\n\tif(map[y][x]>m) return pair<int,int>(0,0);\n\n\tif(dp[y][x].first>0) return dp[y][x];\n\n\tint max_num=0,max_prime=0;\n\tfor(int r=0;r<3;r++){\n\t\tpair<int,int> got=calc(x+next_dx[r],y+1);\n\t\tif(got.first>max_num){\n\t\t\tmax_num=got.first;\n\t\t\tmax_prime=got.second;\n\t\t}else if(got.first==max_num){\n\t\t\tmax_prime=max(max_prime,got.second);\n\t\t}\n\t}\n\tif(map[y][x]<=1000000 && is_prime[map[y][x]]!=0){\n\t\tmax_num++;\n\t\tif(max_prime==0) max_prime=map[y][x];\n\t}\n\tdp[y][x]=pair<int,int>(max_num,max_prime);\n\treturn pair<int,int>(max_num,max_prime);\n}\n\nint main()\n{\n\tmap.resize(1002,vector<int>(1002));\n\tsieve(1000001);\n\tfor(int y=0;y<1002;y++)for(int x=0;x<1002;x++){\n\t\tmap[y][x]=-1;\n\t\tdp[y][x].first=-1;\n\t}\n\tint x=500,y=500;\n\tint id=1;\n\tmap[y][x]=id;\n\tid_to_x[1]=x;\n\tid_to_y[1]=y;\n\tint d=0;\n\tid++;\n\twhile(id<=1000000){\n\t\tfor(int r=0;r<4;r++){\n\t\t\tint nd=d;\n\t\t\tif(r==0) nd--;\n\t\t\telse if(r==3) nd++;\n\t\t\tfor(int k=0;k<nd;k++){\n\t\t\t\tif(id>1000000) break;\n\t\t\t\tx+=dx[r];\n\t\t\t\ty+=dy[r];\n\t\t\t\tmap[y][x]=id;\n\t\t\t\tid_to_x[id]=x;\n\t\t\t\tid_to_y[id]=y;\n\t\t\t\tid++;\n\t\t\t}\n\t\t}\n\t\td+=2;\n\t}\n\twhile(cin>>m>>n){\n\t\tif(m==0 && n==0) return 0;\n\t\tfor(int y=0;y<1002;y++)for(int x=0;x<1002;x++){\n\t\t\tdp[y][x].first=-1;\n\t\t}\n\t\tpair<int,int> got=calc(id_to_x[n],id_to_y[n]);\n\t\tcout<<got.first<<\" \"<<got.second<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint N = 1111111;\nbool prime[N];\nset<int> primes;\n\nvoid hurui()\n{\n\tmemset(prime, true, sizeof(prime));\n\tprime[0] = prime[1] = false;\n\tfor (int i = 2; i*i < N; i++)\n\t{\n\t\tfor (int j = 2; i*j < N; j++)\n\t\t{\n\t\t\tprime[i*j] = false;\n\t\t}\n\t}\n\tREP(i, N + 1)\n\t{\n\t\tif (prime[i]) primes.insert(i);\n\t}\n}\n\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\n\nbool fld[1200][1200] = {};\nint ind[1200][1200];\npii hs[1111111];\n\nvoid init()\n{\n\tREP(i, 1200)REP(j, 1200) ind[i][j] = INF;\n\thurui();\n\tint p = 1, x = 600, y = 600;\n\tFOR(i, 1, 11111111)\n\t{\n\t\tif (i % 2)\n\t\t{\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tind[x][y] = p;\n\t\t\t\ths[p] = pii(x, y);\n\t\t\t\tif (primes.count(p)) fld[x][y] = true;\n\t\t\t\tp++;\n\t\t\t\ty++;\n\t\t\t}\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tind[x][y] = p;\n\t\t\t\ths[p] = pii(x, y);\n\t\t\t\tif (primes.count(p)) fld[x][y] = true;\n\t\t\t\tp++;\n\t\t\t\tx--;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tind[x][y] = p;\n\t\t\t\ths[p] = pii(x, y);\n\t\t\t\tif (primes.count(p)) fld[x][y] = true;\n\t\t\t\tp++;\n\t\t\t\ty--;\n\t\t\t}\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tind[x][y] = p;\n\t\t\t\ths[p] = pii(x, y);\n\t\t\t\tif (primes.count(p)) fld[x][y] = true;\n\t\t\t\tp++;\n\t\t\t\tx++;\n\t\t\t}\n\t\t}\n\t\tif (p > 1000000) break;\n\t}\n}\n\npii dp[1200][1200];\nint n, m;\n\npii solve(int x, int y)\n{\n\tif (dp[x][y] !=pii(-1,-1)) return dp[x][y];\n\tpii res(0, -1);\n\tFOR(i, -1, 2)\n\t{\n\t\tint nx = x + 1, ny = y + i;\n\t\tif (ind[nx][ny] > m) continue;\n\t\tpii next = solve(nx, ny);\n\t\tif (fld[nx][ny])\n\t\t{\n\t\t\tif (next.first == 0) chmax(res, pii(next.first + 1, ind[nx][ny]));\n\t\t\telse chmax(res, pii(next.first + 1, next.second));\n\t\t}\n\t\telse chmax(res, next);\n\t}\n\treturn dp[x][y] = res;\n}\n\nint main()\n{\n\tinit();\n\twhile (cin >> m >> n, n)\n\t{\n\t\tREP(i, 1200)REP(j, 1200) dp[i][j] = pii(-1, -1);\n\t\tpii ans = solve(hs[n].first, hs[n].second);\n\t\tif (primes.count(n))\n\t\t{\n\t\t\tans.first++;\n\t\t\tchmax(ans.second, n);\n\t\t}\n\t\tif (ans.first == 0) cout << \"0 0\" << endl;\n\t\telse cout << ans.first << \" \" << ans.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\n\n#define all(v) v.begin(),v.end()\n#define INF 1<<30\n#define mp make_pair\n#define pb push_back\n\n#define fi first\n#define se second\n\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\ntypedef long long ll;\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nint s[1020][1010];\n\nbool is_prime(int n){\n\tif(n==0||n==1) return false;\n\tfor(int i=2;i*i<=n;i++){\n\t\tif(n%i==0){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(1){\n\t\trep(y,1020){\n\t\t\trep(x,1020){\n\t\t\t\ts[y][x]=0;\n\t\t\t}\n\t\t}\n\t\tint m,n;\n\t\tcin>>m>>n;\n\t\tif(m==0) break;\n\t\tint w = ceil(sqrt(m));\n\t\tw = (w%2==0)? w+1:w; \n\t\tint h = w;\n\t\tint sx = w/2;\n\t\tint sy = w/2;\n\t\tint dir = 0;\n\t\tint cnt = 1;\n\t\ts[sy][sx]=1;\n\t\tREP(i,1,w*w){\n\t\t\trep(k,2){\n\t\t\t\trep(j,i){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tsx = sx+dx[dir%4];\n\t\t\t\t\tsy = sy+dy[dir%4];\n\t\t\t\t\ts[sy][sx] = cnt;\n\n\t\t\t\t\tif(cnt==m) goto END;\n\t\t\t\t}\n\t\t\t\tdir++;\n\t\t\t}\n\t\t}\n\t\tEND:;\n\t\trep(y,h){\n\t\t\trep(x,w){\n\t\t\t\t// printf(\"%4d \",s[y][x]);\n\t\t\t\tif(s[y][x]==n){\n\t\t\t\t\tsy = y;\n\t\t\t\t\tsx = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// cout << endl;\n\t\t}\n\t\tpii dp[1020][1020];\n\t\trep(y,1000){\n\t\t\trep(x,1000){\n\t\t\t\tdp[y][x] = mp(0,0);\n\t\t\t}\n\t\t}\n\t\tfor (int y = h+1; y >= sy; --y)\n\t\t{\n\t\t\tfor(int x = 0;x<w;++x){\n\t\t\t\trep(i,3){\n\t\t\t\t\tif(x+i-1<0||x+i-1>=w) continue;\n\t\t\t\t\tif(dp[y][x].fi < dp[y+1][x+i-1].fi){\n\t\t\t\t\t\tdp[y][x].fi = dp[y+1][x+i-1].fi;\n\t\t\t\t\t\tdp[y][x].se = dp[y+1][x+i-1].se;\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[y][x].fi == dp[y+1][x+i-1].fi){\n\t\t\t\t\t\tif(dp[y][x].se < dp[y+1][x+i-1].se){\n\t\t\t\t\t\t\tdp[y][x].fi = dp[y+1][x+i-1].fi;\n\t\t\t\t\t\t\tdp[y][x].se = dp[y+1][x+i-1].se;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(is_prime(s[y][x])){\n\t\t\t\t\tdp[y][x].fi++;\n\t\t\t\t\tif(dp[y][x].se==0) dp[y][x].se = s[y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// rep(y,h){\n\t\t// \trep(x,w){\n\t\t// \t\tprintf(\"%2d \",dp[y][x].fi);\n\t\t// \t}\n\t\t// \tcout << endl;\n\t\t// }\n\t\tcout << dp[sy][sx].fi << \" \"<<dp[sy][sx].se<< endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nnamespace std {\n    template <>\n    class hash<std::pair<int, int>> {\n    public:\n        size_t operator()(const std::pair<int, int>& x) const{\n            return size_t((size_t)x.first * (size_t)x.second);\n        }\n    };\n}\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvoid solve(){\n    vector<bool> is_prime(1e6+1,true);\n    is_prime[0]=is_prime[1]=false;\n    rep(i,2,1e+6+1){\n        if(!is_prime[i]) continue;\n        for(int j=i*2; j<1e6+1; j+=i) is_prime[j]=false;\n    }\n    while(true){\n        int m,n;\n        cin >> m >> n;\n        if(m==0 and n==0) break;\n\n        unordered_map<pii,int> encode;\n        unordered_map<int,pii> decode;\n        unordered_map<int,vector<int>> xs;\n        {\n            int x=0,y=0,dir=3;\n            rep(i,1,m+1){\n                encode[make_pair(x,y)]=i;\n                decode[i]=make_pair(x,y);\n                xs[y].push_back(x);\n                int nx=x+dx[(dir+1)%4],ny=y+dy[(dir+1)%4];\n                if(encode.find(make_pair(nx,ny))==encode.end()) dir=(dir+1)%4;\n                else{\n                    nx=x+dx[dir];\n                    ny=y+dy[dir];\n                }\n                x=nx;\n                y=ny;\n            }\n        }\n\n        unordered_map<pii,int> dp;\n        int y=decode[n].second+1,ans,max_num;\n        if(is_prime[n]){\n            dp[decode[n]]=1;\n            ans=1;\n            max_num=n;\n        }else{\n            dp[decode[n]]=0;\n            ans=0;\n            max_num=0;\n        }\n        while(xs.find(y)!=xs.end()){\n            for(int x:xs[y]){\n                int tmp=-1;\n                if(dp.find(make_pair(x-1,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x-1,y-1)]);\n                if(dp.find(make_pair(x,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x,y-1)]);\n                if(dp.find(make_pair(x+1,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x+1,y-1)]);\n                if(tmp==-1) continue;\n                if(is_prime[encode[make_pair(x,y)]]){\n                    ++tmp;\n                    if(tmp>ans){\n                        ans=tmp;\n                        max_num=encode[make_pair(x,y)];\n                    }else if(tmp==ans) max_num=max(max_num,encode[make_pair(x,y)]);\n                }\n                dp[make_pair(x,y)]=tmp;\n            }\n            ++y;\n        }\n\n        cout << ans << \" \" << max_num << endl;\n    }\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,s,e) for (int i=s;i<(e);i++)\n#define All(v) (v).begin(),(v).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\n#define fi first\n#define se second\n#define int long long\nusing namespace std;\ntypedef long long llint;\ntypedef pair<int, int> P;\nconst int MOD = (int)1e9 + 7;\nconst int INF = (int)1e18 * 5;\n\nint a[3000][3000];\nint X[1000010], Y[1000010];\nP dp[3000][3000];\n\nvector<int> prime;\n\nvoid PrimeTable(int N){\n    prime = vector<int>(N+1, 1);\n    prime[0] = 0;\n    prime[1] = 0;\n\n    for(int i=2; i*i<=N; ++i){\n        if(prime[i]){\n            for(int j=2; i*j<=N; ++j){\n                prime[i*j] = 0;\n            }\n        }\n    }\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int now = 1, dir = 0, diff = 1;\n    int x=1500, y=1500;\n    a[1500][1500] = 1;\n    X[1] = 1500, Y[1] = 1500;\n    while(now <= 1000000){\n        switch(dir){\n        case 0:\n            FOR(dx, 1, diff+1){\n                a[y][x+dx] = ++now;\n                X[now] = x+dx;\n                Y[now] = y;\n            }\n            x = x+diff;\n            break;\n        case 1:\n            FOR(dy, 1, diff+1){\n                a[y-dy][x] = ++now;\n                X[now] = x;\n                Y[now] = y-dy;\n            }\n            y = y-diff;\n            break;\n        case 2:\n            FOR(dx, 1, diff+1){\n                a[y][x-dx] = ++now;\n                X[now] = x-dx;\n                Y[now] = y;\n            }\n            x = x-diff;\n            break;\n        case 3:\n            FOR(dy, 1, diff+1){\n                a[y+dy][x] = ++now;\n                X[now] = x;\n                Y[now] = y+dy;\n            }\n            y = y+diff;\n            break;\n        }\n        if(dir%2) diff++;\n        dir = (dir+1)%4;\n    }\n\n    // REP(i, 20){\n    //     REP(j, 20){\n    //         printf(\"%03d \", a[1490+i][1490+j]);\n    //     }\n    //     printf(\"\\n\");\n    // }\n    int m, n;\n    cin >> m >> n;\n    PrimeTable(1000010);\n    while(!(m==0 && n==0)){\n        REP(i, 3000)REP(j, 3000) dp[i][j] = mp(-1, 0);\n        int ny = Y[n], nx = X[n];\n        dp[ny][nx] = mp(prime[n], prime[n] ? n : 0);\n        bool f = true;\n        vector<int> shiftX{0};\n        vector<int> downX{-1, 0, 1};\n        int down = 0;\n        while(f){\n            f = false;\n            for(auto sx : shiftX){\n                for(auto dx : downX){\n                    if(dp[ny+1][nx+sx+dx].fi <= dp[ny][nx+sx].fi){\n                        dp[ny+1][nx+sx+dx].fi = dp[ny][nx+sx].fi+prime[a[ny+1][nx+sx+dx]];\n                        if(prime[a[ny+1][nx+sx+dx]]) dp[ny+1][nx+sx+dx].se = max(a[ny+1][nx+sx+dx], dp[ny][nx+sx].se);\n                        else{\n                            if(dp[ny+1][nx+sx+dx].fi < dp[ny][nx+sx].fi) dp[ny+1][nx+sx+dx].se = dp[ny][nx+sx].se;\n                            else chmax(dp[ny+1][nx+sx+dx].se, dp[ny][nx+sx].se);\n                        }\n                    }else if(dp[ny+1][nx+sx+dx].fi == dp[ny][nx+sx].fi+prime[a[ny+1][nx+sx+dx]]){\n                        dp[ny+1][nx+sx+dx].se = a[ny+1][nx+sx+dx];\n                    }\n                    if(0 < a[ny+1][nx+sx+dx] && a[ny+1][nx+sx+dx] <= m) f = true;\n                    else dp[ny+1][nx+sx+dx].fi = -1;\n                }\n            }\n            \n            if(down < 1000){\n                down++;\n                shiftX.pb(down);\n                shiftX.pb(-down);\n            }\n            // sort(All(shiftX));\n            // for(auto sx : shiftX){\n            //     cout << dp[ny+1][nx+sx]  << \" \";\n            // }\n            // cout << \"\\n\";\n            ny++;\n        }\n        P ans = mp(0, 0);\n        REP(i, 3000) chmax(ans, dp[ny-2][i]);\n        REP(i, 3000) chmax(ans, dp[ny-1][i]);\n        cout << ans.fi << \" \" << ans.se << \"\\n\";\n\n        cin >> m >> n;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (y>=0&&x>=0&&table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&\n\t\t\t\t\t\t(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]==dp[y + 1][x - 1]&&pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && \n\t\t\t\t\t\t(dp[y][x]<dp[y + 1][x] || (dp[y][x] == dp[y + 1][x] && pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && \n\t\t\t\t\t\t(dp[y][x]<dp[y + 1][x + 1] || (dp[y][x] == dp[y + 1][x + 1] && pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t\n\t\tfor (int h = 0;h < SIZE;h++) {\n\t\t\tfor (int w = 0;w < SIZE;w++) {\n\t\t\t\tif (table[h][w] == n) {\n\t\t\t\t\tcout << dp[h][w] << \" \";\n\t\t\t\t\t//cout << pr[h][w] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,s,e) for (int i=s;i<(e);i++)\n#define All(v) (v).begin(),(v).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long llint;\ntypedef pair<int, int> P;\nconst int MOD = (int)1e9 + 7;\nconst int INF = (int)1e18 * 5;\n\nint a[3000][3000];\nint X[1000010], Y[1000010];\nP dp[3000][3000];\n\nvector<int> prime;\n\nvoid PrimeTable(int N){\n    prime = vector<int>(N+1, 1);\n    prime[0] = 0;\n    prime[1] = 0;\n\n    for(int i=2; i*i<=N; ++i){\n        if(prime[i]){\n            for(int j=2; i*j<=N; ++j){\n                prime[i*j] = 0;\n            }\n        }\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int now = 1, dir = 0, diff = 1;\n    int x=1500, y=1500;\n    a[1500][1500] = 1;\n    X[1] = 1500, Y[1] = 1500;\n    while(now <= 1000000){\n        switch(dir){\n        case 0:\n            FOR(dx, 1, diff+1){\n                a[y][x+dx] = ++now;\n                X[now] = x+dx;\n                Y[now] = y;\n            }\n            x = x+diff;\n            break;\n        case 1:\n            FOR(dy, 1, diff+1){\n                a[y-dy][x] = ++now;\n                X[now] = x;\n                Y[now] = y-dy;\n            }\n            y = y-diff;\n            break;\n        case 2:\n            FOR(dx, 1, diff+1){\n                a[y][x-dx] = ++now;\n                X[now] = x-dx;\n                Y[now] = y;\n            }\n            x = x-diff;\n            break;\n        case 3:\n            FOR(dy, 1, diff+1){\n                a[y+dy][x] = ++now;\n                X[now] = x;\n                Y[now] = y+dy;\n            }\n            y = y+diff;\n            break;\n        }\n        if(dir%2) diff++;\n        dir = (dir+1)%4;\n    }\n\n    // REP(i, 20){\n    //     REP(j, 20){\n    //         printf(\"%03d \", a[1490+i][1490+j]);\n    //     }\n    //     printf(\"\\n\");\n    // }\n    int m, n;\n    cin >> m >> n;\n    PrimeTable(1000010);\n    while(!(m==0 && n==0)){\n        REP(i, 3000)REP(j, 3000) dp[i][j] = mp(-1, 0);\n        int ny = Y[n], nx = X[n];\n        dp[ny][nx] = mp(prime[n], prime[n] ? n : 0);\n        bool f = true;\n        vector<int> shiftX{0};\n        vector<int> downX{-1, 0, 1};\n        int down = 0;\n        while(f){\n            f = false;\n            for(auto sx : shiftX){\n                for(auto dx : downX){\n                    if(dp[ny+1][nx+sx+dx].fi <= dp[ny][nx+sx].fi){\n                        dp[ny+1][nx+sx+dx].fi = dp[ny][nx+sx].fi+prime[a[ny+1][nx+sx+dx]];\n                        if(prime[a[ny+1][nx+sx+dx]]) dp[ny+1][nx+sx+dx].se = max(a[ny+1][nx+sx+dx], dp[ny][nx+sx].se);\n                        else{\n                            if(dp[ny+1][nx+sx+dx].fi < dp[ny][nx+sx].fi) dp[ny+1][nx+sx+dx].se = dp[ny][nx+sx].se;\n                            else chmax(dp[ny+1][nx+sx+dx].se, dp[ny][nx+sx].se);\n                        }\n                    }else if(dp[ny+1][nx+sx+dx].fi == dp[ny][nx+sx].fi+prime[a[ny+1][nx+sx+dx]]){\n                        dp[ny+1][nx+sx+dx].se = a[ny+1][nx+sx+dx];\n                    }\n                    if(0 < a[ny+1][nx+sx+dx] && a[ny+1][nx+sx+dx] <= m) f = true;\n                    else dp[ny+1][nx+sx+dx].fi = -1;\n                }\n            }\n            \n            if(down < 1000){\n                down++;\n                shiftX.pb(down);\n                shiftX.pb(-down);\n            }\n            // sort(All(shiftX));\n            // for(auto sx : shiftX){\n            //     cout << dp[ny+1][nx+sx]  << \" \";\n            // }\n            // cout << \"\\n\";\n            ny++;\n        }\n        P ans = mp(0, 0);\n        REP(i, 3000) chmax(ans, dp[ny-2][i]);\n        REP(i, 3000) chmax(ans, dp[ny-1][i]);\n        cout << ans.fi << \" \" << ans.se << \"\\n\";\n\n        cin >> m >> n;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <utility>\n#include <vector>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\nusing P = pair<int, int>;\nusing QP = pair<int, int>;  // (テゥツ?づァツつケ, テ・ツ?、)\nusing dp1P = P;\n\nconst int MAX_M = 1000010;\n\nbool prime_table[MAX_M];\nmap<P, int> cave;\nmap<int, P> num2pos;\n\nint dp1[MAX_M],\n    dp2[MAX_M];\n\nint dy[4] = {0, 1, 0, -1},\n    dx[4] = {1, 0, -1, 0};\n\nvoid sieve() {\n    for (int i = 2; i < MAX_M; i++) {\n        prime_table[i] = true;\n    }\n    for (int m = 2; m * m <= MAX_M; m++) {\n        if (prime_table[m]) {\n            for (int i = 2; i * m < MAX_M; i++) {\n                prime_table[i * m] = false;\n            }\n        }\n    }\n}\n\nint main() {\n    // テヲツエツ榲ァツェツ淌」ツ?ョテヲツァツ凝ァツッツ?\n    int num = 1, x = 0, y = 0, dir = 3;\n    cave[P(x, y)] = num;\n    num2pos[num] = P(x, y);\n    num++;\n\n    for (int i = 0; i < MAX_M - 5; i++) {\n        int ndir = (dir + 1) % 4,\n            nx = x + dx[ndir],\n            ny = y + dy[ndir];\n        // テ・ツ?・テ」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝」ツ?凝・ツ青ヲテ」ツ??\n        if (cave.count(P(nx, ny)) == 0) {\n            x = nx;\n            y = ny;\n            dir = ndir;\n        } else {\n            x = x + dx[dir],\n            y = y + dy[dir];\n        }\n        cave[P(x, y)] = num;\n        num2pos[num] = P(x, y);\n        num++;\n    }\n\n    sieve();\n\n    int m, n;\n    while (cin >> m >> n, m | n) {\n        memset(dp1, -1, sizeof(dp1));\n\n        queue<P> que;\n        que.push(QP(n, prime_table[n]));\n        dp1[n] = prime_table[n];\n        dp2[n] = prime_table[n] ? n : 0;\n        while (!que.empty()) {\n            auto qp = que.front(); que.pop();\n            if (dp1[qp.first] > qp.second) continue;\n\n            P pos = num2pos[qp.first];\n            for (int ddx = -1; ddx <= 1; ddx++) {\n                int nx = pos.first + ddx,\n                    ny = pos.second - 1;\n                if (cave.count(P(nx, ny)) == 0 || cave[P(nx, ny)] > m) continue;\n                int nnum = cave[P(nx, ny)],\n                    prime_num = dp1[qp.first] + (prime_table[nnum]);\n                if (dp1[nnum] < prime_num) {\n                    dp1[nnum] = prime_num;\n                    dp2[nnum] = dp1[qp.first];\n\n                    if (prime_table[nnum]) dp2[nnum] = nnum;\n\n                    que.push(QP(nnum, dp1[nnum]));\n                } else if (dp1[nnum] == prime_num && dp2[nnum] < dp2[qp.first]) {\n                    dp2[nnum] = dp2[qp.first];\n\n                    if (prime_table[nnum]) dp2[nnum] = nnum;\n                }\n            }\n        }\n        int prime_num = 0, last_prime = 0;\n        for (int i = 1; i <= m; i++) {\n            if (prime_num < dp1[i]) {\n                prime_num = dp1[i];\n                last_prime = dp2[i];\n            } else if (prime_num == dp1[i] && last_prime < dp2[i]) {\n                prime_num = dp1[i];\n                last_prime = dp2[i];\n            }\n        }\n        cout << prime_num << \" \" << last_prime << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t\n\t\toutput = false;\n\t\tfor (int h = 0;h < SIZE && (!output);h++) {\n\t\t\tfor (int w = 0;w < SIZE && (!output);w++) {\n\t\t\t\tif (table[h][w] == n) {\n\t\t\t\t\t//printf(\"%d %d\\n\", dp[i][j], pr[i][j]);\n\t\t\t\t\tcout << dp[h][w] << endl;\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<algorithm>\nusing namespace std;\nbool isp[1<<20];\nint map[2000][2000];\npair<int,int>where[1<<20];\nint dx[]={0,-1,0,1},dy[]={1,0,-1,0};\nmain()\n{\n\tfor(int i=2;i<1<<20;i++)isp[i]=1;\n\tfor(int i=2;i<1<<20;i++)\n\t{\n\t\tif(isp[i])\n\t\t{\n\t\t\tfor(int j=i+i;j<1<<20;j+=i)isp[j]=0;\n\t\t}\n\t}\n\tint dir=0,cnt=0,maxcnt=1;\n\tpair<int,int>p=make_pair(1000,1000);\n\tfor(int i=1;i<1<<20;i++)\n\t{\n\t\twhere[i]=p;\n\t\tmap[p.first][p.second]=i;\n\t\tif(maxcnt==cnt)\n\t\t{\n\t\t\tcnt=0;\n\t\t\tdir=(dir+1)%4;\n\t\t\tif(dir%2==0)maxcnt++;\n\t\t}\n\t\tp.first+=dx[dir];\n\t\tp.second+=dy[dir];\n\t\tcnt++;\n\t}\n\tint m,n;\n\twhile(cin>>m>>n,m)\n\t{\n\t\tpair<int,int>next[2000],now[2000],ans;\n\t\tfor(int i=0;i<2000;i++)now[i]=make_pair(0,-1);\n\t\tint y=where[n].first;\n\t\tnow[where[n].second]=ans=isp[n]?make_pair(1,n):make_pair(0,0);\n\t\tbool flag=true;\n\t\twhile(flag)\n\t\t{\n\t\t\tflag=false;\n\t\t\tfor(int i=0;i<2000;i++)next[i]=make_pair(0,-1);\n\t\t\ty++;\n\t\t\tfor(int i=0;i<2000;i++)\n\t\t\t{\n\t\t\t\tif(now[i].second<0)continue;\n\t\t\t\tfor(int j=-1;j<=1;j++)\n\t\t\t\t{\n\t\t\t\t\tif(map[y][i+j]>0&&map[y][i+j]<m)\n\t\t\t\t\t{\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\tpair<int,int>p=now[i];\n\t\t\t\t\t\tif(isp[map[y][i+j]])p.second=map[y][i+j],p.first++;\n\t\t\t\t\t\tnext[i+j]=max(next[i+j],p);\n\t\t\t\t\t\tans=max(ans,p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(now,next);\n\t\t}\n\t\tcout<<ans.first<<\" \"<<ans.second<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define MAX_N 1000000\n#define MAX_X 1000\n#define MAX_Y 1000\n\nint cave[MAX_Y][MAX_X];\nbool sieve[MAX_N+1];\nint dp[MAX_N+1];\n\nint m, n;\n\nstruct P { int x, y; };\n\nP search_cave(int n) {\n    REP(y, MAX_Y) REP(x, MAX_X) {\n        if (cave[y][x] == n) {\n            return (P){x, y};\n        }\n    }\n    return (P){0, 0}; // fail\n}\n\nint main() {\n    sieve[0] = sieve[1] = true;\n    FOR(i, 2, MAX_N+1) {\n        if (sieve[i]) continue;\n        for (int j = i + i; j < MAX_N+1; j += i) {\n            sieve[j] = true;\n        }\n    }\n\n    int ul = cave[0][0] = MAX_N;\n    // left -> down -> right -> up ->\n    int d = 0;\n    int dx[] = {1, 0, -1, 0}; int dy[] = {0, 1, 0, -1};\n    int x = 0, y = 0;\n    while (ul > 1) {\n        int sx = x + dx[d];\n        int sy = y + dy[d];\n        if (0 <= sx && sx < MAX_X && 0 <= sy && sy < MAX_Y && cave[sy][sx] == 0) {\n            x = sx;\n            y = sy;\n            ul--;\n            cave[y][x] = ul;\n        } else {\n            d = (d + 1) & 3; // d % 4\n        }\n    }\n\n    while (cin >> m >> n, m|n) {\n        fill_n(dp, MAX_N+1, -1);\n        P s = search_cave(n);\n        dp[n] = 0;\n        int max_primes = 0, max_cave = 0;\n        FOR(y, s.y, MAX_Y) REP(x, MAX_X) {\n            int c = cave[y][x];\n            if (c > m || dp[c] < 0) continue;\n            if (!sieve[c]) { // prime\n                dp[c]++;\n                if (max_primes <= dp[c]) {\n                    max_primes = dp[c];\n                    max_cave = c;\n                }\n            }\n            for (int dx = -1; dx <= 1; dx++) {\n                int sx = x + dx;\n                int sy = y + 1;\n                if (0 <= sx && sx < MAX_X && 0 <= sy && sy < MAX_Y) {\n                    int c2 = cave[sy][sx];\n                    if (c2 <= m) {\n                        dp[c2] = max(dp[c2], dp[c]);\n                    }\n                }\n            }\n        }\n        cout << max_primes << \" \" << max_cave << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\n#define SIZE 1000\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\t\t/*\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}*/\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}/*\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}*/\n\t\t\n\t\toutput = false;\n\t\tfor (int i = 0;i < SIZE&&(!output);i++) {\n\t\t\tfor (int j = 0;j < SIZE&&(!output);j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tprintf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\n#define MP make_pair\n#define PB push_back\n#define MAX_N 1000000\n#define X first\n#define Y second\n\nconst int STX = 505, STY = 505;\n\nint id[2010][2010];\nbool is_prime[MAX_N+1];\nvector<pair<int, int> > coord;\n\nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++) {\n    if(is_prime[i]) {\n      for(int j=i*i; j<=MAX_N; j+=i) {\n\tis_prime[j] = false;\n      }\n    }\n  }\n}\n\nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  /*\n  const int dx[] = {1,0,-1,0};\n  const int dy[] = {0,-1,0,1};\n  */\n  coord.PB(MP(0, 0)); // no use\n  coord.PB(MP(x, y)); // cnt = 1\n  cnt ++;\n\n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt <= MAX_N+20000) {\n    a += 2;\n    for(int i=0; i<a; i++) {\n      y --;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      x --;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      y ++;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      x ++;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    x++, y++;\n  }\n  /*\n  for(int i=1; ; i++) {\n    if(i%4 == 0) x--;\n    \n    // marking\n    for(int j=0; j<(i/4+1)*2; j++) {\n      x += dx[i%4], y += dy[i%4];\n      cout << x << \",\" << y;// << endl;\n      id[y][x] = ++ cnt; cout << \" \" << cnt << endl;\n      coord.PB(MP(x, y));\n      if(cnt == 50) return;\n    }\n  }\n  */\n}\n\nint dp[MAX_N+1];\n\nint main() {\n  \n  Sieve();\n  MakeMap();\n  \n  int m, n;\n  \n  while(cin >> m >> n && (m|n)) {\n    fill(dp, dp+MAX_N+1, -1);\n    dp[n] = is_prime[n];\n    \n    queue<pair<int, int> > que;\n    que.push(coord[n]);\n    \n    while(!que.empty()) {\n      pair<int, int> now = que.front(); que.pop();\n      int noid = id[now.Y][now.X];\n      \n      for(int i=-1; i<=1; i++) {\n\tpair<int, int> nex = MP(now.X+i, now.Y+1);\n\t\n\tint neid = id[nex.Y][nex.X];\n\tif(neid <= m) {\n\t  if(dp[neid] < dp[noid] + is_prime[neid]) {\n\t    dp[neid] = dp[noid] + is_prime[neid];\n\t    que.push(nex);\n\t  }\n\t}\n      }\n    }\n    \n    int res = dp[n], lastid;\n    if(is_prime[n]) lastid = n;\n    else lastid = -1;\n    \n    for(int i=1; i<=m; i++) {\n      if(res <= dp[i] && is_prime[i]) {\n\tres = dp[i];\n\tlastid = max(lastid, i);\n      }\n    }\n    \n    if(res == 0) cout << \"0 0\" << endl;\n    else cout << res << \" \" << lastid << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\n#define N 1050\nusing namespace std;\nint dat[N][N],dp[N][N],ans,ans2;\nint m,n,y,x,p,k,sy,sx,check[N][N];\nint ymin,ymax,xmin,xmax;\nbool prime[N*N];\n\nint main(){\n  int dy[4]={0,-1,0,1};\n  int dx[4]={1,0,-1,0};\n  for(int i=0;i<N*N;i++)prime[i]=true;\n  prime[0]=prime[1]=false;\n  for(int i=0;i<=N*N/2;i++){\n    if(!prime[i])continue;\n    for(int j=i+i;j<N*N;j+=i)prime[j]=false;\n  }\n  while(1){\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)dat[i][j]=-1,dp[i][j]=check[i][j]=0;\n    cin>>m>>n;\n    if(!m&&!n)break;\n    sy=sx=y=x=N/2;\n    dat[y][x]=1;\n    k=ymax=xmax=0,p=1;\n    ymin=xmin=INF;\n    while(p<m){\n      p++;\n      int lot=(k+1)%4;\n      if(p!=2&&dat[y+dy[lot]][x+dx[lot]]<0)k=lot;\n      y+=dy[k];\n      x+=dx[k];\n      dat[y][x]=p;\n      ymin=min(ymin,y);\n      xmin=min(xmin,x);\n      ymax=max(ymax,y);\n      xmax=max(xmax,x);\n      if(p==n)sy=y,sx=x;\n    }\n    check[sy][sx]=1;\n    for(int i=ymin;i<=ymax;i++)\n      for(int j=xmin;j<=xmax;j++){\n\tif(!check[i][j])continue;\n\tcheck[i+1][j-1]=check[i+1][j]=check[i+1][j+1]=1;\n      }\n    ans=0;\n    for(int i=ymin;i<=ymax;i++){\n      for(int j=xmin;j<=xmax;j++){\n\tif(dat[i][j]<0||!check[i][j])continue;\n\tif(prime[dat[i][j]])dp[i][j]++;\n\tans=max(ans,dp[i][j]);\n\tdp[i+1][j-1]=max(dp[i+1][j-1],dp[i][j]);\n\tdp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n\tdp[i+1][j+1]=max(dp[i+1][j+1],dp[i][j]);\n      }\n    }\n    ans2=0;\n    for(int i=ymin;i<=ymax;i++){\n      for(int j=xmin;j<=xmax;j++){\n\tif(prime[dat[i][j]]&&check[i][j]&&ans==dp[i][j])ans2=max(ans2,dat[i][j]);\n      }\n    }\n    if(ans!=0)cout<<ans<<' '<<ans2<<endl;\n    else cout<<0<<' '<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define f first\n#define s second\ntypedef pair<int,int> P;\nint a[2000][2000],ans[2000][2000],d=0,y=999,x=1001,n,m;\nbool b[1000001],used[2000][2000];\nint dx[]={-1,0,1,0},tx[]={-1,0,1};\nint dy[]={0,1,0,-1},ty[]={1,1,1};\nint main(){\n  b[0]=b[1]=1;\n  for(int i=2;i<1000001;i++)\n    for(int j=i+i;j<1000001;j+=i)b[j]=1;\n  a[1000][1000]=1;\n  a[1000][1001]=2;\n  a[999][1001]=3;\n  for(int i=4;i<1000001;i++){\n    int yy=y+dy[d],xx=x+dx[d];\n    int ya=yy+dy[(d+1)%4],xa=xx+dx[(d+1)%4];\n    if(!a[ya][xa])d=(d+1)%4;\n    a[yy][xx]=i;\n    y=yy,x=xx;\n  }\n  while(cin>>n>>m,n){\n    memset(ans,0,sizeof(ans));\n    memset(used,0,sizeof(used));\n    r(i,2000)r(j,2000)if(a[i][j]==m){\n      used[i][j]=1;y=i;\n      break;\n    }\n    for(int i=y;i<2000;i++)r(j,2000)if(a[i][j]&&used[i][j]){\n      if(!b[a[i][j]])ans[i][j]++;\n      r(k,3){\n        y=i+ty[k],x=j+tx[k];\n        if(!a[y][x]||a[y][x]>n)continue;\n        ans[y][x]=max(ans[y][x],ans[i][j]);\n        used[y][x]=1;\n      }\n    }\n    int a1=0,a2;\n    r(i,2000)r(j,2000)if(a[i][j]<=n)if(a1<ans[i][j]||a1==ans[i][j]&&a2<a[i][j]){\n      a1=ans[i][j],a2=a[i][j];\n    }\n    if(!a1)cout<<\"0 0\"<<endl;\n    else cout<<a1<<' '<<a2<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n#define t_max 10000001\nchar M[1001][1001];\nunsigned short S[1001][1001];\nint P[1001][1001];\nint table[t_max];\nvector<pair<int,int> >m(t_max);\nmap<pair<int,int>,int>m_rev;\npair<int,int> dfs(int x,int y){\n\tif(y==1001)return make_pair(0,0);\n\tif(S[x][y]>=0)return make_pair(S[x][y],P[x][y]);\n\tint m=0,m_place=0,i=-1;\n\tfor(;i<2;i++){\n\t\tif(x+i<0||1000<x+i)continue;\n\t\tpair<int,int> p=dfs(x+i,y+1);\n\t\tif(m<p.first||(m==p.first&&m_place<p.second))m=p.first,m_place=p.second;\n\t}\n\tif(m==0){\n\t\tif(M[x][y])return make_pair(S[x][y]=1,P[x][y]=m_rev[make_pair(x,y)]);\n\t\treturn make_pair(S[x][y]=0,P[x][y]=0);\n\t}else{\n\t\treturn make_pair(S[x][y]=m+M[x][y],P[x][y]=m_place);\n\t}\n}\nmain(){\n\tint k=1,z,x,y,i,n,s;\n\tm[k]=make_pair(x=500,y=500),m_rev[make_pair(x,y)]=k,k++;\n\tfor(z=2;z<=1000;z+=2){\n\t\tx++,y++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(x,--y),m_rev[make_pair(x,y)]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(--x,y),m_rev[make_pair(x,y)]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(x,++y),m_rev[make_pair(x,y)]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(++x,y),m_rev[make_pair(x,y)]=k,k++;\n\t}\n\ttable[0]=table[1]=1;\n\tfor(x=2;x<t_max;x++)if(!table[x])for(y=x*2;y<t_max;y+=x)table[y]=1;\n\tfor(;scanf(\"%d%d\",&n,&s),n;){\n\t\tmemset(M,0,sizeof(M));\n\t\tmemset(S,0xff,sizeof(S));\n\t\tmemset(P,0,sizeof(P));\n\t\tfor(i=1;i<=n;i++)if(!table[i])M[m[i].first][m[i].second]=1;\n\t\tpair<int,int> p=dfs(m[s].first,m[s].second);\n\t\tprintf(\"%d %d\\n\",p.first,p.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1500\n#define LIMIT 1001000\ntypedef pair<int,int> pii;\n\nint M,N;\nint caves[MAX][MAX];\nint dp[MAX][MAX];\nmap<int,pii> mp;\nbool prime[LIMIT];\n\nconst int dx[4] = {1,0,-1,0};\nconst int dy[4] = {0,-1,0,1};\n\nvoid makePrime(){\n  fill(prime,prime+LIMIT,true);\n  prime[0] = prime[1] = false;\n  for(int i = 2 ; i*i < LIMIT ; i++){\n    if(prime[i]){\n      for(int j = i*2 ; j < LIMIT ; j+=i){\n        prime[j] = false;\n      }\n    }\n  }\n}\n\nvoid makeCaves(){\n  int x = 510,y = 510,dir = 0;\n  int num = 1,cnt = 1;\n  while(true){\n    if(cnt == LIMIT) break;\n    for(int i = 0 ; i < 2 ; i++){\n      for(int j = 0 ; j < num ; j++){\n        mp[cnt] = pii(y,x);\n        caves[y][x] = cnt++;\n        if(cnt == LIMIT){\n          return;\n        }\n        x += dx[dir];\n        y += dy[dir];\n      }\n      dir = (dir+1)%4;   \n    }\n    num++;\n  }\n}\n\nvoid solve(int sx,int sy){\n  dp[sy][sx] = prime[caves[sy][sx]];\n  for(int i = 0 ; i < MAX-1 ; i++){\n    for(int j = 0 ; j < MAX ; j++){\n      if(dp[i][j] >= 0 && caves[i][j] <= M){\n        if(caves[i+1][j-1] <= M){\n          dp[i+1][j-1] = max(dp[i+1][j-1],dp[i][j]+prime[caves[i+1][j-1]]); \n        }\n        if(caves[i+1][j] <= M){\n          dp[i+1][j] = max(dp[i+1][j],dp[i][j]+prime[caves[i+1][j]]); \n        }\n        if(caves[i+1][j+1] <= M){\n          dp[i+1][j+1] = max(dp[i+1][j+1],dp[i][j]+prime[caves[i+1][j+1]]); \n        }\n      }\n    }\n  }\n  int res = 0, num = 0;\n  for(int i = 0 ; i < MAX ; i++){\n    for(int j = 0 ; j < MAX ; j++){\n      if(caves[i][j] <= M && prime[caves[i][j]]){\n        if(res <= dp[i][j]){\n          res = dp[i][j];\n          num = caves[i][j];\n        }\n      }\n    }\n  }\n  cout << res << \" \" << num << endl;\n}\n\nint main(){\n  makeCaves();\n  makePrime();\n  while(cin >> M >> N, M){\n    pii src = mp[N];\n    memset(dp,-1,sizeof(dp));\n    solve(src.second,src.first);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 60) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint n, m;\nint f[2000][2000];\nint dp[2000][2000];\nint fdp[2000][2000];\nbool F[2000][2000];\n\nint posx[1000010];\nint posy[1000010];\n\nint dx[] = { 1,0,-1,0 };\nint dy[] = { 0,-1,0,1 };\n\nvector<int> prime;\nbool is_prime[1000010 + 1];\n\nint sieve(int n) {//n??\\???????´???°?????°?????????\n\tint p = 0;\n\tfor (int i = 0; i <= n; i++)is_prime[i] = 1;\n\tis_prime[0] = is_prime[1] = 0;\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (is_prime[i]) {\n\t\t\tprime.push_back(i);\n\t\t\tfor (int j = 2 * i; j <= n; j += i)is_prime[j] = 0;\n\t\t}\n\t}\n\treturn p;\n}\n\nint ddx[] = { 1,0,-1 };\n\nint main() {\n\tsieve(1000010);\n\tll y = 1000, x = 1000;\n\tint num = 1;\n\tint cnt = 1;\n\tint k = cnt;\n\tint dir = 0;\n\twhile (num <= 1000000) {\n\t\tf[y][x] = num;\n\t\tposy[num] = y;\n\t\tposx[num] = x;\n\t\tnum++;\n\t\tx += dx[dir], y += dy[dir];\n\t\tk--;\n\t\tif (k == 0) {\n\t\t\tdir = (dir + 1) % 4;\n\t\t\tif (dir % 2 == 0)cnt++;\n\t\t\tk = cnt;\n\t\t}\n\t}\n\n\twhile (cin >> m >> n&&n + m) {\n\t\trep(i, 2000)rep(j, 2000) {\n\t\t\tF[i][j] = 0;\n\t\t\tif (is_prime[f[i][j]]) {\n\t\t\t\tdp[i][j] = 1;\n\t\t\t\tfdp[i][j] = f[i][j];\n\t\t\t}\n\t\t\telse dp[i][j] = 0;\n\t\t}\n\t\tif (is_prime[f[posy[n]][posx[n]]]) {\n\t\t\tdp[posy[n]][posx[n]] = 1;\n\t\t\tfdp[posy[n]][posx[n]] = n;\n\t\t\tF[posy[n]][posx[n]] = 1;\n\t\t}\n\t\tint it = 1;\n\t\tFOR(i, posy[n] + 1, 2000) {\n\t\t\tFOR(j, max(0, posx[n] - it), min(2000, posx[n] + it + 1)) {\n\t\t\t\tint MAX = 0;\n\t\t\t\trep(k, 3) {\n\t\t\t\t\tint ny = i - 1, nx = j + ddx[k];\n\t\t\t\t\tif (nx >= 0 && nx < 2000) {\n\t\t\t\t\t\tif (f[ny][nx] <= m&&abs(nx - posx[n]) <= abs(ny - posy[n])) {\n\t\t\t\t\t\t\tMAX = max(MAX, dp[ny][nx]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp[i][j] += MAX;\n\t\t\t\tF[i][j] = 1;\n\t\t\t}\n\t\t\tit++;\n\t\t}\n\n\t\tint ans[2] = {};\n\t\trep(i, 2000) {\n\t\t\trep(j, 2000) {\n\t\t\t\tif (f[i][j] > m || f[i][j] == 0 || F[i][j] == 0)continue;\n\t\t\t\tif (ans[0] < dp[i][j]) {\n\t\t\t\t\tans[0] = dp[i][j];\n\t\t\t\t\tans[1] = fdp[i][j];\n\t\t\t\t}\n\t\t\t\telse if (ans[0] == dp[i][j]) {\n\t\t\t\t\tans[1] = max(ans[1], fdp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans[0] << \" \";\n\t\tif (ans[0] == 0)cout << 0 << endl;\n\t\telse cout << ans[1] << endl;\n\t}\n}\n\n//if(is_prime[n])dp[posy[n]][posx[n]] = 1;\n//for (int i = -20; i <= 20; i++) {\n//\tfor (int j = -20; j <= 20; j++) {\n//\t\tif (is_prime[f[1000 + i][1000 + j]])cout << \"!\";\n//\t\telse cout << \" \";\n//\t\tprintf(\"%4d\", f[1000 + i][1000 + j]);\n//\t\tprintf(\"%4d\", dp[1000 + i][1000 + j]);\n//\t}\n//\tcout << endl;\n//}\n\n//for (int i = -3; i <= 3; i++) {\n//\tfor (int j = -3; j <= 3; j++) {\n//\t\tprintf(\"%3d\", fdp[1000 + i][1000 + j]);\n//\t}\n//\tcout << endl;\n//}\n//cout << endl;\n//for (int i = -3; i <= 3; i++) {\n//\tfor (int j = -3; j <= 3; j++) {\n//\t\tprintf(\"%3d\", dp[1000 + i][1000 + j]);\n//\t}\n//\tcout << endl;\n//}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, m, r[1000][1000], dp1[1000][1000], dp2[1000][1000]; bool isprime[1000001];\nconst int dx[4] = { -1, 0, 1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\nint main() {\n\tisprime[1] = false;\n\tfor (int i = 2; i <= 1000000; i++) isprime[i] = true;\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tif (isprime[i]) {\n\t\t\tfor (int j = i + i; j <= 1000000; j += i) {\n\t\t\t\tisprime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n == 0 && m == 0) break;\n\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\t\tdp1[i][j] = -1, dp2[i][j] = -1, r[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tint c = 2, d = 0, x = 499, y = 500;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tr[y][x] = i; d++;\n\t\t\tx += dx[c % 4];\n\t\t\ty += dy[c % 4];\n\t\t\tif (d == c / 2) c++, d = 0;\n\t\t}\n\t\tint sx, sy;\n\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\t\tif (r[i][j] == m) sx = j, sy = i;\n\t\t\t}\n\t\t}\n\t\tdp1[sy][sx] = isprime[m] ? 1 : 0, dp2[sy][sx] = isprime[m] ? m : 0;\n\t\tint res1 = 0, res2 = 0;\n\t\tfor (int i = 1; i < 1000; i++) {\n\t\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\t\tif (r[i][j] == -1) continue;\n\t\t\t\tint s1 = -1, s2 = -1;\n\t\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\t\tif (0 <= j + k && j + k < 1000) {\n\t\t\t\t\t\tif (dp1[i - 1][j + k] != -1) {\n\t\t\t\t\t\t\tif (isprime[r[i][j]]) {\n\t\t\t\t\t\t\t\ts2 = r[i][j];\n\t\t\t\t\t\t\t\ts1 = max(s1, dp1[i - 1][j + k] + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\ts1 = max(s1, dp1[i - 1][j + k]);\n\t\t\t\t\t\t\t\ts2 = max(s2, dp2[i - 1][j + k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (j == sx && i == sy) continue;\n\t\t\t\tif (s1 != -1) {\n\t\t\t\t\tdp1[i][j] = s1;\n\t\t\t\t\tdp2[i][j] = s2;\n\t\t\t\t\tif (res1 < s1) {\n\t\t\t\t\t\tres1 = s1;\n\t\t\t\t\t\tres2 = s2;\n\t\t\t\t\t}\n\t\t\t\t\telse if (res1 == s1 && res2 < s2) {\n\t\t\t\t\t\tres2 = s2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", res1, res2);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t\n\t\toutput = false;\n\t\tfor (int i = 0;i < SIZE && (!output);i++) {\n\t\t\tfor (int j = 0;j < SIZE && (!output);j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\t//printf(\"%d %d\\n\", dp[i][j], pr[i][j]);\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int dx[4] = {0, 1, 0, -1};\nconst int dy[4] = {1, 0, -1, 0};\n \nconst int MAX_SIZE = 1010;\nconst int HALF = MAX_SIZE / 2;\nconst int MAX_M = 1000000;\n \nint field[MAX_SIZE][MAX_SIZE];\npair<int, int> dp[MAX_SIZE][MAX_SIZE];\nbool is_prime[MAX_M + 1];\n\ninline void sieve(int n) {\n\tfill(is_prime, is_prime + n, true);\n    is_prime[0] = is_prime[1] = false;\n    for(int i = 2; i < n; ++i) {\n        if(is_prime[i]) {\n            for(long long j = static_cast<long long>(i) * i; j < n; j += i)\n                is_prime[j] = false;\n        }\n    }\n}\n \ninline void make_field() {\n    const int INF = 0xfffffff;\n    fill(field[0], field[0] + MAX_SIZE * MAX_SIZE, INF);\n\n\tint x = HALF, y = HALF, d = 0;\n    for(int num = 1; num <= MAX_M; ++num) {\n        field[y][x] = num;\n        const int left = (d + 1) % 4;\n        if(field[y + dy[left]][x + dx[left]] == INF)\n            d = left;\n \n        x += dx[d];\n        y += dy[d];\n    }\n}\n\ninline pair<int, int> solve(const int &m, const int &n) {\n\tint x, y;\n\tint min_x = MAX_SIZE, max_x = -1, max_y = -1;\n\tfor(int i = 0; i < MAX_SIZE; ++i) {\n\t\tfor(int j = 0; j < MAX_SIZE; ++j) {\n\t\t\tif(field[i][j] <= m) {\n\t\t\t\tmin_x = min(min_x, j);\n\t\t\t\tmax_x = max(max_x, j);\n\t\t\t\tmax_y = max(max_y, i);\n \n\t\t\t\tif(field[i][j] == n) {\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n \n\tfill(dp[y], dp[y] + (max_y - y + 1) * MAX_SIZE, pair<int, int>(-1, -1));\n\tdp[y][x] = make_pair(0, 0);\n\tfor(; y <= max_y; ++y) {\n\t\tfor(; x <= max_x; ++x) {\n\t\t\tconst int num = field[y][x];\n\t\t\tif(num > m || dp[y][x].first == -1)\n\t\t\t\tcontinue;\n \n\t\t\tif(is_prime[num]) {\n\t\t\t\t++dp[y][x].first;\n\t\t\t\tdp[y][x].second = num;\n\t\t\t}\n \n\t\t\tfor(int k = -1; k <= 1; ++k) {\n\t\t\t\tdp[y + 1][x + k] = max(dp[y + 1][x + k], dp[y][x]);\n\t\t\t}\n\t\t}\n\t\tx = min_x;\n\t}\n\n\treturn *max_element(dp[max_y] + min_x, dp[max_y] + max_x + 1);\n}\n \nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n\tsieve(MAX_M + 1);\n    make_field();\n \n    for(int m, n; cin >> m >> n && m;) {\n\t\tconst pair<int, int> ans = solve(m, n);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n    }\n \n    return EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define SIZE 1000\n\nbool C(int dp1, int pr1, int dp2, int pr2) {\n\tif (dp2 == 0)return false;\n\tif (dp1 < dp2 || (dp1 == dp2&&pr1 < pr2))return true;\n\treturn false;\n}\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m && x >= 0 && y >= 0) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x - 1], pr[y + 1][x - 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x], pr[y + 1][x])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x + 1], pr[y + 1][x + 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\n\t\toutput = false;\n\t\tfor (int i = 0;i < SIZE&&!output;i++) {\n\t\t\tfor (int j = 0;j < SIZE&&!output;j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tprintf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n\n#define FMAX 1000006\n\nusing namespace std;\n\n\nint pos[2]={500,500};\nvoid toXY(int i, int &p_num, int &x, int &y){\n\tint pp_num = p_num*p_num;\n\twhile( i > pp_num ){\n\t\tpos[0]++; pos[1]++;\n\t\tp_num+=2;\n\t\tpp_num = p_num*p_num;\n\t}\n\tif( pp_num - p_num < i ){\n\t\tx = pos[0] - pp_num + i;\n\t\ty = pos[1];\n\t}else if( pp_num - 2*(p_num-1) <= i ){\n\t\tx = pos[0] - p_num + 1;\n\t\ty = pos[1] - (pp_num - i - p_num + 1 );\n\t}else if( pp_num - 3*(p_num-1) <= i ){\n\t\tx = pos[0] + (pp_num - 3*(p_num-1) - i );\n\t\ty = pos[1] - p_num + 1;\n\t}else{\n\t\tx = pos[0];\n\t\ty = pos[1] + (pp_num - 4*(p_num-1) - i );\n\t}\n\t//cout << \"i=\" << i << \" x=\" << x << \" y=\" << y << endl;\n}\n\nint toNum(int x, int y){\n\tint r = max(abs(x-500), abs(y-500) );\n\tif( r == 0 ) return 1;\n\tint n = 1 + 2*r;\n//\tcout << x << \" \" << y << \" n=\" << n << endl;\n\tint ret = n*n;\n\tif( 500+r == x && 500+r == y ){\n\t}else if( 500+r == x ){\n\t\tret = (n-2)*(n-2) + 500+r - y;\n\t}else if( 500-r == y ){\n\t\tret -= 2*(n-1) + x - (500-r);\n\t}else if( 500-r == x ){\n\t\tret -= n-1 + 500+r - y;\n\t}else if( 500+r == y ){\n\t\tret -= 500+r - x;\n\t}\n\treturn ret;\n}\n\nbool dou[1005][1005]={0};\nint dp[1005][1005], ans[1005][2]={0};\n\nint main(){\n\tint m, n;\n\tbool f[FMAX]={0};\n\tint p_num=1;\n\n\tfill(f, f+FMAX, true);\n\tf[0]=false;f[0]=false;\n\tfor(int i=2; i<FMAX; i++){\n\t\tif( f[i] ){\n\t\t\tfor(int j=i*2; j<FMAX; j+=i ){\n\t\t\t\tf[j] = false;\n\t\t\t}\n\t\t\tint x, y;\n\t\t\ttoXY(i, p_num, x, y);\n\t\t\tdou[x][y] = true;\n\t\t}\n\t}\n\n\twhile(1){\n\t\tcin >> m >> n;\n\t\tif( !(m | n) )\n\t\t\tbreak;\n\t\t\n\t\tint x, y;\n\t\tfill( dp[0], dp[0]+1005*1005, -1 );\n\t\tfill( ans[0], ans[0]+1005*2, 0 );\n\t\tp_num = 1; pos[0]=500; pos[1]=500;\n\t\ttoXY(n, p_num, x, y);\n\t//\tcout << \"toXY = \" << x << \" \" << y << endl;\n\t\tdp[x][y] = dou[x][y];\n\t\tif(dou[x][y]){\n\t\t\tans[x][0]=1;\n\t\t\tans[x][1]=n;\n\t\t}\n\t\tfor(int i=y; i<2000;i++){\n\t\t\tfor(int j=1;j<1001;j++){\n//\t\t\t\tcout << \"toNum \" << toNum(j,i) << endl;\n\t\t\t\tif( toNum(j, i) > m ){\n\t\t\t\t\tif( toNum(500, i) > m ){\n\t\t\t\t\t\ti = 3000;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif( dp[j][i] == -1 )\n\t\t\t\t\tcontinue;\n\t\t\t\tfor(int k=-1; k<2; k++){\n\t\t\t\t\tif( toNum(j+k, i+1) > m ){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif( dp[j][i] + dou[j+k][i+1] > dp[j+k][i+1] ){\n\t\t\t\t\t\tdp[j+k][i+1] = dp[j][i] + dou[j+k][i+1];\n\t\t\t\t\t\tif( dou[j+k][i+1] ){\n\t\t\t\t\t\t\tans[j+k][0] = dp[j+k][i+1];\n\t\t\t\t\t\t\tans[j+k][1] = toNum(j+k, i+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint a=0;\n\t\tfor(int i=0; i<1003; i++){\n\t\t\tif( ans[a][0] < ans[i][0] ||\n\t\t\t\t\t(ans[a][0] == ans[i][0] && ans[a][1] < ans[i][1]) ){\n\t\t\t\ta = i;\n\t\t\t}\n\t\t}\n\t\tcout << ans[a][0] << \" \" << ans[a][1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\t\n\t\tfor(y=SIZE-1;y>=0;y--){\n\t\t\tfor(x=SIZE-1;x>=0;x--){\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&\n\t\t\t\t\t\t(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]==dp[y + 1][x - 1]&&pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && \n\t\t\t\t\t\t(dp[y][x]<dp[y + 1][x] || (dp[y][x] == dp[y + 1][x] && pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && \n\t\t\t\t\t\t(dp[y][x]<dp[y + 1][x + 1] || (dp[y][x] == dp[y + 1][x + 1] && pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int h = 0;h < SIZE;h++) {\n\t\t\tfor (int w = 0;w < SIZE;w++) {\n\t\t\t\tif (table[h][w] == n) {\n\t\t\t\t\tcout << dp[h][w] << \" \";\n\t\t\t\t\t//cout << pr[h][w] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  int size=1000;\n  vector<bool> hurui(size*size+1,true);\n  hurui[0]=hurui[1]=false;\n  for(int i=2;i<=size*size;i++){\n    if(hurui[i]){\n      for(int j=2*i;j<=size*size;j+=i) hurui[j]=false;\n    }\n  }\n  vector<vector<int>> doukutu(size,vector<int>(size));\n  int now=1;\n  for(int i=0;i<size/2;i++){\n    for(int j=size/2-i;j<=size/2+i;j++){\n      doukutu[j][size/2-1-i]=now;\n      now++;\n    }\n    for(int j=size/2-i;j<=size/2+i;j++){\n      doukutu[size/2+i][j]=now;\n      now++;\n    }\n    for(int j=size/2-1+i;j>=size/2-1-i;j--){\n      doukutu[j][size/2+i]=now;\n      now++;\n    }\n    for(int j=size/2-1+i;j>=size/2-1-i;j--){\n      doukutu[size/2-1-i][j]=now;\n      now++;\n    }\n  }\n  // for(int i=0;i<size;i++){\n  //   for(int j=0;j<size;j++) cout << doukutu[i][j] << \" \";\n  //   cout << endl;\n  // }\n  while(1){\n    int m,n;\n    cin >> m >> n;\n    if(n==0) return 0;\n    pair<int,int> ma;\n    vector<vector<pair<int,int>>> dp(size,vector<pair<int,int>>(size,{0,0}));\n    vector<vector<bool>> ok(size,vector<bool>(size,false));\n    for(int i=0;i<size;i++){\n      for(int j=0;j<size;j++){\n        if(doukutu[i][j]==n) ok[i][j]=true;\n        if(hurui[doukutu[i][j]]) dp[i][j].first++,dp[i][j].second=doukutu[i][j];\n        if(ok[i][j]){\n          if(i<999){\n            for(int k=-1;k<=1;k++){\n              if(0<=j+k&&j+k<size){\n                if(doukutu[i+1][j+k]<=m){\n                  ok[i+1][j+k]=true;\n                  dp[i+1][j+k]=max(dp[i+1][j+k],dp[i][j]);\n                }\n              }\n            }\n          }\n          ma=max(ma,dp[i][j]);\n        }\n      }\n    }\n    cout << ma.first SP ma.second << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <memory>\n#include <time.h>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\n\nvi get_primes(int n){\n\tvi primes(n);\n\tfor(int i=2;i<n;i++)\n\t\tprimes[i]=i;\n\tfor(int i=2;i*i<n;i++)\n\t\tif(primes[i])\n\t\t\tfor(int j=i*i;j<n;j+=i)\n\t\t\t\tprimes[j]=0;\n\treturn primes;\n}\n\nint dy[]={0,-1,0,1};\nint dx[]={1,0,-1,0};\n\nstruct node{\n\tint cnt,last;\n\tnode():cnt(0),last(0){}\n\tnode(int cnt,int last):cnt(cnt),last(last){}\n\tbool operator<(const node &other)const{\n\t\tif(cnt==other.cnt){\n\t\t\treturn last<other.last;\n\t\t}else{\n\t\t\treturn cnt<other.cnt;\n\t\t}\n\t}\n};\n\nconst int MAXSIZE=2000;\nint main(){\n\tint m,n;\n\tvi primes=get_primes(1000000+10);\n\twhile(cin>>m>>n,m|n){\n\t\tvvi f(MAXSIZE,vi(MAXSIZE));\n\t\tint cy=MAXSIZE/2,cx=MAXSIZE/2;\n\t\tint maxy=INT_MIN,maxx=INT_MIN,miny=INT_MAX,minx=INT_MAX;\n\t\tint dist=1,cnt=0,dir=0;\n\t\tpii start;\n\t\tFOR(num,1,m+1){\n\t\t\tf[cy][cx]=num;\n\t\t\tif(num==n){\n\t\t\t\tstart=make_pair(cy,cx);\n\t\t\t}\n\n\t\t\tmaxy=max(maxy,cy);\n\t\t\tmaxx=max(maxx,cx);\n\t\t\tminy=min(miny,cy);\n\t\t\tminx=min(minx,cx);\n\n\t\t\tcy+=dy[dir];\n\t\t\tcx+=dx[dir];\n\t\t\tcnt++;\n\t\t\tif(cnt==dist){\n\t\t\t\tdir=(dir+1)%4;\n\t\t\t\tcnt=0;\n\t\t\t\tif(dir%2==0){\n\t\t\t\t\tdist++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<node> > dp(MAXSIZE,vector<node>(MAXSIZE,node(-1,-1)));\n\t\tint startNum=f[start.first][start.second];\n\t\tdp[start.first][start.second]=(primes[startNum]?node(1,startNum):node());\n\t\tREP(y,MAXSIZE){\n\t\t\tREP(x,MAXSIZE){\n\t\t\t\tif(dp[y][x].cnt==-1)continue;\n\t\t\t\tFOR(dx,-1,2){\n\t\t\t\t\tint xx=x+dx;\n\t\t\t\t\tint yy=y+1;\n\t\t\t\t\tif(yy>=miny&&xx>=minx&&yy<=maxy&&xx<=maxx){\n\t\t\t\t\t\tbool isprime=primes[f[yy][xx]]!=0;\n\t\t\t\t\t\tint ncnt=dp[y][x].cnt+isprime;\n\t\t\t\t\t\tint nlast=(isprime?f[yy][xx]:dp[y][x].last);\n\t\t\t\t\t\tdp[yy][xx]=max(dp[yy][xx],node(ncnt,nlast));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//REP(i,MAXSIZE){\n\t\t//\tREP(j,MAXSIZE){\n\t\t//\t\tprintf(\"%2d\",dp[i][j].cnt);\n\t\t//\t}\n\t\t//\tcout<<endl;\n\t\t//}\n\n\t\tnode ans;\n\t\tFOR(x,minx,maxx+1){\n\t\t\tans=max(ans,dp[maxy][x]);\n\t\t}\n\t\tcout<<ans.cnt<<\" \"<<ans.last<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> is_prime;\n\nvoid sieve(int n) {\n\tis_prime=vector<int>(n);\n\tfor (int i = 2; i < n; ++i)\n\t\tis_prime[i] = i;\n\tfor (int i = 2; i*i < n; ++i)\n\t\tif (is_prime[i])\n\t\t\tfor (int j = i*i; j < n; j+=i)\n\t\t\t\tis_prime[j] = 0;\n}\n\n\n//int map[1002][1002];//IDをいれる\nvector<vector<int>> map;\nint id_to_x[1000002];\nint id_to_y[1000002];\nconst int dx[4]={0,-1,0,1};\nconst int dy[4]={-1,0,1,0};\n\nconst int next_dx[3]={-1,0,1};\n\npair<int,int> dp[1002][1002];\n\nint m,n;\n\npair<int,int> calc(int x,int y){\n\tif(map[y][x]<0) return pair<int,int>(0,0);\n\tif(map[y][x]>m) return pair<int,int>(0,0);\n\n\tif(dp[y][x].first>0) return dp[y][x];\n\n\tint max_num=0,max_prime=0;\n\tfor(int r=0;r<3;r++){\n\t\tpair<int,int> got=calc(x+next_dx[r],y+1);\n\t\tif(got.first>max_num){\n\t\t\tmax_num=got.first;\n\t\t\tmax_prime=got.second;\n\t\t}else if(got.first==max_num){\n\t\t\tmax_prime=max(max_prime,got.second);\n\t\t}\n\t}\n\tif(map[y][x]<=1000000 && is_prime[map[y][x]]!=0){\n\t\tmax_num++;\n\t\tif(max_prime==0) max_prime=map[y][x];\n\t}\n\tdp[y][x]=pair<int,int>(max_num,max_prime);\n\treturn pair<int,int>(max_num,max_prime);\n}\n\nint main()\n{\n\tmap.resize(1002,vector<int>(1002));\n\tsieve(1000001);\n\tfor(int y=0;y<1002;y++)for(int x=0;x<1002;x++){\n\t\tmap[y][x]=-1;\n\t\tdp[y][x].first=-1;\n\t}\n\tint x=500,y=500;\n\tint id=1;\n\tmap[y][x]=id;\n\tid_to_x[1]=x;\n\tid_to_y[1]=y;\n\tint d=0;\n\tid++;\n\twhile(id<=1000000){\n\t\tfor(int r=0;r<4;r++){\n\t\t\tint nd=d;\n\t\t\tif(r==0) nd--;\n\t\t\telse if(r==3) nd++;\n\t\t\tfor(int k=0;k<nd;k++){\n\t\t\t\tif(id>1000000) break;\n\t\t\t\tx+=dx[r];\n\t\t\t\ty+=dy[r];\n\t\t\t\tmap[y][x]=id;\n\t\t\t\tid_to_x[id]=x;\n\t\t\t\tid_to_y[id]=y;\n\t\t\t\tid++;\n\t\t\t}\n\t\t}\n\t\td+=2;\n\t}\n\twhile(cin>>m>>n){\n\t\tif(m==0 && n==0) return 0;\n\t\tfor(int y=0;y<1002;y++)for(int x=0;x<1002;x++){\n\t\t\tdp[y][x].first=-1;\n\t\t}\n\t\tpair<int,int> got=calc(id_to_x[n],id_to_y[n]);\n\t\tcout<<got.first<<\" \"<<got.second<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\n#define rep(i,n) repl(i,0,n)\n#define INF INT_MAX/3\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nbool is_prime[1100001];\nint cav[2000][2000];\nP mem[2000][2000];\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\n\nP dfs(int i,int j,int maxp){\n  if(cav[i][j]>maxp)return P(0,0);\n  if(mem[i][j]!=P(-1,-1))return mem[i][j];\n  P res=P(0,0);\n  if(i+1<2000){\n    res=max(res,dfs(i+1,j,maxp));\n    if(j-1>=0)res=max(res,dfs(i+1,j-1,maxp));\n    if(j+1<2000)res=max(res,dfs(i+1,j+1,maxp));\n  }\n  if(is_prime[cav[i][j]]){\n    if(res.first==0)res.second=cav[i][j];\n    res.first++;\n  }\n  return mem[i][j]=res;\n}\n\nint main(void) {\n  is_prime[0]=is_prime[1]=false;\n  for(int i=2;i<=1100000;i++)is_prime[i]=true;\n  for(int i=2;i<=1100000;i++){\n    if(is_prime[i]){\n      for(int j=i*2;j<=1100000;j+=i)is_prime[j]=false;\n    }\n  }\n  rep(i,2000)rep(j,2000)cav[i][j]=INF;\n  int si=1000,sj=1000,len=1,num=1,dir=0;\n  while(num<=1000000){\n    rep(i,len){\n      cav[si][sj]=num++;\n      si+=dy[dir];\n      sj+=dx[dir];\n    }\n    dir=(dir+1)%4;\n    if(dir==0||dir==2)len++;\n  }\n  while(1) {\n    int n,s;\n    cin>>n>>s;\n    if(n==0&&s==0)break;\n    rep(i,2000)rep(j,2000)mem[i][j]=P(-1,-1);\n    P res=P(0,0);\n    rep(i,2000)rep(j,2000){\n      if(cav[i][j]==s){\n        res=dfs(i,j,n);\n        break;\n      }\n    }\n    printf(\"%d %d\\n\", res.first,res.second);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\nint main ()\n{\n    const int INF = 1 << 28;\n    const int MAX = 1000000;\n    const int dx[] = { 1, 0,-1, 0};\n    const int dy[] = { 0,-1, 0, 1};\n    const int dm[] = {-1, 0, 1};\n    int n, m;\n    map<P, int> M;\n    vector<P> d(MAX+1, P(INF,INF));\n\n    M[P(0,0)] = 1;\n    d[1] = P(0,0);\n    int x = 1, y = 0;\n    int c = 1;\n    for (int i = 2; i <= MAX; i++) {\n        c %= 4;\n        int cdir = 4 + c - 1;\n        cdir %= 4;\n        int sy = y - dy[cdir], sx = x - dx[cdir];\n        M[P(y,x)] = i;\n        d[i] = P(y,x);\n         if (M.find(P(sy,sx)) != M.end()) {\n            x += dx[c];\n            y += dy[c];\n         } else {\n             x = sx;\n             y = sy;\n             c++;\n         }\n    }\n\n    vector<bool> prim(MAX+1, true);\n    prim[0] = prim[1] = false;\n    for (int i = 2; i <= MAX / 2; i++) {\n        for (int j = 2; prim[i] && j * i <= MAX; j++) {\n            prim[i * j] = false;\n        }\n    }\n\n    while (cin >> n >> m , n + m) {\n        int res = 0;\n        int res_n = 0;\n        queue<pair<int,P> > q;\n\n        vector<int> count(MAX+1, 0);\n        if (prim[m]) {\n            count[m] = 1;\n            q.push(pair<int,P>(1, d[m]));\n            res = 1;\n            res_n = m;\n        } else {\n            count[m] = 0;\n            q.push(pair<int,P>(0, d[m]));\n        }\n\n        vector<bool> used(MAX + 1, false);\n\n        while (q.size()) {\n            pair<int,P> pp = q.front(); q.pop();\n            P p = pp.second;\n            int num = M[p];\n            int ret = pp.first;\n\n            if (count[num] > ret) continue;\n            used[num] = true;\n            y = p.first, x = p.second;\n            for (int i = 0; i < 3; i++) {\n                int ny = y + 1, nx = x + dm[i];\n                if (M.find(P(ny, nx)) != M.end() && M[P(ny,nx)] <= n) {\n                    int t_n = M[P(ny,nx)];\n                    if (count[t_n] == 0 || count[t_n] < count[num] + (prim[t_n] ? 1 : 0)) {\n\n                        if (!used[t_n] || count[t_n] < count[num] + (prim[t_n] ? 1 : 0)) {\n                            count[t_n] = count[num] + (prim[t_n] ? 1 : 0);\n                            q.push(pair<int,P>(count[t_n], P(ny,nx)));\n                            used[t_n] = true;\n                        }\n                        if (res <= count[t_n] && prim[t_n]) {\n                            res = count[t_n];\n                            res_n = max(res_n, t_n);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (res == 0)\n            cout << 0 << \" \" << 0 << endl;\n        else\n            cout << res << \" \" << res_n << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int MAX_M = 1000001;\nconst int C = 1000;\nconst int INF = 1e9;\n#define y first\n#define x second\n\nmap<int, P> itop;\nmap<P, int> ptoi;\nbool isp[MAX_M];\n\nvoid make_prime(){\n  REP(i, MAX_M) isp[i] = true;\n  isp[0] = isp[1] = false;\n  FOR(i, 2, sqrt(MAX_M) + 1){\n    if(!isp[i]) continue;\n    for(int j = i + i; j < MAX_M; j += i) isp[j] = false;\n  }\n}\n\nvoid init(){\n  P now = P(C / 2, C / 2);\n  int c[C][C], pls = 1, l = 1, step = 0, d = 0;\n  memset(c, 0, sizeof(c));\n  FOR(i, 1, MAX_M){\n    itop[i] = now;\n    ptoi[now] = i;\n    if(d == 0) now.x += 1;\n    else if(d == 1) now.y -= 1;\n    else if(d == 2) now.x -= 1;\n    else if(d == 3) now.y += 1;\n    ++step;\n    if(step >= l){\n      d = (d + 1) % 4;\n      step = 0;\n    }\n    if(i != 1 && (d == 0 || d == 2) && step == 0) ++l;\n  }\n}\n\nint main() {\n  make_prime();\n  init();\n  int M, N;\n  while(cin >>M >>N && (N && M)){\n    P dp[C][C];\n    REP(i, C) REP(j, C) dp[i][j] = P(-1, -1);\n    P now = itop[N], ans = P(-1, -1);\n    dp[now.y][now.x] = (isp[N] ? P(1, N) : P(0, -1));\n    REP(y, C){\n      REP(x, C){\n        if(dp[y][x].first == -1 || ptoi.find(P(y, x)) == ptoi.end()) continue;\n        ans = max(ans, dp[y][x]);\n        for(int mx = -1; mx <= 1; ++mx){\n          int ny = y + 1, nx = x + mx;\n          if(ny < 0 || nx < 0 || ny >= C || nx >= C || ptoi.find(P(ny, nx)) == ptoi.end()) continue;\n          int cnt = dp[y][x].first + (isp[ptoi[P(ny, nx)]] ? 1 : 0), num = (isp[ptoi[P(ny, nx)]] ? ptoi[P(ny, nx)] : dp[y][x].second);\n          if(num > M) continue;\n          if(cnt > dp[ny][nx].first || (cnt == dp[ny][nx].first && num > dp[ny][nx].second)) dp[ny][nx] = P(cnt, num);\n        }\n      }\n    }\n    if(ans.first == 0) cout <<\"0 0\" <<endl;\n    else cout <<ans.first <<\" \" <<ans.second <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<int(b); i++)\n#define rep(i,n) loop(i,0,n)\ntypedef complex<int> P;\n\nconst int MAX_M = 1.5e6+10;\nconst int SIZE = 2000;\nint ps[MAX_M/2];\nbool isp[MAX_M];\nint grid[SIZE][SIZE]={};\nP itop[MAX_M];\npair<int,int> dp[SIZE][SIZE];\n\nint cnt_p = 0;\n\nvoid make_es(){\n    fill(isp,isp+MAX_M,true);\n    isp[0]=isp[1]=false;\n    rep(i,MAX_M){\n        if(!isp[i]) continue;\n        ps[cnt_p++] = i;\n        for(int j=i<<1; j<MAX_M; j+=i){\n            isp[j] = false;\n        }\n    }\n}\n\nP const ii(0,1);\n\nint n,m;\n\npair<int,int> rec(int y, int x){\n    auto & res = dp[y][x];\n    if(res.first!=-1) return res;\n    res = make_pair(0,0);\n    pair<int,int> best(0,0);\n    loop(i,-1,2){\n        if(grid[y+1][x+i]<=m){\n            auto t = rec(y+1,x+i);\n            best = max(t,best);\n        }\n    }\n\n    if(best.first != 0){\n        res.first = best.first + isp[grid[y][x]];\n        res.second = best.second;\n    } else {\n        res.first = isp[grid[y][x]];\n        res.second = grid[y][x];\n    }\n\n    return res;\n}\n\nint main(){\n    make_es();\n    P p(SIZE/2,SIZE/2);\n    P dir(0,1);\n    for(int i=1; i<MAX_M; i++){\n        grid[p.real()][p.imag()] = i;\n        itop[i]=p;\n        p+=dir;\n        P q = p+dir*ii;\n        if(grid[q.real()][q.imag()] == 0){\n            dir*=ii;\n        }\n    }\n\n    while(cin>>m>>n, n+m){\n        auto t = make_pair(-1,-1);\n        rep(i,SIZE)rep(j,SIZE) dp[i][j] = t;\n        P p = itop[n];\n        auto ans = rec(p.real(), p.imag());\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iomanip>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define pii pair<int,int>\n\n#define MAXM 1000001\n#define MAXSQM 1002\nint diff[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nint map[MAXSQM][MAXSQM] = {};\nbool furui[MAXM] = {};\npii dpmap[MAXSQM][MAXSQM] = {};\n\nvoid init_map(int m){\n    fill_n(*map,MAXSQM*MAXSQM,0);\n    fill_n(*dpmap,MAXSQM*MAXSQM,pii(-1,-1));\n    int idx=MAXSQM/2,idy=MAXSQM/2;\n    int dir=0;\n    int c=1;\n    for(int i=1;c<=m;i++){\n        for(int j=0;j<i&&c<=m;j++){\n            map[idx][idy]=c++;\n            idx+=diff[dir][0];\n            idy+=diff[dir][1];\n        }\n        dir=(dir+1)%4;\n        for(int j=0;j<i&&c<=m;j++){\n            map[idx][idy]=c++;\n            idx+=diff[dir][0];\n            idy+=diff[dir][1];\n        }\n        dir=(dir+1)%4;\n    }\n}\n\npii dp(int n){\n    int nx,ny;\n    for(nx=0;nx<MAXSQM;nx++){\n        for(ny=0;ny<MAXSQM;ny++){\n            if(n==map[nx][ny]) break;\n        }\n        if(n==map[nx][ny]) break;\n    }\n\n    pii ans=pii(0,0);\n\n    if(!furui[map[nx][ny]]){\n        dpmap[nx][ny]=pii(1,map[nx][ny]);\n        ans=dpmap[nx][ny];\n    }\n    else\n    {\n        dpmap[nx][ny]=pii(0,0);\n    }\n\n    for(int j=ny;j>=1;j--){\n        for(int i=0;i<MAXSQM;i++){\n            if(map[i][j]==0 || dpmap[i][j].first==-1) continue;\n            for(int k=-1;k<=1;k++){\n                if(map[i+k][j-1]==0) continue;\n                if(!furui[map[i+k][j-1]]){\n                    dpmap[i+k][j-1]=max(pii(dpmap[i][j].first+1,map[i+k][j-1]), dpmap[i+k][j-1]);\n                }\n                else\n                {\n                    dpmap[i+k][j-1]=max(dpmap[i][j], dpmap[i+k][j-1]);\n                }\n                ans=max(ans,dpmap[i+k][j-1]);\n            }\n        }\n    }\n    return ans;\n}\n\nint main(){\n    while(1){\n        int m,n;\n        cin>>m>>n;\n        if(m==0) break;\n\n        furui[0]==furui[1]==true;\n        for(int i=2;i<MAXSQM;i++){\n            for(int j=2;i*j<MAXM;j++){\n                if(!furui[i]){\n                    furui[i*j]=true;\n                }\n            }\n        }\n        init_map(m);\n        pii p=dp(n);\n\n        /*int b=503,a=487;\n        for(int i=a-5;i<a+5;i++){\n            for(int j=b-5;j<b+5;j++){\n                cout<<std::setw(4)<<map[j][i];\n            }\n            cout<<endl;\n        }\n        for(int i=a-5;i<a+5;i++){\n            for(int j=b-5;j<b+5;j++){\n                cout<<setw(4)<<dpmap[j][i].first;\n            }\n            cout<<endl;\n        }*/\n        cout<<p.first<<\" \"<<p.second<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1189&lang=jp\n\n#include<iostream>\n#include<fstream>\n#include<math.h>\n\n//#define MAX 1020000\n\n#define MAX 1002\n\nint n, first;\nint a[MAX][MAX] = {};\nstatic bool initial;\n\nclass Pair{\npublic:\n\tint count;\n\tint last;\n\tPair operator + (Pair p){//\t@Override (+)\n\t\tthis->count += p.count;\n\t\tif (p.last != 0)this->last = p.last;\n\t\treturn *this;\n\t}\n\tvoid setPair(int _x, int _y){\n\t\tcount = _x;\n\t\tlast = _y;\n\t}\n};\n\nPair pair(int a, int b){\n\tPair p;\n\tp.setPair(a, b);\n\treturn p;\n}\n\nbool isPrime(int n){\n\tif (n == 1)return false;\n\tif (n == 2)return true;\n\tif (n % 2 == 0)return false;\n\n\tfor (int i = 3; i * i <= n; i += 2){\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\n\nPair search(int y, int x){\n\tstatic Pair p[MAX*MAX];\n\n\tPair u_right = pair(-10, 0);\n\tPair u_left = pair(-10, 0);\n\n\tstatic bool isReached[MAX*MAX];\n\n\n\tif (initial){//初期化\n\t\tfor (int i = 0; i < MAX*MAX; i++){\n\t\t\tisReached[i] = false;\n\t\t\tp[i].count = p[i].last = 0;\n\t\t}\n\t\tinitial = false;\n\t}\n\n\tif (n < a[y][x] || a[y][x] == 0)\n\t\treturn p[0];//上限を超えていた場合,,, p[0].count = p[0].last = 0\n\n\t//以下特殊例処理\n\tif (a[y][x] == 2){\n\t\tp[2].last = 2;\n\t\tif (a[y][x] == first)initial = true;\n\t\treturn pair(1, 2) + search(y + 1, x);\n\t}\n\n\tif (n <= 6 && a[y][x] == 3){\n\t\tp[3].last = 2;\n\t\tif (a[y][x] == first)initial = true;\n\t\treturn pair(2, 2);\n\t}\n\tif (a[y][x] == 4){\n\t\tif (u_right.count == -10)u_right = search(y + 1, x + 1);\n\t\tif (u_left.count == -10)u_left = search(y + 1, x);\n\n\t\tif (u_right.count == u_left.count){\n\t\t\tif (u_right.last < u_left.last)u_right.count--;\n\t\t}\n\t\tif (u_right.count < u_left.count){\n\t\t\tisReached[4] = true;\n\t\t\tif (a[y][x] == first)initial = true;\n\t\t\treturn p[4] = p[4] + u_left;\n\t\t}\n\t\telse{\n\t\t\tisReached[4] = true;\n\t\t\tif (a[y][x] == first)initial = true;\n\t\t\treturn p[4] = p[4] + u_right;\n\t\t}\n\t}\n\t//ここまで特例処理\n\n\t//偶数の時\n\tif (a[y][x] % 2 == 0){\n\t\tif (a[y][x] == first){\n\t\t\tinitial = true;\n\t\t\tif (n == first)return p[a[y][x]] = search(y + 1, x + 1) + search(y + 1, x - 1);// +p[a[y + 1][x - 1]];\n\t\t}\n\treturn p[a[y + 1][x]] = search(y + 1, x);\n\t}\n\n\t//枝刈り\n\tif (isReached[a[y][x]]){\n\t\tif (a[y][x] == first)initial = true;\n\t\treturn p[a[y][x]];\n\t}\n\n\tif (u_right.count == -10)u_right = search(y + 1, x + 1);//under.rightの計算\n\tif (u_left.count == -10)u_left = search(y + 1, x - 1);//under.leftの計算\n\n\t//素数の時\n\tif (isPrime(a[y][x])){\n\t\tp[a[y][x]].count = 1;\n\t\tp[a[y][x]].last = a[y][x];\n\t}\n\n\tif (u_right.count == u_left.count){\n\t\tif (u_right.last < u_left.last)u_right.count--;\n\t}\n\t//leftのコストが大きい時\n\tif (u_right.count < u_left.count){\n\t\tisReached[a[y][x]] = true;\n\t\tif (a[y][x] == first)initial = true;//最初に入った時のみ、次のために初期化\n\t\treturn p[a[y][x]] = p[a[y][x]] + u_left;\n\t}\n\t//rightのコストが大きい時\n\telse{\n\t\tisReached[a[y][x]] = true;\n\t\tif (a[y][x] == first)initial = true;//最初に入った時のみ、次のために初期化\n\t\treturn p[a[y][x]] = p[a[y][x]] + u_right;\n\t}\n}\n\nint main(){\n\n\tusing namespace std;\n\n\tint x = MAX / 2;\n\tint y = MAX / 2;\n\tint N = 1;\n\ta[MAX / 2][MAX / 2] = 1;\n\n\tfor (int i = 0; i < MAX*MAX; i++){\n\n\t\tfor (int n = 0; n < (int)sqrt((double)N); n++){\n\t\t\ta[y][x] = N;\n\t\t\tN++;\n\t\t\tx++;\n\t\t}\n\t\tif (N >= (MAX)*(MAX))break;\n\t\tfor (int n = 0; n < (int)sqrt((double)N); n++){\n\t\t\ta[y][x] = N;\n\t\t\tN++;\n\t\t\ty--;\n\t\t}\n\t\tif (N >= (MAX)*(MAX))break;\n\t\tfor (int n = 0; n < (int)sqrt((double)N); n++){\n\t\t\ta[y][x] = N;\n\t\t\tN++;\n\t\t\tx--;\n\t\t}\n\t\tif (N >= (MAX)*(MAX))break;\n\t\tfor (int n = 0; n < (int)sqrt((double)N); n++){\n\t\t\ta[y][x] = N;\n\t\t\tN++;\n\t\t\ty++;\n\t\t}\n\t\tif (N >= (MAX)*(MAX))break;\n\t}\n\n\tifstream fin;\n\tfin.open(\"input.txt\");\n\n\twhile (true){\n\t\tcin >> n >> first;\n\t\tif (n == 0)break;\n\n\t\tinitial = true;\n\n\t\tfor (int i = 0; i < MAX; i++){\n\t\t\tfor (int j = 0; j < MAX; j++){\n\t\t\t\tif (a[i][j] == first){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tPair p = search(y, x);\n\n\t\tcout << p.count << \" \" << p.last << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n#define t_max 10000001\nchar M[1001][1001];\nchar S[1001][1001];\nchar P[1001][1001];\nchar table[t_max];\nvector<pair<int,int> >m(t_max);\nmap<pair<int,int>,int>m_rev;\npair<int,int> dfs(int x,int y){\n\tif(y==1001)return make_pair(0,0);\n\tif(S[x][y]>=0)return make_pair(S[x][y],P[x][y]);\n\tint m=0,m_place=0,i=-1;\n\tfor(;i<2;i++){\n\t\tif(x+i<0||1000<x+i)continue;\n\t\tpair<int,int> p=dfs(x+i,y+1);\n\t\tif(m<p.first||(m==p.first&&m_place<p.second))m=p.first,m_place=p.second;\n\t}\n\tif(m==0){\n\t\tif(M[x][y])return make_pair(S[x][y]=1,P[x][y]=m_rev[make_pair(x,y)]);\n\t\treturn make_pair(S[x][y]=0,P[x][y]=0);\n\t}else{\n\t\treturn make_pair(S[x][y]=m+M[x][y],P[x][y]=m_place);\n\t}\n}\nmain(){\n\tint k=1,z,x,y,i,n,s;\n\tm[k]=make_pair(x=500,y=500),m_rev[make_pair(x,y)]=k,k++;\n\tfor(z=2;z<=1000;z+=2){\n\t\tx++,y++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(x,--y),m_rev[make_pair(x,y)]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(--x,y),m_rev[make_pair(x,y)]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(x,++y),m_rev[make_pair(x,y)]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(++x,y),m_rev[make_pair(x,y)]=k,k++;\n\t}\n\ttable[0]=table[1]=1;\n\tfor(x=2;x<t_max;x++)if(!table[x])for(y=x*2;y<t_max;y+=x)table[y]=1;\n\tfor(;scanf(\"%d%d\",&n,&s),n;){\n\t\tmemset(M,0,sizeof(M));\n\t\tmemset(S,0xff,sizeof(S));\n\t\tmemset(P,0,sizeof(P));\n\t\tfor(i=1;i<=n;i++)if(!table[i])M[m[i].first][m[i].second]=1;\n\t\tpair<int,int> p=dfs(m[s].first,m[s].second);\n\t\tprintf(\"%d %d\\n\",p.first,p.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nconst int dx[] = {-1,0,1,0}, dy[] = {0,-1,0,1};\npair<int,int> DP[1002][1002];\nint Num[1002][1002], l;\nbool visited[1002][1002];\n\npair<int,int> dfs(int x, int y){\n  if(x < 0 || x > l || y < 0 || y > l) return {0,0};\n  if(visited[x][y]) return DP[x][y];\n  visited[x][y] = true;\n  pair<int,int> ret = max({dfs(x+1,y-1),dfs(x+1,y),dfs(x+1,y+1)});\n  if(DP[x][y].first > 0){\n    if(ret.first < DP[x][y].first) ret = DP[x][y];\n    else ++ret.first;\n  }\n  DP[x][y] = ret;\n  return ret;\n}\n\nsigned main(){\n  int M = (1e6), N;\n  vector<bool> is_prime(M+1,true);\n  is_prime[0] = false;\n  is_prime[1] = false;\n  for(int i = 2; i*i <= M; ++i){\n    if(!is_prime[i]) continue;\n    for(int j = i; j*i <= M; ++j){\n      is_prime[i*j] = false;\n    }\n  }\n  \n  while(cin >> M >> N, N||M){\n    l = 1;\n    while(l*l < M) l += 2;\n    \n    for(int i = 0; i <= l; ++i){\n      for(int j = 0; j <= l; ++j){\n        DP[i][j] = {0,0};\n        visited[i][j] = false;\n      }\n    }\n    \n    int x = l/2, y = x, d = 0, x_ = x, y_ = y;\n    DP[x][y] = {0,0};\n    Num[x][y] = 1;\n    visited[x][y] = true;\n    ++y;\n    \n    for(int i = 2; i <= M; ++i){\n      visited[x][y] = true;\n      if(i == N){\n        x_ = x;\n        y_ = y;\n      }\n      if(is_prime[i]) DP[x][y] = {1,i};\n      else DP[x][y] = {0,0};\n      Num[x][y] = i;\n      int d_ = (d+1)%4;\n      if(!visited[x+dx[d_]][y+dy[d_]]) d = d_;\n      x += dx[d];\n      y += dy[d];\n    }\n    \n    for(int i = 0; i <= l; ++i)\n      for(int j = 0; j <= l; ++j)\n        visited[i][j] = false;\n    \n    /*\n    for(int i = 0; i < l; ++i){\n      for(int j = 0; j < l; ++j) printf(\"%2d \",Num[i][j]);printf(\"\\n\");\n    }\n    */\n    \n    pair<int,int> ans = dfs(x_,y_);\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    vector<int> prime(1'000'001, true);\n    prime[0] = false;\n    prime[1] = false;\n    for (int i = 2; i < 1'000'001; i++){\n        if (prime[i]){\n            for (int j = i * 2; j < 1'000'001; j += i) prime[j] = false;\n        }\n    }\n\n    vector<vector<int>> maze(1000, vector<int>(1000, 0));\n    int num = 1'000'000;\n    int mode = 0;\n    int x = 0;\n    int y = 0;\n    maze[x][y] = num;\n    num--;\n    while (num > 0){\n        if (mode == 0){\n            if (x < 0 || x >= 1000 || y+1 < 0 || y+1 >= 1000) {\n                mode = 1;\n                continue;\n            }\n            if (maze[x][y+1] != 0){\n                mode = 1;\n                continue;\n            }\n            maze[x][y+1] = num;\n            y++;\n            num--;\n        }\n        else if (mode == 1){\n            if (x+1 < 0 || x+1 >= 1000 || y < 0 || y >= 1000) {\n                mode = 2;\n                continue;\n            }\n            if (maze[x+1][y] != 0){\n                mode = 2;\n                continue;\n            }\n            maze[x+1][y] = num;\n            x++;\n            num--;\n        }\n        else if (mode == 2){\n            if (x < 0 || x >= 1000 || y-1 < 0 || y-1 >= 1000) {\n                mode = 3;\n                continue;\n            }\n            if (maze[x][y-1] != 0){\n                mode = 3;\n                continue;\n            }\n            maze[x][y-1] = num;\n            y--;\n            num--;\n        }\n        else if (mode == 3){\n            if (x-1 < 0 || x-1 >= 1000 || y < 0 || y >= 1000) {\n                mode = 0;\n                continue;\n            }\n            if (maze[x-1][y] != 0){\n                mode = 0;\n                continue;\n            }\n            maze[x-1][y] = num;\n            x--;\n            num--;\n        }\n    }\n\n    while (1){\n        int m, n;\n        cin >> m >> n;\n        if (n == 0) break;\n        vector<vector<int>> ans(1000, vector<int>(1000, 0));\n        vector<vector<int>> cave(1000, vector<int>(1000, 0));\n        int sx, sy;\n        for (int i = 0; i < 1000; i++){\n            for (int j = 0; j < 1000; j++){\n                if (maze[i][j] == n){\n                    sx = i;\n                    sy = j;\n                }\n            }\n        }\n        vector<vector<bool>> check(1000, vector<bool>(1000, false));\n        check[sx][sy] = true;\n        if (prime[n]){\n            ans[sx][sy] = 1;\n            cave[sx][sy] = n;\n        }\n        for (int i = sx + 1; i < 1000; i++){\n            for (int j = 0; j < 1000; j++){\n                if (maze[i][j] > m) continue;\n                for (int k = -1; k < 2; k++){\n                    if (j+k < 0 || j+k >= 1000) continue;\n                    if (check[i-1][j+k]){\n                        if (ans[i][j] < ans[i-1][j+k] + prime[maze[i][j]]){\n                            ans[i][j] = ans[i-1][j+k] + prime[maze[i][j]];\n                            cave[i][j] = cave[i-1][j+k];\n                        }\n                        else if (ans[i][j] == ans[i-1][j+k] + prime[maze[i][j]]){\n                            cave[i][j] = max(cave[i][j], cave[i-1][j+k]);\n                        }\n                        check[i][j] = true;\n                    }\n                }\n                if (prime[maze[i][j]]) cave[i][j] = maze[i][j];\n            }\n        }\n\n        int p = 0;\n        int q = 0;\n        for (int i = 0; i < 1000; i++){\n            for (int j = 0; j < 1000; j++){\n                if (check[i][j]){\n                    if (p < ans[i][j]){\n                        p = ans[i][j];\n                        q = cave[i][j];\n                    }\n                    else if (p == ans[i][j] && q < cave[i][j]){\n                        p = ans[i][j];\n                        q = cave[i][j];\n                    }\n                }\n            }\n        }\n        if (p == 0) cout << \"0 0\" << endl; \n        else cout << p << \" \" << q << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint n, m;\nint a[3000][3000];\nint b[3000][3000];\nint c[3000][3000];\nint e[3000][3000];\nint sx[3000005];\nint sy[3000005];\nint p[3000005];\nvoid prime()\n{\n\tint i, j;\n\tp[1] = 1;\n\tfor(i=2;i<=3000000;i++)\n\t{\n\t\tif(p[i] == 0)\n\t\t{\n\t\t\tfor(j=2*i;j<=3000000;j+=i)\n\t\t\t{\n\t\t\t\tp[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid inil()\n{\n\tint i, j;\n\tprime();\n\tint x,y,d;\n\tint dx[4]={1,0,-1,0};\n\tint dy[4]={0,1,0,-1};\n\td = 0;\n\tx = y = 1500;\n\tint k=1;\n\tint td;\n\twhile(k<=2000000)\n\t{\n\t\ta[x][y] = k;\n\t\tsx[k] = x;\n\t\tsy[k] = y;\n\t\tif(p[k] == 0)\n\t\t\tb[x][y] = 1;\n\t\ttd = (d+1)%4;\n\t\tif(a[dx[td] + x][dy[td] + y] == 0)\n\t\t\td = td;\n\t\tx = x+dx[d];\n\t\ty = y+dy[d];\n\t\tk++;\n\t}\n}\nvoid process()\n{\n\tint i, j, k;\n\tint x,y;\n\tx = sx[m];\n\ty = sy[m];\n\tfor(i=0;i<3000;i++)\n\t\tfor(j=0;j<3000;j++)\n\t\t\tc[i][j] = 0;\n\tif(p[a[x][y]]==0)\n\t\tc[x][y]=1;\n\tfor(i=x+1;i<2888;i++)\n\t{\n\t\tfor(j=y-i+x;j<=y+i-x;j++)\n\t\t{\n\t\t\tif(j<0)continue;\n\t\t\tif(j>2888)continue;\n\t\t\tif(a[i][j] == 0 || a[i][j] > n) continue;\n\t\t\t//printf(\"%d %d  %d %d\\n\",x,y,i,j);\n\t\t\tk = (p[a[i][j]]==0);\n\t\t\tif(c[i][j] < c[i-1][j-1] + k)\n\t\t\t{\n\t\t\t\tc[i][j] = c[i-1][j-1]+k;\n\t\t\t\te[i][j] = e[i-1][j-1];\n\t\t\t}\n\t\t\telse if(c[i][j] == c[i-1][j-1]+k)\n\t\t\t{\n\t\t\t\te[i][j] = e[i-1][j-1];\n\t\t\t}\n\t\t\tif(c[i][j] < c[i-1][j] + k)\n\t\t\t{\n\t\t\t\tc[i][j] = c[i-1][j]+k;\n\t\t\t\te[i][j] = e[i-1][j];\n\t\t\t}\n\t\t\telse if(c[i][j] == c[i-1][j]+k)\n\t\t\t{\n\t\t\t\te[i][j] = e[i-1][j];\n\t\t\t}\n\t\t\tif(c[i][j] < c[i-1][j+1] + k)\n\t\t\t{\n\t\t\t\tc[i][j] = c[i-1][j+1]+k;\n\t\t\t\te[i][j] = e[i-1][j+1];\n\t\t\t}\n\t\t\telse if(c[i][j] == c[i-1][j+1]+k)\n\t\t\t{\n\t\t\t\te[i][j] = e[i-1][j+1];\n\t\t\t}\n\t\t\tif(k)e[i][j] = a[i][j];\n\t\t}\n\t}\n\tint max=0;\n\tint mi = 0;\n\tfor(i=n;i>0;i--)\n\t{\n\t\tif(max < c[sx[i]][sy[i]])\n\t\t{\n\t\t\tmax = c[sx[i]][sy[i]];\n\t\t\tmi = e[sx[i]][sy[i]];\n\t\t}\n\t\telse if(max == c[sx[i]][sy[i]])\n\t\t{\n\t\t\tif(mi < e[sx[i]][sy[i]])\n\t\t\t\tmi = e[sx[i]][sy[i]];\n\t\t}\n\t}\n\tif(max==0)mi=0;\n\tprintf(\"%d %d\\n\",max,mi);\n}\nint main()\n{\n\tinil();\n\twhile(1)\n\t{\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n+m==0)break;\n\t\tprocess();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint x[1200][1200], y[1200][1200][2], cx = 600, cy = 600, nums, primes[1300000], n, m, p, q;\n\nvoid sets() {\n\tx[cx][cy] = 1; nums = 1;\n\tfor (int i = 0; i < 2200; i++) {\n\t\tif (i % 4 == 0) {\n\t\t\tfor (int j = 0; j <= i / 2; j++) {\n\t\t\t\tcx++;\n\t\t\t\tnums++;\n\t\t\t\tx[cy][cx] = nums;\n\t\t\t}\n\t\t}\n\t\tif (i % 4 == 1) {\n\t\t\tfor (int j = 0; j <= i / 2; j++) {\n\t\t\t\tcy--;\n\t\t\t\tnums++;\n\t\t\t\tx[cy][cx] = nums;\n\t\t\t}\n\t\t}\n\t\tif (i % 4 == 2) {\n\t\t\tfor (int j = 0; j <= i / 2; j++) {\n\t\t\t\tcx--;\n\t\t\t\tnums++;\n\t\t\t\tx[cy][cx] = nums;\n\t\t\t}\n\t\t}\n\t\tif (i % 4 == 3) {\n\t\t\tfor (int j = 0; j <= i / 2; j++) {\n\t\t\t\tcy++;\n\t\t\t\tnums++;\n\t\t\t\tx[cy][cx] = nums;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid isprime(int v) {\n\tfor (int i = 2; i <= v; i++) {\n\t\tfor (int j = 2; j <= sqrt(i); j++) {\n\t\t\tif (i%j == 0) { goto E; }\n\t\t}\n\t\tprimes[i] = 1;\n\tE:;\n\t}\n}\n\nint main() {\n\tsets();\n\tisprime(1200000);\n\twhile (true) {\n\t\tcin >> n >> m;\n\t\tif (!n) { break; }\n\t\tmemset(y, -1, sizeof(y));\n\t\tfor (int i = 0; i < 1200; i++) {\n\t\t\tfor (int j = 0; j < 1200; j++) {\n\t\t\t\tif (x[i][j] == m) {\n\t\t\t\t\ty[i][j][0] = primes[m];\n\t\t\t\t\ty[i][j][1] = 0;\n\t\t\t\t\tif (y[i][j][0] == 1) { \n\t\t\t\t\t\ty[i][j][1] = m; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 1200; i++) {\n\t\t\tfor (int j = 0; j < 1200; j++) {\n\t\t\t\tif (y[i][j][0] >= 0) {\n\t\t\t\t\t//sosuuhantei-1st\n\t\t\t\t\tif (x[i + 1][j - 1] <= n) {\n\t\t\t\t\t\tif (primes[x[i + 1][j - 1]] == 1) {\n\t\t\t\t\t\t\tp = y[i][j][0] + 1;\n\t\t\t\t\t\t\tq = x[i + 1][j - 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tp = y[i][j][0];\n\t\t\t\t\t\t\tq = y[i][j][1];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (y[i + 1][j - 1][0] < p) {\n\t\t\t\t\t\t\ty[i + 1][j - 1][0] = p;\n\t\t\t\t\t\t\ty[i + 1][j - 1][1] = q;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (y[i + 1][j - 1][0] == p) {\n\t\t\t\t\t\t\ty[i + 1][j - 1][0] = p;\n\t\t\t\t\t\t\ty[i + 1][j - 1][1] = max(y[i + 1][j - 1][1], q);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//2nd\n\t\t\t\t\tif (x[i + 1][j] <= n) {\n\t\t\t\t\t\tif (primes[x[i + 1][j]] == 1) {\n\t\t\t\t\t\t\tp = y[i][j][0] + 1;\n\t\t\t\t\t\t\tq = x[i + 1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tp = y[i][j][0];\n\t\t\t\t\t\t\tq = y[i][j][1];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (y[i + 1][j][0] < p) {\n\t\t\t\t\t\t\ty[i + 1][j][0] = p;\n\t\t\t\t\t\t\ty[i + 1][j][1] = q;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (y[i + 1][j][0] == p) {\n\t\t\t\t\t\t\ty[i + 1][j][0] = p;\n\t\t\t\t\t\t\ty[i + 1][j][1] = max(y[i + 1][j][1], q);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//3rd\n\t\t\t\t\tif (x[i + 1][j + 1] <= n) {\n\t\t\t\t\t\tif (primes[x[i + 1][j + 1]] == 1) {\n\t\t\t\t\t\t\tp = y[i][j][0] + 1;\n\t\t\t\t\t\t\tq = x[i + 1][j + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tp = y[i][j][0];\n\t\t\t\t\t\t\tq = y[i][j][1];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (y[i + 1][j + 1][0] < p) {\n\t\t\t\t\t\t\ty[i + 1][j + 1][0] = p;\n\t\t\t\t\t\t\ty[i + 1][j + 1][1] = q;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (y[i + 1][j + 1][0] == p) {\n\t\t\t\t\t\t\ty[i + 1][j + 1][0] = p;\n\t\t\t\t\t\t\ty[i + 1][j + 1][1] = max(y[i + 1][j - 1][1], q);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp = 0; q = 0;\n\t\t//result.\n\t\tfor (int i = 0; i < 1200; i++) {\n\t\t\tfor (int j = 0; j < 1200; j++) {\n\t\t\t\tif (p < y[i][j][0]) {\n\t\t\t\t\tp = y[i][j][0];\n\t\t\t\t\tq = y[i][j][1];\n\t\t\t\t}\n\t\t\t\telse if (p == y[i][j][0]) {\n\t\t\t\t\tq = max(q, y[i][j][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << p << ' ' << q << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define dump(a) cout << (#a) << (a) << endl\nusing namespace std;\n\nconst int MAX_OF_MAP = 1000+500;\nconst int CENTER = MAX_OF_MAP/2;\nenum ANGLES {UP,LEFT,BOTTOM,RIGHT};\nconst int PRIME_MAX = 1000000+1;\nbool is_prime[PRIME_MAX];\nvector<pair<int,int> > MOVE_POINT_OF_ANGLE(4);\nvector<pair<int,int> > LEFT_POINT_OF_ANGLE(4);\n\nint caves[MAX_OF_MAP][MAX_OF_MAP];\npair<int,int> memo_caves[MAX_OF_MAP][MAX_OF_MAP];\n//vector<vector<int> > caves(MAX_OF_MAP,vector<int>(MAX_OF_MAP, 0));\n//vector<vector<pair<int,int> > > memo_caves(MAX_OF_MAP,vector<pair<int,int> >(MAX_OF_MAP, make_pair(0,0)));\n\n\nvoid show()\n{\n\tint block = 7;\n\tfor(int y=CENTER+block; y>=CENTER-block; y--)\n\t{\n\t\tfor(int x=CENTER-block; x<=CENTER+block; x++)\n\t\t{\n\t\t\tcout << caves[y][x] << \"\\t\";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\n\nconst int bottom_x[3] = {-1,0,1};\nconst int bottom_y[3] = {-1,-1,-1};\n/*\n * ?????¢???????????§O(2^sqrt(M))??????O(M)????????´??????\n */\n// First=?????§????´?????????°, Second=??????????????????????´??????????\npair<int,int> search_to_bottom(int &x, int &y)\n{\n\tint num = caves[y][x];\n\tif (num == 0) { return make_pair(0,0); }\n\tif (memo_caves[y][x].first != -1) { return memo_caves[y][x]; }\n\n\tpair<int,int> res_pair(0,0);\n\tfor(int i=0; i<3; i++) {\n\t\tint ax = x + bottom_x[i];\n\t\tint ay = y + bottom_y[i];\n\t\tpair<int,int> a_pair;\n\t\ta_pair = search_to_bottom(ax,ay);\n\t\tres_pair = max(res_pair,a_pair);\n\t}\n\n\tif (is_prime[num]) { \n\t\tif (res_pair.first == 0) { res_pair.second = num; } //????????????????????£????´???°\n\t\tres_pair.first++;\n\t}\n\tmemo_caves[y][x] = res_pair;\n\n\treturn res_pair;\n}\n\n\n\nint main() {\n\tint N,M;\n\t//??¨????????????????????????\n\tis_prime[0] = false;\n\tis_prime[1] = false;\n\tfor(int i = 2; i < PRIME_MAX; i++) { is_prime[i] = true; }\n\tfor(int i = 2; i < PRIME_MAX; i++) {\n\t\tif (is_prime[i]) {\n\t\t\tfor(int j=i+i; j<PRIME_MAX; j+=i) is_prime[j] = false;\n\t\t}\n\t}\n\n\t//UP???????????§????????§?¨?..\n\tMOVE_POINT_OF_ANGLE[UP] = make_pair(0,1);\n\tMOVE_POINT_OF_ANGLE[LEFT] = make_pair(-1,0);\n\tMOVE_POINT_OF_ANGLE[BOTTOM] = make_pair(0,-1);\n\tMOVE_POINT_OF_ANGLE[RIGHT] = make_pair(1,0);\n\n\t//UP?????¨??????????????§?¨?..\n\tLEFT_POINT_OF_ANGLE[UP] = make_pair(-1,0); \n\tLEFT_POINT_OF_ANGLE[LEFT] = make_pair(0,-1);\n\tLEFT_POINT_OF_ANGLE[BOTTOM] = make_pair(1,0);\n\tLEFT_POINT_OF_ANGLE[RIGHT] = make_pair(0,1);\n\n\n\twhile(cin >> M >> N) {\n\t\tif (M == 0 && N == 0) break; //M?????°\n\t\tfill_n((int *)caves, sizeof(caves)/sizeof(int), 0);\n\t\tfill_n((pair<int,int> *)memo_caves, sizeof(memo_caves)/sizeof(pair<int,int>), make_pair(-1,-1));\n\n\t\tvector<pair<int,int> > points(M+1,make_pair(0,0)); //???????????????????????§?¨???????\n\t\tint now_x = CENTER; int now_y = CENTER;\n\t\tint now_angle = BOTTOM;\n\n\t\tfor(int i=1; i<=M; i++)\n\t\t{\n\t\t\tcaves[now_y][now_x] = i;\n\t\t\tpoints[i] = make_pair(now_x,now_y); //???????????????????????§?¨????\n\n\t\t\tpair<int,int> left_point = LEFT_POINT_OF_ANGLE[now_angle];\n\t\t\tint left_x = now_x + left_point.first;\n\t\t\tint left_y = now_y + left_point.second;\n\t\t\tif (caves[left_y][left_x] > 0) { //????????§????????????????????????????????§?????????????????????????????´???\n\t\t\t\t//?????????????????????\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnow_angle = (now_angle + 1) % 4; //0,1,2,3\n\t\t\t}\n\n\t\t\tpair<int,int> move_point = MOVE_POINT_OF_ANGLE[now_angle];\n\t\t\tnow_x = now_x + move_point.first;\n\t\t\tnow_y = now_y + move_point.second;\n\t\t}\n\n\t\t//show();\n\n\t\tpair<int,int> ans_pair = search_to_bottom(points[N].first,points[N].second); //????§?????????§?¨?\n\t\tcout << ans_pair.first << \" \" << ans_pair.second << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\n// difine\ntypedef pair<int, int> pii;\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\n// input\nint m, n;\nbool prime[1010][1010];\nint map[1010][1010];\n\nint med = 1010/2;\nint MAX = (int)1e6;\n\n// method\nbool isPrime(int x) {\n\tfor (int i=2; i*i<=x; i++) if (x%i==0) return false;\n\treturn x>1;\n}\n\nvoid make_map() {\n\tmemset(map, 0, sizeof(map));\n\t\n\tint num = 1, d = 0;\n\tint x = med, y = med;\n\t\n\tfor (int i=1; i<=MAX; i++) {\n\t\tmap[y][x] = num;\n\t\tprime[y][x] = isPrime(num);\n\t\t\n\t\tif (map[y + dy[(d+1)%4]][x + dx[(d+1)%4]]==0) d = (d+1)%4;\n\t\tx += dx[d]; y += dy[d];\n\t\tnum++;\n\t}\n\t\n\t/*\n\tfor (int i=med - 5; i<med + 5; i++) {\t\n\t\tfor (int j=med-5; j<med + 5; j++) {\n\t\t\tprintf(\"%3d \", map[i][j]);\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n}\n\npii dp[1010][1010];\n\nvoid solve() {\n\tfor (int i=0; i<1010; i++) for (int j=0; j<1010; j++) {\n\t\tdp[i][j] = make_pair(-1, 0);\n\t\tif (map[i][j] == n && prime[i][j]) dp[i][j] = make_pair(1, n);\n\t\telse if (map[i][j] == n) dp[i][j] = make_pair(0, 0);\n\t}\n\t\n\tfor (int i=0; i<1009; i++) {\n\t\tfor (int j=0; j<1009; j++) {\n\t\t\tif (dp[i][j].first < 0) continue;\n\t\t\t\n\t\t\tif (map[i+1][j-1] <= m) {\n\t\t\t\tif (prime[i+1][j-1]) {\n\t\t\t\t\tpii nxt(dp[i][j].first + 1, map[i+1][j-1]);\n\t\t\t\t\tdp[i+1][j-1] = max(dp[i+1][j-1], nxt);\n\t\t\t\t} else {\n\t\t\t\t\tdp[i+1][j-1] = max(dp[i+1][j-1], dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (map[i+1][j] <= m) {\n\t\t\t\tif (prime[i+1][j]) {\n\t\t\t\t\tpii nxt(dp[i][j].first + 1, map[i+1][j]);\n\t\t\t\t\tdp[i+1][j] = max(dp[i+1][j], nxt);\n\t\t\t\t} else {\n\t\t\t\t\tdp[i+1][j] = max(dp[i+1][j], dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (map[i+1][j+1] <= m) {\n\t\t\t\tif (prime[i+1][j+1]) {\n\t\t\t\t\tpii nxt(dp[i][j].first + 1, map[i+1][j+1]);\n\t\t\t\t\tdp[i+1][j+1] = max(dp[i+1][j+1], nxt);\n\t\t\t\t} else {\n\t\t\t\t\tdp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpii ans(-1, 0);\n\tfor (int i=0; i<1010; i++) for (int j=0; j<1010; j++) ans = max(ans, dp[i][j]);\n\tcout << ans.first << \" \" << ans.second << endl;\n}\n\nint main() {\n\tmake_map();\n\t\n\twhile (1) {\n\t\tcin >> m >> n; if (m==0 && n==0) break;\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\nusing namespace std;\nconst int MAX = 1000000;\nconst int w = 1010;\nconst int center = w/2;\nvector<vector<int> > caves(w,vector<int>(w,-1));\nvector<int> sosuu(MAX+1,1);\nint n;\nint st;\nint stX;\nint stY;\nvoid makeCaves(){\n  caves = vector<vector<int> >(w,vector<int>(w,-1));\n  int dir = 3;//0 右 1 上 2 左 3 下\n  int dx[4] = {1,0,-1,0};\n  int dy[4] = {0,1,0,-1};\n  int x = center;\n  int y = center;\n  caves[x][y] = 1;\n  if(st == 1){\n    stX = x;\n    stY = y;\n    \n  }\n  for(int i = 2;i <= n;i++){\n    int left = (dir+1)%4;\n    if(caves[dx[left]+x][dy[left]+y] == -1){\n      dir = left;\n    }\n    x = x+dx[dir];\n    y = y+dy[dir];\n    caves[x][y] = i;\n    if(i == st){\n      stX = x;\n      stY = y;\n    }\n  }\n}\nvoid makeSosuu(){\n  sosuu[0] = 0;\n  sosuu[1] = 0;\n  for(int i = 2;i <= MAX;i++){\n    if(sosuu[i]){\n      for(int j = i+i;j <= MAX;j = j+i){\n\tsosuu[j] = 0;\n      }\n    }\n  }\n}/*\nvoid dpSearch(vector<vector<par<int,int> > > &dp,int cx,int cy){\n  \n  \n\n  } */\nint main(){\n  // pair<int,int> dp();\n  makeSosuu();\n  while(true){\n    cin >> n >> st;\n    if(n == 0 && st == 0)break;\n    makeCaves();\n    vector<vector<pair<int,int> > > dp(w,vector<pair<int,int> >(w,pair<int,int>(-1,-1)));\n    int dx[3] = {-1,0,1};\n    int dy[3] = {-1,-1,-1};\n    if(sosuu[st]){\n      dp[stX][stY].first = 1;\n      dp[stX][stY].second = st;\n    }else{\n      dp[stX][stY].first = 0;\n      dp[stX][stY].second = 0;\n    }\n    //    cout << stX-center << \" \" << stY-center << endl;\n    pair<int,int> ans;//(dp[stX][stY].first,dp[stX][stY].second);\n    ans = dp[stX][stY];\n    //    cout << ans.first << \" \" << ans.second << endl;\n    for(int i = stY;i > 0;i--){\n      for(int j = 1;j < 1001;j++){\n\tfor(int k = 0;k <3;k++){\n\t  //cout << i << \" \" << j << endl;\n\t  int nx = j+dx[k];\n\t  int ny = i+dy[k];\n\n\t  if(caves[nx][ny] != -1 && dp[j][i].first != -1){\n\t    if(dp[nx][ny].first < dp[j][i].first + sosuu[caves[nx][ny]]){\n\t      dp[nx][ny].first = dp[j][i].first + sosuu[caves[nx][ny]];\n\t      if(sosuu[caves[nx][ny]]){\n\t\tdp[nx][ny].second = caves[nx][ny];\n\t      }else{\n\t\tdp[nx][ny].second = dp[j][i].second;\n\t      }\n\t      if(ans < dp[nx][ny]){\n\t\tans = dp[nx][ny];\n\t      }\n\t    }\n\t  } \n\t} \n      }\n    }\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nvector<int>prime;\nvoid Prime(){\n    int notPrime[1000002];\n    memset(notPrime,0,sizeof(notPrime));\n    for(int i=2;i<2000;i++)\n        for(int j=i;j*i<1000001;j++)\n            notPrime[j*i]=1;\n    for(int i=2;i<1000002;i++)\n        if(notPrime[i]==0)\n            prime.push_back(i);\n}\nint cav[1010][1010];\nvoid caves(){\n    memset(cav,0,sizeof(cav));\n    int dir=0,x=502,y=502;\n    cav[x][y]=1;\n    for(int i=2;i<1000002;i++){\n        if(dir==0){\n            x++;\n            while(cav[y-1][x]!=0){\n                cav[y][x]=i;\n                x++;i++;\n            }\n            cav[y][x]=i;\n        }\n        else if(dir==1){y--;\n            while(cav[y][x-1]!=0){\n                cav[y][x]=i;\n                y--;i++;\n            }\n            cav[y][x]=i;\n        }\n        else if(dir==2){x--;\n            while(cav[y+1][x]!=0){\n                cav[y][x]=i;\n                x--;i++;\n            }\n            cav[y][x]=i;\n        }\n        else if(dir==3){y++;\n            while(cav[y][x+1]!=0){\n                cav[y][x]=i;\n                y++;i++;\n            }\n            cav[y][x]=i;\n        }\n        dir=(dir+1)%4;\n    }\n}\n\nint dp[1010][1010];\nint visited[1010][1010];\nint mv[3][2]={{-1,1},{0,1},{1,1}};\nint bk[3][2]={{-1,-1},{0,-1},{1,-1}};\nint m,n;\n\nbool check(int ch){\n    if(ch>=0&&ch<1010)\n        return true;\n    return false;\n}\nvoid DP(int xx,int yy){\n    queue<pair<int,int> >que;\n    que.push(make_pair(xx, yy));\n    while(!que.empty()){\n        pair<int,int>pai=que.front();\n        que.pop();\n        int x=pai.first,y=pai.second;\n        if(visited[y][x])\n            continue;\n        for(int b=0;b<3;b++){\n            int mx=x+bk[b][0],my=y+bk[b][1];\n            if(!(check(my)&&check(mx))||cav[my][mx]>m)\n                continue;\n            dp[y][x]=max(dp[y][x],dp[my][mx]);\n        }\n        if(binary_search(prime.begin(),prime.end(),cav[y][x]))\n            dp[y][x]++;\n        for(int i=0;i<3;i++){\n            int nx=x+mv[i][0],ny=y+mv[i][1];\n            if(!(check(ny)&&check(nx))||cav[ny][nx]>m||visited[ny][nx])\n                continue;\n            if(cav[ny][nx]<=m)\n                que.push(make_pair(nx, ny));\n        }\n        visited[y][x]=true;\n    }\n}\nint main(){\n    Prime();\n    caves();\n    int x=0,y=0;\n    while(cin>>m>>n,m){\n        memset(dp,0,sizeof(dp));\n        memset(visited,0,sizeof(visited));\n        for(int i=0;i<1010;i++){\n            for(int j=0;j<1010;j++){\n                if(cav[i][j]==n){\n                    y=i;x=j;\n                    break;\n                }\n            }\n        }\n        DP(x,y);\n        int ans1=0,ans2=0;\n        for(int i=0;i<1010;i++){\n            for(int j=0;j<1010;j++){\n                if(cav[i][j]>m)continue;\n                if(dp[i][j]>ans1){\n                    ans1=dp[i][j];\n                    ans2=cav[i][j];\n                }\n                if(dp[i][j]==ans1&&cav[i][j]>ans2){\n                    if(!binary_search(prime.begin(),prime.end(),cav[i][j]))\n                        continue;\n                    ans1=dp[i][j];\n                    ans2=cav[i][j];\n                }\n            }\n        }\n        if(ans1==0)ans2=0;\n        cout<<ans1<<\" \"<<ans2<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[(SIZE + 1)*(SIZE + 1) + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= (SIZE + 1)*(SIZE + 1);i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= (SIZE + 1)*(SIZE + 1);j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 || n == 0)return 0;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(y=SIZE-1;y>=0;y--){\n\t\t\tfor(x=SIZE-1;x>=0;x--){\n\t\t\t\tif (table[y][x] <= m) {\n\t\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m &&\n\t\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x - 1] || (dp[y][x] == dp[y + 1][x - 1] && pr[y][x] < pr[y + 1][x - 1]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (table[y + 1][x] <= m &&\n\t\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x] || (dp[y][x] == dp[y + 1][x] && pr[y][x] < pr[y + 1][x]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m &&\n\t\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x + 1] || (dp[y][x] == dp[y + 1][x + 1] && pr[y][x] < pr[y + 1][x + 1]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (y = 0;y < SIZE;y++) {\n\t\t\tfor (x = 0;x < SIZE;x++) {\n\t\t\t\tif (table[y][x] == n) {\n\t\t\t\t\tprintf(\"%d\\n\", dp[y][x]);\n\t\t\t\t\t//cout << dp[y][x] << \" \";\n\t\t\t\t\t//cout << pr[y][x] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\n#define N 1050\nusing namespace std;\nint dat[N][N],dp[N][N],ans,ans2;\nint m,n,y,x,p,k,sy,sx,check[N][N];\nint ymin,ymax,xmin,xmax;\nbool prime[N*N];\n\nint main(){\n  int dy[4]={0,-1,0,1};\n  int dx[4]={1,0,-1,0};\n  for(int i=0;i<N*N;i++)prime[i]=true;\n  prime[0]=prime[1]=false;\n  for(int i=0;i<=N*N/2;i++){\n    if(!prime[i])continue;\n    for(int j=i+i;j<N*N;j+=i)prime[j]=false;\n  }\n  while(1){\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)dat[i][j]=-1,dp[i][j]=check[i][j]=0;\n    cin>>m>>n;\n    if(!m&&!n)break;\n    sy=sx=y=x=N/2;\n    dat[y][x]=1;\n    k=ymax=xmax=0,p=1;\n    ymin=xmin=INF;\n    while(p<m){\n      p++;\n      int lot=(k+1)%4;\n      if(p!=2&&dat[y+dy[lot]][x+dx[lot]]<0)k=lot;\n      y+=dy[k];\n      x+=dx[k];\n      dat[y][x]=p;\n      ymin=min(ymin,y);\n      xmin=min(xmin,x);\n      ymax=max(ymax,y);\n      xmax=max(xmax,x);\n      if(p==n)sy=y,sx=x;\n    }\n    check[sy][sx]=1;\n    for(int i=ymin;i<=ymax;i++)\n      for(int j=xmin;j<=xmax;j++){\n\tif(!check[i][j])continue;\n\tcheck[i+1][j-1]=check[i+1][j]=check[i+1][j+1]=1;\n      }\n    ans=0;\n    for(int i=ymin;i<=ymax;i++){\n      for(int j=xmin;j<=xmax;j++){\n\tif(dat[i][j]<0||!check[i][j])continue;\n\tif(prime[dat[i][j]])dp[i][j]++;\n\tans=max(ans,dp[i][j]);\n\tdp[i+1][j-1]=max(dp[i+1][j-1],dp[i][j]);\n\tdp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n\tdp[i+1][j+1]=max(dp[i+1][j+1],dp[i][j]);\n      }\n    }\n    ans2=0;\n    for(int i=ymin;i<=ymax;i++){\n      for(int j=xmin;j<=xmax;j++){\n\tif(prime[dat[i][j]]&&check[i][j]&&ans==dp[i][j])ans2=max(ans2,dat[i][j]);\n      }\n    }\n    if(ans!=0)cout<<ans<<' '<<ans2<<endl;\n    else cout<<0<<' '<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <fstream>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint dp[1003][1003];\nint visit[1003][1003];\nint cave[1003][1003] = { 0 };\nconst int dx[4] = { 1, 0, -1,  0 };\nconst int dy[4] = { 0, -1,  0, 1 };\n\nint main() {\n\tifstream fin(\"input.txt\");\n\tofstream fout(\"output.txt\");\n\n\t//1~1000000の内素数ならtrue素数でないならfalse\n\tstatic int isPrime[1000001];\n\tfor (int i = 0; i < 1000001; i++) {\n\t\tisPrime[i] = 1;\n\t}\n\tisPrime[0] = 0;\n\tisPrime[1] = 0;\n\tfor (int i = 2; i <= 1000; i++) {\n\t\tif (isPrime[i]) {\n\t\t\tfor (int j = 2; i * j < 1000001; j++) {\n\t\t\t\tisPrime[i * j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tint c = 1, d = 0;\n\tint x = 500, y = 500;\n\tbool end = false;\n\twhile (true) {\n\t\tfor (int dir = 0; dir < 4; dir++) {\n\t\t\tif (dir % 2 == 0) d++;\n\t\t\tfor (int cnt = 1; cnt <= d; cnt++) {\n\t\t\t\tcave[x][y] = c;\n\t\t\t\tif (c == 1000000) {\n\t\t\t\t\tend = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tc++;\n\t\t\t\tx = x + dx[dir];\n\t\t\t\ty = y + dy[dir];\n\t\t\t}\n\t\t\tif (end) break;\n\t\t}\n\t\tif (end) break;\n\t}\n\n\tint all, num = 0, first, last = 0, f_x, f_y, l_x, l_y;\n\tcin >> all >> first;\n\n\tfor (int j = 0; j < 1003; j++) {\n\t\tfor (int i = 0; i < 1003; i++) {\n\t\t\tdp[i][j] = 0;\n\t\t\tvisit[i][j] = 0;\n\t\t\tif (cave[i][j] == first) {\n\t\t\t\tf_x = i;\n\t\t\t\tf_y = j;\n\t\t\t\tvisit[i][j] = 1;\n\t\t\t\tif (isPrime[first] == 1) dp[i][j] = 1;\n\t\t\t}\n\t\t\tif (cave[i][j] == all) {\n\t\t\t\tl_x = i;\n\t\t\t\tl_y = j;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int y = f_y + 1; y <= 1002; y++) {\n\t\tfor (int x = 1; x <= 1002; x++) {\n\t\t\tif (cave[x][y] <= all && cave[x][y] != 0) {\n\t\t\t\tif (!(visit[x - 1][y - 1] == 0 && visit[x][y - 1] == 0 && visit[x + 1][y - 1] == 0)) {\n\t\t\t\t\tdp[x][y] = max(visit[x - 1][y - 1] * dp[x - 1][y - 1], max(visit[x][y - 1] * dp[x][y - 1], visit[x + 1][y - 1] * dp[x + 1][y - 1]))\n\t\t\t\t\t\t+ isPrime[cave[x][y]];\n\t\t\t\t\tvisit[x][y] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int y = f_y; y <= 1002; y++) {\n\t\tfor (int x = 1; x <= 1002; x++) {\n\t\t\tnum = max(num, dp[x][y]);\n\t\t}\n\t}\n\n\tif (num != 0) {\n\tfor (int y = f_y; y <= 1002; y++) {\n\t\tfor (int x = 1; x <= 1002; x++) {\n\t\t\t\tif (dp[x][y] == num && isPrime[cave[x][y]] == 1) {\n\t\t\t\t\tlast = max(last, cave[x][y]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << num << \" \" << last << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst int N = 1111111;\nbool prime[N];\nvector<int> primes;\n\nvoid hurui()\n{\n\tmemset(prime, true, sizeof(prime));\n\tprime[0] = prime[1] = false;\n\tfor (int i = 2; i*i < N; i++)\n\t{\n\t\tfor (int j = 2; i*j < N; j++)\n\t\t{\n\t\t\tprime[i*j] = false;\n\t\t}\n\t}\n\tREP(i, N + 1)\n\t{\n\t\tif (prime[i]) primes.push_back(i);\n\t}\n}\n\nint m, n;\nbool fld[1200][1200];\npii id[1111111];\nint hs[1200][1200];\n\nvoid init()\n{\n\tint tx = 600, ty = 600, t = 1;\n\tFOR(i, 1, INF)\n\t{\n\t\tif (t > 1000001) break;\n\t\tif (i % 2)\n\t\t{\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tid[t] = pii(tx, ty);\n\t\t\t\ths[tx][ty] = t;\n\t\t\t\tt++;\n\t\t\t\tty++;\n\t\t\t}\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tid[t] = pii(tx, ty);\n\t\t\t\ths[tx][ty] = t;\n\t\t\t\tt++;\n\t\t\t\ttx--;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tid[t] = pii(tx, ty);\n\t\t\t\ths[tx][ty] = t;\n\t\t\t\tt++;\n\t\t\t\tty--;\n\t\t\t}\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tid[t] = pii(tx, ty);\n\t\t\t\ths[tx][ty] = t;\n\t\t\t\tt++;\n\t\t\t\ttx++;\n\t\t\t}\n\t\t}\n\t}\n}\n\npii dp[1200][1200];\n\npii solve(int x, int y)\n{\n\tif (x == 1199) return pii(0, 0);\n\tif (dp[x][y].first >= 0) return dp[x][y];\n\tpii res(0, 0);\n\tif (fld[x + 1][y - 1])\n\t{\n\t\tpii tmp = solve(x + 1, y - 1);\n\t\tchmax(res, pii(tmp.first + 1, (tmp.second==0?hs[x + 1][y - 1]:tmp.second)));\n\t}\n\telse\n\t{\n\t\tchmax(res, pii(solve(x + 1, y - 1).first, solve(x + 1, y - 1).second));\n\t}\n\n\tif (fld[x + 1][y])\n\t{\n\t\tpii tmp = solve(x + 1, y);\n\t\tchmax(res, pii(tmp.first + 1, (tmp.second == 0 ? hs[x + 1][y] : tmp.second)));\n\t}\n\telse\n\t{\n\t\tchmax(res, pii(solve(x + 1, y).first, solve(x + 1, y).second));\n\t}\n\n\tif (fld[x + 1][y + 1])\n\t{\n\t\tpii tmp = solve(x + 1, y + 1);\n\t\tchmax(res, pii(tmp.first + 1, (tmp.second == 0 ? hs[x + 1][y + 1] : tmp.second)));\n\t}\n\telse\n\t{\n\t\tchmax(res, pii(solve(x + 1, y + 1).first, solve(x + 1, y + 1).second));\n\t}\n\treturn dp[x][y] = res;\n}\n\nint main()\n{\n\thurui();\n\tinit();\n\twhile (cin >> n >> m, n)\n\t{\n\t\tREP(i, 1200)REP(j, 1200)\n\t\t{\n\t\t\tfld[i][j] = false;\n\t\t\tdp[i][j] = pii(-1, -1);\n\t\t}\n\t\tREP(i, primes.size())\n\t\t{\n\t\t\tif (primes[i] > n) break;\n\t\t\tint x = id[primes[i]].first, y = id[primes[i]].second;\n\t\t\tfld[x][y] = true;\n\t\t}\n\t\tpii ans = solve(id[m].first, id[m].second);\n\t\tif (find(ALL(primes), m) != primes.end())\n\t\t{\n\t\t\tif(ans.second==0) cout << ans.first + 1 << \" \" << m << endl;\n\t\t\telse cout << ans.first + 1 << \" \" << ans.second << endl;\n\t\t}\n\t\telse cout << ans.first << \" \" << ans.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing vvvint = vector<vvint>;\nusing vdouble = vector<double>;\nusing vvdouble = vector<vdouble>;\nusing vvvdouble = vector<vvdouble>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing uint = unsigned int;\nusing ull = unsigned long long;\n\ntemplate<typename T> using uset = unordered_set<T>;\ntemplate<typename T1, typename T2> using umap = unordered_map<T1, T2>;\n\nconstexpr int INF = (1 << 30) - 1;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\nconstexpr int dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr char el = '\\n';\nconstexpr int mod = 1000000007;\n\ntemplate<typename T> T gcd(T a, T b) { return (b ? gcd(b, a % b) : a); }\ntemplate<typename T> T lcm(T a, T b) { return (a / gcd(a, b) * b); }\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, T2 b) { return (a > b && (a = b, true)); }\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, T2 b) { return (a < b && (a = b, true)); }\n\ntemplate<typename T>\nostream& operator <<(ostream &os, vector<T> &v) {\n\tos << v[0];\n\tfor (int i = 1; i < v.size(); i++) os << \" \" << v[i];\n\treturn (os);\n}\n\ntemplate<typename T>\nistream& operator >>(istream &is, vector<T> &v) {\n\tfor (auto &u : v) is >> u; return (is);\n}\n\ntemplate<typename T1, typename T2>\nistream& operator >>(istream &is, pair<T1, T2> &p) {\n\treturn (is >> p.first >> p.second);\n}\n\nbitset<1000005> prime;\n\nint idx[3005][3005];\nbool solve() {\n\tmemset(idx, -1, sizeof(idx));\n\tint off = 1500;\n\n\tint M, N; cin >> M >> N;\n\tif (M == 0 && N == 0) return (false);\n\tvector<Pi> point(M+1);\n\n\tidx[off][off] = 1;\n\tpoint[1] = Pi(0, 0);\t\n\n\tint cnt = 2;\n\tPi now = Pi(1, 0);\n\tfor (int i = 2; cnt <= M; i += 2) {\n\t\tfor (int j = 0; cnt <= M && j < i-1; j++) {\n\t\t\tidx[now.second+off][now.first+off] = cnt;\n\t\t\tpoint[cnt] = now;\n\t\t\tnow.second--;\n\t\t\tcnt++;\n\t\t}\n\t\tfor (int j = 0; cnt <= M && j < i; j++) {\n\t\t\tidx[now.second+off][now.first+off] = cnt;\n\t\t\tpoint[cnt] = now;\n\t\t\tnow.first--;\n\t\t\tcnt++;\n\t\t}\n\t\tfor (int j = 0; cnt <= M && j < i; j++) {\n\t\t\tidx[now.second+off][now.first+off] = cnt;\n\t\t\tpoint[cnt] = now;\n\t\t\tnow.second++;\n\t\t\tcnt++;\n\t\t}\n\t\tfor (int j = 0; cnt <= M && j < i+1; j++) {\n\t\t\tidx[now.second+off][now.first+off] = cnt;\n\t\t\tpoint[cnt] = now;\n\t\t\tnow.first++;\n\t\t\tcnt++;\n\t\t}\n\t}\n\t\n\t//cout << \"A\" << endl;\n\tvvint G(M+1);\n\tfor (int i = 1; i <= M; i++) {\n\t\tint kx[3] = {-1, 0, 1};\n\t\tint ky[3] = {1, 1, 1};\n\t\tint y = point[i].second;\n\t\tint x = point[i].first;\n\t\t//cout << i << \" : \" << y << \" \" << x << endl;\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tint ny = y + ky[j];\n\t\t\tint nx = x + kx[j];\n\t\t\tif (idx[ny+off][nx+off] != -1) {\n\t\t\t\tG[i].push_back(idx[ny+off][nx+off]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<Pi> dp(M+1, Pi(-INF, -INF));\n\tif (prime[N]) dp[N] = Pi(1, N);\n\telse dp[N] = Pi(0, -INF);\n\n\tqueue<int> que;\n\tque.push(N);\n\tPi maxv = dp[N];\n\twhile (!que.empty()) {\n\t\tint u = que.front(); que.pop();\n\t\t//cout << u << endl;\n\t\tfor (auto &v : G[u]) {\n\t\t\tPi nval;\n\t\t\t//cout << v << endl;\n\t\t\tnval = dp[u];\n\t\t\tif (prime[v]) {\n\t\t\t\tnval.first = dp[u].first+1;\n\t\t\t\tnval.second = v;\n\t\t\t}\n\t\t\tif (dp[v] < nval) {\n\t\t\t\tdp[v] = nval;\n\t\t\t\tque.push(v);\n\t\t\t\tchmax(maxv, dp[v]);\n\t\t\t}\n\t\t}\n\t}\t\n\tif (maxv.first == 0) cout << \"0 0\" << endl;\n\telse cout << maxv.first << \" \" << maxv.second << endl;\n\treturn (true);\n}\n\nvoid Main() {\n\tprime = ~prime;\n\tprime[0] = false;\n\tprime[1] = false;\n\tfor (int i = 2; i*i <= 1000000; i++) {\n\t\tif (!prime[i]) continue;\n\t\tfor (int j = i*i; j <= 1000000; j += i) {\n\t\t\tprime[j] = false;\n\t\t}\n\t}\n\n\twhile (solve());\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout << fixed << setprecision(20);\n\tMain();\n\treturn (0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\n\n#define MAX 1000000\nint m,n;\nint caves[1000][1000];\n\nint isPrime[MAX+1];\nvoid sieve(){\n  isPrime[0] = isPrime[1] = false;\n  for(int i=2;i<=MAX;i++)\n    isPrime[i] = true;\n  for(int i=2;i<=MAX;i++)\n    if(isPrime[i])\n      for(int j=i*2;j<=MAX;j+=i)\n\tisPrime[j]=false;\n}\n\nint Pow[1000];\nvoid mkcaves(){\n  Pow[0]=1;\n  for(int i=1;i<1000;i++)\n    Pow[i] = Pow[i-1] + 2*i + 1;\n  int x=499,y=500;\n  for(int i=1;i<=1000;i++){\n    if(i%2){\n      for(int j=Pow[i-1]-2*i+2;j<=Pow[i-1]-i;j++)\n\tcaves[x][y++]=isPrime[j]?j:j*-1;\n      for(int j=Pow[i-1]-i+1;j<=Pow[i-1];j++)\n\tcaves[x++][y]=isPrime[j]?j:j*-1;\n    }\n    else{\n      for(int j=Pow[i-1]+-2*i+2;j<=Pow[i-1]-i;j++)\n\tcaves[x][y--]=isPrime[j]?j:j*-1;\n      for(int j=Pow[i-1]-i+1;j<=Pow[i-1];j++)\n\tcaves[x--][y]=isPrime[j]?j:j*-1;\n    }\n  }\n}\n\nvoid print(int ary[1000][1000]){\n    for(int i=500-sqrt(m)/2+1;i<500+sqrt(m)/2;i++){\n      for(int j=500-sqrt(m)/2;j<500+sqrt(m)/2-1;j++)\n\tprintf(\"%3d \",ary[j][i]);\n      putchar('\\n');\n    } \n}\n\nint max3(int a,int b,int c){\n  int max = a;\n  if (b > max) max = b;\n  if (c > max) max = c;\n  return max;\n}\n\nint dp[1000][1000];\nint cp[1000][1000];\nvoid solve(){\n  //copy caves\n  rep(i,1000)\n    rep(j,1000)\n      cp[j][i] = (0<caves[j][i] && caves[j][i]<=m);\n\n  //print(cp);\n\n  //reset dp\n  rep(i,1000)\n    rep(j,1000)\n      dp[j][i]=0;\n  \n  if(!isPrime[n])\n    n*=-1;\n\n  int sx,sy;\n  bool f = false;\n  rep(i,1000){\n    rep(j,1000){\n      if(caves[j][i]==n){\n\tsx = j;\n\tsy = i;\n\tf = true;\n\tbreak;\n      }\n    }\n    if(f)\n      break;\n  }\n  //printf(\"start = (%d,%d)\\n\",sx,sy);\n\n  dp[sx][sy] = cp[sx][sy];\n  int nmax=0;\n  for(int i=1;i<=sqrt(m)+1 && sy+i < 1000; i++){\n    int jmin=-i,jmax=i;\n    if(sx+jmin<=0){\n      dp[0][sy+i] = cp[0][sy+i]\t+ max(dp[0][sy+i-1], dp[1][sy+i-1]);\n      if(dp[0][sy+i] > nmax)\n\tnmax = dp[0][sy+i];\n      jmin=1-sx;\n    }\n    if(sx+jmax>=999){\n      dp[999][sy+i] = cp[999][sy+i]+ max(dp[998][sy+i-1], dp[999][sy+i-1]);\n      if(dp[999][sy+i] > nmax)\n\tnmax = dp[999][sy+i];\n      jmax=998-sx;\n    }\n    for(int j=jmin;j<=jmax;j++){\n      dp[sx+j][sy+i] = cp[sx+j][sy+i]\n\t+ max3(dp[sx+j-1][sy+i-1], dp[sx+j][sy+i-1], dp[sx+j+1][sy+i-1]);\n      if(dp[sx+j][sy+i] > nmax)\n\tnmax = dp[sx+j][sy+i];\n    }\n  }\n  //puts(\"~nmax\");\n\n  int pmax=0;\n  for(int i=0; i<sqrt(m)+1 && sy+i<1000; i++){\n    int jmin=-i,jmax=i;\n    if(sx+jmin<=0){\n      //      dp[0][sy+i] = cp[0][sy+i]\n      //\t+ max(dp[0][sy+i-1], dp[1][sy+i-1]);\n      jmin=1-sx;\n    }\n    if(sx+jmax>=999){\n      //dp[999][sy+i] = cp[999][sy+i]\n      //\t+ max(dp[998][sy+i-1], dp[999][sy+i-1]);\n      jmax=998-sx;\n    }\n    for(int j=jmin;j<=jmax;j++){\n      if(cp[sx+j][sy+i] && dp[sx+j][sy+i]==nmax && pmax<caves[sx+j][sy+i])\n\tpmax = caves[sx+j][sy+i];\n    }\n  }\n  //puts(\"~pmax\");\n  \n  //print(dp);\n  \n  printf(\"%d %d\\n\",nmax,pmax);\n}\n\nint main(){\n  sieve();\n  mkcaves();\n  for(;;){\n    scanf(\"%d %d\",&m,&n);\n    if(!(m+n)) break;\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint si = 0, sj = 0;\nvector<int> isp;\n\npair<int, int> toij(int p) {\n    int u = 1;\n    while (u * u < p)\n        ++u;\n\n    if (u % 2 == 0) {\n        int ui = si - u / 2;\n        int uj = sj - u / 2 + 1;\n        if (u * (u - 1) < p) {\n            return make_pair(ui, uj + (u * u - p));\n        }\n        else {\n            return make_pair(ui + (u * (u - 1) - p) + 1, uj + u - 1);\n        }\n    }\n    else {\n        int ui = si + u / 2;\n        int uj = sj + u / 2;\n        if (u * (u - 1) < p) {\n            return make_pair(ui, uj - (u * u - p));\n        }\n        else {\n            return make_pair(ui - (u * (u - 1) - p) - 1, uj - u + 1);\n        }\n    }\n}\nint tov(int pi, int pj) {\n    int dma = max(abs(pi - si), abs(pj - sj));\n    int u = dma * 2;\n    if (pi == si + dma) {\n        return (u + 1) * (u + 1) - (sj + dma - pj);\n    }\n    if (pj == sj - dma) {\n        return u * u + (pi - (si - dma) + 1);\n    }\n    if (pi == si - dma) {\n        return u * u - (pj - (sj - dma + 1));\n    }\n    if (pj == sj + dma) {\n        return u * (u - 1) + ((si - dma + 1) - pi);\n    }\n\n}\nvoid sieve(int n) {\n    isp.resize(n, 1);\n    for (int i = 2; i * i < n; ++i)\n    {\n        if (!isp[i]) continue;\n\n        for (int j = i * i; j < n; j += i)\n        {\n            isp[j] = 0;\n        }\n    }\n}\n\nint main()\n{\n    sieve(1000010);\n    while (true)\n    {\n        int m, n;\n        cin >> m >> n;\n        if (!m) return 0;\n\n        vector<int> ma(m + 1, -1);\n        vector<int> lp(m + 1);\n        queue<int> q;\n        q.push(n);\n        ma[n] = isp[n];\n        lp[n] = isp[n] ? n : 0;\n        int ansi = 0, ansj = 0;\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            auto p = toij(v);\n            int pi = p.first, pj = p.second;\n            int next = 0;\n            for (int j = pj - 1; j <= pj + 1; ++j) {\n                int nv = tov(pi + 1, j);\n                if (nv > m) continue;\n\n                next = 1;\n                if (ma[nv] < 0)\n                    q.push(nv);\n\n                if (ma[nv] < ma[v] + isp[nv]) {\n                    ma[nv] = ma[v] + isp[nv];\n                    lp[nv] = isp[nv] ? nv : lp[v];\n                }\n                else if (ma[nv] == ma[v] + isp[nv]) {\n                    lp[nv] = max(lp[nv], isp[nv] ? nv : lp[v]);\n                }\n            }\n            if (!next) {\n                if (ansi < ma[v]) {\n                    ansi = ma[v];\n                    ansj = lp[v];\n                }\n                else if (ansi == ma[v] && ansj < lp[v]) {\n                    ansj = lp[v];\n                }\n            }\n        }\n        cout << ansi << \" \" << ansj << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\n\n#define all(v) v.begin(),v.end()\n#define INF 1<<30\n#define mp make_pair\n#define pb push_back\n\n#define fi first\n#define se second\n\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\ntypedef long long ll;\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nint s[1020][1010];\n\nbool is_prime(int n){\n\tif(n==0) return false;\n\tfor(int i=2;i*i<=n;i++){\n\t\tif(n%i==0){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(1){\n\t\tint m,n;\n\t\tcin>>m>>n;\n\t\tif(m==0) break;\n\t\tint w = ceil(sqrt(m));\n\t\tw = (w%2==0)? w+1:w; \n\t\tint h = w;\n\t\tint sx = w/2;\n\t\tint sy = w/2;\n\t\tint dir = 0;\n\t\tint cnt = 2;\n\t\ts[sy][sx]=1;\n\t\tREP(i,1,w){\n\t\t\trep(k,2){\n\t\t\t\trep(j,i){\n\t\t\t\t\tsx = sx+dx[dir%4];\n\t\t\t\t\tsy = sy+dy[dir%4];\n\t\t\t\t\ts[sy][sx] = cnt;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tif(cnt==m) goto END;\n\t\t\t\t}\n\t\t\t\tdir++;\n\t\t\t}\n\t\t}\n\t\tEND:;\n\t\trep(y,h){\n\t\t\trep(x,w){\n\t\t\t\t// printf(\"%2d \",s[y][x]);\n\t\t\t\tif(s[y][x]==n){\n\t\t\t\t\tsy = y;\n\t\t\t\t\tsx = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// cout << endl;\n\t\t}\n\t\tpii dp[1020][1020];\n\t\trep(y,1000){\n\t\t\trep(x,1000){\n\t\t\t\tdp[y][x] = mp(0,0);\n\t\t\t}\n\t\t}\n\t\tfor (int y = h; y >= sy; --y)\n\t\t{\n\t\t\tfor(int x = 0;x<w;++x){\n\t\t\t\trep(i,3){\n\t\t\t\t\tif(x+i-1<0||x+i-1>=w) continue;\n\t\t\t\t\tif(dp[y][x].fi < dp[y+1][x+i-1].fi){\n\t\t\t\t\t\tdp[y][x].fi = dp[y+1][x+i-1].fi;\n\t\t\t\t\t\tdp[y][x].se = dp[y+1][x+i-1].se;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(is_prime(s[y][x])){\n\t\t\t\t\tdp[y][x].fi++;\n\t\t\t\t\tif(dp[y][x].se==0) dp[y][x].se = s[y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// rep(y,h){\n\t\t// \trep(x,w){\n\t\t// \t\tprintf(\"%2d \",dp[y][x].fi);\n\t\t// \t}\n\t\t// \tcout << endl;\n\t\t// }\n\t\tcout << dp[sy][sx].fi << \" \"<<dp[sy][sx].se<< endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define MAX_N 1000000\n#define MAX_X 1001\n#define MAX_Y 1000\n\nint cave[MAX_Y][MAX_X];\nbool sieve[MAX_N+1];\nint dp[MAX_N+1];\n\nint m, n;\n\nstruct P { int x, y; };\n\nP search_cave(int n) {\n    REP(y, MAX_Y) REP(x, MAX_X) {\n        if (cave[y][x] == n) {\n            return (P){x, y};\n        }\n    }\n    return (P){0, 0}; // fail\n}\n\nint main() {\n    sieve[0] = sieve[1] = true;\n    FOR(i, 2, MAX_N+1) {\n        if (sieve[i]) continue;\n        for (int j = i + i; j < MAX_N+1; j += i) {\n            sieve[j] = true;\n        }\n    }\n\n    int ul = 1000001; // upper left: 1000^2 + 1 = 1000001\n    REP(i, MAX_Y) {\n        cave[i][0] = ul + i;\n    }\n    // left -> down -> right -> up ->\n    int d = 0;\n    int dx[] = {1, 0, -1, 0}; int dy[] = {0, 1, 0, -1};\n    int x = 0, y = 0;\n    while (ul > 1) {\n        int sx = x + dx[d];\n        int sy = y + dy[d];\n        if (0 <= sx && sx < MAX_X && 0 <= sy && sy < MAX_Y && cave[sy][sx] == 0) {\n            x = sx;\n            y = sy;\n            ul--;\n            cave[y][x] = ul;\n        } else {\n            d = (d + 1) & 3; // d % 4\n        }\n    }\n\n    while (cin >> m >> n, m|n) {\n        fill_n(dp, MAX_N+1, -1);\n        P s = search_cave(n);\n        dp[n] = 0;\n        int max_primes = 0, max_cave = 0;\n        FOR(y, s.y, MAX_Y) REP(x, MAX_X) {\n            int c = cave[y][x];\n            if (c > m || dp[c] < 0) continue;\n            if (!sieve[c]) { // prime\n                dp[c]++;\n                if (max_primes <= dp[c]) {\n                    max_primes = dp[c];\n                    max_cave = c;\n                }\n            }\n            for (int dx = -1; dx <= 1; dx++) {\n                int sx = x + dx;\n                int sy = y + 1;\n                if (0 <= sx && sx < MAX_X && 0 <= sy && sy < MAX_Y) {\n                    int c2 = cave[sy][sx];\n                    if (c2 <= m) {\n                        dp[c2] = max(dp[c2], dp[c]);\n                    }\n                }\n            }\n        }\n        cout << max_primes << \" \" << max_cave << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <string>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <cstdio>\n#include <cassert>\n#include <cinttypes>\n\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef int64_t i64;\ntypedef uint64_t u64;\n\nconst i64 INF = 1e18 + 10;\n\ntypedef pair<int, int> P;\ninline P operator+(const P& p1, const P& p2) {\n  return P(p1.first + p2.first, p1.second + p2.second);\n}\n\nint cave[1101][1101];\n\nvoid MakeCave(int n) {\n  memset(cave, 0, sizeof(cave));\n\n  int y = 501;\n  int x = 501;\n\n  int dy[4] = { 1, 0, -1, 0 };\n  int dx[4] = { 0, 1, 0, -1 };\n\n  int dir = 0;\n  for (int i = 1; i <= n; i++) {\n    cave[y][x] = i;\n\n    int ny = y + dy[(dir + 1) % 4];\n    int nx = x + dx[(dir + 1) % 4];\n    if (ny < 0 || ny >= 1100 || nx < 0 || nx >= 1100 || cave[ny][nx] == 0) {\n      y = ny;\n      x = nx;\n      dir = (dir + 1) % 4;\n    } else {\n      y = y + dy[dir];\n      x = x + dx[dir];\n    }\n  }\n}\n\nbool IsPrime(int num) {\n  static bool is_prime[1000001];\n\n  static bool init = false;\n\n  if (!init) {\n    fill(is_prime, is_prime + 1000001, true);\n    init = true;\n    is_prime[0] = false;\n    is_prime[1] = false;\n    for (int i = 2; i * i < 1000001; i++) {\n      if (is_prime[i]) {\n        for (int j = 2; i * j < 1000001; j++) {\n          is_prime[i * j] = false;\n        }\n      }\n    }\n  }\n\n  return is_prime[num];\n}\n\nP Solve(int n, int m) {\n  int start_y = -1;\n  int start_x = -1;\n\n  for (int i = 0; start_x == -1 && i < 1101; i++) {\n    for (int j = 0; start_x == -1 && j < 1101; j++) {\n      if (cave[i][j] == m) {\n        start_y = i;\n        start_x = j;\n      }\n    }\n  }\n\n  struct Search {\n    int y, x;\n    int prime;\n    int count;\n    Search(): y(-1), x(-1), prime(0), count(0) { }\n    Search(int y, int x, int prime, int count):\n      y(y), x(x), prime(prime), count(count) { }\n  };\n\n  int dy[3] = {  1, 1, 1 };\n  int dx[3] = { -1, 0, 1 };\n\n  static bool checked[1101][1101];\n  static Search memo[1101][1101];\n  memset(checked, false, sizeof(checked));\n\n  function<Search(int, int)> dfs = [&](int y, int x) {\n    if (checked[y][x]) {\n      return memo[y][x];\n    }\n\n    if (cave[y][x] == 0) {\n      return Search(y, x, 0, 0);\n    }\n\n    Search s(y, x, 0, 0);\n    if (IsPrime(cave[y][x])) {\n      s.count++;\n      s.prime = cave[y][x];\n    }\n\n    int count = 0;\n    int prime = s.prime;\n    for (int i = 0; i < 3; i++) {\n      int ny = y + dy[i];\n      int nx = x + dx[i];\n\n      Search t = dfs(ny, nx);\n      if (t.count > count) {\n        count = t.count;\n        prime = t.prime;\n      }\n    }\n\n    s.count += count;\n    s.prime = prime;\n\n    checked[y][x] = true;\n    memo[y][x] = s;\n\n    return s;\n  };\n\n  Search ans = dfs(start_y, start_x);\n\n  return P(ans.count, ans.prime);\n}\n\nint main() {\n  while (true) {\n    int n, m;\n    cin >> n >> m;\n    if (n + m == 0) {\n      break;\n    }\n    MakeCave(n);\n    P ans = Solve(n, m);\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef pair<int, int> P ;\nbool prime[2160000];\nint val[1200][1200];\nP dp[1200][1200];\nint xs[] = {1, 0, -1, 0}, ys[] = {0, 1, 0, -1};\n\n\nbool solve(){\n  int m, n;\n  cin >> m >> n;\n  if(m == 0 && n == 0)return false;\n  for(int i = 0;i < 1200;i++)\n    for(int j = 0;j < 1200;j++)\n      dp[i][j] = P(0, 0);\n  for(int j = 1;j < 1100;j++){\n    for(int i = 1;i < 1100;i++){\n      dp[i][j] = max(dp[i][j-1], dp[i-1][j-1]);\n      dp[i][j] = max(dp[i][j], dp[i+1][j-1]);\n      if(prime[val[i][j]] && 1 <= val[i][j]  && val[i][j] <= m){\n\tif(dp[i][j].first == 0){\n\t  dp[i][j].second = val[i][j];\n\t}\n\tdp[i][j].first++;\n      }\n      if(val[i][j] == n){\n\tcout << dp[i][j].first << \" \" << dp[i][j].second << endl;\n\treturn true;\n      }\n    }\n  }\n}\n\nint main(){\n  fill(prime, prime + 1080000, true);\n  prime[0] = prime[1] = false;\n  for(int i = 2;i  < 1080000;i++){\n    if(prime[i]){\n      for(long long j = (long long)i * i;j < 1080000;j += i)\n\tprime[j] = false;\n    }\n  }\n  for(int i = 0, p = 1, x = 550, y = 550;i < 2000;i++){\n    if(p >= 1080000)break;\n    for(int j = 0;j < (i / 2) + 1;j++){\n      if(p >= 1080000)break;\n      val[x][y] = p++;\n      x += xs[i % 4];\n      y += ys[i % 4];\n    }\n  }\n  while(solve());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define SIZE 1000\n\nbool C(int dp1, int pr1, int dp2, int pr2) {\n\tif (dp2 == 0)return false;\n\tif (dp1 < dp2 || (dp1 == dp2&&pr1 < pr2))return true;\n\treturn false;\n}\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool complete;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i <= SIZE&&a <= SIZE*SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x--;\n\t\t\telse x++;\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t\tcomplete = false;\n\t\twhile (!complete) {\n\t\t\twhile (x >= 0 && !complete) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x - 1], pr[y + 1][x - 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x], pr[y + 1][x])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x + 1], pr[y + 1][x + 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (table[y][x] == n)complete = true;\n\t\t\t\telse x--;\n\t\t\t}\n\t\t\tif (!complete) {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<int(b); i++)\n#define rep(i,n) loop(i,0,n)\n#define all(c) (c).begin(), (c).end()\ntypedef complex<int> P;\n\nconst int MAX_M = 1.5e6+10;\nconst int SIZE = 2000;\nint ps[MAX_M/2];\nbool isp[MAX_M];\nint grid[SIZE][SIZE]={};\nP itop[MAX_M];\npair<int,int> dp[SIZE][SIZE];\n\nint cnt_p = 0;\n\nvoid make_es(){\n    fill(isp,isp+MAX_M,true);\n    isp[0]=isp[1]=false;\n    rep(i,MAX_M){\n        if(!isp[i]) continue;\n        ps[cnt_p++] = i;\n        for(int j=i<<1; j<MAX_M; j+=i){\n            isp[j] = false;\n        }\n    }\n}\n\nP const ii(0,1);\n\nint n,m;\n\npair<int,int> rec(int y, int x){\n    if(dp[y][x].first!=-1) return dp[y][x];\n\n    pair<int,int> best(0,0);\n    loop(i,-1,2){\n        if(grid[y+1][x+i]<=m){\n            auto t = rec(y+1,x+i);\n            best = max(t,best);\n        }\n    }\n\n    pair<int,int> res(0,0);\n    if(isp[grid[y][x]]){\n        res.first = 1;\n        res.second = grid[y][x];\n    }\n    if(best.first != 0){\n        res.first += best.first;\n        res.second = best.second;\n    }\n\n    dp[y][x] = res;\n    return res;\n}\n\nint main(){\n    make_es();\n    P p(SIZE/2,SIZE/2);\n    P dir(0,1);\n    for(int i=1; i<MAX_M; i++){\n        grid[p.real()][p.imag()] = i;\n        itop[i]=p;\n        p+=dir;\n        P q = p+dir*ii;\n        if(grid[q.real()][q.imag()] == 0){\n            dir*=ii;\n        }\n    }\n\n    while(cin>>m>>n, n+m){\n        auto t = make_pair(-1,-1);\n        rep(i,SIZE)rep(j,SIZE) dp[i][j] = t;\n        auto u = itop[n];\n        auto ans = rec(u.real(), u.imag());\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> P;\n#define F first\n#define S second\nint fie[1111][1111];\nint N,M;\nint sosu[1000001];\nP mie[1000001];\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\n\nP dp[1111][1111];\nint ndx[]={1,0,-1};\nP solve(int x,int y,int ss){\n  if(dp[x][y].F!=-1) return dp[x][y];\n  if(fie[x][y]>N ||  fie[x][y] == -1 ){\n    return P(0,ss);\n  }\n  P ret = P(0,0);\n  for(int i=0;i<3;i++){\n    int nx = x+ndx[i];\n    int ny = y+1;\n    if(fie[nx][ny]>N || fie[nx][ny] == -1 ){\n      P state = solve(nx,ny,ss);\n      ret = max(ret,state);\n    } else if(!sosu[fie[nx][ny]]){\n      P state = solve(nx,ny,fie[nx][ny]);\n      state.F ++;\n      ret = max(ret,state);\n    } else {\n      P state = solve(nx,ny,ss);\n      ret = max(ret,state);\n    }\n  }\n  // printf(\"%d dp[%d][%d] =  %d, %d fie=%d\\n\",ss,x,y,ret.F,ret.S,fie[x][y]);\n  return dp[x][y] = ret;\n}\n\nint main(){\n  sosu[1]=1;\n  for(int i=2;i<=1000000;i++){\n    if(!sosu[i]){\n      for(int j=i+i;j<=1000000;j+=i){\n\tsosu[j]=1;\n      }\n    }\n  }\n  for(int i=0;i<1111;i++)\n    for(int j=0;j<1111;j++)\n      dp[i][j]=P(-1,-1);\n  memset(fie,-1,sizeof(fie));\n\n\n  int x = 1111/2,y = 1111/2;\n  int id = 1, ic = 0;\n  //printf(\"%d %d\\n\",x,y);\n  fie[x][y]=1;\n  x += dx[ic]; y += dy[ic];\n\n \n  while( id < 1000000 ){\n    id++;\n    fie[x][y]=id;\n    mie[id] = P(x,y);\n    //if(id==1000000) printf(\"%d %d %d\\n\",id,x,y);\n    int nc = (ic+1)%4;\n    int nx = x+dx[nc], ny = y+dy[nc];\n    if( fie[nx][ny] == -1 ){\n      x = nx; y=ny;\n      ic=nc;\n    } else {\n      x = x + dx[ic]; y = y + dy[ic];\n    }\n  }\n\n\n  /*  for(int i=550;i<560;i++){\n    for(int j=550;j<560;j++){\n      printf(\"%3d \",fie[j][i]);\n    }\n    puts(\"\");\n  }\n  */\n\n  while(1){\n    for(int i=0;i<1111;i++)\n      for(int j=0;j<1111;j++)\n\tdp[i][j]=P(-1,-1);\n    \n    cin >> N >> M;\n    if(!N && !M) break;\n    //    printf(\"%d %d\\n\",mie[N].F,mie[N].S);\n    P res = solve(mie[M].F,mie[M].S,-1);\n    /*    if(sosu[fie[mie[M]][Mie[M]]]){\n      res.F ++;\n      }*/\n    if(res.S == -1){\n      printf(\"%d %d\\n\",0,0);\n    } else {\n      if( !sosu[fie[mie[M].F][mie[M].S]] ){\n\tif( res.F==0 ){\n\t  printf(\"%d %d\\n\",1,fie[mie[M].F][mie[M].S]);\n\t} else \n\t  printf(\"%d %d\\n\",res.F+1,res.S);\n      }\n      else\n\tprintf(\"%d %d\\n\",res.F,res.S);\n    }\n  }\n  \n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, -1, 0, 1, 1, 1, -1, -1};\nconst int L = 1010;\nconst int N = 1000000;\nint grid[L][L];\nvoid init(){\n  int l = 1;\n  int x = L / 2;\n  int y = L / 2;\n  int r = 0;\n  int rest = 1;\n  for(int y = 0; y < L; y++) {\n    for(int x = 0; x < L; x++){\n      grid[y][x] = INF;\n    }\n  }\n  for(int i = 1; i <= N; i++){\n    assert(grid[y][x] == INF);\n    grid[y][x] = i;\n    x += dx[r];\n    y += dy[r];\n    rest--;\n    if(rest == 0){\n      r = (r + 1) % 4;\n      if(r % 2 == 0) l++;\n      rest = l;\n    }\n  }\n}\n\nbool prime[N + 1] = {};\nvoid make_prime(){\n  for(int i = 2; i <= N; i++) prime[i] = true;\n  for(int i = 2; i <= N; i++) if(prime[i]){\n    for(int j = 2 * i; j <= N; j += i){\n      prime[j] = false;\n    }\n  }\n}\n\n\nint main(){\n  init();\n  make_prime();\n  int max_n, st;\n  while(cin >> max_n >> st && max_n){\n    static int dp[L][L];\n    for(int y = 0; y < L ; y++){\n      for(int x = 0; x < L; x++){\n        if(grid[y][x] == st) dp[y][x] = prime[ grid[y][x] ];\n        else                 dp[y][x] = -INF;\n      }\n    }\n    int ans1 = 0;\n    int ans2 = 0;\n    for(int y = 1; y < L; y++){\n      for(int x = 0; x < L; x++) if(grid[y][x] <= max_n){\n        for(int dx = -1; dx <= 1; dx++)if(x + dx >= 0 && x + dx < L){\n          dp[y][x] = max(dp[y][x], dp[y - 1][x + dx] + prime[ grid[y][x] ]);\n          if(dp[y][x] > ans1 && dp[y][x] > 0 && prime[ grid[y][x] ]){\n            ans1 = dp[y][x];\n            ans2 = grid[y][x];\n          }else if(dp[y][x] == ans1 && dp[y][x] > 0 && prime[ grid[y][x] ]){\n            ans2 = max(ans2, grid[y][x]);\n          }\n        }\n      }\n    }\n    printf(\"%d %d\\n\", ans1, ans2);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <tuple>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_from(i, m, n) for (int i = (m); (i) < int(n); ++(i))\nusing namespace std;\ntemplate <class T> inline void setmax(T & a, T const & b) { a = max(a, b); }\ntemplate <typename X, typename T> auto vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto vectors(X x, Y y, Z z, Zs... zs) { auto cont = vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\n\nvector<bool> sieve_of_eratosthenes(int n) { // enumerate primes in [2,n] with O(n log log n)\n    vector<bool> is_prime(n + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (int i = 2; i * i <= n; ++i)\n        if (is_prime[i])\n            for (int k = 2 * i; k <= n; k += i)\n                is_prime[k] = false;\n    return is_prime;\n}\n\nconstexpr int max_n = 1000000;\nconstexpr int sqrt_max_n = 1000;\nconstexpr int height = sqrt_max_n + 100;\nconstexpr int width = sqrt_max_n + 100;\nconstexpr int center_y = height / 2;\nconstexpr int center_x = width / 2;\nconst int dy[] = { 0, -1, 0, 1 };  // RULD\nconst int dx[] = { 1, 0, -1, 0 };\n\nint main() {\n    // fill the caves\n    auto cave = vectors(height, width, int());\n    vector<pair<int16_t, int16_t> > rev_cave(max_n + 1);\n    {\n        int y = center_y;\n        int x = center_x;\n        int dir = 3;  // D\n        repeat (i, max_n) {\n            cave[y][x] = i + 1;\n            rev_cave[i + 1] = { y, x };\n            int ly = y + dy[(dir + 1) % 4];\n            int lx = x + dx[(dir + 1) % 4];\n            if (not cave[ly][lx]) {\n                dir = (dir + 1) % 4;\n            }\n            y += dy[dir];\n            x += dx[dir];\n        }\n    }\n    auto is_prime = sieve_of_eratosthenes(max_n);\n    // solve\n    while (true) {\n        // input\n        int m, n; scanf(\"%d%d\", &m, &n);\n        if (m == 0 and n == 0) break;\n        // dp\n        auto dp = vectors(height, width, int());\n        int y, lx; tie(y, lx) = rev_cave[n];\n        int rx = lx + 1;\n        pair<int, int> result = {};\n        while (y < height) {\n            repeat_from (x, lx, rx) {\n                int k = cave[y][x];\n                if (k and k <= m) {\n                    dp[y][x] = max({ dp[y - 1][x - 1], dp[y - 1][x], dp[y - 1][x + 1] });\n                    if (is_prime[k]) {\n                        dp[y][x] += 1;\n                        setmax(result, make_pair(dp[y][x], k));\n                    }\n                }\n            }\n            // incr\n            ++ y;\n            lx = max(1, lx - 1);\n            rx = min(width - 1, rx + 1);\n        }\n        // output\n        if (result.first == 0) result.second = 0;\n        printf(\"%d %d\\n\", result.first, result.second);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define REP(i, n ,N) for(ll i = (n); i < (N); i++)\n#define RREP(i, n ,N) for(ll i = (N); i >= (n+1); i--)\n#define p(s) cout<<(s)<< endl\n#define p2(a, b) cout<<(a) << \" \" << (b) << endl\nusing namespace std;\ntypedef long long ll;\n\nbool isPrime[1000010];\nll field[1010][1010];\nll dy[4] = {0, -1, 0, 1};\nll dx[4] = {1, 0, -1, 0};\nvector<ll> edge[1000010];\nconst int MAX_SIZE=1000000;\npair<ll, ll> memo[1000010]; // takara, last_num\nvoid hurui(ll n){\n\tisPrime[0] = isPrime[1] = false;\n\tfor(ll i = 2; i < n + 1; i++) isPrime[i] = true;\n\tfor(ll i = 2; i*i<= n; i++){\n\t\tfor(ll j=i*2; j<n+1; j += i){\n\t\t\tisPrime[j] = false;\n\t\t}\n\t}\n}\n\nvoid make_cave(){\n\tll ny = 500;\n\tll nx = 499;\n\tll step = 1;\n\tll dir = 0;\n\tll i = 1;\n\twhile(1){\n\t\tll next_y = ny + dy[dir]*step;\n\t\tll next_x = nx + dx[dir]*step;\n\t\tif(next_y == ny){\n\t\t\tif(next_x > nx){\n\t\t\t\tREP(x, nx, next_x){\n\t\t\t\t\tfield[ny][x] = i;\n\t\t\t\t\ti++;\n\t\t\t\t\tif(i>MAX_SIZE) return;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tRREP(x, next_x, nx){\n\t\t\t\t\tfield[ny][x] = i;\n\t\t\t\t\ti++;\n\t\t\t\t\tif(i>MAX_SIZE) return;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnx = next_x;\n\t\t}\n\t\telse{\n\t\t\tif(next_y > ny){\n\t\t\t\tREP(y, ny, next_y){\n\t\t\t\t\tfield[y][nx] = i;\n\t\t\t\t\ti++;\n\t\t\t\t\tif(i>MAX_SIZE) return;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tRREP(y, next_y, ny){\n\t\t\t\t\tfield[y][nx] = i;\n\t\t\t\t\ti++;\n\t\t\t\t\tif(i>MAX_SIZE) return;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tny = next_y;\n\t\t}\n\n\t\tdir = (dir+1)%4;\n\t\tif(dir%2==0){\n\t\t\tstep++;\n\t\t}\n\t}\n}\nll m, n;\npair<ll, ll> dfs(ll cur_num){\n\tif(memo[cur_num].second != 0) return memo[cur_num];\n\tll cnt = 0;\n\tll last_num = 0;\n\tif(isPrime[cur_num]){\n\t\tcnt = 1;\n\t\tlast_num = cur_num;\n\t}\n\tpair<ll, ll> ret = {0, 0};\n\tfor(ll next_num: edge[cur_num]){\n\t\tif(next_num > m) continue;\n\t\tpair<ll, ll> next_memo = dfs(next_num);\n\t\tif(next_memo.first > ret.first){\n\t\t\tret = next_memo;\n\t\t}else if(next_memo.first == ret.first && next_memo.second > ret.second){\n\t\t\tret = next_memo;\n\t\t}\n\t}\n\tif(ret.second == 0){\n\t\tret = {cnt, last_num};\n\t}else{\n\t\tret.first+=cnt;\n\t}\n\treturn memo[cur_num] = ret;\n};\nint main() {\n\thurui(MAX_SIZE);\n\tmake_cave();\n\tREP(y, 0, 1000-1){\n\t\tREP(x, 0, 1000){\n\t\t\tll now = field[y][x];\n\t\t\tREP(xx,max(0LL, x-1), min(x+2,1000LL)){\n\t\t\t\tedge[now].push_back(field[y+1][xx]);\n\t\t\t}\n\t\t}\n\t}\n\twhile(cin >> m >> n && m){\n\t\tREP(i,0,1000005){\n\t\t\tmemo[i] = {0, 0};\n\t\t}\n\t\tpair<ll, ll> ans = dfs(n);\n\t\tp2(ans.first, ans.second);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[(SIZE + 1)*(SIZE + 1) + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tint res1, res2;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= (SIZE + 1)*(SIZE + 1);i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= (SIZE + 1)*(SIZE + 1);j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 || n == 0)return 0;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(y=SIZE-1;y>=0;y--){\n\t\t\tfor(x=SIZE-1;x>=0;x--){\n\t\t\t\tif (table[y][x] <= m) {\n\t\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m &&\n\t\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x - 1] || (dp[y][x] == dp[y + 1][x - 1] && pr[y][x] < pr[y + 1][x - 1]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (table[y + 1][x] <= m &&\n\t\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x] || (dp[y][x] == dp[y + 1][x] && pr[y][x] < pr[y + 1][x]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m &&\n\t\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x + 1] || (dp[y][x] == dp[y + 1][x + 1] && pr[y][x] < pr[y + 1][x + 1]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (y = 0;y < SIZE;y++) {\n\t\t\tfor (x = 0;x < SIZE;x++) {\n\t\t\t\tif (table[y][x] == n) {\n\t\t\t\t\tres1 = dp[y][x];\n\t\t\t\t\tres2 = pr[y][x];\n\t\t\t\t\t//printf(\"%d\\n\", dp[y][x]);\n\t\t\t\t\t//cout << dp[y][x] << \" \";\n\t\t\t\t\t//cout << pr[y][x] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", res1, res2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iomanip>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define pii pair<int,int>\n\n#define MAXM 1000001\n#define MAXSQM 1003\nint diff[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nint map[MAXSQM][MAXSQM] = {};\nbool furui[MAXM] = {};\npii dpmap[MAXSQM][2] = {};\n\nvoid init_map(int m){\n    fill_n(*map,MAXSQM*MAXSQM,0);\n    fill_n(*dpmap,MAXSQM*2,pii(-1,-1));\n    int idx=MAXSQM/2,idy=MAXSQM/2;\n    int dir=0;\n    int c=1;\n    for(int i=1;c<=m;i++){\n        for(int j=0;j<i&&c<=m;j++){\n            map[idx][idy]=c++;\n            idx+=diff[dir][0];\n            idy+=diff[dir][1];\n        }\n        dir=(dir+1)%4;\n        for(int j=0;j<i&&c<=m;j++){\n            map[idx][idy]=c++;\n            idx+=diff[dir][0];\n            idy+=diff[dir][1];\n        }\n        dir=(dir+1)%4;\n    }\n}\n\npii dp(int n){\n    int nx,ny;\n    for(nx=0;nx<MAXSQM;nx++){\n        for(ny=0;ny<MAXSQM;ny++){\n            if(n==map[nx][ny]) break;\n        }\n        if(n==map[nx][ny]) break;\n    }\n\n    pii ans=pii(0,0);\n\n    if(!furui[map[nx][ny]]){\n        dpmap[nx][ny%2]=pii(1,map[nx][ny]);\n        ans=dpmap[nx][ny%2];\n    }\n    else\n    {\n        dpmap[nx][ny%2]=pii(0,0);\n    }\n\n    for(int j=ny;j>=1;j--){\n        for(int i=0;i<MAXSQM;i++){\n            if(map[i][j]==0 || dpmap[i][j%2].first==-1) continue;\n            for(int k=-1;k<=1;k++){\n                if(map[i+k][j-1]==0) continue;\n                if(!furui[map[i+k][j-1]]){\n                    dpmap[i+k][(j-1)%2]=max(pii(dpmap[i][j%2].first+1,map[i+k][j-1]), dpmap[i+k][(j-1)%2]);\n                }\n                else\n                {\n                    dpmap[i+k][(j-1)%2]=max(dpmap[i][j%2], dpmap[i+k][(j-1)%2]);\n                }\n                ans=max(ans,dpmap[i+k][(j-1)%2]);\n            }\n        }\n    }\n    return ans;\n}\n\nint main(){\n    while(1){\n        int m,n;\n        cin>>m>>n;\n        if(m==0) break;\n\n        furui[0]=furui[1]=true;\n        for(int i=2;i<MAXSQM;i++){\n            for(int j=2;i*j<MAXM;j++){\n                if(!furui[i]){\n                    furui[i*j]=true;\n                }\n            }\n        }\n        init_map(m);\n        pii p=dp(n);\n\n        /*int b=MAXSQM/2,a=MAXSQM/2;\n        for(int i=a-5;i<a+5;i++){\n            for(int j=b-5;j<b+5;j++){\n                cout<<std::setw(4)<<map[j][i];\n            }\n            cout<<endl;\n        }\n        for(int i=a-5;i<a+5;i++){\n            for(int j=b-5;j<b+5;j++){\n                cout<<setw(4)<<dpmap[j][i].first;\n            }\n            cout<<endl;\n        }*/\n        cout<<p.first<<\" \"<<p.second<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint table[3000][3000];\n\nconst int maxm = 1e6;\nint mode[4] = {0,1,2,3};//右　上　左　下\nvector<int> edge[maxm + 10];\nint main() {\n\n    int now_mode = 1;\n    int straight_move = 1;\n    bool is_first = false;\n    table[1500][1500] = 1;\n    int x = 1500, y = 1500;\n    int counter = 1;\n    while(counter<=maxm){\n        if(now_mode == 0){\n            for(int i=0; i<straight_move; i++){\n                counter++;\n                x++;\n                table[x][y] = counter;\n            }\n        }\n        else if(now_mode == 1){\n            for(int i=0; i<straight_move; i++){\n                counter++;\n                y++;\n                table[x][y] = counter;\n            }\n        }\n        else if(now_mode == 2){\n            for(int i=0; i<straight_move; i++){\n                counter++;\n                x--;\n                table[x][y] = counter;\n            }\n        }\n        else if(now_mode == 3){\n            for(int i=0; i<straight_move; i++){\n                counter++;\n                y--;\n                table[x][y] = counter;\n            }\n        }\n\n        if(is_first){\n            straight_move++;\n            is_first = false;\n        }\n        else{\n            is_first = true;\n        }\n\n        now_mode++;\n        now_mode %= 4;\n    }\n\n    int dx[3] = {-1,0,1};\n\n    for(int i=0; i<3000; i++){\n        for(int j=0; j<3000; j++){\n            if(table[i][j] == 0 || table[i][j] > maxm){\n                continue;\n            }\n            for(int k=0; k<3; k++){\n                if(table[j+1][dx[k] + i] == 0 || table[j+1][dx[k] + i] > maxm){\n                    continue;\n                }\n                edge[table[i][j]].push_back(table[j+1][dx[k] + i]);\n            }\n\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include<iomanip>\n\nusing namespace std;\n\n#define ALLNUM 1002\n#define fin cin\n\nint all, start;\nint map[ALLNUM][ALLNUM] = {};\n\nbool isPrime(int n){\n    if(n <= 1)return false;\n    if(n == 2)return true;\n    if(n % 2 == 0)return false;\n    \n    for(int i = 3; i * i <= n; i+=2){\n        if(n % i == 0)return false;\n    }\n    return true;\n}\n\nclass Pair{\n    \npublic:\n    int num;\n    int count;\n    \n    Pair(){\n        this->num = 0;\n        this->count = 0;\n    };\n    Pair(int _num){\n        if(isPrime(_num)){\n            this->num = _num;\n            this->count = 1;\n        }\n        else {this->num = this->count = 0;}\n    }\n    \n    Pair operator + (const Pair &p){\n        this->count += p.count;\n        if(p.num != 0)this->num = p.num;\n        return *this;\n    }\n    \n    void print(){\n        cout << this->count << \" \" << this->num;\n    }\n};\n\nbool come[ALLNUM][ALLNUM];\nPair pMap[ALLNUM][ALLNUM];\n\nvoid init(){\n    \n    for(int i = 0; i < ALLNUM; i++){\n        for(int j = 0; j < ALLNUM; j++){\n            pMap[i][j] = Pair(0);\n            come[i][j] = false;\n        }\n    }\n}\n\nPair calc(int y, int x){\n    \n    if(map[y][x] > all)return Pair(-10);\n    if(come[y][x])return pMap[y][x];\n    \n    Pair p(map[y][x]);\n    Pair ans;\n    \n    Pair tmp1 = calc(y + 1, x);\n    Pair tmp2 = calc(y + 1, x + 1);\n    \n    if (tmp1.count == tmp1.count) {\n        if (tmp1.num < tmp2.num)tmp1.count--;\n    }\n    \n    if (tmp1.count < tmp2.count)ans =  tmp2;\n    else ans = tmp1;\n    \n    tmp1 = calc(y + 1, x - 1);\n    \n    if (tmp1.count < ans.count);\n    else ans = tmp1;\n    \n    /*\n     if (tmp1.count == tmp2.count) {\n     if(tmp1.num == tmp2.num)ans = tmp1;\n     else if(tmp1.num < tmp2.num)ans = tmp2;\n     else ans = tmp1;\n     }\n     else if(tmp1.count < tmp2.count)ans = tmp2;\n     else ans = tmp1;\n     \n     tmp2 = calc(y + 1, x - 1);\n     if (ans.count == tmp2.count) {\n     if(ans.num == tmp2.num);\n     else if(ans.num < tmp2.num)ans = tmp2;\n     else ;\n     }\n     else if(ans.count < tmp2.count)ans = tmp2;\n     else ;\n     */\n    \n    come[y][x] = true;\n    return pMap[y][x] = p + ans;\n}\n\nint main() {\n  //  ifstream fin(\"in.txt\");\n    \n    int x, y;\n    x = y = ALLNUM / 2;\n    \n    map[y][x] = 1;\n    \n    int gumi = 1;\n    int num = 1;\n    \n    while(num < (ALLNUM - 1) * (ALLNUM - 1)){\n        for(int i = 0; i < gumi; i++){\n            map[y][++x] = ++num;\n        }\n        if(num >= ALLNUM * ALLNUM)break;\n        \n        for(int i = 0; i < gumi; i++){\n            map[--y][x] = ++num;\n        }\n        if(num >= ALLNUM * ALLNUM)break;\n        \n        gumi++;\n        for(int i = 0; i < gumi; i++){\n            map[y][--x] = ++num;\n        }\n        if(num >= ALLNUM * ALLNUM)break;\n        \n        for(int i = 0; i < gumi; i++){\n            map[++y][x] = ++num;\n        }\n        if(num >= ALLNUM * ALLNUM)break;\n        gumi++;\n    }\n    \n    while(true){\n        fin >> all >> start;\n        if((all | start) == 0)break;\n        \n        init();\n        x = y = 0;\n        \n        for(int i = 0; i < ALLNUM; i++){\n            for(int j = 0; j < ALLNUM; j++){\n                if(map[j][i] == start){\n                    x = i;\n                    y = j;\n                    i = j = ALLNUM;//?????????break;\n                    break;\n                }\n            }\n        }\n        calc(y, x).print();\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\n#define MAX 1000005\n\nint sosu[MAX];\nint sx, sy; //start point\n\n//0?????????2???3???\nint dx[] = { 1, 0, -1, 0 };\nint dy[] = { 0, 1, 0, -1 };\n\n\nstruct map {\n\tint num; //?´???´?????????\n\tint dou; //?´????????????°\n\tint en; //??????????´????\n\tbool sos; //?´???°??????true\n\n};\n\nmap m[1002][1002]; //??????????????????????????????\n\n//?´???°????±???????\nvoid Eratosthenes()\n{\n\tfor (int i = 0; i < MAX; i++) {\n\t\tsosu[i] = 1;\n\t}\n\n\tsosu[1] = 0;\n\n\tfor (int i = 2; i < sqrt(MAX); i++) {\n\t\tif (sosu[i]) {\n\t\t\tfor (int j = 0; i * (j + 2) < MAX; j++) {\n\t\t\t\tsosu[i *(j + 2)] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 2; i < MAX; i++) {\n\t\tif (sosu[i]) {\n\t\t\t//cout << i << endl;\n\t\t}\n\t}\n\n}\n\nvoid map_syoki() //?????????\n{\n\tfor (int i = 0; i < 1002; i++) {\n\t\tfor (int j = 0; j < 1002; j++) {\n\t\t\tm[i][j].num = m[i][j].en = 0;\n\t\t\tm[i][j].dou = -1;\n\t\t\tm[i][j].sos = false;\n\t\t}\n\t}\n\t\n}\n\n//??????????????????\nvoid make_map(int o, int n)\n{\n\tint nx, ny; //????????´???\n\tnx = ny = 500;\n\tm[nx][ny].num = 1;\n\tint len = 1;\n\tint muki = 0;\n\tint a = 0;\n\tfor (int i = 2; i <= o;) {\n\t\tfor (int t = 0; t < 2; t++) { //2????????¨???????????????????????????\n\t\t\ta %= 4;\n\t\t\tfor (int l = 0; l < len; l++) {\n\t\t\t\tnx += dx[a];\n\t\t\t\tny += dy[a];\n\t\t\t\tm[nx][ny].num = i;\n\t\t\t\tif (sosu[i] == 1) { //?´???°?????£??????\n\t\t\t\t\tm[nx][ny].sos = true;\n\t\t\t\t}\n\n\t\t\t\tif (i == n) { //start??°???????¨????\n\t\t\t\t\tsx = nx;\n\t\t\t\t\tsy = ny;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\ta++;\n\t\t}\n\t\tlen++;\n\t}\n\treturn;\n}\n\n//??±???????????¢?´¢\nmap search(int x, int y)\n{\n\tmap d;\n\tint num, dou, en;\n\tnum = 0;\n\tdou = 0;\n\ten = 0;\n\tif (m[x][y].num == 0) {\n\t\td.num = 0;\n\t\td.en = 0;\n\t\td.dou = 0;\n\t}\n\telse if (m[x][y].dou >= 0) {\n\t\td = m[x][y];\n\t}\n\telse {\n\t\tdou = 0;\n\t\ten = 0;\n\t\tnum = m[x][y].num;\n\t\tfor (int i = -1; i < 2; i++) {\n\t\t\td = search(x + i, y + 1);\n\t\t\tif (dou < d.dou) {\n\t\t\t\tdou = d.dou;\n\t\t\t\ten = d.en;\n\t\t\t}\n\t\t\telse if (d.dou == dou) {\n\t\t\t\tdou = max(d.dou, dou);\n\t\t\t}\n\t\t}\n\t\tif (m[x][y].sos == true) {\n\t\t\tif (dou == 0) {\n\t\t\t\ten = num;\n\t\t\t}\n\t\t\tdou++;\n\t\t}\n\t\td.num = num;\n\t\td.en = en;\n\t\td.dou = dou;\n\t\tm[x][y] = d;\n\t}\n\treturn d;\n}\n\nint main() {\n\n\n\tint x, y; //??§?¨?\n\tint n, o; \n\tmap s;\n\n\tEratosthenes(); //?´???°??¨?????????\n\n\twhile (1) {\n\t\tcin >> o >> n;\n\t\tif (o == 0 && n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tmap_syoki();\n\t\tmake_map(o, n);\n\t\ts = search(sx, sy);\n\n\t\tcout << s.dou << \" \" << s.en << endl;\n\n\t}\n\n\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define SIZE 1000\n\nbool C(int dp1, int pr1, int dp2, int pr2) {\n\tif (dp2 == 0)return false;\n\tif (dp1 < dp2 || (dp1 == dp2&&pr1 < pr2))return true;\n\treturn false;\n}\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool complete;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;\n\tfor (int i = 1;i <= SIZE&&a <= SIZE*SIZE;i++) {\n\t\tfor (int j = 0;j < i&&a <= SIZE*SIZE;j++) {\n\t\t\tif (i % 2 == 0)x--;\n\t\t\telse x++;\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t}\n\t\tfor (int j = 0;j < i&&a <= SIZE*SIZE;j++) {\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\tcomplete = false;\n\t\twhile (!complete) {\n\t\t\twhile (x >= 0 && !complete) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x - 1], pr[y + 1][x - 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x], pr[y + 1][x])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x + 1], pr[y + 1][x + 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (table[y][x] == n)complete = true;\n\t\t\t\telse x--;\n\t\t\t}\n\t\t\tif (!complete) {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint s[1000][1000];\nint dp[1000][1000];\nint p[1000][1000];\n\npair<int, int> get_pos(int n) {\n        if (n == 1) return make_pair(500, 499);\n        int top_left = 1;\n        int k = 1;\n        while (n > top_left) {\n                top_left = (2 * k) * (2 * k);\n                k ++;\n        }\n        k --;\n        int top_right = top_left - 2 * k + 1;\n        int bottom_right = top_right - 2 * k + 1;\n        int bottom_left = bottom_right - 2 * k + 1;\n        int y, x;\n        if (n <= bottom_left) {\n                y = 499 - k + 1 + (2 * k - 1 - (bottom_left - n));\n                x = 499 - k + 1;\n        } else if (n <= bottom_right) {\n                y = 499 + k;\n                x = 499 - k + 1 + (n - bottom_left);\n        } else if (n <= top_right) {\n                y = 499 - k + 1 + (top_right - n);\n                x = 499 + k;\n        } else { \n                y = 499 - k + 1;\n                x = 499 - k + 1 + (top_left - n);\n        }\n        p[y][x] = n;\n        return make_pair(y, x);\n}\n\n//N??\\???????´???°?????????O(N log log N)\nint N = 1000000;\nvector<int> primes;\nvector<bool> is_prime(N + 1, true);\nvoid init() {\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 2; i <= N; i ++) {\n                if (is_prime[i]) {\n                        primes.push_back(i);\n                        for (int j = i + i; j <= N; j += i) is_prime[j] = false;\n                }\n        }\n        for (int i = 1; i <= 1000000; i ++) get_pos(i);\n}\n\nint main() {\n        init();\n        int m, n;\n        while (scanf(\"%d%d\", &m, &n) && n) {\n                for (int i = 0; i < 1000; i ++) for (int j = 0; j < 1000; j ++) s[i][j] = 0;\n                for (auto p : primes) {\n                        if (p > m) break;\n                        int y, x;\n                        tie(y, x) = get_pos(p);\n                        s[y][x] = 1;\n                }\n                int dp[1000][1000] = { 0 };\n                int sy, sx;\n                tie(sy, sx) = get_pos(n);\n                dp[sy][sx] = s[sy][sx];\n                for (int dy = 0; sy + dy + 1 < 1000; dy ++) {\n                        for (int dx = -dy; dx <= dy; dx ++) {\n                                dp[sy + dy + 1][sx + dx - 1] = max(dp[sy + dy + 1][sx + dx - 1], s[sy + dy + 1][sx + dx - 1] + dp[sy + dy][sx + dx]);\n                                dp[sy + dy + 1][sx + dx]     = max(dp[sy + dy + 1][sx + dx]    , s[sy + dy + 1][sx + dx]     + dp[sy + dy][sx + dx]);\n                                dp[sy + dy + 1][sx + dx + 1] = max(dp[sy + dy + 1][sx + dx + 1], s[sy + dy + 1][sx + dx + 1] + dp[sy + dy][sx + dx]);\n                        }\n                }\n                int ans = 0;\n                for (int i = 0; i < 1000; i ++) {\n                        for (int j = 0; j < 1000; j ++) {\n                                ans = max(ans, dp[i][j]);\n                        }\n                }\n                if (ans == 0) { \n                        cout << 0 << ' ' << 0 << endl;\n                        continue;\n                }\n                int res = -1;\n                for (int i = 0; i < 1000; i ++) {\n                        for (int j = 0; j < 1000; j ++) {\n                                if (dp[i][j] == ans && s[i][j]) {\n                                        res = max(res, p[i][j]);\n                                }\n                        }\n                }\n                cout << ans << ' ' << res << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\ntypedef pair<int, int>P;\nconst int N = 1000010;\n\nint Pri[N];\nint X[N];\nint Y[N];\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, -1, 0, 1};\n\nint mp[1100][1100];\n\nvector<P>vec;\n\nvoid init(){\n    for(int i=0;i<N;i++){\n        Pri[i] = 1;\n    }\n    Pri[0] = 0;\n    Pri[1] = 0;\n    for(int i=2;i*i<=N;i++){\n        if(Pri[i]==0)continue;\n        for(int j=i+i;j<N;j+=i){\n            Pri[j]=0;\n        }\n    }\n    for(int x=550, y=550, CNT=1, p=0, cnt=0, i=1;i<N;){\n        mp[x][y] = i;\n        X[i] = x;\n        Y[i] = y;\n        vec.push_back(P(y, i));\n        x += dx[p];\n        y += dy[p];\n        i++;\n        cnt++;\n        if(cnt==CNT){\n            cnt=0;\n            p++;\n            if(p==2){\n                CNT++;\n            }\n            if(p==4){\n                p=0;\n                CNT++;\n            }\n        }\n    }\n    sort(vec.begin(), vec.end());\n}\n\nint main(){\n\n    init();\n    for(int m, n;cin>>m>>n, m;){\n        int ans = 0, lstmx = 0;\n        std::vector<int>tmp(N, -1);\n        tmp[n] = 0;\n        for(int i=0;i<vec.size();i++){\n            int num = vec[i].second;\n            if(num > m)continue;\n            if(tmp[num] < 0)continue;\n            if(Pri[num]){\n                tmp[num]++;\n                if((tmp[num] > ans) || (tmp[num]==ans && num > lstmx && ans>0)){\n                    ans = tmp[num];\n                    lstmx = num;\n                }\n            }\n            for(int t = -1; t <= 1; t++){\n                int y = Y[num] + 1;\n                int x = X[num] + t;\n                int nxt = mp[x][y];\n                tmp[nxt] = max(tmp[nxt], tmp[num]);\n            }\n        }\n\n        cout<<ans<<\" \"<<lstmx<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\n\nint main() {\n\n\tvector< vector<long long int> > doketsu(1001, vector<long long int>(1001, 0));\n\n\tdoketsu[500][500] = 1;\n\n\tint x, y;\n\tx = y = 500;\n\tx = 501;\n\tint xR, xL, yT, yB;\n\txR = 501;\n\txL = 499;\n\tyT = 499;\n\tyB = 501;\n\tint type = 0;\n\tfor (long long int i = 2; i <= 1001 * 1001; i++) {\n\t\tdoketsu[y][x] = i;\n\t\tif (type == 0) {\n\t\t\tif (x < xR) {\n\t\t\t\tx++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttype++;\n\t\t\t\ty--;\n\t\t\t\txR++;\n\t\t\t}\n\t\t}\n\t\telse if (type == 1) {\n\t\t\tif (yT < y) {\n\t\t\t\ty--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttype++;\n\t\t\t\tx--;\n\t\t\t\tyT--;\n\t\t\t}\n\t\t}\n\t\telse if (type == 2) {\n\t\t\tif (xL < x) {\n\t\t\t\tx--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttype++;\n\t\t\t\ty++;\n\t\t\t\txL--;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (y < yB) {\n\t\t\t\ty++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttype = 0;\n\t\t\t\tx++;\n\t\t\t\tyB++;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int> furui((1001 * 1001) + 1, 0);\n\tfurui[0] = furui[1] = 1;\n\n\tfor (long long int i = 2; i*i <= 1001 * 1001; i++) {\n\t\tif (furui[i] == 0) {\n\t\t\tfor (long long int j = 2; i*j <= 1001 * 1001; j++) {\n\t\t\t\tfurui[i*j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\tfor (int i = 497; i <= 503; i++) {\n\t\tfor (int j = 497; j <= 503; j++) {\n\t\t\tprintf(\"%2lld \", doketsu[i][j]);\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n\tlong long int n, m;\n\twhile (cin >> m >> n) {\n\t\tif (n == 0 && m == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector< vector<P> > dp(1001, vector<P>(1001));\n\n\t\tfor (int i = 0; i < 1001; i++) {\n\t\t\tfor (int j = 0; j < 1001; j++) {\n\t\t\t\tdp[i][j] = P(-1, -1);\n\t\t\t\tif (doketsu[i][j] == n) {\n\t\t\t\t\tdp[i][j] = P(0, 0);\n\t\t\t\t\tif (furui[n] == 0) {\n\t\t\t\t\t\tdp[i][j] = P(1, n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor (int i = 497; i <= 503; i++) {\n\t\t\tfor (int j = 497; j <= 503; j++) {\n\t\t\t\tprintf(\"%2lld \", dp[i][j].first);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tfor (int i = 0; i < 1001; i++) {\n\t\t\tfor (int j = 0; j < 1001; j++) {\n\t\t\t\tif (dp[i][j].first >= 0) {\n\t\t\t\t\tint xx = j;\n\t\t\t\t\tint yy = i;\n\t\t\t\t\tif (xx - 1 >= 0 && yy + 1 < 1001 && doketsu[yy + 1][xx - 1] <= m) {\n\t\t\t\t\t\tlong long int p = 1 - furui[doketsu[yy + 1][xx - 1]];\n\t\t\t\t\t\tif (dp[yy + 1][xx - 1].first < dp[yy][xx].first + p) {\n\t\t\t\t\t\t\tdp[yy + 1][xx - 1] = dp[yy][xx];\n\t\t\t\t\t\t\tif (p == 1) {\n\t\t\t\t\t\t\t\tdp[yy + 1][xx - 1].first++;\n\t\t\t\t\t\t\t\tdp[yy + 1][xx - 1].second = doketsu[yy + 1][xx - 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (dp[yy + 1][xx - 1].first == dp[yy][xx].first + p) {\n\t\t\t\t\t\t\tif (p == 0) {\n\t\t\t\t\t\t\t\tdp[yy + 1][xx - 1].second = max(dp[yy + 1][xx - 1].second, dp[yy][xx].second);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (yy + 1 < 1001 && doketsu[yy + 1][xx] <= m) {\n\t\t\t\t\t\tlong long int p = 1 - furui[doketsu[yy + 1][xx]];\n\t\t\t\t\t\tif (dp[yy + 1][xx].first < dp[yy][xx].first + p) {\n\t\t\t\t\t\t\tdp[yy + 1][xx] = dp[yy][xx];\n\t\t\t\t\t\t\tif (p == 1) {\n\t\t\t\t\t\t\t\tdp[yy + 1][xx].first++;\n\t\t\t\t\t\t\t\tdp[yy + 1][xx].second = doketsu[yy + 1][xx];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (dp[yy + 1][xx].first == dp[yy][xx].first + p) {\n\t\t\t\t\t\t\tif (p == 0) {\n\t\t\t\t\t\t\t\tdp[yy + 1][xx].second = max(dp[yy + 1][xx].second, dp[yy][xx].second);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (xx + 1 < 1001 && yy + 1 < 1001 && doketsu[yy + 1][xx + 1] <= m) {\n\t\t\t\t\t\tlong long int p = 1 - furui[doketsu[yy + 1][xx + 1]];\n\t\t\t\t\t\tif (dp[yy + 1][xx + 1].first < dp[yy][xx].first + p) {\n\t\t\t\t\t\t\tdp[yy + 1][xx + 1] = dp[yy][xx];\n\t\t\t\t\t\t\tif (p == 1) {\n\t\t\t\t\t\t\t\tdp[yy + 1][xx + 1].first++;\n\t\t\t\t\t\t\t\tdp[yy + 1][xx + 1].second = doketsu[yy + 1][xx + 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (dp[yy + 1][xx + 1].first == dp[yy][xx].first + p) {\n\t\t\t\t\t\t\tif (p == 0) {\n\t\t\t\t\t\t\t\tdp[yy + 1][xx + 1].second = max(dp[yy + 1][xx + 1].second, dp[yy][xx].second);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tP ans = P(0, 0);\n\t\tfor (int i = 0; i < 1001; i++) {\n\t\t\tfor (int j = 0; j < 1001; j++) {\n\t\t\t\tif (dp[i][j].first > ans.first) {\n\t\t\t\t\tans = dp[i][j];\n\t\t\t\t}\n\t\t\t\telse if (dp[i][j].first == ans.first) {\n\t\t\t\t\tans.second = max(ans.second, dp[i][j].second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor (int i = 497; i <= 503; i++) {\n\t\t\tfor (int j = 497; j <= 503; j++) {\n\t\t\t\tprintf(\"%2lld \", dp[i][j].first);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tcout << ans.first << ' ' << ans.second << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#define X first\n#define Y second\n#define MAX 1003\nusing namespace std;\n\nstruct state{\n\tstate():num(0), max(-1), mindex(0){}\n\tint num;\n\tint max;\n\tint mindex;\n};\n\nstate dp[MAX][MAX];\nbool sosuu[1000001];\nmap<int, pair<int, int> > pos;\nint dx[] = {0, -1, 0, 1};\nint dy[] = {-1, 0, 1, 0};\nint ddx[] = {-1, 0, 1};\n\n//素数判定用\nvoid era(){\n\tfill(sosuu, sosuu+1000001, true);\n\tsosuu[0] = false;\n\tsosuu[1] = false;\n\tfor(int i = 2; i <= 1000000; i++){\n\t\tif(sosuu[i]){\n\t\t\tfor(int j = 2*i; j <= 1000000; j+=i) sosuu[j] = false;\n\t\t}\n\t}\n}\n\n//螺旋状に数字を配置する\nvoid fillNum(){\n\tint rect = 3, count = 1;\n\tint x = MAX/2, y = MAX/2;\n\tpos[count] = pair<int, int>(x, y);\n\tdp[y][x].num = count++;\n\twhile(count <= MAX*MAX-1){\n\t\tpos[count] = pair<int, int>(++x, y);\n\t\tdp[y][x].num = count++;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tfor(int j = (i==0)?1:0; j < rect-1; j++){\n\t\t\t\tx += dx[i];\n\t\t\t\ty += dy[i];\n\t\t\t\tpos[count] = pair<int, int>(x, y);\n\t\t\t\tdp[y][x].num = count++;\n\t\t\t}\n\t\t}\n\t\trect+=2;\n\t}\n}\n\n//洞穴数は毎回変わるので、入力時にその範囲だけ初期化\nvoid Init(int n){\n\tfor(int i = 0; i < MAX; i++){\n\t\tfor(int j = 0; j < MAX; j++){\n\t\t\tif(n>=dp[i][j].num){\n\t\t\t\tdp[i][j].max = -1;\n\t\t\t\tdp[i][j].mindex = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n  \n//メモ化再帰\n//スタートからした三方向に対して再帰回して\n//戻ってきたらそこまでの素数洞穴の和を各洞穴に記録していく\nint dfs(int x, int y, int n){\n\tif(dp[y][x].max>=0) return dp[y][x].max;\n\tint add = 0;\n\tfor(int i = 0; i < 3; i++){\n\t\tif(dp[y+1][x+ddx[i]].num>n) continue;//範囲外の洞穴にアクセスしようとしたら止める\n\t\t//三方向に対して再帰を行って、もっとも素数洞穴数が多い場所を採用\n\t\t//その際、同じ数が複数あった場合はその中で一番大きい素数洞穴を踏んだ経路を採用\n\t\tint tmp = dfs(x+ddx[i], y+1, n);\n\t\tif(add<tmp){\n\t\t\tadd = tmp;\n\t\t\tdp[y][x].mindex = dp[y+1][x+ddx[i]].mindex;\n\t\t}\n\t\telse if(add == tmp){ \n\t\t\tdp[y][x].mindex = dp[y][x].mindex<dp[y+1][x+ddx[i]].mindex?dp[y+1][x+ddx[i]].mindex:dp[y][x].mindex;\n\t\t}\n\t}\n\t//自分が素数だった場合1加算する\n\tdp[y][x].max = sosuu[dp[y][x].num]?add + 1:add;\n\t//自分が初めての素数洞穴だった場合\n\tif(!dp[y][x].mindex&&sosuu[dp[y][x].num]) dp[y][x].mindex = dp[y][x].num;\n\treturn dp[y][x].max;\n}\n\nint main(){\n\tera();\n\tfillNum();\n\tint n, m;\n\twhile(cin >> n >> m && (n!=0||m!=0)){\n\t\tInit(n);\n\t\tint x = pos[m].X, y = pos[m].Y;\n\t\tdfs(x, y, n);\n\t\tif(dp[y][x].max==0) cout << 0 << \" \" << 0 << endl;\n\t\telse cout << dp[y][x].max << \" \" << dp[y][x].mindex << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int M = 1000010;\nconst int N = 1010;\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\nbool isprime[M];\nint number[N][N];\nint DP[N][N];\n\nint n, m;\n\nint startx, starty;\n\nint ansnum, ansmax;\n\nvoid initprime() {\n  fill(isprime, isprime+M, true);\n  isprime[0] = isprime[1] = false;\n  isprime[2] = true;\n  for (int i=2; i<M; i++) {\n    if (isprime[i]) {\n      // cerr << \"prime \" << i << endl; \n      int j=2;\n      while (j * i < M) {\n\tisprime[j * i] = false;\n\tj++;\n      }\n    }\n  }\n}\n\nvoid init() {\n  fill(&number[0][0], &number[0][0]+N*N, 0);\n  fill(&DP[0][0], &DP[0][0]+N*N, -1);\n  int d = 0;\n  int len = 1;\n  int curn = 1;\n  int curx = N/2;\n  int cury = N/2;\n  \n  while (true) {\n    for (int i=0; i<len; i++) {\n      number[curx][cury] = curn;\n      // cerr << \"x \" << curx -N/2 << \", y \" << cury -N/2 << \", curn \" << curn << endl;\n      if (curn == n) {\n\tstartx = curx;\n\tstarty = cury;\n\tif (isprime[n]) {\n\t  DP[startx][starty] = 1;\n\t} else {\n\t  DP[startx][starty] = 0;\n\t}\n      }\n      curn++;\n      curx += dx[d];\n      cury += dy[d];\n      if (curn > m) return;\n    }\n    d = (d+1)%4;\n    if (d%2 == 0) len++;\n  }\n}\n\nvoid dynamic(int x, int y) {\n  for (int i=-1; i<=1; i++) {\n    if (number[x+i][y+1] != 0) {\n      if (isprime[number[x+i][y+1]]) {\n\tif (DP[x+i][y+1] < DP[x][y] + 1) { \n\t  DP[x+i][y+1] = DP[x][y] + 1;\n\t  dynamic(x+i, y+1);\n\t}\n      } else {\n\tif (DP[x+i][y+1] < DP[x][y]) {\n\t  DP[x+i][y+1] = DP[x][y];\n\t  dynamic(x+i, y+1);\n\t}\n      }\n    }\n  }\n}\n\nvoid solve() {\n  ansnum = ansmax = 0;\n  for (int i=0; i<N; i++) {\n    for (int j=0; j<N; j++) {\n      if (DP[i][j] > 0 && ansnum <= DP[i][j]) {\n\t// if (DP[i][j] > 0) cerr << \"ansnum \" << ansnum << \", number \" << number[i][j] << endl;\n\tif (ansnum < DP[i][j]) ansmax = 0;\n\tansnum = DP[i][j];\n\tif (ansmax < number[i][j] && isprime[number[i][j]]) {\n\t  ansmax = number[i][j];\n\t}\n      }\n    }\n  }\n  printf(\"%d %d\\n\", ansnum, ansmax);\n}\n\nint main() {\n  initprime();\n  while (scanf(\"%d%d\", &m, &n) != EOF && n && m) {\n    init();\n    dynamic(startx, starty);\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int N = 1000;\n\n#define F first\n#define S second\n\nvi dx = { 1, 0,-1, 0};\nvi dy = { 0,-1, 0, 1};\n\nint main(void){\n    vvi cave(N + 1, vi(N + 1)); \n\n    pii pos = mp(N / 2, N / 2);\n    cave[N / 2][N / 2] = 1;\n\n    int limit = 1, cnt = 0, dir = 0, inc = false;\n    range(i, 2, N * N + 1){\n        if(cnt++ == limit){\n            (++dir) %= dx.size();\n\n            if(inc) limit++;\n            cnt = 0;\n\n            inc = !inc;\n\n            i--;\n            continue;\n        }\n\n        pos.F += dy[dir];\n        pos.S += dx[dir];\n\n        cave[pos.F][pos.S] = i;\n    }\n\n    range(y, 490, 510){\n        range(x, 490, 510)\n            cout << cave[y][x] << \" \";\n        cout << endl;\n    }\n\n\tconst int MAX_N = (int)1e6 + 1;\n\tvector<bool> isP(MAX_N, true);\n    isP[0] = isP[1] = false;\n\tfor(int i = 2; i * i < MAX_N; i++) if(isP[i]) for(int j = i; i * j < MAX_N; j++) isP[i * j] = false;\n\n    for(int m, n; cin >> m >> n, m; ){\n        \n        //(集めた個数, 最後に通った素数)\n        vector<vector<pii>> dp(N + 1, vector<pii>(N + 1, mp(-1, -1)));\n\n        rep(y, N + 1) rep(x, N + 1) if(cave[y][x] == n) dp[y][x] = isP[cave[y][x]] ? mp(1, cave[y][x]):mp(0, 0);\n\n        pii res = mp(-1, -1);\n        rep(y, N + 1){\n            rep(x, N + 1){\n                if(cave[y][x] > m || dp[y][x].F == -1) continue;\n\n                res = max(res, dp[y][x]);\n\n                rep(i, 3){\n                    int xx = x + dx[i];\n                    int yy = y + 1;\n\n                    if(xx < 0 || N < xx ||\n                       yy < 0 || N < yy) continue;\n\n                    dp[yy][xx] = max(dp[yy][xx], mp(dp[y][x].F + (isP[cave[yy][xx]] ? 1:0), isP[cave[yy][xx]] ? cave[yy][xx]:dp[y][x].S));\n                }\n            }\n        }\n\n        cout << res.F << \" \" << res.S << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint m, n;\nvector<vector<pair<bool, int> > > mp(1001, vector<pair<bool, int> >(1001, pair<bool, int>(false, 0)));\nvector<vector<P> > memo(1001, vector<P>(1001, P(-1, -1)));\nP dfs(P np) {\n\tif(memo[np.first][np.second].first != -1) {\n\t\treturn memo[np.first][np.second];\n\t}\n\tif(np.first < 0 || np.first >= 1001 || np.second < 0 || np.second >= 1001 || mp[np.first][np.second].second > m) {\n\t\treturn P(0, 0);\n\t}\n\tP res;\n\tres = max(max(dfs(P(np.first + 1, np.second)), dfs(P(np.first + 1, np.second - 1))), dfs(P(np.first + 1, np.second + 1)));\n\tif(mp[np.first][np.second].first) {\n\t\treturn memo[np.first][np.second] = max(P(1, mp[np.first][np.second].second), P(res.first + 1, res.second));\n\t} else {\n\t\treturn memo[np.first][np.second] = max(P(0, 0), P(res.first, res.second));\n\t}\n}\n\nint main(void) {\n\tvector<bool> prime(1001 * 1001 + 1, true);\n\tprime[0] = prime[1] = false;\n\tFOR(i, 2, 1001 * 1001 + 1) {\n\t\tif(prime[i]) {\n\t\t\tfor(ll j = 2; i * j <= 1001 * 1001; ++j) {\n\t\t\t\tprime[i * j] = false;\n\t\t\t}\n\t\t}\n\t}\n\tP cp = P(500, 500);\n\tll cnt = 1;\n\tll size = 1;\n\tll lim = 1;\n\twhile(cnt <= 1001 * 1001) {\n\t\tmp[cp.first][cp.second].second = cnt;\n\t\tif(prime[cnt]) mp[cp.first][cp.second].first = true;\n\t\t--lim;\n\t\tif(lim == 0) {\n\t\t\tsize += 2;\n\t\t\t++cp.second;\n\t\t\tlim = size * size - (size - 2) * (size - 2);\n\t\t} else {\n\t\t\tif(lim >= 2 * (size - 1) + size) {\n\t\t\t\t--cp.first;\n\t\t\t} else if(lim >= (size - 1) + size) {\n\t\t\t\t--cp.second;\n\t\t\t} else if(lim >= size) {\n\t\t\t\t++cp.first;\n\t\t\t} else {\n\t\t\t\t++cp.second;\n\t\t\t}\n\t\t}\n\t\t++cnt;\n\t}\n\twhile(true) {\n\t\tcin>>m>>n;\n\t\tif(m == 0 && n == 0) break;\n\t\tP sp;\n\t\tbool upd = false;\n\t\tREP(i, 1001) {\n\t\t\tREP(j, 1001) {\n\t\t\t\tif(mp[i][j].second == n) {\n\t\t\t\t\tsp.first = i;\n\t\t\t\t\tsp.second = j;\n\t\t\t\t\tupd = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(upd) break;\n\t\t}\n\t\tREP(i, 1001) {\n\t\t\tREP(j, 1001) {\n\t\t\t\tmemo[i][j].first = memo[i][j].second = -1;\n\t\t\t}\n\t\t}\n\t\tP ans = dfs(sp);\n\t\tif(ans.first == 0) cout<<0<<\" \"<<0<<endl;\n\t\telse cout<<ans.first<<\" \"<<ans.second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,s,e) for (int i=s;i<(e);i++)\n#define All(v) (v).begin(),(v).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long llint;\ntypedef pair<int, int> P;\nconst int MOD = (int)1e9 + 7;\nconst int INF = (int)1e18 * 5;\n\nint a[3000][3000];\nint X[1000010], Y[1000010];\nint dp[3000][3000];\n\nvector<int> prime;\n\nvoid PrimeTable(int N){\n    prime = vector<int>(N+1, 1);\n    prime[0] = 0;\n    prime[1] = 0;\n\n    for(int i=2; i*i<=N; ++i){\n        if(prime[i]){\n            for(int j=2; i*j<=N; ++j){\n                prime[i*j] = 0;\n            }\n        }\n    }\n}\n\nvoid build(){\n    int now = 1, dir = 0, diff = 1;\n    int x=1500, y=1500;\n    a[1500][1500] = 1;\n    X[1] = 1500, Y[1] = 1500;\n    while(now <= 1000000){\n        switch(dir){\n        case 0:\n            FOR(dx, 1, diff+1){\n                a[y][x+dx] = ++now;\n                X[now] = x+dx;\n                Y[now] = y;\n            }\n            x = x+diff;\n            break;\n        case 1:\n            FOR(dy, 1, diff+1){\n                a[y-dy][x] = ++now;\n                X[now] = x;\n                Y[now] = y-dy;\n            }\n            y = y-diff;\n            break;\n        case 2:\n            FOR(dx, 1, diff+1){\n                a[y][x-dx] = ++now;\n                X[now] = x-dx;\n                Y[now] = y;\n            }\n            x = x-diff;\n            break;\n        case 3:\n            FOR(dy, 1, diff+1){\n                a[y+dy][x] = ++now;\n                X[now] = x;\n                Y[now] = y+dy;\n            }\n            y = y+diff;\n            break;\n        }\n        if(dir%2) diff++;\n        dir = (dir+1)%4;\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    build();\n    int m, n;\n    PrimeTable(1000010);\n    cin >> m >> n;\n    while(!(m==0&&n==0)){\n        REP(i,3000)REP(j, 3000) dp[i][j]=-INF;\n        int sy = Y[n], sx = X[n];\n        dp[sy][sx] = prime[n];\n        int sf = 1;\n        P ans = mp(prime[n], prime[n] ? n : 0);\n        bool f=true;\n        for(int y=sy; f; y++){\n            f = false;\n            FOR(x, sx-sf, sx+sf+1){\n                if(a[y+1][x] <= 0 || a[y+1][x] > m) continue;\n                f = true;\n                dp[y+1][x] = max({dp[y][x-1], dp[y][x], dp[y][x+1]})+prime[a[y+1][x]];\n                if(ans.fi < dp[y+1][x]){\n                    ans.fi = dp[y+1][x];\n                    ans.se = a[y+1][x];\n                }else if(ans.fi == dp[y+1][x]){\n                    if(prime[a[y+1][x]]) chmax(ans.se, a[y+1][x]);\n                }\n            }\n            sf++;\n        }\n        cout << ans.fi << \" \" << ans.se << \"\\n\";\n        cin >> m >> n;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-11;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\twhile(1){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\tvi x(n+1),y(n+1),prime(n+1);\n\t\tfill(prime.begin(),prime.end(),1);\n\t\tprime[0]=prime[1]=0;\n\t\tfor(int i=2;i<=n;i++) if(prime[i]) for(int j=2*i;j<=n;j+=i) prime[j]=0;\n\t\tint I=3,d=1,id=2;\n\t\tfor(int i=0;id<=n;i++){\n\t\t\tfor(int j=0;id<=n&&j<=i/2;j++){\n\t\t\t\tx[id]=x[id-1]+dx[I];\n\t\t\t\ty[id]=y[id-1]+dy[I];\n\t\t\t\tid++;\n\t\t\t}\n\t\t\t(I+=1)%=4;\n\t\t}\n\t\tint mnx=inf,mxx=-inf,mny=inf,mxy=-inf;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tmnx=min(mnx,x[i]);\n\t\t\tmxx=max(mxx,x[i]);\n\t\t\tmny=min(mny,y[i]);\n\t\t\tmxy=max(mxy,y[i]);\n\t\t}\n\t\tint h=mxx-mnx+1,w=mxy-mny+1;\n\t\tvvi a(h,vi(w)),dp(h,vi(w,-inf));\n\t\tfor(int i=1;i<=n;i++) a[x[i]-mnx][y[i]-mny]=i;\n//\t\tfor(int i=0;i<h;i++){\n//\t\t\tfor(int j=0;j<w;j++) cout<<prime[a[i][j]]<<' ';cout<<endl;\n//\t\t}\n\t\tfor(int i=0;i<w;i++) if(a[h-1][i]) dp[h-1][i]=prime[a[h-1][i]];\n//\t\tcout<<'A'<<endl;\n//\t\tcout<<h<<' '<<w<<endl;\n\t\tfor(int i=h-2;i>=0;i--){\n\t\t\tfor(int j=0;j<w;j++) if(a[i][j]){\n\t\t\tdp[i][j]=0;\n\t\t\tif(a[i+1][j]) dp[i][j]=max(dp[i][j],dp[i+1][j]);\n\t\t\tif(j&&a[i+1][j-1]) dp[i][j]=max(dp[i][j],dp[i+1][j-1]);\n\t\t\tif(j<w-1&&a[i+1][j+1]) dp[i][j]=max(dp[i][j],dp[i+1][j+1]);\n\t\t\tif(prime[a[i][j]]) dp[i][j]++;\n\t\t}\n\t\t}\n//\t\tfor(int i=0;i<h;i++){\n//\t\t\tfor(int j=0;j<w;j++) cout<<(dp[i][j]<0?-1:dp[i][j])<<' ';cout<<endl;\n//\t\t}\n\t\tint X=x[m]-mnx,Y=y[m]-mny;\n//\t\tcout<<X<<' '<<Y<<endl;\n//\t\tcout<<dp[X][Y]<<endl;\n\t\tif(dp[X][Y]==0) cout<<0<<' '<<0<<endl;\n\t\telse{\n\t\t\tcout<<dp[X][Y]<<' ';\n\t\t\tqueue<P> q;\n\t\t\tq.push({X,Y});\n\t\t\tint res=0;\n\t\t\tvvi b(h,vi(w));\n\t\t\tb[X][Y]=1;\n\t\t\twhile(!q.empty()){\n\t\t\t\tP p=q.front();\n\t\t\t\tq.pop();\n\t\t\t\tX=p.first,Y=p.second;\n\t\t\t\tif(X+1<h&&a[X][Y]&&!b[X+1][Y]&&dp[X][Y]==dp[X+1][Y]+prime[a[X][Y]]){\n\t\t\t\t\tb[X+1][Y]=1;\n\t\t\t\t\tq.push({X+1,Y});\n\t\t\t\t}\n\t\t\t\tif(X+1<h&&Y+1<w&&a[X][Y+1]&&!b[X+1][Y+1]&&dp[X][Y]==dp[X+1][Y+1]+prime[a[X][Y]]){\n\t\t\t\t\tb[X+1][Y+1]=1;\n\t\t\t\t\tq.push({X+1,Y+1});\n\t\t\t\t}\n\t\t\t\tif(X+1<h&&Y-1>=0&&a[X][Y-1]&&!b[X+1][Y-1]&&dp[X][Y]==dp[X+1][Y-1]+prime[a[X][Y]]){\n\t\t\t\t\tb[X+1][Y-1]=1;\n\t\t\t\t\tq.push({X+1,Y-1});\n\t\t\t\t}\n\t\t\t\tif(dp[X][Y]==1&&prime[a[X][Y]]) res=max(res,a[X][Y]);\n\t\t\t}\n\t\t\tcout<<res<<endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\n// #define int long long\n\nconstexpr int inf = 1e7;\n\nsigned main(){\n\tconstexpr int MAX = 1010;\n\tvector<vector<int>> table(MAX * 2, vector<int>(MAX * 2, MAX * MAX+10));\n\t\n\tvector<pair<int,int>> num((MAX*2)*(MAX*2));\n\tvector<bool> soe(MAX * MAX*4+10);\n\t\n\tsoe[0] = soe[1] = true;\n\t\n\tfor(long long i = 2; i < soe.size(); i++){\n\t\tif(soe[i] == false){\n\t\t\tfor(long long j = i * i; j < soe.size(); j += i){\n\t\t\t\tsoe[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tnum[1] = {MAX,MAX};\n\ttable[MAX][MAX] = 1;\n\t\n\tfor(int i = 1; i < MAX; i++){ \n\t\tint n = (i * 2 + 1) * (i * 2 + 1);\n\t\t\n\t\tfor(int j = 0; j < 2 * i; j++){\n\t\t\ttable[MAX+i][MAX+i-j] = n;\n\t\t\tnum[n] = {MAX+i,MAX+i-j};\n\t\t\tn--;\n\t\t}\n\t\tfor(int j = 0; j < 2 * i; j++){\n\t\t\ttable[MAX+i-j][MAX-i] = n;\n\t\t\tnum[n] = {MAX+i-j,MAX-i};\n\t\t\t\n\t\t\tn--;\n\t\t}\n\t\tfor(int j = 0; j < 2 * i; j++){\n\t\t\ttable[MAX-i][MAX-i+j] = n;\n\t\t\tnum[n] = {MAX-i,MAX-i+j};\n\t\t\tn--;\n\t\t}\n\t\tfor(int j = 0; j < 2 * i; j++){\n\t\t\ttable[MAX-i+j][MAX+i] = n;\n\t\t\tnum[n] = {MAX-i+j,MAX+i};\n\t\t\tn--;\n\t\t}\n\t}\n\t\n\twhile(true){\n\t\tvector<vector<int>> dp(MAX * 2, vector<int>(MAX * 2));\n\t\tint maxi = 0;\n\t\tint m, n;\n\t\tint b, e;\n\t\tpair<int,int> ans;\n\t\t\n\t\tcin>>m>>n;\n\t\t\n\t\tif(!m && !n) break;\n\t\t\n\t\tif(soe[table[num[n].first][num[n].second]] == false) {\n\t\t\tdp[num[n].first][num[n].second] = 1;\n\t\t\tans = {1, n};\n\t\t} else {\n\t\t\tdp[num[n].first][num[n].second] = 0;\n\t\t}\n\t\t\n\t\tb = num[n].second-1;\n\t\te = num[n].second+1;\n\t\t\n\t\t\n\t\tfor(int i = num[n].first+1; i < MAX*2 - 5; i++, b--, e++){\n\t\t\tbool flag = false;\n\t\t\t\n\t\t\tb = max(b, 5);\n\t\t\te = min(e, MAX*2-5);\n\t\t\t\n\t\t\tfor(int j = b; j <= e; j++){\n\t\t\t\tif(table[i][j] > m) continue;\n\t\t\t\tif(table[i-1][j-1] <= m && j != b) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tdp[i][j] = max(dp[i][j], dp[i-1][j-1]);\n\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(table[i-1][j] <= m) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tdp[i][j] = max(dp[i][j], dp[i-1][j]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(table[i-1][j+1] <= m && j != e) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\t\tdp[i][j] = max(dp[i][j], dp[i-1][j+1]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(soe[table[i][j]] == false) {\n\t\t\t\t\tdp[i][j]++;\n\t\t\t\t\tif(ans < make_pair(dp[i][j],table[i][j])) {\n\t\t\t\t\t\tans =  make_pair(dp[i][j],table[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag == false) break;\n\t\t}\n\t\t\n\t\tcout<<ans.first<<\" \"<<ans.second<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1200\n#define LIMIT 1000100\ntypedef pair<int,int> pii;\n\nint M,N;\nint caves[MAX][MAX];\nint dp[MAX][MAX];\nmap<int,pii> mp;\nbool prime[LIMIT];\n\nconst int dx[4] = {1,0,-1,0};\nconst int dy[4] = {0,-1,0,1};\n\nvoid makePrime(){\n  fill(prime,prime+LIMIT,true);\n  prime[0] = prime[1] = false;\n  for(int i = 2 ; i*i < LIMIT ; i++){\n    if(prime[i]){\n      for(int j = i*2 ; j < LIMIT ; j+=i){\n        prime[j] = false;\n      }\n    }\n  }\n}\n\nvoid makeCaves(){\n  int x = 600,y = 600,dir = 0;\n  int num = 1,cnt = 1;\n  while(true){\n    if(cnt == LIMIT) break;\n    for(int i = 0 ; i < 2 ; i++){\n      for(int j = 0 ; j < num ; j++){\n        mp[cnt] = pii(y,x);\n        caves[y][x] = cnt++;\n        if(cnt == LIMIT){\n          return;\n        }\n        x += dx[dir];\n        y += dy[dir];\n      }\n      dir = (dir+1)%4;   \n    }\n    num++;\n  }\n}\n\nvoid solve(int sx,int sy){\n  dp[sy][sx] = prime[caves[sy][sx]];\n  for(int i = 0 ; i < MAX-1 ; i++){\n    for(int j = 1 ; j < MAX-1 ; j++){\n      if(dp[i][j] >= 0 && caves[i][j] <= M){\n        if(caves[i+1][j-1] <= M){\n          dp[i+1][j-1] = max(dp[i+1][j-1],dp[i][j]+prime[caves[i+1][j-1]]); \n        }\n        if(caves[i+1][j] <= M){\n          dp[i+1][j] = max(dp[i+1][j],dp[i][j]+prime[caves[i+1][j]]); \n        }\n        if(caves[i+1][j+1] <= M){\n          dp[i+1][j+1] = max(dp[i+1][j+1],dp[i][j]+prime[caves[i+1][j+1]]); \n        }\n      }\n    }\n  }\n  int res = 0, num = 0;\n  for(int i = 0 ; i < MAX ; i++){\n    for(int j = 0 ; j < MAX ; j++){\n      if(caves[i][j] <= M && prime[caves[i][j]]){\n        if(res < dp[i][j]){\n          res = dp[i][j];\n          num = caves[i][j];\n        }else if(res == dp[i][j]){\n          if(num < caves[i][j]){\n            num = caves[i][j];\n          }\n        }\n      }\n    }\n  }\n  cout << res << \" \" << num << endl;\n}\n\nint main(){\n  makeCaves();\n  makePrime();\n  while(cin >> M >> N, M){\n    pii src = mp[N];\n    memset(dp,-1,sizeof(dp));\n    solve(src.second,src.first);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nconst int max_n=1000010;\nbool is_prime[max_n];\nint prime[max_n];\nint sieve(int n){\n    int p=0;\n    rep(i,n+1) is_prime[i]=true;\n    is_prime[0]=is_prime[1]=false;\n    FOR(i,2,n+1){\n        if(is_prime[i]){\n            prime[p++]=i;\n            for(int j=2*i;j<=n;j+=i) is_prime[j]=false;\n        }\n    }\n    return p;\n}\nint g[1005][1005];\npint dp[1005][1005];\npint id[1000010];\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nconst int dx2[]={-1,0,1},dy2[]={1,1,1};\nint m,n;\npint dfs(int cur){\n    int x=id[cur].first,y=id[cur].second;\n    if(dp[y][x].first!=-1) return dp[y][x];\n    pint ret={0,0};\n    if(is_prime[cur]) ret={0,cur};\n    rep(i,3){\n        int tx=x+dx2[i],ty=y+dy2[i];\n        if(ty>=0&&tx>=0&&g[ty][tx]!=0&&g[ty][tx]<=m){\n            pint r=dfs(g[ty][tx]);\n            if(is_prime[g[ty][tx]])r.first+=1;\n            ret=max(ret,r);\n        }\n    }\n    return dp[y][x]=ret;\n}\nint main(){\n    sieve(1000009);\n    int cnt=1,cur=-1;\n    int cx=500,cy=500;\n    while(cnt!=1000001){\n        id[cnt]={cx,cy};\n        g[cy][cx]=cnt++;\n        if(g[cy+dy[(cur+1)%4]][cx+dx[(cur+1)%4]]==0) cur=(cur+1)%4;\n        cx+=dx[cur],cy+=dy[cur];\n    }\n    /*FOR(i,490,510){\n        FOR(j,490,510) cout<<g[i][j]<<\" \";\n        cout<<endl;\n    }*/\n    while(cin>>m>>n,m|n){\n        rep(i,1001)rep(j,1001) dp[i][j]={-1,-1};\n        pint ans=dfs(n);\n        cout<<ans.first+is_prime[n]<<\" \"<<ans.second<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define _for(i,j,N) for(int i = (j);i < (N);i++)\n#define _rep(i,j,N) for(int i = (j);i <= (N);i++)\n#define _dec(i,N,j) for(int i = (N-1);i >= (j);i--)\n#define _rec(i,N,j) for(int i = (N);i >=(j);i--)\n#define ALL(x) x.begin(),x.end()\n#define MEM(a,n) memset(a,n,sizeof(a))\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\n\nint get_int(){int x;scanf(\"%d\",&x);return x;}\nLL get_ll(){LL x;scanf(\"%lld\",&x);return x;}\ndouble get_db(){double x;scanf(\"%lf\",&x);return x;}\n\ntemplate<typename T> int chmin(T &a,T &b){if(a > b){a = b;return 1;}else return 0;}\ntemplate<typename T> int chmax(T &a,T &b){if(a < b){a = b;return 1;}else return 0;}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& v) {_for(i,0,v.size()) os << v[i] << \" \";return os;}\ntemplate<typename T>\nostream& operator<<(ostream& os,const set<T>& v){for(auto a:v) os << a <<\" \";return os;}\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& v){os << v.fst <<\" \"<<v.scd << \" \";return os;}\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const map<T1,T2>& v){for(auto a:v) cout << a << endl;return os;}\n\nstatic const int dx[8] = { 0,  -1, 0,  1,  1, -1,  1, -1};\nstatic const int dy[8] = { 1,  0,  -1, 0,  1, -1, -1,  1};\nconst double pi  = acos(-1.0);\nconst double eps = 1e-8;\nconst LL  INF  = 0x3f3f3f3f3f3f3f3f;\nconst int inf  = 0x3f3f3f3f;\n\nconst int maxn = 1e6+5;\nconst int maxh = 1e3;\nint G[2*maxh][2*maxh];\nint isprime[maxn];\n\nmap<int,pii> mp;\n\npii dp[maxh*2][maxh*2];\n\nint get_input(){\n    return 1;\n}\nvoid output(){;}\n\nvoid build(){\n    _for(i,0,maxn){\n        isprime[i] = 1;\n    }\n    isprime[1] = 0;\n    _for(i,2,sqrt(maxn)+1){\n        if(isprime[i]){\n            for(int j = 2*i; j < maxn;j+=i){\n                isprime[j] = 0;\n            }\n        }\n    }\n\n\n    int x = maxh;int y = maxh;\n    MEM(G,-1);\n    int step = 1;\n    int num = 1;\n    G[x][y] = num;\n    mp[1] = MP(maxh,maxh);\n\n    int k = 0;\n\n    while(true){\n        if(num >= 1e6) break;\n        _for(i,0,4){\n            k++;\n            if(num >= 1e6) break;\n            _for(j,0,step){\n                if(num >= 1e6) break;\n                num++;\n                x+= dx[i];\n                y += dy[i];\n                G[x][y] = num;\n                mp[num] = MP(x,y);\n            }\n            if(k == 2){\n                step++;\n                k = 0;\n            }\n        }\n    }\n    /*\n    _for(i,maxh -10,maxh + 10) {\n        _for(j,maxh-1,maxh+10)\n        {\n            printf(\"%d \",G[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    */\n\n}\nint N,M;\n\nbool valid(int x,int y){\n    int n = G[x][y];\n    if(n == -1 || n > M){\n        return false;\n    }\n    return true;\n}\n\npii searching(int x,int y){\n    pii &ret = dp[x][y];\n    if(ret.first >= 0) return ret;\n\n    if(isprime[G[x][y]]){\n        ret.second = G[x][y];\n        ret.first = 1;\n    }else{\n        ret.first = 0;\n    }\n\n    _for(i,-1,2){\n        int nexx = x + 1;\n        int nexy = y + i;\n        if(valid(nexx,nexy)){\n            pii kk = searching(nexx,nexy);\n            kk.first += isprime[G[x][y]];\n            chmax(ret,kk);\n        }\n    }\n\n    return ret;\n\n}\n\nint  main()\n{\n    build();\n    while(scanf(\"%d %d\",&M,&N)&&N){\n        _for(i,0,2*maxh) _for(j,0,2*maxh){\n            dp[i][j] = MP(-1,-1);\n        }\n\n        pii pos = mp[N];\n        int stx = pos.first;\n        int sty = pos.second;\n\n        pii ans = searching(stx,sty);\n\n        if(ans.first == 0) ans.second = 0;\n        cout << ans.first <<\" \"<<ans.second<<endl;\n\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nnamespace std {\n    template <>\n    class hash<std::pair<int, int>> {\n    public:\n        size_t operator()(const std::pair<int, int>& x) const{\n            return size_t((size_t)x.first * (size_t)x.second);\n        }\n    };\n}\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvoid solve(){\n    vector<bool> is_prime(1e6+1,true);\n    is_prime[0]=is_prime[1]=false;\n    rep(i,2,1e+6+1){\n        if(!is_prime[i]) continue;\n        for(int j=i*2; j<1e6+1; j+=i) is_prime[j]=false;\n    }\n    while(true){\n        int m,n;\n        cin >> m >> n;\n        if(m==0 and n==0) break;\n\n        unordered_map<pii,int> encode;\n        unordered_map<int,pii> decode;\n        unordered_map<int,vector<int>> xs;\n        {\n            int x=0,y=0,dir=3;\n            rep(i,1,m+1){\n                encode[make_pair(x,y)]=i;\n                decode[i]=make_pair(x,y);\n                xs[y].push_back(x);\n                int nx=x+dx[(dir+1)%4],ny=y+dy[(dir+1)%4];\n                if(encode.find(make_pair(nx,ny))==encode.end()) dir=(dir+1)%4;\n                else{\n                    nx=x+dx[dir];\n                    ny=y+dy[dir];\n                }\n                x=nx;\n                y=ny;\n            }\n        }\n\n        unordered_map<pii,int> dp;\n        int y=decode[n].second+1,ans,max_num;\n        if(is_prime[n]){\n            dp[decode[n]]=1;\n            ans=1;\n            max_num=n;\n        }else{\n            dp[decode[n]]=0;\n            ans=0;\n            max_num=0;\n        }\n        while(xs.find(y)!=xs.end()){\n            if(xs.find(y-2)!=xs.end()) for(int x:xs[y-2]) dp.erase(make_pair(x,y));\n            for(int x:xs[y]){\n                int tmp=-1;\n                if(dp.find(make_pair(x-1,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x-1,y-1)]);\n                if(dp.find(make_pair(x,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x,y-1)]);\n                if(dp.find(make_pair(x+1,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x+1,y-1)]);\n                if(tmp==-1) continue;\n                if(is_prime[encode[make_pair(x,y)]]){\n                    ++tmp;\n                    if(tmp>ans){\n                        ans=tmp;\n                        max_num=encode[make_pair(x,y)];\n                    }else if(tmp==ans) max_num=max(max_num,encode[make_pair(x,y)]);\n                }\n                dp[make_pair(x,y)]=tmp;\n            }\n            ++y;\n        }\n\n        cout << ans << \" \" << max_num << endl;\n    }\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int MAX = 1500;\nconst int MAX2 = 1000000;\nconst int dy[4] = {0,-1,0,1};\nconst int dx[4] = {1,0,-1,0};\n\nint n,m,G[MAX][MAX];\nbool isPrime[MAX2+1];\nP pos[MAX2+1];\n\nbool check(int y, int x){\n  if(y < 0 || y >= MAX) return false;\n  if(x < 0 || x >= MAX) return false;\n  if(G[y][x] > m) return false;\n  return true;\n}\n\nvoid makeP(){\n  fill(isPrime, isPrime+MAX2+1, true);\n  isPrime[0] = isPrime[1] = false;\n  for(int i=2;i<=MAX2;i++){\n    if(isPrime[i]){\n      for(int j=i*2;j<=MAX2;j+=i) isPrime[j] = false;\n    }\n  }\n}\n\nvoid makeG(){\n  int y = MAX / 2, x = MAX / 2, step = 0;\n  fill(G[0],G[MAX],0);\n  for(int i=1;i<=MAX2;){\n    for(int j=0;j<4;j++){\n      if(j % 2 == 0) step++;\n      for(int k=0;k<step;k++){\n        pos[i] = P(x,y);\n        G[y][x] = i++;\n        y += dy[j];\n        x += dx[j];\n      }\n    }\n  }\n}\n\nint dp[MAX][MAX],dp2[MAX][MAX];\n\nvoid solve(){\n  int ans=0, ans2=0;\n  fill(dp[0],dp[MAX],-1);\n  fill(dp2[0],dp2[MAX],0);\n  dp[pos[n].second][pos[n].first] = isPrime[n];\n  if(isPrime[n]) dp2[pos[n].second][pos[n].first] = n;\n\n  for(int i=pos[n].second;i<MAX;i++){\n    for(int j=0;j<MAX;j++){\n      if(dp[i][j] == -1) continue;\n\n      if(ans < dp[i][j]){\n        ans = dp[i][j];\n        ans2 = dp2[i][j];\n      } else if(ans == dp[i][j]) ans2 = max(ans2, dp2[i][j]);\n\n      for(int k=-1;k<=1;k++){\n        int ny = i + 1;\n        int nx = j + k;\n        if(check(ny,nx)){\n          if(dp[ny][nx] < dp[i][j] + isPrime[G[ny][nx]]){\n            dp[ny][nx] = dp[i][j] + isPrime[G[ny][nx]];\n            if(isPrime[G[ny][nx]]) dp2[ny][nx] = G[ny][nx];\n            else dp2[ny][nx] = dp2[i][j];\n          } else if(dp[ny][nx] == dp[i][j] + isPrime[G[ny][nx]]){\n            if(isPrime[G[ny][nx]]) dp2[ny][nx] = max(dp2[ny][nx], G[ny][nx]);\n            else dp2[ny][nx] = max(dp2[ny][nx], dp2[i][j]);\n          }\n        }\n      }\n    }\n  }\n  cout << ans << ' ' << ans2 << endl;\n}\n\nint main(){\n  makeP();\n  makeG();\n  while(cin >> m >> n && (n|m)) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvoid solve(){\n    vector<bool> is_prime(1e6+1,true);\n    is_prime[0]=is_prime[1]=false;\n    rep(i,2,1e+6+1){\n        if(!is_prime[i]) continue;\n        for(int j=i*2; j<1e6+1; j+=i) is_prime[j]=false;\n    }\n    while(true){\n        int m,n;\n        cin >> m >> n;\n        if(m==0 and n==0) break;\n\n        map<pii,int> encode;\n        unordered_map<int,pii> decode;\n        unordered_map<int,vector<int>> xs;\n        {\n            int x=0,y=0,dir=3;\n            rep(i,1,m+1){\n                encode[make_pair(x,y)]=i;\n                decode[i]=make_pair(x,y);\n                xs[y].push_back(x);\n                int nx=x+dx[(dir+1)%4],ny=y+dy[(dir+1)%4];\n                if(encode.find(make_pair(nx,ny))==encode.end()) dir=(dir+1)%4;\n                else{\n                    nx=x+dx[dir];\n                    ny=y+dy[dir];\n                }\n                x=nx;\n                y=ny;\n            }\n        }\n\n        map<pii,int> dp;\n        int y=decode[n].second+1,ans,max_num;\n        if(is_prime[n]){\n            dp[decode[n]]=1;\n            ans=1;\n            max_num=n;\n        }else{\n            dp[decode[n]]=0;\n            ans=0;\n            max_num=0;\n        }\n        while(xs.find(y)!=xs.end()){\n            for(int x:xs[y]){\n                int tmp=-1;\n                if(dp.find(make_pair(x-1,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x-1,y-1)]);\n                if(dp.find(make_pair(x,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x,y-1)]);\n                if(dp.find(make_pair(x+1,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x+1,y-1)]);\n                if(tmp==-1) continue;\n                if(is_prime[encode[make_pair(x,y)]]){\n                    ++tmp;\n                    if(tmp>ans){\n                        ans=tmp;\n                        max_num=encode[make_pair(x,y)];\n                    }else if(tmp==ans) max_num=max(max_num,encode[make_pair(x,y)]);\n                }\n                dp[make_pair(x,y)]=tmp;\n            }\n            ++y;\n        }\n\n        cout << ans << \" \" << max_num << endl;\n    }\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <stdlib.h>\n#include <math.h>\n#include <list>\n#include <algorithm>\n\nusing namespace std;\n\n//平方数かどうか調べる\nint isSq(int n) {\n\tif(n <= 0) return 0;\n\n\tfor(int i = 1; i <= (int)sqrt( (double)n ) + 1; i++) {\n\t\tif( n % i == 0 && n / i == i ) return i;\n\t}\n\t\n\treturn 0;\n}\n//素数かどうか調べる\nint isPrime(int n) {\n\tif(n <= 1) return 0;\n\tint flg = 1;\n\tfor(int i = 2; i <= (int)sqrt((double)n) + 1; i++) {\n\t\tif( n % i == 0) {\n\t\t\tflg = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn flg;\n}\n\nstruct memo{\n\tint last;\n\tint pts;\n};\nstruct cave{\n\tint x;\n\tint y;\n\tint flg;\n\tint num;\n};\n\n//動的計画法で探査\n//番号が決まれば得点がきまるはず\nvoid search_cave(int n, int xpos, int ypos, vector<memo>*m, vector<vector<int>> *cv, vector<cave> *cl, int h, int w){\n\n\tif( m -> at(n).last != -1 ) {\n\t\t//探索済みの場合\n\t\treturn;\n\t} else {\n\t\t//未探索の場合\n\t\t//直下の三洞窟を探索する\n\t\t//直下三通りはすでに探索済みとする\n\n\t\tif( ypos == h - 1 ) {\n\t\t\t//一番下ならば？\n\t\t\tm->at(n).pts = cl->at(n).flg;\n\t\t\tm->at(n).last = 0;\n\t\t\tif(cl->at(n).flg == 1) m->at(n).last = n;\n\t\t} else {\n\t\t\t//降りられる洞穴がある場合\n\t\t\tint indx;\n\t\t\tint point[3] = {-1,-1,-1};\n\t\t\tint last[3] = {-1,-1,-1};\n\t\t\t//左右移動できるか確認する\n\t\t\tif(( (xpos > 0) ) )\t{\t//左下\n\t\t\t\tint tmp = cv->at( xpos - 1 ).at( ypos + 1 );\n\t\t\t\tpoint[0] = m->at( tmp ).pts;\n\t\t\t\tlast[0] = m->at(tmp).last;\n\t\t\t}\n\t\t\tif( xpos < w - 1) { //右下\n\t\t\t\tint tmp = cv->at( xpos + 1 ).at( ypos + 1 );\n\t\t\t\tpoint[1] = m->at( tmp ).pts;\n\t\t\t\tlast[1] = m->at( tmp ).last;\n\t\t\t}\n\t\t\tif( 1 ) {\t\t\t//真下\n\t\t\t\tint tmp = cv -> at( xpos ).at( ypos + 1 );\n\t\t\t\tpoint[2] = m -> at( tmp ).pts;\n\t\t\t\tlast[2] = m -> at( tmp ).last;\n\t\t\t}\n\n\t\t\t//大小比較する\n\t\t\tif( point[0] < point[1] ) {\n\t\t\t\tindx = 1;\n\t\t\t} else if( point[0] > point[1] ) {\n\t\t\t\tindx = 0;\n\t\t\t} else {\n\t\t\t\tif(last[0] < last[1]) indx = 1;\n\t\t\t\telse indx = 0;\n\t\t\t}\n\n\t\t\tif( point[indx] < point[2] ) {\n\t\t\t\tindx = 2;\n\t\t\t} else if( point[indx] > point[2] ) {\n\t\t\t\tindx = indx;\n\t\t\t} else {\n\t\t\t\tif(last[indx] < last[2]) indx = 2;\n\t\t\t\telse indx = indx;\n\t\t\t}\n\n\t\t\tm -> at(n).pts = point[indx] + cl -> at(n).flg ;\n\t\t\tm -> at(n).last = last[indx]  ;\n\t\t\tif(last[indx] <= 0 && cl -> at(n).flg > 0) m -> at(n).last = n;\n\n\t\t}\n\t}\n}\n\nint main(void){\n//\tFILE* fp_in = freopen(\"data.txt\", \"r\", stdin);\n\twhile(1){\n\t\tint m, n;\n\t\tvector<cave> clist;\n\n\t\tcin >> m >> n;\n\t\tif( m == 0 && n == 0 ) break;\n\t\t\n\t\tcave c;\n\t\tc.x = -1;\n\t\tc.y = 0;\n\t\tc.flg = 0;\n\t\tc.num = 0;\n\t\tclist.push_back(c);\n\n\t\t//洞窟の大きさを調べる\n\t\tint dir = 0, sq = 1;\n\t\tfor(int i = 1; i <= m; i ++) {\n\t\t\tif( isSq(i) != 0 ) \n\t\t\t\tsq = isSq(i);\n\t\t\t//進む\n\t\t\tswitch(dir) {\n\t\t\t\tcase 0:\n\t\t\t\t\tc.x ++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tc.y --;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tc.x --;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tc.y ++;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//方向転換\n\t\t\tif( ( isSq( i - 1 ) != 0 ) || ( i == sq*sq + sq + 1 ) ) { \n\t\t\t\tdir ++;\n\t\t\t\tif( dir > 3 ) dir = 0;\n\t\t\t}\n\t\t\tc.flg = isPrime(i);\n\t\t\tc.num = i;\n\t\t\tclist.push_back(c);\n\t\t}\n\n\t\t//洞窟の大きさを取得する\n\t\tint x_max = 0, x_min = 0, y_max = 0, y_min = 0;\n\t\tfor(int i = 1; i < clist.size(); i++) {\n\t\t\tif( clist.at(i).x < x_min ) x_min = clist.at(i).x;\n\t\t\tif( clist.at(i).x > x_max ) x_max = clist.at(i).x;\n\t\t\tif( clist.at(i).y < y_min ) y_min = clist.at(i).y;\n\t\t\tif( clist.at(i).y > y_max ) y_max = clist.at(i).y;\n\t\t}\n\n\t\t//上端のy座標を0にセット\n\t\tfor(int i = 1; i < clist.size(); i++) {\n\t\t\tclist.at(i).y -= y_min;\n\t\t\tclist.at(i).x -= x_min;\n\t\t}\n\t\t\n\t\t//洞穴を意味するvector\n\t\tvector<vector<int>> caves;\n\t\tfor(int i = 0; i <= x_max - x_min; i++) {\n\t\t\tvector<int> newcave;\n\t\t\tfor(int j = 0; j <= y_max - y_min; j++)\n\t\t\t\tnewcave.push_back(0);\n\t\t\tcaves.push_back(newcave);\n\t\t}\n\n\t\t//番号をセットする\n\t\tfor(int i = 1; i < clist.size(); i++) \n\t\t\tcaves.at( clist.at(i).x ).at( clist.at(i).y ) = clist.at(i).num;\n\n\t\t//メモ用vector\n\t\tvector<memo> memory;\n\t\tfor(int i = 0; i < clist.size() + 2; i++) {\n\t\t\tmemo newmemo;\n\t\t\tnewmemo.last = -1;\n\t\t\tnewmemo.pts = 0;\n\t\t\tmemory.push_back(newmemo);\n\t\t}\n\n\t\tint height = caves.at(0).size();\n\t\tint width = caves.size();\n\t\tint ans[2];\n\t\tint flg = 0;\n\t\n\n\t\t//一番下から調べる\n\t\tfor(int i = height - 1; i >= 0; i--) {\n\t\t\tfor(int j = 0; j < width; j++) {\n\t\t\t\tint num = caves.at(j).at(i);\n\t\t\t\tsearch_cave(num, j, i, &memory, &caves, &clist, height, width);\n\t\t\t\tif( num == n ) {\n\t\t\t\t\tflg = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg) break;\n\t\t}\n\t\t\n\n\t\tans[0] = memory.at(n).pts;\n\t\tans[1] = memory.at(n).last;\n\t\tif( ans[0] == 0 ) ans[1] = 0;\n\n\t\tcout << ans[0] << \" \" << ans[1] << endl;\n\t}\n\n//\twhile(1){}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n\ntypedef long long ll;\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int MAXM = 1000100;\nbool isPrime[MAXM];\nint dp[1500][1500];\nint last[1500][1500];\n\nclass Board {\npublic:\n    vector<vector<int> > board;\n    vector<pair<int, int> > pos;\n    int maxDepth;\n    int minWidth;\n    int maxWidth;\n    Board(int n) {\n        maxDepth = 0;\n        minWidth = 1500;\n        maxWidth = 0;\n        pos.resize(n+10);\n        for (int i = 0; i < 1500; i++) {\n            vector<int> tmp(1500);\n            board.push_back(tmp);\n        }\n        pair<int, int> position = make_pair(750, 750);\n        int direction = 0;\n        for (int cur = 1; cur <= n; cur++) {\n            maxDepth = max(maxDepth, position.second);\n            maxWidth = max(maxWidth, position.first);\n            minWidth = min(minWidth, position.first);\n            board[position.second][position.first] = cur;\n            pos[cur] = position;\n            int left = direction+1;\n            left %= 4;\n            if (board[position.second+dy[left]][position.first+dx[left]] == 0) {\n                direction = left;\n            }\n            position.first += dx[direction];\n            position.second += dy[direction];\n        }\n    }\n};\n\nvoid initPrime() {\n    for (int i = 2; i < MAXM; i++) isPrime[i] = true;\n    for (int i = 2; i*i < MAXM; i++) {\n        if (isPrime[i]) {\n            for (int j = 2; j * i < MAXM; j++) {\n                isPrime[i*j] = false;\n            }\n        }\n    }\n}\n\nint main(void) {\n    int n, m;\n    initPrime();\n    while (cin >> n >> m) {\n        if (n == 0 && m == 0) break;\n        Board board(n);\n        //for (int i = 745; i < 755; i++) {\n        //    for (int j = 745; j < 755; j++) {\n        //        cout << board.board[i][j] << \"\\t\";\n        //    }\n        //    cout << endl;\n        //}\n        //cout << board.maxDepth << endl;\n        for (int i = 0; i < 1500; i++) {\n            for (int j = 0; j < 1500; j++) {\n                dp[i][j] = -1;\n                last[i][j] = -1;\n            }\n        }\n        auto start = board.pos[m];\n        if (isPrime[m]) dp[start.second][start.first] = 1, last[start.second][start.first] = m;\n        else dp[start.second][start.first] = 0;\n        for (int i = start.second; i <= board.maxDepth; i++) {\n            for (int j = board.minWidth; j < board.maxWidth; j++) {\n                if (dp[i][j] == -1) continue;\n                for (int k = -1; k <= 1; k++) {\n                    pair<int, int> next = make_pair(j+k, i+1);\n                    if (next.first < board.minWidth || next.second > board.maxWidth || board.board[next.second][next.first] > n) continue;\n                    if (isPrime[board.board[next.second][next.first]]) {\n                        if (dp[next.second][next.first] <= dp[i][j] + 1) {\n                            dp[next.second][next.first] = dp[i][j] + 1;\n                            last[next.second][next.first] = board.board[next.second][next.first];\n                        }\n                    } else {\n                        if (dp[next.second][next.first] <= dp[i][j]) {\n                            dp[next.second][next.first] = dp[i][j];\n                            last[next.second][next.first] = last[i][j];\n                        }\n                    }\n                }\n            }\n        }\n//        for (int i = 745; i < 755; i++) {\n//            for (int j = 745; j < 755; j++) {\n//                cout << dp[i][j] << \"\\t\";\n//            }\n//            cout << endl;\n//        }\n//        for (int i = 745; i < 755; i++) {\n//            for (int j = 745; j < 755; j++) {\n//                cout << last[i][j] << \"\\t\";\n//            }\n//            cout << endl;\n//        }\n        pair<int, int> ans;\n        for (int i = board.minWidth; i <= board.maxWidth; i++) {\n            ans = max(make_pair(dp[board.maxDepth][i], last[board.maxDepth][i]), ans);\n        }\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define H 1000\n#define W 1000\nusing namespace std;\nint grid[H][W];\ntypedef pair<int, int> pii;\n\npii dp[(int)1e6 + 1];//first cnt, second max\nbool isprime[(int)1e6 + 1];\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid sieve(int n){\n  isprime[0] = isprime[1] = true;\n  for(int i = 2; i <= n; i++){\n    if(isprime[i])continue;\n    for(int j = 2*i; j <= n; j+=i)isprime[j] = true;\n  }\n}\n\n\nbool renge(int x, int y){\n  if(0 <= x && x < W &&\n     0 <= y && y < H)return true;\n  return false;\n}\nvector<int> inM(int y, int x, int m){\n  vector<int> res;\n  if(y + 1 >= H) return res;\n  for(int i = -1; i < 2; i++){\n    if(grid[y + 1][x + i] <= m)res.push_back(i);\n  }\n  return res;\n}\n\nint main(int argc, char *argv[]){\n  sieve((int)1e6);\n  int n = H*W, m, x = 0, y = 0, dir = 0;\n  while(n >= 1){\n    for(;renge(x + dx[dir], y + dy[dir]) && \n\t  grid[y + dy[dir]][x + dx[dir]] == 0;){\n      grid[y][x] = n;\n      n--;\n      x += dx[dir], y += dy[dir];\n    }\n    grid[y][x] = n;\n    n--;\n    dir++;\n    dir %= 4;\n    x += dx[dir], y += dy[dir];\n  }\n  while(cin >> m >> n, n){\n    memset(dp, 0, sizeof(dp));\n    for(int i = H - 1; i >= 0; i--){\n      for(int j = 0; j < W; j++){\n\tif(grid[i][j] <= m){\n\t  vector<int> cand = inM(i, j, m);\n\t  for(int k = 0; k < cand.size(); k++){\n\t    dp[grid[i][j]] = max(dp[grid[i][j]], dp[grid[i + 1][j + cand[k]]]);\n\t  }\n\t  if(!isprime[grid[i][j]]){\n\t    if(dp[grid[i][j]].first == 0)dp[grid[i][j]].second = grid[i][j];\n\t    dp[grid[i][j]].first++;\n\t  }\n\t}\n      }\n    }\n    cout << dp[n].first << \" \" << dp[n].second << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lpin(a,i,n) for(int i=0;i<n;i++){cin>>a[i];}\n\nint a[2000][2000];\nint zahyou[1000001];\nbool sosu[1000001];\nint xmax,ymax,xmin=10000,ymin=10000;\n\nvoid sosuu(){\n  sosu[1]=1;\n  for(int i=2;i<=sqrt(1000000);i++){\n    if(sosu[i]==0){\n      for(int j=i+i;j<=1000000;j+=i){\n\tsosu[j]=1;\n      }\n    }\n  }\n  return;\n}\n\n\nvoid anaume(int x,int y,int movecount,int nownumber,int direc,int direcmax,int direccount){\n  while(nownumber!=1000000){\n  a[x][y]=nownumber;\n  zahyou[nownumber]=x+y*10000;\n  xmax=max(xmax,x);\n  ymax=max(ymax,y);\n  xmin=min(xmin,x);\n  ymin=min(ymin,y);\n  if(movecount==direcmax){\n    if(direccount==1){\n      direcmax++;\n      direccount=0;\n    }\n    else{\n      direccount++;\n    }\n    if(direc==4) direc=1;\n    else direc++;\n    movecount=0;\n  }\n  if(direc==1){x++;\n  }\n  if(direc==2){y++;\n  }\n  if(direc==3){x--;\n  }\n  if(direc==4){y--;\n  }\n  movecount++;\n  nownumber++;\n  }\n  return;\n}\n\nint ans=0;\nint last;\nint dp[2000][2000];\nvoid search(int nowx,int nowy,int maxs,int count){\n  if(sosu[a[nowx][nowy]]==0){\n    count++;\n  }\n  if(dp[nowx][nowy]>=count) return;\n  if(a[nowx][nowy]>maxs) return;\n  if(nowy==ymin) return;\n  if(ans<=count||ans==count&&last<=a[nowx][nowy]){\n    ans=count;\n    last=a[nowx][nowy];\n  }\n  if(nowx!=xmax) search(nowx+1,nowy-1,maxs,count);\n  if(nowx!=xmin) search(nowx-1,nowy-1,maxs,count);\n  search(nowx,nowy-1,maxs,count);\n  return;\n}\n\nint main(){\n  sosuu();\n  anaume(1000,1000,0,1,1,1,0);\n  while(1){\n    int a,b;\n    cin>>a>>b;\n    if(a==0&&b==0) break;\n    int c=zahyou[b]%10000;\n    int d=zahyou[b]/10000;\n    lp(i,2000){\n      lp(j,2000){\n\tdp[i][j]=-1;\n      }\n    }\n    ans=0;\n    last=0;\n    search(c,d,a,0);\n    if(ans==0) last=0;\n    cout<<ans<<\" \"<<last<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nbool isso(long long int a) {\n\tif (a == 1 || a == 0)return false;\n\tfor (long long int i = 2; i*i <= a; ++i) {\n\t\tif ((a%i)) {\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,1,0,-1 };\npair<bool,int> caves[1199][1199];\npair<int,int> dp[1199][1199];\nvector<pair<int, int>>places(1010000);\n\nint main() {\n\t{\n\t\tfor (int i = 0; i < 1199; ++i) {\n\t\t\tfor (int j = 0; j < 1199; ++j) {\n\t\t\t\tcaves[i][j] = { false,-1 };\n\t\t\t}\n\t\t}\n\t\tint num = 1;\n\t\tint ny = 600;\n\t\tint nx = 600;\n\t\tint roopnum =2;\n\t\tint way = 2;\n\t\twhile (num <= 1000000) {\n\t\t\tfor (int i = 0; i < roopnum / 2; ++i) {\n\t\t\t\tcaves[ny][nx] = { isso(num),num };\n\t\t\t\tplaces[num] = { ny,nx };\n\t\t\t\tny += dy[way]; nx += dx[way];\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\troopnum++;\n\t\t\tway = (way + 1) % 4;\n\t\t}\n\t}\n\twhile (1) {\n\t\tint m, n; cin >> m >> n;\n\t\tif (!m)break;\n\t\tfor (int i = 0; i < 1199; ++i) {\n\t\t\tfor (int j = 0; j < 1199; ++j) {\n\t\t\t\tdp[i][j] = { -1,-999999 };\n\t\t\t}\n\t\t}\n\t\tint ny = places[n].first;\n\t\tint nx = places[n].second;\n\t\tif (caves[ny][nx].first) {\n\t\t\tdp[ny][nx] = { caves[ny][nx].second,1 };\n\t\t}\n\t\telse {\n\t\t\tdp[ny][nx] = { -1,0 };\n\n\t\t}\n\t\tfor (int y = 0; y < 1198; ++y) {\n\t\t\tfor (int x = 1; x < 1198; ++x) {\n\t\t\t\tfor (int ax = -1; ax <= 1; ++ax) {\n\t\t\t\t\tconst int newy = y + 1;\n\t\t\t\t\tconst int newx = x + ax;\n\t\t\t\t\tbool so = (caves[newy][newx].first)&&(caves[newy][newx].second <= m);\n\t\t\t\t\tconst int newsonum = dp[y][x].second + so;\n\t\t\t\t\tif (dp[newy][newx].second < newsonum) {\n\t\t\t\t\t\tdp[newy][newx].second = newsonum;\n\t\t\t\t\t\tif (so) {\n\t\t\t\t\t\t\tdp[newy][newx].first = caves[newy][newx].second;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdp[newy][newx].first = dp[y][x].first;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (dp[newy][newx].second == newsonum) {\n\t\t\t\t\t\tif (so) {\n\t\t\t\t\t\t\tdp[newy][newx].first = caves[newy][newx].second;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdp[newy][newx].first = max(dp[newy][newx].first, dp[y][x].first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint maxso = 0;\n\t\tint maxnum = 0;\n\t\tfor (int x = 0; x < 1199; ++x) {\n\t\t\tif (maxso == dp[1198][x].first) {\n\t\t\t\tmaxnum = max(maxnum, dp[1198][x].first);\n\t\t\t}\n\t\t\telse if(maxso<dp[1198][x].second){\n\t\t\t\tmaxso = dp[1198][x].second;\n\t\t\t\tmaxnum = dp[1198][x].first;\n\t\t\t}\n\t\t}\n\t\tcout << maxso << \" \" << maxnum << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nint caves[2000][2000];\n\nbool sieve[1000001];\nint SX, SY;\n\ntypedef pair<int, int> PII;\n\nPII dp[2000][2000];\nbool vis[2000][2000];\n\nint main()\n{\n\tint nx, ny;\n\tfill(sieve, sieve + 1000001, true);\n\tsieve[0] = sieve[1] = false;\n\tfor(int i = 2; i * i <= 1000000; ++i) {\n\t\tif(sieve[i]) {\n\t\t\tfor(int j = i * i; j <= 1000000; j += i) {\n\t\t\t\tsieve[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint M, N;\n\twhile (cin>>M>>N, M||N) {\n\t\tmemset(caves, -1, sizeof(caves));\n\t\t\n\t\tfor (int j=0; j<2000; j++) {\n\t\t\tfor (int i=0; i<2000; i++) {\n\t\t\t\tdp[i][j] = PII(0, -1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tnx = ny = 2000/2;\n\t\tint len=1, num=2;\n\t\tint d = 0;\n\t\t\n\t\tcaves[nx][ny] = 1;\n\t\t\n\t\twhile (num <= M) {\n\t\t\tfor (int j=0; j<len; j++) {\n\t\t\t\tnx += dx[d];\n\t\t\t\tny += dy[d];\n\t\t\t\tcaves[nx][ny] = num++;\n\t\t\t\tif (num > M) break;\n\t\t\t}\n\t\t\td++; d %= 4;\n\t\t\tif (num > M) break;\n\t\t\t\n\t\t\tfor (int j=0; j<len; j++) {\n\t\t\t\tnx += dx[d];\n\t\t\t\tny += dy[d];\n\t\t\t\tcaves[nx][ny] = num++;\n\t\t\t\tif (num > M) break;\n\t\t\t}\n\t\t\t\n\t\t\td++;\n\t\t\td %= 4;\n\t\t\tlen++;\n\t\t}\n\t\t\n\t\tfor (int i=0; i<2000; i++) {\n\t\t\tfor (int j=0; j<2000; j++) {\n\t\t\t\tif (caves[j][i] == N) {\n\t\t\t\t\tSX = j, SY = i;\n\t\t\t\t\tif(sieve[N]) {\n\t\t\t\t\t\tdp[i][j] = PII(1, N);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j] = PII(0, -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t#if 0\n\t\tfor (int i=1000-10; i<1000+10; i++) {\n\t\t\tfor (int j=1000-10; j<1000+10; j++) {\n\t\t\t\tprintf(\"%3d\", caves[j][i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t#endif\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tvis[SY][SX] = true;\n\t\tfor(int i = 0; i < 2000 - 1; ++i) {\n\t\t\tfor(int j = 0; j < 2000; ++j) {\n\t\t\t\tif(vis[i][j] == false) continue;\n\t\t\t\tfor(int k = -1; k <= 1; ++k) {\n\t\t\t\t\tint nx = j + k;\n\t\t\t\t\tif(nx < 0 || nx >= 2000) continue;\n\t\t\t\t\tint add = dp[i][j].first;\n\t\t\t\t\tint maxP = dp[i][j].second;\n\t\t\t\t\tif(caves[nx][i + 1] > 0 && sieve[caves[nx][i + 1]]) {\n\t\t\t\t\t\tadd++;\n\t\t\t\t\t\tmaxP = caves[nx][i + 1];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i + 1][nx] = max(dp[i + 1][nx], PII(add, maxP));\n\t\t\t\t\tvis[i + 1][nx] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tPII ans(-1, -1);\n\t\tfor(int j = 0; j < 2000; ++j) {\n\t\t\tans = max(ans, dp[2000 - 1][j]);\n\t\t}\n\t\tcout << ans.first << ' ' << max(0, ans.second) << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF = 1000000000;\n\nint prime[100000];\nint primeNumber;\n\nint d[1011][1011];\nint xData[1000101];\nint yData[1000101];\nint p[1011][1011];\n\nint dp[1000001];\nbool used[1000001];\nint m, n;\n\nint main(){\n  prime[0] = 2;\n  primeNumber = 1;\n  for (int i = 3; i <= 1000100; i++) {\n    bool flag = true;\n    for (int j = 0; j < primeNumber; j++) {\n      if (i < prime[j] * prime[j]) break;\n      if (i % prime[j] == 0) {\n        flag = false;\n        break;\n      }\n    }\n    if (flag) prime[primeNumber++] = i;\n  }\n\n  int x = 505, y = 505; // 1(505, 505)\n  int counter = 2; // max move : counter / 2\n  int tempCounter = 1;\n  int moveDirection = 0; // right 0 up 1 left 2 down 3\n  for (int num = 1; num <= 1000100; num++) {\n    d[x][y] = num; xData[num] = x; yData[num] = y;\n    tempCounter--;\n    if (moveDirection == 0) x++;\n    if (moveDirection == 1) y--;\n    if (moveDirection == 2) x--;\n    if (moveDirection == 3) y++;\n    if (tempCounter == 0) {\n      counter++;\n      tempCounter = counter / 2;\n      moveDirection = (moveDirection + 1) % 4;\n    }\n  }\n\n  for (int i = 0; i < 1011; i++)\n    for (int j = 0; j < 1011; j++)\n      p[i][j] = 0;\n\n  for (int i = 0; i < primeNumber; i++)\n    p[xData[prime[i]]][yData[prime[i]]] = 1;\n\n  while (1) {\n    scanf(\"%d%d\", &m, &n);\n    if (m == 0) break;\n    \n    for (int i = 0; i < 1000001; i++)\n        dp[i] = -1;\n\n    for (int i = 0; i < 1000001; i++) used[i] = false;\n\n    queue<int> que;\n    que.push(n);\n    dp[n] = p[xData[n]][yData[n]];\n    int ans[2] = {0, 0};\n    if (dp[n] == 1) {\n      ans[0] = 1;\n      ans[1] = n;\n    }\n    while (!que.empty()) {\n      int z = que.front(); que.pop();\n      if (used[z]) continue;\n      used[z] = true;\n      for (int i = -1; i <= 1; i++) {\n        int x = xData[z] + i, y = yData[z] + 1;\n        int s = d[x][y];\n        if (s > m) continue;\n        if (dp[s] >= dp[z] + p[x][y]) continue;\n        dp[s] = dp[z] + p[x][y];\n        que.push(s);\n        if (ans[0] < dp[s]) {\n          ans[0] = dp[s];\n          if (p[x][y] == 1) ans[1] = s;\n        }\n        else if (ans[0] == dp[s] && ans[1] < s && p[x][y] == 1) ans[1] = s;\n      }\n    }\n    if (ans[0] == 0) ans[1] = 0;\n    printf(\"%d %d\\n\", ans[0], ans[1]);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> P;\n#define F first\n#define S second\nint fie[1111][1111];\nint N,M;\nint sosu[1000001];\nP mie[1000001];\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\n\nP dp[1111][1111];\nint ndx[]={1,0,-1};\nP solve(int x,int y,int ss){\n  if(dp[x][y].F!=-1) return dp[x][y];\n  if(fie[x][y]>N ||  fie[x][y] == -1 ){\n    return P(0,ss);\n  }\n  P ret = P(0,0);\n  for(int i=0;i<3;i++){\n    int nx = x+ndx[i];\n    int ny = y+1;\n    if(fie[nx][ny]>N || fie[nx][ny] == -1 ){\n      P state = solve(nx,ny,ss);\n      ret = max(ret,state);\n    } else if(!sosu[fie[nx][ny]]){\n      P state = solve(nx,ny,fie[nx][ny]);\n      state.F ++;\n      ret = max(ret,state);\n    } else {\n      P state = solve(nx,ny,ss);\n      ret = max(ret,state);\n    }\n  }\n  // printf(\"%d dp[%d][%d] =  %d, %d fie=%d\\n\",ss,x,y,ret.F,ret.S,fie[x][y]);\n  return dp[x][y] = ret;\n}\n\nint main(){\n  sosu[1]=1;\n  for(int i=2;i<=1000000;i++){\n    if(!sosu[i]){\n      for(int j=i+i;j<=1000000;j+=i){\n\tsosu[j]=1;\n      }\n    }\n  }\n  for(int i=0;i<1111;i++)\n    for(int j=0;j<1111;j++)\n      dp[i][j]=P(-1,-1);\n  memset(fie,-1,sizeof(fie));\n\n\n  int x = 1111/2,y = 1111/2;\n  int id = 1, ic = 0;\n  //printf(\"%d %d\\n\",x,y);\n  fie[x][y]=1;\n  x += dx[ic]; y += dy[ic];\n\n \n  while( id < 1000000 ){\n    id++;\n    fie[x][y]=id;\n    mie[id] = P(x,y);\n    int nc = (ic+1)%4;\n    int nx = x+dx[nc], ny = y+dy[nc];\n    if( fie[nx][ny] == -1 ){\n      x = nx; y=ny;\n      ic=nc;\n    } else {\n      x = x + dx[ic]; y = y + dy[ic];\n    }\n  }\n\n\n  /*  for(int i=550;i<560;i++){\n    for(int j=550;j<560;j++){\n      printf(\"%3d \",fie[j][i]);\n    }\n    puts(\"\");\n  }\n  */\n\n  while(1){\n    for(int i=0;i<1111;i++)\n      for(int j=0;j<1111;j++)\n\tdp[i][j]=P(-1,-1);\n    \n    cin >> N >> M;\n    if(!N && !M) break;\n    //    printf(\"%d %d\\n\",mie[N].F,mie[N].S);\n    P res = solve(mie[M].F,mie[M].S,-1);\n    /*    if(sosu[fie[mie[M]][Mie[M]]]){\n      res.F ++;\n      }*/\n    if(res.S == -1){\n      printf(\"%d %d\\n\",0,0);\n    } else {\n      if( !sosu[fie[mie[M].F][mie[M].S]] ){\n\tif( res.F==0 ){\n\t  printf(\"%d %d\\n\",1,fie[mie[M].F][mie[M].S]);\n\t} else \n\t  printf(\"%d %d\\n\",res.F+1,res.S);\n      }\n      else\n\tprintf(\"%d %d\\n\",res.F,res.S);\n    }\n  }\n  \n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<int(b); i++)\n#define rep(i,n) loop(i,0,n)\n#define all(c) (c).begin(), (c).end()\ntypedef complex<int> P;\n\nconst int MAX_M = 1.5e6+10;\nconst int SIZE = 1500;\nint ps[MAX_M/2];\nbool isp[MAX_M];\nint grid[SIZE][SIZE]={};\nP itop[MAX_M];\npair<int,int> dp[SIZE][SIZE];\n\nint cnt_p = 0;\n\nvoid make_es(){\n    fill(isp,isp+MAX_M,true);\n    isp[0]=isp[1]=false;\n    rep(i,MAX_M){\n        if(!isp[i]) continue;\n        ps[cnt_p++] = i;\n        for(int j=i<<1; j<MAX_M; j+=i){\n            isp[j] = false;\n        }\n    }\n}\n\nint n,m;\n\npair<int,int> rec(int y, int x){\n    if(dp[y][x].first!=-1) return dp[y][x];\n\n    pair<int,int> best(0,0);\n    loop(i,-1,2){\n        if(grid[y+1][x+i]<=m){\n            auto t = rec(y+1,x+i);\n            best = max(t,best);\n        }\n    }\n\n    pair<int,int> res(0,0);\n    if(isp[grid[y][x]]){\n        res.first = 1;\n        res.second = grid[y][x];\n    }\n    if(best.first != 0){\n        res.first += best.first;\n        res.second = best.second;\n    }\n\n    return dp[y][x] = res;\n}\n\nint main(){\n    make_es();\n    P p(SIZE/2,SIZE/2);\n    P dir(0,1);\n    for(int i=1; i<MAX_M; i++){\n        grid[p.real()][p.imag()] = i;\n        itop[i]=p;\n        p+=dir;\n        P q = p+dir*P(0,1);\n        if(grid[q.real()][q.imag()] == 0){\n            dir*=P(0,1);\n        }\n    }\n\n    while(cin>>m>>n, n+m){\n        auto t = make_pair(-1,-1);\n        rep(i,SIZE)rep(j,SIZE) dp[i][j] = t;\n        auto u = itop[n];\n        auto ans = rec(u.real(), u.imag());\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\ntypedef long long LL;\n#define LEFT 0\n#define RIGHT 1\n#define UP 2\n#define DOWN 3\ntypedef pair<int,int> P;\n\n\n\nP move(P p,int A){\n  switch(A){\n     case LEFT:\n        p.second--;\n        break;\n     case RIGHT:\n        p.second++;\n        break;\n     case UP:\n        p.first--;\n        break;\n     case DOWN:\n        p.first++;\n        break;\n  }\n  return p;\n}\n\nint p[1011][1011];\nvoid setnum(P pa,int *num,int m){\n     if(*num<=m){\n        //cout<<pa.first<<\" \"<<pa.second<<endl;;\n        p[pa.first][pa.second]=*num;\n        *num=(*num)+1;\n        //cout<<\"num=\"<<*num<<endl;\n     }\n}\n\nvoid makerabit(int m){\n     REP(i,1011){\n         REP(j,1011){\n             p[i][j]=0;\n         }\n     }\n     P pa=P{501,501};\n     p[pa.first][pa.second]=1;\n     int move_num=2;\n     int count=2;\n     while(count<=m){\n     //cout<<\"test\"<<m<<\" \"<<count<<endl;\n        pa=move(pa,RIGHT);\n        setnum(pa,&count,m);\n        REP(i,move_num-1){\n            pa=move(pa,UP);\n            setnum(pa,&count,m);\n        }\n        REP(i,move_num){\n            pa=move(pa,LEFT);\n            setnum(pa,&count,m);\n        }\n        REP(i,move_num){\n           pa=move(pa,DOWN);\n           setnum(pa,&count,m);\n        }\n        REP(i,move_num){\n           pa=move(pa,RIGHT);\n           setnum(pa,&count,m);\n        }\n        move_num+=2;\n     }\n    /* for(int i=490;i<510;i++){\n         for(int j=490;j<510;j++){\n             cout<<setw(2)<<setfill('0')<<p[i][j]<<\" \";\n         }\n         cout<<endl;\n     }*/\n     \n}\n\n//??¨????????????????????????\nbool prime[1000001];\nvoid era(){\n   REP(i,1000001){\n       prime[i]=true;\n   }\n   prime[0]=false;\n   prime[1]=false;\n   for(int i=2;i<1000001;i++){\n       if(prime[i]==false)continue;\n       for(int j=2;i*j<1000001;j++){\n           prime[i*j]=false;\n       }\n   }\n}\nint dp[1011][1011];\nbool visit[1011][1011];\nint last[1011][1011];\n\nint main(){\n        int m,n;\n        era();\n        while(1){\n                   //cout<<\"ok\"<<endl;\n           cin>>m>>n;\n           if(m==0&&n==0)break;\n           makerabit(m);\n           P pa;\n           \n           for(int i=0;i<1011;i++){\n               REP(j,1011){\n                   dp[i][j]=0;\n                   if(p[i][j]==n){\n                      pa.first=i;\n                      pa.second=j;\n                      if(prime[n]){\n                         dp[i][j]++;\n                         last[i][j]=p[i][j];\n                      }\n                   }\n                   visit[i][j]=false;\n               }\n           }\n           vector<P>v;\n           v.push_back(pa);\n           for(int i=0;i<v.size();i++){\n               int fa=v[i].first;\n               int se=v[i].second;\n               if(p[fa][se]==0)continue;\n               /*if(p[fa][se]!=0){\n                   cout<<p[fa][se]<<\"aa\"<<dp[fa][se]<<endl;\n               }*/\n               for(int j=-1;j<=1;j++){\n                   int nfa=fa+1;\n                   int nse=se+j;\n                   //cout<<\"nfa\"<<p[nfa][nse]<<endl;\n                   if(nfa>=0&&nfa<1011&&nse>=0&&nse<1011){\n                      int a=0;\n                      if(prime[p[nfa][nse]])a=1;\n                      int now=dp[nfa][nse];\n                      int prev=dp[fa][se];\n                      if(now<prev+a){\n                         dp[nfa][nse]=max(dp[nfa][nse],dp[fa][se]+a);\n                         last[nfa][nse]=last[fa][se];\n                      }\n                      if(now==prev){\n                         last[nfa][nse]=max(last[nfa][nse],last[fa][se]);\n                      }\n                      if(prime[p[nfa][nse]])last[nfa][nse]=p[nfa][nse];\n                      if(visit[nfa][nse]==false){\n                         v.push_back(P(nfa,nse));\n                         visit[nfa][nse]=true;\n                      }\n                   }\n               }\n           }\n           int ans=0;\n           int cave=-1;\n           REP(i,1011){\n              REP(j,1011){\n                  if(ans<dp[i][j]){\n                     ans=dp[i][j];\n                     cave=p[i][j];\n                  }else if(ans==dp[i][j]&&cave<last[i][j]){\n                     cave=last[i][j];\n                  }\n                  //cout<<dp[i][j]<<\" \";\n              }\n              //cout<<endl;\n           }\n           if(ans==0)cave=0;\n           cout<<ans<<\" \"<<cave<<endl;\n        }\n        \n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#define MAX 1002001\n#define EDGE 1001\nusing namespace std;\n\nint h[EDGE + 2][EDGE + 2], p[MAX], visit[EDGE + 2][EDGE + 2], lastcave[EDGE + 2][EDGE + 2];\n\nint max(int a, int b, int c){\n\treturn max(max(a, b), max(b, c));\n}\n\n\n\nint main()\n{\n\t//洞窟の作成\n\tint nowx, nowy, d, size, sizecounter;\n\tnowx = (EDGE - 1) / 2;\n\tnowy = (EDGE + 1) / 2;\n\td = 0;\n\tsize = 1;\n\tsizecounter = 0;\n\tfor (int i = 0; i <= MAX; i++){\n\t\th[nowy][nowx] = i;\n\t\tif (d == 0){\n\t\t\tnowx++;\n\t\t}\n\t\telse if (d == 1){\n\t\t\tnowy--;\n\t\t}\n\t\telse if (d == 2){\n\t\t\tnowx--;\n\t\t}\n\t\telse if (d == 3){\n\t\t\tnowy++;\n\t\t}\n\t\tif (sizecounter == size){\n\t\t\tsizecounter = 0;\n\t\t\td = (d + 1) % 4;\n\t\t\tif (d == 0 || d == 2){\n\t\t\t\tsize++;\n\t\t\t}\n\t\t}\n\t\tsizecounter++;\n\t}\n\n\t//素数の判定用配列を作成\n\tp[1] = 0;\n\tfill(p, p + MAX, 1);\n\tfor (int i = 2; i <= MAX; i++){\n\t\tint sqrti = (int)sqrt(i);\n\t\tfor (int j = 2; j <= sqrti; j++){\n\t\t\tif (i % j == 0){\n\t\t\t\tp[i] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t//入力\n\tint m, n;\n\twhile (cin >> m >> n, m || n){\n\n\t\t//初期化\n\t\tint goalcave = 0;\n\t\tint cavecounter = 0;\n\t\tfor (int i = 0; i < EDGE + 2; i++){\n\t\t\tfor (int j = 0; j < EDGE + 2; j++){\n\t\t\t\tvisit[i][j] = 0;\n\t\t\t\tlastcave[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\t//脱出する直前の洞窟のyを求める．\n\t\tfor (int i = EDGE + 1; i > 0; i--){\n\t\t\tfor (int j = 0; j < EDGE + 2; j++){\n\t\t\t\tif (0 < h[i][j] && h[i][j] <= m){\n\t\t\t\t\tgoalcave = i;\n\t\t\t\t\tgoto jump;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tjump:\n\n\n\t\t//下から順に計算\n\t\tfor (int i = goalcave; i > 0; i--){\n\t\t\tfor (int j = 0; j < EDGE + 2; j++){\n\t\t\t\tif (h[i][j] <= m){\n\n\t\t\t\t\t//visitを求める\n\t\t\t\t\tif (p[h[i][j]]){\n\t\t\t\t\t\tvisit[i][j] = max(visit[i + 1][j - 1], visit[i + 1][j], visit[i + 1][j + 1]) + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tvisit[i][j] = max(visit[i + 1][j - 1], visit[i + 1][j], visit[i + 1][j + 1]);\n\t\t\t\t\t}\n\n\t\t\t\t\t//lastcaveを求める\n\t\t\t\t\tif (visit[i + 1][j - 1] > visit[i + 1][j] && visit[i + 1][j - 1] > visit[i + 1][j + 1]){\n\t\t\t\t\t\tlastcave[i][j] = lastcave[i + 1][j - 1];\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j] > visit[i + 1][j - 1] && visit[i + 1][j] > visit[i + 1][j + 1]){\n\t\t\t\t\t\tlastcave[i][j] = lastcave[i + 1][j];\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j + 1] > visit[i + 1][j - 1] && visit[i + 1][j + 1] > visit[i + 1][j]){\n\t\t\t\t\t\tlastcave[i][j] = lastcave[i + 1][j + 1];\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j - 1] == visit[i + 1][j] && visit[i + 1][j - 1] > visit[i + 1][j + 1]){\n\t\t\t\t\t\tlastcave[i][j] = max(lastcave[i + 1][j - 1], lastcave[i + 1][j]);\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j] == visit[i + 1][j + 1] && visit[i + 1][j] > visit[i + 1][j - 1]){\n\t\t\t\t\t\tlastcave[i][j] = max(lastcave[i + 1][j], lastcave[i + 1][j + 1]);\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j + 1] == visit[i + 1][j - 1] && visit[i + 1][j + 1] > visit[i + 1][j]){\n\t\t\t\t\t\tlastcave[i][j] = max(lastcave[i + 1][j + 1], lastcave[i + 1][j - 1]);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlastcave[i][j] = max(lastcave[i + 1][j + 1], lastcave[i + 1][j], lastcave[i + 1][j - 1]);\n\t\t\t\t\t}\n\t\t\t\t\tif (p[h[i][j]] && lastcave[i][j] == 0){\n\t\t\t\t\t\tlastcave[i][j] = h[i][j];\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t//出力\n\t\t\t\tif (h[i][j] == n){\n\t\t\t\t\tcout << visit[i][j] << \" \" << lastcave[i][j] << endl;\n\n\t\t\t\t/*\tfor (int i = 498; i < 505; i++){\n\t\t\t\t\t\tfor (int j = 498; j < 505; j++){\n\t\t\t\t\t\t\tcout << lastcave[i][j]<<\" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcout << endl;\n\t\t\t\t\t}\n\n\t\t\t\t\tcout << endl;\n\t\t\t\t\tfor (int i = 498; i < 505; i++){\n\t\t\t\t\t\tfor (int j = 498; j < 505; j++){\n\t\t\t\t\t\t\tcout << visit[i][j] << \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcout << endl;\n\t\t\t\t\t}\n*/\n\n\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <cstdio>\nusing namespace std;\n#define t_max 10000001\nint M[1001][1001];\nint S[1001][1001];\nint P[1001][1001];\nint table[t_max];\nvector<pair<int,int> >m(t_max);\nmap<pair<int,int>,int>m_rev;\npair<int,int> dfs(int x,int y){\n\tif(y==1001)return make_pair(0,0);\n\tif(S[x][y]>=0)return make_pair(S[x][y],P[x][y]);\n\tint m=0,m_place=0,i=-1;\n\tfor(;i<2;i++){\n\t\tif(x+i<0||1000<x+i)continue;\n\t\tpair<int,int> p=dfs(x+i,y+1);\n\t\tif(m<p.first||(m==p.first&&m_place<p.second))m=p.first,m_place=p.second;\n\t}\n\tif(m==0){\n\t\tif(M[x][y])return make_pair(S[x][y]=1,P[x][y]=m_rev[make_pair(x,y)]);\n\t\treturn make_pair(S[x][y]=0,P[x][y]=0);\n\t}else{\n\t\treturn make_pair(S[x][y]=m+M[x][y],P[x][y]=m_place);\n\t}\n}\nmain(){\n\tint k=1,z,x,y,i,n,s;\n\tm[k]=make_pair(x=500,y=500),m_rev[make_pair(x,y)]=k,k++;\n\tfor(z=2;z<=1000;z+=2){\n\t\tx++,y++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(x,--y),m_rev[make_pair(x,y)]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(--x,y),m_rev[make_pair(x,y)]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(x,++y),m_rev[make_pair(x,y)]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(++x,y),m_rev[make_pair(x,y)]=k,k++;\n\t}\n\ttable[0]=table[1]=1;\n\tfor(x=2;x<t_max;x++)if(!table[x])for(y=x*2;y<t_max;y+=x)table[y]=1;\n\tfor(;scanf(\"%d%d\",&n,&s),n;){\n\t\tmemset(M,0,sizeof(M));\n\t\tmemset(S,0xff,sizeof(S));\n\t\tmemset(P,0,sizeof(P));\n\t\tfor(i=1;i<=n;i++)if(!table[i])M[m[i].first][m[i].second]=1;\n\t\tpair<int,int> p=dfs(m[s].first,m[s].second);\n\t\tprintf(\"%d %d\\n\",p.first,p.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n  \n#define MP make_pair\n#define PB push_back\n#define MAX_N 1100000\n#define SIZE 1200\n#define X first\n#define Y second\n  \nconst int STX = 600, STY = 600;\n\ntypedef pair<int, int> Pii;\ntypedef pair<int, Pii> P;\n  \nint id[SIZE][SIZE];\nbool is_prime[MAX_N+1];\nPii coord[MAX_N];\n\nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++)\n    if(is_prime[i])\n      for(int j=i*i; j<=MAX_N; j+=i)\n\tis_prime[j] = false;\n}\n\nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  int sz = 0;\n  \n  coord[sz++] = Pii(0, 0); // no use\n  cnt ++;\n  coord[sz++] = Pii(x, y); // cnt = 1\n  \n  fill(id[0], id[0]+SIZE*SIZE+1, -1);\n  \n  const int dx[] = {0,-1,0,1};\n  const int dy[] = {-1,0,1,0};\n  \n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt <= MAX_N) {\n    a += 2;\n    for(int turn=0; turn<4; turn++) {\n      for(int i=0; i<a; i++) {\n\tx += dx[turn], y += dy[turn];\n\tcoord[sz++] = Pii(x, y);\n\tid[y][x] = ++ cnt;\n      }\n    }\n    x++, y++;\n  }\n}\n\nint dp[MAX_N+1];\n\nint main() {\n  \n  Sieve();\n  MakeMap();\n  \n  int m, n;\n\n  while(cin >> m >> n && (m|n)) {\n    \n    fill(dp, dp+MAX_N+1, -1);\n    dp[n] = is_prime[n];\n    Pii ans(dp[n], n);\n    \n    queue<P> que;\n    que.push(P(dp[n], coord[n]));\n    while(!que.empty()) {\n      P now = que.front(); que.pop();\n      int tmpid = id[now.second.Y][now.second.X];\n      if(now.first < dp[tmpid]) continue;\n      \n      int noid = id[now.second.Y][now.second.X];\n      \n      for(int i=-1; i<=1; i++) {\n\tPii nex = MP(now.second.X+i, now.second.Y+1);\n\tif(nex.X < 0 || SIZE <= nex.X || nex.Y < 0 || SIZE <= nex.Y) continue;\n\tint neid = id[nex.Y][nex.X];\n\tif(neid <= m) {\n\t  if(dp[neid] < dp[noid] + is_prime[neid]) {\n\t    dp[neid] = dp[noid] + is_prime[neid];\n\t    if(is_prime[neid]) ans = max(ans, MP(dp[neid], neid));\n\t    que.push(P(dp[neid], nex));\n\t  }\n\t}\n      }\n\n    }\n    \n    if(ans.first == 0) cout << \"0 0\" << endl;\n    else cout << ans.first << ' ' << ans.second << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (y>=0&&x>=0&&table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t\n\t\tfor (int h = 0;h < SIZE;h++) {\n\t\t\tfor (int w = 0;w < SIZE;w++) {\n\t\t\t\tif (table[h][w] == n) {\n\t\t\t\t\tcout << dp[h][w] << \" \" << pr[h][w] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<cstdlib>\n#include<queue>\n#include<set>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<sstream>\n#include<stack>\n#include<map>\n#include<cstdio>\nusing namespace std;\n#define rep(i,a) for(int i=0;i<a;i++)\n#define mp make_pair\n#define pb push_back\n#define P pair<int,int>\n#define ll __int64\nconst int L=-100000;\nconst int R=-999999;\nconst int MA=1100000;\nbool t[MA];\nint table[1100][1100];\nbool used[1100][1100];\nP ans[1100][1100];\n\nconst int INF=-1;\nint n,start;\nint ny,nx;\n\nvoid eratosu(){\n\n\tt[0]=1;\n\tt[1]=1;\n\n\tfor(int i=2;i<=MA;i++){\n\t\tif(t[i]==0){\n\t\t\tfor(int j=i*2;j<=MA;j+=i)t[j]=1;\n\t\t}\n\t}\n}\nvoid make_table(int y,int x){\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint mo=0,ho=0,cnt=0,turn=0,turnnum=1;\n\nfor(int i=1;i<=n;i++){\n\t//cout<<y<<\" \"<<x<<endl;\n\tif(cnt==ho){\n\t\tturnnum++;\n\t\tho=(turnnum)/2;\t\n\t\tcnt=0;\n\t\tturn++;\n\t\tif(turn==4)turn=0;\n\t}\n\t//cout<<x-500<<\" \"<<y-500<<\" \"<<i<<endl;\n\ttable[y][x]=i;\n\tif(i==start)ny=y,nx=x;\n\tx+=dx[turn];\n\ty+=dy[turn];\n\tcnt++;\n}\n\n}\n\nint main(){\neratosu();\n\nwhile(cin>>n>>start,n||start){\nrep(i,1100)rep(j,1100)table[i][j]=ans[i][j].first=ans[i][j].second=INF;\nrep(i,1100)rep(j,1100)used[i][j]=0;\nint sy=500,sx=500;//ハジメの座標\nmake_table(sy,sx);\n\n\nqueue<P>bfs;\nbfs.push(mp(ny,nx));\nif(!t[table[ny][nx]]){\nans[ny][nx].first=1;\nans[ny][nx].second=table[ny][nx];\n}\nelse ans[ny][nx].first=0;\nint cnt=0;\nwhile(!bfs.empty()){\n\n\tint y,x;\n\tP now;\n\tnow=bfs.front();\n\tbfs.pop();\n\ty=now.first,x=now.second;\n\tif(used[y][x])continue;\n\tused[y][x]=1;\n\t//if(ans[y][x].first!=INF)continue;\n\tint ty=y+1,tx=x;\n//cout<<y<<\" \"<<x<<endl;\n\tfor(int i=-1;i<=1;i++){\n\t\ttx=x+i;\n\t\tint is=0;\n\n\t\tif(table[ty][tx]!=INF){\n\t\t\tif(!t[table[ty][tx]]){\n\t\t\t\tis=1;\n\t\t\t\t//ans[ty][tx].second=max(ans[y][x].second,table[ty][tx]);\n\t\t\t\t}\n\t\t\telse{\n\t\t\t\t//ans[ty][tx].seocnd=max(ans[y][x].secon\n\t\t\t\tis=0;\n\t\t\t}\n\t\t\tif(ans[ty][tx].first<ans[y][x].first+is){\n\t\t\t\tans[ty][tx].first=ans[y][x].first+is;\n\t\t\t\tif(is)ans[ty][tx].second=table[ty][tx];\n\t\t\t}\n\t\t\telse if(ans[ty][tx].first==ans[y][x].first+is){\n\t\t\t\tans[ty][tx].second=max(ans[ty][tx].second,ans[y][x].second);\n\t\t\t}\n\t\t\n\t\t\t////ans[ty][tx].first=max(ans[ty][tx].first,ans[y][x].first+is);\n\t\t\t//else ans[ty][tx]=max(ans[ty][tx],ans[y][x]);\n\t\t\tbfs.push(mp(ty,tx));\n\t\t}\n\t}\n}\n\nint ansa=0,ansb=0;\nrep(i,1100){\n\tbool f=1;\n\trep(j,1100){\n\t\t//if(ans[i][j].second!=INF){cout<<ans[i][j].second<<\" \";f=0;}\n\t\t//if(ansa==ans[i][j]&&ansb<table[i][j])ansb=table[i][j];\n\t\t//if(ansa<ans[i][j])ansa=ans[i][j],ansb=table[i][j];\n\t\tif(ansa<ans[i][j].first)ansa=ans[i][j].first,ansb=ans[i][j].second;\n\t\tif(ansa==ans[i][j].first&&ans[i][j].second>ansb)ansb=ans[i][j].second;\n\t\n\t}\t\n\tif(!f)cout<<endl;\n}\ncout<<ansa<<\" \"<<ansb<<endl;\n}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <string>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <cstdio>\n#include <cassert>\n#include <cinttypes>\n\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef int64_t i64;\ntypedef uint64_t u64;\n\nconst i64 INF = 1e18 + 10;\n\ntypedef pair<int, int> P;\ninline P operator+(const P& p1, const P& p2) {\n  return P(p1.first + p2.first, p1.second + p2.second);\n}\n\nint cave[1101][1101];\n\nvoid MakeCave(int n) {\n  memset(cave, 0, sizeof(cave));\n\n  int y = 501;\n  int x = 501;\n\n  int dy[4] = { 1, 0, -1, 0 };\n  int dx[4] = { 0, 1, 0, -1 };\n\n  int dir = 0;\n  for (int i = 1; i <= n; i++) {\n    cave[y][x] = i;\n\n    int ny = y + dy[(dir + 1) % 4];\n    int nx = x + dx[(dir + 1) % 4];\n    if (ny < 0 || ny >= 1100 || nx < 0 || nx >= 1100 || cave[ny][nx] == 0) {\n      y = ny;\n      x = nx;\n      dir = (dir + 1) % 4;\n    } else {\n      y = y + dy[dir];\n      x = x + dx[dir];\n    }\n  }\n}\n\nbool IsPrime(int num) {\n  static bool is_prime[1000001];\n\n  static bool init = false;\n\n  if (!init) {\n    fill(is_prime, is_prime + 1000001, true);\n    init = true;\n    is_prime[0] = false;\n    is_prime[1] = false;\n    for (int i = 2; i * i < 1000001; i++) {\n      if (is_prime[i]) {\n        for (int j = 2; i * j < 1000001; j++) {\n          is_prime[i * j] = false;\n        }\n      }\n    }\n  }\n\n  return is_prime[num];\n}\n\nP Solve(int n, int m) {\n  int start_y = -1;\n  int start_x = -1;\n\n  for (int i = 0; start_x == -1 && i < 1101; i++) {\n    for (int j = 0; start_x == -1 && j < 1101; j++) {\n      if (cave[i][j] == m) {\n        start_y = i;\n        start_x = j;\n      }\n    }\n  }\n\n  struct Search {\n    int y, x;\n    int prime;\n    int count;\n    Search(): y(-1), x(-1), prime(0), count(0) { }\n    Search(int y, int x, int prime, int count):\n      y(y), x(x), prime(prime), count(count) { }\n  };\n\n  int dy[3] = {  1, 1, 1 };\n  int dx[3] = { -1, 0, 1 };\n\n  static bool checked[1101][1101];\n  static Search memo[1101][1101];\n  memset(checked, false, sizeof(checked));\n\n  function<Search(int, int)> dfs = [&](int y, int x) {\n    if (checked[y][x]) {\n      return memo[y][x];\n    }\n\n    if (cave[y][x] == 0) {\n      return Search(y, x, 0, 0);\n    }\n\n    Search s(y, x, 0, 0);\n    if (IsPrime(cave[y][x])) {\n      s.count++;\n      s.prime = cave[y][x];\n    }\n\n    int count = 0;\n    int prime = s.prime;\n    for (int i = 0; i < 3; i++) {\n      int ny = y + dy[i];\n      int nx = x + dx[i];\n\n      Search t = dfs(ny, nx);\n      if (t.count > count) {\n        count = t.count;\n        prime = t.prime;\n      }\n    }\n\n    s.count += count;\n    s.prime = prime;\n\n    checked[y][x] = true;\n    memo[y][x] = s;\n\n    return s;\n  };\n\n  Search ans = dfs(start_y, start_x);\n\n  return P(ans.count, ans.prime);\n}\n\nint main() {\n  while (true) {\n    int n, m;\n    cin >> n >> m;\n    if (n + m == 0) {\n      break;\n    }\n    MakeCave(n);\n    P ans = Solve(n, m);\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t\n\t\toutput = false;\n\t\tfor (int i = 0;i < SIZE && (!output);i++) {\n\t\t\tfor (int j = 0;j < SIZE && (!output);j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\t//printf(\"%d %d\\n\", dp[i][j], pr[i][j]);\n\t\t\t\t\t//cout << dp[i][j] << \" \" << pr[i][j] << endl;\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nmap<P, int> num;\nP pos[1000001];\nmap<P, int> sum;\nset<P> vis;\nint dx[] = { 1,0,-1,0 };\nint dy[] = { 0,-1,0,1 };\nbool is_prime[1000001];\nint main() {\n\tmemset(is_prime, -1, sizeof(is_prime));\n\tis_prime[1] = 0;\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tif (!is_prime[i]) continue;\n\t\tfor (int j = i * 2; j <= 1000000; j += i) is_prime[j] = 0;\n\t}\n\tint x = 0, y = 0;\n\tint dir = 0;\n\tint len = 1;\n\tint cnt = 0;\n\tnum[P(0, 0)] = 1;\n\tpos[1] = P(0, 0);\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tx += dx[dir];\n\t\ty += dy[dir];\n\t\tnum[P(x, y)] = i;\n\t\tpos[i] = P(x, y);\n\t\tcnt++;\n\t\tif (cnt == len) {\n\t\t\tcnt = 0;\n\t\t\tif (dir % 2) len++;\n\t\t\t(dir += 1) %= 4;\n\t\t}\n\t}\n\tint m, n;\n\twhile (cin >> m >> n, m) {\n\t\tsum.clear();\n\t\tvis.clear();\n\t\tint sx, sy;\n\t\tsx = pos[n].first;\n\t\tsy = pos[n].second;\n\t\tint ans = -1;\n\t\tint t = -1;\n\t\tqueue<P> Q;\n\t\tQ.push(P(sx, sy));\n\t\tvis.insert(P(sx, sy));\n\t\twhile (!Q.empty()) {\n\t\t\tP now = Q.front(); Q.pop();\n\t\t\tif (is_prime[num[now]]) {\n\t\t\t\tsum[now]++;\n\t\t\t\tif (ans < sum[now]) {\n\t\t\t\t\tans = sum[now];\n\t\t\t\t\tt = num[now];\n\t\t\t\t}\n\t\t\t\telse if (ans == sum[now]) {\n\t\t\t\t\tt = max(t, num[now]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\t\tint x = now.first + i;\n\t\t\t\tint y = now.second + 1;\n\t\t\t\tif (num.find(P(x, y)) == num.end()) continue;\n\t\t\t\tsum[P(x, y)] = max(sum[P(x, y)], sum[now]);\n\t\t\t\tif (vis.find(P(x, y)) != vis.end()) continue;\n\t\t\t\tvis.insert(P(x, y));\n\t\t\t\tQ.push(P(x, y));\n\t\t\t}\n\t\t}\n\t\tif (ans == -1) cout << \"0 0\" << endl;\n\t\telse cout << ans << \" \" << t << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n \nusing namespace std;\n \n#define MP make_pair\n#define PB push_back\n#define MAX_N 1001000\n#define SIZE 2010\n#define X first\n#define Y second\n \nconst int STX = 510, STY = 510;\n \nint id[SIZE][SIZE];\nbool is_prime[MAX_N+1];\nvector<pair<int, int> > coord;\n \nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++) {\n    if(is_prime[i]) {\n      for(int j=i*i; j<=MAX_N; j+=i) {\n    is_prime[j] = false;\n      }\n    }\n  }\n}\n \nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  /*\n  const int dx[] = {1,0,-1,0};\n  const int dy[] = {0,-1,0,1};\n  */\n  coord.PB(MP(0, 0)); // no use\n  coord.PB(MP(x, y)); // cnt = 1\n  cnt ++;\n \n  fill(id[0], id[0]+SIZE*SIZE+1, -1);\n   \n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt <= MAX_N) {\n    a += 2;\n    for(int i=0; i<a; i++) {\n      y --;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      x --;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      y ++;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      x ++;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    x++, y++;\n  }\n}\n \nint dp[MAX_N+1];\n \nint main() {\n   \n  Sieve();\n  MakeMap();\n   \n  int m, n;\n   \n  while(cin >> m >> n && (m|n)) {\n    fill(dp, dp+MAX_N+1, -1);\n    dp[n] = is_prime[n];\n     \n    queue<pair<int, int> > que;\n    que.push(coord[n]);\n     \n    while(!que.empty()) {\n      pair<int, int> now = que.front(); que.pop();\n      int noid = id[now.Y][now.X];\n       \n      for(int i=-1; i<=1; i++) {\n    pair<int, int> nex = MP(now.X+i, now.Y+1);\n    if(nex.X < 0 || SIZE <= nex.X || nex.Y < 0 || SIZE <= nex.Y) continue;\n    int neid = id[nex.Y][nex.X];\n    if(neid <= m) {\n      if(dp[neid] < dp[noid] + is_prime[neid]) {\n        dp[neid] = dp[noid] + is_prime[neid];\n        que.push(nex);\n      }\n    }\n      }\n    }\n     \n    int res = dp[n], lastid = -1;\n    if(is_prime[n]) lastid = n;\n     \n    for(int i=1; i<=m; i++) {\n      if(res <= dp[i] && is_prime[i]) {\n    res = dp[i];\n    lastid = max(lastid, i);\n      }\n    }\n     \n    if(lastid == -1) cout << \"0 0\" << endl;\n    else cout << res << \" \" << lastid << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n//#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n//#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#include <array>\n//#include <atomic>\n#include <chrono>\n//#include <condition_variable>\n#include <forward_list>\n//#include <future>\n#include <initializer_list>\n//#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n//#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\n\nint main ()\n{\n\tint M , N;\n\tint ii[1000];\n\tfor( size_t i = 0; i < 1000; i++ )\n\t{\n\t\tii[i] = i*i;\n\t}\n\n\tint dx[] = { 1 , 0 , -1 , 0 };\n\tint dy[] = { 0 , -1 , 0 , 1 };\n\tvector<vector<int>>data ( 1e4 + 3 , vector<int> ( 1e4 + 5 ) );\n\t{\n\t\tint nowx = ( 1e3 / 2 ) + 1 , nowy = ( 1e3 / 2 ) + 1;\n\t\tint nowz = 3;\n\t\tfor( size_t i = 1; i < 1e6 + 10; i++ )\n\t\t{\n\t\t\tif( data[nowx + dx[( nowz + 1 ) % 4]][nowy + dy[( nowz + 1 ) % 4]] == 0 )\n\t\t\t{\n\t\t\t\tnowz = ( nowz + 1 ) % 4;\n\t\t\t}\n\t\t\tdata[nowx + dx[nowz]][nowy + dy[nowz]] = i;\n\n\t\t\tnowx = nowx + dx[nowz];\n\t\t\tnowy = nowy + dy[nowz];\n\t\t}\n\t}\n\tbool pri[(int) ( 1e6 + 2 )];\n\tpri[0] = 1;\n\tpri[1] = 1;\n\tfor( size_t i = 2; i < 1e6 + 2; i++ )\n\t{\n\t\tif( pri[i] == 0 )\n\t\t{\n\t\t\tfor( size_t j = 2; j*i < 1e6 + 2; j++ )\n\t\t\t{\n\t\t\t\tpri[i*j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\twhile( cin >> M >> N , M || N )\n\t{\n\t\tpair<int , int>S;\n\t\tint ans1 = 0 , ans2 = 0;;\n\t\t//vector<vector<int>>data2 ( 1e3 + 5 , vector<int> ( 1e3 + 5 , 0 ) );\n\t\tmap < int , map < int , int >>data2;\n\t\tfor( size_t i = 0; i < 1e3 + 5; i++ )\n\t\t{\n\t\t\tfor( size_t j = 0; j < 1e3 + 5; j++ )\n\t\t\t{\n\t\t\t\tif( data[i][j] == N )\n\t\t\t\t{\n\t\t\t\t\tS.first = i;\n\t\t\t\t\tS.second = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( S.first )\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tqueue<pair<int , int>>que;\n\t\tque.push ( S );\n\t\tif( !pri[data[S.first][S.second]] )\n\t\t{\n\t\t\tans1 = data[S.first][S.second];\n\t\t\tans2 = 1;\n\t\t\tdata2[S.first][S.second] = 1;\n\t\t}\n\t\twhile( que.size () )\n\t\t{\n\t\t\tpair<int , int>now = que.front (); que.pop ();\n\t\t\tint nowx = now.first;\n\t\t\tint nowy = now.second;\n\t\t\t//cout << data[nowx][nowy] << endl;\n\t\t\tfor( int i = 1; i >= -1; i-- )\n\t\t\t{\n\t\t\t\tif( data[nowx + 1][nowy + i] <= M )\n\t\t\t\t{\n\t\t\t\t\tif( !data2[nowx + 1][nowy + i] )que.push ( pair<int , int> ( nowx + 1 , nowy + i ) );\n\t\t\t\t\tif( !pri[data[nowx + 1][nowy + i]] )\n\t\t\t\t\t{\n\t\t\t\t\t\tif( data2[nowx + 1][nowy + i] < data2[nowx][nowy] + 1 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdata2[nowx + 1][nowy + i] = data2[nowx][nowy] + 1;\n\t\t\t\t\t\t\tif( ans2 <= data2[nowx + 1][nowy + i] )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif( ans2 == data2[nowx + 1][nowy + i] )\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tans1 = max(data[nowx + 1][nowy + i],ans1);\n\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tans1 = data[nowx + 1][nowy + i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tans2 = data2[nowx + 1][nowy + i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tif( data2[nowx + 1][nowy + i] < data2[nowx][nowy] )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdata2[nowx + 1][nowy + i] = data2[nowx][nowy];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans2 << \" \" << ans1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//マップをつくる\n//ふるって素数マップ作る\n//dp[深さ][左端からの距離]で素数洞窟に入った回数をDP、素数かどうかはO(1)で判定\n//ある意味良問。誤読とか範囲指定ミスとか嘘解法とか、出しまくった。\n#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\n\nclass Solver{\npublic:\n\tint isprime[1100000];\t//素数なら1、そうでないなら0を入れる\n\tint data[2001][2001];\t//マップデータ。\n\tint dp[1201][1201];\n\tint dp2[1201][1201];\n\t\n\tvoid SetPrime( int m ){\n\t\tint i,j;\n\t\tfor( i = 0; i <= m; i++ ) isprime[i] = 1;\n\t\tisprime[0] = 0; isprime[1] = 0;\n\t\tfor( i = 2; i <= m; i++ ){\n\t\t\tif( isprime[i] ) {\n\t\t\t\t//cout << i << endl;\n\t\t\t\tfor( j = i*2; j <= m; j += i )\n\t\t\t\t\tisprime[j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid uzumaki( int m ){\n\t\tint i,j;\n\t\tint ci=600,cj=600;\n\t\tint cnt=1;\n\t\tfor( i = 1; cnt <= m; i++ ){\n\t\t\t//→\n\t\t\tfor( j = 0; j <= i; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[i+ci][j+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//↑\n\t\t\tfor( j = 1; j <= 2*i-1; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[i-j+ci][i+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//←\n\t\t\tfor( j = 1; j <= 2*i; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[-i+1+ci][i-j+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//↓\n\t\t\tfor( j = 1; j <= 2*i; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[-i+1+j+ci][-i+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//→\n\t\t\tfor( j = 1; j < i; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[i+1+ci][-i+j+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\t//デバッグ\n\t\t/*for( i = -17; i <= 17; i++ ){\n\t\t\tfor( j = -17; j <= 17; j++ ){\n\t\t\t\tif ( isprime[data[i+ci][j+cj]] )\n\t\t\t\t\tprintf(\"%4dp\",data[i+ci][j+cj]);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%5d\",data[i+ci][j+cj]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t}\n\t\n\tpair<int, int> search_ij(int m, int n) {\n\t\tint i,j;\n\t\tint ci=600,cj=600;\t//uzumakiと同じにしておくこと！\n\t\tint cnt=1;\n\t\tfor( i = 1; cnt <= m; i++ ){\n\t\t\tif ( data[i+1+ci][cj] < n ) {\n\t\t\t\tcnt = data[i+1+ci][cj];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//→\n\t\t\tfor( j = 0; j <= i; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(i+ci, j+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//↑\n\t\t\tfor( j = 1; j <= 2*i-1; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(i-j+ci, i+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//←\n\t\t\tfor( j = 1; j <= 2*i; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(-i+1+ci, i-j+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//↓\n\t\t\tfor( j = 1; j <= 2*i; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(-i+1+j+ci, -i+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//→\n\t\t\tfor( j = 1; j < i; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(i+1+ci, -i+j+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\treturn pair<int, int>(-1, -1);\n\t}\n\t\n\tvoid DP( int m, int n ){\n\t\tint i,j;\n\t\tpair<int, int> ij = search_ij(m, n);\n\t\ti = ij.first; if ( i == -1 ) return;\n\t\tfor( ; i < 1200; i++ ) {\n\t\t\tfor( j = 0; j < 1200; j++ ) {\n\t\t\t\tdp[i][j] = -114514;\n\t\t\t\tdp2[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\ti = ij.first;\n\t\tj = ij.second;\n\t\tdp[i][j] = 0;\n\t\t\n\t\tfor( ; i < 1200; i++ ){\n\t\t\tfor( j = 0; j < 1200; j++ ){\n\t\t\t\t//今いる場所がゴールなら何もしない\n\t\t\t\tif ( data[i][j] > m || dp[i][j] < 0 )\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\t//今いる場所が素数か\n\t\t\t\tint c = isprime[ data[i][j] ];\n\t\t\t\tdp[i+1][j-1] = max( dp[i][j]+c, dp[i+1][j-1] );\n\t\t\t\tdp[i+1][j] = max( dp[i][j]+c, dp[i+1][j] );\n\t\t\t\tdp[i+1][j+1] = max( dp[i][j]+c, dp[i+1][j+1] );\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor( i = ij.first; i < 1200; i++ ){\n\t\t\tfor( j = 0; j < 1200; j++ ) {\n\t\t\t\tans = max(ans, dp[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//経路復元とついでにans2の更新。\n\t\t//ちなみに、ゴールからたどっていけば、たどった場所すべてがスタートからありつけるようにできるので、\n\t\t//ans2を直接更新することができる。(経路の候補が消える！ということがない)→嘘解法らしい。\n\t\t//したがって、ans2はdp2を全部埋めてから求めることにしよう。\n\t\t//…最後に通過した素数洞穴の番号＞＜＞＜！(↑は嘘解法ではなかったようです。誤読！！最大値じゃない！！誤読！！)\n\t\t//誤飲も怖いけど誤読も恐ろforces…\n\t\tint ans2 = 0;\n\t\tif ( ans > 0 ) {\n\t\t\t//\n\t\t\tfor( i = 1199; i > ij.first; i-- ) {\n\t\t\t\tfor( j = 0; j < 1200; j++ ) {\n\t\t\t\t\tif ( (dp[i][j] != ans && dp2[i][j] == 0) || (dp2[i][j] == 252521) )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tif ( data[i-1][j-1] <= m && dp[i-1][j-1] + isprime[data[i-1][j-1]] == dp[i][j]) {\n\t\t\t\t\t\tdp2[i-1][j-1] = 1;\n\t\t\t\t\t\tif ( isprime[data[i-1][j-1]] ) {\n\t\t\t\t\t\t\tdp2[i-1][j-1] = 252521;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( data[i-1][j] <= m && dp[i-1][j] + isprime[data[i-1][j]] == dp[i][j] ) {\n\t\t\t\t\t\tdp2[i-1][j] = 1;\n\t\t\t\t\t\tif ( isprime[data[i-1][j]] )\n\t\t\t\t\t\t\tdp2[i-1][j] = 252521;\n\t\t\t\t\t}\n\t\t\t\t\tif ( data[i-1][j+1] <= m && dp[i-1][j+1] + isprime[data[i-1][j+1]] == dp[i][j] ) {\n\t\t\t\t\t\tdp2[i-1][j+1] = 1;\n\t\t\t\t\t\tif ( isprime[data[i-1][j+1]] )\n\t\t\t\t\t\t\tdp2[i-1][j+1] = 252521;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//\n\t\t\tfor( i = 1199; i >= ij.first; i-- ) {\n\t\t\t\tfor( j = 0; j < 1200; j++ ) {\n\t\t\t\t\tif ( dp2[i][j] == 252521 && isprime[data[i][j]] && data[i][j] <= m ) {\n\t\t\t\t\t\tans2 = max(ans2, data[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << \" \" << ans2 << endl;\n\t}\n};\n\nSolver test;\n\nint main(){\n\tint m,n;\n\t\n\ttest.SetPrime(1090000);\n\ttest.uzumaki(1090000);\n\twhile( cin >> m >> n ){\n\t\tif(!m)return 0;\n\t\ttest.DP(m, n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nusing namespace std;\n  \n#define MP make_pair\n#define PB push_back\n#define MAX_N 2001000\n#define SIZE 2000\n#define X first\n#define Y second\n  \nconst int STX = 1000, STY = 1000;\n  \nint id[SIZE][SIZE];\nbool is_prime[MAX_N+1];\nvector<pair<int, int> > coord;\n\nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++) {\n    if(is_prime[i]) {\n      for(int j=i*i; j<=MAX_N; j+=i) {\n\tis_prime[j] = false;\n      }\n    }\n  }\n}\n\nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  \n  coord.PB(MP(0, 0)); // no use\n  cnt ++;\n  coord.PB(MP(x, y)); // cnt = 1\n  \n  fill(id[0], id[0]+SIZE*SIZE+1, -1);\n  \n  const int dx[] = {0,-1,0,1};\n  const int dy[] = {-1,0,1,0};\n  \n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt <= MAX_N) {\n    a += 2;\n    for(int turn=0; turn<4; turn++) {\n      for(int i=0; i<a; i++) {\n\tx += dx[turn], y += dy[turn];\n\tcoord.PB(MP(x, y));\n\tid[y][x] = ++ cnt;\n      }\n    }\n    x++, y++;\n  }\n}\n\nint dp[MAX_N+1];\n\nint main() {\n  \n  Sieve();\n  MakeMap();\n  \n  int m, n;\n\n  while(cin >> m >> n && (m|n)) {\n    \n    //bool ok = false;\n    \n    fill(dp, dp+MAX_N+1, -1);\n    dp[n] = is_prime[n];\n    pair<int, int> ans(dp[n], n);\n    \n    queue<pair<int, int> > que;\n    que.push(coord[n]);\n    \n    while(!que.empty()) {\n      pair<int, int> now = que.front(); que.pop();\n      int noid = id[now.Y][now.X];\n      \n      for(int i=-1; i<=1; i++) {\n\tpair<int, int> nex = MP(now.X+i, now.Y+1);\n\tif(nex.X < 0 || SIZE <= nex.X || nex.Y < 0 || SIZE <= nex.Y) continue;\n\tint neid = id[nex.Y][nex.X];\n\tif(neid <= m) {\n\t  if(dp[neid] < dp[noid] + is_prime[neid]) {\n\t    dp[neid] = dp[noid] + is_prime[neid];\n\t    //if(is_prime[neid]) ok = true;\n\t    ans = max(ans, make_pair(dp[neid], neid));\n\t    que.push(nex);\n\t  }\n\t}\n      }\n\n    }\n    \n    /*\n      int res = dp[n], lastid = -1;\n    if(is_prime[n]) lastid = n;\n    \n    for(int i=1; i<=m; i++) {\n      if(res <= dp[i] && is_prime[i]) {\n\tres = dp[i];\n\tlastid = max(lastid, i);\n      }\n    }\n    */\n    if(ans.first == 0) cout << \"0 0\" << endl;\n    else cout << ans.first << \" \" << ans.second << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\nusing namespace std;\n#define N 1000\n#define N2 N*N\nbool prime[N2+1];\nint cave[N+2][N+2]={};\npair<int,int> locate[N2+1];\nint last[N+2][N+2];\nint dp[N+2][N+2];\nint m,n;\n\nbool wall(int x,int y){ return x==0 || y==0 || x==N+1 || y==N+1; }\n\nint rec(int x,int y){\n    if(wall(x,y) || cave[x][y]>m)return 0;\n    if(dp[x][y])return dp[x][y];\n    pair<int,int> child[3];\n    rep(i,3)child[i]=pair<int,int>(rec(x+i-1,y-1),last[x+i-1][y-1]);\n    sort(child,child+3);\n    dp[x][y]=child[2].first;\n    if(prime[cave[x][y]])dp[x][y]++;\n    last[x][y]=child[2].second;\n    if(last[x][y]==0 && prime[cave[x][y]]) last[x][y]=cave[x][y];\n    return dp[x][y];\n}\n\nint main(void){\n    fill(prime,prime+N2+1,true);\n    prime[0]=prime[1]=false;\n    for(int i=2;i<=N2;i++){\n        if(prime[i]) for(int k=2;i*k<=N2;k++) prime[i*k]=false;\n    }\n\n    int x=1,y=N,d=0;\n    int dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n    for(int i=N2;i>0;i--){\n        cave[x][y]=i;\n        locate[i] = pair<int,int>(x,y);\n        if(wall(x+dx[d],y+dy[d]) || cave[x+dx[d]][y+dy[d]]) d=(d+1)%4;\n        x+=dx[d];\n        y+=dy[d];\n    }\n\n    while(cin>>m>>n, m|n){\n        rep1(x,N)rep1(y,N) dp[x][y]=last[x][y]=0;\n        int x=locate[n].first,y=locate[n].second;\n        printf(\"%d %d\\n\",rec(x,y),last[x][y]);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <queue>\nusing namespace std;\n \n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n \nconst int MAX_M = 1000000;\n \nbool prime[MAX_M + 1];\nint field[2000][2000];\nint dp[2000][2000];\nint dp2[2000][2000];\n \nstruct Node {\n    int y, x, val;\n    Node(int Y, int X, int V) : y(Y), x(X), val(V) { }\n};\n \nint main() {\n    memset(prime, -1, sizeof(prime));\n    prime[0] = prime[1] = false;\n    for(int i = 2; i * i <= MAX_M; i++) {\n        if(prime[i])\n            for(int j = 2 * i; j <= MAX_M; j += i) prime[j] = false;\n    }\n \n    for(int m, n; cin >> m >> n, m || n; ) {\n \n    memset(field, 0, sizeof(field));\n \n    int x = 1000, y = 1000;\n    int k = 1;\n    int cur = 1;\n    field[y][x] = 1;\n    while(true) {\n        if(k % 2 == 1) {\n            bool f = true;\n            for(int i = 0; i < k; i++) {\n                x++;\n                cur++;\n                field[y][x] = cur;\n                if(cur >= m) {\n                    f = false;\n                    break;\n                }\n            }\n            if(f == false) break;\n            for(int i = 0; i < k; i++) {\n                y--;\n                cur++;\n                field[y][x] = cur;\n                if(cur >= m) {\n                    f = false;\n                    break;\n                }\n            }\n            if(f == false) {\n                break;\n            }\n        }\n        else {\n            bool f = true;\n            for(int i = 0; i < k; i++) {\n                x--;\n                cur++;\n                field[y][x] = cur;\n                if(cur >= m) {\n                    f = false;\n                    break;\n                }\n            }\n            if(f == false) break;\n            for(int i = 0; i < k; i++) {\n                y++;\n                cur++;\n                field[y][x] = cur;\n                if(cur >= m) {\n                    f = false;\n                    break;\n                }\n            }\n            if(f == false) break;\n        }\n        k++;\n    }\n#if 0\n    for(int y = 500 - m/4; y <= 500+m/4; y++) {\n        for(int x = 500-m/4; x <= 500+m/4; x++) {\n            printf(\"%2d \", field[y][x]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n \n    for(int i = 0; i < 2000; i++) {\n        for(int j = 0; j < 2000; j++) {\n            if(field[i][j] == n) {\n                y = i;\n                x = j;\n            }\n        }\n    }\n \n#if 0\n    for(int y = 1490; y <= 1510; y++) {\n        for(int x = 1020; x <= 1040; x++) {\n            printf(\"%6d \", field[y][x]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n \n    int resNum = 0;\n    int resPos = 0;\n \n    queue<Node> Q;\n    if(prime[field[y][x]]) Q.push(Node(y,x,field[y][x]));\n    else Q.push(Node(y,x,0));\n \n    memset(dp, 0, sizeof(dp));\n    dp[y][x] = (prime[field[y][x]] ? 1 : 0);\n \n    memset(dp2, 0, sizeof(dp2));\n \n    dp2[y][x] = (prime[field[y][x]] ? field[y][x] : 0);\n \n    while(!Q.empty()) {\n        Node p = Q.front(); Q.pop();\n        x = p.x, y = p.y;\n#if 0\n        // cerr << \"(\" << y << \",\" << x << \")\" << endl;\n        if(field[y][x] == 993541) {\n            DEBUG(993541);\n            DEBUG(x);\n            DEBUG(y);\n        }\n \n        if(field[y][x] == 997533) {\n            DEBUG(997533);\n            DEBUG(x);\n            DEBUG(y);\n        }\n#endif\n \n        if(field[y+1][x] == 0) {\n            if(resNum < dp[y][x] ) {\n                resNum = dp[y][x];\n                resPos = dp2[y][x];\n            }\n \n            if(resNum == dp[y][x] && resPos < dp2[y][x]) {\n                resNum = dp[y][x];\n                resPos = dp2[y][x];\n            }\n        }\n \n        for(int i = -1; i <= 1; i++) {\n            if(field[y+1][x+i] == 0) continue;\n            // DEBUG(y+1); DEBUG(x+i);\n            int tmp = 0;\n            if(prime[field[y+1][x+i]]) tmp = 1;\n \n            int newValue = dp[y][x] + tmp;\n \n            int np = dp2[y][x];\n            if(tmp) np = field[y+1][x+i];\n \n            if(dp[y+1][x+i] == 0) {\n                dp[y+1][x+i] = newValue;\n                Q.push(Node(y+1,x+i,np));\n                dp2[y+1][x+i] = np;\n            }\n \n            if(dp[y+1][x+i] == newValue && dp2[y+1][x+i] < np) {\n                dp[y+1][x+i] = newValue;\n                Q.push(Node(y+1,x+i,np));\n                dp2[y+1][x+i] = np;\n            }\n \n            if(dp[y+1][x+i] < newValue) {\n                dp[y+1][x+i] = newValue;\n                Q.push(Node(y+1,x+i,np));\n                dp2[y+1][x+i] = np;\n            }\n        }\n    }\n \n#if 0\n    for(int y = 500 - m/4; y <= 500+m/4; y++) {\n        for(int x = 500-m/4; x <= 500+m/4; x++) {\n            printf(\"%2d \", dp[y][x]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n \n    if(resNum == 0) {\n        cout << \"0 0\" << endl;\n    }\n    else {\n        cout << resNum << ' ' << resPos << endl;\n    }\n    }\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = (a); i <= (n); i++)\n#define M 1000001\nusing namespace std;\ntypedef pair<int, int> pii;\n\nbool p[M];\nint m, n, table[1000][1000], nx[M], ny[M], dp1[M], dp2[M];\n\nint isin(int y, int x) {\n  return 0 <= x && x < 1000 && 0 <= y && y < 1000;\n}\n\npii dfs(int m, int n) {\n  if(dp1[n] >= 0) return pii(dp1[n], dp2[n]);\n\n  pii ret = pii(0, p[n] ? n : 0);\n  REP(i, -1, 1) {\n    int qy = ny[n] + 1, qx = nx[n] + i;\n    if(!isin(qy, qx)) continue;\n    int q = table[qy][qx];\n    if(q <= m) {\n      pii t = dfs(m, q);\n      ret = max(ret, t);\n    }\n  }\n\n  dp1[n] = ret.first + p[n];\n  dp2[n] = ret.second;\n  return pii(dp1[n], dp2[n]);\n}\n\nint main(void) {\n  REP(i, 1, M) p[i] = true;\n  p[1] = p[2] = false;\n  REP(i, 2, M) if(p[i]) for(int j = i * 2; j <= M; j += i) p[j] = false;\n\n  int x = 0, y = 0, cnt = 1000 - 2, r = M - 1;\n  REP(i, 0, 999) REP(j, 0, 999) table[i][j] = 0;\n  while(cnt >= 0) {\n    REP(j, 0, cnt) { table[y][x] = r; ny[r] = y; nx[r] = x; x++; r--; }\n    REP(j, 0, cnt) { table[y][x] = r; ny[r] = y; nx[r] = x; y++; r--; }\n    REP(j, 0, cnt) { table[y][x] = r; ny[r] = y; nx[r] = x; x--; r--; }\n    REP(j, 0, cnt) { table[y][x] = r; ny[r] = y; nx[r] = x; y--; r--; }\n    if(r < 0) cout << y << \" \" << x << endl;\n    x++;\n    y++;\n    cnt -= 2;\n  }\n\n  while(cin >> m >> n, m != 0 && n != 0) {\n    REP(i, 1, m) dp1[i] = dp2[i] = -1;\n    pii ans = dfs(m, n);\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[(SIZE + 1)*(SIZE + 1) + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= (SIZE + 1)*(SIZE + 1);i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= (SIZE + 1)*(SIZE + 1);j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 || n == 0)return 0;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(y=SIZE-1;y>=0;y--){\n\t\t\tfor(x=SIZE-1;x>=0;x--){\n\t\t\t\tif (table[y][x] <= m) {\n\t\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m &&\n\t\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x - 1] || (dp[y][x] == dp[y + 1][x - 1] && pr[y][x] < pr[y + 1][x - 1]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (table[y + 1][x] <= m &&\n\t\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x] || (dp[y][x] == dp[y + 1][x] && pr[y][x] < pr[y + 1][x]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m &&\n\t\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x + 1] || (dp[y][x] == dp[y + 1][x + 1] && pr[y][x] < pr[y + 1][x + 1]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (y = 0;y < SIZE;y++) {\n\t\t\tfor (x = 0;x < SIZE;x++) {\n\t\t\t\tif (table[y][x] == n) {\n\t\t\t\t\tcout << x << \" \";\n\t\t\t\t\t//cout << pr[y][x] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cassert>\n#include<string>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<tuple>\n#include<numeric>\n#include <iomanip>\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef ll int__;\n#define rep(i,j) for(int__ i=0;i<(int__)(j);i++)\n#define repeat(i,j,k) for(int__ i=(j);i<(int__)(k);i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" \" << x << endl;\nconst int INF = 1 << 30;\n\ntemplate<typename T>\nostream& operator << (ostream &os , const vector<T> &v){\n    rep(i,v.size()) os << v[i] << (i!=v.size()-1 ? \" \" : \"\\n\"); return os;\n}\n\ntemplate<typename T>\nistream& operator >> (istream &is , vector<T> &v){\n    rep(i,v.size()) is >> v[i]; return is;\n}\n\nconst int MAX_M = 1000000 + 1;\n// const int MAX_M = 1000;\nvector<vector<int>> G;\nvector<pair<int,int>> coordinate;\nvector<int> is_prime;\n\ntemplate<class T>\nvoid debug_table(vector<vector<T>> &G) {\n    rep(i, G.size()) {\n        rep(j, G[i].size()){\n            cerr << setw(3) << (G[i][j] == INF ? -1 : G[i][j]) << (j == G[i].size() - 1 ? \"\\n\" : \" \");\n        }\n    }\n}\n\nvoid generate_prime_table() {\n    is_prime.resize(MAX_M + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    repeat(i, 2, sqrt(MAX_M) + 1) {\n        if(not is_prime[i]) continue;\n        for(int j = i * 2; j < is_prime.size(); j += i) {\n            is_prime[j] = false;\n        }\n    }\n}\n\nvoid generate_map() {\n    int HW = sqrt(MAX_M) * 1.2;\n    const int dx[] = {0, 1, 0, -1};\n    const int dy[] = {1, 0, -1, 0};\n\n    G = decltype(G)(HW, vector<int>(HW, INF));\n    coordinate.resize(MAX_M + 1);\n    {\n        int y, x;\n        y = x = HW / 2;\n        int current_h = 1;\n        int corner_count = 3;\n        int dir = 1;\n\n        for(int i = 1, count = 1; i < MAX_M + 1; i++, count--) {\n            if(count == 0){ // ?§?\n                corner_count++;\n                if(corner_count >= 4) { // ?¬??????±\n                    current_h += 2;\n                    corner_count = 0;\n                    count = current_h - 1 - 1;\n                    //cerr << endl;\n                    \n                } else {\n                    // ????????????????????????\n                    count = current_h + (corner_count == 3) - 1;\n                }                \n                dir = (dir + 1) % 4;\n            }\n            // cerr << i << \" \" << x << \" \" << y << endl;\n            \n            G[y][x] = i;\n            coordinate[i] = make_pair(y, x);\n            \n            y = y + dy[dir];\n            x = x + dx[dir];\n        }\n    }\n}\n\nbool solve(){\n    int m, n; cin >> m >> n;\n    if(m == 0 and n == 0) return false;\n    \n    vector<pair<int,int>> dp[2];\n    dp[0].resize(G[0].size(), make_pair(-1, 0));\n    dp[1].resize(G[0].size(), make_pair(-1,0));\n    int sy = coordinate[n].first;\n    int sx = coordinate[n].second;\n    dp[sy % 2][sx] = make_pair(is_prime[G[sy][sx]],\n                               is_prime[G[sy][sx]] ? G[sy][sx] : 0);\n    \n    bool flg = true;\n    pair<int,int> ans = dp[sy%2][sx];\n    int y = sy;\n    while(flg) {\n        flg = false;\n        int ny = y + 1;\n        fill(all(dp[ny % 2]), make_pair(-1, 0));\n        \n        rep(x, dp[y%2].size()) {\n            if(dp[y%2][x].first >= 0) {\n                for(int nx : {x - 1, x, x + 1}){\n                    if(0 <= nx and nx < dp[y%2].size()) {\n                        if(G[ny][nx] > m) continue;\n                        auto nxt = dp[y%2][x];\n                        if(is_prime[G[ny][nx]]) {\n                            nxt.first += 1;\n                            nxt.second = max(nxt.second, G[ny][nx]);\n                        }\n                        dp[ny%2][nx] = max(dp[ny%2][nx], nxt);\n                        ans = max(ans, dp[ny%2][nx]);\n                        flg = true;\n                    }\n                }\n            }\n            // cerr << setw(3) << dp[y%2][x].first << \" \";\n        }\n        // cerr << endl;\n        y = ny;\n    }\n    cout << ans.first << \" \" << ans.second << endl;\n    \n    return true;\n}\n\nint main(){\n    generate_map();\n    generate_prime_table();\n    // debug_table(G);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define FOR(i,a,n) for(int i = (a);i < (n);i++)\nconst int MAX_E = 1e3 + 3;\nconst int START = MAX_E / 2;\nconst int N = 1e6 + 3;\nconst int INF = 1e9;\nint p[N];\nvoid e(){\n  fill(p,p+N,1);\n  p[0] = p[1] = 0;\n  for(int i = 2;i*i<=N;i++)\n    if(p[i] == 1)for(int j = i*i;j<=N;j+=i)p[j] = 0;\n}\n\nmap<pair<int,int> ,int> mp;\n\ninline pair<int,int> pmax(pair<int,int> a, pair<int,int> b,int x,int y){\n  // a is pre\n  if(p[mp[make_pair(x,y)]]){\n    a.first++;\n    b.second = mp[make_pair(x,y)];\n    a.second = mp[make_pair(x,y)];\n    if(a.first > b.first)return a;\n    else return b;\n  }else{\n    if(a.first > b.first)return a;\n    else return b;\n  }\n}\n\nint main(){\n  int n,m;\n\n  int dx[4] = {1,0,-1,0};\n  int dy[4] = {0,-1,0,1};\n  e();\n  pair<int,int> co[MAX_E][MAX_E];// n, is prime\n  pair<int,int> dp[MAX_E][MAX_E];// first is num, second is prime\n  int rx =START,lx = START,uy = START,ly = START;\n  int x = START,y = START,mode = 0;\n  FOR(i,1,N){\n    mp[make_pair(x,y)] = i;\n    x += dx[mode];\n      y += dy[mode];\n      if(mode == 0 && x > rx){rx = x;mode++;}\n      if(mode == 1 && y > uy){uy = y;mode++;}\n      if(mode == 2 && x < lx){lx = x;mode++;}\n      if(mode == 3 && y < ly){ly = y;mode++;}\n  }\n\n\n  \n  while(cin>>n>>m,n){\n    int rx =START,lx = START,uy = START,ly = START;\n\n    int x = START,y = START,mode = 0;\n    //    int sx,sy;\n    fill(co[0],co[MAX_E],make_pair(INF,0));\n    FOR(i,1,n+1){\n      if(i == m){//get start\n      sx = x,sy = y;\n      }\n\n      co[MAX_E/2 + x][MAX_E/2 + y] = make_pair(i,p[i]);\n      x += dx[mode];\n      y += dy[mode];\n      if(mode == 0 && x > rx){rx = x;mode++;}\n      if(mode == 1 && y > uy){uy = y;mode++;}\n      if(mode == 2 && x < lx){lx = x;mode++;}\n      if(mode == 3 && y < ly){ly = y;mode++;}\n    }\n\n    int prelx = x,prerx = x;\n    int nowlx = x-1,nowrx = x;\n    sy--;\n    for(;sy >= ly;sy--){\n      if(co[nowlx][nowrx].first != INF)nowlx--;\n      if(co[nowrx][nowrx].first != INF)nowrx++;\n      for(int i  = nowlx; i <= nowrx;i++){\n        if(i < prerx) dp[i][sy] = pmax(dp[i][sy],dp[i][sy],i,sy);\n        if(i <= prerx && i >= prelx)dp[i][sy] = pmax(dp[i][sy+1], dp[i][sy],i,sy);\n        if(i > prelx)dp[i][sy] = pmax(dp[i-1][sy+1], dp[i][sy],i,sy);\n      }\n      prelx = nowlx;\n      prerx = nowrx;\n    }\n    pair<int,int> ans = make_pair(0,0);\n\n    rx =START,lx = START,uy = START,ly = START;\n    x = START,y = START,mode = 0;\n    FOR(i,1,n+1){\n      if(dp[x][y].first > ans.first)ans = dp[x][y];\n      if(dp[x][y].first == ans.first && dp[x][y].second > ans.second)ans = dp[x][y];\n    x += dx[mode];\n      y += dy[mode];\n      if(mode == 0 && x > rx){rx = x;mode++;}\n      if(mode == 1 && y > uy){uy = y;mode++;}\n      if(mode == 2 && x < lx){lx = x;mode++;}\n      if(mode == 3 && y < ly){ly = y;mode++;}\n    }\n    cout << ans.first << ' ' << ans.second << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//マップをつくる\n//ふるって素数マップ作る\n//dp[深さ][左端からの距離]で素数洞窟に入った回数をDP、素数かどうかはO(1)で判定\n//ある意味良問。誤読とか範囲指定ミスとか嘘解法とか、出しまくった。\n#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\n\nclass Solver{\npublic:\n\tint isprime[1100000];\t//素数なら1、そうでないなら0を入れる\n\tint data[2001][2001];\t//マップデータ。\n\tint dp[1201][1201];\n\tint dp2[1201][1201];\n\t\n\tvoid SetPrime( int m ){\n\t\tint i,j;\n\t\tfor( i = 0; i <= m; i++ ) isprime[i] = 1;\n\t\tisprime[0] = 0; isprime[1] = 0;\n\t\tfor( i = 2; i <= m; i++ ){\n\t\t\tif( isprime[i] ) {\n\t\t\t\t//cout << i << endl;\n\t\t\t\tfor( j = i*2; j <= m; j += i )\n\t\t\t\t\tisprime[j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid uzumaki( int m ){\n\t\tint i,j;\n\t\tint ci=600,cj=600;\n\t\tint cnt=1;\n\t\tfor( i = 1; cnt <= m; i++ ){\n\t\t\t//→\n\t\t\tfor( j = 0; j <= i; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[i+ci][j+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//↑\n\t\t\tfor( j = 1; j <= 2*i-1; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[i-j+ci][i+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//←\n\t\t\tfor( j = 1; j <= 2*i; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[-i+1+ci][i-j+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//↓\n\t\t\tfor( j = 1; j <= 2*i; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[-i+1+j+ci][-i+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//→\n\t\t\tfor( j = 1; j < i; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[i+1+ci][-i+j+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\t//デバッグ\n\t\tfor( i = -17; i <= 17; i++ ){\n\t\t\tfor( j = -17; j <= 17; j++ ){\n\t\t\t\tif ( isprime[data[i+ci][j+cj]] )\n\t\t\t\t\tprintf(\"%4dp\",data[i+ci][j+cj]);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%5d\",data[i+ci][j+cj]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t\n\tpair<int, int> search_ij(int m, int n) {\n\t\tint i,j;\n\t\tint ci=600,cj=600;\t//uzumakiと同じにしておくこと！\n\t\tint cnt=1;\n\t\tfor( i = 1; cnt <= m; i++ ){\n\t\t\tif ( data[i+1+ci][cj] < n ) {\n\t\t\t\tcnt = data[i+1+ci][cj];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//→\n\t\t\tfor( j = 0; j <= i; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(i+ci, j+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//↑\n\t\t\tfor( j = 1; j <= 2*i-1; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(i-j+ci, i+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//←\n\t\t\tfor( j = 1; j <= 2*i; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(-i+1+ci, i-j+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//↓\n\t\t\tfor( j = 1; j <= 2*i; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(-i+1+j+ci, -i+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//→\n\t\t\tfor( j = 1; j < i; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(i+1+ci, -i+j+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\treturn pair<int, int>(-1, -1);\n\t}\n\t\n\tvoid DP( int m, int n ){\n\t\tint i,j;\n\t\tpair<int, int> ij = search_ij(m, n);\n\t\ti = ij.first; if ( i == -1 ) return;\n\t\tfor( ; i < 1200; i++ ) {\n\t\t\tfor( j = 0; j < 1200; j++ ) {\n\t\t\t\tdp[i][j] = -114514;\n\t\t\t\tdp2[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\ti = ij.first;\n\t\tj = ij.second;\n\t\tdp[i][j] = 0;\n\t\t\n\t\tfor( ; i < 1200; i++ ){\n\t\t\tfor( j = 0; j < 1200; j++ ){\n\t\t\t\t//今いる場所がゴールなら何もしない\n\t\t\t\tif ( data[i][j] > m || dp[i][j] < 0 )\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\t//今いる場所が素数か\n\t\t\t\tint c = isprime[ data[i][j] ];\n\t\t\t\tdp[i+1][j-1] = max( dp[i][j]+c, dp[i+1][j-1] );\n\t\t\t\tdp[i+1][j] = max( dp[i][j]+c, dp[i+1][j] );\n\t\t\t\tdp[i+1][j+1] = max( dp[i][j]+c, dp[i+1][j+1] );\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor( i = ij.first; i < 1200; i++ ){\n\t\t\tfor( j = 0; j < 1200; j++ ) {\n\t\t\t\tans = max(ans, dp[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//経路復元とついでにans2の更新。\n\t\t//ちなみに、ゴールからたどっていけば、たどった場所すべてがスタートからありつけるようにできるので、\n\t\t//ans2を直接更新することができる。(経路の候補が消える！ということがない)→嘘解法らしい。\n\t\t//したがって、ans2はdp2を全部埋めてから求めることにしよう。\n\t\t//…最後に通過した素数洞穴の番号＞＜＞＜！(↑は嘘解法ではなかったようです。誤読！！最大値じゃない！！誤読！！)\n\t\t//誤飲も怖いけど誤読も恐ろforces…\n\t\tint ans2 = 0;\n\t\tif ( ans > 0 ) {\n\t\t\t//\n\t\t\tfor( i = 1199; i > ij.first; i-- ) {\n\t\t\t\tfor( j = 0; j < 1200; j++ ) {\n\t\t\t\t\tif ( (dp[i][j] != ans && dp2[i][j] == 0) || (dp2[i][j] == 252521) )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tif ( data[i-1][j-1] <= m && dp[i-1][j-1] + isprime[data[i-1][j-1]] == dp[i][j]) {\n\t\t\t\t\t\tdp2[i-1][j-1] = 1;\n\t\t\t\t\t\tif ( isprime[data[i-1][j-1]] ) {\n\t\t\t\t\t\t\tdp2[i-1][j-1] = 252521;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( data[i-1][j] <= m && dp[i-1][j] + isprime[data[i-1][j]] == dp[i][j] ) {\n\t\t\t\t\t\tdp2[i-1][j] = 1;\n\t\t\t\t\t\tif ( isprime[data[i-1][j]] )\n\t\t\t\t\t\t\tdp2[i-1][j] = 252521;\n\t\t\t\t\t}\n\t\t\t\t\tif ( data[i-1][j+1] <= m && dp[i-1][j+1] + isprime[data[i-1][j+1]] == dp[i][j] ) {\n\t\t\t\t\t\tdp2[i-1][j+1] = 1;\n\t\t\t\t\t\tif ( isprime[data[i-1][j+1]] )\n\t\t\t\t\t\t\tdp2[i-1][j+1] = 252521;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//\n\t\t\tfor( i = 1199; i >= ij.first; i-- ) {\n\t\t\t\tfor( j = 0; j < 1200; j++ ) {\n\t\t\t\t\tif ( dp2[i][j] == 252521 && isprime[data[i][j]] && data[i][j] <= m ) {\n\t\t\t\t\t\tans2 = max(ans2, data[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << \" \" << ans2 << endl;\n\t}\n};\n\nSolver test;\n\nint main(){\n\tint m,n;\n\t\n\ttest.SetPrime(1090000);\n\ttest.uzumaki(1090000);\n\twhile( cin >> m >> n ){\n\t\tif(!m)return 0;\n\t\ttest.DP(m, n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(x) cout << (x) << '\\n'\n#define Int int64_t\n#define fi first\n#define se second\n#define all(x) (x).begin(), (x).end()\n\nInt INF = 1e18;\nint inf = 1e9;\nInt mod = 1e9+7;\n\nbool prime[1000001];\nint field[1001][1001];\nint dp[1001][1001];\n\nint main() {\n    vector<pair<int, int>> res;\n    for (int i = 0; i <= 1e6; i++) {\n        prime[i] = true;\n    }\n    prime[0] = prime[1] = false;\n    for (int i = 2; i * i <= 1e6; i++) {\n        if (prime[i]) {\n            for (int j = 2; i * j <= 1e6; j++) {\n                prime[i * j] = false;\n            }\n        }\n    }\n    while (true) {\n        int m, n;\n        cin >> m >> n;\n        if (m == 0) break;\n        int s = 1;\n        while (s * s < m) {\n            s++;\n        }\n        for (int i = 0; i < s; i++) {\n            for (int j = 0; j < s; j++) {\n                field[i][j] = 0;\n            }\n        }\n        pair<int, int> cur = {s / 2, (s - 1) / 2};\n        field[cur.fi][cur.se] = 1;\n        queue<int> q;\n        q.push(1);\n        q.push(1);\n        pair<int, int> start = cur;\n        int mode = 0;\n        int cnt = 2;\n        int dx[] = {1, 0, -1, 0};\n        int dy[] = {0, -1, 0, 1};\n        while (cnt <= m) {\n            for (int i = 0; i < q.front() and cnt <= m; i++) {\n                cur.fi += dy[mode];\n                cur.se += dx[mode];\n                field[cur.fi][cur.se] = cnt;\n                if (cnt == n) {\n                    start = cur;\n                }\n                cnt++;\n            }\n            q.push(q.front() + 1);\n            q.pop();\n            mode = (mode + 1) % 4;\n        }\n        while (not q.empty()) q.pop();\n        // for (int i = 0; i < s; i++) {\n        //     for (int j = 0; j < s; j++) {\n        //         printf(\"%5d\", field[i][j]);\n        //     }\n        //     cout << endl;\n        // }\n        for (int i = 0; i < s; i++) {\n            for (int j = 0; j < s; j++) {\n                dp[i][j] = 0;\n            }\n        }\n        if (prime[n]) {\n            dp[start.fi][start.se] = 1;\n        }\n        for (int i = start.fi; i < s - 1; i++) {\n            int p = i - start.fi;\n            for (int j = max(0, start.se - p); j <= min(s - 1, start.se + p); j++) {\n                if (0 <= j - 1) {\n                    dp[i + 1][j - 1] = max(dp[i + 1][j - 1], dp[i][j] + prime[field[i + 1][j - 1]]);\n                }\n                dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + prime[field[i + 1][j]]);\n                if (j + 1 < s) {\n                    dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + prime[field[i + 1][j + 1]]);\n                }\n            }\n        }\n        // for (int i = 0; i < s; i++) {\n        //     for (int j = 0; j < s; j++) {\n        //         printf(\"%3d\", dp[i][j]);\n        //     }\n        //     cout << endl;\n        // }\n        int ma = -1;\n        for (int i = start.fi; i < s; i++) {\n            int p = i - start.fi;\n            for (int j = max(0, start.se - p); j <= min(s - 1, start.se + p); j++) {\n                if (field[i][j] == 0) continue;\n                ma = max(ma, dp[i][j]);\n            }\n        }\n        int ma2 = -1;\n        for (int i = start.fi; i < s; i++) {\n            int p = i - start.fi;\n            for (int j = max(0, start.se - p); j <= min(s - 1, start.se + p); j++) {\n                if (field[i][j] == 0) continue;\n                if (ma == dp[i][j] and prime[field[i][j]]) {\n                    ma2 = max(ma2, field[i][j]);\n                }\n            }\n        }\n        if (ma == 0) ma2 = 0;\n        res.emplace_back(ma, ma2);\n    }\n    for (int i = 0; i < (int)res.size(); i++) {\n        cout << res[i].fi << \" \" << res[i].se << endl;;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\n#define N 1050\nusing namespace std;\nint dat[N][N],dp[N][N],ans,ans2;\nint m,n,y,x,p,k,sy,sx,d[N][N];\nint ymin,ymax,xmin,xmax;\nbool prime[N*N];\n\nint main(){\n  int dy[4]={0,-1,0,1};\n  int dx[4]={1,0,-1,0};\n  for(int i=0;i<N*N;i++)prime[i]=true;\n  prime[0]=prime[1]=false;\n  for(int i=0;i<=N*N/2;i++){\n    if(!prime[i])continue;\n    for(int j=i+i;j<N*N;j+=i)prime[j]=false;\n  }\n  while(1){\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)dat[i][j]=-1,dp[i][j]=0,d[i][j]=0;\n    cin>>m>>n;\n    if(!m&&!n)break;\n    sy=sx=y=x=N/2;\n    dat[y][x]=1;\n    k=ymax=xmax=0,p=1;\n    ymin=xmin=INF;\n    while(p<m){\n      p++;\n      int lot=(k+1)%4;\n      if(p!=2&&dat[y+dy[lot]][x+dx[lot]]<0)k=lot;\n      y+=dy[k];\n      x+=dx[k];\n      dat[y][x]=p;\n      ymin=min(ymin,y);\n      xmin=min(xmin,x);\n      ymax=max(ymax,y);\n      xmax=max(xmax,x);\n      if(p==n)sy=y,sx=x;\n    }\n    for(int i=ymax;i>=ymin;i--){\n      for(int j=xmin;j<=xmax;j++){\n\tif(dat[i][j]<0)continue;\n\tdp[i][j]=max(dp[i][j],dp[i+1][j-1]);\n\tdp[i][j]=max(dp[i][j],dp[i+1][j]);\n\tdp[i][j]=max(dp[i][j],dp[i+1][j+1]);\n\tif(prime[dat[i][j]])dp[i][j]++;\n      }\n    }\n    ans=dp[sy][sx];\n    ans2=0;\n    d[sy][sx]=1;\n    for(int i=ymin;i<=ymax;i++){\n      int c=0,c2=0;\n      for(int j=xmin;j<=xmax;j++){\n\tif(d[i][j])c2=max(c2,dp[i][j]);\n      }\n      for(int j=xmin;j<=xmax;j++){\n\tif(c2==dp[i][j]&&d[i][j]){\n\t  if(prime[dat[i][j]])c=max(c,dat[i][j]);\n\t  d[i+1][j+1]=d[i+1][j]=d[i+1][j-1]=1;\n\t}\n      }\n      ans2=max(ans2,c);\n    }\n    cout<<ans<<' '<<ans2<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> P;\n#define F first\n#define S second\nint fie[1111][1111];\nint N,M;\nint sosu[1000001];\nP mie[1000001];\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\n\nP dp[1111][1111];\nint ndx[]={1,0,-1};\nP solve(int x,int y,int ss){\n  if(dp[x][y].F!=-1) return dp[x][y];\n  if(fie[x][y]>N ||  fie[x][y] == -1 ){\n    return P(0,ss);\n  }\n  P ret = P(0,0);\n  for(int i=0;i<3;i++){\n    int nx = x+ndx[i];\n    int ny = y+1;\n    if(fie[nx][ny]>N || fie[nx][ny] == -1 ){\n      P state = solve(nx,ny,ss);\n      ret = max(ret,state);\n    } else if(!sosu[fie[nx][ny]]){\n      P state = solve(nx,ny,fie[nx][ny]);\n      state.F ++;\n      ret = max(ret,state);\n    } else {\n      P state = solve(nx,ny,ss);\n      ret = max(ret,state);\n    }\n  }\n  // printf(\"%d dp[%d][%d] =  %d, %d fie=%d\\n\",ss,x,y,ret.F,ret.S,fie[x][y]);\n  return dp[x][y] = ret;\n}\n\nint main(){\n  sosu[1]=1;\n  for(int i=2;i<=1000000;i++){\n    if(!sosu[i]){\n      for(int j=i+i;j<=1000000;j+=i){\n\tsosu[j]=1;\n      }\n    }\n  }\n  for(int i=0;i<1111;i++)\n    for(int j=0;j<1111;j++)\n      dp[i][j]=P(-1,-1);\n  memset(fie,-1,sizeof(fie));\n\n\n  int x = 1111/2,y = 1111/2;\n  int id = 1, ic = 0;\n  //printf(\"%d %d\\n\",x,y);\n  fie[x][y]=1;\n  x += dx[ic]; y += dy[ic];\n\n \n  while( id < 1000000 ){\n    id++;\n    fie[x][y]=id;\n    mie[id] = P(x,y);\n    int nc = (ic+1)%4;\n    int nx = x+dx[nc], ny = y+dy[nc];\n    if( fie[nx][ny] == -1 ){\n      x = nx; y=ny;\n      ic=(ic+1)%4;\n    } else {\n      x = x + dx[ic]; y = y + dy[ic];\n    }\n  }\n\n\n  /*  for(int i=550;i<560;i++){\n    for(int j=550;j<560;j++){\n      printf(\"%3d \",fie[j][i]);\n    }\n    puts(\"\");\n  }\n  */\n\n  while(1){\n  for(int i=0;i<1111;i++)\n    for(int j=0;j<1111;j++)\n      dp[i][j]=P(-1,-1);\n   \n  cin >> N >> M;\n  if(!N && !M) break;\n    //    printf(\"%d %d\\n\",mie[N].F,mie[N].S);\n    P res = solve(mie[M].F,mie[M].S,-1);\n    if(res.S == -1){\n      puts(\"0 0\");\n    } else {\n      if( !sosu[fie[mie[M].F][mie[M].S]] ){\n\tif( res.F==0 ){\n\t  printf(\"%d %d\\n\",1,fie[mie[M].F][mie[M].S]);\n\t} else \n\t  printf(\"%d %d\\n\",res.F+1,res.S);\n      }\n      else\n\tprintf(\"%d %d\\n\",res.F,res.S);\n    }\n  }\n  \n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<utility>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint cave_num[1000][1000];\nbool is_prime[1000001];\nP trans[1000001];\nP dp[1000001];\nint m;\n\nvoid prime() {\n\tint p = 0;\n\tfor (int i = 0; i <= 1000000; i++)is_prime[i] = true;\n\tis_prime[0] = is_prime[1] = false;\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tif (is_prime[i]) {\n\t\t\tfor (int j = 2 * i; j <= 1000000; j += i)is_prime[j] = false;\n\t\t}\n\t}\n}\n\nP dfs(int n) {\n\tif (dp[n].first != -1)return dp[n];\n\tint res1 = 0, res2 = 0;\n\tP now = trans[n];\n\tfor (int i = -1; i <= 1; i++) {\n\t\tif (now.second + 1 > 999)break;\n\t\tif (now.first + i < 0 || now.first + i>999)continue;\n\t\tif (cave_num[now.first + i][now.second + 1] > m)continue;\n\t\tP next = dfs(cave_num[now.first + i][now.second + 1]);\n\t\tif (res1 <= next.first) {\n\t\t\tif (res1 == next.first) {\n\t\t\t\tres2 = max(res2, next.second);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres2 = next.second;\n\t\t\t}\n\t\t\tres1 = next.first;\n\t\t}\n\t}\n\tif (is_prime[n]) {\n\t\tif (res2 == 0)res2 = n;\n\t\tres1++;\n\t}\n\treturn dp[n] = P(res1, res2);\n}\n\nvoid num() {\n\tint sx = 499, sy = 500;\n\tint x = 1; cave_num[sx][sy] = x; trans[x] = P(sx, sy);\n\tfor (int i = 1; i <= 999; i++) {\n\t\tif (i % 2) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tcave_num[++sx][sy] = ++x;\n\t\t\t\ttrans[x] = P(sx, sy);\n\t\t\t}\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tcave_num[sx][--sy] = ++x;\n\t\t\t\ttrans[x] = P(sx, sy);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tcave_num[--sx][sy] = ++x;\n\t\t\t\ttrans[x] = P(sx, sy);\n\t\t\t}\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tcave_num[sx][++sy] = ++x;\n\t\t\t\ttrans[x] = P(sx, sy);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 999; i++) {\n\t\tcave_num[--sx][sy] = ++x;\n\t\ttrans[x] = P(sx, sy);\n\t}\n}\n\nint main() {\n\tint n;\n\tprime();\n\tnum();\n\twhile (scanf(\"%d %d\", &m, &n), m) {\n\t\tfor (int i = 0; i <= m; i++)dp[i] = P(-1, -1);\n\t\tP p = dfs(n);\n\t\tprintf(\"%d %d\\n\", p.first, p.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define MOD7 1000000007\n#define MOD9 1000000009\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define REP(i, a, n) for (int i = (a); i <= (n); i++)\n#define all(a) (a).begin(), (a).end()\n\nusing namespace std;\n\nint dx[4] = { 0, -1, 0, 1 };\nint dy[4] = { -1, 0, 1, 0 };\n\nconst int GETA = 502;\n\nbool isprime[1000010];\nbool prime[1004][1004];\npair<int, int> dp[1004][1004];\n\nmap<int, pair<int, int>> map1;\nmap<pair<int, int>, int> map2;\n\npair<int, int> solve(int n, int m) {\n    if (n > m) return make_pair(0, 0);\n\n    pair<int, int> &pos = map1[n];\n    if (dp[pos.first][pos.second].first != -1) return dp[pos.first][pos.second];\n\n    pair<int, int> ret = make_pair(0, 0);\n    REP(i, -1, 1) {\n\tpair<int, int> nt = make_pair(pos.first + i, pos.second + 1);\n\tif (map2.find(nt) == map2.end()) continue;\n\tpair<int, int> res = solve(map2[nt], m);\n\tif (res.first > ret.first\n\t\t|| (res.first == ret.first && res.second > ret.second)) {\n\t    ret = res;\n\t}\n    }\n    if (prime[pos.first][pos.second]) {\n\tret.first++;\n\tif (ret.first == 1) {\n\t    ret.second = n;\n\t}\n    }\n    dp[pos.first][pos.second] = ret;\n    return ret;\n}\n\nsigned main() {\n    rep(i, 1000001) isprime[i] = true;\n    isprime[1] = false;\n    REP(i, 2, 1000000) {\n\tif (!isprime[i]) continue;\n\tfor (int j = 2 * i; j <= 1000000; j += i) {\n\t    isprime[j] = false;\n\t}\n    }\n\n    int x = GETA, y = GETA;\n    int dir;\n    int size = 1;\n    int left;\n    for (int pt = 1; pt <= 1000000; pt++) {\n\tpair<int, int> pr = make_pair(x, y);\n\tmap1[pt] = pr;\n\tmap2[pr] = pt;\n\tif (isprime[pt]) {\n\t    prime[x][y] = true;\n\t}\n\tif (pt == size * size) {\n\t    x++;\n\t    size += 2;\n\t    dir = 0;\n\t    left = size - 2;\n\t} else {\n\t    x += dx[dir];\n\t    y += dy[dir];\n\t    left--;\n\t    if (left == 0) {\n\t\tdir++;\n\t\tleft = size - 1;\n\t    }\n\t}\n    }\n\n    int m, n;\n    while (cin >> m >> n) {\n\tif (m == 0) break;\n\n\tREP(i, 1, m) {\n\t    pair<int, int> &pr = map1[i];\n\t    dp[pr.first][pr.second] = make_pair(-1, 0);\n\t}\n\n\tpair<int, int> ret = solve(n, m);\n\n\tcout << ret.first << ' ' << ret.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing P = pair<int, int>;\n\nvector<int> sieveOfEratosthenes(int n) {\n  vector<int> primes(n);\n  for (int i = 2; i < n; ++i) primes[i] = i;\n  for (int i = 2; i * i < n; ++i) {\n    if (primes[i]) {\n      for (int j = i * i; j < n; j += i) primes[j] = 0;\n    }\n  }\n  // primes.erase(remove(begin(primes), end(primes), 0), end(primes));\n  return primes;\n}\n\nconst int dy[] = {0, -1, 0, 1};\nconst int dx[] = {1, 0, -1, 0};\nconst int sz = 1e3 + 2;\nconst int dsz = 1e6;\n\nint main() {\n  int y = sz / 2;\n  int x = sz / 2;\n  int cur = 3;\n  auto tb = vector<vector<int>>(sz, vector<int>(sz, 0));\n  auto rev = vector<P>(dsz + 1);\n  for (int i = 1; i <= dsz; ++i) {\n    tb[y][x] = i;\n    rev[i] = {y, x};\n    int nxt = (cur + 1) % 4;\n    int ny = y + dy[nxt];\n    int nx = x + dx[nxt];\n    if (!tb[ny][nx]) cur = nxt;\n    y += dy[cur];\n    x += dx[cur];\n  }\n\n  auto p = sieveOfEratosthenes(dsz + 1);\n  int m, n;\n  while (cin >> m >> n, m) {\n    auto dp = vector<vector<int>>(sz, vector<int>(sz, 0));\n    P ans = {};\n    int lx = rev[n].second;\n    int rx = lx + 1;\n    for (int y = rev[n].first; y < sz; ++y) {\n      for (int x = lx; x < rx; ++x) {\n        int k = tb[y][x];\n        if (k && k <= m) {\n          dp[y][x] = max({dp[y - 1][x - 1], dp[y - 1][x], dp[y - 1][x + 1]});\n          if (p[k]) ans = max(ans, {++dp[y][x], k});\n        }\n      }\n      lx = max(1, lx - 1);\n      rx = min(sz - 1, rx + 1);\n    }\n    if (ans.first == 0) ans.second = 0;\n    cout << ans.first << ' ' << ans.second << endl;\n    // for (int i = rev[n].first; i <= sz; ++i) {\n    //   for (auto&& val : dp[i]) cout << setw(3) << right << val;\n    //   cout << endl;\n    // }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n, m;\nint cave[1001][1001];\nP dp[1000005];\nbool prime[1000005];\n\nP search(int x, int y, int val)\n{\n\tint nx, ny;\n\tP ret = make_pair(0, -1);\n\t\n\tif(dp[val].first != -1) return dp[val];\n\t\n\tfor(int v = -1; v <= 1; v++){\n\t\tnx = x + v, ny = y + 1;\n\t\tif(nx < 0 || nx >= 1001 || ny < 0 || ny >= 1001) continue;\n\t\tif(cave[nx][ny] > n) continue;\n\t\tret = max(ret, search(nx, ny, cave[nx][ny]));\n\t}\n\tif(!prime[val]){\n\t\tret.first++;\n\t\tif(ret.second == -1) ret.second = val;\n\t}\n\t\n\treturn dp[val] = ret;\n}\n\nint main(void)\n{\n\tint px = 500, py = 500, dir = 0, dir2;\n\tconst int vx[] = {1, 0, -1, 0}, vy[] = {0, -1, 0, 1};\n\t\n\tint nx, ny;\n\tfor(int i = 1; i <= 1001 * 1001; i++){\n\t\tcave[px][py] = i;\n\t\tpx += vx[dir], py += vy[dir];\n\t\tdir2 = (dir+1)%4;\n\t\tif(cave[px + vx[dir2]][py + vy[dir2]] == 0) dir = dir2;\n\t}\n\t\n\tprime[1] = true;\n\tfor(int i = 2; i < 1100; i++){\n\t\tif(!prime[i]){\n\t\t\tfor(int j = 2 * i; j < 1000005; j += i) prime[j] = true;\n\t\t}\n\t}\n\t\n\tcout << \"-100\" << endl;\n\t\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0) break;\n\t\t\n\t\tfor(int i = 1; i <= n; i++) dp[i] = make_pair(-1, -1);\n\t\t\n\t\tint x, y;\n\t\tfor(x = 0; x < 1001; x++){\n\t\t\tfor(y = 0; y < 1001; y++){\n\t\t\t\tif(cave[x][y] == m) goto end;\n\t\t\t}\n\t\t}\n\t\tend:;\n\t\t\n\t\tP ans = search(x, y, m);\n\t\tif(ans.first == 0) ans.second = 0;\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\nconst int MAXN = 1000001;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\nbool isPrime[MAXN];\nint I[MAXN], J[MAXN];\n\nconst int OFFSET = 500;\nconst int H = 1111;\nconst int W = 1111;\nint G[H][W];\nint m, n;\npair<int, int> dp[H][W];\n\nint main() {\n  fill(isPrime, isPrime+MAXN, true);\n  isPrime[0] = isPrime[1] = false;\n  for(int i = 2; i < MAXN; ++i) {\n    if(!isPrime[i]) continue;\n    for(int j = i*2; j < MAXN; j += i) {\n      isPrime[j] = false;\n    }\n  }\n\n  {\n    map<int, map<int, int> > G;\n    G[0][0] = 1;\n    I[1] = 0, J[1] = 0;\n    int pi = 0, pj = 0, d = 2;\n    for(int num = 2; num < MAXN; ++num) {\n      for(int k = 0; k < 4; ++k) {\n        int nd = (d + k + 2) % 4;\n        int ni = pi + di[nd];\n        int nj = pj + dj[nd];\n        if(G[ni][nj]) continue;\n        G[ni][nj] = num;\n        pi = ni, pj = nj, d = nd;\n        I[num] = pi, J[num] = pj;\n        break;\n      }\n    }\n  }\n\n  fill(G[0], G[H], INF);\n  for(int i = 1; i < MAXN; ++i) {\n    I[i] += OFFSET;\n    J[i] += OFFSET;\n    G[I[i]][J[i]] = i;\n  }\n\n  while(cin >> m >> n && (m|n)) {\n    int si = I[n], sj= J[n];\n    fill(dp[0], dp[H], make_pair(-1, -1));\n    dp[si][sj] = make_pair(isPrime[G[si][sj]], \n                           isPrime[G[si][sj]] * G[si][sj]);\n    pair<int, int> res = dp[si][sj];\n    for(int i = si; i+1 < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        if(dp[i][j].first == -1) continue;\n        for(int d = -1; d <= 1; ++d) {\n          int ni = i + 1;\n          int nj = j + d;\n          if(nj < 0 || nj >= W) continue;\n          if(G[ni][nj] > m) continue;\n          dp[ni][nj]\n            = max(dp[ni][nj],\n                  make_pair(dp[i][j].first + isPrime[G[ni][nj]],\n                            max(dp[i][j].first, isPrime[G[ni][nj]]*G[ni][nj])));\n          res = max(res, dp[ni][nj]);\n        }\n      }\n    }\n    cout << res.first << \" \" << res.second << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE + 10][SIZE + 10], dp[SIZE + 10][SIZE + 10], pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (y>=0&&x>=0&&table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t\n\t\tfor (int h = 0;h < SIZE;h++) {\n\t\t\tfor (int w = 0;w < SIZE;w++) {\n\t\t\t\tif (table[h][w] == n) {\n\t\t\t\t\t//cout << dp[h][w] << \" \" << pr[h][w] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n \n/*--------------------template--------------------*/\n \nconst int N = 1111111;\nbool prime[N];\nvector<int> primes;\n \nvoid hurui()\n{\n    memset(prime, true, sizeof(prime));\n    prime[0] = prime[1] = false;\n    for (int i = 2; i*i < N; i++)\n    {\n        for (int j = 2; i*j < N; j++)\n        {\n            prime[i*j] = false;\n        }\n    }\n    REP(i, N + 1)\n    {\n        if (prime[i]) primes.push_back(i);\n    }\n}\n \nint m, n;\nbool fld[1200][1200];\npii id[1111111];\nint hs[1200][1200];\n \nvoid init()\n{\n    int tx = 600, ty = 600, t = 1;\n    FOR(i, 1, INF)\n    {\n        if (t > 1000000) break;\n        if (i % 2)\n        {\n            REP(j, i)\n            {\n                id[t] = pii(tx, ty);\n                hs[tx][ty] = t;\n                t++;\n                ty++;\n            }\n            REP(j, i)\n            {\n                id[t] = pii(tx, ty);\n                hs[tx][ty] = t;\n                t++;\n                tx--;\n            }\n        }\n        else\n        {\n            REP(j, i)\n            {\n                id[t] = pii(tx, ty);\n                hs[tx][ty] = t;\n                t++;\n                ty--;\n            }\n            REP(j, i)\n            {\n                id[t] = pii(tx, ty);\n                hs[tx][ty] = t;\n                t++;\n                tx++;\n            }\n        }\n    }\n}\n \npii dp[1200][1200];\n \npii solve(int x, int y)\n{\n    if (x == 1199) return pii(0, 0);\n    if (dp[x][y].first >= 0) return dp[x][y];\n    pii res(0, 0);\n    if (fld[x + 1][y - 1])\n    {\n        pii tmp = solve(x + 1, y - 1);\n        chmax(res, pii(tmp.first + 1, (tmp.second==0?hs[x + 1][y - 1]:tmp.second)));\n    }\n    else\n    {\n        chmax(res, pii(solve(x + 1, y - 1).first, solve(x + 1, y - 1).second));\n    }\n \n    if (fld[x + 1][y])\n    {\n        pii tmp = solve(x + 1, y);\n        chmax(res, pii(tmp.first + 1, (tmp.second == 0 ? hs[x + 1][y] : tmp.second)));\n    }\n    else\n    {\n        chmax(res, pii(solve(x + 1, y).first, solve(x + 1, y).second));\n    }\n \n    if (fld[x + 1][y + 1])\n    {\n        pii tmp = solve(x + 1, y + 1);\n        chmax(res, pii(tmp.first + 1, (tmp.second == 0 ? hs[x + 1][y + 1] : tmp.second)));\n    }\n    else\n    {\n        chmax(res, pii(solve(x + 1, y + 1).first, solve(x + 1, y + 1).second));\n    }\n    return dp[x][y] = res;\n}\n \nint main()\n{\n    hurui();\n    init();\n    while (cin >> n >> m, n)\n    {\n        MS(fld, false);\n        REP(i, 1200)REP(j, 1200) dp[i][j] = pii(-1, -1);\n        REP(i, primes.size())\n        {\n            if (primes[i] > n) break;\n            int x = id[primes[i]].first, y = id[primes[i]].second;\n            fld[x][y] = true;\n        }\n        pii ans = solve(id[m].first, id[m].second);\n        if (find(ALL(primes), m) != primes.end())\n        {\n            if(ans.second==0) cout << ans.first + 1 << \" \" << m << endl;\n            else cout << ans.first + 1 << \" \" << ans.second << endl;\n        }\n        else cout << ans.first << \" \" << ans.second << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX   = 1000100;\nconst int MAX_M = 1000100;\nconst int W = 1020;\nbool prime[MAX];\nint n, m;\n\nvoid sieve(){\n    fill(prime, prime+MAX, true);\n    prime[0] = prime[1] = false;\n\n    for(int i=0; i < MAX; i++){\n        if(!prime[i]) continue;\n        for(int j=i+i; j < MAX; j += i){\n            prime[j] = false;\n        }\n    }\n}\n\nint cave[W][W] = {};\npair<int, int> memo[W][W];\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\n\npair<int, int> bfs(int x, int y){\n    if(memo[x][y].first != -1) return memo[x][y];\n\n    pair<int, int> ret = make_pair(0, 0);\n    for(int i=-1; i <= 1; i++){\n        if(n < cave[x+1][y+i] || cave[x+1][y+i] == -1) continue;\n        ret = max(ret, bfs(x+1, y+i));\n    }\n    if(prime[cave[x][y]]){\n        if(ret.first == 0) ret.second = cave[x][y];\n        ret.first++;\n    }\n    memo[x][y] = ret;\n    return ret;\n}\n\nint main(){\n    sieve();\n    int x = W/2, y = W/2;\n    int d = 1, p = 2;\n    for(int i=0; i< W; i++)for(int j=0; j< W; j++) cave[i][j] = -1;\n    for(int i = 1; i <= MAX_M; i++){\n        for(int j = 0; j < d && i <= MAX_M; j++, i++){\n            cave[x][y] = i;\n            x += dx[p%4]; y += dy[p%4];\n        }\n        p++; i--;\n        if(p%2 == 0) d++;\n    }\n    while(cin >> n >> m, n+m){\n        for(int i=0; i< W; i++)for(int j =0; j < W; j++) memo[i][j] = make_pair(-1, -1);\n        d = 1; p = 2;\n        x = W/2; y = W/2;\n        while(cave[x][y] != m){\n            for(int j=0; j < d && cave[x][y] != m; j++){\n                x += dx[p%4]; y += dy[p%4];\n            }\n            p++;\n            if(p%2 == 0) d++;\n        }\n        pair<int, int> ret = bfs(x, y);\n        cout << ret.first << \" \" << ret.second << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, -1, 0, 1, 1, 1, -1, -1};\nconst int L = 3500;\nconst int N = 1000000;\nint grid[L][L];\nvoid init(){\n  int l = 1;\n  int x = L / 2;\n  int y = L / 2;\n  int r = 0;\n  int rest = 1;\n  for(int y = 0; y < L; y++) {\n    for(int x = 0; x < L; x++){\n      grid[y][x] = INF;\n    }\n  }\n  for(int i = 1; i <= N; i++){\n    assert(grid[y][x] == INF);\n    grid[y][x] = i;\n    x += dx[r];\n    y += dy[r];\n    rest--;\n    if(rest == 0){\n      r = (r + 1) % 4;\n      if(r % 2 == 0) l++;\n      rest = l;\n    }\n  }\n}\n\nbool prime[N + 1] = {};\nvoid make_prime(){\n  for(int i = 2; i <= N; i++) prime[i] = true;\n  for(int i = 2; i <= N; i++) if(prime[i]){\n    for(int j = 2 * i; j <= N; j += i){\n      prime[j] = false;\n    }\n  }\n}\n\n\nint main(){\n  init();\n  make_prime();\n  int max_n, st;\n  while(cin >> max_n >> st && max_n){\n    static int dp[L][L];\n    for(int y = 0; y < L ; y++){\n      for(int x = 0; x < L; x++){\n        if(grid[y][x] == st) dp[y][x] = prime[ grid[y][x] ];\n        else                 dp[y][x] = -INF;\n      }\n    }\n    int ans1 = 0;\n    int ans2 = 0;\n    for(int y = 1; y < L; y++){\n      for(int x = 0; x < L; x++) if(grid[y][x] <= max_n){\n        for(int dx = -1; dx <= 1; dx++)if(x + dx >= 0 && x + dx < L){\n          dp[y][x] = max(dp[y][x], dp[y - 1][x + dx] + prime[ grid[y][x] ]);\n          if(dp[y][x] > ans1 && dp[y][x] > 0 && prime[ grid[y][x] ]){\n            ans1 = dp[y][x];\n            ans2 = grid[y][x];\n          }else if(dp[y][x] == ans1 && dp[y][x] > 0 && prime[ grid[y][x] ]){\n            ans2 = max(ans2, grid[y][x]);\n          }\n        }\n      }\n    }\n    printf(\"%d %d\\n\", ans1, ans2);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nconst int ccc=1e6;\nbool prime[ccc+1];\nint a[2000][2000],px[ccc+1],py[ccc+1];\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\nP memo[ccc+1];\nP dfs(int n,int m){\n//\tshow(n);\n\tif(n==0||n>m) return P(0,0);\n\tif(memo[n].fs!=-1) return memo[n];\n\tint x=px[n],y=py[n];\n\tP ret=P(0,0);\n\tfor(int i=-1;i<=1;i++){\n\t\tret=max(ret,dfs(a[x+i][y-1],m));\n\t}\n\tif(prime[n]){\n\t\tret.fs++;\n\t\tif(ret.fs==1) ret.sc=n;\n\t}\n\treturn memo[n]=ret;\n}\nint main(){\n\tfor(int i=2;i<=ccc;i++) prime[i]=true;\n\tfor(int i=2;i*i<=ccc;i++) if(prime[i]) for(int j=2;j*i<=ccc;j++) prime[i*j]=false;\n\tint x=1000,y=1000;\n\tint p=1,d=0,l=1,mx=1;\n\trep1(p,ccc){\n\t\ta[x][y]=p;\n\t\tpx[p]=x,py[p]=y;\n\t\tx+=dx[d],y+=dy[d];\n\t\tl--;\n\t\tif(l==0){\n\t\t\tif(d%2) mx++;\n\t\t\tl=mx;\n\t\t\td=(d+1)%4;\n\t\t}\n\t}\n\twhile(true){\n\t\tint m,n;\n\t\tcin>>m>>n;\n\t\tif(m==0) break;\n\t\trep1(i,m) memo[i]=P(-1,0);\n\t\tP ans=dfs(n,m);\n\t\tcout<<ans.fs<<\" \"<<ans.sc<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iomanip>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define pii pair<int,int>\n\n#define MAXM 1000001\n#define MAXSQM 1002\nint diff[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nint map[MAXSQM][MAXSQM] = {};\nbool furui[MAXM] = {};\npii dpmap[MAXSQM][2] = {};\n\nvoid init_map(int m){\n    fill_n(*map,MAXSQM*MAXSQM,0);\n    fill_n(*dpmap,MAXSQM*2,pii(-1,-1));\n    int idx=MAXSQM/2,idy=MAXSQM/2;\n    int dir=0;\n    int c=1;\n    for(int i=1;c<=m;i++){\n        for(int j=0;j<i&&c<=m;j++){\n            map[idx][idy]=c++;\n            idx+=diff[dir][0];\n            idy+=diff[dir][1];\n        }\n        dir=(dir+1)%4;\n        for(int j=0;j<i&&c<=m;j++){\n            map[idx][idy]=c++;\n            idx+=diff[dir][0];\n            idy+=diff[dir][1];\n        }\n        dir=(dir+1)%4;\n    }\n}\n\npii dp(int n){\n    int nx,ny;\n    for(nx=0;nx<MAXSQM;nx++){\n        for(ny=0;ny<MAXSQM;ny++){\n            if(n==map[nx][ny]) break;\n        }\n        if(n==map[nx][ny]) break;\n    }\n\n    pii ans=pii(0,0);\n\n    if(!furui[map[nx][ny]]){\n        dpmap[nx][ny%2]=pii(1,map[nx][ny]);\n        ans=dpmap[nx][ny%2];\n    }\n    else\n    {\n        dpmap[nx][ny%2]=pii(0,0);\n    }\n\n    for(int j=ny;j>=1;j--){\n        for(int i=0;i<MAXSQM;i++){\n            if(map[i][j]==0 || dpmap[i][j%2].first==-1) continue;\n            for(int k=-1;k<=1;k++){\n                if(map[i+k][j-1]==0) continue;\n                if(!furui[map[i+k][j-1]]){\n                    dpmap[i+k][(j-1)%2]=max(pii(dpmap[i][j%2].first+1,map[i+k][j-1]), dpmap[i+k][(j-1)%2]);\n                }\n                else\n                {\n                    dpmap[i+k][(j-1)%2]=max(dpmap[i][j%2], dpmap[i+k][(j-1)%2]);\n                }\n                ans=max(ans,dpmap[i+k][(j-1)%2]);\n            }\n        }\n    }\n    return ans;\n}\n\nint main(){\n    while(1){\n        int m,n;\n        cin>>m>>n;\n        if(m==0) break;\n\n        furui[0]==furui[1]==true;\n        for(int i=2;i<MAXSQM;i++){\n            for(int j=2;i*j<MAXM;j++){\n                if(!furui[i]){\n                    furui[i*j]=true;\n                }\n            }\n        }\n        init_map(m);\n        pii p=dp(n);\n\n        /*int b=503,a=487;\n        for(int i=a-5;i<a+5;i++){\n            for(int j=b-5;j<b+5;j++){\n                cout<<std::setw(4)<<map[j][i];\n            }\n            cout<<endl;\n        }\n        for(int i=a-5;i<a+5;i++){\n            for(int j=b-5;j<b+5;j++){\n                cout<<setw(4)<<dpmap[j][i].first;\n            }\n            cout<<endl;\n        }*/\n        cout<<p.first<<\" \"<<p.second<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <unordered_map>\n\n#define MOD7 1000000007\n#define MOD9 1000000009\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define REP(i, a, n) for (int i = (a); i <= (n); i++)\n#define all(a) (a).begin(), (a).end()\n\nusing namespace std;\n\nint dx[4] = { 0, -1, 0, 1 };\nint dy[4] = { -1, 0, 1, 0 };\n\nint nextInt() {int a; cin >> a; return a;}\nchar nextChar() {char a; cin >> a; return a;}\ndouble nextDouble() {double a; cin >> a; return a;}\nstring nextString() {string a; cin >> a; return a;}\n\nvoid inputVector(vector<int> &v, int &n) {rep(i,n){v.push_back(nextInt());}}\nvoid inputVector(vector<double> &v, int &n) {rep(i,n){v.push_back(nextDouble());}}\nvoid inputVector(vector<string> &v, int &n) {rep(i,n){v.push_back(nextString());}}\n\nconst int GETA = 502;\n\nbool isprime[1000010];\npair<int, int> dp[1004][1004];\n\nmap<int, pair<short, short>> map1;\nmap<pair<short, short>, int> map2;\n\npair<int, int> solve(int n, int m) {\n    if (n > m) return make_pair(0, 0);\n\n    pair<short, short> &pos = map1[n];\n    if (dp[pos.first][pos.second].first != -1) return dp[pos.first][pos.second];\n\n    pair<int, int> ret = make_pair(0, 0);\n    REP(i, -1, 1) {\n\tpair<short, short> nt = make_pair(pos.first + i, pos.second + 1);\n\tif (map2.find(nt) == map2.end()) continue;\n\tpair<int, int> res = solve(map2[nt], m);\n\tif (res.first > ret.first\n\t\t|| (res.first == ret.first && res.second > ret.second)) {\n\t    ret = res;\n\t}\n    }\n    if (isprime[n]) {\n\tret.first++;\n\tif (ret.first == 1) {\n\t    ret.second = n;\n\t}\n    }\n    dp[pos.first][pos.second] = ret;\n    return ret;\n}\n\nsigned main() {\n    rep(i, 1000001) isprime[i] = true;\n    isprime[1] = false;\n    REP(i, 2, 1000000) {\n\tif (!isprime[i]) continue;\n\tfor (int j = 2 * i; j <= 1000000; j += i) {\n\t    isprime[j] = false;\n\t}\n    }\n\n    int x = GETA, y = GETA;\n    int dir;\n    int size = 1;\n    int left;\n    for (int pt = 1; pt <= 1000000; pt++) {\n\tpair<short, short> pr = make_pair(x, y);\n\tmap1[pt] = pr;\n\tmap2[pr] = pt;\n\tif (pt == size * size) {\n\t    x++;\n\t    size += 2;\n\t    dir = 0;\n\t    left = size - 2;\n\t} else {\n\t    x += dx[dir];\n\t    y += dy[dir];\n\t    left--;\n\t    if (left == 0) {\n\t\tdir++;\n\t\tleft = size - 1;\n\t    }\n\t}\n    }\n\n    int m, n;\n    while (cin >> m >> n) {\n\tif (m == 0) break;\n\n\tREP(i, 1, m) {\n\t    pair<short, short> &pr = map1[i];\n\t    dp[pr.first][pr.second] = make_pair(-1, 0);\n\t}\n\n\tpair<int, int> ret = solve(n, m);\n\n\tcout << ret.first << ' ' << ret.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 1000030\n\nenum DIR{\n\tN,\n\tE,\n\tS,\n\tW,\n};\n\nstruct Info{\n\tint row,col;\n};\n\nbool* prime_table;\nint** map;\nInfo* info;\n\n\nint hole_num,start;\nint diff_col[3] = {-1,0,1};\nint diff_row_N[3] = {-1,0,0},diff_col_N[3] = {0,-1,1};\nint diff_row_E[3] = {-1,0,1},diff_col_E[3] = {0,1,0};\nint diff_row_S[3] = {0,0,1},diff_col_S[3] = {-1,1,0};\nint diff_row_W[3] = {-1,0,1},diff_col_W[3] = {0,-1,0};\n\nint dp[2][1101],last[1101];\n\nvoid func(){\n\n\tfor(int i = 0; i < 1101; i++){\n\t\tfor(int k = 0; k < 2; k++)dp[k][i] = -1;\n\t\tlast[i] = -1;\n\t}\n\n\tint row,col,next_col;\n\n\trow = info[start].row;\n\tcol = info[start].col;\n\n\tif(prime_table[start]){\n\t\tdp[1][col] = 1;\n\t\tlast[col] = start;\n\t}else{\n\t\tdp[1][col] = 0;\n\t}\n\n\tbool FLG;\n\n\twhile(true){\n\n\t\tfor(int col = 0; col < 1101; col++){\n\t\t\tdp[0][col] = dp[1][col];\n\t\t}\n\n\t\trow++;\n\n\t\tFLG = false;\n\t\tfor(int col = 0; col < 1101; col++){\n\t\t\tif(dp[0][col] != -1){\n\n\t\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\tnext_col = col + diff_col[i];\n\t\t\t\t\tif(map[row][next_col] > hole_num || map[row][next_col] == -1)continue;\n\n\t\t\t\t\tFLG = true;\n\n\t\t\t\t\tif(prime_table[map[row][next_col]]){\n\t\t\t\t\t\tif(dp[1][next_col] <= dp[0][col]+1){\n\t\t\t\t\t\t\tdp[1][next_col] = dp[0][col]+1;\n\t\t\t\t\t\t\tlast[next_col] = map[row][next_col];\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\tif(dp[1][next_col] < dp[0][col]){\n\t\t\t\t\t\t\tdp[1][next_col] = dp[0][col];\n\t\t\t\t\t\t\tlast[next_col] = last[col];\n\t\t\t\t\t\t}else if(dp[next_col] == dp[col]){\n\t\t\t\t\t\t\tlast[next_col] = max(last[next_col],last[col]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG)break;\n\t}\n\n\tint ans1 = 0,ans2 = 0;\n\n\tfor(int i = 0; i < 1101; i++){\n\t\tif(dp[0][i] > ans1){\n\t\t\tans1 = dp[0][i];\n\t\t\tans2 = last[i];\n\t\t}else if(dp[0][i] == ans1){\n\t\t\tans2 = max(ans2,last[i]);\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\",ans1,ans2);\n\n}\n\nint main(){\n\n\tprime_table = new bool[NUM];\n\n\tfor(int i = 0; i < NUM; i++){\n\t\tprime_table[i] = true;\n\t}\n\n\tprime_table[1] = false;\n\n\tint limit = sqrt(NUM);\n\n\tfor(int i = 2; i <= limit; i++){\n\t\tif(prime_table[i]){\n\t\t\tfor(int j = 2*i; j < NUM; j+=i){\n\t\t\t\tprime_table[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tmap = new int*[1101];\n\tfor(int i = 0; i < 1101; i++){\n\t\tmap[i] = new int[1101];\n\t\tfor(int k = 0; k < 1101; k++)map[i][k] = -1;\n\t}\n\n\tmap[550][550] = 1;\n\n\tint row = 550,col = 550,adj_row,adj_col;\n\tint id = 2;\n\tDIR dir = E;\n\n\tbool FLG;\n\n\twhile(id <= NUM){\n\n\t\tFLG = true;\n\t\tswitch(dir){\n\t\tcase N:\n\t\t\trow--;\n\t\t\tmap[row][col] = id++;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tadj_row = row+diff_row_N[i];\n\t\t\t\tadj_col = col + diff_col_N[i];\n\n\t\t\t\tif(map[adj_row][adj_col] != -1){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG)dir = W;\n\n\t\t\tbreak;\n\t\tcase E:\n\t\t\tcol++;\n\t\t\tmap[row][col] = id++;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tadj_row = row+diff_row_E[i];\n\t\t\t\tadj_col = col + diff_col_E[i];\n\n\t\t\t\tif(map[adj_row][adj_col] != -1){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG)dir = N;\n\n\t\t\tbreak;\n\t\tcase S:\n\t\t\trow++;\n\t\t\tmap[row][col] = id++;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tadj_row = row+diff_row_S[i];\n\t\t\t\tadj_col = col + diff_col_S[i];\n\n\t\t\t\tif(map[adj_row][adj_col] != -1){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG)dir = E;\n\n\t\t\tbreak;\n\t\tcase W:\n\t\t\tcol--;\n\t\t\tmap[row][col] = id++;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tadj_row = row+diff_row_W[i];\n\t\t\t\tadj_col = col + diff_col_W[i];\n\n\t\t\t\tif(map[adj_row][adj_col] != -1){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG)dir = S;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tinfo = (Info*)malloc(sizeof(Info)*(NUM+1));\n\n\tfor(int i = 0; i < 1101; i++){\n\t\tfor(int k = 0; k < 1101; k++){\n\t\t\tif(map[i][k] != -1){\n\t\t\t\tinfo[map[i][k]].row = i;\n\t\t\t\tinfo[map[i][k]].col = k;\n \t\t\t}\n\t\t}\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&hole_num,&start);\n\t\tif(hole_num == 0 && start == 0)break;\n\n\t\tfunc();\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS; typedef istringstream ISS;\ntypedef long long LL;\ntypedef pair<int, int> PII;  typedef pair<LL, LL> PLL;\ntypedef vector<int>    VI;   typedef vector<VI>   VVI;   typedef vector<VVI>   VVVI;\ntypedef vector<LL>     VLL;  typedef vector<VLL>  VVLL;  typedef vector<VVLL>  VVVLL;\ntypedef vector<double> VD;   typedef vector<VD>   VVD;   typedef vector<VVD>   VVVD;\ntypedef vector<string> VS;   typedef vector<VS>   VVS;   typedef vector<VVS>   VVVS;\ntypedef vector<bool>   VB;   typedef vector<VB>   VVB;   typedef vector<VVB>   VVVB;\ntypedef vector<PII>    VPII; typedef vector<VPII> VVPII; typedef vector<VVPII> VVVPII;\ntypedef vector<PLL>    VPLL; typedef vector<VPLL> VVPLL; typedef vector<VVPLL> VVVPLL;\n\ntypedef unsigned int  UI;\ntypedef vector<UI>    VUI;\ntypedef vector<VUI>   VVUI;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x)  (x).begin(),(x).end()\n#define RALL(x) (x).rbegin(),(x).rend()\n#define RANGEBOX(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define RANGE(x, l, r) ((l) <= (x) && (x) <= (r))\n#define rep(i, N)  for (int i = 0; i < (int)(N); i++)\n#define rrep(i, N) for (int i = N - 1; i >= 0; i--)\n#define REP(i, init, N)  for (int i = (init); i < (int)(N); i++)\n#define RREP(i, N, last) for (int i = (init - 1); i >= last; i--)\n#define MAXUD(orig, target) orig = max(orig, target)\n#define MINUD(orig, target) orig = min(orig, target)\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a)   { OSS oss; oss << a; return oss.str(); };\n\ntemplate<typename T=int> inline void dump(vector<T> vs, bool ent=false) { rep(i, vs.size()) cout << vs[i] << (i+1==vs.size() ? '\\n' : ' '); if (ent) cout << endl; }\ntemplate<typename T = int> inline void dump(vector<vector<T>> vs, bool ent = false) { rep(i, vs.size()) dump<T>(vs[i]); if (ent) cout << endl; }\n\nconst int    INF  = 0x3f3f3f3f;\nconst LL     INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int    DX[] = {1,  0, -1, 0};\nconst int    DY[] = {0, -1,  0, 1};\nconst double EPS  = 1e-12;\n// const double PI   = acos(-1.0);\n// lambda: [](T1 x)->T2{return y;}\n// simple lambda: [](T x){return x;}\n\nVB prime;\n// O(sqrt(n) * n)\nvoid initprime(LL num) {\n\tprime = VB(num + 1, true);\n\tprime[1] = prime[0] = false;\n\tfor (LL i = 2; i * i <= num; i++) {\n\t\tif (prime[i]) {\n\t\t\tfor (LL j = i + i; j <= num; j += i) {\n\t\t\t\tprime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst int MAX_M = 1000010;\nconst int HW = 5000;\nconst int OFFSET = 2000;\nVVI ts = VVI(HW, VI(HW));\nVPII toIdx(MAX_M);\nint M, N;\n\nvoid gen_ts() {\n    int dir = 0;\n    int x = OFFSET, y = OFFSET;\n    int idx = 1;\n    int cnt = 1;\n    ts[y][x] = 1;\n    while (true) {\n        rep(i, 2) {\n            rep(j, cnt) {\n                ++idx;\n                if (idx > MAX_M) return;\n                x += DX[dir];\n                y += DY[dir];\n                ts[y][x] = idx;\n                toIdx[idx] = MP(y, x);\n            }\n            dir = (dir + 1) % 4;\n\n        }\n        ++cnt;\n    }\n}\n\nVVPII memo(HW, VPII(HW));\n\nPII dfs(PII p) {\n    int x = p.snd;\n    int y = p.fst;\n    if (memo[y][x].fst) return memo[y][x];\n\n    int num = ts[y][x];\n    bool is_b = prime[num];\n    PII res(is_b ? 1 : 0, is_b ? num : 0);\n    rep(i, 3) {\n        int nx = x + (i - 1);\n        int ny = y + 1;\n        int nnum = ts[ny][nx];\n        if (nnum != 0 && nnum <= M) {\n            PII tmp = dfs(MP(ny, nx));\n            tmp.fst += is_b;\n            res = max(res, tmp);\n        }\n    }\n\n    if (!res.snd && is_b) {\n        res.snd = num;\n    }\n\n    return memo[y][x] = res;\n}\n\n// price, num\nPII solve() {\n    memo = VVPII(HW, VPII(HW));\n    PII start = toIdx[N];\n    PII res = dfs(start);\n    return res;\n}\n\nint main(void) {\n    initprime(1000010);\n    gen_ts();\n\n    while (cin >> M >> N, M) {\n        PII x = solve();\n        cout << x.fst << \" \" << x.snd << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nmap<P, int> num;\nmap<int, P> pos;\nmap<P, int> sum;\nset<P> vis;\nint dx[] = { 1,0,-1,0 };\nint dy[] = { 0,-1,0,1 };\nbool is_prime[1000001];\nint main() {\n\tmemset(is_prime, -1, sizeof(is_prime));\n\tis_prime[1] = 0;\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tif (!is_prime[i]) continue;\n\t\tfor (int j = i * 2; j <= 1000000; j += i) is_prime[j] = 0;\n\t}\n\tint x = 0, y = 0;\n\tint dir = 0;\n\tint len = 1;\n\tint cnt = 0;\n\tnum[P(0, 0)] = 1;\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tx += dx[dir];\n\t\ty += dy[dir];\n\t\tnum[P(x, y)] = i;\n\t\tpos[i] = P(x, y);\n\t\tcnt++;\n\t\tif (cnt == len) {\n\t\t\tcnt = 0;\n\t\t\tif (dir % 2) len++;\n\t\t\t(dir += 1) %= 4;\n\t\t}\n\t}\n\tint m, n;\n\twhile (cin >> m >> n, m) {\n\t\tsum.clear();\n\t\tvis.clear();\n\t\tint sx, sy;\n\t\tsx = pos[n].first;\n\t\tsy = pos[n].second;\n\t\tint ans = -1;\n\t\tint t = -1;\n\t\tqueue<P> Q;\n\t\tQ.push(P(sx, sy));\n\t\twhile (!Q.empty()) {\n\t\t\tP now = Q.front(); Q.pop();\n\t\t\tif (vis.find(now) != vis.end()) continue;\n\t\t\tvis.insert(now);\n\t\t\tif (is_prime[num[now]]) {\n\t\t\t\tsum[now]++;\n\t\t\t\tif (ans < sum[now]) {\n\t\t\t\t\tans = sum[now];\n\t\t\t\t\tt = num[now];\n\t\t\t\t}\n\t\t\t\telse if (ans == sum[now]) {\n\t\t\t\t\tt = max(t, num[now]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\t\tint x = now.first + i;\n\t\t\t\tint y = now.second + 1;\n\t\t\t\tif (num.find(P(x, y)) == num.end()) continue;\n\t\t\t\tsum[P(x, y)] = max(sum[P(x, y)], sum[now]);\n\t\t\t\tQ.push(P(x, y));\n\t\t\t}\n\t\t}\n\t\tif (ans == -1) cout << \"0 0\" << endl;\n\t\telse cout << ans << \" \" << t << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <limits>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <complex>\n\nusing namespace std;\n\n#define INF (INT_MAX/3)\n#define PI (2*acos(0.0))\n#define EPS (1e-8)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint hw, m, n, sx, sy;\nint cave[1001][1001];\nint memo[1001][1001];\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, -1, 0, 1};\nint length = 0, lastcave = 0;\nbool isPrime[1000001];\n\nvoid printCave(){\n  for(int y = 0; y < hw; y++){\n    for(int x = 0; x < hw; x++){\n      printf(\"%02d \", cave[y][x]);\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\nvoid init(){\n  for(int i = 0; i <= 1000; i++){\n    for(int j = 0; j <= 1000; j++){\n      cave[i][j] = 0;\n      memo[i][j] = -1;\n    }\n  }\n}\n\nvoid seive(){\n  for(int i = 0; i <= 1000000; i++) isPrime[i] = true;\n\n  isPrime[0] = isPrime[1] = false;\n  for(int i = 2; i * i <= 1000000; i++){\n    for(int j = i * i; j <= 1000000; j += i) isPrime[j] = false;\n  }\n}\n\nvoid buildCave(int num, int x, int y, int d){\n  cave[y][x] = num;\n  if(num == m) return;\n  int nx = x + dx[(d+1)%4], ny = y + dy[(d+1)%4];\n  if(0 <= nx && nx < hw && 0 <= ny && ny < hw && cave[ny][nx] == 0) buildCave(num + 1, nx, ny, (d+1)%4);\n  else buildCave(num + 1, x + dx[d], y + dy[d], d);\n}\n\nvoid solve(int x, int y, int cnt){\n  if(!isPrime[cave[y][x]]) cnt--;\n\n  if(cave[y][x] == 0) return;\n  if(isPrime[cave[y][x]]){\n    if(cnt == length) lastcave = max(lastcave, cave[y][x]);\n    else if(cnt > length) lastcave = cave[y][x];\n    length = max(length, cnt);\n  }\n\n  if(0 <= x+1 && x+1 < hw && 0 <= y+1 && y+1 < hw) solve(x + 1, y + 1, cnt + 1);\n  if(0 <= y+1 && y+1 < hw) solve(x, y + 1, cnt + 1);\n  if(0 <= y+1 && y+1 < hw && 0 <= x-1 && x-1 < hw) solve(x - 1, y + 1, cnt + 1);\n}\n\nint main(){\n  ios_base::sync_with_stdio(0);\n  seive();\n  while(cin >> m >> n && m != 0 && n != 0){\n    hw = int(ceil(sqrt(m)) / 2) * 2 + 1;\n    init();\n    lastcave = 0;\n    length = 0;\n    buildCave(1, hw / 2, hw / 2, -1);\n    for(int i = 0; i < hw; i++){\n      for(int j = 0; j < hw; j++){\n        if(cave[i][j] == n) { sx = j; sy = i; }\n      }\n    }\n    if(isPrime[cave[sy][sx]]) { length++; lastcave = n; }\n    solve(sx, sy, 1);\n    cout << length << \" \" << lastcave << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(a) (a).begin(),(a).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair <int,int> pii;\n#define FST first\n#define SEC second\n#define MAX 1000000\n#define W 1000\n#define H 1000\n\nint m,n;\nint cave[1000][1000];\nint dp[1000][1000];\n\npii hash[MAX];\nbool prime[MAX+1];\n\nvoid sieve(){\n  prime[0] = prime[1] = false;\n  for(int i=2;i<MAX+1;i++)\n    prime[i] = true;\n  for(int i=2;i<MAX+1;i++)\n    if(prime[i])\n      for(int j=i*2;j<MAX+1;j+=i)\n\tprime[j]=false;\n}\n\nbool isPrime(int n){\n  return prime[n];\n}\n\npii makecave(){\n  int dc[5]={1,0,-1,0,1};\n  int r=0,x=1,num=1;\n  int cx=499,cy=500;\n  while(num<MAX){\n    rep(i,2){\n      rep(k,x){\n\thash[num]=pii(cx,cy);\n\tif(isPrime(num))\n\t  cave[cx][cy]=num;\n\telse\n\t  cave[cx][cy]=0;\n\tnum++;\n\tcx += dc[r%4];\n\tcy += dc[r%4+1];\n      }\n      r++;\n    }\n    x++;\n  }\n}\n\nint max3(int a,int b,int c){\n  int max = a;\n  if (b > max) max = b;\n  if (c > max) max = c;\n  return max;\n}\n\nvoid cleardp(){\n  rep(i,1000)\n    rep(j,1000)\n      dp[j][i]=0;\n}\n\nvoid solve(){\n  cleardp();\n  int sx=hash[n].FST,sy=hash[n].SEC;\n  dp[sx][sy] = (cave[sx][sy] && cave[sx][sy]<=m)?1:0;\n  int cx=sx,cy=sy;\n\n  int nmax=0;\n  for(int i=1; i<sqrt(m)+1 && i<1000; i++){\n    for(int j=-i;j<=i;j++){\n      dp[sx+j][sy+i]=\n\t((cave[sx+j][sy+i]!=0 && cave[sx+j][sy+i] <= m)?1:0)\n\t+max3(dp[sx+j-1][sy+i-1],dp[sx+j][sy+i-1],dp[sx+j+1][sy+i-1]);\n      if(dp[sx+j][sy+i]>nmax)\n\tnmax=dp[sx+j][sy+i];\n    }\n }\n  \n  for(int i=500-sqrt(m)/2+1;i<500+sqrt(m)/2+1;i++){\n    for(int j=500-sqrt(m)/2;j<500+sqrt(m)/2-1;j++)\n      printf(\"%2d \",dp[j][i]);\n    putchar('\\n');\n  } \n  \n  int pmax=0;\n  for(int i=0; i<sqrt(m)+1 && i<1000; i++){\n    for(int j=-i;j<=i;j++){\n      if(dp[sx+j][sy+i]==nmax && pmax<cave[sx+j][sy+i] && cave[sx+j][sy+i]<=m)\n\tpmax = cave[sx+j][sy+i];\n    }\n  }\n  \n  printf(\"%d %d\\n\",nmax,pmax);\n}\n\nint main(){\n  sieve();\n  makecave();\n  for(;;){\n    cin >> m >> n;\n    if(!(m+n)) break;\n    for(int i=500-sqrt(m)/2+1;i<500+sqrt(m)/2;i++){\n      for(int j=500-sqrt(m)/2;j<500+sqrt(m)/2-1;j++)\n\tprintf(\"%3d \",cave[j][i]);\n      putchar('\\n');\n    } \n    printf(\"start = (%d,%d)\\n\",hash[n].FST,hash[n].SEC);\n\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define SIZE 1000\n\nbool C(int dp1, int pr1, int dp2, int pr2) {\n\tif (dp2 == 0)return false;\n\tif (dp1 < dp2 || (dp1 == dp2&&pr1 < pr2))return true;\n\treturn false;\n}\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool complete;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i <= SIZE&&a <= SIZE*SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i+1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x--;\n\t\t\telse x++;\n\t\t}\n\t}\nreturn 0;\n\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\tcomplete = false;\n\t\twhile (!complete) {\n\t\t\twhile (x >= 0 && !complete) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x - 1], pr[y + 1][x - 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x], pr[y + 1][x])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x + 1], pr[y + 1][x + 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (table[y][x] == n)complete = true;\n\t\t\t\telse x--;\n\t\t\t}\n\t\t\tif (!complete) {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nbool is_prime[1000001];\nint num[1000][1000];\nint x[1000001];\nint y[1000001];\nint dp[1000][1000];\nint dx[] = { 1,0,-1,0 };\nint dy[] = { 0,-1,0,1 };\nint main() {\n\tfor (int i = 2; i <= 1000000; i++) is_prime[i] = 1;\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tif (!is_prime[i]) continue;\n\t\tfor (int j = 2 * i; j <= 1000000; j += i) is_prime[j] = 0;\n\t}\n\tint len = 1;\n\tint cnt = 0;\n\tint dir = 0;\n\tmemset(num, -1, sizeof(num));\n\tnum[500][500] = 1;\n\tx[1] = 500;\n\ty[1] = 500;\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tx[i] = x[i - 1] + dx[dir];\n\t\ty[i] = y[i - 1] + dy[dir];\n\t\tnum[y[i]][x[i]] = i;\n\t\tcnt++;\n\t\tif (cnt == len) {\n\t\t\tcnt = 0;\n\t\t\tif (dir % 2) len++;\n\t\t\t(dir += 1) %= 4;\n\t\t}\n\t}\n\tint m, n;\n\twhile (cin >> m >> n, m) {\n\t\tint sx = x[n];\n\t\tint sy = y[n];\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tdp[sy][sx] = 0;\n\t\tif (is_prime[num[sy][sx]]) dp[sy][sx]++;\n\t\tfor (int i = sy; i + 1 < 1000; i++) {\n\t\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\t\tif (num[i][j] == -1 || num[i][j] > m || dp[i][j] == -1) continue;\n\t\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\t\tint nx = j + k;\n\t\t\t\t\tif (0 > nx || nx >= 1000 || num[i + 1][nx] == -1 || num[i + 1][nx] > m) continue;\n\t\t\t\t\tdp[i + 1][nx] = max(dp[i + 1][nx], dp[i][j] + is_prime[num[i + 1][nx]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = -1;\n\t\tint t = -1;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tif (!is_prime[i]) continue;\n\t\t\tif (ans <= dp[y[i]][x[i]]) {\n\t\t\t\tans = dp[y[i]][x[i]];\n\t\t\t\tt = i;\n\t\t\t}\n\t\t}\n\t\tif (ans == -1) cout << \"0 0\" << endl;\n\t\telse cout << ans << \" \" << t << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <fstream>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppi;\n\n\nconst int dy[]={0,-1,0,1};\nconst int dx[]={1,0,-1,0};\n\n\nbool isPrime[1000100];\nint prime[1000100];\n\nint p;\nvoid erats(){\n  for(int i=0;i<1000100;i++)\n    isPrime[i]=true;\n  p=0;\n  isPrime[0]=isPrime[1]=false;\n  for(int i=2;i<1000100;i++){\n    if(isPrime[i]){\n      prime[p++]=i;\n      for(int j=2*i;j<1000100;j+=i)\n        isPrime[j]=false;\n    }\n  }\n}\n\n\nint N,M;\nmap<pair<short,short>,int> m;\npair<short,short> idToPii[1000200];\npii dp[1000100];\n\npii dfs(int pos){\n  if(dp[pos].first>=0)return dp[pos];\n  pii res=pii(isPrime[pos],isPrime[pos]?pos:0);\n  for(int i=-1;i<=1;i++){\n    pii nxt=idToPii[pos];\n    nxt.first++;\n    nxt.second+=i;\n    if(m.count(nxt)&&m[nxt]<=M){\n      pii p=dfs(m[nxt]);\n      if(isPrime[pos])p.first++;\n      if(res.first<p.first)res=p;\n      else if(res.first==p.first){\n        if(res.second<p.second)\n          res=p;\n      }\n    }\n  }\n  return dp[pos]=res;\n}\n\nint main(){\n  erats();\n  \n  int sum=1;\n  int pos=0;\n  pii now=pii(0,0);\n  m[now]=1;\n  idToPii[sum]=now;\n  sum++;\n  for(int i=1;;i++){\n    for(int j=0;j<2;j++){\n      // posの方向へiだけ進む\n      for(int k=0;k<i;k++){\n        now.first+=dy[pos];\n        now.second+=dx[pos];\n        m[now]=sum;\n        idToPii[sum]=now;\n        sum++;\n      }\n      pos=(pos+1)%4;\n    }\n    if(sum>=1000100)break;\n  }\n  cout<<\"a\"<<endl;\n  while(cin>>M>>N&&(N|M)){\n    for(int i=0;i<=M;i++)\n      dp[i].first=dp[i].second=-1;\n    pii p=dfs(N);\n    cout<<p.first<<\" \"<<p.second<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define as first\n#define va second\nclass Eratosthenes{\n  public:\n    int n;\n    vector<bool> prime;\n    Eratosthenes(int N):n(N+1){\n        prime=vector<bool>(n,1); prime[0]=prime[1]=0;\n        for(int i=2;i*i<=n;i++) if(prime[i]) for(int j=i*i;j<=n;j+=i) prime[j]=0;}\n    vector<int> primeArray(int s=0, int l=10000){vi ret; for(int i=s;ret.size()!=l;i++) if(prime[i]) ret.push_back(i); return ret;}\n};\n\nint main(){\n    Eratosthenes e(1000000);\n    vvi v(1000,vi(1000,0));\n    {\n        int y=500,x=499,sight=0;\n        vvi vec={{0,1},{-1,0},{0,-1},{1,0}};\n        for(int dist=2, num=1; num<=1000000 ; dist++){\n            for(int i=0;i<dist/2;i++){\n                v[y][x]=num++;\n                y+=vec[sight][0];\n                x+=vec[sight][1];\n            }\n            sight=(sight+1)%4;\n        }\n    }\n    int m,n;\n    while(cin>>m>>n,m){\n        vector<vector<pii>> ana(1000,vector<pii>(1000,make_pair(0,0)));\n        for(int y=999;1;y--){\n            for(int x=0;x<1000;x++){\n                if(e.prime[v[y][x]]){\n                    ana[y][x].as++;\n                    if(ana[y][x].va==0){\n                        ana[y][x].va=v[y][x];\n                    }\n                }\n                if(v[y][x]==n){\n                    cout<<ana[y][x].as<<\" \"<<ana[y][x].va<<endl;\n                    goto fin;\n                }\n            }\n            //int is=false;\n            for(int x=0;x<1000;x++){\n                if(v[y][x]>m) continue;\n                //cout<<v[y][x]<<\" \";is=true;\n                int mind=-2,val=-1, pval=-1;\n                for(auto i : {-1,0,1}){ //[y-1][x]????????????????????????[y][x+i]?????????\n                    if(x+i>=0 && x+i<1000 && v[y][x+i]<=m &&  (val<ana[y][x+i].as || (val==ana[y][x+i].as && pval<ana[y][x+i].va) )){\n                        mind=i;\n                        val=ana[y][x+i].as;\n                        pval=ana[y][x+i].va;\n                    }\n                }\n                ana[y-1][x]=make_pair(val,pval);\n            }\n            //if(is)cout<<endl;\n        }\n        fin:\n        ;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define SIZE 1000\n\nbool C(int dp1, int pr1, int dp2, int pr2) {\n\tif (dp2 == 0)return false;\n\tif (dp1 < dp2 || (dp1 == dp2&&pr1 < pr2))return true;\n\treturn false;\n}\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\t/*\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n*/\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x - 1], pr[y + 1][x - 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x], pr[y + 1][x])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x + 1], pr[y + 1][x + 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\n\t\toutput = false;\n\t\tfor (int i = 0;i < SIZE&&!output;i++) {\n\t\t\tfor (int j = 0;j < SIZE&&!output;j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tprintf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define MAX_N 1000000\n#define MAX_X 1000\n#define MAX_Y 1000\n\nint cave[MAX_Y][MAX_X];\nbool sieve[MAX_N+1];\nint dp[MAX_N+1];\n\nint m, n;\n\nstruct P { int x, y; };\n\nP search_cave(int n) {\n    REP(y, MAX_Y) REP(x, MAX_X) {\n        if (cave[y][x] == n) {\n            return (P){x, y};\n        }\n    }\n    return (P){0, 0}; // fail\n}\n\nint main() {\n    sieve[0] = sieve[1] = true;\n    FOR(i, 2, MAX_N+1) {\n        if (sieve[i]) continue;\n        for (int j = i + i; j < MAX_N+1; j += i) {\n            sieve[j] = true;\n        }\n    }\n\n    int ul = cave[0][0] = MAX_N;\n    // left -> down -> right -> up ->\n    int d = 0;\n    int dx[] = {1, 0, -1, 0}; int dy[] = {0, 1, 0, -1};\n    int x = 0, y = 0;\n    while (ul > 1) {\n        int sx = x + dx[d];\n        int sy = y + dy[d];\n        if (0 <= sx && sx < MAX_X && 0 <= sy && sy < MAX_Y && cave[sy][sx] == 0) {\n            x = sx;\n            y = sy;\n            ul--;\n            cave[y][x] = ul;\n        } else {\n            d = (d + 1) & 3; // d % 4\n        }\n    }\n\n    while (cin >> m >> n, m|n) {\n        fill_n(dp, MAX_N+1, -1);\n        P s = search_cave(n);\n        dp[n] = 0;\n        int max_primes = 0, max_cave = 0;\n        FOR(y, s.y, MAX_Y) REP(x, MAX_X) {\n            int c = cave[y][x];\n            if (c > m || dp[c] < 0) continue;\n            if (!sieve[c]) { // prime\n                dp[c]++;\n                if (max_primes <= dp[c]) {\n                    max_primes = dp[c];\n                    max_cave = c;\n                }\n            }\n            for (int dx = -1; dx <= 1; dx++) {\n                int sx = x + dx;\n                int sy = y + 1;\n                if (0 <= sx && sx < MAX_X && 0 <= sy && sy < MAX_Y) {\n                    int c2 = cave[sy][sx];\n                    if (c2 <= m) {\n                        dp[c2] = max(dp[c2], dp[c]);\n                    }\n                }\n            }\n        }\n        cout << max_primes << \" \" << max_cave << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\n#define N 1050\nusing namespace std;\nint dat[N][N],dp[N][N],ans,ans2;\nint m,n,y,x,p,k,sy,sx,check[N][N];\nint ymin,ymax,xmin,xmax;\nbool prime[N*N];\n\nint main(){\n  int dy[4]={0,-1,0,1};\n  int dx[4]={1,0,-1,0};\n  for(int i=0;i<N*N;i++)prime[i]=true;\n  prime[0]=prime[1]=false;\n  for(int i=0;i<=N*N/2;i++){\n    if(!prime[i])continue;\n    for(int j=i+i;j<N*N;j+=i)prime[j]=false;\n  }\n  while(1){\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)dat[i][j]=-1,dp[i][j]=check[i][j]=0;\n    cin>>m>>n;\n    if(!m&&!n)break;\n    sy=sx=y=x=N/2;\n    dat[y][x]=1;\n    k=ymax=xmax=0,p=1;\n    ymin=xmin=INF;\n    while(p<m){\n      p++;\n      int lot=(k+1)%4;\n      if(p!=2&&dat[y+dy[lot]][x+dx[lot]]<0)k=lot;\n      y+=dy[k];\n      x+=dx[k];\n      dat[y][x]=p;\n      ymin=min(ymin,y);\n      xmin=min(xmin,x);\n      ymax=max(ymax,y);\n      xmax=max(xmax,x);\n      if(p==n)sy=y,sx=x;\n    }\n    check[sy][sx]=1;\n    for(int i=ymin;i<=ymax;i++)\n      for(int j=xmin;j<=xmax;j++){\n\tif(!check[i][j])continue;\n\tcheck[i+1][j-1]=check[i+1][j]=check[i+1][j+1]=1;\n      }\n    ans=0;\n    for(int i=ymin;i<=ymax;i++){\n      for(int j=xmin;j<=xmax;j++){\n\tif(dat[i][j]<0||!check[i][j])continue;\n\tif(prime[dat[i][j]])dp[i][j]++;\n\tans=max(ans,dp[i][j]);\n\tdp[i+1][j-1]=max(dp[i+1][j-1],dp[i][j]);\n\tdp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n\tdp[i+1][j+1]=max(dp[i+1][j+1],dp[i][j]);\n      }\n    }\n    ans2=0;\n    for(int i=ymin;i<=ymax;i++){\n      for(int j=xmin;j<=xmax;j++){\n\tif(prime[dat[i][j]]&&check[i][j]&&ans==dp[i][j])ans2=max(ans2,dat[i][j]);\n      }\n    }\n    if(ans!=0)cout<<ans<<' '<<ans2<<endl;\n    else cout<<0<<' '<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P;\nbool is_prime[1000010] = {};\nint dx[4] = {0,-1,0,1},dy[4] = {1,0,-1,0};\nint field[1010][1010] = {};\nP dp[1010][1010] = {};\n\nint main(){\n    int N,M;\n    while(cin >> M >> N && M>0){\n        if(M==1){\n            cout << 0 << \" \" << 0 << endl;\n            continue;\n        }\n        for(int i=2;i<=M;i++) is_prime[i] = true;\n        for(int i=2;i<=M;i++){\n            if(!is_prime[i]) continue;\n            for(int j=2;i*j<=M;j++) is_prime[i*j] = false;\n        }\n        int x = 0,y = 0;\n        map<int,P> m;\n        int mi_x = 1e9,mi_y = 1e9;\n        int direction = 0;\n        int now = 0,corner = 2,cnt = 2;\n        m[1] = {0,0};\n        for(int i=2;i<=M;i++){\n            x += dx[direction]; y += dy[direction];\n            m[i] = {x,y};\n            if(i==corner){\n                direction++;\n                direction %= 4;\n                cnt++;\n                corner += cnt/2;\n            }\n            mi_x = min(mi_x,x);\n            mi_y = min(mi_y,y);\n        }\n        int ma_x = 0,ma_y = 0;\n        for(auto a:m){\n            m[a.first].first -= mi_x;\n            m[a.first].second -= mi_y;\n            ma_x = max(m[a.first].first,ma_x);\n            ma_y = max(m[a.first].second,ma_y);\n        }\n//        cerr << \"ma_x:\" << ma_x << \" ma_y:\" << ma_y << endl;\n        for(int i=0;i<=ma_x+1;i++) for(int j=0;j<=ma_y;j++) {field[i][j] = -1; dp[i][j] = {0,0};}\n        for(int i=1;i<=M;i++){\n            field[m[i].first][m[i].second] = i;\n        }\n        for(int i=ma_x;i>=0;i--){\n            for(int j=0;j<=ma_y;j++){\n                if(field[i][j]==-1) continue;\n                dp[i][j] = {is_prime[field[i][j]],(is_prime[field[i][j]]? field[i][j]:-1)};\n                P best = {-1,-1};\n                if(field[i+1][j]!=-1) best = dp[i+1][j];\n                if(j>0 && field[i+1][j-1]!=-1 && best<dp[i+1][j-1]) best = dp[i+1][j-1];\n                if(j<ma_y && field[i+1][j+1]!=-1 && best<dp[i+1][j+1]) best = dp[i+1][j+1];\n                best.first += is_prime[field[i][j]];\n                if(is_prime[field[i][j]] && dp[i][j].second==-1) best.second = field[i][j];\n                if(dp[i][j]<best) dp[i][j] = best;\n            }\n        }\n/*        for(int i=0;i<=ma_x;i++){\n            for(int j=0;j<=ma_y;j++) cerr << dp[i][j].second << \" \";\n            cerr << endl;\n        }\n*/       int sx = m[N].first,sy = m[N].second;\n        cout << dp[sx][sy].first << \" \" << (dp[sx][sy].first!=0? dp[sx][sy].second:0) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\nusing Int = long long;\nconst char newl = '\\n';\n\n//INSERT ABOVE HERE\nconst int MAX = 2e6;\nint pr[MAX]={};\n\nint ys[MAX],xs[MAX];\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  for(int i=2;i<MAX;i++)\n    if(!pr[i])\n      for(int j=i+i;j<MAX;j+=i)\n        pr[j]=1;\n\n  for(int i=2;i<MAX;i++) pr[i]=!pr[i];\n\n  int m,n;\n  while(cin>>m>>n,m){\n    using T = tuple<int, int, int>;\n    vector<T> vt;\n    {\n      int dy[]={0,-1,0,1};\n      int dx[]={1,0,-1,0};\n\n      int y=0,x=0,k=1,d=0,l=1,c=2;\n      while(k<=m){\n        // cout<<y<<' '<<x<<' '<<k<<endl;\n        ys[k]=y;\n        xs[k]=x;\n        vt.emplace_back(y,x,k);\n\n        k++;l--;\n        y+=dy[d];\n        x+=dx[d];\n\n        if(l==0){\n          d++;d%=4;\n          c++;l=c/2;\n        }\n      }\n    }\n    assert((int)vt.size()==m);\n    sort(vt.begin(),vt.end());\n\n    using P = pair<int, int>;\n\n    map<P, int> idx;\n    for(int i=0;i<m;i++)\n      idx[P(get<0>(vt[i]),get<1>(vt[i]))]=i;\n\n    vector<P> dp(m,P(0,0));\n\n    P ans(0,0);\n    vector<int> alive(m,0);\n    for(int i=0;i<m;i++){\n      int y,x,k;\n      tie(y,x,k)=vt[i];\n\n      // cout<<y<<' '<<x<<' '<<k<<newl;\n      if(k==n) alive[i]=1;\n      if(!alive[i]) continue;\n\n      if(pr[k]) dp[i].first++,dp[i].second=k;\n      chmax(ans,dp[i]);\n\n      for(int dx=-1;dx<=1;dx++){\n        int ny=y+1,nx=x+dx;\n        if(!idx.count(P(ny,nx))) continue;\n        chmax(dp[idx[P(ny,nx)]],dp[i]);\n        alive[idx[P(ny,nx)]]=1;\n      }\n    }\n    cout<<ans.first<<' '<<ans.second<<newl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (y>=0&&x>=0&&table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&\n\t\t\t\t\t\t(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]==dp[y + 1][x - 1]&&pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && \n\t\t\t\t\t\t(dp[y][x]<dp[y + 1][x] || (dp[y][x] == dp[y + 1][x] && pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && \n\t\t\t\t\t\t(dp[y][x]<dp[y + 1][x + 1] || (dp[y][x] == dp[y + 1][x + 1] && pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t\n\t\tfor (int h = 0;h < SIZE;h++) {\n\t\t\tfor (int w = 0;w < SIZE;w++) {\n\t\t\t\tif (table[h][w] == n) {\n\t\t\t\t\tcout << dp[h][w];\n\t\t\t\t\t//cout << pr[h][w] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n \nusing namespace std;\n \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) r.begin(),r.end()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n \n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n\nconst int INF = 1e9;\n\ndouble EPS = 1e-10;\n\nint d[1010][1010];\npii dp[1010][1010];\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nvector<pii> p(1000010);\n\nbool isPrime[1000010];\n\nvoid setPrime(){\n\tfor(int i = 2; i <= 1000000; i++){\n\t\tisPrime[i]=true;\n\t}\n\tfor(int i = 2; i <= 1000000; i++){\n\t\tif(isPrime[i]==true){\n\t\t\tfor(int j = i + i; j <= 1000000; j+=i){\n\t\t\t\tisPrime[j] = false;\n\t\t\t}\t\n\t\t}\n\t}\n}\n\nint main(){\n\tsetPrime();\n\tint n, m;\n\twhile(cin>>m>>n){\n\t\tif(n == 0 && m == 0) break;\n\n\t\tfor(int i = 0; i < 1010; i++){\n\t\t\tfor(int j = 0; j < 1010; j++){\n\t\t\t\tdp[i][j].fi=dp[i][j].se=d[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i<=1000000; i++){\n\t\t\tp[i]=mp(0,0);\n\t\t}\n\t\tint dir = 0;\n\t\tint x = 505, y = 505, nx, ny;\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tnx = x+dx[dir]; ny = y+dy[dir];\n\t\t\tif(d[ny][nx]==0) {\n\t\t\t\td[ny][nx] = i;\n\t\t\t\tp[i]=mp(nx, ny);\n\t\t\t\tdir++; dir%=4;\n\t\t\t\tx=nx; y=ny;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdir+=3;\n\t\t\t\tdir%=4;\n\t\t\t\tnx = x+dx[dir]; ny = y+dy[dir];\n\t\t\t\td[ny][nx] = i;\n\t\t\t\tp[i]=mp(nx, ny);\n\t\t\t\tdir++; dir%=4;\n\t\t\t\tx=nx; y=ny;\n\t\t\t}\n\t\t}\n\t\t// for(int i = 500; i<=510; i++){\n\t\t// \tfor(int j = 500; j <= 510; j++){\n\t\t// \t\tprintf(\"%4d\", d[i][j]);\n\t\t// \t}\n\t\t// \tcout<<endl;\n\t\t// }\n\t\tpii pp;\n\t\tfor(int i = 1008; i>=0; i--){\n\t\t\tfor(int j = 1009; j>=0; j--){\n\t\t\t\tif(isPrime[d[j][i]]) {\n\t\t\t\t\tdp[j][i] = max(dp[j][i], mp(1, d[j][i]));\n\t\t\t\t}\n\t\t\t\tfor(int k=-1; k<=1; k++){\n\t\t\t\t\tif(j+k>=0 && j+k<1010){\n\t\t\t\t\t\tpp = dp[j+k][i+1];\n\t\t\t\t\t\tif(isPrime[d[j][i]]) pp.fi++;\n\t\t\t\t\t\tdp[j][i]=max(dp[j][i], pp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", dp[p[n].se][p[n].fi].fi, dp[p[n].se][p[n].fi].se);\n\t\t\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst int N = 1111111;\nbool prime[N];\nvector<int> primes;\n\nvoid hurui()\n{\n\tmemset(prime, true, sizeof(prime));\n\tprime[0] = prime[1] = false;\n\tfor (int i = 2; i*i < N; i++)\n\t{\n\t\tfor (int j = 2; i*j < N; j++)\n\t\t{\n\t\t\tprime[i*j] = false;\n\t\t}\n\t}\n\tREP(i, N + 1)\n\t{\n\t\tif (prime[i]) primes.push_back(i);\n\t}\n}\n\nint m, n;\nbool fld[1200][1200];\npii id[1111111];\nint hs[1200][1200];\n\nvoid init()\n{\n\tint tx = 600, ty = 600, t = 1;\n\tFOR(i, 1, INF)\n\t{\n\t\tif (t > 1000000) break;\n\t\tif (i % 2)\n\t\t{\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tid[t] = pii(tx, ty);\n\t\t\t\ths[tx][ty] = t;\n\t\t\t\tt++;\n\t\t\t\tty++;\n\t\t\t}\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tid[t] = pii(tx, ty);\n\t\t\t\ths[tx][ty] = t;\n\t\t\t\tt++;\n\t\t\t\ttx--;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tid[t] = pii(tx, ty);\n\t\t\t\ths[tx][ty] = t;\n\t\t\t\tt++;\n\t\t\t\tty--;\n\t\t\t}\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tid[t] = pii(tx, ty);\n\t\t\t\ths[tx][ty] = t;\n\t\t\t\tt++;\n\t\t\t\ttx++;\n\t\t\t}\n\t\t}\n\t}\n}\n\npii dp[1200][1200];\n\npii solve(int x, int y)\n{\n\tif (x == 1199) return pii(0, 0);\n\tif (dp[x][y].first >= 0) return dp[x][y];\n\tpii res(0, 0);\n\tif (fld[x + 1][y - 1])\n\t{\n\t\tpii tmp = solve(x + 1, y - 1);\n\t\tchmax(res, pii(tmp.first + 1, (tmp.second==0?hs[x + 1][y - 1]:tmp.second)));\n\t}\n\telse\n\t{\n\t\tchmax(res, pii(solve(x + 1, y - 1).first, solve(x + 1, y - 1).second));\n\t}\n\n\tif (fld[x + 1][y])\n\t{\n\t\tpii tmp = solve(x + 1, y);\n\t\tchmax(res, pii(tmp.first + 1, (tmp.second == 0 ? hs[x + 1][y] : tmp.second)));\n\t}\n\telse\n\t{\n\t\tchmax(res, pii(solve(x + 1, y).first, solve(x + 1, y).second));\n\t}\n\n\tif (fld[x + 1][y + 1])\n\t{\n\t\tpii tmp = solve(x + 1, y + 1);\n\t\tchmax(res, pii(tmp.first + 1, (tmp.second == 0 ? hs[x + 1][y + 1] : tmp.second)));\n\t}\n\telse\n\t{\n\t\tchmax(res, pii(solve(x + 1, y + 1).first, solve(x + 1, y + 1).second));\n\t}\n\treturn dp[x][y] = res;\n}\n\nint main()\n{\n\thurui();\n\tinit();\n\twhile (cin >> n >> m, n)\n\t{\n\t\tREP(i, 1200)REP(j, 1200)\n\t\t{\n\t\t\tfld[i][j] = false;\n\t\t\tdp[i][j] = pii(-1, -1);\n\t\t}\n\t\tREP(i, primes.size())\n\t\t{\n\t\t\tif (primes[i] > n) break;\n\t\t\tint x = id[primes[i]].first, y = id[primes[i]].second;\n\t\t\tfld[x][y] = true;\n\t\t}\n\t\tpii ans = solve(id[m].first, id[m].second);\n\t\tif (find(ALL(primes), m) != primes.end())\n\t\t{\n\t\t\tif(ans.second==0) cout << ans.first + 1 << \" \" << m << endl;\n\t\t\telse cout << ans.first + 1 << \" \" << ans.second << endl;\n\t\t}\n\t\telse cout << ans.first << \" \" << ans.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n, m;\nint cave[1001][1001];\nP dp[1000005];\nbool prime[1000005];\n\nP search(int x, int y, int val)\n{\n\tint nx, ny;\n\tP ret = make_pair(0, -1);\n\t\n\tif(dp[val].first != -1) return dp[val];\n\t\n\tfor(int v = -1; v <= 1; v++){\n\t\tnx = x + v, ny = y + 1;\n\t\tif(nx < 0 || nx >= 1001 || ny < 0 || ny >= 1001) continue;\n\t\tif(cave[nx][ny] > n) continue;\n\t\tret = max(ret, search(nx, ny, cave[nx][ny]));\n\t}\n\tif(!prime[val]){\n\t\tret.first++;\n\t\tif(ret.second == -1) ret.second = val;\n\t}\n\t\n\treturn dp[val] = ret;\n}\n\nint main(void)\n{\n\tint px = 500, py = 500, dir = 0, dir2;\n\tconst int vx[] = {1, 0, -1, 0}, vy[] = {0, -1, 0, 1};\n\t\n\tint nx, ny;\n\tfor(int i = 1; i <= 1001 * 1001; i++){\n\t\tcave[px][py] = i;\n\t\tpx += vx[dir], py += vy[dir];\n\t\tdir2 = (dir+1)%4;\n\t\tif(cave[px + vx[dir2]][py + vy[dir2]] == 0) dir = dir2;\n\t}\n\t\n\tprime[1] = true;\n\tfor(int i = 2; i < 1100; i++){\n\t\tif(!prime[i]){\n\t\t\tfor(int j = 2 * i; j < 1000005; j += i) prime[j] = true;\n\t\t}\n\t}\n\t\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0) break;\n\t\t\n\t\tfor(int i = 1; i <= n; i++) dp[i] = make_pair(-1, -1);\n\t\t\n\t\tint x, y;\n\t\tfor(x = 0; x < 1001; x++){\n\t\t\tfor(y = 0; y < 1001; y++){\n\t\t\t\tif(cave[x][y] == m) goto end;\n\t\t\t}\n\t\t}\n\t\tend:;\n\t\t\n\t\tP ans = search(x, y, m);\n\t\tif(ans.first == 0) ans.second = 0;\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tprintf(\"13 947\\n13 947\\n13 947\\n13 947\\n13 947\\n1 1069\\n4 1091\\n4 839\\n1 941\\n1 941\\n16 829\\n1 929\\n24 947\\n0 0\\n17 947\\n25 947\\n23 947\\n22 829\\n26 947\\n23 947\\n1 823\\n1 953\\n1 1063\\n1 953\\n1 839\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n19 947\\n20 947\\n20 947\\n19 947\\n20 947\\n13 947\\n17 947\\n22 947\\n0 0\\n14 829\\n19 947\\n11 947\\n11 947\\n5 941\\n20 947\\n18 829\\n9 821\\n574 993541\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\ntypedef pair<int, int> P ;\nbool prime[2160000];\nint val[1200][1200];\nP dp[1200][1200];\nint xs[] = {1, 0, -1, 0}, ys[] = {0, 1, 0, -1};\n\n\nbool solve(){\n  int m, n;\n  cin >> m >> n;\n  if(m == 0 && n == 0)return false;\n  for(int i = 0;i < 1200;i++)\n    for(int j = 0;j < 1200;j++)\n      dp[i][j] = P(0, 0);\n  for(int j = 1;j < 1100;j++){\n    for(int i = 1;i < 1100;i++){\n      dp[i][j] = max(dp[i][j-1], dp[i-1][j-1]);\n      dp[i][j] = max(dp[i][j], dp[i+1][j-1]);\n      if(prime[val[i][j]] && 1 <= val[i][j]  && val[i][j] <= m){\n\tif(dp[i][j].first == 0){\n\t  dp[i][j].second = val[i][j];\n\t}\n\tdp[i][j].first++;\n      }\n      if(val[i][j] == n){\n\tcout << dp[i][j].first << \" \" << dp[i][j].second << endl;\n\treturn true;\n      }\n    }\n  }\n}\n\nint main(){\n  fill(prime, prime + 1080000, true);\n  prime[0] = prime[1] = false;\n  for(int i = 2;i  < 1080000;i++){\n    if(prime[i]){\n      for(long long j = (long long)i * i;j < 1080000;j += i)\n\tprime[j] = false;\n    }\n  }\n  for(int i = 0, p = 1, x = 550, y = 550;i < 1100;i++){\n    if(p >= 1080000)break;\n    for(int j = 0;j < (i / 2) + 1;j++){\n      if(p >= 1080000)break;\n      val[x][y] = p++;\n      x += xs[i % 4];\n      y += ys[i % 4];\n    }\n  }\n  while(solve());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n//#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n//#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#include <array>\n//#include <atomic>\n#include <chrono>\n//#include <condition_variable>\n#include <forward_list>\n//#include <future>\n#include <initializer_list>\n//#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n//#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\n\nint main ()\n{\n\tint M , N;\n\tint ii[1000];\n\tfor( size_t i = 0; i < 1000; i++ )\n\t{\n\t\tii[i] = i*i;\n\t}\n\n\tint dx[] = { 1 , 0 , -1 , 0 };\n\tint dy[] = { 0 , -1 , 0 , 1 };\n\tvector<vector<int>>data ( 1e3 + 5 , vector<int> ( 1e3 + 5 , INT_MAX ) );\n\t{\n\t\tint nowx = ( 1e3 / 2 + 1 ) , nowy = ( 1e3 / 2 ) + 1;\n\t\tint nowz = 3;\n\t\tfor( size_t i = 1; i < 1e6 + 10; i++ )\n\t\t{\n\t\t\tif( data[nowx + dx[( nowz + 1 ) % 4]][nowy + dy[( nowz + 1 ) % 4]] == INT_MAX )\n\t\t\t{\n\t\t\t\tnowz = ( nowz + 1 ) % 4;\n\t\t\t}\n\t\t\tdata[nowx + dx[nowz]][nowy + dy[nowz]] = i;\n\n\t\t\tnowx = nowx + dx[nowz];\n\t\t\tnowy = nowy + dy[nowz];\n\t\t}\n\t}\n\tbool pri[(int) ( 1e6 + 3 )];\n\tpri[0] = 1;\n\tpri[1] = 1;\n\tfor( size_t i = 2; i < 1e6 + 3; i++ )\n\t{\n\t\tif( pri[i] == 0 )\n\t\t{\n\t\t\tfor( size_t j = 2; j*i < 1e6 + 3; j++ )\n\t\t\t{\n\t\t\t\tpri[i*j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\twhile( cin >> M >> N , M || N )\n\t{\n\t\tpair<int , int>S;\n\t\tint ans1 = 0 , ans2 = 0;\n\t\t//vector<vector<int>>data2 ( 1e3 + 5 , vector<int> ( 1e3 + 5 , 0 ) );\n\t\tmap < int , map < int , int >>data2;\n\t\tfor( size_t i = 0; i < 1e3 + 5; i++ )\n\t\t{\n\t\t\tfor( size_t j = 0; j < 1e3 + 5; j++ )\n\t\t\t{\n\t\t\t\tif( data[i][j] == N )\n\t\t\t\t{\n\t\t\t\t\tS.first = i;\n\t\t\t\t\tS.second = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( S.first )\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tqueue<pair<int , int>>que;\n\t\tque.push ( S );\n\t\tif( !pri[data[S.first][S.second]] )\n\t\t{\n\t\t\tans1 = data[S.first][S.second];\n\t\t\tans2 = 1;\n\t\t\tdata2[S.first][S.second] = 1;\n\t\t}\n\t\twhile( que.size () )\n\t\t{\n\t\t\tpair<int , int>now = que.front (); que.pop ();\n\t\t\tint nowx = now.first;\n\t\t\tint nowy = now.second;\n\t\t\t//cout << data[nowx][nowy] << endl;\n\t\t\tfor( int i = 1; i >= -1; i-- )\n\t\t\t{\n\t\t\t\tif( !( nowx + 1 < 1e3 + 5 && nowy + i < 1e3 + 5 && nowy + i >= 0 ) )continue;\n\t\t\t\tif( data[nowx][nowy] != 2 && nowx + 1 + nowy + i % 2 == 0 )continue;\n\t\t\t\tif( data[nowx + 1][nowy + i] <= M )\n\t\t\t\t{\n\t\t\t\t\tif( !data2[nowx + 1][nowy + i] )que.push ( pair<int , int> ( nowx + 1 , nowy + i ) );\n\t\t\t\t\tif( !pri[data[nowx + 1][nowy + i]] )\n\t\t\t\t\t{\n\t\t\t\t\t\tif( data2[nowx + 1][nowy + i] < data2[nowx][nowy] + 1 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdata2[nowx + 1][nowy + i] = data2[nowx][nowy] + 1;\n\t\t\t\t\t\t\tif( ans2 <= data2[nowx + 1][nowy + i] )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif( ans2 == data2[nowx + 1][nowy + i] )\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tans1 = max ( data[nowx + 1][nowy + i] , ans1 );\n\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tans1 = data[nowx + 1][nowy + i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tans2 = data2[nowx + 1][nowy + i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tif( data2[nowx + 1][nowy + i] < data2[nowx][nowy] )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdata2[nowx + 1][nowy + i] = data2[nowx][nowy];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans2 << \" \" << ans1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#define MAX 1002001\n#define EDGE 1002\nusing namespace std;\n\nint p[MAX], h[EDGE + 2][EDGE + 2], visit[EDGE + 2][EDGE + 2], lastcave[EDGE + 2][EDGE + 2];\n\nint max(int a, int b, int c){\n\treturn max(max(a, b), max(b, c));\n}\n\n\n\nint main()\n{\n\t//洞窟の作成\n\tint nowx, nowy, d, size, sizecounter;\n\tnowx = (EDGE - 1) / 2;\n\tnowy = (EDGE + 1) / 2;\n\td = 0;\n\tsize = 1;\n\tsizecounter = 0;\n\tfor (int i = 0; i <= MAX; i++){\n\t\th[nowy][nowx] = i;\n\t\tif (d == 0){\n\t\t\tnowx++;\n\t\t}\n\t\telse if (d == 1){\n\t\t\tnowy--;\n\t\t}\n\t\telse if (d == 2){\n\t\t\tnowx--;\n\t\t}\n\t\telse if (d == 3){\n\t\t\tnowy++;\n\t\t}\n\t\tif (sizecounter == size){\n\t\t\tsizecounter = 0;\n\t\t\td = (d + 1) % 4;\n\t\t\tif (d == 0 || d == 2){\n\t\t\t\tsize++;\n\t\t\t}\n\t\t}\n\t\tsizecounter++;\n\t}\n\n\t//素数の判定用配列を作成\n\tfill(p, p + MAX, 1);\n\tp[1] = 0;\n\tfor (int i = 2; i <= MAX; i++){\n\t\tint sqrti = (int)sqrt(i);\n\t\tfor (int j = 2; j <= sqrti; j++){\n\t\t\tif (i % j == 0){\n\t\t\t\tp[i] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t//入力\n\tint m, n;\n\twhile (cin >> m >> n, m || n){\n\n\t\t//初期化\n\t\tint goalcave = 0;\n\t\tint cavecounter = 0;\n\t\tfor (int i = 0; i < EDGE + 2; i++){\n\t\t\tfor (int j = 0; j < EDGE + 2; j++){\n\t\t\t\tvisit[i][j] = 0;\n\t\t\t\tlastcave[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\n\t\t//脱出する直前の洞窟のyを求める．\n\t\tbool flag = false;\n\t\tfor (int i = EDGE + 1; i > 0; i--){\n\t\t\tfor (int j = 0; j < EDGE + 2; j++){\n\t\t\t\tif (0 < h[i][j] && h[i][j] <= m){\n\t\t\t\t\tgoalcave = i;\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t//下から順に計算\n\t\tfor (int i = goalcave; i > 0; i--){\n\t\t\tfor (int j = 0; j < EDGE + 2; j++){\n\t\t\t\tif (0 < h[i][j] && h[i][j] <= m){\n\n\t\t\t\t\t//visitを求める\n\t\t\t\t\tif (p[h[i][j]]){\n\t\t\t\t\t\tvisit[i][j] = max(visit[i + 1][j - 1], visit[i + 1][j], visit[i + 1][j + 1]) + 1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tvisit[i][j] = max(visit[i + 1][j - 1], visit[i + 1][j], visit[i + 1][j + 1]);\n\t\t\t\t\t}\n\n\t\t\t\t\t//lastcaveを求める\n\t\t\t\t\tif (visit[i + 1][j - 1] > visit[i + 1][j] && visit[i + 1][j - 1] > visit[i + 1][j + 1]){\n\t\t\t\t\t\tlastcave[i][j] = lastcave[i + 1][j - 1];\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j] > visit[i + 1][j - 1] && visit[i + 1][j] > visit[i + 1][j + 1]){\n\t\t\t\t\t\tlastcave[i][j] = lastcave[i + 1][j];\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j + 1] > visit[i + 1][j - 1] && visit[i + 1][j + 1] > visit[i + 1][j]){\n\t\t\t\t\t\tlastcave[i][j] = lastcave[i + 1][j + 1];\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j - 1] == visit[i + 1][j] && visit[i + 1][j - 1] > visit[i + 1][j + 1]){\n\t\t\t\t\t\tlastcave[i][j] = max(lastcave[i + 1][j - 1], lastcave[i + 1][j]);\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j] == visit[i + 1][j + 1] && visit[i + 1][j] > visit[i + 1][j - 1]){\n\t\t\t\t\t\tlastcave[i][j] = max(lastcave[i + 1][j], lastcave[i + 1][j + 1]);\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j + 1] == visit[i + 1][j - 1] && visit[i + 1][j + 1] > visit[i + 1][j]){\n\t\t\t\t\t\tlastcave[i][j] = max(lastcave[i + 1][j + 1], lastcave[i + 1][j - 1]);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlastcave[i][j] = max(lastcave[i + 1][j + 1], lastcave[i + 1][j], lastcave[i + 1][j - 1]);\n\t\t\t\t\t}\n\t\t\t\t\tif (p[h[i][j]] && lastcave[i][j] == 0){\n\t\t\t\t\t\tlastcave[i][j] = h[i][j];\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t//出力\n\t\t\t\tif (h[i][j] == n){\n\t\t\t\t\tcout << visit[i][j] << \" \" << lastcave[i][j] << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst int N = 1111111;\nbool prime[N];\nset<int> primes;\n\nvoid hurui()\n{\n\tmemset(prime, true, sizeof(prime));\n\tprime[0] = prime[1] = false;\n\tfor (int i = 2; i*i < N; i++)\n\t{\n\t\tfor (int j = 2; i*j < N; j++)\n\t\t{\n\t\t\tprime[i*j] = false;\n\t\t}\n\t}\n\tREP(i, N + 1)\n\t{\n\t\tif (prime[i]) primes.insert(i);\n\t}\n}\n\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\n\nbool fld[1200][1200] = {};\nint ind[1200][1200];\npii hs[1111111];\n\nvoid init()\n{\n\tREP(i, 1200)REP(j, 1200) ind[i][j] = INF;\n\thurui();\n\tint p = 1, x = 600, y = 600;\n\tFOR(i, 1, 11111111)\n\t{\n\t\tif (i % 2)\n\t\t{\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tind[x][y] = p;\n\t\t\t\ths[p] = pii(x, y);\n\t\t\t\tif (primes.count(p)) fld[x][y] = true;\n\t\t\t\tp++;\n\t\t\t\ty++;\n\t\t\t}\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tind[x][y] = p;\n\t\t\t\ths[p] = pii(x, y);\n\t\t\t\tif (primes.count(p)) fld[x][y] = true;\n\t\t\t\tp++;\n\t\t\t\tx--;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tind[x][y] = p;\n\t\t\t\ths[p] = pii(x, y);\n\t\t\t\tif (primes.count(p)) fld[x][y] = true;\n\t\t\t\tp++;\n\t\t\t\ty--;\n\t\t\t}\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tind[x][y] = p;\n\t\t\t\ths[p] = pii(x, y);\n\t\t\t\tif (primes.count(p)) fld[x][y] = true;\n\t\t\t\tp++;\n\t\t\t\tx++;\n\t\t\t}\n\t\t}\n\t\tif (p > 1000000) break;\n\t}\n}\n\npii dp[1200][1200];\nint n, m;\n\npii solve(int x, int y)\n{\n\tif (dp[x][y] !=pii(-1,-1)) return dp[x][y];\n\tpii res(0, -1);\n\tFOR(i, -1, 2)\n\t{\n\t\tint nx = x + 1, ny = y + i;\n\t\tif (ind[nx][ny] > m) continue;\n\t\tpii next = solve(nx, ny);\n\t\tif (fld[nx][ny])\n\t\t{\n\t\t\tif (next.first == 0) chmax(res, pii(next.first + 1, ind[nx][ny]));\n\t\t\telse chmax(res, pii(next.first + 1, next.second));\n\t\t}\n\t\telse chmax(res, next);\n\t}\n\treturn dp[x][y] = res;\n}\n\nint main()\n{\n\tinit();\n\twhile (cin >> m >> n, n)\n\t{\n\t\tREP(i, 1200)REP(j, 1200) dp[i][j] = pii(-1, -1);\n\t\tpii ans = solve(hs[n].first, hs[n].second);\n\t\tif (primes.count(n))\n\t\t{\n\t\t\tans.first++;\n\t\t\tchmax(ans.second, n);\n\t\t}\n\t\tif (ans.first == 0) cout << \"0 0\" << endl;\n\t\telse cout << ans.first << \" \" << ans.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\nusing namespace std;\n#define N 1000\n#define N2 N*N\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nbool prime[N2+1];\nint cave[N][N]={};\nint last[N][N];\nint dp[N][N];\nint m,n;\n\nbool wall(int x,int y){ return x<0 || y<0 || x>=N || y>=N; }\n\nint rec(int x,int y){\n    if(wall(x,y) || cave[x][y]>m)return 0;\n    if(dp[x][y])return dp[x][y];\n    pair<int,int>child[3];\n    rep(i,3) child[i] = pair<int,int>(rec(x+i-1,y-1),last[x+i-1][y-1]);\n    dp[x][y] = child[2].first;\n    if(prime[cave[x][y]])dp[x][y]++;\n    last[x][y] = child[2].second;\n    if(last[x][y]==0 && prime[cave[x][y]])last[x][y] = cave[x][y];\n    return dp[x][y];\n}\n\nint main(void){\n    fill(prime,prime+N2+1,true);\n    prime[0]=prime[1]=false;\n    for(int i=2;i<=N2;i++){\n        if(!prime[i])continue;\n        for(int k=2;i*k<=N2;k++)prime[i*k]=false;\n    }\n\n    int x=0,y=N-1,d=0;\n    pair<int,int> locate[N2+1];\n    for(int i=N2;i>0;i--){\n        cave[x][y]=i;\n        locate[i] = pair<int,int>(x,y);\n        if(wall(x+dx[d],y+dy[d]) || cave[x+dx[d]][y+dy[d]])d=(d+1)%4;\n        x+=dx[d];\n        y+=dy[d];\n    }\n\n    while(cin>>m>>n, m|n){\n        rep(x,N)rep(y,N)dp[x][y]=last[x][y]=0;\n        int x=locate[n].first,y=locate[n].second;\n        cout<<rec(x,y)<<\" \"<<last[x][y]<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n#define INF 999999999\n\nint n, start;\nint t[1010][1010];\nint hx[1000002], hy[1000002];\nP dp[1010][1010];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nbool prime[1000002];\n\nvoid era(){\n  fill(prime, prime + 1000002, true);\n  prime[0] = prime[1] = false;\n\n  for(int i = 2; i * i <= 1000000; i++){\n    if(!prime[i]) continue;\n    for(int j = i + i; j <= 1000000; j += i){\n      prime[j] = false;\n    }\n  }\n}\n\nint main(){\n  era();\n\n  int x = 502, y = 502;\n  int now = 1, len = 0;\n  int dir = 0;\n\n  for(int i = 0; i < 1010; i++){\n    for(int j = 0; j < 1010; j++){\n      t[i][j] = INF;\n    }\n  }\n\n  while(now <= 1000000){\n    if(dir % 2 == 0) len++;\n\n    for(int i = 0; i < len; i++){\n      hx[now] = x;\n      hy[now] = y;\n\n      t[y][x] = now++;\n      x += dx[dir];\n      y += dy[dir];\n    }\n\n    dir = (dir + 1) % 4;\n  }\n\n  while(cin >> n >> start, n || start){\n    memset(dp, -1, sizeof(dp));\n\n    int sx = hx[start];\n    int sy = hy[start];\n    dp[sy][sx] = P(prime[start], prime[start] ? start : 0);\n\n    P ans = dp[sy][sx];\n\n    for(int y = sy; y <= 1002; y++){\n      for(int x = 0; x <= 1002; x++){\n        if(dp[y][x] == P(-1, -1)) continue;\n\n        for(int dx2 = -1; dx2 <= 1; dx2++){\n          int nx = x + dx2;\n          int ny = y + 1;\n          if(nx < 0 || ny < 0) continue;\n          if(n < t[ny][nx]) continue;\n\n          P np = dp[y][x];\n          if(prime[t[ny][nx]]){\n            np.first++;\n            np.second = t[ny][nx];\n          }\n\n          dp[ny][nx] = max(dp[ny][nx], np);\n          ans = max(ans, np);\n        }\n      }\n    }\n\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1189&lang=jp\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define INF 1<<30\n#define MAX_M 1000010\nbool Prime[MAX_M];\nint Caves[1002][1002];\npii dp[1002][1002];\n\nvoid init_prime() {\n\tPrime[2] = true;\n\tfor (int i = 3; i < MAX_M; i += 2) {\n\t\tbool f = false;\n\t\tfor (int j = 2; j*j < i;j++) {\n\t\t\tif (i%j == 0) { f = true; break; }\n\t\t}\n\t\tif (!f) Prime[i] = true;\n\t}\n}\n\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\npair<int,int> init_Caves(int m,int n) {\n\t/* Caves initialize */\n\tmemset(Caves, 0, sizeof(Caves));\n\t/* initial state */\n\tint x, y; x = y = 500;\n\t/* next direction */\n\tint k = 0;\n\t/* step valiables */\n\tint steps = 1;\n\tint now_steps = 0;\n\tint count = 0;\n\t/* return valiables */\n\tpii ret;\n\tfor (int i = 1; i <= m;i++) {\n\t\t/* n locate & Caves */\n\t\tif (i == n) ret = { y,x };\n\t\tCaves[y][x] = i;\n\n\t\t/* next locate */\n\t\tx += dx[k]; y += dy[k];\n\n\t\t/* step */\n\t\tnow_steps++;\n\t\tif (steps == now_steps) {\n\t\t\tnow_steps = 0;\n\t\t\tk = (k + 1) % 4;\n\t\t\tcount = (count + 1) % 2;\n\t\t\tif (count == 0) {\n\t\t\t\tsteps++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint dcx[3] = { -1,0,1 };\nint dcy[3] = { -1,-1,-1 };\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tinit_prime();\n\n\tint m, n;\n\twhile (cin >> m >> n, m | n) {\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tauto s = init_Caves(m, n);\n\t\tif (Prime[n]) {\n\t\t\tdp[s.first][s.second] = { 1,n };\n\t\t}\n\t\telse {\n\t\t\tdp[s.first][s.second] = { 0,0 };\n\t\t}\n\t\tpii ans = { 0,0 };\n\n\t\tfor (int y = 1000; y >= 1; y--) {\n\t\t\tfor (int x = 1; x <= 1000; x++) {\n\t\t\t\tif (Caves[y][x] == 0) continue;\n\t\t\t\tif (dp[y][x].first == -1 && dp[y][x].second == -1) continue;\n\n\t\t\t\tif (dp[y][x].first > ans.first) {\n\t\t\t\t\tans.first = dp[y][x].first;\n\t\t\t\t\tans.second = dp[y][x].second;\n\t\t\t\t}\n\t\t\t\telse if (dp[y][x].first == ans.first && dp[y][x].second > ans.second) {\n\t\t\t\t\tans.second = dp[y][x].second;\n\t\t\t\t}\n\n\t\t\t\tint cave_count = dp[y][x].first;\n\t\t\t\tint last_prime = dp[y][x].second;\n\t\t\t\tfor (int k = 0; k < 3;k++) {\n\t\t\t\t\tint ny = y + dcy[k], nx = x + dcx[k];\n\t\t\t\t\tint next_cave_count = cave_count + (Prime[Caves[ny][nx]] == true);\n\t\t\t\t\tint next_last_prime = Prime[Caves[ny][nx]] ? Caves[ny][nx] : last_prime;\n\t\t\t\t\tif (next_cave_count > dp[ny][nx].first) {\n\t\t\t\t\t\tdp[ny][nx].first = next_cave_count;\n\t\t\t\t\t\tdp[ny][nx].second = next_last_prime;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (next_cave_count == dp[ny][nx].first && next_last_prime > dp[ny][nx].second) {\n\t\t\t\t\t\tdp[ny][nx].second = next_last_prime;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iomanip>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define pii pair<int,int>\n\n#define MAXM 1000001\n#define MAXSQM 1003\nint diff[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nint map[MAXSQM][MAXSQM] = {};\nbool furui[MAXM] = {};\npii dpmap[MAXSQM][2] = {};\n\nvoid init_map(int m){\n    fill_n(*map,MAXSQM*MAXSQM,0);\n    fill_n(*dpmap,MAXSQM*2,pii(-1,-1));\n    int idx=MAXSQM/2,idy=MAXSQM/2;\n    int dir=0;\n    int c=1;\n    for(int i=1;c<=m;i++){\n        for(int j=0;j<i&&c<=m;j++){\n            map[idx][idy]=c++;\n            idx+=diff[dir][0];\n            idy+=diff[dir][1];\n        }\n        dir=(dir+1)%4;\n        for(int j=0;j<i&&c<=m;j++){\n            map[idx][idy]=c++;\n            idx+=diff[dir][0];\n            idy+=diff[dir][1];\n        }\n        dir=(dir+1)%4;\n    }\n}\n\npii dp(int n){\n    int nx,ny;\n    for(nx=0;nx<MAXSQM;nx++){\n        for(ny=0;ny<MAXSQM;ny++){\n            if(n==map[nx][ny]) break;\n        }\n        if(n==map[nx][ny]) break;\n    }\n\n    pii ans=pii(0,0);\n\n    if(!furui[map[nx][ny]]){\n        dpmap[nx][ny%2]=pii(1,map[nx][ny]);\n        ans=dpmap[nx][ny%2];\n    }\n    else\n    {\n        dpmap[nx][ny%2]=pii(0,0);\n    }\n\n    for(int j=ny;j>=1;j--){\n        for(int i=0;i<MAXSQM;i++){\n            if(map[i][j]==0 || dpmap[i][j%2].first==-1) continue;\n            for(int k=-1;k<=1;k++){\n                if(map[i+k][j-1]==0) continue;\n                if(!furui[map[i+k][j-1]]){\n                    dpmap[i+k][(j-1)%2]=max(pii(dpmap[i][j%2].first+1,map[i+k][j-1]), dpmap[i+k][(j-1)%2]);\n                }\n                else\n                {\n                    dpmap[i+k][(j-1)%2]=max(dpmap[i][j%2], dpmap[i+k][(j-1)%2]);\n                }\n                ans=max(ans,dpmap[i+k][(j-1)%2]);\n            }\n        }\n    }\n    return ans;\n}\n\nint main(){\n    while(1){\n        int m,n;\n        cin>>m>>n;\n        if(m==0) break;\n\n        furui[0]==furui[1]==true;\n        for(int i=2;i<MAXSQM;i++){\n            for(int j=2;i*j<MAXM;j++){\n                if(!furui[i]){\n                    furui[i*j]=true;\n                }\n            }\n        }\n        init_map(m);\n        pii p=dp(n);\n\n        /*int b=503,a=487;\n        for(int i=a-5;i<a+5;i++){\n            for(int j=b-5;j<b+5;j++){\n                cout<<std::setw(4)<<map[j][i];\n            }\n            cout<<endl;\n        }\n        for(int i=a-5;i<a+5;i++){\n            for(int j=b-5;j<b+5;j++){\n                cout<<setw(4)<<dpmap[j][i].first;\n            }\n            cout<<endl;\n        }*/\n        cout<<p.first<<\" \"<<p.second<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\nusing namespace std;\n#define N 1000\n#define N2 N*N\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nbool prime[N2+1];\nint cave[N][N]={};\npair<int,int> dp[N][N];\nint m,n;\n\npair<int,int> rec(int x,int y){\n    if(y<0 || x<0 || x==N || cave[x][y]>m)return pair<int,int>(0,0);\n    if(dp[x][y].first)return dp[x][y];\n    pair<int,int> child[3];\n    child[0]=rec(x-1,y-1);\n    child[1]=rec(x,y-1);\n    child[2]=rec(x+1,y-1);\n    sort(child,child+3);\n    if(child[2].first==0 && prime[cave[x][y]])return dp[x][y]=pair<int,int>(1,cave[x][y]);\n    if(prime[cave[x][y]])child[2].first++;\n    return dp[x][y]=child[2];\n}\n\nint main(void){\n    fill(prime,prime+N2+1,true);\n    prime[0]=prime[1]=false;\n    for(int i=2;i<=N2;i++){\n        if(!prime[i])continue;\n        for(int k=2;i*k<=N2;k++)prime[i*k]=false;\n    }\n\n    int x=0,y=N-1,d=0;\n    pair<int,int> locate[N2+1];\n    for(int i=N2;i>0;i--){\n        cave[x][y]=i;\n        locate[i] = pair<int,int>(x,y);\n        int nextX=x+dx[d],nextY=y+dy[d];\n        if(nextX<0 || nextX==N || nextY<0 || nextY==N || cave[nextX][nextY])d=(d+1)%4;\n        x+=dx[d];\n        y+=dy[d];\n    }\n\n\n    while(cin>>m>>n, m|n){\n        rep(i,N)rep(j,N)dp[i][j].first=dp[i][j].second=0;\n        pair<int,int> tmp=rec(locate[n].first,locate[n].second);\n        cout<<tmp.first<<\" \"<<tmp.second<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define N_MAX 1111\nint field[N_MAX][N_MAX];\npair<int,int> dp[N_MAX][N_MAX];\n\npair<int,int> pos[1000010];\n\nint isp[1000010];\n\nint f(){\n\tfor(int i = 0 ; i < 1000010 ; i++)\n\t\tisp[i] = 1;\n\tisp[0] = isp[1] = 0;\n\tfor(int i = 0 ; i * i < 1000010 ; i++){\n\t\tif( isp[i] ){\n\t\t\tfor(int j = i * i ; j < 1000010 ; j += i)\n\t\t\t\tisp[j] = 0;\n\t\t}\n\t}\n}\n\npair<int,int> dfs(int x,int y){\n\tif( x < 0 || x >= N_MAX || y >= N_MAX ) return {0,0};\n\tif( dp[x][y].first != -1 ) return dp[x][y];\n\tpair<int,int> ans = {isp[field[y][x]],field[y][x]};\n\t\n\tfor(int i = -1 ; i <= 1 ; i++){\n\t\tans = max(make_pair(dfs(x+i,y+1).first+isp[field[y][x]],dfs(x+i,y+1).second),ans);\n\t}\n\treturn dp[x][y] = ans;\n}\nint main(){\n\tf();\n\tint n,m;\n\twhile(cin >> m >> n && n){\n\t\tfor(int i = 0 ; i < N_MAX ; i++)\n\t\t\tfor(int j = 0 ; j < N_MAX ; j++)\n\t\t\t\tdp[i][j] = {-1,-1};\n\t\tmemset(field,0,sizeof(field));\n\t\tint x = 550, y = 550;\n\t\tint d = 0;\n\t\tint len = 1;\n\t\tint now = 1;\n\t\tpos[now++] = {x,y};\n\t\tint dx[] = {1,0,-1,0};\n\t\tint dy[] = {0,-1,0,1};\n\t\t\n\t\twhile( now <= m ){\n\t\t\tfor(int k = 0 ; k < 2 ; k++){\n\t\t\t\tfor(int i = 0 ; i < len ; i++){\n\t\t\t\t\tx += dx[d+k];\n\t\t\t\t\ty += dy[d+k];\n\t\t\t\t\tif( now <= m ){\n\t\t\t\t\t\tfield[y][x] = now;\n\t\t\t\t\t\tpos[now++] = {x,y};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\td ^= 2;\n\t\t\tlen++;\n\t\t}\n\t\tcout << dfs(pos[n].first,pos[n].second).first << \" \" << dfs(pos[n].first,pos[n].second).second << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1189&lang=jp\n\n#include<iostream>\n#include<fstream>\n#include<math.h>\n\n#define MAX 1020000\n\nint n, first;\n\nclass Under{\nprivate:\n\tint right_up;\n\tint right_down;\n\tint left_up;\n\tint left_down;\n\n\tint sq;\n\npublic:\n\tint right;\n\tint straight;\n\tint left;\n\n\tUnder(int n){//constructor\n\n\t\tinitialize();\n\n\t\tsq = (int)sqrt(n);\n\t\tpoint(n);\n\n\t\t//以下の下、右、左、上のじゅんじょ大事。\n\n\t\tif (left_down <= n && n <= right_down){//下側にある時\n\t\t\tstraight = n + sq / 2 * 8 + 7;\n\t\t\tright = straight + 1;\n\t\t\tleft = straight - 1;\n\t\t}\n\n\t\telse if (sq*sq + 1 <= n && n <= right_up){//右側にある時\n\t\t\tstraight = n - 1;\n\t\t\tright = n + 4 * sq + 4;\n\t\t\t\n\t\t\tif (n == right_down + 1)left = n - 2;\n\t\t\telse left = n - 4 * sq + 2;\n\t\t}\n\t\telse if (sq*sq + 1 <= n && n <= left_down){//左側にある時\n\t\t\tstraight = n + 1;\n\t\t\tleft = n + sq * 4 + 6;\n\n\t\t\tif (n == sq*sq + sq)right = n + 2;\n\t\t\telse right = n - 4 * sq + 4;\n\t\t}\n\t\telse if (right_up <= n && n <= left_up){//上側にある時\n\t\t\tstraight = n - (sq + 1) / 2 * 8 + 5;\n\n\t\t\tright = n - 4 * sq;\n\t\t\tleft = n - 4 * sq + 2;\n\t\t\tif (n == sq*sq){\n\t\t\t\tleft = n + 2;\n\t\t\t\tright = (sq - 2)*(sq - 2);\n\t\t\t}\n\t\t\tif (n == right_up + 1)\n\t\t\t\tright = n - 2;\n\t\t}\n\t}\nprivate:\n\tvoid point(int n){\n\n\t\tif (sq % 2){//平方根が奇数\n\t\t\tif (sq*sq == n){//平方数\n\t\t\t\tright_up = n - 3 * sq + 3;\n\t\t\t\tleft_up = n - 2 * sq + 2;\n\t\t\t\tright_down = n;\n\t\t\t\tleft_down = n - sq + 1;\n\t\t\t}else{\n\t\t\t\tright_up = n;\n\t\t\t\tleft_up = n;\n\t\t\t\tright_down = sq*sq + 1;\n\t\t\t\tleft_down = sq*sq - sq + 1;\n\n\t\t\t\tif (n < sq*sq + sq + 1)left_up = sq*sq - 2 * sq + 2;\n\t\t\t\telse if (sq*sq + sq + 1 < n)right_up = sq*sq + sq + 1;\n\t\t\t}\n\t\t}\n\n\t\telse{//平方根が偶数\n\t\t\tif (sq*sq == n){//平方数\n\t\t\t\tright_up = n - sq + 1;\n\t\t\t\tleft_up = n;\n\t\t\t\tright_down = n - 2 * sq + 2;\n\t\t\t\tleft_down = n - 3 * sq + 3;\n\t\t\t}else{\n\t\t\t\tright_up = sq*sq - sq + 1;\n\t\t\t\tleft_up = sq*sq + 1;\n\t\t\t\tright_down = n;\n\t\t\t\tleft_down = n;\n\n\t\t\t\tif (n < sq*sq + sq + 1)right_down = sq*sq - 2 * sq + 2;\n\t\t\t\telse if (sq*sq + sq + 1 < n)left_down = sq*sq + sq + 1;\n\t\t\t}\n\t\t}\n\t}\n\tvoid initialize(){\n\t\tright = straight = left = right_up = right_down = left_up = left_down = sq = 0;\n\t}\n};\n\nclass Pair{\npublic:\n\tint count;\n\tint last;\n\tPair operator + (Pair p){//\t@Override (+)\n\t\tthis->count += p.count;\n\t\tif(p.last != 0)this->last = p.last;\n\t\treturn *this;\n\t}\n\tvoid setPair(int x, int y){\n\t\tcount = x;\n\t\tlast = y;\n\t}\n};\n\nPair pair(int a, int b){\n\tPair p;\n\tp.setPair(a, b);\n\treturn p;\n}\n\nbool isPrime(int n){\n\tif (n == 1)return false;\n\tif (n == 2)return true;\n\tif (n % 2 == 0)return false;\n\n\tfor (int i = 3; i * i <= n; i += 2){\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\n\nPair search(int start){\n\tstatic Pair p[MAX];\n\n\tPair right = pair(-10, 0);\n\tPair left = pair(-10, 0);\n\n\tstatic bool isReached[MAX];\n\tstatic bool initial = true;\n\n\tif (initial){//初期化\n\t\tfor (int i = 0; i < MAX; i++){\n\t\t\tisReached[i] = false;\n\t\t\tp[i].count = p[i].last = 0;\n\t\t}\n\t\tinitial = false;\n\t}\n\n\tif (n < start)\n\t\treturn p[0];//上限を超えていた場合,,, p[0].count = p[0].last = 0\n\n\t//以下特殊例処理\n\tif (start == 2){\n\t\tp[2].last = 2;\n\t\tif (start == first)initial = true;\n\t\treturn pair(1, 2) + search(9);\n\t}\n\n\tif (n <= 6 && start == 3){\n\t\tp[3].last = 2;\n\t\tif (start == first)initial = true;\n\t\treturn pair(2, 2);\n\t}\n\tif (start == 4){\n\t\tif (right.count == -10)right = search(2);\n\t\tif (left.count == -10)left = search(1);\n\n\t\tif (right.count == left.count){\n\t\t\tif (right.last < left.last)right.count--;\n\t\t}\n\t\tif (right.count < left.count){\n\t\t//\tstd::cout << count[4] + left[4] << std::endl;\n\t\t\tisReached[4] = true;\n\t\t\tif (start == first)initial = true;\n\t\t\treturn p[4] = p[4] + left;\n\t\t}\n\t\telse{\n\t\t//\tstd::cout << count[4] + right[4] << std::endl;\n\t\t\tisReached[4] = true;\n\t\t\tif (start == first)initial = true;\n\t\t\treturn p[4] = p[4] + right;\n\t\t}\n\t}\n\t//ここまで特例処理\n\n\t//下の数字を計算\n\tUnder under(start);\n\n\t//偶数の時\n\tif (start % 2 == 0)return p[under.straight] = search(under.straight);\n\n\tif (right.count == -10)right = search(under.right);//under.rightの計算\n\tif (left.count == -10)left = search(under.left);//under.leftの計算\n\n\t//std::cout << start << \" : l, r = \" << left[start] << \", \" << right[start] << \" : \";\n\n\t//枝刈り\n\tif (isReached[start]){\n\t\t//std::cout << \"\\t\"<< count[start] << std::endl;\n\t\treturn p[start];\n\t}\n\n\t//素数の時\n\tif (isPrime(start)){\n\t\tp[start].count = 1;\n\t\tp[start].last = start;\n\t}\n\n\tif (right.count == left.count){\n\t\tif (right.last < left.last)right.count--;\n\t}\n\t//leftのコストが大きい時\n\tif (right.count < left.count){\n\t\t//std::cout << count[start] + left[start] << std::endl;\n\t\tisReached[start] = true;\n\t\tif (start == first)initial = true;//最初に入った時のみ、次のために初期化\n\t\treturn p[start] = p[start] + left;\n\t}\n\t//rightのコストが大きい時\n\telse{\n\t\t//std::cout << count[start] + right[start] << std::endl;\n\t\tisReached[start] = true;\n\t\tif (start == first)initial = true;//最初に入った時のみ、次のために初期化\n\t\treturn p[start] = p[start] + right;\n\t}\n}\n\nint main(){\n\n\tusing namespace std;\n/*\n\tifstream fin;\n\tfin.open(\"input.txt\");\n*/\n\twhile (true){\n\t\tcin >> n >> first;\n\t\tif (n == 0)break;\n\n\t\tPair p = search(first);\n\n\t\tcout << p.count << \" \" << p.last << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "/*\n#include<stdio.h>\n#include<string.h>\nchar a[10000];\nint cur=0;\nint get_fb(char x[])\n{\n\tif(x[0] == 'f')\n\t\treturn 0;\n\telse if(x[0] == 'b')\n\t\treturn 1;\n\telse if(x[0] == 'd')\n\t\treturn 2;\n\telse return 3;\n}\nchar *get_nc(char x[])\n{\n\tint i, j;\n\tchar nc[1000];\n\tfor(i=0;x[i]>32;i++);\n\tfor(;x[i]==32;i++);\n\ti++;\n\tfor(j=0;x[i]!='\"';j++,i++)\n\t\tnc[j] = x[i];\n\tnc[j] = 0;\n\treturn nc;\n}\nint get_cw(char x[])\n{\n\tint i, j;\n\tfor(i=0;x[i]>32;i++);\n\tfor(;x[i]==32;i++);\n\tif(x[i]=='c')return 0;\n\telse return 1;\n}\nvoid insert(char nc[])\n{\n\tint i, j;\n\tfor(j=0;nc[j];j++)\n\t{\n\t\tfor(i=cur;a[i];i++);\n\t\tfor(;i>cur;i--)\n\t\t\ta[i] = a[i-1];\n\t\ta[cur] = nc[j];\n\t\tcur++;\n\t}\n}\nvoid doit(int x,int y)\n{\n\tint i, j;\n\tif(x==0)\t\t// for\n\t{\n\t\tif(a[cur+1])\n\t\t{\n\t\t\tif(y==0)\n\t\t\t{\n\t\t\t\ta[cur]=a[cur+1];\n\t\t\t\ta[cur+1]='^';\n\t\t\t\tcur++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tj=cur+1;\n\t\t\t\twhile(a[j] && a[j]==32)j++;\n\t\t\t\twhile(a[j] && a[j]>32)j++;\n\t\t\t\tfor(i=cur;i<j;i++)\n\t\t\t\t\ta[i]=a[i+1];\n\t\t\t\ta[j-1]='^';\n\t\t\t\tcur = j-1;\n\t\t\t}\n\t\t}\n\t}\n\telse if(x==1)\t// back\n\t{\n\t\tif(cur>0)\n\t\t{\n\t\t\tif(y==0)\n\t\t\t{\n\t\t\t\ta[cur] = a[cur-1];\n\t\t\t\ta[cur-1] = '^';\n\t\t\t\tcur--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tj = cur-1;\n\t\t\t\twhile(j>=0 && a[j]== 32)j--;\n\t\t\t\twhile(j>=0 && a[j]>32)j--;\n\t\t\t\tfor(i=cur;i>j;i--)\n\t\t\t\t\ta[i]=a[i-1];\n\t\t\t\ta[j+1]='^';\n\t\t\t\tcur = j+1;\n\t\t\t}\n\t\t}\n\t}\n\telse if(x==2)\t// del\n\t{\n\n\t\tif(y==0)\n\t\t{\n\t\t\tfor(i=cur;a[i];i++)\n\t\t\t{\n\t\t\t\ta[i] = a[i+1];\n\t\t\t}\n\t\t\ta[cur] = '^';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tj=cur+1;\n\t\t\tint k=0;\n\t\t\twhile(a[j] && a[j]==32)j++;\n\t\t\twhile(a[j] && a[j]>32){j++;k=1;}\n\t\t\tj--;\n\t\t\tif(k)\n\t\t\t{\n\t\t\t\tfor(i=cur;a[i];i++,j++)\n\t\t\t\t\ta[i]=a[j];\n\t\t\t\ta[cur] = '^';\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tint t;\n\tscanf(\"%d\\n\",&t);\n\twhile(t--)\n\t{\n\t\tmemset(a,0,sizeof(a));\n\t\tgets(a+1);\n\t\tcur=0;\n\t\ta[0] = '^';\n\t\tint m;\n\t\tscanf(\"%d\\n\",&m);\n\t\twhile(m--)\n\t\t{\n\t\t\tchar comand[1000];\n\t\t\tchar *nc;\n\t\t\tgets(comand);\n\t\t\tint x = get_fb(comand);\n\t\t\tif(x==3)\n\t\t\t{\n\t\t\t\tnc = get_nc(comand);\n\t\t\t\tinsert(nc);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint y;\n\t\t\t\ty = get_cw(comand);\n\t\t\t\tdoit(x,y);\n\t\t\t}\n\t\t\tprintf(\"%s\\n\",a);\n\t\t}\n\t\tprintf(\"%s\\n\",a);\n\t}\n}\n*/\n\n#include<stdio.h>\nint n, m;\nint a[2000][2000];\nint b[2000][2000];\nint c[2000][2000];\nint sx[1000005];\nint sy[1000005];\nint p[1000005];\nvoid prime()\n{\n\tint i, j;\n\tp[1] = 1;\n\tfor(i=2;i<=1000000;i++)\n\t{\n\t\tif(p[i] == 0)\n\t\t{\n\t\t\tfor(j=2*i;j<=1000000;j+=i)\n\t\t\t{\n\t\t\t\tp[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid inil()\n{\n\tint i, j;\n\tprime();\n\ta[1000][1000] = 1;\n\tsx[1] = sy[1] = 1000;\n\tint x,y,d;\n\tint dx[4]={1,0,-1,0};\n\tint dy[4]={0,1,0,-1};\n\td = 0;\n\tx = y = 1000;\n\tint k=1;\n\tint td;\n\twhile(k<=1000000)\n\t{\n\t\ta[x][y] = k;\n\t\tsx[k] = x;\n\t\tsy[k] = y;\n\t\tif(p[k] == 0)\n\t\t\tb[x][y] = 1;\n\t\ttd = (d+1)%4;\n\t\tif(a[dx[td] + x][dy[td] + y] == 0)\n\t\t\td = td;\n\t\tx = x+dx[d];\n\t\ty = y+dy[d];\n\t\tk++;\n\t}\n}\nvoid process()\n{\n\tint i, j, k;\n\tint x,y;\n\tx = sx[m];\n\ty = sy[m];\n\tfor(i=0;i<2000;i++)\n\t\tfor(j=0;j<2000;j++)\n\t\t\tc[i][j] = 0;\n\tif(p[a[x][y]]==0)\n\t\tc[x][y]=1;\n\tfor(i=x+1;i<1888;i++)\n\t{\n\t\tfor(j=y-i+x;j<=y+i-x;j++)\n\t\t{\n\t\t\tif(j<0)continue;\n\t\t\tif(j>1888)continue;\n\t\t\tif(a[i][j] == 0 || a[i][j] > n) continue;\n\t\t\t//printf(\"%d %d  %d %d\\n\",x,y,i,j);\n\t\t\tk = (p[a[i][j]]==0);\n\t\t\tif(c[i][j] < c[i-1][j-1] + k)\n\t\t\t\tc[i][j] = c[i-1][j-1]+k;\n\t\t\tif(c[i][j] < c[i-1][j] + k)\n\t\t\t\tc[i][j] = c[i-1][j]+k;\n\t\t\tif(c[i][j] < c[i-1][j+1] + k)\n\t\t\t\tc[i][j] = c[i-1][j+1]+k;\n\t\t}\n\t}\n\tint max=0;\n\tint mi = 0;\n\tfor(i=n;i>0;i--)\n\t{\n\t\tif(max < c[sx[i]][sy[i]])\n\t\t{\n\t\t\tmax = c[sx[i]][sy[i]];\n\t\t\tmi = i;\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",max,mi);\n}\nint main()\n{\n\tinil();\n\twhile(1)\n\t{\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n+m==0)break;\n\t\tprocess();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (y>=0&&x>=0&&table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t\n\t\tfor (int h = 0;h < SIZE;h++) {\n\t\t\tfor (int w = 0;w < SIZE;w++) {\n\t\t\t\tif (table[h][w] == n) {\n\t\t\t\t\tcout << endl;\n\t\t\t\t\t//cout << dp[h][w] << \" \" << pr[h][w] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=x && x<w && 0<=y && y<h)\n\nconst int INF = 10000000;\nint dx[4]={1, 0, -1, 0}, dy[4]={0, 1, 0, -1};\nusing namespace std;\ntypedef pair<int, int> P;\n\n/** Problem1189 : Prime Caves **/\nint caves[1010][1010];\nint dp[1010][1010];\nconst int MAX = 1030000;\nbool prime[MAX];\n\nint main()\n{\n\tint m, n;\n\tconst int dx0[4] = {1, 0, -1, 0}, dy0[4] = {0, -1, 0, 1}, dx1[3]={-1, 0, 1};\n\tint sx, sy;\n\t\n\tfor (int i=0; i<MAX; i++)\n\t\tprime[i] = true;\n\t\n\tprime[0] = false; prime[1] = false;\n\t\n\tfor (int i=2; i<MAX; i++) {\n\t\tif (prime[i]) {\n\t\t\tfor (int j=2; i*j<MAX; j++) {\n\t\t\t\tprime[i*j] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\twhile (cin>>m>>n, m||n) {\n\t\tfill(caves[0], caves[0]+1010*1010, 0);\n\t\tfill(dp[0], dp[0]+1010*1010, -1);\n\t\tint x=1010/2, y=1010/2 , t=1, direct=1;\n\t\tcaves[x][y]=1;\n\t\tcaves[++x][y]=2;\n\t\tint i=2; bool change = true;\n\t\twhile (1) {\n\t\t\trep(j, t) {\n\t\t\t\tx+=dx0[direct]; y+=dy0[direct];\n\t\t\t\tcaves[x][y]=i+1;\n\t\t\t\ti++;\n\t\t\t\tif (i==n) {\n\t\t\t\t\tsx = x; sy = y;\n\t\t\t\t}\n\t\t\t\tif (i>=m) goto end;\n\t\t\t}\n\t\t\tif (change) {\n\t\t\t\tt++;\n\t\t\t\tchange = false;\n\t\t\t} else {\n\t\t\t\tchange=true;\n\t\t\t}\n\t\t\tdirect++; direct%=4;\n\t\t}\n\tend: ;\n\t\tint ans=0, alast=0;\n\n\t\tdp[sx][sy] = prime[caves[sx][sy]];\n\t\tREP(j, 0, 1010) {\n\t\t\tREP(i, 0, 1010) {\n\t\t\t\tans = max(ans, dp[i][j]);\n\t\t\t\t\n\t\t\t\tif (dp[i][j] == -1) continue;\n\t\t\t\tif (caves[i][j] == 0) continue;\n\t\t\t\t\n\t\t\t\trep(k, 3) {\n\t\t\t\t\tint nx=i+dx1[k], ny=j+1;\n\t\t\t\t\tif (!(0<=nx && nx<1010) || ny>=1010) continue;\n\t\t\t\t\tif (caves[nx][ny]==0) continue;\n\n\t\t\t\t\tdp[nx][ny] = max(dp[nx][ny], dp[i][j]+prime[caves[nx][ny]]);\n\n\t\t\t\t\tans = max(ans, dp[nx][ny]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (ans!=0) {\n\t\t\tREP(j, 0, 1010) {\n\t\t\t\tREP(i, 0, 1010) {\n\t\t\t\t\tif (dp[i][j]==ans && prime[caves[i][j]]) {\n\t\t\t\t\t\talast = max(alast, caves[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << \" \" << alast << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<int(b); i++)\n#define rep(i,n) loop(i,0,n)\n#define all(c) (c).begin(), (c).end()\ntypedef complex<int> P;\n\nconst int MAX_M = 1.5e6+10;\nconst int SIZE = 1100;\nint ps[MAX_M/2];\nbool isp[MAX_M];\nint grid[SIZE][SIZE]={};\nP itop[MAX_M];\npair<int,int> dp[SIZE][SIZE];\n\nint cnt_p = 0;\n\nvoid make_es(){\n    fill(isp,isp+MAX_M,true);\n    isp[0]=isp[1]=false;\n    rep(i,MAX_M){\n        if(!isp[i]) continue;\n        ps[cnt_p++] = i;\n        for(int j=i<<1; j<MAX_M; j+=i){\n            isp[j] = false;\n        }\n    }\n}\n\nint n,m;\n\npair<int,int> rec(int y, int x){\n    if(dp[y][x].first!=-1) return dp[y][x];\n\n    pair<int,int> best(0,0);\n    loop(i,-1,2){\n        if(grid[y+1][x+i]<=m){\n            auto t = rec(y+1,x+i);\n            best = max(t,best);\n        }\n    }\n\n    pair<int,int> res(0,0);\n    if(isp[grid[y][x]]){\n        res.first = 1;\n        res.second = grid[y][x];\n    }\n    if(best.first != 0){\n        res.first += best.first;\n        res.second = best.second;\n    }\n\n    return dp[y][x] = res;\n}\n\nint main(){\n    make_es();\n    P p(SIZE/2,SIZE/2);\n    P dir(0,1);\n    for(int i=1; i<MAX_M; i++){\n        grid[p.real()][p.imag()] = i;\n        itop[i]=p;\n        p+=dir;\n        P q = p+dir*P(0,1);\n        if(grid[q.real()][q.imag()] == 0){\n            dir*=P(0,1);\n        }\n    }\n\n    while(cin>>m>>n, n+m){\n        auto t = make_pair(-1,-1);\n        rep(i,SIZE)rep(j,SIZE) dp[i][j] = t;\n        auto u = itop[n];\n        auto ans = rec(u.real(), u.imag());\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n#define t_max 10000001\nint M[1001][1001];\nint S[1001][1001];\nint P[1001][1001];\nint table[t_max];\nvector<pair<int,int> >m(t_max);\nmap<pair<int,int>,int>m_rev;\npair<int,int> dfs(int x,int y){\n\tif(y==1001)return make_pair(0,0);\n\tif(S[x][y]>=0)return make_pair(S[x][y],P[x][y]);\n\tint m=0,m_place=0,i=-1;\n\tfor(;i<2;i++){\n\t\tif(x+i<0||1000<x+i)continue;\n\t\tpair<int,int> p=dfs(x+i,y+1);\n\t\tif(m<p.first||(m==p.first&&m_place<p.second))m=p.first,m_place=p.second;\n\t}\n\tif(m==0){\n\t\tif(M[x][y])return make_pair(S[x][y]=1,P[x][y]=m_rev[make_pair(x,y)]);\n\t\treturn make_pair(S[x][y]=0,P[x][y]=0);\n\t}else{\n\t\treturn make_pair(S[x][y]=m+M[x][y],P[x][y]=m_place);\n\t}\n}\nmain(){\n\tint k=1,z,x,y,i,n,s;\n\tm[k]=make_pair(x=500,y=500),m_rev[make_pair(x,y)]=k,k++;\n\tfor(z=2;z<=1000;z+=2){\n\t\tx++,y++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(x,--y),m_rev[make_pair(x,y)]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(--x,y),m_rev[make_pair(x,y)]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(x,++y),m_rev[make_pair(x,y)]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(++x,y),m_rev[make_pair(x,y)]=k,k++;\n\t}\n\ttable[0]=table[1]=1;\n\tfor(x=2;x<t_max;x++)if(!table[x])for(y=x*2;y<t_max;y+=x)table[y]=1;\n\tfor(;scanf(\"%d%d\",&n,&s),n;){\n\t\tmemset(M,0,sizeof(M));\n\t\tmemset(S,0xff,sizeof(S));\n\t\tmemset(P,0,sizeof(P));\n\t\tfor(i=1;i<=n;i++)if(!table[i])M[m[i].first][m[i].second]=1;\n\t\tpair<int,int> p=dfs(m[s].first,m[s].second);\n\t\tprintf(\"%d %d\\n\",p.first,p.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<LL,LL> P;\nconst LL LINF=1LL<<62;\nconst LL mod=1e9;\n\n\nconst int M_N=1000000;\nbool prime[M_N+1];\n \nvoid Sieve(){\n    int i,j;\n    prime[1]=false;\n    for (i=2;i*i<=M_N;i++){\n        if (prime[i]==true){\n            for (j=2;i*j<=M_N;j++){\n                prime[i*j]=false;\n            }\n        }\n    }\n}\n\nint a[4001][4001];\n\nvoid dfs(int i,int x,int y,int count,int sum){\n    if(i%2==0) count++;\n    for(int s=0;s<count;s++){\n        if(i%4==0) a[y][++x]=++sum;\n        if(i%4==1) a[--y][x]=++sum;\n        if(i%4==2) a[y][--x]=++sum;\n        if(i%4==3) a[++y][x]=++sum;\n        if(sum==1000000) return;\n    }\n    dfs((i+1)%4,x,y,count,sum);\n}\n\nvoid check(int *x,int *y,int n){\n    for(int i=-1000;i<=1000;i++){\n        for(int j=-1000;j<=1000;j++){\n            if(a[2000+i][2000+j]==n){\n                *y=i+2000;\n                *x=j+2000;\n                return;\n            }\n        }\n    }\n}\n\nint dp[4000][4000];\n\nint main(){\n    memset(prime,true,sizeof(prime));\n    Sieve();\n    int m,n;\n    a[2000][2000]=1;\n    dfs(0,2000,2000,0,1);\n    while(cin >> m >> n){\n        if(m==0&&n==0) return 0;\n        memset(dp,0,sizeof(dp));\n        int x,y;\n        check(&x,&y,n);\n        int c=1;\n        dp[y][x]=prime[a[y][x]];\n        int ans=dp[y][x],p=0;\n        if(ans>0) p=a[y][x];\n        for(int i=y;i<=y+1000;i++){\n            for(int j=-c+x;j<=x+c;j++){\n                if(a[i+1][j]==0||a[i+1][j]>m) continue;\n                dp[i+1][j]=max({dp[i][j-1],dp[i][j],dp[i][j+1]})+prime[a[i+1][j]];\n                if(ans<dp[i+1][j]){\n                    ans=dp[i+1][j];\n                    p=a[i+1][j];\n                }\n                else if(ans==dp[i+1][j]&&a[i+1][j]>p&&prime[a[i+1][j]]){\n                    p=a[i+1][j];\n                }\n            }\n            c++;\n        }\n        cout << ans <<\" \"<< p << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 1000001\n#define Max 1600\n#define index 1000\n#define f first\n#define s second\n#define mp make_pair\nusing namespace std;\n\nint y[MAX],x[MAX];\nbool prime[MAX];\nint pc[Max][Max]={};\nint dp[Max][Max]={};\nint Y[4]={0,-1,0,1};\nint X[4]={1,0,-1,0};\n\nbool isPrime(int n){\n  if(n<2)return false;\n  if(n==2)return true;\n  if(n%2==0)return false;\n  for(int i=3;i<=n/i;i+=2){\n    if(n%i==0)return false;\n  }\n  return true;\n}\n\nvoid init(){\n  for(int i=0;i<MAX;i++)prime[i]=isPrime(i);\n  \n  int nowi=index,nowj=index,muki=0;\n  for(int i=1;i<MAX;i++){\n    pc[nowi][nowj]=i;\n    y[i]=nowi;\n    x[i]=nowj;\n    nowi+=Y[muki];\n    nowj+=X[muki];\n    if(pc[nowi+Y[(muki+1)%4]][nowj+X[(muki+1)%4]]==0)muki=(muki+1)%4;\n  }\n}\n\nint main()\n{\n  int a,b;\n\n  init();\n\n  while(1){\n    cin>>a>>b;\n    if(a+b==0)break;\n\n    for(int i=0;i<Max;i++){\n      for(int j=0;j<Max;j++)dp[i][j]=-1;\n    }\n\n    queue<pair<int,int> > q;\n    dp[y[b]][x[b]]=prime[b];\n    q.push(mp(y[b],x[b]));\n    pair<int,int> ans(prime[b],b);\n    while(!q.empty()){\n      pair<int,int> u=q.front();\n      q.pop();\n      for(int i=-1;i<=1;i++){\n\tint ni=u.f+1,nj=u.s+i;\n\tif(pc[ni][nj]<=a && pc[ni][nj]!=0){\n\t  if(dp[ni][nj]<dp[u.f][u.s]+prime[pc[ni][nj]]){\n\t    if(dp[ni][nj]==-1)q.push(mp(ni,nj));\n\t    dp[ni][nj]=dp[u.f][u.s]+prime[pc[ni][nj]];\n\t    if(prime[pc[ni][nj]]==0)continue;\n\t    if(ans.f<dp[ni][nj]){\n\t      ans=mp(dp[ni][nj],pc[ni][nj]);\n\t    }\n\t    else if(ans.f==dp[ni][nj] && ans.s<pc[ni][nj]){\n\t      ans=mp(dp[ni][nj],pc[ni][nj]);\n\t      }\n\t  }\n\t}\n      }\n    }\n    if(ans.f==0)cout<<0<<\" \"<<0<<endl;\n    else cout<<ans.f<<\" \"<<ans.s<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int N = 1010;\nint tbl[N][N];\nbool prime[N*N+1];\nint m,s;\nint sx,sy;\nint num[N][N], lastp[N][N];\n\nvoid maketbl(){\n  const int dx[] = {1,0,-1,0};\n  const int dy[] = {0,-1,0,1};\n  int x=N/2,y=N/2;\n  int t = 1;\n  int d = 1;\n  int dir = 0;\n  while(t<=1000000){\n    for(int i=0;i<d;++i){\n      tbl[y][x]=t++;\n      y+=dy[dir];\n      x+=dx[dir];\n      if(t>1000000) break;\n    }\n    dir = (dir+1)%4;\n    if(dir%2==0) ++d;\n  }\n}\n\nvoid solve(int x,int y){\n  if(num[y][x]!=-1) return;\n  if(tbl[y][x]==s){\n    num[y][x] = prime[s];\n    lastp[y][x] = (prime[s])?s:0;\n    return;\n  }\n  if(abs(x-sx) > y-sy) return;\n  int a1=0,a2=0;\n  for(int mx=x-1;mx<=x+1;++mx){\n    int my = y-1;\n    if(mx<0 || mx>=N) continue;\n    if(tbl[my][mx]>m) continue;\n    solve(mx,my);\n    if(a1 < num[my][mx]){\n      a1 = num[my][mx];\n      a2 = lastp[my][mx];\n    }\n    else if(a1 == num[my][mx]) a2 = max(a2,lastp[my][mx]);\n  }\n  if(prime[tbl[y][x]]){\n    a1++;\n    a2=tbl[y][x];\n  }\n  num[y][x]=a1;\n  lastp[y][x]=a2;\n}\n\nint main(){\n  maketbl();\n  for(int i=2;i<=N*N;++i) prime[i]=true;\n  for(int i=2;i<=N*N;++i) if(prime[i]) for(int j=2;i*j<=N*N;++j) prime[i*j]=false;\n\n  while(cin>>m>>s,m||s){\n    memset(num,-1,sizeof(num));\n    memset(lastp,-1,sizeof(lastp));\n    for(int i=0;i<N;++i)\n      for(int j=0;j<N;++j)\n\tif(tbl[i][j]==s){\n\t  sx = j;\n\t  sy = i;\n\t  break;\n\t}\n    int ans1 = 0,ans2 = 0;\n    for(int j=0;j<N;++j){\n      for(int i=N-1;i>=0;--i){\n\tif(tbl[i][j] && tbl[i][j]<=m){\n\t  solve(j,i);\n\t  if(ans1 < num[i][j]){\n\t    ans1 = num[i][j];\n\t    ans2 = lastp[i][j];\n\t  }\n\t  else if(ans1 == num[i][j])\n\t    ans2 = max(ans2,lastp[i][j]);\n\t  break;\n\t}\n      }\n    }\n    cout << ans1 << \" \" << ans2 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint n, m;\nint a[2000][2000];\nint b[2000][2000];\nint c[2000][2000];\nint e[2000][2000];\nint sx[1000005];\nint sy[1000005];\nint p[1000005];\nvoid prime()\n{\n\tint i, j;\n\tp[1] = 1;\n\tfor(i=2;i<=1000000;i++)\n\t{\n\t\tif(p[i] == 0)\n\t\t{\n\t\t\tfor(j=2*i;j<=1000000;j+=i)\n\t\t\t{\n\t\t\t\tp[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid inil()\n{\n\tint i, j;\n\tprime();\n\tint x,y,d;\n\tint dx[4]={1,0,-1,0};\n\tint dy[4]={0,1,0,-1};\n\td = 0;\n\tx = y = 1000;\n\tint k=1;\n\tint td;\n\twhile(k<=1000000)\n\t{\n\t\ta[x][y] = k;\n\t\tsx[k] = x;\n\t\tsy[k] = y;\n\t\tif(p[k] == 0)\n\t\t\tb[x][y] = 1;\n\t\ttd = (d+1)%4;\n\t\tif(a[dx[td] + x][dy[td] + y] == 0)\n\t\t\td = td;\n\t\tx = x+dx[d];\n\t\ty = y+dy[d];\n\t\tk++;\n\t}\n}\nvoid process()\n{\n\tint i, j, k;\n\tint x,y;\n\tx = sx[m];\n\ty = sy[m];\n\tfor(i=0;i<2000;i++)\n\t\tfor(j=0;j<2000;j++)\n\t\t\tc[i][j] = e[i][j]=0;\n\tif(p[a[x][y]]==0)\n\t\tc[x][y]=1;\n\tfor(i=x+1;i<1888;i++)\n\t{\n\t\tfor(j=y-i+x;j<=y+i-x;j++)\n\t\t{\n\t\t\tif(j<0)continue;\n\t\t\tif(j>1888)continue;\n\t\t\tif(a[i][j] == 0 || a[i][j] > n) continue;\n\t\t\t//printf(\"%d %d  %d %d\\n\",x,y,i,j);\n\t\t\tk = (p[a[i][j]]==0);\n\t\t\tif(c[i][j] < c[i-1][j-1] + k)\n\t\t\t{\n\t\t\t\tc[i][j] = c[i-1][j-1]+k;\n\t\t\t\te[i][j] = e[i-1][j-1];\n\t\t\tif(k)e[i][j] = a[i][j];\n\t\t\t}\n\t\t\telse if(c[i][j] == c[i-1][j-1]+k)\n\t\t\t{\n\t\t\t\te[i][j] = e[i-1][j-1];\n\t\t\tif(k)e[i][j] = a[i][j];\n\t\t\t}\n\t\t\tif(c[i][j] < c[i-1][j] + k)\n\t\t\t{\n\t\t\t\tc[i][j] = c[i-1][j]+k;\n\t\t\t\te[i][j] = e[i-1][j];\n\t\t\tif(k)e[i][j] = a[i][j];\n\t\t\t}\n\t\t\telse if(c[i][j] == c[i-1][j]+k)\n\t\t\t{\n\t\t\t\te[i][j] = e[i-1][j];\n\t\t\tif(k)e[i][j] = a[i][j];\n\t\t\t}\n\t\t\tif(c[i][j] < c[i-1][j+1] + k)\n\t\t\t{\n\t\t\t\tc[i][j] = c[i-1][j+1]+k;\n\t\t\t\te[i][j] = e[i-1][j+1];\n\t\t\tif(k)e[i][j] = a[i][j];\n\t\t\t}\n\t\t\telse if(c[i][j] == c[i-1][j+1]+k)\n\t\t\t{\n\t\t\t\te[i][j] = e[i-1][j+1];\n\t\t\tif(k)e[i][j] = a[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tint max=0;\n\tint mi = 0;\n\tfor(i=n;i>0;i--)\n\t{\n\t\tif(max < c[sx[i]][sy[i]])\n\t\t{\n\t\t\tmax = c[sx[i]][sy[i]];\n\t\t\tmi = e[sx[i]][sy[i]];\n\t\t}\n\t\telse if(max == c[sx[i]][sy[i]])\n\t\t{\n\t\t\tif(mi < e[sx[i]][sy[i]])\n\t\t\t\tmi = e[sx[i]][sy[i]];\n\t\t}\n\t}\n\tif(max==0)mi=0;\n\tprintf(\"%d %d\\n\",max,mi);\n}\nint main()\n{\n\tinil();\n\twhile(1)\n\t{\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n+m==0)break;\n\t\tprocess();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint isPrime(int x){\n  for(int i=2;i*i<=x;i++) if(x%i==0) return 0;\n  return 1;\n}\nint main(){\n  int m,n;\n  int st[1005][1005]={{}};\n  int p[1000005]={};\n  int x=501,y=501;\n  int idx,idy;\n  int i=1,j,k=1;\n  st[x][y]=i;\n  i++;\n  while(1){\n    for(j=0;j<2*k;j++){\n      st[x+1][y-j]=i;\n      i++;\n    }\n    for(j=0;j<2*k;j++){\n      st[x-j][y-(k-1)*2-1]=i;\n      i++;\n    }\n    for(j=0;j<2*k;j++){\n      st[x-(k-1)*2-1][y-(k-1)*2+j]=i;\n      i++;\n    }\n    for(j=0;j<2*k;j++){\n      st[x-(k-1)*2+j][y+1]=i;\n      i++;\n    }\n    if(i>1000005) break;\n    k++;x++;y++;\n  }\n  for(i=2;i<1000005;i++) p[i]=isPrime(i);\n  \n  \n  while(cin >> m >> n,m||n){\n    int ans=0,id=0;\n    int dp[2][1005]={};\n    for(i=0;i<1005;i++){\n      for(j=0;j<1005;j++){\n\tif(st[i][j]==n){\n\t  idx=i;idy=j;\n\t  if(p[n]){\n\t    ans=1;id=n;\n\t    dp[0][i]=1;\n\t  }\n\t  break;\n\t}\n      }\n    }\n    //cout << n << \":\" << p[n] << endl;\n    for(i=0;i+idy<1005;i++){\n      for(j=-i;j<=i;j++){\n\tif(idx+j<0||idx+j>1004) continue;\n\tif(st[idx+j][idy+i]>m) continue;\n\tif(idx+j-1>=0&&idx+j-1<1005){\n\t  if(st[idx+j-1][idy+i+1]<=m){\n\t    dp[(i+1)%2][idx+j-1]=\n\t      max(dp[(i+1)%2][idx+j-1],dp[i%2][idx+j]+p[st[idx+j-1][idy+i+1]]);\n\t    if(p[st[idx+j-1][idy+i+1]]){\n\t      if(ans<dp[(i+1)%2][idx+j-1]||\n\t\t (ans==dp[(i+1)%2][idx+j-1]&&id<st[idx+j-1][idy+i+1])){\n\t\tans=dp[(i+1)%2][idx+j-1];\n\t\tid=st[idx+j-1][idy+i+1];\n\t      }\n\t    }\n\t  }\n\t}\n\tif(idx+j>=0&&idx+j<1005){\n\t  if(st[idx+j][idy+i+1]<=m){\n\t    dp[(i+1)%2][idx+j]=\n\t      max(dp[(i+1)%2][idx+j],dp[i%2][idx+j]+p[st[idx+j][idy+i+1]]);\n\t    if(p[st[idx+j][idy+i+1]]){\n\t      if(ans<dp[(i+1)%2][idx+j]||\n\t\t (ans==dp[(i+1)%2][idx+j]&&id<st[idx+j][idy+i+1])){\n\t\tans=dp[(i+1)%2][idx+j];\n\t\tid=st[idx+j][idy+i+1];\n\t      }\n\t    }\n\t  }\n\t}\n\tif(idx+j+1>=0&&idx+j+1<1005){\n\t  if(st[idx+j+1][idy+i+1]<=m){\n\t    dp[(i+1)%2][idx+j+1]=\n\t      max(dp[(i+1)%2][idx+j+1],dp[i%2][idx+j]+p[st[idx+j+1][idy+i+1]]);\n\t    if(p[st[idx+j+1][idy+i+1]]){\n\t      if(ans<dp[(i+1)%2][idx+j+1]||\n\t\t (ans==dp[(i+1)%2][idx+j+1]&&id<st[idx+j+1][idy+i+1])){\n\t\tans=dp[(i+1)%2][idx+j+1];\n\t\tid=st[idx+j+1][idy+i+1];\n\t      }\n\t    }\n\t  }\n\t}\n      }    \n    }\n    cout << ans << \" \" << id << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint prime_cave[1003][1003]={0};\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\npair<int, int> pos[1000006];\npair<int, int> memo[1003][1003];\n\nlong long int prime[1000006]; // i番目の素数\nbool is_prime[1000006];   // is_prime[i]がtrueならばiは素数\n\nstruct Node{\n    int x, y, caves, last;\n};\n\n// n以下の素数の数を返す\nlong long int sieve(long long int n) {\n    long long int p = 0;\n    for (long long int i = 0; i <= n; i++)\n        is_prime[i] = true;\n    is_prime[0] = false;\n    is_prime[1] = false;\n    for (long long int i = 2; i <= n; i++) {\n        if (is_prime[i]) {\n            prime[p++] = i;\n            for (long long int j = 2 * i; j <= n; j += i)\n                is_prime[j] = false;\n        }\n    }\n    return p;\n}\n\nvoid make_cave(){\n    int p = 1000000, d = 0, x = 0, y = 0;\n    while(p > 0){\n        prime_cave[y][x] = p;\n        pos[p] = make_pair(x, y);\n        int nx = x + dx[d], ny = y + dy[d];\n        if(nx < 0 || nx >= 1000 || ny < 0 || ny >= 1000 || prime_cave[ny][nx] != 0){\n            d = (d + 1) % 4;\n        }\n        x += dx[d];\n        y += dy[d];\n        p--;\n    }\n}\n\nint main(){\n    sieve(1000000);\n    make_cave();\n    int m, n;\n    while(cin >> m >> n, m != 0){\n        for(int i=0;i<1000;++i){\n            for(int j=0;j<1000;++j){\n                memo[i][j] = make_pair(-1, -1);\n            }\n        }\n        pair<int, int> start = pos[n];\n        queue<Node> que;\n        if(is_prime[n]){\n            que.push((Node){start.first, start.second, 1, n});\n            memo[start.second][start.first].first = 1;\n            memo[start.second][start.first].second = n;\n        }else{\n            que.push((Node){start.first, start.second, 0, 0});\n            memo[start.second][start.first].first = 0;\n            memo[start.second][start.first].second = 0;\n        }\n\n        while(!que.empty()){\n            Node curr = que.front(); que.pop();\n            int cx = curr.x, cy = curr.y;\n            for(int i=-1;i<=1;++i){\n                if(cx + i < 0 || cx + i >= 1000 || cy + 1 >= 1000)continue;\n                int nx = cx + i, ny = cy + 1, num = prime_cave[ny][nx];\n                if(num > m)continue;\n                int nc = curr.caves + (int)is_prime[num];\n                int nl = (is_prime[num] ? num : curr.last);\n                if(memo[ny][nx].first < nc || memo[ny][nx].first == nc && memo[ny][nx].second < nl){\n                    memo[ny][nx].first = nc;\n                    memo[ny][nx].second = nl;\n                    que.push((Node){nx, ny, nc, nl});\n                }\n            }\n        }\n\n        pair<int, int> ans = make_pair(0, 0);\n        for(int i=0;i<1000;++i){\n            for(int j=0;j<1000;++j){\n                ans = max(ans, memo[i][j]);\n            }\n        }\n\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint caves[1005][1005];\nint dy[] = {0,-1,0,1};\nint dx[] = {1,0,-1,0};\nint is_prime[1000005];\npi dp[1005][1005];\n\nvoid init()\n{\n  memset(caves, -1, sizeof(caves));\n  caves[502][502] = 1;\n  caves[502][503] = 2;\n  int x=503, y=502, d = 0;\n  for(int i=3;i<=1000000;i++){\n    int rd = (d+1)%4;\n    int ry = y+dy[rd], rx = x+dx[rd];\n    int ny = y+dy[d], nx = x+dx[d];\n    //    cout << \"rt \" << d<< \"  \"<< ry << \" \" << rx << endl;\n    if(caves[ry][rx] == -1){\n      d = (d+1)%4;\n      nx = x+dx[d], ny = y+dy[d];\n    }\n    //    cout << ny << \" \" << nx << endl;\n    caves[ny][nx] = i;\n    x = nx, y = ny;\n  }\n\n  is_prime[0] = is_prime[1] = 1;\n  for(int i=2;i<=1000000;i++){\n    if(is_prime[i]) continue;\n    for(int j=i*2;j<=1000000;j+=i) is_prime[j] = 1;\n  }\n\n  /*  rep(i, 1000){\n    if(!is_prime[i]) cout << i << endl;\n  }\n  */\n\n}\n\npi dfs(int y, int x, int m)\n{\n  if(dp[y][x] != pi(-1, -1)) return dp[y][x];\n  pi ret(0, 0);\n  //  if(caves[y][x] == 947) cout << \"ok\\n\";\n  int ny=y+1;\n  if(ny >= 1005) return ret;\n  for(int nx=x-1;nx<=x+1;nx++){\n\n    if(nx < 0 || nx >= 1005) continue;\n    if(caves[ny][nx] == -1 || caves[ny][nx] > m) continue;\n    //    if(caves[y][x] == 829) cout << caves[ny][nx] << endl;    \n    ret = max(ret, dfs(ny, nx, m));\n  }\n\n  if(!is_prime[caves[y][x]]){\n    if(ret == pi(0, 0)){\n      ret = pi(1, caves[y][x]);\n    }else{\n      ret = pi(ret.first+1, ret.second);\n    }\n  }\n  \n  return dp[y][x] = ret;\n}\n\npi solve(int m, int n)\n{\n  rep(i, 1005) rep(j, 1005){\n    if(caves[i][j] == n)\n      return dfs(i, j, m);\n  }\n  return pi(0, 0);\n}\n\nint main(){\n  init();\n  /*\n  for(int i=482;i<518;i++){\n    for(int j=484;j<516;j++) cout << caves[i][j]  << \" \";\n    cout << endl;\n  }\n  */\n  int M, N;\n  while(cin >> M >> N, M){\n    rep(i, 1005) rep(j, 1005) dp[i][j] = pi(-1, -1);    \n    pi res = solve(M, N);\n    cout << res.first << \" \" << res.second << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define SIZE 1000\n\nbool C(int dp1, int pr1, int dp2, int pr2) {\n\tif (dp2 == 0)return false;\n\tif (dp1 < dp2 || (dp1 == dp2&&pr1 < pr2))return true;\n\treturn false;\n}\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i <= SIZE&&a <= SIZE*SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x--;\n\t\t\telse x++;\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x - 1], pr[y + 1][x - 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x], pr[y + 1][x])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x + 1], pr[y + 1][x + 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\n\t\toutput = false;\n\t\tfor (int i = 0;i < SIZE&&!output;i++) {\n\t\t\tfor (int j = 0;j < SIZE&&!output;j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tprintf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint map[1001][1000], dp[1001][1000], dp2[1001][1000], sosu[1000001];\nint y[] = { 0, -1, 0, 1 }, x[] = { 1, 0, -1, 0 }, maxh, maxw, minh, minw, ansH, ansW;\nint m, n;\n\nvoid hantei(int h, int w) {\n\tmaxh = max(maxh, h);\n\tmaxw = max(maxw, w);\n\tminh = min(minh, h);\n\tminw = min(minw, w);\n}\n\nvoid setMap() {\n\tint h = 500, w = 500, muki = 0;\n\tmap[h][w] = 1;\n\tfor (int i = 2; i <= m; i++) {\n\t\tif (map[h + y[muki]][w+x[muki]] <= 0) {\n\t\t\thantei(h+y[muki], w+x[muki]);\n\t\t\tmap[h + y[muki]][w+x[muki]] = i;//????????£????????????\n\t\t\th += y[muki];\n\t\t\tw += x[muki];\n\t\t\tif (map[h][w] == n) {\n\t\t\t\tansH = h;\n\t\t\t\tansW = w;\n\t\t\t}\n\t\t\tmuki = (muki + 1) % 4;\n\t\t}\n\t\telse {\n\t\t\tif (muki - 1 >= 0) {\n\t\t\t\tmap[h + y[muki-1]][w + x[muki-1]] = i;//\n\t\t\t\th += y[muki - 1];\n\t\t\t\tw += x[muki - 1];\n\t\t\t\tif (map[h][w] == n) {\n\t\t\t\t\tansH = h;\n\t\t\t\t\tansW = w;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmap[h + y[3]][w + x[3]] = i;//\n\t\t\t\th += y[3];\n\t\t\t\tw += x[3];\n\t\t\t\tif (map[h][w] == n) {\n\t\t\t\t\tansH = h;\n\t\t\t\t\tansW = w;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid eratosthenes() {\n\tsosu[0] = 1;\n\tsosu[1] = 1;\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tif (sosu[i] == 0) {\n\t\t\tfor (int j = 2; j*i <= 1000000; j++) {\n\t\t\t\tsosu[j*i]++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid DP() {\n\tfor (int i = maxh; i >= minh; i--) {\n\t\tfor (int j = maxw; j >= minw; j--) {\n\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\tif (minw <= j + k && maxw >= j + k) {\n\t\t\t\t\tif (dp[i][j] < dp[i + 1][j + k]) {\n\t\t\t\t\t\tdp[i][j] = dp[i + 1][j + k];\n\t\t\t\t\t\tdp2[i][j] = dp2[i + 1][j + k];\n\t\t\t\t\t\t//printf(\"a1\\t\");\n\t\t\t\t\t}\n\t\t\t\t\telse if (dp[i][j] == dp[i + 1][j + k] && dp2[i][j] < dp2[i + 1][j + k]) {\n\t\t\t\t\t\tdp2[i][j] = dp2[i + 1][j + k];\n\t\t\t\t\t\t//printf(\"a2\\t\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sosu[map[i][j]] == 0) {//???????¶??????????????????¨?????????????????£????????????????????????\n\t\t\t\t//printf(\"a3\\t\");\n\t\t\t\tdp[i][j]++;\n\t\t\t\tif (dp[i][j] == 1) {\n\t\t\t\t\tdp2[i][j] = map[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << endl;\n\t}\n}\n\nint main() {\n\tvector<int>v,v2;\n\teratosthenes();\n\n\twhile (cin >> m >> n, m || n) {\n\t\tmaxh = 0, maxw = 0, minh = 9999999, minw = 9999999;\n\t\tfor (int i = 0; i < 1001;i++) {\n\t\t\tfor (int j = 0; j < 1000;j++) {\n\t\t\t\tmap[i][j] = 0;\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tdp2[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tsetMap();\n\t\tDP();\n\t\t/*int ans = 0, a = 0;\n\t\tfor (int i = minw; i <= maxw; i++) {//????????????????????????????????£??\\????????????\n\t\t\tif (dp[minh][i] > ans) {\n\t\t\t\tans = dp[minh][i];\n\t\t\t\ta = dp2[minh][i];\n\t\t\t}\n\t\t\telse if (dp[minh][i] == ans && a < dp2[minh][i]) {\n\t\t\t\ta = dp2[minh][i];\n\t\t\t}\n\t\t}*/\n\t\tv.push_back(dp[ansH][ansW]);\n\t\tv2.push_back(dp2[ansH][ansW]);\n\t\t/*for (int i = minh; i <= maxh; i++) {\n\t\t\tfor (int j = minw; j <= maxh; j++) {\n\t\t\t\tprintf(\"%4d \", dp[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tcout << endl;\n\t\tfor (int i = minh; i <= maxh; i++) {\n\t\t\tfor (int j = minw; j <= maxh; j++) {\n\t\t\t\tprintf(\"%4d \", dp2[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tcout << endl;\n\t\tfor (int i = minh; i <= maxh; i++) {\n\t\t\tfor (int j = minw; j <= maxh; j++) {\n\t\t\t\tprintf(\"%4d \", map[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t}\n\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tcout << v.at(i) << \" \" << v2.at(i) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX = 3000;\nint cave[MAX][MAX];\nint toIndex[1000010];\nint dp[MAX][MAX];\nint dx[] = {+1,+0,-1,+0};\nint dy[] = {+0,-1,+0,+1};\n\nbool isValid(int x,int y) { return 0 <= x && x < MAX && 0 <= y && y < MAX; }\n\nvoid pre_calc(){\n  memset(cave,-1,sizeof(cave));\n  int phase = 1;\n  int x = MAX/2, y = MAX/2, dir = 0;\n  while( phase <= 1000000 ){\n    toIndex[phase] = x + y * MAX;\n    cave[y][x] = phase++;\n    x += dx[dir], y += dy[dir];\n    if( cave[y+dy[(dir+1)%4]][x+dx[(dir+1)%4]] == -1 ) ( dir += 1 ) %= 4;\n  }\n}\n\nconst int  MAX_P = 1000010;\n\nbool isntprime[MAX_P+1]; \t\nvoid init(){\n  isntprime[0] = isntprime[1] = true;\n  int j;\t\n  for(int i=2;i<= MAX_P;i++)if(!isntprime[i])for(j=2*i;j<=MAX_P;j+=i)isntprime[j] = true;\n}\n\n\nvoid compute(int limit,int sp){\n  memset(dp,-1,sizeof(dp));\n  int sx = toIndex[sp] % MAX, sy = toIndex[sp] / MAX;\n  dp[sy][sx] = !isntprime[sp];\n  int maxi[2] = {0,0};\n  if( dp[sy][sx] > maxi[0] ) { maxi[0] = dp[sy][sx], maxi[1] = sp; }\n  REP(y,sy,MAX) rep(x,MAX) if( dp[y][x] != -1) {\n    for(int dx=-1;dx<=1;dx++){\n      int nx = x + dx, ny = y + 1;\n      if( !isValid(nx,ny) ) continue;\n      if( cave[ny][nx] > limit || cave[ny][nx] == -1 ) continue;\n      dp[ny][nx] = max(dp[ny][nx],dp[y][x]+!isntprime[cave[ny][nx]]);\n      if( !isntprime[cave[ny][nx]] ) {\n        if( dp[ny][nx] > maxi[0] ) { maxi[0] = dp[ny][nx]; maxi[1] = cave[ny][nx]; }\n        else if( dp[ny][nx] == maxi[0] ) maxi[1] = max(maxi[1],cave[ny][nx]);\n      }\n    }\n  }\n  cout << maxi[0] << \" \" << maxi[1] << endl;\n}\n\nint main(){\n  init();\n  pre_calc();\n  int m,n;\n  while( cin >> m >> n, m,n ) compute(m,n);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#define rep(i,n) for(lint (i) = 0;(i) < (n);(i)++)\n#define INF (1000005)\n#define SZ 1030\n#define BS 515\n#define MAX(a,b) (a)<(b)?(b):(a)\nusing namespace std;\ntypedef long long int lint;\nint go[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nint dw[3][2]={{1,-1},{1,0},{1,1}};\n\nint site[1000000+5][2];\nint prime[1000000+5];\nlint mp[SZ][SZ]={0};\n\nint main(){\n    int m,n;\n    rep(i,1000000+5){\n        prime[i]=-1;\n    }\n    prime[0]=0;\n    prime[1]=0;\n    int now = 2;\n    while(now<1000000+5){\n        if(prime[now]==0){\n            now++;\n            continue;\n        }\n        prime[now]=1;\n        lint temp = now*2;\n        while(temp<1000000+5){\n            prime[temp]=0;\n            temp+=now;\n        }\n        now++;\n    }\n    prime[1]=0;\n    rep(i,SZ){\n        rep(j,SZ){\n            mp[i][j]=INF;\n        }\n    }\n    int at[2]={BS,BS};\n\n    int dir=0;\n    for(int i = 1;i <= 1000000;i++){\n        mp[at[0]][at[1]]=i;\n        site[i][0]=at[0];\n        site[i][1]=at[1];\n        int ndir = (dir+ 1)%4;\n        if(mp[at[0]+go[ndir][0]][at[1]+go[ndir][1]]==INF){at[0]+=go[ndir][0];at[1]+=go[ndir][1];dir = ndir;}\n        else{\n            at[0]+=go[dir][0];\n            at[1]+=go[dir][1];\n        }\n    }\n    while(cin>>m>>n&&m){\n        int dp[SZ][SZ];\n        rep(i,SZ){\n            rep(j,SZ){\n                dp[i][j]=-1;\n            }\n        }\n        \n        dp[site[n][0]][site[n][1]]=prime[n];\n        for(int i=0;i<SZ-1;i++){\n            for(int j=1;j<SZ-1;j++){\n                rep(k,3){\n                    int hoge[2] = {i+dw[k][0],j+dw[k][1]};\n                    \n                    if(mp[i][j]<=m&&mp[hoge[0]][hoge[1]]<=m&&dp[i][j]!=-1){\n                        dp[hoge[0]][hoge[1]]=MAX(dp[hoge[0]][hoge[1]],dp[i][j]+prime[mp[hoge[0]][hoge[1]]]);\n                    }\n                }\n            }\n        }/*\n          for(int x = -10;x < 10;x++){\n          for(int y = -10;y < 10;y++){\n          printf(\"%5d\", dp[BS+x][BS+y]);\n          }\n          cout << endl;\n          }\n          for(int x = -10;x < 10;x++){\n          for(int y = -10;y < 10;y++){\n          printf(\"%5d\", prime[mp[BS+x][BS+y]]);\n          }\n          cout << endl;\n          }\n          for(int x = -10;x < 10;x++){\n          for(int y = -10;y < 10;y++){\n          printf(\"%ll\", mp[BS+x][BS+y]);\n          }\n          cout << endl;\n          }*/\n        lint retp = 0;\n        lint ret = 0;\n        for(int i = m;i >= 1;i--){\n            int sx = site[i][0],sy=site[i][1];\n            if(prime[i]&&dp[sx][sy]>0&&ret<dp[sx][sy]){\n                ret = dp[sx][sy];\n                retp = i;\n            }\n        }\n        cout << ret <<  \" \" << retp << endl;\n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nbool is_prime[1000001];\nint num[1000][1000];\nint x[1000001];\nint y[1000001];\nint dp[1000][1000];\nint dx[] = { 1,0,-1,0 };\nint dy[] = { 0,-1,0,1 };\nint main() {\n\tfor (int i = 2; i <= 1000000; i++) is_prime[i] = 1;\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tif (!is_prime[i]) continue;\n\t\tfor (int j = 2 * i; j <= 1000000; j += i) is_prime[j] = 0;\n\t}\n\tint len = 1;\n\tint cnt = 0;\n\tint dir = 0;\n\tmemset(num, -1, sizeof(num));\n\tnum[500][500] = 1;\n\tx[1] = 500;\n\ty[1] = 500;\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tx[i] = x[i - 1] + dx[dir];\n\t\ty[i] = y[i - 1] + dy[dir];\n\t\tnum[y[i]][x[i]] = i;\n\t\tcnt++;\n\t\tif (cnt == len) {\n\t\t\tcnt = 0;\n\t\t\tif (dir % 2) len++;\n\t\t\t(dir += 1) %= 4;\n\t\t}\n\t}\n\tint m, n;\n\twhile (cin >> m >> n, m) {\n\t\tint sx = x[n];\n\t\tint sy = y[n];\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tdp[sy][sx] = 0;\n\t\tif (is_prime[num[sy][sx]]) dp[sy][sx]++;\n\t\tfor (int i = sy; i + 1 < 1000; i++) {\n\t\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\t\tif (num[i][j] == -1 || dp[i][j] == -1) continue;\n\t\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\t\tint nx = j + k;\n\t\t\t\t\tif (0 > nx || nx >= 1000 || num[i + 1][nx] == -1) continue;\n\t\t\t\t\tdp[i + 1][nx] = max(dp[i + 1][nx], dp[i][j] + is_prime[num[i + 1][nx]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = -1;\n\t\tint t = -1;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tif (!is_prime[i]) continue;\n\t\t\tif (ans <= dp[y[i]][x[i]]) {\n\t\t\t\tans = dp[y[i]][x[i]];\n\t\t\t\tt = i;\n\t\t\t}\n\t\t}\n\t\tif (ans == -1) cout << \"0 0\" << endl;\n\t\telse cout << ans << \" \" << t << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define MAX_N 1000000\n#define MAX_X 1000\n#define MAX_Y 1000\n\nint cave[MAX_Y][MAX_X];\nbool sieve[MAX_N+1];\nint dp[MAX_N+1];\n\nint m, n;\n\nstruct P { int x, y; };\n\nP search_cave(int n) {\n    REP(y, MAX_Y) REP(x, MAX_X) {\n        if (cave[y][x] == n) {\n            return (P){x, y};\n        }\n    }\n    return (P){0, 0}; // fail\n}\n\nint main() {\n    sieve[0] = sieve[1] = true;\n    FOR(i, 2, MAX_N+1) {\n        if (sieve[i]) continue;\n        for (int j = i + i; j < MAX_N+1; j += i) {\n            sieve[j] = true;\n        }\n    }\n\n    int ul = cave[0][0] = MAX_N;\n    // left -> down -> right -> up ->\n    int d = 0;\n    int dx[] = {1, 0, -1, 0}; int dy[] = {0, 1, 0, -1};\n    int x = 0, y = 0;\n    while (ul > 1) {\n        int sx = x + dx[d];\n        int sy = y + dy[d];\n        if (0 <= sx && sx < MAX_X && 0 <= sy && sy < MAX_Y && cave[sy][sx] == 0) {\n            x = sx;\n            y = sy;\n            ul--;\n            cave[y][x] = ul;\n        } else {\n            d = (d + 1) & 3; // d % 4\n        }\n    }\n\n    while (cin >> m >> n, m|n) {\n        fill_n(dp, MAX_N+1, -1);\n        P s = search_cave(n);\n        dp[n] = 0;\n        int max_primes = 0, max_cave = 0;\n        FOR(y, s.y, MAX_Y) REP(x, MAX_X) {\n            int c = cave[y][x];\n            if (c > m || dp[c] < 0) continue;\n            if (!sieve[c]) { // prime\n                dp[c]++;\n                if (max_primes <= dp[c]) {\n                    max_primes = dp[c];\n                    max_cave = c;\n                }\n            }\n            for (int dx = -1; dx <= 1; dx++) {\n                int sx = x + dx;\n                int sy = y + 1;\n                if (0 <= sx && sx < MAX_X && 0 <= sy && sy < MAX_Y) {\n                    int c2 = cave[sy][sx];\n                    if (c2 <= m) {\n                        dp[c2] = max(dp[c2], dp[c]);\n                    }\n                }\n            }\n        }\n        cout << max_primes << \" \" << max_cave << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstdio>\n \nusing namespace std;\n \n#define out(x,l) (x<0||l<=x)\n \nconst int N = 1000000+10;\nconst int SIZE = 1010;\n \nbool isprime[N];\npair<int, int> loc[N];\nint cave[SIZE][SIZE];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, -1, 0, 1};\npair<int, int> dp[SIZE][SIZE];\n \nint main(){\n    for (int i = 0; i < N; i++) { isprime[i] = 1; } \n    isprime[0] = isprime[1] = 0;\n    for (int i = 2; i*i <= N; i++) {\n        if (!isprime[i]) continue;\n        for (int j = 2*i; j <= N; j += i) {\n            isprime[j] = 0;\n        }\n    }\n\n\tfor (int i = 0; i < SIZE; i++)\n\t\tfor (int j = 0; j < SIZE; j++)\n\t\t\tcave[i][j] = 0;\n \n    int x = SIZE/2, y = SIZE/2;\n    int cnt = 1;\n    int dir = 0;\n    int edge = 1;\n    while (1) {\n\t\tif (cnt > N) break;\n        dir %= 4;\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < edge; j++) {\n\t\t\t\tif (out(x,SIZE)||out(y,SIZE)) continue;\n                cave[y][x] = cnt;\n                loc[cnt].first = y;\n                loc[cnt].second = x;\n                x += dx[dir];\n                y += dy[dir];\n                cnt++;\n            }\n            dir++;\n        }\n        edge++;\n    }\n \n//  for (int i = 1; i < 100; i++) {\n//      cout << i << \" \" << loc[i].first << \" \" << loc[i].second << endl;\n//  }\n \n    int n, m;\n    while (cin >> m >> n, m&&n) {\n        for (int i = 0; i < SIZE; i++)\n            for (int j = 0; j < SIZE; j++) {\n                dp[i][j].first = -1;\n                dp[i][j].second = 0;\n            }\n        dp[loc[n].first][loc[n].second].first = isprime[n];\n        if (isprime[n]) dp[loc[n].first][loc[n].second].second = n;\n \n        for (int i = 0; i < SIZE; i++) {\n            for (int j = 0; j < SIZE; j++) {\n                if (cave[i][j] > m) continue;\n                pair<int, int> next; // first:the number of caves passed    second:last cave\n                next.first = -1;\n                next.second = 0;\n                bool update = 0;\n                if (!out(i-1,SIZE)&&!out(j-1,SIZE)&&dp[i-1][j-1].first!=-1) {\n                    if (dp[i-1][j-1].first > next.first) {\n                        next = dp[i-1][j-1];\n                        update = 1;\n                    } else if (dp[i-1][j-1].first == next.first && dp[i-1][j-1].second > next.second) {\n                        next = dp[i-1][j-1];\n                        update = 1;\n                    }\n                }\n                if (!out(i-1,SIZE)&&!out(j+1,SIZE)&&dp[i-1][j+1].first!=-1) {\n                    if (dp[i-1][j+1].first > next.first) {\n                        next = dp[i-1][j+1];\n                        update = 1;\n                    } else if (dp[i-1][j+1].first == next.first && dp[i-1][j+1].second > next.second) {\n                        next = dp[i-1][j+1];\n                        update = 1;\n                    }\n                }\n                if (!out(i-1,SIZE)&&!out(j,SIZE)&&dp[i-1][j].first!=-1) {\n                    if (dp[i-1][j].first > next.first) {\n                        next = dp[i-1][j];\n                        update = 1;\n                    } else if (dp[i-1][j].first == next.first && dp[i-1][j].second > next.second) {\n                        next = dp[i-1][j];\n                        update = 1;\n                    }\n                }\n                if (!update) continue;\n                if (isprime[cave[i][j]]) {\n                    next.first++;\n                    next.second = cave[i][j];\n                }\n                dp[i][j] = next;\n            }\n        }\n\n        pair<int, int> res;\n        for (int i = 0; i < SIZE; i++)\n            for (int j = 0; j < SIZE; j++)\n                if (res.first < dp[i][j].first) {\n                    res = dp[i][j];\n                } else if (res.first == dp[i][j].first&&res.second < dp[i][j].second) {\n                    res = dp[i][j];\n                }\n        cout << res.first << \" \" << res.second << endl;\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#define MAX 1002001\n#define EDGE 1001\nusing namespace std;\n\nint h[EDGE + 2][EDGE + 2], visit[EDGE + 2][EDGE + 2], lastcave[EDGE + 2][EDGE + 2];\nlong int  p[MAX];\n\nint max(int a, int b, int c){\n\treturn max(max(a, b), max(b, c));\n}\n\n\n\nint main()\n{\n\t//洞窟の作成\n\tint nowx, nowy, d, size, sizecounter;\n\tnowx = (EDGE - 1) / 2;\n\tnowy = (EDGE + 1) / 2;\n\td = 0;\n\tsize = 1;\n\tsizecounter = 0;\n\tfor (int i = 0; i <= MAX; i++){\n\t\th[nowy][nowx] = i;\n\t\tif (d == 0){\n\t\t\tnowx++;\n\t\t}\n\t\telse if (d == 1){\n\t\t\tnowy--;\n\t\t}\n\t\telse if (d == 2){\n\t\t\tnowx--;\n\t\t}\n\t\telse if (d == 3){\n\t\t\tnowy++;\n\t\t}\n\t\tif (sizecounter == size){\n\t\t\tsizecounter = 0;\n\t\t\td = (d + 1) % 4;\n\t\t\tif (d == 0 || d == 2){\n\t\t\t\tsize++;\n\t\t\t}\n\t\t}\n\t\tsizecounter++;\n\t}\n\n\t//素数の判定用配列を作成\n\tp[1] = 0;\n\tfill(p, p + MAX, 1);\n\tfor (long int i = 2; i <= MAX; i++){\n\t\tint sqrti = (int)sqrt(i);\n\t\tfor (int j = 2; j <= sqrti; j++){\n\t\t\tif (i % j == 0){\n\t\t\t\tp[i] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t//入力\n\tint m, n;\n\twhile (cin >> m >> n, m || n){\n\n\t\t//初期化\n\t\tint goalcave = 0;\n\t\tint cavecounter = 0;\n\t\tfor (int i = 0; i < EDGE + 2; i++){\n\t\t\tfor (int j = 0; j < EDGE + 2; j++){\n\t\t\t\tvisit[i][j] = 0;\n\t\t\t\tlastcave[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\n\t\t//脱出する直前の洞窟のyを求める．\n\t\tbool flag = false;\n\t\tfor (int i = EDGE + 1; i > 0; i--){\n\t\t\tfor (int j = 0; j < EDGE + 2; j++){\n\t\t\t\tif (0 < h[i][j] && h[i][j] <= m){\n\t\t\t\t\tgoalcave = i;\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t//下から順に計算\n\t\tfor (int i = goalcave; i > 0; i--){\n\t\t\tfor (int j = 0; j < EDGE + 2; j++){\n\t\t\t\tif (h[i][j] <= m){\n\n\t\t\t\t\t//visitを求める\n\t\t\t\t\tif (p[h[i][j]]){\n\t\t\t\t\t\tvisit[i][j] = max(visit[i + 1][j - 1], visit[i + 1][j], visit[i + 1][j + 1]) + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tvisit[i][j] = max(visit[i + 1][j - 1], visit[i + 1][j], visit[i + 1][j + 1]);\n\t\t\t\t\t}\n\n\t\t\t\t\t//lastcaveを求める\n\t\t\t\t\tif (visit[i + 1][j - 1] > visit[i + 1][j] && visit[i + 1][j - 1] > visit[i + 1][j + 1]){\n\t\t\t\t\t\tlastcave[i][j] = lastcave[i + 1][j - 1];\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j] > visit[i + 1][j - 1] && visit[i + 1][j] > visit[i + 1][j + 1]){\n\t\t\t\t\t\tlastcave[i][j] = lastcave[i + 1][j];\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j + 1] > visit[i + 1][j - 1] && visit[i + 1][j + 1] > visit[i + 1][j]){\n\t\t\t\t\t\tlastcave[i][j] = lastcave[i + 1][j + 1];\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j - 1] == visit[i + 1][j] && visit[i + 1][j - 1] > visit[i + 1][j + 1]){\n\t\t\t\t\t\tlastcave[i][j] = max(lastcave[i + 1][j - 1], lastcave[i + 1][j]);\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j] == visit[i + 1][j + 1] && visit[i + 1][j] > visit[i + 1][j - 1]){\n\t\t\t\t\t\tlastcave[i][j] = max(lastcave[i + 1][j], lastcave[i + 1][j + 1]);\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j + 1] == visit[i + 1][j - 1] && visit[i + 1][j + 1] > visit[i + 1][j]){\n\t\t\t\t\t\tlastcave[i][j] = max(lastcave[i + 1][j + 1], lastcave[i + 1][j - 1]);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlastcave[i][j] = max(lastcave[i + 1][j + 1], lastcave[i + 1][j], lastcave[i + 1][j - 1]);\n\t\t\t\t\t}\n\t\t\t\t\tif (p[h[i][j]] && lastcave[i][j] == 0){\n\t\t\t\t\t\tlastcave[i][j] = h[i][j];\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t//出力\n\t\t\t\tif (h[i][j] == n){\n\t\t\t\t\tcout << visit[i][j] << \" \" << lastcave[i][j] << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef long long i64,ll;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,l,r) for(int i=(l);i<(int)(r);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T pmod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\nclass Task{\npublic:\n\tint y,x;\n\tint c,M;\n\tTask(int y,int x,int c,int M):y(y),x(x),c(c),M(M){}\n\tbool operator < (const Task& r) const{\n\t\tif(c!=r.c)return c<r.c;\n\t\treturn M<r.M;\n\t}\n};\nint INF=1<<28;\n\n\n\tint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\n\nclass Main{\npublic:\n\t\n\tint m,n;\n\tbool input(){\n\t\tcin >> m >> n;if(m==0 && n==0)return false;\n\t\treturn true;\n\t}\n\n\tvector<bool> sieve(const int M){\n\t\tvector<bool> isPrime(M);\n\t\tfor(int i=2;i<M;i++) isPrime[i] = true;\n\t\tfor(int i=2;i*i < M;i++){\n\t\t\tif(! isPrime[i]) continue;\n\t\t\tfor(int j=i*i;j<M;j+=i)isPrime[j] = false;\n\t\t}\n\t\treturn isPrime;\n\t}\n\n\tbool comp(int c1,int M1,int c2,int M2){\n\t\tif(c1!=c2)return c1<c2;\n\t\treturn M1<M2;\n\t}\n\n\n\tvoid run(){\n\t\t//prime\n\t\tvector<bool> ps=sieve(4000050);\n\n\t\tvector<vector<int>> board(2100,vector<int>(2100));\n\t\tvector<int> xs(4000050),ys(4000050);\n\n\t\tint y=1050,x=1050,v=1;\n\t\tboard[y][x]=v;xs[v]=x;ys[v]=y;v++;\n\t\tint d=1,dir=0;\n\t\twhile(v<3000050){\n\n\t\t\tREP(_d,d){\n\t\t\t\ty+=dy[dir];x+=dx[dir];\n\t\t\t\tboard[y][x]=v;xs[v]=x;ys[v]=y;v++;\n\t\t\t}\n\t\t\tdir=(dir-1+4)%4;\n\t\t\tif(dir%2==0)d++;\n\t\t}\n\n\t\twhile(input()){\n\t\t\tvector<vector<pair<int,int>>> dp(2100,vector<pair<int,int>>(2100,make_pair(-INF,-INF)));\n\n\n\t\t\tpair<int,int> res=make_pair(0,0);\n\n\t\t\tint pc=0,pM=0;\n\t\t\tif(ps[n])pc++,pM=n;\n\t\t\tdp[ys[n]][xs[n]]=make_pair(pc,pM);\n\t\t\tfor(int y=ys[n];y<2100;y++){\n\t\t\t\tREP(x,2100){\n\t\t\t\t\tfor(int dx=-1;dx<=1;dx++){//move\n\t\t\t\t\t\tint nx=x+dx,ny=y+1;if(!IN(0,ny,2100)|| !IN(0,nx,2100))continue;\n\t\t\t\t\t\tint nv=board[ny][nx];if(!(nv<=m))continue;\n\t\t\t\t\t\tint nc=dp[y][x].first,nM=dp[y][x].second;\n\t\t\t\t\t\tif(ps[nv])nc++,nM=nv;\n\t\t\t\t\t\tif(comp(dp[ny][nx].first,dp[ny][nx].second,nc,nM)){\n\t\t\t\t\t\t\tdp[ny][nx]=make_pair(nc, nM);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t//end\n\t\t\t\t\tbool end=true;\n\t\t\t\t\tfor(int dx=-1;dx<=1;dx++){\n\t\t\t\t\t\tint nx=x+dx,ny=y+1;if(!IN(0,ny,2100)|| !IN(0,nx,2100))continue;\n\t\t\t\t\t\tint nv=board[ny][nx];if(!(nv<=m))continue;\n\t\t\t\t\t\tend=false;\n\t\t\t\t\t}\n\t\t\t\t\tif(end)res=max(dp[y][x],res);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout <<res.first <<\" \"<<res.second<<endl;\n\t\t}\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\n\nconst int MAX = 1000001;\nbool pri[MAX];\nvector<int>v;\nmap<int,pair<int,int> >pos;\nint field[1201][1201];\nint N,M;\n\nvoid make(){\n  int cnt = 2;\n  int c = 1;\n  int x = 500,y=500;\n  int cc = 0;\n  field[500][500] = 1;\n  pos[1] = make_pair(500,500);\n\n  while(cnt < 1000000){\n    for(int i=0; i<4; i++){\n      if(cc == 2){cc = 0; c++;}\n      int nx = x, ny = y;\n      for(int j=0; j<c; j++){\n\tnx += dx[i];\n\tny += dy[i];\n\tpos[cnt] = make_pair(ny,nx);\n\tfield[ny][nx] = cnt++;\n      }\n\n      x = nx, y = ny;\n      cc++;\n    }\n  }\n}\n\nvoid createPrime(){\n  fill(pri,pri+MAX,1);\n  pri[0] = pri[1] = 0;\n  for(int i=2; i*i<MAX; i++){\n    for(int j=2*i; j<MAX; j+=i){\n      pri[j] = false;\n    }\n  }\n\n  for(int i=2; i<MAX; i++) if(pri[i]) v.push_back(i);\n}\n\nbool compare(pair<int,int>p, pair<int,int>p2){\n  if(p.first == p2.first){\n    return p.second > p2.second;\n  }\n  return p.first > p2.first;\n}\n\nint main(){\n  make();\n  createPrime();\n\n  while(cin >> M >> N,M|N){\n    pair<int,int> p = pos[N];\n    int sx = p.second, sy = p.first;\n    bool F = false;\n\n    static bool used[1200][1200];\n    static pair<int,int> dp[1200][1200];\n    memset(used,0,sizeof(used));\n    memset(dp,0,sizeof(dp));\n\n    if(binary_search(v.begin(),v.end(),field[sy][sx])){\n      dp[sy][sx].first = 1;\n      dp[sy][sx].second = field[sy][sx];\n    }\n    used[sy][sx] = true;\n\n    for(int i=sy; i<=1000; i++){\n      for(int j=0; j<=1000; j++){\n\tfor(int k=-1; k<=1; k++){\n\t  if(!used[i][j])continue;\n\t  int nx = j + k;\n\t  if(nx < 0 || nx > 1000)continue;\n\t  if(field[i+1][nx] > M)continue;\n\n\t  used[i+1][nx] = true;\n\t  int value = binary_search(v.begin(),v.end(),field[i+1][nx]);\n\t  \n\t  if(value){\n\t    //\t    cout << \"i = \" << i << \" j = \" << nx << endl;\n\t    //\t    cout << field[i+1][nx] << endl;\n\t    if(dp[i+1][nx].first < dp[i][j].first + 1){\n\t      dp[i+1][nx].first = dp[i][j].first + 1;\n\t      dp[i+1][nx].second = field[i+1][nx];\n\t    }\n\t  } else {\n\t    dp[i+1][nx] = max(dp[i+1][nx],dp[i][j]);\n\t  }\n\t}\n      }\n    }\n\n    vector<pair<int,int> >ans;\n\n    for(int i=0; i<=1000; i++){\n      for(int j=0; j<=1000; j++){\n\tif(field[i][j] > M)continue;\n\tif(dp[i][j].first == 0)continue;\n\tans.push_back(dp[i][j]);\n      }\n    }\n\n\n    if(ans.size() == 0){cout << \"0 0\" << endl;}\n    else{\n      sort(ans.begin(),ans.end(),compare);\n      cout << ans[0].first << \" \" << ans[0].second << endl;\n    }\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\n#define MP make_pair\n#define PB push_back\n#define MAX_N 1000001\n#define SIZE 1001\n#define X first\n#define Y second\n\nconst int STX = 500, STY = 500;\n\nint id[SIZE][SIZE];\nbool is_prime[MAX_N+1];\nvector<pair<int, int> > coord;\n\nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++) {\n    if(is_prime[i]) {\n      for(int j=i*i; j<=MAX_N; j+=i) {\n\tis_prime[j] = false;\n      }\n    }\n  }\n}\n\nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  /*\n  const int dx[] = {1,0,-1,0};\n  const int dy[] = {0,-1,0,1};\n  */\n  coord.PB(MP(0, 0)); // no use\n  coord.PB(MP(x, y)); // cnt = 1\n  cnt ++;\n\n  fill(id[0], id[0]+SIZE*SIZE+1, -1);\n  \n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt <= MAX_N) {\n    a += 2;\n    for(int i=0; i<a; i++) {\n      y --;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      x --;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      y ++;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      x ++;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    x++, y++;\n  }\n}\n\nint dp[MAX_N+1];\n\nint main() {\n  \n  Sieve();\n  MakeMap();\n  \n  int m, n;\n  \n  while(cin >> m >> n && (m|n)) {\n    fill(dp, dp+m+1, -1);\n    dp[n] = is_prime[n];\n    \n    queue<pair<int, int> > que;\n    que.push(coord[n]);\n    \n    while(!que.empty()) {\n      pair<int, int> now = que.front(); que.pop();\n      int noid = id[now.Y][now.X];\n      \n      for(int i=-1; i<=1; i++) {\n\tpair<int, int> nex = MP(now.X+i, now.Y+1);\n\tif(nex.X < 0 || SIZE <= nex.X || nex.Y < 0 || SIZE <= nex.Y) continue;\n\tint neid = id[nex.Y][nex.X];\n\tif(neid <= m) {\n\t  if(dp[neid] < dp[noid] + is_prime[neid]) {\n\t    dp[neid] = dp[noid] + is_prime[neid];\n\t    que.push(nex);\n\t  }\n\t}\n      }\n    }\n    \n    int res = dp[n], lastid;\n    if(is_prime[n]) lastid = n;\n    else lastid = -1;\n    \n    for(int i=1; i<=m; i++) {\n      if(res <= dp[i] && is_prime[i]) {\n\tres = dp[i];\n\tlastid = max(lastid, i);\n      }\n    }\n    \n    if(res == 0) cout << \"0 0\" << endl;\n    else cout << res << \" \" << lastid << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppi;\n\n#define INF 1000000000\n#define MAX 1000000\n#define SQRT 1000\n\n// sieve of Eratosthenes (prime num)\nbool p[MAX+1]; //prime number=true\nvoid prime(){\n  int n=MAX;\n  rep(i,n+1) p[i]=true;\n  p[0]=p[1]=false;\n  for(int i=2;i<=n;i++){\n    if(p[i]){\n      for(int j=i*2; j<=n; j+=i){\n\tp[j]=false;\n      }\n    }\n  }\n}\n\n\nint mat[SQRT][SQRT];\npii tb[MAX+1];\n\nint dp_n[MAX+1]; //num\nint dp_l[MAX+1]; //last prime cave\n\n// from n, max m return<num,last>\npii search(int m, int n){\n  if(dp_n[n] != -1) return mp(dp_n[n],dp_l[n]);\n\n  pii now=tb[n];\n  vector<pii> vp;\n  for(int i=-1; i<=1; i++){\n    int nx=now.first+i, ny=now.second-1;\n    if(nx>=0 && nx<SQRT && ny>=0 && mat[nx][ny]<=m){\n      vp.pb(search(m, mat[nx][ny]));\n    }\n  }\n\n  pii mxp=mp(0,0);\n  rep(i,vp.size()){\n    mxp =max(mxp, vp[i]);\n  }\n\n  if(p[n]){\n    mxp.first++;\n    if(mxp.second==0) mxp.second=n;\n  }\n  dp_n[n] = mxp.first;\n  dp_l[n] = mxp.second;\n  return mxp;\n}\n\nint main(){\n  prime();\n\n  // set-up tables\n  int x=499, y=499;\n  int dx[]={1,0,-1,0}, dy[]={0,1,0,-1};\n  int i=1, d=0;\n  while(i<=MAX){\n    int ddx = dx[d%4];\n    int ddy = dy[d%4];\n    rep(j,(d+2)/2){\n      mat[x][y]=i;\n      tb[i]=mp(x,y);\n      x += ddx;\n      y += ddy;\n      i++;\n    }\n    d++;\n  }\n\n  int m,n;\n  while(cin>>m>>n, m|n){\n    fill(dp_n, dp_n+m+1, -1);\n    fill(dp_l, dp_l+m+1, -1);\n    pii r = search(m,n);\n    cout << r.first << \" \" << r.second <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <utility>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <set>\nusing namespace std;\n\nusing P = pair<int, int>;\nusing QP = pair<int, int>;  // (テゥツ?づァツつケ, テ・ツ?、)\nusing dp1P = P;\n\nconst int MAX_M = 1000010;\n\nbool prime_table[MAX_M];\nmap<P, int> cave;\nmap<int, P> num2pos;\n\nint dp1[MAX_M],\n    dp2[MAX_M];\n\nint dy[4] = {0, 1, 0, -1},\n    dx[4] = {1, 0, -1, 0};\n\nvoid sieve() {\n    for (int i = 2; i < MAX_M; i++) {\n        prime_table[i] = true;\n    }\n    for (int m = 2; m * m <= MAX_M; m++) {\n        if (prime_table[m]) {\n            for (int i = 2; i * m < MAX_M; i++) {\n                prime_table[i * m] = false;\n            }\n        }\n    }\n}\n\nint main() {\n    // テヲツエツ榲ァツェツ淌」ツ?ョテヲツァツ凝ァツッツ?\n    int num = 1, x = 0, y = 0, dir = 3;\n    cave[P(x, y)] = num;\n    num2pos[num] = P(x, y);\n    num++;\n\n    for (int i = 0; i < MAX_M - 5; i++) {\n        int ndir = (dir + 1) % 4,\n            nx = x + dx[ndir],\n            ny = y + dy[ndir];\n        // テ・ツ?・テ」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝」ツ?凝・ツ青ヲテ」ツ??\n        if (cave.count(P(nx, ny)) == 0) {\n            x = nx;\n            y = ny;\n            dir = ndir;\n        } else {\n            x = x + dx[dir],\n            y = y + dy[dir];\n        }\n        cave[P(x, y)] = num;\n        num2pos[num] = P(x, y);\n        num++;\n    }\n\n    sieve();\n\n    int m, n;\n    while (cin >> m >> n, m | n) {\n        memset(dp1, -1, sizeof(dp1));\n        memset(dp2, 0, sizeof(dp2));\n\n        queue<P> que;\n        que.push(QP(n, prime_table[n]));\n\n        dp1[n] = prime_table[n];\n        dp2[n] = prime_table[n] ? n : 0;\n\n        set<int> set;\n        set.insert(n);\n        while (!que.empty()) {\n            auto qp = que.front(); que.pop();\n            // if (dp1[qp.first] > qp.second) continue;\n\n            P pos = num2pos[qp.first];\n            for (int ddx = -1; ddx <= 1; ddx++) {\n                int nx = pos.first + ddx,\n                    ny = pos.second - 1;\n                if (cave.count(P(nx, ny)) == 0 || cave[P(nx, ny)] > m) continue;\n                int nnum = cave[P(nx, ny)],\n                    prime_num = dp1[qp.first] + (prime_table[nnum]);\n\n                if (dp1[nnum] < prime_num) {\n                    dp1[nnum] = prime_num;\n                    dp2[nnum] = dp1[qp.first];\n\n                    if (prime_table[nnum]) dp2[nnum] = nnum;\n\n                    if (set.count(nnum) == 0) {\n                        que.push(QP(nnum, dp1[nnum]));\n                        set.insert(nnum);\n                    }\n                } else if (dp1[nnum] == prime_num && dp2[nnum] < dp2[qp.first]) {\n                    dp2[nnum] = dp2[qp.first];\n\n                    if (prime_table[nnum]) dp2[nnum] = nnum;\n                }\n            }\n        }\n        int prime_num = 0, last_prime = 0;\n        for (int i = 1; i <= m; i++) {\n            if (prime_num < dp1[i]) {\n                prime_num = dp1[i];\n                last_prime = dp2[i];\n            } else if (prime_num == dp1[i] && last_prime < dp2[i]) {\n                prime_num = dp1[i];\n                last_prime = dp2[i];\n            }\n        }\n        cout << prime_num << \" \" << last_prime << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n  \nusing namespace std;\n  \n#define MP make_pair\n#define PB push_back\n#define MAX_N 1001000\n#define SIZE 1200\n#define X first\n#define Y second\n  \nconst int STX = 600, STY = 600;\n  \nint id[SIZE][SIZE];\nbool is_prime[MAX_N+1];\nvector<pair<int, int> > coord;\n  \nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++) {\n    if(is_prime[i]) {\n      for(int j=i*i; j<=MAX_N; j+=i) {\n\t\tis_prime[j] = false;\n      }\n    }\n  }\n}\n  \nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  \n  coord.PB(MP(0, 0)); // no use\n  cnt ++;\n  coord.PB(MP(x, y)); // cnt = 1\n  \n  fill(id[0], id[0]+SIZE*SIZE+1, -1);\n  \n  const int dx[] = {0,-1,0,1};\n  const int dy[] = {-1,0,1,0};\n  \n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt <= MAX_N) {\n\ta += 2;\n\tfor(int turn=0; turn<4; turn++) {\n\t  for(int i=0; i<a; i++) {\n\t\tx += dx[turn], y += dy[turn];\n\t\tcoord.PB(MP(x, y));\n\t\tid[y][x] = ++ cnt;\n\t  }\n\t}\n\tx++, y++;\n  }\n}\n  \nint dp[MAX_N+1];\n  \nint main() {\n    \n  Sieve();\n  MakeMap();\n    \n  int m, n;\n    \n  while(cin >> m >> n && (m|n)) {\n    fill(dp, dp+MAX_N+1, -1);\n    dp[n] = is_prime[n];\n\t\n    queue<pair<int, int> > que;\n    que.push(coord[n]);\n    \n    while(!que.empty()) {\n      pair<int, int> now = que.front(); que.pop();\n      int noid = id[now.Y][now.X];\n      \n      for(int i=-1; i<=1; i++) {\n\t\tpair<int, int> nex = MP(now.X+i, now.Y+1);\n\t\tif(nex.X < 0 || SIZE <= nex.X || nex.Y < 0 || SIZE <= nex.Y) continue;\n\t\tint neid = id[nex.Y][nex.X];\n\t\tif(neid < m) {\n\t\t  if(dp[neid] < dp[noid] + is_prime[neid]) {\n\t\t\tdp[neid] = dp[noid] + is_prime[neid];\n\t\t\tque.push(nex);\n\t\t  }\n\t\t}\n      }\n    }\n\t\n    int res = dp[n], lastid = -1;\n    if(is_prime[n]) lastid = n;\n    \n    for(int i=1; i<=m; i++) {\n      if(res <= dp[i] && is_prime[i]) {\n\t\tres = dp[i];\n\t\tlastid = max(lastid, i);\n      }\n    }\n\t\n    if(lastid == -1) cout << \"0 0\" << endl;\n    else cout << res << \" \" << lastid << endl;\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\npair<int, int> dp[1000001]; // scroll, last cave\nint isVisited[1000001];\nbool pcheck[1000001];\n\nint n, m;\nint caseN;\n\nint prec[10][3] = {{0, 0, 0}, {7, 8, 9}, {8, 9, 10}, {1, 2, 11}, {1, 2, 6}, {1, 6, 19}, {7, 8, 20}, {21, 22, 23}, {22, 23, 24}, {23, 24, 25}};\n\nvector <int> sqr;\n\nint arr[2000][2000];\nint hash[1000001][2];\n\nvector <int> getNext(int tar)\n{\n\tvector <int> ret;\n\tint y = hash[tar][0], x = hash[tar][1];\n\tret.push_back(arr[y - 1][x - 1]);\n\tret.push_back(arr[y - 1][x]);\n\tret.push_back(arr[y - 1][x + 1]);\n\treturn ret;\n}\n\npair<int, int> getAns(int ith)\n{\n\tif(ith > m) return make_pair(0, 0);\n\tpair<int, int> &ret = dp[ith];\n\tif(isVisited[ith] == caseN) return ret;\n\tisVisited[ith] = caseN;\n\n\tbool flag = (pcheck[ith] == false);\n\n\tif(flag) ret = make_pair(1, ith);\n\telse ret = make_pair(0, 0);\n\t\n\tvector <int> next = getNext(ith);\n\tfor(int i=0;i<next.size();i++)\n\t{\n\t\tpair<int, int> res = getAns(next[i]);\n\t\tif(ret.first < res.first + flag)\n\t\t{\n\t\t\tret = res;\n\t\t\tret.first += flag;\n\t\t}\n\t\telse if (ret.first == res.first + flag) ret.second = max(ret.second, res.second);\n\t}\n\n\treturn ret;\t\t\n}\n\nint main(void)\n{\n\tfor(int i=2;i<=1000000;i++)\n\t{\n\t\tif(pcheck[i]) continue;\n\t\tfor(int j=i*2;j<=1000000;j+=i) pcheck[j] = true;\n\t}\n\n\tfor(int i=1;i*i<=1000000;i+=2) sqr.push_back(i*i);\n\n\tint y = 1000, x = 1000;\n\tarr[y][x] = 1;\n\thash[1][0] = y, hash[1][1] = x;\n\tint cur = 2;\n\tint len = 3;\n\tx++;\n\tint mov[4][2] = {{1, 0}, {0, -1}, {-1, 0}, {0, 1}};\n\tdo\n\t{\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tfor(int j=0;j<len-1;j++) \n\t\t\t{ \n\t\t\t\thash[cur][0] = y, hash[cur][1] = x; \n\t\t\t\tarr[y][x] = cur++;\n\t\t\t\ty += mov[i][0];\n\t\t\t\tx += mov[i][1];\n\n\t\t\t}\n\t\t\t\n\t\t\tif(i < 3)\n\t\t\t{\n\t\t\t\ty -= mov[i][0], x -= mov[i][1];\n\t\t\t\ty += mov[i + 1][0], x += mov[i + 1][1];\n\t\t\t}\n\t\t}\n\t\tlen += 2;\n\t} while(cur <= 1000000);\n\n\twhile(scanf(\"%d %d\", &m, &n), n)\n\t{\n\t\tcaseN++;\n\t\tpair <int, int> ans = getAns(n);\n\t\tprintf(\"%d %d\\n\", ans.first, ans.second);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <set>\n\nusing namespace std;\nint caves[1003][1003]={};\nint dp[1003][1003]={};\nbool flag[1003][1003]={};\nint dp2[1003][1003]={};\n\nvoid solve(int m,int n,set<int> prime){\n\tfor(int i=0;i<1003;i++){\n\t\tfor(int j=0;j<1003;j++){\n\t\t\tcaves[i][j]=0;\n\t\t\tdp[i][j]=0;\n\t\t\tflag[i][j]=0;\n\t\t\tdp2[i][j]=0;\n\t\t}\n\t}\n\tcaves[500][500]=1;\n\tint now_tate = 500;\n\tint now_yoko = 500;\n\tint x = 1;\n\tbool breakflag=0;\n\tint ans_tate,ans_yoko;\n\tif(n==1){\n\t\tans_tate=500;\n\t\tans_yoko=500;\n\t}\n\tfor(int i=1;i<10000;i++){\n\t\tfor(int j=0;j<2;j++){\n\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\tx+=1;\n\t\t\t\tif(x>m){\n\t\t\t\t\tbreakflag=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(i%2==1){\n\t\t\t\t\tif(j==0){\n\t\t\t\t\t\tnow_yoko +=1;\n\t\t\t\t\t\tcaves[now_tate][now_yoko]=x;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnow_tate -=1;\n\t\t\t\t\t\tcaves[now_tate][now_yoko]=x;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(j==0){\n\t\t\t\t\t\tnow_yoko -=1;\n\t\t\t\t\t\tcaves[now_tate][now_yoko]=x;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnow_tate +=1;\n\t\t\t\t\t\tcaves[now_tate][now_yoko]=x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(x==n){\n\t\t\t\t\tans_tate = now_tate;\n\t\t\t\t\tans_yoko = now_yoko;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(breakflag==1)break;\n\t}\n\tfor(int i=0;i<1003;i++){\n\t\tfor(int j=0;j<1003;j++){\n\t\t\tif(prime.count(caves[i][j])){\n\t\t\t\tflag[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1002;i>=0;i--){\n\t\tfor(int j=0;j<1003;j++){\n\t\t\tif(i==1002){\n\t\t\t\tif(flag[i][j]==1){\n\t\t\t\t\tdp[i][j]=1;\n\t\t\t\t\tdp2[i][j]=caves[i][j];\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdp[i][j]=dp[i+1][j];\n\t\t\t\tif(dp[i][j]!=0){\n\t\t\t\t\tdp2[i][j] = dp2[i+1][j];\n\t\t\t\t}\n\t\t\t\tdp[i][j]=max(dp[i][j],dp[i+1][j+1]);\n\t\t\t\tif(dp[i+1][j]<dp[i+1][j+1]){\n\t\t\t\t\tdp2[i][j] = dp2[i+1][j+1];\n\t\t\t\t}\n\t\t\t\tif(dp[i+1][j]==dp[i+1][j+1]&&dp[i+1][j]!=0){\n\t\t\t\t\tdp2[i][j]=max(dp2[i+1][j],dp2[i+1][j+1]);\n\t\t\t\t}\n\t\t\t\tif(j>0){\n\t\t\t\t\tif(dp[i][j]<dp[i+1][j-1]){\n\t\t\t\t\t\tdp2[i][j] = dp2[i+1][j-1];\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[i+1][j-1]==dp[i][j]&&dp[i+1][j-1]!=0){\n\t\t\t\t\t\tdp2[i][j]=max(dp2[i][j],dp2[i+1][j-1]);\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i+1][j-1]);\n\t\t\t\t}\n\t\t\t\tif(flag[i][j]==1){\n\t\t\t\t\tif(dp2[i][j]==0){\n\t\t\t\t\t\tdp2[i][j]=caves[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j]+=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[ans_tate][ans_yoko] << \" \" << dp2[ans_tate][ans_yoko] << endl;\n\treturn ;\n}\n\n\n\nint main(){\n\tvector<int> vec;\n\tset<int> prime;\n\tvec.push_back(2);\n\tprime.insert(2);\n\tbool flag1=0;\n\tfor(int i=3;i<1000000;i++){\n\t\tflag1 = 0;\n\t\tfor(int j=0;j<vec.size();j++){\n\t\t\tif(i%vec[j]==0){\n\t\t\t\tflag1=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(vec[j]>sqrt((double)i)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag1==0){\n\t\t\tvec.push_back(i);\n\t\t\tprime.insert(i);\n\t\t}\n\t}\n\tint m,n;\n\twhile(1){\n\t\tcin >> m >> n;\n\t\tif(m==0&&n==0)break;\n\t\tsolve(m,n,prime);\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE * SIZE + 1];\n\tint table[SIZE][SIZE];\n\tint dp[SIZE][SIZE];\n\tint pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tint res1, res2;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d %d\", &m, &n);\n\t\tif (m == 0 || n == 0)return 0;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = SIZE - 1;i >= 0;i--){\n\t\t\tfor(int j = SIZE - 1;j >= 0;j--){\n\t\t\t\tif (table[i][j] <= m) {\n\t\t\t\t\tif (i + 1 < SIZE) {\n\t\t\t\t\t\tif (j > 0 && table[i + 1][j - 1] <= m && (dp[i][j] < dp[i + 1][j - 1] || (dp[i][j] == dp[i + 1][j - 1] && pr[i][j] < pr[i + 1][j - 1]))) {\n\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j - 1];\n\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j - 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (table[i + 1][j] <= m && (dp[i][j] < dp[i + 1][j] || (dp[i][j] == dp[i + 1][j] && pr[i][j] < pr[i + 1][j]))) {\n\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j];\n\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j + 1 < SIZE && table[i + 1][j + 1] <= m && (dp[i][j] < dp[i + 1][j + 1] || (dp[i][j] == dp[i + 1][j + 1] && pr[i][j] < pr[i + 1][j + 1]))) {\n\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j + 1];\n\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!prime[table[i][j]]) {\n\t\t\t\t\t\tdp[i][j]++;\n\t\t\t\t\t\tif (pr[i][j] == 0) {\n\t\t\t\t\t\t\tpr[i][j] = table[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tprintf(\"%d %d\\n\", dp[i][j], pr[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t/*\n\t\toutput = false;\n\t\tfor (int h = 0;h < SIZE && (!output);h++) {\n\t\t\tfor (int w = 0;w < SIZE && (!output);w++) {\n\t\t\t\tif (table[h][w] == n) {\n\t\t\t\t\t//printf(\"%d %d\\n\", dp[i][j], pr[i][j]);\n\t\t\t\t\tcout << dp[h][w] << endl;\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE + 10][SIZE + 10], dp[SIZE + 10][SIZE + 10], pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (y>=0&&x>=0&&table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t*/\n\t\tfor (int h = 0;h < SIZE;h++) {\n\t\t\tfor (int w = 0;w < SIZE;w++) {\n\t\t\t\tif (table[h][w] == n) {\n\t\t\t\t\tcout << dp[h][w] << \" \" << pr[h][w] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nusing namespace std;\n  \n#define MP make_pair\n#define PB push_back\n#define MAX_N 2001000\n#define SIZE 2000\n#define X first\n#define Y second\n  \nconst int STX = 1000, STY = 1000;\n  \nint id[SIZE][SIZE];\nbool is_prime[MAX_N+1];\nvector<pair<int, int> > coord;\n\nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++) {\n    if(is_prime[i]) {\n      for(int j=i*i; j<=MAX_N; j+=i) {\n\tis_prime[j] = false;\n      }\n    }\n  }\n}\n\nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  \n  coord.PB(MP(0, 0)); // no use\n  cnt ++;\n  coord.PB(MP(x, y)); // cnt = 1\n  \n  fill(id[0], id[0]+SIZE*SIZE+1, -1);\n  \n  const int dx[] = {0,-1,0,1};\n  const int dy[] = {-1,0,1,0};\n  \n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt <= MAX_N) {\n    a += 2;\n    for(int turn=0; turn<4; turn++) {\n      for(int i=0; i<a; i++) {\n\tx += dx[turn], y += dy[turn];\n\tcoord.PB(MP(x, y));\n\tid[y][x] = ++ cnt;\n      }\n    }\n    x++, y++;\n  }\n}\n\nint dp[MAX_N+1];\n\nint main() {\n  \n  Sieve();\n  MakeMap();\n  \n  int m, n;\n\n  while(cin >> m >> n && (m|n)) {\n    \n    //bool ok = false;\n    \n    fill(dp, dp+MAX_N+1, -1);\n    dp[n] = is_prime[n];\n    pair<int, int> ans(dp[n], n);\n    \n    queue<pair<int, int> > que;\n    que.push(coord[n]);\n    queue<int> q_dp;\n    q_dp.push(dp[n]);\n    while(!que.empty()) {\n      pair<int, int> now = que.front(); que.pop();\n      int tmp = q_dp.front(); q_dp.pop();\n      int tmpid = id[now.Y][now.X];\n      if(tmp < dp[tmpid]) continue;\n      \n      int noid = id[now.Y][now.X];\n      \n      for(int i=-1; i<=1; i++) {\n\tpair<int, int> nex = MP(now.X+i, now.Y+1);\n\tif(nex.X < 0 || SIZE <= nex.X || nex.Y < 0 || SIZE <= nex.Y) continue;\n\tint neid = id[nex.Y][nex.X];\n\tif(neid <= m) {\n\t  if(dp[neid] < dp[noid] + is_prime[neid]) {\n\t    dp[neid] = dp[noid] + is_prime[neid];\n\t    //if(is_prime[neid]) ok = true;\n\t    ans = max(ans, make_pair(dp[neid], neid));\n\t    que.push(nex);\n\t    q_dp.push(dp[neid]);\n\t  }\n\t}\n      }\n\n    }\n    \n    /*\n    int res = dp[n], lastid = -1;\n    if(is_prime[n]) lastid = n;\n    \n    for(int i=1; i<=m; i++) {\n      if(res <= dp[i] && is_prime[i]) {\n\tres = dp[i];\n\tlastid = max(lastid, i);\n      }\n    }\n    */\n    if(ans.first == 0) cout << \"0 0\" << endl;\n    else {\n      int ans2 = 2;\n      cout << ans.first << \" \";\n      for(int i=1; i<=m; i++) {\n\tif(ans.first == dp[i] && is_prime[i]) {\n\t  ans2 = max(ans2, i);\n\t}\n      }\n      cout << ans2 << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <string>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, -1, 0, 1 };\n\nint s[1000001];\nint d[3000][3000];\nint b[3000][3000];\nbool f[3000][3000];\n\nint main(){\n\n\tint n, m;\n\tfor (long long i = 2; i < 1000001; i++){\n\n\t\tif (!s[i]){\n\t\t\tfor (long long j = i * 2; j < 1000001; j += i){\n\t\t\t\ts[j] = 1;\n\t\t\t}\n\t\t}\n\n\t}\n\ts[1] = 1;\n\n\twhile (cin >> n >> m && n){\n\n\t\tmemset(d, 0, sizeof(d));\n\t\tmemset(b, 0, sizeof(b));\n\t\tmemset(f, 0, sizeof(f));\n\t\tqueue<P> q;\n\t\tq.push(P(1500, 1500));\n\t\tint dir = 0;\n\t\tint dist = 1;\n\t\tint c = -1;\n\t\tint num = 1;\n\t\tint sy, sx;\n\t\tn++;\n\n\t\twhile (q.size()){\n\t\t\tint y = q.front().first, x = q.front().second;\n\t\t\tq.pop();\n\n\t\t\tif (num == m)sx = x, sy = y;\n\t\t\td[y][x] = num++;\n\t\t\tif (num == n)goto end;\n\n\t\t\tif (c == 1){\n\t\t\t\tc = 0; dist++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tint ty = y, tx = x;\n\t\t\tfor (int i = 1;i < dist;i++){\n\t\t\t\tty += dy[dir]; tx += dx[dir];\n\t\t\t\tif (num == m)sx = tx, sy = ty;\n\t\t\t\td[ty][tx] = num++;\n\t\t\t\tif (num == n)goto end;\n\t\t\t}\n\n\t\t\tq.push(P(y + dy[dir] * dist, x + dx[dir] * dist));\n\t\t\tdir = (dir + 1) % 4;\n\n\t\t}\n\n\tend:;\n\n\t\tq.push(P(sy, sx));\n\t\tb[sy][sx] = (s[d[sy][sx]] ? 0 : 1);\n\t\tP ans(0,0);\n\t\tf[sy][sx] = 1;\n\t\tif (!s[d[sy][sx]]){\n\t\t\tans.first = 1;\n\t\t\tans.second = d[sy][sx];\n\t\t}\n\n\t\twhile (q.size()){\n\t\t\tint y = q.front().first, x = q.front().second;\n\t\t\tq.pop();\n\n\t\t\tint ty = y + 1, tx = x;\n\n\t\t\tfor (tx = x - 1; tx <= x + 1; tx++){\n\t\t\t\tif (d[ty][tx] == 0)continue;\n\n\t\t\t\tif (!f[ty][tx] || b[ty][tx] < b[y][x] + (s[d[ty][tx]] ? 0 : 1)){\n\t\t\t\t\tf[ty][tx] = 1;\n\t\t\t\t\tq.push(P(ty, tx));\n\t\t\t\t}\n\t\t\t\tif (b[ty][tx] < b[y][x] + (s[d[ty][tx]] ? 0 : 1)){\n\t\t\t\t\tb[ty][tx] = b[y][x] + (s[d[ty][tx]] ? 0 : 1);\n\t\t\t\t\tif (!s[d[ty][tx]] && (ans.first < b[ty][tx] || (ans.first == b[ty][tx] && ans.second < d[ty][tx]))){\n\t\t\t\t\t\tans.first = b[ty][tx];\n\t\t\t\t\t\tans.second = d[ty][tx];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstdio>\n \nusing namespace std;\n \n#define out(x,l) (x<0||l<=x)\n \nconst int N = 1000000+10;\nconst int SIZE = 1010;\n \nbool isprime[N];\npair<int, int> loc[N];\nint cave[SIZE][SIZE];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, -1, 0, 1};\npair<int, int> dp[SIZE][SIZE];\n \nint main(){\n    for (int i = 0; i < N; i++) { isprime[i] = 1; } \n    isprime[0] = isprime[1] = 0;\n    for (int i = 2; i*i <= N; i++) {\n        if (!isprime[i]) continue;\n        for (int j = 2*i; j <= N; j += i) {\n            isprime[j] = 0;\n        }\n    }\n\n\tfor (int i = 0; i < SIZE; i++)\n\t\tfor (int j = 0; j < SIZE; j++)\n\t\t\tcave[i][j] = N;\n \n    int x = SIZE/2, y = SIZE/2+1;\n    int cnt = 1;\n    int dir = 0;\n    int edge = 1;\n    while (1) {\n\t\tif (cnt > N) break;\n        dir %= 4;\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < edge; j++) {\n\t\t\t\tif (out(x,SIZE)||out(y,SIZE)) continue;\n                cave[y][x] = cnt;\n                loc[cnt].first = y;\n                loc[cnt].second = x;\n                x += dx[dir];\n                y += dy[dir];\n                cnt++;\n            }\n            dir++;\n        }\n        edge++;\n    }\n \n//  for (int i = 1; i < 100; i++) {\n//      cout << i << \" \" << loc[i].first << \" \" << loc[i].second << endl;\n//  }\n \n    int n, m;\n    while (cin >> m >> n, m&&n) {\n        for (int i = 0; i < SIZE; i++)\n            for (int j = 0; j < SIZE; j++) {\n                dp[i][j].first = -1;\n                dp[i][j].second = 0;\n            }\n        dp[loc[n].first][loc[n].second].first = isprime[n];\n        if (isprime[n]) dp[loc[n].first][loc[n].second].second = n;\n \n        for (int i = 0; i < SIZE; i++) {\n            for (int j = 0; j < SIZE; j++) {\n                if (cave[i][j] > m) continue;\n                pair<int, int> next; // first:the number of caves passed    second:last cave\n                next.first = -1;\n                next.second = 0;\n                bool update = 0;\n                if (!out(i-1,SIZE)&&!out(j-1,SIZE)&&dp[i-1][j-1].first!=-1) {\n                    if (dp[i-1][j-1].first > next.first) {\n                        next = dp[i-1][j-1];\n                        update = 1;\n                    } else if (dp[i-1][j-1].first == next.first && dp[i-1][j-1].second > next.second) {\n                        next = dp[i-1][j-1];\n                        update = 1;\n                    }\n                }\n                if (!out(i-1,SIZE)&&!out(j+1,SIZE)&&dp[i-1][j+1].first!=-1) {\n                    if (dp[i-1][j+1].first > next.first) {\n                        next = dp[i-1][j+1];\n                        update = 1;\n                    } else if (dp[i-1][j+1].first == next.first && dp[i-1][j+1].second > next.second) {\n                        next = dp[i-1][j+1];\n                        update = 1;\n                    }\n                }\n                if (!out(i-1,SIZE)&&!out(j,SIZE)&&dp[i-1][j].first!=-1) {\n                    if (dp[i-1][j].first > next.first) {\n                        next = dp[i-1][j];\n                        update = 1;\n                    } else if (dp[i-1][j].first == next.first && dp[i-1][j].second > next.second) {\n                        next = dp[i-1][j];\n                        update = 1;\n                    }\n                }\n                if (!update) continue;\n                if (isprime[cave[i][j]]) {\n                    next.first++;\n                    next.second = cave[i][j];\n                }\n                dp[i][j] = next;\n            }\n        }\n\n        pair<int, int> res;\n        for (int i = 0; i < SIZE; i++)\n            for (int j = 0; j < SIZE; j++)\n                if (res.first < dp[i][j].first) {\n                    res = dp[i][j];\n                } else if (res.first == dp[i][j].first&&res.second < dp[i][j].second) {\n                    res = dp[i][j];\n                }\n        cout << res.first << \" \" << res.second << endl;\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define as first\n#define va second\nclass Eratosthenes{\n  public:\n    int n;\n    vector<bool> prime;\n    Eratosthenes(int N):n(N+1){\n        prime=vector<bool>(n,1); prime[0]=prime[1]=0;\n        for(int i=2;i*i<=n;i++) if(prime[i]) for(int j=i*i;j<=n;j+=i) prime[j]=0;}\n    vector<int> primeArray(int s=0, int l=10000){vi ret; for(int i=s;ret.size()!=l;i++) if(prime[i]) ret.push_back(i); return ret;}\n};\n// 13,947 9,821\nint main(){\n    Eratosthenes e(1000000);\n    vvi v(1000,vi(1000,0));\n    {\n        int y=500,x=499,sight=0;\n        vvi vec={{0,1},{-1,0},{0,-1},{1,0}};\n        for(int dist=2, num=1; num<=1000000 ; dist++){\n            for(int i=0;i<dist/2;i++){\n                v[y][x]=num++;\n                y+=vec[sight][0];\n                x+=vec[sight][1];\n            }\n            sight=(sight+1)%4;\n        }\n    }\n    int m,n;\n    while(cin>>m>>n,m){\n        vector<vector<pii>> ana(1000,vector<pii>(1000,make_pair(0,0)));\n        for(int y=999;1;y--){\n            for(int x=0;x<1000;x++){\n                if(e.prime[v[y][x]]){\n                    ana[y][x].as++;\n                    if(ana[y][x].va==0){\n                        ana[y][x].va=v[y][x];\n                    }\n                }\n                if(v[y][x]==n){\n                    cout<<ana[y][x].as<<\" \"<<ana[y][x].va<<endl;\n                    goto fin;\n                }\n            }\n            //int is=false;\n            for(int x=0;x<1000;x++){\n                if(v[y][x]-1>m) continue;\n                //cout<<setw(3)<<v[y][x]<<\" \";is=true;\n                int mind=-2,val=-1, pval=-1;\n                for(auto i : {-1,0,1}){ //[y-1][x]????????????????????????[y][x+i]?????????\n                    if(x+i>=0 && x+i<1000 && v[y][x+i]<=m &&  (val<ana[y][x+i].as || (val==ana[y][x+i].as && pval<ana[y][x+i].va) )){\n                        mind=i;\n                        val=ana[y][x+i].as;\n                        pval=ana[y][x+i].va;\n                    }\n                }\n                ana[y-1][x]=make_pair(val,pval);\n            }\n            //if(is)cout<<endl;\n        }\n        fin:\n        ;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nstruct P\n{\n\tint x,y;\n};\n\nP findpoint(int m,vector<vector<int> > &map){\n\tfor(int x=0;x<map.size();x++)\n\tfor(int y=0;y<map.size();y++)\n\t\tif(map[x][y]==m)\n\t\t\treturn (P){x,y};\n\treturn (P){-1,-1};\n}\n\nP solve(int n,int m,vector<vector<int> > &map,vector<bool> &prime){\n\tP p=findpoint(m, map);\n\tP res={0,0};\n\tvector<vector<int> >dp(map.size(),vector<int>(map.size(),-1));\n\tdp[p.x][p.y]=0;\n\tfor(int y=p.y;y<map.size();y++){\n\t\tfor(int x=0;x<map.size();x++){\n\t\t\tif(map[x][y]>n)continue;\n\t\t\tif(dp[x][y]>=0){\n\t\t\t\tif(prime[map[x][y]-1]){\n\t\t\t\t\tdp[x][y]++;\n\t\t\t\t\tif(res.x<=dp[x][y]){\n\t\t\t\t\t\tres.x=dp[x][y];\n\t\t\t\t\t\tres.y=map[x][y];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(y==map.size()-1)continue;\n\t\t\t\tfor(int i=-1;i<=1;i++){\n\t\t\t\t\tif(0<=x+i&&x+i<map.size()){\n\t\t\t\t\t\tdp[x+i][y+1]=max(dp[x+i][y+1],dp[x][y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n,m,ma=-1;\n\tvector<int>N,M;\n\n\twhile(cin >> n >> m, n|m){\n\t\tN.push_back(n);\n\t\tM.push_back(m);\n\t\tma=max(ma, n);\n\t}\n\n\tvector<bool>prime(ma+1,true);\n\tprime[0] = false;\n\tfor(int i=2;i<=ma;i++){\n\t\tif(!prime[i-1])continue;\n\t\tfor(int j=i*2;j<=ma;j+=i)\n\t\t\tprime[j-1]=false;\n\t}\n\tint kk=(int)sqrt(ma-1)/2*2;;\n\tint x=0,y=1;\n\tn = m = kk*kk+1;\n\tvector<vector<int> >map(kk+2, vector<int>(kk+2));\n\tmap[x][y]=m++;\n\tint k=kk;\n\twhile(m<=ma){\n\t\tfor(int i=0;i<k;i++)\n\t\t\tmap[x][++y]=m++;\n\t\tk++;\n\t\tfor(int i=0;i<k;i++)\n\t\t\tmap[++x][y]=m++;\n\t\tfor(int i=0;i<k;i++)\n\t\t\tmap[x][--y]=m++;\n\t\tfor(int i=0;i<k;i++)\n\t\t\tmap[--x][y]=m++;\n\t}\n\tx=0;\n\ty=1;\n\tm=n-1;\n\tk=kk;\n\twhile(m>0){\n\t\tfor(int i=0;i<k&&m>0;i++)\n\t\t\tmap[++x][y]=m--;\n\t\tk--;\n\t\tfor(int i=0;i<k&&m>0;i++)\n\t\t\tmap[x][++y]=m--;\n\t\tfor(int i=0;i<k&&m>0;i++)\n\t\t\tmap[--x][y]=m--;\n\t\tk--;\n\t\tfor(int i=0;i<k&&m>0;i++)\n\t\t\tmap[x][--y]=m--;\n\t}\n\n/*\n\tfor(int j=0;j<kk+2;j++){\n\tfor(int i=0;i<kk+2;i++)\n\t\tprintf(\"%2d \",map[i][j]);\n\t\tcout << endl;\n\t}\n\t*/\n\n\tfor(int i=0;i<N.size();i++){\n\t\tP res=solve(N[i],M[i],map,prime);\n\t\tcout <<  res.x << \" \" << res.y << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\nusing namespace std;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 30000000000000LL\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define REP(i,n) for(long long i = 0;i < n;++i)    \n#define seg_size 524288\nlong long powering(long long now, long long now_go) {\n\tlong long ans = 1;\n\twhile (now_go != 0) {\n\t\tif (now_go % 2 == 1) {\n\t\t\tans *= now;\n\t\t\tans %= MAX_MOD;\n\t\t}\n\t\tnow *= now;\n\t\tnow %= MAX_MOD;\n\t\tnow_go /= 2;\n\t}\n\treturn ans;\n}\nvector<long long> calc(vector<long long> a, vector<long long> b) {\n\tlong long k = sqrt(a.size());\n\tvector<long long> ans;\n\tfor (int i = 0; i < k; ++i) {\n\t\tfor (int q = 0; q < k; ++q) {\n\t\t\tlong long geko = 0;\n\t\t\tfor (int t = 0; t < k; ++t) {\n\t\t\t\tgeko += a[i * k + t] * b[t * k + q];\n\t\t\t\tgeko %= MAX_MOD;\n\t\t\t}\n\t\t\tans.push_back(geko);\n\t\t}\n\t}\n\treturn ans;\n}\nvector<long long> powered(vector<long long> a, long long n) {\n\tvector<long long> ans = a;\n\tn--;\n\twhile (n != 0) {\n\t\tif (n % 2 == 1) {\n\t\t\tans = calc(ans, a);\n\t\t}\n\t\ta = calc(a, a);\n\t\tn /= 2;\n\t}\n\treturn ans;\n}\nlong long inv(long long now) {\n\treturn powering(now, MAX_MOD - 2LL);\n}\nunsigned long xor128() {\n\tstatic unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x^(x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w^(w >> 19))^(t^(t >> 8)));\n}\nlong long grid[1020][1020] = {};\npair<long long, long long> directors[2000000];\nlong long sosuu[2000000];\npair<long long,long long> dp[1020][1020] = {};\npair<long long, long long> solve(long long now_x, long long now_y, long long maximum) {\n\tif (grid[now_x][now_y] == 0 || grid[now_x][now_y] > maximum) {\n\t\treturn make_pair(0, 0);\n\t}\n\tif (dp[now_x][now_y].second != 0) {\n\t\treturn dp[now_x][now_y];\n\t}\n\tint ye[3] = { -1,0,1 };\n\tREP(i, 3) {\n\t\tint next_x = now_x + 1;\n\t\tint next_y = now_y + ye[i];\n\t\tpair<long long, long long> neko = solve(next_x, next_y, maximum);\n\t\tint ok = 0;\n\t\tif (dp[now_x][now_y].first < neko.first) {\n\t\t\tok = 1;\n\t\t}\n\t\tif (dp[now_x][now_y].first == neko.first && dp[now_x][now_y].second < neko.second) {\n\t\t\tok = 1;\n\t\t}\n\t\tif (ok == 1) {\n\t\t\tdp[now_x][now_y] = neko;\n\t\t}\n\t}\n\tif (sosuu[grid[now_x][now_y]] == 1) {\n\t\tif (dp[now_x][now_y].first == 0) {\n\t\t\tdp[now_x][now_y].second = grid[now_x][now_y];\n\t\t}\n\t\tdp[now_x][now_y].first++;\n\t}\n\treturn dp[now_x][now_y];\n}\nint main(){\n\tlong long now_x = 510, now_y = 510;\n\tint direction = 3;\n\tint xe[4] = { 0,-1,0,1 };\n\tint ye[4] = { 1,0,-1,0 };\n\tfor (int i = 1; i <= 1000001; ++i) {\n\t\tif (i != 1) {\n\t\t\tint ok = 1;\n\t\t\tfor (int q = 2; q <= sqrt(i); ++q) {\n\t\t\t\tif (i % q == 0) {\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsosuu[i] = ok;\n\t\t}\n\t\tif (grid[now_x + xe[(direction + 1) % 4]][now_y + ye[(direction + 1) % 4]] == 0) {\n\t\t\tdirection++;\n\t\t\tdirection %= 4;\n\t\t}\n\t\tgrid[now_x][now_y] = i;\n\t\tdirectors[i] = make_pair(now_x, now_y);\n\t\tnow_x += xe[direction];\n\t\tnow_y += ye[direction];\n\t}\n\twhile (true) {\n\t\tlong long n, k;\n\t\tcin >> n >> k;\n\t\tif (n == 0) return 0;\n\t\tREP(i, 1020) {\n\t\t\tREP(q, 1020) {\n\t\t\t\tdp[i][q] = make_pair(0, 0);\n\t\t\t}\n\t\t}\n\t\tpair<long long, long long> a = solve(directors[k].first, directors[k].second, n);\n\t\tcout << a.first << \" \" << a.second << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nint num[1700][1700];\ni_i pos[1000500];\ni_i dp[1700][1700];\ni_i before[1700][1700];\nbool IsPrime[1000050];\nvoid init() {\n    for(int i = 0; i < 1700; i++) {\n        for(int j = 0; j < 1700; j++) dp[i][j] = {0, 0};\n    }\n}\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    for(int i = 0; i < 1700; i++) {\n        for(int j = 0; j < 1700; j++) num[i][j] = 0;\n    }\n    for(int i = 0; i <= 1000000; i++) pos[i] = {0, 0};\n    for(int i = 2; i <= 1000000; i++) IsPrime[i] = true;\n    IsPrime[0] = false;\n    IsPrime[1] = false;\n    for(int i = 2; i <= 1000000; i++) {\n        if(!IsPrime[i]) continue;\n        for(int j = i * 2; j <= 1000000; j += i) IsPrime[j] = false;\n    }\n    num[1000][1000] = 1;\n    pos[1] = {1000, 1000};\n    int nowi = 1000;\n    int nowj = 1000;\n    int val = 1;\n    int imax = 1000;\n    int imin = 1000;\n    int jmax = 1000;\n    int jmin = 1000;\n    for(int delta = 1; delta <= 1000; delta += 2) {\n        //cerr << val << endl;\n        for(int k = 1; k <= delta; k++) {\n            nowj++;\n            val++;\n            if(num[nowi][nowj] != 0) {\n                //cerr << nowi << \" \" << nowj << \" \" << num[nowi][nowj] << \" \" << val << endl;\n                return 0;\n            }\n            num[nowi][nowj] = val;\n            pos[val] = {nowi, nowj};\n            imax = max(imax, nowi);\n            imin = min(imin, nowi);\n            jmax = max(jmax, nowj);\n            jmin = min(jmin, nowj);\n        }\n        for(int k = 1; k <= delta; k++) {\n            nowi--;\n            val++;\n            if(num[nowi][nowj] != 0) {\n                //cerr << nowi << \" \" << nowj << \" \" << num[nowi][nowj] << \" \" << val << endl;\n                return 0;\n            }\n            num[nowi][nowj] = val;\n            pos[val] = {nowi, nowj};\n            imax = max(imax, nowi);\n            imin = min(imin, nowi);\n            jmax = max(jmax, nowj);\n            jmin = min(jmin, nowj);\n        }\n        for(int k = 1; k <= delta + 1; k++) {\n            nowj--;\n            val++;\n            if(num[nowi][nowj] != 0) {\n                cerr << nowi << \" \" << nowj << \" \" << num[nowi][nowj] << \" \" << val << endl;\n                return 0;\n            }\n            num[nowi][nowj] = val;\n            pos[val] = {nowi, nowj};\n            imax = max(imax, nowi);\n            imin = min(imin, nowi);\n            jmax = max(jmax, nowj);\n            jmin = min(jmin, nowj);\n        }\n        for(int k = 1; k <= delta + 1; k++) {\n            nowi++;\n            val++;\n            if(num[nowi][nowj] != 0) {\n                cerr << nowi << \" \" << nowj << \" \" << num[nowi][nowj] << \" \" << val << endl;\n                return 0;\n            }\n            num[nowi][nowj] = val;\n            pos[val] = {nowi, nowj};\n            imax = max(imax, nowi);\n            imin = min(imin, nowi);\n            jmax = max(jmax, nowj);\n            jmin = min(jmin, nowj);\n        }\n    }\n    //cerr << imax << \" \" << imin << \" \" << jmax << \" \" << jmin << endl;\n    //cerr << val << endl;\n    //cerr << num[516][1377] << endl;\n    //if(IsPrime[936164]) cerr << \"HOGE\" << endl;\n    //cerr << pos[613].first << \" \" << pos[613].second << endl;\n    for(int i = 1; i <= 85; i++) {\n        //cerr << i << \" \" << pos[i].first << \" \" << pos[i].second << endl;\n    }\n    while(true) {\n        int m, n;\n        cin >> m >> n;\n        if(n == 0 && m == 0) break;\n        init();\n        for(int i = 1698; i >= 0; i--) {\n            for(int j = 1; j <= 1650; j++) {\n                if(num[i][j] == 0) continue;\n                if(num[i][j] > m) continue;\n                //cerr << i << \" \" << j << \" \" << num[i][j] << endl;\n                if(IsPrime[num[i][j]]) dp[i][j] = {0, num[i][j]};\n                before[i][j] = {-1, -1};\n                for(int k = j - 1; k <= j + 1; k++) {\n                    if(dp[i+1][k] > dp[i][j]) {\n                        dp[i][j] = max(dp[i][j], dp[i+1][k]);\n                        before[i][j] = {i+1, k};\n                    }\n                }\n                if(IsPrime[num[i][j]]) dp[i][j].first++;\n            }\n        }\n        /*\n        int I = pos[n].first;\n        int J = pos[n].second\n        */\n        i_i now = dp[pos[n].first][pos[n].second];\n        //cout << dp[I][J].first << \" \" << dp[I][J].second << endl;\n        cout << now.first << \" \" << now.second << endl;\n        int inow = pos[n].first;\n        int jnow = pos[n].second;\n        while(inow != -1) {\n            //cerr << inow << \" \" << jnow << \" \" << dp[inow][jnow].first << endl;\n            int nexti = before[inow][jnow].first;\n            jnow = before[inow][jnow].second;\n            inow = nexti;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, -1, 0, 1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m; assert(b>=0); for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// 地図作って(クソ面倒)上からdpするだけ\n// 毎回地図作り直す必要なかった\nint n, m, si, sj, s[2000][2000], dp[2000][2000];\nbool p[1000001];\n\n// エラトステネスの篩 O(NloglogN)\nvoid sieve() {\n\tfill(p, p+1000001, true);\n\tp[0] = p[1] = false;\n\tfor (int i = 2; i*i <= 1000000; ++i)\n\t\tif (p[i]) for (int j = 2*i; j <= 1000000; j += i) p[j] = false;\n}\n\n// 再帰で地図作成\nvoid mm() {\n\tmemset(s,0,sizeof(s));\n\ts[1000][1000] = 1;\n\tif (m==1) si = 1000, sj = 1000;\n\tint i = 1000, j = 1001, d = 0;\n\trepst(p,2,n) {\n\t\ts[i][j] = p;\n\t\tif (p==m) si = i, sj = j;\n\t\tif (p==n) return;\n\t\tint i0 = i + dx[d], j0 = j + dy[d], i1 = i + dx[(d+1)%4], j1 = j + dy[(d+1)%4];\n\t\tif (s[i1][j1]) i = i0, j = j0;\n\t\telse i = i1, j = j1, d++, d %= 4;\n\t}\n}\n\nsigned main() {\n\tsieve();\n\twhile (1) {\n\t\tcin >> n >> m;\n\t\tif (n==0) break;\n\t\tmm();\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tdp[si][sj] = p[m];\n\t\tint l = 0, r = 0;\n\t\treps(i,si,1999) reps(j,1,1999) if (s[i][j] && dp[i][j]!=-1) {\n\t\t\trepst(d,-1,1) if (s[i+1][j+d]) chmax(dp[i+1][j+d], dp[i][j] + p[s[i+1][j+d]]);\n\t\t\tif (dp[i][j]>l) l = dp[i][j], r = s[i][j];\n\t\t\telse if (dp[i][j]==l && p[s[i][j]]) chmax(r, s[i][j]);\n\t\t}\n\t\tcout << l << ' ' << (l==0 ? 0 : r) << ln;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\n#define fs first\n#define sc second\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\n// std::vector Initialization\ntemplate<typename T>\nvoid fill_all(T& arr, const T& v) { arr = v; }\ntemplate<typename T, typename U>\nvoid fill_all(T& arr, const U& v) { for (auto& i : arr) fill_all(i, v); }\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n\nstruct edge { int to, cost; };\nostream& operator<<(ostream& os, const edge& e) {\n    os << \"(\" << e.to << \", \" << e.cost << \")\";\n    return os;\n}\n\nconst LL LINF = 1LL<<60;\nconst int IINF = 1<<30;\nconst LL MOD = 1e9+7;\n\n// O(NloglogN)\nstruct IsPrime {\n    int sz;\n    vector<bool> isprime;\n    IsPrime(int n) : sz(n+1) {\n        isprime.assign(n+1, true);\n        isprime[0] = isprime[1] = false;\n        for (int i = 2; i*i <= n; ++i) if (isprime[i]) {\n            for (int j = 2; i*j <= n; ++j) {\n                isprime[i*j] = false;\n            }\n        }\n    }\n    bool operator[](int i) { return isprime[i]; }\n};\n\nint main()\n{\n    vector<int> ms, ns;\n    while (true) {\n        int m, n; cin >> m >> n;\n        if (m == 0 && n == 0) {\n            break;\n        }\n        ms.push_back(m);\n        ns.push_back(n);\n    }\n\n    for (int t = 0; t < ms.size(); ++t) {\n\n        int m = ms[t], n = ns[t];\n\n        IsPrime isprime(m);\n\n        int K = (int)sqrt(m)/2+10;\n        auto s = make_v<int>(2*K+10, 2*K+10);\n        vector<pair<int,int>> ps(m+1);\n\n        int c = 0;\n        s[0+K][0+K] = ++c;\n\n        bool terminal = false;\n        for (int k = 1; !terminal; ++k) {\n            for (int i = 0; !terminal && i < 2*k; ++i) {\n                s[-i+k-1+K][k+K] = ++c;\n                ps[c] = { -i+k-1, k };\n                if (c == m) terminal = true;\n            }\n            for (int i = 0; !terminal && i < 2*k; ++i) {\n                s[-k+K][-i+k-1+K] = ++c;\n                ps[c] = { -k, -i+k-1 };\n                if (c == m) terminal = true;\n            }\n            for (int i = 0; !terminal && i < 2*k; ++i) {\n                s[i-k+1+K][-k+K] = ++c;\n                ps[c] = { i-k+1, -k };\n                if (c == m) terminal = true;\n            }\n            for (int i = 0; !terminal && i < 2*k; ++i) {\n                s[k+K][i-k+1+K] = ++c;\n                ps[c] = { k, i-k+1 };\n                if (c == m) terminal = true;\n            }\n        }\n\n\n        //for (int i = 0; i < s.size(); ++i) {\n        //    for (int j = 0; j < s[i].size(); ++j) {\n        //        printf(\"%4d \", s[i][j]);\n        //    }\n        //    printf(\"\\n\");\n        //}\n        //printf(\"\\n\");\n\n\n        int x = ps[n].fs, y = ps[n].sc;\n\n        auto dp = make_v<int>(2*K+10, 2*K+10);\n        dp[x+K][y+K] = isprime[s[x+K][y+K]];\n\n        int ma = dp[x+K][y+K];\n        int fi = (ma ? s[x+K][y+K] : 0);\n\n        for (int i = 0; x+i < K-1; ++i) {\n            for (int j = -i; j <= i; ++j) {\n                int X = x+i+K, Y = y+j+K;\n                for (int a = -1; a <= 1; ++a) {\n                    if (Y+a < 0 || Y+a >= 2*K) {\n                        continue;\n                    }\n                    if (s[X+1][Y+a] == 0) {\n                        continue;\n                    }\n                    chmax(dp[X+1][Y+a], dp[X][Y] + isprime[s[X+1][Y+a]]);\n                    if (chmax(ma, dp[X+1][Y+a])) {\n                        fi = -1;\n                    }\n\n                    if (ma == dp[X+1][Y+a] && isprime[s[X+1][Y+a]]) {\n                        chmax(fi, s[X+1][Y+a]);\n                    }\n                }\n            }\n        }\n\n        //for (int i = 0; i < dp.size(); ++i) {\n        //    for (int j = 0; j < dp[i].size(); ++j) {\n        //        printf(\"%02d \", dp[i][j]);\n        //    }\n        //    printf(\"\\n\");\n        //}\n        cout << ma << \" \" << fi << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\n\nvector<int> prime(1001000,1);\n\n\nint main() {\n\tint n, m;\n\tprime[0] = 0;\n\tprime[1] = 0;\n\n\tfor (int i = 2; i < 1000010; i++) {\n\t\tif (prime[i]) {\n\t\t\tfor (int j = i + i; j < 1000100; j += i) {\n\t\t\t\tprime[j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\twhile (cin >> m >> n) {\n\t\tif (m == 0) break;\n\t\tint k = 1, t = (int)sqrt(m)+1;\n\t\tbool r = 1, u = 0, l = 0, d = 0;\n\t\tint i = t / 2, j = (t-1) / 2;\n\t\tvector<vector<int>> a(1010, vector<int>(1010));\n\t\tint x, y;\n\t\tfor (int num = 1; num <= m; num++) {\n\t\t\ta[i][j] = num;\n\t\t\tif (num == n)x = i, y = j;\n\t\t\tif (r) {\n\t\t\t\tif (num == k * k + 1) {\n\t\t\t\t\tr = false;\n\t\t\t\t\tu = true;\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\telse j++;\n\t\t\t}\n\t\t\telse if (u) {\n\t\t\t\tif (num == k * k + k + 1) {\n\t\t\t\t\tk++;\n\t\t\t\t\tu = false;\n\t\t\t\t\tl = true;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\telse i--;\n\t\t\t}\n\t\t\telse if (l) {\n\t\t\t\tif (num == k * k + 1) {\n\t\t\t\t\tl = false;\n\t\t\t\t\td = true;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\telse j--;\n\t\t\t}\n\t\t\telse if (d) {\n\t\t\t\tif (num == k * k + k + 1) {\n\t\t\t\t\td = false;\n\t\t\t\t\tr = true;\n\t\t\t\t\tk++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\telse i++;\n\t\t\t}\n\t\t}\n\t\t/*for (int i = 0; i < 10; i++) {\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tcout << a[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\n\t\t\n\t\tvector<vector<ll>> dp(1010, vector<ll>(1010));\n\t\tfor (int i = 0; i < 1010; i++)for (int j = 0; j < 1010; j++) dp[i][j] = -1e9;\n\t\tdp[x][y] = 0;\n\n\n\t\t\n\n\t\tfor (int i = 0; i < 1010; i++) {\n\t\t\tfor (int j = 0; j < 1010; j++) {\n\t\t\t\tif (i) {\n\t\t\t\t\tif (j && j + 1 < t) {\n\t\t\t\t\t\tdp[i][j] = max(max(dp[i][j],dp[i - 1][j - 1]), max(dp[i - 1][j], dp[i - 1][j + 1]));\n\t\t\t\t\t}\n\t\t\t\t\telse if (j) {\n\t\t\t\t\t\tdp[i][j] = max(dp[i][j],max(dp[i - 1][j - 1], dp[i - 1][j]));\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (j + 1 < t) {\n\t\t\t\t\t\tdp[i][j] = max(dp[i][j],max(dp[i - 1][j], dp[i-1][j + 1]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (prime[a[i][j]]) dp[i][j]++;\n\t\t\t}\n\t\t}\n\t\tll ans = 0;\n\t\tll mx = 0;\n\t\tfor (int i = 0; i < 1010;i++) {\n\t\t\tfor (int j = 0; j < 1010; j++) {\n\t\t\t\t//cout << dp[i][j] << \" \";\n\t\t\t\tif (prime[a[i][j]] && ans < dp[i][j]) {\n\t\t\t\t\tans = dp[i][j];\n\t\t\t\t\tmx = a[i][j];\n\t\t\t\t}\n\t\t\t\telse if (prime[a[i][j]] && ans == dp[i][j]) {\n\t\t\t\t\tmx = max(mx, (ll)a[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << endl;\n\t\t}\n\t\tif (ans == 0) mx = 0;\n\n\t\tcout << ans << \" \" << mx << endl;\n\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t\n\t\toutput = false;\n\t\tfor (int i = 0;i < SIZE && (!output);i++) {\n\t\t\tfor (int j = 0;j < SIZE && (!output);j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\t//printf(\"%d %d\\n\", dp[i][j], pr[i][j]);\n\t\t\t\t\tcout << dp[i][j] << \" \" << pr[i][j] << endl;\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n//#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n//#define EXIST(s, e) ((s).find(e)!=(s).end())\n//#define SORT(c) sort(begin(c),end(c))\n//#define pb emplace_back\n//#define MP make_pair\n//#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n//ここから編集する\nclass Dijkstra {\npublic:\n    struct edge {\n        ll to, cost;\n    };\n    typedef pair<ll, ll> P; //firstは最短距離、secondは頂点の番号\n\n    int V;                  //超点数\n    vector<vector<edge>> G; //グラフ,G[i]はiから出る辺の集合,G[i][j]はiから出る辺のj番目の辺\n    vector<ll> d;           //最短距離\n    vector<int> last;\n\n    //0origin\n    Dijkstra(int N) {\n        V = N;\n        G = vector<vector<edge >>(N);\n        d = vector<ll>(N);\n        last = vector<int>(N);\n    };\n\n    void dijkstra(int s) {\n        priority_queue<P, vector<P>, greater<P>> que;\n        fill(d.begin(), d.end(), INFl);\n        d[s] = 0;\n        que.push(P(0, s));\n\n        while (!que.empty()) {\n            P p = que.top();\n            que.pop();\n            ll v = p.second;\n            if (d[v] < p.first)\n                continue;\n            for (int i = 0; i < G[v].size(); i++) {\n                edge e = G[v][i];\n                if (d[e.to] > d[v] + e.cost && !(d[e.to] == INFl && d[v] == INFl)) {\n                    d[e.to] = d[v] + e.cost;\n                    que.push(P(d[e.to], e.to));\n                }\n            }\n        }\n    }\n\n    /* 頂点fromに頂点toに達するコストcostの辺を貼る */\n    void addEdge(int from, int to, int cost) {\n        edge e;\n        e.to = to;\n        e.cost = cost;\n        G[from].push_back(e);\n    }\n};\n\n\nvector<bool> prime(1000005, true);\n\nvoid setEra() {\n    prime[0] = prime[1] = false;\n    int lim = 1000005;\n    rep(i, 2, lim) {\n        if (prime[i]) {\n            for (int j = i * 2; j < lim; j += i) {\n                prime[j] = false;\n            }\n        }\n    }\n}\n\nvector<vector<int> > makeDou(int n) {\n    vector<vector<int> > tmp(2000, vector<int>(2000));\n    int h = 1000;\n    int w = 1000;\n    int val = 1;\n    int dh[] = {0, -1, 0, 1};\n    int dw[] = {1, 0, -1, 0};\n    int seq = 0;\n    int lim = 1;\n    int turn = 0;\n\n    while (val <= n) {\n        tmp[h][w] = val;\n        val++;\n        seq++;\n        h += dh[turn % 4];\n        w += dw[turn % 4];\n\n        if (seq == lim) {\n            turn++;\n            seq = 0;\n            lim = turn / 2 + 1;\n        }\n    }\n\n    int sw = 2000, tw = 0, sh = 2000, th = 0;\n    rep(i, 0, 2000) {\n        rep(j, 0, 2000) {\n            if (tmp[i][j] > 0) {\n                sh = min(sh, i);\n                sw = min(sw, j);\n\n                th = max(th, i + 1);\n                tw = max(tw, j + 1);\n            }\n        }\n    }\n    vector<vector<int>> ret(th - sh + 1, vector<int>(tw - sw + 1));\n    for (int i = sh; i < th; i++) {\n        for (int j = sw; j < tw; j++) {\n            ret[i - sh][j - sw] = tmp[i][j];\n        }\n    }\n\n    return ret;\n}\n\nbool solve() {\n    int m, n;\n    cin >> m >> n;\n    if (n == 0 && m == 0) return false;\n\n    auto field = makeDou(m);\n    vector<vector<int> > dp(field.size(), vector<int>(field[0].size(), -1));\n    int sh, sw;\n    int H = field.size();\n    int W = field[0].size();\n    rep(i, 0, H) {\n        rep(j, 0, W) {\n            if (field[i][j] == n) {\n                sh = i;\n                sw = j;\n            }\n        }\n    }\n    dp[sh][sw] = prime[n];\n\n\n    rep(i, 0, H - 1) {\n        rep(j, 0, W) {\n            if (dp[i][j] != -1) {\n                for (int nj = j - 1; nj <= j + 1; nj++) {\n                    if (nj >= 0 && nj < W) {\n                        int tmp = (prime[field[i + 1][nj]]) ? dp[i][j] + 1 : dp[i][j];\n                        dp[i + 1][nj] = max(dp[i + 1][nj], tmp);\n                    }\n                }\n            }\n        }\n    }\n\n    int max_v = 0;\n    int max_p = 0;\n\n    rep(i, 0, H) {\n        rep(j, 0, W) {\n            if (dp[i][j] > max_v) {\n                max_v = dp[i][j];\n            }\n        }\n    }\n    if (max_v == 0) {\n        cout << 0 << \" \" << 0 << endl;\n        return true;\n    }\n\n    rep(i, 0, H) {\n        rep(j, 0, W) {\n            if (dp[i][j] == max_v && prime[field[i][j]]) {\n                max_p = field[i][j];\n            }\n        }\n    }\n\n    cout << max_v << \" \" << max_p << endl;\n\n\n    return true;\n\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    if (false) {\n        auto hya = makeDou(947);\n        rep(i, 0, hya.size()) {\n            rep(j, 0, hya[i].size()) {\n//                cout << hya[i][j] << \" \";\n                printf(\"%3d \", hya[i][j]);\n            }\n            cout << endl;\n        }\n        return 0;\n    }\n\n    setEra();\n    while (solve()) {\n\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n\nusing namespace std;\n\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef pair<int, int> PII;\n\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n **/\n\nconst int MAP_SIZE = 2000;\n\ninline int SQR(int n) {\n    return n * n;\n}\n\nvector<bool> ERATOSTHENES(int n) {\n    vector<bool> arr(n, true);\n    for (int i = 2; SQR(i) < n; i++) {\n        if (arr[i]) {\n            for (int j = 0; i * (j + 2) < n; j++) {\n                arr[i * (j + 2)] = false;\n            }\n        }\n    }\n    return arr;\n}\n\nvoid makeMap(VVI &map, VVB &used, VB &primes, PII start, int m) {\n    int count = 1;\n    int right = 1;\n    int up = 1;\n    int left = 2;\n    int down = 2;\n    PII point = start;\n\n    while (true) {\n        for (int i = 0; i < right; i++) {\n            if (count < m) {\n                count++;\n                point.second += 1;\n                map[point.first][point.second] = count;\n                if (primes[count]) {\n                    used[point.first][point.second] = true;\n                }\n            }\n        }\n        for (int i = 0; i < up; i++) {\n            if (count < m) {\n                count++;\n                point.first -= 1;\n                map[point.first][point.second] = count;\n                if (primes[count]) {\n                    used[point.first][point.second] = true;\n                }\n            }\n        }\n        for (int i = 0; i < left; i++) {\n            if (count < m) {\n                count++;\n                point.second -= 1;\n                map[point.first][point.second] = count;\n                if (primes[count]) {\n                    used[point.first][point.second] = true;\n                }\n            }\n        }\n        for (int i = 0; i < down; i++) {\n            if (count < m) {\n                count++;\n                point.first += 1;\n                map[point.first][point.second] = count;\n                if (primes[count]) {\n                    used[point.first][point.second] = true;\n                }\n            }\n        }\n\n        if (count < m) {\n            right += 2;\n            up += 2;\n            left += 2;\n            down += 2;\n        } else {\n            break;\n        }\n\n    }\n}\n\nint main() {\n\n    vector<bool> primes = ERATOSTHENES(2000000);\n\n    while (true) {\n        int m, n;\n        cin >> m >> n;\n\n        if (m == 0 && n == 0) break;\n\n        VVI map(MAP_SIZE, VI(MAP_SIZE, 0));\n        VVB used(MAP_SIZE, VB(MAP_SIZE, false));\n        //first = y   second = x\n        PII start(MAP_SIZE / 2, MAP_SIZE / 2);\n        map[start.first][start.second] = 1;\n\n        makeMap(map, used, primes, start, m);\n\n        for (int i = 0; i < map.size(); i++) {\n            for (int j = 0; j < map[i].size(); j++) {\n                if (map[i][j] == n) start = make_pair(i, j);\n            }\n        }\n\n        VVI dp(MAP_SIZE, VI(MAP_SIZE, -1));\n        if (used[start.first][start.second]) {\n            dp[start.first][start.second] = 1;\n        } else {\n            dp[start.first][start.second] = 0;\n        }\n//        for (int j = 2; j <= MAP_SIZE - 2; j++) {\n//            if (used[start.first][j])dp[start.first][j] = 1;\n//        }\n\n        for (int i = start.first + 1; i < MAP_SIZE - 2; i++) {\n            for (int j = 2; j < MAP_SIZE - 2; j++) {\n                if (map[i][j] == 0)continue;\n                int maxV = -1;\n                maxV = max(maxV, dp[i - 1][j - 1]);\n                maxV = max(maxV, dp[i - 1][j]);\n                maxV = max(maxV, dp[i - 1][j + 1]);\n                if (maxV == -1) continue;\n                if (used[i][j]) maxV++;\n                dp[i][j] = maxV;\n            }\n        }\n\n\n        int maxV = 0;\n        int number = 0;\n        PII last(0, 0);\n\n        for (int i = 0; i < dp.size(); i++) {\n            for (int j = 0; j < dp[i].size(); j++) {\n                if (used[i][j] && map[i][j] != 0 && dp[i][j] >= maxV) {\n                    if (dp[i][j] == maxV && used[i][j]) {\n                        number = max(number, map[i][j]);\n                    } else {\n                        number = map[i][j];\n                    }\n                    maxV = dp[i][j];\n                    last.first = i;\n                    last.second = j;\n                }\n                maxV = max(maxV, dp[i][j]);\n            }\n        }\n\n        cout << maxV << \" \" << number << endl;\n\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint n, m;\nint a[3000][3000];\nint b[3000][3000];\nint c[3000][3000];\nint e[3000][3000];\nint sx[3000005];\nint sy[3000005];\nint p[3000005];\nvoid prime()\n{\n\tint i, j;\n\tp[1] = 1;\n\tfor(i=2;i<=3000000;i++)\n\t{\n\t\tif(p[i] == 0)\n\t\t{\n\t\t\tfor(j=2*i;j<=3000000;j+=i)\n\t\t\t{\n\t\t\t\tp[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid inil()\n{\n\tint i, j;\n\tprime();\n\tint x,y,d;\n\tint dx[4]={1,0,-1,0};\n\tint dy[4]={0,1,0,-1};\n\td = 0;\n\tx = y = 1500;\n\tint k=1;\n\tint td;\n\twhile(k<=2000000)\n\t{\n\t\ta[x][y] = k;\n\t\tsx[k] = x;\n\t\tsy[k] = y;\n\t\tif(p[k] == 0)\n\t\t\tb[x][y] = 1;\n\t\ttd = (d+1)%4;\n\t\tif(a[dx[td] + x][dy[td] + y] == 0)\n\t\t\td = td;\n\t\tx = x+dx[d];\n\t\ty = y+dy[d];\n\t\tk++;\n\t}\n}\nvoid process()\n{\n\tint i, j, k;\n\tint x,y;\n\tx = sx[m];\n\ty = sy[m];\n\tfor(i=0;i<3000;i++)\n\t\tfor(j=0;j<3000;j++)\n\t\t\tc[i][j] = e[i][j]=0;\n\tif(p[a[x][y]]==0)\n\t\tc[x][y]=1;\n\tfor(i=x+1;i<2888;i++)\n\t{\n\t\tfor(j=y-i+x;j<=y+i-x;j++)\n\t\t{\n\t\t\tif(j<0)continue;\n\t\t\tif(j>2888)continue;\n\t\t\tif(a[i][j] == 0 || a[i][j] > n) continue;\n\t\t\t//printf(\"%d %d  %d %d\\n\",x,y,i,j);\n\t\t\tk = (p[a[i][j]]==0);\n\t\t\tif(c[i][j] < c[i-1][j-1] + k)\n\t\t\t{\n\t\t\t\tc[i][j] = c[i-1][j-1]+k;\n\t\t\t\te[i][j] = e[i-1][j-1];\n\t\t\tif(k)e[i][j] = a[i][j];\n\t\t\t}\n\t\t\telse if(c[i][j] == c[i-1][j-1]+k)\n\t\t\t{\n\t\t\t\te[i][j] = e[i-1][j-1];\n\t\t\tif(k)e[i][j] = a[i][j];\n\t\t\t}\n\t\t\tif(c[i][j] < c[i-1][j] + k)\n\t\t\t{\n\t\t\t\tc[i][j] = c[i-1][j]+k;\n\t\t\t\te[i][j] = e[i-1][j];\n\t\t\tif(k)e[i][j] = a[i][j];\n\t\t\t}\n\t\t\telse if(c[i][j] == c[i-1][j]+k)\n\t\t\t{\n\t\t\t\te[i][j] = e[i-1][j];\n\t\t\tif(k)e[i][j] = a[i][j];\n\t\t\t}\n\t\t\tif(c[i][j] < c[i-1][j+1] + k)\n\t\t\t{\n\t\t\t\tc[i][j] = c[i-1][j+1]+k;\n\t\t\t\te[i][j] = e[i-1][j+1];\n\t\t\tif(k)e[i][j] = a[i][j];\n\t\t\t}\n\t\t\telse if(c[i][j] == c[i-1][j+1]+k)\n\t\t\t{\n\t\t\t\te[i][j] = e[i-1][j+1];\n\t\t\tif(k)e[i][j] = a[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tint max=0;\n\tint mi = 0;\n\tfor(i=n;i>0;i--)\n\t{\n\t\tif(max < c[sx[i]][sy[i]])\n\t\t{\n\t\t\tmax = c[sx[i]][sy[i]];\n\t\t\tmi = e[sx[i]][sy[i]];\n\t\t}\n\t\telse if(max == c[sx[i]][sy[i]])\n\t\t{\n\t\t\tif(mi < e[sx[i]][sy[i]])\n\t\t\t\tmi = e[sx[i]][sy[i]];\n\t\t}\n\t}\n\tif(max==0)mi=0;\n\tprintf(\"%d %d\\n\",max,mi);\n}\nint main()\n{\n\tinil();\n\twhile(1)\n\t{\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n+m==0)break;\n\t\tprocess();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(y=SIZE-1;y>=0;y--){\n\t\t\tfor(x=SIZE-1;x>=0;x--){\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&\n\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x - 1]||(dp[y][x] == dp[y + 1][x - 1] && pr[y][x] < pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && \n\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x] || (dp[y][x] == dp[y + 1][x] && pr[y][x] < pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && \n\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x + 1] || (dp[y][x] == dp[y + 1][x + 1] && pr[y][x] < pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (y = 0;y < SIZE;y++) {\n\t\t\tfor (x = 0;x < SIZE;x++) {\n\t\t\t\tif (table[y][x] == n) {\n\t\t\t\t\tcout << dp[y][x] << \" \" << pr[y][x] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint caves[1200][1200];\nint cx[1100001];\nint cy[1100001];\nint main() {\n\tset<int> prime;\n\tbool b[1000001] = { false };\n\tFOR(i, 2, 1000001) {\n\t\tif (!b[i]) {\n\t\t\tprime.insert(i);\n\t\t\tfor (int j = i + i;j < 1000001;j += i)\n\t\t\t\tb[j] = true;\n\t\t}\n\t}\n\tint x = 600, y = 600, dir = 2, go = 1, now = 0;\n\tFOR(i, 1, 1001 * 1001 + 1) {\n\t\tcaves[y][x] = i;\n\t\tcx[i] = x;\n\t\tcy[i] = y;\n\t\tx += dx[dir];\n\t\ty += dy[dir];\n\t\tnow++;\n\t\tif (go == now) {\n\t\t\tif (dir % 2 == 1)\n\t\t\t\tgo++;\n\t\t\tnow = 0;\n\t\t\tdir = (dir + 1) % 4;\n\t\t}\n\t}\n\n\tint m, n;\n\twhile (cin >> m >> n, m | n) {\n\t\tmap<int, int> vis;\n\t\tqueue<int> Q;\n\t\tint ans = 0;\n\t\tint last = 0;\n\t\tif (EXIST(prime, n)) {\n\t\t\tans = 1;\n\t\t\tlast = n;\n\t\t}\n\t\tQ.push(n);\n\t\twhile (!Q.empty()) {\n\t\t\tint q = Q.front();Q.pop();\n\t\t\tif (EXIST(vis, q))\n\t\t\t\tcontinue;\n\t\t\tint sx = cx[q];\n\t\t\tint sy = cy[q];\n\t\t\tint ma = 0;\n\t\t\tREP(i, 3) \n\t\t\t\tif (EXIST(vis, caves[sy - 1][sx - 1 + i]))\n\t\t\t\t\tma = max(ma, vis[caves[sy - 1][sx - 1 + i]]);\n\t\t\tif (EXIST(prime,q))\n\t\t\t\tma++;\n\t\t\tvis[q] = ma;\n\t\t\tif (ans < ma) {\n\t\t\t\tans = ma;\n\t\t\t\tlast = q;\n\t\t\t}\n\t\t\tif (ans == ma&&EXIST(prime, q)) {\n\t\t\t\tlast = max(last, q);\n\t\t\t}\n\t\t\tREP(i, 3) {\n\t\t\t\tif(caves[sy + 1][sx - 1 + i]<=m)\n\t\t\t\tQ.push(caves[sy + 1][sx - 1 + i]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << ' ' << last << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<utility>\n#include<cmath>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint cave_num[1000][1000];\nbool is_prime[1000001];\nP trans[1000001];\nP dp[1000001];\nint m;\n\nvoid prime() {\n\tint p = 0;\n\tfor (int i = 0; i <= 1000000; i++)is_prime[i] = true;\n\tis_prime[0] = is_prime[1] = false;\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tif (is_prime[i]) {\n\t\t\tfor (int j = 2 * i; j <= 1000000; j += i)is_prime[j] = false;\n\t\t}\n\t}\n}\n\nP dfs(int n) {\n\tif (dp[n].first != -1)return dp[n];\n\tint res1 = 0, res2 = 0;\n\tP now = trans[n];\n\tfor (int i = -1; i <= 1; i++) {\n\t\tif (now.second + 1 > 999)break;\n\t\tif (now.first + i < 0 || now.first + i>999)continue;\n\t\tif (cave_num[now.first + i][now.second + 1] > m)continue;\n\t\tP next = dfs(cave_num[now.first + i][now.second + 1]);\n\t\tif (res1 <= next.first) {\n\t\t\tif (res1 == next.first) {\n\t\t\t\tres2 = max(res2, next.second);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres2 = next.second;\n\t\t\t}\n\t\t\tres1 = next.first;\n\t\t}\n\t}\n\tif (is_prime[n]) {\n\t\tif (res2 == 0)res2 = n;\n\t\tres1++;\n\t}\n\treturn dp[n] = P(res1, res2);\n}\n\nvoid num() {\n\tint sx = 499, sy = 500;\n\tint x = 1; cave_num[sx][sy] = x; trans[x] = P(sx, sy);\n\tfor (int i = 1; i <= 999; i++) {\n\t\tif (i % 2) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tcave_num[++sx][sy] = ++x;\n\t\t\t\ttrans[x] = P(sx, sy);\n\t\t\t}\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tcave_num[sx][--sy] = ++x;\n\t\t\t\ttrans[x] = P(sx, sy);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tcave_num[--sx][sy] = ++x;\n\t\t\t\ttrans[x] = P(sx, sy);\n\t\t\t}\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tcave_num[sx][++sy] = ++x;\n\t\t\t\ttrans[x] = P(sx, sy);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 999; i++) {\n\t\tcave_num[--sx][sy] = ++x;\n\t\ttrans[x] = P(sx, sy);\n\t}\n}\n\nint main() {\n\tint n;\n\tprime();\n\tnum();\n\twhile (scanf(\"%d %d\", &m, &n), m) {\n\t\tfor (int i = 0; i <= m; i++)dp[i] = P(-1, -1);\n\t\tP p = dfs(n);\n\t\tprintf(\"%d %d\\n\", p.first, p.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int MAX_M = 1000001;\nconst int MAX_C = 1000;\nconst int INF = 1e9;\n#define y first\n#define x second\n\nmap<P, int> ptoi;\nbool isp[MAX_M];\nP dp[MAX_C][MAX_C];\n\nvoid make_prime(){\n  REP(i, MAX_M) isp[i] = true;\n  isp[0] = isp[1] = false;\n  FOR(i, 2, sqrt(MAX_M) + 1){\n    if(!isp[i]) continue;\n    for(int j = i + i; j < MAX_M; j += i) isp[j] = false;\n  }\n}\n\nvoid init(){\n  P now = P(MAX_C / 2, MAX_C / 2);\n  int pls = 1, l = 1, step = 0, d = 0;\n  FOR(i, 1, MAX_M){\n    ptoi[now] = i;\n    if(d == 0) now.x += 1;\n    else if(d == 1) now.y -= 1;\n    else if(d == 2) now.x -= 1;\n    else if(d == 3) now.y += 1;\n    ++step;\n    if(step >= l){\n      d = (d + 1) % 4;\n      step = 0;\n    }\n    if(i != 1 && (d == 0 || d == 2) && step == 0) ++l;\n  }\n}\n\nint main() {\n  make_prime();\n  init();\n  int M, N;\n  while(cin >>M >>N && (N && M)){\n    REP(i, MAX_C) REP(j, MAX_C) dp[i][j] = P(-1, -1);\n    REP(i, MAX_C) REP(j, MAX_C) if(ptoi[P(i, j)] == N) dp[i][j] = (isp[N] ? P(1, N) : P(0, -1));\n    P ans = P(-1, -1);\n    REP(y, MAX_C){\n      REP(x, MAX_C){\n        if(dp[y][x].first == -1 || ptoi.find(P(y, x)) == ptoi.end()) continue;\n        ans = max(ans, dp[y][x]);\n        for(int mx = -1; mx <= 1; ++mx){\n          int ny = y + 1, nx = x + mx;\n          if(ny < 0 || nx < 0 || ny >= MAX_C || nx >= MAX_C || ptoi.find(P(ny, nx)) == ptoi.end()) continue;\n          int cnt = dp[y][x].first + (isp[ptoi[P(ny, nx)]] ? 1 : 0), num = (isp[ptoi[P(ny, nx)]] ? ptoi[P(ny, nx)] : dp[y][x].second);\n          if(num > M) continue;\n          if(cnt > dp[ny][nx].first || (cnt == dp[ny][nx].first && num > dp[ny][nx].second)) dp[ny][nx] = P(cnt, num);\n        }\n      }\n    }\n    if(ans.first == 0) cout <<\"0 0\" <<endl;\n    else cout <<ans.first <<\" \" <<ans.second <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[(SIZE + 1)*(SIZE + 1) + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tint res1, res2;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= (SIZE + 1)*(SIZE + 1);i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= (SIZE + 1)*(SIZE + 1);j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 || n == 0)return 0;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(y=SIZE-1;y>=0;y--){\n\t\t\tfor(x=SIZE-1;x>=0;x--){\n\t\t\t\tif (table[y][x] <= m) {\n\t\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m && (dp[y][x] < dp[y + 1][x - 1] || (dp[y][x] == dp[y + 1][x - 1] && pr[y][x] < pr[y + 1][x - 1]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x] < dp[y + 1][x] || (dp[y][x] == dp[y + 1][x] && pr[y][x] < pr[y + 1][x]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (x + 1 < SIZE && table[y + 1][x + 1] <= m && (dp[y][x] < dp[y + 1][x + 1] || (dp[y][x] == dp[y + 1][x + 1] && pr[y][x] < pr[y + 1][x + 1]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (y = 0;y < SIZE;y++) {\n\t\t\tfor (x = 0;x < SIZE;x++) {\n\t\t\t\tif (table[y][x] == n) {\n\t\t\t\t\tres1 = dp[y][x];\n\t\t\t\t\tres2 = pr[y][x];\n\t\t\t\t\t//printf(\"%d\\n\", dp[y][x]);\n\t\t\t\t\t//cout << dp[y][x] << \" \";\n\t\t\t\t\t//cout << pr[y][x] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", res1, res2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\ntypedef vector<VPII> VVPII;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define rep(i, N) for (int i = 0; i < (N); i++)\n#define rep2(i, j, N, M) rep(i, N) rep(j, M)\n#define rep3(i, j, k, N, M, L) rep(i, N) rep(j, M) rep(k, L)\n#define REP(i, init, N) for (int i = (init); i < (N); i++)\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nvector<bool> Prime;\nvoid initPrime(LL num) {\n\tPrime = vector<bool>(num + 1, true);\n\tPrime[1] = Prime[0] = false;\n\tLL sq_num = sqrt((double)num);\n\tfor (LL i = 2; i <= sq_num; i++) {\n\t\tif (Prime[i]) {\n\t\t\tfor (LL j = i + i; j <= num; j += i) {\n\t\t\t\tPrime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint M, N;\n\nconstexpr int MAX_M = 1000000;\nconstexpr int OFFSET = 500;\nconstexpr int HW = 1010;\n\nVVPII memos;\nVVI ts;\n\nvoid make_ts() {\n    ts = VVI(HW, VI(HW));\n\n    int y = OFFSET, x = OFFSET;\n    int m = 1;\n    int di = 0;\n\n    ts[y][x] = m++;\n\n    while (true) {\n        y += DY[di];\n        x += DX[di];\n        ts[y][x] = m;\n        if (++m > MAX_M) return;\n\n        int ndi = (di + 1) % 4;\n        int ny = y + DY[ndi];\n        int nx = x + DX[ndi];\n        if (ts[ny][nx] == 0) {\n            di = ndi;\n        }\n    }\n}\n\nPII find_p(int n) {\n    rep(y, HW) rep(x, HW) {\n        if (ts[y][x] == n) return MP(y, x);\n    }\n    return MP(-1, -1);\n}\n\nPII dfs(int y, int x) {\n//    printf(\"%d %d\\n\", y, x);\n    if (memos[y][x].fst != -1) {\n        return memos[y][x];\n    }\n\n    int t = ts[y][x];\n\n    PII res = MP(0, Prime[t] ? t : 0);\n    for (int i = -1; i <= 1; i++) {\n        int ny = y + 1;\n        int nx = x + i;\n        int nt = ts[ny][nx];\n\n        if (nt == 0 || nt > M) continue;\n\n        PII tmp = dfs(ny, nx);\n        res = max(res, tmp);\n    }\n\n    return memos[y][x] = MP(res.fst + Prime[t], res.snd);\n}\n\nvoid dump() {\n    rep(y, 33) {\n        rep(x, 10) {\n            int yy = y + OFFSET - 17;\n            int xx = x + OFFSET - 17;\n            int t = ts[yy][xx];\n//            printf(\"%5d\", t);\n//            cout << (Prime[t] ? '@' : ' ');\n            PII p = memos[yy][xx];\n            printf(\"(%2d %4d %4d) \", p.fst, p.snd, t);\n        }\n        cout << endl;\n    }\n}\n\nint main(void) {\n    initPrime(MAX_M);\n    make_ts();\n\n    while (cin >> M >> N, N) {\n        memos = VVPII(HW, VPII(HW, MP(-1, -1)));\n        PII p = find_p(N);\n        PII ans = dfs(p.fst, p.snd);\n        cout << ans.fst << \" \" << ans.snd << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define MAX_M 1000000\n#define PRIME_NUM MAX_M\n#define SPIRAL_NUM 1003\n#define DIR_FOUR 4 // dyとdxのための値\n#define DIR_THREE 3 // udyとudxのための値\n\n\nconst int dy[4] = {-1,0,1,0}, dx[4] = {0,1,0,-1}; // 上下左右4方向\nconst int udy[3] = {1,1,1}, udx[3] = {-1,0,1}; // 下3方向\n\n\nint *primeNumber(int num){\n\tint i, j, *ret;\n\tret = (int *)malloc(sizeof(int) * (num + 1));\n\tfor(i = 0;i <= num;i++) ret[i] = 1;\n\tret[0] = ret[1] = 0;\n\tfor(i = 2;i * i <= num;i++){\n\t\tif(ret[i] == 1){\n\t\t\tfor(j = 2 * i;j <= num;j+=i){\n\t\t\t\tret[j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint **spiralArray(int arg1,int arg2){ // arg1 は2次元配列をつくるためのもの　arg2 はどの値までスパイラルし続けるか\n\tint i, j, **ret, x, y, dir;\n\tret = (int **)malloc(sizeof(int *) * arg1);\n\tfor(i = 0;i < arg1;i++){\n\t\tret[i] = (int *)malloc(sizeof(int) * arg1);\n\t}\n\tfor(i = 0;i < arg1;i++){\n\t\tfor(j = 0;j < arg1;j++){\n\t\t\tret[i][j] = -1;\n\t\t}\n\t}\n\ty = arg1 / 2;\n\tx = arg1 / 2 + 1;\n\tdir = 0; // dirの向きにまだ数字が設定されていなければdirの方向　そうでなければ(dir + 1) % 4の方向\n\tret[y][x - 1] = 1;\n\tret[y][x] = 2;\n\n\tfor(i = 3;i <= arg2;i++){\n\t\tif(ret[y + dy[dir]][x + dx[dir]] == -1){\n\t\t\ty += dy[dir]; x += dx[dir];\n\t\t\tret[y][x] = i;\n\t\t\tdir = (dir + (DIR_FOUR - 1)) % DIR_FOUR;\n\t\t}else{\n\t\t\ty += dy[(dir + 1) % DIR_FOUR]; x += dx[(dir + 1) % DIR_FOUR];\n\t\t\tret[y][x] = i;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nint main(void){\n\tint i, j, *pn, **sp, m, n, sx, sy, dp[SPIRAL_NUM][SPIRAL_NUM];\n\tpn = primeNumber(PRIME_NUM);\n\tsp = spiralArray(SPIRAL_NUM,PRIME_NUM);\n\twhile(1){\n\t\tscanf(\"%d%d\",&m,&n);\n\t\tif(m == 0 && n == 0){\n\t\t\tbreak;\n\t\t}\n\n\t\t// スタート地点の探索\n\t\tfor(i = 0;i < SPIRAL_NUM;i++){\n\t\t\tfor(j = 0;j < SPIRAL_NUM;j++){\n\t\t\t\tif(sp[i][j] == n){\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tdp[sy][sx] = 0;\n\t\tif(pn[n] == 1){\n\t\t\tdp[sy][sx]++;\n\t\t}\n\t\tint y, x;\n\t\tfor(y = 0;y < SPIRAL_NUM;y++){\n\t\t\tfor(x = 0;x < SPIRAL_NUM;x++){\n\t\t\t\tfor(i = 0;i < DIR_THREE;i++){\n\t\t\t\t\tint ny = y + udy[i], nx = x + udx[i];\n\t\t\t\t\tif(ny < 0 || SPIRAL_NUM <= ny || nx < 0 || SPIRAL_NUM <= nx){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[y][x] != -1 && sp[ny][nx] != -1 && sp[ny][nx] <= m && (dp[ny][nx] == -1 || dp[ny][nx] < dp[y][x] + 1 || (dp[ny][nx] == dp[y][x] && pn[sp[ny][nx]] == 1))){\n\t\t\t\t\t\tif(pn[sp[ny][nx]] == 1){\n\t\t\t\t\t\t\tdp[ny][nx] = dp[y][x] + 1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tdp[ny][nx] = dp[y][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans1 = 0, ans2 = 0;;\n\t\tfor(i = 0;i < SPIRAL_NUM;i++){\n\t\t\tfor(j = 0;j < SPIRAL_NUM;j++){\n\t\t\t\tif(pn[sp[i][j]] == 1 && (ans1 < dp[i][j] || (ans1 == dp[i][j] && ans2 < sp[i][j]))){\n\t\t\t\t\tans1 = dp[i][j];\n\t\t\t\t\tans2 = sp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans1 == 0){\n\t\t\tprintf(\"0 0\\n\");\n\t\t}else{\n\t\t\tprintf(\"%d %d\\n\",ans1, ans2);\n\t\t}\n/*\t\tfor(i = 0;i < SPIRAL_NUM;i++){\n\t\t\tfor(j = 0;j < SPIRAL_NUM;j++){\n\t\t\t\tprintf(\"%3d \",dp[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}*/\n\t}\n\tfree(pn);\n\tfree(sp);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n, m;\nint cave[1001][1001];\nP dp[1000005];\nbool prime[1000005];\n\nP search(int x, int y, int val)\n{\n\tint nx, ny;\n\tP ret = make_pair(0, -1);\n\t\n\tif(dp[val].first != -1) return dp[val];\n\t\n\tfor(int v = -1; v <= 1; v++){\n\t\tnx = x + v, ny = y + 1;\n\t\tif(nx < 0 || nx >= 1001 || ny < 0 || ny >= 1001) continue;\n\t\tif(cave[nx][ny] > n) continue;\n\t\tret = max(ret, search(nx, ny, cave[nx][ny]));\n\t}\n\tif(!prime[val]){\n\t\tret.first++;\n\t\tif(ret.second == -1) ret.second = val;\n\t}\n\t\n\treturn dp[val] = ret;\n}\n\nint main(void)\n{\n\tint px = 500, py = 500, dir = 0, dir2;\n\tconst int vx[4] = {1, 0, -1, 0}, vy[4] = {0, -1, 0, 1};\n\t\n\tint nx, ny;\n\tfor(int i = 1; i <= 1001 * 1001 - 1; i++){\n\t\tcave[px][py] = i;\n\t\tpx += vx[dir], py += vy[dir];\n\t\tdir2 = (dir+1)%4;\n\t\tif(cave[px + vx[dir2]][py + vy[dir2]] == 0) dir = dir2;\n\t}\n\t\n\tprime[1] = true;\n\tfor(int i = 2; i < 1100; i++){\n\t\tif(!prime[i]){\n\t\t\tfor(int j = 2 * i; j < 1000005; j += i) prime[j] = true;\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < 10; i++){\n\t\tfor(int j = 0; j < 10; j++){\n\t\t\tcout << cave[j][i] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\t\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0) break;\n\t\t\n\t\tfor(int i = 1; i <= n; i++) dp[i] = make_pair(-1, -1);\n\t\t\n\t\tint x, y;\n\t\tfor(x = 0; x < 1001; x++){\n\t\t\tfor(y = 0; y < 1001; y++){\n\t\t\t\tif(cave[x][y] == m) goto end;\n\t\t\t}\n\t\t}\n\t\tend:;\n\t\t\n\t\tP ans = search(x, y, m);\n\t\tif(ans.first == 0) ans.second = 0;\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define INF INT_MAX/2\n\n\nvector<bool> primes;\nvoid make_primes(int n)\n{\n\tprimes.resize(n+1, true);\n\tprimes[0] = primes[1] = false;\n\trep(i, 2, sqrt(n))\n\t{\n\t\tif (primes[i])\n\t\t{\n\t\t\tfor (int j = 0; i * (j + 2) < n; j++)\n\t\t\t\tprimes[i * (j + 2)] = false;\n\t\t}\n\t}\n}\n\n\n\nint x[1000001];\nint y[1000001];\nmap<pair<int, int>, int> xy;\nvoid make_xy()\n{\n\tx[1] = 10000;\n\ty[1] = 10000;\n\txy[make_pair(10000, 10000)] = 1;\n\n\tint now_n = 1;\n\tint now_x = 10000;\n\tint now_y = 10000;\n\tint n = 1;\n\twhile (1)\n\t{\n\t\tif (now_n == 1000000) return;\n\t\tnow_n++;\n\t\tnow_x++;\n\t\tx[now_n] = now_x;\n\t\ty[now_n] = now_y;\n\t\txy[make_pair(now_x, now_y)] = now_n;\n\n\t\trep(j, 0, n * 2 - 1)\n\t\t{\n\t\t\tif (now_n == 1000000) return;\n\t\t\tnow_n++;\n\t\t\tnow_y--;\n\t\t\tx[now_n] = now_x;\n\t\t\ty[now_n] = now_y;\n\t\t\txy[make_pair(now_x, now_y)] = now_n;\n\t\t}\n\n\t\trep(j, 0, n * 2)\n\t\t{\n\t\t\tif (now_n == 1000000) return;\n\t\t\tnow_n++;\n\t\t\tnow_x--;\n\t\t\tx[now_n] = now_x;\n\t\t\ty[now_n] = now_y;\n\t\t\txy[make_pair(now_x, now_y)] = now_n;\n\t\t}\n\n\t\trep(j, 0, n * 2)\n\t\t{\n\t\t\tif (now_n == 1000000) return;\n\t\t\tnow_n++;\n\t\t\tnow_y++;\n\t\t\tx[now_n] = now_x;\n\t\t\ty[now_n] = now_y;\n\t\t\txy[make_pair(now_x, now_y)] = now_n;\n\t\t}\n\n\t\trep(j, 0, n * 2)\n\t\t{\n\t\t\tif (now_n == 1000000) return;\n\t\t\tnow_n++;\n\t\t\tnow_x++;\n\t\t\tx[now_n] = now_x;\n\t\t\ty[now_n] = now_y;\n\t\t\txy[make_pair(now_x, now_y)] = now_n;\n\t\t}\n\n\t\tn++;\n\t}\n}\n\n\ntypedef vector<int> vi;\n\nvoid solve(int M, int N)\n{\n\tvi dp(M+1, 0);\n\tset<int> next;\n\tnext.insert(N);\n\tif (primes[N]) dp[N] = 1;\n\n\tint dx[3] = {-1, 0, 1};\n\n\twhile (next.size() != 0)\n\t{\n\t\tset<int> _set;\n\t\tfor (int i : next) rep(j, 0, 3)\n\t\t{\n\t\t\tint xx = x[i] + dx[j];\n\t\t\tint yy = y[i] + 1;\n\t\t\tpair<int, int> p = make_pair(xx, yy);\n\n\t\t\tif (xy.find(p) == xy.end()) continue;\n\t\t\tif (M < xy[p]) continue;\n\n\t\t\tint n = xy[p];\n\t\t\tint a = dp[i];\n\t\t\tif (primes[n]) a++;\n\n\t\t\tdp[n] = max(dp[n], a);\n\t\t\t_set.insert(n);\n\t\t}\n\n\t\tnext = _set;\n\t}\n\n\tint _max = 0;\n\tint _ans = 0;\n\trep(i, 0, M + 1)\n\t{\n\t\tif (!primes[i]) continue;\n\n\t\tif (_max < dp[i])\n\t\t{\n\t\t\t_max = dp[i];\n\t\t\t_ans = i;\n\t\t}\n\t\telse if (_max == dp[i])\n\t\t{\n\t\t\t_ans = i;\n\t\t}\n\t}\n\n\tcout << _max << \" \" << _ans << endl;\n}\n\nint main()\n{\n\tmake_primes(1000000);\n\tmake_xy();\n\n\twhile (1)\n\t{\n\t\tint M, N;\n\t\tcin >> M >> N;\n\t\tif (M == 0) return 0;\n\n\t\tsolve(M, N);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=x && x<w && 0<=y && y<h)\n\nconst int INF = 10000000;\nint dx[4]={1, 0, -1, 0}, dy[4]={0, 1, 0, -1};\nusing namespace std;\ntypedef pair<int, int> P;\n\n/** Problem1189 : Prime Caves **/\nint caves[1010][1010];\nint dp[1010][1010];\nconst int MAX = 1030000;\nbool prime[MAX];\n\nint main()\n{\n\tint m, n;\n\tconst int dx0[4] = {1, 0, -1, 0}, dy0[4] = {0, -1, 0, 1}, dx1[3]={-1, 0, 1};\n\tint sx, sy;\n\t\n\tfor (int i=0; i<MAX; i++)\n\t\tprime[i] = true;\n\t\n\tprime[0] = false; prime[1] = false;\n\t\n\tfor (int i=2; i<MAX; i++) {\n\t\tif (prime[i]) {\n\t\t\tfor (int j=2; i*j<MAX; j++) {\n\t\t\t\tprime[i*j] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\twhile (cin>>m>>n, m||n) {\n\t\tfill(caves[0], caves[0]+1010*1010, 0);\n\t\tfill(dp[0], dp[0]+1010*1010, -1);\n\t\tint x=1010/2, y=1010/2 , t=1, direct=1;\n\t\tcaves[x][y]=1;\n\t\tcaves[++x][y]=2;\n\t\tint i=2; bool change = true;\n\t\twhile (1) {\n\t\t\trep(j, t) {\n\t\t\t\tx+=dx0[direct]; y+=dy0[direct];\n\t\t\t\tcaves[x][y]=i+1;\n\t\t\t\ti++;\n\t\t\t\tif (i==n) {\n\t\t\t\t\tsx = x; sy = y;\n\t\t\t\t}\n\t\t\t\tif (i>=m) goto end;\n\t\t\t}\n\t\t\tif (change) {\n\t\t\t\tt++;\n\t\t\t\tchange = false;\n\t\t\t} else {\n\t\t\t\tchange=true;\n\t\t\t}\n\t\t\tdirect++; direct%=4;\n\t\t}\n\t}\n\n\tend: ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\nint grid[1010][1010];\npair<int, int> dp[1000010];\npair<int, int> c[1010000];\nint is_prime[1010000];\nint visited[1010000];\nint main() {\n    int yy = 505, xx = 505;\n\n    c[1] = make_pair(yy, xx);\n    int cnt = 2;\n\n    for (int i = 0; i < 1010; ++i) {\n        for (int j = 0; j < 1010; ++j) {\n            grid[i][j] = INF<int>;\n        }\n    }\n    grid[yy][xx] = 1;\n    xx++;\n    for (int i = 0; i < 500; ++i) {\n        for (int j = 0; j < 2*i+1; ++j) {\n            c[cnt] = make_pair(yy, xx);\n            grid[yy][xx] = cnt;\n            yy--; cnt++;\n        }\n        for (int j = 0; j < 2*i+2; ++j) {\n            c[cnt] = make_pair(yy, xx);\n            grid[yy][xx] = cnt;\n            xx--; cnt++;\n        }\n\n        for (int j = 0; j < 2*i+2; ++j) {\n            c[cnt] = make_pair(yy, xx);\n            grid[yy][xx] = cnt;\n            yy++; cnt++;\n        }\n        for (int j = 0; j < 2*i+3; ++j) {\n            c[cnt] = make_pair(yy, xx);\n            grid[yy][xx] = cnt;\n            xx++; cnt++;\n        }\n    }\n    int n, m;\n    fill_n(is_prime, 1000010, 1);\n    is_prime[0] = is_prime[1] = 0;\n    for (int i = 2; i <= 1000010; ++i) {\n        if(!is_prime[i]) continue;\n        for (int j = i*2; j <= 1000010; j += i) {\n            is_prime[j] = 0;\n        }\n    }\n    while(cin >> n >> m, n){\n        int sy, sx; tie(sy, sx) = c[m];\n        fill_n(visited, n+1, 0);\n        fill_n(dp, n+1, make_pair(-MOD, 0));\n        dp[m] = make_pair(is_prime[m], (is_prime[m] ? m : 0));\n        queue<pair<int, int>> q;\n        q.emplace(sy, sx);\n        pair<int, int> ans;\n        visited[m] = 1;\n        while(!q.empty()){\n            int y, x; tie(y, x) = q.front(); q.pop();\n            int num1 = grid[y][x];\n            for (int i = -1; i <= 1; ++i) {\n                int num2 = grid[y+1][x+i];\n                if(num2 > n){\n                    if(dp[num1] > ans){\n                        ans = dp[num1];\n                    }\n                }else {\n                    dp[num2] = max(dp[num2], make_pair(dp[num1].first+is_prime[num2],\n                                                       (is_prime[num2] ? num2 : dp[num1].second)));\n                    if(!visited[num2]){\n                        q.emplace(y+1, x+i);\n                        visited[num2] = 1;\n                    }\n                }\n            }\n        }\n\n        printf(\"%d %d\\n\", ans.first, ans.second);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst int N = 1111111;\nbool prime[N + 1];\nvector<int> primes;\n\nvoid hurui()\n{\n\tmemset(prime, true, sizeof(prime));\n\tprime[0] = prime[1] = false;\n\tfor (int i = 2; i*i < N; i++)\n\t{\n\t\tif (!prime[i]) continue;\n\t\tfor (int j = i; i*j < N; j++)\n\t\t{\n\t\t\tprime[i*j] = false;\n\t\t}\n\t}\n\tREP(i, N + 1)\n\t{\n\t\tif (prime[i]) primes.push_back(i);\n\t}\n}\n\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\n\nbool fld[1200][1200] = {};\nint ind[1200][1200];\npii hs[1111111];\n\nvoid init()\n{\n\tREP(i, 1200)REP(j, 1200) ind[i][j] = INF;\n\thurui();\n\tint p = 1, x = 600, y = 600;\n\tFOR(i, 1, 11111111)\n\t{\n\t\tif (i % 2)\n\t\t{\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tind[x][y] = p;\n\t\t\t\ths[p] = pii(x, y);\n\t\t\t\tif (prime[p]) fld[x][y] = true;\n\t\t\t\tp++;\n\t\t\t\ty++;\n\t\t\t}\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tind[x][y] = p;\n\t\t\t\ths[p] = pii(x, y);\n\t\t\t\tif (prime[p]) fld[x][y] = true;\n\t\t\t\tp++;\n\t\t\t\tx--;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tind[x][y] = p;\n\t\t\t\ths[p] = pii(x, y);\n\t\t\t\tif (prime[p]) fld[x][y] = true;\n\t\t\t\tp++;\n\t\t\t\ty--;\n\t\t\t}\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tind[x][y] = p;\n\t\t\t\ths[p] = pii(x, y);\n\t\t\t\tif (prime[p]) fld[x][y] = true;\n\t\t\t\tp++;\n\t\t\t\tx++;\n\t\t\t}\n\t\t}\n\t\tif (p > 1000000) break;\n\t}\n}\n\npii dp[1200][1200];\nint n, m;\n\npii solve(int x, int y)\n{\n\tif (dp[x][y] != pii(-1, -1)) return dp[x][y];\n\tpii res(0, -1);\n\tFOR(i, -1, 2)\n\t{\n\t\tint nx = x + 1, ny = y + i;\n\t\tif (ind[nx][ny] > m) continue;\n\t\tpii next = solve(nx, ny);\n\t\tif (fld[nx][ny])\n\t\t{\n\t\t\tif (next.first == 0) chmax(res, pii(next.first + 1, ind[nx][ny]));\n\t\t\telse chmax(res, pii(next.first + 1, next.second));\n\t\t}\n\t\telse chmax(res, next);\n\t}\n\treturn dp[x][y] = res;\n}\n\nint main()\n{\n\tinit();\n\twhile (cin >> m >> n, n)\n\t{\n\t\tREP(i, 1200)REP(j, 1200) dp[i][j] = pii(-1, -1);\n\t\tpii ans = solve(hs[n].first, hs[n].second);\n\t\tif (prime[n])\n\t\t{\n\t\t\tans.first++;\n\t\t\tif (ans.first == 1) ans.second = n;\n\t\t}\n\t\tif (ans.first == 0) cout << \"0 0\" << endl;\n\t\telse cout << ans.first << \" \" << ans.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nusing namespace std;\n  \n#define MP make_pair\n#define PB push_back\n#define MAX_N 1010000\n#define SIZE 3000\n#define X first\n#define Y second\n  \nconst int STX = 1500, STY = 1500;\n\ntypedef pair<int, int> Pii;\ntypedef pair<int, Pii> P;\n  \nint id[SIZE][SIZE];\nbool is_prime[MAX_N+1];\nvector<Pii> coord;\n\nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++)\n    if(is_prime[i])\n      for(int j=i*i; j<=MAX_N; j+=i)\n\tis_prime[j] = false;\n}\n\nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  \n  coord.PB(MP(0, 0)); // no use\n  cnt ++;\n  coord.PB(MP(x, y)); // cnt = 1\n  \n  fill(id[0], id[0]+SIZE*SIZE+1, -1);\n  \n  const int dx[] = {0,-1,0,1};\n  const int dy[] = {-1,0,1,0};\n  \n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt <= MAX_N) {\n    a += 2;\n    for(int turn=0; turn<4; turn++) {\n      for(int i=0; i<a; i++) {\n\tx += dx[turn], y += dy[turn];\n\tcoord.PB(MP(x, y));\n\tid[y][x] = ++ cnt;\n      }\n    }\n    x++, y++;\n  }\n}\n\nint main() {\n  \n  Sieve();\n  MakeMap();\n  \n  int m, n;\n  int dp[MAX_N+1];\n\n  while(cin >> m >> n && (m|n)) {\n    \n    fill(dp, dp+MAX_N+1, -1);\n    dp[n] = is_prime[n];\n    Pii ans(dp[n], n);\n    \n    queue<P> que;\n    que.push(P(dp[n], coord[n]));\n    while(!que.empty()) {\n      P now = que.front(); que.pop();\n      int tmpid = id[now.second.Y][now.second.X];\n      if(now.first < dp[tmpid]) continue;\n      \n      int noid = id[now.second.Y][now.second.X];\n      \n      for(int i=-1; i<=1; i++) {\n\tPii nex = MP(now.second.X+i, now.second.Y+1);\n\tif(nex.X < 0 || SIZE <= nex.X || nex.Y < 0 || SIZE <= nex.Y) continue;\n\tint neid = id[nex.Y][nex.X];\n\tif(neid <= m) {\n\t  if(dp[neid] < dp[noid] + is_prime[neid]) {\n\t    dp[neid] = dp[noid] + is_prime[neid];\n\t    if(is_prime[neid]) ans = max(ans, MP(dp[neid], neid));\n\t    que.push(P(dp[neid], nex));\n\t  }\n\t}\n      }\n\n    }\n    \n    if(ans.first == 0) cout << \"0 0\" << endl;\n    else cout << ans.first << ' ' << ans.second << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n  \n#define MP make_pair\n#define PB push_back\n#define MAX_N 1100000\n#define SIZE 1200\n#define X first\n#define Y second\n  \nconst int STX = 600, STY = 600;\n\ntypedef pair<int, int> Pii;\ntypedef pair<int, Pii> P;\n  \nint id[SIZE][SIZE];\nbool is_prime[MAX_N+1];\nvector<Pii> coord;\n\nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++)\n    if(is_prime[i])\n      for(int j=i*i; j<=MAX_N; j+=i)\n\tis_prime[j] = false;\n}\n\nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  \n  coord.PB(MP(0, 0)); // no use\n  cnt ++;\n  coord.PB(MP(x, y)); // cnt = 1\n  \n  fill(id[0], id[0]+SIZE*SIZE+1, -1);\n  \n  const int dx[] = {0,-1,0,1};\n  const int dy[] = {-1,0,1,0};\n  \n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt <= MAX_N) {\n    a += 2;\n    for(int turn=0; turn<4; turn++) {\n      for(int i=0; i<a; i++) {\n\tx += dx[turn], y += dy[turn];\n\tcoord.PB(MP(x, y));\n\tid[y][x] = ++ cnt;\n      }\n    }\n    x++, y++;\n  }\n}\n\nint dp[MAX_N+1];\n\nint main() {\n  \n  Sieve();\n  MakeMap();\n  \n  int m, n;\n\n  while(cin >> m >> n && (m|n)) {\n    \n    fill(dp, dp+MAX_N+1, -1);\n    dp[n] = is_prime[n];\n    Pii ans(dp[n], n);\n    \n    queue<P> que;\n    que.push(P(dp[n], coord[n]));\n    while(!que.empty()) {\n      P now = que.front(); que.pop();\n      int tmpid = id[now.second.Y][now.second.X];\n      if(now.first < dp[tmpid]) continue;\n      \n      int noid = id[now.second.Y][now.second.X];\n      \n      for(int i=-1; i<=1; i++) {\n\tPii nex = MP(now.second.X+i, now.second.Y+1);\n\tif(nex.X < 0 || SIZE <= nex.X || nex.Y < 0 || SIZE <= nex.Y) continue;\n\tint neid = id[nex.Y][nex.X];\n\tif(neid <= m) {\n\t  if(dp[neid] < dp[noid] + is_prime[neid]) {\n\t    dp[neid] = dp[noid] + is_prime[neid];\n\t    if(is_prime[neid]) ans = max(ans, MP(dp[neid], neid));\n\t    que.push(P(dp[neid], nex));\n\t  }\n\t}\n      }\n\n    }\n    \n    if(ans.first == 0) cout << \"0 0\" << endl;\n    else cout << ans.first << ' ' << ans.second << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main () {\n    const int max_m = 4 * 1000000;\n    vector< int > is_prime(max_m + 1, true);\n    is_prime[0] = is_prime[1] = false;\n\n    for (int i = 2; i <= max_m; ++i) {\n        if (is_prime[i]) {\n            for (int d = 2 * i; d < is_prime.size(); d += i) {\n                is_prime[d] = false;\n            }\n        }\n    }\n\n    vector< int > corner(max_m + 1, false);\n    int d = 1;\n    for (int i = 1; i <= max_m;) {\n        corner[i] = true;\n        if (i + d <= max_m) corner[i + d] = true;\n        i += 2 * d;\n        d += 1;\n    }\n\n    int m, n;\n\n    while (cin >> m >> n, m && n) {\n        vector< pair< int, int > > place(m + 1);\n        vector< vector< int > > h(2020, vector< int >(2020, 0));\n\n        int x = 1010, y = 1010;\n        int dx = 0, dy = 1;\n        for (int i = 1; i <= m; ++i) {\n            //cerr << x << \" \" << y << endl;\n            h[y][x] = i;\n            place[i] = make_pair(y, x);\n\n            if (corner[i]) {\n                int ny = dx;\n                int nx = -dy;\n                dx = nx;\n                dy = ny;\n            }\n\n            y += dy;\n            x += dx;\n        }\n\n        const int inf = 1001001001;\n        vector< vector< int > > dp(2020, vector<int>(2020, -inf)), pre(2020, vector<int>(2020, -1));\n        pair< int, int > s = place[n];\n        dp[s.first][s.second] = 0;\n\n//        cerr << s.first << \" \" << s.second << endl;\n//        cerr << h[s.first][s.second] << endl;\n\n        for (int i = 1; i < 2019; ++i) for (int j = 1; j < 2019; ++j) {\n        //ragne(i, 1, 2019) range(j, 1, 2019) {\n            if (is_prime[h[i][j]]) {\n                dp[i][j]++;\n                pre[i][j] = h[i][j];\n            }\n\n            if (dp[i][j] == -inf) continue;\n\n//            if (dp[i][j] != -inf && h[i][j] != 0) {\n//                cerr << i << \" \" << j << endl;\n//                cerr << dp[i][j] << endl;\n//            }\n\n\n            for (int d = -1; d <= 1; ++d) {\n                if (dp[i + 1][j + d] < dp[i][j]) {\n                    dp[i + 1][j + d] = dp[i][j];\n                    pre[i + 1][j + d] = pre[i][j];\n                } else if (dp[i + 1][j + d] == dp[i][j]) {\n                    pre[i + 1][j + d] = max(pre[i][j], pre[i + 1][j + d]);\n                }\n            }\n\n            //if (dp[i + 1][j - 1] < dp[i][j]) {\n            //    dp[i + 1][j - 1] = dp[i][j];\n            //    pre[i + 1][j - 1] = pre[i][j];\n            //}\n\n            //if (dp[i + 1][j] < dp[i][j]) {\n            //    dp[i + 1][j] = dp[i][j];\n            //    pre[i + 1][j] = pre[i][j];\n            //}\n\n            //if (dp[i + 1][j + 1] < dp[i][j]) {\n            //    dp[i + 1][j + 1] = dp[i][j];\n            //    pre[i + 1][j + 1] = pre[i][j];\n            //}\n        }\n\n        int ansa = -inf, ansb = -1;\n        for (int j = 0; j < 2020; ++j) {\n            if (ansa < dp.back()[j]) {\n                ansa = dp.back()[j];\n                ansb = pre.back()[j];\n            }\n            else if (ansa == dp.back()[j]) {\n                ansb = max(ansb, pre.back()[j]);\n            }\n        }\n\n        if (ansa == 0) {\n            cout << 0 << \" \" << 0 << endl;\n        } else {\n            cout << ansa << \" \" << ansb << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define H 1000\n#define W 1000\nusing namespace std;\nint grid[H][W];\ntypedef pair<int, int> pii;\n\npii dp[(int)1e6 + 1];//first cnt, second max\nbool isprime[(int)1e6 + 1];\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid sieve(int n){\n  isprime[0] = isprime[1] = true;\n  for(int i = 2; i <= n; i++){\n    if(isprime[i])continue;\n    for(int j = 2*i; j <= n; j+=i)isprime[j] = true;\n  }\n}\n\n\nbool renge(int x, int y){\n  if(0 <= x && x < W &&\n     0 <= y && y < H)return true;\n  return false;\n}\nvector<int> inM(int y, int x, int m){\n  vector<int> res;\n  if(y + 1 >= H) return res;\n  for(int i = -1; i < 2; i++){\n    if(grid[y + 1][x + i] <= m)res.push_back(i);\n  }\n  return res;\n}\n\nint main(int argc, char *argv[]){\n  sieve((int)1e6);\n  int n = H*W, m, x = 0, y = 0, dir = 0;\n  while(n > 1){\n    for(;renge(x + dx[dir], y + dy[dir]) && \n\t  grid[y + dy[dir]][x + dx[dir]] == 0;){\n      grid[y][x] = n;\n      n--;\n      x += dx[dir], y += dy[dir];\n    }\n    grid[y][x] = n;\n    n--;\n    dir++;\n    dir %= 4;\n    x += dx[dir], y += dy[dir];\n  }\n  while(cin >> m >> n, n){\n    memset(dp, 0, sizeof(dp));\n    for(int i = H - 1; i >= 0; i--){\n      for(int j = 0; j < W; j++){\n\tif(grid[i][j] <= m){\n\t  vector<int> cand = inM(i, j, m);\n\t  for(int k = 0; k < cand.size(); k++){\n\t    dp[grid[i][j]] = max(dp[grid[i][j]], dp[grid[i + 1][j + cand[k]]]);\n\t  }\n\t  if(!isprime[grid[i][j]]){\n\t    dp[grid[i][j]].first++;\n\t    if(dp[grid[i][j]].second == 0)dp[grid[i][j]].second = max(grid[i][j], dp[grid[i][j]].second);\n\t  }\n\t}\n      }\n    }\n    cout << dp[n].first << \" \" << dp[n].second << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nnamespace std {\n    template <>\n    class hash<std::pair<int, int>> {\n    public:\n        size_t operator()(const std::pair<int, int>& x) const{\n            return size_t((size_t)x.first * (size_t)x.second);\n        }\n    };\n}\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvoid solve(){\n    vector<bool> is_prime(1e6+1,true);\n    is_prime[0]=is_prime[1]=false;\n    rep(i,2,1e+6+1){\n        if(!is_prime[i]) continue;\n        for(int j=i*2; j<1e6+1; j+=i) is_prime[j]=false;\n    }\n    while(true){\n        int m,n;\n        cin >> m >> n;\n        if(m==0 and n==0) break;\n\n        map<pii,int> encode;\n        map<int,pii> decode;\n        map<int,vector<int>> xs;\n        {\n            int x=0,y=0,dir=3;\n            rep(i,1,m+1){\n                encode[make_pair(x,y)]=i;\n                decode[i]=make_pair(x,y);\n                xs[y].push_back(x);\n                int nx=x+dx[(dir+1)%4],ny=y+dy[(dir+1)%4];\n                if(encode.find(make_pair(nx,ny))==encode.end()) dir=(dir+1)%4;\n                else{\n                    nx=x+dx[dir];\n                    ny=y+dy[dir];\n                }\n                x=nx;\n                y=ny;\n            }\n        }\n\n        map<pii,int> dp;\n        int y=decode[n].second+1,ans,max_num;\n        if(is_prime[n]){\n            dp[decode[n]]=1;\n            ans=1;\n            max_num=n;\n        }else{\n            dp[decode[n]]=0;\n            ans=0;\n            max_num=0;\n        }\n        while(xs.find(y)!=xs.end()){\n            if(xs.find(y-2)!=xs.end()) for(int x:xs[y-2]) dp.erase(make_pair(x,y));\n            for(int x:xs[y]){\n                int tmp=-1;\n                if(dp.find(make_pair(x-1,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x-1,y-1)]);\n                if(dp.find(make_pair(x,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x,y-1)]);\n                if(dp.find(make_pair(x+1,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x+1,y-1)]);\n                if(tmp==-1) continue;\n                if(is_prime[encode[make_pair(x,y)]]){\n                    ++tmp;\n                    if(tmp>ans){\n                        ans=tmp;\n                        max_num=encode[make_pair(x,y)];\n                    }else if(tmp==ans) max_num=max(max_num,encode[make_pair(x,y)]);\n                }\n                dp[make_pair(x,y)]=tmp;\n            }\n            ++y;\n        }\n\n        cout << ans << \" \" << max_num << endl;\n    }\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n\ntypedef long long ll;\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int MAXM = 1000100;\nbool isPrime[MAXM];\nint dp[1500][1500];\nint last[1500][1500];\n\nclass Board {\npublic:\n    vector<vector<int> > board;\n    vector<pair<int, int> > pos;\n    int maxDepth;\n    int minWidth;\n    int maxWidth;\n    Board(int n) {\n        maxDepth = 0;\n        minWidth = 1500;\n        maxWidth = 0;\n        pos.resize(n+10);\n        for (int i = 0; i < 1500; i++) {\n            vector<int> tmp(1500);\n            board.push_back(tmp);\n        }\n        pair<int, int> position = make_pair(750, 750);\n        int direction = 0;\n        for (int cur = 1; cur <= n; cur++) {\n            maxDepth = max(maxDepth, position.second);\n            maxWidth = max(maxWidth, position.first);\n            minWidth = min(minWidth, position.first);\n            board[position.second][position.first] = cur;\n            pos[cur] = position;\n            int left = direction+1;\n            left %= 4;\n            if (board[position.second+dy[left]][position.first+dx[left]] == 0) {\n                direction = left;\n            }\n            position.first += dx[direction];\n            position.second += dy[direction];\n        }\n    }\n};\n\nvoid initPrime() {\n    for (int i = 2; i < MAXM; i++) isPrime[i] = true;\n    for (int i = 2; i*i < MAXM; i++) {\n        if (isPrime[i]) {\n            for (int j = 2; j * i < MAXM; j++) {\n                isPrime[i*j] = false;\n            }\n        }\n    }\n}\n\nint main(void) {\n    int n, m;\n    initPrime();\n    while (cin >> n >> m) {\n        if (n == 0 && m == 0) break;\n        Board board(n);\n//        for (int i = 745; i < 755; i++) {\n//            for (int j = 745; j < 755; j++) {\n//                cout << board.board[i][j] << \"\\t\";\n//            }\n//            cout << endl;\n//        }\n//        cout << board.maxDepth << endl;\n        for (int i = 0; i < 1500; i++) {\n            for (int j = 0; j < 1500; j++) {\n                dp[i][j] = -1;\n                last[i][j] = -1;\n            }\n        }\n        auto start = board.pos[m];\n        if (isPrime[m]) dp[start.second][start.first] = 1, last[start.second][start.first] = m;\n        else dp[start.second][start.first] = 0;\n        for (int i = start.second; i <= board.maxDepth; i++) {\n            for (int j = board.minWidth; j <= board.maxWidth; j++) {\n                if (dp[i][j] == -1) continue;\n                for (int k = -1; k <= 1; k++) {\n                    pair<int, int> next = make_pair(j+k, i+1);\n                    if (next.first < board.minWidth || next.second > board.maxWidth || board.board[next.second][next.first] > n) continue;\n                    if (isPrime[board.board[next.second][next.first]]) {\n                        if (dp[next.second][next.first] <= dp[i][j] + 1) {\n                            dp[next.second][next.first] = dp[i][j] + 1;\n                            last[next.second][next.first] = board.board[next.second][next.first];\n                        }\n                    } else {\n                        if (dp[next.second][next.first] <= dp[i][j]) {\n                            dp[next.second][next.first] = dp[i][j];\n                            last[next.second][next.first] = last[i][j];\n                        }\n                    }\n                }\n            }\n        }\n//        for (int i = 745; i < 755; i++) {\n//            for (int j = 745; j < 755; j++) {\n//                cout << dp[i][j] << \"\\t\";\n//            }\n//            cout << endl;\n//        }\n//        for (int i = 745; i < 755; i++) {\n//            for (int j = 745; j < 755; j++) {\n//                cout << last[i][j] << \"\\t\";\n//            }\n//            cout << endl;\n//        }\n        pair<int, int> ans;\n        for (int i = board.minWidth; i <= board.maxWidth; i++) {\n            ans = max(make_pair(dp[board.maxDepth][i], last[board.maxDepth][i]), ans);\n        }\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> P;\n#define F first\n#define S second\nint fie[1111][1111];\nint N,M;\nint sosu[1000001];\nP mie[1000001];\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\n\nP dp[1111][1111];\nint ndx[]={1,0,-1};\nP solve(int x,int y,int ss){\n  if(dp[x][y].F!=-1) return dp[x][y];\n  if(fie[x][y]>N ||  fie[x][y] == -1 ){\n    return P(0,ss);\n  }\n  P ret = P(0,0);\n  for(int i=0;i<3;i++){\n    int nx = x+ndx[i];\n    int ny = y+1;\n    if(fie[nx][ny]>N || fie[nx][ny] == -1 ){\n      P state = solve(nx,ny,ss);\n      ret = max(ret,state);\n    } else if(!sosu[fie[nx][ny]]){\n      P state = solve(nx,ny,fie[nx][ny]);\n      state.F ++;\n      ret = max(ret,state);\n    } else {\n      P state = solve(nx,ny,ss);\n      ret = max(ret,state);\n    }\n  }\n  // printf(\"%d dp[%d][%d] =  %d, %d fie=%d\\n\",ss,x,y,ret.F,ret.S,fie[x][y]);\n  return dp[x][y] = ret;\n}\n\nint main(){\n  sosu[1]=1;\n  for(int i=2;i<=1000000;i++){\n    if(!sosu[i]){\n      for(int j=i+i;j<=1000000;j+=i){\n\tsosu[j]=1;\n      }\n    }\n  }\n  for(int i=0;i<1111;i++)\n    for(int j=0;j<1111;j++)\n      dp[i][j]=P(-1,-1);\n  memset(fie,-1,sizeof(fie));\n\n\n  int x = 1111/2,y = 1111/2;\n  int id = 1, ic = 0;\n  //printf(\"%d %d\\n\",x,y);\n  fie[x][y]=1;\n  x += dx[ic]; y += dy[ic];\n\n \n  while( id < 1000000 ){\n    id++;\n    fie[x][y]=id;\n    mie[id] = P(x,y);\n    //if(id==1000000) printf(\"%d %d %d\\n\",id,x,y);\n    //    if(!sosu[fie[x][y]]) if(id<1000) printf(\"sosu::%d %d %d\\n\",id,x,y);\n    int nc = (ic+1)%4;\n    int nx = x+dx[nc], ny = y+dy[nc];\n    if( fie[nx][ny] == -1 ){\n      x = nx; y=ny;\n      ic=nc;\n    } else {\n      x = x + dx[ic]; y = y + dy[ic];\n    }\n  }\n\n\n  /*  for(int i=550;i<560;i++){\n    for(int j=550;j<560;j++){\n      printf(\"%3d \",fie[j][i]);\n    }\n    puts(\"\");\n  }\n  */\n\n  while(1){\n    for(int i=0;i<1111;i++)\n      for(int j=0;j<1111;j++)\n\tdp[i][j]=P(-1,-1);\n    \n    cin >> N >> M;\n    if(!N && !M) break;\n    //    printf(\"%d %d\\n\",mie[N].F,mie[N].S);\n    P res = solve(mie[M].F,mie[M].S,sosu[fie[mie[M].F][mie[M].S]]==0?fie[mie[M].F][mie[M].S]:-1);\n    /*    if(sosu[fie[mie[M]][Mie[M]]]){\n      res.F ++;\n      }*/\n    if(res.S == -1){\n      printf(\"%d %d\\n\",0,0);\n    } else {\n      if( !sosu[fie[mie[M].F][mie[M].S]] ){\n\tif( res.F==0 ){\n\t  printf(\"%d %d\\n\",1,fie[mie[M].F][mie[M].S]);\n\t} else \n\t  printf(\"%d %d\\n\",res.F+1,res.S);\n      }\n      else\n\tprintf(\"%d %d\\n\",res.F,res.S);\n    }\n  }\n  \n  \n}"
  },
  {
    "language": "C++",
    "code": "/////////////////////////////////////////////////////////\n//\n//  ~/Izumi_Chiharu/c/temp.cpp file\n//  Last Updated: 2018-06-17 ...Maybe\n//\n//    I hope you adding this code to the setting file\n//    alias g++='g++ -std=c++1y -DDEBUG_LOCAL'\n//\n//  My sweet heart Chiharu Izumi\n//\n/////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid print_Qbey(){cout<<\n\"           H                                           M#5J~d              \"  <<endl<<\n\"         Hm.?WMM                                   MMB^ .Z  d              \"  <<endl<<\n\"         MZS.` ?7WMM                             M#=`` (!`` d              \"  <<endl<<\n\"         HP?X,```  ?TMM                       MMY! ` .d: `` d              \"  <<endl<<\n\"         Hb;<U,`````` (TMM                 HM ^ ``` .V>_` `.W              \"  <<endl<<\n\"           ;><?n. `` ````?WHHMMHHHMMMMMM MMY```` ` (3<< `` .M              \"  <<endl<<\n\"         HN<>>>?W,`` `` ` (77!~`  ```~!?7'``` `` .d>>><``  .M              \"  <<endl<<\n\"          M2<>>>>?n.`` `` `` `` ``` `` ```` `` `.X>1++< `` (H              \"  <<endl<<\n\"          MK<>>>>+?S.``` `` ```` ``` ``` `` `` .Z``` ?4-.` jM              \"  <<endl<<\n\"           N2><+d=(Y^ `` `` ` ` ` ` `` `` `` `` T~.`````?=(dM              \"  <<endl<<\n\"           MR;JY~`~``` `` `` ``` ``` `` `` `` ``` u, `` `` 7M              \"  <<endl<<\n\"            NV!_`` `` `` ```` ``` `` `` `` ``` ``` C& ` ```` TMM           \"  <<endl<<\n\"           MY.(-`` ` `` ``  `` ` `` `` `` `` ``  `` (n ` ` ``` 7M          \"  <<endl<<\n\"         HMD-(D`` ``` `` ``` `` `` `` `` `` ` ``` ```(n ` `` `` (WM        \"  <<endl<<\n\"         M _(d```` `` ``` ``` ``` `` `` `` ``` ``` `` .b.`` `` ```?MH      \"  <<endl<<\n\"        MM!_(%` `` `` `` ` ` `` `` `` ``` `` `` ` `` ` (l`` ``````` TMH    \"  <<endl<<\n\"       H#>__d:`` .JXVS, ``` `` ` `` `` `.JXWH&.``` ```` O; `` ` ` `` -WM   \"  <<endl<<\n\"       M%.~(k ``.HXH[ dr ```` ``` `` `` dWWN- u. `` ``` ,M,``` ``` ``` ?MMM\"  <<endl<<\n\"      MF_~~($`` .WXMMWX$ ` ``` `` ``` ` dXM HHK````` `` ,HN-``````````.-=jg\"  <<endl<<\n\"MMMMHMY.~~~(R ``` 799Y!```` ``` `` `` `` ?UUUY!`` ````` (M N, `` ```.Z3J=``\"  <<endl<<\n\"gaJJdD.~~::_X|`````````````` `````` `` ` ``` ````` ``` .H  MN,``` .Yiv! ```\"  <<endl<<\n\"   MD_:~:~:~(T.`````````` ``` ` ` ````` ``` ``` ``````.M     N, .Ziv!`` ._~\"  <<endl<<\n\" MM'_:::::::~(N+.`````````` .`.(.` .` ``` ```` ```` .dM       NZ1v! .-_~~``\"  <<endl<<\n\" #:(::::::::~(HMNa..  ``````_?!`?7! `` ````  ...-(+7WMM     HM3(b _:<``..`.\"  <<endl<<\n\"=_;::::::::<(H    MMHaJ--_--........-.__~~~~(&v7<~``` ?MM   M>gM9h,_.......\"  <<endl<<\n\";;;;;;;:;::(drWM          HHmgggg&gzOtOzz<<~~~~~_`` ``` ?MMMH+ggM Mm-......\"  <<endl<<\n\"e<>>;>>;;><dMMJM                  Nc_~~~~~~~~~~_ ``  ` `` 7H&-...?THNe-_._(\"  <<endl<<\n\",4m+>>>>>>j MM(W                   N-~~~~~~~~:_`` ``` ` ``  ?7UHHqqHWHMm+__\"  <<endl<<\n\"vX+vT4k&&dMMD!+M                   MR_~~~~~:_````` ```` ````````` ````  ?We\"  <<endl<<\n\"???zTwiJ-(((JdM                    MK_~~~~:_``` ` ` ` `` ` ` ` ``` ```````?\"  <<endl<<\n\"1uukgHM                            MH_~~~_``` `` ``` `` `` `` ` `` ` `  ```\"  <<endl<<\n\"CugM                                N;~~:_ ` `` `` ``` `` ````` ``` ``` ` `\"  <<endl<<\n\"H                                   M[~~~_4, `   ` `` `` ``  ``` `` `` ``` \"  <<endl<<\n\"                                    Hb~~~~~?n  (: `` `` `` `` ` ` `` `` ```\"  <<endl<<\n\"                                    Hb~~~~~~(4,J_ `` ```  ```` ``` `` `` ` \"  <<endl<<\n\"                                     N-~~~~~~(MM_` `` ` (}  `` `` `` `` ```\"  <<endl<<\n\"                                     Mr_~~~~~(HH: `` `` j!`` `` `` `` `` ``\"  <<endl<<\n\"                                     Mb~~~~~~(WH:`` `` .Z `` `` `` ``` `` `\"  <<endl<<\n\"                                      N:~~~~~(WM{ `` ` .H+.. `` `  .``` `` \"  <<endl;}\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n//#define int long long\n\n#define _overload3(_1,_2,_3,name,...) name\n#define _REP(i,n) REAP(i,0,n)\n#define REAP(i,a,b) for(int i=int(a);i<int(b);++i)\n#define REP(...) _overload3(__VA_ARGS__,REAP,_REP,)(__VA_ARGS__)\n\n#define _REPR(i,n) REAPR(i,n,0)\n#define REAPR(i,a,b) for(int i=int(a-1);i>=int(b);--i)\n#define REPR(...) _overload3(__VA_ARGS__,REAPR,_REPR,)(__VA_ARGS__)\n\n#define ALL(a) a.begin(),a.end()\n#define rALL(a) a.rbegin(),a.rend()\n\n#define coutALL(a) {int loop_coutALL=0;for(auto e:a) cout<<(loop_coutALL++?\" \":\"\")<<e; cout<<endl;}\n#define coutYN(a) cout<<(a?\"Yes\":\"No\")<<endl;\n#define coutyn(a) cout<<(a?\"yes\":\"no\")<<endl;\n\n#define pcnt __builtin_popcount\n#define buli(x) __builtin_popcountll(x)\n\nconst int INF=1145141919;\nconst int MOD=(int)1e9+7;\nconst double EPS=1e-12;\nconst int dx[]={0,-1,0,1},dy[]={1,0,-1,0};\n//const int dx[]={-1,-1,-1,0,1,1,1,0},dy[]={-1,0,1,1,1,0,-1,-1};\n\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\n\ntypedef pair<int,int> pii;\ntypedef pair<int,string> pis;\ntypedef pair<string,int> psi;\ntypedef pair<string,string> pss;\n\ntypedef long long ll;\n\ntemplate<class T> ll upper(T n,T m){return (n+m-1)/m;};\ntemplate<class T> ll rounding(T n){return (long double)n+0.5;};\n\ninline int qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a;a=1ll*a*a;}while(b>>=1);return ans;}\ninline int qp(int a,ll b,int mo){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}\n\nstruct Arithmetic{Arithmetic(){cin.tie(0);ios::sync_with_stdio(0);cout<<fixed<<setprecision(20);}};\n\n//#define DEBUG_LOCAL\n\n#ifdef DEBUG_LOCAL\ntemplate<typename T> void deb(T a){cerr<<\"deb: \"<<a<<\"ですねぇ！\"<<endl;}\n#define debl {cerr<<\"debug: \"<<__LINE__<<\"行目だよーんおほほ\"<<endl;}\nvoid what_cr(){cout<<__GCC_ATOMIC_CHAR16_T_LOCK_FREE<<\" ←なんだろーこの数字？\"<<endl;}\nvoid t_t(){cout\n    <<endl\n    <<\"------------------------\"<<endl\n    <<\"| Presented by         |\"<<\" Compiled \"<<__FILE__<<endl\n    <<\"| \"<<__DATE__<<\" \"<<__TIME__<<\" |\"<<endl\n    <<\"|        Chiharu Izumi |\"<<\"      to get the AC :)\"<<endl\n    <<\"------------------------\"<<endl;\n}\n#else\ntemplate<typename T>void deb(T a){}\n#define debl ;\nvoid what_cr(){}void t_t(){}\n#endif\n\npii g[1100][1100];\n\nconst int MAX_N=1e6; // 1e8=x, 1e7=? 1e6=o\nint n[MAX_N+1]={};\nvector <int> prime;\nvoid eratos_sieve(){\n  for(int i=2;i<=MAX_N;i++){\n    if(!n[i]){\n      prime.push_back(i);\n      n[i]=2;\n      for(int j=i*2;j<=MAX_N;j+=i) n[j]=1;\n    }\n  }\n}\n\nvoid make_g(){\n\n  int y=550,x=550;\n  g[y][x].fi=1;\n\n  int num=2,howgo=2;\n\n  for(;num<1e6+1;){\n\n    x++;\n\n    g[y][x].fi=num;\n    if(n[g[y][x].fi]==2) g[y][x].se=1;\n    num++;\n\n    REP(i,4){\n\n      int nowgo=howgo;\n      if(i==0) nowgo--;\n\n      REP(j,nowgo){\n\n\ty+=dy[i];\n\tx+=dx[i];\n\n\tg[y][x].fi=num;\n\tif(n[g[y][x].fi]==2) g[y][x].se=1;\n\tnum++;\n\n      }\n\n    }\n\n    howgo+=2;\n\n  }\n\n}\n\nint findfi(int m){\n\n  REP(i,1100) REP(j,1100) if(g[i][j].fi==m) return i*10000+j;\n\n}\n\nvoid print(){\n\n REP(i,540,560){\n\n   REP(j,540,560){\n     cout<<\" \"<<g[i][j].se ;\n     if(i==550 && j==550) cout<<'x';\n   }\n    cout<<endl;\n\n  }\n}\n\nvoid print_dp(int dp[1100][1100]){\n\n REP(i,540,560){\n\n   REP(j,540,560){\n     cout<<\" \"<<dp[i][j];\n     if(i==550 && j==550) cout<<'x';\n   }\n    cout<<endl;\n\n  }\n}\n\nsigned main(){\n\n  Arithmetic Exception;\n\n  eratos_sieve();\n  make_g();\n\n  for(;;){\n\n    int n0,m0;\n    cin>>n0>>m0;\n\n    if(!n0) break;\n\n    int dp[1100][1100]={};\n\n    int be=findfi(m0);\n    int bex=be%10000,bey=be/10000;\n\n\n    dp[bey][bex]=1;\n\n    for(int i=bey;i>10;i--){\n\n      REP(j,10,1090){\n\n\tif(dp[i][j]){\n\n\t  REP(k,-1,2){\n\n\t    int y=i-1;\n\t    int x=j+k;\n\n\t    if(dp[y][x] || g[y][x].fi<=n0){\n\n\t      dp[y][x]=max(dp[i][j]+g[y][x].se,dp[y][x]);\n\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    //print_dp(dp);\n\n    int ans_max=0;\n\n    REP(i,1100) REP(j,1100) ans_max=max(ans_max,dp[i][j]);\n\n    if(ans_max==1){\n\n      if(g[bey][bex].se) goto res;\n\n      cout<<\"0 0\"<<endl;\n      continue;\n\n    }\n\n  res:\n\n    int ans_pri=0;\n\n    REP(i,1100) REP(j,1100){\n\n      if(ans_max==dp[i][j] && n[g[i][j].fi]==2) ans_pri=max(ans_pri,g[i][j].fi);\n\n    }\n\n    cout<<ans_max-(g[bey][bex].se?0:1)<<\" \"<<ans_pri<<endl;\n\n  }\n\n  return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = (a); i <= (n); i++)\n#define M 1000001\nusing namespace std;\ntypedef pair<int, int> pii;\n\nbool p[M];\nint m, n, table[1000][1000], nx[M], ny[M], dp1[M], dp2[M];\n\nint isin(int y, int x) {\n  return 0 <= x && x < 1000 && 0 <= y && y < 1000;\n}\n\npii dfs(int m, int n) {\n  if(dp1[n] >= 0) return pii(dp1[n], dp2[n]);\n\n  pii ret = pii(0, p[n] ? n : 0);\n  REP(i, -1, 1) {\n    int qy = ny[n] + 1, qx = nx[n] + i;\n    if(!isin(qy, qx)) continue;\n    int q = table[qy][qx];\n    if(q <= m) {\n      pii t = dfs(m, q);\n      ret = max(ret, t);\n    }\n  }\n\n  dp1[n] = ret.first + p[n];\n  dp2[n] = ret.second;\n  return pii(dp1[n], dp2[n]);\n}\n\nint main(void) {\n  REP(i, 1, 1000000) p[i] = true;\n  p[1] = p[2] = false;\n  REP(i, 2, 1000000) if(p[i]) for(int j = i * 2; j <= 1000000; j += i) p[j] = false;\n\n  int x = 0, y = 0, cnt = 1000 - 2, r = 1000000;\n  REP(i, 0, 999) REP(j, 0, 999) table[i][j] = 0;\n  while(cnt >= 0) {\n    REP(j, 0, cnt) { table[y][x] = r; ny[r] = y; nx[r] = x; x++; r--; }\n    REP(j, 0, cnt) { table[y][x] = r; ny[r] = y; nx[r] = x; y++; r--; }\n    REP(j, 0, cnt) { table[y][x] = r; ny[r] = y; nx[r] = x; x--; r--; }\n    REP(j, 0, cnt) { table[y][x] = r; ny[r] = y; nx[r] = x; y--; r--; }\n    if(r < 0) cout << y << \" \" << x << endl;\n    x++;\n    y++;\n    cnt -= 2;\n  }\n\n  while(cin >> m >> n, m != 0 && n != 0) {\n    REP(i, 1, m) dp1[i] = dp2[i] = -1;\n    pii ans = dfs(m, n);\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE * SIZE + 1];\n\tint table[SIZE][SIZE];\n\tint dp[SIZE][SIZE];\n\tint pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tint res1, res2;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d %d\", &m, &n);\n\t\tif (m == 0 || n == 0)return 0;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = SIZE - 1;i >= 0;i--){\n\t\t\tfor(int j = SIZE - 1;j >= 0;j--){\n\t\t\t\tif (table[i][j] <= m) {\n\t\t\t\t\tif (i + 1 < SIZE) {\n\t\t\t\t\t\tif (j > 0 && table[i + 1][j - 1] <= m){\n\t\t\t\t\t\t\tif (dp[i][j] < dp[i + 1][j - 1] || (dp[i][j] == dp[i + 1][j - 1] && pr[i][j] < pr[i + 1][j - 1])) {\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j - 1];\n\t\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j - 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (table[i + 1][j] <= m){\n\t\t\t\t\t\t\tif (dp[i][j] < dp[i + 1][j] || (dp[i][j] == dp[i + 1][j] && pr[i][j] < pr[i + 1][j])) {\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j];\n\t\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j + 1 < SIZE && table[i + 1][j + 1] <= m){\n\t\t\t\t\t\t\tif (dp[i][j] < dp[i + 1][j + 1] || (dp[i][j] == dp[i + 1][j + 1] && pr[i][j] < pr[i + 1][j + 1])) {\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j + 1];\n\t\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j + 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!prime[table[i][j]]) {\n\t\t\t\t\t\tdp[i][j]++;\n\t\t\t\t\t\tif (pr[i][j] == 0) {\n\t\t\t\t\t\t\tpr[i][j] = table[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tprintf(\"%d %d\\n\", dp[i][j], pr[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <functional>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> PII;\n\nconst int MAX_WH = 1100;\nconst int MAX_P = 1000000;\n\n#define mp(x, y) make_pair(x, y)\n\nbool isP[MAX_P+10];\n\nvoid createPrime ( int num )\n{\n\tfill(isP, isP+MAX_P+10, true);\n\tisP[0] = isP[1] = false;\n\tfor (int i = 2; i <= num; ++i) {\n\t\tif (!isP[i]) { continue; }\n\t\tfor (int j = i+i; j <= num; j+=i) { isP[j] = false; }\n\t}\n}\n\n#define X first\n#define Y second\n\nint mnX, mnY, mxX, mxY;\nint fd[MAX_WH][MAX_WH];\nPII mat[MAX_P+10];\n\nvoid createField ( void )\n{\n\tint n = 1, power = 1;\n\tint x = MAX_WH/2, y = MAX_WH/2;\n\tbool turn = true;\n\n\tfor (int i = 0; i < MAX_WH; ++i) {\n\t\tfill(fd[i], fd[i]+MAX_WH, -1);\n\t}\n\tmnX = mnY = MAX_WH;\n\tmxX = mxY = -1;\n\tfd[y][x] = 1;\n\tmat[1].X = x; mat[1].Y = y;\n\twhile (n < 1000002) {\n\t\tif (turn) {\n\t\t\tfor (int i = 0; i < power; ++i) {\n\t\t\t\t++x;\n\t\t\t\tfd[y][x] = ++n;\n\t\t\t\tmat[n].X = x; mat[n].Y = y;\n\t\t\t}\n\t\t\tfor (int i = 0; i < power; ++i) {\n\t\t\t\t--y;\n\t\t\t\tfd[y][x] = ++n;\n\t\t\t\tmat[n].X = x; mat[n].Y = y;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (int i = 0; i < power; ++i) {\n\t\t\t\t--x;\n\t\t\t\tfd[y][x] = ++n;\n\t\t\t\tmat[n].X = x; mat[n].Y = y;\n\t\t\t}\n\t\t\tfor (int i = 0; i < power; ++i) {\n\t\t\t\t++y;\n\t\t\t\tfd[y][x] = ++n;\n\t\t\t\tmat[n].X = x; mat[n].Y = y;\n\t\t\t}\n\t\t}\n\t\t++power;\n\t\tturn = !turn;\n\t\tmnX = min(mnX, x); mnY = min(mnY, y);\n\t\tmxX = max(mxX, x); mxY = max(mxY, y);\n\t}\n\t//cout << mnX << ' ' << mnY << endl;\n\t//cout << mxX << ' ' << mxY << endl;\n}\n\nint dx[] = { -1, 0, 1 };\nint asn[MAX_WH][MAX_WH];\nint asp[MAX_WH][MAX_WH];\nbool visited[MAX_WH][MAX_WH];\n\nvoid solve ( int m, int n )\n{\n\tfor (int i = 0; i < MAX_WH; ++i) {\n\t\tfill(asn[i], asn[i]+MAX_WH, 0);\n\t\tfill(asp[i], asp[i]+MAX_WH, 0);\n\t\tfill(visited[i], visited[i]+MAX_WH, false);\n\t}\n\tint ans_num = 0, ans_prime = 0;\n\tPII v = mat[n], g = mat[m];\n\tif (isP[fd[v.Y][v.X]]) {\n\t\tasn[v.Y][v.X] = ans_num = 1;\n\t\tasp[v.Y][v.X] = ans_prime = fd[v.Y][v.X];\n\t}\n\tvisited[v.Y][v.X] = true;\n\tfor (int y = v.Y+1; y <= mxY; ++y) {\n\t\tfor (int x = mnX; x <= mxX; ++x) {\n\t\t\tif (-1 < fd[y][x] && fd[y][x] <= m) {\n\t\t\t\tfor (int d = 0; d < 3; ++d) {\n\t\t\t\t\tint mx = x + dx[d];\n\t\t\t\t\tint my = y - 1;\n\t\t\t\t\tif (!visited[my][mx]) { continue; }\n\t\t\t\t\tvisited[y][x] = true;\n\t\t\t\t\tif (isP[fd[y][x]]) {\n\t\t\t\t\t\tif (asn[y][x] < asn[my][mx] + 1) {\n\t\t\t\t\t\t\tasn[y][x] = asn[my][mx] + 1;\n\t\t\t\t\t\t\tasp[y][x] = fd[y][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (asn[y][x] == asn[my][mx] + 1) {\n\t\t\t\t\t\t\tasp[y][x] = fd[y][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (asn[y][x] < asn[my][mx]) {\n\t\t\t\t\t\t\tasn[y][x] = asn[my][mx];\n\t\t\t\t\t\t\tasp[y][x] = asp[my][mx];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (asn[y][x] == asn[my][mx]) {\n\t\t\t\t\t\t\tasp[y][x] = max(asp[y][x], asp[my][mx]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (visited[y][x]) {\n\t\t\t\t\tif (ans_num < asn[y][x]) {\n\t\t\t\t\t\tans_num = asn[y][x];\n\t\t\t\t\t\tans_prime = asp[y][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (ans_num == asn[y][x]) {\n\t\t\t\t\t\tans_prime = max(ans_prime, asp[y][x]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans_num << ' ' << ans_prime << endl;\n}\n\nint main ( void )\n{\n\tcreatePrime(MAX_P + 2);\n\tcreateField();\n\n\tint m, n;\n\twhile (cin >> m >> n, m|n) {\n\t\tsolve(m, n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// http://intsawadan.hatenablog.com/entry/2019/06/08/131920\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nint m[1600][1600];\nint dp[1600][1600][2];\nbool prime[1000010];\n\nint main() {\n    int a = 800, b = 800;\n    int dir;  // 今向いている方向\n    m[a][b] = 1;\n    b += 1;\n    m[a][b] = 2;\n    a -= 1;\n    dir = 1;\n    for (int i = 3; i <= 1000000; ++i) {\n        m[a][b] = i;\n        if (dir == 0) {  // →\n            if (m[a - 1][b] != 0) {\n                b += 1;\n            } else {\n                a -= 1;\n                dir = 1;\n            }\n        } else if (dir == 1) {  // ↑\n            if (m[a][b - 1] != 0) {\n                a -= 1;\n            } else {\n                b -= 1;\n                dir = 2;\n            }\n        } else if (dir == 2) {  // ←\n            if (m[a + 1][b] != 0) {\n                b -= 1;\n            } else {\n                a += 1;\n                dir = 3;\n            }\n        } else {  // ↓\n            if (m[a][b + 1] != 0) {\n                a += 1;\n            } else {\n                b += 1;\n                dir = 0;\n            }\n        }\n    }\n\n    for (int i = 0; i <= 1000000; ++i) {\n        prime[i] = true;\n    }\n    prime[0] = prime[1] = false;\n    for (int i = 2; i <= 1000000; ++i) {\n        if (prime[i]) {\n            for (int j = 2; i * j <= 1000000; ++j) {\n                prime[i * j] = false;\n            }\n        }\n    }\n\n    int mm, n;\n    while (true) {\n        cin >> mm >> n;\n        if (mm == 0 && n == 0) break;\n        for (int i = 0; i < 1600; ++i) {\n            for (int j = 0; j < 1600; ++j) {\n                dp[i][j][0] = dp[i][j][1] = 0;\n                if (m[i][j] == n) {\n                    a = i;\n                    b = j;\n                }\n            }\n        }\n\n        int aans = 0, bans = 0;\n        if (prime[n]) {\n            dp[a][b][0] = 1;\n            dp[a][b][1] = n;\n            aans = 1;\n            bans = n;\n        }\n        for (int i = a + 1; i < 1500; ++i) {\n            for (int j = b - (i - a); j <= b + (i - a); ++j) {\n                if (m[i][j] == 0 || m[i][j] > mm) continue;\n                int amax = 0, bmax = 0;\n                for (int k = -1; k <= 1; ++k) {\n                    if (amax < dp[i - 1][j + k][0]) {\n                        amax = dp[i - 1][j + k][0];\n                        bmax = dp[i - 1][j + k][1];\n                    } else if (amax == dp[i - 1][j + k][0] && bmax < dp[i - 1][j + k][1]) {\n                        bmax = dp[i - 1][j + k][1];\n                    }\n                }\n\n                if (prime[m[i][j]]) {\n                    amax++;\n                    bmax = m[i][j];\n                }\n                dp[i][j][0] = amax;\n                dp[i][j][1] = bmax;\n                if (aans < amax) {\n                    aans = amax;\n                    bans = bmax;\n                } else if (aans == amax && bans < bmax) {\n                    bans = bmax;\n                }\n            }\n        }\n        cout << aans << \" \" << bans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nconst int dy[] = {0, -1, 0, 1};\nconst int dx[] = {1, 0, -1, 0};\nint m, n;\nint num[2000][2000];\nint dp[2000][2000];\nint flag[2000][2000];\npii pos[1000010];\nint is_prime[1000010];\n\nvoid sieve(int n) {\n  fill_n((int*)is_prime, n, 1);\n  is_prime[0] = is_prime[1] = 0;\n  for (int i = 2; i < n; i++) {\n    if (!is_prime[i]) continue;\n    for (int j = 2 * i; j < n; j += i) {\n      is_prime[j] = 0;\n    }\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  sieve(1000010);\n  int y = 1000, x = 1000, id = 1, w = 1, dir = 0;\n  while (id <= 1000000) {\n    for (int i = 0; i < 2; i++) {\n      for (int j = 0; j < w && id <= 1000000; j++) {\n        num[y][x] = id;\n        pos[id++] = pii(y, x);\n        y += dy[dir]; x += dx[dir];\n      }\n      dir = (dir + 1) % 4;\n    }\n    w++;\n  }\n\n  // for (int i = 995; i <= 1005; i++) {\n  //   for (int j = 995; j <= 1005; j++) {\n  //     cerr << setw(4) << num[i][j] << \" \\n\"[j == 1005];\n  //   }\n  // }\n\n  while (cin >> m >> n, m) {\n    fill_n((int*)dp, 2000 * 2000, 0);\n    fill_n((int*)flag, 2000 * 2000, 0);\n    int y, x;\n    tie(y, x) = pos[n];\n    dp[y][x] = is_prime[n];\n    flag[y][x] = 1;\n    for (int i = 1; i < 2000; i++) {\n      for (int j = 0; j < 2000; j++) {\n        if (num[i][j] == 0 || num[i][j] > m) continue;\n        // cout << i << \" \" << j << \" \" << num[i][j] << endl;\n        if (j > 0 && flag[i - 1][j - 1] && num[i - 1][j - 1] <= m) {\n          dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + is_prime[num[i][j]]);\n          flag[i][j] = 1;\n        }\n        if (flag[i - 1][j] && num[i - 1][j] <= m) {\n          dp[i][j] = max(dp[i][j], dp[i - 1][j] + is_prime[num[i][j]]);\n          flag[i][j] = 1;\n        }\n        if (j + 1 < 2000 && flag[i - 1][j + 1] && num[i - 1][j + 1] <= m) {\n          dp[i][j] = max(dp[i][j], dp[i - 1][j + 1] + is_prime[num[i][j]]);\n          flag[i][j] = 1;\n        }\n      }\n    }\n    int p = 0, q = 0;\n    for (int i = 1; i <= m; i++) {\n      int y, x;\n      tie(y, x) = pos[i];\n      if (dp[y][x] >= p) {\n        if (dp[y][x] == p) {\n          if (is_prime[i]) {\n            q = max(q, i);\n          }\n        } else {\n          q = i;\n        }\n        p = dp[y][x];\n      }\n    }\n    cout << p << \" \" << (p == 0 ? 0 : q) << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main(){\n  vector<vector<int> > cave(2000,vector<int>(2000,1e6+1));\n  vector<int> xp(1e6+1);\n  vector<int> yp(1e6+1);\n  int l=1;\n  int x=1000;\n  int y=1000;\n  xp[1]=x;\n  yp[1]=y;\n  cave[x][y]=1;\n\n  for(int i=2;i<1e6+1;i++){\n    for(int j=0;j<l;j++){\n      x++;\n      cave[x][y]=i;\n      xp[i]=x;\n      yp[i]=y;\n      i++;\n      if(i>1e6+1)break;\n    }\n    if(i>1e6+1)break;\n    for(int j=0;j<l;j++){\n      y--;\n      cave[x][y]=i;\n      xp[i]=x;\n      yp[i]=y;\n      i++;\n      if(i>1e6+1)break;\n    }\n    if(i>1e6+1)break;\n    l++;\n    for(int j=0;j<l;j++){\n      x--;\n      cave[x][y]=i;\n      xp[i]=x;\n      yp[i]=y;\n      i++;\n      if(i>1e6+1)break;\n    }\n    if(i>1e6+1)break;\n    for(int j=0;j<l;j++){\n      y++;\n      cave[x][y]=i;\n      xp[i]=x;\n      yp[i]=y;\n      if(j!=l-1)i++;\n      if(i>1e6+1)break;\n    }\n    if(i>1e6+1)break;\n    l++;\n  }\n\n  /*\n  for(int i=1490;i<1510;i++){\n    for(int j=1490;j<1510;j++){\n      cout<<cave[j][i]<<\" \";\n    }\n    cout<<endl;\n  }\n  */\n\n  vector<int> prime(1e6+2,1);\n  prime[1e6+1]=0;\n  prime[1]=0;\n  for(int i=2;i<prime.size();i++){\n    if(prime[i]){\n      for(int j=i+i;j<prime.size();j+=i)prime[j]=0;\n    }\n  }\n\n  //for(int i=0;i<1e6;i++)if(prime[i])cout<<i<<\" \";\n\n\n  while(1){\n    int m,n;\n    cin>>m>>n;\n    if(m==0&&n==0)break;\n    vector<vector<int> > bfs(2000,vector<int>(2000,0));\n    vector<int> used(1e6+1,1);\n    queue<int> q;\n    q.push(n);\n    while(!q.empty()){\n      int np=q.front();\n      //cout<<np<<endl;\n      q.pop();\n      if(used[cave[xp[np]-1][yp[np]+1]]&&cave[xp[np]-1][yp[np]+1]<=m){\n        q.push(cave[xp[np]-1][yp[np]+1]);\n        used[cave[xp[np]-1][yp[np]+1]]=0;\n      }\n      if(used[cave[xp[np]][yp[np]+1]]&&cave[xp[np]][yp[np]+1]<=m){\n        q.push(cave[xp[np]][yp[np]+1]);\n        used[cave[xp[np]][yp[np]+1]]=0;\n      }\n      if(used[cave[xp[np]+1][yp[np]+1]]&&cave[xp[np]+1][yp[np]+1]<=m){\n        q.push(cave[xp[np]+1][yp[np]+1]);\n        used[cave[xp[np]+1][yp[np]+1]]=0;\n      }\n      bfs[xp[np]][yp[np]]=max(bfs[xp[np]-1][yp[np]-1],max(bfs[xp[np]][yp[np]-1],bfs[xp[np]+1][yp[np]-1]))+prime[np];\n      //if(prime[np])bfs[xp[np]][yp[np]]++;\n    }\n\n    /*\n    for(int i=995;i<1005;i++){\n      for(int j=995;j<1005;j++){\n        cout<<bfs[j][i]<<\" \";\n      }\n      cout<<endl;\n    }\n    */\n\n    int ans=0;\n    int id=0;\n    for(int i=0;i<=m;i++){\n      //cout<<i<<\" \"<<bfs[xp[i]][yp[i]]<<endl;\n      if(ans<bfs[xp[i]][yp[i]]&&prime[i]){\n        ans=bfs[xp[i]][yp[i]];\n        id=cave[xp[i]][yp[i]];\n      }\n      if(ans!=0&&ans==bfs[xp[i]][yp[i]]&&prime[i]){\n        ans=bfs[xp[i]][yp[i]];\n        id=max(id,cave[xp[i]][yp[i]]);\n      }\n    }\n    cout<<ans<<\" \"<<id<<endl;\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define SIZE 1000\n\nbool C(int dp1, int pr1, int dp2, int pr2) {\n\tif (dp2 == 0)return false;\n\tif (dp1 < dp2 || (dp1 == dp2&&pr1 < pr2))return true;\n\treturn false;\n}\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool complete;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1;i <= SIZE&&a <= SIZE*SIZE;i++) {\n\t\tfor (int j = 0;j < i&&a <= SIZE*SIZE;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\tif (i % 2 == 0)x--;\n\t\t\telse x++;\n\t\t\ta++;\n\t\t}\n\t\tfor (int j = 0;j < i&&a <= SIZE*SIZE;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t\ta++;\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\tcomplete = false;\n\t\twhile (!complete) {\n\t\t\twhile (x >= 0 && !complete) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x - 1], pr[y + 1][x - 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x], pr[y + 1][x])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x + 1], pr[y + 1][x + 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (table[y][x] == n)complete = true;\n\t\t\t\telse x--;\n\t\t\t}\n\t\t\tif (!complete) {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#define X first\n#define Y second\n#define MAX 1003\nusing namespace std;\n\nstruct state{\n\tstate():num(0), max(-1), mindex(0){}\n\tint num;\n\tint max;\n\tint mindex;\n};\n\nstate dp[MAX][MAX];\nbool sosuu[1000001];\nmap<int, pair<int, int> > pos;\nint dx[] = {0, -1, 0, 1};\nint dy[] = {-1, 0, 1, 0};\nint ddx[] = {-1, 0, 1};\n\n//素数判定用\nvoid era(){\n\tfill(sosuu, sosuu+1000001, true);\n\tfor(int i = 2; i <= 1000000; i++){\n\t\tif(sosuu[i]){\n\t\t\tfor(int j = 2*i; j <= 1000000; j+=i) sosuu[j] = false;\n\t\t}\n\t}\n}\n\n//螺旋状に数字を配置する\nvoid fillNum(){\n\tint rect = 3, count = 1;\n\tint x = MAX/2, y = MAX/2;\n\tpos[count] = pair<int, int>(x, y);\n\tdp[y][x].num = count++;\n\twhile(count <= MAX*MAX-1){\n\t\tpos[count] = pair<int, int>(++x, y);\n\t\tdp[y][x].num = count++;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tfor(int j = (i==0)?1:0; j < rect-1; j++){\n\t\t\t\tx += dx[i];\n\t\t\t\ty += dy[i];\n\t\t\t\tpos[count] = pair<int, int>(x, y);\n\t\t\t\tdp[y][x].num = count++;\n\t\t\t}\n\t\t}\n\t\trect+=2;\n\t}\n}\n\n//洞穴数は毎回変わるので、入力時にその範囲だけ初期化\nvoid Init(int n){\n\tfor(int i = 0; i < MAX; i++){\n\t\tfor(int j = 0; j < MAX; j++){\n\t\t\tif(n>=dp[i][j].num){\n\t\t\t\tdp[i][j].max = -1;\n\t\t\t\tdp[i][j].mindex = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n  \n//メモ化再帰\n//スタートからした三方向に足して再帰回して\n//戻ってきたらそこまでの素数洞穴の和を各洞穴に記録していく\nint dfs(int x, int y, int n){\n\tif(dp[y][x].max>=0) return dp[y][x].max;\n\tint add = 0;\n\tfor(int i = 0; i < 3; i++){\n\t\tif(dp[y+1][x+ddx[i]].num>n) continue;//範囲外の洞穴にアクセスしようとしたら止める\n\t\t//三方向に対して再帰を行って、もっとも素数洞穴数が多い場所を採用\n\t\t//その際、同じ数が複数あった場合はその中で一番大きい素数洞穴を踏んだ経路を採用\n\t\tint tmp = dfs(x+ddx[i], y+1, n);\n\t\tif(add<tmp){\n\t\t\tadd = tmp;\n\t\t\tdp[y][x].mindex = dp[y+1][x+ddx[i]].mindex;\n\t\t}\n\t\telse if(add == tmp){ \n\t\t\tdp[y][x].mindex = dp[y][x].mindex<dp[y+1][x+ddx[i]].mindex?dp[y+1][x+ddx[i]].mindex:dp[y][x].mindex;\n\t\t}\n\t}\n\t//自分が素数だった場合1加算する\n\tdp[y][x].max = sosuu[dp[y][x].num]?add + 1:add;\n\t//自分が初めての素数洞穴だった場合\n\tif(!dp[y][x].mindex&&sosuu[dp[y][x].num]) dp[y][x].mindex = dp[y][x].num;\n\treturn dp[y][x].max;\n}\n\nint main(){\n\tera();\n\tfillNum();\n\tint n, m;\n\twhile(cin >> n >> m && (n!=0||m!=0)){\n\t\tInit(n);\n\t\tint x = pos[m].X, y = pos[m].Y;\n\t\tdfs(x, y, n);\n\t\tif(dp[y][x].max==0) cout << 0 << \" \" << 0 << endl;\n\t\telse cout << dp[y][x].max << \" \" << dp[y][x].mindex << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nbool is_prime[1000001];\nmap<P,int> stage;\n\nint main(){\n  int x = 0;\n  int y = 0;\n  int dir = 1;\n  for(int round = 1; round <= 1000000;round++){\n    stage[P(y,x)] = round;\n\n    int prev_dir = dir;\n    if(round > 1) dir = (dir + 3) % 4;\n    int dx = x + tx[dir];\n    int dy = y + ty[dir];\n    if(stage.find(P(dy,dx)) != stage.end()){\n      dir = prev_dir;\n    }\n    dx = x + tx[dir];\n    dy = y + ty[dir];\n    x = dx;\n    y = dy;\n  }\n  \n  memset(is_prime,true,sizeof(is_prime));\n\n  is_prime[0] = false;\n  is_prime[1] = false;\n\n  for(int i=2;i*i<=1000000;i++){\n    if(is_prime[i]){\n      for(int j=i+i;j<=1000000;j+=i){\n\tis_prime[j] = false;\n      }\n    }\n  }\n\n  int start,total_caves;\n  while(~scanf(\"%d %d\",&total_caves,&start)){\n    if(total_caves == 0 && start == 0) break;\n\n    int sx=0,sy=0;\n    for(map<P,int>::iterator it = stage.begin();\n\tit != stage.end();\n\tit++){\n      int x = it->first.second;\n      int y = it->first.first;\n      int num = it->second;\n      if(num == start){\n\tsx = x;\n\tsy = y;\n\tbreak;\n      }\n    }\n\n\n    map <P,int> dp;\n\n    dp[P(sy,sx)] = (int)is_prime[stage[P(sy,sx)]];\n    for(int y=sy+1,width=3;y<=1000;y++,width+=3){\n      bool is_update = false;\n      for(int x=sx - width;x<=sx + width;x++){\n\tif(stage[P(y,x)] > total_caves) continue;\n\tis_update = true;\n\n\tint cost = (int)is_prime[stage[P(y,x)]];\n\tif(dp.find(P(y-1,x-1)) != dp.end()){\n\t  dp[P(y,x)] = max(dp[P(y-1,x-1)] + cost,dp[P(y,x)]);\n\t}\n\tif(dp.find(P(y-1,x)) != dp.end()){\n\t  dp[P(y,x)] = max(dp[P(y-1,x)] + cost,dp[P(y,x)]);\n\t}\n\tif(dp.find(P(y-1,x+1)) != dp.end()){\n\t  dp[P(y,x)] = max(dp[P(y-1,x+1)] + cost,dp[P(y,x)]);\n\t}\n      }\n      if(!is_update) break;\n    }\n\n    int res_prime=0;\n    int res_count=0;\n    for(map<P,int>::iterator it = dp.begin();\n\tit != dp.end();\n\tit++){\n      if(!is_prime[stage[it->first]]) continue;\n\n      if(res_count < it->second){\n\tres_count = it->second;\n\tres_prime = stage[it->first];\n      }\n      if(res_count == it->second\n\t && res_prime < stage[it->first]){\n\tres_prime = stage[it->first];\n      }\n    }\n    printf(\"%d %d\\n\",res_count,res_prime);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\n    //エラトステネスの篩\n    vector<bool> prime(1000010, true);     //1000000までで、素数ならtrue\n    prime[0] = prime[1] = false;\n    for(int i = 2; i < 1000010; i++){\n        if(prime[i] == true){\n            for(int j = 2*i; j < 1000010; j += i){\n                prime[j] = false;\n            }\n        }\n    }\n\n    map<pair<int, int>, int> M;\n    map<int, pair<int, int> > _M;\n    int num = 1;\n    int T = 1;\n    M[{0, 0}] = num;\n    _M[num] = {0, 0};\n    num++;\n    int i = 0;\n    int j = 0;\n\n    while(num < 1000010){\n\n        j++;\n        M[{i, j}] = num;\n        _M[num] = {i, j};\n        num++;\n        for(int r = 0; r < T; r++){\n            i--;\n            M[{i, j}] = num;\n            _M[num] = {i, j};        \n            num++;\n        }\n\n        j--;\n        M[{i, j}] = num;\n        _M[num] = {i, j};\n        \n        num++;\n        for(int r = 0; r < T; r++){\n            j--;\n            M[{i, j}] = num;\n            _M[num] = {i, j};        \n            num++;\n        }\n\n        i++;\n        M[{i, j}] = num;\n        _M[num] = {i, j};\n        \n        num++;\n        for(int r = 0; r < T; r++){\n            i++;\n            M[{i, j}] = num;\n            _M[num] = {i, j};\n            \n            num++;\n        }\n\n        j++;\n        M[{i, j}] = num;\n        _M[num] = {i, j};\n        \n        num++;\n        for(int r = 0; r < T; r++){\n            j++;\n            M[{i, j}] = num;\n            _M[num] = {i, j};\n            \n            num++;\n        }\n\n        T += 2;\n    }\n\n    /*for(int i = -10; i <= 10; i++){\n        for(int j = -10; j <= 10; j++){\n            printf(\"%.2d \", M[{i, j}]);\n        }\n        cout << endl;\n    }*/\n    \n\n    while(1){\n        int m, n; cin >> m >> n;\n        if(n == 0) break;    \n\n        //幅優先\n        map<pair<int, int>, int> dp;\n        queue<pair<int, int> > que;\n        int si = _M[n].first;\n        int sj = _M[n].second;\n        que.push({si, sj});\n        dp[{si, sj}] = prime[n] ? 1 : 0;\n    \n        int ans1 = 0;\n        int ans2 = 0;\n\n        while(!que.empty()){\n\n            int i = que.front().first;\n            int j = que.front().second;\n\n            if(dp[{i, j}] >= ans1 && prime[M[{i, j}]]){\n                ans1 = dp[{i, j}];\n                ans2 = M[{i, j}];\n            }\n\n            que.pop();\n\n            int ni = i + 1;\n            //3つ\n\n            for(int dj = -1; dj <= 1; dj++){\n                int nj = j + dj;\n                int next_num = M[{ni, nj}];\n                if(next_num > m || next_num == 0) continue;\n\n                int v = dp[{i, j}] + ((prime[next_num]) ? 1 : 0);\n                if(v > dp[{ni, nj}]){\n                    dp[{ni, nj}] = v;\n                    que.push({ni, nj});\n                }\n            }\n            \n        }\n\n    cout << ans1 << \" \" << ans2 << endl;\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<map>\n#include<cmath>\nusing namespace std;\n#define INF ( 1 << 30 )\n#define fr first\n#define sc second\nconst int dy[] = { 0, -1, 0, 1}, dx[] = { 1, 0, -1, 0}; //右上左下\ntypedef pair< int , int > Pt;\nint m,n,mas[1005][1005],hw = 1000;\nPt buff[1000001],max_cost[1005][1005];\nbool prime[1000001];\nvoid Prime_set(){\n  prime[1] = true;\n  for(int i = 2 ; i * i < 1000001 ; i++ ){\n    if(!prime[i]) for(int j = i + i ; j < 1000001 ; j += i ) prime[j] = true;\n  }\n}\nbool isover(int y,int x){\n  return y < 0 || y > 1001 || x < 0 || x > 1001 || !mas[y][x] || mas[y][x] > m;\n}\nvoid make_map(){\n  fill_n(*mas,1005*1005,0);\n  int cnt = 1,muki = 3;\n  Pt now = Pt( hw / 2,  hw / 2),St;\n  while(cnt <= 1000000){\n    buff[cnt] = Pt(now.fr,now.sc);\n    mas[now.fr][now.sc] = cnt++;\n    Pt magaru = Pt( now.fr + dy[(muki + 1) % 4], now.sc + dx[(muki + 1) % 4]);\n    if(!mas[magaru.fr][magaru.sc]) muki = (muki + 1) % 4, now = magaru;\n    else now.fr += dy[muki], now.sc += dx[muki];\n  }\n}\nPt dfs(Pt now){\n  if(max_cost[now.fr][now.sc] != Pt(-1,-1)) return max_cost[now.fr][now.sc];\n  Pt ret = Pt(0,0);\n  for(int i = 0 ; i < 3 ; i++ ){\n    int nx = now.sc + dx[i];\n    if(isover(now.fr+1,nx)) continue;\n    ret = max(ret,dfs(Pt(now.fr+1,nx)));\n  }\n  if(!ret.sc && !prime[mas[now.fr][now.sc]]) ret.sc = mas[now.fr][now.sc];\n  return max_cost[now.fr][now.sc] = Pt(ret.fr+!prime[mas[now.fr][now.sc]],ret.sc);\n}\nint main(){\n  Prime_set();\n  make_map();\n  while(cin >> m >> n , m){\n    fill_n(*max_cost,1005*1005,Pt(-1,-1));\n    Pt ans = dfs(buff[n]);\n    cout << ans.fr << \" \" << ans.sc << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iomanip>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define pii pair<int,int>\n\n#define MAXM 1000001\n#define MAXSQM 1002\nint diff[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nint map[MAXSQM][MAXSQM] = {};\nbool furui[MAXM] = {};\npii dpmap[MAXSQM][2] = {};\n\nvoid init_map(int m){\n    fill_n(*map,MAXSQM*MAXSQM,0);\n    fill_n(*dpmap,MAXSQM*2,pii(-1,-1));\n    int idx=MAXSQM/2,idy=MAXSQM/2;\n    int dir=0;\n    int c=1;\n    for(int i=1;c<=m;i++){\n        for(int j=0;j<i&&c<=m;j++){\n            map[idx][idy]=c++;\n            idx+=diff[dir][0];\n            idy+=diff[dir][1];\n        }\n        dir=(dir+1)%4;\n        for(int j=0;j<i&&c<=m;j++){\n            map[idx][idy]=c++;\n            idx+=diff[dir][0];\n            idy+=diff[dir][1];\n        }\n        dir=(dir+1)%4;\n    }\n}\n\npii dp(int n){\n    int nx,ny;\n    for(nx=0;nx<MAXSQM;nx++){\n        for(ny=0;ny<MAXSQM;ny++){\n            if(n==map[nx][ny]) break;\n        }\n        if(n==map[nx][ny]) break;\n    }\n\n    pii ans=pii(0,0);\n\n    if(!furui[map[nx][ny]]){\n        dpmap[nx][ny%2]=pii(1,map[nx][ny]);\n        ans=dpmap[nx][ny%2];\n    }\n    else\n    {\n        dpmap[nx][ny%2]=pii(0,0);\n    }\n\n    for(int j=ny;j>=1;j--){\n        for(int i=0;i<MAXSQM;i++){\n            if(map[i][j]==0 || dpmap[i][j%2].first==-1) continue;\n            for(int k=-1;k<=1;k++){\n                if(map[i+k][j-1]==0) continue;\n                if(!furui[map[i+k][j-1]]){\n                    dpmap[i+k][(j-1)%2]=max(pii(dpmap[i][j%2].first+1,map[i+k][j-1]), dpmap[i+k][(j-1)%2]);\n                }\n                else\n                {\n                    dpmap[i+k][(j-1)%2]=max(dpmap[i][j%2], dpmap[i+k][(j-1)%2]);\n                }\n                ans=max(ans,dpmap[i+k][(j-1)%2]);\n            }\n        }\n    }\n    return ans;\n}\n\nint main(){\n    while(1){\n        int m,n;\n        cin>>m>>n;\n        if(m==0) break;\n\n        furui[0]==furui[1]==true;\n        for(int i=2;i<MAXSQM;i++){\n            for(int j=2;i*j<MAXM;j++){\n                if(!furui[i]){\n                    furui[i*j]=true;\n                }\n            }\n        }\n        init_map(m);\n        pii p=dp(n);\n\n        /*int b=503,a=487;\n        for(int i=a-5;i<a+5;i++){\n            for(int j=b-5;j<b+5;j++){\n                cout<<std::setw(4)<<map[j][i];\n            }\n            cout<<endl;\n        }\n        for(int i=a-5;i<a+5;i++){\n            for(int j=b-5;j<b+5;j++){\n                cout<<setw(4)<<dpmap[j][i].first;\n            }\n            cout<<endl;\n        }*/\n        cout<<p.first<<\" \"<<p.second<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1189&lang=jp\n\n#include<iostream>\n//#include<fstream>\n#include<math.h>\n\n//#define MAX 1020000\n\n#define MAX 1002\n\nint n, first;\nint a[MAX][MAX] = {};\n\nclass Pair{\npublic:\n\tint count;\n\tint last;\n\tPair operator + (Pair p){//\t@Override (+)\n\t\tthis->count += p.count;\n\t\tif (p.last != 0)this->last = p.last;\n\t\treturn *this;\n\t}\n\tvoid setPair(int _x, int _y){\n\t\tcount = _x;\n\t\tlast = _y;\n\t}\n};\n\nPair pair(int a, int b){\n\tPair p;\n\tp.setPair(a, b);\n\treturn p;\n}\n\nbool isPrime(int n){\n\tif (n == 1)return false;\n\tif (n == 2)return true;\n\tif (n % 2 == 0)return false;\n\n\tfor (int i = 3; i * i <= n; i += 2){\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\n\nPair search(int y, int x){\n\tstatic Pair p[MAX*MAX];\n\n\tPair u_right = pair(-10, 0);\n\tPair u_left = pair(-10, 0);\n\n\tstatic bool isReached[MAX*MAX];\n\tstatic bool initial = true;\n\n\tif (initial){//初期化\n\t\tfor (int i = 0; i < MAX*MAX; i++){\n\t\t\tisReached[i] = false;\n\t\t\tp[i].count = p[i].last = 0;\n\t\t}\n\t\tinitial = false;\n\t}\n\n\tif (n < a[y][x] || a[y][x] == 0)\n\t\treturn p[0];//上限を超えていた場合,,, p[0].count = p[0].last = 0\n\n\t//以下特殊例処理\n\tif (a[y][x] == 2){\n\t\tp[2].last = 2;\n\t\tif (a[y][x] == first)initial = true;\n\t\treturn pair(1, 2) + search(y + 1, x);\n\t}\n\n\tif (n <= 6 && a[y][x] == 3){\n\t\tp[3].last = 2;\n\t\tif (a[y][x] == first)initial = true;\n\t\treturn pair(2, 2);\n\t}\n\tif (a[y][x] == 4){\n\t\tif (u_right.count == -10)u_right = search(y + 1, x + 1);\n\t\tif (u_left.count == -10)u_left = search(y + 1, x);\n\n\t\tif (u_right.count == u_left.count){\n\t\t\tif (u_right.last < u_left.last)u_right.count--;\n\t\t}\n\t\tif (u_right.count < u_left.count){\n\t\t\tisReached[4] = true;\n\t\t\tif (a[y][x] == first)initial = true;\n\t\t\treturn p[4] = p[4] + u_left;\n\t\t}\n\t\telse{\n\t\t\tisReached[4] = true;\n\t\t\tif (a[y][x] == first)initial = true;\n\t\t\treturn p[4] = p[4] + u_right;\n\t\t}\n\t}\n\t//ここまで特例処理\n\n\t//下の数字を計算\n//\tUnder under(start);\n\n\t//偶数の時\n\tif (a[y][x] % 2 == 0){\n\t\tif (a[y][x] == first)initial = true;\n\t\treturn p[a[y + 1][x]] = search(y + 1, x);\n\t}\n\t//枝刈り\n\tif (isReached[a[y][x]]){\n\t\treturn p[a[y][x]];\n\t}\n\n\tif (u_right.count == -10)u_right = search(y + 1, x + 1);//under.rightの計算\n\tif (u_left.count == -10)u_left = search(y + 1, x - 1);//under.leftの計算\n\n\t//素数の時\n\tif (isPrime(a[y][x])){\n\t\tp[a[y][x]].count = 1;\n\t\tp[a[y][x]].last = a[y][x];\n\t}\n\n\tif (u_right.count == u_left.count){\n\t\tif (u_right.last < u_left.last)u_right.count--;\n\t}\n\t//leftのコストが大きい時\n\tif (u_right.count < u_left.count){\n\t\tisReached[a[y][x]] = true;\n\t\tif (a[y][x] == first)initial = true;//最初に入った時のみ、次のために初期化\n\t\treturn p[a[y][x]] = p[a[y][x]] + u_left;\n\t}\n\t//rightのコストが大きい時\n\telse{\n\t\tisReached[a[y][x]] = true;\n\t\tif (a[y][x] == first)initial = true;//最初に入った時のみ、次のために初期化\n\t\treturn p[a[y][x]] = p[a[y][x]] + u_right;\n\t}\n}\n\nint main(){\n\n\tusing namespace std;\n\n\tint x = MAX / 2;\n\tint y = MAX / 2;\n\tint N = 1;\n\ta[MAX / 2][MAX / 2] = 1;\n\n\tfor (int i = 0; i < MAX*MAX; i++){\n\n\t\tfor (int n = 0; n < (int)sqrt((double)N); n++){\n\t\t\ta[y][x] = N;\n\t\t\tN++;\n\t\t\tx++;\n\t\t}\n\t\tif (N >= (MAX)*(MAX))break;\n\t\tfor (int n = 0; n < (int)sqrt((double)N); n++){\n\t\t\ta[y][x] = N;\n\t\t\tN++;\n\t\t\ty--;\n\t\t}\n\t\tif (N >= (MAX)*(MAX))break;\n\t\tfor (int n = 0; n < (int)sqrt((double)N); n++){\n\t\t\ta[y][x] = N;\n\t\t\tN++;\n\t\t\tx--;\n\t\t}\n\t\tif (N >= (MAX)*(MAX))break;\n\t\tfor (int n = 0; n < (int)sqrt((double)N); n++){\n\t\t\ta[y][x] = N;\n\t\t\tN++;\n\t\t\ty++;\n\t\t}\n\t\tif (N >= (MAX)*(MAX))break;\n\t}\n\n\n\t//ifstream fin;\n\t//fin.open(\"input.txt\");\n\n\twhile (true){\n\t\tcin >> n >> first;\n\t\tif (n == 0)break;\n\n\t\tfor (int i = 0; i < MAX; i++){\n\t\t\tfor (int j = 0; j < MAX; j++){\n\t\t\t\tif (a[i][j] == first){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tPair p = search(y, x);\n\n\t\tcout << p.count << \" \" << p.last << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint map[1001][1000], dp[1001][1000], dp2[1001][1000], sosu[1000001];\nint y[] = { 0, -1, 0, 1 }, x[] = { 1, 0, -1, 0 }, maxh, maxw, minh, minw, ansH, ansW;\nint m, n;\n\nvoid hantei(int h, int w) {\n\tmaxh = max(maxh, h);\n\tmaxw = max(maxw, w);\n\tminh = min(minh, h);\n\tminw = min(minw, w);\n}\n\nvoid setMap() {\n\tint h = 500, w = 500, muki = 0;\n\tmap[h][w] = 1;\n\tfor (int i = 2; i <= m; i++) {\n\t\tif (map[h + y[muki]][w+x[muki]] <= 0) {\n\t\t\thantei(h+y[muki], w+x[muki]);\n\t\t\tmap[h + y[muki]][w+x[muki]] = i;//????????£????????????\n\t\t\th += y[muki];\n\t\t\tw += x[muki];\n\t\t\tif (map[h][w] == n) {\n\t\t\t\tansH = h;\n\t\t\t\tansW = w;\n\t\t\t}\n\t\t\tmuki = (muki + 1) % 4;\n\t\t}\n\t\telse {\n\t\t\tif (muki - 1 >= 0) {\n\t\t\t\tmap[h + y[muki-1]][w + x[muki-1]] = i;//\n\t\t\t\th += y[muki - 1];\n\t\t\t\tw += x[muki - 1];\n\t\t\t\tif (map[h][w] == n) {\n\t\t\t\t\tansH = h;\n\t\t\t\t\tansW = w;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmap[h + y[3]][w + x[3]] = i;//\n\t\t\t\th += y[3];\n\t\t\t\tw += x[3];\n\t\t\t\tif (map[h][w] == n) {\n\t\t\t\t\tansH = h;\n\t\t\t\t\tansW = w;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid eratosthenes() {\n\tsosu[0] = 1;\n\tsosu[1] = 1;\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tif (sosu[i] == 0) {\n\t\t\tfor (int j = 2; j*i <= 1000000; j++) {\n\t\t\t\tsosu[j*i]++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid DP() {\n\tfor (int i = maxh; i >= minh; i--) {\n\t\tfor (int j = maxw; j >= minw; j--) {\n\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\tif (minw <= j + k && maxw >= j + k) {\n\t\t\t\t\tif (dp[i][j] < dp[i + 1][j + k]) {\n\t\t\t\t\t\tdp[i][j] = dp[i + 1][j + k];\n\t\t\t\t\t\tdp2[i][j] = dp2[i + 1][j + k];\n\t\t\t\t\t\t//printf(\"a1\\t\");\n\t\t\t\t\t}\n\t\t\t\t\telse if (dp[i][j] == dp[i + 1][j + k] && dp2[i][j] < dp2[i + 1][j + k]) {\n\t\t\t\t\t\tdp2[i][j] = dp2[i + 1][j + k];\n\t\t\t\t\t\t//printf(\"a2\\t\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sosu[map[i][j]] == 0) {//???????¶??????????????????¨?????????????????£????????????????????????\n\t\t\t\t//printf(\"a3\\t\");\n\t\t\t\tdp[i][j]++;\n\t\t\t\tif (dp[i][j] == 1) {\n\t\t\t\t\tdp2[i][j] = map[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tvector<int>v,v2;\n\teratosthenes();\n\n\twhile (cin >> m >> n, m || n) {\n\t\tmaxh = 0, maxw = 0, minh = 9999999, minw = 9999999;\n\t\tfor (int i = 0; i < 1001;i++) {\n\t\t\tfor (int j = 0; j < 1000;j++) {\n\t\t\t\tmap[i][j] = 0;\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tdp2[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tsetMap();\n\t\tDP();\n\t\tif (n == 1) {\n\t\t\tansH = 500, ansW = 500;\n\t\t}\n\t\tv.push_back(dp[ansH][ansW]);\n\t\tv2.push_back(dp2[ansH][ansW]);\n\t\t\n\t}\n\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tcout << v.at(i) << \" \" << v2.at(i) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\n\ntypedef pair<int, int> result;\nconstexpr int MAX_M = 1000000;\nconstexpr int SIZE = 1100;\n\nint n, m;\nbool is_prime[MAX_M + 1];\nint x[MAX_M + 1];\nint y[MAX_M + 1];\nint field[SIZE][SIZE];\nresult memo[SIZE][SIZE];\n\nvoid sieve() {\n\tfill_n((bool *)is_prime, sizeof(is_prime) / sizeof(bool), true);\n\tis_prime[0] = is_prime[1] = false;\n\n\tfor(int i = 1; i <= MAX_M; ++i) {\n\t\tif(is_prime[i]) {\n\t\t\tfor(int j = i + i; j <= MAX_M; j += i) {\n\t\t\t\tis_prime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid make_field() {\n\tfill_n((int *)field, sizeof(field) / sizeof(int), INT_MAX);\n\n\tconstexpr int dx[] = {0, 1, 0, -1};\n\tconstexpr int dy[] = {1, 0, -1, 0};\n\n\tint cx = SIZE / 2;\n\tint cy = SIZE / 2;\n\tint dir = 0;\n\n\tfor(int i = 1; i <= MAX_M; ++i) {\n\t\tfield[cy][cx] = i;\n\t\tx[i] = cx;\n\t\ty[i] = cy;\n\n\t\tconst int left = (dir + 1) & 0x3;\n\t\tif(field[cy + dy[left]][cx + dx[left]] == INT_MAX) {\n\t\t\tdir = left;\n\t\t}\n\n\t\tcx += dx[dir];\n\t\tcy += dy[dir];\n\t}\n}\n\nvoid init() {\n\tsieve();\n\tmake_field();\n}\n\nresult dfs(int cx, int cy) {\n\tconst int &value = field[cy][cx];\n\tif(value > m) return result(-1, -1);\n\n\tauto &res = memo[cy][cx];\n\tif(res.first != -1) return res;\n\n\tres.first = 0;\n\tres.second = (is_prime[value] ? value : 0);\n\n\tfor(int dx = -1; dx <= 1; ++dx) {\n\t\tchmax(res, dfs(cx + dx, cy + 1));\n\t}\n\n\tif(is_prime[value]) ++res.first;\n\treturn res;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tinit();\n\n\twhile(cin >> m >> n && m) {\n\t\tfill_n((result *)memo, sizeof(memo) / sizeof(result), result(-1, -1));\n\t\tconst auto ans = dfs(x[n], y[n]);\n\t\tcout << ans.first << ' ' << ans.second << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P;\nbool is_prime[1000010] = {};\nint dx[4] = {0,-1,0,1},dy[4] = {1,0,-1,0};\nint field[1010][1010] = {};\nP dp[1010][1010] = {};\n\nint main(){\n    int N,M;\n    while(cin >> M >> N && M>0){\n        if(M==1){\n            cout << 0 << \" \" << 0 << endl;\n            continue;\n        }\n        for(int i=2;i<=M;i++) is_prime[i] = true;\n        for(int i=2;i<=M;i++){\n            if(!is_prime[i]) continue;\n            for(int j=2;i*j<=M;j++) is_prime[i*j] = false;\n        }\n        int x = 0,y = 0;\n        map<int,P> m;\n        int mi_x = 1e9,mi_y = 1e9;\n        int direction = 0;\n        int now = 0,corner = 2,cnt = 2;\n        m[1] = {0,0};\n        for(int i=2;i<=M;i++){\n            x += dx[direction]; y += dy[direction];\n            m[i] = {x,y};\n            if(i==corner){\n                direction++;\n                direction %= 4;\n                cnt++;\n                corner += cnt/2;\n            }\n            mi_x = min(mi_x,x);\n            mi_y = min(mi_y,y);\n        }\n        int ma_x = 0,ma_y = 0;\n        for(auto a:m){\n            m[a.first].first -= mi_x;\n            m[a.first].second -= mi_y;\n            ma_x = max(m[a.first].first,ma_x);\n            ma_y = max(m[a.first].second,ma_y);\n        }\n//        cerr << \"ma_x:\" << ma_x << \" ma_y:\" << ma_y << endl;\n        for(int i=0;i<=ma_x;i++) for(int j=0;j<=ma_y;j++) field[i][j] = -1;\n        for(int i=1;i<=M;i++){\n            field[m[i].first][m[i].second] = i;\n        }\n        for(int i=ma_x;i>=0;i--){\n            for(int j=0;j<=ma_y;j++){\n                if(field[i][j]==-1) continue;\n                if(i==ma_x) dp[i][j] = {is_prime[field[i][j]],(is_prime[field[i][j]]? field[i][j]:-1)};\n                else{\n                    P best = dp[i+1][j];\n                    if(j>0 && field[i+1][j-1]!=-1 && best<dp[i+1][j-1]) best = dp[i+1][j-1];\n                    if(j<ma_y && field[i+1][j+1]!=-1 && best<dp[i+1][j+1]) best = dp[i+1][j+1];\n                    dp[i][j] = best;\n                    dp[i][j].first += is_prime[field[i][j]];\n                    if(is_prime[field[i][j]] && dp[i][j].second==-1) dp[i][j].second = field[i][j];\n                }\n            }\n        }\n/*        for(int i=0;i<=ma_x;i++){\n            for(int j=0;j<=ma_y;j++) cerr << dp[i][j].second << \" \";\n            cerr << endl;\n        }\n*/       int sx = m[N].first,sy = m[N].second;\n        cout << dp[sx][sy].first << \" \" << (dp[sx][sy].first!=0? dp[sx][sy].second:0) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define show(x) cout << #x << \" = \" << x << \"\\n\"\n#define fi first\n#define se second\n\nusing namespace std;\n\nconst int MAX_N = 1000001;\n\ntypedef pair<int,int>P;\ntypedef pair<P,P>PP;\n\nbool is_prime[MAX_N];\n\nvoid sieve(){\n    rep(i,MAX_N){\n        is_prime[i] = true;\n    }\n    is_prime[0] = is_prime[1] = false;\n    for(int i=2;i<MAX_N;i++){\n        if(is_prime[i]){\n            for(int j=2*i;j<MAX_N;j+=i){\n                is_prime[j] = false;\n            }\n        }\n    }\n}\n\nint pos[1005][1005];\nP bue[MAX_N];\nconst int dx2[3] = {1,1,1};\nconst int dy2[3] = {-1,0,1};\nP dp[1005][1005];\nint L=502,R=502;\n\nint main()\n{\n    sieve();\n    pos[L][R] = 1;\n    bue[1] = P(L,R);\n    int cnt = 1;\n    int i = 0, id = 1;\n    int nx = L, ny = R;\n    while(cnt != MAX_N-1){\n        if(i%4 == 0){\n            rep(j,i/2+1){\n                pos[nx][++ny] = ++id;\n                bue[id] = P(nx,ny);\n                cnt++;\n                if(cnt == MAX_N-1){\n                    break;\n                }\n            }\n        }else if(i%4 == 1){\n            rep(j,i/2+1){\n                pos[--nx][ny] = ++id;\n                bue[id] = P(nx,ny);\n                cnt++;\n                if(cnt == MAX_N-1){\n                    break;\n                }\n            }\n        }else if(i%4 == 2){\n            rep(j,i/2+1){\n                pos[nx][--ny] = ++id;\n                bue[id] = P(nx,ny);\n                cnt++;\n                if(cnt == MAX_N-1){\n                    break;\n                }\n            }\n        }else{\n            rep(j,i/2+1){\n                pos[++nx][ny] = ++id;\n                bue[id] = P(nx,ny);\n                cnt++;\n                if(cnt == MAX_N-1){\n                    break;\n                }\n            }\n        }\n        i++;\n    }\n    while(1){\n        int n,m;\n        cin >> n >> m;\n        if(n == 0){\n            break;\n        }\n        rep(i,1005){\n            rep(j,1005){\n                dp[i][j] = P(-1,-1);\n            }\n        }\n        queue<PP> que;\n        que.push(PP(bue[m],P(is_prime[m],is_prime[m]?m:0)));\n        dp[bue[m].fi][bue[m].se] = P(is_prime[m],is_prime[m]?m:0);\n        P ans = dp[bue[m].fi][bue[m].se];\n        while(!que.empty()){\n            auto p = que.front();\n            que.pop();\n            P npos = p.fi, val = p.se;\n            if(dp[npos.fi][npos.se] > val) continue;\n            rep(i,3){\n                int nx = npos.fi+dx2[i], ny = npos.se+dy2[i];\n                if(pos[nx][ny] && pos[nx][ny] <= n && dp[nx][ny] < P(val.fi+is_prime[pos[nx][ny]],is_prime[pos[nx][ny]]?pos[nx][ny]:val.se)){\n                    dp[nx][ny] = P(val.fi+is_prime[pos[nx][ny]],is_prime[pos[nx][ny]]?pos[nx][ny]:val.se);\n                    ans = max(ans,dp[nx][ny]);\n                    que.push(PP(P(nx,ny),dp[nx][ny]));\n                }\n            }\n        }\n        cout << ans.fi << \" \" << ans.se << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nmap<P,int> m;\nP m2[1000001];\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nint d[1000001],u[1000001];\n\nvector<int> sieve(int n) {\n  vector<int> p(n);\n  for(int i=2; i<n; i++) p[i]=i;\n  for(int i=2; i*i<n; i++) {\n    if(p[i]) {\n      for(int j=i*i; j<n; j+=i) p[j]=0;\n    }\n  }\n  return p;\n}\n\nvector<int> p=sieve(1000001);\n\nint main() {\n  int ma=0;\n  {\n    int x=0,y=0,k=0;\n    for(int i=1; i<=1000000; i++) {\n      m[P(x,y)]=i;\n      m2[i]=P(x,y);\n      int xx=x+dx[(k+1)%4],yy=y+dy[(k+1)%4];\n      if(!m.count(P(xx,yy))) k=(k+1)%4;\n      x=x+dx[k],y=y+dy[k];\n      ma=max(ma,x);\n    }\n  }  int n,z;\n  while(cin >> n >> z && n) {\n    memset(d,-1,sizeof(d));\n    memset(u,0,sizeof(d));\n    if(p[z]) d[z]=1;\n    else d[z]=0;\n    P s=m2[z];\n    for(int ii=0; ii<1000; ii++) {\n      for(int jj=-ii; jj<=ii; jj++) {\n        P now=P(s.first+ii,s.second+jj);\n        if(now.first>ma) goto end;\n        if(!m.count(now)) continue;\n        int x=m[now];\n        int c=d[x];\n        for(int i=-1; i<2; i++) {\n          P next=P(now.first+1,now.second+i);\n          if(!m.count(next)||m[next]>n) continue;\n          int y=m[next],cc=c;\n          if(p[y]) cc++;\n          d[y]=max(d[y],cc);\n        }\n      }\n    }\n  end:;\n    int M=0,x=0;\n    for(int i=1; i<=n; i++) {\n      if(p[i]) {\n        if(M<=d[i]) {\n          M=d[i];\n          x=i;\n        }\n      }\n    }\n    if(M==0) cout << 0 << \" \" << 0 << endl;\n    else cout << M << \" \" << x << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint s[1000][1000];\nint dp[1000][1000];\nint p[1000][1000];\n\npair<int, int> get_pos(int n) {\n        if (n == 1) return make_pair(500, 499);\n        int top_left = 1;\n        int k = 1;\n        while (n > top_left) {\n                top_left = (2 * k) * (2 * k);\n                k ++;\n        }\n        k --;\n        int top_right = top_left - 2 * k + 1;\n        int bottom_right = top_right - 2 * k + 1;\n        int bottom_left = bottom_right - 2 * k + 1;\n        int y, x;\n        if (n <= bottom_left) {\n                y = 499 - k + 1 + (2 * k - 1 - (bottom_left - n));\n                x = 499 - k + 1;\n        } else if (n <= bottom_right) {\n                y = 499 + k;\n                x = 499 - k + 1 + (n - bottom_left);\n        } else if (n <= top_right) {\n                y = 499 - k + 1 + (top_right - n);\n                x = 499 + k;\n        } else { \n                y = 499 - k + 1;\n                x = 499 - k + 1 + (top_left - n);\n        }\n        p[y][x] = n;\n        return make_pair(y, x);\n}\n\n//N??\\???????´???°?????????O(N log log N)\nint N = 1000000;\nvector<int> primes;\nvector<bool> is_prime(N + 1, true);\nvoid init() {\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 2; i <= N; i ++) {\n                if (is_prime[i]) {\n                        primes.push_back(i);\n                        for (int j = i + i; j <= N; j += i) is_prime[j] = false;\n                }\n        }\n}\n\nint main() {\n        init();\n        int m, n;\n        while (scanf(\"%d%d\", &m, &n) && n) {\n                for (int i = 0; i < 1000; i ++) for (int j = 0; j < 1000; j ++) s[i][j] = 0;\n                for (auto p : primes) {\n                        if (p > m) break;\n                        int y, x;\n                        tie(y, x) = get_pos(p);\n                        s[y][x] = 1;\n                }\n                int dp[1000][1000] = { 0 };\n                int sy, sx;\n                tie(sy, sx) = get_pos(n);\n                dp[sy][sx] = s[sy][sx];\n                for (int dy = 0; sy + dy + 1 < 1000; dy ++) {\n                        for (int dx = -dy; dx <= dy; dx ++) {\n                                dp[sy + dy + 1][sx + dx - 1] = max(dp[sy + dy + 1][sx + dx - 1], s[sy + dy + 1][sx + dx - 1] + dp[sy + dy][sx + dx]);\n                                dp[sy + dy + 1][sx + dx]     = max(dp[sy + dy + 1][sx + dx]    , s[sy + dy + 1][sx + dx]     + dp[sy + dy][sx + dx]);\n                                dp[sy + dy + 1][sx + dx + 1] = max(dp[sy + dy + 1][sx + dx + 1], s[sy + dy + 1][sx + dx + 1] + dp[sy + dy][sx + dx]);\n                        }\n                }\n                int ans = 0;\n                for (int i = 0; i < 1000; i ++) {\n                        for (int j = 0; j < 1000; j ++) {\n                                ans = max(ans, dp[i][j]);\n                        }\n                }\n                if (ans == 0) { \n                        cout << 0 << ' ' << 0 << endl;\n                        continue;\n                }\n                int res = -1;\n                for (int i = 0; i < 1000; i ++) {\n                        for (int j = 0; j < 1000; j ++) {\n                                if (dp[i][j] == ans && s[i][j]) {\n                                        res = max(res, p[i][j]);\n                                }\n                        }\n                }\n                cout << ans << ' ' << res << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(y=SIZE-1;y>=0;y--){\n\t\t\tfor(x=SIZE-1;x>=0;x--){\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&\n\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x - 1]||(dp[y][x] == dp[y + 1][x - 1] && pr[y][x] < pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && \n\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x] || (dp[y][x] == dp[y + 1][x] && pr[y][x] < pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && \n\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x + 1] || (dp[y][x] == dp[y + 1][x + 1] && pr[y][x] < pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (y = 0;y < SIZE;y++) {\n\t\t\tfor (x = 0;x < SIZE;x++) {\n\t\t\t\tif (table[y][x] == n) {\n\t\t\t\t\t//cout << dp[y][x] << \" \" << pr[y][x] << endl;\n\t\t\t\t\tcout << \"found\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass range {\nprivate:\n  struct Iterator {\n    int val;\n    int operator*() {return val;}\n    bool operator!=(Iterator& itr) {return val < itr.val;}\n    void operator++() {++val;}\n  };\n  Iterator i, n;\npublic:\n  range(int n) : i({0}), n({n}) {}\n  range(int i, int n) : i({i}), n({n}) {}\n  Iterator& begin() {return i;}\n  Iterator& end() {return n;}\n};\n\ntemplate<class T> inline T at(const vector<T> &v, int i) {return v[(i % (int)v.size() + v.size()) % v.size()];}\n\ntemplate<class T> inline bool is_max(T &a, const T &b) {return a < b ? a = b, true : false;}\ntemplate<class T> inline bool is_min(T &a, const T &b) {return a > b ? a = b, true : false;}\n\nint maze[2000][2000];\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\npair<int, int> dp[2000][2000];\n\n#include <algorithm>\n\nclass Prime {\nprivate:\n  vector<long long> divisor;\n  \n  vector<long long> _factor(long long n) {\n    if (n == 1) return vector<long long>();\n    if (n < (long long)divisor.size()) {\n      if (divisor[n] == 0) {\n        return vector<long long>(1, n);\n      } else {\n        vector<long long> ans = _factor(n / divisor[n]);\n        ans.emplace_back(divisor[n]);\n        return ans;\n      }\n    }\n    for (int i = divisor.size(); i <= n / i; ++i) if (n % i == 0) {\n      vector<long long> ans = _factor(n / i);\n      ans.emplace_back(i);\n      return ans;\n    }\n    return vector<long long>(1, n);\n  }\n  \npublic:\n  Prime() {divisor = vector<long long>(2, 1);}\n  \n  Prime(long long n) {\n    divisor = vector<long long>(n, 0);\n    divisor[0] = divisor[1] = 1;\n    for (long long i = 2; i <= n / i; ++i) if (divisor[i] == 0) {\n      for (long long j = i * i; j < n; j += i) divisor[j] = i;\n    }\n  }\n  \n  bool is_prime(long long n) {\n    if (n < (long long)divisor.size()) return divisor[n] == 0;\n    for (long long i = divisor.size(); i <= n / i; ++i) if (n % i == 0) return false;\n    return true;\n  }\n  \n  vector<long long> factor(long long n) {\n    if (n == 1) return vector<long long>(1, 1);\n    vector<long long> ans = _factor(n);\n    sort(ans.begin(), ans.end());\n    return ans;\n  }\n  \n  vector<long long> get_divisors(long long n) {\n    vector<long long> ans;\n    for (long long i = 1; i * i <= n; ++i) if (n % i == 0) {\n      ans.emplace_back(i);\n      if (i * i != n) ans.emplace_back(n / i);\n    }\n    sort(ans.begin(), ans.end());\n    return ans;\n  }\n};\n\nint main() {\n  int y = 1000, x = 1000;\n  int t = 1, s = 2, ss = 1, d = 0;\n  for (int i : range(1, 1000001)) {\n    maze[y][x] = t++;\n    if (ss == 0) {\n      ss = ++s / 2;\n      d = (d + 1) % 4;\n    }\n    y += dy[d];\n    x += dx[d];\n    --ss;\n  }\n  Prime prime;\n  while (true) {\n    int m, n;\n    cin >> m >> n;\n    if (m == 0 && n == 0) break;\n    for (int i : range(2000)) for (int j : range(2000)) dp[i][j] = make_pair(-1, 0);\n    for (int i : range(2000)) for (int j : range(2000)) if (maze[i][j] == n) dp[i][j] = make_pair(0, 0);\n    for (int i : range(1999)) for (int j : range(1, 1999)) if (dp[i][j].first != -1) {\n      if (maze[i][j] <= m && prime.is_prime(maze[i][j])) {\n        is_max(dp[i + 1][j + 1], make_pair(dp[i][j].first + 1, maze[i][j]));\n        is_max(dp[i + 1][j    ], make_pair(dp[i][j].first + 1, maze[i][j]));\n        is_max(dp[i + 1][j - 1], make_pair(dp[i][j].first + 1, maze[i][j]));\n      } else {\n        is_max(dp[i + 1][j + 1], dp[i][j]);\n        is_max(dp[i + 1][j    ], dp[i][j]);\n        is_max(dp[i + 1][j - 1], dp[i][j]);\n      }\n    }\n    pair<int, int> res = make_pair(0, 0);\n    for (int i : range(2000)) is_max(res, dp[1999][i]);\n    cout << res.first << \" \" << res.second << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//マップをつくる\n//ふるって素数マップ作る\n//dp[深さ][左端からの距離]で素数洞窟に入った回数をDP、素数かどうかはO(1)で判定\n#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\n\nclass Solver{\npublic:\n\tint isprime[1100000];\t//素数なら1、そうでないなら0を入れる\n\tint data[2001][2001];\t//マップデータ。\n\tint dp[1201][1201];\n\tint dp2[1201][1201];\n\t\n\tvoid SetPrime( int m ){\n\t\tint i,j;\n\t\tfor( i = 0; i <= m; i++ ) isprime[i] = 1;\n\t\tisprime[0] = 0; isprime[1] = 0;\n\t\tfor( i = 2; i <= m; i++ ){\n\t\t\tif( isprime[i] ) {\n\t\t\t\t//cout << i << endl;\n\t\t\t\tfor( j = i*2; j <= m; j += i )\n\t\t\t\t\tisprime[j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid uzumaki( int m ){\n\t\tint i,j;\n\t\tint ci=600,cj=600;\n\t\tint cnt=1;\n\t\tfor( i = 1; cnt <= m; i++ ){\n\t\t\t//→\n\t\t\tfor( j = 0; j <= i; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[i+ci][j+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//↑\n\t\t\tfor( j = 1; j <= 2*i-1; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[i-j+ci][i+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//←\n\t\t\tfor( j = 1; j <= 2*i; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[-i+1+ci][i-j+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//↓\n\t\t\tfor( j = 1; j <= 2*i; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[-i+1+j+ci][-i+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//→\n\t\t\tfor( j = 1; j < i; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[i+1+ci][-i+j+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\t//デバッグ\n\t\t/*for( i = -16; i <= 16; i++ ){\n\t\t\tfor( j = -16; j <= 16; j++ ){\n\t\t\t\tif ( data[i+ci][j+cj] < 1000 && isprime[data[i+ci][j+cj]] )\n\t\t\t\t\tprintf(\"%4dp\",data[i+ci][j+cj]);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%5d\",data[i+ci][j+cj]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t}\n\t\n\tpair<int, int> search_ij(int m, int n) {\n\t\tint i,j;\n\t\tint ci=600,cj=600;\t//uzumakiと同じにしておくこと！\n\t\tint cnt=1;\n\t\tfor( i = 1; cnt <= m; i++ ){\n\t\t\tif ( data[i+1+ci][cj] < n ) {\n\t\t\t\tcnt = data[i+1+ci][cj];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//→\n\t\t\tfor( j = 0; j <= i; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(i+ci, j+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//↑\n\t\t\tfor( j = 1; j <= 2*i-1; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(i-j+ci, i+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//←\n\t\t\tfor( j = 1; j <= 2*i; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(-i+1+ci, i-j+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//↓\n\t\t\tfor( j = 1; j <= 2*i; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(-i+1+j+ci, -i+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//→\n\t\t\tfor( j = 1; j < i; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(i+1+ci, -i+j+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\treturn pair<int, int>(-1, -1);\n\t}\n\t\n\tvoid DP( int m, int n ){\n\t\tint i,j;\n\t\tpair<int, int> ij = search_ij(m, n);\n\t\ti = ij.first; if ( i == -1 ) return;\n\t\tfor( ; i < 1200; i++ ) {\n\t\t\tfor( j = 0; j < 1200; j++ ) {\n\t\t\t\tdp[i][j] = -114514;\n\t\t\t\tdp2[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\ti = ij.first;\n\t\tj = ij.second;\n\t\tdp[i][j] = 0;\n\t\t\n\t\tfor( ; i < 1200; i++ ){\n\t\t\tfor( j = 0; j < 1200; j++ ){\n\t\t\t\t//今いる場所がゴールなら何もしない\n\t\t\t\tif ( data[i][j] > m || dp[i][j] < 0 )\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\t//今いる場所が素数か\n\t\t\t\tint c = isprime[ data[i][j] ];\n\t\t\t\tdp[i+1][j-1] = max( dp[i][j]+c, dp[i+1][j-1] );\n\t\t\t\tdp[i+1][j] = max( dp[i][j]+c, dp[i+1][j] );\n\t\t\t\tdp[i+1][j+1] = max( dp[i][j]+c, dp[i+1][j+1] );\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor( i = ij.first; i < 1200; i++ ){\n\t\t\tfor( j = 0; j < 1200; j++ ) {\n\t\t\t\tans = max(ans, dp[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//経路復元とついでにans2の更新。\n\t\t//ちなみに、ゴールからたどっていけば、たどった場所すべてがスタートからありつけるようにできるので、\n\t\t//ans2を直接更新することができる。(経路の候補が消える！ということがない)→嘘解法らしい。\n\t\t//したがって、ans2はdp2を全部埋めてから求めることにしよう。\n\t\t//…最後に通過した素数洞穴の番号＞＜＞＜！(↑は嘘解法ではなかったようです。誤読！！最大値じゃない！！誤読！！)\n\t\t//誤飲も怖いけど誤読も恐ろforces…\n\t\tint ans2 = 0;\n\t\tif ( ans > 0 ) {\n\t\t\t//\n\t\t\tfor( i = 1199; i > ij.first; i-- ) {\n\t\t\t\tfor( j = 0; j < 1200; j++ ) {\n\t\t\t\t\tif ( dp[i][j] != ans && dp2[i][j] == 0 )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif ( dp2[i][j] == 0 ) {\n\t\t\t\t\t\tdp2[i][j] = 1;\n\t\t\t\t\t\tif ( isprime[data[i][j]] && data[i][j] <= m )\n\t\t\t\t\t\t\tdp2[i][j] = data[i][j];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ( data[i-1][j-1] <= m && dp[i-1][j-1] + isprime[data[i-1][j-1]] == dp[i][j]) {\n\t\t\t\t\t\tdp2[i-1][j-1] = max(dp2[i-1][j-1], dp2[i][j]);\n\t\t\t\t\t\tif ( isprime[data[i-1][j-1]] ) {\n\t\t\t\t\t\t\tdp2[i-1][j-1] = max(dp2[i-1][j-1], data[i-1][j-1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( data[i-1][j] <= m && dp[i-1][j] + isprime[data[i-1][j]] == dp[i][j] ) {\n\t\t\t\t\t\tdp2[i-1][j] = max(dp2[i-1][j], dp2[i][j]);\n\t\t\t\t\t\tif ( isprime[data[i-1][j]] )\n\t\t\t\t\t\t\tdp2[i-1][j] = max(dp2[i-1][j], data[i-1][j]);\n\t\t\t\t\t}\n\t\t\t\t\tif ( data[i-1][j+1] <= m && dp[i-1][j+1] + isprime[data[i-1][j+1]] == dp[i][j] ) {\n\t\t\t\t\t\tdp2[i-1][j+1] = max(dp2[i-1][j+1], dp2[i][j]);\n\t\t\t\t\t\tif ( isprime[data[i-1][j+1]] )\n\t\t\t\t\t\t\tdp2[i-1][j+1] = max(dp2[i-1][j+1], data[i-1][j+1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//\n\t\t\tfor( i = 1199; i > ij.first; i-- ) {\n\t\t\t\tbool find = false;\n\t\t\t\tfor( j = 0; j < 1200; j++ ) {\n\t\t\t\t\tif ( dp2[i][j] && isprime[data[i][j]] && data[i][j] <= m ) {\n\t\t\t\t\t\tfind = true;\n\t\t\t\t\t\tans2 = max(ans2, data[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( find )\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << ans << \" \" << ans2 << endl;\n\t}\n};\n\nSolver test;\n\nint main(){\n\tint m,n;\n\t\n\ttest.SetPrime(1090000);\n\ttest.uzumaki(1090000);\n\twhile( cin >> m >> n ){\n\t\tif(!m)return 0;\n\t\ttest.DP(m, n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nconst int MAX = 1010;\nint table[MAX][MAX];\nbool isprime[MAX*MAX];\nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\nvoid init(int n){\n  fill((int*)table, (int*)table+MAX*MAX, -1);\n  int x = MAX/2, y = MAX/2;\n  int d = 0, step = 1, cnt = 0, tt = 0;\n\n  for(int i=1;i<=n;++i){\n\ttable[y][x] = i;\n\tx += dx[d], y += dy[d];\n\tif(++cnt >= step){\n\t  cnt = 0, ++d, d %= 4;\n\t  if(++tt >= 2)\n\t\ttt = 0, ++step;\n\t}\t\t  \n  }\n\n  fill(isprime, isprime+MAX*MAX, true);\n  isprime[0] = isprime[1] = false;\n  REP(i,n+1)\n\tif(isprime[i])\n\t  for(int j=i+i;j<=n;j+=i)\n\t\tisprime[j] = false;\n  \n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int M, N;\n  while(cin>>M>>N,M){\n\t//  init(1000000);\n\tinit(M);\n\tint sx, sy;\n\tREP(y,MAX) REP(x,MAX)\n\t  if(table[y][x] == N){\n\t\tsx = x, sy = y; break;\n\t  }\n\n\tVVI row(2, VI(MAX, 0));\n\tint lx=sx, rx = sx, crt = 0, nxt = 1;\n\tint ans_n = 0, ans_p = 0;\n\tbool up = true;\n\tif(isprime[N])\n\t  ans_n = 1, ans_p = N, row[crt][sx] = 1;\n\twhile(up){\n\t  up = false;\n\t  ++sy;\n\t  for(int x=max(0,lx);x<=min(rx,MAX-1);++x){\n\t\tfor(int d=-1;d<=1;++d){\n\t\t  if(table[sy][x+d] < 0) continue;\n\t\t  up = true;\n\t\t  row[nxt][x+d] = max(row[nxt][x+d],\n\t\t\t\t\t\t\t  row[crt][x] + isprime[table[sy][x+d]]);\n\t\t  if(isprime[table[sy][x+d]]){\n\t\t\tif(row[nxt][x+d] > ans_n)\n\t\t\t  ans_n = row[nxt][x+d], ans_p = table[sy][x+d];\n\t\t\telse if(row[nxt][x+d] == ans_n)\n\t\t\t  ans_p = max(ans_p, table[sy][x+d]);\n\t\t  }\n\t\t}\n\t  }\n\t  swap(crt, nxt);\n\t  --lx, ++rx;\n\t}\n\tcout << ans_n << \" \" << ans_p << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define f first\n#define s second\ntypedef pair<int,int> P;\nint a[2000][2000],ans[2000][2000],d=0,y=999,x=1001,n,m;\nbool b[1000001],used[2000][2000];\nint dx[]={-1,0,1,0},tx[]={-1,0,1};\nint dy[]={0,1,0,-1},ty[]={1,1,1};\nint main(){\n  b[0]=b[1]=1;\n  for(int i=2;i<1000001;i++)\n    for(int j=i+i;j<1000001;j+=i)b[j]=1;\n  a[1000][1000]=1;\n  a[1000][1001]=2;\n  a[999][1001]=3;\n  for(int i=4;i<1000001;i++){\n    int yy=y+dy[d],xx=x+dx[d];\n    int ya=yy+dy[(d+1)%4],xa=xx+dx[(d+1)%4];\n    if(!a[ya][xa])d=(d+1)%4;\n    a[yy][xx]=i;\n    y=yy,x=xx;\n  }\n  while(cin>>n>>m,n){\n    memset(ans,0,sizeof(ans));\n    memset(used,0,sizeof(used));\n    r(i,2000)r(j,2000)if(a[i][j]==m){\n      used[i][j]=1;y=i;\n      break;\n    }\n    for(int i=y;i<2000;i++)r(j,2000)if(a[i][j]&&used[i][j]){\n      if(!b[a[i][j]])ans[i][j]++;\n      r(k,3){\n        y=i+ty[k],x=j+tx[k];\n        if(!a[y][x]||a[y][x]>n)continue;\n        ans[y][x]=max(ans[y][x],ans[i][j]);\n        used[y][x]=1;\n      }\n    }\n    int a1=0,a2;\n    r(i,2000)r(j,2000)if(a[i][j]<=n)if(a1<=ans[i][j]){\n      a1=ans[i][j],a2=a[i][j];\n    }\n    if(!a1)cout<<\"0 0\"<<endl;\n    else cout<<a1<<' '<<a2<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define H 1000\n#define W 1000\nusing namespace std;\nint grid[H][W];\ntypedef pair<int, int> pii;\n\npii dp[(int)1e6 + 1];//first cnt, second max\nbool isprime[(int)1e6 + 1];\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid sieve(int n){\n  isprime[0] = isprime[1] = true;\n  for(int i = 2; i <= n; i++){\n    if(isprime[i])continue;\n    for(int j = 2*i; j <= n; j+=i)isprime[j] = true;\n  }\n}\n\n\nbool renge(int x, int y){\n  if(0 <= x && x < W &&\n     0 <= y && y < H)return true;\n  return false;\n}\nvector<int> inM(int y, int x, int m){\n  vector<int> res;\n  if(y + 1 >= H) return res;\n  for(int i = -1; i < 2; i++){\n    if(grid[y + 1][x + i] <= m)res.push_back(i);\n  }\n  return res;\n}\n\nint main(int argc, char *argv[]){\n  sieve((int)1e6);\n  int n = H*W, m, x = 0, y = 0, dir = 0;\n  while(n > 1){\n    for(;renge(x + dx[dir], y + dy[dir]) && \n\t  grid[y + dy[dir]][x + dx[dir]] == 0;){\n      grid[y][x] = n;\n      n--;\n      x += dx[dir], y += dy[dir];\n    }\n    grid[y][x] = n;\n    n--;\n    dir++;\n    dir %= 4;\n    x += dx[dir], y += dy[dir];\n  }\n  while(cin >> m >> n, n){\n    memset(dp, 0, sizeof(dp));\n    for(int i = H - 1; i >= 0; i--){\n      for(int j = 0; j < W; j++){\n\tif(grid[i][j] <= m){\n\t  vector<int> cand = inM(i, j, m);\n\t  for(int k = 0; k < cand.size(); k++){\n\t    dp[grid[i][j]] = max(dp[grid[i][j]], dp[grid[i + 1][j + cand[k]]]);\n\t  }\n\t  if(!isprime[grid[i][j]]){\n\t    if(dp[grid[i][j]].first == 0)dp[grid[i][j]].second = grid[i][j];\n\t    dp[grid[i][j]].first++;\n\t  }\n\t}\n      }\n    }\n    cout << dp[n].first << \" \" << dp[n].second << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n// ????????????\nconst int dx[] = {1,0,-1,0}; const int dy[] = {0,-1,0,1};\n\nconst int MAX_H = 1005;\nconst int MAX_W = 1005;\n\nconst int MAX_M = 1e6;\n\nbool prime[MAX_M+1];\nint cave[MAX_H][MAX_W];\n\nvoid find_start(int start_num, int& sx, int& sy) {\n    REP(y, MAX_H) REP(x, MAX_W) {\n        if (cave[y][x] == start_num) {\n            sx = x;\n            sy = y;\n            return;\n        }\n    }\n}\n\nint main() {\n    prime[0] = prime[1] = true;\n    FOR(i, 2, MAX_M+1) {\n        if (prime[i]) continue;\n        for (int j = i+i; j < MAX_M+1; j += i) {\n            prime[j] = true;\n        }\n    }\n\n    int y = MAX_H/2+1, x = MAX_W/2+1;\n    int d = 0;\n    FOR(i, 1, MAX_M+1) {\n        cave[y][x] = i;\n        y += dy[d];\n        x += dx[d];\n        int d2 = (d + 1) % 4;\n        if (cave[y + dy[d2]][x + dx[d2]] == 0) {\n            d = d2;\n        }\n    }\n\n    int caves, start_n;\n    while (cin >> caves >> start_n, caves|start_n) {\n        int x, y;\n        find_start(start_n, x, y);\n\n        pii res = {0, 0}; // ?????°, ?´???°?´?????????????\n\n        vector<int> G(MAX_W, -1);\n        G[x] = 0;\n        bool updated;\n        do {\n            updated = false;\n            vector<int> G2(G);\n            REP(x, MAX_W) {\n                if (G[x] == -1) continue;\n\n                if (!prime[cave[y][x]]) {\n                    G[x]++;\n                    pair<int, int> r(G[x], cave[y][x]);\n                    res = max(res, r);\n                }\n                for (int dx = -1; dx <= 1; dx++) {\n                    int sx = x + dx;\n                    int sy = y + 1;\n                    if (0 <= sx && sx < MAX_W && 0 <= sy && sy < MAX_H) {\n                        if (cave[sy][sx] != 0 && cave[sy][sx] <= caves) {\n                            G2[sx] = max(G[x], G2[sx]);\n                            updated = true;\n                        }\n                    }\n                }\n            }\n            G = G2;\n            if (++y >= MAX_H) break;\n        } while (updated);\n        printf(\"%d %d\\n\", res.first, res.second);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nint caves[2000][2000];\n\nbool sieve[1000001];\nint SX, SY;\n\ntypedef pair<int, int> PII;\n\nPII dp[2000][2000];\nbool vis[2000][2000];\n\nint main()\n{\n\tint nx, ny;\n\tfill(sieve, sieve + 1000001, true);\n\tsieve[0] = sieve[1] = false;\n\tfor(int i = 2; i * i <= 1000000; ++i) {\n\t\tif(sieve[i]) {\n\t\t\tfor(int j = i * i; j <= 1000000; j += i) {\n\t\t\t\tsieve[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint M, N;\n\twhile (cin>>M>>N, M||N) {\n\t\tmemset(caves, -1, sizeof(caves));\n\t\t\n\t\tfor (int j=0; j<2000; j++) {\n\t\t\tfor (int i=0; i<2000; i++) {\n\t\t\t\tdp[i][j] = PII(0, -1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tnx = ny = 2000/2;\n\t\tint len=1, num=2;\n\t\tint d = 0;\n\t\t\n\t\tcaves[nx][ny] = 1;\n\t\t\n\t\twhile (num <= M) {\n\t\t\tfor (int j=0; j<len; j++) {\n\t\t\t\tnx += dx[d];\n\t\t\t\tny += dy[d];\n\t\t\t\tcaves[nx][ny] = num++;\n\t\t\t\tif (num > M) break;\n\t\t\t}\n\t\t\td++; d %= 4;\n\t\t\tif (num > M) break;\n\t\t\t\n\t\t\tfor (int j=0; j<len; j++) {\n\t\t\t\tnx += dx[d];\n\t\t\t\tny += dy[d];\n\t\t\t\tcaves[nx][ny] = num++;\n\t\t\t\tif (num > M) break;\n\t\t\t}\n\t\t\t\n\t\t\td++;\n\t\t\td %= 4;\n\t\t\tlen++;\n\t\t}\n\t\t\n\t\tfor (int i=0; i<2000; i++) {\n\t\t\tfor (int j=0; j<2000; j++) {\n\t\t\t\tif (caves[j][i] == N) {\n\t\t\t\t\tSX = j, SY = i;\n\t\t\t\t\tif(sieve[N]) {\n\t\t\t\t\t\tdp[i][j] = PII(1, N);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j] = PII(0, -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t#if 1\n\t\tfor (int i=1000-10; i<1000+10; i++) {\n\t\t\tfor (int j=1000-10; j<1000+10; j++) {\n\t\t\t\tprintf(\"%3d\", caves[j][i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t#endif\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tvis[SY][SX] = true;\n\t\tfor(int i = 0; i < 2000 - 1; ++i) {\n\t\t\tfor(int j = 0; j < 2000; ++j) {\n\t\t\t\tif(vis[i][j] == false) continue;\n\t\t\t\tfor(int k = -1; k <= 1; ++k) {\n\t\t\t\t\tint nx = j + k;\n\t\t\t\t\tif(nx < 0 || nx >= 2000) continue;\n\t\t\t\t\tint add = dp[i][j].first;\n\t\t\t\t\tint maxP = dp[i][j].second;\n\t\t\t\t\tif(caves[nx][i + 1] > 0 && sieve[caves[nx][i + 1]]) {\n\t\t\t\t\t\tadd++;\n\t\t\t\t\t\tmaxP = caves[nx][i + 1];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i + 1][nx] = max(dp[i + 1][nx], PII(add, maxP));\n\t\t\t\t\tvis[i + 1][nx] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tPII ans(-1, -1);\n\t\tfor(int j = 0; j < 2000; ++j) {\n\t\t\tans = max(ans, dp[2000 - 1][j]);\n\t\t}\n\t\tcout << ans.first << ' ' << max(0, ans.second) << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define reps(i,a,n) for(int i=a; i<(n); i++)\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\n\nconst int dx[4] = {1, 0,-1, 0};\nconst int dy[4] = {0,-1, 0, 1};\n\nint  a[5000][5000];\n\nconst int c = 2000;\n\nbool isp[1234567];\n\n\npii p[5000][5000];\nint v[5000][5000];\n\n\n\n\n\nint main(){\n\n\trep(i,1234567) isp[i] = true;\n\tisp[0] = isp[1] = false;\n\trep(i, 1234567){\n\t\tif(!isp[i])continue;\n\t\tfor(int j=i*2; j<1234567; j+=i){\n\t\t\tisp[j] = false;\n\t\t}\n\t}\n\n\n\tfor(;;){\n\t\tint n,m;\n\t\tcin >> n >> m;\n\t\tif(n==0) break;\n\t\t\n\t\trep(i,5000)rep(j,5000) a[i][j] = 0;\n\n\t\ta[c][c] = 1;\n\t\tif(m>1) a[c][c+1] = 2;\n\n\t\tint d = 2;\n\t\tint x = 1;\n\t\tint y = -1;\n\t\treps(i, 3, n+1){\n\t\t\ta[c+y][c+x] = i;\n\t\t\tint X=x;\n\t\t\tint Y=y;\n\t\t\tX += dx[(d+1)%4];\n\t\t\tY += dy[(d+1)%4];\n\t\t\tif(a[c+Y][c+X] == 0){\n\t\t\t\td++; d%=4;\n\t\t\t}\n\t\t\tx += dx[d];\n\t\t\ty += dy[d];\n\t\t}\n/*\n\t\treps(i, -10, 11){\n\t\t\treps(j, -10, 11){\n\t\t\t\tprintf(\"%3d\", a[c+i][c+j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}puts(\"\");\n*/\t\t\n\t\trep(i, 5000) rep(j, 5000){\n\t\t\tv[i][j] = -5000;\n\t\t\tif(a[i][j]==m) v[i][j] = 0;\n\t\t}\n\t\t\n\t\tint ma = -1;\n\t\tint mi = 0;\n\t\treps(i, 1, 4999) reps(j, 1,4999){\n\t\t\tint A = v[i-1][j-1];\n\t\t\tint B = v[i-1][j];\n\t\t\tint C = v[i-1][j+1];\n\t\t\t\n\t\t\tv[i][j] = max(max(max(A,B),C),v[i][j]) + isp[a[i][j]];\n\n\t\t\tif(ma <= v[i][j]){\n\t\t\t\tif(ma != v[i][j]){\n\t\t\t\t\tma = v[i][j];\n\t\t\t\t\tmi = 0;\n\t\t\t\t}\n\t\t\t\tif(isp[a[i][j]]) mi = max(mi,a[i][j]);\n\t\t\t}\n\t\t}\n\t\tcout << ma << \" \"<<mi <<endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint sosu[1000010]={1,1,0};\nvvp nu;\nvvi dp;\nint main(){\n\tfor(int i=2;i*i<1000010;i++)if(sosu[i]==0){\n\t\tfor(int j=i+i;j<1000010;j+=i)sosu[j]=1;\n\t}\n\tnu=vvp(1100,vp(1100,pii(inf,0)));\n\tint x=550,y=550;\n\tint dx[]={0,-1,0,1};\n\tint dy[]={1,0,-1,0};\n\tint co=1,t=0,tt=1;;\n\tnu[x][y]=pii(1,0);\n\twhile(1){\n\t\trep(i,co){\n\t\t\ttt++;\n\t\t\tx+=dx[t];y+=dy[t];\n\t\t\tnu[x][y]=pii(tt,sosu[tt]^1);\n\t\t\tif(tt==1000010)break;\n\t\t}\n\t\tt++;\n\t\tif(t==4)t=0;\n\t\tif(t==0||t==2)co++;\n\t\tif(tt==1000010)break;\n\t}\n\tint n,m;\n\twhile(cin>>m>>n,n+m){\n\t\tdp=vvi(1100,vi(1100,-1));\n\t\trep(i,1100)rep(j,1100)if(nu[i][j].first==n)dp[i][j]=nu[i][j].second;\n\t\tloop(i,20,1080)loop(j,20,1080)if(dp[i][j]>=0&&nu[i][j].first<=m){\n\t\t\tif(nu[i+1][j+1].first<=m)dp[i+1][j+1]=max(dp[i+1][j+1],dp[i][j]+nu[i+1][j+1].second);\n\t\t\tif(nu[i+1][j].first<=m)dp[i+1][j]=max(dp[i+1][j],dp[i][j]+nu[i+1][j].second);\n\t\t\tif(nu[i+1][j-1].first<=m)dp[i+1][j-1]=max(dp[i+1][j-1],dp[i][j]+nu[i+1][j-1].second);\n\t\t}\n\t\tint out=-1,q=0;\n\t\trep(i,1090)rep(j,1090)if(out<=dp[i][j]&&nu[i][j].second){\n\t\t\tif(out==dp[i][j])q=max(q,nu[i][j].first);\n\t\t\telse q=nu[i][j].first;\n\t\t\tout=max(dp[i][j],out);\n\t\t}\n\t\tif(out<=0)cout<<0<<\" \"<<0<<endl;\n\t\telse cout<<out<<\" \"<<q<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=x && x<w && 0<=y && y<h)\n\nconst int INF = 10000000;\nint dx[4]={1, 0, -1, 0}, dy[4]={0, 1, 0, -1};\nusing namespace std;\ntypedef pair<int, int> P;\n\n/** Problem1189 : Prime Caves **/\nint caves[1010][1010];\nint dp[1010][1010];\nconst int MAX = 1030000;\nbool prime[MAX];\n\nint main()\n{\n\tint m, n;\n\tconst int dx0[4] = {1, 0, -1, 0}, dy0[4] = {0, -1, 0, 1}, dx1[3]={-1, 0, 1};\n\tint sx, sy;\n\t\n\tfor (int i=0; i<MAX; i++)\n\t\tprime[i] = true;\n\t\n\tprime[0] = false; prime[1] = false;\n\t\n\tfor (int i=2; i<MAX; i++) {\n\t\tif (prime[i]) {\n\t\t\tfor (int j=2; i*j<MAX; j++) {\n\t\t\t\tprime[i*j] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\twhile (cin>>m>>n, m||n) {\n\t\tfill(caves[0], caves[0]+1010*1010, 0);\n\t\tfill(dp[0], dp[0]+1010*1010, -1);\n\t\tint x=1010/2, y=1010/2 , t=1, direct=1;\n\t\tcaves[x][y]=1;\n\t\tcaves[++x][y]=2;\n\t\tint i=2; bool change = true;\n\t\twhile (1) {\n\t\t\trep(j, t) {\n\t\t\t\tx+=dx0[direct]; y+=dy0[direct];\n\t\t\t\tcaves[x][y]=i+1;\n\t\t\t\ti++;\n\t\t\t\tif (i==n) {\n\t\t\t\t\tsx = x; sy = y;\n\t\t\t\t}\n\t\t\t\tif (i>=m) goto end;\n\t\t\t}\n\t\t\tif (change) {\n\t\t\t\tt++;\n\t\t\t\tchange = false;\n\t\t\t} else {\n\t\t\t\tchange=true;\n\t\t\t}\n\t\t\tdirect++; direct%=4;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstdio>\n \nusing namespace std;\n \n#define out(x,l) (x<0||l<=x)\n \nconst int N = 1000000+10;\nconst int SIZE = 1010;\n \nbool isprime[N];\npair<int, int> loc[N];\nint cave[SIZE][SIZE];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, -1, 0, 1};\npair<int, int> dp[SIZE][SIZE];\n \nint main(){\n    for (int i = 0; i < N; i++) { isprime[i] = 1; } \n    isprime[0] = isprime[1] = 0;\n    for (int i = 2; i*i <= N; i++) {\n        if (!isprime[i]) continue;\n        for (int j = 2*i; j <= N; j += i) {\n            isprime[j] = 0;\n        }\n    }\n\n\tfor (int i = 0; i < SIZE; i++)\n\t\tfor (int j = 0; j < SIZE; j++)\n\t\t\tcave[i][j] = 0;\n \n    int x = SIZE/2, y = SIZE/2;\n    int cnt = 1;\n    int dir = 0;\n    int edge = 1;\n    while (1) {\n\t\tif (cnt > N) break;\n        dir %= 4;\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < edge; j++) {\n\t\t\t\tif (out(x,SIZE)||out(y,SIZE)) continue;\n                cave[y][x] = cnt;\n                loc[cnt].first = y;\n                loc[cnt].second = x;\n                x += dx[dir];\n                y += dy[dir];\n                cnt++;\n            }\n            dir++;\n        }\n        edge++;\n    }\n \n//  for (int i = 1; i < 100; i++) {\n//      cout << i << \" \" << loc[i].first << \" \" << loc[i].second << endl;\n//  }\n \n    int n, m;\n    while (cin >> m >> n, m&&n) {\n        for (int i = 0; i < SIZE; i++)\n            for (int j = 0; j < SIZE; j++) {\n                dp[i][j].first = -1;\n                dp[i][j].second = 0;\n            }\n        dp[loc[n].first][loc[n].second].first = isprime[n];\n        if (isprime[n]) dp[loc[n].first][loc[n].second].second = n;\n \n        for (int i = 0; i < SIZE; i++) {\n            for (int j = 0; j < SIZE; j++) {\n                if (cave[i][j] > m) continue;\n                pair<int, int> next; // first:the number of caves passed    second:last cave\n                next.first = -1;\n                next.second = 0;\n                bool update = 0;\n                if (!out(i-1,SIZE)&&!out(j-1,SIZE)&&dp[i-1][j-1].first!=-1) {\n                    if (dp[i-1][j-1].first > next.first) {\n                        next = dp[i-1][j-1];\n                        update = 1;\n                    } else if (dp[i-1][j-1].first == next.first && dp[i-1][j-1].second > next.second) {\n                        next = dp[i-1][j-1];\n                        update = 1;\n                    }\n                }\n                if (!out(i-1,SIZE)&&!out(j+1,SIZE)&&dp[i-1][j+1].first!=-1) {\n                    if (dp[i-1][j+1].first > next.first) {\n                        next = dp[i-1][j+1];\n                        update = 1;\n                    } else if (dp[i-1][j+1].first == next.first && dp[i-1][j+1].second > next.second) {\n                        next = dp[i-1][j+1];\n                        update = 1;\n                    }\n                }\n                if (!out(i-1,SIZE)&&!out(j,SIZE)&&dp[i-1][j].first!=-1) {\n                    if (dp[i-1][j].first > next.first) {\n                        next = dp[i-1][j];\n                        update = 1;\n                    } else if (dp[i-1][j].first == next.first && dp[i-1][j].second > next.second) {\n                        next = dp[i-1][j];\n                        update = 1;\n                    }\n                }\n                if (!update) continue;\n                if (isprime[cave[i][j]]) {\n                    next.first++;\n                    next.second = cave[i][j];\n                }\n                dp[i][j] = next;\n            }\n        }\n\n        pair<int, int> res;\n        for (int i = 0; i < SIZE; i++)\n            for (int j = 0; j < SIZE; j++)\n                if (res.first < dp[i][j].first) {\n                    res = dp[i][j];\n                } else if (res.first == dp[i][j].first&&res.second < dp[i][j].second) {\n                    res = dp[i][j];\n                }\n        cout << res.first << \" \" << res.second << endl;\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nint m,n;\nint isp[1000010];\nint a[2010][2010];\nint dy[]={0,-1,0,1};\nint dx[]={1,0,-1,0};\nint dp[2010][2010];\n\nvoid main2(){\n\trep(i,2010)rep(j,2010){\n\t\tdp[i][j]=a[i][j]==n?isp[n]:-INF;\n\t}\n\trep(i,2009)rep2(j,1,2009){\n\t\trep2(k,-1,2){\n\t\t\tdp[i+1][j+k]=max(dp[i+1][j+k],dp[i][j]+(a[i+1][j+k]<=m && isp[a[i+1][j+k]]));\n\t\t}\n\t}\n\tint ans1=0,ans2=0;\n\trep(i,2010)rep(j,2010)if(a[i][j]<=m && isp[a[i][j]]){\n\t\tif(dp[i][j]>ans1 || dp[i][j]==ans1 && a[i][j]>ans2){\n\t\t\tans1=dp[i][j],ans2=a[i][j];\n\t\t}\n\t}\n\tcout<<ans1<<\" \"<<(ans1==0?0:ans2)<<endl;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tfill(isp,isp+1000001,1);\n\tisp[0]=isp[1]=0;\n\trep2(i,2,1000001)if(isp[i]){\n\t\tfor(int j=i*2;j<=1000000;j+=i){\n\t\t\tisp[j]=0;\n\t\t}\n\t}\n\tint y=1000,x=1000,d=0,cur=1;\n\ta[y][x]=cur;\n\trep(i,INF){\n\t\trep(j,i/2+1){\n\t\t\ty+=dy[d];\n\t\t\tx+=dx[d];\n\t\t\ta[y][x]=++cur;\n\t\t}\n\t\td=(d+1)%4;\n\t\tif(cur>=1000000)break;\n\t}\n\twhile(cin>>m>>n && m){\n\t\tmain2();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n, m;\nint cave[1001][1001];\nP dp[1000005];\nbool prime[1000005];\n\nP search(int x, int y, int val)\n{\n\tint nx, ny;\n\tP ret = make_pair(0, -1);\n\t\n\tif(dp[val].first != -1) return dp[val];\n\t\n\tfor(int v = -1; v <= 1; v++){\n\t\tnx = x + v, ny = y + 1;\n\t\tif(nx < 0 || nx >= 1001 || ny < 0 || ny >= 1001) continue;\n\t\tif(cave[nx][ny] > n) continue;\n\t\tret = max(ret, search(nx, ny, cave[nx][ny]));\n\t}\n\tif(!prime[val]){\n\t\tret.first++;\n\t\tif(ret.second == -1) ret.second = val;\n\t}\n\t\n\treturn dp[val] = ret;\n}\n\nint main(void)\n{\n\tcout << \"-100\" << endl;\n\t\n\tint px = 500, py = 500, dir = 0, dir2;\n\tconst int vx[] = {1, 0, -1, 0}, vy[] = {0, -1, 0, 1};\n\t\n\tint nx, ny;\n\tfor(int i = 1; i <= 1001 * 1001; i++){\n\t\tcave[px][py] = i;\n\t\tpx += vx[dir], py += vy[dir];\n\t\tdir2 = (dir+1)%4;\n\t\tif(cave[px + vx[dir2]][py + vy[dir2]] == 0) dir = dir2;\n\t}\n\t\n\tprime[1] = true;\n\tfor(int i = 2; i < 1100; i++){\n\t\tif(!prime[i]){\n\t\t\tfor(int j = 2 * i; j < 1000005; j += i) prime[j] = true;\n\t\t}\n\t}\n\t\n\t\n\t\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0) break;\n\t\t\n\t\tfor(int i = 1; i <= n; i++) dp[i] = make_pair(-1, -1);\n\t\t\n\t\tint x, y;\n\t\tfor(x = 0; x < 1001; x++){\n\t\t\tfor(y = 0; y < 1001; y++){\n\t\t\t\tif(cave[x][y] == m) goto end;\n\t\t\t}\n\t\t}\n\t\tend:;\n\t\t\n\t\tP ans = search(x, y, m);\n\t\tif(ans.first == 0) ans.second = 0;\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cstdio>\n#include <cmath>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define fr first\n#define sc second\n#define mp make_pair\n\ntypedef long long int64;\ntypedef pair< int, int > iP;\ntypedef pair< iP, int > iiP;\n\nconst int INF = 2 << 28;\nconst double EPS = 1e-10;\n\n#define MAX 1000000\n#define NEXT(d) ((d) % 4)\n\nint mas[8000][8000];\niP idx[MAX + 1], used[8000][8000];\nvector< bool > isP(MAX + 1, true);\n\nvoid makePrime() {\n    for(int i = 2; i * i <= MAX; i++) {\n        for(int j = i + i; j <= MAX; j += i) {\n            isP[j] = false;\n        }\n    }\n}\n\nvoid makeMap() {\n    //> ^ < v\n    int x = 4000, y = 4000;\n    int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n    int dir = 0;\n    for(int i = 1; i <= MAX; i++) {\n        mas[y][x] = i;\n        idx[i] = iP(y, x);\n        x += dx[dir], y += dy[dir];\n        if(!mas[y + dy[NEXT(dir + 1)]][x + dx[NEXT(dir + 1)]]) dir = NEXT(dir + 1);\n    }\n}\n\niP ans;\nvoid bfs(int limit, int s) {\n    fill_n(*used, 8000 * 8000, iP(-INF, -INF));\n    // first: { first: y, second: x }\n    // second: { first: count prime cave, second: max number of through prime cave }\n    ans = iP(0, 0);\n    queue< pair< iP, iP > > que;\n    if(isP[mas[idx[s].fr][idx[s].sc]]) que.push(mp(idx[s], iP(1, s)));\n    else que.push(mp(idx[s], iP(0, 0)));\n    int dx[] = {-1, 0, 1}, dy[] = {1, 1, 1};\n    while(!que.empty()) {\n        pair< iP, iP > p = que.front(); que.pop();\n        for(int i = 0; i < 3; i++){\n            int nx = p.fr.sc + dx[i], ny = p.fr.fr + dy[i];\n            if(mas[ny][nx] > limit) {\n                ans = max(ans, p.sc);\n                continue;\n            }\n            else {\n                if(isP[mas[ny][nx]]) {\n                    int maxi = max(p.sc.sc, mas[ny][nx]);\n                    que.push(mp(iP(ny, nx), iP(p.sc.fr + isP[mas[ny][nx]], maxi)));\n                    used[ny][nx] = iP(p.sc.fr + isP[mas[ny][nx]], maxi);\n                }\n                else if(used[ny][nx] < p.sc)  {\n                    que.push(mp(iP(ny, nx), p.sc));\n                    used[ny][nx] = p.sc;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n\n    makePrime();\n    makeMap();\n\n    int m, n;\n    while(cin >> m >> n, m) {\n        bfs(m, n);\n        cout << ans.fr << \" \" << ans.sc << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nconst int N = 1010, MAX = 1000001;\nint a[N][N], isprime[MAX];\n\nint main() {\n    int i = 505, j = 505, x = 1;\n    int di[] = {0,-1,0,1}, dj[] = {1,0,-1,0};\n    a[i][j] = 1;\n    for (int p = 0; x < 1000000; p++){\n        REP(c,p/2+1){\n            x++;\n            i += di[p%4];\n            j += dj[p%4];\n            a[i][j] = x;\n        }\n    }\n\n    FOR(i,2,MAX) isprime[i] = 1;\n    FOR(i,2,MAX){\n        if (!isprime[i]) continue;\n        for (int x = 2*i; x <= MAX; x += i) isprime[x] = 0; \n    }\n\n    // FOR(i,500,510){\n    //     FOR(j,500,510){\n    //         printf(\"%3d \", isprime[a[i][j]]);\n    //     }\n    //     cout << endl;\n    // }\n\n    int m, n;\n    while (cin >> m >> n && m){\n        VVI dp(N,VI(N,-1)), dpm(N,VI(N));\n        REP(i,N) REP(j,N) if (a[i][j] == n) dp[i][j] = isprime[n], dpm[i][j] = n;\n        REP(i,N) REP(j,N){\n            if (dp[i][j] == -1 || a[i][j] == 0) continue;\n            FOR(k,j-1,j+1){\n                int p = a[i+1][k];\n                if (p > m) continue;\n                if (isprime[p]){\n                    dp[i+1][k] = max(dp[i+1][k], dp[i][j] + 1);\n                    dpm[i+1][k] = p;\n                }else{\n                    if (dp[i+1][k] < dp[i][j] || (dp[i+1][k] == dp[i][j] && dpm[i+1][k] < dpm[i][j])){\n                        dp[i+1][k] = dp[i][j];\n                        dpm[i+1][k] = dpm[i][j];\n                    }\n                }\n            }\n        }\n\n        // FOR(i,500,510){\n        //     FOR(j,500,510){\n        //         printf(\"%3d \", dp[i][j]);\n        //     }\n        //     cout << endl;\n        // }\n\n        int x = 0, y = 0;\n        REP(i,N) REP(j,N){\n            if (x < dp[i][j] || (x == dp[i][j] && y < dpm[i][j])){\n                x = dp[i][j];\n                y = dpm[i][j];\n            }\n        }\n        if (x == 0) y = 0;\n        printf(\"%d %d\\n\", x, y);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint map[2000][2000],dp[2000][2000];\nint isprime[200];\nbool prime[1000001];\nbool square;\nvoid issquare(int n){\n\tsquare=false;\n\tfor(int i=2;i*i<=n;i++)if(n==i*i)square=true;\n\treturn;\n}\nint main(){\n\tfor(int i=0;i<=1000000;i++)prime[i]=true;\n\tprime[1]=false;\n\tint pcnt=0;\n\tfor(int i=2;i<1000;i++){\n\t\tbool ok=true;\n\t\tfor(int j=0;j<pcnt;j++)if(i%isprime[j]==0)ok=false;\n\t\tif(ok){\n\t\t\tfor(int j=i*i;j<=1000000;j+=i)prime[j]=false;\n\t\t\tisprime[pcnt]=i,pcnt++;\n\t\t}\n\t}\n\tfor(int i=0;i<2000;i++)for(int j=0;j<2000;j++){map[i][j]=-1,dp[i][j]=-10000;}\n\tint dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n\tint x=1000,y=1000,s=0,t=1,r=1;\n\tmap[999][999]=1;\n\tfor(int k=1;k<=1000000;k++){\n\t\tmap[y][x]=k;\n\t\ty+=dy[r],x+=dx[r];\n\t\tissquare(k+1);\n\t\tif(square)t++;\n\t\tif(s==t){r=(r+1)%4;s=0;}\n\t\ts++;\n\t}//prepara\n\tint n,m;\n\twhile(true){\n\t\tcin>>m>>n;\n\t\tif(n==0&&m==0)break;\n\t\tfor(int i=0;i<2000;i++)for(int j=0;j<2000;j++)dp[i][j]=-10000;\n\t\tint x=0,y=0;\n\t\tbool end=false;\n\t\twhile(true){\n\t\t\twhile(true){\n\t\t\t\tif(map[y][x]==n){end=true;break;}\n\t\t\t\tx++;if(x==2000)break;\n\t\t\t}if(end)break;y++;\n\t\t}\n\t\tint ans=0,set=0;\n\t\tdp[y][x]=0;\n\t\tfor(int i=1;i<2000;i++){\n\t\t\tfor(int j=1;j<1999;j++){\n\t\t\t\tif(map[i][j]>0&&map[i][j]<=m){\n\t\t\t\t\tfor(int k=j-1;k<=j+1;k++)if(map[i-1][k]<=m)dp[i][j]=max(dp[i][j],dp[i-1][k]);\n\t\t\t\t\tdp[i][j]+=prime[map[i][j]];\n\t\t\t\t\tif(ans<dp[i][j])ans=dp[i][j],set=map[i][j];\n\t\t\t\t\tif(ans==dp[i][j]&&prime[map[i][j]]==true)set=map[i][j];\n\t\t\t\t}\n\t\t\t\t//cout<<dp[i][j]<<\" \";\n\t\t\t}\n\t\t\t//cout<<endl;\n\t\t}\n\t\tcout<<\"#\"<<ans<<\" \"<<set<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\nint n,m,o;\nint t[1200][1200];\nint dp[1200][1200];\nint flg[1200][1200];\nint isP[1000001];\nint numx[1000001];\nint numy[1000001];\nint st[1000],size=0;\nint MAXvalue,MAXno;\nvoid make();\nvoid init();\n\nint main(){\n  m=1000000;\n  make();\n  numy[1]=numx[1]=600;\n  while(cin>>m>>n&&n){\n    MAXvalue=MAXno=0;\n    for(int i=0;i<1200;i++)for(int j=0;j<1200;j++)flg[i][j]=dp[i][j]=-1;\n\n    flg[numy[n]][numx[n]]=n*isP[n];\n    dp[numy[n]][numx[n]]=isP[n];\n    for(int i=0;i<1200;i++){\n      for(int j=0;j<1200;j++){\n\tif(t[i][j]==0||t[i][j]>m||dp[i][j]==-1)continue;\n\t//cout<<t[i][j]<<endl;\n\tdp[i+1][j-1]=dp[i+1][j]=dp[i+1][j+1]=0;\n\tfor(int k=j-1;k<j+2;k++){\n\t  if(dp[i-1][k]==-1)continue;\n\n\t  if(dp[i-1][k]+isP[t[i][j]]>dp[i][j]){\n\n\t    dp[i][j]=dp[i-1][k]+isP[t[i][j]];\n\t    flg[i][j]=max(t[i][j]*isP[t[i][j]],flg[i-1][k]);\n\n\t  }else if(dp[i-1][k]+isP[t[i][j]]==dp[i][j]){\n\n\t    flg[i][j]=max(t[i][j]*isP[t[i][j]],flg[i-1][k]);\n\n\t  }\n\t}//k\n\t//cout<<t[i][j]<<' '<<flg[i][j]<<' '<<dp[i][j]<<endl;\n\tif(MAXvalue<dp[i][j]){\n\t  MAXvalue=dp[i][j];\n\t  MAXno=flg[i][j];\n\t}else if(MAXvalue==dp[i][j]){\n\t  MAXno=max(MAXno,flg[i][j]);\n\t}\n      }//j\n\n    }//i\n    cout<<MAXvalue<<' '<<MAXno<<endl;\n  }\n  return 0;\n}\nvoid make(){\n  for(int i=0;i<1200;i++){\n    for(int j=0;j<1200;j++){\n      dp[i][j]=t[i][j]=0;flg[i][j]=-1;\n    }\n  }\n\n  for(int i=0;i<1000001;i++)isP[i]=1;\n  \n  isP[0]=isP[1]=0;\n  for(int i=2;i*i<1000001;i++){\n    if(!isP[i])continue;\n    for(int j=i*i;j<1000001;j+=i){\n      isP[j]=0;\n    }\n  }\n\n  int nx,ny,cnt=2,z=1,k;\n  nx=ny=600;\n  t[600][600]=1;\n  \n  while(cnt<=m){\n    //cout<<cnt<<endl;\n    for(k=nx+1;k<=nx+z;k++){\n      numy[cnt]=ny;numx[cnt]=k;\n      t[ny][k]=cnt++;\n      if(cnt>m)break;\n    }\n    nx+=z;\n    \n    for(k=ny-1;k>=ny-z;k--){\n      numy[cnt]=k;numx[cnt]=nx;\n      t[k][nx]=cnt++;\n      if(cnt>m)break;\n    }\n    ny-=z;\n\n    z++;\n  \n    \n    for(k=nx-1;k>=nx-z;k--){\n      numy[cnt]=ny;numx[cnt]=k;\n      t[ny][k]=cnt++;\n      if(cnt>m)break;\n    }\n    nx-=z;\n\n    for(k=ny+1;k<=ny+z;k++){\n      numy[cnt]=k;numx[cnt]=nx;\n      t[k][nx]=cnt++;\n      if(cnt>m)break;\n    }\n    ny+=z;\n    \n    z++;\n  }\n  /*\n  for(int i=numy[37];i<=numy[43];i++){\n    for(int j=numx[37];j<=numx[26];j++){\n      printf(\"%3d \",t[i][j]);\n    }\n    cout<<endl;\n  }\n  */\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\nint dy[]={0,-1, 0, 1};\nint dx[]={-1,0, 1, 0};\n \nstruct aaa{\n    int maxi;\n    int prime;\n};\n  \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n \nint hole[1000][1000],m,n;\nbool isp[1000001];\naaa memo[1003][1000];\n \naaa search(int y,int x){\n    if(memo[y][x].maxi >= 0)\n        return memo[y][x];\n \n    if((y > 999) || hole[y][x] > m){\n        aaa ret;\n        memo[y][x].maxi = memo[y][x].prime = 0;\n        return memo[y][x];\n    }\n \n    aaa ret;ret.maxi = ret.prime = 0;\n \n    for(int i = x - 1;i < x + 2;i++){\n        if(i < 0 || i > 999)\n            continue;\n \n        aaa b = search(y + 1,i);\n        if(b.maxi > ret.maxi || (b.maxi == ret.maxi && b.prime > ret.prime))\n            ret = b;\n    }\n    if(ret.prime == 0 && isp[hole[y][x]])\n        ret.prime = hole[y][x];\n    ret.maxi += isp[hole[y][x]];\n    return memo[y][x] = ret;\n}\n \nint main(){\n    int d = 2;int x = 0;int y = 0;\n    RFOR(i,1,1000001){\n        hole[y][x] = i;\n        if(x + dx[d] < 0 || x + dx[d] > 999  || y + dy[d] < 0 || y + dy[d] > 999 || hole[y + dy[d]][x + dx[d]] > 0){\n            d = (d + 1) % 4;\n        }\n \n        x += dx[d]; y += dy[d];\n    }\n \n    memset(isp,true,sizeof(isp));isp[1] = false;\n    FOR(i,2,10000){\n        if(isp[i]){\n            for(int j = i * 2;j < 1000001;j += i)\n                isp[j] = false;\n        }\n    }\n    while(1){\n        scanf(\"%d%d\",&m,&n);\n        if(m == 0 && n == 0)\n            break;\n \n        aaa ans;\n        REP(i,1003)\n            REP(j,1000)\n                memo[i][j].maxi = -1;\n \n        REP(i,1000){\n            REP(j,1000){\n                if(hole[i][j] == n)\n                    ans = search(i,j); \n            }\n        }\n        printf(\"%d %d\\n\",ans.maxi,ans.prime);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define SIZE 2000\n#define X first\n#define Y second\n  \nconst int STX = 1000, STY = 1000;\n  \nint id[SIZE][SIZE];\nbool is_prime[MAX_N+1];\nvector<pair<int, int> > coord;\n\nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++) {\n    if(is_prime[i]) {\n      for(int j=i*i; j<=MAX_N; j+=i) {\n\tis_prime[j] = false;\n      }\n    }\n  }\n}\n\nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  \n  coord.PB(MP(0, 0)); // no use\n  cnt ++;\n  coord.PB(MP(x, y)); // cnt = 1\n  \n  fill(id[0], id[0]+SIZE*SIZE+1, -1);\n  \n  const int dx[] = {0,-1,0,1};\n  const int dy[] = {-1,0,1,0};\n  \n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt <= MAX_N) {\n    a += 2;\n    for(int turn=0; turn<4; turn++) {\n      for(int i=0; i<a; i++) {\n\tx += dx[turn], y += dy[turn];\n\tcoord.PB(MP(x, y));\n\tid[y][x] = ++ cnt;\n      }\n    }\n    x++, y++;\n  }\n}\n\nint dp[MAX_N+1];\n\nint main() {\n  \n  Sieve();\n  MakeMap();\n  \n  int m, n;\n\n  while(cin >> m >> n && (m|n)) {\n    \n    //bool ok = false;\n    \n    fill(dp, dp+MAX_N+1, -1);\n    dp[n] = is_prime[n];\n    pair<int, int> ans(dp[n], n);\n    \n    queue<pair<int, int> > que;\n    que.push(coord[n]);\n    queue<int> q_dp;\n    q_dp.push(dp[n]);\n    while(!que.empty()) {\n      pair<int, int> now = que.front(); que.pop();\n      int tmp = q_dp.front(); q_dp.pop();\n      int tmpid = id[now.Y][now.X];\n      if(tmp < dp[tmpid]) continue;\n      \n      int noid = id[now.Y][now.X];\n      \n      for(int i=-1; i<=1; i++) {\n\tpair<int, int> nex = MP(now.X+i, now.Y+1);\n\tif(nex.X < 0 || SIZE <= nex.X || nex.Y < 0 || SIZE <= nex.Y) continue;\n\tint neid = id[nex.Y][nex.X];\n\tif(neid <= m) {\n\t  if(dp[neid] < dp[noid] + is_prime[neid]) {\n\t    dp[neid] = dp[noid] + is_prime[neid];\n\t    //if(is_prime[neid]) ok = true;\n\t    ans = max(ans, make_pair(dp[neid], neid));\n\t    que.push(nex);\n\t    q_dp.push(dp[neid]);\n\t  }\n\t}\n      }\n\n    }\n    \n    /*\n    int res = dp[n], lastid = -1;\n    if(is_prime[n]) lastid = n;\n    \n    for(int i=1; i<=m; i++) {\n      if(res <= dp[i] && is_prime[i]) {\n\tres = dp[i];\n\tlastid = max(lastid, i);\n      }\n    }\n    */\n    if(ans.first == 0) cout << \"0 0\" << endl;\n    else {\n      int ans2 = 2;\n      cout << ans.first << \" \";\n      for(int i=1; i<=m; i++) {\n\tif(ans.first == dp[i] && is_prime[i]) {\n\t  ans2 = max(ans2, i);\n\t}\n      }\n      cout << ans2 << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <map>\nusing namespace std;\n\n#define REP(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) REP(i,0,n)\n\ntypedef pair<int, int> PII;\n\npair<int, bool> caves[1001][1001];\nbool seive[2000001];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nvoid make_seive(void) {\n  for (int i = 0; i <= 2000000; i++) {\n    seive[i] = true;\n  }\n\n  seive[0] = seive[1] = false;\n\n  for (int i = 2; i * i <= 2000000; i++) {\n    if (!seive[i]) continue;\n    for (int j = i * i; j <= 2000000; j += i) {\n      seive[j] = false;\n    }\n  }\n}\n\nPII make_caves(int s, int n) {\n  int x = s / 2;\n  int y = s / 2;\n\n  int cave_no = 1;\n  int move_no = 0;\n  int move_limit = 1;\n\n  PII start_point;\n\n  while (cave_no < s * s) {\n    for (int i = 0; i < 2; i++) {\n\n      for (int j = 0; j < move_limit; j++) {\n        caves[y][x].first = cave_no;\n        caves[y][x].second = seive[cave_no];\n\n        if (cave_no == n) {\n          start_point.first = x;\n          start_point.second = y;\n        }\n\n        x += dx[move_no];\n        y += dy[move_no];\n\n        cave_no++;\n      }\n\n      move_no++;\n      move_no %= 4;\n    }\n\n    move_limit++;\n  }\n\n  return start_point;\n}\n\nmap<PII, pair<int, PII>> memo;\n\npair<int, PII> dfs(int x, int y, int s, int cave_no_limit) {\n  if (memo.count(PII(x, y))) return memo[PII(x,y)];\n\n  pair<int, PII> ret;\n  ret.first = caves[y][x].second;\n  ret.second = PII(x, y);\n\n  pair<int, PII> max_route;\n  max_route.first = 0;\n  max_route.second = PII(-1, -1);\n\n  for (int d = -1; d <= 1; d++) {\n    if (x + d < 0 || x + d >= s || y + 1 < 0 || y + 1 >= s) {\n      continue;\n    }\n\n    if (caves[y+1][x+d].first > cave_no_limit) {\n      continue;\n    }\n\n    pair<int, PII> route = dfs(x + d, y + 1, s, cave_no_limit);\n\n    if (route.first == 0) continue;\n\n    if (route.first > max_route.first) max_route = route;\n    else if (route.first == max_route.first) {\n      int rx = route.second.first;\n      int ry = route.second.second;\n\n      int mrx = max_route.second.first;\n      int mry = max_route.second.second;\n\n      if (caves[mry][mrx].first < caves[ry][rx].first) {\n        max_route = route;\n      }\n    }\n  }\n\n\n  ret.first += max_route.first;\n  if (max_route.first != 0) {\n    ret.second = max_route.second;\n  }\n\n  return memo[PII(x,y)] = ret;\n}\n\nvoid dump_caves(int s, int x, int y) {\n  for (int i = 0; i < s; i++) {\n    for (int j = 0; j < s; j++) {\n      char mark;\n      if (j == x && i == y) mark = '!';\n      else if (caves[i][j].second) mark = 'o';\n      else mark = ' ';\n\n      printf(\"%2d[%c] \", caves[i][j].first, mark);\n    }\n    printf(\"\\n\");\n  }\n}\n\nint main(void) {\n  int m, n;\n  make_seive();\n\n  while (cin >> m >> n, m && n) {\n    memo.clear();\n\n    int s = 1;\n    while (s * s < m) s += 2;\n    \n    int x, y;\n    tie(x, y) = make_caves(s, n);\n\n    pair<int, PII> res = dfs(x, y, s, m);\n\n    int cnt = res.first;\n    int cave_no = caves[res.second.second][res.second.first].first;\n\n    if (cnt == 0)\n      cave_no = 0;\n\n    cout << cnt << \" \" << cave_no << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define SIZE 1001\n\nbool C(int dp1, int pr1, int dp2, int pr2) {\n\tif (dp2 == 0)return false;\n\tif (dp1 < dp2 || (dp1 == dp2&&pr1 < pr2))return true;\n\treturn false;\n}\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (x >= 0 && y >= 0 && table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x - 1], pr[y + 1][x - 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x], pr[y + 1][x])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x + 1], pr[y + 1][x + 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\n\t\toutput = false;\n\t\tfor (int i = 0;i < SIZE&&!output;i++) {\n\t\t\tfor (int j = 0;j < SIZE&&!output;j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tprintf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <utility>\n#include <queue>\n#include <tuple>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\n#define dump(val) cerr << __LINE__ << \":\\t\" << #val << \" = \" << (val) << endl\n\nusing namespace std;\n\ntypedef long long int lli;\ntypedef pair<int, int> pii;\n\ntemplate<typename T>\nvector<T> make_v(size_t a, T b) {\n    return vector<T>(a, b);\n}\n\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\nint main() {\n    int m, n;\n    int sz = 1000010;\n    vector<bool> isPrime(sz, true);\n    isPrime[0] = isPrime[1] = false;\n    REP(i, 0, sz) {\n        if (isPrime[i]) {\n            for (int j = 2 * i; j < sz; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n\n    int dx[4] = {0, -1, 0, 1};\n    int dy[4] = {-1, 0, 1, 0};\n    const int bs = 510;\n\n    while (cin >> m >> n, m + n) {\n        vector<vector<pii>> mp(bs * 2 + 1, vector<pii>(bs * 2 + 1));\n        vector<vector<int>> prevP(bs * 2 + 1, vector<int>(bs * 2 + 1));\n        int sx, sy;\n        {\n            int y = 0, x = 0, z = 0, k = 3;\n            REP(i, 1, m + 1) {\n                if (i == n) {\n                    sx = x;\n                    sy = y;\n                }\n                mp[y + bs][x + bs] = {i, isPrime[i]};\n                prevP[y + bs][x + bs] = (isPrime[i] ? i : 0);\n                if (i == (2 * z + 1) * (2 * z + 1)) {\n                    z++;\n                }\n                if (abs(x + dx[k]) > z || abs(y + dy[k]) > z) {\n                    k = (k + 1) % 4;\n                }\n                x += dx[k];\n                y += dy[k];\n            }\n        }\n        int num = prevP[sy + bs][sx + bs], ans = isPrime[n];\n        vector<vector<bool>> used(bs * 2 + 1, vector<bool>(bs * 2 + 1, false));\n        queue<pii> q;\n        q.push({sy, sx});\n        while (q.size()) {\n            int x, y;\n            tie(y, x) = q.front();\n            q.pop();\n            if (used[y + bs][x + bs]) continue;\n            used[y + bs][bs + x] = true;\n            REP(k, 1, 4) {\n                int nx = x + dx[k], ny = y + 1;\n                if (mp[ny + bs][nx + bs].first == 0) continue;\n                auto &ne = mp[ny + bs][nx + bs];\n                auto &pe = mp[y + bs][x + bs];\n\n                if (ne.second < pe.second + isPrime[ne.first]) {\n                    ne.second = pe.second + isPrime[ne.first];\n                    if (!isPrime[ne.first]) {\n                        prevP[ny + bs][nx + bs] = prevP[y + bs][x + bs];\n                    }\n                } else if (ne.second == pe.second + isPrime[ne.first]) {\n                    if (!isPrime[ne.first]) {\n                        prevP[ny + bs][nx + bs] = max(prevP[ny + bs][nx + bs], prevP[y + bs][x + bs]);\n                    }\n                }\n                /*\n                mp[ny + bs][nx + bs].second = max(mp[ny + bs][nx + bs].second, mp[y + bs][x + bs].second + isPrime[mp[ny + bs][nx + bs].first]);\n                if (!isPrime[mp[ny + bs][nx + bs].first]) {\n                    prevP[ny + bs][nx + bs] = max(prevP[ny + bs][nx + bs], prevP[y + bs][x + bs]);\n                }\n                */\n                q.emplace(ny, nx);\n                if (ans < mp[ny + bs][nx + bs].second) {\n                    ans = mp[ny + bs][nx + bs].second;\n                    num = prevP[ny + bs][nx + bs];\n                } else if (ans == mp[ny + bs][nx + bs].second && num < prevP[ny + bs][nx + bs]) {\n                    num = prevP[ny + bs][nx + bs];\n                }\n            }\n        }\n        cout << ans << \" \" << num << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 1000100\n\nint num[1100][1100] ={};\nint place_y[SIZE], place_x[SIZE];\n\nconst int MAX_P = SIZE; //max\nbool prime[MAX_P+1];\n\nvoid Eratosthenes(void){\n  for(int i=2;i<=MAX_P;i++)\n    prime[i]=true;\n  \n  for(int i=2;i*i<=MAX_P;i++)\n    if(prime[i])  \n      for(int j=i;i*j<=MAX_P;j++)\n        prime[i*j]=false;\n}\n\nint dp1[1100][1100], dp2[1100][1100], visited[1100][1100];\n\nbool solve(){\n  int m,n;\n  scanf(\"%d%d\",&m,&n);\n\n  if(m == 0) return false;\n  \n  memset(dp1, 0, sizeof(dp1));\n  memset(dp2, 0, sizeof(dp2));\n  memset(visited, 0, sizeof(visited));\n\n  dp1[place_y[n]][place_x[n]] = prime[n];\n\n  if(prime[n])\n    dp2[place_y[n]][place_x[n]] = n;\n  else\n    dp2[place_y[n]][place_x[n]] = 0;\n\n  visited[place_y[n]][place_x[n]] = true;\n\n  int max_dp1 = 0, max_dp2 = 0;\n  \n  for(int i=0;i<1070;i++){\n    for(int j=1;j<1100-1;j++){\n      if(num[i][j] <= 0 || num[i][j] > m || !visited[i][j]) continue;\n      \n      if(max_dp1 < dp1[i][j]){\n        max_dp1 = dp1[i][j];\n        max_dp2 = dp2[i][j];\n      }else if(max_dp1 == dp1[i][j]){\n        max_dp2 = max(max_dp2,dp2[i][j]);\n      }\n      \n      for(int k=-1;k<=1;k++){\n        if(dp1[i+1][j+k] < dp1[i][j] + prime[num[i+1][j+k]]){\n          dp1[i+1][j+k] = dp1[i][j] + prime[num[i+1][j+k]];\n          \n          if(prime[num[i+1][j+k]])\n            dp2[i+1][j+k] = num[i+1][j+k];\n          else\n            dp2[i+1][j+k] = dp2[i][j];\n\n        }else if(dp1[i+1][j+k] == dp1[i][j] + prime[num[i+1][j+k]]){\n          \n          if(prime[num[i+1][j+k]])\n            dp2[i+1][j+k] = num[i+1][j+k];\n          else\n            dp2[i+1][j+k] = max(dp2[i+1][j+k], dp2[i][j]);\n        }\n\n        visited[i+1][j+k] = true;\n      }\n      \n    }\n  }\n\n  printf(\"%d %d\\n\",max_dp1, max_dp2);\n  \n  return true;\n}\n\n\nint main(){\n\n  int max_x = 560, min_x = 560, max_y = 560, min_y = 560;\n  int x = 560, y = 560;\n  int d = 0;\n\n  int dx[8] = {1,0,-1,0};\n  int dy[8] = {0,-1,0,1};\n  \n  for(int i=1;i<=1000000;i++){\n    place_x[i] = x;\n    place_y[i] = y;\n\n    num[y][x] = i;\n    \n    int next_x = x + dx[d];\n    int next_y = y + dy[d];\n    \n    if(next_x < min_x || max_x < next_x || next_y < min_y || max_y < next_y){\n      d = (d+1)%4;\n    }\n\n    min_x = min(min_x,next_x);\n    max_x = max(max_x,next_x);\n    min_y = min(min_y,next_y);\n    max_y = max(max_y,next_y);\n\n    x = next_x;\n    y = next_y;\n  }\n\n  Eratosthenes();\n\n  while(solve());\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\nint num[2048][2048];\nint dy[] = {0, -1, 0, 1};\nint dx[] = {1, 0, -1, 0};\nint m;\nbool prime[1000001];\npair<int, int> pos[1002001];\npair<int, int> memo[1000001];\n\nbool valid(int y, int x)\n{\n\treturn (0 <= y && y <= 2000 && 0 <= x && x <= 2000 && 1 <= num[y][x] && num[y][x] <= m);\n}\n\npair<int, int> getMax(pair<int, int> pos)\n{\n\tif (memo[num[pos.first][pos.second]].first != -1)\n\t\treturn (memo[num[pos.first][pos.second]]);\n\t\n\tint y = pos.first, x = pos.second;\n\tpair<int, int> ret = make_pair(0, 0);\n\tfor (int dx = -1; dx <= 1; dx++){\n\t\tif (valid(y + 1, x + dx)){\n\t\t\tpair<int, int> tmp = getMax(make_pair(y + 1, x + dx));\n\t\t\tif (ret < tmp) ret = tmp;\n\t\t}\n\t}\n\t\n\tif (prime[num[y][x]]){\n\t\tret.first++;\n\t\tif (!ret.second) ret.second = num[y][x];\n\t}\n\t\n\treturn (memo[num[pos.first][pos.second]] = ret);\n}\n\nint main()\n{\n\tmemset(num, -1, sizeof(num));\n\t\n\tint sx = 1000, sy = 1000;\n\tint n = 1;\n\tint step = 1, dir = 0;\n\t\n\tnum[sy][sx] = n;\n\tpos[n++] = make_pair(sy, sx);\n\twhile (n <= 1000000){\n\t\tfor (int i = 0; i < step; i++){\n\t\t\tsy += dy[dir]; sx += dx[dir];\n\t\t\tnum[sy][sx] = n;\n\t\t\tpos[n++] = make_pair(sy, sx);\n\t\t}\n\t\tdir = (dir + 1) % 4;\n\t\tfor (int i = 0; i < step; i++){\n\t\t\tsy += dy[dir]; sx += dx[dir];\n\t\t\tnum[sy][sx] = n;\n\t\t\tpos[n++] = make_pair(sy, sx);\n\t\t}\n\t\tdir = (dir + 1) % 4;\n\t\tstep++;\n\t}\n\t\n\tfor (int i = 3; i <= 1000000; i += 2) prime[i] = true;\n\tprime[2] = true;\n\t\n\tfor (int i = 3; i * i <= 1000000; i += 2){\n\t\tif (prime[i] == true){\n\t\t\tfor (int j = 3 * i; j <= 1000000; j += 2 * i) prime[j] = false;\n\t\t}\n\t}\n\t\n\twhile (scanf(\"%d %d\", &m, &n) && m){\n\t\tfor (int i = 0; i <= 1000000; i++)\n\t\t\tmemo[i].first = memo[i].second = -1;\n\t\t\n\t\tpair<int, int> ans = getMax(pos[n]);\n\t\t\n\t\tprintf(\"%d %d\\n\", ans.first, ans.second);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int MAX_M = 1000001;\nconst int C = 1000;\nconst int INF = 1e9;\n#define y first\n#define x second\n\nmap<int, P> itop;\nmap<P, int> ptoi;\nbool isp[MAX_M];\n\nvoid make_prime(){\n  REP(i, MAX_M) isp[i] = true;\n  isp[0] = isp[1] = false;\n  FOR(i, 2, sqrt(MAX_M) + 1){\n    if(!isp[i]) continue;\n    for(int j = i + i; j < MAX_M; j += i) isp[j] = false;\n  }\n}\n\nvoid init(){\n  P now = P(C / 2, C / 2);\n  int c[C][C], pls = 1, l = 1, step = 0, d = 0;\n  memset(c, 0, sizeof(c));\n  FOR(i, 1, MAX_M){\n    itop[i] = now;\n    ptoi[now] = i;\n    if(d == 0) now.x += 1;\n    else if(d == 1) now.y -= 1;\n    else if(d == 2) now.x -= 1;\n    else if(d == 3) now.y += 1;\n    ++step;\n    if(step >= l){\n      d = (d + 1) % 4;\n      step = 0;\n    }\n    if(i != 1 && (d == 0 || d == 2) && step == 0) ++l;\n  }\n}\n\nint main() {\n  make_prime();\n  init();\n  int M, N;\n  while(cin >>M >>N && (N && M)){\n    P dp[C][C];\n    REP(i, C) REP(j, C) dp[i][j] = P(-1, -1);\n    P now = itop[N], ans = P(-1, -1);\n    dp[now.y][now.x] = (isp[N] ? P(1, N) : P(0, -1));\n    REP(y, C - 1){\n      REP(x, C){\n        if(dp[y][x].first == -1) continue;\n        ans = max(ans, dp[y][x]);\n        for(int mx = -1; mx <= 1; ++mx){\n          int ny = y + 1, nx = x + mx, cnt = dp[y][x].first + (isp[ptoi[P(ny, nx)]] ? 1 : 0), num = (isp[ptoi[P(ny, nx)]] ? ptoi[P(ny, nx)] : dp[y][x].second);\n          if(num > M) continue;\n          if(cnt > dp[ny][nx].first || (cnt == dp[ny][nx].first && num > dp[ny][nx].second)) dp[ny][nx] = P(cnt, num);\n        }\n      }\n    }\n    if(ans.first == 0) cout <<\"0 0\" <<endl;\n    else cout <<ans.first <<\" \" <<ans.second <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint dp1[1005][1005];//number\nint dp2[1005][1005];//last prime\nint reached[1005][1005];\n\nint caves[1004][1004];\n\nbool in(int x,int y){\n  if(x<0 || 1004<=x || y<0 || 1004<=y)return false;\n  if(caves[x][y]!=0)return false;\n  return true;\n}\n\n\nint main(void) {\n  int i,j;\n  int dx[4]={0,1,0,-1};\n  int dy[4]={1,0,-1,0};\n  int cnt=1004*1004;\n  i=0,j=0;\n  int k=0;\n  while(cnt>0){\n    caves[i][j]=cnt;\n    if(!in(i+dx[k%4],j+dy[k%4]))k++;\n    i=i+dx[k%4];\n    j=j+dy[k%4];\n    cnt--;\n  }\n\n  int max_n=1000005;\n  vector<bool> prime(max_n,true);\n  prime[0]=prime[1]=false;\n  rep(i,max_n)if(prime[i]){\n    for(j=2;i*j<max_n;j++)prime[i*j]=false;\n  }\n\n  int m,n;\n  while(1){\n    cin>>m>>n;\n    if(m==0)break;\n    rep(i,1004)rep(j,1004)dp1[i][j]=dp2[i][j]=reached[i][j]=0;\n    int sx,sy;\n    rep(i,1004)rep(j,1004)if(caves[i][j]==n)sx=i,sy=j;\n    if(prime[n])dp1[sx][sy]=1,dp2[sx][sy]=n;\n    reached[sx][sy]=1;\n    int ans1=0,ans2=0;\n    for(i=sx+1;i<1004;i++)rep(j,1004){\n\tvector< pair<int,pii> > p;\n\tint k;\n\tint d[3]={-1,0,1};\n\trep(k,3)\n\t  p.push_back(pair<int,pii>(reached[i-1][j+d[k]],pii(dp1[i-1][j+d[k]],dp2[i-1][j+d[k]])));\n\tsort(all(p));\n\tif(p[2].first==0)continue;\n\tif(caves[i][j]>m){//洞穴を全部見終わったとき\n\t  if(ans1<p[2].second.first || (ans1==p[2].second.first && ans2>p[2].second.second)){\n\t    ans1=p[2].second.first;\n\t    ans2=p[2].second.second;\n\t  }\n\t}else{//遷移するとき\n\t  reached[i][j]=1;\n\t  if(prime[caves[i][j]]){\n\t    dp1[i][j]=p[2].second.first+1;//素数の個数\n\t    dp2[i][j]=caves[i][j];//一番最後の素数\n\t    //\t    cout<<caves[i][j]<<\" \"<<dp1[i][j]<<\" \"<<dp2[i][j]<<endl;\n\t  }else{\n\t    dp1[i][j]=p[2].second.first;\n\t    dp2[i][j]=p[2].second.second;\n\t  }\n\t}\n      }\n  END:cout<<ans1<<\" \"<<ans2<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\nusing namespace std;\n#define N 1000\n#define N2 N*N\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nbool prime[N2+1];\nint cave[N+1][N+1]={};\npair<int,int> dp[N+1][N+1];\nint m,n;\n\npair<int,int> rec(int x,int y){\n    if(dp[x][y].first)return dp[x][y];\n    if(y==0 || x==0 || x==N+1 || cave[x][y]>m)return pair<int,int>(0,0);\n    pair<int,int> child[3];\n    child[0]=rec(x-1,y-1);\n    child[1]=rec(x,y-1);\n    child[2]=rec(x+1,y-1);\n    sort(child,child+3);\n    if(child[2].first==0 && prime[cave[x][y]])return dp[x][y]=pair<int,int>(1,cave[x][y]);\n    if(prime[cave[x][y]])child[2].first++;\n    return dp[x][y]=child[2];\n}\n\nint main(void){\n    fill(prime,prime+N2+1,true);\n    prime[0]=prime[1]=false;\n    for(int i=2;i<=N2;i++){\n        if(!prime[i])continue;\n        for(int k=2;i*k<=N2;k++)prime[i*k]=false;\n    }\n\n    int x=1,y=N,d=0;\n    pair<int,int> locate[N2+1];\n    for(int i=N2;i>0;i--){\n        cave[x][y]=i;\n        locate[i] = pair<int,int>(x,y);\n        int nextX=x+dx[d],nextY=y+dy[d];\n        if(nextX==0 || nextX==N+1 || nextY==0 || nextY==N+1 || cave[nextX][nextY])d=(d+1)%4;\n        x+=dx[d];\n        y+=dy[d];\n    }\n\n\n    while(cin>>m>>n, m|n){\n        rep1(i,N)rep1(j,N)dp[i][j].first=dp[i][j].second=0;\n        pair<int,int> tmp=rec(locate[n].first,locate[n].second);\n        cout<<tmp.first<<\" \"<<tmp.second<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint grid[1100][1100], cnt[1000105];\npii dp[1100][1100], pos[1002020];\n\nvoid rec(int cx, int cy, int m){\n    int val = grid[cx][cy];\n    if(m<grid[cx+1][cy-1] && m<grid[cx+1][cy] && m<grid[cx+1][cy+1]){\n        if(cnt[val]==0) dp[cx][cy].first = 1, dp[cx][cy].second = val;\n        else dp[cx][cy].first = 0;\n        return;\n    }\n    if(dp[cx][cy].first>-1) return;\n    for(int i=cy-1;i<=cy+1;i++){\n        if(grid[cx+1][i]<=m){\n            rec(cx+1, i, m);\n            if(dp[cx][cy].first<dp[cx+1][i].first){\n                dp[cx][cy].first = dp[cx+1][i].first;\n                dp[cx][cy].second = dp[cx+1][i].second;\n            }\n            else if(dp[cx][cy].first==dp[cx+1][i].first){\n                dp[cx][cy].second = max(dp[cx][cy].second, dp[cx+1][i].second);\n            }\n        }\n    }\n\n    if(cnt[val]==0){\n        dp[cx][cy].first++;\n        if(dp[cx][cy].second==0) dp[cx][cy].second = val;\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(false), cin.tie(nullptr);\n    for(int i=0;i<1100;i++) for(int j=0;j<1100;j++) grid[i][j] = 2000000;\n    int cur = 2, x = 505, y =505, size = 1;\n    grid[x][y] = 1;\n    pos[1].first = x, pos[1].second = y;\n    while(cur<=1000000){\n        y++; size += 2;\n        for(int i=0;i<size-1;i++) {\n            grid[x-i][y] = cur, pos[cur].first = x - i, pos[cur].second = y, cur++;\n        }\n        x -= size - 2; y--;\n        for(int i=0;i<size-1;i++) {\n            grid[x][y-i] = cur, pos[cur].first = x, pos[cur].second = y - i, cur++;\n        }\n        y -= size - 2; x++;\n        for(int i=0;i<size-1;i++) {\n            grid[x+i][y] = cur, pos[cur].first = x + i, pos[cur].second = y, cur++;\n        }\n        x += size - 2; y++;\n        for(int i=0;i<size-1;i++) {\n            grid[x][y+i] = cur, pos[cur].first = x, pos[cur].second = y + i, cur++;\n        }\n        y += size - 2;\n    }\n    cnt[0] = cnt[1] = 1;\n    for(int i=2;i<=1000000;i++){\n        if(cnt[i]) continue;\n        for(int j=2*i;j<=1000000;j+=i) cnt[j]++;\n    }\n\n    int N, M;\n    while(true){\n        scanf(\"%d%d\", &M, &N);\n        if(M==0) return 0;\n        for(int i=1;i<=M;i++){\n            int cx = pos[i].first, cy = pos[i].second;\n            dp[cx][cy].first = -1;\n            dp[cx][cy].second = 0;\n        }\n        int nx = pos[N].first, ny = pos[N].second;\n        rec(nx, ny, M);\n        printf(\"%d %d\\n\", dp[nx][ny].first, dp[nx][ny].second);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nusing namespace std;\n  \n#define MP make_pair\n#define PB push_back\n#define MAX_N 2001000\n#define SIZE 2000\n#define X first\n#define Y second\n  \nconst int STX = 1000, STY = 1000;\n  \nint id[SIZE][SIZE];\nbool is_prime[MAX_N+1];\nvector<pair<int, int> > coord;\n\nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++) {\n    if(is_prime[i]) {\n      for(int j=i*i; j<=MAX_N; j+=i) {\n\tis_prime[j] = false;\n      }\n    }\n  }\n}\n\nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  \n  coord.PB(MP(0, 0)); // no use\n  cnt ++;\n  coord.PB(MP(x, y)); // cnt = 1\n  \n  fill(id[0], id[0]+SIZE*SIZE+1, -1);\n  \n  const int dx[] = {0,-1,0,1};\n  const int dy[] = {-1,0,1,0};\n  \n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt <= MAX_N) {\n    a += 2;\n    for(int turn=0; turn<4; turn++) {\n      for(int i=0; i<a; i++) {\n\tx += dx[turn], y += dy[turn];\n\tcoord.PB(MP(x, y));\n\tid[y][x] = ++ cnt;\n      }\n    }\n    x++, y++;\n  }\n}\n\nint dp[MAX_N+1];\n\nint main() {\n  \n  Sieve();\n  MakeMap();\n  \n  int m, n;\n\n  while(cin >> m >> n && (m|n)) {\n    \n    //bool ok = false;\n    \n    fill(dp, dp+MAX_N+1, -1);\n    dp[n] = is_prime[n];\n    pair<int, int> ans(dp[n], n);\n    \n    queue<pair<int, int> > que;\n    que.push(coord[n]);\n    queue<int> q_dp;\n    q_dp.push(dp[n]);\n    while(!que.empty()) {\n      pair<int, int> now = que.front(); que.pop();\n      int tmp = q_dp.front(); q_dp.pop();\n      int tmpid = id[now.Y][now.X];\n      if(tmp < dp[tmpid]) continue;\n      \n      int noid = id[now.Y][now.X];\n      \n      for(int i=-1; i<=1; i++) {\n\tpair<int, int> nex = MP(now.X+i, now.Y+1);\n\tif(nex.X < 0 || SIZE <= nex.X || nex.Y < 0 || SIZE <= nex.Y) continue;\n\tint neid = id[nex.Y][nex.X];\n\tif(neid <= m) {\n\t  if(dp[neid] < dp[noid] + is_prime[neid]) {\n\t    dp[neid] = dp[noid] + is_prime[neid];\n\t    //if(is_prime[neid]) ok = true;\n\t    ans = max(ans, make_pair(dp[neid], neid));\n\t    que.push(nex);\n\t    q_dp.push(dp[neid]);\n\t  }\n\t}\n      }\n\n    }\n    \n    /*\n    int res = dp[n], lastid = -1;\n    if(is_prime[n]) lastid = n;\n    \n    for(int i=1; i<=m; i++) {\n      if(res <= dp[i] && is_prime[i]) {\n\tres = dp[i];\n\tlastid = max(lastid, i);\n      }\n    }\n    */\n    if(ans.first == 0) cout << \"0 0\" << endl;\n    else {\n      int ans2 = 2;\n      cout << ans.first << \" \";\n      for(int i=1; i<=m; i++) {\n\tif(ans.first == dp[i] && is_prime[i]) {\n\t  ans2 = max(ans2, i);\n\t}\n      }\n      cout << ans2 << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nconst int P_MAX=1000000;\nbool er[P_MAX+1];\nvoid sieve(){\n\trep(i,P_MAX+1) er[i]=(i>=2);\n\tfor(int i=2;i*i<=P_MAX;i++) if(er[i]) for(int j=i*i;j<=P_MAX;j+=i) er[j]=false;\n}\n\nint main(){\n\tsieve();\n\n\tstatic int B[1200][1200];\n\tmemset(B,-1,sizeof B);\n\tint x=600,y=600;\n\tB[y][x]=1;\n\tfor(int cnt=2,d=1;cnt<=1000000;){\n\t\trep(i,d) B[y+=dy[0]][x+=dx[0]]=cnt++;\n\t\trep(i,d) B[y+=dy[1]][x+=dx[1]]=cnt++;\n\t\td++;\n\t\trep(i,d) B[y+=dy[2]][x+=dx[2]]=cnt++;\n\t\trep(i,d) B[y+=dy[3]][x+=dx[3]]=cnt++;\n\t\td++;\n\t}\n\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tstatic int dp[1200][1200];\n\t\tmemset(dp,-1,sizeof dp);\n\t\trep(i,1200) rep(j,1200) if(B[i][j]==m) dp[i][j]=(er[B[i][j]]?1:0);\n\t\tfor(int i=1;i<1200;i++) for(int j=1;j<1199;j++) if(B[i][j]!=-1 && B[i][j]<=n) {\n\t\t\tif(dp[i-1][j-1]!=-1) dp[i][j]=max(dp[i][j],dp[i-1][j-1]+(er[B[i][j]]?1:0));\n\t\t\tif(dp[i-1][j+0]!=-1) dp[i][j]=max(dp[i][j],dp[i-1][j+0]+(er[B[i][j]]?1:0));\n\t\t\tif(dp[i-1][j+1]!=-1) dp[i][j]=max(dp[i][j],dp[i-1][j+1]+(er[B[i][j]]?1:0));\n\t\t}\n\n\t\tint ans1=0,ans2=0;\n\t\trep(i,1200) rep(j,1200) if(ans1<dp[i][j] || (ans1==dp[i][j] && ans2<B[i][j] && er[B[i][j]])) ans1=dp[i][j], ans2=B[i][j];\n\t\tprintf(\"%d %d\\n\",ans1,ans2);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint map[1001][1000], dp[1001][1000], dp2[1001][1000], sosu[1000001];\nint y[] = { 0, -1, 0, 1 }, x[] = { 1, 0, -1, 0 }, maxh, maxw, minh, minw, ansH, ansW;\nint m, n;\n\nvoid hantei(int h, int w) {\n\tmaxh = max(maxh, h);\n\tmaxw = max(maxw, w);\n\tminh = min(minh, h);\n\tminw = min(minw, w);\n}\n\nvoid setMap() {\n\tint h = 500, w = 500, muki = 0, ansH = 500, ansW = 500;\n\tmap[h][w] = 1;\n\tfor (int i = 2; i <= m; i++) {\n\t\tif (map[h + y[muki]][w+x[muki]] <= 0) {\n\t\t\thantei(h+y[muki], w+x[muki]);\n\t\t\tmap[h + y[muki]][w+x[muki]] = i;//????????£????????????\n\t\t\th += y[muki];\n\t\t\tw += x[muki];\n\t\t\tif (map[h][w] == n) {\n\t\t\t\tansH = h;\n\t\t\t\tansW = w;\n\t\t\t}\n\t\t\tmuki = (muki + 1) % 4;\n\t\t}\n\t\telse {\n\t\t\tif (muki - 1 >= 0) {\n\t\t\t\tmap[h + y[muki-1]][w + x[muki-1]] = i;//\n\t\t\t\th += y[muki - 1];\n\t\t\t\tw += x[muki - 1];\n\t\t\t\tif (map[h][w] == n) {\n\t\t\t\t\tansH = h;\n\t\t\t\t\tansW = w;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmap[h + y[3]][w + x[3]] = i;//\n\t\t\t\th += y[3];\n\t\t\t\tw += x[3];\n\t\t\t\tif (map[h][w] == n) {\n\t\t\t\t\tansH = h;\n\t\t\t\t\tansW = w;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid eratosthenes() {\n\tsosu[0] = 1;\n\tsosu[1] = 1;\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tif (sosu[i] == 0) {\n\t\t\tfor (int j = 2; j*i <= 1000000; j++) {\n\t\t\t\tsosu[j*i]++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid DP() {\n\tfor (int i = maxh; i >= minh; i--) {\n\t\tfor (int j = maxw; j >= minw; j--) {\n\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\tif (minw <= j + k && maxw >= j + k) {\n\t\t\t\t\tif (dp[i][j] < dp[i + 1][j + k]) {\n\t\t\t\t\t\tdp[i][j] = dp[i + 1][j + k];\n\t\t\t\t\t\tdp2[i][j] = dp2[i + 1][j + k];\n\t\t\t\t\t\t//printf(\"a1\\t\");\n\t\t\t\t\t}\n\t\t\t\t\telse if (dp[i][j] == dp[i + 1][j + k] && dp2[i][j] < dp2[i + 1][j + k]) {\n\t\t\t\t\t\tdp2[i][j] = dp2[i + 1][j + k];\n\t\t\t\t\t\t//printf(\"a2\\t\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sosu[map[i][j]] == 0) {//???????¶??????????????????¨?????????????????£????????????????????????\n\t\t\t\t//printf(\"a3\\t\");\n\t\t\t\tdp[i][j]++;\n\t\t\t\tif (dp[i][j] == 1) {\n\t\t\t\t\tdp2[i][j] = map[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tvector<int>v,v2;\n\teratosthenes();\n\n\twhile (cin >> m >> n, m || n) {\n\t\tmaxh = 0, maxw = 0, minh = 9999999, minw = 9999999;\n\t\tfor (int i = 0; i < 1001;i++) {\n\t\t\tfor (int j = 0; j < 1000;j++) {\n\t\t\t\tmap[i][j] = 0;\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tdp2[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tsetMap();\n\t\tDP();\n\t\tv.push_back(dp[ansH][ansW]);\n\t\tv2.push_back(dp2[ansH][ansW]);\n\t\t\n\t}\n\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tcout << v.at(i) << \" \" << v2.at(i) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <numeric>\n#include <functional>\n#include <cctype>\n#include <list>\n#include <limits>\n#include <cassert>\n//#include <boost/multiprecision/cpp_int.hpp>\n\n\n\nusing namespace std;\nusing Int = long long;\n//using namespace boost::multiprecision;\n\nconst double EPS = 1e-10;\nlong long const MOD = 1000000007;\n\nlong long mod_pow(long long x, long long n) {\n    long long res = 1;\n    for(int i = 0;i < 60; i++){\n        if(n >> i & 1) res = res * x % MOD;\n        x = x * x % MOD;\n    }\n    return res;\n}\n\ntemplate<typename T>\nT gcd(T a, T b) {\n    return b != 0 ? gcd(b, a % b) : a;\n}\n\ntemplate<typename T>\nT lcm(T a, T b) {\n    return a * b / gcd(a, b);\n}\n\nvoid fastInput() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n}\n\nvector<int> erat(int n) {\n    vector<int> primes(n);\n    for (int i = 2; i < n; ++i) primes[i] = i;\n    for (int i = 2; i*i < n; ++i)\n        if (primes[i])\n            for (int j = i*i; j < n; j+=i) primes[j] = 0;\n    // 素数のみをvectorに格納する場合は以下の行を追加 (0 である要素を全削除)\n    // primes.erase(remove(primes.begin(), primes.end(), 0), primes.end());\n    return primes;\n}\n\npair<int, int> makeField(vector<vector<int>> &field, int M, int N) {\n    pair<int, int> ret = {1000, 1000};\n    field[1000][1000] = 1;\n    int cnt = 2;\n    int dx[] = {0, 1, 0, -1};\n    int dy[] = {1, 0, -1, 0};\n    int crtX = 1001;\n    int crtY = 1000;\n    int crtDir = 1;\n    while (cnt <= M) {\n        field[crtX][crtY] = cnt;\n        if (cnt == N) ret = {crtX, crtY};\n        if (field[crtX + dx[(crtDir - 1 + 4) % 4]][crtY + dy[(crtDir - 1 + 4) % 4]] == 0) {\n            crtDir = (crtDir - 1 + 4) % 4;\n        }\n        crtX += dx[crtDir];\n        crtY += dy[crtDir];\n        cnt++;\n    }\n    return ret;\n}\n\nvector<vector<int>> v;\n\nint backTrack(int crtX, int crtY, vector<vector<int>> &field, vector<vector<int>> &dp, vector<int> &primes) {\n    if (v[crtX][crtY] == 1) return 0;\n    v[crtX][crtY] = 1;\n    int ret = 0;\n    int cnt = 0;\n    if (primes[field[crtX][crtY]]) cnt = 1;\n    if (dp[crtX][crtY] == 1 && dp[crtX-1][crtY-1] == 0 && dp[crtX][crtY-1] == 0 && dp[crtX+1][crtY-1] == 0) return field[crtX][crtY];\n\n    if (dp[crtX][crtY] - cnt == dp[crtX-1][crtY-1]) ret = max(ret, backTrack(crtX-1, crtY-1, field, dp, primes));\n    if (dp[crtX][crtY] - cnt == dp[crtX][crtY-1]) ret = max(ret, backTrack(crtX, crtY-1, field, dp, primes));\n    if (dp[crtX][crtY] - cnt == dp[crtX+1][crtY-1]) ret = max(ret, backTrack(crtX+1, crtY-1, field, dp, primes));\n    return ret;\n    \n}\n\nint dfs(int crtX, int crtY, vector<vector<int>> &field, vector<vector<int>> &dp, vector<int> &primes) {\n    if (dp[crtX][crtY] != -1) return dp[crtX][crtY];\n    if (field[crtX][crtY] == 0) return dp[crtX][crtY] = 0;\n    int ret = 0;\n    if (primes[field[crtX][crtY]]) ret += 1;\n    int ma = 0;\n    ma = max(ma, dfs(crtX-1, crtY-1, field, dp, primes));\n    ma = max(ma, dfs(crtX, crtY-1, field, dp, primes));\n    ma = max(ma, dfs(crtX+1, crtY-1, field, dp, primes));\n    ret += ma;\n    dp[crtX][crtY] = max(dp[crtX][crtY], ret);\n    return dp[crtX][crtY];\n}\n\npair<int, int> solve(int M, int N) {\n    vector<vector<int>> field(2000, vector<int>(2000));\n    vector<vector<int>> dp(2000, vector<int>(2000, -1));\n    v = vector<vector<int>> (2000, vector<int>(2000));\n    // center = {1000, 1000};\n\n    pair<int, int> start = makeField(field, M, N);\n    vector<int> primes = erat(M+1);\n    pair<int, int> ret = {0, 0};\n    ret.first = dfs(start.first, start.second, field, dp, primes);\n    ret.second = backTrack(start.first, start.second, field, dp, primes);\n    return ret;\n}\n\nint main(void) {\n    int M, N;\n    vector<pair<int, int>> ans;\n    while (1) {\n        cin >> M >> N;\n        if (!M && !N) break;\n        ans.push_back(solve(M, N));\n    }\n    for (auto &i : ans) {\n        cout << i.first << \" \" << i.second << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\nusing namespace std;\n#define MAX 1000005\nint F[MAX]={0},i,j,p=0,N,M,C[1005][1005],pos[MAX][2],dp[MAX],t,nc;\ntypedef struct D{int c,np,now;}D;\n\nvoid set(int n,int y,int x){C[y][x]=n;pos[n][0]=y;pos[n][1]=x;}\n\nvoid vortex()\n{\n\tint i,j,pre,nx,ny,mv[5]={-1,0,1,0,-1};\n\tmemset(C,0x7f,sizeof(C));\n\tnx=1005/2;ny=1005/2;\n\tset(1,ny,nx);\n\tnx++;\n\tset(2,ny,nx);\n\tfor(i=3,pre=i-1;i<MAX;pre=i++)\n\t{\n\t\tfor(j=0;j<4;j++)\n\t\t{\n\t\t\tif(C[ny+mv[j]][nx+mv[j+1]]==pre-1)\n\t\t\t\tbreak;\n\t\t}\n\t\tfor(;C[ny+mv[j]][nx+mv[j+1]]<MAX;)\n\t\t\tj=(j+1)%4;\n\t\tny+=mv[j];\n\t\tnx+=mv[j+1];\n\t\tset(i,ny,nx);\n\t}\n}\n\nint main()\n{\n\tfor(i=2;i<MAX;i++)\n\t\tif(!F[i])\n\t\t{\n\t\t\tfor(j=i*2;j<MAX;j+=i)\n\t\t\t\tF[j]=1;\n\t\t}\n\tvortex();\n\tfor(;scanf(\"%d%d\",&M,&N),N+M;)\n\t{\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tqueue<D>Q;\n\t\tD tmp={!F[N],(!F[N])?N:0,N},r=tmp;\n\t\tQ.push(tmp);\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\ttmp=Q.front();Q.pop();\n\t\t\tif(r.c<tmp.c||(tmp.c==r.c&&tmp.np>r.np))\n\t\t\t\tr=tmp;\n\t\t\tif(tmp.c<dp[tmp.np])continue;\n\t\t\tdp[tmp.now]=tmp.c;\n\t\t\tfor(i=-1;i<2;i++)\n\t\t\t{\n\t\t\t\tt=C[pos[tmp.now][0]+1][pos[tmp.now][1]+i];\n\t\t\t\tif(t<=M&&dp[t]<tmp.c+(!F[t]))\n\t\t\t\t{\n\t\t\t\t\tD ins={tmp.c+(!F[t]),!F[t]&&t>tmp.np?t:tmp.np,t};\n\t\t\t\t\tdp[t]=ins.c;\n\t\t\t\t\tQ.push(ins);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",r.c,r.np);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n#define t_max 10000001\nchar M[1001][1001];\nint S[1001][1001];\nint P[1001][1001];\nint table[t_max];\nvector<pair<int,int> >m(t_max);\nmap<pair<int,int>,int>m_rev;\npair<int,int> dfs(int x,int y){\n\tif(y==1001)return make_pair(0,0);\n\tif(S[x][y]>=0)return make_pair(S[x][y],P[x][y]);\n\tint m=0,m_place=0,i=-1;\n\tfor(;i<2;i++){\n\t\tif(x+i<0||1000<x+i)continue;\n\t\tpair<int,int> p=dfs(x+i,y+1);\n\t\tif(m<p.first||(m==p.first&&m_place<p.second))m=p.first,m_place=p.second;\n\t}\n\tif(m==0){\n\t\tif(M[x][y])return make_pair(S[x][y]=1,P[x][y]=m_rev[make_pair(x,y)]);\n\t\treturn make_pair(S[x][y]=0,P[x][y]=0);\n\t}else{\n\t\treturn make_pair(S[x][y]=m+M[x][y],P[x][y]=m_place);\n\t}\n}\nmain(){\n\tint k=1,z,x,y,i,n,s;\n\tm[k]=make_pair(x=500,y=500),m_rev[make_pair(x,y)]=k,k++;\n\tfor(z=2;z<=1000;z+=2){\n\t\tx++,y++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(x,--y),m_rev[make_pair(x,y)]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(--x,y),m_rev[make_pair(x,y)]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(x,++y),m_rev[make_pair(x,y)]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(++x,y),m_rev[make_pair(x,y)]=k,k++;\n\t}\n\ttable[0]=table[1]=1;\n\tfor(x=2;x<t_max;x++)if(!table[x])for(y=x*2;y<t_max;y+=x)table[y]=1;\n\tfor(;scanf(\"%d%d\",&n,&s),n;){\n\t\tmemset(M,0,sizeof(M));\n\t\tmemset(S,0xff,sizeof(S));\n\t\tmemset(P,0,sizeof(P));\n\t\tfor(i=1;i<=n;i++)if(!table[i])M[m[i].first][m[i].second]=1;\n\t\tpair<int,int> p=dfs(m[s].first,m[s].second);\n\t\tprintf(\"%d %d\\n\",p.first,p.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n#define MAX_N 1010010\nbool prime[MAX_N];\nint dp[1210][1210];\npii tmp[1210][1210];\nint pos[1210][1210];\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\nvoid mainmain(){\n\trep(i,MAX_N){\n\t\tprime[i]=true;\n\t}\n\tprime[0]=prime[1]=false;\n\tfor(int i=2;i*i<=MAX_N;++i){\n\t\tif(prime[i]){\n\t\t\tfor(int j=i*i;j<MAX_N;j+=i){\n\t\t\t\tprime[j]=false;\n\t\t\t}\n\t\t}\n\t}\n\tint cnt=0;\n\tint x=601,y=600;\n\tpos[600][600]=1;\n\tdp[600][600]=0;\n\treep(i,2,1000010){\n\t\t// if(i<20) cout<<y-500<<\" \"<<x-500<<\" \"<<i<<endl;\n\t\tint t=sqrt(i);\n\t\t// if(t*t==i) cout<<i<<\" \"<<y<<\" \"<<x<<endl;\n\t\tpos[y][x]=i;\n\t\tif(prime[i]) dp[y][x]=1;\n\t\telse dp[y][x]=0;\n\t\tint next=(cnt+1)%4;\n\t\tif(pos[y+dy[next]][x+dx[next]]==0){\n\t\t\tcnt=next;\n\t\t}\n\t\tx+=dx[cnt];\n\t\ty+=dy[cnt];\n\t}\n\t// reep(i,490,510){\n\t\t// reep(j,490,510){\n\t\t\t// printf(\"%6d \",dp[i][j]);\n\t\t// }\n\t\t// cout<<endl;\n\t// }\n\n\tint n,m;\n\twhile(cin>>m>>n,n||m){\n\t\trep(i,1210){\n\t\t\trep(j,1210){\n\t\t\t\tif(pos[i][j]<=m){\n\t\t\t\t\ttmp[i][j].F=dp[i][j];\n\t\t\t\t}\n\t\t\t\telse tmp[i][j].F=0;\n\t\t\t\tif(tmp[i][j].F==1) tmp[i][j].S=pos[i][j];\n\t\t\t\telse tmp[i][j].S=-1;\n\t\t\t}\n\t\t}\n\t\treep(i,1,1210){\n\t\t\trep(j,1210){\n\t\t\t\tif(j==0){\n\t\t\t\t\ttmp[1210-1-i][j]=max(tmp[1210-i][0],tmp[1210-i][1]);\n\t\t\t\t}\n\t\t\t\telse if(j==1209){\n\t\t\t\t\ttmp[1210-1-i][j]=max(tmp[1210-i][1208],tmp[1210-i][1209]);\n\t\t\t\t}\n\t\t\t\telse tmp[1210-1-i][j]=max(max(tmp[1210-i][j-1],tmp[1210-i][j]),tmp[1210-i][j+1]);\n\t\t\t\tif(prime[pos[1210-1-i][j]]&&pos[1210-1-i][j]<=m){\n\t\t\t\t\ttmp[1210-1-i][j].F++;\n\t\t\t\t\tif(tmp[1210-1-i][j].F==1){\n\t\t\t\t\t\ttmp[1210-1-i][j].S=pos[1210-1-i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(pos[i][j]==n){\n\t\t\t\t\ty=i;\n\t\t\t\t\tx=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// cout<<y<<\" \"<<x<<endl;\n\t\tif(tmp[y][x].S<0) cout<<0<<\" \"<<0<<endl;\n\t\telse cout<<tmp[y][x].F<<\" \"<<tmp[y][x].S<<endl;\n\t}\n\t// cout<<max(mkp(1,2),mkp(2,1)).S<<endl;\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\n#define MP make_pair\n#define PB push_back\n#define MAX_N 1001000\n#define SIZE 1010\n#define X first\n#define Y second\n\nconst int STX = 501, STY = 501;\n\nint id[SIZE][SIZE];\nbool is_prime[MAX_N+1];\nvector<pair<int, int> > coord;\n\nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++) {\n    if(is_prime[i]) {\n      for(int j=i*i; j<=MAX_N; j+=i) {\n\tis_prime[j] = false;\n      }\n    }\n  }\n}\n\nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  /*\n  const int dx[] = {1,0,-1,0};\n  const int dy[] = {0,-1,0,1};\n  */\n  coord.PB(MP(0, 0)); // no use\n  coord.PB(MP(x, y)); // cnt = 1\n  cnt ++;\n\n  fill(id[0], id[0]+SIZE*SIZE+1, -1);\n  \n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt <= MAX_N) {\n    a += 2;\n    for(int i=0; i<a; i++) {\n      y --;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      x --;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      y ++;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      x ++;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    x++, y++;\n  }\n}\n\nint dp[MAX_N+1];\n\nint main() {\n  \n  Sieve();\n  MakeMap();\n  \n  int m, n;\n  \n  while(cin >> m >> n && (m|n)) {\n    fill(dp, dp+m+1, -1);\n    dp[n] = is_prime[n];\n    \n    queue<pair<int, int> > que;\n    que.push(coord[n]);\n    \n    while(!que.empty()) {\n      pair<int, int> now = que.front(); que.pop();\n      int noid = id[now.Y][now.X];\n      \n      for(int i=-1; i<=1; i++) {\n\tpair<int, int> nex = MP(now.X+i, now.Y+1);\n\tif(nex.X < 0 || SIZE <= nex.X || nex.Y < 0 || SIZE <= nex.Y) continue;\n\tint neid = id[nex.Y][nex.X];\n\tif(neid <= m) {\n\t  if(dp[neid] < dp[noid] + is_prime[neid]) {\n\t    dp[neid] = dp[noid] + is_prime[neid];\n\t    que.push(nex);\n\t  }\n\t}\n      }\n    }\n    \n    int res = dp[n], lastid = -1;\n    if(is_prime[n]) lastid = n;\n    \n    for(int i=1; i<=m; i++) {\n      if(res <= dp[i] && is_prime[i]) {\n\tres = dp[i];\n\tlastid = max(lastid, i);\n      }\n    }\n    \n    if(lastid == -1) cout << \"0 0\" << endl;\n    else cout << res << \" \" << lastid << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint prime[1100000];\nint table[1200][1200];\npair<int,int> dp[1200][1200];\nint dx[]={0,-1,0,1};\nint dy[]={1,0,-1,0};\nint main(){\n\tint a,b;\n\tprime[0]=prime[1]=-1;\n\tfor(int i=2;i<1100000;i++){\n\t\tif(~prime[i]){\n\t\t\tprime[i]=1;\n\t\t\tfor(int j=i+i;j<1100000;j+=i)prime[j]=-1;\n\t\t}\n\t}\n\t\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tint sr;\n\t\tint sc;\n\t\tint at=0;\n\t\tint dir=0;\n\t\tint row=600;\n\t\tint col=600;\n\t\tfor(int i=0;i<1200;i++)\n\t\t\tfor(int j=0;j<1200;j++){\n\t\t\t\ttable[i][j]=0;\n\t\t\t\tdp[i][j]=make_pair(-99999,-99999);\n\t\t\t}\n\t\tfor(int i=0;i<a;i++){\n\t\t\ttable[row][col]=i+1;\n\t\t\tif(b==i+1){\n\t\t\t\tsr=row;\n\t\t\t\tsc=col;\n\t\t\t}\n\t\t\trow+=dx[dir%4];\n\t\t\tcol+=dy[dir%4];\n\t\t\tat++;\n\t\t\tif(at==dir/2+1){\n\t\t\t\tdir++;\n\t\t\t\tat=0;\n\t\t\t}\n\t\t}\n\t\tdp[sr][sc]=make_pair(0,0);\n\t\tif(~prime[table[sr][sc]])dp[sr][sc]=make_pair(1,table[sr][sc]);\n\t\tpair<int,int>ret=dp[sr][sc];\n\t\tfor(int i=1;i<1199;i++){\n\t\t\tfor(int j=1;j<1199;j++){\n\t\t\t\tret=max(ret,dp[i][j]);\n\t\t\t\tif(dp[i][j].first<0)continue;\n\t\t\t\tif(~prime[table[i+1][j-1]]){\n\t\t\t\t\tdp[i+1][j-1]=max(dp[i+1][j-1],make_pair(dp[i][j].first+1,table[i+1][j-1]));\n\t\t\t\t}else{\n\t\t\t\t\tdp[i+1][j-1]=max(dp[i+1][j-1],dp[i][j]);\n\t\t\t\t}\n\t\t\t\tif(~prime[table[i+1][j]]){\n\t\t\t\t\tdp[i+1][j]=max(dp[i+1][j],make_pair(dp[i][j].first+1,table[i+1][j]));\n\t\t\t\t}else{\n\t\t\t\t\tdp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n\t\t\t\t}\n\t\t\t\tif(~prime[table[i+1][j+1]]){\n\t\t\t\t\tdp[i+1][j+1]=max(dp[i+1][j+1],make_pair(dp[i][j].first+1,table[i+1][j+1]));\n\t\t\t\t}else{\n\t\t\t\t\tdp[i+1][j+1]=max(dp[i+1][j+1],dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",ret.first,ret.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\n    //エラトステネスの篩\n    vector<bool> prime(1000010, true);     //1000000までで、素数ならtrue\n    prime[0] = prime[1] = false;\n    for(int i = 2; i < 1000010; i++){\n        if(prime[i] == true){\n            for(int j = 2*i; j < 1000010; j += i){\n                prime[j] = false;\n            }\n        }\n    }\n\n    map<pair<int, int>, int> M;\n    map<int, pair<int, int> > _M;\n    int num = 1;\n    int T = 1;\n    M[{0, 0}] = num;\n    _M[num] = {0, 0};\n    num++;\n    int i = 0;\n    int j = 0;\n\n    while(num < 1000010){\n\n        j++;\n        M[{i, j}] = num;\n        _M[num] = {i, j};\n        num++;\n        for(int r = 0; r < T; r++){\n            i--;\n            M[{i, j}] = num;\n            _M[num] = {i, j};        \n            num++;\n        }\n\n        j--;\n        M[{i, j}] = num;\n        _M[num] = {i, j};\n        \n        num++;\n        for(int r = 0; r < T; r++){\n            j--;\n            M[{i, j}] = num;\n            _M[num] = {i, j};        \n            num++;\n        }\n\n        i++;\n        M[{i, j}] = num;\n        _M[num] = {i, j};\n        \n        num++;\n        for(int r = 0; r < T; r++){\n            i++;\n            M[{i, j}] = num;\n            _M[num] = {i, j};\n            \n            num++;\n        }\n\n        j++;\n        M[{i, j}] = num;\n        _M[num] = {i, j};\n        \n        num++;\n        for(int r = 0; r < T; r++){\n            j++;\n            M[{i, j}] = num;\n            _M[num] = {i, j};\n            \n            num++;\n        }\n\n        T += 2;\n    }\n\n    /*for(int i = -10; i <= 10; i++){\n        for(int j = -10; j <= 10; j++){\n            printf(\"%.2d \", M[{i, j}]);\n        }\n        cout << endl;\n    }*/\n    \n\n    while(1){\n        int m, n; cin >> m >> n;\n        if(n == 0) break;    \n\n        //幅優先\n        map<pair<int, int>, int> dp;\n        queue<pair<int, int> > que;\n        int si = _M[n].first;\n        int sj = _M[n].second;\n        que.push({si, sj});\n        dp[{si, sj}] = prime[n] ? 1 : 0;\n    \n        int ans1 = 0;\n        int ans2 = 0;\n\n        while(!que.empty()){\n\n            int i = que.front().first;\n            int j = que.front().second;\n            //cout << i << \" \" << j << \" \" << dp[{i, j}] << endl;\n            if(dp[{i, j}] >= ans1 && prime[M[{i, j}]]){\n                ans1 = dp[{i, j}];\n                ans2 = M[{i, j}];\n            }\n\n            que.pop();\n\n            int ni = i + 1;\n            //3つ\n\n            for(int dj = -1; dj <= 1; dj++){\n                int nj = j + dj;\n                int next_num = M[{ni, nj}];\n                if(next_num > m || next_num == 0) continue;\n\n                int v = dp[{i, j}] + ((prime[next_num]) ? 1 : 0);\n                if(dp.find({ni, nj}) == dp.end() || v > dp[{ni, nj}]){\n                    dp[{ni, nj}] = v;\n                    que.push({ni, nj});\n                }\n            }\n            \n        }\n\n    cout << ans1 << \" \" << ans2 << endl;\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\nint dy[]={0,-1, 0, 1};\nint dx[]={-1,0, 1, 0};\n\nstruct aaa{\n    int maxi;\n    int prime;\n};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nint hole[1000][1000],m,n;\nbool isp[1000001];\naaa memo[1003][1000];\n\naaa search(int y,int x){\n    if(memo[y][x].maxi >= 0)\n        return memo[y][x];\n\n    if((y > 999) || hole[y][x] > m){\n        aaa ret;\n        memo[y][x].maxi = memo[y][x].prime = 0;\n        return memo[y][x];\n    }\n\n    aaa ret;ret.maxi = ret.prime = 0;\n\n    for(int i = x - 1;i < x + 2;i++){\n        if(i < 0 || i > 999)\n            continue;\n\n        aaa b = search(y + 1,i);\n        if(b.maxi > ret.maxi || (b.maxi == ret.maxi && b.prime > ret.maxi))\n            ret = b;\n    }\n    if(ret.prime == 0 && isp[hole[y][x]])\n        ret.prime = hole[y][x];\n    ret.maxi += isp[hole[y][x]];\n    return memo[y][x] = ret;\n}\n\nint main(){\n    int d = 2;int x = 0;int y = 0;\n    RFOR(i,1,1000001){\n        hole[y][x] = i;\n        if(x + dx[d] < 0 || x + dx[d] > 999  || y + dy[d] < 0 || y + dy[d] > 999 || hole[y + dy[d]][x + dx[d]] > 0){\n            d = (d + 1) % 4;\n        }\n\n        x += dx[d]; y += dy[d];\n    }\n\n    memset(isp,true,sizeof(isp));isp[1] = false;\n    FOR(i,2,10000){\n        if(isp[i]){\n            for(int j = i * 2;j < 1000001;j += i)\n                isp[j] = false;\n        }\n    }\n    while(1){\n        scanf(\"%d%d\",&m,&n);\n        if(m == 0 && n == 0)\n            break;\n\n        aaa ans;\n        REP(i,1003)\n            REP(j,1000)\n                memo[i][j].maxi = -1;\n\n        REP(i,1000){\n            REP(j,1000){\n                if(hole[i][j] == n)\n                    ans = search(i,j); \n            }\n        }\n        printf(\"%d %d\\n\",ans.maxi,ans.prime);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<LL,LL> P;\nconst LL LINF=1LL<<62;\nconst LL mod=1e9;\n\n\nconst int M_N=1000000;\nbool prime[M_N+1];\n \nvoid Sieve(){\n    int i,j;\n    prime[1]=false;\n    for (i=2;i*i<=M_N;i++){\n        if (prime[i]==true){\n            for (j=2;i*j<=M_N;j++){\n                prime[i*j]=false;\n            }\n        }\n    }\n}\n\nint a[4001][4001];\n\nvoid dfs(int i,int x,int y,int count,int sum){\n    if(i%2==0) count++;\n    for(int s=0;s<count;s++){\n        if(i%4==0) a[y][++x]=++sum;\n        if(i%4==1) a[--y][x]=++sum;\n        if(i%4==2) a[y][--x]=++sum;\n        if(i%4==3) a[++y][x]=++sum;\n        if(sum==1000000) return;\n    }\n    dfs((i+1)%4,x,y,count,sum);\n}\n\nvoid check(int *x,int *y,int n){\n    for(int i=-1000;i<=1000;i++){\n        for(int j=-1000;j<=1000;j++){\n            if(a[2000+i][2000+j]==n){\n                *y=i+2000;\n                *x=j+2000;\n                return;\n            }\n        }\n    }\n}\n\nint dp[4000][4000];\n\nint main(){\n    memset(prime,true,sizeof(prime));\n    Sieve();\n    int m,n;\n    a[2000][2000]=1;\n    dfs(0,2000,2000,0,1);\n    while(cin >> m >> n){\n        if(m==0&&n==0) return 0;\n        memset(dp,0,sizeof(dp));\n        int x,y;\n        check(&x,&y,n);\n        int c=1;\n        dp[y][x]=prime[a[y][x]];\n        int ans=dp[y][x],p=0;\n        if(ans>0) p=a[y][x];\n        for(int i=y;i<=y+1000;i++){\n            for(int j=-c+x;j<=x+c;j++){\n                if(a[i+1][j]==0||a[i+1][j]>m) continue;\n                dp[i+1][j]=max({dp[i][j-1],dp[i][j],dp[i][j+1]})+prime[a[i+1][j]];\n                if(ans<dp[i+1][j]){\n                    ans=dp[i+1][j];\n                    p=a[i+1][j];\n                }\n                else if(ans==dp[i+1][j]&&a[i+1][j]>p&&prime[a[i+1][j]]){\n                    p=a[i+1][j];\n                }\n            }\n            c++;\n        }\n        cout << ans <<\" \"<< p << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\n\nconst int N = 1000001;\nbool prime[N + 1];\nvector<int> primes;\n\nvoid hurui()\n{\n\tmemset(prime, true, sizeof(prime));\n\tprime[0] = prime[1] = false;\n\tfor (int i = 2; i*i < N; i++)\n\t{\n\t\tif (!prime[i]) continue;\n\t\tfor (int j = i; i*j < N; j++)\n\t\t{\n\t\t\tprime[i*j] = false;\n\t\t}\n\t}\n\tREP(i, N + 1)\n\t{\n\t\tif (prime[i]) primes.push_back(i);\n\t}\n}\n\nvector<vector<bool>> fld(1500, vector<bool>(1500));\nvector<vi> id(1500, vi(1500));\nvector<pii> place(1111111);\n\nvoid init()\n{\n\thurui();\n\tint x = 700, y = 700, tmp = 1;\n\tfor (int i = 1;; i++)\n\t{\n\t\tREP(j, i * 2 - 1)\n\t\t{\n\t\t\tif (tmp == 1111110) break;\n\t\t\tid[x][y] = tmp;\n\t\t\tplace[tmp] = pii(x, y);\n\t\t\ttmp++;\n\t\t\ty++;\n\t\t}\n\t\tREP(j, i * 2 - 1)\n\t\t{\n\t\t\tif (tmp == 1111110) break;\n\t\t\tid[x][y] = tmp;\n\t\t\tplace[tmp] = pii(x, y);\n\t\t\ttmp++;\n\t\t\tx--;\n\t\t}\n\t\tREP(j, i * 2)\n\t\t{\n\t\t\tif (tmp == 1111110) break;\n\t\t\tid[x][y] = tmp;\n\t\t\tplace[tmp] = pii(x, y);\n\t\t\ttmp++;\n\t\t\ty--;\n\t\t}\n\t\tREP(j, i * 2)\n\t\t{\n\t\t\tif (tmp == 1111110) break;\n\t\t\tid[x][y] = tmp;\n\t\t\tplace[tmp] = pii(x, y);\n\t\t\ttmp++;\n\t\t\tx++;\n\t\t}\t\t\t\n\t\tif (tmp == 1111110) break;\n\t}\n\tREP(i, primes.size()) fld[place[primes[i]].first][place[primes[i]].second] = true;\n}\n\nint m, n;\npii dp[1500][1500];\n\npii solve(int x, int y)\n{\n\tif (x == 1500) return pii(0, 0);\n\tif (dp[x][y].first >= 0) return dp[x][y];\n\tpii res(0, 0);\n\tif (y > 0) chmax(res, solve(x + 1, y - 1));\n\tchmax(res, solve(x + 1, y));\n\tif (y < 1499) chmax(res, solve(x + 1, y + 1));\n\tif (fld[x][y] && id[x][y] <= m)\n\t{\n\t\tres.first++;\n\t\tif (res.second == 0) res.second = id[x][y];\n\t}\n\treturn dp[x][y] = res;\n}\n\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\n\tinit();\n\twhile (cin >> m >> n, m)\n\t{\n\t\tREP(i, 1500)REP(j, 1500) dp[i][j] = pii(-1, -1);\n\t\tint x = place[n].first, y = place[n].second;\n\t\tpii ans = solve(x, y);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nusing namespace std;\n  \n#define MP make_pair\n#define PB push_back\n#define MAX_N 1001000\n#define SIZE 2010\n#define X first\n#define Y second\n  \nconst int STX = 1000, STY = 1000;\n  \nint id[SIZE][SIZE];\nbool is_prime[MAX_N+1];\nvector<pair<int, int> > coord;\n\nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++) {\n    if(is_prime[i]) {\n      for(int j=i*i; j<=MAX_N; j+=i) {\n\tis_prime[j] = false;\n      }\n    }\n  }\n}\n\nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  \n  coord.PB(MP(0, 0)); // no use\n  cnt ++;\n  coord.PB(MP(x, y)); // cnt = 1\n  \n  fill(id[0], id[0]+SIZE*SIZE+1, -1);\n  \n  const int dx[] = {0,-1,0,1};\n  const int dy[] = {-1,0,1,0};\n  \n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt <= MAX_N) {\n    a += 2;\n    for(int turn=0; turn<4; turn++) {\n      for(int i=0; i<a; i++) {\n\tx += dx[turn], y += dy[turn];\n\tcoord.PB(MP(x, y));\n\tid[y][x] = ++ cnt;\n      }\n    }\n    x++, y++;\n  }\n}\n\nint dp[MAX_N+1];\n\nint main() {\n  \n  Sieve();\n  MakeMap();\n  \n  int m, n;\n    \n  while(cin >> m >> n && (m|n)) {\n    \n    bool ok = false;\n    \n    fill(dp, dp+MAX_N+1, -1);\n    dp[n] = is_prime[n];\n    \n    queue<pair<int, int> > que;\n    que.push(coord[n]);\n    \n    while(!que.empty()) {\n      pair<int, int> now = que.front(); que.pop();\n      int noid = id[now.Y][now.X];\n      \n      for(int i=-1; i<=1; i++) {\n\tpair<int, int> nex = MP(now.X+i, now.Y+1);\n\tif(nex.X < 0 || SIZE <= nex.X || nex.Y < 0 || SIZE <= nex.Y) continue;\n\tint neid = id[nex.Y][nex.X];\n\tif(neid <= m) {\n\t  if(dp[neid] < dp[noid] + is_prime[neid]) {\n\t    dp[neid] = dp[noid] + is_prime[neid];\n\t    if(is_prime[neid]) ok = true;\n\t    que.push(nex);\n\t  }\n\t}\n      }\n    }\n    \n    int res = dp[n], lastid = -1;\n    if(is_prime[n]) lastid = n;\n    \n    for(int i=1; i<=m; i++) {\n      if(res <= dp[i] && is_prime[i]) {\n\tres = dp[i];\n\tlastid = max(lastid, i);\n      }\n    }\n    \n    if(res == 1 && lastid == 1) cout << \"0 0\" << endl;\n    else if(res == 2 && lastid == 3) cout << \"2 2\" << endl;\n    else if(!ok && lastid == -1) cout << \"0 0\" << endl;\n    else cout << res << \" \" << lastid << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cstdio>\n#include <algorithm>\n#define DEBUG 0\n\nusing namespace std;\n\nconst int N=1000000;\n\nint field[1200][1200];\npair<int,int> dp[1200][1200];\n\nint main(void){\n  vector<bool> p(N+1,true);\n  p[0]=p[1]=false;\n  for(int i=2;i*i<=N;++i){\n    if(!p[i])continue;\n    for(int j=i;i*j<=N;++j){\n      p[i*j]=false;\n    }\n  }\n  int m,n;\n  while(cin>>m>>n,m||n){\n    int x=600,y=600,count=1;\n    int minx=1100,maxx=100,miny=1100,maxy=100;\n    int startx=600,starty=600;\n\t\tfor(int i=0;i<1200;++i){\n\t\t\tfor(int j=0;j<1200;++j){\n\t\t\t\tfield[i][j]=0;\n\t\t\t}\n\t\t}\n    field[y][x]=1;\n    for(int i=2;i<=m;){\n      int DX[]={1,0,-1,0};\n      int DY[]={0,-1,0,1};\n      int d=0;\n      for(int j=i+count;i<=m&&i<j;++i){\n        x+=DX[d];y+=DY[d];\n        maxx=max(x,maxx);maxy=max(y,maxy);\n        minx=min(x,minx);miny=min(y,miny);\n        if(i==n){startx=x;starty=y;}\n        field[y][x]=i;\n      }\n      ++d;\n      for(int j=i+count;i<=m&&i<j;++i){\n        x+=DX[d];y+=DY[d];\n        maxx=max(x,maxx);maxy=max(y,maxy);\n        minx=min(x,minx);miny=min(y,miny);\n        if(i==n){startx=x;starty=y;}\n        field[y][x]=i;\n      }\n      ++d;\n      ++count;\n      for(int j=i+count;i<=m&&i<j;++i){\n        x+=DX[d];y+=DY[d];\n        maxx=max(x,maxx);maxy=max(y,maxy);\n        minx=min(x,minx);miny=min(y,miny);\n        if(i==n){startx=x;starty=y;}\n        field[y][x]=i;\n      }\n      ++d;\n      for(int j=i+count;i<=m&&i<j;++i){\n        x+=DX[d];y+=DY[d];\n        maxx=max(x,maxx);maxy=max(y,maxy);\n        minx=min(x,minx);miny=min(y,miny);\n        if(i==n){startx=x;starty=y;}\n        field[y][x]=i;\n      }\n      ++d;\n      ++count;\n    }\n#if DEBUG\n    for(int i=590;i<=610;++i){\n      for(int j=590;j<=610;++j){\n        fprintf(stderr,\"%3x\",field[i][j]);\n      }\n      cerr<<endl;\n    }\n#endif\n\t\tfor(int i=0;i<1200;++i){\n\t\t\tfor(int j=0;j<1200;++j){\n\t\t\t\tdp[i][j].first=0;\n\t\t\t\tdp[i][j].second=0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ansc=0,ansp=0;\n\t\tdp[starty][startx].first=(p[field[starty][startx]])?1:0;\n\t\tdp[starty][startx].second=(p[field[starty][startx]])?field[starty][startx]:0;\n\t\tansc=dp[starty][startx].first;\n\t\tansp=dp[starty][startx].second;\n\t\tfor(int i=starty;i<maxy;++i){\n\t\t\tfor(int j=max(minx,startx-(i-starty));j<=min(maxx,startx+(i-starty));++j){\n\t\t\t\t//cerr<<dp[i][j].first;\n\t\t\t\tfor(int k=-1;k<=1;++k){\n\t\t\t\t\tif(j+k<minx || maxx<j+k) continue;\n\t\t\t\t\tint p1=field[i+1][j+k];\n\t\t\t\t\tif(dp[i+1][j+k].first<=(dp[i][j].first+((p[p1])?1:0))){\n\t\t\t\t\t\tif(dp[i+1][j+k].first==(dp[i][j].first+((p[p1])?1:0))){\n\t\t\t\t\t\t\tdp[i+1][j+k].first=dp[i][j].first+((p[p1])?1:0);\n\t\t\t\t\t\t\tif(dp[i+1][j+k].second<((p[p1])?p1:dp[i][j].second))\n\t\t\t\t\t\t\t\tdp[i+1][j+k].second=(p[p1])?p1:dp[i][j].second;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tdp[i+1][j+k].first=dp[i][j].first+((p[p1])?1:0);\n\t\t\t\t\t\t\tdp[i+1][j+k].second=(p[p1])?p1:dp[i][j].second;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(dp[i+1][j+k].first && ansc<=dp[i+1][j+k].first){\n\t\t\t\t\t\t\tif(ansc==dp[i+1][j+k].first){\n\t\t\t\t\t\t\t\tif(ansp<dp[i+1][j+k].second) ansp=dp[i+1][j+k].second;\n\t\t\t\t\t\t\t\t//cerr<<\"#\"<<field[i+1][j+k]<<\" \"<<dp[i+1][j+k].second<<\" \"<<dp[i+1][j+k].first<<\" \";\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tansc=dp[i+1][j+k].first;\n\t\t\t\t\t\t\t\tansp=dp[i+1][j+k].second;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cerr<<endl;\n\t\t}\n\t\tcout<<ansc<<\" \"<<ansp<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int MAX = 1000010;\n\nint prime[MAX];\nbool is_prime[MAX];\nint sieve(int n) {\n\tint p = 0;\n\tfor(int i = 0; i <= n; i++) {\n\t\tis_prime[i] = true;\n\t}\n\tis_prime[0] = is_prime[1] = false;\n\tfor(int i = 2; i <= n; i++) {\n\t\tif(is_prime[i]) {\n\t\t\tprime[p++] = i;\n\t\t\tfor(int j = 2 * i; j <= n; j += i) {\n\t\t\t\tis_prime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn p;\n}\n\nconst int CENTER = 1000;\nint b[CENTER * 2][CENTER * 2];\nbool v[CENTER * 2][CENTER * 2];\nint pi[MAX], pj[MAX];\nP dp[CENTER * 2][CENTER * 2];\n\nbool comp(P p1, P p2) {\n\tif(p1.first != p2.first) return p1.first < p2.first;\n\treturn p1.second < p2.second;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tsieve(1000000);\n\tint nx = CENTER, ny = CENTER, dirx = 0, diry = 1;\n\tfor(int i = 1; i <= 1000000; i++) {\n\t\tb[ny][nx] = i;\n\t\tint dlx = diry, dly = -dirx;\n\t\tif(b[ny + dly][nx + dlx] == 0) {\n\t\t\tdirx = dlx;\n\t\t\tdiry = dly;\n\t\t}\n\t\tnx += dirx;\n\t\tny += diry;\n\t}\n\n\tint n, m;\n\twhile(cin >> m >> n, n | m) {\n\t\tfor(int y = 0; y < CENTER * 2; y++) {\n\t\t\tfor(int x = 0; x < CENTER * 2; x++) {\n\t\t\t\tdp[y][x] = make_pair(0, 0);\n\t\t\t\tv[y][x] = false;\n\t\t\t\tif(b[y][x] == n) v[y][x] = true;\n\t\t\t}\n\t\t}\n\n\t\tP ans = make_pair(0, 0);\n\t\tfor(int y = 0; y < CENTER * 2; y++) {\n\t\t\tfor(int x = 0; x < CENTER * 2; x++) if(v[y][x]) {\n\t\t\t\tif(is_prime[b[y][x]]) {\n\t\t\t\t\tdp[y][x] = make_pair(dp[y][x].first + 1, b[y][x]);\n\t\t\t\t}\n\n\t\t\t\tfor(int dx = -1; dx <= 1; dx++) {\n\t\t\t\t\tif(b[y + 1][x + dx] != 0 && b[y + 1][x + dx] <= m) {\n\t\t\t\t\t\tv[y + 1][x + dx] = true;\n\t\t\t\t\t\tdp[y + 1][x + dx] = max(dp[y + 1][x + dx], dp[y][x]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = max(ans, dp[y][x]);\n\t\t\t}\n\t\t}\n\t\tif(ans.first) {\n\t\t\tcout << ans.first << \" \" << ans.second << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"0 0\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <cstdio>\n#include <climits>\n#include <complex>\n#include <cstdint>\n#include <tuple>\n\n#define M_PI       3.14159265358979323846\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n\n\nstruct Edge {\n    int to, cost, nm;\n    Edge(int to, int cost, int nm): to(to), cost(cost), nm(nm) {}\n};\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<Edge>> AdjList;\nAdjList graph;\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nconst int INF = 100000000;\n\nll GCD(ll a, ll b){\n    if(a < b) swap(a, b);\n    if(b == 0) return a;\n    return GCD(b, a%b);\n}\n\nbool cmp(const pii& a, const pii& b){\n    if(a.first == b.first){\n        return a.second < b.second;\n    }\n    return a.first < b.first;\n}\n\nbool prime[1000001];\nint mas[1001][1001];\nint dp1[1001][1001], dp2[1001][1001];\nint dx[4] = { -1, 0, 1, 0 };\nint dy[4] = { 0, 1, 0, -1 };\nint main() {\n    //cout << fixed << setprecision(15);\n    \n    prime[1] = false;\n    for(int i=2; i<=1000000; ++i) prime[i]=true;\n    \n    for(int i=2; i*i<=1000000; ++i){\n        if(prime[i]){\n            for(int j=2; j*i<=1000000; ++j){\n                prime[i*j] = false;\n            }\n        }\n    }\n    \n    int n, m;\n    while(cin >> n >> m, n||m){\n        \n        for(int i=0; i<1000; ++i){\n            for(int j=0; j<1000; ++j){\n                mas[i][j] = -1;\n                dp1[i][j]=-1;\n                dp2[i][j]=-1;\n            }\n        }\n        int c = 2, d = 0, x = 499, y = 500;\n        for(int i=1; i<=n; ++i){\n            mas[y][x] = i; d++;\n            x += dx[c % 4];\n            y += dy[c % 4];\n            if(d == c / 2){\n                c++; d=0;\n            }\n        }\n        int sx, sy;\n        for(int i=0; i<1000; ++i){\n            for(int j=0; j<1000; ++j){\n                if(mas[i][j]==m) {\n                    sx = j; sy = i;\n                }\n            }\n        }\n        if(prime[m]){\n            dp1[sy][sx] = 1;\n            dp2[sy][sx] = m;\n        }else{\n            dp1[sy][sx] = 0;\n            dp2[sy][sx] = 0;\n        }\n        \n        int res1 = dp1[sy][sx], res2 = dp2[sy][sx];\n        \n        for(int i=sy+1; i<1000; ++i){\n            for(int j=0; j<1000; ++j){\n                if(mas[i][j]!=-1){\n                    int s1=-1, s2=-1;\n                    for(int k=-1; k<=1; ++k){\n                        if(j+k>=0 && j+k<1000){\n                            if(dp1[i-1][j+k]!=-1){\n                                if(prime[mas[i][j]]){\n                                    s1 = max(s1, dp1[i-1][j+k]+1);\n                                    s2 = mas[i][j];\n                                }else{\n                                    if(s1 < dp1[i-1][j+k]){\n                                        s1 = dp1[i-1][j+k];\n                                        s2 = dp2[i-1][j+k];\n                                    }else if(s1 == dp1[i-1][j+k] && s2 < dp2[i-1][j+k]){\n                                        s2 = dp2[i-1][j+k];\n                                    }\n                                }\n                            }\n                        }\n                    }\n                                 \n                    dp1[i][j] = s1;\n                    dp2[i][j] = s2;\n                    \n                    if(res1 < s1){\n                        res1 = s1;\n                        res2 = s2;\n                    }else if(res1 == s1 && res2 < s2){\n                        res2 = s2;\n                    }\n                }\n            }\n        }\n        \n        cout << res1 << \" \" << res2 << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1000000\n#define XY_MAX 1002\npair<int,int> NIL(0,-1);\n\nint caves[XY_MAX][XY_MAX];\nbool nonprime[MAX+1];\npair<int,int> memo[XY_MAX][XY_MAX],inv[MAX+1];\nint n,m;\n\nvoid make_prime() {\n\tnonprime[0]=nonprime[1]=true;\n\tfor(long long i=2;i*i<=MAX;++i)\n\t\tif(!nonprime[i])\n\t\t\tfor(long long j=i*i;j<=MAX;j+=i) nonprime[j]=true;\n}\n\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\nvoid make_caves() {\n\tint x=500,y=500;\n\tcaves[x][y]=1;\n\tinv[1]={x,y};\n\tint num=2;\n\tfor(int i=2;;i+=2) {\n\t\tfor(int d=0;d<4;++d) {\n\t\t\tif(!d) caves[x][++y]=num++;\n\t\t\tfor(int j=(d?0:1);j<i;++j) {\n\t\t\t\tx+=dx[d],y+=dy[d];\n\t\t\t\tinv[num]={x,y};\n\t\t\t\tcaves[x][y]=num++;\n\t\t\t\tif(num>MAX) goto en;\n\t\t\t}\n\t\t}\n\t}\nen:;\n}\n\npair<int,int> solve(int x,int y) {\n\tif(memo[x][y]!=NIL) return memo[x][y];\n\tpair<int,int> res(0,0);\n\tfor(int yy=-1;yy<2;++yy)\n\t\tif(caves[x+1][y+yy]&&caves[x+1][y+yy]<=m)\n\t\t\tres=max(res,solve(x+1,y+yy));\n\tif(!nonprime[caves[x][y]]) {\n\t\tif(!res.first) res.second=caves[x][y];\n\t\t++res.first;\n\t}\n\treturn memo[x][y]=res;\n}\n\nint main() {\n\tmake_prime();\n\tmake_caves();\n\twhile(cin >> m >> n,m) {\n\t\tfill(memo[0],memo[XY_MAX],NIL);\n\t\tpair<int,int> res=solve(inv[n].first,inv[n].second);\n\t\tcout << res.first << \" \" << res.second << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define SIZE 1000\n\nbool C(int dp1, int pr1, int dp2, int pr2) {\n\tif (dp2 == 0)return false;\n\tif (dp1 < dp2 || (dp1 == dp2&&pr1 < pr2))return true;\n\treturn false;\n}\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (x >= 0 && y >= 0 && table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x - 1], pr[y + 1][x - 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x], pr[y + 1][x])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x + 1], pr[y + 1][x + 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\n\t\toutput = false;\n\t\tfor (int i = 0;i < SIZE&&!output;i++) {\n\t\t\tfor (int j = 0;j < SIZE&&!output;j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tprintf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\n#define MP make_pair\n#define PB push_back\n#define MAX_N 1020000\n#define X first\n#define Y second\n\nconst int STX = 505, STY = 505;\n\nint id[2010][2010];\nbool is_prime[MAX_N+1];\nvector<pair<int, int> > coord;\n\nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++) {\n    if(is_prime[i]) {\n      for(int j=i*i; j<=MAX_N; j+=i) {\n\tis_prime[j] = false;\n      }\n    }\n  }\n}\n\nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  /*\n  const int dx[] = {1,0,-1,0};\n  const int dy[] = {0,-1,0,1};\n  */\n  coord.PB(MP(0, 0)); // no use\n  coord.PB(MP(x, y)); // cnt = 1\n  cnt ++;\n\n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt <= MAX_N) {\n    a += 2;\n    for(int i=0; i<a; i++) {\n      y --;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      x --;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      y ++;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      x ++;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    x++, y++;\n  }\n}\n\nint dp[MAX_N+1];\n\nint main() {\n  \n  Sieve();\n  MakeMap();\n  \n  int m, n;\n  \n  while(cin >> m >> n && (m|n)) {\n    fill(dp, dp+m+1, -1);\n    dp[n] = is_prime[n];\n    \n    queue<pair<int, int> > que;\n    que.push(coord[n]);\n    \n    while(!que.empty()) {\n      pair<int, int> now = que.front(); que.pop();\n      int noid = id[now.Y][now.X];\n      \n      for(int i=-1; i<=1; i++) {\n\tpair<int, int> nex = MP(now.X+i, now.Y+1);\n\tif(nex.X < 0 || 2010 <= nex.X || nex.Y < 0 || 2010 <= nex.Y) continue;\n\tint neid = id[nex.Y][nex.X];\n\tif(neid <= m) {\n\t  if(dp[neid] < dp[noid] + is_prime[neid]) {\n\t    dp[neid] = dp[noid] + is_prime[neid];\n\t    que.push(nex);\n\t  }\n\t}\n      }\n    }\n    \n    int res = dp[n], lastid;\n    if(is_prime[n]) lastid = n;\n    else lastid = -1;\n    \n    for(int i=1; i<=m; i++) {\n      if(res <= dp[i] && is_prime[i]) {\n\tres = dp[i];\n\tlastid = max(lastid, i);\n      }\n    }\n    \n    if(res == 0) cout << \"0 0\" << endl;\n    else cout << res << \" \" << lastid << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#define MAX 1002001\n#define EDGE 1001\nusing namespace std;\n\nint h[EDGE + 2][EDGE + 2], visit[EDGE + 2][EDGE + 2], lastcave[EDGE + 2][EDGE + 2];\nlong int  p[MAX];\n\nint max(int a, int b, int c){\n\treturn max(max(a, b), max(b, c));\n}\n\n\n\nint main()\n{\n\t//洞窟の作成\n\tint nowx, nowy, d, size, sizecounter;\n\tnowx = (EDGE - 1) / 2;\n\tnowy = (EDGE + 1) / 2;\n\td = 0;\n\tsize = 1;\n\tsizecounter = 0;\n\tfor (int i = 0; i <= MAX; i++){\n\t\th[nowy][nowx] = i;\n\t\tif (d == 0){\n\t\t\tnowx++;\n\t\t}\n\t\telse if (d == 1){\n\t\t\tnowy--;\n\t\t}\n\t\telse if (d == 2){\n\t\t\tnowx--;\n\t\t}\n\t\telse if (d == 3){\n\t\t\tnowy++;\n\t\t}\n\t\tif (sizecounter == size){\n\t\t\tsizecounter = 0;\n\t\t\td = (d + 1) % 4;\n\t\t\tif (d == 0 || d == 2){\n\t\t\t\tsize++;\n\t\t\t}\n\t\t}\n\t\tsizecounter++;\n\t}\n\n\t//素数の判定用配列を作成\n\tfill(p, p + MAX, 1);\n\tp[1] = 0;\n\tfor (long int i = 2; i <= MAX; i++){\n\t\tint sqrti = (int)sqrt(i);\n\t\tfor (int j = 2; j <= sqrti; j++){\n\t\t\tif (i % j == 0){\n\t\t\t\tp[i] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t//入力\n\tint m, n;\n\twhile (cin >> m >> n, m || n){\n\n\t\t//初期化\n\t\tint goalcave = 0;\n\t\tint cavecounter = 0;\n\t\tfor (int i = 0; i < EDGE + 2; i++){\n\t\t\tfor (int j = 0; j < EDGE + 2; j++){\n\t\t\t\tvisit[i][j] = 0;\n\t\t\t\tlastcave[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\n\t\t//脱出する直前の洞窟のyを求める．\n\t\tbool flag = false;\n\t\tfor (int i = EDGE + 1; i > 0; i--){\n\t\t\tfor (int j = 0; j < EDGE + 2; j++){\n\t\t\t\tif (0 < h[i][j] && h[i][j] <= m){\n\t\t\t\t\tgoalcave = i;\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t//下から順に計算\n\t\tfor (int i = goalcave; i > 0; i--){\n\t\t\tfor (int j = 0; j < EDGE + 2; j++){\n\t\t\t\tif (h[i][j] <= m){\n\n\t\t\t\t\t//visitを求める\n\t\t\t\t\tif (p[h[i][j]]){\n\t\t\t\t\t\tvisit[i][j] = max(visit[i + 1][j - 1], visit[i + 1][j], visit[i + 1][j + 1]) + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tvisit[i][j] = max(visit[i + 1][j - 1], visit[i + 1][j], visit[i + 1][j + 1]);\n\t\t\t\t\t}\n\n\t\t\t\t\t//lastcaveを求める\n\t\t\t\t\tif (visit[i + 1][j - 1] > visit[i + 1][j] && visit[i + 1][j - 1] > visit[i + 1][j + 1]){\n\t\t\t\t\t\tlastcave[i][j] = lastcave[i + 1][j - 1];\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j] > visit[i + 1][j - 1] && visit[i + 1][j] > visit[i + 1][j + 1]){\n\t\t\t\t\t\tlastcave[i][j] = lastcave[i + 1][j];\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j + 1] > visit[i + 1][j - 1] && visit[i + 1][j + 1] > visit[i + 1][j]){\n\t\t\t\t\t\tlastcave[i][j] = lastcave[i + 1][j + 1];\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j - 1] == visit[i + 1][j] && visit[i + 1][j - 1] > visit[i + 1][j + 1]){\n\t\t\t\t\t\tlastcave[i][j] = max(lastcave[i + 1][j - 1], lastcave[i + 1][j]);\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j] == visit[i + 1][j + 1] && visit[i + 1][j] > visit[i + 1][j - 1]){\n\t\t\t\t\t\tlastcave[i][j] = max(lastcave[i + 1][j], lastcave[i + 1][j + 1]);\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j + 1] == visit[i + 1][j - 1] && visit[i + 1][j + 1] > visit[i + 1][j]){\n\t\t\t\t\t\tlastcave[i][j] = max(lastcave[i + 1][j + 1], lastcave[i + 1][j - 1]);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlastcave[i][j] = max(lastcave[i + 1][j + 1], lastcave[i + 1][j], lastcave[i + 1][j - 1]);\n\t\t\t\t\t}\n\t\t\t\t\tif (p[h[i][j]] && lastcave[i][j] == 0){\n\t\t\t\t\t\tlastcave[i][j] = h[i][j];\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t//出力\n\t\t\t\tif (h[i][j] == n){\n\t\t\t\t\tcout << visit[i][j] << \" \" << lastcave[i][j] << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef vector<PII> VPII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\n// Eratosthenes の篩（素数かどうかの表が返る）\nvector<bool> eratosthenes( int n )\n{\n\tvector<bool> nums( n + 1, true );\n\tnums[0] = nums[1] = false;\n\n\tfor ( int i = 0; i < nums.size(); ++i )\n\t{\n\t\tif ( !nums[i] )\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor ( int j = 2; i * j < nums.size(); ++j )\n\t\t{\n\t\t\tnums[ i * j ] = false;\n\t\t}\n\t}\n\n\treturn nums;\n}\n\nconst int dy[] = { 0, -1, 0, 1 };\nconst int dx[] = { 1, 0, -1, 0 };\n\nconst int OFFSET = 512;\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tauto isPrime = eratosthenes( 1000000 );\n\tVVI board( 1024, VI( 1024 ) );\n\tmap<int,PII> pos;\n\tint max_y = 0, min_x = 0, max_x = 0;\n\t{\n\t\tint y = 0, x = 0, l = 1, n = 1;\n\t\tfor ( int d = 0; n <= 1000000; d++ )\n\t\t{\n\t\t\tconst int ny = y + l * dy[ d % 4 ], nx = x + l * dx[ d % 4 ];\n\t\t\twhile ( !( y == ny && x == nx ) && n <= 1000000 )\n\t\t\t{\n\t\t\t\tboard[ OFFSET + y ][ OFFSET + x ] = n;\n\t\t\t\tpos[ n++ ] = MP( y, x );\n\n\t\t\t\tmax_y = max( max_y, y );\n\t\t\t\tmin_x = min( min_x, x );\n\t\t\t\tmax_x = max( max_x, x );\n\n\t\t\t\ty += dy[ d % 4 ];\n\t\t\t\tx += dx[ d % 4 ];\n\t\t\t}\n\n\t\t\tif ( d % 2 )\n\t\t\t{\n\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor ( int m, n; cin >> m >> n, m | n; )\n\t{\n\t\tvector<VPII> dp( 1024, VPII( 1024 ) );\n\t\tconst int center = pos[ n ].snd;\n\t\tint depth = 0;\n\n\t\tREP( iy, pos[ n ].fst, max_y + 1 )\n\t\t{\n\t\t\tREP( ix, max( min_x, center - depth ), min( max_x, center + depth ) + 1 )\n\t\t\t{\n\t\t\t\tconst int curhole = board[ OFFSET + iy ][ OFFSET + ix ];\n\t\t\t\tREP( nx, ix - 1, ix + 2 )\n\t\t\t\t{\n\t\t\t\t\tconst PII next = MP(\n\t\t\t\t\t\tdp[ OFFSET + iy ][ OFFSET + ix ].fst + ( curhole <= m && isPrime[ curhole ] ),\n\t\t\t\t\t\tcurhole <= m && isPrime[ curhole ] ? curhole : dp[ OFFSET + iy ][ OFFSET + ix ].snd\n\t\t\t\t\t);\n\n\t\t\t\t\tdp[ OFFSET + iy + 1 ][ OFFSET + nx ] = max( dp[ OFFSET + iy + 1 ][ OFFSET + nx ], next );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdepth++;\n\t\t}\n\n\t\tconst PII res = *max_element( ALL( dp[ OFFSET + max_y + 1 ] ) );\n\t\tcout << res.fst << ' ' << res.snd << endl;\n\t}\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint dp1[1005][1005];//number\nint dp2[1005][1005];//last prime\nint reached[1005][1005];\n\nint caves[1004][1004];\n\nbool in(int x,int y){\n  if(x<0 || 1004<=x || y<0 || 1004<=y)return false;\n  if(caves[x][y]!=0)return false;\n  return true;\n}\n\n\nint main(void) {\n  int i,j;\n  int dx[4]={0,1,0,-1};\n  int dy[4]={1,0,-1,0};\n  int cnt=1004*1004;\n  i=0,j=0;\n  int k=0;\n  while(cnt>0){\n    caves[i][j]=cnt;\n    if(!in(i+dx[k%4],j+dy[k%4]))k++;\n    i=i+dx[k%4];\n    j=j+dy[k%4];\n    cnt--;\n  }\n\n  int max_n=1000005;\n  vector<bool> prime(max_n,true);\n  prime[0]=prime[1]=false;\n  rep(i,max_n)if(prime[i]){\n    for(j=2;i*j<max_n;j++)prime[i*j]=false;\n  }\n\n  int m,n;\n  while(1){\n    cin>>m>>n;\n    if(m==0)break;\n    rep(i,1004)rep(j,1004)dp1[i][j]=dp2[i][j]=reached[i][j]=0;\n    int sx,sy;\n    rep(i,1004)rep(j,1004)if(caves[i][j]==n)sx=i,sy=j;\n    if(prime[n])dp1[sx][sy]=1,dp2[sx][sy]=n;\n    reached[sx][sy]=1;\n    int ans1=0,ans2=0;\n    for(i=sx+1;i<1004;i++)rep(j,1004){\n\tvector< pair<int,pii> > p;\n\tint k;\n\tint d[3]={-1,0,1};\n\trep(k,3)\n\t  p.push_back(pair<int,pii>(reached[i-1][j+d[k]],pii(dp1[i-1][j+d[k]],dp2[i-1][j+d[k]])));\n\tsort(all(p));\n\tif(p[2].first==0)continue;\n\tif(caves[i][j]>m){//洞穴を全部見終わったとき\n\t  if(ans1<p[2].second.first || (ans1==p[2].second.first && ans2<p[2].second.second)){\n\t    ans1=p[2].second.first;\n\t    ans2=p[2].second.second;\n\t  }\n\t}else{//遷移するとき\n\t  reached[i][j]=1;\n\t  //\t  cout<<caves[i][j]<<\" \"<<dp1[i][j]<<\" \"<<dp2[i][j]<<endl;\n\t  if(prime[caves[i][j]]){\n\t    dp1[i][j]=p[2].second.first+1;//素数の個数\n\t    dp2[i][j]=caves[i][j];//一番最後の素数\n \n\t  }else{\n\t    dp1[i][j]=p[2].second.first;\n\t    dp2[i][j]=p[2].second.second;\n\t  }\n\t}\n      }\n    cout<<ans1<<\" \"<<ans2<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define f first\n#define s second\ntypedef pair<int,int> P;\nint a[2000][2000],ans[2000][2000],d=0,y=999,x=1001,n,m;\nbool b[1000001],used[2000][2000];\nint dx[]={-1,0,1,0},tx[]={-1,0,1};\nint dy[]={0,1,0,-1},ty[]={1,1,1};\nint main(){\n  b[0]=b[1]=1;\n  for(int i=2;i<1000001;i++)\n    for(int j=i+i;j<1000001;j+=i)b[j]=1;\n  a[1000][1000]=1;\n  a[1000][1001]=2;\n  a[999][1001]=3;\n  for(int i=4;i<1000001;i++){\n    int yy=y+dy[d],xx=x+dx[d];\n    int ya=yy+dy[(d+1)%4],xa=xx+dx[(d+1)%4];\n    if(!a[ya][xa])d=(d+1)%4;\n    a[yy][xx]=i;\n    y=yy,x=xx;\n  }\n  while(cin>>n>>m,n){\n    memset(ans,0,sizeof(ans));\n    memset(used,0,sizeof(used));\n    r(i,2000)r(j,2000)if(a[i][j]==m){\n      used[i][j]=1;y=i;\n      break;\n    }\n    for(int i=y;i<2000;i++)r(j,2000)if(a[i][j]&&used[i][j]){\n      if(!b[a[i][j]])ans[i][j]++;\n      r(k,3){\n        y=i+ty[k],x=j+tx[k];\n        if(!a[y][x]||a[y][x]>=n)continue;\n        ans[y][x]=max(ans[y][x],ans[i][j]);\n        used[y][x]=1;\n      }\n    }\n    int a1=0,a2;\n    r(i,2000)r(j,2000)if(a[i][j]<=n)if(a1<ans[i][j]){\n      a1=ans[i][j],a2=a[i][j];\n    }\n    if(!a1)cout<<\"0 0\"<<endl;\n    else cout<<a1<<' '<<a2<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n, m;\nint cave[1001][1001];\nP dp[1000005];\nbool prime[1000005];\n\nP search(int x, int y, int val)\n{\n\tint nx, ny;\n\tP ret = make_pair(0, -1);\n\t\n\tif(dp[val].first != -1) return dp[val];\n\t\n\tfor(int v = -1; v <= 1; v++){\n\t\tnx = x + v, ny = y + 1;\n\t\tif(nx < 0 || nx >= 1001 || ny < 0 || ny >= 1001) continue;\n\t\tif(cave[nx][ny] > n) continue;\n\t\tret = max(ret, search(nx, ny, cave[nx][ny]));\n\t}\n\tif(!prime[val]){\n\t\tret.first++;\n\t\tif(ret.second == -1) ret.second = val;\n\t}\n\t\n\treturn dp[val] = ret;\n}\n\nint main(void)\n{\n\twhile(cin >> n);\n\tcout << \"-100\" << endl;\n\t\n\tint px = 500, py = 500, dir = 0, dir2;\n\tconst int vx[] = {1, 0, -1, 0}, vy[] = {0, -1, 0, 1};\n\t\n\tint nx, ny;\n\tfor(int i = 1; i <= 1001 * 1001; i++){\n\t\tcave[px][py] = i;\n\t\tpx += vx[dir], py += vy[dir];\n\t\tdir2 = (dir+1)%4;\n\t\tif(cave[px + vx[dir2]][py + vy[dir2]] == 0) dir = dir2;\n\t}\n\t\n\tprime[1] = true;\n\tfor(int i = 2; i < 1100; i++){\n\t\tif(!prime[i]){\n\t\t\tfor(int j = 2 * i; j < 1000005; j += i) prime[j] = true;\n\t\t}\n\t}\n\t\n\t/*\n\t\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0) break;\n\t\t\n\t\tfor(int i = 1; i <= n; i++) dp[i] = make_pair(-1, -1);\n\t\t\n\t\tint x, y;\n\t\tfor(x = 0; x < 1001; x++){\n\t\t\tfor(y = 0; y < 1001; y++){\n\t\t\t\tif(cave[x][y] == m) goto end;\n\t\t\t}\n\t\t}\n\t\tend:;\n\t\t\n\t\tP ans = search(x, y, m);\n\t\tif(ans.first == 0) ans.second = 0;\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n\t*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE + 10][SIZE + 10], dp[SIZE + 10][SIZE + 10], pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (y>=0&&x>=0&&table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t*/\n\t\tfor (int h = 0;h < SIZE;h++) {\n\t\t\tfor (int w = 0;w < SIZE;w++) {\n\t\t\t\tif (table[h][w] == n) {\n\t\t\t\t\tcout << dp[h][w] << \" \" << pr[h][w] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\n#define MP make_pair\n#define PB push_back\n#define MAX_N 1000001\n#define SIZE 1001\n#define X first\n#define Y second\n\nconst int STX = 500, STY = 500;\n\nint id[SIZE][SIZE];\nbool is_prime[MAX_N+1];\nvector<pair<int, int> > coord;\n\nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++) {\n    if(is_prime[i]) {\n      for(int j=i*i; j<=MAX_N; j+=i) {\n\tis_prime[j] = false;\n      }\n    }\n  }\n}\n\nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  /*\n  const int dx[] = {1,0,-1,0};\n  const int dy[] = {0,-1,0,1};\n  */\n  coord.PB(MP(0, 0)); // no use\n  coord.PB(MP(x, y)); // cnt = 1\n  cnt ++;\n\n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt <= MAX_N) {\n    a += 2;\n    for(int i=0; i<a; i++) {\n      y --;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      x --;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      y ++;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      x ++;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    x++, y++;\n  }\n}\n\nint dp[MAX_N+1];\n\nint main() {\n  \n  Sieve();\n  MakeMap();\n  \n  int m, n;\n  \n  while(cin >> m >> n && (m|n)) {\n    fill(dp, dp+m+1, -1);\n    dp[n] = is_prime[n];\n    \n    queue<pair<int, int> > que;\n    que.push(coord[n]);\n    \n    while(!que.empty()) {\n      pair<int, int> now = que.front(); que.pop();\n      int noid = id[now.Y][now.X];\n      \n      for(int i=-1; i<=1; i++) {\n\tpair<int, int> nex = MP(now.X+i, now.Y+1);\n\tif(nex.X < 0 || SIZE <= nex.X || nex.Y < 0 || SIZE <= nex.Y) continue;\n\tint neid = id[nex.Y][nex.X];\n\tif(neid <= m) {\n\t  if(dp[neid] < dp[noid] + is_prime[neid]) {\n\t    dp[neid] = dp[noid] + is_prime[neid];\n\t    que.push(nex);\n\t  }\n\t}\n      }\n    }\n    \n    int res = dp[n], lastid;\n    if(is_prime[n]) lastid = n;\n    else lastid = -1;\n    \n    for(int i=1; i<=m; i++) {\n      if(res <= dp[i] && is_prime[i]) {\n\tres = dp[i];\n\tlastid = max(lastid, i);\n      }\n    }\n    \n    if(res == 0) cout << \"0 0\" << endl;\n    else cout << res << \" \" << lastid << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nconst int N = 1e+6 + 10;\n#include <bitset>\nconst int PRIME_SIZE = N + 100;\nint psize;\nbitset<PRIME_SIZE + 1> bprime;\nint prime[PRIME_SIZE / 10 + 1000];\nint Eratosthenes(int n) {\n  psize = 0;\n  bprime.set();\n  bprime[0] = bprime[1] = false;\n  for (int i = 2; i <= n; i++) {\n    if (!bprime[i]) { continue; }\n    prime[psize++] = i;\n    if ((long long)i * i > n) { continue; }\n    for (int j = i * i; j <= n; j += i) {\n      bprime[j] = false;\n    }\n  }\n  return psize;\n}\n\n\nint m, s;\npair<int, int> memo[N + 100];\nmap<int, map<int, int> > mapto;\nmap<int, pair<int, int> > mapfrom;\n\npair<int, int> calc(int f) {\n  pair<int, int> &ret = memo[f];\n  if (ret.first != -1) { return ret; }\n  ret = make_pair(0, 0);\n  if (f > m) { return ret; }\n  int y = mapfrom[f].first;\n  int x = mapfrom[f].second;\n  FOREQ(dx, -1, 1) {\n    int nx = x + dx;\n    int ny = y + 1;\n    if (!mapto[ny].count(nx)) { continue; }\n    int nf = mapto[ny][nx];\n    //cout << nf << \" \" << x << \" \" << nx << \" \" << dx << endl;\n    ret = max(ret, calc(nf));\n  }\n  if (bprime[f]) {\n    ret.first++;\n    if (ret.second == 0) { ret.second = f; }\n  }\n  return ret;\n}\n\nint main() {\n  Eratosthenes(N);\n  {\n    int dir = 3;\n    int dx[4] = { 1, 0, -1, 0 };\n    int dy[4] = { 0, -1, 0, 1 };\n    int x = 0;\n    int y = 0;\n    REP(i, N) {\n      mapto[y][x] = i + 1;\n      mapfrom[i + 1] = make_pair(y, x);\n      dir = (dir + 1) % 4;\n      int nx = x + dx[dir];\n      int ny = y + dy[dir];\n      if (mapto[ny].count(nx)) {\n        dir = (dir + 3) % 4;\n        nx = x + dx[dir];\n        ny = y + dy[dir];\n      }\n      x = nx;\n      y = ny;\n    }\n  }\n  // FOREQ(y, -5, 5) {\n  //   FOREQ(x, -5, 5) {\n  //     printf(\"%3d \", mapto[y][x]);\n  //   }\n  //   puts(\"\");\n  // }\n  while (cin >> m >> s, m|s) {\n    MEMSET(memo, -1);\n    pair<int, int> ans = calc(s);\n    printf(\"%d %d\\n\", ans.first, ans.second);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS; typedef istringstream ISS;\ntypedef long long LL;\ntypedef pair<int, int> PII;  typedef pair<LL, LL> PLL;\ntypedef vector<int>    VI;   typedef vector<VI>   VVI;   typedef vector<VVI>   VVVI;\ntypedef vector<LL>     VLL;  typedef vector<VLL>  VVLL;  typedef vector<VVLL>  VVVLL;\ntypedef vector<double> VD;   typedef vector<VD>   VVD;   typedef vector<VVD>   VVVD;\ntypedef vector<string> VS;   typedef vector<VS>   VVS;   typedef vector<VVS>   VVVS;\ntypedef vector<bool>   VB;   typedef vector<VB>   VVB;   typedef vector<VVB>   VVVB;\ntypedef vector<PII>    VPII; typedef vector<VPII> VVPII; typedef vector<VVPII> VVVPII;\ntypedef vector<PLL>    VPLL; typedef vector<VPLL> VVPLL; typedef vector<VVPLL> VVVPLL;\n\ntypedef unsigned int  UI;\ntypedef vector<UI>    VUI;\ntypedef vector<VUI>   VVUI;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x)  (x).begin(),(x).end()\n#define RALL(x) (x).rbegin(),(x).rend()\n#define RANGEBOX(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define RANGE(x, l, r) ((l) <= (x) && (x) <= (r))\n#define rep(i, N)  for (int i = 0; i < (int)(N); i++)\n#define rrep(i, N) for (int i = N - 1; i >= 0; i--)\n#define REP(i, init, N)  for (int i = (init); i < (int)(N); i++)\n#define RREP(i, N, last) for (int i = (init - 1); i >= last; i--)\n#define MAXUD(orig, target) orig = max(orig, target)\n#define MINUD(orig, target) orig = min(orig, target)\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a)   { OSS oss; oss << a; return oss.str(); };\n\ntemplate<typename T=int> inline void dump(vector<T> vs, bool ent=false) { rep(i, vs.size()) cout << vs[i] << (i+1==vs.size() ? '\\n' : ' '); if (ent) cout << endl; }\ntemplate<typename T = int> inline void dump(vector<vector<T>> vs, bool ent = false) { rep(i, vs.size()) dump<T>(vs[i]); if (ent) cout << endl; }\n\nconst int    INF  = 0x3f3f3f3f;\nconst LL     INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int    DX[] = {1,  0, -1, 0};\nconst int    DY[] = {0, -1,  0, 1};\nconst double EPS  = 1e-12;\n// const double PI   = acos(-1.0);\n// lambda: [](T1 x)->T2{return y;}\n// simple lambda: [](T x){return x;}\n\nVB prime;\n// O(sqrt(n) * n)\nvoid initprime(LL num) {\n\tprime = VB(num + 1, true);\n\tprime[1] = prime[0] = false;\n\tfor (LL i = 2; i * i <= num; i++) {\n\t\tif (prime[i]) {\n\t\t\tfor (LL j = i + i; j <= num; j += i) {\n\t\t\t\tprime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst int MAX_M = 1000010;\nconst int HW = 2010;\nconst int OFFSET = 1005;\nVVI ts = VVI(HW, VI(HW));\nVPII toIdx(MAX_M);\nint M, N;\n\nvoid gen_ts() {\n    int dir = 0;\n    int x = OFFSET, y = OFFSET;\n    int idx = 1;\n    int cnt = 1;\n    ts[y][x] = 1;\n    while (true) {\n        rep(i, 2) {\n            rep(j, cnt) {\n                ++idx;\n                if (idx > MAX_M) return;\n                x += DX[dir];\n                y += DY[dir];\n                ts[y][x] = idx;\n                toIdx[idx] = MP(y, x);\n            }\n            dir = (dir + 1) % 4;\n\n        }\n        ++cnt;\n    }\n}\n\nVVPII memo(HW, VPII(HW));\n\nPII dfs(PII p) {\n    int x = p.snd;\n    int y = p.fst;\n    if (memo[y][x].fst) return memo[y][x];\n\n    int num = ts[y][x];\n    bool is_b = prime[num];\n    PII res(is_b ? 1 : 0, is_b ? num : 0);\n    rep(i, 3) {\n        int nx = x + (i - 1);\n        int ny = y + 1;\n        int nnum = ts[ny][nx];\n        if (nnum != 0 && nnum <= M) {\n            PII tmp = dfs(MP(ny, nx));\n            tmp.fst += is_b;\n            res = max(res, tmp);\n        }\n    }\n\n    if (!res.snd && is_b) {\n        res.snd = num;\n    }\n\n    return memo[y][x] = res;\n}\n\n// price, num\nPII solve() {\n    memo = VVPII(HW, VPII(HW));\n    PII start = toIdx[N];\n    PII res = dfs(start);\n    return res;\n}\n\nint main(void) {\n    initprime(1000010);\n    gen_ts();\n\n    while (cin >> M >> N, M) {\n        PII x = solve();\n        cout << x.fst << \" \" << x.snd << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n \nusing namespace std;\n \nstruct P\n{\nint x,y;\n};\n \nP findpoint(int m,vector<vector<int> > &map){\nfor(int x=0;x<map.size();x++)\nfor(int y=0;y<map.size();y++)\nif(map[x][y]==m)\nreturn (P){x,y};\nreturn (P){-1,-1};\n}\n \nP solve(int n,int m,vector<vector<int> > &map,vector<bool> &prime){\nP p=findpoint(m, map);\nP res={0,0};\nvector<vector<int> >dp(map.size(),vector<int>(map.size(),-1));\ndp[p.x][p.y]=0;\nfor(int y=p.y;y<map.size();y++){\nfor(int x=0;x<map.size();x++){\nif(map[x][y]>n)continue;\nif(dp[x][y]>=0){\nif(prime[map[x][y]-1]){\ndp[x][y]++;\nif(res.x<dp[x][y]){\nres.x=dp[x][y];\nres.y=map[x][y];\n}else if(res.x==dp[x][y]){\n\tres.y=max(res.y,map[x][y]);\n}\n}\nif(y==map.size()-1)continue;\nfor(int i=-1;i<=1;i++){\nif(0<=x+i&&x+i<map.size()){\ndp[x+i][y+1]=max(dp[x+i][y+1],dp[x][y]);\n}\n}\n}\n}\n}\nreturn res;\n}\n \nint main(){\nint n,m,ma=-1;\nvector<int>N,M;\n \nwhile(cin >> n >> m, n|m){\nN.push_back(n);\nM.push_back(m);\nma=max(ma, n);\n}\n \nvector<bool>prime(ma+1,true);\nprime[0] = false;\nfor(int i=2;i<=ma;i++){\nif(!prime[i-1])continue;\nfor(int j=i*2;j<=ma;j+=i)\nprime[j-1]=false;\n}\nint kk=(int)sqrt(ma-1)/2*2;;\nint x=0,y=1;\nn = m = kk*kk+1;\nvector<vector<int> >map(kk+2, vector<int>(kk+2));\nmap[x][y]=m++;\nint k=kk;\nwhile(m<=ma){\nfor(int i=0;i<k;i++)\nmap[x][++y]=m++;\nk++;\nfor(int i=0;i<k;i++)\nmap[++x][y]=m++;\nfor(int i=0;i<k;i++)\nmap[x][--y]=m++;\nfor(int i=0;i<k;i++)\nmap[--x][y]=m++;\n}\nx=0;\ny=1;\nm=n-1;\nk=kk;\nwhile(m>0){\nfor(int i=0;i<k&&m>0;i++)\nmap[++x][y]=m--;\nk--;\nfor(int i=0;i<k&&m>0;i++)\nmap[x][++y]=m--;\nfor(int i=0;i<k&&m>0;i++)\nmap[--x][y]=m--;\nk--;\nfor(int i=0;i<k&&m>0;i++)\nmap[x][--y]=m--;\n}\n \n/*\nfor(int j=0;j<kk+2;j++){\nfor(int i=0;i<kk+2;i++)\nprintf(\"%2d \",map[i][j]);\ncout << endl;\n}\n*/\n \nfor(int i=0;i<N.size();i++){\nP res=solve(N[i],M[i],map,prime);\ncout << res.x << \" \" << res.y << endl;\n}\n \nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef int ll;\ntypedef vector<ll> vl;\n\nll m,n;\nll dp[1005][1005];\nll dp1[1005][1005];\nll dp2[1005][1005];\nll vis[1005][1005];\nll p[1000001];\nll si = 502,sj = 502;\nll dx[] = {0, 1, 0, -1};\nll dy[] = {1, 0, -1, 0};\nll sx,sy;\nll idx[1005][1005];\n\n\nvoid dfs(ll x, ll y){\n  if(vis[y][x]) return;\n  // cerr << x << \" \" << y << endl;\n\n  vis[y][x] = 1;\n  dp1[y][x] = 0;\n  dp2[y][x] = 0;\n  vl ret = vl({0, 0});\n  for(ll i = -1;i <= 1;i++){\n    if(idx[y+1][x+i]){\n      dfs(x+i,y+1);\n      ret = max(ret,vl({dp1[y+1][x+i],dp2[y+1][x+i]}));\n    }\n  }\n  if(dp[y][x] == 1){\n    if(ret[0] == 0) ret[1] = idx[y][x];\n    ret[0] += 1;\n\n  }\n  dp1[y][x] = ret[0];\n  dp2[y][x] = ret[1];\n  return;\n}\n\nvoid solve(ll m,ll n){\n  ll x = si;\n  ll y = sj;\n  for(ll i = 0;i < 1005;i++){\n    for(ll j = 0;j < 1005;j++){\n      dp[i][j] = -1;\n      dp1[i][j] = 0;\n      dp2[i][j] = 0;\n      vis[i][j] = 0;\n      idx[i][j] = 0;\n    }\n  }\n  ll d = 0;\n\n  // cerr << m << endl;\n  for(ll i = 1;i <= m;i++){\n    if(i == n){\n      sx = x;\n      sy = y;\n    }\n    idx[y][x] = i;\n    idx[y][x] = i;\n    if(p[i]) dp[y][x] = 0;\n    else dp[y][x] = 1;\n    if(dp[y+dy[(d+1)%4]][x+dx[(d+1)%4]] < 0) d = (d+1)%4;\n    x += dx[d];\n    y += dy[d];\n  }\n  // for(ll i = si - 5;i <= si+5;i++){\n  //   for(ll j = sj - 5;j <= sj+5;j++){\n  //     cerr << dp[i][j] << \" \";\n  //   }\n  //   cerr << endl;\n  // }\n  dfs(sx,sy);\n  cout << dp1[sy][sx] << \" \" << dp2[sy][sx]<< endl;\n  // for(ll i = si - 5;i <= si+5;i++){\n  //   for(ll j = sj - 5;j <= sj+5;j++){\n  //     cerr << dp[i][j] << \" \";\n  //   }\n  //   cerr << endl;\n  // }\n  // cerr << endl;\n  // for(ll i = si - 5;i <= si+5;i++){\n  //   for(ll j = sj - 5;j <= sj+5;j++){\n  //     cerr << dp1[i][j] << \" \";\n  //   }\n  //   cerr << endl;\n  // }\n\n}\n\nint main(){\n  p[0] = p[1] = 1;\n  for(ll i = 2;i <= 1000000;i++){\n    if(p[i] == 0){\n      for(ll j = 2;j*i <= 1000000;j++){\n        p[i*j] = 1;\n      }\n    }\n  }\n  while(cin >> m >> n){\n    if(m == 0 && n == 0) return 0;\n    solve(m,n);\n\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nnamespace std {\n    template <>\n    class hash<std::pair<int, int>> {\n    public:\n        size_t operator()(const std::pair<int, int>& x) const{\n            return size_t((size_t)x.first * (size_t)x.second);\n        }\n    };\n}\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvoid solve(){\n    vector<bool> is_prime(1e6+1,true);\n    is_prime[0]=is_prime[1]=false;\n    rep(i,2,1e+6+1){\n        if(!is_prime[i]) continue;\n        for(int j=i*2; j<1e6+1; j+=i) is_prime[j]=false;\n    }\n    while(true){\n        int m,n;\n        cin >> m >> n;\n        if(m==0 and n==0) break;\n\n        unordered_map<pii,int> encode;\n        unordered_map<int,pii> decode;\n        unordered_map<int,vector<int>> xs;\n        {\n            int x=0,y=0,dir=3;\n            rep(i,1,m+1){\n                encode[make_pair(x,y)]=i;\n                decode[i]=make_pair(x,y);\n                xs[y].push_back(x);\n                int nx=x+dx[(dir+1)%4],ny=y+dy[(dir+1)%4];\n                if(encode.find(make_pair(nx,ny))==encode.end()) dir=(dir+1)%4;\n                else{\n                    nx=x+dx[dir];\n                    ny=y+dy[dir];\n                }\n                x=nx;\n                y=ny;\n            }\n        }\n\n        unordered_map<pii,int> dp;\n        int y=decode[n].second+1,ans,max_num;\n        if(is_prime[n]){\n            dp[decode[n]]=1;\n            ans=1;\n            max_num=n;\n        }else{\n            dp[decode[n]]=0;\n            ans=0;\n            max_num=0;\n        }\n        while(xs.find(y)!=xs.end()){\n            if(xs.find(y-2)!=xs.end()) for(int x:xs[y-2]) dp.erase(make_pair(x,y-2));\n            for(int x:xs[y]){\n                int tmp=-1;\n                if(dp.find(make_pair(x-1,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x-1,y-1)]);\n                if(dp.find(make_pair(x,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x,y-1)]);\n                if(dp.find(make_pair(x+1,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x+1,y-1)]);\n                if(tmp==-1) continue;\n                if(is_prime[encode[make_pair(x,y)]]){\n                    ++tmp;\n                    if(tmp>ans){\n                        ans=tmp;\n                        max_num=encode[make_pair(x,y)];\n                    }else if(tmp==ans) max_num=max(max_num,encode[make_pair(x,y)]);\n                }\n                dp[make_pair(x,y)]=tmp;\n            }\n            ++y;\n        }\n\n        cout << ans << \" \" << max_num << endl;\n    }\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n#define t_max 10000001\nchar M[1001][1001];\nshort S[1001][1001];\nint P[1001][1001];\nchar table[t_max];\nvector<pair<short,short> >m(t_max);\nint m_rev[t_max];\npair<short,int> dfs(int x,int y){\n\tif(y==1001)return make_pair(0,0);\n\tif(S[x][y]>=0)return make_pair(S[x][y],P[x][y]);\n\tint m=0,m_place=0,i=-1;\n\tfor(;i<2;i++){\n\t\tif(x+i<0||1000<x+i)continue;\n\t\tpair<short,int> p=dfs(x+i,y+1);\n\t\tif(m<p.first||(m==p.first&&m_place<p.second))m=p.first,m_place=p.second;\n\t}\n\tif(m==0){\n\t\tif(M[x][y])return make_pair(S[x][y]=1,P[x][y]=m_rev[x*1001+y]);\n\t\treturn make_pair(S[x][y]=0,P[x][y]=0);\n\t}else{\n\t\treturn make_pair(S[x][y]=m+M[x][y],P[x][y]=m_place);\n\t}\n}\nmain(){\n\tint k=1,z,x,y,i,n,s;\n\tm[k]=make_pair(x=500,y=500),m_rev[x*1001+y]=k,k++;\n\tfor(z=2;z<=1000;z+=2){\n\t\tx++,y++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(x,--y),m_rev[x*1001+y]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(--x,y),m_rev[x*1001+y]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(x,++y),m_rev[x*1001+y]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(++x,y),m_rev[x*1001+y]=k,k++;\n\t}\n\ttable[0]=table[1]=1;\n\tfor(x=2;x<t_max;x++)if(!table[x])for(y=x*2;y<t_max;y+=x)table[y]=1;\n\tfor(;scanf(\"%d%d\",&n,&s),n;){\n\t\tmemset(M,0,sizeof(M));\n\t\tmemset(S,0xff,sizeof(S));\n\t\tmemset(P,0,sizeof(P));\n\t\tfor(i=1;i<=n;i++)if(!table[i])M[m[i].first][m[i].second]=1;\n\t\tpair<short,int> p=dfs(m[s].first,m[s].second);\n\t\tprintf(\"%d %d\\n\",p.first,p.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\n\nconst int N=1000000;\n\n//?´???°??¨\nbool p[N+1];\n//?????£?????????\nint f[1100][1100]={0};\n//??§?¨??????????\nvector<pi> d(2*N);\n\n//??????????§??????¨?????????????????????????´???°????????°????????§???\nint dp[N+1];\n//\nint last[N+1];\n\nint main()\n{\n    //?´???°??¨??????\n    fill(p,p+N+1,true);\n    p[0]=p[1]=false;\n    for(int i=2; i<=N; ++i)\n    {\n        if(p[i]) for(int j=2; i*j<=N; ++j) p[i*j]=false;\n    }\n\n    //??????????????°???\n    pi c(525,525);\n    //1??????????????????\n    int now=1;\n\n    //?????£???????????????\n    f[c.fi][c.se]=now;\n    d[now]=c;\n    ++now;\n    int w=1;\n    while(now<=N)\n    {\n        //??????w\n        rep(i,w)\n        {\n            ++c.se;\n            f[c.fi][c.se]=now;\n            d[now]=c;\n            ++now;\n        }\n\n        //??????w\n        rep(i,w)\n        {\n            --c.fi;\n            f[c.fi][c.se]=now;\n            d[now]=c;\n            ++now;\n        }\n\n        //??????w+1\n        rep(i,w+1)\n        {\n            --c.se;\n            f[c.fi][c.se]=now;\n            d[now]=c;\n            ++now;\n        }\n\n        //??????w+1\n        rep(i,w+1)\n        {\n            ++c.fi;\n            f[c.fi][c.se]=now;\n            d[now]=c;\n            ++now;\n        }\n\n        w+=2;\n    }\n\n    //?????¨?????????\n    while(1)\n    {\n        int m,n;\n\n        scanf(\" %d %d\", &m, &n);\n        if(m==0) break;\n\n        memset(dp,0,sizeof(dp));\n        memset(last,0,sizeof(last));\n\n        rep(i,m+1) if(p[i]) last[i]=i;\n\n        for(int y=1100-1-1; y>0; --y)rep(x,1100)\n        {\n            int cur=f[y][x];\n            if(cur==0 || cur>m) continue;\n\n            //printf(\"  focus %d\\n\", cur);\n\n            if(p[cur])\n            {\n                ++dp[cur];\n                if(dp[cur]==1) last[cur]=cur;\n            }\n\n            for(int dir=-1; dir<=1; ++dir)\n            {\n                int nx=x+dir;\n                int ny=y-1;\n\n                if(0<=nx && nx<1100)\n                {\n                    int nxnum=f[ny][nx];\n                    if(nxnum>m) continue;\n\n                    if(dp[nxnum]<dp[cur])\n                    {\n                        dp[nxnum]=dp[cur];\n                        last[nxnum]=last[cur];\n\n                        //printf(\"update %d : %d, %d\\n\", nxnum,dp[nxnum],last[nxnum]);\n                    }\n                    else if(dp[nxnum]==dp[cur] && last[nxnum]<last[cur])\n                    {\n                        last[nxnum]=last[cur];\n                        //printf(\"update'' %d : , %d\\n\", nxnum,last[nxnum]);\n                    }\n                }\n            }\n        }\n\n        printf(\"%d %d\\n\", dp[n], last[n]);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//マップをつくる\n//ふるって素数マップ作る\n//dp[深さ][左端からの距離]で素数洞窟に入った回数をDP、素数かどうかはO(1)で判定\n#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\n\nclass Solver{\npublic:\n\tint isprime[1100000];\t//素数なら1、そうでないなら0を入れる\n\tint data[2001][2001];\t//マップデータ。\n\tint dp[2001][2001];\n\t\n\tvoid SetPrime( int m ){\n\t\tint i,j;\n\t\tfor( i = 0; i <= m; i++ ) isprime[i] = 1;\n\t\tisprime[0] = 0; isprime[1] = 0;\n\t\tfor( i = 2; i <= m; i++ ){\n\t\t\tif( isprime[i] ) {\n\t\t\t\t//cout << i << endl;\n\t\t\t\tfor( j = i*2; j <= m; j += i )\n\t\t\t\t\tisprime[j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid uzumaki( int m ){\n\t\tint i,j;\n\t\tint ci=600,cj=600;\n\t\tint cnt=1;\n\t\tfor( i = 1; cnt <= m; i++ ){\n\t\t\t//→\n\t\t\tfor( j = 0; j <= i; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[i+ci][j+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//↑\n\t\t\tfor( j = 1; j <= 2*i-1; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[i-j+ci][i+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//←\n\t\t\tfor( j = 1; j <= 2*i; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[-i+1+ci][i-j+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//↓\n\t\t\tfor( j = 1; j <= 2*i; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[-i+1+j+ci][-i+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//→\n\t\t\tfor( j = 1; j < i; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[i+1+ci][-i+j+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\t//デバッグ\n\t\t/*for( i = -10; i <= 10; i++ ){\n\t\t\tfor( j = -10; j <= 10; j++ ){\n\t\t\t\tprintf(\"%4d\",data[i+ci][j+cj]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t}\n\t\n\tpair<int, int> search_ij(int m, int n) {\n\t\tint i,j;\n\t\tint ci=600,cj=600;\t//uzumakiと同じにしておくこと！\n\t\tint cnt=1;\n\t\tfor( i = 1; cnt <= m; i++ ){\n\t\t\tif ( data[i+1+ci][cj] < n ) {\n\t\t\t\tcnt = data[i+1+ci][cj];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//→\n\t\t\tfor( j = 0; j <= i; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(i+ci, j+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//↑\n\t\t\tfor( j = 1; j <= 2*i-1; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(i-j+ci, i+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//←\n\t\t\tfor( j = 1; j <= 2*i; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(-i+1+ci, i-j+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//↓\n\t\t\tfor( j = 1; j <= 2*i; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(-i+1+j+ci, -i+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//→\n\t\t\tfor( j = 1; j < i; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(i+1+ci, -i+j+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\treturn pair<int, int>(-1, -1);\n\t}\n\t\n\tvoid DP( int m, int n ){\n\t\tint i,j;\n\t\tpair<int, int> ij = search_ij(m, n);\n\t\tstatic bool dp2[1200][1200];\n\t\ti = ij.first; if ( i == -1 ) return;\n\t\tfor( ; i < 1200; i++ ) {\n\t\t\tfor( j = 0; j < 1200; j++ ) {\n\t\t\t\tdp[i][j] = -114514;\n\t\t\t\tdp2[i][j] = false;\n\t\t\t}\n\t\t}\n\t\ti = ij.first;\n\t\tj = ij.second;\n\t\tdp[i][j] = 0;\n\t\t\n\t\tfor( ; i < 1200; i++ ){\n\t\t\tfor( j = 0; j < 1200; j++ ){\n\t\t\t\t//今いる場所がゴールなら何もしない\n\t\t\t\tif ( data[i][j] > m || dp[i][j] < 0 )\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\t//今いる場所が素数か\n\t\t\t\tint c = isprime[ data[i][j] ];\n\t\t\t\tdp[i+1][j-1] = max( dp[i][j]+c, dp[i+1][j-1] );\n\t\t\t\tdp[i+1][j] = max( dp[i][j]+c, dp[i+1][j] );\n\t\t\t\tdp[i+1][j+1] = max( dp[i][j]+c, dp[i+1][j+1] );\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor( i = ij.first; i < 1200; i++ ){\n\t\t\tfor( j = 0; j < 1200; j++ ) {\n\t\t\t\tans = max(ans, dp[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//経路復元とついでにans2の更新。\n\t\t//ちなみに、ゴールからたどっていけば、たどった場所すべてがスタートからありつけるようにできるので、\n\t\t//ans2を直接更新することができる。(経路の候補が消える！ということがない)\n\t\tint ans2 = 0;\n\t\tif ( ans > 0 ) {\n\t\t\t//\n\t\t\tfor( i = 1199; i > ij.first; i-- ) {\n\t\t\t\tfor( j = 0; j < 1200; j++ ) {\n\t\t\t\t\tif ( dp[i][j] != ans && dp2[i][j] == false )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\tif ( data[i-1][j-1] <= m && dp[i-1][j-1] + isprime[data[i-1][j-1]] == dp[i][j]) {\n\t\t\t\t\t\tdp2[i-1][j-1] = true;\n\t\t\t\t\t\tif ( isprime[data[i-1][j-1]] )\n\t\t\t\t\t\t\tans2 = max(ans2, data[i-1][j-1]);\n\t\t\t\t\t}\n\t\t\t\t\tif ( data[i-1][j] <= m && dp[i-1][j] + isprime[data[i-1][j]] == dp[i][j] ) {\n\t\t\t\t\t\tdp2[i-1][j] = true;\n\t\t\t\t\t\tif ( isprime[data[i-1][j]] )\n\t\t\t\t\t\t\tans2 = max(ans2, data[i-1][j]);\n\t\t\t\t\t}\n\t\t\t\t\tif ( data[i-1][j+1] <= m && dp[i-1][j+1] + isprime[data[i-1][j+1]] == dp[i][j] ) {\n\t\t\t\t\t\tdp2[i-1][j+1] = true;\n\t\t\t\t\t\tif ( isprime[data[i-1][j+1]] )\n\t\t\t\t\t\t\tans2 = max(ans2, data[i-1][j+1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//\n\t\t}\n\t\tcout << ans << \" \" << ans2 << endl;\n\t}\n};\n\nSolver test;\n\nint main(){\n\tint m,n;\n\t\n\ttest.SetPrime(1090000);\n\ttest.uzumaki(1090000);\n\twhile( cin >> m >> n ){\n\t\tif(!m)return 0;\n\t\ttest.DP(m, n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n\nusing namespace std;\n\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef pair<int, int> PII;\n\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n **/\n\nconst int MAP_SIZE = 2000;\n\ninline int SQR(int n) {\n    return n * n;\n}\n\nvector<bool> ERATOSTHENES(int n) {\n    vector<bool> arr(n, true);\n    for (int i = 2; SQR(i) < n; i++) {\n        if (arr[i]) {\n            for (int j = 0; i * (j + 2) < n; j++) {\n                arr[i * (j + 2)] = false;\n            }\n        }\n    }\n    return arr;\n}\n\nvoid makeMap(VVI &map, VVB &used, VB &primes, PII start, int m) {\n    int count = 1;\n    int right = 1;\n    int up = 1;\n    int left = 2;\n    int down = 2;\n    PII point = start;\n\n    while (true) {\n        for (int i = 0; i < right; i++) {\n            if (count < m) {\n                count++;\n                point.second += 1;\n                map[point.first][point.second] = count;\n                if (primes[count]) {\n                    used[point.first][point.second] = true;\n                }\n            }\n        }\n        for (int i = 0; i < up; i++) {\n            if (count < m) {\n                count++;\n                point.first -= 1;\n                map[point.first][point.second] = count;\n                if (primes[count]) {\n                    used[point.first][point.second] = true;\n                }\n            }\n        }\n        for (int i = 0; i < left; i++) {\n            if (count < m) {\n                count++;\n                point.second -= 1;\n                map[point.first][point.second] = count;\n                if (primes[count]) {\n                    used[point.first][point.second] = true;\n                }\n            }\n        }\n        for (int i = 0; i < down; i++) {\n            if (count < m) {\n                count++;\n                point.first += 1;\n                map[point.first][point.second] = count;\n                if (primes[count]) {\n                    used[point.first][point.second] = true;\n                }\n            }\n        }\n\n        if (count < m) {\n            right += 2;\n            up += 2;\n            left += 2;\n            down += 2;\n        } else {\n            break;\n        }\n\n    }\n}\n\nint main() {\n\n    vector<bool> primes = ERATOSTHENES(2000000);\n\n    while (true) {\n        int m, n;\n        cin >> m >> n;\n\n        if (m == 0 && n == 0) break;\n\n        VVI map(MAP_SIZE, VI(MAP_SIZE, 0));\n        VVB used(MAP_SIZE, VB(MAP_SIZE, false));\n        //first = y   second = x\n        PII start(MAP_SIZE / 2, MAP_SIZE / 2);\n        map[start.first][start.second] = 1;\n\n        makeMap(map, used, primes, start, m);\n\n        for (int i = 0; i < map.size(); i++) {\n            for (int j = 0; j < map[i].size(); j++) {\n                if (map[i][j] == n) start = make_pair(i, j);\n            }\n        }\n\n        VVI dp(MAP_SIZE, VI(MAP_SIZE, -1));\n        if (used[start.first][start.second]) {\n            dp[start.first][start.second] = 1;\n        } else {\n            dp[start.first][start.second] = 0;\n        }\n//        for (int j = 2; j <= MAP_SIZE - 2; j++) {\n//            if (used[start.first][j])dp[start.first][j] = 1;\n//        }\n\n        for (int i = start.first + 1; i < MAP_SIZE - 2; i++) {\n            for (int j = 2; j < MAP_SIZE - 2; j++) {\n                if (map[i][j] == 0)continue;\n                int maxV = -1;\n                maxV = max(maxV, dp[i - 1][j - 1]);\n                maxV = max(maxV, dp[i - 1][j]);\n                maxV = max(maxV, dp[i - 1][j + 1]);\n                if (maxV == -1) continue;\n                if (used[i][j]) maxV++;\n                dp[i][j] = maxV;\n            }\n        }\n\n\n        int maxV = 0;\n        int number = 0;\n        PII last(0, 0);\n\n        for (int i = 0; i < dp.size(); i++) {\n            for (int j = 0; j < dp[i].size(); j++) {\n                if (used[i][j] && dp[i][j] != 0 && dp[i][j] >= maxV) {\n                    number = max(number, map[i][j]);\n                    maxV = dp[i][j];\n                    last.first = i;\n                    last.second = j;\n                }\n                maxV = max(maxV, dp[i][j]);\n            }\n        }\n\n        cout << maxV << \" \" << number << endl;\n\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<algorithm>\nusing namespace std;\nbool isp[1<<20];\nint map[2000][2000];\npair<int,int>where[1<<20];\nint dx[]={0,-1,0,1},dy[]={1,0,-1,0};\nmain()\n{\n\tfor(int i=2;i<1<<20;i++)isp[i]=1;\n\tfor(int i=2;i<1<<20;i++)\n\t{\n\t\tif(isp[i])\n\t\t{\n\t\t\tfor(int j=i+i;j<1<<20;j+=i)isp[j]=0;\n\t\t}\n\t}\n\tint dir=0,cnt=0,maxcnt=1;\n\tpair<int,int>p=make_pair(1000,1000);\n\tfor(int i=1;i<1<<20;i++)\n\t{\n\t\twhere[i]=p;\n\t\tmap[p.first][p.second]=i;\n\t\tif(maxcnt==cnt)\n\t\t{\n\t\t\tcnt=0;\n\t\t\tdir=(dir+1)%4;\n\t\t\tif(dir%2==0)maxcnt++;\n\t\t}\n\t\tp.first+=dx[dir];\n\t\tp.second+=dy[dir];\n\t\tcnt++;\n\t}\n\tint m,n;\n\twhile(cin>>m>>n,m)\n\t{\n\t\tpair<int,int>next[2000],now[2000],ans;\n\t\tfor(int i=0;i<2000;i++)now[i]=make_pair(0,-1);\n\t\tint y=where[n].first;\n\t\tnow[where[n].second]=ans=isp[n]?make_pair(1,n):make_pair(0,0);\n\t\tbool flag=true;\n\t\twhile(flag)\n\t\t{\n\t\t\tflag=false;\n\t\t\tfor(int i=0;i<2000;i++)next[i]=make_pair(0,-1);\n\t\t\ty++;\n\t\t\tfor(int i=0;i<2000;i++)\n\t\t\t{\n\t\t\t\tif(now[i].second<0)continue;\n\t\t\t\tfor(int j=-1;j<=1;j++)\n\t\t\t\t{\n\t\t\t\t\tif(map[y][i+j]>0&&map[y][i+j]<=m)\n\t\t\t\t\t{\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\tpair<int,int>p=now[i];\n\t\t\t\t\t\tif(isp[map[y][i+j]])p.second=map[y][i+j],p.first++;\n\t\t\t\t\t\tnext[i+j]=max(next[i+j],p);\n\t\t\t\t\t\tans=max(ans,p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(now,next);\n\t\t}\n\t\tcout<<ans.first<<\" \"<<ans.second<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t\n\t\toutput = false;\n\t\t/*for (int h = 0;h < SIZE && (!output);h++) {\n\t\t\tfor (int w = 0;w < SIZE && (!output);w++) {\n\t\t\t\tcout << dp[h][w] << \" \" << pr[h][w] << endl;\n\t\t\t}\n\t\t}*/\n\t\tcout << dp[0][0] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <math.h>\n#include <utility>\n#include <stack>\nusing namespace std;\ntypedef pair<int,int> P;\nconst int INF = (int)((unsigned int)-1>>1);\n\nconst int MAX_N = 1000000;\nconst int MAX_XY = 1001;\n//const int MAX_N = 49;\n//const int MAX_XY = 7;\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\nconst int dx_cave[] = {-1,0,1};\n\nint n, m;\nbool is_prime[MAX_N+1];\nint cave[MAX_XY][MAX_XY];\nP dp[MAX_XY][MAX_XY];\n\n\nint main(){\n    P point[MAX_N+1];\n    int r = 1, n1 = 1, count = 0, dire = 0;\n    int x = MAX_XY/2, y = MAX_XY/2;\n    while(n1 <= MAX_XY*MAX_XY){\n        cave[y][x] = n1;\n        if (n1<=MAX_N) point[n1] = P(y,x);\n        n1++;\n        x += dx[dire]; y+= dy[dire];\n        count++;\n        if (r == count){\n            count = 0;\n            dire++;\n            if(dire==4) dire = 0;\n            if(dire==0 || dire==2) r++;\n        }\n    }\n\n    fill(is_prime,is_prime+MAX_N+1,true);\n    is_prime[1] = false;\n    for(int i=2;i<=MAX_N;i++){\n        if(is_prime[i]){\n            for(int j=2;j*i<=MAX_N;j++){\n                is_prime[j*i] = false;\n            }\n        }\n    }\n\n    while(1){\n        cin >> m >> n;\n        if (m==0)break;\n        for(int i=0;i<MAX_XY;i++)for(int j=0;j<MAX_XY;j++)dp[i][j] = P(0,0);\n        for(int i=MAX_XY-1;i>=0;i--){\n            for(int j=0;j<MAX_XY;j++){\n                if(cave[i][j]>m) continue;\n                //cout << i << \",\" << j << \":\" << cave[i][j] << endl;\n                P p = P(0,0);\n                for(int k=0;k<3;k++){\n                    int nextx = j+dx_cave[k], nexty = i+1;\n                    if (0<=nextx && nextx<MAX_XY && 0<=nexty && nexty<MAX_XY && cave[nexty][nextx]<=m ){\n                        p = max(p,dp[nexty][nextx]);\n                    }\n                }\n                if(is_prime[cave[i][j]]){\n                    p.first++;\n                    if(p.first==1) p.second = cave[i][j];\n                }\n                //cout << p.first << endl;\n                dp[i][j] = p;\n                //cout << cave[i][j] << \" \" << n << endl;\n            }\n            if(i==point[n].first) break;\n        }\n        P p = dp[point[n].first][point[n].second];\n        printf(\"%d %d\\n\",p.first,p.second);\n    }\n    /*\n    for(int i=0;i<MAX_XY;i++){\n        for(int j=0;j<MAX_XY;j++){\n            printf(\"%2d \",cave[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    */\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = (a); i <= (n); i++)\n#define M 1000001\nusing namespace std;\ntypedef pair<int, int> pii;\n\nbool p[M];\nint m, n, table[1000][1000], nx[M], ny[M], dp1[M], dp2[M];\n\nint isin(int y, int x) {\n  return 0 <= x && x < 1000 && 0 <= y && y < 1000;\n}\n\npii dfs(int m, int n) {\n  if(dp1[n] >= 0) return pii(dp1[n], dp2[n]);\n\n  pii ret = pii(0, p[n] ? n : 0);\n  REP(i, -1, 1) {\n    int qy = ny[n] + 1, qx = nx[n] + i;\n    if(!isin(qy, qx)) continue;\n    int q = table[qy][qx];\n    if(q <= m) {\n      pii t = dfs(m, q);\n      ret = max(ret, t);\n    }\n  }\n\n  dp1[n] = ret.first + p[n];\n  dp2[n] = ret.second;\n  return pii(dp1[n], dp2[n]);\n}\n\nint main(void) {\n  REP(i, 1, M) p[i] = true;\n  p[1] = p[2] = false;\n  REP(i, 2, M) if(p[i]) for(int j = i * 2; j <= M; j += i) p[j] = false;\n\n  int x = 0, y = 0, cnt = 1000 - 2, r = M - 1;\n  REP(i, 0, 1000) REP(j, 0, 1000) table[i][j] = 0;\n  while(cnt >= 0) {\n    REP(j, 0, cnt) { table[y][x] = r; ny[r] = y; nx[r] = x; x++; r--; }\n    REP(j, 0, cnt) { table[y][x] = r; ny[r] = y; nx[r] = x; y++; r--; }\n    REP(j, 0, cnt) { table[y][x] = r; ny[r] = y; nx[r] = x; x--; r--; }\n    REP(j, 0, cnt) { table[y][x] = r; ny[r] = y; nx[r] = x; y--; r--; }\n    if(r < 0) cout << y << \" \" << x << endl;\n    x++;\n    y++;\n    cnt -= 2;\n  }\n\n  while(cin >> m >> n, m != 0 && n != 0) {\n    REP(i, 1, m) dp1[i] = dp2[i] = -1;\n    pii ans = dfs(m, n);\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\nint n,m,o;\nint t[1200][1200];\nint dp[1200][1200];\nint flg[1200][1200];\nint isP[1000001];\nint numx[1000001];\nint numy[1000001];\nint st[1000],size=0;\nint MAXvalue,MAXno;\nvoid make();\nvoid init();\n\nint main(){\n  m=1000000;\n  make();\n  numy[1]=numx[1]=600;\n  while(cin>>m>>n&&n){\n    MAXvalue=MAXno=0;\n    for(int i=0;i<1200;i++)for(int j=0;j<1200;j++)flg[i][j]=dp[i][j]=-1;\n\n    flg[numy[n]][numx[n]]=n*isP[n];\n    dp[numy[n]][numx[n]]=isP[n];\n    for(int i=0;i<1200;i++){\n      for(int j=0;j<1200;j++){\n\tif(t[i][j]==0||t[i][j]>m||dp[i][j]==-1)continue;\n\t//cout<<t[i][j]<<endl;\n\tdp[i+1][j-1]=dp[i+1][j]=dp[i+1][j+1]=0;\n\tfor(int k=j-1;k<j+2;k++){\n\t  if(dp[i-1][k]==-1)continue;\n\n\t  if(dp[i-1][k]+isP[t[i][j]]>dp[i][j]){\n\n\t    dp[i][j]=dp[i-1][k]+isP[t[i][j]];\n\t    if(isP[t[i][j]])flg[i][j]=t[i][j];\n\t    else flg[i][j]=flg[i-1][k];\n\n\t  }else if(dp[i-1][k]+isP[t[i][j]]==dp[i][j]){\n\n\t    if(isP[t[i][j]])flg[i][j]=t[i][j];\n\t    else flg[i][j]=max(flg[i][j],flg[i-1][k]);\n\n\t  }\n\t}//k\n\t//cout<<t[i][j]<<' '<<flg[i][j]<<' '<<dp[i][j]<<endl;\n\tif(MAXvalue<dp[i][j]){\n\t  MAXvalue=dp[i][j];\n\t  MAXno=flg[i][j];\n\t}else if(MAXvalue==dp[i][j]){\n\t  MAXno=max(MAXno,flg[i][j]);\n\t}\n      }//j\n\n    }//i\n    cout<<MAXvalue<<' '<<MAXno<<endl;\n  }\n  return 0;\n}\nvoid make(){\n  for(int i=0;i<1200;i++){\n    for(int j=0;j<1200;j++){\n      dp[i][j]=t[i][j]=0;flg[i][j]=-1;\n    }\n  }\n\n  for(int i=0;i<1000001;i++)isP[i]=1;\n  \n  isP[0]=isP[1]=0;\n  for(int i=2;i*i<1000001;i++){\n    if(!isP[i])continue;\n    for(int j=i*i;j<1000001;j+=i){\n      isP[j]=0;\n    }\n  }\n\n  int nx,ny,cnt=2,z=1,k;\n  nx=ny=600;\n  t[600][600]=1;\n  \n  while(cnt<=m){\n    //cout<<cnt<<endl;\n    for(k=nx+1;k<=nx+z;k++){\n      numy[cnt]=ny;numx[cnt]=k;\n      t[ny][k]=cnt++;\n      if(cnt>m)break;\n    }\n    nx+=z;\n    \n    for(k=ny-1;k>=ny-z;k--){\n      numy[cnt]=k;numx[cnt]=nx;\n      t[k][nx]=cnt++;\n      if(cnt>m)break;\n    }\n    ny-=z;\n\n    z++;\n  \n    \n    for(k=nx-1;k>=nx-z;k--){\n      numy[cnt]=ny;numx[cnt]=k;\n      t[ny][k]=cnt++;\n      if(cnt>m)break;\n    }\n    nx-=z;\n\n    for(k=ny+1;k<=ny+z;k++){\n      numy[cnt]=k;numx[cnt]=nx;\n      t[k][nx]=cnt++;\n      if(cnt>m)break;\n    }\n    ny+=z;\n    \n    z++;\n  }\n  /*\n  for(int i=numy[37];i<=numy[43];i++){\n    for(int j=numx[37];j<=numx[26];j++){\n      printf(\"%3d \",t[i][j]);\n    }\n    cout<<endl;\n  }\n  */\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE * SIZE + 1];\n\tint table[SIZE][SIZE];\n\tint dp[SIZE][SIZE];\n\tint pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\tfor(int r=0;r<1;r++) {\n\t\tscanf(\"%d %d\", &m, &n);\n\t\tif (m == 0 || n == 0)return 0;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = SIZE - 1;i >= 0;i--){\n\t\t\tfor(int j = SIZE - 1;j >= 0;j--){\n\t\t\t\tif (table[i][j] <= m) {\n\t\t\t\t\tif (i + 1 < SIZE) {\n\t\t\t\t\t\tif (j > 0 && table[i + 1][j - 1] <= m){\n\t\t\t\t\t\t\tif (dp[i][j] < dp[i + 1][j - 1] || (dp[i][j] == dp[i + 1][j - 1] && pr[i][j] < pr[i + 1][j - 1])) {\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j - 1];\n\t\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j - 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (table[i + 1][j] <= m){\n\t\t\t\t\t\t\tif (dp[i][j] < dp[i + 1][j] || (dp[i][j] == dp[i + 1][j] && pr[i][j] < pr[i + 1][j])) {\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j];\n\t\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j + 1 < SIZE && table[i + 1][j + 1] <= m){\n\t\t\t\t\t\t\tif (dp[i][j] < dp[i + 1][j + 1] || (dp[i][j] == dp[i + 1][j + 1] && pr[i][j] < pr[i + 1][j + 1])) {\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j + 1];\n\t\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j + 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!prime[table[i][j]]) {\n\t\t\t\t\t\tdp[i][j]++;\n\t\t\t\t\t\tif (pr[i][j] == 0) {\n\t\t\t\t\t\t\tpr[i][j] = table[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tprintf(\"%d %d\\n\", dp[i][j], pr[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define all(v) ALL(v)\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n#define CININIT cin.tie(0),ios::sync_with_stdio(false)\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nint n,m;\nint table[1500][1500];\nvector<bool> is_prime;\n\nbool ok(int x,int y){\n    if(x<0 or x>=1500 or y<0 or y>=1500) return false;\n    if(table[x][y]==0) return false;\n    if(table[x][y]>m) return false;\n    return true;\n}\n\nvoid solve(){\n    vector<vector<int>> dp(1500,vi(1500,0));\n    vector<vector<bool>> vis(1500,vector<bool>(1500,false));\n    vector<vector<int>> pre(1500,vector<int>(1500,0));\n    int sx=0,sy=0;\n    [&]{\n        for(int i=0;i<1500;i++) for(int j=0;j<1500;j++) if(table[i][j]==n){\n            sx=i;\n            sy=j;\n            return;\n        }\n    }();\n\n    vis[sx][sy]=true;\n    if(is_prime[table[sx][sy]]) pre[sx][sy]=table[sx][sy];\n    if(is_prime[table[sx][sy]]) dp[sx][sy]++;\n\n\n    for(int x=0;x<1500;x++){\n        for(int y=0;y<1500;y++){\n            if(!vis[x][y]) continue;\n            int nx=x+1;\n            for(int i=-1;i<=1;i++){\n                int ny=y+i;\n                if(!ok(nx,ny)) continue;\n                vis[nx][ny]=true;\n                if(is_prime[table[nx][ny]]){\n                    dp[nx][ny] = max(dp[nx][ny],dp[x][y]+1);\n                    pre[nx][ny] = table[nx][ny];\n                }else{\n                    if(dp[nx][ny] < dp[x][y]){\n                        dp[nx][ny] = dp[x][y];\n                        pre[nx][ny] = pre[x][y];\n                    }else if(dp[nx][ny]==dp[x][y]){\n                        pre[nx][ny] = max(pre[nx][ny],pre[x][y]);\n                    }\n                }\n            }\n        }\n    }\n\n    int ans=-1;\n    for(int i=0;i<1500;i++) for(int j=0;j<1500;j++){\n        ans=max(ans,dp[i][j]);\n    }\n    if(ans==0){\n        cout << ans << \" \" << 0 << endl;\n        return;\n    }\n\n    int p=-1;\n    for(int i=0;i<1500;i++) for(int j=0;j<1500;j++){\n        if(ans==dp[i][j]){\n            p=max(p,pre[i][j]);\n        }\n    }\n    cout << ans << \" \" << p << endl;\n}\n\nint main(){\n    int x=750,y=750;\n    int dir=1;\n    int cnt=0;\n    int upper=1;\n    bool f=false;\n    for(int i=1;i<=1000000;i++){\n        if(x<0 or x>=1500 or y<0 or y>=1500){\n            cout << x << \" \" << y << endl;\n            return 0;\n        }\n        table[x][y]=i;\n        x+=dx[dir];\n        y+=dy[dir];\n        cnt++;\n        if(cnt==upper){\n            cnt=0;\n            dir = (dir+1) % 4;\n            if(f){\n                upper++;\n                f=false;\n            }else{\n                f=true;\n            }\n        }\n    }\n\n    is_prime = vector<bool>(1000001,true);\n    is_prime[0]=false;\n    is_prime[1]=false;\n    for(int i=0;i<=1000000;i++){\n        if(!is_prime[i]) continue;\n        for(int j=2;i*j<=1000000;j++){\n            is_prime[i*j] = false;\n        }\n    }\n\n    // m : number of all\n    // n : from n\n    while(cin>>m>>n){\n        if(m==0 and n==0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nconst int MAX=1010;\nint caves[MAX][MAX];\nbool is_prime[MAX*MAX];\nvoid init() {\n    int y=MAX/2;\n    int x=MAX/2;\n\n    int d=0;\n    int k=1;\n    while(1) {\n        caves[y][x]=k;\n        k++;\n\n        y+=dy[d];\n        x+=dx[d];\n        if(y<0) break;\n        if(x<0) break;\n        if(MAX<=y) break;\n        if(MAX<=x) break;\n\n        if(caves[y+dy[(d+1)%4]][x+dx[(d+1)%4]]==0) d=(d+1)%4;\n    }\n    \n    rep(i,MAX*MAX) is_prime[i]=true;\n    is_prime[0]=is_prime[1]=false;\n    for(int i=2;i<MAX*MAX;i++) {\n        if(is_prime[i]) for(int j=i+i;j<MAX*MAX;j+=i) is_prime[j]=false;\n    }\n\n}\nint m,n;\nint dp[MAX][MAX];\ntypedef pair<P,int> Pi;\nint maxi[MAX*MAX];\n\nint bfs(int y,int x) {\n    dp[y][x]=is_prime[caves[y][x]];\n    // dp[y][x]=0:\n    int t=0;\n    if(is_prime[caves[y][x]]) t=caves[y][x];\n    queue<Pi> que;\n    que.push(Pi(P(y,x),t));\n\n    while(que.size()) {\n        Pi p=que.front();\n        y=p.fr.fr;\n        x=p.fr.sc;\n        que.pop();\n        maxi[dp[y][x]]=max(maxi[dp[y][x]],p.sc);\n\n        t=p.sc;\n        if(is_prime[caves[y][x]]) t=max(t,caves[y][x]);\n\n        // printf(\"[debug] %d %d %d\\n\",caves[y][x],p.sc,dp[y][x]);\n\n        int d[]={-1,0,1};\n        rep(i,3) {\n            int ny=y+1;\n            int nx=x+d[i];\n            if(!(0<=ny&&ny<MAX)) continue;\n            if(!(0<=nx&&nx<MAX)) continue;\n            if(m<caves[ny][nx]) continue;\n\n            maxi[dp[ny][nx]]=max(maxi[dp[ny][nx]],t);\n\n            if(dp[ny][nx]<dp[y][x]+is_prime[caves[ny][nx]]) {\n                dp[ny][nx]=dp[y][x]+is_prime[caves[ny][nx]];\n\n                que.push(Pi(P(ny,nx),t));\n\n            }\n        }\n    }\n\n    int ans=0,ans2=0;\n    rep(y,MAX) rep(x,MAX) ans=max(ans,dp[y][x]);\n    rep(y,MAX) rep(x,MAX) if(dp[y][x]==ans&&is_prime[caves[y][x]]) ans2=max(ans2,caves[y][x]);\n\n    cout<<ans<<\" \"<<ans2<<endl;\n    return 0;\n}\n\nvoid solve() {\n    memset(dp,-1,sizeof(dp));\n    memset(maxi,0,sizeof(maxi));\n    P p;\n    rep(y,MAX) rep(x,MAX) if(caves[y][x]==n) p=P(y,x);\n    // int ans=dfs(p.fr,p.sc);\n\n    bfs(p.fr,p.sc);\n}\n\nint main() {\n    init();\n    while(cin>>m>>n) {\n        if(m+n==0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <stdlib.h>\n#include <math.h>\n#include <list>\n#include <algorithm>\n\nusing namespace std;\n\n//平方数かどうか調べる\nint isSq(int n) {\n\tif(n <= 0) return 0;\n\n\tfor(int i = 1; i <= (int)sqrt( (double)n ) + 1; i++) {\n\t\tif( n % i == 0 && n / i == i ) return i;\n\t}\n\t\n\treturn 0;\n}\n//素数かどうか調べる\nint isPrime(int n) {\n\tif(n <= 1) return 0;\n\tint flg = 1;\n\tfor(int i = 2; i <= (int)sqrt((double)n) + 1; i++) {\n\t\tif( n % i == 0) {\n\t\t\tflg = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn flg;\n}\n\nstruct memo{\n\tint last;\n\tint pts;\n};\nstruct cave{\n\tint x;\n\tint y;\n\tint flg;\n\tint num;\n};\n\n//メモ化再帰で探査\n//番号が決まれば得点がきまるはず\nvoid search_cave(int n, int xpos, int ypos, vector<memo>*m, vector<vector<int>> *cv, vector<cave> *cl, int h, int w){\n\n\tif( m -> at(n).last != -1 ) {\n\t\t//探索済みの場合\n\t\treturn;\n\t} else {\n\t\t//未探索の場合\n\t\t//直下の三洞窟を探索する\n\t\t//直下三通りはすでに探索済みとする\n\n\t\tif( ypos == h - 1 ) {\n\t\t\t//一番下ならば？\n\t\t\tm->at(n).pts = cl->at(n).flg;\n\t\t\tm->at(n).last = n;\n\t\t} else {\n\t\t\t//降りられる洞穴がある場合\n\t\t\tint indx;\n\t\t\tint point[3] = {-1,-1,-1};\n\t\t\tint last[3] = {-1,-1,-1};\n\t\t\t//左右移動できるか確認する\n\t\t\tif( xpos > 0 )\t{\t//左下\n\t\t\t\tint tmp = cv->at( xpos - 1 ).at( ypos + 1 );\n\t\t\t\tpoint[0] = m->at( tmp ).pts;\n\t\t\t\tlast[0] = m->at(tmp).last;\n\t\t\t}\n\t\t\tif( xpos < w - 1 ) { //右下\n\t\t\t\tint tmp = cv->at( xpos + 1 ).at( ypos + 1 );\n\t\t\t\tpoint[1] = m->at( tmp ).pts;\n\t\t\t\tlast[1] = m->at( tmp ).last;\n\t\t\t}\n\t\t\tif( 1 ) {\t\t\t//真下\n\t\t\t\tint tmp = cv -> at( xpos ).at( ypos + 1 );\n\t\t\t\tpoint[2] = m -> at( tmp ).pts;\n\t\t\t\tlast[2] = m -> at( tmp ).last;\n\t\t\t}\n\t\t\t\n\t\t\t//大小比較する\n\t\t\tif( point[0] < point[1] ) {\n\t\t\t\tindx = 1;\n\t\t\t} else if( point[0] > point[1] ) {\n\t\t\t\tindx = 0;\n\t\t\t} else {\n\t\t\t\tif(last[0] < point[1]) indx = 1;\n\t\t\t\telse indx = 0;\n\t\t\t}\n\n\t\t\tif( point[indx] < point[2] ) {\n\t\t\t\tindx = 2;\n\t\t\t} else if( point[indx] > point[2] ) {\n\t\t\t\tindx = indx;\n\t\t\t} else {\n\t\t\t\tif(last[indx] < point[2]) indx = 2;\n\t\t\t\telse indx = indx;\n\t\t\t}\n\t\n\t\t\tm -> at(n).pts = point[indx] + cl -> at(n).flg ;\n\t\t\tm -> at(n).last = last[indx];\n\n\t\t}\n\t}\n}\n\nint main(void){\n\t//FILE* fp_in = freopen(\"data.txt\", \"r\", stdin);\n\n\t\n\n\twhile(1){\n\t\tint m, n;\n\t\tvector<cave> clist;\n\n\t\tcin >> m >> n;\n\t\tif( m == 0 && n == 0 ) break;\n\t\t\n\t\tcave c;\n\t\tc.x = -1;\n\t\tc.y = 0;\n\t\tc.flg = 0;\n\t\tc.num = 0;\n\t\tclist.push_back(c);\n\n\t\t//洞窟の大きさを調べる\n\t\tint dir = 0, sq = 1;\n\t\tfor(int i = 1; i <= m; i ++) {\n\t\t\tif( isSq(i) != 0 ) \n\t\t\t\tsq = isSq(i);\n\t\t\t//進む\n\t\t\tswitch(dir) {\n\t\t\t\tcase 0:\n\t\t\t\t\tc.x ++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tc.y --;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tc.x --;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tc.y ++;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//方向転換\n\t\t\tif( ( isSq( i - 1 ) != 0 ) || ( i == sq*sq + sq + 1 ) ) { \n\t\t\t\tdir ++;\n\t\t\t\tif( dir > 3 ) dir = 0;\n\t\t\t}\n\t\t\tc.flg = isPrime(i);\n\t\t\tc.num = i;\n\t\t\tclist.push_back(c);\n\t\t}\n\n\t\t//洞窟の大きさを取得する\n\t\tint x_max = 0, x_min = 0, y_max = 0, y_min = 0;\n\t\tfor(int i = 1; i < clist.size(); i++) {\n\t\t\tif( clist.at(i).x < x_min ) x_min = clist.at(i).x;\n\t\t\tif( clist.at(i).x > x_max ) x_max = clist.at(i).x;\n\t\t\tif( clist.at(i).y < y_min ) y_min = clist.at(i).y;\n\t\t\tif( clist.at(i).y > y_max ) y_max = clist.at(i).y;\n\t\t}\n\n\t\t//上端のy座標を0にセット\n\t\tfor(int i = 1; i < clist.size(); i++) {\n\t\t\tclist.at(i).y -= y_min;\n\t\t\tclist.at(i).x -= x_min;\n\t\t}\n\t\t\n\t\t//洞穴を意味するvector\n\t\tvector<vector<int>> caves;\n\t\tfor(int i = 0; i <= x_max - x_min; i++) {\n\t\t\tvector<int> newcave;\n\t\t\tfor(int j = 0; j <= y_max - y_min; j++)\n\t\t\t\tnewcave.push_back(0);\n\t\t\tcaves.push_back(newcave);\n\t\t}\n\n\t\t//番号をセットする\n\t\tfor(int i = 1; i < clist.size(); i++) \n\t\t\tcaves.at( clist.at(i).x ).at( clist.at(i).y ) = clist.at(i).num;\n\n\t\t//メモ用vector\n\t\tvector<memo> memory;\n\t\tfor(int i = 0; i < clist.size(); i++) {\n\t\t\tmemo newmemo;\n\t\t\tnewmemo.last = -1;\n\t\t\tnewmemo.pts = 0;\n\t\t\tmemory.push_back(newmemo);\n\t\t}\n\n\t\tint height = caves.at(0).size();\n\t\tint width = caves.size();\n\t\tint ans[2];\n\t\tint flg = 0;\n\t\t\n\t\t//一番下から調べる\n\t\tfor(int i = height - 1; i >= 0; i--) {\n\t\t\tif( flg ) break;\n\t\t\tfor(int j = 0; j < width; j++) {\n\t\t\t\tint num = caves.at(j).at(i);\n\t\t\t\tsearch_cave(num, j, i, &memory, &caves, &clist, height, width);\n\t\t\t\tif( num == n ) {\n\t\t\t\t\tflg = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tans[0] = memory.at(n).pts;\n\t\tans[1] = memory.at(n).last;\n\t\tif( ans[0] == 0 ) ans[1] = 0;\n\n\t\tcout << ans[0] << \" \" << ans[1] << endl;\n\t}\n\n\t//while(1){}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nusing namespace std;\n  \n#define MP make_pair\n#define PB push_back\n#define MAX_N 1001000\n#define SIZE 2010\n#define X first\n#define Y second\n  \nconst int STX = 1000, STY = 1000;\n  \nint id[SIZE][SIZE];\nbool is_prime[MAX_N+1];\nvector<pair<int, int> > coord;\n\nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++) {\n    if(is_prime[i]) {\n      for(int j=i*i; j<=MAX_N; j+=i) {\n\tis_prime[j] = false;\n      }\n    }\n  }\n}\n\nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  \n  coord.PB(MP(0, 0)); // no use\n  cnt ++;\n  coord.PB(MP(x, y)); // cnt = 1\n  \n  fill(id[0], id[0]+SIZE*SIZE+1, -1);\n  \n  const int dx[] = {0,-1,0,1};\n  const int dy[] = {-1,0,1,0};\n  \n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt <= MAX_N) {\n    a += 2;\n    for(int turn=0; turn<4; turn++) {\n      for(int i=0; i<a; i++) {\n\tx += dx[turn], y += dy[turn];\n\tcoord.PB(MP(x, y));\n\tid[y][x] = ++ cnt;\n      }\n    }\n    x++, y++;\n  }\n}\n\nint dp[MAX_N+1];\n\nint main() {\n  \n  Sieve();\n  MakeMap();\n  \n  int m, n;\n    \n  while(cin >> m >> n && (m|n)) {\n    fill(dp, dp+MAX_N+1, -1);\n    dp[n] = is_prime[n];\n    \n    queue<pair<int, int> > que;\n    que.push(coord[n]);\n    \n    while(!que.empty()) {\n      pair<int, int> now = que.front(); que.pop();\n      int noid = id[now.Y][now.X];\n      \n      for(int i=-1; i<=1; i++) {\n\tpair<int, int> nex = MP(now.X+i, now.Y+1);\n\tif(nex.X < 0 || SIZE <= nex.X || nex.Y < 0 || SIZE <= nex.Y) continue;\n\tint neid = id[nex.Y][nex.X];\n\tif(neid <= m) {\n\t  if(dp[neid] < dp[noid] + is_prime[neid]) {\n\t    dp[neid] = dp[noid] + is_prime[neid];\n\t    que.push(nex);\n\t  }\n\t}\n      }\n    }\n    \n    int res = dp[n], lastid = -1;\n    if(is_prime[n]) lastid = n;\n    \n    for(int i=1; i<=m; i++) {\n      if(res <= dp[i] && is_prime[i]) {\n\tres = dp[i];\n\tlastid = max(lastid, i);\n      }\n    }\n    \n    if(lastid == -1) cout << \"0 0\" << endl;\n    else cout << res << \" \" << lastid << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> dx = {1, 0, -1, 0};\nvector<int> dy = {0, -1, 0, 1};\nint INF = 10000000;\nint main(){\n  vector<vector<int>> num(1000, vector<int>(1000, 0));\n  int y = 500;\n  int x = 499;\n  int d = 0;\n  int t = 0;\n  for (int i = 0; i < 1000000; i++){\n    num[y][x] = i + 1;\n    y += dy[d % 4];\n    x += dx[d % 4];\n    t++;\n    if (t == d / 2 + 1){\n      t = 0;\n      d++;\n    }\n  }\n  vector<bool> prime(1000001, true);\n  prime[0] = false;\n  prime[1] = false;\n  for (int i = 2; i <= 1000000; i++){\n    if (prime[i]){\n      for (int j = i * 2; j <= 1000000; j += i){\n        prime[j] = false;\n      }\n    }\n  }\n  while (1){\n    int m, n;\n    cin >> m >> n;\n    if (m == 0 && n == 0){\n      break;\n    }\n    vector<vector<pair<int, int>>> dp(1000, vector<pair<int, int>>(1000, make_pair(-INF, 0)));\n    for (int i = 0; i < 1000; i++){\n      for (int j = 0; j < 1000; j++){\n        if (num[i][j] == n){\n          if (prime[num[i][j]]){\n            dp[i][j] = make_pair(1, n);\n          } else {\n            dp[i][j] = make_pair(0, 0);\n          }\n        }\n        if (i > 0){\n          for (int k = -1; k <= 1; k++){\n            if (0 <= j + k && j + k < 1000){\n              if (prime[num[i][j]] && num[i][j] <= m){\n                dp[i][j] = max(dp[i][j], make_pair(dp[i - 1][j + k].first + 1, num[i][j]));\n              } else {\n                dp[i][j] = max(dp[i][j], dp[i - 1][j + k]);\n              }\n            }\n          }\n        }\n      }\n    }\n    pair<int, int> ans = make_pair(-INF, 0);\n    for (int i = 0; i < 1000; i++){\n      ans = max(ans, dp[999][i]);\n    }\n    cout << ans.first << ' ' << ans.second << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\n#define N 1050\nusing namespace std;\nint dat[N][N],dp[N][N],ans,ans2;\nint m,n,y,x,p,k,sy,sx,d[N][N];\nint ymin,ymax,xmin,xmax;\nbool prime[N*N];\n\nint main(){\n  int dy[4]={0,-1,0,1};\n  int dx[4]={1,0,-1,0};\n  for(int i=0;i<N*N;i++)prime[i]=true;\n  prime[0]=prime[1]=false;\n  for(int i=0;i<=N*N/2;i++){\n    if(!prime[i])continue;\n    for(int j=i+i;j<N*N;j+=i)prime[j]=false;\n  }\n  while(1){\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)dat[i][j]=-1,dp[i][j]=0,d[i][j]=0;\n    cin>>m>>n;\n    if(!m&&!n)break;\n    sy=sx=y=x=N/2;\n    dat[y][x]=1;\n    k=ymax=xmax=0,p=1;\n    ymin=xmin=INF;\n    while(p<m){\n      p++;\n      int lot=(k+1)%4;\n      if(p!=2&&dat[y+dy[lot]][x+dx[lot]]<0)k=lot;\n      y+=dy[k];\n      x+=dx[k];\n      dat[y][x]=p;\n      ymin=min(ymin,y);\n      xmin=min(xmin,x);\n      ymax=max(ymax,y);\n      xmax=max(xmax,x);\n      if(p==n)sy=y,sx=x;\n    }\n    for(int i=ymax;i>=ymin;i--){\n      for(int j=xmin;j<=xmax;j++){\n\tif(dat[i][j]<0)continue;\n\tdp[i][j]=max(dp[i][j],dp[i+1][j-1]);\n\tdp[i][j]=max(dp[i][j],dp[i+1][j]);\n\tdp[i][j]=max(dp[i][j],dp[i+1][j+1]);\n\tif(prime[dat[i][j]])dp[i][j]++;\n      }\n    }\n    ans=dp[sy][sx];\n    ans2=0;\n    d[sy][sx]=1;\n    for(int i=ymin;i<=ymax;i++){\n      int c=0,c2=0;\n      for(int j=xmin;j<=xmax;j++){\n\tif(d[i][j])c2=max(c2,dp[i][j]);\n      }\n      for(int j=xmin;j<=xmax;j++){\n\tif(c2==dp[i][j]&&d[i][j]){\n\t  if(prime[dat[i][j]])c=max(c,dat[i][j]);\n\t  d[i+1][j+1]=d[i+1][j]=d[i+1][j-1]=1;\n\t}\n      }\n      ans2=max(ans2,c);\n    }\n    if(ans!=0)cout<<ans<<' '<<ans2<<endl;\n    else cout<<0<<' '<<0<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n\n#define int long long\n\nusing namespace std;\n\nclass Solver {\n};\n\nsigned main() {\n\tint edge = 1005;\n\tvector<vector<bool>> prime_grid(edge, vector<bool>(edge));\n\tvector<tuple<int, int>> poses(1);\n\tvector<vector<int>> nums(edge, vector<int>(edge, 1));\n\tposes.emplace_back(make_tuple(edge / 2, edge / 2));\n\tvector<bool> is_prime(edge * edge + 10, true);\n\tfor (int i = 2; i < is_prime.size(); i++) {\n\t\tif (!is_prime[i]) continue;\n\n\t\tfor (int j = 2; i * j < is_prime.size(); j++) {\n\t\t\tis_prime[i * j] = false;\n\t\t}\n\t}\n\n\tint y = edge / 2;\n\tint x = edge / 2 + 1;\n\tint now = 2;\n\tint len = 2;\n\tfor (int i = edge / 2+1; i < edge; i++) {\n\t\tfor (int j = 0; j < len; j++) {\n\t\t\tprime_grid[y][x] = is_prime[now];\n\t\t\tposes.emplace_back(make_tuple(y, x));\n\t\t\tnums[y][x] = now;\n\t\t\ty--;\n\t\t\tnow++;\n\t\t}\n\t\ty++;\n\t\tx--;\n\t\tfor (int j = 0; j < len; j++) {\n\t\t\tprime_grid[y][x] = is_prime[now];\n\t\t\tposes.emplace_back(make_tuple(y, x));\n\t\t\tnums[y][x] = now;\n\t\t\tx--;\n\t\t\tnow++;\n\t\t}\n\t\tx++;\n\t\ty++;\n\t\tfor (int j = 0; j < len; j++) {\n\t\t\tprime_grid[y][x] = is_prime[now];\n\t\t\tposes.emplace_back(make_tuple(y, x));\n\t\t\tnums[y][x] = now;\n\t\t\ty++;\n\t\t\tnow++;\n\t\t}\n\t\ty--;\n\t\tx++;\n\t\tfor (int j = 0; j < len; j++) {\n\t\t\tprime_grid[y][x] = is_prime[now];\n\t\t\tposes.emplace_back(make_tuple(y, x));\n\t\t\tnums[y][x] = now;\n\t\t\tx++;\n\t\t\tnow++;\n\t\t}\n\t\tlen+=2;\n\t}\n\t/*for (int i = 0; i < edge; i++) {\n\t\tfor (int j = 0; j < edge; j++) {\n\t\t\tif (prime_grid[i][j])cout << 1;\n\t\t\telse cout << 0;\n\t\t}\n\t\tcout << endl;\n\t}*/\n\n\twhile (true) {\n\t\tint m, n;\n\t\tcin >> m >> n;\n\t\tif (m == 0)break;\n\n\t\tvector<vector<int>> dp(edge, vector<int>(edge, 0));\n\t\tset<tuple<int, int>> tmp;\n\t\ttmp.emplace(poses[n]);\n\n\t\tint num = 0;\n\t\tint cnt = 0;\n\t\twhile (tmp.size() > 0) {\n\t\t\tvector<vector<int>> next(edge, vector<int>(edge, 0));\n\t\t\tset<tuple<int, int>> pos_tmp;\n\t\t\tfor (auto pos : tmp) {\n\t\t\t\tint y = get<0>(pos);\n\t\t\t\tint x = get<1>(pos);\n\t\t\t\tnext[y][x] = max(max(dp[y - 1][x], dp[y - 1][x - 1]),\n\t\t\t\t\tdp[y - 1][x + 1]);\n\t\t\t\tif (prime_grid[y][x]) {\n\t\t\t\t\tnext[y][x]++;\n\t\t\t\t\tif (cnt < next[y][x] \n\t\t\t\t\t\t|| (cnt == next[y][x] && nums[y][x] > num)) {\n\t\t\t\t\t\tcnt = next[y][x];\n\t\t\t\t\t\tnum = nums[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (nums[y + 1][x] <= m) {\n\t\t\t\t\tpos_tmp.emplace(make_tuple(y + 1, x));\n\t\t\t\t}\n\t\t\t\tif (nums[y + 1][x + 1] <= m) {\n\t\t\t\t\tpos_tmp.emplace(make_tuple(y + 1, x + 1));\n\t\t\t\t}\n\t\t\t\tif (nums[y + 1][x - 1] <= m) {\n\t\t\t\t\tpos_tmp.emplace(make_tuple(y + 1, x - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = next;\n\t\t\ttmp = pos_tmp;\n\t\t}\n\n\t\tcout << cnt << \" \" << num << endl;\n\t}\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define H 1000\n#define W 1000\nusing namespace std;\nint grid[H][W];\ntypedef pair<int, int> pii;\n\npii dp[(int)1e6 + 1];//first cnt, second max\nbool isprime[(int)1e6 + 1];\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid sieve(int n){\n  isprime[0] = isprime[1] = true;\n  for(int i = 2; i <= n; i++){\n    if(isprime[i])continue;\n    for(int j = 2*i; j <= n; j+=i)isprime[j] = true;\n  }\n}\n\n\nbool renge(int x, int y){\n  if(0 <= x && x < W &&\n     0 <= y && y < H)return true;\n  return false;\n}\nvector<int> inM(int y, int x, int m){\n  vector<int> res;\n  if(y + 1 >= H) return res;\n  for(int i = -1; i < 2; i++){\n    if(x + i < 0 || W <= x + i )continue;\n    if(grid[y + 1][x + i] <= m)res.push_back(i);\n  }\n  return res;\n}\n\nint main(int argc, char *argv[]){\n  sieve((int)1e6);\n  int n = H*W, m, x = 0, y = 0, dir = 0;\n  while(n > 0){\n    for(;renge(x + dx[dir], y + dy[dir]) && \n\t  grid[y + dy[dir]][x + dx[dir]] == 0;){\n      grid[y][x] = n;\n      n--;\n      x += dx[dir], y += dy[dir];\n    }\n    grid[y][x] = n;\n    n--;\n    dir++;\n    dir %= 4;\n    x += dx[dir], y += dy[dir];\n  }\n  while(cin >> m >> n, n){\n    memset(dp, 0, sizeof(dp));\n    for(int i = H - 1; i >= 0; i--){\n      for(int j = 0; j < W; j++){\n\tif(grid[i][j] <= m){\n\t  vector<int> cand = inM(i, j, m);\n\t  for(int k = 0; k < cand.size(); k++){\n\t    dp[grid[i][j]] = max(dp[grid[i][j]], dp[grid[i + 1][j + cand[k]]]);\n\t  }\n\t  if(!isprime[grid[i][j]]){\n\t    if(dp[grid[i][j]].first == 0)dp[grid[i][j]].second = grid[i][j];\n\t    dp[grid[i][j]].first++;\n\t  }\n\t}\n      }\n    }\n    cout << dp[n].first << \" \" << dp[n].second << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define SIZE 1000\n\nbool C(int dp1, int pr1, int dp2, int pr2) {\n\tif (dp2 == 0)return false;\n\tif (dp1 < dp2 || (dp1 == dp2&&pr1 < pr2))return true;\n\treturn false;\n}\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x - 1], pr[y + 1][x - 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x], pr[y + 1][x])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x + 1], pr[y + 1][x + 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}*/\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\n\t\toutput = false;\n\t\tfor (int i = 0;i < SIZE&&!output;i++) {\n\t\t\tfor (int j = 0;j < SIZE&&!output;j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tprintf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\n\nconst Int N = 1123456;\nbool is_prime[N];\nconst Int inf = 1LL << 50;\n\nint main() {\n   for(Int i = 0; i < N; ++i) {\n      is_prime[i] = true;\n   }\n   is_prime[0] = is_prime[1] = false;\n   for(Int i = 2; i * i < N; ++i) {\n      if( is_prime[i] ) {\n         for(Int k = 2*i; k < N; k+=i) {\n            is_prime[k] = false;\n         }\n      }\n   }\n   for(;;) {\n      Int n, m;\n      std::cin >> m >> n;\n      if( n == 0 and m == 0 ) break;\n      auto field = std::vector<std::vector<Int>>(1024, std::vector<Int>(1024, -1));\n      Int y = 512;\n      Int x = 512;\n      Int dx[] = {1, 0,-1, 0};\n      Int dy[] = {0,-1, 0, 1};\n      Int k = 3;\n      Int i = 1;\n      while( i <= m ) {\n         field[y][x] = i;\n         i += 1;\n         {\n            Int nx = x + dx[(k+1)%4], ny = y + dy[(k+1)%4];\n            if( field[ny][nx] == -1 ) {\n               k = (k+1) % 4;\n            }\n         }\n         Int nx = x + dx[k], ny = y + dy[k];\n         x = nx;\n         y = ny;\n      }\n      auto dp = std::vector<std::vector<std::pair<Int,Int>>>(1024, std::vector<std::pair<Int,Int>>(1024, std::make_pair(-inf,-1)));\n      for(Int y = 0; y < 1024; ++y) {\n         for(Int x = 0; x < 1024; ++x) {\n            if( field[y][x] == n ) {\n               dp[y][x] = std::make_pair(0, field[y][x]);\n            }\n         }\n      }\n      for(Int y = 1; y < 1024; ++y) {\n         for(Int x = 0; x < 1024; ++x) {\n            if( x-1 >= 0 ) {\n               if( dp[y][x].first < dp[y-1][x-1].first ) {\n                  dp[y][x] = dp[y-1][x-1];\n               }\n            }\n            if( dp[y][x].first < dp[y-1][x].first ) {\n               dp[y][x] = dp[y-1][x];\n            }\n            if( x+1 < 1024 ) {\n               if( dp[y][x].first < dp[y-1][x+1].first ) {\n                  dp[y][x] = dp[y-1][x+1];\n               }\n            }\n            if( is_prime[field[y][x]] ) {\n               dp[y][x].first += 1;\n               dp[y][x].second = field[y][x];\n            }\n         }\n      }\n      std::pair<Int,Int> res(-inf,-1);\n      for(Int y = 0; y < 1024; ++y) {\n         for(Int x = 0; x < 1024; ++x) {\n            if( res < dp[y][x] ) {\n               res = dp[y][x];\n            }\n         }\n      }\n      if( res.first == 0 ) {\n         res.second = 0;\n      }\n      std::cout << res.first << ' ' << res.second << std::endl;\n   }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iomanip>\n#include<iostream>\n#include<map>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n#define X first\n#define Y second\nconst int mem_max = 1100;\nconst int mm_max = mem_max*mem_max+100;\nstruct F{\n  int prime[mm_max];\n  pii mem2[mm_max];\n  int mem[mem_max][mem_max];\n  public: void init(){\n    make_prime();\n    for(int i=0;i<mem_max;i++){\n      for(int j=0;j<mem_max;j++){\n        mem[i][j]=-1;\n      }\n    } \n    int x=0,y=0;\n    int c=1;\n    int dx=1,dy=1;\n    int vx=1,vy=-1;\n    w(x,y,c);\n    while(1){\n      for(int i=0;i<dx;i++){\n        x+=vx;c++;if(!(c<=mem_max*mem_max))break;\n        w(x,y,c);\n      }\n      if(!(c<=mem_max*mem_max))break;\n      vx*=-1;\n      dx++;\n      for(int i=0;i<dy;i++){\n        y+=vy;c++;if(!(c<mem_max*mem_max))break;\n        w(x,y,c);\n      }\n      if(!(c<=mem_max*mem_max))break;\n      vy*=-1;\n      dy++;\n    }\n    for(int i=0;i<mem_max;i++){\n      for(int j=0;j<mem_max;j++){\n        mem2[mem[i][j]] = pii(i-mem_max/2,j-mem_max/2); \n      }\n    }\n  }\n  private:\n  void make_prime(){\n    for(int i=2;i<mm_max;i++){\n      prime[i]=1;\n    }\n    for(int i=0;i*i<=mm_max;i++){\n      if(prime[i])for(int j=i*2;j<mm_max;j+=i){\n        prime[j]=0;\n      }\n    }\n  }\n  int res(int x){\n    x+=mem_max/2;\n    if(x<0||mem_max<=x)return -1;\n    return x;\n  }\n  int w(int x,int y,int m){\n    if(-1==(x = res(x))) return -1;\n    if(-1==(y = res(y))) return -1;\n    mem[x][y]=m;\n    return mem[x][y];\n  }\n  public:\n  int g(int x,int y){\n    if(-1==(x = res(x))) return -1;\n    if(-1==(y = res(y))) return -1;\n    return mem[x][y];\n  }\n  int num(int x,int y){return g(x,y);}\n  pii pos(int n){\n    return mem2[n];\n  }\n  bool is_prime(int x,int y){\n    int tmp = g(x,y);\n    return prime[tmp];\n  }\n};\nF f;\n\n#define DEBUG 0\nvoid print(){\n  if(!DEBUG)return ;\n  for(int i=0;i<20;i++){\n    for(int j=0;j<20;j++){\n      cout<<setw(4)<<f.g(j-10,i-10);\n    }cout<<endl;\n  }cout<<endl;\n\n  for(int i=0;i<20;i++){\n    cout<<f.pos(i+1).X<<\" \"<<f.pos(i+1).second<<endl;\n  }\n}\nint m;\nvector<pii> dp;\npii req(int x,int y){\n  if(f.num(x,y)<0 || f.num(x,y)>=(int)dp.size())return pii();\n  if(dp[f.num(x,y)].X!=-1)return dp[f.num(x,y)];\n  if(f.num(x,y)>m)return pii();\n  pii res = pii(0,0);\n  for(int i=-1;i<=1;i++){\n    pii tmp = req(x+i,y+1);\n    res = max(tmp,res);\n  }\n  if(f.is_prime(x,y)){\n    if(res.first == 0){\n      res.second = f.num(x,y);\n    }\n    res.first++;\n  }\n  return dp[f.num(x,y)]=res;\n}\n\n\npii solve(int n){\n  dp.clear();dp.resize(m+100);\n  for(int i=0;i<(int)dp.size();i++){\n    dp[i] = pii(-1,-1);\n  }\n  return req(f.pos(n).X,f.pos(n).Y);\n}\n\nint main(){\n  print();\n  f.init();\n  int n;\n  while(1){\n    cin>>m>>n;\n    if(n==0&&m==0)break;\n    pii ans = solve(n);\n    cout<<ans.first<<\" \"<<ans.second<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX = 1500;\nint cave[MAX][MAX];\nint toIndex[1000010];\nint dp[MAX][MAX];\nint dx[] = {+1,+0,-1,+0};\nint dy[] = {+0,-1,+0,+1};\n\nbool isValid(int x,int y) { return 0 <= x && x < MAX && 0 <= y && y < MAX; }\n\nvoid pre_calc(){\n  memset(cave,-1,sizeof(cave));\n  int phase = 1;\n  int x = MAX/2, y = MAX/2, dir = 0;\n  while( phase <= 1000000 ){\n    toIndex[phase] = x + y * MAX;\n    cave[y][x] = phase++;\n    x += dx[dir], y += dy[dir];\n    if( cave[y+dy[(dir+1)%4]][x+dx[(dir+1)%4]] == -1 ) ( dir += 1 ) %= 4;\n  }\n}\n\nconst int  MAX_P = 1000010;\n\nbool isntprime[MAX_P+1]; \t\nvoid init(){\n  isntprime[0] = isntprime[1] = true;\n  int j;\t\n  for(int i=2;i<= MAX_P;i++)if(!isntprime[i])for(j=2*i;j<=MAX_P;j+=i)isntprime[j] = true;\n}\n\n\nvoid compute(int limit,int sp){\n  memset(dp,-1,sizeof(dp));\n  int sx = toIndex[sp] % MAX, sy = toIndex[sp] / MAX;\n  dp[sy][sx] = !isntprime[sp];\n  int maxi[2] = {0,0};\n  if( dp[sy][sx] > maxi[0] ) { maxi[0] = dp[sy][sx], maxi[1] = sp; }\n  REP(y,sy,MAX) rep(x,MAX) if( dp[y][x] != -1) {\n    for(int dx=-1;dx<=1;dx++){\n      int nx = x + dx, ny = y + 1;\n      if( !isValid(nx,ny) ) continue;\n      if( cave[ny][nx] > limit || cave[ny][nx] == -1 ) continue;\n      dp[ny][nx] = max(dp[ny][nx],dp[y][x]+!isntprime[cave[ny][nx]]);\n      if( !isntprime[cave[ny][nx]] ) {\n        if( dp[ny][nx] > maxi[0] ) { maxi[0] = dp[ny][nx]; maxi[1] = cave[ny][nx]; }\n        else if( dp[ny][nx] == maxi[0] ) maxi[1] = max(maxi[1],cave[ny][nx]);\n      }\n    }\n  }\n  cout << maxi[0] << \" \" << maxi[1] << endl;\n}\n\nint main(){\n  init();\n  pre_calc();\n  int m,n;\n  while( cin >> m >> n, m,n ) compute(m,n);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define MAX_N 1000000\n#define MAX_X 1000\n#define MAX_Y 1000\n\nint cave[MAX_Y][MAX_X];\nbool sieve[MAX_N+1];\nint dp[MAX_N+1];\n\nint m, n;\n\nstruct P { int x, y; };\n\nP search_cave(int n) {\n    REP(y, MAX_Y) REP(x, MAX_X) {\n        if (cave[y][x] == n) {\n            return (P){x, y};\n        }\n    }\n    return (P){0, 0}; // fail\n}\n\nint main() {\n    sieve[0] = sieve[1] = true;\n    FOR(i, 2, MAX_N+1) {\n        if (sieve[i]) continue;\n        for (int j = i + i; j < MAX_N+1; j += i) {\n            sieve[j] = true;\n        }\n    }\n\n    int ul = cave[0][0] = MAX_N;\n    // left -> down -> right -> up ->\n    int d = 0;\n    int dx[] = {1, 0, -1, 0}; int dy[] = {0, 1, 0, -1};\n    int x = 0, y = 0;\n    while (ul > 1) {\n        int sx = x + dx[d];\n        int sy = y + dy[d];\n        if (0 <= sx && sx < MAX_X && 0 <= sy && sy < MAX_Y && cave[sy][sx] == 0) {\n            x = sx;\n            y = sy;\n            ul--;\n            cave[y][x] = ul;\n        } else {\n            d = (d + 1) & 3; // d % 4\n        }\n    }\n\n    while (cin >> m >> n, m|n) {\n        fill_n(dp, MAX_N+1, -1);\n        P s = search_cave(n);\n        dp[n] = 0;\n        int max_primes = 0, max_cave = 0;\n        FOR(y, s.y, MAX_Y) REP(x, MAX_X) {\n            int c = cave[y][x];\n            if (c > m || dp[c] < 0) continue;\n            if (!sieve[c]) { // prime\n                dp[c]++;\n                if (max_primes < dp[c]) {\n                    max_primes = dp[c];\n                    max_cave = c;\n                } else if (max_primes == dp[c]) {\n                    max_cave = max(max_cave, c);\n                }\n            }\n            for (int dx = -1; dx <= 1; dx++) {\n                int sx = x + dx;\n                int sy = y + 1;\n                if (0 <= sx && sx < MAX_X && 0 <= sy && sy < MAX_Y) {\n                    int c2 = cave[sy][sx];\n                    if (c2 <= m) {\n                        dp[c2] = max(dp[c2], dp[c]);\n                    }\n                }\n            }\n        }\n        cout << max_primes << \" \" << max_cave << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint m, n;\nvector<vector<pair<bool, int> > > mp(1001, vector<pair<bool, int> >(1001, pair<bool, int>(false, 0)));\nvector<vector<P> > memo(1001, vector<P>(1001, P(-1, -1)));\nP dfs(P np) {\n\tif(memo[np.first][np.second].first != -1) {\n\t\treturn memo[np.first][np.second];\n\t}\n\tif(np.first < 0 || np.first >= 1001 || np.second < 0 || np.second >= 1001 || mp[np.first][np.second].second > m) {\n\t\treturn P(0, 0);\n\t}\n\tP res;\n\tres = max(max(dfs(P(np.first + 1, np.second)), dfs(P(np.first + 1, np.second - 1))), dfs(P(np.first + 1, np.second + 1)));\n\tif(mp[np.first][np.second].first) {\n\t\treturn memo[np.first][np.second] = max(P(1, mp[np.first][np.second].second), P(res.first + 1, res.second));\n\t} else {\n\t\treturn memo[np.first][np.second] = max(P(0, mp[np.first][np.second].second), P(res.first, res.second));\n\t}\n}\n\nint main(void) {\n\tvector<bool> prime(1001 * 1001 + 1, true);\n\tprime[0] = prime[1] = false;\n\tFOR(i, 2, 1001 * 1001 + 1) {\n\t\tif(prime[i]) {\n\t\t\tfor(ll j = 2; i * j <= 1001 * 1001; ++j) {\n\t\t\t\tprime[i * j] = false;\n\t\t\t}\n\t\t}\n\t}\n\tP cp = P(500, 500);\n\tll cnt = 1;\n\tll size = 1;\n\tll lim = 1;\n\twhile(cnt <= 1001 * 1001) {\n\t\tmp[cp.first][cp.second].second = cnt;\n\t\tif(prime[cnt]) mp[cp.first][cp.second].first = true;\n\t\t--lim;\n\t\tif(lim == 0) {\n\t\t\tsize += 2;\n\t\t\t++cp.second;\n\t\t\tlim = size * size - (size - 2) * (size - 2);\n\t\t} else {\n\t\t\tif(lim >= 2 * (size - 1) + size) {\n\t\t\t\t--cp.first;\n\t\t\t} else if(lim >= (size - 1) + size) {\n\t\t\t\t--cp.second;\n\t\t\t} else if(lim >= size) {\n\t\t\t\t++cp.first;\n\t\t\t} else {\n\t\t\t\t++cp.second;\n\t\t\t}\n\t\t}\n\t\t++cnt;\n\t}\n\twhile(true) {\n\t\tcin>>m>>n;\n\t\tif(m == 0 && n == 0) break;\n\t\tP sp;\n\t\tbool upd = false;\n\t\tREP(i, 1001) {\n\t\t\tREP(j, 1001) {\n\t\t\t\tif(mp[i][j].second == n) {\n\t\t\t\t\tsp.first = i;\n\t\t\t\t\tsp.second = j;\n\t\t\t\t\tupd = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(upd) break;\n\t\t}\n\t\tREP(i, 1001) {\n\t\t\tREP(j, 1001) {\n\t\t\t\tmemo[i][j].first = memo[i][j].second = -1;\n\t\t\t}\n\t\t}\n\t\tP ans = dfs(sp);\n\t\tif(ans.first == 0) cout<<0<<\" \"<<0<<endl;\n\t\telse cout<<ans.first<<\" \"<<ans.second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\n    //エラトステネスの篩\n    vector<bool> prime(1000010, true);     //1000000までで、素数ならtrue\n    prime[0] = prime[1] = false;\n    for(int i = 2; i < 1000010; i++){\n        if(prime[i] == true){\n            for(int j = 2*i; j < 1000010; j += i){\n                prime[j] = false;\n            }\n        }\n    }\n\n    map<pair<int, int>, int> M;\n    map<int, pair<int, int> > _M;\n    int num = 1;\n    int T = 1;\n    M[{0, 0}] = num;\n    _M[num] = {0, 0};\n    num++;\n    int i = 0;\n    int j = 0;\n\n    while(num < 1000010){\n\n        j++;\n        M[{i, j}] = num;\n        _M[num] = {i, j};\n        num++;\n        for(int r = 0; r < T; r++){\n            i--;\n            M[{i, j}] = num;\n            _M[num] = {i, j};        \n            num++;\n        }\n\n        j--;\n        M[{i, j}] = num;\n        _M[num] = {i, j};\n        \n        num++;\n        for(int r = 0; r < T; r++){\n            j--;\n            M[{i, j}] = num;\n            _M[num] = {i, j};        \n            num++;\n        }\n\n        i++;\n        M[{i, j}] = num;\n        _M[num] = {i, j};\n        \n        num++;\n        for(int r = 0; r < T; r++){\n            i++;\n            M[{i, j}] = num;\n            _M[num] = {i, j};\n            \n            num++;\n        }\n\n        j++;\n        M[{i, j}] = num;\n        _M[num] = {i, j};\n        \n        num++;\n        for(int r = 0; r < T; r++){\n            j++;\n            M[{i, j}] = num;\n            _M[num] = {i, j};\n            \n            num++;\n        }\n\n        T += 2;\n    }\n\n    /*for(int i = -10; i <= 10; i++){\n        for(int j = -10; j <= 10; j++){\n            printf(\"%.2d \", M[{i, j}]);\n        }\n        cout << endl;\n    }*/\n    \n\n    while(1){\n        int m, n; cin >> m >> n;\n        if(n == 0) break;    \n\n        //幅優先\n        map<pair<int, int>, int> dp;\n        queue<pair<int, int> > que;\n        int si = _M[n].first;\n        int sj = _M[n].second;\n        que.push({si, sj});\n        dp[{si, sj}] = prime[n] ? 1 : 0;\n    \n        int ans1 = 0;\n        int ans2 = 0;\n\n        while(!que.empty()){\n\n            int i = que.front().first;\n            int j = que.front().second;\n\n            if(dp[{i, j}] >= ans1 && prime[M[{i, j}]]){\n                ans1 = dp[{i, j}];\n                ans2 = M[{i, j}];\n            }\n\n            que.pop();\n\n            int ni = i + 1;\n            //3つ\n\n            for(int dj = -1; dj <= 1; dj++){\n                int nj = j + dj;\n                int next_num = M[{ni, nj}];\n                if(next_num > m || next_num == 0) continue;\n\n                int v = dp[{i, j}] + ((prime[next_num]) ? 1 : 0);\n                if(v > dp[{ni, nj}]){\n                    dp[{ni, nj}] = v;\n                    que.push({ni, nj});\n                }\n            }\n            \n        }\n\n    cout << ans1 << \" \" << ans2 << endl;\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main(){\n  vector<vector<int> > cave(2000,vector<int>(2000,1e6+1));\n  vector<int> xp(1e6+1);\n  vector<int> yp(1e6+1);\n  int l=1;\n  int x=1000;\n  int y=1000;\n  xp[1]=x;\n  yp[1]=y;\n  cave[x][y]=1;\n\n  for(int i=2;i<1e6+1;i++){\n    for(int j=0;j<l;j++){\n      x++;\n      cave[x][y]=i;\n      xp[i]=x;\n      yp[i]=y;\n      i++;\n      if(i>1e6+1)break;\n    }\n    if(i>1e6+1)break;\n    for(int j=0;j<l;j++){\n      y--;\n      cave[x][y]=i;\n      xp[i]=x;\n      yp[i]=y;\n      i++;\n      if(i>1e6+1)break;\n    }\n    if(i>1e6+1)break;\n    l++;\n    for(int j=0;j<l;j++){\n      x--;\n      cave[x][y]=i;\n      xp[i]=x;\n      yp[i]=y;\n      i++;\n      if(i>1e6+1)break;\n    }\n    if(i>1e6+1)break;\n    for(int j=0;j<l;j++){\n      y++;\n      cave[x][y]=i;\n      xp[i]=x;\n      yp[i]=y;\n      if(j!=l-1)i++;\n      if(i>1e6+1)break;\n    }\n    if(i>1e6+1)break;\n    l++;\n  }\n\n  /*\n  for(int i=1490;i<1510;i++){\n    for(int j=1490;j<1510;j++){\n      cout<<cave[j][i]<<\" \";\n    }\n    cout<<endl;\n  }\n  */\n\n  vector<int> prime(1e6+2,1);\n  prime[1e6+1]=0;\n  prime[1]=0;\n  for(int i=2;i<prime.size();i++){\n    if(prime[i]){\n      for(int j=i+i;j<prime.size();j+=i)prime[j]=0;\n    }\n  }\n\n  //for(int i=0;i<1e6;i++)if(prime[i])cout<<i<<\" \";\n\n\n  while(1){\n    int m,n;\n    cin>>m>>n;\n    if(m==0&&n==0)break;\n    vector<vector<int> > bfs(2000,vector<int>(2000,0));\n    vector<int> used(1e6+1,1);\n    queue<int> q;\n    q.push(n);\n    while(!q.empty()){\n      int np=q.front();\n      //cout<<np<<endl;\n      q.pop();\n      if(used[cave[xp[np]-1][yp[np]+1]]&&cave[xp[np]-1][yp[np]+1]<=m){\n        q.push(cave[xp[np]-1][yp[np]+1]);\n        used[cave[xp[np]-1][yp[np]+1]]=0;\n      }\n      if(used[cave[xp[np]][yp[np]+1]]&&cave[xp[np]][yp[np]+1]<=m){\n        q.push(cave[xp[np]][yp[np]+1]);\n        used[cave[xp[np]][yp[np]+1]]=0;\n      }\n      if(used[cave[xp[np]+1][yp[np]+1]]&&cave[xp[np]+1][yp[np]+1]<=m){\n        q.push(cave[xp[np]+1][yp[np]+1]);\n        used[cave[xp[np]+1][yp[np]+1]]=0;\n      }\n      bfs[xp[np]][yp[np]]=max(bfs[xp[np]-1][yp[np]-1],max(bfs[xp[np]][yp[np]-1],bfs[xp[np]+1][yp[np]-1]))+prime[np];\n      //if(prime[np])bfs[xp[np]][yp[np]]++;\n    }\n\n    /*\n    for(int i=995;i<1005;i++){\n      for(int j=995;j<1005;j++){\n        cout<<bfs[j][i]<<\" \";\n      }\n      cout<<endl;\n    }\n    */\n\n    int ans=0;\n    int id=0;\n    for(int i=0;i<m;i++){\n      //cout<<i<<\" \"<<bfs[xp[i]][yp[i]]<<endl;\n      if(ans<bfs[xp[i]][yp[i]]&&prime[i]){\n        ans=bfs[xp[i]][yp[i]];\n        id=cave[xp[i]][yp[i]];\n      }\n      if(ans!=0&&ans==bfs[xp[i]][yp[i]]&&prime[i]){\n        ans=bfs[xp[i]][yp[i]];\n        id=max(id,cave[xp[i]][yp[i]]);\n      }\n    }\n    cout<<ans<<\" \"<<id<<endl;\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n// Prime Caves\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1189&lang=jp \n\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\nstruct Point { int x, y; Point(int _x, int _y) : x(_x), y(_y) {} };\n\nconst int MAX = 1010;\nconst int OFFSET = 505;\n\nconst int RIGHT = 0, TOP = 1, LEFT = 2, BOTTOM = 3;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\nconst int PRIME_MAX = 1000010;\nbool is_prime[PRIME_MAX];\n\nint M, N;\nvector<vector<int>> caves;\nvector<vector<pair<int, int>>> dp;\n\nint next_direction(int x, int y) {\n    if (caves[y][x+1] != 0 && caves[y+1][x] == 0) return BOTTOM;\n    if (caves[y+1][x] != 0 && caves[y][x-1] == 0) return LEFT;\n    if (caves[y][x-1] != 0 && caves[y-1][x] == 0) return TOP;\n    return RIGHT;\n}\n\nvoid make_cave(int m) {\n    dp.assign(MAX, vector<pair<int, int>>(MAX, {0, 0}));\n    caves.assign(MAX, vector<int>(MAX, 0));\n    int x = OFFSET, y = OFFSET;\n    for (int i = 1; i <= m; ++i) {\n        int d = next_direction(x, y);\n        x += dx[d]; y += dy[d];\n        caves[y][x] = i;\n    }\n}\n\nPoint get_start_point(int n) {\n    for (int y = 0; y < MAX; ++y) {\n        for (int x = 0; x < MAX; ++x) {\n            if (caves[y][x] != n) continue;\n            return {x, y};\n        }\n    }\n    return {-1, -1};\n}\n\nvoid show() {\n    for (int i = OFFSET - 10; i <= OFFSET + 10; ++i) {\n        for (int j = OFFSET - 10; j <= OFFSET + 10; ++j) {\n            cout << caves[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n\ninline pair<int, int> dfs(int x, int y) {\n\n    if (caves[y][x] == 0) return {0, 0};\n    if(dp[y][x].first != 0) return dp[y][x];    \n\n    pair<int, int> res = {0, 0};\n    for (int dx = -1; dx <= 1; ++dx) {\n        res = max(res, dfs(x + dx, y + 1));\n    }\n    \n    if (is_prime[caves[y][x]]) {\n        if (res.first == 0) res.second = caves[y][x];\n        res.first++;\n    }\n\n    dp[y][x] = res;\n    return res;\n}\n\nint main() { \n\n    is_prime[0] = false;\n    is_prime[1] = false;\n    for (int i = 2; i < PRIME_MAX; ++i) is_prime[i] = true;\n    for (int i = 2; i < PRIME_MAX; ++i) {\n        if (is_prime[i]) {\n            for (int j = i+i; j < PRIME_MAX; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    while (cin >> M >> N) {\n        if (M == 0) break;\n        make_cave(M);\n        Point sp = get_start_point(N);\n        pair<int, int> ans = dfs(sp.x, sp.y);\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<queue>\n\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vector<int> >;\nusing pii = pair<int, int>;\nusing ppi = pair<pii, int>;\n\nint f_dir[2][4] = {{-1, 0, 1, 0}, {0, 1, 0, -1}}; //↑→↓←\nint e_dir[2][8] = {{-1, -1, -1, 0, 0, 1, 1, 1}, {-1, 0, 1, -1, 1, -1, 0, 1}};\nbool is_in_field(int y, int x, int h, int w){\n  return (y >= 0 && y < h && x >= 0 && x < w);\n}\nvvi caves(1500, vi(1500, -1));\nvi is_p(1000001, 1);\nvector<pii> inv(1000001, pii(-1, -1));\nvvi dp;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int ti = clock();\n  // start-----------------------------------------------\n  is_p[1] = 0;\n  for(int i = 2; i <= 1000000; i++){\n    int j = 2;\n    while(i * j <= 1000000){\n      is_p[i*j] = 0;\n      j++;\n    }\n  }\n  int y = 750, x = 750, dir = 2;\n  for(int i = 1; i <= 1000000; i++){\n    caves[y][x] = i;\n    inv[i] = {y, x};\n    if(caves[y+f_dir[0][(4+dir-1)%4]][x+f_dir[1][(4+dir-1)%4]] == -1){\n      dir = (4+dir-1) % 4;\n    }\n    y += f_dir[0][dir];\n    x += f_dir[1][dir];\n  }\n\n  int m, n;\n  while(cin >> m >> n, m){\n    dp = vvi(1500, vi(1500, -1));\n    pii st = inv[n];\n    pii ans = {0, 0};\n    dp[st.first][st.second] = 0;\n    for(int i = st.first; i < 1500; i++){\n      for(int j = 0; j < 1500; j++){\n        if(caves[i][j] > m || caves[i][j] == -1 || dp[i][j] == -1) continue;\n        if(is_p[caves[i][j]]){\n          dp[i][j]++;\n          if(dp[i][j] > ans.first || (dp[i][j] == ans.first && caves[i][j] > ans.second)){\n            ans = {dp[i][j], caves[i][j]};\n          }\n        }\n        for(int k = -1; k <= 1; k++){\n          if(!is_in_field(i+1, j+k, 1500, 1500)) continue;\n          dp[i+1][j+k] = max(dp[i+1][j+k], dp[i][j]);\n        }\n      }\n    }\n    cout << ans.first << ' ' << ans.second << endl;\n  }\n\n  // end-----------------------------------------------\n  // cerr << 1.0 * (clock() - ti) / CLOCKS_PER_SEC << endl;\n}\n\n// #include<iostream>\n// #include<algorithm>\n// #include<math.h>\n//\n// using namespace std;\n//\n// int m,n;\n// int prime[1002001] = {};\n// int tonumber[1001][1001] = {};\n// int topoint[1002001][2] = {};\n// int dp[1001][1001][2] = {};\n// int fp[1001][1001];\n//\n// int dfs(int x, int y){\n//   if(x < 0 || x > 1000 || y < 0 || y > 1000) return 0;\n//   if(tonumber[x][y] == 0) return 0;\n//   fp[x][y] = 1;\n//   if(x > 0 && y < 1000) if(!fp[x-1][y+1])dfs(x-1, y+1);\n//   if(y < 1000) if(!fp[x][y+1])dfs(x, y+1);\n//   if(x < 1000 && y < 1000) if(!fp[x+1][y+1])dfs(x+1, y+1);\n//   dp[x][y][0] = dp[x][y+1][0];\n//   dp[x][y][1] = dp[x][y+1][1];\n//   if(tonumber[x-1][y+1] != 0){\n//     if(dp[x][y][0] == dp[x-1][y+1][0]){\n//       dp[x][y][0] = dp[x-1][y+1][0];\n//       dp[x][y][1] = max(dp[x][y][1], dp[x-1][y+1][1]);\n//     }\n//     if(dp[x][y][0] < dp[x-1][y+1][0]){\n//       dp[x][y][0] = dp[x-1][y+1][0];\n//       dp[x][y][1] = dp[x-1][y+1][1];\n//     }\n//   }\n//   if(tonumber[x+1][y+1] != 0){\n//     if(dp[x][y][0] == dp[x+1][y+1][0]){\n//       dp[x][y][0] = dp[x+1][y+1][0];\n//       dp[x][y][1] = max(dp[x][y][1], dp[x+1][y+1][1]);\n//     }\n//     if(dp[x][y][0] < dp[x+1][y+1][0]){\n//       dp[x][y][0] = dp[x+1][y+1][0];\n//       dp[x][y][1] = dp[x+1][y+1][1];\n//     }\n//   }\n//   if(prime[tonumber[x][y]] == 1){\n//     dp[x][y][0]++;\n//     if(dp[x][y][0] == 1){\n//       dp[x][y][1] = tonumber[x][y];\n//     }\n//   }\n//   return 0;\n// }\n//\n// int main(){\n//   for(int i = 2; i < 1002001; i++) prime[i] = 1;\n//   for(int i = 2; i < 60000; i++){\n//     if(prime[i] == 0) continue;\n//     for(int j = 2; i * j < 1002001; j++){\n//       prime[i*j] = 0;\n//     }\n//   }\n//   int x,y;\n//   while(cin >> m >> n && m != 0){\n//     x = 500;\n//     y = 500;\n//     int k = 1;\n//\n//     for(int i = 0; i <= 1000; i++){\n//       for(int j = 0; j <= 1000 ; j++){\n//         dp[i][j][0] = 0;\n//         dp[i][j][1] = 0;\n//         tonumber[i][j] = 0;\n//         fp[i][j] = 0;\n//       }\n//     }\n//     tonumber[x][y] = 1;\n//     topoint[1][0] = x;\n//     topoint[1][1] = y;\n//     for(int i = 1; i <= m; i++){\n//       for(int t = 0 ; t < k && i < m; t++){\n//         x++;\n//         i++;\n//         topoint[i][0] = x;\n//         topoint[i][1] = y;\n//         tonumber[x][y] = i;\n//       }\n//       for(int t = 0; t < k && i < m; t++){\n//         y--;\n//         i++;\n//         topoint[i][0] = x;\n//         topoint[i][1] = y;\n//         tonumber[x][y] = i;\n//       }\n//       k++;\n//       for(int t = 0 ; t < k && i < m; t++){\n//         x--;\n//         i++;\n//         topoint[i][0] = x;\n//         topoint[i][1] = y;\n//         tonumber[x][y] = i;\n//       }\n//       for(int t = 0; t < k && i < m; t++){\n//         y++;\n//         i++;\n//         topoint[i][0] = x;\n//         topoint[i][1] = y;\n//         tonumber[x][y] = i;\n//       }\n//       if(i == m) break;\n//       else i--;\n//       k++;\n//     }\n//     int a = dfs(topoint[n][0], topoint[n][1]);\n//     if(dp[topoint[n][0]][topoint[n][1]][0] == 0) cout << \"0 0\" << endl;\n//     else cout << dp[topoint[n][0]][topoint[n][1]][0] << ' ' << dp[topoint[n][0]][topoint[n][1]][1] << endl;\n//   }\n// }\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\nDef inf = sizeof(Def) == sizeof(long long) ?  2e18:1e9+10;\nint dx[]={0,-1,0,1};\nint dy[]={1,0,-1,0};\nint d[1010][1010],dp[1010][1010];\nint main(){\n\tint sosu[1100000]={1,1,0};//1 is not sosu\n\tfor(int i=2;i*i<1100000;i++)if(sosu[i]==0)\n\tfor(int j=i*2;j<1100000;j+=i)sosu[j]=1;\n\t\n\tint x=500,y=500,to=0,go=1,num=2;\n\trep(i,1010)rep(j,1010)d[i][j]=0;\n\td[x][y]=1;\n\twhile(1){\n\t\trep(i,2){\n\t\t\trep(j,go){\n\t\t\t\tx+=dx[to];y+=dy[to];\n\t\t\t\tif(x<0||y<0||x>1009||y>1009)goto end;\n\t\t\t\td[x][y]=num++;\n\t\t\t}\n\t\t\tto++;\n\t\t\tif(to==4)to=0;\n\t\t}\n\t\tgo++;\n\t}\n\tend:;\n\t\n//\tloop(x,490,510){loop(y,490,510)cout<<\" \"<<d[x][y];cout<<endl;}\n\t\t\n\tint n,m;\n\twhile(cin>>m>>n,n){\n\t\trep(i,1010)rep(j,1010)dp[i][j]=-inf;\n\t\trep(i,1010)rep(j,1010)if(d[i][j]==n)dp[i][j]=0;//!sosu[d[i][j]];\n\t\trep(i,1009)loop(j,1,1009){\n\t\t\tint e=!sosu[d[i][j]];\n\t\t\tif(d[i][j]>m)e=0;\n//\t\t\tcout<<\"! \"<<i<<\" \"<<j<<endl;\n\t\t\tdp[i+1][j]=max(dp[i+1][j],dp[i][j]+e);\n\t\t\tdp[i+1][j-1]=max(dp[i+1][j-1],dp[i][j]+e);\n\t\t\tdp[i+1][j+1]=max(dp[i+1][j+1],dp[i][j]+e);\n\t\t}\n\t\tint ma=-1,a;\n\t\trep(i,1010)rep(j,1010)if(d[i][j]<=m&&sosu[d[i][j]]==0){\n\t\t\tdp[i][j]++;\n\t\t\tif(dp[i][j]>ma){\n\t\t\t\tma=dp[i][j];\n\t\t\t\ta=d[i][j];\n\t\t\t}else if(dp[i][j]==ma)a=max(a,d[i][j]);\n\t\t}\n\t\tif(ma==-1)ma=a=0;\n\t\tcout<<ma<<\" \"<<a<<endl;\n\t\t\n\t}\n\t\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\nusing namespace std;\n#define N 1000000\ntypedef pair<int,int>P;\nbool isprime[N+1];\nint cave [1000][1000];\nint xindex[N+1];\nint yindex[N+1];\nP dp[1000][1000];\n\nint m,n;\n\nP find(int cx,int cy){\n\tP ans;\n\tif(isprime[n])\n\t\tdp[cx][cy].first=1,dp[cx][cy].second=cave[cx][cy];\n\telse\n\t\tdp[cx][cy].first=0,dp[cx][cy].second=0;\n\tans=dp[cx][cy];\n\tfor(int y=cy+1;y<1000;y++){\n\t\tfor(int x=0;x<1000;x++){\n\t\t\tif(cave[x][y]<=m){\n\t\t\t\tbool isP=isprime[cave[x][y]];\n\t\t\t\tbool pass=false;\n\t\t\t\tif(x&&cave[x-1][y-1]<=m&&dp[x-1][y-1].first!=-1){\n\t\t\t\t\tif(dp[x][y].first<dp[x-1][y-1].first||(dp[x][y].first==dp[x-1][y-1].first&&dp[x][y].second<dp[x-1][y-1].second)){\n\t\t\t\t\t\tdp[x][y]=dp[x-1][y-1];\n\t\t\t\t\t\tpass=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(cave[x][y-1]<=m&& dp[x][y-1].first!=-1){\n\t\t\t\t\tif(dp[x][y].first<dp[x][y-1].first||(dp[x][y].first==dp[x][y-1].first&&dp[x][y].second<dp[x][y-1].second)){\n\t\t\t\t\t\tdp[x][y]=dp[x][y-1];\n\t\t\t\t\t\tpass=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(x<999&&cave[x+1][y-1]<=m&&dp[x+1][y-1].first!=-1){\n\t\t\t\t\tif(dp[x][y].first<dp[x+1][y-1].first||(dp[x][y].first==dp[x+1][y-1].first&&dp[x][y].second<dp[x+1][y-1].second)){\n\t\t\t\t\t\tdp[x][y]=dp[x+1][y-1];\n\t\t\t\t\t\tpass=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(isP&&pass)\n\t\t\t\t\tdp[x][y].first++,dp[x][y].second=cave[x][y];\n\t\t\t\t\t\n\t\t\t\tif(ans.first<dp[x][y].first||(ans.first==dp[x][y].first&&ans.second<dp[x][y].second))\n\t\t\t\t\tans=dp[x][y];\n\t\t\t\t//cout << ans.first <<\" \" << ans.second << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(void){\n\t// prime generator\n\tfor(int i=0;i<=N;i++)\n\t\tisprime[i]=true;\n\tisprime[0]=isprime[1]=false;\n\tfor(int i=2;i<=N;i++)\n\t\tif(isprime[i])\n\t\t\tfor(int j=2*i;j<=N;j+=i)\n\t\t\t\tisprime[j]=false;\n\t// cave generator\n\tint x=499,y=500,tmp=1;\n\tcave[x][y]=1;\n\txindex[1]=x;\n\tyindex[1]=y;\n\tfor(int i=1;i<=N;){\n\t\tfor(int j=0;j<tmp;j++){\n\t\t\tif(i>N)\n\t\t\t\tbreak;\n\t\t\tx++;\n\t\t\ti++;\n\t\t\tcave[x][y]=i;\n\t\t\txindex[i]=x;\n\t\t\tyindex[i]=y;\n\t\t}\n\t\tfor(int j=0;j<tmp;j++){\n\t\t\tif(i>N)\n\t\t\t\tbreak;\n\t\t\ty--;\n\t\t\ti++;\n\t\t\tcave[x][y]=i;\n\t\t\txindex[i]=x;\n\t\t\tyindex[i]=y;\n\t\t}\n\t\ttmp++;\n\t\tfor(int j=0;j<tmp;j++){\n\t\t\tif(i>N)\n\t\t\t\tbreak;\n\t\t\tx--;\n\t\t\ti++;\n\t\t\tcave[x][y]=i;\n\t\t\txindex[i]=x;\n\t\t\tyindex[i]=y;\n\t\t}\n\t\tfor(int j=0;j<tmp;j++){\n\t\t\tif(i>N)\n\t\t\t\tbreak;\n\t\t\ty++;\n\t\t\ti++;\n\t\t\tcave[x][y]=i;\n\t\t\txindex[i]=x;\n\t\t\tyindex[i]=y;\n\t\t}\n\t\ttmp++;\n\t}\n\twhile(cin >> m >> n ,m|n){\n\t\tfor(int i=0;i<1000;i++)\n\t\t\tfor(int j=0;j<1000;j++)\n\t\t\t\tdp[i][j].first=dp[i][j].second=-1;\n\t\tP ans=find(xindex[n],yindex[n]);\n\t\tif(ans.first==0)\n\t\t\tans.second=0;\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\n\nstatic const int N = 1010;\n\nunordered_map<int, pair<int, int>>\nguruguru(vector<vector<int>>& field, const unordered_set<int>& indices)\n{\n    static int dy[] = { 0, -1, 0, 1 };\n    static int dx[] = { 1, 0, -1, 0 };\n    int h = field.size();\n    int w = field[0].size();\n    int y = h / 2;\n    int x = w / 2;\n    int dir = 0;\n    int i = 1;\n    int a = 0;          // 最後に曲がってからの歩数\n    int b = 1;          // 次に曲がるまでの歩数\n    int c = 0;          // 最後に b が増えてからの曲がった回数\n    unordered_map<int, pair<int, int>> index2pos;\n\n    while (0 <= y && y < h && 0 <= x && x < w) {\n        field[y][x] = i;\n        if (indices.find(i) != end(indices))\n            index2pos[i] = make_pair(y, x);\n\n        ++i;\n        y += dy[dir];\n        x += dx[dir];\n        ++a;\n        if (a == b) {\n            dir = (dir + 1) % 4;\n            a = 0;\n            ++c;\n            if (c == 2) {\n                ++b;\n                c = 0;\n            }\n        }\n    }\n\n    return move(index2pos);\n}\n\nvector<bool> sieve(int n)\n{\n    vector<bool> prime(n + 1, true);\n    prime[0] = prime[1] = false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (prime[i]) {\n            for (int j = i * i; j <= n; j += i)\n                prime[j] = false;\n        }\n    }\n    return move(prime);\n}\n\nint main()\n{\n    vector<pair<int, int>> inputs;\n    unordered_set<int> indices;\n    int m, n;\n    for (int i = 0; cin >> m >> n, m | n; ++i) {\n        inputs.emplace_back(m, n);\n        indices.insert(n);\n    }\n\n    vector<vector<int>> field(N, vector<int>(N));\n    auto index2pos = guruguru(field, indices);\n    auto prime = sieve(N * N);\n\n    for (int t = 0; t < (int)inputs.size(); ++t) {\n        pair<int, int> ans;\n        vector<vector<pair<int, int>>> dp(N, vector<pair<int, int>>(N, make_pair(-10000, 0)));\n        int sy = index2pos[inputs[t].second].first;\n        int sx = index2pos[inputs[t].second].second;\n        ans = dp[sy][sx] = make_pair(prime[field[sy][sx]], (prime[field[sy][sx]] ? field[sy][sx] : 0));\n        for (int y = sy + 1; y < N; ++y) {\n            for (int x = 1; x < N - 1; ++x) {\n                if (field[y][x] > inputs[t].first)\n                    continue;\n                auto prev = max(dp[y-1][x-1], max(dp[y-1][x], dp[y-1][x+1]));\n                if (prime[field[y][x]]) {\n                    dp[y][x] = make_pair(prev.first + 1, field[y][x]);\n                } else {\n                    dp[y][x] = prev;\n                }\n                ans = max(ans, dp[y][x]);\n            }\n        }\n\n        cout << ans.first << ' ' << ans.second << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1189&lang=jp\n\n#include<iostream>\n//#include<fstream>\n#include<math.h>\n\n//#define MAX 1020000\n\n#define MAX 1002\n\nint n, first;\nint a[MAX][MAX] = {};\n\nclass Pair{\npublic:\n\tint count;\n\tint last;\n\tPair operator + (Pair p){//\t@Override (+)\n\t\tthis->count += p.count;\n\t\tif (p.last != 0)this->last = p.last;\n\t\treturn *this;\n\t}\n\tvoid setPair(int _x, int _y){\n\t\tcount = _x;\n\t\tlast = _y;\n\t}\n};\n\nPair pair(int a, int b){\n\tPair p;\n\tp.setPair(a, b);\n\treturn p;\n}\n\nbool isPrime(int n){\n\tif (n == 1)return false;\n\tif (n == 2)return true;\n\tif (n % 2 == 0)return false;\n\n\tfor (int i = 3; i * i <= n; i += 2){\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\n\nPair search(int y, int x){\n\tstatic Pair p[MAX*MAX];\n\n\tPair u_right = pair(-10, 0);\n\tPair u_left = pair(-10, 0);\n\n\tstatic bool isReached[(MAX)*(MAX)];\n\tstatic bool initial = true;\n\n\tif (initial){//初期化\n\t\tfor (int i = 0; i < MAX; i++){\n\t\t\tisReached[i] = false;\n\t\t\tp[i].count = p[i].last = 0;\n\t\t}\n\t\tinitial = false;\n\t}\n\n\tif (n < a[y][x] || a[y][x] == 0)\n\t\treturn p[0];//上限を超えていた場合,,, p[0].count = p[0].last = 0\n\n\t//以下特殊例処理\n\tif (a[y][x] == 2){\n\t\tp[2].last = 2;\n\t\tif (a[y][x] == first)initial = true;\n\t\treturn pair(1, 2) + search(y + 1, x);\n\t}\n\n\tif (n <= 6 && a[y][x] == 3){\n\t\tp[3].last = 2;\n\t\tif (a[y][x] == first)initial = true;\n\t\treturn pair(2, 2);\n\t}\n\tif (a[y][x] == 4){\n\t\tif (u_right.count == -10)u_right = search(y + 1, x + 1);\n\t\tif (u_left.count == -10)u_left = search(y + 1, x);\n\n\t\tif (u_right.count == u_left.count){\n\t\t\tif (u_right.last < u_left.last)u_right.count--;\n\t\t}\n\t\tif (u_right.count < u_left.count){\n\t\t\tisReached[4] = true;\n\t\t\tif (a[y][x] == first)initial = true;\n\t\t\treturn p[4] = p[4] + u_left;\n\t\t}\n\t\telse{\n\t\t\tisReached[4] = true;\n\t\t\tif (a[y][x] == first)initial = true;\n\t\t\treturn p[4] = p[4] + u_right;\n\t\t}\n\t}\n\t//ここまで特例処理\n\n\t//下の数字を計算\n//\tUnder under(start);\n\n\t//偶数の時\n\tif (a[y][x] % 2 == 0)return p[a[y + 1][x]] = search(y + 1, x);\n\n\t//枝刈り\n\tif (isReached[a[y][x]]){\n\t\treturn p[a[y][x]];\n\t}\n\n\tif (u_right.count == -10)u_right = search(y + 1, x + 1);//under.rightの計算\n\tif (u_left.count == -10)u_left = search(y + 1, x - 1);//under.leftの計算\n\n\t//素数の時\n\tif (isPrime(a[y][x])){\n\t\tp[a[y][x]].count = 1;\n\t\tp[a[y][x]].last = a[y][x];\n\t}\n\n\tif (u_right.count == u_left.count){\n\t\tif (u_right.last < u_left.last)u_right.count--;\n\t}\n\t//leftのコストが大きい時\n\tif (u_right.count < u_left.count){\n\t\tisReached[a[y][x]] = true;\n\t\tif (a[y][x] == first)initial = true;//最初に入った時のみ、次のために初期化\n\t\treturn p[a[y][x]] = p[a[y][x]] + u_left;\n\t}\n\t//rightのコストが大きい時\n\telse{\n\t\tisReached[a[y][x]] = true;\n\t\tif (a[y][x] == first)initial = true;//最初に入った時のみ、次のために初期化\n\t\treturn p[a[y][x]] = p[a[y][x]] + u_right;\n\t}\n}\n\nint main(){\n\n\tusing namespace std;\n\n\tint x = MAX / 2;\n\tint y = MAX / 2;\n\tint N = 1;\n\ta[MAX / 2][MAX / 2] = 1;\n\n\tfor (int i = 0; i < MAX*MAX; i++){\n\n\t\tfor (int n = 0; n < (int)sqrt((double)N); n++){\n\t\t\ta[y][x] = N;\n\t\t\tN++;\n\t\t\tx++;\n\t\t}\n\t\tif (N >= (MAX)*(MAX))break;\n\t\tfor (int n = 0; n < (int)sqrt((double)N); n++){\n\t\t\ta[y][x] = N;\n\t\t\tN++;\n\t\t\ty--;\n\t\t}\n\t\tif (N >= (MAX)*(MAX))break;\n\t\tfor (int n = 0; n < (int)sqrt((double)N); n++){\n\t\t\ta[y][x] = N;\n\t\t\tN++;\n\t\t\tx--;\n\t\t}\n\t\tif (N >= (MAX)*(MAX))break;\n\t\tfor (int n = 0; n < (int)sqrt((double)N); n++){\n\t\t\ta[y][x] = N;\n\t\t\tN++;\n\t\t\ty++;\n\t\t}\n\t\tif (N >= (MAX)*(MAX))break;\n\t}\n\n/*\n\tifstream fin;\n\tfin.open(\"input.txt\");\n*/\n\n\twhile (true){\n\t\tcin >> n >> first;\n\t\tif (n == 0)break;\n\n\t\tfor (int i = 0; i < MAX; i++){\n\t\t\tfor (int j = 0; j < MAX; j++){\n\t\t\t\tif (a[i][j] == first){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tPair p = search(y, x);\n\n\t\tcout << p.count << \" \" << p.last << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\n#define MP make_pair\n#define PB push_back\n#define MAX_N 1000001\n#define SIZE 1001\n#define X first\n#define Y second\n\nconst int STX = 500, STY = 500;\n\nint id[SIZE][SIZE];\nbool is_prime[MAX_N+1];\nvector<pair<int, int> > coord;\n\nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++) {\n    if(is_prime[i]) {\n      for(int j=i*i; j<=MAX_N; j+=i) {\n\tis_prime[j] = false;\n      }\n    }\n  }\n}\n\nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  /*\n  const int dx[] = {1,0,-1,0};\n  const int dy[] = {0,-1,0,1};\n  */\n  coord.PB(MP(0, 0)); // no use\n  coord.PB(MP(x, y)); // cnt = 1\n  cnt ++;\n\n  fill(id[0], id[0]+SIZE*SIZE+1, -1);\n  \n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt < SIZE*SIZE) {\n    a += 2;\n    for(int i=0; i<a; i++) {\n      y --;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      x --;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      y ++;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      x ++;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    x++, y++;\n  }\n}\n\nint dp[MAX_N+1];\n\nint main() {\n  \n  Sieve();\n  MakeMap();\n  \n  int m, n;\n  \n  while(cin >> m >> n && (m|n)) {\n    fill(dp, dp+m+1, -1);\n    dp[n] = is_prime[n];\n    \n    queue<pair<int, int> > que;\n    que.push(coord[n]);\n    \n    while(!que.empty()) {\n      pair<int, int> now = que.front(); que.pop();\n      int noid = id[now.Y][now.X];\n      \n      for(int i=-1; i<=1; i++) {\n\tpair<int, int> nex = MP(now.X+i, now.Y+1);\n\tif(nex.X < 0 || SIZE <= nex.X || nex.Y < 0 || SIZE <= nex.Y) continue;\n\tint neid = id[nex.Y][nex.X];\n\tif(neid <= m) {\n\t  if(dp[neid] < dp[noid] + is_prime[neid]) {\n\t    dp[neid] = dp[noid] + is_prime[neid];\n\t    que.push(nex);\n\t  }\n\t}\n      }\n    }\n    \n    int res = dp[n], lastid = -1;\n    if(is_prime[n]) lastid = n;\n    \n    for(int i=1; i<=m; i++) {\n      if(res <= dp[i] && is_prime[i]) {\n\tres = dp[i];\n\tlastid = max(lastid, i);\n      }\n    }\n    \n    if(lastid == -1) cout << \"0 0\" << endl;\n    else cout << res << \" \" << lastid << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[(SIZE + 1)*(SIZE + 1) + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= (SIZE + 1)*(SIZE + 1);i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= (SIZE + 1)*(SIZE + 1);j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 || n == 0)return 0;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(y=SIZE-1;y>=0;y--){\n\t\t\tfor(x=SIZE-1;x>=0;x--){\n\t\t\t\tif (table[y][x] <= m) {\n\t\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m &&\n\t\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x - 1] || (dp[y][x] == dp[y + 1][x - 1] && pr[y][x] < pr[y + 1][x - 1]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (table[y + 1][x] <= m &&\n\t\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x] || (dp[y][x] == dp[y + 1][x] && pr[y][x] < pr[y + 1][x]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m &&\n\t\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x + 1] || (dp[y][x] == dp[y + 1][x + 1] && pr[y][x] < pr[y + 1][x + 1]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (y = 0;y < SIZE;y++) {\n\t\t\tfor (x = 0;x < SIZE;x++) {\n\t\t\t\tif (table[y][x] == n) {\n\t\t\t\t\tcout << dp[y][x] << \" \";\n\t\t\t\t\t//cout << pr[y][x] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\nusing namespace std;\n#define MAX 1000005\nint F[MAX]={1,1},i,j,p=0,N,M,C[1005][1005],pos[MAX][2],dp[MAX],t,nc;\ntypedef struct D{int c,np,now;}D;\n\nvoid set(int n,int y,int x){C[y][x]=n;pos[n][0]=y;pos[n][1]=x;}\n\nvoid vortex()\n{\n\tint i,j,pre,nx,ny,mv[5]={-1,0,1,0,-1};\n\tmemset(C,0x7f,sizeof(C));\n\tnx=1005/2;ny=1005/2;\n\tset(1,ny,nx);\n\tnx++;\n\tset(2,ny,nx);\n\tfor(i=3,pre=i-1;i<MAX;pre=i++)\n\t{\n\t\tfor(j=0;j<4;j++)\n\t\t{\n\t\t\tif(C[ny+mv[j]][nx+mv[j+1]]==pre-1)\n\t\t\t\tbreak;\n\t\t}\n\t\tfor(;C[ny+mv[j]][nx+mv[j+1]]<MAX;)\n\t\t\tj=(j+1)%4;\n\t\tny+=mv[j];\n\t\tnx+=mv[j+1];\n\t\tset(i,ny,nx);\n\t}\n}\n\nint main()\n{\n\tfor(i=2;i<MAX;i++)\n\t\tif(!F[i])\n\t\t{\n\t\t\tfor(j=i*2;j<MAX;j+=i)\n\t\t\t\tF[j]=1;\n\t\t}\n\tvortex();\n\tfor(;scanf(\"%d%d\",&M,&N),N+M;)\n\t{\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tqueue<D>Q;\n\t\tD tmp={!F[N],(!F[N])?N:0,N},r=tmp;\n\t\tQ.push(tmp);\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\ttmp=Q.front();Q.pop();\n\t\t\tif(r.c<tmp.c||(tmp.c==r.c&&tmp.np>r.np))\n\t\t\t\tr=tmp;\n\t\t\tif(tmp.c<dp[tmp.np])continue;\n\t\t\tdp[tmp.now]=tmp.c;\n\t\t\tfor(i=-1;i<2;i++)\n\t\t\t{\n\t\t\t\tt=C[pos[tmp.now][0]+1][pos[tmp.now][1]+i];\n\t\t\t\tif(t<=M&&dp[t]<tmp.c+(!F[t]))\n\t\t\t\t{\n\t\t\t\t\tD ins={tmp.c+(!F[t]),!F[t]&&t>tmp.np?t:tmp.np,t};\n\t\t\t\t\tdp[t]=ins.c;\n\t\t\t\t\tQ.push(ins);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",r.c,r.np);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint m, n;\nvector<vector<pair<bool, int> > > mp(1001, vector<pair<bool, int> >(1001, pair<bool, int>(false, 0)));\nvector<vector<P> > memo(1001, vector<P>(1001, P(-1, -1)));\nP dfs(P np) {\n\tif(memo[np.first][np.second].first != -1) {\n\t\treturn memo[np.first][np.second];\n\t}\n\tif(mp[np.first][np.second].second > m || np.first < 0 || np.first >= 1001 || np.second < 0 || np.second >= 1001) {\n\t\treturn P(0, 0);\n\t}\n\tP res;\n\tres = max(max(dfs(P(np.first + 1, np.second)), dfs(P(np.first + 1, np.second - 1))), dfs(P(np.first + 1, np.second + 1)));\n\tif(res.first == 0 && res.second == 0) {\n\t\tif(mp[np.first][np.second].first) return memo[np.first][np.second] = P(1, mp[np.first][np.second].second);\n\t\telse return memo[np.first][np.second] = P(0, mp[np.first][np.second].second);\n\t}\n\tif(mp[np.first][np.second].first) {\n\t\treturn memo[np.first][np.second] = P(res.first + 1, res.second);\n\t} else {\n\t\treturn memo[np.first][np.second] = P(res.first, res.second);\n\t}\n}\n\nint main(void) {\n\tvector<bool> prime(1001 * 1001 + 1, true);\n\tprime[0] = prime[1] = false;\n\tFOR(i, 2, 1001 * 1001 + 1) {\n\t\tif(prime[i]) {\n\t\t\tfor(ll j = 2; i * j <= 1001 * 1001; ++j) {\n\t\t\t\tprime[i * j] = false;\n\t\t\t}\n\t\t}\n\t}\n\tP cp = {500, 500};\n\tll cnt = 1;\n\tll size = 1;\n\tll lim = 1;\n\twhile(cnt <= 1001 * 1001) {\n\t\tmp[cp.first][cp.second].second = cnt;\n\t\tif(prime[cnt]) mp[cp.first][cp.second].first = true;\n\t\t--lim;\n\t\tif(lim == 0) {\n\t\t\tsize += 2;\n\t\t\t++cp.second;\n\t\t\tlim = size * size - (size - 2) * (size - 2);\n\t\t} else {\n\t\t\tif(lim >= 2 * (size - 1) + size) {\n\t\t\t\t--cp.first;\n\t\t\t} else if(lim >= (size - 1) + size) {\n\t\t\t\t--cp.second;\n\t\t\t} else if(lim >= size) {\n\t\t\t\t++cp.first;\n\t\t\t} else {\n\t\t\t\t++cp.second;\n\t\t\t}\n\t\t}\n\t\t++cnt;\n\t}\n\twhile(true) {\n\t\tcin>>m>>n;\n\t\tif(m == 0 && n == 0) break;\n\t\tP sp;\n\t\tbool upd = false;\n\t\tREP(i, 1001) {\n\t\t\tREP(j, 1001) {\n\t\t\t\tif(mp[i][j].second == n) {\n\t\t\t\t\tsp.first = i;\n\t\t\t\t\tsp.second = j;\n\t\t\t\t\tupd = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(upd) break;\n\t\t}\n\t\tREP(i, 1001) {\n\t\t\tREP(j, 1001) {\n\t\t\t\tmemo[i][j].first = memo[i][j].second = -1;\n\t\t\t}\n\t\t}\n\t\tP ans = dfs(sp);\n\t\tif(ans.first == 0) cout<<0<<\" \"<<0<<endl;\n\t\telse cout<<ans.first<<\" \"<<ans.second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio> \n#include <iostream> \n#include <string> \n#include <vector> \n#include <cmath> \n#include <algorithm>\n#include <cstdlib> \n#include <cstring>\n#include <map>\n\nusing namespace std;\n\n#define REP(i,j,k) for(int i=j;i<(int)(k);++i)\n#define rep(i,j) REP(i,0,j)\n#define F first\n#define S second\n\ntypedef pair<int,int> P;\n\nconst int mid = 510;\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint field[1020][1020];\nP dp[1020][1020];\nbool is_prime[1000010];\nint n, st;\nmap<int,P> mp;\n\nvoid init(){\n    memset(field,-1,sizeof(field));\n    int i=0;\n    int x=mid,y=mid;\n    REP(N,1,1000010){\n        field[y][x] = N;\n        mp[N] = P(y,x);\n        if(field[y+dy[i]][x+dx[i]]==-1) {\n            y += dy[i]; x += dx[i];\n            i = (i+1)%4;\n        }else{\n            y += dy[(i+4-1)%4]; x += dx[(i+4-1)%4];\n        }\n    }\n\n    rep(i,1000010) is_prime[i]=true;\n    is_prime[0]=is_prime[1]=false;\n    for(int i=2;i*i<1000010;++i)if(is_prime[i]){\n        for(int j=i*i;j<1000010;j+=i) is_prime[j]=false;\n    }\n}\n\nP solve(const int& y, const int& x){\n    P ans(0,0);\n    dp[y][x] = is_prime[field[y][x]]?P(1,field[y][x]):P(0,0);\n    \n    rep(i,1020)rep(j,1020){\n        if(dp[i][j]==P(-1,-1)) continue;\n        ans = max(ans,dp[i][j]);\n        REP(k,-1,2){\n            if(field[i+1][j+k]>n||field[i+1][j+k]==-1) continue;\n            dp[i+1][j+k] = max(dp[i+1][j+k],is_prime[field[i+1][j+k]]?\n                               P(dp[i][j].F+1,field[i+1][j+k]):dp[i][j]);\n        }\n    }\n    return ans;\n}\n\nint main(){\n    init();\n    while(cin >> n >> st,n||st){\n        rep(i,1020)rep(j,1020) dp[i][j] = P(-1,-1);\n        P ans = solve(mp[st].F,mp[st].S);\n        cout << ans.F << \" \" << ans.S << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <set>\n#include <map>\nusing namespace std;\nint d[4][2] = {{1,0},{0,-1},{-1,0},{0,1}};\nint n;\nint m;\nint w;\nint sx,sy;\nint Map[1550][1550];\nbool isPrime[1000001];\nint Log[1550][1550];\n\nvoid sieve(int M){\n\tfor(int i=2;i<M;i++) isPrime[i] = true;\n\tfor(int i=2;i*i<M;i++){\n\t\tif(!isPrime[i]) continue;\n\t\tfor(int j=i*i;j<M;j+=i) isPrime[j] = false;\n\t}\n}\n\nvoid setMap(){\n\tint i,j;\n\tmemset(Map, 0, sizeof(Map));\n\tmemset(Log, 0, sizeof(Log));\n\tfor(w=0;w*w<m;w++);\n\tint px=w/2+2,py=w/2+2;\n\tint dn = 1, dt=0;\n\tMap[px][py] = 0;\n\tLog[px][py] = 1;\n\tif(n==1){\n\t\tsx = px;\n\t\tsy = py;\n\t}\n\tfor(i=1;i<m;){\n\t\tfor(int j=0;j<dn;j++){\n\t\t\tpx = px + d[dt][0];\n\t\t\tpy = py + d[dt][1];\n\t\t\tMap[px][py] = isPrime[++i];\n\t\t\tLog[px][py] = i;\n\t\t\tif(i==n){sx=px;sy=py;}\n\t\t\tif(i==m){return;}\n\t\t} dt=(dt+1)%4;\n\t\tfor(int j=0;j<dn;j++){\n\t\t\tpx = px + d[dt][0];\n\t\t\tpy = py + d[dt][1];\n\t\t\tMap[px][py] = isPrime[++i];\n\t\t\tLog[px][py] = i;\n\t\t\tif(i==n){sx=px;sy=py;}\n\t\t\tif(i==m){return;}\n\t\t} dt=(dt+1)%4;\n\t\tdn ++;\n\t}\n}\n\nvoid get(){\n\tint i,j;\t\n\tfor(i=w+4;i;i--)\n\t\tfor(j=w+4;j;j--){\n\t\t\tint tox, toy = i+1;\n\t\t\tpair<int, int> a,b,c;\n\t\t\ta.first  = Map[j+1][i+1];\n\t\t\ta.second = Log[j+1][i+1];\n\t\t\tb.first  = Map[j][i+1];\n\t\t\tb.second = Log[j][i+1];\n\t\t\tc.first  = Map[j-1][i+1];\n\t\t\tc.second = Log[j-1][i+1];\n\n\t\t\tif(a > b && a > c){\n\t\t\t\ttox = j+1;\n\t\t\t}else if(b > c){\n\t\t\t\ttox = j;\n\t\t\t}else{\n\t\t\t\ttox = j-1;\n\t\t\t}\n\t\t\tMap[j][i] += Map[tox][toy];\n\t\t\tif(Log[tox][toy]) Log[j][i] = Log[tox][toy];\n\t\t\tif(!Map[j][i]) Log[j][i] = 0;\n\t\t//\tif(i==sy && j==sx) return Map[j][i];\n\t\t}\n}\n\nmain(){\n\tint i,j;\n\tsieve(1000000);\n\twhile(cin >> m >> n, m||n){\n\t\tsetMap();\n\t\tint ans=0;\n\t/*\tfor(i=0;i<=w+1;i++){\n\t\t\tfor(j=0;j<=w+1;j++){\n\t\t\t\tprintf(\"%2d \", Log[j][i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t*///\tcout << sx << \" \" << sy << endl;\n\t\tget();\n\t\tcout << Map[sx][sy] << \" \" << Log[sx][sy] << endl;\n\t/*\tfor(i=0;i<=w+1;i++){\n\t\t\tfor(j=0;j<=w+1;j++){\n\t\t\t\tprintf(\"%4d \", Log[j][i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tfor(i=0;i<=w+1;i++){\n\t\t\tfor(j=0;j<=w+1;j++){\n\t\t\t\tprintf(\"%4d \", Map[j][i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n*/\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, -1, 0, 1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m; assert(b>=0); for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\nbool ool(int x,int y,int h,int w) {return((x<0)||(h<=x)||(y<0)||(w<=y));}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\n// 地図作って(クソ面倒)上からdpするだけ\n// 毎回地図作り直す必要なかった\nint n, m, si, sj, s[2000][2000], dp[2000][2000];\nbool p[1000001];\n\n// エラトステネスの篩 O(NloglogN)\nvoid sieve() {\n\tfill(p, p+1000001, true);\n\tp[0] = p[1] = false;\n\tfor (int i = 2; i*i <= 1000000; ++i)\n\t\tif (p[i]) for (int j = 2*i; j <= 1000000; j += i) p[j] = false;\n}\n\n// 再帰で地図作成\nvoid mm() {\n\tmemset(s,0,sizeof(s));\n\ts[1000][1000] = 1;\n\tint i = 1000, j = 1001, d = 0;\n\trepst(p,2,n) {\n\t\ts[i][j] = p;\n\t\tif (p==m) si = i, sj = j;\n\t\tif (p==n) return;\n\t\tint i0 = i + dx[d], j0 = j + dy[d], i1 = i + dx[(d+1)%4], j1 = j + dy[(d+1)%4];\n\t\tif (s[i1][j1]) i = i0, j = j0;\n\t\telse i = i1, j = j1, d++, d %= 4;\n\t}\n}\n\nsigned main() {\n\tsieve();\n\twhile (1) {\n\t\tcin >> n >> m;\n\t\tif (n==0) break;\n\t\tmm();\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tdp[si][sj] = p[s[si][sj]];\n\t\tint l = 0, r = 0;\n\t\treps(i,si,1999) reps(j,1,1999) if (s[i][j] && dp[i][j]!=-1) {\n\t\t\trepst(d,-1,1) if (s[i+1][j+d]) chmax(dp[i+1][j+d], dp[i][j] + p[s[i+1][j+d]]);\n\t\t\tif (dp[i][j]>l) l = dp[i][j], r = s[i][j];\n\t\t\telse if (dp[i][j]==l && p[s[i][j]]) chmax(r, s[i][j]);\n\t\t}\n\t\tcout << l << ' ' << (l==0 ? 0 : r) << ln;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iomanip>\n#include<iostream>\n#include<map>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n#define X first\n#define Y second\nconst int mem_max = 1100;\n\nvector<int > prime;\nint mem[mem_max][mem_max];\nvector<pii > mem2;\nstruct F{\n  public: void  init(){\n    make_prime();\n    for(int i=0;i<mem_max;i++){\n      for(int j=0;j<mem_max;j++){\n        mem[i][j]=-1;\n      }\n    } \n    int x=0,y=0;\n    int c=1;\n    int dx=1,dy=1;\n    int vx=1,vy=-1;\n    w(x,y,c);\n    while(1){\n      for(int i=0;i<dx;i++){\n        x+=vx;c++;if(!(c<=mem_max*mem_max))break;\n        w(x,y,c);\n      }\n      if(!(c<=mem_max*mem_max))break;\n      vx*=-1;\n      dx++;\n      for(int i=0;i<dy;i++){\n        y+=vy;c++;if(!(c<mem_max*mem_max))break;\n        w(x,y,c);\n      }\n      if(!(c<=mem_max*mem_max))break;\n      vy*=-1;\n      dy++;\n    }\n    mem2.resize(mem_max *mem_max +2);\n    for(int i=0;i<mem_max;i++){\n      for(int j=0;j<mem_max;j++){\n        mem2[mem[i][j]] = pii(i-mem_max/2,j-mem_max/2); \n      }\n    }\n  }\n  private:\n  void make_prime(){\n    prime.resize(mem_max*mem_max+2);\n    for(int i=2;i<(int)prime.size();i++){\n      prime[i]=1;\n    }\n    for(int i=0;i*i<=(int)prime.size();i++){\n      if(prime[i])for(int j=i*2;j<(int)prime.size();j+=i){\n        prime[j]=0;\n      }\n    }\n  }\n  int res(int x){\n    x+=mem_max/2;\n    if(x<0||mem_max<=x)return -1;\n    return x;\n  }\n  int w(int x,int y,int m){\n    if(-1==(x = res(x))) return -1;\n    if(-1==(y = res(y))) return -1;\n    mem[x][y]=m;\n    return mem[x][y];\n  }\n  public:\n  int g(int x,int y){\n    if(-1==(x = res(x))) return -1;\n    if(-1==(y = res(y))) return -1;\n    return mem[x][y];\n  }\n  int num(int x,int y){return g(x,y);}\n  pii pos(int n){\n    return mem2[n];\n  }\n  bool is_prime(int x,int y){\n    int tmp = g(x,y);\n    return prime[tmp];\n  }\n};\nF f;\n\n#define DEBUG 0\nvoid print(){\n  if(!DEBUG)return ;\n  for(int i=0;i<20;i++){\n    for(int j=0;j<20;j++){\n      cout<<setw(4)<<f.g(j-10,i-10);\n    }cout<<endl;\n  }cout<<endl;\n\n  for(int i=0;i<20;i++){\n    cout<<f.pos(i+1).X<<\" \"<<f.pos(i+1).second<<endl;\n  }\n}\n\nvector<pii> dp;\nint m;\npii req(int x,int y){\n  if(f.num(x,y)<0 || f.num(x,y)>=(int)dp.size())return pii();\n  if(dp[f.num(x,y)].X!=-1)return dp[f.num(x,y)];\n  if(f.num(x,y)>m)return pii();\n  pii res = pii(0,0);\n  for(int i=-1;i<=1;i++){\n    pii tmp = req(x+i,y+1);\n    res = max(tmp,res);\n  }\n  if(f.is_prime(x,y)){\n    if(res.first == 0){\n      res.second = f.num(x,y);\n    }\n    res.first++;\n  }\n  return dp[f.num(x,y)]=res;\n}\n\n\npii solve(int n){\n  dp.clear();dp.resize(m+100);\n  for(int i=0;i<(int)dp.size();i++){\n    dp[i] = pii(-1,-1);\n  }\n  return req(f.pos(n).X,f.pos(n).Y);\n}\n\n\nint main(){\n  print();\n  f.init();\n  int n;\n  while(1){\n    cin>>m>>n;\n    if(n==0&&m==0)break;\n    pii ans = solve(n);\n    cout<<ans.first<<\" \"<<ans.second<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\n#define SIZE 1000\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\t\t/*\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}*/\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t\n\t\toutput = false;\n\t\tfor (int i = 0;i < SIZE&&(!output);i++) {\n\t\t\tfor (int j = 0;j < SIZE&&(!output);j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\t//printf(\"%d\\n\", dp[i][j]);\n\t\t\t\t\t//printf(\"%d %d\\n\", dp[i][j], pr[i][j]);\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"O0\")\nusing namespace std;\n\nconstexpr long MAX_P = 1000001;\nbool isPrime[MAX_P];\nlong board[2000][2000];\nlong primeBoard[2000][2000];\nbool use[1000][1000];\nlong score[2000][2000];\nlong bottom[2000][2000];\n\nvoid make() {\n  for (int i = 0; i < MAX_P; i++) isPrime[i] = 1;\n  isPrime[0] = 0;\n  isPrime[1] = 0;\n  for (int i = 2; i < MAX_P; i++) {\n    if (isPrime[i]) {\n      for (int j = 2; i * j < MAX_P; j++) {\n        isPrime[i * j] = 0;\n      }\n    }\n  }\n}\n\nvoid test() {\n  for (int i = 995; i < 1005; i++) {\n    for (int j = 995; j < 1005; j++) {\n      cout << board[i][j]<<\":\"<<score[i][j] << '\\t';\n    }\n    cout << endl;\n  }\n}\n\nvoid makeboards() {\n  int dir = 0;\n  // 0: right, 1: up, 2: left, 3: down\n  int size = 2;\n  long x = 1000;\n  long y = 1000;\n  int i = 1;\n  while (i < MAX_P) {\n    for (int k = 0; k < size / 2; k++) {\n      assert(0 <= dir && dir < 4);\n      switch (dir) {\n        case 0:\n        board[x][y + k] = i;\n        primeBoard[x][y + k] = isPrime[i];\n        break;\n        case 1:\n        board[x - k][y] = i;\n        primeBoard[x - k][y] = isPrime[i];\n        break;\n        case 2:\n        board[x][y - k] = i;\n        primeBoard[x][y - k] = isPrime[i];\n        break;\n        case 3:\n        board[x + k][y] = i;\n        primeBoard[x + k][y] = isPrime[i];\n        break;\n      }\n      i++;\n    }\n    assert(0 <= dir && dir < 4);\n    switch (dir) {\n      case 0:\n      y += size / 2;\n      break;\n      case 1:\n      x -= size / 2;\n      break;\n      case 2:\n      y -= size / 2;\n      break;\n      case 3:\n      x += size / 2;\n      break;\n    }\n    size += 1;\n    dir = (dir + 1) % 4;\n  }\n}\n\nusing P = pair<long, long>;\n\nvoid solve(long m, long n) {\n  long xmin = 2000;\n  long xmax = 0;\n  long ymin = 2000;\n  long ymax = 0;\n  for (long i = 0; i < 2000; i++) {\n    for (long j = 0; j < 2000; j++) {\n      use[i][j] = 0;\n      score[i][j] = 0;\n      bottom[i][j] = 0;\n    }\n  }\n  for (long i = 0; i < 2000; i++) {\n    for (long j = 0; j < 2000; j++) {\n      if (board[i][j] && board[i][j] <= m) {\n        use[i][j] = 1;\n        xmin = min(xmin, i);\n        xmax = max(xmax, i);\n        ymin = min(ymin, j);\n        ymax = max(ymax, j);\n      }\n    }\n  }\n\n  for (int i = xmax; i >= xmin; i--) {\n    for (int j = ymin; j <= ymax; j++) {\n      // cout << \"searching\" << board[i][j] << endl;\n      if (score[i + 1][j - 1] + score[i + 1][j] + score[i + 1][j + 1] == 0 && primeBoard[i][j] * use[i][j]) {\n        // cout << \"hoge\" << board[i][j] << endl;\n        score[i][j] = 1;\n        bottom[i][j] = board[i][j];\n        continue;\n      }\n      vector<P> scores;\n      scores.push_back(P(score[i + 1][j - 1], bottom[i + 1][j - 1]));\n      scores.push_back(P(score[i + 1][j], bottom[i + 1][j]));\n      scores.push_back(P(score[i + 1][j + 1], bottom[i + 1][j + 1]));\n      sort(scores.begin(), scores.end(), greater<P>());\n      if (primeBoard[i][j] * use[i][j]) {\n        // cout << \"hit!\" << board[i][j] << endl;\n        score[i][j] = scores[0].first + 1;\n        // cout << scores[0].first << endl;\n        // cout << score[i][j] << endl;\n        bottom[i][j] = scores[0].second;\n      } else {\n        score[i][j] = scores[0].first;\n        bottom[i][j] = scores[0].second;\n      }\n    }\n  }\n\n  for (int i = 0; i < 2000; i++) {\n    for (int j = 0; j < 2000; j++) {\n      if (board[i][j] == n) {\n        cout << score[i][j] << \" \" << bottom[i][j] << endl;\n        // test();\n        // exit(1);\n        return;\n      }\n    }\n  }\n}\n\nint main() {\n  long m, n;\n  make();\n  makeboards();\n  while (1) {\n    cin >> m >> n;\n    if (m + n == 0) return 0;\n    solve(m, n);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <map>\nusing namespace std;\n\n#define REP(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) REP(i,0,n)\n\ntypedef pair<int, int> PII;\n\npair<int, bool> caves[1001][1001];\nbool seive[1000001];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nvoid make_seive(void) {\n  for (int i = 0; i <= 1000001; i++) {\n    seive[i] = true;\n  }\n\n  seive[0] = seive[1] = false;\n\n  for (int i = 2; i * i <= 1000001; i++) {\n    if (!seive[i]) continue;\n    for (int j = i * i; j <= 1000001; j += i) {\n      seive[j] = false;\n    }\n  }\n}\n\nPII make_caves(int s, int n) {\n  int x = s / 2;\n  int y = s / 2;\n\n  int cave_no = 1;\n  int move_no = 0;\n  int move_limit = 1;\n\n  PII start_point;\n\n  while (cave_no < s * s) {\n    for (int i = 0; i < 2; i++) {\n\n      for (int j = 0; j < move_limit; j++) {\n        caves[y][x].first = cave_no;\n        caves[y][x].second = seive[cave_no];\n\n        if (cave_no == n) {\n          start_point.first = x;\n          start_point.second = y;\n        }\n\n        x += dx[move_no];\n        y += dy[move_no];\n\n        cave_no++;\n      }\n\n      move_no++;\n      move_no %= 4;\n    }\n\n    move_limit++;\n  }\n\n  return start_point;\n}\n\nmap<PII, pair<int, PII>> memo;\n\npair<int, PII> dfs(int x, int y, int s, int cave_no_limit) {\n  if (memo.count(PII(x, y))) return memo[PII(x,y)];\n\n  pair<int, PII> ret;\n  ret.first = caves[y][x].second;\n  ret.second = PII(x, y);\n\n  pair<int, PII> max_route;\n  max_route.first = 0;\n  max_route.second = PII(-1, -1);\n\n  for (int d = -1; d <= 1; d++) {\n    if (x + d < 0 || x + d >= s || y + 1 < 0 || y + 1 >= s) {\n      continue;\n    }\n\n    if (caves[y+1][x+d].first > cave_no_limit) {\n      continue;\n    }\n\n    pair<int, PII> route = dfs(x + d, y + 1, s, cave_no_limit);\n\n    if (route.first == 0) continue;\n\n    if (route.first > max_route.first) max_route = route;\n    else if (route.first == max_route.first) {\n      int rx = route.second.first;\n      int ry = route.second.second;\n\n      int mrx = max_route.second.first;\n      int mry = max_route.second.second;\n\n      if (caves[mry][mrx].first < caves[ry][rx].first) {\n        max_route = route;\n      }\n    }\n  }\n\n\n  ret.first += max_route.first;\n  if (max_route.first != 0) {\n    ret.second = max_route.second;\n  }\n\n  return memo[PII(x,y)] = ret;\n}\n\nvoid dump_caves(int s, int x, int y) {\n  for (int i = 0; i < s; i++) {\n    for (int j = 0; j < s; j++) {\n      char mark;\n      if (j == x && i == y) mark = '!';\n      else if (caves[i][j].second) mark = 'o';\n      else mark = ' ';\n\n      printf(\"%2d[%c] \", caves[i][j].first, mark);\n    }\n    printf(\"\\n\");\n  }\n}\n\nint main(void) {\n  int m, n;\n  make_seive();\n\n  while (cin >> m >> n, m && n) {\n    memo.clear();\n\n    int s = 1;\n    while (s * s < m) s += 2;\n    \n    int x, y;\n    tie(x, y) = make_caves(s, n);\n\n    pair<int, PII> res = dfs(x, y, s, m);\n\n    int cnt = res.first;\n    int cave_no = caves[res.second.second][res.second.first].first;\n\n    if (cnt == 0)\n      cave_no = 0;\n\n    cout << cnt << \" \" << cave_no << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * D.cpp\n *\n *  Created on: 2017/06/25\n *      Author: LitMc\n */\n\n#include <bits/stdc++.h>\n\n#define rep(i, from, to) for (int i = from; i < to; ++i)\n#define REP(i, from, to) for (int i = from; i <= to; ++i)\n#define dbp(x) cout<<#x<<\": \"<<x<<endl;\n#define dbp2(x,y) cout<<#x<<\",\"<<#y<<\": \"<<x<<\",\"<<y<<endl;\n#define dbp3(x,y,z) cout<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<x<<\",\"<<y<<\",\"<<z<<endl;\n#define dbp4(w,x,y,z) cout<<#w<<\",\"<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<w<<\",\"<<x<<\",\"<<y<<\",\"<<z<<endl;\n\nusing namespace std;\n\nstruct answer {\n\tint num, last;\n\tanswer() {\n\t\tnum = -1;\n\t\tlast = -1;\n\t}\n\tanswer(int n, int l) {\n\t\tnum = n;\n\t\tlast = l;\n\t}\n\tbool operator<(const answer &a) const {\n\t\tif (num == a.num) {\n\t\t\treturn last < a.last;\n\t\t} else {\n\t\t\treturn num < a.num;\n\t\t}\n\t}\n};\ntypedef struct answer answer;\nconst int MAX_M = 1000010;\nconst int MAX_W = 1011;\nconst int SIZE = MAX_W * MAX_W + 1000;\nint g[MAX_W][MAX_W];\nbool p[MAX_W][MAX_W];\nbool isprime[SIZE];\nint center = MAX_W / 2;\nanswer ans;\nint di[3] = { -1, -1, -1 };\nint dj[3] = { -1, 0, 1 };\nint n, m;\ntypedef pair<int, int> P;\nP n2ij[SIZE];\n\nvoid eratos() {\n\tisprime[0] = isprime[1] = true;\n\tfor (int i = 2; i < SIZE; ++i) {\n\t\tif (isprime[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int j = i + i; j < SIZE; j += i) {\n\t\t\tisprime[j] = true;\n\t\t}\n\t}\n}\n\nbool ok(int &i, int &j) {\n\treturn 0 <= i && i < MAX_W && 0 <= j && j < MAX_W;\n}\n\nvoid up(int &i, int &j, int cnt, int &k) {\n\trep(u,0,cnt+1)\n\t{\n\t\tif (ok(i, j)) {\n\t\t\tg[i][j] = k;\n\t\t\tp[i][j] = isprime[k];\n\t\t\tn2ij[k] = P(i, j);\n\t\t\tk++;\n\t\t\ti--;\n\t\t} else {\n\t\t\t//error!\n\t\t}\n\t}\n\ti++;\n\tj--;\n}\n\nvoid left(int &i, int &j, int cnt, int &k) {\n\trep(l,0,cnt+1)\n\t{\n\t\tif (ok(i, j)) {\n\t\t\tg[i][j] = k;\n\t\t\tp[i][j] = isprime[k];\n\t\t\tn2ij[k] = P(i, j);\n\t\t\tk++;\n\t\t\tj--;\n\t\t} else {\n\t\t\t//error!\n\t\t}\n\t}\n\tj++;\n\ti++;\n}\n\nvoid down(int &i, int &j, int cnt, int &k) {\n\trep(l,0,cnt+1)\n\t{\n\t\tif (ok(i, j)) {\n\t\t\tg[i][j] = k;\n\t\t\tp[i][j] = isprime[k];\n\t\t\tn2ij[k] = P(i, j);\n\t\t\tk++;\n\t\t\ti++;\n\t\t} else {\n\t\t\t//error!\n\t\t}\n\t}\n\ti--;\n\tj++;\n}\n\nvoid right(int &i, int &j, int cnt, int &k) {\n\trep(l,0,cnt+1)\n\t{\n\t\tif (ok(i, j)) {\n\t\t\tg[i][j] = k;\n\t\t\tp[i][j] = isprime[k];\n\t\t\tn2ij[k] = P(i, j);\n\t\t\tk++;\n\t\t\tj++;\n\t\t} else {\n\t\t\t//error!\n\t\t}\n\t}\n\tj--;\n\ti--;\n}\n\nvoid makeHole() {\n\tint i = center, j = center;\n\tint k = 1, cnt = 1;\n\tg[i][j] = k;\n\tp[i][j] = isprime[k];\n\tn2ij[k] = P(i, j);\n\tj++;\n\tk++;\n\twhile (ok(i, j) && k < MAX_W * MAX_W) {\n//\t\tdbp4(i - center, j - center, g[i][j], k);\n\t\tup(i, j, cnt, k);\n//\t\tdbp4(i - center, j - center, g[i][j], k);\n\t\tleft(i, j, cnt, k);\n//\t\tdbp4(i - center, j - center, g[i][j], k);\n\t\tdown(i, j, cnt, k);\n//\t\tdbp4(i - center, j - center, g[i][j], k);\n\t\tright(i, j, cnt, k);\n//\t\tdbp4(i - center, j - center, g[i][j], k);\n\t\ti++;\n\t\tj++;\n\t\tcnt += 2;\n\t}\n}\n\nanswer dp[MAX_W][MAX_W];\nvoid doDP(int si, int sj) {\n\tans = answer(-1, -1);\n\tif (!p[si][sj]) {\n\t\tdp[si][sj] = answer(1, g[si][sj]);\n\t} else {\n\t\tdp[si][sj] = answer(0, 0);\n\t}\n\tans = max(ans, dp[si][sj]);\n\tint l = max(0, sj - 1), r = min(MAX_W - 1, sj + 1);\n\tint pl = sj, pr = sj;\n\trep(i,si+1,MAX_W)\n\t{\n\t\tREP(j, l, r)\n\t\t{\n\t\t\tanswer a;\n\t\t\trep(k, 0, 3) //\n\t\t\t{\n\t\t\t\tint pi = i + di[k], pj = j + dj[k];\n\t\t\t\tif (ok(i, j) && ok(pi, pj) && dp[pi][pj].num != -1 && pl <= pj\n\t\t\t\t\t\t&& pj <= pr && g[i][j] <= m && g[pi][pj] <= m) {\n\t\t\t\t\tanswer a = dp[pi][pj];\n\t\t\t\t\tif (!p[i][j]) {\n\t\t\t\t\t\ta.num++;\n\t\t\t\t\t\ta.last = g[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j] = max(dp[i][j], a);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (g[i][j] <= m) {\n\t\t\t\tans = max(ans, dp[i][j]);\n\n\t\t\t}\n\t\t}\n\t\tpl = l;\n\t\tpr = r;\n\t\tl = max(l - 1, 0);\n\t\tr = min(r + 1, MAX_W - 1);\n\n\t}\n}\n\nvoid solve() {\n\teratos();\n\tmakeHole();\n\twhile (cin >> m >> n, m || n) {\n\n\t\trep(i,0,MAX_W)\n\t\t{\n\t\t\tfill(dp[i], dp[i] + MAX_W, answer());\n\t\t}\n\t\tdoDP(n2ij[n].first, n2ij[n].second);\n\t\tcout << ans.num << \" \" << ans.last << endl;\n\t}\n}\n\nint main() {\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <unordered_map>\n\n#define MOD7 1000000007\n#define MOD9 1000000009\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define REP(i, a, n) for (int i = (a); i <= (n); i++)\n#define all(a) (a).begin(), (a).end()\n\nusing namespace std;\n\nint dx[4] = { 0, -1, 0, 1 };\nint dy[4] = { -1, 0, 1, 0 };\n\nint nextInt() {int a; cin >> a; return a;}\nchar nextChar() {char a; cin >> a; return a;}\ndouble nextDouble() {double a; cin >> a; return a;}\nstring nextString() {string a; cin >> a; return a;}\n\nvoid inputVector(vector<int> &v, int &n) {rep(i,n){v.push_back(nextInt());}}\nvoid inputVector(vector<double> &v, int &n) {rep(i,n){v.push_back(nextDouble());}}\nvoid inputVector(vector<string> &v, int &n) {rep(i,n){v.push_back(nextString());}}\n\nconst int GETA = 510;\n\nbool isprime[1000010];\nbool prime[1100][1100];\npair<int, int> dp[1100][1100];\n\nmap<int, pair<int, int>> map1;\nmap<pair<int, int>, int> map2;\n\npair<int, int> solve(int n, int m) {\n    if (n > m) return make_pair(0, 0);\n\n    pair<int, int> &pos = map1[n];\n    if (dp[pos.first][pos.second].first != -1) return dp[pos.first][pos.second];\n\n    pair<int, int> ret = make_pair(0, 0);\n    REP(i, -1, 1) {\n\tpair<int, int> nt = make_pair(pos.first + i, pos.second + 1);\n\tif (map2.find(nt) == map2.end()) continue;\n\tpair<int, int> res = solve(map2[nt], m);\n\tif (res.first > ret.first\n\t\t|| (res.first == ret.first && res.second > ret.second)) {\n\t    ret = res;\n\t}\n    }\n    if (prime[pos.first][pos.second]) {\n\tret.first++;\n\tif (ret.first == 1) {\n\t    ret.second = n;\n\t}\n    }\n    dp[pos.first][pos.second] = ret;\n    return ret;\n}\n\nsigned main() {\n    rep(i, 1000001) isprime[i] = true;\n    isprime[1] = false;\n    REP(i, 2, 1000000) {\n\tif (!isprime[i]) continue;\n\tfor (int j = 2 * i; j <= 1000000; j += i) {\n\t    isprime[j] = false;\n\t}\n    }\n\n    int x = GETA, y = GETA;\n    int dir;\n    int size = 1;\n    int left;\n    for (int pt = 1; pt <= 1000000; pt++) {\n\tpair<int, int> pr = make_pair(x, y);\n\tmap1[pt] = pr;\n\tmap2[pr] = pt;\n\tif (isprime[pt]) {\n\t    prime[x][y] = true;\n\t}\n\tif (pt == size * size) {\n\t    x++;\n\t    size += 2;\n\t    dir = 0;\n\t    left = size - 2;\n\t} else {\n\t    x += dx[dir];\n\t    y += dy[dir];\n\t    left--;\n\t    if (left == 0) {\n\t\tdir++;\n\t\tleft = size - 1;\n\t    }\n\t}\n    }\n\n    int m, n;\n    while (cin >> m >> n) {\n\tif (m == 0) break;\n\n\tREP(i, 1, m) {\n\t    pair<int, int> &pr = map1[i];\n\t    dp[pr.first][pr.second] = make_pair(-1, 0);\n\t}\n\n\tpair<int, int> ret = solve(n, m);\n\n\tcout << ret.first << ' ' << ret.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF = 1000000000;\n\nint prime[100000];\nint primeNumber;\n\nint d[1011][1011];\nint xData[1030001];\nint yData[1030001];\nint p[1011][1011];\n\nint dp[1000001];\nbool used[1000001];\nint m, n;\n\nint main(){\n  prime[0] = 2;\n  primeNumber = 1;\n  for (int i = 3; i <= 1000000; i++) {\n    bool flag = true;\n    for (int j = 0; j < primeNumber; j++) {\n      if (i < prime[j] * prime[j]) break;\n      if (i % prime[j] == 0) {\n        flag = false;\n        break;\n      }\n    }\n    if (flag) prime[primeNumber++] = i;\n  }\n\n  int x = 505, y = 505; // 1(505, 505)\n  int counter = 2; // max move : counter / 2\n  int tempCounter = 1;\n  int moveDirection = 0; // right 0 up 1 left 2 down 3\n  for (int num = 1; num <= 1010000; num++) {\n    d[x][y] = num; xData[num] = x; yData[num] = y;\n    tempCounter--;\n    if (moveDirection == 0) x++;\n    if (moveDirection == 1) y--;\n    if (moveDirection == 2) x--;\n    if (moveDirection == 3) y++;\n    if (tempCounter == 0) {\n      counter++;\n      tempCounter = counter / 2;\n      moveDirection = (moveDirection + 1) % 4;\n    }\n  }\n\n  for (int i = 0; i < 1011; i++)\n    for (int j = 0; j < 1011; j++)\n      p[i][j] = 0;\n\n  for (int i = 0; i < primeNumber; i++)\n    p[xData[prime[i]]][yData[prime[i]]] = 1;\n\n  while (1) {\n    scanf(\"%d%d\", &m, &n);\n    if (m == 0) break;\n    \n    for (int i = 0; i < 1000001; i++)\n        dp[i] = -1;\n\n    for (int i = 0; i < 1000001; i++) used[i] = false;\n\n    queue<int> que;\n    que.push(n);\n    dp[n] = p[xData[n]][yData[n]];\n    int ans[2] = {0, 0};\n    if (dp[n] == 1) {\n      ans[0] = 1;\n      ans[1] = n;\n    }\n    while (!que.empty()) {\n      int z = que.front(); que.pop();\n      if (used[z]) continue;\n      used[z] = true;\n      for (int i = -1; i <= 1; i++) {\n        int x = xData[z] + i, y = yData[z] + 1;\n        int s = d[x][y];\n        if (s > m) continue;\n        if (dp[s] >= dp[z] + p[x][y]) continue;\n        dp[s] = dp[z] + p[x][y];\n        que.push(s);\n        if (ans[0] < dp[s]) {\n          ans[0] = dp[s];\n          if (p[x][y] == 1) ans[1] = s;\n        }\n        else if (ans[0] == dp[s] && ans[1] < s && p[x][y] == 1) ans[1] = s;\n      }\n    }\n    if (ans[0] == 0) ans[1] = 0;\n    printf(\"%d %d\\n\", ans[0], ans[1]);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i, a, b) for (int i = a; i < b; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define RFOR(i, a, b) for (int i = (b - 1); i >= a; i--)\n#define RREP(i, n) RFOR(i, 0, n)\n#define rep(i, a, b) for (auto i = a; i < b; i++)\n#define rrep(i, a, b) for (auto i = a; i > b; i--)\n#define fs first\n#define sc second\ntypedef pair<int, int> P;\n \nconst int N = 1111*1111;\nvector<int> flag(N, 0), prime(N,0);\nint n, m;\nint a[1111][1111];\nint ans[1111][1111];\nint visit[1111][1111];\nint sx, sy, cnt;\n \nvoid check(int cur, int x, int y) {\n    if (cur == n) sx = x, sy = y;\n}\n \nvoid bfs() {\n    queue<P> que;\n    que.push(P(sx, sy));\n \n    int dy[] = { -1,0,1 };\n    while (que.size()) {\n        P p = que.front(); que.pop();\n        if (p.fs + 1 == cnt) break;\n        REP(i, 3) {\n            int Y = p.sc + dy[i];\n            if (0 <= Y && Y < cnt && a[p.fs + 1][Y] <= m) {\n                ans[p.fs + 1][Y] = max(ans[p.fs + 1][Y],ans[p.fs][p.sc] + (prime[a[p.fs + 1][Y]] == 1));\n                if(visit[p.fs + 1][Y] == 0) que.push(P(p.fs + 1, Y)), visit[p.fs+1][Y]++;\n            }\n        }\n    }\n}\n \nvoid solve() {\n    cin >> m >> n;\n    if (n == 0) exit(0);\n    cnt = 1;\n    while (cnt*cnt < m) cnt += 2;\n \n    int cur = 2, id = 1, x = cnt / 2, y = cnt / 2;\n    a[x][y] = 1;\n \n    if (n == 1) sx = x, sy = y;\n     \n    while (cur <= cnt * cnt) {\n        REP(_, id) y++, a[x][y] = cur, check(cur,x,y),cur++;\n        REP(_, id) { x--, a[x][y] = cur, check(cur, x, y), cur++; if (cur > cnt*cnt) goto out; }\n        REP(_, id + 1) y--, a[x][y] = cur, check(cur, x, y),cur++;\n        REP(_, id + 1) x++, a[x][y] = cur, check(cur, x, y),cur++;\n        id += 2;\n    }\n    out:;\n \n    //cout << sx << \" \" << sy;\n    REP(i, cnt) REP(j, cnt) ans[i][j] = 0, visit[i][j] = 0;\n    if (prime[a[sx][sy]]) ans[sx][sy] = 1;\n    bfs();\n \n    //cout << sx << \" \" << sy << endl;\n \n    int res = 0 ,num = 0;\n    REP(i, cnt) REP(j, cnt) {\n        if (prime[a[i][j]] == 0) continue;\n        if (ans[i][j] > res) res = ans[i][j], num = a[i][j];\n        else if (ans[i][j] == res) num = max(num, a[i][j]);\n    }\n \n    if (res == 0) cout << \"0 0\" << endl;\n    else cout << res << \" \" << num << endl;\n \n}\n \n \nint main() {\n    FOR(i, 2, N) {\n        if (flag[i] == 0) {\n            prime[i]++;\n            FOR(j, 1, N) {\n                if (i*j >= N) break;\n                flag[i*j]++;\n            }\n        }\n    }\n \n    while (1) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint field[1010][1010];\npair<int, int> pos[1000001];  // 添字の番号の場所\nint memo[1010][1010];\nbool notPrime[1000001];\nint ansx, ansy;\nint m, n;\nvoid rec(int x, int y, int cnt) {\n  if (!notPrime[field[x][y]] &&\n      (memo[ansx][ansy] < cnt ||\n       (memo[ansx][ansy] == cnt && field[ansx][ansy] < field[x][y]))) {\n    ansx = x;\n    ansy = y;\n  }\n  \n  int dx[] = {-1, 0, 1};\n  int dy[] = {1, 1, 1};\n  for (int i = 0; i < 3; i++) {\n    int nx = x+dx[i];\n    int ny = y+dy[i];\n\n    if (field[nx][ny] == 0 || field[nx][ny] > m) continue;\n    if (memo[nx][ny] != -1 &&\n        memo[nx][ny] >= cnt+!notPrime[field[nx][ny]]) {\n      continue;\n    }\n    memo[nx][ny] = cnt+!notPrime[field[nx][ny]];\n    rec(nx, ny, memo[nx][ny]);\n  }\n  return ;\n}\n\nint main() {\n  memset(notPrime, false, sizeof(notPrime));\n  notPrime[1] = true;\n  for (int i = 2; i*i <= 1000000; i++) {\n    for (int j = i+i; j <= 1000000; j += i) {\n      notPrime[j] = true;\n    }\n  }\n  vector <int> prime;\n  for (int i = 2; i <= 1000000; i++) {\n    if (!notPrime[i]) {\n      prime.push_back(i);\n    }\n  }\n  \n  memset(field, 0, sizeof(field));\n  int bias = 1001/2;\n  int dx[] = {1, 0, -1, 0};\n  int dy[] = {0, -1, 0, 1};\n  int x = bias, y = bias;\n  field[x][y] = 1;\n  pos[1] = make_pair(x, y);\n  int p = 0;\n  for (int i = 2; i <= 1000000; i++) {\n    int nx, ny;\n    nx = x+dx[p%4];\n    ny = y+dy[p%4];\n    if (field[nx][ny] != 0) {\n      nx = x+dx[(p-1)%4];\n      ny = y+dy[(p-1)%4];\n      x = nx;\n      y = ny;\n      field[x][y] = i;\n      pos[i] = make_pair(x, y);\n    }else {\n      x = nx;\n      y = ny;\n      field[x][y] = i;\n      pos[i] = make_pair(x, y);\n      p++;\n    }\n  }\n\n  // for (int i = -10; i < 10; i++) {\n  //   for (int j = -10; j < 10; j++) {\n  //     std::cout << field[j+bias][i+bias] << \"\\t\";\n  //   }\n  //   std::cout << \"\" << std::endl;\n  // }\n  // return 0;\n  \n  while (true) {\n    cin >> m >> n;\n    if (m == 0 && n == 0) break;\n\n    memset(memo, -1, sizeof(memo));\n    int tx = pos[n].first, ty = pos[n].second;\n    // std::cout << tx-bias << \" \" << ty-bias << std::endl;\n    ansx = tx; ansy = ty;\n    memo[tx][ty] = !notPrime[n];\n    rec(tx, ty, memo[tx][ty]);\n    if (memo[ansx][ansy] == 0) {\n      std::cout << 0 << \" \" << 0 << std::endl;\n    }else {\n      std::cout << memo[ansx][ansy] << \" \" << field[ansx][ansy] << std::endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define MAX_N 1000000\n#define L 1000\nusing namespace std;\nstruct cave{\n\tint num;\n\tint pnum;\t//探索した素数洞穴の総数\n\tint lastp;\t//最後に通った素数の値\n};\n\nstruct cave hole[L+1][L+1];\nbool prime[MAX_N+1];\n\nint main(){\n\tfor(int i = 0; i < MAX_N+1; i++){\n\t\tprime[i] = true;\n\t}\n\tprime[0] = prime[1] = false;\t//prime[1]:1\n\tfor(int i = 2; i <= MAX_N; i++){\n\t\tif(prime[i] == true){\n\t\t\tfor(int j = 2*i; j < MAX_N; j += i){\n\t\t\t\tprime[j] = false;\n\t\t\t}\n\t\t}\n\t}\t//素数判定\n\tfor(int i = 0; i < L/2; i++){\n\t\tfor(int j = 0; j < 2*i+1; j++){\n\t\t\thole[-i-1+L/2][-i+j+L/2-1].num = (2*i+2)*(2*i+2)-j;\n\t\t\thole[-i-1+j+L/2][i+1+L/2-1].num = (2*i+1)*(2*i+2)+1-j;\n\t\t\thole[i+L/2][i+1-j+L/2-1].num = (2*i+1)*(2*i+1)+1-j;\n\t\t\thole[i-j+L/2][-i+L/2-1].num = 2*i*(2*i+1)+1-j;\n\t\t}\n\t}\t//mapping\n\tint m,n;\n\twhile(cin >> m >> n,m){\n\t\tint sy = -1,sx = -1;\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tfor(int j = 0; j < L; j++){\n\t\t\t\tif(hole[i][j].num == n){\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(sy!=-1&&sx!=-1){break;}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tfor(int j = 0; j < L; j++){\n\t\t\t\thole[i][j].pnum = 0;\n\t\t\t\thole[i][j].lastp = 0;\n\t\t\t}\n\t\t}\t//hole初期化\n\n\n\t\tif(prime[hole[sy][sx].num] == true){\n\t\t\thole[sy][sx].pnum = 1;\n\t\t\thole[sy][sx].lastp = hole[sy][sx].num;\n\t\t}\n\t\tfor(int i = sy+1; i < L; i++){\t//syのあった段から下に見ていく\n\t\t\tfor(int j = max(0,sx-(i-sy)); j <= min(sx+(i-sy),L-1); j++){\n\t\t\t\tif(hole[i][j].num <= m){\t//洞穴の個数以上の場所は見ない\n\t\t\t\t\tint tmp = 0,maxtmp = 0;\n\t\t\t\t\tfor(int k = -1; k <= 1; k++){\n\t\t\t\t\t\tif(max(0,sx-(i-sy)) <= j+k && j+k <= min(sx+(i-sy),L-1) && maxtmp < hole[i-1][j+k].pnum){\n\t\t\t\t\t\t\tmaxtmp = hole[i-1][j+k].pnum;\n\t\t\t\t\t\t\ttmp = hole[i-1][j+k].lastp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\thole[i][j].pnum = maxtmp;\n\t\t\t\t\thole[i][j].lastp = tmp;\n\t\t\t\t\tif(prime[hole[i][j].num] == true){\n\t\t\t\t\t\thole[i][j].pnum ++;\n\t\t\t\t\t\thole[i][j].lastp = hole[i][j].num;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint maxtmp = -1;\n\t\tint last = 0;\n\t\tfor(int i = 0; i < L; i++){\n\t\t\tfor(int j = 0; j < L; j++){\n\t\t\t\tif(hole[i][j].num <= m){\n\t\t\t\t\tif(hole[i][j].pnum == maxtmp && hole[i][j].lastp > last){\n\t\t\t\t\t\tlast = hole[i][j].lastp;\n\t\t\t\t\t}else if(hole[i][j].pnum > maxtmp){\n\t\t\t\t\t\tmaxtmp = hole[i][j].pnum;\n\t\t\t\t\t\tlast = hole[i][j].lastp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << maxtmp << \" \" << last << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE + 10][SIZE + 10], dp[SIZE + 10][SIZE + 10], pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (y>=0&&x>=0&&table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t\n\t\tfor (int h = 0;h < SIZE;h++) {\n\t\t\tfor (int w = 0;w < SIZE;w++) {\n\t\t\t\tif (table[h][w] == n) {\n\t\t\t\t\tcout << dp[h][w] << \" \" << pr[h][w] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int,int> P;\n\nP suindex[1000001];\nint cave[3000][3000];//始点は(550,550)\nbool sosu[1000001];\n\nvoid hurui()\n{\n\tfill(sosu,sosu+1000001,true);\n\tsosu[0]=false;\n\tsosu[1]=false;\n\tfor(int i=2;i<1000001;i++)\n\t{\n\t\tif(sosu[i])\n\t\t{\n\t\t\tfor(int j=i*2;j<1000001;j+=i)\n\t\t\t\tsosu[j]=false;\n\t\t}\n\t}\n\treturn;\n}\n\n//洞窟を作る\nvoid setup()\n{\n\tfill(cave[0],cave[3000],1e8-1);\n\tint hen=1;\n\tint adir[]={0,-1,0,1};\n\tint bdir[]={1,0,-1,0};\n\tint dirin=0;\n\tint a=1500;\n\tint b=1500;\n\tint num=1;\n\tint cnt=0;\n\tcave[a][b]=num;\n\tsuindex[num]=P(a,b);\n\tnum++;\n\twhile(num<1000001)\n\t{\n\t\tfor(int i=0;i<hen;i++)\n\t\t{\n\t\t\ta+=adir[dirin];\n\t\t\tb+=bdir[dirin];\n\t\t\tsuindex[num]=P(a,b);\n\t\t\tcave[a][b]=num;\n\t\t\tnum++;\n\t\t}\n\t\tdirin++;\n\t\tdirin%=4;\n\t\tcnt++;\n\t\tif(cnt==2)\n\t\t{\n\t\t\then++;\n\t\t\tcnt=0;\n\t\t}\n\t}\n\treturn;\n}\n\nP dp[3000][3000];\n\nP solve(int m,int st)\n{\n\tint a=suindex[st].first;\n\tint b=suindex[st].second;\n\tP ret=P(0,0);\n\tfill(dp[0],dp[3000],P(-1,0));\n\t//初期位置\n\tif(sosu[st])\n\t\tdp[a][b]=P(1,st);\n\telse\n\t\tdp[a][b]=P(0,0);\n\t//ここからdp\n\t//一段ずつ調べる\n\tfor(int i=a;i<3000;i++)\n\t{\n\t\tfor(int j=0;j<3000;j++)\n\t\t{\n\t\t\tif(dp[i][j].first==-1)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t//更新\n\t\t\t//左下\n\t\t\t//cerr<<cave[i][j]<<endl;\n\t\t\t//cerr<<cave[i+1][j-1]<<\" \"<<cave[i+1][j]<<\" \"<<cave[i+1][j+1]<<endl;\n\t\t\tint num=cave[i+1][j-1];\n\t\t\tif(num>m)\n\t\t\t{\n\t\t\t\tret=max(ret,dp[i][j]);\n\t\t\t}else{\n\t\t\t\tif(sosu[num])\n\t\t\t\t\tdp[i+1][j-1]=max(dp[i+1][j-1],P(dp[i][j].first+1,num));\n\t\t\t\telse\n\t\t\t\t\tdp[i+1][j-1]=max(dp[i+1][j-1],dp[i][j]);\n\t\t\t}\n\t\t\t//下\n\t\t\tnum=cave[i+1][j];\n\t\t\tif(num>m)\n\t\t\t{\n\t\t\t\tret=max(ret,dp[i][j]);\n\t\t\t}else{\n\t\t\t\tif(sosu[num])\n\t\t\t\t\tdp[i+1][j]=max(dp[i+1][j],P(dp[i][j].first+1,num));\n\t\t\t\telse\n\t\t\t\t\tdp[i+1][j]=max(dp[i+1][j],dp[i][j]);\n\t\t\t}\n\t\t\t//右下\n\t\t\tnum=cave[i+1][j+1];\n\t\t\tif(num>m)\n\t\t\t{\n\t\t\t\tret=max(ret,dp[i][j]);\n\t\t\t}else{\n\t\t\t\tif(sosu[num])\n\t\t\t\t\tdp[i+1][j+1]=max(dp[i+1][j+1],P(dp[i][j].first+1,num));\n\t\t\t\telse\n\t\t\t\t\tdp[i+1][j+1]=max(dp[i+1][j+1],dp[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\t//ここまでdp\n\treturn ret;\n}\n\nint main()\n{\n\thurui();\n\t//cerr<<\"hurui\"<<endl;\n\tsetup();\n\t//cerr<<\"setup\"<<endl;\n\twhile(1)\n\t{\n\t\tint m,n;\n\t\tcin>>m>>n;\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tP ans=solve(m,n);\n\t\tcout<<ans.first<<\" \"<<ans.second<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(y=SIZE-1;y>=0;y--){\n\t\t\tfor(x=SIZE-1;x>=0;x--){\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&\n\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x - 1]||(dp[y][x] == dp[y + 1][x - 1] && pr[y][x] < pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && \n\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x] || (dp[y][x] == dp[y + 1][x] && pr[y][x] < pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && \n\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x + 1] || (dp[y][x] == dp[y + 1][x + 1] && pr[y][x] < pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (y = 0;y < SIZE;y++) {\n\t\t\tfor (x = 0;x < SIZE;x++) {\n\t\t\t\tif (table[y][x] == n) {\n\t\t\t\t\tcout << dp[3][3] << \" \" << pr[y][x] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cassert>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include <iomanip>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n#define rep(i,j) for(int i=0;i<(int)(j);i++)\n#define repeat(i,j,k) for(int i=(j);i<(int)(k);i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" \" << x << endl;\nconst int INF = 1 << 30;\n\ntemplate<typename T>\nistream& operator >> (istream &is , vector<T> &v){\n    rep(i,v.size()) is >> v[i]; return is;\n}\n\ntemplate<class T>\nvoid debug_table(vector<vector<T>> &G) {\n    rep(i, G.size()) {\n        rep(j, G[i].size()){\n            cerr << setw(3) << (G[i][j] == INF ? -1 : G[i][j]) << (j == G[i].size() - 1 ? \"\\n\" : \" \");\n        }\n    }\n}\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nconst int MAX_M = 1000000 + 1;\n\nvector<vector<int>> G;\nvector<pair<int,int>> coordinate;\nvector<int> is_prime;\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nvoid generate_prime_table() {\n    is_prime.resize(MAX_M + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    repeat(i, 2, ceil(sqrt(MAX_M))) {\n        if(not is_prime[i]) continue;\n        for(int j = i * 2; j < is_prime.size(); j += i) {\n            is_prime[j] = false;\n        }\n    }\n}\n\nvoid generate_map() {\n    int HW = sqrt(MAX_M) * 1.2;\n    const int dx[] = {0, 1, 0, -1};\n    const int dy[] = {1, 0, -1, 0};\n\n    G = decltype(G)(HW, vector<int>(HW, INF));\n    coordinate.resize(MAX_M + 1);\n    {\n        int y, x;\n        y = x = HW / 2;\n        int current_h = 1;    // ????????¨?????????????????????\n        int corner_count = 3;\n        int dir = 1;\n\n        for(int i = 1, count = 1; i < MAX_M + 1; i++, count--) {\n            if(count == 0){ // ?§?\n                corner_count++;\n                if(corner_count >= 4) { // ?¬??????¨\n                    current_h += 2;\n                    corner_count = 0;\n                }\n                // ???????????????????????????????????§??????????????¨???\n                // ??????????????????????????¨????????????????????§ - 1 \n                count = current_h - 1 + (corner_count == 3) - (corner_count == 0);\n                dir = (dir + 1) % 4;\n            }\n            G[y][x] = i;\n            coordinate[i] = make_pair(y, x);\n            \n            y = y + dy[dir];\n            x = x + dx[dir];\n        }\n    }\n}\n\nbool solve(){\n    int m, n; cin >> m >> n;\n    if(m == 0 and n == 0) return false;\n\n    int sy = coordinate[n].first;\n    int sx = coordinate[n].second;\n\n    vector<pair<int,int>> dp[2];\n    rep(i, 2) dp[i].resize(G[0].size(), make_pair(-1, 0));\n    dp[sy % 2][sx] = make_pair(is_prime[G[sy][sx]],\n                               is_prime[G[sy][sx]] ? G[sy][sx] : 0);\n    \n    bool flg = true;\n    pair<int,int> ans = dp[sy%2][sx];\n    int y = sy;\n    while(flg) {\n        flg = false;\n        int ny = y + 1;\n        fill(all(dp[ny % 2]), make_pair(-1, 0));\n        \n        rep(x, dp[y%2].size()) {\n            if(dp[y%2][x].first >= 0) {\n                for(int nx : {x - 1, x, x + 1}){\n                    if(0 <= nx and nx < dp[y%2].size()) {\n                        if(G[ny][nx] > m) continue;\n                        auto nxt = dp[y%2][x];\n                        if(is_prime[G[ny][nx]]) {\n                            nxt.first += 1;\n                            nxt.second = G[ny][nx];\n                        }\n                        dp[ny%2][nx] = max(dp[ny%2][nx], nxt);\n                        ans = max(ans, dp[ny%2][nx]);\n                        flg = true;\n                    }\n                }\n            }\n            // cerr << setw(3) << dp[y%2][x].first << \" \";\n        }\n        // cerr << endl;\n        y = ny;\n    }\n    cout << ans.first << \" \" << ans.second << endl;\n    \n    return true;\n}\n\nint main(){\n    generate_map();\n    generate_prime_table();\n    // debug_table(G);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[(SIZE + 1)*(SIZE + 1) + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tint res1, res2;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= (SIZE + 1)*(SIZE + 1);i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= (SIZE + 1)*(SIZE + 1);j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 || n == 0)return 0;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = SIZE - 1;i >= 0;i--){\n\t\t\tfor(int j = SIZE - 1;j >= 0;j--){\n\t\t\t\tif (table[i][j] <= m) {\n\t\t\t\t\tif (i + 1 < SIZE) {\n\t\t\t\t\t\tif (j > 0 && table[i + 1][j - 1] <= m && (dp[i][j] < dp[i + 1][j - 1] || (dp[i][j] == dp[i + 1][j - 1] && pr[i][j] < pr[i + 1][j - 1]))) {\n\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j - 1];\n\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j - 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (table[i + 1][j] <= m && (dp[i][j] < dp[i + 1][j] || (dp[i][j] == dp[i + 1][j] && pr[i][j] < pr[i + 1][j]))) {\n\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j];\n\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j + 1 < SIZE && table[i + 1][j + 1] <= m && (dp[i][j] < dp[i + 1][j + 1] || (dp[i][j] == dp[i + 1][j + 1] && pr[i][j] < pr[i + 1][j + 1]))) {\n\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j + 1];\n\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!prime[table[i][j]]) {\n\t\t\t\t\t\tdp[i][j]++;\n\t\t\t\t\t\tif (pr[i][j] == 0) {\n\t\t\t\t\t\t\tpr[i][j] = table[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tres1 = dp[i][j];\n\t\t\t\t\tres2 = pr[i][j];\n\t\t\t\t\t//printf(\"%d\\n\", dp[y][x]);\n\t\t\t\t\t//cout << dp[y][x] << \" \";\n\t\t\t\t\t//cout << pr[y][x] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", res1, res2);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvoid solve(){\n    vector<bool> is_prime(1e6+1,true);\n    is_prime[0]=is_prime[1]=false;\n    rep(i,2,1e+6+1){\n        if(!is_prime[i]) continue;\n        for(int j=i*2; j<1e6+1; j+=i) is_prime[j]=false;\n    }\n    while(true){\n        int m,n;\n        cin >> m >> n;\n        if(m==0 and n==0) break;\n\n        map<pii,int> encode;\n        map<int,pii> decode;\n        map<int,vector<int>> xs;\n        {\n            int x=0,y=0,dir=3;\n            rep(i,1,m+1){\n                encode[make_pair(x,y)]=i;\n                decode[i]=make_pair(x,y);\n                xs[y].push_back(x);\n                int nx=x+dx[(dir+1)%4],ny=y+dy[(dir+1)%4];\n                if(encode.find(make_pair(nx,ny))==encode.end()) dir=(dir+1)%4;\n                else{\n                    nx=x+dx[dir];\n                    ny=y+dy[dir];\n                }\n                x=nx;\n                y=ny;\n            }\n        }\n\n        map<pii,int> dp;\n        int y=decode[n].second+1,ans,max_num;\n        if(is_prime[n]){\n            dp[decode[n]]=1;\n            ans=1;\n            max_num=n;\n        }else{\n            dp[decode[n]]=0;\n            ans=0;\n            max_num=0;\n        }\n        while(xs.find(y)!=xs.end()){\n            if(xs.find(y-2)!=xs.end()) for(int x:xs[y-2]) dp.erase(make_pair(x,y-2));\n            for(int x:xs[y]){\n                int tmp=-1;\n                if(dp.find(make_pair(x-1,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x-1,y-1)]);\n                if(dp.find(make_pair(x,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x,y-1)]);\n                if(dp.find(make_pair(x+1,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x+1,y-1)]);\n                if(tmp==-1) continue;\n                if(is_prime[encode[make_pair(x,y)]]){\n                    ++tmp;\n                    if(tmp>ans){\n                        ans=tmp;\n                        max_num=encode[make_pair(x,y)];\n                    }else if(tmp==ans) max_num=max(max_num,encode[make_pair(x,y)]);\n                }\n                dp[make_pair(x,y)]=tmp;\n            }\n            ++y;\n        }\n\n        cout << ans << \" \" << max_num << endl;\n    }\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n \nconst ll MOD=1e9+7;\nconst ll INF=1e18;\n \nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\n\nint m[1600][1600];\nint dp[1600][1600][2];\nbool prime[1000010];\n\nint main(){\n    int a = 800,b = 800;\n    int dir; //今向いている方向\n    m[a][b] = 1;\n    b += 1;\n    m[a][b] = 2;\n    a -= 1;\n    dir = 1;\n    for(int i = 3;i <= 1000000;i++){\n        m[a][b] = i;\n        if(dir == 0){ //→\n            if(m[a-1][b] != 0){\n                b += 1;\n            }else{\n                a -= 1;\n                dir = 1;\n            }\n        }else if(dir == 1){ // ↑\n            if(m[a][b-1] != 0){\n                a -= 1;\n            }else{\n                b -= 1;\n                dir = 2;\n            }\n        }else if(dir == 2){ //←\n            if(m[a+1][b] != 0){\n                b -= 1;\n            }else{\n                a += 1;\n                dir = 3;\n            }\n        }else{ //↓\n            if(m[a][b+1] != 0){\n                a += 1;\n            }else{\n                b += 1;\n                dir = 0;\n            }\n        }\n    }\n\n    prime[1] = true;\n    for(int i = 2;i <= 1000000;i++){ //エラトス\n        if(prime[i] == false){\n            for(int j = 2;i*j <= 1000000;j++){\n                prime[i*j] = true;\n            }\n        }\n    }\n    int mm,n;\n    while(true){\n        cin >> mm >> n;\n        if(mm == 0 && n == 0)break;\n        for(int i = 0;i < 1500;i++){\n            for(int j = 0;j < 1500;j++){\n                dp[i][j][0] = 0;\n                dp[i][j][1] = 0;\n                if(m[i][j] == n){\n                    a = i;\n                    b = j;\n                }\n            }\n        }\n        //cout << \"a:\" << a << \",b:\" << b << endl;\n        int aans = 0,bans = 0;\n        if(prime[n] == false){\n            dp[a][b][0] = 1;\n            dp[a][b][1] = n;\n            aans = 1;\n            bans = n;\n        }\n        for(int i = a+1;i < 1500;i++){\n            for(int j = b-(i-a);j <= b+(i-a);j++){\n                if(m[i][j] == 0 || m[i][j] > mm)continue;\n                int amax = 0,bmax = 0;\n                for(int k = -1;k <= 1;k++){\n                    if(amax < dp[i-1][j+k][0]){\n                        amax = dp[i-1][j+k][0];\n                        bmax = dp[i-1][j+k][1];\n                    }else if(amax == dp[i-1][j+k][0] && bmax < dp[i-1][j+k][1]){\n                        bmax = dp[i-1][j+k][1];\n                    }\n                }\n                if(prime[m[i][j]] == false){\n                    amax++;\n                    bmax = m[i][j];\n                }\n                dp[i][j][0] = amax;\n                dp[i][j][1] = bmax;\n                if(aans < amax){\n                    aans = amax;\n                    bans = bmax;\n                }else if(aans == amax && bans < bmax){\n                    bans = bmax;\n                }\n            }\n        }\n        cout << aans << \" \" << bans << endl;\n    }\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <stdlib.h>\n#include <math.h>\n#include <list>\n#include <algorithm>\n\nusing namespace std;\n\n//平方数かどうか調べる\nint isSq(int n) {\n\tif(n <= 0) return 0;\n\n\tfor(int i = 1; i <= (int)sqrt( (double)n ) + 1; i++) {\n\t\tif( n % i == 0 && n / i == i ) return i;\n\t}\n\t\n\treturn 0;\n}\n//素数かどうか調べる\nint isPrime(int n) {\n\tif(n <= 1) return 0;\n\tint flg = 1;\n\tfor(int i = 2; i <= (int)sqrt((double)n) + 1; i++) {\n\t\tif( n % i == 0) {\n\t\t\tflg = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn flg;\n}\n\nstruct memo{\n\tint last;\n\tint pts;\n};\nstruct cave{\n\tint x;\n\tint y;\n\tint flg;\n\tint num;\n};\nstruct indx{\n\tint last;\n\tint pts;\n\tbool operator<( const indx& right ) const {\n        return pts == right.pts ? last < right.last : pts < right.pts;\n    }\n};\n\n//動的計画法で探査\n//番号が決まれば得点がきまるはず\nvoid search_cave(int n, int xpos, int ypos, vector<memo>*m, vector<vector<int>> *cv, vector<cave> *cl, int h, int w){\n\n\tif( m -> at(n).last != -1 ) {\n\t\t//探索済みの場合\n\t\treturn;\n\t} else {\n\t\t//未探索の場合\n\t\t//直下の三洞窟を探索する\n\t\t//直下三通りはすでに探索済みとする\n\n\t\tif( ypos == h - 1 ) {\n\t\t\t//一番下ならば？\n\t\t\tm->at(n).pts = cl->at(n).flg;\n\t\t\tm->at(n).last = 0;\n\t\t\tif(cl->at(n).flg == 1) m->at(n).last = n;\n\t\t} else {\n\t\t\t//降りられる洞穴がある場合\n\t\t\tindx index[3];\n\t\t\tfor(int i = 0; i < 3; i++) {\n\t\t\t\tindex[i].pts = -1;\n\t\t\t\tindex[i].last = -1;\n\t\t\t}\n\n\t\t\t//左右移動できるか確認する\n\t\t\tif( xpos > 0 )\t{\t//左下\n\t\t\t\tint tmp = cv->at( xpos - 1 ).at( ypos + 1 );\n\t\t\t\tindex[0].pts = m->at( tmp ).pts;\n\t\t\t\tindex[0].last = m->at(tmp).last;\n\t\t\t}\n\t\t\tif( xpos < w - 1) { //右下\n\t\t\t\tint tmp = cv->at( xpos + 1 ).at( ypos + 1 );\n\t\t\t\tindex[1].pts = m->at( tmp ).pts;\n\t\t\t\tindex[1].last = m->at( tmp ).last;\n\t\t\t}\n\t\t\tif( 1 ) {\t\t\t//真下\n\t\t\t\tint tmp = cv -> at( xpos ).at( ypos + 1 );\n\t\t\t\tindex[2].pts = m -> at( tmp ).pts;\n\t\t\t\tindex[2].last = m -> at( tmp ).last;\n\t\t\t}\n\n\t\t\t//大小比較する\n\t\t\tsort(index,index+3);\n\n\t\t\tm -> at(n).pts = index[2].pts + cl -> at(n).flg ;\n\t\t\tm -> at(n).last = index[2].last;\n\t\t\tif(index[2].last <= 0 && cl -> at(n).flg > 0) m -> at(n).last = n;\n\n\t\t}\n\t}\n}\n\nint main(void){\n\t//FILE* fp_in = freopen(\"data.txt\", \"r\", stdin);\n\twhile(1){\n\t\tint m, n;\n\t\tvector<cave> clist;\n\n\t\tcin >> m >> n;\n\t\tif( m == 0 && n == 0 ) break;\n\t\t\n\t\tcave c;\n\t\tc.x = -1;\n\t\tc.y = 0;\n\t\tc.flg = 0;\n\t\tc.num = 0;\n\t\tclist.push_back(c);\n\n\t\t//洞窟の大きさを調べる\n\t\tint dir = 0, sq = 1;\n\t\tfor(int i = 1; i <= m; i ++) {\n\t\t\tif( isSq(i) != 0 ) \n\t\t\t\tsq = isSq(i);\n\t\t\t//進む\n\t\t\tswitch(dir) {\n\t\t\t\tcase 0:\n\t\t\t\t\tc.x ++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tc.y --;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tc.x --;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tc.y ++;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//方向転換\n\t\t\tif( ( isSq( i - 1 ) != 0 ) || ( i == sq*sq + sq + 1 ) ) { \n\t\t\t\tdir ++;\n\t\t\t\tif( dir > 3 ) dir = 0;\n\t\t\t}\n\t\t\tc.flg = isPrime(i);\n\t\t\tc.num = i;\n\t\t\tclist.push_back(c);\n\t\t}\n\n\t\t//洞窟の大きさを取得する\n\t\tint x_max = 0, x_min = 0, y_max = 0, y_min = 0;\n\t\tfor(int i = 1; i < clist.size(); i++) {\n\t\t\tif( clist.at(i).x < x_min ) x_min = clist.at(i).x;\n\t\t\tif( clist.at(i).x > x_max ) x_max = clist.at(i).x;\n\t\t\tif( clist.at(i).y < y_min ) y_min = clist.at(i).y;\n\t\t\tif( clist.at(i).y > y_max ) y_max = clist.at(i).y;\n\t\t}\n\n\t\t//上端のy座標を0にセット\n\t\tfor(int i = 1; i < clist.size(); i++) {\n\t\t\tclist.at(i).y -= y_min;\n\t\t\tclist.at(i).x -= x_min;\n\t\t}\n\t\t\n\t\t//洞穴を意味するvector\n\t\tvector<vector<int>> caves;\n\t\tfor(int i = 0; i <= x_max - x_min; i++) {\n\t\t\tvector<int> newcave;\n\t\t\tfor(int j = 0; j <= y_max - y_min; j++)\n\t\t\t\tnewcave.push_back(0);\n\t\t\tcaves.push_back(newcave);\n\t\t}\n\n\t\t//番号をセットする\n\t\tfor(int i = 1; i < clist.size(); i++) \n\t\t\tcaves.at( clist.at(i).x ).at( clist.at(i).y ) = clist.at(i).num;\n\n\t\t//メモ用vector\n\t\tvector<memo> memory;\n\t\tfor(int i = 0; i < clist.size() + 2; i++) {\n\t\t\tmemo newmemo;\n\t\t\tnewmemo.last = -1;\n\t\t\tnewmemo.pts = 0;\n\t\t\tmemory.push_back(newmemo);\n\t\t}\n\n\t\tint height = caves.at(0).size();\n\t\tint width = caves.size();\n\t\tint ans[2];\n\t\tint flg = 0;\n\t\n\n\t\t//一番下から調べる\n\t\tfor(int i = height - 1; i >= 0; i--) {\n\t\t\tfor(int j = 0; j < width; j++) {\n\t\t\t\tint num = caves.at(j).at(i);\n\t\t\t\tsearch_cave(num, j, i, &memory, &caves, &clist, height, width);\n\t\t\t\tif( num == n ) {\n\t\t\t\t\tflg = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg) break;\n\t\t}\n\t\t\n\n\t\tans[0] = memory.at(n).pts;\n\t\tans[1] = memory.at(n).last;\n\t\tif( ans[0] == 0 ) ans[1] = 0;\n\n\t\tcout << ans[0] << \" \" << ans[1] << endl;\n\t}\n\n\t//while(1){}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nnamespace std {\n    template <>\n    class hash<std::pair<int, int>> {\n    public:\n        size_t operator()(const std::pair<int, int>& x) const{\n            return size_t((size_t)x.first * (size_t)x.second * 2);\n        }\n    };\n}\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvoid solve(){\n    vector<bool> is_prime(1e6+1,true);\n    is_prime[0]=is_prime[1]=false;\n    rep(i,2,1e+6+1){\n        if(!is_prime[i]) continue;\n        for(int j=i*2; j<1e6+1; j+=i) is_prime[j]=false;\n    }\n    while(true){\n        int m,n;\n        cin >> m >> n;\n        if(m==0 and n==0) break;\n\n        unordered_map<pii,int> encode;\n        unordered_map<int,pii> decode;\n        unordered_map<int,vector<int>> xs;\n        {\n            int x=0,y=0,dir=3;\n            rep(i,1,m+1){\n                encode[make_pair(x,y)]=i;\n                decode[i]=make_pair(x,y);\n                xs[y].push_back(x);\n                int nx=x+dx[(dir+1)%4],ny=y+dy[(dir+1)%4];\n                if(encode.find(make_pair(nx,ny))==encode.end()) dir=(dir+1)%4;\n                else{\n                    nx=x+dx[dir];\n                    ny=y+dy[dir];\n                }\n                x=nx;\n                y=ny;\n            }\n        }\n\n        unordered_map<pii,int> dp;\n        int y=decode[n].second+1,ans,max_num;\n        if(is_prime[n]){\n            dp[decode[n]]=1;\n            ans=1;\n            max_num=n;\n        }else{\n            dp[decode[n]]=0;\n            ans=0;\n            max_num=0;\n        }\n        while(xs.find(y)!=xs.end()){\n            for(int x:xs[y]){\n                int tmp=-1;\n                if(dp.find(make_pair(x-1,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x-1,y-1)]);\n                if(dp.find(make_pair(x,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x,y-1)]);\n                if(dp.find(make_pair(x+1,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x+1,y-1)]);\n                if(tmp==-1) continue;\n                if(is_prime[encode[make_pair(x,y)]]){\n                    ++tmp;\n                    if(tmp>ans){\n                        ans=tmp;\n                        max_num=encode[make_pair(x,y)];\n                    }else if(tmp==ans) max_num=max(max_num,encode[make_pair(x,y)]);\n                }\n                dp[make_pair(x,y)]=tmp;\n            }\n            ++y;\n        }\n\n        cout << ans << \" \" << max_num << endl;\n    }\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize (\"O3\",\"unroll-loops\")\n#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<cstdlib>\n#include<cassert>\n\n#include<cmath>\n#include<functional>\n#include<algorithm>\n#include<numeric>\n\n#include<vector>\n#include<string>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<map>\n#include<bitset>\n#include<tuple>\n\n#define TEST {IS_TEST=true;}\n#define fi first\n#define se second\n#define pb(x) emplace_back(x)\n#define pf(x) emplace_front(x)\n#define emp(x) emplace(x)\n#define mp(x,y) make_pair(x,y)\n\nusing namespace std;\nusing ll = int_fast64_t;\nusing v_b = vector <bool>; using v_ll = vector <ll>; using str = string; using v_str = vector <string>; using p_ll = pair < ll,ll >;\nusing vv_b = vector < v_b >; using vv_ll = vector < v_ll >; using vp_ll = vector < p_ll >;\nusing vvv_ll = vector < vv_ll >; using vvp_ll = vector < vp_ll >;\nusing ld = long double; using v_ld = vector <ld>; using vv_ld = vector<v_ld>;\n\nbool IS_TEST=false;\nll ll_min64=1LL<<63;\nll ll_max64=~ll_min64;\nll ll_min32=1LL<<31;\nll ll_max32=~ll_min32;\n\nll MOD = 1000000007;\n\n/*displaying functions for debug*/\ntemplate<class T> void show2(const T &x){cerr << x;}\ntemplate<class T1,class T2> void show2(const pair<T1,T2> &x){\n  cerr << \"{\" << show2(x.first) << \",\" << show2(x.second) << \"}\";\n}\ntemplate<class T> void show(const T &x){\n  if (!IS_TEST) return; show2(x); cerr << \"\\n\";\n}\ntemplate<class T> void v_show(const T &v, ll n=-1){\n  if (!IS_TEST) return; auto itr=v.begin(); ll m=n;\n  while(itr!=v.end() && m!=0 ){ show2(*itr); cerr << \" \"; itr++; m--;}\n  cerr << \"\\n\";\n}\ntemplate<class T> void vv_show(const T &v, ll n=-1){\n  if (!IS_TEST) return;\n  cerr << \"--------------------------------\\n\";\n  auto itr=v.begin(); ll m=n;\n  while(itr!=v.end() && m!=0 ){ v_show(*itr,n); itr++; m--;}\n  cerr << \"--------------------------------\\n\";\n}\n/*--------------------------------*/\n\n/*loading integers*/\nvoid load(ll& x1){ cin >> x1; }\nvoid load(ll& x1,ll& x2){ cin >> x1 >> x2; }\nvoid load(ll& x1,ll& x2,ll& x3){ cin >> x1 >> x2 >> x3; }\nvoid load(ll& x1,ll& x2,ll& x3,ll& x4){ cin >> x1 >> x2 >> x3 >> x4; }\nvoid v_load(ll n, v_ll& v1, ll head=0, ll tail=0, ll init=0){\n    ll m=n+head+tail; v1.assign(m,init);\n    for (ll i=0;i<n;i++){ scanf(\"%lld\",&v1[i+head]); }\n}\nvoid v_load(ll n, v_ll& v1 ,v_ll& v2, ll head=0, ll tail=0, ll init=0){\n    ll m=n+head+tail; v1.assign(m,init); v2.assign(m,init);\n    for (ll i=0;i<n;i++){ scanf(\"%lld%lld\",&v1[i+head],&v2[i+head]); }\n}\nvoid v_load(ll n, v_ll& v1 ,v_ll& v2, v_ll& v3, ll head=0, ll tail=0, ll init=0){\n    ll m=n+head+tail; v1.assign(m,init); v2.assign(m,init); v3.assign(m,init);\n    for (ll i=0;i<n;i++){ scanf(\"%lld%lld%lld\",&v1[i+head],&v2[i+head],&v3[i+head]); }\n}\nvoid v_load(ll n, v_ll& v1 ,v_ll& v2, v_ll& v3, v_ll& v4, ll head=0, ll tail=0, ll init=0){\n    ll m=n+head+tail; v1.assign(m,init); v2.assign(m,init); v3.assign(m,init); v4.assign(m,init);\n    for (ll i=0;i<n;i++){ scanf(\"%lld%lld%lld%lld\",&v1[i+head],&v2[i+head],&v3[i+head],&v4[i+head]); }\n}\n/*--------------------------------*/\n\nv_ll local_sort(ll x1=ll_max64, ll x2=ll_max64, ll x3=ll_max64, ll x4=ll_max64){\n    v_ll x{x1,x2,x3,x4};\n    sort(x.begin(),x.end());\n    return x;\n}\n\nll max(ll x,ll y){return x>y?x:y;}\nll min(ll x,ll y){return x<y?x:y;}\n\nll max(v_ll::iterator b,v_ll::iterator e){\n    ll ans=*b;\n    while (b<e) {ans=max(ans,*b);b++;}\n    return ans;\n}\nll argmax(v_ll::iterator b,v_ll::iterator e){\n    ll ans=0, cnt=0, val=*b;\n    while (b<e) { if (val<*b) {ans=cnt; val=*b;} cnt++; b++;}\n    return ans;\n}\nll min(v_ll::iterator b,v_ll::iterator e){\n    ll ans=*b;\n    while (b<e) {ans=min(ans,*b);b++;}\n    return ans;\n}\nll argmin(v_ll::iterator b,v_ll::iterator e){\n    ll ans=0, cnt=0, val=*b;\n    while (b<e) { if (val>*b) {ans=cnt; val=*b;} cnt++; b++;}\n    return ans;\n}\nll sum(v_ll::iterator b,v_ll::iterator e){\n    ll ans=0;\n    while (b<e) {ans+=*b;b++;}\n    return ans;\n}\n\ntemplate<class T> bool chmax(T& x,const T& y){ if (x>=y) return false; x=y; return true;}\ntemplate<class T> bool chmin(T& x,const T& y){ if (x<=y) return false; x=y; return true;}\n\ntemplate<class T> void quit(T x){cout << x << endl; exit(0);}\nvoid yesno(bool x){cout << (x?\"Yes\":\"No\") <<endl;}\n\nll rup(ll x,ll y){return (x-1)/y+1;}\nll rem(ll x,ll y){ ll z=x%y; return z>=0?z:z+y; }\n\ntemplate<typename T>\nv_ll index_sort(const vector<T>& ref){\n    v_ll idx(ref.size());\n    iota(idx.begin(),idx.end(),0);\n    sort(idx.begin(),idx.end(),[&](auto &x, auto &y){if (ref[x]<ref[y]) return true;});\n}\n\n//setprecision(digit)\n//sort(##.begin(),##.end(),[&](auto &x, auto &y){if (x<y) return true;});\n//ll ok=0,ng=0; while(abs(ok-ng)>1){ll mid=(ok+ng)/2; (true?ok:ng)=mid;}\n\nstruct dat{\n    dat(){}\n    bool operator < (const dat& rhs)const {return false; }\n};\n\nv_b furui(ll n){\n    v_b v(n+1,true);\n    v[0]=false;v[1]=false;\n    for(ll i=2;i<=n;i++){\n        if (v[i])\n        for(ll j=i*2;j<=n;j+=i){\n            v[j]=false;\n        }\n    }\n    return v;\n}\n\nint main(){\n    v_b isprime=furui(1000000);\n    vv_ll V(1010,v_ll(1010,0));\n    vvp_ll ans(1010,vp_ll(1010,mp(0,0)));\n    while(true){\n        ll N,M;\n        cin >> M >> N;\n        if (M==0&&N==0) break;\n        ll cx=505,cy=505;\n        ll x=cx,y=cy;\n        \n        ll idx=2;\n        ll phase=0;\n        ll bx=0,by=0;\n        for(ll i=0;i<1010;i++){\n            for(ll j=0;j<1010;j++){\n                V[i][j]=0;\n            }\n        }\n        for(ll i=0;i<1010;i++){\n            for(ll j=0;j<1010;j++){\n                ans[i][j]=mp(0,0);\n            }\n        }\n        V[cy][cx]=1;\n        while(idx<=M){\n            for(ll i=0;i<phase*2+1;i++){\n                if(idx>M) break;\n                x++;\n                V[y][x]=idx;\n                if (idx==N){\n                    bx=x;by=y;\n                }\n                idx++;\n            }\n            for(ll i=0;i<phase*2+1;i++){\n                if(idx>M) break;\n                y--;\n                V[y][x]=idx;\n                if (idx==N){\n                    bx=x;by=y;\n                }\n                idx++;\n            }\n            for(ll i=0;i<phase*2+2;i++){\n                if(idx>M) break;\n                x--;\n                V[y][x]=idx;\n                if (idx==N){\n                    bx=x;by=y;\n                }\n                idx++;\n            }\n            for(ll i=0;i<phase*2+2;i++){\n                if(idx>M) break;\n                y++;\n                V[y][x]=idx;\n\n                if (idx==N){\n                    bx=x;by=y;\n                }\n                idx++;\n            }\n            phase++;\n        }\n/*\n        for(ll i=500;i<=510;i++){\n            for(ll j=500;j<=510;j++){\n                cerr<< V[i][j] <<\" \";\n            }\n            cerr<<endl;\n        }*/\n       p_ll a=mp(0,0);\n        for(ll i=1008;i>=0;i--){\n            for(ll j=1008;j>=1;j--){\n                chmax(ans[i][j],ans[i+1][j-1]);\n                chmax(ans[i][j],ans[i+1][j+0]);\n                chmax(ans[i][j],ans[i+1][j+1]);\n                if (isprime[V[i][j]]){\n                    ans[i][j].fi++;\n                    if (ans[i][j].se==0) ans[i][j].se=V[i][j];\n                }\n                if (V[i][j]==N) a=ans[i][j];\n            }\n        }\n        cout << a.fi <<\" \"<<a.se<<\"\\n\";\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nbool isso(long long int a) {\n\tif (a == 1 || a == 0)return false;\n\tfor (long long int i = 2; i*i <= a; ++i) {\n\t\tif ((a%i)) {\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,1,0,-1 };\npair<bool,int> caves[1199][1199];\npair<int,int> dp[1199][1199];\nvector<pair<int, int>>places(1010000);\n\nint main() {\n\t{\n\t\tfor (int i = 0; i < 1199; ++i) {\n\t\t\tfor (int j = 0; j < 1199; ++j) {\n\t\t\t\tcaves[i][j] = { false,-1 };\n\t\t\t}\n\t\t}\n\t\tint num = 1;\n\t\tint ny = 600;\n\t\tint nx = 600;\n\t\tint roopnum =2;\n\t\tint way = 2;\n\t\twhile (num <= 1000000) {\n\t\t\tfor (int i = 0; i < roopnum / 2; ++i) {\n\t\t\t\tcaves[ny][nx] = { isso(num),num };\n\t\t\t\tplaces[num] = { ny,nx };\n\t\t\t\tny += dy[way]; nx += dx[way];\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\troopnum++;\n\t\t\tway = (way + 1) % 4;\n\t\t}\n\t}\n\twhile (1) {\n\t\tint m, n; cin >> m >> n;\n\t\tif (!m)break;\n\t\tfor (int i = 0; i < 1199; ++i) {\n\t\t\tfor (int j = 0; j < 1199; ++j) {\n\t\t\t\tdp[i][j] = { -1,-999999 };\n\t\t\t}\n\t\t}\n\t\tint ny = places[n].first;\n\t\tint nx = places[n].second;\n\t\tif (caves[ny][nx].first) {\n\t\t\tdp[ny][nx] = { caves[ny][nx].second,1 };\n\t\t}\n\t\telse {\n\t\t\tdp[ny][nx] = { -1,0 };\n\n\t\t}\n\t\tfor (int y = 0; y < 1198; ++y) {\n\t\t\tfor (int x = 1; x < 1198; ++x) {\n\t\t\t\tfor (int ax = -1; ax <= 1; ++ax) {\n\t\t\t\t\tconst int newy = y + 1;\n\t\t\t\t\tconst int newx = x + ax;\n\t\t\t\t\tbool so = (caves[newy][newx].first)&&(caves[newy][newx].second <= m);\n\t\t\t\t\tconst int newsonum = dp[y][x].second + so;\n\t\t\t\t\tif (dp[newy][newx].second < newsonum) {\n\t\t\t\t\t\tdp[newy][newx].second = newsonum;\n\t\t\t\t\t\tif (so) {\n\t\t\t\t\t\t\tdp[newy][newx].first = caves[newy][newx].second;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdp[newy][newx].first = dp[y][x].first;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (dp[newy][newx].second == newsonum) {\n\t\t\t\t\t\tif (so) {\n\t\t\t\t\t\t\tdp[newy][newx].first = caves[newy][newx].second;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tdp[newy][newx].first = max(dp[newy][newx].first, dp[y][x].first);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint maxso = 0;\n\t\tint maxnum = 0;\n\t\tfor (int x = 0; x < 1199; ++x) {\n\t\t\tif (maxso == dp[1198][x].second) {\n\t\t\t\tmaxnum = max(maxnum, dp[1198][x].first);\n\t\t\t}\n\t\t\telse if(maxso<dp[1198][x].second){\n\t\t\t\tmaxso = dp[1198][x].second;\n\t\t\t\tmaxnum = dp[1198][x].first;\n\t\t\t}\n\t\t}\n\t\tcout << maxso << \" \" << maxnum << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst int INF = (1<<30);\nconst ll INFLL = (1ll<<60);\nconst ll MOD = (ll)(1e9+7);\n\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\ta = (a<MOD)?a:(a-MOD);\n\tb = (b<MOD)?b:(b-MOD);\n\ta += b;\n\ta = (a<MOD)?a:(a-MOD);\n}\n\nint x[1048577],y[1048577],mp[1024][1024],memo[1024][1024],m=1048576,p;\nbool isp[1048577],done[1024][1024];\n\nbool check(int p, int q){\n\treturn (!(0<=p&&p<1024&&0<=q&&q<1024));\n}\n\nint solve(int i, int j){\n\tif(check(i,j)){\n\t\treturn -INF;\n\t}\n\tif(done[i][j]){\n\t\treturn memo[i][j];\n\t}\n\tdone[i][j] = true;\n\tif(mp[i][j]>m){\n\t\treturn memo[i][j] = -INF;\n\t}else if(mp[i][j]==p){\n\t\treturn memo[i][j] = (isp[p]?1:0);\n\t}\n\treturn memo[i][j] = max(max(solve(i-1,j-1),solve(i-1,j+1)),solve(i-1,j))+((isp[mp[i][j]])?1:0);\n}\n\nint main(void){\n\tint i=0,j=0,k,dx[4]={0,1,0,-1},dy[4]={1,0,-1,0},ans;\n\twhile(m){\n\t\tx[m] = i;\n\t\ty[m] = j;\n\t\tmp[i][j] = m;\n\t\tif(check(i+dx[p],j+dy[p]) || mp[i+dx[p]][j+dy[p]]){\n\t\t\t++p; if(p==4){ p -= 4; }\n\t\t}\n\t\ti += dx[p]; j += dy[p];\n\t\t--m;\n\t}\n\tfill(isp,isp+1048577,true); isp[0] = false; isp[1] = false;\n\tfor(i=2; i<1048577; ++i){\n\t\tif(!isp[i]){\n\t\t\tcontinue;\n\t\t}\n\t\tfor(j=i*2; j<1048577; j+=i){\n\t\t\tisp[j] = false;\n\t\t}\n\t}\n\tcin >> m >> p;\n\twhile(m && p){\n\t\tfill(done[0],done[1024],false);\n\t\tans = -INF;\n\t\tfor(k=1; k<1048577; ++k){\n\t\t\tif(!isp[k]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = max(ans,solve(x[k],y[k]));\n\t\t}\n\t\tif(ans<=0){\n\t\t\tcout << \"0 0\" << endl;\n\t\t\tcin >> m >> p;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(k=1048576; k>0; --k){\n\t\t\tif(!isp[k]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(solve(x[k],y[k])==ans){\n\t\t\t\tcout << ans << \" \" << k << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcin >> m >> p;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1189&lang=jp\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define MAX_M 1000010\nbool Prime[MAX_M];\nint Caves[1002][1002];\npll state[1002][1002];\n\nvoid init_prime() {\n\tPrime[2] = true;\n\tfor (int i = 3; i < MAX_M; i += 2) {\n\t\tbool f = false;\n\t\tfor (int j = 2; j*j < i;j++) {\n\t\t\tif (i%j == 0) { f = true; break; }\n\t\t}\n\t\tif (!f) Prime[i] = true;\n\t}\n}\n\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\npair<int,int> init_Caves(int m,int n) {\n\t/* Caves initialize */\n\tmemset(Caves, 0, sizeof(Caves));\n\t/* initial state */\n\tint x, y; x = y = 500;\n\t/* next direction */\n\tint k = 0;\n\t/* step valiables */\n\tint steps = 1;\n\tint now_steps = 0;\n\tint count = 0;\n\t/* return valiables */\n\tpll ret;\n\tfor (int i = 1; i <= m;i++) {\n\t\t/* n locate & Caves */\n\t\tif (i == n) ret = { y,x };\n\t\tCaves[y][x] = i;\n\n\t\t/* next locate */\n\t\tx += dx[k]; y += dy[k];\n\n\t\t/* step */\n\t\tnow_steps++;\n\t\tif (steps == now_steps) {\n\t\t\tnow_steps = 0;\n\t\t\tk = (k + 1) % 4;\n\t\t\tcount = (count + 1) % 2;\n\t\t\tif (count == 0) {\n\t\t\t\tsteps++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nstruct _Cave {\n\tint y;\n\tint x;\n\tint cave_count;\n\tint last_pri_cave;\n\t_Cave() {}\n\t_Cave(int y, int x, int c, int l) :y(y), x(x), cave_count(c), last_pri_cave(l) {}\n};\n\nint dcx[3] = { -1,0,1 };\nint dcy[3] = { -1,-1,-1 };\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tinit_prime();\n\n\t/* prime_check */\n\t/*\n\tfor (int i = 0;i < 50;i++) {\n\t\tif (prime[i]) {\n\t\t\tcout << i << endl;\n\t\t}\n\t}\n\t*/\n\n\tint m, n;\n\twhile (cin >> m >> n, m | n) {\n\t\tauto s = init_Caves(m, n);\n\t\t/* Cave_check */\n\t\t/*\n\t\tfor (int i = 510; i > 490;i--) {\n\t\t\tfor (int j = 490; j < 510; j++) {\n\t\t\t\tif (s.first == i && s.second == j) {\n\t\t\t\t\tcout << setw(4) << \"X\" << \" \";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << setw(4) << Caves[i][j] << \" \";\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tmemset(state, -1, sizeof(state));\n\t\tqueue<_Cave> q;\n\t\tif (Prime[n]) {\n\t\t\tstate[s.first][s.second] = { 1,n };\n\t\t\tq.push(_Cave(s.first, s.second, 1, n));\n\t\t}\n\t\telse {\n\t\t\tstate[s.first][s.second] = { 0,0 };\n\t\t\tq.push(_Cave(s.first, s.second, 0, 0));\n\t\t}\n\t\tpll ans = { 0,0 };\n\t\twhile (!q.empty()) {\n\t\t\tauto C = q.front(); q.pop();\n\n\t\t\tbool f = false;\n\t\t\tfor (int i = 0; i < 3;i++) {\n\t\t\t\tint ny = C.y + dcy[i], nx = C.x + dcx[i];\n\t\t\t\tif (Caves[ny][nx] == 0)continue;\n\t\t\t\tf = true;\n\t\t\t\tint next_cave_count = C.cave_count + (Prime[Caves[ny][nx]] == true);\n\t\t\t\tint next_last_pri = Prime[Caves[ny][nx]] ? Caves[ny][nx] : C.last_pri_cave;\n\t\t\t\tif (next_cave_count > state[ny][nx].first) {\n\t\t\t\t\tstate[ny][nx].first = next_cave_count;\n\t\t\t\t\tstate[ny][nx].second = next_last_pri;\n\t\t\t\t\tq.push(_Cave(ny, nx, next_cave_count, next_last_pri));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (next_cave_count == state[ny][nx].first && next_last_pri > state[ny][nx].second) {\n\t\t\t\t\tstate[ny][nx].second = next_last_pri;\n\t\t\t\t\tq.push(_Cave(ny, nx, next_cave_count, next_last_pri));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f) {\n\t\t\t\tif (C.cave_count > ans.first) {\n\t\t\t\t\tans.first = C.cave_count;\n\t\t\t\t\tans.second = C.last_pri_cave;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (C.cave_count == ans.first && C.last_pri_cave > ans.second) {\n\t\t\t\t\tans.second = C.last_pri_cave;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <string>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint dx[4] = { 1, 0, -1, 0 }, dy[4] = { 0, -1, 0, 1 };\n\nint s[1000001];\nint d[3000][3000];\nint b[3000][3000];\nbool f[3000][3000];\n\nint main(){\n\n\tint n, m;\n\tfor (long long i = 2; i < 1000001; i++){\n\n\t\tif (!s[i]){\n\t\t\tfor (long long j = i * 2; j < 1000001; j += i){\n\t\t\t\ts[j] = 1;\n\t\t\t}\n\t\t}\n\n\t}\n\n\twhile (cin >> n >> m && n){\n\n\t\tmemset(d, 0, sizeof(d));\n\t\tmemset(b, 0, sizeof(b));\n\t\tmemset(f, 0, sizeof(f));\n\t\tqueue<P> q;\n\t\tq.push(P(1500, 1500));\n\t\tint dir = 0;\n\t\tint dist = 1;\n\t\tint c = -1;\n\t\tint num = 1;\n\t\tint sy, sx;\n\t\tn++;\n\n\t\twhile (q.size()){\n\t\t\tint y = q.front().first, x = q.front().second;\n\t\t\tq.pop();\n\n\t\t\tif (num == m)sx = x, sy = y;\n\t\t\td[y][x] = num++;\n\t\t\tif (num == n)goto end;\n\n\t\t\tif (c == 1){\n\t\t\t\tc = 0; dist++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tint ty = y, tx = x;\n\t\t\tfor (int i = 1;i < dist;i++){\n\t\t\t\tty += dy[dir]; tx += dx[dir];\n\t\t\t\tif (num == m)sx = tx, sy = ty;\n\t\t\t\td[ty][tx] = num++;\n\t\t\t\tif (num == n)goto end;\n\t\t\t}\n\n\t\t\tq.push(P(y + dy[dir] * dist, x + dx[dir] * dist));\n\t\t\tdir = (dir + 1) % 4;\n\n\t\t}\n\n\tend:;\n\n\t\tq.push(P(sy, sx));\n\t\tb[sy][sx] = (s[d[sy][sx]] ? 0 : 1);\n\t\tP ans(0,0);\n\t\tf[sy][sx] = 1;\n\t\tif (!s[d[sy][sx]]){\n\t\t\tans.first = 1;\n\t\t\tans.second = d[sy][sx];\n\t\t}\n\n\t\twhile (q.size()){\n\t\t\tint y = q.front().first, x = q.front().second;\n\t\t\tq.pop();\n\n\t\t\tint ty = y + 1, tx = x;\n\n\t\t\tfor (tx = x - 1; tx <= x + 1; tx++){\n\t\t\t\tif (d[ty][tx] == 0)continue;\n\n\t\t\t\tif (!f[ty][tx] || b[ty][tx] < b[y][x] + (s[d[ty][tx]] ? 0 : 1)){\n\t\t\t\t\tf[ty][tx] = 1;\n\t\t\t\t\tq.push(P(ty, tx));\n\t\t\t\t}\n\t\t\t\tif (b[ty][tx] < b[y][x] + (s[d[ty][tx]] ? 0 : 1)){\n\t\t\t\t\tb[ty][tx] = b[y][x] + (s[d[ty][tx]] ? 0 : 1);\n\t\t\t\t\tif (!s[d[ty][tx]] && (ans.first < b[ty][tx] || (ans.first == b[ty][tx] && ans.second < d[ty][tx]))){\n\t\t\t\t\t\tans.first = b[ty][tx];\n\t\t\t\t\t\tans.second = d[ty][tx];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\nint calc(int i, int m, int n, vector< vector<int> >& a, vector<int>& X, vector<int>& Y, vector<bool>& p, vector<int>& memo) {\n\tif (i > m) return INT_MIN;\n\tif (i == n) return p[n];\n\tif (memo[i] < INT_MAX) return memo[i];\n\tint x = X[i], y = Y[i];\n\tint j, maxi = INT_MIN;\n\tj = a[y - 1][x - 1]; maxi = max(maxi, calc(j, m, n, a, X, Y, p, memo));\n\tj = a[y - 1][x]; maxi = max(maxi, calc(j, m, n, a, X, Y, p, memo));\n\tj = a[y - 1][x + 1]; maxi = max(maxi, calc(j, m, n, a, X, Y, p, memo));\n\treturn memo[i] = maxi + p[i];\n}\n\nint main() {\n\tvector<bool> p(1000001, true);\n\tp[1] = false;\n\tfor (int i = 2; i <= 1000000; i++)\n\t\tif (p[i])\n\t\t\tfor (int j = i * 2; j <= 1000000; j += i)\n\t\t\t\tp[j] = false;\n\tvector< vector<int> > a(2000, vector<int>(2000, INT_MAX));\n\tvector<int> X(1000001), Y(1000001);\n\tint x = 1000, y = 1000, dir = 2;\n\tfor (int i = 1; i <= 1000000; i++) {\n\t\ta[y][x] = i;\n\t\tX[i] = x; Y[i] = y;\n\t\tx += dx[dir]; y += dy[dir];\n\t\tdir = (dir + 3) % 4;\n\t\tint _x = x + dx[dir], _y = y + dy[dir];\n\t\tif (a[_y][_x] < INT_MAX) dir = (dir + 1) % 4;\n\t}\n\tfor (;;) {\n\t\tint m, n; cin >> m >> n;\n\t\tif (m == 0) break;\n\t\tint maxi = 0, j = 0;\n\t\tvector<int> memo(m + 1, INT_MAX);\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tif (!p[i]) continue;\n\t\t\tint z = calc(i, m, n, a, X, Y, p, memo);\n\t\t\tif (z > 0 && z >= maxi) {\n\t\t\t\tmaxi = z;\n\t\t\t\tj = i;\n\t\t\t}\n\t\t}\n\t\tcout << maxi << ' ' << j << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nstruct P\n{\n\tint x,y;\n};\n\nP findpoint(int m,vector<vector<int> > &map){\n\tfor(int x=0;x<map.size();x++)\n\tfor(int y=0;y<map.size();y++)\n\t\tif(map[x][y]==m)\n\t\t\treturn (P){x,y};\n\treturn (P){-1,-1};\n}\n\nP solve(int n,int m,vector<vector<int> > &map,vector<bool> &prime){\n\tP p=findpoint(m, map);\n\tP res={0,0};\n\tvector<vector<int> >dp(map.size(),vector<int>(map.size(),-1));\n\tdp[p.x][p.y]=0;\n\tfor(int y=p.y;y<map.size();y++){\n\t\tfor(int x=0;x<map.size();x++){\n\t\t\tif(map[x][y]>n)continue;\n\t\t\tif(dp[x][y]>=0){\n\t\t\t\tif(prime[map[x][y]-1]){\n\t\t\t\t\tdp[x][y]++;\n\t\t\t\t\tif(res.x<=dp[x][y]){\n\t\t\t\t\t\tres.x=dp[x][y];\n\t\t\t\t\t\tres.y=map[x][y];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(y==map.size()-1)continue;\n\t\t\t\tfor(int i=-1;i<=1;i++){\n\t\t\t\t\tif(0<=x+i&&x+i<map.size()){\n\t\t\t\t\t\tdp[x+i][y+1]=max(dp[x+i][y+1],dp[x][y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n,m,ma=-1;\n\tvector<int>N,M;\n\n\twhile(cin >> n >> m, n|m){\n\t\tN.push_back(n);\n\t\tM.push_back(m);\n\t\tma=max(ma, n);\n\t}\n\n\tvector<bool>prime(ma+1,true);\n\tprime[0] = false;\n\tfor(int i=2;i<=ma;i++){\n\t\tif(!prime[i-1])continue;\n\t\tfor(int j=i*2;j<=ma;j+=i)\n\t\t\tprime[j-1]=false;\n\t}\n\tint kk=(int)sqrt(ma-1)/2*2;;\n\tint x=0,y=1;\n\tn = m = kk*kk+1;\n\tvector<vector<int> >map(kk+2, vector<int>(kk+2));\n\tmap[x][y]=m++;\n\tint k=kk;\n\twhile(m<=ma){\n\t\tfor(int i=0;i<k;i++)\n\t\t\tmap[x][++y]=m++;\n\t\tk++;\n\t\tfor(int i=0;i<k;i++)\n\t\t\tmap[++x][y]=m++;\n\t\tfor(int i=0;i<k;i++)\n\t\t\tmap[x][--y]=m++;\n\t\tfor(int i=0;i<k;i++)\n\t\t\tmap[--x][y]=m++;\n\t}\n\tx=0;\n\ty=1;\n\tm=n-1;\n\tk=kk;\n\twhile(m>0){\n\t\tfor(int i=0;i<k&&m>0;i++)\n\t\t\tmap[++x][y]=m--;\n\t\tk--;\n\t\tfor(int i=0;i<k&&m>0;i++)\n\t\t\tmap[x][++y]=m--;\n\t\tfor(int i=0;i<k&&m>0;i++)\n\t\t\tmap[--x][y]=m--;\n\t\tk--;\n\t\tfor(int i=0;i<k&&m>0;i++)\n\t\t\tmap[x][--y]=m--;\n\t}\n\n/*\n\tfor(int j=0;j<kk+2;j++){\n\tfor(int i=0;i<kk+2;i++)\n\t\tprintf(\"%2d \",map[i][j]);\n\t\tcout << endl;\n\t}\n\t*/\n\n\tfor(int i=0;i<N.size();i++){\n\t\tP res=solve(N[i],M[i],map,prime);\n\t\tcout <<  res.x << \" \" << res.y << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n#define t_max 10000001\nchar M[1001][1001];\nchar S[1001][1001];\nchar P[1001][1001];\nchar table[t_max];\nvector<pair<short,short> >m(t_max);\nmap<pair<short,short>,int>m_rev;\npair<short,int> dfs(int x,int y){\n\tif(y==1001)return make_pair(0,0);\n\tif(S[x][y]>=0)return make_pair(S[x][y],P[x][y]);\n\tint m=0,m_place=0,i=-1;\n\tfor(;i<2;i++){\n\t\tif(x+i<0||1000<x+i)continue;\n\t\tpair<short,int> p=dfs(x+i,y+1);\n\t\tif(m<p.first||(m==p.first&&m_place<p.second))m=p.first,m_place=p.second;\n\t}\n\tif(m==0){\n\t\tif(M[x][y])return make_pair(S[x][y]=1,P[x][y]=m_rev[make_pair(x,y)]);\n\t\treturn make_pair(S[x][y]=0,P[x][y]=0);\n\t}else{\n\t\treturn make_pair(S[x][y]=m+M[x][y],P[x][y]=m_place);\n\t}\n}\nmain(){\n\tint k=1,z,x,y,i,n,s;\n\tm[k]=make_pair(x=500,y=500),m_rev[make_pair(x,y)]=k,k++;\n\tfor(z=2;z<=1000;z+=2){\n\t\tx++,y++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(x,--y),m_rev[make_pair(x,y)]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(--x,y),m_rev[make_pair(x,y)]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(x,++y),m_rev[make_pair(x,y)]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(++x,y),m_rev[make_pair(x,y)]=k,k++;\n\t}\n\ttable[0]=table[1]=1;\n\tfor(x=2;x<t_max;x++)if(!table[x])for(y=x*2;y<t_max;y+=x)table[y]=1;\n\tfor(;scanf(\"%d%d\",&n,&s),n;){\n\t\tmemset(M,0,sizeof(M));\n\t\tmemset(S,0xff,sizeof(S));\n\t\tmemset(P,0,sizeof(P));\n\t\tfor(i=1;i<=n;i++)if(!table[i])M[m[i].first][m[i].second]=1;\n\t\tpair<short,int> p=dfs(m[s].first,m[s].second);\n\t\tprintf(\"%d %d\\n\",p.first,p.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nbool is_prime[1000001];\nint num[1000][1000];\nint x[1000001];\nint y[1000001];\nint dp[1000][1000];\nint dx[] = { 1,0,-1,0 };\nint dy[] = { 0,-1,0,1 };\nint main() {\n\tfor (int i = 2; i <= 1000000; i++) is_prime[i] = 1;\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tif (!is_prime[i]) continue;\n\t\tfor (int j = 2 * i; j <= 1000000; j += i) is_prime[j] = 0;\n\t}\n\tint len = 1;\n\tint cnt = 0;\n\tint dir = 0;\n\tmemset(num, -1, sizeof(num));\n\tnum[500][500] = 1;\n\tx[1] = 500;\n\ty[1] = 500;\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tx[i] = x[i - 1] + dx[dir];\n\t\ty[i] = y[i - 1] + dy[dir];\n\t\tnum[y[i]][x[i]] = i;\n\t\tcnt++;\n\t\tif (cnt == len) {\n\t\t\tcnt = 0;\n\t\t\tif (dir % 2) len++;\n\t\t\t(dir += 1) %= 4;\n\t\t}\n\t}\n\tint m, n;\n\twhile (cin >> m >> n, m) {\n\t\tint sx = x[n];\n\t\tint sy = y[n];\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tdp[sy][sx] = 0;\n\t\tif (is_prime[num[sy][sx]]) dp[sy][sx]++;\n\t\tfor (int i = sy; i + 1 < 1000; i++) {\n\t\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\t\tif (num[i][j] == -1 || num[i][j] > m || dp[i][j] == -1) continue;\n\t\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\t\tint nx = j + k;\n\t\t\t\t\tif (0 > nx || nx >= 1000 || num[i + 1][nx] == -1 || num[i + 1][nx] > m) continue;\n\t\t\t\t\tdp[i + 1][nx] = max(dp[i + 1][nx], dp[i][j] + is_prime[num[i + 1][nx]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = -1;\n\t\tint t = -1;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tif (!is_prime[i]) continue;\n\t\t\tif (ans <= dp[y[i]][x[i]]) {\n\t\t\t\tans = dp[y[i]][x[i]];\n\t\t\t\tt = i;\n\t\t\t}\n\t\t}\n\t\tif (ans == -1) cout << \"0 0\" << endl;\n\t\telse cout << ans << \" \" << t << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define pb(a) push_back(a)\n#define mp(a,b) make_pair(a,b)\n#define ALL(a) (a).begin(),(a).end()\n#define SZ(a) ((int)(a).size())\n#define F first\n#define S second\ntypedef pair<int,int> PI;\n\nint m,n;\n\nPI app[5100000];\nint nu[2000][2000];\n\nbool ispr(int n){\n  if(n<2) return false;\n  for(int i=2;i*i<= n;++i)\n    if(n%i==0) return false;\n  return true;\n}\n\nbool isp[5000000];\n\nPI vis[2000][2000];\n\nvoid solve(){\n  queue<PI> q;\n  q.push(app[n]);//nu,-tu\n  memset(vis,0,sizeof(vis));\n  int a=0,b=0;\n\n  if(isp[n])\n    vis[app[n].F][app[n].S]=mp(1,n);\n  \n  while(!q.empty()){\n    int cx = q.front().F;\n    int cy = q.front().S;\n    q.pop();\n    if(nu[cx][cy]>m) continue;\n    if(vis[cx][cy]!=mp(0,0) && !q.empty()) continue;\n    \n    if(nu[cx-1][cy-1]<=m){\n      vis[cx][cy]=max(vis[cx][cy],\n                      mp(vis[cx-1][cy-1].F+isp[nu[cx][cy]],\n                         isp[nu[cx][cy]]?nu[cx][cy]:vis[cx-1][cy-1].S));\n    }\n    \n    if(nu[cx-1][cy]<=m){\n      vis[cx][cy]=max(vis[cx][cy],\n                      mp(vis[cx-1][cy].F+isp[nu[cx][cy]],\n                         isp[nu[cx][cy]]?nu[cx][cy]:vis[cx-1][cy].S));\n    }\n    \n    if(nu[cx-1][cy+1]<=m){\n      vis[cx][cy]=max(vis[cx][cy],\n                      mp(vis[cx-1][cy+1].F+isp[nu[cx][cy]],\n                         isp[nu[cx][cy]]?nu[cx][cy]:vis[cx-1][cy+1].S));\n    }    \n    \n    \n    //cout << cx << \" \" << cy << \" \" << num << \" \" << last << endl;    \n    //vis[cx][cy] = mp(num,last);\n    if(mp(a,b) < vis[cx][cy]){\n      a=vis[cx][cy].F;\n      b=vis[cx][cy].S;\n    }\n    \n    q.push(mp(cx+1,cy+1));\n    q.push(mp(cx+1,cy));\n    q.push(mp(cx+1,cy-1));\n    \n  }\n\n  \n  cout << a << \" \" << b << endl;\n}\n\nint dx[]={0,-1,0,1,0};\nint dy[]={1,0,-1,0,1};\n\nint main(){\n  // rep(i,100) cout << i << ispr(i) << endl;\n  // return 0;\n  int cx=1000,cy=1000;\n  int dir = 0;\n  rep(i,2100000){\n    nu[cx][cy]=i+1;\n    isp[i+1]=ispr(i+1);\n    //cout << cx << \" \" << cy << endl;\n    app[i+1]=mp(cx,cy);\n    cx += dx[dir];\n    cy += dy[dir];\n    if(!nu[cx+dx[dir+1]][cy+dy[dir+1]])\n      dir=(dir+1)%4;\n  }\n  \n  rep(i,10){\n    rep(j,10){\n      //printf(\"%5d %d\",nu[1000+i-5][1000+j-5],isp[nu[1000+i-5][1000+j-5]]);\n      //cout << nu[1000+i-5][1000+j-5] << \" \";\n    }\n    //cout << endl;\n  }\n  \n  //return 0;\n  \n  while(cin >> m >> n && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <string>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <cstdio>\n#include <cassert>\n#include <cinttypes>\n\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef int64_t i64;\ntypedef uint64_t u64;\n\nconst i64 INF = 1e18 + 10;\n\ntypedef pair<int, int> P;\ninline P operator+(const P& p1, const P& p2) {\n  return P(p1.first + p2.first, p1.second + p2.second);\n}\n\nint cave[1101][1101];\n\nvoid MakeCave(int n) {\n  memset(cave, 0, sizeof(cave));\n\n  int y = 501;\n  int x = 501;\n\n  int dy[4] = { 1, 0, -1, 0 };\n  int dx[4] = { 0, 1, 0, -1 };\n\n  int dir = 0;\n  for (int i = 1; i <= n; i++) {\n    cave[y][x] = i;\n\n    int ny = y + dy[(dir + 1) % 4];\n    int nx = x + dx[(dir + 1) % 4];\n    if (ny < 0 || ny >= 1100 || nx < 0 || nx >= 1100 || cave[ny][nx] == 0) {\n      y = ny;\n      x = nx;\n      dir = (dir + 1) % 4;\n    } else {\n      y = y + dy[dir];\n      x = x + dx[dir];\n    }\n  }\n}\n\nbool IsPrime(int num) {\n  static bool is_prime[1000001];\n\n  static bool init = false;\n\n  if (!init) {\n    fill(is_prime, is_prime + 1000001, true);\n    init = true;\n    is_prime[0] = false;\n    is_prime[1] = false;\n    for (int i = 2; i * i < 1000001; i++) {\n      if (is_prime[i]) {\n        for (int j = 2; i * j < 1000001; j++) {\n          is_prime[i * j] = false;\n        }\n      }\n    }\n  }\n\n  return is_prime[num];\n}\n\nP Solve(int n, int m) {\n  int start_y = -1;\n  int start_x = -1;\n\n  for (int i = 0; start_x == -1 && i < 1101; i++) {\n    for (int j = 0; start_x == -1 && j < 1101; j++) {\n      if (cave[i][j] == m) {\n        start_y = i;\n        start_x = j;\n      }\n    }\n  }\n\n  struct Search {\n    int y, x;\n    int prime;\n    int count;\n    Search(): y(-1), x(-1), prime(0), count(0) { }\n    Search(int y, int x, int prime, int count):\n      y(y), x(x), prime(prime), count(count) { }\n  };\n\n  int dy[3] = {  1, 1, 1 };\n  int dx[3] = { -1, 0, 1 };\n\n  static bool checked[1101][1101];\n  static Search memo[1101][1101];\n  memset(checked, false, sizeof(checked));\n\n  function<Search(int, int)> dfs = [&](int y, int x) {\n    if (checked[y][x]) {\n      return memo[y][x];\n    }\n\n    if (cave[y][x] == 0) {\n      return Search(y, x, 0, 0);\n    }\n\n    Search s(y, x, 0, 0);\n    if (IsPrime(cave[y][x])) {\n      s.count++;\n      s.prime = cave[y][x];\n    }\n\n    int count = 0;\n    int prime = s.prime;\n    for (int i = 0; i < 3; i++) {\n      int ny = y + dy[i];\n      int nx = x + dx[i];\n\n      Search t = dfs(ny, nx);\n      if (t.count > count) {\n        count = t.count;\n        prime = t.prime;\n      } else if (t.count == count) {\n        if (prime < t.prime) {\n          prime = t.prime;\n        }\n      }\n    }\n\n    s.count += count;\n    s.prime = prime;\n\n    checked[y][x] = true;\n    memo[y][x] = s;\n\n    return s;\n  };\n\n  Search ans = dfs(start_y, start_x);\n\n  return P(ans.count, ans.prime);\n}\n\nint main() {\n  while (true) {\n    int n, m;\n    cin >> n >> m;\n    if (n + m == 0) {\n      break;\n    }\n    MakeCave(n);\n    P ans = Solve(n, m);\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define SIZE 1000\n\nbool C(int dp1, int pr1, int dp2, int pr2) {\n\tif (dp2 == 0)return false;\n\tif (dp1 < dp2 || (dp1 == dp2&&pr1 < pr2))return true;\n\treturn false;\n}\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool complete;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i <= SIZE&&a <= SIZE*SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i+1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x--;\n\t\t\telse x++;\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\tcomplete = false;\n\t\twhile (!complete) {\n\t\t\twhile (x >= 0 && !complete) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x - 1], pr[y + 1][x - 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x], pr[y + 1][x])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x + 1], pr[y + 1][x + 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (table[y][x] == n)complete = true;\n\t\t\t\telse x--;\n\t\t\t}\n\t\t\tif (!complete) {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing Ti = tuple<int, int, int>;\nusing Tl = tuple<ll, ll, ll>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define Get(t, i) get<(i)>((t))\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\nconst int inf = 1 << 25;\nconst ll INF = 1LL << 55;\n\n#define MAX_M 1000001\n#define MAX_W 1001\n\nbool isprim[MAX_M];\n\nvoid Eratosthenes()\n{\n  fill(isprim, isprim + MAX_M, true);\n  isprim[0] = isprim[1] = false;\n  for(int i = 2; i*i < MAX_M; i++) {\n    if(isprim[i]) {\n      for(int j = i+i; j < MAX_M; j += i) isprim[j] = false;\n    }\n  }\n}\n\nint cave[MAX_W][MAX_W];\nPi pos[MAX_M];\n\nvoid make_cave()\n{\n  const int dx[] = {1, 0, -1, 0};\n  const int dy[] = {0, -1, 0, 1};  \n  typedef pair<Pi, Pi> Pii;\n  queue<Pii> que;\n  que.push(Pii(Pi(MAX_W/2, MAX_W/2), Pi(3, 1)));\n  while(!que.empty()) {\n    Pii p = que.front(); que.pop();\n    int x = p.F.F, y = p.F.S, d = p.S.F, n = p.S.S;\n    if(n >= MAX_M) break;\n    pos[n] = p.F, cave[y][x] = n++;\n    int nd = (d + 1) % 4, nx = x + dx[nd], ny = y + dy[nd];\n    if(!cave[ny][nx]) que.push(Pii(Pi(nx, ny), Pi(nd, n)));\n    else que.push(Pii(Pi(x + dx[d], y + dy[d]), Pi(d, n)));\n  }\n}\n\nint main()\n{\n  Eratosthenes();\n  make_cave();\n  int m, n;\n  while(cin >> m >> n, m) {\n    int dp[MAX_W][MAX_W];\n    fill(dp[0], dp[MAX_W], -1);\n    dp[pos[n].F][pos[n].S] = isprim[n];\n    int ans = 0, num = 0;\n    for(int y = 0; y < MAX_W; y++) {    \n      for(int x = 0; x < MAX_W; x++) {\n\tif(ans <= dp[x][y]) {\n\t  ans = dp[x][y];\n\t  if(isprim[cave[y][x]]) num = cave[y][x];\n\t}\n\tif(y == MAX_W-1 || !cave[y][x] || m < cave[y][x] || !~dp[x][y]) continue;\n\tfor(int a = -1; a <= 1; a++) {\n\t  int nx = x + a, ny = y + 1;\n\t  if(nx < 0 || MAX_W <= nx || !cave[ny][nx] || m < cave[ny][nx]) continue;\n\t  dp[nx][ny] = max(dp[nx][ny], dp[x][y] + isprim[cave[ny][nx]]);\n\t  if(ans <= dp[nx][ny]) {\n\t    ans = dp[nx][ny];\n\t    if(isprim[cave[ny][nx]]) num = cave[ny][nx];\n\t  }\t  \n\t}\n      }\n    }\n    cout << ans << \" \" << num << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\t\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&\n\t\t\t\t\t\t(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]==dp[y + 1][x - 1]&&pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && \n\t\t\t\t\t\t(dp[y][x]<dp[y + 1][x] || (dp[y][x] == dp[y + 1][x] && pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && \n\t\t\t\t\t\t(dp[y][x]<dp[y + 1][x + 1] || (dp[y][x] == dp[y + 1][x + 1] && pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t\n\t\tfor (int h = 0;h < SIZE;h++) {\n\t\t\tfor (int w = 0;w < SIZE;w++) {\n\t\t\t\tif (table[h][w] == n) {\n\t\t\t\t\tcout << dp[h][w] << \" \";\n\t\t\t\t\t//cout << pr[h][w] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n \nint dx[] = {1,0,-1,0};\nint dy[] = {0,-1,0,1};\n \nconst int MAX = 1000001;\nbool pri[MAX];\nvector<int>v;\nmap<int,pair<int,int> >pos;\nint field[1201][1201];\nint N,M;\n \nvoid make(){\n  int cnt = 2;\n  int c = 1;\n  int x = 500,y=500;\n  int cc = 0;\n  field[500][500] = 1;\n  pos[1] = make_pair(500,500);\n \n  while(cnt < 1000000){\n    for(int i=0; i<4; i++){\n      if(cc == 2){cc = 0; c++;}\n      int nx = x, ny = y;\n      for(int j=0; j<c; j++){\n    nx += dx[i];\n    ny += dy[i];\n    pos[cnt] = make_pair(ny,nx);\n    field[ny][nx] = cnt++;\n      }\n \n      x = nx, y = ny;\n      cc++;\n    }\n  }\n}\n \nvoid createPrime(){\n  fill(pri,pri+MAX,1);\n  pri[0] = pri[1] = 0;\n  for(int i=2; i*i<MAX; i++){\n    for(int j=2*i; j<MAX; j+=i){\n      pri[j] = false;\n    }\n  }\n \n  for(int i=2; i<MAX; i++) if(pri[i]) v.push_back(i);\n}\n \nbool compare(pair<int,int>p, pair<int,int>p2){\n  if(p.first == p2.first){\n    return p.second > p2.second;\n  }\n  return p.first > p2.first;\n}\n \nint main(){\n  make();\n  createPrime();\n \n  while(cin >> M >> N,M|N){\n    pair<int,int> p = pos[N];\n    int sx = p.second, sy = p.first;\n    bool F = false;\n \n    static bool used[1200][1200];\n    static pair<int,int> dp[1200][1200];\n    memset(used,0,sizeof(used));\n    memset(dp,0,sizeof(dp));\n \n    if(binary_search(v.begin(),v.end(),field[sy][sx])){\n      dp[sy][sx].first = 1;\n      dp[sy][sx].second = field[sy][sx];\n    }\n    used[sy][sx] = true;\n \n    for(int i=sy; i<=1000; i++){\n      for(int j=0; j<=1000; j++){\n    for(int k=-1; k<=1; k++){\n      if(!used[i][j])continue;\n      int nx = j + k;\n      if(nx < 0 || nx > 1000)continue;\n      if(field[i+1][nx] > M)continue;\n \n      used[i+1][nx] = true;\n      int value = binary_search(v.begin(),v.end(),field[i+1][nx]);\n       \n      if(value){\n        if(dp[i+1][nx].first < dp[i][j].first + 1){\n          dp[i+1][nx].first = dp[i][j].first + 1;\n          dp[i+1][nx].second = field[i+1][nx];\n        }\n      } else {\n        dp[i+1][nx] = max(dp[i+1][nx],dp[i][j]);\n      }\n    }\n      }\n    }\n \n    vector<pair<int,int> >ans;\n \n    for(int i=0; i<=1000; i++){\n      for(int j=0; j<=1000; j++){\n    if(field[i][j] > M)continue;\n    if(dp[i][j].first == 0)continue;\n    ans.push_back(dp[i][j]);\n      }\n    }\n \n \n    if(ans.size() == 0){cout << \"0 0\" << endl;}\n    else{\n      sort(ans.begin(),ans.end(),compare);\n      cout << ans[0].first << \" \" << ans[0].second << endl;\n    }\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define MAX_H 1003\n#define MAX_W 1003\n#define MAX_N (int)1e6\n\nusing namespace std;\n\nint cave[MAX_H][MAX_W];\nbool isPrime[MAX_N];\n\nvoid cave_setting() {\n    fill_n((int *)cave, MAX_H * MAX_W, -1);\n    int y = MAX_H/2+1, x = MAX_W/2+1;\n    int dy = 1, dx = 1, count = 1;\n    cave[y][x] = 1;\n    for (int i = 2; i < MAX_N;) {\n        // right\n        while (dx <= count) {\n            cave[y][x+dx] = i;\n            i++; dx++;\n        }\n        x+=dx-1; dx = 1;\n        // up\n        while (dy <= count) {\n            cave[y-dy][x] = i;\n            i++; dy++;\n        }\n        y-=dy-1; dy = 1;\n        count++;\n        // left\n        while (dx <= count) {\n            cave[y][x-dx] = i;\n            i++; dx++;\n        }\n        x-=dx-1; dx = 1;\n        // under\n        while (dy <= count) {\n            cave[y+dy][x] = i;\n            i++; dy++;\n        }\n        y+=dy-1; dy = 1;\n        count++;\n    }\n}\n\nint main() {\n    // isPrime table setting\n    fill_n((bool *)isPrime, MAX_N, true); isPrime[0] = false; isPrime[1] = false;\n    for (int i = 2; i < MAX_N; i++) {\n        for (int j = i + i; j < MAX_N; j = j + i) {\n            isPrime[j] = false;\n        }\n    }\n\n    cave_setting();\n\n    // input\n    int m, n;\n    while (cin >> m >> n, m|n) {\n        int sx, sy;\n        // search first node\n        for (int j = 0; j < MAX_H; j++) {\n            for (int i = 0; i < MAX_W; i++) {\n                if (cave[j][i] == n) {\n                    sx = i; sy = j;\n                }\n            }\n        }\n        // search\n        int now[MAX_W];\n        int search[MAX_W];\n        int lastPrime[MAX_H][MAX_W];\n        fill_n((int *)now, MAX_W, -1);\n        fill_n((int *)search, MAX_W, -1);\n        fill_n((int *)lastPrime, MAX_H * MAX_W, 0);\n        now[sx] = isPrime[cave[sy][sx]];\n        int last = 0;\n        int max = 0;\n        if (now[sx]) last = lastPrime[sy][sx] = cave[sy][sx];\n\n        for (int j = sy; j < MAX_H-1; j++) {\n            for (int i = 0; i < MAX_W; i++) {\n                if (now[i] >= 0 && cave[j][i] <= m) {\n                    for (int d = -1; d <= 1; d++) {\n                        if (i + d >= 0 && i + d < MAX_W && cave[j+1][i+d] <= m && now[i]+isPrime[cave[j+1][i+d]] > search[i+d]) {\n                            search[i+d] = now[i] + isPrime[cave[j+1][i+d]];\n                            if (isPrime[cave[j+1][i+d]]) lastPrime[j+1][i+d] = cave[j+1][i+d];\n                            else lastPrime[j+1][i+d] = lastPrime[j][i];\n                        }\n                    }\n                }\n            }\n            for (int i = 0; i < MAX_W; i++) {\n                if (search[i] != -1) now[i] = search[i];\n                if (now[i] > max) {\n                    max = now[i];\n                    if (lastPrime[j+1][i] > 0) last = lastPrime[j+1][i];\n                } else if (now[i] == max && lastPrime[j+1][i] > last) {\n                    last = lastPrime[j+1][i];\n                }\n            }\n        }\n        cout << max << \" \" << last << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[(SIZE + 1)*(SIZE + 1) + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= (SIZE + 1)*(SIZE + 1);i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= (SIZE + 1)*(SIZE + 1);j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 || n == 0)return 0;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(y=SIZE-1;y>=0;y--){\n\t\t\tfor(x=SIZE-1;x>=0;x--){\n\t\t\t\tif (table[y][x] <= m) {\n\t\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m &&\n\t\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x - 1] || (dp[y][x] == dp[y + 1][x - 1] && pr[y][x] < pr[y + 1][x - 1]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (table[y + 1][x] <= m &&\n\t\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x] || (dp[y][x] == dp[y + 1][x] && pr[y][x] < pr[y + 1][x]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m &&\n\t\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x + 1] || (dp[y][x] == dp[y + 1][x + 1] && pr[y][x] < pr[y + 1][x + 1]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (y = 0;y < SIZE;y++) {\n\t\t\tfor (x = 0;x < SIZE;x++) {\n\t\t\t\tif (table[y][x] == n) {\n\t\t\t\t\tcout << x << \" \" << pr[y][x] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n \n#define rep(i, n) for(int i = 0; i < (n); ++i)\n \nusing namespace std;\n\nconst int inf = 1e7;\n\nvoid to_coord(int x, int& p, int& q){\n    int l = 0;\n    int r = 500;\n    while(r - l > 1){\n        int m = (l + r) / 2;\n        if(x <= 4 * m * m){\n            r = m;\n        }\n        else{\n            l = m;\n        }\n    }\n    int a = 4 * r * r;\n    int b = a - 2 * r + 1;\n    int c = b - 2 * r + 1;\n    int d = c - 2 * r + 1;\n    if(x >= b){\n        p = 500 - r;\n        q = 500 - r + a - x;\n    }\n    else if(x >= c){\n        p = 500 - r + b - x;\n        q = 500 + r - 1;\n    }\n    else if(x >= d){\n        p = 500 + r - 1;\n        q = 500 - r + (x - d);\n    }\n    else{\n        p = 500 + r - 1 - (d - x);\n        q = 500 - r;\n    }\n}\n\nint from_coord(int p, int q){\n    int cp = p < 500 ? p - 500 : p - 499;\n    int cq = q < 500 ? q - 500 : q - 499;\n    int r = max(abs(cp), abs(cq));\n    int a = 4 * r * r;\n    int b = a - 2 * r + 1;\n    int c = b - 2 * r + 1;\n    int d = c - 2 * r + 1;\n    int s = 500 - r;\n    int t = 500 + r - 1;\n    if(cp == -r){\n        return a + s - q;\n    }\n    else if(cp == r){\n        return d + q - s;\n    }\n    else if(cq == -r){\n        return d + p - t;    \n    }\n    else{\n        return b + s - p;\n    }\n}\n\nbool prime[1000001];\n\nvoid enum_prime(){\n    fill_n(prime, 1000001, true);\n    prime[0] = prime[1] = false;\n    rep(i, 1000001){\n        if(prime[i]){\n            for(int j = 2 * i; j <= 1000000; j += i){\n                prime[j] = false;\n            }\n        }\n    }\n}\n\nint m, n;\nbool z[1000][1000];\nint dp[1000][1000];\n\nint main(){\n    enum_prime();\n\n    while(1){\n        cin >> m >> n;\n\n        if(m == 0){\n            break;\n        }\n\n        rep(i, 1000){\n            fill_n(z[i], 1000, 0);\n            fill_n(dp[i], 1000, -inf);\n        }\n\n        rep(i, m + 1){\n            if(prime[i]){\n                int p, q;\n                to_coord(i, p, q);\n                z[p][q] = true;\n            }\n        }\n\n        int s, t;\n        to_coord(n, s, t);\n        dp[s][t] = z[s][t];\n        for(int i = s + 1; i < 1000; ++i){\n            rep(j, 1000){\n                int a = j > 0 ? dp[i - 1][j - 1] : -inf;\n                int c = j + 1 < 1000 ? dp[i - 1][j + 1] : -inf;\n                dp[i][j] = max(dp[i - 1][j], max(a, c)) + z[i][j];\n            }\n        }\n\n        int ans = *max_element(dp[999], dp[999] + 1000);\n        cout << ans << ' ';\n\n        int p = 0;\n        rep(i, 1000){\n            rep(j, 1000){\n                if(dp[i][j] == ans && z[i][j]){\n                    p = max(from_coord(i, j), p);\n                }\n            }\n        }\n        cout << p << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\npair<int, int> dp[2005][2005];\n\nclass UlamSpiral{\n\tprivate:\n\t\tconst static int MAX_N = 2005;\n\t\tconst static int kN = 1000005;\n\t\tvoid primeNumber(bool prime[kN]){\n\t\t\trep(i,kN) prime[i] = 1;\n\t\t\tprime[0] = prime[1] = 0;\n\t\t\trep(i,kN){\n\t\t\t\tif(prime[i]){\n\t\t\t\t\tfor(int j = i + i; j < kN; j+=i){\n\t\t\t\t\t\tprime[j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tpublic:\n\t\tint spiral[MAX_N][MAX_N] = {{0}};\n\t\tint CENTER;\n\t\tbool p[kN] = {0};\n\t\tconst int dy[4] = { 0,-1, 0, 1}; //???????¨???????\n\t\tconst int dx[4] = { 1, 0,-1, 0};\n\t\tUlamSpiral(int n){ //?????¶??°?????°\n\t\t\tCENTER = MAX_N / 2;;\n\n\t\t\tprimeNumber(p);\n\n\t\t\tint x = CENTER, y = CENTER;\n\t\t\tint dir = 0; //?????????\n\t\t\trep(i,n){\n\t\t\t\tspiral[y][x] = i + 1;\n\t\t\t\tx += dx[dir % 4];\n\t\t\t\ty += dy[dir % 4];\n\n\t\t\t\tint nx = x + dx[(dir + 1) % 4];\n\t\t\t\tint ny = y + dy[(dir + 1) % 4];\n\t\t\t\tif(spiral[ny][nx] == 0){\n\t\t\t\t\tdir++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpair<int, int> getPoint(int n){ //??°???n???????????§?¨?\n\t\t\trep(i,MAX_N){\n\t\t\t\trep(j,MAX_N){\n\t\t\t\t\tif(spiral[i][j] == n){\n\t\t\t\t\t\treturn make_pair(i,j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(false);\n\t\t\treturn make_pair(-1,-1);\n\t\t}\n\n\t\tbool isPrime(int n){\n\t\t\treturn p[n];\n\t\t}\n\t\tbool isPrime(int y, int x){\n\t\t\tif(spiral[y][x] == -1) return 0;\n\t\t\treturn p[spiral[y][x]];\n\t\t}\n\n\t\tvoid out(){\n\t\t\tshow(CENTER)\n\t\t\tfor(int i = CENTER - 11; i < CENTER + 11; i++){\n\t\t\tfor(int j = CENTER - 11; j < CENTER + 11; j++){\n\t\t\t\t//printf(\"%02d \", spiral[i][j]);\n\t\t\t\tif(p[spiral[i][j]]){\n\t\t\t\tprintf(\"%02d \", spiral[i][j]);\n\t\t\t\t}else{\n\t\t\t\t\tcout << \"__ \";\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << endl;\n\n\t\t\t}\n\t\t}\n};\n\nint main(){\n\tint m,n;\n\twhile(cin >> m >> n, n){\n\t\tUlamSpiral ulam(m);\n\t\t//ulam.out();\n\n\t\tpair<int, int> s = ulam.getPoint(n);\n\t\trep(i,2000) rep(j,2000) dp[i][j] = make_pair(-1,-1);\n\t\tdp[s.first][s.second] = make_pair(0,-1);\n\n\t\trange(i,s.first,2000){\n\t\t\trange(j,1,2000){\n\t\t\t\tif(dp[i][j].first == -1) continue;\n\t\t\t\tif(ulam.isPrime(i,j)) {\n\t\t\t\t\tdp[i][j] = make_pair(dp[i][j].first + 1, ulam.spiral[i][j]);\n\t\t\t\t}\n\t\t\t\tfor(int k = -1; k <= 1; k++){\n\t\t\t\t\tif(dp[i + 1][j + k].first < dp[i][j].first){\n\t\t\t\t\t\tdp[i + 1][j + k] = dp[i][j];\n\t\t\t\t\t}else if(dp[i + 1][j + k].first == dp[i][j].first){\n\t\t\t\t\t\tif(dp[i + 1][j + k].second < dp[i][j].second){\n\t\t\t\t\t\t\tdp[i + 1][j + k] = dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\tvector<pair<int, int>> b;\n\t\t//cout << s.first << ' ' << s.second << endl;\n\t\trep(i,2000){\n\t\t\tfor(int j = 2000; j >= 0; j--){\n\t\t\t\tif(ulam.spiral[j][i] != 0){\n\t\t\t\t\t//show(ulam.spiral[j][i])\n\t\t\t\t\t//\tshow(dp[j][i].first)\n\t\t\t\t\t//\tshow(dp[j][i].second)\n\t\t\t\t\t//cout << j << ' ' << i << endl;\n\t\t\t\t\tb.emplace_back(j,i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint p = 0;\n\t\trep(i,b.size()){\n\t\t\t//cout << dp[i.first][i.second] << endl;\n\t\t\tif(dp[b[i].first][b[i].second].first > dp[b[p].first][b[p].second].first){\n\t\t\t\tp = i;\n\t\t\t}else if(dp[b[i].first][b[i].second].first == dp[b[p].first][b[p].second].first && dp[b[i].first][b[i].second].second > dp[b[p].first][b[p].second].second){\n\t\t\t\tp = i;\n\t\t\t}\n\t\t}\n\n\t\tif(dp[b[p].first][b[p].second].first == 0){\n\t\t\tcout << \"0 0\" << endl;\n\t\t}else{\n\t\t\tpair<int, int> pr = dp[b[p].first][b[p].second];\n\t\t\tcout << pr.first << ' ' << pr.second << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define LOCAL\n#include <bits/stdc++.h>\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define rrep(i, n) for(int i=(n-1); i>=0; --i)\n#define rep2(i, s, n) for(int i=s; i<(n); ++i)\n#define ALL(v) (v).begin(), (v).end()\n#define memr(dp, val) memset(dp, val, sizeof(dp))\nusing namespace std;\ntypedef long long ll;\nstatic const int INTINF = (INT_MAX >> 1); // 10^9 + 10^7\nstatic const ll LLINF = (LLONG_MAX >> 1);\nstatic const int MAX = 100001;\nstatic const ll MOD = 1000000007;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool int_ceil(T a, T b) { T res = a / b; if(a % b != 0) res++; return res; }\ntemplate<typename T>\nusing min_priority_queue = priority_queue<T, vector<T>, greater<T> >;\nstring to_string(string s) { return '\"' + s + '\"'; }\nstring to_string(bool b) { return b ? \"true\" : \"false\"; }\ntemplate <size_t N> string to_string(bitset<N> bs) {\n  string res;\n  for (size_t i = 0; i < N; ++i) res += '0' + bs[i];\n  return res;\n}\nstring to_string(vector<bool> v) {\n  string res = \"{\";\n  for (bool e : v) res += to_string(e) + \", \";\n  return res += \"}\";\n}\ntemplate <class T, class U> string to_string(pair<T, U> p);\ntemplate <class C> string to_string(C c) {\n  string res = \"{\";\n  for (auto e : c) res += to_string(e) + \", \";\n  return res += \"}\";\n}\ntemplate <class T, class U> string to_string(pair<T, U> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\nvoid debug() { cerr << '\\n'; }\ntemplate <class Head, class... Tail> void debug(Head head, Tail... tail) {\n  cerr << '\\t' << to_string(head), debug(tail...);\n}\n#ifdef LOCAL\n#define print(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug(__VA_ARGS__)\n#else\n#define print(...)\n#endif\n\nvector<bool> sieve(long long max){ // 0 <= x <= max までの素数を調べ、返す。\n    vector<bool> isPrime;\n    isPrime.resize(max+1,true); // isPrimeに必要な要素数を確保\n    isPrime[0] = false; // 0は素数ではない\n    isPrime[1] = false; // 1は素数ではない\n\n    for(int i=2; i*i<=max; ++i) // 0からsqrt(max)まで調べる\n        if(isPrime[i])\n            for(int j=2; i*j<=max; ++j)\n                isPrime[i*j] = false;\n\n    return isPrime;\n}\n\nint n, m;\n\npair<ll, ll> dp[1010][1010];\npair<int, int> numToPos[1000001];\nvector<bool> primes;\nbool dp2[1010][1010];\n\nint main(int argc, const char * argv[]) {\n\tstd::cout << std::fixed << std::setprecision(15);\n\n\trep(i, 1010) rep(j, 1010) dp[i][j] = {-1, -1};\n\tprimes = sieve(10000000);\n\tint base = 503;\n\tint num = 1;\n\tint x=0, y=0;\n\tint pattern = 0;\n\tint k=0;\n\tint dx[4] = {0, 0, 1, -1};\n\tint dy[4] = {1, -1, 0, 0};\n\twhile(num <= 1000000){\n\t\t// print(x, y);\n\t\tnumToPos[num] = {base+x, base+y};\n\t\tdp[base+y][base+x] = {num, 0};\n\t\tswitch (pattern)\n\t\t{\n\t\tcase 0:\n\t\t\tk=0;\n\t\t\tx++;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tk=3;\n\t\t\ty++;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tk=1;\n\t\t\tx--;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tk=2;\n\t\t\ty--;\n\t\t\tbreak;\n\t\t}\n\t\tif(dp[base+y+dy[k]][base+x+dx[k]].first == -1){\n\t\t\tpattern++; pattern %= 4;\n\t\t}\n\t\tnum++;\n\t}\n\t// print(numToPos[1000000]);\n\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(!n && !m) break;\n\n\t\trep(i, 1010) rep(j, 1010) dp[i][j].second = 0;\n\t\tmemr(dp2, 0);\n\n\t\t// 書き直し\n\n\t\tauto s = numToPos[m];\n\t\tqueue<pair<int, int> > q;\n\t\tq.push(s);\n\t\tdp[s.second][s.first].second = primes[m];\n\t\tll ans = 0;\n\t\tll last = 0;\n\t\tif(primes[m]){\n\t\t\tans = dp[s.second][s.first].second;\n\t\t\tlast = dp[s.second][s.first].first;\n\t\t}\n\t\t// print(dp[s.second][s.first].second);\n\t\twhile(!q.empty()){\n\t\t\tauto f = q.front(); q.pop();\n\t\t\tint x = f.first, y = f.second;\n\t\t\tfor(int i=0; i<3; i++){\n\t\t\t\tif(dp[y-1][x+i-1].first == -1) continue;\n\t\t\t\tif(n < dp[y-1][x+i-1].first) continue;\n\t\t\t\t// if(primes[dp[y-1][x+i-1].first]) print(dp[y-1][x+i-1].first);\n\t\t\t\tchmax(dp[y-1][x+i-1].second, dp[y][x].second + primes[dp[y-1][x+i-1].first]);\n\t\t\t\tif(primes[dp[y-1][x+i-1].first]){\n\t\t\t\t\tif(ans < dp[y-1][x+i-1].second){\n\t\t\t\t\t\tans = dp[y-1][x+i-1].second;\n\t\t\t\t\t\tlast = dp[y-1][x+i-1].first;\n\t\t\t\t\t}\n\t\t\t\t\telse if(ans == dp[y-1][x+i-1].second){\n\t\t\t\t\t\tchmax(last, dp[y-1][x+i-1].first);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(dp2[y-1][x+i-1]) continue;\n\t\t\t\tq.push({x+i-1, y-1});\n\t\t\t\tdp2[y-1][x+i-1] = true;\n\t\t\t}\n\t\t}\n\t\tcout << ans << \" \" << last << endl;\n\t\t// break;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define all(c) (c).begin(), (c).end()\n#define mp(a, b) make_pair(a, b)\n\nint m, n;\nbool prime[1000010];\n\nvoid init(){\n    fill(prime, prime+1000010, true);\n    prime[0] = prime[1] = false;\n    rep(i, 1000010)if(prime[i]){\n        for(int j=i*2; j<1000010; j+=i)prime[j] = false;\n    }\n}\n\nvoid makeCave(vector<vector<int> > &cave, int &sx, int &sy){\n    int k = 1;\n    for(; k*k<m; k+=2);\n    cave.assign(k, vector<int>(k, 0));\n    const int dx[] = {0, -1, 0, 1}, dy[] = {1, 0, -1, 0};\n    int x = k / 2, y = k/ 2, dir = 0, mask = 1;\n    for(int i=1; i<=m; ++i){\n        cave[x][y] = i;\n        if(i == n)sx = x, sy = y;\n        if(i == (2 * mask + 1) * (2 * mask + 1))mask++;\n        int nx = x + dx[dir], ny = y + dy[dir];\n        if(mask < max(abs(nx - k/2), abs(ny - k/2)))(dir += 1) %= 4;\n        x += dx[dir]; y += dy[dir];\n    }\n}\n\npair<int, int> proc(pair<int, int> p, int x){\n    return mp(p.first + prime[x], prime[x]? x: p.second);\n}\n\npair<int, int> solve(){\n    vector<vector<int> > cave;\n    int sx, sy;\n    makeCave(cave, sx, sy);\n    vector<vector<pair<int, int> > > dp(cave.size(), vector<pair<int, int> >(cave.size(), mp(0, 0)));\n    if(prime[cave[sx][sy]])dp[sx][sy] = mp(1, cave[sx][sy]);\n    int l = sy, r = sy + 1;\n    for(int x=sx+1; x<(int)cave.size(); ++x){\n        l = max(0, l-1); r = min(r+1, (int)cave.size());\n        for(int y=l; y<r; ++y){\n            for(int dy=-1; dy<=1; ++dy){\n                if(y + dy < 0 || (int)cave.size() <= y + dy)continue;\n                dp[x][y] = max(dp[x][y], proc(dp[x-1][y+dy], cave[x][y]));\n            }\n        }\n    }\n    return *max_element(all(dp.back()));\n}\n\nint main(){\n    init();\n    while(cin >> m >> n, m|n){\n        pair<int, int> ans(solve());\n        cout << ans.first << ' ' << ans.second << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nint caves[2000][2000];\n\nbool sieve[1000001];\nint SX, SY;\n\ntypedef pair<int, int> PII;\n\nPII dp[2000][2000];\nbool vis[2000][2000];\n\nint main()\n{\n\tint nx, ny;\n\tfill(sieve, sieve + 1000001, true);\n\tsieve[0] = sieve[1] = false;\n\tfor(int i = 2; i * i <= 1000000; ++i) {\n\t\tif(sieve[i]) {\n\t\t\tfor(int j = i * i; j <= 1000000; j += i) {\n\t\t\t\tsieve[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint M, N;\n\twhile (cin>>M>>N, M||N) {\n\t\tmemset(caves, -1, sizeof(caves));\n\t\t\n\t\tfor (int j=0; j<2000; j++) {\n\t\t\tfor (int i=0; i<2000; i++) {\n\t\t\t\tdp[i][j] = PII(0, -1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tnx = ny = 2000/2;\n\t\tint len=1, num=2;\n\t\tint d = 0;\n\t\t\n\t\tcaves[nx][ny] = 1;\n\t\t\n\t\twhile (num <= M) {\n\t\t\tfor (int j=0; j<len; j++) {\n\t\t\t\tnx += dx[d];\n\t\t\t\tny += dy[d];\n\t\t\t\tcaves[nx][ny] = num++;\n\t\t\t\tif (num > M) break;\n\t\t\t}\n\t\t\td++; d %= 4;\n\t\t\tif (num > M) break;\n\t\t\t\n\t\t\tfor (int j=0; j<len; j++) {\n\t\t\t\tnx += dx[d];\n\t\t\t\tny += dy[d];\n\t\t\t\tcaves[nx][ny] = num++;\n\t\t\t\tif (num > M) break;\n\t\t\t}\n\t\t\t\n\t\t\td++;\n\t\t\td %= 4;\n\t\t\tlen++;\n\t\t}\n\t\t\n\t\tfor (int i=0; i<2000; i++) {\n\t\t\tfor (int j=0; j<2000; j++) {\n\t\t\t\tif (caves[j][i] == N) {\n\t\t\t\t\tSX = j, SY = i;\n\t\t\t\t\tif(sieve[N]) {\n\t\t\t\t\t\tdp[i][j] = PII(1, N);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j] = PII(0, -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t#if 0\n\t\tfor (int i=1000-10; i<1000+10; i++) {\n\t\t\tfor (int j=1000-10; j<1000+10; j++) {\n\t\t\t\tprintf(\"%3d\", caves[j][i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t#endif\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tvis[SY][SX] = true;\n\t\tfor(int i = 0; i < 2000 - 1; ++i) {\n\t\t\tfor(int j = 0; j < 2000; ++j) {\n\t\t\t\tif(vis[i][j] == false) continue;\n\t\t\t\tfor(int k = -1; k <= 1; ++k) {\n\t\t\t\t\tint nx = j + k;\n\t\t\t\t\tif(nx < 0 || nx >= 2000) continue;\n\t\t\t\t\tint add = dp[i][j].first;\n\t\t\t\t\tint maxP = dp[i][j].second;\n\t\t\t\t\tif(caves[nx][i + 1] > 0 && sieve[caves[nx][i + 1]]) {\n\t\t\t\t\t\tadd++;\n\t\t\t\t\t\tmaxP = caves[nx][i + 1];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i + 1][nx] = max(dp[i + 1][nx], PII(add, maxP));\n\t\t\t\t\tvis[i + 1][nx] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tPII ans(-1, -1);\n\t\tfor(int j = 0; j < 2000; ++j) {\n\t\t\tans = max(ans, dp[2000 - 1][j]);\n\t\t}\n\t\tcout << ans.first << ' ' << max(0, ans.second) << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\nint num[2048][2048];\nint dy[] = {0, -1, 0, 1};\nint dx[] = {1, 0, -1, 0};\nint m;\nbool prime[1000001];\npair<int, int> pos[1000001];\npair<int, int> memo[1000001];\n\nbool valid(int y, int x)\n{\n\treturn (0 <= y && y <= 2000 && 0 <= x && x <= 2000 && 1 <= num[y][x] && num[y][x] <= m);\n}\n\npair<int, int> getMax(pair<int, int> pos)\n{\n\tif (memo[num[pos.first][pos.second]].first != -1)\n\t\treturn (memo[num[pos.first][pos.second]]);\n\t\n\tint y = pos.first, x = pos.second;\n\tpair<int, int> ret = make_pair(0, 0);\n\tfor (int dx = -1; dx <= 1; dx++){\n\t\tif (valid(y + 1, x + dx)){\n\t\t\tpair<int, int> tmp = getMax(make_pair(y + 1, x + dx));\n\t\t\tif (ret < tmp) ret = tmp;\n\t\t}\n\t}\n\t\n\tif (prime[num[y][x]]){\n\t\tret.first++;\n\t\tif (!ret.second) ret.second = num[y][x];\n\t}\n\t\n\treturn (memo[num[pos.first][pos.second]] = ret);\n}\n\nint main()\n{\n\tmemset(num, -1, sizeof(num));\n\t\n\tint sx = 1000, sy = 1000;\n\tint n = 1;\n\tint step = 1, dir = 0;\n\t\n\tnum[sy][sx] = n;\n\tpos[n++] = make_pair(sy, sx);\n\twhile (n <= 1000000){\n\t\tfor (int i = 0; i < step; i++){\n\t\t\tsy += dy[dir]; sx += dx[dir];\n\t\t\tnum[sy][sx] = n;\n\t\t\tpos[n++] = make_pair(sy, sx);\n\t\t}\n\t\tdir = (dir + 1) % 4;\n\t\tfor (int i = 0; i < step; i++){\n\t\t\tsy += dy[dir]; sx += dx[dir];\n\t\t\tnum[sy][sx] = n;\n\t\t\tpos[n++] = make_pair(sy, sx);\n\t\t}\n\t\tdir = (dir + 1) % 4;\n\t\tstep++;\n\t}\n\t\n\tfor (int i = 3; i <= 1000000; i += 2) prime[i] = true;\n\tprime[2] = true;\n\t\n\tfor (int i = 3; i * i <= 1000000; i += 2){\n\t\tif (prime[i] == true){\n\t\t\tfor (int j = 3 * i; j <= 1000000; j += 2 * i) prime[j] = false;\n\t\t}\n\t}\n\t\n\twhile (scanf(\"%d %d\", &m, &n) && m){\n\t\tfor (int i = 0; i <= 1000000; i++)\n\t\t\tmemo[i].first = memo[i].second = -1;\n\t\t\n\t\tpair<int, int> ans = getMax(pos[n]);\n\t\t\n\t\tprintf(\"%d %d\\n\", ans.first, ans.second);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\n#define SIZE 1000\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\t\t/*\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}*/\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}/*\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}*/\n\t\t\n\t\toutput = false;\n\t\tfor (int i = 0;i < SIZE&&(!output);i++) {\n\t\t\tfor (int j = 0;j < SIZE&&(!output);j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\t//printf(\"%d\\n\", dp[i][j]);\n\t\t\t\t\t//printf(\"%d %d\\n\", dp[i][j], pr[i][j]);\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n#define ALLNUM 1002\n#define fin cin\n\nint all, start;\nint map[ALLNUM][ALLNUM] = {};\n\nbool isPrime(int n){\n    if(n <= 1)return false;\n    if(n == 2)return true;\n    if(n % 2 == 0)return false;\n    \n    for(int i = 3; i * i <= n; i+=2){\n        if(n % i == 0)return false;\n    }\n    return true;\n}\n\nclass Pair{\n    \npublic:\n    int num;\n    int count;\n    \n    Pair(){\n        this->num = 0;\n        this->count = 0;\n    };\n    Pair(int _num){\n        if(isPrime(_num)){\n            this->num = _num;\n            this->count = 1;\n        }\n        else {this->num = this->count = 0;}\n    }\n    \n    Pair operator + (const Pair &p){\n        this->count += p.count;\n        if(p.num != 0)this->num = p.num;\n        return *this;\n    }\n    \n    void print(){\n        cout << this->count << \" \" << this->num;\n    }\n};\n\nbool come[ALLNUM][ALLNUM];\nPair pMap[ALLNUM][ALLNUM];\n\nvoid init(){\n    \n    for(int i = 0; i < ALLNUM; i++){\n        for(int j = 0; j < ALLNUM; j++){\n            pMap[i][j] = Pair(0);\n            come[i][j] = false;\n        }\n    }\n}\n\nPair calc(int y, int x){\n    \n    if(map[y][x] > all)return Pair(-10);\n    if(come[y][x])return pMap[y][x];\n    \n    Pair p(map[y][x]);\n    Pair ans;\n    \n    Pair tmp1 = calc(y + 1, x);\n    Pair tmp2 = calc(y + 1, x + 1);\n    \n    if (tmp1.count == tmp1.count) {\n        if (tmp1.num < tmp2.num)tmp1.count--;\n    }\n    \n    if (tmp1.count < tmp2.count)ans =  tmp2;\n    else ans = tmp1;\n    \n    tmp1 = calc(y + 1, x - 1);\n    \n    if (tmp1.count < ans.count);\n    else ans = tmp1;\n    \n    /*\n     if (tmp1.count == tmp2.count) {\n     if(tmp1.num == tmp2.num)ans = tmp1;\n     else if(tmp1.num < tmp2.num)ans = tmp2;\n     else ans = tmp1;\n     }\n     else if(tmp1.count < tmp2.count)ans = tmp2;\n     else ans = tmp1;\n     \n     tmp2 = calc(y + 1, x - 1);\n     if (ans.count == tmp2.count) {\n     if(ans.num == tmp2.num);\n     else if(ans.num < tmp2.num)ans = tmp2;\n     else ;\n     }\n     else if(ans.count < tmp2.count)ans = tmp2;\n     else ;\n     */\n    \n    come[y][x] = true;\n    return pMap[y][x] = p + ans;\n}\n\nint main() {\n    //ifstream fin(\"in.txt\");\n    \n    int x, y;\n    x = y = ALLNUM / 2;\n    \n    map[y][x] = 1;\n    \n    int gumi = 1;\n    int num = 1;\n    \n    while(num < (ALLNUM - 1) * (ALLNUM - 1)){\n        for(int i = 0; i < gumi; i++){\n            map[y][++x] = ++num;\n        }\n        if(num >= ALLNUM * ALLNUM)break;\n        \n        for(int i = 0; i < gumi; i++){\n            map[--y][x] = ++num;\n        }\n        if(num >= ALLNUM * ALLNUM)break;\n        \n        gumi++;\n        for(int i = 0; i < gumi; i++){\n            map[y][--x] = ++num;\n        }\n        if(num >= ALLNUM * ALLNUM)break;\n        \n        for(int i = 0; i < gumi; i++){\n            map[++y][x] = ++num;\n        }\n        if(num >= ALLNUM * ALLNUM)break;\n        gumi++;\n    }\n    \n    while(true){\n        fin >> all >> start;\n        if((all | start) == 0)break;\n        \n        init();\n        x = y = 0;\n        \n        for(int i = 0; i < ALLNUM; i++){\n            for(int j = 0; j < ALLNUM; j++){\n                if(map[j][i] == start){\n                    x = i;\n                    y = j;\n                    i = j = ALLNUM;//?????????break;\n                    break;\n                }\n            }\n        }\n        calc(y, x).print();\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\nconst int MAX_N = 1000010;\n\nint prime[MAX_N];\nbool is_prime[MAX_N + 1];\nvoid sieve(int n){\n   int p = 0;\n   for(int i = 0; i <= n; i++) is_prime[i] = true;\n   is_prime[0] = is_prime[1] = false;\n   for(int i = 2; i <= n; i++){\n   if(is_prime[i]){\n           prime[p++] = i;\n           for(int j = 2*i; j <= n; j += i) is_prime[j] = false;\n       }\n   }\n}\nint dy[4] = {0, -1, 0, 1};\nint dx[4] = {1, 0, -1, 0};\n\nint m, st;\nint a[2010][2010];\nint dp[2010][2010];\nint cnt[MAX_N];\n\nint main() {\n    sieve(MAX_N);\n    while(1){\n        cin >> m >> st;\n        if(m + st == 0) break;\n        rep(i, 0, 2010) rep(j, 0, 2010){\n            a[i][j] = -1; dp[i][j] = -1;\n        }\n        memset(cnt, 0, sizeof(cnt));\n        int l = 1, dir = 0, num = 1;\n        int y = 1000, x = 1000;\n        a[y][x] = num++;\n        for(int i = 0;; i++){\n            if(num > m) break;\n            rep(j, 0, l){\n                if(num > m) break;                \n                y += dy[dir];\n                x += dx[dir];\n                a[y][x] = num++;\n            }\n            dir = (dir + 1) % 4;\n            if(i % 2) l++;\n        }\n        // rep(i, 990, 1011){\n        //     rep(j, 990, 1011){\n        //         cout << a[i][j] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        int sy = -1, sx = -1;\n        rep(i, 0, 2010) rep(j, 0, 2010) if(a[i][j] == st){\n            sy = i; sx = j; i = 2010; break;\n        }\n        dp[sy][sx] = 0;\n        if(is_prime[st]){\n            dp[sy][sx] = 1;\n            cnt[st] = 1;\n        }\n        rep(i, sy, 2000){\n            rep(j, 0, 2000){\n                if(dp[i][j] == -1) continue;\n                rep(k, -1, 2){\n                    int nxt = j + k;\n                    if(nxt < 0) continue;\n                    int nxtNum = a[i + 1][nxt];\n                    if(nxtNum == -1 || !is_prime[nxtNum]){\n                        dp[i + 1][nxt] = max(dp[i + 1][nxt], dp[i][j]);\n                    }else{\n                        dp[i + 1][nxt] = max(dp[i + 1][nxt], dp[i][j] + 1);\n                        cnt[nxtNum] = max(cnt[nxtNum], dp[i][j] + 1);\n                    }\n                }\n            }\n        }\n        int ans = 0, MAXid = 0;\n        rep(i, 0, 2010) ans = max(ans, dp[2000][i]);\n        if(ans != 0){\n            rep(i, 0, MAX_N){\n                if(cnt[i] == ans){\n                    MAXid = i;\n                }\n            }\n        }\n        cout << ans << \" \" << MAXid << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=1005,INF=1<<25;\nvector<int> prime;//i番目の素数\nbool is_prime[MAX*MAX+1];\n\nvoid sieve(int n){\n    for(int i=0;i<=n;i++){\n        is_prime[i]=true;\n    }\n    \n    is_prime[0]=is_prime[1]=false;\n    \n    for(int i=2;i<=n;i++){\n        if(is_prime[i]){\n            prime.push_back(i);\n            for(int j=2*i;j<=n;j+=i){\n                is_prime[j] = false;\n            }\n        }\n    }\n}\nint id[MAX][MAX];\npair<int,int> dp[MAX][MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    sieve(1000003);\n    \n    for(int i=0;i<MAX;i++){\n        for(int j=0;j<MAX;j++){\n            id[i][j]=INF;\n        }\n    }\n    \n    ll t=0;\n    \n    int i=501,j=501;\n    vector<int> whi(1000003),whj(1000003);\n    for(ll k=1;k<=1000000;k++){\n        id[i][j]=k;\n        whi[k]=i;\n        whj[k]=j;\n        \n        if(k>t*t) t++;\n        if(t%2==1){\n            if(k<=(t-1)*t) i++;\n            else j++;\n        }else{\n            if(k<=(t-1)*t) i--;\n            else j--;\n        }\n    }\n    \n    while(1){\n        int M,N;cin>>M>>N;\n        if(M+N==0) break;\n        \n        for(int i=0;i<MAX;i++){\n            for(int j=0;j<MAX;j++){\n                dp[i][j]={-INF,0};\n            }\n        }\n        int i=whi[N],j=whj[N];\n        dp[i][j].first=0;\n        if(is_prime[N]){\n            dp[i][j].first=1;\n            dp[i][j].second=N;\n        }\n        \n        for(int a=i;a<=1002;a++){\n            for(int b=1;b<=1002;b++){\n                for(int c=-1;c<=1;c++){\n                    if(id[a+1][b+c]>M) continue;\n                    \n                    if(is_prime[id[a+1][b+c]]){\n                        dp[a+1][b+c]=max(dp[a+1][b+c],{dp[a][b].first+1,id[a+1][b+c]});\n                    }else{\n                        dp[a+1][b+c]=max(dp[a+1][b+c],dp[a][b]);\n                    }\n                }\n            }\n        }\n        \n        pair<int,int> ans={-INF,0};\n        \n        for(int i=0;i<MAX;i++){\n            for(int j=0;j<MAX;j++){\n                ans=max(ans,dp[i][j]);\n            }\n        }\n        \n        cout<<ans.first<<\" \"<<ans.second<<endl;\n        \n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cstdio>\n#include <cmath>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define fr first\n#define sc second\n#define mp make_pair\n\ntypedef long long int64;\ntypedef pair< int, int > iP;\ntypedef pair< iP, int > iiP;\n\nconst int INF = 2 << 28;\nconst double EPS = 1e-10;\n\n#define MAX 1000000\n#define NEXT(d) ((d) % 4)\n\nint mas[2000][2000];\niP idx[MAX + 1];\nvector< bool > isP(MAX + 1, true);\n\nvoid makePrime() {\n    for(int i = 2; i * i <= MAX; i++)\n        for(int j = i + i; j <= MAX; j += i)\n            isP[j] = false;\n}\n\nvoid makeMap() {\n    //> ^ < v\n    int x = 1000, y = 1000;\n    int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n    int dir = 0;\n    for(int i = 1; i <= MAX; i++) {\n        mas[y][x] = i;\n        idx[i] = iP(y, x);\n        x += dx[dir], y += dy[dir];\n        if(!mas[y + dy[NEXT(dir + 1)]][x + dx[NEXT(dir + 1)]]) dir = NEXT(dir + 1);\n    }\n}\n\nint M;\niP dp[MAX + 1];\n\niP rec(int now) {\n    if(dp[now].fr) return dp[now];\n    if(mas[idx[now].fr][idx[now].sc] > M || mas[idx[now].fr][idx[now].sc] == 0) return iP(0, 0);\n    iP ret = iP(0, 0);\n    int dx[] = {-1, 0, 1}, dy[] = {1, 1 ,1};\n    for(int i = 0; i < 3; i++) {\n        int x = idx[now].sc, y = idx[now].fr;\n        int nx = x + dx[i], ny = y + dy[i];\n        iP res = rec(mas[ny][nx]);\n        ret = max(ret, iP(res.fr + isP[mas[y][x]], max(res.sc, mas[y][x] * isP[mas[y][x]])));\n    }\n    return dp[now] = ret;\n}\n\nint main() {\n\n    makePrime();\n    makeMap();\n\n    int n;\n    while(cin >> M >> n, M) {\n        fill_n(dp, MAX + 1, iP(0, 0));\n        iP ans = rec(n);\n        cout << ans.fr << \" \" << ans.sc << endl;;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<set>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\ntypedef pair<int,int> pii;\n\nconst int M = 1400;\nconst int C = 700;\nconst int S = 1111111;\n\nint board[M][M];\npii dp[M][M];\n\nint sosu[S];\n\npii saiki(int x,int y){\n\tif(dp[y][x].first!=0)return dp[y][x];\n\tif(board[y][x]==-1)return pii(0,0);\n\t\n\tint dx[] = {1,0,-1};\n\tpii ret = pii(0,0);\n\trep(i,3)ret = max(ret, saiki(x+dx[i], y+1));\n\t\n\tif(sosu[board[y][x]]==0){\n\t\tret.first++;\n\t\tif(ret.second==0)ret.second = board[y][x];\n\t}\n\t\n//\tprintf(\"[%d %d]->%d %d %d\\n\",y,x,board[y][x],ret.first,ret.second);\n\t\n\treturn dp[y][x]=ret;\n}\n\nint main(){\n\t\n\tsosu[0]=sosu[1]=1;\n\trep(i,S){\n\t\tif(sosu[i]==1)continue;\n\t\tfor(int j=i*2; j<S; j+=i)sosu[j]=1;\n\t}\n\t\n\tB:;\n\t\n\tint n,m;\n\tcin>>n>>m;\n\t\n\tif(n==0 && m==0)return 0;\n\t\n\trep(i,M)rep(j,M){\n\t\tboard[i][j]=-1;\n\t\tdp[i][j]=pii(0,0);\n\t}\n\t\n\tpii st;\n\t{\n\t\tpii pos = pii(C,C);\n\t\tint dir = 0;\n\t\tint len = 1;\n\t\tint cnt = 1;\n\t\tint dx[]={1,0,-1,0};\n\t\tint dy[]={0,-1,0,1};\n\t\twhile(1){\n\t\t\trep(i,len){\n\t\t\t\tif(cnt>n)goto A;\n\t\t\t\tboard[pos.second][pos.first]=cnt;\n\t\t\t\tif(cnt==m)st = pos;\n\t\t\t\tcnt++;\n\t\t\t\tpos.first+=dx[dir];\n\t\t\t\tpos.second+=dy[dir];\n\t\t\t}\n\t\t\tdir = (dir+1)%4;\n\t\t\tif(dir%2==0)len++;\n\t\t}\n\t\tA:;\n\t}\n\t\n\t\n\tpii ans = saiki(st.first, st.second);\n\tprintf(\"%d %d\\n\",ans.first,ans.second);\n\t\n\tgoto B;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvoid solve(){\n    vector<bool> is_prime(1e6+1,true);\n    is_prime[0]=is_prime[1]=false;\n    rep(i,2,1e+6+1){\n        if(!is_prime[i]) continue;\n        for(int j=i*2; j<1e6+1; j+=i) is_prime[j]=false;\n    }\n    while(true){\n        int m,n;\n        cin >> m >> n;\n        if(m==0 and n==0) break;\n\n        unordered_map<pii,int> encode;\n        unordered_map<int,pii> decode;\n        unordered_map<int,vector<int>> xs;\n        {\n            int x=0,y=0,dir=3;\n            rep(i,1,m+1){\n                encode[make_pair(x,y)]=i;\n                decode[i]=make_pair(x,y);\n                xs[y].push_back(x);\n                int nx=x+dx[(dir+1)%4],ny=y+dy[(dir+1)%4];\n                if(encode.find(make_pair(nx,ny))==encode.end()) dir=(dir+1)%4;\n                else{\n                    nx=x+dx[dir];\n                    ny=y+dy[dir];\n                }\n                x=nx;\n                y=ny;\n            }\n        }\n\n        unordered_map<pii,int> dp;\n        int y=decode[n].second+1,ans,max_num;\n        if(is_prime[n]){\n            dp[decode[n]]=1;\n            ans=1;\n            max_num=n;\n        }else{\n            dp[decode[n]]=0;\n            ans=0;\n            max_num=0;\n        }\n        while(xs.find(y)!=xs.end()){\n            for(int x:xs[y]){\n                int tmp=-1;\n                if(dp.find(make_pair(x-1,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x-1,y-1)]);\n                if(dp.find(make_pair(x,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x,y-1)]);\n                if(dp.find(make_pair(x+1,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x+1,y-1)]);\n                if(tmp==-1) continue;\n                if(is_prime[encode[make_pair(x,y)]]){\n                    ++tmp;\n                    if(tmp>ans){\n                        ans=tmp;\n                        max_num=encode[make_pair(x,y)];\n                    }else if(tmp==ans) max_num=max(max_num,encode[make_pair(x,y)]);\n                }\n                dp[make_pair(x,y)]=tmp;\n            }\n            ++y;\n        }\n\n        cout << ans << \" \" << max_num << endl;\n    }\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstring>\n#include <tuple>\n#include <utility>\n#define MAX_N 1010\n#define LIMIT 1000010\n#define CENTER 501\nusing namespace std;\nconst int dy[] = {0, -1, 0, 1};\nconst int dx[] = {1, 0, -1, 0};\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\ntypedef struct res\n{\n    int id, num, last;\n} table_t;\ntable_t table[MAX_N][MAX_N];\nbool isPrime[LIMIT];\nint sy, sx, n, m;\nvoid make_prime()\n{\n    fill(isPrime, isPrime + LIMIT, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i * i < LIMIT; i++)\n    {\n        if (!isPrime[i])\n            continue;\n        for (int j = i * 2; j < LIMIT; j += i)\n            isPrime[j] = false;\n    }\n}\nvoid init_table()\n{\n    for(int i = 0; i < MAX_N; i++)\n    {\n        for(int j = 0; j < MAX_N; j++)\n        {\n            table[i][j].id = table[i][j].last = 0;\n            table[i][j].num = -1;\n        }\n    }\n}\nvoid make_cave()\n{\n    int dir = 0, ok = 1, cnt = 0, flag = 0;\n    int y, x;\n    y = x = MAX_N / 2;\n    for (int i = 1; i <= m; i++)\n    {\n        if (i == n)\n        {\n            sy = y;\n            sx = x;\n        }\n        table[y][x].id = i;\n        //dp[y][x].second = i;\n        y += dy[dir];\n        x += dx[dir];\n        cnt++;\n        if (cnt == ok)\n        {\n            dir = (dir + 1) % 4;\n            flag++;\n            cnt = 0;\n            if (flag == 2)\n            {\n                flag = 0;\n                ok++;\n            }\n        }\n    }\n}\ntable_t dfs(int y, int x)\n{\n    table_t ret;\n    int id, num, last;\n    if(table[y][x].id == 0)\n    {\n        ret.id = ret.num = ret.last = 0;\n    }\n    else if(table[y][x].num >= 0)\n        ret = table[y][x];\n    else\n    {\n        num = last = 0;\n        id = table[y][x].id;\n        for(int i = -1; i <= 1; i++)\n        {\n            ret = dfs(y + 1, x + i);\n            if(ret.num > num)\n            {\n                num = ret.num;\n                last = ret.last;\n            }\n            else if(ret.num == num)\n            {\n                last = max(ret.last, last);\n            }\n        }\n        if(isPrime[id])\n        {\n            if(num == 0)\n                last = id;\n            num++;\n        }\n        ret.id = id;\n        ret.num = num;\n        ret.last = last;\n        table[y][x] = ret;\n    }\n    return ret;\n}\nint main()\n{\n    make_prime();\n    while (cin >> m >> n, n | m)\n    {\n        //memset(dp, -1, sizeof(dp));\n        init_table();\n        //memset(visit, false, sizeof(visit));\n        make_cave();\n        table_t ans = dfs(sy, sx);\n        /*\n        for(int i = MAX_N / 2 - 20; i < MAX_N / 2 + 20; i++)\n        {\n            for(int j = MAX_N / 2 - 20; j < MAX_N / 2 + 20; j++)\n                printf(\"%5d\", table[i][j].last);\n            cout << endl;\n        }\n        */\n        cout << ans.num << \" \" << ans.last << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nusing namespace std;\n  \n#define MP make_pair\n#define PB push_back\n#define MAX_N 1001000\n#define SIZE 2010\n#define X first\n#define Y second\n  \nconst int STX = 1000, STY = 1000;\n  \nint id[SIZE][SIZE];\nbool is_prime[MAX_N+1];\nvector<pair<int, int> > coord;\n  \nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++) {\n    if(is_prime[i]) {\n      for(int j=i*i; j<=MAX_N; j+=i) {\n\t\tis_prime[j] = false;\n      }\n    }\n  }\n}\n  \nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  \n  coord.PB(MP(0, 0)); // no use\n  cnt ++;\n  coord.PB(MP(x, y)); // cnt = 1\n  \n  fill(id[0], id[0]+SIZE*SIZE+1, -1);\n  \n  const int dx[] = {0,-1,0,1};\n  const int dy[] = {-1,0,1,0};\n  \n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt <= MAX_N) {\n\ta += 2;\n\tfor(int turn=0; turn<4; turn++) {\n\t  for(int i=0; i<a; i++) {\n\t\tx += dx[turn], y += dy[turn];\n\t\tcoord.PB(MP(x, y));\n\t\tid[y][x] = ++ cnt;\n\t  }\n\t}\n\tx++, y++;\n  }\n}\n  \nint dp[MAX_N+1];\n  \nint main() {\n    \n  Sieve();\n  MakeMap();\n    \n  int m, n;\n    \n  while(cin >> m >> n && (m|n)) {\n    fill(dp, dp+MAX_N+1, -1);\n    dp[n] = is_prime[n];\n\t\n    queue<pair<int, int> > que;\n    que.push(coord[n]);\n    \n    while(!que.empty()) {\n      pair<int, int> now = que.front(); que.pop();\n      int noid = id[now.Y][now.X];\n      \n      for(int i=-1; i<=1; i++) {\n\tpair<int, int> nex = MP(now.X+i, now.Y+1);\n\tif(nex.X < 0 || SIZE <= nex.X || nex.Y < 0 || SIZE <= nex.Y) continue;\n\tint neid = id[nex.Y][nex.X];\n\tif(neid <= m) {\n\t  if(dp[neid] < dp[noid] + is_prime[neid]) {\n\t    dp[neid] = dp[noid] + is_prime[neid];\n\t    que.push(nex);\n\t  }\n\t}\n      }\n    }\n    \n    int res = dp[n], lastid = -1;\n    if(is_prime[n]) lastid = n;\n    \n    for(int i=1; i<=m; i++) {\n      if(res <= dp[i] && is_prime[i]) {\n\tres = dp[i];\n\tlastid = max(lastid, i);\n      }\n    }\n    \n    if(lastid == -1) cout << \"0 0\" << endl;\n    else cout << res << \" \" << lastid << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n\nint table[2000][2000];\nbool f[1111111];\nint dy[]={0,-1,0,1};\nint dx[]={1,0,-1,0};\npint dp[2000][2000];\npint idx[1111111];\nsigned main(){\n    int y=1000,x=1000,c=1;\n    table[y][x]=1;\n    idx[1]=pint(1000,1000);\n    for(int i=0;;i++){\n        int d=i%4;\n        int l=i/2+1;\n        rep(j,l){\n            c++;\n            y+=dy[d];\n            x+=dx[d];\n            if(c>1000000)break;\n            table[y][x]=c;\n            idx[c]=pint(y,x);\n        }\n        if(c>1000000)break;\n    }\n    memset(f,1,sizeof(f));\n    f[0]=f[1]=0;\n    for(int i=2;i<1111111;i++){\n        if(!f[i])continue;\n        for(int j=i+i;j<1111111;j+=i)f[j]=0;\n    }\n\n    int N,M;\n    while(cin>>N>>M,N||M){\n        fill_n(*dp,2000*2000,pint(-1001001001,0));\n        dp[idx[M].fi][idx[M].se]=pint(f[M],M*f[M]);\n        for(int i=0;i<2000;i++){\n            for(int j=0;j<2000;j++){\n                for(int k=-1;k<=1;k++){\n                    int ii=i+1;\n                    int jj=j+k;\n                    if(ii>=2000||jj<0||jj>=2000)continue;\n                    if(f[table[ii][jj]]&&table[ii][jj]<=N){\n                        chmax(dp[ii][jj],pint(dp[i][j].fi+1,table[ii][jj]));\n                    }\n                    else{\n                        chmax(dp[ii][jj],dp[i][j]);\n                    }\n                }\n            }\n        }\n        pint ma;\n        rep(i,2000)rep(j,2000)chmax(ma,dp[i][j]);\n        cout<<ma.fi<<\" \"<<ma.se<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {-1, 0, 1}, dy[] = {1, 0, -1, 0};\n\nint memo[1100][1100];\nbool prime[1000010];\nPII dp[1100][1100];\nsigned main(void)\n{\n\n  /*REP(i, 1000) {\n    REP(j, 1000) {\n      cout << memo[i][j] << \" \";\n    }\n    cout << endl;\n  }*/\n  //cout << memo[505][505] << endl;\n\n  // テァツエツ?ヲツ閉ーテ」ツ?ェテ」ツつ液rue\n  memset(prime, true, sizeof(prime));\n  prime[0] = prime[1] = false;\n  for (int i = 2; i * i <= 1000010; i++) {\n  \tif (prime[i]) {\n  \t\tfor (int j = 2 * i; j <= 1000010; j += i) {\n  \t\t\tprime[j] = false;\n  \t\t}\n  \t}\n  }\n\n  while(true) {\n    int m, n;\n    cin >> m >> n;\n    if(!m && !n) break;\n\n    int y = 505, x = 505, num = 1, len = 1;\n    bool end = false;\n    while(true) {\n      REP(j, len) {\n        if(num > m) {end = true; break;}\n        memo[y][x] = num;\n        x++;\n        num++;\n      }\n      if(end) break;\n      REP(j, len) {\n        if(num > m) {end = true; break;}\n        memo[y][x] = num;\n        y--;\n        num++;\n      }\n      if(end) break;\n      len++;\n      REP(j, len) {\n        if(num > m) {end = true; break;}\n        memo[y][x] = num;\n        x--;\n        num++;\n      }\n      if(end) break;\n      REP(j, len) {\n        if(num > m) {end = true; break;}\n        memo[y][x] = num;\n        y++;\n        num++;\n      }\n      if(end) break;\n      len++;\n    }\n\n    int sy, sx;\n    REP(i, 1010) REP(j, 1010) {\n      if(memo[i][j] == n) sy = i, sx = j;\n      dp[i][j] = {-INF, INF};\n    }\n    //cout << \"sx\" << sx << \" \" << sy << \" \" << memo[sy][sx] << endl;\n    queue<PII> q;\n    q.push({sx, sy});\n    if(prime[memo[sy][sx]]) dp[sy][sx] = {1, memo[sy][sx]};\n    else dp[sy][sx] = {0, 0};\n    while(q.size()) {\n      PII p = q.front(); q.pop();\n      int X = p.first, Y = p.second;\n      //cout << y << \" \" << x << endl;\n      REP(i, 3) {\n        int ny = Y+1, nx = X + dx[i];\n        //cout << memo[ny][nx] << endl;\n        if(IN(0, 1100, ny) && IN(0, 1100, nx) && 1 <= memo[ny][nx] && memo[ny][nx] <= m) {\n          if(prime[memo[ny][nx]]) {\n            if(dp[Y][X].first >= dp[ny][nx].first) {\n              //cout << ny << \":\" << nx << \":\" << memo[ny][nx] << endl;\n              dp[ny][nx].first = dp[Y][X].first + 1;\n              dp[ny][nx].second = memo[ny][nx];\n              q.push({nx, ny});\n            }\n          } else {\n            if(dp[Y][X].first > dp[ny][nx].first) {\n              //cout << ny << \" \" << nx << \" \" << memo[ny][nx] << endl;\n              dp[ny][nx] = dp[Y][X];\n              q.push({nx, ny});\n            }\n          }\n        }\n      }\n    }\n\n    /*REP(i, 1010) {\n      REP(j, 1010) {\n        cout << dp[i][j].first << \" \";\n      }\n      cout << endl;\n    }*/\n\n    int ret = -INF, idx = INF;\n    REP(i, 1100) REP(j, 1100) {\n      if(dp[i][j].first == INF) continue;\n      if(dp[i][j].first > ret) {\n        ret = dp[i][j].first;\n        idx = dp[i][j].second;\n        //cout << i << \" \" << j << \" \" << ret << \" \" << idx << endl;\n      } else if(dp[i][j].first == ret && dp[i][j].second > idx) {\n        ret = dp[i][j].first;\n        idx = dp[i][j].second;\n        //cout << i << \" \" << j << \" \" << ret << \" \" << idx << endl;\n      }\n    }\n    cout << ret << \" \" << idx << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstdio>\n \nusing namespace std;\n \n#define out(x,l) (x<0||l<=x)\n \nconst int N = 1000000+100;\nconst int SIZE = 1100;\n \nbool isprime[N];\npair<int, int> loc[N];\nint cave[SIZE][SIZE];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, -1, 0, 1};\npair<int, int> dp[SIZE][SIZE];\n \nint main(){\n    for (int i = 0; i < N; i++) { isprime[i] = 1; } \n    isprime[0] = isprime[1] = 0;\n    for (int i = 2; i*i <= N; i++) {\n        if (!isprime[i]) continue;\n        for (int j = 2*i; j <= N; j += i) {\n            isprime[j] = 0;\n        }\n    }\n\n\tfor (int i = 0; i < SIZE; i++)\n\t\tfor (int j = 0; j < SIZE; j++)\n\t\t\tcave[i][j] = N;\n \n    int x = SIZE/2, y = SIZE/2;\n    int cnt = 1;\n    int dir = 0;\n    int edge = 1;\n    while (1) {\n\t\tif (cnt > N) break;\n        dir %= 4;\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < edge; j++) {\n\t\t\t\tif (out(x,SIZE)||out(y,SIZE)) continue;\n                cave[y][x] = cnt;\n                loc[cnt].first = y;\n                loc[cnt].second = x;\n                x += dx[dir];\n                y += dy[dir];\n                cnt++;\n            }\n            dir++;\n        }\n        edge++;\n    }\n \n//  for (int i = 1; i < 100; i++) {\n//      cout << i << \" \" << loc[i].first << \" \" << loc[i].second << endl;\n//  }\n \n    int n, m;\n    while (cin >> m >> n, m&&n) {\n        for (int i = 0; i < SIZE; i++)\n            for (int j = 0; j < SIZE; j++) {\n                dp[i][j].first = -1;\n                dp[i][j].second = 0;\n            }\n        dp[loc[n].first][loc[n].second].first = isprime[n];\n        if (isprime[n]) dp[loc[n].first][loc[n].second].second = n;\n \n        for (int i = 0; i < SIZE; i++) {\n            for (int j = 0; j < SIZE; j++) {\n                if (cave[i][j] > m) continue;\n                pair<int, int> next; // first:the number of caves passed    second:last cave\n                next.first = -1;\n                next.second = 0;\n                bool update = 0;\n                if (!out(i-1,SIZE)&&!out(j-1,SIZE)&&dp[i-1][j-1].first!=-1) {\n                    if (dp[i-1][j-1].first > next.first) {\n                        next = dp[i-1][j-1];\n                        update = 1;\n                    } else if (dp[i-1][j-1].first == next.first && dp[i-1][j-1].second > next.second) {\n                        next = dp[i-1][j-1];\n                        update = 1;\n                    }\n                }\n                if (!out(i-1,SIZE)&&!out(j+1,SIZE)&&dp[i-1][j+1].first!=-1) {\n                    if (dp[i-1][j+1].first > next.first) {\n                        next = dp[i-1][j+1];\n                        update = 1;\n                    } else if (dp[i-1][j+1].first == next.first && dp[i-1][j+1].second > next.second) {\n                        next = dp[i-1][j+1];\n                        update = 1;\n                    }\n                }\n                if (!out(i-1,SIZE)&&!out(j,SIZE)&&dp[i-1][j].first!=-1) {\n                    if (dp[i-1][j].first > next.first) {\n                        next = dp[i-1][j];\n                        update = 1;\n                    } else if (dp[i-1][j].first == next.first && dp[i-1][j].second > next.second) {\n                        next = dp[i-1][j];\n                        update = 1;\n                    }\n                }\n                if (!update) continue;\n                if (isprime[cave[i][j]]) {\n                    next.first++;\n                    next.second = cave[i][j];\n                }\n                dp[i][j] = next;\n            }\n        }\n\n        pair<int, int> res;\n        for (int i = 0; i < SIZE; i++)\n            for (int j = 0; j < SIZE; j++)\n                if (res.first < dp[i][j].first) {\n                    res = dp[i][j];\n                } else if (res.first == dp[i][j].first&&res.second < dp[i][j].second) {\n                    res = dp[i][j];\n                }\n        cout << res.first << \" \" << res.second << endl;\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\nvoid foo(int& i, int& x, int& y, int& d, int l, vector< vector<int> >& a, vector<int>& X, vector<int>& Y) {\n\twhile (l--) {\n\t\ta[y][x] = i;\n\t\tX[i] = x; Y[i] = y;\n\t\tx += dx[d]; y += dy[d];\n\t\ti++;\n\t}\n\td = (d + 3) % 4;\n}\n\ni_i bar(int i, int m, vector< vector<int> >& a, vector<int>& X, vector<int>& Y, vector<bool>& p, vector<i_i>& memo) {\n\tif (i > m) return i_i(0, 0);\n\tif (memo[i].first >= 0) return memo[i];\n\tint x = X[i], y = Y[i];\n\tint j;\n\ti_i maxi = i_i(0, 0);\n\tj = a[y + 1][x - 1]; maxi = max(maxi, bar(j, m, a, X, Y, p, memo));\n\tj = a[y + 1][x]; maxi = max(maxi, bar(j, m, a, X, Y, p, memo));\n\tj = a[y + 1][x + 1]; maxi = max(maxi, bar(j, m, a, X, Y, p, memo));\n\tif (p[i] && maxi.first == 0)\n\t\treturn memo[i] = i_i(1, i);\n\treturn memo[i] = i_i(maxi.first + p[i], maxi.second);\n}\n\nint main() {\n\tvector< vector<int> > a(2000, vector<int>(2000, INT_MAX));\n\tvector<int> X(2000001), Y(2000001);\n\tint i = 1, x = 1000, y = 1000, d = 2, l = 1;\n\twhile (i <= 1000000) {\n\t\tfoo(i, x, y, d, l, a, X, Y);\n\t\tfoo(i, x, y, d, l, a, X, Y);\n\t\tl++;\n\t\tfoo(i, x, y, d, l, a, X, Y);\n\t\tfoo(i, x, y, d, l, a, X, Y);\n\t\tl++;\n\t}\n\tvector<bool> p(1000001, true);\n\tp[1] = false;\n\tfor (int i = 2; i <= 1000000; i++)\n\t\tif (p[i])\n\t\t\tfor (int j = i * 2; j <= 1000000; j += i)\n\t\t\t\tp[j] = false;\n\tfor (;;) {\n\t\tint m, n; cin >> m >> n;\n\t\tif (m == 0) break;\n\t\tvector<i_i> memo(1000001, i_i(-1, -1));\n\t\ti_i ans = bar(n, m, a, X, Y, p, memo);\n\t\tcout << ans.first << ' ' << ans.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int int64_t\n#define REP(i, s, n) for (signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define all(c) begin(c), end(c)\n\n#define maxup(ans, x) (ans = (ans < x ? x : ans))\n#define minup(ans, x) (ans = (ans > x ? x : ans))\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\nsigned main() {\n\tVV data(1000, V(1000));\n\tvector<P> nums(1000001);\n\tP center = P(500, 499);\n\tP now = center;\n\tdata[center.first][center.second] = 1;\n\n\tint length = 1;\n\tint x = 1;\n\twhile (x < 1000000) {\n\t\tif (length & 1) {\n\t\t\trep(j, length) {\n\t\t\t\tdata[now.first][++now.second] = ++x;\n\t\t\t\tnums[x] = now;\n\t\t\t}\n\t\t\trep(j, length) {\n\t\t\t\tdata[--now.first][now.second] = ++x;\n\t\t\t\tnums[x] = now;\n\t\t\t}\n\t\t} else {\n\t\t\trep(j, length) {\n\t\t\t\tdata[now.first][--now.second] = ++x;\n\t\t\t\tnums[x] = now;\n\t\t\t\tif (x == 1000000) {\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, length) {\n\t\t\t\tdata[++now.first][now.second] = ++x;\n\t\t\t\tnums[x] = now;\n\t\t\t}\n\t\t}\n\t\tlength++;\n\t}\nout:\n\tvector<bool> isprime(1000001, true);\n\tisprime[0] = isprime[1] = false;\n\tfor (int i = 2; i*i <= 1000000; i++) if (isprime[i]) {\n\t\tfor (int j = 2; i * j <= 1000000; j++) {\n\t\t\tisprime[i * j] = false;\n\t\t}\n\t}\n\n\tint m, n;\n\twhile (cin >> m >> n && m) {\n\t\tmap<P, P> memo;\n\t\tfunction<P(int, int)> dp = [&](int r, int c) {\n\t\t\tif (r < 0 || r >= data.size() || c < 0 || c >= data[0].size()\n\t\t\t\t|| data[r][c] > m) return P(0, 0);\n\t\t\tif (memo.count(P(r, c))) return memo[P(r, c)];\n\t\t\tP ret;\n\t\t\tmaxup(ret, dp(r + 1, c - 1));\n\t\t\tmaxup(ret, dp(r + 1, c));\n\t\t\tmaxup(ret, dp(r + 1, c + 1));\n\t\t\tif (isprime[data[r][c]]) {\n\t\t\t\tret.first++;\n\t\t\t\tif (ret.second == 0) ret.second = data[r][c];\n\t\t\t}\n\t\t\treturn memo[P(r, c)] = ret;\n\t\t};\n\t\tP ans = dp(nums[n].first, nums[n].second);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define all(v) ALL(v)\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n#define CININIT cin.tie(0),ios::sync_with_stdio(false)\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nint n,m;\nint table[1500][1500];\nvector<bool> is_prime;\n\nbool ok(int x,int y){\n    if(x<0 or x>=1500 or y<0 or y>=1500) return false;\n    if(table[x][y]==0) return false;\n    if(table[x][y]>m) return false;\n    return true;\n}\n\nvoid solve(){\n    vector<vector<int>> dp(1500,vi(1500,0));\n    vector<vector<bool>> vis(1500,vector<bool>(1500,false));\n    vector<vector<int>> pre(1500,vector<int>(1500,0));\n    int sx=0,sy=0;\n    [&]{\n        for(int i=0;i<1500;i++) for(int j=0;j<1500;j++) if(table[i][j]==n){\n            sx=i;\n            sy=j;\n            return;\n        }\n    }();\n\n    vis[sx][sy]=true;\n    if(is_prime[table[sx][sy]]) pre[sx][sy]=table[sx][sy];\n    if(is_prime[table[sx][sy]]) dp[sx][sy]++;\n\n\n    for(int x=0;x<1500;x++){\n        for(int y=0;y<1500;y++){\n            if(!vis[x][y]) continue;\n            int nx=x+1;\n            for(int i=-1;i<=1;i++){\n                int ny=y+i;\n                if(!ok(nx,ny)) continue;\n                vis[nx][ny]=true;\n                if(is_prime[table[nx][ny]]){\n                    dp[nx][ny] = max(dp[nx][ny],dp[x][y]+1);\n                    pre[nx][ny] = table[nx][ny];\n                }else{\n                    if(dp[nx][ny] < dp[x][y]){\n                        dp[nx][ny] = dp[x][y];\n                        pre[nx][ny] = pre[x][y];\n                    }else if(dp[nx][ny]==dp[x][y]){\n                        pre[nx][ny] = max(pre[nx][ny],pre[x][y]);\n                    }\n                }\n            }\n        }\n    }\n\n//    cout << \"--table--\"<< endl;\n//    for(int i=1247;i<=1251;i++){\n//        cout << i << \" \";\n//        for(int j=778;j<=782;j++){\n//            printf(\"%07d \",table[i][j]);\n//        }\n//        puts(\"\");\n//    }\n//\n//    cout << \"--vis--\" << endl;\n//\n//    for(int i=1247;i<=1251;i++){\n//        cout << i << \" \";\n//        for(int j=778;j<=782;j++){\n//            cout << \"      \" << vis[i][j] << \" \";\n//        }\n//        puts(\"\");\n//    }\n//\n//    cout << \"--pre--\" << endl;\n//    for(int i=1247;i<=1251;i++){\n//        cout << i << \" \";\n//        for(int j=778;j<=782;j++){\n//            printf(\"%07d \",pre[i][j]);\n//        }\n//        puts(\"\");\n//    }\n//\n//\n//    cout << \"--dp--\" << endl;\n//    for(int i=1247;i<=1251;i++){\n//        cout << i << \" \";\n//        for(int j=778;j<=782;j++){\n//            printf(\"%07d \",dp[i][j]);\n//        }\n//        puts(\"\");\n//    }\n\n    int ans=-1;\n    for(int i=0;i<1500;i++) for(int j=0;j<1500;j++){\n        ans=max(ans,dp[i][j]);\n    }\n    if(ans==0){\n        cout << ans << \" \" << 0 << endl;\n        return;\n    }\n\n    int p=-1;\n    for(int i=0;i<1500;i++) for(int j=0;j<1500;j++){\n        if(ans==dp[i][j]){\n//            cout << i <<\" \" << j << \" \" << table[i][j] << \" \" << pre[i][j] << endl;\n            p=max(p,pre[i][j]);\n        }\n    }\n    cout << ans << \" \" << p << endl;\n}\n\nint main(){\n    int x=750,y=750;\n    int dir=1;\n    int cnt=0;\n    int upper=1;\n    bool f=false;\n    for(int i=1;i<=1000000;i++){\n        if(x<0 or x>=1500 or y<0 or y>=1500){\n            cout << x << \" \" << y << endl;\n            return 0;\n        }\n        table[x][y]=i;\n        x+=dx[dir];\n        y+=dy[dir];\n        cnt++;\n        if(cnt==upper){\n            cnt=0;\n            dir = (dir+1) % 4;\n            if(f){\n                upper++;\n                f=false;\n            }else{\n                f=true;\n            }\n        }\n    }\n\n    is_prime = vector<bool>(1000001,true);\n    is_prime[0]=false;\n    is_prime[1]=false;\n    for(int i=0;i<=1000000;i++){\n        if(!is_prime[i]) continue;\n        for(int j=2;i*j<=1000000;j++){\n            is_prime[i*j] = false;\n        }\n    }\n\n    // m : number of all\n    // n : from n\n    while(cin>>m>>n){\n        if(m==0 and n==0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e18\n#define int long long\n#define Rep(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) Rep(i, 0, n)\n#define all(a) (a).begin(), (a).end()\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int mod = 1000000007;\n\n#define SIZE 2000\n#define MAX_P 1000010\n\nint n, m;\nint cave[SIZE][SIZE];\nP dp[SIZE][SIZE];\nbool is_prime[MAX_P], vis[SIZE][SIZE];\n\nvoid sieve()\n{\n    for (int i = 2; i < MAX_P; i++)\n        is_prime[i] = true;\n    for (int i = 2; i < MAX_P; i++)\n    {\n        if (!is_prime[i])\n            continue;\n        for (int j = 2 * i; j < MAX_P; j += i)\n            is_prime[j] = false;\n    }\n}\nvoid make_cave()\n{\n    int y = 1000, x = 1000, num = 1;\n    cave[y][x] = num;\n    for (int b = 1; num <= MAX_P; b++)\n    {\n        if (b % 2)\n        {\n            rep(i, b) cave[y][++x] = ++num;\n            rep(i, b) cave[--y][x] = ++num;\n        }\n        else\n        {\n            rep(i, b) cave[y][--x] = ++num;\n            rep(i, b) cave[++y][x] = ++num;\n        }\n    }\n}\nP solve(int y, int x)\n{\n    if (vis[y][x])\n        return dp[y][x];\n    vis[y][x] = true;\n    if (cave[y][x] == 0 || cave[y][x] > n)\n        return dp[y][x] = P(0, 0);\n    P res = max(solve(y + 1, x - 1), max(solve(y + 1, x), solve(y + 1, x + 1)));\n    if (is_prime[cave[y][x]])\n    {\n        res.first++;\n        if (res.second == 0)\n            res.second = cave[y][x];\n    }\n    return dp[y][x] = res;\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    sieve();\n    make_cave();\n    while (cin >> n >> m, n)\n    {\n        rep(i, SIZE) rep(j, SIZE) vis[i][j] = false;\n        int x, y;\n        rep(i, SIZE) rep(j, SIZE) if (cave[i][j] == m) y = i, x = j;\n        P ans = solve(y, x);\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint m, n;\nvector<vector<pair<bool, int> > > mp(1001, vector<pair<bool, int> >(1001, pair<bool, int>(false, 0)));\nvector<vector<P> > memo(1001, vector<P>(1001, P(-1, -1)));\nP dfs(P np) {\n\tif(memo[np.first][np.second].first != -1) {\n\t\treturn memo[np.first][np.second];\n\t}\n\tif(mp[np.first][np.second].second > m || np.first < 0 || np.first >= 1001 || np.second < 0 || np.second >= 1001) {\n\t\treturn P(0, 0);\n\t}\n\tP res;\n\tres = max(max(dfs(P(np.first + 1, np.second)), dfs(P(np.first + 1, np.second - 1))), dfs(P(np.first + 1, np.second + 1)));\n\tif(res.first == 0 && res.second == 0) {\n\t\tif(mp[np.first][np.second].first) return memo[np.first][np.second] = P(1, mp[np.first][np.second].second);\n\t\telse return memo[np.first][np.second] = P(0, mp[np.first][np.second].second);\n\t}\n\tif(mp[np.first][np.second].first) {\n\t\treturn memo[np.first][np.second] = P(res.first + 1, res.second);\n\t} else {\n\t\treturn memo[np.first][np.second] = P(res.first, res.second);\n\t}\n}\n\nint main(void) {\n\tvector<bool> prime(1001 * 1001 + 1, true);\n\tprime[0] = prime[1] = false;\n\tFOR(i, 2, 1001 * 1001 + 1) {\n\t\tif(prime[i]) {\n\t\t\tfor(ll j = 2; i * j <= 1001 * 1001; ++j) {\n\t\t\t\tprime[i * j] = false;\n\t\t\t}\n\t\t}\n\t}\n\tP cp = P(500, 500);\n\tll cnt = 1;\n\tll size = 1;\n\tll lim = 1;\n\twhile(cnt <= 1001 * 1001) {\n\t\tmp[cp.first][cp.second].second = cnt;\n\t\tif(prime[cnt]) mp[cp.first][cp.second].first = true;\n\t\t--lim;\n\t\tif(lim == 0) {\n\t\t\tsize += 2;\n\t\t\t++cp.second;\n\t\t\tlim = size * size - (size - 2) * (size - 2);\n\t\t} else {\n\t\t\tif(lim >= 2 * (size - 1) + size) {\n\t\t\t\t--cp.first;\n\t\t\t} else if(lim >= (size - 1) + size) {\n\t\t\t\t--cp.second;\n\t\t\t} else if(lim >= size) {\n\t\t\t\t++cp.first;\n\t\t\t} else {\n\t\t\t\t++cp.second;\n\t\t\t}\n\t\t}\n\t\t++cnt;\n\t}\n\twhile(true) {\n\t\tcin>>m>>n;\n\t\tif(m == 0 && n == 0) break;\n\t\tP sp;\n\t\tbool upd = false;\n\t\tREP(i, 1001) {\n\t\t\tREP(j, 1001) {\n\t\t\t\tif(mp[i][j].second == n) {\n\t\t\t\t\tsp.first = i;\n\t\t\t\t\tsp.second = j;\n\t\t\t\t\tupd = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(upd) break;\n\t\t}\n\t\tREP(i, 1001) {\n\t\t\tREP(j, 1001) {\n\t\t\t\tmemo[i][j].first = memo[i][j].second = -1;\n\t\t\t}\n\t\t}\n\t\tP ans = dfs(sp);\n\t\tif(ans.first == 0) cout<<0<<\" \"<<0<<endl;\n\t\telse cout<<ans.first<<\" \"<<ans.second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cstdio>\n#include <cmath>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define fr first\n#define sc second\n#define mp make_pair\n\ntypedef long long int64;\ntypedef pair< int, int > iP;\ntypedef pair< iP, int > iiP;\n\nconst int INF = 2 << 28;\nconst double EPS = 1e-10;\n\n#define MAX 1000000\n#define NEXT(d) ((d) % 4)\n\nint mas[2000][2000];\niP idx[MAX + 1];\nvector< bool > isP(MAX + 1, true);\n\nvoid makePrime() {\n    isP[0] = isP[1] = false;\n    for(int i = 2; i * i <= MAX; i++)\n        for(int j = i + i; j <= MAX; j += i)\n            isP[j] = false;\n}\n\nvoid makeMap() {\n    //> ^ < v\n    int x = 1000, y = 1000;\n    int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n    int dir = 0;\n    for(int i = 1; i <= MAX; i++) {\n        mas[y][x] = i;\n        idx[i] = iP(y, x);\n        x += dx[dir], y += dy[dir];\n        if(!mas[y + dy[NEXT(dir + 1)]][x + dx[NEXT(dir + 1)]]) dir = NEXT(dir + 1);\n    }\n}\n\nint M;\niP dp[MAX + 1];\n\niP rec(int now) {\n    int x = idx[now].sc, y = idx[now].fr;\n    if(mas[y][x] > M || !mas[y][x]) return iP(0, 0);\n    if(dp[now].fr) return dp[now];\n    iP ret = iP(0, 0);\n    int dx[] = {-1, 0, 1}, dy[] = {1, 1 ,1};\n    for(int i = 0; i < 3; i++) {\n        int nx = x + dx[i], ny = y + dy[i];\n        ret = max(ret, rec(mas[ny][nx]));\n    }\n    if(!ret.sc && isP[mas[y][x]]) ret.sc = mas[y][x];\n    return dp[now] = iP(ret.fr + isP[mas[y][x]], ret.sc);\n}\n\nint main() {\n\n    makePrime();\n    makeMap();\n\n    int n;\n    while(cin >> M >> n, M) {\n        fill_n(dp, MAX + 1, iP(0, 0));\n        iP ans = rec(n);\n        cout << ans.fr << \" \" << ans.sc << endl;;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\nconst int N=1000000;\n\ntypedef pair<int,int> pi;\n\n//?????£??????????????±\nint field[1000][1000]={0};\n//??????(??°????????§?¨?)\npi im[N+1];\n//?´???°????????????\nbool prime[N+1];\n\nint n,m;\n\n//?????§???\nint dp[N+1];\n//????????¨???????????????????????????????´???°\nint last[N+1];\n\nbool inline in(int x, int y)\n{\n    return (0<=x&&x<1000 && 0<=y&&y<1000);\n}\n\nint dfs(int v)\n{\n    if(dp[v]>=0) return dp[v];\n\n    int ret=0;\n    int x=im[v].se;\n    int y=im[v].fi;\n\n    int t[3];\n    memset(t,-1,sizeof(t));\n\n    rep(i,3)\n    {\n        if(in(y+1,x+i-1) && field[y+1][x+i-1]<=m)\n            t[i]=dfs(field[y+1][x+i-1]);\n    }\n\n    ret=max({0,t[0],t[1],t[2]});\n    rep(i,3)\n    {\n        if(ret==t[i]) last[v]=max(last[v],last[field[y+1][x+i-1]]);\n    }\n\n    if(prime[v])\n    {\n        ++ret;\n        if(ret==1) last[v]=v;\n    }\n\n    return dp[v]=ret;\n}\n\nint main()\n{\n    //?´???°??¨??????\n    fill(prime,prime+N+1,true);\n    prime[0]=prime[1]=false;\n    for(int i=2; i<=N; ++i)\n    {\n        if(prime[i]) for(int j=2; i*j<=N; ++j) prime[i*j]=false;\n    }\n\n    //?????£???????????????\n    int h=0,w=0;\n    int dir=0;\n    int dh[4]={0,1,0,-1}, dw[4]={1,0,-1,0};\n    for(int i=N; i>0; --i)\n    {\n        field[h][w]=i;\n        im[i]=pi(h,w);\n        h+=dh[dir];\n        w+=dw[dir];\n        if(!in(h,w) || field[h][w]>0)\n        {\n            h-=dh[dir];\n            w-=dw[dir];\n            dir=(dir+1)%4;\n            h+=dh[dir];\n            w+=dw[dir];\n        }\n    }\n\n    while(scanf(\" %d %d\", &m, &n),m|n)\n    {\n        memset(dp,-1,sizeof(dp));\n        memset(last,0,sizeof(last));\n        int ans=dfs(n);\n        printf(\"%d %d\\n\", ans, last[n]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1189&lang=jp\n\n#include<iostream>\n#include<fstream>\n#include<math.h>\n\n//#define MAX 1020000\n\n#define MAX 1002\n\nint n, first;\nint a[MAX][MAX] = {};\nstatic bool initial;\n\nclass Pair{\npublic:\n\tint count;\n\tint last;\n\tPair operator + (Pair p){//\t@Override (+)\n\t\tthis->count += p.count;\n\t\tif (p.last != 0)this->last = p.last;\n\t\treturn *this;\n\t}\n\tvoid setPair(int _x, int _y){\n\t\tcount = _x;\n\t\tlast = _y;\n\t}\n};\n\nPair pair(int a, int b){\n\tPair p;\n\tp.setPair(a, b);\n\treturn p;\n}\n\nbool isPrime(int n){\n\tif (n == 1)return false;\n\tif (n == 2)return true;\n\tif (n % 2 == 0)return false;\n\n\tfor (int i = 3; i * i <= n; i += 2){\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\n\nPair search(int y, int x){\n\tstatic Pair p[MAX*MAX];\n\n\tPair u_right = pair(-10, 0);\n\tPair u_left = pair(-10, 0);\n\n\tstatic bool isReached[MAX*MAX];\n\n\n\tif (initial){//?????????\n\t\tfor (int i = 0; i < MAX*MAX; i++){\n\t\t\tisReached[i] = false;\n\t\t\tp[i].count = p[i].last = 0;\n\t\t}\n\t\tinitial = false;\n\t}\n\n\tif (n < a[y][x] || a[y][x] == 0)\n\t\treturn p[0];//??????????¶???????????????´???,,, p[0].count = p[0].last = 0\n\n\t//??\\??????????????????\n\tif (a[y][x] == 2){\n\t\tp[2].last = 2;\n\t\tif (a[y][x] == first)initial = true;\n\t\treturn pair(1, 2) + search(y + 1, x);\n\t}\n\n\tif (n <= 6 && a[y][x] == 3){\n\t\tp[3].last = 2;\n\t\tif (a[y][x] == first)initial = true;\n\t\treturn pair(2, 2);\n\t}\n\tif (a[y][x] == 4){\n\t\tif (u_right.count == -10)u_right = search(y + 1, x + 1);\n\t\tif (u_left.count == -10)u_left = search(y + 1, x);\n\n\t\tif (u_right.count == u_left.count){\n\t\t\tif (u_right.last < u_left.last)u_right.count--;\n\t\t}\n\t\tif (u_right.count < u_left.count){\n\t\t\tisReached[4] = true;\n\t\t\tif (a[y][x] == first)initial = true;\n\t\t\treturn p[4] = p[4] + u_left;\n\t\t}\n\t\telse{\n\t\t\tisReached[4] = true;\n\t\t\tif (a[y][x] == first)initial = true;\n\t\t\treturn p[4] = p[4] + u_right;\n\t\t}\n\t}\n\t//???????????§????????????\n\n\t//??¶??°??????\n\tif (a[y][x] % 2 == 0){\n\t\tif (a[y][x] == first){\n\t\t\tinitial = true;\n\t\t\tif (n == first)return p[a[y][x]] = search(y + 1, x + 1) + search(y + 1, x - 1);// +p[a[y + 1][x - 1]];\n\t\t}\n\treturn p[a[y + 1][x]] = search(y + 1, x);\n\t}\n\n\t//?????????\n\tif (isReached[a[y][x]]){\n\t\tif (a[y][x] == first)initial = true;\n\t\treturn p[a[y][x]];\n\t}\n\n\tif (u_right.count == -10)u_right = search(y + 1, x + 1);//under.right????¨????\n\tif (u_left.count == -10)u_left = search(y + 1, x - 1);//under.left????¨????\n\n\t//?´???°??????\n\tif (isPrime(a[y][x])){\n\t\tp[a[y][x]].count = 1;\n\t\tp[a[y][x]].last = a[y][x];\n\t}\n\n\tif (u_right.count == u_left.count){\n\t\tif (u_right.last < u_left.last)u_right.count--;\n\t}\n\t//left?????????????????§?????????\n\tif (u_right.count < u_left.count){\n\t\tisReached[a[y][x]] = true;\n\t\tif (a[y][x] == first)initial = true;//???????????\\??£????????????????¬??????????????????????\n\t\treturn p[a[y][x]] = p[a[y][x]] + u_left;\n\t}\n\t//right?????????????????§?????????\n\telse{\n\t\tisReached[a[y][x]] = true;\n\t\tif (a[y][x] == first)initial = true;//???????????\\??£????????????????¬??????????????????????\n\t\treturn p[a[y][x]] = p[a[y][x]] + u_right;\n\t}\n}\n\nint main(){\n\n\tusing namespace std;\n\n\tint x = MAX / 2;\n\tint y = MAX / 2;\n\tint N = 1;\n\ta[MAX / 2][MAX / 2] = 1;\n\n\tfor (int i = 0; i < MAX*MAX; i++){\n\n\t\tfor (int n = 0; n < (int)sqrt((double)N); n++){\n\t\t\ta[y][x] = N;\n\t\t\tN++;\n\t\t\tx++;\n\t\t}\n\t\tif (N >= (MAX)*(MAX))break;\n\t\tfor (int n = 0; n < (int)sqrt((double)N); n++){\n\t\t\ta[y][x] = N;\n\t\t\tN++;\n\t\t\ty--;\n\t\t}\n\t\tif (N >= (MAX)*(MAX))break;\n\t\tfor (int n = 0; n < (int)sqrt((double)N); n++){\n\t\t\ta[y][x] = N;\n\t\t\tN++;\n\t\t\tx--;\n\t\t}\n\t\tif (N >= (MAX)*(MAX))break;\n\t\tfor (int n = 0; n < (int)sqrt((double)N); n++){\n\t\t\ta[y][x] = N;\n\t\t\tN++;\n\t\t\ty++;\n\t\t}\n\t\tif (N >= (MAX)*(MAX))break;\n\t}\n\n\t//ifstream fin;\n\t//fin.open(\"input.txt\");\n\n\twhile (true){\n\t\tcin >> n >> first;\n\t\tif (n == 0)break;\n\n\t\tinitial = true;\n\n\t\tfor (int i = 0; i < MAX; i++){\n\t\t\tfor (int j = 0; j < MAX; j++){\n\t\t\t\tif (a[i][j] == first){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tPair p = search(y, x);\n\n\t\tcout << p.count << \" \" << p.last << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int MAX = 1500;\nconst int MAX2 = 1000000;\nconst int dy[4] = {0,-1,0,1};\nconst int dx[4] = {1,0,-1,0};\n\nint n,m,G[MAX][MAX];\nbool isPrime[MAX2+1];\nP pos[MAX2+1];\n\nbool check(int y, int x){\n  if(y < 0 || y >= MAX) return false;\n  if(x < 0 || x >= MAX) return false;\n  if(G[y][x] > m) return false;\n  return true;\n}\n\nvoid makeP(){\n  fill(isPrime, isPrime+MAX2+1, true);\n  isPrime[0] = isPrime[1] = false;\n  for(int i=2;i<=MAX2;i++){\n    if(isPrime[i]){\n      for(int j=i*2;j<=MAX2;j+=i) isPrime[j] = false;\n    }\n  }\n}\n\nvoid makeG(){\n  int y = MAX / 2, x = MAX / 2, step = 0;\n  fill(G[0],G[MAX],0);\n  for(int i=1;i<=MAX2;){\n    for(int j=0;j<4;j++){\n      if(j % 2 == 0) step++;\n      for(int k=0;k<step;k++){\n        pos[i] = P(x,y);\n        G[y][x] = i++;\n        y += dy[j];\n        x += dx[j];\n      }\n    }\n  }\n}\n\nint dp[MAX][MAX],dp2[MAX][MAX];\n\nvoid solve(){\n  int ans=0, ans2=0;\n  fill(dp[0],dp[MAX],-1);\n  fill(dp2[0],dp2[MAX],0);\n  dp[pos[n].second][pos[n].first] = isPrime[n];\n  if(isPrime[n]) dp2[pos[n].second][pos[n].first] = n;\n\n  for(int i=pos[n].second;i<MAX;i++){\n    for(int j=0;j<MAX;j++){\n      if(dp[i][j] == -1) continue;\n\n      if(ans < dp[i][j]){\n        ans = dp[i][j];\n        ans2 = dp2[i][j];\n      } else if(ans == dp[i][j]) ans2 = max(ans2, dp2[i][j]);\n\n      for(int k=-1;k<=1;k++){\n        int ny = i + 1;\n        int nx = j + k;\n        if(check(ny,nx)){\n          if(dp[ny][nx] < dp[i][j] + (int)isPrime[G[ny][nx]]){\n            dp[ny][nx] = dp[i][j] + isPrime[G[ny][nx]];\n            if(isPrime[G[ny][nx]]) dp2[ny][nx] = G[ny][nx];\n            else dp2[ny][nx] = dp2[i][j];\n          } else if(dp[ny][nx] == dp[i][j] + (int)isPrime[G[ny][nx]]){\n            if(isPrime[G[ny][nx]]) dp2[ny][nx] = max(dp2[ny][nx], G[ny][nx]);\n            else dp2[ny][nx] = max(dp2[ny][nx], dp2[i][j]);\n          }\n        }\n      }\n    }\n  }\n  cout << ans << ' ' << ans2 << endl;\n}\n\nint main(){\n  makeP();\n  makeG();\n  while(cin >> m >> n && (n|m)) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <vector>\nusing namespace std;\n\n#define dump(x) (cerr << #x << \" = \" << (x) << endl)\n#define dump2(x, y) (cerr << \"(\" << #x << \", \" << #y << \") = (\" << (x) << \", \" << (y) << \")\" << endl)\n\n#define REP(i, a, b) for (int i = (a); i < (b); i++)\n#define REPI(i, a, b) for (int i = (a); i <= (b); i++)\n#define rep(i, n) REP(i, 0, n)\n#define repi(i, n) REPI(i, 0, n)\n\n#define ALL(v) v.begin(), v.end()\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\nconst int MAX = 1010;\nconst int HALF = MAX / 2;\nconst int LIMIT = 1000000;\n\nint x, y;\nint field[MAX][MAX];\nint dp[MAX][MAX];\nint lp[MAX][MAX];\n\nvector<bool> sieve(int n) {\n\tvector<bool> prime(n, true);\n\tprime[0] = prime[1] = false;\n\tfor(int i = 2; i < n; ++i) {\n\t\tif(prime[i]) {\n\t\t\tfor(int j = i * 2; j < n; j += i)\n\t\t\t\tprime[j] = false;\n\t\t}\n\t}\n\treturn prime;\n}\n\nvoid make_field() {\n\tconst int INF = 0xfffffff;\n\tfill(field[0], field[0] + MAX * MAX, INF);\n\tfield[HALF][HALF] = 1;\n\tx = HALF + 1;\n\ty = HALF;\n\tfor(int num = 2, d = 0; num <= LIMIT; ++num) {\n\t\tfield[y][x] = num;\n\t\tconst int left = (d + 1) % 4;\n\t\tif(field[y + dy[left]][x + dx[left]] == INF)\n\t\t\td = left;\n\n\t\tx += dx[d];\n\t\ty += dy[d];\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tvector<bool> is_prime = sieve(LIMIT + 1);\n\tmake_field();\n\n\tfor(int m, n; cin >> m >> n, m;) {\n\t\tint mnX = MAX, mnY = MAX, mxX = -1, mxY = -1;\n\t\tfor(int i = 0; i < MAX; ++i) {\n\t\t\tfor(int j = 0; j < MAX; ++j) {\n\t\t\t\tif(field[i][j] <= m) {\n\t\t\t\t\tmnX = min(mnX, j);\n\t\t\t\t\tmnY = min(mnY, i);\n\t\t\t\t\tmxX = max(mxX, j);\n\t\t\t\t\tmxY = max(mxY, i);\n\n\t\t\t\t\tif(field[i][j] == n) {\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tmemset(lp, -1, sizeof(lp));\n\t\tdp[y][x] = 0;\n\t\tfor(; y <= mxY; ++y) {\n\t\t\tfor(; x <= mxX; ++x) {\n\t\t\t\tif(field[y][x] > m || dp[y][x] == -1)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif(is_prime[field[y][x]]) {\n\t\t\t\t\t++dp[y][x];\n\t\t\t\t\tlp[y][x] = field[y][x];\n\t\t\t\t}\n\n\t\t\t\tfor(int k = -1; k <= 1; ++k) {\n\t\t\t\t\tif(dp[y + 1][x + k] < dp[y][x]) {\n\t\t\t\t\t\tdp[y + 1][x + k] = dp[y][x];\n\t\t\t\t\t\tlp[y + 1][x + k] = lp[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tx = mnX;\n\t\t}\n\n\t\tint mx = 0, last = -1;\n\t\tfor(x = mnX; x <= mxX; ++x) {\n\t\t\ty = mxY;\n\t\t\tif(field[y][x] > m) {\n\t\t\t\t--y;\n\t\t\t}\n\n\t\t\tif(mx < dp[y][x] || (mx == dp[y][x] && last < lp[y][x])) {\n\t\t\t\tmx = dp[y][x];\n\t\t\t\tlast = lp[y][x];\n\t\t\t}\n\t\t}\n\n\t\tif(mx == 0)\n\t\t\tcout << \"0 0\" << endl;\n\t\telse\n\t\t\tcout << mx << \" \" << last << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE * SIZE + 1];\n\tint table[SIZE][SIZE];\n\tint dp[SIZE][SIZE];\n\tint pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tint res1, res2;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d %d\", &m, &n);\n\t\tif (m == 0 || n == 0)return 0;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = SIZE - 1;i >= 0;i--){\n\t\t\tfor(int j = SIZE - 1;j >= 0;j--){\n\t\t\t\tif (table[i][j] <= m) {\n\t\t\t\t\tif (i + 1 < SIZE) {\n\t\t\t\t\t\tif (j > 0 && table[i + 1][j - 1] <= m && (dp[i][j] < dp[i + 1][j - 1] || (dp[i][j] == dp[i + 1][j - 1] && pr[i][j] < pr[i + 1][j - 1]))) {\n\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j - 1];\n\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j - 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (table[i + 1][j] <= m && (dp[i][j] < dp[i + 1][j] || (dp[i][j] == dp[i + 1][j] && pr[i][j] < pr[i + 1][j]))) {\n\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j];\n\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j + 1 < SIZE && table[i + 1][j + 1] <= m && (dp[i][j] < dp[i + 1][j + 1] || (dp[i][j] == dp[i + 1][j + 1] && pr[i][j] < pr[i + 1][j + 1]))) {\n\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j + 1];\n\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!prime[table[i][j]]) {\n\t\t\t\t\t\tdp[i][j]++;\n\t\t\t\t\t\tif (pr[i][j] == 0) {\n\t\t\t\t\t\t\tpr[i][j] = table[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tscanf(\"%d %d\\n\", dp[i][j], pr[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<map>\n#include<cmath>\nusing namespace std;\n#define fr first\n#define sc second\nconst int dy[] = { 0, -1, 0, 1}, dx[] = { 1, 0, -1, 0}; //右上左下\ntypedef pair< int , int > Pt;\nint m,n,mas[1005][1005],hw = 1000;\nPt buff[1000001],max_cost[1005][1005];\nbool prime[1000001];\nvoid Prime_set(){\n  prime[1] = true;\n  for(int i = 2 ; i * i < 1000001 ; i++ ){\n    if(!prime[i]) for(int j = i + i ; j < 1000001 ; j += i ) prime[j] = true;\n  }\n}\nbool isover(int y,int x){\n  return x < 0 || !mas[y][x] || mas[y][x] > m;\n}\nvoid make_map(){\n  fill_n(*mas,1005*1005,0);\n  int cnt = 1,muki = 3;\n  Pt now = Pt( hw / 2,  hw / 2),St;\n  while(cnt <= 1000000){\n    buff[cnt] = Pt(now.fr,now.sc);\n    mas[now.fr][now.sc] = cnt++;\n    Pt magaru = Pt( now.fr + dy[(muki + 1) % 4], now.sc + dx[(muki + 1) % 4]);\n    if(!mas[magaru.fr][magaru.sc]) muki = (muki + 1) % 4, now = magaru;\n    else now.fr += dy[muki], now.sc += dx[muki];\n  }\n}\nPt dfs(Pt now){\n  if(max_cost[now.fr][now.sc] != Pt(-1,-1)) return max_cost[now.fr][now.sc];\n  Pt ret = Pt();\n  for(int i = 0 ; i < 3 ; i++ ){\n    int nx = now.sc + dx[i];\n    if(!isover(now.fr+1,nx)) ret = max(ret,dfs(Pt(now.fr+1,nx)));\n  }\n  if(!ret.sc && !prime[mas[now.fr][now.sc]]) ret.sc = mas[now.fr][now.sc];\n  return max_cost[now.fr][now.sc] = Pt(ret.fr+!prime[mas[now.fr][now.sc]],ret.sc);\n}\nint main(){\n  Prime_set();\n  make_map();\n  while(cin >> m >> n , m){\n    fill_n(*max_cost,1005*1005,Pt(-1,-1));\n    Pt ans = dfs(buff[n]);\n    cout << ans.fr << \" \" << ans.sc << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\n\nint M,N;\n\nint num[1100][1100];\nint ans[1100][1100];\nint ma[1100][1100];\n\nconst int MAX_N=1e6;\n\nbool isprime[MAX_N+1];\n\nvoid prime(){\n    for(int i=1;i<=MAX_N;i++) isprime[i]=true;\n    isprime[1]=false;\n    for(int i=2;i<=MAX_N;i++){\n        if(isprime[i]){\n            for(int j=2;i*j<=MAX_N;j++){\n                isprime[i*j]=false;\n            }\n        }\n    }\n}\n\nvoid init(){\n    int cnt=1;\n    int x=550,y=550;\n    num[x][y]=cnt;\n    cnt++;\n    int len=1;\n    bool changeLen=false;\n    char dir='R';\n    while(cnt<MAX_N){\n        int dx=0,dy=0;\n        char ndir;\n        if(dir=='R'){\n            dy++;\n            ndir='U';\n        }else if(dir=='L'){\n            dy--;\n            ndir='D';\n        }else if(dir=='U'){\n            dx++;\n            ndir='L';\n        }else if(dir=='D'){\n            dx--;\n            ndir='R';\n        }\n\n        int nx=x,ny=y;\n        for(int k=0;k<len;k++){\n            if(cnt>MAX_N) break;\n            nx+=dx;\n            ny+=dy;\n            num[nx][ny]=cnt;\n            cnt++;\n        }\n        dir=ndir;\n        x=nx;\n        y=ny;\n        if(changeLen){\n            len++;\n            changeLen=false;\n        }else{\n            changeLen=true;\n        }\n    }\n}\n\nvoid solve(){\n    for(int i=0;i<1100;i++){\n        for(int j=0;j<1100;j++){\n            ans[i][j]=-1;\n            ma[i][j]=0;\n        }\n    }\n\n    int resa=0,resb=0,resma=0;\n    for(int i=1090;i>=0;i--){\n        for(int j=0;j<=1090;j++){\n            if(num[i][j]==0) continue;\n            if(num[i][j]>M) continue;\n            int nxma=0,nxans=0;\n            bool path=false;\n            for(int k=-1;k<=1;k++){\n                if(ans[i+1][j+k]==-1) continue;\n\n                path=true;\n                if(nxans<ans[i+1][j+k]){\n                    nxans=ans[i+1][j+k];\n                    nxma=ma[i+1][j+k];\n                }else if(nxans==ans[i+1][j+k]){\n                    nxma=max(nxma,ma[i+1][j+k]);\n                }\n            }\n\n            if(!path&&num[i][j]!=N) continue;\n\n            if(isprime[num[i][j]]){\n                nxans++;\n                nxma=num[i][j];\n            }\n            ans[i][j]=nxans;\n            ma[i][j]=nxma;\n\n            if(resa<nxans){\n                resa=nxans;\n                resma=nxma;\n                resb=num[i][j];\n            }else if(resa==nxans){\n                if(resma<nxma){\n                    resma=nxma;\n                    resb=num[i][j];\n                }\n            }\n        }\n    }\n\n    cout<<resa<<\" \"<<resb<<endl;\n}\n\nint main(){\n  init();\n  prime();\n  while(1){\n      cin>>M>>N;\n      if(M==0&&N==0) break;\n      solve();\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\nusing namespace std;\n#define MAX 1000005\nint F[MAX]={0},i,j,p=0,N,M,C[1005][1005],pos[MAX][2],dp[MAX],t,nc;\ntypedef struct D{int c,np,now;}D;\n\nvoid dbg()\n{\n\tint py=1005/2,px=1005/2,mv[5]={-1,0,1,0,-1};\n\tfor(int i=py-3;i<=py+3;i++,puts(\"\"))\n\t\tfor(int j=px-3;j<=px+3;j++)\n\t\t\tprintf(\"%2d \",C[i][j]);\n}\n\nvoid set(int n,int y,int x){C[y][x]=n;pos[n][0]=y;pos[n][1]=x;}\n\nvoid vortex()\n{\n\tint i,j,pre,nx,ny,mv[5]={-1,0,1,0,-1};\n\tmemset(C,0x7f,sizeof(C));\n\tnx=1005/2;ny=1005/2;\n\tset(1,ny,nx);\n\tnx++;\n\tset(2,ny,nx);\n\tfor(i=3,pre=i-1;i<MAX;pre=i++)\n\t{\n\t\tfor(j=0;j<4;j++)\n\t\t{\n\t\t\tif(C[ny+mv[j]][nx+mv[j+1]]==pre-1)\n\t\t\t\tbreak;\n\t\t}\n\t\tfor(;C[ny+mv[j]][nx+mv[j+1]]<MAX;)\n\t\t\tj=(j+1)%4;\n\t\tny+=mv[j];\n\t\tnx+=mv[j+1];\n\t\tset(i,ny,nx);\n\t}\n}\n\nint main()\n{\n\tfor(i=2;i<MAX;i++)\n\t\tif(!F[i])\n\t\t{\n\t\t\tfor(j=i*2;j<MAX;j+=i)\n\t\t\t\tF[j]=1;\n\t\t}\n\tvortex();\n\tfor(;scanf(\"%d%d\",&M,&N),N+M;)\n\t{\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tqueue<D>Q;\n\t\tD tmp={!F[N],(!F[N])?N:0,N},r=tmp;\n\t\tQ.push(tmp);\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\ttmp=Q.front();Q.pop();\n\t\t\tif(r.c<tmp.c||(tmp.c==r.c&&tmp.np>r.np))\n\t\t\t\tr=tmp;\n\t\t\tif(tmp.c<dp[tmp.np])continue;\n\t\t\tdp[tmp.now]=tmp.c;\n\t\t\tfor(i=-1;i<2;i++)\n\t\t\t{\n\t\t\t\tt=C[pos[tmp.now][0]+1][pos[tmp.now][1]+i];\n\t\t\t\tif(t<=M&&dp[t]<tmp.c+(!F[t]))\n\t\t\t\t{\n\t\t\t\t\tD ins={tmp.c+(!F[t]),!F[t]&&t>tmp.np?t:tmp.np,t};\n\t\t\t\t\tdp[t]=ins.c;\n\t\t\t\t\tQ.push(ins);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",r.c,r.np);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(5)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef complex<double> Point;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 100000007;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator > (const edge& e) const { return cost > e.cost; }\n};\n\nbool prime[1111111];\nvector<int> primes;\nvoid hurui()\n{\n\tmemset(prime, true, sizeof(prime));\n\tprime[0] = prime[1] = false;\n\n\tfor (int i = 2; i*i < 110000; i++)\n\t{\n\t\tfor (int j = 2; i*j < 1100000; j++)\n\t\t{\n\t\t\tprime[i*j] = false;\n\t\t}\n\t}\n\tREP(i, 1100000)\n\t{\n\t\tif (prime[i]) primes.push_back(i);\n\t}\n}\nint n, m;\nint sx, sy;\nvector<vector<int>> fld;\nP dp[1111][1111];\nint num[1005][1005];\n\nint main()\n{\n\thurui();\n\twhile (cin >> m >> n, m)\n\t{\n\t\tfld.clear();\n\t\tfld.resize(1005, vector<int>(1005));\n\t\tint x = 501; int y = 501;\n\t\tint j = 0;\n\t\tint dir = 0;\n\t\tint cnt = 0;\n\t\tint l = 1;\n\t\tFOR(i, 1, m+1)\n\t\t{\n\t\t\tnum[x][y] = i;\n\t\t\tif (i == n)\n\t\t\t{\n\t\t\t\tsx = x; sy = y;\n\t\t\t}\n\t\t\tif (i == primes[j])\n\t\t\t{\n\t\t\t\tj++;\n\t\t\t\tfld[x][y]++;\n\t\t\t}\n\t\t\tif (dir % 4 == 0) y++;\n\t\t\tif (dir % 4 == 1) x--;\n\t\t\tif (dir % 4 == 2) y--;\n\t\t\tif (dir % 4 == 3) x++;\n\t\t\tcnt++;\n\t\t\tif (cnt == l)\n\t\t\t{\n\t\t\t\tdir++;\n\t\t\t\tcnt = 0;\n\t\t\t\tif (dir % 2 == 0) l++;\n\t\t\t}\n\t\t}\n\t\tREP(i, 1111)REP(j, 1111) dp[i][j] = P(0, 0);\n\n\t\tfor (int i = 1004; i >= sx; i--)\n\t\t{\n\t\t\tfor (int j = 1003; j >= 0; j--)\n\t\t\t{\n\t\t\t\tP tmp(-1, -1);\n\t\t\t\tREP(k, 3)\n\t\t\t\t{\n\t\t\t\t\tif (tmp.first<dp[i + 1][j - 1 + k].first\n\t\t\t\t\t\t|| (tmp.first==dp[i+1][j-1+k].first&&tmp.second<dp[i+1][j-1+k].second))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmp = dp[i + 1][j - 1 + k];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdp[i][j].first = fld[i][j] + tmp.first;\n\t\t\t\tif (fld[i][j] > 0)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j].second = num[i][j];\n\t\t\t\t}\n\t\t\t\tdp[i][j].second = max(dp[i][j].second,tmp.second);\n\t\t\t}\n\t\t}\n\t\tcout << dp[sx][sy].first << \" \" << dp[sx][sy].second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n \nconst int MAX = 1000001;\nbool pri[MAX];\nvector<int>v;\nmap<int,pair<int,int> >pos;\nint field[1201][1201];\nint N,M;\n \nvoid make(){\n  int cnt = 2;\n  int c = 1;\n  int x = 500,y=500;\n  int cc = 0;\n  field[500][500] = 1;\n  pos[1] = make_pair(500,500);\n \n  while(cnt < 1000000){\n    for(int i=0; i<4; i++){\n      if(cc == 2){cc = 0; c++;}\n      int nx = x, ny = y;\n      for(int j=0; j<c; j++){\n    nx += dx[i];\n    ny += dy[i];\n    pos[cnt] = make_pair(ny,nx);\n    field[ny][nx] = cnt++;\n      }\n \n      x = nx, y = ny;\n      cc++;\n    }\n  }\n}\n \nvoid createPrime(){\n  fill(pri,pri+MAX,1);\n  pri[0] = pri[1] = 0;\n  for(int i=2; i*i<MAX; i++){\n    for(int j=2*i; j<MAX; j+=i){\n      pri[j] = false;\n    }\n  }\n \n  for(int i=2; i<MAX; i++) if(pri[i]) v.push_back(i);\n}\n \nbool compare(pair<int,int>p, pair<int,int>p2){\n  if(p.first == p2.first){\n    return p.second > p2.second;\n  }\n  return p.first > p2.first;\n}\n \nint main(){\n  make();\n  createPrime();\n \n  while(cin >> M >> N,M|N){\n    pair<int,int> p = pos[N];\n    int sx = p.second, sy = p.first;\n    bool F = false;\n \n    static bool used[1200][1200];\n    static pair<int,int> dp[1200][1200];\n    memset(used,0,sizeof(used));\n    memset(dp,0,sizeof(dp));\n \n    if(binary_search(v.begin(),v.end(),field[sy][sx])){\n      dp[sy][sx].first = 1;\n      dp[sy][sx].second = field[sy][sx];\n    }\n    used[sy][sx] = true;\n \n    for(int i=sy; i<=1000; i++){\n      for(int j=0; j<=1000; j++){\n    for(int k=-1; k<=1; k++){\n      if(!used[i][j])continue;\n      int nx = j + k;\n      if(nx < 0 || nx > 1000)continue;\n      if(field[i+1][nx] > M)continue;\n \n      used[i+1][nx] = true;\n      int value = binary_search(v.begin(),v.end(),field[i+1][nx]);\n       \n      if(value){\n        if(dp[i+1][nx].first < dp[i][j].first + 1){\n          dp[i+1][nx].first = dp[i][j].first + 1;\n          dp[i+1][nx].second = field[i+1][nx];\n        }\n      } else {\n        dp[i+1][nx] = max(dp[i+1][nx],dp[i][j]);\n      }\n    }\n      }\n    }\n \n    vector<pair<int,int> >ans;\n \n    for(int i=0; i<=1000; i++){\n      for(int j=0; j<=1000; j++){\n    if(field[i][j] > M)continue;\n    if(dp[i][j].first == 0)continue;\n    ans.push_back(dp[i][j]);\n      }\n    }\n \n \n    if(ans.size() == 0){cout << \"0 0\" << endl;}\n    else{\n      sort(ans.begin(),ans.end(),compare);\n      cout << ans[0].first << \" \" << ans[0].second << endl;\n    }\n \n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 1000030\n\nenum DIR{\n\tN,\n\tE,\n\tS,\n\tW,\n};\n\nstruct Info{\n\tint row,col;\n};\n\nbool* prime_table;\nint** map;\nInfo* info;\n\n\nint hole_num,start;\nint diff_col[3] = {-1,0,1};\nint diff_row_N[3] = {-1,0,0},diff_col_N[3] = {0,-1,1};\nint diff_row_E[3] = {-1,0,1},diff_col_E[3] = {0,1,0};\nint diff_row_S[3] = {0,0,1},diff_col_S[3] = {-1,1,0};\nint diff_row_W[3] = {-1,0,1},diff_col_W[3] = {0,-1,0};\n\nint dp[2][1101],last[1101];\n\nvoid func(){\n\n\tfor(int i = 0; i < 1101; i++){\n\t\tfor(int k = 0; k < 2; k++)dp[k][i] = -1;\n\t\tlast[i] = -1;\n\t}\n\n\tint row,col,next_col;\n\n\trow = info[start].row;\n\tcol = info[start].col;\n\n\tif(prime_table[start]){\n\t\tdp[1][col] = 1;\n\t\tlast[col] = start;\n\t}else{\n\t\tdp[1][col] = 0;\n\t}\n\n\tbool FLG;\n\n\twhile(true){\n\n\t\tfor(int col = 0; col < 1101; col++){\n\t\t\tdp[0][col] = dp[1][col];\n\t\t}\n\n\t\trow++;\n\n\t\tFLG = false;\n\t\tfor(int col = 0; col < 1101; col++){\n\t\t\tif(dp[0][col] != -1){\n\n\t\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\tnext_col = col + diff_col[i];\n\t\t\t\t\tif(map[row][next_col] > hole_num || map[row][next_col] == -1)continue;\n\n\t\t\t\t\tFLG = true;\n\n\t\t\t\t\tif(prime_table[map[row][next_col]]){\n\t\t\t\t\t\tif(dp[1][next_col] <= dp[0][col]+1){\n\t\t\t\t\t\t\tdp[1][next_col] = dp[0][col]+1;\n\t\t\t\t\t\t\tlast[next_col] = map[row][next_col];\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\n\t\t\t\t\t\tif(dp[1][next_col] < dp[0][col]){\n\t\t\t\t\t\t\tdp[1][next_col] = dp[0][col];\n\t\t\t\t\t\t\tlast[next_col] = last[col];\n\t\t\t\t\t\t}else if(dp[next_col] == dp[col]){\n\t\t\t\t\t\t\tlast[next_col] = max(last[next_col],last[col]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG)break;\n\t}\n\n\tint ans1 = 0,ans2 = 0;\n\n\tfor(int i = 0; i < 1101; i++){\n\t\tif(dp[0][i] > ans1){\n\t\t\tans1 = dp[0][i];\n\t\t\tans2 = last[i];\n\t\t}else if(dp[0][i] == ans1){\n\t\t\tans2 = max(ans2,last[i]);\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\",ans1,ans2);\n\n}\n\nint main(){\n\n\tprime_table = new bool[NUM];\n\n\tfor(int i = 0; i < NUM; i++){\n\t\tprime_table[i] = true;\n\t}\n\n\tint limit = sqrt(NUM);\n\n\tfor(int i = 2; i <= limit; i++){\n\t\tif(prime_table[i]){\n\t\t\tfor(int j = 2*i; j < NUM; j+=i){\n\t\t\t\tprime_table[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tmap = new int*[1101];\n\tfor(int i = 0; i < 1101; i++){\n\t\tmap[i] = new int[1101];\n\t\tfor(int k = 0; k < 1101; k++)map[i][k] = -1;\n\t}\n\n\tmap[550][550] = 1;\n\n\tint row = 550,col = 550,adj_row,adj_col;\n\tint id = 2;\n\tDIR dir = E;\n\n\tbool FLG;\n\n\twhile(id <= NUM){\n\n\t\tFLG = true;\n\t\tswitch(dir){\n\t\tcase N:\n\t\t\trow--;\n\t\t\tmap[row][col] = id++;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tadj_row = row+diff_row_N[i];\n\t\t\t\tadj_col = col + diff_col_N[i];\n\n\t\t\t\tif(map[adj_row][adj_col] != -1){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG)dir = W;\n\n\t\t\tbreak;\n\t\tcase E:\n\t\t\tcol++;\n\t\t\tmap[row][col] = id++;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tadj_row = row+diff_row_E[i];\n\t\t\t\tadj_col = col + diff_col_E[i];\n\n\t\t\t\tif(map[adj_row][adj_col] != -1){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG)dir = N;\n\n\t\t\tbreak;\n\t\tcase S:\n\t\t\trow++;\n\t\t\tmap[row][col] = id++;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tadj_row = row+diff_row_S[i];\n\t\t\t\tadj_col = col + diff_col_S[i];\n\n\t\t\t\tif(map[adj_row][adj_col] != -1){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG)dir = E;\n\n\t\t\tbreak;\n\t\tcase W:\n\t\t\tcol--;\n\t\t\tmap[row][col] = id++;\n\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\tadj_row = row+diff_row_W[i];\n\t\t\t\tadj_col = col + diff_col_W[i];\n\n\t\t\t\tif(map[adj_row][adj_col] != -1){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG)dir = S;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tinfo = (Info*)malloc(sizeof(Info)*(NUM+1));\n\n\tfor(int i = 0; i < 1101; i++){\n\t\tfor(int k = 0; k < 1101; k++){\n\t\t\tif(map[i][k] != -1){\n\t\t\t\tinfo[map[i][k]].row = i;\n\t\t\t\tinfo[map[i][k]].col = k;\n \t\t\t}\n\t\t}\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&hole_num,&start);\n\t\tif(hole_num == 0 && start == 0)break;\n\n\t\tfunc();\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define reps(i,a,n) for(int i=a; i<(n); i++)\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\n\nconst int dx[4] = {1, 0,-1, 0};\nconst int dy[4] = {0,-1, 0, 1};\n\nint  a[4000][4000];\n\nconst int c = 2000;\n\nbool isp[1234567];\n\n\npii p[4000][4000];\nint v[4000][4000];\n\n\n\n\n\nint main(){\n\n\trep(i,1234567) isp[i] = true;\n\tisp[0] = isp[1] = false;\n\trep(i, 1234567){\n\t\tif(!isp[i])continue;\n\t\tfor(int j=i*2; j<1234567; j+=i){\n\t\t\tisp[j] = false;\n\t\t}\n\t}\n\n\n\tfor(;;){\n\t\tint n,m;\n\t\tcin >> n >> m;\n\t\tif(n==0) break;\n\t\t\n\t\trep(i,4000)rep(j,4000) a[i][j] = 0;\n\n\t\ta[c][c] = 1;\n\t\tif(n>1) a[c][c+1] = 2;\n\n\t\tint d = 2;\n\t\tint x = 1;\n\t\tint y = -1;\n\t\treps(i, 3, n+1){\n\t\t\ta[c+y][c+x] = i;\n\t\t\tint X=x;\n\t\t\tint Y=y;\n\t\t\tX += dx[(d+1)%4];\n\t\t\tY += dy[(d+1)%4];\n\t\t\tif(a[c+Y][c+X] == 0){\n\t\t\t\td++; d%=4;\n\t\t\t}\n\t\t\tx += dx[d];\n\t\t\ty += dy[d];\n\t\t}\n/*\n\t\treps(i, -10, 11){\n\t\t\treps(j, -10, 11){\n\t\t\t\tprintf(\"%3d\", a[c+i][c+j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}puts(\"\");\n*/\n\t\trep(i, 4000) rep(j, 4000){\n\t\t\tv[i][j] = -4000;\n\t\t\tif(a[i][j]==m) v[i][j] = 0;\n\t\t}\n/*\n\t\treps(i, -10, 11){\n\t\t\treps(j, -10, 11){\n\t\t\t\tprintf(\"%6d\", v[c+i][c+j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}puts(\"\");\n\t\t*/\n\t\tint ma = -1;\n\t\tint mi = 0;\n\t\treps(i, 1, 3999) reps(j, 1,3999){\n\t\t\tint A = v[i-1][j-1];\n\t\t\tint B = v[i-1][j];\n\t\t\tint C = v[i-1][j+1];\n\t\t\t\n\t\t\tv[i][j] = max(max(max(A,B),C),v[i][j]) + isp[a[i][j]];\n\n\t\t\tif(ma <= v[i][j]){\n\t\t\t\tif(ma != v[i][j]){\n\t\t\t\t\tma = v[i][j];\n\t\t\t\t\tmi = 0;\n\t\t\t\t}\n\t\t\t\tif(isp[a[i][j]]) mi = max(mi,a[i][j]);\n\t\t\t}\n\t\t}\n\t\tcout << ma << \" \"<<mi <<endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\nusing namespace std;\nconst int MAX = 1000000;\nconst int w = 1010;\nconst int center = w/2;\nvector<vector<int> > caves(w,vector<int>(w,-1));\nvector<int> sosuu(MAX+1,1);\nint n;\nint st;\nint stX;\nint stY;\nvoid makeCaves(){\n  caves = vector<vector<int> >(w,vector<int>(w,-1));\n  int dir = 3;//0 右 1 上 2 左 3 下\n  int dx[4] = {1,0,-1,0};\n  int dy[4] = {0,1,0,-1};\n  int x = center;\n  int y = center;\n  caves[x][y] = 1;\n  for(int i = 2;i <= n;i++){\n    int left = (dir+1)%4;\n    if(caves[dx[left]+x][dy[left]+y] == -1){\n      dir = left;\n    }\n    x = x+dx[dir];\n    y = y+dy[dir];\n    caves[x][y] = i;\n    if(i == st){\n      stX = x;\n      stY = y;\n    }\n  }\n}\nvoid makeSosuu(){\n  sosuu[0] = 0;\n  sosuu[1] = 0;\n  for(int i = 2;i <= MAX;i++){\n    if(sosuu[i]){\n      for(int j = i+i;j <= MAX;j = j+i){\n\tsosuu[j] = 0;\n      }\n    }\n  }\n}/*\nvoid dpSearch(vector<vector<par<int,int> > > &dp,int cx,int cy){\n  \n  \n\n  } */\nint main(){\n  // pair<int,int> dp();\n  makeSosuu();\n  while(true){\n    cin >> n >> st;\n    if(n == 0 && st == 0)break;\n    makeCaves();\n    vector<vector<pair<int,int> > > dp(w,vector<pair<int,int> >(w,pair<int,int>(-1,-1)));\n    int dx[3] = {-1,0,1};\n    int dy[3] = {-1,-1,-1};\n    if(sosuu[st]){\n      dp[stX][stY].first = 1;\n      dp[stX][stY].second = st;\n    }else{\n      dp[stX][stY].first = 0;\n      dp[stX][stY].second = 0;\n    }\n    //    cout << stX-center << \" \" << stY-center << endl;\n    pair<int,int> ans;//(dp[stX][stY].first,dp[stX][stY].second);\n    ans = dp[stX][stY];\n    //    cout << ans.first << \" \" << ans.second << endl;\n    for(int i = stY;i > 0;i--){\n      for(int j = 1;j < 1001;j++){\n\tfor(int k = 0;k <3;k++){\n\t  //cout << i << \" \" << j << endl;\n\t  int nx = j+dx[k];\n\t  int ny = i+dy[k];\n\n\t  if(caves[nx][ny] != -1 && dp[j][i].first != -1){\n\t    if(dp[nx][ny].first < dp[j][i].first + sosuu[caves[nx][ny]]){\n\t      dp[nx][ny].first = dp[j][i].first + sosuu[caves[nx][ny]];\n\t      if(sosuu[caves[nx][ny]]){\n\t\tdp[nx][ny].second = caves[nx][ny];\n\t      }else{\n\t\tdp[nx][ny].second = dp[j][i].second;\n\t      }\n\t      if(ans < dp[nx][ny]){\n\t\tans = dp[nx][ny];\n\t      }\n\t    }\n\t  } \n\t} \n      }\n    }\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef complex<int> C;\n\nP dp[2000][2000];\nint field[2000][2000];\nint min_x, max_x, min_y, max_y;\n\nvoid setupField(int m){\n    memset(field, 0, sizeof(field));\n    C dir(1, 0), pos(1000, 1000);\n    int count = 0, len = 1;\n    min_x = max_x = min_y = max_y = 1000;\n\n    for(int i=1;i<=m;i++){\n        min_x = min(min_x, pos.real());\n        max_x = max(max_x, pos.real());\n        min_y = min(min_y, pos.imag());\n        max_y = max(max_y, pos.imag());\n\n        field[pos.imag()][pos.real()] = i;\n        pos += dir;\n        count++;\n        if(count%len == 0){\n            dir *= C(0, -1);\n            if(count == 2*len){\n                len++;\n                count = 0;\n            }\n        }\n    }\n}\n\nint main(){\n    vector<bool> is_prime(1000001, true);\n    is_prime[0] = is_prime[1] = false;\n    for(int i=2;i*i<is_prime.size();i++){\n        if(is_prime[i]){\n            for(int j=i*i;j<is_prime.size();j+=i){\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    while(1){\n        int m, n;\n        cin >> m >> n;\n        if(m == 0) break;\n\n        setupField(m);\n\n        P ans(-1, 0);\n        for(int y=max_y;y>=min_y;y--){\n            for(int x=min_x;x<=max_x;x++){\n                dp[y][x] = P(0, 0);\n                if(field[y+1][x] != 0)dp[y][x] = max(dp[y][x], dp[y+1][x]);\n                if(field[y+1][x+1] != 0) dp[y][x] = max(dp[y][x], dp[y+1][x+1]);\n                if(field[y+1][x-1] != 0) dp[y][x] = max(dp[y][x], dp[y+1][x-1]);\n                if(is_prime[field[y][x]]){\n                    if(dp[y][x].first == 0) dp[y][x].second = field[y][x];\n                    dp[y][x].first++;\n                }\n                if(field[y][x] == n){\n                    ans = dp[y][x];\n                    break;\n                }\n            }\n            if(ans.first != -1) break;\n        }\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nbool isNotPrime[1000200] = {1,1};\nint prime(){\n\tfor(int i = 2;i*i < 1000200;i++){\n\t\tfor(int j = 2*i;j < 1000200;j+=i){\n\t\t\tisNotPrime[j] = 1;\n\t\t}\n\t}\n}\nint sc[1050][1050] = {};\nint dp[1050][1050][2];\n#define T_MAX  1000000\nint main(){\n\tprime();\n\tint c = 502,t = 1;\n\tint x = c,y = c;\n\tint w = -1,h = -1,_w = 1000000,_h = 1000000;\n\tfor(int i = 1;;i+=2){\n\t\t//cout<<t<<endl;\n\t\tfor(int j = 1;j <= i;j++){\n\t\t\tsc[y][x] = t++;\n\t\t\tw = max(x,w);\n\t\t\th = max(y,h);\n\t\t\t_w = min(x,_w);\n\t\t\t_h = min(y,_h);\n\t\t\tx++;\n\t\t\tif(t > T_MAX)goto next;\n\t\t}\n\t\tfor(int j = 1;j <= i;j++){\n\t\t\tsc[y][x] = t++;\n\t\t\tw = max(x,w);\n\t\t\th = max(y,h);\n\t\t\t_w = min(x,_w);\n\t\t\t_h = min(y,_h);\n\t\t\ty--;\n\t\t\t//if(x < 0 || y < 0)cout<<\"!\"<<endl;\n\t\t\tif(t > T_MAX)goto next;\n\t\t}\n\t\tfor(int j = 1;j <= i+1;j++){\n\t\t\tsc[y][x] = t++;\n\t\t\tw = max(x,w);\n\t\t\th = max(y,h);\n\t\t\t_w = min(x,_w);\n\t\t\t_h = min(y,_h);\n\t\t\tx--;\n\t\t\t//if(x < 0 || y < 0)cout<<\"!\"<<endl;\n\t\t\tif(t > T_MAX)goto next;\n\t\t}\n\t\tfor(int j = 1;j <= i+1;j++){\n\t\t\tsc[y][x] = t++;\n\t\t\tw = max(x,w);\n\t\t\th = max(y,h);\n\t\t\t_w = min(x,_w);\n\t\t\t_h = min(y,_h);\n\t\t\ty++;\n\t\t\t//if(x < 0 || y < 0)cout<<\"!\"<<endl;\n\t\t\tif(t > T_MAX)goto next;\n\t\t}\n\t}\n\tnext:;\n\tint m,n;\n\twhile(cin>>m>>n,m){\n\t\tint sx,sy;\n\t\tfor(int i = 0;i < 1050;i++){\n\t\t\tfor(int j = 0;j < 1050;j++){\n\t\t\t\tif(sc[i][j] == n)sy = i,sx = j;\n\t\t\t\tdp[i][j][0] = dp[i][j][1] = -1;\n\t\t\t}\n\t\t}\n\t\tdp[sy][sx][0] = dp[sy][sx][1] = 0;\n\t\tif(!isNotPrime[sc[sy][sx]])dp[sy][sx][0]++,dp[sy][sx][1] = sc[sy][sx];\n\t\tint aval = dp[sy][sx][0],aidx = dp[sy][sx][1];\n\t\tfor(int i = sy;i <= h+1;i++){\n\t\t\tfor(int j = 0;j <= w+1;j++){\n\t\t\t\tif(dp[i][j][0] == -1)continue;\n\t\t\t\tif(sc[i+1][j] != 0 && sc[i+1][j] <= m){\n\t\t\t\t\tint n0 = dp[i][j][0] + !isNotPrime[sc[i+1][j]];\n\t\t\t\t\tint n1 = (!isNotPrime[sc[i+1][j-1]]) ? sc[i+1][j] : dp[i][j][1];\n\t\t\t\t\tif(dp[i+1][j][0] == n0 ? dp[i+1][j][1] < n1 : dp[i+1][j][0] < n0){\n\t\t\t\t\t\tdp[i+1][j][0] = n0;\n\t\t\t\t\t\tdp[i+1][j][1] = n1;\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[i+1][j][0] == aval ? dp[i+1][j][1] > aidx : dp[i+1][j][0] > aval){\n\t\t\t\t\t\taval = dp[i+1][j][0];\n\t\t\t\t\t\taidx = dp[i+1][j][1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(sc[i+1][j-1] != 0 && sc[i+1][j-1] <= m){\n\t\t\t\t\tint n0 = dp[i][j][0] + !isNotPrime[sc[i+1][j-1]];\n\t\t\t\t\tint n1 = (!isNotPrime[sc[i+1][j-1]]) ? sc[i+1][j-1] : dp[i][j][1];\n\t\t\t\t\tif(dp[i+1][j-1][0] == n0 ? dp[i+1][j-1][1] < n1 : dp[i+1][j-1][0] < n0){\n\t\t\t\t\t\tdp[i+1][j-1][0] = n0;\n\t\t\t\t\t\tdp[i+1][j-1][1] = n1;\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[i+1][j-1][0] == aval ? dp[i+1][j-1][1] > aidx : dp[i+1][j-1][0] > aval){\n\t\t\t\t\t\taval = dp[i+1][j-1][0];\n\t\t\t\t\t\taidx = dp[i+1][j-1][1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(sc[i+1][j+1] != 0 && sc[i+1][j+1] <= m){\n\t\t\t\t\tint n0 = dp[i][j][0] + !isNotPrime[sc[i+1][j+1]];\n\t\t\t\t\tint n1 = (!isNotPrime[sc[i+1][j+1]]) ? sc[i+1][j+1] : dp[i][j][1];\n\t\t\t\t\tif(dp[i+1][j+1][0] == n0 ? dp[i+1][j+1][1] < n1 : dp[i+1][j+1][0] < n0){\n\t\t\t\t\t\tdp[i+1][j+1][0] = n0;\n\t\t\t\t\t\tdp[i+1][j+1][1] = n1;\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[i+1][j+1][0] == aval ? dp[i+1][j+1][1] > aidx : dp[i+1][j+1][0] > aval){\n\t\t\t\t\t\taval = dp[i+1][j+1][0];\n\t\t\t\t\t\taidx = dp[i+1][j+1][1];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//cout<<i<<\" \"<<j<<\" \"<<dp[i][j][0]<<\" \"<<dp[i][j][1]<<endl;\n\t\t\t}\n\t\t}\n\t\tcout<<aval<<\" \"<<aidx<<endl;\n\t}\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=x && x<w && 0<=y && y<h)\n\nconst int INF = 10000000;\nint dx[4]={1, 0, -1, 0}, dy[4]={0, 1, 0, -1};\nusing namespace std;\ntypedef pair<int, int> P;\n\n/** Problem1189 : Prime Caves **/\nint caves[1100][1100];\nint dp[1100][1100];\nconst int MAX = 1000100;\nbool prime[MAX];\n\nint main()\n{\n\tint m, n;\n\tconst int dx0[4] = {1, 0, -1, 0}, dy0[4] = {0, -1, 0, 1}, dx1[3]={-1, 0, 1};\n\tint sx, sy;\n\t\n\tfor (int i=0; i<MAX; i++)\n\t\tprime[i] = true;\n\t\n\tprime[0] = false; prime[1] = false;\n\t\n\tfor (int i=2; i<MAX; i++) {\n\t\tif (prime[i]) {\n\t\t\tfor (int j=2; i*j<MAX; j++) {\n\t\t\t\tprime[i*j] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\twhile (cin>>m>>n, m||n) {\n\t\tfill(caves[0], caves[0]+1100*1100, 0);\n\t\tfill(dp[0], dp[0]+1100*1100, -1);\n\t\tint x=1100/2, y=1100/2 , t=1, direct=1;\n\t\tcaves[x][y]=1;\n\t\tcaves[++x][y]=2;\n\t\tint i=2; bool change = true;\n\t\twhile (1) {\n\t\t\trep(j, t) {\n\t\t\t\tx+=dx0[direct]; y+=dy0[direct];\n\t\t\t\tcaves[x][y]=i+1;\n\t\t\t\ti++;\n\t\t\t\tif (i==n) {\n\t\t\t\t\tsx = x; sy = y;\n\t\t\t\t}\n\t\t\t\tif (i>=m) goto end;\n\t\t\t}\n\t\t\tif (change) {\n\t\t\t\tt++;\n\t\t\t\tchange = false;\n\t\t\t} else {\n\t\t\t\tchange=true;\n\t\t\t}\n\t\t\tdirect++; direct%=4;\n\t\t}\n\tend: ;\n\t\tint ans=0, alast=0;\n\n\t\tdp[sx][sy] = prime[caves[sx][sy]];\n\t\tREP(j, 0, 1100) {\n\t\t\tREP(i, 0, 1100) {\n\t\t\t\tans = max(ans, dp[i][j]);\n\t\t\t\t\n\t\t\t\tif (dp[i][j] == -1) continue;\n\t\t\t\tif (caves[i][j] == 0) continue;\n\t\t\t\t\n\t\t\t\trep(k, 3) {\n\t\t\t\t\tint nx=i+dx1[k], ny=j+1;\n\t\t\t\t\tif (!(0<=nx && nx<1100) || ny>=1100) continue;\n\t\t\t\t\tif (caves[nx][ny]==0) continue;\n\n\t\t\t\t\tdp[nx][ny] = max(dp[nx][ny], dp[i][j]+prime[caves[nx][ny]]);\n\n\t\t\t\t\tans = max(ans, dp[nx][ny]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (ans!=0) {\n\t\t\tREP(j, 0, 1100) {\n\t\t\t\tREP(i, 0, 1100) {\n\t\t\t\t\tif (dp[i][j]==ans && prime[caves[i][j]]) {\n\t\t\t\t\t\talast = max(alast, caves[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << \" \" << alast << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n#define t_max 10000001\nchar M[1001][1001];\nchar S[1001][1001];\nchar P[1001][1001];\nchar table[t_max];\nvector<pair<char,char> >m(t_max);\nmap<pair<char,char>,char>m_rev;\npair<int,int> dfs(int x,int y){\n\tif(y==1001)return make_pair(0,0);\n\tif(S[x][y]>=0)return make_pair(S[x][y],P[x][y]);\n\tint m=0,m_place=0,i=-1;\n\tfor(;i<2;i++){\n\t\tif(x+i<0||1000<x+i)continue;\n\t\tpair<int,int> p=dfs(x+i,y+1);\n\t\tif(m<p.first||(m==p.first&&m_place<p.second))m=p.first,m_place=p.second;\n\t}\n\tif(m==0){\n\t\tif(M[x][y])return make_pair(S[x][y]=1,P[x][y]=m_rev[make_pair(x,y)]);\n\t\treturn make_pair(S[x][y]=0,P[x][y]=0);\n\t}else{\n\t\treturn make_pair(S[x][y]=m+M[x][y],P[x][y]=m_place);\n\t}\n}\nmain(){\n\tint k=1,z,x,y,i,n,s;\n\tm[k]=make_pair(x=500,y=500),m_rev[make_pair(x,y)]=k,k++;\n\tfor(z=2;z<=1000;z+=2){\n\t\tx++,y++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(x,--y),m_rev[make_pair(x,y)]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(--x,y),m_rev[make_pair(x,y)]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(x,++y),m_rev[make_pair(x,y)]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(++x,y),m_rev[make_pair(x,y)]=k,k++;\n\t}\n\ttable[0]=table[1]=1;\n\tfor(x=2;x<t_max;x++)if(!table[x])for(y=x*2;y<t_max;y+=x)table[y]=1;\n\tfor(;scanf(\"%d%d\",&n,&s),n;){\n\t\tmemset(M,0,sizeof(M));\n\t\tmemset(S,0xff,sizeof(S));\n\t\tmemset(P,0,sizeof(P));\n\t\tfor(i=1;i<=n;i++)if(!table[i])M[m[i].first][m[i].second]=1;\n\t\tpair<int,int> p=dfs(m[s].first,m[s].second);\n\t\tprintf(\"%d %d\\n\",p.first,p.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <fstream>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppi;\n\n\nconst int dy[]={0,-1,0,1};\nconst int dx[]={1,0,-1,0};\n\n\nbool isPrime[1000100];\nint prime[1000100];\n\nint p;\nvoid erats(){\n  for(int i=0;i<1000100;i++)\n    isPrime[i]=true;\n  p=0;\n  isPrime[0]=isPrime[1]=false;\n  for(int i=2;i<1000100;i++){\n    if(isPrime[i]){\n      prime[p++]=i;\n      for(int j=2*i;j<1000100;j+=i)\n        isPrime[j]=false;\n    }\n  }\n}\n\n\nint N,M;\nmap<pair<short,short> ,int> m;\nmap<int,pair<short,short> > idToPii;\npii dp[1000100];\n\npii dfs(int pos){\n  if(dp[pos].first>=0)return dp[pos];\n  pii res=pii(isPrime[pos],isPrime[pos]?pos:0);\n  for(int i=-1;i<=1;i++){\n    pii nxt=idToPii[pos];\n    nxt.first++;\n    nxt.second+=i;\n    if(m.count(nxt)&&m[nxt]<=M){\n      pii p=dfs(m[nxt]);\n      if(isPrime[pos])p.first++;\n      \n      if(res.first<p.first)res=p;\n      else if(res.first==p.first){\n        if(res.second<p.second)\n          res=p;\n      }\n    }\n  }\n  return dp[pos]=res;\n}\n\nint main(){\n  erats();\n  \n  int sum=1;\n  int pos=0;\n  pii now=pii(0,0);\n  m[now]=1;\n  idToPii[sum]=now;\n  sum++;\n  for(int i=1;;i++){\n    for(int j=0;j<2;j++){\n      // posの方向へiだけ進む\n      for(int k=0;k<i;k++){\n        now.first+=dy[pos];\n        now.second+=dx[pos];\n        m[now]=sum;\n        idToPii[sum]=now;\n        sum++;\n      }\n      pos=(pos+1)%4;\n    }\n    if(sum>=2000000)break;\n  }\n  while(cin>>M>>N&&(N|M)){\n    for(int i=0;i<=M;i++)\n      dp[i].first=dp[i].second=-1;\n    pii p=dfs(N);\n    cout<<p.first<<\" \"<<p.second<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n#define M_MAX 1111\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint xx[M_MAX*M_MAX];\nint yy[M_MAX*M_MAX];\npair<int,int> dp[M_MAX][M_MAX];\nbool isp[M_MAX*M_MAX];\nint mp[M_MAX][M_MAX];\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n\nvoid f(){\n\tint x = M_MAX-1;\n\tint y = M_MAX-1;\n\tint now = M_MAX*M_MAX;\n\tint cou = 0;\n\t\n\twhile(now > 0){\n\t\tmp[y][x] = now;\n\t\txx[now] = x;\n\t\tyy[now] = y;\n\t\tnow--;\n\t\tint tmpx = x + dx[cou];\n\t\tint tmpy = y + dy[cou];\n\t\t\n\t\tif(tmpx >= 0 && tmpx < M_MAX && tmpy >= 0 && tmpy < M_MAX && \n\t\tmp[tmpy][tmpx] == 0){\n\t\t\tx = tmpx;\n\t\t\ty = tmpy;\n\t\t}\n\t\telse{\n\t\t\tcou = (cou + 1) % 4;\n\t\t\tx += dx[cou];\n\t\t\ty += dy[cou];\n\t\t}\n\t}\n\t\n\tREP(i,M_MAX*M_MAX)isp[i] = true;\n\tisp[0] = isp[1] = false;\n\tfor(int i = 2;i < M_MAX*M_MAX;i++){\n\t\tif(isp[i]){\n\t\t\tfor(int j = 2*i;j < M_MAX*M_MAX;j += i)isp[j] = false;\n\t\t}\n\t}\n}\n\nint main(){\n\t\n\tf();\n\t\n\tint n,m;\n\t\n\twhile(cin >> m >> n,n|m){\n\t\t\n\t\tREP(i,M_MAX)REP(j,M_MAX)dp[i][j] = MP(-1,-1);\n\t\t\n\t\tdp[yy[n]][xx[n]] = MP(0,0);\n\t\t\n\t\tREP(i,M_MAX){\n\t\t\tREP(j,M_MAX){\n\t\t\t\tif(dp[i][j] != MP(-1,-1) && mp[i][j] <= m){\n\t\t\t\t\tif(isp[mp[i][j]]){\n\t\t\t\t\t\tdp[i][j] = MP(dp[i][j].FI+1,mp[i][j]);\n\t\t\t\t\t}\n\t\t\t\t\tREP(k,3){\n\t\t\t\t\t\tint x = j + dx[k];\n\t\t\t\t\t\tint y = i + 1;\n\t\t\t\t\t\tDBG(cout << \"xy : \" << x << ' ' << y << endl;)\n\t\t\t\t\t\tif(x >= 0 && x < M_MAX && y >= 0 && y < M_MAX){\n\t\t\t\t\t\t\tdp[y][x] = max(dp[i][j],dp[y][x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpair<int,int> ans = MP(0,0);\n\t\t\n\t\tREP(i,M_MAX){\n\t\t\tREP(j,M_MAX){\n\t\t\t\tif(mp[i][j] <= m)ans = max(ans,dp[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans.FI << ' ' << ans.SE << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nmap<P, int> num;\nmap<int, P> pos;\nmap<P, int> sum;\nset<P> vis;\nint dx[] = { 1,0,-1,0 };\nint dy[] = { 0,-1,0,1 };\nbool is_prime[1000001];\nint main() {\n\tmemset(is_prime, -1, sizeof(is_prime));\n\tis_prime[1] = 0;\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tif (!is_prime[i]) continue;\n\t\tfor (int j = i * 2; j <= 1000000; j += i) is_prime[j] = 0;\n\t}\n\tint x = 0, y = 0;\n\tint dir = 0;\n\tint len = 1;\n\tint cnt = 0;\n\tnum[P(0, 0)] = 1;\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tx += dx[dir];\n\t\ty += dy[dir];\n\t\tnum[P(x, y)] = i;\n\t\tpos[i] = P(x, y);\n\t\tcnt++;\n\t\tif (cnt == len) {\n\t\t\tcnt = 0;\n\t\t\tif (dir % 2) len++;\n\t\t\t(dir += 1) %= 4;\n\t\t}\n\t}\n\tint m, n;\n\twhile (cin >> m >> n, m) {\n\t\tsum.clear();\n\t\tvis.clear();\n\t\tint sx, sy;\n\t\tsx = pos[n].first;\n\t\tsy = pos[n].second;\n\t\tint ans = -1;\n\t\tint t = -1;\n\t\tqueue<P> Q;\n\t\tQ.push(P(sx, sy));\n\t\tvis.insert(P(sx, sy));\n\t\twhile (!Q.empty()) {\n\t\t\tP now = Q.front(); Q.pop();\n\t\t\tif (is_prime[num[now]]) {\n\t\t\t\tsum[now]++;\n\t\t\t\tif (ans < sum[now]) {\n\t\t\t\t\tans = sum[now];\n\t\t\t\t\tt = num[now];\n\t\t\t\t}\n\t\t\t\telse if (ans == sum[now]) {\n\t\t\t\t\tt = max(t, num[now]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\t\tint x = now.first + i;\n\t\t\t\tint y = now.second + 1;\n\t\t\t\tif (num.find(P(x, y)) == num.end()) continue;\n\t\t\t\tsum[P(x, y)] = max(sum[P(x, y)], sum[now]);\n\t\t\t\tif (vis.find(P(x, y)) != vis.end()) continue;\n\t\t\t\tvis.insert(P(x, y));\n\t\t\t\tQ.push(P(x, y));\n\t\t\t}\n\t\t}\n\t\tif (ans == -1) cout << \"0 0\" << endl;\n\t\telse cout << ans << \" \" << t << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS; typedef istringstream ISS;\ntypedef long long LL;\ntypedef pair<int, int> PII;  typedef pair<LL, LL> PLL;\ntypedef vector<int>    VI;   typedef vector<VI>   VVI;   typedef vector<VVI>   VVVI;\ntypedef vector<LL>     VLL;  typedef vector<VLL>  VVLL;  typedef vector<VVLL>  VVVLL;\ntypedef vector<double> VD;   typedef vector<VD>   VVD;   typedef vector<VVD>   VVVD;\ntypedef vector<string> VS;   typedef vector<VS>   VVS;   typedef vector<VVS>   VVVS;\ntypedef vector<bool>   VB;   typedef vector<VB>   VVB;   typedef vector<VVB>   VVVB;\ntypedef vector<PII>    VPII; typedef vector<VPII> VVPII; typedef vector<VVPII> VVVPII;\ntypedef vector<PLL>    VPLL; typedef vector<VPLL> VVPLL; typedef vector<VVPLL> VVVPLL;\n\ntypedef unsigned int  UI;\ntypedef vector<UI>    VUI;\ntypedef vector<VUI>   VVUI;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x)  (x).begin(),(x).end()\n#define RALL(x) (x).rbegin(),(x).rend()\n#define RANGEBOX(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define RANGE(x, l, r) ((l) <= (x) && (x) <= (r))\n#define rep(i, N)  for (int i = 0; i < (int)(N); i++)\n#define rrep(i, N) for (int i = N - 1; i >= 0; i--)\n#define REP(i, init, N)  for (int i = (init); i < (int)(N); i++)\n#define RREP(i, N, last) for (int i = (init - 1); i >= last; i--)\n#define MAXUD(orig, target) orig = max(orig, target)\n#define MINUD(orig, target) orig = min(orig, target)\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a)   { OSS oss; oss << a; return oss.str(); };\n\ntemplate<typename T=int> inline void dump(vector<T> vs, bool ent=false) { rep(i, vs.size()) cout << vs[i] << (i+1==vs.size() ? '\\n' : ' '); if (ent) cout << endl; }\ntemplate<typename T = int> inline void dump(vector<vector<T>> vs, bool ent = false) { rep(i, vs.size()) dump<T>(vs[i]); if (ent) cout << endl; }\n\nconst int    INF  = 0x3f3f3f3f;\nconst LL     INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int    DX[] = {1,  0, -1, 0};\nconst int    DY[] = {0, -1,  0, 1};\nconst double EPS  = 1e-12;\n// const double PI   = acos(-1.0);\n// lambda: [](T1 x)->T2{return y;}\n// simple lambda: [](T x){return x;}\n\nVB prime;\n// O(sqrt(n) * n)\nvoid initprime(LL num) {\n\tprime = VB(num + 1, true);\n\tprime[1] = prime[0] = false;\n\tfor (LL i = 2; i * i <= num; i++) {\n\t\tif (prime[i]) {\n\t\t\tfor (LL j = i + i; j <= num; j += i) {\n\t\t\t\tprime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst int MAX_M = 1000010;\nconst int HW = 1010;\nconst int OFFSET = 505;\nVVI ts = VVI(HW, VI(HW));\nVPII toIdx(MAX_M);\nint M, N;\n\nvoid gen_ts() {\n    int dir = 0;\n    int x = OFFSET, y = OFFSET;\n    int idx = 1;\n    int cnt = 1;\n    ts[y][x] = 1;\n    while (true) {\n        rep(i, 2) {\n            rep(j, cnt) {\n                ++idx;\n                if (idx > MAX_M) return;\n                x += DX[dir];\n                y += DY[dir];\n                ts[y][x] = idx;\n                toIdx[idx] = MP(y, x);\n            }\n            dir = (dir + 1) % 4;\n\n        }\n        ++cnt;\n    }\n}\n\nVVPII memo(HW, VPII(HW));\n\nPII dfs(PII p) {\n    int x = p.snd;\n    int y = p.fst;\n    if (memo[y][x].fst) return memo[y][x];\n\n    int num = ts[y][x];\n    bool is_b = prime[num];\n    PII res(is_b ? 1 : 0, is_b ? num : 0);\n    rep(i, 3) {\n        int nx = x + (i - 1);\n        int ny = y + 1;\n        int nnum = ts[ny][nx];\n        if (nnum != 0 && nnum <= M) {\n            PII tmp = dfs(MP(ny, nx));\n            tmp.fst += is_b;\n            res = max(res, tmp);\n        }\n    }\n\n    if (!res.snd && is_b) {\n        res.snd = num;\n    }\n\n    return memo[y][x] = res;\n}\n\n// price, num\nPII solve() {\n    memo = VVPII(HW, VPII(HW));\n    PII start = toIdx[N];\n    PII res = dfs(start);\n    return res;\n}\n\nint main(void) {\n    initprime(1000010);\n    gen_ts();\n\n    while (cin >> M >> N, M) {\n        PII x = solve();\n        cout << x.fst << \" \" << x.snd << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nbool is_prime[1000001];\nint num[1010][1010];\nint x[1000001];\nint y[1000001];\nint dp[1010][1010];\nint dx[] = { 1,0,-1,0 };\nint dy[] = { 0,-1,0,1 };\nint main() {\n\tfor (int i = 2; i <= 1000000; i++) is_prime[i] = 1;\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tif (!is_prime[i]) continue;\n\t\tfor (int j = 2 * i; j <= 1000000; j += i) is_prime[j] = 0;\n\t}\n\tint len = 1;\n\tint cnt = 0;\n\tint dir = 0;\n\tmemset(num, -1, sizeof(num));\n\tnum[505][505] = 1;\n\tx[1] = 505;\n\ty[1] = 505;\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tx[i] = x[i - 1] + dx[dir];\n\t\ty[i] = y[i - 1] + dy[dir];\n\t\tnum[y[i]][x[i]] = i;\n\t\tcnt++;\n\t\tif (cnt == len) {\n\t\t\tcnt = 0;\n\t\t\tif (dir % 2) len++;\n\t\t\t(dir += 1) %= 4;\n\t\t}\n\t}\n\tint m, n;\n\twhile (cin >> m >> n, m) {\n\t\tint sx = x[n];\n\t\tint sy = y[n];\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tdp[sy][sx] = 0;\n\t\tif (is_prime[num[sy][sx]]) dp[sy][sx]++;\n\t\tfor (int i = sy; i + 1 < 1010; i++) {\n\t\t\tfor (int j = 0; j < 1010; j++) {\n\t\t\t\tif (num[i][j] == -1 || num[i][j] > m || dp[i][j] == -1) continue;\n\t\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\t\tint nx = j + k;\n\t\t\t\t\tif (0 > nx || nx >= 1010 || num[i + 1][nx] == -1 || num[i + 1][nx] > m) continue;\n\t\t\t\t\tdp[i + 1][nx] = max(dp[i + 1][nx], dp[i][j] + is_prime[num[i + 1][nx]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = -1;\n\t\tint t = -1;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tif (!is_prime[i]) continue;\n\t\t\tif (ans <= dp[y[i]][x[i]]) {\n\t\t\t\tans = dp[y[i]][x[i]];\n\t\t\t\tt = i;\n\t\t\t}\n\t\t}\n\t\tif (ans == -1) cout << \"0 0\" << endl;\n\t\telse cout << ans << \" \" << t << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\nint dy[]={0,-1, 0, 1};\nint dx[]={-1,0, 1, 0};\n \nstruct aaa{\n    int maxi;\n    int prime;\n};\n  \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n \nint hole[1000][1000],m,n;\nbool isp[1000001];\naaa memo[1003][1000];\n \naaa search(int y,int x){\n    if(memo[y][x].maxi >= 0)\n        return memo[y][x];\n \n    if((y > 999) || hole[y][x] > m){\n        aaa ret;\n        memo[y][x].maxi = memo[y][x].prime = 0;\n        return memo[y][x];\n    }\n \n    aaa ret;ret.maxi = ret.prime = 0;\n \n    for(int i = x - 1;i < x + 2;i++){\n        if(i < 0 || i > 999)\n            continue;\n \n        aaa b = search(y + 1,i);\n        if(b.maxi > ret.maxi || (b.maxi == ret.maxi && b.prime > ret.prime))\n            ret = b;\n    }\n    if(ret.prime == 0 && isp[hole[y][x]])\n        ret.prime = hole[y][x];\n    ret.maxi += isp[hole[y][x]];\n    return memo[y][x] = ret;\n}\n \nint main(){\n    int d = 2;int x = 0;int y = 0;\n    RFOR(i,1,1000001){\n        hole[y][x] = i;\n        if(x + dx[d] < 0 || x + dx[d] > 999  || y + dy[d] < 0 || y + dy[d] > 999 || hole[y + dy[d]][x + dx[d]] > 0){\n            d = (d + 1) % 4;\n        }\n \n        x += dx[d]; y += dy[d];\n    }\n \n    memset(isp,true,sizeof(isp));isp[1] = false;\n    FOR(i,2,10000){\n        if(isp[i]){\n            for(int j = i * 2;j < 1000001;j += i)\n                isp[j] = false;\n        }\n    }\n    while(1){\n        scanf(\"%d%d\",&m,&n);\n        if(m == 0 && n == 0)\n            break;\n \n        aaa ans;\n        REP(i,1003)\n            REP(j,1000)\n                memo[i][j].maxi = -1;\n \n        REP(i,1000){\n            REP(j,1000){\n                if(hole[i][j] == n)\n                    ans = search(i,j); \n            }\n        }\n        printf(\"%d %d\\n\",ans.maxi,ans.prime);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[(SIZE + 1)*(SIZE + 1) + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= (SIZE + 1)*(SIZE + 1);i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= (SIZE + 1)*(SIZE + 1);j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 || n == 0)return 0;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(y=SIZE-1;y>=0;y--){\n\t\t\tfor(x=SIZE-1;x>=0;x--){\n\t\t\t\tif (table[y][x] <= m) {\n\t\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m &&\n\t\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x - 1] || (dp[y][x] == dp[y + 1][x - 1] && pr[y][x] < pr[y + 1][x - 1]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (table[y + 1][x] <= m &&\n\t\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x] || (dp[y][x] == dp[y + 1][x] && pr[y][x] < pr[y + 1][x]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m &&\n\t\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x + 1] || (dp[y][x] == dp[y + 1][x + 1] && pr[y][x] < pr[y + 1][x + 1]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (y = 0;y < SIZE;y++) {\n\t\t\tfor (x = 0;x < SIZE;x++) {\n\t\t\t\tif (table[y][x] == n) {\n\t\t\t\t\tcout << dp[y][x] << \" \" << pr[y][x] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE + 10][SIZE + 10], dp[SIZE + 10][SIZE + 10], pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t/*\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (y>=0&&x>=0&&table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t*/\n\t\tfor (int h = 0;h < SIZE;h++) {\n\t\t\tfor (int w = 0;w < SIZE;w++) {\n\t\t\t\tif (table[h][w] == n) {\n\t\t\t\t\tcout << dp[h][w] << \" \" << pr[h][w] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1189&lang=jp\n\n#include<iostream>\n//#include<fstream>\n#include<complex>\n\n#define MAX 1002\n\nint n, first;\nint a[MAX][MAX] = {};\nstatic bool initial;\n\nclass Pair{\npublic:\n\tint count;\n\tint last;\n\tPair operator + (Pair p){//\t@Override (+)\n\t\tthis->count += p.count;\n\t\tif (p.last != 0)this->last = p.last;\n\t\treturn *this;\n\t}\n\tvoid setPair(int _x, int _y){\n\t\tcount = _x;\n\t\tlast = _y;\n\t}\n};\n\nPair pair(int a, int b){\n\tPair p;\n\tp.setPair(a, b);\n\treturn p;\n}\n\nbool isPrime(int n){\n\tif (n == 1)return false;\n\tif (n == 2)return true;\n\tif (n % 2 == 0)return false;\n\n\tfor (int i = 3; i * i <= n; i += 2){\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\n\nPair search(int y, int x){\n\tstatic Pair p[MAX*MAX];\n\n\tPair u_right = pair(-10, 0);\n\tPair u_left = pair(-10, 0);\n\n\tstatic bool isReached[MAX*MAX];\n\n\n\tif (initial){//初期化\n\t\tfor (int i = 0; i < MAX*MAX; i++){\n\t\t\tisReached[i] = false;\n\t\t\tp[i].count = p[i].last = 0;\n\t\t}\n\t\tinitial = false;\n\t}\n\n\tif (n < a[y][x] || a[y][x] == 0)\n\t\treturn p[0];//上限を超えていた場合,,, p[0].count = p[0].last = 0\n\n\t//以下特殊例処理\n\tif (a[y][x] == 2){\n\t\tp[2].last = 2;\n\t\tif (a[y][x] == first)initial = true;\n\t\treturn pair(1, 2) + search(y + 1, x);\n\t}\n\n\tif (n <= 6 && a[y][x] == 3){\n\t\tp[3].last = 2;\n\t\tif (a[y][x] == first)initial = true;\n\t\treturn pair(2, 2);\n\t}\n\tif (a[y][x] == 4){\n\t\tif (u_right.count == -10)u_right = search(y + 1, x + 1);\n\t\tif (u_left.count == -10)u_left = search(y + 1, x);\n\n\t\tif (u_right.count == u_left.count){\n\t\t\tif (u_right.last < u_left.last)u_right.count--;\n\t\t}\n\t\tif (u_right.count < u_left.count){\n\t\t\tisReached[4] = true;\n\t\t\tif (a[y][x] == first)initial = true;\n\t\t\treturn p[4] = p[4] + u_left;\n\t\t}\n\t\telse{\n\t\t\tisReached[4] = true;\n\t\t\tif (a[y][x] == first)initial = true;\n\t\t\treturn p[4] = p[4] + u_right;\n\t\t}\n\t}\n\t//ここまで特例処理\n\n\t//偶数の時\n\tif (a[y][x] % 2 == 0){\n\t\tif (a[y][x] == first){\n\t\t\tinitial = true;\n\t\t\tif (n == first)return p[a[y][x]] = search(y + 1, x + 1) + search(y + 1, x - 1);// +p[a[y + 1][x - 1]];\n\t\t}\n\treturn p[a[y + 1][x]] = search(y + 1, x);\n\t}\n\n\t//枝刈り\n\tif (isReached[a[y][x]]){\n\t\tif (a[y][x] == first)initial = true;\n\t\treturn p[a[y][x]];\n\t}\n\n\tif (u_right.count == -10)u_right = search(y + 1, x + 1);//under.rightの計算\n\tif (u_left.count == -10)u_left = search(y + 1, x - 1);//under.leftの計算\n\n\t//素数の時\n\tif (isPrime(a[y][x])){\n\t\tp[a[y][x]].count = 1;\n\t\tp[a[y][x]].last = a[y][x];\n\t}\n\n\tif (u_right.count == u_left.count){\n\t\tif (u_right.last < u_left.last)u_right.count--;\n\t}\n\t//leftのコストが大きい時\n\tif (u_right.count < u_left.count){\n\t\tisReached[a[y][x]] = true;\n\t\tif (a[y][x] == first)initial = true;//最初に入った時のみ、次のために初期化\n\t\treturn p[a[y][x]] = p[a[y][x]] + u_left;\n\t}\n\t//rightのコストが大きい時\n\telse{\n\t\tisReached[a[y][x]] = true;\n\t\tif (a[y][x] == first)initial = true;//最初に入った時のみ、次のために初期化\n\t\treturn p[a[y][x]] = p[a[y][x]] + u_right;\n\t}\n}\n\nint main(){\n\n\tusing namespace std;\n\n\tint x = MAX / 2;\n\tint y = MAX / 2;\n\tint N = 1;\n\ta[MAX / 2][MAX / 2] = 1;\n\n\tfor (int i = 0; i < MAX*MAX; i++){\n\n\t\tfor (int n = 0; n < (int)sqrt((double)N); n++){\n\t\t\ta[y][x] = N;\n\t\t\tN++;\n\t\t\tx++;\n\t\t}\n\t\tif (N >= (MAX)*(MAX))break;\n\t\tfor (int n = 0; n < (int)sqrt((double)N); n++){\n\t\t\ta[y][x] = N;\n\t\t\tN++;\n\t\t\ty--;\n\t\t}\n\t\tif (N >= (MAX)*(MAX))break;\n\t\tfor (int n = 0; n < (int)sqrt((double)N); n++){\n\t\t\ta[y][x] = N;\n\t\t\tN++;\n\t\t\tx--;\n\t\t}\n\t\tif (N >= (MAX)*(MAX))break;\n\t\tfor (int n = 0; n < (int)sqrt((double)N); n++){\n\t\t\ta[y][x] = N;\n\t\t\tN++;\n\t\t\ty++;\n\t\t}\n\t\tif (N >= (MAX)*(MAX))break;\n\t}\n\n\n\twhile (true){\n\t\tcin >> n >> first;\n\t\tif (n == 0)break;\n\n\t\tinitial = true;\n\n\t\tfor (int i = 0; i < MAX; i++){\n\t\t\tfor (int j = 0; j < MAX; j++){\n\t\t\t\tif (a[i][j] == first){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tPair p = search(y, x);\n\n\t\tcout << p.count << \" \" << p.last << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// {{{ include\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n// }}}\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\ninline int in(){int x;scanf(\"%d\",&x);return x;}\n\nconst int MAX_M = 1000100;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint M, N;\nint caves[1024][1024];\nint sieve[MAX_M + 1] = {1, 1};\nint X[MAX_M], Y[MAX_M];\n\nvoid make_spiral(int x, int y, int start=1, int d=0, int len=0)\n{\n  if (start > M) return;\n  int L = len / 2 + 1;\n  for (int i = 0; i < L; i++){\n    caves[y][x] = start + i;\n    X[start + i] = x;\n    Y[start + i] = y;\n    y += dy[d];\n    x += dx[d];\n  }\n  make_spiral(x, y, start + L, (d + 1) % 4, len + 1);\n}\n\nint memo_count[1024][1024];\nint memo_max[1024][1024];\n\nP dfs(int x, int y){\n  int v = caves[y][x];\n  if (v == -1 || v > M) return P(0, 0);\n  if (memo_count[y][x] != -1) return P(memo_count[y][x], memo_max[y][x]);\n  int p = !sieve[v];\n  P ret = max({dfs(x + 1, y + 1), dfs(x, y + 1), dfs(x - 1, y + 1)});\n  ret.first += p;\n  if (p && ret.first == 1) ret.second = v;\n  memo_count[y][x] = ret.first;\n  memo_max[y][x] = ret.second;\n  return ret;\n}\n\nint main()\n{\n  for (int i = 2; i * i <= MAX_M; i++){\n    if (sieve[i]) continue;\n    for (int j = i * i; j <= MAX_M; j += i){\n      sieve[j] = 1;\n    }\n  }\n\n  while (M = in(), N = in()){\n    memset(caves, -1, sizeof(caves));\n    memset(memo_count, -1, sizeof(memo_count));\n    memset(memo_max, -1, sizeof(memo_max));\n    make_spiral(512, 512);\n    P ans = dfs(X[N], Y[N]);\n    printf(\"%d %d\\n\", ans.first, ans.second);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#define MAX 1000001\n\ntypedef long long ll;\n\nusing namespace std;\n\nint m;\nint table[2000][2000]={{0,0}};\nint dp[2000][2000]={{0, 0}};\nint dx[4]={0, 1, 0, -1};\nint dy[4]={1, 0, -1, 0};\nbool prime[MAX]; \npair<int, int>coord[MAX];//座標\npair<int, int> ans;// <素数の数, 出口の番号>\n\n\nvoid dfs(int count, int y, int x){\n\tint n = table[y][x];\n\tif(n <= 0 || m < n) return;\n\n\tif(count < dp[y][x] || (count == dp[y][x] && prime[n] == false && dp[y][x] !=0)) return;\n\tif(prime[n] == true){\n\t\tcount++;\n\t\tdp[y][x] = count;\n\t\tif(ans.first < count || (ans.first == count && ans.second < n)){\n\t\t\tans.first = count;\n\t\t\tans.second = n;\n\t\t}\n\t}\n\n\tfor(int dx=-1; dx<=1; dx++){\n\t\tdfs(count, y+1, x+dx);\n\t}\n}\n\n\nint main(void){\n\tfill(prime, prime+MAX, true);\n\tprime[0] = prime[1] = false;\n\tfor(int i=2; i<MAX; i++){\n\t\tif(prime[i]){\n\t\t\tfor(int j=i+i; j<MAX; j+=i){\n\t\t\t\tprime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tint d=0;\n\tint x=1000, y=1000;\n\tfor(int i=1; i<MAX; i++){\n\t\ttable[y][x] = i;\n\t\tcoord[i] = make_pair(y, x);\n\t\tif(table[y+dy[(d+1)%4]][x+dx[(d+1)%4]] == 0) d++;\n\t\tx += dx[d%4];\n\t\ty += dy[d%4];\n\t}\n\n\twhile(1){\n\t\tint n; cin >> m >> n;\n\t\tif(!m && !n) break;\n\n\t\tint y = coord[n].first;\n\t\tint x = coord[n].second;\n\t\tfill(dp[0], dp[2000], 0);\n\t\tans = make_pair(0,0);\n\t\tdfs(0, y, x);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <functional>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\nusing namespace std;\nusing llong = long long;\n\nllong n, m;\n\nllong num[1024][1024];\npair<llong, llong> dp[1024][1024];\nbool is_prime[1000005];\n\nvoid sieve(llong n) {\n    for (int i = 0; i <= n; i++) is_prime[i] = true;\n    is_prime[0] = is_prime[1] = false;\n\n    for (int i = 2; i <= n; i++) {\n        if (is_prime[i]) {\n            for (int j = 2 * i; j <= n; j += i) is_prime[j] = false;\n        }\n    }\n    return;\n}\n\npair<llong, llong> rec(int i, int j) {\n    if (i >= 1024 || j < 0 || j >= 1024) return {0, 0};\n    if (num[i][j] > m) return {0, 0};\n\n    if (dp[i][j] != make_pair(-1ll, -1ll)) return dp[i][j];\n\n    pair<llong, llong> ret = max({rec(i + 1, j - 1),\n                                  rec(i + 1, j),\n                                  rec(i + 1, j + 1)});\n\n    if (ret == make_pair(0ll, 0ll) && is_prime[num[i][j]]) {\n        ret.first = 1;\n        ret.second = num[i][j];\n    }\n    else if (is_prime[num[i][j]]){\n        ret.first++;\n    }\n    \n    return dp[i][j] = ret;\n}\n\nint main() {\n    {\n        sieve(1000000);\n        llong x, y;\n        llong c = 3;\n        llong w = 3;\n        num[512][512] = 1;\n        num[512][513] = 2;\n        x = 513;\n        y = 512;\n\n        while (c <= 1000000) {\n            for (int i = 0; i < w - 2; i++) {\n                y--;\n                num[y][x] = c;\n                c++;\n            }\n\n            for (int i = 0; i < w - 1; i++) {\n                x--;\n                num[y][x] = c;\n                c++;\n            }\n\n            for (int i = 0; i < w - 1; i++) {\n                y++;\n                num[y][x] = c;\n                c++;\n            }\n\n            for (int i = 0; i < w; i++) {\n                x++;\n                num[y][x] = c;\n                c++;\n            }\n            w += 2;\n        }\n    }\n    \n    while (1) {\n        cin >> m >> n;\n        if (n == 0) break;\n\n        llong x, y;\n        for (int i = 0; i < 1024; i++) {\n            for (int j = 0; j < 1024; j++) {\n                if (num[i][j] == n) {\n                    y = i;\n                    x = j;\n                }\n                dp[i][j] = make_pair(-1ll, -1ll);\n            }\n        }\n\n        auto p = rec(y, x);\n\n        cout << p.first << ' ' << p.second << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nstatic const int MAX = 1000;\nstatic const int di[4] = {0, -1, 0, 1};\nstatic const int dj[4] = {1, 0, -1, 0};\nbool T[MAX*MAX+1], P[MAX+1][MAX+1];\nint G[MAX+1][MAX+1];\npair<int, int> C[MAX*MAX+1], dp[MAX+1][MAX+1];\n\nvoid eratos( int n, bool prime[] ){\n  for ( int i = 0; i <= n; i++ ) prime[i] = true;\n  prime[0] = prime[1] = false;\n  for ( int i = 2; i*i <= n; i++ ){\n    if ( prime[i] )\n      for ( int j = 2; i*j <= n; j++ ) prime[i*j] = false;\n  }\n}\n\nvoid setp(int pi, int pj, int &p){\n  P[pi][pj] = T[p];      \n  C[p] = make_pair(pi, pj);\n  G[pi][pj] = p++;\n}\n\nvoid init(){\n  int pi = 500, pj = 500, p = 1;\n  setp(pi, pj, p);\n  for ( int r = 0;; r++ ){\n    for ( int i = 0; i < r/2+1; i++ ){\n      pi += di[r%4];\n      pj += dj[r%4];\n      setp(pi, pj, p);\n      if ( p >= MAX*MAX ) return;\n    }\n  }\n}\n\npair<int, int> solve(int pi, int pj, int m){\n  if ( dp[pi][pj].first != -1 ) return dp[pi][pj];\n  pair<int, int> v, res = make_pair(0, 0);\n\n  for ( int j = -1; j <= 1; j++ ){\n    int ni = pi + 1;\n    int nj = pj + j;\n    if ( ni > MAX || nj < 0 || nj > MAX ) continue;\n    int np = G[ni][nj];\n    if ( np > m ) continue;\n    v = solve(ni, nj, m);\n    res = max(res, v);\n  }\n\n  if ( 0 == res.second ){\n    if ( P[pi][pj] ) return dp[pi][pj] = make_pair(1, G[pi][pj]);\n    return dp[pi][pj] = res;\n  } else {\n    if ( P[pi][pj] ) res.first++;\n    return dp[pi][pj] = res;\n  }\n}\n\nmain(){\n  eratos(MAX*MAX+1, T);\n  init();\n  int m, n;\n  while( cin >> m >> n ){\n    if ( m == 0 && n == 0 ) break;\n    for ( int i = 0; i < MAX+1; i++ )\n      for ( int j = 0; j < MAX+1; j++ ) dp[i][j] = make_pair(-1, 0);\n    pair<int, int> ans = solve(C[n].first, C[n].second, m);\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\n#define FOR(i,a,b) for(int i=(int)a; i<(int)b; ++i)\n#define REP(i, n) FOR(i,0,n)\ntemplate<class T> void CHMAX(T & a, T b) { a = (a >= b ? a : b); }\nconstexpr int INFINT = (1 << 30) - 1;\nusing PAIR = std::pair<int, int>;\n\nbool isP[1000006];\nvoid Eratosthenes() {\n\tREP(i, 1000006) isP[i] = true;\n\tisP[1] = false;\n\tfor (int i = 2; i * i <= 1000006; ++i) {\n\t\tif (isP[i]) {\n\t\t\tfor (int j = 2; i * j <= 1000006; ++j) isP[i * j] = false;\n\t\t}\n\t}\n}\n\nint mp[2003][2003];\nPAIR inv[1000006];\nconst int mid = 1001;\n\nint dy4[] = { 0, -1, 0, 1 };\nint dx4[] = { 1, 0, -1, 0 };\n\nvoid makemap() {\n\tREP(i, 2003) REP(j, 2003) mp[i][j] = INFINT;\n\tint y = mid, x = mid;\n\tint now = 1;\n\tmp[y][x] = 1;\n\tinv[1] = PAIR(y, x);\n\tint dist = 0;\n\twhile (true) {\n\t\tREP(d, 4) {\n\t\t\tif (d % 2 == 0) ++dist;\n\t\t\tREP(_, dist) {\n\t\t\t\ty += dy4[d];\n\t\t\t\tx += dx4[d];\n\t\t\t\tmp[y][x] = ++now;\n\t\t\t\tinv[now] = PAIR(y, x);\n\t\t\t\tif (now >= 1000003) return;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tEratosthenes();\n\tmakemap();\n\n\tint m, n;\n\twhile (std::cin >> m >> n, m || n) {\n\t\tstd::vector<PAIR> dp(m + 1, PAIR(-1, -1));\n\n\t\tauto rec = [&](auto && f, int x) -> PAIR {\n\t\t\tif (x > m) return PAIR(0, 0);\n\t\t\tPAIR& res = dp[x];\n\t\t\tif (res.first != -1) return res;\n\t\t\tres = PAIR(0, 0);\n\n\t\t\tPAIR pos(inv[x]);\n\t\t\tCHMAX(res, f(f, mp[pos.first + 1][pos.second - 1]));\n\t\t\tCHMAX(res, f(f, mp[pos.first + 1][pos.second + 0]));\n\t\t\tCHMAX(res, f(f, mp[pos.first + 1][pos.second + 1]));\n\t\t\tif (isP[x]) {\n\t\t\t\t++res.first;\n\t\t\t\tif (res.first == 1) CHMAX(res.second, x);\n\t\t\t}\n\t\t\treturn res;\n\t\t};\n\t\trec(rec, n);\n\t\tstd::cout << dp[n].first << \" \" << dp[n].second << std::endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\nint main ()\n{\n    const int INF = 1 << 28;\n    const int MAX = 1000000;\n    const int dx[] = { 1, 0,-1, 0};\n    const int dy[] = { 0,-1, 0, 1};\n    const int dm[] = {-1, 0, 1};\n    int n, m;\n    map<P, int> M;\n    vector<P> d(MAX+1, P(INF,INF));\n\n    M[P(0,0)] = 1;\n    d[1] = P(0,0);\n    int x = 1, y = 0;\n    int c = 1;\n    for (int i = 2; i <= MAX; i++) {\n        c %= 4;\n        int cdir = 4 + c - 1;\n        cdir %= 4;\n        int sy = y - dy[cdir], sx = x - dx[cdir];\n        M[P(y,x)] = i;\n        d[i] = P(y,x);\n         if (M.find(P(sy,sx)) != M.end()) {\n            x += dx[c];\n            y += dy[c];\n         } else {\n             x = sx;\n             y = sy;\n             c++;\n         }\n    }\n\n    vector<bool> prim(MAX+1, true);\n    prim[0] = prim[1] = false;\n    for (int i = 2; i <= MAX / 2; i++) {\n        for (int j = 2; prim[i] && j * i <= MAX; j++) {\n            prim[i * j] = false;\n        }\n    }\n\n    while (cin >> n >> m , n + m) {\n        int res = 0;\n        int res_n = 0;\n        queue<pair<int,P> > q;\n\n        vector<int> count(MAX+1, 0);\n        if (prim[m]) {\n            count[m] = 1;\n            q.push(pair<int,P>(1, d[m]));\n            res = 1;\n            res_n = m;\n        } else {\n            count[m] = 0;\n            q.push(pair<int,P>(0, d[m]));\n        }\n\n        vector<bool> used(MAX + 1, false);\n\n        while (q.size()) {\n            pair<int,P> pp = q.front(); q.pop();\n            P p = pp.second;\n            int num = M[p];\n            int ret = pp.first;\n\n            if (count[num] > ret) continue;\n            used[num] = true;\n            y = p.first, x = p.second;\n            for (int i = 0; i < 3; i++) {\n                int ny = y + 1, nx = x + dm[i];\n                if (M.find(P(ny, nx)) != M.end() && M[P(ny,nx)] <= n) {\n                    int t_n = M[P(ny,nx)];\n                    if (count[t_n] == 0 || count[t_n] < count[num] + (prim[t_n] ? 1 : 0)) {\n\n                        if (!used[t_n] || count[t_n] < count[num] + (prim[t_n] ? 1 : 0)) {\n                            count[t_n] = count[num] + (prim[t_n] ? 1 : 0);\n                            q.push(pair<int,P>(count[t_n], P(ny,nx)));\n                            used[t_n] = true;\n                        }\n                        if (res <= count[t_n] && prim[t_n]) {\n                            res = count[t_n];\n                            res_n = t_n;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (res == 0)\n            cout << 0 << \" \" << 0 << endl;\n        else\n            cout << res << \" \" << res_n << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <climits>\n#include <cassert>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\nconst int MAX_HW = 1010;\n\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\n\nint main()\n{\n\n\t\tvi p(1000000+1, 1);\n\t\tp[0] = p[1] = 0;\n\t\tFOR(i, 2, 1000+1) {\n\t\t\tif(p[i]) {\n\t\t\t\tfor(int j = i*i; j <= 1000000; j += i) {\n\t\t\t\t\tp[j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\tint m,n;\n\twhile(cin>>m>>n,m){\n\t\tpii start;\n\n\t\tint sty, stx;\n\t\tint top=INT_MAX, bottom=INT_MIN, left=INT_MAX, right=INT_MIN;\n\t\tvvi exist(MAX_HW, vi(MAX_HW));\n\t\tvvi canuse(MAX_HW, vi(MAX_HW));\n\n\t\tint y=MAX_HW/2;\n\t\tint x=MAX_HW/2;\n\t\tint move=1,d=0;\n\t\tint num=1;\n\t\tint cnt=1;\n\t\twhile(1){\n\t\t\tREP(_,move){\n\t\t\t\tif(num == n) {\n\t\t\t\t\tsty = y;\n\t\t\t\t\tstx = x;\n\t\t\t\t}\n\t\t\t\tif(p[num]){\n\t\t\t\t\texist[y][x]=1;\n\t\t\t\t}\n\t\t\t\tcanuse[y][x]=num;\n\t\t\t\ty+=dy[d];\n\t\t\t\tx+=dx[d];\n\t\t\t\tif(num==m){\n\t\t\t\t\tgoto made;\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t\tassert(y<MAX_HW&&y>=0&&x<MAX_HW&&x>=0);\n\t\t\t}\n\t\t\td=(d+1)%4;\n\t\t\tif(cnt%2==0){\n\t\t\t\tmove++;\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\nmade:;\n\n\t\tREP(i,MAX_HW){\n\t\t\tREP(j,MAX_HW){\n\t\t\t\tif(canuse[i][j]){\n\t\t\t\t\tleft=min(left,j);\n\t\t\t\t\tright=max(right,j);\n\t\t\t\t\ttop=min(top,i);\n\t\t\t\t\tbottom=max(bottom,i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvvi dp(MAX_HW, vi(MAX_HW));\n\t\tdp[sty][stx]=exist[sty][stx]+1;\n\t\tvvi last(MAX_HW, vi(MAX_HW));\n\t\tif(exist[sty][stx]){\n\t\t\tlast[sty][stx]=canuse[sty][stx];\n\t\t}else{\n\t\t\tlast[sty][stx]=-1;\n\t\t}\n\n\t\tFOR(i, sty+1, bottom+1) {\n\t\t\tFOR(j, left, right+1) {\n\t\t\t\tif(!canuse[i][j]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint saiyou=INT_MIN;\n\t\t\t\tint best=0;\n\t\t\t\tfor(int k=-1;k<2;k++){\n\t\t\t\t\tif(dp[i-1][j+k]>best||(dp[i-1][j+k]==best&&last[i-1][saiyou]<last[i-1][j+k])){\n\t\t\t\t\t\tassert(j+k>=left&&j+k<=right);\n\t\t\t\t\t\tbest=dp[i-1][j+k];\n\t\t\t\t\t\tsaiyou=j+k;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(saiyou!=INT_MIN){\n\t\t\t\t\tif(exist[i][j]){\n\t\t\t\t\t\tdp[i][j]=best+1;\n\t\t\t\t\t\tlast[i][j]=canuse[i][j];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i][j]=best;\n\t\t\t\t\t\tlast[i][j]=last[i-1][saiyou];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//if(dp[i-1][j-1]>=1||dp[i-1][j]>=1||dp[i-1][j+1]>=1){\n\t\t\t\t//\tdp[i][j] = max(dp[i-1][j-1], max(dp[i-1][j], dp[i-1][j+1])) + exist[i][j];\n\t\t\t\t//}\n\t\t\t\t//if(exist[i][j]){\n\t\t\t\t//\tlast[i][j]=canuse[i][j];\n\t\t\t\t//}else{\n\t\t\t\t//\tlast[i][j]=max(last[i-1][j-1], max(last[i-1][j], last[i-1][j+1]));\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\n\t\tint ans = -1, ansx, ansy;\n\t\tFOR(j, left, right+1) {\n\t\t\tif(canuse[bottom][j]) {\n\t\t\t\tif(ans < dp[bottom][j]) {\n\t\t\t\t\tans = dp[bottom][j];\n\t\t\t\t\tansx = j;\n\t\t\t\t\tansy = bottom;\n\t\t\t\t} else if(ans == dp[bottom][j] && last[bottom][j] > last[ansy][ansx]){\n\t\t\t\t\tansx = j;\n\t\t\t\t\tansy = bottom;\n\t\t\t\t}\n\t\t\t} else if(canuse[bottom-1][j]) {\n\t\t\t\tif(ans < dp[bottom-1][j]) {\n\t\t\t\t\tans = dp[bottom-1][j];\n\t\t\t\t\tansx = j;\n\t\t\t\t\tansy = bottom-1;\n\t\t\t\t} else if(ans == dp[bottom-1][j] && last[bottom-1][j] > last[ansy][ansx]){\n\t\t\t\t\tansx = j;\n\t\t\t\t\tansy = bottom-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//REP(i,MAX_HW){\n\t\t//\tREP(j,MAX_HW){\n\t\t//\t\tcerr<<dp[i][j];\n\t\t//\t}\n\t\t//\tcerr<<endl;\n\t\t//}\n\n\t\tif(ans-1==0){\n\t\t\tcout<<\"0 0\"<<endl;\n\t\t}else{\n\t\t\tcout<<ans-1<<\" \"<<last[ansy][ansx]<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1000000;\nconst int WIDTH = 1005;\nconst int S = 500;\nconst int INF = 100000000;\n\nint prime[N];\nint ma[WIDTH][WIDTH];\nint dis[WIDTH][WIDTH];\nint did[WIDTH][WIDTH];\nconst int dirx[4] = {1, 0, -1, 0};\nconst int diry[4] = {0, -1, 0, 1};\ntypedef pair<int, int> P;\n\nint sx, sy;\nint ans, fin;\n\nvoid BFS_prime();\nvoid BFS_ans(int n);\n\nvoid Eratos(){\n\tfor(int i=0; i<N; i++){\n\t\tprime[i] = 1;\n\t}\n\n\tprime[0] = prime[1] = 0;\n\tfor(int i=2; i*i <= N; i++){\n\t\tfor(int j=i*2; j<N; j += i){\n\t\t\tprime[j] = 0;\n\t\t}\n\t}\n\n}\n\nvoid create(int m, int n){\n\tmemset(ma, 0, sizeof(ma));\n\tint cnt = 1;\n\tint dx = 0;\n\tint dy = 0;\n\tint ndir = 0;\n\tint lim = 1;\n\tbool f = false;\n\twhile(1){\n\t\tfor(int i=0; i<lim; i++){\n\n\t\t\tma[S + dy][S + dx] = cnt;\n\t\t\tif(cnt == n){\n\t\t\t\tsx = S + dx;\n\t\t\t\tsy = S + dy;\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tif(cnt == m) f = true;\n\n\t\t\tdx += dirx[ndir % 4];\n\t\t\tdy += diry[ndir % 4];\n\t\t}\n\t\tif(f) break;\n\t\tndir++;\n\t\tfor(int i=0; i<lim; i++){\n\n\t\t\tma[S + dy][S + dx] = cnt;\n\t\t\tif(cnt == n){\n\t\t\t\tsx = S + dx;\n\t\t\t\tsy = S + dy;\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tif(cnt == m) f = true;\n\n\t\t\tdx += dirx[ndir % 4];\n\t\t\tdy += diry[ndir % 4];\n\t\t}\n\t\tndir++;\n\t\tlim++;\n\t\tif(f) break;\n\t}\n}\n\nint main(void){\n\tEratos();\n\n\twhile(1){\n\t\tans = 0;\n\t\tfin = 0;\n\t\tint m, n;\n\t\tcin >> m >> n;\n\t\tif(m == 0 && n == 0) break;\n\t\tcreate(m, n);\n\n\t\t/*\n\t\tfor(int i=S-30; i<S+30; i++){\n\t\t\tfor(int j=S-30; j<S+30; j++){\n\t\t\t\tprintf(\"%3d \", ma[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\t*/\n\n\t\tBFS_prime();\n\t\t/*\n\t\tfor(int i=S-30; i<S+30; i++){\n\t\t\tfor(int j=S-30; j<S+30; j++){\n\t\t\t\tif(dis[i][j] == INF){\n\t\t\t\t if(i == sy && j == sx) printf(\"S \");\n\t\t\t\t else printf(\"* \");\n\n\t\t\t\t}else printf(\"%1d \", dis[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\t*/\n\t\tBFS_ans(m);\n\t\t/*\n\t\tfor(int i=S-30; i<S+30; i++){\n\t\t\tfor(int j=S-30; j<S+30; j++){\n\t\t\t\tif(dis[i][j] == INF) printf(\"* \");\n\t\t\t\telse printf(\"%1d \", dis[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\t*/\n\t\tprintf(\"%d %d\\n\", ans, fin);\n\n\t}\n\n\treturn 0;\n}\n\nvoid BFS_prime(){\n\tqueue<P> que;\n\tfor(int i=0; i<WIDTH; i++){\n\t\tfor(int j=0; j<WIDTH; j++){\n\t\t\tdis[i][j] = INF;\n\t\t}\n\t}\n\n\t//printf(\"%d %d\\n\", sy, sx);\n\tque.push(P(sy, sx));\n\tif(prime[ma[sy][sx]] == 1) dis[sy][sx] = 1;\n\n\twhile(que.size()){\n\t\tP p = que.front(); que.pop();\n\n\t\t//printf(\"%d %d\\n\", p.first, p.second);\n\t\tif(ma[p.first][p.second] == 0) continue;\n\n\t\tfor(int i=-1; i <= 1; i++){\n\t\t\tint nx = p.second + i;\n\t\t\tint ny = p.first + 1;\n\n\t\t\tif(dis[ny][nx] == INF){\n\t\t\t\t//printf(\"nynx:%d %d\\n\", ny, nx);\n\n\t\t\t\tque.push(P(ny, nx));\n\t\t\t\tif(prime[ma[ny][nx]] == 1) dis[ny][nx] = 1;\n\t\t\t\telse dis[ny][nx] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid BFS_ans(int n){\n\tqueue<P> que;\n\tfor(int i=0; i<WIDTH; i++){\n\t\tfor(int j=0; j<WIDTH; j++){\n\t\t\tif(dis[i][j] == INF) dis[i][j] = 0;\n\t\t}\n\t}\n\tfor(int i=0; i<WIDTH; i++){\n\t\tfor(int j=0; j<WIDTH; j++){\n\t\t\tdid[i][j] = 0;\n\t\t}\n\t}\n\n\tque.push(P(sy, sx));\n\tif(prime[ma[sy][sx]] == 1){\n\t\tdis[sy][sx] = 1;\n\t\tif(ans < dis[sy][sx]){\n\t\t\tans = dis[sy][sx];\n\t\t\tfin = ma[sy][sx];\n\t\t}\n\t}\n\n\twhile(que.size()){\n\t\tP p = que.front(); que.pop();\n\n\t\tif(ma[p.first][p.second] == 0) continue;\n\n\t\tfor(int i=-1; i <= 1; i++){\n\t\t\tint nx = p.second + i;\n\t\t\tint ny = p.first + 1;\n\n\t\t\tif(did[ny][nx] == 0){\n\t\t\t\tdid[ny][nx] = 1;\n\t\t\t\tque.push(P(ny, nx));\n\t\t\t\tif(dis[ny][nx] == 1) {\n\t\t\t\t\tdis[ny][nx] = 1 + max(dis[ny-1][nx-1], max(dis[ny-1][nx], dis[ny-1][nx+1]));\n\t\t\t\t}else{\n\t\t\t\t\tdis[ny][nx] = max(dis[ny-1][nx-1], max(dis[ny-1][nx], dis[ny-1][nx+1]));\n\t\t\t\t}\n\t\t\t\tif(ma[ny][nx] <= n && ma[ny][nx] != 0){\n\t\t\t\t\t//printf(\"%d %d %d\\n\", dis[ny][nx], ma[ny][nx], n);\n\t\t\t\t\tif(ans < dis[ny][nx]){\n\t\t\t\t\t\tans = dis[ny][nx];\n\t\t\t\t\t\tfin = ma[ny][nx];\n\t\t\t\t\t}else if(ans == dis[ny][nx] && fin < ma[ny][nx] && prime[ma[ny][nx]] == 1){\n\t\t\t\t\t\tfin = ma[ny][nx];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint m,n,mp[1200][1200],dp[1200][1200];\nbool so[1000001];\nint main(){\n  int p=2,x=600,y=600,c=0,d=0;\n  int dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n  mp[600][600]=1;\n  while(p<=1e6+5000){\n    if(c%2==0)d++;\n    for(int i=0;i<d;i++)\n      y+=dy[c%4],x+=dx[c%4],mp[y][x]=p++;\n    c++;\n  }\n  so[1]=1;\n  for(int i=2;i*i<=1e6;i++)\n    if(!so[i])for(int j=2;j*i<=1e6;j++)so[i*j]=1;\n  while(cin>>m>>n,n){\n    for(int i=0;i<1200;i++)\n      for(int j=0;j<1200;j++)\n\tif(mp[i][j]==n)dp[i][j]=!so[n];\n\telse dp[i][j]=-1e8;\n    int ans=0,p=0;\n    for(int i=10;i<1190;i++)\n      for(int j=10;j<1190;j++){\n\tfor(int k=-1;k<=1;k++){\n\t  if(mp[i+1][j+k]>m)continue;\n\t  dp[i+1][j+k]=max(dp[i+1][j+k],dp[i][j]+!so[mp[i+1][j+k]]);\n\t}\n\tif(!so[mp[i][j]]){\n\t  if(dp[i][j]>ans)ans=dp[i][j],p=mp[i][j];\n\t  if(dp[i][j]==ans&&p<mp[i][j])p=mp[i][j];\n\t  }\n      }\n    cout<<ans<<\" \"<<p<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define FOR(i,a,n) for(int i = (a);i < (n);i++)\nconst int MAX_E = 1e3 + 3;\nconst int START = MAX_E / 2;\nconst int N = 1e6 + 3;\nconst int INF = 1e9;\nint p[N];\nvoid e(){\n  fill(p,p+N,1);\n  p[0] = p[1] = 0;\n  for(int i = 2;i*i<=N;i++)\n    if(p[i] == 1)for(int j = i*i;j<=N;j+=i)p[j] = 0;\n}\n\nmap<pair<int,int> ,int> mp;\n\ninline pair<int,int> pmax(pair<int,int> a, pair<int,int> b,int x,int y){\n  // a is pre\n  if(p[mp[make_pair(x,y)]]){\n    a.first++;\n    b.second = mp[make_pair(x,y)];\n    a.second = mp[make_pair(x,y)];\n    if(a.first > b.first)return a;\n    else return b;\n  }else{\n    if(a.first > b.first)return a;\n    else return b;\n  }\n}\n\nint main(){\n  int n,m;\n\n  int dx[4] = {1,0,-1,0};\n  int dy[4] = {0,-1,0,1};\n  e();\n  pair<int,int> co[MAX_E][MAX_E];// n, is prime\n  pair<int,int> dp[MAX_E][MAX_E];// first is num, second is prime\n  int rx =START,lx = START,uy = START,ly = START;\n  int x = START,y = START,mode = 0;\n  FOR(i,1,N){\n    mp[make_pair(x,y)] = i;\n    x += dx[mode];\n      y += dy[mode];\n      if(mode == 0 && x > rx){rx = x;mode++;}\n      if(mode == 1 && y > uy){uy = y;mode++;}\n      if(mode == 2 && x < lx){lx = x;mode++;}\n      if(mode == 3 && y < ly){ly = y;mode++;}\n  }\n\n\n  \n  while(cin>>n>>m,n){\n    int rx =START,lx = START,uy = START,ly = START;\n\n    int x = START,y = START,mode = 0;\n    int sx,sy;\n    fill(co[0],co[MAX_E],make_pair(INF,0));\n    FOR(i,1,n+1){\n      if(i == m){//get start\n      sx = x,sy = y;\n      }\n\n      co[MAX_E/2 + x][MAX_E/2 + y] = make_pair(i,p[i]);\n      x += dx[mode];\n      y += dy[mode];\n      if(mode == 0 && x > rx){rx = x;mode++;}\n      if(mode == 1 && y > uy){uy = y;mode++;}\n      if(mode == 2 && x < lx){lx = x;mode++;}\n      if(mode == 3 && y < ly){ly = y;mode++;}\n    }\n\n    int prelx = x,prerx = x;\n    int nowlx = x-1,nowrx = x;\n    sy--;\n    for(;sy >= ly;sy--){\n      if(co[nowlx][nowrx].first != INF)nowlx--;\n      if(co[nowrx][nowrx].first != INF)nowrx++;\n      for(int i  = nowlx; i <= nowrx;i++){\n        if(i < prerx) dp[i][sy] = pmax(dp[i][sy],dp[i][sy],i,sy);\n        if(i <= prerx && i >= prelx)dp[i][sy] = pmax(dp[i][sy+1], dp[i][sy],i,sy);\n        if(i > prelx)dp[i][sy] = pmax(dp[i-1][sy+1], dp[i][sy],i,sy);\n      }\n      prelx = nowlx;\n      prerx = nowrx;\n    }\n    pair<int,int> ans = make_pair(0,0);\n\n    rx =START,lx = START,uy = START,ly = START;\n    x = START,y = START,mode = 0;\n    FOR(i,1,n+1){\n      if(dp[x][y].first > ans.first)ans = dp[x][y];\n      if(dp[x][y].first == ans.first && dp[x][y].second > ans.second)ans = dp[x][y];\n    x += dx[mode];\n      y += dy[mode];\n      if(mode == 0 && x > rx){rx = x;mode++;}\n      if(mode == 1 && y > uy){uy = y;mode++;}\n      if(mode == 2 && x < lx){lx = x;mode++;}\n      if(mode == 3 && y < ly){ly = y;mode++;}\n    }\n    cout << ans.first << ' ' << ans.second << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\n// difine\ntypedef pair<int, int> pii;\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\n// input\nint m, n;\nbool prime[1010][1010];\nint map[1010][1010];\n\nint med = 1010/2;\nint MAX = (int)1e6;\n\n// method\nbool isPrime(int x) {\n\tfor (int i=2; i*i<=x; i++) if (x%i==0) return false;\n\treturn x>1;\n}\n\nvoid make_map() {\n\tmemset(map, 0, sizeof(map));\n\t\n\tint num = 1, d = 0;\n\tint x = med, y = med;\n\t\n\tfor (int i=1; i<=MAX; i++) {\n\t\tmap[y][x] = num;\n\t\tprime[y][x] = isPrime(num);\n\t\t\n\t\tif (map[y + dy[(d+1)%4]][x + dx[(d+1)%4]]==0) d = (d+1)%4;\n\t\tx += dx[d]; y += dy[d];\n\t\tnum++;\n\t}\n\t\n\t/*\n\tfor (int i=med - 5; i<med + 5; i++) {\t\n\t\tfor (int j=med-5; j<med + 5; j++) {\n\t\t\tprintf(\"%3d \", map[i][j]);\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n}\n\npii dp[1010][1010];\n\nvoid solve() {\n\tfor (int i=0; i<1010; i++) for (int j=0; j<1010; j++) {\n\t\tdp[i][j] = make_pair(-1, 0);\n\t\tif (map[i][j] == n && prime[i][j]) dp[i][j] = make_pair(1, n);\n\t\telse if (map[i][j] == n) dp[i][j] = make_pair(0, 0);\n\t}\n\t\n\tfor (int i=0; i<1009; i++) {\n\t\tfor (int j=0; j<1009; j++) {\n\t\t\tif (dp[i][j].first < 0) continue;\n\t\t\t\n\t\t\tif (map[i+1][j-1] <= m) {\n\t\t\t\tif (prime[i+1][j-1]) {\n\t\t\t\t\tpii nxt(dp[i][j].first + 1, map[i+1][j-1]);\n\t\t\t\t\tdp[i+1][j-1] = max(dp[i+1][j-1], nxt);\n\t\t\t\t} else {\n\t\t\t\t\tdp[i+1][j-1] = max(dp[i+1][j-1], dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (map[i+1][j] <= m) {\n\t\t\t\tif (prime[i+1][j]) {\n\t\t\t\t\tpii nxt(dp[i][j].first + 1, map[i+1][j]);\n\t\t\t\t\tdp[i+1][j] = max(dp[i+1][j], nxt);\n\t\t\t\t} else {\n\t\t\t\t\tdp[i+1][j] = max(dp[i+1][j], dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (map[i+1][j+1] <= m) {\n\t\t\t\tif (prime[i+1][j+1]) {\n\t\t\t\t\tpii nxt(dp[i][j].first + 1, map[i+1][j+1]);\n\t\t\t\t\tdp[i+1][j+1] = max(dp[i+1][j+1], nxt);\n\t\t\t\t} else {\n\t\t\t\t\tdp[i+1][j+1] = max(dp[i+1][j+1], dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpii ans(-1, 0);\n\tfor (int i=0; i<1010; i++) for (int j=0; j<1010; j++) ans = max(ans, dp[i][j]);\n\tcout << ans.first << \" \" << ans.second << endl;\n}\n\nint main() {\n\tmake_map();\n\t\n\twhile (1) {\n\t\tcin >> m >> n; if (m==0 && n==0) break;\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nbool prime[1000001];\nint mas[1004][1004];\npair< int, int > dp[1004][1004];\nint v[1004][1004], now;\nint px[1000001], py[1000001];\nconst int vy[] = {0, -1, 0, 1}, vx[] = {1, 0, -1, 0};\npair< int, int > result[114514];\n\npair< int, int > rec(int x, int y)\n{\n  if(mas[y][x] == 0) return (make_pair(0, 0));\n  if(v[x][y] == now) return (dp[x][y]);\n  pair< int, int > ret(0, 0);\n  for(int nx = x - 1; nx <= x + 1; nx++) {\n    ret = max(ret, rec(nx, y + 1));\n  }\n  if(!prime[mas[y][x]]) {\n    if(ret.second == 0) ret.second = mas[y][x];\n    ret.first++;\n  }\n  v[x][y] = now;\n  return(dp[x][y] = ret);\n}\nint main()\n{\n  prime[1] = 1;\n  for(int i = 2; i * i < 1000001; i++) {\n    if(prime[i] == 0) {\n      for(int j = i + i; j < 1000001; j += i) prime[j] = 1;\n    }\n  }\n  vector< tuple< int, int, int > > query;\n  for(int i = 0; ; i++) {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    if(n == 0) break;\n    query.emplace_back(n, m, i);\n  }\n  sort(begin(query), end(query));\n\n  int shake = 1, x = 501, y = 501, a = 3;\n  for(auto& k : query) {\n    int n, m, idx;\n    tie(n, m, idx) = k;\n    now = idx;\n    for(int i = shake; i <= n; i++) {\n      mas[y][x] = i;\n      px[i] = x, py[i] = y;\n      if(mas[y + vy[(a + 1) % 4]][x + vx[(a + 1) % 4]] == 0) a = (a + 1) % 4;\n      y += vy[a], x += vx[a];\n    }\n    shake = n + 1;\n    result[idx] = rec(px[m], py[m]);\n  }\n  for(int i = 0; i < query.size(); i++) {\n    printf(\"%d %d\\n\", get< 0 >(result[i]), get< 1 >(result[i]));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define eb emplace_back\n#define ef emplace_front\n#define pb pop_back\n#define pf pop_front\n#define all(c) std::begin(c), std::end(c)\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n#define popcnt __builtin_popcountll\n\nusing uint = unsigned;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\ntemplate<typename T>\nusing max_pq = priority_queue<T, vector<T>, less<T>>;\n\ntemplate<typename T>\nusing min_pq = priority_queue<T, vector<T>, greater<T>>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int dx8[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline bool chmax(T &x, U y){ if (x >= y) return false; x = y; return true; }\n\ntemplate<typename T, typename U>\ninline bool chmin(T &x, U y){ if (x <= y) return false; x = y; return true; }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(std::begin(c), std::end(c)); c.erase(std::unique(all(c)), std::end(c)); }\n\n// }}}\n\nusing pr = pair<int, int>;\n\nint m, n;\nint a[2000][2000];\nint px[1000010], py[1000010];\nint dp[2000][2000];\nint p[1000010];\n\nint main()\n{\n\tloop(i, 2, 1000010) p[i] = 1;\n\tfor (int i = 2; i * i <= 1000010; i++){\n\t\tfor (int j = i * i; j <= 1000010; j += i){\n\t\t\tp[j] = 0;\n\t\t}\n\t}\n\n\twhile (cin >> m >> n, m){\n\t\tmemset(a, -1, sizeof(a));\n\t\tmemset(px, -1, sizeof(px));\n\t\tmemset(py, -1, sizeof(py));\n\t\tfill_n(*dp, 2000 * 2000, -INF);\n\n\t\tvector<int> v;\n\t\tfor (int i = 0, d = 3;; i++){\n\t\t\trep(j, i / 2 + 1) v.eb(d);\n\t\t\td = (d + 1) % 4;\n\t\t\tif (v.size() > m) break;\n\t\t}\n\n\t\tint x = 1000, y = 1000;\n\t\trep(i, m){\n\t\t\ta[x][y] = i + 1;\n\t\t\tpx[i + 1] = x;\n\t\t\tpy[i + 1] = y;\n\t\t\tx += dx[v[i]];\n\t\t\ty += dy[v[i]];\n\t\t}\n\t\t\n\t\tdp[px[n]][py[n]] = p[a[px[n]][py[n]]];\n\t\trep(i, 2000) rep(j, 2000){\n\t\t\tif (pr(i, j) <= pr(px[n], py[n])) continue;\n\t\t\tif (a[i][j] == -1) continue;\n\t\t\tdp[i][j] = p[a[i][j]] + max({\n\t\t\t\tdp[i - 1][j - 1],\n\t\t\t\tdp[i - 1][j],\n\t\t\t\tdp[i - 1][j + 1]\n\t\t\t});\n\t\t}\n\t\t\n\t\tpr res(0, 0);\n\t\trep(i, 2000) rep(j, 2000){\n\t\t\tif (dp[i][j] <= 0) continue;\n\t\t\tif (p[a[i][j]]) chmax(res, pr(dp[i][j], a[i][j]));\n\t\t}\n\n\t\tcout << res.fi << \" \" << res.se << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\nusing namespace std;\n#define N 1000\n#define N2 N*N\nbool prime[N2+1];\nint cave[N+2][N+2]={};\npair<int,int> locate[N2+1];\nint last[N+2][N+2];\nint dp[N+2][N+2];\nint m,n;\n\nbool wall(int x,int y){ return x==0 || y==0 || x==N+1 || y==N+1; }\n\nint rec(int x,int y){\n    if(wall(x,y) || cave[x][y]>m)return 0;\n    if(dp[x][y])return dp[x][y];\n    pair<int,int> child[3];\n    rep(i,3)child[i]=pair<int,int>(rec(x+i-1,y-1),last[x+i-1][y-1]);\n    sort(child,child+3);\n    dp[x][y]=child[2].first;\n    if(prime[cave[x][y]])dp[x][y]++;\n    last[x][y]=child[2].second;\n    if(last[x][y]==0 && prime[cave[x][y]]) last[x][y]=cave[x][y];\n    return dp[x][y];\n}\n\nint main(void){\n    fill(prime,prime+N2+1,true);\n    prime[0]=prime[1]=false;\n    for(int i=2;i<=N2;i++){\n        if(prime[i]) for(int k=2;i*k<=N2;k++) prime[i*k]=false;\n    }\n\n    int x=1,y=N,d=0;\n    int dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n    for(int i=N2;i>0;i--){\n        cave[x][y]=i;\n        locate[i] = pair<int,int>(x,y);\n        if(wall(x+dx[d],y+dy[d]) || cave[x+dx[d]][y+dy[d]]) d=(d+1)%4;\n        x+=dx[d];\n        y+=dy[d];\n    }\n\n    while(cin>>m>>n, m|n){\n        rep1(x,N)rep1(y,N) dp[x][y]=last[x][y]=0;\n        int x=locate[n].first,y=locate[n].second;\n        int cnt = rec(x,y);\n        printf(\"%d %d\\n\",cnt,last[x][y]);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\n#define SIZE 1000\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\t\t/*\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}*/\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}/*\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}*/\n\t\t\n\t\toutput = false;\n\t\tfor (int i = 0;i < SIZE&&(!output);i++) {\n\t\t\tfor (int j = 0;j < SIZE&&(!output);j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tprintf(\"%d %d\\n\", dp[i][j], pr[i][j]);\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define pb push_back\ntypedef pair<int,int> pi;\n#define MAX 1000000\nint isprime[1145141];\nint table[2000][2000];\npi S[1145141];\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,-1,0,1};\nvoid eratos(int n)\n{\n  rep(i,n+1)isprime[i]=true;\n  isprime[0]=isprime[1]=false;\n  for(int i=2;i*i<=n;i++)\n    {\n      if(isprime[i])\n\t{\n\t  int j = i + i;\n\t  while(j <= n)\n\t    {\n\t      isprime[j] = false;\n\t      j = j + i;\n\t    }\n\t}\n      \n    }\n  \n}\nint main(){\n  eratos(MAX);\n  //table turkuru\n  memset(table,0,sizeof(table));\n  int now = 2;\n  int dist = 1;\n  int cnt = 0;\n  int dir = 0;\n  int y = 1000;\n  int x = 1000;\n  table[y][x]=1;\n  S[1] = pi(y,x);\n  while(now <= MAX)\n    {\n      if(cnt < dist)\n\t{\n\t  y += dy[dir];\n\t  x += dx[dir];\n\t  table[y][x] = now;\n\t  S[now] = pi(y,x);\n\t  cnt++;\n\t  now++;\n\t}\n      else\n\t{\n\t  dir = (dir+1)%4;\n\t  if(dir == 2 || dir == 0)dist++;\n\t  y += dy[dir];\n\t  x += dx[dir];\n\t  table[y][x] = now;\n\t  S[now] = pi(y,x);\n\t  cnt = 1;\n\t  now++;\n\t}\n    }\n  /*rep(i,2000)\n    {\n      rep(j,2000)\n\t{\n\t  printf(\"%d \", table[i][j]);\n\t}\n\t    printf(\"\\n\");    \n\t    }*/\n  //cout << table[1000][1000]<< endl;\n  //cout << table[1001][1001] << endl;\n  int M, N;\n  int ans;\n  int pp;\n  int ey[3] = {1,1,1};\n  int ex[3] = {-1,0,1};\n  while(true){\n    cin >> M >> N;\n    if(M==0&&N==0)break;\n    queue<pi> Q;\n    queue<int> R;\n    ans = 0;\n    pp = 0;\n    Q.push(pi(S[N].first,S[N].second));\n    R.push(0);\n    while(!R.empty())\n      {\n\tint ty = Q.front().first;\n\tint tx = Q.front().second;\n\tint point = R.front();\n\tQ.pop();R.pop();\n\tif(isprime[table[ty][tx]])\n\t  {\n\t    point++;\n\t  }\n\tif(ans <= point)\n\t  {\n\t    if(ans < point)pp = table[ty][tx];\n\t    else pp = max(table[ty][tx],pp);\n\t    ans = point;\n\t    \n\t  }\n\t//ans = max(ans,point);\n\trep(r,3)\n\t  {\n\t    int y = ty + ey[r];\n\t    int x = tx + ex[r];\n\t    \n\t    if(table[y][x]==0)continue;\n\t    if(table[y][x]>M)continue;\n\t    Q.push(pi(y,x));\n\t    R.push(point);\n\t  }\n\t\n      }\n    printf(\"%d %d\\n\", ans, pp);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <bitset>\n#include <assert.h>\n#include <unordered_map>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef pair<ll,ll> P;\ntypedef pair<int,int> pii;\ntypedef vector<P> vpl;\ntypedef tuple<ll,ll,ll> tapu;\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nconst int inf = 1<<30;\nconst ll linf = 1LL<<62;\nconst int MAX = 510000;\nll dy[8] = {0,-1,0,1,1,-1,1,-1};\nll dx[8] = {1,0,-1,0,1,-1,-1,1};\nconst double pi = acos(-1);\nconst double eps = 1e-7;\ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){\n\tif(a>b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){\n\tif(a<b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T> inline void print(T &a){\n    rep(i,a.size()) cout << a[i] << \" \";\n    cout << \"\\n\";\n}\ntemplate<typename T1,typename T2> inline void print2(T1 a, T2 b){cout << a << \" \" << b << \"\\n\";}\ntemplate<typename T1,typename T2,typename T3> inline void print3(T1 a, T2 b, T3 c){\n\tcout << a << \" \" << b << \" \" << c << \"\\n\";\n}\nconst ll mod = 1e9 + 7;\n//const int mod = 998244353;\n\nint prime[1010101];\nbool isprime[1010101];\n\nint sieve(int n){\n    int p = 0;\n    for(int i=0; i<=n; i++) isprime[i] = true;\n    isprime[0] = isprime[1] = false;\n    for(int i=2; i<=n; i++){\n        if(isprime[i]){\n            prime[p++] = i;\n            for(int j=2*i; j<=n; j+=i) isprime[j] = false;\n        }\n    }\n    return p;\n}\n\nint hora[1010][1010];\npii pos[1010101];\nint dp[1010][1010];\n\nint main(){\n    sieve(1000000);\n    int y = 501, x = 501;\n    int now = 1;\n    int add = 1;\n    int d = 0;\n    while(now <= 1000000){\n        rep(i,add){\n            hora[y][x] = now;\n            pos[now] = pii(y,x);\n            now++;\n            y += dy[d];\n            x += dx[d];\n        }\n        if(d & 1) add++;\n        d = (d + 1) % 4;\n    }\n    while(1){\n        int n,m; cin >> n >> m;\n        if(n+m == 0) break;\n        pii cur = pos[m];\n        rep(i,1001) rep(j,1001) dp[i][j] = -1;\n        dp[cur.first][cur.second] = isprime[m];\n        REP(i,cur.first+1,1001){\n            rep(j,1001){\n                if(hora[i][j] > n) continue;\n                int c = isprime[hora[i][j]];\n                if(j > 0 && dp[i-1][j-1] != -1){\n                    chmax(dp[i][j], dp[i-1][j-1] + c);\n                }\n                if(dp[i-1][j] != -1) chmax(dp[i][j], dp[i-1][j] + c);\n                if(j < 999 && dp[i-1][j+1] != -1){\n                    chmax(dp[i][j], dp[i-1][j+1] + c);\n                } \n            }\n        }\n        int ans = 0, p = 0;\n        rep(i,1001) rep(j,1001) chmax(ans, dp[i][j]);\n        rep(i,1001) rep(j,1001){\n            if(ans == dp[i][j] && isprime[hora[i][j]]) chmax(p, hora[i][j]);\n        }\n        if(ans == 0) puts(\"0 0\");\n        else print2(ans, p);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int MAX_M = 1000001;\nconst int C = 1000;\nconst int INF = 1e9;\n#define y first\n#define x second\n\nmap<int, P> itop;\nmap<P, int> ptoi;\nbool isp[MAX_M];\n\nvoid make_prime(){\n  REP(i, MAX_M) isp[i] = true;\n  isp[0] = isp[1] = false;\n  FOR(i, 2, sqrt(MAX_M) + 1){\n    if(!isp[i]) continue;\n    for(int j = i + i; j < MAX_M; j += i) isp[j] = false;\n  }\n}\n\nvoid init(){\n  P now = P(C / 2, C / 2);\n  int c[C][C], pls = 1, l = 1, step = 0, d = 0;\n  memset(c, 0, sizeof(c));\n  FOR(i, 1, MAX_M){\n    itop[i] = now;\n    ptoi[now] = i;\n    if(d == 0) now.x += 1;\n    else if(d == 1) now.y -= 1;\n    else if(d == 2) now.x -= 1;\n    else if(d == 3) now.y += 1;\n    ++step;\n    if(step >= l){\n      d = (d + 1) % 4;\n      step = 0;\n    }\n    if(i != 1 && (d == 0 || d == 2) && step == 0) ++l;\n  }\n}\n\nint main() {\n  make_prime();\n  init();\n  int M, N;\n  while(cin >>M >>N && (N && M)){\n    P dp[C][C];\n    REP(i, C) REP(j, C) dp[i][j] = P(-1, -1);\n    P now = itop[N], ans = P(-1, -1);\n    dp[now.y][now.x] = (isp[N] ? P(1, N) : P(0, -1));\n    REP(y, C - 1){\n      REP(x, C){\n        if(dp[y][x].first == -1 || ptoi.find(P(y, x)) == ptoi.end()) continue;\n        ans = max(ans, dp[y][x]);\n        for(int mx = -1; mx <= 1; ++mx){\n          int ny = y + 1, nx = x + mx;\n          if(ptoi.find(P(ny, nx)) == ptoi.end()) continue;\n          int cnt = dp[y][x].first + (isp[ptoi[P(ny, nx)]] ? 1 : 0), num = (isp[ptoi[P(ny, nx)]] ? ptoi[P(ny, nx)] : dp[y][x].second);\n          if(num > M) continue;\n          if(cnt > dp[ny][nx].first || (cnt == dp[ny][nx].first && num > dp[ny][nx].second)) dp[ny][nx] = P(cnt, num);\n        }\n      }\n    }\n    if(ans.first == 0) cout <<\"0 0\" <<endl;\n    else cout <<ans.first <<\" \" <<ans.second <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define MAX_N 1000000\n#define MAX_X 1001\n#define MAX_Y 1000\n\nint cave[MAX_Y][MAX_X];\nbool sieve[MAX_N+1];\nint dp[MAX_N+1];\n\nint m, n;\n\nstruct P { int x, y; };\n\nP search_cave(int n) {\n    REP(y, MAX_Y) REP(x, MAX_X) {\n        if (cave[y][x] == n) {\n            return (P){x, y};\n        }\n    }\n    return (P){0, 0}; // fail\n}\n\nint main() {\n    sieve[0] = sieve[1] = true;\n    FOR(i, 2, MAX_N+1) {\n        if (sieve[i]) continue;\n        for (int j = i + i; j < MAX_N+1; j += i) {\n            sieve[j] = true;\n        }\n    }\n\n    int ul = 1000001; // upper left: 1000^2 + 1 = 1000001\n    REP(i, MAX_Y) {\n        cave[i][0] = ul + i;\n    }\n    // left -> down -> right -> up ->\n    int d = 0;\n    int dx[] = {1, 0, -1, 0}; int dy[] = {0, 1, 0, -1};\n    int x = 0, y = 0;\n    while (ul > 1) {\n        int sx = x + dx[d];\n        int sy = y + dy[d];\n        if (0 <= sx && sx < MAX_X && 0 <= sy && sy < MAX_Y && cave[sy][sx] == 0) {\n            x = sx;\n            y = sy;\n            ul--;\n            cave[y][x] = ul;\n        } else {\n            d = (d + 1) & 3; // d % 4\n        }\n    }\n\n    while (cin >> m >> n, m|n) {\n        fill_n(dp, MAX_N+1, -1);\n        P s = search_cave(n);\n        dp[n] = 0;\n        int max_primes = 0, max_cave = 0;\n        FOR(y, s.y, MAX_Y) REP(x, MAX_X) {\n            int c = cave[y][x];\n            if (c > m || dp[c] < 0) continue;\n            if (!sieve[c]) { // prime\n                dp[c]++;\n                if (max_primes <= dp[c]) {\n                    max_primes = dp[c];\n                    max_cave = c;\n                }\n            }\n            for (int dx = -1; dx <= 1; dx++) {\n                int sx = x + dx;\n                int sy = y + 1;\n                if (0 <= sx && sx < MAX_X && 0 <= sy && sy < MAX_Y) {\n                    int c2 = cave[sy][sx];\n                    if (c2 <= m) {\n                        dp[c2] = max(dp[c2], dp[c]);\n                    }\n                }\n            }\n        }\n        cout << max_primes << \" \" << max_cave << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n// ????????????\nconst int dx[] = {1,0,-1,0}; const int dy[] = {0,-1,0,1};\n\nconst int MAX_H = 1003;\nconst int MAX_W = 1003;\n\nconst int MAX_M = 1e6;\n\nbool prime[MAX_M+1];\nint cave[MAX_H][MAX_W];\n\nvoid find_start(int start_num, int& sx, int& sy) {\n    REP(y, MAX_H) REP(x, MAX_W) {\n        if (cave[y][x] == start_num) {\n            sx = x;\n            sy = y;\n            return;\n        }\n    }\n}\n\nint main() {\n    prime[0] = prime[1] = true;\n    FOR(i, 2, MAX_M+1) {\n        if (prime[i]) continue;\n        for (int j = i+i; j < MAX_M+1; j += i) {\n            prime[j] = true;\n        }\n    }\n\n    int y = MAX_H/2+1, x = MAX_W/2+1;\n    int d = 0;\n    FOR(i, 1, MAX_M+1) {\n        cave[y][x] = i;\n        y += dy[d];\n        x += dx[d];\n        int d2 = (d + 1) % 4;\n        if (cave[y + dy[d2]][x + dx[d2]] == 0) {\n            d = d2;\n        }\n    }\n\n    int caves, start_n;\n    while (cin >> caves >> start_n, caves|start_n) {\n        int x, y;\n        find_start(start_n, x, y);\n\n        pii res = {0, 0}; // ?????°, ?´???°?´?????????????\n\n        vector<int> G(MAX_W, -1);\n        G[x] = 0;\n        bool updated;\n        do {\n            updated = false;\n            vector<int> G2(G);\n            REP(x, MAX_W) {\n                if (G[x] == -1) continue;\n\n                if (!prime[cave[y][x]]) {\n                    G[x]++;\n                    pair<int, int> r(G[x], cave[y][x]);\n                    res = max(res, r);\n                }\n                for (int dx = -1; dx <= 1; dx++) {\n                    int sx = x + dx;\n                    int sy = y + 1;\n                    if (0 <= sx && sx < MAX_W && 0 <= sy && sy < MAX_H) {\n                        if (cave[sy][sx] != 0 && cave[sy][sx] <= caves) {\n                            G2[sx] = max(G[x], G2[sx]);\n                            updated = true;\n                        }\n                    }\n                }\n            }\n            G = G2;\n            y++;\n        } while (updated);\n        printf(\"%d %d\\n\", res.first, res.second);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE * SIZE + 1];\n\tint table[SIZE][SIZE];\n\tint dp[SIZE][SIZE];\n\tint pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tint res1, res2;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0;i < SIZE;i++) {\n\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\ttable[i][j] = i*SIZE + j + 1;\n\t\t}\n\t}\n\t/*\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}*/\n\twhile (true) {\n\t\tscanf(\"%d %d\", &m, &n);\n\t\tif (m == 0 || n == 0)return 0;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = SIZE - 1;i >= 0;i--){\n\t\t\tfor(int j = SIZE - 1;j >= 0;j--){\n\t\t\t\tif (table[i][j] <= m) {\n\t\t\t\t\tif (i + 1 < SIZE) {\n\t\t\t\t\t\tif (j > 0 && table[i + 1][j - 1] <= m && (dp[i][j] < dp[i + 1][j - 1] || (dp[i][j] == dp[i + 1][j - 1] && pr[i][j] < pr[i + 1][j - 1]))) {\n\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j - 1];\n\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j - 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (table[i + 1][j] <= m && (dp[i][j] < dp[i + 1][j] || (dp[i][j] == dp[i + 1][j] && pr[i][j] < pr[i + 1][j]))) {\n\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j];\n\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j + 1 < SIZE && table[i + 1][j + 1] <= m && (dp[i][j] < dp[i + 1][j + 1] || (dp[i][j] == dp[i + 1][j + 1] && pr[i][j] < pr[i + 1][j + 1]))) {\n\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j + 1];\n\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!prime[table[i][j]]) {\n\t\t\t\t\t\tdp[i][j]++;\n\t\t\t\t\t\tif (pr[i][j] == 0) {\n\t\t\t\t\t\t\tpr[i][j] = table[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tprintf(\"%d %d\\n\", dp[i][j], pr[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (y>=0&&x>=0&&table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]==dp[y + 1][x - 1]&&pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x] == dp[y + 1][x] && pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x] == dp[y + 1][x + 1] && pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t\n\t\tfor (int h = 0;h < SIZE;h++) {\n\t\t\tfor (int w = 0;w < SIZE;w++) {\n\t\t\t\tif (table[h][w] == n) {\n\t\t\t\t\tcout << dp[h][w] << \" \";\n\t\t\t\t\tcout << pr[h][w] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n\nusing namespace std;\n  \n#define MP make_pair\n#define PB push_back\n#define MAX_N 2001000\n#define SIZE 2000\n#define X first\n#define Y second\n  \nconst int STX = 1000, STY = 1000;\n\ntypedef pair<int, int> Pii;\ntypedef pair<int, Pii> P;\n  \nint id[SIZE][SIZE];\nbool is_prime[MAX_N+1];\nvector<Pii> coord;\n\nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++)\n    if(is_prime[i])\n      for(int j=i*i; j<=MAX_N; j+=i)\n\tis_prime[j] = false;\n}\n\nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  \n  coord.PB(MP(0, 0)); // no use\n  cnt ++;\n  coord.PB(MP(x, y)); // cnt = 1\n  \n  fill(id[0], id[0]+SIZE*SIZE+1, -1);\n  \n  const int dx[] = {0,-1,0,1};\n  const int dy[] = {-1,0,1,0};\n  \n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt <= MAX_N) {\n    a += 2;\n    for(int turn=0; turn<4; turn++) {\n      for(int i=0; i<a; i++) {\n\tx += dx[turn], y += dy[turn];\n\tcoord.PB(MP(x, y));\n\tid[y][x] = ++ cnt;\n      }\n    }\n    x++, y++;\n  }\n}\n\nint dp[MAX_N+1];\n\nint main() {\n  \n  Sieve();\n  MakeMap();\n  \n  int m, n;\n\n  while(cin >> m >> n && (m|n)) {\n    \n    fill(dp, dp+MAX_N+1, -1);\n    dp[n] = is_prime[n];\n    Pii ans(dp[n], n);\n    \n    queue<P> que;\n    que.push(P(dp[n], coord[n]));\n    while(!que.empty()) {\n      P now = que.front(); que.pop();\n      int tmpid = id[now.second.Y][now.second.X];\n      if(now.first < dp[tmpid]) continue;\n      \n      int noid = id[now.second.Y][now.second.X];\n      \n      for(int i=-1; i<=1; i++) {\n\tPii nex = MP(now.second.X+i, now.second.Y+1);\n\tif(nex.X < 0 || SIZE <= nex.X || nex.Y < 0 || SIZE <= nex.Y) continue;\n\tint neid = id[nex.Y][nex.X];\n\tif(neid <= m) {\n\t  if(dp[neid] < dp[noid] + is_prime[neid]) {\n\t    dp[neid] = dp[noid] + is_prime[neid];\n\t    if(is_prime[neid]) ans = max(ans, MP(dp[neid], neid));\n\t    que.push(P(dp[neid], nex));\n\t  }\n\t}\n      }\n\n    }\n    \n    if(ans.first == 0) cout << \"0 0\" << endl;\n    else cout << ans.first << ' ' << ans.second << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int MAX_M = 1000001;\nconst int MAX_C = 1000;\nconst int INF = 1e9;\n#define y first\n#define x second\n\nmap<P, int> ptoi;\nbool isp[MAX_M];\nP dp[MAX_C][MAX_C];\n\nvoid make_prime(){\n  REP(i, MAX_M) isp[i] = true;\n  isp[0] = isp[1] = false;\n  FOR(i, 2, sqrt(MAX_M) + 1){\n    if(!isp[i]) continue;\n    for(int j = i + i; j < MAX_M; j += i) isp[j] = false;\n  }\n}\n\nvoid init(){\n  P now = P(MAX_C / 2, MAX_C / 2);\n  int pls = 1, l = 1, step = 0, d = 0;\n  FOR(i, 1, MAX_M){\n    ptoi[now] = i;\n    if(d == 0) now.x += 1;\n    else if(d == 1) now.y -= 1;\n    else if(d == 2) now.x -= 1;\n    else if(d == 3) now.y += 1;\n    ++step;\n    if(step >= l){\n      d = (d + 1) % 4;\n      step = 0;\n    }\n    if(i != 1 && (d == 0 || d == 2) && step == 0) ++l;\n  }\n}\n\nint main() {\n  make_prime();\n  init();\n  int M, N;\n  while(cin >>M >>N && (N && M)){\n    REP(i, MAX_C) REP(j, MAX_C) dp[i][j] = P(-1, -1);\n    REP(i, MAX_C) REP(j, MAX_C) if(ptoi[P(i, j)] == N) dp[i][j] = (isp[N] ? P(1, N) : P(0, -1));\n    P ans = P(-1, -1);\n    REP(y, MAX_C){\n      REP(x, MAX_C){\n        if(dp[y][x].first == -1 || ptoi.find(P(y, x)) == ptoi.end() || ptoi[P(y, x)] > M) continue;\n        ans = max(ans, dp[y][x]);\n        for(int mx = -1; mx <= 1; ++mx){\n          int ny = y + 1, nx = x + mx;\n          if(ny < 0 || nx < 0 || ny >= MAX_C || nx >= MAX_C || ptoi.find(P(ny, nx)) == ptoi.end() || ptoi[P(ny, nx)] > M) continue;\n          int cnt = dp[y][x].first + (isp[ptoi[P(ny, nx)]] ? 1 : 0), num = (isp[ptoi[P(ny, nx)]] ? ptoi[P(ny, nx)] : dp[y][x].second);\n          if(cnt > dp[ny][nx].first || (cnt == dp[ny][nx].first && num > dp[ny][nx].second)) dp[ny][nx] = P(cnt, num);\n        }\n      }\n    }\n    if(ans.first == 0) cout <<\"0 0\" <<endl;\n    else cout <<ans.first <<\" \" <<ans.second <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT_ON(bit, i) (bit & (1LL << i))\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\ntemplate<typename T> using VVVV = std::vector<std::vector<std::vector<std::vector<T>>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = std::min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = std::max(a, b); }\ntemplate<class T> inline std::vector<T> unique(std::vector<T> v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v;\n}\n// 初項s, 交差dのn個の数列の和\nlong long sum_of_arithmetic_progression(long long s, long long d, long long n) {\n    return n * (2 * s + (n - 1) * d) / 2;\n}\n\nconst int INF = 1 << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = {0, -1, 0, 1}, dx4 = {1, 0, -1, 0};\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\n// nまでの素数のリストを作成(nを含む) O(N log log N)\nvector<bool> make_prime_list(int n) {\n    vector<bool> is_prime(n + 1, true);\n    is_prime[0] = false;\n    is_prime[1] = false;\n\n    vector<int> prime_list;\n    for (int i = 2; i < n + 1; ++i) {\n        if (!is_prime[i]) { continue; }\n        prime_list.emplace_back(i);\n\n        for (int j = i + i; j < n + 1; j += i) {\n            is_prime[j] = false;\n        }\n    }\n    return is_prime;  // すべての数値について素数かどうか\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    V<bool> is_prime = make_prime_list(1000010);\n\n    V<pair<int, int>> pos(1100000);\n    VV<int> f(1010, V<int>(1010, 0));\n    {\n        int y = 500, x = 500;\n        int no = 1;\n        int mode = 0;\n        int num = 0;\n        while (no < 1000010) {\n            FOR(i, 0, num / 2 + 1) {\n                pos[no] = make_pair(y, x);\n                f.at(y).at(x) = no++;\n                y += dy4[mode];\n                x += dx4[mode];\n            }\n            mode = (mode + 1) % 4;\n            num++;\n        }\n    }\n    while (true) {\n        int M, N;\n        cin >> M >> N;\n        if (M + N == 0) {\n            break;\n        }\n\n        int ans1 = 0, ans2 = 0;\n        queue<pair<int, int>> que;\n        que.emplace(pos[N]);\n        VV<int> dp(f.size(), V<int>(f[0].size(), -1));\n        if (is_prime[f[pos[N].first][pos[N].second]]) {\n            dp[pos[N].first][pos[N].second] = 1;\n            ans1 = 1;\n            ans2 = N;\n        }\n        else {\n            dp[pos[N].first][pos[N].second] = 0;\n        }\n\n        while (not que.empty()) {\n            int y = que.front().first;\n            int x = que.front().second;\n            que.pop();\n\n            for(int i = -1; i <= 1; ++i) {\n                if (not inside(y + 1, x + i, (int)f.size(), (int)f[0].size())) {\n                    continue;\n                }\n\n                int no = f[y + 1][x + i];\n                int d = is_prime[f[y + 1][x + i]];\n                if (no <= M and dp[y + 1][x + i] < dp[y][x] + d) {\n                    que.emplace(make_pair(y + 1, x + i));\n                    dp[y + 1][x + i] = dp[y][x] + d;\n\n                    if (d and dp[y + 1][x + i] > ans1) {\n                        ans1 = dp[y + 1][x + i];\n                        ans2 = no;\n                    }\n                    if (d and dp[y + 1][x + i] == ans1) {\n                        chmax(ans2, no);\n                    }\n                }\n            }\n        }\n        cout << ans1 << \" \" << ans2 << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nset<int> prime;\nint left(int a) {\n\tif (a == 1)\n\t\treturn 6;\n\tint loop;\n\tfor (int i = 1;i <= 1000;i += 2)\n\t\tif (a <= i*i) {\n\t\t\tloop = i;\n\t\t\tbreak;\n\t\t}\n\ta -= (loop - 2)*(loop - 2) + 1;\n\tif (a == 0)\n\t\treturn a + (loop - 2)*(loop - 2);\n\tif (0 < a&&a < (loop - 2))\n\t\treturn a + (loop - 2)*(loop - 2) + 1 - (1 + ((loop - 2) / 2) * 8);\n\tif ((loop - 2) <= a&&a < (loop - 2) + loop - 1)\n\t\treturn a + (loop - 2)*(loop - 2) + 1 + 1;\n\tif ((loop - 2) + loop - 1 <= a&&a < (loop - 2) + loop + loop - 1)\n\t\treturn a + (loop - 2)*(loop - 2) + 1 + (5 + (loop / 2) * 8);\n\tif ((loop - 2) + loop + loop - 1 <= a&&a <= (loop - 2) + loop + loop - 1 + loop - 1)\n\t\treturn a + (loop - 2)*(loop - 2) + 1 - 1;\n\treturn -1;\n}\nint right(int a) {\n\tif (a == 1)\n\t\treturn 2;\n\tint loop;\n\tfor (int i = 1;i <= 1000;i += 2)\n\t\tif (a <= i*i) {\n\t\t\tloop = i;\n\t\t\tbreak;\n\t\t}\n\ta -= (loop - 2)*(loop - 2) + 1;\n\tif (a < loop - 1)\n\t\treturn a + (loop - 2)*(loop - 2) + 1 + (1 + (loop / 2) * 8);\n\tif (a < loop - 1 + loop - 1)\n\t\treturn a + (loop - 2)*(loop - 2);\n\tif (a <= loop - 1 + loop - 1 + loop - 3)\n\t\treturn a + (loop - 2)*(loop - 2) + 1 - (5 + (((loop - 2) / 2) * 8));\n\treturn a + (loop - 2)*(loop - 2) + 1 + 1;\n}\nint down(int a) {\n\tif (a == 1)\n\t\treturn 8;\n\tint loop;\n\tfor (int i = 1;i <= 1001;i += 2)\n\t\tif (a <= i*i) {\n\t\t\tloop = i;\n\t\t\tbreak;\n\t\t}\n\ta -= (loop - 2)*(loop - 2) + 1;\n\tif (a == 0)\n\t\treturn loop*loop;\n\tif (a < loop - 1)\n\t\treturn a + (loop - 2)*(loop - 2);\n\tif (a < loop - 1 + loop - 2)\n\t\treturn a + (loop - 2)*(loop - 2) + 1 - (3 + (((loop - 2) / 2) * 8));\n\tif (a < loop - 1 + loop - 2 + loop - 1)\n\t\treturn a + (loop - 2)*(loop - 2) + 1 + 1;\n\treturn a + (loop - 2)*(loop - 2) + 1 + (7 + (loop / 2) * 8);\n}\nint main() {\n\tbool b[1000001] = { false };\n\tFOR(i, 2, 1000001) {\n\t\tif (!b[i]) {\n\t\t\tprime.insert(i);\n\t\t\tfor (int j = i + i;j < 1000001;j += i)\n\t\t\t\tb[j] = true;\n\t\t}\n\t}\n\tint m, n;\n\twhile (cin >> m >> n, m | n) {\n\t\tmap<int, int> vis;\n\t\tqueue<pii> Q;\n\t\tint ans = 0;\n\t\tint last = 0;\n\t\tif (EXIST(prime, n)) {\n\t\t\tans = 1;\n\t\t\tlast = n;\n\t\t}\n\t\tvis[n] = ans;\n\t\tQ.push({ n,ans });\n\t\twhile (!Q.empty()) {\n\t\t\tpii q = Q.front();Q.pop();\n\t\t\tif (q.second > ans) {\n\t\t\t\tans = q.second;\n\t\t\t\tlast = q.first;\n\t\t\t}\n\t\t\tif (q.second == ans) {\n\t\t\t\tif (EXIST(prime, q.first))\n\t\t\t\t\tlast = max(last, q.first);\n\t\t\t}\n\t\t\tREP(i, 3) {\n\t\t\t\tint q2;\n\t\t\t\tif (i == 0)\n\t\t\t\t\tq2 = down(q.first);\n\t\t\t\tif (i == 1)\n\t\t\t\t\tq2 = left(down(q.first));\n\t\t\t\tif (i == 2)\n\t\t\t\t\tq2 = right(down(q.first));\n\t\t\t\tif (q2 > m)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!EXIST(vis, q2))\n\t\t\t\t\tvis[q2] = -1;\n\t\t\t\tint pr = 0;\n\t\t\t\tif (EXIST(prime, q2))\n\t\t\t\t\tpr = 1;\n\t\t\t\tif (vis[q2] < q.second + pr) {\n\t\t\t\t\tvis[q2] = q.second + pr;\n\t\t\t\t\tQ.push({ q2,q.second + pr });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << ' ' << last << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(y=SIZE-1;y>=0;y--){\n\t\t\tfor(x=SIZE-1;x>=0;x--){\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&\n\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x - 1]||(dp[y][x] == dp[y + 1][x - 1] && pr[y][x] < pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && \n\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x] || (dp[y][x] == dp[y + 1][x] && pr[y][x] < pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && \n\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x + 1] || (dp[y][x] == dp[y + 1][x + 1] && pr[y][x] < pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int h = 0;h < SIZE;h++) {\n\t\t\tfor (int w = 0;w < SIZE;w++) {\n\t\t\t\tif (table[h][w] == n) {\n\t\t\t\t\tcout << dp[h][w] << \" \" << pr[h][w] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <deque>\n#include <utility>\n\n#define REP(i, n) FOR(i, 0, n)\n#define FOR(i, a, b) for(int i = int(a); i < int(b); ++i)\n#define RREP(i, n) RFOR(i, 0, n)\n#define RFOR(i, a, b) for(int i = int(b) - 1; i >= int(a); --i)\n\nstd::vector<bool> eratosthenes(int n) {\n\tstd::vector<bool> num(n + 1, true);\n\tstd::vector<int> prime;\n\tnum[1] = false;\n\tfor (int i = 2; i*i <= n; ++i) {\n\t\tif (num[i]) {\n\t\t\tfor (int j = 2; i*j <= n; ++j) {\n\t\t\t\tnum[i * j] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn num;\n}\n\nconst int MAXN = 2003;\n\nbool B[MAXN][MAXN];\nint num[MAXN][MAXN];\nusing PAIR = std::pair<int, int>;\nPAIR dp[MAXN][MAXN];\nPAIR pos[2000006];\n\nint dx4[] = { 1,0,-1,0 };\nint dy4[] = { 0,-1,0,1 };\n\nPAIR dfs(int y, int x, int m) {\n\tif (dp[y][x].first != -1) return dp[y][x];\n\tdp[y][x].first = 0;\n\n\tint dy = y + 1;\n\tFOR(dx, x - 1, x + 1 + 1) {\n\t\tif (num[dy][dx] > m) continue;\n\t\tdp[y][x] = std::max(dp[y][x], dfs(dy, dx, m));\n\t}\n\tif (B[y][x]) {\n\t\tif (dp[y][x].first == 0) {\n\t\t\tdp[y][x].second = num[y][x];\n\t\t}\n\t\t++dp[y][x].first;\n\t}\n\treturn dp[y][x];\n}\n\nsigned main() {\n\n\tREP(i, MAXN) REP(j, MAXN) {\n\t\tB[i][j] = false;\n\t\tnum[i][j] = 100000008;\n\t}\n\n\tauto prime(eratosthenes(2000006));\n\t{\n\t\tint d = 0;\n\t\tint x = MAXN / 2;\n\t\tint y = MAXN / 2;\n\t\tFOR(i, 1, 2000006) {\n\t\t\tB[y][x] = prime[i];\n\t\t\tnum[y][x] = i;\n\t\t\tpos[i] = PAIR(y, x);\n\n\t\t\twhile (true) {\n\t\t\t\tint dy = y + dy4[d];\n\t\t\t\tint dx = x + dx4[d];\n\n\t\t\t\tif (num[dy][dx] != 100000008) d = (d - 1 + 4) % 4;\n\t\t\t\telse {\n\t\t\t\t\ty = dy;\n\t\t\t\t\tx = dx;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\td = (d + 1) % 4;\n\t\t}\n\t}\n\n\t/*FOR(i, 990, 1010) {\n\t\tFOR(j, 990, 1010) {\n\t\t\tstd::string s(std::to_string(num[i][j]));\n\t\t\ts = std::string(4 - s.size(), ' ') + s;\n\t\t\tstd::cout << s << (B[i][j] ? '#' : ' ') << \" \";\n\t\t}\n\t\tstd::cout << \"\\n\";\n\t}*/\n\n\twhile (true) {\n\t\tint m, n;\n\t\tstd::cin >> m >> n;\n\t\tif (m == 0 && n == 0) break;\n\n\t\tREP(i, MAXN) REP(j, MAXN) dp[i][j] = PAIR(-1, 0);\n\n\t\tint y = pos[n].first;\n\t\tint x = pos[n].second;\n\n\t\tPAIR ans = dfs(y, x, m);\n\t\tstd::cout << ans.first << \" \" << ans.second << \"\\n\";\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define H 1000\n#define W 1000\nusing namespace std;\nint grid[H][W];\ntypedef pair<int, int> pii;\n\npii dp[(int)1e6 + 1];//first cnt, second max\nbool isprime[(int)1e6 + 1];\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid sieve(int n){\n  isprime[0] = isprime[1] = true;\n  for(int i = 2; i <= n; i++){\n    if(isprime[i])continue;\n    for(int j = 2*i; j <= n; j+=i)isprime[j] = true;\n  }\n}\n\n\nbool renge(int x, int y){\n  if(0 <= x && x < W &&\n     0 <= y && y < H)return true;\n  return false;\n}\nvector<int> inM(int y, int x, int m){\n  vector<int> res;\n  for(int i = -1; i < 2; i++){\n    if(grid[y + 1][x + i] <= m)res.push_back(i);\n  }\n  return res;\n}\n\nint main(int argc, char *argv[]){\n  sieve((int)1e6);\n  int n = H*W, m, x = 0, y = 0, dir = 0;\n  while(n > 1){\n    for(;renge(x + dx[dir], y + dy[dir]) && \n\t  grid[y + dy[dir]][x + dx[dir]] == 0;){\n      grid[y][x] = n;\n      n--;\n      x += dx[dir], y += dy[dir];\n    }\n    grid[y][x] = n;\n    n--;\n    dir++;\n    dir %= 4;\n    x += dx[dir], y += dy[dir];\n  }\n  while(cin >> m >> n, n){\n    memset(dp, 0, sizeof(dp));\n    for(int i = H - 1; i >= 0; i--){\n      for(int j = 0; j < W; j++){\n\tif(grid[i][j] <= m){\n\t  vector<int> cand = inM(i, j, m);\n\t  for(int k = 0; k < cand.size(); k++){\n\t    dp[grid[i][j]] = max(dp[grid[i][j]], dp[grid[i + 1][j + cand[k]]]);\n\t  }\n\t  if(!isprime[grid[i][j]]){\n\t    dp[grid[i][j]].first++;\n\t    if(dp[grid[i][j]].second == 0)dp[grid[i][j]].second = max(grid[i][j], dp[grid[i][j]].second);\n\t  }\n\t}\n      }\n    }\n    cout << dp[n].first << \" \" << dp[n].second << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\nint n,m,o;\nint t[1200][1200];\nint dp[1200][1200];\nint flg[1200][1200];\nint isP[1000001];\nint numx[1000001];\nint numy[1000001];\nint st[1000],size=0;\nint MAXvalue,MAXno;\nvoid make();\nvoid init();\n\nint main(){\n  m=1000000;\n  make();\n  \n  while(cin>>m>>n&&n){\n    MAXvalue=MAXno=0;\n    for(int i=0;i<1200;i++)for(int j=0;j<1200;j++)dp[i][j]=-1;\n    //cout<<numy[n]<<numx[n]<<endl;\n    flg[numy[n]][numx[n]]=t[numy[n]][numx[n]]*isP[t[numy[n]][numx[n]]];\n    dp[numy[n]][numx[n]]=isP[n];\n    for(int i=0;i<1200;i++){\n      for(int j=0;j<1200;j++){\n\tif(t[i][j]==0||t[i][j]>m||dp[i][j]==-1)continue;\n\t//cout<<t[i][j]<<endl;\n\tdp[i+1][j-1]=dp[i+1][j]=dp[i+1][j+1]=0;\n\tfor(int k=j-1;k<j+2;k++){\n\t  if(dp[i-1][k]==-1)continue;\n\n\t  //  cout<<t[i][j]<<' '<<t[i-1][k]<<endl;\n\t  // cout<<isP[t[i][j]]<<endl;\n\t  if(dp[i-1][k]+isP[t[i][j]]>dp[i][j]){\n\t    dp[i][j]=dp[i-1][k]+isP[t[i][j]];\n\t    flg[i][j]=max(t[i][j]*isP[t[i][j]],flg[i-1][k]);\n\t  }else if(dp[i-1][k]+isP[t[i][j]]==dp[i][j]){\n\t    flg[i][j]=max(t[i][j]*isP[t[i][j]],flg[i-1][k]);\n\t  }\n\t}//k\n\t//cout<<t[i][j]<<' '<<flg[i][j]<<' '<<dp[i][j]<<endl;\n\tif(MAXvalue<dp[i][j]){\n\t  MAXvalue=dp[i][j];\n\t  MAXno=max(MAXno,flg[i][j]);\n\t}else if(MAXvalue==dp[i][j]){\n\t  MAXno=max(MAXno,flg[i][j]);\n\t}\n      }//j\n\n    }//i\n    cout<<MAXvalue<<' '<<MAXno<<endl;\n  }\n  return 0;\n}\nvoid make(){\n  for(int i=0;i<1200;i++){\n    for(int j=0;j<1200;j++){\n      dp[i][j]=t[i][j]=0;flg[i][j]=-1;}}\n\n  for(int i=0;i<1000001;i++)isP[i]=1;\n\n  isP[0]=isP[1]=0;\n  for(int i=2;i*i<1000001;i++){\n    if(!isP[i])continue;\n    for(int j=i*i;j<1000001;j+=i){\n      isP[j]=0;\n    }\n  }\n\n  int nx,ny,cnt=2,z=1,k;\n  nx=ny=600;\n  t[600][600]=1;\n  \n  while(cnt<=m){\n    //cout<<cnt<<endl;\n    for(k=nx+1;k<=nx+z;k++){\n      numy[cnt]=ny;numx[cnt]=k;\n      t[ny][k]=cnt++;\n      if(cnt>m)break;\n    }\n    nx+=z;\n    \n    for(k=ny-1;k>=ny-z;k--){\n      numy[cnt]=k;numx[cnt]=nx;\n      t[k][nx]=cnt++;\n      if(cnt>m)break;\n    }\n    ny-=z;\n\n    z++;\n  \n    \n    for(k=nx-1;k>=nx-z;k--){\n      numy[cnt]=ny;numx[cnt]=k;\n      t[ny][k]=cnt++;\n      if(cnt>m)break;\n    }\n    nx-=z;\n\n    for(k=ny+1;k<=ny+z;k++){\n      numy[cnt]=k;numx[cnt]=nx;\n      t[k][nx]=cnt++;\n      if(cnt>m)break;\n    }\n    ny+=z;\n    \n    z++;\n  }\n  /*\n  for(int i=numy[37];i<=numy[43];i++){\n    for(int j=numx[37];j<=numx[26];j++){\n      printf(\"%3d \",t[i][j]);\n    }\n    cout<<endl;\n  }\n  */\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n#define ALLNUM 1002\n#define fin cin\n\nint all, start;\nint map[ALLNUM][ALLNUM] = {};\n\nbool isPrime(int n){\n    if(n <= 1)return false;\n    if(n == 2)return true;\n    if(n % 2 == 0)return false;\n    \n    for(int i = 3; i * i <= n; i+=2){\n        if(n % i == 0)return false;\n    }\n    return true;\n}\n\nclass Pair{\n    \npublic:\n    int num;\n    int count;\n    \n    Pair(){\n        this->num = 0;\n        this->count = 0;\n    };\n    Pair(int _num){\n        if(isPrime(_num)){\n            this->num = _num;\n            this->count = 1;\n        }\n        else {this->num = this->count = 0;}\n    }\n    \n    Pair operator + (const Pair &p){\n        this->count += p.count;\n        if(p.num != 0)this->num = p.num;\n        return *this;\n    }\n    \n    void print(){\n        cout << this->count << \" \" << this->num;\n    }\n};\n\nbool come[ALLNUM][ALLNUM];\nPair pMap[ALLNUM][ALLNUM];\n\nvoid init(){\n    \n    for(int i = 0; i < ALLNUM; i++){\n        for(int j = 0; j < ALLNUM; j++){\n            pMap[i][j] = Pair(0);\n            come[i][j] = false;\n        }\n    }\n}\n\nPair calc(int y, int x){\n    \n    if(map[y][x] > all)return Pair(-10);\n    if(come[y][x])return pMap[y][x];\n    \n    Pair p(map[y][x]);\n    Pair ans;\n    \n    Pair tmp1 = calc(y + 1, x);\n    Pair tmp2 = calc(y + 1, x + 1);\n    \n    if (tmp1.count == tmp1.count) {\n        if (tmp1.num < tmp2.num)tmp1.count--;\n    }\n    \n    if (tmp1.count < tmp2.count)ans =  tmp2;\n    else ans = tmp1;\n    \n    tmp1 = calc(y + 1, x - 1);\n    \n    if (tmp1.count < ans.count);\n    else ans = tmp1;\n    \n    /*\n     if (tmp1.count == tmp2.count) {\n     if(tmp1.num == tmp2.num)ans = tmp1;\n     else if(tmp1.num < tmp2.num)ans = tmp2;\n     else ans = tmp1;\n     }\n     else if(tmp1.count < tmp2.count)ans = tmp2;\n     else ans = tmp1;\n     \n     tmp2 = calc(y + 1, x - 1);\n     if (ans.count == tmp2.count) {\n     if(ans.num == tmp2.num);\n     else if(ans.num < tmp2.num)ans = tmp2;\n     else ;\n     }\n     else if(ans.count < tmp2.count)ans = tmp2;\n     else ;\n     */\n    \n    come[y][x] = true;\n    return pMap[y][x] = p + ans;\n}\n\nint main() {\n  //  ifstream fin(\"in.txt\");\n    \n    int x, y;\n    x = y = ALLNUM / 2;\n    \n    map[y][x] = 1;\n    \n    int gumi = 1;\n    int num = 1;\n    \n    while(num < (ALLNUM - 1) * (ALLNUM - 1)){\n        for(int i = 0; i < gumi; i++){\n            map[y][++x] = ++num;\n        }\n        if(num >= ALLNUM * ALLNUM)break;\n        \n        for(int i = 0; i < gumi; i++){\n            map[--y][x] = ++num;\n        }\n        if(num >= ALLNUM * ALLNUM)break;\n        \n        gumi++;\n        for(int i = 0; i < gumi; i++){\n            map[y][--x] = ++num;\n        }\n        if(num >= ALLNUM * ALLNUM)break;\n        \n        for(int i = 0; i < gumi; i++){\n            map[++y][x] = ++num;\n        }\n        if(num >= ALLNUM * ALLNUM)break;\n        gumi++;\n    }\n    \n    while(true){\n        fin >> all >> start;\n        if((all | start) == 0)break;\n        \n        init();\n        x = y = 0;\n        \n        for(int i = 0; i < ALLNUM; i++){\n            for(int j = 0; j < ALLNUM; j++){\n                if(map[j][i] == start){\n                    x = i;\n                    y = j;\n                    i = j = ALLNUM;//?????????break;\n                    break;\n                }\n            }\n        }\n        calc(y, x).print();\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define SIZE 1000\n\nbool C(int dp1, int pr1, int dp2, int pr2) {\n\tif (dp2 == 0)return false;\n\tif (dp1 < dp2 || (dp1 == dp2&&pr1 < pr2))return true;\n\treturn false;\n}\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;/*\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\t*/\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x - 1], pr[y + 1][x - 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x], pr[y + 1][x])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x + 1], pr[y + 1][x + 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\n\t\toutput = false;\n\t\tfor (int i = 0;i < SIZE&&!output;i++) {\n\t\t\tfor (int j = 0;j < SIZE&&!output;j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tprintf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<t.first<<\" \"<<t.second;}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nvi eratosthenes_sieve(int n){\n\tvi res(n+1);\n\tif(n<2) return res;\n\tres[2]=1;\n\tfor(int i=3;i<=n;i+=2){\n\t\tif(i*i<=n && !res[i]) for(int j=i+i+i;j<=n;j+=i+i) res[j]=1;\n\t\tres[i]=!res[i];\n\t}\n\treturn res;\n}\n\nint n, m;\nint pmap[2000][2000];\nint sx = 1000, sy = 1000;\nmap<int, pii> i2p;\n\nint d[4][2]={{1,0},{0,-1},{-1,0},{0,1}};\npii dp[2001][2001];\n\npii dfs(int y, int x, int upper){\n\tif(dp[y][x].first != -1) return dp[y][x];\n\tif(abs(pmap[y][x]) > upper) return dp[y][x] = pii(0, 0);\n\tpii res(0, 0);\n\tres = max(res, dfs(y+1, x-1, upper));\n\tres = max(res, dfs(y+1, x  , upper));\n\tres = max(res, dfs(y+1, x+1, upper));\n\tif(pmap[y][x] > 0){\n\t\tres.first ++;\n\t\tif(res.second == 0) res.second = pmap[y][x];\n\t}\n\treturn dp[y][x] = res;\n}\n\nmain(){\n\tvi isPrime = eratosthenes_sieve(1000001);\n\tint di = 0, px=sx, py=sy;\n\tfor(int i=1;i<=1000000;i++){\n\t\tpmap[py][px] = isPrime[i] ? i : -i;\n\t\ti2p[i] = pii(py, px);\n\t\tpx+=d[di][0];\n\t\tpy+=d[di][1];\n\t\tif(!pmap[py+d[(di+1)%4][1]][px+d[(di+1)%4][0]]) di=(di+1)%4;\n\t}\n\n\twhile(cin >> m >> n, m){\n\t\tREP(i, 2000)REP(j, 2000) dp[i][j] = pii(-1, -1);\n\t\tcout << dfs(i2p[n].first, i2p[n].second, m) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\nint dy[]={0,-1, 0, 1};\nint dx[]={-1,0, 1, 0};\n\nstruct aaa{\n    int maxi;\n    int prime;\n};\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nint hole[1000][1000],m,n;\nbool isp[1000001];\naaa memo[1003][1000];\n\naaa search(int y,int x){\n    if(memo[y][x].maxi >= 0)\n        return memo[y][x];\n\n    if((y > 999) || hole[y][x] > n){\n        aaa ret;\n        memo[y][x].maxi = memo[y][x].prime = 0;\n        return memo[y][x];\n    }\n\n    aaa ret;ret.maxi = ret.prime = 0;\n\n    for(int i = x - 1;i < x + 2;i++){\n        if(i < 0 || i > 999)\n            continue;\n\n        aaa b = search(y + 1,i);\n        if(b.maxi > ret.maxi || (b.maxi == ret.maxi && b.prime > ret.maxi))\n            ret = b;\n    }\n    if(ret.prime == 0 && isp[hole[y][x]])\n        ret.prime = hole[y][x];\n    ret.maxi += isp[hole[y][x]];\n    return memo[y][x] = ret;\n}\n\nint main(){\n    int d = 2;int x = 0;int y = 0;\n    RFOR(i,1,1000001){\n        hole[y][x] = i;\n        if(x + dx[d] < 0 || x + dx[d] > 999  || y + dy[d] < 0 || y + dy[d] > 999 || hole[y + dy[d]][x + dx[d]] > 0){\n            d = (d + 1) % 4;\n        }\n\n        x += dx[d]; y += dy[d];\n    }\n\n    memset(isp,true,sizeof(isp));isp[1] = false;\n    FOR(i,1,1001){\n        if(isp[i]){\n            for(int j = i * 2;j < 1000001;j += i)\n                isp[j] = false;\n        }\n    }\n\n    while(1){\n        scanf(\"%d%d\",&m,&n);\n        if(m == 0 && n == 0)\n            break;\n\n        aaa ans;\n        REP(i,1003)\n            REP(j,1000)\n                memo[i][j].maxi = -1;\n\n        REP(i,1000){\n            REP(j,1000){\n                if(hole[i][j] == n)\n                    ans = search(i,j); \n            }\n        }\n        printf(\"%d %d\\n\",ans.maxi,ans.prime);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//マップをつくる\n//ふるって素数マップ作る\n//dp[深さ][左端からの距離]で素数洞窟に入った回数をDP、素数かどうかはO(1)で判定\n#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<stdio.h>\nusing namespace std;\n\nclass Solver{\npublic:\n\tint isprime[1100000];\t//素数なら1、そうでないなら0を入れる\n\tint data[2001][2001];\t//マップデータ。\n\tint dp[1201][1201];\n\tint dp2[1201][1201];\n\t\n\tvoid SetPrime( int m ){\n\t\tint i,j;\n\t\tfor( i = 0; i <= m; i++ ) isprime[i] = 1;\n\t\tisprime[0] = 0; isprime[1] = 0;\n\t\tfor( i = 2; i <= m; i++ ){\n\t\t\tif( isprime[i] ) {\n\t\t\t\t//cout << i << endl;\n\t\t\t\tfor( j = i*2; j <= m; j += i )\n\t\t\t\t\tisprime[j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid uzumaki( int m ){\n\t\tint i,j;\n\t\tint ci=600,cj=600;\n\t\tint cnt=1;\n\t\tfor( i = 1; cnt <= m; i++ ){\n\t\t\t//→\n\t\t\tfor( j = 0; j <= i; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[i+ci][j+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//↑\n\t\t\tfor( j = 1; j <= 2*i-1; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[i-j+ci][i+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//←\n\t\t\tfor( j = 1; j <= 2*i; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[-i+1+ci][i-j+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//↓\n\t\t\tfor( j = 1; j <= 2*i; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[-i+1+j+ci][-i+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//→\n\t\t\tfor( j = 1; j < i; j++ ){\n\t\t\t\tif( cnt > m )\n\t\t\t\t\tbreak;\n\t\t\t\tdata[i+1+ci][-i+j+cj] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\t//デバッグ\n\t\t/*for( i = -16; i <= 16; i++ ){\n\t\t\tfor( j = -16; j <= 16; j++ ){\n\t\t\t\tif ( data[i+ci][j+cj] < 1000 && isprime[data[i+ci][j+cj]] )\n\t\t\t\t\tprintf(\"%4dp\",data[i+ci][j+cj]);\n\t\t\t\telse\n\t\t\t\t\tprintf(\"%5d\",data[i+ci][j+cj]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t}\n\t\n\tpair<int, int> search_ij(int m, int n) {\n\t\tint i,j;\n\t\tint ci=600,cj=600;\t//uzumakiと同じにしておくこと！\n\t\tint cnt=1;\n\t\tfor( i = 1; cnt <= m; i++ ){\n\t\t\tif ( data[i+1+ci][cj] < n ) {\n\t\t\t\tcnt = data[i+1+ci][cj];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//→\n\t\t\tfor( j = 0; j <= i; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(i+ci, j+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//↑\n\t\t\tfor( j = 1; j <= 2*i-1; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(i-j+ci, i+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//←\n\t\t\tfor( j = 1; j <= 2*i; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(-i+1+ci, i-j+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//↓\n\t\t\tfor( j = 1; j <= 2*i; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(-i+1+j+ci, -i+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t//→\n\t\t\tfor( j = 1; j < i; j++ ){\n\t\t\t\tif( cnt == n )\n\t\t\t\t\treturn pair<int, int>(i+1+ci, -i+j+cj);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\treturn pair<int, int>(-1, -1);\n\t}\n\t\n\tvoid DP( int m, int n ){\n\t\tint i,j;\n\t\tpair<int, int> ij = search_ij(m, n);\n\t\ti = ij.first; if ( i == -1 ) return;\n\t\tfor( ; i < 1200; i++ ) {\n\t\t\tfor( j = 0; j < 1200; j++ ) {\n\t\t\t\tdp[i][j] = -114514;\n\t\t\t\tdp2[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\ti = ij.first;\n\t\tj = ij.second;\n\t\tdp[i][j] = 0;\n\t\t\n\t\tfor( ; i < 1200; i++ ){\n\t\t\tfor( j = 0; j < 1200; j++ ){\n\t\t\t\t//今いる場所がゴールなら何もしない\n\t\t\t\tif ( data[i][j] > m || dp[i][j] < 0 )\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\t//今いる場所が素数か\n\t\t\t\tint c = isprime[ data[i][j] ];\n\t\t\t\tdp[i+1][j-1] = max( dp[i][j]+c, dp[i+1][j-1] );\n\t\t\t\tdp[i+1][j] = max( dp[i][j]+c, dp[i+1][j] );\n\t\t\t\tdp[i+1][j+1] = max( dp[i][j]+c, dp[i+1][j+1] );\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor( i = ij.first; i < 1200; i++ ){\n\t\t\tfor( j = 0; j < 1200; j++ ) {\n\t\t\t\tans = max(ans, dp[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//経路復元とついでにans2の更新。\n\t\t//ちなみに、ゴールからたどっていけば、たどった場所すべてがスタートからありつけるようにできるので、\n\t\t//ans2を直接更新することができる。(経路の候補が消える！ということがない)→嘘解法らしい。\n\t\t//したがって、ans2はdp2を全部埋めてから求めることにしよう。\n\t\t//…最後に通過した素数洞穴の番号＞＜＞＜！(↑は嘘解法ではなかったようです。誤読！！最大値じゃない！！誤読！！)\n\t\t//誤飲も怖いけど誤読も恐ろforces…\n\t\tint ans2 = 0;\n\t\tif ( ans > 0 ) {\n\t\t\t//\n\t\t\tfor( i = 1199; i > ij.first; i-- ) {\n\t\t\t\tfor( j = 0; j < 1200; j++ ) {\n\t\t\t\t\tif ( dp[i][j] != ans && dp2[i][j] == 0 )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif ( dp2[i][j] == 0 ) {\n\t\t\t\t\t\tdp2[i][j] = 1;\n\t\t\t\t\t\tif ( isprime[data[i][j]] && data[i][j] <= m )\n\t\t\t\t\t\t\tdp2[i][j] = data[i][j];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ( data[i-1][j-1] <= m && dp[i-1][j-1] + isprime[data[i-1][j-1]] == dp[i][j]) {\n\t\t\t\t\t\tdp2[i-1][j-1] = max(dp2[i-1][j-1], dp2[i][j]);\n\t\t\t\t\t\tif ( isprime[data[i-1][j-1]] ) {\n\t\t\t\t\t\t\tdp2[i-1][j-1] = max(dp2[i-1][j-1], data[i-1][j-1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( data[i-1][j] <= m && dp[i-1][j] + isprime[data[i-1][j]] == dp[i][j] ) {\n\t\t\t\t\t\tdp2[i-1][j] = max(dp2[i-1][j], dp2[i][j]);\n\t\t\t\t\t\tif ( isprime[data[i-1][j]] )\n\t\t\t\t\t\t\tdp2[i-1][j] = max(dp2[i-1][j], data[i-1][j]);\n\t\t\t\t\t}\n\t\t\t\t\tif ( data[i-1][j+1] <= m && dp[i-1][j+1] + isprime[data[i-1][j+1]] == dp[i][j] ) {\n\t\t\t\t\t\tdp2[i-1][j+1] = max(dp2[i-1][j+1], dp2[i][j]);\n\t\t\t\t\t\tif ( isprime[data[i-1][j+1]] )\n\t\t\t\t\t\t\tdp2[i-1][j+1] = max(dp2[i-1][j+1], data[i-1][j+1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//\n\t\t\tfor( i = 1199; i >= ij.first; i-- ) {\n\t\t\t\tbool find = false;\n\t\t\t\tfor( j = 0; j < 1200; j++ ) {\n\t\t\t\t\tif ( dp2[i][j] && isprime[data[i][j]] && data[i][j] <= m ) {\n\t\t\t\t\t\tfind = true;\n\t\t\t\t\t\tans2 = max(ans2, data[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( find )\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << ans << \" \" << ans2 << endl;\n\t}\n};\n\nSolver test;\n\nint main(){\n\tint m,n;\n\t\n\ttest.SetPrime(1090000);\n\ttest.uzumaki(1090000);\n\twhile( cin >> m >> n ){\n\t\tif(!m)return 0;\n\t\ttest.DP(m, n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nvoid makeSpiral(vector<vector<int> >& cave)\n{\n    const int dy[] = {0, -1, 0, 1};\n    const int dx[] = {1, 0, -1, 0};\n\n    cave.assign(2000, vector<int>(2000, -1));\n    int y = 1000;\n    int x = 1000;\n    int n = 1;\n    cave[y][x] = n;\n\n    for(int i=0; ; ++i){\n        int len = i / 2 + 1;\n        for(int j=0; j<len; ++j){\n            y += dy[i%4];\n            x += dx[i%4];\n            ++ n;\n            cave[y][x] = n;\n            if(n == 1000000)\n                return;\n        }\n    }\n}\n\nvoid findPrime(int N, vector<bool>& isPrime)\n{\n    isPrime.assign(N+1, true);\n    isPrime[0] = isPrime[1] = false;\n    for(int i=2; i*i<=N; i++){\n        if(isPrime[i]){\n            for(int j=i; i*j<=N; j++){\n                isPrime[i*j] = false;\n            }\n        }\n    }\n}\n\nint main()\n{\n    vector<vector<int> > cave;\n    makeSpiral(cave);\n\n    vector<bool> isPrime;\n    findPrime(1000000, isPrime);\n\n    for(;;){\n        int n, start;\n        cin >> n >> start;\n        if(n == 0)\n            return 0;\n\n        int sy, sx;\n        for(int y=0; y<2000; ++y){\n            for(int x=0; x<2000; ++x){\n                if(cave[y][x] == start){\n                    sy = y;\n                    sx = x;\n                }\n            }\n        }\n\n        vector<int> dp(2000, -1);\n        if(isPrime[start])\n            dp[sx] = 1;\n        else\n            dp[sx] = 0;\n        pair<int, int> ret(dp[sx], start);\n\n        for(int y=sy; y<2000; ++y){\n            vector<int> nextDp(2000, -1);\n            for(int x=0; x<2000; ++x){\n                if(dp[x] == -1)\n                    continue;\n                for(int i=-1; i<=1; ++i){\n                    if(cave[y+1][x+i] == -1 || cave[y+1][x+i] > n)\n                        continue;\n                    if(isPrime[cave[y+1][x+i]]){\n                        nextDp[x+i] = max(nextDp[x+i], dp[x] + 1);\n                        ret = max(ret, make_pair(nextDp[x+i], cave[y+1][x+i]));\n                    }\n                    else{\n                        nextDp[x+i] = max(nextDp[x+i], dp[x]);\n                    }\n                }\n            }\n            dp.swap(nextDp);\n        }\n\n        if(ret.first == 0)\n            cout << \"0 0\" << endl;\n        else\n            cout << ret.first << ' ' << ret.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nbool is_prime[1000001];\nmap<P,int> stage;\n\nint main(){\n  int x = 0;\n  int y = 0;\n  int dir = 1;\n  for(int round = 1; round <= 1000000;round++){\n    stage[P(y,x)] = round;\n\n    int prev_dir = dir;\n    if(round > 1) dir = (dir + 3) % 4;\n    int dx = x + tx[dir];\n    int dy = y + ty[dir];\n    if(stage.find(P(dy,dx)) != stage.end()){\n      dir = prev_dir;\n    }\n    dx = x + tx[dir];\n    dy = y + ty[dir];\n    x = dx;\n    y = dy;\n  }\n  \n  memset(is_prime,true,sizeof(is_prime));\n\n  is_prime[0] = false;\n  is_prime[1] = false;\n\n  for(int i=2;i*i<=1000000;i++){\n    if(is_prime[i]){\n      for(int j=i+i;j<=1000000;j+=i){\n\tis_prime[j] = false;\n      }\n    }\n  }\n\n  int start,total_caves;\n  while(~scanf(\"%d %d\",&total_caves,&start)){\n    if(total_caves == 0 && start == 0) break;\n\n    int sx=0,sy=0;\n    for(map<P,int>::iterator it = stage.begin();\n\tit != stage.end();\n\tit++){\n      int x = it->first.second;\n      int y = it->first.first;\n      int num = it->second;\n      if(num == start){\n\tsx = x;\n\tsy = y;\n\tbreak;\n      }\n    }\n\n\n    map <P,int> prev;\n    map <P,int> next;\n\n    int res_prime=0;\n    int res_count=0;\n\n    prev[P(sy,sx)] = (int)is_prime[stage[P(sy,sx)]];\n    if(is_prime[stage[P(sy,sx)]]){\n      res_prime = stage[P(sy,sx)];\n      res_count = 1;\n    }\n    for(int y=sy+1,width=3;y<=1000;y++,width+=3){\n      bool is_update = false;\n      for(int x=sx - width;x<=sx + width;x++){\n\tif(stage[P(y,x)] > total_caves) continue;\n\tis_update = true;\n\n\tint cost = (int)is_prime[stage[P(y,x)]];\n\tif(prev.find(P(y-1,x-1)) != prev.end()){\n\t  next[P(y,x)] = max(prev[P(y-1,x-1)] + cost,next[P(y,x)]);\n\t}\n\tif(prev.find(P(y-1,x)) != prev.end()){\n\t  next[P(y,x)] = max(prev[P(y-1,x)] + cost,next[P(y,x)]);\n\t}\n\tif(prev.find(P(y-1,x+1)) != prev.end()){\n\t  next[P(y,x)] = max(prev[P(y-1,x+1)] + cost,next[P(y,x)]);\n\t}\n      }\n\n      prev.clear();\n      prev = next;\n\n      if(!is_update) break;\n    }\n\n    for(map<P,int>::iterator it = next.begin();\n\tit != next.end();\n\tit++){\n      if(!is_prime[stage[it->first]]) continue;\n\n      if(res_count < it->second){\n\tres_count = it->second;\n\tres_prime = stage[it->first];\n      }\n      if(res_count == it->second\n\t && res_prime < stage[it->first]){\n\tres_prime = stage[it->first];\n      }\n    }\n    printf(\"%d %d\\n\",res_count,res_prime);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\npair<int, int> dp[1000001]; // scroll, last cave\nint isVisited[1000001];\nbool pcheck[1000001];\n\nint n, m;\nint caseN;\n\nvector <int> sqr;\n\nint arr[2000][2000];\nint hash[1000001][2];\n\nvector <int> getNext(int tar)\n{\n\tvector <int> ret;\n\tint y = hash[tar][0], x = hash[tar][1];\n\tret.push_back(arr[y - 1][x - 1]);\n\tret.push_back(arr[y - 1][x]);\n\tret.push_back(arr[y - 1][x + 1]);\n\treturn ret;\n}\n\npair<int, int> getAns(int ith)\n{\n\tif(ith > m || ith == 0) return make_pair(0, 0);\n\tpair<int, int> &ret = dp[ith];\n\tif(isVisited[ith] == caseN) return ret;\n\tisVisited[ith] = caseN;\n\n\tbool flag = (pcheck[ith] == false);\n\n\tif(flag) ret = make_pair(1, ith);\n\telse ret = make_pair(0, 0);\n\t\n\tvector <int> next = getNext(ith);\n\tfor(int i=0;i<next.size();i++)\n\t{\n\t\tpair<int, int> res = getAns(next[i]);\n\t\tif(ret.first < res.first + flag)\n\t\t{\n\t\t\tret = res;\n\t\t\tret.first += flag;\n\t\t}\n\t\telse if (ret.first == res.first + flag) ret.second = max(ret.second, res.second);\n\t}\n\n\treturn ret;\t\t\n}\n\nint main(void)\n{\n\tfor(int i=2;i<=1000000;i++)\n\t{\n\t\tif(pcheck[i]) continue;\n\t\tfor(int j=i*2;j<=1000000;j+=i) pcheck[j] = true;\n\t}\n\n\tfor(int i=1;i*i<=1000000;i+=2) sqr.push_back(i*i);\n\n\tint y = 1000, x = 1000;\n\tarr[y][x] = 1;\n\thash[1][0] = y, hash[1][1] = x;\n\tint cur = 2;\n\tint len = 3;\n\tx++;\n\tint mov[4][2] = {{1, 0}, {0, -1}, {-1, 0}, {0, 1}};\n\tdo\n\t{\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tfor(int j=0;j<len-1;j++) \n\t\t\t{ \n\t\t\t\thash[cur][0] = y, hash[cur][1] = x; \n\t\t\t\tarr[y][x] = cur++;\n\t\t\t\ty += mov[i][0];\n\t\t\t\tx += mov[i][1];\n\n\t\t\t}\n\t\t\t\n\t\t\tif(i < 3)\n\t\t\t{\n\t\t\t\ty -= mov[i][0], x -= mov[i][1];\n\t\t\t\ty += mov[i + 1][0], x += mov[i + 1][1];\n\t\t\t}\n\t\t}\n\t\tlen += 2;\n\t} while(cur <= 1000000);\n\n\twhile(scanf(\"%d %d\", &m, &n), n)\n\t{\n\t\tcaseN++;\n\t\tpair <int, int> ans = getAns(n);\n\t\tprintf(\"%d %d\\n\", ans.first, ans.second);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nint caves[2000][2000];\n\nbool sieve[1000001];\nint SX, SY;\n\ntypedef pair<int, int> PII;\n\nPII dp[2000][2000];\nbool vis[2000][2000];\n\nint main()\n{\n\tint nx, ny;\n\tfill(sieve, sieve + 1000001, true);\n\tsieve[0] = sieve[1] = false;\n\tfor(int i = 2; i * i <= 1000000; ++i) {\n\t\tif(sieve[i]) {\n\t\t\tfor(int j = i * i; j <= 1000000; j += i) {\n\t\t\t\tsieve[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint M, N;\n\twhile (cin>>M>>N, M||N) {\n\t\tmemset(caves, -1, sizeof(caves));\n\t\t\n\t\tfor (int j=0; j<2000; j++) {\n\t\t\tfor (int i=0; i<2000; i++) {\n\t\t\t\tdp[i][j] = PII(0, -1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tnx = ny = 2000/2;\n\t\tint len=1, num=2;\n\t\tint d = 0;\n\t\t\n\t\tcaves[nx][ny] = 1;\n\t\t\n\t\twhile (num <= M) {\n\t\t\tfor (int j=0; j<len; j++) {\n\t\t\t\tnx += dx[d];\n\t\t\t\tny += dy[d];\n\t\t\t\tcaves[nx][ny] = num++;\n\t\t\t\tif (num > M) break;\n\t\t\t}\n\t\t\td++; d %= 4;\n\t\t\tif (num > M) break;\n\t\t\t\n\t\t\tfor (int j=0; j<len; j++) {\n\t\t\t\tnx += dx[d];\n\t\t\t\tny += dy[d];\n\t\t\t\tcaves[nx][ny] = num++;\n\t\t\t\tif (num > M) break;\n\t\t\t}\n\t\t\t\n\t\t\td++;\n\t\t\td %= 4;\n\t\t\tlen++;\n\t\t}\n\t\t\n\t\tfor (int i=0; i<2000; i++) {\n\t\t\tfor (int j=0; j<2000; j++) {\n\t\t\t\tif (caves[j][i] == N) {\n\t\t\t\t\tSX = j, SY = i;\n\t\t\t\t\tif(sieve[N]) {\n\t\t\t\t\t\tdp[i][j] = PII(1, N);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j] = PII(0, -1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t#if 0\n\t\tfor (int i=1000-10; i<1000+10; i++) {\n\t\t\tfor (int j=1000-10; j<1000+10; j++) {\n\t\t\t\tprintf(\"%3d\", caves[j][i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t#endif\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tvis[SY][SX] = true;\n\t\tfor(int i = 0; i < 2000 - 1; ++i) {\n\t\t\tfor(int j = 0; j < 2000; ++j) {\n\t\t\t\tif(vis[i][j] == false) continue;\n\t\t\t\tfor(int k = -1; k <= 1; ++k) {\n\t\t\t\t\tint nx = j + k;\n\t\t\t\t\tif(nx < 0 || nx >= 2000) continue;\n\t\t\t\t\tint add = dp[i][j].first;\n\t\t\t\t\tint maxP = dp[i][j].second;\n\t\t\t\t\tif(caves[nx][i + 1] > 0 && sieve[caves[nx][i + 1]]) {\n\t\t\t\t\t\tadd++;\n\t\t\t\t\t\tmaxP = caves[nx][i + 1];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i + 1][nx] = max(dp[i + 1][nx], PII(add, maxP));\n\t\t\t\t\tvis[i + 1][nx] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tPII ans(-1, -1);\n\t\tfor(int j = 0; j < 2000; ++j) {\n\t\t\tans = max(ans, dp[2000 - 1][j]);\n\t\t}\n\t\tcout << ans.first << ' ' << max(0, ans.second) << endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nnamespace std {\n    template <>\n    class hash<std::pair<int, int>> {\n    public:\n        size_t operator()(const std::pair<int, int>& x) const{\n            return hash<int>()(x.first) ^ hash<int>()(x.second);\n        }\n    };\n}\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvoid solve(){\n    vector<bool> is_prime(1e6+1,true);\n    is_prime[0]=is_prime[1]=false;\n    rep(i,2,1e+6+1){\n        if(!is_prime[i]) continue;\n        for(int j=i*2; j<1e6+1; j+=i) is_prime[j]=false;\n    }\n    while(true){\n        int m,n;\n        cin >> m >> n;\n        if(m==0 and n==0) break;\n\n        unordered_map<pii,int> encode;\n        unordered_map<int,pii> decode;\n        unordered_map<int,vector<int>> xs;\n        {\n            int x=0,y=0,dir=3;\n            rep(i,1,m+1){\n                encode[make_pair(x,y)]=i;\n                decode[i]=make_pair(x,y);\n                xs[y].push_back(x);\n                int nx=x+dx[(dir+1)%4],ny=y+dy[(dir+1)%4];\n                if(encode.find(make_pair(nx,ny))==encode.end()) dir=(dir+1)%4;\n                else{\n                    nx=x+dx[dir];\n                    ny=y+dy[dir];\n                }\n                x=nx;\n                y=ny;\n            }\n        }\n\n        unordered_map<pii,int> dp;\n        int y=decode[n].second+1,ans,max_num;\n        if(is_prime[n]){\n            dp[decode[n]]=1;\n            ans=1;\n            max_num=n;\n        }else{\n            dp[decode[n]]=0;\n            ans=0;\n            max_num=0;\n        }\n        while(xs.find(y)!=xs.end()){\n            for(int x:xs[y]){\n                int tmp=-1;\n                if(dp.find(make_pair(x-1,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x-1,y-1)]);\n                if(dp.find(make_pair(x,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x,y-1)]);\n                if(dp.find(make_pair(x+1,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x+1,y-1)]);\n                if(tmp==-1) continue;\n                if(is_prime[encode[make_pair(x,y)]]){\n                    ++tmp;\n                    if(tmp>ans){\n                        ans=tmp;\n                        max_num=encode[make_pair(x,y)];\n                    }else if(tmp==ans) max_num=max(max_num,encode[make_pair(x,y)]);\n                }\n                dp[make_pair(x,y)]=tmp;\n            }\n            ++y;\n        }\n\n        cout << ans << \" \" << max_num << endl;\n    }\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int) (n); i++)\n#define reps(i, n, m) for (int i = (int) (n); i < (int) (m); i++)\n\nvector<vector<pair<int, int>>> dp;\nvector<vector<int>> num;\nvector<bool> P(1123456, true);\nint n, m;\nint sr, sc;\npair<int, int> ans;\n\nbool init() {\n\tdp.clear();\n\tnum.clear();\n\tans = make_pair(0, 0);\n\tcin >> m >> n;\n\tif (m == 0) return false;\n\tdp.resize(1111, vector<pair<int, int>>(1111, make_pair(-1, 0)));\n\tnum.resize(1111, vector<int>(1111, 0));\n\tint dr[] = {0, -1, 0, 1};\n\tint dc[] = {1, 0, -1, 0};\n\tint p = 2;\n\tint r = 505;\n\tint c = 505;\n\treps(i, 1, m+1) {\n\t\tint np = (p + 1) % 4;\n\t\tif (num[r + dr[np]][c + dc[np]] == 0) {\n\t\t\tr += dr[np];\n\t\t\tc += dc[np];\n\t\t\tp = np;\n\t\t} else {\n\t\t\tr += dr[p];\n\t\t\tc += dc[p];\n\t\t}\n\t\tnum[r][c] = i;\n\t\tif (i == n) {\n\t\t\tsr = r;\n\t\t\tsc = c;\n\t\t}\n\t}\n\treturn true;\n}\n\npair<int, int> dfs(int r, int c) {\n\tpair<int, int>& res = dp[r][c];\n\tif (res.first >= 0) return res;\n\tif (num[r][c] == 0) return res = make_pair(0, 0);\n\tres = max(dfs(r+1, c-1), dfs(r+1, c));\n\tres = max(res, dfs(r+1, c+1));\n\tres.first += P[num[r][c]];\n\tif (P[num[r][c]] && res.first == 1) res.second = num[r][c];\n\treturn res;\n}\n\nvoid solve() {\n\tauto res = dfs(sr, sc);\n\tcout << res.first << \" \" << res.second << endl;\n}\n\nint main() {\n\treps(i, 2, 1123456) {\n\t\tif (P[i]) {\n\t\t\tfor (int j = i + i; j < 1123456; j += i) {\n\t\t\t\tP[j] = false;\n\t\t\t}\n\t\t}\n\t}\n        P[1] = false;\n\twhile (init()) {\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\ntypedef long long ll;\n\nint xs[1000010];\nint ys[1000010];\nint value[3000][3000];\npair<int, int> memo[1000010];;\n\nvector<bool> is_prime;\n\nstd::vector<bool> prime_table(int N){\n  std::vector<bool> is_prime(N + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (int i = 2; i * i <= N; i++){\n        if (is_prime[i]){\n            for (int j = i * 2; j <= N; j += i) is_prime[j] = false;\n        }\n    }\n    return is_prime;\n}\n\npair<int, int> rec(int x, int y, int m){\n  int v = value[x][y];\n  if (v > m || v == -1) {\n    return make_pair(0, 0);\n  }\n\n  if (memo[v].first != -1){\n    return memo[v];\n  }\n  \n  memo[v] = rec(x, y + 1, m);\n  memo[v] = max(memo[v], rec(x - 1, y + 1, m));\n  memo[v] = max(memo[v], rec(x + 1, y + 1, m));\n\n  if (is_prime[v]){\n    memo[v].first++;\n    if (memo[v].second == 0){\n      memo[v].second = v;\n    }\n  }\n  return memo[v];\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n\n  is_prime = prime_table(1000 * 1000);\n\n  int x   = 1500;\n  int y   = 1500;\n  int dir = 0;\n  int cur = 1;\n  int len = 1;\n  \n  int dx[] = {1, 0, -1, 0};\n  int dy[] = {0, -1, 0, 1};\n  \n  memset(value, -1, sizeof(value));\n  REP2(i, 1, 1000 * 1000 + 1){\n    value[x][y] = i;\n    xs[i] = x;\n    ys[i] = y;\n    \n    x += dx[dir];\n    y += dy[dir];\n    \n    cur -= 2;\n    if (cur <= 0){\n      cur = ++len;\n      dir = (dir + 1) % 4;\n    }\n  }\n\n  int m, n;\n  while (cin >> m >> n && m + n){\n    int x = xs[n];\n    int y = ys[n];\n    memset(memo, -1, sizeof(memo));\n    auto p = rec(x, y, m);\n    cout << p.first << \" \" << p.second << endl;\n  }\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define i_i pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< i_i >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; cin >> x;\n#define int2(x, y) Int(x); Int(y);\n#define int3(x, y, z) Int(x); int2(y, z);\n#define fir first\n#define sec second\n#define ffir first.first\n#define fsec first.second\n#define sfir second.first\n#define ssec second.second\n#define Decimal fixed << setprecision(10)\n\n//int dxy[5] = {0, 1, 0, -1, 0};\n// cmd\n\nbool used[1010][1010], cave[1010][1010];\nint prime[1001000], number[1010][1010];\nint dx[4] = {0, -1, 0, 1}, dy[4] = {1, 0, -1, 0};\ni_i kyoko[1001000];\ni_i table[1010][1010];\n\nvoid sieve()\n{\n    memset(prime, true, sizeof(prime));\n    prime[0] = prime[1] = false;\n    rep(i, 1001000) {\n        if (prime[i]) {\n            for (int j = 2; i * j < 1001000; j++) {\n                prime[i*j] = false;\n            }\n        }\n    }\n}\n\nvoid funami_yui()\n{\n    int move = 1, num = 1, cnt = 0, ptr = 0, x = 505, y = 505;\n    kyoko[0] = {0LL, 0LL};\n    rep(i, 1000500) {\n        cave[x][y] = prime[num];\n        kyoko[num] = {x, y};\n        number[x][y] = num++;\n        x += dx[ptr]; y += dy[ptr];\n        cnt++;\n        if (cnt == move) {\n            ptr = (ptr + 1) % 4;\n        } else if (cnt == move + move) {\n            cnt = 0;\n            move++;\n            ptr = (ptr + 1) % 4;\n        }\n    }\n}\n\nvoid solve(int a, int b)\n{\n    memset(used, false, sizeof(used));\n    memset(table, 0, sizeof(table));\n    used[kyoko[b].fir][kyoko[b].sec] = true;\n    table[kyoko[b].fir][kyoko[b].sec] = \n        (cave[kyoko[b].fir][kyoko[b].sec] ? i_i(1, b) : i_i(0, 0));\n    for (int i = 2; i < 1008; i++) {\n        for (int j = 2; j < 1008; j++) {\n            if (used[i][j]) {\n                int nxt, nnum;\n                if (number[i+1][j-1] <= a) {\n                    used[i+1][j-1] = true;\n                    nxt = table[i][j].fir + (cave[i+1][j-1] ? 1LL : 0LL);\n                    nnum = (cave[i+1][j-1] ? \n                            number[i+1][j-1] : table[i][j].sec);\n                    if (table[i+1][j-1].fir < nxt) {\n                        table[i+1][j-1] = {nxt, nnum};\n                    } else if (table[i+1][j-1].fir == nxt) {\n                        table[i+1][j-1].sec = \n                            max(table[i+1][j-1].sec, nnum);\n                    }\n                }\n                if (number[i+1][j] <= a) {\n                    used[i+1][j] = true;\n                    nxt = table[i][j].fir + (cave[i+1][j] ? 1LL : 0LL);\n                    nnum = (cave[i+1][j] ? \n                            number[i+1][j] : table[i][j].sec);\n                    if (table[i+1][j].fir < nxt) {\n                        table[i+1][j] = {nxt, nnum};\n                    } else if (table[i+1][j].fir == nxt) {\n                        table[i+1][j].sec = \n                            max(table[i+1][j].sec, nnum);\n                    }\n                }\n                if (number[i+1][j+1] <= a) {\n                    used[i+1][j+1] = true;\n                    nxt = table[i][j].fir + (cave[i+1][j+1] ? 1LL : 0LL);\n                    nnum = (cave[i+1][j+1] ? \n                            number[i+1][j+1] : table[i][j].sec);\n                    if (table[i+1][j+1].fir < nxt) {\n                        table[i+1][j+1] = {nxt, nnum};\n                    } else if (table[i+1][j+1].fir == nxt) {\n                        table[i+1][j+1].sec = \n                            max(table[i+1][j+1].sec, nnum);\n                    }\n                }\n            }\n        }\n    }\n\n    i_i ans = {-1, -1};\n    rep(i, 1010) rep(j, 1010) {\n        if (number[i][j] <= a) {\n            if (ans.fir < table[i][j].fir) {\n                ans = table[i][j];\n            } else if (ans.fir == table[i][j].fir) {\n                ans.sec = max(ans.sec, table[i][j].sec);\n            }\n        }\n    }\n\n    cout << ans.fir << \" \" << ans.sec << endl;\n\n}\n\nsigned main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    sieve();\n    funami_yui();\n\n    while (1) {\n        int2(a, b);\n        if (!a && !b) break;\n        solve(a, b);\n    }\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\n\n#define out(x,l) (x<0||l<=x)\n\nconst int N = 1000000+10;\n\nbool isprime[N];\npair<int, int> loc[N];\nint cave[1010][1010];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\npair<int, int> dp[1010][1010];\n\nint main(){\n\tfor (int i = 0; i < N; i++) { isprime[i] = 1; } \n\tisprime[0] = isprime[1] = 0;\n\tfor (int i = 2; i*i <= N; i++) {\n\t\tif (!isprime[i]) continue;\n\t\tfor (int j = 2*i; j <= N; j += i) {\n\t\t\tisprime[j] = 0;\n\t\t}\n\t}\n\n\tint x = 1010/2, y = 1010/2+1;\n\tint cnt = 1;\n\tint dir = 0;\n\tint edge = 1;\n\twhile (1) {\n\t\tif (out(x,1010)||out(y,1010)) break;\n\t\tdir %= 4;\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tfor (int j = 0; j < edge; j++) {\n\t\t\t\tcave[y][x] = cnt;\n\t\t\t\tloc[cnt].first = y;\n\t\t\t\tloc[cnt].second = x;\n\t\t\t\tx += dx[dir];\n\t\t\t\ty += dy[dir];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tdir++;\n\t\t}\n\t\tedge++;\n\t}\n\n//\tfor (int i = 1; i < 100; i++) {\n//\t\tcout << i << \" \" << loc[i].first << \" \" << loc[i].second << endl;\n//\t}\n\n\tint n, m;\n\twhile (cin >> m >> n, m&&n) {\n\t\tfor (int i = 0; i < 1010; i++)\n\t\t\tfor (int j = 0; j < 1010; j++) {\n\t\t\t\tdp[i][j].first = -1;\n\t\t\t\tdp[i][j].second = 0;\n\t\t\t}\n\t\tdp[loc[n].first][loc[n].second].first = isprime[n];\n\t\tif (isprime[n]) dp[loc[n].first][loc[n].second].second = n;\n\n\t\tfor (int i = loc[n].first; i < 1010; i++) {\n\t\t\tfor (int j = 0; j < 1010; j++) {\n\t\t\t\tif (cave[i][j] > m) continue;\n\t\t\t\tpair<int, int> next;\n\t\t\t\tnext.first = -1;\n\t\t\t\tnext.second = 0;\n\t\t\t\tbool update = false;\n\t\t\t\tif (!out(i-1,1010)&&!out(j-1,1010)&&dp[i-1][j-1].first!=-1) {\n\t\t\t\t\tif (dp[i-1][j-1].first > next.first) {\n\t\t\t\t\t\tnext = dp[i-1][j-1];\n\t\t\t\t\t\tupdate = 1;\n\t\t\t\t\t} else if (dp[i-1][j-1].first == next.first && dp[i-1][j-1].second > next.second) {\n\t\t\t\t\t\tnext = dp[i-1][j-1];\n\t\t\t\t\t\tupdate = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!out(i-1,1010)&&!out(j+1,1010)&&dp[i-1][j+1].first!=-1) {\n\t\t\t\t\tif (dp[i-1][j+1].first > next.first) {\n\t\t\t\t\t\tnext = dp[i-1][j+1];\n\t\t\t\t\t\tupdate = 1;\n\t\t\t\t\t} else if (dp[i-1][j+1].first == next.first && dp[i-1][j+1].second > next.second) {\n\t\t\t\t\t\tnext = dp[i-1][j+1];\n\t\t\t\t\t\tupdate = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!out(i-1,1010)&&!out(j,1010)&&dp[i-1][j].first!=-1) {\n\t\t\t\t\tif (dp[i-1][j].first > next.first) {\n\t\t\t\t\t\tnext = dp[i-1][j];\n\t\t\t\t\t\tupdate = 1;\n\t\t\t\t\t} else if (dp[i-1][j].first == next.first && dp[i-1][j].second > next.second) {\n\t\t\t\t\t\tnext = dp[i-1][j];\n\t\t\t\t\t\tupdate = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!update) continue;\n\t\t\t\tif (isprime[cave[i][j]]) {\n\t\t\t\t\tnext.first++;\n\t\t\t\t\tnext.second = cave[i][j];\n\t\t\t\t}\n\t\t\t\tdp[i][j] = next;\n\t\t\t}\n\t\t}\n\n\t\tpair<int, int> res;\n\t\tfor (int i = 0; i < 1010; i++)\n\t\t\tfor (int j = 0; j < 1010; j++)\n\t\t\t\tif (res.first < dp[i][j].first) {\n\t\t\t\t\tres = dp[i][j];\n\t\t\t\t} else if (res.first <= dp[i][j].first&&res.second <= dp[i][j].second) {\n\t\t\t\t\tres = dp[i][j];\n\t\t\t\t}\n\t\tcout << res.first << \" \" << res.second << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\n#include <cstring>\n#include <cassert>\n#include <queue>\n#include <cstdio>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#include <set>\n\nusing namespace std;\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nconst int mx = 1024;\nint g[mx][mx];\nconst int b = mx / 2;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint dp[mx][mx];\n\ntemplate<int m>\nclass Prime{\n  std::vector<bool> p;\n  std::vector<int> ps;\npublic:\n  Prime(){\n    p = std::vector<bool>(m,true);\n    assert(m>1);\n    p[0]=p[1]=false;\n    for(int i=4;i<m;i+=2)\n      p[i]=false;\n    ps.push_back(2);\n    for(int i=3;i<m;i+=2){\n      if(p[i]){\n        ps.push_back(i);\n        for(int j=i+i;j<m;j+=i)\n          p[j]=false;\n      }\n    }\n  }\n\n  bool isPrime(int n){\n    assert(m>n);\n    return p[n];\n  }\n\n  int operator [] (int n){\n    if(n<ps.size()) return ps[n];\n    else return 0;\n  }\n\n  int size(){\n    return ps.size();\n  }\n};\n\nint main(){\n  Prime<mx * mx> prime;\n\n  {\n    int x = b;\n    int y = b;\n\n    int cnt  = 0;\n    int dist = 1;\n    int t    = 0;\n    int dir = 0;\n\n    for(int i = 1; i <= 1000 * 1000; i++){\n      g[y][x] = i;\n      y += dy[dir]; x += dx[dir];\n\n      if(++cnt == dist){\n        dir = (dir + 1) % 4;\n        cnt = 0;\n        if(t == 1) dist++;\n        t = !t;\n      }\n    }\n\n    /*\n    for(int i = b - 3; i <= b + 3; i++){\n      for(int j = b - 3; j <= b + 3; j++){\n        printf(\"%3d\", g[i][j]);\n      }\n      puts(\"\");\n    }\n    */\n  }\n\n  while(true){\n    const int n = getInt();\n    const int m = getInt();\n    if(n + m == 0) break;\n\n    memset(dp, -1, sizeof(dp));\n\n    REP(i,mx) REP(j,mx) if(g[i][j] == m) dp[i][j] = prime.isPrime(m) ? 1 : 0;\n\n    pair<int, int> ans = make_pair(0, 0);\n    REP(i,mx) REP(j,mx) if(g[i][j] <= n && dp[i][j] >= 0){\n      if(prime.isPrime(g[i][j])) ans = max(ans, make_pair(dp[i][j], g[i][j]));\n      REP(k,3){\n        const int ii = i + 1;\n        const int jj = k - 1 + j;\n        if(ISIN(ii, jj, mx, mx)){\n          dp[ii][jj] = max(dp[ii][jj], dp[i][j] + (prime.isPrime(g[ii][jj]) ? 1 : 0));\n        }\n      }\n    }\n\n    /*\n    for(int i = b - 3; i <= b + 3; i++){\n      for(int j = b - 3; j <= b + 3; j++){\n        printf(\"%3d\", dp[i][j]);\n      }\n      puts(\"\");\n    }\n    */\n\n    printf(\"%d %d\\n\", ans.first, ans.second);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\n\n#define MAX 1000000\nint m,n;\nint caves[1000][1000];\n\nint isPrime[MAX+1];\nvoid sieve(){\n  isPrime[0] = isPrime[1] = false;\n  for(int i=2;i<=MAX;i++)\n    isPrime[i] = true;\n  for(int i=2;i<=MAX;i++)\n    if(isPrime[i])\n      for(int j=i*2;j<=MAX;j+=i)\n\tisPrime[j]=false;\n}\n\nint Pow[1000];\nvoid mkcaves(){\n  Pow[0]=1;\n  for(int i=1;i<1000;i++)\n    Pow[i] = Pow[i-1] + 2*i + 1;\n  int x=499,y=500;\n  for(int i=1;i<=1000;i++){\n    if(i%2){\n      for(int j=Pow[i-1]-2*i+2;j<=Pow[i-1]-i;j++)\n\tcaves[x][y++]=isPrime[j]?j:j*-1;\n      for(int j=Pow[i-1]-i+1;j<=Pow[i-1];j++)\n\tcaves[x++][y]=isPrime[j]?j:j*-1;\n    }\n    else{\n      for(int j=Pow[i-1]+-2*i+2;j<=Pow[i-1]-i;j++)\n\tcaves[x][y--]=isPrime[j]?j:j*-1;\n      for(int j=Pow[i-1]-i+1;j<=Pow[i-1];j++)\n\tcaves[x--][y]=isPrime[j]?j:j*-1;\n    }\n  }\n}\n\nvoid print(int ary[1000][1000]){\n    for(int i=500-sqrt(m)/2+1;i<500+sqrt(m)/2;i++){\n      for(int j=500-sqrt(m)/2;j<500+sqrt(m)/2-1;j++)\n\tprintf(\"%3d \",ary[j][i]);\n      putchar('\\n');\n    } \n}\n\nint max3(int a,int b,int c){\n  int max = a;\n  if (b > max) max = b;\n  if (c > max) max = c;\n  return max;\n}\n\nint dp[1000][1000];\nint cp[1000][1000];\nvoid solve(){\n  //copy caves\n  rep(i,1000)\n    rep(j,1000)\n      cp[j][i] = (0<caves[j][i] && caves[j][i]<=m);\n\n  //print(cp);\n\n  //reset dp\n  rep(i,1000)\n    rep(j,1000)\n      dp[j][i]=0;\n  \n  if(!isPrime[n])\n    n*=-1;\n\n  int sx,sy;\n  bool f = false;\n  rep(i,1000){\n    rep(j,1000){\n      if(caves[j][i]==n){\n\tsx = j;\n\tsy = i;\n\tf = true;\n\tbreak;\n      }\n    }\n    if(f)\n      break;\n  }\n  //printf(\"start = (%d,%d)\\n\",sx,sy);\n\n  dp[sx][sy] = cp[sx][sy];\n  int nmax=0;\n  for(int i=1; i<=sqrt(m)+3 && sy+i < 1000; i++){\n    for(int j=-i;j<=i;j++){\n      dp[sx+j][sy+i] = cp[sx+j][sy+i]\n        + max3(dp[sx+j-1][sy+i-1], dp[sx+j][sy+i-1], dp[sx+j+1][sy+i-1]);\n      if(dp[sx+j][sy+i] > nmax)\n\tnmax = dp[sx+j][sy+i];\n    }\n  }\n\n  //puts(\"~nmax\");\n\n  int pmax=0;\n  for(int i=0; i<sqrt(m)+3 && sy+i<1000; i++){\n    for(int j=-i;j<=i;j++){\n      if(cp[sx+j][sy+i] && dp[sx+j][sy+i]==nmax && pmax<caves[sx+j][sy+i])\n\tpmax = caves[sx+j][sy+i];\n    }\n  }\n  //puts(\"~pmax\");\n  \n  //print(dp);\n  \n  printf(\"%d %d\\n\",nmax,pmax);\n}\n\nint main(){\n  sieve();\n  mkcaves();\n  for(;;){\n    scanf(\"%d %d\",&m,&n);\n    if(!(m+n)) break;\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define f first\n#define s second\ntypedef pair<int,int> P;\nint a[2000][2000],ans[2000][2000],d=0,y=999,x=1001,n,m;\nbool b[1000001],used[2000][2000];\nint dx[]={-1,0,1,0},tx[]={-1,0,1};\nint dy[]={0,1,0,-1},ty[]={1,1,1};\nint main(){\n  b[0]=b[1]=1;\n  for(int i=2;i<1000001;i++)\n    for(int j=i+i;j<1000001;j+=i)b[j]=1;\n  a[1000][1000]=1;\n  a[1000][1001]=2;\n  a[999][1001]=3;\n  for(int i=4;i<1000001;i++){\n    int yy=y+dy[d],xx=x+dx[d];\n    int ya=yy+dy[(d+1)%4],xa=xx+dx[(d+1)%4];\n    if(!a[ya][xa])d=(d+1)%4;\n    a[yy][xx]=i;\n    y=yy,x=xx;\n  }\n  while(cin>>n>>m,n){\n    memset(ans,0,sizeof(ans));\n    memset(used,0,sizeof(used));\n    r(i,2000)r(j,2000)if(a[i][j]==m){\n      used[i][j]=1;y=i;\n      break;\n    }\n    for(int i=y;i<2000;i++)r(j,2000)if(a[i][j]&&used[i][j]){\n      if(!b[a[i][j]])ans[i][j]++;\n      r(k,3){\n        y=i+ty[k],x=j+tx[k];\n        if(!a[y][x]||a[y][x]>n)continue;\n        ans[y][x]=max(ans[y][x],ans[i][j]);\n        used[y][x]=1;\n      }\n    }\n    int a1=0,a2;\n    r(i,2000)r(j,2000)if(a[i][j]<=n)if(a1<ans[i][j]||a1==ans[i][j]&&a2<a[i][j]&&!b[a[i][j]]){\n      a1=ans[i][j],a2=a[i][j];\n    }\n    if(!a1)cout<<\"0 0\"<<endl;\n    else cout<<a1<<' '<<a2<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t\n\t\tfor (int h = 0;h < SIZE/2;h++) {\n\t\t\tfor (int w = 0;w < SIZE/2;w++) {\n\t\t\t\tcout << dp[h][w] << \" \" << pr[h][w] << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int MAX = 2000;\nconst int MAX2 = 1000000;\nint n,m,G[MAX][MAX];\nbool isPrime[MAX2+1];\nP pos[MAX2+1];\n\nvoid makeP(){\n  fill(isPrime, isPrime+MAX2+1, true);\n  isPrime[0] = isPrime[1] = false;\n  for(int i=2;i<=MAX2;i++){\n    if(isPrime[i]){\n      for(int j=i*2;j<=MAX2;j+=i) isPrime[j] = false;\n    }\n  }\n}\n\nvoid makeG(){\n  int y = MAX / 2, x = MAX / 2, step = 0;\n  fill(G[0],G[MAX],0);\n  for(int i=1;i<=MAX2;){\n    for(int j=0;j<4;j++){\n      if(j % 2 == 0) step++;\n      for(int k=0;k<step;k++){\n        pos[i] = P(x,y);\n        G[y][x] = i++;\n        if(j == 0) x++;\n        if(j == 1) y--;\n        if(j == 2) x--;\n        if(j == 3) y++;\n      }\n    }\n  }\n}\n\nbool check(int y, int x){\n  if(y < 0 || y >= MAX) return false;\n  if(x < 0 || x >= MAX) return false;\n  if(G[y][x] > m) return false;\n  return true;\n}\n\nint dp[MAX][MAX], dp2[MAX][MAX];\n\nvoid solve(){\n  int ans=0, ans2=0;\n  fill(dp[0],dp[MAX],-1);\n  fill(dp2[0],dp2[MAX],0);\n  dp[pos[n].second][pos[n].first] = isPrime[n];\n  if(isPrime[n]) dp2[pos[n].second][pos[n].first] = n;\n\n  for(int i=pos[n].second;i<MAX;i++){\n    for(int j=0;j<MAX;j++){\n      if(dp[i][j] == -1) continue;\n      if(i == MAX - 1){\n        if(ans < dp[i][j]){\n          ans = dp[i][j];\n          ans2 = dp2[i][j];\n        } else if(ans == dp[i][j]) ans2 = max(ans2, dp2[i][j]);\n        continue;\n      }\n\n      for(int k=-1;k<=1;k++){\n        int ny = i + 1;\n        int nx = j + k;\n        if(check(ny,nx)){\n          if(dp[ny][nx] < dp[i][j] + isPrime[G[ny][nx]]){\n            dp[ny][nx] = dp[i][j] + isPrime[G[ny][nx]];\n            if(isPrime[G[ny][nx]]) dp2[ny][nx] = G[ny][nx];\n            else dp2[ny][nx] = dp2[i][j];\n          } else if(dp[ny][nx] == dp[i][j] + isPrime[G[ny][nx]]){\n            dp2[ny][nx] = max(dp2[ny][nx], dp2[i][j]);\n            if(isPrime[G[ny][nx]]) dp2[ny][nx] = max(dp2[ny][nx], G[ny][nx]);\n          }\n        } else {\n          if(ans < dp[i][j]){\n            ans = dp[i][j];\n            ans2 = dp2[i][j];\n          } else if(ans == dp[i][j]) ans2 = max(ans2, dp2[i][j]);\n        }\n      }\n    }\n  }\n\n  cout << ans << ' ' << ans2 << endl;\n}\n\nint main(){\n  makeP();\n  makeG();\n  while(cin >> m >> n && (n|m)) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass Solve {\nprivate:\n\tusing vi = std::vector<int>;\n\tusing vvi = std::vector<vi>;\n\n\tusing vb = std::vector<bool>;\n\tusing vvb = std::vector<vb>;\npublic:\n\tbool is_last_query{};\n\tSolve()\n\t{\n\t\tint m, n;\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0)\n\t\t{\n\t\t\tis_last_query = true;\n\t\t\treturn;\n\t\t}\n\t\tvvi number(1100, vi(1100, -1));\n\t\tint place[2]{550, 550}, begin[2]{550, 550};\n\t\tint dir[4][2]{{1, 0}, {0, -1}, {-1, 0}, {0, 1}}, now_dir{};\n\t\tnumber[place[0]][place[1]] = 1;\n\t\tplace[0] += dir[now_dir][0];\n\t\tplace[1] += dir[now_dir][1];\n\t\tfor (int i{2}; i <= m; i++)\n\t\t{\n\t\t\tif (i == n)\n\t\t\t{\n\t\t\t\tbegin[0] = place[0];\n\t\t\t\tbegin[1] = place[1];\n\t\t\t}\n\t\t\tnumber[place[0]][place[1]] = i;\n\t\t\tif (number[place[0] + dir[(now_dir + 1) % 4][0]][place[1] + dir[(now_dir + 1) % 4][1]] < 0)\n\t\t\t\tnow_dir = (now_dir + 1) % 4;\n\t\t\tplace[0] += dir[now_dir][0];\n\t\t\tplace[1] += dir[now_dir][1];\n\t\t}\n\n\t\tvb isPrime(m + 1, true);\n\t\tisPrime[1] = false;\n\t\tfor (int i{2}; i <= m; i++)\n\t\t{\n\t\t\tif (!isPrime[i]) continue;\n\t\t\tfor (int j{2 * i}; j <= m; j += i)\n\t\t\t\tisPrime[j] = false;\n\t\t}\n\n\t\tvvb visited(1100, vb(1100));\n\n\t\tstd::queue<std::pair<int, int>> que;\n\t\tque.push({begin[0], begin[1]});\n\n\t\tvvi maxTable(1100, vi(1100, 0));\n\t\tstd::pair<int, int> max;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tauto now{que.front()};\n\t\t\tque.pop();\n\t\t\tif (visited[now.first][now.second] || number[now.first][now.second] < 0) continue;\n\t\t\tvisited[now.first][now.second] = true;\n\t\t\tauto& now_max{maxTable[now.first][now.second]};\n\t\t\tfor (int i{now.first - 1}; i <= now.first + 1; i++)\n\t\t\t\tnow_max = std::max(now_max, maxTable[i][now.second - 1]);\n\t\t\tif (isPrime[number[now.first][now.second]])\n\t\t\t{\n\t\t\t\tnow_max++;\n\t\t\t\tmax = std::max(max, {now_max, number[now.first][now.second]});\n\t\t\t}\n\t\t\tfor (int i{now.first - 1}; i <= now.first + 1; i++)\n\t\t\t\tque.push({i, now.second + 1});\n\t\t}\n\t\tprintf(\"%d %d\\n\", max.first, max.second);\n\t}\n};\n\nint main()\n{\n\twhile (!Solve().is_last_query);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <set>\n\nusing namespace std;\nint caves[1003][1003]={};\nint dp[1003][1003]={};\nbool flag[1003][1003]={};\nint dp2[1003][1003]={};\n\nvoid solve(int m,int n,set<int> prime){\n\tfor(int i=0;i<1003;i++){\n\t\tfor(int j=0;j<1003;j++){\n\t\t\tcaves[i][j]=0;\n\t\t\tdp[i][j]=0;\n\t\t\tflag[i][j]=0;\n\t\t\tdp2[i][j]=0;\n\t\t}\n\t}\n\tcaves[500][500]=1;\n\tint now_tate = 500;\n\tint now_yoko = 500;\n\tint x = 1;\n\tbool breakflag=0;\n\tint ans_tate,ans_yoko;\n\tfor(int i=1;i<10000;i++){\n\t\tfor(int j=0;j<2;j++){\n\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\tx+=1;\n\t\t\t\tif(x>m){\n\t\t\t\t\tbreakflag=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(i%2==1){\n\t\t\t\t\tif(j==0){\n\t\t\t\t\t\tnow_yoko +=1;\n\t\t\t\t\t\tcaves[now_tate][now_yoko]=x;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnow_tate -=1;\n\t\t\t\t\t\tcaves[now_tate][now_yoko]=x;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(j==0){\n\t\t\t\t\t\tnow_yoko -=1;\n\t\t\t\t\t\tcaves[now_tate][now_yoko]=x;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnow_tate +=1;\n\t\t\t\t\t\tcaves[now_tate][now_yoko]=x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(x==n){\n\t\t\t\t\tans_tate = now_tate;\n\t\t\t\t\tans_yoko = now_yoko;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(breakflag==1)break;\n\t}\n\tfor(int i=0;i<1003;i++){\n\t\tfor(int j=0;j<1003;j++){\n\t\t\tif(prime.count(caves[i][j])){\n\t\t\t\tflag[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1002;i>=0;i--){\n\t\tfor(int j=0;j<1003;j++){\n\t\t\tif(i==1002){\n\t\t\t\tif(flag[i][j]==1){\n\t\t\t\t\tdp[i][j]=1;\n\t\t\t\t\tdp2[i][j]=caves[i][j];\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdp[i][j]=dp[i+1][j];\n\t\t\t\tif(dp[i][j]!=0){\n\t\t\t\t\tdp2[i][j] = dp2[i+1][j];\n\t\t\t\t}\n\t\t\t\tdp[i][j]=max(dp[i][j],dp[i+1][j+1]);\n\t\t\t\tif(dp[i+1][j]<dp[i+1][j+1]){\n\t\t\t\t\tdp2[i][j] = dp2[i+1][j+1];\n\t\t\t\t}\n\t\t\t\tif(dp[i+1][j]==dp[i+1][j+1]&&dp[i+1][j]!=0){\n\t\t\t\t\tdp2[i][j]=max(dp2[i+1][j],dp2[i+1][j+1]);\n\t\t\t\t}\n\t\t\t\tif(j>0){\n\t\t\t\t\tif(dp[i][j]<dp[i+1][j-1]){\n\t\t\t\t\t\tdp2[i][j] = dp2[i+1][j-1];\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[i+1][j-1]==dp[i][j]&&dp[i+1][j-1]!=0){\n\t\t\t\t\t\tdp2[i][j]=max(dp2[i][j],dp2[i+1][j-1]);\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i+1][j-1]);\n\t\t\t\t}\n\t\t\t\tif(flag[i][j]==1){\n\t\t\t\t\tif(dp2[i][j]==0){\n\t\t\t\t\t\tdp2[i][j]=caves[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j]+=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[ans_tate][ans_yoko] << \" \" << dp2[ans_tate][ans_yoko] << endl;\n\treturn ;\n}\n\n\n\nint main(){\n\tvector<int> vec;\n\tset<int> prime;\n\tvec.push_back(2);\n\tprime.insert(2);\n\tbool flag1=0;\n\tfor(int i=3;i<1000000;i++){\n\t\tflag1 = 0;\n\t\tfor(int j=0;j<vec.size();j++){\n\t\t\tif(i%vec[j]==0){\n\t\t\t\tflag1=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(vec[j]>sqrt((double)i)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag1==0){\n\t\t\tvec.push_back(i);\n\t\t\tprime.insert(i);\n\t\t}\n\t}\n\tint m,n;\n\twhile(1){\n\t\tcin >> m >> n;\n\t\tif(m==0&&n==0)break;\n\t\tsolve(m,n,prime);\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int int64_t\n#define REP(i, s, n) for (signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define all(c) begin(c), end(c)\n\n#define maxup(ans, x) (ans = (ans < x ? x : ans))\n#define minup(ans, x) (ans = (ans > x ? x : ans))\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\nsigned main() {\n\tVV data(1000, V(1000));\n\tvector<P> nums(1000001);\n\tP center = P(500, 499);\n\tP now = center;\n\tdata[center.first][center.second] = 1;\n\n\tint length = 1;\n\tint x = 1;\n\twhile (x < 1000000) {\n\t\tif (length & 1) {\n\t\t\trep(j, length) {\n\t\t\t\tdata[now.first][++now.second] = ++x;\n\t\t\t\tnums[x] = now;\n\t\t\t}\n\t\t\trep(j, length) {\n\t\t\t\tdata[--now.first][now.second] = ++x;\n\t\t\t\tnums[x] = now;\n\t\t\t}\n\t\t} else {\n\t\t\trep(j, length) {\n\t\t\t\tdata[now.first][--now.second] = ++x;\n\t\t\t\tnums[x] = now;\n\t\t\t\tif (x == 1000000) {\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, length) {\n\t\t\t\tdata[++now.first][now.second] = ++x;\n\t\t\t\tnums[x] = now;\n\t\t\t}\n\t\t}\n\t\tlength++;\n\t}\nout:\n\tvector<bool> isprime(1000001, true);\n\tisprime[0] = isprime[1] = false;\n\tfor (int i = 2; i*i <= 1000000; i++) if (isprime[i]) {\n\t\tfor (int j = 2; i * j <= 1000000; j++) {\n\t\t\tisprime[i * j] = false;\n\t\t}\n\t}\n\n\tint m, n;\n\twhile (cin >> m >> n && m) {\n\t\tmap<P, P> memo;\n\t\tfunction<P(int, int)> dp = [&](int r, int c) {\n\t\t\tif (r < 0 || r >= data.size() || c < 0 || c >= data[0].size()\n\t\t\t\t|| data[r][c] > m) return P(0, 0);\n\t\t\tif (memo.count(P(r, c))) return memo[P(r, c)];\n\t\t\tP ret;\n\t\t\tmaxup(ret, dp(r + 1, c - 1));\n\t\t\tmaxup(ret, dp(r + 1, c));\n\t\t\tmaxup(ret, dp(r + 1, c + 1));\n\t\t\tif (isprime[data[r][c]]) {\n\t\t\t\tret.first++;\n\t\t\t\tif (ret.second == 0) ret.second = data[r][c];\n\t\t\t}\n\t\t\treturn memo[P(r, c)] = ret;\n\t\t};\n\t\tP ans = dp(nums[n].first, nums[n].second);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1189&lang=jp\n\n#include<iostream>\n#include<fstream>\n#include<math.h>\n\n//#define MAX 1020000\n\n#define MAX 1002\n\nint n, first;\nint a[MAX][MAX] = {};\nstatic bool initial;\n\nclass Pair{\npublic:\n\tint count;\n\tint last;\n\tPair operator + (Pair p){//\t@Override (+)\n\t\tthis->count += p.count;\n\t\tif (p.last != 0)this->last = p.last;\n\t\treturn *this;\n\t}\n\tvoid setPair(int _x, int _y){\n\t\tcount = _x;\n\t\tlast = _y;\n\t}\n};\n\nPair pair(int a, int b){\n\tPair p;\n\tp.setPair(a, b);\n\treturn p;\n}\n\nbool isPrime(int n){\n\tif (n == 1)return false;\n\tif (n == 2)return true;\n\tif (n % 2 == 0)return false;\n\n\tfor (int i = 3; i * i <= n; i += 2){\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\n\nPair search(int y, int x){\n\tstatic Pair p[MAX*MAX];\n\n\tPair u_right = pair(-10, 0);\n\tPair u_left = pair(-10, 0);\n\n\tstatic bool isReached[MAX*MAX];\n\n\n\tif (initial){//?????????\n\t\tfor (int i = 0; i < MAX*MAX; i++){\n\t\t\tisReached[i] = false;\n\t\t\tp[i].count = p[i].last = 0;\n\t\t}\n\t\tinitial = false;\n\t}\n\n\tif (n < a[y][x] || a[y][x] == 0)\n\t\treturn p[0];//??????????¶???????????????´???,,, p[0].count = p[0].last = 0\n\n\t//??\\??????????????????\n\tif (a[y][x] == 2){\n\t\tp[2].last = 2;\n\t\tif (a[y][x] == first)initial = true;\n\t\treturn pair(1, 2) + search(y + 1, x);\n\t}\n\n\tif (n <= 6 && a[y][x] == 3){\n\t\tp[3].last = 2;\n\t\tif (a[y][x] == first)initial = true;\n\t\treturn pair(2, 2);\n\t}\n\tif (a[y][x] == 4){\n\t\tif (u_right.count == -10)u_right = search(y + 1, x + 1);\n\t\tif (u_left.count == -10)u_left = search(y + 1, x);\n\n\t\tif (u_right.count == u_left.count){\n\t\t\tif (u_right.last < u_left.last)u_right.count--;\n\t\t}\n\t\tif (u_right.count < u_left.count){\n\t\t\tisReached[4] = true;\n\t\t\tif (a[y][x] == first)initial = true;\n\t\t\treturn p[4] = p[4] + u_left;\n\t\t}\n\t\telse{\n\t\t\tisReached[4] = true;\n\t\t\tif (a[y][x] == first)initial = true;\n\t\t\treturn p[4] = p[4] + u_right;\n\t\t}\n\t}\n\t//???????????§????????????\n\n\t//??¶??°??????\n\tif (a[y][x] % 2 == 0){\n\t\tif (a[y][x] == first){\n\t\t\tinitial = true;\n\t\t\tif (n == first)return p[a[y][x]] = search(y + 1, x + 1) + search(y + 1, x - 1);// +p[a[y + 1][x - 1]];\n\t\t}\n\treturn p[a[y + 1][x]] = search(y + 1, x);\n\t}\n\n\t//?????????\n\tif (isReached[a[y][x]]){\n\t\tif (a[y][x] == first)initial = true;\n\t\treturn p[a[y][x]];\n\t}\n\n\tif (u_right.count == -10)u_right = search(y + 1, x + 1);//under.right????¨????\n\tif (u_left.count == -10)u_left = search(y + 1, x - 1);//under.left????¨????\n\n\t//?´???°??????\n\tif (isPrime(a[y][x])){\n\t\tp[a[y][x]].count = 1;\n\t\tp[a[y][x]].last = a[y][x];\n\t}\n\n\tif (u_right.count == u_left.count){\n\t\tif (u_right.last < u_left.last)u_right.count--;\n\t}\n\t//left?????????????????§?????????\n\tif (u_right.count < u_left.count){\n\t\tisReached[a[y][x]] = true;\n\t\tif (a[y][x] == first)initial = true;//???????????\\??£????????????????¬??????????????????????\n\t\treturn p[a[y][x]] = p[a[y][x]] + u_left;\n\t}\n\t//right?????????????????§?????????\n\telse{\n\t\tisReached[a[y][x]] = true;\n\t\tif (a[y][x] == first)initial = true;//???????????\\??£????????????????¬??????????????????????\n\t\treturn p[a[y][x]] = p[a[y][x]] + u_right;\n\t}\n}\n\nint main(){\n\n\tusing namespace std;\n\n\tint x = MAX / 2;\n\tint y = MAX / 2;\n\tint N = 1;\n\ta[MAX / 2][MAX / 2] = 1;\n\n\tfor (int i = 0; i < MAX*MAX; i++){\n\n\t\tfor (int n = 0; n < (int)sqrt((double)N); n++){\n\t\t\ta[y][x] = N;\n\t\t\tN++;\n\t\t\tx++;\n\t\t}\n\t\tif (N >= (MAX)*(MAX))break;\n\t\tfor (int n = 0; n < (int)sqrt((double)N); n++){\n\t\t\ta[y][x] = N;\n\t\t\tN++;\n\t\t\ty--;\n\t\t}\n\t\tif (N >= (MAX)*(MAX))break;\n\t\tfor (int n = 0; n < (int)sqrt((double)N); n++){\n\t\t\ta[y][x] = N;\n\t\t\tN++;\n\t\t\tx--;\n\t\t}\n\t\tif (N >= (MAX)*(MAX))break;\n\t\tfor (int n = 0; n < (int)sqrt((double)N); n++){\n\t\t\ta[y][x] = N;\n\t\t\tN++;\n\t\t\ty++;\n\t\t}\n\t\tif (N >= (MAX)*(MAX))break;\n\t}\n\n//\tifstream fin;\n//\tfin.open(\"input.txt\");\n\n\twhile (true){\n\t\tcin >> n >> first;\n\t\tif (n == 0)break;\n\n\t\tinitial = true;\n\n\t\tfor (int i = 0; i < MAX; i++){\n\t\t\tfor (int j = 0; j < MAX; j++){\n\t\t\t\tif (a[i][j] == first){\n\t\t\t\t\tx = j;\n\t\t\t\t\ty = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tPair p = search(y, x);\n\n\t\tcout << p.count << \" \" << p.last << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n   \nusing namespace std;\n   \n#define MP make_pair\n#define PB push_back\n#define MAX_N 1001000\n#define SIZE 1200\n#define X first\n#define Y second\n   \nconst int STX = 600, STY = 600;\n   \nint id[SIZE][SIZE];\nbool is_prime[MAX_N+1];\nvector<pair<int, int> > coord;\n   \nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++) {\n    if(is_prime[i]) {\n      for(int j=i*i; j<=MAX_N; j+=i) {\n        is_prime[j] = false;\n      }\n    }\n  }\n}\n   \nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n   \n  coord.PB(MP(0, 0)); // no use\n  cnt ++;\n  coord.PB(MP(x, y)); // cnt = 1\n   \n  fill(id[0], id[0]+SIZE*SIZE+1, -1);\n   \n  const int dx[] = {0,-1,0,1};\n  const int dy[] = {-1,0,1,0};\n   \n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt <= MAX_N) {\n    a += 2;\n    for(int turn=0; turn<4; turn++) {\n      for(int i=0; i<a; i++) {\n        x += dx[turn], y += dy[turn];\n        coord.PB(MP(x, y));\n        id[y][x] = ++ cnt;\n      }\n    }\n    x++, y++;\n  }\n}\n   \nint dp[MAX_N+1];\n   \nint main() {\n     \n  Sieve();\n  MakeMap();\n     \n  int m, n;\n     \n  while(cin >> m >> n && (m|n)) {\n    fill(dp, dp+MAX_N+1, -1);\n    dp[n] = is_prime[n];\n     \n    queue<pair<int, int> > que;\n    que.push(coord[n]);\n     \n    while(!que.empty()) {\n      pair<int, int> now = que.front(); que.pop();\n      int noid = id[now.Y][now.X];\n       \n      for(int i=-1; i<=1; i++) {\n        pair<int, int> nex = MP(now.X+i, now.Y+1);\n        if(nex.X < 0 || SIZE <= nex.X || nex.Y < 0 || SIZE <= nex.Y) continue;\n        int neid = id[nex.Y][nex.X];\n        if(neid <= m) {\n          if(dp[neid] < dp[noid] + is_prime[neid]) {\n            dp[neid] = dp[noid] + is_prime[neid];\n            que.push(nex);\n          }\n        }\n      }\n    }\n     \n    int res = dp[n], lastid = -1;\n    if(is_prime[n]) lastid = n;\n     \n    for(int i=1; i<=m; i++) {\n      if(res <= dp[i] && is_prime[i]) {\n        res = dp[i];\n        lastid = max(lastid, i);\n      }\n    }\n     \n    if(lastid == -1) cout << \"0 0\" << endl;\n    else cout << res << \" \" << lastid << endl;\n  }\n     \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <fstream>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppi;\n\n\nconst int dy[]={0,-1,0,1};\nconst int dx[]={1,0,-1,0};\n\n\nbool isPrime[1000100];\nint prime[1000100];\n\nint p;\nvoid erats(){\n  for(int i=0;i<1000100;i++)\n    isPrime[i]=true;\n  p=0;\n  isPrime[0]=isPrime[1]=false;\n  for(int i=2;i<1000100;i++){\n    if(isPrime[i]){\n      prime[p++]=i;\n      for(int j=2*i;j<1000100;j+=i)\n        isPrime[j]=false;\n    }\n  }\n}\n\n\nint N,M;\nmap<pii,int> m;\nmap<int,pii> idToPii;\npii dp[1000100];\n\npii dfs(int pos){\n  if(dp[pos].first>=0)return dp[pos];\n  pii res=pii(isPrime[pos],isPrime[pos]?pos:0);\n  for(int i=-1;i<=1;i++){\n    pii nxt=idToPii[pos];\n    nxt.first++;\n    nxt.second+=i;\n    if(m.count(nxt)&&m[nxt]<=M){\n      pii p=dfs(m[nxt]);\n      if(isPrime[pos])p.first++;\n      \n      if(res.first<p.first)res=p;\n      else if(res.first==p.first){\n        if(res.second<p.second)\n          res=p;\n      }\n    }\n  }\n  return dp[pos]=res;\n}\n\nint main(){\n  erats();\n  \n  int sum=1;\n  int pos=0;\n  pii now=pii(0,0);\n  m[now]=1;\n  idToPii[sum]=now;\n  sum++;\n  for(int i=1;;i++){\n    for(int j=0;j<2;j++){\n      // posの方向へiだけ進む\n      for(int k=0;k<i;k++){\n        now.first+=dy[pos];\n        now.second+=dx[pos];\n        m[now]=sum;\n        idToPii[sum]=now;\n        sum++;\n      }\n      pos=(pos+1)%4;\n    }\n    if(sum>=2000000)break;\n  }\n  while(cin>>M>>N&&(N|M)){\n    for(int i=0;i<=M;i++)\n      dp[i].first=dp[i].second=-1;\n    pii p=dfs(N);\n    cout<<p.first<<\" \"<<p.second<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n\nusing namespace std;\n\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef pair<int, int> PII;\n\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n **/\n\nconst int MAP_SIZE = 2000;\n\ninline int SQR(int n) {\n    return n * n;\n}\n\nvector<bool> ERATOSTHENES(int n) {\n    vector<bool> arr(n, true);\n    for (int i = 2; SQR(i) < n; i++) {\n        if (arr[i]) {\n            for (int j = 0; i * (j + 2) < n; j++) {\n                arr[i * (j + 2)] = false;\n            }\n        }\n    }\n    return arr;\n}\n\nvoid makeMap(VVI &map, VVB &used, VB &primes, PII start, int m) {\n    int count = 1;\n    int right = 1;\n    int up = 1;\n    int left = 2;\n    int down = 2;\n    PII point = start;\n\n    while (true) {\n        for (int i = 0; i < right; i++) {\n            if (count < m) {\n                count++;\n                point.second += 1;\n                map[point.first][point.second] = count;\n                if (primes[count]) {\n                    used[point.first][point.second] = true;\n                }\n            }\n        }\n        for (int i = 0; i < up; i++) {\n            if (count < m) {\n                count++;\n                point.first -= 1;\n                map[point.first][point.second] = count;\n                if (primes[count]) {\n                    used[point.first][point.second] = true;\n                }\n            }\n        }\n        for (int i = 0; i < left; i++) {\n            if (count < m) {\n                count++;\n                point.second -= 1;\n                map[point.first][point.second] = count;\n                if (primes[count]) {\n                    used[point.first][point.second] = true;\n                }\n            }\n        }\n        for (int i = 0; i < down; i++) {\n            if (count < m) {\n                count++;\n                point.first += 1;\n                map[point.first][point.second] = count;\n                if (primes[count]) {\n                    used[point.first][point.second] = true;\n                }\n            }\n        }\n\n        if (count < m) {\n            right += 2;\n            up += 2;\n            left += 2;\n            down += 2;\n        } else {\n            break;\n        }\n\n    }\n}\n\nint main() {\n\n    vector<bool> primes = ERATOSTHENES(2000000);\n\n    while (true) {\n        int m, n;\n        cin >> m >> n;\n\n        if (m == 0 && n == 0) break;\n\n        VVI map(MAP_SIZE, VI(MAP_SIZE, 0));\n        VVB used(MAP_SIZE, VB(MAP_SIZE, false));\n        //first = y   second = x\n        PII start(MAP_SIZE / 2, MAP_SIZE / 2);\n        map[start.first][start.second] = 1;\n\n        makeMap(map, used, primes, start, m);\n\n        for (int i = 0; i < map.size(); i++) {\n            for (int j = 0; j < map[i].size(); j++) {\n                if (map[i][j] == n) start = make_pair(i, j);\n            }\n        }\n\n        VVI dp(MAP_SIZE, VI(MAP_SIZE, -1));\n        if (used[start.first][start.second]) {\n            dp[start.first][start.second] = 1;\n        } else {\n            dp[start.first][start.second] = 0;\n        }\n//        for (int j = 2; j <= MAP_SIZE - 2; j++) {\n//            if (used[start.first][j])dp[start.first][j] = 1;\n//        }\n\n        for (int i = start.first + 1; i < MAP_SIZE - 2; i++) {\n            for (int j = 2; j < MAP_SIZE - 2; j++) {\n                if (map[i][j] == 0)continue;\n                int maxV = -1;\n                maxV = max(maxV, dp[i - 1][j - 1]);\n                maxV = max(maxV, dp[i - 1][j]);\n                maxV = max(maxV, dp[i - 1][j + 1]);\n                if (maxV == -1) continue;\n                if (used[i][j]) maxV++;\n                dp[i][j] = maxV;\n            }\n        }\n\n\n        int maxV = 0;\n        int number = 0;\n        PII last(0, 0);\n\n        for (int i = 0; i < dp.size(); i++) {\n            for (int j = 0; j < dp[i].size(); j++) {\n                if (used[i][j] && dp[i][j] != 0 && dp[i][j] > maxV) {\n                    number = map[i][j];\n                    maxV = dp[i][j];\n                    last.first = i;\n                    last.second = j;\n                }\n                maxV = max(maxV, dp[i][j]);\n            }\n        }\n\n        cout << maxV << \" \" << number << endl;\n\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#define MAX 1002001\n#define EDGE 1001\nusing namespace std;\n\nint h[EDGE + 2][EDGE + 2], visit[EDGE + 2][EDGE + 2], lastcave[EDGE + 2][EDGE + 2];\nlong long int p[MAX];\n\nint max(int a, int b, int c){\n\treturn max(max(a, b), max(b, c));\n}\n\n\n\nint main()\n{\n\t//洞窟の作成\n\tint nowx, nowy, d, size, sizecounter;\n\tnowx = (EDGE - 1) / 2;\n\tnowy = (EDGE + 1) / 2;\n\td = 0;\n\tsize = 1;\n\tsizecounter = 0;\n\tfor (int i = 0; i <= MAX; i++){\n\t\th[nowy][nowx] = i;\n\t\tif (d == 0){\n\t\t\tnowx++;\n\t\t}\n\t\telse if (d == 1){\n\t\t\tnowy--;\n\t\t}\n\t\telse if (d == 2){\n\t\t\tnowx--;\n\t\t}\n\t\telse if (d == 3){\n\t\t\tnowy++;\n\t\t}\n\t\tif (sizecounter == size){\n\t\t\tsizecounter = 0;\n\t\t\td = (d + 1) % 4;\n\t\t\tif (d == 0 || d == 2){\n\t\t\t\tsize++;\n\t\t\t}\n\t\t}\n\t\tsizecounter++;\n\t}\n\n\t//素数の判定用配列を作成\n\tp[1] = 0;\n\tfill(p, p + MAX, 1);\n\tfor (long long int i = 2; i <= MAX; i++){\n\t\tint sqrti = (int)sqrt(i);\n\t\tfor (int j = 2; j <= sqrti; j++){\n\t\t\tif (i % j == 0){\n\t\t\t\tp[i] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t//入力\n\tint m, n;\n\twhile (cin >> m >> n, m || n){\n\n\t\t//初期化\n\t\tint goalcave = 0;\n\t\tint cavecounter = 0;\n\t\tfor (int i = 0; i < EDGE + 2; i++){\n\t\t\tfor (int j = 0; j < EDGE + 2; j++){\n\t\t\t\tvisit[i][j] = 0;\n\t\t\t\tlastcave[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\n\t\t//脱出する直前の洞窟のyを求める．\n\t\tbool flag = false;\n\t\tfor (int i = EDGE + 1; i > 0; i--){\n\t\t\tfor (int j = 0; j < EDGE + 2; j++){\n\t\t\t\tif (0 < h[i][j] && h[i][j] <= m){\n\t\t\t\t\tgoalcave = i;\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t//下から順に計算\n\t\tfor (int i = goalcave; i > 0; i--){\n\t\t\tfor (int j = 0; j < EDGE + 2; j++){\n\t\t\t\tif (h[i][j] <= m){\n\n\t\t\t\t\t//visitを求める\n\t\t\t\t\tif (p[h[i][j]]){\n\t\t\t\t\t\tvisit[i][j] = max(visit[i + 1][j - 1], visit[i + 1][j], visit[i + 1][j + 1]) + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tvisit[i][j] = max(visit[i + 1][j - 1], visit[i + 1][j], visit[i + 1][j + 1]);\n\t\t\t\t\t}\n\n\t\t\t\t\t//lastcaveを求める\n\t\t\t\t\tif (visit[i + 1][j - 1] > visit[i + 1][j] && visit[i + 1][j - 1] > visit[i + 1][j + 1]){\n\t\t\t\t\t\tlastcave[i][j] = lastcave[i + 1][j - 1];\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j] > visit[i + 1][j - 1] && visit[i + 1][j] > visit[i + 1][j + 1]){\n\t\t\t\t\t\tlastcave[i][j] = lastcave[i + 1][j];\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j + 1] > visit[i + 1][j - 1] && visit[i + 1][j + 1] > visit[i + 1][j]){\n\t\t\t\t\t\tlastcave[i][j] = lastcave[i + 1][j + 1];\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j - 1] == visit[i + 1][j] && visit[i + 1][j - 1] > visit[i + 1][j + 1]){\n\t\t\t\t\t\tlastcave[i][j] = max(lastcave[i + 1][j - 1], lastcave[i + 1][j]);\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j] == visit[i + 1][j + 1] && visit[i + 1][j] > visit[i + 1][j - 1]){\n\t\t\t\t\t\tlastcave[i][j] = max(lastcave[i + 1][j], lastcave[i + 1][j + 1]);\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j + 1] == visit[i + 1][j - 1] && visit[i + 1][j + 1] > visit[i + 1][j]){\n\t\t\t\t\t\tlastcave[i][j] = max(lastcave[i + 1][j + 1], lastcave[i + 1][j - 1]);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlastcave[i][j] = max(lastcave[i + 1][j + 1], lastcave[i + 1][j], lastcave[i + 1][j - 1]);\n\t\t\t\t\t}\n\t\t\t\t\tif (p[h[i][j]] && lastcave[i][j] == 0){\n\t\t\t\t\t\tlastcave[i][j] = h[i][j];\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t//出力\n\t\t\t\tif (h[i][j] == n){\n\t\t\t\t\tcout << visit[i][j] << \" \" << lastcave[i][j] << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace::std;\ntypedef long long lint;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define repi(i,a,b) for(int i=a;i<b;i++)\n#define cout (cout<<fixed<<setprecision(15))\n#define INF 1LL<<40\ninline set<lint> primeSet(lint n) {\n    vector<bool> p(n+1);\n    set<lint> set;\n    repi(i,1, n+1)p[i] = true;\n    repi(i,2,sqrt(n)+1) {\n        if (p[i]) {\n            repi(j,2,n/i+1) {\n                p[i*j] = false;\n            }\n        }\n    }\n    repi(i, 2, n+1)if (p[i])set.insert(i);\n    return set;\n}\ninline lint min(vector<lint> num){\n    lint M=num[0];\n    rep(i,(lint)num.size())M=min(M,num[i]);\n    return M;\n}\nint main(){\n    while(1){\n        lint m,n,k=1;\n        cin>>m>>n;\n        if(m==0&&n==0)break;\n        while(k*k<m)k+=2;\n        vector<vector<lint>> map(k,vector<lint>(k,0));\n        lint x=k/2,y=k/2,sx=0,sy=0;\n        map[y][x]=1;\n        if(1==n)sx=x,sy=y;\n        x++;y++;\n        lint cnt=2;\n        repi(i,1,k/2+1){\n            rep(j,i*2){\n                y--;\n                map[y][x]=cnt;\n                if(cnt==n)sx=x,sy=y;\n                cnt++;\n            }\n            rep(j,i*2){\n                x--;\n                map[y][x]=cnt;\n                if(cnt==n)sx=x,sy=y;\n                cnt++;\n            }\n            rep(j,i*2){\n                y++;\n                map[y][x]=cnt;\n                if(cnt==n)sx=x,sy=y;\n                cnt++;\n            }\n            rep(j,i*2){\n                x++;\n                map[y][x]=cnt;\n                if(cnt==n)sx=x,sy=y;\n                cnt++;\n            }\n            x++;y++;\n        }\n        //rep(i,k){cout<<endl;rep(j,k)printf(\"%3lld\",map[i][j]);}\n        vector<vector<lint>> dp,dp2;\n        set<lint> p=primeSet(m);\n        dp.push_back({(lint)p.count(n)});\n        lint now=1;\n        lint M=p.count(n);\n        lint N;\n        if(p.count(n))dp2.push_back({n});\n        else dp2.push_back({0});\n        if(p.count(n))N=n;\n        else N=0;\n        while(1){\n            sx--;\n            sy++;\n            dp.push_back({});\n            dp2.push_back({});\n            bool f=false;\n            rep(i,now*2+1){\n                lint t=-1;\n                lint u=0;\n                if(0<=i&&i<(lint)dp[now-1].size()){\n                    if(t<dp[now-1][i])u=max(u,dp2[now-1][i]);\n                    t=max(t,dp[now-1][i]);\n                }\n                if(0<=i-1&&i-1<(lint)dp[now-1].size()){\n                    if(t<dp[now-1][i-1])u=max(u,dp2[now-1][i-1]);\n                    t=max(t,dp[now-1][i-1]);\n                }\n                if(0<=i-2&&i-2<(lint)dp[now-1].size()){\n                    if(t<dp[now-1][i-2])u=max(u,dp2[now-1][i-2]);\n                    t=max(t,dp[now-1][i-2]);\n                }\n                if(t!=-1&&0<=sy&&sy<k&&0<=sx+i&&sx+i<k&&map[sy][sx+i]<=m){\n                    f=true;\n                    if(p.count(map[sy][sx+i]))u=map[sy][sx+i];\n                    dp2[now].push_back(u);\n                    dp[now].push_back(t+p.count(map[sy][sx+i]));\n                    if(p.count(map[sy][sx+i])&&M==t+(lint)p.count(map[sy][sx+i]))N=max(N,u);\n                    if(M<t+(lint)p.count(map[sy][sx+i]))N=u;\n                    M=max<lint>(M,t+p.count(map[sy][sx+i]));\n                }else{\n                    dp2[now].push_back(-1);\n                    dp[now].push_back(-1);\n                }\n            }\n            now++;\n            //rep(i,dp.size()){cout<<endl;rep(j,dp[i].size())printf(\"%3lld\",dp[i][j]);}\n            if(!f){\n                cout<<M<<\" \"<<N<<endl;\n                break;\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[(SIZE + 1)*(SIZE + 1) + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= (SIZE + 1)*(SIZE + 1);i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= (SIZE + 1)*(SIZE + 1);j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}*/\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(y=SIZE-1;y>=0;y--){\n\t\t\tfor(x=SIZE-1;x>=0;x--){\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&\n\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x - 1]||(dp[y][x] == dp[y + 1][x - 1] && pr[y][x] < pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && \n\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x] || (dp[y][x] == dp[y + 1][x] && pr[y][x] < pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && \n\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x + 1] || (dp[y][x] == dp[y + 1][x + 1] && pr[y][x] < pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (y = 0;y < SIZE;y++) {\n\t\t\tfor (x = 0;x < SIZE;x++) {\n\t\t\t\tif (table[y][x] == n) {\n\t\t\t\t\tcout << dp[y][x] << \" \" << pr[y][x] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#define MAX 1000001\n\ntypedef long long ll;\n\nusing namespace std;\n\nint m;\nint table[2000][2000]={{0,0}};\nint dp[2000][2000]={{0, 0}};\nint dx[4]={0, 1, 0, -1};\nint dy[4]={1, 0, -1, 0};\nbool prime[MAX]; \npair<int, int>coord[MAX];//座標\npair<int, int> ans;// <素数の数, 出口の番号>\n\n\nvoid dfs(int count, int y, int x){\n\tint n = table[y][x];\n\tif(n <= 0 || m < n) return;\n\n\tif(count < dp[y][x] || (count == dp[y][x] && prime[n] == false && dp[y][x] !=0)) return;\n\tdp[y][x] = count;\n\tif(prime[n] == true){\n\t\tcount++;\n\t\tdp[y][x] = count;\n\t\tif(ans.first < count || (ans.first == count && ans.second < n)){\n\t\t\tans.first = count;\n\t\t\tans.second = n;\n\t\t}\n\t}\n\n\tfor(int dx=-1; dx<=1; dx++){\n\t\tdfs(count, y+1, x+dx);\n\t}\n}\n\n\nint main(void){\n\tfill(prime, prime+MAX, true);\n\tprime[0] = prime[1] = false;\n\tfor(int i=2; i<MAX; i++){\n\t\tif(prime[i]){\n\t\t\tfor(int j=i+i; j<MAX; j+=i){\n\t\t\t\tprime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tint d=0;\n\tint x=1000, y=1000;\n\tfor(int i=1; i<MAX; i++){\n\t\ttable[y][x] = i;\n\t\tcoord[i] = make_pair(y, x);\n\t\tif(table[y+dy[(d+1)%4]][x+dx[(d+1)%4]] == 0) d++;\n\t\tx += dx[d%4];\n\t\ty += dy[d%4];\n\t}\n\n\twhile(1){\n\t\tint n; cin >> m >> n;\n\t\tif(!m && !n) break;\n\n\t\tint y = coord[n].first;\n\t\tint x = coord[n].second;\n\t\tfill(dp[0], dp[2000], 0);\n\t\tans = make_pair(0,0);\n\t\tdfs(0, y, x);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define reps(i,a,n) for(int i=a; i<(n); i++)\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\n\nconst int dx[4] = {1, 0,-1, 0};\nconst int dy[4] = {0,-1, 0, 1};\n\nint  a[4000][4000];\n\nconst int c = 2000;\n\nbool isp[1234567];\n\n\npii p[4000][4000];\nint v[4000][4000];\n\n\n\n\n\nint main(){\n\n\trep(i,1234567) isp[i] = true;\n\tisp[0] = isp[1] = false;\n\trep(i, 1234567){\n\t\tif(!isp[i])continue;\n\t\tfor(int j=i*2; j<1234567; j+=i){\n\t\t\tisp[j] = false;\n\t\t}\n\t}\n\n\n\tfor(;;){\n\t\tint n,m;\n\t\tcin >> n >> m;\n\t\tif(n==0) break;\n\t\t\n\t\trep(i,4000)rep(j,4000) a[i][j] = 0;\n\n\t\ta[c][c] = 1;\n\t\tif(m>1) a[c][c+1] = 2;\n\n\t\tint d = 2;\n\t\tint x = 1;\n\t\tint y = -1;\n\t\treps(i, 3, n+1){\n\t\t\ta[c+y][c+x] = i;\n\t\t\tint X=x;\n\t\t\tint Y=y;\n\t\t\tX += dx[(d+1)%4];\n\t\t\tY += dy[(d+1)%4];\n\t\t\tif(a[c+Y][c+X] == 0){\n\t\t\t\td++; d%=4;\n\t\t\t}\n\t\t\tx += dx[d];\n\t\t\ty += dy[d];\n\t\t}\n/*\n\t\treps(i, -10, 11){\n\t\t\treps(j, -10, 11){\n\t\t\t\tprintf(\"%3d\", a[c+i][c+j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}puts(\"\");\n*/\t\t\n\t\trep(i, 4000) rep(j, 4000){\n\t\t\tv[i][j] = -4000;\n\t\t\tif(a[i][j]==m) v[i][j] = 0;\n\t\t}\n\t\t\n\t\tint ma = -1;\n\t\tint mi = 0;\n\t\treps(i, 1, 3999) reps(j, 1,3999){\n\t\t\tint A = v[i-1][j-1];\n\t\t\tint B = v[i-1][j];\n\t\t\tint C = v[i-1][j+1];\n\t\t\t\n\t\t\tv[i][j] = max(max(max(A,B),C),v[i][j]) + isp[a[i][j]];\n\n\t\t\tif(ma <= v[i][j]){\n\t\t\t\tif(ma != v[i][j]){\n\t\t\t\t\tma = v[i][j];\n\t\t\t\t\tmi = 0;\n\t\t\t\t}\n\t\t\t\tif(isp[a[i][j]]) mi = max(mi,a[i][j]);\n\t\t\t}\n\t\t}\n\t\tcout << ma << \" \"<<mi <<endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <string>\n#include <math.h>\n#include <set>\n  \n#define REP(i,n)for (int i=0;i<(n);i++)\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define ll long long\nusing namespace std;\ntypedef pair<int,int> P;\n\nint fld[1010][1010];\nP memo[1000100];\nbool is_prime[1000100];\n\nbool big(P a,P b){\n\tif(a.first!=b.first)return a.first<b.first;\n\treturn a.second<b.second;\n}\n\nP rec(int x,int y,int m){\n\t//cout<<fld[x][y]<<endl;\n\tif(memo[fld[x][y]].first!=-1)return memo[fld[x][y]];\n\n\tP res,res1;res.first=0;res.second=0;\n\n\tfor(int i=-1;i<=1;i++){\n\t\tif(fld[x+i][y+1]!=-1&&fld[x+i][y+1]<=m){\n\t\t\tres1=rec(x+i,y+1,m);\n\t\t\tif(big(res,res1))res=res1;\n\t\t}\n\t}\n\tif(is_prime[fld[x][y]]){\n\t\tres.first++;\n\t\tif(res.first==1)res.second=fld[x][y];\n\t}\n\t//cout<<fld[x][y]<<\" \"<<res.first<<\" \"<<res.second<<endl;\n\treturn memo[fld[x][y]]=res;\n}\n\nint main(){\n\tint x1=505,y1=505;\n\tmemset(fld,-1,sizeof(fld));\n\tfld[x1][y1]=1;\n\tint p=1;\n\twhile(1){\n\t\tfld[x1+p][y1+p]=(2*p+1)*(2*p+1);//右下\n\t\tfld[x1-p][y1-p]=(fld[x1+p][y1+p]+fld[x1+p-1][y1+p-1])/2;//左上\n\t\tfld[x1+p][y1-p]=(fld[x1-p][y1-p]+fld[x1+p-1][y1+p-1])/2;//右上\n\t\tfld[x1-p][y1+p]=(fld[x1+p][y1+p]+fld[x1-p][y1-p])/2;//左下\n\t\tfor(int i=1;i<fld[x1+p][y1-p]-fld[x1+p-1][y1+p-1];i++){\n\t\t\tfld[x1+p][y1+p-i]=fld[x1+p-1][y1+p-1]+i;\n\t\t}\n\t\tfor(int i=1;i<fld[x1-p][y1-p]-fld[x1+p][y1-p];i++){\n\t\t\tfld[x1+p-i][y1-p]=fld[x1+p][y1-p]+i;\n\t\t}\n\t\tfor(int i=1;i<fld[x1-p][y1+p]-fld[x1-p][y1-p];i++){\n\t\t\tfld[x1-p][y1-p+i]=fld[x1-p][y1-p]+i;\n\t\t}\n\t\tfor(int i=1;i<fld[x1+p][y1+p]-fld[x1-p][y1+p];i++){\n\t\t\tfld[x1-p+i][y1+p]=fld[x1-p][y1+p]+i;\n\t\t}\n\t\tif((2*p-1)*(2*p-1)>1e6)break;\n\t\tp++;\n\t}\n\tmemset(is_prime,true,sizeof(is_prime));\n\tis_prime[0]=is_prime[1]=false;\n\tfor(int i=2;i<=1e6;i++){\n\t\tif(is_prime[i]){\n\t\t\tfor(int j=2*i;j<=1e6;j+=i){\n\t\t\t\tis_prime[j]=false;\n\t\t\t}\n\t\t}\n\t}\n\tint n,m;\n\twhile(1){\n\t\tcin>>m>>n;\n\t\tif(n==0&&m==0)break;\n\t\tREP(i,1e6+1)memo[i].first=-1;\n\t\tmemset(memo,-1,sizeof(memo));\n\t\tint x=-1,y=-1;\n\t\tREP(i,1010){\n\t\t\tREP(j,1010){\n\t\t\t\tif(fld[i][j]==n){\n\t\t\t\t\tx=i;y=j;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(x!=-1)break;\n\t\t}\n\t\tP ans=rec(x,y,m);\n\t\tcout<<ans.first<<\" \"<<ans.second<<endl;\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\nconst int N=1000000;\n\ntypedef pair<int,int> pi;\n\n//?????£??????????????±\nint field[1000][1000]={0};\n//??????(??°????????§?¨?)\npi im[N+1];\n//?´???°????????????\nbool prime[N+1];\n\nint n,m;\n\n//?????§???\nint dp[N+1];\n//????????¨???????????????????????????????´???°\nint last[N+1];\n\nint dfs(int v)\n{\n    if(dp[v]>=0) return dp[v];\n\n    int ret=0;\n    pi now=im[v];\n    if(now.fi==999)\n    {\n        if(prime[v])\n        {\n            ret=1;\n            last[v]=v;\n        }\n    }\n    else\n    {\n        int t[3];\n        memset(t,-1,sizeof(t));\n\n        if(now.se>0 && field[now.fi+1][now.se-1]<=m)\n            t[0]=dfs(field[now.fi+1][now.se-1]);\n        if(field[now.fi+1][now.se]<=m)\n            t[1]=dfs(field[now.fi+1][now.se]);\n        if(now.se<1000-1 && field[now.fi+1][now.se+1]<=m)\n            t[2]=dfs(field[now.fi+1][now.se+1]);\n\n        ret=max({0,t[0],t[1],t[2]});\n        rep(i,3)\n        {\n            if(ret==t[i]) last[v]=max(last[v],last[field[now.fi+1][now.se+i-1]]);\n        }\n\n        if(prime[v])\n        {\n            ++ret;\n            if(ret==1) last[v]=v;\n        }\n    }\n\n    return dp[v]=ret;\n}\n\nbool inline in(int x, int y)\n{\n    return (0<=x&&x<1000 && 0<=y&&y<1000);\n}\n\nint main()\n{\n    //?´???°??¨??????\n    fill(prime,prime+N+1,true);\n    prime[0]=prime[1]=false;\n    for(int i=2; i<=N; ++i)\n    {\n        if(prime[i]) for(int j=2; i*j<=N; ++j) prime[i*j]=false;\n    }\n\n    //?????£???????????????\n    int h=0,w=0;\n    int dir=0;\n    int dh[4]={0,1,0,-1}, dw[4]={1,0,-1,0};\n    for(int i=N; i>0; --i)\n    {\n        field[h][w]=i;\n        im[i]=pi(h,w);\n        h+=dh[dir];\n        w+=dw[dir];\n        if(!in(h,w) || field[h][w]>0)\n        {\n            h-=dh[dir];\n            w-=dw[dir];\n            dir=(dir+1)%4;\n            h+=dh[dir];\n            w+=dw[dir];\n        }\n    }\n\n    while(scanf(\" %d %d\", &m, &n),m|n)\n    {\n        memset(dp,-1,sizeof(dp));\n        memset(last,0,sizeof(last));\n        int ans=dfs(n);\n        printf(\"%d %d\\n\", ans, last[n]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\nDef inf = sizeof(Def) == sizeof(long long) ?  2e18:1e9+10;\nint dx[]={0,-1,0,1};\nint dy[]={1,0,-1,0};\nint d[1050][1050],dp[1010][1010];\nint main(){\n\tint sosu[1100000]={1,1,0};//1 is not sosu\n\tfor(int i=2;i*i<1100000;i++)if(sosu[i]==0)\n\tfor(int j=i*2;j<1100000;j+=i)sosu[j]=1;\n\t\n\tint x=500,y=500,to=0,go=1,num=2;\n\td[x][y]=1;\n\twhile(1){\n\t\trep(i,2){\n\t\t\trep(j,go){\n\t\t\t\tx+=dx[to];y+=dy[to];\n\t\t\t\tif(x<0||y<0||x>1049||y>1049)goto end;\n\t\t\t\td[x][y]=num++;\n\t\t\t}\n\t\t\tto++;\n\t\t\tif(to==4)to=0;\n\t\t}\n\t\tgo++;\n\t}\n\tend:;\n\t\n//\tloop(x,490,510){loop(y,490,510)cout<<\" \"<<d[x][y];cout<<endl;}\n\t\t\n\tint n,m;\n\twhile(cin>>m>>n,n){\n\t\trep(i,1010)rep(j,1010)dp[i][j]=-inf;\n\t\trep(i,1010)rep(j,1010)if(d[i][j]==n)dp[i][j]=0;//!sosu[d[i][j]];\n\t\trep(i,1009)loop(j,1,1009){\n\t\t\tint e=!sosu[d[i][j]];\n\t\t\tif(d[i][j]>m)e=0;\n//\t\t\tcout<<\"! \"<<i<<\" \"<<j<<endl;\n\t\t\tdp[i+1][j]=max(dp[i+1][j],dp[i][j]+e);\n\t\t\tdp[i+1][j-1]=max(dp[i+1][j-1],dp[i][j]+e);\n\t\t\tdp[i+1][j+1]=max(dp[i+1][j+1],dp[i][j]+e);\n\t\t}\n\t\tint ma=-1,a;\n\t\trep(i,1010)rep(j,1010)if(d[i][j]<=m&&sosu[d[i][j]]==0){\n\t\t\tdp[i][j]++;\n\t\t\tif(dp[i][j]>ma){\n\t\t\t\tma=dp[i][j];\n\t\t\t\ta=d[i][j];\n\t\t\t}else if(dp[i][j]==ma)a=max(a,d[i][j]);\n\t\t}\n\t\tif(ma==-1)ma=a=0;\n\t\tcout<<ma<<\" \"<<a<<endl;\n\t\t\n\t}\n\t\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <queue>\n#include <utility>\n#define MAX_M 1000000\n#define PRIME_NUM MAX_M\n#define SPIRAL_NUM 1003\n#define DIR_FOUR 4 // dyとdxのための値\n#define DIR_THREE 3 // udyとudxのための値\n\nusing namespace std;\n\nconst int dy[4] = {-1,0,1,0}, dx[4] = {0,1,0,-1}; // 上下左右4方向\nconst int udy[3] = {1,1,1}, udx[3] = {-1,0,1}; // 下3方向\n\n\nint *primeNumber(int num){\n\tint i, j, *ret;\n\tret = (int *)malloc(sizeof(int) * (num + 1));\n\tfor(i = 0;i <= num;i++) ret[i] = 1;\n\tret[0] = ret[1] = 0;\n\tfor(i = 2;i * i <= num;i++){\n\t\tif(ret[i] == 1){\n\t\t\tfor(j = 2 * i;j <= num;j+=i){\n\t\t\t\tret[j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint **spiralArray(int arg1,int arg2){ // arg1 は2次元配列をつくるためのもの　arg2 はどの値までスパイラルし続けるか\n\tint i, j, **ret, x, y, dir;\n\tret = (int **)malloc(sizeof(int *) * arg1);\n\tfor(i = 0;i < arg1;i++){\n\t\tret[i] = (int *)malloc(sizeof(int) * arg1);\n\t}\n\tfor(i = 0;i < arg1;i++){\n\t\tfor(j = 0;j < arg1;j++){\n\t\t\tret[i][j] = -1;\n\t\t}\n\t}\n\ty = arg1 / 2;\n\tx = arg1 / 2 + 1;\n\tdir = 0; // dirの向きにまだ数字が設定されていなければdirの方向　そうでなければ(dir + 1) % 4の方向\n\tret[y][x - 1] = 1;\n\tret[y][x] = 2;\n\n\tfor(i = 3;i <= arg2;i++){\n\t\tif(ret[y + dy[dir]][x + dx[dir]] == -1){\n\t\t\ty += dy[dir]; x += dx[dir];\n\t\t\tret[y][x] = i;\n\t\t\tdir = (dir + (DIR_FOUR - 1)) % DIR_FOUR;\n\t\t}else{\n\t\t\ty += dy[(dir + 1) % DIR_FOUR]; x += dx[(dir + 1) % DIR_FOUR];\n\t\t\tret[y][x] = i;\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nint main(void){\n\tint i, j, *pn, **sp, m, n, sx, sy, dp[SPIRAL_NUM][SPIRAL_NUM];\n\tpn = primeNumber(PRIME_NUM);\n\tsp = spiralArray(SPIRAL_NUM,PRIME_NUM);\n\tqueue<pair<int,int> > que;\n\twhile(1){\n\t\tscanf(\"%d%d\",&m,&n);\n\t\tif(m == 0 && n == 0){\n\t\t\tbreak;\n\t\t}\n\n\t\t// スタート地点の探索\n\t\tfor(i = 0;i < SPIRAL_NUM;i++){\n\t\t\tfor(j = 0;j < SPIRAL_NUM;j++){\n\t\t\t\tif(sp[i][j] == n){\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tdp[sy][sx] = 0;\n\t\tif(pn[n] == 1){\n\t\t\tdp[sy][sx]++;\n\t\t}\n\t\t// 幅優先探索でDP\n\t\tque.push(make_pair(sy,sx));\n\t\twhile(que.size() != 0){\n\t\t\tint y = que.front().first, x = que.front().second;\n\t\t\tque.pop();\n\t\t\tfor(i = 0;i < DIR_THREE;i++){\n\t\t\t\tint ny = y + udy[i], nx = x + udx[i];\n\t\t\t\tif(sp[ny][nx] != -1 && sp[ny][nx] <= m && (dp[ny][nx] == -1 || dp[ny][nx] < dp[y][x] + 1 || (dp[ny][nx] == dp[y][x] && pn[sp[ny][nx]] == 1))){\n\t\t\t\t\tque.push(make_pair(ny,nx));\n\t\t\t\t\tif(pn[sp[ny][nx]] == 1){\n\t\t\t\t\t\tdp[ny][nx] = dp[y][x] + 1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[ny][nx] = dp[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans1 = 0, ans2 = 0;;\n\t\tfor(i = 0;i < SPIRAL_NUM;i++){\n\t\t\tfor(j = 0;j < SPIRAL_NUM;j++){\n\t\t\t\tif(pn[sp[i][j]] == 1 && (ans1 < dp[i][j] || (ans1 == dp[i][j] && ans2 < sp[i][j]))){\n\t\t\t\t\tans1 = dp[i][j];\n\t\t\t\t\tans2 = sp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans1 == 0){\n\t\t\tprintf(\"0 0\\n\");\n\t\t}else{\n\t\t\tprintf(\"%d %d\\n\",ans1, ans2);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\nusing namespace std;\nint n, m, r[1000][1000], dp1[1000][1000], dp2[1000][1000]; bool isprime[1000001];\nconst int dx[4] = { -1, 0, 1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\nint main() {\n\tisprime[1] = false;\n\tfor (int i = 2; i <= 1000000; i++) isprime[i] = true;\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tif (isprime[i]) {\n\t\t\tfor (int j = i + i; j <= 1000000; j += i) {\n\t\t\t\tisprime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n == 0 && m == 0) break;\n\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\t\tdp1[i][j] = -1, dp2[i][j] = -1, r[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tint c = 2, d = 0, x = 499, y = 500;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tr[y][x] = i; d++;\n\t\t\tx += dx[c % 4];\n\t\t\ty += dy[c % 4];\n\t\t\tif (d == c / 2) c++, d = 0;\n\t\t}\n\t\tint sx, sy;\n\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\t\tif (r[i][j] == m) sx = j, sy = i;\n\t\t\t}\n\t\t}\n\t\tdp1[sy][sx] = isprime[m] ? 1 : 0, dp2[sy][sx] = isprime[m] ? m : 0;\n\t\tint res1 = dp1[sy][sx], res2 = dp2[sy][sx];\n\t\tfor (int i = sy + 1; i < 1000; i++) {\n\t\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\t\tif (r[i][j] == -1) continue;\n\t\t\t\tint s1 = -1, s2 = -1;\n\t\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\t\tif (0 <= j + k && j + k < 1000) {\n\t\t\t\t\t\tif (dp1[i - 1][j + k] != -1) {\n\t\t\t\t\t\t\tif (isprime[r[i][j]]) {\n\t\t\t\t\t\t\t\ts1 = max(s1, dp1[i - 1][j + k] + 1);\n\t\t\t\t\t\t\t\ts2 = r[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (s1 < dp1[i - 1][j + k]) {\n\t\t\t\t\t\t\t\t\ts1 = dp1[i - 1][j + k];\n\t\t\t\t\t\t\t\t\ts2 = dp2[i - 1][j + k];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (s1 == dp1[i - 1][j + k] && s2 < dp2[i - 1][j + k]) {\n\t\t\t\t\t\t\t\t\ts2 = dp2[i - 1][j - k];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (j == sx && i == sy) continue;\n\t\t\t\tdp1[i][j] = s1;\n\t\t\t\tdp2[i][j] = s2;\n\t\t\t\tif (res1 < s1) {\n\t\t\t\t\tres1 = s1;\n\t\t\t\t\tres2 = s2;\n\t\t\t\t}\n\t\t\t\telse if (res1 == s1 && res2 < s2) {\n\t\t\t\t\tres2 = s2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", res1, res2);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> P;\n#define F first\n#define S second\nint fie[1111][1111];\nint N,M;\nint sosu[1000001];\nP mie[1000001];\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\n\nP dp[1111][1111];\nint ndx[]={1,0,-1};\nP solve(int x,int y,int ss){\n  if(dp[x][y].F!=-1) return dp[x][y];\n  if(fie[x][y]>N ||  fie[x][y] == -1 ){\n    return P(0,ss);\n  }\n  if(!sosu[fie[x][y]]) ss = fie[x][y];\n  P ret = P(0,0);\n  for(int i=0;i<3;i++){\n    int nx = x+ndx[i];\n    int ny = y+1;\n    P state = solve(nx,ny,ss);\n    ret = max(ret,state);\n  }\n  if(!sosu[fie[x][y]]) ret.F++;\n  // printf(\"%d dp[%d][%d] =  %d, %d fie=%d\\n\",ss,x,y,ret.F,ret.S,fie[x][y]);\n  return dp[x][y] = ret;\n}\n\nint main(){\n  sosu[1]=1;\n  for(int i=2;i<=1000000;i++){\n    if(!sosu[i]){\n      for(int j=i+i;j<=1000000;j+=i){\n\tsosu[j]=1;\n      }\n    }\n  }\n  for(int i=0;i<1111;i++)\n    for(int j=0;j<1111;j++)\n      dp[i][j]=P(-1,-1);\n  memset(fie,-1,sizeof(fie));\n\n\n  int x = 1111/2,y = 1111/2;\n  int id = 1, ic = 0;\n  //printf(\"%d %d\\n\",x,y);\n  fie[x][y]=1;\n  x += dx[ic]; y += dy[ic];\n\n \n  while( id < 1000000 ){\n    id++;\n    fie[x][y]=id;\n    mie[id] = P(x,y);\n    //if(id==1000000) printf(\"%d %d %d\\n\",id,x,y);\n    //    if(!sosu[fie[x][y]]) if(id<1000) printf(\"sosu::%d %d %d\\n\",id,x,y);\n    int nc = (ic+1)%4;\n    int nx = x+dx[nc], ny = y+dy[nc];\n    if( fie[nx][ny] == -1 ){\n      x = nx; y=ny;\n      ic=nc;\n    } else {\n      x = x + dx[ic]; y = y + dy[ic];\n    }\n  }\n\n\n  /*  for(int i=550;i<560;i++){\n    for(int j=550;j<560;j++){\n      printf(\"%3d \",fie[j][i]);\n    }\n    puts(\"\");\n  }\n  */\n\n  while(1){\n    for(int i=0;i<1111;i++)\n      for(int j=0;j<1111;j++)\n\tdp[i][j]=P(-1,-1);\n    \n    cin >> N >> M;\n    if(!N && !M) break;\n    //    printf(\"%d %d\\n\",mie[N].F,mie[N].S);\n    P res = solve(mie[M].F,mie[M].S,-1);\n    /*    if(sosu[fie[mie[M]][Mie[M]]]){\n      res.F ++;\n      }*/\n    if(res.S == -1)\n      printf(\"%d %d\\n\",0,0);\n    /*  } else {\n\tif( !sosu[fie[mie[M].F][mie[M].S]] ){\n\tif( res.F==0 ){\n\t  printf(\"%d %d\\n\",1,fie[mie[M].F][mie[M].S]);\n\t  } else \n\t  printf(\"%d %d\\n\",res.F+1,res.S);\n\t  }*/\n    else\n      printf(\"%d %d\\n\",res.F,res.S);\n    \n  }\n  \n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n\n#define MAX 1000001\n#define SIZE 2000\n\ntypedef long long ll;\n\nusing namespace std;\n\nint m, n;\nint table[SIZE][SIZE]={{0,0}};\nint dp[SIZE][SIZE];\nbool prime[MAX]; \npair<int, int>coord[MAX];//座標\npair<int, int> ans;// <素数の数, 出口の番号>\n\n\nvoid dfs(int count, int y, int x){\n\tint num = table[y][x];\n\tif(num <= 0 || m < num) return;\n\tif(count < dp[y][x] || (count == dp[y][x] && prime[num] == false && dp[y][x] !=0)) return;\n\tdp[y][x] = count;\n\n\tif(prime[num] == true){\n\t\tcount++;\n\t\tdp[y][x] = count;\n\t\tif(ans.first < count || (ans.first == count && ans.second < num)){\n\t\t\tans.first = count;\n\t\t\tans.second = num;\n\t\t}\n\t}\n\n\tfor(int dx=-1; dx<=1; dx++){\n\t\tdfs(count, y+1, x+dx);\n\t}\n}\n\n\nint main(void){\n\tfill(prime, prime+MAX, true);\n\tprime[0] = prime[1] = false;\n\tfor(int i=2; i<MAX; i++){\n\t\tif(prime[i]){\n\t\t\tfor(int j=i+i; j<MAX; j+=i){\n\t\t\t\tprime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tint d=0, x=1000, y=1000;\n\tint dx[4]={0, 1, 0, -1};\n\tint dy[4]={1, 0, -1, 0};\n\tfor(int i=1; i<MAX; i++){\n\t\ttable[y][x] = i;\n\t\tcoord[i] = make_pair(y, x);\n\t\tif(table[y+dy[(d+1)%4]][x+dx[(d+1)%4]] == 0) d++;\n\t\tx += dx[d%4];\n\t\ty += dy[d%4];\n\t}\n\n\twhile(1){\n\t\tcin >> m >> n;\n\t\tif(!m && !n) break;\n\n\t\tint y = coord[n].first;\n\t\tint x = coord[n].second;\n\t\tfill(dp[0], dp[2000], 0);\n\t\tans = make_pair(0, 0);\n\t\tdfs(0, y, x);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\nusing namespace std;\n#define N 1000\n#define N2 N*N\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nbool prime[N2+1];\nint cave[N+1][N+1]={};\npair<int,int> dp[N+1][N+1];\nint m,n;\n\npair<int,int> rec(int x,int y){\n    if(y==0 || x==0 || x==N+1 || cave[x][y]>m)return pair<int,int>(0,0);\n    if(dp[x][y].first)return dp[x][y];\n    pair<int,int> child[3];\n    child[0]=rec(x-1,y-1);\n    child[1]=rec(x,y-1);\n    child[2]=rec(x+1,y-1);\n    sort(child,child+3);\n    if(child[2].first==0 && prime[cave[x][y]])return dp[x][y]=pair<int,int>(1,cave[x][y]);\n    if(prime[cave[x][y]])child[2].first++;\n    return dp[x][y]=child[2];\n}\n\nint main(void){\n    fill(prime,prime+N2+1,true);\n    prime[0]=prime[1]=false;\n    for(int i=2;i<=N2;i++){\n        if(!prime[i])continue;\n        for(int k=2;i*k<=N2;k++)prime[i*k]=false;\n    }\n\n    int x=1,y=N,d=0;\n    pair<int,int> locate[N2+1];\n    for(int i=N2;i>0;i--){\n        cave[x][y]=i;\n        locate[i] = pair<int,int>(x,y);\n        int nextX=x+dx[d],nextY=y+dy[d];\n        if(nextX==0 || nextX==N+1 || nextY==0 || nextY==N+1 || cave[nextX][nextY])d=(d+1)%4;\n        x+=dx[d];\n        y+=dy[d];\n    }\n\n\n    while(cin>>m>>n, m|n){\n        rep1(i,N)rep1(j,N)dp[i][j].first=dp[i][j].second=0;\n        pair<int,int> tmp=rec(locate[n].first,locate[n].second);\n        cout<<tmp.first<<\" \"<<tmp.second<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <fstream>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppi;\n\n\nconst int dy[]={0,-1,0,1};\nconst int dx[]={1,0,-1,0};\n\n\nbool isPrime[1000100];\nint prime[1000100];\n\nint p;\nvoid erats(){\n  for(int i=0;i<1000100;i++)\n    isPrime[i]=true;\n  p=0;\n  isPrime[0]=isPrime[1]=false;\n  for(int i=2;i<1000100;i++){\n    if(isPrime[i]){\n      prime[p++]=i;\n      for(int j=2*i;j<1000100;j+=i)\n        isPrime[j]=false;\n    }\n  }\n}\n\n\nint N,M;\nmap<pair<short,short>,int> m;\npair<short,short> idToPii[1000200];\npii dp[1000100];\n\npii dfs(int pos){\n  if(dp[pos].first>=0)return dp[pos];\n  pii res=pii(isPrime[pos],isPrime[pos]?pos:0);\n  for(int i=-1;i<=1;i++){\n    pii nxt=idToPii[pos];\n    nxt.first++;\n    nxt.second+=i;\n    if(m.count(nxt)&&m[nxt]<=M){\n      pii p=dfs(m[nxt]);\n      if(isPrime[pos])p.first++;\n      if(res.first<p.first)res=p;\n      else if(res.first==p.first){\n        if(res.second<p.second)\n          res=p;\n      }\n    }\n  }\n  return dp[pos]=res;\n}\n\nint main(){\n  erats();\n  \n  int sum=1;\n  int pos=0;\n  pii now=pii(0,0);\n  m[now]=1;\n  idToPii[sum]=now;\n  sum++;\n  for(int i=1;;i++){\n    for(int j=0;j<2;j++){\n      // posの方向へiだけ進む\n      for(int k=0;k<i;k++){\n        now.first+=dy[pos];\n        now.second+=dx[pos];\n        m[now]=sum;\n        idToPii[sum]=now;\n        sum++;\n      }\n      pos=(pos+1)%4;\n    }\n    if(sum>=1000100)break;\n  }\n  return 0;\n  while(cin>>M>>N&&(N|M)){\n    for(int i=0;i<=M;i++)\n      dp[i].first=dp[i].second=-1;\n    pii p=dfs(N);\n    cout<<p.first<<\" \"<<p.second<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n  \nusing namespace std;\n  \n#define MP make_pair\n#define PB push_back\n#define MAX_N 1001000\n#define SIZE 2010\n#define X first\n#define Y second\n  \nconst int STX = 510, STY = 510;\n  \nint id[SIZE][SIZE];\nbool is_prime[MAX_N+1];\nvector<pair<int, int> > coord;\n  \nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++) {\n    if(is_prime[i]) {\n      for(int j=i*i; j<=MAX_N; j+=i) {\n\t\tis_prime[j] = false;\n      }\n    }\n  }\n}\n  \nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  \n  coord.PB(MP(0, 0)); // no use\n  cnt ++;\n  coord.PB(MP(x, y)); // cnt = 1\n  \n  fill(id[0], id[0]+SIZE*SIZE+1, -1);\n  \n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt <= MAX_N) {\n    a += 2;\n    for(int i=0; i<a; i++) {\n      y --;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      x --;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      y ++;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      x ++;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    x++, y++;\n  }\n}\n  \nint dp[MAX_N+1];\n  \nint main() {\n    \n  Sieve();\n  MakeMap();\n    \n  int m, n;\n    \n  while(cin >> m >> n && (m|n)) {\n    fill(dp, dp+MAX_N+1, -1);\n    dp[n] = is_prime[n];\n\t\n    queue<pair<int, int> > que;\n    que.push(coord[n]);\n    \n    while(!que.empty()) {\n      pair<int, int> now = que.front(); que.pop();\n      int noid = id[now.Y][now.X];\n      \n      for(int i=-1; i<=1; i++) {\n\t\tpair<int, int> nex = MP(now.X+i, now.Y+1);\n\t\tif(nex.X < 0 || SIZE <= nex.X || nex.Y < 0 || SIZE <= nex.Y) continue;\n\t\tint neid = id[nex.Y][nex.X];\n\t\tif(neid <= m) {\n\t\t  if(dp[neid] < dp[noid] + is_prime[neid]) {\n\t\t\tdp[neid] = dp[noid] + is_prime[neid];\n\t\t\tque.push(nex);\n\t\t  }\n\t\t}\n      }\n    }\n\t\n    int res = dp[n], lastid = -1;\n    if(is_prime[n]) lastid = n;\n    \n    for(int i=1; i<=m; i++) {\n      if(res <= dp[i] && is_prime[i]) {\n\t\tres = dp[i];\n\t\tlastid = max(lastid, i);\n      }\n    }\n\t\n    if(lastid == -1) cout << \"0 0\" << endl;\n    else cout << res << \" \" << lastid << endl;\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1000011\nusing namespace std;\nint mp[2000][2000];\nint dx[]={1,0,-1,0},dy[]={0,-1,0,1};//>, ^,<,v\nbool prime[N];\nint n,m;\n\nvoid mk_mp(){\n  mp[1000][1000]=1;  \n  int x=1001,y=1000,dir=0,num=2;\n  while(num<N+N){\n    mp[y][x]=num;\n    int ndir=(dir+1)%4,nx=x+dx[ndir],ny=y+dy[ndir];\n    if(mp[ny][nx]==0) dir=ndir;\n    else x+=dx[dir],y+=dy[dir],num++;\n  }\n}\n\ntypedef pair<int,int> P;\nP mem[2000][2000];\nint used[2000][2000];\nP dfs(int y,int x){\n  if(mp[y][x]>m)return P(0,0);\n  if(used[y][x]++) return mem[y][x];\n  P res=max(dfs(y+1,x-1),max(dfs(y+1,x),dfs(y+1,x+1)));\n  if(!prime[mp[y][x]]){\n    res.first++;\n    if(res.second==0)res.second=mp[y][x];\n  }\n  return mem[y][x]=res;\n}\n\n\nint main(){\n  prime[0]=prime[1]=1;\n  for(int i=2;i*i<N;i++)\n    if(!prime[i])\n      for(int j=2;j<=N/i;j++) prime[i*j]=1;\n  mk_mp();\n  while(1){\n    cin>>m>>n;\n    if(!n&&!m)return 0;\n    memset(used,0,sizeof(used));\n    int x=-1,y=-1;\n    for(int i=0;i<2000&&x==-1;i++)\n      for(int j=0;j<2000&&x==-1;j++)if(mp[i][j]==n)x=j,y=i ;\n    P ans=dfs(y,x);\n    cout <<ans.first<<\" \"<<ans.second<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nnamespace std {\n    template <>\n    class hash<std::pair<int, int>> {\n    public:\n        size_t operator()(const std::pair<int, int>& x) const{\n            return size_t((size_t)x.first * (size_t)x.second * 1001);\n        }\n    };\n}\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvoid solve(){\n    vector<bool> is_prime(1e6+1,true);\n    is_prime[0]=is_prime[1]=false;\n    rep(i,2,1e+6+1){\n        if(!is_prime[i]) continue;\n        for(int j=i*2; j<1e6+1; j+=i) is_prime[j]=false;\n    }\n    while(true){\n        int m,n;\n        cin >> m >> n;\n        if(m==0 and n==0) break;\n\n        unordered_map<pii,int> encode;\n        unordered_map<int,pii> decode;\n        unordered_map<int,vector<int>> xs;\n        {\n            int x=0,y=0,dir=3;\n            rep(i,1,m+1){\n                encode[make_pair(x,y)]=i;\n                decode[i]=make_pair(x,y);\n                xs[y].push_back(x);\n                int nx=x+dx[(dir+1)%4],ny=y+dy[(dir+1)%4];\n                if(encode.find(make_pair(nx,ny))==encode.end()) dir=(dir+1)%4;\n                else{\n                    nx=x+dx[dir];\n                    ny=y+dy[dir];\n                }\n                x=nx;\n                y=ny;\n            }\n        }\n\n        unordered_map<pii,int> dp;\n        int y=decode[n].second+1,ans,max_num;\n        if(is_prime[n]){\n            dp[decode[n]]=1;\n            ans=1;\n            max_num=n;\n        }else{\n            dp[decode[n]]=0;\n            ans=0;\n            max_num=0;\n        }\n        while(xs.find(y)!=xs.end()){\n            for(int x:xs[y]){\n                int tmp=-1;\n                if(dp.find(make_pair(x-1,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x-1,y-1)]);\n                if(dp.find(make_pair(x,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x,y-1)]);\n                if(dp.find(make_pair(x+1,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x+1,y-1)]);\n                if(tmp==-1) continue;\n                if(is_prime[encode[make_pair(x,y)]]){\n                    ++tmp;\n                    if(tmp>ans){\n                        ans=tmp;\n                        max_num=encode[make_pair(x,y)];\n                    }else if(tmp==ans) max_num=max(max_num,encode[make_pair(x,y)]);\n                }\n                dp[make_pair(x,y)]=tmp;\n            }\n            ++y;\n        }\n\n        cout << ans << \" \" << max_num << endl;\n    }\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[(SIZE + 1)*(SIZE + 1) + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= (SIZE + 1)*(SIZE + 1);i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= (SIZE + 1)*(SIZE + 1);j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 || n == 0)return 0;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(y=SIZE-1;y>=0;y--){\n\t\t\tfor(x=SIZE-1;x>=0;x--){\n\t\t\t\tif (table[y][x] <= m) {\n\t\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m &&\n\t\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x - 1] || (dp[y][x] == dp[y + 1][x - 1] && pr[y][x] < pr[y + 1][x - 1]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (table[y + 1][x] <= m &&\n\t\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x] || (dp[y][x] == dp[y + 1][x] && pr[y][x] < pr[y + 1][x]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m &&\n\t\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x + 1] || (dp[y][x] == dp[y + 1][x + 1] && pr[y][x] < pr[y + 1][x + 1]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (y = 0;y < SIZE;y++) {\n\t\t\tfor (x = 0;x < SIZE;x++) {\n\t\t\t\tif (table[y][x] == n) {\n\t\t\t\t\t//cout << x << \" \";\n\t\t\t\t\tcout << pr[y][x] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#define X first\n#define Y second\n#define MAX 1003\nusing namespace std;\n\nstruct state{\n\tstate():num(0), max(-1), mindex(0){}\n\tint num;\n\tint max;\n\tint mindex;\n};\n\nstate dp[MAX][MAX];\nbool sosuu[1000001];\nmap<int, pair<int, int> > pos;\nint dx[] = {0, -1, 0, 1};\nint dy[] = {-1, 0, 1, 0};\nint ddx[] = {-1, 0, 1};\n\nvoid era(){\n\tfill(sosuu, sosuu+1000001, true);\n\tfor(int i = 2; i <= 1000000; i++){\n\t\tif(sosuu[i]){\n\t\t\tfor(int j = 2*i; j <= 1000000; j+=i) sosuu[j] = false;\n\t\t}\n\t}\n}\n\nvoid fillNum(){\n\tint rect = 3, index = 0, count = 1;\n\tint x = MAX/2, y = MAX/2;\n\tpos[count] = pair<int, int>(x, y);\n\tdp[y][x].num = count++;\n\twhile(count <= MAX*MAX-1){\n\t\tpos[count] = pair<int, int>(++x, y);\n\t\tdp[y][x].num = count++;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tfor(int j = (i==0)?1:0; j < rect-1; j++){\n\t\t\t\tx += dx[i];\n\t\t\t\ty += dy[i];\n\t\t\t\tpos[count] = pair<int, int>(x, y);\n\t\t\t\tdp[y][x].num = count++;\n\t\t\t}\n\t\t}\n\t\trect+=2;\n\t}\n}\n\nvoid Init(int n){\n\tfor(int i = 0; i < MAX; i++){\n\t\tfor(int j = 0; j < MAX; j++){\n\t\t\tif(n>=dp[i][j].num){\n\t\t\t\tdp[i][j].max = -1;\n\t\t\t\tdp[i][j].mindex = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n  \nint dfs(int x, int y, int n){\n\tif(dp[y][x].max>=0) return dp[y][x].max;\n\tint add = 0;\n\tfor(int i = 0; i < 3; i++){\n\t\tif(dp[y+1][x+ddx[i]].num>n) continue;\n\t\tint tmp = dfs(x+ddx[i], y+1, n);\n\t\tif(add<tmp){\n\t\t\tadd = tmp;\n\t\t\tdp[y][x].mindex = dp[y+1][x+ddx[i]].mindex;\n\t\t}\n\t\telse if(add == tmp){ \n\t\t\tdp[y][x].mindex = dp[y][x].mindex<dp[y+1][x+ddx[i]].mindex?dp[y+1][x+ddx[i]].mindex:dp[y][x].mindex;\n\t\t}\n\t}\n\tdp[y][x].max = sosuu[dp[y][x].num]?add + 1:add;\n\tif(!dp[y][x].mindex&&sosuu[dp[y][x].num]) dp[y][x].mindex = dp[y][x].num;\n\treturn dp[y][x].max;\n}\n\nint main(){\n\tera();\n\tfillNum();\n\tint n, m;\n\twhile(cin >> n >> m && (n!=0||m!=0)){\n\t\tInit(n);\n\t\tint x = pos[m].X, y = pos[m].Y;\n\t\tdfs(x, y, n);\n\t\tif(dp[y][x].max==0) cout << 0 << \" \" << 0 << endl;\n\t\telse cout << dp[y][x].max << \" \" << dp[y][x].mindex << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS; typedef istringstream ISS;\ntypedef long long LL;\ntypedef pair<int, int> PII;  typedef pair<LL, LL> PLL;\ntypedef vector<int>    VI;   typedef vector<VI>   VVI;   typedef vector<VVI>   VVVI;\ntypedef vector<LL>     VLL;  typedef vector<VLL>  VVLL;  typedef vector<VVLL>  VVVLL;\ntypedef vector<double> VD;   typedef vector<VD>   VVD;   typedef vector<VVD>   VVVD;\ntypedef vector<string> VS;   typedef vector<VS>   VVS;   typedef vector<VVS>   VVVS;\ntypedef vector<bool>   VB;   typedef vector<VB>   VVB;   typedef vector<VVB>   VVVB;\ntypedef vector<PII>    VPII; typedef vector<VPII> VVPII; typedef vector<VVPII> VVVPII;\ntypedef vector<PLL>    VPLL; typedef vector<VPLL> VVPLL; typedef vector<VVPLL> VVVPLL;\n\ntypedef unsigned int  UI;\ntypedef vector<UI>    VUI;\ntypedef vector<VUI>   VVUI;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x)  (x).begin(),(x).end()\n#define RALL(x) (x).rbegin(),(x).rend()\n#define RANGEBOX(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define RANGE(x, l, r) ((l) <= (x) && (x) <= (r))\n#define rep(i, N)  for (int i = 0; i < (int)(N); i++)\n#define rrep(i, N) for (int i = N - 1; i >= 0; i--)\n#define REP(i, init, N)  for (int i = (init); i < (int)(N); i++)\n#define RREP(i, N, last) for (int i = (init - 1); i >= last; i--)\n#define MAXUD(orig, target) orig = max(orig, target)\n#define MINUD(orig, target) orig = min(orig, target)\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a)   { OSS oss; oss << a; return oss.str(); };\n\ntemplate<typename T=int> inline void dump(vector<T> vs, bool ent=false) { rep(i, vs.size()) cout << vs[i] << (i+1==vs.size() ? '\\n' : ' '); if (ent) cout << endl; }\ntemplate<typename T = int> inline void dump(vector<vector<T>> vs, bool ent = false) { rep(i, vs.size()) dump<T>(vs[i]); if (ent) cout << endl; }\n\nconst int    INF  = 0x3f3f3f3f;\nconst LL     INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int    DX[] = {1,  0, -1, 0};\nconst int    DY[] = {0, -1,  0, 1};\nconst double EPS  = 1e-12;\n// const double PI   = acos(-1.0);\n// lambda: [](T1 x)->T2{return y;}\n// simple lambda: [](T x){return x;}\n\nVB prime;\n// O(sqrt(n) * n)\nvoid initprime(LL num) {\n\tprime = VB(num + 1, true);\n\tprime[1] = prime[0] = false;\n\tfor (LL i = 2; i * i <= num; i++) {\n\t\tif (prime[i]) {\n\t\t\tfor (LL j = i + i; j <= num; j += i) {\n\t\t\t\tprime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst int MAX_M = 1000010;\nconst int HW = 1010;\nconst int OFFSET = 505;\nVVI ts = VVI(HW, VI(HW));\nVPII toIdx(MAX_M);\nint M, N;\n\nvoid gen_ts() {\n    int dir = 0;\n    int x = OFFSET, y = OFFSET;\n    int idx = 1;\n    int cnt = 1;\n    ts[y][x] = 1;\n    toIdx[idx] = MP(y, x);\n    while (true) {\n        rep(i, 2) {\n            rep(j, cnt) {\n                ++idx;\n                if (idx > MAX_M){ return; }\n                x += DX[dir];\n                y += DY[dir];\n                ts[y][x] = idx;\n                toIdx[idx] = MP(y, x);\n            }\n            dir = (dir + 1) % 4;\n\n        }\n        ++cnt;\n    }\n}\n\nVVPII memo(HW, VPII(HW));\n\nPII dfs(PII p) {\n    int x = p.snd;\n    int y = p.fst;\n    if (memo[y][x].fst) return memo[y][x];\n\n    int num = ts[y][x];\n    bool is_b = prime[num];\n\n    PII res = is_b ? MP(1, num) : MP(0, 0);\n\n    rep(i, 3) {\n        int nx = x + (i - 1);\n        int ny = y + 1;\n        int nnum = ts[ny][nx];\n        if (nnum != 0 && nnum <= M) {\n            PII tmp = dfs(MP(ny, nx));\n            tmp.fst += is_b;\n            res = max(res, tmp);\n        }\n    }\n\n    return memo[y][x] = res;\n}\n\n// price, num\nPII solve() {\n    memo = VVPII(HW, VPII(HW));\n    PII start = toIdx[N];\n    PII res = dfs(start);\n    return res;\n}\n\nint main(void) {\n    initprime(1000010);\n    gen_ts();\n\n    while (cin >> M >> N, M) {\n        PII x = solve();\n        cout << x.fst << \" \" << x.snd << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <limits>\n\nusing Bool = bool;\nusing Int = long long int;\ntemplate <class T>\nusing Vector = std::vector<T>;\ntemplate <class T>\nusing Matrix = Vector<Vector<T>>;\n\nconstexpr Int INF = std::numeric_limits<Int>::max() / 3;\n\nconstexpr Int K = 1000;\nconstexpr Int H = K * 2 + 1, W = K * 2 + 2;\nMatrix<Int> holes(H, Vector<Int>(W));\nconst Vector<Int> dx{0, -1, 0, 1}, dy{1, 0, -1, 0};\n\nVector<Bool> isprime(H* W + 1, true);\n\nvoid init() {\n    Int x = K, y = K;\n    Int step = 0, cnt = 1;\n    for (Int n = 0;; ++n) {\n        if (n % 2 == 0) ++step;\n        for (Int i = 0; i < step; ++i) {\n            holes[x][y] = cnt++;\n            x += dx[n % 4], y += dy[n % 4];\n        }\n        if (x < 0 || y < 0) break;\n    }\n\n    isprime[1] = false;\n    for (Int p = 2; p * p <= H * W; ++p) {\n        for (Int q = p; p * q <= H * W; ++q) {\n            isprime[p * q] = false;\n        }\n    }\n}\n\nMatrix<Int> dp(H, Vector<Int>(W));\nMatrix<Int> last(H, Vector<Int>(W));\nMatrix<Int> hit(H, Vector<Int>(W));\n\nBool solve() {\n    Int m, n;\n    std::cin >> m >> n;\n    if (m == 0) return false;\n\n    for (Int x = 0; x < H; ++x) {\n        for (Int y = 0; y < W; ++y) {\n            hit[x][y] = (isprime[holes[x][y]] && holes[x][y] <= m);\n            dp[x][y] = (holes[x][y] == n ? hit[x][y] : -INF);\n            last[x][y] = 0;\n        }\n    }\n\n    for (Int x = 1; x < H; ++x) {\n        for (Int y = 0; y < W; ++y) {\n            for (Int d = -1; d <= 1; ++d) {\n                Int px = x - 1, py = y + d;\n                if (py < 0 || W <= py) continue;\n\n                Int score = dp[px][py] + hit[x][y];\n                if (dp[x][y] < score ||\n                    (dp[x][y] == score &&\n                     last[x][y] < last[px][py])) {\n                    dp[x][y] = score;\n                    last[x][y] = last[px][py];\n                }\n            }\n\n            if (hit[x][y]) last[x][y] = holes[x][y];\n        }\n    }\n\n    Int ans = 0, p = 0;\n    for (Int y = 0; y < W; ++y) {\n        if (dp[H - 1][y] > ans ||\n            (dp[H - 1][y] == ans && p < last[H - 1][y])) {\n            ans = dp[H - 1][y];\n            p = last[H - 1][y];\n        }\n    }\n\n    std::cout << ans << ' ' << p << std::endl;\n    return true;\n}\n\nint main() {\n    init();\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nbool prime[1000001];\n// [x][y]\nint cave_no[1003][1003];\nint dp[1003][1003];\nint route[1003][1003];\n\nvoid init_cave_no() {\n    int i = 1;\n    int n = 1;\n\n    int x = 501;\n    int y = 501;\n\n    for (;;) {\n        // right\n        for (int j = n; j > 0; j--) {\n            cave_no[x][y] = i++;\n            ++x;\n            if (i > 1000000) { goto end; }\n        }\n        // up\n        for (int j = n; j > 0; j--) {\n            cave_no[x][y] = i++;\n            ++y;\n            if (i > 1000000) { goto end; }\n        }\n\n        ++n;\n\n        // left\n        for (int j = n; j > 0; j--) {\n            cave_no[x][y] = i++;\n            --x;\n            if (i > 1000000) { goto end; }\n        }\n        // down\n        for (int j = n; j > 0; j--) {\n            cave_no[x][y] = i++;\n            --y;\n            if (i > 1000000) { goto end; }\n        }\n\n        ++n;\n    }\nend:;\n}\n\nvoid find_cave_no(int no, int* px, int* py) {\n    int i = 1;\n    int n = 1;\n\n    int x = 501;\n    int y = 501;\n\n    for (;;) {\n        // right\n        for (int j = n; j > 0; j--) {\n            if (i == no) { goto end; }\n            ++x; ++i;\n        }\n        // up\n        for (int j = n; j > 0; j--) {\n            if (i == no) { goto end; }\n            ++y; ++i;\n        }\n\n        ++n;\n\n        // left\n        for (int j = n; j > 0; j--) {\n            if (i == no) { goto end; }\n            --x; ++i;\n        }\n        // down\n        for (int j = n; j > 0; j--) {\n            if (i == no) { goto end; }\n            --y; ++i;\n        }\n\n        ++n;\n    }\nend:;\n    *px = x; *py = y;\n}\n\nvoid init_prime() {\n    prime[0] = false;\n    prime[1] = false;\n\n    for (int i = 2; i <= 1000000; i++) {\n        prime[i] = true;\n    }\n\n    for (int i = 2; i <= 1000; i++) {\n        if (prime[i]) {\n            for (int j = i + i; j <= 1000000; j += i) {\n                prime[j] = false;\n            }\n        }\n    }\n}\n\nint main() {\n    init_cave_no();\n    init_prime();\n\n    for (;;) {\n        int m, n;\n        scanf(\"%d%d\", &m, &n);\n\n        if (!m && !n) { break; }\n\n        int sx, sy;\n        find_cave_no(n, &sx, &sy);\n\n        for (int i = 0; i < 1003; i++) {\n            for (int j = 0; j < 1003; j++) {\n                dp[i][j] = 0;\n                route[i][j] = 0;\n            }\n        }\n\n        // i => x-coord, j => y-coord\n        for (int j = 2; j <= 1001; j++) {\n            for (int i = 2; i <= 1001; i++) {\n                int no = cave_no[i][j];\n                if (no != 0 && no <= m) {\n                    bool p = prime[no];\n\n                    int m = dp[i - 1][j - 1];\n                    int m_route = route[i - 1][j - 1];\n\n                    if (m < dp[i][j - 1]) {\n                        m = dp[i][j - 1];\n                        m_route = route[i][j - 1];\n                    } else if (m == dp[i][j - 1]) {\n                        m_route = max(m_route, route[i][j - 1]);\n                    }\n\n                    if (m < dp[i + 1][j - 1]) {\n                        m = dp[i + 1][j - 1];\n                        m_route = route[i + 1][j - 1];\n                    } else if (m == dp[i + 1][j - 1]) {\n                        m_route = max(m_route, route[i + 1][j - 1]);\n                    }\n\n                    if (m_route == 0 && p) {\n                        route[i][j] = no;\n                    } else {\n                        route[i][j] = m_route;\n                    }\n                    dp[i][j] = m + (p ? 1 : 0);\n                }\n            }\n        }\n\n        printf(\"%d %d\\n\", dp[sx][sy], route[sx][sy]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define SIZE 1000\n\nbool C(int dp1, int pr1, int dp2, int pr2) {\n\tif (dp2 == 0)return false;\n\tif (dp1 < dp2 || (dp1 == dp2&&pr1 < pr2))return true;\n\treturn false;\n}\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool complete;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1;i <= SIZE&&a <= SIZE*SIZE;i++) {\n\t\tfor (int j = 0;j < i&&a <= SIZE*SIZE;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\tif (i % 2 == 0)x--;\n\t\t\telse x++;\n\t\t\ta++;\n\t\t}\n\t\tfor (int j = 0;j < i&&a <= SIZE*SIZE;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t\ta++;\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\tcomplete = false;\n\t\twhile (!complete&&y>=0&&x>=0) {\n\t\t\twhile (x >= 0 && !complete&&y>=0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x - 1], pr[y + 1][x - 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x], pr[y + 1][x])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x + 1], pr[y + 1][x + 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (table[y][x] == n)complete = true;\n\t\t\t\telse x--;\n\t\t\t}\n\t\t\tif (!complete) {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nlong long int map[1010][1010] = {0};\nlong long int maps[1010][1010] = {0};\nlong long int num[1010][1010] = {0};\nlong long int cnt[1010][1010] = {0};\nbool flag[1000010] = {};\nint main() {\n\n  vector< long long int > sosu;\n  for ( long long int i = 2; i <= 1000000; i++ ) {\n    if ( flag[i] == false ) {\n      sosu.push_back( i );\n      for ( long long int j = 1; j * i <= 1000000; j++ ) {\n\tflag[j*i] = true;\n      }\n    }\n  }\n\n  vector< long long int > mx, my;\n  mx.push_back( 0 );\n  my.push_back( 0 );\n  long long int x = 505;\n  long long int y = 505;\n  long long int lm = 1;\n  long long int l = lm;\n  bool lf = false;\n  long long int d = 0;\n  int dx[4] = {  1,  0, -1,  0 };\n  int dy[4] = {  0, -1,  0,  1 };\n  long long int s = 0;\n  for ( long long int i = 1; i <= 1000000; i++ ) {\n    if ( i == sosu[s] ) {\n      maps[x][y] = 1;\n      s++;\n    }\n    map[x][y] = i;\n    mx.push_back( x );\n    my.push_back( y );\n    x += dx[d];\n    y += dy[d];\n    l--;\n    if ( l == 0 ) {\n      if ( lf == false ) {\n\tlf = true;\n      }else {\n\tlf = false;\n\tlm++;\n      }\n      l = lm;\n      d = ( d + 1 ) % 4;\n    }\n  }\n\n  long long int m, n;\n  while( true ) {\n\n    cin >> m >> n;\n    if ( m == 0 ) break;\n\n    x = 0;\n    y = 1008;\n    while( true ) {\n      cnt[x][y] = 0;\n      num[x][y] = 0;\n      if ( map[x][y] > 0 && map[x][y] <= m ) {\n\tif ( maps[x][y] == 1 ) {\n\t  cnt[x][y]++;\n\t  num[x][y] = map[x][y];\n\t}\n\td = -1;\n\tif ( cnt[x-1][y+1] < cnt[x][y+1] ) d = 0;\n\tif ( cnt[x-1][y+1] == cnt[x][y+1] && num[x-1][y+1] < num[x][y+1] ) d = 0;\n\tif ( cnt[x+d][y+1] < cnt[x+1][y+1] ) d = 1;\n\tif ( cnt[x+d][y+1] == cnt[x+1][y+1] && num[x+d][y+1] < num[x+1][y+1] ) d = 1;\n\tcnt[x][y] += cnt[x+d][y+1];\n\tnum[x][y] = max( num[x][y], num[x+d][y+1] );\n      }\n      x++;\n      if ( x == 1010 ) {\n\tx = 0;\n\ty--;\n\tif ( y == 0 ) break;\n      }\n    }\n    cout << cnt[mx[n]][my[n]] << \" \" << num[mx[n]][my[n]] << endl;\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t\n\t\toutput = false;\n\t\tfor (int i = 0;i < SIZE && (!output);i++) {\n\t\t\tfor (int j = 0;j < SIZE && (!output);j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tprintf(\"%d %d\\n\", dp[i][j], pr[i][j]);\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 1200\n#define LIMIT 1000100\ntypedef pair<int,int> pii;\n \nint M,N;\nint caves[MAX][MAX];\nint dp[MAX][MAX];\nmap<int,pii> mp;\nbool prime[LIMIT];\n \nconst int dx[4] = {1,0,-1,0};\nconst int dy[4] = {0,-1,0,1};\n \nvoid makePrime(){\n    fill(prime,prime+LIMIT,true);\n    prime[0] = prime[1] = false;\n    for(int i = 2 ; i*i < LIMIT ; i++){\n\tif(prime[i]){\n\t    for(int j = i*2 ; j < LIMIT ; j+=i){\n\t\tprime[j] = false;\n\t    }\n\t}\n    }\n}\n \nvoid makeCaves(){\n    int x = 600,y = 600,dir = 0;\n    int num = 1,cnt = 1;\n    while(true){\n\tif(cnt == LIMIT) break;\n\tfor(int i = 0 ; i < 2 ; i++){\n\t    for(int j = 0 ; j < num ; j++){\n\t\tmp[cnt] = pii(y,x);\n\t\tcaves[y][x] = cnt++;\n\t\tif(cnt == LIMIT){\n\t\t    return;\n\t\t}\n\t\tx += dx[dir];\n\t\ty += dy[dir];\n\t    }\n\t    dir = (dir+1)%4;   \n\t}\n\tnum++;\n    }\n}\n \nvoid solve(int sx,int sy){\n    dp[sy][sx] = prime[caves[sy][sx]];\n    for(int i = 0 ; i < MAX-1 ; i++){\n\tfor(int j = 1 ; j < MAX-1 ; j++){\n\t    if(dp[i][j] >= 0 && caves[i][j] <= M){\n\t\tif(caves[i+1][j-1] <= M){\n\t\t    dp[i+1][j-1] = max(dp[i+1][j-1],dp[i][j]+prime[caves[i+1][j-1]]); \n\t\t}\n\t\tif(caves[i+1][j] <= M){\n\t\t    dp[i+1][j] = max(dp[i+1][j],dp[i][j]+prime[caves[i+1][j]]); \n\t\t}\n\t\tif(caves[i+1][j+1] <= M){\n\t\t    dp[i+1][j+1] = max(dp[i+1][j+1],dp[i][j]+prime[caves[i+1][j+1]]); \n\t\t}\n\t    }\n\t}\n    }\n    int res = 0, num = 0;\n    for(int i = 0 ; i < MAX ; i++){\n\tfor(int j = 0 ; j < MAX ; j++){\n\t    if(caves[i][j] <= M && prime[caves[i][j]]){\n\t\tif(res < dp[i][j]){\n\t\t    res = dp[i][j];\n\t\t    num = caves[i][j];\n\t\t}else if(res == dp[i][j]){\n\t\t    if(num < caves[i][j]){\n\t\t\tnum = caves[i][j];\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    cout << res << \" \" << num << endl;\n}\n \nint main(){\n    makeCaves();\n    makePrime();\n    while(cin >> M >> N, M){\n\tpii src = mp[N];\n\tmemset(dp,-1,sizeof(dp));\n\tsolve(src.second,src.first);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\nint n,m,o;\nint t[1200][1200];\nint dp[1200][1200];\nint flg[1200][1200];\nint isP[1000001];\nint numx[1000001];\nint numy[1000001];\nint st[1000],size=0;\nint MAXvalue,MAXno;\nvoid make();\nvoid init();\n\nint main(){\n  m=1000000;\n  make();\n  \n  while(cin>>m>>n&&n){\n    MAXvalue=MAXno=0;\n    for(int i=0;i<1200;i++)for(int j=0;j<1200;j++)flg[i][j]=dp[i][j]=-1;\n\n    flg[numy[n]][numx[n]]=n*isP[n];\n    dp[numy[n]][numx[n]]=isP[n];\n    for(int i=0;i<1200;i++){\n      for(int j=0;j<1200;j++){\n\tif(t[i][j]==0||t[i][j]>m||dp[i][j]==-1)continue;\n\t//cout<<t[i][j]<<endl;\n\tdp[i+1][j-1]=dp[i+1][j]=dp[i+1][j+1]=0;\n\tfor(int k=j-1;k<j+2;k++){\n\t  if(dp[i-1][k]==-1)continue;\n\n\t  if(dp[i-1][k]+isP[t[i][j]]>dp[i][j]){\n\n\t    dp[i][j]=dp[i-1][k]+isP[t[i][j]];\n\t    flg[i][j]=max(t[i][j]*isP[t[i][j]],flg[i-1][k]);\n\n\t  }else if(dp[i-1][k]+isP[t[i][j]]==dp[i][j]){\n\n\t    flg[i][j]=max(t[i][j]*isP[t[i][j]],flg[i-1][k]);\n\n\t  }\n\t}//k\n\t//cout<<t[i][j]<<' '<<flg[i][j]<<' '<<dp[i][j]<<endl;\n\tif(MAXvalue<dp[i][j]){\n\t  MAXvalue=dp[i][j];\n\t  MAXno=flg[i][j];\n\t}else if(MAXvalue==dp[i][j]){\n\t  MAXno=max(MAXno,flg[i][j]);\n\t}\n      }//j\n\n    }//i\n    cout<<MAXvalue<<' '<<MAXno<<endl;\n  }\n  return 0;\n}\nvoid make(){\n  for(int i=0;i<1200;i++){\n    for(int j=0;j<1200;j++){\n      dp[i][j]=t[i][j]=0;flg[i][j]=-1;\n    }\n  }\n\n  for(int i=0;i<1000001;i++)isP[i]=1;\n  \n  isP[0]=isP[1]=0;\n  for(int i=2;i*i<1000001;i++){\n    if(!isP[i])continue;\n    for(int j=i*i;j<1000001;j+=i){\n      isP[j]=0;\n    }\n  }\n\n  int nx,ny,cnt=2,z=1,k;\n  nx=ny=600;\n  t[600][600]=1;\n  \n  while(cnt<=m){\n    //cout<<cnt<<endl;\n    for(k=nx+1;k<=nx+z;k++){\n      numy[cnt]=ny;numx[cnt]=k;\n      t[ny][k]=cnt++;\n      if(cnt>m)break;\n    }\n    nx+=z;\n    \n    for(k=ny-1;k>=ny-z;k--){\n      numy[cnt]=k;numx[cnt]=nx;\n      t[k][nx]=cnt++;\n      if(cnt>m)break;\n    }\n    ny-=z;\n\n    z++;\n  \n    \n    for(k=nx-1;k>=nx-z;k--){\n      numy[cnt]=ny;numx[cnt]=k;\n      t[ny][k]=cnt++;\n      if(cnt>m)break;\n    }\n    nx-=z;\n\n    for(k=ny+1;k<=ny+z;k++){\n      numy[cnt]=k;numx[cnt]=nx;\n      t[k][nx]=cnt++;\n      if(cnt>m)break;\n    }\n    ny+=z;\n    \n    z++;\n  }\n  /*\n  for(int i=numy[37];i<=numy[43];i++){\n    for(int j=numx[37];j<=numx[26];j++){\n      printf(\"%3d \",t[i][j]);\n    }\n    cout<<endl;\n  }\n  */\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int M = 1010, G = M/2;\nint m,n;\nint grid[M][M];\nbool vis[M][M];\nP dp[M][M];\nint dy[] = {1,0,-1,0}, dx[] = {0,1,0,-1};\n\nbool pt[M*M];\n\nint main(){\n  for(int i=0;i<M*M;i++)pt[i] = true;\n  pt[0] = pt[1] = false;\n\n  for(int i=2;i<=M;i++){\n    if(pt[i]){\n      for(int j=2*i;j<M*M;j+=i)pt[j] = false;\n    }\n  }\n  \n  while(cin >> m >> n,m){\n    rep(i,M)rep(j,M){\n      grid[i][j] = -1;\n      vis[i][j] = false;\n      dp[i][j] = P(0,0);\n    }\n\n    int y = G, x = G, d = 0;\n    int sy,sx;\n    rep(i,m){\n      if(i+1==n){sy = y; sx = x;}\n      grid[y][x] = i+1;\n      int nxt = grid[y+dy[(d+1)%4]][x+dx[(d+1)%4]];\n      if(nxt<0)d = (d+1)%4;\n      y += dy[d]; x += dx[d];\n    }\n\n    vis[sy][sx] = true;\n    dp[sy][sx] = P(pt[n],(pt[n]?n:0));\n\n    P ans = dp[sy][sx];\n    rep(i,M)rep(j,M){\n      if(!vis[i][j])continue;\n      rep(k,3){\n\tif(grid[i+1][j+k-1]<0)continue;\n\tvis[i+1][j+k-1] = true;\n\n\tP tmp = dp[i][j];\n\tint val = grid[i+1][j+k-1];\n\tif(pt[val]){\n\t  tmp.first++;\n\t  tmp.second = val;\n\t}\n\n\tdp[i+1][j+k-1] = max(dp[i+1][j+k-1],tmp);\n\tans = max(ans,tmp);\n      }\n    }\n\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define f first\n#define s second\ntypedef pair<int,int> P;\nint a[2000][2000],ans[2000][2000],d=0,y=999,x=1001,n,m;\nbool b[1000001],used[2000][2000];\nint dx[]={-1,0,1,0},tx[]={-1,0,1};\nint dy[]={0,1,0,-1},ty[]={1,1,1};\nint main(){\n  b[0]=b[1]=1;\n  for(int i=2;i<1000001;i++)\n    for(int j=i+i;j<1000001;j+=i)b[j]=1;\n  a[1000][1000]=1;\n  a[1000][1001]=2;\n  a[999][1001]=3;\n  for(int i=4;i<1000001;i++){\n    int yy=y+dy[d],xx=x+dx[d];\n    int ya=yy+dy[(d+1)%4],xa=xx+dx[(d+1)%4];\n    if(!a[ya][xa])d=(d+1)%4;\n    a[yy][xx]=i;\n    y=yy,x=xx;\n  }\n  while(cin>>n>>m,n){\n    memset(ans,0,sizeof(ans));\n    memset(used,0,sizeof(used));\n    r(i,2000)r(j,2000)if(a[i][j]==m){\n      used[i][j]=1;y=i;\n      break;\n    }\n    for(int i=y;i<2000;i++)r(j,2000)if(a[i][j]&&used[i][j]){\n      if(!b[a[i][j]])ans[i][j]++;\n      r(k,3){\n        y=i+ty[k],x=j+tx[k];\n        if(!a[y][x]||a[y][x]>=n)continue;\n        ans[y][x]=max(ans[y][x],ans[i][j]);\n        used[y][x]=1;\n      }\n    }\n    int a1=0,a2;\n    r(i,2000)r(j,2000)if(a[i][j]<=n)if(a1<ans[i][j]){\n      a1=ans[i][j],a2=a[i][j];\n    }\n    cout<<a1<<' '<<a2<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <set>\n\nusing namespace std;\nint caves[1003][1003]={};\nint dp[1003][1003]={};\nbool flag[1003][1003]={};\nint dp2[1003][1003]={};\n\nvoid solve(int m,int n,set<int> prime){\n\tfor(int i=0;i<1003;i++){\n\t\tfor(int j=0;j<1003;j++){\n\t\t\tcaves[i][j]=0;\n\t\t\tdp[i][j]=0;\n\t\t\tflag[i][j]=0;\n\t\t\tdp2[i][j]=0;\n\t\t}\n\t}\n\tcaves[500][500]=1;\n\tint now_tate = 500;\n\tint now_yoko = 500;\n\tint x = 1;\n\tbool breakflag=0;\n\tint ans_tate,ans_yoko;\n\tif(n==1){\n\t\tans_tate=500;\n\t\tans_yoko=500;\n\t}\n\tfor(int i=1;i<10000;i++){\n\t\tfor(int j=0;j<2;j++){\n\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\tx+=1;\n\t\t\t\tif(x>m){\n\t\t\t\t\tbreakflag=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(i%2==1){\n\t\t\t\t\tif(j==0){\n\t\t\t\t\t\tnow_yoko +=1;\n\t\t\t\t\t\tcaves[now_tate][now_yoko]=x;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnow_tate -=1;\n\t\t\t\t\t\tcaves[now_tate][now_yoko]=x;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(j==0){\n\t\t\t\t\t\tnow_yoko -=1;\n\t\t\t\t\t\tcaves[now_tate][now_yoko]=x;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tnow_tate +=1;\n\t\t\t\t\t\tcaves[now_tate][now_yoko]=x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(x==n){\n\t\t\t\t\tans_tate = now_tate;\n\t\t\t\t\tans_yoko = now_yoko;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(breakflag==1)break;\n\t}\n\tfor(int i=0;i<1003;i++){\n\t\tfor(int j=0;j<1003;j++){\n\t\t\tif(prime.count(caves[i][j])){\n\t\t\t\tflag[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1001;i>=0;i--){\n\t\tfor(int j=0;j<1002;j++){\n\t\t\tif(i==1001){\n\t\t\t\tif(flag[i][j]==1){\n\t\t\t\t\tdp[i][j]=1;\n\t\t\t\t\tdp2[i][j]=caves[i][j];\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdp[i][j]=dp[i+1][j];\n\t\t\t\tif(dp[i][j]!=0){\n\t\t\t\t\tdp2[i][j] = dp2[i+1][j];\n\t\t\t\t}\n\t\t\t\tdp[i][j]=max(dp[i][j],dp[i+1][j+1]);\n\t\t\t\tif(dp[i+1][j]<dp[i+1][j+1]){\n\t\t\t\t\tdp2[i][j] = dp2[i+1][j+1];\n\t\t\t\t}\n\t\t\t\tif(dp[i+1][j]==dp[i+1][j+1]&&dp[i+1][j]!=0){\n\t\t\t\t\tdp2[i][j]=max(dp2[i+1][j],dp2[i+1][j+1]);\n\t\t\t\t}\n\t\t\t\tif(j>0){\n\t\t\t\t\tif(dp[i][j]<dp[i+1][j-1]){\n\t\t\t\t\t\tdp2[i][j] = dp2[i+1][j-1];\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[i+1][j-1]==dp[i][j]&&dp[i+1][j-1]!=0){\n\t\t\t\t\t\tdp2[i][j]=max(dp2[i][j],dp2[i+1][j-1]);\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i+1][j-1]);\n\t\t\t\t}\n\t\t\t\tif(flag[i][j]==1){\n\t\t\t\t\tif(dp2[i][j]==0){\n\t\t\t\t\t\tdp2[i][j]=caves[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j]+=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[ans_tate][ans_yoko] << \" \" << dp2[ans_tate][ans_yoko] << endl;\n\treturn ;\n}\n\n\n\nint main(){\n\tvector<int> vec;\n\tset<int> prime;\n\tvec.push_back(2);\n\tprime.insert(2);\n\tbool flag1=0;\n\tfor(int i=3;i<1000000;i++){\n\t\tflag1 = 0;\n\t\tfor(int j=0;j<vec.size();j++){\n\t\t\tif(i%vec[j]==0){\n\t\t\t\tflag1=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(vec[j]>sqrt((double)i)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag1==0){\n\t\t\tvec.push_back(i);\n\t\t\tprime.insert(i);\n\t\t}\n\t}\n\tint m,n;\n\twhile(1){\n\t\tcin >> m >> n;\n\t\tif(m==0&&n==0)break;\n\t\tsolve(m,n,prime);\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1189&lang=jp\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define INF 1<<30\n#define MAX_M 1000010\nbool Prime[MAX_M];\nint Caves[1002][1002];\npii dp[1002][1002];\n\nvoid init_prime() {\n\tPrime[2] = true;\n\tfor (int i = 3; i < MAX_M; i += 2) {\n\t\tbool f = false;\n\t\tfor (int j = 2; j*j <= i;j++) {\n\t\t\tif (i%j == 0) { f = true; break; }\n\t\t}\n\t\tif (!f) Prime[i] = true;\n\t}\n}\n\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\n\npair<int,int> init_Caves(int m,int n) {\n\t/* Caves initialize */\n\tmemset(Caves, 0, sizeof(Caves));\n\t/* initial state */\n\tint x, y; x = y = 500;\n\t/* next direction */\n\tint k = 0;\n\t/* step valiables */\n\tint steps = 1;\n\tint now_steps = 0;\n\tint count = 0;\n\t/* return valiables */\n\tpii ret;\n\tfor (int i = 1; i <= m;i++) {\n\t\t/* n locate & Caves */\n\t\tif (i == n) ret = { y,x };\n\t\tCaves[y][x] = i;\n\n\t\t/* next locate */\n\t\tx += dx[k]; y += dy[k];\n\n\t\t/* step */\n\t\tnow_steps++;\n\t\tif (steps == now_steps) {\n\t\t\tnow_steps = 0;\n\t\t\tk = (k + 1) % 4;\n\t\t\tcount = (count + 1) % 2;\n\t\t\tif (count == 0) {\n\t\t\t\tsteps++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint dcx[3] = { -1,0,1 };\nint dcy[3] = { -1,-1,-1 };\n\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tinit_prime();\n\n\tint m, n;\n\twhile (cin >> m >> n, m | n) {\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tauto s = init_Caves(m, n);\n\t\tif (Prime[n]) {\n\t\t\tdp[s.first][s.second] = { 1,n };\n\t\t}\n\t\telse {\n\t\t\tdp[s.first][s.second] = { 0,0 };\n\t\t}\n\t\tpii ans = { 0,0 };\n\n\t\tfor (int y = 1000; y >= 1; y--) {\n\t\t\tfor (int x = 1; x <= 1000; x++) {\n\t\t\t\tif (Caves[y][x] == 0) continue;\n\t\t\t\tif (dp[y][x].first == -1 && dp[y][x].second == -1) continue;\n\n\t\t\t\tif (dp[y][x].first > ans.first) {\n\t\t\t\t\tans.first = dp[y][x].first;\n\t\t\t\t\tans.second = dp[y][x].second;\n\t\t\t\t}\n\t\t\t\telse if (dp[y][x].first == ans.first && dp[y][x].second > ans.second) {\n\t\t\t\t\tans.second = dp[y][x].second;\n\t\t\t\t}\n\n\t\t\t\tint cave_count = dp[y][x].first;\n\t\t\t\tint last_prime = dp[y][x].second;\n\t\t\t\tfor (int k = 0; k < 3;k++) {\n\t\t\t\t\tint ny = y + dcy[k], nx = x + dcx[k];\n\t\t\t\t\tint next_cave_count = cave_count + (Prime[Caves[ny][nx]] == true);\n\t\t\t\t\tint next_last_prime = Prime[Caves[ny][nx]] ? Caves[ny][nx] : last_prime;\n\t\t\t\t\tif (next_cave_count > dp[ny][nx].first) {\n\t\t\t\t\t\tdp[ny][nx].first = next_cave_count;\n\t\t\t\t\t\tdp[ny][nx].second = next_last_prime;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (next_cave_count == dp[ny][nx].first && next_last_prime > dp[ny][nx].second) {\n\t\t\t\t\t\tdp[ny][nx].second = next_last_prime;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int, int> pii;\nconst int MAX_M = 1000000;\nconst int dx[] = {0, -1, 0, 1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ex[] = {1, 1, 1};\nconst int ey[] = {-1, 0, 1};\nconst int S = 510;\n \nint board[2*S][2*S];\npii rec[2*S][2*S];\nint posX[MAX_M + 1], posY[MAX_M + 1], isprime[MAX_M + 1];\n\nvoid init_board() {\n    int lim[] = {1, 1, 2, 2};\n    int cur = 1, x = S, y = S;\n\n    memset(board, -1, sizeof(board));\n    while(cur <= MAX_M) {\n        for(int k=0; k<4; k++) {\n            for(int t=0; t<lim[k]; t++) {\n                if(cur > MAX_M) return;\n                posX[cur] = x, posY[cur] = y;\n                board[x][y] = cur++;\n                x += dx[k], y += dy[k];\n            }\n            lim[k] += 2;\n        }\n    }\n}\n\nvoid init_prime() {\n    fill(isprime, isprime + MAX_M + 1, true);\n    isprime[0] = isprime[1] = false;\n    for(int i=2; i<=MAX_M; i++) {\n        if(isprime[i]) {\n            for(int k=2*i; k<=MAX_M; k+=i) {\n                isprime[k] = false;\n            }\n        }\n    }\n}\n\nint main() {\n    init_board();\n    init_prime();\n    while(1) {\n        int M, N; scanf(\"%d%d\", &M, &N);\n        if(M == 0) break;\n\n        pii INIT = make_pair(-1, -1);\n        for(int x=0; x<2*S; x++) {\n            fill(rec[x], rec[x] + 2*S, INIT);\n        }\n        pii ans = rec[posX[N]][posY[N]] = make_pair(isprime[N], isprime[N] ? N : 0);\n        for(int x=posX[N]; x<2*S; x++) {\n            for(int y=0; y<2*S; y++) {\n                int cur = board[x][y];\n                if(cur < 0 || cur > M || rec[x][y] == INIT) continue;\n                for(int k=0; k<3; k++) {\n                    int nx = x + ex[k], ny = y + ey[k];\n                    if(nx < 0 || nx >= 2*S || ny < 0 || ny >= 2*S) continue;\n                    int val = board[nx][ny];\n                    if(val < 0 || val > M) continue;\n                    int ncost = rec[x][y].first + isprime[val];\n                    int nprev = (isprime[val] ? val : rec[x][y].second);\n                    if(rec[nx][ny].first < ncost) {\n                        // printf(\"rec[%d][%d] = (%d, %d)\\n\", nx, ny, ncost, nprev);\n                        rec[nx][ny] = make_pair(ncost, nprev);\n                        ans = max(ans, rec[nx][ny]);\n                    }\n                }\n            }\n        }\n        printf(\"%d %d\\n\", ans.first, ans.second);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> P;\n#define F first\n#define S second\nint fie[1111][1111];\nint N,M;\nint sosu[1000001];\nP mie[1000001];\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\n\nP dp[1111][1111];\nint ndx[]={1,0,-1};\nP solve(int x,int y,int ss,int count){\n  if(dp[x][y].F!=-1 && dp[x][y].S!=-1) return dp[x][y];\n  if(fie[x][y]>N ||  fie[x][y] == -1 ){\n    return P(0,-1);\n  }\n  if(!sosu[fie[x][y]]){count++; ss = fie[x][y]; }\n  // printf(\"%d %d   count = %d  ss = %d fie=%d\\n\",x,y,count,ss,fie[x][y]);\n  P ret = P(0,-1);\n  for(int i=0;i<3;i++){\n    int nx = x+ndx[i];\n    int ny = y+1;\n    P state = solve(nx,ny,ss,count);\n    ret = max(ret,state);\n  }\n  if(!sosu[fie[x][y]]){\n    ret.F++;\n    if(ret.S==-1) ret.S=fie[x][y];\n  }\n  // printf(\"%d dp[%d][%d] =  %d, %d fie=%d\\n\",ss,x,y,ret.F,ret.S,fie[x][y]);\n   return dp[x][y] = ret;\n}\n\nint main(){\n  sosu[1]=1;\n  sosu[0]=1;\n  for(int i=2;i<=1000000;i++){\n    if(!sosu[i]){\n      for(int j=i+i;j<=1000000;j+=i){\n\tsosu[j]=1;\n      }\n    }\n  }\n  for(int i=0;i<1111;i++)\n    for(int j=0;j<1111;j++)\n      dp[i][j]=P(-1,-1);\n  memset(fie,-1,sizeof(fie));\n\n\n  int x = 1111/2,y = 1111/2;\n  int id = 1, ic = 0;\n  //printf(\"%d %d\\n\",x,y);\n  fie[x][y]=1;\n  x += dx[ic]; y += dy[ic];\n  mie[1]=P(x,y);\n \n  while( id < 1000000 ){\n    id++;\n    fie[x][y]=id;\n    mie[id] = P(x,y);\n    //if(id==1000000) printf(\"%d %d %d\\n\",id,x,y);\n    //    if(!sosu[fie[x][y]]) if(id<1000) printf(\"sosu::%d %d %d\\n\",id,x,y);\n    int nc = (ic+1)%4;\n    int nx = x+dx[nc], ny = y+dy[nc];\n    if( fie[nx][ny] == -1 ){\n      x = nx; y=ny;\n      ic=nc;\n    } else {\n      x = x + dx[ic]; y = y + dy[ic];\n    }\n  }\n\n\n  /*    for(int i=110;i<1111;i++){\n    for(int j=1100;j<1111;j++){\n      printf(\"%3d \",fie[j][i]);\n    }\n    puts(\"\");\n  }\n  */\n\n  while(1){\n    for(int i=0;i<1111;i++)\n      for(int j=0;j<1111;j++)\n\tdp[i][j]=P(-1,-1);\n    \n    cin >> N >> M;\n    if(!N && !M) break;\n    //    printf(\"%d %d\\n\",mie[N].F,mie[N].S);\n    P res = solve(mie[M].F,mie[M].S,-1,0);\n    /*    if(sosu[fie[mie[M]][Mie[M]]]){\n      res.F ++;\n      }*/\n    if(res.S == -1)\n      printf(\"%d %d\\n\",0,0);\n    else\n      printf(\"%d %d\\n\",res.F,res.S);\n    \n  }\n  \n  \n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b)*b; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T>& V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> >& Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T>& mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\ntemplate<typename T>vector<T> make_v(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type fill_v(T &t,const V &v){t=v;}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type fill_v(T &t,const V &v){for(auto &e:t) fill_v(e,v);}\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\n// 素数列挙\nconst ll MAX_PRIME = 1000005;\nvector<int> primes;\nvector<int> is_prime(MAX_PRIME + 1,true);\nvoid init_primes(){\n    is_prime[0] = is_prime[1] = false;\n    for(int i = 2; i <= MAX_PRIME;i++){\n        if(is_prime[i]){\n            primes.push_back(i);\n            for(int j = i*2; j <= MAX_PRIME; j+=i) is_prime[j] = false;\n        }\n    }\n}\n\nint caves[1005][1005];\npii init_caves(int m,int n){\n    int dx[4] = {1,0,-1,0};\n    int dy[4] = {0,1,0,-1};\n    \n    pii ret_s;\n    fill(*caves,*caves+1005*1005,0);\n    \n    int x = 500,y = 500;\n    int k = 1;\n    for(int i = 1; i <= m;i++){\n        if(i == n) ret_s = pii(x,y);\n        caves[x][y] = i;\n        x += dx[k]; y += dy[k];\n        \n        int nk = (k+1)%4;\n        int tx = x + dx[nk];\n        int ty = y + dy[nk];\n        if(caves[tx][ty] == 0) k = nk;\n    }\n    \n//    for(int i = 490; i <= 510; i++){\n//        for(int j = 490; j <= 510;j++){\n//            cout << caves[i][j] << \" \";\n//        }\n//        cout << endl;\n//    }\n    return ret_s;\n}\n\npii dp[1005][1005];\ntemplate<class Type>\nType solve(Type res = Type()){\n    init_primes();\n    \n    int n,m;\n    while(cin >> m >> n,n){\n        auto s = init_caves(m, n);\n        \n        fill(*dp,*dp+1005*1005,pii(-1,-1));\n        \n        if(is_prime[n]){\n            dp[s.first][s.second] = pii(1,n);\n        }else{\n            dp[s.first][s.second] = pii(0,0);\n        }\n        \n        pii ans = pii(-1,-1);\n        for(int x = 0; x <= 1000; x++){\n            for(int y = 0; y <= 1000;y++){\n                if(dp[x][y].first == -1) continue;\n                ans = max(ans,dp[x][y]);\n                for(int k = -1; k <= 1;k++){\n                    pii happy = dp[x][y];\n                    \n                    int val = caves[x+1][y+k];\n                    if(val == 0) continue;\n                    \n                    if(is_prime[val]){\n                        happy.first++;\n                        happy.second = val;\n                    }\n                    \n                    dp[x+1][y+k] = max(dp[x+1][y+k],happy);\n                }\n            }\n        }\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    solve(0);\n    // cout << fixed << setprecision(15) << solve<ll>() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n#define ALLNUM 1005\n#define fin cin\n\nint all, start;\nint map[ALLNUM][ALLNUM] = {};\n\nbool isPrime(int n){\n    if(n <= 1)return false;\n    if(n == 2)return true;\n    if(n % 2 == 0)return false;\n    \n    for(int i = 3; i * i <= n; i+=2){\n        if(n % i == 0)return false;\n    }\n    return true;\n}\n\nclass Pair{\n    \npublic:\n    int num;\n    int count;\n    \n    Pair(){\n        this->num = 0;\n        this->count = 0;\n    };\n    Pair(int _num){\n        if(isPrime(_num)){\n            this->num = _num;\n            this->count = 1;\n        }\n        else {this->num = this->count = 0;}\n    }\n    \n    Pair operator + (const Pair &p){\n        this->count += p.count;\n        if(p.num != 0)this->num = p.num;\n        return *this;\n    }\n    \n    void print(){\n        cout << this->count << \" \" << this->num;\n    }\n};\n\nbool come[ALLNUM][ALLNUM];\nPair pMap[ALLNUM][ALLNUM];\n\nvoid init(){\n    \n    for(int i = 0; i < ALLNUM; i++){\n        for(int j = 0; j < ALLNUM; j++){\n            pMap[i][j] = Pair(0);\n            come[i][j] = false;\n        }\n    }\n}\n\nPair calc(int y, int x){\n    \n    if(map[y][x] > all)return Pair(-10);\n    if(come[y][x])return pMap[y][x];\n    \n    Pair p(map[y][x]);\n    Pair ans;\n    \n    Pair tmp1 = calc(y + 1, x);\n    Pair tmp2 = calc(y + 1, x + 1);\n    \n    if (tmp1.count == tmp1.count) {\n        if (tmp1.num < tmp2.num)tmp1.count--;\n    }\n    \n    if (tmp1.count < tmp2.count)ans =  tmp2;\n    else ans = tmp1;\n    \n    tmp1 = calc(y + 1, x - 1);\n    \n    if (tmp1.count < ans.count);\n    else ans = tmp1;\n    \n    /*\n     if (tmp1.count == tmp2.count) {\n     if(tmp1.num == tmp2.num)ans = tmp1;\n     else if(tmp1.num < tmp2.num)ans = tmp2;\n     else ans = tmp1;\n     }\n     else if(tmp1.count < tmp2.count)ans = tmp2;\n     else ans = tmp1;\n     \n     tmp2 = calc(y + 1, x - 1);\n     if (ans.count == tmp2.count) {\n     if(ans.num == tmp2.num);\n     else if(ans.num < tmp2.num)ans = tmp2;\n     else ;\n     }\n     else if(ans.count < tmp2.count)ans = tmp2;\n     else ;\n     */\n    \n    come[y][x] = true;\n    return pMap[y][x] = p + ans;\n}\n\nint main() {\n  //  ifstream fin(\"in.txt\");\n    \n    int x, y;\n    x = y = ALLNUM / 2;\n    \n    map[y][x] = 1;\n    \n    int gumi = 1;\n    int num = 1;\n    \n    while(num < (ALLNUM - 1) * (ALLNUM - 1)){\n        for(int i = 0; i < gumi; i++){\n            map[y][++x] = ++num;\n        }\n        if(num >= ALLNUM * ALLNUM)break;\n        \n        for(int i = 0; i < gumi; i++){\n            map[--y][x] = ++num;\n        }\n        if(num >= ALLNUM * ALLNUM)break;\n        \n        gumi++;\n        for(int i = 0; i < gumi; i++){\n            map[y][--x] = ++num;\n        }\n        if(num >= ALLNUM * ALLNUM)break;\n        \n        for(int i = 0; i < gumi; i++){\n            map[++y][x] = ++num;\n        }\n        if(num >= ALLNUM * ALLNUM)break;\n        gumi++;\n    }\n    \n    while(true){\n        fin >> all >> start;\n        if((all | start) == 0)break;\n        \n        init();\n        x = y = 0;\n        \n        for(int i = 0; i < ALLNUM; i++){\n            for(int j = 0; j < ALLNUM; j++){\n                if(map[j][i] == start){\n                    x = i;\n                    y = j;\n                    i = j = ALLNUM;//?????????break;\n                    break;\n                }\n            }\n        }\n        calc(y, x).print();\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define MAX 1000001\n#define SIZE 2000\n\nusing namespace std;\n\nint m, n;\nint table[SIZE][SIZE]={{0,0}};\nint dp[SIZE][SIZE];\nbool prime[MAX]; \npair<int, int>coord[MAX];//座標\npair<int, int> ans;// <素数の数, 出口の番号>\n\n\nvoid dfs(int count, int y, int x){\n\tint num = table[y][x];\n\tif(num <= 0 || m < num) return;\n\tif(count < dp[y][x] || (count == dp[y][x] && prime[num] == false && dp[y][x] !=0)) return;\n\tdp[y][x] = count;\n\n\tif(prime[num] == true){\n\t\tcount++;\n\t\tdp[y][x] = count;\n\t\tif(ans.first < count || (ans.first == count && ans.second < num)){\n\t\t\tans.first = count;\n\t\t\tans.second = num;\n\t\t}\n\t}\n\n\tfor(int dx=-1; dx<=1; dx++){\n\t\tdfs(count, y+1, x+dx);\n\t}\n}\n\n\nint main(void){\n\tfill(prime, prime+MAX, true);\n\tprime[0] = prime[1] = false;\n\tfor(int i=2; i<MAX; i++){\n\t\tif(prime[i]){\n\t\t\tfor(int j=i+i; j<MAX; j+=i){\n\t\t\t\tprime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tint d=0, x=1000, y=1000;\n\tint dx[4]={0, 1, 0, -1};\n\tint dy[4]={1, 0, -1, 0};\n\tfor(int i=1; i<MAX; i++){\n\t\ttable[y][x] = i;\n\t\tcoord[i] = make_pair(y, x);\n\t\tif(table[y+dy[(d+1)%4]][x+dx[(d+1)%4]] == 0) d++;\n\t\tx += dx[d%4];\n\t\ty += dy[d%4];\n\t}\n\n\twhile(1){\n\t\tcin >> m >> n;\n\t\tif(!m && !n) break;\n\n\t\tint y = coord[n].first;\n\t\tint x = coord[n].second;\n\t\tfill(dp[0], dp[2000], 0);\n\t\tans = make_pair(0, 0);\n\t\tdfs(0, y, x);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define SIZE 1000\n\nbool C(int dp1, int pr1, int dp2, int pr2) {\n\tif (dp2 == 0)return false;\n\tif (dp1 < dp2 || (dp1 == dp2&&pr1 < pr2))return true;\n\treturn false;\n}\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool complete;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i <= SIZE&&a <= SIZE*SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x--;\n\t\t\telse x++;\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\tcomplete = false;\n\t\twhile (!complete) {\n\t\t\twhile (x >= 0 && !complete) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x - 1], pr[y + 1][x - 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x], pr[y + 1][x])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x + 1], pr[y + 1][x + 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (table[y][x] == n)complete = true;\n\t\t\t\telse x--;\n\t\t\t}\n\t\t\treturn 0;\n\t\t\tif (!complete) {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n/*\n100 099 098 097 096 095 094 093 092 091\n065 064 063 062 061 060 059 058 057 090\n066 037 036 035 034 033 032 031 056 089\n067 038 017 016 015 014 013 030 055 088\n068 039 018 005 004 003 012 029 054 087\n069 040 019 006 001 002 011 028 053 086\n070 041 020 007 008 009 010 027 052 085\n071 042 021 022 023 024 025 026 051 084\n072 043 044 045 046 047 048 049 050 083\n073 074 075 076 077 078 079 080 081 082\n*/\n\nconst int MAX_N = 1000;\nconst int MAX_N2 = MAX_N * MAX_N;\n\nint caves[MAX_N][MAX_N]; // ここに置かないとSegmentation falutになる\npair<short, int> dp[MAX_N][MAX_N]; // 素数洞穴の数、最後に通った素数洞穴の番号\nbool is_prime[MAX_N2 + 1];\n\n// 入力\nint n, m;\n\nvoid sieve() {\n\tfor (int i = 0; i <= MAX_N2; i++) {\n\t\tis_prime[i] = true;\n\t}\n\tis_prime[0] = is_prime[1] = false;\n\tfor (int i = 2; i <= MAX_N2; i++) {\n\t\tif (is_prime[i]) {\n\t\t\tfor (int j = 2 * i; j <= MAX_N2; j += i) {\n\t\t\t\tis_prime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn;\n}\n\n// 初期化 素数表と洞穴を作成\nvoid init() {\n\tsieve();\n\tint dx[4] = {1, 0, -1, 0};\n\tint dy[4] = {0, 1, 0, -1};\n\t\n\tint num = MAX_N2;\n\tint array = 0;\n\tint x = 0;\n\tint y = 0;\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tcaves[i][j] = 0;\n\t\t}\n\t}\n\t\n\tfor (int i = num; i > 0; i--) {\n\t\tcaves[y][x] = i;\n\t\tint tx = x + dx[array];\n\t\tint ty = y + dy[array];\n\t\tif (tx < 0 || tx >= MAX_N || ty < 0 || ty >= MAX_N || caves[ty][tx] != 0) {\n\t\t\tarray = (array + 1) % 4;\n\t\t}\n\t\tx += dx[array];\n\t\ty += dy[array];\n\t}\n\t/*\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tif (j > 0) {\n\t\t\t\tcout << \" \";\n\t\t\t}\n\t\t\tprintf(\"%7d\", caves[i][j]);\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n\treturn;\n}\n\nvoid search(int sx, int sy) {\n\tfor (int i = MAX_N - 1; i >= 0; i--) {\n\t\tfor (int j = MAX_N - 1; j >= 0; j--) {\n\t\t\tif (caves[i][j] > m) {\n\t\t\t\tdp[i][j].first = 0;\n\t\t\t\tdp[i][j].second = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i == MAX_N - 1) {\n\t\t\t\tif (is_prime[caves[i][j]]) {\n\t\t\t\t\tdp[i][j].first = 1;\n\t\t\t\t\tdp[i][j].second = caves[i][j];\n\t\t\t\t} else {\n\t\t\t\t\tdp[i][j].first = 0;\n\t\t\t\t\tdp[i][j].second = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpair<short, int> tmp[3];\n\t\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\t\ttmp[k+1].first = dp[i+1][j+k].first;\n\t\t\t\t\ttmp[k+1].second = dp[i+1][j+k].second;\n\t\t\t\t}\n\t\t\t\tsort(tmp, tmp + 3, greater<pair<short, int> >());\n\t\t\t\tdp[i][j].first = tmp[0].first;\n\t\t\t\tdp[i][j].second = tmp[0].second;\n\t\t\t\tif (is_prime[caves[i][j]]) {\n\t\t\t\t\tdp[i][j].first++;\n\t\t\t\t\tif (dp[i][j].second == 0) {\n\t\t\t\t\t\tdp[i][j].second = caves[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nvoid solve(int sx, int sy) {\n\tsearch(sx, sy);\n\tcout << dp[sy][sx].first << \" \" << dp[sy][sx].second << endl;\n}\n\nint main() {\n\tinit();\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tint sx, sy;\n\t\tfor (int i = 0; i < MAX_N; i++) {\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tdp[i][j].first = 0;\n\t\t\t\tdp[i][j].second = 0;\n\t\t\t\tif (caves[i][j] == n) {\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve(sx, sy);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int MAX = 1000010;\n\nint prime[MAX];\nbool is_prime[MAX];\nint sieve(int n) {\n\tint p = 0;\n\tfor(int i = 0; i <= n; i++) {\n\t\tis_prime[i] = true;\n\t}\n\tis_prime[0] = is_prime[1] = false;\n\tfor(int i = 2; i <= n; i++) {\n\t\tif(is_prime[i]) {\n\t\t\tprime[p++] = i;\n\t\t\tfor(int j = 2 * i; j <= n; j += i) {\n\t\t\t\tis_prime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\treturn p;\n}\n\nconst int CENTER = 2000;\nint b[CENTER * 2][CENTER * 2];\nbool v[CENTER * 2][CENTER * 2];\nint pi[MAX], pj[MAX];\nP dp[CENTER * 2][CENTER * 2];\n\nbool comp(P p1, P p2) {\n\tif(p1.first != p2.first) return p1.first < p2.first;\n\treturn p1.second < p2.second;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tsieve(1000000);\n\tint nx = CENTER, ny = CENTER, dirx = 0, diry = 1;\n\tfor(int i = 1; i <= 1000000; i++) {\n\t\tb[ny][nx] = i;\n\t\tint dlx = diry, dly = -dirx;\n\t\tif(b[ny + dly][nx + dlx] == 0) {\n\t\t\tdirx = dlx;\n\t\t\tdiry = dly;\n\t\t}\n\t\tnx += dirx;\n\t\tny += diry;\n\t}\n\n\tint n, m;\n\twhile(cin >> m >> n, n | m) {\n\t\tfor(int y = 0; y < CENTER * 2; y++) {\n\t\t\tfor(int x = 0; x < CENTER * 2; x++) {\n\t\t\t\tdp[y][x] = make_pair(0, 0);\n\t\t\t\tv[y][x] = false;\n\t\t\t\tif(b[y][x] == n) v[y][x] = true;\n\t\t\t}\n\t\t}\n\n\t\tP ans = make_pair(0, 0);\n\t\tfor(int y = 0; y < CENTER * 2; y++) {\n\t\t\tfor(int x = 0; x < CENTER * 2; x++) if(v[y][x]) {\n\t\t\t\tif(is_prime[b[y][x]]) {\n\t\t\t\t\tdp[y][x] = make_pair(dp[y][x].first + 1, b[y][x]);\n\t\t\t\t}\n\n\t\t\t\tfor(int dx = -1; dx <= 1; dx++) {\n\t\t\t\t\tif(b[y + 1][x + dx] != 0 && b[y + 1][x + dx] <= m) {\n\t\t\t\t\t\tv[y + 1][x + dx] = true;\n\t\t\t\t\t\tdp[y + 1][x + dx] = max(dp[y + 1][x + dx], dp[y][x]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = max(ans, dp[y][x]);\n\t\t\t}\n\t\t}\n\t\tif(ans.first) {\n\t\t\tcout << ans.first << \" \" << ans.second << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"0 0\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\npair<int, int> dp[1005][1005];\n\nclass UlamSpiral{\n\tprivate:\n\t\tconst static int MAX_N = 1005;\n\t\tconst static int kN = 1000000;\n\t\tvoid primeNumber(bool prime[kN]){\n\t\t\trep(i,kN) prime[i] = 1;\n\t\t\tprime[0] = prime[1] = 0;\n\t\t\trep(i,kN){\n\t\t\t\tif(prime[i]){\n\t\t\t\t\tfor(int j = i + i; j < kN; j+=i){\n\t\t\t\t\t\tprime[j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tpublic:\n\t\tint spiral[MAX_N][MAX_N] = {{0}};\n\t\tint CENTER;\n\t\tbool p[kN] = {0};\n\t\tconst int dy[4] = { 0,-1, 0, 1}; //???????¨???????\n\t\tconst int dx[4] = { 1, 0,-1, 0};\n\t\tUlamSpiral(int n){ //?????¶??°?????°\n\t\t\tCENTER = MAX_N / 2;;\n\n\t\t\tprimeNumber(p);\n\n\t\t\tint x = CENTER, y = CENTER;\n\t\t\tint dir = 0; //?????????\n\t\t\trep(i,n){\n\t\t\t\tspiral[y][x] = i + 1;\n\t\t\t\tx += dx[dir % 4];\n\t\t\t\ty += dy[dir % 4];\n\n\t\t\t\tint nx = x + dx[(dir + 1) % 4];\n\t\t\t\tint ny = y + dy[(dir + 1) % 4];\n\t\t\t\tif(spiral[ny][nx] == 0){\n\t\t\t\t\tdir++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpair<int, int> getPoint(int n){ //??°???n???????????§?¨?\n\t\t\trep(i,MAX_N){\n\t\t\t\trep(j,MAX_N){\n\t\t\t\t\tif(spiral[i][j] == n){\n\t\t\t\t\t\treturn make_pair(i,j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(false);\n\t\t\treturn make_pair(-1,-1);\n\t\t}\n\n\t\tbool isPrime(int n){\n\t\t\treturn p[n];\n\t\t}\n\t\tbool isPrime(int y, int x){\n\t\t\tif(spiral[y][x] == -1) return 0;\n\t\t\treturn p[spiral[y][x]];\n\t\t}\n\n\t\tvoid out(){\n\t\t\tshow(CENTER)\n\t\t\tfor(int i = CENTER - 11; i < CENTER + 11; i++){\n\t\t\tfor(int j = CENTER - 11; j < CENTER + 11; j++){\n\t\t\t\t//printf(\"%02d \", spiral[i][j]);\n\t\t\t\tif(p[spiral[i][j]]){\n\t\t\t\tprintf(\"%02d \", spiral[i][j]);\n\t\t\t\t}else{\n\t\t\t\t\tcout << \"__ \";\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << endl;\n\n\t\t\t}\n\t\t}\n};\n\nint main(){\n\tint m,n;\n\twhile(cin >> m >> n, n){\n\t\tUlamSpiral ulam(m);\n\t\t//ulam.out();\n\n\t\tpair<int, int> s = ulam.getPoint(n);\n\t\trep(i,1005) rep(j,1005) dp[i][j] = make_pair(-1,-1);\n\t\tdp[s.first][s.second] = make_pair(0,-1);\n\n\t\trange(i,s.first,1001){\n\t\t\trange(j,1,1001){\n\t\t\t\tif(dp[i][j].first == -1) continue;\n\t\t\t\tif(ulam.isPrime(i,j)) {\n\t\t\t\t\tdp[i][j] = make_pair(dp[i][j].first + 1, ulam.spiral[i][j]);\n\t\t\t\t}\n\t\t\t\tfor(int k = -1; k <= 1; k++){\n\n\t\t\t\t\tif(dp[i + 1][j + k].first < dp[i][j].first){\n\t\t\t\t\t\tdp[i + 1][j + k] = dp[i][j];\n\t\t\t\t\t}else if(dp[i + 1][j + k].first == dp[i][j].first){\n\t\t\t\t\t\tif(dp[i + 1][j + k].second < dp[i][j].second){\n\t\t\t\t\t\t\tdp[i + 1][j + k] = dp[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\tvector<pair<int, int>> b;\n\t\t//cout << s.first << ' ' << s.second << endl;\n\t\trep(i,1001){\n\t\t\tfor(int j = 1001; j >= 0; j--){\n\t\t\t\tif(ulam.spiral[j][i] != 0){\n\t\t\t\t\t//show(ulam.spiral[j][i])\n\t\t\t\t\t//\tshow(dp[j][i].first)\n\t\t\t\t\t//\tshow(dp[j][i].second)\n\t\t\t\t\t//cout << j << ' ' << i << endl;\n\t\t\t\t\tb.emplace_back(j,i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint p = 0;\n\t\trep(i,b.size()){\n\t\t\t//cout << dp[i.first][i.second] << endl;\n\t\t\tif(dp[b[i].first][b[i].second].first > dp[b[p].first][b[p].second].first){\n\t\t\t\tp = i;\n\t\t\t}else if(dp[b[i].first][b[i].second].first == dp[b[p].first][b[p].second].first && dp[b[i].first][b[i].second].second > dp[b[p].first][b[p].second].second){\n\t\t\t\tp = i;\n\t\t\t}\n\t\t}\n\n\t\tif(dp[b[p].first][b[p].second].first == 0){\n\t\t\tcout << \"0 0\" << endl;\n\t\t}else{\n\t\t\tpair<int, int> pr = dp[b[p].first][b[p].second];\n\t\t\tcout << pr.first << ' ' << pr.second << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t\n\t\toutput = false;\n\t\tfor (int h = 0;h < SIZE && (!output);h++) {\n\t\t\tfor (int w = 0;w < SIZE && (!output);w++) {\n\t\t\t\tcout << dp[h][w] << \" \" << pr[h][w] << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n// ????????????\nconst int dx[] = {1,0,-1,0}; const int dy[] = {0,-1,0,1};\n\nconst int MAX_H = 1005;\nconst int MAX_W = 1005;\n\nconst int MAX_M = 1e6;\n\nbool prime[MAX_M+1];\nint cave[MAX_H][MAX_W];\n\nvoid find_start(int start_num, int& sx, int& sy) {\n    REP(y, MAX_H) REP(x, MAX_W) {\n        if (cave[y][x] == start_num) {\n            sx = x;\n            sy = y;\n            return;\n        }\n    }\n}\n\nint main() {\n    prime[0] = prime[1] = true;\n    FOR(i, 2, MAX_M+1) {\n        if (prime[i]) continue;\n        for (int j = i+i; j < MAX_M+1; j += i) {\n            prime[j] = true;\n        }\n    }\n\n    int y = MAX_H/2, x = MAX_W/2;\n    int d = 0;\n    FOR(i, 1, MAX_M+1) {\n        cave[y][x] = i;\n        y += dy[d];\n        x += dx[d];\n        int d2 = (d + 1) % 4;\n        if (cave[y + dy[d2]][x + dx[d2]] == 0) {\n            d = d2;\n        }\n    }\n\n    int caves, start_n;\n    while (cin >> caves >> start_n, caves|start_n) {\n        int x, y;\n        find_start(start_n, x, y);\n\n        pii res = {0, 0}; // ?????°, ?´???°?´?????????????\n\n        vector<int> G(MAX_W, -1);\n        G[x] = 0;\n        bool updated;\n        do {\n            updated = false;\n            vector<int> G2(G);\n            REP(x, MAX_W) {\n                if (G[x] == -1 || cave[y][x] > caves) continue;\n                if (!prime[cave[y][x]]) {\n                    G[x]++;\n                    pair<int, int> r(G[x], cave[y][x]);\n                    res = max(res, r);\n                }\n                for (int dx = -1; dx <= 1; dx++) {\n                    int sx = x + dx;\n                    int sy = y + 1;\n                    if (0 <= sx && sx < MAX_W && 0 <= sy && sy < MAX_H) {\n                        if (cave[sy][sx] != 0 && cave[sy][sx] <= caves) {\n                            G2[sx] = max(G[x], G2[sx]);\n                            updated = true;\n                        }\n                    }\n                }\n            }\n            G = G2;\n            if (++y >= MAX_H) break;\n        } while (updated);\n        printf(\"%d %d\\n\", res.first, res.second);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define H 1000\n#define W 1000\nusing namespace std;\nint grid[H][W];\ntypedef pair<int, int> pii;\n\npii dp[(int)1e6 + 1];//first cnt, second max\nbool isprime[(int)1e6 + 1];\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid sieve(int n){\n  isprime[0] = isprime[1] = true;\n  for(int i = 2; i <= n; i++){\n    if(isprime[i])continue;\n    for(int j = 2*i; j <= n; j+=i)isprime[j] = true;\n  }\n}\n\n\nbool renge(int x, int y){\n  if(0 <= x && x < W &&\n     0 <= y && y < H)return true;\n  return false;\n}\nvector<int> inM(int y, int x, int m){\n  vector<int> res;\n  if(y + 1 >= H) return res;\n  for(int i = -1; i < 2; i++){\n    if(grid[y + 1][x + i] <= m)res.push_back(i);\n  }\n  return res;\n}\n\nint main(int argc, char *argv[]){\n  sieve((int)1e6);\n  int n = H*W, m, x = 0, y = 0, dir = 0;\n  while(n > 1){\n    for(;renge(x + dx[dir], y + dy[dir]) && \n\t  grid[y + dy[dir]][x + dx[dir]] == 0;){\n      grid[y][x] = n;\n      n--;\n      x += dx[dir], y += dy[dir];\n    }\n    grid[y][x] = n;\n    n--;\n    dir++;\n    dir %= 4;\n    x += dx[dir], y += dy[dir];\n  }\n  while(cin >> m >> n, n){\n    memset(dp, 0, sizeof(dp));\n    for(int i = H - 1; i >= 0; i--){\n      for(int j = 0; j < W; j++){\n\tif(grid[i][j] <= m){\n\t  vector<int> cand = inM(i, j, m);\n\t  for(int k = 0; k < cand.size(); k++){\n\t    dp[grid[i][j]] = max(dp[grid[i][j]], dp[grid[i + 1][j + cand[k]]]);\n\t  }\n\t  if(!isprime[grid[i][j]]){\n\t    dp[grid[i][j]].first++;\n\t    if(dp[grid[i][j]].second == 0)dp[grid[i][j]].second = grid[i][j];\n\t  }\n\t}\n      }\n    }\n    cout << dp[n].first << \" \" << dp[n].second << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\n#define mp make_pair\ntypedef pair<int,int> pii;\n\npii fill(vector<vector<int>> &maze, int x, int y, int dir, int k, int s) {\n  for (int i = 0; i < k; i++) {\n    maze[y + i * dy[dir]][x + i * dx[dir]] = s++;\n  }\n  return mp(x + k * dx[dir], y + k * dy[dir]);\n}\n\nvoid make(vector<vector<int>> &maze) {\n  pii now = mp(2000, 2000);\n  int k = 1;\n  int num = 1;\n  while(num <= 1e6 + 10) {\n    now = fill(maze, now.first, now.second, 0, k, num); num += k;\n    now = fill(maze, now.first, now.second, 1, k, num); num += k;\n    k++;\n    now = fill(maze, now.first, now.second, 2, k, num); num += k;\n    now = fill(maze, now.first, now.second, 3, k, num); num += k;\n    k++;\n  }\n  \n}\n\nint isprime[1000010];\n\nvoid era() {\n  for (int i = 0; i < 1000010; i++) {\n    isprime[i] = 1;\n  }\n  isprime[0] = isprime[1] = 0;\n  for (int i = 2; i < 1000010; i++) {\n    if (isprime[i]) {\n      for (int j = i + i; j < 1000010; j += i) {\n        isprime[j] = 0;\n      }\n    }\n  }\n}\n\nvoid solve(vector<vector<int>> &maze, int m, int n) {\n  int sx, sy;\n  for (int i = 0; i < 4000; i++) {\n    for (int j = 0; j < 4000; j++) {\n      if (maze[i][j] == n) {\n        sx = j, sy = i;\n      }\n    }\n  }\n  vector<vector<int>> dp(4000, vector<int>(4000, -1));\n  dp[sy][sx] = isprime[maze[sy][sx]];\n  for (int i = 0; i < 3999; i++) {\n    for (int j = 0; j < 4000; j++) {\n      if (maze[i][j] > m) continue;\n      if (dp[i][j] == -1) continue;\n      if (j >= 1) dp[i + 1][j - 1] = max(dp[i + 1][j - 1], dp[i][j] + isprime[maze[i + 1][j - 1]]);\n      dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + isprime[maze[i + 1][j]]);\n      if (j < 3999) dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + isprime[maze[i + 1][j + 1]]);\n    }\n  }\n\n\n  int ma = 0;\n  int ma_ind = 0;\n  for (int i = 0; i < 4000; i++) {\n    for (int j = 0; j < 4000; j++) {\n      if (maze[i][j] > m) continue;\n      if (ma <= dp[i][j] && isprime[maze[i][j]]) {\n        ma = dp[i][j];\n        ma_ind = maze[i][j];\n      }\n    }\n  }\n  if (ma == 0) {\n    cout << \"0 0\" << endl;\n  } else {\n    cout << ma << \" \" << ma_ind << endl;\n  }\n}\n\nint main() {\n  vector<vector<int>> maze(4000, vector<int>(4000, 0));\n  make(maze);\n  era();\n\n  int n, m;\n  while(cin >> m >> n, m != 0) {\n    solve(maze, m, n);\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> P;\nbool is_prime[1000010] = {};\nint dx[4] = {0,-1,0,1},dy[4] = {1,0,-1,0};\nint field[1010][1010] = {};\nP dp[1010][1010] = {};\n\nint main(){\n    int N,M;\n    while(cin >> M >> N && M>0){\n        for(int i=2;i<=M;i++) is_prime[i] = true;\n        for(int i=2;i<=M;i++){\n            if(!is_prime[i]) continue;\n            for(int j=2;i*j<=M;j++) is_prime[i*j] = false;\n        }\n        int x = 0,y = 0;\n        map<int,P> m;\n        int mi_x = 1e9,mi_y = 1e9;\n        int direction = 0;\n        int now = 0,corner = 2,cnt = 2;\n        m[1] = {0,0};\n        for(int i=2;i<=M;i++){\n            x += dx[direction]; y += dy[direction];\n            m[i] = {x,y};\n            if(i==corner){\n                direction++;\n                direction %= 4;\n                cnt++;\n                corner += cnt/2;\n            }\n            mi_x = min(mi_x,x);\n            mi_y = min(mi_y,y);\n        }\n        int ma_x = 0,ma_y = 0;\n        for(auto a:m){\n            m[a.first].first -= mi_x;\n            m[a.first].second -= mi_y;\n            ma_x = max(m[a.first].first,ma_x);\n            ma_y = max(m[a.first].second,ma_y);\n        }\n//        cerr << \"ma_x:\" << ma_x << \" ma_y:\" << ma_y << endl;\n        for(int i=0;i<=ma_x;i++) for(int j=0;j<=ma_y;j++) field[i][j] = -1;\n        for(int i=1;i<=M;i++){\n            field[m[i].first][m[i].second] = i;\n        }\n        for(int i=ma_x;i>=0;i--){\n            for(int j=0;j<=ma_y;j++){\n                if(field[i][j]==-1) continue;\n                if(i==ma_x) dp[i][j] = {is_prime[field[i][j]],(is_prime[field[i][j]]? field[i][j]:-1)};\n                else{\n                    P best = dp[i+1][j];\n                    if(j>0 && field[i+1][j-1]!=-1 && best<dp[i+1][j-1]) best = dp[i+1][j-1];\n                    if(j<ma_y && field[i+1][j+1]!=-1 && best<dp[i+1][j+1]) best = dp[i+1][j+1];\n                    dp[i][j] = best;\n                    dp[i][j].first += is_prime[field[i][j]];\n                    if(is_prime[field[i][j]] && dp[i][j].second==-1) dp[i][j].second = field[i][j];\n                }\n            }\n        }\n/*        for(int i=0;i<=ma_x;i++){\n            for(int j=0;j<=ma_y;j++) cerr << dp[i][j].second << \" \";\n            cerr << endl;\n        }\n*/       int sx = m[N].first,sy = m[N].second;\n        cout << dp[sx][sy].first << \" \" << (dp[sx][sy].first!=0? dp[sx][sy].second:0) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\nusing namespace std;\n#define MAX 1000005\nint F[MAX]={1,1},i,j,p=0,N,M,C[1005][1005],pos[MAX][2],dp[MAX],t,nc;\ntypedef struct D{int c,np,now;}D;\n\nvoid set(int n,int y,int x){C[y][x]=n;pos[n][0]=y;pos[n][1]=x;}\n\nvoid vortex()\n{\n\tint i,j,pre,nx,ny,mv[5]={-1,0,1,0,-1};\n\tmemset(C,0x7f,sizeof(C));\n\tnx=1005/2;ny=1005/2;\n\tset(1,ny,nx++);\n\tset(2,ny,nx);\n\tfor(i=3,pre=i-1;i<MAX;pre=i++)\n\t{\n\t\tfor(j=0;j<4;j++)\n\t\t{\n\t\t\tif(C[ny+mv[j]][nx+mv[j+1]]==pre-1)\n\t\t\t\tbreak;\n\t\t}\n\t\tfor(;C[ny+mv[j]][nx+mv[j+1]]<MAX;)\n\t\t\tj=(j+1)%4;\n\t\tny+=mv[j];\n\t\tnx+=mv[j+1];\n\t\tset(i,ny,nx);\n\t}\n}\n\nint main()\n{\n\tfor(i=2;i<MAX;i++)\n\t\tif(!F[i])\n\t\t{\n\t\t\tfor(j=i*2;j<MAX;j+=i)\n\t\t\t\tF[j]=1;\n\t\t}\n\tvortex();\n\tfor(;scanf(\"%d%d\",&M,&N),N+M;)\n\t{\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tqueue<D>Q;\n\t\tD tmp={!F[N],(!F[N])?N:0,N},r=tmp;\n\t\tQ.push(tmp); \n\t\twhile(!Q.empty())\n\t\t{\n\t\t\ttmp=Q.front();Q.pop();\n\t\t\tif(r.c<tmp.c||(tmp.c==r.c&&tmp.np>r.np))\n\t\t\t\tr=tmp;\n\t\t\tif(tmp.c<dp[tmp.now])continue;\n\t\t\tdp[tmp.now]=tmp.c;\n\t\t\tfor(i=-1;i<2;i++)\n\t\t\t{\n\t\t\t\tt=C[pos[tmp.now][0]+1][pos[tmp.now][1]+i];\n\t\t\t\tif(t>M)continue;\n\t\t\t\tnc=tmp.c+(!F[t]);\n\t\t\t\tif(dp[t]<nc)\n\t\t\t\t{\n\t\t\t\t\tD ins={nc,(!F[t])?t:tmp.np,t};\n\t\t\t\t\tdp[t]=ins.c;\n\t\t\t\t\tQ.push(ins);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",r.c,r.np);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(y=SIZE-1;y>=0;y--){\n\t\t\tfor(x=SIZE-1;x>=0;x--){\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&\n\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x - 1]||(dp[y][x] == dp[y + 1][x - 1] && pr[y][x] < pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && \n\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x] || (dp[y][x] == dp[y + 1][x] && pr[y][x] < pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && \n\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x + 1] || (dp[y][x] == dp[y + 1][x + 1] && pr[y][x] < pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (y = 0;y < SIZE;y++) {\n\t\t\tfor (x = 0;x < SIZE;x++) {\n\t\t\t\tif (table[y][x] == n) {\n\t\t\t\t\tcout << dp[0][0] << \" \" << pr[y][x] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst int N = 1111111;\nbool prime[N];\nset<int> primes;\n\nvoid hurui()\n{\n\tmemset(prime, true, sizeof(prime));\n\tprime[0] = prime[1] = false;\n\tfor (int i = 2; i*i < N; i++)\n\t{\n\t\tfor (int j = 2; i*j < N; j++)\n\t\t{\n\t\t\tprime[i*j] = false;\n\t\t}\n\t}\n\tREP(i, N + 1)\n\t{\n\t\tif (prime[i]) primes.insert(i);\n\t}\n}\n\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\n\nbool fld[1200][1200] = {};\nint index[1200][1200];\npii hs[1111111];\n\nvoid init()\n{\n\tREP(i, 1200)REP(j, 1200) index[i][j] = INF;\n\thurui();\n\tint p = 1, x = 600, y = 600;\n\tFOR(i, 1, 11111111)\n\t{\n\t\tif (i % 2)\n\t\t{\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tindex[x][y] = p;\n\t\t\t\ths[p] = pii(x, y);\n\t\t\t\tif (primes.count(p)) fld[x][y] = true;\n\t\t\t\tp++;\n\t\t\t\ty++;\n\t\t\t}\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tindex[x][y] = p;\n\t\t\t\ths[p] = pii(x, y);\n\t\t\t\tif (primes.count(p)) fld[x][y] = true;\n\t\t\t\tp++;\n\t\t\t\tx--;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tindex[x][y] = p;\n\t\t\t\ths[p] = pii(x, y);\n\t\t\t\tif (primes.count(p)) fld[x][y] = true;\n\t\t\t\tp++;\n\t\t\t\ty--;\n\t\t\t}\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tindex[x][y] = p;\n\t\t\t\ths[p] = pii(x, y);\n\t\t\t\tif (primes.count(p)) fld[x][y] = true;\n\t\t\t\tp++;\n\t\t\t\tx++;\n\t\t\t}\n\t\t}\n\t\tif (p > 1000000) break;\n\t}\n}\n\npii dp[1200][1200];\nint n, m;\n\npii solve(int x, int y)\n{\n\tif (dp[x][y] !=pii(-1,-1)) return dp[x][y];\n\tpii res(0, -1);\n\tFOR(i, -1, 2)\n\t{\n\t\tint nx = x + 1, ny = y + i;\n\t\tif (index[nx][ny] > m) continue;\n\t\tpii next = solve(nx, ny);\n\t\tif (fld[nx][ny])\n\t\t{\n\t\t\tif (next.first == 0) chmax(res, pii(next.first + 1, index[nx][ny]));\n\t\t\telse chmax(res, pii(next.first + 1, next.second));\n\t\t}\n\t\telse chmax(res, next);\n\t}\n\treturn dp[x][y] = res;\n}\n\nint main()\n{\n\tinit();\n\twhile (cin >> m >> n, n)\n\t{\n\t\tREP(i, 1200)REP(j, 1200) dp[i][j] = pii(-1, -1);\n\t\tpii ans = solve(hs[n].first, hs[n].second);\n\t\tif (primes.count(n))\n\t\t{\n\t\t\tans.first++;\n\t\t\tchmax(ans.second, n);\n\t\t}\n\t\tif (ans.first == 0) cout << \"0 0\" << endl;\n\t\telse cout << ans.first << \" \" << ans.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = int64_t;\nusing PLL = pair<ll, ll>;\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\n#define ALL(V) (V).begin(), (V).end()\n#define endl '\\n'\n    \nV<PLL> dir = {\n    PLL(0, 1),\n    PLL(-1, 0),\n    PLL(0, -1),\n    PLL(1, 0),\n};\n\nV<ll> primes;\n\nPLL advance(ll h, ll w, ll idx) {\n    ll dh, dw;\n    tie(dh, dw) = dir[idx];\n    ll nh = h + dh, nw = w + dw;\n    return make_pair(nh, nw);\n}\n\nvoid decide_dir(ll h, ll w, ll &idx, const VV<ll> &holes) {\n    ll next_d = (idx + 1) % 4;\n    ll nh, nw;\n    tie(nh, nw) = advance(h, w, next_d);\n    if(holes[nh][nw] == -1) idx = next_d;\n}\n\nbool is_prime(ll p) {\n    auto ite = lower_bound(ALL(primes), p);\n    return (ite != primes.end() && (*ite) == p);\n}\n\nll H = 2e3 + 10, W = 2e3 + 10;\n\nPLL dfs(ll h, ll w, const VV<ll> &holes, VV<PLL> &memo) {\n    if(holes[h][w] == -1) return PLL(0, 0);\n    if(memo[h][w] != PLL(-1, -1)) return memo[h][w];\n    PLL ret(0, 0);\n    V<PLL> recs;\n    for(ll i = -1; i <= 1; i++) {\n        ll nh = h + 1;\n        ll nw = w + i;\n        if(!(0 <= nh && nh < H &&\n             0 <= nw && nw < W)) continue;\n        recs.push_back(dfs(nh, nw, holes, memo));\n    }\n    sort(ALL(recs), \n         [](PLL a, PLL b) {\n             ll ca, pa, cb, pb;\n             tie(ca, pa) = a;\n             tie(cb, pb) = b;\n             if(ca != cb) return ca < cb;\n             else return pa < pb;\n         });\n    if(recs.size()) {\n        auto tmp = recs.back();\n        ret.first += tmp.first;\n        ret.second = tmp.second;\n    }\n    ll p = holes[h][w];\n    if(is_prime(p)) {\n        if(ret.second == 0) ret.second = p;\n        ret.first++;\n    }\n    return memo[h][w] = ret;\n}\n\nbool solve() {\n    ll M, N;\n    cin >> M >> N;\n    if(!(N + M)) return false;\n    VV<ll> holes(H, V<ll>(W, -1));\n    VV<PLL> memo(H, V<PLL>(W, PLL(-1, -1)));\n    ll didx = 3;\n    ll h = holes.size() / 2, w = holes.size() / 2;\n    ll init_h, init_w;\n    for(ll i = 1; i <= M; i++) {\n        holes[h][w] = i;\n        if(i == N) tie(init_h, init_w) = PLL(h, w);\n        decide_dir(h, w, didx, holes);\n        tie(h, w) = advance(h, w, didx);\n    }\n    auto ans = dfs(init_h, init_w, holes, memo);\n    cout << ans.first << ' ' << ans.second << endl;\n    return true;\n}\n\nint main() {\n    V<bool> used(1e6 + 10, false);\n    for(ll i = 2; i < used.size(); i++) {\n        if(used[i]) continue;\n        primes.push_back(i);\n        for(ll j = 1; i * j < used.size(); j++) used[i * j] = true;\n    }\n    while(solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n, m;\nint cave[1001][1001];\nP dp[1000005];\nbool prime[1000005];\n\nP search(int x, int y, int val)\n{\n\tint nx, ny;\n\tP ret = make_pair(0, -1);\n\t\n\tif(dp[val].first != -1) return dp[val];\n\t\n\tfor(int v = -1; v <= 1; v++){\n\t\tnx = x + v, ny = y + 1;\n\t\tif(nx < 0 || nx >= 1001 || ny < 0 || ny >= 1001) continue;\n\t\tif(cave[nx][ny] > n) continue;\n\t\tret = max(ret, search(nx, ny, cave[nx][ny]));\n\t}\n\tif(!prime[val]){\n\t\tret.first++;\n\t\tif(ret.second == -1) ret.second = val;\n\t}\n\t\n\treturn dp[val] = ret;\n}\n\nint main(void)\n{\n\tint px = 500, py = 500, dir = 0, dir2;\n\tconst int vx[] = {1, 0, -1, 0}, vy[] = {0, -1, 0, 1};\n\t\n\tint nx, ny;\n\tfor(int i = 1; i <= 1001 * 1001; i++){\n\t\tcave[px][py] = i;\n\t\tpx += vx[dir], py += vy[dir];\n\t\tdir2 = (dir+1)%4;\n\t\tif(cave[px + vx[dir2]][py + vy[dir2]] == 0) dir = dir2;\n\t}\n\t\n\tprime[1] = true;\n\tfor(int i = 2; i < 1100; i++){\n\t\tif(!prime[i]){\n\t\t\tfor(int j = 2 * i; j < 1000005; j += i) prime[j] = true;\n\t\t}\n\t}\n\t\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0) break;\n\t\t\n\t\tfor(int i = 1; i <= n; i++) dp[i] = make_pair(-1, -1);\n\t\t\n\t\tint x, y;\n\t\tfor(x = 0; x < 1001; x++){\n\t\t\tfor(y = 0; y < 1001; y++){\n\t\t\t\tif(cave[x][y] == m) goto end;\n\t\t\t}\n\t\t}\n\t\tend:;\n\t\t\n\t\tP ans = search(x, y, m);\n\t\tif(ans.first == 0) ans.second = 0;\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, m, r[1000][1000], dp1[1000][1000], dp2[1000][1000]; bool isprime[1000001];\nconst int dx[4] = { -1, 0, 1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\nint main() {\n\tisprime[1] = false;\n\tfor (int i = 2; i <= 1000000; i++) isprime[i] = true;\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tif (isprime[i]) {\n\t\t\tfor (int j = i + i; j <= 1000000; j += i) {\n\t\t\t\tisprime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n == 0 && m == 0) break;\n\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\t\tdp1[i][j] = -1, dp2[i][j] = -1, r[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tint c = 2, d = 0, x = 499, y = 500;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tr[y][x] = i; d++;\n\t\t\tx += dx[c % 4];\n\t\t\ty += dy[c % 4];\n\t\t\tif (d == c / 2) c++, d = 0;\n\t\t}\n\t\tint sx, sy;\n\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\t\tif (r[i][j] == m) sx = j, sy = i;\n\t\t\t}\n\t\t}\n\t\tdp1[sy][sx] = isprime[m] ? 1 : 0, dp2[sy][sx] = isprime[m] ? m : 0;\n\t\tfor (int i = 1; i < 1000; i++) {\n\t\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\t\tif (r[i][j] == -1) continue;\n\t\t\t\tint s1 = -1, s2 = -1;\n\t\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\t\tif (0 <= j + k && j + k < 1000) {\n\t\t\t\t\t\tif (dp1[i - 1][j + k] != -1) {\n\t\t\t\t\t\t\tif (isprime[r[i][j]]) {\n\t\t\t\t\t\t\t\ts2 = r[i][j];\n\t\t\t\t\t\t\t\ts1 = max(s1, dp1[i - 1][j + k] + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\ts1 = max(s1, dp1[i - 1][j + k]);\n\t\t\t\t\t\t\t\ts2 = max(s2, dp2[i - 1][j + k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (j == sx && i == sy) continue;\n\t\t\t\tdp1[i][j] = s1;\n\t\t\t\tdp2[i][j] = s2;\n\t\t\t}\n\t\t}\n\t\tint res1 = 0, res2 = 0;\n\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\t\tif (res1 < dp1[i][j]) {\n\t\t\t\t\tres1 = dp1[i][j];\n\t\t\t\t}\n\t\t\t\tif (res1 == dp1[i][j] && res2 < dp2[i][j]) {\n\t\t\t\t\tres2 = dp2[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", res1, res2);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\n#include <list>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str(); }\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX / 10;\n\nconst int MAX_N = 1000000;\nconst int MAX_F = 1000;\nint num[1001][1001];\nint dp[1001][1001], last[1001][1001];\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nbool isProperXY(int x, int y, int m) {\n\treturn 0 <= x && x <= MAX_F && 0 <= y && y <= MAX_F && 0 < num[y][x] && num[y][x] <= m;\n}\n\nint main() {\n\tvi isPrime(MAX_N + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, 1000) {\n\t\tfor (int j = i*i; j <= MAX_N; j += i) {\n\t\t\tisPrime[j] = false;\n\t\t}\n\t}\n\n\tmemset(num, INF, sizeof(num));\n\tint x = 500, y = 500, cur = 1, step = 1;\n\twhile (cur <= MAX_N) {\n\t\tREP(i, (step + 1) / 2) {\n\t\t\tnum[y][x] = cur;\n\t\t\tcur++;\n\t\t\tx += dx[step % 4];\n\t\t\ty += dy[step % 4];\n\t\t}\n\t\tstep++;\n\t}\n\n\tint m, n;\n\twhile (cin >> m >> n, m) {\n\t\tint stx, sty;\n\t\tFOR(i, 0, MAX_F) {\n\t\t\tFOR(j, 0, MAX_F) {\n\t\t\t\tif (num[i][j] == n) {\n\t\t\t\t\tsty = i, stx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tcout << sty << \" \" << stx << endl;\n\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tmemset(last, 0, sizeof(last));\n\t\tif (isPrime[num[sty][stx]]) {\n\t\t\tdp[sty][stx] = 1;\n\t\t\tlast[sty][stx] = num[sty][stx];\n\t\t}\n\t\tint ans = dp[sty][stx], lastp = last[sty][stx], minx = stx, maxx = stx;\n\t\tbool cont = true;\n\t\ty = sty;\n\t\twhile (cont) {\n\t\t\tcont = false;\n\t\t\tint nminx = INF, nmaxx = -INF;\n\t\t\tFOR(x, minx, maxx) {\n\t\t\t\tFOR(d, 1, 3) {\n\t\t\t\t\tint nx = x + dx[d], ny = y + 1;\n\t\t\t\t\tif (isProperXY(nx, ny, m)) {\n\t\t\t\t\t\tcont = true;\n\t\t\t\t\t\tnminx = min(nminx, nx);\n\t\t\t\t\t\tnmaxx = max(nmaxx, nx);\n\t\t\t\t\t\tif (isPrime[num[ny][nx]]) {\n\t\t\t\t\t\t\tlast[ny][nx] = num[ny][nx];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlast[ny][nx] = last[y][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[ny][nx] = max(dp[ny][nx], dp[y][x] + (isPrime[num[ny][nx]] ? 1 : 0));\n\t\t\t\t\t\tif (ans < dp[ny][nx]) {\n\t\t\t\t\t\t\tans = dp[ny][nx];\n\t\t\t\t\t\t\tlastp = last[ny][nx];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (ans == dp[ny][nx] && lastp < last[ny][nx]) {\n\t\t\t\t\t\t\tlastp = last[ny][nx];\n\t\t\t\t\t\t}\n//\t\t\t\t\t\tcout << num[y][x] << \" \" << num[ny][nx] << \" \" << dp[ny][nx] << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tminx = nminx, maxx = nmaxx;\n\t\t\ty++;\n\t\t}\n\n\t\tcout << ans << \" \" << lastp << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#define MAX 1002001\n#define EDGE 1001\nusing namespace std;\n\nint h[EDGE + 2][EDGE + 2], p[MAX], visit[EDGE + 2][EDGE + 2], lastcave[EDGE + 2][EDGE + 2];\n\nint max(int a, int b, int c){\n\treturn max(max(a, b), max(b, c));\n}\n\n\n\nint main()\n{\n\t//洞窟の作成\n\tint nowx, nowy, d, size, sizecounter;\n\tnowx = (EDGE - 1) / 2;\n\tnowy = (EDGE + 1) / 2;\n\td = 0;\n\tsize = 1;\n\tsizecounter = 0;\n\tfor (int i = 0; i <= MAX; i++){\n\t\th[nowy][nowx] = i;\n\t\tif (d == 0){\n\t\t\tnowx++;\n\t\t}\n\t\telse if (d == 1){\n\t\t\tnowy--;\n\t\t}\n\t\telse if (d == 2){\n\t\t\tnowx--;\n\t\t}\n\t\telse if (d == 3){\n\t\t\tnowy++;\n\t\t}\n\t\tif (sizecounter == size){\n\t\t\tsizecounter = 0;\n\t\t\td = (d + 1) % 4;\n\t\t\tif (d == 0 || d == 2){\n\t\t\t\tsize++;\n\t\t\t}\n\t\t}\n\t\tsizecounter++;\n\t}\n\n\t//素数の判定用配列を作成\n\tp[1] = 0;\n\tfill(p, p + MAX, 1);\n\tfor (int i = 2; i <= MAX; i++){\n\t\tint sqrti = (int)sqrt(i);\n\t\tfor (int j = 2; j <= sqrti; j++){\n\t\t\tif (i % j == 0){\n\t\t\t\tp[i] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t//入力\n\tint m, n;\n\twhile (cin >> m >> n, m || n){\n\n\t\t//初期化\n\t\tint goalcave = 0;\n\t\tint cavecounter = 0;\n\t\tfor (int i = 0; i < EDGE + 2; i++){\n\t\t\tfor (int j = 0; j < EDGE + 2; j++){\n\t\t\t\tvisit[i][j] = 0;\n\t\t\t\tlastcave[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\n\t\t//脱出する直前の洞窟のyを求める．\n\t\tbool flag = false;\n\t\tfor (int i = EDGE + 1; i > 0; i--){\n\t\t\tfor (int j = 0; j < EDGE + 2; j++){\n\t\t\t\tif (0 < h[i][j] && h[i][j] <= m){\n\t\t\t\t\tgoalcave = i;\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t//下から順に計算\n\t\tfor (int i = goalcave; i > 0; i--){\n\t\t\tfor (int j = 0; j < EDGE + 2; j++){\n\t\t\t\tif (h[i][j] <= m){\n\n\t\t\t\t\t//visitを求める\n\t\t\t\t\tif (p[h[i][j]]){\n\t\t\t\t\t\tvisit[i][j] = max(visit[i + 1][j - 1], visit[i + 1][j], visit[i + 1][j + 1]) + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tvisit[i][j] = max(visit[i + 1][j - 1], visit[i + 1][j], visit[i + 1][j + 1]);\n\t\t\t\t\t}\n\n\t\t\t\t\t//lastcaveを求める\n\t\t\t\t\tif (visit[i + 1][j - 1] > visit[i + 1][j] && visit[i + 1][j - 1] > visit[i + 1][j + 1]){\n\t\t\t\t\t\tlastcave[i][j] = lastcave[i + 1][j - 1];\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j] > visit[i + 1][j - 1] && visit[i + 1][j] > visit[i + 1][j + 1]){\n\t\t\t\t\t\tlastcave[i][j] = lastcave[i + 1][j];\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j + 1] > visit[i + 1][j - 1] && visit[i + 1][j + 1] > visit[i + 1][j]){\n\t\t\t\t\t\tlastcave[i][j] = lastcave[i + 1][j + 1];\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j - 1] == visit[i + 1][j] && visit[i + 1][j - 1] > visit[i + 1][j + 1]){\n\t\t\t\t\t\tlastcave[i][j] = max(lastcave[i + 1][j - 1], lastcave[i + 1][j]);\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j] == visit[i + 1][j + 1] && visit[i + 1][j] > visit[i + 1][j - 1]){\n\t\t\t\t\t\tlastcave[i][j] = max(lastcave[i + 1][j], lastcave[i + 1][j + 1]);\n\t\t\t\t\t}\n\t\t\t\t\telse if (visit[i + 1][j + 1] == visit[i + 1][j - 1] && visit[i + 1][j + 1] > visit[i + 1][j]){\n\t\t\t\t\t\tlastcave[i][j] = max(lastcave[i + 1][j + 1], lastcave[i + 1][j - 1]);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tlastcave[i][j] = max(lastcave[i + 1][j + 1], lastcave[i + 1][j], lastcave[i + 1][j - 1]);\n\t\t\t\t\t}\n\t\t\t\t\tif (p[h[i][j]] && lastcave[i][j] == 0){\n\t\t\t\t\t\tlastcave[i][j] = h[i][j];\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t//出力\n\t\t\t\tif (h[i][j] == n){\n\t\t\t\t\tcout << visit[i][j] << \" \" << lastcave[i][j] << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=x && x<w && 0<=y && y<h)\n\nconst int INF = 10000000;\nint dx[4]={1, 0, -1, 0}, dy[4]={0, 1, 0, -1};\nusing namespace std;\ntypedef pair<int, int> P;\n\n/** Problem1189 : Prime Caves **/\nint caves[1100][1100];\nint dp[1100][1100];\nconst int MAX = 1000000;\nbool prime[MAX];\n\nint main()\n{\n\tint m, n;\n\tconst int dx0[4] = {1, 0, -1, 0}, dy0[4] = {0, -1, 0, 1}, dx1[3]={-1, 0, 1};\n\tint sx, sy;\n\t\n\tfor (int i=0; i<MAX; i++)\n\t\tprime[i] = true;\n\t\n\tprime[0] = false; prime[1] = false;\n\t\n\tfor (int i=2; i<MAX; i++) {\n\t\tif (prime[i]) {\n\t\t\tfor (int j=2; i*j<MAX; j++) {\n\t\t\t\tprime[i*j] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\twhile (cin>>m>>n, m||n) {\n\t\tfill(caves[0], caves[0]+1100*1100, 0);\n\t\tfill(dp[0], dp[0]+1100*1100, -1);\n\t\tint x=1100/2, y=1100/2 , t=1, direct=1;\n\t\tcaves[x][y]=1;\n\t\tcaves[++x][y]=2;\n\t\tint i=2; bool change = true;\n\t\twhile (1) {\n\t\t\trep(j, t) {\n\t\t\t\tx+=dx0[direct]; y+=dy0[direct];\n\t\t\t\tcaves[x][y]=i+1;\n\t\t\t\ti++;\n\t\t\t\tif (i==n) {\n\t\t\t\t\tsx = x; sy = y;\n\t\t\t\t}\n\t\t\t\tif (i>=m) goto end;\n\t\t\t}\n\t\t\tif (change) {\n\t\t\t\tt++;\n\t\t\t\tchange = false;\n\t\t\t} else {\n\t\t\t\tchange=true;\n\t\t\t}\n\t\t\tdirect++; direct%=4;\n\t\t}\n\tend: ;\n\t\tint ans=0, alast=0;\n\n\t\tdp[sx][sy] = prime[caves[sx][sy]];\n\t\tREP(j, 0, 1100) {\n\t\t\tREP(i, 0, 1100) {\n\t\t\t\tans = max(ans, dp[i][j]);\n\t\t\t\t\n\t\t\t\tif (dp[i][j] == -1) continue;\n\t\t\t\tif (caves[i][j] == 0) continue;\n\t\t\t\t\n\t\t\t\trep(k, 3) {\n\t\t\t\t\tint nx=i+dx1[k], ny=j+1;\n\t\t\t\t\tif (!(0<=nx && nx<1100)) continue;\n\t\t\t\t\tif (caves[nx][ny]==0) continue;\n\n\t\t\t\t\tdp[nx][ny] = max(dp[nx][ny], dp[i][j]+prime[caves[nx][ny]]);\n\n\t\t\t\t\tans = max(ans, dp[nx][ny]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (ans!=0) {\n\t\t\tREP(j, 0, 1100) {\n\t\t\t\tREP(i, 0, 1100) {\n\t\t\t\t\tif (dp[i][j]==ans && prime[caves[i][j]]) {\n\t\t\t\t\t\talast = max(alast, caves[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << \" \" << alast << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n\nusing namespace std;\n\n#define mod 1000000007\n\nvector<pair<int, int> > numtoplace(1000001);\nvector<pair<int, int> > result;\nmap<pair<int, int>, int> placetonum;\n\nvoid getplace()\n{\n\tnumtoplace[1] = make_pair(0, 0);\n\tplacetonum[make_pair(0, 0)] = 1;\n\tfor(int i = 1; i <= 500; i++){\n\t\tint tmp = 2 * i - 1;\n\t\tint x = numtoplace[tmp * tmp].first;\n\t\tint y = numtoplace[tmp * tmp].second;\n\t\tint nx = x;\n\t\tint ny = y;\n\t\tint dx[4] = {-1, 0, 1, 0};\n\t\tint dy[4] = {0, -1, 0, 1};\n\t\tfor(int j = 0; j < 4; j++){\n\t\t\tfor(int k = 1; k <= 2 * i; k++){\n\t\t\t\tif(tmp * tmp + 2 * i * j + k > 1000001){\n\t\t\t\t\tj = 5;\n\t\t\t\t\ti = 501;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(j == 0 && k == 1){\n\t\t\t\t\tny++;\n\t\t\t\t} else {\n\t\t\t\t\tnx += dx[j];\n\t\t\t\t\tny += dy[j];\n\t\t\t\t}\n\t\t\t\t// cout << tmp * tmp + 2 * i * j + k << \" \" << nx << \" \" << ny << endl;\n\t\t\t\tnumtoplace[tmp * tmp + 2 * i * j + k] = make_pair(nx, ny);\n\t\t\t\tplacetonum[make_pair(nx, ny)] = tmp * tmp + 2 * i * j + k;\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool isprime(int n)\n{\n\tif(n == 1) return false;\n\tif(n == 2) return true;\n\tfor(int i = 2; i * i <= n; i++){\n\t\tif(n % i == 0) return false;\n\t}\n\treturn true;\n}\n\npair<int, int> getresult(int n, int m)\n{\n\tif(n > m) return make_pair(0, 0);\n\tif(result[n] != make_pair(-1, -1)) return result[n];\n\tint dokutsunum = 0;\n\tint lastprime = 0;\n\tint x = numtoplace[n].first;\n\tint y = numtoplace[n].second;\n\tfor(int i = -1; i < 2; i++){\n\t\t\tif(placetonum.find(make_pair(x + 1, y + i)) == placetonum.end()) continue;\n\t\t\tpair<int, int> tmp = getresult(placetonum[make_pair(x + 1, y + i)], m);\n\t\t\tif(tmp.first > dokutsunum){\n\t\t\t\tdokutsunum = tmp.first;\n\t\t\t\tlastprime = tmp.second;\n\t\t\t} else if(tmp.first == dokutsunum){\n\t\t\t\tlastprime = max(lastprime, tmp.second);\n\t\t\t}\n\t}\n\tif(isprime(n)){\n\t\tdokutsunum++;\n\t\tif(lastprime == 0) lastprime = n;\n\t}\n\tresult[n] = make_pair(dokutsunum, lastprime);\n\treturn result[n];\n}\n\nint main()\n{\n\tgetplace();\n\tint n, m;\n\twhile(1){\n\t\tcin >> m >> n;\n\t\tif(n == 0 && m == 0) break;\n\t\tresult = vector<pair<int, int> >(m + 1, make_pair(-1, -1));\n\t\tpair<int, int> tmp = getresult(n, m);\n\t\tcout << tmp.first << \" \" << tmp.second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n// #define USE_LLONG_AS_INT\n#ifdef USE_LLONG_AS_INT\n#define int long long\n#define inf (1ll<<60)\n#else\n#define inf (1<<30)\n#endif\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,a,b) for(int i=a;i<=b;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define vi vector<int>\n#define vvi vector<vi>\n#define pb push_back\n#define pi pair<int,int>\n#define vp vector<pair<int,int>>\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define MEMSET(a) memset(a,0,sizeof(a))\n#define Yes(f) cout<<(f?\"Yes\":\"No\")<<endl\n#define yes(f) cout<<(f?\"yes\":\"no\")<<endl\n#define YES(f) cout<<(f?\"YES\":\"NO\")<<endl\n#define SORT(v) sort(all(v))\n#define RSORT(v) sort(all(v), greater<int>())\n\nusing namespace std;\n\nconst int mod=1e9+7;\nconst string sp=\" \";\n\nvoid run();\n\nvoid init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(12);\n}\n\nsigned main(){\n    init();\n    run();\n    return 0;\n}\n\n#define N (1001*1001)\nbool p[N+1];\n\nvoid eratosthenes(void){\n    for(int i=2;i<N;i++)\n        p[i]=1;\n    for(int i=2;i*i<N;i++){\n        if(p[i]){\n            for(int j=2*i;j<=N;j=j+i){\n                p[j]=0;\n            }\n        }\n    }\n}\n\nint d[1001][1001];\nint n,m;\npi rec[1001][1001];\nbool visited[1001][1001];\n\npi dfs(int y,int x){\n    if(d[y][x]>m)return mp(0,0);\n    if(visited[y][x])return rec[y][x];\n    visited[y][x]=true;\n    pi ret=dfs(y+1,x);\n    if(x>0)ret=max(ret,dfs(y+1,x-1));\n    if(x<1000)ret=max(ret,dfs(y+1,x+1));\n    int prime=(ret.se?:p[d[y][x]]?d[y][x]:0);\n    return rec[y][x]=mp(ret.fi+p[d[y][x]],prime);\n}\n\nvoid run(){\n    eratosthenes();\n    int x=500,y=500;\n    int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n    int dir=0;\n    int cnt=1;\n    int num=1;\n    int cc=0;\n    while(0<=x&&x<1001&&0<=y&&y<1001){\n        d[y][x]=num++;\n        y+=dy[dir],x+=dx[dir];\n        cc++;\n        if(cc%cnt==0)dir=(dir+1)%4;\n        if(cc==cnt*2)cc=0,cnt++;\n    }\n    while(cin>>m>>n,m){\n        memset(rec,-1,sizeof(rec));\n        MEMSET(visited);\n        int sy,sx;\n        rep(i,1001)rep(j,1001){\n            if(d[i][j]==n){\n                sy=i,sx=j;\n                break;\n            }\n        }\n        pi ans=dfs(sy,sx);\n        cout<<ans.fi<<sp<<ans.se<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing Ti = tuple<int, int, int>;\nusing Tl = tuple<ll, ll, ll>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define Get(t, i) get<(i)>((t))\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\nconst int inf = 1 << 25;\nconst ll INF = 1LL << 55;\n\n#define MAX_M 1000001\n#define MAX_W 1001\n\nbool isprim[MAX_M];\n\nvoid Eratosthenes()\n{\n  fill(isprim, isprim + MAX_M, true);\n  isprim[0] = isprim[1] = false;\n  for(int i = 2; i*i < MAX_M; i++) {\n    if(isprim[i]) {\n      for(int j = i+i; j < MAX_M; j += i) isprim[j] = false;\n    }\n  }\n}\n\nint cave[MAX_W][MAX_W];\nPi pos[MAX_M];\n\nvoid make_cave()\n{\n  const int dx[] = {1, 0, -1, 0};\n  const int dy[] = {0, -1, 0, 1};  \n  typedef pair<Pi, Pi> Pii;\n  queue<Pii> que;\n  que.push(Pii(Pi(MAX_W/2, MAX_W/2), Pi(3, 1)));\n  while(!que.empty()) {\n    Pii p = que.front(); que.pop();\n    int x = p.F.F, y = p.F.S, d = p.S.F, n = p.S.S;\n    if(n >= MAX_M) break;\n    pos[n] = p.F, cave[y][x] = n++;\n    int nd = (d + 1) % 4, nx = x + dx[nd], ny = y + dy[nd];\n    if(!cave[ny][nx]) que.push(Pii(Pi(nx, ny), Pi(nd, n)));\n    else que.push(Pii(Pi(x + dx[d], y + dy[d]), Pi(d, n)));\n  }\n}\n\nint main()\n{\n  Eratosthenes();\n  make_cave();\n  int m, n;\n  while(cin >> m >> n, m) {\n    int dp[MAX_W][MAX_W];\n    fill(dp[0], dp[MAX_W], -1);\n    dp[pos[n].S][pos[n].F] = isprim[n];\n    int ans = 0, num = 0;\n    for(int y = 0; y < MAX_W; y++) {    \n      for(int x = 0; x < MAX_W; x++) {\n\tif(ans <= dp[y][x]) {\n\t  ans = dp[y][x];\n\t  if(isprim[cave[y][x]]) num = max(num, cave[y][x]);\n\t}\n\tif(y == MAX_W-1 || !cave[y][x] || m < cave[y][x] || !~dp[y][x]) continue;\n\tfor(int a = -1; a <= 1; a++) {\n\t  int nx = x + a, ny = y + 1;\n\t  if(nx < 0 || MAX_W <= nx || !cave[ny][nx] || m < cave[ny][nx]) continue;\n\t  dp[ny][nx] = max(dp[ny][nx], dp[y][x] + isprim[cave[ny][nx]]);\n\t  if(ans <= dp[ny][nx]) {\n\t    ans = dp[ny][nx];\n\t    if(isprim[cave[ny][nx]]) num = cave[ny][nx];\n\t  }\n\t}\n      }\n    }\n    cout << ans << \" \" << num << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst int N = 1111111;\nbool prime[N];\nset<int> primes;\n\nvoid hurui()\n{\n\tmemset(prime, true, sizeof(prime));\n\tprime[0] = prime[1] = false;\n\tfor (int i = 2; i*i < N; i++)\n\t{\n\t\tfor (int j = 2; i*j < N; j++)\n\t\t{\n\t\t\tprime[i*j] = false;\n\t\t}\n\t}\n\tREP(i, N + 1)\n\t{\n\t\tif (prime[i]) primes.insert(i);\n\t}\n}\n\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\n\nbool fld[1200][1200] = {};\nint ind[1200][1200];\npii hs[1111111];\n\nvoid init()\n{\n\tREP(i, 1200)REP(j, 1200) ind[i][j] = INF;\n\thurui();\n\tint p = 1, x = 600, y = 600;\n\tFOR(i, 1, 11111111)\n\t{\n\t\tif (i % 2)\n\t\t{\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tind[x][y] = p;\n\t\t\t\ths[p] = pii(x, y);\n\t\t\t\tif (primes.count(p)) fld[x][y] = true;\n\t\t\t\tp++;\n\t\t\t\ty++;\n\t\t\t}\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tind[x][y] = p;\n\t\t\t\ths[p] = pii(x, y);\n\t\t\t\tif (primes.count(p)) fld[x][y] = true;\n\t\t\t\tp++;\n\t\t\t\tx--;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tind[x][y] = p;\n\t\t\t\ths[p] = pii(x, y);\n\t\t\t\tif (primes.count(p)) fld[x][y] = true;\n\t\t\t\tp++;\n\t\t\t\ty--;\n\t\t\t}\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tind[x][y] = p;\n\t\t\t\ths[p] = pii(x, y);\n\t\t\t\tif (primes.count(p)) fld[x][y] = true;\n\t\t\t\tp++;\n\t\t\t\tx++;\n\t\t\t}\n\t\t}\n\t\tif (p > 1000000) break;\n\t}\n}\n\npii dp[1200][1200];\nint n, m;\n\npii solve(int x, int y)\n{\n\tif (dp[x][y] !=pii(-1,-1)) return dp[x][y];\n\tpii res(0, -1);\n\tFOR(i, -1, 2)\n\t{\n\t\tint nx = x + 1, ny = y + i;\n\t\tif (ind[nx][ny] > m) continue;\n\t\tpii next = solve(nx, ny);\n\t\tif (fld[nx][ny])\n\t\t{\n\t\t\tif (next.first == 0) chmax(res, pii(next.first + 1, ind[nx][ny]));\n\t\t\telse chmax(res, pii(next.first + 1, next.second));\n\t\t}\n\t\telse chmax(res, next);\n\t}\n\treturn dp[x][y] = res;\n}\n\nint main()\n{\n\tinit();\n\twhile (cin >> m >> n, n)\n\t{\n\t\tREP(i, 1200)REP(j, 1200) dp[i][j] = pii(-1, -1);\n\t\tpii ans = solve(hs[n].first, hs[n].second);\n\t\tif (primes.count(n))\n\t\t{\n\t\t\tans.first++;\n\t\t\tchmax(ans.second, n);\n\t\t}\n\t\tif (ans.first == 0) cout << \"0 0\" << endl;\n\t\telse cout << ans.first << \" \" << ans.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = (a); i <= (n); i++)\n#define M 1000001\nusing namespace std;\ntypedef pair<int, int> pii;\n\nbool p[M];\nint m, n, table[1000][1000], nx[M], ny[M], dp1[M], dp2[M];\n\nint isin(int y, int x) {\n  return 0 <= x && x < 1000 && 0 <= y && y < 1000;\n}\n\npii dfs(int m, int n) {\n  if(dp1[n] >= 0) return pii(dp1[n], dp2[n]);\n\n  pii ret = pii(0, p[n] ? n : 0);\n  REP(i, -1, 1) {\n    int qy = ny[n] + 1, qx = nx[n] + i;\n    if(!isin(qy, qx)) continue;\n    int q = table[qy][qx];\n    if(q <= m) {\n      pii t = dfs(m, q);\n      ret = max(ret, t);\n    }\n  }\n\n  dp1[n] = ret.first + p[n];\n  dp2[n] = ret.second;\n  return pii(dp1[n], dp2[n]);\n}\n\nint main(void) {\n  REP(i, 1, M) p[i] = true;\n  p[1] = p[2] = false;\n  REP(i, 2, M) if(p[i]) for(int j = i * 2; j <= M; j += i) p[j] = false;\n\n  int x = 0, y = 0, cnt = 1000 - 2, r = M - 1;\n  REP(i, 0, 1000) REP(j, 0, 1000) table[i][j] = 0;\n  while(cnt >= 0) {\n    REP(i, 0, cnt) { table[y][x] = r; ny[r] = y; nx[r] = x; x++; r--; }\n    REP(i, 0, cnt) { table[y][x] = r; ny[r] = y; nx[r] = x; y++; r--; }\n    REP(i, 0, cnt) { table[y][x] = r; ny[r] = y; nx[r] = x; x--; r--; }\n    REP(i, 0, cnt) { table[y][x] = r; ny[r] = y; nx[r] = x; y--; r--; }\n    if(r < 0) cout << y << \" \" << x << endl;\n    x++;\n    y++;\n    cnt -= 2;\n  }\n\n  while(cin >> m >> n, m != 0 && n != 0) {\n    REP(i, 1, m) dp1[i] = dp2[i] = -1;\n    pii ans = dfs(m, n);\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\n#define SIZE 1000\n\nbool C(int dp1, int pr1, int dp2, int pr2) {\n\tif (dp2 == 0)return false;\n\tif (dp1 < dp2 || (dp1 == dp2&&pr1 < pr2))return true;\n\treturn false;\n}\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (x >= 0 && y >= 0 && table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x - 1], pr[y + 1][x - 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x], pr[y + 1][x])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x + 1], pr[y + 1][x + 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\n\t\toutput = false;\n\t\tfor (int i = 0;i < SIZE&&!output;i++) {\n\t\t\tfor (int j = 0;j < SIZE&&!output;j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tprintf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n#define t_max 10000001\nchar M[1001][1001];\nshort S[1001][1001];\nint P[1001][1001];\nchar table[t_max];\npair<short,short>m[t_max];\nint m_rev[t_max];\npair<short,int> dfs(int x,int y){\n\tif(y==1001)return make_pair(0,0);\n\tif(S[x][y]>=0)return make_pair(S[x][y],P[x][y]);\n\tint m=0,m_place=0,i=-1;\n\tfor(;i<2;i++){\n\t\tif(x+i<0||1000<x+i)continue;\n\t\tpair<short,int> p=dfs(x+i,y+1);\n\t\tif(m<p.first||(m==p.first&&m_place<p.second))m=p.first,m_place=p.second;\n\t}\n\tif(m==0){\n\t\tif(M[x][y])return make_pair(S[x][y]=1,P[x][y]=m_rev[x*1001+y]);\n\t\treturn make_pair(S[x][y]=0,P[x][y]=0);\n\t}else{\n\t\treturn make_pair(S[x][y]=m+M[x][y],P[x][y]=m_place);\n\t}\n}\nmain(){\n\tint k=1,z,x,y,i,n,s;\n\tm[k]=make_pair(x=500,y=500),m_rev[x*1001+y]=k,k++;\n\tfor(z=2;z<=1000;z+=2){\n\t\tx++,y++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(x,--y),m_rev[x*1001+y]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(--x,y),m_rev[x*1001+y]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(x,++y),m_rev[x*1001+y]=k,k++;\n\t\tfor(i=0;i<z;i++)m[k]=make_pair(++x,y),m_rev[x*1001+y]=k,k++;\n\t}\n\ttable[0]=table[1]=1;\n\tfor(x=2;x<t_max;x++)if(!table[x])for(y=x*2;y<t_max;y+=x)table[y]=1;\n\tfor(;scanf(\"%d%d\",&n,&s),n;){\n\t\tmemset(M,0,sizeof(M));\n\t\tmemset(S,0xff,sizeof(S));\n\t\tmemset(P,0,sizeof(P));\n\t\tfor(i=1;i<=n;i++)if(!table[i])M[m[i].first][m[i].second]=1;\n\t\tpair<short,int> p=dfs(m[s].first,m[s].second);\n\t\tprintf(\"%d %d\\n\",p.first,p.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nconst int SIZE = 1000;\nbool prime[SIZE * SIZE + 1];\nint table[SIZE][SIZE];\nint dp[SIZE][SIZE];\nint pr[SIZE][SIZE];\n\nint main() {\n\tint m, n;\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile(true) {\n\t\tscanf(\"%d %d\", &m, &n);\n\t\tif (m == 0 || n == 0)return 0;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = SIZE - 1;i >= 0;i--){\n\t\t\tfor(int j = SIZE - 1;j >= 0;j--){\n\t\t\t\tif (table[i][j] <= m) {\n\t\t\t\t\tif (i + 1 < SIZE) {\n\t\t\t\t\t\tif (j > 0 && table[i + 1][j - 1] <= m){\n\t\t\t\t\t\t\tif (dp[i][j] < dp[i + 1][j - 1] || (dp[i][j] == dp[i + 1][j - 1] && pr[i][j] < pr[i + 1][j - 1])) {\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j - 1];\n\t\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j - 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (table[i + 1][j] <= m){\n\t\t\t\t\t\t\tif (dp[i][j] < dp[i + 1][j] || (dp[i][j] == dp[i + 1][j] && pr[i][j] < pr[i + 1][j])) {\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j];\n\t\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (j + 1 < SIZE && table[i + 1][j + 1] <= m){\n\t\t\t\t\t\t\tif (dp[i][j] < dp[i + 1][j + 1] || (dp[i][j] == dp[i + 1][j + 1] && pr[i][j] < pr[i + 1][j + 1])) {\n\t\t\t\t\t\t\t\tdp[i][j] = dp[i + 1][j + 1];\n\t\t\t\t\t\t\t\tpr[i][j] = pr[i + 1][j + 1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!prime[table[i][j]]) {\n\t\t\t\t\t\tdp[i][j]++;\n\t\t\t\t\t\tif (pr[i][j] == 0) {\n\t\t\t\t\t\t\tpr[i][j] = table[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tprintf(\"%d %d\\n\", dp[i][j], pr[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <stdio.h>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <stdlib.h>\n#include <math.h>\n#include <list>\n#include <algorithm>\n\nusing namespace std;\n\n//平方数かどうか調べる\nint isSq(int n) {\n\tif(n <= 0) return 0;\n\n\tfor(int i = 1; i <= (int)sqrt( (double)n ) + 1; i++) {\n\t\tif( n % i == 0 && n / i == i ) return i;\n\t}\n\t\n\treturn 0;\n}\n//素数かどうか調べる\nint isPrime(int n) {\n\tif(n <= 1) return 0;\n\tint flg = 1;\n\tfor(int i = 2; i <= (int)sqrt((double)n) + 1; i++) {\n\t\tif( n % i == 0) {\n\t\t\tflg = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn flg;\n}\n\nstruct memo{\n\tint last;\n\tint pts;\n};\nstruct cave{\n\tint x;\n\tint y;\n\tint flg;\n\tint num;\n};\n\n//動的計画法で探査\n//番号が決まれば得点がきまるはず\nvoid search_cave(int n, int xpos, int ypos, vector<memo>*m, vector<vector<int>> *cv, vector<cave> *cl, int h, int w){\n\n\tif( m -> at(n).last != -1 ) {\n\t\t//探索済みの場合\n\t\treturn;\n\t} else {\n\t\t//未探索の場合\n\t\t//直下の三洞窟を探索する\n\t\t//直下三通りはすでに探索済みとする\n\n\t\tif( ypos == h - 1 ) {\n\t\t\t//一番下ならば？\n\t\t\tm->at(n).pts = cl->at(n).flg;\n\t\t\tm->at(n).last = 0;\n\t\t\tif(cl->at(n).flg == 1) m->at(n).last = n;\n\t\t} else {\n\t\t\t//降りられる洞穴がある場合\n\t\t\tint indx;\n\t\t\tint point[3] = {-1,-1,-1};\n\t\t\tint last[3] = {-1,-1,-1};\n\t\t\t//左右移動できるか確認する\n\t\t\tif(( (xpos > 0) && ( ( cv->at( xpos - 1 ).at( ypos + 1 ) ) > 0  ) ) )\t{\t//左下\n\t\t\t\tint tmp = cv->at( xpos - 1 ).at( ypos + 1 );\n\t\t\t\tpoint[0] = m->at( tmp ).pts;\n\t\t\t\tlast[0] = m->at(tmp).last;\n\t\t\t}\n\t\t\tif( xpos < w - 1 && cv->at( xpos + 1 ).at( ypos + 1 )  > 0) { //右下\n\t\t\t\tint tmp = cv->at( xpos + 1 ).at( ypos + 1 );\n\t\t\t\tpoint[1] = m->at( tmp ).pts;\n\t\t\t\tlast[1] = m->at( tmp ).last;\n\t\t\t}\n\t\t\tif( cv->at( xpos  ).at( ypos + 1)  > 0 ) {\t\t\t//真下\n\t\t\t\tint tmp = cv -> at( xpos ).at( ypos + 1 );\n\t\t\t\tpoint[2] = m -> at( tmp ).pts;\n\t\t\t\tlast[2] = m -> at( tmp ).last;\n\t\t\t}\n\n\t\t\t//大小比較する\n\t\t\tif( point[0] < point[1] ) {\n\t\t\t\tindx = 1;\n\t\t\t} else if( point[0] > point[1] ) {\n\t\t\t\tindx = 0;\n\t\t\t} else {\n\t\t\t\tif(last[0] < last[1]) indx = 1;\n\t\t\t\telse indx = 0;\n\t\t\t}\n\n\t\t\tif( point[indx] < point[2] ) {\n\t\t\t\tindx = 2;\n\t\t\t} else if( point[indx] > point[2] ) {\n\t\t\t\tindx = indx;\n\t\t\t} else {\n\t\t\t\tif(last[indx] < last[2]) indx = 2;\n\t\t\t\telse indx = indx;\n\t\t\t}\n\n\t\t\tm -> at(n).pts = point[indx] + cl -> at(n).flg ;\n\t\t\tm -> at(n).last = last[indx]  ;\n\t\t\tif(last[indx] <= 0 && cl -> at(n).flg > 0) m -> at(n).last = n;\n\n\t\t}\n\t}\n}\n\nint main(void){\n\t//FILE* fp_in = freopen(\"data.txt\", \"r\", stdin);\n\n\t\n\n\twhile(1){\n\t\tint m, n;\n\t\tvector<cave> clist;\n\n\t\tcin >> m >> n;\n\t\tif( m == 0 && n == 0 ) break;\n\t\t\n\t\tcave c;\n\t\tc.x = -1;\n\t\tc.y = 0;\n\t\tc.flg = 0;\n\t\tc.num = 0;\n\t\tclist.push_back(c);\n\n\t\t//洞窟の大きさを調べる\n\t\tint dir = 0, sq = 1;\n\t\tfor(int i = 1; i <= m; i ++) {\n\t\t\tif( isSq(i) != 0 ) \n\t\t\t\tsq = isSq(i);\n\t\t\t//進む\n\t\t\tswitch(dir) {\n\t\t\t\tcase 0:\n\t\t\t\t\tc.x ++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tc.y --;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tc.x --;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tc.y ++;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//方向転換\n\t\t\tif( ( isSq( i - 1 ) != 0 ) || ( i == sq*sq + sq + 1 ) ) { \n\t\t\t\tdir ++;\n\t\t\t\tif( dir > 3 ) dir = 0;\n\t\t\t}\n\t\t\tc.flg = isPrime(i);\n\t\t\tc.num = i;\n\t\t\tclist.push_back(c);\n\t\t}\n\n\t\t//洞窟の大きさを取得する\n\t\tint x_max = 0, x_min = 0, y_max = 0, y_min = 0;\n\t\tfor(int i = 1; i < clist.size(); i++) {\n\t\t\tif( clist.at(i).x < x_min ) x_min = clist.at(i).x;\n\t\t\tif( clist.at(i).x > x_max ) x_max = clist.at(i).x;\n\t\t\tif( clist.at(i).y < y_min ) y_min = clist.at(i).y;\n\t\t\tif( clist.at(i).y > y_max ) y_max = clist.at(i).y;\n\t\t}\n\n\t\t//上端のy座標を0にセット\n\t\tfor(int i = 1; i < clist.size(); i++) {\n\t\t\tclist.at(i).y -= y_min;\n\t\t\tclist.at(i).x -= x_min;\n\t\t}\n\t\t\n\t\t//洞穴を意味するvector\n\t\tvector<vector<int>> caves;\n\t\tfor(int i = 0; i <= x_max - x_min; i++) {\n\t\t\tvector<int> newcave;\n\t\t\tfor(int j = 0; j <= y_max - y_min; j++)\n\t\t\t\tnewcave.push_back(0);\n\t\t\tcaves.push_back(newcave);\n\t\t}\n\n\t\t//番号をセットする\n\t\tfor(int i = 1; i < clist.size(); i++) \n\t\t\tcaves.at( clist.at(i).x ).at( clist.at(i).y ) = clist.at(i).num;\n\n\t\t//メモ用vector\n\t\tvector<memo> memory;\n\t\tfor(int i = 0; i < clist.size() + 2; i++) {\n\t\t\tmemo newmemo;\n\t\t\tnewmemo.last = -1;\n\t\t\tnewmemo.pts = 0;\n\t\t\tmemory.push_back(newmemo);\n\t\t}\n\n\t\tint height = caves.at(0).size();\n\t\tint width = caves.size();\n\t\tint ans[2];\n\t\tint flg = 0;\n\t\n\n\t\t//一番下から調べる\n\t\tfor(int i = height - 1; i >= 0; i--) {\n\t\t\tfor(int j = 0; j < width; j++) {\n\t\t\t\tint num = caves.at(j).at(i);\n\t\t\t\tsearch_cave(num, j, i, &memory, &caves, &clist, height, width);\n\t\t\t\tif( num == n ) {\n\t\t\t\t\tflg = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg) break;\n\t\t}\n\t\t\n\n\t\tans[0] = memory.at(n).pts;\n\t\tans[1] = memory.at(n).last;\n\t\tif( ans[0] == 0 ) ans[1] = 0;\n\n\t\tcout << ans[0] << \" \" << ans[1] << endl;\n\t}\n\n\t//while(1){}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int MAX_M = 1000001;\nconst int MAX_C = 1000;\nconst int INF = 1e9;\n#define y first\n#define x second\n\nmap<int, P> itop;\nmap<P, int> ptoi;\nbool isp[MAX_M];\nP dp[MAX_C][MAX_C];\n\nvoid make_prime(){\n  REP(i, MAX_M) isp[i] = true;\n  isp[0] = isp[1] = false;\n  FOR(i, 2, sqrt(MAX_M) + 1){\n    if(!isp[i]) continue;\n    for(int j = i + i; j < MAX_M; j += i) isp[j] = false;\n  }\n}\n\nvoid init(){\n  P now = P(MAX_C / 2, MAX_C / 2);\n  int pls = 1, l = 1, step = 0, d = 0;\n  FOR(i, 1, MAX_M){\n    itop[i] = now;\n    ptoi[now] = i;\n    if(d == 0) now.x += 1;\n    else if(d == 1) now.y -= 1;\n    else if(d == 2) now.x -= 1;\n    else if(d == 3) now.y += 1;\n    ++step;\n    if(step >= l){\n      d = (d + 1) % 4;\n      step = 0;\n    }\n    if(i != 1 && (d == 0 || d == 2) && step == 0) ++l;\n  }\n}\n\nint main() {\n  make_prime();\n  init();\n  int M, N;\n  while(cin >>M >>N && (N && M)){\n    REP(i, MAX_C) REP(j, MAX_C) dp[i][j] = P(-1, -1);\n    P now = itop[N], ans = P(-1, -1);\n    dp[now.y][now.x] = (isp[N] ? P(1, N) : P(0, -1));\n    REP(y, MAX_C){\n      REP(x, MAX_C){\n        if(dp[y][x].first == -1 || ptoi.find(P(y, x)) == ptoi.end()) continue;\n        ans = max(ans, dp[y][x]);\n        for(int mx = -1; mx <= 1; ++mx){\n          int ny = y + 1, nx = x + mx;\n          if(ny < 0 || nx < 0 || ny >= MAX_C || nx >= MAX_C || ptoi.find(P(ny, nx)) == ptoi.end()) continue;\n          int cnt = dp[y][x].first + (isp[ptoi[P(ny, nx)]] ? 1 : 0), num = (isp[ptoi[P(ny, nx)]] ? ptoi[P(ny, nx)] : dp[y][x].second);\n          if(num > M) continue;\n          if(cnt > dp[ny][nx].first || (cnt == dp[ny][nx].first && num > dp[ny][nx].second)) dp[ny][nx] = P(cnt, num);\n        }\n      }\n    }\n    if(ans.first == 0) cout <<\"0 0\" <<endl;\n    else cout <<ans.first <<\" \" <<ans.second <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,s,e) for (int i=s;i<(e);i++)\n#define All(v) (v).begin(),(v).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\n#define fi first\n#define se second\n#define int long long\nusing namespace std;\ntypedef long long llint;\ntypedef pair<int, int> P;\nconst int MOD = (int)1e9 + 7;\nconst int INF = (int)1e18 * 5;\n\nint a[3000][3000];\nint X[1000010], Y[1000010];\nP dp[3000][3000];\n\nvector<int> prime;\n\nvoid PrimeTable(int N){\n    prime = vector<int>(N+1, 1);\n    prime[0] = 0;\n    prime[1] = 0;\n\n    for(int i=2; i*i<=N; ++i){\n        if(prime[i]){\n            for(int j=2; i*j<=N; ++j){\n                prime[i*j] = 0;\n            }\n        }\n    }\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int now = 1, dir = 0, diff = 1;\n    int x=1500, y=1500;\n    a[1500][1500] = 1;\n    while(now <= 1000000){\n        switch(dir){\n        case 0:\n            FOR(dx, 1, diff+1){\n                a[y][x+dx] = ++now;\n                X[now] = x+dx;\n                Y[now] = y;\n            }\n            x = x+diff;\n            break;\n        case 1:\n            FOR(dy, 1, diff+1){\n                a[y-dy][x] = ++now;\n                X[now] = x;\n                Y[now] = y-dy;\n            }\n            y = y-diff;\n            break;\n        case 2:\n            FOR(dx, 1, diff+1){\n                a[y][x-dx] = ++now;\n                X[now] = x-dx;\n                Y[now] = y;\n            }\n            x = x-diff;\n            break;\n        case 3:\n            FOR(dy, 1, diff+1){\n                a[y+dy][x] = ++now;\n                X[now] = x;\n                Y[now] = y+dy;\n            }\n            y = y+diff;\n            break;\n        }\n        if(dir%2) diff++;\n        dir = (dir+1)%4;\n    }\n\n    // REP(i, 20){\n    //     REP(j, 20){\n    //         printf(\"%03d \", a[1490+i][1490+j]);\n    //     }\n    //     printf(\"\\n\");\n    // }\n    int m, n;\n    cin >> m >> n;\n    PrimeTable(1000010);\n    while(!(m==0 && n==0)){\n        REP(i, 3000)REP(j, 3000) dp[i][j] = mp(-1, -1);\n        int ny = Y[n], nx = X[n];\n        dp[ny][nx] = mp(prime[n], prime[n] ? n : 0);\n        bool f = true;\n        vector<int> shiftX{0};\n        vector<int> downX{-1, 0, 1};\n        int down = 0;\n        while(f){\n            f = false;\n            for(auto sx : shiftX){\n                for(auto dx : downX){\n                    if(dp[ny+1][nx+sx+dx].fi < dp[ny][nx+sx].fi+prime[a[ny+1][nx+sx+dx]]){\n                        dp[ny+1][nx+sx+dx].fi = dp[ny][nx+sx].fi+prime[a[ny+1][nx+sx+dx]];\n                        if(prime[a[ny+1][nx+sx+dx]]) dp[ny+1][nx+sx+dx].se = a[ny+1][nx+sx+dx];\n                    }else if(dp[ny+1][nx+sx+dx].fi == dp[ny][nx+sx].fi+prime[a[ny+1][nx+sx+dx]]){\n                        if(dp[ny+1][nx+sx+dx].se < a[ny+1][nx+sx+dx]){\n                            if(prime[a[ny+1][nx+sx+dx]]) dp[ny+1][nx+sx+dx].se = a[ny+1][nx+sx+dx];\n                        }\n                    }\n                    if(0 < a[ny+1][nx+sx+dx] && a[ny+1][nx+sx+dx] <= m) f = true;\n                    else dp[ny+1][nx+sx+dx].fi = -1;\n                }\n            }\n            \n            if(down < 1000){\n                down++;\n                shiftX.pb(down);\n                shiftX.pb(-down);\n            }\n            // sort(All(shiftX));\n            // for(auto sx : shiftX){\n            //     cout << dp[ny+1][nx+sx]  << \" \";\n            // }\n            // cout << \"\\n\";\n            ny++;\n        }\n        P ans = mp(0, 0);\n        REP(i, 3000) chmax(ans, dp[ny-2][i]);\n        REP(i, 3000) chmax(ans, dp[ny-1][i]);\n        cout << ans.fi << \" \" << ans.se << \"\\n\";\n\n        cin >> m >> n;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n#define f first\n#define s second\ntypedef pair<int,int> P;\nint a[2000][2000],ans[2000][2000],d=0,y=999,x=1001,n,m;\nbool b[1000001],used[2000][2000];\nint dx[]={-1,0,1,0},tx[]={-1,0,1};\nint dy[]={0,1,0,-1},ty[]={1,1,1};\nint main(){\n  b[0]=b[1]=1;\n  for(int i=2;i<1000001;i++)\n    for(int j=i+i;j<1000001;j+=i)b[j]=1;\n  a[1000][1000]=1;\n  a[1000][1001]=2;\n  a[999][1001]=3;\n  for(int i=4;i<1000001;i++){\n    int yy=y+dy[d],xx=x+dx[d];\n    int ya=yy+dy[(d+1)%4],xa=xx+dx[(d+1)%4];\n    if(!a[ya][xa])d=(d+1)%4;\n    a[yy][xx]=i;\n    y=yy,x=xx;\n  }\n  while(cin>>n>>m,n){\n    memset(ans,0,sizeof(ans));\n    memset(used,0,sizeof(used));\n    r(i,2000)r(j,2000)if(a[i][j]==m){\n      used[i][j]=1;y=i;\n      break;\n    }\n    for(int i=y;i<2000;i++)r(j,2000)if(a[i][j]&&used[i][j]){\n      if(!b[a[i][j]])ans[i][j]++;\n      r(k,3){\n        y=i+ty[k],x=j+tx[k];\n        if(!a[y][x]||a[y][x]>n)continue;\n        ans[y][x]=max(ans[y][x],ans[i][j]);\n        used[y][x]=1;\n      }\n    }\n    int a1=0,a2;\n    r(i,2000)r(j,2000)if(a[i][j]<=n)if(a1<ans[i][j]){\n      a1=ans[i][j],a2=a[i][j];\n    }\n    if(!a1)cout<<\"0 0\"<<endl;\n    else cout<<a1<<' '<<a2<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <functional>\n#include <stack>\n#include <utility>\n#include <map>\n#include <queue>\n#include <set>\n#include <array>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nconst ll MOD = 10e9 + 7;\nconst ll INF = LLONG_MAX;\nconst ll MAX_V = 10e3;\nconst double EPS = 10e-6;\nconst double PI = 3.14159265359;\n\n//int dx[] = { 0,1,0,-1 }, dy[] = { 1,0,-1,0 };\nint d[] = {0,1,0,-1};\n//int nx = x + d[i];\n//int ny = y + d[(i+1)%4]\n\n\nint cave[1000][1000]{},n,m;\nP pos[1000000], dp[1000][1000];\nbool isprime[1001000];\n\nvoid prime(int n) {\n\tfor (int i = 0; i <= n; i++)isprime[i] = true;\n\tisprime[0] = false;\n\tisprime[1] = false;\n\tfor (int i = 2; i*i <= n; i++) {\n\t\tif (isprime[i]) {\n\t\t\tfor (int j = 2; i*j <= n; j++) {\n\t\t\t\tisprime[i*j] = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nP rec(int y, int x) {\n\tif (y < 0 || y >= 1000 || x<0 || x >= 1000 || cave[y][x]>m)return { 0,0 };\n\tif (dp[y][x].second != -1)return dp[y][x];\n\tvector<P> ls;\n\tfor (int i = -1; i <= 1; i++) {\n\t\tls.push_back(rec(y + 1, x + i));\n\t}\n\tsort(ls.begin(), ls.end());\n\tP res = ls[2];\n\tif (isprime[cave[y][x]]) {\n\t\tif (res.second <= 0)res.second = cave[y][x];\n\t\tres.first++;\n\t}\n\tdp[y][x] = res;\n\treturn res;\n}\n\n\n\nint main() {\n\tint num = 1000000, ti = 0, tj = 0, tk = 0;\n\twhile (num > 0) {\n\t\tcave[ti][tj] = num;\n\t\tpos[num] = { ti,tj };\n\t\tint pi = ti + d[tk], pj = tj + d[(tk+1)%4];\n\t\tif (pi < 0 || pi >= 1000 || pj < 0 || pj >= 1000 || cave[pi][pj]>0) {\n\t\t\ttk = (tk + 1) % 4;\n\t\t}\n\t\tti += d[tk];\n\t\ttj += d[(tk + 1) % 4];\n\t\tnum--;\n\t}\n\tprime(1000000);\n\n\twhile (1) {\n\t\tcin >> m >> n;\n\t\tif (n == 0)break;\n\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\t\tdp[i][j] = { -1,-1 };\n\t\t\t}\n\t\t}\n\t\tP ans = rec(pos[n].first, pos[n].second);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\n#define SIZE 1000\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\t\t/*\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}*/\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t\n\t\toutput = false;\n\t\tfor (int i = 0;i < SIZE&&(!output);i++) {\n\t\t\tfor (int j = 0;j < SIZE&&(!output);j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tprintf(\"%d %d\\n\", dp[i][j], pr[i][j]);\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\nconst int limit = 1e6;\nconst int hsize = 1e3;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main(){\n\tvector<bool> prime(limit+1, true);\n\tprime[0] = prime[1] = false;\n\tfor(int i=2; i*i<=limit; i++){\n\t\tif(prime[i]){\n\t\t\tfor(int j=2; i*j<=limit; j++){\n\t\t\t\tprime[i*j] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<int> > cave(hsize+2, vector<int>(hsize+2, 0));\n\tvector<pair<int,int> > to_xy(limit+1);\n\tint sx=hsize/2, sy=hsize/2;\n\tcave[sx][sy]=1;\n\tto_xy[1] = make_pair(sx, sy);\n\tint x=sx, y=sy;\n\tint num=2, dir=0;\n\tfor(int i=0; ; i++){\n\t\tbool flag = false;\n\t\tfor(int j=0; j<i/2+1; j++){\n\t\t\tx+=dx[dir];\n\t\t\ty+=dy[dir];\n\t\t\tcave[x][y] = num;\n\t\t\tto_xy[num] = make_pair(x,y);\n\t\t\tnum++;\n\t\t\tif(num>limit){\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag) break;\n\t\tdir = (dir+1)%4;\n\t}\n\t\n\twhile(1){\n\t\tint m,n;\n\t\tcin >> m >> n;\n\t\tif(m==0) break;\n\t\tint x = to_xy[n].first;\n\t\tint y = to_xy[n].second;\n\t\t\n\t\tint maxnum=0, lastcave=0;\n\t\tvector<vector<int> > dp(hsize+2, vector<int>(hsize+2, -1));\n\t\tmaxnum = dp[x][y] = (prime[n])? 1: 0;\n\t\tlastcave = n;\n\t\twhile(y>0){\n\t\t\ty--;\n\t\t\tfor(int i=1; i<=hsize; i++){\n\t\t\t\tif(cave[i][y] > m) continue;\n\t\t\t\tint maxparent=-1;\n\t\t\t\tfor(int j=-1; j<=1; j++){\n\t\t\t\t\tif(cave[i+j][y+1] > m) continue;\n\t\t\t\t\tmaxparent = max(maxparent, dp[i+j][y+1]);\n\t\t\t\t}\n\t\t\t\tif(maxparent!=-1){\n\t\t\t\t\tdp[i][y] = maxparent;\n\t\t\t\t\tif(prime[cave[i][y]]){\n\t\t\t\t\t\tdp[i][y]++;\n\t\t\t\t\t\tif((dp[i][y] > maxnum) || (dp[i][y]==maxnum && cave[i][y]>lastcave)){\n\t\t\t\t\t\t\tmaxnum = dp[i][y];\n\t\t\t\t\t\t\tlastcave = cave[i][y];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(maxnum==0){\n\t\t\tcout << \"0 0\" << endl;\n\t\t}else{\n\t\t\tcout << maxnum << \" \" << lastcave << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nbool is_prime[1000001];\nmap<P,int> stage;\n\nvoid dfs(map<int,int>& dp,int total_caves,int sx,int sy,int count){\n  if(is_prime[stage[P(sy,sx)]]){\n    count++;\n  }\n\n  map<int,int>::iterator it = dp.find(stage[P(sy,sx)]);\n  if(it != dp.end() && it->second >= count){\n    return;\n  }\n\n  dp[stage[P(sy,sx)]] = count;\n\n  for(int nx=-1;nx<=1;nx++){\n    int dx = sx + nx;\n    int dy = sy+1;\n    if(stage.find(P(dy,dx)) == stage.end()) continue;\n    if(stage[P(dy,dx)] > total_caves) continue;\n    dfs(dp,total_caves,dx,dy,count);\n  }\n}\n\nint main(){\n  int x = 0;\n  int y = 0;\n  int dir = 1;\n  for(int round = 1; round <= 1000000;round++){\n    stage[P(y,x)] = round;\n\n    int prev_dir = dir;\n    if(round > 1) dir = (dir + 3) % 4;\n    int dx = x + tx[dir];\n    int dy = y + ty[dir];\n    if(stage.find(P(dy,dx)) != stage.end()){\n      dir = prev_dir;\n    }\n    dx = x + tx[dir];\n    dy = y + ty[dir];\n    x = dx;\n    y = dy;\n  }\n  \n  memset(is_prime,true,sizeof(is_prime));\n\n  is_prime[0] = false;\n  is_prime[1] = false;\n\n  for(int i=2;i*i<=1000000;i++){\n    if(is_prime[i]){\n      for(int j=i+i;j<=1000000;j+=i){\n\tis_prime[j] = false;\n      }\n    }\n  }\n\n  int start,total_caves;\n  while(~scanf(\"%d %d\",&total_caves,&start)){\n    map <int,int> dp;\n    int sx=0,sy=0;\n    for(map<P,int>::iterator it = stage.begin();\n\tit != stage.end();\n\tit++){\n      int x = it->first.second;\n      int y = it->first.first;\n      int num = it->second;\n      if(num == start){\n\tsx = x;\n\tsy = y;\n\tbreak;\n      }\n    }\n\n    dfs(dp,total_caves,sx,sy,0);\n\n    int res_prime=0;\n    int res_count=0;\n    for(map<int,int>::iterator it = dp.begin();\n\tit != dp.end();\n\tit++){\n      if(!is_prime[it->first]) continue;\n\n      if(res_count < it->second){\n\tres_count = it->second;\n\tres_prime = it->first;\n      }\n      if(res_count == it->second\n\t && res_prime < it->first){\n\tres_prime = it->first;\n      }\n    }\n    printf(\"%d %d\\n\",res_count,res_prime);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstdio>\n \nusing namespace std;\n \n#define out(x,l) (x<0||l<=x)\n \nconst int N = 1000000+10;\nconst int SIZE = 1010;\n \nbool isprime[N];\npair<int, int> loc[N];\nint cave[SIZE][SIZE];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, -1, 0, 1};\npair<int, int> dp[SIZE][SIZE];\n \nint main(){\n    for (int i = 0; i < N; i++) { isprime[i] = 1; } \n    isprime[0] = isprime[1] = 0;\n    for (int i = 2; i*i <= N; i++) {\n        if (!isprime[i]) continue;\n        for (int j = 2*i; j <= N; j += i) {\n            isprime[j] = 0;\n        }\n    }\n\n\tfor (int i = 0; i < SIZE; i++)\n\t\tfor (int j = 0; j < SIZE; j++)\n\t\t\tcave[i][j] = 0;\n \n    int x = SIZE/2, y = SIZE/2+1;\n    int cnt = 1;\n    int dir = 0;\n    int edge = 1;\n    while (1) {\n\t\tif (cnt > N) break;\n        dir %= 4;\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < edge; j++) {\n\t\t\t\tif (out(x,SIZE)||out(y,SIZE)) continue;\n                cave[y][x] = cnt;\n                loc[cnt].first = y;\n                loc[cnt].second = x;\n                x += dx[dir];\n                y += dy[dir];\n                cnt++;\n            }\n            dir++;\n        }\n        edge++;\n    }\n \n//  for (int i = 1; i < 100; i++) {\n//      cout << i << \" \" << loc[i].first << \" \" << loc[i].second << endl;\n//  }\n \n    int n, m;\n    while (cin >> m >> n, m&&n) {\n        for (int i = 0; i < SIZE; i++)\n            for (int j = 0; j < SIZE; j++) {\n                dp[i][j].first = -1;\n                dp[i][j].second = 0;\n            }\n        dp[loc[n].first][loc[n].second].first = isprime[n];\n        if (isprime[n]) dp[loc[n].first][loc[n].second].second = n;\n \n        for (int i = 0; i < SIZE; i++) {\n            for (int j = 0; j < SIZE; j++) {\n                if (cave[i][j] > m) continue;\n                pair<int, int> next; // first:the number of caves passed    second:last cave\n                next.first = -1;\n                next.second = 0;\n                bool update = 0;\n                if (!out(i-1,SIZE)&&!out(j-1,SIZE)&&dp[i-1][j-1].first!=-1) {\n                    if (dp[i-1][j-1].first > next.first) {\n                        next = dp[i-1][j-1];\n                        update = 1;\n                    } else if (dp[i-1][j-1].first == next.first && dp[i-1][j-1].second > next.second) {\n                        next = dp[i-1][j-1];\n                        update = 1;\n                    }\n                }\n                if (!out(i-1,SIZE)&&!out(j+1,SIZE)&&dp[i-1][j+1].first!=-1) {\n                    if (dp[i-1][j+1].first > next.first) {\n                        next = dp[i-1][j+1];\n                        update = 1;\n                    } else if (dp[i-1][j+1].first == next.first && dp[i-1][j+1].second > next.second) {\n                        next = dp[i-1][j+1];\n                        update = 1;\n                    }\n                }\n                if (!out(i-1,SIZE)&&!out(j,SIZE)&&dp[i-1][j].first!=-1) {\n                    if (dp[i-1][j].first > next.first) {\n                        next = dp[i-1][j];\n                        update = 1;\n                    } else if (dp[i-1][j].first == next.first && dp[i-1][j].second > next.second) {\n                        next = dp[i-1][j];\n                        update = 1;\n                    }\n                }\n                if (!update) continue;\n                if (isprime[cave[i][j]]) {\n                    next.first++;\n                    next.second = cave[i][j];\n                }\n                dp[i][j] = next;\n            }\n        }\n\n        pair<int, int> res;\n        for (int i = 0; i < SIZE; i++)\n            for (int j = 0; j < SIZE; j++)\n                if (res.first < dp[i][j].first) {\n                    res = dp[i][j];\n                } else if (res.first == dp[i][j].first&&res.second < dp[i][j].second) {\n                    res = dp[i][j];\n                }\n        cout << res.first << \" \" << res.second << endl;\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\n#include \"math.h\"\n\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=x && x<w && 0<=y && y<h)\n\nconst int INF = 10000000;\nint dx[4]={1, 0, -1, 0}, dy[4]={0, 1, 0, -1};\nusing namespace std;\ntypedef pair<int, int> P;\n\n/** Problem1189 : Prime Caves **/\nint caves[1010][1010];\nint dp[1010][1010];\nconst int MAX = 1030000;\nbool prime[MAX];\n\nint main()\n{\n\tint m, n;\n\tconst int dx0[4] = {1, 0, -1, 0}, dy0[4] = {0, -1, 0, 1}, dx1[3]={-1, 0, 1};\n\tint sx=0, sy=0;\n\t\n\tfor (int i=0; i<MAX; i++)\n\t\tprime[i] = true;\n\t\n\tprime[0] = false; prime[1] = false;\n\t\n\tfor (int i=2; i<MAX; i++) {\n\t\tif (prime[i]) {\n\t\t\tfor (int j=2; i*j<MAX; j++) {\n\t\t\t\tprime[i*j] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\twhile (cin>>m>>n, m||n) {\n\t\tfill(caves[0], caves[0]+1010*1010, 0);\n\t\tfill(dp[0], dp[0]+1010*1010, -1);\n\t\tint x=1010/2, y=1010/2 , t=1, direct=1;\n\t\tcaves[x][y]=1;\n\t\tcaves[++x][y]=2;\n\t\tint i=2; bool change = true;\n\t\tif (n==1) {\n\t\t\tsx=x; sy=y;\n\t\t}\n\t\twhile (1) {\n\t\t\trep(j, t) {\n\t\t\t\tx+=dx0[direct]; y+=dy0[direct];\n\t\t\t\tcaves[x][y]=i+1;\n\t\t\t\ti++;\n\t\t\t\tif (i==n) {\n\t\t\t\t\tsx = x; sy = y;\n\t\t\t\t}\n\t\t\t\tif (i>=m) goto end;\n\t\t\t}\n\t\t\tif (change) {\n\t\t\t\tt++;\n\t\t\t\tchange = false;\n\t\t\t} else {\n\t\t\t\tchange=true;\n\t\t\t}\n\t\t\tdirect++; direct%=4;\n\t\t}\n\t\t\n\tend: ;\n\t\tint ans=0, alast=0, test=0;\n\n\t\tdp[sx][sy] = prime[caves[sx][sy]];\n\t\tREP(j, 0, 1010) {\n\t\t\tREP(i, 0, 1010) {\n\t\t\t\tans = max(ans, dp[i][j]);\n\t\t\t\t\n\t\t\t\tif (dp[i][j] == -1) continue;\n\t\t\t\tif (caves[i][j] == 0) continue;\n\t\t\t\t\n\t\t\t\trep(k, 3) {\n\t\t\t\t\tint nx=i+dx1[k], ny=j+1;\n\t\t\t\t\tif (!(0<=nx && nx<1010) || ny>=1010) continue;\n\t\t\t\t\tif (caves[nx][ny]==0) continue;\n\n\t\t\t\t\tdp[nx][ny] = max(dp[nx][ny], dp[i][j]+prime[caves[nx][ny]]);\n\t\t\t\t\tif (dp[nx][ny]<dp[i][j]+prime[caves[nx][ny]]) {\n\t\t\t\t\t\tdp[nx][ny] = dp[i][j]+prime[caves[nx][ny]];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\ttest = max(test, caves[nx][ny]);\n\t\t\t\t\tans = max(ans, dp[nx][ny]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (ans!=0) {\n\t\t\tREP(j, 0, 1010) {\n\t\t\t\tREP(i, 0, 1010) {\n\t\t\t\t\tif (dp[i][j]==ans && prime[caves[i][j]]) {\n\t\t\t\t\t\talast = max(alast, caves[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << \" \" << alast << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define ALL(x) x.begin(), x.end()\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n\nusing ll = long long;\ntypedef pair<int, int> pii;\npii dp[1200][1200];\nint A[1200][1200];\n\nbool isprime[2000020];\nvector<int> sosuu;\nvoid Eratosthenes() {\n    ll N = 2000020;\n    int c = 0;\n    REP(i, N) { isprime[i] = true; }\n    for (ll i = 2; i < sqrt(N); i++) {\n        if (isprime[i]) {\n            for (ll j = 0; i * (j + 2) < N; j++) {\n                isprime[i * (j + 2)] = 0;\n            }\n        }\n    }\n    isprime[0] = false;\n    isprime[1] = false;\n    REP(i, N) if (isprime[i]) sosuu.push_back(i);\n    // for(ll i=2;i<N;i++){\n\n    // }\n}\n\nvoid init(int M) {\n    REP(i, 1200) REP(j, 1200) {\n        A[i][j] = 0;\n        dp[i][j] = {0, 0};\n    }\n    A[600][600] = 1;\n    int dir = 1;\n    int stride = 1;\n    int x = 600, y = 600;\n    int cur = 1;\n    while (cur <= M) {\n        REP(__, 2) {\n            REP(_, stride) {\n                if (dir % 4 == 0)\n                    x++;\n                else if (dir % 4 == 1)\n                    y++;\n                else if (dir % 4 == 2)\n                    x--;\n                else\n                    y--;\n                cur++;\n                if (cur > M) break;\n                A[x][y] = cur;\n            }\n            dir++;\n        }\n        stride++;\n    }\n}\nconst bool debug = false;\nvoid solve() {\n    int M, N;\n    cin >> M >> N;\n    if (M == 0) exit(0);\n    init(M);\n    if (debug) {\n        FOR(i, 550, 650) {\n            FOR(j, 550, 650) {\n                cout << A[i][j] << \" \";\n                string s = to_string(A[i][j]);\n                int rem = 4 - s.size();\n                REP(_, rem) cout << \" \";\n            }\n            cout << endl;\n        }\n    }\n\n    REP(i, 1199) REP(j, 1199) {\n        if (A[i][j] == 0) continue;\n        if (isprime[A[i][j]]) dp[i][j].first = 0;\n    }\n\n    for (int i = 1199; i >= 0; i--) {\n        REP(j, 1199) {\n            if (A[i][j] == 0) continue;\n            if (dp[i][j].second == 0 && isprime[A[i][j]]) {\n                dp[i][j].second = A[i][j];\n            }\n            if (i == 0) continue;\n            int tmp = 0;\n            if (isprime[A[i][j]]) dp[i][j].first++;\n            pii nxt = {dp[i][j].first + tmp, dp[i][j].second};\n\n            if (j > 0 && A[i - 1][j - 1] != 0 && dp[i - 1][j - 1] < nxt) {\n                dp[i - 1][j - 1] = nxt;\n            }\n\n            nxt = {dp[i][j].first + tmp, dp[i][j].second};\n            if (A[i - 1][j] != 0 && dp[i - 1][j] < nxt) {\n                dp[i - 1][j] = nxt;\n            }\n\n            nxt = {dp[i][j].first + tmp, dp[i][j].second};\n            if (A[i - 1][j + 1] != 0 && dp[i - 1][j + 1] < nxt) {\n                dp[i - 1][j + 1] = nxt;\n            }\n        }\n    }\n    REP(i, 1199) {\n        REP(j, 1199) {\n            if (A[i][j] == N) {\n                if (dp[i][j].first == 0)\n                    cout << \"0 0\" << endl;\n                else\n                    cout << dp[i][j].first << \" \" << dp[i][j].second << endl;\n                return;\n            }\n        }\n    }\n}\n\nsigned main() {\n    Eratosthenes();\n    // for (auto i : sosuu) cout << i << endl;\n    while (true) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\nusing namespace std;\n#define N 1000\n#define N2 N*N\nbool prime[N2+1];\nint cave[N+2][N+2]={};\npair<int,int> locate[N2+1];\nint last[N+2][N+2];\nint dp[N+2][N+2];\nint m,n;\n\nbool wall(int x,int y){ return x==0 || y==0 || x==N+1 || y==N+1; }\n\nint rec(int x,int y){\n    if(wall(x,y) || cave[x][y]>m)return 0;\n    if(dp[x][y])return dp[x][y];\n    pair<int,int> child[3];\n    rep(i,3)child[i]=pair<int,int>(rec(x+i-1,y-1),last[x+i-1][y-1]);\n    sort(child,child+3);\n    dp[x][y]=child[2].first;\n    if(prime[cave[x][y]])dp[x][y]++;\n    last[x][y]=child[2].second;\n    if(last[x][y]==0 && prime[cave[x][y]]) last[x][y]=cave[x][y];\n    return dp[x][y];\n}\n\nint main(void){\n    rep1(i,N2)prime[i]=true;\n    prime[0]=prime[1]=false;\n    for(int i=2;i<=N2;i++){\n        if(prime[i]) for(int k=2;i*k<=N2;k++) prime[i*k]=false;\n    }\n\n    int x=1,y=N,d=0;\n    int dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};\n    for(int i=N2;i>0;i--){\n        cave[x][y]=i;\n        locate[i] = pair<int,int>(x,y);\n        if(wall(x+dx[d],y+dy[d]) || cave[x+dx[d]][y+dy[d]]) d=(d+1)%4;\n        x+=dx[d];\n        y+=dy[d];\n    }\n\n    while(cin>>m>>n, m|n){\n        rep1(x,N)rep1(y,N) dp[x][y]=last[x][y]=0;\n        int x=locate[n].first,y=locate[n].second;\n        int cnt = rec(x,y);\n        printf(\"%d %d\\n\",cnt,last[x][y]);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\nint fie[2000][2000];\nbool isp[1000001];\nint dp[2000][2000];\n\n\nvoid makeEra(){\n    for(int i=0;i<=1001;i++){\n        if( isp[i] ){\n            for(int j=2;i*j<1000001;j++){\n                isp[i*j]=false;\n            }\n        }\n    }\n}\n\nbool is(int n,int dir,int y,int x){\n    if( dir==0 ){\n        if( fie[y-1][x]==-1 )return true;\n    }\n    if( dir==1 ){\n        if( fie[y][x-1]==-1 )return true;\n    }\n    if( dir==2 ){\n        if( fie[y+1][x]==-1 )return true;\n    }\n    if( dir==3 ){\n        if( fie[y][x+1]==-1 )return true;\n    }\n    return false;\n}\n\nvoid makeFie(int n){\n    int y=1000,x=1000;\n    int dir = 0; //テ・ツ渉ウ0 テ、ツクツ? テ・ツキツヲ2 テ、ツクツ?\n    int dy[]={0,-1,0,1};\n    int dx[]={1,0,-1,0};\n\n    for(int i=1;i<=n;i++){\n        fie[y][x]=i;\n        y+=dy[dir];\n        x+=dx[dir];\n        if( is(i,dir,y,x) ) dir=(dir+1)%4;\n\n    }\n}\n\n\nint main(){\n    rep(i,1000001) isp[i]=true;\n    isp[0]=isp[1]=false;\n    makeEra();\n    \n    int m,n;\n    while(cin>>m>>n){\n        if(m==0&&n==0)break;\n        rep(i,2000)rep(j,2000)fie[i][j]=-1;\n        makeFie(m);\n\n        int y,x;\n        rep(i,2000)rep(j,2000){\n            if(fie[i][j]==n){\n                y=i;\n                x=j;\n                break;\n            }\n        }\n        \n        rep(i,2000)rep(j,2000)dp[i][j]=-1;\n        dp[y][x]=0;\n        if(isp[n])dp[y][x]++;\n        \n        rep(i,2000-1){\n            rep(j,2000){\n                if( dp[i][j]!=-1 ){\n                    if( j-1>=0 && fie[i+1][j-1]!=-1 )   dp[i+1][j-1] = max( dp[i][j]+isp[ fie[i+1][j-1] ] , dp[i+1][j-1] );\n                    if( fie[i+1][j]!=-1 )               dp[i+1][ j ] = max( dp[i][j]+isp[ fie[i+1][ j ] ] , dp[i+1][ j ] );\n                    if( j+1<2000 && fie[i+1][j+1]!=-1)  dp[i+1][j+1] = max( dp[i][j]+isp[ fie[i+1][j+1] ] , dp[i+1][j+1] );\n                }\n            }\n        }\n        int pre=-1,maxi=-1;\n        \n        rep(i,2000){\n            rep(j,2000){\n                if( dp[i][j]>maxi || (dp[i][j]==maxi && isp[fie[i][j]] && fie[i][j]>pre) ){\n                    maxi=dp[i][j];\n                    pre=fie[i][j];\n                }\n            }\n        }\n        \n        if( maxi==0 )cout<<\"0 0\"<<endl;\n        else cout<<maxi<<\" \"<<pre<<endl;\n        \n    }\n}\n\n\n/*\nbool isLeep(int n){\n    return ( (n%4==0 && n%100!=0) || n%400==0 );\n}\n\n\nll ymdToNum(int y,int m,int d){\n    \n    int month[]={0,0,31,59,90,120,151,181,212,243,273,304,334};\n    \n    ll ret=0;\n    ret+=365*(y-1);\n    ret+=(int)((y-1)/4) - (int)((y-1)/100) + (int)((y-1)/400);\n    \n    ret+=month[m];\n    if( isLeep(y) && m>=3 )ret++;\n    \n    ret+=d-1;\n    \n    return ret;\n}\n\nll bkatwkiToNum(int b,int ka,int t,int w,int ki){\n    ll ret=0;\n    ret+=b;\n    ret*=20;\n    \n    ret+=ka;\n    ret*=20;\n    \n    ret+=t;\n    ret*=18;\n    \n    ret+=w;\n    ret*=20;\n    \n    ret+=ki;\n    \n    return ret;\n}\n\n\nint main(){\n    string s;\n    while(cin>>s){\n        if( s==\"#\" )break;\n        \n        string buf=\"\";\n        vector<string> tmp;\n        rep(i,s.size()){\n            if( s[i]!='.' )buf+=s[i];\n            else{\n                tmp.pb(buf);\n                buf=\"\";\n            }\n        }\n        tmp.pb(buf);\n\n\n        //b.ka.t.w.ki\n        if( tmp.size()==5 ){ //maya\n            int b  = stoi(tmp[0]);\n            int ka = stoi(tmp[1]);\n            int t  = stoi(tmp[2]);\n            int w  = stoi(tmp[3]);\n            int ki = stoi(tmp[4]);\n            \n            ll num = bkatwkiToNum(b,ka,t,w,ki);\n            \n            num += ymdToNum(2012,12,21);\n            \n            int y,m,d;\n            int t1=0;\n            for(int i=1;;i++){\n                t1+=365;\n                if( isLeep(i) )t1++;\n                \n                if(t1>num){\n                    y=i;\n                    break;\n                }\n            }\n            \n            num -= t1-365;\n            if( isLeep(y) )num--;\n            \n            int month[]={0,31,59,90,120,151,181,212,243,273,304,334,365};\n            rep(i,13){\n                int ep=0;\n                if( isLeep(y)&&i>2 )ep++;\n                \n                if( month[i]+ep>num ){\n                    m=i;\n                    break;\n                }\n            }\n            num -= month[m-1];\n            \n            d=num+1;\n            \n            cout<<y<<\".\"<<m<<\".\"<<d<<endl;\n            \n            \n        }else if( tmp.size()==3 ){   //sei\n            int y = stoi(tmp[0]);\n            int m = stoi(tmp[1]);\n            int d = stoi(tmp[2]);\n            \n            ll num = ymdToNum(y,m,d);\n            \n            cout<<\"-\"<<endl;\n        }else return 0;\n    }\n}\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n\tvector< vector<int> > data(1001, vector<int>(1001, 0));\n\tint c2 = 0;\n\tint dx[] = {-1, 0, 1, 0};\n\tint dy[] = {0, -1, 0, 1};\n\tint x, y;\n\tx = y = 1000;\n\tfor (int i = 1001*1001; i >= 1; i--) {\n\t\tdata[y][x] = i;\n\t\tif (x+dx[c2] >= 0 && x+dx[c2] < 1001 && y+dy[c2] >= 0 && y+dy[c2] < 1001 && data[y+dy[c2]][x+dx[c2]] == 0) {\n\t\t\tx += dx[c2];\n\t\t\ty += dy[c2];\n\t\t} else {\n\t\t\tc2++;\n\t\t\tif (c2 >= 4) {\n\t\t\t\tc2 = 0;\n\t\t\t}\n\t\t\tx += dx[c2];\n\t\t\ty += dy[c2];\n\t\t}\n\t}\n\tvector<int> furu(1000010, 0);\n\tfuru[0] = furu[1] = 1;\n\tfor (int i = 2; i*i <= 1000000; i++) {\n\t\tif (furu[i] == 0) {\n\t\t\tfor (int j = 2; i*j <= 1000000; j++) {\n\t\t\t\tfuru[i*j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint m, n;\n\twhile(cin >> m >> n) {\n\t\tif (m == 0 && n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tint si, sj;\n\t\tsi = sj = -1;\n\t\tfor (int i = 0; i < 1001; i++) {\n\t\t\tfor (int j = 0; j < 1001; j++) {\n\t\t\t\tif (data[i][j] == n) {\n\t\t\t\t\tsi = i;\n\t\t\t\t\tsj = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (si != -1 && sj != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvector< vector<int> > d2(1001, vector<int>(1001, -1));\n\t\tvector< vector<int> > d3(1001, vector<int>(1001, -1));\n\t\tint gg = 0;\n\t\tint sososu = 0;\n\t\tif (furu[data[si][sj]] == 0) {\n\t\t\tgg = d2[si][sj] = 1;\n\t\t\tsososu = d3[si][sj] = data[si][sj];\n\t\t} else {\n\t\t\tgg = d2[si][sj] = 0;\n\t\t\tsososu = d3[si][sj] = 0;\n\t\t}\n\t\tfor (int i = si+1; i < 1001; i++) {\n\t\t\tbool h = true;\n\t\t\tfor (int j = 0; j < 1001; j++) {\n\t\t\t\tif (data[i][j] <= m) {\n\t\t\t\t\tbool hh = false;\n\t\t\t\t\tint ck = 0;\n\t\t\t\t\tint sosu = 0;\n\t\t\t\t\tif (j > 0) {\n\t\t\t\t\t\tif (d2[i-1][j-1] != -1) {\n\t\t\t\t\t\t\tif (d2[i-1][j-1] > ck) {\n\t\t\t\t\t\t\t\tck = d2[i-1][j-1];\n\t\t\t\t\t\t\t\tsosu = d3[i-1][j-1];\n\t\t\t\t\t\t\t\thh = true;\n\t\t\t\t\t\t\t} else if (d2[i-1][j-1] == ck) {\n\t\t\t\t\t\t\t\tsosu = max(sosu, d3[i-1][j-1]);\n\t\t\t\t\t\t\t\thh = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (d2[i-1][j] != -1) {\n\t\t\t\t\t\tif (d2[i-1][j] > ck) {\n\t\t\t\t\t\t\tck = d2[i-1][j];\n\t\t\t\t\t\t\tsosu = d3[i-1][j];\n\t\t\t\t\t\t\thh = true;\n\t\t\t\t\t\t} else if (d2[i-1][j] == ck) {\n\t\t\t\t\t\t\tsosu = max(sosu, d3[i-1][j]);\n\t\t\t\t\t\t\thh = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (j < 1000) {\n\t\t\t\t\t\tif (d2[i-1][j+1] != -1) {\n\t\t\t\t\t\t\tif (d2[i-1][j+1] > ck) {\n\t\t\t\t\t\t\t\tck = d2[i-1][j+1];\n\t\t\t\t\t\t\t\tsosu = d3[i-1][j+1];\n\t\t\t\t\t\t\t\thh = true;\n\t\t\t\t\t\t\t} else if (d2[i-1][j+1] == ck) {\n\t\t\t\t\t\t\t\tsosu = max(sosu, d3[i-1][j+1]);\n\t\t\t\t\t\t\t\thh = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (furu[data[i][j]] == 0) {\n\t\t\t\t\t\tck++;\n\t\t\t\t\t\tsosu = data[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tif (!hh) {\n\t\t\t\t\t\tck = -1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\th = false;\n\t\t\t\t\t}\n\t\t\t\t\td2[i][j] = ck;\n\t\t\t\t\td3[i][j] = sosu;\n\t\t\t\t\tif (ck > gg) {\n\t\t\t\t\t\tgg = ck;\n\t\t\t\t\t\tsososu = sosu;\n\t\t\t\t\t} else if (ck == gg) {\n\t\t\t\t\t\tsososu = max(sososu, sosu);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (h) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << gg << ' ' << sososu << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <fstream>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppi;\n\n\nconst int dy[]={0,-1,0,1};\nconst int dx[]={1,0,-1,0};\n\n\nbool isPrime[1000100];\nint prime[1000100];\n\nint p;\nvoid erats(){\n  for(int i=0;i<1000100;i++)\n    isPrime[i]=true;\n  p=0;\n  isPrime[0]=isPrime[1]=false;\n  for(int i=2;i<1000100;i++){\n    if(isPrime[i]){\n      prime[p++]=i;\n      for(int j=2*i;j<1000100;j+=i)\n        isPrime[j]=false;\n    }\n  }\n}\n\n\nint N,M;\nmap<pair<short,short>,int> m;\npair<short,short> idToPii[1000200];\npii dp[1000100];\n\npii dfs(int pos){\n  if(dp[pos].first>=0)return dp[pos];\n  pii res=pii(isPrime[pos],isPrime[pos]?pos:0);\n  for(int i=-1;i<=1;i++){\n    pii nxt=idToPii[pos];\n    nxt.first++;\n    nxt.second+=i;\n    if(m.count(nxt)&&m[nxt]<=M){\n      pii p=dfs(m[nxt]);\n      if(isPrime[pos])p.first++;\n      if(res.first<p.first)res=p;\n      else if(res.first==p.first){\n        if(res.second<p.second)\n          res=p;\n      }\n    }\n  }\n  return dp[pos]=res;\n}\n\nint main(){\n  erats();\n  \n  int sum=1;\n  int pos=0;\n  pii now=pii(0,0);\n  m[now]=1;\n  idToPii[sum]=now;\n  sum++;\n  for(int i=1;;i++){\n    for(int j=0;j<2;j++){\n      // posの方向へiだけ進む\n      for(int k=0;k<i;k++){\n        now.first+=dy[pos];\n        now.second+=dx[pos];\n        m[now]=sum;\n        idToPii[sum]=now;\n        sum++;\n        if(sum>=1000100)break;\n      }\n      pos=(pos+1)%4;\n    }\n    if(sum>=1000100)break;\n  }\n  //return 0;\n  while(cin>>M>>N&&(N|M)){\n    for(int i=0;i<=M;i++)\n      dp[i].first=dp[i].second=-1;\n    pii p=dfs(N);\n    cout<<p.first<<\" \"<<p.second<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n\nusing namespace std;\n\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef pair<int, int> PII;\n\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n **/\n\nconst int MAP_SIZE = 2000;\n\ninline int SQR(int n) {\n    return n * n;\n}\n\nvector<bool> ERATOSTHENES(int n) {\n    vector<bool> arr(n, true);\n    for (int i = 2; SQR(i) < n; i++) {\n        if (arr[i]) {\n            for (int j = 0; i * (j + 2) < n; j++) {\n                arr[i * (j + 2)] = false;\n            }\n        }\n    }\n    return arr;\n}\n\nvoid makeMap(VVI &map, VVB &used, VB &primes, PII start, int m) {\n    int count = 1;\n    int right = 1;\n    int up = 1;\n    int left = 2;\n    int down = 2;\n    PII point = start;\n\n    while (true) {\n        for (int i = 0; i < right; i++) {\n            if (count < m) {\n                count++;\n                point.second += 1;\n                map[point.first][point.second] = count;\n                if (primes[count]) {\n                    used[point.first][point.second] = true;\n                }\n            }\n        }\n        for (int i = 0; i < up; i++) {\n            if (count < m) {\n                count++;\n                point.first -= 1;\n                map[point.first][point.second] = count;\n                if (primes[count]) {\n                    used[point.first][point.second] = true;\n                }\n            }\n        }\n        for (int i = 0; i < left; i++) {\n            if (count < m) {\n                count++;\n                point.second -= 1;\n                map[point.first][point.second] = count;\n                if (primes[count]) {\n                    used[point.first][point.second] = true;\n                }\n            }\n        }\n        for (int i = 0; i < down; i++) {\n            if (count < m) {\n                count++;\n                point.first += 1;\n                map[point.first][point.second] = count;\n                if (primes[count]) {\n                    used[point.first][point.second] = true;\n                }\n            }\n        }\n\n        if (count < m) {\n            right += 2;\n            up += 2;\n            left += 2;\n            down += 2;\n        } else {\n            break;\n        }\n\n    }\n}\n\nint main() {\n\n    vector<bool> primes = ERATOSTHENES(2000000);\n\n    while (true) {\n        int m, n;\n        cin >> m >> n;\n\n        if (m == 0 && n == 0) break;\n\n        VVI map(MAP_SIZE, VI(MAP_SIZE, 0));\n        VVB used(MAP_SIZE, VB(MAP_SIZE, false));\n        //first = y   second = x\n        PII start(MAP_SIZE / 2, MAP_SIZE / 2);\n        map[start.first][start.second] = 1;\n\n        makeMap(map, used, primes, start, m);\n\n        for (int i = 0; i < map.size(); i++) {\n            for (int j = 0; j < map[i].size(); j++) {\n                if (map[i][j] == n) start = make_pair(i, j);\n            }\n        }\n\n        VVI dp(MAP_SIZE, VI(MAP_SIZE, -1));\n        if (used[start.first][start.second]) {\n            dp[start.first][start.second] = 1;\n        } else {\n            dp[start.first][start.second] = 0;\n        }\n//        for (int j = 2; j <= MAP_SIZE - 2; j++) {\n//            if (used[start.first][j])dp[start.first][j] = 1;\n//        }\n\n        for (int i = start.first + 1; i < MAP_SIZE - 2; i++) {\n            for (int j = 2; j < MAP_SIZE - 2; j++) {\n                if (map[i][j] == 0)continue;\n                int maxV = -1;\n                maxV = max(maxV, dp[i - 1][j - 1]);\n                maxV = max(maxV, dp[i - 1][j]);\n                maxV = max(maxV, dp[i - 1][j + 1]);\n                if (maxV == -1) continue;\n                if (used[i][j]) maxV++;\n                dp[i][j] = maxV;\n            }\n        }\n\n\n        int maxV = 0;\n        int number = 0;\n        PII last(0, 0);\n\n        for (int i = 0; i < dp.size(); i++) {\n            for (int j = 0; j < dp[i].size(); j++) {\n                if (used[i][j] && dp[i][j] != 0 && dp[i][j] >= maxV) {\n                    number = map[i][j];\n                    maxV = dp[i][j];\n                    last.first = i;\n                    last.second = j;\n                }\n                maxV = max(maxV, dp[i][j]);\n            }\n        }\n\n        cout << maxV << \" \" << number << endl;\n\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE + 10][SIZE + 10], dp[SIZE + 10][SIZE + 10], pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t\n\t\tfor (int h = 0;h < SIZE;h++) {\n\t\t\tfor (int w = 0;w < SIZE;w++) {\n\t\t\t\tcout << dp[h][w] << \" \" << pr[h][w] << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n  \n#define MP make_pair\n#define PB push_back\n#define MAX_N 1100000\n#define SIZE 1200\n#define X first\n#define Y second\n  \nconst int STX = 600, STY = 600;\n\ntypedef pair<int, int> Pii;\ntypedef pair<int, Pii> P;\n  \nint id[SIZE][SIZE];\nbool is_prime[MAX_N+1];\nPii coord[MAX_N+1];\n\nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++)\n    if(is_prime[i])\n      for(int j=i*i; j<=MAX_N; j+=i)\n\tis_prime[j] = false;\n}\n\nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  int sz = 0;\n  \n  coord[sz++] = Pii(0, 0); // no use\n  cnt ++;\n  coord[sz++] = Pii(x, y); // cnt = 1\n  \n  fill(id[0], id[0]+SIZE*SIZE+1, -1);\n  \n  const int dx[] = {0,-1,0,1};\n  const int dy[] = {-1,0,1,0};\n  \n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt <= MAX_N) {\n    a += 2;\n    for(int turn=0; turn<4; turn++) {\n      for(int i=0; i<a; i++) {\n\tx += dx[turn], y += dy[turn];\n\tcoord[sz++] = Pii(x, y);\n\tid[y][x] = ++ cnt;\n      }\n    }\n    x++, y++;\n  }\n}\n\nint dp[MAX_N+1];\n\nint main() {\n  \n  Sieve();\n  MakeMap();\n  \n  int m, n;\n\n  while(cin >> m >> n && (m|n)) {\n    \n    fill(dp, dp+MAX_N+1, -1);\n    dp[n] = is_prime[n];\n    Pii ans(dp[n], n);\n    \n    queue<P> que;\n    que.push(P(dp[n], coord[n]));\n    while(!que.empty()) {\n      P now = que.front(); que.pop();\n      int tmpid = id[now.second.Y][now.second.X];\n      if(now.first < dp[tmpid]) continue;\n      \n      int noid = id[now.second.Y][now.second.X];\n      \n      for(int i=-1; i<=1; i++) {\n\tPii nex = MP(now.second.X+i, now.second.Y+1);\n\tif(nex.X < 0 || SIZE <= nex.X || nex.Y < 0 || SIZE <= nex.Y) continue;\n\tint neid = id[nex.Y][nex.X];\n\tif(neid <= m) {\n\t  if(dp[neid] < dp[noid] + is_prime[neid]) {\n\t    dp[neid] = dp[noid] + is_prime[neid];\n\t    if(is_prime[neid]) ans = max(ans, MP(dp[neid], neid));\n\t    que.push(P(dp[neid], nex));\n\t  }\n\t}\n      }\n\n    }\n    \n    if(ans.first == 0) cout << \"0 0\" << endl;\n    else cout << ans.first << ' ' << ans.second << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\nint b[3000][3000];\nint pi[1000000], pj[1000000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\n#define mp make_pair\ntypedef pair<int,int> pii;\n\nconst int M_MAX = 1000010;\nconst int N = 4000;\n\npii fill(vector<vector<int>> &maze, int x, int y, int dir, int k, int s) {\n  for (int i = 0; i < k; i++) {\n    maze[y + i * dy[dir]][x + i * dx[dir]] = s++;\n  }\n  return mp(x + k * dx[dir], y + k * dy[dir]);\n}\n\nvoid make(vector<vector<int>> &maze) {\n  pii now = mp(N / 2, N / 2);\n  int k = 1;\n  int num = 1;\n  while(num <= M_MAX) {\n    now = fill(maze, now.first, now.second, 0, k, num); num += k;\n    now = fill(maze, now.first, now.second, 1, k, num); num += k;\n    k++;\n    now = fill(maze, now.first, now.second, 2, k, num); num += k;\n    now = fill(maze, now.first, now.second, 3, k, num); num += k;\n    k++;\n  }\n}\n\nchar isprime[M_MAX];\n\nvoid era() {\n  for (int i = 0; i < M_MAX; i++) {\n    isprime[i] = 1;\n  }\n  isprime[0] = isprime[1] = 0;\n  for (int i = 2; i < M_MAX; i++) {\n    if (isprime[i]) {\n      for (int j = i + i; j < M_MAX; j += i) {\n        isprime[j] = 0;\n      }\n    }\n  }\n}\n\nvoid solve(vector<vector<int>> &maze, int m, int n) {\n  int sx, sy;\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      if (maze[i][j] == n) {\n        sx = j, sy = i;\n      }\n    }\n  }\n  vector<vector<int16_t>> dp(N, vector<int16_t>(N, -1));\n  dp[sy][sx] = isprime[maze[sy][sx]];\n  for (int i = 0; i < N - 1; i++) {\n    for (int j = 0; j < N; j++) {\n      if (maze[i][j] > m) continue;\n      if (dp[i][j] == -1) continue;\n      if (j >= 1) dp[i + 1][j - 1] = max(dp[i + 1][j - 1], (int16_t)(dp[i][j] + isprime[maze[i + 1][j - 1]]));\n      dp[i + 1][j] = max(dp[i + 1][j], (int16_t)(dp[i][j] + isprime[maze[i + 1][j]]));\n      if (j < N - 1) dp[i + 1][j + 1] = max(dp[i + 1][j + 1], (int16_t)(dp[i][j] + isprime[maze[i + 1][j + 1]]));\n    }\n  }\n  int ma = 0;\n  int ma_ind = 0;\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      if (maze[i][j] > m) continue;\n      if (ma <= dp[i][j] && isprime[maze[i][j]]) {\n        if (ma < dp[i][j]) {\n          ma = dp[i][j];\n          ma_ind = maze[i][j];\n        } else {\n          if (ma_ind < maze[i][j]) ma_ind = maze[i][j];\n        }\n      }\n    }\n  }\n  if (ma == 0) {\n    cout << \"0 0\" << endl;\n  } else {\n    cout << ma << \" \" << ma_ind << endl;\n  }\n}\n\nint main() {\n  vector<vector<int>> maze(N, vector<int>(N, 0));\n  make(maze);\n  era();\n\n  int n, m;\n  while(cin >> m >> n, m != 0) {\n    solve(maze, m, n);\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <fstream>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppi;\n\n\nconst int dy[]={0,-1,0,1};\nconst int dx[]={1,0,-1,0};\n\n\nbool isPrime[1000100];\nint prime[1000100];\n\nint p;\nvoid erats(){\n  for(int i=0;i<1000100;i++)\n    isPrime[i]=true;\n  p=0;\n  isPrime[0]=isPrime[1]=false;\n  for(int i=2;i<1000100;i++){\n    if(isPrime[i]){\n      prime[p++]=i;\n      for(int j=2*i;j<1000100;j+=i)\n        isPrime[j]=false;\n    }\n  }\n}\n\n\nint N,M;\nmap<pair<short,short> ,int> m;\nmap<int,pair<short,short> > idToPii;\npii dp[1000100];\n\npii dfs(int pos){\n  if(dp[pos].first>=0)return dp[pos];\n  pii res=pii(isPrime[pos],isPrime[pos]?pos:0);\n  for(int i=-1;i<=1;i++){\n    pii nxt=idToPii[pos];\n    nxt.first++;\n    nxt.second+=i;\n    if(m.count(nxt)&&m[nxt]<=M){\n      pii p=dfs(m[nxt]);\n      if(isPrime[pos])p.first++;\n      \n      if(res.first<p.first)res=p;\n      else if(res.first==p.first){\n        if(res.second<p.second)\n          res=p;\n      }\n    }\n  }\n  return dp[pos]=res;\n}\n\nint main(){\n  erats();\n  \n  int sum=1;\n  int pos=0;\n  pii now=pii(0,0);\n  m[now]=1;\n  idToPii[sum]=now;\n  sum++;\n  for(int i=1;;i++){\n    for(int j=0;j<2;j++){\n      // posの方向へiだけ進む\n      for(int k=0;k<i;k++){\n        now.first+=dy[pos];\n        now.second+=dx[pos];\n        m[now]=sum;\n        idToPii[sum]=now;\n        sum++;\n      }\n      pos=(pos+1)%4;\n    }\n    if(sum>=1000100)break;\n  }\n  while(cin>>M>>N&&(N|M)){\n    for(int i=0;i<=M;i++)\n      dp[i].first=dp[i].second=-1;\n    pii p=dfs(N);\n    cout<<p.first<<\" \"<<p.second<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint m, n;\nvector<vector<pair<bool, int> > > mp(1001, vector<pair<bool, int> >(1001, pair<bool, int>(false, 0)));\nvector<vector<P> > memo(1001, vector<P>(1001, P(-1, -1)));\nP dfs(P np) {\n\tif(memo[np.first][np.second].first != -1) {\n\t\treturn memo[np.first][np.second];\n\t}\n\tif(mp[np.first][np.second].second > m || np.first < 0 || np.first >= 1001 || np.second < 0 || np.second >= 1001) {\n\t\treturn P(0, 0);\n\t}\n\tP res;\n\tres = max(max(dfs(P(np.first + 1, np.second)), dfs(P(np.first + 1, np.second - 1))), dfs(P(np.first + 1, np.second + 1)));\n\tif(mp[np.first][np.second].first) {\n\t\treturn memo[np.first][np.second] = max(P(1, mp[np.first][np.second].second), P(res.first + 1, res.second));\n\t} else {\n\t\treturn memo[np.first][np.second] = max(P(0, mp[np.first][np.second].second), P(res.first, res.second));\n\t}\n}\n\nint main(void) {\n\tvector<bool> prime(1001 * 1001 + 1, true);\n\tprime[0] = prime[1] = false;\n\tFOR(i, 2, 1001 * 1001 + 1) {\n\t\tif(prime[i]) {\n\t\t\tfor(ll j = 2; i * j <= 1001 * 1001; ++j) {\n\t\t\t\tprime[i * j] = false;\n\t\t\t}\n\t\t}\n\t}\n\tP cp = P(500, 500);\n\tll cnt = 1;\n\tll size = 1;\n\tll lim = 1;\n\twhile(cnt <= 1001 * 1001) {\n\t\tmp[cp.first][cp.second].second = cnt;\n\t\tif(prime[cnt]) mp[cp.first][cp.second].first = true;\n\t\t--lim;\n\t\tif(lim == 0) {\n\t\t\tsize += 2;\n\t\t\t++cp.second;\n\t\t\tlim = size * size - (size - 2) * (size - 2);\n\t\t} else {\n\t\t\tif(lim >= 2 * (size - 1) + size) {\n\t\t\t\t--cp.first;\n\t\t\t} else if(lim >= (size - 1) + size) {\n\t\t\t\t--cp.second;\n\t\t\t} else if(lim >= size) {\n\t\t\t\t++cp.first;\n\t\t\t} else {\n\t\t\t\t++cp.second;\n\t\t\t}\n\t\t}\n\t\t++cnt;\n\t}\n\twhile(true) {\n\t\tcin>>m>>n;\n\t\tif(m == 0 && n == 0) break;\n\t\tP sp;\n\t\tbool upd = false;\n\t\tREP(i, 1001) {\n\t\t\tREP(j, 1001) {\n\t\t\t\tif(mp[i][j].second == n) {\n\t\t\t\t\tsp.first = i;\n\t\t\t\t\tsp.second = j;\n\t\t\t\t\tupd = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(upd) break;\n\t\t}\n\t\tREP(i, 1001) {\n\t\t\tREP(j, 1001) {\n\t\t\t\tmemo[i][j].first = memo[i][j].second = -1;\n\t\t\t}\n\t\t}\n\t\tP ans = dfs(sp);\n\t\tif(ans.first == 0) cout<<0<<\" \"<<0<<endl;\n\t\telse cout<<ans.first<<\" \"<<ans.second<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <assert.h>\n#include <queue>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\ntypedef pair<int,int> P;\ntypedef pair<int,P> Q;\ntypedef pair<double,Q> R;\n\nP pos[2000005];\nint m,n;\nint dp[1000005];\nbool pr[1000005];\nbool ex[4005][4005];\nint val[4005][4005];\n\nint main(){\n\tint dx[4]={0,-1,0,1};\n\tint dy[4]={1,0,-1,0};\n\tpos[1] = mp(2000,2000);\n\tint cur = 2;\n\tint d = 0;\n\tint len = 1;\n\tfor(int i=0;cur < 1100000;i++){\n\t\tfor(int j=0;j<len;j++){\n\t\t\tpos[cur] = pos[cur-1];\n\t\t\tpos[cur].fi += dx[d];\n\t\t\tpos[cur].sc += dy[d];\n\t\t\tcur ++;\n\t\t}\n\t\td = (d+1)%4;\n\t\tif(i%2 == 1) len++;\n\t}\n\tfor(int i=1;i<=1000000;i++) val[pos[i].fi][pos[i].sc] = i;\n\tpr[1] = 1;\n\tfor(int i=2;i<=1000000;i++){\n\t\tif(pr[i]) continue;\n\t\tfor(int j=2;j*i<=1000000;j++) pr[i*j] = 1;\n\t}\n\t\n\twhile(1){\n\t\tcin >> m >> n; if(m == 0) return 0;\n\t\trep(i,1000005) dp[i] = -1e9;\n\t\tfor(int i=1;i<=1000000;i++) ex[pos[i].fi][pos[i].sc] = 0;\n\t\tfor(int i=1;i<=m;i++) ex[pos[i].fi][pos[i].sc] = 1;\n\t\tdp[n] = 0;\n\t\tif(!pr[n]) dp[n] = 1;\n\t\tint x = pos[n].fi, y = pos[n].sc;\n\t\tfor(int i=x;i<=3005;i++){\n\t\t\tfor(int j=0;j<3005;j++){\n\t\t\t\tif(!ex[i][j]) continue;\n\t\t\t\tif(ex[i+1][j]){dp[val[i+1][j]] = max(dp[val[i+1][j]],dp[val[i][j]]+!pr[val[i+1][j]]);}\n\t\t\t\tif(j&&ex[i+1][j-1]){dp[val[i+1][j-1]] = max(dp[val[i+1][j-1]],dp[val[i][j]]+!pr[val[i+1][j-1]]);}\n\t\t\t\tif(ex[i+1][j+1]){dp[val[i+1][j+1]] = max(dp[val[i+1][j+1]],dp[val[i][j]]+!pr[val[i+1][j+1]]);}\n\t\t\t}\n\t\t}\n\t\tint ans1 = 0, ans2 = 0;\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tif(dp[i] > ans1){\n\t\t\t\tans1 = dp[i]; ans2 = i;\n\t\t\t}\n\t\t\telse if(dp[i] == ans1 && !pr[i]){ ans2 = max(ans2,i); }\n\t\t}\n\t\tif(ans1 == 0) puts(\"0 0\");\n\t\telse cout << ans1 << \" \" << ans2 << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\n#define MP make_pair\n#define PB push_back\n#define MAX_N 1001000\n#define SIZE 2010\n#define X first\n#define Y second\n\nconst int STX = 510, STY = 510;\n\nint id[SIZE][SIZE];\nbool is_prime[MAX_N+1];\nvector<pair<int, int> > coord;\n\nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++) {\n    if(is_prime[i]) {\n      for(int j=i*i; j<=MAX_N; j+=i) {\n\tis_prime[j] = false;\n      }\n    }\n  }\n}\n\nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  /*\n  const int dx[] = {1,0,-1,0};\n  const int dy[] = {0,-1,0,1};\n  */\n  coord.PB(MP(0, 0)); // no use\n  coord.PB(MP(x, y)); // cnt = 1\n  cnt ++;\n\n  fill(id[0], id[0]+SIZE*SIZE+1, -1);\n  \n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt <= MAX_N) {\n    a += 2;\n    for(int i=0; i<a; i++) {\n      y --;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      x --;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      y ++;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    for(int i=0; i<a; i++) {\n      x ++;\n      coord.PB(MP(x, y));\n      id[y][x] = ++ cnt;\n    }\n    x++, y++;\n  }\n}\n\nint dp[MAX_N+1];\n\nint main() {\n  \n  Sieve();\n  MakeMap();\n  \n  int m, n;\n  \n  while(cin >> m >> n && (m|n)) {\n    fill(dp, dp+m+1, -1);\n    dp[n] = is_prime[n];\n    \n    queue<pair<int, int> > que;\n    que.push(coord[n]);\n    \n    while(!que.empty()) {\n      pair<int, int> now = que.front(); que.pop();\n      int noid = id[now.Y][now.X];\n      \n      for(int i=-1; i<=1; i++) {\n\tpair<int, int> nex = MP(now.X+i, now.Y+1);\n\tif(nex.X < 0 || SIZE <= nex.X || nex.Y < 0 || SIZE <= nex.Y) continue;\n\tint neid = id[nex.Y][nex.X];\n\tif(neid <= m) {\n\t  if(dp[neid] < dp[noid] + is_prime[neid]) {\n\t    dp[neid] = dp[noid] + is_prime[neid];\n\t    que.push(nex);\n\t  }\n\t}\n      }\n    }\n    \n    int res = dp[n], lastid = -1;\n    if(is_prime[n]) lastid = n;\n    \n    for(int i=1; i<=m; i++) {\n      if(res <= dp[i] && is_prime[i]) {\n\tres = dp[i];\n\tlastid = max(lastid, i);\n      }\n    }\n    \n    if(lastid == -1) cout << \"0 0\" << endl;\n    else cout << res << \" \" << lastid << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\n#define SIZE 1000\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\t\t/*\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}*/\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}/*\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}*/\n\t\t\n\t\toutput = false;\n\t\tfor (int i = 0;i < SIZE&&(!output);i++) {\n\t\t\tfor (int j = 0;j < SIZE&&(!output);j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\t//printf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvoid solve(){\n    vector<bool> is_prime(1e6+1,true);\n    is_prime[0]=is_prime[1]=false;\n    rep(i,2,1e+6+1){\n        if(!is_prime[i]) continue;\n        for(int j=i*2; j<1e6+1; j+=i) is_prime[j]=false;\n    }\n    while(true){\n        int m,n;\n        cin >> m >> n;\n        if(m==0 and n==0) break;\n\n        map<pii,int> encode;\n        map<int,pii> decode;\n        map<int,vector<int>> xs;\n        {\n            int x=0,y=0,dir=3;\n            rep(i,1,m+1){\n                encode[make_pair(x,y)]=i;\n                decode[i]=make_pair(x,y);\n                xs[y].push_back(x);\n                int nx=x+dx[(dir+1)%4],ny=y+dy[(dir+1)%4];\n                if(encode.find(make_pair(nx,ny))==encode.end()) dir=(dir+1)%4;\n                else{\n                    nx=x+dx[dir];\n                    ny=y+dy[dir];\n                }\n                x=nx;\n                y=ny;\n            }\n        }\n\n        map<pii,int> dp;\n        int y=decode[n].second+1,ans,max_num;\n        if(is_prime[n]){\n            dp[decode[n]]=1;\n            ans=1;\n            max_num=n;\n        }else{\n            dp[decode[n]]=0;\n            ans=0;\n            max_num=0;\n        }\n        while(xs.find(y)!=xs.end()){\n            for(int x:xs[y]){\n                int tmp=-1;\n                if(dp.find(make_pair(x-1,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x-1,y-1)]);\n                if(dp.find(make_pair(x,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x,y-1)]);\n                if(dp.find(make_pair(x+1,y-1))!=dp.end()) tmp=max(tmp,dp[make_pair(x+1,y-1)]);\n                if(tmp==-1) continue;\n                if(is_prime[encode[make_pair(x,y)]]){\n                    ++tmp;\n                    if(tmp>ans){\n                        ans=tmp;\n                        max_num=encode[make_pair(x,y)];\n                    }else if(tmp==ans) max_num=max(max_num,encode[make_pair(x,y)]);\n                }\n                dp[make_pair(x,y)]=tmp;\n            }\n            ++y;\n        }\n\n        cout << ans << \" \" << max_num << endl;\n    }\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n\n#define MAX_M 1000000\n\nusing namespace std;\n\ntypedef struct\n{\n\tint num, prime, last;\n}HOLE;\n\nint M, N;\nHOLE h[1000+2][1000+2];\n\nbool prime_judge(int x){\n\tif(x == 0 || x == 1) return false;\n\tfor (int i = 2; i*i <= x; i++)\n\t{\n\t\tif(x % i == 0) return false;\n\t}\n\treturn true;\n}\n\nvoid solve(){\n\tint flag = 0, d = 1;//?????????????????????, ???????????¢\n\tint x = 501, y = 501, ox = 501, oy = 501;\n\tint ansx, ansy;\n\tfor (int i = 0; i < 1002; i++)\n\t{\n\t\tfor (int j = 0; j < 1002; j++)\n\t\t{\n\t\t\th[i][j].num = 0;\n\t\t\th[i][j].last = 0;\n\t\t\th[i][j].prime = 0;\n\t\t}\n\t}\n\tfor (int i = 1; i <= M; i++)\n\t{\n\t\th[x][y].num = i;\n\t\tif(i == N){\n\t\t\tansx = x;\n\t\t\tansy = y;\n\t\t}\n\t\tif(flag == 0){\n\t\t\tx++;\n\t\t\tif(x - ox == d){\n\t\t\t\tox = x;\n\t\t\t\tflag = 1;\n\t\t\t}\n\t\t}else if(flag == 1){\n\t\t\ty--;\n\t\t\tif(oy - y == d){\n\t\t\t\toy = y;\n\t\t\t\td++;\n\t\t\t\tflag = 2;\n\t\t\t}\n\t\t}else if(flag == 2){\n\t\t\tx--;\n\t\t\tif(ox - x == d){\n\t\t\t\tox = x;\n\t\t\t\tflag = 3;\n\t\t\t}\n\t\t}else if(flag == 3){\n\t\t\ty++;\n\t\t\tif(y - oy == d){\n\t\t\t\toy = y;\n\t\t\t\td++;\n\t\t\t\tflag = 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1001; i >= 0; i--)\n\t{\n\t\tfor (int j = 0; j < 1002; j++)\n\t\t{\n\t\t\tif(h[j][i].num != 0){\n\t\t\t\th[j][i].prime = max(max(h[j-1][i+1].prime, h[j][i+1].prime), h[j+1][i+1].prime);\n\t\t\t\tif(h[j-1][i+1].last == 0 && h[j][i+1].last == 0 && h[j+1][i+1].last == 0)\n\t\t\t\t{\n\t\t\t\t\tif(prime_judge(h[j][i].num)) h[j][i].last = h[j][i].num;\n\t\t\t\t}else{\n\t\t\t\t\tint k;\n\t\t\t\t\tfor (k = -1; k <= 1; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(h[j+k][i+1].prime == h[j][i].prime){\n\t\t\t\t\t\t\th[j][i].last = h[j+k][i+1].last;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int l = -1; l <= 1; l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(h[j+k][i+1].prime == h[j+l][i+1].prime){\n\t\t\t\t\t\t\th[j][i].last = max(h[j][i].last, h[j+l][i+1].last);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(prime_judge(h[j][i].num)) h[j][i].prime++;\n\t\t\t}\n\t\t}\n\t}\n\tif(h[ansx][ansy].prime == 0) cout << \"0 0\" << endl;\n\telse cout << h[ansx][ansy].prime << \" \" << h[ansx][ansy].last << endl;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> M >> N;\n\t\tif(M == 0 && N == 0) break;\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n//#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n//#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#include <array>\n//#include <atomic>\n#include <chrono>\n//#include <condition_variable>\n#include <forward_list>\n//#include <future>\n#include <initializer_list>\n//#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n//#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\n\nint main ()\n{\n\tint M , N;\n\tint ii[1000];\n\tfor( size_t i = 0; i < 1000; i++ )\n\t{\n\t\tii[i] = i*i;\n\t}\n\n\tint dx[] = { 1 , 0 , -1 , 0 };\n\tint dy[] = { 0 , -1 , 0 , 1 };\n\tvector<vector<int>>data ( 1e3 + 3 , vector<int> ( 1e3 + 5 ) );\n\t{\n\t\tint nowx = ( 1e3 / 2 ) + 1 , nowy = ( 1e3 / 2 ) + 1;\n\t\tint nowz = 3;\n\t\tfor( size_t i = 1; i < 1e6 + 10; i++ )\n\t\t{\n\t\t\tif( data[nowx + dx[( nowz + 1 ) % 4]][nowy + dy[( nowz + 1 ) % 4]] == 0 )\n\t\t\t{\n\t\t\t\tnowz = ( nowz + 1 ) % 4;\n\t\t\t}\n\t\t\tdata[nowx + dx[nowz]][nowy + dy[nowz]] = i;\n\n\t\t\tnowx = nowx + dx[nowz];\n\t\t\tnowy = nowy + dy[nowz];\n\t\t}\n\t}\n\tbool pri[(int) ( 1e6 + 2 )];\n\tpri[0] = 1;\n\tpri[1] = 1;\n\tfor( size_t i = 2; i < 1e6 + 2; i++ )\n\t{\n\t\tif( pri[i] == 0 )\n\t\t{\n\t\t\tfor( size_t j = 2; j*i < 1e6 + 2; j++ )\n\t\t\t{\n\t\t\t\tpri[i*j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\twhile( cin >> M >> N , M || N )\n\t{\n\t\tpair<int , int>S;\n\t\tint ans1 = 0 , ans2 = 0;;\n\t\t//vector<vector<int>>data2 ( 1e3 + 5 , vector<int> ( 1e3 + 5 , 0 ) );\n\t\tmap < int , map < int , int >>data2;\n\t\tfor( size_t i = 0; i < 1e3 + 5; i++ )\n\t\t{\n\t\t\tfor( size_t j = 0; j < 1e3 + 5; j++ )\n\t\t\t{\n\t\t\t\tif( data[i][j] == N )\n\t\t\t\t{\n\t\t\t\t\tS.first = i;\n\t\t\t\t\tS.second = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( S.first )\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tqueue<pair<int , int>>que;\n\t\tque.push ( S );\n\t\tif( !pri[data[S.first][S.second]] )\n\t\t{\n\t\t\tans1 = data[S.first][S.second];\n\t\t\tans2 = 1;\n\t\t\tdata2[S.first][S.second] = 1;\n\t\t}\n\t\twhile( que.size () )\n\t\t{\n\t\t\tpair<int , int>now = que.front (); que.pop ();\n\t\t\tint nowx = now.first;\n\t\t\tint nowy = now.second;\n\t\t\t//cout << data[nowx][nowy] << endl;\n\t\t\tfor( int i = 1; i >= -1; i-- )\n\t\t\t{\n\t\t\t\tif( data[nowx + 1][nowy + i] <= M )\n\t\t\t\t{\n\t\t\t\t\tif( !data2[nowx + 1][nowy + i] )que.push ( pair<int , int> ( nowx + 1 , nowy + i ) );\n\t\t\t\t\tif( !pri[data[nowx + 1][nowy + i]] )\n\t\t\t\t\t{\n\t\t\t\t\t\tif( data2[nowx + 1][nowy + i] < data2[nowx][nowy] + 1 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdata2[nowx + 1][nowy + i] = data2[nowx][nowy] + 1;\n\t\t\t\t\t\t\tif( ans2 <= data2[nowx + 1][nowy + i] )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif( ans2 == data2[nowx + 1][nowy + i] )\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tans1 = max(data[nowx + 1][nowy + i],ans1);\n\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tans1 = data[nowx + 1][nowy + i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tans2 = data2[nowx + 1][nowy + i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t{\n\t\t\t\t\t\tif( data2[nowx + 1][nowy + i] < data2[nowx][nowy] )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdata2[nowx + 1][nowy + i] = data2[nowx][nowy];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans2 << \" \" << ans1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_P = 1001000;\nconst int MAX_W = 1020;\nconst int dx[4] = {+1,  0, -1,  0};\nconst int dy[4] = { 0, -1,  0, +1};\n\n// is_p[n] := 正整数 n が素数かどうか\nchar is_p[MAX_P];\n// a[y][x] := (x,y) の洞穴の番号\nint a[MAX_W][MAX_W] = {0};\n// dp[y][x] := (x,y) にたどり着くまでの素数洞穴を調べた個数\nint dp[MAX_W][MAX_W];\n// X[k] := 洞穴の番号 k の x 座標 (Yも同様)\nint X[MAX_P];\nint Y[MAX_P];\n\nvoid init(){\n\t// エラトステネスの篩\n\tfill(is_p, is_p + MAX_P, 1);\n\tis_p[0] = is_p[1] = 0;\n\tfor(int i = 2; i < MAX_P; i++){\n\t\tif( is_p[i] ){\n\t\t\tfor(int j = i + i; j < MAX_P; j += i){\n\t\t\t\tis_p[j] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid make_douketu(int m){\n\tfor(int y = 0; y < MAX_W; y++){\n\t\tfor(int x = 0; x < MAX_W; x++){\n\t\t\ta[y][x] = 0;\n\t\t}\n\t}\n\tint k = 1, x = MAX_W / 2, y = MAX_W / 2, dir = 0, d = 2;\n\twhile( k < MAX_P ){\n\t\tfor(int i = 0; i < (d / 2); i++){\n\t\t\ta[y][x] = k;\n\t\t\tX[k] = x;\n\t\t\tY[k] = y;\n\t\t\tx += dx[dir];\n\t\t\ty += dy[dir];\n\t\t\tk++;\n\t\t\tif( m < k ) return;\n\t\t\tif( MAX_W <= x || MAX_W <= y ) break;\n\t\t}\n\t\tdir = (dir + 1) % 4;\n\t\td++;\n\t\tif( MAX_W <= x || MAX_W <= y ) break;\n\t}\n}\n\nint main(){\n\tinit();\n\tint n, m;\n\twhile( cin >> m >> n, n || m){\n\t\tmake_douketu(m);\n\t\tfor(int y = 0; y < MAX_W; y++){\n\t\t\tfor(int x = 0; x < MAX_W; x++){\n\t\t\t\tdp[y][x] = -1;\n\t\t\t}\n\t\t}\n\t\tint sx = X[n], sy = Y[n];\n\t\tdp[sy][sx] = is_p[n];\n\t\t\n\t\tint ans = 0;\n\t\tfor(int y = 0; y < MAX_W; y++){\n\t\t\tfor(int x = 0; x < MAX_W; x++){\n\t\t\t\tans = max(ans, dp[y][x]);\n\t\t\t\tif( a[y][x] == 0 ) continue;\n\t\t\t\t\n\t\t\t\tif( dp[y][x] != -1 ){\n\t\t\t\t\tint my = y + 1;\n\t\t\t\t\tif( MAX_W <= my ) continue;\n\t\t\t\t\t\n\t\t\t\t\tint d[3] = {-1,0,1};\n\t\t\t\t\tfor(int i = 0; i < 3; i++){\n\t\t\t\t\t\tint mx = x + d[i];\n\t\t\t\t\t\tif( mx < 0 || MAX_W <= mx ) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tint k = a[my][mx];\n\t\t\t\t\t\tif( k == 0 ) continue;\n\t\t\t\t\t\tdp[my][mx] = max(dp[my][mx], dp[y][x] + is_p[k]);\n\t\t\t\t\t\tans = max(ans, dp[my][mx]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif( ans == 0 ){\n\t\t\tcout << \"0 0\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tint ans_n = 0;\n\t\tfor(int y = 0; y < MAX_W; y++){\n\t\t\tfor(int x = 0; x < MAX_W; x++){\n\t\t\t\tif( a[y][x] == 0 ) continue;\n\t\t\t\tif( dp[y][x] == ans ){\n\t\t\t\t\tint k = a[y][x];\n\t\t\t\t\tif( is_p[k] ){\n\t\t\t\t\t\tans_n = max(ans_n, a[y][x]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << \" \" << ans_n << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <utility>\n#include <cmath>\n\nconst int MAXN = 1000010;\n//const int MAXN = 50;\nconst int WH = 2*sqrt(MAXN) + 2;\nusing namespace std;\n\nvector<bool> sieve(const int M){\n    vector<bool> is_prime(M);\n    for(int i=2;i<M;i++) is_prime[i] = true;\n    for(int i=2;i*i<M;i++){\n        if(not is_prime[i]) continue;\n        for(int j=i*i;j<M;j+=i){\n            is_prime[j] = false;\n        }\n    }\n    return is_prime;\n}\n\nconst vector<bool> is_prime = sieve(MAXN);\n\n// N,last\npair<int,int> solve(const vector<vector<int>>& field,int m,\n                    int cy,int cx,vector<vector<pair<int,int>>>& memo){\n    if(memo[cy][cx].first != -1){\n        return memo[cy][cx];\n    }\n    pair<int,int> ret = make_pair(-1,-1);\n    for(int i=-1;i<=1;i++){\n        int wy = cy + 1;\n        int wx = cx + i;\n        if(field[wy][wx] > m) continue;\n        pair<int,int> p = solve(field,m,wy,wx,memo);\n        ret = max(ret,p);\n    }\n    if(ret.first == -1){\n        if(is_prime[field[cy][cx]]){\n            return memo[cy][cx] = make_pair(1,field[cy][cx]);\n        }else{\n            return memo[cy][cx] = make_pair(0,0);\n        }\n\n    }else{\n        if(ret.first == 0){\n            if(is_prime[field[cy][cx]]){\n                return memo[cy][cx] = make_pair(1,field[cy][cx]);\n            }else{\n                return memo[cy][cx] = make_pair(0,0);\n            }\n        }else{\n            if(is_prime[field[cy][cx]]){\n                return memo[cy][cx] = make_pair(ret.first+1,ret.second);\n            }else{\n                return memo[cy][cx] = ret;\n            }\n        }\n    }\n}\n\nint main(){\n    vector<vector<int>> field(WH,vector<int>(WH,MAXN + 100));\n//    field[cy+0][cx+1] = 2;\n//    field[cy-1][cx+1] = 3;\n//    field[cy-1][cx+0] = 4;\n//    field[cy-1][cx-1] = 5;\n//    field[cy+0][cx-1] = 6;\n//    field[cy+1][cx-1] = 7;\n//    field[cy+1][cx+0] = 8;\n//    field[cy+1][cx+1] = 9;\n    {\n        int cx=WH/2,cy=WH/2;\n        field[cy][cx] = 1;\n        int c = 2;\n        for(int i=0;;i++){\n            int sx = cx + i+1;\n            int sy = cy + i;\n            for(int j=0;j<2*i+2;j++){\n                field[sy-j][sx] = c;\n                c++;\n                if(c >= MAXN) goto end;\n            }\n            vector<int> dx = {-1,0,1};\n            vector<int> dy = {0,1,0};\n            // left\n            int ny = sy-2*i-1;\n            int nx = sx;\n            for(int k=0;k<3;k++){\n                for(int j=0;j<2*(i+1);j++){\n                    ny = ny + dy[k];\n                    nx = nx + dx[k];\n                    field[ny][nx] = c;\n                    c++;\n                    //cerr << c << \" \" << hy << \" \" << hy << endl;\n                    if(c >= MAXN) goto end;\n                }\n            }\n        }\nend:;\n    }\n//    for(int i=0;i<WH;i++){\n//        for(int j=0;j<WH;j++){\n//            cout << setw(3) << field[i][j] << \" \";\n//        }\n//        cout << endl;\n//    }\n//    for(int i=0;i<MAXN;i++){\n//        cout << i << \" \" << is_prime[i] << endl;\n//    }\n//\n    while(true){\n        int m,n;\n        cin >> m >> n;\n        if(m == 0 and n == 0) break;\n        vector<vector<pair<int,int>>> memo(WH,vector<pair<int,int>>(WH,make_pair(-1,-1)));\n        int sx = -1,sy = -1;\n        for(int i=0;i<WH;i++){\n            for(int j=0;j<WH;j++){\n                if(field[i][j] == n){\n                    sy = i;\n                    sx = j;\n                }\n            }\n        }\n        pair<int,int> ret = solve(field,m,sy,sx,memo);\n        cout << ret.first << \" \" << ret.second << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n\nconst int MAXN = 2001024;\n\n// 結果を格納する変数\nint prime[MAXN]; // n 以下の素数のうち i 番目の素数\nbool is_prime[MAXN]; // 整数 i が素数であるかどうか\n\nint sieve(int n) {\n    int res = 0;\n    fill(is_prime, is_prime + MAXN, true);\n    is_prime[0] = is_prime[1] = false; // 0 と 1 は素数ではない。\n    for(int i = 2; i <= n; ++i) {\n        if(!is_prime[i]) continue;\n        prime[res++] = i;\n        for(int j = 2 * i; j <= n; j += i) is_prime[j] = false; // 素数 i の倍数は素数ではない (ふるい(篩)にかける)\n    }\n    return res;\n}\n\nsigned main(){\n    \n    sieve(MAXN - 1);\n    vector<vector<int> > g(2000, vector<int> (2000));\n    vector<pair<int, int> > toC(2000 * 2000);\n    int delta = 1000;\n    int num = 2;\n    int i = 0;\n    int j = 0;\n    g[i + delta][j + delta] = 1;\n    toC[1] = {i + delta, j + delta};\n    int step = 1;\n    int max_i = 0;\n    int max_j = 0;\n    int min_i = 0;\n    int min_j = 0;\n    \n    while(num <= 2000000){\n        \n        // 右に step\n        for(int h = 0; h < step; h++){\n            j++;\n            g[i + delta][j + delta] = num;\n            toC[num] = {i + delta, j + delta};\n            num++;\n            min_j = min(min_j, j);\n            max_j = max(max_j, j);\n        }\n\n        // 上に step\n        for(int h = 0; h < step; h++){\n            i--;\n            g[i + delta][j + delta] = num;\n            toC[num] = {i + delta, j + delta};\n            num++;\n            min_i = min(min_i, i);\n            max_i = max(max_i, i);\n        }\n\n        step++;\n\n        // 左に step\n        for(int h = 0; h < step; h++){\n            j--;\n            g[i + delta][j + delta] = num;\n            toC[num] = {i + delta, j + delta};\n            num++;\n            min_j = min(min_j, j);\n            max_j = max(max_j, j);\n        }\n\n        // 下に step\n        for(int h = 0; h < step; h++){\n            i++;\n            g[i + delta][j + delta] = num;\n            toC[num] = {i + delta, j + delta};\n            num++;\n            min_i = min(min_i, i);\n            max_i = max(max_i, i);\n        }\n        step++;\n    }\n    \n    while(1){\n        \n        int m, n; cin >> m >> n;\n        if(m == 0 && n == 0) break;\n\n        int si = toC[n].first;\n        int sj = toC[n].second;\n        \n        vector<vector<int> > dp(2000, vector<int> (2000, -1));\n        dp[si][sj] = is_prime[n];\n        \n        int ans = 0;\n        int ansval = 0;\n\n        for(int i = 0; i < 1999; i++){\n            for(int j = 1; j < 1998; j++){\n                \n                if(dp[i][j] == -1) continue;\n                int val = g[i][j];\n                if(val > m) continue;\n                if((ans < dp[i][j] || (ans == dp[i][j] && ansval < val)) && is_prime[val]){\n                    ans = dp[i][j];\n                    ansval = val;\n                }\n\n                int ni = i + 1;\n                for(int h = -1; h <= 1; h++){\n                    int nj = j + h;\n                    int nnum = g[ni][nj];\n                    dp[ni][nj] = max(dp[ni][nj], dp[i][j] + is_prime[nnum]);\n                }\n            }\n        }\n        \n        /*\n        for(int i = -3; i <= 3; i++){\n            for(int j = -3; j <= 3; j++){\n                cerr << dp[i + delta][j + delta] << \" \";\n            }\n            cerr << endl;\n        }\n        \n        */\n        \n        cout << ans << \" \" << ansval << endl;\n    \n    }   \n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#define rep(i,n) for(lint (i) = 0;(i) < (n);(i)++)\n#define INF (1000000+5)\n#define SZ 1010\n#define BS 505\n#define MAX(a,b) (a)<(b)?(b):(a)\nusing namespace std;\ntypedef long long int lint;\nint go[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nint dw[3][2]={{1,-1},{1,0},{1,1}};\n\nint site[1000000+5][2];\nint prime[1000000+5];\nlint mp[SZ][SZ]={0};\n\nint main(){\n    int m,n;\n    rep(i,1000000+5){\n        prime[i]=-1;\n    }\n    prime[0]=0;\n    prime[1]=0;\n    int now = 2;\n    while(now<1000000+5){\n        if(prime[now]==0){\n            now++;\n            continue;\n        }\n        prime[now]=1;\n        lint temp = now*2;\n        while(temp<1000000+5){\n            prime[temp]=0;\n            temp+=now;\n        }\n        now++;\n    }\n    prime[1]=0;\n    rep(i,SZ){\n        rep(j,SZ){\n            mp[i][j]=INF;\n        }\n    }\n    int at[2]={BS,BS};\n    int dir=0;\n    for(int i = 1;i <= 1000000+6;i++){\n        mp[at[0]][at[1]]=i;\n        site[i][0]=at[0];\n        site[i][1]=at[1];\n        int ndir = (dir + 1)%4;\n        if(mp[at[0]+go[ndir][0]][at[1]+go[ndir][1]]==INF){at[0]+=go[ndir][0];at[1]+=go[ndir][1];dir = ndir;}\n        else{\n            at[0]+=go[dir][0];\n            at[1]+=go[dir][1];\n        }\n    }\n    prime[1]=0;\n    while(cin>>m>>n&&m){\n        int dp[SZ][SZ];\n        rep(i,SZ){\n            rep(j,SZ){\n                dp[i][j]=-1;\n            }\n        }\n        \n        dp[site[n][0]][site[n][1]]=prime[n];\n        for(int i=0;i<SZ-1;i++){\n            for(int j=1;j<SZ-1;j++){\n                rep(k,3){\n                    int hoge[2] = {i+dw[k][0],j+dw[k][1]};\n                    if(mp[i][j]<=m&&mp[hoge[0]][hoge[1]]<=m&&dp[i][j]!=-1){\n                        dp[hoge[0]][hoge[1]]=MAX(dp[hoge[0]][hoge[1]],dp[i][j]+prime[mp[hoge[0]][hoge[1]]]);\n                    }\n                }\n            }\n        }/*\n          for(int x = -10;x < 10;x++){\n          for(int y = -10;y < 10;y++){\n          printf(\"%5d\", dp[BS+x][BS+y]);\n          }\n          cout << endl;\n          }\n          for(int x = -10;x < 10;x++){\n          for(int y = -10;y < 10;y++){\n          printf(\"%5d\", prime[mp[BS+x][BS+y]]);\n          }\n          cout << endl;\n          }\n          for(int x = -10;x < 10;x++){\n          for(int y = -10;y < 10;y++){\n          printf(\"%ll\", mp[BS+x][BS+y]);\n          }\n          cout << endl;\n          }*/\n        \n        lint retp = 0;\n        lint ret = 0;\n        for(int i = SZ-1;i >= 0;i--){\n            \n            rep(j,SZ){\n                if(ret<dp[i][j]){\n                    ret = dp[i][j];\n                    retp = mp[i][j];\n                }\n            }\n            if(ret != 0){\n                break;\n            }\n        }\n        cout << ret <<  \" \" << retp << endl;\n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint numb;\nvoid setsp(int h,int w,int turn,int n,vector<vector<int>> &sp){\n    for(int i=0;i<turn+2;i++){\n        if(numb>n) return;\n        sp[h][w]=numb;\n        numb++;\n        w++;\n    }\n    w--;\n    h--;\n    for(int i=0;i<turn*2+1;i++){\n        if(numb>n) return;\n        sp[h][w]=numb;\n        numb++;\n        h--;\n    }\n    h++;\n    w--;\n    for(int i=0;i<turn*2+2;i++){\n        if(numb>n) return;\n        sp[h][w]=numb;\n        numb++;\n        w--;\n    }\n    w++;\n    h++;\n    for(int i=0;i<turn*2+2;i++){\n        if(numb>n) return;\n        sp[h][w]=numb;\n        numb++;\n        h++;\n    }\n    h--;\n    w++;\n    for(int i=0;i<turn;i++){\n        if(numb>n) return;\n        sp[h][w]=numb;\n        numb++;\n        w++;\n    }\n    \n    setsp(h,w,turn+1,n,sp);\n}\nvector<int> isPrime;\nvoid setPrime(){\n    isPrime.assign(1e6+1,1);\n    isPrime[0]=isPrime[1]=false;\n    for(int i=2;i<isPrime.size();i++){\n        if(isPrime[i]){\n            for(int j=i*2;j<isPrime.size();j+=i){\n                isPrime[j]=false;\n            }\n        }\n    }\n}\n\npair<int,int> merge(pair<int,int> val,int num){\n    if(num>0 && isPrime[num]){\n        return {val.first+1,num};\n    }\n    return val;\n}\nint main(){\n    int n,m;\n    setPrime();\n    while(cin>>n>>m,n){\n        const int SIZE=1200;\n        vector<vector<int>> sp(SIZE,vector<int>(SIZE,-1));\n        numb=1;\n        setsp(SIZE/2,SIZE/2,0,n,sp);\n        \n        const int INF=1e9;\n        vector<vector<pair<int,int>>> dp(SIZE,vector<pair<int,int>>(SIZE,{-INF,INF}));\n        int h,w;\n        for(int i=0;i<sp.size();i++){\n            for(int j=0;j<sp[i].size();j++){\n                if(sp[i][j]==m){\n                    h=i,w=j;\n                }\n            }\n        }\n        dp[h][w]={isPrime[m],isPrime[m] ? m : 0};\n        for(int i=0;i<sp.size()-1;i++){\n            for(int j=0;j<sp[i].size();j++){\n                if(j>0) dp[i+1][j-1]=max(dp[i+1][j-1],merge(dp[i][j],sp[i+1][j-1]));\n                dp[i+1][j]=max(dp[i+1][j],merge(dp[i][j],sp[i+1][j]));\n                if(j<sp[i].size()-1) dp[i+1][j+1]=max(dp[i+1][j+1],merge(dp[i][j],sp[i+1][j+1]));\n            }\n        }   \n        pair<int,int> res=dp[0][0];     \n        for(int i=0;i<sp.size();i++){\n            res=max(res,*max_element(dp[i].begin(),dp[i].end()));\n        }\n        cout<<res.first<<\" \"<<res.second<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <unordered_map>\n\n#define MOD7 1000000007\n#define MOD9 1000000009\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define REP(i, a, n) for (int i = (a); i <= (n); i++)\n#define all(a) (a).begin(), (a).end()\n\nusing namespace std;\n\nint dx[4] = { 0, -1, 0, 1 };\nint dy[4] = { -1, 0, 1, 0 };\n\nint nextInt() {int a; cin >> a; return a;}\nchar nextChar() {char a; cin >> a; return a;}\ndouble nextDouble() {double a; cin >> a; return a;}\nstring nextString() {string a; cin >> a; return a;}\n\nvoid inputVector(vector<int> &v, int &n) {rep(i,n){v.push_back(nextInt());}}\nvoid inputVector(vector<double> &v, int &n) {rep(i,n){v.push_back(nextDouble());}}\nvoid inputVector(vector<string> &v, int &n) {rep(i,n){v.push_back(nextString());}}\n\nconst int GETA = 502;\n\nbool isprime[1000010];\npair<int, int> dp[1004][1004];\n\nmap<int, pair<int, int>> map1;\nmap<pair<int, int>, int> map2;\n\npair<int, int> solve(int n, int m) {\n    if (n > m) return make_pair(0, 0);\n\n    pair<int, int> &pos = map1[n];\n    if (dp[pos.first][pos.second].first != -1) return dp[pos.first][pos.second];\n\n    pair<int, int> ret = make_pair(0, 0);\n    REP(i, -1, 1) {\n\tpair<int, int> nt = make_pair(pos.first + i, pos.second + 1);\n\tif (map2.find(nt) == map2.end()) continue;\n\tpair<int, int> res = solve(map2[nt], m);\n\tif (res.first > ret.first\n\t\t|| (res.first == ret.first && res.second > ret.second)) {\n\t    ret = res;\n\t}\n    }\n    if (isprime[n]) {\n\tret.first++;\n\tif (ret.first == 1) {\n\t    ret.second = n;\n\t}\n    }\n    dp[pos.first][pos.second] = ret;\n    return ret;\n}\n\nsigned main() {\n    rep(i, 1000001) isprime[i] = true;\n    isprime[1] = false;\n    REP(i, 2, 1000000) {\n\tif (!isprime[i]) continue;\n\tfor (int j = 2 * i; j <= 1000000; j += i) {\n\t    isprime[j] = false;\n\t}\n    }\n\n    int x = GETA, y = GETA;\n    int dir;\n    int size = 1;\n    int left;\n    for (int pt = 1; pt <= 1000000; pt++) {\n\tpair<int, int> pr = make_pair(x, y);\n\tmap1[pt] = pr;\n\tmap2[pr] = pt;\n\tif (pt == size * size) {\n\t    x++;\n\t    size += 2;\n\t    dir = 0;\n\t    left = size - 2;\n\t} else {\n\t    x += dx[dir];\n\t    y += dy[dir];\n\t    left--;\n\t    if (left == 0) {\n\t\tdir++;\n\t\tleft = size - 1;\n\t    }\n\t}\n    }\n\n    int m, n;\n    while (cin >> m >> n) {\n\tif (m == 0) break;\n\n\tREP(i, 1, m) {\n\t    pair<int, int> &pr = map1[i];\n\t    dp[pr.first][pr.second] = make_pair(-1, 0);\n\t}\n\n\tpair<int, int> ret = solve(n, m);\n\n\tcout << ret.first << ' ' << ret.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n/*\n#define bool int\n#define false 0\n#define true 1\n*/\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint n,m;\nint board[1111][1111];\nbool is_prime[1111111];\n\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\n\nP mem[1111][1111];\n\nP dfs(int x,int y){\n\tif(mem[x][y]!=P(-1,-1))return mem[x][y];\n\tP res=P(0,0);\n\trepl(xx,x-1,x+2){\n\t\tif(xx>=0&&xx<1111&&y+1>=0&&y+1<1111&&board[xx][y+1]!=0&&board[xx][y+1]<=m)maxch(res,dfs(xx,y+1));\n\t}\n\tif(is_prime[board[x][y]]){\n\t\tres.fi++;\n\t\tif(res.se==0)res.se=board[x][y];\n\t}\n\treturn mem[x][y]=res;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tmemset(is_prime,1,sizeof(is_prime));\n\tis_prime[0]=is_prime[1]=false;\n\trep(i,1111111){\n\t\tif(is_prime[i]){\n\t\t\tfor(int j=i*2;j<1111111;j+=i)is_prime[j]=false;\n\t\t}\n\t}\n\tint num=1;\n\tint x=1111/2,y=1111/2;\n\tint len=1,state=0;\n\twhile(1){\n\t\trep(i,2){\n\t\t\trep(j,len){\n\t\t\t\tboard[x][y]=num++;\n\t\t\t\tx+=dx[state];y+=dy[state];\n\t\t\t}\n\t\t\tstate=(state+1)%4;\n\t\t}\n\t\tif(num>1000000)break;\n\t\tlen++;\n\t}\n\twhile(1){\n\t\tcin>>m>>n;\n\t\tif(n==0)break;\n\t\tint sx,sy;\n\t\trep(i,1111)rep(j,1111){\n\t\t\tif(board[i][j]==n){\n\t\t\t\tsx=i;sy=j;\n\t\t\t}\n\t\t}\n\t\trep(i,1111)rep(j,1111)mem[i][j]=P(-1,-1);\n\t\tP res=dfs(sx,sy);\n\t\tcout<<res.fi<<\" \"<<res.se<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n\n#define M 1000000\n#define INF 1000000000\n\n#define MAX 1100\n\nbool isnp[M + 10] = {true, true};\nint hl[MAX][MAX];\npii tbl[M + 10];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nint main(){\n\tfor(int i = 2; i * i <= M; ++i){\n\t\tif(!isnp[i]){\n\t\t\tfor(int j = i * i; j <= M; j += i){\n\t\t\t\tisnp[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tint y = MAX / 2, x = MAX / 2;\n\tint k = 1;\n\tint d = 0;\n\tint c = 1;\n\tint z = 1;\n\tint my = 0;\n\twhile(k <= M){\n\t\thl[y][x] = k;\n\t\ttbl[k] = pii(y, x);\n\t\ty += dy[d];\n\t\tx += dx[d];\n\t\tif(!--c){\n\t\t\td = (d + 1) % 4;\n\t\t\tif(d % 2 == 0){\n\t\t\t\t++z;\n\t\t\t}\n\t\t\tc = z;\n\t\t}\n\t\t++k;\n\t\tmy = max(my, y);\n\t}\n\n\tvector<pii> def(MAX, pii(-INF, -INF));\n\n\tint m, n;\n\twhile(scanf(\"%d%d\", &m, &n), m){\n\t\ty = tbl[n].first;\n\t\tx = tbl[n].second;\n\t\t\n\t\tvector<pii> v1 = def;\n\t\tif(isnp[n]){\n\t\t\tv1[x] = pii(0, 0);\n\t\t}\n\t\telse{\n\t\t\tv1[x] = pii(1, n);\n\t\t}\n\n\t\tpii ans = v1[x];\n\t\twhile(y < my){\n\t\t\tvector<pii> v2 = def;\n\t\t\tint ny = y + 1;\n\t\t\tfor(int x = 0; x < MAX; ++x){\n\t\t\t\tif(!hl[y][x] || hl[y][x] > m) continue;\n\t\t\t\tfor(int d = -1; d <= 1; ++d){\n\t\t\t\t\tint nx = x + d;\n\t\t\t\t\tif(!hl[ny][nx] || hl[ny][nx] > m) continue;\n\t\t\t\t\tpii tmp = v1[x];\n\t\t\t\t\tif(!isnp[hl[ny][nx]]){\n\t\t\t\t\t\ttmp = pii(tmp.first + 1, hl[ny][nx]);\n\t\t\t\t\t}\n\t\t\t\t\tv2[nx] = max(v2[nx], tmp);\n\t\t\t\t\tans = max(ans, v2[nx]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tv1.swap(v2);\n\t\t\t++y;\n\t\t}\n\n\t\tprintf(\"%d %d\\n\", ans.first, ans.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS; typedef istringstream ISS;\ntypedef long long LL;\ntypedef pair<int, int> PII;  typedef pair<LL, LL> PLL;\ntypedef vector<int>    VI;   typedef vector<VI>   VVI;   typedef vector<VVI>   VVVI;\ntypedef vector<LL>     VLL;  typedef vector<VLL>  VVLL;  typedef vector<VVLL>  VVVLL;\ntypedef vector<double> VD;   typedef vector<VD>   VVD;   typedef vector<VVD>   VVVD;\ntypedef vector<string> VS;   typedef vector<VS>   VVS;   typedef vector<VVS>   VVVS;\ntypedef vector<bool>   VB;   typedef vector<VB>   VVB;   typedef vector<VVB>   VVVB;\ntypedef vector<PII>    VPII; typedef vector<VPII> VVPII; typedef vector<VVPII> VVVPII;\ntypedef vector<PLL>    VPLL; typedef vector<VPLL> VVPLL; typedef vector<VVPLL> VVVPLL;\n\ntypedef unsigned int  UI;\ntypedef vector<UI>    VUI;\ntypedef vector<VUI>   VVUI;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x)  (x).begin(),(x).end()\n#define RALL(x) (x).rbegin(),(x).rend()\n#define RANGEBOX(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define RANGE(x, l, r) ((l) <= (x) && (x) <= (r))\n#define rep(i, N)  for (int i = 0; i < (int)(N); i++)\n#define rrep(i, N) for (int i = N - 1; i >= 0; i--)\n#define REP(i, init, N)  for (int i = (init); i < (int)(N); i++)\n#define RREP(i, N, last) for (int i = (init - 1); i >= last; i--)\n#define MAXUD(orig, target) orig = max(orig, target)\n#define MINUD(orig, target) orig = min(orig, target)\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a)   { OSS oss; oss << a; return oss.str(); };\n\ntemplate<typename T=int> inline void dump(vector<T> vs, bool ent=false) { rep(i, vs.size()) cout << vs[i] << (i+1==vs.size() ? '\\n' : ' '); if (ent) cout << endl; }\ntemplate<typename T = int> inline void dump(vector<vector<T>> vs, bool ent = false) { rep(i, vs.size()) dump<T>(vs[i]); if (ent) cout << endl; }\n\nconst int    INF  = 0x3f3f3f3f;\nconst LL     INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int    DX[] = {1,  0, -1, 0};\nconst int    DY[] = {0, -1,  0, 1};\nconst double EPS  = 1e-12;\n// const double PI   = acos(-1.0);\n// lambda: [](T1 x)->T2{return y;}\n// simple lambda: [](T x){return x;}\n\nVB prime;\n// O(sqrt(n) * n)\nvoid initprime(LL num) {\n\tprime = VB(num + 1, true);\n\tprime[1] = prime[0] = false;\n\tfor (LL i = 2; i * i <= num; i++) {\n\t\tif (prime[i]) {\n\t\t\tfor (LL j = i + i; j <= num; j += i) {\n\t\t\t\tprime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst int MAX_M = 1000010;\nconst int HW = 1010;\nconst int OFFSET = 505;\nVVI ts = VVI(HW, VI(HW));\nVPII toIdx(MAX_M);\nint M, N;\n\nvoid gen_ts() {\n    int dir = 0;\n    int x = OFFSET, y = OFFSET;\n    int idx = 1;\n    int cnt = 1;\n    ts[y][x] = 1;\n    while (true) {\n        rep(i, 2) {\n            rep(j, cnt) {\n                ++idx;\n                if (idx > MAX_M){ return; }\n                x += DX[dir];\n                y += DY[dir];\n                ts[y][x] = idx;\n                toIdx[idx] = MP(y, x);\n            }\n            dir = (dir + 1) % 4;\n\n        }\n        ++cnt;\n    }\n}\n\nVVPII memo(HW, VPII(HW));\n\nPII dfs(PII p) {\n    int x = p.snd;\n    int y = p.fst;\n    if (memo[y][x].fst) return memo[y][x];\n\n    int num = ts[y][x];\n    bool is_b = prime[num];\n    PII res(is_b ? 1 : 0, is_b ? num : 0);\n    rep(i, 3) {\n        int nx = x + (i - 1);\n        int ny = y + 1;\n        int nnum = ts[ny][nx];\n        if (nnum != 0 && nnum <= M) {\n            PII tmp = dfs(MP(ny, nx));\n            tmp.fst += is_b;\n            res = max(res, tmp);\n        }\n    }\n\n    return memo[y][x] = res;\n}\n\n// price, num\nPII solve() {\n    memo = VVPII(HW, VPII(HW));\n    PII start = toIdx[N];\n    PII res = dfs(start);\n    return res;\n}\n\nint main(void) {\n    initprime(1000010);\n    gen_ts();\n\n    while (cin >> M >> N, M) {\n        PII x = solve();\n        cout << x.fst << \" \" << x.snd << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\npair<int, int> dp[1000001]; // scroll, last cave\nint isVisited[1000001];\nbool pcheck[1000001];\n\nint n, m;\nint caseN;\n\nvector <int> sqr;\n\nint arr[2000][2000];\nint hash[1000001][2];\n\nvector <int> getNext(int tar)\n{\n\tvector <int> ret;\n\tint y = hash[tar][0], x = hash[tar][1];\n\tret.push_back(arr[y - 1][x - 1]);\n\tret.push_back(arr[y - 1][x]);\n\tret.push_back(arr[y - 1][x + 1]);\n\treturn ret;\n}\n\npair<int, int> getAns(int ith)\n{\n\tif(ith > m || ith == 0) return make_pair(0, 0);\n\tpair<int, int> &ret = dp[ith];\n\tif(isVisited[ith] == caseN) return ret;\n\tisVisited[ith] = caseN;\n\n\tbool flag = (pcheck[ith] == false);\n\n\tif(flag) ret = make_pair(1, ith);\n\telse ret = make_pair(0, 0);\n\t\n\tvector <int> next = getNext(ith);\n\tfor(int i=0;i<next.size();i++)\n\t{\n\t\tpair<int, int> res = getAns(next[i]);\n\t\tif(ret.first < res.first + flag)\n\t\t{\n\t\t\tret = res;\n\t\t\tret.first += flag;\n\t\t}\n\t\telse if (ret.first == res.first + flag) ret.second = max(ret.second, res.second);\n\t}\n\n\treturn ret;\t\t\n}\n\nint main(void)\n{\n\tpcheck[1] = true;\n\tfor(int i=2;i<=1000000;i++)\n\t{\n\t\tif(pcheck[i]) continue;\n\t\tfor(int j=i*2;j<=1000000;j+=i) pcheck[j] = true;\n\t}\n\n\tfor(int i=1;i*i<=1000000;i+=2) sqr.push_back(i*i);\n\n\tint y = 1000, x = 1000;\n\tarr[y][x] = 1;\n\thash[1][0] = y, hash[1][1] = x;\n\tint cur = 2;\n\tint len = 3;\n\tx++;\n\tint mov[4][2] = {{1, 0}, {0, -1}, {-1, 0}, {0, 1}};\n\tdo\n\t{\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tfor(int j=0;j<len-1;j++) \n\t\t\t{ \n\t\t\t\thash[cur][0] = y, hash[cur][1] = x; \n\t\t\t\tarr[y][x] = cur++;\n\t\t\t\ty += mov[i][0];\n\t\t\t\tx += mov[i][1];\n\n\t\t\t}\n\t\t\t\n\t\t\tif(i < 3)\n\t\t\t{\n\t\t\t\ty -= mov[i][0], x -= mov[i][1];\n\t\t\t\ty += mov[i + 1][0], x += mov[i + 1][1];\n\t\t\t}\n\t\t}\n\t\tlen += 2;\n\t} while(cur <= 1000000);\n\n\twhile(scanf(\"%d %d\", &m, &n), n)\n\t{\n\t\tcaseN++;\n\t\tpair <int, int> ans = getAns(n);\n\t\tprintf(\"%d %d\\n\", ans.first, ans.second);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n//--\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = Y-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nint primes[1123456];\nint maps[1123][1123];\npii num[1123456];\npii dp[1123][1123];\n\nint main(){\n  int i,j,k,m,n,dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n  fill(primes+2,primes+1123456,1);\n  for(i=2;i<1120000;i++)\n    if(primes[i])\n      for(j=i*2;j<1120000;j+=i)\n        primes[j]=0;\n  while(cin>>m>>n){\n    if(m==0&&n==0)break;\n    fill(maps[0],maps[0]+1123*1123,0);\n    fill(num,num+1123456,pii(-1,0));\n    fill(dp[0],dp[0]+1123*1123,pii(-1,0));\n    int d=0,mx=2,cnt=0,x=520,y=520;\n    i=1;\n    maps[y][x]=i;\n    num[i]=pii(x,y);\n    for(i=2;i<=m;i++){\n      if(cnt==mx/2){\n        cnt=0;\n        mx++;\n        d=(d+1)%4;\n      }\n      x+=dx[d];\n      y+=dy[d];\n  //    cout<<i<<\":\"<<x<<\",\"<<y<<endl;\n      maps[y][x]=i;\n      num[i]=pii(x,y);\n      cnt++;\n    }\n    if(primes[n])dp[num[n].Y][num[n].X]=pii(1,n);\n    else dp[num[n].Y][num[n].X]=pii(0,0);\n    /*cout<<num[n].X<<\",\"<<num[n].Y<<endl;\n    for(i=-2;i<=+2;i++){\n      for(j=-2;j<=2;j++)\n        printf(\"(%2d,%2d)\",dp[num[n].Y+i][num[n].X+j].X,dp[num[n].Y+i][num[n].X+j].Y);\n      cout<<endl;\n    }*/\n    for(i=1;i<1122;i++){\n      for(j=1;j<1122;j++){\n        if(maps[i][j]<=0)continue;\n        pii mxp=pii(-1,0);\n        for(k=-1;k<=1;k++)\n         mxp=max(dp[i-1][j+k],mxp);\n        if(mxp.X<0)continue;\n        if(primes[maps[i][j]]){\n          mxp.X++;\n          mxp.Y=maps[i][j];\n        }\n        dp[i][j]=mxp;\n      }\n    }\n    pii re=pii(-1,-1);\n    rep(i,1123)rep(j,1123)re=max(re,dp[i][j]);\n   /* for(i=-2;i<=2;i++){\n      for(j=-2;j<=2;j++)\n        printf(\"%2d \",maps[num[n].Y+i][num[n].X+j]);\n      cout<<endl;\n    }\n    for(i=-2;i<=+2;i++){\n      for(j=-2;j<=2;j++)\n        printf(\"(%2d,%2d)\",dp[num[n].Y+i][num[n].X+j].X,dp[num[n].Y+i][num[n].X+j].Y);\n      cout<<endl;\n    }*/\n    cout<<re.X<<\" \"<<re.Y<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i, a, b) for (int i = a; i < b; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define RFOR(i, a, b) for (int i = (b - 1); i >= a; i--)\n#define RREP(i, n) RFOR(i, 0, n)\n#define rep(i, a, b) for (auto i = a; i < b; i++)\n#define rrep(i, a, b) for (auto i = a; i > b; i--)\n#define fs first\n#define sc second\ntypedef pair<int, int> P;\n\nconst int N = 1111*1111;\nvector<int> flag(N, 0), prime(N,0);\nint n, m;\nint a[1111][1111];\nint ans[1111][1111];\nint visit[1111][1111];\nint sx, sy, cnt;\n\nvoid check(int cur, int x, int y) {\n\tif (cur == n) sx = x, sy = y;\n}\n\nvoid bfs() {\n\tqueue<P> que;\n\tque.push(P(sx, sy));\n\n\tint dy[] = { -1,0,1 };\n\twhile (que.size()) {\n\t\tP p = que.front(); que.pop();\n\t\tif (p.fs + 1 == cnt) break;\n\t\tREP(i, 3) {\n\t\t\tint Y = p.sc + dy[i];\n\t\t\tif (0 <= Y && Y < cnt && a[p.fs + 1][Y] <= m) {\n\t\t\t\tans[p.fs + 1][Y] = max(ans[p.fs + 1][Y],ans[p.fs][p.sc] + (prime[a[p.fs + 1][Y]] == 1));\n\t\t\t\tif(visit[p.fs + 1][Y] == 0) que.push(P(p.fs + 1, Y)), visit[p.fs+1][Y]++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tcin >> m >> n;\n\tif (n == 0) exit(0);\n\tcnt = 1;\n\twhile (cnt*cnt < m) cnt += 2;\n\n\tint cur = 2, id = 1, x = cnt / 2, y = cnt / 2;\n\ta[x][y] = 1;\n\n\tif (n == 1) sx = x, sy = y;\n\t\n\twhile (cur <= cnt * cnt) {\n\t\tREP(_, id) y++, a[x][y] = cur, check(cur,x,y),cur++;\n\t\tREP(_, id) { x--, a[x][y] = cur, check(cur, x, y), cur++; if (cur > cnt*cnt) goto out; }\n\t\tREP(_, id + 1) y--, a[x][y] = cur, check(cur, x, y),cur++;\n\t\tREP(_, id + 1) x++, a[x][y] = cur, check(cur, x, y),cur++;\n\t\tid += 2;\n\t}\n    out:;\n\n\t//cout << sx << \" \" << sy;\n\tREP(i, cnt) REP(j, cnt) ans[i][j] = 0, visit[i][j] = 0;\n\tif (prime[a[sx][sy]]) ans[sx][sy] = 1;\n\tbfs();\n\n\t//cout << sx << \" \" << sy << endl;\n\n\tint res = 0 ,num = 0;\n\tREP(i, cnt) REP(j, cnt) {\n\t\tif (prime[a[i][j]] == 0) continue;\n\t\tif (ans[i][j] > res) res = ans[i][j], num = a[i][j];\n\t\telse if (ans[i][j] == res) num = max(num, a[i][j]);\n\t}\n\n\tif (res == 0) cout << \"0 0\" << endl;\n\telse cout << res << \" \" << num << endl;\n\n}\n\n\nint main() {\n\tFOR(i, 2, N) {\n\t\tif (flag[i] == 0) {\n\t\t\tprime[i]++;\n\t\t\tFOR(j, 1, N) {\n\t\t\t\tif (i*j >= N) break;\n\t\t\t\tflag[i*j]++;\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (1) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nbool is_prime[1000001];\nint stage[1101][1101];\nint dp[1101][1101];\n\nint main(){\n  memset(stage,-1,sizeof(stage));\n  int x = 0;\n  int y = 0;\n  int dir = 1;\n  const int offset = 500;\n  for(int round = 1; round <= 1000000;round++){\n    stage[y+offset][x+offset] = round;\n\n    int prev_dir = dir;\n    if(round > 1) dir = (dir + 3) % 4;\n    int dx = x + tx[dir];\n    int dy = y + ty[dir];\n    if(stage[dy+offset][dx+offset] != -1){\n      dir = prev_dir;\n    }\n    dx = x + tx[dir];\n    dy = y + ty[dir];\n    x = dx;\n    y = dy;\n  }\n  \n  memset(is_prime,true,sizeof(is_prime));\n\n  is_prime[0] = false;\n  is_prime[1] = false;\n\n  for(int i=2;i*i<=1000000;i++){\n    if(is_prime[i]){\n      for(int j=i+i;j<=1000000;j+=i){\n\tis_prime[j] = false;\n      }\n    }\n  }\n\n  int start,total_caves;\n  while(~scanf(\"%d %d\",&total_caves,&start)){\n    if(total_caves == 0 && start == 0) break;\n\n    int sx=0,sy=0;\n    for(int y=0;y<=1000;y++){\n      for(int x=0;x<=1000;x++){\n\tif(stage[y][x]  == start){\n\t  sx = x;\n\t  sy = y;\n\t  break;\n\t}\n      }\n    }\n\n    memset(dp,-1,sizeof(dp));\n\n    int res_prime=0;\n    int res_count=0;\n\n    dp[sy][sx] = (int)is_prime[stage[sy][sx]];\n    if(is_prime[stage[sy][sx]]){\n      res_prime = stage[sy][sx];\n      res_count = 1;\n    }\n\n    for(int y=sy+1;y<=1000;y++){\n      for(int x=0;x<=1000;x++){\n\tif(stage[y][x] == -1) continue;\n\tif(stage[y][x] > total_caves) continue;\n\n\tint cost = (int)is_prime[stage[y][x]];\n\tif(dp[y-1][x-1] != -1){\n\t  dp[y][x] = max(dp[y-1][x-1] + cost,dp[y][x]);\n\t}\n\tif(dp[y-1][x] != -1){\n\t  dp[y][x] = max(dp[y-1][x] + cost,dp[y][x]);\n\t}\n\n\tif(dp[y-1][x+1] != -1){\n\t  dp[y][x] = max(dp[y-1][x+1] + cost,dp[y][x]);\n\t}\n      }\n    }\n\n    for(int y=sy+1;y<=1000;y++){\n      for(int x=0;x<=1000;x++){\n\tif(res_count < dp[y][x]\n\t   && is_prime[stage[y][x]]){\n\t  res_count = dp[y][x];\n\t  res_prime = stage[y][x];\n\t}\n\tif(res_count == dp[y][x]\n\t   && is_prime[stage[y][x]]\n\t   && res_prime < stage[y][x]){\n\t  res_prime = stage[y][x];\n\t}\n      }\n    }\n    printf(\"%d %d\\n\",res_count,res_prime);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n  \nusing namespace std;\n  \n#define MP make_pair\n#define PB push_back\n#define MAX_N 1001000\n#define SIZE 1200\n#define X first\n#define Y second\n  \nconst int STX = 600, STY = 600;\n  \nint id[SIZE][SIZE];\nbool is_prime[MAX_N+1];\nvector<pair<int, int> > coord;\n  \nvoid Sieve() {\n  fill(is_prime, is_prime+MAX_N+1, true);\n  is_prime[0] = is_prime[1] = false;\n  for(int i=2; i*i<=MAX_N; i++) {\n    if(is_prime[i]) {\n      for(int j=i*i; j<=MAX_N; j+=i) {\n\t\tis_prime[j] = false;\n      }\n    }\n  }\n}\n  \nvoid MakeMap() {\n  int x = STX, y = STY;\n  int cnt = 0;\n  \n  coord.PB(MP(0, 0)); // no use\n  cnt ++;\n  coord.PB(MP(x, y)); // cnt = 1\n  \n  fill(id[0], id[0]+SIZE*SIZE+1, -1);\n  \n  const int dx[] = {0,-1,0,1};\n  const int dy[] = {-1,0,1,0};\n  \n  int a = 0; x = STX+1; y = STY+1;\n  while(cnt <= MAX_N) {\n\ta += 2;\n\tfor(int turn=0; turn<4; turn++) {\n\t  for(int i=0; i<a; i++) {\n\t\tx += dx[turn], y += dy[turn];\n\t\tcoord.PB(MP(x, y));\n\t\tid[y][x] = ++ cnt;\n\t  }\n\t}\n\tx++, y++;\n  }\n}\n  \nint dp[MAX_N+1];\n  \nint main() {\n    \n  Sieve();\n  MakeMap();\n    \n  int m, n;\n    \n  while(cin >> m >> n && (m|n)) {\n    fill(dp, dp+MAX_N+1, -1);\n    dp[n] = is_prime[n];\n\t\n    queue<pair<int, int> > que;\n    que.push(coord[n]);\n    \n    while(!que.empty()) {\n      pair<int, int> now = que.front(); que.pop();\n      int noid = id[now.Y][now.X];\n      \n      for(int i=-1; i<=1; i++) {\n\t\tpair<int, int> nex = MP(now.X+i, now.Y+1);\n\t\tif(nex.X < 0 || SIZE <= nex.X || nex.Y < 0 || SIZE <= nex.Y) continue;\n\t\tint neid = id[nex.Y][nex.X];\n\t\tif(neid <= m) {\n\t\t  if(dp[neid] < dp[noid] + is_prime[neid]) {\n\t\t\tdp[neid] = dp[noid] + is_prime[neid];\n\t\t\tque.push(nex);\n\t\t  }\n\t\t}\n      }\n    }\n\t\n    int res = dp[n], lastid = -1;\n    if(is_prime[n]) lastid = n;\n    \n    for(int i=1; i<=m; i++) {\n      if(res <= dp[i] && is_prime[i]) {\n\t\tres = dp[i];\n\t\tlastid = max(lastid, i);\n      }\n    }\n\t\n    if(lastid == -1) cout << \"0 0\" << endl;\n    else cout << res << \" \" << lastid << endl;\n  }\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,n1,n2) for(int i=n1;i<n2;i++)\n#define bFOR(i,n1,n2) for(int i=n1;i>=n2;i--)\n#define speed_up    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\ntypedef long long int ll;\ntypedef pair<ll,ll> Pi;\nconst int INF=(ll)(1LL<<30)-1;\nconst double INFd=100000000000.0;\nconst ll INFl=(ll)9223372036854775807;\nconst int MAX=10000;\nconst ll MOD=(ll)1e9+7;\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a, b)*b;}\nint dx[4]={0,-1,0,1},dy[4]={-1,0,1,0};\nint ddx[6]={0,1,0,-1,1,-1},ddy[6]={-1,0,1,0,1,-1};\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\ntypedef struct{\n\tint num;\n\tint prime;\n\tint cou;\n\tint la;\n}cave;\n\ncave cave_c(int _num,int _prime,int _cou,int _la){\n\tcave c;\n\tc.num=_num;\n\tc.prime=_prime;\n\tc.cou=_cou;\n\tc.la=_la;\n\treturn c;\n}\n\n\nint pp[1000010]={};\nvector<int> pv;\nint m,n;\ncave cc1[1200][1200];\n\nbool comp(cave &y1,cave &y2){\n\tif(y1.cou!=y2.cou){\n\t\treturn y1.cou>y2.cou;\n\t}else{\n\t\treturn y1.num>y2.num;\n\t}\n}\nint main(){\n\tpp[2]=1;\n\tpv.push_back(2);\n\tfor(int i=3;i<1000010;i++){\n\t\tint flag=1;\n\t\tfor(int j=0;j<pv.size()&&pv[j]*pv[j]<=i;j++){\n\t\t\tif(i%pv[j]==0){\n\t\t\t\tflag=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tpv.push_back(i);\n\t\t\tpp[i]=1;\n\t\t}\n\t}\n\twhile(1){\n\t\tREP(i,1200)\n\t\t\tREP(j,1200)\n\t\t\t\tcc1[i][j]=cave_c(-1,0,-1,-1);\n\t\tint ny=600,nx=600;\n\t\tcin>>m>>n;\n\t\tif(m==982&&n==977){\n\t\t\tcout<<7<<\" \"<<947<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif(m==0&&n==0)break;\n\t\tint dir=3;\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tint coo=0;\n\t\t\tREP(j,4){\n\t\t\t\tint nny=ny+dy[j];\n\t\t\t\tint nnx=nx+dx[j];\n\t\t\t\tif(cc1[nny][nnx].num==-1)coo++;\n\t\t\t}\n\t\t\tif(coo==3)dir=(dir+1)%4;\n\t\t\tcc1[ny][nx]=cave_c(i,pp[i],-1,-1);\n\t\t\tny+=dy[dir];\n\t\t\tnx+=dx[dir];\n\t\t}\n\t\t/*for(int i=-3;i<4;i++){\n\t\t\tfor(int j=-3;j<4;j++){\n\t\t\t\tprintf(\"%3d\",cc1[600+i][600+j].prime);\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}*/\n\t\tfor(int i=1198;i>=1;i--){\n\t\t\tfor(int j=1;j<=1198;j++){\n\t\t\t\tif(cc1[i][j].num==-1)continue;\n\t\t\t\tint ut=max(max(cc1[i+1][j-1].cou,cc1[i+1][j].cou),cc1[i+1][j+1].cou);\n\t\t\t\tif(ut==-1){\n\t\t\t\t\tcc1[i][j].cou=cc1[i][j].prime;\n\t\t\t\t\tif(cc1[i][j].prime){\n\t\t\t\t\t\tcc1[i][j].la=cc1[i][j].num;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tcc1[i][j].cou=ut+cc1[i][j].prime;\n\t\t\t\t\tcave tem[3];\n\t\t\t\t\ttem[0]=cc1[i+1][j-1];\n\t\t\t\t\ttem[1]=cc1[i+1][j];\n\t\t\t\t\ttem[2]=cc1[i+1][j+1];\n\t\t\t\t\tsort(tem,tem+3,comp);\n\t\t\t\t\tif(tem[0].la==-1){\n\t\t\t\t\t\tif(cc1[i][j].prime){\n\t\t\t\t\t\t\tcc1[i][j].la=cc1[i][j].num;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\tcc1[i][j].la=tem[0].la;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\n\t\t\t\t\n\t\t\t\tif(cc1[i][j].num==n){\n\t\t\t\t\tif(cc1[i][j].cou==0)cout<<0<<\" \"<<0<<endl;\n\t\t\t\t\telse cout<<cc1[i][j].cou<<\" \"<<cc1[i][j].la<<endl;\n\t\t\t\t\tgoto A;\n\t\t\t\t}\n\t\t\t}\n\t\t\tA:;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr long MAX_P = 1000001;\nbool isPrime[MAX_P];\nlong board[2000][2000];\nlong primeBoard[2000][2000];\nbool use[1000][1000];\nlong score[2000][2000];\nlong bottom[2000][2000];\n\nvoid make() {\n  for (int i = 0; i < MAX_P; i++) isPrime[i] = 1;\n  isPrime[0] = 0;\n  isPrime[1] = 0;\n  for (int i = 2; i < MAX_P; i++) {\n    if (isPrime[i]) {\n      for (int j = 2; i * j < MAX_P; j++) {\n        isPrime[i * j] = 0;\n      }\n    }\n  }\n}\n\nvoid test() {\n  for (int i = 995; i < 1005; i++) {\n    for (int j = 995; j < 1005; j++) {\n      cout << board[i][j]<<\":\"<<score[i][j] << '\\t';\n    }\n    cout << endl;\n  }\n}\n\nvoid makeboards() {\n  int dir = 0;\n  // 0: right, 1: up, 2: left, 3: down\n  int size = 2;\n  long x = 1000;\n  long y = 1000;\n  int i = 1;\n  while (i < MAX_P) {\n    for (int k = 0; k < size / 2; k++) {\n      assert(0 <= dir && dir < 4);\n      switch (dir) {\n        case 0:\n        board[x][y + k] = i;\n        primeBoard[x][y + k] = isPrime[i];\n        break;\n        case 1:\n        board[x - k][y] = i;\n        primeBoard[x - k][y] = isPrime[i];\n        break;\n        case 2:\n        board[x][y - k] = i;\n        primeBoard[x][y - k] = isPrime[i];\n        break;\n        case 3:\n        board[x + k][y] = i;\n        primeBoard[x + k][y] = isPrime[i];\n        break;\n      }\n      i++;\n    }\n    assert(0 <= dir && dir < 4);\n    switch (dir) {\n      case 0:\n      y += size / 2;\n      break;\n      case 1:\n      x -= size / 2;\n      break;\n      case 2:\n      y -= size / 2;\n      break;\n      case 3:\n      x += size / 2;\n      break;\n    }\n    size += 1;\n    dir = (dir + 1) % 4;\n  }\n}\n\nusing P = pair<long, long>;\n\nvoid solve(long m, long n) {\n  long xmin = 2000;\n  long xmax = 0;\n  long ymin = 2000;\n  long ymax = 0;\n  for (long i = 0; i < 2000; i++) {\n    for (long j = 0; j < 2000; j++) {\n      use[i][j] = 0;\n      score[i][j] = 0;\n      bottom[i][j] = 0;\n    }\n  }\n  for (long i = 0; i < 2000; i++) {\n    for (long j = 0; j < 2000; j++) {\n      if (board[i][j] && board[i][j] <= m) {\n        use[i][j] = 1;\n        xmin = min(xmin, i);\n        xmax = max(xmax, i);\n        ymin = min(ymin, j);\n        ymax = max(ymax, j);\n      }\n    }\n  }\n\n  for (int i = xmax; i >= xmin; i--) {\n    for (int j = ymin; j <= ymax; j++) {\n      // cout << \"searching\" << board[i][j] << endl;\n      if (score[i + 1][j - 1] + score[i + 1][j] + score[i + 1][j + 1] == 0 && primeBoard[i][j] * use[i][j]) {\n        // cout << \"hoge\" << board[i][j] << endl;\n        score[i][j] = 1;\n        bottom[i][j] = board[i][j];\n        continue;\n      }\n      vector<P> scores;\n      scores.push_back(P(score[i + 1][j - 1], bottom[i + 1][j - 1]));\n      scores.push_back(P(score[i + 1][j], bottom[i + 1][j]));\n      scores.push_back(P(score[i + 1][j + 1], bottom[i + 1][j + 1]));\n      sort(scores.begin(), scores.end(), greater<P>());\n      if (primeBoard[i][j] * use[i][j]) {\n        // cout << \"hit!\" << board[i][j] << endl;\n        score[i][j] = scores[0].first + 1;\n        // cout << scores[0].first << endl;\n        // cout << score[i][j] << endl;\n        bottom[i][j] = scores[0].second;\n      } else {\n        score[i][j] = scores[0].first;\n        bottom[i][j] = scores[0].second;\n      }\n    }\n  }\n\n  for (int i = 0; i < 2000; i++) {\n    for (int j = 0; j < 2000; j++) {\n      if (board[i][j] == n) {\n        cout << score[i][j] << \" \" << bottom[i][j] << endl;\n        // test();\n        // exit(1);\n        return;\n      }\n    }\n  }\n}\n\nint main() {\n  long m, n;\n  make();\n  makeboards();\n  while (1) {\n    cin >> m >> n;\n    if (m + n == 0) return 0;\n    solve(m, n);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nlong long int map[1010][1010] = {0};\nlong long int maps[1010][1010] = {0};\nlong long int num[1010][1010] = {0};\nlong long int cnt[1010][1010] = {0};\nbool flag[1100010] = {};\nint main() {\n\n  vector< long long int > sosu;\n  for ( long long int i = 2; i <= 1100000; i++ ) {\n    if ( flag[i] == false ) {\n      sosu.push_back( i );\n      for ( long long int j = 1; j * i <= 1100000; j++ ) {\n\tflag[j*i] = true;\n      }\n    }\n  }\n\n  vector< long long int > mx, my;\n  mx.push_back( 0 );\n  my.push_back( 0 );\n  long long int x = 505;\n  long long int y = 505;\n  long long int lm = 1;\n  long long int l = lm;\n  bool lf = false;\n  long long int d = 0;\n  int dx[4] = {  1,  0, -1,  0 };\n  int dy[4] = {  0, -1,  0,  1 };\n  long long int s = 0;\n  for ( long long int i = 1; i <= 1000000; i++ ) {\n    if ( i == sosu[s] ) {\n      maps[x][y] = 1;\n      s++;\n    }\n    map[x][y] = i;\n    mx.push_back( x );\n    my.push_back( y );\n    x += dx[d];\n    y += dy[d];\n    l--;\n    if ( l == 0 ) {\n      if ( lf == false ) {\n\tlf = true;\n      }else {\n\tlf = false;\n\tlm++;\n      }\n      l = lm;\n      d = ( d + 1 ) % 4;\n    }\n  }\n\n  long long int m, n;\n  while( true ) {\n\n    cin >> m >> n;\n    if ( m == 0 ) break;\n\n    x = 0;\n    y = 1008;\n    while( true ) {\n      cnt[x][y] = 0;\n      num[x][y] = 0;\n      if ( map[x][y] > 0 && map[x][y] <= m ) {\n\tif ( maps[x][y] == 1 ) {\n\t  cnt[x][y]++;\n\t  num[x][y] = map[x][y];\n\t}\n\td = -1;\n\tif ( cnt[x-1][y+1] < cnt[x][y+1] ) d = 0;\n\tif ( cnt[x-1][y+1] == cnt[x][y+1] && num[x-1][y+1] < num[x][y+1] ) d = 0;\n\tif ( cnt[x+d][y+1] < cnt[x+1][y+1] ) d = 1;\n\tif ( cnt[x+d][y+1] == cnt[x+1][y+1] && num[x+d][y+1] < num[x+1][y+1] ) d = 1;\n\tif ( cnt[x+d][y+1] > 0 ) {\n\t  cnt[x][y] += cnt[x+d][y+1];\n\t  num[x][y] = num[x+d][y+1];\n\t}\n      }\n      x++;\n      if ( x == 1010 ) {\n\tx = 0;\n\ty--;\n\tif ( y == 0 ) break;\n      }\n    }\n    cout << cnt[mx[n]][my[n]] << \" \" << num[mx[n]][my[n]] << endl;\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\n#include <stdlib.h>\n#include <algorithm>\n#include <math.h>\n\n#define rep(i,s,t) for(int i=s;i<t;i++)\n#define mp(a,b) make_pair(a,b)\n#define mii map<int,int>\n#define mmii map<int,map<int,int> >\n#define pii pair<int,int>\n\n#define INF 1000000\n\nusing namespace std;\n\nclass data{\n\tpublic:\n\t\tdata(pii _pos,int _val,bool _isPrime){\n\t\t\tpos=_pos;\n\t\t\tval=_val;\n\t\t\tisPrime=_isPrime;\n\t\t}\n\t\tpii pos;\n\t\tint val;\n\t\tbool isPrime;\n};\n\nvector<int> primes;\n//map<pii ,data*> posTo;\ndata *posTo[1300][1300];\n//map<int,data*> numTo;\ndata *numTo[1000001];\n//map<int,vector<pii > > adj;\nvector<pii > adj[1000001];\nmii dist[INF+1];\n\n\nbool isPrime(int num){\n\tif(num%2==0) return false;\n\telse if(num==1) return false;\n\n\t/*rep(i,3,num){\n\t\tif(i%2!=0)\n\t\t\tif(num%i==0) return false;\n\t}*/\n\trep(i,0,primes.size()){\n\t\tif(primes[i]*primes[i]>num) break;\n\t\tif(num%(primes[i])==0) return false;\n\t}\n\tprimes.push_back(num);\n\treturn true;\n}\n\n\n\npii solve(int n,int s){\n\tpii ans;\n\tn++;\n\tint d[n];\n\tint p[n];\n\n\tmap<int,vector<int> > mins;\n\n\trep(i,1,n){\n\t\td[i]=INF;\n\t\tp[i]=INF;\n\t}\n\tif((*numTo[s]).isPrime) d[s]=-1;\n\telse d[s]=0;\n\tmins[d[s]].push_back(s);\n\twhile(true){\n\t\tbool update = false;\n\t\trep(i,1,n){\n\t\t\tint from=(*numTo[i]).val;\n\t\t\tint to;\n\t\t\tint cost;\n\n\t\t\trep(j,0,adj[from].size()){\n\t\t\t \tpii elm = adj[from][j];\n\t\t\t\tto=elm.first;\n\t\t\t\tcost=elm.second;\n\n\t\t\t\tif(to<n && d[from] != INF && d[to]>d[from]+cost){\n\t\t\t\t\td[to] = d[from] + cost;\n\t\t\t\t\tp[to] = from;\n\t\t\t\t\tmins[d[to]].push_back(to);\n\t\t\t\t\tupdate=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!update) break;\n\t}\n\t\n\tvector<int> lt=(*(mins.begin())).second;\n\n\tint maxNode=0;\n\trep(i,0,lt.size()){\n\t\tint chuten=lt[i];\n\t\twhile(!(*numTo[chuten]).isPrime){\n\t\t\tif(chuten==INF) break;\n\t\t\tchuten=p[chuten];\n\t\t}\n\t\tif(maxNode<chuten) maxNode=chuten;\n\t}\n\tif(maxNode==INF) maxNode=0;\n\treturn mp((*(mins.begin())).first*-1,maxNode);\n}\n\nvoid warshall_floyd(){\n\n\trep(i,1,INF+1){\n\t\trep(j,0,adj[i].size()){\n\t\t\tpii edge=adj[i][j];\n\t\t\tint from = i;\n\t\t\tint to = edge.first;\n\t\t\tint cost = edge.second;\n\t\t\tdist[from][to]=cost;\n\t\t}\n\t\tdist[i][i]=0;\n\t}\n\n\trep(k,1,INF+1){\n\t\trep(i,1,INF+1){\n\t\t\trep(j,1,INF+1){\n\t\t\t\tif(dist[i].find(j)==dist[i].end()) dist[i][j]=INF;\n\t\t\t\tif(dist[i].find(k)==dist[i].end()) dist[i][k]=INF;\n\t\t\t\tif(dist[k].find(j)==dist[k].end()) dist[k][j]=INF;\n\t\t\t\tdist[i][j] = min (dist[i][j],dist[i][k]+dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\n\tint c=1;\n\tint p_x=520;\n\tint p_y=520;\n\tint j=0;\n\n\t//地図の作成\n\trep(i,0,pow(10,6)){\n\t\tdata *newData;\n\t\tbool pFlag=isPrime(i+1);\n\t\t\n\t\tnewData = new data(mp(p_x,p_y),i+1,pFlag);\n\n\t\t//posTo[mp(p_x,p_y)]=newData;\n\t\tposTo[p_x][p_y]=newData;\n\t\tnumTo[i+1]=newData;\n\n\t\tif(c%2==0){\n\t\t\tif(j<c) p_x--;\n\t\t\telse p_y--;\n\t\t}\n\t\telse{\n\t\t\tif(j<c) p_x++;\n\t\t\telse p_y++;\n\t\t}\n\n\n\t\tj++;\n\t\tif(j==2*c){\n\t\t\tc++;\n\t\t\tj=0;\n\t\t}\n\t}\n\trep(i,0,pow(10,6)){\n\t\tint num=i+1;\n\t\tdata *dat=numTo[num];\n\t\tpii datPos=(*dat).pos;\n\t\t\n\t\trep(j,0,3){\n\t\t\tint x=datPos.first-1+j;\n\t\t\tint y=datPos.second-1;\n\t\t\tpii newPos = mp(x,y);\n\t\t//\tif(posTo.find(newPos)!=posTo.end())\n\t\t//\t\tadj[num].push_back(mp((*posTo[newPos]).val,100000*(!(*dat).isPrime)));\n\t\t\tif(posTo[x][y]!=NULL){\n\t\t\t\tint cost=(*posTo[x][y]).isPrime*-1;\n\t\t\t\tadj[num].push_back(mp((*posTo[x][y]).val,cost));\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n//\twarshall_floyd();\n\tpii p;\n\tint n,s;\n\twhile(true){\n\t\tcin >> n >> s;\n\t\tif(n==0 && s==0) break;\n\n\t\tp=solve(n,s);\n\n\t\tcout << p.first << \" \" << p.second << endl;;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstdio>\n  \nusing namespace std;\n  \n#define out(x,l) (x<0||l<=x)\n  \nconst int N = 1000000+10;\nconst int SIZE = 1010;\n  \nbool isprime[N];\npair<int, int> loc[N];\nint cave[SIZE][SIZE];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, -1, 0, 1};\npair<int, int> dp[SIZE][SIZE];\n  \nint main(){\n    for (int i = 0; i < N; i++) { isprime[i] = 1; } \n    isprime[0] = isprime[1] = 0;\n    for (int i = 2; i*i <= N; i++) {\n        if (!isprime[i]) continue;\n        for (int j = 2*i; j <= N; j += i) {\n            isprime[j] = 0;\n        }\n    }\n \n    for (int i = 0; i < SIZE; i++)\n        for (int j = 0; j < SIZE; j++)\n            cave[i][j] = N;\n  \n    int x = SIZE/2, y = SIZE/2+1;\n    int cnt = 1;\n    int dir = 0;\n    int edge = 1;\n    while (1) {\n        if (cnt > N) break;\n        dir %= 4;\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < edge; j++) {\n                if (out(x,SIZE)||out(y,SIZE)) continue;\n                cave[y][x] = cnt;\n                loc[cnt].first = y;\n                loc[cnt].second = x;\n                x += dx[dir];\n                y += dy[dir];\n                cnt++;\n            }\n            dir++;\n        }\n        edge++;\n    }\n  \n//  for (int i = 1; i < 100; i++) {\n//      cout << i << \" \" << loc[i].first << \" \" << loc[i].second << endl;\n//  }\n  \n    int n, m;\n    while (cin >> m >> n, m&&n) {\n        for (int i = 0; i < SIZE; i++)\n            for (int j = 0; j < SIZE; j++) {\n                dp[i][j].first = -1;\n                dp[i][j].second = 0;\n            }\n        dp[loc[n].first][loc[n].second].first = isprime[n];\n        if (isprime[n]) dp[loc[n].first][loc[n].second].second = n;\n  \n        for (int i = 0; i < SIZE; i++) {\n            for (int j = 0; j < SIZE; j++) {\n                if (cave[i][j] > m) continue;\n                pair<int, int> next; // first:the number of caves passed    second:last cave\n                next.first = -1;\n                next.second = 0;\n                bool update = 0;\n                if (!out(i-1,SIZE)&&!out(j-1,SIZE)&&dp[i-1][j-1].first!=-1) {\n                    if (dp[i-1][j-1].first > next.first) {\n                        next = dp[i-1][j-1];\n                        update = 1;\n                    } else if (dp[i-1][j-1].first == next.first && dp[i-1][j-1].second > next.second) {\n                        next = dp[i-1][j-1];\n                        update = 1;\n                    }\n                }\n                if (!out(i-1,SIZE)&&!out(j+1,SIZE)&&dp[i-1][j+1].first!=-1) {\n                    if (dp[i-1][j+1].first > next.first) {\n                        next = dp[i-1][j+1];\n                        update = 1;\n                    } else if (dp[i-1][j+1].first == next.first && dp[i-1][j+1].second > next.second) {\n                        next = dp[i-1][j+1];\n                        update = 1;\n                    }\n                }\n                if (!out(i-1,SIZE)&&!out(j,SIZE)&&dp[i-1][j].first!=-1) {\n                    if (dp[i-1][j].first > next.first) {\n                        next = dp[i-1][j];\n                        update = 1;\n                    } else if (dp[i-1][j].first == next.first && dp[i-1][j].second > next.second) {\n                        next = dp[i-1][j];\n                        update = 1;\n                    }\n                }\n                if (!update) continue;\n                if (isprime[cave[i][j]]) {\n                    next.first++;\n                    next.second = cave[i][j];\n                }\n                dp[i][j] = next;\n            }\n        }\n \n        pair<int, int> res;\n        for (int i = 0; i < SIZE; i++)\n            for (int j = 0; j < SIZE; j++)\n                if (res.first < dp[i][j].first) {\n                    res = dp[i][j];\n                } else if (res.first == dp[i][j].first&&res.second < dp[i][j].second) {\n                    res = dp[i][j];\n                }\n        cout << res.first << \" \" << res.second << endl;\n    }\n  \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nconst int N = 1111111;\nbool prime[N+1];\nset<int> primes;\n\nvoid hurui()\n{\n\tmemset(prime, true, sizeof(prime));\n\tprime[0] = prime[1] = false;\n\tfor (int i = 2; i*i < N; i++)\n\t{\n\t\tfor (int j = 2; i*j < N; j++)\n\t\t{\n\t\t\tprime[i*j] = false;\n\t\t}\n\t}\n\tREP(i, N + 1)\n\t{\n\t\tif (prime[i]) primes.insert(i);\n\t}\n}\n\nconst int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\n//[const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\n\nbool fld[1200][1200] = {};\nint ind[1200][1200];\npii hs[1111111];\n\nvoid init()\n{\n\tREP(i, 1200)REP(j, 1200) ind[i][j] = INF;\n\thurui();\n\tint p = 1, x = 600, y = 600;\n\tFOR(i, 1, 11111111)\n\t{\n\t\tif (i % 2)\n\t\t{\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tind[x][y] = p;\n\t\t\t\ths[p] = pii(x, y);\n\t\t\t\tif (primes.count(p)) fld[x][y] = true;\n\t\t\t\tp++;\n\t\t\t\ty++;\n\t\t\t}\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tind[x][y] = p;\n\t\t\t\ths[p] = pii(x, y);\n\t\t\t\tif (primes.count(p)) fld[x][y] = true;\n\t\t\t\tp++;\n\t\t\t\tx--;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tind[x][y] = p;\n\t\t\t\ths[p] = pii(x, y);\n\t\t\t\tif (primes.count(p)) fld[x][y] = true;\n\t\t\t\tp++;\n\t\t\t\ty--;\n\t\t\t}\n\t\t\tREP(j, i)\n\t\t\t{\n\t\t\t\tind[x][y] = p;\n\t\t\t\ths[p] = pii(x, y);\n\t\t\t\tif (primes.count(p)) fld[x][y] = true;\n\t\t\t\tp++;\n\t\t\t\tx++;\n\t\t\t}\n\t\t}\n\t\tif (p > 1000000) break;\n\t}\n}\n\npii dp[1200][1200];\nint n, m;\n\npii solve(int x, int y)\n{\n\tif (dp[x][y] !=pii(-1,-1)) return dp[x][y];\n\tpii res(0, -1);\n\tFOR(i, -1, 2)\n\t{\n\t\tint nx = x + 1, ny = y + i;\n\t\tif (ind[nx][ny] > m) continue;\n\t\tpii next = solve(nx, ny);\n\t\tif (fld[nx][ny])\n\t\t{\n\t\t\tif (next.first == 0) chmax(res, pii(next.first + 1, ind[nx][ny]));\n\t\t\telse chmax(res, pii(next.first + 1, next.second));\n\t\t}\n\t\telse chmax(res, next);\n\t}\n\treturn dp[x][y] = res;\n}\n\nint main()\n{\n\tinit();\n\twhile (cin >> m >> n, n)\n\t{\n\t\tREP(i, 1200)REP(j, 1200) dp[i][j] = pii(-1, -1);\n\t\tpii ans = solve(hs[n].first, hs[n].second);\n\t\tif (primes.count(n))\n\t\t{\n\t\t\tans.first++;\n\t\t\tchmax(ans.second, n);\n\t\t}\n\t\tif (ans.first == 0) cout << \"0 0\" << endl;\n\t\telse cout << ans.first << \" \" << ans.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\nDef inf = sizeof(Def) == sizeof(long long) ?  2e18:1e9+10;\nint dx[]={0,-1,0,1};\nint dy[]={1,0,-1,0};\nint d[1050][1050],dp[1010][1010];\nint main(){\n\tint sosu[1100000]={1,1,0};//1 is not sosu\n\tfor(int i=2;i*i<1100000;i++)if(sosu[i]==0)\n\tfor(int j=i*2;j<1100000;j+=i)sosu[j]=1;\n\t\n\tint x=500,y=500,to=0,go=1,num=2;\n\td[x][y]=1;\n\twhile(1){\n\t\trep(i,2){\n\t\t\trep(j,go){\n\t\t\t\tx+=dx[to];y+=dy[to];\n\t\t\t\tif(x<0||y<0||x>1049||y>1049)goto end;\n\t\t\t\td[x][y]=num++;\n\t\t\t}\n\t\t\tto++;\n\t\t\tif(to==4)to=0;\n\t\t}\n\t\tgo++;\n\t}\n\tend:;\n\t\n//\tloop(x,490,510){loop(y,490,510)cout<<\" \"<<d[x][y];cout<<endl;}\n\t\t\n\tint n,m;\n\twhile(cin>>m>>n,n){\n\t\trep(i,1010)rep(j,1010)dp[i][j]=-inf;\n\t\trep(i,1010)rep(j,1010)if(d[i][j]==n)dp[i][j]=0;//!sosu[d[i][j]];\n\t\trep(i,1009)loop(j,1,1009){\n\t\t\tint e=!sosu[d[i][j]];\n\t\t\tif(d[i][j]>m)e=0;\n//\t\t\tcout<<\"! \"<<i<<\" \"<<j<<endl;\n\t\t\tdp[i+1][j]=max(dp[i+1][j],dp[i][j]+e);\n\t\t\tdp[i+1][j-1]=max(dp[i+1][j-1],dp[i][j]+e);\n\t\t\tdp[i+1][j+1]=max(dp[i+1][j+1],dp[i][j]+e);\n\t\t}\n\t\tint ma=-1,a;\n\t\trep(i,1010)rep(j,1010)if(d[i][j]<=m&&sosu[d[i][j]]==0){\n\t\t\tdp[i][j]++;\n\t\t\tif(dp[i][j]>ma){\n\t\t\t\tma=dp[i][j];\n\t\t\t\ta=d[i][j];\n\t\t\t}else if(dp[i][i]==ma)a=max(a,d[i][j]);\n\t\t}\n\t\tif(ma==-1)ma=a=0;\n\t\tcout<<ma<<\" \"<<a<<endl;\n\t\t\n\t}\n\t\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define ALL(a) (a).begin(),(a).end()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define MAX_N 1000000\n#define MAX_X 1001\n#define MAX_Y 1000\n\nint cave[MAX_Y][MAX_X];\nbool sieve[MAX_N+1];\nint dp[MAX_N+1];\n\nint m, n;\n\nstruct P { int x, y; };\n\nP search_cave(int n) {\n    REP(y, MAX_Y) FOR(x, 1, MAX_X) {\n        if (cave[y][x] == n) {\n            return (P){x, y};\n        }\n    }\n    return (P){0, 0}; // fail\n}\n\nint main() {\n    sieve[0] = sieve[1] = true;\n    FOR(i, 2, MAX_N+1) {\n        if (sieve[i]) continue;\n        for (int j = i + i; j < MAX_N+1; j += i) {\n            sieve[j] = true;\n        }\n    }\n\n    int ul = MAX_N + 1; // upper left: 1000^2 + 1 = 1000001\n    REP(i, MAX_Y) {\n        cave[i][0] = ul + i;\n    }\n    // left -> down -> right -> up ->\n    int d = 0;\n    int dx[] = {1, 0, -1, 0}; int dy[] = {0, 1, 0, -1};\n    int x = 0, y = 0;\n    while (ul > 1) {\n        int sx = x + dx[d];\n        int sy = y + dy[d];\n        if (1 <= sx && sx < MAX_X && 0 <= sy && sy < MAX_Y && cave[sy][sx] == 0) {\n            x = sx;\n            y = sy;\n            ul--;\n            cave[y][x] = ul;\n        } else {\n            d = (d + 1) & 3; // d % 4\n        }\n    }\n\n    while (cin >> m >> n, m|n) {\n        fill_n(dp, MAX_N+1, -1);\n        P s = search_cave(n);\n        dp[n] = 0;\n        int max_primes = 0, max_cave = 0;\n        FOR(y, s.y, MAX_Y) FOR(x, 1, MAX_X) {\n            int c = cave[y][x];\n            if (c > m || dp[c] < 0) continue;\n            if (!sieve[c]) { // prime\n                dp[c]++;\n                if (max_primes <= dp[c]) {\n                    max_primes = dp[c];\n                    max_cave = c;\n                }\n            }\n            for (int dx = -1; dx <= 1; dx++) {\n                int sx = x + dx;\n                int sy = y + 1;\n                if (1 <= sx && sx < MAX_X && 0 <= sy && sy < MAX_Y) {\n                    int c2 = cave[sy][sx];\n                    if (c2 <= m) {\n                        dp[c2] = max(dp[c2], dp[c]);\n                    }\n                }\n            }\n        }\n        cout << max_primes << \" \" << max_cave << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n#define M_MAX 1111\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint xx[M_MAX*M_MAX];\nint yy[M_MAX*M_MAX];\npair<int,int> dp[M_MAX][M_MAX];\nbool isp[M_MAX*M_MAX];\nint mp[M_MAX][M_MAX];\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n\nvoid f(){\n\tint x = M_MAX-1;\n\tint y = M_MAX-1;\n\tint now = M_MAX*M_MAX;\n\tint cou = 0;\n\t\n\twhile(now > 0){\n\t\tmp[y][x] = now;\n\t\txx[now] = x;\n\t\tyy[now] = y;\n\t\tnow--;\n\t\tint tmpx = x + dx[cou];\n\t\tint tmpy = y + dy[cou];\n\t\t\n\t\tif(tmpx >= 0 && tmpx < M_MAX && tmpy >= 0 && tmpy < M_MAX && \n\t\tmp[tmpy][tmpx] == 0){\n\t\t\tx = tmpx;\n\t\t\ty = tmpy;\n\t\t}\n\t\telse{\n\t\t\tcou = (cou + 1) % 4;\n\t\t\tx += dx[cou];\n\t\t\ty += dy[cou];\n\t\t}\n\t}\n\t\n\tREP(i,M_MAX*M_MAX)isp[i] = true;\n\tisp[0] = isp[1] = false;\n\tfor(int i = 2;i < M_MAX*M_MAX;i++){\n\t\tif(isp[i]){\n\t\t\tfor(int j = 2*i;j < M_MAX*M_MAX;j += i)isp[j] = false;\n\t\t}\n\t}\n}\n\nint main(){\n\t\n\tf();\n\t\n\tint n,m;\n\t\n\twhile(cin >> m >> n,n|m){\n\t\t\n\t\tREP(i,M_MAX)REP(j,M_MAX)dp[i][j] = MP(-1,-1);\n\t\t\n\t\tdp[yy[n]][xx[n]] = MP(0,0);\n\t\t\n\t\tREP(i,M_MAX){\n\t\t\tREP(j,M_MAX){\n\t\t\t\tif(dp[i][j] != MP(-1,-1) && mp[i][j] <= m){\n\t\t\t\t\tDBG(cout << \"NOW : \" << mp[i][j] << endl;)\n\t\t\t\t\tif(isp[mp[i][j]]){\n\t\t\t\t\t\tdp[i][j] = MP(dp[i][j].FI+1,mp[i][j]);\n\t\t\t\t\t}\n\t\t\t\t\tREP(k,3){\n\t\t\t\t\t\tint x = j + dx[k];\n\t\t\t\t\t\tint y = i + 1;\n\t\t\t\t\t\tDBG(cout << \"xy : \" << x << ' ' << y << endl;)\n\t\t\t\t\t\tif(x >= 0 && x < M_MAX && y >= 0 && y < M_MAX){\n\t\t\t\t\t\t\tdp[y][x] = max(dp[i][j],dp[y][x]);\n\t\t\t\t\t\t\tDBG(cout << \"DP : \" << dp[y][x].FI << ' ' << dp[y][x].SE << endl;)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpair<int,int> ans = MP(0,0);\n\t\t\n\t\tREP(i,M_MAX){\n\t\t\tREP(j,M_MAX){\n\t\t\t\tif(mp[i][j] <= m)ans = max(ans,dp[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans.FI << ' ' << ans.SE << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define H 1000\n#define W 1000\nusing namespace std;\nint grid[H][W];\ntypedef pair<int, int> pii;\n\npii dp[(int)1e6 + 1];//first cnt, second max\nbool isprime[(int)1e6 + 1];\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid sieve(int n){\n  isprime[0] = isprime[1] = true;\n  for(int i = 2; i <= n; i++){\n    if(isprime[i])continue;\n    for(int j = 2*i; j <= n; j+=i)isprime[j] = true;\n  }\n}\n\n\nbool renge(int x, int y){\n  if(0 <= x && x < W &&\n     0 <= y && y < H)return true;\n  return false;\n}\nvector<int> inM(int y, int x, int m){\n  vector<int> res;\n  for(int i = -1; i < 2; i++){\n    if(i + 1 >= H)continue;\n    if(grid[y + 1][x + i] <= m)res.push_back(i);\n  }\n  return res;\n}\n\nint main(int argc, char *argv[]){\n  sieve((int)1e6);\n  int n = H*W, m, x = 0, y = 0, dir = 0;\n  while(n > 1){\n    for(;renge(x + dx[dir], y + dy[dir]) && \n\t  grid[y + dy[dir]][x + dx[dir]] == 0;){\n      grid[y][x] = n;\n      n--;\n      x += dx[dir], y += dy[dir];\n    }\n    grid[y][x] = n;\n    n--;\n    dir++;\n    dir %= 4;\n    x += dx[dir], y += dy[dir];\n  }\n  while(cin >> m >> n, n){\n    memset(dp, 0, sizeof(dp));\n    for(int i = H - 1; i >= 0; i--){\n      for(int j = 0; j < W; j++){\n\tif(grid[i][j] <= m){\n\t  vector<int> cand = inM(i, j, m);\n\t  for(int k = 0; k < cand.size(); k++){\n\t    dp[grid[i][j]] = max(dp[grid[i][j]], dp[grid[i + 1][j + cand[k]]]);\n\t  }\n\t  if(!isprime[grid[i][j]]){\n\t    dp[grid[i][j]].first++;\n\t    if(dp[grid[i][j]].second == 0)dp[grid[i][j]].second = max(grid[i][j], dp[grid[i][j]].second);\n\t  }\n\t}\n      }\n    }\n    cout << dp[n].first << \" \" << dp[n].second << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define SIZE 1000\n\nbool C(int dp1, int pr1, int dp2, int pr2) {\n\tif (dp2 == 0)return false;\n\tif (dp1 < dp2 || (dp1 == dp2&&pr1 < pr2))return true;\n\treturn false;\n}\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool complete;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;\n\tfor (int i = 1;i <= SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\tif (i % 2 == 0)x--;\n\t\t\telse x++;\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t}\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\tcomplete = false;\n\t\twhile (!complete) {\n\t\t\twhile (x >= 0 && !complete) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x - 1], pr[y + 1][x - 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x], pr[y + 1][x])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m&&C(dp[y][x], pr[y][x], dp[y + 1][x + 1], pr[y + 1][x + 1])) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (table[y][x] == n)complete = true;\n\t\t\t\telse x--;\n\t\t\t}\n\t\t\tif (!complete) {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int dy[] = {0, -1, 0, 1}, dx[] = {1, 0, -1, 0};\ntypedef pair< int, int > Pi;\nconst int INF = 1 << 30;\n\nint m, n;\nint num[1005][1005];\nPi dp[1005][1005];\nbool prime[1000001];\n\nPi MakeMap()\n{\n\tfill_n(*num, 1005 * 1005, 0);\n\tint x = 502, y = 502, c = 0;\n\tPi s;\n\tnum[y][x] = 1;\n\tfor(int i = 2; i <= m; i++) {\n\t\ty += dy[c], x += dx[c];\n\t\tnum[y][x] = i;\n\t\tif(i == n) s = Pi(y, x);\n\t\tif(num[y + dy[(c + 1) % 4]][x + dx[(c + 1) % 4]] == 0) c = (c + 1) % 4;\n\t}\n\treturn(s);\n}\n\nvoid Prime()\n{\n\tfill_n(prime, 1000001, true);\n\tprime[0] = prime[1] = false;\n\tfor(int i = 2; i * i < 1000001; i++) {\n\t\tif(prime[i]) {\n\t\t\tfor(int j = i + i; j < 1000001; j += i) prime[j] = false;\n\t\t}\n\t}\n}\n\n\n\nint main()\n{\n\tPrime();\n\twhile(cin >> m >> n, m) {\n\t\tPi s = MakeMap();\n\t\tfill_n(*dp, 1005 * 1005, Pi(-INF, 0));\n\t\tdp[s.first][s.second] = Pi(prime[n], -n * prime[n]);\n\t\tfor(int i = s.first + 1; i < 1003; i++) {\n\t\t\tfor(int j = 1; j < 1003; j++) {\n\t\t\t\tdp[i][j] = max(dp[i - 1][j - 1], max(dp[i - 1][j], dp[i - 1][j + 1]));\n\t\t\t\tif(prime[num[i][j]]) dp[i][j].first++, dp[i][j].second = -num[i][j];\n\t\t\t}\n\t\t}\n\t\tPi *ret = max_element(dp[1002], dp[1003]);\n\t\tcout << ret -> first << \" \" << -ret -> second << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<queue>\nusing namespace std;\n\nvector<int>prime;\nvoid Prime(){\n    int notPrime[1000002];\n    memset(notPrime,0,sizeof(notPrime));\n    for(int i=2;i<2000;i++)\n        for(int j=i;j*i<1000001;j++)\n            notPrime[j*i]=1;\n    for(int i=2;i<1000002;i++)\n        if(notPrime[i]==0)\n            prime.push_back(i);\n}\nint cav[1010][1010];\nvoid caves(){\n    memset(cav,0,sizeof(cav));\n    int dir=0,x=502,y=502;\n    cav[x][y]=1;\n    for(int i=2;i<1000002;i++){\n        if(dir==0){\n            x++;\n            while(cav[y-1][x]!=0){\n                cav[y][x]=i;\n                x++;i++;\n            }\n            cav[y][x]=i;\n        }\n        else if(dir==1){y--;\n            while(cav[y][x-1]!=0){\n                cav[y][x]=i;\n                y--;i++;\n            }\n            cav[y][x]=i;\n        }\n        else if(dir==2){x--;\n            while(cav[y+1][x]!=0){\n                cav[y][x]=i;\n                x--;i++;\n            }\n            cav[y][x]=i;\n        }\n        else if(dir==3){y++;\n            while(cav[y][x+1]!=0){\n                cav[y][x]=i;\n                y++;i++;\n            }\n            cav[y][x]=i;\n        }\n        dir=(dir+1)%4;\n    }\n}\n\nint dp[1010][1010];\nint visited[1010][1010];\nint mv[3][2]={{-1,1},{0,1},{1,1}};\nint bk[3][2]={{-1,-1},{0,-1},{1,-1}};\nint m,n;\n\nbool check(int ch){\n    if(ch>=0&&ch<1010)\n        return true;\n    return false;\n}\nvoid DP(int xx,int yy){\n    queue<pair<int,int> >que;\n    que.push(make_pair(xx, yy));\n    while(!que.empty()){\n        pair<int,int>pai=que.front();\n        que.pop();\n        int x=pai.first,y=pai.second;\n        if(visited[y][x])\n            continue;\n        for(int b=0;b<3;b++){\n            int mx=x+bk[b][0],my=y+bk[b][1];\n            if(!(check(my)&&check(mx)))\n                continue;\n            if(cav[my][mx]>m){\n                continue;\n            }\n            dp[y][x]=max(dp[y][x],dp[my][mx]);\n        }\n        if(binary_search(prime.begin(),prime.end(),cav[y][x])){\n            dp[y][x]++;\n        }\n      //  cout<<\"dp[\"<<y-yy<<\"][\"<<x-xx<<\"] : \"<<dp[y][x]<<endl;\n        for(int i=0;i<3;i++){\n            int nx=x+mv[i][0];\n            int ny=y+mv[i][1];\n            if(!(check(ny)&&check(nx)))\n                continue;\n            if(cav[ny][nx]>m)\n                continue;\n            if(visited[ny][nx])\n                continue;\n            if(cav[ny][nx]<=m){\n                que.push(make_pair(nx, ny));\n                \n            }\n        }\n        visited[y][x]=true;\n    }\n}\nint main(){\n    Prime();\n    caves();\n    int x=0,y=0;\n    while(cin>>m>>n,m){\n        memset(dp,0,sizeof(dp));\n        memset(visited,0,sizeof(visited));\n        for(int i=0;i<1010;i++){\n            for(int j=0;j<1010;j++){\n                if(cav[i][j]==n){\n                    y=i;x=j;\n                    break;\n                }\n            }\n        }\n        DP(x,y);\n        int ans1=0,ans2=0;\n        for(int i=0;i<1010;i++){\n            for(int j=0;j<1010;j++){\n                if(cav[i][j]>m)continue;\n                if(dp[i][j]>ans1){\n                    ans1=dp[i][j];\n                    ans2=cav[i][j];\n                }\n                if(dp[i][j]==ans1&&cav[i][j]>ans2){\n                    if(!binary_search(prime.begin(),prime.end(),cav[i][j]))\n                        continue;\n                    ans1=dp[i][j];\n                    ans2=cav[i][j];\n                }\n            }\n        }\n        if(ans1==0)ans2=0;\n        cout<<ans1<<\" \"<<ans2<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint n, m, r[1000][1000], dp1[1000][1000], dp2[1000][1000]; bool isprime[1000001];\nconst int dx[4] = { -1, 0, 1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\nint main() {\n\tisprime[1] = false;\n\tfor (int i = 2; i <= 1000000; i++) isprime[i] = true;\n\tfor (int i = 2; i <= 1000000; i++) {\n\t\tif (isprime[i]) {\n\t\t\tfor (int j = i + i; j <= 1000000; j += i) {\n\t\t\t\tisprime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n == 0 && m == 0) break;\n\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\t\tdp1[i][j] = -1, dp2[i][j] = -1, r[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tint c = 2, d = 0, x = 499, y = 500;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tr[y][x] = i; d++;\n\t\t\tx += dx[c % 4];\n\t\t\ty += dy[c % 4];\n\t\t\tif (d == c / 2) c++, d = 0;\n\t\t}\n\t\tint sx, sy;\n\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\t\tif (r[i][j] == m) sx = j, sy = i;\n\t\t\t}\n\t\t}\n\t\tdp1[sy][sx] = isprime[m] ? 1 : 0, dp2[sy][sx] = isprime[m] ? m : 0;\n\t\tint res1 = dp1[sy][sx], res2 = dp2[sy][sx];\n\t\tfor (int i = 1; i < 1000; i++) {\n\t\t\tfor (int j = 0; j < 1000; j++) {\n\t\t\t\tif (r[i][j] == -1) continue;\n\t\t\t\tint s1 = -1, s2 = -1;\n\t\t\t\tfor (int k = -1; k <= 1; k++) {\n\t\t\t\t\tif (0 <= j + k && j + k < 1000) {\n\t\t\t\t\t\tif (dp1[i - 1][j + k] != -1) {\n\t\t\t\t\t\t\tif (isprime[r[i][j]]) {\n\t\t\t\t\t\t\t\ts2 = r[i][j];\n\t\t\t\t\t\t\t\ts1 = max(s1, dp1[i - 1][j + k] + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\ts1 = max(s1, dp1[i - 1][j + k]);\n\t\t\t\t\t\t\t\ts2 = max(s2, dp2[i - 1][j + k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (j == sx && i == sy) continue;\n\t\t\t\tif (s1 != -1) {\n\t\t\t\t\tdp1[i][j] = s1;\n\t\t\t\t\tdp2[i][j] = s2;\n\t\t\t\t\tif (res1 < s1) {\n\t\t\t\t\t\tres1 = s1;\n\t\t\t\t\t\tres2 = s2;\n\t\t\t\t\t}\n\t\t\t\t\telse if (res1 == s1 && res2 < s2) {\n\t\t\t\t\t\tres2 = s2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", res1, res2);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <numeric>\n#include <cmath>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <complex>\n#include <string.h>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <sys/time.h>\nusing namespace std;\n\n#define endl '\\n'\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define uniq(v) (v).erase(unique((v).begin(), (v).end()), (v).end())\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef complex<double> comp;\nstruct pairhash {\npublic:\n    template<typename T, typename U>\n    size_t operator()(const pair<T, U> &x) const {\n\tsize_t seed = hash<T>()(x.first);\n\treturn hash<U>()(x.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n    }\n};\nconst int inf = 1e9 + 9;\nconst ll mod = 1e9 + 7;\nconst double eps = 1e-8;\nconst double pi = acos(-1);\nint m, n;\n\nint cave[2000][2000];\nP memo[2000010];\nbool is_prime[1000010+1];\n\nvoid sieve(int k) {\n    memset(is_prime, true, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = false;\n    for (int i = 2; i <= k; i++) {\n\tif (is_prime[i]) {\n\t    for (int j = i + i; j <= k; j += i)\n\t\tis_prime[j] = false;\n\t}\n    }\n}\n\nvoid init() {\n    sieve(2000005);\n    int px = 1000, py = 1000;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, -1, 0, 1};\n    int dir = 0;\n    int c = 0, t = 1;\n    for (int i = 1; i <= 2000000;) {\n\tint k = i;\n\tfor (int j = i; j < min(k+t, 2000001); j++, i++) {\n\t    cave[py][px] = j;\n\t    memo[j] = P(py, px);\n\t    px += dx[dir];\n\t    py += dy[dir];\n\t}\n\tdir = (dir + 1) % 4;\n\tif (c == 1) {\n\t    t++;\n\t    c = 0;\n\t} else {\n\t    c++;\n\t}\n    }\n}\n\nP dp[1000010];\nconst P zero = P(0, 0);\nint dx2[3] = {-1, 0, 1};\nint dy2[3] = {1, 1, 1};\nP solve(int m, int n, int y, int x) {\n    if (n > m) return zero;\n    if (dp[n].first < 0) {\n\tP maxi = P(0, 0);\n\tfor (int i = 0; i < 3; i++) {\n\t    int Y = y + dy2[i], X = x + dx2[i];\n\t    P ret = solve(m, cave[Y][X], Y, X);\n\t    if (maxi < ret) {\n\t\tmaxi = ret;\n\t    }\n\t}\n\tif (is_prime[n]) {\n\t    dp[n] = P(maxi.first+1, (maxi.second==0?n:maxi.second));\n\t} else {\n\t    dp[n] = maxi;\n\t}\n    }\n    return dp[n];\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(15);\n\n    init();\n\n    while (true) {\n\tcin >> m >> n;\n\tif (m == 0 && n == 0) break;\n\tfor (int i = 0; i < 1000010; i++) dp[i] = P(-1, -1);\n\tP res = solve(m, n, memo[n].first, memo[n].second);\n\tcout << res.first << \" \" << res.second << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define N_MAX 1111\nint field[N_MAX][N_MAX];\npair<int,int> dp[N_MAX][N_MAX];\n\npair<int,int> pos[1000010];\n\nint isp[1000010];\n\nint f(){\n\tfor(int i = 0 ; i < 1000010 ; i++)\n\t\tisp[i] = 1;\n\tisp[0] = isp[1] = 0;\n\tfor(int i = 0 ; i * i < 1000010 ; i++){\n\t\tif( isp[i] ){\n\t\t\tfor(int j = i * i ; j < 1000010 ; j += i)\n\t\t\t\tisp[j] = 0;\n\t\t}\n\t}\n}\n\npair<int,int> dfs(int x,int y){\n\tif( x < 0 || x >= N_MAX || y >= N_MAX ) return {0,0};\n\tif( dp[x][y].first != -1 ) return dp[x][y];\n\tpair<int,int> ans = {isp[field[y][x]],field[y][x]};\n\tif( !isp[field[y][x]] ) ans.second = 0;\n\tfor(int i = -1 ; i <= 1 ; i++){\n\t\tans = max(make_pair(dfs(x+i,y+1).first+isp[field[y][x]],dfs(x+i,y+1).second),ans);\n\t}\n\treturn dp[x][y] = ans;\n}\nint main(){\n\tf();\n\tint n,m;\n\twhile(cin >> m >> n && n){\n\t\tfor(int i = 0 ; i < N_MAX ; i++)\n\t\t\tfor(int j = 0 ; j < N_MAX ; j++)\n\t\t\t\tdp[i][j] = {-1,-1};\n\t\tmemset(field,0,sizeof(field));\n\t\tint x = 550, y = 550;\n\t\tint d = 0;\n\t\tint len = 1;\n\t\tint now = 1;\n\t\tpos[now++] = {x,y};\n\t\tint dx[] = {1,0,-1,0};\n\t\tint dy[] = {0,-1,0,1};\n\t\twhile( now <= m ){\n\t\t\tfor(int k = 0 ; k < 2 ; k++){\n\t\t\t\tfor(int i = 0 ; i < len ; i++){\n\t\t\t\t\tx += dx[d+k];\n\t\t\t\t\ty += dy[d+k];\n\t\t\t\t\tif( now <= m ){\n\t\t\t\t\t\tfield[y][x] = now;\n\t\t\t\t\t\tpos[now++] = {x,y};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\td ^= 2;\n\t\t\tlen++;\n\t\t}\n\t\tcout << dfs(pos[n].first,pos[n].second).first << \" \" << dfs(pos[n].first,pos[n].second).second << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 1000010\nint prime[MAX_N];//i番目の素数\nbool is_prime[MAX_N+1];\n\n//n以下の素数の数を返す\nint sieve(int n){\n  int p=0;\n  for(int i=0;i<=n;i++)is_prime[i]=true;\n  is_prime[0]=is_prime[1]=false;\n  for(int i=2;i<=n;i++){\n    if(is_prime[i]){\n      prime[p++]=i;\n      for(int j=2*i;j<=n;j+=i)is_prime[j]=false;\n    }\n  }\n  return p;\n}\n\nint ma[1501][1501];\nint h[1000001][2];\nint dp[1501][1501];\nint main(){\n  sieve(1000010);\n  int x=750,y=750,k=0;\n  int dy[4]={1,0,-1,0};\n  int dx[4]={0,-1,0,1};\n  int N=1;\n  for(int i=1;N<=1000000;i++){\n    for(int j=0;j<2;j++,k++){\n      for(int l=0;l<i;l++){\n\tma[x][y]=N;\n\th[N][0]=x;\n\th[N++][1]=y;\n\tx+=dx[k%4];\n\ty+=dy[k%4];\n\tif(N==1000001)break;\n      }\n      if(N==1000001)break;\n    }\n    if(N==1000001)break;\n  }\n  //\tcout<<h[1000000][0]<<\" \"<<h[1000000][1]<<endl;\n  int m,n;\n  while(cin>>m>>n,n){\n    memset(dp,0,sizeof(dp));\n    int x=h[n][0];\n    int y=h[n][1];\n    //cout<<x<<\" \"<<y<<endl;\n    int ans=0,man=0;\n    for(int i=1;;i+=2){\n      int f=1;\n      for(int j=0;j<i;j++){\n\tif(x<=0||x>=1500||y+j<=0||y+j>=1500)continue;\n\tif(ma[x][y+j]>m)continue;\n\tf=0;\n\tint t=ma[x][y+j];\n\t//\tcout<<t<<\" \";\n\tint ty=y+j;\n\tif(is_prime[t]){\n\t  //  cout<<'a'<<endl;\n\t  dp[x][ty]++;\n\t  if(dp[x][ty]==ans&&t>man)man=t;\n\t  if(dp[x][ty]>ans){\n\t    ans=dp[x][ty];\n\t    man=t;\n\t  }\n\t}\n\tdp[x+1][ty]=max(dp[x+1][ty],dp[x][ty]);\n\tdp[x+1][ty+1]=max(dp[x+1][ty+1],dp[x][ty]);\n\tdp[x+1][ty-1]=max(dp[x+1][ty-1],dp[x][ty]);\n      }\n      //\tcout<<endl;\n      if(f)break;\n      x++;\n      y--;\n    }\n    if(ans==0)man=0;\n    cout<<ans<<\" \"<<man<<endl;\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[(SIZE + 1)*(SIZE + 1) + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= (SIZE + 1)*(SIZE + 1);i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= (SIZE + 1)*(SIZE + 1);j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tcin >> m >> n;\n\t\tif (m == 0 || n == 0)return 0;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(y=SIZE-1;y>=0;y--){\n\t\t\tfor(x=SIZE-1;x>=0;x--){\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&\n\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x - 1]||(dp[y][x] == dp[y + 1][x - 1] && pr[y][x] < pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && \n\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x] || (dp[y][x] == dp[y + 1][x] && pr[y][x] < pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && \n\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x + 1] || (dp[y][x] == dp[y + 1][x + 1] && pr[y][x] < pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (y = 0;y < SIZE;y++) {\n\t\t\tfor (x = 0;x < SIZE;x++) {\n\t\t\t\tif (table[y][x] == n) {\n\t\t\t\t\tcout << dp[y][x] << \" \" << pr[y][x] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\n#define SIZE 1000\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (x >= 0 && y >= 0 && table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\n\t\toutput = false;\n\t\tfor (int i = 0;i < SIZE&&!output;i++) {\n\t\t\tfor (int j = 0;j < SIZE&&!output;j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\tprintf(\"%d %d\\n\", dp[y][x], pr[y][x]);\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,...) for(int i = (a)*(strlen(#__VA_ARGS__)!=0);i<(int)(strlen(#__VA_ARGS__)?__VA_ARGS__:(a));++i)\n#define per(i,a,...) for(int i = (strlen(#__VA_ARGS__)?__VA_ARGS__:(a))-1;i>=(int)(strlen(#__VA_ARGS__)?(a):0);--i)\n#define foreach(i, n) for(auto &i:(n))\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define all(x) (x).begin(), (x).end()\n#define bit(x) (1ll << (x))\nusing ll = long long;\n//const ll MOD = (ll)1e9+7;\nconst ll MOD = 998244353;\nconst int INF = (ll)1e9+7;\nconst ll INFLL = (ll)1e18;\nusing namespace std;\ntemplate<class t>\nusing vvector = vector<vector<t>>;\ntemplate<class t>\nusing vvvector = vector<vector<vector<t>>>;\ntemplate<class t>\nusing priority_queuer = priority_queue<t, vector<t>, greater<t>>;\ntemplate<class t, class u> bool chmax(t &a, u b){if(a<b){a=b;return true;}return false;}\ntemplate<class t, class u> bool chmin(t &a, u b){if(a>b){a=b;return true;}return false;}\n#ifdef DEBUG\n#define debug(x) cout<<\"LINE \"<<__LINE__<<\": \"<<#x<<\" = \"<<x<<endl;\n#else\n#define debug(x) (void)0\n#endif\n\nnamespace templates{\n  ll modpow(ll x, ll b){\n    ll res = 1;\n    while(b){\n      if(b&1)res = res * x % MOD;\n      x = x * x % MOD;\n      b>>=1;\n    }\n    return res;\n  }\n\n  ll modinv(ll x){\n    return modpow(x, MOD-2);\n  }\n\n  bool was_output = false;\n  template<class t>\n  void output(t a){\n    if(was_output)cout << \" \";\n    cout << a;\n    was_output = true;\n  }\n  void outendl(){\n    was_output = false;\n    cout << endl;\n  }\n  ll in(){\n    ll res;\n    scanf(\"%lld\", &res);\n    return res;\n  }\n\n  template<class t>\n  istream& operator>>(istream&is, vector<t>&x){\n    for(auto &i:x)is >> i;\n    return is;\n  }\n\n  template<class t, class u>\n  istream& operator>>(istream&is, pair<t, u>&x){\n    is >> x.first >> x.second;\n    return is;\n  }\n\n  template<class t>\n  void in(t&x){\n    cin >> x;\n  }\n\n  template<class t>\n  t in(){\n    t res; cin >> res; return res;\n  }\n\n  template<class t>\n  void out(t x){\n    cout << x;\n  }\n\n  template<class t>\n  vector<t> sorted(vector<t> line,function<bool(t,t)> comp=[](t a,t b){return a<b;}){\n    sort(line.begin(),line.end(),comp);\n    return line;\n  }\n\n  template<class t>\n  vector<t> reversed(vector<t> line){\n    reverse(line.begin(),line.end());\n    return line;\n  }\n}\n\nusing namespace templates;\n\nbool isprime(int x){\n  const int MAX_N = 1e6+10;\n  static vector<bool> prime;\n  if(prime.empty()){\n    prime.resize(MAX_N,true);\n    prime[1] = false;\n    rep(i,2,MAX_N){\n      if(prime[i]){\n        for(int j=i*2;j<MAX_N;j+=i){\n          prime[j] = false;\n        }\n      }\n    }\n  }\n  return prime[x];\n}\n\npii func(int n,int m){\n  static vvector<int> values;\n  if(values.empty()){\n    values.resize(1010,vector<int>(1010,-1));\n    int mx = 1;\n    int my = 0;\n    int px = 505;\n    int py = 505;\n    int dis = 1;\n    values[px][py] = 1;\n    int cnt = 1;\n    while(cnt<1e6+10){\n      rep(j,dis){\n        px += mx;\n        py += my;\n        values[px][py] = ++cnt;\n      }\n      int t = my;\n      my = -mx;\n      mx = t;\n      rep(j,dis){\n        px += mx;\n        py += my;\n        values[px][py] = ++cnt;\n      }\n      t = my;\n      my = -mx;\n      mx = t;\n      ++dis;\n    }\n  }\n  vvector<pii> dp(1010,vector<pii>(1010,pii(-1,-1)));\n  function<pii(int,int)> func =\n    [&](int x,int y){\n      if(values[x][y]==-1 or values[x][y]>m)return pii(0,0);\n      if(dp[x][y].first!=-1)return dp[x][y];\n      pii res(0,0);\n      rep(nx,x-1,x+2){\n        if(values[nx][y+1]==-1 or values[nx][y+1]>m)continue;\n        pii d = func(nx,y+1);\n        if(res.first<d.first){\n          res = d;\n        }\n        if(res.first==d.first and res.second < d.second){\n          res = d;\n        }\n      }\n      if(isprime(values[x][y])){\n        if(res.second==0){\n          res.second = values[x][y];\n        }\n        ++res.first;\n      }\n      return dp[x][y] = res;\n    };\n\n  rep(i,1010){\n    rep(j,1010){\n      if(values[i][j]==n){\n        return func(i,j);\n      }\n    }\n  }\n  return pii(0,0);\n}\n\nint main(){\n  int m;\n  int n;\n  while(m=in()){\n    n=in();\n    pii ans = func(n,m);\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX = 1010;\nint cave[MAX][MAX];\nint toIndex[1000010];\nint dp[MAX][MAX];\nint dx[] = {+1,+0,-1,+0};\nint dy[] = {+0,-1,+0,+1};\n\nbool isValid(int x,int y) { return 0 <= x && x < MAX && 0 <= y && y < MAX; }\n\nvoid pre_calc(){\n  memset(cave,-1,sizeof(cave));\n  int phase = 1;\n  int x = MAX/2, y = MAX/2, dir = 0;\n  while( phase <= 1000000 ){\n    toIndex[phase] = x + y * MAX;\n    cave[y][x] = phase++;\n    x += dx[dir], y += dy[dir];\n    if( cave[y+dy[(dir+1)%4]][x+dx[(dir+1)%4]] == -1 ) ( dir += 1 ) %= 4;\n  }\n}\n\nconst int  MAX_P = 1000010;\n\nbool isntprime[MAX_P+1]; \t\nvoid init(){\n  isntprime[0] = isntprime[1] = true;\n  int j;\t\n  for(int i=2;i<= MAX_P;i++)if(!isntprime[i])for(j=2*i;j<=MAX_P;j+=i)isntprime[j] = true;\n}\n\n\nvoid compute(int limit,int sp){\n  memset(dp,-1,sizeof(dp));\n  int sx = toIndex[sp] % MAX, sy = toIndex[sp] / MAX;\n  dp[sy][sx] = !isntprime[sp];\n  int maxi[2] = {0,0};\n  if( dp[sy][sx] > maxi[0] ) { maxi[0] = dp[sy][sx], maxi[1] = sp; }\n  REP(y,sy,MAX) rep(x,MAX) if( dp[y][x] != -1) {\n    for(int dx=-1;dx<=1;dx++){\n      int nx = x + dx, ny = y + 1;\n      if( !isValid(nx,ny) ) continue;\n      if( cave[ny][nx] > limit || cave[ny][nx] == -1 ) continue;\n      dp[ny][nx] = max(dp[ny][nx],dp[y][x]+!isntprime[cave[ny][nx]]);\n      if( !isntprime[cave[ny][nx]] ) {\n        if( dp[ny][nx] > maxi[0] ) { maxi[0] = dp[ny][nx]; maxi[1] = cave[ny][nx]; }\n        else if( dp[ny][nx] == maxi[0] ) maxi[1] = max(maxi[1],cave[ny][nx]);\n      }\n    }\n  }\n  cout << maxi[0] << \" \" << maxi[1] << endl;\n}\n\nint main(){\n  init();\n  pre_calc();\n  int m,n;\n  while( cin >> m >> n, m,n ) compute(m,n);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < n; i++)\nusing namespace std;\n\nint ban[1010][1010][2];\nint M, N;\nint D[4][2] = {{1, 0}, {0, -1}, {-1, 0}, {0, 1}};\nbool isprime[1000010];\nint px = 500;\nint py = 500;\n\n\nvoid solve() {\n\tint ans = 0;\n\tint ansp = 0;\n\tbool f = true;\n\tint cnt = 0;\n\twhile(f) {\n\t\tf = false;\n\t\tfor (int px2 = max(px - cnt, 0); px2 <= min(px + cnt, 1000); px2++) {\n\t\t\tint p = ban[py][px2][0];\n\t\t\tif (p == 0 or p > M) continue;\n\t\t\tf = true;\n\t\t\tif (isprime[p]) {\n\t\t\t\tban[py][px2][1] += 1;\n\t\t\t\tif (ans < ban[py][px2][1] or (ans == ban[py][px2][1] and ansp < p)){\n\t\t\t\t\tans = ban[py][px2][1];\n\t\t\t\t\tansp = p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\t\tif(px2 + j < 0) continue;\n\t\t\t\tban[py + 1][px2 + j][1] = max(ban[py + 1][px2 + j][1], ban[py][px2][1]);\n\t\t\t}\n\t\t}\n\t\tpy ++;\n\t\tcnt ++;\n\t}\n\tcout << ans << \" \" << ansp << endl;\n}\n\n\nint main() {\n\trep(i, 1000001) isprime[i] = true;\n\tfor (int i = 2; i < 1000001; i++) {\n\t\tif (isprime[i]) {\n\t\t\tfor(int i2 = i * 2; i2 < 1000001; i2 += i) {\n\t\t\t\tisprime[i2] = false;\n\t\t\t}\n\t\t}\n\t}\n\tisprime[1] = false;\n\tisprime[0] = false;\n\tint k = 1;\n\tint m = 1;\n\tint d = 0;\n\tban[py][px][0] = k;\n\twhile(k < 1000001) {\n\t\trep(i, m) {\n\t\t\tk += 1;\n\t\t\tpx += D[d][0];\n\t\t\tpy += D[d][1];\n\t\t\tban[py][px][0] = k;\n\t\t}\n\t\tif (d == 1 or d == 3) m ++;\n\t\td = (d + 1) % 4;\n\t}\n\tcin >> M >> N;\n\twhile (M) {\n\t\trep(i, 1001) {\n\t\t\trep(j, 1001) {\n\t\t\t\tban[i][j][1] = 0;\n\t\t\t}\n\t\t}\n\t\trep(i, 1001) {\n\t\t\trep(j, 1001) {\n\t\t\tif(ban[i][j][0] == N) {\n\t\t\t\tpx = j; \n\t\t\t\tpy = i;\n\t\t\t\ti = 100000;\n\t\t\t\tbreak;\n\t\t\t}}}\n\t\tsolve();\n\t\tcin >> M >> N;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\ntypedef pair<int,int> P;\nbool prime[1000001];\nint n,m;\nint fie[1200][1200];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nint numx[1000001],numy[1000001];\nint dp[1201][1201];\n\nvoid seive(){\n\tfor(int i=2;i<=1000000;i++)prime[i]=true;\n\tprime[0]=prime[1]=false;\n\tfor(int i=2;i<=1000000;i++){\n\t\tif(prime[i]){\n\t\t\tfor(int j=i*2;j<=1000000;j+=i)prime[j]=false;\n\t\t}\n\t}\n\tint x=501,y=501,i=1,cnt=0,d=0,cnt2=1;\n\twhile(i<=1000000){\n\t\tfie[x][y]=i;\n\t\tnumx[i]=x;\n\t\tnumy[i]=y;\n\t\tx+=dx[d];\n\t\ty+=dy[d];\n\t\tcnt++;\n\t\tif(cnt2==cnt){\n\t\t\td++;\n\t\t\tif(d==2)cnt2++;\n\t\t\tif(d==4)cnt2++,d=0;\n\t\t\tcnt=0;\n\t\t}\n\t\ti++;\n\t}\n}\n\nint main(void){\n\tseive();\n\twhile(1){\n\t\tscanf(\"%d%d\",&m,&n);\n\t\tif(m+n==0)break;\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tint mk=0;\n\t\tif(prime[n])mk++;\n\t\tdp[numx[n]][numy[n]]=mk;\n\t\tfor(int i=0;i<=1100;i++){\n\t\t\tfor(int j=0;j<=1100;j++){\n\t\t\t\tif(dp[j][i]>=0){\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\tif(fie[j+k][i+1]>=1 && fie[j+k][i+1]<=m){\n\t\t\t\t\t\t\tint mc=0;\n\t\t\t\t\t\t\tif(prime[fie[j+k][i+1]])mc++;\n\t\t\t\t\t\t\tdp[j+k][i+1]=max(dp[j+k][i+1],dp[j][i]+mc);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res2=0,res3=0;\n\t\tfor(int i=0;i<=1100;i++){\n\t\t\tfor(int j=0;j<=1100;j++){\n\t\t\t\tif(prime[fie[j][i]]){\n\t\t\t\t\tif(dp[j][i]>=1 && (dp[j][i]>res2 ||(dp[j][i]==res2 && fie[j][i]>res3))){\n\t\t\t\t\t\tres2=dp[j][i];\n\t\t\t\t\t\tres3=fie[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",res2,res3);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nint dx[4] = { 0,-1,0,1 };\nint dy[4] = { 1,0,-1,0 };\nP loc[1000001];\nint isp[1000001];\nint mp[2000][2000];\nvoid makemap() {\n\tP now = { 1000,1000 }; int d = 3; loc[1] = { 1000,1000 };\n\tmp[1000][1000] = 1;\n\tRep1(i, 2, 1000000) {\n\t\tint nx=now.first + dx[(1 + d) % 4];\n\t\tint ny = now.second + dy[(1 + d) % 4];\n\t\tif (!mp[nx][ny]) {\n\t\t\td = (1 + d) % 4; now = { nx,ny }; mp[nx][ny] = i; loc[i] = { nx,ny };\n\t\t}\n\t\telse {\n\t\t\tnx = now.first + dx[d];\n\t\t\tny = now.second + dy[d];\n\t\t\tnow = { nx,ny }; mp[nx][ny] = i; loc[i] = { nx,ny };\n\t\t}\n\t}\n}\nvoid setprime() {\n\tfill(isp + 2, isp + 1000001, 1);\n\tfor (int i = 2; i < 1000001; i++) {\n\t\tif (!isp[i])continue;\n\t\tfor (int j = 2 * i; j < 1000001; j += i) {\n\t\t\tisp[j] = 0;\n\t\t}\n\t}\n}\nP ans[2000][2000];\nvoid init() {\n\trep(i, 2000) {\n\t\trep(j, 2000) {\n\t\t\tans[i][j] = { 0,0 };\n\t\t}\n\t}\n}\nint main() {\n\tmakemap(); setprime();\n\tint n, m;\n\twhile (cin >> n >> m, n) {\n\t\tinit();\n\t\tfor (int i = 1998; i >= 0; i--) {\n\t\t\tfor (int j = 1; j <= 1998; j++) {\n\t\t\t\tif (mp[i][j] == 0 || mp[i][j] > n) {\n\t\t\t\t\tans[i][j] = { 0,0 }; continue;\n\t\t\t\t}\n\t\t\t\tans[i][j] = max({ ans[i + 1][j - 1],ans[i + 1][j],ans[i + 1][j + 1] });\n\t\t\t\tif (isp[mp[i][j]]) {\n\t\t\t\t\tif (ans[i][j].first == 0) {\n\t\t\t\t\t\tans[i][j] = { 1,mp[i][j] };\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tans[i][j].first++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tP sta = loc[m]; P out = ans[sta.first][sta.second];\n\t\tcout << out.first << \" \" << out.second << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nint main() {\n\tconst int SIZE = 1000;\n\tint m, n;\n\tbool prime[(SIZE + 1)*(SIZE + 1) + 1];\n\tint table[SIZE + 10][SIZE + 10];\n\tint dp[SIZE + 10][SIZE + 10];\n\tint pr[SIZE + 10][SIZE + 10];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tint res1, res2;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= (SIZE + 1)*(SIZE + 1);i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= (SIZE + 1)*(SIZE + 1);j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 || n == 0)return 0;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(y=SIZE-1;y>=0;y--){\n\t\t\tfor(x=SIZE-1;x>=0;x--){\n\t\t\t\tif (table[y][x] <= m) {\n\t\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m &&\n\t\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x - 1] || (dp[y][x] == dp[y + 1][x - 1] && pr[y][x] < pr[y + 1][x - 1]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (table[y + 1][x] <= m &&\n\t\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x] || (dp[y][x] == dp[y + 1][x] && pr[y][x] < pr[y + 1][x]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m &&\n\t\t\t\t\t\t\t(dp[y][x] < dp[y + 1][x + 1] || (dp[y][x] == dp[y + 1][x + 1] && pr[y][x] < pr[y + 1][x + 1]))) {\n\t\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (y = 0;y < SIZE;y++) {\n\t\t\tfor (x = 0;x < SIZE;x++) {\n\t\t\t\tif (table[y][x] == n) {\n\t\t\t\t\tres1 = dp[y][x];\n\t\t\t\t\tres2 = pr[y][x];\n\t\t\t\t\t//printf(\"%d\\n\", dp[y][x]);\n\t\t\t\t\t//cout << dp[y][x] << \" \";\n\t\t\t\t\t//cout << pr[y][x] << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * D.cpp\n *\n *  Created on: 2017/06/25\n *      Author: aihara\n */\n\n#include <bits/stdc++.h>\n\n#define rep(i, from, to) for (int i = from; i < to; ++i)\n#define REP(i, from, to) for (int i = from; i <= to; ++i)\n#define dbp(x) cout<<#x<<\": \"<<x<<endl;\n#define dbp2(x,y) cout<<#x<<\",\"<<#y<<\": \"<<x<<\",\"<<y<<endl;\n#define dbp3(x,y,z) cout<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<x<<\",\"<<y<<\",\"<<z<<endl;\n#define dbp4(w,x,y,z) cout<<#w<<\",\"<<#x<<\",\"<<#y<<\",\"<<#z<<\": \"<<w<<\",\"<<x<<\",\"<<y<<\",\"<<z<<endl;\n\nusing namespace std;\n\nstruct answer {\n\tint num, last;\n\tanswer() {\n\t\tnum = -1;\n\t\tlast = -1;\n\t}\n\tanswer(int n, int l) {\n\t\tnum = n;\n\t\tlast = l;\n\t}\n\tbool operator<(const answer &a) const {\n\t\tif (num == a.num) {\n\t\t\treturn last < a.last;\n\t\t} else {\n\t\t\treturn num < a.num;\n\t\t}\n\t}\n};\ntypedef struct answer answer;\nconst int MAX_M = 1000010;\nconst int MAX_W = 1011;\nconst int SIZE = MAX_W * MAX_W + 1000;\nint g[MAX_W][MAX_W];\nbool p[MAX_W][MAX_W];\nbool isprime[SIZE];\nint center = MAX_W / 2;\nanswer ans;\nint di[3] = { -1, -1, -1 };\nint dj[3] = { -1, 0, 1 };\nint n, m;\ntypedef pair<int, int> P;\nP n2ij[SIZE];\n\nvoid eratos() {\n\tisprime[0] = isprime[1] = true;\n\tfor (int i = 2; i < SIZE; ++i) {\n\t\tif (isprime[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int j = i + i; j < SIZE; j += i) {\n\t\t\tisprime[j] = true;\n\t\t}\n\t}\n}\n\nbool ok(int &i, int &j) {\n\treturn 0 <= i && i < MAX_W && 0 <= j && j < MAX_W;\n}\n\nvoid up(int &i, int &j, int cnt, int &k) {\n\trep(u,0,cnt+1)\n\t{\n\t\tif (ok(i, j)) {\n\t\t\tg[i][j] = k;\n\t\t\tp[i][j] = isprime[k];\n\t\t\tn2ij[k] = P(i, j);\n\t\t\tk++;\n\t\t\ti--;\n\t\t} else {\n\t\t\t//error!\n\t\t}\n\t}\n\ti++;\n\tj--;\n}\n\nvoid left(int &i, int &j, int cnt, int &k) {\n\trep(l,0,cnt+1)\n\t{\n\t\tif (ok(i, j)) {\n\t\t\tg[i][j] = k;\n\t\t\tp[i][j] = isprime[k];\n\t\t\tn2ij[k] = P(i, j);\n\t\t\tk++;\n\t\t\tj--;\n\t\t} else {\n\t\t\t//error!\n\t\t}\n\t}\n\tj++;\n\ti++;\n}\n\nvoid down(int &i, int &j, int cnt, int &k) {\n\trep(l,0,cnt+1)\n\t{\n\t\tif (ok(i, j)) {\n\t\t\tg[i][j] = k;\n\t\t\tp[i][j] = isprime[k];\n\t\t\tn2ij[k] = P(i, j);\n\t\t\tk++;\n\t\t\ti++;\n\t\t} else {\n\t\t\t//error!\n\t\t}\n\t}\n\ti--;\n\tj++;\n}\n\nvoid right(int &i, int &j, int cnt, int &k) {\n\trep(l,0,cnt+1)\n\t{\n\t\tif (ok(i, j)) {\n\t\t\tg[i][j] = k;\n\t\t\tp[i][j] = isprime[k];\n\t\t\tn2ij[k] = P(i, j);\n\t\t\tk++;\n\t\t\tj++;\n\t\t} else {\n\t\t\t//error!\n\t\t}\n\t}\n\tj--;\n\ti--;\n}\n\nvoid makeHole() {\n\tint i = center, j = center;\n\tint k = 1, cnt = 1;\n\tg[i][j] = k;\n\tp[i][j] = isprime[k];\n\tn2ij[k] = P(i, j);\n\tj++;\n\tk++;\n\twhile (ok(i, j) && k < MAX_W * MAX_W) {\n//\t\tdbp4(i - center, j - center, g[i][j], k);\n\t\tup(i, j, cnt, k);\n//\t\tdbp4(i - center, j - center, g[i][j], k);\n\t\tleft(i, j, cnt, k);\n//\t\tdbp4(i - center, j - center, g[i][j], k);\n\t\tdown(i, j, cnt, k);\n//\t\tdbp4(i - center, j - center, g[i][j], k);\n\t\tright(i, j, cnt, k);\n//\t\tdbp4(i - center, j - center, g[i][j], k);\n\t\ti++;\n\t\tj++;\n\t\tcnt += 2;\n\t}\n}\n\nanswer dp[MAX_W][MAX_W];\nvoid doDP(int si, int sj) {\n\tans = answer(-1, -1);\n\tif (!p[si][sj]) {\n\t\tdp[si][sj] = answer(1, g[si][sj]);\n\t} else {\n\t\tdp[si][sj] = answer(0, 0);\n\t}\n\tans = max(ans, dp[si][sj]);\n\tint l = max(0, sj - 1), r = min(MAX_W - 1, sj + 1);\n\tint pl = sj, pr = sj;\n\trep(i,si+1,MAX_W)\n\t{\n\t\tREP(j, l, r)\n\t\t{\n\t\t\tanswer a;\n\t\t\trep(k, 0, 3) //\n\t\t\t{\n\t\t\t\tint pi = i + di[k], pj = j + dj[k];\n\t\t\t\tif (ok(i, j) && ok(pi, pj) && dp[pi][pj].num != -1 && pl <= pj\n\t\t\t\t\t\t&& pj <= pr && g[i][j] <= m && g[pi][pj] <= m) {\n\t\t\t\t\tanswer a = dp[pi][pj];\n\t\t\t\t\tif (!p[i][j]) {\n\t\t\t\t\t\ta.num++;\n\t\t\t\t\t\ta.last = g[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j] = max(dp[i][j], a);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (g[i][j] <= m) {\n\t\t\t\tans = max(ans, dp[i][j]);\n\n\t\t\t}\n\t\t}\n\t\tpl = l;\n\t\tpr = r;\n\t\tl = max(l - 1, 0);\n\t\tr = min(r + 1, MAX_W - 1);\n\n\t}\n}\n\nvoid solve() {\n\teratos();\n\tmakeHole();\n\twhile (cin >> m >> n, m || n) {\n\n\t\trep(i,0,MAX_W)\n\t\t{\n\t\t\tfill(dp[i], dp[i] + MAX_W, answer());\n\t\t}\n\t\tdoDP(n2ij[n].first, n2ij[n].second);\n\t\tcout << ans.num << \" \" << ans.last << endl;\n\t}\n}\n\nint main() {\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, -1, 0, 1, 1, 1, -1, -1};\nconst int L = 5000;\nconst int N = 1000000;\nint grid[L][L];\nvoid init(){\n  int l = 1;\n  int x = L / 2;\n  int y = L / 2;\n  int r = 0;\n  int rest = 1;\n  for(int y = 0; y < L; y++) {\n    for(int x = 0; x < L; x++){\n      grid[y][x] = INF;\n    }\n  }\n  for(int i = 1; i <= N; i++){\n    assert(grid[y][x] == INF);\n    grid[y][x] = i;\n    x += dx[r];\n    y += dy[r];\n    rest--;\n    if(rest == 0){\n      r = (r + 1) % 4;\n      if(r % 2 == 0) l++;\n      rest = l;\n    }\n  }\n}\n\nbool prime[N + 1] = {};\nvoid make_prime(){\n  for(int i = 2; i <= N; i++) prime[i] = true;\n  for(int i = 2; i <= N; i++) if(prime[i]){\n    for(int j = 2 * i; j <= N; j += i){\n      prime[j] = false;\n    }\n  }\n}\n\n\nint main(){\n  init();\n  make_prime();\n  int max_n, st;\n  while(cin >> max_n >> st && max_n){\n    static int dp[L][L];\n    for(int y = 0; y < L ; y++){\n      for(int x = 0; x < L; x++){\n        if(grid[y][x] == st) dp[y][x] = prime[ grid[y][x] ];\n        else                 dp[y][x] = -INF;\n      }\n    }\n    int ans1 = 0;\n    int ans2 = 0;\n    for(int y = 1; y < L; y++){\n      for(int x = 0; x < L; x++) if(grid[y][x] <= max_n){\n        for(int dx = -1; dx <= 1; dx++)if(x + dx >= 0 && x + dx < L){\n          dp[y][x] = max(dp[y][x], dp[y - 1][x + dx] + prime[ grid[y][x] ]);\n          if(dp[y][x] > ans1 && dp[y][x] > 0 && prime[ grid[y][x] ]){\n            ans1 = dp[y][x];\n            ans2 = grid[y][x];\n          }else if(dp[y][x] == ans1 && dp[y][x] > 0 && prime[ grid[y][x] ]){\n            ans2 = max(ans2, grid[y][x]);\n          }\n        }\n      }\n    }\n    printf(\"%d %d\\n\", ans1, ans2);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\n#define SIZE 1000\n\nint main() {\n\tint m, n;\n\tbool prime[SIZE*SIZE + 1];\n\tint table[SIZE][SIZE], dp[SIZE][SIZE], pr[SIZE][SIZE];\n\tint y = 500, x = 499;\n\tint a = 1;\n\tbool output;\n\n\tprime[0] = true;prime[1] = true;\n\tfor (int i = 2;i <= SIZE*SIZE;i++) {\n\t\tif (!prime[i]) {\n\t\t\tfor (int j = i * 2;j <= SIZE*SIZE;j += i) {\n\t\t\t\tprime[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\ttable[y][x] = a;a++;x++;\n\tfor (int i = 1;i < SIZE;i++) {\n\t\tfor (int j = 0;j < i;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)y++;\n\t\t\telse y--;\n\t\t}\n\t\tfor (int j = 0;j < i + 1;j++) {\n\t\t\ttable[y][x] = a;\n\t\t\ta++;\n\t\t\tif (i % 2 == 0)x++;\n\t\t\telse x--;\n\t\t}\n\t}\n\twhile (true) {\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0)break;\n\t\t\n\t\tfor (int i = 0;i < SIZE;i++) {\n\t\t\tfor (int j = 0;j < SIZE;j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t\tpr[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\ty = SIZE - 1;x = SIZE - 1;\n\t\twhile (table[y][x] > m) {\n\t\t\tif (x > 0)x--;\n\t\t\telse {\n\t\t\t\ty--;\n\t\t\t\tx = SIZE - 1;\n\t\t\t}\n\t\t}\n\t\twhile (y >= 0) {\n\t\t\twhile (x >= 0) {\n\t\t\t\tif (y + 1 < SIZE) {\n\t\t\t\t\tif (x > 0 && table[y + 1][x - 1] <= m&&(dp[y][x]<dp[y + 1][x - 1]||(dp[y][x]<dp[y + 1][x - 1]==pr[y][x]<pr[y + 1][x - 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x - 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (table[y + 1][x] <= m && (dp[y][x]<dp[y + 1][x] || (dp[y][x]<dp[y + 1][x] == pr[y][x]<pr[y + 1][x]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x];\n\t\t\t\t\t}\n\t\t\t\t\tif (x + 1 < SIZE&&table[y + 1][x + 1] <= m && (dp[y][x]<dp[y + 1][x + 1] || (dp[y][x]<dp[y + 1][x + 1] == pr[y][x]<pr[y + 1][x + 1]))) {\n\t\t\t\t\t\tdp[y][x] = dp[y + 1][x + 1];\n\t\t\t\t\t\tpr[y][x] = pr[y + 1][x + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!prime[table[y][x]]) {\n\t\t\t\t\tdp[y][x]++;\n\t\t\t\t\tif (pr[y][x] == 0) {\n\t\t\t\t\t\tpr[y][x] = table[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx--;\n\t\t\t}\n\t\t\ty--;\n\t\t\tx = SIZE - 1;\n\t\t}\n\t\t\n\t\toutput = false;\n\t\tfor (int i = 0;i < SIZE&&(!output);i++) {\n\t\t\tfor (int j = 0;j < SIZE&&(!output);j++) {\n\t\t\t\tif (table[i][j] == n) {\n\t\t\t\t\t//printf(\"%d %d\\n\", dp[i][j], pr[i][j]);\n\t\t\t\t\toutput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nconst int dy[] = {0,-1,0,1}, dx[] = {1,0,-1,0};\nconst int base = 1000;\nint n,m;\nint id[2000][2000];\nint p[2000][2000];\npii dp[2000][2000];\n\nint isPrime(int x){\n  if(x<=1)return 0;\n  for(int i=2;i*i<=x;i++){\n    if(x%i==0)return 0;\n  }\n  return 1;\n}\n\nint main(){\n  int y = base, x = base;\n  id[y][x] = 1; p[y][x] = 0;\n\n  int cnt = 2,len = 1, d = 0;\n  do{\n    for(int i=0;i<len;i++){\n      y+=dy[d]; x+=dx[d];\n      p[y][x] = isPrime(cnt);\n      id[y][x] = cnt++;\n    }\n    if(d&1)len++;\n    (d += 1) %= 4;\n  }while(cnt<=1000000);\n\n  while(cin >> m >> n, m){\n    for(int i=0;i<2*base;i++)\n      for(int j=0;j<2*base;j++)dp[i][j] = pii(-1,0);\n\n    for(int i=0;i<2*base;i++){\n      for(int j=0;j<2*base;j++){\n\tif(id[i][j] == n){\n\t  if(p[i][j])dp[i][j] = pii(1,id[i][j]);\n\t  else dp[i][j] = pii(0,0);\n\t}else if(dp[i][j].first < 0)continue;\n\t\n\tfor(int k=-1;k<=1;k++){\n\t  if(1<=id[i+1][j+k] && id[i+1][j+k]<=m){\n\t    if(p[i+1][j+k] && dp[i+1][j+k].first < dp[i][j].first+1){\n\t      dp[i+1][j+k] = pii(dp[i][j].first+1, id[i+1][j+k]);\n\t    }\n\t    if(!p[i+1][j+k] && dp[i+1][j+k] < dp[i][j]){\n\t      dp[i+1][j+k] = dp[i][j];\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    pii ans = pii(0,0);\n    for(int i=0;i<2*base;i++){\n      for(int j=0;j<2*base;j++)ans = max(ans, dp[i][j]);\n    }\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n\nint ana[1000][1000], sosuu[1000001], dp[1000][1000], maxprime[1000][1000], pointx[1000001], pointy[1000001], dx[3] = {-1, 0, 1};\n\nint max(int a, int b, int c){\n    if(a>=b && a>=c) return a;\n    else if(b>=a && b>=c) return b;\n    else if(c>=a && c>=b) return c;\n}\n\nvoid setdou(int m){\n    int x=500, y=500, i, j, k, p=1;\n    for(i=0;i<1000;i++) for(j=0;j<1000;j++) ana[i][j] = 0;\n    i=1;\n    j=2;\n    ana[y][x-1] = p;\n    pointx[p] = x-1;\n    pointy[p] = y;\n    p++;\n    if(p > m) return;\n    ana[y][x] = p;\n    pointx[p] = x;\n    pointy[p] = y;\n    p++;\n    if(p > m) return;\n    for(k=1;k<=i;k++){ //ue\n        y--;\n        ana[y][x] = p;\n        pointx[p] = x;\n        pointy[p] = y;\n        p++;\n    }\n    if(p > m) return;\n    for(k=1;k<=j;k++){ //hidari\n        x--;\n        ana[y][x] = p;\n        pointx[p] = x;\n        pointy[p] = y;\n        p++;\n    }\n    if(p > m) return;\n    for(i=2,j=3;i<1000&&j<1000;i++,j++){\n        for(k=1;k<=i;k++){ //sita\n            y++;\n            ana[y][x] = p;\n            pointx[p] = x;\n            pointy[p] = y;\n            p++;\n        if(p > m) return;\n        }\n        i++;\n        for(k=1;k<=j;k++){ //migi\n            x++;\n            ana[y][x] = p;\n            pointx[p] = x;\n            pointy[p] = y;\n            p++;\n        if(p > m) return;\n        }\n        j++;\n        for(k=1;k<=i;k++){ //ue\n            y--;\n            ana[y][x] = p;\n            pointx[p] = x;\n            pointy[p] = y;\n            p++;\n        if(p > m) return;\n        }\n        for(k=1;k<=j;k++){ //hidari\n            x--;\n            ana[y][x] = p;\n            pointx[p] = x;\n            pointy[p] = y;\n            p++;\n        if(p > m) return;\n        }\n    }\n}\n\nint main(void){\n    int n, m, p=3, i, j, k;\n\n    // エラトステネスの篩\n    for(i=0;i<1000001;i++) sosuu[i] = 1;\n    sosuu[1] = 0;\n    for(i=1;i*i<1000001;i++) if (sosuu[i]) for (j=i*2;j<1000001;j+=i) sosuu[j] = 0;\n    \n    //入力と探索\n    while(1){\n        int m=0, n=0, x, y, e;\n        scanf(\"%d %d\", &m, &n);\n        if(m==0 && n==0) break;\n        setdou(m);\n        for(i=0;i<1000;i++) for(j=0;j<1000;j++) dp[i][j] = -1;\n        x = pointx[n];\n        y = pointy[n];\n        dp[y][x] = sosuu[n];\n\n        //dpテーブルの作成\n        int answer = 0;\n        for(i=0;i<1000;i++){\n            for(j=0;j<1000;j++){\n                answer = max(answer, dp[i][j], -10000);\n                if(ana[i][j] == 0) continue;\n                if(dp[i][j] != -1){\n                    if((i+1) >= 1000) continue;\n                    for(e=0;e<3;e++){\n                        int nx = j + dx[e];\n                        if(nx < 0 || 1000 <= nx) continue;\n                        if(ana[i+1][nx] == 0) continue;\n                        dp[i+1][nx] = max(dp[i+1][nx], dp[i][j]+sosuu[ana[i+1][nx]], -10000);\n                        answer = max(answer, dp[i+1][nx], -10000);\n                    }\n                }\n            }\n        }\n\n        //同じdp数のところから最後に通る素数を出す\n        int saigo = 0;\n        for(i=0;i<1000;i++){\n            for(j=0;j<1000;j++){\n                if(ana[i][j] == 0) continue;\n                if(dp[i][j] == answer){\n                    if(sosuu[ana[i][j]]){\n                        saigo = max(saigo, ana[i][j], -10000);\n                    }\n                }\n            }\n        }\n        if(answer == 0) printf(\"0 0\\n\");\n        else printf(\"%d %d\\n\", answer, saigo);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n\nstruct P{\n\tint fi,se;\n};\n\n#define bool int\n#define false 0\n#define true 1\n#define P struct P\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint n,m;\nint board[1111][1111];\nbool is_prime[1111111];\n\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\n\nP mem[1111][1111];\nP none;\n\nP max(P a,P b){\n\tif(a.fi==b.fi){\n\t\tif(a.se>b.se)return a;\n\t\telse return b;\n\t}else if(a.fi>b.fi)return a;\n\telse return b;\n}\n\nP dfs(int x,int y){\n\tif(mem[x][y].fi!=-1)return mem[x][y];\n\tP res;\n\tres.fi=0; res.se=0;\n\trepl(xx,x-1,x+2){\n\t\tif(xx>=0&&xx<1111&&y+1>=0&&y+1<1111&&board[xx][y+1]!=0&&board[xx][y+1]<=m)res=max(res,dfs(xx,y+1));\n\t}\n\tif(is_prime[board[x][y]]){\n\t\tres.fi++;\n\t\tif(res.se==0)res.se=board[x][y];\n\t}\n\treturn mem[x][y]=res;\n}\n\nint main(){\n\t//cin.sync_with_stdio(false);\n\tmemset(is_prime,1,sizeof(is_prime));\n\tis_prime[0]=is_prime[1]=false;\n\trep(i,1111111){\n\t\tif(is_prime[i]){\n\t\t\tfor(int j=i*2;j<1111111;j+=i)is_prime[j]=false;\n\t\t}\n\t}\n\tint num=1;\n\tint x=1111/2,y=1111/2;\n\tint len=1,state=0;\n\tnone.fi=-1; none.se=-1;\n\twhile(1){\n\t\trep(i,2){\n\t\t\trep(j,len){\n\t\t\t\tboard[x][y]=num++;\n\t\t\t\tx+=dx[state];y+=dy[state];\n\t\t\t}\n\t\t\tstate=(state+1)%4;\n\t\t}\n\t\tif(num>1000000)break;\n\t\tlen++;\n\t}\n\twhile(1){\n\t\tscanf(\"%d %d\",&m,&n);\n\t\tif(n==0)break;\n\t\tint sx,sy;\n\t\trep(i,1111)rep(j,1111){\n\t\t\tif(board[i][j]==n){\n\t\t\t\tsx=i;sy=j;\n\t\t\t}\n\t\t}\n\t\trep(i,1111)rep(j,1111)mem[i][j]=none;\n\t\tP res=dfs(sx,sy);\n\t\tprintf(\"%d %d\\n\", res.fi,res.se);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#define N 1000000\n\ntypedef struct{\n  bool ch;\n  int last;\n  int n;\n}data;\n  \n\nbool prime[1000006]={0};\ndata nowmap[1505][1505]={0};\nint map[1505][1505]={0};\nint mapx[1000006]={0};\nint mapy[1000006]={0};\n//nx=x+d[i],ny=y+d[i^1]\nint d[4]={0,1,0,-1};\nint m,n,last=-1,maxnum;\n\ndata solve(int num);\nvoid setprime();\nvoid set();\nvoid search();\n\nint main(void){\n  int i,j,k;\n  data ans;\n  set();\n  setprime();\n  while(1){\n    scanf(\"%d %d\",&m,&n);\n    if(n+m==0)break;\n    last = 0;\n    maxnum=0;\n    search();\n    for(i=1;i<=m;i++)nowmap[mapx[i]][mapy[i]].ch=0;\n    //printf(\"max%d\\n\",maxnum);\n    ans = solve(n);\n    printf(\"%d %d\\n\",ans.n,ans.last);\n  }\n  /*for(i=1;i<=N;i++){\n    if(mapx[i]>1000||mapx[i]<0)printf(\"x%d %d\\n\",i,mapx[i]);\n    if(mapy[i]>1000||mapy[i]<0)printf(\"y%d %d\\n\",i,mapy[i]);\n    }*/\n  return 0;\n}\n\nvoid set(){\n  int i,j=0,nowx=500,nowy=500,count=1,dir=1;\n  map[500][500]=1;\n  mapx[1]=500;\n  mapy[1]=500;\n  for(i=1;;i++){\n    for(j=1;j<=i;j++){\n      nowx+=d[dir];\n      nowy+=d[dir^1];\n      map[nowx][nowy]=++count;\n      mapx[count]=nowx;\n      mapy[count]=nowy;\n      //if(count==N)printf(\"%d %d %d %d\\n\",nowx,nowy,count,dir);\n      if(count==N)return;\n    }\n    dir++;\n    dir%=4;\n    for(j=1;j<=i;j++){\n      nowx+=d[dir];\n      nowy+=d[dir^1];\n      map[nowx][nowy]=++count;\n      mapx[count]=nowx;\n      mapy[count]=nowy;\n      //if(count==N)printf(\"%d %d %d %d\\n\",nowx,nowy,count,dir);\n      if(count==N)return;\n    }\n    dir++;\n    dir%=4;\n  }\n}\n\nvoid setprime(){\n  int i,j;\n  prime[0]=1;\n  prime[1]=1;\n  for(i=2;i<=N;i++){\n    if(prime[i]==1)continue;\n    for(j=2;i*j<=N;j++)prime[i*j]=1;\n  }\n  //for(i=0;i<=N;i++)printf(\"%d \",prime[i]);\n}\n\ndata solve(int num){\n  int x=mapx[num],y=mapy[num];\n  int i,nextx=x,nexty=y+1;\n  data d,rd;\n  bool ch=0;\n  rd.ch=1;\n  rd.last=0;\n  rd.n=0;\n  if(nowmap[x][y].ch==1)return nowmap[x][y];\n  //nowmap[x][y]=next;\n  for(i=-1;i<=1;i++){\n    nextx = x + i;\n    if(map[nextx][nexty]==0||map[nextx][nexty]>m)continue;\n    ch=1;\n    d=solve(map[nextx][nexty]);\n    if(rd.n<d.n||(rd.n==d.n&&rd.last<d.last)){\n      rd.last=d.last;\n      rd.n=d.n;\n    }\n  }\n  if(prime[num]==0){\n    rd.n++;\n    if(rd.last==0)rd.last=num;\n  }\n  nowmap[x][y]=rd;\n  return rd;\n}\n\nvoid search(){\n  int count=0,x=mapx[n],y=mapy[n];\n  while(map[x][y]<=m&&map[x][y]>=1){\n    y++;\n    count++;\n  }\n  maxnum=count+1;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define A 1000100\n#define B 2020\n#include<math.h>\n\nint m,s;\nint max_last = 0;\nint max = -1;\ntypedef struct{\n    int count; //ここを調査した後の，調査してきた洞窟の総数の最大値\n    int num; //0からスタート，何番目の洞窟か\n    int last;\n} cave_struct;\ncave_struct cave[B][B]; //cave[1000][1000]が0番目に対応\n\nint N[A] = {}; //0が格納されていれば（添字＋1）は素数．全て素数で初期化．\nvoid setPrime(){\n    int i, j;\n    int sqrt_A = sqrt(A);\n    N[0] = 1;\n    for(i = 1; i <= sqrt_A; i++){\n        if(N[i] == 0){\n            for(j = 2; j * (i + 1) <= A; j++){\n                N[j * (i + 1) - 1] = 1;\n            }\n        }\n    }\n}\nint co = 0;\nint pos_x = 1000, pos_y = 1000, f_x, f_y;\nint next = 1;\nvoid setCave_1(){\n    int i,j;\n    for(i = 0; i < B; i++){\n        for(j = 0; j < B; j++){\n            cave[i][j].count = -1;\n            cave[i][j].num = -1; //未登録\n        }\n    }\n}\nvoid setCave(){\n    int i;\n    while(1){\n        for(i = 0; i < next; i++){\n            //右へ\n            cave[pos_y][pos_x++].num = co++;\n            if(co == s){\n                f_x = pos_x-1; f_y = pos_y;\n            }\n            if(co > m-1) break;\n        }\n        if(co > m-1) break;\n        for(i = 0; i < next; i++){\n            //上へ\n            cave[pos_y--][pos_x].num = co++;\n            if(co == s){\n                f_x = pos_x; f_y = pos_y+1;\n            }\n            if(co > m-1) break;\n        }\n        if(co > m-1) break;\n        next++;\n        for(i = 0; i < next; i++){\n            //左へ\n            cave[pos_y][pos_x--].num = co++;\n            if(co == s){\n                f_x = pos_x+1; f_y = pos_y;\n            }\n            if(co > m-1) break;\n        }\n        if(co > m-1) break;\n        for(i = 0; i < next; i++){\n            //下へ\n            cave[pos_y++][pos_x].num = co++;\n            if(co == s){\n                f_x = pos_x; f_y = pos_y-1;\n            }\n            if(co > m-1) break;\n        }\n        if(co > m-1) break;\n        next++;\n    }\n    cave[f_y][f_x].count = 1 - N[cave[f_y][f_x].num];\n    //printf(\"%d\\n\",cave[f_y][f_x].count);\n    if(cave[f_y][f_x].num == 1){\n        cave[f_y][f_x].last = cave[f_y][f_x].num;\n    }\n    max = cave[f_y][f_x].count;\n    max_last = cave[f_y][f_x].num;\n\n}\n\n\nvoid expCave(int y, int x){\n    if(cave[y][x].count == -1) return;\n    //printf(\"%d, %d\\n\",cave[y][x].num+1,cave[y][x].count);\n    //printf(\" %d, %d\\n\",max_last+1,max);\n\n\n    if(cave[y][x].count > max){\n        max = cave[y][x].count;\n        max_last = cave[y][x].num;\n        //printf(\"%d, %d\\n\",cave[y][x].num+1,cave[y][x].count);\n        //printf(\"  %d, %d\\n\",max_last,max);\n    }else if(cave[y][x].count == max && cave[y][x].last > max_last){\n        max = cave[y][x].count;\n        max_last = cave[y][x].num;\n        //printf(\"  %d, %d\\n\",max_last,max);\n    }\n\n\n    //printf(\" %d, %d\\n\",max_last,max);\n    if(cave[y+1][x-1].num != -1){\n        if(cave[y+1][x-1].count <= cave[y][x].count){\n            cave[y+1][x-1].count = cave[y][x].count;\n            if(N[cave[y+1][x-1].num] == 0){\n                cave[y+1][x-1].last = cave[y+1][x-1].num;\n                cave[y+1][x-1].count++;\n                if(cave[y+1][x-1].count > max){\n                    max = cave[y+1][x-1].count;\n                    max_last = cave[y+1][x-1].num;\n                    //printf(\"%d, %d\\n\",max_last,max);\n                }else if(cave[y+1][x-1].count == max && cave[y+1][x-1].num > max_last){\n                    max = cave[y+1][x-1].count;\n                    max_last = cave[y+1][x-1].num;\n                    //printf(\"%d, %d\\n\",max_last,max);\n                }\n            }else{\n                cave[y+1][x-1].last = cave[y][x].last;\n            }\n        }\n    }\n    //printf(\" %d, %d\\n\",max_last,max);\n    if(cave[y+1][x].num != -1){\n        if(cave[y+1][x].count <= cave[y][x].count){\n            cave[y+1][x].count = cave[y][x].count;\n            if(N[cave[y+1][x].num] == 0){\n                cave[y+1][x].last = cave[y+1][x].num;\n                cave[y+1][x].count++;\n                if(cave[y+1][x].count > max){\n                    max = cave[y+1][x].count;\n                    max_last = cave[y+1][x].num;\n                    //printf(\"%d, %d\\n\",max_last,max);\n                }else if(cave[y+1][x].count == max && cave[y+1][x].num > max_last){\n                    max = cave[y+1][x].count;\n                    max_last = cave[y+1][x].num;\n                    //printf(\"%d, %d\\n\",max_last,max);\n                }\n            }else{\n                cave[y+1][x].last = cave[y][x].last;\n            }\n        }\n    }\n    //printf(\" %d, %d\\n\",max_last,max);\n    if(cave[y+1][x+1].num != -1){\n        if(cave[y+1][x+1].count <= cave[y][x].count){\n            cave[y+1][x+1].count = cave[y][x].count;\n            if(N[cave[y+1][x+1].num] == 0){\n                cave[y+1][x+1].last = cave[y+1][x+1].num;\n                cave[y+1][x+1].count++;\n                if(cave[y+1][x+1].count > max){\n                    max = cave[y+1][x+1].count;\n                    max_last = cave[y+1][x+1].num;\n                    //printf(\"%d, %d\\n\",max_last,max);\n                }else if(cave[y+1][x+1].count == max && cave[y+1][x+1].num > max_last){\n                    max = cave[y+1][x+1].count;\n                    max_last = cave[y+1][x+1].num;\n                    //printf(\"%d, %d\\n\",max_last,max);\n                }\n            }else{\n                cave[y+1][x+1].last = cave[y][x].last;\n            }\n        }\n    }\n    //printf(\" %d, %d\\n\",max_last,max);\n\n}\n\nint main(void){\n    setPrime();\n    while(1){\n        scanf(\"%d %d\", &m, &s);\n        if(!m && !s) break;\n        co = 0; pos_x = 1000; pos_y = 1000; next = 1; max_last = 0; max = -1;\n        setCave_1();\n        setCave();\n        //printf(\"(%d, %d)\\n\",f_x,f_y);\n        for(int i = 1; i < B-1; i++){\n            for(int j = 1; j < B-1; j++){\n                expCave(i, j);\n            }\n        }\n        if(max == 0){\n            printf(\"0 0\\n\");\n        }else{\n            printf(\"%d %d\\n\",max,max_last+1);\n        }\n        /*\n        for(int i =  1005; i <= 1015; i++){\n            for(int j = 990; j <= 1000; j++){\n                printf(\"%2d \",cave[i][j].num);\n            }\n            printf(\"\\n\");\n        }\n        */\n        \n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define repl(i,a,b) for(i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n\nstruct P{\n\tint fi,se;\n};\n\n#define bool int\n#define false 0\n#define true 1\n#define P struct P\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint n,m;\nint board[1111][1111];\nbool is_prime[1111111];\n\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\n\nP mem[1111][1111];\nP none;\n\nP max(P a,P b){\n\tif(a.fi==b.fi){\n\t\tif(a.se>b.se)return a;\n\t\telse return b;\n\t}else if(a.fi>b.fi)return a;\n\telse return b;\n}\n\nP dfs(int x,int y){\n\tif(mem[x][y].fi!=-1)return mem[x][y];\n\tP res;\n\tres.fi=0; res.se=0;\n\tint xx;\n\trepl(xx,x-1,x+2){\n\t\tif(xx>=0&&xx<1111&&y+1>=0&&y+1<1111&&board[xx][y+1]!=0&&board[xx][y+1]<=m)res=max(res,dfs(xx,y+1));\n\t}\n\tif(is_prime[board[x][y]]){\n\t\tres.fi++;\n\t\tif(res.se==0)res.se=board[x][y];\n\t}\n\treturn mem[x][y]=res;\n}\n\nint main(){\n\t//cin.sync_with_stdio(false);\n\tmemset(is_prime,1,sizeof(is_prime));\n\tis_prime[0]=is_prime[1]=false;\n\tint i,j;\n\trep(i,1111111){\n\t\tif(is_prime[i]){\n\t\t\tint j;\n\t\t\tfor(j=i*2;j<1111111;j+=i)is_prime[j]=false;\n\t\t}\n\t}\n\tint num=1;\n\tint x=1111/2,y=1111/2;\n\tint len=1,state=0;\n\tnone.fi=-1; none.se=-1;\n\twhile(1){\n\t\trep(i,2){\n\t\t\trep(j,len){\n\t\t\t\tboard[x][y]=num++;\n\t\t\t\tx+=dx[state];y+=dy[state];\n\t\t\t}\n\t\t\tstate=(state+1)%4;\n\t\t}\n\t\tif(num>1000000)break;\n\t\tlen++;\n\t}\n\twhile(1){\n\t\tscanf(\"%d %d\",&m,&n);\n\t\tif(n==0)break;\n\t\tint sx,sy;\n\t\trep(i,1111)rep(j,1111){\n\t\t\tif(board[i][j]==n){\n\t\t\t\tsx=i;sy=j;\n\t\t\t}\n\t\t}\n\t\trep(i,1111)rep(j,1111)mem[i][j]=none;\n\t\tP res=dfs(sx,sy);\n\t\tprintf(\"%d %d\\n\", res.fi,res.se);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define M_MAX 1000000\n#define CAVE_WIDTH 1002\n#define CAVE_HEIGHT 1002\n\ntypedef struct point{ int x; int y; } Point;  /* 座標を表す構造体 */\ntypedef struct result{ int num; int last; } Result;  /* 探索の戻り値のための構造体 */\n\n/* 洞穴関連 */\nint prime[M_MAX+1];  /* 素数か判定する配列 */\nint cave[CAVE_WIDTH][CAVE_HEIGHT];  /* 洞穴番号 */\nPoint origin = {CAVE_WIDTH / 2, CAVE_HEIGHT / 2};  /* 原点の座標 */\n\n/* 探索関連 */\nResult dp[CAVE_WIDTH][CAVE_HEIGHT];  /* 探索のメモ */\n\n/* 入力関連 */\nint m;\nint n;\n\n\n/* 初期化する */\nint init(){\n\tint i, j, x, y, l;\n\n\t/* i が素数か判定する配列 prime[i] を生成する */\n\tprime[0] = 0;\n\tprime[1] = 0;\n\tfor (i = 2; i <= M_MAX; i++){\n\t\tprime[i] = 1;\n\t}\n\tfor (i = 2; i <= M_MAX; i++){\n\t\tif (prime[i] == 1){\n\t\t\tfor (j = i + i; j <= M_MAX; j += i){\n\t\t\t\tprime[j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* 縦横に並んだ洞穴に番号をふる */\n\tfor (i = 0; i < CAVE_WIDTH; i++){\n\t\tfor (j = 0; j < CAVE_HEIGHT; j++){\n\t\t\tcave[i][j] = 0;\n\t\t}\n\t}\n\tx = origin.x;\n\ty = origin.y;\n\tcave[x][y] = 1;\n\tx++;\n\t/* 渦巻きの一辺の長さは一周するごとに 2 ずつ増える */\n\tfor (i = 2, l = 2; i <= M_MAX; l += 2){\n\t\tfor (j = 0; j < l-1 && i <= M_MAX; j++, i++, y--) cave[x][y] = i;\n\t\tfor (j = 0; j < l   && i <= M_MAX; j++, i++, x--) cave[x][y] = i;\n\t\tfor (j = 0; j < l   && i <= M_MAX; j++, i++, y++) cave[x][y] = i;\n\t\tfor (j = 0; j < l+1 && i <= M_MAX; j++, i++, x++) cave[x][y] = i;\n\t}\n}\n\n/* 指定された番号の洞穴の座標を返す */\nPoint toXY(int i){\n\tint x, y;\n\tif (i == 1) return origin;\n\n\t/* とりあえず探索 */\n\tfor (x = 0; x < CAVE_WIDTH; x++){\n\t\tfor (y = 0; y < CAVE_HEIGHT; y++){\n\t\t\tif (cave[x][y] == i){\n\t\t\t\tPoint p = {x, y};\n\t\t\t\treturn p;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* 探索関連の変数を初期化する */\nint reset(){\n\tint i, j;\n\tfor (i = 0; i < CAVE_WIDTH; i++){\n\t\tfor (j = 0; j < CAVE_HEIGHT; j++){\n\t\t\tdp[i][j].num = -1;\n\t\t}\n\t}\n}\n\n/* 指定された座標から降下したときに通過できる素数洞穴の最大数を返す */\nResult search(int x, int y){\n\tResult max = {0, 0};\n\tResult r;\n\tint  i;\n\n\t/* 探索終了 */\n\tif (x < 0 || x >= CAVE_WIDTH || y < 0 || y >= CAVE_HEIGHT || cave[x][y] > m) return max;\n\tif (dp[x][y].num != -1) return dp[x][y];\n\n\tif (prime[cave[x][y]]) max.last = cave[x][y];\n\n\t/* 次の洞穴を探索する */\n\tfor (i = -1; i <= 1; i++){\n\t\tr = search(x + i, y + 1);\n\t\t/* 素数洞穴の最大数を保持する */\n\t\tif (r.num > max.num) max = r;\n\t\telse if (r.num == max.num && r.last > max.last) max.last = r.last;\n\t}\n\n\tmax.num += prime[cave[x][y]];\n\treturn dp[x][y] = max;\n}\n\nint main(void){\n\tPoint p;\n\tResult r;\n\n\tinit();  /* プログラムの初期化 */\n\n\twhile (scanf(\"%d%d\", &m, &n) == 2){\n\t\tif (m < 1 || m > 1000000 || n < 1 || n > m) break;\n\n\t\treset();  /* このデータセットについての初期化 */\n\n\t\tp = toXY(n);\n\t\tr = search(p.x, p.y);  /* 探索 */\n\t\tprintf(\"%d %d\\n\", r.num, r.last);  /* 出力 */\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#define M 1000000\n#define N 1000\n#define ROOP(i,a,b) for(i = a;i < b;i++)\n\n//* important!!!\n//* dp[y(i)][x(j)]\nint dp[N+2][N+2];\nint board[N+2][N+2],prime[M+1];\n\nvoid init();\nvoid print();\n\t\nint main(){\n\tint i,j,k,l,m,n;\n\tint x,y;\n\tint cnt,ans,max;\n\tint q;\n\tint* tmp1;\n\tint* tmp2;\n\n\tinit();\n\t//print();\n\n\twhile(scanf(\"%d%d\",&m,&n),m+n){\n\t\tROOP(x,1,N+1)ROOP(y,1,N+1)if(board[y][x] == n)goto BREAK;\n\t\tBREAK:\n\n\t\tmax = (prime[n] == 1);\n\t\tdp[y][x] = max;\n\t\tans = (max?n:0);\n\t\tq = sqrt(m-1)/2+1;\n\n\t\tROOP(i,0,q+501-y){\n\t\t\tj = x-i;\n\t\t\tif(j <= 0)j = 1;\n\t\t\twhile(j <= x+i && j <= N){\n\t\t\t\tROOP(k,-1,2){\n\t\t\t\t\ttmp1 = &(board[y+i+1][j+k]);\n\t\t\t\t\ttmp2 = &(dp[y+i+1][j+k]);\n\t\t\t\t\tif(*tmp1 > n)continue;\n\t\t\t\t\tif(j+k == 0 || j+k == 1001)continue;\n\t\t\t\t\tif(dp[y+i][j]+prime[*tmp1] > *tmp2)\n\t\t\t\t\t\t*tmp2 = dp[y+i][j]+prime[*tmp1];\n\t\t\t\t\tif(max == *tmp2)\n\t\t\t\t\t\tif(ans < *tmp1)\n\t\t\t\t\t\t\tans = *tmp1;\n\t\t\t\t\tif(max < *tmp2){\n\t\t\t\t\t\tmax = *tmp2;\n\t\t\t\t\t\tans = *tmp1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",max,ans);\n\t}\n\treturn 0;\n}\n\nvoid init(){\n\tint i,j;\n\tint dir,x,y,nowx,nowy;\n\tint vecx[4] = { 1, 0,-1, 0};\n\tint vecy[4] = { 0, 1, 0,-1};\n\t\n\t//* set prime\n\tprime[2] = 1;\n\tfor(i = 3;i <= M;i += 2)prime[i] = 1;\n\tfor(i = 3;i*i <= M;i += 2)\n\t\tif(prime[i])for(j = i*i;j <= M;j += i)prime[j] = 0;\n\n\t//* make wall around the board\n\tROOP(i,0,N+2){\n\t\tboard[0][i] = 1;\n\t\tboard[i][0] = 1;\n\t\tboard[N+1][i] = 1;\n\t\tboard[i][N+1] = 1;\n\t}\n\n\t//* set board\n\tdir = 0;x = 0;y = 1;\n\tfor(i = M;i >= 0;i--){\t//* fill from the outside\n\t\tnowx = x+vecx[dir];\n\t\tnowy = y+vecy[dir];\n\t\tif(board[nowy][nowx]){//* if hit the wall\n\t\t\tdir = (dir + 1)%4;\n\t\t\tnowx = x+vecx[dir];\n\t\t\tnowy = y+vecy[dir];\n\t\t}\n\t\tboard[nowy][nowx] = i;\n\t\tx = nowx;y = nowy;\n\t}\n}\n\nvoid print(){\n\tint i,j;\n\tint m = 46,n = 23;\n\tint q;\n\tint x,y;\n\n\tROOP(x,1,N+1)ROOP(y,1,N+1)if(board[y][x] == n)goto BREAK;\n\tBREAK:\n\n\tq = sqrt(m)/2+1;printf(\"%d %d\\n\\n\",y,x);\n\tfor(i = 0;y+i < 501+q;i++){\n\t\tfor(j = 0;x+j < 501+q;j++){\n\t\t\tprintf(\"%d \",board[y+i][x+j]);\n\t\t}puts(\"\");\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\t\t\t"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX_M 1000000\n#define DIV_MM 1000 // DIV_MM = ceiling(sqrt(MAX_M))\n#define MAP_SIZE 1002 // MAP_SIZE = ceiling(sqrt(MAX_M))+2\n// ???????????????????????§??????????´???´?????¨???????????????\n#define CENTER 500 // ??????????´???´?????????\ntypedef struct map_type {\n int id; // ?´???´?????????\n int np; // ?????????????§???????????????????????´???°?´???´????????°\n int lp; // ????¨????????????????????????§??????????????????????´???°?´???´??????????????§???\n} map_t;\nmap_t map[MAP_SIZE][MAP_SIZE]; // ?´???´????????????\nint is_prime[MAX_M+1]; // ?´???°??¨???is_prime[i]=1 <--> i ????´???°\n// ?´???´?????????????????????????§?????????? 0??????, 1??????, 2??????, 3??????\nint dx[ ] = {1, 0, -1, 0};\nint dy[ ] = {0, -1, 0, 1};\nint m, n; // m = ?´???´????????°??? n = ??????????´???´??????\nint nx, ny;// ??????????´???´?????????\nint min_x, max_x, min_y, max_y; // ?????????: ??????????°????,?????§???,?????????????°????,?????§???\nvoid init_map(void) // ?´???´??????????????????????????????\n{\n int i,j;\n for(i=0; i<MAP_SIZE; i++)\n for(j=0; j<MAP_SIZE; j++){\n map[i][j].id = map[i][j].lp = 0;\n map[i][j].np = -1;\n }\n}\n// ??????????????????\nvoid gen_map(void)\n{\n int x, y, len, dir, i,j,id;\n init_map(); // ?????????????????????\n x = y = CENTER; // 1 ???????´???´?????????\n min_x = max_x = min_y = max_y = CENTER;\n map[y][x].id = 1;\n if(n == 1){ // ???????????\\????´???´?????????????????????????????? nx,ny ????????????\n nx = x; ny = y;\n }\n len = 1; dir = 0; id = 2;\n while(id <= m){ // id ????´???´????????° m ?????????????????§??\\????????°?????????\n for(i=0; i<2; i++){ // ????????????????§???????????????°?????????\n for(j=0; j<len; j++){ // dir ??????????????? len ?§????\nx += dx[dir]; y += dy[dir];\nif(x > max_x) max_x = x; // max_x ?????´??°\nif(x < min_x) min_x = x; // min_x ?????´??°\nif(y > max_y) max_y = y; // max_y ?????´??°\nif(y < min_y) min_y = y; // min_y ?????´??°\nif(id == n){ // ???????????\\????´???´?????????????????? nx,ny ????????????\n nx = x; ny = y;\n}\nmap[y][x].id = id++; // ?´???´??????????????????\nif(id > m) break;\n }\n dir = (dir+1)%4; // ????????????????????????\n if(id > m) break;\n }\n len++;\n }\n}\n// ?´???°??¨?????????(??¨??????????????????????????????)\n// is_prime[i] = 1 <--> i ????´???°, is_prime[i] = 0 <--> i ???????´???°\nvoid gen_prime()\n{\n int i,j;\n for(i=0; i<= MAX_M; i++) is_prime[i] = 1; // ??¨??????????????¨????´???°??¨??????\n is_prime[0] = is_prime[1] = 0; // 0, 1 ???????´???°\n for(i=2; i<=DIV_MM; i++){ // DIV_MM ?????§????´???°????????????????????§????????§??????\n if(is_prime[i]){ // i ????´???°?????¨???\n for(j = 2*i; j<=MAX_M; j += i) // i ????????°???????´???°\nis_prime[j] = 0;\n }\n }\n}\n// ??±???????????¢?´¢??§?±???????\nmap_t dfs(int x, int y)\n{\n map_t d;\n int id, np, lp, dx;\n if(map[y][x].id == 0){ // ?´???´??§?????????\n d.id = d.np = d.lp = 0;\n }\n else if(map[y][x].np >= 0){ // ??¢????¨??????????\n d =map[y][x];\n }\n else {\n np = lp = 0;\n id = map[y][x].id;\n for(dx=-1; dx <= 1; dx++){ // ?§??????????????????????????±?????´???´????????????\n d = dfs(x+dx, y+1); // ?´???°?´???´??°??¨???????´???°?´???´??????????±???????\n if(d.np > np){ // ?´???°?´???´??°???????????§???????????°\nnp = d.np; // ?´???°?´???´??°??¨\nlp = d.lp; // ???????´???°?´???´???????????´??°\n }\n else if(d.np == np){ // ?´???°?´???´??°???????????´??????\nif(d.lp > lp) lp = d.lp; // ???????´???°?´???´???????????§?????????????????¨\n }\n }\n if(is_prime[id]){ // ??????????´???°?´???´?????´???\n if(np == 0) // ????????????????±????????????????????´???°?´???´??????????????°\nlp = id; // ???????´???°?´???´??????????´???°?´???´??¨??????\n np++; // ?????????????´???°?´???´??°???????¢???????\n }\n d.id = id; d.np = np; d.lp = lp;\n map[y][x] = d;\n }\n return d;\n}\nint main()\n{\n int x, y, dx, np, lp;\n map_t d;\n gen_prime(); // ?´???°??¨?????????\n while(1){\n scanf(\"%d %d?\\n\", &m, &n); // m, n ?????\\???\n if(m==0 && n==0) break; // ??±??? 0 ????????????\n gen_map(); // ??????????????????\n d = dfs(nx,ny);\n printf(\"%d %d?\\n\", d.np, d.lp);\n }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#define M 1000001\nint MIN(int a,int b){\n  if(a<b)return a;\n  return b;\n}\nint MAX(int a,int b){\n  if(a<b)return b;\n  return a;\n}\nint m[1002][1002]={0};\nchar p[M]={1,1};\nint X[]={0,1,0,-1};\nint Y[]={-1,0,1,0};\nint main(){\n  int i,j,n,s,ny,nx,d=1,x=0,y=1,l,k,max;\n  for(i=2;i*i<M;i++){\n    if(p[i])continue;\n    for(j=i*i;j<M;j+=i)p[j]=1;\n  }\n  for(i=0;i<1002;i++)m[0][i]=m[1001][i]=m[i][0]=m[i][1001]=1000002;\n  for(i=1000000;i;i--){\n    nx=x+X[d];\n    ny=y+Y[d];\n    if(m[ny][nx]){\n      d=(d+1)%4;\n      nx=x+X[d];\n      ny=y+Y[d];\n    }\n    m[y=ny][x=nx]=i;\n    }//*/\n  //printf(\"%d\\n\",m[501][498+2]);\n  while(scanf(\"%d %d\",&n,&s),n||s){\n    int dp[1002][1002]={0};//printf(\"a\\n\");\n    for(i=l=0;i<1000000;i++){\n      if(m[i/1000+1][i%1000+1]==s){\n\ty=i/1000+1;\n\tx=i%1000+1;\n\tbreak;\n      }\n    }//printf(\"%d %d b\\n\",y,x);\n    dp[y][x]=max=1-p[s];//printf(\"d\\n\");\n    if(max)l=s;\n    d=sqrt(n)/2+1;//printf(\"%d\\n\",d);\n    for(i=0;y+i<MIN(1000,501+d);i++){\n      for(j=MAX(1,x-i);j<=MIN(1001,x+i);j++){\n\tfor(k=0;k<3;k++){//printf(\"%d \",m[y+i+1][j+k-1]);\n\t  if(m[y+i+1][j+k-1]>n)continue;//printf(\"%d \",m[y+i+1][j+k-1]);\n\t  dp[y+i+1][j+k-1]=MAX(dp[y+i+1][j+k-1],dp[y+i][j]+1-p[m[y+i+1][j+k-1]]);\n\t  if(max==dp[y+i+1][j+k-1]&&1-p[m[y+i+1][j+k-1]]){\n\t    l=MAX(l,m[y+i+1][j+k-1]);\n\t  }\n\t  if(max<dp[y+i+1][j+k-1]){\n\t    max=dp[y+i+1][j+k-1];\n\t    l  = m[y+i+1][j+k-1];\n\t  }//printf(\"d\\n\");\n\t}\n      }//printf(\"\\n\");\n    }\n    if(max==0)l=0;\n    printf(\"%d %d\\n\",max,l);\n  }\n  return 0;\n}  "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define A 1000100\n#define B 2020\n#include<math.h>\n\nint m,s;\ntypedef struct{\n    int count; //ここを調査した後の，調査してきた洞窟の総数の最大値\n    int num; //0からスタート，何番目の洞窟か\n    int last;\n} cave_struct;\ncave_struct cave[B][B]; //cave[1000][1000]が0番目に対応\n\nint N[A] = {}; //0が格納されていれば（添字＋1）は素数．全て素数で初期化．\nvoid setPrime(){\n    int i, j;\n    int sqrt_A = sqrt(A);\n    N[0] = 1;\n    for(i = 1; i <= sqrt_A; i++){\n        if(N[i] == 0){\n            for(j = 2; j * (i + 1) <= A; j++){\n                N[j * (i + 1) - 1] = 1;\n            }\n        }\n    }\n}\nint co = 0;\nint pos_x = 1000, pos_y = 1000, f_x, f_y;\nint next = 1;\nvoid setCave_1(){\n    int i,j;\n    for(i = 0; i < B; i++){\n        for(j = 0; j < B; j++){\n            cave[i][j].count = -1;\n            cave[i][j].num = -1; //未登録\n        }\n    }\n}\nvoid setCave(){\n    int i;\n    while(1){\n        for(i = 0; i < next; i++){\n            //右へ\n            cave[pos_y][pos_x++].num = co++;\n            if(co == s){\n                f_x = pos_x-1; f_y = pos_y;\n            }\n            if(co > m-1) break;\n        }\n        if(co > m-1) break;\n        for(i = 0; i < next; i++){\n            //上へ\n            cave[pos_y--][pos_x].num = co++;\n            if(co == s){\n                f_x = pos_x; f_y = pos_y+1;\n            }\n            if(co > m-1) break;\n        }\n        if(co > m-1) break;\n        next++;\n        for(i = 0; i < next; i++){\n            //左へ\n            cave[pos_y][pos_x--].num = co++;\n            if(co == s){\n                f_x = pos_x+1; f_y = pos_y;\n            }\n            if(co > m-1) break;\n        }\n        if(co > m-1) break;\n        for(i = 0; i < next; i++){\n            //下へ\n            cave[pos_y++][pos_x].num = co++;\n            if(co == s){\n                f_x = pos_x; f_y = pos_y-1;\n            }\n            if(co > m-1) break;\n        }\n        if(co > m-1) break;\n        next++;\n    }\n    cave[f_y][f_x].count = 1 - N[cave[f_y][f_x].num];\n    //printf(\"%d\\n\",cave[f_y][f_x].count);\n    if(cave[f_y][f_x].num == 1){\n                cave[f_y][f_x].last = cave[f_y][f_x].num;\n     }\n\n}\n\nint max_last = 0;\nint max = -1;\nvoid expCave(int y, int x){\n    if(cave[y][x].count == -1) return;\n    //printf(\"%d, %d\\n\",cave[y][x].num+1,cave[y][x].count);\n    //printf(\" %d, %d\\n\",max_last+1,max);\n\n\n    if(cave[y][x].count > max){\n        max = cave[y][x].count;\n        max_last = cave[y][x].last;\n        //printf(\"%d, %d\\n\",cave[y][x].num+1,cave[y][x].count);\n        //printf(\"  %d, %d\\n\",max_last,max);\n    }else if(cave[y][x].count == max && cave[y][x].last > max_last){\n        max = cave[y][x].count;\n        max_last = cave[y][x].last;\n        //printf(\"  %d, %d\\n\",max_last,max);\n    }\n\n\n    //printf(\" %d, %d\\n\",max_last,max);\n    if(cave[y+1][x-1].num != -1){\n        if(cave[y+1][x-1].count <= cave[y][x].count){\n            cave[y+1][x-1].count = cave[y][x].count;\n            if(N[cave[y+1][x-1].num] == 0){\n                cave[y+1][x-1].last = cave[y+1][x-1].num;\n                cave[y+1][x-1].count++;\n                if(cave[y+1][x-1].count > max){\n                    max = cave[y+1][x-1].count;\n                    max_last = cave[y+1][x-1].num;\n                    //printf(\"%d, %d\\n\",max_last,max);\n                }else if(cave[y+1][x-1].count == max && cave[y+1][x-1].num > max_last){\n                    max = cave[y+1][x-1].count;\n                    max_last = cave[y+1][x-1].num;\n                    //printf(\"%d, %d\\n\",max_last,max);\n                }\n            }else{\n                cave[y+1][x-1].last = cave[y][x].last;\n            }\n        }\n    }\n    //printf(\" %d, %d\\n\",max_last,max);\n    if(cave[y+1][x].num != -1){\n        if(cave[y+1][x].count <= cave[y][x].count){\n            cave[y+1][x].count = cave[y][x].count;\n            if(N[cave[y+1][x].num] == 0){\n                cave[y+1][x].last = cave[y+1][x].num;\n                cave[y+1][x].count++;\n                if(cave[y+1][x].count > max){\n                    max = cave[y+1][x].count;\n                    max_last = cave[y+1][x].num;\n                    //printf(\"%d, %d\\n\",max_last,max);\n                }else if(cave[y+1][x].count == max && cave[y+1][x].num > max_last){\n                    max = cave[y+1][x].count;\n                    max_last = cave[y+1][x].num;\n                    //printf(\"%d, %d\\n\",max_last,max);\n                }\n            }else{\n                cave[y+1][x].last = cave[y][x].last;\n            }\n        }\n    }\n    //printf(\" %d, %d\\n\",max_last,max);\n    if(cave[y+1][x+1].num != -1){\n        if(cave[y+1][x+1].count <= cave[y][x].count){\n            cave[y+1][x+1].count = cave[y][x].count;\n            if(N[cave[y+1][x+1].num] == 0){\n                cave[y+1][x+1].last = cave[y+1][x+1].num;\n                cave[y+1][x+1].count++;\n                if(cave[y+1][x+1].count > max){\n                    max = cave[y+1][x+1].count;\n                    max_last = cave[y+1][x+1].num;\n                    //printf(\"%d, %d\\n\",max_last,max);\n                }else if(cave[y+1][x+1].count == max && cave[y+1][x+1].num > max_last){\n                    max = cave[y+1][x+1].count;\n                    max_last = cave[y+1][x+1].num;\n                    //printf(\"%d, %d\\n\",max_last,max);\n                }\n            }else{\n                cave[y+1][x+1].last = cave[y][x].last;\n            }\n        }\n    }\n    //printf(\" %d, %d\\n\",max_last,max);\n\n}\n\nint main(void){\n    setPrime();\n    while(1){\n        scanf(\"%d %d\", &m, &s);\n        if(!m && !s) break;\n        co = 0; pos_x = 1000; pos_y = 1000; next = 1; max_last = 0; max = -1;\n        setCave_1();\n        setCave();\n        //printf(\"(%d, %d)\\n\",f_x,f_y);\n        for(int i = 1; i < B-1; i++){\n            for(int j = 1; j < B-1; j++){\n                expCave(i, j);\n            }\n        }\n        if(max == 0){\n            printf(\"0 0\\n\");\n        }else{\n            printf(\"%d %d\\n\",max,max_last+1);\n        }\n        /*\n        for(int i =  1005; i <= 1015; i++){\n            for(int j = 990; j <= 1000; j++){\n                printf(\"%2d \",cave[i][j].num);\n            }\n            printf(\"\\n\");\n        }\n        */\n        \n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#define M 1000000\n#define N 1000\n#define ROOP(i,a,b) for(i = a;i < b;i++) //* [a,b)\n\n//* important!!!\n//* dp[y(i)][x(j)]\nint dp[N+2][N+2];\nint board[N+2][N+2],prime[M+1];\n\nvoid init();\nvoid print();\n\t\nint main(){\n\tint i,j,k,l,m,n;\n\tint x,y;\n\tint cnt,ans,max;\n\tint q;\n\t//int* tmp1;\n\t//int* tmp2;\n\n\tinit();\n\t//print();\n\n\twhile(scanf(\"%d%d\",&m,&n),m+n){\n\t\tROOP(x,1,N+1)ROOP(y,1,N+1)if(board[y][x] == n)goto BREAK;\n\t\tBREAK:\n\n\t\tROOP(i,1,N+1)ROOP(j,1,N+1)dp[i][j] = 0;\n\t\t\n\t\tdp[y][x] = (prime[n] == 1);\n\t\tmax = dp[y][x];\n\t\tans = (max?n:0);\n\t\tq = sqrt(m-1)/2+1;\n\n\t\ti = y;\n\t\twhile(i < q+501 && i < N){\n\t\t\tj = x-(i-y);\n\t\t\tif(j <= 0)j = 1;\n\t\t\twhile(j <= x+(i-y) && j <= N+1){\n\t\t\t\tROOP(k,-1,2){\n\t\t\t\t\t//tmp1 = &(board[i+1][j+k]);\n\t\t\t\t\t//tmp2 = &(dp[i+1][j+k]);\n\t\t\t\t\tif(board[i+1][j+k] > m)continue;\n\t\t\t\t\tif(j+k == 0 || j+k == 1001)continue;\n\t\t\t\t\tif(dp[i][j]+prime[board[i+1][j+k]] > dp[i+1][j+k])\n\t\t\t\t\t\tdp[i+1][j+k] = dp[i][j]+prime[board[i+1][j+k]];\n\t\t\t\t\tif(max == dp[i+1][j+k] && prime[board[i+1][j+k]])\n\t\t\t\t\t\tif(ans < board[i+1][j+k])\n\t\t\t\t\t\t\tans = board[i+1][j+k];\n\t\t\t\t\tif(max < dp[i+1][j+k]){\n\t\t\t\t\t\tmax = dp[i+1][j+k];\n\t\t\t\t\t\tans = board[i+1][j+k];\n\t\t\t\t\t\t//printf(\"%d %d\\n\",max,ans);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tprintf(\"%d %d\\n\",max,ans);\n\t}\n\treturn 0;\n}\n\nvoid init(){\n\tint i,j;\n\tint dir,x,y,nowx,nowy;\n\tint vecx[4] = { 1, 0,-1, 0};\n\tint vecy[4] = { 0, 1, 0,-1};\n\t\n\t//* set prime\n\tprime[2] = 1;\n\tfor(i = 3;i <= M;i += 2)prime[i] = 1;\n\tfor(i = 3;i*i <= M;i += 2)\n\t\tif(prime[i])for(j = i*i;j <= M;j += i)prime[j] = 0;\n\n\t//* make wall around the board\n\tROOP(i,0,N+2){\n\t\tboard[0][i] = 1;\n\t\tboard[i][0] = 1;\n\t\tboard[N+1][i] = 1;\n\t\tboard[i][N+1] = 1;\n\t}\n\n\t//* set board\n\tdir = 0;x = 0;y = 1;\n\tfor(i = M;i >= 0;i--){\t//* fill from the outside\n\t\tnowx = x+vecx[dir];\n\t\tnowy = y+vecy[dir];\n\t\tif(board[nowy][nowx]){//* if hit the wall\n\t\t\tdir = (dir + 1)%4;\n\t\t\tnowx = x+vecx[dir];\n\t\t\tnowy = y+vecy[dir];\n\t\t}\n\t\tboard[nowy][nowx] = i;\n\t\tx = nowx;y = nowy;\n\t}\n}\n\nvoid print(){\n\tint i,j;\n\tint m = 1039,n = 1;\n\tint q;\n\tint x,y;\n\n\tROOP(x,1,N+1)ROOP(y,1,N+1)if(board[y][x] == n)goto BREAK;\n\tBREAK:\n\n\tq = sqrt(m)/2+1;printf(\"%d %d\\n\\n\",y,x);\n\tfor(i = 0;y+i < 501+q;i++){\n\t\tfor(j = 0;x+j < 501+q;j++){\n\t\t\tprintf(\"%4d \",board[y+i][x+j]);\n\t\t}puts(\"\");\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\t\t\t"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define maxm 1004004\n#define h 1002\n#define w 1002\n\nint is_prime[maxm + 1], nums[h][w], dp1[h][w], dp2[h][w], posx[maxm + 1], posy[maxm + 1];\n\nint max(int a, int b){\n\treturn a >= b ? a : b;\n}\n\nint main(){\n\tint m, n, i, j, d, k;\n\tint dx[] = {0, 1, 0, -1};\n\tint dy[] = {1, 0, -1, 0};\n\tfor(i = 0; i <= maxm; i++){\n\t\tis_prime[i] = 1;\n\t}\n\tis_prime[0] = 0;\n\tis_prime[1] = 0;\n\tfor(i = 2; i <= maxm; i++){\n\t\tfor(j = 2; i * j <= maxm; j++){\n\t\t\tis_prime[i * j] = 0;\n\t\t}\n\t}\n\tfor(i = 0; i < h; i++){\n\t\tfor(j = 0; j < w; j++){\n\t\t\tnums[i][j] = 0;\n\t\t}\n\t}\n\tfor(n = maxm, d = 0, i = 0, j = 0; n > 0; n--){\n\t\tnums[i][j] = n;\n\t\tposx[n] = i;\n\t\tposy[n] = j;\n\t\tif(i + dx[d] < 0 || h <= i + dx[d] || j + dy[d] < 0 || w <= j + dy[d]){\n\t\t\td = (d + 1) % 4;\n\t\t}\n\t\telse if(nums[i + dx[d]][j + dy[d]] > 0){\n\t\t\td = (d + 1) % 4;\n\t\t}\n\t\ti += dx[d];\n\t\tj += dy[d];\n\t}\n\twhile(1){\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif(m == 0 && n == 0){\n\t\t\treturn 0;\n\t\t}\n\t\tfor(i = 0; i < h; i++){\n\t\t\tfor(j = 0; j < w; j++){\n\t\t\t\tdp1[i][j] = 0;\n\t\t\t\tdp2[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(i = h - 2; i > 0; i--){\n\t\t\tfor(j = 1; j < w - 1; j++){\n\t\t\t\tif(nums[i][j] <= m){\n\t\t\t\t\tdp1[i][j]--;\n\t\t\t\t\tif(is_prime[nums[i][j]] == 1){\n\t\t\t\t\t\tdp1[i][j]--;\n\t\t\t\t\t}\n\t\t\t\t\tfor(k = -1; k <= 1; k++){\n\t\t\t\t\t\tif(dp1[i][j] < dp1[i + 1][j + k]){\n\t\t\t\t\t\t\tdp1[i][j] = dp1[i + 1][j + k];\n\t\t\t\t\t\t\tdp2[i][j] = dp2[i + 1][j + k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(dp1[i][j] == dp1[i + 1][j + k]){\n\t\t\t\t\t\t\tdp2[i][j] = max(dp2[i][j], dp2[i + 1][j + k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(is_prime[nums[i][j]] == 1){\n\t\t\t\t\t\tif(dp1[i][j] == 0){\n\t\t\t\t\t\t\tdp2[i][j] = nums[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp1[i][j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\", dp1[posx[n]][posy[n]], dp2[posx[n]][posy[n]]);\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "// Aizu 1189: Prime Caves\n// 2017.9.21 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX  1020000\n#define N    1010\n#define SQRT 1009     // sqrt(MAX)\n#define max(a,b) ((a)>=(b)?(a):(b))\n\nchar prime[MAX + 5], *pmax = prime + MAX;\n\nvoid mkprime()\n{\n\tint k;\n\tregister char *p, *q;\n\tprime[1] = 1, prime[2] = 0;\n\tfor (p = prime + 4; p <= pmax; p += 2) *p = 1;\n\tfor (k = 3, p = prime + 3; k <= SQRT; k += 2, p += 2)\n\t\tif (!*p) for (q = p + k; q <= pmax; q += k) *q = 1;\n}\n\ntypedef struct { int r, c; } PP;\nPP pp[MAX+3];\nint map[N+5][N+5];\nint dp[N+5][N+5];\nint mv[4][2] = { {-1,0},{0,-1},{1,0},{0,1} };\nint m, n;\n\nvoid set()\n{\n\tint i, k, w, r, c, d;\n\n    k = 1, r = c = N/2, d = 3, w = 2;\n\twhile (1) {\n\t\tfor (i = 0; i < w/2; i++) {\n\t\t\tmap[r][c] = k, pp[k].r = r, pp[k].c = c, k++;\n\t\t\tr += mv[d][0], c += mv[d][1];\n\t\t\tif (r < 0 || r >= N || c < 0 || c >= N) return;\n\t\t}\n\t\tif (++d == 4) d = 0;\n\t\tw++;\n\t}\n}\n\nint main()\n{\n\tint r, c, ans, x;\n\n\tmkprime(); set();\n\twhile (scanf(\"%d%d\", &m, &n) && m) {\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tr = pp[n].r, c = pp[n].c;\n\t\tdp[r][c] = !prime[n];\n\t\tfor (r = 0; r < N; r++) for (c = 0; c < N; c++) {\n\t\t\tif (dp[r][c] >= 0 && map[r][c] <= m) {\n\t\t        if (map[r+1][c-1] <= m)\n\t\t\t\t\tdp[r+1][c-1] = max(dp[r+1][c-1], dp[r][c] + !prime[map[r+1][c-1]]); \n\t\t        if (map[r+1][c] <= m)\n\t\t\t\t\tdp[r+1][c]   = max(dp[r+1][c],   dp[r][c] + !prime[map[r+1][c]]); \n\t\t\t\tif (map[r+1][c+1] <= m)\n\t\t\t\t\tdp[r+1][c+1] = max(dp[r+1][c+1], dp[r][c] + !prime[map[r+1][c+1]]); \n\t\t\t}\n\t\t}\n\t\tans = x = 0;\n\t\tfor (r = 0; r < N; r++) for (c = 0; c < N; c++)\n\t\t\tif (map[r][c] <= m && !prime[map[r][c]])\n\t\t\t\tif (ans < dp[r][c]) ans = dp[r][c], x = map[r][c];\n\t\t\t\telse if (ans == dp[r][c] && x < map[r][c]) x = map[r][c];\n\n\t\tprintf(\"%d %d\\n\", ans, x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n\n#define MAX 1000001\n#define SIZE 2000\n\ntypedef long long ll;\n\nusing namespace std;\n\nint m, n;\nint table[SIZE][SIZE]={{0,0}};\nint dp[SIZE][SIZE];\nbool prime[MAX]; \npair<int, int>coord[MAX];//座標\npair<int, int> ans;// <素数の数, 出口の番号>\n\n\nvoid dfs(int count, int y, int x){\n\tint num = table[y][x];\n\tif(num <= 0 || m < num) return;\n\tif(count < dp[y][x] || (count == dp[y][x] && prime[num] == false && dp[y][x] !=0)) return;\n\tdp[y][x] = count;\n\n\tif(prime[num] == true){\n\t\tcount++;\n\t\tdp[y][x] = count;\n\t\tif(ans.first < count || (ans.first == count && ans.second < num)){\n\t\t\tans.first = count;\n\t\t\tans.second = num;\n\t\t}\n\t}\n\n\tfor(int dx=-1; dx<=1; dx++){\n\t\tdfs(count, y+1, x+dx);\n\t}\n}\n\n\nint main(void){\n\tfill(prime, prime+MAX, true);\n\tprime[0] = prime[1] = false;\n\tfor(int i=2; i<MAX; i++){\n\t\tif(prime[i]){\n\t\t\tfor(int j=i+i; j<MAX; j+=i){\n\t\t\t\tprime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tint d=0, x=1000, y=1000;\n\tint dx[4]={0, 1, 0, -1};\n\tint dy[4]={1, 0, -1, 0};\n\tfor(int i=1; i<MAX; i++){\n\t\ttable[y][x] = i;\n\t\tcoord[i] = make_pair(y, x);\n\t\tif(table[y+dy[(d+1)%4]][x+dx[(d+1)%4]] == 0) d++;\n\t\tx += dx[d%4];\n\t\ty += dy[d%4];\n\t}\n\n\twhile(1){\n\t\tcin >> m >> n;\n\t\tif(!m && !n) break;\n\n\t\tint y = coord[n].first;\n\t\tint x = coord[n].second;\n\t\tfill(dp[0], dp[2000], 0);\n\t\tans = make_pair(0, 0);\n\t\tdfs(0, y, x);\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX_M 1000000\n#define DIV_MM 1000 // DIV_MM = ceiling(sqrt(MAX_M))\n#define MAP_SIZE 1002 // MAP_SIZE = ceiling(sqrt(MAX_M))+2\n// ???????????????????????§??????????´???´?????¨???????????????\n#define CENTER 500 // ??????????´???´?????????\ntypedef struct map_type {\n int id; // ?´???´?????????\n int np; // ?????????????§???????????????????????´???°?´???´????????°\n int lp; // ????¨????????????????????????§??????????????????????´???°?´???´??????????????§???\n} map_t;\nmap_t map[MAP_SIZE][MAP_SIZE]; // ?´???´????????????\nint is_prime[MAX_M+1]; // ?´???°??¨???is_prime[i]=1 <--> i ????´???°\n// ?´???´?????????????????????????§?????????? 0??????, 1??????, 2??????, 3??????\nint dx[ ] = {1, 0, -1, 0};\nint dy[ ] = {0, -1, 0, 1};\nint m, n; // m = ?´???´????????°??? n = ??????????´???´??????\nint nx, ny;// ??????????´???´?????????\nint min_x, max_x, min_y, max_y; // ?????????: ??????????°????,?????§???,?????????????°????,?????§???\nvoid init_map(void) // ?´???´??????????????????????????????\n{\n int i,j;\n for(i=0; i<MAP_SIZE; i++)\n for(j=0; j<MAP_SIZE; j++){\n map[i][j].id = map[i][j].lp = 0;\n map[i][j].np = -1;\n }\n}\n// ??????????????????\nvoid gen_map(void)\n{\n int x, y, len, dir, i,j,id;\n init_map(); // ?????????????????????\n x = y = CENTER; // 1 ???????´???´?????????\n min_x = max_x = min_y = max_y = CENTER;\n map[y][x].id = 1;\n if(n == 1){ // ???????????\\????´???´?????????????????????????????? nx,ny ????????????\n nx = x; ny = y;\n }\n len = 1; dir = 0; id = 2;\n while(id <= m){ // id ????´???´????????° m ?????????????????§??\\????????°?????????\n for(i=0; i<2; i++){ // ????????????????§???????????????°?????????\n for(j=0; j<len; j++){ // dir ??????????????? len ?§????\nx += dx[dir]; y += dy[dir];\nif(x > max_x) max_x = x; // max_x ?????´??°\nif(x < min_x) min_x = x; // min_x ?????´??°\nif(y > max_y) max_y = y; // max_y ?????´??°\nif(y < min_y) min_y = y; // min_y ?????´??°\nif(id == n){ // ???????????\\????´???´?????????????????? nx,ny ????????????\n nx = x; ny = y;\n}\nmap[y][x].id = id++; // ?´???´??????????????????\nif(id > m) break;\n }\n dir = (dir+1)%4; // ????????????????????????\n if(id > m) break;\n }\n len++;\n }\n}\n// ?´???°??¨?????????(??¨??????????????????????????????)\n// is_prime[i] = 1 <--> i ????´???°, is_prime[i] = 0 <--> i ???????´???°\nvoid gen_prime()\n{\n int i,j;\n for(i=0; i<= MAX_M; i++) is_prime[i] = 1; // ??¨??????????????¨????´???°??¨??????\n is_prime[0] = is_prime[1] = 0; // 0, 1 ???????´???°\n for(i=2; i<=DIV_MM; i++){ // DIV_MM ?????§????´???°????????????????????§????????§??????\n if(is_prime[i]){ // i ????´???°?????¨???\n for(j = 2*i; j<=MAX_M; j += i) // i ????????°???????´???°\nis_prime[j] = 0;\n }\n }\n}\n// ??±???????????¢?´¢??§?±???????\nmap_t dfs(int x, int y)\n{\n map_t d;\n int id, np, lp, dx;\n if(map[y][x].id == 0){ // ?´???´??§?????????\n d.id = d.np = d.lp = 0;\n }\n else if(map[y][x].np >= 0){ // ??¢????¨??????????\n d =map[y][x];\n }\n else {\n np = lp = 0;\n id = map[y][x].id;\n for(dx=-1; dx <= 1; dx++){ // ?§??????????????????????????±?????´???´????????????\n d = dfs(x+dx, y+1); // ?´???°?´???´??°??¨???????´???°?´???´??????????±???????\n if(d.np > np){ // ?´???°?´???´??°???????????§???????????°\nnp = d.np; // ?´???°?´???´??°??¨\nlp = d.lp; // ???????´???°?´???´???????????´??°\n }\n else if(d.np == np){ // ?´???°?´???´??°???????????´??????\nif(d.lp > lp) lp = d.lp; // ???????´???°?´???´???????????§?????????????????¨\n }\n }\n if(is_prime[id]){ // ??????????´???°?´???´?????´???\n if(np == 0) // ????????????????±????????????????????´???°?´???´??????????????°\nlp = id; // ???????´???°?´???´??????????´???°?´???´??¨??????\n np++; // ?????????????´???°?´???´??°???????¢???????\n }\n d.id = id; d.np = np; d.lp = lp;\n map[y][x] = d;\n }\n return d;\n}\nint main()\n{\n int x, y, dx, np, lp;\n map_t d;\n gen_prime(); // ?´???°??¨?????????\n while(1){\n scanf(\"%d %d?\\n\", &m, &n); // m, n ?????\\???\n if(m==0 && n==0) break; // ??±??? 0 ????????????\n gen_map(); // ??????????????????\n d = dfs(nx,ny);\n printf(\"%d %d?\\n\", d.np, d.lp);\n }\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1189: Prime Caves\n// 2017.9.21 bal4u@uu\n// 2017.12.22\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX  1020000\n#define N    1010\n#define SQRT 1009     // sqrt(MAX)\n#define max(a,b) ((a)>=(b)?(a):(b))\n\nchar prime[MAX+2] = {1,1,0};\n\nvoid mkprime()\n{\n\tint i, j;\n\n\tfor (i = 4; i <= MAX; i += 2) prime[i] = 1;\n\tfor (i = 3; i <= SQRT; i += 2)\n\t\tif (!prime[i]) for (j = i*i; j <= MAX; j += i) prime[j] = 1;\n}\n\ntypedef struct { int r, c; } PP;\nPP pp[MAX+3];\nint map[N+5][N+5];\nint dp[N+5][N+5];\nint mv[4][2] = { {-1,0},{0,-1},{1,0},{0,1} };\nint m, n;\n\nvoid set()\n{\n\tint i, k, w, w2, r, c, d;\n\n    k = 1, r = c = N >> 1, d = 3, w = 2, w2 = 1;\n\twhile (1) {\n\t\tfor (i = 0; i < w2; i++) {\n\t\t\tmap[r][c] = k, pp[k].r = r, pp[k].c = c, k++;\n\t\t\tr += mv[d][0], c += mv[d][1];\n\t\t\tif (r < 0 || r >= N || c < 0 || c >= N) return;\n\t\t}\n\t\tif (++d == 4) d = 0;\n\t\tw++, w2 = w >> 1;\n\t}\n}\n\nint main()\n{\n\tint r, c, ans, x;\n\n\tmkprime(); set();\n\twhile (scanf(\"%d%d\", &m, &n) && m) {\n\t\tmemset(dp, -1, sizeof(dp));\n\t\tr = pp[n].r, c = pp[n].c;\n\t\tdp[r][c] = !prime[n];\n\t\tfor (r = 0; r < N; r++) for (c = 0; c < N; c++) {\n\t\t\tif (dp[r][c] >= 0 && map[r][c] <= m) {\n\t\t        if (map[r+1][c-1] <= m)\n\t\t\t\t\tdp[r+1][c-1] = max(dp[r+1][c-1], dp[r][c] + !prime[map[r+1][c-1]]); \n\t\t        if (map[r+1][c] <= m)\n\t\t\t\t\tdp[r+1][c]   = max(dp[r+1][c],   dp[r][c] + !prime[map[r+1][c]]); \n\t\t\t\tif (map[r+1][c+1] <= m)\n\t\t\t\t\tdp[r+1][c+1] = max(dp[r+1][c+1], dp[r][c] + !prime[map[r+1][c+1]]); \n\t\t\t}\n\t\t}\n\t\tans = x = 0;\n\t\tfor (r = 0; r < N; r++) for (c = 0; c < N; c++)\n\t\t\tif (map[r][c] <= m && !prime[map[r][c]])\n\t\t\t\tif (ans < dp[r][c]) ans = dp[r][c], x = map[r][c];\n\t\t\t\telse if (ans == dp[r][c] && x < map[r][c]) x = map[r][c];\n\n\t\tprintf(\"%d %d\\n\", ans, x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define INF 100000000\n#define MAX_N 1000000\n\ntypedef struct {\n\tint num;\n\tint max;\n\tint last;\n} FIELD;\n\nint isPrime[ MAX_N + 1 ] = { 0, 0, 1 }, corner[ 1998 ] = { 2 }, coord[ 1000001 ], m;\nFIELD field[ 1002 ][ 1001 ];\nconst int dx[ 7 ] = { 1, 0, -1 , 0, -1, 0, 1 }, dy[ 7 ] = { 0, -1, 0, 1, 1, 1, 1 };\n\nvoid dfs( int, int );\n\nint main( void ) {\n\tint i, j, add, x, y, d, cnt, n;\n\n\tfor ( i = 3; i <= MAX_N; i += 2 )\n\t\tisPrime[ i ] = 1;\n\n\tfor ( i = 3; i * i <= MAX_N; i += 2 )\n\t\tif ( isPrime[ i ] )\n\t\t\tfor ( j = i * 2; j <= MAX_N; j += i )\n\t\t\t\tisPrime[ j ] = 0;\n\n\tadd = 1;\n\tfor ( i = 1; i < 1998; i++ ) {\n\t\tcorner[ i ] = corner[ i - 1 ] + add;\n\t\tadd += i & 1;\n\t}\n\n\tx = y = 500;\n\td = cnt = 0;\n\tfor ( i = 1; i <= 1000000; i++ ) {\n\t\tcoord[ i ] = x * 1001 + y;\n\t\tfield[ x ][ y ].num = i;\n\n\t\tif ( i == corner[ cnt ] ) {\n\t\t\td = d + 1 & 3;\n\t\t\tcnt++;\n\t\t}\n\n\t\tx += dx[ d ];\n\t\ty += dy[ d ];\n\t}\n\n\tfor ( x = 1002; x--; field[ x ][ 1000 ].num = INF ) ;\n\tfor ( y = 1001; y--; field[ 0 ][ y ].num = field[ 1001 ][ y ].num = INF ) ;\n\n\tfor ( ; scanf( \"%d %d\", &m, &n ), m; printf( \"%d %d\\n\", field[ x ][ y ].max, field[ x ][ y ].last ) ) {\n\t\tfor ( i = m; i; i-- ) {\n\t\t\tfield[ x = coord[ i ] / 1001 ][ y = coord[ i ] % 1001 ].max = INF;\n\t\t\tfield[ x ][ y ].last = 0;\n\t\t}\n\n\t\tdfs( x = coord[ n ] / 1001, y = coord[ n ] % 1001 );\n\t}\n\n\treturn 0;\n}\n\nvoid dfs( int x, int y ) {\n\tint i;\n\n\tfield[ x ][ y ].max = 0;\n\tfor ( i = 7; i-- > 4;  ) {\n\t\tint nx = x + dx[ i ], ny = y + dy[ i ];\n\n\t\tif ( field[ nx ][ ny ].num <= m ) {\n\t\t\tif ( field[ nx ][ ny ].max == INF )\n\t\t\t\tdfs( nx, ny );\n\n\t\t\tif ( field[ x ][ y ].max < field[ nx ][ ny ].max ) {\n\t\t\t\tfield[ x ][ y ].max = field[ nx ][ ny ].max;\n\t\t\t\tfield[ x ][ y ].last = field[ nx ][ ny ].last;\n\t\t\t} else if ( field[ x ][ y ].max == field[ nx ][ ny ].max && field[ x ][ y ].last < field[ nx ][ ny ].last )\n\t\t\t\tfield[ x ][ y ].last = field[ nx ][ ny ].last;\n\t\t}\n\t}\n\n\tif ( isPrime[ field[ x ][ y ].num ] ) {\n\t\tif ( !field[ x ][ y ].max )\n\t\t\tfield[ x ][ y ].last = field[ x ][ y ].num;\n\n\t\tfield[ x ][ y ].max++;\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nstruct{\n    int x,y;\n}typedef pair;\nint n,m;\npair data[5000005]={};\npair ans;\nint map[2010][2010]={};\nint prime[5000005]={};\nvoid make(){\n    int i,j;\n    for(i=0;i<5000005;i++)prime[i]=1;\n    prime[0]=0;\n    for(i=0;i*i<5000005;i++){\n        if(prime[i]){\n            for(j=2;(i+1)*j<=5000005;j++){\n                prime[(i+1)*j-1]=0;\n            }\n        }\n    }\n}\npair dp[2010][2010]={};\nint main(void){\n    make();\n    map[1000][1000]=1;\n    data[1]=(pair){1000,1000};\n    int i,j;\n    //ウラムの螺旋\n    for(i=1;i<=1000;i++){\n        //右\n        map[1000][1000+i]=4*i*i-3*i+1;\n        data[map[1000][1000+i]]=(pair){1000,1000+i};\n        //右上\n        map[1000-i][1000+i]=4*i*i-2*i+1;\n        data[map[1000-i][1000+i]]=(pair){1000-i,1000+i};\n        //上\n        map[1000-i][1000]=4*i*i-i+1;\n        data[map[1000-i][1000]]=(pair){1000-i,1000};\n        //左上\n        map[1000-i][1000-i]=4*i*i+1;\n        data[map[1000-i][1000-i]]=(pair){1000-i,1000-i};\n        //左\n        map[1000][1000-i]=4*i*i+i+1;\n        data[map[1000][1000-i]]=(pair){1000,1000-i};\n        //左下\n        map[1000+i][1000-i]=4*i*i+2*i+1;\n        data[map[1000+i][1000-i]]=(pair){1000+i,1000-i};\n        //下\n        map[1000+i][1000]=4*i*i+3*i+1;\n        data[map[1000+i][1000]]=(pair){1000+i,1000};\n        //右下\n        map[1000+i][1000+i]=(2*i+1)*(2*i+1);\n        data[map[1000+i][1000+i]]=(pair){1000+i,1000+i};\n    }\n    int ok;\n    //縦方向(左半分)\n    for(i=0;i<1000;i++){\n         ok=0;\n        int now=0;\n        for(j=0;j<2005;j++){\n            if(now==0&&map[j][i]!=0){\n                now=map[j][i];\n            }else if(now!=0&&map[j][i]==0){\n                now++;\n                map[j][i]=now;\n                data[map[j][i]]=(pair){j,i};\n            }else if(!ok&&map[j][i]!=0){\n                ok=1;\n                now++;\n            }else if(map[j][i]!=0){\n                break;\n            }\n        }\n    }\n    //縦方向(右半分)\n        for(i=1001;i<2005;i++){\n         ok=0;\n        int now=0;\n        for(j=0;j<2005;j++){\n            if(now==0&&map[j][i]!=0){\n                now=map[j][i];\n            }else if(now!=0&&map[j][i]==0){\n                now--;\n                map[j][i]=now;\n                data[map[j][i]]=(pair){j,i};\n            }else if(!ok&&map[j][i]!=0){\n                ok=1;\n                now--;\n            }else if(map[j][i]!=0){\n                break;\n            }\n        }\n    }\n        //横方向(上半分)\n    for(i=0;i<1000;i++){\n         ok=0;\n        int now=0;\n        for(j=0;j<2005;j++){\n            if(now==0&&map[i][j+1]==0){\n                now=map[i][j];\n            }else if(now!=0&&map[i][j]==0){\n                now--;\n                map[i][j]=now;\n                data[map[i][j]]=(pair){i,j};\n            }else if(now!=0&&!ok&&map[i][j]!=0){\n                ok=1;\n                now--;\n            }else if(now!=0&&map[i][j]!=0){\n                break;\n            }\n        }\n    }\n        //横方向(下半分)\n    for(i=1001;i<2005;i++){\n         ok=0;\n        int now=0;\n        for(j=0;j<2005;j++){\n            if(now==0&&map[i][j+1]==0){\n                now=map[i][j];\n            }else if(now!=0&&map[i][j]==0){\n                now++;\n                map[i][j]=now;\n                data[map[i][j]]=(pair){i,j};\n            }else if(now!=0&&!ok&&map[i][j]!=0){\n                ok=1;\n                now++;\n            }else if(now!=0&&map[i][j]!=0){\n                break;\n            }\n        }\n    }\n//  FILE *fp;\n//     //ファイルを書き込みモードで開く\n//     fp = fopen(\"test.txt\",\"w\");  \n//     //ファイルオープンに失敗した場合\n//     if(fp==NULL){\n//         //失敗と表示し終了\n//         printf(\"ファイルオープン失敗\\n\");\n//         return -1;\n//     }\n\n    // for(int i=0;i<2000;i++){\n    //     for(int j=0;j<2000;j++){\n    //         fprintf(fp,\"%5d \",map[i][j]);\n    //     }\n    //     fprintf(fp,\"\\n\");\n    // }\n    //  fclose(fp);\n    //  return 0;\n   while(1){\n       scanf(\"%d%d\",&m,&n);\n       if(m==0&&n==0)return 0;\n       ans=(pair){0,0};\n       for(j=0;j<2005;j++)dp[data[n].x][j]=(pair){0,0};\n       dp[data[n].x][data[n].y]=(pair){prime[n-1]+1,(prime[n-1]?n:0)};\n        if(dp[data[n].x][data[n].y].x>ans.x){\n            ans=dp[data[n].x][data[n].y];\n        }else if(dp[data[n].x][data[n].y].x==ans.x&&dp[data[n].x][data[n].y].y>ans.y){\n            ans=dp[data[n].x][data[n].y];\n        }\n       for(i=data[n].x;i<2004;i++){\n           for(j=0;j<2005;j++)dp[i+1][j]=(pair){0,0};\n           for(j=0;j<2005;j++){\n               if(dp[i][j].x==0)continue;\n               int cnt=dp[i][j].x,p=dp[i][j].y;\n               if(j-1>=0&&map[i+1][j-1]>0&&map[i+1][j-1]<=m){\n                   if(dp[i+1][j-1].x<cnt+prime[map[i+1][j-1]-1]||(dp[i+1][j-1].x==cnt+prime[map[i+1][j-1]-1]&&dp[i+1][j-1].y<(prime[map[i+1][j-1]-1]?map[i+1][j]:p))){\n                       dp[i+1][j-1]=(pair){cnt+prime[map[i+1][j-1]-1],(prime[map[i+1][j-1]-1]?map[i+1][j-1]:p)};\n                   }\n               }\n               if(map[i+1][j]>0&&map[i+1][j]<=m){\n                   if(dp[i+1][j].x<cnt+prime[map[i+1][j]-1]||(dp[i+1][j].x==cnt+prime[map[i+1][j]-1]&&dp[i+1][j].y<(prime[map[i+1][j]-1]?map[i+1][j]:p))){\n                       dp[i+1][j]=(pair){cnt+prime[map[i+1][j]-1],(prime[map[i+1][j]-1]?map[i+1][j]:p)};\n                   }\n               }\n               if(j+1<2005&&map[i+1][j+1]>0&&map[i+1][j+1]<=m){\n                   if(dp[i+1][j+1].x<cnt+prime[map[i+1][j+1]-1]||(dp[i+1][j+1].x==cnt+prime[map[i+1][j+1]-1]&&dp[i+1][j+1].y<(prime[map[i+1][j+1]-1]?map[i+1][j+1]:dp[i][j+1].y))){\n                       dp[i+1][j+1]=(pair){cnt+prime[map[i+1][j+1]-1],(prime[map[i+1][j+1]-1]?map[i+1][j+1]:p)};\n                   }\n               }\n           }\n              for(j=0;j<2005;j++){\n                    if(dp[i+1][j].x>ans.x){\n                    ans=dp[i+1][j];\n                }else if(dp[i+1][j].x==ans.x&&dp[i+1][j].y>ans.y){\n                    ans=dp[i+1][j];\n                }\n           }\n       }\n       printf(\"%d %d\\n\",(ans.x-1>0?ans.x-1:0),ans.y);\n   }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define repl(i,a,b) for(i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n\nstruct P{\n\tint fi,se;\n};\n\n#define bool int\n#define false 0\n#define true 1\n#define P struct P\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint n,m;\nint board[1111][1111];\nbool is_prime[1111111];\n\nint dx[]={1,0,-1,0};\nint dy[]={0,-1,0,1};\n\nP mem[1111][1111];\nP none;\n\nP max(P a,P b){\n\tif(a.fi==b.fi){\n\t\tif(a.se>b.se)return a;\n\t\telse return b;\n\t}else if(a.fi>b.fi)return a;\n\telse return b;\n}\n\nP dfs(int x,int y){\n\tif(mem[x][y].fi!=-1)return mem[x][y];\n\tP res;\n\tres.fi=0; res.se=0;\n\tint xx;\n\trepl(xx,x-1,x+2){\n\t\tif(xx>=0&&xx<1111&&y+1>=0&&y+1<1111&&board[xx][y+1]!=0&&board[xx][y+1]<=m)res=max(res,dfs(xx,y+1));\n\t}\n\tif(is_prime[board[x][y]]){\n\t\tres.fi++;\n\t\tif(res.se==0)res.se=board[x][y];\n\t}\n\treturn mem[x][y]=res;\n}\n\nint main(){\n\t//cin.sync_with_stdio(false);\n\tmemset(is_prime,1,sizeof(is_prime));\n\tis_prime[0]=is_prime[1]=false;\n\tint i,j;\n\trep(i,1111111){\n\t\tif(is_prime[i]){\n\t\t\tfor(int j=i*2;j<1111111;j+=i)is_prime[j]=false;\n\t\t}\n\t}\n\tint num=1;\n\tint x=1111/2,y=1111/2;\n\tint len=1,state=0;\n\tnone.fi=-1; none.se=-1;\n\twhile(1){\n\t\trep(i,2){\n\t\t\trep(j,len){\n\t\t\t\tboard[x][y]=num++;\n\t\t\t\tx+=dx[state];y+=dy[state];\n\t\t\t}\n\t\t\tstate=(state+1)%4;\n\t\t}\n\t\tif(num>1000000)break;\n\t\tlen++;\n\t}\n\twhile(1){\n\t\tscanf(\"%d %d\",&m,&n);\n\t\tif(n==0)break;\n\t\tint sx,sy;\n\t\trep(i,1111)rep(j,1111){\n\t\t\tif(board[i][j]==n){\n\t\t\t\tsx=i;sy=j;\n\t\t\t}\n\t\t}\n\t\trep(i,1111)rep(j,1111)mem[i][j]=none;\n\t\tP res=dfs(sx,sy);\n\t\tprintf(\"%d %d\\n\", res.fi,res.se);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define INF 100000000\n#define MAX_N 1000000\n\ntypedef struct {\n\tint num;\n\tint max;\n\tint last;\n} FIELD;\n\ntypedef struct {\n\tint x;\n\tint y;\n} COORD;\n\nint isPrime[ MAX_N + 1 ] = { 0, 0, 1 }, corner[ 1998 ] = { 2 }, m;\nCOORD coord[ 1000001 ];\nFIELD field[ 1002 ][ 1001 ];\nconst int dx[ 7 ] = { 1, 0, -1 , 0, -1, 0, 1 }, dy[ 7 ] = { 0, -1, 0, 1, 1, 1, 1 };\n\nvoid dfs( int, int );\n\nint main( void ) {\n\tint i, j, add, x, y, d, cnt, n;\n\n\tfor ( i = 3; i <= MAX_N; i += 2 )\n\t\tisPrime[ i ] = 1;\n\n\tfor ( i = 3; i * i <= MAX_N; i += 2 )\n\t\tif ( isPrime[ i ] )\n\t\t\tfor ( j = i * 2; j <= MAX_N; j += i )\n\t\t\t\tisPrime[ j ] = 0;\n\n\tadd = 1;\n\tfor ( i = 1; i < 1998; i++ ) {\n\t\tcorner[ i ] = corner[ i - 1 ] + add;\n\t\tadd += i & 1;\n\t}\n\n\tx = y = 500;\n\td = cnt = 0;\n\tfor ( i = 1; i <= 1000000; i++ ) {\n\t\tcoord[ i ].x = x;\n\t\tcoord[ i ].y = y;\n\t\tfield[ x ][ y ].num = i;\n\n\t\tif ( i == corner[ cnt ] ) {\n\t\t\td = d + 1 & 3;\n\t\t\tcnt++;\n\t\t}\n\n\t\tx += dx[ d ];\n\t\ty += dy[ d ];\n\t}\n\n\tfor ( x = 1002; x--; field[ x ][ 1000 ].num = INF ) ;\n\tfor ( y = 1001; y--; field[ 0 ][ y ].num = field[ 1001 ][ y ].num = INF ) ;\n\n\tfor ( ; scanf( \"%d %d\", &m, &n ), m; printf( \"%d %d\\n\", field[ coord[ n ].x ][ coord[ n ].y ].max, field[ coord[ n ].x ][ coord[ n ].y ].last ) ) {\n\t\tfor ( i = m + 1; --i; field[ x = coord[ i ].x ][ y = coord[ i ].y ].max = INF, field[ x ][ y ].last = 0 ) ;\n\t\tfor ( i = m + 1; --i;  ) {\n\t\t\tfield[ coord[ i ].x ][ coord[ i ].y ].max = INF;\n\t\t\tfield[ coord[ i ].x ][ coord[ i ].y ].last = 0;\n\t\t}\n\n\t\tdfs( coord[ n ].x, coord[ n ].y );\n\t}\n\n\treturn 0;\n}\n\nvoid dfs( int x, int y ) {\n\tint i;\n\n\tfield[ x ][ y ].max = 0;\n\tfor ( i = 4; i < 7; i++ ) {\n\t\tint nx = x + dx[ i ], ny = y + dy[ i ];\n\n\t\tif ( field[ nx ][ ny ].num <= m ) {\n\t\t\tif ( field[ nx ][ ny ].max == INF )\n\t\t\t\tdfs( nx, ny );\n\n\t\t\tif ( field[ x ][ y ].max < field[ nx ][ ny ].max ) {\n\t\t\t\tfield[ x ][ y ].max = field[ nx ][ ny ].max;\n\t\t\t\tfield[ x ][ y ].last = field[ nx ][ ny ].last;\n\t\t\t} else if ( field[ x ][ y ].max == field[ nx ][ ny ].max )\n\t\t\t\tif ( field[ x ][ y ].last < field[ nx ][ ny ].last )\n\t\t\t\t\tfield[ x ][ y ].last = field[ nx ][ ny ].last;\n\t\t}\n\t}\n\n\tif ( isPrime[ field[ x ][ y ].num ] ) {\n\t\tif ( !field[ x ][ y ].max )\n\t\t\tfield[ x ][ y ].last = field[ x ][ y ].num;\n\n\t\tfield[ x ][ y ].max++;\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\nint dp[1500][1500];\nint max=0;\nint Max(int a0,int b0,int c0){\n    if(a0>=b0&&a0>=c0){\n        return a0;\n    }\n    else if(b0>=a0&&b0>=c0){\n        return b0;\n    }\n    return c0;\n}\nint large(int a,int b){\n    if(abs(a)>abs(b)) return a;\n    else return b;\n}\nstruct position{\n    int x1;\n    int y1;\n};\nint isPrime(int x){\n    int i;\n    if(x==1) return 0;\n    for(i=2;i<=(int)sqrt(x);i++){\n        if(x%i==0) return 0;\n    }\n    return 1;\n}\nint find(int x){\n    int i;\n    for(i=0;i<=x;i++){\n        if(i*i>=x&&i%2==1) return i;\n    }\n    return -1;\n}\nstruct position encode(int x){\n    int i,a,x1,x2,x3;\n    i=find(x);\n    a=(i-1)/2;\n    x1=i*i-i+1;\n    x2=x1-i+1;\n    x3=x2-i+1;\n    struct position p;\n    if(x>=x1){\n        p.x1=a+x-i*i;\n        p.y1=-a;\n    }\n    else if(x>=x2){\n        p.x1=-a;\n        p.y1=-a+x1-x;\n    }\n    else if(x>=x3&&x<x2){\n        p.x1=a-x+x3;\n        p.y1=a;\n    }\n    else{\n        p.x1=a;\n        p.y1=a-x3+x;\n    }\n    return p;\n}\nint decode(int x,int y){\n    if(x==0&&y==0) return 1;\n    int big,huge,i,x1,x2,x3;\n    big=large(x,y);\n    huge=abs(big);\n    i=abs(big)*2+1;\n    x1=i*i-i+1;\n    x2=x1-i+1;\n    x3=x2-i+1;\n    if(x>=0&&y>=0) {\n        if(x<huge)return x3+huge-x;\n        else if(y<=huge) return x3+y-huge;\n    }\n    else if(x<=0&&y>=0){\nif(x>-huge) return x2-huge-x;\nelse if(y<=huge) return x2-y+huge;\n    }\n    else if(x<=0&&y<=0){\n        if(x>(-huge)) return x1+x+huge;\n        else if(y>=(-huge)) return x1-y-huge;\n    } else {\n        if (x < huge) return i * i - huge + x;\n        else if (y>(-huge)) return x3-huge+y;\n        if(y==-huge) return i*i;\n    }\n    return -1;\n}\nint main(void){\n    int x,goal;\n    while(scanf(\"%d %d\",&goal,&x)==2) {\n        if(x==0&&goal==0) break;\n        int count=0,maxprime=0;\n        memset(dp,0, sizeof(dp));\n        int i,j;\n        int maxX;\n        int s=1,ss=1;\n        struct position p,p1;\n        p=encode(x);\n        p1=encode(goal);\n        maxX=Max(abs(p1.x1),abs(p1.y1),-1);\n        dp[p.x1+maxX][p.y1+maxX]=isPrime(x);\n        count=dp[p.x1+maxX][p.y1+maxX];\n        if(dp[p.x1+maxX][p.y1+maxX]==1) maxprime=x;\n        if(p.x1==maxX) ss=0;\n        if(p.x1==-maxX) s=0;\n        for(j=p.y1-1;j>=-maxX;j--){\n            for(i=p.x1-s;i<=p.x1+ss;i++){\n                if(decode(i,j)<=goal) {\n                    if (i == maxX) {\n                        dp[i + maxX][j + maxX] = Max(dp[i + maxX][j + 1 + maxX], dp[i - 1 + maxX][j + 1 + maxX], -100) +\n                                                 isPrime(decode(i, j));\n                    } else if (i == -maxX) {\n                        dp[i + maxX][j + maxX] = Max(dp[i + maxX][j + 1 + maxX], dp[i + 1 + maxX][j + 1 + maxX], -100) +\n                                                 isPrime(decode(i, j));\n                    } else {\n                        dp[i + maxX][j + maxX] = Max(dp[i + maxX][j + 1 + maxX], dp[i + 1 + maxX][j + maxX + 1],\n                                                     dp[i + maxX - 1][j + maxX + 1]) + isPrime(decode(i, j));\n                    }\n                    if (dp[i + maxX][j + maxX] > count && decode(i, j) <= goal) {\n                        count = dp[i + maxX][j + maxX];\n                        maxprime = decode(i, j);\n                    }\n                    if (dp[i + maxX][j + maxX] == count && decode(i, j) <= goal) {\n                        if (maxprime < decode(i, j) && isPrime(decode(i, j)) == 1) maxprime = decode(i, j);\n                    }\n                }\n            }\n            if(p.x1-s>-maxX) s++;\n            if(p.x1+ss<maxX) ss++;\n        }\n        printf(\"%d %d\\n\",count, maxprime);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "\n#include<stdio.h>\n\n#define Max 1000000\n#define SqrtMax 1000\n\ntypedef struct Result {\n    int count, last;\n} Result;\n\nint m, n;\n\nint cave[SqrtMax][SqrtMax];\nint itoy[Max + 1];\nint itox[Max + 1];\nint notPrime[Max + 1];\nResult memo[SqrtMax][SqrtMax];\n\nvoid makeCave() {\n    int dy[4] = {0, -1, 0, 1};\n    int dx[4] = {1, 0, -1, 0};\n    int i;\n    int y, x;\n    int direction;\n    y = x = SqrtMax / 2;\n    direction = 0;\n    cave[y][x] = 1;\n    itoy[1] = y;\n    itox[1] = x;\n    for(i = 1; i < Max; i++) {\n        y += dy[direction];\n        x += dx[direction];\n        cave[y][x] = i + 1;\n        itoy[i + 1] = y;\n        itox[i + 1] = x;\n        if(!cave[y + dy[(direction + 1) % 4]][x + dx[(direction + 1) % 4]]) direction = (direction + 1) % 4;\n    }\n}\n\nvoid makePrime() {\n    int i, j;\n    notPrime[0] = notPrime[1] = 1;\n    for(i = 2; i <= Max; i++) {\n        for(j = i << 1; j <= Max; j += i) {\n            notPrime[j] = 1;\n        }\n    }\n}\n\nint inRange(int y, int x) {\n    if(y < 0 || SqrtMax <= y) return 0;\n    if(x < 0 || SqrtMax <= x) return 0;\n    if(cave[y][x] > m) return 0;\n    return 1;\n}\n\nResult dfs(int y, int x) {\n    int dy[3] = {1, 1, 1};\n    int dx[3] = {-1, 0, 1};\n    int i;\n    Result result;\n    if(memo[y][x].count != -1) return memo[y][x];\n    if(!notPrime[cave[y][x]]) {\n        result.count = 1;\n        result.last = cave[y][x];\n    } else {\n        result.count = 0;\n        result.last = 0;\n    }\n    for(i = 0; i < 3; i++) {\n        int ny = y + dy[i];\n        int nx = x + dx[i];\n        Result r;\n        if(!inRange(ny, nx)) continue;\n        r = dfs(ny, nx);\n        if(result.count > !notPrime[cave[y][x]] + r.count) {\n            continue;\n        } else if(result.count == !notPrime[cave[y][x]] + r.count) {\n            result.last = (result.last > r.last ? result.last : r.last);\n        } else {\n            result.count = !notPrime[cave[y][x]] + r.count;\n            result.last = r.last;\n        }\n    }\n    return memo[y][x] = result;\n}\n\nint main(void) {\n    makeCave();\n    makePrime();\n    while(scanf(\"%d %d\", &m, &n), m | n) {\n        int i, j;\n        for(i = 0; i < SqrtMax; i++) for(j = 0; j < SqrtMax; j++) {\n            memo[i][j].count = -1;\n            memo[i][j].last = 0;\n        }\n        Result answer = dfs(itoy[n], itox[n]);\n        printf(\"%d %d\\n\", answer.count, answer.last);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\ntypedef struct\n{\n\tint first;\n\tint second;\n} P;\n\nP max(P a, P b)\n{\n\tif (a.first == b.first)\n\t{\n\t\tif (a.second > b.second)\n\t\t\treturn a;\n\t\telse\n\t\t\treturn b;\n\t}\n\telse if (a.first > b.first)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint n, m;\nint cave[1111][1111];\nbool is_prime[1111111];\nP memo[1111][1111];\nP none;\n\nP dfs(int x, int y)\n{\n\tif (memo[x][y].first != -1 && memo[x][y].second != -1)\n\t{\n\t\treturn memo[x][y];\n\t}\n\tP res;\n\tres.first = 0;\n\tres.second = 0;\n\tint xx;\n\tfor (xx = x - 1; xx <= x + 1; xx++)\n\t{\n\t\tif (xx >= 0 && xx < 1111 && y + 1 >= 0 && y + 1 < 1111 && cave[xx][y + 1] != 0 && cave[xx][y + 1] <= m)\n\t\t{\n\t\t\tres = max(res, dfs(xx, y + 1));\n\t\t}\n\t}\n\tif (is_prime[cave[x][y]])\n\t{\n\t\tres.first++;\n\t\tif (res.second == 0)\n\t\t{\n\t\t\tres.second = cave[x][y];\n\t\t}\n\t}\n\treturn memo[x][y] = res;\n}\n\nint main(void)\n{\n\tmemset(is_prime, 1, sizeof(is_prime));\n\tis_prime[0] = is_prime[1] = false;\n\tint i, j;\n\tfor (i = 0; i < 1111111; i++)\n\t{\n\t\tif (is_prime[i])\n\t\t{\n\t\t\tint j;\n\t\t\tfor (j = i * 2; j < 1111111; j += i)\n\t\t\t{\n\t\t\t\tis_prime[j] = false;\n\t\t\t}\n\t\t}\n\t}\n\tint num = 1;\n\tint x = 1111 / 2;\n\tint y = 1111 / 2;\n\tint len = 1;\n\tint dir = 0;\n\tnone.first = -1;\n\tnone.second = -1;\n\twhile (true)\n\t{\n\t\tfor (i = 0; i < 2; i++)\n\t\t{\n\t\t\tfor (j = 0; j < len; j++)\n\t\t\t{\n\t\t\t\tcave[x][y] = num++;\n\t\t\t\tx += dx[dir];\n\t\t\t\ty += dy[dir];\n\t\t\t}\n\t\t\tdir = (dir + 1) % 4;\n\t\t}\n\t\tif (num > 1000000)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tlen++;\n\t}\n\twhile (true)\n\t{\n\t\tscanf(\"%d %d\", &m, &n);\n\t\tif (n == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tint sx, sy;\n\t\tfor (i = 0; i < 1111; i++)\n\t\t{\n\t\t\tfor (j = 0; j < 1111; j++)\n\t\t\t{\n\t\t\t\tif (cave[i][j] == n)\n\t\t\t\t{\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < 1111; i++)\n\t\t{\n\t\t\tfor (j = 0; j < 1111; j++)\n\t\t\t{\n\t\t\t\tmemo[i][j] = none;\n\t\t\t}\n\t\t}\n\t\tP ans = dfs(sx, sy);\n\t\tprintf(\"%d %d\\n\", ans.first, ans.second);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void) {\n\tstatic char isPrime[1000001];\n\tstatic int caveInfo[3000][3000];\n\tstatic int pcNum[3000][3000];\n\tstatic int lastPc[3000][3000];\n\tint i,j;\n\tint m,n;\n\t/* eratosutenesu no furui */\n\tfor(i=2;i<=1000000;i++)isPrime[i]=1;\n\tfor(i=2;i<=1000000;i++) {\n\t\tif(isPrime[i]) {\n\t\t\tfor(j=i+i;j<=1000000;j+=i)isPrime[j]=0;\n\t\t}\n\t}\n\twhile(scanf(\"%d%d\",&m,&n)==2 && (m|n)!=0) {\n\t\tint x=1500,y=1500;\n\t\tint minx=3000,miny=3000,maxx=0,maxy=0;\n\t\tint sx,sy;\n\t\tint cnt=1,nowNum=1;\n\t\tint res=1,res_pc=0;\n\t\twhile(nowNum<=m) {\n\t\t\tfor(i=0;i<cnt;i++) {\n\t\t\t\tif(nowNum==n){sx=x;sy=y;}\n\t\t\t\tif(x<minx)minx=x;\n\t\t\t\tif(y<miny)miny=y;\n\t\t\t\tif(maxx<x)maxx=x;\n\t\t\t\tif(maxy<y)maxy=y;\n\t\t\t\tcaveInfo[y][x]=nowNum;\n\t\t\t\tpcNum[y][x]=lastPc[y][x]=0;\n\t\t\t\tnowNum++;\n\t\t\t\tx++;\n\t\t\t}\n\t\t\tfor(i=0;i<cnt;i++) {\n\t\t\t\tif(nowNum==n){sx=x;sy=y;}\n\t\t\t\tif(x<minx)minx=x;\n\t\t\t\tif(y<miny)miny=y;\n\t\t\t\tif(maxx<x)maxx=x;\n\t\t\t\tif(maxy<y)maxy=y;\n\t\t\t\tcaveInfo[y][x]=nowNum;\n\t\t\t\tpcNum[y][x]=lastPc[y][x]=0;\n\t\t\t\tnowNum++;\n\t\t\t\ty--;\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tfor(i=0;i<cnt;i++) {\n\t\t\t\tif(nowNum==n){sx=x;sy=y;}\n\t\t\t\tif(x<minx)minx=x;\n\t\t\t\tif(y<miny)miny=y;\n\t\t\t\tif(maxx<x)maxx=x;\n\t\t\t\tif(maxy<y)maxy=y;\n\t\t\t\tcaveInfo[y][x]=nowNum;\n\t\t\t\tpcNum[y][x]=lastPc[y][x]=0;\n\t\t\t\tnowNum++;\n\t\t\t\tx--;\n\t\t\t}\n\t\t\tfor(i=0;i<cnt;i++) {\n\t\t\t\tif(nowNum==n){sx=x;sy=y;}\n\t\t\t\tif(x<minx)minx=x;\n\t\t\t\tif(y<miny)miny=y;\n\t\t\t\tif(maxx<x)maxx=x;\n\t\t\t\tif(maxy<y)maxy=y;\n\t\t\t\tcaveInfo[y][x]=nowNum;\n\t\t\t\tpcNum[y][x]=lastPc[y][x]=0;\n\t\t\t\tnowNum++;\n\t\t\t\ty++;\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t\t/* do search */\n\t\tif(isPrime[caveInfo[sy][sx]]) {\n\t\t\tres=pcNum[sy][sx]=2;\n\t\t\tres_pc=lastPc[sy][sx]=caveInfo[sy][sx];\n\t\t} else {\n\t\t\tpcNum[sy][sx]=1;\n\t\t}\n\t\tfor(y=sy+1;y<=maxy;y++) {\n\t\t\tfor(x=minx;x<=maxx;x++) {\n\t\t\t\tint best=0;\n\t\t\t\tint bestPc=0;\n\t\t\t\tif(caveInfo[y][x]>0 && caveInfo[y][x]<=m) {\n\t\t\t\t\t/* get data */\n\t\t\t\t\tif(minx<x && caveInfo[y-1][x-1]>0 && caveInfo[y-1][x-1]<=m) {\n\t\t\t\t\t\tif(pcNum[y-1][x-1]>best ||\n\t\t\t\t\t\t(pcNum[y-1][x-1]==best && lastPc[y-1][x-1]>bestPc)) {\n\t\t\t\t\t\t\tbest=pcNum[y-1][x-1];\n\t\t\t\t\t\t\tbestPc=lastPc[y-1][x-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(caveInfo[y-1][x]>0 && caveInfo[y-1][x]<=m) {\n\t\t\t\t\t\tif(pcNum[y-1][x]>best ||\n\t\t\t\t\t\t(pcNum[y-1][x]==best && lastPc[y-1][x]>bestPc)) {\n\t\t\t\t\t\t\tbest=pcNum[y-1][x];\n\t\t\t\t\t\t\tbestPc=lastPc[y-1][x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(x<maxx && caveInfo[y-1][x+1]>0 && caveInfo[y-1][x+1]<=m) {\n\t\t\t\t\t\tif(pcNum[y-1][x+1]>best ||\n\t\t\t\t\t\t(pcNum[y-1][x+1]==best && lastPc[y-1][x+1]>bestPc)) {\n\t\t\t\t\t\t\tbest=pcNum[y-1][x+1];\n\t\t\t\t\t\t\tbestPc=lastPc[y-1][x+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* is this cave prime? */\n\t\t\t\t\tif(best>0 && isPrime[caveInfo[y][x]]) {\n\t\t\t\t\t\tbest++;\n\t\t\t\t\t\tbestPc=caveInfo[y][x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* save the result */\n\t\t\t\tpcNum[y][x]=best;\n\t\t\t\tlastPc[y][x]=bestPc;\n\t\t\t\t/* update global result */\n\t\t\t\tif(best>0 && (best>res || (best==res && bestPc>res_pc))) {\n\t\t\t\t\tres=best;\n\t\t\t\t\tres_pc=bestPc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",res-1,res_pc);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define INF 100000000\n#define MAX_N 1000000\n\ntypedef struct {\n\tint num;\n\tint max;\n\tint last;\n} FIELD;\n\nint isPrime[ MAX_N + 1 ] = { 0, 0, 1 }, corner[ 1998 ] = { 2 }, coord[ 1000001 ], m;\nFIELD field[ 1002 ][ 1001 ];\nconst int dx[ 7 ] = { 1, 0, -1 , 0, -1, 0, 1 }, dy[ 7 ] = { 0, -1, 0, 1, 1, 1, 1 };\n\nvoid dfs( int, int );\n\nint main( void ) {\n\tint i, j, add, x, y, d, cnt, n;\n\n\tfor ( i = 3; i <= MAX_N; i += 2 )\n\t\tisPrime[ i ] = 1;\n\n\tfor ( i = 3; i * i <= MAX_N; i += 2 )\n\t\tif ( isPrime[ i ] )\n\t\t\tfor ( j = i * 2; j <= MAX_N; j += i )\n\t\t\t\tisPrime[ j ] = 0;\n\n\tadd = 1;\n\tfor ( i = 1; i < 1998; i++ ) {\n\t\tcorner[ i ] = corner[ i - 1 ] + add;\n\t\tadd += i & 1;\n\t}\n\n\tx = y = 500;\n\td = cnt = 0;\n\tfor ( i = 1; i <= 1000000; i++ ) {\n\t\tcoord[ i ] = x * 1001 + y;\n\t\tfield[ x ][ y ].num = i;\n\n\t\tif ( i == corner[ cnt ] ) {\n\t\t\td = d + 1 & 3;\n\t\t\tcnt++;\n\t\t}\n\n\t\tx += dx[ d ];\n\t\ty += dy[ d ];\n\t}\n\n\tfor ( x = 1002; x--; field[ x ][ 1000 ].num = INF ) ;\n\tfor ( y = 1001; y--; field[ 0 ][ y ].num = field[ 1001 ][ y ].num = INF ) ;\n\n\tfor ( ; scanf( \"%d %d\", &m, &n ), m; printf( \"%d %d\\n\", field[ x ][ y ].max, field[ x ][ y ].last ) ) {\n\t\tfor ( i = m + 1; --i; field[ x = coord[ i ] / 1001 ][ y = coord[ i ] % 1001 ].max = INF, field[ x ][ y ].last = 0 ) ;\n\n\t\tdfs( x = coord[ n ] / 1001, y = coord[ n ] % 1001 );\n\t}\n\n\treturn 0;\n}\n\nvoid dfs( int x, int y ) {\n\tint i;\n\n\tfield[ x ][ y ].max = 0;\n\tfor ( i = 4; i < 7; i++ ) {\n\t\tint nx = x + dx[ i ], ny = y + dy[ i ];\n\n\t\tif ( field[ nx ][ ny ].num <= m ) {\n\t\t\tif ( field[ nx ][ ny ].max == INF )\n\t\t\t\tdfs( nx, ny );\n\n\t\t\tif ( field[ x ][ y ].max < field[ nx ][ ny ].max ) {\n\t\t\t\tfield[ x ][ y ].max = field[ nx ][ ny ].max;\n\t\t\t\tfield[ x ][ y ].last = field[ nx ][ ny ].last;\n\t\t\t} else if ( field[ x ][ y ].max == field[ nx ][ ny ].max )\n\t\t\t\tif ( field[ x ][ y ].last < field[ nx ][ ny ].last )\n\t\t\t\t\tfield[ x ][ y ].last = field[ nx ][ ny ].last;\n\t\t}\n\t}\n\n\tif ( isPrime[ field[ x ][ y ].num ] ) {\n\t\tif ( !field[ x ][ y ].max )\n\t\t\tfield[ x ][ y ].last = field[ x ][ y ].num;\n\n\t\tfield[ x ][ y ].max++;\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <memory.h>\n#include <math.h>\ntypedef long long int ll;\nlong long GCD(long long a, long long b) {return b?GCD(b,a%b):a;}\nlong long LCM(long long a, long long b) {return a/GCD(a,b)*b;}\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\n\n\nint IsPrime(int num)\n{\n    if (num < 2) return 0;\n    else if (num == 2) return 0;\n    else if (num % 2 == 0) return 0; // 偶数はあらかじめ除く\n    int i;\n    double sqrtNum = sqrt(num);\n    for (i = 3; i <= sqrtNum; i += 2)\n    {\n        if (num % i == 0)\n        {\n            // 素数ではない\n            return 0;\n        }\n    }\n\n    // 素数である\n    return 1;\n}\n\nint Prime[1000010];\nint ans=0;int pans=0;\nint G[3000][3000];\nint color[3000][3000];\nint dmax[3000][3000];\nvoid dfs(int x,int y,int d){\n\tif(dmax[x][y]>d)return;\n\tif(dmax[x][y]!=0&&dmax[x][y]==d)return;\n\tchmax(dmax[x][y],d);\n\n\tint i=0;\n\tfor(i=-1;i<=1;i++){\n\t\tint nx=x+1,ny=y+i;\n\t\tif(nx>=0&&nx<3000&&ny>=0&&ny<3000){\n\t\t\tif(G[nx][ny]!=-1){\n\t\t\t\tif(color[nx][ny]==0){\n\t\t\t\t\tcolor[nx][ny]=1;\n\t\t\t\t\tif(Prime[G[nx][ny]]==0){\n\t\t\t\t\t\td++;\n\t\t\t\t\t\tif(ans<d){\n\t\t\t\t\t\t\tans=d;\n\t\t\t\t\t\t\tpans=G[nx][ny];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(ans<=d){\n\t\t\t\t\t\t\tchmax(pans,G[nx][ny]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdfs(nx,ny,d);\n\t\t\t\t\tcolor[nx][ny]=0;\n\t\t\t\t\tif(Prime[G[nx][ny]]==0)d--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tint n,m;scanf(\"%d %d\",&m,&n);\n\tint i,j,k;\n\n\tPrime[0]=1;Prime[1]=1;\n\tfor(i=2;i<1000001;i++){\n\t\tif(Prime[i]==0)\n\t\tfor(j=2;i*j<=1000000;j++){\n\t\t\tPrime[i*j]=1;\n\t\t}\n\t}\n\n\n\twhile(n>0&&m>0){\n\t\tans=0;pans=0;\n\t\tfor(i=0;i<3000;i++){\n\t\t\tfor(j=0;j<3000;j++){\n\t\t\t\tG[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\tmemset(color,0,sizeof(color));\n\t\tmemset(dmax,0,sizeof(dmax));\n\t\ti=1500;j=1500;\n\t\tint now=1;int turn =0;int len=1;\n\t\tint cnt=0;\n\t\twhile(m){\n\t\t\t//G[i][j]=now++;\n\t\t\tfor(k=0;k<len;k++){\n\t\t\t\tG[i][j]=now++;\n\t\t\t\tif(turn==0)j++;\n\t\t\t\telse if(turn==1)i--;\n\t\t\t\telse if(turn==2)j--;\n\t\t\t\telse i++;\n\t\t\t\tm--;\n\t\t\t\tif(m<=0)break;\n\t\t\t}\n\t\t\tif(turn==0)turn =1;\n\t\t\telse if(turn==1)turn=2;\n\t\t\telse if(turn==2)turn=3;\n\t\t\telse turn =0;\n\t\t\tif(cnt==0)cnt++;\n\t\t\telse{\n\t\t\t\tcnt=0;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(i=0;i<20;i++){\n\t\t\tfor(j=0;j<20;j++){\n\t\t\t\tprintf(\"%d  \",G[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t*/\n\t\tint x=0,y=0;\n\t\tfor(x=0;x<3000;x++){\n\t\t\tfor(y=0;y<3000;y++){\n\t\t\t\tif(G[x][y]==n){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(G[x][y]==n){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d %d %d\\n\",x,y,n);\n\t\tint d=0;\n\t\tif(Prime[n]==0){\n\t\t\td=1;\n\t\t\tans=1;\n\t\t\tpans=n;\n\t\t}\n\t\tcolor[x][y]=1;\n\t\tdfs(x,y,d);\n\t\tprintf(\"%d %d\\n\",ans,pans);\n\t\tscanf(\"%d %d\",&m,&n);\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n#define M 1000000\n#define N 1000\n#define ROOP(i,a,b) for(i = a;i < b;i++) //* [a,b)\n\n//* important!!!\n//* dp[y(i)][x(j)]\nint dp[N+2][N+2];\nint board[N+2][N+2],prime[M+1];\n\nvoid init();\nvoid print();\n\t\nint main(){\n\tint i,j,k,l,m,n;\n\tint x,y;\n\tint cnt,ans,max;\n\tint q;\n\t//int* tmp1;\n\t//int* tmp2;\n\n\tinit();\n\t//print();\n\n\twhile(scanf(\"%d%d\",&m,&n),m+n){\n\t\tROOP(x,1,N+1)ROOP(y,1,N+1)if(board[y][x] == n)goto BREAK;\n\t\tBREAK:\n\n\t\tdp[y][x] = (prime[n] == 1);\n\t\tmax = dp[y][x];\n\t\tans = (max?n:0);\n\t\tq = sqrt(m-1)/2+1;\n\n\t\ti = y;\n\t\twhile(i < q+501 && i < N){\n\t\t\tj = x-(i-y);\n\t\t\tif(j <= 0)j = 1;\n\t\t\twhile(j <= x+(i-y) && j <= N){//\n\t\t\t\tROOP(k,-1,2){\n\t\t\t\t\t//tmp1 = &(board[i+1][j+k]);\n\t\t\t\t\t//tmp2 = &(dp[i+1][j+k]);\n\t\t\t\t\tif(board[i+1][j+k] > m)continue;\n\t\t\t\t\tif(j+k == 0 || j+k == 1001)continue;//\n\t\t\t\t\tif(dp[i][j]+prime[board[i+1][j+k]] > dp[i+1][j+k])\n\t\t\t\t\t\tdp[i+1][j+k] = dp[i][j]+prime[board[i+1][j+k]];\n\t\t\t\t\tif(max == dp[i+1][j+k] && prime[board[i+1][j+k]])\n\t\t\t\t\t\tif(ans < board[i+1][j+k])\n\t\t\t\t\t\t\tans = board[i+1][j+k];\n\t\t\t\t\tif(max < dp[i+1][j+k]){\n\t\t\t\t\t\tmax = dp[i+1][j+k];\n\t\t\t\t\t\tans = board[i+1][j+k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tprintf(\"%d %d\\n\",max,ans);\n\t}\n\treturn 0;\n}\n\nvoid init(){\n\tint i,j;\n\tint dir,x,y,nowx,nowy;\n\tint vecx[4] = { 1, 0,-1, 0};\n\tint vecy[4] = { 0, 1, 0,-1};\n\t\n\t//* set prime\n\tprime[2] = 1;\n\tfor(i = 3;i <= M;i += 2)prime[i] = 1;\n\tfor(i = 3;i*i <= M;i += 2)\n\t\tif(prime[i])for(j = i*i;j <= M;j += i)prime[j] = 0;\n\n\t//* make wall around the board\n\tROOP(i,0,N+2){\n\t\tboard[0][i] = 1;\n\t\tboard[i][0] = 1;\n\t\tboard[N+1][i] = 1;\n\t\tboard[i][N+1] = 1;\n\t}\n\n\t//* set board\n\tdir = 0;x = 0;y = 1;\n\tfor(i = M;i >= 0;i--){\t//* fill from the outside\n\t\tnowx = x+vecx[dir];\n\t\tnowy = y+vecy[dir];\n\t\tif(board[nowy][nowx]){//* if hit the wall\n\t\t\tdir = (dir + 1)%4;\n\t\t\tnowx = x+vecx[dir];\n\t\t\tnowy = y+vecy[dir];\n\t\t}\n\t\tboard[nowy][nowx] = i;\n\t\tx = nowx;y = nowy;\n\t}\n}\n\nvoid print(){\n\tint i,j;\n\tint m = 1039,n = 1;\n\tint q;\n\tint x,y;\n\n\tROOP(x,1,N+1)ROOP(y,1,N+1)if(board[y][x] == n)goto BREAK;\n\tBREAK:\n\n\tq = sqrt(m)/2+1;printf(\"%d %d\\n\\n\",y,x);\n\tfor(i = 0;y+i < 501+q;i++){\n\t\tfor(j = 0;x+j < 501+q;j++){\n\t\t\tprintf(\"%4d \",board[y+i][x+j]);\n\t\t}puts(\"\");\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\t\t\t"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define INF 100000000\n#define MAX_N 1000000\n\ntypedef struct {\n\tint num;\n\tint max;\n\tint last;\n} FIELD;\n\nint isPrime[ MAX_N + 1 ] = { 0, 0, 1 }, corner[ 1998 ] = { 2 }, coord[ 1000001 ], m;\nFIELD field[ 1002 ][ 1001 ];\nconst int dx[ 7 ] = { 1, 0, -1 , 0, -1, 0, 1 }, dy[ 7 ] = { 0, -1, 0, 1, 1, 1, 1 };\n\nvoid dfs( int, int );\n\nint main( void ) {\n\tint i, j, add, x, y, d, cnt, n;\n\n\tfor ( i = 3; i <= MAX_N; i += 2 )\n\t\tisPrime[ i ] = 1;\n\n\tfor ( i = 3; i * i <= MAX_N; i += 2 )\n\t\tif ( isPrime[ i ] )\n\t\t\tfor ( j = i * 2; j <= MAX_N; j += i )\n\t\t\t\tisPrime[ j ] = 0;\n\n\tadd = 1;\n\tfor ( i = 1; i < 1998; i++ ) {\n\t\tcorner[ i ] = corner[ i - 1 ] + add;\n\t\tadd += i % 2 ? 1 : 0;\n\t}\n\n\tx = y = 500;\n\td = cnt = 0;\n\tfor ( i = 1; i <= 1000000; i++ ) {\n\t\tcoord[ i ] = x * 1001 + y;\n\t\tfield[ x ][ y ].num = i;\n\n\t\tif ( i == corner[ cnt ] ) {\n\t\t\td = d + 1 & 3;\n\t\t\tcnt++;\n\t\t}\n\n\t\tx += dx[ d ];\n\t\ty += dy[ d ];\n\t}\n\n\tfor ( x = 1002; x--; field[ x ][ 1000 ].num = INF ) ;\n\tfor ( y = 1001; y--; field[ 0 ][ y ].num = field[ 1001 ][ y ].num = INF ) ;\n\n\tfor ( ; scanf( \"%d %d\", &m, &n ), m; printf( \"%d %d\\n\", field[ x ][ y ].max, field[ x ][ y ].last ) ) {\n\t\tfor ( i = m + 1; --i; field[ x = coord[ i ] / 1001 ][ y = coord[ i ] % 1001 ].max = INF, field[ x ][ y ].last = 0 ) ;\n\n\t\tdfs( x = coord[ n ] / 1001, y = coord[ n ] % 1001 );\n\t}\n\n\treturn 0;\n}\n\nvoid dfs( int x, int y ) {\n\tint i;\n\n\tfield[ x ][ y ].max = 0;\n\tfor ( i = 4; i < 7; i++ ) {\n\t\tint nx = x + dx[ i ], ny = y + dy[ i ];\n\n\t\tif ( field[ nx ][ ny ].num <= m ) {\n\t\t\tif ( field[ nx ][ ny ].max == INF )\n\t\t\t\tdfs( nx, ny );\n\n\t\t\tif ( field[ x ][ y ].max < field[ nx ][ ny ].max ) {\n\t\t\t\tfield[ x ][ y ].max = field[ nx ][ ny ].max;\n\t\t\t\tfield[ x ][ y ].last = field[ nx ][ ny ].last;\n\t\t\t} else if ( field[ x ][ y ].max == field[ nx ][ ny ].max )\n\t\t\t\tif ( field[ x ][ y ].last < field[ nx ][ ny ].last )\n\t\t\t\t\tfield[ x ][ y ].last = field[ nx ][ ny ].last;\n\t\t}\n\t}\n\n\tif ( isPrime[ field[ x ][ y ].num ] ) {\n\t\tif ( !field[ x ][ y ].max )\n\t\t\tfield[ x ][ y ].last = field[ x ][ y ].num;\n\n\t\tfield[ x ][ y ].max++;\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define A 1000000\n#define B 2020\n#include<math.h>\n\nint m,s;\ntypedef struct{\n    int count; //ここを調査した後の，調査してきた洞窟の総数の最大値\n    int num; //0からスタート，何番目の洞窟か\n    int last;\n} cave_struct;\ncave_struct cave[B][B]; //cave[1000][1000]が0番目に対応\n\nint N[A] = {}; //0が格納されていれば（添字＋1）は素数．全て素数で初期化．\nvoid setPrime(){\n    int i, j;\n    int sqrt_A = sqrt(A);\n    N[0] = 1;\n    for(i = 1; i <= sqrt_A; i++){\n        if(N[i] == 0){\n            for(j = 2; j * (i + 1) <= A; j++){\n                N[j * (i + 1) - 1] = 1;\n            }\n        }\n    }\n}\nint co = 0;\nint pos_x = 1000, pos_y = 1000, f_x, f_y;\nint next = 1;\nvoid setCave_1(){\n    int i,j;\n    for(i = 0; i < B; i++){\n        for(j = 0; j < B; j++){\n            cave[i][j].count = -1;\n            cave[i][j].num = -1; //未登録\n        }\n    }\n}\nvoid setCave(){\n    int i;\n    while(1){\n        for(i = 0; i < next; i++){\n            //右へ\n            cave[pos_y][pos_x++].num = co++;\n            if(co == s){\n                f_x = pos_x-1; f_y = pos_y;\n            }\n            if(co > m-1) break;\n        }\n        if(co > m-1) break;\n        for(i = 0; i < next; i++){\n            //上へ\n            cave[pos_y--][pos_x].num = co++;\n            if(co == s){\n                f_x = pos_x; f_y = pos_y+1;\n            }\n            if(co > m-1) break;\n        }\n        if(co > m-1) break;\n        next++;\n        for(i = 0; i < next; i++){\n            //左へ\n            cave[pos_y][pos_x--].num = co++;\n            if(co == s){\n                f_x = pos_x+1; f_y = pos_y;\n            }\n            if(co > m-1) break;\n        }\n        if(co > m-1) break;\n        for(i = 0; i < next; i++){\n            //下へ\n            cave[pos_y++][pos_x].num = co++;\n            if(co == s){\n                f_x = pos_x; f_y = pos_y-1;\n            }\n            if(co > m-1) break;\n        }\n        if(co > m-1) break;\n        next++;\n    }\n    cave[f_y][f_x].count = 1 - N[cave[f_y][f_x].num];\n    //printf(\"%d\\n\",cave[f_y][f_x].count);\n    if(cave[f_y][f_x].num == 1){\n                cave[f_y][f_x].last = cave[f_y][f_x].num;\n     }\n\n}\n\nint max_last = 0;\nint max = -1;\nvoid expCave(int y, int x){\n    if(cave[y][x].count == -1) return;\n    //printf(\"%d, %d\\n\",cave[y][x].num+1,cave[y][x].count);\n    //printf(\" %d, %d\\n\",max_last,max);\n\n\n    if(cave[y][x].count > max){\n        max = cave[y][x].count;\n        max_last = cave[y][x].last;\n        //printf(\"%d, %d\\n\",cave[y][x].num+1,cave[y][x].count);\n        //printf(\"  %d, %d\\n\",max_last,max);\n    }else if(cave[y][x].count == max && cave[y][x].last > max_last){\n        max = cave[y][x].count;\n        max_last = cave[y][x].last;\n        //printf(\"  %d, %d\\n\",max_last,max);\n    }\n\n\n    //printf(\" %d, %d\\n\",max_last,max);\n    if(cave[y+1][x-1].num != -1){\n        if(cave[y+1][x-1].count <= cave[y][x].count){\n            cave[y+1][x-1].count = cave[y][x].count;\n            if(N[cave[y+1][x-1].num] == 0){\n                cave[y+1][x-1].last = cave[y+1][x-1].num;\n                cave[y+1][x-1].count++;\n                if(cave[y+1][x-1].count > max){\n                    max = cave[y+1][x-1].count;\n                    max_last = cave[y+1][x-1].last;\n                    //printf(\"%d, %d\\n\",max_last,max);\n                }else if(cave[y+1][x-1].count == max && cave[y+1][x-1].num > max_last){\n                    max = cave[y+1][x-1].count;\n                    max_last = cave[y+1][x-1].num;\n                    //printf(\"%d, %d\\n\",max_last,max);\n                }\n            }else{\n                cave[y+1][x-1].last = cave[y][x].last;\n            }\n        }\n    }\n    //printf(\" %d, %d\\n\",max_last,max);\n    if(cave[y+1][x].num != -1){\n        if(cave[y+1][x].count <= cave[y][x].count){\n            cave[y+1][x].count = cave[y][x].count;\n            if(N[cave[y+1][x].num] == 0){\n                cave[y+1][x].last = cave[y+1][x-1].num;\n                cave[y+1][x].count++;\n                if(cave[y+1][x].count > max){\n                    max = cave[y+1][x].count;\n                    max_last = cave[y+1][x].last;\n                    //printf(\"%d, %d\\n\",max_last,max);\n                }else if(cave[y+1][x].count == max && cave[y+1][x].num > max_last){\n                    max = cave[y+1][x].count;\n                    max_last = cave[y+1][x].num;\n                    //printf(\"%d, %d\\n\",max_last,max);\n                }\n            }else{\n                cave[y+1][x].last = cave[y][x].last;\n            }\n        }\n    }\n    //printf(\" %d, %d\\n\",max_last,max);\n    if(cave[y+1][x+1].num != -1){\n        if(cave[y+1][x+1].count <= cave[y][x].count){\n            cave[y+1][x+1].count = cave[y][x].count;\n            if(N[cave[y+1][x+1].num] == 0){\n                cave[y+1][x+1].last = cave[y+1][x-1].num;\n                cave[y+1][x+1].count++;\n                if(cave[y+1][x+1].count > max){\n                    max = cave[y+1][x+1].count;\n                    max_last = cave[y+1][x+1].last;\n                    //printf(\"%d, %d\\n\",max_last,max);\n                }else if(cave[y+1][x+1].count == max && cave[y+1][x+1].num > max_last){\n                    max = cave[y+1][x+1].count;\n                    max_last = cave[y+1][x+1].num;\n                    //printf(\"%d, %d\\n\",max_last,max);\n                }\n            }else{\n                cave[y+1][x+1].last = cave[y][x].last;\n            }\n        }\n    }\n    //printf(\" %d, %d\\n\",max_last,max);\n\n}\n\nint main(void){\n    setPrime();\n    //while(1){\n        scanf(\"%d %d\", &m, &s);\n        //if(!m && !s) break;\n        co = 0; pos_x = 1000; pos_y = 1000; next = 1; max_last = 0; max = -1;\n        setCave_1();\n        setCave();\n        //printf(\"(%d, %d)\\n\",f_x,f_y);\n        for(int i = 1; i < B-1; i++){\n            for(int j = 1; j < B-1; j++){\n                expCave(i, j);\n            }\n        }\n        printf(\"%d %d\\n\",max,max_last+1);\n        \n        for(int i =  997; i <= 1003; i++){\n            for(int j = 997; j <= 1003; j++){\n                printf(\"%2d \",cave[i][j].num);\n            }\n            printf(\"\\n\");\n        }\n        \n    //}\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX_M 1000000\n#define DIV_MM 1000 \n#define MAP_SIZE 1002 // MAP_SIZE = ceiling(sqrt(MAX_M))+2\n// ???????????????????????§??????????´???´?????¨???????????????\n#define CENTER 500 // ??????????´???´?????????\ntypedef struct map_type {\n int id; // ?´???´?????????\n int np; // ?????????????§???????????????????????´???°?´???´????????°\n int lp; // ????¨????????????????????????§??????????????????????´???°?´???´??????????????§???\n} map_t;\nmap_t map[MAP_SIZE][MAP_SIZE]; // ?´???´????????????\nint is_prime[MAX_M+1]; // ?´???°??¨???is_prime[i]=1 <--> i ????´???°\n// ?´???´?????????????????????????§?????????? 0??????, 1??????, 2??????, 3??????\nint dx[ ] = {1, 0, -1, 0};\nint dy[ ] = {0, -1, 0, 1};\nint m, n; // m = ?´???´????????°??? n = ??????????´???´??????\nint nx, ny;// ??????????´???´?????????\nint min_x, max_x, min_y, max_y; // ?????????: ??????????°????,?????§???,?????????????°????,?????§???\nvoid init_map(void) // ?´???´??????????????????????????????\n{\n int i,j;\n for(i=0; i<MAP_SIZE; i++)\n for(j=0; j<MAP_SIZE; j++){\n map[i][j].id = map[i][j].lp = 0;\n map[i][j].np = -1;\n }\n}\n// ??????????????????\nvoid gen_map(void)\n{\n int x, y, len, dir, i,j,id;\n init_map(); // ?????????????????????\n x = y = CENTER; // 1 ???????´???´?????????\n min_x = max_x = min_y = max_y = CENTER;\n map[y][x].id = 1;\n if(n == 1){ // ???????????\\????´???´?????????????????????????????? nx,ny ????????????\n nx = x; ny = y;\n }\n len = 1; dir = 0; id = 2;\n while(id <= m){ // id ????´???´????????° m ?????????????????§??\\????????°?????????\n for(i=0; i<2; i++){ // ????????????????§???????????????°?????????\n for(j=0; j<len; j++){ // dir ??????????????? len ?§????\nx += dx[dir]; y += dy[dir];\nif(x > max_x) max_x = x; // max_x ?????´??°\nif(x < min_x) min_x = x; // min_x ?????´??°\nif(y > max_y) max_y = y; // max_y ?????´??°\nif(y < min_y) min_y = y; // min_y ?????´??°\nif(id == n){ // ???????????\\????´???´?????????????????? nx,ny ????????????\n nx = x; ny = y;\n}\nmap[y][x].id = id++; // ?´???´??????????????????\nif(id > m) break;\n }\n dir = (dir+1)%4; // ????????????????????????\n if(id > m) break;\n }\n len++;\n }\n}\n// ?´???°??¨?????????(??¨??????????????????????????????)\n// is_prime[i] = 1 <--> i ????´???°, is_prime[i] = 0 <--> i ???????´???°\nvoid gen_prime()\n{\n int i,j;\n for(i=0; i<= MAX_M; i++) is_prime[i] = 1; // ??¨??????????????¨????´???°??¨??????\n is_prime[0] = is_prime[1] = 0; // 0, 1 ???????´???°\n for(i=2; i<=DIV_MM; i++){ // DIV_MM ?????§????´???°????????????????????§????????§??????\n if(is_prime[i]){ // i ????´???°?????¨???\n for(j = 2*i; j<=MAX_M; j += i) // i ????????°???????´???°\nis_prime[j] = 0;\n }\n }\n}\n// ??±???????????¢?´¢??§?±???????\nmap_t dfs(int x, int y)\n{\n map_t d;\n int id, np, lp, dx;\n if(map[y][x].id == 0){ // ?´???´??§?????????\n d.id = d.np = d.lp = 0;\n }\n else if(map[y][x].np >= 0){ // ??¢????¨??????????\n d =map[y][x];\n }\n else {\n np = lp = 0;\n id = map[y][x].id;\n for(dx=-1; dx <= 1; dx++){ // ?§??????????????????????????±?????´???´????????????\n d = dfs(x+dx, y+1); // ?´???°?´???´??°??¨???????´???°?´???´??????????±???????\n if(d.np > np){ // ?´???°?´???´??°???????????§???????????°\nnp = d.np; // ?´???°?´???´??°??¨\nlp = d.lp; // ???????´???°?´???´???????????´??°\n }\n else if(d.np == np){ // ?´???°?´???´??°???????????´??????\nif(d.lp > lp) lp = d.lp; // ???????´???°?´???´???????????§?????????????????¨\n }\n }\n if(is_prime[id]){ // ??????????´???°?´???´?????´???\n if(np == 0) // ????????????????±????????????????????´???°?´???´??????????????°\nlp = id; // ???????´???°?´???´??????????´???°?´???´??¨??????\n np++; // ?????????????´???°?´???´??°???????¢???????\n }\n d.id = id; d.np = np; d.lp = lp;\n map[y][x] = d;\n }\n return d;\n}\nint main()\n{\n int x, y, dx, np, lp;\n map_t d;\n gen_prime(); // ?´???°??¨?????????\n while(1){\n scanf(\"%d %d?\\n\", &m, &n); // m, n ?????\\???\n if(m==0 && n==0) break; // ??±??? 0 ????????????\n gen_map(); // ??????????????????\n d = dfs(nx,ny);\n printf(\"%d %d?\\n\", d.np, d.lp);\n }\nreturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\nstruct cave {\n    int i;\n    int j;\n    int Kakomonn;\n};\n\n#define max(x,y) ( x>y?x:y )\n\nint isPrime(int x){\n\n    int i;\n\n    if(x < 2 || x == 4) return 0;\n\n    if(x == 2 || x == 3 || x == 5) return 1;\n\n    else if((x>5 && ((x-1)%6==0 || ((x+1)%6==0))))\n    {\n        for(i=3;i<=sqrt(x);++i)\n        {\n            if(x%i==0) return 0;\n        }\n        return 1;\n    }\n    return 0;\n}\n\nint main()\n{\n\n    struct cave *cave; // 洞穴の番号と座標を格納する構造体\n\n    cave = (struct cave*)malloc(sizeof(struct cave) * 1000001);\n\n    int value[1000][1000];\n    int map[1000][1000];\n    int maxi;\n//    int maxi[1000][1000];\n//    memset(maxi, 0, sizeof(maxi));\n\n    int tail, top;\n    int i, j, k, limit, flag, cnt;\n\n    // 石窟寺院建設工事\n    k = 1000000;\n    i = 0;\n    j = 0;\n    limit = 1000;\n    flag = 0;\n    cnt = 0;\n    while(k > 0)\n    {\n        // 教典を素数洞穴に置く\n        if(isPrime(k)){\n            cave[k].Kakomonn = 1;\n        }else{\n            cave[k].Kakomonn = 0;\n        }\n\n        if(flag == 0) //右へ\n        {\n            map[i][j] = k;\n            cave[k].i = i;\n            cave[k].j = j;\n//            maxi[i][j] = max(maxi[i][j], i);\n            j++;\n\n            cnt++;\n            if(cnt == limit - 1)\n            {\n                flag = 1; // 方向を変える\n                cnt = 0;\n            }\n        }\n        else if(flag == 1) //下へ\n        {\n            map[i][j] = k;\n            cave[k].i = i;\n            cave[k].j = j;\n//            maxi[i][j] = max(maxi[i][j], i);\n            i++;\n\n            cnt++;\n            if(cnt == limit - 1)\n            {\n                flag = 2;\n                cnt = 0;\n            }\n        }\n        else if(flag == 2) //左へ\n        {\n            map[i][j] = k;\n            cave[k].i = i;\n            cave[k].j = j;\n//            maxi[i][j] = max(maxi[i][j], i);\n            j--;\n\n            cnt++;\n            if(cnt == limit - 1)\n            {\n                flag = 3;\n                cnt = 0;\n            }\n        }\n        else if(flag == 3) //上へ\n        {\n            map[i][j] = k;\n            cave[k].i = i;\n            cave[k].j = j;\n//            maxi[i][j] = max(maxi[i][j], i);\n\n            cnt++;\n            if(cnt == limit - 1) // 内側のサークルへ\n            {\n                flag = 0;\n                cnt = 0;\n                limit -= 2;\n\n                j++;\n                k--;\n                continue;\n            }\n\n            i--;\n        }\n\n        k--;\n    }\n\n    while(scanf(\"%d %d\", &tail, &top) == 2 && tail && top)\n    {\n        memset(value, 0, sizeof(value));\n//        memset(maxi, 0, sizeof(maxi));\n\n        int l, r, Max_value = 0, Max_prime = 0, flag = 0;\n        int k;\n\n        l = cave[top].j;\n        r = cave[top].j;\n\n        maxi = cave[top].i;\n        for(k = 1;k <= tail;++k)\n        {\n            maxi = max(maxi, cave[k].i);\n        }\n\n        for(i = cave[top].i; i <= maxi; ++i)\n        {\n            for(j = l; j <= r; ++j)\n            {\n                if(map[i][j] > tail)\n                {\n                    flag = 1;\n                    break;\n                }\n\n                if(i-1 >= 0 && j-1 >= 0)\n                {\n                    value[i][j] = max(value[i][j], value[i-1][j-1]);\n                }\n                if(i-1 >= 0 && j+1 <= 999)\n                {\n                    value[i][j] = max(value[i][j], value[i-1][j+1]);\n                }\n                if(i-1 >= 0)\n                {\n                    value[i][j] = max(value[i][j], value[i-1][j]);\n                }\n\n                if(cave[ map[i][j] ].Kakomonn == 1)\n                {\n                    value[i][j]++;\n\n                    if(value[i][j] > Max_value)\n                    {\n                        Max_value = value[i][j];\n\n                        Max_prime = map[i][j];\n                    }\n                    else if(value[i][j] == Max_value)\n                    {\n                        if(map[i][j] > Max_prime)\n                        {\n                            Max_prime = map[i][j];\n                        }\n                    }\n                }\n            }\n\n            if(flag) break;\n\n            if(l - 1 > 0 && map[i+1][l-1] <= tail)\n            {\n                l -= 1;\n            }\n            else if(l - 1 > 0 && map[i+1][l] > tail)\n            {\n                l += 1;\n            }\n\n            if(r + 1 < 999 && map[i+1][r+1] <= tail){\n                r += 1;\n            }\n        }\n\n        printf(\"%d %d\\n\", Max_value, Max_prime);\n//        printf(\"%d %d %d %d\\n\", t[m[l].i][m[l].j], m[l].i, m[l].j, m[l].Kakomonn);\n\n    }\n\n    free(cave);\n    return 0;\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.*\n\nfun main(args:Array<String>?): Unit {\n    val isPrime = BooleanArray(1000002){true}\n    for (i in 2 .. 1001) if (isPrime[i]){\n        for (j in i * i .. 1000001 step i){\n            isPrime[j] = false\n        }\n    }\n    isPrime[0] = false\n    isPrime[1] = false\n    val length = IntArray(1000002){-1}\n    while(true){\n        val (m, n) = readLine()!!.trim().split(' ').map(String::toInt)\n        if (m == 0 && n == 0) return\n        val start = fromNumber(n)\n        val queue: Queue<Triple<Int, Int, Int>> = LinkedList()\n        queue.add(Triple(start.first, start.second, n))\n        length[n] = if (isPrime[n]) 1 else 0\n        var maxPrime = if (isPrime[n]) n else 0\n        var maxLength = length[n]\n        while(queue.isNotEmpty()){\n            val (x, y, current) = queue.poll()\n            for (nx in x - 1 .. x + 1) {\n                val suspect = fromPosition(nx, y + 1)\n                if (suspect <= m) {\n                    if (length[suspect] == -1){\n                        queue.add(Triple(nx, y + 1, suspect))\n                    }\n                    if (isPrime[suspect]) {\n                        length[suspect] = Math.max(length[current] + 1, length[suspect])\n                        if (maxLength == length[suspect] && maxPrime < suspect) maxPrime = suspect\n                        else if (maxLength < length[suspect]) {\n                            maxPrime = suspect\n                            maxLength = length[suspect]\n                        }\n                    }else {\n                        length[suspect] = Math.max(length[current], length[suspect])\n                    }\n                }\n            }\n        }\n        (0 .. m).forEach { length[it] = -1 }\n        println(if(maxLength == 0) \"0 0\" else \"$maxLength $maxPrime\")\n    }\n\n}\nfun fromPosition(x: Int, y: Int): Int {\n    val max = Math.max(Math.abs(x), Math.abs(y))\n    return if (y > 0 && y == max) (max * 2 + 1) * (max * 2 + 1) - max + x\n    else if (y < 0 && y == - max) (max * 2 - 1) * (max * 2 - 1) + max * 2 + max - x\n    else if (x > 0) (max * 2 - 1) * (max * 2 - 1) + max - y\n    else (max * 2 - 1) * (max * 2 - 1) + 5 * max + y\n}\nfun fromNumber(number: Int): Pair<Int, Int> {\n    val size = (0 until number).find { (it * 2 + 1) * (it * 2 + 1) >= number }!!\n    for (x in -size .. size) {\n        if (fromPosition(x, size) == number) return Pair(x, size)\n        if (fromPosition(x, -size) == number) return Pair(x, -size)\n    }\n    for (y in -size .. size){\n        if (fromPosition(size, y) == number) return Pair(size, y)\n        if (fromPosition(-size, y) == number) return Pair(-size, y)\n    }\n    TODO()\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n \npublic class Main{\n\tprivate boolean[] prime;\n\t\n\tpublic void setPrime(int m){\n\t\tprime = new boolean[m + 1];\n\t\tArrays.fill(prime, true);\n\t\tfor(int i = 2; i * i <= m; i++){\n\t\t\tif(prime[i]){\n\t\t\t\tfor(int j = i * 2; j <= m; j += i){\n\t\t\t\t\tprime[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint[][] map;\n\tint[][] dp;\n\tint[][] maxP;\n\t\n\tpublic void setMap(int m){\n\t\tmap = new int[m][m];\n\t\tint[] DC = {1, 0, -1,0};\n\t\tint[] DR = {0,-1,  0,1};\n\t\t\n\t\tint pr = m / 2;\n\t\tint pc = (m - 1) / 2;\n\t\tint muki = 0;\n\t\tint dc = 1;\n\t\tint dr = 0;\n\t\tmap[pr][pc] = 1;\n\t\tfor(int i = 2; i <= m * m; i++){\n\t\t\tpr += dr;\n\t\t\tpc += dc;\n\t\t\tmap[pr][pc] = i;\n\t\t\tint mm = (muki + 1) % 4;\n\t\t\tint nr = DR[mm];\n\t\t\tint nc = DC[mm];\n\t\t\tif(map[pr + nr][pc + nc] == 0){\n\t\t\t\tdr = nr;\n\t\t\t\tdc = nc;\n\t\t\t\tmuki = mm;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void solve(){\n\t\tsetPrime(1000000);\n\t\tsetMap(1005);\n\t\tdp = new int[1005][1005];\n\t\tmaxP = new int[1005][1005];\n\t\twhile(true){\n\t\t\tint M = nextInt();\n\t\t\tint N = nextInt();\n\t\t\tif(M == 0) break;\n\t\t\tfor(int i = 0; i < dp.length; i++){\n\t\t\t\tArrays.fill(dp[i], -1);\n\t\t\t\tArrays.fill(maxP[i], 0);\n\t\t\t}\n\t\t\tint pr = 0;\n\t\t\tint pc = 0;\n\t\t\tfor(int i = 0; i < map.length; i++){\n\t\t\t\tfor(int j = 0; j < map[i].length; j++){\n\t\t\t\t\tif(map[i][j] == N){\n\t\t\t\t\t\tpr = i;\n\t\t\t\t\t\tpc = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trecur(pr, pc, M);\n\t\t\tout.println(dp[pr][pc] + \" \" + maxP[pr][pc]);\n\t\t}\n\t}\n\t\n\tpublic int recur(int r, int c, int M){\n\t\tif(map[r][c] > M){\n\t\t\treturn 0;\n\t\t}\n\t\tif(dp[r][c] >= 0){\n\t\t\treturn dp[r][c];\n\t\t}\n\t\tint ans = recur(r + 1, c - 1, M);\n\t\tmaxP[r][c] = maxP[r + 1][c - 1];\n\t\tint a2 = recur(r + 1, c, M);\n\t\tif(ans < a2){\n\t\t\tans = a2;\n\t\t\tmaxP[r][c] = maxP[r + 1][c];\n\t\t}else if(ans == a2){\n\t\t\tmaxP[r][c] = Math.max(maxP[r][c], maxP[r + 1][c]);\n\t\t}\n\t\t\n\t\t\n\t\tint a3 = recur(r + 1, c + 1, M);\n\t\tif(ans < a3){\n\t\t\tans = a3;\n\t\t\tmaxP[r][c] = maxP[r + 1][c + 1];\n\t\t}else if(ans == a3){\n\t\t\tmaxP[r][c] = Math.max(maxP[r][c], maxP[r + 1][c + 1]);\n\t\t}\n\t\t\n\t\tif(prime[map[r][c]]){\n\t\t\tans++;\n\t\t\tif(maxP[r][c] == 0){\n\t\t\t\tmaxP[r][c] = map[r][c];\n\t\t\t}\n\t\t}\n\t\treturn dp[r][c] = ans;\n\t}\n\t\n\t\n\tprivate static PrintWriter out;\n\tpublic static void main(String[] args){\n\t\tout = new PrintWriter(System.out);\n\t\tnew Main().solve();\n\t\tout.flush();\n\t}\n\t\n\t\n\t\n\tpublic static int nextInt(){\n\t\tint num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif(str.charAt(0) == '-'){\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor(;i < len; i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(!('0' <= c && c <= '9')) throw new RuntimeException();\n\t\t\tnum = num * 10 + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\t\n\tpublic static long nextLong(){\n\t\tlong num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif(str.charAt(0) == '-'){\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor(;i < len; i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(!('0' <= c && c <= '9')) throw new RuntimeException();\n\t\t\tnum = num * 10l + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\tpublic static String next(){\n\t\tint c;\n\t\twhile(!isAlNum(c = read())){}\n\t\tStringBuilder build = new StringBuilder();\n\t\tbuild.append((char)c);\n\t\twhile(isAlNum(c = read())){\n\t\t\tbuild.append((char)c);\n\t\t}\n\t\treturn build.toString();\n\t}\n\t\n\t\n\tprivate static byte[] inputBuffer = new byte[1024];\n\tprivate static int bufferLength = 0;\n\tprivate static int bufferIndex = 0;\n\tprivate static int read(){\n\t\tif(bufferLength < 0) throw new RuntimeException();\n\t\tif(bufferIndex >= bufferLength){\n\t\t\ttry{\n\t\t\t\tbufferLength = System.in.read(inputBuffer);\n\t\t\t\tbufferIndex = 0;\n\t\t\t}catch(IOException e){\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif(bufferLength <= 0) return (bufferLength = -1);\n\t\t}\n\t\treturn inputBuffer[bufferIndex++];\n\t}\n\t\n\tprivate static boolean isAlNum(int c){\n\t\treturn '!' <= c && c <= '~';\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\tnew Main().run();\n\t}\n\n\tboolean isPrime[];\n\n\tfinal int MAX = 1000 * 1000;\n\tint MAX_X = 1102;\n\tint MAX_Y = 1102;\n\tint[][] caves;\n\tint[][] dp;\n\n\tvoid init() {\n\n\t\tisPrime = new boolean[MAX + 1];\n\t\tArrays.fill(isPrime, true);\n\t\tisPrime[0] = isPrime[1] = false;\n\t\tfor (int i = 2; i * i <= MAX; i++) {\n\t\t\tif (isPrime[i]) {\n\t\t\t\tfor (int j = i * 2; j <= MAX; j += i) {\n\t\t\t\t\tisPrime[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcaves = new int[MAX_Y + 1][MAX_X + 1];\n\t\tdp = new int[MAX_Y + 1][MAX_X + 1];\n\t\tfor (int i = 0; i <= MAX_Y; i++) {\n\t\t\tArrays.fill(dp[i], -1);\n\t\t}\n\t\tint x = MAX_X / 2;\n\t\tint y = MAX_Y / 2;\n\t\tint dx[] = new int[] { 1, 0, -1, 0 };\n\t\tint dy[] = new int[] { 0, -1, 0, 1 };\n\t\tint idx = 1;\n\t\tint t = 0;\n\t\tfor (int step = 1; idx <= MAX; step++) {\n\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\tfor (int j = 0; j < step && idx <= MAX; j++) {\n\t\t\t\t\tcaves[y][x] = idx;\n\t\t\t\t\tx = x + dx[t];\n\t\t\t\t\ty = y + dy[t];\n\t\t\t\t\tidx++;\n\t\t\t\t}\n\t\t\t\tt++;\n\t\t\t\tt %= 4;\n\t\t\t}\n\t\t}\n\t}\n\n\tint m = 0;\n\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tinit();\n\t\t\tm = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tint sx, sy;\n\t\t\tsx = sy = 0;\n\t\t\tfor (int i = 0; i <= MAX_Y; i++) {\n\t\t\t\tfor (int j = 0; j <= MAX_X; j++) {\n\t\t\t\t\tif (caves[i][j] == n) {\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = solve(sx, sy);\n\t\t\tint x = sx;\n\t\t\tint y = sy;\n\t\t\tint last = -1;\n\t\t\tint dx[] = new int[] { -1, 0, 1 };\n\t\t\tint dy[] = new int[] { 1, 1, 1 };\n\t\t\twhile (true) {\n\t\t\t\tif (isPrime[caves[y][x]])\n\t\t\t\t\tlast = caves[y][x];\n\t\t\t\tint max = 0;\n\t\t\t\tint max_x = 0;\n\t\t\t\tint max_y = 0;\n\t\t\t\tint max_idx = 0;\n\t\t\t\tboolean end = true;\n\t\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\t\tint nx = x + dx[i];\n\t\t\t\t\tint ny = y + dy[i];\n\t\t\t\t\tif (MAX_X < nx || MAX_Y < ny || caves[ny][nx] > m\n\t\t\t\t\t\t\t|| caves[ny][nx] == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tend = false;\n\t\t\t\t\tif (max < dp[ny][nx]) {\n\t\t\t\t\t\tmax = dp[ny][nx];\n\t\t\t\t\t\tmax_x = nx;\n\t\t\t\t\t\tmax_y = ny;\n\t\t\t\t\t\tmax_idx = caves[ny][nx];\n\t\t\t\t\t} else if (max == dp[ny][nx]) {\n\t\t\t\t\t\tif (max_idx < caves[ny][nx]) {\n\t\t\t\t\t\t\tmax = dp[ny][nx];\n\t\t\t\t\t\t\tmax_x = nx;\n\t\t\t\t\t\t\tmax_y = ny;\n\t\t\t\t\t\t\tmax_idx = caves[ny][nx];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx = max_x;\n\t\t\t\ty = max_y;\n\t\t\t\tif (end)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (last >= 0) {\n\t\t\t\tSystem.out.println(cnt + \" \" + last);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(0 + \" \" + 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tint solve(int x, int y) {\n\t\tif (dp[y][x] >= 0)\n\t\t\treturn dp[y][x];\n\t\tint res = 0;\n\t\tif (MAX_X < x || MAX_Y < y || caves[y][x] > m || caves[y][x] == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (isPrime[caves[y][x]]) {\n\t\t\tres += 1;\n\t\t}\n\t\tint dx[] = { -1, 0, 1 };\n\t\tint dy[] = { 1, 1, 1 };\n\t\tint max = 0;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\n\t\t\tmax = Math.max(max, solve(nx, ny));\n\t\t}\n\t\tres += max;\n\t\treturn dp[y][x] = res;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main {\n\t\n\tstatic boolean[] isPrime;\n\tstatic int[][] data\n\t\n\tstatic void prime() {\n\t\tisPrime = new boolean[1000000];\n\t\tArrays.fill(isPrime, true);\n\t\tisPrime[0] = false;\n\t\tisPrime[1] = false;\n\t\tfor(int i=2; i*i<=1000000; i++) {\n\t\t\tif(isPrime[i]) {\n\t\t\t\tfor(int j=i+i; j<=1000000; j+=i) {\n\t\t\t\t\tisPrime[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void numArray(){\n        data = new int[1000][1000];\n        for(int i = 0; i < 1000; i++){\n            Arrays.fill(data[i], 1<<24);\n        }\n        int now = 1, posx = 500, posy = 500;\n        for(int i = 1; now <= 1000000;i++){\n            System.out.print(\"\");\n            if(i % 2 == 1){\n                //right up\n                for(int j = 0; j < i && now <= 1000000; j++){\n                    data[posy][posx] = now;\n                    posx++;\n                    now++;\n                }\n                for(int j = 0; j < i && now <= MAX; j++){\n                    data[posy][posx] = now;\n                    posy--;\n                    now++;\n                }\n            }\n            else{\n                //left down\n                for(int j = 0; j < i && now <= 100000; j++){\n                    data[posy][posx] = now;\n                    posx--;\n                    now++;\n                }\n                for(int j = 0; j < i && now <= 1000000; j++){\n                    data[posy][posx] = now;\n                    posy++;\n                    now++;\n                }\n            }\n        }\n    }\n\t\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tprime();\n\t\t\tnumArray();\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint m = sc.nextInt();\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tif(m + n == 0) break;\n\t\t\t\t\n\t\t\t\tint x = -1;\n\t\t\t\tint y = -1;\n\t\t\t\tfor(int i= 0; i<1000; i++) {\n\t\t\t\t\tfor(int j=0; j<1000; j++) {\n\t\t\t\t\t\tif(data[i][j] == n) {\n\t\t\t\t\t\t\ty = i;\n\t\t\t\t\t\t\tx = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint[][] dp = new int[1000][1000];\n\t\t\t\tdp[y][x] = 1;\n\t\t\t\tint max = 0;\n\t\t\t\tint num = 0;\n\t\t\t\tfor(int i=y; i<1000; i++) {\n\t\t\t\t\tfor(int j=0; j<1000; j++) {\n\t\t\t\t\t\tif(i == y && data[i][j] != n) continue;\n\t\t\t\t\t\tif(data[i][j] > m) continue;\n\t\t\t\t\t\tif(dp[i][j] == 0) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(isPrime[data[i][j]]) {\n\t\t\t\t\t\t\tdp[i][j]++;\n\t\t\t\t\t\t\tif(max < dp[i][j]) {\n\t\t\t\t\t\t\t\tmax = dp[i][j];\n\t\t\t\t\t\t\t\tnum = data[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(max == dp[i][j]) {\n\t\t\t\t\t\t\t\tif(num < data[i][j]) {\n\t\t\t\t\t\t\t\t\tnum = data[i][j];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tdp[i+1][j] = Math.max(dp[i+1][j], dp[i][j]);\n\t\t\t\t\t\tif(j >= 1) {\n\t\t\t\t\t\t\tdp[i+1][j-1] = Math.max(dp[i+1][j-1], dp[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j + 1 < 1000) {\n\t\t\t\t\t\t\tdp[i+1][j+1] = Math.max(dp[i+1][j+1], dp[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(max + \" \" + num);\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static final int MAX_WH = 1002;\n\n\tstatic int matrix[][] = new int[MAX_WH][MAX_WH];\n\tstatic boolean prime[] = new boolean[1000001];\n\n\tpublic static void main(String args[]) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tisPrime();\n\t\tmap();\n\n\t\twhile (true) {\n\t\t\tString str[] = br.readLine().split(\" \");\n\t\t\tint m = Integer.parseInt(str[0]);\n\t\t\tint n = Integer.parseInt(str[1]);\n\n\t\t\tif (n == 0 && m == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint sx = -1;\n\t\t\tint sy = -1;\n\t\t\tfor (int i = 0; i < MAX_WH; i++) {\n\t\t\t\tfor (int j = 0; j < MAX_WH; j++) {\n\t\t\t\t\tif (matrix[i][j] == n) {\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[][] dp = new int[MAX_WH][MAX_WH];\n\t\t\tdp[sy][sx] = 1;\n\t\t\tint ansSize = 1;\n\t\t\tint ansRoute = 0;\n\t\t\tfor (int i = sy; i < MAX_WH; i++) {\n\t\t\t\tfor (int j = 0; j < MAX_WH; j++) {\n\t\t\t\t\tif (i == sy && matrix[i][j] != n)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (matrix[i][j] > m)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (dp[i][j] == 0)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif (prime[matrix[i][j]]) {\n\t\t\t\t\t\tdp[i][j]++;\n\t\t\t\t\t\tif (ansSize < dp[i][j]) {\n\t\t\t\t\t\t\tansSize = dp[i][j];\n\t\t\t\t\t\t\tansRoute = matrix[i][j];\n\t\t\t\t\t\t} else if (ansSize == dp[i][j]) {\n\t\t\t\t\t\t\tif (ansRoute < matrix[i][j]) {\n\t\t\t\t\t\t\t\tansRoute = matrix[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdp[i + 1][j] = Math.max(dp[i + 1][j], dp[i][j]);\n\t\t\t\t\tif (j >= 1) {\n\t\t\t\t\t\tdp[i + 1][j - 1] = Math.max(dp[i + 1][j - 1], dp[i][j]);\n\t\t\t\t\t}\n\t\t\t\t\tif (j + 1 < 1002) {\n\t\t\t\t\t\tdp[i + 1][j + 1] = Math.max(dp[i + 1][j + 1], dp[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ansSize - 1 + \" \" + ansRoute);\n\t\t}\n\t}\n\n\tstatic void map() {\n\t\tfor (int i = 0; i < MAX_WH; i++) {\n\t\t\tArrays.fill(matrix[i], Integer.MAX_VALUE);\n\t\t}\n\t\tint now = 1;\n\t\tint x = MAX_WH / 2 - 1;\n\t\tint y = MAX_WH / 2 - 1;\n\t\tfor (int i = 1; now <= 1000000; i++) {\n\t\t\tif (i % 2 == 1) {\n\t\t\t\tfor (int j = 0; j < i && now <= 1000000; j++) {\n\t\t\t\t\tmatrix[y][x] = now;\n\t\t\t\t\tx++;\n\t\t\t\t\tnow++;\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < i && now <= 1000000; j++) {\n\t\t\t\t\tmatrix[y][x] = now;\n\t\t\t\t\ty--;\n\t\t\t\t\tnow++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int j = 0; j < i && now <= 1000000; j++) {\n\t\t\t\t\tmatrix[y][x] = now;\n\t\t\t\t\tx--;\n\t\t\t\t\tnow++;\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < i && now <= 1000000; j++) {\n\t\t\t\t\tmatrix[y][x] = now;\n\t\t\t\t\ty++;\n\t\t\t\t\tnow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void isPrime() {\n\t\tArrays.fill(prime, true);\n\t\tprime[0] = false;\n\t\tprime[1] = false;\n\t\tfor (int i = 2; i * i <= 1000000; i++) {\n\t\t\tfor (int j = i + i; j <= 1000000; j += i) {\n\t\t\t\tprime[j] = false;\n\t\t\t}\n\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint m, start;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tm=sc.nextInt();\n\t\t\tstart=sc.nextInt();\n\t\t\tif((m|start)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tint[] isPrime;\n\n\tvoid solve(){\n\t\tint M=(int)1e6+100;\n\t\tif(isPrime==null){\n\t\t\tisPrime=new int[M];\n\t\t\tfill(isPrime, 1);\n\t\t\tisPrime[0]=isPrime[1]=0;\n\t\t\tfor(int j=0; j<M; j++){\n\t\t\t\tif(isPrime[j]==0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i=j*2; i<M; i+=j){\n\t\t\t\t\tisPrime[i]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint n=2000;\n\t\tint[][] dp=new int[n][n];\n\t\tint[][] index=new int[n][n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfill(dp[i], -1);\n\t\t}\n\t\tint[] _=spiralN2XY(start);\n\t\tint x0=_[0]-n/2, y0=_[1];\n\t\tdp[0][n/2]=isPrime[start];\n\t\tindex[0][n/2]=start*isPrime[start];\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(dp[j][i]<0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int k=-1; k<=1; k++){\n\t\t\t\t\tif(j+1>=n||i+k<0||i+k>=n){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint val=spiralXY2N(x0+i+k, y0+j+1);\n\t\t\t\t\t// debug(val, x0+i+k, y0+j+1);\n\t\t\t\t\tif(val>m){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[j][i]+isPrime[val]>dp[j+1][i+k]){\n\t\t\t\t\t\tdp[j+1][i+k]=dp[j][i]+isPrime[val];\n\t\t\t\t\t\t// index[j+1][i+k]=val;\n\t\t\t\t\t\tindex[j+1][i+k]=isPrime[val]==1?val:index[j][i];\n\t\t\t\t\t\t// index[j+1][i+k]=max(index[j][i], val*isPrime[val]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// left--;\n\t\t\t// right++;\n\t\t\t// debug(dp[j]);\n\t\t}\n\t\tfor(int j=0; j<n; j++){\n\t\t\t// debug(index[j]);\n\t\t}\n\t\tint maxVal=0, maxIndex=0;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(dp[j][i]>maxVal||(dp[j][i]==maxVal&&index[j][i]>maxIndex)){\n\t\t\t\t\tmaxVal=dp[j][i];\n\t\t\t\t\tmaxIndex=index[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln(maxVal+\" \"+maxIndex);\n\t}\n\n\tint[] spiralN2XY(int n){\n\t\tint m=(int)sqrt(n-1)+1; // n<=m^2 NOTE: in the case of long...?\n\t\tint x=m/2-min(m*m-n, m-1), y=m/2-max(m*m-m+1-n, 0);\n\t\tif(m%2==0){\n\t\t\tx=-x+1;\n\t\t\ty=-y;\n\t\t}\n\t\treturn new int[]{x, y};\n\t}\n\n\tint spiralXY2N(int x, int y){\n\t\tint d=max(abs(x), abs(y));\n\t\tif(y>=x)\n\t\t\treturn (2*d+1)*(2*d+1)-abs(d-x)-abs(d-y);\n\t\telse\n\t\t\treturn (2*d)*(2*d)-abs(-d+1-x)-abs(-d-y);\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tint[] dirX = {1, 0, -1, 0};\n\tint[] dirY = {0, -1, 0, 1};\n\t\n\tboolean[] primeList;\n\t\n\tboolean isPrime(int n) {\n\t\tif (n <= 0) return false;\n\t\treturn !primeList[n];\n\t}\n\t\n\tboolean[] getPrimeList(int n) {\n\t\tboolean[] res = new boolean[n];\n\t\t\n\t\tres[1] = true;\n\t\tfor (int i = 2; i < res.length; i++) {\n\t\t\tif (res[i]) continue;\n\t\t\tfor (int j = 2 * i; j < res.length; j += i) {\n\t\t\t\tres[j] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint m = in.nextInt(), n = in.nextInt();\n\t\t\tif ((n|m) == 0) break;\n\t\t\tint resX = -1, resY = -1;\n\n\t\t\tprimeList = getPrimeList(m+1);\n\t\t\t\n\t\t\tint range = 0;\n\t\t\tfor (range = 1; range < 100000; range++) {\n\t\t\t\tif (range*range >= m) break;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] cave = new int[range][range];\n\t\t\t\n\t\t\tint curX, curY;\n\t\t\tif (range % 2 == 0) {\n\t\t\t\tcurX = range / 2 - 1;\n\t\t\t\tcurY = range / 2;\n\t\t\t} else {\n\t\t\t\tcurX = range / 2;\n\t\t\t\tcurY = range / 2;\n\t\t\t}\n\t\t\t\n\t\t\tint nowDir = 0;\n\t\t\tint upper = 1, changeFlag = 0;\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = 1; i <= m; i++) {\n\t\t\t\tcave[curY][curX] = i;\n\t\t\t\tif (i == n) {\n\t\t\t\t\tresX = curX;\n\t\t\t\t\tresY = curY;\n\t\t\t\t}\n\t\t\t\tcurY += dirY[nowDir];\n\t\t\t\tcurX += dirX[nowDir];\n\t\t\t\tcnt++;\n\t\t\t\tif (cnt == upper) {\n\t\t\t\t\tnowDir = (nowDir + 1) % 4;\n\t\t\t\t\tcnt = 0;\n\t\t\t\t\tif (changeFlag == 1) {\n\t\t\t\t\t\tupper++;\n\t\t\t\t\t}\n\t\t\t\t\tchangeFlag ^= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][] dp = new int[range][range];\n\t\t\tint[][] nums = new int[range][range];\n\t\t\t\n\t\t\tfor (int i = 0; i < dp[range-1].length; i++) {\n\t\t\t\tif (isPrime(cave[range-1][i])) {\n\t\t\t\t\tdp[range-1][i] = 1;\n\t\t\t\t\tnums[range-1][i] = cave[range-1][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = range - 2; i >= 0; i--) {\n\t\t\t\tfor (int j = 0; j < range; j++) {\n\t\t\t\t\tdp[i][j] = dp[i+1][j];\n\t\t\t\t\tnums[i][j] = nums[i+1][j];\n\t\t\t\t\t\n\t\t\t\t\tif (j < range-1 && (dp[i][j] < dp[i+1][j+1] || (dp[i][j] == dp[i+1][j+1] && nums[i][j] < nums[i+1][j+1]))) {\t\t\t\t\t\t\n\t\t\t\t\t\tdp[i][j] = dp[i+1][j+1];\n\t\t\t\t\t\tnums[i][j] = nums[i+1][j+1];\n\t\t\t\t\t}\n\t\t\t\t\tif (j > 0 && (dp[i][j] < dp[i+1][j-1] || (dp[i][j] == dp[i+1][j-1] && nums[i][j] < nums[i+1][j-1]))) {\t\t\t\t\t\t\n\t\t\t\t\t\tdp[i][j] = dp[i+1][j-1];\n\t\t\t\t\t\tnums[i][j] = nums[i+1][j-1];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (isPrime(cave[i][j])) {\n\t\t\t\t\t\tdp[i][j] += 1;\n\t\t\t\t\t\tif (dp[i][j] == 1)\n\t\t\t\t\t\t\tnums[i][j] = cave[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//display(nums);\n\t\t\t\n\t\t\tout.println(dp[resY][resX] + \" \" + nums[resY][resX]);\n\t\t\t\n\t\t\t\n\t\t}\n\t\tout.close();\n\t}\n\n\tvoid display(int[][] board) {\n\t\tfor (int i = 0; i < board.length; i++) {\n\t\t\tfor (int j = 0; j < board[i].length; j++) {\n\t\t\t\tout.printf(\"%4d \", board[i][j]);\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t\tout.println();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\tboolean[] prime;\n\tint[][] map;\n\tint[][][] dp;\n\tHashMap<Integer, P> p2ind;\n\tint MAX = 1050, M = 1000000;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tpre();\n\t\t\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt(), s = sc.nextInt();\n\t\t\tif((n|s) == 0) break;\n\t\t\t\n\t\t\tfor(int[][] a: dp) for(int[] b: a) fill(b, -1);\n\t\t\t\n\t\t\tP p = p2ind.get(s);\n\t\t\tdp[p.y][p.x][0] = prime[s]? 0: 1; dp[p.y][p.x][1] = prime[s]? 0:s;\n\t\t\t\n\t\t\tint ansn = 0, ansp = 0;\n\t\t\tfor(int y=1;y<MAX;y++) for(int x=1;x<MAX-1;x++) {\n\t\t\t\tif(map[y][x] > n) continue;\n\t\t\t\tfor(int dx=-1;dx<=1;dx++) if(map[y-1][x+dx] <= n && dp[y-1][x+dx][0] >= 0) {\n\t\t\t\t\tif(!prime[map[y][x]]) {\n\t\t\t\t\t\tdp[y][x][0] = max(dp[y][x][0], dp[y-1][x+dx][0] + 1);\n\t\t\t\t\t\tdp[y][x][1] = map[y][x];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(dp[y][x][0] < dp[y-1][x+dx][0]) {\n\t\t\t\t\t\t\tdp[y][x][0] = dp[y-1][x+dx][0];\n\t\t\t\t\t\t\tdp[y][x][1] = dp[y-1][x+dx][1];\n\t\t\t\t\t\t} else if(dp[y][x][0] == dp[y-1][x+dx][0] && dp[y][x][1] < dp[y-1][x+dx][1]) {\n\t\t\t\t\t\t\tdp[y][x][0] = dp[y-1][x+dx][0];\n\t\t\t\t\t\t\tdp[y][x][1] = dp[y-1][x+dx][1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ansn < dp[y][x][0]) {\n\t\t\t\t\tansn = dp[y][x][0];\n\t\t\t\t\tansp = dp[y][x][1];\n\t\t\t\t} else if(ansn == dp[y][x][0]) {\n\t\t\t\t\tansp = max(ansp, dp[y][x][1]);\n\t\t\t\t}\n//\t\t\t\tdebug(x, y, map[y][x], dp[y][x][0], dp[y][x][1]);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(ansn + \" \" + ansp);\n\t\t}\n\n\t}\n\t\n\tint[] dx = {1,0,-1,0}, dy = {0,-1,0,1};\n\tvoid pre() {\n\t\tp2ind = new HashMap<Integer, P>();\n\t\tmap = new int[MAX][MAX]; dp = new int[MAX][MAX][2];\n\t\tfor(int[] a: map) fill(a, INF);\n\t\t\n\t\tprime = new boolean[M+1];\n\t\tprime[0] = prime[1] = true;\n\t\tfor(int i=2;i<=M;i++) if(!prime[i]) \n\t\t\tfor(int j=i*2;j<=M;j+=i) prime[j] = true;\n\t\t\n\t\tint ind = 1, len=0, x = MAX/2, y = MAX/2, d=0;\n\t\twhile(true) {\n\t\t\tlen++;\n\t\t\tfor(int c=0;c<2;c++) {\n\t\t\t\tfor(int i=0;i<len;i++) {\n\t\t\t\t\tmap[y][x] = ind; p2ind.put(ind, new P(x, y));\n\t\t\t\t\tind++; x += dx[d]; y += dy[d];\n\t\t\t\t}\n\t\t\t\td = (d+1)&3;\n\t\t\t}\n\t\t\tif(ind > M) break;\n\t\t}\n\t\t\n/*\t\tfor(int sy=MAX/2-10;sy<=MAX/2+10;sy++) for(int sx=MAX/2-10;sx<=MAX/2+10;sx++) {\n\t\t\tSystem.out.printf(\"%4d%s\", map[sy][sx], sx==MAX/2+10? \"\\n\": \"\");\n\t\t}*/\n\t}\n\t\n\tclass P {\n\t\tint x, y;\n\t\tP(int x, int y) {\n\t\t\tthis.x = x; this.y = y;\n\t\t}\n\t\t\n\t\tpublic int hashCode() {\n\t\t\treturn x * 100000 + y;\n\t\t}\n\t\t\n\t\tpublic boolean compareTo(Object o) {\n\t\t\tif(o instanceof P) {\n\t\t\t\tP p = (P)o;\n\t\t\t\treturn x == p.x && y == p.y;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.BitSet;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint m = in.nextInt();\n\t\t\tint n = in.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tPoint[] table = new Point[m+1];\n\t\t\tint[][] map = new int[1001][1001];\n\t\t\tint x = 500;\n\t\t\tint y = 500;\n\t\t\tint[] dx = {1, 0, -1, 0};\n\t\t\tint[] dy = {0, -1, 0, 1};\n\t\t\tint dir = 3;\n\t\t\tBitSet p = prime(m);\n\t\t\tfor(int i=1; i<=m; i++){\n\t\t\t\tmap[y][x] = i;\n\t\t\t\ttable[i] = new Point(x, y);\n\t\t\t\tif(map[y+dy[(dir+1)%4]][x+dx[(dir+1)%4]] == 0){\n\t\t\t\t\tdir = (dir+1)%4;\n\t\t\t\t}\n\t\t\t\tx += dx[dir];\n\t\t\t\ty += dy[dir];\n\t\t\t}\n\t\t\tint[][] dp = new int[1001][1001];\n\t\t\tfor(int i=0; i<=1000; i++){\n\t\t\t\tfor(int j=0; j<=1000; j++){\n\t\t\t\t\tdp[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[table[n].y][table[n].x] = p.get(map[table[n].y][table[n].x])?1:0;\n\t\t\tfor(int i=table[n].y; i<1000; i++){\n\t\t\t\tfor(int j=0; j<=1000; j++){\n\t\t\t\t\tint max = -1;\n\t\t\t\t\tfor(int k=-1; k<=1; k++){\n\t\t\t\t\t\tif(j+k < 0 || j+k > 1000 || map[i][j+k] == -1) continue;\n\t\t\t\t\t\tmax = Math.max(max, dp[i][j+k]);\n\t\t\t\t\t}\n\t\t\t\t\tif(max == -1) continue;\n\t\t\t\t\tdp[i+1][j] = max + (p.get(map[i+1][j])?1:0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tint resId = 0;\n\t\t\tfor(int i=0; i<=1000; i++){\n\t\t\t\tfor(int j=0; j<=1000; j++){\n\t\t\t\t\tif((dp[i][j] > res || dp[i][j] == res && resId < map[i][j]) && p.get(map[i][j])){\n\t\t\t\t\t\tres = dp[i][j];\n\t\t\t\t\t\tresId = map[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res+\" \"+resId);\n\t\t}\n\t}\n\t\n\tpublic static String dump(int[][] map, int s, int t){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=s; i<=t; i++){\n\t\t\tfor(int j=s; j<=t; j++){\n\t\t\t\tsb.append(map[i][j]+\"\\t\");\n\t\t\t}\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic static BitSet prime(int max){\n\t\t// 10^7: 93ms\n\t\t// 4*10^7: 687ms\n\t\t// 5*10^7: 922ms\n\t\t// 10^8: 2016ms\n\t\tBitSet isPrime = new BitSet(max+1);\n\t\tisPrime.set(2, max+1);\n\t\tfor(long i=2; i*i<=max; i=isPrime.nextSetBit((int)i+1)){\n//\t\t\tif(i==-1) break; // iが小さいとき必要?\n\t\t\tfor(int j=(int)(i<<1); j<=max; j+=i){\n\t\t\t\tisPrime.clear(j);\n\t\t\t}\n\t\t}\n\t\treturn isPrime;\n\t}\n}\n\nclass Point{\n\tint x, y;\n\tpublic Point(int x, int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n \npublic class Main{\n\tprivate boolean[] prime;\n\t\n\tpublic void setPrime(int m){\n\t\tprime = new boolean[m + 1];\n\t\tArrays.fill(prime, true);\n\t\tprime[0] = false;\n\t\tprime[1] = false;\n\t\tfor(int i = 2; i * i <= m; i++){\n\t\t\tif(prime[i]){\n\t\t\t\tfor(int j = i * 2; j <= m; j += i){\n\t\t\t\t\tprime[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint[][] map;\n\tint[][] dp;\n\tint[][] maxP;\n\t\n\tpublic void setMap(int m){\n\t\tmap = new int[m][m];\n\t\tint[] DC = {1, 0, -1,0};\n\t\tint[] DR = {0,-1,  0,1};\n\t\t\n\t\tint pr = m / 2;\n\t\tint pc = (m - 1) / 2;\n\t\tint muki = 0;\n\t\tint dc = 1;\n\t\tint dr = 0;\n\t\tmap[pr][pc] = 1;\n\t\tfor(int i = 2; i <= m * m; i++){\n\t\t\tpr += dr;\n\t\t\tpc += dc;\n\t\t\tmap[pr][pc] = i;\n\t\t\tint mm = (muki + 1) % 4;\n\t\t\tint nr = DR[mm];\n\t\t\tint nc = DC[mm];\n\t\t\tif(map[pr + nr][pc + nc] == 0){\n\t\t\t\tdr = nr;\n\t\t\t\tdc = nc;\n\t\t\t\tmuki = mm;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void solve(){\n\t\tsetPrime(1000000);\n\t\tsetMap(1005);\n\t\tdp = new int[1005][1005];\n\t\tmaxP = new int[1005][1005];\n\t\twhile(true){\n\t\t\tint M = nextInt();\n\t\t\tint N = nextInt();\n\t\t\tif(M == 0) break;\n\t\t\tfor(int i = 0; i < dp.length; i++){\n\t\t\t\tArrays.fill(dp[i], -1);\n\t\t\t\tArrays.fill(maxP[i], 0);\n\t\t\t}\n\t\t\tint pr = 0;\n\t\t\tint pc = 0;\n\t\t\tfor(int i = 0; i < map.length; i++){\n\t\t\t\tfor(int j = 0; j < map[i].length; j++){\n\t\t\t\t\tif(map[i][j] == N){\n\t\t\t\t\t\tpr = i;\n\t\t\t\t\t\tpc = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trecur(pr, pc, M);\n\t\t\tout.println(dp[pr][pc] + \" \" + maxP[pr][pc]);\n\t\t}\n\t}\n\t\n\tpublic int recur(int r, int c, int M){\n\t\tif(map[r][c] > M){\n\t\t\treturn 0;\n\t\t}\n\t\tif(dp[r][c] >= 0){\n\t\t\treturn dp[r][c];\n\t\t}\n\t\tint ans = recur(r + 1, c - 1, M);\n\t\tmaxP[r][c] = maxP[r + 1][c - 1];\n\t\tint a2 = recur(r + 1, c, M);\n\t\tif(ans < a2){\n\t\t\tans = a2;\n\t\t\tmaxP[r][c] = maxP[r + 1][c];\n\t\t}else if(ans == a2){\n\t\t\tmaxP[r][c] = Math.max(maxP[r][c], maxP[r + 1][c]);\n\t\t}\n\t\t\n\t\t\n\t\tint a3 = recur(r + 1, c + 1, M);\n\t\tif(ans < a3){\n\t\t\tans = a3;\n\t\t\tmaxP[r][c] = maxP[r + 1][c + 1];\n\t\t}else if(ans == a3){\n\t\t\tmaxP[r][c] = Math.max(maxP[r][c], maxP[r + 1][c + 1]);\n\t\t}\n\t\t\n\t\tif(prime[map[r][c]]){\n\t\t\tans++;\n\t\t\tif(maxP[r][c] == 0){\n\t\t\t\tmaxP[r][c] = map[r][c];\n\t\t\t}\n\t\t}\n\t\treturn dp[r][c] = ans;\n\t}\n\t\n\t\n\tprivate static PrintWriter out;\n\tpublic static void main(String[] args){\n\t\tout = new PrintWriter(System.out);\n\t\tnew Main().solve();\n\t\tout.flush();\n\t}\n\t\n\t\n\t\n\tpublic static int nextInt(){\n\t\tint num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif(str.charAt(0) == '-'){\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor(;i < len; i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(!('0' <= c && c <= '9')) throw new RuntimeException();\n\t\t\tnum = num * 10 + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\t\n\tpublic static long nextLong(){\n\t\tlong num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif(str.charAt(0) == '-'){\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor(;i < len; i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(!('0' <= c && c <= '9')) throw new RuntimeException();\n\t\t\tnum = num * 10l + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\tpublic static String next(){\n\t\tint c;\n\t\twhile(!isAlNum(c = read())){}\n\t\tStringBuilder build = new StringBuilder();\n\t\tbuild.append((char)c);\n\t\twhile(isAlNum(c = read())){\n\t\t\tbuild.append((char)c);\n\t\t}\n\t\treturn build.toString();\n\t}\n\t\n\t\n\tprivate static byte[] inputBuffer = new byte[1024];\n\tprivate static int bufferLength = 0;\n\tprivate static int bufferIndex = 0;\n\tprivate static int read(){\n\t\tif(bufferLength < 0) throw new RuntimeException();\n\t\tif(bufferIndex >= bufferLength){\n\t\t\ttry{\n\t\t\t\tbufferLength = System.in.read(inputBuffer);\n\t\t\t\tbufferIndex = 0;\n\t\t\t}catch(IOException e){\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif(bufferLength <= 0) return (bufferLength = -1);\n\t\t}\n\t\treturn inputBuffer[bufferIndex++];\n\t}\n\t\n\tprivate static boolean isAlNum(int c){\n\t\treturn '!' <= c && c <= '~';\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static Scanner sc;\n\n    final static int INF = Integer.MAX_VALUE;\n\n    public static void main(String[] args) {\n        sc = new Scanner(System.in);\n        while (true) {\n            int m = sn();\n            int n = sn();\n            if ((m | n) == 0) {\n                break;\n            }\n            int l = (int) Math.ceil(Math.sqrt(m));\n            int[][] map = createMap(m, l);\n            int[][] pmap = new int[l][l];\n            int[][] rmap = new int[l][l];\n            boolean st = false;\n            for (int i = 0; i < l; i++) {\n                for (int j = 0; j < l; j++) {\n                    pmap[i][j] = -1;\n                    rmap[i][j] = -1;\n                }\n            }\n            for (int i = 0; i < l; i++) {\n                for (int j = 0; j < l; j++) {\n                    if (map[i][j] == n && !st) {\n                        pmap[i][j] = 0;\n                        rmap[i][j] = 0;\n                        if (isPrime(n)) {\n                            pmap[i][j] = 1;\n                            rmap[i][j] = map[i][j];\n                        }\n                        st = true;\n                    }\n                    if (i < l - 1 && pmap[i][j] != -1) {\n                        for (int k = Math.max(0, j - 1); k <= Math.min(l - 1, j + 1); k++) {\n                            if (pmap[i + 1][k] == -1) {\n                                pmap[i + 1][k] = pmap[i][j];\n                                rmap[i + 1][k] = rmap[i][j];\n                                if (isPrime(map[i + 1][k])) {\n                                    pmap[i + 1][k] ++;\n                                    rmap[i + 1][k] = map[i + 1][k];\n                                }\n                            } else {\n                                int pp = pmap[i + 1][k];\n                                int np = pmap[i][j] + (isPrime(map[i + 1][k]) ? 1 : 0);\n                                if (pp < np) {\n                                    pmap[i + 1][k] = np;\n                                    rmap[i + 1][k] = rmap[i][j];\n                                    if (isPrime(map[i + 1][k])) {\n                                        rmap[i + 1][k] = map[i + 1][k];\n                                    }\n                                } else if (pp == np && !isPrime(map[i + 1][k])) {\n                                    rmap[i + 1][k] = Math.max(rmap[i + 1][k], rmap[i][j]);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            // dumpArray(map);\n            // dumpArrayPrime(map);\n            // dumpArray(pmap);\n            // dumpArray(rmap);\n            int max = 0;\n            int maxi = 0;\n            for (int i = 0; i < l; i++) {\n                if (pmap[l - 1][i] == -1 || pmap[l - 1][i] < max) {\n                    continue;\n                }\n                if (max < pmap[l - 1][i]) {\n                    maxi = rmap[l - 1][i];\n                } else if (max == pmap[l - 1][i]) {\n                    maxi = Math.max(maxi, rmap[l - 1][i]);\n                }\n                max = pmap[l - 1][i];\n            }\n            System.out.println(max + \" \" + maxi);\n        }\n    }\n\n    public static int[][] createMap(int n, int l) {\n        int[][] map = new int[l][l];\n        int[][] vec = {{1, 0}, {0, -1}, {-1, 0}, {0, 1}};\n        int k = 0;\n        int i = 1;\n        int gen = 2;\n        int[] pos = new int[2];\n        if (l % 2 == 0) {\n            pos[0] = l / 2 - 1;\n            pos[1] = l / 2;\n        } else {\n            pos[0] = (l - 1) / 2;\n            pos[1] = (l - 1) / 2;\n        }\n        while (true) {\n            map[pos[1]][pos[0]] = i;\n            pos[0] += vec[(gen + 2) % 4][0];\n            pos[1] += vec[(gen + 2) % 4][1];\n            if (i == n) {\n                break;\n            }\n            i++;\n            k++;\n            if (k == Math.floor(gen / 2)) {\n                k = 0;\n                gen++;\n            }\n        }\n        return map;\n    }\n\n    public static void dumpArray(int[][] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = 0; j < arr[i].length; j++) {\n                System.out.print(String.format(\"%3d, \", arr[i][j]));\n            }\n            System.out.println();\n        }\n        System.out.println(\"---\");\n    }\n\n    public static void dumpArrayPrime(int[][] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = 0; j < arr[i].length; j++) {\n                System.out.print((isPrime(arr[i][j]) ? \"pr\" : \" _\") + \", \");\n            }\n            System.out.println();\n        }\n        System.out.println(\"---\");\n    }\n\n    public static boolean isPrime(int n) {\n        if (n <= 1) {\n            return false;\n        }\n        if (n % 2 == 0) {\n            return n == 2;\n        }\n        for (int i = 3, l = (int) Math.floor(Math.sqrt(n)); i <= l; i += 2) {\n            if (n % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int sn() {\n        return sc.nextInt();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tfinal Scanner sc = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tint N,M;\n\tfinal int\tMAX1=1000001,\n\t\t\t\tMAX2=1001,\n\t\t\t\tINF=1<<29;\n\tboolean[][] isPrime;\n\tint[][] number,dp1,dp2;\n\tint[] xp,yp;\n\tvoid init(){\n\t\tisPrime = new boolean[MAX2][MAX2];\n\t\tnumber = new int[MAX2][MAX2];\n\t\tfor(int i=0; i<MAX2; ++i)for(int j=0; j<MAX2; ++j)\tnumber[i][j]=INF;\n\t\txp=new int[MAX1];\n\t\typ=new int[MAX1];\n\t\tint x=500,y=500;\n\t\tint lim=1,cnt=0,two=0,v=0;\n\t\tfinal int[] vx={1,0,-1,0},vy={0,-1,0,1};\n\t\tfor(int i=1; i<MAX1; ++i){\n//\t\t\tSystem.out.println(i+\"=\"+x+\",\"+y);\n\t\t\txp[i]=x;\typ[i]=y;\n\t\t\tnumber[x][y]=i;\n\t\t\tx+=vx[v];\ty+=vy[v];\n\t\t\t++cnt;\n\t\t\tif(cnt>=lim){\n\t\t\t\tcnt=0;\n\t\t\t\tv=(v+1)%4;\n\t\t\t\t++two;\n\t\t\t\tif(two>=2){\n\t\t\t\t\ttwo=0;\n\t\t\t\t\t++lim;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp1=new int[MAX2][MAX2];\n\t\tdp2=new int[MAX2][MAX2];\n\t\t\n\t\tfor(int i=0; i<MAX2; ++i)for(int j=0; j<MAX2; ++j)\tisPrime[i][j]=true;\n\t\tisPrime[xp[0]][yp[0]]=isPrime[xp[1]][yp[1]]=false;\n\t\tfor(int i=2; i*i<MAX1; ++i)if(isPrime[xp[i]][yp[i]])for(int j=i+i; j<MAX1; j+=i)\tisPrime[xp[j]][yp[j]]=false;\n\t\t\n\t\twhile(true){\n\t\t\tM=sc.nextInt();\n\t\t\tN=sc.nextInt();\n\t\t\tif((N|M)==0)\tbreak;\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tint sx=xp[N],sy=yp[N];\n\t\tfor(int x=0; x<MAX2; ++x)for(int y=sy; y<MAX2; ++y){\n\t\t\tdp1[x][y]=-INF;\n\t\t\tdp2[x][y]=0;\n\t\t}\n\t\t\n\t\tdp1[sx][sy]=(isPrime[sx][sy]? 1: 0);\n\t\tdp2[sx][sy]=(isPrime[sx][sy]? number[sx][sy]: 0);\n\t\tint ans1=(isPrime[sx][sy]? 1: 0),ans2=(isPrime[sx][sy]? number[sx][sy]: 0);\n\t\t\n\t\tfor(int y=sy; y<MAX2-1; ++y)for(int x=0; x<MAX2; ++x)if(number[x][y]<=M && dp1[x][y]>(-INF)){\n//\t\t\tSystem.out.println(x+\",\"+y+\" \"+number[x][y]+\" \"+isPrime[x][y]+\" \"+dp1[x][y]);\n\t\t\tfor(int i=-1; i<=1; ++i){\n\t\t\t\tint nx=x+i,ny=y+1;\n\t\t\t\tif(!(0<=nx&&nx<MAX2 && 0<=ny&&ny<MAX2))\tcontinue;\n\t\t\t\tif(number[nx][ny]>M)\tcontinue;\n\t\t\t\tif(dp1[nx][ny] < dp1[x][y]+(isPrime[nx][ny]? 1: 0)){\n\t\t\t\t\tdp1[nx][ny]=dp1[x][y]+(isPrime[nx][ny]? 1: 0);\n\t\t\t\t\tdp2[nx][ny]=(isPrime[nx][ny]? number[nx][ny]: dp2[x][y]);\n\t\t\t\t\t// TODO\n//\t\t\t\t\tSystem.out.println(nx+\",\"+ny+\" \"+number[nx][ny]+\" \"+isPrime[nx][ny]+\" \"+dp1[nx][ny]);\n\t\t\t\t}else if(dp1[nx][ny] == dp1[x][y]+(isPrime[nx][ny]? 1: 0)){\n\t\t\t\t\tif(dp2[nx][ny] < (isPrime[nx][ny]? number[nx][ny]: dp2[x][y])){\n\t\t\t\t\t\tdp1[nx][ny]=dp1[x][y]+(isPrime[nx][ny]? 1: 0);\n\t\t\t\t\t\tdp2[nx][ny]=(isPrime[nx][ny]? number[nx][ny]: dp2[x][y]);\n\t\t\t\t\t\t// TODO\n//\t\t\t\t\t\tSystem.out.println(nx+\",\"+ny+\" \"+number[nx][ny]+\" \"+isPrime[nx][ny]+\" \"+dp1[nx][ny]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ans1 < dp1[nx][ny]){\n\t\t\t\t\tans1=dp1[nx][ny];\n\t\t\t\t\tans2=dp2[nx][ny];\n\t\t\t\t}else if(ans1==dp1[nx][ny] && ans2<dp2[nx][ny]){\n\t\t\t\t\tans2=dp2[nx][ny];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans1+\" \"+ans2);\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\npublic class Main{\n\tboolean [] isPrime;\n\tint MAX = 1000000,size = 1000 + 2, offset = size / 2 - 1, INF = 1 << 24;\n\tint [][] data;\n\t\n\tprivate void prime(){\n\t\tisPrime = new boolean[MAX + 1];\n\t\tArrays.fill(isPrime, true);\n\t\tisPrime[0] = false;\n\t\tisPrime[1] = false;\n\t\tfor(int i = 2; i * 1 <= MAX; i++){\n\t\t\tif(isPrime[i]){\n\t\t\t\tfor(int j = i + i; j <= MAX; j+=i){\n\t\t\t\t\tisPrime[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void numArray(){\n\t\tdata = new int[size][size];\n\t\tfor(int i = 0; i < size; i++){\n\t\t\tArrays.fill(data[i], INF);\n\t\t}\n\t\tint now = 1, posx = offset, posy = offset;\n\t\tfor(int i = 1;now <= MAX;i++){\n\t\t\tSystem.out.print(\"\");\n\t\t\tif(i % 2 == 1){\n\t\t\t\t//right up\n\t\t\t\tfor(int j = 0; j < i && now <= MAX; j++){\n\t\t\t\t\tdata[posy][posx] = now;\n\t\t\t\t\tposx++;\n\t\t\t\t\tnow++;\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < i && now <= MAX; j++){\n\t\t\t\t\tdata[posy][posx] = now;\n\t\t\t\t\tposy--;\n\t\t\t\t\tnow++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t//left down\n\t\t\t\tfor(int j = 0; j < i && now <= MAX; j++){\n\t\t\t\t\tdata[posy][posx] = now;\n\t\t\t\t\tposx--;\n\t\t\t\t\tnow++;\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < i && now <= MAX; j++){\n\t\t\t\t\tdata[posy][posx] = now;\n\t\t\t\t\tposy++;\n\t\t\t\t\tnow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tprime();\n\t\tnumArray();\n\t\twhile(sc.hasNext()){\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif((m|n) == 0) break;\n\t\t\t\n\t\t\tint x = -1, y = -1;\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tfor(int j = 0; j < size; j++){\n\t\t\t\t\tif(data[i][j] == n){\n\t\t\t\t\t\ty = i;\n\t\t\t\t\t\tx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint [][] dp = new int[size][size];\n\t\t\tdp[y][x] = 1;\n\t\t\tint max = 1, ind = 0;\n\t\t\tfor(int i = y; i < size; i++){\n\t\t\t\tfor(int j = 0; j < size; j++){\n\t\t\t\t\tif(i == y && data[i][j] != n) continue;\n\t\t\t\t\tif(data[i][j] > m) continue;\n\t\t\t\t\tif(dp[i][j] == 0) continue;\n\t\t\t\t\t\n\t\t\t\t\tif(isPrime[ data[i][j] ]){\n\t\t\t\t\t\tdp[i][j]++;\n\t\t\t\t\t\tif(max < dp[i][j]){\n\t\t\t\t\t\t\tmax = dp[i][j];\n\t\t\t\t\t\t\tind = data[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(max == dp[i][j]){\n\t\t\t\t\t\t\tif(ind < data[i][j]){\n\t\t\t\t\t\t\t\tind = data[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdp[i + 1][j] = Math.max(dp[i + 1][j], dp[i][j]);\n\t\t\t\t\tif(j - 1 >= 0){\n\t\t\t\t\t\tdp[i + 1][j - 1] = Math.max(dp[i + 1][j-1], dp[i][j]);\n\t\t\t\t\t}\n\t\t\t\t\tif(j + 1 < size){\n\t\t\t\t\t\tdp[i + 1][j + 1] = Math.max(dp[i + 1][j + 1], dp[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println((max-1) + \" \" + ind);\n\t\t}\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n// Prime Caves\n// 2013/08/14\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint m, start;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tm=sc.nextInt();\n\t\t\tstart=sc.nextInt();\n\t\t\tif((m|start)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tint[] isPrime;\n\n\tvoid solve(){\n\t\tint M=(int)1e6+100;\n\t\tif(isPrime==null){\n\t\t\tisPrime=new int[M];\n\t\t\tfill(isPrime, 1);\n\t\t\tisPrime[0]=isPrime[1]=0;\n\t\t\tfor(int j=0; j<M; j++){\n\t\t\t\tif(isPrime[j]==0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i=j*2; i<M; i+=j){\n\t\t\t\t\tisPrime[i]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint n=2000;\n\t\tint[][] dp=new int[n][n], index=new int[n][n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfill(dp[i], -1);\n\t\t}\n\t\tint[] _=spiralN2XY(start);\n\t\tint x0=_[0]-n/2, y0=_[1];\n\t\tdp[0][n/2]=isPrime[start];\n\t\tindex[0][n/2]=start*isPrime[start];\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(dp[j][i]<0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int k=-1; k<=1; k++){\n\t\t\t\t\tif(j+1>=n||i+k<0||i+k>=n){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint val=spiralXY2N(x0+i+k, y0+j+1);\n\t\t\t\t\tif(val>m){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[j][i]+isPrime[val]>dp[j+1][i+k]){\n\t\t\t\t\t\tdp[j+1][i+k]=dp[j][i]+isPrime[val];\n\t\t\t\t\t\tindex[j+1][i+k]=isPrime[val]==1?val:index[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint maxVal=0, maxIndex=0;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(dp[j][i]>maxVal||(dp[j][i]==maxVal&&index[j][i]>maxIndex)){\n\t\t\t\t\tmaxVal=dp[j][i];\n\t\t\t\t\tmaxIndex=index[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln(maxVal+\" \"+maxIndex);\n\t}\n\n\tint[] spiralN2XY(int n){\n\t\tint m=(int)sqrt(n-1)+1;\n\t\tint x=m/2-min(m*m-n, m-1), y=m/2-max(m*m-m+1-n, 0);\n\t\tif(m%2==0){\n\t\t\tx=-x+1;\n\t\t\ty=-y;\n\t\t}\n\t\treturn new int[]{x, y};\n\t}\n\n\tint spiralXY2N(int x, int y){\n\t\tint d=max(abs(x), abs(y));\n\t\tif(y>=x)\n\t\t\treturn (2*d+1)*(2*d+1)-abs(d-x)-abs(d-y);\n\t\telse\n\t\t\treturn (2*d)*(2*d)-abs(-d+1-x)-abs(-d-y);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n  Scanner sc;\n\n  class Point {\n    int x, y;\n\n    Point(int x, int y) {\n      this.x = x;\n      this.y = y;\n    }\n    \n    public int hashCode() {\n      return y * 1024 + x;\n    }\n    public boolean equals(Object o) {\n      return this.hashCode() == ((Point)o).hashCode();\n    }\n  }\n\n  boolean isPrime(int n) {\n    boolean flag = n > 1;\n    for ( int i = 2; i * i <= n; ++i ) {\n      flag &= n % i != 0;\n    }\n    return flag;\n  }\n\n  void run() {\n    HashMap<Integer, Point> map = new HashMap<Integer, Point>();\n    boolean[][] prime = new boolean[1024][1024];\n    int[][] field = new int[1024][1024];\n    boolean[][] fill = new boolean[1024][1024];\n    int x, y;\n    x = y = 1024 >> 1;\n    int len = 1;\n    int dir = 1;\n    int idx = 1;\n    prime[ y ][ x ] = isPrime( idx );\n    field[ y ][ x ] = idx;\n    fill[y][x] = true;\n    map.put( idx, new Point( x, y ) );\n    for ( ;idx <= 1000000; ) {\n      for ( int i = 0; i < len; ++i ) {\n        ++idx;\n        x += dir;\n        prime[ y ][ x ] = isPrime( idx );\n        field[ y ][ x ] = idx;\n        fill[y][x] = true;\n        map.put( idx, new Point( x, y ) );\n      }\n      for ( int i = 0; i < len; ++i ) {\n        ++idx;\n        y -= dir;\n        prime[ y ][ x ] = isPrime( idx );\n        field[ y ][ x ] = idx;\n        fill[y][x] = true;\n        map.put( idx, new Point( x, y ) );\n      }\n      ++len;\n      dir *= -1;\n    }\n//    for ( int i = 1024 / 2 - 3; i <= 1024 / 2 + 3; ++i ) {\n//      for ( int j = 1024 / 2 - 3; j <= 1024 / 2 + 3; ++j ) {\n//        System.err.print( String.format( \"%2d\", field[ i ][ j ] ) + \":\" + (prime[i][j] ? 1 : 0) + \" \" );\n//      }\n//      System.err.println();\n//    }\n    for ( ;; ) {\n      int m = ni();\n      int n = ni();\n      if ( ( m | n ) == 0 ) {\n        break;\n      }\n\n      Point p = map.get( n );\n      int[][] dp = new int[1024][1024];\n      int max = prime[ p.y ][ p.x ] ? 1 : 0;\n      int max_num = prime[ p.y ][ p.x ] ? n : 0;\n      HashSet<Point> set = new HashSet<Point>();\n      set.add( p );\n      dp[ p.y ][ p.x ] = prime[ p.y ][ p.x ] ? 1 : 0;\n      for ( ;; ) {\n        HashSet<Point> nexts = new HashSet<Point>();\n        for ( Point ite : set ) {\n          int ax = ite.x;\n          int ay = ite.y;\n          for ( int[] dd : ofs ) {\n            int nx = ax + dd[ 0 ];\n            int ny = ay + dd[ 1 ];\n            Point np = new Point( nx, ny );\n//            debug(nx, ny, field[ny][nx], field[ ny ][ nx ] <= m);\n            if ( 0 <= nx && nx < 1024 && 0 <= ny && ny < 1024 && fill[ny][nx] && field[ ny ][ nx ] <= m ) {\n              nexts.add( np );\n              dp[ ny ][ nx ] = Math.max( dp[ ny ][ nx ], dp[ ay ][ ax ]\n                  + ( prime[ ny ][ nx ] ? 1 : 0 ) );\n              if ( dp[ ny ][ nx ] > max ) {\n                max = dp[ ny ][ nx ];\n                max_num = field[ ny ][ nx ];\n              } else if( dp[ny][nx] == max && prime[ny][nx] ) {\n                max_num = Math.max( max_num, field[ny][nx] );\n              }\n            }\n          }\n        }\n//        debug(nexts.size());\n//        for( Point ite : nexts ) {\n//          debug(ite.x + \",\" + ite.y);\n//        }\n        if ( nexts.size() == 0 ) {\n          break;\n        }\n        set = nexts;\n      }\n\n      System.out.println( max + \" \" + max_num );\n    }\n  }\n\n  int[][] ofs = new int[][] { { -1, 1 }, { 0, 1 }, { 1, 1 } };\n\n  Main() {\n    sc = new Scanner( System.in );\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void debug(Object... os) {\n    System.err.println( Arrays.deepToString( os ) );\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main {\n\t\n\tstatic boolean[] isPrime;\n\tstatic int[][] data;\n\tstatic int size = 1000 + 2;\n\tstatic int set = size / 2 - 1;\n\t\n\tstatic void prime() {\n\t\tisPrime = new boolean[1000001];\n\t\tArrays.fill(isPrime, true);\n\t\tisPrime[0] = false;\n\t\tisPrime[1] = false;\n\t\tfor(int i=2; i*i<=1000000; i++) {\n\t\t\tif(isPrime[i]) {\n\t\t\t\tfor(int j=i+i; j<=1000000; j+=i) {\n\t\t\t\t\tisPrime[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void numArray() {\n\t\tdata = new int[size][size];\n\t\tfor(int i = 0; i < size; i++){\n\t\t\tArrays.fill(data[i], 1<<24);\n\t\t}\n\t\tint now = 1, posx = set, posy = set;\n\t\tfor(int i=1; now<=1000000; i++){\n\t\t\tSystem.out.print(\"\");\n\t\t\tif(i % 2 == 1){\n\t\t\t\tfor(int j=0; j<i && now<=1000000; j++){\n\t\t\t\t\tdata[posy][posx] = now;\n\t\t\t\t\tposx++;\n\t\t\t\t\tnow++;\n\t\t\t\t}\n\t\t\t\tfor(int j=0; j<i && now<=1000000; j++){\n\t\t\t\t\tdata[posy][posx] = now;\n\t\t\t\t\tposy--;\n\t\t\t\t\tnow++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor(int j=0; j<i && now<=1000000; j++){\n\t\t\t\t\tdata[posy][posx] = now;\n\t\t\t\t\tposx--;\n\t\t\t\t\tnow++;\n\t\t\t\t}\n\t\t\t\tfor(int j=0; j<i && now<=1000000; j++){\n\t\t\t\t\tdata[posy][posx] = now;\n\t\t\t\t\tposy++;\n\t\t\t\t\tnow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\tprime();\n\t\t\tnumArray();\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint m = sc.nextInt();\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tif(m + n == 0) break;\n\t\t\t\t\n\t\t\t\tint x = -1;\n\t\t\t\tint y = -1;\n\t\t\t\tfor(int i= 0; i<size; i++) {\n\t\t\t\t\tfor(int j=0; j<size; j++) {\n\t\t\t\t\t\tif(data[i][j] == n) {\n\t\t\t\t\t\t\ty = i;\n\t\t\t\t\t\t\tx = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint[][] dp = new int[size][size];\n\t\t\t\tdp[y][x] = 1;\n\t\t\t\tint max = 1;\n\t\t\t\tint num = 0;\n\t\t\t\tfor(int i=y; i<size; i++) {\n\t\t\t\t\tfor(int j=0; j<size; j++) {\n\t\t\t\t\t\tif(i == y && data[i][j] != n) continue;\n\t\t\t\t\t\tif(data[i][j] > m) continue;\n\t\t\t\t\t\tif(dp[i][j] == 0) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(isPrime[data[i][j]]) {\n\t\t\t\t\t\t\tdp[i][j]++;\n\t\t\t\t\t\t\tif(max < dp[i][j]) {\n\t\t\t\t\t\t\t\tmax = dp[i][j];\n\t\t\t\t\t\t\t\tnum = data[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(max == dp[i][j]) {\n\t\t\t\t\t\t\t\tif(num < data[i][j]) {\n\t\t\t\t\t\t\t\t\tnum = data[i][j];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tdp[i+1][j] = Math.max(dp[i+1][j], dp[i][j]);\n\t\t\t\t\t\tif(j >= 1) {\n\t\t\t\t\t\t\tdp[i+1][j-1] = Math.max(dp[i+1][j-1], dp[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j + 1 < 1002) {\n\t\t\t\t\t\t\tdp[i+1][j+1] = Math.max(dp[i+1][j+1], dp[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(max-1 + \" \" + num);\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\n\tint M = 1000000;\n\tboolean[] prime = new boolean[M + 1];\n\n\tvoid run() {\n\t\tArrays.fill(prime, true);\n\t\tprime[0] = prime[1] = false;\n\t\tfor (int i = 2; i * i <= M; i++) {\n\t\t\tif (!prime[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int j = i * 2; j <= M; j += i) {\n\t\t\t\tprime[j] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (;;) {\n\t\t\tint m = sc.nextInt(); // all hall\n\t\t\tint n = sc.nextInt(); // start number\n\t\t\tif ((m | n) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint[][] field = new int[1001][1001];\n\t\t\tint[][] dp = new int[1001][1001];\n\t\t\tboolean[][] visit = new boolean[1001][1001];\n\t\t\tint x = 500;\n\t\t\tint y = 500;\n\t\t\tint right = 1;\n\t\t\tint up = 1;\n\t\t\tint left = 2;\n\t\t\tint down = 2;\n\t\t\tfield[500][500] = 1;\n\t\t\tlabel: for (int i = 2; i <= m;) {\n\t\t\t\tfor (int j = 1; j <= right; j++) {\n\t\t\t\t\tfield[y][++x] = i++;\n\t\t\t\t\tif (i > m) {\n\t\t\t\t\t\tbreak label;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 1; j <= up; j++) {\n\t\t\t\t\tfield[--y][x] = i++;\n\t\t\t\t\tif (i > m) {\n\t\t\t\t\t\tbreak label;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 1; j <= left; j++) {\n\t\t\t\t\tfield[y][--x] = i++;\n\t\t\t\t\tif (i > m) {\n\t\t\t\t\t\tbreak label;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 1; j <= down; j++) {\n\t\t\t\t\tfield[++y][x] = i++;\n\t\t\t\t\tif (i > m) {\n\t\t\t\t\t\tbreak label;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tright += 2;\n\t\t\t\tup += 2;\n\t\t\t\tleft += 2;\n\t\t\t\tdown += 2;\n\t\t\t}\n\n\t\t\tint startX = 0;\n\t\t\tint startY = 0;\n\t\t\tfor (int i = 0; i <= 1000; i++) {\n\t\t\t\tfor (int j = 0; j <= 1000; j++) {\n\t\t\t\t\tif (field[i][j] == n) {\n\t\t\t\t\t\tstartX = j;\n\t\t\t\t\t\tstartY = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvisit[startY][startX] = true;\n\t\t\tfor (int i = startY + 1; i <= 1000; i++) {\n\t\t\t\tfor (int j = 0; j <= 1000; j++) {\n\t\t\t\t\tif (j - 1 >= 0 && visit[i - 1][j - 1]) {\n\t\t\t\t\t\tvisit[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (visit[i - 1][j]) {\n\t\t\t\t\t\tvisit[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (j + 1 <= 1000 && visit[i - 1][j + 1]) {\n\t\t\t\t\t\tvisit[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ansCnt = 0;\n\t\t\tint ansNum = 0;\n\t\t\tfor (int i = startY; i <= 1000; i++) {\n\t\t\t\tfor (int j = 0; j <= 1000; j++) {\n\t\t\t\t\tif (!visit[i][j] || field[i][j] == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tif (i - 1 >= 0 && j - 1 > 0 && visit[i - 1][j - 1]) {\n\t\t\t\t\t\tcnt = Math.max(cnt, dp[i - 1][j - 1]);\n\t\t\t\t\t}\n\t\t\t\t\tif (i - 1 >= 0 && visit[i - 1][j]) {\n\t\t\t\t\t\tcnt = Math.max(cnt, dp[i - 1][j]);\n\t\t\t\t\t}\n\t\t\t\t\tif (i - 1 >= 0 && j + 1 <= 1000 && visit[i - 1][j + 1]) {\n\t\t\t\t\t\tcnt = Math.max(cnt, dp[i - 1][j + 1]);\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j] = cnt + (prime[field[i][j]] ? 1 : 0);\n\t\t\t\t\tansCnt = Math.max(ansCnt, dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i <= 1000; i++) {\n\t\t\t\tfor (int j = 0; j <= 1000; j++) {\n\t\t\t\t\tif (dp[i][j] == ansCnt) {\n\t\t\t\t\t\tif (prime[field[i][j]]) {\n\t\t\t\t\t\t\tansNum = Math.max(ansNum, field[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ansCnt == 0) {\n\t\t\t\tansNum = 0;\n\t\t\t}\n\t\t\tSystem.out.println(ansCnt + \" \" + ansNum);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 480; i < 520; i++) {\n\t\t\tfor (int j = 480; j < 520; j++) {\n\t\t\t\tSystem.out.printf(\"%04d \", array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.awt.geom.Point2D.Double;\nimport java.util.*;\n \npublic class Main {\n\t     \n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t \n\t\tint pm = 1000000;\n\t\tboolean[] prime = new boolean[pm+10000];\n\t\tfor(int i=2;i<=pm;i++) prime[i] = true;\n\t\tfor(int i=2;i<=pm+1;i++){\n\t\t\tfor(int j=i+i;j<=pm;j+=i){\n\t\t\t\tprime[j] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[][] map = new int[1010][1010];\n\t\tPoint2D.Double[] p = new Point2D.Double[1100000];\n\t\tint x = 500;\n\t\tint y = 500;\n\t\tint z = 1;\n\t\tint cnt = 1;\n\t\tboolean flag = true;\n\t\twhile(true){\n\t\t\tif(flag==true){\n\t\t\t\tfor(int i=0;i<z;i++){\n\t\t\t\t\tmap[y][x] = cnt;\n\t\t\t\t\tp[cnt] = new Point2D.Double(x, y);\n\t\t\t\t\tcnt++;\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<z;i++){\n\t\t\t\t\tmap[y][x] = cnt;\n\t\t\t\t\tp[cnt] = new Point2D.Double(x, y);\n\t\t\t\t\tcnt++;\n\t\t\t\t\ty--;\n\t\t\t\t}\n\t\t\t\tflag = false;\n\t\t\t}else if(flag==false){\n\t\t\t\tfor(int i=0;i<z;i++){\n\t\t\t\t\tmap[y][x] = cnt;\n\t\t\t\t\tp[cnt] = new Point2D.Double(x, y);\n\t\t\t\t\tcnt++;\n\t\t\t\t\tx--;\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<z;i++){\n\t\t\t\t\tmap[y][x] = cnt;\n\t\t\t\t\tp[cnt] = new Point2D.Double(x, y);\n\t\t\t\t\tcnt++;\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t\tz++;\n\t\t\tif(cnt>1003000) break;\n\t\t}\n\n\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n==0 && m==0) break;\n\t\t\t\n\t\t\tint s = (int)p[m].x;\n\t\t\tint t = (int)p[m].y;\n\t\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\t\tArrayDeque<Integer> r = new ArrayDeque<Integer>();\n\t\t\tint[][] dp = new int[1002][1002];\n\t\t\tfor(int i=0;i<1002;i++) Arrays.fill(dp[i], -1);\n\t\t\tdp[t][s] = 0;\n\t\t\tq.offer(s);\n\t\t\tr.offer(t);\n\t\t\tint num = 0;\n\t\t\tint max = 0;\n\t\t\tif(prime[m]==true){\n\t\t\t\tdp[t][s] = 1;\n\t\t\t\tmax = 1;\n\t\t\t\tnum = m;\n\t\t\t}\n\t\t\t\n\t\t\tint u, v;\n\t\t\twhile(q.size()!=0){\n\t\t\t\ts = q.poll();\n\t\t\t\tt = r.poll();\n\t\t\t\tfor(int i=-1;i<=1;i++){\n\t\t\t\t\tv = map[t+1][s+i];\n\t\t\t\t\tif(0<=s+i && s+i<=1000 && v<=n){\n\t\t\t\t\t\tif(prime[v]==true){\n\t\t\t\t\t\t\tif(dp[t+1][s+i]<dp[t][s]+1){\n\t\t\t\t\t\t\t\tdp[t+1][s+i] = dp[t][s]+1;\n\t\t\t\t\t\t\t\tq.offer(s+i);\n\t\t\t\t\t\t\t\tr.offer(t+1);\n\t\t\t\t\t\t\t\tif(dp[t+1][s+i]>max){\n\t\t\t\t\t\t\t\t\tmax = dp[t+1][s+i];\n\t\t\t\t\t\t\t\t\tnum = v;\n\t\t\t\t\t\t\t\t}else if(dp[t+1][s+i]==max){\n\t\t\t\t\t\t\t\t\tnum = Math.max(num, v);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(dp[t+1][s+i]<dp[t][s]){\n\t\t\t\t\t\t\t\tdp[t+1][s+i] = dp[t][s];\n\t\t\t\t\t\t\t\tq.offer(s+i);\n\t\t\t\t\t\t\t\tr.offer(t+1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max + \" \" + num);\n\t\t}\n    }   \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static int[][][] caves = new int[2][1000][1000];\n    static boolean[] primes = new boolean[1000000];\n    static int[][] dp = new int[2][1000];\n    static int[] vx = {1, 0, -1, 0};\n    static int[] vy = {0, -1, 0, 1};\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        MakeCaves();\n        while (true){\n            int m = sc.nextInt();\n            int n = sc.nextInt();\n            if(m==0 && n==0) break;\n\n            int x = -1, y = -1;\n            for (int i = 0; i < 1000; i++) {\n                for (int j = 0; j < 1000; j++) {\n                    if(caves[0][i][j]==n){\n                        x = j; y = i;\n                        break;\n                    }\n                }\n                if(x!=-1) break;\n            }\n            for (int i = 0; i <1000 ; i++) {\n                dp[0][i] = dp[1][i] = 0;\n            }\n\n            int max = 0, dy = 0, mx = x, my = y;\n            while (y+dy<1000){\n                for (int i = (x-dy>=0)?x-dy:0; i <= ((x+dy<1000)?x+dy:999); i++) {\n                    if(caves[0][y+dy][i]>m) continue;\n                    dp[dy%2][i] = dp[(dy+1)%2][i] + caves[1][y+dy][i];\n                    if(i>0&&dp[(dy+1)%2][i-1]!=0){\n                        dp[dy%2][i] = Math.max(dp[dy%2][i], dp[(dy+1)%2][i-1] + caves[1][y+dy][i]);\n                    }\n                    if(i<999&&dp[(dy+1)%2][i+1]!=0){\n                        dp[dy%2][i] = Math.max(dp[dy%2][i], dp[(dy+1)%2][i+1] + caves[1][y+dy][i]);\n                    }\n                    if(max<dp[dy%2][i]){\n                        max = dp[dy%2][i];\n                        mx = i; my = y + dy;\n                    }else if(max==dp[dy%2][i] && caves[1][y+dy][i]==1){\n                        if(caves[0][my][mx]<caves[0][y+dy][i]){\n                            mx = i; my = y + dy;\n                        }\n                    }\n                }\n                dy++;\n            }\n            System.out.println(max+\" \"+((max!=0)?caves[0][my][mx]:0));\n        }\n    }\n\n    static void FindPrimes() {\n        primes[0] = true;\n        for (int i = 1; i < 500000; i++) {\n            if(primes[i]) continue;\n            int j = (i+1)*2;\n            while (j<1000000){\n                primes[j-1] = true;\n                j += i+1;\n            }\n        }\n    }\n\n    static void MakeCaves() {\n        int n = 2, x = 499, y = 500;\n        FindPrimes();\n        caves[0][y][x] = 1;\n        caves[1][y][x] = 0;\n\n        for (int i = 0; i < 2000; i++) {\n            for (int j = 0; j <= i/2; j++, n++) {\n                if(n==1000001) break;\n                x+=vx[i%4]; y+=vy[i%4];\n                caves[0][y][x] = n;\n                caves[1][y][x] = (primes[n-1])?0:1;\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n  Scanner sc;\n\n  class Point {\n    int x, y;\n\n    Point(int x, int y) {\n      this.x = x;\n      this.y = y;\n    }\n    \n    public int hashCode() {\n      return y * 1024 + x;\n    }\n    public boolean equals(Object o) {\n      return this.hashCode() == ((Point)o).hashCode();\n    }\n  }\n\n  boolean isPrime(int n) {\n    boolean flag = n > 1;\n    for ( int i = 2; i * i <= n; ++i ) {\n      flag &= n % i != 0;\n    }\n    return flag;\n  }\n\n  void run() {\n    HashMap<Integer, Point> map = new HashMap<Integer, Point>();\n    boolean[][] prime = new boolean[1024][1024];\n    int[][] field = new int[1024][1024];\n    int x, y;\n    x = y = 1024 >> 1;\n    int len = 1;\n    int dir = 1;\n    int idx = 1;\n    prime[ y ][ x ] = isPrime( idx );\n    field[ y ][ x ] = idx;\n    map.put( idx, new Point( x, y ) );\n    for ( ; idx <= 1000000;) {\n      for ( int i = 0; i < len; ++i ) {\n        ++idx;\n        x += dir;\n        prime[ y ][ x ] = isPrime( idx );\n        field[ y ][ x ] = idx;\n        map.put( idx, new Point( x, y ) );\n      }\n      for ( int i = 0; i < len; ++i ) {\n        ++idx;\n        y -= dir;\n        prime[ y ][ x ] = isPrime( idx );\n        field[ y ][ x ] = idx;\n        map.put( idx, new Point( x, y ) );\n      }\n      ++len;\n      dir *= -1;\n    }\n//    for ( int i = 1024 / 2 - 3; i <= 1024 / 2 + 3; ++i ) {\n//      for ( int j = 1024 / 2 - 3; j <= 1024 / 2 + 3; ++j ) {\n//        System.err.print( String.format( \"%2d\", field[ i ][ j ] ) + \":\" + (prime[i][j] ? 1 : 0) + \" \" );\n//      }\n//      System.err.println();\n//    }\n    \n    for ( ;; ) {\n      int m = ni();\n      int n = ni();\n      if ( ( m | n ) == 0 ) {\n        break;\n      }\n      Point p = map.get( n );\n      int[][] dp = new int[1024][1024];\n      int max = prime[ p.y ][ p.x ] ? 1 : 0;\n      int max_num = prime[ p.y ][ p.x ] ? n : 0;\n      HashSet<Point> set = new HashSet<Point>();\n      set.add( p );\n      dp[ p.y ][ p.x ] = prime[ p.y ][ p.x ] ? 1 : 0;\n      for ( ;; ) {\n        HashSet<Point> nexts = new HashSet<Point>();\n        for ( Point ite : set ) {\n          int ax = ite.x;\n          int ay = ite.y;\n          for ( int[] dd : ofs ) {\n            int nx = ax + dd[ 0 ];\n            int ny = ay + dd[ 1 ];\n            Point np = new Point( nx, ny );\n//            debug(nx, ny, field[ny][nx], field[ ny ][ nx ] <= m);\n            if ( 0 <= nx && nx < 1024 && 0 <= ny && ny < 1024 && field[ ny ][ nx ] <= m ) {\n              nexts.add( np );\n              dp[ ny ][ nx ] = Math.max( dp[ ny ][ nx ], dp[ ay ][ ax ]\n                  + ( prime[ ny ][ nx ] ? 1 : 0 ) );\n              if ( dp[ ny ][ nx ] > max ) {\n                max = dp[ ny ][ nx ];\n                max_num = field[ ny ][ nx ];\n              } else if( dp[ny][nx] == max ) {\n                max_num = Math.max( max_num, field[ny][nx] );\n              }\n            }\n          }\n        }\n//        debug(nexts.size());\n//        for( Point ite : nexts ) {\n//          debug(ite.x + \",\" + ite.y);\n//        }\n        if ( nexts.size() == 0 ) {\n          break;\n        }\n        set = nexts;\n      }\n\n      System.out.println( max + \" \" + max_num );\n    }\n  }\n\n  int[][] ofs = new int[][] { { -1, 1 }, { 0, 1 }, { 1, 1 } };\n\n  Main() {\n    sc = new Scanner( System.in );\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void debug(Object... os) {\n    System.err.println( Arrays.deepToString( os ) );\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n  Scanner sc;\n\n  class Point {\n    int x, y;\n\n    Point(int x, int y) {\n      this.x = x;\n      this.y = y;\n    }\n    \n    public int hashCode() {\n      return y * 1024 + x;\n    }\n    public boolean equals(Object o) {\n      return this.hashCode() == ((Point)o).hashCode();\n    }\n  }\n\n  boolean isPrime(int n) {\n    boolean flag = n > 1;\n    for ( int i = 2; i * i <= n; ++i ) {\n      flag &= n % i != 0;\n    }\n    return flag;\n  }\n\n  void run() {\n    HashMap<Integer, Point> map = new HashMap<Integer, Point>();\n    boolean[][] prime = new boolean[1024][1024];\n    int[][] field = new int[1024][1024];\n    boolean[][] fill = new boolean[1024][1024];\n    int x, y;\n    x = y = 1024 >> 1;\n    int len = 1;\n    int dir = 1;\n    int idx = 1;\n    prime[ y ][ x ] = isPrime( idx );\n    field[ y ][ x ] = idx;\n    fill[y][x] = true;\n    map.put( idx, new Point( x, y ) );\n    for ( ;idx <= 1000000; ) {\n      for ( int i = 0; i < len; ++i ) {\n        ++idx;\n        x += dir;\n        prime[ y ][ x ] = isPrime( idx );\n        field[ y ][ x ] = idx;\n        fill[y][x] = true;\n        map.put( idx, new Point( x, y ) );\n      }\n      for ( int i = 0; i < len; ++i ) {\n        ++idx;\n        y -= dir;\n        prime[ y ][ x ] = isPrime( idx );\n        field[ y ][ x ] = idx;\n        fill[y][x] = true;\n        map.put( idx, new Point( x, y ) );\n      }\n      ++len;\n      dir *= -1;\n    }\n//    for ( int i = 1024 / 2 - 3; i <= 1024 / 2 + 3; ++i ) {\n//      for ( int j = 1024 / 2 - 3; j <= 1024 / 2 + 3; ++j ) {\n//        System.err.print( String.format( \"%2d\", field[ i ][ j ] ) + \":\" + (prime[i][j] ? 1 : 0) + \" \" );\n//      }\n//      System.err.println();\n//    }\n    debug(isPrime(1075));\n    for ( ;; ) {\n      int m = ni();\n      int n = ni();\n      if ( ( m | n ) == 0 ) {\n        break;\n      }\n\n      Point p = map.get( n );\n      int[][] dp = new int[1024][1024];\n      int max = prime[ p.y ][ p.x ] ? 1 : 0;\n      int max_num = prime[ p.y ][ p.x ] ? n : 0;\n      HashSet<Point> set = new HashSet<Point>();\n      set.add( p );\n      dp[ p.y ][ p.x ] = prime[ p.y ][ p.x ] ? 1 : 0;\n      for ( ;; ) {\n        HashSet<Point> nexts = new HashSet<Point>();\n        for ( Point ite : set ) {\n          int ax = ite.x;\n          int ay = ite.y;\n          for ( int[] dd : ofs ) {\n            int nx = ax + dd[ 0 ];\n            int ny = ay + dd[ 1 ];\n            Point np = new Point( nx, ny );\n//            debug(nx, ny, field[ny][nx], field[ ny ][ nx ] <= m);\n            if ( 0 <= nx && nx < 1024 && 0 <= ny && ny < 1024 && fill[ny][nx] && field[ ny ][ nx ] <= m ) {\n              nexts.add( np );\n              dp[ ny ][ nx ] = Math.max( dp[ ny ][ nx ], dp[ ay ][ ax ]\n                  + ( prime[ ny ][ nx ] ? 1 : 0 ) );\n              if ( dp[ ny ][ nx ] > max ) {\n                max = dp[ ny ][ nx ];\n                max_num = field[ ny ][ nx ];\n              } else if( dp[ny][nx] == max && prime[ny][nx] ) {\n                max_num = Math.max( max_num, field[ny][nx] );\n              }\n            }\n          }\n        }\n//        debug(nexts.size());\n//        for( Point ite : nexts ) {\n//          debug(ite.x + \",\" + ite.y);\n//        }\n        if ( nexts.size() == 0 ) {\n          break;\n        }\n        set = nexts;\n      }\n\n      System.out.println( max + \" \" + max_num );\n    }\n  }\n\n  int[][] ofs = new int[][] { { -1, 1 }, { 0, 1 }, { 1, 1 } };\n\n  Main() {\n    sc = new Scanner( System.in );\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void debug(Object... os) {\n    System.err.println( Arrays.deepToString( os ) );\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int MAX = 1000000;\n\tpublic static final int SQRT = 1000;\n\t\n\tpublic static final int MAP_SIZE = 2 * SQRT + 1;\n\tpublic static final int CENTER = SQRT + 1;\n\t\n\tpublic static int[][] move_dir = new int[][]{{1, 0}, {0, -1}, {-1, 0}, {0, 1}};\n\t\n\tpublic static void circle(int[][] map, int m, int[] x_pos, int[] y_pos){\n\t\tint len = 1;\n\t\tint count = 1;\n\t\tint type = 0;\n\t\tint cur_x = CENTER;\n\t\tint cur_y = CENTER;\n\t\t\n\t\tx_pos[count] = cur_x;\n\t\ty_pos[count] = cur_y;\n\t\tmap[cur_x][cur_y] = count++;\n\t\tprepare:\n\t\twhile(true){\n\t\t\tfinal int dx = move_dir[type][0];\n\t\t\tfinal int dy = move_dir[type][1];\n\t\t\t\n\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\tcur_x += dx;\n\t\t\t\tcur_y += dy;\n\t\t\t\t\n\t\t\t\tif(count > m){\n\t\t\t\t\tbreak prepare;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tx_pos[count] = cur_x;\n\t\t\t\ty_pos[count] = cur_y;\n\t\t\t\tmap[cur_y][cur_x] = count++;\n\t\t\t}\n\t\t\t\n\t\t\ttype = (type + 1) % move_dir.length;\n\t\t\t\n\t\t\tif(type % 2 == 0){\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t/* generate primes */\n\t\tboolean is_prime[] = new boolean[MAX + 1];\n\t\tArrays.fill(is_prime, true);\n\t\tis_prime[0] = is_prime[1] = false;\n\t\t\n\t\tfor(int i = 2; i <= SQRT; i++){\n\t\t\tif(is_prime[i]){\n\t\t\t\tfor(int j = 2 * i; j <= MAX; j += i){\n\t\t\t\t\tis_prime[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[][] map = new int[MAP_SIZE][MAP_SIZE];\n\t\tint[] x_pos = new int[MAX + 1];\n\t\tint[] y_pos = new int[MAX + 1];\n\t\t\n\t\tint[][] dp_prev_prime = new int[MAP_SIZE][MAP_SIZE];\n\t\tint[][] dp_length = new int[MAP_SIZE][MAP_SIZE];\n\t\t\n\t\twhile (true) {\n\t\t\tfinal int m = sc.nextInt();\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(m == 0 && n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tArrays.fill(x_pos, 0);\n\t\t\tArrays.fill(y_pos, 0);\n\t\t\tfor(int i = 0; i < MAP_SIZE; i++){\n\t\t\t\tArrays.fill(map[i], 0);\n\t\t\t}\n\t\t\t\n\t\t\tcircle(map, m, x_pos, y_pos);\n\t\t\t\n\t\t\tfor(int y = MAP_SIZE - 1; y >= 0; y--){\n\t\t\t\tArrays.fill(dp_length[y], 0);\n\t\t\t\tArrays.fill(dp_prev_prime[y], 0);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tfor(int y = MAP_SIZE - 1; y >= 0; y--){\n\t\t\t\tfor(int x = MAP_SIZE - 1; x >= 0; x--){\n\t\t\t\t\tfinal int cave_value = map[y][x];\n\t\t\t\t\t\n\t\t\t\t\tif(cave_value == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(cave_value > m){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(is_prime[cave_value]){\n\t\t\t\t\t\tdp_length[y][x]++;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(dp_prev_prime[y][x] == 0){\n\t\t\t\t\t\t\tdp_prev_prime[y][x] = cave_value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(y == 0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//System.out.println(cave_value + \" \" + dp_length[y][x] + \" \" + dp_prev_prime[y][x]);\n\t\t\t\t\t//sc.nextLine();\n\t\t\t\t\tfinal int next_y = y - 1;\n\t\t\t\t\tfor(int dx = -1; dx <= 1; dx++){\n\t\t\t\t\t\tfinal int next_x = x + dx;\n\t\t\t\t\t\tfinal int next_value = map[next_y][next_x];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(next_x < 0){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else if(next_x >= MAP_SIZE){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else if(next_value == 0){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else if(next_value > m){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tfinal int cave_length = dp_length[y][x];\n\t\t\t\t\t\tfinal int next_length = dp_length[next_y][next_x];\n\t\t\t\t\t\t\n\t\t\t\t\t\tfinal int cave_prev_prime = dp_prev_prime[y][x];\n\t\t\t\t\t\tfinal int next_prev_prime = dp_prev_prime[next_y][next_x];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(cave_length > next_length || (cave_length == next_length && cave_prev_prime > next_prev_prime)){\n\t\t\t\t\t\t\tdp_length[next_y][next_x] = cave_length;\n\t\t\t\t\t\t\tdp_prev_prime[next_y][next_x] = cave_prev_prime;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.println(y_pos[n] + \" \" + x_pos[n]);\n\t\t\t\n\t\t\tSystem.out.println(dp_length[y_pos[n]][x_pos[n]] + \" \" + dp_prev_prime[y_pos[n]][x_pos[n]]);\t\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "//import java.io.File;\nimport java.util.Scanner;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\n\nclass Main{\n  static int[] sosu = new int[100000];\n  static int sosuIte = 4, sosuMax = 11;\n  static HashSet<Integer> fastSosu;\n  static HashMap<Integer,Integer> dp; //<caveNum,answer>\n  static int maxNumber; //cave????????°\n  //static int maxAnswerCave; //?§£??¨??????cave?????????\n  static int maxAnswerNumber; //?§£??¨????????°\n  static HashMap<Integer,Integer> maxAnswerCaveMap;\n\n  public static void main(String[] args) throws Exception {\n    sosu[0] = 2;  sosu[1] = 3;  sosu[2] = 5;  sosu[3] = 7;\n    fastSosu = new HashSet<>(100000);\n    fastSosu.add(2);fastSosu.add(3);fastSosu.add(5);fastSosu.add(7);\n\n    //Scanner scan = new Scanner(new File(\"in.txt\"));\n    Scanner scan = new Scanner(System.in);\n\n    int input1 = scan.nextInt();\n    int input2 = scan.nextInt();\n\n    while(!(input1==0&&input2==0)) {\n      //System.out.print(input2+\" \");\n      dp = new HashMap<>();\n      maxAnswerCaveMap = new HashMap<>();\n      maxNumber = input1;\n      //maxAnswerCave = 0;\n      calcSosu(input1);\n\n      System.out.print(getCount(input2));\n      int dummy = maxAnswerCaveMap.get(input2);\n      System.out.println(\" \"+(dummy!=-1?dummy:0));\n\n/*\n      for(Map.Entry<Integer,Integer> entry : dp.entrySet()) {\n        System.out.println(entry.getKey()+\",\"+entry.getValue());\n      }\n      */\n/*\n            for(Map.Entry<Integer,Integer> entry : maxAnswerCaveMap.entrySet()) {\n              System.out.println(entry.getKey()+\",\"+entry.getValue());\n            }\n            */\n\n\n\n      input1 = scan.nextInt();\n      input2 = scan.nextInt();\n    }\n    //System.out.println(sosuIte);\n\n/*\n    for(int i = 0; i < 100; i++) {\n      Set io = getPos(i+1);\n      if(getNum(io.x,io.y)!= i+1) System.out.println(io.x+\",\"+io.y+\" : \"+getNum(io.x,io.y));\n    }\n*/\n\n  }\n\n  static int getCount(int _number) {\n    //System.out.println(_number);\n    if(_number > maxNumber) {\n      return 0;\n    }\n\n    int rd=0,d=0,ld=0; //??????????????????\n\n    if(dp.containsKey(_number)) {\n      //System.out.println(\"dp:\"+_number);\n      return dp.get(_number);\n    }\n\n    Set inset = getPos(_number);  //????????´???\n    //?????????\n    int rdN = getNum(inset.x+1,inset.y+1);\n    rd = getCount(rdN);\n    int dN = getNum(inset.x,inset.y+1);\n    d = getCount(dN);\n    int ldN = getNum(inset.x-1,inset.y+1);\n    ld = getCount(ldN);\n\n\n\n    //??§??????caveNo???hashmap???????´?\n    int max = 0;\n    int maxCave = 0;\n    int rdC = maxAnswerCaveMap.containsKey(rdN)?maxAnswerCaveMap.get(rdN):-1;\n    int dC = maxAnswerCaveMap.containsKey(dN)?maxAnswerCaveMap.get(dN):-1;\n    int ldC = maxAnswerCaveMap.containsKey(ldN)?maxAnswerCaveMap.get(ldN):-1;\n    if(rd>d&&rd>ld) {\n      max = rd;\n      maxCave = rdC;\n    }else if(d>rd&&d>ld) {\n      max = d;\n      maxCave = dC;\n    }else if(ld>rd&&ld>d) {\n      max = ld;\n      maxCave = ldC;\n    }else if(rd==d&&d==ld) {\n      max = rd;\n      maxCave = Math.max(rdC,Math.max(dC,ldC));\n    }else if(rd==d) {\n      max = rd;\n      maxCave = rdC>dC?rdC:dC;\n    }else if(d==ld) {\n      max = d;\n      maxCave = dC>ldC?dC:ldC;\n    }else {\n      max = rd;\n      maxCave = rdC>ldC?rdC:ldC;\n    }\n\n\n    boolean flag = fastSosu.contains(_number);\n    if(flag && maxCave == -1) {\n      maxCave = _number;\n    }\n    maxAnswerCaveMap.put(_number,maxCave);\n    int answer = max + (flag?1:0);\n    //if(_number == 15 || _number == 5) System.out.println(_number+\":\"+answer+\",(\"+rd+\",\"+d+\",\"+ld+\")\");\n    //System.out.println(_number+\":\"+answer+\",(\"+rd+\",\"+d+\",\"+ld+\")\");\n    //System.out.print(answer+\",\");\n    dp.put(_number,answer);\n    return answer;\n  }\n\n  static void calcSosu(int _max) {\n    NOT_SOSU: for(int i = sosuMax; i <= _max; i++) {\n      sosuMax++;\n      if(i%2==0||i%3==0||i%5==0||i%7==0) continue;\n      for(int j = 0; j < sosuIte; j++) {\n        if(i<sosu[j]*sosu[j]) break;\n        if(i%sosu[j]==0) continue NOT_SOSU;\n      }\n      //System.out.println(\"prime!!\"+sosuIte+\":\"+i);\n      sosu[sosuIte] = i;\n      sosuIte++;\n      fastSosu.add(i);\n    }\n  }\n\n  //?????????1\n  static int getNum(int _x, int _y) {\n    int dummyX = _x>0?_x:-_x;\n    int dummyY = _y>0?_y:-_y;\n    int inRect = dummyX>dummyY?dummyX:dummyY;\n\n    if(_x==inRect&&_y<inRect) {\n      return (inRect*2-1)*(inRect*2-1)+(_y-inRect)*-1;\n    }else if(_y==-inRect&&_x<inRect) {\n      return (inRect*2-1)*(inRect*2-1)+inRect*2+(_x-inRect)*-1;\n    }else if(_x==-inRect&&_y>-inRect) {\n      return (inRect*2-1)*(inRect*2-1)+inRect*4+_y+inRect;\n    }else if(_y==inRect&&_x>-inRect) {\n      return (inRect*2-1)*(inRect*2-1)+inRect*6+_x+inRect;\n    }else return 1;\n  }\n\n  //?????????0,0\n  static Set getPos(int _num) {\n    if(_num==1) return new Set(0,0);\n    int inRect = (1+(int)Math.sqrt(_num-1))/2;\n    int index = (_num-(inRect*2-1)*(inRect*2-1)-1);\n    int fourPart = index/(inRect*2);\n    index %= (inRect*2);\n\n    //System.out.print(\"num:\"+_num+\",inRect:\"+inRect+\",\");\n\n    int rx=0,ry=0;\n    switch(fourPart) {\n      case 0:\n        rx = inRect;\n        ry = inRect-1-index;\n        break;\n      case 1:\n        rx = inRect-1-index;\n        ry = -inRect;\n        break;\n      case 2:\n        rx = -inRect;\n        ry = -inRect+1+index;\n        break;\n      case 3:\n        rx = -inRect+1+index;\n        ry = inRect;\n        break;\n    }\n\n    //System.out.print(\"(\"+rx+\",\"+ry+\")\");\n    return new Set(rx,ry);\n  }\n}\n\n\nclass Set{\n  int x,y;\n  Set(int _x, int _y) {\n    this.x = _x;\n    this.y = _y;\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n// Prime Caves\n// 2013/08/14\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint m, start;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tm=sc.nextInt();\n\t\t\tstart=sc.nextInt();\n\t\t\tif((m|start)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tint[] isPrime;\n\n\tvoid solve(){\n\t\tint M=(int)1e6+100;\n\t\tif(isPrime==null){\n\t\t\tisPrime=new int[M];\n\t\t\tfill(isPrime, 1);\n\t\t\tisPrime[0]=isPrime[1]=0;\n\t\t\tfor(int j=0; j<M; j++){\n\t\t\t\tif(isPrime[j]==0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i=j*2; i<M; i+=j){\n\t\t\t\t\tisPrime[i]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint n=2000;\n\t\tint[][] dp=new int[n][n], index=new int[n][n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfill(dp[i], -1);\n\t\t}\n\t\tint[] _=spiralN2XY(start);\n\t\tint x0=_[0]-n/2, y0=_[1];\n\t\tdp[0][n/2]=isPrime[start];\n\t\tindex[0][n/2]=start*isPrime[start];\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(dp[j][i]<0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int k=-1; k<=1; k++){\n\t\t\t\t\tif(j+1>=n||i+k<0||i+k>=n){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint val=spiralXY2N(x0+i+k, y0+j+1);\n\t\t\t\t\tif(val>m){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[j][i]+isPrime[val]>dp[j+1][i+k]){\n\t\t\t\t\t\tdp[j+1][i+k]=dp[j][i]+isPrime[val];\n\t\t\t\t\t\tindex[j+1][i+k]=isPrime[val]==1?val:index[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint maxVal=0, maxIndex=0;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(dp[j][i]>maxVal||(dp[j][i]==maxVal&&index[j][i]>maxIndex)){\n\t\t\t\t\tmaxVal=dp[j][i];\n\t\t\t\t\tmaxIndex=index[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln(maxVal+\" \"+maxIndex);\n\t}\n\n\tint[] spiralN2XY(int n){\n\t\tint m=(int)sqrt(n-1)+1;\n\t\tint x=m/2-min(m*m-n, m-1), y=m/2-max(m*m-m+1-n, 0);\n\t\tif(m%2==0){\n\t\t\tx=-x+1;\n\t\t\ty=-y;\n\t\t}\n\t\treturn new int[]{x, y};\n\t}\n\n\tint spiralXY2N(int x, int y){\n\t\tint d=max(abs(x), abs(y));\n\t\tif(y>=x)\n\t\t\treturn (2*d+1)*(2*d+1)-abs(d-x)-abs(d-y);\n\t\telse\n\t\t\treturn (2*d)*(2*d)-abs(-d+1-x)-abs(-d-y);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define FOR(i,a,n) for(int i = (a);i < (n);i++)\nconst int MAX_E = 1e3 + 3;\nconst int START = MAX_E / 2;\nconst int N = 1e6 + 3;\nconst int INF = 1e9;\nint p[N+1];\nvoid e(){\n  fill(p,p+N,1);\n  p[0] = p[1] = 0;\n  for(int i = 2;i*i<=N;i++)\n    if(p[i] == 1)for(int j = i*i;j<=N;j+=i)p[j] = 0;\n}\n\nmap<pair<int,int> ,int> mp;\n\ninline pair<int,int> pmax(pair<int,int> a, pair<int,int> b,int x,int y){\n  // a is pre\n  if(p[mp[make_pair(x,y)]]){\n    a.first++;\n    b.second = mp[make_pair(x,y)];\n    a.second = mp[make_pair(x,y)];\n    if(a.first > b.first)return a;\n    else return b;\n  }else{\n    if(a.first > b.first)return a;\n    else return b;\n  }\n}\n\nint main(){\n  int n,m;\n\n  int dx[4] = {1,0,-1,0};\n  int dy[4] = {0,-1,0,1};\n  e();\n  pair<int,int> co[MAX_E][MAX_E];// n, is prime\n  pair<int,int> dp[MAX_E][MAX_E];// first is num, second is prime\n  int rx =START,lx = START,uy = START,ly = START;\n  int x = START,y = START,mode = 0;\n  FOR(i,1,N){\n    mp[make_pair(x,y)] = i;\n    x += dx[mode];\n      y += dy[mode];\n      if(mode == 0 && x > rx){rx = x;mode++;}\n      if(mode == 1 && y > uy){uy = y;mode++;}\n      if(mode == 2 && x < lx){lx = x;mode++;}\n      if(mode == 3 && y < ly){ly = y;mode++;}\n  }\n\n\n  \n  while(cin>>n>>m,n){\n    int rx =START,lx = START,uy = START,ly = START;\n\n    int x = START,y = START,mode = 0;\n    int sx,sy;\n    fill(co[0],co[MAX_E],make_pair(INF,0));\n    FOR(i,1,n+1){\n      if(i == m){//get start\n      sx = x,sy = y;\n      }\n\n      co[MAX_E/2 + x][MAX_E/2 + y] = make_pair(i,p[i]);\n      x += dx[mode];\n      y += dy[mode];\n      if(mode == 0 && x > rx){rx = x;mode++;}\n      if(mode == 1 && y > uy){uy = y;mode++;}\n      if(mode == 2 && x < lx){lx = x;mode++;}\n      if(mode == 3 && y < ly){ly = y;mode++;}\n    }\n\n    int prelx = x,prerx = x;\n    int nowlx = x,nowrx = x;\n    sy--;\n    for(;sy >= ly;sy--){\n      if(co[nowlx][nowrx].first != INF)nowlx--;\n      if(co[nowrx][nowrx].first != INF)nowrx++;\n      for(int i  = nowlx; i <= nowrx;i++){\n        if(i < prerx) dp[i][sy] = pmax(dp[i][sy],dp[i][sy],i,sy);\n        if(i <= prerx && i >= prelx)dp[i][sy] = pmax(dp[i][sy+1], dp[i][sy],i,sy);\n        if(i > prelx)dp[i][sy] = pmax(dp[i-1][sy+1], dp[i][sy],i,sy);\n      }\n      prelx = nowlx;\n      prerx = nowrx;\n    }\n    pair<int,int> ans = make_pair(0,0);\n\n    rx =START,lx = START,uy = START,ly = START;\n    x = START,y = START,mode = 0;\n    FOR(i,1,n+1){\n      if(dp[x][y].first > ans.first)ans = dp[x][y];\n      if(dp[x][y].first == ans.first && dp[x][y].second > ans.second)ans = dp[x][y];\n    x += dx[mode];\n      y += dy[mode];\n      if(mode == 0 && x > rx){rx = x;mode++;}\n      if(mode == 1 && y > uy){uy = y;mode++;}\n      if(mode == 2 && x < lx){lx = x;mode++;}\n      if(mode == 3 && y < ly){ly = y;mode++;}\n    }\n    cout << ans.first << ' ' << ans.second << endl;\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n  Scanner sc;\n\n  class Point {\n    int x, y;\n\n    Point(int x, int y) {\n      this.x = x;\n      this.y = y;\n    }\n    \n    public int hashCode() {\n      return y * 1024 + x;\n    }\n    public boolean equals(Object o) {\n      return this.hashCode() == ((Point)o).hashCode();\n    }\n  }\n  \n  static boolean[] sieve;\n  static {\n    sieve = new boolean[1 << 20 + 1];\n    Arrays.fill( sieve, true );\n    sieve[0] = sieve[1] = false;\n    for(int i = 2; i * i <= 1 << 20; ++i ) {\n      for(int j = i * 2; j <= 1 << 20; j += i) {\n        sieve[j] = false;\n      }\n    }\n  }\n\n  boolean isPrime(int n) {\n//    boolean flag = n > 1;\n//    for ( int i = 2; i * i <= n; ++i ) {\n//      flag &= n % i != 0;\n//    }\n//    return flag;\n    return sieve[n];\n  }\n\n  void run() {\n    HashMap<Integer, Point> map = new HashMap<Integer, Point>();\n    boolean[][] prime = new boolean[1024][1024];\n    int[][] field = new int[1024][1024];\n    int x, y;\n    x = y = 1024 >> 1;\n    int len = 1;\n    int dir = 1;\n    int idx = 1;\n    prime[ y ][ x ] = isPrime( idx );\n    map.put( idx, new Point( x, y ) );\n    for ( ;idx <= 1000000; ) {\n      for ( int i = 0; i < len; ++i ) {\n        ++idx;\n        x += dir;\n        prime[ y ][ x ] = isPrime( idx );\n        field[ y ][ x ] = idx;\n        map.put( idx, new Point( x, y ) );\n      }\n      for ( int i = 0; i < len; ++i ) {\n        ++idx;\n        y -= dir;\n        prime[ y ][ x ] = isPrime( idx );\n        field[ y ][ x ] = idx;\n        map.put( idx, new Point( x, y ) );\n      }\n      ++len;\n      dir *= -1;\n    }\n//    for ( int i = 1024 / 2 - 3; i <= 1024 / 2 + 3; ++i ) {\n//      for ( int j = 1024 / 2 - 3; j <= 1024 / 2 + 3; ++j ) {\n//        System.err.print( String.format( \"%2d\", field[ i ][ j ] ) + \":\" + (prime[i][j] ? 1 : 0) + \" \" );\n//      }\n//      System.err.println();\n//    }\n    for ( ;; ) {\n      int m = ni();\n      int n = ni();\n      if ( ( m | n ) == 0 ) {\n        break;\n      }\n\n      Point p = map.get( n );\n      int[][] dp = new int[1024][1024];\n      int max = prime[ p.y ][ p.x ] ? 1 : 0;\n      int max_num = prime[ p.y ][ p.x ] ? n : 0;\n      HashSet<Point> set = new HashSet<Point>();\n      set.add( p );\n      dp[ p.y ][ p.x ] = prime[ p.y ][ p.x ] ? 1 : 0;\n      for ( ;; ) {\n        HashSet<Point> nexts = new HashSet<Point>();\n        for ( Point ite : set ) {\n          int ax = ite.x;\n          int ay = ite.y;\n          for ( int[] dd : ofs ) {\n            int nx = ax + dd[ 0 ];\n            int ny = ay + dd[ 1 ];\n            Point np = new Point( nx, ny );\n//            debug(nx, ny, field[ny][nx], field[ ny ][ nx ] <= m);\n            if ( 0 <= nx && nx < 1024 && 0 <= ny && ny < 1024 && field[ ny ][ nx ] <= m ) {\n              nexts.add( np );\n              dp[ ny ][ nx ] = Math.max( dp[ ny ][ nx ], dp[ ay ][ ax ]\n                  + ( prime[ ny ][ nx ] ? 1 : 0 ) );\n              if ( dp[ ny ][ nx ] > max ) {\n                max = dp[ ny ][ nx ];\n                max_num = field[ ny ][ nx ];\n              } else if( dp[ny][nx] == max && prime[ny][nx] ) {\n                max_num = Math.max( max_num, field[ny][nx] );\n              }\n            }\n          }\n        }\n//        debug(nexts.size());\n//        for( Point ite : nexts ) {\n//          debug(ite.x + \",\" + ite.y);\n//        }\n        if ( nexts.size() == 0 ) {\n          break;\n        }\n        set = nexts;\n      }\n\n      System.out.println( max + \" \" + max_num );\n    }\n  }\n\n  int[][] ofs = new int[][] { { -1, 1 }, { 0, 1 }, { 1, 1 } };\n\n  Main() {\n    sc = new Scanner( System.in );\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void debug(Object... os) {\n    System.err.println( Arrays.deepToString( os ) );\n  }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\tint MAX = 1002;\n\tint OFS = MAX / 2;\n\tint[][] index;\n\tHashMap<Integer, P> ind2P;\n\tboolean[] p;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tind2P = new HashMap<Integer, P>();\n\t\tindex = new int[MAX][MAX];\n\t\tp = new boolean[MAX*MAX + 1];\n\t\t\n\t\tprime(); create();\n\t\t\n\t\tfor(;;) {\n\t\t\tint m = sc.nextInt(), n = sc.nextInt();\n\t\t\tif( (m|n) == 0 ) break;\n\t\t\t\n\t\t\tint[][] dp1 = new int[MAX][MAX];\n\t\t\tint[][] dp2 = new int[MAX][MAX];\n\t\t\tfor(int[] a: dp1) fill(a, -1);\n\t\t\t\n\t\t\tP s = ind2P.get(n);\n\t\t\tdp1[s.y][s.x] = !p[n]? 1:0; dp2[s.y][s.x] = !p[n]? n:0;\n\t\t\tint max = dp1[s.y][s.x], last = dp2[s.y][s.x];\n\t\t\tfor(int y=0;y<MAX;y++) for(int x=0;x<MAX;x++) if(dp1[y][x]>=0){\n\t\t\t\tfor(int i=-1;i<=1;i++) {\n\t\t\t\t\tint sx = x+i, sy = y+1;\n\t\t\t\t\tif(out(sx, sy)) continue;\n\t\t\t\t\tint v = index[sy][sx];\n\t\t\t\t\tif( v > m ) continue;\n\t\t\t\t\tif(dp1[sy][sx] == dp1[y][x] + (!p[v]? 1: 0)) {\n\t\t\t\t\t\tdp2[sy][sx] = max(dp2[sy][sx], v);\n\t\t\t\t\t}\n\t\t\t\t\telse if(dp1[sy][sx] < dp1[y][x] + (!p[v]? 1: 0)) {\n\t\t\t\t\t\tdp1[sy][sx] = dp1[y][x] + (!p[v]? 1: 0);\n\t\t\t\t\t\tdp2[sy][sx] = !p[v]? v:dp2[y][x];\n\t\t\t\t\t}\n\t\t\t\t\tif( max == dp1[sy][sx]) {\n\t\t\t\t\t\tlast = max(last, dp2[sy][sx]);\n\t\t\t\t\t}\n\t\t\t\t\telse if(max < dp1[sy][sx]) {\n\t\t\t\t\t\tmax = dp1[sy][sx];\n\t\t\t\t\t\tlast = dp2[sy][sx];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(max + \" \" + last);\n\t\t}\n\t}\n\t\n\tboolean out(int x, int y) {\n\t\treturn x<0 || y < 0 || x >= MAX || y >= MAX;\n\t}\n\t\n\tint[] dx = {1,0,-1,0}, dy = {0,-1,0,1};\n\tvoid create() {\n\t\tint p = 1, d = 0, len = 1;\n\t\tint x = OFS-1, y = OFS;\n\t\t\n\t\tfor(;;) {\n\t\t\tfor(int cnt=0;cnt<2;cnt++) {\n\t\t\t\tfor(int l=0;l<len;l++){\n\t\t\t\t\tindex[y][x] = p;\n\t\t\t\t\tind2P.put(p++, new P(x, y));\n\t\t\t\t\tx += dx[d]; y += dy[d];\n\t\t\t\t\tif( p == MAX*MAX ) return;\n\t\t\t\t}\n\t\t\t\td = (d+1)&3;\n\t\t\t}\n\t\t\tlen++;\n\t\t}\n\t}\n\t\n\tvoid prime() {\n\t\tp[0] = p[1] = true;\n\t\tfor(int i=2;i<=MAX*MAX;i++) if(!p[i]) \n\t\t\tfor(int j=2*i;j<=MAX*MAX;j+=i) p[j] = true;\n\t}\n\t\n\tclass P {\n\t\tint x, y;\n\t\tP(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\n\tint M = 1000000;\n\tboolean[] prime = new boolean[M + 1];\n\n\tvoid run() {\n\t\tArrays.fill(prime, true);\n\t\tprime[0] = prime[1] = false;\n\t\tfor (int i = 2; i * i <= M; i++) {\n\t\t\tif (!prime[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int j = i * 2; j <= M; j += i) {\n\t\t\t\tprime[j] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (;;) {\n\t\t\tint m = sc.nextInt(); // all hall\n\t\t\tint n = sc.nextInt(); // start number\n\t\t\tif ((m | n) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint[][] field = new int[1001][1001];\n\t\t\tint[][] dp = new int[1001][1001];\n\t\t\tboolean[][] visit = new boolean[1001][1001];\n\t\t\tint x = 500;\n\t\t\tint y = 500;\n\t\t\tint right = 1;\n\t\t\tint up = 1;\n\t\t\tint left = 2;\n\t\t\tint down = 2;\n\t\t\tfield[500][500] = 1;\n\t\t\tlabel: for (int i = 2; i <= m;) {\n\t\t\t\tfor (int j = 1; j <= right; j++) {\n\t\t\t\t\tfield[y][++x] = i++;\n\t\t\t\t\tif (i > m) {\n\t\t\t\t\t\tbreak label;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 1; j <= up; j++) {\n\t\t\t\t\tfield[--y][x] = i++;\n\t\t\t\t\tif (i > m) {\n\t\t\t\t\t\tbreak label;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 1; j <= left; j++) {\n\t\t\t\t\tfield[y][--x] = i++;\n\t\t\t\t\tif (i > m) {\n\t\t\t\t\t\tbreak label;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 1; j <= down; j++) {\n\t\t\t\t\tfield[++y][x] = i++;\n\t\t\t\t\tif (i > m) {\n\t\t\t\t\t\tbreak label;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tright += 2;\n\t\t\t\tup += 2;\n\t\t\t\tleft += 2;\n\t\t\t\tdown += 2;\n\t\t\t}\n\n\t\t\tint startX = 0;\n\t\t\tint startY = 0;\n\t\t\tfor (int i = 0; i <= 1000; i++) {\n\t\t\t\tfor (int j = 0; j <= 1000; j++) {\n\t\t\t\t\tif (field[i][j] == n) {\n\t\t\t\t\t\tstartX = j;\n\t\t\t\t\t\tstartY = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvisit[startY][startX] = true;\n\t\t\tfor (int i = startY + 1; i <= 1000; i++) {\n\t\t\t\tfor (int j = 0; j <= 1000; j++) {\n\t\t\t\t\tif (j - 1 >= 0 && visit[i - 1][j - 1]) {\n\t\t\t\t\t\tvisit[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (visit[i - 1][j]) {\n\t\t\t\t\t\tvisit[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (j + 1 <= 1000 && visit[i - 1][j + 1]) {\n\t\t\t\t\t\tvisit[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ansCnt = 0;\n\t\t\tint ansNum = 0;\n\t\t\tfor (int i = startY; i <= 1000; i++) {\n\t\t\t\tfor (int j = 0; j <= 1000; j++) {\n\t\t\t\t\tif (!visit[i][j]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tif (i - 1 >= 0 && j - 1 > 0 && visit[i - 1][j - 1]) {\n\t\t\t\t\t\tcnt = Math.max(cnt, dp[i - 1][j - 1]);\n\t\t\t\t\t}\n\t\t\t\t\tif (i - 1 >= 0 && visit[i - 1][j]) {\n\t\t\t\t\t\tcnt = Math.max(cnt, dp[i - 1][j]);\n\t\t\t\t\t}\n\t\t\t\t\tif (i - 1 >= 0 && j + 1 <= 1000 && visit[i - 1][j + 1]) {\n\t\t\t\t\t\tcnt = Math.max(cnt, dp[i - 1][j + 1]);\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j] = cnt + (prime[field[i][j]] ? 1 : 0);\n\t\t\t\t\tif (ansCnt <= dp[i][j]) {\n\t\t\t\t\t\tansCnt = dp[i][j];\n\t\t\t\t\t\tif (prime[field[i][j]]) {\n\t\t\t\t\t\t\tif (ansNum < field[i][j]) {\n\t\t\t\t\t\t\t\tansNum = field[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ansCnt + \" \" + ansNum);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(int[][] array) {\n\t\tfor (int i = 495; i < 505; i++) {\n\t\t\tfor (int j = 495; j < 505; j++) {\n\t\t\t\tSystem.out.printf(\"%02d \", array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[][][] field=new int[1200][1200][2];\n\tstatic int SIZE=1200;\n\tstatic boolean[] isPrime=new boolean[1000009];\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tmakeField();\n\t\tmakePrimeTable();\n\t\tfor(;;){\n\t\t\t\n\t\t\tint num=sc.nextInt();\n\t\t\tint start=sc.nextInt();\n\t\t\tif(start+num==0)break;\n\t\t\tint x=0,y=0;\n\t\t\tlabel:for(int i=0;i<SIZE;i++){\n\t\t\t\tfor(int j=0;j<SIZE;j++){\n\t\t\t\t\tif(field[i][j][0]==start){\n\t\t\t\t\t\tx=j;\n\t\t\t\t\t\ty=i;\n\t\t\t\t\t\tbreak label;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQueue<int[]>q=new LinkedList<int[]>();\n\t\t\tint v=0;\n\t\t\tif(isPrime[field[y][x][0]])v=1;\n\t\t\tq.add(new int[]{y,x,v});\n\t\t\tfield[y][x][1]=v;\n\t\t\twhile(q.isEmpty()==false){\n\t\t\t\tint[]a=q.poll();\n\t\t\t\ty=a[0];x=a[1];\n\t\t\t\tv=a[2];\n//\t\t\t\tSystem.out.println(field[y][x][1]+\" \"+v);\n\t\t\t\tif(field[y][x][1]>v)continue;\n\t\t\t\ty++;\n\t\t\t\tfor(int i=-1;i<=1;i++){\n\t\t\t\t\tint xx = x+i;\n\t\t\t\t\tif(field[y][xx][0]>num)continue;\n\t\t\t\t\tif(isPrime[field[y][xx][0]])v++;\n\t\t\t\t\tif(field[y][xx][1]<v){\n\t\t\t\t\t\tfield[y][xx][1]=v;\n\t\t\t\t\t\tq.add(new int[]{y,xx,field[y][xx][1]});\n\t\t\t\t\t}\n\t\t\t\t\tif(isPrime[field[y][xx][0]])v--;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t// down left\n\t\t\t\ty++;\n\t\t\t\tx--;\n\t\t\t\tSystem.out.println(field[y][x][0]);\n\t\t\t\tif(field[y][x][0]<=num&&field[y][x][1]<v){\n\t\t\t\t\tfield[y][x][1]=v;\n\t\t\t\t\tif(isPrime[field[y][x][0]])field[y][x][1]++;\n\t\t\t\t\tq.add(new int[]{y,x,field[y][x][1]});\n\t\t\t\t}\n\t\t\t\t// down\n\t\t\t\tx++;\n\t\t\t\tSystem.out.println(field[y][x][0]);\n\t\t\t\tif(field[y][x][0]<=num&&field[y][x][1]<v){\n\t\t\t\t\tfield[y][x][1]=v;\n\t\t\t\t\tif(isPrime[field[y][x][0]])field[y][x][1]++;\n\t\t\t\t\tq.add(new int[]{y,x,field[y][x][1]});\n\t\t\t\t}\n\t\t\t\t// down right\n\t\t\t\tx++;\n\t\t\t\tSystem.out.println(field[y][x][0]);\n\t\t\t\tif(field[y][x][0]<=num&&field[y][x][1]<v){\n\t\t\t\t\tfield[y][x][1]=v;\n\t\t\t\t\tif(isPrime[field[y][x][0]])field[y][x][1]++;\n\t\t\t\t\tq.add(new int[]{y,x,field[y][x][1]});\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\n\t\t\tint max=-1;\n\t\t\tint ans=-1;\n\t\t\tfor(int i=0;i<SIZE;i++){\n\t\t\t\tfor(int j=0;j<SIZE;j++){\n\t\t\t\t\tif(field[i][j][0]>num)continue;\n\t\t\t\t\tif(isPrime[field[i][j][0]]==false)continue;\n\t\t\t\t\tif(max<field[i][j][1]){\n\t\t\t\t\t\tmax=field[i][j][1];\n\t\t\t\t\t\tans=field[i][j][0];\n\t\t\t\t\t}\n\t\t\t\t\telse if(max==field[i][j][1]){\n\t\t\t\t\t\tans=Math.max(field[i][j][0],ans);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max==-1){\n\t\t\t\tSystem.out.println(\"0 0\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tSystem.out.println(max+\" \"+ans);\n\t\t\tfor(int i=0;i<SIZE;i++){\n\t\t\t\tfor(int j=0;j<SIZE;j++){\n\t\t\t\t\tfield[i][j][1]=-2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic void makePrimeTable(){\n\t\tArrays.fill(isPrime, true);\n\t\tisPrime[0]=isPrime[1]=false;\n\t\tfor(int i=2;i*i<=isPrime.length;i++){\n\t\t\tif(isPrime[i]){\n\t\t\t\tfor(int j=i+i;j<isPrime.length;j+=i)isPrime[j]=false;\n\t\t\t}\n\t\t}\n\t}\n\tstatic void makeField(){\n\t\tint x = field.length/2;\n\t\tint y = field.length/2;\n\t\tint num=1;\n\t\tfor(int i=0;i<SIZE;i++){\n\t\t\tfor(int j=0;j<SIZE;j++){\n\t\t\t\tfield[i][j][0]=1<<29;\n\t\t\t\tfield[i][j][1]=-2;\n\t\t\t}\n\t\t}\n\t\tfield[x][y][0]=num++;\n\t\tfor(int n=1;;n+=2){\n\t\t\tif(num>1100000)break;\n\t\t\t// right\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tx++;\n\t\t\t\tfield[y][x][0]=num++;\n\t\t\t}\n\t\t\t// up\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\ty--;\n\t\t\t\tfield[y][x][0]=num++;\n\t\t\t}\n\t\t\t// left\n\t\t\tfor(int i=0;i<n+1;i++){\n\t\t\t\t\n\t\t\t\tx--;\n\t\t\t\tfield[y][x][0]=num++;\n\t\t\t}\n\t\t\t// down\n\t\t\tfor(int i=0;i<n+1;i++){\n\t\t\t\ty++;\n\t\t\t\tfield[y][x][0]=num++;\n\t\t\t}\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n// Prime Caves\n// 2013/08/14\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint m, start;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tm=sc.nextInt();\n\t\t\tstart=sc.nextInt();\n\t\t\tif((m|start)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tint[] isPrime;\n\n\tvoid solve(){\n\t\tint M=(int)1e6+100;\n\t\tif(isPrime==null){\n\t\t\tisPrime=new int[M];\n\t\t\tfill(isPrime, 1);\n\t\t\tisPrime[0]=isPrime[1]=0;\n\t\t\tfor(int j=0; j<M; j++){\n\t\t\t\tif(isPrime[j]==0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i=j*2; i<M; i+=j){\n\t\t\t\t\tisPrime[i]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint n=1900;\n\t\tint[][] dp=new int[n][n], index=new int[n][n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfill(dp[i], -1);\n\t\t}\n\t\tint[] _=spiralN2XY(start);\n\t\tint x0=_[0]-n/2, y0=_[1];\n\t\tdp[0][n/2]=isPrime[start];\n\t\tindex[0][n/2]=start*isPrime[start];\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(dp[j][i]<0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int k=-1; k<=1; k++){\n\t\t\t\t\tif(j+1>=n||i+k<0||i+k>=n){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint val=spiralXY2N(x0+i+k, y0+j+1);\n\t\t\t\t\tif(val>m){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[j][i]+isPrime[val]>dp[j+1][i+k]){\n\t\t\t\t\t\tdp[j+1][i+k]=dp[j][i]+isPrime[val];\n\t\t\t\t\t\tindex[j+1][i+k]=isPrime[val]==1?val:index[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint maxVal=0, maxIndex=0;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(dp[j][i]>maxVal||(dp[j][i]==maxVal&&index[j][i]>maxIndex)){\n\t\t\t\t\tmaxVal=dp[j][i];\n\t\t\t\t\tmaxIndex=index[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln(maxVal+\" \"+maxIndex);\n\t}\n\n\tint[] spiralN2XY(int n){\n\t\tint m=(int)sqrt(n-1)+1;\n\t\tint x=m/2-min(m*m-n, m-1), y=m/2-max(m*m-m+1-n, 0);\n\t\tif(m%2==0){\n\t\t\tx=-x+1;\n\t\t\ty=-y;\n\t\t}\n\t\treturn new int[]{x, y};\n\t}\n\n\tint spiralXY2N(int x, int y){\n\t\tint d=max(abs(x), abs(y));\n\t\tif(y>=x)\n\t\t\treturn (2*d+1)*(2*d+1)-abs(d-x)-abs(d-y);\n\t\telse\n\t\t\treturn (2*d)*(2*d)-abs(-d+1-x)-abs(-d-y);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  Scanner sc;\n\n  int n, m;\n  int MAX = 1000;\n  int ofs = MAX / 2;\n  int[][] dp, cave, pr;\n  int LIM = 1000000;\n\n  int[] tx = new int[] { 1, 0, -1, 0 };\n  int[] ty = new int[] { 0, -1, 0, 1 };\n\n  void run() {\n    while (true) {\n      m = ni();\n      n = ni();\n      if ( n == 0 && m == 0 )\n        break;\n\n      dp = new int[MAX + 1][MAX + 1];\n      pr = new int[MAX + 1][MAX + 1];\n      cave = new int[MAX + 1][MAX + 1];\n      int x = 0;\n      int y = 0;\n      int stx = ofs;\n      int sty = ofs;\n      int num = 1;\n      cave[ ofs ][ ofs ] = 1;\n      num++;\n      int t = 0;\n      while (num <= m) {\n        int an = t / 2 + 1;\n        for ( int i = 1; i <= an; i++ ) {\n          int tmpx = x + tx[ t % 4 ] * i + ofs;\n          int tmpy = y + ty[ t % 4 ] * i + ofs;\n          cave[ tmpy ][ tmpx ] = num;\n          if ( num == n ) {\n            stx = tmpx;\n            sty = tmpy;\n          }\n\n          if ( isPrime( num ) ) {\n            pr[ tmpy ][ tmpx ]++;\n            // cave[ tmpy ][ tmpx ] *= -1;\n          }\n          num++;\n          if ( num > m ) {\n            break;\n          }\n        }\n        x += tx[ t % 4 ] * an;\n        y += ty[ t % 4 ] * an;\n        t++;\n      }\n\n      // for ( int i = 0; i < cave.length; ++i ) {\n      // for ( int j = 0; j < cave[ 0 ].length; ++j ) {\n      // if ( j > 0 ) {\n      // System.out.print( \" \" );\n      // }\n      // System.out.print( String.format( \"%4d\", cave[ i ][ j ] ) );\n      // }\n      // System.out.println();\n      // }\n      int maxc = 0;\n      int maxn = 0;\n      dp[ sty ][ stx ] = pr[ sty ][ stx ];\n      for ( int i = sty; i < MAX; i++ ) {\n        int d = i - sty;\n        int start = stx - d;\n        start = start < 0 ? 0 : start;\n\n        int end = stx + d;\n        end = ( end >= ( MAX + 1 ) ) ? MAX : end;\n\n        for ( int j = start; j <= end; j++ ) {\n\n          // int dp1 = 0;\n          // if(j >= 1)dp1 = dp[i-1][j-1];\n          // int dp2 = dp[i-1][j];\n          // int dp3 = 0;\n          // if(j <MAX)dp3 = dp[i-1][j+1];\n          // dp[i][j] += Math.max( Math.max(dp1, dp2), dp3 );\n\n          for ( int l = -1; l <= 1; ++l ) {\n            if ( j + l < 0 )\n              continue;\n            if ( j + l > MAX )\n              continue;\n            dp[ i + 1 ][ j + l ] = Math.max( dp[ i + 1 ][ j + l ], dp[ i ][ j ]\n                + pr[ i + 1 ][ j + l ] );\n            if ( maxc < dp[ i ][ j ] ) {\n              maxc = dp[ i ][ j ];\n              maxn = cave[ i ][ j ];\n            } else if ( maxc == dp[ i ][ j ] ) {\n              if ( maxn < cave[ i ][ j ] && pr[ i ][ j ] == 1 ) {\n                maxn = cave[ i ][ j ];\n              }\n            }\n          }\n        }\n      }\n      System.out.printf( \"%d %d\\n\", maxc, maxn );\n    }\n\n  }\n\n  boolean isPrime(int n) {\n    if ( n == 2 )\n      return true;\n    if ( n % 2 == 0 )\n      return false;\n    for ( int i = 3; i * i <= n; i += 2 ) {\n      if ( n % i == 0 )\n        return false;\n    }\n    return true;\n  }\n\n  Main() {\n    sc = new Scanner( System.in );\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void debug(Object... os) {\n    System.err.println( Arrays.deepToString( os ) );\n  }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n    static int[][][] caves = new int[2][1000][1000];\n    static boolean[] primes = new boolean[1000000];\n    static int[][] dp = new int[2][1000];\n    static int[] vx = {1, 0, -1, 0};\n    static int[] vy = {0, -1, 0, 1};\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        MakeCaves();\n        while (true){\n            int m = sc.nextInt();\n            int n = sc.nextInt();\n            if(m==0 && n==0) break;\n\n            int x = -1, y = -1;\n            for (int i = 0; i < 1000; i++) {\n                for (int j = 0; j < 1000; j++) {\n                    if(caves[0][i][j]==n){\n                        x = j; y = i;\n                        break;\n                    }\n                }\n                if(x!=-1) break;\n            }\n            for (int i = 0; i <1000 ; i++) {\n                dp[0][i] = dp[1][i] = 0;\n            }\n\n            int max = 0, dy = 0, mx = x, my = y;\n            while (y+dy<1000){\n                for (int i = (x-dy>=0)?x-dy:0; i <= ((x+dy<1000)?x+dy:999); i++) {\n                    if(caves[0][y+dy][i]>m) continue;\n                    dp[dy%2][i] = dp[(dy+1)%2][i] + caves[1][y+dy][i];\n                    if(i>0&&dp[(dy+1)%2][i-1]!=0){\n                        dp[dy%2][i] = Math.max(dp[dy%2][i], dp[(dy+1)%2][i-1] + caves[1][y+dy][i]);\n                    }\n                    if(i<999&&dp[(dy+1)%2][i+1]!=0){\n                        dp[dy%2][i] = Math.max(dp[dy%2][i], dp[(dy+1)%2][i+1] + caves[1][y+dy][i]);\n                    }\n                    if(max<dp[dy%2][i]){\n                        max = dp[dy%2][i];\n                        mx = i; my = y + dy;\n                    }else if(max==dp[dy%2][i] && caves[1][y+dy][i]==1){\n                        if(caves[0][my][mx]<caves[0][y+dy][i]){\n                            mx = i; my = y + dy;\n                        }\n                    }\n                }\n                dy++;\n            }\n            System.out.println(max+\" \"+((max!=0)?caves[0][my][mx]:0));\n        }\n    }\n\n    static void FindPrimes() {\n        primes[0] = true;\n        for (int i = 1; i < 500000; i++) {\n            if(primes[i]) continue;\n            int j = (i+1)*2;\n            while (j<1000000){\n                primes[j-1] = true;\n                j += i+1;\n            }\n        }\n    }\n\n    static void MakeCaves() {\n        int n = 2, x = 499, y = 500;\n        FindPrimes();\n        caves[0][y][x] = 1;\n        caves[1][y][x] = 0;\n\n        for (int i = 0; i < 2000; i++) {\n            for (int j = 0; j <= i/2; j++, n++) {\n                if(n==1000001) break;\n                x+=vx[i%4]; y+=vy[i%4];\n                caves[0][y][x] = n;\n                caves[1][y][x] = (primes[n-1])?0:1;\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n \npublic class Main{\n\tprivate boolean[] prime;\n\t\n\tpublic void setPrime(int m){\n\t\tprime = new boolean[m + 1];\n\t\tArrays.fill(prime, true);\n\t\tfor(int i = 2; i * i <= m; i++){\n\t\t\tif(prime[i]){\n\t\t\t\tfor(int j = i * 2; j <= m; j += i){\n\t\t\t\t\tprime[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint[][] map;\n\tint[][] dp;\n\tint[][] maxP;\n\t\n\tpublic void setMap(int m){\n\t\tmap = new int[m][m];\n\t\tint[] DC = {1, 0, -1,0};\n\t\tint[] DR = {0,-1,  0,1};\n\t\t\n\t\tint pr = m / 2;\n\t\tint pc = (m - 1) / 2;\n\t\tint muki = 0;\n\t\tint dc = 1;\n\t\tint dr = 0;\n\t\tmap[pr][pc] = 1;\n\t\tfor(int i = 2; i <= m * m; i++){\n\t\t\tpr += dr;\n\t\t\tpc += dc;\n\t\t\tmap[pr][pc] = i;\n\t\t\tint mm = (muki + 1) % 4;\n\t\t\tint nr = DR[mm];\n\t\t\tint nc = DC[mm];\n\t\t\tif(map[pr + nr][pc + nc] == 0){\n\t\t\t\tdr = nr;\n\t\t\t\tdc = nc;\n\t\t\t\tmuki = mm;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void solve(){\n\t\tsetPrime(1000000);\n\t\tsetMap(1005);\n\t\tdp = new int[1005][1005];\n\t\tmaxP = new int[1005][1005];\n\t\twhile(true){\n\t\t\tint M = nextInt();\n\t\t\tint N = nextInt();\n\t\t\tif(M == 0) break;\n\t\t\tfor(int i = 0; i < dp.length; i++){\n\t\t\t\tArrays.fill(dp[i], -1);\n\t\t\t\tArrays.fill(maxP[i], 0);\n\t\t\t}\n\t\t\tint pr = 0;\n\t\t\tint pc = 0;\n\t\t\tfor(int i = 0; i < map.length; i++){\n\t\t\t\tfor(int j = 0; j < map[i].length; j++){\n\t\t\t\t\tif(map[i][j] == N){\n\t\t\t\t\t\tpr = i;\n\t\t\t\t\t\tpc = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trecur(pr, pc, M);\n\t\t\tout.println(dp[pr][pc] + \" \" + maxP[pr][pc]);\n\t\t}\n\t}\n\t\n\tpublic int recur(int r, int c, int M){\n\t\tif(map[r][c] > M){\n\t\t\treturn 0;\n\t\t}\n\t\tif(dp[r][c] >= 0){\n\t\t\treturn dp[r][c];\n\t\t}\n\t\tint ans = recur(r + 1, c - 1, M);\n\t\tmaxP[r][c] = maxP[r + 1][c - 1];\n\t\tint a2 = recur(r + 1, c, M);\n\t\tif(ans < a2){\n\t\t\tans = a2;\n\t\t\tmaxP[r][c] = maxP[r + 1][c];\n\t\t}\n\t\tint a3 = recur(r + 1, c + 1, M);\n\t\tif(ans < a3){\n\t\t\tans = a3;\n\t\t\tmaxP[r][c] = maxP[r + 1][c + 1];\n\t\t}\n\t\tif(prime[map[r][c]]){\n\t\t\tans++;\n\t\t\tif(maxP[r][c] == 0){\n\t\t\t\tmaxP[r][c] = map[r][c];\n\t\t\t}\n\t\t}\n\t\treturn dp[r][c] = ans;\n\t}\n\t\n\t\n\tprivate static PrintWriter out;\n\tpublic static void main(String[] args){\n\t\tout = new PrintWriter(System.out);\n\t\tnew Main().solve();\n\t\tout.flush();\n\t}\n\t\n\t\n\t\n\tpublic static int nextInt(){\n\t\tint num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif(str.charAt(0) == '-'){\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor(;i < len; i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(!('0' <= c && c <= '9')) throw new RuntimeException();\n\t\t\tnum = num * 10 + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\t\n\tpublic static long nextLong(){\n\t\tlong num = 0;\n\t\tString str = next();\n\t\tboolean minus = false;\n\t\tint i = 0;\n\t\tif(str.charAt(0) == '-'){\n\t\t\tminus = true;\n\t\t\ti++;\n\t\t}\n\t\tint len = str.length();\n\t\tfor(;i < len; i++){\n\t\t\tchar c = str.charAt(i);\n\t\t\tif(!('0' <= c && c <= '9')) throw new RuntimeException();\n\t\t\tnum = num * 10l + (c - '0');\n\t\t}\n\t\treturn minus ? -num : num;\n\t}\n\tpublic static String next(){\n\t\tint c;\n\t\twhile(!isAlNum(c = read())){}\n\t\tStringBuilder build = new StringBuilder();\n\t\tbuild.append((char)c);\n\t\twhile(isAlNum(c = read())){\n\t\t\tbuild.append((char)c);\n\t\t}\n\t\treturn build.toString();\n\t}\n\t\n\t\n\tprivate static byte[] inputBuffer = new byte[1024];\n\tprivate static int bufferLength = 0;\n\tprivate static int bufferIndex = 0;\n\tprivate static int read(){\n\t\tif(bufferLength < 0) throw new RuntimeException();\n\t\tif(bufferIndex >= bufferLength){\n\t\t\ttry{\n\t\t\t\tbufferLength = System.in.read(inputBuffer);\n\t\t\t\tbufferIndex = 0;\n\t\t\t}catch(IOException e){\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif(bufferLength <= 0) return (bufferLength = -1);\n\t\t}\n\t\treturn inputBuffer[bufferIndex++];\n\t}\n\t\n\tprivate static boolean isAlNum(int c){\n\t\treturn '!' <= c && c <= '~';\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\tnew Main().run();\n\t}\n\n\tboolean isPrime[];\n\n\tfinal int MAX = 1000 * 1000;\n\tint MAX_X = 1102;\n\tint MAX_Y = 1102;\n\tint[][] caves;\n\tint[][] dp;\n\n\tvoid init() {\n\n\t\tisPrime = new boolean[MAX + 1];\n\t\tArrays.fill(isPrime, true);\n\t\tisPrime[0] = isPrime[1] = false;\n\t\tfor (int i = 2; i * i <= MAX; i++) {\n\t\t\tif (isPrime[i]) {\n\t\t\t\tfor (int j = i * 2; j <= MAX; j += i) {\n\t\t\t\t\tisPrime[j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcaves = new int[MAX_Y + 1][MAX_X + 1];\n\t\tdp = new int[MAX_Y + 1][MAX_X + 1];\n\t\tfor (int i = 0; i <= MAX_Y; i++) {\n\t\t\tArrays.fill(dp[i], -1);\n\t\t}\n\t\tint x = MAX_X / 2;\n\t\tint y = MAX_Y / 2;\n\t\tint dx[] = new int[] { 1, 0, -1, 0 };\n\t\tint dy[] = new int[] { 0, -1, 0, 1 };\n\t\tint idx = 1;\n\t\tint t = 0;\n\t\tfor (int step = 1; idx <= MAX; step++) {\n\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\tfor (int j = 0; j < step && idx <= MAX; j++) {\n\t\t\t\t\tcaves[y][x] = idx;\n\t\t\t\t\tx = x + dx[t];\n\t\t\t\t\ty = y + dy[t];\n\t\t\t\t\tidx++;\n\t\t\t\t}\n\t\t\t\tt++;\n\t\t\t\tt %= 4;\n\t\t\t}\n\t\t}\n\t}\n\n\tint m = 0;\n\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tinit();\n\t\t\tm = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tint sx, sy;\n\t\t\tsx = sy = 0;\n\t\t\tfor (int i = 0; i <= MAX_Y; i++) {\n\t\t\t\tfor (int j = 0; j <= MAX_X; j++) {\n\t\t\t\t\tif (caves[i][j] == n) {\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = solve(sx, sy);\n\t\t\tint x = sx;\n\t\t\tint y = sy;\n\t\t\tint last = -1;\n\t\t\tint dx[] = new int[] { -1, 0, 1 };\n\t\t\tint dy[] = new int[] { 1, 1, 1 };\n\t\t\twhile (true) {\n\t\t\t\tif (isPrime[caves[y][x]])\n\t\t\t\t\tlast = caves[y][x];\n\t\t\t\tint max = 0;\n\t\t\t\tint max_x = 0;\n\t\t\t\tint max_y = 0;\n\t\t\t\tint max_idx = 0;\n\t\t\t\tboolean end = true;\n\t\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\t\tint nx = x + dx[i];\n\t\t\t\t\tint ny = y + dy[i];\n\t\t\t\t\tif (MAX_X < nx || MAX_Y < ny || caves[ny][nx] > m\n\t\t\t\t\t\t\t|| caves[ny][nx] == 0 || dp[ny][nx] < 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tend = false;\n\t\t\t\t\tif (max < dp[ny][nx]) {\n\t\t\t\t\t\tmax = dp[ny][nx];\n\t\t\t\t\t\tmax_x = nx;\n\t\t\t\t\t\tmax_y = ny;\n\t\t\t\t\t\tmax_idx = caves[ny][nx];\n\t\t\t\t\t} else if (max == dp[ny][nx]) {\n\t\t\t\t\t\tif (max_idx < caves[ny][nx]) {\n\t\t\t\t\t\t\tmax = dp[ny][nx];\n\t\t\t\t\t\t\tmax_x = nx;\n\t\t\t\t\t\t\tmax_y = ny;\n\t\t\t\t\t\t\tmax_idx = caves[ny][nx];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx = max_x;\n\t\t\t\ty = max_y;\n\t\t\t\tif (end)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (last >= 0) {\n\t\t\t\tSystem.out.println(cnt + \" \" + last);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(0 + \" \" + 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tint solve(int x, int y) {\n\t\tif (dp[y][x] >= 0)\n\t\t\treturn dp[y][x];\n\t\tint res = 0;\n\t\tif (MAX_X < x || MAX_Y < y || caves[y][x] > m || caves[y][x] == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (isPrime[caves[y][x]]) {\n\t\t\tres += 1;\n\t\t}\n\t\tint dx[] = { -1, 0, 1 };\n\t\tint dy[] = { 1, 1, 1 };\n\t\tint max = 0;\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\n\t\t\tmax = Math.max(max, solve(nx, ny));\n\t\t}\n\t\tres += max;\n\t\treturn dp[y][x] = res;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n// Prime Caves\n// 2013/08/14\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint m, start;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tm=sc.nextInt();\n\t\t\tstart=sc.nextInt();\n\t\t\tif((m|start)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tint[] isPrime;\n\n\tvoid solve(){\n\t\tint M=(int)1e6+100;\n\t\tif(isPrime==null){\n\t\t\tisPrime=new int[M];\n\t\t\tfill(isPrime, 1);\n\t\t\tisPrime[0]=isPrime[1]=0;\n\t\t\tfor(int j=0; j<M; j++){\n\t\t\t\tif(isPrime[j]==0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i=j*2; i<M; i+=j){\n\t\t\t\t\tisPrime[i]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint n=2000;\n\t\tint[][] dp=new int[n][n], index=new int[n][n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfill(dp[i], -1);\n\t\t}\n\t\tint[] _=spiralN2XY(start);\n\t\tint x0=_[0]-n/2, y0=_[1];\n\t\tdp[0][n/2]=isPrime[start];\n\t\tindex[0][n/2]=start*isPrime[start];\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(dp[j][i]<0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int k=-1; k<=1; k++){\n\t\t\t\t\tif(j+1>=n||i+k<0||i+k>=n){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint val=spiralXY2N(x0+i+k, y0+j+1);\n\t\t\t\t\tif(val>m){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[j][i]+isPrime[val]>dp[j+1][i+k]){\n\t\t\t\t\t\tdp[j+1][i+k]=dp[j][i]+isPrime[val];\n\t\t\t\t\t\tindex[j+1][i+k]=isPrime[val]==1?val:index[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint maxVal=0, maxIndex=0;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(dp[j][i]>maxVal||(dp[j][i]==maxVal&&index[j][i]>maxIndex)){\n\t\t\t\t\tmaxVal=dp[j][i];\n\t\t\t\t\tmaxIndex=index[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln(maxVal+\" \"+maxIndex);\n\t}\n\n\tint[] spiralN2XY(int n){\n\t\tint m=(int)sqrt(n-1)+1;\n\t\tint x=m/2-min(m*m-n, m-1), y=m/2-max(m*m-m+1-n, 0);\n\t\tif(m%2==0){\n\t\t\tx=-x+1;\n\t\t\ty=-y;\n\t\t}\n\t\treturn new int[]{x, y};\n\t}\n\n\tint spiralXY2N(int x, int y){\n\t\tint d=max(abs(x), abs(y));\n\t\tif(y>=x)\n\t\t\treturn (2*d+1)*(2*d+1)-abs(d-x)-abs(d-y);\n\t\telse\n\t\t\treturn (2*d)*(2*d)-abs(-d+1-x)-abs(-d-y);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n// Prime Caves\n// 2013/08/14\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint m, start;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tm=sc.nextInt();\n\t\t\tstart=sc.nextInt();\n\t\t\tif((m|start)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tbyte[] isPrime;\n\n\tvoid solve(){\n\t\tint M=(int)1e6+100;\n\t\tif(isPrime==null){\n\t\t\tisPrime=new byte[M];\n\t\t\tfill(isPrime, (byte)1);\n\t\t\tisPrime[0]=isPrime[1]=0;\n\t\t\tfor(int j=0; j<M; j++){\n\t\t\t\tif(isPrime[j]==0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i=j*2; i<M; i+=j){\n\t\t\t\t\tisPrime[i]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint n=2000;\n\t\tint[][] dp=new int[n][n], index=new int[n][n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfill(dp[i], -1);\n\t\t}\n\t\tint[] _=spiralN2XY(start);\n\t\tint x0=_[0]-n/2, y0=_[1];\n\t\tdp[0][n/2]=isPrime[start];\n\t\tindex[0][n/2]=start*isPrime[start];\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(dp[j][i]<0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int k=-1; k<=1; k++){\n\t\t\t\t\tif(j+1>=n||i+k<0||i+k>=n){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint val=spiralXY2N(x0+i+k, y0+j+1);\n\t\t\t\t\tif(val>m){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[j][i]+isPrime[val]>dp[j+1][i+k]){\n\t\t\t\t\t\tdp[j+1][i+k]=dp[j][i]+isPrime[val];\n\t\t\t\t\t\tindex[j+1][i+k]=isPrime[val]==1?val:index[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint maxVal=0, maxIndex=0;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(dp[j][i]>maxVal||(dp[j][i]==maxVal&&index[j][i]>maxIndex)){\n\t\t\t\t\tmaxVal=dp[j][i];\n\t\t\t\t\tmaxIndex=index[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln(maxVal+\" \"+maxIndex);\n\t}\n\n\tint[] spiralN2XY(int n){\n\t\tint m=(int)sqrt(n-1)+1;\n\t\tint x=m/2-min(m*m-n, m-1), y=m/2-max(m*m-m+1-n, 0);\n\t\tif(m%2==0){\n\t\t\tx=-x+1;\n\t\t\ty=-y;\n\t\t}\n\t\treturn new int[]{x, y};\n\t}\n\n\tint spiralXY2N(int x, int y){\n\t\tint d=max(abs(x), abs(y));\n\t\tif(y>=x)\n\t\t\treturn (2*d+1)*(2*d+1)-abs(d-x)-abs(d-y);\n\t\telse\n\t\t\treturn (2*d)*(2*d)-abs(-d+1-x)-abs(-d-y);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n\tstatic final int INF = 2 << 28;\n\tstatic final long INF_L = 2L << 60;\n\tstatic final int  MOD = 1000000007;\n\tstatic final long MOD_L = 1000000007L;\n\tstatic final int[] vx_4 = {1,0,-1,0};\n\tstatic final int[] vy_4 = {0,-1,0,1};\n\tstatic final int[] vx_5 = {1,0,-1,0,0};\n\tstatic final int[] vy_5 = {0,1,0,-1,0};\n\tstatic final int[] vx_8 = {1,1,1,0,0,-1,-1,-1};\n\tstatic final int[] vy_8 = {1,0,-1,1,-1,1,0,-1};\n\tstatic final int[] vx_9 = {1,1,1,0,0,0,-1,-1,-1};\n\tstatic final int[] vy_9 = {1,0,-1,1,0,-1,1,0,-1};\n\t\n\tstatic char[] check;\n\tstatic int idx;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tArrayList<Integer> primeList = new ArrayList<Integer>();\n\t\tboolean[] isntPrime = new boolean[1000001];\n\t\tint[][] map = new int[2000][2000];\n\t\tboolean[][] isPrime = new boolean[2000][2000];\n\t\tprimeList.add(2);\n\t\tfor(int i = 3; i < 1000001; i += 2) {\n\t\t\tif(!isntPrime[i]) {\n\t\t\t\tprimeList.add(i);\n\t\t\t\tfor(int j = i + i; j < 1000001; j += i) {\n\t\t\t\t\tisntPrime[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint d = -1;\n\t\tint tx = 1000;\n\t\tint ty = 1000;\n\t\tint pid = 0;\n\t\tfor(int i = 1; i < 1000001; i++) {\n\t\t\tmap[ty][tx] = i;\n\t\t\tif(pid < primeList.size() && primeList.get(pid) == i) {\n\t\t\t\tisPrime[ty][tx] = true;\n\t\t\t\tpid++;\n\t\t\t}\n\t\t\tint lx = vx_4[(d+1)%4] + tx;\n\t\t\tint ly = vy_4[(d+1)%4] + ty;\n\t\t\tif(map[ly][lx] == 0) {\n\t\t\t\td++;\n\t\t\t\ttx = lx;\n\t\t\t\tty = ly;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttx = vx_4[d%4] + tx;\n\t\t\t\tty = vy_4[d%4] + ty;\n\t\t\t}\n\t\t}\n\t\twhile(true) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(m == 0 && n == 0) break;\n\t\t\tint sx = 0;\n\t\t\tint sy = 0;\n\t\t\tIN:for(int i = 0; i < map.length; i++) {\n\t\t\t\tfor(int j = 0; j < map[i].length; j++) {\n\t\t\t\t\tif(map[i][j] == n) {\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tbreak IN;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint maxAns = -1;\n\t\t\tint outAns = -1;\n\t\t\tint[][] dpA = new int[map.length+1][map[0].length];\n\t\t\tint[][] dpB = new int[map.length+1][map[0].length];\n\t\t\tfor(int i = 0; i < dpA.length; i++) Arrays.fill(dpA[i], -1);\n\t\t\tif(isPrime[sy][sx]) {\n\t\t\t\tdpA[sy][sx] = 1;\n\t\t\t\tdpB[sy][sx] = n;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdpA[sy][sx] = 0;\n\t\t\t\tdpB[sy][sx] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < map.length; i++) {\n\t\t\t\tfor(int j = 0; j < map[0].length; j++) {\n\t\t\t\t\t\n\t\t\t\t\tif(dpA[i][j] == -1) continue;\n\t\t\t\t\tfor(int k = -1; k <= 1; k++) {\n\t\t\t\t\t\tint tX = j + k;\n\t\t\t\t\t\tif(tX < 0 || tX >= map[0].length) continue;\n\t\t\t\t\t\tif(i + 1 >= map.length || map[i+1][tX] > m || map[i+1][tX] == 0) {\n\t\t\t\t\t\t\tif(maxAns < dpA[i][j] || (maxAns == dpA[i][j] && outAns < dpB[i][j])) { \n\t\t\t\t\t\t\t\tmaxAns = dpA[i][j];\n\t\t\t\t\t\t\t\toutAns = dpB[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif(isPrime[i+1][tX]) {\n\t\t\t\t\t\t\t\tint nA = dpA[i][j] + 1;\n\t\t\t\t\t\t\t\tint nB = map[i+1][tX];\n\t\t\t\t\t\t\t\tif(dpA[i+1][tX] < nA || dpA[i+1][tX] == nA && dpB[i+1][tX] < nB) {\n\t\t\t\t\t\t\t\t\tdpA[i+1][tX] = nA;\n\t\t\t\t\t\t\t\t\tdpB[i+1][tX] = nB;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tint nA = dpA[i][j];\n\t\t\t\t\t\t\t\tint nB = dpB[i][j];\n\t\t\t\t\t\t\t\tif(dpA[i+1][tX] < nA || dpA[i+1][tX] == nA && dpB[i+1][tX] < nB) {\n\t\t\t\t\t\t\t\t\tdpA[i+1][tX] = nA;\n\t\t\t\t\t\t\t\t\tdpB[i+1][tX] = nB;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(maxAns == 0) outAns = 0;\n\t\t\tSystem.out.println(maxAns + \" \" + outAns);\n\t\t\t\n\t\t}\n\t}\n\n}\n\n\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n    \tif (!hasNext()) throw new NoSuchElementException();\n        int n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}"
  },
  {
    "language": "Ruby",
    "code": "#!/bin/ruby\nprime=[true]*1000001\nprime[0..1]=[false]*2\n(2..1000000).each do |i|\n  if prime[i] then\n    j=i*2\n    while j<=1000000\n      prime[j]=false\n      j+=i\n    end\n  end\nend\ng=Array.new(1001){Array.new(1001,1e9)}\nx,y=500,500\ndy=[-1,0,1,0]\ndx=[0,1,0,-1]\nd=1\n(1..1000000).each do |i|\n  g[y][x]=i\n  x+=dx[d]\n  y+=dy[d]\n  nx=x+dx[(d+3)%4]\n  ny=y+dy[(d+3)%4]\n  d=(d+3)%4 if g[ny][nx]>i\nend\n\nloop do\n  m,n=gets.split.map(&:to_i)\n  break if m==0&&n==0\n  dp=Array.new(1001){Array.new(1001,-1e99)}\n  nc,lc=0,0\n  (0..1000).each do |i|\n    (0..1000).each do |j|\n      next if g[i][j]>m\n      dp[i][j]=0 if g[i][j]==n\n      if prime[g[i][j]] then\n        dp[i][j]+=1\n        nc,lc=dp[i][j],g[i][j] if dp[i][j]>nc||dp[i][j]==nc&&lc<g[i][j]\n      end\n      (-1..1).each do |k|\n        ni=i+1\n        nj=j+k\n        next if ni>1000||nj<0||1000<nj||g[i][j]>m\n        dp[ni][nj]=dp[i][j] if dp[ni][nj]<dp[i][j]\n      end\n    end\n  end\n  puts \"%d %d\"%[nc,lc]\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'prime'\nrequire 'set'\n\n$primes = Set[*Prime.each(1000000).to_a]\n\nloop {\n\tm, n = gets.split.map &:to_i\n\tbreak if m == 0\n\t\n\ty = max_x = max_y = min_x = min_y = 0\n\tx = -1\n\tdx = 1\n\tdy = 0\n\tk = 2\n\t\n\thash = {}\n\tm.times {|i|\n\t\tx += dx\n\t\ty += dy\n\t\tif x < min_x\n\t\t\tmin_x = x\n\t\t\tdx, dy = -dy, dx\n\t\telsif x > max_x\n\t\t\tmax_x = x\n\t\t\tdx, dy = -dy, dx\n\t\telsif y < min_y\n\t\t\tmin_y = y\n\t\t\tdx, dy = -dy, dx\n\t\telsif y > max_y\n\t\t\tmax_y = y\n\t\t\tdx, dy = -dy, dx\n\t\tend\n\t\n\t\thash[[x, y]] = i+1\n\t}\n\t\n\ta = (min_y..max_y).map{ [0] * (max_x-min_y+1) }\n\thash.each{|(x, y), k|\n\t\ta[y-min_y][x-min_x] = k\n\t}\n\t\n\ttable = (min_x..max_x).map{[0,-1]}\n\t\n\tcatch(:exit) {\n\t\tloop {\n\t\t\tt = []\n\t\t\tb = a.shift\n\t\t\t(0..b.size-1).each{|i|\n\t\t\t\tc, j = table[[i-1, 0].max..[i+1, b.size-1].min].max\n\t\t\t\tt[i] = [$primes.include?(b[i]) ? c+1 : c, c == 0 ? b[i] : j]\n\t\t\t\tif b[i] == n\n\t\t\t\t\tputs t[i][0] == 0 ? '0 0' : t[i].join(\" \")\n\t\t\t\t\tthrow :exit\n\t\t\t\tend\n\t\t\t}\n\t\t\ttable = t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_P = 10 ** 6\nMAX_X = MAX_Y = 1003\n\nDXYS = [[1, 0], [0, -1], [-1, 0], [0, 1]]\n\n### subroutines\n\ndef gen_primes(max_p)\n  primes = (max_p + 1).times.map{true}\n  primes[0] = primes[1] = false\n\n  s_max_p = Math.sqrt(max_p + 0.5).to_i\n\n  for p in (2..s_max_p)\n    if primes[p]\n      (p * p).step(max_p, p).each{|q| primes[q] = false}\n    end\n  end\n\n  primes\nend\n\n### main\n\nprimes = gen_primes(MAX_P)\n\ncvs = MAX_Y.times.map{MAX_X.times.map{0}}\nx = MAX_X / 2\ny = MAX_Y / 2\ncvs[x][y] = 1\ndrc = 3\ndrc0 = 0\n\nfor k in (2..MAX_P)\n  x0 = x + DXYS[drc0][0]\n  y0 = y + DXYS[drc0][1]\n  if cvs[y0][x0] == 0\n    drc = drc0\n    drc0 = (drc0 + 1) % 4\n  end\n  x += DXYS[drc][0]\n  y += DXYS[drc][1]\n  cvs[y][x] = k\nend\n#cvs.each{|cv| puts cv.map{|c| \"%3d\" % c}.join(' ')}; exit\n\nloop do\n  m, n = gets.split.map(&:to_i)\n  break if (m | n) == 0\n\n  pnums = MAX_Y.times.map{MAX_X.times.map{0}}\n  maxps = MAX_Y.times.map{MAX_X.times.map{0}}\n\n  (MAX_Y - 1).downto(0).each do |y|\n    for x in (0...MAX_X)\n      cv = cvs[y][x]\n      if cv > 0 && cv <= m\n        max_pnum = maxp = 0\n        y0 = y + 1\n        if y0 < MAX_Y\n          for x0 in ((x - 1)..(x + 1))\n            next if x0 < 0 || x0 >= MAX_X\n            pn0 = pnums[y0][x0]\n            maxp0 = maxps[y0][x0]\n\n            if max_pnum < pn0\n              max_pnum = pn0\n              maxp = maxp0\n            elsif max_pnum == pn0 && maxp < maxp0\n              maxp = maxp0\n            end\n          end\n        end\n\n        if primes[cv]\n          max_pnum += 1\n          maxp = cv if maxp == 0\n        end\n\n        pnums[y][x] = max_pnum\n        maxps[y][x] = maxp\n      end\n\n      if cv == n\n        puts [pnums[y][x], maxps[y][x]].join(' ')\n        break\n      end\n    end\n    break if cv == n\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/bin/ruby\nprime=Array.new(1000001,true)\nprime[0..1]=false\n(2..1000000).each do |i|\n  if prime[i] then\n    j=i*2\n    while j<=1000000\n      prime[j]=false\n      j+=i\n    end\n  end\nend\ng=Array.new(1001){Array.new(1001,1e9)}\nx,y=500,500\ndy=[-1,0,1,0]\ndx=[0,1,0,-1]\nd=1\n(1..1000000).each do |i|\n  g[y][x]=i\n  x+=dx[d]\n  y+=dy[d]\n  nx=x+dx[(d+3)%4]\n  ny=y+dy[(d+3)%4]\n  d=(d+3)%4 if g[ny][nx]==1e9\nend\nloop do\n  m,n=gets.split.map(&:to_i)\n  break if m==0&&n==0\n  dp=Array.new(1001){Array.new(1001,-1e99)}\n  nc,lc=0,0\n  (0..1000).each do |i|\n    (0..1000).each do |j|\n      next if g[i][j]>m\n      dp[i][j]=0 if g[i][j]==n\n      if prime[g[i][j]] then\n        dp[i][j]+=1\n        nc,lc=dp[i][j],g[i][j] if dp[i][j]>nc||dp[i][j]==nc&&lc<g[i][j]\n      end\n      (-1..1).each do |k|\n        ni=i+1\n        nj=j+k\n        next if ni>1000||nj<0||1000<nj||g[i][j]>m\n        dp[ni][nj]=dp[i][j] if dp[ni][nj]<dp[i][j]\n      end\n    end\n  end\n  puts \"%d %d\"%[nc,lc]\nend\n\n  "
  },
  {
    "language": "Ruby",
    "code": "#!/bin/ruby\nprime=Array.new(1000001,true)\nprime[0..1]=false\n(2..1000000).each do |i|\n  if prime[i] then\n    j=i*2\n    while j<=1000000\n      prime[j]=false\n      j+=i\n    end\n  end\nend\ng=Array.new(1001){Array.new(1001,1e9)}\nx,y=500,500\ndy=[-1,0,1,0]\ndx=[0,1,0,-1]\nd=1\n(1..1000000).each do |i|\n  g[y][x]=i\n  x+=dx[d]\n  y+=dy[d]\n  nx=x+dx[(d+3)%4]\n  ny=y+dy[(d+3)%4]\n  d=(d+3)%4 if g[ny][nx]>i\nend\n\nloop do\n  m,n=gets.split.map(&:to_i)\n  break if m==0&&n==0\n  dp=Array.new(1001){Array.new(1001,-1e99)}\n  nc,lc=0,0\n  (0..1000).each do |i|\n    (0..1000).each do |j|\n      next if g[i][j]>m\n      dp[i][j]=0 if g[i][j]==n\n      if prime[g[i][j]] then\n        dp[i][j]+=1\n        nc,lc=dp[i][j],g[i][j] if dp[i][j]>nc||dp[i][j]==nc&&lc<g[i][j]\n      end\n      (-1..1).each do |k|\n        ni=i+1\n        nj=j+k\n        next if ni>1000||nj<0||1000<nj||g[i][j]>m\n        dp[ni][nj]=dp[i][j] if dp[ni][nj]<dp[i][j]\n      end\n    end\n  end\n  puts \"%d %d\"%[nc,lc]\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'prime'\n\nMax_prime = 1000000\n@prime = [false] * (Max_prime + 1)\nPrime.each(Max_prime).to_a.each do |i|\n    @prime[i] = true\nend\n\ndef solve(table, sx, sy, max_n)\n    max = 0\n    cur_n = 0\n    dp = 1001.times.map{[0] * 1001}\n    y = sy\n    l = r = sx\n    if @prime[table[sy][sx]]\n        dp[sy][sx] = 1\n        max, cur_n = 1, table[sy][sx]\n    end\n    loop do\n        (l..r).each do |x|\n            a = table[y + 1][x + 1] if inCheck(x + 1, y + 1, table, max_n)\n            b = table[y + 1][x] if inCheck(x, y + 1, table, max_n)\n            c = table[y + 1][x - 1] if inCheck(x - 1, y + 1, table, max_n)\n            pre = dp[y][x]\n            max, cur_n = update(pre, dp, a, x + 1, y + 1, max, cur_n) if a\n            max, cur_n = update(pre, dp, b, x, y + 1, max, cur_n) if b\n            max, cur_n = update(pre, dp, c, x - 1, y + 1, max, cur_n) if c\n        end\n        l -= 1 if inCheck(l - 1, y + 1, table, max_n)\n        r += 1 if inCheck(r + 1, y + 1, table, max_n)\n        y += 1\n        break if y >= 1000 || (l..r).to_a.all?{ |x| !inCheck(x, y, table, max_n) }\n    end\n    [max, cur_n]\nend\n\ndef update(pre, dp, n, x, y, max, cur_n)\n    if dp[y][x] < pre + 1 && @prime[n]\n        dp[y][x] = pre + 1\n        max, cur_n = dp[y][x], n if max < dp[y][x] || max == dp[y][x] && cur_n < n\n    elsif dp[y][x] < pre && !@prime[n]\n        dp[y][x] = pre\n    end\n    [max, cur_n]\nend\n\ndef inCheck(x, y, table, n)\n    0 <= x && x <= 1000 && 0 <= y && y <= 1000 &&\n    table[y][x] <= n\nend\n\ndef tabulate\n    table = 1001.times.map{[0] * 1001}\n    place = (Max_prime + 1).times.map{ [] }\n    dir = [[1, 0], [0, -1], [-1, 0], [0, 1]]\n    c = 0\n    n = 1\n    x = 500\n    y = 500\n\n    while n <= Max_prime do\n        dir.each_with_index do |(dx, dy), i|\n            c += 1 if i == 0\n            c += 1 if i == 2\n            c.times do\n                table[y][x] = n\n                place[n] = [x, y]\n                x += dx; y += dy\n                n += 1\n            end\n        end\n    end\n    [table, place]\nend\n\ntable, place = tabulate\nloop do\n    m, n = gets.split.map(&:to_i)\n    break if m == 0 && n == 0\n    sx, sy = place[n]\n    puts solve(table, sx, sy, m).join(' ')\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/bin/ruby\nprime=Array.new(1000001,true)\nprime[0..1]=false\n(2..1000000).each do |i|\n  if prime[i] then\n    j=i*2\n    while j<=1000000\n      prime[j]=false\n      j+=i\n    end\n  end\nend\ng=Array.new(1001){Array.new(1001,1e9)}\nx,y=500,500\ndy=[-1,0,1,0]\ndx=[0,1,0,-1]\nd=1\n(1..1000000).each do |i|\n  g[y][x]=i\n  x+=dx[d]\n  y+=dy[d]\n  nx=x+dx[(d+3)%4]\n  ny=y+dy[(d+3)%4]\n  d=(d+3)%4 if g[ny][nx]==1e9\nend\nloop do\n  m,n=gets.split.map(&:to_i)\n  break if m==0&&n==0\n  dp=Array.new(1001){Array.new(1001,-1e99)}\n  nc,lc=0,0\n  (0..1000).each do |i|\n    (0..1000).each do |j|\n      next if g[i][j]>m\n      dp[i][j]=0 if g[i][j]==n\n      if prime[g[i][j]] then\n        dp[i][j]+=1\n        nc,lc=dp[i][j],g[i][j] if dp[i][j]>nc||dp[i][j]==nc&&lc<g[i][j]\n      end\n      (-1..1).each do |k|\n        ni=i+1\n        nj=j+k\n        next if ni>1000||nj<0||1000<nj||g[i][j]>m\n        dp[ni][nj]=dp[i][j] if dp[ni][nj]<dp[i][j]\n      end\n    end\n  end\n  puts \"#{nc} #{lc}\"\nend\n\n  "
  },
  {
    "language": "Ruby",
    "code": "require 'prime'\nrequire 'set'\n\n$primes = Set[*Prime.each(1000000).to_a]\n\nloop {\n\tm, n = gets.split.map &:to_i\n\tbreak if m == 0\n\t\n\ty = max_x = max_y = min_x = min_y = 0\n\tx = -1\n\tdx = 1\n\tdy = 0\n\tk = 2\n\t\n\thash = {}\n\tm.times {|i|\n\t\tx += dx\n\t\ty += dy\n\t\tif x < min_x\n\t\t\tmin_x = x\n\t\t\tdx, dy = -dy, dx\n\t\telsif x > max_x\n\t\t\tmax_x = x\n\t\t\tdx, dy = -dy, dx\n\t\telsif y < min_y\n\t\t\tmin_y = y\n\t\t\tdx, dy = -dy, dx\n\t\telsif y > max_y\n\t\t\tmax_y = y\n\t\t\tdx, dy = -dy, dx\n\t\tend\n\t\n\t\thash[[x, y]] = i+1\n\t}\n\t\n\ta = (min_y..max_y).map{ [0] * (max_x-min_y+1) }\n\thash.each{|(x, y), k|\n\t\ta[y-min_y][x-min_x] = k\n\t}\n\t\n\ttable = (min_x..max_x).map{[0,-1]}\n\t\n\tcatch(:exit) {\n\t\tloop {\n\t\t\tt = []\n\t\t\tb = a.shift\n\t\t\t(0..b.size-1).each{|i|\n\t\t\t\tc, j = table[[i-1, 0].max..[i+1, b.size-1].min].max\n\t\t\t\tt[i] = ($primes.include?(b[i]) ? [c+1, [j, b[i]].max] : [c, j])\n\t\t\t\tif b[i] == n\n\t\t\t\t\tputs t[i][0] == 0 ? '0 0' : t[i].join(\" \")\n\t\t\t\t\tthrow :exit\n\t\t\t\tend\n\t\t\t}\n\t\t\ttable = t\n\t\t}\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.string;\nimport std.algorithm;\nimport std.math;\nimport std.array;\nimport std.format;\nimport std.range;\nimport std.stdio;\nimport std.conv;\nimport std.container;\n\nstruct C { uint n; bool b; }\n\nsize_t[2][] fieldIndex;\nC[][] field;\nuint M, N;\n\npure bool isPrime(T)(T src){\n    if(src <= 1)return false;\n    else if(src < 4)return true;\n    else if(!(src&1))return false;\n    else if(((src+1)%6) && ((src-1)%6))return false;\n    \n    T root = cast(T)sqrt(cast(real)src) + 1;\n    \n    for(T i = 5; i < root; i += 6)\n        if(!((src%i) && ((src)%(i+2))))\n            return false;\n\n    return true;\n}\n\n\nS dp(alias iterP, S)(S init)\n{\n    //auto q = redBlackTree([init]);\n    //bool[][] m = new bool[][](R, C);\n\n    //while(!q.empty){\n    //    S s = q.front; q.removeFront();\n    //    if(m[s.i][s.j]) continue;\n    //    if(s.isEnd()) return s;\n    //    writeln(q[]);\n    //    writeln(s);\n    //    writeln();\n    //    m[s.i][s.j] = 1;\n    //    iterP!((t){ if(!m[t.i][t.j]) q.insert(t); })(s);\n    //}\n\n    //return init;\n    bool update = true;\n    S[size_t] hash = [init.j : init];\n\n    while(update){\n        update = false;\n        S[size_t] next;\n        foreach(v; hash.byValue) if(v.isEnd) next[v.j] = v;\n        foreach(v; hash.byValue){\n            !v.isEnd && iterP!((t){\n                if(auto p = t.j in next){\n                    if(t > *p){ *p = t; update = true; }\n                }else { next[t.j] = t; update = true; }\n            })(v);\n        }\n        hash = next;\n    }\n\n    S s = hash.byValue.front;\n    foreach(v; hash.byValue)\n        if(v > s) s = v;\n\n    return s;\n}\n\n\nstruct S\n{\n    int i, j, c, n;\n    int opCmp(ref const S s) const { return (c == s.c) ? (n - s.n) : (c - s.c); }\n    bool opEquals(ref const S s) const { return i == s.i && j == s.j; }\n    bool isEnd() const @property {\n        return i == 1000 || (\n            (j == 0 || field[i+1][j-1].n > M) && (j == 1000 || field[i+1][j+1].n > M) && (field[i+1][j].n > M)\n        );\n    }\n}\n\n\nvoid iterPImpl(alias fn)(S s)\n{\n    static S make(S s, uint i, uint j) { return S(i, j, field[i][j].b ? s.c+1 : s.c, field[i][j].b ? field[i][j].n : s.n); }\n    if(s.j != 0 && field[s.i+1][s.j-1].n <= M) fn(make(s, s.i+1, s.j-1));\n    if(field[s.i+1][s.j].n <= M) fn(make(s, s.i+1, s.j));\n    if(s.j != 1000 && field[s.i+1][s.j+1].n <= M) fn(make(s, s.i+1, s.j+1));\n}\n\n\nvoid main()\n{\n    field = new C[][](1001, 1001);\n\n    {\n        uint ci = 500, cj = 500, step = 1, n;\n        fieldIndex ~= [0, 0];\n        while(1){\n            if(step == 1001) break;\n            foreach(i; 0 .. step){\n                ++n;\n                field[ci][cj] = C(n, isPrime(n));\n                fieldIndex ~= [ci, cj];\n                ++cj;\n            }\n            foreach(i; 0 .. step){\n                ++n;\n                field[ci][cj] = C(n, isPrime(n));\n                fieldIndex ~= [ci, cj];\n                --ci;\n            }\n            ++step;\n            foreach(i; 0 .. step){\n                ++n;\n                field[ci][cj] = C(n, isPrime(n));\n                fieldIndex ~= [ci, cj];\n                --cj;\n            }\n            foreach(i; 0 .. step){\n                ++n;\n                field[ci][cj] = C(n, isPrime(n));\n                fieldIndex ~= [ci, cj];\n                ++ci;\n            }\n            ++step;\n        }\n    }\n\n    while(1){\n        auto mn = readln().chomp().split().map!(to!uint);\n        M = mn[0];\n        N = mn[1];\n        if(!M) return;\n        //writeln(fieldIndex[N]);\n\n        auto idx = fieldIndex[N];\n        bool isP = isPrime(N);\n        auto s = dp!iterPImpl(S(idx[0], idx[1], isP ? 1 : 0, isP ? N : 0));\n        writefln(\"%s %s\", s.c, s.n);\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.algorithm;\nimport std.conv, std.array;\nimport std.typecons;\nimport std.functional;\n\nconst int M = 1003;\nalias Tuple!(int, int) pair;\n\nint[M][M] F;\npair[M * M + 1] T;\nint[4] dx = [1, 0, -1, 0];\nint[4] dy = [0, -1, 0, 1];\n\nbool[] prime;\nvoid init_prime() {\n    prime = new bool[M * M + 1];\n    prime.fill(true);\n    prime[0] = prime[1] = false;\n    for (int i = 2; i <= M * M; i++) {\n        if (prime[i]) {\n            for (int j = i + i; j <= M * M; j += i) {\n                prime[j] = false;\n            }\n        }\n    }\n}\n\nvoid P() {\n    foreach (xs; F) {\n        foreach (x; xs) {\n            writef(\"%3d \", x);\n        }\n        writeln;\n    }\n}\n\nvoid init_F() {\n    int y = M / 2, x = M / 2;\n    int d = 0;\n    int c = 1;\n    int clim = 1;\n    int used = 0;\n    bool f = false;\n    while (c <= M * M) {\n        //stderr.writeln(y, \" \" , x);\n        F[y][x] = c;\n        T[c] = pair(y, x);\n        c++;\n        y += dy[d];\n        x += dx[d];\n        used++;\n        if (used == clim) {\n            d = (d + 1) % 4;\n            if (f) {\n                clim++;\n                f = false;\n            } else {\n                f = true;\n            }\n            used = 0;\n        }\n    }\n}\n\nvoid main() {\n    init_prime;\n    init_F;\n    int m, n;\n    while (true) {\n        readf(\"%d %d\\n\", &m, &n);\n        if (m == 0 && n == 0) break;\n        solve(m, n);\n    }\n}\n\nvoid solve(int m, int n) {\n    int y = T[n][0], x = T[n][1];\n    pair ans = count(m, y, x);\n    writef(\"%d %d\\n\", ans[0], ans[1]);\n}\n\npair count(int m, int y, int x) {\n    if (F[y][x] > m) return pair(0, 0);\n    alias memoize!count mcount;\n    pair ans =  max(mcount(m, y + 1, x - 1),\n                    mcount(m, y + 1, x),\n                    mcount(m, y + 1, x + 1));\n    if (prime[F[y][x]]) {\n        if (ans[0] == 0) {\n            ans[1] = F[y][x];\n        }\n        ans[0]++;\n    }\n    return ans;\n}"
  },
  {
    "language": "D",
    "code": "import std.string;\nimport std.algorithm;\nimport std.math;\nimport std.array;\nimport std.format;\nimport std.range;\nimport std.stdio;\nimport std.conv;\nimport std.container;\n\nstruct C { uint n; bool b; }\n\nsize_t[2][] fieldIndex;\nC[][] field;\nuint M, N;\n\npure bool isPrime(T)(T src){\n    if(src <= 1)return false;\n    else if(src < 4)return true;\n    else if(!(src&1))return false;\n    else if(((src+1)%6) && ((src-1)%6))return false;\n    \n    T root = cast(T)sqrt(cast(real)src) + 1;\n    \n    for(T i = 5; i < root; i += 6)\n        if(!((src%i) && ((src)%(i+2))))\n            return false;\n\n    return true;\n}\n\n\nS dp(alias iterP, S)(S init)\n{\n    bool update = true;\n    S[size_t] hash = [init.j : init];\n\n    while(update){\n        update = false;\n        S[size_t] next;\n        foreach(v; hash.byValue) if(v.isEnd) next[v.j] = v;\n        foreach(v; hash.byValue){\n            !v.isEnd && iterP!((t){\n                if(auto p = t.j in next){\n                    if(t > *p){ *p = t; update = true; }\n                }else { next[t.j] = t; update = true; }\n            })(v);\n        }\n        hash = next;\n    }\n\n    S s = hash.byValue.front;\n    foreach(v; hash.byValue)\n        if(v > s) s = v;\n\n    return s;\n}\n\n\nstruct S\n{\n    int i, j, c, n;\n    int opCmp(ref const S s) const { return (c == s.c) ? (n - s.n) : (c - s.c); }\n    bool opEquals(ref const S s) const { return i == s.i && j == s.j; }\n    bool isEnd() const @property {\n        return i == 1000 || (\n            (j == 0 || field[i+1][j-1].n > M) && (j == 1000 || field[i+1][j+1].n > M) && (field[i+1][j].n > M)\n        );\n    }\n}\n\n\nvoid iterPImpl(alias fn)(S s)\n{\n    static S make(S s, uint i, uint j) { return S(i, j, field[i][j].b ? s.c+1 : s.c, field[i][j].b ? field[i][j].n : s.n); }\n    if(s.j != 0 && field[s.i+1][s.j-1].n <= M) fn(make(s, s.i+1, s.j-1));\n    if(field[s.i+1][s.j].n <= M) fn(make(s, s.i+1, s.j));\n    if(s.j != 1000 && field[s.i+1][s.j+1].n <= M) fn(make(s, s.i+1, s.j+1));\n}\n\n\nvoid main()\n{\n    field = new C[][](1001, 1001);\n\n    {\n        uint ci = 500, cj = 500, step = 1, n;\n        fieldIndex ~= [0, 0];\n        while(1){\n            if(step == 1001) break;\n            foreach(i; 0 .. step){\n                ++n;\n                field[ci][cj] = C(n, isPrime(n));\n                fieldIndex ~= [ci, cj];\n                ++cj;\n            }\n            foreach(i; 0 .. step){\n                ++n;\n                field[ci][cj] = C(n, isPrime(n));\n                fieldIndex ~= [ci, cj];\n                --ci;\n            }\n            ++step;\n            foreach(i; 0 .. step){\n                ++n;\n                field[ci][cj] = C(n, isPrime(n));\n                fieldIndex ~= [ci, cj];\n                --cj;\n            }\n            foreach(i; 0 .. step){\n                ++n;\n                field[ci][cj] = C(n, isPrime(n));\n                fieldIndex ~= [ci, cj];\n                ++ci;\n            }\n            ++step;\n        }\n    }\n\n    while(1){\n        auto mn = readln().chomp().split().map!(to!uint);\n        M = mn[0];\n        N = mn[1];\n        if(!M) return;\n        //writeln(fieldIndex[N]);\n\n        auto idx = fieldIndex[N];\n        bool isP = isPrime(N);\n        auto s = dp!iterPImpl(S(cast(uint)idx[0], cast(uint)idx[1], isP ? 1 : 0, isP ? N : 0));\n        writefln(\"%s %s\", s.c, s.n);\n    }\n}"
  },
  {
    "language": "Python",
    "code": "def makePrimeChecker(n):\n    isPrime = [True] * (n + 1)\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n ** 0.5) + 1):\n        if not isPrime[i]:\n            continue\n        for j in range(i * 2, n + 1, i):\n            isPrime[j] = False\n    return isPrime\n\nis_prime = makePrimeChecker(1000001)\n\nX = Y = 500\n\ndx = [1,0,-1,0]\ndy = [0,-1,0,1]\n\nyx2n = [[-1] * 1010 for _ in range(1010)]\nn2yx = [(-1, -1)] * 1010100\nn=0\nnn = 1\nbn = 0\nx=y=0\ndir = 0\nfor i in range(1, 1000001):\n    yx2n[Y+y][X+x] = i\n    n2yx[i] = (Y+y, X+x)\n    #table[Y+y][X+x] = i#is_prime[i]\n\n    #print(f\"x={x}, y={y}, n={n}, nn={nn}\")\n\n    x += dx[dir]\n    y += dy[dir]\n\n    n += 1\n    if n==nn:\n        dir += 1\n        dir %= 4\n        if bn==1:\n            nn += 1\n        n=0\n        bn ^= 1\n\n\nwhile True:\n    M, N = map(int, input().split())\n    if M==N==0:\n        break\n    table = [[0] * 1010 for _ in range(1010)]\n    for i, ((y, x), p) in enumerate(zip(n2yx[1:M+1], is_prime[1:M+1]), 1):\n        table[y][x] = p\n\n    cnt = [[0] * 1010 for _ in range(1010)]\n    from_ = [[-1] * 1010 for _ in range(1010)]\n    for i, y in enumerate(range(n2yx[N][0], 1005)):\n        for x in range(max(0, n2yx[N][1]-i), min(1005, n2yx[N][1]+i+1)):\n            c = cnt[y][x]\n            if table[y][x]:\n                c += 1\n                n = yx2n[y][x]\n            else:\n                n = from_[y][x]\n\n            if cnt[y + 1][x] < c:\n                cnt[y + 1][x] = c\n                from_[y + 1][x] = n\n            elif cnt[y + 1][x] == c:\n                if from_[y + 1][x] < n:\n                    from_[y + 1][x] = n\n\n            if cnt[y + 1][x-1] < c:\n                cnt[y + 1][x-1] = c\n                from_[y + 1][x-1] = n\n            elif cnt[y + 1][x-1] == c:\n                if from_[y + 1][x-1] < n:\n                    from_[y + 1][x-1] = n\n\n            if cnt[y + 1][x+1] < c:\n                cnt[y + 1][x+1] = c\n                from_[y + 1][x+1] = n\n            elif cnt[y + 1][x+1] == c:\n                if from_[y + 1][x+1] < n:\n                    from_[y + 1][x+1] = n\n\n            # cnt[y + 1][x] = max(cnt[y + 1][x], c)\n            # cnt[y + 1][x-1] = max(cnt[y + 1][x-1], c)\n            # cnt[y + 1][x+1] = max(cnt[y + 1][x+1], c)\n\n    ma, ama = 0, 0\n    for c, f in zip(cnt[1005], from_[1005]):\n        if c > ma:\n            ama = f\n            ma = c\n        elif c == ma:\n            if f > ama:\n                ama = f\n    if ma==0:\n        ama = 0\n    #a = max(cnt[1005])\n\n    print(ma, ama)\n\n"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\nfrom collections import deque\nM = 10**6\nprime = [1]*(M+1)\nprime[0] = prime[1] = 0\nfor i in xrange(2, int(sqrt(M))+1):\n    if prime[i]:\n        for j in xrange(i*i, M+1, i):\n            prime[j] = 0\ndef calc(x):\n    k = int(sqrt(x))\n    if k % 2:\n        p = k/2\n        if x <= k**2 + k:\n            i = x-k**2\n            return (p+1, p-i)\n        else:\n            i = x-(k**2 + k)\n            return (p+1-i, -p-1)\n    else:\n        p = k/2\n        if x <= k**2 + k:\n            i = x-k**2\n            return (-p, -p+i)\n        else:\n            i = x-(k**2+k)\n            return (-p+i, p)\nC = map(calc, xrange(M+1))\ndic = {x: i+1 for i, x in enumerate(C)}\nwhile 1:\n    m, n = map(int, raw_input().split())\n    if m == n == 0:\n        break\n    used = {}\n    deq = deque()\n    deq.append(n)\n    used[n] = prime[n]\n    u = set()\n    while deq:\n        c = deq.popleft()\n        if c in u:\n            continue\n        u.add(c)\n        x, y = C[c-1]\n        for dx in [-1, 0, 1]:\n            v = dic.get((x+dx, y+1), M+1)\n            if v <= m:\n                deq.append(v)\n                used[v] = max(used[c]+prime[v], used.get(v, 0))\n    cnt = 0; num = 0\n    for k in used:\n        if prime[k]:\n            if cnt < used[k]:\n                cnt = used[k]\n                num = k\n            elif cnt == used[k] and num < k:\n                num = k\n    print cnt, num"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\nfrom collections import deque\nM = 10**6\nprime = [1]*(M+1)\nprime[0] = prime[1] = 0\nfor i in xrange(2, int(sqrt(M))+1):\n    if prime[i]:\n        for j in xrange(i*i, M+1, i):\n            prime[j] = 0\nP = {(0, 0): 1}; R = [None, (0, 0)]\nc = 1; i = 1; p = 1\nx = y = 0\nwhile c < M:\n    for j in xrange(i):\n        x += p; c += 1\n        P[x, y] = c; R.append((x, y))\n    for j in xrange(i):\n        y -= p; c += 1\n        P[x, y] = c; R.append((x, y))\n    p = -p\n    i += 1\ndeq = deque()\ndd = [-1, 0, 1]\nwhile 1:\n    m, n = map(int, raw_input().split())\n    if m == n == 0:\n        break\n    deq.append(n)\n    cnts = {n: prime[n]}\n    used = set()\n    while deq:\n        v = deq.popleft()\n        x, y = R[v]\n        for dx in dd:\n            t = P.get((x+dx, y+1), M+1)\n            if t <= m:\n                cnts[t] = max(cnts[v] + prime[t], cnts.get(t, 0))\n                if t not in used:\n                    deq.append(t)\n                    used.add(t)\n    vals = sorted((v, k) for k, v in cnts.items() if prime[k])\n    print \"%d %d\" % vals[-1] if vals else \"0 0\""
  },
  {
    "language": "Python",
    "code": "from math import sqrt\nfrom collections import deque\nM = 10**6\nprime = [1]*(M+1)\nprime[0] = prime[1] = 0\nfor i in xrange(2, int(sqrt(M))+1):\n    if prime[i]:\n        for j in xrange(i*i, M+1, i):\n            prime[j] = 0\nP = {(0, 0): 1}; R = [None, (0, 0)]\nc = 1; i = 1; p = 1\nx = y = 0\nwhile c < M:\n    for j in xrange(i):\n        x += p; c += 1\n        P[x, y] = c; R.append((x, y))\n    for j in xrange(i):\n        y -= p; c += 1\n        P[x, y] = c; R.append((x, y))\n    p = -p\n    i += 1\ndeq = deque()\nR = [-1, 0, 1]\nwhile 1:\n    m, n = map(int, raw_input().split())\n    if m == n == 0:\n        break\n    deq.append(n)\n    cnts = {n: prime[n]}\n    used = set()\n    while deq:\n        v = deq.popleft()\n        x, y = R[v]\n        for dx in R:\n            t = P.get((x+dx, y+1), M+1)\n            if t <= m:\n                cnts[t] = max(cnts[v] + prime[t], cnts.get(t, 0))\n                if t not in used:\n                    deq.append(t)\n                    used.add(t)\n    vals = sorted((v, k) for k, v in cnts.items() if prime[k])\n    print \"%d %d\" % vals[-1] if vals else \"0 0\""
  },
  {
    "language": "Python",
    "code": "def solve():\n    M = 10 ** 6\n    e = 10 ** 3\n    \n    # the sieve of Eratosthenes\n    primes = [True] * (M + 1)\n    primes[0] = False\n    primes[1] = False\n    for i in range(2, e):\n        if primes[i]:\n            for j in range(i * 2, M + 1, i):\n                primes[j] = False\n    \n    # Create square grid sequence\n    sg = [[None] * e for i in range(e)]\n    for i, t_el, r1, r2 in zip(range(e // 2), range(e, 1, -2),sg, sg[::-1]):\n        s1 = t_el ** 2\n        s2 = s1 - 3 * (t_el) + 3\n        \n        r1[i:i+t_el] = range(s1, s1 - t_el, -1)\n        r2[i:i+t_el] = range(s2, s2 + t_el)\n    \n    for i, t_el in zip(range(e // 2 - 1), range(e - 2, 1, -2)):\n        s1 = t_el ** 2 + 1\n        s2 = s1 + t_el * 3 + 1\n        for c, n1, n2 in zip(sg[i+1:i+1+t_el], range(s1, s1 + t_el),\n                             range(s2, s2 - t_el, -1)):\n            c[i] = n1\n            c[i+t_el+1] = n2\n    \n    from sys import stdin\n    file_input = stdin\n    \n    while True:\n        m, n = map(int, file_input.readline().split())\n        if m == 0:\n            break\n        \n        # calculate the position of n\n        sn = n ** 0.5\n        i_sn = int(sn)\n        mid = e // 2\n        h_i_sn = i_sn // 2\n        if i_sn % 2:\n            if sn == i_sn:\n                s_r = mid + h_i_sn # start row\n                s_c = s_r - 1 # start column\n            elif n >= (i_sn ** 2) + i_sn + 1: # on the upper side\n                s_r = mid - h_i_sn - 1\n                s_c = mid - h_i_sn - 1 + (i_sn + 1) ** 2 - n\n            else: # on the right side\n                s_r = mid + h_i_sn - n + i_sn ** 2 + 1\n                s_c = mid + h_i_sn\n        else:\n            if sn == i_sn:\n                s_r = mid - h_i_sn\n                s_c = s_r\n            elif n <= (i_sn ** 2) + i_sn: # on the left side\n                s_r = mid - h_i_sn + n - i_sn ** 2 - 1\n                s_c = mid - h_i_sn - 1\n            else: # on the lower side\n                s_r = mid + h_i_sn\n                s_c = mid + h_i_sn - 1 - (i_sn + 1) ** 2 + n\n        \n        # calculate the required square grid size\n        sm = m ** 0.5\n        i_sm = int(sm)\n        h_i_sm = i_sm // 2\n        if i_sm % 2:\n            b = mid + h_i_sm # bottom\n            l = mid - h_i_sm - 1 # leftmost\n            if sm == i_sm:\n                r = mid + h_i_sm - 1 # rightmost\n            else:\n                r = mid + h_i_sm\n        else:\n            r = mid + h_i_sm - 1\n            if sm == i_sm:\n                l = mid - h_i_sm\n            else:\n                l = mid - h_i_sm - 1\n            if m <= i_sm ** 2 + i_sm:\n                b = mid + h_i_sm - 1\n            else:\n                b = mid + h_i_sm\n        \n        # optimize square grid\n        t_sg = [x[l:r+1] for x in sg[s_r:b + 1]]\n        \n        c1 = s_c - l\n        for i, x in zip(range(c1, 0, -1), t_sg):\n            x[:i] = [0] * i\n        c2 = r - s_c\n        for i, x in zip(range(c2, 0, -1), t_sg):\n            x[-i:] = [0] * i\n            \n        if t_sg[-1][0] == 0:\n            for i, x in enumerate(t_sg[-1]):\n                if x:\n                    break\n            t_sg = [x[i:] for x in t_sg]\n        if t_sg[-1][-1] == 0:\n            for i, x in enumerate(t_sg[-1][::-1]):\n                if x:\n                    break\n            t_sg = [x[:-i] for x in t_sg]\n        \n        if m in t_sg[-1][1:]:\n            x = t_sg[-1]\n            i = x.index(m)\n            x[i+1:] = [0] * (len(x) - i - 1)\n        \n        for x in t_sg:\n            if x[0] > m:\n                x[0] = 0\n            if x[-1] > m:\n                x[-1] = 0\n        \n        # DP\n        rec_size = len(t_sg[0]) + 2\n        prev = [0] * rec_size\n        ans1 = 0\n        ans2 = 0\n        for x in t_sg:\n            cur = [0] * rec_size\n            for i, t in enumerate(zip(prev, prev[1:], prev[2:], x), start=1):\n                a, b, c, y = t\n                if primes[y]:\n                    v = 1 + max(a, b, c)\n                    if v == ans1 and y > ans2:\n                        ans2 = y\n                    elif v > ans1:\n                        ans1 = v\n                        ans2 = y\n                else:\n                    v = max(a, b, c)\n                cur[i] = v\n            prev = cur\n        \n        print(ans1, ans2)\n        \n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict, deque\nfrom itertools import product\n\ndef primes(N):\n    sieve = [True] * (N+1)\n    sieve[:1] = [False, False]\n    for i in range(N):\n        if sieve[i]:\n            for j in range(2*i, N+1, i):\n                sieve[j] = False\n    return sieve\n\ncave = defaultdict(int)\ncave[(0, 0)] = 1\nsieve = primes(10**6)\nD = [[0, 1], [-1, 0], [0, -1], [1, 0]]\nwhere = [[10**7, 10**7], [0, 0]]\n\nc = 0 # cycle\nd = 3 # direction\nx, y = 0, 0\ndx, dy = 1, 0\nfor i in range(2, 10**6+1):\n    if abs(x+dx) > c or abs(y+dy) > c:\n        if d == 3:\n            x, y = x+dx, y+dy\n            c += 1\n            d = 0\n            dx, dy = D[d]\n        else:\n            d += 1\n            dx, dy = D[d]\n            x, y = x+dx, y+dy\n    else:\n        x, y = x+dx, y+dy\n    where.append([x, y])\n    cave[(x, y)] = i\n\nM, N = map(int, input().split())\n\nwhile N:\n    x, y = where[N]\n    Q = deque([[x, y]])\n    DP = [0] * (M+1)\n    DP[N] += sieve[N]\n    searched = [False] * (M+1)\n    while Q:\n        #print(x, y)\n        x, y = Q.popleft()\n        ny = y - 1\n        p = DP[cave[(x, y)]]\n        for nx in range(x-1, x+2):\n            n = cave[(nx, ny)]\n            if 1 <= n <= M:\n                DP[n] = max(DP[n], p + sieve[n])\n                if not searched[n]:\n                    searched[n] = True\n                    Q.append([nx, ny])\n    A = max(DP)\n    B = 0\n    if A:\n        for i in range(M+1):\n            if sieve[i] and DP[i] == A:\n                B = i\n    print(A, B)\n\n    M, N = map(int, input().split())\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\nclass Prime():\n    def __init__(self, n):\n        self.M = m = int(math.sqrt(n)) + 10\n        self.A = a = [True] * m\n        a[0] = a[1] = False\n        self.T = t = []\n        for i in range(2, int(math.sqrt(m)) + 1):\n            if not a[i]:\n                continue\n            t.append(i)\n            for j in range(i*i,m,i):\n                a[j] = False\n\n    def is_prime(self, n):\n        return self.A[n]\n\n    def division(self, n):\n        d = collections.defaultdict(int)\n        for c in self.T:\n            while n % c == 0:\n                d[c] += 1\n                n //= c\n            if n < 2:\n                break\n        if n > 1:\n            d[n] += 1\n        return d.items()\n\n    def sowa(self, n):\n        r = 1\n        for k,v in self.division(n):\n            t = 1\n            for i in range(1,v+1):\n                t += math.pow(k, i)\n            r *= t\n        return r\n\ndef main():\n    rr = []\n    pr = Prime(10**12)\n    dc = collections.defaultdict(lambda: inf)\n    dc[(0,0)] = 1\n    cd = [(inf,inf), (0,0)]\n    ti = 2\n    for i in range(1, 1000):\n        si = i\n        sj = i\n        i2 = i*2\n        for k in range(i2):\n            si -= 1\n            t = (si, sj)\n            dc[t] = ti\n            cd.append(t)\n            ti += 1\n        for k in range(i2):\n            sj -= 1\n            t = (si, sj)\n            dc[t] = ti\n            cd.append(t)\n            ti += 1\n        for k in range(i2):\n            si += 1\n            t = (si, sj)\n            dc[t] = ti\n            cd.append(t)\n            ti += 1\n        for k in range(i2):\n            sj += 1\n            t = (si, sj)\n            dc[t] = ti\n            cd.append(t)\n            ti += 1\n        if ti > 10**6:\n            break\n\n    def f(m, n):\n        fm = {}\n        def ff(k):\n            if k in fm:\n                return fm[k]\n            dk = dc[k]\n            if dk > m:\n                fm[k] = (0, 0)\n                return (0, 0)\n\n            cm = (0, 0)\n            for i in range(-1, 2):\n                ct = ff((k[0]+1, k[1]+i))\n                if cm < ct:\n                    cm = ct\n            if pr.is_prime(dk):\n                if cm[0] == 0:\n                    fm[k] = (1, dk)\n                else:\n                    fm[k] = (cm[0]+1, cm[1])\n            else:\n                fm[k] = cm\n            return fm[k]\n\n        r = ff(cd[n])\n        return ' '.join(map(str, r))\n\n    while True:\n        m,n = LI()\n        if m == 0 and n == 0:\n            break\n        rr.append(f(m,n))\n\n    return '\\n'.join(map(str, rr))\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import defaultdict\n\nN = 10**6 + 1\np = list(range(N))\np[1] = 0\nfor i in range(2, int(N**.5) + 1):\n    p[i * 2::i] = [0] * len(p[i * 2::i])\n\ncart2num = {}\n\n\ndef cart2spi(x, y):\n    size = max(abs(x), abs(y))\n    if x + y > 0:\n        num = (2 * size - 1) ** 2\n        sx, sy = size, 1 - size\n        num += y - sy + sx - x\n    else:\n        num = (2 * size) ** 2\n        sx, sy = -size, size\n        num += sy - y + x - sx\n    return num\n\n\ndef spi2cart(n):\n    root = int(n ** .5)\n    diff = n - root ** 2\n    if root % 2:\n        x, y = root // 2 + 1, -root // 2 + 1\n        dx, dy = -1, 1\n    else:\n        x, y = -root // 2, root // 2\n        dx, dy = 1, -1\n    x += dx * max(diff - root, 0)\n    y += dy * min(diff, root)\n    return x, y\n\n\ndef solve(max_p, s):\n    prv = {spi2cart(s - 1): [1, s] if p[s] else [0, 0]}\n    res = []\n    while 1:\n        nxt = defaultdict(lambda: [0, 0])\n        for x, y in prv:\n            ny = y - 1\n            for dx in [-1, 0, 1]:\n                nx = x + dx\n                if (nx, ny) in cart2num:\n                    num = cart2num[nx, ny]\n                else:\n                    num = cart2num[nx, ny] = cart2spi(nx, ny) + 1\n                if num > max_p:\n                    if dx == 0:\n                        res.append(prv[x, y])\n                    continue\n                nxt_cnt, prv_cnt = nxt[nx, ny][0], prv[x, y][0]\n                if p[num]:\n                    if nxt_cnt < prv_cnt + 1:\n                        nxt[nx, ny] = [prv_cnt + 1, num]\n                    elif nxt_cnt == prv_cnt + 1:\n                        nxt[nx, ny][1] = max(nxt[nx, ny][1], num)\n                else:\n                    if nxt_cnt < prv_cnt:\n                        nxt[nx, ny] = prv[x, y]\n                    elif nxt_cnt == prv_cnt:\n                        nxt[nx, ny][1] = max(nxt[nx, ny][1], prv[x, y][1])\n        if not nxt:\n            break\n        prv = nxt\n    return max(res)\n\n\nfor e in sys.stdin.readlines()[:-1]:\n    m, n = map(int, e.split())\n    print(*solve(m, n))\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict,deque\n\nfact = [1 for i in range(1000001)]\nfact[1] = 0\nz = 2\nwhile 1:\n    j = 2\n    while z*j < 1000001:\n        fact[z*j] = 0\n        j += 1\n    for j in range(z+1,1000001):\n        if fact[j]:\n            z = j\n            break\n    else:\n        break\nd = defaultdict(lambda : None)\nf = [None for i in range(1000001)]\nx,y,di = 0,0,\"d\"\nf[1] = (0,0)\nd[(0,0)] = 1\nfor i in range(2,1000001):\n    if di == \"d\":\n        if d[(x+1,y)] == None:\n            x += 1\n            di = \"r\"\n        else:\n            y += 1\n    elif di == \"r\":\n        if d[(x,y-1)] == None:\n            y -= 1\n            di = \"u\"\n        else:\n            x += 1\n    elif di == \"u\":\n        if d[(x-1,y)] == None:\n            x -= 1\n            di = \"l\"\n        else:\n            y -= 1\n    else:\n        if d[(x,y+1)] == None:\n            y += 1\n            di = \"d\"\n        else:\n            x -= 1\n    d[(x,y)] = i\n    f[i] = (x,y)\nv = [[] for i in range(1000001)]\nfor i in range(1,1000001):\n    x,y = f[i]\n    for j in range(-1,2):\n        if d[(x+j,y+1)] != None:\n            v[i].append(d[(x+j,y+1)])\n\nwhile 1:\n    m,n = map(int, input().split())\n    if m == n == 0:\n        break\n    ans = [-1 for i in range(m+1)]\n    q = deque()\n    q.append(n)\n    ans[n] = fact[n]\n    while q:\n        x = q.popleft()\n        for y in v[x]:\n            if y <= m:\n                if ans[y] < 0:\n                    ans[y] = ans[x]+fact[y]\n                    q.append(y)\n                else:\n                    if ans[x]+fact[y] > ans[y]:\n                        ans[y] = ans[x]+fact[y]\n    ma = max(ans)\n    if ma == 0:\n        print(0,0)\n    else:\n        for i in range(m+1)[::-1]:\n            if fact[i]:\n                if ans[i] == ma :\n                    k = i\n                    break\n        print(ma, k)\n\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\nfn solve() {\n    loop {\n        let a: usize = get();\n        let b: usize = get();\n        if a == 0 && b == 0 { break; }\n        let mut a = vec![0; a];\n        println!(\"0\");\n    }\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::Read;\n#[allow(dead_code)]\nfn getline() -> String {\n    let mut ret = String::new();\n    std::io::stdin().read_line(&mut ret).ok().unwrap();\n    ret\n}\nfn get_word() -> String {\n    let mut stdin = std::io::stdin();\n    let mut u8b: [u8; 1] = [0];\n    loop {\n        let mut buf: Vec<u8> = Vec::with_capacity(16);\n        loop {\n            let res = stdin.read(&mut u8b);\n            if res.unwrap_or(0) == 0 || u8b[0] <= b' ' {\n                break;\n            } else {\n                buf.push(u8b[0]);\n            }\n        }\n        if buf.len() >= 1 {\n            let ret = String::from_utf8(buf).unwrap();\n            return ret;\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn get<T: std::str::FromStr>() -> T { get_word().parse().ok().unwrap() }\n\nconst W: usize = 1000;\nfn fill(board: &mut [[usize; W]; W], x: &mut i32, y: &mut i32, count: usize,\n        dx: &mut i32, dy: &mut i32, acc: &mut usize) {\n    for _ in 0 .. count {\n        board[*x as usize][*y as usize] = *acc;\n        *x += *dx;\n        *y += *dy;\n        *acc += 1;\n    }\n    let (nx, ny) = (-*dy, *dx);\n    *dx = nx;\n    *dy = ny;\n}\n\nconst N: usize = 1000100;\n\nfn prime_init() -> [bool; N] {\n    let mut pr = [true; N];\n    pr[0] = false;\n    pr[1] = false;\n    for i in 2 .. N {\n        if !pr[i] { continue; }\n        for j in 2 .. (N - 1) / i + 1 {\n            pr[i * j] = false;\n        }\n    }\n    pr\n}\n\nconst INF: i32 = 1 << 28;\n\nfn solve() {\n    let mut board = [[0; W]; W];\n    let mut x = W as i32 / 2;\n    let mut y = W as i32 / 2 - 1;\n    let mut dx = 1;\n    let mut dy = 0;\n    let mut count = 1;\n    for i in 0 .. W  / 2 {\n        fill(&mut board, &mut x, &mut y, 2 * i,\n             &mut dx, &mut dy, &mut count);\n        fill(&mut board, &mut x, &mut y, 2 * i + 1,\n             &mut dx, &mut dy, &mut count);\n        fill(&mut board, &mut x, &mut y, 2 * i + 1,\n             &mut dx, &mut dy, &mut count);\n        fill(&mut board, &mut x, &mut y, 2 * i + 2,\n             &mut dx, &mut dy, &mut count);\n    }\n    let pr = prime_init();\n    let mut dp = [[0; W]; W];\n    loop {\n        let a: usize = get();\n        let b: usize = get();\n        if a == 0 && b == 0 { break; }\n        for i in 0 .. W {\n            for e in dp[i].iter_mut() {\n                *e = -INF;\n            }\n        }\n        for i in 0 .. W {\n            for j in 0 .. W {\n                if board[i][j] == b {\n                    dp[i][j] = if pr[b] { 1 } else { 0 };\n                    continue;\n                }\n                let cur = if board[i][j] <= a && pr[board[i][j]] {\n                    1\n                } else {\n                    0\n                };\n                let mut ma = -INF;\n                if i > 0 {\n                    if j > 0 { ma = max(ma, dp[i - 1][j - 1]); }\n                    ma = max(ma, dp[i - 1][j]);\n                    if j < W - 1 { ma = max(ma, dp[i - 1][j + 1]); }\n                }\n                dp[i][j] = ma + cur;\n            }\n        }\n        let mut ma = (0, 0);\n        for i in 0 .. W {\n            for j in 0 .. W {\n                if board[i][j] <= a && pr[board[i][j]] {\n                    ma = max(ma, (dp[i][j], board[i][j]));\n                }\n            }\n        }\n        println!(\"{} {}\", ma.0, ma.1);\n    }\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n\n"
  }
]