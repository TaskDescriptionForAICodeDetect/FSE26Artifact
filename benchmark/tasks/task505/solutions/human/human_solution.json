[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\n// 座標圧縮(map実装)\nmap<ll,int> zip; // zipではない 定数倍重めなので二分探索が必要ないならunordered_map実装を\nmap<int,ll> un_zip;\nvoid zip_in(vector<ll>& a){\n  for(auto &i:a) zip[i] = 1;\n  int cnt = 1; // 好みだけど0はエラー検出のために利用しない方がよさげ\n  for(auto &p:zip){ // ちゃんと参照渡しにしよう（2敗）\n    p.second = cnt++;\n    un_zip[p.second] = p.first;\n  }\n  /*\n    DEB;\n    for(auto a: zip) SHOW(a.first,a.second);\n    for(auto a: un_zip) SHOW(a.first,a.second);\n  */\n}\nbool area[250][250]={};\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    zip.clear();\n    un_zip.clear();\n    rep(i,250)rep(j,250)  area[i][j] = 0;\n    vector<int>x(n),y(n);\n    vector<long long>x2(2*n);\n    vector<int>cx,cy;\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i];\n      x2[i]=x[i];\n      x2[i+n]=y[i];\n    }\n    for(int i=0;i<4;i++){\n      int a,b;cin>>a>>b;\n      cx.pb(a);\n      cy.pb(b);\n      x2.pb(a);\n      x2.pb(b);\n    }\n    x2.pb(-1000000);\n    x2.pb(1000000);\n    sort(x2.begin(),x2.end());\n    zip_in(x2);\n    for(int i=0;i<n;i++){\n      area[zip[x[i]]][zip[y[i]]]=1;\n    }\n    for(int i=0;i<250;i++){\n      int cnt=0;\n      for(int j=0;j<250;j++){\n\tif(area[i][j]==1)\n\t  cnt++;\n\tif(cnt%2==0){\n\t  area[i][j]=0;\n\t}else{\n\t  area[i][j]=1;\n\t}\n      }\n    }\n    for(int i=0;i<250;i++){\n      int cnt=0;\n      for(int j=0;j<250;j++){\n\tif(area[j][i]==1)\n\t  cnt++;\n\tif(cnt%2==0){\n\t  area[j][i]=0;\n\t}else{\n\t  area[j][i]=1;\n\t}\n      }\n    }\n    ll ans=0;\n    for(int i=0;i<249;i++){\n      for(int j=0;j<249;j++){\n\tint ax=un_zip[i];\n\tint ay=un_zip[j];\n\tint bx=un_zip[i+1];\n\tint by=un_zip[j+1];\n  \n\tint min_x = min(cx[0],cx[2]);\n\tint min_y = min(cy[0],cy[2]);\n\tint max_x = max(cx[0],cx[2]);\n\tint max_y = max(cy[0],cy[2]);\n  \n\tif(area[i][j]){\n\t  if(min_x <= ax && max_x >= bx && min_y <= ay && max_y >= by)\n            ;\n\t  else ans+=(bx-ax)*(by-ay);\n\t}\n      }\n    }\n    //rep(i,20){rep(j,20)cerr <<area[i][j];cerr << endl;}\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct data {\n  long long x, y;\n  bool iscurtain;\n};\nbool operator<(const data &l, const data &r) {\n  if(l.x != r.x) return l.x < r.x;\n  return l.y < r.y;\n}\n\nlong long n, minx, miny, maxx, maxy;\nvector<data> v;\nvector<long long> xlst;\nvector<vector<long long>> ylst;\nset<long long> st;\n\nlong long solve();\nlong long calc(bool curtain);\n\nint main() {\n  while(1) {\n    cin >> n;\n    if(n == 0) break;\n    minx = miny = (long long)1e9;\n    maxx = maxy = (long long)-1e9;\n    v.resize(n);\n    xlst.clear();\n    ylst.clear();\n    for(int i = 0; i < n; ++i) {\n      cin >> v[i].x >> v[i].y;\n      v[i].iscurtain = 0;\n    }\n    for(int i = 0; i < 4; ++i) {\n      long long x, y;\n      cin >> x >> y;\n      minx = min(minx, x);\n      miny = min(miny, y);\n      maxx = max(maxx, x);\n      maxy = max(maxy, y);\n    }\n    v.push_back({minx, (long long)-1e9, 1});\n    v.push_back({maxx, (long long)-1e9, 1});\n    n += 2;\n    sort(v.begin(), v.end());\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\nlong long solve() {\n  long long res = 0, nowx = -1e9;\n  bool nowcurtain = 0;\n  for(int i = 0; i < n;) {\n    xlst.push_back(v[i].x);\n    if(v[i].iscurtain) {\n      ++i;\n      ylst.push_back(vector<long long>());\n    }\n    else {\n      vector<long long> tmp;\n      nowx = v[i].x;\n      while(i < n && v[i].x == nowx)\n        tmp.push_back(v[i++].y);\n      ylst.push_back(tmp);\n    }\n  }\n  n = xlst.size();\n  st.clear();\n  for(int i = 0; i < n; ++i) {\n    res += (xlst[i] - nowx) * calc(nowcurtain);\n    for(int j = 0; j < ylst[i].size(); ++j)\n      if(st.find(ylst[i][j]) == st.end())\n        st.insert(ylst[i][j]);\n      else\n        st.erase(ylst[i][j]);\n    nowx = xlst[i];\n    if(ylst[i].size() == 0) nowcurtain = 1 - nowcurtain;\n  }\n  return res;\n}\n\nlong long calc(bool curtain) {\n  long long res = 0;\n  for(auto it = st.begin(); it != st.end();) {\n    long long d, u = 0, now;\n    d = *(it++);\n    u = *(it++);\n    now = u - d;\n    if(curtain)\n      now -= max(0LL, min(u, maxy) - max(d, miny));\n    res += max(0LL, now);\n  }\n  return res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repp(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perr(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl;\n#define CNO cout<<\"No\"<<endl;\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  while(1){\n    int n;\n    cin >> n;\n    if(n==0) return 0;\n    vector<int> x(n),y(n);\n    rep(i,n) cin >> x[i] >> y[i];\n    vector<pair<int,int>> c(4);\n    rep(i,4) cin >> c[i].first >> c[i].second;\n    sort(all(c));\n    LL l=c[0].first,r=c[2].first,u=c[1].second+30000,d=c[0].second+30000;\n    LL ans=0;\n    rep(i,n){\n      LL px=x[i];\n      LL py=y[i]+30000;\n      LL nx=x[(i+1)%n];\n      LL ny=y[(i+1)%n]+30000;\n      if(px==nx) continue;\n      if(px<nx){\n        if(nx<=l||r<=px){\n          ans-=(nx-px)*ny;\n          goto next;\n        }\n        ans-=(max(l-px,0ll)+max(nx-r,0ll))*ny+min(ny,d)*(min(r,nx)-max(l,px))+max(ny-u,0ll)*(min(r,nx)-max(l,px));\n      }else{\n        swap(px,nx);\n        if(nx<=l||r<=px){\n          ans+=(nx-px)*ny;\n          goto next;\n        }\n        ans+=(max(l-px,0ll)+max(nx-r,0ll))*ny+min(ny,d)*(min(r,nx)-max(l,px))+max(ny-u,0ll)*(min(r,nx)-max(l,px));\n      }\n      next:;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing Pi = pair<bool, int>;\n\nint main() {\n    int N;\n    int c = 0;\n    while(cin >> N, N != 0) {\n        c++;\n        //if(c == 37) cerr << N << endl;\n        vector<vector<Pi>> mp(40001, vector<Pi>());\n        int x, y;\n        cin >> x >> y;\n        int sx = x, sy = y;\n        for(int i = 0; i < N; ++i) {\n            int x2, y2;\n            if(i == N - 1) {\n                x2 = sx, y2 = sy;\n            } else {\n                cin >> x2 >> y2;\n            }\n            if(x < x2) {\n                for(int xn = x; xn < x2; ++xn) {\n                    mp[xn + 20000].push_back(Pi(0, y));\n                }\n            } else if(x2 < x) {\n                for(int xn = x2; xn < x; ++xn) {\n                    mp[xn + 20000].push_back(Pi(0, y));\n                }\n            }\n            x = x2, y = y2;\n        }\n        cin >> x >> y;\n        sx = x, sy = y;\n        for(int i = 0; i < 4; ++i) {\n            int x2, y2;\n            if(i == 3) {\n                x2 = sx, y2 = sy;\n            } else {\n                cin >> x2 >> y2;\n            }\n            if(x < x2) {\n                for(int xn = x; xn < x2; ++xn) {\n                    mp[xn + 20000].push_back(Pi(1, y));\n                }\n            } else if(x2 < x) {\n                for(int xn = x2; xn < x; ++xn) {\n                    mp[xn + 20000].push_back(Pi(1, y));\n                }\n            }\n            x = x2, y = y2;\n        }\n        long long ans = 0;\n        for(int x = -20000; x <= 20000; ++x) {\n            sort(mp[x + 20000].begin(), mp[x + 20000].end(), [](const Pi &l, const Pi &r) { return l.second < r.second; });\n            bool window = 0, carten = 0;\n            int window_start;\n            for(Pi p : mp[x + 20000]) {\n                if(p.first == 0) {\n                    if(window == 0) {\n                        window = 1;\n                        window_start = p.second;\n                    } else {\n                        if(!carten) {\n                            ans += p.second - window_start;\n                        }\n                        window = 0;\n                    }\n                } else {\n                    if(carten == 0) {\n                        if(window) {\n                            ans += (p.second - window_start);\n                        }\n                        carten = 1;\n                    } else {\n                        if(window) {\n                            window_start = p.second;\n                        }\n                        carten = 0;\n                    }\n                }\n                //cerr << ans << endl;\n            }\n            //if(!mp[x + 20000].empty()) cerr << \"debug:\" << x << \" \" << ans << endl;\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint N, x[109], y[109], ax, ay, bx, by; bool used[209][209];\n\nvoid init() {\n\tN = 0; ax = 0; ay = 0; bx = 0; by = 0;\n\tfor (int i = 0; i < 109; i++) { x[i] = 0; y[i] = 0; }\n\tfor (int i = 0; i < 209 * 209; i++) used[i / 209][i % 209] = false;\n}\n\nint solve() {\n\tvector<int>X, Y;\n\tfor (int i = 0; i < N; i++) { X.push_back(x[i]); Y.push_back(y[i]); }\n\tsort(X.begin(), X.end()); X.erase(unique(X.begin(), X.end()), X.end());\n\tsort(Y.begin(), Y.end()); Y.erase(unique(Y.begin(), Y.end()), Y.end());\n\n\tfor (int i = 0; i < Y.size(); i++) {\n\t\tvector<int>P;\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tint v1 = y[j], v2 = y[(j + 1) % N]; if (v1 > v2) swap(v1, v2);\n\t\t\tif (x[j] == x[(j + 1) % N] && v1 <= Y[i] && Y[i] < v2) P.push_back(x[j]);\n\t\t}\n\t\tsort(P.begin(), P.end());\n\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < X.size(); j++) {\n\t\t\twhile (cnt < P.size() && P[cnt] == X[j]) cnt++;\n\t\t\tif (cnt % 2 == 1) used[j][i] = true; // (x 座標, y 座標) の順\n\t\t}\n\t}\n\tlong long ret = 0;\n\tfor (int i = 0; i < X.size() - 1; i++) {\n\t\tfor (int j = 0; j < Y.size() - 1; j++) {\n\t\t\tif (used[i][j] == false) continue;\n\t\t\tint px = X[i], py = Y[j], qx = X[i + 1], qy = Y[j + 1];\n\t\t\tpx = max(px, ax); py = max(py, ay);\n\t\t\tqx = min(qx, bx); qy = min(qy, by);\n\n\t\t\tif (px >= qx || py >= qy) ret += 0;\n\t\t\telse ret += (qx - px) * (qy - py);\n\t\t}\n\t}\n\tlong long ret2 = 0;\n\tfor (int i = 0; i < N; i++) ret2 += (x[i] - x[(i + 1) % N]) * (y[i] + y[(i + 1) % N]);\n\tret2 = abs(ret2); ret2 /= 2;\n\n\treturn ret2 - ret;\n}\n\nint main() {\n\twhile (true) {\n\t\tinit();\n\t\tcin >> N; if (N == 0) break;\n\t\tfor (int i = 0; i < N; i++) cin >> x[i] >> y[i];\n\t\tint v1, v2, v3, v4, v5, v6, v7, v8;\n\t\tcin >> v1 >> v2 >> v3 >> v4 >> v5 >> v6 >> v7 >> v8;\n\t\tax = min({ v1, v3, v5, v7 });\n\t\tay = min({ v2, v4, v6, v8 });\n\t\tbx = max({ v1, v3, v5, v7 });\n\t\tby = max({ v2, v4, v6, v8 });\n\t\tcout << solve() << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\nusing lint = long long int;\nlong long int INF = 1001001001001001LL;\nint inf = 1000000007;\nlong long int MOD = 1000000007LL;\ndouble PI = 3.1415926535897932;\n\ntemplate<typename T1,typename T2>inline void chmin(T1 &a,const T2 &b){if(a>b) a=b;}\ntemplate<typename T1,typename T2>inline void chmax(T1 &a,const T2 &b){if(a<b) a=b;}\n\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n\n// quoted from beet-aizu\ntemplate <typename T,typename E, typename F, typename G, typename H>\nstruct LazySegmentTree{\n    //using F = function<T(T,T)>;\n    //using G = function<T(T,E)>;\n    //using H = function<E(E,E)>;\n    int n,height;\n    F f;\n    G g;\n    H h;\n    T ti;\n    E ei;\n    vector<T> dat;\n    vector<E> laz;\n    LazySegmentTree(F f,G g,H h,T ti,E ei):\n        f(f),g(g),h(h),ti(ti),ei(ei){}\n\n    void init(int n_){\n        n=1;height=0;\n        while(n<n_) n<<=1,height++;\n        dat.assign(2*n,ti);\n        laz.assign(2*n,ei);\n    }\n    void build(const vector<T> &v){\n        int n_=v.size();\n        init(n_);\n        for(int i=0;i<n_;i++) dat[n+i]=v[i];\n        for(int i=n-1;i;i--)\n            dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);\n    }\n    inline T reflect(int k){\n        return laz[k]==ei?dat[k]:g(dat[k],laz[k]);\n    }\n    inline void eval(int k){\n        if(laz[k]==ei) return;\n        laz[(k<<1)|0]=h(laz[(k<<1)|0],laz[k]);\n        laz[(k<<1)|1]=h(laz[(k<<1)|1],laz[k]);\n        dat[k]=reflect(k);\n        laz[k]=ei;\n    }\n    inline void thrust(int k){\n        for(int i=height;i;i--) eval(k>>i);\n    }\n    inline void recalc(int k){    \n        while(k>>=1)\n            dat[k]=f(reflect((k<<1)|0),reflect((k<<1)|1));\n    }\n    void update(int a,int b,E x){\n        thrust(a+=n);\n        thrust(b+=n-1);\n        for(int l=a,r=b+1;l<r;l>>=1,r>>=1){\n            if(l&1) laz[l]=h(laz[l],x),l++;\n            if(r&1) --r,laz[r]=h(laz[r],x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n    void set_val(int a,T x){\n        thrust(a+=n);\n        dat[a]=x;laz[a]=ei;\n        recalc(a);\n    }\n    T query(int a,int b){\n        thrust(a+=n);\n        thrust(b+=n-1);\n        T vl=ti,vr=ti;\n        for(int l=a,r=b+1;l<r;l>>=1,r>>=1) {\n            if(l&1) vl=f(vl,reflect(l++));\n            if(r&1) vr=f(reflect(--r),vr);\n        }\n        return f(vl,vr);\n    }\n};\n\n/* \n *    [考えるべきこと]\n *    区間をマージしてから作用素を作用させても、作用素を作用させてから区間をマージするのと結果が同じ\n *    複数の作用素をマージして一度に作用させられること\n *    作用素を伝搬し終わっているのかの判定に必要（まあこれは満たされていなくても最悪どうにかなる）\n *    O(N) とかだと困る（setのマージとか）\n *    区間の長さに比例して作用が変わるときは，practice/RSRA や Library-Checher の RangeAffineRangeSum を参照する\n * \n */\n\n/**  テンプレ\nint main(){\n  using T = ***;  // type T\n  using E = ***;  // type E\n  auto f = [](T a, T b){ // return type T value\n    return ***;\n  };\n  auto g = [](T a, E b){ // return type T value\n    return ***;\n  };\n  auto h = [](E a, E b){ // return type E value\n    return ***;\n  };\n  T ti = ***;  // identity element\n  E ei = ***;  // identity element\n  LazySegmentTree<T, E, decltype(f), decltype(g), decltype(h)> sg(f, g, h, ti, ei);  // don't change\n  sg.build(***);\n}\n**/\n\nbool solve() {\n\n  int n; cin >> n;\n  if (n == 0) return false;\n  vector<lint> x(n);\n  vector<lint> y(n);\n  \n  int ofs = 20001;\n  int MAXW = 40010;\n\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n    x[i] += ofs;\n    y[i] += ofs;\n  }\n\n  vector<lint> a(4);\n  vector<lint> b(4);\n  for (int i = 0; i < 4; i++) {\n    cin >> a[i] >> b[i];\n    a[i] += ofs;\n    b[i] += ofs;\n  }\n\n  // 各 y に対する x を全列挙する\n  vector<vector<int>> xs(MAXW);\n\n  for (int i = 0; i < n; i++) {\n    if (y[i] == y[(i + 1) % n]) continue;\n    int miny = min(y[i], y[(i + 1) % n]);\n    int maxy = max(y[i], y[(i + 1) % n]);\n    for (int j = miny; j < maxy; j++) {\n      xs[j].push_back(x[i]);\n    }\n  }\n\n  // xs を全てソートする\n  for (int i = 0; i < MAXW; i++) {\n    sort(ALL(xs[i]));\n  }\n\n  // 各 y に対する add 座標と del 座標を全列挙する（偶奇）\n  vector<vector<int>> add(MAXW);\n  vector<vector<int>> del(MAXW);\n\n  for (int i = 0; i < MAXW; i++) {\n    for (int j = 0; j < xs[i].size(); j++) {\n      if (j % 2 == 0) {\n        add[i].push_back(xs[i][j]);\n      } else {\n        del[i].push_back(xs[i][j]);\n      }\n    }\n  }\n\n  // カーテンの座標\n  int cMinX = MAXW;\n  int cMaxX = 0;\n  int cMinY = MAXW;\n  int cMaxY = 0;\n  for (int i = 0; i < 4; i++) {\n    chmin(cMinX, a[i]);\n    chmin(cMinY, b[i]);\n    chmax(cMaxX, a[i]);\n    chmax(cMaxY, b[i]);\n  }\n\n  using T = pair<int, int>;\n  using E = int;\n  auto f = [](T l, T r){\n      return T(l.first + r.first, l.second + r.second);\n  };\n  auto g = [](T l, E r){\n      return T(l.first + l.second * r, l.second);       \n  };\n  auto h = [](E l, E r){\n      return l + r;\n  };\n\n  LazySegmentTree<T, E, decltype(f), decltype(g), decltype(h)> sg(f, g, h, T(0, 0), 0);\n  sg.build(vector<T>(MAXW, T(0, 1)));\n  \n  lint ans = 0;\n  for (int i = 0; i < MAXW; i++) {\n\n    // 窓があるなら，update 処理\n    for (int j = 0; j < add[i].size(); j++) {\n      sg.update(add[i][j], del[i][j], 1);\n    }\n\n    // 値を得る\n    ans += sg.query(0, MAXW).first;\n    if (sg.query(0, MAXW).first > 0) {\n    }\n    \n\n    // カーテンがあるなら，被ってる分はひく\n    if (cMinY <= i and i < cMaxY) {\n      ans -= sg.query(cMinX, cMaxX).first;\n    }\n\n    // 窓があるなら，update 処理\n    for (int j = 0; j < add[i].size(); j++) {\n      sg.update(add[i][j], del[i][j], -1);\n    }\n\n    assert(sg.query(0, MAXW).first == 0);\n\n  }\n  \n  cout << ans << endl;\n\n  return true;\n}\n\nint main() {\n\n  while (solve()) {\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        vector<ll> ux,uy;\n\n        vector<pi> window(n);\n        rep(i,n){\n            int x,y;\n            cin >>x >>y;\n            window[i] = {x,y};\n            ux.pb(x);\n            uy.pb(y);\n        }\n\n        vector<pi> curtain(4);\n        rep(i,4){\n            int x,y;\n            cin >>x >>y;\n            curtain[i] = {x,y};\n            ux.pb(x);\n            uy.pb(y);\n        }\n\n        sort(all(ux));\n        ux.erase(unique(all(ux)), ux.end());\n        sort(all(uy));\n        uy.erase(unique(all(uy)), uy.end());\n\n        auto cover = [&](const vector<pi> &v, double X, double Y){\n            int ct = 0;\n            int V = v.size();\n            rep(i,V){\n                int j = (i+1)%V;\n                if(v[i].fi==v[j].fi && X<v[i].fi){\n                    int ly = min(v[i].se, v[j].se);\n                    int ry = max(v[i].se, v[j].se);\n\n                    if(ly<Y && Y<ry) ++ct;\n                }\n            }\n            return ct%2 == 1;\n        };\n\n        int X = ux.size();\n        int Y = uy.size();\n        ll ans = 0;\n        rep(i,X-1)rep(j,Y-1){\n            ll area = (ux[i+1]-ux[i])*(uy[j+1]-uy[j]);\n            double px = (ux[i]+ux[i+1])/2.0;\n            double py = (uy[j]+uy[j+1])/2.0;\n\n            if(cover(window,px,py) && !cover(curtain,px,py)) ans += area;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define reps(i,j,k) for(int i=(j);i<(k);i++)\n#define rep(i,j) reps(i,0,j)\n#define sc second\n#define fs first\n#define pb push_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n\nint mnx=200005, mny=200005, mxx=-200005, mxy=-200005;\nvector<pii> flip(vector<pii> &v, pii p){\n\tint l = p.fs;\n\tint r = p.sc;\n\tvector<pii> ret;\n\tfor(auto q: v){\n\t\tint a = q.fs;\n\t\tint b = q.sc;\n\t\tif( a == b ) continue;\n\t\tif( l == r ){\n\t\t\tret.emplace_back( a, b );\n\t\t}else if( r <= a ){\n\t\t\tret.emplace_back( l, r );\n\t\t\tret.emplace_back( a, b );\n\t\t\tl = r;\n\t\t}else if( b <= l ){\n\t\t\t//ret.emplace_back( l, r );\n\t\t\tret.emplace_back( a, b );\n\t\t}else if( a < l && r < b ){\n\t\t\tret.emplace_back( a, l );\n\t\t\tret.emplace_back( r, b );\n\t\t\tl = r;\n\t\t}else if( l <= a && r <= b ){\n\t\t\tret.emplace_back( l, a );\n\t\t\tret.emplace_back( r, b );\n\t\t\tl = r;\n\t\t}else if( l <= a && b <= r ){\n\t\t\tret.emplace_back( l, a );\n\t\t\tl = b;\n\t\t}else if( a < l && l <= b ){\n\t\t\tret.emplace_back( a, l );\n\t\t\tl = b;\n\t\t}\n\t}\n\tif( l != r ) ret.emplace_back(l, r);\n\treturn ret;\n}\n\nll sum(vector<pii> &v, int x){\n\tint l = 2000056;\n\tint r = 2000056;\n\tif( mnx <= x && x < mxx ){\n\t\tl = mny;\n\t\tr = mxy;\n\t}\n\tll ret = 0;\n\tfor(auto q: v){\n\t\tint a = q.fs;\n\t\tint b = q.sc;\n\t\tif( a == b ) continue;\n\t\tif( l == r ){\n\t\t\tret += b - a;\n\t\t}else if( r <= a ){\n\t\t\tret += b - a;\n\t\t}else if( b <= l ){\n\t\t\tret += b - a;\n\t\t}else if( a < l && r < b ){\n\t\t\tret += l - a;\n\t\t\tret += b - r;\n\t\t}else if( l <= a && r <= b ){\n\t\t\tret += b - r;\n\t\t}else if( l <= a && b <= r ){\n\t\t}else if( a < l && l <= b ){\n\t\t\tret += l - a;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint N;\n\twhile(cin >> N, N){\n\t\tvector<pii> v;\n\t\trep(i,N){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tv.emplace_back(x, y);\n\t\t}\n\t\tmnx=200005, mny=200005, mxx=-200005, mxy=-200005;\n\t\trep(i,4){\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tmnx = min(mnx, x);\n\t\t\tmny = min(mny, y);\n\t\t\tmxx = max(mxx, x);\n\t\t\tmxy = max(mxy, y);\n//cout << mnx << \" \" << mxx << endl;\n\t\t}\n\t\tvector<pair<int,pii>> vv;\n\t\tif( v[0].fs != v[1].fs ) v.push_back( v[0] );\n\t\tfor(int i=0; i<v.size()-1; i+=2){\n\t\t\tif( v[i].fs != v[i+1].fs ) i++;\n\t\t\tint a = v[i].sc;\n\t\t\tint b = v[i+1].sc;\n\t\t\tif( a > b ) swap(a, b);\n\t\t\tvv.emplace_back( v[i].fs, pii(a, b) );\n\t\t}\n\t\tsort( vv.begin(), vv.end() );\n\t\t\t\t//cout << \"vv:\"; for(auto t: vv) cout << \"(\" << t.sc.fs << \",\" << t.sc.sc << \") \"; cout << endl;\n\t\tll ans = 0, idx=0;\n\t\tvector<pii> vp;\n\t\tfor(ll x=-20000; x<=20000; x++){\n\t\t\twhile( idx < vv.size() && vv[idx].fs == x ){\n\t\t\t\tvp = flip(vp, vv[idx].sc);\n\t\t\t\tidx++;\n\t\t\t\t//cout << \"flip:\"; for(auto t: vp) cout << \"(\" << t.fs << \",\" << t.sc << \") \"; cout << endl;\n//cout << \"sum: \" << ans << endl;\n\t\t\t}\n\t\t\tans += sum(vp, x);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nint main()\n{\n  int N, x[101], y[101];\n  while(cin >> N, N) {\n    for(int i = 0; i < N; i++) cin >> x[i] >> y[i];\n    x[N] = x[0], y[N] = y[0];\n\n    int a = -INF, b = INF, c = -INF, d = INF;\n    for(int i = 0; i < 4; i++) {\n      int u, t;\n      cin >> u >> t;\n      a = max(a, u), b = min(b, u);\n      c = max(c, t), d = min(d, t);\n    }\n    long long ret1 = 0, ret2 = 0;\n    for(int i = 0; i < N; i++) {\n      if(y[i] == y[i + 1]) {\n        ret2 += 1LL * y[i] * (x[i] - x[i + 1]);\n        ret1 += 1LL * max(d, min(c, y[i])) * (max(b, min(a, x[i])) - max(b, min(a, x[i + 1])));\n      }\n    }\n    cout << ret2 - ret1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(V) V.begin(),V.end()\nusing namespace std;\nusing ll = int64_t;\ntemplate <typename T> using V = vector<T>;\nusing PLL = pair<ll, ll>;\nusing TLL = tuple<ll, ll, ll>;\n\nconst ll inf = 5e15;\n\nvoid sort_and_unique(V<ll> &v) {\n    sort(ALL(v));\n    auto ite = unique(ALL(v));\n    v.erase(ite, v.end());\n}\n\nmap<ll, V<PLL>> create_map(const V<PLL> &shape) {\n    ll N = shape.size();\n    map<ll, V<PLL>> ret;\n    for(ll i = 0; i < N; i++) {\n        PLL p1 = shape[i], p2 = shape[(i + 1) % N];\n        ll x1, y1, x2, y2;\n        tie(x1, y1) = p1;\n        tie(x2, y2) = p2;\n        if(x1 != x2) continue;\n        ret[x1].emplace_back(min(y1, y2), max(y1, y2));\n    }\n\n    for(auto &ele : ret) {\n        ele.second.emplace_back(inf, inf);\n        ele.second.emplace_back(-inf, -inf);\n        sort(ALL(ele.second));\n    }\n\n    return move(ret);\n}\n\nbool check_inside(map<ll, V<PLL>> &mp, ll x, ll y1, ll y2, const V<ll> &xlis) {\n    auto ite = lower_bound(ALL(xlis), x);\n    if(*ite != x) return false;\n    const auto &v = mp[x];\n    PLL yline = *(upper_bound(ALL(v), PLL(y1, inf)) - 1);\n    return yline.first <= y1 && y2 <= yline.second;\n}\n\nbool solve() {\n    ll N;\n    cin >> N;\n\n    if(!N) return false;\n\n    V<PLL> window, curtain;\n    V<ll> xlis, ylis;\n    V<ll> wxlis, cxlis;\n    map<ll, V<PLL>> mp;\n\n    for(ll i = 0; i < N + 4; i++) {\n        ll x, y;\n        cin >> x >> y;\n        (i < N ? window : curtain).emplace_back(x, y);\n        (i < N ? wxlis : cxlis).push_back(x);\n        xlis.push_back(x);\n        ylis.push_back(y);\n    }\n\n    wxlis.push_back(inf);\n    cxlis.push_back(inf);\n\n    sort_and_unique(xlis);\n    sort_and_unique(wxlis);\n    sort_and_unique(cxlis);\n    sort_and_unique(ylis);\n\n    auto window_mp = create_map(window);\n    auto curtain_mp = create_map(curtain);\n\n    ll ans = 0;\n    bool inside_window = false, inside_curtain = false;\n\n    ll px = -inf;\n    for(ll yi = 0; yi < ylis.size() - 1; yi++) {\n        for(ll xi = 0; xi < xlis.size(); xi++) {\n            ll x = xlis[xi];\n            ll y1 = ylis[yi], y2 = ylis[yi + 1];\n            if(inside_window && !inside_curtain) {\n                ans += (y2 - y1) * (x - px);\n            }\n            px = x;\n            if(check_inside(window_mp, x, y1, y2, wxlis)) inside_window = !inside_window;\n            if(check_inside(curtain_mp, x, y1, y2, cxlis)) inside_curtain = !inside_curtain;\n        }\n    }\n\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    while(solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nvoid compress(vi &v){\n  sort(all(v));\n  v.erase(unique(all(v)),v.end());\n}\n\nint idx(int i,vector<int> &c){\n    return lower_bound(all(c),i)-c.begin();\n}\n\nint main(void) {\n    int i,j;\n    int n;\n    while(cin >> n, n){\n        int m = n + 4;\n        vi xx(m), yy(m);\n        vi x(n+1),y(n+1);\n        rep(i,n) cin >> x[i] >> y[i], xx[i] = x[i], yy[i] = y[i];\n        vi rx(4),ry(4);\n        rep(i,4) cin >> rx[i] >> ry[i], xx[n+i] = rx[i], yy[n+i] = ry[i];\n\n        xx.push_back(INF);xx.push_back(-INF);\n        yy.push_back(INF);yy.push_back(-INF);\n        compress(xx);compress(yy);\n\n        x[n] = x[0], y[n] = y[0];\n        int a[200][200]={};\n\n        int ax = -INF, ay = -INF;\n        int ix = INF, iy = INF;\n\n        rep(i,4){\n            ax = max(ax, rx[i]);\n            ay = max(ay, ry[i]);\n            ix = min(ix, rx[i]);\n            iy = min(iy, ry[i]);\n        }\n\n//cout << ax << \" \" << ay << \" \" << ix << \" \" << iy << endl;\n        rep(i,n){\n            if(x[i] < x[i+1]){\n                loop(j,idx(x[i],xx),idx(x[i+1],xx)){\n                    a[j][idx(y[i],yy)]--;\n                }\n            }\n            if(x[i] > x[i+1]){\n                loop(j,idx(x[i+1],xx),idx(x[i],xx)){\n                    a[j][idx(y[i],yy)]++;\n                }\n            }\n        }\n\n        int ans = 0;\n\n        rep(i,199){\n            rep(j,199){\n                a[i][j+1] += a[i][j];\n                if(a[i][j]){\n                    //cout << xx[i+1] <<\" \" << xx[i] << \" \" << yy[j+1] <<\" \" << yy[j] << endl;\n                    if(iy <= yy[j] && yy[j+1] <= ay && ix <= xx[i] && xx[i+1] <= ax) continue;\n\n                    ans += (xx[i+1] - xx[i])*(yy[j+1] - yy[j]);\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i < (int)(b);++i)\n#define long long long\n#define UNIQ(vec) vec.erase(unique(vec.begin(), vec.end()),vec.end()) //ソートの必要あり\n\nint main(void) {\n    while (true) {\n        int N;\n        cin >> N;\n        if(N == 0)return 0;\n        vector<int> X(N);\n        vector<int> Y(N);\n\n        vector<int> CompX;\n        vector<int> CompY;\n        rep(i, N)\n        {\n            cin >> X[i] >> Y[i];\n            CompX.emplace_back(X[i]);\n            CompY.emplace_back(Y[i]);\n        }\n        vector<int> CurtainX(4);\n        vector<int> CurtainY(4);\n        \n\n        rep(i, 4)\n        {\n            cin >> CurtainX[i] >> CurtainY[i];\n            CompX.emplace_back(CurtainX[i]);\n            CompY.emplace_back(CurtainY[i]);\n        }\n        CompX.emplace_back(-30000);\n        CompX.emplace_back(30000);\n        CompY.emplace_back(-30000);\n        CompY.emplace_back(30000);\n\n        sort(CompX.begin(), CompX.end());\n        sort(CompY.begin(), CompY.end());\n        UNIQ(CompX);\n        UNIQ(CompY);\n        // unique(CompX.begin(), CompX.end());\n        // unique(CompY.begin(), CompY.end()); \n\n        sort(CurtainX.begin(), CurtainX.end());\n        sort(CurtainY.begin(), CurtainY.end());\n\n        UNIQ(CurtainX);\n        UNIQ(CurtainY);\n        // unique(CurtainX.begin(), CurtainX.end());\n        // unique(CurtainY.begin(), CurtainY.end()); \n\n        // vec.erase(unique(vec.begin(), vec.end()),vec.end())\n        // cout << CompX.size() << \" \" << CompY.size() << endl;\n        // rep(i,CompX.size())\n        // {\n        //     cout << CompX[i] << endl;\n        // }\n\n        int L = CompX.size();\n        long boxsize = 0;\n        long curtainsize = 0;\n        \n        rep(i, CompY.size() - 1)//縦方向\n        {\n            bool inbox = false;\n            long u = CompY[i + 1];\n            long d = CompY[i];\n            rep(j, CompX.size() - 1)//横方向\n            {\n                long r = CompX[j + 1];\n                long l = CompX[j];\n\n                long size = (u - d) * (r - l);\n                // 箱に入ったかのチェック\n                if(j > 0)\n                {\n                    rep(r, N + 1)\n                    {\n                        int px = X[r];\n                        int py = Y[r];\n                        int qx = X[(r + 1) % N];\n                        int qy = Y[(r + 1) % N];\n                        if(py == qy)continue;\n                        if(px != qx)continue;\n                        //cout << \"ko\" << endl;\n                        if(px == l && min(py,qy) <= d && u <= max(py,qy))\n                        {\n                            //cout << \"ok\" << endl;\n                            inbox = !inbox;\n                            break;\n                        }\n                    }\n                }\n                \n\n                if(inbox)\n                {\n                    boxsize += size;\n                    //cout << boxsize << endl;\n                    if(CurtainX[0] <= l && r <= CurtainX[1] && CurtainY[0] <= d && u <= CurtainY[1])\n                    {\n                        curtainsize += size;\n                    }\n                }\n\n            }\n\n        }\n\n        cout << (boxsize-curtainsize) << \"\\n\";\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nint N, X[104], Y[104], CXL, CYL, CXR, CYR;\nint w, h;\nvector<ll> vx, vy;\n\nint compress(int n, int *p, vector<ll> &s) {\n  REP(i, 0, n) s.push_back(p[i]);\n  sort(s.begin(), s.end());\n  s.erase(unique(s.begin(), s.end()), s.end());\n  return s.size();\n}\n\nbool isin(int x, int y) {\n  return CXL <= x && x <= CXR && CYL <= y && y <= CYR;\n}\n\nbool ok(int xl, int yl, int xr, int yr) {\n  if(isin(xl, yl) && isin(xr, yr)) return false;\n  int x = xl + xr, y = yl + yr;\n  int cx = 0, cy = 0;\n  REP(i, 0, N) {\n    int c = i, n = (i + 1) % N;\n    int x1 = 2 * min(X[c], X[n]), x2 = 2 * max(X[c], X[n]);\n    int y1 = 2 * min(Y[c], Y[n]), y2 = 2 * max(Y[c], Y[n]);\n    if(y1 == y2 && y < y1 && x1 < x && x < x2) cx++;\n    if(x1 == x2 && x < x1 && y1 < y && y < y2) cy++;\n  }\n  return cx % 2 == 1 && cy % 2 == 1;\n}\n\nint main(void) {\n  while(cin >> N, N) {\n    REP(i, 0, N) cin >> X[i] >> Y[i];\n    REP(i, 0, 4) cin >> X[N + i] >> Y[N + i];\n    CXL = min(X[N], min(X[N + 1], min(X[N + 2], X[N + 3])));\n    CYL = min(Y[N], min(Y[N + 1], min(Y[N + 2], Y[N + 3])));\n    CXR = max(X[N], max(X[N + 1], max(X[N + 2], X[N + 3])));\n    CYR = max(Y[N], max(Y[N + 1], max(Y[N + 2], Y[N + 3])));\n    vx.clear();\n    vy.clear();\n    w = compress(N + 4, X, vx);\n    h = compress(N + 4, Y, vy);\n\n    ll ans = 0;\n    REP(i, 0, w - 1) REP(j, 0, h - 1) if(ok(vx[i], vy[j], vx[i + 1], vy[j + 1])) ans += (vx[i + 1] - vx[i]) * (vy[j + 1] - vy[j]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef double D;\ntypedef complex<D> P;\nconst D EPS = 1e-9;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) {  return (conj(a)*b).Y;}\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;\n  if (cross(b,c) < -EPS) return -1;\n  if (dot(b,c)   < -EPS) return +2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isecSS(P a1, P a2, P b1, P b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\nint dp[200][200],n,x,y;\nvector<P>v,car;\nvector<int>vy,vx;\nvoid input(){\n  memset(dp,0,sizeof(dp));\n  v.clear();\n  vx.clear();\n  vy.clear();\n  car.clear();\n  r(i,n){\n    cin>>x>>y;\n    x+=20001;\n    y+=20001;\n    v.push_back(P(x,y));\n    vx.push_back(x);\n    vy.push_back(y);\n  }\n  r(i,4){\n    cin>>x>>y;\n    x+=20001;\n    y+=20001;\n    car.push_back(P(x,y));\n    vx.push_back(x);\n    vy.push_back(y);\n  }\n}\nvoid zaatsu(){\n  sort(vx.begin(),vx.end());\n  vx.erase(unique(vx.begin(),vx.end()),vx.end());\n  sort(vy.begin(),vy.end());\n  vy.erase(unique(vy.begin(),vy.end()),vy.end());\n  r(i,vy.size()-1){\n    r(j,vx.size()-1){\n      dp[i][j]=(vy[i+1]-vy[i])*(vx[j+1]-vx[j]);\n    }\n  }\n}\nint calc(){\n  int ans=0;\n  r(i,vy.size()-1){\n    r(j,vx.size()-1){\n      P st=P(0.5+vx[j],0.5+vy[i]);\n      P go=P(0.5+vx[j],-100);\n      int res=0,f=0;\n      r(k,v.size()){\n        if(isecSS(st,go,v[k],v[(k+1)%v.size()]))res++;\n      }\n      r(k,car.size()){\n        if(isecSS(st,go,car[k],car[(k+1)%car.size()]))f++;\n      }\n      if(res%2&&f%2==0)ans+=dp[i][j];\n    }\n  }\n  return ans;\n}\nint main(){\n  while(cin>>n,n){\n    input();\n    zaatsu();\n    cout<<calc()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint idx(vi a,int c){\n\treturn lower_bound(all(a),c)-a.begin();\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvi x(n+4),y(n+4);\n\t\trep(i,n+4)cin>>x[i]>>y[i];\n\t\tvi X,Y;\n\t\trep(i,n+4)X.pb(x[i]),X.pb(x[i]+1);\n\t\trep(i,n+4)Y.pb(y[i]),Y.pb(y[i]+1);\n\t\tsort(all(X));X.erase(unique(all(X)),X.end());\n\t\tsort(all(Y));Y.erase(unique(all(Y)),Y.end());\n\t\tint N=X.size(),M=Y.size();\n\t\tvvi dp(N,vi(M));\n\t\tint t=1;\n\t\trep(i,n){\n\t\t\tint a=idx(X,x[i]),b=idx(Y,y[i]);\n\t\t\tdp[a][b]=t;\n\t\t\tt*=-1;\n\t\t}\n\t\trep(i,N-1)rep(j,M)dp[i+1][j]+=dp[i][j];\n\t\trep(i,N)rep(j,M-1)dp[i][j+1]+=dp[i][j];\n\t\tint a=min(min(x[n],x[n+1]),min(x[n+2],x[n+3]));\n\t\tint b=max(max(x[n],x[n+1]),max(x[n+2],x[n+3]));\n\t\tint c=min(min(y[n],y[n+1]),min(y[n+2],y[n+3]));\n\t\tint d=max(max(y[n],y[n+1]),max(y[n+2],y[n+3]));\n\t\ta=idx(X,a);b=idx(X,b);c=idx(Y,c);d=idx(Y,d);\n\t\tloop(i,a,b)loop(j,c,d)dp[i][j]=0;\n\t\t\n\t\tll sum=0;\n\t\trep(i,N)rep(j,M)if(dp[i][j])sum+=(ll)(X[i+1]-X[i])*(Y[j+1]-Y[j]);\n\t\tcout<<sum<<endl;\n\t}\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\n#define X first\n#define Y second\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    vector<P> v(n+1),s(4);\n    for(int i=0;i<n;i++) cin>>v[i].X>>v[i].Y;\n    for(int i=0;i<4;i++) cin>>s[i].X>>s[i].Y;\n    vector<int> cx,cy;\n    for(int i=0;i<n;i++) cx.push_back(v[i].X);\n    for(int i=0;i<n;i++) cy.push_back(v[i].Y);\n    for(int i=0;i<4;i++) cx.push_back(s[i].X);\n    for(int i=0;i<4;i++) cy.push_back(s[i].Y);\n    \n    int INF=30000;\n    cx.push_back(INF);cx.push_back(-INF);\n    cy.push_back(INF);cy.push_back(-INF);\n    sort(cx.begin(),cx.end());\n    cx.erase(unique(cx.begin(),cx.end()),cx.end());\n    sort(cy.begin(),cy.end());\n    cy.erase(unique(cy.begin(),cy.end()),cy.end());\n    int w=cx.size(),h=cy.size();\n    map<int,int> mx,my;\n    for(int i=0;i<w;i++) mx[cx[i]]=i;\n    for(int i=0;i<h;i++) my[cy[i]]=i;\n    int imos[h][w];\n    memset(imos,0,sizeof(imos));\n\n    \n    int ax=s[0].X,ay=s[0].Y,ix=s[0].X,iy=s[0].Y;\n    for(int i=0;i<4;i++) ax=max(ax,s[i].X);\n    for(int i=0;i<4;i++) ay=max(ay,s[i].Y);\n    for(int i=0;i<4;i++) ix=min(ix,s[i].X);\n    for(int i=0;i<4;i++) iy=min(iy,s[i].Y);\n\n    \n    v[n]=v[0];\n    for(int i=0;i<n;i++){\n      if(v[i].Y<v[i+1].Y){\n\tfor(int j=my[v[i].Y];j<my[v[i+1].Y];j++){\n\t  imos[j][mx[v[i].X]]--;\n\t}\n      }\n      if(v[i].Y>v[i+1].Y){\n\tfor(int j=my[v[i+1].Y];j<my[v[i].Y];j++){\n\t  imos[j][mx[v[i].X]]++;\n\t}\n      }\n    }\n    //cout<<w<<\" \"<<h<<endl;\n    int ans=0;\n    for(int i=0;i<h-1;i++){\n      for(int j=0;j<w-1;j++){\n\timos[i][j+1]+=imos[i][j];\n\t//cout<<imos[i][j];\n\tif(imos[i][j]){\n\t  if(iy<=cy[i]&&cy[i+1]<=ay&&ix<=cx[j]&&cx[j+1]<=ax) continue;\n\t  ans+=(cy[i+1]-cy[i])*(cx[j+1]-cx[j]);\n\t}\n      }\n      //cout<<endl;\n    }\n    cout<<ans<<endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Geometry_Library\n#define ___Geometry_Library\n\n// ------ Includes ------ //\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <algorithm>\n\n// ------ Defines ------ //\ntypedef long double GType;\ntypedef std::complex<GType> Point;\ntypedef std::pair<Point, Point> Segment;\n\n// ------ Constants ------ //\nconst GType EPS = 1.0e-10L;\n\n// ------ Functions Level 1 ------ //\nGType dot(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).real();\n}\nGType cross(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).imag();\n}\nint ccw(const Point& p1, const Point& p2, const Point& p3) {\n\tPoint v1 = p2 - p1, v2 = p3 - p1;\n\tif (cross(v1, v2) > EPS) return +1;\n\tif (cross(v1, v2) < -EPS) return -1;\n\tif (dot(v1, v2) < -EPS) return +2;\n\tif (std::norm(v1) < std::norm(v2)) return -2;\n\treturn 0;\n}\n\n// ------ Functions Level 2 ------ //\nbool intersect(const Segment& s1, const Point& p1, bool segflag) {\n\tif (!segflag) return std::abs(cross(s1.second - p1, s1.first - p1)) < EPS;\n\treturn (std::abs(s1.first - p1) + std::abs(s1.second - p1) - std::abs(s1.second - s1.first)) < EPS;\n}\nbool intersect(const Segment& s1, const Segment& s2, bool segflag) {\n\tif (!segflag) return cross(s1.second - s1.first, s2.first - s1.first) * cross(s1.second - s1.first, s2.second - s1.first) < EPS;\n\treturn (ccw(s1.first, s1.second, s2.first) * ccw(s1.first, s1.second, s2.second) <= 0 && ccw(s2.first, s2.second, s1.first) * ccw(s2.first, s2.second, s1.second) <= 0);\n}\nPoint projection(const Segment& s1, const Point& p1) {\n\tGType mul = dot(p1 - s1.first, s1.first - s1.second) / norm(s1.first - s1.second);\n\treturn s1.first + (s1.first - s1.second) * mul;\n}\nPoint reflection(const Segment& s1, const Point& p1) {\n\treturn p1 + (projection(s1, p1) - p1) * (GType)(2);\n}\nGType distance(const Point& p1, const Point& p2) {\n\treturn std::abs(p2 - p1);\n}\nGType distance(const Segment& s1, const Point& p1, bool segflag) {\n\tif (!segflag) return std::abs(p1 - projection(s1, p1));\n\tconst Point p2 = projection(s1, p1);\n\tif (intersect(s1, p2, true)) return std::abs(p2 - p1);\n\treturn std::min(std::abs(s1.first - p1), std::abs(s1.second - p1));\n}\nGType distance(const Segment& s1, const Segment& s2, bool segflag) {\n\tif (intersect(s1, s2, segflag)) return 0;\n\tif (!segflag) return std::min(distance(s1, s2.first, false), distance(s1, s2.second, false));\n\treturn std::min({ distance(s1, s2.first, true), distance(s1, s2.second, true), distance(s2, s1.first, true), distance(s2, s1.second, true) });\n}\nPoint crosspoint(const Segment& s1, const Segment& s2) {\n\tGType r1 = cross(s1.second - s1.first, s2.second - s2.first);\n\tGType r2 = cross(s1.second - s1.first, s1.second - s2.first);\n\tif (std::abs(r1) < EPS && std::abs(r2) < EPS) return s2.first;\n\treturn s2.first + r2 / r1 * (s2.second - s2.first);\n}\n\n// ------ Functions Level 3 ------ //\nGType area(std::vector<Point> v) {\n\tGType ret = 0;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tif (i + 1 != v.size()) ret += cross(v[i], v[i + 1]);\n\t\telse ret += cross(v[i], v[0]);\n\t}\n\treturn std::abs(ret / 2);\n}\nbool convex(std::vector<Point> v) {\n\tif (v.size() < 3) return false;\n\tint s = -3;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tint r = ccw(v[i], v[(i != 0 ? i - 1 : v.size() - 1)], v[(i + 1 != v.size() ? i + 1 : 0)]);\n\t\tif (abs(r) == 1 && s == -3) s = r;\n\t\tif (s * r == -1) return false;\n\t}\n\treturn true;\n}\nint contain(std::vector<Point> v, Point p) {\n\tbool in = false;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tPoint a = v[i] - p, b = v[(i + 1 != v.size() ? i + 1 : 0)] - p;\n\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\tif (a.imag() <= EPS && EPS < b.imag() && cross(a, b) < -EPS) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\nstd::vector<Point> convex_hull(std::vector<Point> v) {\n\tif (v.size() < 3) return v;\n\tstruct sorter {\n\t\tbool operator()(const Point& p1, const Point& p2) const {\n\t\t\treturn p1.real() < p2.real();\n\t\t}\n\t};\n\tstd::sort(v.begin(), v.end(), sorter());\n\tstd::vector<Point> u = { v[0], v[1] }, l = { v[v.size() - 1], v[v.size() - 2] };\n\tfor (int i = 2; i < v.size(); i++) {\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], v[i]) >= 0; n--) u.pop_back();\n\t\tu.push_back(v[i]);\n\t}\n\tfor (int i = v.size() - 3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], v[i]) >= 0; n--) l.pop_back();\n\t\tl.push_back(v[i]);\n\t}\n\tstd::reverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\n#endif\n\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, cx, cy;\nint main() {\n\twhile (cin >> n, n) {\n\t\tvector<Point> v(n);\n\t\tvector<int> sx, sy;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> cx >> cy;\n\t\t\tv[i] = Point(cx, cy);\n\t\t\tsx.push_back(cx);\n\t\t\tsy.push_back(cy);\n\t\t}\n\t\tvector<int> rx(4), ry(4);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcin >> rx[i] >> ry[i];\n\t\t}\n\t\tint xa = *min_element(rx.begin(), rx.end());\n\t\tint ya = *min_element(ry.begin(), ry.end());\n\t\tint xb = *max_element(rx.begin(), rx.end());\n\t\tint yb = *max_element(ry.begin(), ry.end());\n\t\tsx.push_back(xa);\n\t\tsy.push_back(ya);\n\t\tsx.push_back(xb);\n\t\tsy.push_back(yb);\n\t\tsort(sx.begin(), sx.end());\n\t\tsx.erase(unique(sx.begin(), sx.end()), sx.end());\n\t\tsort(sy.begin(), sy.end());\n\t\tsy.erase(unique(sy.begin(), sy.end()), sy.end());\n\t\tint ptlx = lower_bound(sx.begin(), sx.end(), xa) - sx.begin();\n\t\tint ptly = lower_bound(sy.begin(), sy.end(), ya) - sy.begin();\n\t\tint ptrx = lower_bound(sx.begin(), sx.end(), xb) - sx.begin();\n\t\tint ptry = lower_bound(sy.begin(), sy.end(), yb) - sy.begin();\n\t\tint ret = 0;\n\t\tfor (int i = ptlx + 1; i <= ptrx; i++) {\n\t\t\tfor (int j = ptly + 1; j <= ptry; j++) {\n\t\t\t\tdouble mx = (sx[i - 1] + sx[i]) * 0.5, my = (sy[j - 1] + sy[j]) * 0.5;\n\t\t\t\tif (contain(v, Point(mx, my))) ret += (sx[i] - sx[i - 1]) * (sy[j] - sy[j - 1]);\n\t\t\t}\n\t\t}\n\t\tint res = (int)(area(v) + 0.5);\n\t\tcout << res - ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <iostream>\n#include <map>\n#include <vector>\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> Poly;\ntypedef pair<P,P> L;\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble dot(P a, P b){return a.X*b.X + a.Y*b.Y;}\n\ndouble cross(P a, P b){return a.X*b.Y - a.Y*b.X;}\n\nint ccw(P a, P b, P c){\n  b -= a;c -= a;\n  if(cross(b, c) > EPS) return 1;\n  if(cross(b, c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(c) - norm(b) > EPS) return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  if(ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0 &&\n     ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0) return true;\n  return false;\n}\n\n\nP intersection(L a, L b){\n  //テァツ崢エテァツキツ啾テ」ツ?ィテァツ崢エテァツキツ喘テ」ツ?ョテ、ツコツ、テァツつケ\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nint in_poly(P a, Poly p){\n  int n = p.size(), c = 0;\n  for(int i = 0; i < n; ++i){\n    P s = p[i]-a, t = p[(i+1)%n]-a;\n    if(!ccw(s,t,P(0,0))) return 1;//ティツセツコテ、ツクツ?\n    if(s.Y > t.Y + EPS) swap(s,t);\n    if((s.Y*t.Y < 0 || (s.Y*t.Y < EPS && t.Y > EPS)) && cross(s,t) < EPS) ++c;\n  }\n  if(c%2) return 2;//テ・ツ??ゥツδィ\n  return 0;//テ・ツ、ツ姪ゥツδィ\n}\n\n\nint main(){\n  int N;\n  map<int, int> M_x, M_y;\n  while(cin >> N, N){\n    double x, y;\n    Poly W;\n    for(int i = 0; i < N; ++i){\n      cin >> x >> y;\n      W.push_back(P(x,y));\n      M_x[(int)x] = 0;\n      M_y[(int)y] = 0;\n    }\n    Poly C;\n    for(int i = 0; i < 4; ++i){\n      cin >> x >> y;\n      C.push_back(P(x,y));\n      M_x[(int)x] = 0;\n      M_y[(int)y] = 0;\n    }\n    int k = 0;\n    vector<int> V_x;\n    for(auto p: M_x){\n      p.second = k++;\n      V_x.push_back(p.first);\n    }\n    k = 0;\n    vector<int> V_y;\n    for(auto p: M_y){\n      p.second = k++;\n      V_y.push_back(p.first);\n    }\n    int n_x = V_x.size(), n_y = V_y.size();\n    long long int ans = 0LL;\n    for(int i = 1; i < n_x; ++i){\n      for(int j = 1; j < n_y; ++j){\n\tP p = P((double)(V_x[i]+V_x[i-1])/2.0, (double)(V_y[j]+V_y[j-1])/2.0);\n\tif(in_poly(p,W) && !in_poly(p,C)) ans += (V_x[i]-V_x[i-1])*(V_y[j]-V_y[j-1]);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define REP(i,n,N) for(ll i=(n);i<(N);i++)\n#define RREP(i,n,N) for(ll i=(N-1);i>=(n);i--)\n#define p(s) cout<<(s)<<endl\n#define CK(n,a,b) ((a)<=(n)&&(n)<(b))\ntypedef long long ll;\nconst ll mod =1e9+7;\nconst ll inf =1e18;\nusing namespace std;\nll N;\nll x[110], y[110];\nll carty[4], cartx[4];\nll cxs, cxb, cys, cyb;\nll compfield[40010][110];\nint main(){\n    while(cin>>N && N != 0){\n        vector<ll> vx;\n        REP(i,0,N + 4){\n            cin>>x[i]>>y[i];\n            vx.push_back(x[i]);\n            if(i >= N){\n                cartx[i - N] = x[i];\n                carty[i - N] = y[i];\n            }\n        }\n//        ll test[110];\n//        memcpy(test, x, sizeof(test));\n        //cout<<\"========\"<<endl;\n        /*\n        REP(i,0,N){\n            cout<<x[i]<<\", \"<<y[i]<<endl;\n        }*/\n        //カーテンの座標\n        sort(cartx, cartx+4);\n        sort(carty, carty+4);\n        cxs = cartx[0];\n        cxb = cartx[3];\n        cys = carty[0];\n        cyb = carty[3];\n        //\n        //cout<<\"test1\"<<endl;\n        //座圧\n        sort(vx.begin(), vx.end());\n        vx.erase(unique(vx.begin(), vx.end()), vx.end());\n        //\n        //cout<<\"test___1___1\"<<endl;\n        map<ll, ll> xzip;\n        map<ll, ll> xunzip;\n        //\n        //cout<<\"test___1___2\"<<endl;\n        REP(i,0,vx.size()){\n            xzip[vx[i]] = i;\n            xunzip[i] = vx[i];\n            //p(xunzip[i]);\n        }\n        //\n        //cout<<\"test2\"<<endl;\n        //窓の頂点チェック\n        //初期化\n        REP(i,0,40010){\n            REP(j,0,110){\n                compfield[i][j] = 0;\n            }\n        }\n        //\n        //cout<<\"test3\"<<endl;\n        REP(i,1,N){\n            if(y[i] - y[i-1] < 0){\n                REP(j,y[i] + 20000, y[i-1] + 20000) compfield[j][ xzip[x[i]] ]++;  //yが異なるならxは必ず同じ\n            }else if(y[i] - y[i-1] > 0){\n                REP(j,y[i-1] + 20000, y[i] + 20000) compfield[j][ xzip[x[i]] ]--;\n            }\n        }\n        if(y[0] - y[N-1] < 0){\n            REP(j,y[0] + 20000, y[N-1] + 20000) compfield[j][ xzip[x[0]] ]++;  //yが異なるならxは必ず同じ\n        }else if(y[0] - y[N-1] > 0){\n            REP(j,y[N-1] + 20000, y[0] + 20000) compfield[j][ xzip[x[0]] ]--;\n        }\n\n        //\n        //cout<<\"test4\"<<endl;\n        //塗る\n        REP(i,0,40010){\n            REP(j,1,xzip.size()){\n                compfield[i][j] += compfield[i][j-1];\n            }\n        }\n\n\n        //カーテンチェック\n        REP(i,cys+20000,cyb+20000){\n            REP(j,xzip[cxs],xzip[cxb]){\n                //cout<<i<<\", \"<<j<<endl;\n                compfield[i][j] = 0;    //カーテンで覆われている。\n            }\n        }\n\n        ll ans = 0;\n        REP(i,0,40010){\n            REP(j,0,xzip.size()-1){\n                if(compfield[i][j] > 0){\n                    ans += xunzip[j+1] - xunzip[j];\n                }\n            }\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin >> N, N){\n\tvector<PII> ps(N);\n\tVI xs_, ys_;\n\tREP(i,N){\n\t  cin >> ps[i];\n\t  xs_.EB(ps[i].FF);\n\t  ys_.EB(ps[i].SS);\n\t}\n\tvector<PII> cs(4);\n\tREP(i,4){\n\t  cin >> cs[i];\n\t  xs_.EB(cs[i].FF);\n\t  ys_.EB(cs[i].SS);\n\t}\n\n\tSORT(xs_);\n\tSORT(ys_);\n\tUNIQ(xs_);\n\tUNIQ(ys_);\n\tint MX = SZ(xs_);\n\tint MY = SZ(ys_);\n\tmap<int,int> zxs, zys;\n\tREP(i,MX)\n\t  zxs[xs_[i]] = i;\n\tREP(i,MY)\n\t  zys[ys_[i]] = i;\n\n\tREP(i,N){\n\t  ps[i].FF = zxs[ps[i].FF];\n\t  ps[i].SS = zys[ps[i].SS];\n\t}\n\tREP(i,4){\n\t  cs[i].FF = zxs[cs[i].FF];\n\t  cs[i].SS = zys[cs[i].SS];\n\t}\n\n\tauto isin = [](vector<PII>& ps, const PII& p){\n\t  int cnt = 0;\n\t  for(int i=0;i<SZ(ps);++i){\n\t\tint i1 = i, i2 = (i+1) % SZ(ps);\n\t\tif(ps[i1].FF != ps[i2].FF) continue;\n\t\tif(p.FF < ps[i1].FF &&\n\t\t   ((ps[i1].SS <= p.SS && p.SS < ps[i2].SS)\n\t\t\t|| (ps[i2].SS <= p.SS && p.SS < ps[i1].SS)))\n\t\t  ++cnt;\n\t  }\n\t  return cnt%2 == 1;\n\t};\n\n\tvector<vector<bool>> dom(MY, vector<bool>(MX));\n\tfor(int y=0;y<MY;++y){\n\t  for(int x=0;x<MX;++x){\n\t\tif(isin(ps, MP(x,y)) && !isin(cs, MP(x,y))){\n\t\t  dom[y][x] = true;\n\t\t}\n\t  }\n\t}\n\tint ans = 0;\n\tREP(y,MY) REP(x,MX)\n\t  if(dom[y][x]){\n\t\tans += (xs_[x+1] - xs_[x]) * (ys_[y+1] - ys_[y]);\n\t  }\n\tcout << ans << endl;\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\nint dy[] = {0, 1, 0, -1},\n    dx[] = {-1, 0, 1, 0};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n        vector<LL> x(n), y(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> x[i] >> y[i];\n        }\n        map<LL,int> compx, compy;\n        for (int i = 0; i < n; ++i) {\n            compx[x[i]] = -1;\n            compy[y[i]] = -1;\n        }\n        int cntx = 0, cnty = 0;\n        for (auto& tp : compx) {\n            tp.second = cntx++;\n        }\n        for (auto& tp : compy) {\n            tp.second = cnty++;\n        }\n\n        vector<LL> posx, posy;\n        for (const auto& tp : compx) {\n            posx.push_back(tp.first);\n        }\n        for (const auto& tp : compy) {\n            posy.push_back(tp.first);\n        }\n\n        LL l = 20000, r = -20000, t = -20000, b = 20000;\n        for (int k = 0; k < 4; ++k) {\n            LL p, q; cin >> p >> q;\n            chmax(r, p); chmin(l, p);\n            chmax(t, q); chmin(b, q);\n        }\n\n        auto sumy = make_v<int>(cnty, cntx + 1),\n             sumx = make_v<int>(cnty + 1, cntx);\n        for (int i = 0; i < n; ++i) {\n            int px = compx[x[i]], qx = compx[x[(i+1)%n]],\n                py = compy[y[i]], qy = compy[y[(i+1)%n]];\n            if (px == qx) {\n                if (py > qy) swap(py, qy);\n                for (int t = py; t < qy; ++t) {\n                    sumy[t][px + 1] += 1;\n                }\n            }\n            else {\n                if (px > qx) swap(px, qx);\n                for (int t = px; t < qx; ++t) {\n                    sumx[py + 1][t] += 1;\n                }\n            }\n        }\n\n        for (int i = 0; i < cnty; ++i) {\n            for (int j = 0; j < cntx; ++j) {\n                sumy[i][j+1] += sumy[i][j];\n                sumx[i+1][j] += sumx[i][j];\n            }\n        }\n\n        LL ans = 0;\n        for (int i = 0; i < cntx - 1; ++i) {\n            for (int j = 0; j < cnty - 1; ++j) {\n                if (sumx[j+1][i] & 1 and sumy[j][i+1] & 1) {\n                    LL px = posx[i], py = posy[j],\n                       qx = posx[i+1], qy = posy[j+1];\n\n                    LL h = max(min(t, qy) - max(b, py), (LL)0),\n                       w = max(min(r, qx) - max(l, px), (LL)0);\n\n                    ans += (qx - px) * (qy - py) - h * w;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nconst ll dx[4] = {0, 1, 0, -1};\nconst ll dy[4] = {-1, 0, 1, 0};\n\nll get_dir(ll x1, ll y1, ll x2, ll y2) {\n    assert(x1 == x2 || y1 == y2);\n    ll len = abs(x1 - x2) + abs(y1 - y2);\n    rep(i, 4) {\n        if (x1 + dx[i] * len == x2 && y1 + dy[i] * len == y2) {\n            return i;\n        }\n    }\n    assert(false);\n    return -1;\n}\n\nvector<vector<bool>> get_pol(const vector<ll>& xin, const vector<ll>& yin, map<ll, ll>& xid, map<ll, ll>& yid) {\n    const ll n = xin.size();\n    assert(yin.size() == n);\n    const ll w = xid.size();\n    const ll h = yid.size();\n    auto inRange = [&](ll x, ll y) {\n        return 0 <= x && x < w && 0 <= y && y < h;\n    };\n    // 外周を塗りつぶす\n    vector<vector<bool>> edge(h, vector<bool>(w, false));\n    rep(i, n) {\n        ll x1 = xin[i], y1 = yin[i];\n        ll x2 = xin[(i+1)%n], y2 = yin[(i+1)%n];\n        ll dir = get_dir(x1, y1, x2, y2);\n        ll rdir = (dir+2)%2;\n        ll xid1 = xid[x1], yid1 = yid[y1];\n        ll xid2 = xid[x2], yid2 = yid[y2];\n        ll x = xid1, y = yid1;\n        // cout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << \" \" << dir << endl;\n        while (true) {\n            edge[y][x] = true;\n            if (x == xid2 && y == yid2) break;\n            x += dx[dir];\n            y += dy[dir];\n        }\n    }\n    // 外から塗り潰していく\n    vector<vector<bool>> res(h, vector<bool>(w, true));\n    function<void(ll, ll)> fill = [&](ll x, ll y) {\n        assert(!edge[y][x]);\n        rep(d, 4) {\n            ll nx = x + dx[d];\n            ll ny = y + dy[d];\n            if (inRange(nx, ny) && res[ny][nx] && !edge[ny][nx]) {\n                res[ny][nx] = false;\n                fill(nx, ny);\n            }\n        }\n    };\n    res[0][0] = false;\n    fill(0, 0); // (-inf, -inf)\n    rep(y, h) rep(x, w) {\n        if (res[y][x] && (!res[y][x+1] || !res[y+1][x])) {\n            res[y][x] = false;\n        }\n    }\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n;\n    while ( cin >> n, n ) {\n        vector<ll> xin(n), yin(n);\n        rep(i, n) cin >> xin[i] >> yin[i];\n        vector<ll> a(4), b(4);\n        rep(i, 4) cin >> a[i] >> b[i];\n        // 座圧\n        map<ll, ll> X, Y;\n        X[-inf]; X[inf];\n        Y[-inf]; Y[inf];\n        rep(i, n) rep(d, -1, 2) {\n            X[xin[i]+d];\n            Y[yin[i]+d];\n        }\n        rep(i, 4) rep(d, -1, 2) {\n            X[a[i]+d];\n            Y[b[i]+d];\n        }\n        ll k = 0; EACH(p, X) p.second = k++;\n        k = 0; EACH(p, Y) p.second = k++;\n        vector<vector<bool>> m1 = get_pol(xin, yin, X, Y);\n        vector<vector<bool>> m2 = get_pol(a, b, X, Y);\n        // cout << m1 << endl << endl;\n        // cout << m2 << endl << endl;\n        vector<ll> X0(X.size());\n        vector<ll> Y0(Y.size());\n        EACH(p, X) X0[p.second] = p.first;\n        EACH(p, Y) Y0[p.second] = p.first;\n        ll ans = 0;\n        ll h = m1.size(), w = m1[0].size();\n        vector<vector<bool>> m(h, vector<bool>(w));\n        rep(i, h) rep(j, w) {\n            m[i][j] = m1[i][j] && !m2[i][j];\n        }\n        // cout << X0 << endl;\n        // cout << Y0 << endl;\n        rep(i, h) rep(j, w) {\n            if (m[i][j]) {\n                assert(1 < i && i < h-1);\n                assert(1 < j && j < w-1);\n                ll ww = m[i][j+1] ? X0[j+1]-X0[j] : 1;\n                ll hh = m[i+1][j] ? Y0[i+1]-Y0[i] : 1;\n                ans += ww * hh;\n            }\n        }\n        // ll cnt = 0;\n        // rep(y, h) rep(x, w) {\n        //     if (!m[i][j]) continue;\n        //     ll c = 0;\n        //     rep(d, 4) {\n        //         ll nx = x + dx[d];\n        //         ll ny = y + dy[d];\n        //         if (!m[ny][nx]) ++c;\n        //     }\n        //     assert(c != 3);\n\n        // }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct Line {\n\tll lx, rx, y;\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\twhile(cin >> N, N) {\n\t\tvector<ll> x(N), y(N);\n\t\tvector<ll> xs;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t\txs.push_back(x[i]);\n\t\t}\n\n\t\tvector<ll> ax(4), ay(4);\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tcin >> ax[i] >> ay[i];\n\t\t\txs.push_back(ax[i]);\n\t\t}\n\t\tsort(xs.begin(), xs.end());\n\t\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n\t\tvector<Line> ls, cls;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tif(y[i] == y[(i + 1) % N]) {\n\t\t\t\tll lx = min(x[i], x[(i + 1) % N]);\n\t\t\t\tll rx = max(x[i], x[(i + 1) % N]);\n\t\t\t\tls.push_back({ lx, rx, y[i] });\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tif(ay[i] == ay[(i + 1) % 4]) {\n\t\t\t\tll lx = min(ax[i], ax[(i + 1) % N]);\n\t\t\t\tll rx = max(ax[i], ax[(i + 1) % N]);\n\t\t\t\tcls.push_back({ lx, rx, ay[i] });\n\t\t\t}\n\t\t}\n\n\t\ttypedef pair<ll, int> P; // <y, curtain>\n\n\t\tll ans = 0;\n\t\tfor(int i = 0; i < (int)xs.size() - 1; i++) {\n\t\t\tll lx = xs[i], rx = xs[i + 1];\n\t\t\tll w = xs[i + 1] - xs[i];\n\t\t\tvector<P> ys;\n\t\t\tfor(auto l : ls) {\n\t\t\t\tif(l.lx <= lx && rx <= l.rx) {\n\t\t\t\t\tys.push_back({ l.y, 0 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(auto l : cls) {\n\t\t\t\tif(l.lx <= lx && rx <= l.rx) {\n\t\t\t\t\tys.push_back({ l.y, 1 });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsort(ys.begin(), ys.end());\n\t\t\tbool in = false, in_curtain = false;\n\t\t\tfor(int j = 0; j < (int)ys.size() - 1; j++) {\n\t\t\t\tif(ys[j].second) {\n\t\t\t\t\tin_curtain = !in_curtain;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tin = !in;\n\t\t\t\t}\n\t\t\t\tif(in && !in_curtain) {\n\t\t\t\t\tans += w * abs(ys[j].first - ys[j + 1].first);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nint N, X[104], Y[104], CXL, CYL, CXR, CYR;\nint w, h;\nvector<ll> vx, vy;\n\nint compress(int n, int *p, vector<ll> &s) {\n  REP(i, 0, n) s.push_back(p[i]);\n  sort(s.begin(), s.end());\n  s.erase(unique(s.begin(), s.end()), s.end());\n  return s.size();\n}\n\nbool isin(int x, int y) {\n  return CXL <= x && x <= CXR && CYL <= y && y <= CYR;\n}\n\nbool ok(int xl, int yl, int xr, int yr) {\n  if(isin(xl, yl) && isin(xr, yr)) return false;\n  int x = xl + xr, y = yl + yr;\n  int cx = 0, cy = 0;\n  REP(i, 0, N) {\n    int c = i, n = (i + 1) % N;\n    int x1 = 2 * min(X[c], X[n]), x2 = 2 * max(X[c], X[n]);\n    int y1 = 2 * min(Y[c], Y[n]), y2 = 2 * max(Y[c], Y[n]);\n    if(y1 == y2 && y < y1 && x1 < x && x < x2) cx++;\n    if(x1 == x2 && x < x1 && y1 < y && y < y2) cy++;\n  }\n  return cx % 2 == 1 && cy % 2 == 1;\n}\n\nint main(void) {\n  while(cin >> N, N) {\n    REP(i, 0, N) cin >> X[i] >> Y[i];\n    REP(i, 0, 4) cin >> X[N + i] >> Y[N + i];\n    CXL = min(X[N], min(X[N + 1], min(X[N + 2], X[N + 3])));\n    CYL = min(Y[N], min(Y[N + 1], min(Y[N + 2], Y[N + 3])));\n    CXR = max(X[N], max(X[N + 1], max(X[N + 2], X[N + 3])));\n    CYR = max(Y[N], max(Y[N + 1], max(Y[N + 2], Y[N + 3])));\n    vx.clear();\n    vy.clear();\n    w = compress(N + 4, X, vx);\n    h = compress(N + 4, Y, vy);\n\n    ll ans = 0;\n    REP(i, 0, w - 1) REP(j, 0, h - 1) if(ok(vx[i], vy[j], vx[i + 1], vy[j + 1])) ans += (vx[i + 1] - vx[i]) * (vy[j + 1] - vy[j]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef complex<double> Point;\n\nint n;\nvector<Point> poly;\nint lx, ly, rx, ry;\n\ndouble area(vector<Point> poly) {\n\tdouble ret = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint ni = (i + 1) % n;\n\t\tret += poly[i].real() * poly[ni].imag() - poly[ni].real() * poly[i].imag();\n\t}\n\tret /= 2;\n\treturn ret;\n}\n\nint main() {\n\tint i;\n\t\n\twhile (cin >> n) {\n\t\tif (n == 0) break;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tpoly.push_back(Point((double)x, (double)y));\n\t\t}\n\t\t\n\t\tlx = ly = 50000;\n\t\trx = ry = -50000;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tlx = min(lx, x);\n\t\t\tly = min(ly, y);\n\t\t\trx = max(rx, x);\n\t\t\try = max(ry, y);\n\t\t}\n\t\t\n\t\tvector<Point> poly2;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tdouble x, y;\n\t\t\tx = min((double)rx, max((double)lx, poly[i].real()));\n\t\t\ty = min((double)ry, max((double)ly, poly[i].imag()));\n\t\t\tpoly2.push_back(Point(x, y));\n\t\t}\n\t\t\n\t\tcout << (int)(area(poly) - area(poly2)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ndouble x[105], y[105], a[4], b[4];\n\n//point\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n// line\nstruct L : public vector<P> {\n\tL(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\t\t\t\t\t\t\t\t  // a--c--b on line\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\n// polygon\ntypedef vector<P> G;\n\nenum { OUT, ON, IN };\nint contains(const G& po, const P& p) {\n  bool in = false;\n  for (int i = 0; i < po.size(); ++i) {\n  \tP a = po[i] - p, b = po[(i+1)%po.size()] - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\ndouble area2(const G& po) {\n\tdouble A = 0;\n  \tfor (int i = 0; i < po.size(); ++i)\n    \tA += cross(po[i], po[(i+1)%po.size()]);\n\t//?????????|????????????????????????????????????????????????\n  \treturn A/2;\n}\n\nP p[105];\nvector<L> l;\nsigned main(void)\n{\n  while(true) {\n    int n;\n    cin >> n;\n    if(!n) break;\n\n    G all;\n    REP(i, n) {\n      cin >> x[i] >> y[i];\n      p[i] = P{x[i], y[i]};\n      all.PB(p[i]);\n    }\n    vector<pair<double, double>> c[2];\n    // right 0 ue 1 left 2 sita 3\n    int d[4];\n    REP(i, 4) cin >> a[i] >> b[i];\n    REP(i, 4) {\n      if(a[i] == a[(i+1)%4]) {\n        if(c[0].size() == 0) c[0].PB(MP(a[i], i));\n        else {\n          if(c[0][0].first > a[i]) d[i] = 2, d[(int)c[0][0].second] = 0;\n          else d[i] = 0, d[(int)c[0][0].second] = 2;\n        }\n      } else {\n        if(c[1].size() == 0) c[1].PB(MP(b[i], i));\n        else {\n          if(c[1][0].first > b[i]) d[i] = 3, d[(int)c[1][0].second] = 1;\n          else d[i] = 1, d[(int)c[1][0].second] = 3;\n        }\n      }\n    }\n    //REP(i, 4) cout << d[i] << \" \"; cout << endl;\n\n    REP(i, 4) {\n      REP(j, n) {\n        if(d[i] == 0) {\n          x[j] = min(x[j], a[i]);\n        } else if(d[i] == 1) {\n          y[j] = min(y[j], b[i]);\n        } else if(d[i] == 2) {\n          x[j] = max(x[j], a[i]);\n        } else {\n          y[j] = max(y[j], b[i]);\n        }\n      }\n    }\n    G in;\n    REP(i, n) {\n      //cout << x[i] << \" \" << y[i] << endl;\n      in.PB(P{x[i], y[i]});\n    }\n\n    //cout << area2(all) << \" \" << area2(in) << endl;\n    cout << (ll)area2(all) - (ll)area2(in) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf 1e18\n#define eps (1e-6)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\ndouble getPolygonArea(Polygon p){\n  double area=0.0;\n  int n=p.size();\n  for(int i=0;i<n;i++)area+=cross(p[i%n],p[(i+1)%n]);\n  return area/2.0;\n}\n\nPolygon convex_cut(Polygon p,Line l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0)\n      ans.push_back(getCrossPointLL(l,Segment(A,B)));\n  }\n  return ans;\n}\n\ndouble getArea(Polygon t,Polygon s){\n  bool flag=true;\n  if(ccw(t[0],t[1],t[2])==-1){\n    reverse(t.begin(),t.end());\n    flag=false;\n  }\n  FOR(i,0,s.size()){\n    Point a=s[i],b=s[(i+1)%s.size()];\n    t=convex_cut(t,Line(a,b));\n  }\n  double res=getPolygonArea(t);\n  if(flag)return res;\n  return -res;\n}\n\ndouble getCommonArea(Polygon p,Polygon s){\n  int n=p.size();\n  double res=0.0;\n  Point a=p[0];\n  FOR(i,1,n-1){\n    Point b=p[i],c=p[(i+1)%n];\n    Polygon t;\n    t.pb(a);t.pb(b);t.pb(c);\n    res+=getArea(t,s);\n  }\n  return res;\n}\n\nint main()\n{\n  int n;\n\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    Polygon p;\n    FOR(i,0,n){\n      int x,y;\n      cin>>x>>y;\n      p.pb(Point(x,y));\n    }\n    Polygon s;\n    FOR(i,0,4){\n      int x,y;\n      cin>>x>>y;\n      s.pb(Point(x,y));\n    }\n    cout<<(int)getPolygonArea(p)-(int)getCommonArea(p,s)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct Line {\n\tll lx, rx, y;\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\twhile(cin >> N, N) {\n\t\tvector<ll> x(N), y(N);\n\t\tvector<ll> xs;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t\txs.push_back(x[i]);\n\t\t}\n\n\t\tvector<ll> ax(4), ay(4);\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tcin >> ax[i] >> ay[i];\n\t\t\txs.push_back(ax[i]);\n\t\t}\n\t\tsort(xs.begin(), xs.end());\n\t\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n\t\tvector<Line> ls, cls;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tif(y[i] == y[(i + 1) % N]) {\n\t\t\t\tll lx = min(x[i], x[(i + 1) % N]);\n\t\t\t\tll rx = max(x[i], x[(i + 1) % N]);\n\t\t\t\tls.push_back({ lx, rx, y[i] });\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tif(ay[i] == ay[(i + 1) % 4]) {\n\t\t\t\tll lx = min(ax[i], ax[(i + 1) % 4]);\n\t\t\t\tll rx = max(ax[i], ax[(i + 1) % 4]);\n\t\t\t\tcls.push_back({ lx, rx, ay[i] });\n\t\t\t}\n\t\t}\n\n\t\ttypedef pair<ll, int> P; // <y, curtain>\n\n\t\tll ans = 0;\n\t\tfor(int i = 0; i < (int)xs.size() - 1; i++) {\n\t\t\tll lx = xs[i], rx = xs[i + 1];\n\t\t\tll w = xs[i + 1] - xs[i];\n\t\t\tvector<P> ys;\n\t\t\tfor(auto l : ls) {\n\t\t\t\tif(l.lx <= lx && rx <= l.rx) {\n\t\t\t\t\tys.push_back({ l.y, 0 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(auto l : cls) {\n\t\t\t\tif(l.lx <= lx && rx <= l.rx) {\n\t\t\t\t\tys.push_back({ l.y, 1 });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsort(ys.begin(), ys.end());\n\t\t\tbool in = false, in_curtain = false;\n\t\t\tfor(int j = 0; j < (int)ys.size() - 1; j++) {\n\t\t\t\tif(ys[j].second) {\n\t\t\t\t\tin_curtain = !in_curtain;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tin = !in;\n\t\t\t\t}\n\t\t\t\tif(in && !in_curtain) {\n\t\t\t\t\tans += w * abs(ys[j].first - ys[j + 1].first);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto x : v){cout << x << \" \";} cout << endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(vv) for(auto v : vv){for(auto&& x : v){cout << x << \" \";}cout << endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n\nstruct L {\n    P a, b, v;\n    L(){}\n    L(P _a, P _b) : a(_a), b(_b), v(b - a) {}\n    L(double _ax, double _ay, double _bx, double _by) : L(P(_ax, _ay), P(_bx, _by)) {}\n};\n\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\nenum { OUT, ON, IN };\nint containPG(const P& p, const G& g) {\n    int n = g.size();\n    bool in = false;\n    rep(i, n) {\n        P a = here(g, i) - p, b = next(g, i) - p;\n        if (a.imag() > b.imag()) swap(a, b);\n        if (a.imag() <= 0 && 0 < b.imag() && cross(a, b) > 0) in = !in;\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int N;\n    while (cin >> N, N) {\n        map<int, int> mpx, mpy;\n        map<int, int> rmpx, rmpy;\n\n        vector<int> x(N), y(N);\n        rep(i, N) {\n            cin >> x[i] >> y[i];\n            mpx[x[i]] = 0;\n            mpy[y[i]] = 0;\n        }\n        vector<int> a(4), b(4);\n        rep(i, 4) {\n            cin >> a[i] >> b[i];\n            mpx[a[i]] = 0;\n            mpy[b[i]] = 0;\n        }\n\n        int numx = 0;\n        for (auto p : mpx) {\n            mpx[p.first] = numx;\n            rmpx[numx] = p.first;\n            numx++;\n        }\n\n        int numy = 0;\n        for (auto p : mpy) {\n            mpy[p.first] = numy;\n            rmpy[numy] = p.first;\n            numy++;\n        }\n\n        vector<int> X(N), Y(N);\n        rep(i, N) {\n            X[i] = mpx[x[i]];\n            Y[i] = mpy[y[i]];\n        }\n\n        vector<int> A(4), B(4);\n        rep(i, 4) {\n            A[i] = mpx[a[i]];\n            B[i] = mpy[b[i]];\n        }\n\n        G g1;\n        rep(i, N) {\n            g1.emplace_back(P(1. * X[i], 1. * Y[i]));\n        }\n\n        G g2;\n        rep(i, 4) {\n            g2.emplace_back(P(1. * A[i], 1. * B[i]));\n        }\n\n        int ans = 0;\n        rep(i, numx - 1) {\n            rep(j, numy - 1) {\n                P p(1. * i + 0.5, 1. * j + 0.5);\n                if (containPG(p, g1) && !containPG(p, g2)) {\n                    ans += (rmpx[i + 1] - rmpx[i]) * (rmpy[j + 1] - rmpy[j]);\n                }\n            }\n        }\n\n        cout << ans << endl;\n\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <iostream>\n#include <utility>\n#include <vector>\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> Poly;\ntypedef pair<P,P> L;\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble dot(P a, P b){return a.X*b.X + a.Y*b.Y;}\n\ndouble cross(P a, P b){return a.X*b.Y - a.Y*b.X;}\n\nint ccw(P a, P b, P c){\n  b -= a;c -= a;\n  if(cross(b, c) > EPS) return 1;\n  if(cross(b, c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(c) - norm(b) > EPS) return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  if(ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0 &&\n     ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0) return true;\n  return false;\n}\n\n\nP intersection(L a, L b){\n  //テァツ崢エテァツキツ啾テ」ツ?ィテァツ崢エテァツキツ喘テ」ツ?ョテ、ツコツ、テァツつケ\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nint in_poly(P a, Poly p){\n  int n = p.size(), c = 0;\n  for(int i = 0; i < n; ++i){\n    P s = p[i]-a, t = p[(i+1)%n]-a;\n    if(!ccw(s,t,P(0,0))) return 1;//ティツセツコテ、ツクツ?\n    if(s.Y > t.Y + EPS) swap(s,t);\n    if((s.Y*t.Y < 0 || (s.Y*t.Y < EPS && t.Y > EPS)) && cross(s,t) < EPS) ++c;\n  }\n  if(c%2) return 2;//テ・ツ??ゥツδィ\n  return 0;//テ・ツ、ツ姪ゥツδィ\n}\n\n\nlong long int solve(int N, Poly W, Poly C){\n  vector< pair<double, P> > S;\n  bool f = true;\n  for(int i = 0; i < N; ++i){\n    if(in_poly(W[i], C)){\n      f = false;\n      break;\n    }\n  }\n  for(int i = 0; i < 4; ++i){\n    if(in_poly(C[i], W)){\n      f = false;\n      break;\n    }\n  }\n  if(f){\n    long long int s = 0LL;\n    for(int i = 0; i < N; ++i)\n      s += (long long int)cross(W[i],W[(i+1)%N]);\n    return s/2;\n  }\n  P m = (C[0]+C[2])/2.0;\n  for(int i = 0; i < N; ++i){\n    if(!in_poly(W[i],C)) S.push_back(make_pair(arg(W[i]-m),W[i]-m));\n  }\n  for(int i = 0; i < 4; ++i){\n    if(!in_poly(C[i],W)) S.push_back(make_pair(arg(C[i]-m),C[i]-m));\n  }\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < 4; ++j){\n      L l1 = L(W[i],W[(i+1)%N]), l2 = L(C[j],C[(j+1)%4]);\n      if(is_cross(l1, l2)){\n\tif(abs(cross(l1.first-l1.second, l2.first-l2.second)) < EPS){\n\t  S.push_back(make_pair(arg(l1.first-m),(l1.first-m)));\n\t  S.push_back(make_pair(arg(l1.second-m),(l1.second-m)));\n\t  S.push_back(make_pair(arg(l2.first-m),(l2.first-m)));\n\t  S.push_back(make_pair(arg(l2.second-m),(l2.second-m)));\n\t}else{\n\t  P cp = intersection(l1,l2)-m;\n\t  S.push_back(make_pair(arg(cp),cp));\n\t}\n      }\n    }\n  }\n  sort(S.begin(), S.end());\n  int n = S.size();\n  double s = 0.0;\n  for(int i = 0; i < n; ++i){\n    s += (int)cross(S[i].second,S[(i+1)%n].second);\n  }\n  for(int i = 0; i < 4; ++i) s -= cross(C[i],C[(i+1)%4]);\n  return (long long int)s/2;\n}\n\nint main(){\n  int N;\n  while(cin >> N, N){\n    Poly W;\n    double x, y;\n    for(int i = 0; i < N; ++i){\n      cin >> x >> y;\n      W.push_back(P(x,y));\n    }\n    Poly C;\n    for(int i = 0; i < 4; ++i){\n      cin >> x >> y;\n      C.push_back(P(x,y));\n    }\n    cout << solve(N, W, C) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\nstruct UnionFind{ //// sorry, i'm unko\n  vector<int> v;\n  UnionFind(int n) : v(n, -1) {}\n  int find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n  bool unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (-v[x] < -v[y]) swap(x, y);\n    v[x] += v[y]; v[y] = x;\n    return true;\n  }\n  bool same(int x, int y) { return find(x) == find(y); }\n};\n\nint n;\nint X[111],Y[111];\nint A[5],B[5];\nvector<int> xps,yps;\nint x[111],y[111],a[5],b[5];\nbool wal[111][111][111][111];\nint dd[]={-1,0,1,0,-1};\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    int x1=INF,y1=INF,x2=-INF,y2=-INF;\n    rep(i,n)cin>>X[i]>>Y[i];\n    rep(i,4){\n      cin>>A[i]>>B[i];\n      minch(x1,A[i]); maxch(x2,A[i]);\n      minch(y1,B[i]); maxch(y2,B[i]);\n    }\n\n    xps.clear();\n    xps.pb(-114514);\n    rep(i,n)xps.pb(X[i]);\n    rep(i,4){\n      xps.pb(A[i]);\n    }\n    sort(all(xps));\n    uni(xps);\n    rep(i,n){\n      x[i]=lower_bound(all(xps),X[i])-xps.begin();\n    }\n    x1=lower_bound(all(xps),x1)-xps.begin();\n    x2=lower_bound(all(xps),x2)-xps.begin();\n\n    yps.clear();\n    yps.pb(-114514);\n    rep(i,n)yps.pb(Y[i]);\n    rep(i,4)yps.pb(B[i]);\n    sort(all(yps));\n    uni(yps);\n    rep(i,n){\n      y[i]=lower_bound(all(yps),Y[i])-yps.begin();\n    }\n    y1=lower_bound(all(yps),y1)-yps.begin();\n    y2=lower_bound(all(yps),y2)-yps.begin();\n\n    //dbg(x1); dbg(x2); dbg(y1); dbg(y2);\n\n    memset(wal,0,sizeof(wal));\n    rep(i,n){\n      if(y[i]==y[(i+1)%n]){\n        repl(k,min(x[i],x[(i+1)%n]),max(x[i],x[(i+1)%n])){\n          wal[y[i]][k][y[i]-1][k]=true;\n          wal[y[i]-1][k][y[i]][k]=true;\n        }\n      }else{\n        repl(k,min(y[i],y[(i+1)%n]),max(y[i],y[(i+1)%n])){\n          wal[k][x[i]][k][x[i]-1]=true;\n          wal[k][x[i]-1][k][x[i]]=true;\n        }\n      }\n    }\n\n    UnionFind uf(111*111);\n    rep(i,111)rep(j,111){\n      rep(d,4){\n        int ni=i+dd[d],nj=j+dd[d+1];\n        if(ni>=0&&ni<111&&nj>=0&&nj<111&&!wal[i][j][ni][nj]){\n          uf.unite(i*111+j,ni*111+nj);\n        }\n      }\n    }\n\n    ll res=0;\n    rep(i,110)rep(j,110){\n      if(i>=y1&&i+1<=y2&&j>=x1&&j+1<=x2)continue;\n      if(!uf.same(0,i*111+j)){\n        res+=(yps[i+1]-yps[i])*(xps[j+1]-xps[j]);\n      }\n    }\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <numeric>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\n#ifdef _DEBUG_\n#define dump(val) cerr << __LINE__ << \":\\t\" << #val << \" = \" << (val) << endl\n#else\n#define dump(val)\n#endif\n\nusing namespace std;\n\ntypedef long long int ll;\n\n#include <utility>\ntemplate<typename T>\nvector<T> make_v(size_t a, T b) {\n    return vector<T>(a, b);\n}\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\ntemplate<typename T, typename E>\nvoid compress_insert(vector<T> &inserter, pair<vector<T> &, vector<E> &> pr) {\n    for (T &val : pr.first) {\n        inserter.push_back(val);\n    }\n}\ntemplate<typename T, typename Head, typename... Args>\nvoid compress_insert(vector<T> &inserter, Head head, Args... args) {\n    compress_insert(inserter, head);\n    compress_insert(inserter, args...);\n}\ntemplate<typename T, typename E>\nvoid compress_update(vector<T> &inserter, pair<vector<T> &, vector<E> &> pr) {\n    for (unsigned int i = 0; i < pr.first.size(); i++) {\n        pr.second[i] = static_cast<int>(lower_bound(inserter.begin(), inserter.end(), pr.first[i]) - inserter.begin());\n    }\n}\ntemplate<typename T, typename Head, typename... Args>\nvoid compress_update(vector<T> &inserter, Head head, Args... args) {\n    compress_update(inserter, head);\n    compress_update(inserter, args...);\n}\ntemplate<typename T, typename... Args>\nsize_t compress(vector<T> &inserter, Args... args) {\n    compress_insert(inserter, args...);\n    sort(inserter.begin(), inserter.end());\n    inserter.erase(unique(inserter.begin(), inserter.end()), inserter.end());\n    compress_update(inserter, args...);\n    return inserter.size();\n}\n#include <functional>\ntemplate<typename T, typename E>\nauto refer(vector<T> &a, vector<E> &b) {\n    return make_pair(ref(a), ref(b));\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n;\n    while (cin >> n, n) {\n        vector<int> x(n), y(n);\n        REP(i, 0, n) {\n            cin >> x[i] >> y[i];\n        }\n        vector<int> carX(4), carY(4);\n        REP(i, 0, 4) {\n            cin >> carX[i] >> carY[i];\n        }\n        vector<int> resX, resY;\n\n        int W = compress(resX, refer(x, x), refer(carX, carX));\n        int H = compress(resY, refer(y, y), refer(carY, carY));\n        int minX = *min_element(carX.begin(), carX.end());\n        int minY = *min_element(carY.begin(), carY.end());\n        int maxX = *max_element(carX.begin(), carX.end());\n        int maxY = *max_element(carY.begin(), carY.end());\n\n        /*\n        dump(minX);\n        dump(minY);\n        dump(maxX);\n        dump(maxY);\n        */\n\n        ll ans = 0;\n        REP(i, 0, H - 1) {\n            int TX = 0;\n            REP(j, 0, W - 1) {\n                REP(k, 0, n) {\n                    int kk = (k + 1) % n;\n                    if (x[k] == j && x[kk] == j && ((y[k] <= i && i < y[kk]) || (y[kk] <= i && i < y[k]))) {\n                        TX = 1 - TX;\n                        break;\n                    }\n                }\n                //dump(TX);\n                if (TX && ((j < minX || maxX <= j) || (i < minY || maxY <= i))) {\n                    ans += ll(resX[j + 1] - resX[j]) * (resY[i + 1] - resY[i]);\n                    //dump(ans);\n                }\n            }\n            //cout << endl;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n#include <complex>\n\nusing namespace std;\n   \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n   \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n  \nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\nconst double PI = acos(-1);\n\ntypedef complex<double> P;\ndouble cross(const P& p, const P& q){return imag(conj(p)*q);}\n\nint main(){\n    int n;\n    while(cin>>n&&n){\n        vector<P> p;\n        double x, y;\n        rep(i, n){\n            cin>>x>>y;\n            p.pb({x, y});\n        }\n        P q[4];\n        rep(i, 4){\n            cin>>x>>y;\n            q[i] = {x, y};\n        }\n        double s = 0.0;\n        rep(i, n) s += cross(p[i], p[(i+1)%n])/2;\n        s = abs(s);\n        double mx,Mx,my,My;\n        mx = my = 1e18;\n        Mx = My = 0;\n        rep(i, 4){\n            mx = min(mx, real(q[i]));\n            my = min(my, imag(q[i]));\n            Mx = max(Mx, real(q[i]));\n            My = max(My, imag(q[i]));\n        }\n        rep(i, n){\n            x = real(p[i]);\n            y = imag(p[i]);\n            if(mx>x) x = mx;\n            else if(Mx<x) x = Mx;\n            if(my>y) y = my;\n            else if(My < y) y = My;\n            p[i] = {x, y};\n        }\n        double s2 = 0.0;\n        rep(i, n) s2 += cross(p[i], p[(i+1)%n])/2; \n        s2 = abs(s2);       \n        printf(\"%.15lf\\n\",s-s2);        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<pii> pos(n);\n\t\tvector<pii> posc(4);\n\t\tint minx = 99999;\n\t\tint miny = 99999;\n\t\tint maxx = -99999;\n\t\tint maxy = -99999;\n\t\tset<int> posx;\n\t\tset<int> posy;\n\t\tREP(i, n) {\n\t\t\tcin >> pos[i].first >> pos[i].second;\n\t\t\tposx.insert(pos[i].first);\n\t\t\tposy.insert(pos[i].second);\n\t\t}\n\t\tREP(i, 4) {\n\t\t\tcin >> posc[i].first >> posc[i].second;\n\t\t\tposx.insert(posc[i].first);\n\t\t\tposy.insert(posc[i].second);\n\t\t\tminx = min(minx, posc[i].first);\n\t\t\tminy = min(miny, posc[i].second);\n\t\t\tmaxx = max(maxx, posc[i].first);\n\t\t\tmaxy = max(maxy, posc[i].second);\n\t\t}\n\t\tmap<int, int> comx;\n\t\tmap<int, int> comy;\n\t\tmap<int, int> uncomx;\n\t\tmap<int, int> uncomy;\n\t\tfor (auto x : posx) {\n\t\t\tif (comx.empty())\n\t\t\t\tcomx[x] = 0;\n\t\t\telse\n\t\t\t\tcomx[x] = comx.size();\n\t\t\tuncomx[comx.size() - 1] = x;\n\t\t}\n\t\tfor (auto x : posy) {\n\t\t\tif (comy.empty())\n\t\t\t\tcomy[x] = 0;\n\t\t\telse\n\t\t\t\tcomy[x] = comy.size();\n\t\t\tuncomy[comy.size() - 1] = x;\n\t\t}\n\t\tvvb tate(posy.size() - 1, vb(posx.size(), false));\n\t\tvvb yoko(posy.size(), vb(posx.size() - 1, false));\n\t\tREP(i, n) {\n\t\t\tint start = comy[pos[i].second];\n\t\t\tint goal = comy[pos[(i + 1) % n].second];\n\t\t\tif (goal < start)\n\t\t\t\tswap(start, goal);\n\t\t\tREP(j, goal - start) {\n\t\t\t\ttate[start + j][comx[pos[i].first]] = true;\n\t\t\t}\n\t\t\tstart = comx[pos[i].first];\n\t\t\tgoal = comx[pos[(i + 1) % n].first];\n\t\t\tif (goal < start)\n\t\t\t\tswap(start, goal);\n\t\t\tREP(j, goal - start) {\n\t\t\t\tyoko[comy[pos[i].second]][start + j] = true;\n\t\t\t}\n\t\t}\n\t\tvvb cell(posy.size() - 1, vb(posx.size() - 1, false));\n\t\tREP(i, posy.size() - 1) {\n\t\t\tbool into = false;\n\t\t\tREP(j, posx.size()) {\n\t\t\t\tif (tate[i][j] == true)\n\t\t\t\t\tinto = !into;\n\t\t\t\tif (j < posx.size() - 1 && into)\n\t\t\t\t\tcell[i][j] = true;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tREP(j, posx.size() - 1) {\n\t\t\tbool into = false;\n\t\t\tREP(i, posy.size()) {\n\t\t\t\tif (yoko[i][j] == true)\n\t\t\t\t\tinto = !into;\n\t\t\t\tif (i < posy.size() - 1)\n\t\t\t\t\tif(into&&cell[i][j])\n\t\t\t\t\tcell[i][j] = true;\n\t\t\t\telse\n\t\t\t\t\tcell[i][j] = false;\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tint ans = 0;\n\t\tREP(i, posy.size() - 1) {\n\t\t\tREP(j, posx.size() - 1) {\n\t\t\t\tif (comy[miny] <= i&&i < comy[maxy] && comx[minx] <= j&&j < comx[maxx])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (cell[i][j])\n\t\t\t\t\tans += (uncomx[j + 1] - uncomx[j])*(uncomy[i + 1] - uncomy[i]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\nLL x[101], y[101];\nLL a[4], b[4];\nint main() {\n\tint N;\n\tLL l, r, u, d;\n\twhile (scanf(\"%d\", &N), N) {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tscanf(\"%lld %lld\", &x[i], &y[i]);\n\t\t}\n\t\tx[N] = x[0];\n\t\ty[N] = y[0];\n\t\tl = 1LL << 60;\n\t\tr = -(1LL << 60);\n\t\tu = -(1LL << 60);\n\t\td = 1LL << 60;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tscanf(\"%lld %lld\", &a[i], &b[i]);\n\t\t\tl = min(l, a[i]);\n\t\t\tr = max(r, a[i]);\n\t\t\tu = max(u, b[i]);\n\t\t\td = min(d, b[i]);\n\t\t}\n\t\tLL ans = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (x[i] < l && x[i + 1] < l) {\n\t\t\t\tif (x[i] != x[i + 1]) continue;\n\t\t\t\tans += (l - x[i])*(y[i] - y[i + 1]);\n\t\t\t\tif (y[i + 1] < d) ans -= (l - x[i])*(d - y[i + 1]);\n\t\t\t}\n\t\t\telse if (x[i] > r && x[i + 1] > r) {\n\t\t\t\tif (x[i] != x[i + 1]) continue;\n\t\t\t\tans += (x[i] - r)*(y[i + 1] - y[i]);\n\t\t\t\tif (y[i + 1] > u) ans -= (x[i] - r)*(y[i + 1] - u);\n\t\t\t}\n\t\t\telse if (y[i] < d && y[i + 1] < d) {\n\t\t\t\tif (y[i] != y[i + 1]) continue;\n\t\t\t\tans += (d - y[i])*(x[i + 1] - x[i]);\n\t\t\t\tif (x[i + 1] > r) ans -= (d - y[i])*(x[i + 1] - r);\n\t\t\t}\n\t\t\telse if (y[i] > u && y[i + 1] > u) {\n\t\t\t\tif (y[i] != y[i + 1]) continue;\n\t\t\t\tans += (y[i]-u)*(x[i] - x[i+1]);\n\t\t\t\tif (x[i + 1] < l) ans -= (y[i]-u)*(l - x[i + 1]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<pii> pos(n);\n\t\tvector<pii> posc(4);\n\t\tint minx = 99999;\n\t\tint miny = 99999;\n\t\tint maxx = -99999;\n\t\tint maxy = -99999;\n\t\tset<int> posx;\n\t\tset<int> posy;\n\t\tREP(i, n) {\n\t\t\tcin >> pos[i].first >> pos[i].second;\n\t\t\tposx.insert(pos[i].first);\n\t\t\tposy.insert(pos[i].second);\n\t\t}\n\t\tREP(i, 4) {\n\t\t\tcin >> posc[i].first >> posc[i].second;\n\t\t\tposx.insert(posc[i].first);\n\t\t\tposy.insert(posc[i].second);\n\t\t\tminx = min(minx, posc[i].first);\n\t\t\tminy = min(miny, posc[i].second);\n\t\t\tmaxx = max(maxx, posc[i].first);\n\t\t\tmaxy = max(maxy, posc[i].second);\n\t\t}\n\t\tmap<int, int> comx;\n\t\tmap<int, int> comy;\n\t\tmap<int, int> uncomx;\n\t\tmap<int, int> uncomy;\n\t\tfor (auto x : posx) {\n\t\t\tcomx[x] = comx.size();\n\t\t\tuncomx[comx.size()-1] = x;\n\t\t}\n\t\tfor (auto x : posy) {\n\t\t\tcomy[x] = comy.size();\n\t\t\tuncomy[comy.size() - 1] = x;\n\t\t}\n\t\tvvb tate(posy.size()-1,vb(posx.size(),false));\n\t\tvvb yoko(posy.size(), vb(posx.size()-1, false));\n\t\tREP(i, n) {\n\t\t\tint start = comy[pos[i].second];\n\t\t\tint goal = comy[pos[(i + 1) % n].second];\n\t\t\tif (goal < start)\n\t\t\t\tswap(start, goal);\n\t\t\tREP(j, goal-start) {\n\t\t\t\ttate[start + j][comx[pos[i].first]]=true;\n\t\t\t}\n\t\t\tstart = comx[pos[i].first];\n\t\t\tgoal = comx[pos[(i+1)%n].first];\n\t\t\tif (goal < start)\n\t\t\t\tswap(start, goal);\n\t\t\tREP(j, goal - start) {\n\t\t\t\tyoko[comy[pos[i].second]][start + j] = true;\n\t\t\t}\n\t\t}\n\t\tvvb cell(posy.size() - 1, vb(posx.size() - 1, false));\n\t\tREP(i, posy.size()-1) {\n\t\t\tbool into=false;\n\t\t\tREP(j, posx.size()) {\n\t\t\t\tif (tate[i][j] == true)\n\t\t\t\t\tinto = !into;\n\t\t\t\tif (j < posx.size() - 1 && into)\n\t\t\t\t\tcell[i][j] = true;\n\t\t\t}\n\t\t}\n\t\tREP(j, posx.size() - 1) {\n\t\t\tbool into = false;\n\t\t\tREP(i, posy.size()) {\n\t\t\t\tif (yoko[i][j] == true)\n\t\t\t\t\tinto = !into;\n\t\t\t\tif (i < posy.size() - 1)  \n\t\t\t\t\tif(into&&cell[i][j])\n\t\t\t\t\tcell[i][j] = true;\n\t\t\t\telse\n\t\t\t\t\tcell[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tREP(i, posy.size() - 1) {\n\t\t\tREP(j, posx.size() - 1) {\n\t\t\t\tif (comy[miny] <= i&&i < comy[maxy] && comx[minx] <= j&&j < comx[maxx])\n\t\t\t\t\tcontinue;\n\t\t\t\tif(cell[i][j])\n\t\t\t\tans += (uncomx[j + 1] - uncomx[j])*(uncomy[i + 1] - uncomy[i]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T>\nvector<T> compress(vector<T> v){\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n  return v;\n}\n\ntemplate<typename T>\nmap<T, Int> dict(const vector<T> &v){\n  map<T, Int> res;\n  for(Int i=0;i<(Int)v.size();i++)\n    res[v[i]]=i;\n  return res;\n}\n\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  while(cin>>n,n){\n    vector<Int> xs(n),ys(n);\n    for(Int i=0;i<n;i++) cin>>xs[i]>>ys[i];\n\n    vector<Int> as(4),bs(4);\n    for(Int i=0;i<4;i++) cin>>as[i]>>bs[i];\n    \n    vector<Int> vx(xs),vy(ys);\n    for(Int i=0;i<4;i++){\n      vx.emplace_back(as[i]);\n      vy.emplace_back(bs[i]);\n    }\n    vx.emplace_back(-20001);\n    vy.emplace_back(-20001);\n    vx.emplace_back(+20001);\n    vy.emplace_back(+20001);\n\n    vx=compress(vx);\n    vy=compress(vy);\n    auto dx=dict(vx);\n    auto dy=dict(vy);\n\n    Int h=vy.size(),w=vx.size();\n    auto dp=make_v<Int>(h,w);\n    fill_v<Int>(dp,0);\n\n    for(Int i=0;i<n;i++){\n      if(~i&1) dp[dy[ys[i]]][dx[xs[i]]]++;\n      else dp[dy[ys[i]]][dx[xs[i]]]--;\n    }\n    \n    for(Int i=0;i<h;i++)\n      for(Int j=1;j<w;j++)\n        dp[i][j]+=dp[i][j-1];\n\n    for(Int i=1;i<h;i++)\n      for(Int j=0;j<w;j++)\n        dp[i][j]+=dp[i-1][j];\n\n    Int a1=*min_element(as.begin(),as.end());\n    Int a2=*max_element(as.begin(),as.end());\n    Int b1=*min_element(bs.begin(),bs.end());\n    Int b2=*max_element(bs.begin(),bs.end());\n    \n    Int ans=0;\n    for(Int i=0;i+1<h;i++){\n      for(Int j=0;j+1<w;j++){\n        if(b1<=vy[i]&&vy[i]<b2&&a1<=vx[j]&&vx[j]<a2) continue;\n        ans+=abs(dp[i][j])*(vy[i+1]-vy[i])*(vx[j+1]-vx[j]);\n      }\n    }\n    cout<<ans<<endl;\n  }  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint N;\nint W, H;\nvector<int> x, y;\nvector<int> xl, yl;\nint l, r, u, b;\nbool window[300][300];\n\nint comp(vector<int> &X, vector<int> &XL)\n{\n\tvector<int> xs;\n\tfor(int i = 0; i < X.size(); i++){\n\t\txs.push_back(X[i]);\n\t\txs.push_back(X[i] - 1);\n\t}\n\txs.push_back(20005), xs.push_back(-20005);\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\tsort(xs.begin(), xs.end());\n\t\n\tfor(int i = 0; i < X.size(); i++){\n\t\tX[i] = lower_bound(xs.begin(), xs.end(), X[i]) - xs.begin();\n\t}\n\tfor(int i = 0; i < xs.size()-1; i++){\n\t\tXL.push_back(xs[i+1] - xs[i]);\n\t}\n\treturn xs.size();\n}\n\nvoid dfs(int i, int j)\n{\n\tif(i < 0 || i >= W || j < 0 || j >= H) return;\n\tif(window[i][j]) return;\n\t\n\twindow[i][j] = true;\n\tdfs(i+1, j);\n\tdfs(i-1, j);\n\tdfs(i, j+1);\n\tdfs(i, j-1);\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\t\n\t\tx.clear(), y.clear();\n\t\tint xx, yy;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> xx >> yy;\n\t\t\tx.push_back(xx), y.push_back(yy);\n\t\t}\n\t\tint A[4], B[4];\n\t\tfor(int i = 0; i < 4; i++) cin >> A[i] >> B[i];\n\t\tl = min(A[0], A[2]), r = max(A[0], A[2]);\n\t\tu = min(B[0], B[2]), b = max(B[0], B[2]);\n\t\tx.push_back(l), x.push_back(r);\n\t\ty.push_back(u), y.push_back(b);\n\t\t\n\t\txl.clear(), yl.clear();\n\t\tW = comp(x, xl);\n\t\tH = comp(y, yl);\n\t\tl = x[N], r = x[N+1];\n\t\tu = y[N], b = y[N+1];\n\t\t\n\t\tfor(int i = 0; i < W; i++){\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\twindow[i][j] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint px, py, nx, ny, dx, dy;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tpx = x[i], py = y[i];\n\t\t\tnx = x[(i+1)%N], ny = y[(i+1)%N];\n\t\t\tif(nx == px) dx = 0; \n\t\t\telse dx = (nx - px) / abs(nx - px);\n\t\t\tif(ny == py) dy = 0;\n\t\t\telse dy = (ny - py) / abs(ny - py);\n\t\t\t\n\t\t\t/*if(dx < 0) y[i]--, y[(i+1)%N]--;\n\t\t\telse if(dy > 0) x[i]--, x[(i+1)%N]--;\n\t\t\tpx = x[i], py = y[i];\n\t\t\tnx = x[(i+1)%N], ny = y[(i+1)%N];*/\n\t\t\t\n\t\t\tfor(; px != nx || py != ny; px += dx, py += dy) window[px][py] = true;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < W; i++){\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tif(window[i][j] && !window[i][j+1]){\n\t\t\t\t\tfor(int k = j+1; k < H; k++){\n\t\t\t\t\t\tif(window[i][k]){\n\t\t\t\t\t\t\tdfs(i, j+1);\n\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tend:;\n\t\t\n\t\tfor(int i = l; i < r; i++){\n\t\t\tfor(int j = u; j < b; j++){\n\t\t\t\twindow[i][j] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*for(int i = 0; i < W; i++){\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tcout << window[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < W; i++){\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tif(window[i][j]) ans += xl[i] * yl[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\ntypedef long long ll;\n\nclass Point {\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator + (Point p) { return Point(x+p.x,y+p.y); }\n  Point operator - (Point p) { return Point(x-p.x,y-p.y); }\n  Point operator * (double a) { return Point(a*x,a*y); }\n  Point operator / (double a) { return Point(x/a,y/a); }\n\n  bool operator < ( const Point &p ) const {\n    return !equals(x,p.x) ? x < p.x : (!equals(y,p.y)&&y<p.y); \n  }\n\n  bool operator == ( const Point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) <EPS;\n  }\n};\n\nstruct Segment {\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2) {}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\ndouble dot(Point a,Point b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Point a,Point b) { return a.x*b.y - a.y*b.x; }\ndouble norm(Point a) { return a.x*a.x + a.y*a.y; }\ndouble abs(Point p) { return sqrt(norm(p)); }\n\nint ccw(Point p0,Point p1,Point p2) {\n  Point a = p1 - p0;\n  Point b = p2 - p0;\n  if( cross(a,b) > EPS ) return COUNTER_CLOCKWISE;\n  if( cross(a,b) < -EPS ) return CLOCKWISE;\n  if( dot(a,b) < -EPS ) return ONLINE_BACK;\n  if( norm(a) < norm(b) ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\n\nPoint crosspoint(Line l,Line m) {\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\ndouble getArea(vector<Point>& vec) {\n  double sum = 0;\n  for(int i=0;i<(int)vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0;\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\ndouble angle(Point a,Point b,Point c) {\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \nbool inPolygon(Polygon poly,Point p){\n  if((int)poly.size() == 0)return false;\n  rep(i,(int)poly.size()) if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++) {\n    if( equals(cross(poly[i]-p,poly[(i+1)%poly.size()]-p),0.0) ) continue; \n    if( cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0 ) sum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n    else                                                 sum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n  }\n  const double eps = 1e-5;\n  return (fabs(sum - 2*M_PI) < eps || fabs(sum + 2*M_PI) < eps);\n}  \n\n\n#define MAX_N 110\n\nint N, x[MAX_N], y[MAX_N], a[5], b[5];\n\nvoid compute() {\n  vector<int> xs,ys;\n  rep(i,4) {\n    xs.push_back(a[i]);\n    ys.push_back(b[i]);\n  }\n  rep(i,N) {\n    xs.push_back(x[i]);\n    ys.push_back(y[i]);\n    Segment s1 = Segment(Point(x[i],y[i]),Point(x[(i+1)%N],y[(i+1)%N]));\n    rep(j,4) {\n      Segment s2 = Segment(Point(a[j],b[j]),Point(a[(j+1)%4],b[(j+1)%4]));\n      if( equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0) )  continue;\n      if( intersectSS(s1,s2) ) {\n\tPoint cp = crosspoint(s1,s2);\n\txs.push_back(cp.x);\n\tys.push_back(cp.y);\n      }\n    }\n  }\n  \n  xs.push_back(0);\n  //xs.push_back(200000);\n  ys.push_back(0);\n  //ys.push_back(200000);\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n  sort(ys.begin(),ys.end());\n  ys.erase(unique(ys.begin(),ys.end()),ys.end());\n\n  Polygon window;\n  rep(i,N) window.push_back(Point(x[i],y[i]));\n  double danswer = getArea(window);\n\n  ll answer = (ll)danswer;\n  //cout <<\"area = \" << answer << endl;\n  \n  Polygon poly;\n  rep(i,4) poly.push_back(Point(a[i],b[i]));\n  /*\n  cout << \"xs---\" << endl;\n  rep(i,(int)xs.size()){\n    cout << xs[i] << endl;\n  }\n\n  cout << \"ys---\" << endl;\n  rep(i,(int)ys.size()){\n    cout << ys[i] << endl;\n  }\n  */\n\n  rep(i,(int)xs.size()-1) {\n    rep(j,(int)ys.size()-1) {\n      //cout << \"(\" << xs[i] << \",\" << ys[j] << \") and (\" << xs[i+1] << \",\" << ys[j+1] << \")\" << endl;\n      Point mid = Point( ( xs[i] + xs[i+1] ) / 2.0, ( ys[j] + ys[j+1] ) / 2.0 );\n      //cout << \"mid = (\" << mid.x << \",\" << mid.y << \")\" <<endl;\n      if( inPolygon(poly,mid) && inPolygon(window,mid) ) {\n\tanswer -= ( xs[i+1] - xs[i] ) * ( ys[j+1] - ys[j] );\n\t//cout << \"erase \" << ( xs[i+1] - xs[i] ) * ( ys[j+1] - ys[j] ) << endl;\n\n      }\n    }\n  }\n  cout<< answer << endl;\n  \n}\n\nint main() {\n  while( cin >> N, N ) {\n    rep(i,N) cin >> x[i] >> y[i];\n    rep(i,4) cin >> a[i] >> b[i];\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nint main(){\n  int n;\n  while(cin>>n, n){\n    vector<int> x(n),y(n);\n    rep(i,n) cin>>x[i]>>y[i];\n    vector<int> px(4), py(4);\n    rep(i,4) cin>>px[i]>>py[i];\n\n    vector<int> sx,sy;\n    rep(i,n) sx.pb(x[i]), sy.pb(y[i]);\n    rep(i,4) sx.pb(px[i]),sy.pb(py[i]);\n    sx.pb(-300000);\n    sy.pb(-300000);\n    uniq(sx); uniq(sy);\n    int nx = sx.size(), ny = sy.size();\n\n    x.pb(x[0]); y.pb(y[0]);\n\n    auto idx = [&](vector<int> &v, int val){ return lower_bound(all(v), val) - v.begin(); };\n\n    vector<vector<int>> vec(nx,vector<int>(ny,0));\n\n    rep(i,n) if(y[i] == y[i+1]){\n      int l = idx(sx, min(x[i], x[i+1]));\n      int r = idx(sx, max(x[i], x[i+1]));\n      int t = idx(sy, y[i]);\n      for(; l<r; l++) vec[l][t]+=1;\n    }\n\n    rep(i,nx) repl(j,1,ny) vec[i][j] += vec[i][j-1];\n    rep(i,nx) rep(j,ny) vec[i][j] %=2;\n\n    {\n      int lw = idx(sy, min(py[0], py[2]));\n      int up= idx(sy, max(py[0], py[2]));\n      int l = idx(sx, min(px[0], px[2]));\n      int r = idx(sx, max(px[0], px[2]));\n      repl(i,l,r)repl(j,lw,up) vec[i][j] = 0;\n    }\n\n    long ans = 0;\n    rep(i,nx) rep(j,ny) if(vec[i][j]>0) ans += (sx[i+1]-sx[i])*(sy[j+1]-sy[j]);\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nconst int INF = 1 << 22;\nint main() {\n    int n;\n    while (cin >> n, n) {\n        vector<int> x(n + 1), y(n + 1);\n        for (int i = 0; i < n; i++) cin >> x[i] >> y[i];\n        x[n] = x[0], y[n] = y[0];\n        int xmin = INF, xmax = -INF;\n        int ymin = INF, ymax = -INF;\n        for (int i = 0; i < 4; i++) {\n            int a, b;\n            cin >> a >> b;\n            xmin = min(xmin, a);\n            xmax = max(xmax, a);\n            ymin = min(ymin, b);\n            ymax = max(ymax, b);\n        }\n        int r1 = 0, r2 = 0;\n        for (int i = 0; i < n; i++) {\n            if (y[i] == y[i + 1]) {\n                int x1 = x[i];\n                int x2 = x[i + 1];\n                int y1 = y[i];\n                r2 += y1 * (x1 - x2);\n\n                x1 = max(xmin, min(xmax, x1));\n                x2 = max(xmin, min(xmax, x2));\n                y1 = max(ymin, min(ymax, y1));\n                r1 += y1 * (x1 - x2);\n            }\n        }\n        cout << r2 - r1 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\n#define int long long\n\nclass Grid{\n\tprivate:\n\t\tconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\n\t\tconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\n\t\tvector<int> x,y;\n\t\tvoid compress(vector<int> &v) {\n\t\t\tsort(v.begin(), v.end());\n\t\t\tv.erase(unique(v.begin(),v.end()),v.end());\n\t\t}\n\t\tint lb(vector<int> v, int num){\n\t\t\treturn lower_bound(all(v), num) - v.begin();\n\t\t}\n\tpublic:\n\t\tstatic const int MAX_H = 500, MAX_W = 500;\n\t\tint grid[MAX_H][MAX_W];\n\t\t~Grid(){\n\t\t\tmemset(grid, 0, sizeof(grid));\n\t\t}\n\t\tvoid bfs(int x, int y, int c = -1){ //(x,y)??????bfs????????°????????????c????????????\n\t\t\tif(grid[x][y] != 0) return;\n\t\t\tqueue<pair<int, int>> q;\n\t\t\tq.push(make_pair(x,y));\n\n\t\t\twhile(not q.empty()){\n\t\t\t\tpair<int, int> u = q.front(); q.pop();\n\t\t\t\trep(i,4){\n\t\t\t\t\tint nx, ny;\n\t\t\t\t\tnx = u.first + dx[i];\n\t\t\t\t\tny = u.second + dy[i];\n\t\t\t\t\tif(nx < 0 || nx >= MAX_W || ny < 0 || ny >= MAX_H) continue;\n\t\t\t\t\tif(grid[ny][nx] == 0){\n\t\t\t\t\t\tgrid[ny][nx] = c;\n\t\t\t\t\t\tq.push(make_pair(nx,ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvoid setXY(vector<int> a, vector<int> b){\n\t\t\tcompress(a);\n\t\t\tx = a;\n\t\t\tcompress(b);\n\t\t\ty = b;\n\t\t}\n\t\tvoid write(pair<int, int> a, pair<int, int> b){ //?????´??????????????????\n\t\t\t//show(\"rite\")\n\t\t\t//cout << a.first << ' ' << a.second << endl;\n\t\t\t//cout << b.first << ' ' << b.second << endl;\n\t\t\tint ly = lb(y, a.second);\n\t\t\tint lx = lb(x, a.first);\n\t\t\tint ry = lb(y, b.second);\n\t\t\tint rx = lb(x, b.first);\n\t\t\tif(ly > ry) swap(ly, ry);\n\t\t\tif(lx > rx) swap(lx, rx);\n\t\t\t//cout << ly << ' ' << lx << ' ' << ry << ' ' << rx << endl;\n\t\t\trange(i,ly * 2,ry * 2 + 1){ //?????´\n\t\t\t\tgrid[i][lx * 2] = 1;\n\t\t\t\tgrid[i][rx * 2] = 1;\n\t\t\t}\n\t\t\trange(j,lx * 2, rx * 2 + 1){\n\t\t\t\tgrid[ly * 2][j] = 1;\n\t\t\t\tgrid[ry * 2][j] = 1;\n\t\t\t}\n\t\t}\n\t\tvoid overWrite(Grid a){\n\t\t\trep(i,MAX_H){\n\t\t\t\trep(j,MAX_W){\n\t\t\t\t\tif(a.grid[i][j] != -1){\n\t\t\t\t\t\tgrid[i][j] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sum(){\n\t\t\tint res = 0;\n\t\t\t//for(auto i : y){ show(i) }\n\t\t\trange(i,0,y.size() - 1){\n\t\t\t\trange(j,0,x.size() - 1){\n\t\t\t\t\tif(grid[i * 2 + 1][j * 2 + 1] == 0){\n\t\t\t\t\t\t//show(x.size())\n\t\t\t\t\t\t//\tshow(y.size())\n\t\t\t\t\t\t//cout << i << ' ' << j << endl;\n\t\t\t\t\t\t//show(y[i])\n\t\t\t\t\t\t\t//show(x[j])\n\t\t\t\t\t\t//\tshow(y[i - 1])\n\t\t\t\t\t\t//show(y[i] - y[i - 1])\n\t\t\t\t\t\t//int tmpy = i - 1 < 0 ? 20000 : y[i - 1];\n\t\t\t\t\t\t//int tmpx = j - 1 < 0 ? 20000 : x[j - 1];\n\t\t\t\t\t\tres += (y[i + 1] - y[i]) * (x[j + 1] - x[j]);\n\t\t\t\t\t\t//show(res)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tvoid output(){\n\t\t\trep(i,10){\n\t\t\t\trep(j,10){\n\t\t\t\t\tif(grid[i][j] == 0) cout << \"_ \";\n\t\t\t\t\telse if(grid[i][j] == -1) cout << \"# \";\n\t\t\t\t\telse cout << \"* \";\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n};\n\nsigned main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<int> x, y;\n\t\tvector<pair<int, int>> p, r;\n\t\trep(i,n){\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta += 20000;\n\t\t\tb += 20000;\n\t\t\tx.emplace_back(a);\n\t\t\ty.emplace_back(b);\n\t\t\tp.emplace_back(make_pair(a,b));\n\t\t}\n\t\trep(i,4){\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta += 20000;\n\t\t\tb += 20000;\n\t\t\tx.emplace_back(a);\n\t\t\ty.emplace_back(b);\n\t\t\tr.emplace_back(make_pair(a,b));\n\t\t}\n\t\t//x.emplace_back(20000);\n\t\t//y.emplace_back(20000);\n\n\t\tGrid win, cur;\n\t\twin.setXY(x,y);\n\t\tcur.setXY(x,y);\n\n\t\trep(i,n){\n\t\t\twin.write(p[i], p[(i + 1) % n]);\n\t\t}\n\t\trep(i,4){\n\t\t\tcur.write(r[i], r[(i + 1) % 4]);\n\t\t}\n\t\twin.bfs(0,0);\n\t\tcur.bfs(0,0);\n\t\twin.bfs(400,400);\n\t\tcur.bfs(400,400);\n\t\t//win.output();\n\t\t//cur.output();\n\n\t\twin.overWrite(cur);\n\t\t//win.output();\n\n\t\tcout << win.sum() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf 1e18\n#define eps (1e-10)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\ndouble getPolygonArea(Polygon p){\n  double area=0.0;\n  int n=p.size();\n  for(int i=0;i<n;i++)area+=cross(p[i%n],p[(i+1)%n]);\n  return area/2;\n}\n\nPolygon convex_cut(Polygon p,Line l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0)\n      ans.push_back(getCrossPointLL(l,Segment(A,B)));\n  }\n  return ans;\n}\n\ndouble getArea(Polygon t,Polygon s){\n  FOR(i,0,s.size()){\n    Point a=s[i],b=s[(i+1)%s.size()];\n    t=convex_cut(t,Line(a,b));\n  }\n  return getPolygonArea(t);\n}\n\ndouble getCommonArea(Polygon p,Polygon s){\n  int n=p.size();\n  double res=0.0;\n  Point a=p[0];\n  FOR(i,1,n-1){\n    Point b=p[i],c=p[(i+1)%n];\n    Polygon t;\n    t.pb(a);t.pb(b);t.pb(c);\n    res+=getArea(t,s);\n  }\n  return res;\n}\n\nint main()\n{\n  int n;\n\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    Polygon p;\n    FOR(i,0,n){\n      int x,y;\n      cin>>x>>y;\n      p.pb(Point(x,y));\n    }\n    Polygon s;\n    FOR(i,0,4){\n      int x,y;\n      cin>>x>>y;\n      s.pb(Point(x,y));\n    }\n    Polygon p1,p2;\n    cout<<(int)(getPolygonArea(p)-getCommonArea(p,s))<<endl;;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,s,e) for (int i=s;i<(e);i++)\n#define All(v) (v).begin(),(v).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\nconst int MOD = (int)1e9 + 7;\nconst int INF = 1010101010;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N;\n    cin >> N;\n    \n    while(N != 0){\n        vector<P> w;\n        REP(i, N){\n            int x, y;\n            cin >> x >> y;\n            w.pb(mp(y, x));\n        }\n        w.pb(w[0]);\n        int xu = -20000, xd = 20000, yu = -20000, yd = 20000;\n        REP(i, 4){\n            int x, y;\n            cin >> x >> y;\n            chmax(yu, y);\n            chmin(yd, y);\n            chmax(xu, x);\n            chmin(xd, x);\n        }\n\n        LL ans = 0;\n        REP(i, N){\n            int x1 = w[i].se;\n            int x2 = w[i+1].se;\n            int y = w[i].fi;\n            ans += (x1 - x2) * y;\n            x1 = max(xd, min(xu, x1));\n            x2 = max(xd, min(xu, x2));\n            y = max(yd, min(yu, y));\n            ans -= (x1 - x2) * y;\n\n        }\n        cout << ans << endl;\n\n        cin >> N;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n#include<algorithm>\nusing namespace std;\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(n);i++)\ntypedef complex<double> C;\ndouble cross(const C a, const C b)\n{\n    return imag(conj(a)*b);\n}\ndouble dot(const C a, const C b)\n{\n    return real(conj(a)*b);\n}\nint contains(const vector<C>& ps, const C p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n\nint main(){\n    int n;\n    while(cin>>n&&n!=0){\n        vector<C>v;\n        vector<C>s;\n        vector<int>x;\n        vector<int>y;\n        rep(i,n){\n            int a,b;\n            cin >> a >> b;\n            x.push_back(a);\n            y.push_back(b);\n            v.push_back(C((double)a,(double)b));\n        }\n        rep(i,4){\n            int a,b;\n            cin >> a >> b;\n            x.push_back(a);\n            y.push_back(b);\n            s.push_back(C((double)a,(double)b));\n        }\n        sort(x.begin(),x.end());\n        sort(y.begin(),y.end());\n        x.erase(unique(x.begin(),x.end()),x.end());\n        y.erase(unique(y.begin(),y.end()),y.end());\n        long long sm = 0;\n        for(int i=0;i<x.size()-1;i++){\n            for(int j=0;j<y.size()-1;j++){\n                double xx = (double)(x[i]+x[i+1])/2.0;\n                double yy = (double)(y[j]+y[j+1])/2.0;\n                if(contains(v,C(xx,yy))==2){\n                    if(contains(s,C(xx,yy))!=2){\n                        sm += (long long)(x[i+1]-x[i])*(long long)(y[j+1]-y[j]);\n                        \n                    }\n                }\n            }\n        }\n        cout << sm << endl;\n    }   \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf 1e18\n#define eps (1e-5)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0.0,double y=0.0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\ndouble getPolygonArea(Polygon p){\n  double area=0.0;\n  int n=p.size();\n  for(int i=0;i<n;i++)area+=cross(p[i%n],p[(i+1)%n])/2.0;\n  return area;\n}\n\nPolygon convex_cut(Polygon p,Line l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0)\n      ans.push_back(getCrossPointLL(l,Segment(A,B)));\n  }\n  return ans;\n}\n\ndouble getArea(Polygon t,Polygon s){\n  FOR(i,0,s.size()){\n    Point a=s[i],b=s[(i+1)%s.size()];\n    t=convex_cut(t,Line(a,b));\n  }\n  return getPolygonArea(t);\n}\n\ndouble getCommonArea(Polygon p,Polygon s){\n  int n=p.size();\n  double res=0.0;\n  Point a=p[0];\n  FOR(i,1,n-1){\n    Point b=p[i],c=p[(i+1)%n];\n    Polygon t;\n    t.pb(a);t.pb(b);t.pb(c);\n    res+=getArea(t,s);\n  }\n  return res;\n}\n\nint main()\n{\n  int n;\n\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    Polygon p;\n    FOR(i,0,n){\n      int x,y;\n      cin>>x>>y;\n      p.pb(Point(x,y));\n    }\n    Polygon s;\n    FOR(i,0,4){\n      int x,y;\n      cin>>x>>y;\n      s.pb(Point(x,y));\n    }\n    double ans=getPolygonArea(p)-getCommonArea(p,s)+eps;\n    cout<<(int)ans<<endl;;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <iostream>\n#include <map>\n#include <vector>\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> Poly;\ntypedef pair<P,P> L;\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble dot(P a, P b){return a.X*b.X + a.Y*b.Y;}\n\ndouble cross(P a, P b){return a.X*b.Y - a.Y*b.X;}\n\nint ccw(P a, P b, P c){\n  b -= a;c -= a;\n  if(cross(b, c) > EPS) return 1;\n  if(cross(b, c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(c) - norm(b) > EPS) return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  if(ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0 &&\n     ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0) return true;\n  return false;\n}\n\n\nP intersection(L a, L b){\n  //??´???a??¨??´???b?????????\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nint in_poly(P a, Poly p){\n  int n = p.size(), c = 0;\n  for(int i = 0; i < n; ++i){\n    P s = p[i]-a, t = p[(i+1)%n]-a;\n    if(!ccw(s,t,P(0,0))) return 1;//??????\n    if(s.Y > t.Y + EPS) swap(s,t);\n    if((s.Y*t.Y < 0 || (s.Y*t.Y < EPS && t.Y > EPS)) && cross(s,t) < EPS) ++c;\n  }\n  if(c%2) return 2;//?????¨\n  return 0;//?????¨\n}\n\n\nint main(){\n  int N;\n  map<int, int> M_x, M_y;\n  while(cin >> N, N){\n    double x, y;\n    Poly W;\n    for(int i = 0; i < N; ++i){\n      cin >> x >> y;\n      W.push_back(P(x,y));\n      M_x[(int)x] = 0;\n      M_y[(int)y] = 0;\n    }\n    Poly C;\n    for(int i = 0; i < 4; ++i){\n      cin >> x >> y;\n      C.push_back(P(x,y));\n      M_x[(int)x] = 0;\n      M_y[(int)y] = 0;\n    }\n    int k = 0;\n    vector<int> V_x;\n    for(auto p: M_x){\n      p.second = k++;\n      V_x.push_back(p.first);\n    }\n    k = 0;\n    vector<int> V_y;\n    for(auto p: M_y){\n      p.second = k++;\n      V_y.push_back(p.first);\n    }\n    int n_x = V_x.size(), n_y = V_y.size();\n    long long int ans = 0LL;\n    for(int i = 1; i < n_x; ++i){\n      for(int j = 1; j < n_y; ++j){\n\tP p = P((double)(V_x[i]+V_x[i-1])/2.0, (double)(V_y[j]+V_y[j-1])/2.0);\n\tif(in_poly(p,W) && !in_poly(p,C)) ans += (V_x[i]-V_x[i-1])*(V_y[j]-V_y[j-1]);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1e9)\nint main(){\n  while(1){\n    int N;\n    int x[100],y[100];\n    vector<int> X,Y;\n    int ax=INF,bx=-INF;\n    int ay=INF,by=-INF;\n    \n    scanf(\"%d\",&N);\n    if(N==0)break;\n    for(int i=0;i<N;i++){\n      scanf(\"%d %d\",&x[i],&y[i]);\n      X.push_back(x[i]);\n      Y.push_back(y[i]);\n    }\n    for(int i=0;i<4;i++){\n      int px,py;\n      cin>>px>>py;\n      ax=min(ax,px);\n      ay=min(ay,py);\n      bx=max(bx,px);\n      by=max(by,py);\n    }\n    X.push_back(ax);\n    Y.push_back(ay);\n    X.push_back(bx);\n    Y.push_back(by);\n    \n    sort(X.begin(),X.end());\n    sort(Y.begin(),Y.end());\n    X.erase( unique( X.begin(), X.end() ), X.end() );\n    Y.erase( unique( Y.begin(), Y.end() ), Y.end() );\n    \n    for(int i=0;i<N;i++){\n      x[i]=lower_bound(X.begin(),X.end(),x[i])-X.begin();\n      y[i]=lower_bound(Y.begin(),Y.end(),y[i])-Y.begin();\n    }\n    ax=lower_bound(X.begin(),X.end(),ax)-X.begin();\n    ay=lower_bound(Y.begin(),Y.end(),ay)-Y.begin();\n    bx=lower_bound(X.begin(),X.end(),bx)-X.begin();\n    by=lower_bound(Y.begin(),Y.end(),by)-Y.begin();\n    vector<int> G[300];\n    for(int i=0;i<N;i++){\n      int px=x[i],py=y[i];\n      int qx=x[ (i+1)%N ];\n      int qy=y[ (i+1)%N ];\n      if(qy!=py)continue;\n      G[py].push_back( min(px,qx) );\n      G[py].push_back( max(px,qx) );\n    }\n\n    int t[300]={};\n    \n    long long ans=0;\n    for(int py=0;py+1<(int)Y.size();py++){\n      for(int i=0;i<(int)G[py].size();i+=2){\n        int ax=G[py][i];\n        int bx=G[py][i+1];\n        for(int px=ax;px<bx;px++){\n          t[px]=1-t[px];\n        }\n      }\n      for(int px=0;px+1<(int)X.size();px++){\n        if(t[px]==0)continue;\n        if(ax<=px&&px<bx&&ay<=py&&py<by)continue;\n        long long dy=Y[py+1]-Y[py];\n        long long dx=X[px+1]-X[px];\n        ans+=dy*dx;\n      }\n    }\n    printf(\"%lld\\n\",ans);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf 1e18\n#define eps (1e-5)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0.0,double y=0.0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\ndouble getPolygonArea(Polygon p){\n  double area=0.0;\n  int n=p.size();\n  for(int i=0;i<n;i++)area+=cross(p[i%n],p[(i+1)%n])/2.0;\n  return area;\n}\n\nPolygon convex_cut(Polygon p,Line l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0)\n      ans.push_back(getCrossPointLL(l,Segment(A,B)));\n  }\n  return ans;\n}\n\ndouble getArea(Polygon t,Polygon s){\n  FOR(i,0,s.size()){\n    Point a=s[i],b=s[(i+1)%s.size()];\n    t=convex_cut(t,Line(a,b));\n  }\n  return getPolygonArea(t);\n}\n\ndouble getCommonArea(Polygon p,Polygon s){\n  int n=p.size();\n  double res=0.0;\n  Point a=p[0];\n  FOR(i,1,n-1){\n    Point b=p[i],c=p[(i+1)%n];\n    Polygon t;\n    t.pb(a);t.pb(b);t.pb(c);\n    res+=getArea(t,s);\n  }\n  return res;\n}\n\nint main()\n{\n  int n;\n\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    Polygon p;\n    FOR(i,0,n){\n      int x,y;\n      cin>>x>>y;\n      p.pb(Point(x,y));\n    }\n    Polygon s;\n    FOR(i,0,4){\n      int x,y;\n      cin>>x>>y;\n      s.pb(Point(x,y));\n    }\n    double ans=getPolygonArea(p)-getCommonArea(p,s)+eps;\n    cout<<(int)ans<<endl;;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <algorithm>\n#undef max\n#undef min\n\nstd::array<std::vector<long long>, 40001> vLine;\n\nstruct Point {\n\tlong long x, y;\n};\n\nint main() {\n\tint n;\n\twhile (std::cin >> n && n) {\n\t\tPoint curtain[2];\n\n\t\tfor (auto& line : vLine) {\n\t\t\tline.clear();\n\t\t}\n\n\t\tint lx = 99999, ly = 99999;\n\t\tint firstX, firstY;\n\t\tfor (int i = 0; i < n + 1; i++) {\n\t\t\tint x, y;\n\t\t\tif (i != n) {\n\t\t\t\tstd::cin >> x >> y;\n\t\t\t\tx += 20000;\n\t\t\t\ty += 20000;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = firstX;\n\t\t\t\ty = firstY;\n\t\t\t}\n\t\t\tif (!i) {\n\t\t\t\tfirstX = x; firstY = y;\n\t\t\t}\n\t\t\tif (i) {\n\t\t\t\tfor (int j = std::min(y, ly); j < std::max(y, ly); j++) {\n\t\t\t\t\tvLine[j].push_back(x);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlx = x;\n\t\t\tly = y;\n\t\t}\n\t\tint a[4], b[4];\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tstd::cin >> a[i] >> b[i];\n\t\t\ta[i] += 20000;\n\t\t\tb[i] += 20000;\n\t\t}\n\t\tcurtain[0] = { *(std::min_element(a, &a[3])), *(std::max_element(b, &b[3])) }; // 左上\n\t\tcurtain[1] = { *(std::max_element(a, &a[3])), *(std::min_element(b, &b[3])) }; // 右下\n\n\t\t// 下からスキャン\n\t\tlong long sum = 0;\n\t\tfor (int y = 0; y < 40000; y++) {\n\t\t\tif (vLine[y].empty()) continue;\n\n\t\t\tstd::sort(vLine[y].begin(), vLine[y].end());\n\t\t\tint lx = 0;\n\t\t\tfor (int i = 0; i < vLine[y].size(); i++) {\n\t\t\t\tlong long x = vLine[y][i];\n\t\t\t\tif (i % 2) {\n\t\t\t\t\tif (y >= curtain[0].y || curtain[1].y > y || curtain[1].x <= lx || curtain[0].x >= x) sum += x - lx; // 露出している\n\t\t\t\t\telse if (curtain[0].x <= lx && x <= curtain[1].x); // 隠れている\n\t\t\t\t\telse { //中途半端\n\t\t\t\t\t\tif (lx <= curtain[0].x && curtain[1].x <= x) {\n\t\t\t\t\t\t\tsum += (x - lx) - (curtain[1].x - curtain[0].x);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (curtain[0].x < x && x <= curtain[1].x) { // 右が隠れている\n\t\t\t\t\t\t\tsum += curtain[0].x - lx;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse { // 左が隠れている\n\t\t\t\t\t\t\tsum += x - curtain[1].x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlx = x;\n\t\t\t}\n\t\t}\n\t\tstd::cout << sum << std::endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint x[101],y[101],X[4],Y[4],n;\nmain()\n{\n\twhile(cin>>n,n)\n\t{\n\t\tfor(int i=0;i<n;i++)cin>>x[i]>>y[i];\n\t\tfor(int i=0;i<4;i++)cin>>X[i]>>Y[i];\n\t\twhile(!(X[0]>X[1]&&Y[0]>Y[3]))\n\t\t{\n\t\t\tint a=X[0],b=Y[0];\n\t\t\tfor(int i=0;i<3;i++)X[i]=X[i+1],Y[i]=Y[i+1];\n\t\t\tX[3]=a,Y[3]=b;\n\t\t}\n\t\tx[n]=x[0],y[n]=y[0];\n\t\tint ans=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(x[i]==x[i-1])\n\t\t\t{\n\t\t\t\tif(X[3]<x[i])\n\t\t\t\t{\n\t\t\t\t\tint L=x[i]-X[3];\n\t\t\t\t\tint nowy=y[i-1];\n\t\t\t\t\tif(nowy<Y[3])nowy=Y[3];\n\t\t\t\t\tans+=(y[i]-nowy)*L;\n\t\t\t\t}\n\t\t\t\telse if(x[i]<X[1])\n\t\t\t\t{\n\t\t\t\t\tint L=x[i]-X[1];\n\t\t\t\t\tint nowy=y[i-1];\n\t\t\t\t\tif(nowy>Y[1])nowy=Y[1];\n\t\t\t\t\tans+=(y[i]-nowy)*L;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(Y[0]<y[i])\n\t\t\t\t{\n\t\t\t\t\tint L=y[i]-Y[0];\n\t\t\t\t\tint nowx=x[i-1];\n\t\t\t\t\tif(nowx>X[0])nowx=X[0];\n\t\t\t\t\tans+=(nowx-x[i])*L;\n\t\t\t\t}\n\t\t\t\telse if(y[i]<Y[2])\n\t\t\t\t{\n\t\t\t\t\tint L=y[i]-Y[2];\n\t\t\t\t\tint nowx=x[i-1];\n\t\t\t\t\tif(nowx<X[2])nowx=X[2];\n\t\t\t\t\tans+=(nowx-x[i])*L;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint N;\nint W, H;\nvector<int> x, y;\nvector<int> xl, yl;\nint l, r, u, b;\nbool window[300][300];\n\nint comp(vector<int> &X, vector<int> &XL)\n{\n\tvector<int> xs;\n\tfor(int i = 0; i < X.size(); i++){\n\t\txs.push_back(X[i]);\n\t\txs.push_back(X[i] - 1);\n\t}\n\txs.push_back(20005), xs.push_back(-20005);\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\tsort(xs.begin(), xs.end());\n\t\n\tfor(int i = 0; i < X.size(); i++){\n\t\tX[i] = lower_bound(xs.begin(), xs.end(), X[i]) - xs.begin();\n\t}\n\tfor(int i = 0; i < xs.size()-1; i++){\n\t\tXL.push_back(xs[i+1] - xs[i]);\n\t}\n\treturn xs.size();\n}\n\nvoid dfs(int i, int j)\n{\n\tif(i < 0 || i >= W || j < 0 || j >= H) return;\n\tif(window[i][j]) return;\n\t\n\twindow[i][j] = true;\n\tdfs(i+1, j);\n\tdfs(i-1, j);\n\tdfs(i, j+1);\n\tdfs(i, j-1);\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\t\n\t\tx.clear(), y.clear();\n\t\tint xx, yy;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> xx >> yy;\n\t\t\tx.push_back(xx), y.push_back(yy);\n\t\t}\n\t\tint A[4], B[4];\n\t\tfor(int i = 0; i < 4; i++) cin >> A[i] >> B[i];\n\t\tl = min(A[0], A[2]), r = max(A[0], A[2]);\n\t\tu = min(B[0], B[2]), b = max(B[0], B[2]);\n\t\tx.push_back(l), x.push_back(r);\n\t\ty.push_back(u), y.push_back(b);\n\t\t\n\t\txl.clear(), yl.clear();\n\t\tW = comp(x, xl);\n\t\tH = comp(y, yl);\n\t\tl = x[N], r = x[N+1];\n\t\tu = y[N], b = y[N+1];\n\t\t\n\t\tfor(int i = 0; i < W; i++){\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\twindow[i][j] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint px, py, nx, ny, dx, dy;\n\t\tint difx[105], dify[105];\n\t\t\n\t\tfor(int i = 0; i < N; i++) difx[i] = dify[i] = 0;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tpx = x[i], py = y[i];\n\t\t\tnx = x[(i+1)%N], ny = y[(i+1)%N];\n\t\t\tif(nx == px) dx = 0; \n\t\t\telse dx = (nx - px) / abs(nx - px);\n\t\t\tif(ny == py) dy = 0;\n\t\t\telse dy = (ny - py) / abs(ny - py);\n\t\t\t\n\t\t\tif(dx < 0) dify[i]--, dify[(i+1)%N]--;\n\t\t\telse if(dy > 0) difx[i]--, difx[(i+1)%N]--;\n\t\t}\n\t\tfor(int i = 0; i < N; i++) x[i] += difx[i], y[i] += dify[i];\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tpx = x[i], py = y[i];\n\t\t\tnx = x[(i+1)%N], ny = y[(i+1)%N];\n\t\t\tif(nx == px) dx = 0; \n\t\t\telse dx = (nx - px) / abs(nx - px);\n\t\t\tif(ny == py) dy = 0;\n\t\t\telse dy = (ny - py) / abs(ny - py);\n\t\t\t\n\t\t\tfor(; px != nx || py != ny; px += dx, py += dy) window[px][py] = true;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < W; i++){\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tif(window[i][j] && !window[i][j+1]){\n\t\t\t\t\tfor(int k = j+1; k < H; k++){\n\t\t\t\t\t\tif(window[i][k]){\n\t\t\t\t\t\t\tdfs(i, j+1);\n\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tend:;\n\t\t\n\t\tfor(int i = l; i < r; i++){\n\t\t\tfor(int j = u; j < b; j++){\n\t\t\t\twindow[i][j] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < W; i++){\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tif(window[i][j]) ans += xl[i] * yl[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\nmap<int,int> xmp; //座標圧縮\nmap<int,int> ymp; //座標圧縮\nP win[100];\nP car[4];\nvector<int> x;\nvector<int> y;\n\n//横xmp[x]-xmp[x-1] 縦ymp[y]-ymp[y-1]の長方形がカーテンの領域でないかつ窓の領域ならその面積を出力\n//そうでないなら0\nll addrect(int x,int y,int n)\n{\n\tll ret=0;\n\t//左下で判定（全部入ってるかそうでないかのどっちかしかない）\n\tpair<double,double> p=make_pair((double)(xmp[x]+xmp[x-1])/2.0,(double)(ymp[y]+ymp[y-1])/2.0);\n\tint cnt=0;\n\t//cerr<<p.first<<\" \"<<p.second<<endl;\n\tfor(int i=1;i<5;i++)\n\t{\n\t\tint j=i-1;\n\t\t//調べている点よりも左にある縦線を調べる\n\t\tif(car[j].first<p.first && car[j].first==car[i%4].first)\n\t\t{\n\t\t\tif(p.second>min(car[j].second,car[i%4].second) && p.second<max(car[j].second,car[i%4].second))\n\t\t\t\tcnt++;\n\t\t}\n\t}\n\tif(cnt%2==1)\n\t\treturn 0;\n\tcnt=0;\n\tfor(int i=1;i<n+1;i++)\n\t{\n\t\tint j=i-1;\n\t\t//調べている点よりも左にある縦線を調べる\n\t\tif(win[j].first<p.first && win[j].first==win[i%n].first)\n\t\t{\n\t\t\tif(p.second>min(win[j].second,win[i%n].second) && p.second<max(win[j].second,win[i%n].second))\n\t\t\t\tcnt++;\n\t\t}\n\t}\n\t//cerr<<cnt<<endl;\n\tif(cnt%2==1)\n\t\tret=(ll)(xmp[x]-xmp[x-1])*(ll)(ymp[y]-ymp[y-1]);\n\treturn ret;\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tint n;\n\t\tll ans=0;\n\t\tcin>>n;\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tx.clear();\n\t\ty.clear();\n\t\txmp.clear();\n\t\tymp.clear();\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\twin[i]=P(a,b);\n\t\t\tx.push_back(a);\n\t\t\ty.push_back(b);\n\t\t}\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\tcar[i]=P(a,b);\n\t\t\tx.push_back(a);\n\t\t\ty.push_back(b);\n\t\t}\n\t\tsort(x.begin(),x.end());\n\t\tx.erase(unique(x.begin(),x.end()),x.end());\n\t\tsort(y.begin(),y.end());\n\t\ty.erase(unique(y.begin(),y.end()),y.end());\n\t\tfor(int i=0;i<x.size();i++)\n\t\t\txmp[i]=x[i];\n\t\tfor(int i=0;i<y.size();i++)\n\t\t\tymp[i]=y[i];\n\t\t\n\t\tfor(int i=1;i<x.size();i++)\n\t\t{\n\t\t\tfor(int j=1;j<y.size();j++)\n\t\t\t{\n\t\t\t\tans+=addrect(i,j,n);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst int INF = 1LL << 29;\nconst ll LONGINF = 1LL << 60;\nconst ll MOD = 1000000007LL;\n\nconst int MAXW = 40010;\nconst int ofs = 20000;\n\n// @category セグメント木 (Segment Tree)\n// @title 遅延伝播セグメント木 (Lazy Segment Tree)\ntemplate <typename MonoidType, typename OperatorType>\nstruct LazySegmentTree {\n    using MMtoM = function< MonoidType(MonoidType, MonoidType) >;\n    using OOtoO = function< OperatorType(OperatorType, OperatorType) >;\n    using MOtoM = function< MonoidType(MonoidType, OperatorType) >;\n    using OItoO = function< OperatorType(OperatorType, int) >;\n\n    // node, lazy, update flag (for lazy), identity element\n    int n;\n    vector<MonoidType> node;\n    vector<OperatorType> lazy;\n    vector<bool> need_update;\n    MonoidType E0;\n    OperatorType E1;\n\n    // update / combine / lazy / accumulate function\n    MOtoM upd_f;\n    MMtoM cmb_f;\n    OOtoO lzy_f;\n    OItoO acc_f;\n\n    void build(int m, vector<MonoidType> v = vector<MonoidType>()) {\n        if(v != vector<MonoidType>()) m = v.size();\n        n = 1; while(n < m) n *= 2;\n\n        node = vector<MonoidType>(2*n-1, E0);\n        lazy = vector<OperatorType>(2*n-1, E1);\n        need_update = vector<bool>(2*n-1, false);\n        if(v != vector<MonoidType>()) {\n            for(int i=0; i<m; i++) {\n                node[n-1+i] = v[i];\n            }\n            for(int i=n-2; i>=0; i--) {\n                node[i] = cmb_f(node[2*i+1], node[2*i+2]);\n            }\n        }\n    }\n\n    // initialize\n    LazySegmentTree() {}\n    LazySegmentTree(int n_, MonoidType E0_, OperatorType E1_,\n                    MOtoM upd_f_, MMtoM cmb_f_, OOtoO lzy_f_, OItoO acc_f_,\n                    vector<MonoidType> v = vector<MonoidType>()) :\n        E0(E0_), E1(E1_),\n        upd_f(upd_f_), cmb_f(cmb_f_), lzy_f(lzy_f_), acc_f(acc_f_) {\n        build(n_, v);\n    }\n\n    void eval(int k, int l, int r) {\n        if(!need_update[k]) return;\n        node[k] = upd_f(node[k], acc_f(lazy[k], r - l));\n        if(r - l > 1) {\n            lazy[2*k+1] = lzy_f(lazy[2*k+1], lazy[k]);\n            lazy[2*k+2] = lzy_f(lazy[2*k+2], lazy[k]);\n            need_update[2*k+1] = need_update[2*k+2] = true;\n        }\n        lazy[k] = E1;\n        need_update[k] = false;\n    }\n\n    void update(int a, int b, OperatorType x, int l, int r, int k) {\n        eval(k, l, r);\n        if(b <= l or  r <= a) return;\n        if(a <= l and r <= b) {\n            lazy[k] = lzy_f(lazy[k], x);\n            need_update[k] = true;\n            eval(k, l, r);\n        }\n        else {\n            int mid = (l + r) / 2;\n            update(a, b, x, l, mid, 2*k+1);\n            update(a, b, x, mid, r, 2*k+2);\n            node[k] = cmb_f(node[2*k+1], node[2*k+2]);\n        }\n    }\n\n    MonoidType query(int a, int b, int l, int r, int k) {\n        if(b <= l or  r <= a) return E0;\n        eval(k, l, r);\n        if(a <= l and r <= b) return node[k];\n        int mid = (l + r) / 2;\n        MonoidType vl = query(a, b, l, mid, 2*k+1);\n        MonoidType vr = query(a, b, mid, r, 2*k+2);\n        return cmb_f(vl, vr);\n    }\n\n    // update [a, b)-th element (applied value, x)\n    void update(int a, int b, OperatorType x) {\n        update(a, b, x, 0, n, 0);\n    }\n\n    // range query for [a, b)\n    MonoidType query(int a, int b) {\n        return query(a, b, 0, n, 0);\n    }\n\n    void dump() {\n        fprintf(stderr, \"[lazy]\\n\");\n        for(int i=0; i<2*n-1; i++) {\n            if(i == n-1) fprintf(stderr, \"xxx \");\n            if(lazy[i] == E1) fprintf(stderr, \"  E \");\n            else fprintf(stderr, \"%3d \", lazy[i]);\n        }\n        fprintf(stderr, \"\\n\");\n\n        fprintf(stderr, \"[node]\\n\");\n        for(int i=0; i<2*n-1; i++) {\n            if(i == n-1) fprintf(stderr, \"xxx \");\n            if(node[i] == E0) fprintf(stderr, \"  E \");\n            else fprintf(stderr, \"%3d \", node[i]);\n        }\n        fprintf(stderr, \"\\n\");\n    }\n};\n\nint solve_testcase() {\n    int N; scanf(\"%d\", &N);\n    if(N == 0) return 1;\n\n    vector< vector< pair<int, int> > > add_y(MAXW), del_y(MAXW);\n    vector<int> X(N), Y(N), pari(N);\n    for(int i=0; i<N; i++) {\n        scanf(\"%d%d\", &X[i], &Y[i]);\n        X[i] += ofs, Y[i] += ofs;\n    }\n    for(int i=0; i<N; i++) {\n        int u = i, v = (i + 1) % N;\n        if(Y[u] == Y[v]) continue;\n        int mi = min(Y[u], Y[v]), ma = max(Y[u], Y[v]);\n        add_y[mi].emplace_back(X[u], i);\n        del_y[ma].emplace_back(X[u], i);\n    }\n    for(int i=0; i<MAXW; i++) {\n        sort(add_y[i].begin(), add_y[i].end());\n        sort(del_y[i].begin(), del_y[i].end());\n    }\n\n    int wx1 = INF, wx2 = -INF, wy1 = INF, wy2 = -INF;\n    for(int i=0; i<4; i++) {\n        int s, t; scanf(\"%d%d\", &s, &t);\n        s += ofs, t += ofs;\n        chmin(wx1, s);\n        chmax(wx2, s);\n        chmin(wy1, t);\n        chmax(wy2, t);\n    }\n\n    LazySegmentTree<int, int> seg1(MAXW, 0, 0,\n                                   [](int a, int b) { return a + b; },\n                                   [](int a, int b) { return a + b; },\n                                   [](int a, int b) { return a + b; },\n                                   [](int a, int x) { return a * x; });\n    LazySegmentTree<int, int> seg2(MAXW, 0, 0,\n                                   [](int a, int b) { return a + b; },\n                                   [](int a, int b) { return a + b; },\n                                   [](int a, int b) { return a + b; },\n                                   [](int a, int x) { return a * x; });\n\n    ll ans = 0;\n    for(int i=0; i<MAXW; i++) {\n        for(auto p : del_y[i]) {\n            int x, k; tie(x, k) = p;\n            seg1.update(x, x+1, -1);\n            seg2.update(x, MAXW, (pari[k] ? +1 : -1));\n        }\n        for(auto p : add_y[i]) {\n            int x, k; tie(x, k) = p;\n            int m = seg1.query(0, x) % 2;\n            pari[k] = m;\n            // fprintf(stderr, \"add (i = %d): x = %d, pari = %d\\n\", i, x, pari[k]);\n            seg1.update(x, x+1, +1);\n            seg2.update(x, MAXW, (pari[k] ? -1 : +1));\n        }\n\n        ll add = 0;\n        if(wy1 <= i and i < wy2) {\n            add += seg2.query(0, wx1);\n            add += seg2.query(wx2, MAXW);\n        }\n        else {\n            add += seg2.query(0, MAXW);\n        }\n        // if(add > 0) fprintf(stderr, \"i = %d, add = %lld\\n\", i, add);\n        ans += add;\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n\n\n\nint main() {\n    while(!solve_testcase());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ndouble x[105], y[105], a[4], b[4];\n\n//point\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n// line\nstruct L : public vector<P> {\n\tL(const P& a, const P& b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\t\t\t\t\t\t\t\t  // a--c--b on line\n}\n\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\n// polygon\ntypedef vector<P> G;\n\nenum { OUT, ON, IN };\nint contains(const G& po, const P& p) {\n  bool in = false;\n  for (int i = 0; i < po.size(); ++i) {\n  \tP a = po[i] - p, b = po[(i+1)%po.size()] - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\ndouble area2(const G& po) {\n\tdouble A = 0;\n  \tfor (int i = 0; i < po.size(); ++i)\n    \tA += cross(po[i], po[(i+1)%po.size()]);\n\t//?????????|????????????????????????????????????????????????\n  \treturn A/2;\n}\n\nP p[105];\nvector<L> l;\nsigned main(void)\n{\n  while(true) {\n    int n;\n    cin >> n;\n    if(!n) break;\n\n    G all;\n    REP(i, n) {\n      cin >> x[i] >> y[i];\n      p[i] = P{x[i], y[i]};\n      all.PB(p[i]);\n    }\n    vector<pair<double, double>> c[2];\n    // right 0 ue 1 left 2 sita 3\n    int d[4];\n    REP(i, 4) cin >> a[i] >> b[i];\n    REP(i, 4) {\n      if(a[i] == a[(i+1)%4]) {\n        if(c[0].size() == 0) c[0].PB(MP(a[i], i));\n        else {\n          if(c[0][0].first > a[i]) d[i] = 2, d[(int)c[0][0].second] = 0;\n          else d[i] = 0, d[(int)c[0][0].second] = 2;\n        }\n      } else {\n        if(c[1].size() == 0) c[1].PB(MP(b[i], i));\n        else {\n          if(c[1][0].first > b[i]) d[i] = 3, d[(int)c[1][0].second] = 1;\n          else d[i] = 1, d[(int)c[1][0].second] = 3;\n        }\n      }\n    }\n    //REP(i, 4) cout << d[i] << \" \"; cout << endl;\n\n    REP(i, 4) {\n      REP(j, n) {\n        if(d[i] == 0) {\n          x[j] = min(x[j], a[i]);\n        } else if(d[i] == 1) {\n          y[j] = min(y[j], b[i]);\n        } else if(d[i] == 2) {\n          x[j] = max(x[j], a[i]);\n        } else {\n          y[j] = max(y[j], b[i]);\n        }\n      }\n    }\n    G in;\n    REP(i, n) {\n      //cout << x[i] << \" \" << y[i] << endl;\n      in.PB(P{x[i], y[i]});\n    }\n\n    //cout << area2(all) << \" \" << area2(in) << endl;\n    cout << fixed << setprecision(15) << area2(all) - area2(in) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nvector<ll> x;\nvector<ll> xx;\nvector<ll> y;\nvector<ll> yy;\n\nchar mp[444][444];\nchar cmp[444][444];\n\nvoid zaatu(){\n\tREP(i,x.size()){\n\t\txx.PB(x[i]);\n\t\txx.PB(x[i]+1);\n\t\txx.PB(x[i]-1);\n\t}\n\tREP(i,y.size()){\n\t\tyy.PB(y[i]);\n\t\tyy.PB(y[i]+1);\n\t\tyy.PB(y[i]-1);\n\t}\n\tsort(ALL(xx));\n\tsort(ALL(yy));\n\txx.erase(unique(ALL(xx)),xx.end());\n\tyy.erase(unique(ALL(yy)),yy.end());\n\t\n\tREP(i,x.size()){\n\t\tx[i] = lower_bound(ALL(xx),x[i]) - xx.begin();\n\t\ty[i] = lower_bound(ALL(yy),y[i]) - yy.begin();\n\t}\n}\n\t\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tREP(i,444)REP(j,444)mp[i][j] = '.';\n\t\tREP(i,444)REP(j,444)cmp[i][j] = '.';\n\t\tx.clear();\n\t\ty.clear();\n\t\txx.clear();\n\t\tyy.clear();\n\t\tREP(i,n+4){\n\t\t\tint a,b;cin >> a >> b;\n\t\t\tx.PB(a);\n\t\t\ty.PB(b);\n\t\t}\n\t\t\n\t\tzaatu();\n\t\t\n\t\tREP(i,n){\n\t\t\tmp[y[i]][x[i]] = '#';\n\t\t}\n\t\t\n\t\tbool flag = false;\n\t\tREP(i,444){\n\t\t\tREP(j,444){\n\t\t\t\tif(mp[i][j] == '#')flag = !flag;\n\t\t\t\tif(flag)mp[i][j] = '#';\n\t\t\t\telse mp[i][j] = '.';\n\t\t\t}\n\t\t\tflag = false;\n\t\t}\n\t\t//SHOW2d(mp,3*n,3*n);\n\t\t\n\t\tflag = false;\n\t\tREP(j,444){\n\t\t\tREP(i,444){\n\t\t\t\tif(mp[i][j] == '#')flag = !flag;\n\t\t\t\tif(flag)mp[i][j] = '#';\n\t\t\t\telse mp[i][j] = '.';\n\t\t\t}\n\t\t\tflag = false;\n\t\t}\n\t\t//SHOW2d(mp,3*n,3*n);\n\t\t\n\t\tREP(i,4){\n\t\t\tcmp[y[i+n]][x[i+n]] = '!';\n\t\t}\n\t\t\n\t\tflag = false;\n\t\tREP(i,444){\n\t\t\tREP(j,444){\n\t\t\t\tif(cmp[i][j] == '!')flag = !flag;\n\t\t\t\tif(flag)cmp[i][j] = '!';\n\t\t\t\telse cmp[i][j] = '.';\n\t\t\t}\n\t\t\tflag = false;\n\t\t}\n\t\t\n\t\tflag = false;\n\t\tREP(j,444){\n\t\t\tREP(i,444){\n\t\t\t\tif(cmp[i][j] == '!')flag = !flag;\n\t\t\t\tif(flag)mp[i][j] = '!';\n\t\t\t\telse cmp[i][j] = '.';\n\t\t\t}\n\t\t\tflag = false;\n\t\t}\n\t\t\t\t\n\t\tREP(i,444){\n\t\t\tREP(j,444){\n\t\t\t\tif(cmp[i][j] == '!')mp[i][j] = '!';\n\t\t\t}\n\t\t}\n\t\t//SHOW2d(mp,3*n,3*n);\t\n\n\t\t//SHOW1d(xx,xx.size());\n\t\t//SHOW1d(yy,yy.size());\n\t\t\n\t\tll ans = 0;\n\t\t\n\t\tREP(i,444){\n\t\t\tREP(j,444){\n\t\t\t\tif(mp[i][j] == '#'){\n\t\t\t\t\t//cout << i << ' ' << j << ' '<< yy[i+1] << ' ' << yy[i] << ' ' << xx[j+1] << ' ' << xx[j] << endl;\n\t\t\t\t\tans += (yy[i+1] - yy[i]) * (xx[j+1] - xx[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\nstruct UnionFind{ //// sorry, i'm unko\n  vector<int> v;\n  UnionFind(int n) : v(n, -1) {}\n  int find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n  bool unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (-v[x] < -v[y]) swap(x, y);\n    v[x] += v[y]; v[y] = x;\n    return true;\n  }\n  bool same(int x, int y) { return find(x) == find(y); }\n};\n\nint n;\nint X[111],Y[111];\nint A[5],B[5];\nvector<int> xps,yps;\nint x[111],y[111],a[5],b[5];\nbool aru[111][111];\nint dd[]={-1,0,1,0,-1};\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    int x1=INF,y1=INF,x2=-INF,y2=-INF;\n    rep(i,n)cin>>X[i]>>Y[i];\n    rep(i,4){\n      cin>>A[i]>>B[i];\n      minch(x1,A[i]); maxch(x2,A[i]);\n      minch(y1,B[i]); maxch(y2,B[i]);\n    }\n\n    xps.clear();\n    xps.pb(-114514);\n    rep(i,n)xps.pb(X[i]);\n    rep(i,4){\n      xps.pb(A[i]);\n    }\n    sort(all(xps));\n    uni(xps);\n    rep(i,n){\n      x[i]=lower_bound(all(xps),X[i])-xps.begin();\n    }\n    x1=lower_bound(all(xps),x1)-xps.begin();\n    x2=lower_bound(all(xps),x2)-xps.begin();\n\n    yps.clear();\n    yps.pb(-114514);\n    rep(i,n)yps.pb(Y[i]);\n    rep(i,4)yps.pb(B[i]);\n    sort(all(yps));\n    uni(yps);\n    rep(i,n){\n      y[i]=lower_bound(all(yps),Y[i])-yps.begin();\n    }\n    y1=lower_bound(all(yps),y1)-yps.begin();\n    y2=lower_bound(all(yps),y2)-yps.begin();\n\n    //dbg(x1); dbg(x2); dbg(y1); dbg(y2);\n\n    memset(aru,0,sizeof(aru));\n    rep(i,n)aru[y[i]][x[i]]=true;\n\n    rep(i,n){\n      int si=y[i],sj=x[i];\n      int ti=y[(i+1)%n],tj=x[(i+1)%n];\n      if(si==ti){\n        repl(k,min(sj,tj),max(sj,tj)){\n          aru[si][k]=true;\n        }\n      }else if(sj==tj){\n        repl(k,min(si,ti),max(si,ti)){\n          aru[k][sj]=true;\n        }\n      }\n    }\n    /*\n    rep(i,20)rep(j,20){\n      printf(\"%d%c\", aru[i][j],j==19?'\\n':' ');\n    }\n    printf(\"\\n\");\n  */\n    UnionFind uf(111*111);\n    rep(i,111)rep(j,111){\n      if(!aru[i][j]){\n        rep(d,4){\n          int ni=i+dd[d],nj=j+dd[d+1];\n          if(ni>=0&&ni<111&&nj>=0&&nj<111&&!aru[ni][nj]){\n            uf.unite(i*111+j,ni*111+nj);\n          }\n        }\n      }\n    }\n    rep(i,111)rep(j,111){\n      if(!uf.same(i*111+j,110*111+110))aru[i][j]=true;\n    }\n    /*\n    rep(i,20)rep(j,20){\n      printf(\"%d%c\", aru[i][j],j==19?'\\n':' ');\n    }*/\n    ll res=0;\n    rep(i,110)rep(j,110){\n      if(i>=y1&&i+1<=y2&&j>=x1&&j+1<=x2)continue;\n      if(aru[i][j]&&aru[i+1][j+1]){\n        res+=(yps[i+1]-yps[i])*(xps[j+1]-xps[j]);\n      }\n    }\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint compress(vector<int>& xs, vector<int>& x) {\n    const int N = x.size();\n    sort(xs.begin(), xs.end());\n    xs.erase(unique(xs.begin(), xs.end()), xs.end());\n    for(int i=0; i<N; ++i) {\n        x[i] = lower_bound(xs.begin(), xs.end(), x[i]) - xs.begin();\n    }\n    return xs.size();\n}\n\nint main() {\n    int N;\n    while(cin >> N, N) {\n        vector<int> x(N), y(N);\n        vector<int> xs, ys;\n        vector<int> a(4), b(4);\n        for(int i=0; i<N; ++i) {\n            cin >> x[i] >> y[i];\n            xs.push_back(x[i]);\n            ys.push_back(y[i]);\n        }\n        for(int i=0; i<4; ++i) {\n            cin >> a[i] >> b[i];\n            xs.push_back(a[i]);\n            ys.push_back(b[i]);\n        }\n        int W = compress(xs, x);\n        int H = compress(ys, y);\n        int cx1 = 10000, cx2 = 0, cy1 = 10000, cy2 = 0;\n        for(int i=0; i<4; ++i) {\n            a[i] = lower_bound(xs.begin(), xs.end(), a[i]) - xs.begin();\n            b[i] = lower_bound(ys.begin(), ys.end(), b[i]) - ys.begin();\n            cx1 = min(cx1, a[i]);\n            cx2 = max(cx2, a[i]);\n            cy1 = min(cy1, b[i]);\n            cy2 = max(cy2, b[i]);\n        }\n        vector<vector<int>> flag(H, vector<int>(W));\n        for(int i=0; i<N; ++i) {\n            int i2 = (i+1)%N;\n            if(x[i] != x[i2]) {\n                continue;\n            }\n            int miny = min(y[i], y[i2]), maxy = max(y[i], y[i2]);\n            for(int j=miny; j<maxy; ++j) {\n                flag[j][x[i]] = 1;\n            }\n        }\n        for(int i=cy1; i<cy2; ++i) {\n            flag[i][cx1] |= 2;\n            flag[i][cx2] |= 2;\n        }\n        for(int i=0; i<H; ++i) {\n            for(int j=0; j+1<W; ++j) {\n                flag[i][j+1] ^= flag[i][j];\n            }\n        }\n        int res = 0;\n        for(int i=0; i+1<H; ++i) {\n            for(int j=0; j+1<W; ++j) {\n                if(flag[i][j] == 1) {\n                    res += (ys[i+1] - ys[i]) * (xs[j+1] - xs[j]);\n                }\n            }\n        }\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\ntemplate <typename T>\nclass CompressCoordinate{\npublic:\n\tvector<T> a, c; // 圧縮した数列、ソートした数列\n\tCompressCoordinate(const vector<T>& arg){\n\t\ta = vector<T>(arg.size());\n\t\tc = arg;\n\t\tcompress(c);\n\t\trep(i,arg.size()){\n\t\t\ta[i] = lb(c, arg[i]);\n\t\t}\n\t}\n\tvoid compress(vector<T> &v) {\n\t\tsort(v.begin(), v.end());\n\t\tv.erase(unique(v.begin(),v.end()),v.end());\n\t}\n\tint lb(const vector<T>& v, T num){\n\t\treturn lower_bound(all(v), num) - v.begin();\n\t}\n\tint map(T a){\n\t\treturn lb(c, a);\n\t}\n};\n\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nvoid dfs(int y, int x, vector<vector<int>>& m){\n\tm[y][x] = -1;\n\trep(i,4){\n\t\tint ny = y + dy[i];\n\t\tint nx = x + dx[i];\n\t\tif(ny < 0 || ny >= 200 || nx < 0 || nx >= 200) continue;\n\t\tif(m[ny][nx] != 0) continue;\n\t\tdfs(ny, nx, m);\n\t}\n}\n\nvector<vector<int>> getGrid(CompressCoordinate<long long>& cx, CompressCoordinate<long long>& cy, vector<long long>& x, vector<long long>& y){\n\tvector<vector<int>> m(200, vector<int>(200, 0));\n\tint n = x.size();\n\trep(i,n){\n\t\tpair<int, int> a = make_pair(cx.map(x[i]), cy.map(y[i]));\n\t\tpair<int, int> b = make_pair(cx.map(x[(i + 1) % n]), cy.map(y[(i + 1) % n]));\n\t\tif(a.first > b.first) swap(a,b);\n\t\tif(a.first == b.first and a.second > b.second) swap(a,b);\n\t\tassert(a < b);\n\n\t\t//cout << a.first << ' ' << a.second << endl;\n\t\t//cout << b.first << ' ' << b.second << endl;\n\t\t//cout << endl;\n\t\tm[a.second][a.first] = 1;\n\t\twhile(a != b){\n\t\t\tm[a.second][a.first] = 1;\n\t\t\tif(a.first == b.first) a.second++;\n\t\t\telse a.first++;\n\t\t}\n\t\tm[a.second][a.first] = 1;\n\t}\n\n\tif(m[0][0] == 0) dfs(0,0,m);\n\tdfs(199, 199, m);\n\n\tvector<pair<int, int>> d;\n\trep(i,200 - 1){\n\t\trep(j,200 - 1){\n\t\t\tif(m[i][j] == 0) m[i][j] = 1;\n\t\t}\n\t}\n\trep(i,200 - 1){\n\t\trep(j,200 - 1){\n\t\t\tif(m[i][j] == 1 and m[i][j + 1] != 1) d.emplace_back(i,j);\n\t\t\tif(m[i][j] == 1 and m[i + 1][j] != 1) d.emplace_back(i,j);\n\t\t}\n\t}\n\tfor(auto i : d){\n\t\tm[i.first][i.second] = -1;\n\t}\n\treturn m;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\t//vector<pair<int, int>> win(n);\n\t\tvector<long long> comx(n + 4), comy(n + 4);\n\t\tvector<long long> x(n), y(n);\n\t\trep(i,n){\n\t\t\tcin >> x[i] >> y[i];\n\t\t\tcomx[i] = x[i];\n\t\t\tcomy[i] = y[i];\n\t\t\t//win[i] = make_pair(x[i], y[i]);\n\t\t}\n\n\t\tvector<long long> X(4), Y(4);\n\t\trep(i,4){\n\t\t\tcin >> comx[i + n] >> comy[i + n];\n\t\t\tX[i] = comx[i + n];\n\t\t\tY[i] = comy[i + n];\n\t\t}\n\n\t\tCompressCoordinate<long long> cx(comx), cy(comy);\n\n\t\tvector<vector<int>> window = getGrid(cx, cy, x, y), curtain = getGrid(cx, cy, X, Y);\n\t\t//cout << endl; rep(i,10){ rep(j,10){ cout << curtain[i][j] << ' '; } cout << endl; }\n\t\t//cout << endl; rep(i,10){ rep(j,10){ cout << window[i][j] << ' '; } cout << endl; }\n\t\trep(i,200){\n\t\t\trep(j,200){\n\t\t\t\tif(curtain[i][j] == 1) window[i][j]--;\n\t\t\t}\n\t\t}\n\n\t\t//cout << endl; rep(i,10){ rep(j,10){ cout << window[i][j] << ' '; } cout << endl; }\n\n\n\t\tlong long ans = 0;\n\t\trep(i,200){\n\t\t\trep(j,200){\n\t\t\t\tif(window[i][j] >= 1){\n\t\t\t\t\t//cout << (cy.c[i + 1] - cy.c[i]) << ' ' << (cx.c[j  + 1] - cx.c[j]) << endl;\n\t\t\t\t\tans += (cy.c[i + 1] - cy.c[i]) * (cx.c[j + 1] - cx.c[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n#include <complex>\n\nusing namespace std;\n   \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n   \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n  \nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\nconst double PI = acos(-1);\n\ntypedef complex<double> P;\ndouble cross(const P& p, const P& q){return imag(conj(p)*q);}\n\nint main(){\n    int n;\n    while(cin>>n&&n){\n        vector<P> p;\n        double x, y;\n        rep(i, n){\n            cin>>x>>y;\n            p.pb({x, y});\n        }\n        P q[4];\n        rep(i, 4){\n            cin>>x>>y;\n            q[i] = {x, y};\n        }\n        double s = 0.0;\n        rep(i, n) s += cross(p[i], p[(i+1)%n])/2;\n        s = abs(s);\n        double mx,Mx,my,My;\n        mx = my = 1e18;\n        Mx = My = 0;\n        rep(i, 4){\n            mx = min(mx, real(q[i]));\n            my = min(my, imag(q[i]));\n            Mx = max(Mx, real(q[i]));\n            My = max(My, imag(q[i]));\n        }\n        rep(i, n){\n            x = real(p[i]);\n            y = imag(p[i]);\n            if(mx>x) x = mx;\n            else if(Mx<x) x = Mx;\n            if(my>y) y = my;\n            else if(My < y) y = My;\n            p[i] = {x, y};\n        }\n        double s2 = 0.0;\n        rep(i, n) s2 += cross(p[i], p[(i+1)%n])/2; \n        s2 = abs(s2);       \n        printf(\"%lld\\n\",(ll)(s-s2));        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAX_N = 1<<16;\n\nclass RSQ2{\npublic:\n  ll n,dat[2*MAX_N-1],td[2*MAX_N-1];\n  //?????????\n  RSQ2(){n=MAX_N,memset(dat,0,sizeof(dat)),memset(td,0,sizeof(td));};\n  \n  //[a,b)????????????x???????????????,query(a,b,x);\n  ll add(int a,int b,ll x,int k=0,int l=0,int r=-1){\n    if(r==-1) r=n;\n    if(r<=a||b<=l)return 0;\n    if(a<=l&&r<=b){\n      dat[k]+=(r-l)*x; \n      td[k]+=x;\n      return dat[k];\n    }\n\n    dat[k]+=(min(r,b)-max(l,a))*x;\n    ll kl=k*2+1,kr=k*2+2,t=td[k]*(r-l)/2;\n    dat[kl]+=t, dat[kr]+=t;\n    td[kl]+=td[k], td[kr]+=td[k];\n    td[k]=0;\n\n    ll vl=add(a,b,x,k*2+1,l,(l+r)/2);\n    ll vr=add(a,b,x,k*2+2,(l+r)/2,r);\n    return vl+vr;\n  }\n  \n  //[a,b)??????????????????\n  ll sum(int a,int b){return a>=b? 0:add(a,b,0);}\n};\n\n\nstruct data{int l,r;};\nstruct P{int x,y;};\nconst int Base=20010;\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<vector<data> > LR(MAX_N);\n    vector<P> A(n);\n    for(int i=0;i<n;i++)cin>>A[i].x>>A[i].y,A[i].x+=Base,A[i].y+=Base;\n    for(int i=0;i<n;i++)\n      if(A[i].y==A[(i+1)%n].y)\n\tLR[A[i].y].push_back((data){A[i].x,A[(i+1)%n].x});\n    \n    vector<data> C(MAX_N,(data){-1e9,-1e9});  \n    A.resize(4);\n    for(int i=0;i<4;i++)cin>>A[i].x>>A[i].y;\n    for(int i=0;i<n;i++)\n      if(A[i].y==A[(i+1)%n].y) C[A[i].y]=(data){A[i].x,A[(i+1)%n].x};\n    \n    RSQ2 T;\n    int ans=0;\n    for(int i=0,flg=1,cl=0,cr=0;i<MAX_N;i++){\n      if(flg&&C[i].l!=-1e9) cl=C[i].l,cr=C[i].r,flg=0;\n      else if(flg==0&&C[i].l!=-1e9) cl=cr=0;\n      \n      for(int j=0;j<LR[i].size();j++){\n\tint l = LR[i][j].l,r=LR[i][j].r;\n\tl<r ? T.add(l,r,1): T.add(r,l,-1);\n      }\n      ans+=T.sum(0,cl)+T.sum(cr,T.n);\n\n    }\n    cout <<ans<<endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> Point;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(b, c) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(b, c) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(b) < norm(c)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// ??´?????¨???????????¢\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), nret.begin(), nret.end());\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tfor (int j = 0;j < n;j++) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tfor (int i = 0;i < n;i++) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n// -1 => out\n//  0 => on\n//  1 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tfor (int i = 0;i < n;i++) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// ??????\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n// ????????????\nPolygon convex_cut(const Polygon &ps, Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tfor (int i = 0;i < n;i++) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n\t\t\tQ.push_back(is_ll(l, m));\n\t}\n\treturn Q;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint N;\n\twhile (cin >> N, N) {\n\t\tPolygon ps(N);\n\t\tfor (int i = 0; i < N;i++) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tps[i] = Point(x, y);\n\t\t}\n\t\tll Area = area(ps);\n\t\tPolygon curtain(4);\n\t\tfor (int i = 0; i < 4;i++) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tcurtain[i] = Point(x, y);\n\t\t}\n\t\tfor (int i = 0; i < 4;i++) {\n\t\t\tps = convex_cut(ps, Line(curtain[i], curtain[(i + 1) % 4]));\n\t\t}\n\t\tll in_Area = area(ps);\n\t\tcout << Area - in_Area << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <iostream>\n#include <utility>\n#include <vector>\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> Poly;\ntypedef pair<P,P> L;\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble dot(P a, P b){return a.X*b.X + a.Y*b.Y;}\n\ndouble cross(P a, P b){return a.X*b.Y - a.Y*b.X;}\n\nint ccw(P a, P b, P c){\n  b -= a;c -= a;\n  if(cross(b, c) > EPS) return 1;\n  if(cross(b, c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(c) - norm(b) > EPS) return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  if(ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0 &&\n     ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0) return true;\n  return false;\n}\n\n\nP intersection(L a, L b){\n  //テァツ崢エテァツキツ啾テ」ツ?ィテァツ崢エテァツキツ喘テ」ツ?ョテ、ツコツ、テァツつケ\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nint in_poly(P a, Poly p){\n  int n = p.size(), c = 0;\n  for(int i = 0; i < n; ++i){\n    P s = p[i]-a, t = p[(i+1)%n]-a;\n    if(!ccw(s,t,P(0,0))) return 1;//ティツセツコテ、ツクツ?\n    if(s.Y > t.Y + EPS) swap(s,t);\n    if((s.Y*t.Y < 0 || (s.Y*t.Y < EPS && t.Y > EPS)) && cross(s,t) < EPS) ++c;\n  }\n  if(c%2) return 2;//テ・ツ??ゥツδィ\n  return 0;//テ・ツ、ツ姪ゥツδィ\n}\n\nlong long int solve(int N, Poly W, Poly C){\n  vector< pair<double, P> > S;\n  bool f = true;\n  int c = 0;\n  for(int i = 0; i < N; ++i){\n    if(in_poly(W[i], C) == 2){\n      f = false;\n      break;\n    }\n    if(in_poly(W[i], C) == 1) ++c;\n  }\n  for(int i = 0; i < 4; ++i){\n    if(in_poly(C[i], W) == 2){\n      f = false;\n      break;\n    }\n    if(in_poly(C[i], W) == 1) ++c;\n  }\n  if(f && c < 3){\n    long long int s = 0LL;\n    for(int i = 0; i < N; ++i)\n      s += (long long int)cross(W[i],W[(i+1)%N]);\n    return s/2;\n  }\n  P m = (C[0]+C[2])/2.0;\n  for(int i = 0; i < N; ++i){\n    if(!in_poly(W[i],C)) S.push_back(make_pair(arg(W[i]-m),W[i]-m));\n  }\n  for(int i = 0; i < 4; ++i){\n    if(!in_poly(C[i],W)) S.push_back(make_pair(arg(C[i]-m),C[i]-m));\n  }\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < 4; ++j){\n      L l1 = L(W[i],W[(i+1)%N]), l2 = L(C[j],C[(j+1)%4]);\n      if(is_cross(l1, l2)){\n\tif(abs(cross(l1.first-l1.second, l2.first-l2.second)) < EPS){\n\t  S.push_back(make_pair(arg(l1.first-m),(l1.first-m)));\n\t  S.push_back(make_pair(arg(l1.second-m),(l1.second-m)));\n\t  S.push_back(make_pair(arg(l2.first-m),(l2.first-m)));\n\t  S.push_back(make_pair(arg(l2.second-m),(l2.second-m)));\n\t}else{\n\t  P cp = intersection(l1,l2)-m;\n\t  S.push_back(make_pair(arg(cp),cp));\n\t}\n      }\n    }\n  }\n  sort(S.begin(), S.end());\n  int n = S.size();\n  double s = 0.0;\n  //cout << m << endl;\n  for(int i = 0; i < n; ++i){\n    //cout << S[i].second+m << endl;\n    s += cross(S[i].second,S[(i+1)%n].second);\n  }\n  for(int i = 0; i < 4; ++i) s -= cross(C[i],C[(i+1)%4]);\n  return (long long int)s/2;\n}\n\nint main(){\n  int N;\n  while(cin >> N, N){\n    Poly W;\n    double x, y;\n    for(int i = 0; i < N; ++i){\n      cin >> x >> y;\n      W.push_back(P(x,y));\n    }\n    Poly C;\n    for(int i = 0; i < 4; ++i){\n      cin >> x >> y;\n      C.push_back(P(x,y));\n    }\n    cout << solve(N, W, C) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int, int> P;\n\nlong long calcArea(const vector<P> &pts){\n    long long sum = 0;\n    for(int i=0;i<pts.size();i++){\n        P a = pts[i];\n        P b = pts[(i+1)%pts.size()];\n        sum += a.first*b.second - a.second*b.first;\n    }\n    if(sum<0)sum = -sum;\n    return sum / 2;\n}\n\n\nint main(){\n    for(int n; cin>>n, n; ){\n        long long sum = 0;\n        vector<P>C;\n        vector<P>W;\n        set<int>X;\n        set<int>Y;\n        int xmin = 40000, xmax = -40000;\n        int ymin = 40000, ymax = -40000;\n        for(int i = 0; i < n; i++){\n            int x, y;\n            cin>>x>>y;\n            W.push_back(P(x, y));\n            X.insert(x);\n            Y.insert(y);\n        }\n        for(int i=0;i<4;i++){\n            int x, y;\n            cin>>x>>y;\n            C.push_back(P(x, y));            \n            X.insert(x);\n            Y.insert(y);\n            xmin = min(xmin, x);\n            xmax = max(xmax, x);\n            ymin = min(ymin, y);\n            ymax = max(ymax, y);\n        }\n        set<int>::iterator l = X.begin();\n        set<int>::iterator r = X.begin();\n        r++;\n        for(; r != X.end(); l++, r++){\n            if(xmin <= (*l) && (*r) <= xmax){\n                int d = (*r) - (*l);\n                set<int>::iterator b = Y.begin();\n                set<int>::iterator u = Y.begin();\n                u++;\n                for(int on = 0;u!=Y.end();u++, b++){\n                    for(int i=0;i<W.size();i++){\n                        P p = W[i], q = W[(i+1)%W.size()];\n                        if(p.second != q.second)continue;\n                        if(p.second != (*b))continue;\n                        int mx = max(p.first, q.first);\n                        int mn = min(p.first, q.first);\n                        if(mn <= (*l) && (*r) <= mx){\n                            on = (on+1)%2;\n                            break;\n                        }\n                    }\n                    if(on){\n                        if(ymin <= (*b) && (*u) <= ymax){\n                            sum += d * ((*u) - (*b));\n                        }\n                    }\n                }\n            }\n        }\n        cout<<calcArea(W) - sum<<endl;\n        \n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid compress(vector<int>& xs) {\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n}\n\nbool solve() {\n\tint N;\n\tcin >> N;\n\tif (N == 0) return false;\n\n\tvector<int> x(N), y(N), xa(4), ya(4), xs(N + 4), ys(N + 4);\n\tfor(int i = 0; i < N; ++i) {\n\t\tcin >> x[i] >> y[i];\n\t\txs[i] = x[i];\n\t\tys[i] = y[i];\n\t}\n\tfor(int i = 0; i < 4; ++i) {\n\t\tcin >> xa[i] >> ya[i];\n\t\txs[i + N] = xa[i];\n\t\tys[i + N] = ya[i];\n\t}\n\n\tcompress(xs);\n\tcompress(ys);\n\n\tauto isin = [&](int i, int j, vector<int>& xv, vector<int>& yv) {\n\t\tint K = xv.size();\n\n\t\tint cnt = 0;\n\t\tfor(int k = 0; k < K; ++k) {\n\t\t\tint tx0 = xv[k],           ty0 = yv[k];\n\t\t\tint tx1 = xv[(k + 1) % K], ty1 = yv[(k + 1) % K];\n\n\t\t\tif (tx0 < xs[i + 1] || tx1 < xs[i + 1]) continue;\n\n\t\t\tif (ty0 > ty1) swap(ty0, ty1);\n\t\t\tif (ty0 <= ys[j] && ys[j + 1] <= ty1) ++cnt;\n\t\t}\n\t\treturn cnt % 2;\n\t};\n\n\tint ans = 0;\n\n\tfor(int i = 0; i + 1 < xs.size(); ++i) {\n\t\tfor(int j = 0; j + 1 < ys.size(); ++j) {\n\t\t\t// cerr << (isin(i, j, x, y) && !isin(i, j, xa, ya)) << \" \";\n\t\t\tif (isin(i, j, x, y) && !isin(i, j, xa, ya)) {\n\t\t\t\tans += (xs[i + 1] - xs[i]) * (ys[j + 1] - ys[j]);\n\t\t\t}\n\t\t}\n\t\t// cerr << endl;\n\t}\n\n\tcout << ans << endl;\n\treturn true;\n}\n\n\nint main() {\n\twhile(solve());\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, a, n) for(int i=(a);i < (n);i++)\n#define REP(i, n) rep(i,0,n)\n#define all(e) e.begin(),e.end()\n\n\n#ifdef LOCAL\n#define show(x) cerr<<__LINE__\" : \"<<#x<<\" = \"<<(x)<<endl\n#else\n#define show(x) true\n#endif\n\nusing namespace std;\nusing ll = long long;\ntemplate<class T>\nusing V=vector<T>;\n\ntemplate<class T, class U>\nvoid chmin(T &t, const U u) { if (t > u) t = u; }\n\ntemplate<class T, class U>\nvoid chmax(T &t, const U u) { if (t < u) t = u; }\n\nconst int INF = (1 << 30) - 1;\nconst ll INFL = (ll) 5e15;\nconst int MOD = 1e9 + 7;\n\n\nstruct Solve {\n    int N;\n    vector<ll> x, y;\n    vector<ll> a, b;\n    ll kl = INFL, kr = -INFL;\n    ll kd = INFL, ku = -INFL;\n\n    int calc(int x1, int y1, int x2, int y2) {\n//        cerr << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << endl;\n        if (x1 == x2) return 0;\n        if (x1 > x2) return -calc(x2, y2, x1, y1);\n        if (x1 < kl && kl < x2) {\n            ll left = calc(x1, y1, kl, y1);\n            ll right = calc(kl, y2, x2, y2);\n            return left + right;\n        }\n\n        if (x1 < kr && kr < x2) {\n            ll left = calc(x1, y1, kr, y1);\n            ll right = calc(kr, y2, x2, y2);\n            return left + right;\n        }\n\n        if (kl <= x1 && x2 <= kr) {\n            //教会内\n            if (y1 >= ku) {\n                //上側にいる\n                return (y1 - (ku - kd)) * (x2 - x1);\n            } else if (y1 <= kd) {\n                //下側にいる\n                return y1 * (x2 - x1);\n            } else {\n                //内側にいる\n                return kd * (x2 - x1);\n\n            }\n        }\n\n        if (x2 <= kl || kr <= x1) {\n            //今日海外\n            return y1 * (x2 - x1);\n        }\n\n        assert(false);\n    }\n\n    bool solve() {\n        cin >> N;\n        if (N == 0) return false;\n\n        x.resize(N);\n        y.resize(N);\n        a.resize(4);\n        b.resize(4);\n        for (int i = 0; i < N; ++i) {\n            cin >> x[i] >> y[i];\n        }\n        for (int i = 0; i < 4; ++i) {\n            cin >> a[i] >> b[i];\n        }\n        x.push_back(x[0]);\n        y.push_back(y[0]);\n\n        for (int i = 0; i < 4; ++i) {\n            chmin(kl, a[i]);\n            chmax(kr, a[i]);\n            chmin(kd, b[i]);\n            chmax(ku, b[i]);\n        }\n//        if (kl > kr) swap(kl, kr);\n//        cerr << kl << \" \" << kr << \" \" << kd << \" \" << ku << endl;\n\n        ll ans = 0ll;\n        for (int i = 0; i < N; ++i) {\n            ll tmp = calc(x[i], y[i], x[i + 1], y[i + 1]);\n//            cerr << tmp << endl;\n            ans += tmp;\n        }\n\n        cout << -ans << endl;\n        return true;\n    }\n};\n\nint main() {\n\n    while (Solve().solve());\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n#define UNIQUE(x) sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end()); \n\n/* SegmentTree(Sum) */\n//0-index\n\nstruct SegTree{\n  typedef int Type;\n  int segn2;\n  Type inf;\n  vector<Type> data,s_data;\n  \n  SegTree(int n){\n    segn2=1;\n    while(segn2<n) segn2*=2;\n    \n    data.assign(segn2*2,0);\n    s_data.assign(segn2*2,0);\n  }\n  \n  //get sum of [a,b]\n  Type query(int a,int b,int l=0,int r=-1,int k=0){\n    Type ret = 0;\n    \n    if(r==-1) r+=segn2;\n    \n    if(r<a || b<l) return 0;\n    \n    if(a<=l && r<=b) return data[k] + s_data[k]*(r-l+1);\n    \n    ret += (min(r,b)-max(l,a)+1) * s_data[k];\n    \n    ret += query(a,b,l,(l+r)/2,k*2+1)+query(a,b,(l+r)/2+1,r,k*2+2);\n    return ret;\n  }\n  \n  //add x to [a,b]\n  Type add(int a,int b,Type x,int l=0,int r=-1,int k=0){\n    if(r==-1) r+=segn2;\n    \n    if(a<=l && r<=b){\n      s_data[k]+=x;\n    }else if(a<=r && l<=b){\n      data[k] = add(a,b,x,l,(l+r)/2,k*2+1) + add(a,b,x,(l+r)/2+1,r,k*2+2);\n    }\n    \n    return data[k] + s_data[k]*(r-l+1);\n  }\n};\n\n\n\nvoid calc(int n){\n  int base = 20000;\n  int x[SIZE],y[SIZE], a[4],b[4];\n  vector<int> vec_x, vec_y;\n  map<int,int> dic_x, dic_y;\n  \n  vector<pair<int,pair<int,int> > > vec;\n  \n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\",x+i,y+i);\n    x[i] += base;\n    y[i] += base;\n\n    if(i > 0 && y[i-1] == y[i]){\n      vec.push_back({y[i],{min(x[i-1],x[i]),max(x[i-1],x[i])}});\n    }\n  }\n\n  if(y[0] == y[n-1]){\n    vec.push_back({y[0],{min(x[0],x[n-1]),max(x[0],x[n-1])}});\n  }\n\n  int min_x = INF, min_y = INF, max_x = -INF, max_y = -INF;\n  \n  for(int i=0;i<4;i++){\n    scanf(\"%d%d\",a+i,b+i);\n    a[i]+=base; b[i]+=base;\n    min_x = min(min_x, a[i]);\n    min_y = min(min_y, b[i]);\n    max_x = max(max_x, a[i]);\n    max_y = max(max_y, b[i]);\n  }\n\n  sort(vec.begin(),vec.end());\n  \n  SegTree seg(base*2+10);\n\n  int t = 0;\n  ll ans = 0;\n  \n  for(int i=0;i<=base*2;i++){\n    \n    while(t < n && vec[t].first == i){\n      if(seg.query(vec[t].second.first, vec[t].second.second-1) > 0){\n        seg.add(vec[t].second.first, vec[t].second.second-1,-1);\n      }else{\n        seg.add(vec[t].second.first, vec[t].second.second-1,1);\n      }\n      t++;\n    }\n\n    if(min_y <= i && i < max_y){\n      ans += seg.query(0,min_x-1) + seg.query(max_x,INF);\n    }else{\n      ans += seg.query(0,INF);\n    }\n    \n  }\n\n\n  printf(\"%lld\\n\",ans);\n  \n}\n\n\nint main(){\n  int n;\n\n  while(1){\n    scanf(\"%d\",&n);\n    if(n == 0) break;\n    calc(n);\n  }\n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAX_N = 1<<16;\n\nclass RSQ2{\npublic:\n  ll n,dat[2*MAX_N-1],td[2*MAX_N-1];\n  RSQ2(){n=MAX_N,memset(dat,0,sizeof(dat)),memset(td,0,sizeof(td));};\n  \n  ll add(int a,int b,ll x,int k=0,int l=0,int r=-1){\n    if(r==-1) r=n;\n    if(r<=a||b<=l)return 0;\n    if(a<=l&&r<=b){\n      dat[k]+=(r-l)*x; \n      td[k]+=x;\n      return dat[k];\n    }\n\n    dat[k]+=(min(r,b)-max(l,a))*x;\n    ll kl=k*2+1,kr=k*2+2,t=td[k]*(r-l)/2;\n    dat[kl]+=t, dat[kr]+=t;\n    td[kl]+=td[k], td[kr]+=td[k];\n    td[k]=0;\n    \n    ll vl=add(a,b,x,k*2+1,l,(l+r)/2);\n    ll vr=add(a,b,x,k*2+2,(l+r)/2,r);\n    return vl+vr;\n  }\n  \n  ll sum(int a,int b){return a>=b? 0:add(a,b,0);}\n};\n\n\nstruct data{int l,r;};\nstruct P{int x,y;};\nconst int B=30000;\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<vector<data> > LR(MAX_N);\n    vector<P> A(n);\n    for(int i=0;i<n;i++)cin>>A[i].x>>A[i].y,A[i].x+=B,A[i].y+=B;\n    for(int i=1;i<=n;i++)\n      if(A[i%n].y==A[i-1].y)\n\tLR[A[i%n].y].push_back((data){A[i-1].x,A[i%n].x});\n    \n    map <int,data> C;\n    for(int i=0;i<4;i++)cin>>A[i].x>>A[i].y,A[i].x+=B,A[i].y+=B;\n    for(int i=1;i<=4;i++)\n      if(A[i%4].y==A[i-1].y)C[A[i%4].y]=(data){A[i-1].x,A[i%4].x};\n    \n    RSQ2 T;\n    ll ans=0;\n    for(int i=0,cl=0,cr=0;i<MAX_N;i++){\n      if(C.count(i)&&!cl&&!cr) cl=C[i].l,cr=C[i].r;\n      else if(C.count(i)) cl=cr=0;\n\n      for(int j=0;j<LR[i].size();j++){\n\tint l = LR[i][j].l,r=LR[i][j].r;\n\tl<r ? T.add(l,r,1): T.add(r,l,-1);\n      }\n      ans+=T.sum(0,cl)+T.sum(cr,T.n);\n    }\n    cout <<ans<<endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n\ntemplate <class T>\nstd::map<T, int> compress(std::vector<T>& v) {\n    std::sort(v.begin(), v.end());\n    v.erase(std::unique(v.begin(), v.end()), v.end());\n\n    std::map<T, int> rev;\n    for (int i = 0; i < (int)v.size(); ++i) rev[v[i]] = i;\n    return rev;\n}\n\nusing lint = long long;\nconstexpr lint INF = 30000;\n\nbool solve() {\n    int n;\n    std::cin >> n;\n    if (n == 0) return false;\n\n    std::vector<lint> xs{-INF, INF}, ys{-INF, INF};\n    std::vector<std::pair<lint, lint>> ps(n + 4);\n    for (auto& p : ps) {\n        std::cin >> p.first >> p.second;\n        xs.push_back(p.first);\n        ys.push_back(p.second);\n    }\n\n    auto revx = compress(xs);\n    auto revy = compress(ys);\n\n    for (auto& p : ps) {\n        p.first = revx[p.first];\n        p.second = revy[p.second];\n    }\n\n    auto crossing = [&](int x, int y, int i, int j) {\n        if (ps[i].second <= y) return false;\n\n        int xi = ps[i].first,\n            xj = ps[j].first;\n\n        for (int q = 0; q < 2; ++q) {\n            if (xi <= x && x + 1 <= xj) return true;\n            std::swap(xi, xj);\n        }\n        return false;\n    };\n\n    lint ans = 0;\n    int h = xs.size(), w = ys.size();\n    for (int x = 0; x + 1 < h; ++x) {\n        for (int y = 0; y + 1 < w; ++y) {\n            int cnt = 0;\n            for (int i = 0; i < n; ++i) {\n                int j = (i + 1) % n;\n                if (crossing(x, y, i, j)) ++cnt;\n            }\n\n            if (cnt % 2 == 0) continue;\n\n            cnt = 0;\n            for (int i = 0; i < 4; ++i) {\n                int j = (i + 1) % 4;\n                if (crossing(x, y, n + i, n + j)) ++cnt;\n            }\n\n            if (cnt % 2 != 0) continue;\n\n            ans += (xs[x + 1] - xs[x]) * (ys[y + 1] - ys[y]);\n        }\n    }\n\n    std::cout << ans << std::endl;\n    return true;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    while (solve()) {};\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main()\n{\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<int> xs, ys;\n\t\tvector<int> x(N), y(N);\n\t\tvector<int> a(4), b(4);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t\txs.push_back(x[i]);\n\t\t\txs.push_back(x[i] - 1);\n\t\t\txs.push_back(x[i] + 1);\n\t\t\tys.push_back(y[i]);\n\t\t\tys.push_back(y[i] - 1);\n\t\t\tys.push_back(y[i] + 1);\n\t\t}\n\t\tint xma = -20000, xmi = 20000, yma = -20000, ymi = 20000;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcin >> a[i] >> b[i];\n\t\t\txs.push_back(a[i]);\n\t\t\txs.push_back(a[i] - 1);\n\t\t\txs.push_back(a[i] + 1);\n\t\t\tys.push_back(b[i]);\n\t\t\tys.push_back(b[i] - 1);\n\t\t\tys.push_back(b[i] + 1);\n\t\t\txma = max(xma, a[i]);\n\t\t\txmi = min(xmi, a[i]);\n\t\t\tyma = max(yma, b[i]);\n\t\t\tymi = min(ymi, b[i]);\n\t\t}\n\t\tsort(xs.begin(), xs.end());\n\t\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\t\tsort(ys.begin(), ys.end());\n\t\tys.erase(unique(ys.begin(), ys.end()), ys.end());\n\n\t\tint nx = xs.size(), ny = ys.size();\n\t\tvector<vector<int>> sta(nx, vector<int>(ny));\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint y1 = y[(i + 1) % N], y2 = y[i];\n\t\t\tif (y1 != y2) {\n\t\t\t\tif (y1 > y2) swap(y1, y2);\n\t\t\t\tint sy = lower_bound(ys.begin(), ys.end(), y1) - ys.begin();\n\t\t\t\tint ey = lower_bound(ys.begin(), ys.end(), y2) - ys.begin();\n\t\t\t\tint X = lower_bound(xs.begin(), xs.end(), x[i]) - xs.begin();\n\t\t\t\tfor (int j = sy; j < ey; j++) {\n\t\t\t\t\tsta[X][j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res = 0;\n\t\tfor (int i = 0; i < ny; i++) {\n\t\t\tfor (int j = 1; j < nx; j++) {\n\t\t\t\tsta[j][i] = (sta[j][i] + sta[j - 1][i]) & 1;\n\t\t\t\tif (i + 1 < ny && j + 1 < nx && sta[j][i]) {\n\t\t\t\t\tres += (ll)(xs[j + 1] - xs[j]) * (ys[i + 1] - ys[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cxs = lower_bound(xs.begin(), xs.end(), xmi) - xs.begin();\n\t\tint cxt = lower_bound(xs.begin(), xs.end(), xma) - xs.begin();\n\t\tint cys = lower_bound(ys.begin(), ys.end(), ymi) - ys.begin();\n\t\tint cyt = lower_bound(ys.begin(), ys.end(), yma) - ys.begin();\n\t\tfor (int i = cxs; i < cxt; i++) {\n\t\t\tfor (int j = cys; j < cyt; j++) {\n\t\t\t\tif (sta[i][j]) {\n\t\t\t\t\tres -= (ll)(xs[i + 1] - xs[i]) * (ys[j + 1] - ys[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\nint sign(int val) {\n  return val > 0 ? 1 : (val == 0 ? 0 : -1);\n}\n\nvoid bfs(vector<vector<bitset<4>>> &tb, pair<int,int> s) {\n  int w = tb[0].size();\n  int h = tb.size();\n  queue<pair<int,int>> que;\n  que.push(s);\n  tb[s.first][s.second].set();\n  while(!que.empty()) {\n    int i,j;\n    tie(i,j) = que.front();\n    que.pop();\n    int di[] = {1,0,-1,0};\n    int dj[] = {0,1,0,-1};\n    REP(k,4) {\n      int ni=i+di[k];\n      int nj=j+dj[k];\n      if (ni<0||nj<0||ni>=h||nj>=w) continue;\n      if(tb[ni][nj].none()) {\n        tb[ni][nj].set();\n        que.emplace(ni,nj);\n      }\n    }\n  }\n}\n\nint main() {\n  while(1){\n    int n;\n    cin>>n;\n    if (!n) break;\n    vector<pair<int,int>> poly;\n    vector<int> vx, vy;\n    vx.push_back(-21000);\n    vy.push_back(-21000);\n    vx.push_back(-20100);\n    vy.push_back(-20100);\n    vx.push_back(21000);\n    vy.push_back(21000);\n    vx.push_back(20100);\n    vy.push_back(20100);\n    REP(i,n) {\n      int x,y;\n      cin>>x>>y;\n      poly.emplace_back(x,y);\n      vx.push_back(x);\n      vy.push_back(y);\n    }\n    vector<pair<int,int>> rect;\n    REP(i,4) {\n      int x,y;\n      cin>>x>>y;\n      rect.emplace_back(x,y);\n      vx.push_back(x);\n      vy.push_back(y);\n    }\n    sort(ALL(vx));\n    sort(ALL(vy));\n    vx.erase(unique(ALL(vx)), end(vx));\n    vy.erase(unique(ALL(vy)), end(vy));\n    int h = vy.size();\n    int w = vx.size();\n    vector<vector<bitset<4>>> tb(h, vector<bitset<4>>(w, 0));\n    REP(i,n) {\n      int j = (i+1)%n;\n      int ix, iy, jx, jy;\n      tie(ix, iy) = poly[i];\n      tie(jx, jy) = poly[j];\n      int idix = lower_bound(ALL(vx), ix) - begin(vx);\n      int idiy = lower_bound(ALL(vy), iy) - begin(vy);\n      int idjx = lower_bound(ALL(vx), jx) - begin(vx);\n      int idjy = lower_bound(ALL(vy), jy) - begin(vy);\n      if (jx-ix != 0) {\n        if (jx > ix) {\n          FOR(k,idix,idjx) {\n            tb[idjy-1][k].set(0);\n          }\n        } else {\n          FOR(k,idjx,idix) {\n            tb[idjy][k].set(2);\n          }\n        }\n      } else {\n        if (jy > iy) {\n          FOR(k,idiy,idjy) {\n            tb[k][idjx].set(1);\n          }\n        } else {\n          FOR(k,idjy,idiy) {\n            tb[k][idjx-1].set(3);\n          }\n        }\n      }\n    }\n    REP(i,h)REP(j,w) {\n      int di[] = {1,0,-1,0};\n      int dj[] = {0,-1,0,1};\n      bitset<4> flag = tb[i][j];\n      if (flag.count() == 1) {\n        REP(dir,4) {\n          if (flag.test(dir)) {\n            bfs(tb, make_pair(i+di[dir],j+dj[dir]));\n          }\n        }\n      }\n    }\n    vector<vector<int>> tb2(h, vector<int>(w, 0));\n    REP(i,4) {\n      int j = (i+1)%4;\n      int ix, iy, jx, jy;\n      tie(ix, iy) = rect[i];\n      tie(jx, jy) = rect[j];\n      int cross2 = ix-jx;\n      int idx = lower_bound(ALL(vx), jx) - begin(vx);\n      int idy = lower_bound(ALL(vy), jy) - begin(vy);\n      tb2[idy][idx] += (cross2 ? 1 : -1);\n    }\n    REP(i,h) REP(j,w-1) tb2[i][j+1] += tb2[i][j];\n    REP(i,h-1) REP(j,w) tb2[i+1][j] += tb2[i][j];\n    int64_t area = 0;\n    REP(i,h)REP(j,w) {\n      if (tb[i][j].all() && tb2[i][j] == 0)\n        area += int64_t(vx[j+1] - vx[j]) * (vy[i+1] - vy[i]);\n    }\n    cout << area << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\nconst int inf = 1e9;\nint dx[4] ={1, 0, -1, 0};\nint dy[4] ={0, 1, 0, -1};\n\nvoid color(int x, int y, int c, vector<vector<int> > &map){\n    if(map[x][y]==c) return;\n    map[x][y] = c;\n    for(int i=0; i<4; i++){\n        color(x+dx[i], y+dy[i], c, map);\n    }\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        vector<int> x(n), y(n);\n        vector<int> ax(n+2), ay(n+2);\n        for(int i=0; i<n; i++){\n            cin >> x[i] >> y[i];\n            ax[i] = x[i];\n            ay[i] = y[i];\n        }\n        int xmax=-inf, xmin=inf;\n        int ymax=-inf, ymin=inf;\n        for(int i=0; i<4; i++){\n            int x,y;\n            cin >> x >> y;\n            xmax = max(xmax, x);\n            xmin = min(xmin, x);\n            ymax = max(ymax, y);\n            ymin = min(ymin, y);\n        }\n        ax[n] = xmax;\n        ax[n+1] = xmin;\n        ay[n] = ymax;\n        ay[n+1] = ymin;\n\n        sort(ax.begin(), ax.end());\n        sort(ay.begin(), ay.end());\n        ax.erase(unique(ax.begin(), ax.end()), ax.end());\n        ay.erase(unique(ay.begin(), ay.end()), ay.end());\n        int sx = ax.size();\n        int sy = ay.size();\n        map<int, int> xtoi, ytoi;\n        for(int i=0; i<sx; i++) xtoi[ax[i]] = i*2;\n        for(int i=0; i<sy; i++) ytoi[ay[i]] = i*2;\n\n        vector<vector<int> > map(sx*2-1, vector<int>(sy*2-1, 0));\n        for(int i=0; i<n; i++){\n            if(x[i]==x[(i+1)%n]){\n                int s = ytoi[y[i]];\n                int e = ytoi[y[(i+1)%n]];\n                if(s>e) swap(s,e);\n                for(int j=s; j<e; j++){\n                    map[xtoi[x[i]]][j] = 1;\n                }\n            }else{\n                int s = xtoi[x[i]];\n                int e = xtoi[x[(i+1)%n]];\n                if(s>e) swap(s,e);\n                for(int j=s; j<e; j++){\n                    map[j][ytoi[y[i]]] = 1;\n                }\n            }\n        }\n        if(x[0]==x[1]){\n            int fx = (y[1]>y[0])? xtoi[x[0]]-1: xtoi[x[0]]+1;\n            int fy = (ytoi[y[0]]+ytoi[y[1]])/2;\n            color(fx, fy, 1, map);\n        }else{\n            int fx = (xtoi[x[0]]+xtoi[x[1]])/2;\n            int fy = (x[1]>x[0])? ytoi[y[0]]+1: ytoi[y[0]]-1;\n            color(fx, fy, 1, map);\n        }\n\n        for(int i=xtoi[xmin]; i<xtoi[xmax]; i++){\n            for(int j=ytoi[ymin]; j<ytoi[ymax]; j++){\n                map[i][j] = 0;\n            }\n        }\n\n        int ans=0;\n        for(int i=0; i<sx-1; i++){\n            for(int j=0; j<sy-1; j++){\n                if(map[i*2+1][j*2+1]==1){\n                    ans += (ax[i+1]-ax[i])*(ay[j+1]-ay[j]);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n#include <complex>\n\nusing namespace std;\n   \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n   \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n  \nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\nconst double PI = acos(-1);\n\ntypedef complex<double> P;\ndouble cross(const P& p, const P& q){return imag(conj(p)*q);}\n\nint main(){\n    int n;\n    while(cin>>n&&n){\n        vector<P> p;\n        double x, y;\n        rep(i, n){\n            cin>>x>>y;\n            p.pb({x, y});\n        }\n        P q[4];\n        rep(i, 4){\n            cin>>x>>y;\n            q[i] = {x, y};\n        }\n        double s = 0.0;\n        rep(i, n) s += cross(p[i], p[(i+1)%n])/2;\n        double mx,Mx,my,My;\n        mx = my = 1e18;\n        Mx = My = 0;\n        rep(i, 4){\n            mx = min(mx, real(q[i]));\n            my = min(my, imag(q[i]));\n            Mx = max(Mx, real(q[i]));\n            My = max(My, imag(q[i]));\n        }\n        rep(i, n){\n            x = real(p[i]);\n            y = imag(p[i]);\n            if(mx>x) x = mx;\n            else if(Mx<x) x = Mx;\n            if(my>y) y = my;\n            else if(My < y) y = My;\n            p[i] = {x, y};\n        }\n        rep(i, n) s -= cross(p[i], p[(i+1)%n])/2;        \n        printf(\"%.15lf\\n\",s);        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int int64_t\nusing P = pair<int, int>;\n\nvoid solve(int n) {\n  vector<P> ps;\n  vector<P> rec;\n  vector<int> largex, largey;\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    cin >> x >> y;\n    ps.push_back(P(x, y));\n    largex.push_back(x);\n    largey.push_back(y);\n  }\n  for (int i = 0; i < 4; i++) {\n    int x, y;\n    cin >> x >> y;\n    rec.push_back(P(x, y));\n    largex.push_back(x);\n    largey.push_back(y);\n  }\n  sort(largex.begin(), largex.end());\n  sort(largey.begin(), largey.end());\n  largex.erase(unique(largex.begin(), largex.end()), largex.end());\n  largey.erase(unique(largey.begin(), largey.end()), largey.end());\n  unordered_map<int, int> presX;\n  unordered_map<int, int> expaX;\n  unordered_map<int, int> presY;\n  unordered_map<int, int> expaY;\n  for (int i = 0; i < largex.size(); i++) {\n    presX[largex[i]] = i;\n    expaX[i] = largex[i];\n  }\n  for (int i = 0; i < largey.size(); i++) {\n    presY[largey[i]] = i;\n    expaY[i] = largey[i];\n  }\n\n  vector<P> presPs;\n  vector<P> presRec;\n  for (P p: ps) {\n    presPs.push_back(P(presX[p.first], presY[p.second]));\n  }\n  for (P p: rec) {\n    presRec.push_back(P(presX[p.first], presY[p.second]));\n  }\n\n  assert(largex.size() < 100 && largey.size() < 100);\n  int bd[100][100] = {};\n  int board[100][100] = {};\n  P start = presPs.front();\n  P prev = presPs.front();\n  for (int i = 1; i < n; i++) {\n    if (presPs[i].second != prev.second) {\n      int x = prev.first;\n      int ycrt = presPs[i].second;\n      int yprv = prev.second;\n      for (int y = min(ycrt, yprv); y < max(ycrt, yprv); y++) {\n        bd[x][y] = 1;\n      }\n    }\n    prev = presPs[i];\n  }\n\n  if (prev.second != start.second) {\n    int x = prev.first;\n    for (int y = min(prev.second, start.second); y < max(prev.second, start.second); y++) {\n      bd[x][y] = 1;\n    }\n  }\n\n\n\n  int ans = 0;\n  for (int j = 0; j < 100; j++) {\n    int prev = -1;\n    for (int i = 0; i < 100; i++) {\n      if (bd[i][j]) {\n        if (prev != -1) {\n          assert(j < 99);\n          // long x = expaX[i] - expaX[prev];\n          // long y = expaY[j + 1] - expaY[j];\n          // assert(x > 0 && y > 0);\n          // ans += x * y;\n          for (int k = prev; k < i; k++) {\n            board[k][j] = 1;\n          }\n          prev = -1;\n        } else {\n          prev = i;\n        }\n      }\n    }\n  }\n\n  int minx = 100, maxx = 0, miny = 100, maxy = 0;\n  for (P p: presRec) {\n    minx = min(minx, p.first);\n    maxx = max(maxx, p.first);\n    miny = min(miny, p.second);\n    maxy = max(maxy, p.second);\n  }\n\n  for (int i = minx; i < maxx; i++) {\n    for (int j = miny; j < maxy; j++) {\n      board[i][j] = 0;\n    }\n  }\n\n  for (int i = 0; i < 100; i++) {\n    for (int j = 0; j < 100; j++) {\n      if (board[i][j]) {\n        assert(i < 99 && j < 99);\n        long x = expaX[i + 1] - expaX[i];\n        long y = expaY[j + 1] - expaY[j];\n        ans += x * y;\n      }\n    }\n  }\n  cout << ans << endl;\n}\n\nsigned main() {\n  int n;\n  while (1) {\n    cin >> n;\n    if (n == 0) return 0;\n    solve(n);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAX_N = 1<<16;\n\nclass RSQ2{\npublic:\n  ll n,dat[2*MAX_N-1],td[2*MAX_N-1];\n  //?????????\n  RSQ2(){n=MAX_N,memset(dat,0,sizeof(dat)),memset(td,0,sizeof(td));};\n  \n  //[a,b)????????????x???????????????,query(a,b,x);\n  ll add(int a,int b,ll x,int k=0,int l=0,int r=-1){\n    if(r==-1) r=n;\n    if(r<=a||b<=l)return 0;\n    if(a<=l&&r<=b){\n      dat[k]+=(r-l)*x; \n      td[k]+=x;\n      return dat[k];\n    }\n\n    dat[k]+=(min(r,b)-max(l,a))*x;\n    ll kl=k*2+1,kr=k*2+2,t=td[k]*(r-l)/2;\n    dat[kl]+=t, dat[kr]+=t;\n    td[kl]+=td[k], td[kr]+=td[k];\n    td[k]=0;\n\n    ll vl=add(a,b,x,k*2+1,l,(l+r)/2);\n    ll vr=add(a,b,x,k*2+2,(l+r)/2,r);\n    return vl+vr;\n  }\n  \n  //[a,b)??????????????????\n  ll sum(int a,int b){return a>=b? 0:add(a,b,0);}\n};\n\n\nstruct data{int l,r;};\nstruct P{int x,y;};\nconst int Base=20010;\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<vector<data> > LR(MAX_N);\n    vector<P> A(n);\n    for(int i=0;i<n;i++)cin>>A[i].x>>A[i].y,A[i].x+=Base,A[i].y+=Base;\n    for(int i=0;i<n;i++)\n      if(A[i].y==A[(i+1)%n].y)\n\tLR[A[i].y].push_back((data){A[i].x,A[(i+1)%n].x});\n    \n    vector<data> C(MAX_N,(data){1e5,1e5});  \n    A.resize(4);\n    for(int i=0;i<4;i++)cin>>A[i].x>>A[i].y,A[i].x+=Base,A[i].y+=Base;\n    for(int i=0;i<4;i++)\n      if(A[i].y==A[(i+1)%n].y)C[A[i].y]=(data){A[i].x,A[(i+1)%n].x};\n    \n    RSQ2 T;\n    int ans=0;\n    for(int i=0,flg=1,cl=0,cr=0;i<MAX_N;i++){\n      if(flg&&C[i].l!=1e5) cl=C[i].l,cr=C[i].r,flg=0;\n      else if(flg==0&&C[i].l!=1e5) cl=cr=0;\n\n      for(int j=0;j<LR[i].size();j++){\n\tint l = LR[i][j].l,r=LR[i][j].r;\n\tl<r ? T.add(l,r,1): T.add(r,l,-1);\n      }\n      ans+=T.sum(0,cl)+T.sum(cr,T.n);\n    }\n    cout <<ans<<endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing P = pair<int, int>;\n\nint main() {\n  int N;\n  while (cin >> N, N) {\n    auto xs = vector<int>(N + 4);\n    auto ys = vector<int>(N + 4);\n    auto window = vector<P>(N);\n    for (int i = 0; i < N; ++i) {\n      int x, y; cin >> x >> y;\n      window[i] = {x, y};\n      xs[i] = x;\n      ys[i] = y;\n    }\n\n    auto curtain = vector<P>(4);\n    for (int i = 0; i < 4; ++i) {\n      int a, b; cin >> a >> b;\n      curtain[i] = {a, b};\n      xs[N + i] = a;\n      ys[N + i] = b;\n    }\n\n    sort(begin(xs), end(xs)); xs.erase(unique(begin(xs), end(xs)), end(xs));\n    sort(begin(ys), end(ys)); ys.erase(unique(begin(ys), end(ys)), end(ys));\n\n    auto cover = [](vector<P> &v, double X, double Y) {\n      int res = 0;\n      for (int cur = 0; cur < v.size(); ++cur) {\n        int nxt = (cur + 1) % v.size();\n        int sx, sy, tx, ty;\n        tie(sx, sy) = v[cur];\n        tie(tx, ty) = v[nxt];\n        if (sx == tx && X < sx) {\n          int ly = min(sy, ty);\n          int uy = max(sy, ty);\n          if (ly < Y && Y < uy) ++res;\n        }\n      }\n      return res % 2 == 1;\n    };\n\n    int ans = 0;\n    for (int i = 0; i < xs.size() - 1; ++i) {\n      for (int j = 0; j < ys.size() - 1; ++j) {\n        int S = (xs[i + 1] - xs[i]) * (ys[j + 1] - ys[j]);\n        double px = (xs[i] + xs[i + 1]) / 2.0;\n        double py = (ys[j] + ys[j + 1]) / 2.0;\n        if (cover(window, px, py) && !cover(curtain, px, py)) ans += S;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\n//#define double long double\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define next(P,i) P[(i+1)%P.size()]\n#define prev(P,i) P[(i+P.size()-1)%P.size()]\n\nstruct Point {\n\tdouble x, y;\n\tPoint() {}\n\tPoint(double x, double y) :x(x), y(y) {}\n\n\tPoint &operator+=(const Point &p) { x += p.x; y += p.y; return *this; }\n\tPoint &operator-=(const Point &p) { x -= p.x; y -= p.y; return *this; }\n\tPoint &operator*=(double a) { x *= a; y *= a; return *this; }\n\tPoint &operator/=(double a) { x /= a; y /= a; return *this; }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y; }\n};\nPoint operator+(const Point &p1, const Point &p2) { return Point(p1) += p2; }\nPoint operator-(const Point &p1, const Point &p2) { return Point(p1) -= p2; }\nPoint operator*(const Point &p, double a) { return Point(p) *= a; }\nPoint operator/(const Point &p, double a) { return Point(p) /= a; }\nbool operator==(const Point &p1, const Point &p2) { return equals(p1.x, p2.x) && equals(p1.y, p2.y); }\nbool operator<(const Point &p1, const Point &p2) {\n\t//return p1.y != p2.y ? p1.y < p2.y : p1.x < p2.x; //y?????? -> x??????\n\treturn p1.x != p2.x ? p1.x < p2.x : p1.y < p2.y; //x?????? -> y??????\n}\nbool operator>(const Point &p1, const Point &p2) { return p2 < p1; }\ninline istream &operator >> (istream &is, Point &p) { double x, y; is >> x >> y; p = Point(x, y); return is; }\ninline ostream &operator << (ostream &os, const Point &p) { os << p.x << ' ' << p.y; return os; }\n\nstruct Vector :public Point {\n\tusing Point::Point;\n\tVector() {}\n\tVector(const Point &P) { x = P.x; y = P.y; }\n\tVector rotate(double rad) { return Vector(x*cos(rad) - y*sin(rad), x*sin(rad) + y*cos(rad)); }\n\tVector unit() { return *this / abs(); }\n};\n\n//?????? dot product\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\n//?????? cross product ?????§???????????£????????????\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\nstruct Line {\n\tPoint p1, p2;\n\tLine() {}\n\tLine(Point p1, Point p2) :p1(p1), p2(p2) {}\n};\n\nstruct Segment :public Line {\n\tusing Line::Line;\n\tSegment() {}\n\tSegment(const Line &L) { p1 = L.p1; p2 = L.p2; }\n\tVector vec() { return p2 - p1; }\n};\n\nstruct Circle {\n\tPoint c; //center\n\tdouble r; //radius\n\tCircle() {}\n\tCircle(Point c, double r) :c(c), r(r) {}\n};\nusing Polygon = vector<Point>;\n\n//degree to radian\ndouble rad(double deg) { return PI*deg / 180; }\n//radian to degree\ndouble deg(double rad) { return rad / PI * 180; }\n\n//????§? argument\ndouble arg(Vector p) { return atan2(p.y, p.x); }\n\n//?\\???¢??? polar form\nVector polar(double r, double a) { return Point(cos(a)*r, sin(a)*r); }\n\n//2??????????????????????§????\ndouble angle(Vector a, Vector b) {\n\tdouble lena = a.abs(), lenb = b.abs();\n\tif (lena == 0 || lenb == 0)return 0; //?§£??????\n\tdouble costheta = dot(a, b) / (lena*lenb);\n\tif (equals(costheta, 1))costheta = 1; //????????????\n\treturn acos(costheta);\n}\n\nbool inrange(Point p, double x1, double y1, double x2, double y2) {\n\treturn x1 <= p.x&&p.x <= x2&&y1 <= p.y&&p.y <= y2;\n}\n\n//??´?????????\nbool is_orthogonal(Vector a, Vector b) { return equals(dot(a, b), 0.0); }\nbool is_orthogonal(Segment s1, Segment s2) { return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//????????????\nbool is_parallel(Vector a, Vector b) { return equals(cross(a, b), 0.0); }\nbool is_parallel(Segment s1, Segment s2) { return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0); }\n\n//?°???±\nPoint project(Segment s, Point p) {\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\n//????°?\nPoint reflect(Segment s, Point p) { return p + (project(s, p) - p)*2.0; }\n\n//??????(p0,p1)????????????p2???????????¢???\nenum { ONLINE_FRONT = -2, CLOCKWISE, ON_SEGMENT, COUNTER_CLOCKWISE, ONLINE_BACK };\nint ccw(Point p0, Point p1, Point p2) {\n\tVector a = p1 - p0, b = p2 - p0;\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\nint ccw(Vector a, Vector b) {\n\tif (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -EPS)return CLOCKWISE;\n\tif (dot(a, b) < -EPS)return ONLINE_BACK; //p2 p0 p1\n\tif (a.norm() < b.norm())return ONLINE_FRONT; //p0 p1 p2\n\treturn ON_SEGMENT;\n}\n\n//??´?????¨??´??????????????????\nbool intersect(Segment a, Segment b) {\n\tPoint p1 = a.p1, p2 = a.p2, p3 = b.p1, p4 = b.p2;\n\treturn (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t\tccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\n//(?????????????¶????)\n\n//2??????????????¢\ndouble get_distance(Point a, Point b) { return (a - b).abs(); }\n\n//??´?????¨???????????¢\ndouble get_distance(Line l, Point p) { return abs(cross(l.p2 - l.p1, p - l.p1) / (l.p2 - l.p1).abs()); }\n\n//????????¨???????????¢\ndouble get_distance(Segment s, Point p) {\n\tif (dot(s.p2 - s.p1, p - s.p1) < 0.0)return (p - s.p1).abs();\n\tif (dot(s.p1 - s.p2, p - s.p2) < 0.0)return (p - s.p2).abs();\n\treturn get_distance(Line(s), p);\n}\n\n//????????¨??????????????¢\ndouble get_distance(Segment s1, Segment s2) {\n\tif (intersect(s1, s2))return 0.0;\n\treturn\tmin(\n\t\tmin(get_distance(s1, s2.p1), get_distance(s1, s2.p2)),\n\t\tmin(get_distance(s2, s1.p1), get_distance(s2, s1.p2))\n\t);\n}\n\n//?????¨??´??????????????????\nbool intersect(Circle c, Line l) { return get_distance(l, c.c) <= c.r + EPS; }\n\n//?????¨?????????????????? ??±?????\\????????°\nint intersect(Circle c1, Circle c2) {\n\tdouble d = get_distance(c1.c, c2.c);\n\tif (d > c1.r + c2.r)return 4;\n\tif (d == c1.r + c2.r)return 3;\n\tif (d + c1.r == c2.r || d + c2.r == c1.r)return 1;\n\tif (d + c1.r < c2.r || d + c2.r < c1.r)return 0;\n\treturn 2;\n}\n\n//????????¨???????????????\nPoint get_cross_point(Segment a, Segment b) {\n\tassert(intersect(a, b));\n\tVector base = b.p2 - b.p1;\n\tdouble area1 = abs(cross(base, a.p1 - b.p1));\n\tdouble area2 = abs(cross(base, a.p2 - b.p1));\n\tdouble t = area1 / (area1 + area2);\n\treturn a.p1 + (a.p2 - a.p1)*t;\n}\n\n//?????¨??´????????????\npair<Point, Point> get_cross_points(Circle c, Line l) {\n\tassert(intersect(c, l));\n\tVector pr = project(l, c.c);\n\tVector e = (l.p2 - l.p1) / (l.p2 - l.p1).abs();\n\tdouble base = sqrt(c.r*c.r - (pr - c.c).norm());\n\treturn make_pair(pr + e*base, pr - e*base);\n}\n\n//?????¨????????????\npair<Point, Point> get_cross_points(Circle c1, Circle c2) {\n\tint m = intersect(c1, c2);\n\tassert(m != 4 && m != 0);\n\tdouble d = (c1.c - c2.c).abs();\n\tdouble a = acos((c1.r*c1.r - c2.r*c2.r + d*d) / (2 * c1.r*d));\n\tdouble t = arg(c2.c - c1.c);\n\treturn make_pair(c1.c + polar(c1.r, t + a), c1.c + polar(c1.r, t - a));\n}\n\n//????????????\nenum { OUT = 0, ON, IN };\nint contains(const Polygon &pl, Point p) {\n\tint n = pl.size();\n\tbool x = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tPoint a = pl[i] - p, b = pl[(i + 1) % n] - p;\n\t\tif (abs(cross(a, b)) < EPS&&dot(a, b) < EPS)return ON;\n\t\tif (a.y > b.y)swap(a, b);\n\t\tif (a.y < EPS&&EPS<b.y&&cross(a, b)>EPS)x = !x;\n\t}\n\treturn (x ? IN : OUT);\n}\n\nint contains(Circle c, Point p) {\n\tdouble d = get_distance(c.c, p);\n\tif (equals(d, c.r))return ON;\n\tif (d < c.r)return IN;\n\treturn OUT;\n}\n\n//????§???¢?????¢???\ndouble area(const Polygon &p) {\n\tdouble a = 0;\n\tfor (size_t i = 0; i < p.size(); i++)\n\t\ta += cross(p[i], p[(i + 1) % p.size()]);\n\treturn fabs(a / 2.0);\n}\n\n//?????§????????????????¨??????????\nbool is_convex(Polygon g) {\n\tfor (size_t i = 0; i < g.size(); i++)\n\t\tif (ccw(g[i], g[(i + 1) % g.size()], g[(i + 2) % g.size()]) == CLOCKWISE)\n\t\t\treturn false;\n\treturn true;\n}\n\n//??????\n//Graham scan https://en.wikipedia.org/wiki/Graham_scan\n//???????????????????????????\nPolygon convex_hull(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\twhile (up.size() > 1 && ccw(up[up.size() - 2], up[up.size() - 1], p) != CLOCKWISE)up.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\twhile (down.size() > 1 && ccw(down[down.size() - 2], down[down.size() - 1], p) != COUNTER_CLOCKWISE)down.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); //???????¨??????????\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n//??????\n//Graham scan https://en.wikipedia.org/wiki/Graham_scan\n//?????????????????????\nPolygon convex_hull_with_points_online(Polygon P) {\n\tsort(P.begin(), P.end());\n\tPolygon up;\n\tfor (Point &p : P) {\n\t\tint _ccw;\n\t\twhile (up.size() > 1 && (_ccw = ccw(up[up.size() - 2], up[up.size() - 1], p)) != CLOCKWISE &&_ccw != ONLINE_FRONT)\n\t\t\tup.pop_back();\n\t\tup.emplace_back(p);\n\t}\n\tPolygon down;\n\tfor (Point &p : P) {\n\t\tint _ccw;\n\t\twhile (down.size() > 1 && (_ccw = ccw(down[down.size() - 2], down[down.size() - 1], p)) != COUNTER_CLOCKWISE && _ccw != ONLINE_FRONT)\n\t\t\tdown.pop_back();\n\t\tdown.emplace_back(p);\n\t}\n\treverse(up.begin(), up.end()); //???????¨??????????\n\tdown.insert(down.end(), up.begin() + 1, up.end() - 1);\n\treturn down;\n}\n\n//???????§???¢??????????????????????????¢\n//calipers https://en.wikipedia.org/wiki/Rotating_calipers\ndouble diameter(Polygon P) {\n\tP = convex_hull(P);\n\tauto mima = minmax_element(P.begin(), P.end());\n\tint I = mima.first - P.begin();\n\tint J = mima.second - P.begin();\n\tdouble maxd = get_distance(P[I], P[J]);\n\n\tint maxi, maxj, i, j;\n\ti = maxi = I;\n\tj = maxj = J;\n\tdo {\n\t\tif (ccw(next(P, i) - P[i], next(P, j) - P[j]) == COUNTER_CLOCKWISE)\n\t\t\tj = (j + 1) % P.size();\n\t\telse\n\t\t\ti = (i + 1) % P.size();\n\t\tif (maxd < get_distance(P[i], P[j])) {\n\t\t\tmaxd = get_distance(P[i], P[j]);\n\t\t\tmaxi = i, maxj = j;\n\t\t}\n\t} while (!(i == I&&j == J));\n\treturn maxd;\n}\n\n//????§???¢???(0,0)???????????¨???????????¢\nPolygon rotate(const Polygon &P, double rad) {\n\tPolygon ret;\n\tfor (auto &p : P)\n\t\tret.emplace_back(p.x*cos(rad) - p.y*sin(rad), p.x*sin(rad) + p.y*cos(rad));\n\treturn ret;\n}\n\n//Heron's formula\ndouble area(double a, double b, double c) {\n\tdouble s = (a + b + c) / 2;\n\treturn sqrt(s*(s - a)*(s - b)*(s - c));\n}\n\n//????§???¢?????????\nPoint center(const Polygon &P) {\n\tPoint ret(0, 0);\n\tfor (auto &p : P)ret = ret + p;\n\tret = ret / P.size();\n\treturn ret;\n}\n\n//?????´????????????\nLine get_bisection(const Point &p1, const Point &p2) {\n\tCircle c1(p1, INF), c2(p2, INF); //INF ?????¨???????????????\n\tauto ps = get_cross_points(c1, c2);\n\treturn Line(ps.first, ps.second);\n}\n\n//3??????????????¢??????????????? (3???????????¨????????????????????????)\nPoint get_center(const Point &p1, const Point &p2, const Point &p3) {\n\tLine l1 = get_bisection(p1, p2), l2 = get_bisection(p2, p3);\n\treturn get_cross_point(l1, l2);\n}\n\n//???p????????????c?????\\?????????????????\\???\npair<Point, Point> get_tangent(const Circle &c, const Point &p) {\n\tdouble d = get_distance(c.c, p);\n\tCircle c2((c.c + p) / 2, d / 2);\n\treturn get_cross_points(c, c2);\n}\n\ntemplate<typename T>\nvector<T> compress(vector<T> v) {\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\treturn v;\n}\n\ntemplate<typename T>\nint index(const vector<T> &v, T i) { return lower_bound(v.begin(), v.end(), i) - v.begin(); }\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int N; cin >> N&&N;) {\n\t\tvector<int> X, Y;\n\t\tPolygon w(N);\n\t\trep(i, 0, N) {\n\t\t\tcin >> w[i];\n\t\t\tX.emplace_back(w[i].x);\n\t\t\tY.emplace_back(w[i].y);\n\t\t}\n\t\tPolygon c(4);\n\t\trep(i, 0, 4) {\n\t\t\tcin >> c[i];\n\t\t\tX.emplace_back(c[i].x);\n\t\t\tY.emplace_back(c[i].y);\n\t\t}\n\t\tX.emplace_back(INF);\n\t\tY.emplace_back(INF);\n\t\tX = compress(X);\n\t\tY = compress(Y);\n\t\tdump(X);\n\t\tdump(Y);\n\t\tint ans = 0;\n\t\trep(i, 0, X.size() - 1)rep(j, 0, Y.size() - 1) {\n\t\t\tPoint p(X[i] + 0.5, Y[j] + 0.5);\n\t\t\tif (contains(w, p) && !contains(c, p)) {\n\t\t\t\tans += (X[i + 1] - X[i])*(Y[j + 1] - Y[j]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,s,e) for (int i=s;i<(e);i++)\n#define All(v) (v).begin(),(v).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\nconst int MOD = (int)1e9 + 7;\nconst int INF = 1010101010;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N;\n    cin >> N;\n    \n    while(N != 0){\n        vector<P> w;\n        REP(i, N){\n            int x, y;\n            cin >> x >> y;\n            w.pb(mp(y, x));\n        }\n        w.pb(w[0]);\n        int xu = -20000, xd = 20000, yu = -20000, yd = 20000;\n        REP(i, 4){\n            int x, y;\n            cin >> x >> y;\n            chmax(yu, y);\n            chmin(yd, y);\n            chmax(xu, x);\n            chmin(xd, x);\n        }\n\n        LL ans = 0;\n        REP(i, N){\n            int x1 = w[i].se;\n            int x2 = w[i+1].se;\n            int y = w[i].fi;\n            ans += (x1 - x2) * y;\n            x1 = max(xd, min(xu, x1));\n            x2 = max(xd, min(xu, x2));\n            y = max(yd, min(yu, y));\n            ans -= (x1 - x2) * y;\n\n        }\n        cout << ans << endl;\n\n        cin >> N;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n\n#define EPS (1e-10)\n\nclass P{\npublic:\n\tdouble x,y;\n\t\n\tP(double _x=0, double _y=0):x(_x),y(_y){};\n\tP operator + (const P &p)const{ return P( x+p.x , y+p.y ); }\n\tP operator - (const P &p)const{ return P( x-p.x, y-p.y); }\n\tP operator * (const double k)const{ return P( x*k , y*k);}\n\tP operator / (const double k)const{ return P( x/k, y/k);}\n\t\n\tbool operator == (const P &p){return ( fabs(x-p.x)<EPS && fabs(y-p.y)<EPS); }\n\tbool operator < (const P &p) const{ return ( x!=p.x ? x<p.x:y<p.y); }\n\t\n\tdouble norm(){ return x*x+y*y; }\n\tdouble abs() { return sqrt(norm()); }\n};\n\nstruct S{P p1,p2;};\ntypedef P Vector;\n\ndouble dot (Vector a, Vector b) { return a.x*b.x+a.y*b.y; }\ndouble cross(Vector a, Vector b) { return a.x*b.y-a.y*b.x; }\n\nint ccw(P p0, P p1, P p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\t\n\tif( cross(a,b) > EPS) return 1;\n\tif( cross(a,b) < -EPS) return -1;\n\tif( dot(a,b) < -EPS) return 2;\n\tif( a.norm() < b.norm() ) return -2;\n\t\n\treturn 0;\n}\n\nbool intersect(P p1,P p2,P p3,P p4){\t//??????????????????\n\treturn (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nP getCrossPoint(S s1,S s2){\t\t\t\t//???????????????\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1/(d1+d2);\n\treturn s1.p1 + (s1.p2 - s1.p1) * t;\n}\n\n\nint main(){\n\tint n;\n\twhile(cin>>n&&n){\n\t\tvector<P> p(n);\n\t\trep(i,n){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tp[i] = P(x+30000,y+30000);\t//??§?¨??????£???\n\t\t}\n\t\t\n\t\tint min_x=INF,max_x=-INF,min_y=INF,max_y=-INF;\t//???????????????XY??§?¨???? ??????????????§\n\t\trep(i,4){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tx+=30000;\t//??§?¨??????£???\n\t\t\ty+=30000;\t//??§?¨??????£???\n\t\t\tmin_x = min(x,min_x);\n\t\t\tmax_x = max(x,max_x);\n\t\t\tmin_y = min(y,min_y);\n\t\t\tmax_y = max(y,max_y);\n\t\t}\n\t\t\n\t\tvector<S> edge;\t//????§???¢?????????\n\t\trep(i,n){\n\t\t\tedge.pb(S{p[i],p[(i+1)%n]});\n\t\t}\n\t\t\n\t\t\n\t\tll ans=0;\n\t\tfor(double y = 0.5;y<50100.5;y++){\t//XY?????¢???y??????????????¨??¢?´¢\n\t\t\tS line = S{P(-1,y),P(50100,y)};\t//Y??§?¨????y??¨????????´???(?????????????????§??¨???)\n\t\t\tvector<pii> crs;\t//????¨????line??¨?????????????????????X??§?¨?????????? (second==0:??????????????¨?????? , second==1:????§???¢??¨??????)\n\t\t\t\n\t\t\trep(i,n){\t//line??¨???????????????????????¢?´¢??????crs???????????????\n\t\t\t\tif( intersect(line.p1,line.p2,edge[i].p1,edge[i].p2) ){\n\t\t\t\t\tP res = getCrossPoint(line, edge[i]);\n\t\t\t\t\tcrs.pb(pii(res.x+EPS,1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(min_y<y && y<max_y){\t//line???Y??§?¨??????????????????? ??????~???????????? ???????????¨???\n\t\t\t\tcrs.pb(pii(min_x,0));\n\t\t\t\tcrs.pb(pii(max_x,0));\n\t\t\t}\n\t\t\tsort(all(crs));\n\t\t\t\n\t\t\t\n\t\t\t//status  ???->0 , ??????????????????->1 , ?????????->2 , ????????????->3\n\t\t\tint  status = 0;\n\t\t\tint bef_point=-INF;\n\t\t\trep(i,crs.size()){\n\t\t\t\tint x_point = crs[i].first;\t//?????????????????????X??§?¨?\n\t\t\t\tint st = crs[i].second;\t\t//??????????????????????????????????????¨?????????????????¨?????????????????¨???\n\t\t\t\t\n\t\t\t\tif(st==0){\t//????????????\n\t\t\t\t\tif(status==0)\t\tstatus = 1;\n\t\t\t\t\telse if(status==1)\tstatus = 0;\n\t\t\t\t\telse if(status==2){\n\t\t\t\t\t\tans+=x_point-bef_point;\n\t\t\t\t\t\tstatus = 3;\n\t\t\t\t\t}\n\t\t\t\t\telse if(status==3)\tstatus = 2;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\telse{\t//???\n\t\t\t\t\tif(status==0)\t\tstatus = 2;\n\t\t\t\t\telse if(status==1)\tstatus = 3;\n\t\t\t\t\telse if(status==2){\n\t\t\t\t\t\tans+=x_point-bef_point;\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if(status==3)\tstatus = 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbef_point = x_point;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define RFOR(i, a, b) for (int i = (b)-1; i >= int(a); --i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, int(n) + 1)\n#define rrep(i, n) RFOR(i, 0, n)\n#define rrep1(i, n) RFOR(i, 1, int(n) + 1)\n#define all(c) begin(c), end(c)\n\ntemplate <typename T>\nvoid __dump__(std::ostream &os, const T &first) {\n    os << first;\n}\ntemplate <typename First, typename... Rest>\nvoid __dump__(std::ostream &os, const First &first, const Rest &... rest) {\n    os << first << \", \";\n    __dump__(os, rest...);\n}\n#define dump(...)                                         \\\n    do {                                                  \\\n        std::ostringstream os;                            \\\n        os << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; \\\n        __dump__(os, __VA_ARGS__);                        \\\n        std::cerr << os.str() << std::endl;               \\\n    } while (0)\n\nconst int INF = 1000000;\nconst int OFS = 20000;\n\nint N;\nint X[110], Y[110];\nvector<vector<int>> ys(OFS * 2 + 1);\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    while (cin >> N && N) {\n        ys.assign(OFS*2 + 1, {});\n        int px = INF, py = INF;\n        rep(i, N) cin >> X[i] >> Y[i], X[i] += OFS;\n        X[N] = X[0], Y[N] = Y[0];\n        rep(i, N + 1) {\n            int x = X[i], y = Y[i];\n            if (px != INF) {\n                if (y == py) {\n                    int xl = min(x, px), xr = max(x, px);\n                    for (int ix = xl; ix < xr; ++ix) {\n                        ys[ix].push_back(y);\n                    }\n                }\n            }\n            px = x;\n            py = y;\n        }\n        int yu = -INF, yd = +INF, xl = +INF, xr = -INF;\n        rep(i, 4) {\n            int x, y;\n            cin >> x >> y;\n            x += OFS;\n            yu = max(y, yu);\n            yd = min(y, yd);\n            xr = max(x, xr);\n            xl = min(x, xl);\n        }\n        ll ans = 0;\n        for (int x = 0; x <= OFS*2; ++x) {\n            auto yy = ys[x];\n            sort(all(yy));\n            assert(ys[x].size() % 2 == 0);\n            rep(i, yy.size()) {\n                int y1 = yy[i], y2 = yy[i+1];\n                ans += y2 - y1;\n                if (xl <= x && x < xr) {\n                    int oy1 = max(y1, yd);\n                    int oy2 = min(y2, yu);\n                    ans -= oy2 - oy1;\n                }\n                ++i;\n            }\n        }\n        cout << ans << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\nusing namespace std;\n\nint N;\nvector<int> a(4),b(4);\nvector<int> a2(4),b2(4);\nint l,r,u,d;\n\ninline bool inCaten(double x,double y){\n    if(l<= x and x <= r and d <= y and y <= u) return true;\n    else return false;\n}\n\nvoid solve(){\n    vector<int> x(N),y(N);\n    for(int i=0;i<N;i++) cin >> x[i] >> y[i];\n    for(int i=0;i<4;i++) cin >> a[i] >> b[i];\n\n    set<int> xset,yset;\n    for(int i=0;i<N;i++){\n        xset.insert(x[i]); yset.insert(y[i]);\n    }\n    for(int i=0;i<4;i++){\n        xset.insert(a[i]); yset.insert(b[i]);\n    }\n\n    map<int,int> X,rX,Y,rY;\n    int cnt = 0;\n    for(auto xx : xset){\n        X[xx] = cnt;\n        rX[cnt] = xx;\n        cnt++;\n    }\n    cnt = 0;\n    for(auto yy : yset){\n        Y[yy] = cnt;\n        rY[cnt] = yy;\n        cnt++;\n    }\n\n    // 座標変換\n    vector<int> x2(N),y2(N);\n    for(int i=0;i<N;i++){\n        x2[i] = X[x[i]];\n        y2[i] = Y[y[i]];\n    }\n    for(int i=0;i<4;i++){\n        a2[i] = X[a[i]];\n        b2[i] = Y[b[i]];\n    }\n\n    // カーテンの座標 \n    l = 200000; r = 0;\n    for(int i=0;i<4;i++) l = min(l,a2[i]);\n    for(int i=0;i<4;i++) r = max(r,a2[i]);\n    d = 20000;u = 0;\n    for(int i=0;i<4;i++) d = min(d,b2[i]);\n    for(int i=0;i<4;i++) u = max(u,b2[i]);\n\n    \n    int H = xset.size();\n    int W = yset.size();\n\n    vector<vector<bool>> table(H+10,vector<bool>(W+10,false));\n\n    for(int i=0;i<N;i++){\n        int nxt = (i+1) % N;\n\n        int myx = x2[i];\n        int myy = y2[i];\n        int nxtx = x2[nxt];\n        int nxty = y2[nxt];\n\n        if(myx == nxtx){\n            for(int yy = min(myy,nxty); yy <= max(myy,nxty); yy++){\n                table[myx][yy] = true;\n            }\n        }else{\n            for(int xx = min(myx,nxtx); xx <= max(myx,nxtx); xx++){\n                table[xx][myy] = true;\n            }\n        }\n    }\n\n    //cerr << \"H \" << H << endl;\n    //cerr << \"W \" << W << endl;\n    //cerr << \"l \" << l << endl;\n    //cerr << \"r \" << r << endl;\n    //cerr << \"d \" << d << endl;\n    //cerr << \"u \" << u << endl;\n\n\n    //for(int i=0;i<H;i++){\n    //    for(int j=0;j<W;j++){\n    //        cerr << table[i][j];\n    //    }\n    //    cerr << endl;\n    //}\n\n    long long ans = 0;\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            double nowx = (i + i + 1) / 2.0;\n            double nowy = (j + j + 1) / 2.0;\n            if(inCaten(nowx,nowy)) continue;\n            int cnt1=0,cnt2=0;\n            if(!rX.count(i+1) or !rY.count(j+1)) continue;\n            for(int k=j;k>=0;k--){\n                if(table[i][k] and table[i+1][k]) cnt1++;\n            }\n            for(int k=j+1;k<W;k++){\n                if(table[i][k] and table[i+1][k]) cnt2++;\n            }\n            if(cnt1%2==1 and cnt2%2==1){\n                int dx = rX[i+1] - rX[i];\n                int dy = rY[j+1] - rY[j];\n                ans += dx * dy;\n            }\n        }\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    while(1){\n        cin >> N;\n        if(N==0) break;\n        solve();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAX_N = 1<<16;\n\nclass RSQ2{\npublic:\n  ll n,dat[2*MAX_N-1],td[2*MAX_N-1];\n  //?????????\n  RSQ2(){n=MAX_N,memset(dat,0,sizeof(dat)),memset(td,0,sizeof(td));};\n  \n  //[a,b)????????????x???????????????,query(a,b,x);\n  ll add(int a,int b,ll x,int k=0,int l=0,int r=-1){\n    if(r==-1) r=n;\n    if(r<=a||b<=l)return 0;\n    if(a<=l&&r<=b){\n      dat[k]+=(r-l)*x; \n      td[k]+=x;\n      return dat[k];\n    }\n\n    dat[k]+=(min(r,b)-max(l,a))*x;\n    ll kl=k*2+1,kr=k*2+2,t=td[k]*(r-l)/2;\n    dat[kl]+=t, dat[kr]+=t;\n    td[kl]+=td[k], td[kr]+=td[k];\n    td[k]=0;\n\n    ll vl=add(a,b,x,k*2+1,l,(l+r)/2);\n    ll vr=add(a,b,x,k*2+2,(l+r)/2,r);\n    return vl+vr;\n  }\n  \n  //[a,b)??????????????????\n  ll sum(int a,int b){return a==b? 0:add(a,b,0);}\n};\n\n\nstruct data{int l,r;};\nconst int Base=20001;\n\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<vector<data> > LR(MAX_N);\n\n    int sx,sy,x,y;\n    cin>>x>>y;x+=Base,y+=Base,sx=x,sy=y;\n    for(int i=1,nx,ny;i<n;i++){\n      cin>>nx>>ny;nx+=Base,ny+=Base;\n      if(ny==y) LR[y].push_back((data){x,nx});\n      x=nx,y=ny;\n    } \n    if(sy==y) LR[y].push_back((data){x,sx});\n\n    vector<data> C(MAX_N,(data){-1,-1});  \n    cin>>x>>y;x+=Base,y+=Base;\n    for(int i=1,nx,ny;i<4;i++){\n      cin>>nx>>ny;nx+=Base,ny+=Base;\n      if(ny==y) C[y]=(data){min(nx,x),max(x,nx)};\n      x=nx,y=ny;\n    }\n    \n    RSQ2 T;\n    int ans=0;\n    for(int i=0,flg=1,cl=0,cr=0;i<MAX_N;i++){\n      if(flg&&C[i].l!=-1) cl=C[i].l,cr=C[i].r,flg=0;\n      else if(flg==0&&C[i].l!=-1) cl=cr=0;\n      \n      for(int j=0;j<LR[i].size();j++){\n\tint l = LR[i][j].l,r=LR[i][j].r;\n\tl<r ? T.add(l,r,1): T.add(r,l,-1);\n      }\n      ans+=T.sum(0,cl)+T.sum(cr,T.n);\n\n    }\n    cout <<ans<<endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 100000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nvector<int> xi;\nvector<int> yi;\nint x[101];\nint y[101];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint fie[501][501];\nint fie2[501][501];\nint a[4],b[4];\n\nvoid bfs(int y,int x,int c){\n\tfie[y][x]=c;\n\tqueue<P> que;\n\tque.push(P(y,x));\n\twhile(que.size()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=p.second+dx[i];\n\t\t\tint ny=p.first+dy[i];\n\t\t\tif(nx>=0 && nx<=2*xi.size() && ny>=0 && ny<=2*yi.size()){\n\t\t\t\tif(fie[ny][nx]==-1){\n\t\t\t\t\tfie[ny][nx]=c;\n\t\t\t\t\tque.push(P(ny,nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid bfs2(int y,int x,int c){\n\tfie2[y][x]=c;\n\tqueue<P> que;\n\tque.push(P(y,x));\n\twhile(que.size()){\n\t\tP p=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=p.second+dx[i];\n\t\t\tint ny=p.first+dy[i];\n\t\t\tif(nx>=0 && nx<=2*xi.size() && ny>=0 && ny<=2*yi.size()){\n\t\t\t\tif(fie2[ny][nx]==-1){\n\t\t\t\t\tfie2[ny][nx]=c;\n\t\t\t\t\tque.push(P(ny,nx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\txi.clear();\n\t\tyi.clear();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\t\txi.push_back(x[i]);\n\t\t\txi.push_back(x[i]+1);\n\t\t\txi.push_back(x[i]-1);\n\t\t\tyi.push_back(y[i]);\n\t\t\tyi.push_back(y[i]+1);\n\t\t\tyi.push_back(y[i]-1);\n\t\t}\n\t\tfor(int i=0;i<4;i++){\n\t\t\tscanf(\"%d%d\",&a[i],&b[i]);\n\t\t\txi.push_back(a[i]-1);\n\t\t\txi.push_back(a[i]);\n\t\t\txi.push_back(a[i]+1);\n\t\t\tyi.push_back(b[i]-1);\n\t\t\tyi.push_back(b[i]);\n\t\t\tyi.push_back(b[i]+1);\n\t\t}\n\t\tsort(xi.begin(),xi.end());\n\t\txi.erase(unique(xi.begin(),xi.end()),xi.end());\n\t\tsort(yi.begin(),yi.end());\n\t\tyi.erase(unique(yi.begin(),yi.end()),yi.end());\n\t\tfor(int i=0;i<n;i++){\n\t\t\tx[i]=lower_bound(xi.begin(),xi.end(),x[i])-xi.begin();\n\t\t\ty[i]=lower_bound(yi.begin(),yi.end(),y[i])-yi.begin();\n\t\t}\n\t\tfor(int i=0;i<4;i++){\n\t\t\ta[i]=lower_bound(xi.begin(),xi.end(),a[i])-xi.begin();\n\t\t\tb[i]=lower_bound(yi.begin(),yi.end(),b[i])-yi.begin();\n\t\t}\n\t\tmemset(fie,-1,sizeof(fie));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(x[i]==x[(i+1)%n]){\n\t\t\t\tfor(int j=min(y[i],y[(i+1)%n])*2;j<=max(y[i],y[(i+1)%n])*2;j++){\n\t\t\t\t\tfie[j][x[i]*2]=1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j=min(x[i],x[(i+1)%n])*2;j<=max(x[i],x[(i+1)%n])*2;j++){\n\t\t\t\t\tfie[y[i]*2][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbfs(0,0,0);\n\t\tfor(int i=0;i<=2*yi.size();i++){\n\t\t\tfor(int j=0;j<=2*xi.size();j++){\n\t\t\t\tif(fie[i][j]==-1){\n\t\t\t\t\tbfs(i,j,1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(fie2,-1,sizeof(fie2));\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(a[i]==a[(i+1)%4]){\n\t\t\t\tfor(int j=min(b[i],b[(i+1)%4])*2;j<=max(b[i],b[(i+1)%4])*2;j++){\n\t\t\t\t\tfie2[j][a[i]*2]=1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j=min(a[i],a[(i+1)%4])*2;j<=max(a[i],a[(i+1)%4])*2;j++){\n\t\t\t\t\tfie2[b[i]*2][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbfs2(0,0,0);\n\n\t\tfor(int i=0;i<=2*yi.size();i++){\n\t\t\tfor(int j=0;j<=2*xi.size();j++){\n\t\t\t\tif(fie2[i][j]==-1){\n\t\t\t\t\tbfs2(i,j,1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res=0,res2=0;\n\t\tfor(int i=0;i+1<yi.size();i++){\n\t\t\tfor(int j=0;j+1<xi.size();j++){\n\t\t\t\tif(fie[i*2+1][j*2+1]==1 && fie2[i*2+1][j*2+1]!=1){\n\t\t\t\t\tres+=(yi[i+1]-yi[i])*(xi[j+1]-xi[j]);\n\t\t\t\t}\n\t\t\t\tif(fie[i*2+1][j*2+1]==1){\n\t\t\t\t\tres2+=(yi[i+1]-yi[i])*(xi[j+1]-xi[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define int long long\n\n#define INF ((int)1e17)\n#define MAX 400\n#define x first\n#define y second\n\nsigned main(){\n  \n  while(true){\n    int N;\n    pair<int,int>p[4] = {};\n    vector<int> xc, yc;\n    vector<pair<int,int> > c;\n    \n    int area = 0;\n\tvector<vector<int>> field(MAX, vector<int>(MAX,0)), field2(MAX, vector<int>(MAX,0));\n    //  int field[MAX][MAX] = {}, field2[MAX][MAX] = {};\n\n\t\n    cin>>N;\n    \n    if(N == 0) break;\n    \n    c.resize(N);\n    \n    \n    xc.push_back(INF);\n    yc.push_back(INF);\n    \n    xc.push_back(-INF);\n    yc.push_back(-INF);\n    \n    for(int i = 0;  i < N; i++){\n      cin>>c[i].x>>c[i].y;\n      \n      xc.push_back(c[i].x);\n      yc.push_back(c[i].y);\n    }\n    \n    for(int i = 0; i < 4; i++){\n      cin>>p[i].x>>p[i].y;\n      \n      xc.push_back(p[i].x);\n      yc.push_back(p[i].y);\n    }\n    \n    \n    sort(xc.begin(), xc.end());\n    sort(yc.begin(), yc.end());\n    \n    \n    xc.erase(unique(xc.begin(), xc.end()), xc.end());\n    yc.erase(unique(yc.begin(), yc.end()), yc.end());\n    \n    for(int i = 0; i < N; i++){\n      int tx = lower_bound(xc.begin(), xc.end(), c[i].x) - xc.begin();\n      int ty = lower_bound(yc.begin(), yc.end(), c[i].y) - yc.begin();\n      \n    if(c[(i-1 + N)%N].x == c[(i)%N].x && c[(i+1 + N)%N].x == c[(i)%N].x) continue;\n    if(c[(i-1 + N)%N].y == c[(i)%N].y && c[(i+1 + N)%N].y == c[(i)%N].y) continue;\n    \n    if(c[(i - 1 + N)%N].y > c[(i)%N].y){\n      if(c[(i + 1 + N)%N].x > c[(i)%N].x){\n\tfield[ty][tx]--;\n      } else {\n\tfield[ty][tx]--;\n      }\n    } else if(c[(i - 1 + N)%N].y < c[(i)%N].y){\n      if(c[(i + 1 + N)%N].x > c[(i)%N].x){\n\tfield[ty][tx]--;\n      } else {\n\tfield[ty][tx]--;\n      }\n    } else if(c[(i - 1 + N)%N].x > c[(i)%N].x){\n      if(c[(i + 1 + N)%N].y < c[(i)%N].y){\n\t//\tcout<<\"x \"<<c[(i - 1 + N)%N].x<<\" \"<< c[(i)%N].x<<\" \"<<c[(i + 1 + N)%N].x<<endl;\n\t//\tcout<<\"y \"<<c[(i - 1 + N)%N].y<<\" \"<< c[(i)%N].y<<\" \"<<c[(i + 1 + N)%N].y<<endl;\n\tfield[ty][tx]++;\n      } else {\n\tfield[ty][tx]++;\n      }\n    } else if (c[(i - 1 + N)%N].x < c[(i)%N].x){\n      if(c[(i + 1 + N)%N].y < c[(i)%N].y){\n\tfield[ty][tx]++;\n      } else {\n\tfield[ty][tx]++;\n      }\n    }\n    }\n    \n    \n    N = 4;\n    for(int i = 0; i < N; i++){\n      int tx = lower_bound(xc.begin(), xc.end(), p[i].x) - xc.begin();\n      int ty = lower_bound(yc.begin(), yc.end(), p[i].y) - yc.begin();\n    \n      if(p[(i-1 + N)%N].x == p[(i)%N].x && p[(i+1 + N)%N].x == p[(i)%N].x) continue;\n      if(p[(i-1 + N)%N].y == p[(i)%N].y && p[(i+1 + N)%N].y == p[(i)%N].y) continue;\n      \n      if(p[(i - 1 + N)%N].y > p[(i)%N].y){\n\tif(p[(i + 1 + N)%N].x > p[(i)%N].x){\n\tfield2[ty][tx]--;\n\t} else {\n\t  field2[ty][tx]--;\n\t}\n      } else if(p[(i - 1 + N)%N].y < p[(i)%N].y){\n\tif(p[(i + 1 + N)%N].x > p[(i)%N].x){\n\t  field2[ty][tx]--;\n\t  \n\t} else {\n\t\n\t  //cout<<\"px \"<<p[(i - 1 + N)%N].x<<\" \"<< p[(i)%N].x<<\" \"<<p[(i + 1 + N)%N].x<<endl;\n\t  //cout<<\"py \"<<p[(i - 1 + N)%N].y<<\" \"<< p[(i)%N].y<<\" \"<<p[(i + 1 + N)%N].y<<endl;\n\t  field2[ty][tx]--;\n\t}\n      } else if(p[(i - 1 + N)%N].x > p[(i)%N].x){\n\tif(p[(i + 1 + N)%N].y < p[(i)%N].y){\n\t  field2[ty][tx]++;\n\t} else {\n\t  field2[ty][tx]++;\n      }\n      } else if (p[(i - 1 + N)%N].x < p[(i)%N].x){\n\tif(p[(i + 1 + N)%N].y < p[(i)%N].y){\n\t  field2[ty][tx]++;\n\t} else {\n\t  field2[ty][tx]++;\n\t}\n      }\n    }\n    \n     /*\n      \n      cout<<\"xc.size() \"<<xc.size()<<\" \"<<\"yc.size() \"<<yc.size()<<endl;\n      \n      cout<<endl;\n      for(int i = 0; i < yc.size(); i++){\n      //cout<<\"\\t\"<<yc[yc.size()-i-1];\n      for(int j = 0; j < xc.size(); j++){\n      cout<<\"\\t\"<<field[yc.size()-i-1][j];\n      }cout<<endl;\n  }\n       */\n    for(int i = 0; i < yc.size(); i++){\n      for(int j = 0; j < xc.size(); j++){\n\tfield[i][j+1] += field[i][j];\n      field2[i][j+1] += field2[i][j];\n      }\n    }\n    \n    for(int i = 0; i < xc.size(); i++){\n    for(int j = yc.size()-1; j >= 0; j--){\n      field[j][i] += field[j+1][i];\n      field2[j][i] += field2[j+1][i];\n    }\n  }\n     /*\n      cout<<endl;\n      for(int i = 0; i < yc.size(); i++){\n      for(int j = 0; j < xc.size(); j++){\n      cout<<\"\\t\"<<field[yc.size()-i-1][j];\n      }cout<<endl;\n      }\n      cout<<endl;\n      \n      for(int i = 0; i < yc.size(); i++){\n      for(int j = 0; j < xc.size(); j++){\n      cout<<\"\\t\"<<field2[yc.size()-i-1][j];\n      }cout<<endl;\n  }\n          */\n    for(int i = 2; i < yc.size()-1; i++){\n      for(int j = 1; j < xc.size()-2; j++){\n\tif(field[i][j] && field2[i][j] == 0){\n\t  area += (yc[i] - yc[i-1])*(xc[j+1] - xc[j]);\n\t  //cout<<\" \"<<yc[i]<<\" \"<<yc[i-1]<<\" \"<<xc[j+1]<<\" \"<< xc[j]<<endl;\n\t  //cout<<\" \"<<(yc[i] - yc[i-1])<<\" * \"<<(xc[j+1] - xc[j])<<endl;\n\t}\n      }\n    }\n    \n    cout<<area<<endl;\n    \n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst long double PI = acos(-1);\nconstexpr long double EPS = 1e-15;\nconstexpr int inf = 2e9;\nconstexpr ll INF = 2e18;\nconstexpr ll MOD = 1e9+7;\nconstexpr ll MOD1 = 998244353;\ntypedef pair<ll,ll> P;\n\n//#define all(v) (v).begin(), (v).end()\n#define rep(i,a,b) for (int i = (a); i < (b); i++)\n#define REP(i,n) rep(i,0,n)\n#define sz(s) (s).size()\n#define pb push_back\n#define fi first\n#define se second\n//#define mp make_pair\n#define int long long\n\nint areasub(int x, int y, int a, int b){\n    int ret = 0;\n    if(a < x && b < y){\n        ret += (x - a) * (y - b);\n    }\n    return ret;\n}\nsigned main(){\n    int n;\n    int x[112], y[112];\n    int t, b, l, r;\n    int xmin, ymin;\n    auto succ = [&](int x){if(x == n - 1) return 0ll; else return ++x;};\n\n    auto area = [&](int x, int y){\n        int ret;\n        ret = areasub(x, y, l, b) - areasub(x, y, l, t) - areasub(x, y, r, b) + areasub(x, y, r, t);\n        return x * y - ret;\n    };\n\n    while(cin >> n, n){\n        int ans = 0;\n        t = -100000;\n        b = 100000;\n        l = 100000;\n        r = -100000;\n        xmin = 0, ymin = 0;\n        REP(i, n){\n            cin >> x[i] >> y[i];\n            xmin = min(xmin, x[i]);\n            ymin = min(ymin, y[i]);\n        }\n        REP(i, 4){\n            int tmp_a, tmp_b;\n            cin >> tmp_a >> tmp_b;\n            l = min(l, tmp_a);\n            r = max(r, tmp_a);\n            t = max(t, tmp_b);\n            b = min(b, tmp_b);\n            xmin = min(xmin, tmp_a);\n            ymin = min(ymin, tmp_b);\n        }\n        REP(i, n){\n            x[i] -= xmin;\n            y[i] -= ymin;\n        }\n        l -= xmin;\n        r -= xmin;\n        b -= ymin;\n        t -= ymin;\n        REP(i, n){\n            if(x[i] == x[succ(i)]){\n\n            }else if(y[i] == y[succ(i)]){\n                ans += area(x[succ(i)], y[succ(i)]) - area(x[i], y[i]);\n            }else{\n                while(1);\n            }\n        }\n        cout << abs(ans) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint idx(vi a,int c){\n\treturn lower_bound(all(a),c)-a.begin();\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvi x(n+4),y(n+4);\n\t\trep(i,n+4)cin>>x[i]>>y[i];\n\t\tvi X,Y;\n\t\trep(i,n+4)X.pb(x[i]),X.pb(x[i]+1);\n\t\trep(i,n+4)Y.pb(y[i]),Y.pb(y[i]+1);\n\t\tsort(all(X));X.erase(unique(all(X)),X.end());\n\t\tsort(all(Y));Y.erase(unique(all(Y)),Y.end());\n\t\tint N=X.size(),M=Y.size();\n\t\tvvi dp(N,vi(M));\n\t\tint t=1;\n\t\trep(i,n){\n\t\t\tint a=idx(X,x[i]),b=idx(Y,y[i]);\n\t\t\tdp[a][b]=t;\n\t\t\tt*=-1;\n\t\t}\n\t\trep(i,N-1)rep(j,M)dp[i+1][j]+=dp[i][j];\n\t\trep(i,N)rep(j,M-1)dp[i][j+1]+=dp[i][j];\n\t\tint a=min(min(x[n],x[n+1]),min(x[n+2],x[n+3]));\n\t\tint b=max(max(x[n],x[n+1]),max(x[n+2],x[n+3]));\n\t\tint c=min(min(y[n],y[n+1]),min(y[n+2],y[n+3]));\n\t\tint d=max(max(y[n],y[n+1]),max(y[n+2],y[n+3]));\n\t\ta=idx(X,a);b=idx(X,b);c=idx(Y,c);d=idx(Y,d);\n\t\tloop(i,a,b)loop(j,c,d)dp[i][j]=0;\n\t\t\n\t\tll sum=0;\n\t\trep(i,N)rep(j,M)if(dp[i][j])sum+=(ll)(X[i+1]-X[i])*(Y[j+1]-Y[j]);\n\t\tcout<<sum<<endl;\n\t}\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<pii> pos(n);\n\t\tvector<pii> posc(4);\n\t\tint minx = 99999;\n\t\tint miny = 99999;\n\t\tint maxx = -99999;\n\t\tint maxy = -99999;\n\t\tset<int> posx;\n\t\tset<int> posy;\n\t\tREP(i, n) {\n\t\t\tcin >> pos[i].first >> pos[i].second;\n\t\t\tposx.insert(pos[i].first);\n\t\t\tposy.insert(pos[i].second);\n\t\t}\n\t\tREP(i, 4) {\n\t\t\tcin >> posc[i].first >> posc[i].second;\n\t\t\tposx.insert(posc[i].first);\n\t\t\tposy.insert(posc[i].second);\n\t\t\tminx = min(minx, posc[i].first);\n\t\t\tminy = min(miny, posc[i].second);\n\t\t\tmaxx = max(maxx, posc[i].first);\n\t\t\tmaxy = max(maxy, posc[i].second);\n\t\t}\n\t\tmap<int, int> comx;\n\t\tmap<int, int> comy;\n\t\tmap<int, int> uncomx;\n\t\tmap<int, int> uncomy;\n\t\tfor (auto x : posx) {\n\t\t\tcomx[x] = comx.size();\n\t\t\tuncomx[comx.size()-1] = x;\n\t\t}\n\t\tfor (auto x : posy) {\n\t\t\tcomy[x] = comy.size();\n\t\t\tuncomy[comy.size() - 1] = x;\n\t\t}\n\t\tvvb tate(posy.size()-1,vb(posx.size(),false));\n\t\tvvb yoko(posy.size(), vb(posx.size()-1, false));\n\t\tREP(i, n) {\n\t\t\tint start = comy[pos[i].second];\n\t\t\tint goal = comy[pos[(i + 1) % n].second];\n\t\t\tif (goal < start)\n\t\t\t\tswap(start, goal);\n\t\t\tREP(j, goal-start) {\n\t\t\t\ttate[start + j][comx[pos[i].first]]=true;\n\t\t\t}\n\t\t\tstart = comx[pos[i].first];\n\t\t\tgoal = comx[pos[(i+1)%n].first];\n\t\t\tif (goal < start)\n\t\t\t\tswap(start, goal);\n\t\t\tREP(j, goal - start) {\n\t\t\t\tyoko[comy[pos[i].second]][start + j] = true;\n\t\t\t}\n\t\t}\n\t\tvvb cell(posy.size() - 1, vb(posx.size() - 1, false));\n\t\tREP(i, posy.size()-1) {\n\t\t\tbool into=false;\n\t\t\tREP(j, posx.size()) {\n\t\t\t\tif (tate[i][j] == true)\n\t\t\t\t\tinto = !into;\n\t\t\t\tif (j < posx.size() - 1 && into)\n\t\t\t\t\tcell[i][j] = true;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tREP(j, posx.size() - 1) {\n\t\t\tbool into = false;\n\t\t\tREP(i, posy.size()) {\n\t\t\t\tif (yoko[i][j] == true)\n\t\t\t\t\tinto = !into;\n\t\t\t\tif (i < posy.size() - 1)  \n\t\t\t\t\tif(into&&cell[i][j])\n\t\t\t\t\tcell[i][j] = true;\n\t\t\t\telse\n\t\t\t\t\tcell[i][j] = false;\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tint ans = 0;\n\t\tREP(i, posy.size() - 1) {\n\t\t\tREP(j, posx.size() - 1) {\n\t\t\t\tif (comy[miny] <= i&&i < comy[maxy] && comx[minx] <= j&&j < comx[maxx])\n\t\t\t\t\tcontinue;\n\t\t\t\tif(cell[i][j])\n\t\t\t\tans += (uncomx[j + 1] - uncomx[j])*(uncomy[i + 1] - uncomy[i]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<pii> pos(n);\n\t\tvector<pii> posc(4);\n\t\tint minx = 99999;\n\t\tint miny = 99999;\n\t\tint maxx = -99999;\n\t\tint maxy = -99999;\n\t\tset<int> posx;\n\t\tset<int> posy;\n\t\tREP(i, n) {\n\t\t\tcin >> pos[i].first >> pos[i].second;\n\t\t\tposx.insert(pos[i].first);\n\t\t\tposy.insert(pos[i].second);\n\t\t}\n\t\tREP(i, 4) {\n\t\t\tcin >> posc[i].first >> posc[i].second;\n\t\t\tposx.insert(posc[i].first);\n\t\t\tposy.insert(posc[i].second);\n\t\t\tminx = min(minx, posc[i].first);\n\t\t\tminy = min(miny, posc[i].second);\n\t\t\tmaxx = max(maxx, posc[i].first);\n\t\t\tmaxy = max(maxy, posc[i].second);\n\t\t}\n\t\tmap<int, int> comx;\n\t\tmap<int, int> comy;\n\t\tmap<int, int> uncomx;\n\t\tmap<int, int> uncomy;\n\t\tfor (auto x : posx) {\n\t\t\tif (comx.empty())\n\t\t\t\tcomx[x] = 0;\n\t\t\telse\n\t\t\t\tcomx[x] = comx.size();\n\t\t\tuncomx[comx.size() - 1] = x;\n\t\t}\n\t\tfor (auto x : posy) {\n\t\t\tif (comy.empty())\n\t\t\t\tcomy[x] = 0;\n\t\t\telse\n\t\t\t\tcomy[x] = comy.size();\n\t\t\tuncomy[comy.size() - 1] = x;\n\t\t}\n\t\tvvb tate(posy.size() - 1, vb(posx.size(), false));\n\t\tvvb yoko(posy.size(), vb(posx.size() - 1, false));\n\t\tREP(i, n) {\n\t\t\tint start = comy[pos[i].second];\n\t\t\tint goal = comy[pos[(i + 1) % n].second];\n\t\t\tif (goal < start)\n\t\t\t\tswap(start, goal);\n\t\t\tREP(j, goal - start) {\n\t\t\t\ttate[start + j][comx[pos[i].first]] = true;\n\t\t\t}\n\t\t\t/*\n\t\t\tstart = comx[pos[i].first];\n\t\t\tgoal = comx[pos[(i + 1) % n].first];\n\t\t\tif (goal < start)\n\t\t\t\tswap(start, goal);\n\t\t\tREP(j, goal - start) {\n\t\t\t\tyoko[comy[pos[i].second]][start + j] = true;\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tvvb cell(posy.size() - 1, vb(posx.size() - 1, false));\n\t\tREP(i, posy.size() - 1) {\n\t\t\tbool into = false;\n\t\t\tREP(j, posx.size()) {\n\t\t\t\tif (tate[i][j] == true)\n\t\t\t\t\tinto = !into;\n\t\t\t\tif (j < posx.size() - 1 && into)\n\t\t\t\t\tcell[i][j] = true;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tREP(j, posx.size() - 1) {\n\t\t\tbool into = false;\n\t\t\tREP(i, posy.size()) {\n\t\t\t\tif (yoko[i][j] == true)\n\t\t\t\t\tinto = !into;\n\t\t\t\tif (i < posy.size() - 1)\n\t\t\t\t\tif(into&&cell[i][j])\n\t\t\t\t\tcell[i][j] = true;\n\t\t\t\telse\n\t\t\t\t\tcell[i][j] = false;\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tint ans = 0;\n\t\tREP(i, posy.size() - 1) {\n\t\t\tREP(j, posx.size() - 1) {\n\t\t\t\tif (comy[miny] <= i&&i < comy[maxy] && comx[minx] <= j&&j < comx[maxx])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (cell[i][j])\n\t\t\t\t\tans += (uncomx[j + 1] - uncomx[j])*(uncomy[i + 1] - uncomy[i]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n#define X real()\n#define Y imag()\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ntypedef complex<double> P;\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<P> G;\ntypedef vector<P> polygon;\n\nstruct C {\n\tP p; double r;\n\tC(const P &p, double r) : p(p), r(r) { }\n};\n//??????????????????\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\ndouble getArea(const polygon& pol) {\n\tint n = pol.size();\n\tdouble s = 0.0;\n\tfor(int i = 0; i < n; i++) {\n\t\tint now = i, nxt = (i + 1) % n;\n\t\ts += (pol[now].X - pol[nxt].X) * (pol[now].Y + pol[nxt].Y);\n\t}\n\treturn abs(s/2.0);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n > 0) {\n\t\tvector<P> ps;\n\t\trep(i, n) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tps.pb({x, y});\n\t\t}\n\t\tdouble S = 0.0;\n\t\tS = getArea(ps);\n\t\tG rect;\n\t\tdouble l = INF, r = -INF, u = -INF, d = INF;\n\t\trep(i, 4) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\trect.pb({x, y});\n\t\t\tl = min(l, x);\n\t\t\tr = max(r, x);\n\t\t\tu = max(u, y);\n\t\t\td = min(d, y);\n\t\t}\n\t\tG pp;\n\t\trep(i, n) {\n\t\t\tdouble x, y;\n\t\t\tif(ps[i].X > r) x = r;\n\t\t\telse if(ps[i].X < l) x = l;\n\t\t\telse x = ps[i].X;\n\t\t\tif(ps[i].Y > u) y = u;\n\t\t\telse if(ps[i].Y < d) y = d;\n\t\t\telse y = ps[i].Y;\n\t\t\tpp.pb({x, y});\n\t\t}\n\t\tdouble s = 0.0;\n\t\ts = getArea(pp);\n\t\tprintf(\"%d\\n\", (int)(abs(S) - abs(s) + EPS));\n\t\t//cout << S <<\" \" << s << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nlong long N;\nlong long W, H;\nvector<long long> x, y;\nvector<long long> xl, yl;\nlong long l, r, u, b;\nbool window[300][300];\n\nlong long comp(vector<long long> &X, vector<long long> &XL)\n{\n\tvector<long long> xs;\n\tfor(long long i = 0; i < X.size(); i++){\n\t\txs.push_back(X[i]);\n\t\txs.push_back(X[i] - 1);\n\t}\n\txs.push_back(20005), xs.push_back(-20005);\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\tsort(xs.begin(), xs.end());\n\t\n\tfor(long long i = 0; i < X.size(); i++){\n\t\tX[i] = lower_bound(xs.begin(), xs.end(), X[i]) - xs.begin();\n\t}\n\tfor(long long i = 0; i < xs.size()-1; i++){\n\t\tXL.push_back(xs[i+1] - xs[i]);\n\t}\n\treturn xs.size();\n}\n\nvoid dfs(long long i, long long j)\n{\n\tif(i < 0 || i >= W || j < 0 || j >= H) return;\n\tif(window[i][j]) return;\n\t\n\twindow[i][j] = true;\n\tdfs(i+1, j);\n\tdfs(i-1, j);\n\tdfs(i, j+1);\n\tdfs(i, j-1);\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\t\n\t\tx.clear(), y.clear();\n\t\tlong long xx, yy;\n\t\tfor(long long i = 0; i < N; i++){\n\t\t\tcin >> xx >> yy;\n\t\t\tx.push_back(xx), y.push_back(yy);\n\t\t}\n\t\tlong long A[4], B[4];\n\t\tfor(long long i = 0; i < 4; i++) cin >> A[i] >> B[i];\n\t\tl = min(A[0], A[2]), r = max(A[0], A[2]);\n\t\tu = min(B[0], B[2]), b = max(B[0], B[2]);\n\t\tx.push_back(l), x.push_back(r);\n\t\ty.push_back(u), y.push_back(b);\n\t\t\n\t\txl.clear(), yl.clear();\n\t\tW = comp(x, xl);\n\t\tH = comp(y, yl);\n\t\tl = x[N], r = x[N+1];\n\t\tu = y[N], b = y[N+1];\n\t\t\n\t\tfor(long long i = 0; i < W; i++){\n\t\t\tfor(long long j = 0; j < H; j++){\n\t\t\t\twindow[i][j] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong long px, py, nx, ny, dx, dy;\n\t\tlong long difx[105], dify[105];\n\t\t\n\t\tfor(long long i = 0; i < N; i++) difx[i] = dify[i] = 0;\n\t\tfor(long long i = 0; i < N; i++){\n\t\t\tpx = x[i], py = y[i];\n\t\t\tnx = x[(i+1)%N], ny = y[(i+1)%N];\n\t\t\tif(nx == px) dx = 0; \n\t\t\telse dx = (nx - px) / abs(nx - px);\n\t\t\tif(ny == py) dy = 0;\n\t\t\telse dy = (ny - py) / abs(ny - py);\n\t\t\t\n\t\t\tif(dx < 0) dify[i]--, dify[(i+1)%N]--;\n\t\t\telse if(dy > 0) difx[i]--, difx[(i+1)%N]--;\n\t\t}\n\t\tfor(long long i = 0; i < N; i++) x[i] += difx[i], y[i] += dify[i];\n\t\t\n\t\tfor(long long i = 0; i < N; i++){\n\t\t\tpx = x[i], py = y[i];\n\t\t\tnx = x[(i+1)%N], ny = y[(i+1)%N];\n\t\t\tif(nx == px) dx = 0; \n\t\t\telse dx = (nx - px) / abs(nx - px);\n\t\t\tif(ny == py) dy = 0;\n\t\t\telse dy = (ny - py) / abs(ny - py);\n\t\t\t\n\t\t\tfor(; px != nx || py != ny; px += dx, py += dy) window[px][py] = true;\n\t\t}\n\t\t\n\t\tfor(long long i = 0; i < W; i++){\n\t\t\tfor(long long j = 0; j < H; j++){\n\t\t\t\tif(window[i][j] && !window[i][j+1]){\n\t\t\t\t\tfor(long long k = j+1; k < H; k++){\n\t\t\t\t\t\tif(window[i][k]){\n\t\t\t\t\t\t\tdfs(i, j+1);\n\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tend:;\n\t\t\n\t\tfor(long long i = l; i < r; i++){\n\t\t\tfor(long long j = u; j < b; j++){\n\t\t\t\twindow[i][j] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong long ans = 0;\n\t\tfor(long long i = 0; i < W; i++){\n\t\t\tfor(long long j = 0; j < H; j++){\n\t\t\t\tif(window[i][j]) ans += xl[i] * yl[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct point{double x,y;};\ndouble X[110],Y[110];\ndouble eps = 1e-9;\nint N;\nint main(){\n    while(true){\n        cin >> N;\n        if(N==0) return 0;\n        vector<point> window,curtain;\n        double x,y;\n        window.clear();\n        curtain.clear();\n        for(int i=1;i<=N;i++){\n            cin >> x >> y;\n            window.push_back({x,y});\n            X[i] = x; Y[i] = y; \n        }\n        for(int i=1;i<=4;i++){\n            cin >> x >> y;\n            X[N+i] = x;\n            Y[N+i] = y;\n            curtain.push_back({x,y});\n        }\n        sort(X+1,X+N+5);\n        sort(Y+1,Y+N+5);\n        double ans = 0;\n        for(int i=1;i<=N+3;i++){\n            for(int j=1;j<=N+3;j++){\n                double cx = (X[i]+X[i+1])/2,cy = (Y[j]+Y[j+1])/2;\n                int cnt = 0;\n                for(int k=0;k<N;k++){\n                    if(cx>window[k].x) continue;\n                    double uy = max(window[k].y,window[(k+1)%N].y);\n                    double dy = min(window[k].y,window[(k+1)%N].y);\n                    if(dy<cy && cy<uy) cnt++;\n                }\n                if(cnt%2==0) continue;\n                cnt = 0;\n                for(int k=0;k<4;k++){\n                    if(cx>curtain[k].x) continue;\n                    double uy = max(curtain[k].y,curtain[(k+1)%4].y);\n                    double dy = min(curtain[k].y,curtain[(k+1)%4].y);\n                    if(dy<cy && cy<uy) cnt++;\n                }\n                if(cnt%2==1) continue;\n                ans += (X[i+1]-X[i])*(Y[j+1]-Y[j]);\n            }\n        }\n        cout << (int) ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint N;\nint W, H;\nvector<int> x, y;\nvector<int> xl, yl;\nint l, r, u, b;\nbool window[300][300];\n\nint comp(vector<int> &X, vector<int> &XL)\n{\n\tvector<int> xs;\n\tfor(int i = 0; i < X.size(); i++){\n\t\txs.push_back(X[i]);\n\t\txs.push_back(X[i] - 1);\n\t}\n\txs.push_back(20005), xs.push_back(-20005);\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\tsort(xs.begin(), xs.end());\n\t\n\tfor(int i = 0; i < X.size(); i++){\n\t\tX[i] = lower_bound(xs.begin(), xs.end(), X[i]) - xs.begin();\n\t}\n\tfor(int i = 0; i < xs.size()-1; i++){\n\t\tXL.push_back(xs[i+1] - xs[i]);\n\t}\n\treturn xs.size();\n}\n\nvoid dfs(int i, int j, bool a[300][300])\n{\n\tif(i < 0 || i >= W || j < 0 || j >= H) return;\n\tif(a[i][j]) return;\n\t\n\ta[i][j] = true;\n\tdfs(i+1, j, a);\n\tdfs(i-1, j, a);\n\tdfs(i, j+1, a);\n\tdfs(i, j-1, a);\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\t\n\t\tx.clear(), y.clear();\n\t\tint xx, yy;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tcin >> xx >> yy;\n\t\t\tx.push_back(xx), y.push_back(yy);\n\t\t}\n\t\tint A[4], B[4];\n\t\tfor(int i = 0; i < 4; i++) cin >> A[i] >> B[i];\n\t\tl = min(A[0], A[2]), r = max(A[0], A[2]);\n\t\tu = min(B[0], B[2]), b = max(B[0], B[2]);\n\t\tx.push_back(l), x.push_back(r);\n\t\ty.push_back(u), y.push_back(b);\n\t\t\n\t\txl.clear(), yl.clear();\n\t\tW = comp(x, xl);\n\t\tH = comp(y, yl);\n\t\tl = x[N], r = x[N+1];\n\t\tu = y[N], b = y[N+1];\n\t\t\n\t\tfor(int i = 0; i < W; i++){\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\twindow[i][j] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint px, py, nx, ny, dx, dy;\n\t\tint difx[105], dify[105];\n\t\t\n\t\tfor(int i = 0; i < N; i++) difx[i] = dify[i] = 0;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tpx = x[i], py = y[i];\n\t\t\tnx = x[(i+1)%N], ny = y[(i+1)%N];\n\t\t\tif(nx == px) dx = 0; \n\t\t\telse dx = (nx - px) / abs(nx - px);\n\t\t\tif(ny == py) dy = 0;\n\t\t\telse dy = (ny - py) / abs(ny - py);\n\t\t\t\n\t\t\tif(dx < 0) dify[i]--, dify[(i+1)%N]--;\n\t\t\telse if(dy > 0) difx[i]--, difx[(i+1)%N]--;\n\t\t}\n\t\tfor(int i = 0; i < N; i++) x[i] += difx[i], y[i] += dify[i];\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tpx = x[i], py = y[i];\n\t\t\tnx = x[(i+1)%N], ny = y[(i+1)%N];\n\t\t\tif(nx == px) dx = 0; \n\t\t\telse dx = (nx - px) / abs(nx - px);\n\t\t\tif(ny == py) dy = 0;\n\t\t\telse dy = (ny - py) / abs(ny - py);\n\t\t\t\n\t\t\tfor(; px != nx || py != ny; px += dx, py += dy) window[px][py] = true;\n\t\t}\n\t\t\n\t\tbool out[300][300];\n\t\tfor(int i = 0; i < W; i++){\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tout[i][j] = window[i][j];\n\t\t\t}\n\t\t}\n\t\tdfs(0, 0, out);\n\t\t\n\t\tfor(int i = 0; i < W; i++){\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tif(!window[i][j] && !out[i][j]){\n\t\t\t\t\tdfs(i, j, window);\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tend:;\n\t\t\n\t\t\n\t\tfor(int i = l; i < r; i++){\n\t\t\tfor(int j = u; j < b; j++){\n\t\t\t\twindow[i][j] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < W; i++){\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tif(window[i][j]) ans += xl[i] * yl[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 20000\n#define N 40005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P1;\ntypedef long long ll;\nconst int DAT_SIZE=(1<<18)-1;\nint X=N;\nll data[DAT_SIZE],datb[DAT_SIZE];\n\nvoid add(int a,int b,int x,int k,int l,int r){\n  if(a<=l&&r<=b)data[k]+=x;\n  else if(l<b&&a<r){\n    datb[k]+=(min(b,r)-max(a,l))*x;\n    add(a,b,x,k*2+1,l,(l+r)/2);\n    add(a,b,x,k*2+2,(l+r)/2,r);\n  }\n}\n\nll sum(int a,int b,int k,int l,int r){\n  if(b<=l||r<=a)return 0;\n  else if(a<=l&&r<=b)\n    return data[k]*(r-l)+datb[k];\n  else{\n    ll res=(min(b,r)-max(a,l))*data[k];\n    res+=sum(a,b,k*2+1,l,(l+r)/2);\n    res+=sum(a,b,k*2+2,(l+r)/2,r);\n    return res;\n  }\n}\n\nint n,x[N],y[N],a,b,xmax,xmin,ymax,ymin;\nvector<P1> L[N];\nset<int> Y;\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i];\n      x[i]+=M;\n      y[i]+=M;\n      Y.insert(y[i]);\n    }\n    for(int i=0;i<n;i++){\n      if(y[i]!=y[(i+1)%n])continue;\n      if(x[i]<x[(i+1)%n])\n\tL[y[i]].push_back(P1(P(x[i],x[(i+1)%n]),1));\n      else\n\tL[y[i]].push_back(P1(P(x[(i+1)%n],x[i]),-1));\n    }\n    xmax=ymax=0;\n    xmin=ymin=(1e9);\n    for(int i=0;i<4;i++){\n      cin>>a>>b;\n      a+=M;\n      b+=M;\n      xmax=max(xmax,a);\n      xmin=min(xmin,a);\n      ymax=max(ymax,b);\n      ymin=min(ymin,b);\n      Y.insert(b);\n    }\n    for(int i=0;i<X;i++)\n      add(i,i+1,0,0,0,X);\n    set<int>::iterator ite=Y.begin();\n    int ans=0,py=(*ite),S=0;\n    while(ite!=Y.end()){\n      ans+=S*((*ite)-py);\n      py=(*ite);\n      for(int i=0;i<L[(*ite)].size();i++){\n\tint s=L[(*ite)][i].first.first;\n\tint g=L[(*ite)][i].first.second;\n\tadd(s,g,L[(*ite)][i].second,0,0,X);\n      }\n      if(ymin<=(*ite)&&(*ite)<ymax)\n\tS=sum(0,xmin,0,0,X)+sum(xmax,X,0,0,X);\n      else S=sum(0,X,0,0,X);\n      ite++;\n    }\n    cout<<ans<<endl;\n    for(int i=0;i<DAT_SIZE;i++)\n      data[i]=datb[i]=0;\n    for(int i=0;i<N;i++)L[i].clear();\n    Y.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct Line {\n\tll lx, rx, y;\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\twhile(cin >> N, N) {\n\t\tvector<ll> x(N), y(N);\n\t\tvector<ll> xs;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t\txs.push_back(x[i]);\n\t\t}\n\n\t\tvector<ll> ax(4), ay(4);\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tcin >> ax[i] >> ay[i];\n\t\t\txs.push_back(ax[i]);\n\t\t}\n\t\tsort(xs.begin(), xs.end());\n\t\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n\t\tvector<Line> ls, cls;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tif(y[i] == y[(i + 1) % N]) {\n\t\t\t\tint lx = min(x[i], x[(i + 1) % N]);\n\t\t\t\tint rx = max(x[i], x[(i + 1) % N]);\n\t\t\t\tls.push_back({ lx, rx, y[i] });\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tif(ay[i] == ay[(i + 1) % 4]) {\n\t\t\t\tint lx = min(ax[i], ax[(i + 1) % N]);\n\t\t\t\tint rx = max(ax[i], ax[(i + 1) % N]);\n\t\t\t\tcls.push_back({ lx, rx, ay[i] });\n\t\t\t}\n\t\t}\n\n\t\ttypedef pair<ll, int> P; // <y, curtain>\n\n\t\tll ans = 0;\n\t\tfor(int i = 0; i < (int)xs.size() - 1; i++) {\n\t\t\tint lx = xs[i], rx = xs[i + 1];\n\t\t\tll w = xs[i + 1] - xs[i];\n\t\t\tvector<P> ys;\n\t\t\tfor(auto l : ls) {\n\t\t\t\tif(l.lx <= lx && rx <= l.rx) {\n\t\t\t\t\tys.push_back({ l.y, 0 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(auto l : cls) {\n\t\t\t\tif(l.lx <= lx && rx <= l.rx) {\n\t\t\t\t\tys.push_back({ l.y, 1 });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsort(ys.begin(), ys.end());\n\t\t\tbool in = false, in_curtain = false;\n\t\t\tfor(int j = 0; j < (int)ys.size() - 1; j++) {\n\t\t\t\tif(ys[j].second) {\n\t\t\t\t\tin_curtain = !in_curtain;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tin = !in;\n\t\t\t\t}\n\t\t\t\tif(in && !in_curtain) {\n\t\t\t\t\tans += w * abs(ys[j].first - ys[j + 1].first);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<pii> pos(n);\n\t\tvector<pii> posc(4);\n\t\tint minx = 99999;\n\t\tint miny = 99999;\n\t\tint maxx = -99999;\n\t\tint maxy = -99999;\n\t\tset<int> posx;\n\t\tset<int> posy;\n\t\tREP(i, n) {\n\t\t\tcin >> pos[i].first >> pos[i].second;\n\t\t\tposx.insert(pos[i].first);\n\t\t\tposy.insert(pos[i].second);\n\t\t}\n\t\tREP(i, 4) {\n\t\t\tcin >> posc[i].first >> posc[i].second;\n\t\t\tposx.insert(posc[i].first);\n\t\t\tposy.insert(posc[i].second);\n\t\t\tminx = min(minx, posc[i].first);\n\t\t\tminy = min(miny, posc[i].second);\n\t\t\tmaxx = max(maxx, posc[i].first);\n\t\t\tmaxy = max(maxy, posc[i].second);\n\t\t}\n\t\tmap<int, int> comx;\n\t\tmap<int, int> comy;\n\t\tmap<int, int> uncomx;\n\t\tmap<int, int> uncomy;\n\t\tfor (int x : posx) {\n\t\t\tif (comx.empty())\n\t\t\t\tcomx[x] = 0;\n\t\t\telse\n\t\t\t\tcomx[x] = comx.size();\n\t\t\tuncomx[comx.size() - 1] = x;\n\t\t}\n\t\tfor (int x : posy) {\n\t\t\tif (comy.empty())\n\t\t\t\tcomy[x] = 0;\n\t\t\telse\n\t\t\t\tcomy[x] = comy.size();\n\t\t\tuncomy[comy.size() - 1] = x;\n\t\t}\n\t\tvvb tate(posy.size() - 1, vb(posx.size(), false));\n\t\tvvb yoko(posy.size(), vb(posx.size() - 1, false));\n\t\tREP(i, n) {\n\t\t\tint start = comy[pos[i].second];\n\t\t\tint goal = comy[pos[(i + 1) % n].second];\n\t\t\tif (goal < start)\n\t\t\t\tswap(start, goal);\n\t\t\tREP(j, goal - start) {\n\t\t\t\ttate[start + j][comx[pos[i].first]] = true;\n\t\t\t}\n\t\t\t/*\n\t\t\tstart = comx[pos[i].first];\n\t\t\tgoal = comx[pos[(i + 1) % n].first];\n\t\t\tif (goal < start)\n\t\t\t\tswap(start, goal);\n\t\t\tREP(j, goal - start) {\n\t\t\t\tyoko[comy[pos[i].second]][start + j] = true;\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tvvb cell(posy.size() - 1, vb(posx.size() - 1, false));\n\t\tREP(i, posy.size() - 1) {\n\t\t\tbool into = false;\n\t\t\tREP(j, posx.size()) {\n\t\t\t\tif (tate[i][j] == true)\n\t\t\t\t\tinto = !into;\n\t\t\t\tif (j < posx.size() - 1 && into)\n\t\t\t\t\tcell[i][j] = true;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tREP(j, posx.size() - 1) {\n\t\t\tbool into = false;\n\t\t\tREP(i, posy.size()) {\n\t\t\t\tif (yoko[i][j] == true)\n\t\t\t\t\tinto = !into;\n\t\t\t\tif (i < posy.size() - 1)\n\t\t\t\t\tif(into&&cell[i][j])\n\t\t\t\t\tcell[i][j] = true;\n\t\t\t\telse\n\t\t\t\t\tcell[i][j] = false;\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tint ans = 0;\n\t\tREP(i, posy.size() - 1) {\n\t\t\tREP(j, posx.size() - 1) {\n\t\t\t\tif (comy[miny] <= i&&i < comy[maxy] && comx[minx] <= j&&j < comx[maxx])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (cell[i][j])\n\t\t\t\t\tans += (uncomx[j + 1] - uncomx[j])*(uncomy[i + 1] - uncomy[i]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst int INF = 1LL << 29;\nconst ll LONGINF = 1LL << 60;\nconst ll MOD = 1000000007LL;\n\nconst int MAXW = 40010;\nconst int ofs = 20000;\n\n// @category セグメント木 (Segment Tree)\n// @title 遅延伝播セグメント木 (Lazy Segment Tree)\ntemplate <typename MonoidType, typename OperatorType>\nstruct LazySegmentTree {\n    using MMtoM = function< MonoidType(MonoidType, MonoidType) >;\n    using OOtoO = function< OperatorType(OperatorType, OperatorType) >;\n    using MOtoM = function< MonoidType(MonoidType, OperatorType) >;\n    using OItoO = function< OperatorType(OperatorType, int) >;\n\n    // node, lazy, update flag (for lazy), identity element\n    int n;\n    vector<MonoidType> node;\n    vector<OperatorType> lazy;\n    vector<bool> need_update;\n    MonoidType E0;\n    OperatorType E1;\n\n    // update / combine / lazy / accumulate function\n    MOtoM upd_f;\n    MMtoM cmb_f;\n    OOtoO lzy_f;\n    OItoO acc_f;\n\n    void build(int m, vector<MonoidType> v = vector<MonoidType>()) {\n        if(v != vector<MonoidType>()) m = v.size();\n        n = 1; while(n < m) n *= 2;\n\n        node = vector<MonoidType>(2*n-1, E0);\n        lazy = vector<OperatorType>(2*n-1, E1);\n        need_update = vector<bool>(2*n-1, false);\n        if(v != vector<MonoidType>()) {\n            for(int i=0; i<m; i++) {\n                node[n-1+i] = v[i];\n            }\n            for(int i=n-2; i>=0; i--) {\n                node[i] = cmb_f(node[2*i+1], node[2*i+2]);\n            }\n        }\n    }\n\n    // initialize\n    LazySegmentTree() {}\n    LazySegmentTree(int n_, MonoidType E0_, OperatorType E1_,\n                    MOtoM upd_f_, MMtoM cmb_f_, OOtoO lzy_f_, OItoO acc_f_,\n                    vector<MonoidType> v = vector<MonoidType>()) :\n        E0(E0_), E1(E1_),\n        upd_f(upd_f_), cmb_f(cmb_f_), lzy_f(lzy_f_), acc_f(acc_f_) {\n        build(n_, v);\n    }\n\n    void eval(int k, int l, int r) {\n        if(!need_update[k]) return;\n        node[k] = upd_f(node[k], acc_f(lazy[k], r - l));\n        if(r - l > 1) {\n            lazy[2*k+1] = lzy_f(lazy[2*k+1], lazy[k]);\n            lazy[2*k+2] = lzy_f(lazy[2*k+2], lazy[k]);\n            need_update[2*k+1] = need_update[2*k+2] = true;\n        }\n        lazy[k] = E1;\n        need_update[k] = false;\n    }\n\n    void update(int a, int b, OperatorType x, int l, int r, int k) {\n        eval(k, l, r);\n        if(b <= l or  r <= a) return;\n        if(a <= l and r <= b) {\n            lazy[k] = lzy_f(lazy[k], x);\n            need_update[k] = true;\n            eval(k, l, r);\n        }\n        else {\n            int mid = (l + r) / 2;\n            update(a, b, x, l, mid, 2*k+1);\n            update(a, b, x, mid, r, 2*k+2);\n            node[k] = cmb_f(node[2*k+1], node[2*k+2]);\n        }\n    }\n\n    MonoidType query(int a, int b, int l, int r, int k) {\n        if(b <= l or  r <= a) return E0;\n        eval(k, l, r);\n        if(a <= l and r <= b) return node[k];\n        int mid = (l + r) / 2;\n        MonoidType vl = query(a, b, l, mid, 2*k+1);\n        MonoidType vr = query(a, b, mid, r, 2*k+2);\n        return cmb_f(vl, vr);\n    }\n\n    // update [a, b)-th element (applied value, x)\n    void update(int a, int b, OperatorType x) {\n        update(a, b, x, 0, n, 0);\n    }\n\n    // range query for [a, b)\n    MonoidType query(int a, int b) {\n        return query(a, b, 0, n, 0);\n    }\n\n    void dump() {\n        fprintf(stderr, \"[lazy]\\n\");\n        for(int i=0; i<2*n-1; i++) {\n            if(i == n-1) fprintf(stderr, \"xxx \");\n            if(lazy[i] == E1) fprintf(stderr, \"  E \");\n            else fprintf(stderr, \"%3d \", lazy[i]);\n        }\n        fprintf(stderr, \"\\n\");\n\n        fprintf(stderr, \"[node]\\n\");\n        for(int i=0; i<2*n-1; i++) {\n            if(i == n-1) fprintf(stderr, \"xxx \");\n            if(node[i] == E0) fprintf(stderr, \"  E \");\n            else fprintf(stderr, \"%3d \", node[i]);\n        }\n        fprintf(stderr, \"\\n\");\n    }\n};\n\nint solve_testcase() {\n    int N; scanf(\"%d\", &N);\n    if(N == 0) return 1;\n\n    vector< vector< pair<int, int> > > add_y(MAXW), del_y(MAXW);\n    vector<int> X(N), Y(N), pari(N);\n    for(int i=0; i<N; i++) {\n        scanf(\"%d%d\", &X[i], &Y[i]);\n        X[i] += ofs, Y[i] += ofs;\n    }\n    for(int i=0; i<N; i++) {\n        int u = i, v = (i + 1) % N;\n        if(Y[u] == Y[v]) continue;\n        int mi = min(Y[u], Y[v]), ma = max(Y[u], Y[v]);\n        add_y[mi].emplace_back(X[u], i);\n        del_y[ma].emplace_back(X[u], i);\n    }\n    for(int i=0; i<MAXW; i++) {\n        sort(add_y[i].begin(), add_y[i].end());\n        sort(del_y[i].begin(), del_y[i].end());\n    }\n\n    int wx1 = INF, wx2 = -INF, wy1 = INF, wy2 = -INF;\n    for(int i=0; i<4; i++) {\n        int s, t; scanf(\"%d%d\", &s, &t);\n        s += ofs, t += ofs;\n        chmin(wx1, s);\n        chmax(wx2, s);\n        chmin(wy1, t);\n        chmax(wy2, t);\n    }\n\n    LazySegmentTree<int, int> seg1(MAXW, 0, 0,\n                                   [](int a, int b) { return a + b; },\n                                   [](int a, int b) { return a + b; },\n                                   [](int a, int b) { return a + b; },\n                                   [](int a, int x) { return a * x; });\n    LazySegmentTree<int, int> seg2(MAXW, 0, 0,\n                                   [](int a, int b) { return a + b; },\n                                   [](int a, int b) { return a + b; },\n                                   [](int a, int b) { return a + b; },\n                                   [](int a, int x) { return a * x; });\n\n    ll ans = 0;\n    for(int i=0; i<MAXW; i++) {\n        for(auto p : del_y[i]) {\n            int x, k; tie(x, k) = p;\n            seg1.update(x, x+1, -1);\n            seg2.update(x, MAXW, (pari[k] ? +1 : -1));\n        }\n        for(auto p : add_y[i]) {\n            int x, k; tie(x, k) = p;\n            int m = seg1.query(0, x) % 2;\n            pari[k] = m;\n            // fprintf(stderr, \"add (i = %d): x = %d, pari = %d\\n\", i, x, pari[k]);\n            seg1.update(x, x+1, +1);\n            seg2.update(x, MAXW, (pari[k] ? -1 : +1));\n        }\n\n        ll add = 0;\n        if(wy1 <= i and i < wy2) {\n            add += seg2.query(0, wx1);\n            add += seg2.query(wx2, MAXW);\n        }\n        else {\n            add += seg2.query(0, MAXW);\n        }\n        // if(add > 0) fprintf(stderr, \"i = %d, add = %lld\\n\", i, add);\n        ans += add;\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n\n\n\nint main() {\n    while(!solve_testcase());\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  while (true) {\n    int n; cin >> n;\n    if (!n) break;\n    V<> xs, ys;\n    V<> x(n), y(n);\n    for (int i = 0; i < n; ++i) {\n      cin >> x[i] >> y[i];\n      xs.push_back(x[i]);\n      ys.push_back(y[i]);\n    }\n    V<> a(4), b(4);\n    for (int i = 0; i < 4; ++i) {\n      cin >> a[i] >> b[i];\n      xs.push_back(a[i]);\n      ys.push_back(b[i]);\n    }\n    sort(begin(xs), end(xs));\n    xs.erase(unique(begin(xs), end(xs)), end(xs));\n    sort(begin(ys), end(ys));\n    ys.erase(unique(begin(ys), end(ys)), end(ys));\n    auto zipx = [&](int e) -> int { return lower_bound(begin(xs), end(xs), e) - begin(xs); };\n    auto zipy = [&](int e) -> int { return lower_bound(begin(ys), end(ys), e) - begin(ys); };\n    for (auto&& e : x) e = zipx(e);\n    for (auto&& e : y) e = zipy(e);\n    for (auto&& e : a) e = zipx(e);\n    for (auto&& e : b) e = zipy(e);\n    int w = xs.size() - 1, h = ys.size() - 1;\n    VV<bool> e(w, V<bool>(h + 1));\n    for (int i = 0; i < n; ++i) {\n      int j = (i + 1) % n;\n      if (y[i] != y[j]) continue;\n      int xl = x[i], xr = x[j];\n      if (xl > xr) swap(xl, xr);\n      for (int t = xl; t < xr; ++t) e[t][y[i]] = true;\n    }\n    VV<bool> s(w, V<bool>(h));\n    for (int xx = 0; xx < w; ++xx) for (int yy = 0; yy < h; ++yy) {\n      int c = 0;\n      for (int yyy = 0; yyy <= yy; ++yyy) c += e[xx][yyy];\n      s[xx][yy] = c & 1;\n    }\n    int res = 0;\n    int x0 = *min_element(begin(a), end(a)), x1 = *max_element(begin(a), end(a));\n    int y0 = *min_element(begin(b), end(b)), y1 = *max_element(begin(b), end(b));\n    for (int xx = 0; xx < w; ++xx) for (int yy = 0; yy < h; ++yy) if (s[xx][yy]) {\n      if (x0 <= xx and xx < x1 and y0 <= yy and yy < y1) continue;\n      res += (xs[xx + 1] - xs[xx]) * (ys[yy + 1] - ys[yy]);\n    }\n    cout << res << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\nint sign(int val) {\n  return val > 0 ? 1 : (val == 0 ? 0 : -1);\n}\n\nvoid bfs(vector<vector<int>> &tb, pair<int,int> s) {\n  int w = tb[0].size();\n  int h = tb.size();\n  queue<pair<int,int>> que;\n  que.push(s);\n  while(!que.empty()) {\n    int i,j;\n    tie(i,j) = que.front();\n    que.pop();\n    int di[] = {1,0,-1,0};\n    int dj[] = {0,1,0,-1};\n    REP(k,4) {\n      int ni=i+di[k];\n      int nj=j+dj[k];\n      if (ni<0||nj<0||ni>=h||nj>=w) continue;\n      if(tb[ni][nj] == 1) {\n        tb[ni][nj] = 0;\n        que.emplace(ni,nj);\n      }\n    }\n  }\n}\n\nint main() {\n  while(1){\n    int n;\n    cin>>n;\n    if (!n) break;\n    vector<pair<int,int>> poly;\n    vector<int> vx, vy;\n    vx.push_back(-21000);\n    vy.push_back(-21000);\n    vx.push_back(-20100);\n    vy.push_back(-20100);\n    vx.push_back(21000);\n    vy.push_back(21000);\n    REP(i,n) {\n      int x,y;\n      cin>>x>>y;\n      poly.emplace_back(x,y);\n      vx.push_back(x);\n      vy.push_back(y);\n    }\n    vector<pair<int,int>> rect;\n    REP(i,4) {\n      int x,y;\n      cin>>x>>y;\n      rect.emplace_back(x,y);\n      vx.push_back(x);\n      vy.push_back(y);\n    }\n    sort(ALL(vx));\n    sort(ALL(vy));\n    vx.erase(unique(ALL(vx)), end(vx));\n    vy.erase(unique(ALL(vy)), end(vy));\n    int h = vy.size();\n    int w = vx.size();\n    vector<vector<int>> tb(h, vector<int>(w, 1));\n    REP(i,n) {\n      int j = (i+1)%n;\n      int ix, iy, jx, jy;\n      tie(ix, iy) = poly[i];\n      tie(jx, jy) = poly[j];\n      int idix = lower_bound(ALL(vx), ix) - begin(vx);\n      int idiy = lower_bound(ALL(vy), iy) - begin(vy);\n      int idjx = lower_bound(ALL(vx), jx) - begin(vx);\n      int idjy = lower_bound(ALL(vy), jy) - begin(vy);\n      if (jx-ix != 0) {\n        if (jx > ix) {\n          FOR(k,idix,idjx) {\n            tb[idjy-1][k] = 0;\n          }\n        } else {\n          FOR(k,idjx,idix) {\n            tb[idjy][k] = 0;\n          }\n        }\n      } else {\n        if (jy > iy) {\n          FOR(k,idiy,idjy) {\n            tb[k][idjx] = 0;\n          }\n        } else {\n          FOR(k,idjy,idiy) {\n            tb[k][idjx-1] = 0;\n          }\n        }\n      }\n    }\n    tb[0][0] = 0;\n    bfs(tb, make_pair(0,0));\n    vector<vector<int>> tb2(h, vector<int>(w, 0));\n    REP(i,4) {\n      int j = (i+1)%4;\n      int ix, iy, jx, jy;\n      tie(ix, iy) = rect[i];\n      tie(jx, jy) = rect[j];\n      int cross2 = ix-jx;\n      int idx = lower_bound(ALL(vx), jx) - begin(vx);\n      int idy = lower_bound(ALL(vy), jy) - begin(vy);\n      tb2[idy][idx] += (cross2 ? 1 : -1);\n    }\n    REP(i,h) REP(j,w-1) tb2[i][j+1] += tb2[i][j];\n    REP(i,h-1) REP(j,w) tb2[i+1][j] += tb2[i][j];\n    int64_t area = 0;\n    REP(i,h)REP(j,w) {\n      if (tb[i][j] && tb2[i][j] == 0)\n        area += (vx[j+1] - vx[j]) * (vy[i+1] - vy[i]);\n    }\n    cout << area << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\nusing namespace std;\n\nint N;\nvector<int> a(4),b(4);\nvector<int> a2(4),b2(4);\nint l,r,u,d;\n\nusing P = pair<int,int>;\nusing PP = pair<P,P>;\n\n// 0.5 2.5\n// l : 1 r : 3 , d : 0 , u : 2\ninline bool inCaten(double x,double y){\n    if(d<= x and x<=u and l<= y and y<=r) return true;\n    else return false;\n}\n\nvoid solve(){\n    vector<int> x(N),y(N);\n    for(int i=0;i<N;i++) cin >> x[i] >> y[i];\n    for(int i=0;i<4;i++) cin >> a[i] >> b[i];\n\n    set<int> xset,yset;\n    for(int i=0;i<N;i++){\n        xset.insert(x[i]); yset.insert(y[i]);\n    }\n    for(int i=0;i<4;i++){\n        xset.insert(a[i]); yset.insert(b[i]);\n    }\n\n    map<int,int> X,rX,Y,rY;\n    int cnt = 0;\n    for(auto xx : xset){\n        X[xx] = cnt;\n        rX[cnt] = xx;\n        cnt++;\n    }\n    cnt = 0;\n    for(auto yy : yset){\n        Y[yy] = cnt;\n        rY[cnt] = yy;\n        cnt++;\n    }\n\n    // 座標変換\n    vector<int> x2(N),y2(N);\n    for(int i=0;i<N;i++){\n        x2[i] = X[x[i]];\n        y2[i] = Y[y[i]];\n    }\n    for(int i=0;i<4;i++){\n        a2[i] = X[a[i]];\n        b2[i] = Y[b[i]];\n    }\n\n    // カーテンの座標 \n    l = 200000; r = 0;\n    d = 200000; u = 0;\n    for(int i=0;i<4;i++) d = min(d,a2[i]);\n    for(int i=0;i<4;i++) u = max(u,a2[i]);\n    for(int i=0;i<4;i++) l = min(l,b2[i]);\n    for(int i=0;i<4;i++) r = max(r,b2[i]);\n\n    \n    int H = xset.size();\n    int W = yset.size();\n\n    vector<vector<bool>> table(H+10,vector<bool>(W+10,false));\n    map<PP,bool> edge;\n\n    for(int i=0;i<N;i++){\n        int nxt = (i+1) % N;\n\n        int myx = x2[i];\n        int myy = y2[i];\n        int nxtx = x2[nxt];\n        int nxty = y2[nxt];\n\n        //edge[PP(P(myx,myy),P(nxtx,nxty))] = true;\n        //edge[PP(P(nxtx,nxty),P(myx,myy))] = true;\n    \n        // TODO : FIX\n        if(myx == nxtx){\n            for(int yy = min(myy,nxty); yy <= max(myy,nxty); yy++){\n                if(yy+1 <= max(myy,nxty)){\n                    edge[PP(P(myx,yy),P(myx,yy+1))] = true;\n                    edge[PP(P(myx,yy+1),P(myx,yy))] = true;\n                }\n                table[myx][yy] = true;\n            }\n        }else{\n            for(int xx = min(myx,nxtx); xx <= max(myx,nxtx); xx++){\n                if(xx+1 <= max(myx,nxtx)){\n                    edge[PP(P(xx,myy),P(xx+1,myy))] = true;\n                    edge[PP(P(xx+1,myy),P(xx,myy))] = true;\n                }\n                table[xx][myy] = true;\n            }\n        }\n    }\n/*\n    cerr << \"H \" << H << endl;\n    cerr << \"W \" << W << endl;\n    cerr << \"l \" << l << endl;\n    cerr << \"r \" << r << endl;\n    cerr << \"d \" << d << endl;\n    cerr << \"u \" << u << endl;\n\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            cerr << table[i][j];\n        }\n        cerr << endl;\n    }\n\n    if(edge[PP(P(0,0),P(0,1))]){\n        cerr << \"POI\" << endl;\n    }else{\n        cerr << \"HA\" << endl;\n    }\n*/\n\n    long long ans = 0;\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            double nowx = (i + i + 1) / 2.0;\n            double nowy = (j + j + 1) / 2.0;\n            if(inCaten(nowx,nowy)){\n                //cerr << nowx << \" \" << nowy << \" \" << \"CARTEN\" << endl;\n                continue;\n            }\n            int cnt1=0,cnt2=0;\n            if(!rX.count(i+1) or !rY.count(j+1)) continue;\n            for(int k=i;k>=0;k--){\n                if(edge[PP(P(k,j),P(k,j+1))]){\n                    cnt1++;\n                }\n                /*\n                if(table[k][j] and table[k][j+1]){\n                    cerr << \"cnt1 \" << \"(\" << k << \",\" << j << \")\" << \" \"  << \"(\" << k << \",\" << j+1 << \")\" << endl;\n                    cnt1++;\n                }\n                */\n            }\n            for(int k=i+1;k<H;k++){\n                if(edge[PP(P(k,j),P(k,j+1))]){\n                    cnt2++;\n                }\n                /*\n                if(table[k][j] and table[k][j+1]){\n                    cerr << \"cnt2 \" << \"(\" << k << \",\" << j << \")\" << \" \"  << \"(\" << k << \",\" << j+1 << \")\" << endl;\n                    cnt2++;\n                }\n                */\n            }\n            if(cnt1%2==1 and cnt2%2==1){\n                int dx = rX[i+1] - rX[i];\n                int dy = rY[j+1] - rY[j];\n                ans += dx * dy;\n                //cerr << nowx << \" \" << nowy << \" \" << \"OK\" << endl;\n            }\n            else{\n                //cerr << nowx << \" \" << nowy << \" \" << \"NO\" << cnt1 << \" \" << cnt2 << endl;\n            }\n        }\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    while(1){\n        cin >> N;\n        if(N==0) break;\n        solve();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\nint sign(int val) {\n  return val > 0 ? 1 : (val == 0 ? 0 : -1);\n}\n\nvoid bfs(vector<vector<int>> &tb, pair<int,int> s) {\n  int w = tb[0].size();\n  int h = tb.size();\n  queue<pair<int,int>> que;\n  que.push(s);\n  while(!que.empty()) {\n    int i,j;\n    tie(i,j) = que.front();\n    que.pop();\n    int di[] = {1,0,-1,0};\n    int dj[] = {0,1,0,-1};\n    REP(k,4) {\n      int ni=i+di[k];\n      int nj=j+dj[k];\n      if (ni<0||nj<0||ni>=h||nj>=w) continue;\n      if(tb[ni][nj] == 1) {\n        tb[ni][nj] = 0;\n        que.emplace(ni,nj);\n      }\n    }\n  }\n}\n\nint main() {\n  while(1){\n    int n;\n    cin>>n;\n    if (!n) break;\n    vector<pair<int,int>> poly;\n    vector<int> vx, vy;\n    vx.push_back(-21000);\n    vy.push_back(-21000);\n    vx.push_back(-20100);\n    vy.push_back(-20100);\n    vx.push_back(21000);\n    vy.push_back(21000);\n    REP(i,n) {\n      int x,y;\n      cin>>x>>y;\n      poly.emplace_back(x,y);\n      vx.push_back(x);\n      vy.push_back(y);\n    }\n    vector<pair<int,int>> rect;\n    REP(i,4) {\n      int x,y;\n      cin>>x>>y;\n      rect.emplace_back(x,y);\n      vx.push_back(x);\n      vy.push_back(y);\n    }\n    sort(ALL(vx));\n    sort(ALL(vy));\n    vx.erase(unique(ALL(vx)), end(vx));\n    vy.erase(unique(ALL(vy)), end(vy));\n    int h = vy.size();\n    int w = vx.size();\n    vector<vector<int>> tb(h, vector<int>(w, 1));\n    REP(i,n) {\n      int j = (i+1)%n;\n      int ix, iy, jx, jy;\n      tie(ix, iy) = poly[i];\n      tie(jx, jy) = poly[j];\n      int idix = lower_bound(ALL(vx), ix) - begin(vx);\n      int idiy = lower_bound(ALL(vy), iy) - begin(vy);\n      int idjx = lower_bound(ALL(vx), jx) - begin(vx);\n      int idjy = lower_bound(ALL(vy), jy) - begin(vy);\n      if (jx-ix != 0) {\n        if (jx > ix) {\n          FOR(k,idix,idjx) {\n            tb[idjy-1][k] = 0;\n          }\n        } else {\n          FOR(k,idjx,idix) {\n            tb[idjy][k] = 0;\n          }\n        }\n      } else {\n        if (jy > iy) {\n          FOR(k,idiy,idjy) {\n            tb[k][idjx] = 0;\n          }\n        } else {\n          FOR(k,idjy,idiy) {\n            tb[k][idjx-1] = 0;\n          }\n        }\n      }\n    }\n    tb[0][0] = 0;\n    bfs(tb, make_pair(0,0));\n    vector<vector<int>> tb2(h, vector<int>(w, 0));\n    REP(i,4) {\n      int j = (i+1)%4;\n      int ix, iy, jx, jy;\n      tie(ix, iy) = rect[i];\n      tie(jx, jy) = rect[j];\n      int cross2 = ix-jx;\n      int idx = lower_bound(ALL(vx), jx) - begin(vx);\n      int idy = lower_bound(ALL(vy), jy) - begin(vy);\n      tb2[idy][idx] += (cross2 ? 1 : -1);\n    }\n    REP(i,h) REP(j,w-1) tb2[i][j+1] += tb2[i][j];\n    REP(i,h-1) REP(j,w) tb2[i+1][j] += tb2[i][j];\n    int64_t area = 0;\n    REP(i,h)REP(j,w) {\n      if (tb[i][j] && tb2[i][j] == 0)\n        area += int64_t(vx[j+1] - vx[j]) * (vy[i+1] - vy[i]);\n    }\n    cout << area << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; ++i)\nusing namespace std;\n\nusing state = tuple<int,int>;\n\nint main(void){\n\n\tint n;\n\twhile(cin >> n,n){\n\n\t\tvector<int> x(n),y(n);\n\t\trep(i,n) cin >> x[i] >> y[i];\n\t\tvector<int> a(4),b(4);\n\t\trep(i,4) cin >> a[i] >> b[i];\n\t\n\t\tconst int offset = 20005;\n\t\tconst int total = 40010;\n\t\tvector<state> events[total];\n\n\t\trep(i,n){\n\t\t\tconst int cur = i;\n\t\t\tconst int nxt = (i+1)%n;\n\t\t\tif(x[cur]==x[nxt]){\n\t\t\t\tint ly = y[cur], uy = y[nxt];\n\t\t\t\tif(ly > uy) swap(ly,uy);\n\t\t\t\tevents[x[cur]+offset].push_back(state(ly,uy));\n\t\t\t}\n\t\t}\n\n\t\tconst int from = min({a[0],a[1],a[2],a[3]});\n\t\tconst int to = max({a[0],a[1],a[2],a[3]});\n\n\n\t\tconst int bl = min({b[0],b[1],b[2],b[3]});\n\t\tconst int bu = max({b[0],b[1],b[2],b[3]});\n\t\t\n\t\t//cerr << \"Range: \" << from << \" \" << to << endl;\n\t\t//cerr << \"Range: \" << bl << \" \" << bu << endl;\n\t\t\n\n\t\tint ans = 0LL, cur = 0; \n\t\tset<state> s;\n\n\t\trep(i,total){\n\t\t\tconst int cx = i - offset;\n\t\t\tbool change = false;\n\n\t\t\tfor(auto &e:events[i]){\n\t\t\t\tchange = true;\n\t\t\t\tif(s.find(e)!=end(s)){\n\t\t\t\t\ts.erase(e);\n\t\t\t\t}else{\n\t\t\t\t\ts.insert(e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(cx == from or cx == to) change = true;\n\n\t\t\tif(change){\n\t\t\t\tvector<int> imos(total,0);\n\n\t\t\t\tfor(auto &e:s){\n\t\t\t\t\tint ly,uy;\n\t\t\t\t\ttie(ly,uy) = e; \n\t\t\t\t\timos[ly+offset]++;\n\t\t\t\t\timos[uy+offset]++;\n\t\t\t\t}\n\n\t\t\t\trep(j,total) if(j-1>=0) imos[j] = (imos[j] + imos[j-1]) % 2;\n\n\t\t\t\tcur = 0;\n\t\t\t\trep(j,total){\n\t\t\t\t\tconst int cy = j - offset;\n\t\t\t\t\tif(from <= cx and cx < to and bl <= cy and cy < bu) continue;\n\t\t\t\t\tcur += imos[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += cur;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, bool> P;\n\nvector<P> ys[200];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\twhile(cin >> N, N) {\n\t\tvector<ll> x(N), y(N), cx(4), cy(4);\n\t\tvector<ll> xv;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i];\n\t\t\txv.push_back(x[i]);\n\t\t}\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tcin >> cx[i] >> cy[i];\n\t\t\txv.push_back(cx[i]);\n\t\t}\n\t\tsort(xv.begin(), xv.end());\n\t\txv.erase(unique(xv.begin(), xv.end()), xv.end());\n\t\tfor(int i = 0; i < xv.size(); i++) {\n\t\t\tys[i].clear();\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tint j = (i + 1) % N;\n\t\t\tif(y[i] != y[j]) continue;\n\t\t\tll lx = min(x[i], x[j]);\n\t\t\tll rx = max(x[i], x[j]);\n\t\t\tfor(int k = 0; k < xv.size() - 1; k++) {\n\t\t\t\tif(lx <= xv[k] && xv[k + 1] <= rx) {\n\t\t\t\t\tys[k].push_back({ y[i], 0 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tint j = (i + 1) % 4;\n\t\t\tif(cy[i] != cy[j]) continue;\n\t\t\tll lx = min(cx[i], cx[j]);\n\t\t\tll rx = max(cx[i], cx[j]);\n\t\t\tfor(int k = 0; k < xv.size() - 1; k++) {\n\t\t\t\tif(lx <= xv[k] && xv[k + 1] <= rx) {\n\t\t\t\t\tys[k].push_back({ cy[i], 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < xv.size(); i++) {\n\t\t\tsort(ys[i].begin(), ys[i].end());\n\t\t}\n\n\t\tll ans = 0;\n\t\tfor(int i = 0; i < xv.size() - 1; i++) {\n\t\t\tll w = xv[i + 1] - xv[i];\n\t\t\tbool in = false, in_curtain = false;\n\t\t\tfor(int j = 0; j < ys[i].size(); j++) {\n\t\t\t\tif(in && !in_curtain) {\n\t\t\t\t\tans += w * (ys[i][j].first - ys[i][j - 1].first);\n\t\t\t\t}\n\t\t\t\tif(ys[i][j].second) in_curtain = !in_curtain;\n\t\t\t\telse in = !in;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nvector<ll> x;\nvector<ll> xx;\nvector<ll> y;\nvector<ll> yy;\n\nchar mp[444][444];\nchar cmp[444][444];\n\nvoid zaatu(){\n\tREP(i,x.size()){\n\t\txx.PB(x[i]);\n\t\txx.PB(x[i]+1);\n\t\txx.PB(x[i]-1);\n\t}\n\tREP(i,y.size()){\n\t\tyy.PB(y[i]);\n\t\tyy.PB(y[i]+1);\n\t\tyy.PB(y[i]-1);\n\t}\n\tsort(ALL(xx));\n\tsort(ALL(yy));\n\txx.erase(unique(ALL(xx)),xx.end());\n\tyy.erase(unique(ALL(yy)),yy.end());\n\t\n\tREP(i,x.size()){\n\t\tx[i] = lower_bound(ALL(xx),x[i]) - xx.begin();\n\t\ty[i] = lower_bound(ALL(yy),y[i]) - yy.begin();\n\t}\n}\n\t\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tREP(i,444)REP(j,444)mp[i][j] = '.';\n\t\tREP(i,444)REP(j,444)cmp[i][j] = '.';\n\t\tx.clear();\n\t\ty.clear();\n\t\txx.clear();\n\t\tyy.clear();\n\t\tREP(i,n+4){\n\t\t\tint a,b;cin >> a >> b;\n\t\t\tx.PB(a);\n\t\t\ty.PB(b);\n\t\t}\n\t\t\n\t\tzaatu();\n\t\t\n\t\tREP(i,n){\n\t\t\tmp[y[i]][x[i]] = '#';\n\t\t}\n\t\t\n\t\tbool flag = false;\n\t\tREP(i,444){\n\t\t\tREP(j,444){\n\t\t\t\tif(mp[i][j] == '#')flag = !flag;\n\t\t\t\tif(flag)mp[i][j] = '#';\n\t\t\t\telse mp[i][j] = '.';\n\t\t\t}\n\t\t\tflag = false;\n\t\t}\n\t\t//SHOW2d(mp,3*n,3*n);\n\t\t\n\t\tflag = false;\n\t\tREP(j,444){\n\t\t\tREP(i,444){\n\t\t\t\tif(mp[i][j] == '#')flag = !flag;\n\t\t\t\tif(flag)mp[i][j] = '#';\n\t\t\t\telse mp[i][j] = '.';\n\t\t\t}\n\t\t\tflag = false;\n\t\t}\n\t\t//SHOW2d(mp,3*n,3*n);\n\t\t\n\t\tREP(i,4){\n\t\t\tcmp[y[i+n]][x[i+n]] = '!';\n\t\t}\n\t\t\n\t\tflag = false;\n\t\tREP(i,444){\n\t\t\tREP(j,444){\n\t\t\t\tif(cmp[i][j] == '!')flag = !flag;\n\t\t\t\tif(flag)cmp[i][j] = '!';\n\t\t\t\telse cmp[i][j] = '.';\n\t\t\t}\n\t\t\tflag = false;\n\t\t}\n\t\t\n\t\tflag = false;\n\t\tREP(j,444){\n\t\t\tREP(i,444){\n\t\t\t\tif(cmp[i][j] == '!')flag = !flag;\n\t\t\t\tif(flag)mp[i][j] = '!';\n\t\t\t\telse cmp[i][j] = '.';\n\t\t\t}\n\t\t\tflag = false;\n\t\t}\n\t\t\t\t\n\t\tREP(i,444){\n\t\t\tREP(j,444){\n\t\t\t\tif(cmp[i][j] == '!')mp[i][j] = '!';\n\t\t\t}\n\t\t}\n\t\t\n\t\tDBG(\n\t\tSHOW2d(mp,3*n,3*n);\t\n\t\tSHOW1d(xx,xx.size());\n\t\tSHOW1d(yy,yy.size());\n\t\t)\n\t\t\n\t\tll ans = 0;\n\t\t\n\t\tREP(i,444){\n\t\t\tREP(j,444){\n\t\t\t\tif(mp[i][j] == '#'){\n\t\t\t\t\t//cout << i << ' ' << j << ' '<< yy[i+1] << ' ' << yy[i] << ' ' << xx[j+1] << ' ' << xx[j] << endl;\n\t\t\t\t\tans += (yy[i+1] - yy[i]) * (xx[j+1] - xx[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef complex<double> Point;\n\nint n;\nint lx, ly, rx, ry;\n\ndouble area(vector<Point> poly) {\n\tdouble ret = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint ni = (i + 1) % n;\n\t\tret += poly[i].real() * poly[ni].imag() - poly[ni].real() * poly[i].imag();\n\t}\n\tret /= 2;\n\treturn ret;\n}\n\nint main() {\n\tint i;\n\t\n\twhile (cin >> n) {\n\t\tif (n == 0) break;\n\t\t\n\t\tvector<Point> poly;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tpoly.push_back(Point((double)x, (double)y));\n\t\t}\n\t\t\n\t\tlx = ly = 50000;\n\t\trx = ry = -50000;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tlx = min(lx, x);\n\t\t\tly = min(ly, y);\n\t\t\trx = max(rx, x);\n\t\t\try = max(ry, y);\n\t\t}\n\t\t\n\t\tvector<Point> poly2;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tdouble x, y;\n\t\t\tx = min((double)rx, max((double)lx, poly[i].real()));\n\t\t\ty = min((double)ry, max((double)ly, poly[i].imag()));\n\t\t\tpoly2.push_back(Point(x, y));\n\t\t}\n\t\t\n\t\tcout << area(poly) << endl;\n\t\tcout << area(poly2) << endl;\n\t\t\n\t\tcout << (int)(area(poly) - area(poly2)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\nint sign(int val) {\n  return val > 0 ? 1 : (val == 0 ? 0 : -1);\n}\n\nvoid bfs(vector<vector<int>> &tb, pair<int,int> s) {\n  int w = tb[0].size();\n  int h = tb.size();\n  queue<pair<int,int>> que;\n  que.push(s);\n  while(!que.empty()) {\n    int i,j;\n    tie(i,j) = que.front();\n    que.pop();\n    int di[] = {1,0,-1,0};\n    int dj[] = {0,1,0,-1};\n    REP(k,4) {\n      int ni=i+di[k];\n      int nj=j+dj[k];\n      if (ni<0||nj<0||ni>=h||nj>=w) continue;\n      if(tb[ni][nj] == 1) {\n        tb[ni][nj] = 0;\n        que.emplace(ni,nj);\n      }\n    }\n  }\n}\n\nint main() {\n  while(1){\n    int n;\n    cin>>n;\n    if (!n) break;\n    vector<pair<int,int>> poly;\n    vector<int> vx, vy;\n    vx.push_back(-21000);\n    vy.push_back(-21000);\n    vx.push_back(-20100);\n    vy.push_back(-20100);\n    vx.push_back(21000);\n    vy.push_back(21000);\n    vx.push_back(20100);\n    vy.push_back(20100);\n    REP(i,n) {\n      int x,y;\n      cin>>x>>y;\n      poly.emplace_back(x,y);\n      vx.push_back(x);\n      vy.push_back(y);\n    }\n    vector<pair<int,int>> rect;\n    REP(i,4) {\n      int x,y;\n      cin>>x>>y;\n      rect.emplace_back(x,y);\n      vx.push_back(x);\n      vy.push_back(y);\n    }\n    sort(ALL(vx));\n    sort(ALL(vy));\n    vx.erase(unique(ALL(vx)), end(vx));\n    vy.erase(unique(ALL(vy)), end(vy));\n    int h = vy.size();\n    int w = vx.size();\n    vector<vector<int>> tb(h, vector<int>(w, 1));\n    REP(i,n) {\n      int j = (i+1)%n;\n      int ix, iy, jx, jy;\n      tie(ix, iy) = poly[i];\n      tie(jx, jy) = poly[j];\n      int idix = lower_bound(ALL(vx), ix) - begin(vx);\n      int idiy = lower_bound(ALL(vy), iy) - begin(vy);\n      int idjx = lower_bound(ALL(vx), jx) - begin(vx);\n      int idjy = lower_bound(ALL(vy), jy) - begin(vy);\n      if (jx-ix != 0) {\n        if (jx > ix) {\n          FOR(k,idix,idjx) {\n            tb[idjy-1][k] = 0;\n          }\n        } else {\n          FOR(k,idjx,idix) {\n            tb[idjy][k] = 0;\n          }\n        }\n      } else {\n        if (jy > iy) {\n          FOR(k,idiy,idjy) {\n            tb[k][idjx] = 0;\n          }\n        } else {\n          FOR(k,idjy,idiy) {\n            tb[k][idjx-1] = 0;\n          }\n        }\n      }\n    }\n    tb[0][0] = 0;\n    bfs(tb, make_pair(0,0));\n    vector<vector<int>> tb2(h, vector<int>(w, 0));\n    REP(i,4) {\n      int j = (i+1)%4;\n      int ix, iy, jx, jy;\n      tie(ix, iy) = rect[i];\n      tie(jx, jy) = rect[j];\n      int cross2 = ix-jx;\n      int idx = lower_bound(ALL(vx), jx) - begin(vx);\n      int idy = lower_bound(ALL(vy), jy) - begin(vy);\n      tb2[idy][idx] += (cross2 ? 1 : -1);\n    }\n    REP(i,h) REP(j,w-1) tb2[i][j+1] += tb2[i][j];\n    REP(i,h-1) REP(j,w) tb2[i+1][j] += tb2[i][j];\n    int64_t area = 0;\n    REP(i,h)REP(j,w) {\n      if (tb[i][j] && tb2[i][j] == 0)\n        area += int64_t(vx[j+1] - vx[j]) * (vy[i+1] - vy[i]);\n    }\n    cout << area << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef complex<double> Point;\n\nint n;\nint lx, ly, rx, ry;\n\ndouble area(vector<Point> poly) {\n\tdouble ret = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint ni = (i + 1) % n;\n\t\tret += poly[i].real() * poly[ni].imag() - poly[ni].real() * poly[i].imag();\n\t}\n\tret /= 2;\n\treturn ret;\n}\n\nint main() {\n\tint i;\n\t\n\twhile (cin >> n) {\n\t\tif (n == 0) break;\n\t\t\n\t\tvector<Point> poly;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tpoly.push_back(Point((double)x, (double)y));\n\t\t}\n\t\t\n\t\tlx = ly = 50000;\n\t\trx = ry = -50000;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tlx = min(lx, x);\n\t\t\tly = min(ly, y);\n\t\t\trx = max(rx, x);\n\t\t\try = max(ry, y);\n\t\t}\n\t\t\n\t\tvector<Point> poly2;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tdouble x, y;\n\t\t\tx = min((double)rx, max((double)lx, poly[i].real()));\n\t\t\ty = min((double)ry, max((double)ly, poly[i].imag()));\n\t\t\tpoly2.push_back(Point(x, y));\n\t\t}\n\t\t\n\t\tcout << (int)(area(poly) - area(poly2)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\nint N, AX, AY, BX, BY;\nvector<int> UX, UY;\nint F[200][200];\nvector<pair<int, int>> wd, cr;\nvector<int> wdirs;\n\nvoid input() {\n  \n  wd.clear();\n  UX.clear();\n  UY.clear();\n  cr.clear();\n  wdirs.clear();\n  \n  int px, py;\n  rep(i, N) {\n    int x, y; cin >> x >> y;\n    wd.push_back({x, y});\n    UX.push_back(x);\n    UY.push_back(y);\n    if(i) {\n      if(x < px) wdirs.push_back(0);\n      if(y < py) wdirs.push_back(1);\n      if(px < x) wdirs.push_back(2);\n      if(py < y) wdirs.push_back(3);\n    }\n    px = x, py = y;\n  }\n\n  if(wd[0].first < px) wdirs.push_back(0);\n  if(wd[0].second < py) wdirs.push_back(1);\n  if(px < wd[0].first) wdirs.push_back(2);\n  if(py < wd[0].second) wdirs.push_back(3);\n  \n  AX = AY = 1e9, BX = BY = -1e9;\n  \n  rep(i, 4) {\n    int x, y; cin >> x >> y;\n    AX = min(AX, x);\n    AY = min(AY, y);\n    BX = max(BX, x);\n    BY = max(BY, y);\n    cr.push_back({x, y});\n    UX.push_back(x);\n    UY.push_back(y);\n  }\n}\n\nint main() {\n  \n  while(cin >> N && N) {\n    \n    input();\n\n    sort(UX.begin(), UX.end());\n    sort(UY.begin(), UY.end());\n    \n    UX.erase(unique(UX.begin(), UX.end()), UX.end());\n    UY.erase(unique(UY.begin(), UY.end()), UY.end());\n    \n    map<int, int> X, Y;\n    rep(i, UX.size()) X[UX[i]] = i;\n    rep(i, UY.size()) Y[UY[i]] = i;\n    \n    memset(F, 0, sizeof F);\n    \n    rep(i, N) {\n      if(wdirs[i] == 0 || wdirs[i] == 2) {\n      \tF[Y[wd[i].second]][X[wd[i].first]] ++;\n      \tF[Y[wd[(i+1)%N].second]][X[wd[(i+1)%N].first]] --;\n      }\n    }\n    \n    rep(j, N) rep(i, N) F[i+1][j] += F[i][j];\n    rep(i, N) rep(j, N) F[i][j+1] += F[i][j];\n    \n    REP(i, Y[AY], Y[BY]) REP(j, X[AX], X[BX]) F[i][j] = 0;\n    \n    long long ans = 0;\n\n    rep(i, N) rep(j, N) if(F[i][j])\n      ans += (UX[j+1] - UX[j]) * (UY[i+1] - UY[i]);\n    \n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\n#define int long long\n\nclass Grid{\n\tprivate:\n\t\tconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\n\t\tconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\n\t\tvector<int> x,y;\n\t\tvoid compress(vector<int> &v) {\n\t\t\tsort(v.begin(), v.end());\n\t\t\tv.erase(unique(v.begin(),v.end()),v.end());\n\t\t}\n\t\tint lb(vector<int> v, int num){\n\t\t\treturn lower_bound(all(v), num) - v.begin();\n\t\t}\n\tpublic:\n\t\tstatic const int MAX_H = 500, MAX_W = 500;\n\t\tint grid[MAX_H][MAX_W] = {{0}};\n\t\t//~Grid(){ memset(grid, 0, sizeof(grid)); }\n\t\tvoid bfs(int x, int y, int c = -1){ //(x,y)??????bfs????????°????????????c????????????\n\t\t\tif(grid[x][y] != 0) return;\n\t\t\tqueue<pair<int, int>> q;\n\t\t\tq.push(make_pair(x,y));\n\n\t\t\twhile(not q.empty()){\n\t\t\t\tpair<int, int> u = q.front(); q.pop();\n\t\t\t\trep(i,4){\n\t\t\t\t\tint nx, ny;\n\t\t\t\t\tnx = u.first + dx[i];\n\t\t\t\t\tny = u.second + dy[i];\n\t\t\t\t\tif(nx < 0 || nx >= MAX_W || ny < 0 || ny >= MAX_H) continue;\n\t\t\t\t\tif(grid[ny][nx] == 0){\n\t\t\t\t\t\tgrid[ny][nx] = c;\n\t\t\t\t\t\tq.push(make_pair(nx,ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvoid setXY(vector<int> a, vector<int> b){\n\t\t\tcompress(a);\n\t\t\tx = a;\n\t\t\tcompress(b);\n\t\t\ty = b;\n\t\t}\n\t\tvoid write(pair<int, int> a, pair<int, int> b){ //?????´??????????????????\n\t\t\t//show(\"rite\")\n\t\t\t//cout << a.first << ' ' << a.second << endl;\n\t\t\t//cout << b.first << ' ' << b.second << endl;\n\t\t\tint ly = lb(y, a.second);\n\t\t\tint lx = lb(x, a.first);\n\t\t\tint ry = lb(y, b.second);\n\t\t\tint rx = lb(x, b.first);\n\t\t\tif(ly > ry) swap(ly, ry);\n\t\t\tif(lx > rx) swap(lx, rx);\n\t\t\t//cout << ly << ' ' << lx << ' ' << ry << ' ' << rx << endl;\n\t\t\trange(i,ly * 2,ry * 2 + 1){ //?????´\n\t\t\t\tgrid[i][lx * 2] = 1;\n\t\t\t\tgrid[i][rx * 2] = 1;\n\t\t\t}\n\t\t\trange(j,lx * 2, rx * 2 + 1){\n\t\t\t\tgrid[ly * 2][j] = 1;\n\t\t\t\tgrid[ry * 2][j] = 1;\n\t\t\t}\n\t\t}\n\t\tvoid overWrite(Grid a){\n\t\t\trep(i,MAX_H){\n\t\t\t\trep(j,MAX_W){\n\t\t\t\t\tif(a.grid[i][j] != -1){\n\t\t\t\t\t\tgrid[i][j] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sum(){\n\t\t\tint res = 0;\n\t\t\t//for(auto i : y){ show(i) }\n\t\t\trange(i,0,y.size() - 1){\n\t\t\t\trange(j,0,x.size() - 1){\n\t\t\t\t\tif(grid[i * 2 + 1][j * 2 + 1] == 0){\n\t\t\t\t\t\t//show(x.size())\n\t\t\t\t\t\t//\tshow(y.size())\n\t\t\t\t\t\t//cout << i << ' ' << j << endl;\n\t\t\t\t\t\t//show(y[i])\n\t\t\t\t\t\t\t//show(x[j])\n\t\t\t\t\t\t//\tshow(y[i - 1])\n\t\t\t\t\t\t//show(y[i] - y[i - 1])\n\t\t\t\t\t\t//int tmpy = i - 1 < 0 ? 20000 : y[i - 1];\n\t\t\t\t\t\t//int tmpx = j - 1 < 0 ? 20000 : x[j - 1];\n\t\t\t\t\t\tres += (y[i + 1] - y[i]) * (x[j + 1] - x[j]);\n\t\t\t\t\t\t//show(res)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tvoid output(){\n\t\t\trep(i,10){\n\t\t\t\trep(j,10){\n\t\t\t\t\tif(grid[i][j] == 0) cout << \"_ \";\n\t\t\t\t\telse if(grid[i][j] == -1) cout << \"# \";\n\t\t\t\t\telse cout << \"* \";\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n};\n\nsigned main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<int> x, y;\n\t\tvector<pair<int, int>> p, r;\n\t\trep(i,n){\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta += 20000;\n\t\t\tb += 20000;\n\t\t\tx.emplace_back(a);\n\t\t\ty.emplace_back(b);\n\t\t\tp.emplace_back(make_pair(a,b));\n\t\t}\n\t\trep(i,4){\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta += 20000;\n\t\t\tb += 20000;\n\t\t\tx.emplace_back(a);\n\t\t\ty.emplace_back(b);\n\t\t\tr.emplace_back(make_pair(a,b));\n\t\t}\n\t\t//x.emplace_back(20000);\n\t\t//y.emplace_back(20000);\n\n\t\tGrid win, cur;\n\t\t//win.output();\n\t\twin.setXY(x,y);\n\t\tcur.setXY(x,y);\n\n\t\trep(i,n){\n\t\t\twin.write(p[i], p[(i + 1) % n]);\n\t\t}\n\t\trep(i,4){\n\t\t\tcur.write(r[i], r[(i + 1) % 4]);\n\t\t}\n\t\twin.bfs(0,0);\n\t\tcur.bfs(0,0);\n\t\twin.bfs(400,400);\n\t\tcur.bfs(400,400);\n\t\t//win.output();\n\t\t//cur.output();\n\n\t\twin.overWrite(cur);\n\t\t//win.output();\n\n\t\tcout << win.sum() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n#define UNIQUE(x) sort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end()); \n\n/* SegmentTree(Sum) */\n//0-index\n\nstruct SegTree{\n  typedef int Type;\n  int segn2;\n  Type inf;\n  vector<Type> data,s_data;\n  \n  SegTree(int n){\n    segn2=1;\n    while(segn2<n) segn2*=2;\n    \n    data.assign(segn2*2,0);\n    s_data.assign(segn2*2,0);\n  }\n  \n  //get sum of [a,b]\n  Type query(int a,int b,int l=0,int r=-1,int k=0){\n    Type ret = 0;\n    \n    if(r==-1) r+=segn2;\n    \n    if(r<a || b<l) return 0;\n    \n    if(a<=l && r<=b) return data[k] + s_data[k]*(r-l+1);\n    \n    ret += (min(r,b)-max(l,a)+1) * s_data[k];\n    \n    ret += query(a,b,l,(l+r)/2,k*2+1)+query(a,b,(l+r)/2+1,r,k*2+2);\n    return ret;\n  }\n  \n  //add x to [a,b]\n  Type add(int a,int b,Type x,int l=0,int r=-1,int k=0){\n    if(r==-1) r+=segn2;\n    \n    if(a<=l && r<=b){\n      s_data[k]+=x;\n    }else if(a<=r && l<=b){\n      data[k] = add(a,b,x,l,(l+r)/2,k*2+1) + add(a,b,x,(l+r)/2+1,r,k*2+2);\n    }\n    \n    return data[k] + s_data[k]*(r-l+1);\n  }\n};\n\n\n\nvoid calc(int n){\n  int base = 20000;\n  int x[SIZE],y[SIZE], a[4],b[4];\n  \n  vector<pair<int,pair<int,int> > > vec;\n  \n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\",x+i,y+i);\n    x[i] += base;\n    y[i] += base;\n\n    if(i > 0 && y[i-1] == y[i]){\n      vec.push_back({y[i],{min(x[i-1],x[i]),max(x[i-1],x[i])}});\n    }\n  }\n\n  if(y[0] == y[n-1]){\n    vec.push_back({y[0],{min(x[0],x[n-1]),max(x[0],x[n-1])}});\n  }\n\n  int min_x = INF, min_y = INF, max_x = -INF, max_y = -INF;\n  \n  for(int i=0;i<4;i++){\n    scanf(\"%d%d\",a+i,b+i);\n    a[i]+=base; b[i]+=base;\n    min_x = min(min_x, a[i]);\n    min_y = min(min_y, b[i]);\n    max_x = max(max_x, a[i]);\n    max_y = max(max_y, b[i]);\n  }\n\n  sort(vec.begin(),vec.end());\n  \n  SegTree seg(base*2+10);\n\n  int t = 0;\n  ll ans = 0;\n  \n  for(int i=0;i<=base*2+1;i++){\n    \n    while(t < vec.size() && vec[t].first == i){\n      if(seg.query(vec[t].second.first, vec[t].second.second-1) > 0){\n        seg.add(vec[t].second.first, vec[t].second.second-1,-1);\n      }else{\n        seg.add(vec[t].second.first, vec[t].second.second-1,1);\n      }\n      t++;\n    }\n\n    if(min_y <= i && i < max_y){\n      ans += seg.query(0,min_x-1) + seg.query(max_x,INF);\n    }else{\n      ans += seg.query(0,INF);\n    }\n    \n  }\n\n\n  printf(\"%lld\\n\",ans);\n  \n}\n\n\nint main(){\n  int n;\n\n  while(1){\n    scanf(\"%d\",&n);\n    if(n == 0) break;\n    calc(n);\n  }\n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define int ll\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define RFOR(i, a, b) for (int i = (b)-1; i >= int(a); --i)\n#define rep(i, n) FOR(i, 0, n)\n#define rep1(i, n) FOR(i, 1, int(n) + 1)\n#define rrep(i, n) RFOR(i, 0, n)\n#define rrep1(i, n) RFOR(i, 1, int(n) + 1)\n#define all(c) begin(c), end(c)\n\ntemplate <typename T>\nvoid __dump__(std::ostream &os, const T &first) {\n    os << first;\n}\ntemplate <typename First, typename... Rest>\nvoid __dump__(std::ostream &os, const First &first, const Rest &... rest) {\n    os << first << \", \";\n    __dump__(os, rest...);\n}\n#define dump(...)                                         \\\n    do {                                                  \\\n        std::ostringstream os;                            \\\n        os << __LINE__ << \":\\t\" << #__VA_ARGS__ << \" = \"; \\\n        __dump__(os, __VA_ARGS__);                        \\\n        std::cerr << os.str() << std::endl;               \\\n    } while (0)\n\n\nconst int INF = 1000000000;\nconst int OFS = 20010;\n\nint N;\nint X[110], Y[110];\nvector<vector<int>> ys(OFS * 2 + 1);\n\nsigned main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    while (cin >> N && N) {\n        ys.assign(OFS*2 + 1, {});\n        int px = INF, py = INF;\n        rep(i, N) cin >> X[i] >> Y[i], X[i] += OFS;\n        X[N] = X[0], Y[N] = Y[0];\n        rep(i, N + 1) {\n            int x = X[i], y = Y[i];\n            if (px != INF) {\n                if (y == py) {\n                    int xl = min(x, px), xr = max(x, px);\n                    for (int ix = xl; ix < xr; ++ix) {\n                        ys[ix].push_back(y);\n                    }\n                }\n            }\n            px = x;\n            py = y;\n        }\n        int yu = -INF, yd = +INF, xl = +INF, xr = -INF;\n        rep(i, 4) {\n            int x, y;\n            cin >> x >> y;\n            x += OFS;\n            yu = max(y, yu);\n            yd = min(y, yd);\n            xr = max(x, xr);\n            xl = min(x, xl);\n        }\n        ll ans = 0;\n        for (int x = 0; x <= OFS*2; ++x) {\n            auto &yy = ys[x];\n            sort(all(yy));\n            assert(ys[x].size() % 2 == 0);\n            rep(i, yy.size()) {\n                int y1 = yy[i], y2 = yy[i+1];\n                ans += y2 - y1;\n                if (xl <= x && x < xr) {\n                    int oy1 = max(y1, yd);\n                    int oy2 = min(y2, yu);\n                    ans -= oy2 - oy1;\n                }\n                ++i;\n            }\n        }\n        cout << ans << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 200000\n\nstruct Info{\n\tint x,y;\n};\n\nint N,table_X[2*NUM+1],table_Y[2*NUM+1];\nInfo info[101],curtain[4];\nvector<int> X,Y;\n\n\nvoid func(){\n\n\tX.clear();\n\tY.clear();\n\n\tX.push_back(-BIG_NUM);\n\tX.push_back(BIG_NUM);\n\tY.push_back(-BIG_NUM);\n\tY.push_back(BIG_NUM);\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].x,&info[i].y);\n\t\tX.push_back(info[i].x);\n\t\tY.push_back(info[i].y);\n\t}\n\n\tfor(int i = 0; i < 4; i++){\n\t\tscanf(\"%d %d\",&curtain[i].x,&curtain[i].y);\n\t\tX.push_back(curtain[i].x);\n\t\tY.push_back(curtain[i].y);\n\t}\n\n\tsort(X.begin(),X.end());\n\tsort(Y.begin(),Y.end());\n\n\tX.erase(unique(X.begin(),X.end()),X.end());\n\tY.erase(unique(Y.begin(),Y.end()),Y.end());\n\n\tfor(int i = 1; i < X.size()-1; i++){\n\t\ttable_X[X[i]+NUM] = i;\n\t}\n\n\tfor(int i = 1; i < Y.size()-1; i++){\n\t\ttable_Y[Y[i]+NUM] = i;\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tinfo[i].x = table_X[info[i].x+NUM];\n\t\tinfo[i].y = table_Y[info[i].y+NUM];\n\t}\n\n\tinfo[N].x = info[0].x;\n\tinfo[N].y = info[0].y;\n\n\tint H = (int)Y.size(),W = (int)X.size();\n\n\tint calc_table[H][W];\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tcalc_table[row][col] = 0;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tif(info[i].x == info[i+1].x){\n\n\t\t\tif(info[i].y < info[i+1].y){\n\n\t\t\t\tfor(int row = info[i].y; row < info[i+1].y; row++){\n\t\t\t\t\tcalc_table[row][info[i].x]--;\n\t\t\t\t}\n\t\t\t}else{\n\n\t\t\t\tfor(int row = info[i+1].y; row < info[i].y; row++){\n\t\t\t\t\tcalc_table[row][info[i].x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 1; col < W; col++){\n\t\t\tcalc_table[row][col] += calc_table[row][col-1];\n\t\t}\n\t}\n\n\tint min_row = BIG_NUM,max_row = -1,min_col = BIG_NUM,max_col = -1;\n\n\tfor(int i = 0; i < 4; i++){\n\t\tcurtain[i].x = table_X[curtain[i].x+NUM];\n\t\tmin_col = min(min_col,curtain[i].x);\n\t\tmax_col = max(max_col,curtain[i].x);\n\n\t\tcurtain[i].y = table_Y[curtain[i].y+NUM];\n\t\tmin_row = min(min_row,curtain[i].y);\n\t\tmax_row = max(max_row,curtain[i].y);\n\t}\n\n\tfor(int row = min_row; row < max_row; row++){\n\t\tfor(int col = min_col; col < max_col; col++)calc_table[row][col]--;\n\t}\n\n\tll ans = 0;\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tif(calc_table[row][col] == 1){\n\t\t\t\tans += (X[col+1]-X[col])*(Y[row+1]-Y[row]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef complex<double> Point;\n \nint n;\nint lx, ly, rx, ry;\n \ndouble area(vector<Point> poly) {\n    double ret = 0;\n    for (int i = 0; i < n; i++) {\n        int ni = (i + 1) % n;\n        ret += poly[i].real() * poly[ni].imag() - poly[ni].real() * poly[i].imag();\n    }\n    ret /= 2;\n    return ret;\n}\n \nint main() {\n    int i;\n     \n    while (cin >> n) {\n        if (n == 0) break;\n         \n        vector<Point> poly;\n        for (i = 0; i < n; i++) {\n            int x, y;\n            cin >> x >> y;\n            poly.push_back(Point((double)x, (double)y));\n        }\n         \n        lx = ly = 50000;\n        rx = ry = -50000;\n        for (i = 0; i < 4; i++) {\n            int x, y;\n            cin >> x >> y;\n            lx = min(lx, x);\n            ly = min(ly, y);\n            rx = max(rx, x);\n            ry = max(ry, y);\n        }\n         \n        vector<Point> poly2;\n        for (i = 0; i < n; i++) {\n            double x, y;\n            x = min((double)rx, max((double)lx, poly[i].real()));\n            y = min((double)ry, max((double)ly, poly[i].imag()));\n            poly2.push_back(Point(x, y));\n        }\n         \n        cout << (int)(area(poly) - area(poly2)) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,s,e) for(int i = s; i < e; i++)\nusing namespace std;\n\nbool cmp(int a, int b)\n{\n   return a > b;\n}\n\nint main()\n{\n    int n;\n    while(scanf(\"%d\", &n) && n != 0)\n    {\n        list<int> c[40000];\n        int left = 40000, right = 0;\n        int fx, fy;\n        int px, py;\n        rep(i,0,n+1)\n        {\n            int x,y;\n            if(i == n)\n            {\n                x = fx;\n                y = fy;\n                goto label;\n            }\n            cin >> x >> y;\n            if(i == 0)\n            {\n                fx = x;\n                fy = y;\n                px = x;\n                py = y;\n                continue;\n            }\n            label:\n            if(x != px)\n            {\n                int Min = min(x,px)+20000, Max = max(x,px)+20000;\n                left = min(left,Min), right = max(right,Max);\n                rep(j,Min,Max)\n                {\n                    c[j].push_back(y);\n                }\n                px = x;\n            }\n        }\n        rep(i,left,right)\n            c[i].sort(greater<int>());\n    \n        pair<int,int> cartain[4];\n        rep(i,0,4)\n        {\n            cin >> cartain[i].first >> cartain[i].second;\n            cartain[i].first += 20000;\n        }\n        sort(cartain,cartain+4);\n        int cUp= cartain[1].second;\n        int cBottom = cartain[0].second;\n        int cLeft = cartain[1].first;\n        int cRight = cartain[3].first;\n        long long ans = 0;\n       \n        rep(i, left, right)\n        {\n            bool flag = true;\n            auto it = c[i].begin();\n            auto end = c[i].end();\n            for(it; it != --end; it++)\n            {\n                if(flag)\n                {\n                    int up = *it;\n                    int bottom = *(++it);\n                    it--;\n                    if(cLeft > i || cBottom >= up || cUp <= bottom || cRight <= i)\n                        ans += up - bottom;\n                    else if(cBottom >= bottom && cBottom <= up && cUp >= up)\n                        ans += cBottom - bottom;\n                    else if(cUp >= bottom && cUp <= up && cBottom <= bottom) \n                        ans += up - cUp;\n                    else if(cUp <= up && cBottom >= bottom)\n                        ans += (up-cUp) + (cBottom-bottom);   \n                }\n                flag = !flag;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(X,Y) for(int X=0;X<(Y); ++X)\n#define reps(X,O,Y) for(int X=O;X<(Y); ++X)\n#define pb push_back\n#define eb emplace_back\n#define all(X) (X).begin(),(X).end()\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst ll MOD=1e9+7;\n\nint mp[333][333];\n\nint main(){\n  int n;\n  while(cin>>n, n){\n    fill(mp[0],mp[333],0);\n    vector<pii> ps(n);\n    rep(i,n) cin>>ps[i].X>>ps[i].Y;\n    ps.pb(ps[0]); ++n;\n    int x,y,X,Y;\n    cin>>x>>y; {int a,b; cin>>a>>b;}\n    cin>>X>>Y; {int a,b; cin>>a>>b;}\n    vector<int> xs{x,X},ys{y,Y};\n    for(pii p:ps) xs.pb(p.X), ys.pb(p.Y);\n    sort(all(xs)); xs.erase(unique(all(xs)),xs.end());\n    sort(all(ys)); ys.erase(unique(all(ys)),ys.end());\n    for(pii &p:ps){\n      p.X=lower_bound(all(xs),p.X)-xs.begin();\n      p.Y=lower_bound(all(ys),p.Y)-ys.begin();\n    }\n    x=lower_bound(all(xs),x)-xs.begin();\n    y=lower_bound(all(ys),y)-ys.begin();\n    X=lower_bound(all(xs),X)-xs.begin();\n    Y=lower_bound(all(ys),Y)-ys.begin();\n    if(x>X) swap(x,X);\n    if(y>Y) swap(y,Y);\n    //rep(i,n) cout<<i<<\",\"<<ps[i].X<<\",\"<<ps[i].Y<<endl;\n    rep(i,n)if(i && ps[i-1].X==ps[i].X){\n      //cout<<i<<\",\"<<ps[i].X<<\":\"<<ps[i-1].Y<<\",\"<<ps[i].Y<<endl;\n      reps(y,min(ps[i-1].Y,ps[i].Y),max(ps[i-1].Y,ps[i].Y)) mp[y][ps[i].X]^=1;\n    }\n    reps(i,y,Y) mp[i][x]^=2;\n    reps(i,y,Y) mp[i][X]^=2;\n    //rep(i,10){rep(j,10)cout<<mp[i][j];cout<<endl;} cout<<endl;\n    rep(i,330)rep(j,330) mp[i][j+1]^=mp[i][j];\n    // for(int x:xs) cout<<x<<\",\";cout<<x<<\",\"<<X<<endl;\n    // for(int y:ys) cout<<y<<\",\";cout<<y<<\",\"<<Y<<endl;\n    // rep(i,10){rep(j,10)cout<<mp[i][j];cout<<endl;}\n    ll re=0;\n    rep(i,330)rep(j,330)if(mp[i][j]==1){\n      re+=1ll*(xs[j+1]-xs[j])*(ys[i+1]-ys[i]);\n    }\n    cout<<re<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <iostream>\n#include <map>\n#include <set>\n#include <vector>\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> Poly;\ntypedef pair<P,P> L;\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble dot(P a, P b){return a.X*b.X + a.Y*b.Y;}\n\ndouble cross(P a, P b){return a.X*b.Y - a.Y*b.X;}\n\nint ccw(P a, P b, P c){\n  b -= a;c -= a;\n  if(cross(b, c) > EPS) return 1;\n  if(cross(b, c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(c) - norm(b) > EPS) return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  if(ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0 &&\n     ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0) return true;\n  return false;\n}\n\n\nP intersection(L a, L b){\n  //??´???a??¨??´???b?????????\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nint in_poly(P a, Poly p){\n  int n = p.size(), c = 0;\n  for(int i = 0; i < n; ++i){\n    P s = p[i]-a, t = p[(i+1)%n]-a;\n    if(!ccw(s,t,P(0,0))) return 1;//??????\n    if(s.Y > t.Y + EPS) swap(s,t);\n    if((s.Y*t.Y < 0 || (s.Y*t.Y < EPS && t.Y > EPS)) && cross(s,t) < EPS) ++c;\n  }\n  if(c%2) return 2;//?????¨\n  return 0;//?????¨\n}\n\n\nint main(){\n  int N;\n  set<int> M_x, M_y;\n  while(cin >> N, N){\n    double x, y;\n    Poly W;\n    for(int i = 0; i < N; ++i){\n      cin >> x >> y;\n      W.push_back(P(x,y));\n      M_x.insert(x);\n      M_y.insert(y);\n    }\n    Poly C;\n    for(int i = 0; i < 4; ++i){\n      cin >> x >> y;\n      C.push_back(P(x,y));\n      M_x.insert(x);\n      M_y.insert(y);\n    }\n    vector<int> V_x;\n    for(auto p: M_x){\n      V_x.push_back(p);\n    }\n    vector<int> V_y;\n    for(auto p: M_y){\n      V_y.push_back(p);\n    }\n    int n_x = V_x.size(), n_y = V_y.size();\n    long long int ans = 0LL;\n    for(int i = 1; i < n_x; ++i){\n      for(int j = 1; j < n_y; ++j){\n\tP p = P((double)(V_x[i]+V_x[i-1])/2.0, (double)(V_y[j]+V_y[j-1])/2.0);\n\tif(in_poly(p,W) && !in_poly(p,C)) ans += (V_x[i]-V_x[i-1])*(V_y[j]-V_y[j-1]);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAX_N = 1<<16;\n\nclass RSQ2{\npublic:\n  ll n,dat[2*MAX_N-1],td[2*MAX_N-1];\n  RSQ2(){n=MAX_N,memset(dat,0,sizeof(dat)),memset(td,0,sizeof(td));};\n  \n  ll add(int a,int b,ll x,int k=0,int l=0,int r=-1){\n    if(r==-1) r=n;\n    if(r<=a||b<=l)return 0;\n    if(a<=l&&r<=b){\n      dat[k]+=(r-l)*x; \n      td[k]+=x;\n      return dat[k];\n    }\n\n    dat[k]+=(min(r,b)-max(l,a))*x;\n    ll kl=k*2+1,kr=k*2+2,t=td[k]*(r-l)/2;\n    dat[kl]+=t, dat[kr]+=t;\n    td[kl]+=td[k], td[kr]+=td[k];\n    td[k]=0;\n    \n    ll vl=add(a,b,x,k*2+1,l,(l+r)/2);\n    ll vr=add(a,b,x,k*2+2,(l+r)/2,r);\n    return vl+vr;\n  }\n  \n  ll sum(int a,int b){return a>=b? 0:add(a,b,0);}\n};\n\n\nstruct data{int l,r;};\nstruct P{int x,y;};\nconst int B=30000;\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<vector<data> > LR(MAX_N);\n    vector<P> A(n);\n    for(int i=0;i<n;i++)cin>>A[i].x>>A[i].y,A[i].x+=B,A[i].y+=B;\n    for(int i=1;i<=n;i++)\n      if(A[i%n].y==A[i-1].y)\n\tLR[A[i%n].y].push_back((data){A[i-1].x,A[i%n].x});\n    \n    map <int,data> C;\n    for(int i=0;i<4;i++)cin>>A[i].x>>A[i].y,A[i].x+=B,A[i].y+=B;\n    for(int i=1;i<=4;i++)\n      if(A[i%4].y==A[i-1].y)C[A[i%4].y]=(data){A[i-1].x,A[i%4].x};\n    \n    RSQ2 T;\n    ll ans=0;\n    for(int i=0,cl=0,cr=0;i<MAX_N;i++){\n      if(C.count(i)&&!cl&&!cr) cl=C[i].l,cr=C[i].r;\n      else if(C.count(i)) cl=cr=0;\n\n      for(int j=0;j<LR[i].size();j++){\n\tint l = LR[i][j].l,r=LR[i][j].r;\n\tl<r ? T.add(l,r,1): T.add(r,l,-1);\n      }\n      ans+=T.sum(0,cl)+T.sum(cr,T.n);\n    }\n    cout <<ans<<endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n#define X real()\n#define Y imag()\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\ntypedef complex<double> P;\ntypedef complex<double> point;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<P> G;\ntypedef vector<P> polygon;\n\nstruct C {\n\tP p; double r;\n\tC(const P &p, double r) : p(p), r(r) { }\n};\n//??????????????????\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n > 0) {\n\t\tvector<P> ps;\n\t\trep(i, n) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tps.pb({x, y});\n\t\t}\n\t\tdouble S = 0.0;\n\t\trep(i, n) {\n\t\t\tint now = i, prv = (i - 1 + n) % n, nxt = (i + 1) % n;\n\t\t\t//S += cross(ps[nxt]-ps[now], ps[prv]-ps[now])/2.0;\n\t\t\t//S += cross(ps[nxt] - c, ps[now] - c)/2.0;\n\t\t\tS += (ps[now].X - ps[nxt].X)*(ps[now].Y +ps[nxt].Y);\n\t\t}\n\t\tG rect;\n\t\tdouble l = INF, r = -INF, u = -INF, d = INF;\n\t\trep(i, 4) {\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\trect.pb({x, y});\n\t\t\tl = min(l, x);\n\t\t\tr = max(r, x);\n\t\t\tu = max(u, y);\n\t\t\td = min(d, y);\n\t\t}\n\t\tG pp;\n\t\trep(i, n) {\n\t\t\tdouble x, y;\n\t\t\tif(ps[i].X > r) x = r;\n\t\t\telse if(ps[i].X < l) x = l;\n\t\t\telse x = ps[i].X;\n\t\t\tif(ps[i].Y > u) y = u;\n\t\t\telse if(ps[i].Y < d) y = d;\n\t\t\telse y = ps[i].Y;\n\t\t\tpp.pb({x, y});\n\t\t}\n\t\tdouble s = 0.0;\n\t\trep(i, n) {\n\t\t\tint now = i, prv = (i - 1 + n) % n, nxt = (i + 1) % n;\n\t\t\t//s += cross(pp[nxt]-pp[now], pp[prv]-pp[now])/2.0;\n\t\t\t//s += cross(ps[nxt] - m, ps[now] -)/2.0;\n\t\t\ts += (pp[now].X - pp[nxt].X)*(pp[now].Y +pp[nxt].Y);\n\t\t}\n\t\tS /= 2.0;\n\t\ts /= 2.0;\n\t\tprintf(\"%d\\n\", (int)(abs(S) - abs(s) + EPS));\n\t\t//cout << S <<\" \" << s << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 101;\nconst int wide = 20000;\n\nint main()\n{\n    while(1){\n        int n;\n        scanf(\"%d\",&n);\n        if(n == 0){\n            break;\n        }\n        vector<P> cor;\n        vector<P> row[wide*2+2];\n        rep(i,n){\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            cor.push_back(P(x,y));\n        }\n        vector<P> cart;\n        rep(i,4){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            cart.push_back(P(a,b));\n        }\n        sort(cart.begin(),cart.end());\n        sort(cor.begin(),cor.end());\n        rep(i,n/2){\n            for(int j = cor[2*i+1].second + wide - 1; j >= cor[2*i].second + wide; j--){\n                row[j].push_back(P(cor[2*i].first,0));\n            }\n        }\n        for(int j = cart[1].second + wide - 1; j >= cart[0].second + wide; j--){\n            row[j].push_back(P(cart[0].first,1));\n        }\n        for(int j = cart[3].second + wide - 1; j >= cart[2].second + wide; j--){\n            row[j].push_back(P(cart[2].first,1));\n        }\n        for(int j = 2*wide - 1; j >= 0; j--){\n            sort(row[j].begin(),row[j].end());\n        }\n        int res = 0;\n        for(int i = 2*wide - 1;i >= 0; i--){\n            int sm = 0;\n            bool hide = false;\n            rep(j,row[i].size()){\n                if(row[i][j].second == 1){\n                    if(hide){\n                        hide = false;\n                    }else{\n                        if(row[i][j+1].second == 1){\n                            j++;\n                        }else{\n                            if(row[i][j+2].second == 1){\n                                sm += row[i][j+3].first - row[i][j+2].first;\n                                j += 3;\n                            }else{\n                                hide = true;\n                                j += 2;\n                            }\n                        }\n                    }\n                }else{\n                    if(hide){\n                        if(row[i][j+1].second == 1){\n                            sm += row[i][j+2].first - row[i][j+1].first;\n                            hide = false;\n                            j += 2;\n                        }else{\n                            j++;\n                        }\n                    }else{\n                        if(row[i][j+1].second == 1){\n                            if(row[i][j+2].second == 1){\n                                sm += (row[i][j+3].first - row[i][j].first) - (row[i][j+2].first - row[i][j+1].first);\n                                j += 3;\n                            }else{\n                                sm += row[i][j+1].first - row[i][j].first;\n                                j += 2;\n                                hide = true;\n                            }\n                        }else{\n                            sm += row[i][j+1].first - row[i][j].first;\n                            j++;\n                        }\n                    }\n                }\n            }\n            res += sm;\n        }\n        printf(\"%d\\n\",res);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\nconst int MOD = 1000000007;\n// const int INF = 0x3f3f3f3f3f3f3f3f;\n// const double EPS = 1e-10;\n/* ---------------------------------------------------------------------------------------------------- */\n\n/* 基本要素 */\n\nusing D = double; // 座標値の型 doubleかlong double\nusing P = complex<D>; // Point\nusing L = pair<P,P>;  // Line\nusing VP = vector<P>;\nconst double EPS = 1e-8;  // 許容誤差\nconst double INF = 1e12;\n#define X real()\n#define Y imag()\n#define LT(n,m) ((n)+EPS<(m)) // n < m ?\n#define LE(n,m) ((n)-EPS<(m)) // n <= m ?\n#define GT(n,m) LT(m,n) // n > m ?\n#define GE(n,m) LE(m,n) // n >= m ?\n#define EQ(n,m) (abs((n)-(m))<EPS)\n#define NE(n,m) !EQ(n,m)\n#define rep(i,n) for (int i=0;i<(n);++i)\n\nnamespace std {\n  istream& operator >> (istream& is, P& p) {\n    int F, S;\n    is >> F >> S;\n    p = P(F,S);\n    return is;\n  }\n  bool operator < (const P a, const P b) {\n    return NE(a.X,b.X) ? LT(a.X,b.X) : LT(a.Y,b.Y);\n  }\n  bool operator > (const P a, const P b) {\n    return NE(a.X,b.X) ? GT(a.X,b.X) : GT(a.Y,b.Y);\n  }\n  bool sort_y(const P a, const P b) {\n    return LT(a.Y,b.Y);\n  }\n  void swap(P& a, P& b) {\n    P c = a; a = b; b = c;\n  }\n}\n\n// 内積\nD dot(P a, P b) {\n  return (conj(a)*b).X;\n}\n// 外積\nD cross(P a, P b) {\n  return (conj(a)*b).Y;\n}\n// 点aから見た、点bから点cへの方向\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (GT(cross(b,c),0)) return +1;  // counter clockwise\n  if (LT(cross(b,c),0)) return -1;  // clockwise\n  if (LT(dot(b,c),0)) return +2;  // c--a--b on line\n  if (LT(norm(b),norm(c))) return -2; // a--b--c on line or a==b\n  return 0;                     // a--c--b on line or a==c or b==c\n}\n\n// 多角形の内部判定 O(n)\n// 点が領域内部なら1、境界上なら2、外部なら0を返す\nint inPolygon(const VP& ps, P p) {\n  int n = ps.size();\n  bool in = false;\n  rep (i,n) {\n    P a = ps[i]-p;\n    P b = ps[(i+1)%n]-p;\n    if (EQ(cross(a,b),0) && LE(dot(a,b),0)) return 2;\n    if (GT(a.Y,b.Y)) swap(a,b);\n    if ((LT(a.Y*b.Y,0) || (LE(a.Y*b.Y,0) && GT(b.Y,0))) && LE(cross(a,b),0)) in = !in;\n  }\n  return in;\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  int N;\n  while (cin >> N, N) {\n    vector<int> vx,vy;\n    VP ps(N), qs(4);\n    REP(i,N) {\n      cin >> ps[i];\n      vx.push_back(ps[i].X);\n      vy.push_back(ps[i].Y);\n    }\n    REP(i,4) {\n      cin >> qs[i];\n      vx.push_back(qs[i].X);\n      vy.push_back(qs[i].Y);\n    }\n    UNI(vx);\n    UNI(vy);\n    int ans = 0;\n    for (int i = 0; i+1 < vx.size(); i++) {\n      for (int j = 0; j+1 < vy.size(); j++) {\n        int dx = vx[i+1] - vx[i];\n        int dy = vy[j+1] - vy[j];\n        P p(vx[i]+dx/2.0,vy[j]+dy/2.0);\n        if (inPolygon(ps,p) && !inPolygon(qs,p)) {\n          ans += dx*dy;\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\ntypedef pair<int, P> speP;\nint n;\nvoid solve() {\n\tvector<P> p(n);\n\trep(i, n) {\n\t\tcin >> p[i].first >> p[i].second;\n\t}\n\tint mx[2] = { mod,-mod }, my[2] = { mod,-mod };\n\trep(i, 4) {\n\t\tint a, b; cin >> a >> b;\n\t\tmx[0] = min(mx[0], a);\n\t\tmx[1] = max(mx[1], a);\n\t\tmy[0] = min(my[0], b);\n\t\tmy[1] = max(my[1], b);\n\t}\n\tp.push_back(p[0]);\n\n\tvector<speP> v;\n\trep(i, n) {\n\t\tif (p[i].first == p[i + 1].first) {\n\t\t\tint le = p[i].second, ri = p[i+1].second;\n\t\t\tif (le > ri)swap(le, ri);\n\t\t\tv.push_back({ p[i].first,{le,ri} });\n\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\tint cur = -mod;\n\tvector<P> z;\n\tll ans = 0;\n\t//cout << v.size() << endl;\n\trep(i, v.size()) {\n\t\tsort(z.begin(), z.end());\n\t\t/*cout << i << endl;\n\t\trep(j, z.size()) {\n\t\t\tcout << z[j].first << \" \" << z[j].second << endl;\n\t\t}*/\n\t\tint nx = v[i].first;\n\t\tif (i > 0&&v[i].first>v[i-1].first) {\n\t\t\trep(j, z.size()) {\n\t\t\t\tint ley = z[j].first, riy = z[j].second;\n\t\t\t\tll ad=(riy - ley)*(nx - cur);\n\t\t\t\tint dx = min(mx[1], nx) - max(mx[0], cur);\n\t\t\t\tdx = max(dx, 0);\n\t\t\t\tint dy = min(my[1], riy) - max(my[0], ley);\n\t\t\t\tdy = max(dy, 0);\n\t\t\t\tad -= dx * dy;\n\t\t\t\t//cout << \"! \" << ad << endl;\n\t\t\t\tans += ad;\n\t\t\t}\n\t\t}\n\t\tint le = v[i].second.first, ri = v[i].second.second;\n\t\tbool f = true;\n\t\trep(j, z.size()) {\n\t\t\tif (z[j].first <= le && ri <= z[j].second) {\n\t\t\t\tP nle = { z[j].first,le };\n\t\t\t\tP nri = { ri,z[j].second };\n\t\t\t\tz.erase(z.begin() + j);\n\t\t\t\tif(nri.first!=nri.second)z.insert(z.begin()+j, nri);\n\t\t\t\tif(nle.first!=nle.second)z.insert(z.begin()+j, nle);\n\t\t\t\tf = false; break;\n\t\t\t}\n\t\t}\n\t\tif (f) {\n\t\t\trep(j, z.size()) {\n\t\t\t\tif (z[j].first == ri) {\n\t\t\t\t\tP nex = { le,z[j].second };\n\t\t\t\t\tz.erase(z.begin() + j);\n\t\t\t\t\tz.insert(z.begin() + j, nex);\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (z[j].second == le) {\n\t\t\t\t\tif (j + 1 < z.size() && z[j + 1].first == ri) {\n\t\t\t\t\t\tP nex = { z[j].first,z[j+1].second };\n\t\t\t\t\t\tz.erase(z.begin() + j);\n\t\t\t\t\t\tz.erase(z.begin() + j);\n\t\t\t\t\t\tz.insert(z.begin() + j, nex); \n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tP nex = { z[j].first,ri };\n\t\t\t\t\t\tz.erase(z.begin() + j);\n\t\t\t\t\t\tz.insert(z.begin() + j, nex);\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tz.push_back({ le,ri });\n\t\t\t}\n\t\t}\n\t\tcur = nx;\n\t}\n\t//cout << \"ans is\" << endl;\n\tcout << ans << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\twhile (cin >> n, n) {\n\t\tsolve();\n\t}\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Geometry_Library\n#define ___Geometry_Library\n\n// ------ Includes ------ //\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <algorithm>\n\n// ------ Defines ------ //\ntypedef long double GType;\ntypedef std::complex<GType> Point;\ntypedef std::pair<Point, Point> Segment;\n\n// ------ Constants ------ //\nconst GType EPS = 1.0e-10L;\n\n// ------ Functions Level 1 ------ //\nGType dot(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).real();\n}\nGType cross(const Point& p1, const Point& p2) {\n\treturn (std::conj(p1) * p2).imag();\n}\nint ccw(const Point& p1, const Point& p2, const Point& p3) {\n\tPoint v1 = p2 - p1, v2 = p3 - p1;\n\tif (cross(v1, v2) > EPS) return +1;\n\tif (cross(v1, v2) < -EPS) return -1;\n\tif (dot(v1, v2) < -EPS) return +2;\n\tif (std::norm(v1) < std::norm(v2)) return -2;\n\treturn 0;\n}\n\n// ------ Functions Level 3 ------ //\nGType area(std::vector<Point> v) {\n\tGType ret = 0;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tif (i + 1 != v.size()) ret += cross(v[i], v[i + 1]);\n\t\telse ret += cross(v[i], v[0]);\n\t}\n\treturn std::abs(ret / 2);\n}\nint contain(std::vector<Point> v, Point p) {\n\tbool in = false;\n\tfor (int i = 0; i < v.size(); i++) {\n\t\tPoint a = v[i] - p, b = v[(i + 1 != v.size() ? i + 1 : 0)] - p;\n\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\tif (a.imag() <= EPS && EPS < b.imag() && cross(a, b) < -EPS) in = !in;\n\t\tif (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\n\n#endif\n\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, cx, cy;\nint main() {\n\twhile (cin >> n, n) {\n\t\tvector<Point> v(n);\n\t\tvector<int> sx, sy;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> cx >> cy;\n\t\t\tv[i] = Point(cx, cy);\n\t\t\tsx.push_back(cx);\n\t\t\tsy.push_back(cy);\n\t\t}\n\t\tvector<int> rx(4), ry(4);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcin >> rx[i] >> ry[i];\n\t\t}\n\t\tint xa = *min_element(rx.begin(), rx.end());\n\t\tint ya = *min_element(ry.begin(), ry.end());\n\t\tint xb = *max_element(rx.begin(), rx.end());\n\t\tint yb = *max_element(ry.begin(), ry.end());\n\t\tsx.push_back(xa);\n\t\tsy.push_back(ya);\n\t\tsx.push_back(xb);\n\t\tsy.push_back(yb);\n\t\tsort(sx.begin(), sx.end());\n\t\tsx.erase(unique(sx.begin(), sx.end()), sx.end());\n\t\tsort(sy.begin(), sy.end());\n\t\tsy.erase(unique(sy.begin(), sy.end()), sy.end());\n\t\tint ptlx = lower_bound(sx.begin(), sx.end(), xa) - sx.begin();\n\t\tint ptly = lower_bound(sy.begin(), sy.end(), ya) - sy.begin();\n\t\tint ptrx = lower_bound(sx.begin(), sx.end(), xb) - sx.begin();\n\t\tint ptry = lower_bound(sy.begin(), sy.end(), yb) - sy.begin();\n\t\tint ret = 0;\n\t\tfor (int i = ptlx + 1; i <= ptrx; i++) {\n\t\t\tfor (int j = ptly + 1; j <= ptry; j++) {\n\t\t\t\tdouble mx = (sx[i - 1] + sx[i]) * 0.5, my = (sy[j - 1] + sy[j]) * 0.5;\n\t\t\t\tif (contain(v, Point(mx, my))) ret += (sx[i] - sx[i - 1]) * (sy[j] - sy[j - 1]);\n\t\t\t}\n\t\t}\n\t\tint res = (int)(area(v) + 0.5);\n\t\tcout << res - ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<pii> pos(n);\n\t\tvector<pii> posc(4);\n\t\tint minx = 99999;\n\t\tint miny = 99999;\n\t\tint maxx = -99999;\n\t\tint maxy = -99999;\n\t\tset<int> posx;\n\t\tset<int> posy;\n\t\tREP(i, n) {\n\t\t\tcin >> pos[i].first >> pos[i].second;\n\t\t\tposx.insert(pos[i].first);\n\t\t\tposy.insert(pos[i].second);\n\t\t}\n\t\tREP(i, 4) {\n\t\t\tcin >> posc[i].first >> posc[i].second;\n\t\t\tposx.insert(posc[i].first);\n\t\t\tposy.insert(posc[i].second);\n\t\t\tminx = min(minx, posc[i].first);\n\t\t\tminy = min(miny, posc[i].second);\n\t\t\tmaxx = max(maxx, posc[i].first);\n\t\t\tmaxy = max(maxy, posc[i].second);\n\t\t}\n\t\tmap<int, int> comx;\n\t\tmap<int, int> comy;\n\t\tmap<int, int> uncomx;\n\t\tmap<int, int> uncomy;\n\t\tfor (auto x : posx) {\n\t\t\tif (comx.empty())\n\t\t\t\tcomx[x] = 0;\n\t\t\telse\n\t\t\t\tcomx[x] = comx.size();\n\t\t\tuncomx[comx.size() - 1] = x;\n\t\t}\n\t\tfor (auto x : posy) {\n\t\t\tif (comy.empty())\n\t\t\t\tcomy[x] = 0;\n\t\t\telse\n\t\t\t\tcomy[x] = comy.size();\n\t\t\tuncomy[comy.size() - 1] = x;\n\t\t}\n\t\tvvb tate(posy.size() - 1, vb(posx.size(), false));\n\t\tvvb yoko(posy.size(), vb(posx.size() - 1, false));\n\t\tREP(i, n) {\n\t\t\tint start = comy[pos[i].second];\n\t\t\tint goal = comy[pos[(i + 1) % n].second];\n\t\t\tif (goal < start)\n\t\t\t\tswap(start, goal);\n\t\t\tREP(j, goal - start) {\n\t\t\t\ttate[start + j][comx[pos[i].first]] = true;\n\t\t\t}\n\t\t\t/*\n\t\t\tstart = comx[pos[i].first];\n\t\t\tgoal = comx[pos[(i + 1) % n].first];\n\t\t\tif (goal < start)\n\t\t\t\tswap(start, goal);\n\t\t\tREP(j, goal - start) {\n\t\t\t\tyoko[comy[pos[i].second]][start + j] = true;\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tvvb cell(posy.size() - 1, vb(posx.size() - 1, false));\n\t\tREP(i, posy.size() - 1) {\n\t\t\tbool into = false;\n\t\t\tREP(j, posx.size()) {\n\t\t\t\tif (tate[i][j] == true)\n\t\t\t\t\tinto = !into;\n\t\t\t\tif (j < posx.size() - 1 && into)\n\t\t\t\t\tcell[i][j] = true;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tREP(j, posx.size() - 1) {\n\t\t\tbool into = false;\n\t\t\tREP(i, posy.size()) {\n\t\t\t\tif (yoko[i][j] == true)\n\t\t\t\t\tinto = !into;\n\t\t\t\tif (i < posy.size() - 1)\n\t\t\t\t\tif(into&&cell[i][j])\n\t\t\t\t\tcell[i][j] = true;\n\t\t\t\telse\n\t\t\t\t\tcell[i][j] = false;\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tint ans = 0;\n\t\tREP(i, posy.size() - 1) {\n\t\t\tREP(j, posx.size() - 1) {\n\t\t\t\tif (comy[miny] <= i&&i < comy[maxy] && comx[minx] <= j&&j < comx[maxx])\n\t\t\t\t\tcontinue;\n\t\t\t\tif (cell[i][j])\n\t\t\t\t\tans += (uncomx[j + 1] - uncomx[j])*(uncomy[i + 1] - uncomy[i]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <complex>\n#include <iostream>\n#include <map>\n#include <vector>\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> Poly;\ntypedef pair<P,P> L;\n\nnamespace std{\n  bool operator<(const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\ndouble dot(P a, P b){return a.X*b.X + a.Y*b.Y;}\n\ndouble cross(P a, P b){return a.X*b.Y - a.Y*b.X;}\n\nint ccw(P a, P b, P c){\n  b -= a;c -= a;\n  if(cross(b, c) > EPS) return 1;\n  if(cross(b, c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(c) - norm(b) > EPS) return -2;\n  return 0;\n}\n\nbool is_cross(L a, L b){\n  if(ccw(a.first,a.second,b.first)*ccw(a.first,a.second,b.second) <= 0 &&\n     ccw(b.first,b.second,a.first)*ccw(b.first,b.second,a.second) <= 0) return true;\n  return false;\n}\n\n\nP intersection(L a, L b){\n  //??´???a??¨??´???b?????????\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nint in_poly(P a, Poly p){\n  int n = p.size(), c = 0;\n  for(int i = 0; i < n; ++i){\n    P s = p[i]-a, t = p[(i+1)%n]-a;\n    if(!ccw(s,t,P(0,0))) return 1;//??????\n    if(s.Y > t.Y + EPS) swap(s,t);\n    if((s.Y*t.Y < 0 || (s.Y*t.Y < EPS && t.Y > EPS)) && cross(s,t) < EPS) ++c;\n  }\n  if(c%2) return 2;//?????¨\n  return 0;//?????¨\n}\n\n\nint main(){\n  int N;\n  map<int, int> M_x, M_y;\n  while(cin >> N, N){\n    double x, y;\n    Poly W;\n    for(int i = 0; i < N; ++i){\n      cin >> x >> y;\n      W.push_back(P(x,y));\n      M_x[(int)x] = 0;\n      M_y[(int)y] = 0;\n    }\n    Poly C;\n    for(int i = 0; i < 4; ++i){\n      cin >> x >> y;\n      C.push_back(P(x,y));\n      M_x[(int)x] = 0;\n      M_y[(int)y] = 0;\n    }\n    int k = 0;\n    vector<int> V_x;\n    for(auto p: M_x){\n      p.second = k++;\n      V_x.push_back(p.first);\n    }\n    k = 0;\n    vector<int> V_y;\n    for(auto p: M_y){\n      p.second = k++;\n      V_y.push_back(p.first);\n    }\n    int n_x = V_x.size(), n_y = V_y.size();\n    long long int ans = 0LL;\n    for(int i = 1; i < n_x; ++i){\n      for(int j = 1; j < n_y; ++j){\n\tP p = P((double)(V_x[i]+V_x[i-1])/2.0, (double)(V_y[j]+V_y[j-1])/2.0);\n\tif(in_poly(p,W) && !in_poly(p,C)) ans += (V_x[i]-V_x[i-1])*(V_y[j]-V_y[j-1]);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\n#define int long long\n\nclass Grid{\n\tprivate:\n\t\tconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\n\t\tconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\n\t\tvector<int> x,y;\n\t\tvoid compress(vector<int> &v) {\n\t\t\tsort(v.begin(), v.end());\n\t\t\tv.erase(unique(v.begin(),v.end()),v.end());\n\t\t}\n\t\tint lb(vector<int> v, int num){\n\t\t\treturn lower_bound(all(v), num) - v.begin();\n\t\t}\n\tpublic:\n\t\tstatic const int MAX_H = 1000, MAX_W = 1000;\n\t\tint grid[MAX_H][MAX_W];\n\t\t~Grid(){\n\t\t\tmemset(grid, 0, sizeof(grid));\n\t\t}\n\t\tvoid bfs(int x, int y, int c = -1){ //(x,y)??????bfs????????°????????????c????????????\n\t\t\tif(grid[x][y] != 0) return;\n\t\t\tqueue<pair<int, int>> q;\n\t\t\tq.push(make_pair(x,y));\n\n\t\t\twhile(not q.empty()){\n\t\t\t\tpair<int, int> u = q.front(); q.pop();\n\t\t\t\trep(i,4){\n\t\t\t\t\tint nx, ny;\n\t\t\t\t\tnx = u.first + dx[i];\n\t\t\t\t\tny = u.second + dy[i];\n\t\t\t\t\tif(nx < 0 || nx >= MAX_W || ny < 0 || ny >= MAX_H) continue;\n\t\t\t\t\tif(grid[ny][nx] == 0){\n\t\t\t\t\t\tgrid[ny][nx] = c;\n\t\t\t\t\t\tq.push(make_pair(nx,ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvoid setXY(vector<int> a, vector<int> b){\n\t\t\tcompress(a);\n\t\t\tx = a;\n\t\t\tcompress(b);\n\t\t\ty = b;\n\t\t}\n\t\tvoid write(pair<int, int> a, pair<int, int> b){ //?????´??????????????????\n\t\t\t//show(\"rite\")\n\t\t\t//cout << a.first << ' ' << a.second << endl;\n\t\t\t//cout << b.first << ' ' << b.second << endl;\n\t\t\tint ly = lb(y, a.second);\n\t\t\tint lx = lb(x, a.first);\n\t\t\tint ry = lb(y, b.second);\n\t\t\tint rx = lb(x, b.first);\n\t\t\tif(ly > ry) swap(ly, ry);\n\t\t\tif(lx > rx) swap(lx, rx);\n\t\t\t//cout << ly << ' ' << lx << ' ' << ry << ' ' << rx << endl;\n\t\t\trange(i,ly * 2,ry * 2 + 1){ //?????´\n\t\t\t\tgrid[i][lx * 2] = 1;\n\t\t\t\tgrid[i][rx * 2] = 1;\n\t\t\t}\n\t\t\trange(j,lx * 2, rx * 2 + 1){\n\t\t\t\tgrid[ly * 2][j] = 1;\n\t\t\t\tgrid[ry * 2][j] = 1;\n\t\t\t}\n\t\t}\n\t\tvoid overWrite(Grid a){\n\t\t\trep(i,MAX_H){\n\t\t\t\trep(j,MAX_W){\n\t\t\t\t\tif(a.grid[i][j] != -1){\n\t\t\t\t\t\tgrid[i][j] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sum(){\n\t\t\tint res = 0;\n\t\t\t//for(auto i : y){ show(i) }\n\t\t\trange(i,0,y.size() - 1){\n\t\t\t\trange(j,0,x.size() - 1){\n\t\t\t\t\tif(grid[i * 2 + 1][j * 2 + 1] == 0){\n\t\t\t\t\t\t//show(x.size())\n\t\t\t\t\t\t//\tshow(y.size())\n\t\t\t\t\t\t//cout << i << ' ' << j << endl;\n\t\t\t\t\t\t//show(y[i])\n\t\t\t\t\t\t\t//show(x[j])\n\t\t\t\t\t\t//\tshow(y[i - 1])\n\t\t\t\t\t\t//show(y[i] - y[i - 1])\n\t\t\t\t\t\t//int tmpy = i - 1 < 0 ? 20000 : y[i - 1];\n\t\t\t\t\t\t//int tmpx = j - 1 < 0 ? 20000 : x[j - 1];\n\t\t\t\t\t\tres += (y[i + 1] - y[i]) * (x[j + 1] - x[j]);\n\t\t\t\t\t\t//show(res)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tvoid output(){\n\t\t\trep(i,10){\n\t\t\t\trep(j,10){\n\t\t\t\t\tif(grid[i][j] == 0) cout << \"_ \";\n\t\t\t\t\telse if(grid[i][j] == -1) cout << \"# \";\n\t\t\t\t\telse cout << \"* \";\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t}\n};\n\nsigned main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<int> x, y;\n\t\tvector<pair<int, int>> p, r;\n\t\trep(i,n){\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta += 20000;\n\t\t\tb += 20000;\n\t\t\tx.emplace_back(a);\n\t\t\ty.emplace_back(b);\n\t\t\tp.emplace_back(make_pair(a,b));\n\t\t}\n\t\trep(i,4){\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta += 20000;\n\t\t\tb += 20000;\n\t\t\tx.emplace_back(a);\n\t\t\ty.emplace_back(b);\n\t\t\tr.emplace_back(make_pair(a,b));\n\t\t}\n\t\t//x.emplace_back(20000);\n\t\t//y.emplace_back(20000);\n\n\t\tGrid win, cur;\n\t\twin.setXY(x,y);\n\t\tcur.setXY(x,y);\n\n\t\trep(i,n){\n\t\t\twin.write(p[i], p[(i + 1) % n]);\n\t\t}\n\t\trep(i,4){\n\t\t\tcur.write(r[i], r[(i + 1) % 4]);\n\t\t}\n\t\twin.bfs(0,0);\n\t\tcur.bfs(0,0);\n\t\twin.bfs(400,400);\n\t\tcur.bfs(400,400);\n\t\t//win.output();\n\t\t//cur.output();\n\n\t\twin.overWrite(cur);\n\t\t//win.output();\n\n\t\tcout << win.sum() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing P = pair<int, int>;\n\nconst int MAX = 20000;\n\nint main() {\n  int N;\n  while (cin >> N, N) {\n    auto xs = vector<int>(N);\n    auto ys = vector<int>(N);\n    for (int i = 0; i < N; ++i) cin >> xs[i] >> ys[i];\n\n    int xmin = MAX, xmax = -MAX, ymin = MAX, ymax = -MAX;\n    for (int i = 0; i < 4; ++i) {\n      int a, b; cin >> a >> b;\n      xmin = min(xmin, a);\n      xmax = max(xmax, a);\n      ymin = min(ymin, b);\n      ymax = max(ymax, b);\n    }\n\n    int ans1 = 0, ans2 = 0;\n    auto fx = [&](int val) { return max(xmin, min(xmax, val)); };\n    auto fy = [&](int val) { return max(ymin, min(ymax, val)); };\n    for (int cur = 0; cur < N; ++cur) {\n      int nxt = (cur + 1) % N;\n      if (ys[cur] == ys[nxt]) {\n        ans2 += ys[cur] * (xs[nxt] - xs[cur]);\n        ans1 += fy(ys[cur]) * (fx(xs[nxt]) - fx(xs[cur]));\n      }\n    }\n    cout << abs(ans2 - ans1) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<n;++i)\n#define FOR(i, a, b) for(int i=a;i<b;++i)\n#define RREP(i, n) for(int i=n-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=b-1;i>=a;--i)\n\n#define all(x) begin(x),end(x)\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\n// edit\n\nbool solve() {\n    int n;\n    cin >> n;\n    if (n == 0) return false;\n\n    vector<pair<ll, ll>> xy(n + 1);\n    REP(i, n) {\n        cin >> xy[i].first >> xy[i].second;\n    }\n    xy[n] = xy[0];\n\n    ll lx = INF, rx = -INF, dy = INF, uy = -INF;\n\n    vector<pair<ll, ll>> rect(4);\n    REP(i, 4) cin >> rect[i].first >> rect[i].second;\n\n    REP(i, 4) {\n        chmin(lx, rect[i].first);\n        chmax(rx, rect[i].first);\n        chmin(dy, rect[i].second);\n        chmax(uy, rect[i].second);\n    }\n\n\n    ll ans = 0;\n\n    REP(i, n) {\n        ll sx, sy, tx, ty;\n        tie(sx, sy) = xy[i];\n        tie(tx, ty) = xy[i + 1];\n\n        if (sx == tx) continue;\n\n        ll cx = max(0ll, min(max(sx, tx), rx) - max(min(sx, tx), lx));\n        ll cy = 0;\n        if (sy >= dy) {\n//            cy = max(sy - dy, 0ll);\n            cy = min(uy, sy) - dy;\n        }\n\n        ll add = abs(tx - sx) * ty;\n        add -= cx * cy;\n        if (sx < tx) {\n            add *= -1;\n        }\n        ans += add;\n    }\n\n\n    cout << ans << endl;\n\n    return true;\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n//    std::ifstream in(\"input.txt\");\n//    std::cin.rdbuf(in.rdbuf());\n\n    while (solve());\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAX_N = 1<<16;\n\nclass RSQ2{\npublic:\n  ll n,dat[2*MAX_N-1],td[2*MAX_N-1];\n  RSQ2(){n=MAX_N,memset(dat,0,sizeof(dat)),memset(td,0,sizeof(td));};\n  \n  ll add(int a,int b,ll x,int k=0,int l=0,int r=-1){\n    if(r==-1) r=n;\n    if(r<=a||b<=l)return 0;\n    if(a<=l&&r<=b){\n      dat[k]+=(r-l)*x; \n      td[k]+=x;\n      return dat[k];\n    }\n\n    dat[k]+=(min(r,b)-max(l,a))*x;\n    ll kl=k*2+1,kr=k*2+2,t=td[k]*(r-l)/2;\n    dat[kl]+=t, dat[kr]+=t;\n    td[kl]+=td[k], td[kr]+=td[k];\n    td[k]=0;\n    \n    ll vl=add(a,b,x,k*2+1,l,(l+r)/2);\n    ll vr=add(a,b,x,k*2+2,(l+r)/2,r);\n    return vl+vr;\n  }\n  \n  ll sum(int a,int b){return a>=b? 0:add(a,b,0);}\n};\n\n\nstruct data{int l,r;};\nstruct P{int x,y;};\nconst int B=30000;\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<vector<data> > LR(MAX_N);\n    vector<P> A(n);\n    for(int i=0;i<n;i++)cin>>A[i].x>>A[i].y,A[i].x+=B,A[i].y+=B;\n    for(int i=1;i<=n;i++)\n      if(A[i%n].y==A[i-1].y)\n\tLR[A[i%n].y].push_back((data){A[i%n].x,A[(i-1)%n].x});\n    \n    map <int,data> C;\n    for(int i=0;i<4;i++)cin>>A[i].x>>A[i].y,A[i].x+=B,A[i].y+=B;\n    for(int i=1;i<=4;i++)\n      if(A[i%4].y==A[i-1].y)C[A[i].y]=(data){A[i%4].x,A[i-1].x};\n    \n    RSQ2 T;\n    ll ans=0;\n    for(int i=0,cl=0,cr=0;i<MAX_N;i++){\n      if(C.count(i)&&!cl&&!cr) cl=C[i].l,cr=C[i].r;\n      else if(C.count(i)) cl=cr=0;\n\n      for(int j=0;j<LR[i].size();j++){\n\tint l = LR[i][j].l,r=LR[i][j].r;\n\tl<r ? T.add(l,r,1): T.add(r,l,-1);\n      }\n      ans+=T.sum(0,cl)+T.sum(cr,T.n);\n    }\n    cout <<ans<<endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,s,e) for(int i = s; i < e; i++)\nusing namespace std;\n\nbool cmp(int a, int b)\n{\n   return a > b;\n}\n\nint main()\n{\n    int n;\n     list<int> ansList;\n    while(scanf(\"%d\", &n) && n != 0)\n    {\n        vector<long long> c[40000];\n        int left = 40000, right = 0;\n        int fx, fy;\n        int px, py;\n        rep(i,0,n+1)\n        {\n            int x,y;\n            if(i == n)\n            {\n                x = fx;\n                y = fy;\n                goto label;\n            }\n            cin >> x >> y;\n            if(i == 0)\n            {\n                fx = x;\n                fy = y;\n                px = x;\n                py = y;\n                continue;\n            }\n            label:\n            if(x != px)\n            {\n                int Min = min(x,px)+20000, Max = max(x,px)+20000;\n                left = min(left,Min), right = max(right,Max);\n                rep(j,Min,Max)\n                {\n                    c[j].push_back(y);\n                }\n                px = x;\n            }\n        }\n        rep(i,left,right)\n        {\n            sort(c[i].begin(),c[i].end(), cmp);\n        }\n        pair<int,int> cartain[4];\n        rep(i,0,4)\n        {\n            cin >> cartain[i].first >> cartain[i].second;\n            cartain[i].first += 20000;\n        }\n        sort(cartain,cartain+4);\n        int cUp= cartain[1].second;\n        int cBottom = cartain[0].second;\n        int cLeft = cartain[1].first;\n        int cRight = cartain[3].first;\n        long long ans = 0;\n       \n        rep(i, left, right)\n        {\n            int index = 0;\n            int _size = c[i].size();\n            bool flag = true;\n            while(index < _size-1)\n            {\n                if(flag)\n                {\n                    int up = c[i][index];\n                    int bottom = c[i][index+1];\n                    if(cLeft > i || cBottom >= up || cUp <= bottom || cRight <= i)\n                        ans += up - bottom;\n                    else if(cBottom >= bottom && cBottom <= up && cUp >= up)\n                        ans += cBottom - bottom;\n                    else if(cUp >= bottom && cUp <= up && cBottom <= bottom) \n                        ans += up - cUp;\n                    else if(cUp <= up && cBottom >= bottom)\n                        ans += (up-cUp) + (cBottom-bottom);   \n                }\n                flag = !flag;\n                index++;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\nusing namespace std;\n\nstruct POINT{\n\tint x,y;\n};\n\nint main()\n{\n\twhile (1){\n\t\tint N; cin >> N;\n\n\t\tif (N == 0)break;\n\n\t\tvector<vector<int8_t>>co(40001);\n\t\tfor (int i = 0; i <= 40000; i++) {\n\t\t\tco[i].resize(40001);\n\t\t}\n\t\tvector<POINT>p(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> p[i].x >> p[i].y;\n\t\t\tp[i].x += 20000;\n\t\t\tp[i].y += 20000;\n\t\t\tco[p[i].y][p[i].x] += pow(-1, i);\n\t\t}\n\n\t\tvector<POINT>car(4);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcin >> car[i].x >> car[i].y;\n\t\t\tcar[i].x += 20000;\n\t\t\tcar[i].y += 20000;\n\n\t\t\tco[car[i].y][car[i].x] += 3*pow(-1, i);\n\t\t}\n\n\t\tfor (int i = 0; i <= 40000; i++) {\n\t\t\tfor (int j = 1; j <= 40000; j++) {\n\t\t\t\tco[i][j] += co[i][j - 1];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i <= 40000; i++) {\n\t\t\tfor (int j = 1; j <= 40000; j++) {\n\t\t\t\tco[j][i] += co[j - 1][i];\n\t\t\t}\n\t\t}\n\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i <= 40000; i++) {\n\t\t\tfor (int j = 0; j <= 40000; j++) {\n\t\t\t\tif (co[i][j] == 1 || co[i][j] == -1)cnt++;\n\t\t\t}\n\t\t}\n\n\t\tcout << cnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n  if(a < b) {a = b; return true;}\n  return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n  if(a > b) {a = b; return true;}\n  return false;\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  for(int i=0;i<((int)(v.size()));++i) {\n    if(i) os << \" \";\n    os << v[i];\n  }\n  return os;\n}\nbool solve() {\n  int n; cin >> n;\n  if(n == 0) return false;\n  vector<P> p(n);\n  for(int i=0;i<(n);++i) {\n    cin >> p[i].first >> p[i].second;\n  }\n  vector<P> carten(4);\n  int u = -INF, d = INF, l = INF, r = -INF;\n  for(int i=0;i<(4);++i) {\n    int x, y;\n    cin >> x >> y;\n    chmin(l, x);\n    chmax(r, x);\n    chmin(d, y);\n    chmax(u, y);\n  }\n  l += 20000;\n  r += 20000;\n  u += 20000;\n  d += 20000;\n  vector<pair<int, bitset<40002>>> v;\n  for(int i=0;i<(n);++i) {\n    P p1 = p[i];\n    P p2 = p[(i+1)%n];\n    if(p1.first == p2.first) {\n      bitset<40002> now;\n      int mi = p1.second, ma = p2.second;\n      if(mi > ma) swap(mi, ma);\n      mi += 20000;\n      ma += 20000;\n      for(int j=(mi);j<(ma);++j) {\n        now[j] = 1;\n      }\n      v.emplace_back(make_pair(p1.first + 20000, now));\n    }\n  }\n  sort(v.rbegin(), v.rend(), [](pair<int, bitset<40002>> a, pair<int, bitset<40002>> b){return a.first < b.first;});\n  bitset<40002> bs(0), tmp(0);\n  for(int i=(d);i<(u);++i) {\n    tmp[i] = 1;\n  }\n  int mask = 0;\n  int area = 0;\n  for(int i=0;i<(40002);++i) {\n    while(!v.empty() && v.back().first == i) {\n      bs ^= v.back().second;\n      v.pop_back();\n    }\n    if(l <= i && i < r) {\n      mask += (bs & tmp).count();\n    }\n    area += bs.count();\n  }\n  cout << area - mask << endl;\n  return true;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(solve()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong long x[101],y[101],X[4],Y[4],n,ans;\nmain()\n{\n\twhile(cin>>n,n)\n\t{\n\t\tfor(int i=0;i<n;i++)cin>>x[i]>>y[i];\n\t\tfor(int i=0;i<4;i++)cin>>X[i]>>Y[i];\n\t\twhile(!(X[0]>X[1]&&Y[0]>Y[3]))\n\t\t{\n\t\t\tint a=X[0],b=Y[0];\n\t\t\tfor(int i=0;i<3;i++)X[i]=X[i+1],Y[i]=Y[i+1];\n\t\t\tX[3]=a,Y[3]=b;\n\t\t}\n\t\tx[n]=x[0],y[n]=y[0];\n\t\tans=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(x[i]==x[i-1])\n\t\t\t{\n\t\t\t\tif(X[3]<x[i])\n\t\t\t\t{\n\t\t\t\t\tif(y[i]>Y[3])\n\t\t\t\t\t{\n\t\t\t\t\t\tlong long L=x[i]-X[3],nowy=y[i-1];\n\t\t\t\t\t\tif(nowy<Y[3])nowy=Y[3];\n\t\t\t\t\t\tans+=(y[i]-nowy)*L;\n\t\t\t\t\t}\n\t\t\t\t\telse if(y[i-1]>Y[3])\n\t\t\t\t\t{\n\t\t\t\t\t\tlong long L=x[i]-X[3],nowy=y[i];\n\t\t\t\t\t\tif(nowy<Y[3])nowy=Y[3];\n\t\t\t\t\t\tans+=(nowy-y[i-1])*L;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(x[i]<X[1])\n\t\t\t\t{\n\t\t\t\t\tif(y[i]<Y[1])\n\t\t\t\t\t{\n\t\t\t\t\t\tlong long L=x[i]-X[1],nowy=y[i-1];\n\t\t\t\t\t\tif(nowy>Y[1])nowy=Y[1];\n\t\t\t\t\t\tans+=(y[i]-nowy)*L;\n\t\t\t\t\t}\n\t\t\t\t\telse if(y[i-1]<Y[1])\n\t\t\t\t\t{\n\t\t\t\t\t\tlong long L=x[i]-X[1],nowy=y[i];\n\t\t\t\t\t\tif(nowy>Y[1])nowy=Y[1];\n\t\t\t\t\t\tans+=(nowy-y[i-1])*L;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(Y[0]<y[i])\n\t\t\t\t{\n\t\t\t\t\tif(x[i]<X[0])\n\t\t\t\t\t{\n\t\t\t\t\t\tlong long L=y[i]-Y[0],nowx=x[i-1];\n\t\t\t\t\t\tif(nowx>X[0])nowx=X[0];\n\t\t\t\t\t\tans+=(nowx-x[i])*L;\n\t\t\t\t\t}\n\t\t\t\t\telse if(x[i-1]<X[0])\n\t\t\t\t\t{\n\t\t\t\t\t\tlong long L=y[i]-Y[0],nowx=x[i];\n\t\t\t\t\t\tif(nowx>X[0])nowx=X[0];\n\t\t\t\t\t\tans+=(x[i-1]-nowx)*L;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(y[i]<Y[2])\n\t\t\t\t{\n\t\t\t\t\tif(x[i]>X[2])\n\t\t\t\t\t{\n\t\t\t\t\t\tlong long L=y[i]-Y[2],nowx=x[i-1];\n\t\t\t\t\t\tif(nowx<X[2])nowx=X[2];\n\t\t\t\t\t\tans+=(nowx-x[i])*L;\n\t\t\t\t\t}\n\t\t\t\t\telse if(x[i-1]>X[2])\n\t\t\t\t\t{\n\t\t\t\t\t\tlong long L=y[i]-Y[2],nowx=x[i];\n\t\t\t\t\t\tif(nowx<X[2])nowx=X[2];\n\t\t\t\t\t\tans+=(x[i-1]-nowx)*L;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1e9)\nint main(){\n  while(1){\n    int N;\n    int x[100],y[100];\n    vector<int> X,Y;\n    int ax=INF,bx=-INF;\n    int ay=INF,by=-INF;\n     \n    scanf(\"%d\",&N);\n    if(N==0)break;\n    for(int i=0;i<N;i++){\n      scanf(\"%d %d\",&x[i],&y[i]);\n      X.push_back(x[i]);\n      Y.push_back(y[i]);\n    }\n    for(int i=0;i<4;i++){\n      int px,py;\n      cin>>px>>py;\n      ax=min(ax,px);\n      ay=min(ay,py);\n      bx=max(bx,px);\n      by=max(by,py);\n    }\n    X.push_back(ax);\n    Y.push_back(ay);\n    X.push_back(bx);\n    Y.push_back(by);\n     \n    sort(X.begin(),X.end());\n    sort(Y.begin(),Y.end());\n    X.erase( unique( X.begin(), X.end() ), X.end() );\n    Y.erase( unique( Y.begin(), Y.end() ), Y.end() );\n     \n    for(int i=0;i<N;i++){\n      x[i]=lower_bound(X.begin(),X.end(),x[i])-X.begin();\n      y[i]=lower_bound(Y.begin(),Y.end(),y[i])-Y.begin();\n    }\n    ax=lower_bound(X.begin(),X.end(),ax)-X.begin();\n    ay=lower_bound(Y.begin(),Y.end(),ay)-Y.begin();\n    bx=lower_bound(X.begin(),X.end(),bx)-X.begin();\n    by=lower_bound(Y.begin(),Y.end(),by)-Y.begin();\n    vector<int> G[300];\n    for(int i=0;i<N;i++){\n      int px=x[i],py=y[i];\n      int qx=x[ (i+1)%N ];\n      int qy=y[ (i+1)%N ];\n      if(qy!=py)continue;\n      G[py].push_back( min(px,qx) );\n      G[py].push_back( max(px,qx) );\n    }\n \n    int t[300]={};\n     \n    long long ans=0;\n    for(int py=0;py+1<(int)Y.size();py++){\n      for(int i=0;i<(int)G[py].size();i+=2){\n        int ax=G[py][i];\n        int bx=G[py][i+1];\n        for(int px=ax;px<bx;px++){\n          t[px]=1-t[px];\n        }\n      }\n      for(int px=0;px+1<(int)X.size();px++){\n        if(t[px]==0)continue;\n        if(ax<=px&&px<bx&&ay<=py&&py<by)continue;\n        long long dy=Y[py+1]-Y[py];\n        long long dx=X[px+1]-X[px];\n        ans+=dy*dx;\n      }\n    }\n    printf(\"%lld\\n\",ans);\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\nint main(){\n    ll n;\n    while(cin>>n){\n        if(n==0){break;}\n    vector<pll> A(n);\n    const ll C=30000;\n    for(auto &I:A){cin>>I.F>>I.S; I.S+=C;}\n    vector<pair<pair<ll,ll>,pll>> B;\n    for(int i=1;i<=n;i++){\n        if(A[i%n].F==A[i-1].F){\n            if(A[i-1].S<A[i%n].S){B.push_back({{A[i%n].F,3},{A[i-1].S,A[i%n].S}});}\n            else{B.push_back({{A[i%n].F,2},{A[i%n].S,A[i-1].S}});}\n        }\n    }\n    vector<pll> S(4);\n    for(auto &I:S){cin>>I.F>>I.S; I.S+=C;}\n    for(int i=1;i<=4;i++){\n        if(S[i%4].F==S[i-1].F){\n            if(S[i-1].S<S[i%4].S){B.push_back({{S[i%4].F,1},{S[i-1].S,S[i%4].S}});}\n            else{B.push_back({{S[i%4].F,0},{S[i%4].S,S[i-1].S}});}\n        }\n    }\n    sort(B.begin(),B.end());\n    vector<bool> in(2*C,false);\n    vector<bool> sq(2*C,false);\n    ll bef=-E;\n    ll ans=0;\n    for(auto &I:B){\n        for(int i=0;i<2*C;i++){\n            if(in[i] && !sq[i]){ans+=I.F.F-bef;}\n        }\n        if(I.F.S>>1&1){\n            for(ll i=I.S.F;i<I.S.S;i++){in[i]=!in[i];}\n        }\n        else{\n            for(ll i=I.S.F;i<I.S.S;i++){sq[i]=!sq[i];}\n        }\n        bef=I.F.F;\n        //cout<<bef<<\" \"<<ans<<endl;\n    }\n    cout<<ans<<endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\ntypedef long double ld;\nconst ld EPS = 1e-9;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine() {};\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; ld r;\n\tCircle() {};\n\tCircle(Point a, ld b) :p(a), r(b) {};\n};\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tld r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2, 0)*projection(l, p) - p;\n}\n\nld dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tld a = cross(s.b - s.a, t.b - t.a);\n\tld b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tld dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tld d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r > EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tld d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tld len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\nint contains(Polygon g, Point p)\n{\n\tbool f = false;\n\tREP(i, g.size())\n\t{\n\t\tPoint a = g[i] - p, b = g[(i + 1) % g.size()] - p;\n\t\tif (abs(cross(a, b)) < EPS&&dot(a, b) < EPS) return 0; //ON\n\t\tif (a.imag() > b.imag()) swap(a, b);\n\t\tif (a.imag() < EPS&&b.imag() > EPS&&cross(a, b) > EPS) f = !f;\n\t}\n\tif (f) return 1; //IN\n\telse return -1; //OUT\n}\n\n\ntemplate<class T>\nvoid compress(vector<T> v, map<T, int>& zip, vector<T>& unzip)\n{\n\tsort(ALL(v));\n\tv.erase(unique(ALL(v)), v.end());\n\tunzip.resize(v.size());\n\tREP(i, v.size())\n\t{\n\t\tzip[v[i]] = i;\n\t\tunzip[i] = v[i];\n\t}\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n; \n\twhile (cin >> n, n)\n\t{\n\t\tvi x, y;\n\t\tREP(i, n + 4)\n\t\t{\n\t\t\tint a, b; cin >> a >> b;\n\t\t\tx.push_back(a);\n\t\t\ty.push_back(b);\n\t\t}\n\t\tmap<int, int> xzip, yzip;\n\t\tvi xunzip, yunzip;\n\t\tcompress(x, xzip, xunzip);\n\t\tcompress(y, yzip, yunzip);\n\t\tPolygon w, c;\n\t\tREP(i, n)\n\t\t{\n\t\t\tPoint p(xzip[x[i]], yzip[y[i]]);\n\t\t\tw.push_back(p);\n\t\t}\n\t\tFOR(i, n, n + 4)\n\t\t{\n\t\t\tPoint p(xzip[x[i]], yzip[y[i]]);\n\t\t\tc.push_back(p);\n\t\t}\n\t\tll ans = 0;\n\t\tREP(i, xunzip.size() - 1)REP(j, yunzip.size() - 1)\n\t\t{\n\t\t\tPoint p(i + 0.5, j + 0.5);\n\t\t\tif (contains(w, p) == 1 && contains(c, p) == -1)\n\t\t\t{\n\t\t\t\tll hei = xunzip[i + 1] - xunzip[i];\n\t\t\t\tll wid = yunzip[j + 1] - yunzip[j];\n\t\t\t\tans += hei * wid;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=2005,INF=1<<30;\n\nconst double eps=1e-10;\nconst double pi=acos((long double)-1.0L);\n#define equals(a,b) (fabs((a)-(b))<eps)\n\ndouble torad(int deg) {return (double)(deg)*pi/180.0;}\ndouble todeg(double ang) {return ang*180.0/pi;}\n\nclass Point{\npublic:\n    double x,y;\n    \n    Point(double x=0,double y=0):x(x),y(y){}\n    \n    Point operator + (Point p){return Point(x+p.x,y+p.y);}\n    Point operator - (Point p){return Point(x-p.x,y-p.y);}\n    Point operator * (double a){return Point(a*x,a*y);}\n    Point operator / (double a){return Point(x/a,y/a);}\n    \n    double abs(){return sqrt(norm());}\n    double norm(){return x*x+y*y;}\n    \n    bool operator < (const Point &p)const{\n        return x+eps<p.x||(equals(x,p.x)&&y+eps<p.y);\n    }\n    \n    bool operator == (const Point &p)const{\n        return fabs(x-p.x)<eps&&fabs(y-p.y)<eps;\n    }\n};\n\ntypedef Point Vector;\n\ndouble norm(Vector a){\n    return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a){\n    return sqrt(norm(a));\n}\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\nstruct Segment{\n    Point p1,p2;\n};\n\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n    return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n    return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\nstatic const int counter_clockwise=1;\nstatic const int clockwise=-1;\nstatic const int online_back=2;\nstatic const int online_front=-2;\nstatic const int on_segment=0;\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    \n    if(cross(a,b)>eps) return counter_clockwise;\n    if(cross(a,b)<-eps) return clockwise;\n    if(dot(a,b)<-eps) return online_back;\n    if(a.norm()<b.norm()) return online_front;\n    \n    return on_segment;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return(ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ntypedef Segment Line;\n\ndouble getDistance(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0) return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0) return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2)) return 0.0;\n    return min({getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2),getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)});\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n    if(ccw(s1.p1,s1.p2,s2.p1)==0&&ccw(s1.p1,s1.p2,s2.p2)==0) return s1.p1;\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}//同じ時壊れます\n\n\nclass Circle{\npublic:\n    Point c;\n    double r;\n    Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\nPoint CircleCenter(Point a,Point b,Point c){\n    Point u=a-b,v=a-c;\n    double m1=(norm(a)-norm(b))/2.0,m2=(norm(a)-norm(c))/2.0;\n    \n    Point res;\n    if(cross(u,v)==0.0){\n        res.x=1e9;\n        res.y=1e9;\n        \n        return res;\n    }\n    res.x=(m1*v.y-m2*u.y)/cross(u,v);\n    res.y=(m1*v.x-m2*u.x)/cross(v,u);\n    \n    return res;\n}\n\npair<Point,Point> segCrossPpoints(Circle c,Line l){\n    //assert(intersect(c,l));\n    Vector pr=project(l,c.c);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(c.r*c.r-norm(pr-c.c));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\ndouble arg(Vector p){return atan2(p.y,p.x);}\nVector polar(double a,double r){return Point(cos(r)*a,sin(r)*a);}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    //assert(intersect(c1,c2));\n    double d=abs(c1.c-c2.c);\n    double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    double t=arg(c2.c-c1.c);\n    return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\ntypedef vector<Point> Polygon;\n\n/*\n IN 2\n ON 1\n OUT 0\n */\n\nint contains(Polygon g,Point p){\n    int n=int(g.size());\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=g[(i+1)%n]-p;\n        if(a.y>b.y) swap(a,b);\n        if(a.y<eps&&eps<b.y&&cross(a,b)>eps) x=!x;\n    }\n    return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s,bool ok){\n    Polygon u,l;\n    sort(all(s));\n    \n    if(int(s.size())<3) return s;\n    int n=int(s.size());\n    \n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    \n    l.push_back(s[n-1]);\n    l.push_back(s[n-2]);\n    \n    if(ok){\n        for(int i=2;i<n;i++){\n            for(int j=int(u.size());j>=2&&ccw(u[j-2],u[j-1],s[i])==counter_clockwise;j--){\n                u.pop_back();\n            }\n            u.push_back(s[i]);\n        }\n        \n        for(int i=int(s.size())-3;i>=0;i--){\n            for(int j=int(l.size());j>=2&&ccw(l[j-2],l[j-1],s[i])==counter_clockwise;j--){\n                l.pop_back();\n            }\n            l.push_back(s[i]);\n        }\n    }\n    \n    if(!ok){\n        for(int i=2;i<n;i++){\n            for(int j=int(u.size());j>=2&&ccw(u[j-2],u[j-1],s[i])!=clockwise;j--){\n                u.pop_back();\n            }\n            u.push_back(s[i]);\n        }\n        \n        for(int i=int(s.size())-3;i>=0;i--){\n            for(int j=int(l.size());j>=2&&ccw(l[j-2],l[j-1],s[i])!=clockwise;j--){\n                l.pop_back();\n            }\n            l.push_back(s[i]);\n        }\n    }\n    \n    reverse(all(l));\n    \n    for(int i=int(u.size())-2;i>=1;i--) l.push_back(u[i]);\n    \n    return l;\n}//ok==1なら辺の上も含める\n\nPolygon convex_cut(const Polygon& P, const Line& l) {\n    Polygon Q;\n    for(int i=0;i<si(P);i++){\n        Point A=P[i],B=P[(i+1)%si(P)];\n        if(ccw(l.p1,l.p2,A)!=-1)Q.push_back(A);\n        if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0) Q.push_back(getCrossPoint(Line{A,B},l));\n    }\n    return Q;\n}\n\ndouble area(Point a,Point b,Point c){\n    b=b-a;\n    c=c-a;\n    return abs(b.x*c.y-b.y*c.x)/2.0;\n}\n\ndouble area(Polygon &P){\n    if(si(P)==0) return 0.0;\n    double res=0;\n    Point c={0.0,0.0};\n    for(int i=0;i<si(P);i++){\n        c=c+P[i];\n    }\n    c=c/si(P);\n    \n    for(int i=0;i<si(P);i++){\n        res+=area(c,P[i],P[(i+1)%si(P)]);\n    }\n    \n    return res;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int N;cin>>N;\n        if(N==0) break;\n        \n        map<ll,int> MX,MY;\n        \n        vector<Point> P(N),Q(4);\n        vector<ll> x,y;\n        for(int i=0;i<N;i++){\n            cin>>P[i].x>>P[i].y;\n            MX[P[i].x]=1;\n            MY[P[i].y]=1;\n        }\n        for(int i=0;i<4;i++){\n            cin>>Q[i].x>>Q[i].y;\n            MX[Q[i].x]=1;\n            MY[Q[i].y]=1;\n        }\n        \n        int idx=0,idy=0;\n        for(auto &a:MX){\n            a.se=idx;\n            x.push_back(a.fi);\n            idx++;\n        }\n        for(auto &a:MY){\n            a.se=idy;\n            y.push_back(a.fi);\n            idy++;\n        }\n        \n        ll ans=0;\n        \n        for(auto xx:MX){\n            for(auto yy:MY){\n                Point p={xx.fi+0.5,yy.fi+0.5};\n                if(contains(Q,p)) continue;\n                Line l={p,p+Point{0,100000}};\n                \n                int cnt=0;\n                \n                for(int i=0;i<N;i++){\n                    if(intersect(l,Segment{P[i],P[(i+1)%N]})) cnt++;\n                }\n                \n                if(cnt&1){\n                    ans+=(x[xx.se+1]-x[xx.se])*(y[yy.se+1]-y[yy.se]);\n                }\n            }\n        }\n        \n        cout<<ans<<endl;\n        \n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; ++i)\nusing namespace std;\n\nusing state = tuple<int,int>;\n\nint main(void){\n\n\tint n;\n\twhile(cin >> n,n){\n\n\t\tvector<int> x(n),y(n);\n\t\trep(i,n) cin >> x[i] >> y[i];\n\t\tvector<int> a(4),b(4);\n\t\trep(i,4) cin >> a[i] >> b[i];\n\t\n\t\tconst int offset = 20000;\n\t\tconst int total = 40010;\n\t\tvector<state> events[total];\n\n\t\trep(i,n){\n\t\t\tconst int cur = i;\n\t\t\tconst int nxt = (i+1)%n;\n\t\t\tif(x[cur]==x[nxt]){\n\t\t\t\tint ly = y[cur], uy = y[nxt];\n\t\t\t\tif(ly > uy) swap(ly,uy);\n\t\t\t\tevents[x[cur]+offset].push_back(state(ly,uy));\n\t\t\t}\n\t\t}\n\n\t\tconst int from = min({a[0],a[1],a[2],a[3]});\n\t\tconst int to = max({a[0],a[1],a[2],a[3]});\n\n\n\t\tconst int bl = min({b[0],b[1],b[2],b[3]});\n\t\tconst int bu = max({b[0],b[1],b[2],b[3]});\n\t\t\n\t\t//cerr << \"Range: \" << from << \" \" << to << endl;\n\t\t//cerr << \"Range: \" << bl << \" \" << bu << endl;\n\t\t\n\n\t\tint ans = 0LL, cur = 0; \n\t\tset<state> s;\n\n\t\trep(i,total){\n\t\t\tconst int cx = i - offset;\n\t\t\tbool change = false;\n\n\t\t\tfor(auto &e:events[i]){\n\t\t\t\tchange = true;\n\t\t\t\tif(s.find(e)!=end(s)){\n\t\t\t\t\ts.erase(e);\n\t\t\t\t}else{\n\t\t\t\t\ts.insert(e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(cx == from or cx == to) change = true;\n\n\t\t\tif(change){\n\t\t\t\tvector<int> imos(total,0);\n\n\t\t\t\tfor(auto &e:s){\n\t\t\t\t\tint ly,uy;\n\t\t\t\t\ttie(ly,uy) = e; \n\t\t\t\t\timos[ly+offset]++;\n\t\t\t\t\timos[uy+offset]++;\n\t\t\t\t}\n\n\t\t\t\trep(j,total) if(j-1>=0) imos[j] = (imos[j] + imos[j-1]) % 2;\n\n\t\t\t\tcur = 0;\n\t\t\t\trep(j,total){\n\t\t\t\t\tconst int cy = j - offset;\n\t\t\t\t\tif(from <= cx and cx < to and bl <= cy and cy < bu) continue;\n\t\t\t\t\tcur += imos[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += cur;\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAX_N = 1<<16;\n\nclass RSQ2{\npublic:\n  ll n,dat[2*MAX_N-1],td[2*MAX_N-1];\n  //?????????\n  RSQ2(){n=MAX_N,memset(dat,0,sizeof(dat)),memset(td,0,sizeof(td));};\n  \n  //[a,b)????????????x???????????????,query(a,b,x);\n  ll add(int a,int b,ll x,int k=0,int l=0,int r=-1){\n    if(r==-1) r=n;\n    if(r<=a||b<=l)return 0;\n    if(a<=l&&r<=b){\n      dat[k]+=(r-l)*x; \n      td[k]+=x;\n      return dat[k];\n    }\n\n    dat[k]+=(min(r,b)-max(l,a))*x;\n    ll kl=k*2+1,kr=k*2+2,t=td[k]*(r-l)/2;\n    dat[kl]+=t, dat[kr]+=t;\n    td[kl]+=td[k], td[kr]+=td[k];\n    td[k]=0;\n\n    ll vl=add(a,b,x,k*2+1,l,(l+r)/2);\n    ll vr=add(a,b,x,k*2+2,(l+r)/2,r);\n    return vl+vr;\n  }\n  \n  //[a,b)??????????????????\n  ll sum(int a,int b){return a>=b? 0:add(a,b,0);}\n};\n\n\nstruct data{int l,r;};\nstruct P{int x,y;};\nconst int Base=30000;\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<vector<data> > LR(MAX_N);\n    vector<P> A(n);\n    for(int i=0;i<n;i++)cin>>A[i].x>>A[i].y,A[i].x+=Base,A[i].y+=Base;\n    for(int i=0;i<n;i++)\n      if(A[i].y==A[(i+1)%n].y)\n\tLR[A[i].y].push_back((data){A[i].x,A[(i+1)%n].x});\n    \n    map <int,data> C;\n    A.resize(4);\n    for(int i=0;i<4;i++)cin>>A[i].x>>A[i].y,A[i].x+=Base,A[i].y+=Base;\n    for(int i=0;i<4;i++)\n      if(A[i].y==A[(i+1)%4].y)C[A[i].y]=(data){A[i].x,A[(i+1)%4].x};\n    \n    RSQ2 T;\n    ll ans=0;\n    for(int i=0,cl=0,cr=0;i<MAX_N;i++){\n      if(C.count(i)&&!cl&&!cr) cl=C[i].l,cr=C[i].r;\n      else if(C.count(i)) cl=cr=0;\n\n      for(int j=0;j<LR[i].size();j++){\n\tint l = LR[i][j].l,r=LR[i][j].r;\n\tl<r ? T.add(l,r,1): T.add(r,l,-1);\n      }\n      ans+=T.sum(0,cl)+T.sum(cr,T.n);\n    }\n    cout <<ans<<endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2747 Curtain\n// 2018.4.26 bal4u\n\n#include <stdio.h>\n\n// バッファを経ずstdinから数値を得る\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\tif (c == '-') { c = getchar_unlocked();\n\t\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\n#define INF 20002\n\nint x[102], y[102];\n\nint main()\n{\n\tint N, a, b, c, i;\n\tint xmin, xmax, ymin, ymax;\n\tlong long win, cur;\n\n\twhile (N = in()) {\n\t\tfor (i = 0; i < N; i++) x[i] = in(), y[i] = in();\n\t\tx[N] = x[0], y[N] = y[0];\n \n\t\txmin = ymin = INF, xmax = ymax = -INF;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\ta = in(), b = in();\n\t\t\tif (a < xmin) xmin = a;\n\t\t\tif (a > xmax) xmax = a;\n\t\t\tif (b < ymin) ymin = b;\n\t\t\tif (b > ymax) ymax = b;\n\t\t}\n\n\t\twin = cur = 0;\n\t\tfor (i = 0; i < N; i++) if (x[i] == x[i+1]) {\n\t\t\tcur += (long long)x[i] * (y[i]-y[i+1]);\n\t\t\ta = x[i]; if (a > xmax) a = xmax;\n\t\t\tif (xmin > a) a = xmin;\n\t\t\tb = y[i]; if (b > ymax) b = ymax;\n\t\t\tif (ymin > b) b = ymin;\n\t\t\tc = y[i+1]; if (c > ymax) c = ymax;\n\t\t\tif (ymin > c) c = ymin;\n\t\t\twin += (long long)a * (b-c);\n\t\t}\n\t\tprintf(\"%lld\\n\", win-cur);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define max(p,q)((p)>(q)?(p):(q))\n#define min(p,q)((p)<(q)?(p):(q))\n\ntypedef struct Point{long long x,y;}P;\nvoid readpoint(P*p){scanf(\"%lld%lld\",&p->x,&p->y);}\nlong long crossproduct(P p,P q,P o){return (p.x-o.x)*(q.y-o.y)-(p.y-o.y)*(q.x-o.x);}\nlong long area(P*p,int n){\n\t//凸包の点が順に与えられる（向き不問）\n\tlong long s=0;\n\tfor(int i=2;i<n;i++)s+=crossproduct(p[i-1],p[i],p[0]);\n\treturn llabs(s/2);\n}\n\nP p[110];\nP x[5];\nint main(){\n\tint n;\n\twhile(scanf(\"%d\",&n),n){\n\t\tfor(int i=0;i<n;i++)readpoint(p+i);\n\t\tfor(int i=0;i<4;i++)readpoint(x+i);\n\t\tlong long l=min(x[0].x,x[2].x);\n\t\tlong long r=max(x[0].x,x[2].x);\n\t\tlong long d=min(x[0].y,x[2].y);\n\t\tlong long u=max(x[0].y,x[2].y);\n\t\tlong long mado=area(p,n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tp[i].x=max(l,min(r,p[i].x));\n\t\t\tp[i].y=max(d,min(u,p[i].y));\n\t\t}\n\t\tprintf(\"%lld\\n\",mado-area(p,n));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Comparator;\nimport java.util.ArrayList;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Curtain solver = new Curtain();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class Curtain {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n = in.nextInt();\n            List<List<Integer>> edges = new ArrayList<>();\n            for (int i = 0; i < 40000; i++) {\n                edges.add(new ArrayList<>());\n            }\n            while (n != 0) {\n                for (int i = 0; i < 40000; i++) edges.get(i).clear();\n                int sx = in.nextInt() + 20000, sy = in.nextInt() + 20000;\n                int lx = sx, ly = sy;\n                for (int i = 1; i < n; i++) {\n                    int x = in.nextInt() + 20000, y = in.nextInt() + 20000;\n                    if (ly != y && lx == x) {\n                        int min = Math.min(ly, y), max = Math.max(ly, y);\n                        for (int j = min; j < max; j++) {\n                            edges.get(j).add(x);\n                        }\n                    }\n                    lx = x;\n                    ly = y;\n                }\n                if (ly != sy && lx == sx) {\n                    int min = Math.min(ly, sy), max = Math.max(ly, sy);\n                    for (int j = min; j < max; j++) {\n                        edges.get(j).add(lx);\n                    }\n                }\n\n                int miny = 40001, maxy = 0, minx = 40001, maxx = 0;\n                for (int i = 0; i < 4; i++) {\n                    int x = in.nextInt() + 20000, y = in.nextInt() + 20000;\n                    miny = Math.min(miny, y);\n                    maxy = Math.max(maxy, y);\n                    minx = Math.min(minx, x);\n                    maxx = Math.max(maxx, x);\n                }\n\n                //System.out.println(\"(\" + minx + \",\" + miny + \"), (\" + maxx + \",\" + maxy + \")\");\n\n                long ans = 0;\n                for (int i = 0; i < 40000; i++) {\n                    if (edges.get(i).isEmpty()) continue;\n                    List<Integer> es = edges.get(i);\n                    es.sort(Comparator.naturalOrder());\n                    //System.out.println(i + \":\" + es);\n                    if (es.size() % 2 == 1) {\n                        throw new RuntimeException();\n                    }\n                    for (int j = 0; j < es.size(); j += 2) {\n                        int left = es.get(j), right = es.get(j + 1);\n                        if (miny <= i && i < maxy) {\n                            if (right <= minx || maxx <= left) {\n                                ans += right - left;\n                            } else {\n                                int cleft = Math.max(left, minx), cright = Math.min(right, maxx);\n                                ans += (right - left) - Math.max(0, cright - cleft);\n                            }\n                        } else {\n                            ans += right - left;\n                        }\n                    }\n                    //System.out.println(ans);\n                }\n                out.println(ans);\n                n = in.nextInt();\n            }\n        }\n\n    }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n    int wn = 0;\n    for (LineSegment l : list) {\n      if (l.y1 <= y && l.y2 > y) {\n        double vt = (y - l.y1) / (l.y2 - l.y1);\n        if (x < l.x1 + (vt * (l.x2 - l.x1))) {\n          ++wn;\n        }\n      }\n      if (l.y1 > y && l.y2 <= y) {\n        double vt = (y - l.y1) / (l.y2 - l.y1);\n        if (x < (l.x1 + (vt * (l.x2 - l.x1)))) {\n          --wn;\n        }\n      }\n    }\n    return wn > 0;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      TreeSet<Long> setx = new TreeSet<>();\n      TreeSet<Long> sety = new TreeSet<>();\n      long[] x = new long[n];\n      long[] y = new long[n];\n      for (int i = 0; i < n; ++i) {\n        x[i] = ni();\n        y[i] = ni();\n        setx.add(x[i]);\n        sety.add(y[i]);\n      }\n      long[] a = new long[4];\n      long[] b = new long[4];\n      for (int i = 0; i < 4; ++i) {\n        a[i] = ni();\n        b[i] = ni();\n        setx.add(a[i]);\n        sety.add(b[i]);\n      }\n      TreeMap<Long, Integer> encoderX = new TreeMap<>();\n      TreeMap<Long, Integer> encoderY = new TreeMap<>();\n      long[] decoderX = new long[setx.size()];\n      long[] decoderY = new long[sety.size()];\n      {\n        int index = 0;\n        for (Long v : setx) {\n          encoderX.put(v, index);\n          decoderX[index] = v;\n          ++index;\n        }\n      }\n      {\n        int index = 0;\n        for (Long v : sety) {\n          encoderY.put(v, index);\n          decoderY[index] = v;\n          ++index;\n        }\n      }\n      ArrayList<LineSegment> mado = new ArrayList<>();\n      for (int i = 0; i < n; ++i) {\n        int j = (i + 1) % n;\n        int xl = encoderX.get(x[i]);\n        int xr = encoderX.get(x[j]);\n        int yl = encoderY.get(y[i]);\n        int yr = encoderY.get(y[j]);\n        mado.add(new LineSegment(xl, yl, xr, yr));\n      }\n      ArrayList<LineSegment> karten = new ArrayList<>();\n      for (int i = 0; i < 4; ++i) {\n        int j = (i + 1) % 4;\n        int xl = encoderX.get(a[i]);\n        int xr = encoderX.get(a[j]);\n        int yl = encoderY.get(b[i]);\n        int yr = encoderY.get(b[j]);\n        karten.add(new LineSegment(xl, yl, xr, yr));\n      }\n      long sum = 0;\n      for (int i = 0; i < decoderY.length - 1; ++i) {\n        for (int j = 0; j < decoderX.length - 1; ++j) {\n          double my = i + 0.5;\n          double mx = j + 0.5;\n          if (isIn(mado, mx, my) && !isIn(karten, mx, my)) {\n            sum += (decoderX[j + 1] - decoderX[j]) * (decoderY[i + 1] - decoderY[i]);\n          }\n        }\n      }\n      System.out.println(sum);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n    int wn = 0;\n    for (LineSegment l : list) {\n      if (l.y1 <= y && l.y2 > y) {\n        double vt = (y - l.y1) / (l.y2 - l.y1);\n        if (x < l.x1 + (vt * (l.x2 - l.x1))) {\n          ++wn;\n        }\n      } else if (l.y1 > y && l.y2 <= y) {\n        double vt = (y - l.y1) / (l.y2 - l.y1);\n        if (x < (l.x1 + (vt * (l.x2 - l.x1)))) {\n          --wn;\n        }\n      }\n    }\n    return wn > 0;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      TreeSet<Long> setx = new TreeSet<>();\n      TreeSet<Long> sety = new TreeSet<>();\n      long[] x = new long[n];\n      long[] y = new long[n];\n      for (int i = 0; i < n; ++i) {\n        x[i] = ni();\n        y[i] = ni();\n        setx.add(x[i]);\n        sety.add(y[i]);\n      }\n      long[] a = new long[4];\n      long[] b = new long[4];\n      for (int i = 0; i < 4; ++i) {\n        a[i] = ni();\n        b[i] = ni();\n        setx.add(a[i]);\n        sety.add(b[i]);\n      }\n      TreeMap<Long, Integer> encoderX = new TreeMap<>();\n      TreeMap<Long, Integer> encoderY = new TreeMap<>();\n      long[] decoderX = new long[setx.size()];\n      long[] decoderY = new long[sety.size()];\n      {\n        int index = 0;\n        for (Long v : setx) {\n          encoderX.put(v, index);\n          decoderX[index] = v;\n          ++index;\n        }\n      }\n      {\n        int index = 0;\n        for (Long v : sety) {\n          encoderY.put(v, index);\n          decoderY[index] = v;\n          ++index;\n        }\n      }\n      ArrayList<LineSegment> mado = new ArrayList<>();\n      for (int i = 0; i < n; ++i) {\n        int j = (i + 1) % n;\n        int xl = encoderX.get(x[i]);\n        int xr = encoderX.get(x[j]);\n        int yl = encoderY.get(y[i]);\n        int yr = encoderY.get(y[j]);\n        mado.add(new LineSegment(xl, yl, xr, yr));\n      }\n      ArrayList<LineSegment> karten = new ArrayList<>();\n      for (int i = 0; i < 4; ++i) {\n        int j = (i + 1) % 4;\n        int xl = encoderX.get(a[i]);\n        int xr = encoderX.get(a[j]);\n        int yl = encoderY.get(b[i]);\n        int yr = encoderY.get(b[j]);\n        karten.add(new LineSegment(xl, yl, xr, yr));\n      }\n      long sum = 0;\n      for (int i = 0; i < decoderY.length - 1; ++i) {\n        for (int j = 0; j < decoderX.length - 1; ++j) {\n          double my = i + 0.5;\n          double mx = j + 0.5;\n          if (isIn(mado, mx, my) && !isIn(karten, mx, my)) {\n            sum += (decoderX[j + 1] - decoderX[j]) * (decoderY[i + 1] - decoderY[i]);\n          }\n        }\n      }\n      System.out.println(sum);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef compress(used_x)\n\tx_map = {}\n\tused_x.to_a.uniq.sort.each_with_index{|x, i| x_map[x] = i}\n\tx_map\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    used_x = Set.new\n    used_y = Set.new\n    w_points = []\n    n.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        used_y << y\n        w_points << [x, y]\n    end\n\n    x_min = Float::INFINITY\n    x_max = - x_min\n    y_min = Float::INFINITY\n    y_max = - y_min\n\n    4.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        x_max = x if x > x_max\n        x_min = x if x < x_min\n        used_y << y\n        y_max = y if y > y_max\n        y_min = y if y < y_min\n    end\n\n    cx = compress(used_x)\n    cy = compress(used_x)\n\n    v_lines = []\n    (w_points + [w_points[0]]).each_cons(2) do |p1, p2|\n        x1, y1 = p1\n        x2, y2 = p2\n        next if x1 != x2\n        y1, y2 = y2, y1 if y1 > y2\n        v_lines << [cx[x1], cy[y1], cy[y2]]#\n    end\n    v_lines.sort_by!(&:first)\n\n#    a = (0..cx.values.max).map { [0] * (cy.values.max + 1) }\n\n#    (0..cy.values.max).each do |y|\n#        crossed = v_lines.select {|x, y1, y2| y1 <= y && y < y2 }\n#        crossed.each_slice(2) do |l1, l2|\n#            x1, _, _ = l1\n#            x2, _, _ = l2\n#            (x1..x2-1).each do |x|\n#                a[x][y] = 1\n#            end\n#        end\n#    end\n\n#    (cy[y_min]..cy[y_max]-1).each do |y|\n#        (cx[x_min]..cx[x_max]-1).each do |x|\n#            a[x][y] = 0\n#        end\n#    end\n\n#    cx_inv = cx.invert\n#    cy_inv = cy.invert\n\n    s = 0\n#    (0..cy.values.max).each do |y|\n#        (0..cx.values.max).each do |x|\n#            s += (cx_inv[x+1] - cx_inv[x]) * (cy_inv[y+1] - cy_inv[y]) if a[x][y] == 1\n#        end\n#    end\n\n    p s\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef compress(used_x)\n\tx_map = {}\n\tused_x.to_a.uniq.sort.each_with_index{|x, i| x_map[x] = i}\n\tx_map\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    used_x = Set.new\n    used_y = Set.new\n    w_points = []\n    n.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        used_y << y\n        w_points << [x, y]\n    end\n\n    x_min = Float::INFINITY\n    x_max = - x_min\n    y_min = Float::INFINITY\n    y_max = - y_min\n\n    4.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        x_max = x if x > x_max\n        x_min = x if x < x_min\n        used_y << y\n        y_max = y if y > y_max\n        y_min = y if y < y_min\n    end\n\n    cx = compress(used_x)\n    cy = compress(used_x)\n\n#    v_lines = []\n#    (w_points + [w_points[0]]).each_cons(2) do |p1, p2|\n#        x1, y1 = p1\n#        x2, y2 = p2\n#        next if x1 != x2\n#        y1, y2 = y2, y1 if y1 > y2\n#        v_lines << [cx[x1], cy[y1], cy[y2]]\n#    end\n#    v_lines.sort_by! {|x, _, _| x}\n\n#    a = (0..cx.values.max).map { [0] * (cy.values.max + 1) }\n\n#    (0..cy.values.max).each do |y|\n#        crossed = v_lines.select {|x, y1, y2| y1 <= y && y < y2 }\n#        crossed.each_slice(2) do |l1, l2|\n#            x1, _, _ = l1\n#            x2, _, _ = l2\n#            (x1..x2-1).each do |x|\n#                a[x][y] = 1\n#            end\n#        end\n#    end\n\n#    (cy[y_min]..cy[y_max]-1).each do |y|\n#        (cx[x_min]..cx[x_max]-1).each do |x|\n#            a[x][y] = 0\n#        end\n#    end\n\n#    cx_inv = cx.invert\n#    cy_inv = cy.invert\n\n    s = 0\n#    (0..cy.values.max).each do |y|\n#        (0..cx.values.max).each do |x|\n#            s += (cx_inv[x+1] - cx_inv[x]) * (cy_inv[y+1] - cy_inv[y]) if a[x][y] == 1\n#        end\n#    end\n\n    p s\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef compress(used_x)\n\tx_map = {}\n\tused_x.to_a.uniq.sort.each_with_index{|x, i| x_map[x] = i}\n\tx_map\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    used_x = Set.new\n    used_y = Set.new\n    w_points = []\n    n.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        used_y << y\n        w_points << [x, y]\n    end\n\n    x_min = Float::INFINITY\n    x_max = - x_min\n    y_min = Float::INFINITY\n    y_max = - y_min\n\n    4.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        x_max = x if x > x_max\n        x_min = x if x < x_min\n        used_y << y\n        y_max = y if y > y_max\n        y_min = y if y < y_min\n    end\n\n    cx = compress(used_x)\n    cy = compress(used_x)\n\n    v_lines = []\n    (w_points + [w_points[0]]).each_cons(2) do |p1, p2|\n        x1, y1 = p1\n        x2, y2 = p2\n        next if x1 != x2\n        y1, y2 = y2, y1 if y1 > y2\n        v_lines << [cx[x1], cy[y1], cy[y2]]\n    end\n    v_lines.sort_by!(&:first)\n\n    a = (0..cx.values.max).map { [0] * (cy.values.max + 1) }\n\n    (0..cy.values.max).each do |y|\n#        crossed = v_lines.select {|x, y1, y2| y1 <= y && y < y2 }\n#        crossed.each_slice(2) do |l1, l2|\n#            x1, _, _ = l1\n#            x2, _, _ = l2\n#            (x1..x2-1).each do |x|\n#                a[x][y] = 1\n#            end\n#        end\n    end\n\n#    (cy[y_min]..cy[y_max]-1).each do |y|\n#        (cx[x_min]..cx[x_max]-1).each do |x|\n#            a[x][y] = 0\n#        end\n#    end\n\n#    cx_inv = cx.invert\n#    cy_inv = cy.invert\n\n    s = 0\n#    (0..cy.values.max).each do |y|\n#        (0..cx.values.max).each do |x|\n#            s += (cx_inv[x+1] - cx_inv[x]) * (cy_inv[y+1] - cy_inv[y]) if a[x][y] == 1\n#        end\n#    end\n\n    p s\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef compress(used_x)\n\tx_map = {}\n\tused_x.to_a.uniq.sort.each_with_index{|x, i| x_map[x] = i}\n\tx_map\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    used_x = Set.new\n    used_y = Set.new\n    w_points = []\n    n.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        used_y << y\n        w_points << [x, y]\n    end\n\n    x_min = Float::INFINITY\n    x_max = - x_min\n    y_min = Float::INFINITY\n    y_max = - y_min\n\n    4.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        x_max = x if x > x_max\n        x_min = x if x < x_min\n        used_y << y\n        y_max = y if y > y_max\n        y_min = y if y < y_min\n    end\n\n    cx = compress(used_x)\n    cy = compress(used_x)\n\n    v_lines = []\n    (w_points + [w_points[0]]).each_cons(2) do |p1, p2|\n        x1, y1 = p1\n        x2, y2 = p2\n        next if x1 != x2\n        y1, y2 = y2, y1 if y1 > y2\n        v_lines << [cx[x1], cy[y1], cy[y2]]#\n    end\n    v_lines.sort_by!(&:first)\n\n    a = (0..cx.values.max).map { [0] * (cy.values.max + 1) }\n\n    (0..cy.values.max).each do |y|\n#        crossed = v_lines.select {|x, y1, y2| y1 <= y && y < y2 }\n#        crossed.each_slice(2) do |l1, l2|\n#            x1, _, _ = l1\n#            x2, _, _ = l2\n#            (x1..x2-1).each do |x|\n#                a[x][y] = 1\n#            end\n#        end\n    end\n\n#    (cy[y_min]..cy[y_max]-1).each do |y|\n#        (cx[x_min]..cx[x_max]-1).each do |x|\n#            a[x][y] = 0\n#        end\n#    end\n\n#    cx_inv = cx.invert\n#    cy_inv = cy.invert\n\n    s = 0\n#    (0..cy.values.max).each do |y|\n#        (0..cx.values.max).each do |x|\n#            s += (cx_inv[x+1] - cx_inv[x]) * (cy_inv[y+1] - cy_inv[y]) if a[x][y] == 1\n#        end\n#    end\n\n    p s\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef compress(used_x)\n\tx_map = {}\n\tused_x.to_a.uniq.sort.each_with_index{|x, i| x_map[x] = i}\n\tx_map\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    used_x = Set.new\n    used_y = Set.new\n    w_points = []\n    n.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        used_y << y\n        w_points << [x, y]\n    end\n\n    x_min = Float::INFINITY\n    x_max = - x_min\n    y_min = Float::INFINITY\n    y_max = - y_min\n\n    4.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        x_max = x if x > x_max\n        x_min = x if x < x_min\n        used_y << y\n        y_max = y if y > y_max\n        y_min = y if y < y_min\n    end\n\n    cx = compress(used_x)\n    cy = compress(used_x)\n\n    v_lines = []\n    (w_points + [w_points[0]]).each_cons(2) do |p1, p2|\n        x1, y1 = p1\n        x2, y2 = p2\n        next if x1 != x2\n        y1, y2 = y2, y1 if y1 > y2\n        v_lines << [cx[x1], cy[y1], cy[y2]]#\n    end\n    v_lines.sort_by! {|x, _, _| x}\n\n#    a = (0..cx.values.max).map { [0] * (cy.values.max + 1) }\n\n#    (0..cy.values.max).each do |y|\n#        crossed = v_lines.select {|x, y1, y2| y1 <= y && y < y2 }\n#        crossed.each_slice(2) do |l1, l2|\n#            x1, _, _ = l1\n#            x2, _, _ = l2\n#            (x1..x2-1).each do |x|\n#                a[x][y] = 1\n#            end\n#        end\n#    end\n\n#    (cy[y_min]..cy[y_max]-1).each do |y|\n#        (cx[x_min]..cx[x_max]-1).each do |x|\n#            a[x][y] = 0\n#        end\n#    end\n\n#    cx_inv = cx.invert\n#    cy_inv = cy.invert\n\n    s = 0\n#    (0..cy.values.max).each do |y|\n#        (0..cx.values.max).each do |x|\n#            s += (cx_inv[x+1] - cx_inv[x]) * (cy_inv[y+1] - cy_inv[y]) if a[x][y] == 1\n#        end\n#    end\n\n    p s\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef compress(used_x)\n\tx_map = {}\n\tused_x.to_a.uniq.sort.each_with_index{|x, i| x_map[x] = i}\n\tx_map\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    used_x = Set.new\n    used_y = Set.new\n    w_points = []\n    n.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        used_y << y\n        w_points << [x, y]\n    end\n\n    x_min = Float::INFINITY\n    x_max = - x_min\n    y_min = Float::INFINITY\n    y_max = - y_min\n\n    4.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        x_max = x if x > x_max\n        x_min = x if x < x_min\n        used_y << y\n        y_max = y if y > y_max\n        y_min = y if y < y_min\n    end\n\n    cx = compress(used_x)\n    cy = compress(used_y)\n\n    v_lines = []\n    (w_points + [w_points[0]]).each_cons(2) do |p1, p2|\n        x1, y1 = p1\n        x2, y2 = p2\n        next if x1 != x2\n        y1, y2 = y2, y1 if y1 > y2\n        v_lines << [cx[x1], cy[y1], cy[y2]]\n    end\n    v_lines.sort_by!(&:first)\n\n    a = (0..cx.values.max).map { [0] * (cy.values.max + 1) }\n\n    (0..cy.values.max).each do |y|\n        crossed = v_lines.select {|x, y1, y2| y1 <= y && y < y2 }\n        crossed.each_slice(2) do |l1, l2|\n            x1, _, _ = l1\n            x2, _, _ = l2\n            (x1..x2-1).each do |x|\n                a[x][y] = 1\n            end\n        end\n    end\n\n    (cy[y_min]..cy[y_max]-1).each do |y|\n        (cx[x_min]..cx[x_max]-1).each do |x|\n            a[x][y] = 0\n        end\n    end\n\n    cx_inv = cx.invert\n    cy_inv = cy.invert\n\n    s = 0\n    (0..cy.values.max).each do |y|\n        (0..cx.values.max).each do |x|\n            s += (cx_inv[x+1] - cx_inv[x]) * (cy_inv[y+1] - cy_inv[y]) if a[x][y] == 1\n        end\n    end\n\n    p s\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef compress(used_x)\n\tx_map = {}\n\tused_x.to_a.uniq.sort.each_with_index{|x, i| x_map[x] = i}\n\tx_map\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    used_x = Set.new\n    used_y = Set.new\n    w_points = []\n    n.times do\n        x, y = gets.split.map(&:to_i)\n        usedLL_x << x\n        used_y << y\n        w_points << [x, y]\n    end\n\n    x_min = Float::INFINITY\n    x_max = - x_min\n    y_min = Float::INFINITY\n    y_max = - y_min\n\n    4.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        x_max = x if x > x_max\n        x_min = x if x < x_min\n        used_y << y\n        y_max = y if y > y_max\n        y_min = y if y < y_min\n    end\n\n    cx = compress(used_x)\n    cy = compress(used_x)\n\n    v_lines = []\n    (w_points + [w_points[0]]).each_cons(2) do |p1, p2|\n        x1, y1 = p1\n        x2, y2 = p2\n        next if x1 != x2\n        y1, y2 = y2, y1 if y1 > y2\n        v_lines << [cx[x1], cy[y1], cy[y2]]\n    end\n    v_lines.sort_by! {|x, _, _| x}\n\n    a = (0..cx.values.max).map { [0] * (cy.values.max + 1) }\n\n    (0..cy.values.max).each do |y|\n        crossed = v_lines.select {|x, y1, y2| y1 <= y && y < y2 }\n        crossed.each_slice(2) do |l1, l2|\n            x1, _, _ = l1\n            x2, _, _ = l2\n            (x1..x2-1).each do |x|\n                a[x][y] = 1\n            end\n        end\n    end\n\n    (cy[y_min]..cy[y_max]-1).each do |y|\n        (cx[x_min]..cx[x_max]-1).each do |x|\n            a[x][y] = 0\n        end\n    end\n\n    cx_inv = cx.invert\n    cy_inv = cy.invert\n\n    s = 0\n    (0..cy.values.max).each do |y|\n        (0..cx.values.max).each do |x|\n            s += (cx_inv[x+1] - cx_inv[x]) * (cy_inv[y+1] - cy_inv[y]) if a[x][y] == 1\n        end\n    end\n\n    p s\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef compress(used_x)\n\tx_map = {}\n\tused_x.to_a.uniq.sort.each_with_index{|x, i| x_map[x] = i}\n\tx_map\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    used_x = Set.new\n    used_y = Set.new\n    w_points = []\n    n.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        used_y << y\n        w_points << [x, y]\n    end\n\n    x_min = Float::INFINITY\n    x_max = - x_min\n    y_min = Float::INFINITY\n    y_max = - y_min\n\n    4.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        x_max = x if x > x_max\n        x_min = x if x < x_min\n        used_y << y\n        y_max = y if y > y_max\n        y_min = y if y < y_min\n    end\n\n    cx = compress(used_x)\n    cy = compress(used_x)\n\n    v_lines = []\n    (w_points + [w_points[0]]).each_cons(2) do |p1, p2|\n        x1, y1 = p1\n        x2, y2 = p2\n        next if x1 != x2\n        y1, y2 = y2, y1 if y1 > y2\n        v_lines << [cx[x1], cy[y1], cy[y2]]\n    end\n    v_lines.sort_by!(&:first)\n\n    a = (0..cx.values.max).map { [0] * (cy.values.max + 1) }\n\n    (0..cy.values.max).each do |y|\n        crossed = v_lines.select {|x, y1, y2| y1 <= y && y < y2 }\n        crossed.each_slice(2) do |l1, l2|\n            x1, _, _ = l1\n            x2, _, _ = l2\n#            (x1..x2-1).each do |x|\n#                a[x][y] = 1\n            end\n        end\n    end\n\n#    (cy[y_min]..cy[y_max]-1).each do |y|\n#        (cx[x_min]..cx[x_max]-1).each do |x|\n#            a[x][y] = 0\n#        end\n#    end\n\n#    cx_inv = cx.invert\n#    cy_inv = cy.invert\n\n    s = 0\n#    (0..cy.values.max).each do |y|\n#        (0..cx.values.max).each do |x|\n#            s += (cx_inv[x+1] - cx_inv[x]) * (cy_inv[y+1] - cy_inv[y]) if a[x][y] == 1\n#        end\n#    end\n\n    p s\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef compress(used_x)\n\tx_map = {}\n\tused_x.to_a.uniq.sort.each_with_index{|x, i| x_map[x] = i}\n\tx_map\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n#    used_x = Set.new\n#    used_y = Set.new\n#    w_points = []\n#    n.times do\n#        x, y = gets.split.map(&:to_i)\n#        used_x << x\n#        used_y << y\n#        w_points << [x, y]\n#    end\n\n#    x_min = Float::INFINITY\n#    x_max = - x_min\n#    y_min = Float::INFINITY\n#    y_max = - y_min\n\n#    4.times do\n#        x, y = gets.split.map(&:to_i)\n#        used_x << x\n#        x_max = x if x > x_max\n#        x_min = x if x < x_min\n#        used_y << y\n#        y_max = y if y > y_max\n#        y_min = y if y < y_min\n#    end\n\n#    cx = compress(used_x)\n#    cy = compress(used_x)\n\n#    v_lines = []\n#    (w_points + [w_points[0]]).each_cons(2) do |p1, p2|\n#        x1, y1 = p1\n#        x2, y2 = p2\n#        next if x1 != x2\n#        y1, y2 = y2, y1 if y1 > y2\n#        v_lines << [cx[x1], cy[y1], cy[y2]]\n#    end\n#    v_lines.sort_by! {|x, _, _| x}\n\n#    a = (0..cx.values.max).map { [0] * (cy.values.max + 1) }\n\n#    (0..cy.values.max).each do |y|\n#        crossed = v_lines.select {|x, y1, y2| y1 <= y && y < y2 }\n#        crossed.each_slice(2) do |l1, l2|\n#            x1, _, _ = l1\n#            x2, _, _ = l2\n#            (x1..x2-1).each do |x|\n#                a[x][y] = 1\n#            end\n#        end\n#    end\n\n#    (cy[y_min]..cy[y_max]-1).each do |y|\n#        (cx[x_min]..cx[x_max]-1).each do |x|\n#            a[x][y] = 0\n#        end\n#    end\n\n#    cx_inv = cx.invert\n#    cy_inv = cy.invert\n\n    s = 0\n#    (0..cy.values.max).each do |y|\n#        (0..cx.values.max).each do |x|\n#            s += (cx_inv[x+1] - cx_inv[x]) * (cy_inv[y+1] - cy_inv[y]) if a[x][y] == 1\n#        end\n#    end\n\n    p s\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef compress(used_x)\n\tx_map = {}\n\tused_x.to_a.uniq.sort.each_with_index{|x, i| x_map[x] = i}\n\tx_map\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    used_x = Set.new\n    used_y = Set.new\n    w_points = []\n    n.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        used_y << y\n        w_points << [x, y]\n    end\n\n    x_min = Float::INFINITY\n    x_max = - x_min\n    y_min = Float::INFINITY\n    y_max = - y_min\n\n    4.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        x_max = x if x > x_max\n        x_min = x if x < x_min\n        used_y << y\n        y_max = y if y > y_max\n        y_min = y if y < y_min\n    end\n\n    cx = compress(used_x)\n    cy = compress(used_x)\n\n    v_lines = []\n    (w_points + [w_points[0]]).each_cons(2) do |p1, p2|\n        x1, y1 = p1\n        x2, y2 = p2\n        next if x1 != x2\n        y1, y2 = y2, y1 if y1 > y2\n        v_lines << [cx[x1], cy[y1], cy[y2]]\n    end\n    v_lines.sort_by! {|x, _, _| x}\n\n    a = (0..cx.values.max).map { [0] * (cy.values.max + 1) }\n\n    (0..cy.values.max).each do |y|\n        crossed = v_lines.select {|x, y1, y2| y1 <= y && y < y2 }\n        crossed.each_slice(2) do |l1, l2|\n            x1, _, _ = l1\n            x2, _, _ = l2\n            (x1..x2-1).each do |x|\n                a[x][y] = 1\n            end\n        end\n    end\n\n    (cy[y_min]..cy[y_max]-1).each do |y|\n        (cx[x_min]..cx[x_max]-1).each do |x|\n            a[x][y] = 0\n        end\n    end\n\n    cx_inv = cx.invert\n    cy_inv = cy.invert\n\n    s = 0\n    (0..cy.values.max).each do |y|\n        (0..cx.values.max).each do |x|\n            s += (cx_inv[x+1] - cx_inv[x]) * (cy_inv[y+1] - cy_inv[y]) if a[x][y] == 1\n        end\n    end\n    p s\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef compress(used_x)\n\tx_map = {}\n\tused_x.to_a.uniq.sort.each_with_index{|x, i| x_map[x] = i}\n\tx_map\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    used_x = Set.new\n    used_y = Set.new\n    w_points = []\n    n.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        used_y << y\n        w_points << [x, y]\n    end\n\n    x_min = Float::INFINITY\n    x_max = - x_min\n    y_min = Float::INFINITY\n    y_max = - y_min\n\n    4.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        x_max = x if x > x_max\n        x_min = x if x < x_min\n        used_y << y\n        y_max = y if y > y_max\n        y_min = y if y < y_min\n    end\n\n    cx = compress(used_x)\n    cy = compress(used_x)\n\n    v_lines = []\n    (w_points + [w_points[0]]).each_cons(2) do |p1, p2|\n        x1, y1 = p1\n        x2, y2 = p2\n        next if x1 != x2\n        y1, y2 = y2, y1 if y1 > y2\n        v_lines << [cx[x1], cy[y1], cy[y2]]\n    end\n    v_lines.sort_by! {|x, _, _| x}\n\n    a = (0..cx.values.max).map { [0] * (cy.values.max + 1) }\n\n    (0..cy.values.max).each do |y|\n        crossed = v_lines.select {|x, y1, y2| y1 <= y && y < y2 }\n        crossed.each_slice(2) do |l1, l2|\n            x1, _, _ = l1\n            x2, _, _ = l2\n            (x1..x2-1).each do |x|\n                a[x][y] = 1\n            end\n        end\n    end\n\n    (cy[y_min]..cy[y_max]-1).each do |y|\n        (cx[x_min]..cx[x_max]-1).each do |x|\n            a[x][y] = 0\n        end\n    end\n\n    cx_inv = cx.invert\n    cy_inv = cy.invert\n\n    s = 0\n    (0..cy.values.max).each do |y|\n        (0..cx.values.max).each do |x|\n            s += (cx_inv[x+1] - cx_inv[x]) * (cy_inv[y+1] - cy_inv[y]) if a[x][y] == 1\n        end\n    end\n\n    p s\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef compress(used_x)\n\tx_map = {}\n\tused_x.to_a.uniq.sort.each_with_index{|x, i| x_map[x] = i}\n\tx_map\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    used_x = Set.new\n    used_y = Set.new\n    w_points = []\n    n.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        used_y << y\n        w_points << [x, y]\n    end\n\n    x_min = Float::INFINITY\n    x_max = - x_min\n    y_min = Float::INFINITY\n    y_max = - y_min\n\n    4.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        x_max = x if x > x_max\n        x_min = x if x < x_min\n        used_y << y\n        y_max = y if y > y_max\n        y_min = y if y < y_min\n    end\n\n    cx = compress(used_x)\n    cy = compress(used_x)\n\n    v_lines = []\n    (w_points + [w_points[0]]).each_cons(2) do |p1, p2|\n        x1, y1 = p1\n        x2, y2 = p2\n        next if x1 != x2\n        y1, y2 = y2, y1 if y1 > y2\n        v_lines << [cx[x1], cy[y1], cy[y2]]\n    end\n    v_lines.sort_by!(&:first)\n\n    a = (0..cx.values.max).map { [0] * (cy.values.max + 1) }\n\n    (0..cy.values.max).each do |y|\n        crossed = v_lines.select {|x, y1, y2| y1 <= y && y < y2 }\n        crossed.each_slice(2) do |l1, l2|\n            x1, _, _ = l1\n            x2, _, _ = l2\n            (x1..x2-1).each do |x|\n#                a[x][y] = 1\n            end\n        end\n    end\n\n#    (cy[y_min]..cy[y_max]-1).each do |y|\n#        (cx[x_min]..cx[x_max]-1).each do |x|\n#            a[x][y] = 0\n#        end\n#    end\n\n#    cx_inv = cx.invert\n#    cy_inv = cy.invert\n\n    s = 0\n#    (0..cy.values.max).each do |y|\n#        (0..cx.values.max).each do |x|\n#            s += (cx_inv[x+1] - cx_inv[x]) * (cy_inv[y+1] - cy_inv[y]) if a[x][y] == 1\n#        end\n#    end\n\n    p s\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef compress(used_x)\n\tx_map = {}\n\tused_x.to_a.uniq.sort.each_with_index{|x, i| x_map[x] = i}\n\tx_map\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    used_x = Set.new\n    used_y = Set.new\n    w_points = []\n    n.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        used_y << y\n        w_points << [x, y]\n    end\n\n#    x_min = Float::INFINITY\n#    x_max = - x_min\n#    y_min = Float::INFINITY\n#    y_max = - y_min\n\n#    4.times do\n#        x, y = gets.split.map(&:to_i)\n#        used_x << x\n#        x_max = x if x > x_max\n#        x_min = x if x < x_min\n#        used_y << y\n#        y_max = y if y > y_max\n#        y_min = y if y < y_min\n#    end\n\n#    cx = compress(used_x)\n#    cy = compress(used_x)\n\n#    v_lines = []\n#    (w_points + [w_points[0]]).each_cons(2) do |p1, p2|\n#        x1, y1 = p1\n#        x2, y2 = p2\n#        next if x1 != x2\n#        y1, y2 = y2, y1 if y1 > y2\n#        v_lines << [cx[x1], cy[y1], cy[y2]]\n#    end\n#    v_lines.sort_by! {|x, _, _| x}\n\n#    a = (0..cx.values.max).map { [0] * (cy.values.max + 1) }\n\n#    (0..cy.values.max).each do |y|\n#        crossed = v_lines.select {|x, y1, y2| y1 <= y && y < y2 }\n#        crossed.each_slice(2) do |l1, l2|\n#            x1, _, _ = l1\n#            x2, _, _ = l2\n#            (x1..x2-1).each do |x|\n#                a[x][y] = 1\n#            end\n#        end\n#    end\n\n#    (cy[y_min]..cy[y_max]-1).each do |y|\n#        (cx[x_min]..cx[x_max]-1).each do |x|\n#            a[x][y] = 0\n#        end\n#    end\n\n#    cx_inv = cx.invert\n#    cy_inv = cy.invert\n\n    s = 0\n#    (0..cy.values.max).each do |y|\n#        (0..cx.values.max).each do |x|\n#            s += (cx_inv[x+1] - cx_inv[x]) * (cy_inv[y+1] - cy_inv[y]) if a[x][y] == 1\n#        end\n#    end\n\n    p s\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef compress(used_x)\n\tx_map = {}\n\tused_x.to_a.uniq.sort.each_with_index{|x, i| x_map[x] = i}\n\tx_map\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    used_x = Set.new\n    used_y = Set.new\n    w_points = []\n    n.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        used_y << y\n        w_points << [x, y]\n    end\n\n    x_min = Float::INFINITY\n    x_max = - x_min\n    y_min = Float::INFINITY\n    y_max = - y_min\n\n    4.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        x_max = x if x > x_max\n        x_min = x if x < x_min\n        used_y << y\n        y_max = y if y > y_max\n        y_min = y if y < y_min\n    end\n\n    cx = compress(used_x)\n    cy = compress(used_y)\n\n    v_lines = []\n    (w_points + [w_points[0]]).each_cons(2) do |p1, p2|\n        x1, y1 = p1\n        x2, y2 = p2\n        next if x1 != x2\n        y1, y2 = y2, y1 if y1 > y2\n        v_lines << [cx[x1], cy[y1], cy[y2]]\n    end\n    v_lines.sort_by!(&:first)\n\n    a = (0..cx.values.max).map { [0] * (cy.values.max + 1) }\n\n    (0..cy.values.max).each do |y|\n        crossed = v_lines.select {|x, y1, y2| y1 <= y && y < y2 }\n        crossed.each_slice(2) do |l1, l2|\n            x1, _, _ = l1\n            x2, _, _ = l2\n            (x1..x2-1).each do |x|\n                a[x][y] = 1\n            end\n        end\n    end\n\n#    (cy[y_min]..cy[y_max]-1).each do |y|\n#        (cx[x_min]..cx[x_max]-1).each do |x|\n#            a[x][y] = 0\n#        end\n#    end\n\n#    cx_inv = cx.invert\n#    cy_inv = cy.invert\n\n    s = 0\n#    (0..cy.values.max).each do |y|\n#        (0..cx.values.max).each do |x|\n#            s += (cx_inv[x+1] - cx_inv[x]) * (cy_inv[y+1] - cy_inv[y]) if a[x][y] == 1\n#        end\n#    end\n\n    p s\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef compress(used_x)\n\tx_map = {}\n\tused_x.to_a.uniq.sort.each_with_index{|x, i| x_map[x] = i}\n\tx_map\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    used_x = Set.new\n    used_y = Set.new\n    w_points = []\n    n.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        used_y << y\n        w_points << [x, y]\n    end\n\n    x_min = Float::INFINITY\n    x_max = - x_min\n    y_min = Float::INFINITY\n    y_max = - y_min\n\n    4.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        x_max = x if x > x_max\n        x_min = x if x < x_min\n        used_y << y\n        y_max = y if y > y_max\n        y_min = y if y < y_min\n    end\n\n    cx = compress(used_x)\n    cy = compress(used_x)\n\n    v_lines = []\n    (w_points + [w_points[0]]).each_cons(2) do |p1, p2|\n        x1, y1 = p1\n        x2, y2 = p2\n        next if x1 != x2\n        y1, y2 = y2, y1 if y1 > y2\n        v_lines << [cx[x1], cy[y1], cy[y2]]\n    end\n    v_lines.sort_by!(&:first)\n\n    a = (0..cx.values.max).map { [0] * (cy.values.max + 1) }\n\n    (0..cy.values.max).each do |y|\n        crossed = v_lines.select {|x, y1, y2| y1 <= y && y < y2 }\n#        crossed.each_slice(2) do |l1, l2|\n#            x1, _, _ = l1\n#            x2, _, _ = l2\n#            (x1..x2-1).each do |x|\n#                a[x][y] = 1\n#            end\n#        end\n    end\n\n#    (cy[y_min]..cy[y_max]-1).each do |y|\n#        (cx[x_min]..cx[x_max]-1).each do |x|\n#            a[x][y] = 0\n#        end\n#    end\n\n#    cx_inv = cx.invert\n#    cy_inv = cy.invert\n\n    s = 0\n#    (0..cy.values.max).each do |y|\n#        (0..cx.values.max).each do |x|\n#            s += (cx_inv[x+1] - cx_inv[x]) * (cy_inv[y+1] - cy_inv[y]) if a[x][y] == 1\n#        end\n#    end\n\n    p s\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef compress(used_x)\n\tx_map = {}\n\tused_x.to_a.uniq.sort.each_with_index{|x, i| x_map[x] = i}\n\tx_map\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    used_x = Set.new\n    used_y = Set.new\n    w_points = []\n    n.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        used_y << y\n        w_points << [x, y]\n    end\n\n    x_min = Float::INFINITY\n    x_max = - x_min\n    y_min = Float::INFINITY\n    y_max = - y_min\n\n    4.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        x_max = x if x > x_max\n        x_min = x if x < x_min\n        used_y << y\n        y_max = y if y > y_max\n        y_min = y if y < y_min\n    end\n\n#    cx = compress(used_x)\n#    cy = compress(used_x)\n\n#    v_lines = []\n#    (w_points + [w_points[0]]).each_cons(2) do |p1, p2|\n#        x1, y1 = p1\n#        x2, y2 = p2\n#        next if x1 != x2\n#        y1, y2 = y2, y1 if y1 > y2\n#        v_lines << [cx[x1], cy[y1], cy[y2]]\n#    end\n#    v_lines.sort_by! {|x, _, _| x}\n\n#    a = (0..cx.values.max).map { [0] * (cy.values.max + 1) }\n\n#    (0..cy.values.max).each do |y|\n#        crossed = v_lines.select {|x, y1, y2| y1 <= y && y < y2 }\n#        crossed.each_slice(2) do |l1, l2|\n#            x1, _, _ = l1\n#            x2, _, _ = l2\n#            (x1..x2-1).each do |x|\n#                a[x][y] = 1\n#            end\n#        end\n#    end\n\n#    (cy[y_min]..cy[y_max]-1).each do |y|\n#        (cx[x_min]..cx[x_max]-1).each do |x|\n#            a[x][y] = 0\n#        end\n#    end\n\n#    cx_inv = cx.invert\n#    cy_inv = cy.invert\n\n    s = 0\n#    (0..cy.values.max).each do |y|\n#        (0..cx.values.max).each do |x|\n#            s += (cx_inv[x+1] - cx_inv[x]) * (cy_inv[y+1] - cy_inv[y]) if a[x][y] == 1\n#        end\n#    end\n\n    p s\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef compress(used_x)\n\tx_map = {}\n\tused_x.to_a.uniq.sort.each_with_index{|x, i| x_map[x] = i}\n\tx_map\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    used_x = Set.new\n    used_y = Set.new\n    w_points = []\n    n.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        used_y << y\n        w_points << [x, y]\n    end\n\n    x_min = Float::INFINITY\n    x_max = - x_min\n    y_min = Float::INFINITY\n    y_max = - y_min\n\n    4.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        x_max = x if x > x_max\n        x_min = x if x < x_min\n        used_y << y\n        y_max = y if y > y_max\n        y_min = y if y < y_min\n    end\n\n    cx = compress(used_x)\n    cy = compress(used_x)\n\n    v_lines = []\n    (w_points + [w_points[0]]).each_cons(2) do |p1, p2|\n        x1, y1 = p1\n        x2, y2 = p2\n        next if x1 != x2\n        y1, y2 = y2, y1 if y1 > y2\n        v_lines << [cx[x1], cy[y1], cy[y2]]\n    end\n    v_lines.sort_by!(&:first)\n\n    a = (0..cx.values.max).map { [0] * (cy.values.max + 1) }\n\n    (0..cy.values.max).each do |y|\n#        crossed = v_lines.select {|x, y1, y2| y1 <= y && y < y2 }\n#        crossed.each_slice(2) do |l1, l2|\n#            x1, _, _ = l1\n#            x2, _, _ = l2\n#            (x1..x2-1).each do |x|\n#                a[x][y] = 1\n#            end\n#        end\n    end\n\n#    (cy[y_min]..cy[y_max]-1).each do |y|\n#        (cx[x_min]..cx[x_max]-1).each do |x|\n#            a[x][y] = 0\n#        end\n#    end\n\n#    cx_inv = cx.invert\n#    cy_inv = cy.invert\n\n    s = 0\n#    (0..cy.values.max).each do |y|\n#        (0..cx.values.max).each do |x|\n#            s += (cx_inv[x+1] - cx_inv[x]) * (cy_inv[y+1] - cy_inv[y]) if a[x][y] == 1\n#        end\n#    end\n\n    p s\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\ndef compress(used_x)\n\tx_map = {}\n\tused_x.to_a.uniq.sort.each_with_index{|x, i| x_map[x] = i}\n\tx_map\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    used_x = Set.new\n    used_y = Set.new\n    w_points = []\n    n.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        used_y << y\n        w_points << [x, y]\n    end\n\n    x_min = Float::INFINITY\n    x_max = - x_min\n    y_min = Float::INFINITY\n    y_max = - y_min\n\n    4.times do\n        x, y = gets.split.map(&:to_i)\n        used_x << x\n        x_max = x if x > x_max\n        x_min = x if x < x_min\n        used_y << y\n        y_max = y if y > y_max\n        y_min = y if y < y_min\n    end\n\n    cx = compress(used_x)\n    cy = compress(used_y)\n\n    v_lines = []\n    (w_points + [w_points[0]]).each_cons(2) do |p1, p2|\n        x1, y1 = p1\n        x2, y2 = p2\n        next if x1 != x2\n        y1, y2 = y2, y1 if y1 > y2\n        v_lines << [cx[x1], cy[y1], cy[y2]]\n    end\n    v_lines.sort_by!(&:first)\n\n    a = (0..cx.values.max).map { [0] * (cy.values.max + 1) }\n\n    (0..cy.values.max).each do |y|\n        crossed = v_lines.select {|x, y1, y2| y1 <= y && y < y2 }\n#        crossed.each_slice(2) do |l1, l2|\n#            x1, _, _ = l1\n#            x2, _, _ = l2\n#            (x1..x2-1).each do |x|\n#                a[x][y] = 1\n#            end\n#        end\n    end\n\n#    (cy[y_min]..cy[y_max]-1).each do |y|\n#        (cx[x_min]..cx[x_max]-1).each do |x|\n#            a[x][y] = 0\n#        end\n#    end\n\n#    cx_inv = cx.invert\n#    cy_inv = cy.invert\n\n    s = 0\n#    (0..cy.values.max).each do |y|\n#        (0..cx.values.max).each do |x|\n#            s += (cx_inv[x+1] - cx_inv[x]) * (cy_inv[y+1] - cy_inv[y]) if a[x][y] == 1\n#        end\n#    end\n\n    p s\nend"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\nstruct Point {\n    int x, y;\n}\n\nvoid main() {\n    while (true) {\n        int N; readf(\"%d\\n\", &N);\n        if (N == 0) break;\n        auto P = new Point[N];\n        auto A = new Point[4];\n        foreach (ref p; P) { readf(\"%d %d\\n\", &p.x, &p.y); }\n        foreach (ref p; A) { readf(\"%d %d\\n\", &p.x, &p.y); }\n        auto X = (P.dup ~ A.dup).map!\"a.x\".array;\n        auto Y = (P.dup ~ A.dup).map!\"a.y\".array;\n\n        X = X.sort.uniq.array;\n        Y = Y.sort.uniq.array;\n        int[int] mX, mY;\n        foreach (i, x; X) mX[x] = i;\n        foreach (i, y; Y) mY[y] = i;\n        auto H = Y.size;\n        auto W = X.size;\n\n        int ax = int.max, ay = int.max, bx = int.min, by = int.min;\n        foreach (a; A) {\n            ax = min(ax, a.x);\n            ay = min(ay, a.y);\n            bx = max(bx, a.x);\n            by = max(by, a.y);\n        }\n        ax = mX[ax]; ay = mY[ay];\n        bx = mX[bx]; by = mY[by];\n\n        int area(int i, int j) {\n            if (i + 1 == H || j + 1 == W) return 0;\n            int sy = Y[i], ty = Y[i + 1];\n            int sx = X[j], tx = X[j + 1];\n            int dy = ty - sy;\n            int dx = tx - sx;\n            return dy * dx;\n        }\n\n        auto D = new int[][](H, W);\n        int n = P.size;\n        for (int i = 0; i < n; i++) {\n            auto p = P[i], q = P[(i + 1) % n];\n            auto s = Point(mX[p.x], mY[p.y]);\n            auto t = Point(mX[q.x], mY[q.y]);\n            if (s.y == t.y) continue;\n            assert(s.x == t.x);\n            int dy = (t.y - s.y) / abs(t.y - s.y);\n            do {\n                int y = s.y + (dy == -1 ? -1 : 0);\n                D[y][s.x] = (dy == -1 ? 1 : -1);\n                s.y += dy;\n            } while (s != t);\n        }\n        long ans = 0;\n        for (int i = 0; i < H; i++) {\n            int d = 0;\n            for (int j = 0; j < W; j++) {\n                d += D[i][j];\n                assert(0 <= d && d <= 1);\n                if (! (ax <= j && j < bx && ay <= i && i < by) ) {\n                    ans += d * area(i, j);\n                }\n            }\n            assert(d == 0);\n        }\n        writeln(ans);\n\n    }\n\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\nstruct Point {\n    int x, y;\n}\n\nvoid main() {\n    while (true) {\n        int N; readf(\"%d\\n\", &N);\n        if (N == 0) break;\n        auto P = new Point[N];\n        auto A = new Point[4];\n        foreach (ref p; P) { readf(\"%d %d\\n\", &p.x, &p.y); }\n        foreach (ref p; A) { readf(\"%d %d\\n\", &p.x, &p.y); }\n        auto X = (P.dup ~ A.dup).map!\"a.x\".array;\n        auto Y = (P.dup ~ A.dup).map!\"a.y\".array;\n\n        X = X.sort.uniq.array;\n        Y = Y.sort.uniq.array;\n        int[int] mX, mY;\n        foreach (int i, x; X) mX[x] = i;\n        foreach (int i, y; Y) mY[y] = i;\n        auto H = Y.size;\n        auto W = X.size;\n\n        int ax = int.max, ay = int.max, bx = int.min, by = int.min;\n        foreach (a; A) {\n            ax = min(ax, a.x);\n            ay = min(ay, a.y);\n            bx = max(bx, a.x);\n            by = max(by, a.y);\n        }\n        ax = mX[ax]; ay = mY[ay];\n        bx = mX[bx]; by = mY[by];\n\n        int area(int i, int j) {\n            if (i + 1 == H || j + 1 == W) return 0;\n            int sy = Y[i], ty = Y[i + 1];\n            int sx = X[j], tx = X[j + 1];\n            int dy = ty - sy;\n            int dx = tx - sx;\n            return dy * dx;\n        }\n\n        auto D = new int[][](H, W);\n        int n = P.size;\n        for (int i = 0; i < n; i++) {\n            auto p = P[i], q = P[(i + 1) % n];\n            auto s = Point(mX[p.x], mY[p.y]);\n            auto t = Point(mX[q.x], mY[q.y]);\n            if (s.y == t.y) continue;\n            assert(s.x == t.x);\n            int dy = (t.y - s.y) / abs(t.y - s.y);\n            do {\n                int y = s.y + (dy == -1 ? -1 : 0);\n                D[y][s.x] = (dy == -1 ? 1 : -1);\n                s.y += dy;\n            } while (s != t);\n        }\n        long ans = 0;\n        for (int i = 0; i < H; i++) {\n            int d = 0;\n            for (int j = 0; j < W; j++) {\n                d += D[i][j];\n                assert(0 <= d && d <= 1);\n                if (! (ax <= j && j < bx && ay <= i && i < by) ) {\n                    ans += d * area(i, j);\n                }\n            }\n            assert(d == 0);\n        }\n        writeln(ans);\n\n    }\n\n}"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nINF = 10**9\nwhile 1:\n    N = int(input())\n    if N == 0:\n        break\n    P = [list(map(int, input().split())) for i in range(N)]\n    S = defaultdict(list)\n    X = set()\n    x0 = y0 = INF; x1 = y1 = -INF\n    for i in range(4):\n        x, y = map(int, input().split())\n        x0 = min(x0, x); x1 = max(x1, x)\n        y0 = min(y0, y); y1 = max(y1, y)\n    S[y0] = [INF]; S[y1] = [INF]\n    X.add(x0); X.add(x1)\n    for x, y in P:\n        S[y].append(x)\n        X.add(x)\n    xs = sorted(X)\n    MP = {x: i for i, x in enumerate(xs)}\n    L = len(xs)\n\n    su = 0\n    for i in range(N):\n        xa, ya = P[i-1]\n        xb, yb = P[i]\n        su += xa*yb - ya*xb\n    su = abs(su) // 2\n    res = 0\n    *ps, = S.items()\n    ps.sort()\n    mode = 0\n    prv = -1\n    U = [0]*L\n    for y, vs in ps:\n        if mode:\n            px = 0; c = 0\n            d = y - prv\n            for i in range(L):\n                if U[i]:\n                    x = min(max(xs[i], x0), x1)\n                    if c == 1:\n                        res += d * (x - px)\n                    c ^= 1\n                    px = x\n        for x in vs:\n            if x == INF:\n                mode ^= 1\n            else:\n                U[MP[x]] ^= 1\n        prv = y\n    print(su - res)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nwhile True:\n    N = input()\n    if N == 0:\n        break\n    lst = []\n    for i in range(N):\n        x, y = map(int, raw_input().split())\n        lst.append((x, y))\n    x0, y0 = lst[0]\n    x_pre, y_pre = lst[0]\n    lst.append((x0, y0))\n    sq_list = []\n    for i in range(1, N):\n        x, y = lst[i]\n        if y != y_pre:\n            flag = ((x > x0) ^ (y > y_pre))\n            sq_list.append((min(x, x0),max(x, x0),min(y, y_pre),max(y, y_pre),flag))\n        x_pre = x\n        y_pre = y\n    sq = []\n    for i in range(4):\n        x, y = map(int, raw_input().split())\n        sq.append((x, y))\n    sq.sort()\n    sq = (sq[0][0], sq[3][0], sq[0][1], sq[3][1])\n    ans = 0\n    for s in sq_list:\n        S = (s[1] - s[0]) * (s[3] - s[2])\n        x1 = max(sq[0], s[0])\n        x2 = min(sq[1], s[1])\n        y1 = max(sq[2], s[2])\n        y2 = min(sq[3], s[3])\n        if y2 - y1 > 0 and x2 - x1 > 0:\n            S -= (y2 - y1) * (x2 - x1)\n        if s[4]:\n            S *= -1\n        ans += S\n    print ans\n\n\n"
  }
]