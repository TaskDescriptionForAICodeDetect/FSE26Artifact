[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define MAX_VERTICES 100\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble cross_product(Point p1, Point p2, Point p3) {\n    return (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);\n}\n\ndouble polygon_area(Point *polygon, int n) {\n    double area = 0.0;\n    for (int i = 0; i < n; i++) {\n        int j = (i + 1) % n;\n        area += polygon[i].x * polygon[j].y - polygon[j].x * polygon[i].y;\n    }\n    return fabs(area) / 2.0;\n}\n\nint point_inside_rectangle(Point p, Point rect[4]) {\n    double area_rect = polygon_area(rect, 4);\n    double total_area = 0.0;\n    \n    for (int i = 0; i < 4; i++) {\n        Point temp[3] = {rect[i], rect[(i+1)%4], p};\n        total_area += fabs(cross_product(temp[0], temp[1], temp[2]) / 2.0);\n    }\n    \n    return fabs(total_area - area_rect) < 1e-9;\n}\n\ndouble clip_polygon(Point *window, int n_window, Point *rect, Point *result) {\n    Point intersection[MAX_VERTICES * 2];\n    int n_intersection = 0;\n    \n    for (int i = 0; i < n_window; i++) {\n        Point curr = window[i];\n        Point next = window[(i + 1) % n_window];\n        \n        if (point_inside_rectangle(curr, rect)) {\n            intersection[n_intersection++] = curr;\n        }\n        \n        for (int j = 0; j < 4; j++) {\n            Point clip_edge_start = rect[j];\n            Point clip_edge_end = rect[(j + 1) % 4];\n            \n            double cross1 = cross_product(clip_edge_start, clip_edge_end, curr);\n            double cross2 = cross_product(clip_edge_start, clip_edge_end, next);\n            \n            if ((cross1 * cross2) < 0) {\n                double t = cross1 / (cross1 - cross2);\n                Point intersect = {\n                    curr.x + t * (next.x - curr.x),\n                    curr.y + t * (next.y - curr.y)\n                };\n                intersection[n_intersection++] = intersect;\n            }\n        }\n    }\n    \n    memcpy(result, intersection, n_intersection * sizeof(Point));\n    return polygon_area(result, n_intersection);\n}\n\nint main() {\n    int datasets;\n    scanf(\"%d\", &datasets);\n    \n    while (datasets--) {\n        int n_window;\n        scanf(\"%d\", &n_window);\n        \n        Point window[MAX_VERTICES];\n        for (int i = 0; i < n_window; i++) {\n            scanf(\"%lf %lf\", &window[i].x, &window[i].y);\n        }\n        \n        Point rect[4];\n        for (int i = 0; i < 4; i++) {\n            scanf(\"%lf %lf\", &rect[i].x, &rect[i].y);\n        }\n        \n        Point clipped[MAX_VERTICES * 2];\n        double uncovered_area = polygon_area(window, n_window) - clip_polygon(window, n_window, rect, clipped);\n        \n        printf(\"%d\\n\", (int)round(uncovered_area));\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:56:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    Point p1, p2;\n} Rect;\n\nint min(int a, int b) { return a < b ? a : b; }\nint max(int a, int b) { return a > b ? a : b; }\n\nint cross(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\nint areaPolygon(Point *poly, int n) {\n    int area = 0;\n    for (int i = 0; i < n; i++) {\n        int j = (i + 1) % n;\n        area += poly[i].x * poly[j].y - poly[j].x * poly[i].y;\n    }\n    return abs(area) / 2;\n}\n\nint pointInRect(Point p, Rect r) {\n    return p.x >= min(r.p1.x, r.p2.x) && p.x <= max(r.p1.x, r.p2.x) &&\n           p.y >= min(r.p1.y, r.p2.y) && p.y <= max(r.p1.y, r.p2.y);\n}\n\nint lineIntersects(Point a1, Point a2, Point b1, Point b2) {\n    int c1 = cross(a1, a2, b1);\n    int c2 = cross(a1, a2, b2);\n    int c3 = cross(b1, b2, a1);\n    int c4 = cross(b1, b2, a2);\n    \n    if (((c1 > 0 && c2 < 0) || (c1 < 0 && c2 > 0)) &&\n        ((c3 > 0 && c4 < 0) || (c3 < 0 && c4 > 0))) {\n        return 1;\n    }\n    return 0;\n}\n\nPoint computeIntersection(Point a1, Point a2, Point b1, Point b2) {\n    int A1 = a2.y - a1.y;\n    int B1 = a1.x - a2.x;\n    int C1 = A1 * a1.x + B1 * a1.y;\n    \n    int A2 = b2.y - b1.y;\n    int B2 = b1.x - b2.x;\n    int C2 = A2 * b1.x + B2 * b1.y;\n    \n    int det = A1 * B2 - A2 * B1;\n    Point p;\n    p.x = (B2 * C1 - B1 * C2) / det;\n    p.y = (A1 * C2 - A2 * C1) / det;\n    return p;\n}\n\nint clipPolygon(Point *poly, int n, Rect r, Point *result) {\n    Point clipPoly[4] = {\n        {min(r.p1.x, r.p2.x), min(r.p1.y, r.p2.y)},\n        {max(r.p1.x, r.p2.x), min(r.p1.y, r.p2.y)},\n        {max(r.p1.x, r.p2.x), max(r.p1.y, r.p2.y)},\n        {min(r.p1.x, r.p2.x), max(r.p1.y, r.p2.y)}\n    };\n    \n    int resultSize = n;\n    Point *input = (Point *)malloc(n * sizeof(Point));\n    for (int i = 0; i < n; i++) input[i] = poly[i];\n    \n    for (int clipEdge = 0; clipEdge < 4; clipEdge++) {\n        Point a = clipPoly[clipEdge];\n        Point b = clipPoly[(clipEdge + 1) % 4];\n        \n        Point *output = (Point *)malloc(resultSize * sizeof(Point));\n        int outputSize = 0;\n        \n        for (int i = 0; i < resultSize; i++) {\n            Point p1 = input[i];\n            Point p2 = input[(i + 1) % resultSize];\n            \n            int inside1 = (b.x - a.x) * (p1.y - a.y) > (b.y - a.y) * (p1.x - a.x);\n            int inside2 = (b.x - a.x) * (p2.y - a.y) > (b.y - a.y) * (p2.x - a.x);\n            \n            if (inside1 && inside2) {\n                output[outputSize++] = p2;\n            } else if (inside1) {\n                output[outputSize++] = computeIntersection(a, b, p1, p2);\n            } else if (inside2) {\n                output[outputSize++] = computeIntersection(a, b, p1, p2);\n                output[outputSize++] = p2;\n            }\n        }\n        \n        free(input);\n        input = output;\n        resultSize = outputSize;\n    }\n    \n    for (int i = 0; i < resultSize; i++) result[i] = input[i];\n    free(input);\n    return resultSize;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1 && n >= 3) {\n        Point *window = (Point *)malloc(n * sizeof(Point));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d\", &window[i].x, &window[i].y);\n        }\n        \n        Rect curtains;\n        scanf(\"%d %d %d %d\", &curtains.p1.x, &curtains.p1.y, &curtains.p2.x, &curtains.p2.y);\n        \n        Point *clipped = (Point *)malloc(n * 4 * sizeof(Point));\n        int clippedSize = clipPolygon(window, n, curtains, clipped);\n        \n        int windowArea = areaPolygon(window, n);\n        int clippedArea = clippedSize ? areaPolygon(clipped, clippedSize) : 0;\n        \n        printf(\"%d\\n\", windowArea - clippedArea);\n        \n        free(window);\n        free(clipped);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:57:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    Point(int x = 0, int y = 0) : x(x), y(y) {}\n};\n\nint cross(const Point &O, const Point &A, const Point &B) {\n    return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);\n}\n\nvector<Point> convexHull(vector<Point> P) {\n    int n = P.size(), k = 0;\n    vector<Point> H(2 * n);\n    sort(P.begin(), P.end(), [](const Point &a, const Point &b) {\n        return a.x < b.x || (a.x == b.x && a.y < b.y);\n    });\n    for (int i = 0; i < n; ++i) {\n        while (k >= 2 && cross(H[k-2], H[k-1], P[i]) <= 0) k--;\n        H[k++] = P[i];\n    }\n    for (int i = n-2, t = k+1; i >= 0; --i) {\n        while (k >= t && cross(H[k-2], H[k-1], P[i]) <= 0) k--;\n        H[k++] = P[i];\n    }\n    H.resize(k-1);\n    return H;\n}\n\nint polygonArea(const vector<Point> &polygon) {\n    int area = 0;\n    int n = polygon.size();\n    for (int i = 0; i < n; ++i) {\n        int j = (i + 1) % n;\n        area += polygon[i].x * polygon[j].y;\n        area -= polygon[i].y * polygon[j].x;\n    }\n    return abs(area) / 2;\n}\n\nvector<Point> clip(const vector<Point> &polygon, const Point &p1, const Point &p2) {\n    vector<Point> result;\n    int n = polygon.size();\n    for (int i = 0; i < n; ++i) {\n        int j = (i + 1) % n;\n        Point vi = polygon[i];\n        Point vj = polygon[j];\n        int d1 = cross(p1, p2, vi);\n        int d2 = cross(p1, p2, vj);\n        if (d1 >= 0) result.push_back(vi);\n        if (d1 * d2 < 0) {\n            Point intersection;\n            int den = (p2.x - p1.x) * (vj.y - vi.y) - (p2.y - p1.y) * (vj.x - vi.x);\n            if (den != 0) {\n                double t = (double)((p2.x - p1.x) * (vi.y - p1.y) - (p2.y - p1.y) * (vi.x - p1.x)) / den;\n                intersection.x = vi.x + t * (vj.x - vi.x);\n                intersection.y = vi.y + t * (vj.y - vi.y);\n                result.push_back(intersection);\n            }\n        }\n    }\n    return result;\n}\n\nvector<Point> sutherlandHodgman(const vector<Point> &polygon, const vector<Point> &clipPolygon) {\n    vector<Point> result = polygon;\n    int n = clipPolygon.size();\n    for (int i = 0; i < n; ++i) {\n        int j = (i + 1) % n;\n        result = clip(result, clipPolygon[i], clipPolygon[j]);\n        if (result.empty()) break;\n    }\n    return result;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    while (cin >> n && n != 0) {\n        vector<Point> window(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> window[i].x >> window[i].y;\n        }\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        vector<Point> curtain = {\n            {min(x1, x2), min(y1, y2)},\n            {max(x1, x2), min(y1, y2)},\n            {max(x1, x2), max(y1, y2)},\n            {min(x1, x2), max(y1, y2)}\n        };\n        int windowArea = polygonArea(window);\n        vector<Point> clipped = sutherlandHodgman(window, curtain);\n        int coveredArea = clipped.empty() ? 0 : polygonArea(clipped);\n        cout << windowArea - coveredArea << '\\n';\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:58:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.awt.geom.Path2D;\nimport java.awt.geom.Area;\nimport java.awt.geom.Rectangle2D;\nimport java.util.Scanner;\n\npublic class WindowArea {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            int n = scanner.nextInt();\n            double[] xPoints = new double[n];\n            double[] yPoints = new double[n];\n            for (int i = 0; i < n; i++) {\n                xPoints[i] = scanner.nextDouble();\n                yPoints[i] = scanner.nextDouble();\n            }\n            double x1 = scanner.nextDouble();\n            double y1 = scanner.nextDouble();\n            double x2 = scanner.nextDouble();\n            double y2 = scanner.nextDouble();\n\n            Path2D.Double windowPath = new Path2D.Double();\n            windowPath.moveTo(xPoints[0], yPoints[0]);\n            for (int i = 1; i < n; i++) {\n                windowPath.lineTo(xPoints[i], yPoints[i]);\n            }\n            windowPath.closePath();\n            Area windowArea = new Area(windowPath);\n\n            Rectangle2D.Double curtainRect = new Rectangle2D.Double(\n                Math.min(x1, x2), Math.min(y1, y2),\n                Math.abs(x2 - x1), Math.abs(y2 - y1));\n            Area curtainArea = new Area(curtainRect);\n\n            windowArea.subtract(curtainArea);\n            System.out.println((int) Math.round(computeArea(windowArea)));\n        }\n        scanner.close();\n    }\n\n    private static double computeArea(Area area) {\n        double totalArea = 0;\n        Path2D.Float path = new Path2D.Float();\n        path.append(area.getPathIterator(null), false);\n        double[] coords = new double[6];\n        double startX = 0, startY = 0;\n        double prevX = 0, prevY = 0;\n        while (!path.getPathIterator(null).isDone()) {\n            int type = path.getPathIterator(null).currentSegment(coords);\n            if (type == Path2D.SEG_MOVETO) {\n                startX = coords[0];\n                startY = coords[1];\n                prevX = startX;\n                prevY = startY;\n            } else if (type == Path2D.SEG_LINETO) {\n                totalArea += prevX * coords[1] - prevY * coords[0];\n                prevX = coords[0];\n                prevY = coords[1];\n            } else if (type == Path2D.SEG_CLOSE) {\n                totalArea += prevX * startY - prevY * startX;\n            }\n            path.getPathIterator(null).next();\n        }\n        return Math.abs(totalArea) / 2.0;\n    }\n}",
    "timestamp": "2025-08-05 21:59:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class WindowArea {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static double polygonArea(Point[] polygon) {\n        int n = polygon.length;\n        double area = 0.0;\n        for (int i = 0; i < n; i++) {\n            int j = (i + 1) % n;\n            area += polygon[i].x * polygon[j].y - polygon[j].x * polygon[i].y;\n        }\n        return Math.abs(area) / 2.0;\n    }\n\n    static Point[] intersection(Point[] polygon, Point[] rectangle) {\n        List<Point> intersectionPoints = new ArrayList<>();\n        for (int i = 0; i < polygon.length; i++) {\n            for (int j = 0; j < rectangle.length; j++) {\n                Point intersect = lineIntersection(polygon[i], polygon[(i+1)%polygon.length], \n                                                   rectangle[j], rectangle[(j+1)%rectangle.length]);\n                if (intersect != null) {\n                    intersectionPoints.add(intersect);\n                }\n            }\n        }\n        return intersectionPoints.toArray(new Point[0]);\n    }\n\n    static Point lineIntersection(Point p1, Point p2, Point p3, Point p4) {\n        double x1 = p1.x, y1 = p1.y;\n        double x2 = p2.x, y2 = p2.y;\n        double x3 = p3.x, y3 = p3.y;\n        double x4 = p4.x, y4 = p4.y;\n\n        double denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n        if (denom == 0) return null;\n\n        double ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;\n        double ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;\n\n        if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n            double x = x1 + ua * (x2 - x1);\n            double y = y1 + ua * (y2 - y1);\n            return new Point(x, y);\n        }\n        return null;\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int datasets = Integer.parseInt(br.readLine());\n\n        for (int dataset = 0; dataset < datasets; dataset++) {\n            int n = Integer.parseInt(br.readLine());\n            Point[] window = new Point[n];\n\n            for (int i = 0; i < n; i++) {\n                String[] coords = br.readLine().split(\" \");\n                window[i] = new Point(Double.parseDouble(coords[0]), Double.parseDouble(coords[1]));\n            }\n\n            Point[] rectangle = new Point[4];\n            for (int i = 0; i < 4; i++) {\n                String[] coords = br.readLine().split(\" \");\n                rectangle[i] = new Point(Double.parseDouble(coords[0]), Double.parseDouble(coords[1]));\n            }\n\n            double windowArea = polygonArea(window);\n            Point[] intersectionPoints = intersection(window, rectangle);\n\n            if (intersectionPoints.length > 0) {\n                double coverageArea = polygonArea(intersectionPoints);\n                System.out.println((int)(windowArea - coverageArea));\n            } else {\n                System.out.println((int)windowArea);\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:59:13"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n};\n\ndouble cross(const Point& o, const Point& a, const Point& b) {\n    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);\n}\n\ndouble polygonArea(const vector<Point>& polygon) {\n    int n = polygon.size();\n    double area = 0.0;\n    for (int i = 1; i < n - 1; ++i) {\n        area += cross(polygon[0], polygon[i], polygon[i + 1]);\n    }\n    return abs(area) / 2.0;\n}\n\nbool pointInRectangle(const Point& p, const vector<Point>& rect) {\n    double minX = min({rect[0].x, rect[1].x, rect[2].x, rect[3].x});\n    double maxX = max({rect[0].x, rect[1].x, rect[2].x, rect[3].x});\n    double minY = min({rect[0].y, rect[1].y, rect[2].y, rect[3].y});\n    double maxY = max({rect[0].y, rect[1].y, rect[2].y, rect[3].y});\n    \n    return p.x >= minX && p.x <= maxX && p.y >= minY && p.y <= maxY;\n}\n\nbool lineIntersectRectangle(const Point& a, const Point& b, const vector<Point>& rect) {\n    vector<Point> lines = {\n        {rect[0].x, rect[0].y}, {rect[1].x, rect[1].y},\n        {rect[1].x, rect[1].y}, {rect[2].x, rect[2].y},\n        {rect[2].x, rect[2].y}, {rect[3].x, rect[3].y},\n        {rect[3].x, rect[3].y}, {rect[0].x, rect[0].y}\n    };\n\n    for (int i = 0; i < 4; ++i) {\n        if (doLinesIntersect(a, b, lines[i * 2], lines[i * 2 + 1]))\n            return true;\n    }\n    return false;\n}\n\nbool doLinesIntersect(const Point& a, const Point& b, const Point& c, const Point& d) {\n    double crossA = cross(c, d, a);\n    double crossB = cross(c, d, b);\n    double crossC = cross(a, b, c);\n    double crossD = cross(a, b, d);\n\n    return (crossA * crossB < 0) && (crossC * crossD < 0);\n}\n\nvector<Point> clipPolygon(const vector<Point>& polygon, const vector<Point>& rectangle) {\n    vector<Point> result;\n    for (const Point& p : polygon) {\n        if (!pointInRectangle(p, rectangle)) {\n            result.push_back(p);\n        }\n    }\n\n    for (int i = 0; i < polygon.size(); ++i) {\n        Point a = polygon[i];\n        Point b = polygon[(i + 1) % polygon.size()];\n        if (!lineIntersectRectangle(a, b, rectangle)) {\n            result.push_back(a);\n            result.push_back(b);\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    int datasets;\n    cin >> datasets;\n\n    for (int dataset = 1; dataset <= datasets; ++dataset) {\n        int windowVertices;\n        cin >> windowVertices;\n\n        vector<Point> window(windowVertices);\n        for (int i = 0; i < windowVertices; ++i) {\n            cin >> window[i].x >> window[i].y;\n        }\n\n        vector<Point> rectangle(4);\n        for (int i = 0; i < 4; ++i) {\n            cin >> rectangle[i].x >> rectangle[i].y;\n        }\n\n        double originalArea = polygonArea(window);\n        vector<Point> uncoveredPolygon = clipPolygon(window, rectangle);\n        double uncoveredArea = polygonArea(uncoveredPolygon);\n\n        cout << \"Dataset \" << dataset << \": \" << round(uncoveredArea) << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:59:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from shapely.geometry import Polygon, box\n\ndef calculate_uncovered_area(window_vertices, curtain_vertices):\n    window_polygon = Polygon(window_vertices)\n    curtain_polygon = box(*curtain_vertices)\n    \n    uncovered_polygon = window_polygon.difference(curtain_polygon)\n    \n    return int(uncovered_polygon.area)\n\ndef parse_input(input_data):\n    datasets = []\n    lines = input_data.strip().split('\\n')\n    \n    i = 0\n    while i < len(lines):\n        vertex_count = int(lines[i].strip())\n        \n        window_vertices = []\n        for j in range(vertex_count):\n            x, y = map(int, lines[i + 1 + j].strip().split())\n            window_vertices.append((x, y))\n        \n        curtain_vertices = tuple(map(int, lines[i + 1 + vertex_count].strip().split()))\n        \n        datasets.append((window_vertices, curtain_vertices))\n        i += vertex_count + 2\n    \n    return datasets\n\ndef main(input_data):\n    datasets = parse_input(input_data)\n    results = []\n    for window_vertices, curtain_vertices in datasets:\n        uncovered_area = calculate_uncovered_area(window_vertices, curtain_vertices)\n        results.append(uncovered_area)\n    \n    for result in results:\n        print(result)\n\n# Example Usage\n# input_data = \"\" # Input data should be provided here\n# main(input_data)",
    "timestamp": "2025-08-13 08:14:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.awt.Polygon;\nimport java.awt.Rectangle;\nimport java.awt.geom.Area;\nimport java.util.Scanner;\n\npublic class UncoveredWindowArea {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int datasets = scanner.nextInt();\n\n        for (int i = 0; i < datasets; i++) {\n            int windowVertices = scanner.nextInt();\n            int[] xPoints = new int[windowVertices];\n            int[] yPoints = new int[windowVertices];\n\n            for (int j = 0; j < windowVertices; j++) {\n                xPoints[j] = scanner.nextInt();\n                yPoints[j] = scanner.nextInt();\n            }\n\n            Polygon windowPolygon = new Polygon(xPoints, yPoints, windowVertices);\n\n            int curtainX1 = scanner.nextInt();\n            int curtainY1 = scanner.nextInt();\n            int curtainX2 = scanner.nextInt();\n            int curtainY2 = scanner.nextInt();\n\n            Rectangle curtainRectangle = new Rectangle(\n                Math.min(curtainX1, curtainX2),\n                Math.min(curtainY1, curtainY2),\n                Math.abs(curtainX2 - curtainX1),\n                Math.abs(curtainY2 - curtainY1)\n            );\n\n            Area windowArea = new Area(windowPolygon);\n            Area curtainArea = new Area(curtainRectangle);\n\n            windowArea.subtract(curtainArea);\n\n            System.out.println((int)Math.round(getArea(windowArea)));\n        }\n        scanner.close();\n    }\n\n    private static double getArea(Area area) {\n        double totalArea = 0.0;\n        double[] coords = new double[6];\n        for (java.awt.geom.PathIterator pi = area.getPathIterator(null); !pi.isDone(); pi.next()) {\n            int type = pi.currentSegment(coords);\n            if (type != java.awt.geom.PathIterator.SEG_LINETO && type != java.awt.geom.PathIterator.SEG_CLOSE) {\n                continue;\n            }\n            totalArea += coords[0] * coords[3] - coords[1] * coords[2];\n        }\n        return Math.abs(totalArea / 2.0);\n    }\n}",
    "timestamp": "2025-08-13 08:14:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    Point p1, p2;\n} Rectangle;\n\nint orientation(Point p, Point q, Point r) {\n    int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    if (val == 0)\n        return 0;\n    return (val > 0) ? 1 : 2;\n}\n\nint onSegment(Point p, Point q, Point r) {\n    if (q.x <= fmax(p.x, r.x) && q.x >= fmin(p.x, r.x) &&\n        q.y <= fmax(p.y, r.y) && q.y >= fmin(p.y, r.y))\n        return 1;\n    return 0;\n}\n\nint doIntersect(Point p1, Point q1, Point p2, Point q2) {\n    int o1 = orientation(p1, q1, p2);\n    int o2 = orientation(p1, q1, q2);\n    int o3 = orientation(p2, q2, p1);\n    int o4 = orientation(p2, q2, q1);\n    if (o1 != o2 && o3 != o4)\n        return 1;\n    if (o1 == 0 && onSegment(p1, p2, q1))\n        return 1;\n    if (o2 == 0 && onSegment(p1, q2, q1))\n        return 1;\n    if (o3 == 0 && onSegment(p2, p1, q2))\n        return 1;\n    if (o4 == 0 && onSegment(p2, q1, q2))\n        return 1;\n    return 0;\n}\n\nint isInside(Point polygon[], int n, Point p) {\n    if (n < 3)\n        return 0;\n    Point extreme = {10000, p.y};\n    int count = 0, i = 0;\n    do {\n        int next = (i + 1) % n;\n        if (doIntersect(polygon[i], polygon[next], p, extreme)) {\n            if (orientation(polygon[i], p, polygon[next]) == 0)\n                return onSegment(polygon[i], p, polygon[next]);\n            count++;\n        }\n        i = next;\n    } while (i != 0);\n    return count & 1;\n}\n\nint rectArea(Rectangle r) {\n    return abs((r.p2.x - r.p1.x) * (r.p2.y - r.p1.y));\n}\n\nint polygonArea(Point polygon[], int n) {\n    int area = 0;\n    int j = n - 1;\n    for (int i = 0; i < n; i++) {\n        area += (polygon[j].x + polygon[i].x) * (polygon[j].y - polygon[i].y);\n        j = i;\n    }\n    return abs(area / 2);\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        int n;\n        scanf(\"%d\", &n);\n        Point window[n];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d\", &window[i].x, &window[i].y);\n        }\n        Rectangle curtain;\n        scanf(\"%d %d %d %d\", &curtain.p1.x, &curtain.p1.y, &curtain.p2.x, &curtain.p2.y);\n        Point rectPolygon[4] = {\n            curtain.p1,\n            {curtain.p2.x, curtain.p1.y},\n            curtain.p2,\n            {curtain.p1.x, curtain.p2.y}\n        };\n\n        int window_area = polygonArea(window, n);\n        int curtain_area = 0;\n\n        for (int i = 0; i < 4; i++) {\n            if (isInside(window, n, rectPolygon[i])) {\n                curtain_area = rectArea(curtain);\n                break;\n            }\n        }\n\n        printf(\"%d\\n\", window_area - curtain_area);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 08:15:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate_polygon_area(vertices):\n    n = len(vertices)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += vertices[i][0] * vertices[j][1]\n        area -= vertices[j][0] * vertices[i][1]\n    area = abs(area) / 2.0\n    return area\n\ndef is_point_inside_rectangle(point, rect_vertices):\n    x, y = point\n    x1, y1 = rect_vertices[0]\n    x2, y2 = rect_vertices[2]\n    return min(x1, x2) <= x <= max(x1, x2) and min(y1, y2) <= y <= max(y1, y2)\n\ndef polygon_intersection_area(polygon_vertices, rect_vertices):\n    # Compute convex hull of intersection points\n    intersection_vertices = []\n    \n    # Check polygon vertices inside rectangle\n    for vertex in polygon_vertices:\n        if is_point_inside_rectangle(vertex, rect_vertices):\n            intersection_vertices.append(vertex)\n    \n    # Check rectangle vertices inside polygon\n    def point_in_polygon(point):\n        x, y = point\n        inside = False\n        j = len(polygon_vertices) - 1\n        for i in range(len(polygon_vertices)):\n            xi, yi = polygon_vertices[i]\n            xj, yj = polygon_vertices[j]\n            intersect = ((yi > y) != (yj > y)) and (x < (xj - xi) * (y - yi) / (yj - yi) + xi)\n            if intersect:\n                inside = not inside\n            j = i\n        return inside\n    \n    for vertex in rect_vertices:\n        if point_in_polygon(vertex):\n            intersection_vertices.append(vertex)\n    \n    # Add intersection points of polygon and rectangle edges\n    def line_intersection(line1, line2):\n        x1, y1 = line1[0]\n        x2, y2 = line1[1]\n        x3, y3 = line2[0]\n        x4, y4 = line2[1]\n        \n        denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)\n        if denom == 0:\n            return None\n        \n        ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom\n        ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom\n        \n        if 0 <= ua <= 1 and 0 <= ub <= 1:\n            x = x1 + ua * (x2 - x1)\n            y = y1 + ua * (y2 - y1)\n            return (x, y)\n        return None\n    \n    polygon_edges = [(polygon_vertices[i], polygon_vertices[(i+1)%len(polygon_vertices)]) for i in range(len(polygon_vertices))]\n    rect_edges = [(rect_vertices[i], rect_vertices[(i+1)%len(rect_vertices)]) for i in range(len(rect_vertices))]\n    \n    for p_edge in polygon_edges:\n        for r_edge in rect_edges:\n            intersect = line_intersection(p_edge, r_edge)\n            if intersect:\n                intersection_vertices.append(intersect)\n    \n    # Remove duplicate points\n    intersection_vertices = list(set(intersection_vertices))\n    \n    # Sort vertices to form convex hull\n    def cross_product(o, a, b):\n        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n    \n    def convex_hull(points):\n        points = sorted(set(points))\n        lower = []\n        for p in points:\n            while len(lower) >= 2 and cross_product(lower[-2], lower[-1], p) <= 0:\n                lower.pop()\n            lower.append(p)\n        \n        upper = []\n        for p in reversed(points):\n            while len(upper) >= 2 and cross_product(upper[-2], upper[-1], p) <= 0:\n                upper.pop()\n            upper.append(p)\n        \n        return lower[:-1] + upper[:-1]\n    \n    if len(intersection_vertices) < 3:\n        return 0\n    \n    hull_vertices = convex_hull(intersection_vertices)\n    \n    if len(hull_vertices) < 3:\n        return 0\n    \n    return calculate_polygon_area(hull_vertices)\n\ndef main():\n    datasets = int(input())\n    \n    for _ in range(datasets):\n        # Window vertices\n        n = int(input())\n        window_vertices = []\n        for _ in range(n):\n            x, y = map(int, input().split())\n            window_vertices.append((x, y))\n        \n        # Curtain rectangle vertices\n        rect_vertices = []\n        for _ in range(4):\n            x, y = map(int, input().split())\n            rect_vertices.append((x, y))\n        \n        # Calculate uncovered area\n        window_area = calculate_polygon_area(window_vertices)\n        covered_area = polygon_intersection_area(window_vertices, rect_vertices)\n        uncovered_area = int(window_area - covered_area)\n        \n        print(uncovered_area)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 08:15:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom itertools import tee\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef pairwise(iterable):\n    a, b = tee(iterable)\n    next(b, None)\n    return zip(a, b)\n\ndef point_on_segment(a, b, c):\n    cross = (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])\n    if abs(cross) != 0:\n        return False\n    min_x = min(a[0], b[0])\n    max_x = max(a[0], b[0])\n    min_y = min(a[1], b[1])\n    max_y = max(a[1], b[1])\n    return (c[0] >= min_x and c[0] <= max_x) and (c[1] >= min_y and c[1] <= max_y)\n\ndef segments_intersect(a1, a2, b1, b2):\n    d1 = (b2[0] - b1[0]) * (a1[1] - b1[1]) - (b2[1] - b1[1]) * (a1[0] - b1[0])\n    d2 = (b2[0] - b1[0]) * (a2[1] - b1[1]) - (b2[1] - b1[1]) * (a2[0] - b1[0])\n    d3 = (a2[0] - a1[0]) * (b1[1] - a1[1]) - (a2[1] - a1[1]) * (b1[0] - a1[0])\n    d4 = (a2[0] - a1[0]) * (b2[1] - a1[1]) - (a2[1] - a1[1]) * (b2[0] - a1[0])\n    \n    if ((d1 > 0 and d2 < 0) or (d1 < 0 and d2 > 0)) and ((d3 > 0 and d4 < 0) or (d3 < 0 and d4 > 0)):\n        return True\n    if point_on_segment(a1, a2, b1) or point_on_segment(a1, a2, b2) or point_on_segment(b1, b2, a1) or point_on_segment(b1, b2, a2):\n        return True\n    return False\n\ndef point_in_polygon(polygon, point):\n    x, y = point\n    n = len(polygon)\n    inside = False\n    p1x, p1y = polygon[0]\n    for i in range(n + 1):\n        p2x, p2y = polygon[i % n]\n        if y > min(p1y, p2y):\n            if y <= max(p1y, p2y):\n                if x <= max(p1x, p2x):\n                    if p1y != p2y:\n                        xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\n                    if p1x == p2x or x <= xinters:\n                        inside = not inside\n        p1x, p1y = p2x, p2y\n    return inside\n\ndef polygon_area(polygon):\n    area = 0.0\n    n = len(polygon)\n    for i in range(n):\n        x_i, y_i = polygon[i]\n        x_j, y_j = polygon[(i + 1) % n]\n        area += (x_i * y_j) - (x_j * y_i)\n    return abs(area) / 2\n\ndef clip_polygon(subject_polygon, clip_polygon):\n    output = subject_polygon.copy()\n    n = len(clip_polygon)\n    \n    for i in range(n):\n        clip_edge_start = clip_polygon[i]\n        clip_edge_end = clip_polygon[(i + 1) % n]\n        input_list = output.copy()\n        output = []\n        if not input_list:\n            break\n        s = input_list[-1]\n        \n        for e in input_list:\n            if is_inside(e, clip_edge_start, clip_edge_end):\n                if not is_inside(s, clip_edge_start, clip_edge_end):\n                    intersection = compute_intersection(s, e, clip_edge_start, clip_edge_end)\n                    output.append(intersection)\n                output.append(e)\n            elif is_inside(s, clip_edge_start, clip_edge_end):\n                intersection = compute_intersection(s, e, clip_edge_start, clip_edge_end)\n                output.append(intersection)\n            s = e\n    return output\n\ndef is_inside(p, edge_start, edge_end):\n    return (edge_end[0] - edge_start[0]) * (p[1] - edge_start[1]) > (edge_end[1] - edge_start[1]) * (p[0] - edge_start[0])\n\ndef compute_intersection(s, e, edge_start, edge_end):\n    dc = (edge_start[0] - edge_end[0], edge_start[1] - edge_end[1])\n    dp = (s[0] - e[0], s[1] - e[1])\n    n1 = edge_start[0] * edge_end[1] - edge_start[1] * edge_end[0]\n    n2 = s[0] * e[1] - s[1] * e[0]\n    n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0])\n    x = (n1 * dp[0] - n2 * dc[0]) * n3\n    y = (n1 * dp[1] - n2 * dc[1]) * n3\n    return (x, y)\n\ndef main():\n    while True:\n        line = sys.stdin.readline()\n        if not line:\n            break\n        n = int(line.strip())\n        if n == 0:\n            break\n        window = []\n        for _ in range(n):\n            x, y = readints()\n            window.append((x, y))\n        curtain = []\n        coords = readints()\n        for i in range(0, len(coords), 2):\n            x, y = coords[i], coords[i + 1]\n            curtain.append((x, y))\n        \n        clipped = clip_polygon(window, curtain)\n        area = polygon_area(clipped)\n        print(int(round(area)))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 08:16:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n};\n\ndouble crossProduct(Point p1, Point p2, Point p3) {\n    return (p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y);\n}\n\nbool onSameSide(Point p1, Point p2, Point a, Point b) {\n    return (crossProduct(a, b, p1) * crossProduct(a, b, p2)) >= 0;\n}\n\nbool pointInRectangle(Point p, Point topLeft, Point bottomRight) {\n    return (p.x >= topLeft.x && p.x <= bottomRight.x && p.y >= bottomRight.y && p.y <= topLeft.y);\n}\n\nint pointOrientation(Point a, Point b, Point c) {\n    double value = crossProduct(a, b, c);\n    if (value == 0) return 0;\n    return (value > 0) ? 1 : -1;\n}\n\nbool isIntersecting(Point p1, Point q1, Point p2, Point q2) {\n    int o1 = pointOrientation(p1, q1, p2);\n    int o2 = pointOrientation(p1, q1, q2);\n    int o3 = pointOrientation(p2, q2, p1);\n    int o4 = pointOrientation(p2, q2, q1);\n    if (o1 != o2 && o3 != o4) return true;\n    return (o1 == 0 && pointInRectangle(p2, p1, q1)) || (o2 == 0 && pointInRectangle(q2, p1, q1)) ||\n           (o3 == 0 && pointInRectangle(p1, p2, q2)) || (o4 == 0 && pointInRectangle(q1, p2, q2));\n}\n\ndouble polygonArea(vector<Point> &vertices) {\n    double area = 0;\n    int n = vertices.size();\n    for (int i = 1; i < n - 1; i++) {\n        area += crossProduct(vertices[0], vertices[i], vertices[i + 1]);\n    }\n    return abs(area) / 2.0;\n}\n\ndouble clipPolygonArea(vector<Point> &polygon, Point topLeft, Point bottomRight) {\n    vector<Point> clippedPolygon;\n    vector<Point> rect = {topLeft, {bottomRight.x, topLeft.y}, bottomRight, {topLeft.x, bottomRight.y}};\n    \n    for (int i = 0; i < polygon.size(); ++i) {\n        Point p1 = polygon[i];\n        Point p2 = polygon[(i + 1) % polygon.size()];\n        \n        for (int j = 0; j < 4; ++j) {\n            Point q1 = rect[j];\n            Point q2 = rect[(j + 1) % 4];\n            \n            if (isIntersecting(p1, p2, q1, q2)) {\n                return polygonArea(polygon); // Simple clipping, returns max possible area in case of intersection\n            }\n        }\n    }\n    \n    // Check if polygon completely inside rectangle\n    if (all_of(polygon.begin(), polygon.end(), [&](Point p) { return pointInRectangle(p, topLeft, bottomRight); })) {\n        return 0;\n    }\n    \n    return polygonArea(polygon);\n}\n\nint main() {\n    int datasets;\n    cin >> datasets;\n    \n    while (datasets--) {\n        int n;\n        cin >> n;\n        vector<Point> polygon(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> polygon[i].x >> polygon[i].y;\n        }\n        \n        Point topLeft, bottomRight;\n        cin >> topLeft.x >> topLeft.y >> bottomRight.x >> bottomRight.y;\n        \n        double windowArea = polygonArea(polygon);\n        double coveredArea = clipPolygonArea(polygon, topLeft, bottomRight);\n        \n        int uncoveredArea = static_cast<int>(windowArea - coveredArea + 0.5);\n        cout << uncoveredArea << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:44:29"
  }
]